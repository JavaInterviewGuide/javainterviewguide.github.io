<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker</title>
    <url>/publishes/52555cb3db5d.html</url>
    <content><![CDATA[<h1 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h1><ul>
<li>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</li>
<li>容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li>
<li>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</li>
<li>容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li>
<li>容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</li>
</ul>
<h1 id="物理机、虚拟机与容器"><a href="#物理机、虚拟机与容器" class="headerlink" title="物理机、虚拟机与容器"></a>物理机、虚拟机与容器</h1><ul>
<li>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的</li>
<li>虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统</li>
<li>因此容器的隔离级别会稍低一些。</li>
</ul>
<h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><ul>
<li>Docker是世界领先的软件容器平台。</li>
<li>Docker使用Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li>
<li>由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器</li>
<li>Docke最初实现是基于LXC。</li>
<li>Docker能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</li>
<li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li>
</ul>
<h1 id="Docker思想"><a href="#Docker思想" class="headerlink" title="Docker思想"></a>Docker思想</h1><ul>
<li>集装箱</li>
<li>标准化： ①运输方式、②存储方式、 ③API接口</li>
<li>隔离</li>
</ul>
<h1 id="Docker容器的特点"><a href="#Docker容器的特点" class="headerlink" title="Docker容器的特点"></a>Docker容器的特点</h1><ul>
<li>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li>
<li>标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</li>
<li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li>
</ul>
<h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><ul>
<li>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境</li>
<li>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</li>
<li>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</li>
<li>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</li>
<li>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</li>
<li>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</li>
</ul>
<h1 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h1><ul>
<li>简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</li>
<li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</li>
<li>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。</li>
<li>虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。</li>
</ul>
<h1 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h1><ul>
<li>Docker包括三个基本概念：<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
</li>
</ul>
<h4 id="镜像（Image）——一个特殊的文件系统"><a href="#镜像（Image）——一个特殊的文件系统" class="headerlink" title="镜像（Image）——一个特殊的文件系统"></a>镜像（Image）——一个特殊的文件系统</h4><ul>
<li>操作系统分为内核和用户空间</li>
<li>对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持</li>
<li>而Docker镜像（Image），就相当于是一个root文件系统。</li>
<li>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</li>
<li>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li>
<li>Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。</li>
<li>镜像实际是由多层文件系统联合组成。</li>
<li>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</li>
<li>分层存储的特征还使得镜像的复用、定制变的更为容易</li>
<li>甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</li>
</ul>
<h4 id="容器（Container）——镜像运行时的实体"><a href="#容器（Container）——镜像运行时的实体" class="headerlink" title="容器（Container）——镜像运行时的实体"></a>容器（Container）——镜像运行时的实体</h4><ul>
<li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</li>
<li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</li>
<li>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</li>
<li>按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li>
</ul>
<h4 id="仓库（Repository）——集中存放镜像文件的地方"><a href="#仓库（Repository）——集中存放镜像文件的地方" class="headerlink" title="仓库（Repository）——集中存放镜像文件的地方"></a>仓库（Repository）——集中存放镜像文件的地方</h4><ul>
<li>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</li>
<li>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</li>
<li>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。</li>
<li>这里补充一下Docker Registry公开服务和私有Docker Registry的概念：<ul>
<li>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub，这也是默认的Registry，并拥有大量的高质量的官方镜像。</li>
<li>除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</li>
</ul>
</li>
</ul>
<h1 id="Build，Ship，and-Run"><a href="#Build，Ship，and-Run" class="headerlink" title="Build，Ship，and Run"></a>Build，Ship，and Run</h1><ul>
<li>Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。</li>
<li>Ship（运输镜像）：主机和仓库间运输，这里的仓库就像是超级码头一样。</li>
<li>Run （运行镜像）：运行的镜像就是一个容器，容器就是运行程序的地方。</li>
<li>Docker运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。</li>
</ul>
<h1 id="Docker-的目的是什么？"><a href="#Docker-的目的是什么？" class="headerlink" title="Docker 的目的是什么？"></a>Docker 的目的是什么？</h1><ul>
<li>Docker 提供了一个可用于托管任何应用程序的容器环境。在此，软件应用程序和支持它的依赖项紧密打包在一起。</li>
<li>因此，这个打包的产品被称为 Container，因为它是由 Docker 完成的，所以它被称为 Docker 容器！</li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/publishes/b9efb3c36627.html</url>
    <content><![CDATA[<h1 id="Dubbo是什么？"><a href="#Dubbo是什么？" class="headerlink" title="Dubbo是什么？"></a>Dubbo是什么？</h1><ul>
<li>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案</li>
<li>简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）</li>
<li>其核心部分包含:<ul>
<li>远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>
<li>集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
<li>自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>
</ul>
</li>
</ul>
<h1 id="Dubbo能做什么？"><a href="#Dubbo能做什么？" class="headerlink" title="Dubbo能做什么？"></a>Dubbo能做什么？</h1><ul>
<li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li>
<li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li>
<li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li>
<li>Dubbo采用全spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。</li>
<li>之前使用Web Service，我想测试接口可以通过模拟消息的方式通过soapui或LR进行功能测试或性能测试。但现在使用Dubbo，接口之间不能直接交互，我尝试通过模拟消费者地址测试，结果不堪入目，再而使用jmeter通过junit进行测试，但还是需要往dubbo上去注册，如果再不给提供源代码的前提下，这个测试用例不好写啊….</li>
</ul>
<h1 id="dubbo的架构"><a href="#dubbo的架构" class="headerlink" title="dubbo的架构"></a>dubbo的架构</h1><ul>
<li>Provider: 暴露服务的服务提供方。</li>
<li>Consumer: 调用远程服务的服务消费方。</li>
<li>Registry: 服务注册与发现的注册中心。</li>
<li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li>
<li>Container: 服务运行容器。</li>
<li>这点我觉得非常好，角色分明，可以根据每个节点角色的状态来确定该服务是否正常。</li>
<li>调用关系说明：<ul>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
</li>
</ul>
<h1 id="Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么"><a href="#Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么" class="headerlink" title="Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么"></a>Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么</h1><ul>
<li>可以通信的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用；</li>
<li>注册中心对等集群，任意一台宕机后，将会切换到另一台；注册中心全部宕机后，服务的提供者和消费者仍能通过本地缓存通讯。服务提供者无状态，任一台 宕机后，不影响使用；服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复；</li>
<li>挂掉是不要紧的，但前提是你没有增加新的服务，如果你要调用新的服务，则是不能办到的。</li>
</ul>
<h1 id="dubbo服务负载均衡策略"><a href="#dubbo服务负载均衡策略" class="headerlink" title="dubbo服务负载均衡策略"></a>dubbo服务负载均衡策略</h1><ul>
<li>随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。(权重可以在dubbo管控台配置)</li>
<li>轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
<li>一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数Hash，如果要修改，请配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>缺省用160份虚拟节点，如果要修改，请配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Dubbo在安全机制方面是如何解决的"><a href="#Dubbo在安全机制方面是如何解决的" class="headerlink" title="Dubbo在安全机制方面是如何解决的"></a>Dubbo在安全机制方面是如何解决的</h1><ul>
<li>Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。</li>
</ul>
<h1 id="dubbo连接注册中心和直连的区别"><a href="#dubbo连接注册中心和直连的区别" class="headerlink" title="dubbo连接注册中心和直连的区别"></a>dubbo连接注册中心和直连的区别</h1><ul>
<li>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，<br>点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，</li>
<li>服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</li>
</ul>
<h1 id="dubbo服务集群配置（集群容错模式）"><a href="#dubbo服务集群配置（集群容错模式）" class="headerlink" title="dubbo服务集群配置（集群容错模式）"></a>dubbo服务集群配置（集群容错模式）</h1><ul>
<li>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。可以自行扩展集群容错策略</li>
</ul>
<h4 id="Failover-Cluster-默认"><a href="#Failover-Cluster-默认" class="headerlink" title="Failover Cluster(默认)"></a>Failover Cluster(默认)</h4><ul>
<li>失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过retries&#x3D;”2”来设置重试次数(不含第一次)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service retries=&quot;2&quot; cluster=&quot;failover&quot;/&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference retries=&quot;2&quot; cluster=&quot;failover&quot;/&gt;</span><br><span class="line">         cluster=&quot;failover&quot;可以不用写,因为默认就是failover</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Failfast-Cluster"><a href="#Failfast-Cluster" class="headerlink" title="Failfast Cluster"></a>Failfast Cluster</h4><ul>
<li>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dubbo:service cluster=&quot;failfast&quot; /&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference cluster=&quot;failfast&quot; /&gt;</span><br><span class="line">    cluster=&quot;failfast&quot;和 把cluster=&quot;failover&quot;、retries=&quot;0&quot;是一样的效果,retries=&quot;0&quot;就是不重试</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Failsafe-Cluster"><a href="#Failsafe-Cluster" class="headerlink" title="Failsafe Cluster"></a>Failsafe Cluster</h4><ul>
<li>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Failback-Cluster"><a href="#Failback-Cluster" class="headerlink" title="Failback Cluster"></a>Failback Cluster</h4><ul>
<li>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service cluster=&quot;failback&quot; /&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference cluster=&quot;failback&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Forking-Cluster"><a href="#Forking-Cluster" class="headerlink" title="Forking Cluster"></a>Forking Cluster</h4><ul>
<li>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks&#x3D;”2”来设置最大并行数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service cluster=“forking&quot; forks=&quot;2&quot;/&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference cluster=“forking&quot; forks=&quot;2&quot;/&gt;</span><br><span class="line">服务端服务级别</span><br><span class="line">　　　　&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">　　客户端服务级别</span><br><span class="line">　　　　&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">　　服务端方法级别　　　&lt;dubbo:service interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt; &lt;/dubbo:service&gt;</span><br><span class="line">客户端方法级别　        &lt;dubbo:reference interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt; &lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="dubbo通信协议dubbo协议为什么要消费者比提供者个数多："><a href="#dubbo通信协议dubbo协议为什么要消费者比提供者个数多：" class="headerlink" title="dubbo通信协议dubbo协议为什么要消费者比提供者个数多："></a>dubbo通信协议dubbo协议为什么要消费者比提供者个数多：</h1><ul>
<li>因dubbo协议采用单一长连接，假设网络为千兆网卡(1024Mbit&#x3D;128MByte)，根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，理论上1个服务提供者需要20个服务消费者才能压满网卡。</li>
</ul>
<h1 id="dubbo通信协议dubbo协议为什么不能传大包"><a href="#dubbo通信协议dubbo协议为什么不能传大包" class="headerlink" title="dubbo通信协议dubbo协议为什么不能传大包"></a>dubbo通信协议dubbo协议为什么不能传大包</h1><ul>
<li>因dubbo协议采用单一长连接，</li>
<li>如果每次请求的数据包大小为500KByte，假设网络为千兆网卡(1024Mbit&#x3D;128MByte)，每条连接最大7MByte(不同的环境可能不一样，供参考)，</li>
<li>单个服务提供者的TPS(每秒处理事务数)最大为：128MByte &#x2F; 500KByte &#x3D; 262。</li>
<li>单个消费者调用单个服务提供者的TPS(每秒处理事务数)最大为：7MByte &#x2F; 500KByte &#x3D; 14。</li>
<li>如果能接受，可以考虑使用，否则网络将成为瓶颈。</li>
</ul>
<h1 id="dubbo通信协议dubbo协议为什么采用异步单一长连接"><a href="#dubbo通信协议dubbo协议为什么采用异步单一长连接" class="headerlink" title="dubbo通信协议dubbo协议为什么采用异步单一长连接"></a>dubbo通信协议dubbo协议为什么采用异步单一长连接</h1><ul>
<li>因为服务的现状大都是服务提供者少，通常只有几台机器，</li>
<li>而服务的消费者多，可能整个网站都在访问该服务，</li>
<li>比如Morgan的提供者只有6台提供者，却有上百台消费者，每天有1.5亿次调用，</li>
<li>如果采用常规的hessian服务，服务提供者很容易就被压跨，</li>
<li>通过单一连接，保证单一消费者不会压死提供者，</li>
<li>长连接，减少连接握手验证等，</li>
<li>并使用异步IO，复用线程池，防止C10K问题。</li>
</ul>
<h1 id="dubbo通信协议dubbo协议适用范围和适用场景"><a href="#dubbo通信协议dubbo协议适用范围和适用场景" class="headerlink" title="dubbo通信协议dubbo协议适用范围和适用场景"></a>dubbo通信协议dubbo协议适用范围和适用场景</h1><ul>
<li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。</li>
<li>适用场景：常规远程服务方法调用</li>
<li>dubbo协议补充：<ul>
<li>连接个数：单连接</li>
<li>连接方式：长连接</li>
<li>传输协议：TCP</li>
<li>传输方式：NIO异步传输</li>
<li>序列化：Hessian二进制序列化</li>
</ul>
</li>
</ul>
<h1 id="RMI协议"><a href="#RMI协议" class="headerlink" title="RMI协议"></a>RMI协议</h1><ul>
<li>RMI协议采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式，Java标准的远程调用协议。</li>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：TCP</li>
<li>传输方式：同步传输</li>
<li>序列化：Java标准二进制序列化</li>
<li>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。</li>
<li>适用场景：常规远程服务方法调用，与原生RMI服务互操作</li>
</ul>
<h1 id="Hessian协议"><a href="#Hessian协议" class="headerlink" title="Hessian协议"></a>Hessian协议</h1><ul>
<li>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现</li>
<li>基于Hessian的远程调用协议。</li>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：Hessian二进制序列化</li>
<li>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</li>
<li>适用场景：页面传输，文件传输，或与原生hessian服务互操作</li>
</ul>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><ul>
<li>采用Spring的HttpInvoker实现</li>
<li>基于http表单的远程调用协议。</li>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：表单序列化（JSON）</li>
<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。</li>
<li>适用场景：需同时给应用程序和浏览器JS使用的服务。</li>
</ul>
<h1 id="Webservice"><a href="#Webservice" class="headerlink" title="Webservice"></a>Webservice</h1><ul>
<li>基于CXF的frontend-simple和transports-http实现</li>
<li>基于WebService的远程调用协议。</li>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：SOAP文本序列化</li>
<li>适用场景：系统集成，跨语言调用。</li>
</ul>
<h1 id="Thrif"><a href="#Thrif" class="headerlink" title="Thrif"></a>Thrif</h1><ul>
<li>Thrift是Facebook捐给Apache的一个RPC框架，当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如service name，magic number等</li>
</ul>
<h1 id="为什么要⽤Dubbo？"><a href="#为什么要⽤Dubbo？" class="headerlink" title="为什么要⽤Dubbo？"></a>为什么要⽤Dubbo？</h1><ul>
<li>因为是阿⾥开源项⽬，国内很多互联⽹公司都在⽤，已经经过很多线上考验。</li>
<li>内部使⽤了 Netty、Zookeeper，保证了⾼性能⾼可⽤性。</li>
<li>使⽤ Dubbo 可以将核⼼业务抽取出来，作为独⽴的服务，逐渐形成稳定的服务中⼼，可⽤于提⾼业务复⽤灵活扩展，使前端应⽤能更快速的响应多变的市场需求。</li>
<li>最重要的⼀点是，分布式架构可以承受更⼤规模的并发流量。</li>
</ul>
<h1 id="Dubbo-和-Spring-Cloud-有什么区别？"><a href="#Dubbo-和-Spring-Cloud-有什么区别？" class="headerlink" title="Dubbo 和 Spring Cloud 有什么区别？"></a>Dubbo 和 Spring Cloud 有什么区别？</h1><ul>
<li>两个没关联，如果硬要说区别，有以下⼏点。<ul>
<li><p>通信⽅式不同</p>
<ul>
<li>Dubbo 使⽤的是 RPC 通信，⽽ Spring Cloud 使⽤的是 HTTP RESTFul ⽅式。</li>
<li>dubbo由于是⼆进制的传输，占⽤带宽会更少（基于netty等）；springCloud是http协议传输，带宽会⽐较多，同时使⽤http协议（http+restful api）⼀般会使⽤JSON报⽂，消耗会更⼤。</li>
</ul>
</li>
<li><p>dubbo的开发难度较⼤，原因是dubbo的jar包依赖（存在代码级别的强依赖）问题很多⼤型⼯程⽆法解决；</p>
</li>
<li><p>springcloud的接⼝协议约定⽐较⾃由且松散，需要有强有⼒的⾏政措施来限制接⼝⽆序升级。</p>
</li>
<li><p>dubbo的改进是通过dubbofilter，很多东⻄没有，需要⾃⼰继承，如监控，如⽇志，如限流，如追踪。</p>
</li>
<li><p>springcloud具有配置管理、服务发现、断路器、智能路由、微代理、控制总线、⼀次性token、全局锁、选主、分布式会话和集群状态等，满⾜了构建微服务所需的所有解决⽅案。</p>
</li>
<li><p>组成部分不同</p>
</li>
</ul>
</li>
</ul>
<h1 id="dubbo都⽀持什么协议，推荐⽤哪种？"><a href="#dubbo都⽀持什么协议，推荐⽤哪种？" class="headerlink" title="dubbo都⽀持什么协议，推荐⽤哪种？"></a>dubbo都⽀持什么协议，推荐⽤哪种？</h1><ul>
<li>dubbo:&#x2F;&#x2F;（推荐）</li>
<li>rmi:&#x2F;&#x2F;</li>
<li>hessian:&#x2F;&#x2F;</li>
<li>http:&#x2F;&#x2F;</li>
<li>webservice:&#x2F;&#x2F;</li>
<li>thrift:&#x2F;&#x2F;</li>
<li>memcached:&#x2F;&#x2F;</li>
<li>redis:&#x2F;&#x2F;</li>
<li>rest:&#x2F;&#x2F;</li>
</ul>
<h1 id="Dubbo需要-Web-容器吗？"><a href="#Dubbo需要-Web-容器吗？" class="headerlink" title="Dubbo需要 Web 容器吗？"></a>Dubbo需要 Web 容器吗？</h1><ul>
<li>不需要，如果硬要⽤ Web 容器，只会增加复杂性，也浪费资源。</li>
</ul>
<h1 id="Dubbo内置了哪⼏种服务容器？"><a href="#Dubbo内置了哪⼏种服务容器？" class="headerlink" title="Dubbo内置了哪⼏种服务容器？"></a>Dubbo内置了哪⼏种服务容器？</h1><ul>
<li>Spring Container</li>
<li>Jetty Container</li>
<li>Log4j Container</li>
<li>Dubbo 的服务容器只是⼀个简单的 Main ⽅法，并加载⼀个简单的 Spring 容器，⽤于暴露服务。</li>
</ul>
<h1 id="Dubbo默认使⽤什么注册中⼼，还有别的选择吗？"><a href="#Dubbo默认使⽤什么注册中⼼，还有别的选择吗？" class="headerlink" title="Dubbo默认使⽤什么注册中⼼，还有别的选择吗？"></a>Dubbo默认使⽤什么注册中⼼，还有别的选择吗？</h1><ul>
<li>推荐使⽤ Zookeeper 作为注册中⼼，还有 Redis、Multicast、Simple 注册中⼼，但不推荐。</li>
<li>redis⽅案需要服务器时间同步，且性能消耗过⼤。</li>
</ul>
<h1 id="Dubbo有哪⼏种配置⽅式？"><a href="#Dubbo有哪⼏种配置⽅式？" class="headerlink" title="Dubbo有哪⼏种配置⽅式？"></a>Dubbo有哪⼏种配置⽅式？</h1><ul>
<li>Spring 配置⽅式</li>
<li>Java API 配置⽅式</li>
</ul>
<h1 id="在-Provider-上可以配置的-Consumer-端的属性有哪些？"><a href="#在-Provider-上可以配置的-Consumer-端的属性有哪些？" class="headerlink" title="在 Provider 上可以配置的 Consumer 端的属性有哪些？"></a>在 Provider 上可以配置的 Consumer 端的属性有哪些？</h1><ul>
<li>timeout：⽅法调⽤超时</li>
<li>retries：失败重试次数，默认重试 2 次</li>
<li>loadbalance：负载均衡算法，默认随机</li>
<li>actives 消费者端，最⼤并发调⽤限制</li>
</ul>
<h1 id="Dubbo启动时如果依赖的服务不可⽤会怎样？"><a href="#Dubbo启动时如果依赖的服务不可⽤会怎样？" class="headerlink" title="Dubbo启动时如果依赖的服务不可⽤会怎样？"></a>Dubbo启动时如果依赖的服务不可⽤会怎样？</h1><ul>
<li>Dubbo 缺省会在启动时检查依赖的服务是否可⽤，不可⽤时会抛出异常，阻⽌ Spring 初始化完成，默认 check&#x3D;”true”，可以通过 check&#x3D;”false” 关闭检查。</li>
</ul>
<h1 id="Dubbo推荐使⽤什么序列化框架，你知道的还有哪些？"><a href="#Dubbo推荐使⽤什么序列化框架，你知道的还有哪些？" class="headerlink" title="Dubbo推荐使⽤什么序列化框架，你知道的还有哪些？"></a>Dubbo推荐使⽤什么序列化框架，你知道的还有哪些？</h1><ul>
<li>推荐使⽤Hessian序列化，还有Duddo、FastJson、Java⾃带序列化。</li>
</ul>
<h1 id="Dubbo默认使⽤的是什么通信框架，还有别的选择吗？"><a href="#Dubbo默认使⽤的是什么通信框架，还有别的选择吗？" class="headerlink" title="Dubbo默认使⽤的是什么通信框架，还有别的选择吗？"></a>Dubbo默认使⽤的是什么通信框架，还有别的选择吗？</h1><ul>
<li>Dubbo 默认使⽤ Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。</li>
</ul>
<h1 id="注册了多个同⼀样的服务，如果测试指定的某⼀个服务呢？"><a href="#注册了多个同⼀样的服务，如果测试指定的某⼀个服务呢？" class="headerlink" title="注册了多个同⼀样的服务，如果测试指定的某⼀个服务呢？"></a>注册了多个同⼀样的服务，如果测试指定的某⼀个服务呢？</h1><ul>
<li>可以配置环境点对点直连，绕过注册中⼼，将以服务接⼝为单位，忽略注册中⼼的提供者列表。</li>
</ul>
<h1 id="Dubbo⽀持服务多协议吗？"><a href="#Dubbo⽀持服务多协议吗？" class="headerlink" title="Dubbo⽀持服务多协议吗？"></a>Dubbo⽀持服务多协议吗？</h1><ul>
<li>Dubbo 允许配置多协议，在不同服务上⽀持不同协议或者同⼀服务上同时⽀持多种协议。</li>
</ul>
<h1 id="当⼀个服务接⼝有多种实现时怎么做？"><a href="#当⼀个服务接⼝有多种实现时怎么做？" class="headerlink" title="当⼀个服务接⼝有多种实现时怎么做？"></a>当⼀个服务接⼝有多种实现时怎么做？</h1><ul>
<li>当⼀个接⼝有多种实现时，可以⽤ group 属性来分组，服务提供⽅和消费⽅都指定同⼀个 group 即可。</li>
</ul>
<h1 id="服务上线怎么兼容旧版本？"><a href="#服务上线怎么兼容旧版本？" class="headerlink" title="服务上线怎么兼容旧版本？"></a>服务上线怎么兼容旧版本？</h1><ul>
<li>可以⽤版本号（version）过渡，多个不同版本的服务注册到注册中⼼，版本号不同的服务相互间不引⽤。这个和服务分组的概念有⼀点类似。</li>
</ul>
<h1 id="Dubbo可以对结果进⾏缓存吗？"><a href="#Dubbo可以对结果进⾏缓存吗？" class="headerlink" title="Dubbo可以对结果进⾏缓存吗？"></a>Dubbo可以对结果进⾏缓存吗？</h1><ul>
<li>可以，Dubbo 提供了声明式缓存，⽤于加速热⻔数据的访问速度，以减少⽤户加缓存的⼯作量。</li>
</ul>
<h1 id="Dubbo服务之间的调⽤是阻塞的吗？"><a href="#Dubbo服务之间的调⽤是阻塞的吗？" class="headerlink" title="Dubbo服务之间的调⽤是阻塞的吗？"></a>Dubbo服务之间的调⽤是阻塞的吗？</h1><ul>
<li>默认是同步等待结果阻塞的，⽀持异步调⽤。</li>
<li>Dubbo 是基于 NIO 的⾮阻塞实现并⾏调⽤，客户端不需要启动多线程即可完成并⾏调⽤多个远程服务，相对多线程开销较⼩，异步调⽤会返回⼀个 Future 对象。</li>
</ul>
<h1 id="Dubbo⽀持分布式事务吗？"><a href="#Dubbo⽀持分布式事务吗？" class="headerlink" title="Dubbo⽀持分布式事务吗？"></a>Dubbo⽀持分布式事务吗？</h1><ul>
<li>⽬前暂时不⽀持，后续可能采⽤基于 JTA&#x2F;XA 规范实现，如以图所示。</li>
</ul>
<h1 id="Dubbo-telnet-命令能做什么？"><a href="#Dubbo-telnet-命令能做什么？" class="headerlink" title="Dubbo telnet 命令能做什么？"></a>Dubbo telnet 命令能做什么？</h1><ul>
<li>dubbo 通过 telnet 命令来进⾏服务治理</li>
<li>telnet localhost 8090</li>
</ul>
<h1 id="Dubbo⽀持服务降级吗？"><a href="#Dubbo⽀持服务降级吗？" class="headerlink" title="Dubbo⽀持服务降级吗？"></a>Dubbo⽀持服务降级吗？</h1><ul>
<li>Dubbo 2.2.0 以上版本⽀持。</li>
</ul>
<h1 id="Dubbo如何优雅停机？"><a href="#Dubbo如何优雅停机？" class="headerlink" title="Dubbo如何优雅停机？"></a>Dubbo如何优雅停机？</h1><ul>
<li>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使⽤ kill -9 PID 等强制关闭指令，是不会执⾏优雅停机的，只有通过 kill PID 时，才会执⾏。</li>
</ul>
<h1 id="服务提供者能实现失效踢出是什么原理？"><a href="#服务提供者能实现失效踢出是什么原理？" class="headerlink" title="服务提供者能实现失效踢出是什么原理？"></a>服务提供者能实现失效踢出是什么原理？</h1><ul>
<li>服务失效踢出基于 Zookeeper 的临时节点原理。 （服务机器会在zk上注册⼀个临时节点，服务失效则临时节点被删除）</li>
</ul>
<h1 id="如何解决服务调⽤链过⻓的问题？"><a href="#如何解决服务调⽤链过⻓的问题？" class="headerlink" title="如何解决服务调⽤链过⻓的问题？"></a>如何解决服务调⽤链过⻓的问题？</h1><ul>
<li>Dubbo 可以使⽤ Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪，当然还有其他很多⽅案。</li>
</ul>
<h1 id="服务读写推荐的容错策略是怎样的？"><a href="#服务读写推荐的容错策略是怎样的？" class="headerlink" title="服务读写推荐的容错策略是怎样的？"></a>服务读写推荐的容错策略是怎样的？</h1><ul>
<li>读操作建议使⽤ Failover 失败⾃动切换，默认重试两次其他服务器。</li>
<li>写操作建议使⽤ Failfast 快速失败，发⼀次调⽤失败就⽴即报错。</li>
</ul>
<h1 id="Dubbo必须依赖的包有哪些？"><a href="#Dubbo必须依赖的包有哪些？" class="headerlink" title="Dubbo必须依赖的包有哪些？"></a>Dubbo必须依赖的包有哪些？</h1><ul>
<li>Dubbo 必须依赖 JDK，其他为可选。</li>
</ul>
<h1 id="Dubbo的管理控制台能做什么？"><a href="#Dubbo的管理控制台能做什么？" class="headerlink" title="Dubbo的管理控制台能做什么？"></a>Dubbo的管理控制台能做什么？</h1><ul>
<li>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。</li>
</ul>
<h1 id="说说-Dubbo-服务暴露的过程。"><a href="#说说-Dubbo-服务暴露的过程。" class="headerlink" title="说说 Dubbo 服务暴露的过程。"></a>说说 Dubbo 服务暴露的过程。</h1><ul>
<li>Dubbo 会在 Spring 实例化完 bean 之后，</li>
<li>在刷新容器最后⼀步发布 ContextRefreshEvent 事件的时候，</li>
<li>通知实现了ApplicationListener 的 ServiceBean 类进⾏回调 onApplicationEvent 事件⽅法，</li>
<li>Dubbo 会在这个⽅法中调⽤ ServiceBean ⽗类ServiceConfig 的 export ⽅法，</li>
<li>⽽该⽅法真正实现了服务的（异步或者⾮异步）发布。</li>
</ul>
<h1 id="Dubbo-停⽌维护了吗？"><a href="#Dubbo-停⽌维护了吗？" class="headerlink" title="Dubbo 停⽌维护了吗？"></a>Dubbo 停⽌维护了吗？</h1><ul>
<li>2014 年开始停⽌维护过⼏年，17 年开始重新维护，并进⼊了 Apache 项⽬。</li>
</ul>
<h1 id="Dubbo-和-Dubbox-有什么区别？"><a href="#Dubbo-和-Dubbox-有什么区别？" class="headerlink" title="Dubbo 和 Dubbox 有什么区别？"></a>Dubbo 和 Dubbox 有什么区别？</h1><ul>
<li>Dubbox 是继 Dubbo 停⽌维护后，当当⽹基于 Dubbo 做的⼀个扩展项⽬，如加了服务可 Restful 调⽤，更新了开源组件等。</li>
</ul>
<h1 id="你还了解别的分布式框架吗？"><a href="#你还了解别的分布式框架吗？" class="headerlink" title="你还了解别的分布式框架吗？"></a>你还了解别的分布式框架吗？</h1><ul>
<li>别的还有 Spring cloud、Facebook 的 Thrift、Twitter 的 Finagle 等。</li>
</ul>
<h1 id="Dubbo-能集成-Spring-Boot-吗？"><a href="#Dubbo-能集成-Spring-Boot-吗？" class="headerlink" title="Dubbo 能集成 Spring Boot 吗？"></a>Dubbo 能集成 Spring Boot 吗？</h1><ul>
<li>可以的，项⽬地址如下。</li>
<li><a href="https://github.com/apache/incubator-dubbo-spring-boot-project">https://github.com/apache/incubator-dubbo-spring-boot-project</a></li>
</ul>
<h1 id="在使⽤过程中都遇到了些什么问题？"><a href="#在使⽤过程中都遇到了些什么问题？" class="headerlink" title="在使⽤过程中都遇到了些什么问题？"></a>在使⽤过程中都遇到了些什么问题？</h1><ul>
<li>单⼀⻓连接和NIO异步通讯，适合⼤并发⼩数据量的服务调⽤，以及消费者远⼤于提供者。Dubbo 的设计⽬的是为了满⾜⾼并发⼩数据量的 rpc 调⽤，在⼤数据量下的性能表现并不好，建议使⽤ rmi 或 http 协议。</li>
</ul>
<h1 id="你觉得⽤-Dubbo-好还是-Spring-Cloud-好？"><a href="#你觉得⽤-Dubbo-好还是-Spring-Cloud-好？" class="headerlink" title="你觉得⽤ Dubbo 好还是 Spring Cloud 好？"></a>你觉得⽤ Dubbo 好还是 Spring Cloud 好？</h1><ul>
<li>扩展性的问题，没有好坏，只有适合不适合，不过我好像更倾向于使⽤ Dubbo, Spring Cloud 版本升级太快，组件更新替换太频繁，配置太繁琐，还有很多我觉得是没有 Dubbo 顺⼿的地⽅……</li>
</ul>
<h1 id="Dubbo-是什么"><a href="#Dubbo-是什么" class="headerlink" title="Dubbo 是什么"></a>Dubbo 是什么</h1><ul>
<li>Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</li>
<li>主要核心部件：<ul>
<li>Remoting: 网络通信框架，实现了 sync-over-async 和 request-response 消息机制. RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能</li>
<li>Registry: 服务目录框架用于服务的注册和服务事件发布和订阅</li>
<li>Dubbo服务集群-集群容错模式</li>
<li>Dubbo 服务提供者集群与负载均衡</li>
</ul>
</li>
</ul>
<h1 id="Dubbo-执行流程什么是？"><a href="#Dubbo-执行流程什么是？" class="headerlink" title="Dubbo 执行流程什么是？"></a>Dubbo 执行流程什么是？</h1><ul>
<li>start: 启动 Spring 容器时,自动启动 Dubbo 的 Provider</li>
<li>register: Dubbo 的 Provider 在启动后自动会去注册中心注册内容.注册的内容包括:<ul>
<li>Provider 的 IP</li>
<li>Provider 的端口.</li>
<li>Provider 对外提供的接口列表.哪些方法.哪些接口类</li>
<li>Dubbo 的版本.</li>
<li>访问 Provider 的协议.</li>
</ul>
</li>
<li>subscribe: 订阅.当 Consumer 启动时,自动去 Registry 获取到所已注册的服务的信息.</li>
<li>notify: 通知.当 Provider 的信息发生变化时, 自动由 Registry 向 Consumer 推送通知.</li>
<li>invoke: 调用. Consumer 调用 Provider 中方法<ul>
<li>同步请求.消耗一定性能.但是必须是同步请求,因为需要接收调用方法后的结果.</li>
</ul>
</li>
<li>count:次数. 每隔 2 分钟,provoider 和 consumer 自动向 Monitor 发送访问次数.Monitor 进行统计.</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java web</title>
    <url>/publishes/e002a9c6759b.html</url>
    <content><![CDATA[<h1 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service?"></a>什么是Web Service?</h1><ul>
<li>Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。</li>
<li>使用的技术：HTTP、XML、SOAP（简单对象访问协议）、WSDL</li>
<li>优点：跨平台、跨语言、跨系统</li>
<li>SOAP协议:<ul>
<li>SOAP协议（Simple Object Access Protocal,简单对象访问协议）</li>
<li>Tcp&#x2F;iphttp-&gt;soap，soap 通过xml文件传送信息</li>
</ul>
</li>
<li>缺点：<ul>
<li>WebService使用了XML对数据封装，会造成大量的数据要在网络中传输。</li>
<li>WebService规范没有规定任何与实现相关的细节，包括对象模型、编程语言，这一点，它不如CORBA。</li>
</ul>
</li>
</ul>
<h1 id="什么是Web容器"><a href="#什么是Web容器" class="headerlink" title="什么是Web容器?"></a>什么是Web容器?</h1><ul>
<li>实现J2EE规范中web协议的应用</li>
<li>该协议定义了web程序的运行时环境,包括:并发性,安全性,生命周期管理等等.</li>
<li>就是在tomcat、weblogic下运行jsp、servlet、struts</li>
</ul>
<h1 id="应用服务器有那些？"><a href="#应用服务器有那些？" class="headerlink" title="应用服务器有那些？"></a>应用服务器有那些？</h1><ul>
<li>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat</li>
</ul>
<h1 id="如何给weblogic指定大小的内存"><a href="#如何给weblogic指定大小的内存" class="headerlink" title="如何给weblogic指定大小的内存?"></a>如何给weblogic指定大小的内存?</h1><ul>
<li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li>
</ul>
<h1 id="如何设定的weblogic的热启动模式-开发模式-与产品发布模式"><a href="#如何设定的weblogic的热启动模式-开发模式-与产品发布模式" class="headerlink" title="如何设定的weblogic的热启动模式(开发模式)与产品发布模式?"></a>如何设定的weblogic的热启动模式(开发模式)与产品发布模式?</h1><ul>
<li>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一</li>
<li>或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE&#x3D;true。</li>
</ul>
<h1 id="如何启动时不需输入用户名与密码"><a href="#如何启动时不需输入用户名与密码" class="headerlink" title="如何启动时不需输入用户名与密码?"></a>如何启动时不需输入用户名与密码?</h1><ul>
<li>修改服务启动文件，增加 WLS_USER和WLS_PW项</li>
<li>也可以在boot.properties文件中增加加密过的用户名和密码.</li>
</ul>
<h1 id="在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中"><a href="#在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中" class="headerlink" title="在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?"></a>在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?</h1><ul>
<li>保存在此Domain的config.xml文件中，它是服务器的核心配置文件。</li>
</ul>
<h1 id="说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办"><a href="#说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办" class="headerlink" title="说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?"></a>说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?</h1><ul>
<li>Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问</li>
<li>如果是Web应用，应用目录需要满足Web应用目录要求</li>
<li>jsp文件可以直接放在应用目录中</li>
<li>Javabean需要放在应用目录的WEB-INF目录的classes目录中</li>
<li>设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。</li>
</ul>
<h1 id="CORBA是什么-用途是什么"><a href="#CORBA是什么-用途是什么" class="headerlink" title="CORBA是什么?用途是什么?"></a>CORBA是什么?用途是什么?</h1><ul>
<li>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)</li>
<li>由对象管理组织 (Object Management Group，缩写为 OMG)标准化</li>
<li>它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议</li>
<li>其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。</li>
</ul>
<h1 id="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"><a href="#说说在weblogic中开发消息Bean时的persistent与non-persisten的差别" class="headerlink" title="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"></a>说说在weblogic中开发消息Bean时的persistent与non-persisten的差别</h1><ul>
<li>persistent方式的MDB可以保证消息传递的可靠性</li>
<li>也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来</li>
<li>而non－persistent方式的消息将被丢弃。</li>
</ul>
<h1 id="WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。"><a href="#WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。" class="headerlink" title="WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。"></a>WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</h1><ul>
<li>Web Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。</li>
<li>JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口，这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。</li>
<li>JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。</li>
<li>WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。</li>
<li>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。</li>
<li>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。</li>
</ul>
<h1 id="简单说说tomcat的配置？"><a href="#简单说说tomcat的配置？" class="headerlink" title="简单说说tomcat的配置？"></a>简单说说tomcat的配置？</h1><ul>
<li>JAVA_HOME&#x3D;JDK的根目录</li>
<li>CATALINA_HOME&#x3D;tomcat的根目录</li>
<li>CATALINA-HOME\conf\server.xml:可以配置tomcat的端口，可以配置tomcat中下连接池。</li>
<li>CATALINA-HOME\common\lib:存放公用的类包</li>
</ul>
<h1 id="JSP中动态INCLUDE与静态INCLUDE的区别？"><a href="#JSP中动态INCLUDE与静态INCLUDE的区别？" class="headerlink" title="JSP中动态INCLUDE与静态INCLUDE的区别？"></a>JSP中动态INCLUDE与静态INCLUDE的区别？</h1><ul>
<li>jsp:include:在运行时调用另一个页面，变量是可以重复的。</li>
<li>&lt;%@include file&#x3D;””%&gt;:在转译时合在一起，会成为同一个类，变量不可以重复。</li>
<li>&lt;@include file&gt;:在将jsp生成servlet类前将两个文件和在一起，生成一个java类，一起运行的。所以是一家子，当中的变量名不能重名。</li>
<li>&lt;jsp:include page&gt;:是两个类，是一个调用关系，在运行时动态的调用，不是一家子，可以重复变量。</li>
</ul>
<h1 id="forward和redirect的区别？"><a href="#forward和redirect的区别？" class="headerlink" title="forward和redirect的区别？"></a>forward和redirect的区别？</h1><ul>
<li>forward: 转发，在下一个页面中，request保留上一个页面中的request的所有值</li>
<li>redirect: 跳转，不传递request对象。</li>
</ul>
<h1 id="Servlet的体系结构是什么"><a href="#Servlet的体系结构是什么" class="headerlink" title="Servlet的体系结构是什么?"></a>Servlet的体系结构是什么?</h1><ul>
<li>Servlet</li>
<li>GenericServlet</li>
<li>HttpServlet</li>
</ul>
<h1 id="如何实现一个自定义的servlet"><a href="#如何实现一个自定义的servlet" class="headerlink" title="如何实现一个自定义的servlet?"></a>如何实现一个自定义的servlet?</h1><ul>
<li>extends HttpServlet 并覆盖doPost或doGet方法</li>
<li>在web.xml中进行部署</li>
</ul>
<h1 id="Servlet的生命周期是什么"><a href="#Servlet的生命周期是什么" class="headerlink" title="Servlet的生命周期是什么?"></a>Servlet的生命周期是什么?</h1><ul>
<li>Init </li>
<li>多次执行doGet或doPost  </li>
<li>destroy</li>
</ul>
<h1 id="jsp就是一个servlet是否正确"><a href="#jsp就是一个servlet是否正确" class="headerlink" title="jsp就是一个servlet是否正确?"></a>jsp就是一个servlet是否正确?</h1><ul>
<li>对</li>
</ul>
<h1 id="请罗列jsp中的脚本、指令及动作"><a href="#请罗列jsp中的脚本、指令及动作" class="headerlink" title="请罗列jsp中的脚本、指令及动作?"></a>请罗列jsp中的脚本、指令及动作?</h1><ul>
<li>脚本：&lt;%%&gt;  &lt;%&#x3D;%&gt;  &lt;%!%&gt; &lt;%—-%&gt;</li>
<li>指令<ul>
<li>&lt;%@page contentType&#x3D;”text&#x2F;html;charset&#x3D;utf-8” language&#x3D;”java” import&#x3D;””%&gt;</li>
<li>&lt;%@include file&#x3D;””%&gt;</li>
<li>&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</li>
</ul>
</li>
<li>动作:<ul>
<li>&lt;jsp:useBean class&#x3D;”” id&#x3D;”” scope&#x3D;””&gt;  在scope中如果没有实例化一个对象，如果有直接用以前的。</li>
<li>&lt;jsp:getProperty name&#x3D;”” property&#x3D;””&gt;  向一个bean中设置属性值</li>
<li>&lt;jsp:forward &gt;  jsp页的转发</li>
<li>&lt;jsp:include page&#x3D;””&gt;  导入一个jsp页面</li>
</ul>
</li>
</ul>
<h1 id="JSP的内置对象及方法"><a href="#JSP的内置对象及方法" class="headerlink" title="JSP的内置对象及方法"></a>JSP的内置对象及方法</h1><ul>
<li>Request  request表示HttpServletRequest对象。取客户端表单域信息及cookie, header, 和session </li>
<li>response response表示HttpServletResponse对象，对客户端的响应返回文本、写cookies。</li>
<li>out out 向客户端打印html文本. </li>
<li>pageContext :当前jsp页面的上下文环境，可以得到session、request、application等内置对象，在自定义标签中使用的很多。</li>
<li>session session表示一个请求的javax.servlet.http.HttpSession对象。Session一个用户多个页面共享同一变量。</li>
<li>application applicaton 表示一个javax.servle.ServletContext对象。存放容器级的变量。</li>
<li>config config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 </li>
<li>page page表示从该页面产生的一个servlet实例</li>
<li>exception:异常，当iserrorpage&#x3D;true</li>
</ul>
<h1 id="说出在JSP页面里是怎么分页的"><a href="#说出在JSP页面里是怎么分页的" class="headerlink" title="说出在JSP页面里是怎么分页的?"></a>说出在JSP页面里是怎么分页的?</h1><ul>
<li>页面需要保存以下参数：(数据库的分页及比较)<ul>
<li>总行数：根据sql语句得到总行数</li>
<li>每页显示行数：设定值</li>
<li>当前页数：请求参数</li>
</ul>
</li>
<li>页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。</li>
</ul>
<h1 id="描述JSP和Servlet的区别、共同点、各自应用的范围"><a href="#描述JSP和Servlet的区别、共同点、各自应用的范围" class="headerlink" title="描述JSP和Servlet的区别、共同点、各自应用的范围"></a>描述JSP和Servlet的区别、共同点、各自应用的范围</h1><ul>
<li>Jsp主要在于页面的显示动态生成页面，可以与html标记一起使用，其还是要生成为一个servlet。</li>
<li>Servlet：主要是控制的处理，如调用业务层，跳转不同的jsp页面。</li>
<li>Mvc:<ul>
<li>Jsp:v</li>
<li>Servlet:c</li>
</ul>
</li>
</ul>
<h1 id="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"><a href="#在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？" class="headerlink" title="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"></a>在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？</h1><ul>
<li>Request.getparameter(“”)</li>
<li>&lt;%&#x3D;application.getRealPath(“aa.jsp”) %&gt;</li>
</ul>
<h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。</h1><ul>
<li>Cookie:主要用在保存客户端，其值在客户端与服务端之间传送，不安全，存储的数据量有限。</li>
<li>Session:保存在服务端，每一个session在服务端有一个sessionID作一个标识。存储的数据量大，安全性高。占用服务端的内存资源。</li>
</ul>
<h1 id="说明Jsp中errorPage的作用，应用范围。"><a href="#说明Jsp中errorPage的作用，应用范围。" class="headerlink" title="说明Jsp中errorPage的作用，应用范围。"></a>说明Jsp中errorPage的作用，应用范围。</h1><ul>
<li>正常页面中：%@page erropage&#x3D;”error.jsp”%</li>
<li>错误页面：&lt;%@page iserrorpage&#x3D;”true”%&gt;</li>
<li>有一内置对象:exception</li>
</ul>
<h1 id="介绍在Jsp中如何使用JavaBeans"><a href="#介绍在Jsp中如何使用JavaBeans" class="headerlink" title="介绍在Jsp中如何使用JavaBeans"></a>介绍在Jsp中如何使用JavaBeans</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;jsp:useBean class=”” id=”” scope=””/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	New 类();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h1 id="简单介绍JSP的标记库"><a href="#简单介绍JSP的标记库" class="headerlink" title="简单介绍JSP的标记库"></a>简单介绍JSP的标记库</h1><ul>
<li><p>做一个标记处理类 extends TagSupport</p>
</li>
<li><p>通过tld说明标记处理的类的前缀及后缀</p>
</li>
<li><p>在web.xml中说明tld文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;taglib&gt;</span><br><span class="line">		&lt;taglib-uri&gt;</span><br><span class="line">		&lt;taglib-location&gt;</span><br><span class="line">&lt;taglib&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在jsp页面是引用tld&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</p>
</li>
</ul>
<h1 id="Servlet中的核心类有那些，各有什么特点"><a href="#Servlet中的核心类有那些，各有什么特点" class="headerlink" title="Servlet中的核心类有那些，各有什么特点?"></a>Servlet中的核心类有那些，各有什么特点?</h1><ul>
<li>ServletContext：容器，放置全局变量<ul>
<li>setAtribute()</li>
<li>getAttribute()</li>
</ul>
</li>
<li>ServletConfig：一个servlet的配置<ul>
<li>getInitParameter(”名称”)</li>
</ul>
</li>
<li>HttpServletRequest：封装的所有的请求<ul>
<li>getParameterValue(”名称”)</li>
<li>getParameterValues(”称”)</li>
</ul>
</li>
<li>getSession();<ul>
<li>getAttribute(” 名称”);</li>
<li>getRequestDispatch(”a.jsp”).forward(request,response)</li>
</ul>
</li>
<li>HttpServletResponse：响应<ul>
<li>getOut();</li>
<li>sendRedirect(””)</li>
</ul>
<p>							</p>
</li>
<li>HttpSession：一个用户多个页面共享同一变量<ul>
<li>setAttribute(””,””)</li>
</ul>
</li>
</ul>
<h1 id="Servlet中重要的包有那些，有什么区别"><a href="#Servlet中重要的包有那些，有什么区别" class="headerlink" title="Servlet中重要的包有那些，有什么区别?"></a>Servlet中重要的包有那些，有什么区别?</h1><ul>
<li>javax.servlet.<em>；javax.servlet.http.</em>;</li>
</ul>
<h1 id="说出Servlet的生命周期，并说出Servlet和CGI的区别？"><a href="#说出Servlet的生命周期，并说出Servlet和CGI的区别？" class="headerlink" title="说出Servlet的生命周期，并说出Servlet和CGI的区别？"></a>说出Servlet的生命周期，并说出Servlet和CGI的区别？</h1><ul>
<li>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</li>
<li>与cgi的区别在于servlet处理服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li>
</ul>
<h1 id="什么情况下调用doGet-和doPost-？"><a href="#什么情况下调用doGet-和doPost-？" class="headerlink" title="什么情况下调用doGet()和doPost()？"></a>什么情况下调用doGet()和doPost()？</h1><ul>
<li>Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。</li>
</ul>
<h1 id="如何现实servlet的单线程模式"><a href="#如何现实servlet的单线程模式" class="headerlink" title="如何现实servlet的单线程模式"></a>如何现实servlet的单线程模式</h1><ul>
<li>在doGet及doPost方法前加入synchoronized</li>
<li>JSP：&lt;%@ page isThreadSafe&#x3D;”true”%&gt;</li>
</ul>
<h1 id="Request对象的主要方法："><a href="#Request对象的主要方法：" class="headerlink" title="Request对象的主要方法："></a>Request对象的主要方法：</h1><ul>
<li>setAttribute(String name,Object)：设置名字为name的request的参数值</li>
<li>getAttribute(String name)：返回由name指定的属性值</li>
<li>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例</li>
<li>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组</li>
<li>getCharacterEncoding()：返回请求中的字符编码方式</li>
<li>getContentLength()：返回请求的Body的长度</li>
<li>getInputStream()：返回请求的输入流，用于获得请求中的数据</li>
<li>getMethod()：获得客户端向服务器端传送数据的方法</li>
<li>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值</li>
<li>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li>
<li>getParameterValues(String name)：获得有name指定的参数的所有值</li>
<li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li>
<li>getQueryString()：获得查询字符串</li>
<li>getRequestURI()：获取发出请求字符串的客户端地址</li>
<li>getRemoteAddr()：获取客户端的IP地址</li>
<li>getRemoteHost()：获取客户端的名字</li>
<li>getSession([Boolean create])：返回和请求相关Session</li>
<li>getServerName()：获取服务器的名字</li>
<li>getServletPath()：获取客户端所请求的脚本文件的路径</li>
<li>getServerPort()：获取服务器的端口号</li>
<li>removeAttribute(String name)：删除请求中的一个属性</li>
</ul>
<h1 id="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"><a href="#我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"></a>我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public String translate (String str) &#123;</span><br><span class="line">  String tempStr = &quot;&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">    tempStr = new String(str.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);</span><br><span class="line">    tempStr = tempStr.trim();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Exception e) &#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  return tempStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Servlet执行时一般实现哪几个方法"><a href="#Servlet执行时一般实现哪几个方法" class="headerlink" title="Servlet执行时一般实现哪几个方法?"></a>Servlet执行时一般实现哪几个方法?</h1><ul>
<li>public void init(ServletConfig config)</li>
<li>public ServletConfig getServletConfig()</li>
<li>public String getServletInfo()</li>
<li>public void service(ServletRequest request,ServletResponse response)</li>
<li>public void destroy()</li>
</ul>
<h1 id="jsp有哪些内置对象-作用分别是什么："><a href="#jsp有哪些内置对象-作用分别是什么：" class="headerlink" title="jsp有哪些内置对象?作用分别是什么："></a>jsp有哪些内置对象?作用分别是什么：</h1><ul>
<li>JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）： <ul>
<li>request 用户端请求，此请求会包含来自GET&#x2F;POST请求的参数 </li>
<li>response 网页传回用户端的回应 </li>
<li>pageContext 网页的属性是在这里管理 </li>
<li>session 与请求有关的会话期 </li>
<li>application servlet 正在执行的内容 </li>
<li>out 用来传送回应的输出 </li>
<li>config servlet的构架部件 </li>
<li>page JSP网页本身 </li>
<li>exception 针对错误网页，未捕捉的例外。</li>
</ul>
</li>
</ul>
<h1 id="jsp有哪些动作-作用分别是什么："><a href="#jsp有哪些动作-作用分别是什么：" class="headerlink" title="jsp有哪些动作?作用分别是什么："></a>jsp有哪些动作?作用分别是什么：</h1><ul>
<li>JSP共有以下6种基本动作 <ul>
<li>jsp:include：在页面被请求的时候引入一个文件。 </li>
<li>jsp:useBean：寻找或者实例化一个JavaBean。 </li>
<li>jsp:setProperty：设置JavaBean的属性。 </li>
<li>jsp:getProperty：输出某个JavaBean的属性。 </li>
<li>jsp:forward：把请求转到一个新的页面。 </li>
<li>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。</li>
</ul>
</li>
</ul>
<h1 id="说一说Servlet的生命周期："><a href="#说一说Servlet的生命周期：" class="headerlink" title="说一说Servlet的生命周期："></a>说一说Servlet的生命周期：</h1><ul>
<li>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束</li>
<li>这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。</li>
</ul>
<h1 id="JAVA-SERVLET-API中forward-与redirect-的区别："><a href="#JAVA-SERVLET-API中forward-与redirect-的区别：" class="headerlink" title="JAVA SERVLET API中forward() 与redirect()的区别："></a>JAVA SERVLET API中forward() 与redirect()的区别：</h1><ul>
<li>前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接，从浏览器的地址栏中可以看到跳转后的链接地址</li>
<li>前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。</li>
</ul>
<h1 id="MVC的各个部分都有那些技术来实现-如何实现："><a href="#MVC的各个部分都有那些技术来实现-如何实现：" class="headerlink" title="MVC的各个部分都有那些技术来实现?如何实现："></a>MVC的各个部分都有那些技术来实现?如何实现：</h1><ul>
<li>MVC是Model－View－Controller的简写</li>
<li>“Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）</li>
<li>“View” 是应用的表示面（由JSP页面产生）</li>
<li>“Controller” 是提供应用的处理过程控制（一般是一个Servlet）</li>
<li>通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。</li>
</ul>
<h1 id="J2EE是什么："><a href="#J2EE是什么：" class="headerlink" title="J2EE是什么："></a>J2EE是什么：</h1><ul>
<li>Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model)</li>
<li>在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中</li>
<li>所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。</li>
</ul>
<h1 id="STRUTS的应用-如STRUTS架构-："><a href="#STRUTS的应用-如STRUTS架构-：" class="headerlink" title="STRUTS的应用(如STRUTS架构) ："></a>STRUTS的应用(如STRUTS架构) ：</h1><ul>
<li>Struts是采用Java Servlet&#x2F;JavaServer Pages技术，开发Web应用程序的开放源码的framework</li>
<li>采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架</li>
<li>Struts有如下的主要功能： <ul>
<li>包含一个controller servlet，能将用户的请求发送到相应的Action对象。 </li>
<li>JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 </li>
<li>提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。</li>
</ul>
</li>
</ul>
<h1 id="开发中都用到了那些设计模式-用在什么场合："><a href="#开发中都用到了那些设计模式-用在什么场合：" class="headerlink" title="开发中都用到了那些设计模式?用在什么场合："></a>开发中都用到了那些设计模式?用在什么场合：</h1><ul>
<li>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心</li>
<li>通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作</li>
<li>主要用到了MVC的设计模式</li>
<li>用来开发JSP&#x2F;Servlet或者J2EE的相关应用</li>
<li>简单工厂模式等。</li>
</ul>
<h1 id="四种会话跟踪技术："><a href="#四种会话跟踪技术：" class="headerlink" title="四种会话跟踪技术："></a>四种会话跟踪技术：</h1><ul>
<li>cookie,url重写,session,隐藏域。</li>
</ul>
<h1 id="J2EE是技术还是平台还是框架："><a href="#J2EE是技术还是平台还是框架：" class="headerlink" title="J2EE是技术还是平台还是框架："></a>J2EE是技术还是平台还是框架：</h1><ul>
<li>J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。</li>
<li>J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。</li>
</ul>
<h1 id="EJB的角色和三个对象："><a href="#EJB的角色和三个对象：" class="headerlink" title="EJB的角色和三个对象："></a>EJB的角色和三个对象：</h1><ul>
<li>一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性</li>
<li>这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类</li>
</ul>
<h1 id="EJB容器提供的服务："><a href="#EJB容器提供的服务：" class="headerlink" title="EJB容器提供的服务："></a>EJB容器提供的服务：</h1><ul>
<li>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</li>
</ul>
<h1 id="EJB规范规定EJB中禁止的操作有哪些："><a href="#EJB规范规定EJB中禁止的操作有哪些：" class="headerlink" title="EJB规范规定EJB中禁止的操作有哪些："></a>EJB规范规定EJB中禁止的操作有哪些：</h1><ul>
<li>不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，</li>
<li>不能操作awt，</li>
<li>不能实现服务器功能，</li>
<li>不能对静态属生存取，</li>
<li>不能使用IO操作直接存取文件系统，</li>
<li>不能加载本地库.，</li>
<li>不能将this作为变量和返回，</li>
<li>不能循环调用。</li>
</ul>
<h1 id="说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法："><a href="#说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法：" class="headerlink" title="说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法："></a>说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法：</h1><ul>
<li>Session Facade Pattern：使用SessionBean访问EntityBean；</li>
<li>Message Facade Pattern：实现异步调用</li>
<li>EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问；</li>
<li>Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性；</li>
<li>Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性；</li>
<li>Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性；</li>
<li>ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率</li>
<li>项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。</li>
</ul>
<h1 id="UML方面："><a href="#UML方面：" class="headerlink" title="UML方面："></a>UML方面：</h1><ul>
<li>标准建模语言UML</li>
<li>用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。</li>
</ul>
<h1 id="说出一些常用的类，包，接口，请各举5个常用的类："><a href="#说出一些常用的类，包，接口，请各举5个常用的类：" class="headerlink" title="说出一些常用的类，包，接口，请各举5个常用的类："></a>说出一些常用的类，包，接口，请各举5个常用的类：</h1><ul>
<li>常用的类：BufferedReader  BufferedWriter  FileReader  FileWirter  String  Integer；</li>
<li>常用的包：java.lang  java.awt  java.io  java.util  java.sql；</li>
<li>常用的接口：Remote  List  Map  Document  NodeList</li>
</ul>
<h1 id="应用服务器与WEB-SERVER的区别："><a href="#应用服务器与WEB-SERVER的区别：" class="headerlink" title="应用服务器与WEB SERVER的区别："></a>应用服务器与WEB SERVER的区别：</h1><ul>
<li>应用服务器：Weblogic、Tomcat、Jboss； WEB SERVER：IIS、 Apache</li>
</ul>
<h1 id="BS与CS的联系与区别："><a href="#BS与CS的联系与区别：" class="headerlink" title="BS与CS的联系与区别："></a>BS与CS的联系与区别：</h1><ul>
<li>C&#x2F;S是Client&#x2F;Server的缩写</li>
<li>服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server</li>
<li>客户端需要安装专用的客户端软件</li>
<li>B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库</li>
<li>在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。</li>
<li>浏览器通过Ｗeb Server 同数据库进行数据交互。</li>
</ul>
<h4 id="C-S-与-B-S-区别"><a href="#C-S-与-B-S-区别" class="headerlink" title="C&#x2F;S 与 B&#x2F;S 区别"></a>C&#x2F;S 与 B&#x2F;S 区别</h4><ul>
<li>硬件环境不同: C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C&#x2F;S更强的适应范围, 一般只要有操作系统和浏览器就行 </li>
<li>对安全要求不同 ：C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C&#x2F;S 结构适宜. 可以通过B&#x2F;S发布部分可公开信息.B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。</li>
<li>对程序架构不同 ：　C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C&#x2F;S有更高的要求 B&#x2F;S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B&#x2F;S更加成熟. </li>
<li>软件重用不同： C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性好.　B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。</li>
<li>系统维护不同  ：C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级. </li>
<li>处理问题不同 ：C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C&#x2F;S无法作到的. 与操作系统平台关系最小. </li>
<li>用户接口不同： C&#x2F;S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本. </li>
<li>信息流不同 ：　C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B&#x2F;S 信息流向可变化,        B-B B-C B-G等信息、流向的变化, 更像交易中心</li>
</ul>
<h1 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h1><ul>
<li>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址</li>
<li>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</li>
</ul>
<h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理</h1><ul>
<li>Session用于保存每个用户的专用信息</li>
<li>每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID）</li>
<li>她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右)</li>
<li>Session中的信息保存在Web服务器内容中,保存的数据量可大可小</li>
<li>当 Session超时或被关闭时将自动释放保存的数据信息</li>
<li>由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低</li>
<li>对于小量的数据,使用Session对象保存还是一个不错的选择</li>
<li>Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置</li>
<li>如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止</li>
<li>如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期</li>
<li>Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据</li>
<li>由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性</li>
<li>session工作原理<ul>
<li>当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。</li>
<li>然后，服务器开辟一块内存，对应于该Session ID。</li>
<li>服务器再将该Session ID写入浏览器的cookie。</li>
<li>服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。</li>
<li>当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。</li>
<li>然后，服务检查该Session ID所对应的内存是否有效。</li>
<li>如果有效，就读出内存中的值。</li>
<li>如果无效，就建立新的Session。</li>
</ul>
</li>
</ul>
<h1 id="Servlet的生命周期分为3个阶段-和CGI的区别？"><a href="#Servlet的生命周期分为3个阶段-和CGI的区别？" class="headerlink" title="Servlet的生命周期分为3个阶段:?  和CGI的区别？"></a>Servlet的生命周期分为3个阶段:?  和CGI的区别？</h1><ul>
<li>Servlet的生命周期主要由3个过程组成。<ul>
<li>init()方法：服务器初始化servlet。</li>
<li>service()方法：初始化完毕，servlet对象调用该方法响应客户的请求。</li>
<li>destroy()方法：调用该方法消灭servlet对象。</li>
</ul>
</li>
<li>其中，init()方法只在servlet第一次被请求加载的时候被调用一次，当有客户再请求servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。</li>
<li>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li>
</ul>
<h1 id="浏览器页面与T0MCat的交互过程？"><a href="#浏览器页面与T0MCat的交互过程？" class="headerlink" title="浏览器页面与T0MCat的交互过程？"></a>浏览器页面与T0MCat的交互过程？</h1><ul>
<li>当一个JSP页面第一次被访问的时候，JSP引擎将执行以下步骤：<ul>
<li>将JSP页面翻译成一个Servlet，这个Servlet是一个java文件，同时也是一个完整的java程序</li>
<li>JSP引擎调用java编译器对这个Servlet进行编译，得到可执行文件class</li>
<li>JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户端</li>
</ul>
</li>
<li>以上三个步骤仅仅在JSP页面第一次被访问时才会执行，以后的访问速度会因为class文件已经生成而大大提高<br>当JSP引擎接到一个客户端的访问请求时，首先判断请求的JSP页面是否比对应的Servlet新，如果新，对应的JSP需要重新编译。</li>
</ul>
<h1 id="JSP内置对象作用，如何取Cookie的方法"><a href="#JSP内置对象作用，如何取Cookie的方法" class="headerlink" title="JSP内置对象作用，如何取Cookie的方法"></a>JSP内置对象作用，如何取Cookie的方法</h1><ul>
<li>使用request对象的getCookies()方法取cookies</li>
</ul>
<h1 id="JAVA事件有哪些模式？"><a href="#JAVA事件有哪些模式？" class="headerlink" title="JAVA事件有哪些模式？"></a>JAVA事件有哪些模式？</h1><ul>
<li>事件直接驱动模式。它的第一个要求就是性能的要求，需要直接而且快，是必须经常使用的，主要适合于迅速处理 前台的命令，往往是系统架构的重要部分，也是流程控制的主要模式。</li>
<li>监控式事件模式是借助第三者来监控和触发事件，特点是： 有一个观察者置身事外在定期独立运行着。</li>
</ul>
<h1 id="uml三要素"><a href="#uml三要素" class="headerlink" title="uml三要素."></a>uml三要素.</h1><ul>
<li>事物、关系、图</li>
</ul>
<h1 id="Session的具体用法？"><a href="#Session的具体用法？" class="headerlink" title="Session的具体用法？"></a>Session的具体用法？</h1><ul>
<li>Session用来保存每一个用户的专有信息，比如像用户登录验证、购物车。</li>
</ul>
<h1 id="请裂举session、cookie、viewstated的应用范围"><a href="#请裂举session、cookie、viewstated的应用范围" class="headerlink" title="请裂举session、cookie、viewstated的应用范围"></a>请裂举session、cookie、viewstated的应用范围</h1><ul>
<li>Session 服务器端维护， 某个用户活动时间 + 延迟时间（默认20分钟），</li>
<li>Cookie 客户端维护， 程序可指定生命周期，</li>
<li>ViewState 小量数据，一个web页面的生命期</li>
</ul>
<h1 id="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"><a href="#用什么方法使服务器关闭之后，session所保存的信息不会丢失？" class="headerlink" title="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"></a>用什么方法使服务器关闭之后，session所保存的信息不会丢失？</h1><ul>
<li>将session信息保存到数据库中或文件中</li>
</ul>
<h4 id="写客户端Cookie的方式"><a href="#写客户端Cookie的方式" class="headerlink" title="写客户端Cookie的方式"></a>写客户端Cookie的方式</h4><ul>
<li>当用户登陆成功以后，把网站域名、用户名、密码、token、session有效时间全部采用cookie的形式写入到客户端的cookie里面</li>
<li>如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务</li>
<li>当然，如果cookie过期，或者无效，自然就不让用户继续服务了</li>
<li>当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？</li>
</ul>
<h4 id="服务器之间Session数据同步的方式"><a href="#服务器之间Session数据同步的方式" class="headerlink" title="服务器之间Session数据同步的方式"></a>服务器之间Session数据同步的方式</h4><ul>
<li>假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了</li>
<li>缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。</li>
</ul>
<h4 id="利用NFS共享Session数据的方式"><a href="#利用NFS共享Session数据的方式" class="headerlink" title="利用NFS共享Session数据的方式"></a>利用NFS共享Session数据的方式</h4><ul>
<li>其实这个方案和下面的Mysql方案类似，只是存储方式不一样</li>
<li>大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台NFS服务器上的，不论用户访问那太Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了</li>
<li>缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。</li>
</ul>
<h4 id="利用Mysql数据库共享Session数据的方式"><a href="#利用Mysql数据库共享Session数据的方式" class="headerlink" title="利用Mysql数据库共享Session数据的方式"></a>利用Mysql数据库共享Session数据的方式</h4><ul>
<li>这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上</li>
<li>所有Web服务器都来这台Mysql服务器来获取Session数据</li>
<li>缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql数据的方式。</li>
</ul>
<h1 id="使用硬件设备"><a href="#使用硬件设备" class="headerlink" title="使用硬件设备"></a>使用硬件设备</h1><ul>
<li>这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了</li>
<li>目前很多门户网站采用这种方式</li>
<li>缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的。</li>
</ul>
<h1 id="过滤器有哪些作用和用法？"><a href="#过滤器有哪些作用和用法？" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h1><ul>
<li>对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤</li>
<li>当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联</li>
<li>如果有，那么容器将把请求交给过滤器进行处理</li>
<li>在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源</li>
<li>当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常- 见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。</li>
<li>和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain</li>
</ul>
<h1 id="监听器有哪些作用和用法？"><a href="#监听器有哪些作用和用法？" class="headerlink" title="监听器有哪些作用和用法？"></a>监听器有哪些作用和用法？</h1><ul>
<li>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：<ul>
<li>ServletContextListener：对Servlet上下文的创建和销毁进行监听。</li>
<li>ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。</li>
<li>HttpSessionListener：对Session的创建和销毁进行监听。补充：session的销毁有两种情况：1session超时（可以在web.xml中通过&lt;session-config&gt;&#x2F;&lt;session-timeout&gt;标签配置超时时间）；2通过调用session对象的invalidate()方法使session失效。</li>
<li>HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。</li>
<li>ServletRequestListener：对请求对象的初始化和销毁进行监听。</li>
<li>ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</li>
</ul>
</li>
</ul>
<h1 id="实现会话跟踪的技术有哪些？"><a href="#实现会话跟踪的技术有哪些？" class="headerlink" title="实现会话跟踪的技术有哪些？"></a>实现会话跟踪的技术有哪些？</h1><ul>
<li>由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。</li>
</ul>
<h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><ul>
<li>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</li>
</ul>
<h4 id="设置表单隐藏域"><a href="#设置表单隐藏域" class="headerlink" title="设置表单隐藏域"></a>设置表单隐藏域</h4><ul>
<li>将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。</li>
<li>这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul>
<li>cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间</li>
<li>当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份</li>
<li>会话中可以为用户保存信息</li>
<li>会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的</li>
<li>如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪</li>
<li>当然，在使用cookie时要注意几点<ul>
<li>首先不要在cookie中存放敏感信息</li>
<li>其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中</li>
<li>再者浏览器通常只允许一个站点最多存放20个cookie</li>
<li>当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。</li>
</ul>
</li>
</ul>
<h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><ul>
<li>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的</li>
<li>当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession</li>
<li>可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象</li>
<li>与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能</li>
<li>添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</li>
</ul>
<h1 id="JSP-和Servlet-有有什么关系？"><a href="#JSP-和Servlet-有有什么关系？" class="headerlink" title="JSP 和Servlet 有有什么关系？"></a>JSP 和Servlet 有有什么关系？</h1><ul>
<li>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容</li>
<li>JSP本质上是Servlet的一种简易形式， JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成</li>
<li>Servlet和JSP最主要的不同点在于，Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML分离开来</li>
<li>而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp 的文件（有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然，这个说法还是很片面的）</li>
<li>JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</li>
</ul>
<h1 id="常用的Web容器"><a href="#常用的Web容器" class="headerlink" title="常用的Web容器"></a>常用的Web容器</h1><ul>
<li>Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器</li>
<li>选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等</li>
<li>下面是对常用服务器的简介：<ul>
<li>IIS：Microsoft的Web服务器产品为Internet Information Services。IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。</li>
<li>Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。</li>
<li>WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要，范围从简单到高级直到企业级。</li>
<li>WebLogic：BEA WebLogic Server是一种多功能、基于标准的Web应用服务器，为企业构建自己的应用提供了坚实的基础。各种应用开发、部署所有关键性的任务，无论是集成各种系统和数据库，还是提交服务、跨Internet协作，Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发，基于Internet的企业都选择它来开发、部署最佳的应用。BEA WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础，它们以 Internet的容量和速度，在连网的企业之间共享信息、提交服务，实现协作自动化。</li>
<li>Apache：目前Apache仍然是世界上用得最多的Web服务器，市场占有率约为60%左右。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。</li>
<li>Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。TomcatServer实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。</li>
<li>Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</li>
</ul>
</li>
</ul>
<h1 id="MVC原理"><a href="#MVC原理" class="headerlink" title="MVC原理"></a>MVC原理</h1><ul>
<li>MVC是一种程序开发设计模式,它实现了显示模块与功能模块的分离</li>
<li>提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、控制器三层。<ul>
<li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li>
<li>视图(view) 用户与之交互的界面、在web中视图一般由jsp,html组成</li>
<li>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用</li>
</ul>
</li>
</ul>
<h4 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h4><ul>
<li>降低代码耦合性。在MVC模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。</li>
<li>有利于分工合作。在MVC模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。</li>
<li>有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。</li>
</ul>
<h4 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h4><ul>
<li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li>
<li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li>
<li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li>
<li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难。</li>
</ul>
<h1 id="JSP的执行过程"><a href="#JSP的执行过程" class="headerlink" title="JSP的执行过程"></a>JSP的执行过程</h1><ul>
<li>在JSP运行过程中，首先由客户端发出请求，Web服务器接收到请求后，如果是第一次访问某个jsp页面，Web服务器对它进行以下3个操作。<ul>
<li>翻译：由.jsp变为.java,由JSP引擎实现。</li>
<li>编译：由.java变为.class,由 Java编译器实现。</li>
<li>执行：由.class变为.html,用Java虚拟机执行编译文件,然后将执行结果返回给Web服务器，并最终返回给客户端</li>
</ul>
</li>
<li>如果不是第一次访问某个JSP页面，则只执行第三步。所以第一次访问JSP较慢。</li>
</ul>
<h1 id="CGI-Servlet-JSP的比较"><a href="#CGI-Servlet-JSP的比较" class="headerlink" title="CGI&#x2F;Servlet&#x2F;JSP的比较"></a>CGI&#x2F;Servlet&#x2F;JSP的比较</h1><ul>
<li>CGI(Common Gateway Interface)，通用网关接口,是一种根据请求信息动态产生回应内容的技术。通过CGI，Web 服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于每个请求，都要产生一个新的进程进行处理。</li>
<li>Servlet 是在服务器上运行的小程序。在实际运行的时候Java Servlet与Web服务器会融为一体。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。</li>
<li>JSP从本质上说就是Servlet。JSP技术产生于Servlet之后，两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。</li>
<li>与CGI相比，Servlet效率更高。Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet 。</li>
<li>与CGI相比，Servlet更容易使用，功能更强大，具有更好的可移植性，更节省投资。在未来的技术发展过程中，Servlet有可能彻底取代CGI。</li>
</ul>
<h1 id="JSP-ASP-PHP的比较"><a href="#JSP-ASP-PHP的比较" class="headerlink" title="JSP&#x2F;ASP&#x2F;PHP的比较"></a>JSP&#x2F;ASP&#x2F;PHP的比较</h1><ul>
<li>ASP(Active Server Pages),JSP(JavaServer Pages),PHP(Hypertext Preprocessor)是目前主流的三种动态网页语言。</li>
<li>ASP是微软（Microsoft）所开发的一种后台脚本语言，它的语法和Visual BASIC类似，可以像SSI（Server Side Include）那样把后台脚本代码内嵌到HTML页面中。虽然ASP简单易用，但是它自身存在着许多缺陷，最重要的就是安全性问题。</li>
<li>PHP是一种跨平台的服务器端的嵌入式脚本语言。它大量地借用C,Java和Perl语言的语法, 并耦合PHP自己的特性,使WEB开发者能够快速地写出动态产生页面。它支持目前绝大多数数据库。</li>
<li>JSP是一个简化的Servlet，它是由Sun公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML中插入Java程序段和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。</li>
<li>ASP优点:无需编译、易于生成、独立于浏览器、面向对象、与任何ActiveX scripting 语言兼容、源程序码不会外漏。</li>
<li>ASP缺点:<ul>
<li>Windows本身的所有问题都会一成不变的也累加到了它的身上。安全性、稳定性、跨平台性都会因为与NT的捆绑而显现出来。</li>
<li>ASP由于使用了COM组件所以它会变的十分强大，但是这样的强大由于Windows NT系统最初的设计问题而会引发大量的安全问题。只要在这样的组件或是操作中一不注意，那么外部攻击就可以取得相当高的权限而导致网站瘫痪或者数据丢失。</li>
<li>还无法完全实现一些企业级的功能：完全的集群、负载均横。</li>
</ul>
</li>
<li>PHP优点：<ul>
<li>一种能快速学习、跨平台、有良好数据库交互能力的开发语言。</li>
<li>简单轻便，易学易用。</li>
<li>与Apache及其它扩展库结合紧密。</li>
</ul>
</li>
<li>PHP缺点：<ul>
<li>数据库支持的极大变化。</li>
<li>不适合应用于大型电子商务站点。</li>
</ul>
</li>
<li>JSP优点：<ul>
<li>一处编写随处运行。</li>
<li>系统的多台平支持。</li>
<li>强大的的可伸缩性。</li>
<li>多样化和功能强大的开发工具支持。</li>
</ul>
</li>
<li>JSP缺点：<ul>
<li>与ASP一样，Java的一些优势正是它致命的问题所在。</li>
<li>开发速度慢</li>
</ul>
</li>
</ul>
<h1 id="http的响应码"><a href="#http的响应码" class="headerlink" title="http的响应码"></a>http的响应码</h1><ul>
<li>200 - 确定。客户端请求已成功</li>
<li>302 - 临时移动转移，请求的内容已临时移动新的位置</li>
<li>404 - 未找到文件或目录</li>
<li>500 - 服务器内部错误</li>
</ul>
<h1 id="Session域和request域什么区别？"><a href="#Session域和request域什么区别？" class="headerlink" title="Session域和request域什么区别？"></a>Session域和request域什么区别？</h1><ul>
<li>作用域：存放数据，获取数据（传递数据）</li>
<li>有效的作用域：生命周期，作用范围</li>
<li>http<ul>
<li>生命周期 ：一次请求之间</li>
<li>作用范围：所有被请求转发过的servlet都能获取到httpSession:</li>
</ul>
</li>
<li>Servelt<ul>
<li>生命周期：一次会话</li>
<li>作用范围：所有的servlet都可以获取到servletContex:</li>
</ul>
</li>
<li>Request:<ul>
<li>生命周期：从项目开始运行到服务器关闭</li>
<li>作用范围：所有的servlet都可以获取到</li>
</ul>
</li>
<li>作用域如何选用？<ul>
<li>httpServeltRequest：和当前请求有关的信息</li>
<li>httpSession：和当前用户有关的信息</li>
<li>servletContex：访问量比较大，不易更改</li>
</ul>
</li>
</ul>
<h1 id="如何给weblogic定内存的大小？"><a href="#如何给weblogic定内存的大小？" class="headerlink" title="如何给weblogic定内存的大小？"></a>如何给weblogic定内存的大小？</h1><ul>
<li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li>
</ul>
<h1 id="Java-Web-开发的-Model-1-和-Model-2-分别指的是什么？"><a href="#Java-Web-开发的-Model-1-和-Model-2-分别指的是什么？" class="headerlink" title="Java Web 开发的 Model 1 和 Model 2 分别指的是什么？"></a>Java Web 开发的 Model 1 和 Model 2 分别指的是什么？</h1><ul>
<li>Model 1 是以页面为中心的 Java Web 开发，只适合非常小型的应用程序，Model 2是基于 MVC 架构模式的应用，这一点在前文的面试题中已经详细讲解过了</li>
<li>说说什么是框架：框架(framework)是一个框子–》指约束性，也是一个架子–》指支撑性 IT 语境中的框架，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，在此结构上可以根据具体问题扩展、按插更多的组成部分，从而更迅速和方便地架构完整的解决问题的方案。<ul>
<li>框架本身一般不完整到可以解决特定问题，但是可以帮助您快速解决特定问题：没有框架所有的工作都从零开始做，有了框架，为我们提供了一定的功能。我们就可以在框架的基础上开发，极大的解决了生产力。不同的框架，是为了解决不同领域的问题，一定要为了解决问题才去学习框架。</li>
<li>框架天生就是为了扩展而设计的</li>
<li>框架里面可以为后续的组件提供很多辅助性、支撑性的方便易用的实用工具(utilities)，也就是框架时常配套一些帮组解决某类问题的库(libraries）或工具（tools）</li>
</ul>
</li>
</ul>
<h1 id="简单说一下-MVC-框架？"><a href="#简单说一下-MVC-框架？" class="headerlink" title="简单说一下 MVC 框架？"></a>简单说一下 MVC 框架？</h1><ul>
<li>是为了解决传统 MVC 模式(jsp+servlet+javabean)一些问题而出现的框架</li>
<li>传统 MVC 模式模式问题：<ul>
<li>所有的 Servlet 和 Servlet 映射都要配置在 web.xml 中，如果项目太大，web.xml就太庞大并且不能实现模块化管理。</li>
<li>Servlet 的主要功能就是接受参数、调用逻辑、跳转页面，比如像其他字符编码、文件上传等功能也要写在 Servlet 中，不能让 Servlet 主要功能而需要做处理一些特例。</li>
<li>接受参数比较麻烦，(String name &#x3D; request.getParameter(“name”))，不能通过 model 接受，只能单个接收，接收完成后转换封装 model。</li>
<li>跳转页面方式比较单一(forward,redirect)，并且当我们的页面名称发生改变时需要改变 Servlet 源代码。</li>
</ul>
</li>
<li>现在比较常用的 MVC 框架：<ul>
<li>webwork</li>
<li>Struts</li>
<li>Struts2</li>
<li>SpringMVC</li>
</ul>
</li>
</ul>
<h1 id="模式完成分页功能的基本思路是什么？"><a href="#模式完成分页功能的基本思路是什么？" class="headerlink" title="模式完成分页功能的基本思路是什么？"></a>模式完成分页功能的基本思路是什么？</h1><ul>
<li>页面提交页码(第几页)到 Servlet 中</li>
<li>Servlet 接收到页码后，将页码传递给分页工具类(PageBean)</li>
<li>Servlet 中调用 Service 层传入 PageBean 对象</li>
<li>Service 层调用 DAO 层传入 PageBean 对象</li>
<li>Servlet 中得到查询出来的数据，并 setAttrivute 保存</li>
<li>在页面中得到(getAttribute)数据，遍历输出</li>
</ul>
<h1 id="MVC-模式及其优缺点"><a href="#MVC-模式及其优缺点" class="headerlink" title="MVC 模式及其优缺点"></a>MVC 模式及其优缺点</h1><h4 id="MVC-原理"><a href="#MVC-原理" class="headerlink" title="MVC 原理"></a>MVC 原理</h4><ul>
<li>MVC 是一种程序开发设计模式,它实现了显示模块与功能模块的分离</li>
<li>提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度</li>
<li>它主要分模型、视图、控制器三层。<ul>
<li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li>
<li>视图(view) 用户与之交互的界面、在 web 中视图一般由 jsp,html 组成</li>
<li>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用</li>
</ul>
</li>
</ul>
<h4 id="MVC-的优点"><a href="#MVC-的优点" class="headerlink" title="MVC 的优点"></a>MVC 的优点</h4><ul>
<li>降低代码耦合性。在 MVC 模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。</li>
<li>有利于分工合作。在 MVC 模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的 JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。</li>
<li>有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。</li>
</ul>
<h4 id="MVC-的不足之处"><a href="#MVC-的不足之处" class="headerlink" title="MVC 的不足之处"></a>MVC 的不足之处</h4><ul>
<li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循 MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li>
<li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li>
<li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li>
<li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应 MVC 需要和建立分离的部件的代价是很高的，从而造成 MVC 使用的困难。</li>
</ul>
<h1 id="说说你对容器的理解"><a href="#说说你对容器的理解" class="headerlink" title="说说你对容器的理解"></a>说说你对容器的理解</h1><ul>
<li>容器也是 java 程序，它的主要作用是为应用程序提供运行环境</li>
<li>容器用来接管安全性、并发性、事务处理、交换到辅助存储器和其它服务的责任</li>
<li>以 tomcat 为例：Tomcat 是一个后台服务进程，其它的 servlet（相当于 DLL）是在 Tomcat容器内运行,Broswer 只与 Tomcat 通迅; Tomcat 接受 browser 的请求，经过一系列动作（如果是静态网页，那么装载，按 http 协议形成响应流;如果是动态的如 JSP，那就要调用 JDK 中的 servlet.jsp 接口，解释形成静态网页，按 http 协议生成响应流发送回browser）后，形成静态网页，返回响应。</li>
</ul>
<h1 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h1><ul>
<li>同源策略&#x2F;SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略</li>
<li>如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源</li>
</ul>
<h1 id="什么是-JsonP？"><a href="#什么是-JsonP？" class="headerlink" title="什么是 JsonP？"></a>什么是 JsonP？</h1><ul>
<li>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</li>
</ul>
<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><ul>
<li>跨域是指一个域（网站）下的文档或脚本试图去请求另一个域（网站）下的资源。</li>
</ul>
<h1 id="怎么防止重复提交"><a href="#怎么防止重复提交" class="headerlink" title="怎么防止重复提交"></a>怎么防止重复提交</h1><ul>
<li>禁掉提交按钮。表单提交后使用 Javascript 使提交按钮 disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把 Javascript 给禁止掉，这种方法就无效了。</li>
<li>Post&#x2F;Redirect&#x2F;Get 模式。在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按 F5 导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</li>
<li>在 session 中存放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。</li>
<li>在数据库里添加约束。在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。</li>
</ul>
<h1 id="阐述-Session-加载实体对象的过程。"><a href="#阐述-Session-加载实体对象的过程。" class="headerlink" title="阐述 Session 加载实体对象的过程。"></a>阐述 Session 加载实体对象的过程。</h1><ul>
<li>Session 加载实体对象的步骤是：<ul>
<li>Session 在调用数据库查询功能之前, 首先会在缓存中进行查询, 在一级缓存中, 通过实体类型和主键进行查找, 如果一级缓存查找命中且数据状态合法, 则直接返回</li>
<li>如果一级缓存没有命中, 接下来 Session 会在当前 NonExists 记录(相当于一个查询黑名单, 如果出现重复的无效查询可以迅速判断, 从而提升性能)中进行查找, 如果NonExists 中存在同样的查询条件,则返回 null</li>
<li>对于 load 方法, 如果一级缓存查询失败则查询二级缓存, 如果二级缓存命中则直接返回</li>
<li>如果之前的查询都未命中, 则发出 SQL 语句, 如果查询未发现对应记录则将此次查询添加到 Session 的 NonExists 中加以记录, 并返回 null</li>
<li>根据映射配置和 SQL 语句得到 ResultSet,并创建对应的实体对象</li>
<li>将对象纳入 Session(一级缓存)管理</li>
<li>执行拦截器的 onLoad 方法(如果有对应的拦截器)</li>
<li>将数据对象纳入二级缓存</li>
<li>返回数据对象</li>
</ul>
</li>
</ul>
<h1 id="Servlet-3-中的异步处理指的是什么？"><a href="#Servlet-3-中的异步处理指的是什么？" class="headerlink" title="Servlet 3 中的异步处理指的是什么？"></a>Servlet 3 中的异步处理指的是什么？</h1><ul>
<li>在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交给 Executor（如果不清楚请查看前文关于多线程和线程池的部分）并立即返回即可。</li>
</ul>
<h1 id="过滤器有哪些作用和用法？-1"><a href="#过滤器有哪些作用和用法？-1" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h1><ul>
<li>Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在Servlet 2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web 容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果<br>有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。</li>
<li>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT等。</li>
<li>和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain</li>
</ul>
<h1 id="静态网页和动态网页的联系和区别"><a href="#静态网页和动态网页的联系和区别" class="headerlink" title="静态网页和动态网页的联系和区别"></a>静态网页和动态网页的联系和区别</h1><ul>
<li>联系：<ul>
<li>静态网页是网站建设的基础，静态网页和动态网页都要使用到 HTMl 语言。  </li>
<li>静态网页是相对于动态网页而言，指没有后台数据库、不含程序和不可交互的网页、是标准的 HTML 文件，它的文件扩展名是.htm 或.html。你编的是什么它显示的就是什么、不会有任何改变。</li>
<li>静态网页和动态网页之间并不矛盾，为了网站适应搜索引擎检索的需要，动态网站可以采用静动结合的原则，适合采用动态网页的地方用动态网页，如果必要使用静态网页，则可以考虑用静态网页的方法来实现，在同一个网站上，动态网页内容和静态网页内容同时存在也是很常见的事情。</li>
</ul>
</li>
<li>区别：<ul>
<li>程序是否在服务器端运行，是重要标志。在服务器端运行的程序、网页、组件，属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如 ASP、PHP、JSP、ASP.net、CGI 等。运行于客户端的程序、网页、插件、组件，属于静态网页，例如 html页、Flash、javascript、VBscript 等等，它们是永远不变的。</li>
<li>编程技术不同。静态网页和动态网页主要根据网页制作的语言来区分。静态网页使用语言：HTML。 动态网页使用语言：HTML＋ASP 或 HTML＋PHP 或 HTML＋JSP 等其它网站动态语言。</li>
<li>被搜索引擎收录情况不同。由于编程技术不容，静态网页是纯粹 HTML 格式的网页，页面内容稳定，不论是网页是否被访问，页面都被保存在网站服务器上，很容易被搜索引擎收录。而动态网页的内容是当用户点击请求时才从数据库中调出返回给用户一个网页的内容，并不是存放在服务器上的独立文件，相比较于静态网页而言，动态网页很难被搜索引擎收录。</li>
<li>用户访问速度不同。用户访问动态网页时，网页在获得搜索指令后经过数据库的调查匹配，再将与指令相符的内容传递给服务器，通过服务器的编译将网页编译成标准的 HTML 代码，从而传递给用户浏览器，多个读取过程大大降低了用户的访问速度。而静态网页不同，由于网页内容直接存取在服务器上，省去了服务器的编译过程，用户访问网页速度很快。</li>
<li>制作和后期维护工作量不同。动态网页的设计以数据库技术为基础，可以实现多种功能，降低了网站维护的工作量。而静态网页由于没有数据库的支持，网页内容更改时需要直接修改代码，在网站内容制作和维护中，所需的工作量更大。动态网页与静态网页各有特点，网站设计师在网页设计时，主要根据网站的功能需求和网站内容多少选择不同网页。如，网站包含信息量太大时，就需要选择动态网页，反之，则选择静态网页。</li>
</ul>
</li>
</ul>
<h1 id="Session-的基本原理是什么？"><a href="#Session-的基本原理是什么？" class="headerlink" title="Session 的基本原理是什么？"></a>Session 的基本原理是什么？</h1><ul>
<li>Session 对象的原理在于，服务器可以为客户端创建并维护一个所谓的 Session 对象，用于存放数据。在创建 Session 对象的同时，服务器将会为该 Session 对象产生一个唯一编号，这个编号称之为 SessionID，服务器以 Cookie 的方式将 SessionID 存放在客户端。当浏览器再次访问该服务器时，会将 SessionID 作为 Cookie 信息带到服务器，服务器可以通过该SessionID 检索到以前的 Session 对象，并对其进行访问。需要注意的是，此时的 Cookie 中仅仅保存了一个 SessionID，而相对较多的会话数据保存在服务器端对应的 Session 对象中，由服务器来统一维护，这样一定程度保证了会话数据安全性，但增加了服务器端的内存开销。</li>
<li>存放在客户端的用于保存 SessionID 的 Cookie 会在浏览器关闭时清除。我们把用户打开一个浏览器访问某个应用开始，到关闭浏览器为止交互过程称为一个 “会话”。在一个“会话”过程中，可能会向同一个应用发出了多次请求，这些请求将共享一个 Session 对象，因为这些请求携带了相同的 SessionID 信息。Session 对象的正常使用要依赖于 Cookie。如果考虑到客户端浏览器可能出于安全的考虑禁用了 Cookie，应该使用 URL 重写的方式使 Session 在客户端禁用 Cookie 的情况下继续生效。</li>
</ul>
<h1 id="谈谈对-XML-的理解？说明-Web-应用中-Web-xml-文件的作用？"><a href="#谈谈对-XML-的理解？说明-Web-应用中-Web-xml-文件的作用？" class="headerlink" title="谈谈对 XML 的理解？说明 Web 应用中 Web.xml 文件的作用？"></a>谈谈对 XML 的理解？说明 Web 应用中 Web.xml 文件的作用？</h1><ul>
<li>XML（Extensible Markup Language）即可扩展标记语言，它与 HTML 一样，都是SGML(Standard Generalized Markup Language,标准通用标记语言)。Xml 是 Internet 环境中跨平台的，依赖于内容的技术，是当前处理结构化文档信息的有力工具。扩展标记语言 XML 是一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式建立，虽然 XML 占用的空间比二进制数据要占用更多的空间，但 XML 极其简单易于掌握和使用。</li>
<li>web.xml 的作用是配置欢迎页，servlet，filter，listener 等的。</li>
</ul>
<h1 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h1><ul>
<li>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</li>
</ul>
]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/publishes/22829df8f04f.html</url>
    <content><![CDATA[<h1 id="获得Class对象的⽅式"><a href="#获得Class对象的⽅式" class="headerlink" title="获得Class对象的⽅式"></a>获得Class对象的⽅式</h1><ul>
<li>静态类的.class语法：GuideUtil.class</li>
<li>普通类对象的getClass()⽅法：new Test().getClass()</li>
<li>通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”);</li>
<li>对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE</li>
</ul>
<h1 id="在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>在 Java 中，为什么不允许从静态方法中访问非静态变量？</h1><ul>
<li>因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联</li>
</ul>
<h1 id="在-Java-中，什么时候用重载，什么时候用重写？"><a href="#在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="在 Java 中，什么时候用重载，什么时候用重写？"></a>在 Java 中，什么时候用重载，什么时候用重写？</h1><ul>
<li>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding）</li>
<li>而重载（overloading）是用不同的输入做同一件事</li>
<li>在 Java 中，重载的方法签名不同，而重写并不是。</li>
</ul>
<h1 id="举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>举例说明什么情况下会更倾向于使用抽象类而不是接口？</h1><ul>
<li>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求</li>
<li>在 Java 中，你只能继承一个类，但可以实现多个接口</li>
<li>所以一旦你继承了一个类，你就失去了继承其他类的机会了。</li>
<li>接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable(注：这里的意思是指如果把 Runnable 等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</li>
<li>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</li>
<li>如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择</li>
<li>有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</li>
</ul>
<h1 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h1><ul>
<li>调用该访问返回一个以字符串指定类名的类的对象。</li>
</ul>
<h1 id="Jdo是什么"><a href="#Jdo是什么" class="headerlink" title="Jdo是什么?"></a>Jdo是什么?</h1><ul>
<li>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API</li>
<li>JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）</li>
<li>这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上</li>
<li>另外，JDO很灵活，因为它可以在任何数据底层上运行</li>
<li>JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。</li>
</ul>
<h1 id="HashMap-，HashTable-区别"><a href="#HashMap-，HashTable-区别" class="headerlink" title="HashMap ，HashTable 区别"></a>HashMap ，HashTable 区别</h1><ul>
<li>默认容量不同。扩容不同</li>
<li>线程安全性，HashTable 安全</li>
<li>效率不同 HashTable 要慢因为加锁</li>
</ul>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul>
<li>数组 + 链表方式存储</li>
<li>默认容量：11(质数 为宜)</li>
<li>put:<ul>
<li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li>
<li>若在链表中找到了，则替换旧值，若未找到则继续</li>
<li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li>
<li>将新元素加到链表头部</li>
<li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。</li>
</ul>
</li>
</ul>
<h1 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h1><ul>
<li>默认的负载因子大小为0.75</li>
<li>也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组来重新调整map的大小，并将原来的对象放入新的bucket数组中。</li>
<li>这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</li>
</ul>
<h1 id="EJB与JavaBean的区别？"><a href="#EJB与JavaBean的区别？" class="headerlink" title="EJB与JavaBean的区别？"></a>EJB与JavaBean的区别？</h1><ul>
<li>Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于JavaBean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器。另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。</li>
<li>Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。</li>
</ul>
<h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</li>
<li>下面列出了使用封装的一些好处：<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交互提高模块化</li>
</ul>
</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul>
<li>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</li>
</ul>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul>
<li>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</li>
</ul>
<h1 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h1><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul>
<li>修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。</li>
</ul>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul>
<li>在异常处理时提供 finally 块来执行任何清除操作</li>
<li>如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</li>
</ul>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ul>
<li>方法名</li>
<li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</li>
<li>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</li>
</ul>
<h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h4 id="override（重写）"><a href="#override（重写）" class="headerlink" title="override（重写）"></a>override（重写）</h4><ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为final不能被重写。</li>
</ul>
<h4 id="overload（重载）"><a href="#overload（重载）" class="headerlink" title="overload（重载）"></a>overload（重载）</h4><ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
<h1 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h1><ul>
<li>接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。</li>
<li>还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。</li>
</ul>
<h1 id="Java1-7与1-8-1-9-10-新特性"><a href="#Java1-7与1-8-1-9-10-新特性" class="headerlink" title="Java1.7与1.8,1.9,10 新特性"></a>Java1.7与1.8,1.9,10 新特性</h1><h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4><ul>
<li>switch中可以使用字串了</li>
<li>运用List tempList &#x3D; new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断</li>
<li>语法上支持集合，而不一定是数组</li>
<li>新增一些取环境信息的工具方法</li>
<li>Boolean类型反转，空指针安全,参与位运算</li>
<li>两个char间的equals</li>
<li>安全的加减乘除</li>
<li>map集合支持并发请求，且可以写成 Map map &#x3D; {name:”xxx”,age:18};</li>
</ul>
<h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><ul>
<li>允许在接口中有默认方法实现</li>
<li>Lambda表达式</li>
<li>函数式接口</li>
<li>方法和构造函数引用</li>
<li>Lambda的范围</li>
<li>内置函数式接口</li>
<li>Streams</li>
<li>Parallel Streams</li>
<li>Map</li>
<li>时间日期API</li>
<li>Annotations</li>
</ul>
<h4 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h4><ul>
<li>Jigsaw 项目;模块化源码</li>
<li>简化进程API</li>
<li>轻量级 JSON API</li>
<li>钱和货币的API</li>
<li>改善锁争用机制</li>
<li>代码分段缓存</li>
<li>智能Java编译, 第二阶段</li>
<li>HTTP 2.0客户端</li>
<li>Kulla计划: Java的REPL实现</li>
</ul>
<h1 id="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"><a href="#解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI" class="headerlink" title="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"></a>解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI</h1><ul>
<li>web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。</li>
<li>EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。</li>
<li>JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</li>
<li>JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</li>
<li>JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</li>
<li>JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</li>
<li>RMI&#x2F;IIOP:（Remote Method Invocation &#x2F;internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。</li>
</ul>
<h1 id="Class类的作用？生成Class对象的方法有哪些？"><a href="#Class类的作用？生成Class对象的方法有哪些？" class="headerlink" title="Class类的作用？生成Class对象的方法有哪些？"></a>Class类的作用？生成Class对象的方法有哪些？</h1><ul>
<li>Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类</li>
<li>Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口</li>
<li>方法示例<ul>
<li>getClass()</li>
<li>getSuperClass()</li>
<li>.class</li>
<li>.TYPE</li>
</ul>
</li>
</ul>
<h1 id="序列化的定义、实现和注意事项"><a href="#序列化的定义、实现和注意事项" class="headerlink" title="序列化的定义、实现和注意事项"></a>序列化的定义、实现和注意事项</h1><ul>
<li>想把一个对象写在硬盘上或者网络上，对其进行序列化，把他序列化成为一个字节流。</li>
<li>实现和注意事项：<ul>
<li>实现接口Serializable Serializable接口中没有任何的方法，实现该接口的类不需要实现额外的方法。</li>
<li>如果对象中的某个属性是对象类型，必须也实现Serializable接口才可以，序列化对静态变量无效</li>
<li>如果不希望某个属性参与序列化，不是将其static，而是transient</li>
</ul>
</li>
<li>串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存</li>
<li>序列化版本不兼容</li>
</ul>
<h1 id="java-sql-Date和java-util-Date的联系和区别"><a href="#java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="java.sql.Date和java.util.Date的联系和区别"></a>java.sql.Date和java.util.Date的联系和区别</h1><ul>
<li>java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</li>
<li>JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002&#x2F;05&#x2F;22 5:00:57 PM的字段，读取日期时得到的是2002&#x2F;05&#x2F;22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.sql.Timestamp类比java.util.Date类精确度要高。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用…</li>
<li>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。</li>
</ul>
<h1 id="String-s-new-String-“xyz”-创建几个String-Object"><a href="#String-s-new-String-“xyz”-创建几个String-Object" class="headerlink" title="String s &#x3D; new String(“xyz”);创建几个String Object?"></a>String s &#x3D; new String(“xyz”);创建几个String Object?</h1><ul>
<li>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个</li>
<li>New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象</li>
<li>如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</li>
</ul>
<h1 id="String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？"><a href="#String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？" class="headerlink" title="String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？"></a>String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？</h1><ul>
<li>没有改变。</li>
<li>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</li>
</ul>
<h1 id="基本数据类型有哪些"><a href="#基本数据类型有哪些" class="headerlink" title="基本数据类型有哪些"></a>基本数据类型有哪些</h1><ul>
<li>byte、short、char、int、long、float、double、boolean</li>
</ul>
<h1 id="String、StringBuffer、StringBuilder区别与联系"><a href="#String、StringBuffer、StringBuilder区别与联系" class="headerlink" title="String、StringBuffer、StringBuilder区别与联系"></a>String、StringBuffer、StringBuilder区别与联系</h1><ul>
<li>String类是字符序列不可变的类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。</li>
<li>StringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setChartAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String</li>
<li>JDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder</li>
</ul>
<h1 id="String类为什么是final的"><a href="#String类为什么是final的" class="headerlink" title="String类为什么是final的"></a>String类为什么是final的</h1><ul>
<li>为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。</li>
<li>为了安全。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的， 和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的， 这不就成了核心病毒了么？</li>
<li>不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性， 如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点；</li>
</ul>
<h1 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h1><ul>
<li>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</li>
<li>int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</li>
<li>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</li>
<li>Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</li>
</ul>
<h1 id="异常处理中throws和throw的区别"><a href="#异常处理中throws和throw的区别" class="headerlink" title="异常处理中throws和throw的区别"></a>异常处理中throws和throw的区别</h1><ul>
<li>作用不同：<ul>
<li>throw用于程序员自行产生并抛出异常；</li>
<li>throws用于声明在该方法内抛出了异常</li>
</ul>
</li>
<li>使用的位置不同：<ul>
<li>throw位于方法体内部，可以作为单独语句使用；</li>
<li>throws必须跟在方法参数列表的后面，不能单独使用。</li>
</ul>
</li>
<li>内容不同：<ul>
<li>throw抛出一个异常对象，且只能是一个；</li>
<li>throws后面跟异常类，而且可以有多个。</li>
</ul>
</li>
</ul>
<h1 id="Java异常处理try-catch-finally的执行过程"><a href="#Java异常处理try-catch-finally的执行过程" class="headerlink" title="Java异常处理try-catch-finally的执行过程"></a>Java异常处理try-catch-finally的执行过程</h1><ul>
<li>try-catch-finally程序块的执行流程以及执行结果比较复杂。</li>
<li>基本执行过程如下：<ul>
<li>程序首先执行可能发生异常的try语句块。</li>
<li>如果try语句没有出现异常则执行完后跳至finally语句块执行；</li>
<li>如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。</li>
<li>catch语句块可以有多个，分别捕获不同类型的异常。</li>
<li>catch语句块执行完后程序会继续执行finally语句块。</li>
</ul>
</li>
<li>finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。需要注意的是即使try和catch块中存在return语句，finally语句也会执行，是在执行完finally语句后再通过return退出。</li>
</ul>
<h1 id="运行时异常与受检异常有何异同"><a href="#运行时异常与受检异常有何异同" class="headerlink" title="运行时异常与受检异常有何异同"></a>运行时异常与受检异常有何异同</h1><ul>
<li>运行时异常：包括RuntimeaException及其所有子类。不要求程序必须对它们作出处理，比如InputMismatchException、ArithmeticException、NullPointerException等。即使没有显示使用try-catch或throws进行处理，仍旧可以进行编译和运行(其实是JVM隐式的使用try-catch或throws进行处理)。如果运行时发生异常，会输出异常的堆栈信息并中止程序执行。</li>
<li>Checked异常（非运行时异常）：除了运行时异常外的其他异常类都是Checked异常，程序必须捕获或者声明抛出这种异常，否则出现编译错误，无法通过编译。处理方式包括两种：通过try-catch捕获异常，通过throws声明抛出异常从而交给上一级调用方法处理。</li>
</ul>
<h1 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h1><ul>
<li>Error类，表示仅靠程序本身无法恢复的严重错误，比如说内存溢出、动态链接异常、虚拟机错误。应用程序不应该抛出这种类型的对象。假如出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。所以在进行程序设计时，应该更关注Exception类。</li>
<li>Exception类，由Java应用程序抛出和处理的非严重错误，比如所需文件没有找到、零作除数，数组下标越界等。它的各种不同子类分别对应不同类型异常。可分为两类：Checked异常和Runtime异常</li>
</ul>
<h1 id="和equals的区别和联系"><a href="#和equals的区别和联系" class="headerlink" title="&#x3D;&#x3D;和equals的区别和联系"></a>&#x3D;&#x3D;和equals的区别和联系</h1><ul>
<li>“&#x3D;&#x3D;”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</li>
<li>“&#x3D;&#x3D;”使用情况如下：<ul>
<li>基本类型，比较的是值</li>
<li>引用类型，比较的是地址</li>
<li>不能比较没有父子关系的两个对象</li>
</ul>
</li>
<li>equals()方法使用如下：<ul>
<li>系统类一般已经覆盖了equals()，比较的是内容。</li>
<li>用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this &#x3D;&#x3D; obj);）</li>
<li>用户自定义类需要覆盖父类的equals()</li>
</ul>
</li>
<li>注意：Object的&#x3D;&#x3D;和equals比较的都是地址，作用相同</li>
</ul>
<h1 id="继承条件下构造方法的执行过程"><a href="#继承条件下构造方法的执行过程" class="headerlink" title="继承条件下构造方法的执行过程"></a>继承条件下构造方法的执行过程</h1><ul>
<li>继承条件下构造方法的调用规则如下：<ul>
<li>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</li>
<li>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li>
<li>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</li>
</ul>
</li>
<li>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li>
</ul>
<h1 id="权限修饰符的区别"><a href="#权限修饰符的区别" class="headerlink" title="权限修饰符的区别"></a>权限修饰符的区别</h1><ul>
<li>类的访问权限只有两种<ul>
<li>public 公共的   可被同一项目中所有的类访问。 (必须与文件名同名)</li>
<li>default 默认的  可被同一个包中的类访问。</li>
</ul>
</li>
<li>成员（成员变量或成员方法）访问权限共有四种：<ul>
<li>public 公共的  可以被项目中所有的类访问。(项目可见性)</li>
<li>protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）</li>
<li>default 默认的被这个类本身访问；被同一个包中的类访问。（包可见性）</li>
<li>private 私有的只能被这个类本身访问。（类可见性）</li>
</ul>
</li>
</ul>
<h1 id="final和abstract关键字的作用"><a href="#final和abstract关键字的作用" class="headerlink" title="final和abstract关键字的作用"></a>final和abstract关键字的作用</h1><ul>
<li>final和abstract是功能相反的两个关键字，可以对比记忆</li>
<li>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</li>
<li>final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</li>
<li>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li>
</ul>
<h1 id="static关键字的作用（修饰变量、方法、代码块）"><a href="#static关键字的作用（修饰变量、方法、代码块）" class="headerlink" title="static关键字的作用（修饰变量、方法、代码块）"></a>static关键字的作用（修饰变量、方法、代码块）</h1><ul>
<li>static可以修饰变量、方法、代码块和内部类</li>
<li>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</li>
<li>static变量和非static变量的区别(都是成员变量，不是局部变量)<ul>
<li>在内存中份数不同<ul>
<li>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</li>
<li>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</li>
</ul>
</li>
<li>在内存中存放的位置不同<ul>
<li>静态变量存在方法区中，实例变量存在堆内存中</li>
</ul>
</li>
<li>访问的方式不同<ul>
<li>实例变量： 对象名.变量名  stu1.name&#x3D;”小明明”;</li>
<li>静态变量：对象名.变量名  stu1.schoolName&#x3D;”西二旗小学”; 不推荐如此使用</li>
<li>类名.变量名  Student.schoolName&#x3D;”东三旗小学”; 推荐使用</li>
</ul>
</li>
<li>在内存中分配空间的时间不同<ul>
<li>实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候</li>
<li>Student.schoolName&#x3D;”东三旗小学”;或者Student stu1 &#x3D; new Student(“小明”,”男”,20,98);</li>
<li>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</li>
<li>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</li>
<li>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="this和super关键字的作用"><a href="#this和super关键字的作用" class="headerlink" title="this和super关键字的作用"></a>this和super关键字的作用</h1><ul>
<li>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题</li>
<li>this可以调用成员变量，不能调用局部变量</li>
<li>this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句，而且在静态方法当中不允许出现this关键字。</li>
<li>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</li>
<li>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</li>
</ul>
<h1 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h1><ul>
<li>面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li>
<li>封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</li>
<li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</li>
</ul>
<h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><ul>
<li>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</li>
<li>类和对象好比图纸和实物的关系，模具和铸件的关系。</li>
</ul>
<h1 id="可变参数的作用和特点"><a href="#可变参数的作用和特点" class="headerlink" title="可变参数的作用和特点"></a>可变参数的作用和特点</h1><ul>
<li>可变参数<ul>
<li>可变参数的形式  …</li>
<li>可变参数只能是方法的形参</li>
<li>可变参数对应的实参可以0,1,2…..个，也可以是一个数组</li>
<li>在可变参数的方法中，将可变参数当做数组来处理</li>
<li>可变参数最多有一个，只能是最后一个</li>
<li>可变参数好处：方便  简单  减少重载方法的数量</li>
<li>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</li>
</ul>
</li>
<li>数组做形参和可变参数做形参联系和区别</li>
<li>联系：<br>  -实参都可以是数组；2.方法体中，可变参数当做数组来处理</li>
<li>区别：<ul>
<li>个数不同	可变参数只能有一个数组参数可以多个</li>
<li>位置不同	可变参数只能是最后一个	数组参数位置任意</li>
<li>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</li>
</ul>
</li>
</ul>
<h1 id="递归的定义和优缺点"><a href="#递归的定义和优缺点" class="headerlink" title="递归的定义和优缺点"></a>递归的定义和优缺点</h1><ul>
<li>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</li>
<li>递归算法解决问题的特点：<ul>
<li>递归就是在过程或函数里调用自身。</li>
<li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
<li>递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</li>
<li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</li>
</ul>
</li>
</ul>
<h1 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h1><ul>
<li>break: 结束当前循环并退出当前循环体。</li>
<li>break还可以退出switch语句</li>
<li>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。</li>
</ul>
<h1 id="while和do-while循环的区别"><a href="#while和do-while循环的区别" class="headerlink" title="while和do-while循环的区别"></a>while和do-while循环的区别</h1><ul>
<li>while先判断后执行，第一次判断为false,循环体一次都不执行</li>
<li>do while先执行 后判断，最少执行1次。</li>
<li>如果while循环第一次判断为true, 则两种循环没有区别。</li>
</ul>
<h1 id="用最有效率的方法算出2乘以8等于多少"><a href="#用最有效率的方法算出2乘以8等于多少" class="headerlink" title="用最有效率的方法算出2乘以8等于多少"></a>用最有效率的方法算出2乘以8等于多少</h1><ul>
<li>使用位运算来实现效率最高</li>
<li>位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数</li>
<li>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高</li>
<li>所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</li>
</ul>
<h1 id="和-的区别和联系，-和-的区别和联系"><a href="#和-的区别和联系，-和-的区别和联系" class="headerlink" title="&amp;和&amp;&amp;的区别和联系，|和||的区别和联系"></a>&amp;和&amp;&amp;的区别和联系，|和||的区别和联系</h1><ul>
<li>&amp;和&amp;&amp;的联系(共同点)：<ul>
<li>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</li>
<li>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</li>
<li>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</li>
<li>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li>
<li>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li>
<li>表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</li>
</ul>
</li>
<li>&amp;和&amp;&amp;的区别(不同点)<ul>
<li>&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。</li>
<li>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</li>
<li>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</li>
<li>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</li>
<li>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</li>
</ul>
</li>
<li>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</li>
</ul>
<h1 id="i-和-i的异同之处"><a href="#i-和-i的异同之处" class="headerlink" title="i++和++i的异同之处"></a>i++和++i的异同之处</h1><ul>
<li>共同点：<ul>
<li>i++和++i都是变量自增1，都等价于i&#x3D;i+1</li>
<li>如果i++,++i是一条单独的语句，两者没有任何区别</li>
<li>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</li>
</ul>
</li>
<li>不同点：<ul>
<li>如果i++,++i不是一条单独的语句，他们就有区别</li>
<li>i++ ：先运算后增1。如：int x&#x3D;5;</li>
<li>int y&#x3D;x++;</li>
<li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li>
<li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;5++i ： 先增1后运算。如： </li>
<li>int x&#x3D;5;</li>
<li>int y&#x3D;++x;</li>
<li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li>
<li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;6334.</li>
</ul>
</li>
</ul>
<h1 id="JDK-JRE-JVM三者关系概括如下："><a href="#JDK-JRE-JVM三者关系概括如下：" class="headerlink" title="JDK,JRE,JVM三者关系概括如下："></a>JDK,JRE,JVM三者关系概括如下：</h1><ul>
<li>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE</li>
<li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了</li>
<li>JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li>
</ul>
<h1 id="Java跨平台原理"><a href="#Java跨平台原理" class="headerlink" title="Java跨平台原理"></a>Java跨平台原理</h1><ul>
<li>C&#x2F;C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</li>
<li>Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</li>
<li>字节码文件不面向任何具体平台，只面向虚拟机。</li>
<li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li>
<li>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C&#x2F;C++要低。</li>
<li>Java的跨平台原理决定了其性能没有C&#x2F;C++高</li>
</ul>
<h1 id="Java的安全性"><a href="#Java的安全性" class="headerlink" title="Java的安全性"></a>Java的安全性</h1><ul>
<li>语言层次的安全性主要体现在：<ul>
<li>Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</li>
<li>垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。</li>
<li>异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</li>
<li>强制类型转换：只有在满足强制转换规则的情况下才能强转成功。</li>
</ul>
</li>
<li>底层的安全性可以从以下方面来说明<ul>
<li>Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。</li>
</ul>
</li>
<li>在运行环境提供了四级安全性保障机制：<ul>
<li>字节码校验器 -类装载器 -运行时内存布局 -文件访问限制</li>
</ul>
</li>
</ul>
<h1 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h1><ul>
<li>对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术</li>
<li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（可以用XML或者是注解），将Java程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</li>
</ul>
<h1 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h1><ul>
<li>DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作</li>
<li>为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中</li>
<li>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法</li>
<li>在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储</li>
<li>DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</li>
</ul>
<h1 id="UML是什么？UML中有哪些图？"><a href="#UML是什么？UML中有哪些图？" class="headerlink" title="UML是什么？UML中有哪些图？"></a>UML是什么？UML中有哪些图？</h1><ul>
<li>UML是统一建模语言（Unified Modeling Language）的缩写，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为</li>
<li>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等</li>
<li>在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</li>
</ul>
<h1 id="Java-中有几种类型的流？"><a href="#Java-中有几种类型的流？" class="headerlink" title="Java 中有几种类型的流？"></a>Java 中有几种类型的流？</h1><ul>
<li>两种流分别是字节流，字符流。</li>
<li>字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer</li>
<li>在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</li>
<li>关于Java的IO需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</li>
</ul>
<h1 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h1><ul>
<li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间</li>
<li>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</li>
<li>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</li>
</ul>
<h1 id="什么时候用assert？"><a href="#什么时候用assert？" class="headerlink" title="什么时候用assert？"></a>什么时候用assert？</h1><ul>
<li>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制</li>
<li>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。</li>
</ul>
<h1 id="比较一下Java-和JavaSciprt"><a href="#比较一下Java-和JavaSciprt" class="headerlink" title="比较一下Java 和JavaSciprt"></a>比较一下Java 和JavaSciprt</h1><ul>
<li>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。</li>
<li>下面对两种语言间的异同作如下比较：<ul>
<li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</li>
<li>解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</li>
<li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</li>
<li>代码格式不一样。</li>
</ul>
</li>
<li>上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</li>
</ul>
<p> </p>
<h1 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h1><ul>
<li><p>代码如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = &quot;你好&quot;;</span><br><span class="line">String s2 = newString(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); </span><br></pre></td></tr></table></figure>
</li>
<li><p>在String类的构造方法当中，存在一个字符集设置的方法</p>
</li>
</ul>
<h1 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h1><ul>
<li>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</li>
<li>如果要访问外部类的局部变量，此时局部变量必须使用final修饰，否则无法访问。</li>
</ul>
<h1 id="匿名内部类是否可以继承其它类？是否可以实现接口？"><a href="#匿名内部类是否可以继承其它类？是否可以实现接口？" class="headerlink" title="匿名内部类是否可以继承其它类？是否可以实现接口？"></a>匿名内部类是否可以继承其它类？是否可以实现接口？</h1><ul>
<li>可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。</li>
</ul>
<h1 id="一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h1><ul>
<li>可以，但一个源文件中最多只能有一个公开类（public class）</li>
<li>而且文件名必须和公开类的类名完全保持一致。</li>
</ul>
<p> </p>
<h1 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h1><ul>
<li>接口可以继承接口</li>
<li>抽象类可以实现(implements)接口，抽象类可以继承具体类</li>
<li>抽象类中可以有静态的main方法。</li>
</ul>
<h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><ul>
<li>有两种方式：<ul>
<li>实现Cloneable接口并重写Object类中的clone()方法；</li>
<li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</li>
</ul>
</li>
<li>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</li>
</ul>
<h1 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h1><ul>
<li>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</li>
</ul>
<p> </p>
<h1 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h1><ul>
<li>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝</li>
<li>实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存</li>
<li>两者的相同点：都有默认值而且在类的任何地方都可以调用</li>
</ul>
<h1 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h1><ul>
<li>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的</li>
<li>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li>
<li>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li>
</ul>
<h1 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h1><ul>
<li>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）</li>
<li>然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露</li>
<li>一个例子就是hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象</li>
</ul>
<h1 id="静态内部类和内部类有什么区别"><a href="#静态内部类和内部类有什么区别" class="headerlink" title="静态内部类和内部类有什么区别"></a>静态内部类和内部类有什么区别</h1><ul>
<li>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</li>
<li>内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</li>
<li>在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类</li>
<li>Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class</li>
<li>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</li>
<li>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化</li>
</ul>
<h1 id="char-型变量中能不能存贮一个中文汉字-为什么"><a href="#char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char 型变量中能不能存贮一个中文汉字?为什么?"></a>char 型变量中能不能存贮一个中文汉字?为什么?</h1><ul>
<li>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦</li>
</ul>
<h1 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h1><ul>
<li>是值传递</li>
<li>Java 编程语言只有值传递参数</li>
<li>当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用</li>
<li>对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。</li>
</ul>
<h1 id="是否可以继承String-类"><a href="#是否可以继承String-类" class="headerlink" title="是否可以继承String 类?"></a>是否可以继承String 类?</h1><ul>
<li>String 类是final类，不可以被继承。</li>
</ul>
<h1 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</h1><ul>
<li>不对</li>
<li>如果两个对象x和y满足x.equals(y) &#x3D;&#x3D;++++ true，它们的哈希码（hash code）应当相同</li>
<li>Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同</li>
</ul>
<h1 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）?"></a>构造器（constructor）是否可被重写（override）?</h1><ul>
<li>构造器不能被继承，因此不能被重写，但可以被重载。</li>
</ul>
<h1 id="在Java-中，如何跳出当前的多重嵌套循环？"><a href="#在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java 中，如何跳出当前的多重嵌套循环？"></a>在Java 中，如何跳出当前的多重嵌套循环？</h1><ul>
<li>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</li>
<li>Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好</li>
</ul>
<h1 id="数组有没有length-方法-String-有没有length-方法？"><a href="#数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="数组有没有length()方法?String 有没有length()方法？"></a>数组有没有length()方法?String 有没有length()方法？</h1><ul>
<li>数组没有length()方法，有length 的属性</li>
<li>String 有length()方法</li>
<li>JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</li>
</ul>
<h1 id="swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h1><ul>
<li>早期的JDK中，switch（expr）中，expr可以是byte、short、char、int</li>
<li>从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举</li>
<li>从JDK 1.7版开始，还可以是字符串（String）</li>
<li>长整型（long）是不可以的。</li>
</ul>
<h1 id="Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?"></a>Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h1><ul>
<li>Math.round(11.5)的返回值是12</li>
<li>Math.round(-11.5)的返回值是-11</li>
<li>四舍五入的原理是在参数上加0.5然后进行下取整。</li>
</ul>
<p> </p>
<h1 id="解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h1><ul>
<li><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间</p>
</li>
<li><p>而通过new关键字和构造器创建的对象放在堆空间</p>
</li>
<li><p>程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中</p>
</li>
<li><p>栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“hello”);</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。</p>
</li>
<li><p>较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p>
</li>
</ul>
<h1 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h1><ul>
<li>&amp;运算符有两种用法<ul>
<li>按位与</li>
<li>逻辑与</li>
</ul>
</li>
<li>&amp;&amp;运算符是短路与运算</li>
<li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true</li>
<li>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</li>
<li>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常</li>
<li>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</li>
</ul>
<h1 id="Java-有没有goto"><a href="#Java-有没有goto" class="headerlink" title="Java 有没有goto?"></a>Java 有没有goto?</h1><ul>
<li>goto 是Java中的保留字，在目前版本的Java中没有使用</li>
<li>其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字</li>
</ul>
<h1 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?</h1><ul>
<li>对于short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型</li>
<li>而short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为s1+&#x3D; 1;相当于s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。</li>
</ul>
<h1 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确?"></a>float f&#x3D;3.4;是否正确?</h1><ul>
<li>不正确</li>
<li>3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成float f &#x3D;3.4F;。</li>
</ul>
<h1 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h1><ul>
<li>不是</li>
<li>Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</li>
</ul>
<h1 id="访问修饰符的区别？"><a href="#访问修饰符的区别？" class="headerlink" title="访问修饰符的区别？"></a>访问修饰符的区别？</h1><table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同包</th>
<th>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ul>
<li>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</li>
</ul>
<p> </p>
<h1 id="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><a href="#如果变量用final修饰，则怎样？如果方法final修饰，则怎样？" class="headerlink" title="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"></a>如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</h1><ul>
<li>用final修饰的类不能被扩展，也就是说不可能有子类；</li>
<li>用final修饰的方法不能被替换或隐藏：<ul>
<li>使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</li>
<li>使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏	（hidden）；</li>
</ul>
</li>
<li>用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：<ul>
<li>静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，		赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，	赋值只能在其声明中通过初始化表达式完成；</li>
<li>实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通	过初始化表达式完成，也可以在实例初始化块或构造器中进行；</li>
<li>方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体	（body）结束，在此期间其值不能改变；</li>
<li>构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，	同时被初始化为对应实参值，终止于构造器体结束，在此期间其值不能改变；</li>
<li>异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化	为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</li>
<li>局部变量在其值被访问之前必须被明确赋值；</li>
</ul>
</li>
</ul>
<h1 id="成员变量用static修饰和不用static修饰有什么区别？"><a href="#成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="成员变量用static修饰和不用static修饰有什么区别？"></a>成员变量用static修饰和不用static修饰有什么区别？</h1><ul>
<li>两个变量的生命周期不同。<ul>
<li>成员变量随着对象的创建而存在，随着对象的被回收而释放。</li>
<li>静态变量随着类的加载而存在，随着类的消失而消失。</li>
</ul>
</li>
<li>调用方式不同。<ul>
<li>成员变量只能被对象调用。</li>
<li>静态变量可以被对象调用，还可以被类名调用。</li>
<li>对象调用：p.country</li>
<li>类名调用 ：Person.country</li>
</ul>
</li>
<li>别名不同。<ul>
<li>成员变量也称为实例变量。</li>
<li>静态变量称为类变量。</li>
</ul>
<p> </p>
</li>
<li>数据存储位置不同。<ul>
<li>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.</li>
<li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.</li>
</ul>
</li>
</ul>
<h1 id="System-out-println-‘a’-1-的结果是"><a href="#System-out-println-‘a’-1-的结果是" class="headerlink" title="System.out.println(‘a’+1);的结果是"></a>System.out.println(‘a’+1);的结果是</h1><ul>
<li>‘a’是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98</li>
</ul>
<h1 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h1><ul>
<li>NullPointerException：一般都是在null对象上调用方法了。</li>
<li>NumberFormatException：继承IllegalArgumentException，字符串转换为数字时。</li>
<li>StringIndexOutOfBoundsException：字符串越界</li>
<li>ClassCastException:类型转换错误</li>
</ul>
<h1 id="200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><a href="#200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？" class="headerlink" title="200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"></a>200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</h1><ul>
<li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li>
<li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序</li>
<li>Collections 工具类的sort方法有两种重载的形式<ul>
<li>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较</li>
<li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li>
</ul>
</li>
</ul>
<h1 id="199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><a href="#199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？" class="headerlink" title="199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"></a>199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</h1><ul>
<li>构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法</li>
</ul>
<h1 id="char型变量中能不能存储一个中文汉字？"><a href="#char型变量中能不能存储一个中文汉字？" class="headerlink" title="char型变量中能不能存储一个中文汉字？"></a>char型变量中能不能存储一个中文汉字？</h1><ul>
<li>java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。</li>
<li>char 在java中是2个字节，所以可以存储中文</li>
</ul>
<h1 id="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"><a href="#创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。" class="headerlink" title="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"></a>创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</h1><ul>
<li>用一个for循环创建线程对象并调用start方法启动线程。</li>
</ul>
<h1 id="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><a href="#Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？" class="headerlink" title="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"></a>Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</h1><ul>
<li>Map的实现类有HashMap,LinkedHashMap,TreeMap</li>
<li>HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序；TreeMap默认是自然升序）</li>
<li>LinkedHashMap底层存储结构是哈希表+链表，链表记录了添加数据的顺序</li>
<li>TreeMap底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性</li>
<li>LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表</li>
</ul>
<h1 id="try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？"><a href="#try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？" class="headerlink" title="try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？"></a>try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？</h1><ul>
<li>在异常处理时提供 finally 块来执行任何清除操作。</li>
<li>如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。</li>
<li>finally中语句不执行的唯一情况中执行了System.exit(0)语句。</li>
</ul>
<h1 id="什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>什么是编译型语言，什么是解释型语言？java可以归类到那种？</h1><ul>
<li>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。</li>
<li>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。</li>
<li>解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。</li>
<li>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C&#x2F;C++、Pascal&#x2F;Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。</li>
<li>JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</li>
</ul>
<h1 id="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h1><ul>
<li>final修饰基本类型变量，其值不能改变。</li>
<li>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li>
</ul>
<h1 id="Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="Class类的getDeclaredFields()方法与getFields()的区别？"></a>Class类的getDeclaredFields()方法与getFields()的区别？</h1><ul>
<li>getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法</li>
<li>getFields(): 只能获取所有public声43明的方法, 包括继承的方法</li>
</ul>
<h1 id="103-可序列化对象为什么要定义serialversionUID值"><a href="#103-可序列化对象为什么要定义serialversionUID值" class="headerlink" title="103.可序列化对象为什么要定义serialversionUID值?"></a>103.可序列化对象为什么要定义serialversionUID值?</h1><ul>
<li>SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容</li>
<li>如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常</li>
<li>如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</li>
</ul>
<h1 id="GC线程是否为守护线程？"><a href="#GC线程是否为守护线程？" class="headerlink" title="GC线程是否为守护线程？"></a>GC线程是否为守护线程？</h1><ul>
<li>GC线程是守护线程</li>
<li>线程分为守护线程和非守护线程（即用户线程）。只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。</li>
</ul>
<h1 id="不通过构造函数也能创建对象么"><a href="#不通过构造函数也能创建对象么" class="headerlink" title="不通过构造函数也能创建对象么"></a>不通过构造函数也能创建对象么</h1><ul>
<li>是</li>
<li>Java创建对象的几种方式：<ul>
<li>用new语句创建对象，这是最常见的创建对象的方法。</li>
<li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li>
<li>调用对象的clone()方法。</li>
<li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ul>
</li>
<li>(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。</li>
</ul>
<h1 id="同步代码块和同步方法有什么区别"><a href="#同步代码块和同步方法有什么区别" class="headerlink" title="同步代码块和同步方法有什么区别"></a>同步代码块和同步方法有什么区别</h1><ul>
<li>相同点：同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为this，那么同步方法和同步代码块没有太大的区别。</li>
<li>区别：同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</li>
</ul>
<h1 id="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><a href="#Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？" class="headerlink" title="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"></a>Java中，如果Manager是Employee的子类，那么Pair<Manager>是Pair<Employee>的子类吗？</h1><ul>
<li>不是，两者没有任何关联。</li>
</ul>
<h1 id="简述Java中如何实现多态"><a href="#简述Java中如何实现多态" class="headerlink" title="简述Java中如何实现多态"></a>简述Java中如何实现多态</h1><ul>
<li>实现多态有三个前提条件：<ul>
<li>继承的存在；（继承是多态的基础，没有继承就没有多态）。</li>
<li>子类重写父类的方法。（多态下会调用子类重写后的方法）。</li>
<li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</li>
</ul>
</li>
<li>最后使用父类的引用变量调用子类重写的方法即可实现多态。</li>
</ul>
<h1 id="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h1><ul>
<li>在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt;K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt;K, V&gt;可以理解为HashMap&lt;Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型</li>
<li>引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。</li>
</ul>
<h1 id="对象在虚拟机的大小中可不可以用size-of取出。"><a href="#对象在虚拟机的大小中可不可以用size-of取出。" class="headerlink" title="对象在虚拟机的大小中可不可以用size of取出。"></a>对象在虚拟机的大小中可不可以用size of取出。</h1><ul>
<li>可以</li>
</ul>
<h1 id="什么是-JMS？"><a href="#什么是-JMS？" class="headerlink" title="什么是 JMS？"></a>什么是 JMS？</h1><ul>
<li>JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。</li>
</ul>
<h1 id="JMS-有哪些模型？"><a href="#JMS-有哪些模型？" class="headerlink" title="JMS 有哪些模型？"></a>JMS 有哪些模型？</h1><ul>
<li>JMS 消息机制主要分为两种模型：PTP 模型和 Pub&#x2F;Sub 模型。</li>
</ul>
<h4 id="PTP-模型"><a href="#PTP-模型" class="headerlink" title="PTP 模型"></a>PTP 模型</h4><ul>
<li>（Point to Point 对点模型) 每一个消息传递给一个消息消费者，保证消息传递给消息消费者，且消息不会同时被多个消费者接收。如果消息消费者暂时不在连接范围内，JMS 会自动保证消息不会丢失，直到消息消费者进入连接，消息将自动送达。因此，JMS 需要将消息保存到永久性介质上，例如数据库或者文件。</li>
</ul>
<h4 id="Pub-Sub-模型"><a href="#Pub-Sub-模型" class="headerlink" title="Pub-Sub 模型"></a>Pub-Sub 模型</h4><ul>
<li>(publish-subscription 发布者订阅者模型)每个主题可以拥有多个订阅者。JMS 系统负责将消息的副本传给该主题的每个订阅者。如果希望每一条消息都能够被处理，那么应该使用 PTP 消息模型。如果并不要求消息都必须被消息消费者接收到的情况下，可使用 pub-sub 消息模型。Pub-Sub 模型可以在一对多的消息广播时使用。</li>
</ul>
<h1 id="为什么不能根据返回类型来区分重载，为什么？"><a href="#为什么不能根据返回类型来区分重载，为什么？" class="headerlink" title="为什么不能根据返回类型来区分重载，为什么？"></a>为什么不能根据返回类型来区分重载，为什么？</h1><ul>
<li>方法的重载，即使返回值类型不同，也不能改变实现功能相同或类似这一既定事实</li>
<li>同时方法的重载只是要求两同三不同，即在同一个类中，相同的方法名称，参数列表当中的参数类型、个数、顺序不同；跟权限修饰符和返回值类无关</li>
</ul>
<h1 id="Java-中-byte-表示的数值范围是什么？"><a href="#Java-中-byte-表示的数值范围是什么？" class="headerlink" title="Java 中 byte 表示的数值范围是什么？"></a>Java 中 byte 表示的数值范围是什么？</h1><ul>
<li>范围是-128 至 127</li>
</ul>
<h1 id="在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？"><a href="#在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？" class="headerlink" title="在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？"></a>在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？</h1><ul>
<li>不正确。</li>
<li>通常情况下，进行比较判断的处理，switch 和 if-else 可以互相转换来写；</li>
<li>if-else 作用的范围比 switch-case 作用范围要大，但是当 switch-case 和 if-else 都可以用的情况下，通常推荐使用 switch-case。</li>
</ul>
<h1 id="Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？"><a href="#Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？" class="headerlink" title="Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？"></a>Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？</h1><ul>
<li>Java 程序中创建新的类对象，使用关键字 new 是正确的</li>
<li>回收无用的类对象使用关键字 free 是错误的.</li>
</ul>
<h1 id="存在使-i-1"><a href="#存在使-i-1" class="headerlink" title="存在使 i+1&lt;i 的数么?"></a>存在使 i+1&lt;i 的数么?</h1><ul>
<li>存在, int 的最大值, 加 1 后变为负数.</li>
</ul>
<h1 id="Java-中-Math-random（）-Math-random（）值为？"><a href="#Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="Java 中 Math.random（）&#x2F; Math.random（）值为？"></a>Java 中 Math.random（）&#x2F; Math.random（）值为？</h1><ul>
<li>如果除数与被除数均不为 0.0 的话，则取值范围为[0, +∞]。+∞在 Java 中显示的结果为 Infinity。</li>
<li>如果除数与被除数均为 0.0 的话，则运行结果为 NaN（Not a Number 的简写），计算错误。</li>
</ul>
<h1 id="匿名内部类可不可以继承或实现接口。为什么？"><a href="#匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="匿名内部类可不可以继承或实现接口。为什么？"></a>匿名内部类可不可以继承或实现接口。为什么？</h1><ul>
<li>匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现.</li>
<li>由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把<br>创建对象的任务交给了父类去完成。</li>
<li>在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。</li>
<li>因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。</li>
</ul>
<h1 id="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？"><a href="#说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？" class="headerlink" title="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？"></a>说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？</h1><ul>
<li>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；比如申请了一个 integer,但给它存了long 才能存下的数，那就是内存溢出。</li>
<li>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li>
<li>memory leak 会最终会导致 out of memory！</li>
</ul>
<h1 id="为什么为基本类型引入包装类"><a href="#为什么为基本类型引入包装类" class="headerlink" title="为什么为基本类型引入包装类"></a>为什么为基本类型引入包装类</h1><ul>
<li>基本数据类型有方便之处，简单、高效。</li>
<li>但是 Java 中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是 Object）。</li>
<li>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</li>
<li>包装类和基本数据类型之间的转换<ul>
<li>包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</li>
<li>包装类——-new WrapperClass(primitive) new WrapperClass(string)——基本数据类型</li>
</ul>
</li>
<li>自动装箱和自动拆箱<ul>
<li>JDK1.5 提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换</li>
</ul>
</li>
<li>包装类还可以实现基本类型变量和字符串之间的转换<ul>
<li>基本类型变量&lt;————String.valueof()————&gt;字符串</li>
<li>基本类型变量&lt;————WrapperClass.parseXxx(string)————字符串</li>
</ul>
</li>
</ul>
<h1 id="谈谈-Java-的多态"><a href="#谈谈-Java-的多态" class="headerlink" title="谈谈 Java 的多态"></a>谈谈 Java 的多态</h1><ul>
<li>实现多态的三个条件（前提条件，向上转型、向下转型）<ul>
<li>继承的存在；（继承是多态的基础，没有继承就没有多态）</li>
<li>子类重写父类的方法。（多态下会调用子类重写后的方法）</li>
<li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）</li>
</ul>
</li>
<li>向上转型 Student person &#x3D; new Student()</li>
<li>将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。</li>
<li>此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法此时通过父类引用变量无法调用子类特有的方法。</li>
<li>向下转型 Student stu &#x3D; (Student)person;</li>
<li>将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类型，否则将出现 ClassCastException，不是任意的强制转换向下转型时可以结合使用 instanceof 运算符进行强制类型转换，比如出现转换异常—ClassCastException</li>
</ul>
<h1 id="if-多分支语句和-switch-多分支语句的异同之处"><a href="#if-多分支语句和-switch-多分支语句的异同之处" class="headerlink" title="if 多分支语句和 switch 多分支语句的异同之处"></a>if 多分支语句和 switch 多分支语句的异同之处</h1><ul>
<li>相同之处：都是分支语句，多超过一种的情况进行判断处理。</li>
<li>不同之处：<ul>
<li>switch 更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有 break 跳出），不加判断地执行下去;而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。</li>
<li>switch 为等值判断（不允许比如&gt;&#x3D; &lt;&#x3D;），而 if 为等值和区间都可以，if 的使用范围大。</li>
</ul>
</li>
</ul>
<h1 id="基本数据类型的类型转换规则"><a href="#基本数据类型的类型转换规则" class="headerlink" title="基本数据类型的类型转换规则"></a>基本数据类型的类型转换规则</h1><ul>
<li>基本类型转换分为自动转换和强制转换。</li>
<li>自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的<br>范围。</li>
<li>强制转换规则：高级变为低级需要强制转换。</li>
<li>如何转换：<ul>
<li>赋值运算符“&#x3D;”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</li>
<li>赋值运算符“&#x3D;”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 &#x3D;&#x3D; 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li>
<li>可以将整型常量直接赋值给 byte, short, char 等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li>
</ul>
</li>
</ul>
<h1 id="Java-三种注释类型"><a href="#Java-三种注释类型" class="headerlink" title="Java 三种注释类型"></a>Java 三种注释类型</h1><ul>
<li>共有单行注释、多行注释、文档注释 3 种注释类型</li>
</ul>
<h1 id="谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么"><a href="#谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么" class="headerlink" title="谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?"></a>谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?</h1><ul>
<li>Java本身是一种面向对象的语言,最显著的特点有两个方面,一个是所谓的”书写一次,到处运行”;能够非常容易地获得跨平台能力;另外就是垃圾收集器(GC)，Java通过垃圾收集器回收分配内存,大部分情况下,程序员不需要自己操心内存的分配和回收。我们日常接触到JRE或者JDK。JRE也就是Java运行环境,包含了JVM和Java类库,以及一些模块等。而JDK可以看作是JRE的一个超集,提供了更多的工具,比如编译器 各种诊断工具。</li>
<li>“对于Java是解释执行”这句话,这个说法不准确。我们开发的Java的源代码,首先通过Javac编译成为字节码,然后在运行时通过Java虚拟机内嵌的解释器将字节码转换为最终的机器码。但是常见的JVM,比如我们大数据情况使用的Oracle JDK提供的HostpotJVM,提供了JIT编译器,就是通常所说的动态编译器,JIT能够在运行时将热点代码(高频调用的方法和代码块)编译成机器码,这种情况下部分热点就属于编译执行,而不是解释执行。这样类似于缓存技术,运行时在遇到热点代码可以直接执行,而不是先解释在执行。</li>
</ul>
<h1 id="NoClassDeFoundError和ClassNotFoundException的区别"><a href="#NoClassDeFoundError和ClassNotFoundException的区别" class="headerlink" title="NoClassDeFoundError和ClassNotFoundException的区别?"></a>NoClassDeFoundError和ClassNotFoundException的区别?</h1><ul>
<li>首先NoClassDeFoundError是一个错误,ClassNotFoundException是一个异常。ClassNotFoundException的产生原因,Java支持使用Class.froName方法来动态地加载类,任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中,如果这个类在类路径中没有被找到,那么此时就会在运行时抛出ClassNotFoundException异常。另外还有一个导致ClassNotFoundException的原因就是,当一个类已经被某个类加载器加载到内存中,此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li>
<li>NoClassDeFoundError产生的原因在于:如果JVM或者ClassLoader实例尝试加载类的时候找不到类的定义。例如要查找的类在编译的时候是存在的,运行的时候找不到了。这个时候就会导致NoClassDefFoundError。造成该问题的原因可能是打包过程中漏掉了部分类,或者jar包出现损坏或者篡改。解决这个问题的办法就是查找那些在开发期间存在与类路径下,但在运行期间却不在类路径下的类。</li>
</ul>
<h1 id="一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数"><a href="#一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数" class="headerlink" title="一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?"></a>一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?</h1><ul>
<li>用 super 关键字,子类去调用父类的方法，如：super.myMethod();子类去调用父类的构造函数，如：super()</li>
</ul>
<h1 id="Bit-和-Byte-是什么意思-它们之间有什么关系"><a href="#Bit-和-Byte-是什么意思-它们之间有什么关系" class="headerlink" title="Bit 和 Byte 是什么意思?它们之间有什么关系?"></a>Bit 和 Byte 是什么意思?它们之间有什么关系?</h1><ul>
<li>bit 中文名称是位，是用以描述电脑数据量的最小单位。</li>
<li>byte（字节）是计算机信息技术用于计量存储容量和传输容量的一种计量单位 1byte&#x3D;8bit</li>
</ul>
<h1 id="什么是-java-序列化，如何实现-java-序列化？"><a href="#什么是-java-序列化，如何实现-java-序列化？" class="headerlink" title="什么是 java 序列化，如何实现 java 序列化？"></a>什么是 java 序列化，如何实现 java 序列化？</h1><ul>
<li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；</li>
<li>序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream) 来 构 造 一 个 ObjectOutputStream( 对 象 流 ) 对 象 ， 接 着 ， 使 用ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。</li>
</ul>
<h1 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h1><ul>
<li>Lambda表达式的本质只是一个”语法糖”,由编译器推断并帮我们转换包装为常规的代码,因此我们可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘。</li>
<li>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许我们通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。</li>
<li>Lambda表达式还增强了集合库。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。</li>
</ul>
<h1 id="获取用键盘输入常用的的两种方法"><a href="#获取用键盘输入常用的的两种方法" class="headerlink" title="获取用键盘输入常用的的两种方法"></a>获取用键盘输入常用的的两种方法</h1><ul>
<li>通过 Scanner</li>
<li>通过 BufferedReader</li>
</ul>
<h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><ul>
<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>
<li>拆箱：将包装类型转换为基本数据类型；</li>
</ul>
<h1 id="JAVA-复制"><a href="#JAVA-复制" class="headerlink" title="JAVA 复制"></a>JAVA 复制</h1><ul>
<li>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</li>
</ul>
<h4 id="直接赋值复制"><a href="#直接赋值复制" class="headerlink" title="直接赋值复制"></a>直接赋值复制</h4><ul>
<li>直接赋值。在 Java 中，A a1 &#x3D; a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。</li>
</ul>
<h4 id="浅复制（复制引用但不复制引用的对象）"><a href="#浅复制（复制引用但不复制引用的对象）" class="headerlink" title="浅复制（复制引用但不复制引用的对象）"></a>浅复制（复制引用但不复制引用的对象）</h4><ul>
<li>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。</li>
<li>因此，原始对象及其副本引用同一个对象。</li>
</ul>
<h4 id="深复制（复制对象和其应用对象）"><a href="#深复制（复制对象和其应用对象）" class="headerlink" title="深复制（复制对象和其应用对象）"></a>深复制（复制对象和其应用对象）</h4><ul>
<li>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</li>
</ul>
<h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><ul>
<li>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List&lt;Object&gt;和 List&lt;String&gt;等类型，在编译之后</li>
<li>都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</li>
<li>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</li>
</ul>
<h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h1><ul>
<li>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数</li>
<li>例 如 List&lt;?&gt; 在逻辑上是 List&lt;String&gt;,List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt;的父类。</li>
</ul>
<h1 id="创建对象的两种方法"><a href="#创建对象的两种方法" class="headerlink" title="创建对象的两种方法"></a>创建对象的两种方法</h1><ul>
<li>Class 对象的 newInstance()<ul>
<li>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</li>
</ul>
</li>
<li>调用 Constructor 对象的 newInstance()<ul>
<li>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</li>
</ul>
</li>
</ul>
<h1 id="Java-中，Serializable-与-Externalizable-的区别？"><a href="#Java-中，Serializable-与-Externalizable-的区别？" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别？"></a>Java 中，Serializable 与 Externalizable 的区别？</h1><ul>
<li>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</li>
</ul>
<h1 id="OOP-中的-组合、聚合和关联有什么区别？"><a href="#OOP-中的-组合、聚合和关联有什么区别？" class="headerlink" title="OOP 中的 组合、聚合和关联有什么区别？"></a>OOP 中的 组合、聚合和关联有什么区别？</h1><ul>
<li>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B组合的，则 A 不存在的话，B 一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</li>
</ul>
<h1 id="Java-中，嵌套公共静态类与顶级类有什么不同？"><a href="#Java-中，嵌套公共静态类与顶级类有什么不同？" class="headerlink" title="Java 中，嵌套公共静态类与顶级类有什么不同？"></a>Java 中，嵌套公共静态类与顶级类有什么不同？</h1><ul>
<li>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</li>
</ul>
<h1 id="继承和组合之间有什么不同？"><a href="#继承和组合之间有什么不同？" class="headerlink" title="继承和组合之间有什么不同？"></a>继承和组合之间有什么不同？</h1><ul>
<li>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</li>
</ul>
<h1 id="我们能自己写一个容器类，然后使用-for-each-循环码？"><a href="#我们能自己写一个容器类，然后使用-for-each-循环码？" class="headerlink" title="我们能自己写一个容器类，然后使用 for-each 循环码？"></a>我们能自己写一个容器类，然后使用 for-each 循环码？</h1><ul>
<li>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</li>
</ul>
<h1 id="写一段代码在遍历-ArrayList-时移除一个元素？"><a href="#写一段代码在遍历-ArrayList-时移除一个元素？" class="headerlink" title="写一段代码在遍历 ArrayList 时移除一个元素？"></a>写一段代码在遍历 ArrayList 时移除一个元素？</h1><ul>
<li>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</li>
</ul>
<h1 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a>Java 中的 HashSet，内部是如何工作的？</h1><ul>
<li>HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。</li>
</ul>
<h1 id="Java-中的-TreeMap-是采用什么树实现的？"><a href="#Java-中的-TreeMap-是采用什么树实现的？" class="headerlink" title="Java 中的 TreeMap 是采用什么树实现的？"></a>Java 中的 TreeMap 是采用什么树实现的？</h1><ul>
<li>Java 中的 TreeMap 是使用红黑树实现的。</li>
</ul>
<h1 id="Java-中的-LinkedList-是单向链表还是双向链表？"><a href="#Java-中的-LinkedList-是单向链表还是双向链表？" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表？"></a>Java 中的 LinkedList 是单向链表还是双向链表？</h1><ul>
<li>是双向链表，你可以检查 JDK 的源码</li>
</ul>
<h1 id="Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？</h1><ul>
<li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li>
</ul>
<h1 id="poll-方法和-remove-方法的区别？"><a href="#poll-方法和-remove-方法的区别？" class="headerlink" title="poll() 方法和 remove() 方法的区别？"></a>poll() 方法和 remove() 方法的区别？</h1><ul>
<li>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</li>
</ul>
<h1 id="Java-中的编译期常量是什么？使用它又什么风险？"><a href="#Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="Java 中的编译期常量是什么？使用它又什么风险？"></a>Java 中的编译期常量是什么？使用它又什么风险？</h1><ul>
<li>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</li>
</ul>
<h1 id="我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？"><a href="#我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？" class="headerlink" title="我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？"></a>我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？</h1><ul>
<li>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</li>
</ul>
<h1 id="3-0-1-0-3-将会返回什么？true-还是-false？"><a href="#3-0-1-0-3-将会返回什么？true-还是-false？" class="headerlink" title="3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？"></a>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？</h1><ul>
<li>false，因为有些浮点数不能完全精确的表示出来。</li>
</ul>
<h1 id="int-和-Integer-哪个会占用更多的内存？"><a href="#int-和-Integer-哪个会占用更多的内存？" class="headerlink" title="int 和 Integer 哪个会占用更多的内存？"></a>int 和 Integer 哪个会占用更多的内存？</h1><ul>
<li>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。</li>
<li>但是 int 是一个原始类型的数据，所以占用的空间更少。</li>
</ul>
<h1 id="为什么-Java-中的-String-是不可变的（Immutable）？"><a href="#为什么-Java-中的-String-是不可变的（Immutable）？" class="headerlink" title="为什么 Java 中的 String 是不可变的（Immutable）？"></a>为什么 Java 中的 String 是不可变的（Immutable）？</h1><ul>
<li>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。</li>
</ul>
<h1 id="我们能在-Switch-中使用-String-吗？"><a href="#我们能在-Switch-中使用-String-吗？" class="headerlink" title="我们能在 Switch 中使用 String 吗？"></a>我们能在 Switch 中使用 String 吗？</h1><ul>
<li>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</li>
</ul>
<h1 id="Java-中的构造器链是什么？"><a href="#Java-中的构造器链是什么？" class="headerlink" title="Java 中的构造器链是什么？"></a>Java 中的构造器链是什么？</h1><ul>
<li>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</li>
</ul>
<h1 id="什么是-Busy-spin？我们为什么要使用它？"><a href="#什么是-Busy-spin？我们为什么要使用它？" class="headerlink" title="什么是 Busy spin？我们为什么要使用它？"></a>什么是 Busy spin？我们为什么要使用它？</h1><ul>
<li>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。</li>
<li>所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</li>
</ul>
<h1 id="Swing-是线程安全的？"><a href="#Swing-是线程安全的？" class="headerlink" title="Swing 是线程安全的？"></a>Swing 是线程安全的？</h1><ul>
<li>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。</li>
<li>这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</li>
</ul>
<h1 id="什么是线程局部变量？"><a href="#什么是线程局部变量？" class="headerlink" title="什么是线程局部变量？"></a>什么是线程局部变量？</h1><ul>
<li>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</li>
</ul>
<h1 id="Java-中应该使用什么数据类型来代表价格？"><a href="#Java-中应该使用什么数据类型来代表价格？" class="headerlink" title="Java 中应该使用什么数据类型来代表价格？"></a>Java 中应该使用什么数据类型来代表价格？</h1><ul>
<li>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的double 类型。</li>
</ul>
<h1 id="怎么将-byte-转换为-String？"><a href="#怎么将-byte-转换为-String？" class="headerlink" title="怎么将 byte 转换为 String？"></a>怎么将 byte 转换为 String？</h1><ul>
<li>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</li>
</ul>
<h1 id="我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h1><ul>
<li>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。</li>
</ul>
<h1 id="哪个类包含-clone-方法？是-Cloneable-还是-Object？"><a href="#哪个类包含-clone-方法？是-Cloneable-还是-Object？" class="headerlink" title="哪个类包含 clone 方法？是 Cloneable 还是 Object？"></a>哪个类包含 clone 方法？是 Cloneable 还是 Object？</h1><ul>
<li>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由c 或 c++ 或 其他本地语言实现的。</li>
</ul>
<h1 id="Java-中-操作符是线程安全的吗？"><a href="#Java-中-操作符是线程安全的吗？" class="headerlink" title="Java 中 ++ 操作符是线程安全的吗？"></a>Java 中 ++ 操作符是线程安全的吗？</h1><p> 不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p>
<h1 id="a-a-b-与-a-b-的区别"><a href="#a-a-b-与-a-b-的区别" class="headerlink" title="a &#x3D; a + b 与 a +&#x3D; b 的区别"></a>a &#x3D; a + b 与 a +&#x3D; b 的区别</h1><ul>
<li>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是a +&#x3D; b 没问题，如下：<ul>
<li>byte a &#x3D; 127;</li>
<li>byte b &#x3D; 127;</li>
<li>b &#x3D; a + b; &#x2F;&#x2F; error : cannot convert from int to byte</li>
<li>b +&#x3D; a; &#x2F;&#x2F; ok</li>
</ul>
</li>
</ul>
<h1 id="什么是多线程环境下的伪共享（false-sharing）？"><a href="#什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="什么是多线程环境下的伪共享（false sharing）？"></a>什么是多线程环境下的伪共享（false sharing）？</h1><ul>
<li>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行</li>
</ul>
<h1 id="89、简述一下面向对象的”六原则一法则”。"><a href="#89、简述一下面向对象的”六原则一法则”。" class="headerlink" title="89、简述一下面向对象的”六原则一法则”。"></a>89、简述一下面向对象的”六原则一法则”。</h1><ul>
<li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</li>
<li>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</li>
<li>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li>
<li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</li>
<li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/publishes/b3085e36f5dd.html</url>
    <content><![CDATA[<h1 id="什么是Apache-Kafka"><a href="#什么是Apache-Kafka" class="headerlink" title="什么是Apache Kafka"></a>什么是Apache Kafka</h1><p>Apache Kafka是一个分布式发布&#x2F;订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个Apache顶级项目。Kafka适合离线和在线消息消费。</p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>消息队列</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机（JVM）</title>
    <url>/publishes/8270315bab4b.html</url>
    <content><![CDATA[<h1 id="gc概述"><a href="#gc概述" class="headerlink" title="gc概述"></a>gc概述</h1><ul>
<li>垃圾收集机制是指jvm用于释放那些不再使用的对象所占用的内存</li>
<li>java语言并不要求jvm有gc，也没有规定gc如何工作</li>
<li>不过常用的jvm都有gc，而且大多数gc都使用类似的算法管理内存和执行收集操作</li>
<li>垃圾收集的目的在于清除不再使用的对象</li>
<li>gc通过确定对象是否被活动对象引用来确定是否收集该对象</li>
<li>gc首先要判断该对象是否是时候可以收集，两种常用的方法是引用计数和对象引用遍历<ul>
<li>引用计数<ul>
<li>引用计数存储对特定对象的所有引用数</li>
<li>当应用程序创建引用以及引用超出范围时，jvm必须适当增减引用数</li>
<li>当某对象的引用数为0时，便可以进行垃圾收集</li>
</ul>
</li>
<li>对象引用遍历<ul>
<li>早期的jvm使用引用计数，现在大多数jvm采用对象引用遍历</li>
<li>对象引用遍历从一组对象（GC ROOT）开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象</li>
<li>如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集</li>
<li>在对象遍历阶段，gc必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象</li>
<li>下一步，gc要删除不可到达的对象</li>
<li>删除时，有些gc只是简单的扫描堆栈，删除未标记的对象，并释放它们的内存以生成新的对象，这叫做清除（sweeping）</li>
<li>这种方法的问题在于内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大</li>
<li>因此，许多gc可以重新组织内存中的对象，并进行压缩（compact），形成可利用的空间</li>
<li>为此，gc需要停止其他的活动活动，这种方法意味着所有与应用程序相关的工作停止，只有gc运行，结果，在响应期间增减了许多混杂请求</li>
<li>另外，更复杂的gc不断增加或同时运行以减少或者清除应用程序的中断，有的gc使用单线程完成这项工作，有的则采用多线程以增加效率。</li>
<li>java中可作为GC Root的对象有<ul>
<li>虚拟机栈中引用的对象（本地变量表）</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中引用的对象（Native对象）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>有3个内存区域是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。</li>
</ul>
<h1 id="几种垃圾回收机制"><a href="#几种垃圾回收机制" class="headerlink" title="几种垃圾回收机制"></a>几种垃圾回收机制</h1><h4 id="标记-清除收集器"><a href="#标记-清除收集器" class="headerlink" title="标记-清除收集器"></a>标记-清除收集器</h4><ul>
<li>这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存</li>
<li>这种收集器一般使用单线程工作并停止其他操作</li>
<li>标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片</li>
</ul>
<h4 id="标记-压缩收集器"><a href="#标记-压缩收集器" class="headerlink" title="标记-压缩收集器"></a>标记-压缩收集器</h4><ul>
<li>有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段</li>
<li>在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈</li>
<li>这种收集器也停止其他操作</li>
<li>由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。（该算法适用于旧生代）</li>
</ul>
<h4 id="复制收集器"><a href="#复制收集器" class="headerlink" title="复制收集器"></a>复制收集器</h4><ul>
<li>这种收集器将堆栈分为两个域，常称为半空间</li>
<li>每次仅使用一半的空间，jvm生成的新对象则放在另一半空间中</li>
<li>gc运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈</li>
<li>这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低</li>
<li>复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域</li>
<li>当存活的对象较少时，复制算法会比较高效（新生代的Eden区就是采用这种算法），其带来的成本是需要一块额外的空闲空间和对象的移动</li>
</ul>
<h4 id="增量收集器"><a href="#增量收集器" class="headerlink" title="增量收集器"></a>增量收集器</h4><ul>
<li>增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾</li>
<li>这会造成较小的应用程序中断</li>
</ul>
<h4 id="分代收集器"><a href="#分代收集器" class="headerlink" title="分代收集器"></a>分代收集器</h4><ul>
<li>这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象</li>
<li>jvm生成的新对象一般放在其中的某个域中，过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中</li>
<li>分代收集器对不同的域使用不同的算法以优化性能</li>
</ul>
<h4 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h4><ul>
<li>并发收集器与应用程序同时运行</li>
<li>这些收集器在某点上（比如压缩时）一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低</li>
</ul>
<h4 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h4><ul>
<li>并行收集器使用某种传统的算法并使用多线程并行的执行它们的工作</li>
<li>在多cpu机器上使用多线程技术可以显著的提高java应用程序的可扩展性</li>
</ul>
<h1 id="Sun-HotSpot"><a href="#Sun-HotSpot" class="headerlink" title="Sun HotSpot"></a>Sun HotSpot</h1><ul>
<li>Sun HotSpot 使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域</li>
<li>Jvm生成的所有新对象放在新域中</li>
<li>一旦对象经历了一定数量的垃圾收集循环后，便获得使用期并进入旧域</li>
<li>在永久域中jvm则存储class和method对象</li>
<li>就配置而言，永久域是一个独立域并且不认为是堆的一部分</li>
<li>可使用-Xms和-Xmx 控制整个堆的原始大小或最大值</li>
<li>默认状态下，HotSpot在新域中使用复制收集器，该域一般分为三个部分<ul>
<li>第一部分为Eden，用于生成新的对象</li>
<li>另两部分称为救助空间，当Eden充满时，收集器停止应用程序，把所有可到达对象复制到当前的from救助空间，一旦当前的from救助空间充满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们获得使用期并转入旧域</li>
</ul>
</li>
<li>默认状态下HotSpot对新域使用复制收集器，对旧域使用标记－清除－压缩收集器</li>
<li>在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。如果能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价</li>
</ul>
<h1 id="如何从JVM中获取信息来进行调整"><a href="#如何从JVM中获取信息来进行调整" class="headerlink" title="如何从JVM中获取信息来进行调整"></a>如何从JVM中获取信息来进行调整</h1><ul>
<li>-verbose.gc开关可显示gc的操作内容。打开它，可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等。</li>
<li>打开-xx：+ printgcdetails开关，可以详细了解gc中的变化</li>
<li>打开-XX： + PrintGCTimeStamps开关，可以了解这些垃圾收集发生的时间，自jvm启动以后以秒计量</li>
<li>通过-xx： + PrintHeapAtGC开关了解堆的更详细的信息</li>
<li>为了了解新域的情况，可以通过-XX：&#x3D;PrintTenuringDistribution开关了解获得使用期的对象权。</li>
</ul>
<h1 id="查看配置JVM内存信息"><a href="#查看配置JVM内存信息" class="headerlink" title="查看配置JVM内存信息"></a>查看配置JVM内存信息</h1><ul>
<li>Runtime.getRuntime().maxMemory();&#x2F;&#x2F;最大可用内存，对应-Xmx</li>
<li>Runtime.getRuntime().freeMemory();&#x2F;&#x2F;当前JVM空闲内存</li>
<li>Runtime.getRuntime().totalMemory();&#x2F;&#x2F;当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和</li>
</ul>
<h4 id="关于maxMemory-，freeMemory-和totalMemory-："><a href="#关于maxMemory-，freeMemory-和totalMemory-：" class="headerlink" title="关于maxMemory()，freeMemory()和totalMemory()："></a>关于maxMemory()，freeMemory()和totalMemory()：</h4><ul>
<li>maxMemory()为JVM的最大可用内存，可通过-Xmx设置，默认值为物理内存的1&#x2F;4，设值不能高于计算机物理内存；</li>
<li>totalMemory()为当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和，会随着JVM使用内存的增加而增加；</li>
<li>freeMemory()为当前JVM空闲内存，因为JVM只有在需要内存时才占用物理内存使用，所以freeMemory()的值一般情况下都很小，而JVM实际可用内存并不等于freeMemory()，而应该等于maxMemory()-totalMemory()+freeMemory()。及其配置JVM内存分配。</li>
</ul>
<h1 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h1><ul>
<li>JVM的新生代、老年代、MinorGC、MajorGC</li>
<li>JVM中的堆，一般分为三大部分：新生代、老年代、永久代</li>
</ul>
<h4 id="新生代（Youn-Generation）"><a href="#新生代（Youn-Generation）" class="headerlink" title="新生代（Youn Generation）"></a>新生代（Youn Generation）</h4><ul>
<li>主要是用来存放新生的对象</li>
<li>一般占据堆的1&#x2F;3空间</li>
<li>由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收</li>
<li>新生代又分为 Eden区、ServivorFrom、ServivorTo三个区<ul>
<li>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收</li>
<li>ServivorTo：保留了一次MinorGC过程中的幸存者</li>
<li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者</li>
</ul>
</li>
<li>当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。</li>
<li>MinorGC的过程：采用复制算法<ul>
<li>首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则赋值到老年代区）</li>
<li>同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）</li>
<li>然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</li>
</ul>
</li>
<li>新建的对象都是从新生代分配内存，Eden区不足的时候，会把存活的对象转移到Survivor区</li>
</ul>
<h4 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h4><ul>
<li>老年代的对象比较稳定，所以MajorGC不会频繁执行</li>
<li>在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发</li>
<li>当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间</li>
<li>MajorGC采用标记—清除算法：<ul>
<li>首先扫描一次所有老年代，标记出存活的对象</li>
<li>然后回收没有标记的对象</li>
</ul>
</li>
<li>MajorGC的耗时比较长，因为要扫描再回收</li>
<li>MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配</li>
<li>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常</li>
<li>旧生代用于存放新生代多次回收依然存活的对象，如缓存对象。当旧生代满了的时候就需要对旧生代进行回收，旧生代的垃圾回收称作Major GC</li>
</ul>
<h4 id="永久代（Permanent-Generation）"><a href="#永久代（Permanent-Generation）" class="headerlink" title="永久代（Permanent Generation）"></a>永久代（Permanent Generation）</h4><ul>
<li>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息</li>
<li>Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常</li>
<li>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现</li>
<li>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</li>
<li>类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中</li>
<li>这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制</li>
<li>在Sun 的JVM中就是方法区的意思，尽管大多数JVM没有这一代</li>
</ul>
<h4 id="Major-GC和Full-GC区别"><a href="#Major-GC和Full-GC区别" class="headerlink" title="Major GC和Full GC区别"></a>Major GC和Full GC区别</h4><ul>
<li>Full GC：收集young gen、old gen、perm gen</li>
<li>Major GC：有时又叫old gc，只收集old gen</li>
</ul>
<h1 id="常⽤的GC策略和触发时机"><a href="#常⽤的GC策略和触发时机" class="headerlink" title="常⽤的GC策略和触发时机"></a>常⽤的GC策略和触发时机</h1><h4 id="YGC-Young-GC"><a href="#YGC-Young-GC" class="headerlink" title="YGC(Young GC)"></a>YGC(Young GC)</h4><ul>
<li>概念：对新⽣代堆进⾏GC。频率⽐较⾼，因为⼤部分对象的存活寿命较短，在新⽣代⾥被回收。性能耗费较⼩。</li>
<li>触发时机：Eden区空间不⾜</li>
</ul>
<h4 id="FGC-Full-GC"><a href="#FGC-Full-GC" class="headerlink" title="FGC(Full GC)"></a>FGC(Full GC)</h4><ul>
<li>概念：全堆范围的GC。默认堆空间使⽤到达80%(可调整)的时候会触发FGC。以我们⽣产环境为例，⼀般⽐较少会触发FGC，有时10天或⼀周左右会有⼀次。</li>
<li>触发时机：<ul>
<li>Old空间不⾜</li>
<li>Perm空间不⾜</li>
</ul>
</li>
</ul>
<h4 id="显示调⽤System-gc-，包括RMI等的定时触发"><a href="#显示调⽤System-gc-，包括RMI等的定时触发" class="headerlink" title="显示调⽤System.gc() ，包括RMI等的定时触发"></a>显示调⽤System.gc() ，包括RMI等的定时触发</h4><h4 id="YGC时的悲观策略"><a href="#YGC时的悲观策略" class="headerlink" title="YGC时的悲观策略"></a>YGC时的悲观策略</h4><h4 id="dump-live的内存信息时-jmap-–dump-live-。"><a href="#dump-live的内存信息时-jmap-–dump-live-。" class="headerlink" title="dump live的内存信息时(jmap –dump:live)。"></a>dump live的内存信息时(jmap –dump:live)。</h4><h1 id="深入理解JVM–JVM垃圾回收机制"><a href="#深入理解JVM–JVM垃圾回收机制" class="headerlink" title="深入理解JVM–JVM垃圾回收机制"></a>深入理解JVM–JVM垃圾回收机制</h1><h4 id="GC为我们做了什么操作呢？"><a href="#GC为我们做了什么操作呢？" class="headerlink" title="GC为我们做了什么操作呢？"></a>GC为我们做了什么操作呢？</h4><ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<h4 id="学习GC作用"><a href="#学习GC作用" class="headerlink" title="学习GC作用"></a>学习GC作用</h4><ul>
<li>排查内存溢出</li>
<li>排查内存泄漏</li>
<li>性能调优，排查并发瓶颈</li>
</ul>
<h4 id="什么时候会触发一个对象的回收"><a href="#什么时候会触发一个对象的回收" class="headerlink" title="什么时候会触发一个对象的回收"></a>什么时候会触发一个对象的回收</h4><ul>
<li>对象没有引用</li>
<li>作用域发生未捕获异常</li>
<li>程序在作用域正常执行完毕</li>
<li>程序执行了System.exit()</li>
<li>程序发生意外终止（被杀进程等）</li>
</ul>
<h1 id="Java中存在四种引用"><a href="#Java中存在四种引用" class="headerlink" title="Java中存在四种引用"></a>Java中存在四种引用</h1><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul>
<li>只要引用存在，垃圾回收器永远不会回收</li>
<li>Object obj &#x3D; new Object();</li>
<li>new出来的对象都是强引用，GC无论如何都不会回收，即使抛出OOM异常</li>
</ul>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul>
<li>非必须引用，内存溢出之前进行回收，可以通过以下代码实现</li>
<li>只有当JVM内存不足时才会被回收<br>Object obj &#x3D; new Object();<br>SoftReference<Object> sf &#x3D; new SoftReference<Object>(obj);<br>obj &#x3D; null;<br>sf.get();&#x2F;&#x2F;有时候会返回null<br>这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；<br>软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</li>
</ul>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul>
<li>第二次垃圾回收时回收，可以通过如下代码实现<br>Object obj &#x3D; new Object();<br>WeakReference<Object> wf &#x3D; new WeakReference<Object>(obj);<br>obj &#x3D; null;<br>wf.get();&#x2F;&#x2F;有时候会返回null<br>wf.isEnQueued();&#x2F;&#x2F;返回是否被垃圾回收器标记为即将回收的垃圾<br>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。<br>弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器</li>
<li>只要GC,就会立马回收，不管内存是否充足</li>
</ul>
<h4 id="虚引用（幽灵-幻影引用）"><a href="#虚引用（幽灵-幻影引用）" class="headerlink" title="虚引用（幽灵&#x2F;幻影引用）"></a>虚引用（幽灵&#x2F;幻影引用）</h4><ul>
<li>垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现<br>Object obj &#x3D; new Object();<br>PhantomReference<Object> pf &#x3D; new PhantomReference<Object>(obj);<br>obj&#x3D;null;<br>pf.get();&#x2F;&#x2F;永远返回null<br>pf.isEnQueued();&#x2F;&#x2F;返回从内存中已经删除<br>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。<br>虚引用主要用于检测对象是否已经从内存中删除。</li>
<li>它唯一的作用就是做一些跟踪记录，辅助finalize函数的使用</li>
</ul>
<h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><p>JVM把内存划分成了如下几个区域：<br>1.方法区（Method Area）<br>2.堆区（Heap）<br>3.虚拟机栈（VM Stack）<br>4.本地方法栈（Native Method Stack）<br>5.程序计数器（Program Counter Register）<br>其中，方法区和堆所有线程共享。</p>
<ul>
<li>线程不共享区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的</li>
<li>线程共享区域 线程共享区域包含：堆和方法区</li>
</ul>
<h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><ul>
<li>主要存放类与类之间关系的数据，而这部分数据被加载到内存之后，基本上是不会发生变更的</li>
<li>方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息</li>
<li>方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常</li>
<li>在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation）</li>
<li>一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载</li>
<li>在方法区上进行GC，条件相当苛刻而且困难。</li>
<li>方法区的数据因为回收率非常小，而成本又比较高，一般认为是“性价比”非常差的，所以Sun自己的虚拟机HotSpot中是不回收的！但是在现在高性能分布式J2EE的系统中，我们大量用到了反射、动态代理、CGLIB、JSP和OSGI等，这些类频繁的调用自定义类加载器，都需要动态的加载和卸载了，以保证永久带不会溢出，他们通过自定义的类加载器进行了各项操作，因此在实际的应用开发中，类也是被经常加载和卸载的，方法区也是会被回收的！但是方法区的回收条件非常苛刻，只有同时满足以下三个条件才会被回收！<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的ClassLoad已经被回收</li>
<li>Class对象无法通过任何途径访问(包括反射)，该类对应的反射类java.lang.Class对象没有被任何地方引用</li>
</ul>
</li>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用</li>
<li>一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</li>
<li>保存装载的类的元信息：类型的常量池，字段、⽅法信息，⽅法字节码</li>
<li>jdk6时，String等常量信息置于⽅法区，jdk7移到了堆中</li>
<li>通常和永久区（Perm）关联在⼀起</li>
</ul>
<h4 id="堆区（Heap）"><a href="#堆区（Heap）" class="headerlink" title="堆区（Heap）"></a>堆区（Heap）</h4><ul>
<li>Java堆中的数据基本上是朝生夕死的，我们用完之后要马上回收的，而Java栈和本地方法栈中的数据，因为有后进先出的原则，当我取下面的数据之前，必须要把栈顶的元素出栈，因此回收率可认为是100%</li>
<li>堆区是GC最频繁的，也是理解GC机制最重要的区域</li>
<li>堆区由所有线程共享，在虚拟机启动时创建</li>
<li>堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。</li>
<li>应⽤系统对象都保存在java堆中</li>
<li>所有线程共享java堆</li>
<li>对分代GC来说，堆也是分代的</li>
</ul>
<h4 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h4><ul>
<li>虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈</li>
<li>局部变量表中存储着方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：内存空间可以在编译期间就确定，运行时不再改变</li>
<li>虚拟机栈定义了两种异常类型：StackOverFlowError(栈溢出)和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError；不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</li>
<li>线程私有</li>
<li>栈由⼀系列帧组成（因此java栈也叫做帧栈）</li>
<li>帧保存⼀个⽅法的局部变量（局部变量表）、操作数栈、常量池指针</li>
<li>每⼀次⽅法调⽤创建⼀个帧，并压栈</li>
</ul>
<h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><ul>
<li>本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态</li>
<li>本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法</li>
<li>在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</li>
</ul>
<h4 id="程序计数器（Program-Counter-Register）-PC寄存器"><a href="#程序计数器（Program-Counter-Register）-PC寄存器" class="headerlink" title="程序计数器（Program Counter Register）(PC寄存器)"></a>程序计数器（Program Counter Register）(PC寄存器)</h4><ul>
<li>主要用于记录线程执行的行号等一些信息，这块区域也是被认为是唯一一块不会内存溢出的区域。在SunHostSpot的虚拟机中，对于程序计数器是不回收的</li>
<li>每个线程拥有⼀个pc寄存器，指向下⼀条指令的地址</li>
<li>程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它</li>
<li>它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的</li>
<li>每个程序计数器只能记录一个线程的行号，因此它是线程私有的</li>
<li>如果程序当前正在执行的是一个java方法，则程序计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则计数器的值为空</li>
</ul>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ul>
<li>属于串行收集器</li>
<li>Serial收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下ServerVM 4核4GB以下机器的默认垃圾回收器</li>
<li>比较适合于只有一个处理器的系统</li>
<li>串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World”的垃圾回收器</li>
<li>串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。</li>
<li>Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</li>
<li>在串行处理器中minor和major GC过程都是用一个线程进行回收的</li>
</ul>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul>
<li>ParNew收集器其实就是多线程版本的Serial收集器</li>
<li>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器</li>
<li>它可以与CMS GC配合，所以，更加有理由将他用于server端</li>
</ul>
<h4 id="ParallelScavenge"><a href="#ParallelScavenge" class="headerlink" title="ParallelScavenge"></a>ParallelScavenge</h4><ul>
<li>ParallelScavenge又被称为是吞吐量优先的收集器</li>
<li>ParallelScavenge所提到的吞吐量&#x3D;程序运行时间&#x2F;(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%，在交互不多的云端，比较适合使用该回收器。</li>
<li>在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式</li>
</ul>
<h1 id="ParallelOld"><a href="#ParallelOld" class="headerlink" title="ParallelOld"></a>ParallelOld</h1><ul>
<li>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器</li>
<li>这个收集器是JDK1.6之后刚引入的一款收集器，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先</li>
<li>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法</li>
</ul>
<h4 id="SerialOld"><a href="#SerialOld" class="headerlink" title="SerialOld"></a>SerialOld</h4><ul>
<li>SerialOld是旧生代Client模式下的默认收集器，单线程执行</li>
<li>在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器</li>
<li>Serial Old是Serial收集器的老年代版本</li>
<li>它同样使用一个单线程执行收集，使用“标记-整理”算法</li>
<li>主要使用在Client模式下的虚拟机</li>
</ul>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><ul>
<li>CMS又称响应时间优先(最短回收停顿)的回收器</li>
<li>使用并发模式回收垃圾</li>
<li>使用标记-清除算法</li>
<li>CMS对CPU是非常敏感的，它的回收线程数&#x3D;（CPU+3）&#x2F;4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%</li>
<li>CMS模式主要分为4个过程</li>
<li>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程</li>
<li>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</li>
<li>CMS为了确保能够扫描到所有的对象，避免在Initial Marking中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack中，如依赖的对象地址在其之后，则仅标记该对象。在进行Concurrent Marking时minor GC也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS为了应对这样的并发现象，提供了一个Mod Union Table来进行记录，在这个Mod Union Table中记录每次minor GC后修改了的Card的信息。这也是ParallelScavenge不能和CMS一起使用的原因。</li>
<li>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收</li>
<li>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收</li>
<li>该收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间</li>
<li>常见的B&#x2F;S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清楚算法实现的</li>
<li>CMS收集器的优点：并发收集、低停顿，但远没有达到完美</li>
<li>CMS收集器的缺点：<ul>
<li>CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。</li>
<li>CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。</li>
<li>CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。</li>
</ul>
</li>
</ul>
<h4 id="GarbageFirst-G1"><a href="#GarbageFirst-G1" class="headerlink" title="GarbageFirst(G1)"></a>GarbageFirst(G1)</h4><ul>
<li>SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器</li>
<li>他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间</li>
<li>相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿</li>
</ul>
<h4 id="RTSJ垃圾收集器"><a href="#RTSJ垃圾收集器" class="headerlink" title="RTSJ垃圾收集器"></a>RTSJ垃圾收集器</h4><ul>
<li>RTSJ垃圾收集器，用于Java实时编程</li>
</ul>
<h1 id="JVM的内存分配与回收策略"><a href="#JVM的内存分配与回收策略" class="headerlink" title="JVM的内存分配与回收策略"></a>JVM的内存分配与回收策略</h1><ul>
<li>优先在Edon上分配对象</li>
<li>大对象直接进入老生代</li>
<li>年长者(长期存活对象)进入老生代</li>
<li>群体效应(大批中年对象进入老生代)</li>
<li>担保GC(担保minorGC)<ul>
<li>担保GC就是担保minorGC能够满足当前的存储空间，而无需触发老生代的回收，由于大部分对象都是朝生夕死的，因此，在实际开发中这种很起效，但是也有可能会发生担保失败的情况，当担保失败的时候会触发FullGC，但是失败毕竟是少数，因此这种一般是很划算的。</li>
<li>默认情况是是开启担保的，无需设置参数</li>
</ul>
</li>
</ul>
<h1 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h1><ul>
<li>每⼀个线程有⼀个⼯作内存，和主存独⽴</li>
<li>⼯作内存存放主存中变量的值的拷⻉</li>
<li>对于普通变量，⼀个线程中更新的值，不能⻢上反应在其他变量中；如果需要在其他线程中⽴即可⻅，需要使⽤volatile关键字</li>
<li>volatile不能代替锁，⼀般认为volatile⽐锁性能好(不绝对)，使⽤volatile的条件是语义是否满⾜应⽤</li>
<li>可⻅性：⼀个线程修改了变量，其他线程可以⽴即知道。<ul>
<li>volatile；</li>
<li>synchronized（unlock之前，写变量值回主存）</li>
<li>final（⼀旦初始化完成，其他线程可⻅）</li>
</ul>
</li>
</ul>
<h1 id="Java-中堆和栈有什么不同"><a href="#Java-中堆和栈有什么不同" class="headerlink" title="Java 中堆和栈有什么不同"></a>Java 中堆和栈有什么不同</h1><ul>
<li>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的</li>
<li>而堆是所有线程共享的一片公用内存区域</li>
<li>对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</li>
</ul>
<h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>虚拟机把描述类的数据⽂件（字节码）加载到内存，并对数据进⾏验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使⽤的java类型（java.lang.Class对象）</li>
<li>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</li>
</ul>
<h4 id="类⽣命周期"><a href="#类⽣命周期" class="headerlink" title="类⽣命周期"></a>类⽣命周期</h4><ul>
<li>类加载过程：读取⼆进制字节流到jvm—&gt;验证格式语义等—&gt;为静态变量分配内存空间—&gt;常量池引⽤解析—&gt;执⾏static标识的代码<ul>
<li>a. 加载过程：通过⼀个类的全限定名来获取定义此类的⼆进制字节流，将这个字节流所代表的静态存储结构转化为⽅法区的运⾏时数据结构。在内存中(⽅法区)⽣成⼀个代表这个类的java.lang.Class对象，作为⽅法区这个类的各种数据的访问⼊⼝；</li>
<li>b. 验证过程：为了确保Class⽂件的字节流中包含的信息符合当前虚拟机的要求，⽂件格式验证、元数据验证、字节码验证、符号引⽤验证；</li>
<li>c. 准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在⽅法区中进⾏分配；准备阶段，static对象会被设置默认值，static ﬁnal对象会被赋上给予的值。</li>
<li>d. 解析阶段：虚拟机将常量池内的符号引⽤替换为直接引⽤的过程。<ul>
<li>i. 符号引⽤：字符串，引⽤对象不⼀定被加载；</li>
<li>ii. 直接引⽤：指针或者地址偏移量，引⽤对象⼀定在内存中。</li>
</ul>
</li>
<li>e. 初始化阶段：类初始化阶段是类加载过程的最后⼀步。初始化阶段就是执⾏类构造器<clint>()⽅法的过程。</li>
<li>f. 使⽤阶段</li>
<li>g. 卸载阶段：</li>
</ul>
</li>
</ul>
<h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><ul>
<li>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</li>
<li>主要有一下四种类加载器:<ul>
<li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ul>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li>java默认提供三个类加载器：<ul>
<li>a. 启动类加载器（BootStrap ClassLoader） 启动ClassLoader（sun.boot.class.path）：最顶层的加载类，主要加载jdk中的核⼼库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。Bootstrap ClassLoader不继承⾃ClassLoader，因为它不是⼀个普通的Java类，底层由C++编写，已嵌⼊到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核⼼类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</li>
<li>b. 扩展类加载器（Extension ClassLoader）扩展ClassLoader（java.ext.dirs）：扩展的类加载器，加载⽬录%JRE_HOME%\lib\ext⽬录下的jar包和class⽂件。还可以加载-D java.ext.dirs选项指定的⽬录。</li>
<li>c. App ClassLoader应⽤ClassLoader&#x2F;系统ClassLoader（java.class.path）：也称为SystemAppClass 加载当前应⽤的classpath的所有类。除了BootStrap ClassLoader，每个ClassLoader都有⼀个Parent作为⽗亲。</li>
</ul>
</li>
<li>双亲委派机制：<ul>
<li>定义：当⼀个ClassLoader实例需要加载某个类时，它会试图亲⾃搜索某个类之前，先把这个任务委托给它的⽗类加载器，这个过程是由上⾄下依次检查的，⾸先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader进⾏加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的⽂件系统或⽹络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类⽣成⼀个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</li>
<li>作⽤：<ul>
<li>避免重复加载；</li>
<li>考虑到安全因素，避免⾃定义的类去替代系统类，如String。</li>
<li>jvm如何判定两个class是否相同？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，⽽且要判断是否由同⼀个类加载器实例加载的。只有两者同时满⾜的情况下，JVM才认为这两个class是相同的。<ul>
<li>⾃底向上检查类是否已经加载；</li>
<li>⾃顶向下尝试加载类。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>custom classloader：⾃定义classloader<ul>
<li>Java中提供的默认ClassLoader，只加载指定⽬录下的jar和class，如果我们想加载其它位置的类或jar时，就需要定义⾃⼰的ClassLoader。</li>
<li>步骤：<ul>
<li>继承java.lang.ClassLoader</li>
<li>重写⽗类的findClass⽅法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="引起类加载的五个⾏为"><a href="#引起类加载的五个⾏为" class="headerlink" title="引起类加载的五个⾏为"></a>引起类加载的五个⾏为</h4><ul>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li>
<li>反射调⽤的时候，如果类没有进⾏过初始化，则需要先触发其初始化</li>
<li>⼦类初始化的时候，如果其⽗类还没初始化，则需先触发其⽗类的初始化</li>
<li>虚拟机执⾏主类的时候(有 main(string[] args))</li>
<li>JDK1.7 动态语⾔⽀持</li>
</ul>
<h4 id="java对象创建时机"><a href="#java对象创建时机" class="headerlink" title="java对象创建时机"></a>java对象创建时机</h4><ul>
<li>使⽤new关键字创建对象</li>
<li>使⽤Class类的newInstance⽅法(反射机制)</li>
<li>使⽤Constructor类的newInstance⽅法(反射机制)</li>
<li>使⽤Clone⽅法创建对象</li>
<li>使⽤(反)序列化机制创建对象</li>
</ul>
<h1 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h1><h4 id="调优时机"><a href="#调优时机" class="headerlink" title="调优时机"></a>调优时机</h4><ul>
<li>heap 内存（⽼年代）持续上涨达到设置的最⼤内存值；</li>
<li>Full GC 次数频繁；</li>
<li>GC 停顿时间过⻓（超过1秒）；</li>
<li>应⽤出现OutOfMemory 等内存异常；</li>
<li>应⽤中有使⽤本地缓存且占⽤⼤量内存空间；</li>
<li>系统吞吐量与响应性能不⾼或下降。</li>
</ul>
<h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><ul>
<li>多数的Java应⽤不需要在服务器上进⾏JVM优化；</li>
<li>多数导致GC问题的Java应⽤，都不是因为我们参数设置错误，⽽是代码问题；</li>
<li>在应⽤上线之前，先考虑将机器的JVM参数设置到最优（最适合）；</li>
<li>减少创建对象的数量；</li>
<li>减少使⽤全局变量和⼤对象；</li>
<li>JVM优化是到最后不得已才采⽤的⼿段；</li>
<li>在实际使⽤中，分析GC情况优化代码⽐优化JVM参数更好；</li>
</ul>
<h4 id="调优⽬标"><a href="#调优⽬标" class="headerlink" title="调优⽬标"></a>调优⽬标</h4><ul>
<li>GC低停顿；</li>
<li>GC低频率；</li>
<li>低内存占⽤；</li>
<li>⾼吞吐量；</li>
</ul>
<h4 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a>调优步骤</h4><ul>
<li>分析GC⽇志及dump⽂件，判断是否需要优化，确定瓶颈问题点；</li>
<li>确定jvm调优量化⽬标；</li>
<li>确定jvm调优参数（根据历史jvm参数来调整）；</li>
<li>调优⼀台服务器，对⽐观察调优前后的差异；</li>
<li>不断的分析和调整，知道找到合适的jvm参数配置；</li>
<li>找到最合适的参数，将这些参数应⽤到所有服务器，并进⾏后续跟踪。</li>
</ul>
<h1 id="jvm调优参数"><a href="#jvm调优参数" class="headerlink" title="jvm调优参数"></a>jvm调优参数</h1><ul>
<li>设定堆内存⼤⼩，这是最基本的。</li>
<li>-Xms：启动JVM时的堆内存空间。</li>
<li>-Xmx：堆内存最⼤限制。</li>
<li>设定新⽣代⼤⼩。</li>
<li>新⽣代不宜太⼩，否则会有⼤量对象涌⼊⽼年代。</li>
<li>-XX:NewRatio：新⽣代和⽼年代的占⽐。</li>
<li>-XX:NewSize：新⽣代空间。</li>
<li>-XX:SurvivorRatio：伊甸园空间和幸存者空间的占⽐。</li>
<li>-XX:MaxTenuringThreshold：对象进⼊⽼年代的年龄阈值。</li>
<li>设定垃圾回收器<ul>
<li>年轻代：-XX:+UseParNewGC。</li>
<li>⽼年代：-XX:+UseConcMarkSweepGC。</li>
<li>CMS可以将STW时间降到最低，但是不对内存进⾏压缩，有可能出现“并⾏模式失败”。⽐如⽼年代空间还有300MB空间，但是⼀些10MB的对象⽆法被顺序的存储。这时候会触发压缩处理，但是CMS GC模式下的压缩处理时间要⽐Parallel GC⻓很多。</li>
<li>G1采⽤”标记-整理“算法，解决了内存碎⽚问题，建⽴了可预测的停顿时间类型，能让使⽤者指定在⼀个⻓度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
</li>
</ul>
<h1 id="触发full-gc的场景及应对策略"><a href="#触发full-gc的场景及应对策略" class="headerlink" title="触发full gc的场景及应对策略"></a>触发full gc的场景及应对策略</h1><ul>
<li>System.gc()⽅法的调⽤，应对策略：通过-XX:+DisableExpl icitGC来禁⽌调⽤System.gc ;</li>
<li>⽼年代代空间不⾜，应对策略：让对象在Minor GC阶段被回收，让对象在新⽣代多存活⼀段时间，不要创建过⼤的对象及数组;</li>
<li>永⽣区空间不⾜，应对策略：增⼤PermGen空间；</li>
<li>GC时出现promotionfailed和concurrent mode failure，应对策略：增⼤survivor space；</li>
<li>Minor GC后晋升到旧⽣代的对象⼤⼩⼤于⽼年代的剩余空间，应对策略：增⼤Tenured space 或下调CMSInitiatingOccupancyFraction&#x3D;60；</li>
<li>内存持续增涨达到上限导致Full GC，应对策略：通过dumpheap 分析是否存在内存泄漏。</li>
</ul>
<h1 id="简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述java内存分配与回收策率以及Minor GC和Major GC"></a>简述java内存分配与回收策率以及Minor GC和Major GC</h1><ul>
<li>对象优先在堆的Eden区分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将直接进入老年代</li>
<li>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc&#x2F;Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度</li>
</ul>
<h1 id="如何查看jvm内存使⽤情况"><a href="#如何查看jvm内存使⽤情况" class="headerlink" title="如何查看jvm内存使⽤情况"></a>如何查看jvm内存使⽤情况</h1><ul>
<li>可以使⽤JDK⾃带的JConsole、JVisualVM、JMap、JHat等⼯具，或者使⽤第三⽅⼯具，⽐如 Eclipse Memory Analyzer</li>
</ul>
<h1 id="内存溢出的可能原因和解决⽅法"><a href="#内存溢出的可能原因和解决⽅法" class="headerlink" title="内存溢出的可能原因和解决⽅法"></a>内存溢出的可能原因和解决⽅法</h1><h4 id="内存溢出原因"><a href="#内存溢出原因" class="headerlink" title="内存溢出原因"></a>内存溢出原因</h4><ul>
<li>数据加载过多，如1次从数据库中取出过多数据   </li>
<li>集合类中有对对象的引⽤，⽤完后没有清空或者集合对象未置空导致引⽤存在等，是的JVM⽆法回收</li>
<li>死循环，过多重复对象 </li>
<li>第三⽅软件的bug       </li>
<li>启动参数内存值设定的过⼩</li>
</ul>
<h4 id="解决⽅法"><a href="#解决⽅法" class="headerlink" title="解决⽅法"></a>解决⽅法</h4><ul>
<li>修改JVM启动参数，加内存(-Xms，-Xmx)</li>
<li>错误⽇志，是否还有其他错误</li>
<li>代码⾛查</li>
</ul>
<h1 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h1><ul>
<li>未对作废数据内存单元置为null，尽早释放⽆⽤对象的引⽤，使⽤临时变量时，让引⽤变量在推出活动域后⾃动设置为null，暗示垃圾收集器收集；</li>
<li>程序避免⽤String拼接，⽤StringBuffer，因为每个String会占⽤内存⼀块区域；</li>
<li>尽量少⽤静态变量（全局不会回收）；</li>
<li>不要集中创建对象尤其⼤对象，可以使⽤流操作；</li>
<li>尽量使⽤对象池，不再循环中创建对象，优化配置；</li>
<li>创建对象到单例getInstance中，对象⽆法回收被单例引⽤；</li>
<li>服务器session时间设置过⻓也会引起内存泄漏。</li>
</ul>
<h1 id="⽅法区oom"><a href="#⽅法区oom" class="headerlink" title="⽅法区oom"></a>⽅法区oom</h1><ul>
<li>⽅法区⽤于存放Class的相关信息，如：类名，访问修饰符，常量池，字符描述，⽅法描述等。</li>
<li>原因：运⾏时产⽣⼤量的类去填满⽅法区，直到溢出。</li>
</ul>
<h1 id="哪些情况下对象会进⼊⽼年代"><a href="#哪些情况下对象会进⼊⽼年代" class="headerlink" title="哪些情况下对象会进⼊⽼年代"></a>哪些情况下对象会进⼊⽼年代</h1><ul>
<li>新⽣代对象每次经历⼀次minor gc，年龄会加1，当达到年龄阈值（默认为15岁）会直接进⼊⽼年代</li>
<li>⼤对象直接进⼊⽼年代</li>
<li>新⽣代复制算法需要⼀个survivor区进⾏轮换备份，如果出现⼤量对象在minor gc后仍然存活的情况时，就需要⽼年代进⾏分配担保，让survivor⽆法容纳的对象直接进⼊⽼年代</li>
<li>如果在Survivor空间中相同年龄所有对象⼤⼩的总和⼤于Survivor空间的⼀半，年龄⼤于或等于该年龄的对象就可以直接进⼊年⽼代</li>
</ul>
<h1 id="当对象A创建之后，对象A在各个区之间的流转过程"><a href="#当对象A创建之后，对象A在各个区之间的流转过程" class="headerlink" title="当对象A创建之后，对象A在各个区之间的流转过程"></a>当对象A创建之后，对象A在各个区之间的流转过程</h1><ul>
<li>对象A被new出来之后，是被存放在Eden（伊甸园）区的</li>
<li>当发⽣⼀次GC后，Eden区存活下来的对象A会被复制到s1区，s0中存活的对象也会被复制到s1中。如果对象年龄超过阈值年龄（默认15岁），会被复制到⽼年区。部分对象也需要⽼年代分担。<br>c. GC会清空Eden和s0中存储的所有对象；<br>d. 交换s0和s1的⻆⾊；<br>e. 重复上⾯的步骤。</li>
</ul>
<h1 id="jvm体系总体分四大块"><a href="#jvm体系总体分四大块" class="headerlink" title="jvm体系总体分四大块"></a>jvm体系总体分四大块</h1><ul>
<li>类的加载机制</li>
<li>jvm内存结构</li>
<li>GC算法 垃圾回收</li>
<li>GC分析 命令调优</li>
</ul>
<h1 id="调优命令"><a href="#调优命令" class="headerlink" title="调优命令"></a>调优命令</h1><ul>
<li>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</li>
<li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</li>
<li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li>
<li>jmap，JVM Memory Map命令用于生成heap dump文件</li>
<li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li>
<li>jstack，用于生成java虚拟机当前时刻的线程快照</li>
<li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数</li>
<li>jstack可以看当前栈的情况，jmap查看内存，jhat 进行dump堆的信息</li>
</ul>
<h1 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h1><ul>
<li>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto</li>
<li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li>
<li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等</li>
<li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li>
<li>GChisto，一款专业分析gc日志的工具</li>
</ul>
<h1 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h1><ul>
<li>比如GC的时候必须要等到Java线程都进入到safepoint的时候VMThread才能开始执行GC，</li>
<li>循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)</li>
<li>方法返回前</li>
<li>调用方法的call之后</li>
<li>抛出异常的位置</li>
</ul>
<h1 id="简述java垃圾回收机制"><a href="#简述java垃圾回收机制" class="headerlink" title="简述java垃圾回收机制"></a>简述java垃圾回收机制</h1><ul>
<li>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行</li>
<li>在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</li>
</ul>
<h1 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h1><ul>
<li>－server 启用服务器模式（如果CPU多，服务器机建议使用此项）</li>
<li>－Xms，－Xmx一般设为同样大小。 800m</li>
<li>－Xmn 是将NewSize与MaxNewSize设为一致。320m</li>
<li>－XX：PerSize 64m</li>
<li>－XX：NewSize 320m 此值设大可调大新对象区，减少Full GC次数</li>
<li>－XX：MaxNewSize 320m</li>
<li>－XX：NewRato NewSize设了可不设。4</li>
<li>－XX： SurvivorRatio 4</li>
<li>－XX：userParNewGC 可用来设置并行收集</li>
<li>－XX：ParallelGCThreads 可用来增加并行度 4</li>
<li>－XXUseParallelGC 设置后可以使用并行清除收集器</li>
<li>－XX：UseAdaptiveSizePolicy 与上面一个联合使用效果更好，利用它可以自动优化新域大小以及救助空间比值</li>
<li>-XmxJavaHeap最大值，默认值为物理内存的1&#x2F;4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；</li>
<li>-XmsJavaHeap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/publishes/f17ba5c005d6.html</url>
    <content><![CDATA[<h1 id="使⽤两种命令创建⼀个⽂件？"><a href="#使⽤两种命令创建⼀个⽂件？" class="headerlink" title="使⽤两种命令创建⼀个⽂件？"></a>使⽤两种命令创建⼀个⽂件？</h1><ul>
<li>touch a.txt</li>
<li>vi a.txt</li>
<li>mkdir abc</li>
<li>cat &gt; a.txt 建⽴⼀⽂件，然后把接下来的键盘输⼊写⼊⽂件，直到按Ctrl+D为⽌.</li>
</ul>
<h1 id="硬链接和软连接的区别？"><a href="#硬链接和软连接的区别？" class="headerlink" title="硬链接和软连接的区别？"></a>硬链接和软连接的区别？</h1><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul>
<li>⽂件有相同的 inode 及 data block；</li>
<li>只能对已存在的⽂件进⾏创建；</li>
<li>不能交叉⽂件系统进⾏硬链接的创建；</li>
<li>不能对⽬录进⾏创建，只可对⽂件创建；</li>
<li>删除⼀个硬链接⽂件并不影响其他有相同 inode 号的⽂件。</li>
</ul>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><ul>
<li>软链接有⾃⼰的⽂件属性及权限等；</li>
<li>可对不存在的⽂件或⽬录创建软链接；</li>
<li>软链接可交叉⽂件系统；</li>
<li>软链接可对⽂件或⽬录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的⽂件，但若被指向的原⽂件被删除，则相关软连接被称为死链接（即 dangling<br>link，若被指向路径⽂件被重新创建，死链接可恢复为正常的软链接）。</li>
</ul>
<h1 id="linux常⽤命令有哪些"><a href="#linux常⽤命令有哪些" class="headerlink" title="linux常⽤命令有哪些"></a>linux常⽤命令有哪些</h1><ul>
<li>查找关闭端⼝进程 netstat -nlp | grep :3306 kill pid</li>
<li>删除⽂件 rm -rf</li>
<li>查找⽇志 cat xx.log | grep ‘xxx’ | more</li>
<li>解压tar.gz tar -xzvf file.tar.gz</li>
<li>创建⽂件 touch filename cat &gt; filename</li>
<li>修改⽂件 vi</li>
</ul>
<h1 id="怎么查看⼀个java线程的资源耗⽤"><a href="#怎么查看⼀个java线程的资源耗⽤" class="headerlink" title="怎么查看⼀个java线程的资源耗⽤"></a>怎么查看⼀个java线程的资源耗⽤</h1><ul>
<li>linux下，所有的java内部线程，其实都对应了⼀个进程id，也就是说，linux上的jvm将java程序中的线程映射为操作系统进程。</li>
<li>jps -lvm或者ps -ef | grep java查看当前机器上运⾏的Java应⽤进程</li>
<li>top -Hp pid可以查看Java所有线程的资源耗⽤</li>
<li>printf “%x\n” pid等到线程ID的16进制</li>
<li>jstack Java应⽤进程ID | grep 线程ID的16进制</li>
</ul>
<h1 id="Load过⾼的可能性有哪些？"><a href="#Load过⾼的可能性有哪些？" class="headerlink" title="Load过⾼的可能性有哪些？"></a>Load过⾼的可能性有哪些？</h1><ul>
<li>cpu load的飙升，⼀⽅⾯可能和full gc的次数增⼤有关，⼀⽅⾯可能和死循环有关系</li>
</ul>
<h1 id="etc-hosts⽂件什么作⽤"><a href="#etc-hosts⽂件什么作⽤" class="headerlink" title="&#x2F;etc&#x2F;hosts⽂件什么作⽤"></a>&#x2F;etc&#x2F;hosts⽂件什么作⽤</h1><ul>
<li>在当前主机给ip设置别名，通过该别名可以访问到该ip地址，通过别名、ip访问的效果是⼀样的</li>
</ul>
<h1 id="如何快速的将⼀个⽂本中的”abc”转换成”xyz”？"><a href="#如何快速的将⼀个⽂本中的”abc”转换成”xyz”？" class="headerlink" title="如何快速的将⼀个⽂本中的”abc”转换成”xyz”？"></a>如何快速的将⼀个⽂本中的”abc”转换成”xyz”？</h1><ul>
<li>vi filename编辑⽂本，按Esc键，输⼊:%s&#x2F;abc&#x2F;xyz&#x2F;g</li>
</ul>
<h1 id="如何在log⽂件中搜索找出error的⽇志？"><a href="#如何在log⽂件中搜索找出error的⽇志？" class="headerlink" title="如何在log⽂件中搜索找出error的⽇志？"></a>如何在log⽂件中搜索找出error的⽇志？</h1><ul>
<li>cat xx.log | grep ‘error’</li>
</ul>
<h1 id="发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件"><a href="#发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件" class="headerlink" title="发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件?"></a>发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件?</h1><ul>
<li>find . -type f -size +100M | xargs du -h | sort -nr</li>
</ul>
<h1 id="Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）"><a href="#Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）" class="headerlink" title="Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）"></a>Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）</h1><h4 id="业务⽇志相关"><a href="#业务⽇志相关" class="headerlink" title="业务⽇志相关"></a>业务⽇志相关</h4><ul>
<li>less或者more</li>
<li>grep</li>
<li>tail -f filename</li>
<li>切忌vim直接打开⼤⽇志⽂件，因为会直接加载到内存的</li>
</ul>
<h4 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h4><ul>
<li>登录线上库，show processlist查看数据库连接情况</li>
</ul>
<h4 id="jvm相关："><a href="#jvm相关：" class="headerlink" title="jvm相关："></a>jvm相关：</h4><ul>
<li>jps显示java进程</li>
<li>jinfo实时查看和调整jvm参数</li>
<li>jstat监控jvm各种运⾏状态信息；</li>
<li>jstack(Stack Trace for Java)命令⽤于⽣成JVM进程当前时刻的线程的调⽤堆栈，可以⽤来定位线程间死锁、<br>锁等待、等待外部资源等</li>
<li>jmap(Memory Map for Java) 命令⽤于⽣成堆转储快照dump⽂件，除了这种⽅式还可以通过-<br>XX:HeapDumpOnOutOfMemoryError参数，可以在虚拟机发⽣OOM的时候⾃动⽣成堆的dump⽂件，或者kill -3<br>命令发出进程退出信号”吓唬”⼀下虚拟机，也能拿到dump⽂件。</li>
</ul>
<h4 id="oom问题："><a href="#oom问题：" class="headerlink" title="oom问题："></a>oom问题：</h4><ul>
<li>配置了-XX:+HeapDumpOnOutOfMemoryError, 在发⽣OOM的时候会在-XX:HeapDumpPath⽣成堆的dump⽂<br>件，结合MAT，可以对dump⽂件进⾏分析，查找出发⽣OOM的原因。</li>
<li>另外⼿动dump堆快照，可以使⽤命令jmap -dump:format&#x3D;b,file&#x3D;file_name pid 或者kill -3 pid</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul>
<li>jps -v</li>
<li>jstack -l pid</li>
</ul>
<h4 id="线程block、线程数暴涨："><a href="#线程block、线程数暴涨：" class="headerlink" title="线程block、线程数暴涨："></a>线程block、线程数暴涨：</h4><ul>
<li>jstack -l pid |wc -l</li>
<li>jstack -l pid |grep “BLOCKED”|wc -l</li>
<li>jstack -l pid |grep “Waiting on condition”|wc -l<br>线程block问题⼀般是等待io、等待⽹络、等待监视器锁等造成，可能会导致请求超时、造成造成线程数暴涨导致系统502等。</li>
</ul>
<h4 id="服务器问题："><a href="#服务器问题：" class="headerlink" title="服务器问题："></a>服务器问题：</h4><h5 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h5><ul>
<li>top</li>
</ul>
<h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><ul>
<li>free -m -c10 -s1：<ul>
<li>-m：以MB为单位显示，其他的有-k -g -b</li>
<li>-s: 间隔多少秒持续观察内存使⽤状况</li>
<li>-c:观察多少次</li>
</ul>
</li>
<li>vmstat 1 10：1表示每隔1s输出⼀次,10 表示输出10次<ul>
<li>r: 运⾏队列中进程数量，这个值也可以判断是否需要增加CPU。（⻓期⼤于1）</li>
<li>b: 等待IO的进程数量。</li>
</ul>
</li>
</ul>
<h5 id="io"><a href="#io" class="headerlink" title="io"></a>io</h5><ul>
<li>iostat -m 1 10：<ul>
<li>-m：某些使⽤block为单位的列强制使⽤MB为单位</li>
<li>1 10：数据显示每隔1秒刷新⼀次，共显示10次</li>
</ul>
</li>
</ul>
<h5 id="⽹络"><a href="#⽹络" class="headerlink" title="⽹络"></a>⽹络</h5><ul>
<li>netstat -antp：<ul>
<li>-a (all)显示所有选项，默认不显示LISTEN相关</li>
<li>-t (tcp)仅显示tcp相关选项</li>
<li>-u (udp)仅显示udp相关选项</li>
<li>-n 拒绝显示别名，能显示数字的全部转化成数字。</li>
<li>-l 仅列出有在 Listen (监听) 的服服务状态</li>
<li>-p 显示建⽴相关链接的程序名</li>
</ul>
</li>
</ul>
<h1 id="Thread-dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）"><a href="#Thread-dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）" class="headerlink" title="Thread dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）"></a>Thread dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）</h1><h4 id="Thread-Dump-能诊断的问题"><a href="#Thread-Dump-能诊断的问题" class="headerlink" title="Thread Dump 能诊断的问题"></a>Thread Dump 能诊断的问题</h4><ul>
<li>查找内存泄露，常⻅的是程序⾥load⼤量的数据到缓存；</li>
<li>发现死锁线程；</li>
</ul>
<h4 id="如何抓取Thread-Dump信息："><a href="#如何抓取Thread-Dump信息：" class="headerlink" title="如何抓取Thread Dump信息："></a>如何抓取Thread Dump信息：</h4><ul>
<li>⼀般当服务器挂起,崩溃或者性能底下时,就需要抓取服务器的线程堆栈(Thread Dump)⽤于后续的分析. 在实际运⾏中，往往⼀次 dump的信息，还不⾜以确认问题。为了反映线程状态的动态变化，需要接连多次做threaddump，每次间隔10-20s，建议⾄少产⽣三次 dump信息，如果每次 dump都指向同⼀个问题，我们才确定问题的典型性。</li>
</ul>
<h4 id="linux命令获取"><a href="#linux命令获取" class="headerlink" title="linux命令获取"></a>linux命令获取</h4><ul>
<li>ps –ef | grep java</li>
<li>kill -3 <pid></li>
</ul>
<h4 id="jdk⾃带⼯具获取"><a href="#jdk⾃带⼯具获取" class="headerlink" title="jdk⾃带⼯具获取"></a>jdk⾃带⼯具获取</h4><ul>
<li>jps 或 ps –ef|grepjava (获取PID)</li>
<li>jstack [-l ]<pid> | tee -a jstack.log (获取ThreadDump)</li>
</ul>
<h1 id="如何查看Java应⽤的线程信息？"><a href="#如何查看Java应⽤的线程信息？" class="headerlink" title="如何查看Java应⽤的线程信息？"></a>如何查看Java应⽤的线程信息？</h1><ul>
<li>通过top命令拿到线程的pid后使⽤jstack命令</li>
</ul>
<h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1><ul>
<li>wc -l</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Memcached</title>
    <url>/publishes/fe062138c36d.html</url>
    <content><![CDATA[<h1 id="memcached是怎么工作的？"><a href="#memcached是怎么工作的？" class="headerlink" title="memcached是怎么工作的？"></a>memcached是怎么工作的？</h1><ul>
<li>Memcached的神奇来自两阶段哈希（two-stage hash）</li>
<li>Memcached就像一个巨大的、存储了很多&lt;key,value&gt;对的哈希表。通过key，可以存储或查询任意的数据。 </li>
<li>客户端可以把数据存储在多台memcached上。当查询数据时，客户端首先参考节点列表计算出key的哈希值（阶段一哈希），进而选中一个节点；客户端将请求发送给选中的节点，然后memcached节点通过一个内部的哈希算法（阶段二哈希），查找真正的数据（item）。 </li>
<li>举个列子，假设有3个客户端1, 2, 3，3台memcached A, B, C：Client 1想把数据”barbaz”以key “foo”存储。Client 1首先参考节点列表（A, B, C），计算key “foo”的哈希值，假设memcached B被选中。接着，Client 1直接connect到memcached B，通过key “foo”把数据”barbaz”存储进去。Client 2使用与Client 1相同的客户端库（意味着阶段一的哈希算法相同），也拥有同样的memcached列表（A, B, C）。 于是，经过相同的哈希计算（阶段一），Client 2计算出key “foo”在memcached B上，然后它直接请求memcached B，得到数据”barbaz”。 </li>
<li>各种客户端在memcached中数据的存储形式是不同的（perl Storable, php serialize, java hibernate, JSON等）。一些客户端实现的哈希算法也不一样。但是，memcached服务器端的行为总是一致的。 </li>
<li>最后，从实现的角度看，memcached是一个非阻塞的、基于事件的服务器程序。这种架构可以很好地解决C10K problem ，并具有极佳的可扩展性。</li>
</ul>
<p> </p>
<h1 id="memcached最大的优势是什么？"><a href="#memcached最大的优势是什么？" class="headerlink" title="memcached最大的优势是什么？"></a>memcached最大的优势是什么？</h1><ul>
<li>Memcached最大的好处就是它带来了极佳的水平可扩展性，特别是在一个巨大的系统中</li>
<li>由于客户端自己做了一次哈希，那么我们很容易增加大量memcached到集群中</li>
<li>memcached之间没有相互通信，因此不会增加 memcached的负载；没有多播协议，不会网络通信量爆炸（implode）。memcached的集群很好用。内存不够了？增加几台 memcached吧；CPU不够用了？再增加几台吧；有多余的内存？在增加几台吧，不要浪费了。 </li>
<li>基于memcached的基本原则，可以相当轻松地构建出不同类型的缓存架构。</li>
</ul>
<h1 id="memcached和MySQL的query-cache相比，有什么优缺点？"><a href="#memcached和MySQL的query-cache相比，有什么优缺点？" class="headerlink" title="memcached和MySQL的query cache相比，有什么优缺点？"></a>memcached和MySQL的query cache相比，有什么优缺点？</h1><ul>
<li>把memcached引入应用中，还是需要不少工作量的</li>
<li>MySQL有个使用方便的query cache，可以自动地缓存SQL查询的结果，被缓存的SQL查询可以被反复地快速执行。</li>
</ul>
<h4 id="Memcached与之相比，怎么样呢"><a href="#Memcached与之相比，怎么样呢" class="headerlink" title="Memcached与之相比，怎么样呢"></a>Memcached与之相比，怎么样呢</h4><ul>
<li>MySQL的query cache是集中式的，连接到该query cache的MySQL服务器都会受益。 </li>
<li>当您修改表时，MySQL的query cache会立刻被刷新（flush）</li>
<li>存储一个memcached item只需要很少的时间，但是当写操作很频繁时，MySQL的query cache会经常让所有缓存数据都失效。 </li>
<li>在多核CPU上，MySQL的query cache会遇到扩展问题（scalability issues）。在多核CPU上，query cache会增加一个全局锁（global lock）, 由于需要刷新更多的缓存数据，速度会变得更慢。 </li>
<li>在 MySQL的query cache中，我们是不能存储任意的数据的（只能是SQL查询结果）。而利用memcached，我们可以搭建出各种高效的缓存。比如，可以执行多个独立的查询，构建出一个用户对象（user object），然后将用户对象缓存到memcached中。而query cache是SQL语句级别的，不可能做到这一点。在小的网站中，query cache会有所帮助，但随着网站规模的增加，query cache的弊将大于利。 </li>
<li>query cache能够利用的内存容量受到MySQL服务器空闲内存空间的限制。给数据库服务器增加更多的内存来缓存数据，固然是很好的。但是，有了memcached，只要您有空闲的内存，都可以用来增加memcached集群的规模，然后您就可以缓存更多的数据。</li>
</ul>
<p> </p>
<h1 id="memcached和服务器的local-cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？"><a href="#memcached和服务器的local-cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？" class="headerlink" title="memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？"></a>memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？</h1><ul>
<li>首先，local cache有许多与上面(query cache)相同的问题</li>
<li>local cache能够利用的内存容量受到（单台）服务器空闲内存空间的限制</li>
<li>不过，local cache有一点比memcached和query cache都要好，那就是它不但可以存储任意的数据，而且没有网络存取的延迟。 </li>
<li>local cache的数据查询更快</li>
<li>考虑把highly common的数据放在local cache中吧。如果每个页面都需要加载一些数量较少的数据，考虑把它们放在local cached吧。 </li>
<li>local cache缺少集体失效（group invalidation）的特性。在memcached集群中，删除或更新一个key会让所有的观察者觉察到。但是在local cache中, 我们只能通知所有的服务器刷新cache（很慢，不具扩展性），或者仅仅依赖缓存超时失效机制。 </li>
<li>local cache面临着严重的内存限制，这一点上面已经提到。</li>
</ul>
<p> </p>
<h1 id="memcached的cache机制是怎样的？"><a href="#memcached的cache机制是怎样的？" class="headerlink" title="memcached的cache机制是怎样的？"></a>memcached的cache机制是怎样的？</h1><ul>
<li>Memcached主要的cache机制是LRU（最近最少用）算法+超时失效</li>
<li>当您存数据到memcached中，可以指定该数据在缓存中可以呆多久Which is forever, or some time in the future</li>
<li>如果memcached的内存不够用了，过期的slabs会优先被替换，接着就轮到最老的未被使用的slabs。</li>
</ul>
<p> </p>
<h1 id="memcached如何实现冗余机制？"><a href="#memcached如何实现冗余机制？" class="headerlink" title="memcached如何实现冗余机制？"></a>memcached如何实现冗余机制？</h1><ul>
<li>不实现！我们对这个问题感到很惊讶</li>
<li>Memcached应该是应用的缓存层</li>
<li>它的设计本身就不带有任何冗余机制</li>
<li>如果一个memcached节点失去了所有数据，您应该可以从数据源（比如数据库）再次获取到数据</li>
<li>您应该特别注意，您的应用应该可以容忍节点的失效</li>
<li>不要写一些糟糕的查询代码，寄希望于 memcached来保证一切！如果您担心节点失效会大大加重数据库的负担，那么您可以采取一些办法。比如您可以增加更多的节点（来减少丢失一个节点的影响），热备节点（在其他节点down了的时候接管IP），等等。</li>
</ul>
<p> </p>
<h1 id="memcached如何处理容错的？"><a href="#memcached如何处理容错的？" class="headerlink" title="memcached如何处理容错的？"></a>memcached如何处理容错的？</h1><ul>
<li>不处理！</li>
<li>在memcached节点失效的情况下，集群没有必要做任何容错处理</li>
<li>如果发生了节点失效，应对的措施完全取决于用户</li>
<li>节点失效时，下面列出几种方案供您选择： <ul>
<li>忽略它！在失效节点被恢复或替换之前，还有很多其他节点可以应对节点失效带来的影响</li>
<li>把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下（余数式哈希算法），客户端添加或移除节点，会导致所有的缓存数据不可用！因为哈希参照的节点列表变化了，大部分key会因为哈希值的改变而被映射到（与原来）不同的节点上。 </li>
<li>启动热备节点，接管失效节点所占用的IP。这样可以防止哈希紊乱（hashing chaos）。 </li>
<li>如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈希算法（consistent hashing）</li>
<li>两次哈希（reshing）。当客户端存取数据时，如果发现一个节点down了，就再做一次哈希（哈希算法与前一次不同），重新选择另一个节点（需要注意的时，客户端并没有把down的节点从节点列表中移除，下次还是有可能先哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和坏的节点上都可能存在脏数据（stale data）。</li>
</ul>
</li>
</ul>
<p> </p>
<h1 id="如何将memcached中item批量导入导出？"><a href="#如何将memcached中item批量导入导出？" class="headerlink" title="如何将memcached中item批量导入导出？"></a>如何将memcached中item批量导入导出？</h1><ul>
<li>您不应该这样做！</li>
<li>Memcached是一个非阻塞的服务器</li>
<li>任何可能导致memcached暂停或瞬时拒绝服务的操作都应该值得深思熟虑</li>
<li>向 memcached中批量导入数据往往不是您真正想要的</li>
<li>想象看，如果缓存数据在导出导入之间发生了变化，您就需要处理脏数据了；如果缓存数据在导出导入之间过期了，您又怎么处理这些数据呢？ </li>
<li>因此，批量导出导入数据并不像您想象中的那么有用。不过在一个场景倒是很有用。如果您有大量的从不变化的数据，并且希望缓存很快热（warm）起来，批量导入缓存数据是很有帮助的。虽然这个场景并不典型，但却经常发生，因此我们会考虑在将来实现批量导出导入的功能。</li>
</ul>
<p> </p>
<h1 id="memcached是如何做身份验证的？"><a href="#memcached是如何做身份验证的？" class="headerlink" title="memcached是如何做身份验证的？"></a>memcached是如何做身份验证的？</h1><ul>
<li>没有身份认证机制！</li>
<li>memcached是运行在应用下层的软件（身份验证应该是应用上层的职责）</li>
<li>memcached的客户端和服务器端之所以是轻量级的，部分原因就是完全没有实现身份验证机制。这样，memcached可以很快地创建新连接，服务器端也无需任何配置。 </li>
<li>如果您希望限制访问，您可以使用防火墙，或者让memcached监听unix domain socket。</li>
</ul>
<p> </p>
<h1 id="memcached的多线程是什么？如何使用它们？"><a href="#memcached的多线程是什么？如何使用它们？" class="headerlink" title="memcached的多线程是什么？如何使用它们？"></a>memcached的多线程是什么？如何使用它们？</h1><ul>
<li>线程就是定律（threads rule）！</li>
<li>多线程模式允许memcached能够充分利用多个CPU，并在CPU之间共享所有的缓存数据</li>
<li>memcached使用一种简单的锁机制来保证数据更新操作的互斥</li>
<li>相比在同一个物理机器上运行多个memcached实例，这种方式能够更有效地处理multi gets。 </li>
<li>如果您的系统负载并不重，也许您不需要启用多线程工作模式</li>
<li>如果您在运行一个拥有大规模硬件的、庞大的网站，您将会看到多线程的好处。 </li>
<li>简单地总结一下：命令解析（memcached在这里花了大部分时间）可以运行在多线程模式下。memcached内部对数据的操作是基于很多全局锁的（因此这部分工作不是多线程的）。未来对多线程模式的改进，将移除大量的全局锁，提高memcached在负载极高的场景下的性能。</li>
</ul>
<p> </p>
<h1 id="memcached能接受的key的最大长度是多少？"><a href="#memcached能接受的key的最大长度是多少？" class="headerlink" title="memcached能接受的key的最大长度是多少？"></a>memcached能接受的key的最大长度是多少？</h1><ul>
<li>key的最大长度是250个字符</li>
<li>需要注意的是，250是memcached服务器端内部的限制，如果您使用的客户端支持”key的前缀”或类似特性，那么key（前缀+原始key）的最大长度是可以超过250个字符的</li>
<li>我们推荐使用使用较短的key，因为可以节省内存和带宽。</li>
</ul>
<p> </p>
<h1 id="memcached对item的过期时间有什么限制？"><a href="#memcached对item的过期时间有什么限制？" class="headerlink" title="memcached对item的过期时间有什么限制？"></a>memcached对item的过期时间有什么限制？</h1><ul>
<li>过期时间最大可以达到30天</li>
<li>memcached把传入的过期时间（时间段）解释成时间点后，一旦到了这个时间点，memcached就把item置为失效状态。</li>
</ul>
<p> </p>
<h1 id="memcached最大能存储多大的单个item？"><a href="#memcached最大能存储多大的单个item？" class="headerlink" title="memcached最大能存储多大的单个item？"></a>memcached最大能存储多大的单个item？</h1><ul>
<li>1MB</li>
<li>如果你的数据大于1MB，可以考虑在客户端压缩或拆分到多个key中。</li>
</ul>
<p> </p>
<h1 id="为什么单个item的大小被限制在1M-byte之内？"><a href="#为什么单个item的大小被限制在1M-byte之内？" class="headerlink" title="为什么单个item的大小被限制在1M byte之内？"></a>为什么单个item的大小被限制在1M byte之内？</h1><ul>
<li>简单的回答：因为内存分配器的算法就是这样的。 </li>
<li>详细的回答：Memcached的内存存储引擎（引擎将来可插拔…），使用slabs来管理内存。内存被分成大小不等的slabs chunks（先分成大小相等的slabs，然后每个slab被分成大小相等chunks，不同slab的chunk大小是不相等的）。chunk的大小依次从一个最小数开始，按某个因子增长，直到达到最大的可能值。 </li>
<li>如果最小值为400B，最大值是1MB，因子是1.20，各个slab的chunk的大小依次是：slab1 – 400B slab2 – 480B slab3 – 576B … </li>
<li>slab中chunk越大，它和前面的slab之间的间隙就越大。因此，最大值越大，内存利用率越低。Memcached必须为每个slab预先分配内存，因此如果设置了较小的因子和较大的最大值，会需要更多的内存。 </li>
<li>还有其他原因使得您不要这样向memcached中存取很大的数据…不要尝试把巨大的网页放到mencached中。把这样大的数据结构load和unpack到内存中需要花费很长的时间，从而导致您的网站性能反而不好。 </li>
<li>如果您确实需要存储大于1MB的数据，你可以修改slabs.c:POWER_BLOCK的值，然后重新编译memcached；或者使用低效的malloc&#x2F;free。其他的建议包括数据库、MogileFS等。</li>
</ul>
<p> </p>
<h1 id="我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？"><a href="#我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？" class="headerlink" title="我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？"></a>我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？</h1><ul>
<li>Memcache客户端仅根据哈希算法来决定将某个key存储在哪个节点上，而不考虑节点的内存大小</li>
<li>因此，您可以在不同的节点上使用大小不等的缓存。但是一般都是这样做的：拥有较多内存的节点上可以运行多个memcached实例，每个实例使用的内存跟其他节点上的实例相同。</li>
</ul>
<p> </p>
<h1 id="LRU算法，slab分配，如何减少内存碎⽚"><a href="#LRU算法，slab分配，如何减少内存碎⽚" class="headerlink" title="LRU算法，slab分配，如何减少内存碎⽚"></a>LRU算法，slab分配，如何减少内存碎⽚</h1><ul>
<li>memcached预先将分配的内存分割成各种尺⼨的块(chunk)，并把尺⼨相同的块分成组(chunk的集合)，以此克服内<br>存碎⽚化问题</li>
</ul>
<h1 id="memcached-是原子的吗？"><a href="#memcached-是原子的吗？" class="headerlink" title="memcached 是原子的吗？"></a>memcached 是原子的吗？</h1><ul>
<li>所有的被发送到 memcached 的单个命令是完全原子的。如果您针对同一份数据同时发送了一个 set 命令和一个 get 命令，它们不会影响对方。它们将被串行化、先后执行。即使在多线程模式，所有的命令都是原子的，除非程序有 bug:)命令序列不是原子的。如果您通过 get 命令获取了一个 item，修改了它，然后想把它 set 回 memcached，我们不保证这个 item 没有被其他进程（process，未必是操作系统中的进程）操作过。在并发的情况下，您也可能覆写了一个被其他进程 set 的 item。</li>
<li>memcached 1.2.5 以及更高版本，提供了 gets 和 cas 命令，它们可以解决上面的问题。如果您使用 gets 命令查询某个 key 的 item，memcached 会给您返回该 item 当前值的唯一标识。如果您覆写了这个 item 并想把它写回到 memcached中，您可以通过 cas 命令把那个唯一标识一起发送给 memcached。如果该 item存放在 memcached 中的唯一标识与您提供的一致，您的写操作将会成功。如果另一个进程在这期间也修改了这个 item，那么该 item 存放在 memcached 中的唯一标识将会改变，您的写操作就会失败</li>
</ul>
<h1 id="memcached-能够更有效地使用内存吗？"><a href="#memcached-能够更有效地使用内存吗？" class="headerlink" title="memcached 能够更有效地使用内存吗？"></a>memcached 能够更有效地使用内存吗？</h1><ul>
<li>Memcache 客户端仅根据哈希算法来决定将某个 key 存储在哪个节点上，而不考虑节点的内存大小。因此，您可以在不同的节点上使用大小不等的缓存。但是一般都是这样做的：拥有较多内存的节点上可以运行多个 memcached 实例，每个实例使用的内存跟其他节点上的实例相同。</li>
</ul>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/publishes/dffc02696193.html</url>
    <content><![CDATA[<h1 id="不可重复读和幻读到底有什么区别呢？"><a href="#不可重复读和幻读到底有什么区别呢？" class="headerlink" title="不可重复读和幻读到底有什么区别呢？"></a>不可重复读和幻读到底有什么区别呢？</h1><ul>
<li>不可重复读是读取了其他事务更改的数据，针对update操作</li>
<li>解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。</li>
<li>幻读是读取了其他事务新增的数据，针对insert操作</li>
<li>解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。</li>
</ul>
<h1 id="MySQL千万级的大表要怎么优化"><a href="#MySQL千万级的大表要怎么优化" class="headerlink" title="MySQL千万级的大表要怎么优化"></a>MySQL千万级的大表要怎么优化</h1><ul>
<li>读写分离、水平拆分、垂直拆分</li>
<li>如何设计或优化千万级别的大表？此外无其他信息，个人觉得这个话题有点范，就只好简单说下该如何做，对于一个存储设计，必须考虑业务特点，收集的信息如下：<ul>
<li>数据的容量：1-3年内会大概多少条数据，每条数据大概多少字节；</li>
<li>数据项：是否有大字段，那些字段的值是否经常被更新；</li>
<li>数据查询SQL条件：哪些数据项的列名称经常出现在WHERE、GROUP BY、ORDER BY子句中等；</li>
<li>数据更新类SQL条件：有多少列经常出现UPDATE或DELETE 的WHERE子句中；</li>
<li>SQL量的统计比，如：SELECT：UPDATE+DELETE：INSERT&#x3D;多少？</li>
<li>预计大表及相关联的SQL，每天总的执行量在何数量级？</li>
<li>表中的数据：更新为主的业务 还是 查询为主的业务 ？</li>
<li>打算采用什么数据库物理服务器，以及数据库服务器架构？</li>
<li>并发如何？</li>
<li>存储引擎选择InnoDB还是MyISAM？</li>
</ul>
</li>
<li>大致明白以上10个问题，至于如何设计此类的大表，应该什么都清楚了！</li>
<li>至于优化若是指创建好的表，不能变动表结构的话，那建议InnoDB引擎，多利用点内存，减轻磁盘IO负载，因为IO往往是数据库服务器的瓶颈</li>
<li>另外对优化索引结构去解决性能问题的话，建议优先考虑修改类SQL语句，使他们更快些，不得已只靠索引组织结构的方式，当然此话前提是， 索引已经创建的非常好，若是读为主，可以考虑打开query_cache，以及调整一些参数值：sort_buffer_size,read_buffer_size,read_rnd_buffer_size,join_buffer_size</li>
<li>以及调整一些参数值：sort_buffer_size,read_buffer_size,read_rnd_buffer_size,join_buffer_size</li>
</ul>
<h1 id="union和union-all有什么不同"><a href="#union和union-all有什么不同" class="headerlink" title="union和union all有什么不同?"></a>union和union all有什么不同?</h1><ul>
<li>Union和Union All的区别之一在于对重复结果的处理。</li>
<li>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION</li>
<li>而UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。</li>
<li>从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL，</li>
</ul>
<h1 id="oracle中除了数据库备份，还有什么方法备份？"><a href="#oracle中除了数据库备份，还有什么方法备份？" class="headerlink" title="oracle中除了数据库备份，还有什么方法备份？"></a>oracle中除了数据库备份，还有什么方法备份？</h1><ul>
<li>Oracle数据库有三种标准的备份方法，它们分别是导出&#x2F;导入(EXP&#x2F;IMP)、热备份和冷备份</li>
<li>导出备份是一种逻辑备份，冷备份和热备份是物理备份。</li>
</ul>
<h1 id="truncate与delete的区别？（delete-from-table和truncate-table-tablea的区别！）"><a href="#truncate与delete的区别？（delete-from-table和truncate-table-tablea的区别！）" class="headerlink" title="truncate与delete的区别？（delete from table和truncate table tablea的区别！）"></a>truncate与delete的区别？（delete from table和truncate table tablea的区别！）</h1><ul>
<li>truncate是DDL語言</li>
<li>delete是DML語言 DDL語言是自動提交的，命令完成就不可回滾.truncate的速度也比delete要快得多.</li>
<li>相同点:truncate和不带where子句的delete, 以及drop都会删除表内的数据  </li>
<li>不同点:  <ul>
<li>truncate和 delete只删除数据不删除表的结构(定义)  </li>
<li>drop语句将删除表的结构被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程&#x2F;函数将保留,但是变为invalid状态.  </li>
<li>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.  </li>
<li>truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.  </li>
<li>delete语句不影响表所占用的extent, 高水线(high watermark)保持原位置不动  </li>
<li>显然drop语句将表所占用的空间全部释放  </li>
<li>truncate 语句缺省情况下见空间释放到 minextents个 extent,除非使用reuse storage;   truncate会将高水线复位(回到最开始).</li>
</ul>
</li>
<li>速度,一般来说: drop&gt; truncate &gt; delete  </li>
<li>安全性:小心使用drop 和truncate,尤其没有备份的时候.否则哭都来不及  </li>
<li>使用上,想删除部分数据行用delete,注意带上where子句. 回滚段要足够大.  </li>
<li>想删除表,当然用drop  </li>
<li>想保留表而将所有数据删除. 如果和事务无关,用truncate即可. 如果和事务有关,或者想触发trigger,还是用delete.</li>
</ul>
<h1 id="Oracle冷备份的通常步骤"><a href="#Oracle冷备份的通常步骤" class="headerlink" title="Oracle冷备份的通常步骤"></a>Oracle冷备份的通常步骤</h1><ul>
<li>正常关闭数据库</li>
<li>备份所有重要的文件到备份目录（数据文件、控制文件、重做日志文件等）</li>
<li>完成备份后启动数据库用冷备份进行恢复时，只需要将所有文件恢复到原有位置，就可以启动数据库了</li>
<li>关闭数据库  SQL&gt;shutdown</li>
<li>备份文件到备份的目录</li>
<li>然后启动数据库 ＃sqlplus “&#x2F;as sysdba”SQL&gt;startup</li>
<li>冷备份完毕！！</li>
</ul>
<h1 id="对数据库的访问是怎么实现的"><a href="#对数据库的访问是怎么实现的" class="headerlink" title="对数据库的访问是怎么实现的"></a>对数据库的访问是怎么实现的</h1><ul>
<li>将对持久层数据库的基本添加，修改，查找等操作提取到BaseDAO中</li>
<li>采用JavaBean对数据进行封装，以便对持久层的数据能够很好的处理，实现BaseDAO设计对数据库访问的便捷</li>
<li>业务组件通过DAO 的委托接口调用DAO对象，使得上层组件不 直接依赖于DAO的实现类.</li>
</ul>
<h1 id="Mysql-的技术特点是什么？"><a href="#Mysql-的技术特点是什么？" class="headerlink" title="Mysql 的技术特点是什么？"></a>Mysql 的技术特点是什么？</h1><ul>
<li>Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。</li>
</ul>
<h1 id="Heap-表是什么？"><a href="#Heap-表是什么？" class="headerlink" title="Heap 表是什么？"></a>Heap 表是什么？</h1><ul>
<li>HEAP 表存在于内存中，用于临时高速存储。</li>
<li>BLOB 或 TEXT 字段是不允许的</li>
<li>只能使用比较运算符&#x3D;，&lt;，&gt;，&#x3D;&gt;，&#x3D; &lt;</li>
<li>HEAP 表不支持 AUTO_INCREMENT</li>
<li>索引不可为 NULL</li>
</ul>
<h1 id="Mysql-服务器默认端口是什么？"><a href="#Mysql-服务器默认端口是什么？" class="headerlink" title="Mysql 服务器默认端口是什么？"></a>Mysql 服务器默认端口是什么？</h1><ul>
<li>Mysql 服务器的默认端口是 3306。</li>
</ul>
<h1 id="与-Oracle-相比，Mysql-有什么优势？"><a href="#与-Oracle-相比，Mysql-有什么优势？" class="headerlink" title="与 Oracle 相比，Mysql 有什么优势？"></a>与 Oracle 相比，Mysql 有什么优势？</h1><ul>
<li>Mysql 是开源软件，随时可用，无需付费。</li>
<li>Mysql 是便携式的</li>
<li>带有命令提示符的 GUI。</li>
<li>使用 Mysql 查询浏览器支持管理</li>
</ul>
<h1 id="如何区分-FLOAT-和-DOUBLE？"><a href="#如何区分-FLOAT-和-DOUBLE？" class="headerlink" title="如何区分 FLOAT 和 DOUBLE？"></a>如何区分 FLOAT 和 DOUBLE？</h1><ul>
<li>以下是 FLOAT 和 DOUBLE 的区别：<ul>
<li>浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。</li>
<li>浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。</li>
</ul>
</li>
</ul>
<h1 id="区分-CHAR-LENGTH-和-LENGTH？"><a href="#区分-CHAR-LENGTH-和-LENGTH？" class="headerlink" title="区分 CHAR_LENGTH 和 LENGTH？"></a>区分 CHAR_LENGTH 和 LENGTH？</h1><ul>
<li>CHAR_LENGTH 是字符数，而 LENGTH 是字节数</li>
<li>Latin 字符的这两个数据是相同的，但是对于 Unicode 和其他编码，它们是不同的。</li>
</ul>
<h1 id="在-Mysql-中-ENUM-的用法是什么？"><a href="#在-Mysql-中-ENUM-的用法是什么？" class="headerlink" title="在 Mysql 中 ENUM 的用法是什么？"></a>在 Mysql 中 ENUM 的用法是什么？</h1><ul>
<li>ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。</li>
<li>Create table size(name ENUM(‘Smail,’Medium’,’Large’));</li>
</ul>
<h1 id="如何定义-REGEXP？"><a href="#如何定义-REGEXP？" class="headerlink" title="如何定义 REGEXP？"></a>如何定义 REGEXP？</h1><ul>
<li>REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置。</li>
</ul>
<h1 id="列的字符串类型可以是什么？"><a href="#列的字符串类型可以是什么？" class="headerlink" title="列的字符串类型可以是什么？"></a>列的字符串类型可以是什么？</h1><ul>
<li>字符串类型是：<ul>
<li>SET</li>
<li>BLOB</li>
<li>ENUM</li>
<li>CHAR</li>
<li>TEXT</li>
<li>VARCHAR</li>
</ul>
</li>
</ul>
<h1 id="如何获取当前的-Mysql-版本？"><a href="#如何获取当前的-Mysql-版本？" class="headerlink" title="如何获取当前的 Mysql 版本？"></a>如何获取当前的 Mysql 版本？</h1><ul>
<li>SELECT VERSION();用于获取当前 Mysql 的版本。</li>
</ul>
<h1 id="Mysql-中使用什么存储引擎？"><a href="#Mysql-中使用什么存储引擎？" class="headerlink" title="Mysql 中使用什么存储引擎？"></a>Mysql 中使用什么存储引擎？</h1><ul>
<li>存储引擎称为表类型，数据使用各种技术存储在文件中。</li>
<li>技术涉及：<ul>
<li>Storage mechanism</li>
<li>Locking levels</li>
<li>Indexing</li>
<li>Capabilities and functions.</li>
</ul>
</li>
</ul>
<h1 id="Mysql-驱动程序是什么？"><a href="#Mysql-驱动程序是什么？" class="headerlink" title="Mysql 驱动程序是什么？"></a>Mysql 驱动程序是什么？</h1><ul>
<li>以下是 Mysql 中可用的驱动程序：<ul>
<li>PHP 驱动程序</li>
<li>JDBC 驱动程序</li>
<li>ODBC 驱动程序</li>
<li>CWRAPPER PYTHON驱动程序 </li>
<li>PERL 驱动程序 </li>
<li>RUBY 驱动程序 </li>
<li>CAP11PHP 驱动程序</li>
</ul>
</li>
</ul>
<h1 id="TIMESTAMP-在-UPDATE-CURRENT-TIMESTAMP-数据类型上做什么？"><a href="#TIMESTAMP-在-UPDATE-CURRENT-TIMESTAMP-数据类型上做什么？" class="headerlink" title="TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？"></a>TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？</h1><ul>
<li>创建表时 TIMESTAMP 列用 Zero 更新</li>
<li>只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。</li>
</ul>
<h1 id="如何使用-Unix-shell-登录-Mysql？"><a href="#如何使用-Unix-shell-登录-Mysql？" class="headerlink" title="如何使用 Unix shell 登录 Mysql？"></a>如何使用 Unix shell 登录 Mysql？</h1><ul>
<li>mysql -h hostname -u</li>
</ul>
<h1 id="如何控制-HEAP-表的最大尺寸？"><a href="#如何控制-HEAP-表的最大尺寸？" class="headerlink" title="如何控制 HEAP 表的最大尺寸？"></a>如何控制 HEAP 表的最大尺寸？</h1><ul>
<li>Heal 表的大小可通过称为 max_heap_table_size 的 Mysql 配置变量来控制。</li>
</ul>
<h1 id="federated-表是什么？"><a href="#federated-表是什么？" class="headerlink" title="federated 表是什么？"></a>federated 表是什么？</h1><ul>
<li>federated 表，允许访问位于其他服务器数据库上的表。</li>
</ul>
<h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h1><ul>
<li>LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。</li>
</ul>
<h1 id="你怎么看到为表格定义的所有索引？"><a href="#你怎么看到为表格定义的所有索引？" class="headerlink" title="你怎么看到为表格定义的所有索引？"></a>你怎么看到为表格定义的所有索引？</h1><ul>
<li>索引是通过以下方式为表格定义的：SHOW INDEX FROM</li>
</ul>
<h1 id="LIKE-声明中的％和-是什么意思？"><a href="#LIKE-声明中的％和-是什么意思？" class="headerlink" title="LIKE 声明中的％和_是什么意思？"></a>LIKE 声明中的％和_是什么意思？</h1><ul>
<li>％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。</li>
</ul>
<h1 id="如何在-Unix-和-Mysql-时间戳之间进行转换？"><a href="#如何在-Unix-和-Mysql-时间戳之间进行转换？" class="headerlink" title="如何在 Unix 和 Mysql 时间戳之间进行转换？"></a>如何在 Unix 和 Mysql 时间戳之间进行转换？</h1><ul>
<li>UNIX_TIMESTAMP 是从 Mysql 时间戳转换为 Unix 时间戳的命令</li>
<li>FROM_UNIXTIME 是从 Unix 时间戳转换为 Mysql 时间戳的命令</li>
</ul>
<h1 id="列对比运算符是什么？"><a href="#列对比运算符是什么？" class="headerlink" title="列对比运算符是什么？"></a>列对比运算符是什么？</h1><ul>
<li>在 SELECT 语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，OR 或 LIKE 运算符。</li>
</ul>
<h1 id="LIKE-和-REGEXP-操作有什么区别？"><a href="#LIKE-和-REGEXP-操作有什么区别？" class="headerlink" title="LIKE 和 REGEXP 操作有什么区别？"></a>LIKE 和 REGEXP 操作有什么区别？</h1><ul>
<li>LIKE 和 REGEXP 运算符用于表示^和％。</li>
<li>SELECT * FROM employee WHERE emp_name REGEXP “^b”;</li>
<li>SELECT * FROM employee WHERE emp_name LIKE “%b”;</li>
</ul>
<h1 id="BLOB-和-TEXT-有什么区别？"><a href="#BLOB-和-TEXT-有什么区别？" class="headerlink" title="BLOB 和 TEXT 有什么区别？"></a>BLOB 和 TEXT 有什么区别？</h1><ul>
<li>BLOB 是一个二进制对象，可以容纳可变数量的数据</li>
<li>有四种类型的 BLOB<ul>
<li>TINYBLOB</li>
<li>BLOB</li>
<li>MEDIUMBLOB</li>
<li>LONGBLOB</li>
</ul>
</li>
<li>它们只能在所能容纳价值的最大长度上有所不同。</li>
<li>TEXT 是一个不区分大小写的 BLOB</li>
<li>四种 TEXT 类型<ul>
<li>TINYTEXT</li>
<li>TEXT</li>
<li>MEDIUMTEXT </li>
<li>LONGTEXT</li>
</ul>
</li>
<li>它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。</li>
<li>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT值不区分大小写。</li>
</ul>
<h1 id="mysql-fetch-array-和-mysql-fetch-object-的区别是什么？"><a href="#mysql-fetch-array-和-mysql-fetch-object-的区别是什么？" class="headerlink" title="mysql_fetch_array 和 mysql_fetch_object 的区别是什么？"></a>mysql_fetch_array 和 mysql_fetch_object 的区别是什么？</h1><ul>
<li>mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。</li>
<li>mysql_fetch_object - 从数据库返回结果行作为对象。</li>
</ul>
<h1 id="我们如何在-mysql-中运行批处理模式？"><a href="#我们如何在-mysql-中运行批处理模式？" class="headerlink" title="我们如何在 mysql 中运行批处理模式？"></a>我们如何在 mysql 中运行批处理模式？</h1><ul>
<li>以下命令用于在批处理模式下运行：<ul>
<li>mysql;</li>
<li>mysql mysql.out</li>
</ul>
</li>
</ul>
<h1 id="MyISAM-表格将在哪里存储，并且还提供其存储格式？"><a href="#MyISAM-表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="MyISAM 表格将在哪里存储，并且还提供其存储格式？"></a>MyISAM 表格将在哪里存储，并且还提供其存储格式？</h1><ul>
<li>每个 MyISAM 表格以三种格式存储在磁盘上：<ul>
<li>·“.frm”文件存储表定义</li>
<li>·数据文件具有“.MYD”（MYData）扩展名</li>
<li>索引文件具有“.MYI”（MYIndex）扩展名</li>
</ul>
</li>
</ul>
<h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><ul>
<li>共有 5 种类型的表格：<ul>
<li>MyISAM</li>
<li>Heap</li>
<li>Merge</li>
<li>INNODB</li>
<li>ISAM</li>
</ul>
</li>
<li>MyISAM 是 Mysql 的默认存储引擎。</li>
</ul>
<h1 id="ISAM-是什么？"><a href="#ISAM-是什么？" class="headerlink" title="ISAM 是什么？"></a>ISAM 是什么？</h1><ul>
<li>ISAM 简称为索引顺序访问方法</li>
<li>它是由 IBM 开发的，用于在磁带等辅助存储系统上存储和检索数据。</li>
</ul>
<h1 id="InnoDB-是什么？"><a href="#InnoDB-是什么？" class="headerlink" title="InnoDB 是什么？"></a>InnoDB 是什么？</h1><ul>
<li>lnnoDB 是一个由 Oracle 公司开发的 Innobase Oy 事务安全存储引擎。</li>
</ul>
<h1 id="Mysql-如何优化-DISTINCT？"><a href="#Mysql-如何优化-DISTINCT？" class="headerlink" title="Mysql 如何优化 DISTINCT？"></a>Mysql 如何优化 DISTINCT？</h1><ul>
<li>DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。</li>
<li>SELECT DISTINCT t1.a FROM t1,t2 where t1.a&#x3D;t2.a;</li>
</ul>
<h1 id="如何输入字符为十六进制数字？"><a href="#如何输入字符为十六进制数字？" class="headerlink" title="如何输入字符为十六进制数字？"></a>如何输入字符为十六进制数字？</h1><ul>
<li>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。</li>
<li>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。</li>
</ul>
<h1 id="如何显示前-50-行？"><a href="#如何显示前-50-行？" class="headerlink" title="如何显示前 50 行？"></a>如何显示前 50 行？</h1><ul>
<li>在 Mysql 中，使用以下代码查询显示前 50 行：</li>
<li>SELECT*FROM LIMIT 0,50;</li>
</ul>
<h1 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><ul>
<li>任何标准表最多可以创建 16 个索引列。</li>
</ul>
<h1 id="NOW（）和-CURRENT-DATE（）有什么区别？"><a href="#NOW（）和-CURRENT-DATE（）有什么区别？" class="headerlink" title="NOW（）和 CURRENT_DATE（）有什么区别？"></a>NOW（）和 CURRENT_DATE（）有什么区别？</h1><ul>
<li>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</li>
<li>CURRENT_DATE（）仅显示当前年份，月份和日期。</li>
</ul>
<h1 id="Mysql-表中允许有多少个-TRIGGERS？"><a href="#Mysql-表中允许有多少个-TRIGGERS？" class="headerlink" title="Mysql 表中允许有多少个 TRIGGERS？"></a>Mysql 表中允许有多少个 TRIGGERS？</h1><ul>
<li>在 Mysql 表中允许有六个触发器，如下：<ul>
<li>BEFORE INSERT</li>
<li>AFTER INSERT</li>
<li>BEFORE UPDATE</li>
<li>AFTER UPDATE</li>
<li>BEFORE DELETE</li>
<li>AFTER DELETE</li>
</ul>
</li>
</ul>
<h1 id="什么是非标准字符串类型？"><a href="#什么是非标准字符串类型？" class="headerlink" title="什么是非标准字符串类型？"></a>什么是非标准字符串类型？</h1><ul>
<li>以下是非标准字符串类型：<ul>
<li>TINYTEXT</li>
<li>TEXT</li>
<li>MEDIUMTEXT</li>
<li>LONGTEXT</li>
</ul>
</li>
</ul>
<h1 id="解释访问控制列表"><a href="#解释访问控制列表" class="headerlink" title="解释访问控制列表"></a>解释访问控制列表</h1><ul>
<li>ACL（访问控制列表）是与对象关联的权限列表</li>
<li>这个列表是 Mysql 服务器安全模型的基础，它有助于排除用户无法连接的问题。</li>
<li>Mysql 将 ACL（也称为授权表）缓存在内存中</li>
<li>当用户尝试认证或运行命令时，Mysql 会按照预定的顺序检查 ACL 的认证信息和权限。</li>
</ul>
<h1 id="MYSQL-支持事务吗？"><a href="#MYSQL-支持事务吗？" class="headerlink" title="MYSQL 支持事务吗？"></a>MYSQL 支持事务吗？</h1><ul>
<li>在缺省模式下，MYSQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql 是不支持事务的。</li>
<li>但是如果你的 MYSQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的 MYSQL 就可以使用事务处理,使用 SET AUTOCOMMIT&#x3D;0 就可以使 MYSQL 允许在非 autocommit 模式，在非autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK 来回滚你的更改。</li>
</ul>
<h1 id="mysql-里记录货币用什么字段类型好"><a href="#mysql-里记录货币用什么字段类型好" class="headerlink" title="mysql 里记录货币用什么字段类型好"></a>mysql 里记录货币用什么字段类型好</h1><ul>
<li>NUMERIC 和 DECIMAL 类型被 Mysql 实现为同样的类型，这在 SQL92 标准允许</li>
<li>他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据</li>
<li>当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。</li>
</ul>
<h1 id="MYSQL-数据表在什么情况下容易损坏？"><a href="#MYSQL-数据表在什么情况下容易损坏？" class="headerlink" title="MYSQL 数据表在什么情况下容易损坏？"></a>MYSQL 数据表在什么情况下容易损坏？</h1><ul>
<li>服务器突然断电导致数据文件损坏。</li>
<li>强制关机，没有先关闭 mysql 服务等。</li>
</ul>
<h1 id="mysql-有关权限的表都有哪几个？"><a href="#mysql-有关权限的表都有哪几个？" class="headerlink" title="mysql 有关权限的表都有哪几个？"></a>mysql 有关权限的表都有哪几个？</h1><ul>
<li>Mysql 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里</li>
<li>由mysql_install_db 脚本初始化</li>
<li>这些权限表分别 user，db，table_priv，columns_priv 和host。</li>
</ul>
<h1 id="一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，"><a href="#一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，" class="headerlink" title="一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，"></a>一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，</h1><ul>
<li>删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？</li>
<li>如果表的类型是MylSAM，那么是18因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失</li>
<li>如果表的类型是InnoDB，那么是15InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。</li>
</ul>
<h1 id="Myql-中的事务回滚机制概述"><a href="#Myql-中的事务回滚机制概述" class="headerlink" title="Myql 中的事务回滚机制概述"></a>Myql 中的事务回滚机制概述</h1><ul>
<li>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</li>
<li>要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚</li>
</ul>
<h1 id="可以使用多少列创建索引？-1"><a href="#可以使用多少列创建索引？-1" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><ul>
<li>任何标准表最多可以创建 16 个索引列。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/publishes/2f1abbd5b4e4.html</url>
    <content><![CDATA[<h1 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h1><ul>
<li>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<ul>
<li>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</li>
</ul>
</li>
<li>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<ul>
<li>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li>
</ul>
</li>
<li>向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<ul>
<li>解决：Mybatis自动将java对象映射至sql语句。</li>
</ul>
</li>
<li>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<ul>
<li>解决：Mybatis自动将sql执行结果映射至java对象。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h1><ul>
<li>创建SqlSessionFactory</li>
<li>通过SqlSessionFactory创建SqlSession</li>
<li>通过sqlsession执行数据库操作</li>
<li>调用session.commit()提交事务</li>
<li>调用session.close()关闭会话</li>
</ul>
<h1 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h1><ul>
<li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li>
<li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li>
<li>Hibernate对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O&#x2F;R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li>
<li>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</li>
</ul>
<p> </p>
<h1 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h1><ul>
<li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同</li>
<li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</li>
<li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li>
<li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li>
</ul>
<h1 id="SqlMapConfig-xml中配置有哪些内容？"><a href="#SqlMapConfig-xml中配置有哪些内容？" class="headerlink" title="SqlMapConfig.xml中配置有哪些内容？"></a>SqlMapConfig.xml中配置有哪些内容？</h1><ul>
<li>SqlMapConfig.xml中配置的内容和顺序如下： <ul>
<li>properties（属性）</li>
<li>settings（配置）</li>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）</li>
<li>environments（环境集合属性对象）</li>
<li>environment（环境子属性对象）</li>
<li>transactionManager（事务管理）</li>
<li>dataSource（数据源）</li>
<li>mappers（映射器）</li>
</ul>
</li>
</ul>
<h1 id="简单的说一下MyBatis的一级缓存和二级缓存？"><a href="#简单的说一下MyBatis的一级缓存和二级缓存？" class="headerlink" title="简单的说一下MyBatis的一级缓存和二级缓存？"></a>简单的说一下MyBatis的一级缓存和二级缓存？</h1><ul>
<li>Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。</li>
<li>Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象</li>
<li>Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。</li>
</ul>
<h1 id="Mapper编写有哪几种方式？"><a href="#Mapper编写有哪几种方式？" class="headerlink" title="Mapper编写有哪几种方式？"></a>Mapper编写有哪几种方式？</h1><h4 id="接口实现类继承SqlSessionDaoSupport"><a href="#接口实现类继承SqlSessionDaoSupport" class="headerlink" title="接口实现类继承SqlSessionDaoSupport"></a>接口实现类继承SqlSessionDaoSupport</h4><ul>
<li><p>使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件</p>
</li>
<li><p>在sqlMapConfig.xml中配置mapper.xml的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义mapper接口</p>
</li>
<li><p>实现类集成SqlSessionDaoSupport</p>
</li>
<li><p>mapper方法中可以this.getSqlSession()进行数据增删改查。</p>
</li>
<li><p>spring 配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot; &quot; class=&quot;mapper接口的实现&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用org-mybatis-spring-mapper-MapperFactoryBean"><a href="#使用org-mybatis-spring-mapper-MapperFactoryBean" class="headerlink" title="使用org.mybatis.spring.mapper.MapperFactoryBean"></a>使用org.mybatis.spring.mapper.MapperFactoryBean</h4><ul>
<li><p>在sqlMapConfig.xml中配置mapper.xml的位置</p>
</li>
<li><p>如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义mapper接口</p>
</li>
<li><p>注意</p>
<ul>
<li>mapper.xml中的namespace为mapper接口的地址</li>
<li>mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</li>
</ul>
</li>
<li><p>Spring中定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;mapperInterface&quot;   value=&quot;mapper接口地址&quot; /&gt;  </span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </span><br><span class="line">4&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用mapper扫描器"><a href="#使用mapper扫描器" class="headerlink" title="使用mapper扫描器"></a>使用mapper扫描器</h4><ul>
<li><p>mapper.xml文件编写，</p>
</li>
<li><p>注意：<br>-mapper.xml中的namespace为mapper接口的地址<br>-mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</p>
<ul>
<li>如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置</li>
</ul>
<p> </p>
</li>
<li><p>定义mapper接口</p>
<ul>
<li>注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录</li>
</ul>
</li>
<li><p>配置mapper扫描器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;mapper接口包地址&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用扫描器后从spring容器中获取mapper的实现对象</p>
</li>
<li><p>扫描器将接口通过代理方法生成实现对象，要spring容器中自动注册，名称为mapper 接口的名称。</p>
</li>
</ul>
<h1 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h1><ul>
<li>#{}是预编译处理，${}是字符串替换。</li>
<li>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set方法来赋值；</li>
<li>Mybatis 在处理${}时，就是把${}替换成变量的值。</li>
<li>使用#{}可以有效的防止 SQL 注入，提高系统安全性。</li>
</ul>
<h1 id="通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，"><a href="#通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，" class="headerlink" title="通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，"></a>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，</h1><ul>
<li>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</li>
<li>Dao 接口，就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement</li>
<li>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao 下面 id &#x3D; findStudentById 的MappedStatement。在 Mybatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个 MappedStatement 对象。</li>
<li>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li>
<li>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement 所代表的 sql，然后将 sql 执行结果返回。</li>
</ul>
<h1 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><ul>
<li>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</li>
<li>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</li>
</ul>
<h1 id="Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><ul>
<li>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系</li>
<li>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</li>
</ul>
<h1 id="Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h1><ul>
<li>注：这道题出自京东面试官。</li>
<li>还有很多其他的标签，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中为sql片段标签，通过标签引入 sql 片段，为不支持自增的主键生成策略标签。</li>
</ul>
<h1 id="简述-Mybatis-的插件运行原理，以及如何编写一个插件"><a href="#简述-Mybatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述 Mybatis 的插件运行原理，以及如何编写一个插件"></a>简述 Mybatis 的插件运行原理，以及如何编写一个插件</h1><ul>
<li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li>
<li>实现 Mybatis 的 Interceptor 接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</li>
</ul>
<h1 id="一级、二级缓存"><a href="#一级、二级缓存" class="headerlink" title="一级、二级缓存"></a>一级、二级缓存</h1><ul>
<li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。</li>
<li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如Ehcache</li>
<li>要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：<cache/></li>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存Session&#x2F;二级缓存Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ul>
<h1 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><ul>
<li>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载</li>
<li>association 指的就是一对一，collection 指的就是一对多查询</li>
<li>在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。</li>
<li>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li>
</ul>
<h1 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h1><ul>
<li>虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。</li>
<li>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</li>
</ul>
<h1 id="简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h1><ul>
<li>Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部</li>
<li>在 Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultMap>标签会被解析为ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。</li>
</ul>
<h1 id="ibatis-中的-与-的区别"><a href="#ibatis-中的-与-的区别" class="headerlink" title="ibatis 中的#与$的区别"></a>ibatis 中的#与$的区别</h1><ul>
<li>#是把传入的数据当作字符串，如#field#传入的是id,则sql语句生成是这样，order by “id”,这当然会报错．．</li>
<li>$传入的数据直接生成在sql里，如#field#传入的是id,则sql语句生成是这样，order by id, 这就对了．</li>
<li>#方式能够很大程度防止sql注入．</li>
<li>$方式无法方式sql注入．</li>
<li>$方式一般用于传入数据库对象．例如传入表名.</li>
<li>一般能用#的就别用$.</li>
</ul>
<h1 id="什么情况下用注解绑定-什么情况下用-xml-绑定？"><a href="#什么情况下用注解绑定-什么情况下用-xml-绑定？" class="headerlink" title="什么情况下用注解绑定,什么情况下用 xml 绑定？"></a>什么情况下用注解绑定,什么情况下用 xml 绑定？</h1><ul>
<li>当 Sql 语句比较简单时候,用注解绑定</li>
<li>当 SQL 语句比较复杂时候,用 xml 绑定,</li>
<li>一般用 xml 绑定的比较多</li>
</ul>
<h1 id="MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>MyBatis 实现一对一有几种方式?具体怎么操作的？</h1><ul>
<li>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap 里面配置 association 节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过 select 属性配置。</li>
</ul>
<h1 id="MyBatis-接口绑定有几种实现方式-分别是怎么实现的"><a href="#MyBatis-接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="MyBatis 接口绑定有几种实现方式,分别是怎么实现的?"></a>MyBatis 接口绑定有几种实现方式,分别是怎么实现的?</h1><ul>
<li>接口绑定有两种实现方式<ul>
<li>一种是通过注解绑定,就是在接口的方法上面加上@Select@Update 等注解里面包含 Sql 语句来绑定</li>
<li>另外一种就是通过 xml 里面写 SQL来绑定,在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名.</li>
</ul>
</li>
</ul>
<h1 id="Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？-1"><a href="#Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？-1" class="headerlink" title="Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><ul>
<li>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</li>
<li>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis一样可以正常工作。</li>
<li>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</li>
</ul>
<h1 id="使用-MyBatis-的-mapper-接口调用时有哪些要求？"><a href="#使用-MyBatis-的-mapper-接口调用时有哪些要求？" class="headerlink" title="使用 MyBatis 的 mapper 接口调用时有哪些要求？"></a>使用 MyBatis 的 mapper 接口调用时有哪些要求？</h1><ul>
<li>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同</li>
<li>Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的parameterType 的类型相同</li>
<li>Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的resultType 的类型相同</li>
<li>Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。</li>
</ul>
<h1 id="MyBatis-里面的动态-Sql-是怎么设定的-用什么语法"><a href="#MyBatis-里面的动态-Sql-是怎么设定的-用什么语法" class="headerlink" title="MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?"></a>MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?</h1><ul>
<li>MyBatis 里面的动态 Sql 一般是通过 if 节点来实现,通过 OGNL 语法来实现,但是如果要写的完整,必须配合 where,trim 节点,where 节点是判断包含节点有内容就插入where,否则不插入,trim 节点是用来判断如果动态语句是以 and 或 or 开始,那么会自动把这个 and 或者 or 取掉。</li>
</ul>
<h1 id="Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"><a href="#Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？" class="headerlink" title="Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"></a>Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h1><ul>
<li>能</li>
<li>Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为selectList()即可。</li>
<li>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql查询，就可以把主对象和其关联对象查出来。</li>
</ul>
<h1 id="什么是-MyBatis-的接口绑定-有什么好处？"><a href="#什么是-MyBatis-的接口绑定-有什么好处？" class="headerlink" title="什么是 MyBatis 的接口绑定,有什么好处？"></a>什么是 MyBatis 的接口绑定,有什么好处？</h1><ul>
<li>接口映射就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定,我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置.</li>
</ul>
<h1 id="简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？-1"><a href="#简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？-1" class="headerlink" title="简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h1><ul>
<li>Mybatis 将所有Xml 配置信息都封装到All-In-One 重量级对象 Configuration内部</li>
<li>在 Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultMap>标签会被解析为ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、 <insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。</li>
</ul>
<h1 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h1><ul>
<li>Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，不过 mybatis 可以通过 XML 或注解方式灵活配置要运行的sql 语句，并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成 java 对象。</li>
<li>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 sql 映射文件，工作量大。</li>
<li>Hibernate 对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O&#x2F;R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</li>
</ul>
<h1 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h1><ul>
<li>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</li>
</ul>
<h1 id="Mybatis-是如何进行分页的？分页插件的原理是什么？-1"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？-1" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><ul>
<li>Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。</li>
<li>分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql。</li>
<li>select * from student，拦截 sql 后重写为：select t.* from （select * from student）t limit 0，10</li>
</ul>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/publishes/b318dfbd2190.html</url>
    <content><![CDATA[<h1 id="BIO、NIO和AIO的区别？"><a href="#BIO、NIO和AIO的区别？" class="headerlink" title="BIO、NIO和AIO的区别？"></a>BIO、NIO和AIO的区别？</h1><ul>
<li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</li>
<li>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</li>
<li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li>
<li>AIO：一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的。</li>
<li>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I&#x2F;O，I&#x2F;O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。</li>
<li>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作</li>
<li>如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<h1 id="NIO的组成"><a href="#NIO的组成" class="headerlink" title="NIO的组成"></a>NIO的组成</h1><ul>
<li>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</li>
<li>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</li>
<li>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。</li>
<li>rewind方法 ： 重绕此缓冲区，将position置为0</li>
<li>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I&#x2F;O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</li>
<li>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！</li>
<li>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</li>
<li>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</li>
<li>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</li>
<li>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取<br>-NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</li>
</ul>
<h1 id="Netty的特点？"><a href="#Netty的特点？" class="headerlink" title="Netty的特点？"></a>Netty的特点？</h1><ul>
<li>一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持</li>
<li>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。</li>
<li>采用多种decoder&#x2F;encoder 支持，对TCP粘包&#x2F;分包进行自动化处理</li>
<li>可使用接受&#x2F;处理线程池，提高连接效率，对重连、心跳检测的简单支持</li>
<li>可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf</li>
<li>通过引用计数器及时申请释放不再引用的对象，降低了GC频率</li>
<li>使用单线程串行化的方式，高效的Reactor线程模型</li>
<li>大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用</li>
</ul>
<h1 id="Netty的线程模型？"><a href="#Netty的线程模型？" class="headerlink" title="Netty的线程模型？"></a>Netty的线程模型？</h1><ul>
<li>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池</li>
<li>其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池</li>
<li>其中work线程池负责请求的read和write事件，由对应的Handler处理。</li>
</ul>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><ul>
<li>所有I&#x2F;O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的</li>
<li>既要接收客户端的连接请求,向服务端发起连接，又要发送&#x2F;读取请求或应答&#x2F;响应消息</li>
<li>一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</li>
</ul>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul>
<li>有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求</li>
<li>NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送</li>
<li>1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题</li>
<li>但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</li>
</ul>
<h4 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h4><ul>
<li>Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I&#x2F;O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；</li>
</ul>
<h1 id="TCP-粘包-拆包的原因及解决方法？"><a href="#TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="TCP 粘包&#x2F;拆包的原因及解决方法？"></a>TCP 粘包&#x2F;拆包的原因及解决方法？</h1><ul>
<li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li>
</ul>
<h4 id="TCP粘包-分包的原因："><a href="#TCP粘包-分包的原因：" class="headerlink" title="TCP粘包&#x2F;分包的原因："></a>TCP粘包&#x2F;分包的原因：</h4><ul>
<li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象</li>
<li>而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</li>
<li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li>
<li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>消息定长：FixedLengthFrameDecoder类</li>
<li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
<h1 id="了解哪几种序列化协议？"><a href="#了解哪几种序列化协议？" class="headerlink" title="了解哪几种序列化协议？"></a>了解哪几种序列化协议？</h1><ul>
<li>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；</li>
<li>反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</li>
<li>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</li>
</ul>
<h4 id="Java默认提供的序列化"><a href="#Java默认提供的序列化" class="headerlink" title="Java默认提供的序列化"></a>Java默认提供的序列化</h4><ul>
<li>无法跨语言、序列化后的码流太大、序列化的性能差</li>
</ul>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><ul>
<li>优点：人机可读性好，可指定元素或特性的名称</li>
<li>缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽</li>
<li>适用场景：当做配置文件存储数据，实时数据转换。</li>
</ul>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul>
<li>是一种轻量级的数据交换格式</li>
<li>优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快</li>
<li>缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大</li>
<li>适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li>
</ul>
<h4 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h4><ul>
<li>采用一种“假定有序快速匹配”的算法</li>
<li>优点：接口简单易用、目前java语言中最快的json库</li>
<li>缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全</li>
<li>适用场景：协议交互、Web输出、Android客户端</li>
</ul>
<h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><ul>
<li>不仅是序列化协议，还是一个RPC框架</li>
<li>优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码</li>
<li>缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议</li>
<li>适用场景：分布式系统的RPC解决方案</li>
</ul>
<h4 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h4><ul>
<li>Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题</li>
<li>优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现</li>
<li>缺点：对于习惯于静态类型语言的用户不直观</li>
<li>适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</li>
</ul>
<h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><ul>
<li>将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性</li>
<li>优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护</li>
<li>缺点：需要依赖于工具生成代码、支持的语言相对较少</li>
<li>适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li>protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可</li>
<li>Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口</li>
<li>Message pack 一个高效的二进制序列化格式</li>
<li>Hessian 采用二进制协议的轻量级remoting onhttp工具</li>
<li>kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）</li>
</ul>
<h1 id="如何选择序列化协议？"><a href="#如何选择序列化协议？" class="headerlink" title="如何选择序列化协议？"></a>如何选择序列化协议？</h1><h4 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h4><ul>
<li>对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。</li>
<li>基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选</li>
<li>对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</li>
<li>对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</li>
<li>当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</li>
<li>对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。</li>
<li>对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯</li>
<li>由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</li>
<li>如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</li>
<li>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</li>
<li>protobuf的数据类型有多种<ul>
<li>bool、double、float、int32、int64、string、bytes、enum、message</li>
<li>protobuf的限定符：<ul>
<li>required: 必须赋值，不能为空</li>
<li>optional:字段可以赋值，也可以不赋值</li>
<li>repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="protobuf的基本规则"><a href="#protobuf的基本规则" class="headerlink" title="protobuf的基本规则"></a>protobuf的基本规则</h4><ul>
<li>每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段</li>
<li>repeated表示的字段可以包含0个或多个数据</li>
<li>[1,15]之内的标识号在编码的时候会占用一个字节（常用）</li>
<li>[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。</li>
<li>protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。</li>
<li>编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder &#x3D; UserProto.User.newBuilder();builder.build()；</li>
<li>Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类</li>
<li>将StringBuilder转换为ByteBuf类型：copiedBuffer()方法</li>
</ul>
<h1 id="Netty的零拷贝实现？"><a href="#Netty的零拷贝实现？" class="headerlink" title="Netty的零拷贝实现？"></a>Netty的零拷贝实现？</h1><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝</li>
<li>堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中</li>
<li>ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li>
<li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer</li>
<li>addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li>
<li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li>
<li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</li>
<li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li>
<li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。</li>
</ul>
<h1 id="Netty的高性能表现在哪些方面？"><a href="#Netty的高性能表现在哪些方面？" class="headerlink" title="Netty的高性能表现在哪些方面？"></a>Netty的高性能表现在哪些方面？</h1><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><ul>
<li>对服务端：会定时清除闲置会话inactive(netty5)</li>
<li>对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态</li>
</ul>
<h4 id="串行无锁化设计"><a href="#串行无锁化设计" class="headerlink" title="串行无锁化设计"></a>串行无锁化设计</h4><ul>
<li>即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁</li>
<li>表面上看，串行化设计似乎CPU利用率不高，并发程度不够</li>
<li>但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</li>
</ul>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul>
<li>链路有效性检测：链路空闲检测机制，读&#x2F;写空闲超时机制</li>
<li>内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护</li>
<li>优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</li>
</ul>
<h4 id="Netty安全性"><a href="#Netty安全性" class="headerlink" title="Netty安全性"></a>Netty安全性</h4><ul>
<li>支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。</li>
</ul>
<h4 id="高效并发编程的体现"><a href="#高效并发编程的体现" class="headerlink" title="高效并发编程的体现"></a>高效并发编程的体现</h4><ul>
<li>volatile的大量、正确使用</li>
<li>CAS和原子类的广泛使用</li>
<li>线程安全容器的使用</li>
<li>通过读写锁提升并发性能</li>
<li>IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）</li>
</ul>
<h4 id="流量整型的作用（变压器）"><a href="#流量整型的作用（变压器）" class="headerlink" title="流量整型的作用（变压器）"></a>流量整型的作用（变压器）</h4><ul>
<li>防止由于上下游网关性能不均衡导致下游网关被压垮，业务流中断</li>
<li>防止由于通信模块接收消息过快，后端业务线程处理不及时导致撑死问题。</li>
</ul>
<h4 id="TCP参数配置"><a href="#TCP参数配置" class="headerlink" title="TCP参数配置"></a>TCP参数配置</h4><ul>
<li>SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K</li>
<li>SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率</li>
<li>但是对于时延敏感的应用场景需要关闭该优化算法；</li>
</ul>
<h1 id="NIOEventLoopGroup源码？"><a href="#NIOEventLoopGroup源码？" class="headerlink" title="NIOEventLoopGroup源码？"></a>NIOEventLoopGroup源码？</h1><ul>
<li>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。</li>
<li>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素</li>
<li>如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回</li>
<li>如果taskQueue没有元素，执行 select(oldWakenUp) 方法</li>
<li>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。</li>
<li>rebuildSelector方法先通过openSelector方法创建一个新的selector</li>
<li>然后将old selector的selectionKey执行cancel</li>
<li>最后将old selector的channel重新注册到新的selector中</li>
<li>rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</li>
<li>接下来调用processSelectedKeys 方法（处理I&#x2F;O任务），当selectedKeys !&#x3D; null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。</li>
<li>最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。</li>
<li>每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。</li>
<li>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head</li>
<li>Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。</li>
</ul>
<h4 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h4><ul>
<li>首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成</li>
<li>Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址</li>
<li>当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了</li>
<li>大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。</li>
</ul>
<h4 id="ByteBuf的特点"><a href="#ByteBuf的特点" class="headerlink" title="ByteBuf的特点"></a>ByteBuf的特点</h4><ul>
<li>支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）</li>
<li>不需要调用flip()来切换读&#x2F;写模式，读取和写入索引分开</li>
<li>方法链</li>
<li>引用计数基于AtomicIntegerFieldUpdater用于内存回收</li>
<li>PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象</li>
<li>UnpooledHeapByteBuf每次都会新建一个缓冲区对象。</li>
</ul>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/publishes/0777702c9d7f.html</url>
    <content><![CDATA[<h1 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h1><ul>
<li>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。</li>
<li>当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。</li>
<li>除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</li>
<li>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。</li>
<li>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</li>
<li>RPC 在我们熟知的各种中间件中都有它的身影。</li>
<li>Nginx&#x2F;Redis&#x2F;MySQL&#x2F;Dubbo&#x2F;Hadoop&#x2F;Spark&#x2F;Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的</li>
<li>我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。</li>
</ul>
<h1 id="Nginx-与-RPC"><a href="#Nginx-与-RPC" class="headerlink" title="Nginx 与 RPC"></a>Nginx 与 RPC</h1><ul>
<li>Ngnix 是互联网企业使用最为广泛的代理服务器。</li>
<li>它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务</li>
<li>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互</li>
<li>也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。</li>
<li>你说的没错，不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</li>
<li>uWSGI 是著名的 Python 容器，使用它可以启动 uwsgi 协议的服务器对外提供服务。</li>
<li>uwsgi 通讯协议在 Python 语言体系里使用非常普遍，如果一个企业内部使用 Python 语言栈搭建 Web 服务，那么他们在生产环境部署 Python 应用的时候不是在使用 HTTP 协议就是在使用 uwsgi 协议来和 Nginx 之间建立通讯。</li>
<li>Fastcgi 协议在 PHP 语言体系里非常常见，Nginx 和 PHP-fpm 进程之间一般较常使用 Fastcgi 协议进行通讯。</li>
</ul>
<h1 id="Hadoop-与-RPC"><a href="#Hadoop-与-RPC" class="headerlink" title="Hadoop 与 RPC"></a>Hadoop 与 RPC</h1><ul>
<li>在大数据技术领域，RPC 也占据了非常重要的地位</li>
<li>大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在</li>
<li>大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。</li>
<li>比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</li>
</ul>
<h1 id="TensorFlow-与-RPC"><a href="#TensorFlow-与-RPC" class="headerlink" title="TensorFlow 与 RPC"></a>TensorFlow 与 RPC</h1><ul>
<li>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯</li>
<li>Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</li>
</ul>
<h1 id="Http-与-RPC"><a href="#Http-与-RPC" class="headerlink" title="Http 与 RPC"></a>Http 与 RPC</h1><ul>
<li>HTTP 调用其实也是一种特殊的 RPC</li>
<li>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。</li>
<li>HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</li>
<li>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了</li>
<li>所以在后文我们不再明确强调 RPC 和 HTTP 请求调用之间的细微区别了，直接统一称之为 RPC。</li>
</ul>
<h1 id="HTTP-VS-RPC-（普通话-VS-方言）"><a href="#HTTP-VS-RPC-（普通话-VS-方言）" class="headerlink" title="HTTP VS RPC （普通话 VS 方言）"></a>HTTP VS RPC （普通话 VS 方言）</h1><ul>
<li>HTTP 与 RPC 的关系就好比普通话与方言的关系</li>
<li>要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本</li>
<li>但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源</li>
<li>整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。</li>
<li>如果再深入一点说，普通话本质上也是一种方言，只不过它是官方的方言，使用最为广泛的方言，相比而言其它方言都是小语种，小语种之中也会有几个使用比较广泛比较特色的方言占比也会比较大。</li>
<li>这就好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</li>
</ul>
<h1 id="换个角度看世界"><a href="#换个角度看世界" class="headerlink" title="换个角度看世界"></a>换个角度看世界</h1><ul>
<li>分布式子系统交互方案，除了 RPC 技术之外还有数据库、消息队列和缓存。但其实这三者本质上是 RPC 技术的一个应用组合。</li>
<li>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。</li>
<li>如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL</li>
<li>在互联网企业里一般都会使用这种主从读写分离的数据库</li>
<li>一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来</li>
<li>这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</li>
</ul>
]]></content>
      <categories>
        <category>rpc</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/publishes/726ed62e2d44.html</url>
    <content><![CDATA[<h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><ul>
<li>Nginx应该是现在最火的web和反向代理服务器，没有之一</li>
<li>它是一款诞生于俄罗斯的高性能web服务器，尤其在高并发情况下，相较Apache，有优异的表现。</li>
</ul>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><ul>
<li>Nginx擅长处理静态文件，是非常好的图片、文件服务器</li>
<li>把所有的静态资源的放到nginx上，可以使应用动静分离，性能更好</li>
</ul>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><ul>
<li>Nginx通过反向代理可以实现服务的负载均衡，避免了服务器单节点故障，把请求按照一定的策略转发到不同的服务器上，达到负载的效果。</li>
</ul>
<h6 id="常用的负载均衡策略有"><a href="#常用的负载均衡策略有" class="headerlink" title="常用的负载均衡策略有"></a>常用的负载均衡策略有</h6><ul>
<li>轮询 <ul>
<li>将请求按顺序轮流地分配到后端服务器上</li>
<li>它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li>
</ul>
</li>
<li>加权轮询<ul>
<li>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同</li>
<li>给配置高、负载低的机器配置更高的权重，让其处理更多的请；</li>
<li>而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li>
</ul>
</li>
<li>ip_hash（源地址哈希法）<ul>
<li>根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问服务器的序号。</li>
<li>采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li>
</ul>
</li>
<li>随机<ul>
<li>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。</li>
</ul>
</li>
<li>least_conn（最小连接数法）<ul>
<li>由于后端服务器的配置不尽相同，对于请求的处理有快有慢</li>
<li>最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li>
</ul>
</li>
</ul>
<h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><ul>
<li>Nginx的限流模块，是基于漏桶算法实现的，在高并发的场景下非常实用，如下图：</li>
</ul>
<h6 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h6><ul>
<li>limit_req_zone定义在http块中，$binary_remote_addr 表示保存客户端IP地址的二进制形式。</li>
<li>Zone定义IP状态及URL访问频率的共享内存区域。<br>-zone&#x3D;keyword标识区域的名字，以及冒号后面跟区域大小。16000个IP地址的状态信息约1MB，所以示例中区域可以存储160000个IP地址。</li>
<li>Rate定义最大请求速率。示例中速率不能超过每秒100个请求。</li>
</ul>
<h6 id="设置限流"><a href="#设置限流" class="headerlink" title="设置限流"></a>设置限流</h6><ul>
<li>burst排队大小，nodelay不限制单个请求间的时间。</li>
</ul>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul>
<li>浏览器缓存，静态资源缓存用expire。</li>
<li>代理层缓存</li>
</ul>
<h5 id="黑白名单"><a href="#黑白名单" class="headerlink" title="黑白名单"></a>黑白名单</h5><ul>
<li>不限流白名单</li>
<li>黑名单</li>
</ul>
<h1 id="Nginx性能调优："><a href="#Nginx性能调优：" class="headerlink" title="Nginx性能调优："></a>Nginx性能调优：</h1><ul>
<li>增加同时打开⽂件数open files数量；</li>
<li>处理⼤量静态⽂件的磁盘I&#x2F;O时(此时worker进程是单线程的)，增加CPU核⼼数Worker Processes数量，提⾼计算能⼒；</li>
<li>如果⽹站流量很⾼，则可以提升worker进程连接数Worker Connections(默认1024)；</li>
<li>控制keep alive在10s-20s之间，减少连接的时间开销；</li>
<li>合理设置open file cache时间提⾼处理效率；</li>
<li>提⾼⽹路带宽；</li>
<li>开启压缩传输数据gzip，设置压缩级别gzip_comp_level为1-2，再⾼效果不明显并且浪费CPU了；</li>
<li>扩展机器数量。</li>
</ul>
<h1 id="Nginx-有哪些作用？"><a href="#Nginx-有哪些作用？" class="headerlink" title="Nginx 有哪些作用？"></a>Nginx 有哪些作用？</h1><ul>
<li>http 协议代理</li>
<li>搭建虚拟主机</li>
<li>服务的反向代理</li>
<li>在反向代理中配置集群的负载均衡</li>
</ul>
<h1 id="什么是正向代理？"><a href="#什么是正向代理？" class="headerlink" title="什么是正向代理？"></a>什么是正向代理？</h1><ul>
<li>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</li>
</ul>
<h1 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h1><ul>
<li>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li>
</ul>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC</title>
    <url>/publishes/235b69f65d9c.html</url>
    <content><![CDATA[<h1 id="什么是SpringMvc？"><a href="#什么是SpringMvc？" class="headerlink" title="什么是SpringMvc？"></a>什么是SpringMvc？</h1><ul>
<li>SpringMvc是spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。</li>
</ul>
<h1 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h1><ul>
<li>它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成. </li>
<li>不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的) </li>
<li>可以任意使用各种视图技术,而不仅仅局限于JSP </li>
<li>支持各种请求资源的映射策略 </li>
<li>它应是易于扩展的</li>
</ul>
<h1 id="SpringMVC工作原理？"><a href="#SpringMVC工作原理？" class="headerlink" title="SpringMVC工作原理？"></a>SpringMVC工作原理？</h1><h4 id="简要回答"><a href="#简要回答" class="headerlink" title="简要回答"></a>简要回答</h4><ul>
<li>客户端发送请求到DispatcherServlet </li>
<li>DispatcherServlet查询handlerMapping找到处理请求的Controller </li>
<li>Controller调用业务逻辑后，返回ModelAndView </li>
<li>DispatcherServlet查询ModelAndView，找到指定视图 </li>
<li>视图将结果返回到客户端</li>
</ul>
<h4 id="详细回答"><a href="#详细回答" class="headerlink" title="详细回答"></a>详细回答</h4><ul>
<li>用户发送请求至前端控制器DispatcherServlet。 </li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li>
<li>Controller执行完成返回ModelAndView。 </li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 </li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li>
<li>ViewReslover解析后返回具体View。 </li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>
<li>DispatcherServlet响应用户。</li>
</ul>
<h4 id="详细回答2"><a href="#详细回答2" class="headerlink" title="详细回答2"></a>详细回答2</h4><ul>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器</li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户</li>
</ul>
<h1 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h1><ul>
<li><p>在web.xml中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上可以解决post请求乱码问题</p>
</li>
<li><p>对于get请求中文参数出现乱码解决方法有两个：</p>
<ul>
<li><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外一种方法对参数进行重新编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>
</li>
</ul>
<h1 id="SpringMVC与Struts2的主要区别？"><a href="#SpringMVC与Struts2的主要区别？" class="headerlink" title="SpringMVC与Struts2的主要区别？"></a>SpringMVC与Struts2的主要区别？</h1><ul>
<li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。Jsp视图解析器默认使用jstl。</li>
<li>springmvc是基于方法开发，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
</ul>
<h1 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h1><ul>
<li>是单例模式</li>
<li>所以在多线程访问的时候有线程安全问题</li>
<li>不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</li>
</ul>
<h1 id="SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</h1><ul>
<li>一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。</li>
</ul>
<h1 id="RequestMapping注解用在类上面有什么作用？"><a href="#RequestMapping注解用在类上面有什么作用？" class="headerlink" title="@RequestMapping注解用在类上面有什么作用？"></a>@RequestMapping注解用在类上面有什么作用？</h1><ul>
<li>是一个用来处理请求地址映射的注解，可用于类或方法上</li>
<li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li>
</ul>
<h1 id="怎么样把某个请求映射到特定的方法上面？"><a href="#怎么样把某个请求映射到特定的方法上面？" class="headerlink" title="怎么样把某个请求映射到特定的方法上面？"></a>怎么样把某个请求映射到特定的方法上面？</h1><ul>
<li>直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径</li>
</ul>
<h1 id="如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？"><a href="#如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？" class="headerlink" title="如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？"></a>如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？</h1><ul>
<li>可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET</li>
</ul>
<h1 id="怎么样在方法里面得到Request-或者Session？"><a href="#怎么样在方法里面得到Request-或者Session？" class="headerlink" title="怎么样在方法里面得到Request,或者Session？"></a>怎么样在方法里面得到Request,或者Session？</h1><ul>
<li>直接在方法的形参中声明request,SpringMvc就自动把request对象传入</li>
</ul>
<h1 id="我想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#我想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="我想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>我想在拦截的方法里面得到从前台传入的参数,怎么得到？</h1><ul>
<li>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样</li>
</ul>
<h1 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h1><ul>
<li>直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</li>
</ul>
<h1 id="SpringMvc中函数的返回值是什么？"><a href="#SpringMvc中函数的返回值是什么？" class="headerlink" title="SpringMvc中函数的返回值是什么？"></a>SpringMvc中函数的返回值是什么？</h1><ul>
<li>返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。</li>
</ul>
<h1 id="SpringMVC怎么样设定重定向和转发的？"><a href="#SpringMVC怎么样设定重定向和转发的？" class="headerlink" title="SpringMVC怎么样设定重定向和转发的？"></a>SpringMVC怎么样设定重定向和转发的？</h1><ul>
<li>在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name&#x3D;method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:<a href="http://www.baidu.com/">http://www.baidu.com</a>“</li>
</ul>
<h1 id="SpringMvc用什么对象从后台向前台传递数据的？"><a href="#SpringMvc用什么对象从后台向前台传递数据的？" class="headerlink" title="SpringMvc用什么对象从后台向前台传递数据的？"></a>SpringMvc用什么对象从后台向前台传递数据的？</h1><ul>
<li>通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。</li>
</ul>
<h1 id="SpringMvc中有个类把视图和数据都合并的一起的-叫什么？"><a href="#SpringMvc中有个类把视图和数据都合并的一起的-叫什么？" class="headerlink" title="SpringMvc中有个类把视图和数据都合并的一起的,叫什么？"></a>SpringMvc中有个类把视图和数据都合并的一起的,叫什么？</h1><ul>
<li>叫ModelAndView。</li>
</ul>
<h1 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h1><ul>
<li>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key</li>
</ul>
<h1 id="SpringMvc怎么和AJAX相互调用的？"><a href="#SpringMvc怎么和AJAX相互调用的？" class="headerlink" title="SpringMvc怎么和AJAX相互调用的？"></a>SpringMvc怎么和AJAX相互调用的？</h1><ul>
<li>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。 </li>
<li>具体步骤如下 ：<ul>
<li>加入Jackson.jar </li>
<li>在配置文件中配置json的映射 </li>
<li>在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</li>
</ul>
</li>
</ul>
<h1 id="当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？"><a href="#当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？" class="headerlink" title="当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？"></a>当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</h1><ul>
<li>要加上@ResponseBody注解</li>
</ul>
<h1 id="SpringMvc里面拦截器是怎么写的"><a href="#SpringMvc里面拦截器是怎么写的" class="headerlink" title="SpringMvc里面拦截器是怎么写的"></a>SpringMvc里面拦截器是怎么写的</h1><ul>
<li>有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;    </span><br><span class="line">    &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;   </span><br><span class="line">    &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.et.action.MyHandlerInterceptor&quot;&gt;&lt;/bean&gt;    </span><br><span class="line">    &lt;!-- 只针对部分请求拦截 --&gt;    </span><br><span class="line">    &lt;mvc:interceptor&gt;       </span><br><span class="line">        &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;       </span><br><span class="line">        &lt;bean class=&quot;com.et.action.MyHandlerInterceptorAdapter&quot; /&gt;  </span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="讲下SpringMvc的执行流程"><a href="#讲下SpringMvc的执行流程" class="headerlink" title="讲下SpringMvc的执行流程"></a>讲下SpringMvc的执行流程</h1><ul>
<li>系统启动的时候根据配置文件创建spring的容器</li>
<li>首先是发送http请求到核心控制器disPatherServlet</li>
<li>spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类</li>
<li>在进业务类时进行数据封装，在封装前可能会涉及到类型转换</li>
<li>执行完业务类后使用ModelAndView进行视图转发</li>
<li>数据放在model中，用map传递数据进行页面显示</li>
</ul>
<h1 id="框架的优缺点SpringMVC-Struts2等…"><a href="#框架的优缺点SpringMVC-Struts2等…" class="headerlink" title="框架的优缺点SpringMVC,Struts2等…"></a>框架的优缺点SpringMVC,Struts2等…</h1><ul>
<li>Struts2是类级别拦截，参数为类中所有⽅法共有，⼀个Action对应⼀个request上下⽂，SpringMVC是⽅法级别拦截，参数为对应⽅法所有；</li>
<li>由于Struts2需要针对每个request进⾏封装，把request，session等servlet⽣命周期的变量封装成⼀个⼀个Map，供给每个Action使⽤，并保证线程安全，所以在原则上，是⽐较耗费内存的。</li>
<li>拦截器实现机制上，Struts2有以⾃⼰的interceptor机制，SpringMVC⽤的是独⽴的AOP⽅式，这样导致Struts2的配置⽂件量还是⽐SpringMVC⼤。</li>
<li>SpringMVC的⼊⼝是servlet，⽽Struts2是filter</li>
<li>SpringMVC集成了Ajax，使⽤⾮常⽅便，只需⼀个注解@ResponseBody就可以实现，然后直接返回响应⽂本即可，⽽Struts2拦截器集成了Ajax，在Action中处理时⼀般必须安装插件或者⾃⼰写代码集成进去，使⽤起来也相对不⽅便。</li>
<li>SpringMVC开发效率和性能⾼于Struts2。</li>
<li>SpringMVC配置少，零配置。</li>
</ul>
<h1 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h1><ul>
<li>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序</li>
<li>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</li>
</ul>
]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot</title>
    <url>/publishes/4d12791836df.html</url>
    <content><![CDATA[<h1 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h1><ul>
<li>多年来，随着新功能的增加，spring变得越来越复杂。</li>
<li>如果必须启动一个新的Spring项目，我们必须添加构建路径或添加Maven依赖关系，配置应用程序服务器，添加spring配置。</li>
<li>因此，开始一个新的spring项目需要很多努力，因为我们现在必须从头开始做所有事情。</li>
<li>Spring Boot是解决这个问题的方法。Spring Boot已经建立在现有spring框架之上。使用spring启动，我们避免了之前我们必须做的所有样板代码和配置。</li>
<li>因此，Spring Boot可以帮助我们以最少的工作量，更加健壮地使用现有的Spring功能。</li>
</ul>
<h1 id="Spring-Boot有哪些优点"><a href="#Spring-Boot有哪些优点" class="headerlink" title="Spring Boot有哪些优点"></a>Spring Boot有哪些优点</h1><ul>
<li>减少开发，测试时间和努力。</li>
<li>使用JavaConfig有助于避免使用XML。</li>
<li>避免大量的Maven导入和各种版本冲突。</li>
<li>提供意见发展方法。</li>
<li>通过提供默认值快速开始开发。</li>
<li>没有单独的Web服务器需要。这意味着你不再需要启动Tomcat，Glassfish或其他任何东西。</li>
<li>需要更少的配置 因为没有web.xml文件。只需添加用@ Configuration注释的类，然后添加用@Bean注释的方法，Spring将自动加载对象并像以前一样对其进行管理。您甚至可以将@Autowired添加到bean方法中，以使Spring自动装入需要的依赖关系中。</li>
<li>基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active &#x3D; {enviornment}。在加载主应用程序属性文件后，Spring将在（application{environment} .properties）中加载后续的应用程序属性文件。</li>
</ul>
<h1 id="什么是JavaConfig"><a href="#什么是JavaConfig" class="headerlink" title="什么是JavaConfig"></a>什么是JavaConfig</h1><ul>
<li>Spring JavaConfig提供了配置Spring IoC容器的纯Java方法</li>
<li>因此它有助于避免使用XML配置</li>
<li>使用JavaConfig的优点在于：<ul>
<li>面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。</li>
<li>减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。</li>
</ul>
</li>
<li>JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。</li>
<li>从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。</li>
<li>类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。</li>
</ul>
<h1 id="如何重新加载Spring-Boot上的更改，而无需重新启动服务器？"><a href="#如何重新加载Spring-Boot上的更改，而无需重新启动服务器？" class="headerlink" title="如何重新加载Spring Boot上的更改，而无需重新启动服务器？"></a>如何重新加载Spring Boot上的更改，而无需重新启动服务器？</h1><ul>
<li>这可以使用DEV工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat将重新启动。</li>
<li>Spring Boot有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力</li>
<li>Java开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。</li>
<li>开发人员可以重新加载Spring Boot上的更改，而无需重新启动服务器</li>
<li>这将消除每次手动部署更改的需要</li>
<li>Spring Boot在发布它的第一个版本时没有这个功能。</li>
<li>这是开发人员最需要的功能</li>
<li>DevTools模块完全满足开发人员的需求</li>
<li>该模块将在生产环境中被禁用</li>
<li>它还提供H2数据库控制台以更好地测试应用程序。</li>
</ul>
<h1 id="Spring-Boot中的监视器是什么？"><a href="#Spring-Boot中的监视器是什么？" class="headerlink" title="Spring Boot中的监视器是什么？"></a>Spring Boot中的监视器是什么？</h1><ul>
<li>Spring boot actuator是spring启动框架中的重要功能之一</li>
<li>Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。</li>
<li>有几个指标必须在生产环境中进行检查和监控</li>
<li>即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息</li>
<li>监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</li>
</ul>
<h1 id="如何在Spring-Boot中禁用Actuator端点安全性？"><a href="#如何在Spring-Boot中禁用Actuator端点安全性？" class="headerlink" title="如何在Spring Boot中禁用Actuator端点安全性？"></a>如何在Spring Boot中禁用Actuator端点安全性？</h1><ul>
<li>默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。</li>
<li>安全性是使用标准的HttpServletRequest.isUserInRole方法实施的</li>
<li>我们可以使用management.security.enabled &#x3D; false 来禁用安全性</li>
<li>只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</li>
</ul>
<h1 id="如何在自定义端口上运行Spring-Boot应用程序？"><a href="#如何在自定义端口上运行Spring-Boot应用程序？" class="headerlink" title="如何在自定义端口上运行Spring Boot应用程序？"></a>如何在自定义端口上运行Spring Boot应用程序？</h1><ul>
<li>为了在自定义端口上运行Spring Boot应用程序，您可以在application.properties中指定端口。</li>
<li>server.port &#x3D; 8090</li>
</ul>
<h1 id="什么是YAML？"><a href="#什么是YAML？" class="headerlink" title="什么是YAML？"></a>什么是YAML？</h1><ul>
<li>YAML是一种人类可读的数据序列化语言</li>
<li>它通常用于配置文件。</li>
<li>与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML文件就更加结构化，而且更少混淆</li>
<li>可以看出YAML具有分层配置数据。</li>
</ul>
<h1 id="如何实现Spring-Boot应用程序的安全性？"><a href="#如何实现Spring-Boot应用程序的安全性？" class="headerlink" title="如何实现Spring Boot应用程序的安全性？"></a>如何实现Spring Boot应用程序的安全性？</h1><ul>
<li>为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置</li>
<li>它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。</li>
</ul>
<h1 id="如何集成Spring-Boot和ActiveMQ？"><a href="#如何集成Spring-Boot和ActiveMQ？" class="headerlink" title="如何集成Spring Boot和ActiveMQ？"></a>如何集成Spring Boot和ActiveMQ？</h1><ul>
<li>对于集成Spring Boot和ActiveMQ，我们使用spring-boot-starter-activemq依赖关系</li>
<li>它只需要很少的配置，并且不需要样板代码</li>
</ul>
<h1 id="如何使用Spring-Boot实现分页和排序？"><a href="#如何使用Spring-Boot实现分页和排序？" class="headerlink" title="如何使用Spring Boot实现分页和排序？"></a>如何使用Spring Boot实现分页和排序？</h1><ul>
<li>使用Spring Boot实现分页非常简单</li>
<li>使用Spring Data-JPA可以实现将可分页的org.springframework.data.domain.Pageable传递给存储库方法</li>
</ul>
<h1 id="什么是Swagger？你用Spring-Boot实现了它吗？"><a href="#什么是Swagger？你用Spring-Boot实现了它吗？" class="headerlink" title="什么是Swagger？你用Spring Boot实现了它吗？"></a>什么是Swagger？你用Spring Boot实现了它吗？</h1><ul>
<li>Swagger广泛用于可视化API</li>
<li>使用Swagger UI为前端开发人员提供在线沙箱</li>
<li>Swagger是用于生成RESTful Web服务的可视化表示的工具，规范和完整框架实现</li>
<li>它使文档能够以与服务器相同的速度更新</li>
<li>当通过Swagger正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互</li>
<li>因此，Swagger消除了调用服务时的猜测。</li>
</ul>
<h1 id="什么是Spring-Profiles？"><a href="#什么是Spring-Profiles？" class="headerlink" title="什么是Spring Profiles？"></a>什么是Spring Profiles？</h1><ul>
<li>Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean</li>
<li>因此，当应用程序在开发中运行时，只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载</li>
<li>假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档</li>
<li>这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单。</li>
</ul>
<h1 id="什么是Spring-Batch？"><a href="#什么是Spring-Batch？" class="headerlink" title="什么是Spring Batch？"></a>什么是Spring Batch？</h1><ul>
<li>Spring Boot Batch提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理</li>
<li>它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业</li>
<li>简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息</li>
</ul>
<h1 id="什么是FreeMarker模板？"><a href="#什么是FreeMarker模板？" class="headerlink" title="什么是FreeMarker模板？"></a>什么是FreeMarker模板？</h1><ul>
<li>FreeMarker是一个基于Java的模板引擎，最初专注于使用MVC软件架构进行动态网页生成</li>
<li>使用Freemarker的主要优点是表示层和业务层的完全分离</li>
<li>程序员可以处理应用程序代码，而设计人员可以处理html页面设计</li>
<li>最后使用freemarker可以将这些结合起来，给出最终的输出页面。</li>
</ul>
<h1 id="如何使用Spring-Boot实现异常处理？"><a href="#如何使用Spring-Boot实现异常处理？" class="headerlink" title="如何使用Spring Boot实现异常处理？"></a>如何使用Spring Boot实现异常处理？</h1><ul>
<li>Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法</li>
<li>我们通过实现一个ControlerAdvice类，来处理控制器类抛出的所有异常。</li>
</ul>
<h1 id="您使用了哪些starter-maven依赖项？"><a href="#您使用了哪些starter-maven依赖项？" class="headerlink" title="您使用了哪些starter maven依赖项？"></a>您使用了哪些starter maven依赖项？</h1><ul>
<li>使用了下面的一些依赖项<ul>
<li>spring-boot-starter-activemq</li>
<li>spring-boot-starter-security</li>
<li>spring-boot-starter-web</li>
</ul>
</li>
<li>这有助于增加更少的依赖关系，并减少版本的冲突。</li>
</ul>
<h1 id="如何监视所有Spring-Boot微服务"><a href="#如何监视所有Spring-Boot微服务" class="headerlink" title="如何监视所有Spring Boot微服务"></a>如何监视所有Spring Boot微服务</h1><ul>
<li>Spring Boot提供监视器端点以监控各个微服务的度量</li>
<li>这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助</li>
<li>但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况</li>
<li>想象一下涉及50个应用程序的微服务，管理员将不得不击中所有50个应用程序的执行终端。</li>
</ul>
<h1 id="SpringBoot项⽬启动时执⾏特定的⽅法"><a href="#SpringBoot项⽬启动时执⾏特定的⽅法" class="headerlink" title="SpringBoot项⽬启动时执⾏特定的⽅法"></a>SpringBoot项⽬启动时执⾏特定的⽅法</h1><ul>
<li>我们可以通过实现ApplicationRunner和CommandLineRunner，来实现，他们都是在SpringApplication 执⾏之后开始执⾏的</li>
</ul>
<h1 id="SpringBoot的启动过程"><a href="#SpringBoot的启动过程" class="headerlink" title="SpringBoot的启动过程"></a>SpringBoot的启动过程</h1><ul>
<li>通过 SpringFactoriesLoader加载 META-INF&#x2F;spring.factories⽂件，获取并创建 SpringApplicationRunListener对象</li>
<li>然后由 SpringApplicationRunListener来发出 starting 消息</li>
<li>创建参数，并配置当前 SpringBoot 应⽤将要使⽤的 Environment</li>
<li>完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息</li>
<li>创建 ApplicationContext</li>
<li>初始化 ApplicationContext，并设置 Environment，加载相关配置等</li>
<li>由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应⽤使⽤的 ApplicationContext已准备OK</li>
<li>将各种 beans 装载⼊ ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知SpringBoot 应⽤使⽤的 ApplicationContext已装填OK</li>
<li>refresh ApplicationContext，完成IoC容器可⽤的最后⼀步</li>
<li>由 SpringApplicationRunListener来发出 started 消息</li>
<li>完成最终的程序的启动</li>
<li>由 SpringApplicationRunListener来发出 running 消息，告知程序已运⾏起来了</li>
</ul>
<h1 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h1><ul>
<li>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。</li>
<li>为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</li>
</ul>
<h1 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h1><ul>
<li>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法</li>
<li>我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/publishes/5788a7088796.html</url>
    <content><![CDATA[<h1 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h1><ul>
<li>如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了。</li>
<li>我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除 + 定期删除两种策略对过期键删除。</li>
<li>如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。</li>
<li>这就是缓存雪崩：Redis挂掉了，请求全部走数据库。</li>
<li>缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！</li>
</ul>
<h1 id="如何解决缓存雪崩"><a href="#如何解决缓存雪崩" class="headerlink" title="如何解决缓存雪崩"></a>如何解决缓存雪崩</h1><ul>
<li>使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间</li>
<li>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</li>
<li>大多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队，加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。</li>
<li>还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存</li>
<li>对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：<ul>
<li>事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。</li>
<li>事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li>
<li>事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
</li>
</ul>
<h1 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h1><ul>
<li>缓存穿透是指查询一个一定不存在的数据</li>
<li>由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存</li>
<li>这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。</li>
<li>这就是缓存穿透：请求的数据在缓存大量不命中，导致请求走数据库。</li>
<li>缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！</li>
</ul>
<h1 id="如何解决缓存穿透"><a href="#如何解决缓存穿透" class="headerlink" title="如何解决缓存穿透"></a>如何解决缓存穿透</h1><ul>
<li>解决缓存穿透也有两种方案：<ul>
<li>由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！</li>
<li>当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间</li>
</ul>
</li>
</ul>
<h1 id="缓存与数据库双写一致"><a href="#缓存与数据库双写一致" class="headerlink" title="缓存与数据库双写一致"></a>缓存与数据库双写一致</h1><ul>
<li>对于读操作，流程是这样的<ul>
<li>如果我们的数据在缓存里边有，那么就直接取缓存的。</li>
<li>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。最后将数据返回给请求</li>
</ul>
</li>
</ul>
<h1 id="什么是缓存与数据库双写一致问题"><a href="#什么是缓存与数据库双写一致问题" class="headerlink" title="什么是缓存与数据库双写一致问题"></a>什么是缓存与数据库双写一致问题</h1><ul>
<li>如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要更新时候呢？各种情况很可能就造成数据库和缓存的数据不一致了。</li>
<li>这里不一致指的是：数据库的数据跟缓存的数据不一致</li>
<li>从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。</li>
<li>因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</li>
</ul>
<h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><ul>
<li>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统</li>
<li>这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li>
<li>解决思路：<ul>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ul>
</li>
</ul>
<h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><ul>
<li>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<ul>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ul>
</li>
<li>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂</li>
</ul>
<h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><ul>
<li>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。</li>
<li>系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</li>
<li>降级的最终目的是保证核心服务可用，即使是有损的</li>
<li>而且有些服务是无法降级的（如加入购物车、结算）。</li>
<li>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅，从而梳理出哪些必须誓死保护，哪些可降级</li>
<li>比如可以参考日志级别设置预案：<ul>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ul>
</li>
</ul>
<h1 id="为什么使用-Redis"><a href="#为什么使用-Redis" class="headerlink" title="为什么使用 Redis"></a>为什么使用 Redis</h1><ul>
<li>主要是从两个角度去考虑：性能和并发。</li>
<li>当然，Redis 还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件，如 ZooKpeer 等代替，并不是非要使用 Redis</li>
<li>因此，这个问题主要从性能和并发两个角度去答</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，就特别适合将运行结果放入缓存</li>
<li>这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</li>
</ul>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ul>
<li>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。</li>
<li>这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库。</li>
</ul>
<h4 id="使用-Redis-有什么缺点"><a href="#使用-Redis-有什么缺点" class="headerlink" title="使用 Redis 有什么缺点"></a>使用 Redis 有什么缺点</h4><ul>
<li>回答主要是四个问题：<ul>
<li>缓存和数据库双写一致性问题</li>
<li>缓存雪崩问题</li>
<li>缓存击穿问题</li>
<li>缓存的并发竞争问题</li>
</ul>
</li>
</ul>
<h4 id="单线程的-Redis-为什么这么快"><a href="#单线程的-Redis-为什么这么快" class="headerlink" title="单线程的 Redis 为什么这么快"></a>单线程的 Redis 为什么这么快</h4><ul>
<li>回答主要是以下三点：<ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞 I&#x2F;O 多路复用机制</li>
</ul>
</li>
</ul>
<h4 id="I-O-多路复用机制"><a href="#I-O-多路复用机制" class="headerlink" title="I&#x2F;O 多路复用机制"></a>I&#x2F;O 多路复用机制</h4><ul>
<li>简单来说，就是我们的 redis-client 在操作的时候，会产生具有不同事件类型的 Socket。</li>
<li>在服务端，有一段 I&#x2F;O 多路复用程序，将其置入队列之中</li>
<li>然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</li>
<li>需要说明的是，这个 I&#x2F;O 多路复用机制，Redis 还提供了 select、epoll、evport、kqueue 等多路复用函数库，大家可以自行去了解。</li>
</ul>
<h1 id="Redis-的数据类型，以及每种数据类型的使用场景"><a href="#Redis-的数据类型，以及每种数据类型的使用场景" class="headerlink" title="Redis 的数据类型，以及每种数据类型的使用场景"></a>Redis 的数据类型，以及每种数据类型的使用场景</h1><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li>常规的 set&#x2F;get 操作，Value 可以是 String 也可以是数字</li>
<li>一般做一些复杂的计数功能的缓存</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><ul>
<li>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。</li>
<li>我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li>使用 List 的数据结构，可以做简单的消息队列的功能</li>
<li>可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li>因为 Set 堆放的是一堆不重复值的集合，所以可以做全局去重的功能</li>
<li>为什么不用 JVM 自带的 Set 进行去重？因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</li>
<li>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</li>
</ul>
<h4 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h4><ul>
<li>Sorted Set多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。</li>
<li>可以做排行榜应用，取 TOP N 操作</li>
<li>Sorted Set 可以用来做延时任务</li>
<li>最后一个应用就是可以做范围查找。</li>
</ul>
<h1 id="Redis-的过期策略以及内存淘汰机制"><a href="#Redis-的过期策略以及内存淘汰机制" class="headerlink" title="Redis 的过期策略以及内存淘汰机制"></a>Redis 的过期策略以及内存淘汰机制</h1><ul>
<li>Redis 采用的是定期删除+惰性删除策略。</li>
</ul>
<h4 id="为什么不用定时删除策略"><a href="#为什么不用定时删除策略" class="headerlink" title="为什么不用定时删除策略"></a>为什么不用定时删除策略</h4><ul>
<li>定时删除，用一个定时器来负责监视 Key，过期则自动删除</li>
<li>虽然内存及时释放，但是十分消耗 CPU 资源。</li>
<li>在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。</li>
</ul>
<h4 id="定期删除-惰性删除是如何工作"><a href="#定期删除-惰性删除是如何工作" class="headerlink" title="定期删除+惰性删除是如何工作"></a>定期删除+惰性删除是如何工作</h4><ul>
<li>定期删除，Redis 默认每隔 100ms 检查，是否有过期的 Key，有过期 Key 则删除。</li>
<li>需要说明的是，Redis 不是每隔 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。</li>
<li>如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。</li>
<li>也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。</li>
<li>采用定期删除+惰性删除就没其他问题了么?不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。</li>
<li>在 redis.conf 中有一行配置：maxmemory-policy volatile-lru</li>
<li>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)：<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。</li>
</ul>
</li>
<li>PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。</li>
</ul>
<h1 id="Redis-和数据库双写一致性问题"><a href="#Redis-和数据库双写一致性问题" class="headerlink" title="Redis 和数据库双写一致性问题"></a>Redis 和数据库双写一致性问题</h1><ul>
<li>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性</li>
<li>数据库和缓存双写，就必然会存在不一致的问题。</li>
<li>首先，采取正确更新策略，先更新数据库，再删缓存</li>
<li>其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li>
</ul>
<h1 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h1><h4 id="如果对这个-Key-操作，不要求顺序"><a href="#如果对这个-Key-操作，不要求顺序" class="headerlink" title="如果对这个 Key 操作，不要求顺序"></a>如果对这个 Key 操作，不要求顺序</h4><ul>
<li>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。</li>
</ul>
<h4 id="如果对这个-Key-操作，要求顺序"><a href="#如果对这个-Key-操作，要求顺序" class="headerlink" title="如果对这个 Key 操作，要求顺序"></a>如果对这个 Key 操作，要求顺序</h4><ul>
<li>假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。</li>
<li>期望按照 key1 的 value 值按照 valueA &gt; valueB &gt; valueC 的顺序变化</li>
<li>这种时候我们在数据写入数据库的时候，需要保存一个时间戳。</li>
<li>假设时间戳如下：<ul>
<li>系统A key 1 {valueA 3:00}</li>
<li>系统B key 1 {valueB 3:05}</li>
<li>系统C key 1 {valueC 3:10}</li>
</ul>
</li>
<li>那么，假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。</li>
<li>其他方法，比如利用队列，将 set 方法变成串行访问也可以。总之，灵活变通。</li>
</ul>
<h1 id="分布式缓存，⼀致性hash"><a href="#分布式缓存，⼀致性hash" class="headerlink" title="分布式缓存，⼀致性hash"></a>分布式缓存，⼀致性hash</h1><ul>
<li>⼀致性hash算法：⼀致性hash算法是对我们要存储数据的服务器进⾏hash计算，进⽽确认每个key的存储位置</li>
<li>这⾥提到的⼀致性hash算法ketama的做法是：选择具体的机器节点不在只依赖需要缓存数据的key的hash本身了，⽽是机器节点本身也进⾏了hash运<br>算。</li>
<li>⼀致性hash算法是分布式系统中常⽤算法，设计⽬的是为了解决因特⽹中的热点(hot spot)问题</li>
<li>解决了P2P环境最为关键问题—如何在动态⽹络拓扑中分布存储和路由；</li>
<li>⼀致性hash算法引⼊虚拟节点机制，解决服务节点少时数据倾斜问题(即对每⼀个服务节点计算多个哈希，每个计算结果位置都放置⼀个此服务节点，称为虚拟节点。)；</li>
<li>具体做法：如果有⼀个写⼊缓存的请求，其中Key值为K，计算器hash值Hash(K)， Hash(K) 对应于图 – 1环中的某⼀个点，如果该点对应没有映射到具体的某⼀个机器节点，那么顺时针查找，直到第⼀次找到有映射机器的节点，该节点就是确定的⽬标节点，如果超过了2^32仍然找不到节点，则命中第⼀个机器节点</li>
<li>⽐如 Hash(K) 的值介于A~B之间，那么命中的机器节点应该是B节点（如上图 ）。</li>
<li>数据保存流程：<ul>
<li>⾸先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。</li>
<li>然后采⽤同样的⽅法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第⼀个服务器上。如果超过232仍然找不到服务器，就会保存到第⼀台memcached服务器上。</li>
</ul>
</li>
</ul>
<h1 id="如何解决缓存单机热点问题"><a href="#如何解决缓存单机热点问题" class="headerlink" title="如何解决缓存单机热点问题"></a>如何解决缓存单机热点问题</h1><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>缓存服务器⾃身有限流保持<ul>
<li>缓存服务器数量 * 单机能够承受的qps &gt; ⽤户最⼤的QPS 就会触发限流保护</li>
<li>针对这个原因：可以做横向扩容。加机器即可</li>
</ul>
</li>
<li>⽤户访问过来cache服务器集中打到⼀台上⾯了<ul>
<li>⼤流量并没有按预期的那样分摊到不同的cache机器上导致出现单机热点。(热点数据)</li>
<li>针对这个原因：只要计算cache-hash算法不出问题，那基本上可以做到缓存的随机分布均匀的</li>
</ul>
</li>
<li>缓存⾥⾯的value过⼤<ul>
<li>导致虽然QPS不⾼，但⽹络流量（qps * 单个value的⼤⼩）还是过⼤，触发了cache机器单台机器的⽹络流量限流；</li>
<li>针对这个原因：需要把⼤value进⾏精简，部分可以放在本机内存⽽不需要⾛远程获取这种⽅式的。</li>
</ul>
</li>
</ul>
<h4 id="解决⽅法"><a href="#解决⽅法" class="headerlink" title="解决⽅法"></a>解决⽅法</h4><ul>
<li>针对cache中元素key的访问监控</li>
<li>⼀旦发现cache有qps限流或⽹络⼤⼩限流时，能够通过监控看到到底是哪个key并发访问量过⼤导致，或者哪些key返回的value⼤⼩较⼤</li>
<li>再结合cache散列算法，通过⼀定的规则动态修改key值去平摊到各个cache机器上去。</li>
</ul>
<h1 id="memcache与redis的区别"><a href="#memcache与redis的区别" class="headerlink" title="memcache与redis的区别"></a>memcache与redis的区别</h1><ul>
<li>Redis中，并不是所有的数据都⼀直存储在内存中的，这是和Memcached相⽐⼀个最⼤的区别。</li>
<li>Memcache仅仅⽀持简单的k&#x2F;v类型的数据，Redis同时还提供String, list，set，hash等数据结构的存储。</li>
<li>Redis⽀持数据的备份，即master-slave模式的数据备份。</li>
<li>Redis⽀持数据的持久化，可以将内存中的数据保持在磁盘中（rdb定时快照和aof实时记录操作命令的⽇志备<br>份），重启的时候可以再次加载进⾏使⽤。Redis在很多⽅⾯具备数据库的特征，或者说就是⼀个数据库系统，⽽<br>Memcached只是简单的K&#x2F;V缓存</li>
<li>Redis可以做⼀些聚合、排序操作。</li>
<li>memcache使⽤cas乐观锁做⼀致性：拿版本号，操作，对⽐版本号，如果⼀致就操作，不⼀致就放弃任何操作；</li>
<li>⼤数据memcached性能更⾼。由于Redis只使⽤单核，⽽Memcached可以使⽤多核，所以平均每⼀个核上<br>Redis在存储⼩数据时⽐Memcached性能更⾼。⽽在100k以上的数据中，Memcached性能要⾼于Redis 。</li>
</ul>
<h1 id="redis-本身有持久化，为什么还要写进-mysql-呢？"><a href="#redis-本身有持久化，为什么还要写进-mysql-呢？" class="headerlink" title="redis 本身有持久化，为什么还要写进 mysql 呢？"></a>redis 本身有持久化，为什么还要写进 mysql 呢？</h1><ul>
<li>RDB：快照形式是直接把内存中的数据保存到⼀个 dump ⽂件中，定时保存，保存策略。</li>
<li>AOF：把所有的对Redis的服务器进⾏修改的命令都存到⼀个⽂件⾥，命令的集合。</li>
<li>RDB会丢数据，AOF性能不⾏</li>
<li>有改动先插⼊数据库，再插缓存，⽐较靠谱但性能⼀般；</li>
<li>有改动先插缓存，批量更新到数据库，靠谱度略差，但性能好。</li>
</ul>
<h1 id="redis的数据结构和各种应⽤场景？"><a href="#redis的数据结构和各种应⽤场景？" class="headerlink" title="redis的数据结构和各种应⽤场景？"></a>redis的数据结构和各种应⽤场景？</h1><ul>
<li>更多的数据结构；</li>
<li>可持久化；</li>
<li>计数器；</li>
<li>发布-订阅功能；</li>
<li>事务功能；</li>
<li>过期回调功能；</li>
<li>队列功能；</li>
<li>排序、聚合查询功能。</li>
</ul>
<h1 id="redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高"><a href="#redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高" class="headerlink" title="redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高"></a>redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高</h1><ul>
<li>区别：<ul>
<li>mc可缓存图片和视频。rd支持除k&#x2F;v更多的数据结构;</li>
<li>rd可以使用虚拟内存，rd可持久化和aof灾难恢复，rd通过主从支持数据备份;</li>
<li>rd可以做消息队列。</li>
</ul>
</li>
<li>原因：mc多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。</li>
</ul>
<h1 id="redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？"><a href="#redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？" class="headerlink" title="redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？"></a>redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？</h1><ul>
<li>主从复制实现<ul>
<li>主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数据恢复到内存中</li>
<li>之后再每次增加新数据的时候，主节点以类似于mysql的二进制日志方式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放。</li>
</ul>
</li>
<li>分片方式：<ul>
<li>客户端分片</li>
<li>基于代理的分片<ul>
<li>Twemproxy</li>
<li>codis</li>
</ul>
</li>
<li>路由查询分片</li>
</ul>
</li>
<li>Redis-cluster（本身提供了自动将数据分散到Redis Cluster不同节点的能力，整个数据集合的某个数据子集存储在哪个节点对于用户来说是透明的）</li>
<li>redis-cluster分片原理<ul>
<li>Cluster中有一个16384长度的槽(虚拟槽)，编号分别为0-16383</li>
<li>每个Master节点都会负责一部分的槽，当有某个key被映射到某个Master负责的槽，那么这个Master负责为这个key提供服务</li>
<li>至于哪个Master节点负责哪个槽，可以由用户指定，也可以在初始化的时候自动生成，只有Master才拥有槽的所有权</li>
<li>Master节点维护着一个16384&#x2F;8字节的位序列，Master节点用bit来标识对于某个槽自己是否拥有</li>
<li>比如对于编号为1的槽，Master只要判断序列的第二位（索引从0开始）是不是为1即可</li>
<li>这种结构很容易添加或者删除节点</li>
<li>比如如果我想新添加个节点D, 我需要从节点A、B、 C中得部分槽到D上。</li>
</ul>
</li>
</ul>
<h1 id="使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？"><a href="#使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？" class="headerlink" title="使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？"></a>使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？</h1><ul>
<li>redis:<ul>
<li>线程A setnx(上锁的对象,超时时的时间戳t1)，如果返回true，获得锁。</li>
<li>线程B 用get获取t1,与当前时间戳比较,判断是是否超时,没超时false,若超时执行第3步;</li>
<li>计算新的超时时间t2,使用getset命令返回t3(该值可能其他线程已经修改过),如果t1&#x3D;&#x3D;t3，获得锁，如果t1!&#x3D;t3说明锁被其他线程获取了。</li>
<li>获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）。</li>
</ul>
</li>
<li>zk:<ul>
<li>客户端对某个方法加锁时，在zk上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点node1;</li>
<li>客户端获取该路径下所有已经创建的子节点，如果发现自己创建的node1的序号是最小的，就认为这个客户端获得了锁。</li>
<li>如果发现node1不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。</li>
<li>获取锁后，处理完逻辑，删除自己创建的node1即可。</li>
</ul>
</li>
<li>区别:zk性能差一些，开销大，实现简单。</li>
</ul>
<h1 id="知道redis的持久化吗？底层如何实现的？有什么优点缺点？"><a href="#知道redis的持久化吗？底层如何实现的？有什么优点缺点？" class="headerlink" title="知道redis的持久化吗？底层如何实现的？有什么优点缺点？"></a>知道redis的持久化吗？底层如何实现的？有什么优点缺点？</h1><ul>
<li>RDB(Redis DataBase:在不同的时间点将redis的数据生成的快照同步到磁盘等介质上)<ul>
<li>内存到硬盘的快照，定期更新</li>
<li>缺点：耗时，耗性能(fork+io操作)，易丢失数据。</li>
</ul>
</li>
<li>AOF(Append Only File：将redis所执行过的所有指令都记录下来，在下次redis重启时，只需要执行指令就可以了)<ul>
<li>写日志</li>
<li>缺点：体积大，恢复速度慢。</li>
</ul>
</li>
<li>bgsave做镜像全量持久化，aof做增量持久化</li>
<li>因为bgsave会消耗比较长的时间，不够实时，在停机的时候会导致大量的数据丢失，需要aof来配合</li>
<li>在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复</li>
<li>Redis会定期做aof重写，压缩aof文件日志大小</li>
<li>Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性</li>
<li>bgsave的原理，fork和cow, </li>
<li>fork是指redis通过创建子进程来进行bgsave操作</li>
<li>cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li>
</ul>
<h1 id="redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？"><a href="#redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？" class="headerlink" title="redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？"></a>redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？</h1><ul>
<li>过期策略:<ul>
<li>定时过期(一key一定时器)</li>
<li>惰性过期：只有使用key时才判断key是否已过期，过期则清除</li>
<li>定期过期：前两者折中。</li>
</ul>
</li>
<li>LRU:new LinkedHashMap&lt;K, V&gt;(capacity, DEFAULT_LOAD_FACTORY, true);&#x2F;&#x2F;第三个参数置为true，代表linkedlist按访问顺序排序，可作为LRU缓存；设为false代表按插入顺序排序，可作为FIFO缓存</li>
<li>LRU算法实现<ul>
<li>通过双向链表来实现，新数据插入到链表头部</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
</li>
<li>LinkedHashMap：HashMap和双向链表合二为一即是LinkedHashMap。HashMap是无序的，LinkedHashMap通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插入顺序（默认），也可以是访问顺序。</li>
</ul>
<h1 id="在选择缓存时，什么时候选择redis，什么时候选择memcached"><a href="#在选择缓存时，什么时候选择redis，什么时候选择memcached" class="headerlink" title="在选择缓存时，什么时候选择redis，什么时候选择memcached"></a>在选择缓存时，什么时候选择redis，什么时候选择memcached</h1><h4 id="选择redis的情况"><a href="#选择redis的情况" class="headerlink" title="选择redis的情况"></a>选择redis的情况</h4><ul>
<li>复杂数据结构，value的数据是哈希，列表，集合，有序集合等这种情况下，会选择redis, 因为memcache无法满足这些数据结构，最典型的的使用场景是，用户订单列表，用户消息，帖子评论等。</li>
<li>需要进行数据的持久化功能，但是注意，不要把redis当成数据库使用，如果redis挂了，内存能够快速恢复热数据，不会将压力瞬间压在数据库上，没有cache预热的过程。对于只读和数据一致性要求不高的场景可以采用持久化存储</li>
<li>高可用，redis支持集群，可以实现主动复制，读写分离，而对于memcache如果想要实现高可用，需要进行二次开发。</li>
<li>存储的内容比较大，memcache存储的value最大为1M。</li>
</ul>
<h4 id="选择memcache的场景"><a href="#选择memcache的场景" class="headerlink" title="选择memcache的场景"></a>选择memcache的场景</h4><ul>
<li>纯KV,数据量非常大的业务，使用memcache更合适，原因是，<ul>
<li>memcache的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时间，redis是临时申请空间，可能导致碎片化。</li>
<li>虚拟内存使用，memcache将所有的数据存储在物理内存里，redis有自己的vm机制，理论上能够存储比物理内存更多的数据，当数据超量时，引发swap,把冷数据刷新到磁盘上，从这点上，数据量大时，memcache更快</li>
<li>网络模型，memcache使用非阻塞的IO复用模型，redis也是使用非阻塞的IO复用模型，但是redis还提供了一些非KV存储之外的排序，聚合功能，复杂的CPU计算，会阻塞整个IO调度，从这点上由于redis提供的功能较多，memcache更快些</li>
<li>线程模型，memcache使用多线程，主线程监听，worker子线程接受请求，执行读写，这个过程可能存在锁冲突。redis使用的单线程，虽然无锁冲突，但是难以利用多核的特性提升吞吐量。</li>
</ul>
</li>
</ul>
<h1 id="Redis常见的性能问题和解决方案"><a href="#Redis常见的性能问题和解决方案" class="headerlink" title="Redis常见的性能问题和解决方案"></a>Redis常见的性能问题和解决方案</h1><ul>
<li>master最好不要做持久化工作，如RDB内存快照和AOF日志文件</li>
<li>如果数据比较重要，某个slave开启AOF备份，策略设置成每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，master和Slave最好在一个局域网内</li>
<li>尽量避免在压力大得主库上增加从库</li>
<li>主从复制不要采用网状结构，尽量是线性结构，<code>Master&lt;-- Slave1 &lt;--Slave2</code></li>
</ul>
<h1 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来</h1><ul>
<li>使用keys指令可以扫出指定模式的key列表。</li>
<li>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</li>
<li>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复</li>
<li>这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</li>
</ul>
<h1 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h1><ul>
<li>使用list类型保存数据信息</li>
<li>rpush生产消息</li>
<li>lpop消费消息</li>
<li>当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息</li>
<li>如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来</li>
<li>redis可以通过pub&#x2F;sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</li>
</ul>
<h1 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h1><ul>
<li>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><ul>
<li>通常会采取的一种方式是主从架构Master&#x2F;Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。</li>
<li>redis-server –port 6380 –slaveof <master-ip> <master-port>，配置当前服务为某Redis服务的Slave</li>
<li>SLAVEOF host port命令，将当前服务器状态从Master修改为别的服务器的Slave</li>
<li>redis&gt;SLAVEOF 192.169.0.110 6379，将服务器转换为Slave</li>
<li>redis&gt;SLAVEOF NO ONE 将服务器状态重新恢复到Master，不会丢弃已同步的数据</li>
<li>配置方式：启动时，服务器读取配置文件，并自动成为指定服务器的从服务器</li>
<li>slaveof <master-ip> <master-port></li>
<li>slaveof 127.0.0.1 6379</li>
</ul>
<h1 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h1><ul>
<li>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： <ul>
<li>从服务器连接主服务器，发送SYNC命令； </li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ul>
</li>
</ul>
<h1 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h1><ul>
<li>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </li>
<li>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</li>
</ul>
<p> </p>
<h1 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h1><ul>
<li>主从刚刚连接的时候，进行全量同步；</li>
<li>全同步结束后，进行增量同步</li>
<li>当然，如果有需要，slave 在任何时候都可以发起全量同步</li>
<li>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li>
<li>如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</li>
<li>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</li>
<li>不持久化的主服务器自动重启非常危险呢？</li>
</ul>
<h1 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h1><ul>
<li>反客为主的自动版，能够后台监控Master库是否故障，如果故障了根据投票数自动将slave库转换为主库</li>
<li>一组sentinel能同时监控多个Master。</li>
<li>使用步骤：<ul>
<li>在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；</li>
<li>配置哨兵，在sentinel.conf文件中填入内容：<ul>
<li>sentinel monitor 被监控数据库名字（自己起名字） ip port 1</li>
<li>说明：上面最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机。</li>
</ul>
</li>
<li>启动哨兵模式：<ul>
<li>命令键入：redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</li>
<li>注：上述sentinel.conf路径按各自实际情况配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h1><ul>
<li>延时，由于所有的写操作都是在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟</li>
<li>当系统很繁忙的时候，延迟问题会更加严重</li>
<li>Slave机器数量的增加也会使得这个问题更加严重。</li>
</ul>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><ul>
<li>redis cluster在设计的时候，就考虑到了去中心化，去中间件</li>
<li>也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态</li>
<li>每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li>
<li>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的</li>
<li>redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384</li>
<li>Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步</li>
<li>当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据</li>
<li>只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。</li>
<li>需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</li>
</ul>
<h1 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h1><ul>
<li>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存</li>
<li>因为纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。</li>
<li>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等</li>
<li>另外 Redis 也可以对存入的Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。</li>
<li>Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
</ul>
<h1 id="Redis-相比-memcached-有哪些优势？"><a href="#Redis-相比-memcached-有哪些优势？" class="headerlink" title="Redis 相比 memcached 有哪些优势？"></a>Redis 相比 memcached 有哪些优势？</h1><ul>
<li>memcached 所有的值均是简单的字符串，Redis 作为其替代者，支持更为丰富的数据类型</li>
<li>Redis 的速度比 memcached 快很多</li>
<li>Redis 可以持久化其数据</li>
</ul>
<h1 id="Redis-主要消耗什么物理资源？"><a href="#Redis-主要消耗什么物理资源？" class="headerlink" title="Redis 主要消耗什么物理资源？"></a>Redis 主要消耗什么物理资源？</h1><ul>
<li>内存。</li>
</ul>
<h1 id="Redis-的全称是什么？"><a href="#Redis-的全称是什么？" class="headerlink" title="Redis 的全称是什么？"></a>Redis 的全称是什么？</h1><ul>
<li>Remote Dictionary Server。</li>
</ul>
<h1 id="Redis-官方为什么不提供-Windows-版本？"><a href="#Redis-官方为什么不提供-Windows-版本？" class="headerlink" title="Redis 官方为什么不提供 Windows 版本？"></a>Redis 官方为什么不提供 Windows 版本？</h1><ul>
<li>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。</li>
</ul>
<h1 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h1><ul>
<li>512M</li>
</ul>
<h1 id="为什么-Redis-需要把所有数据放到内存中？"><a href="#为什么-Redis-需要把所有数据放到内存中？" class="headerlink" title="为什么 Redis 需要把所有数据放到内存中？"></a>为什么 Redis 需要把所有数据放到内存中？</h1><ul>
<li>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。</li>
<li>所以 Redis 具有快速和数据持久化的特征</li>
<li>如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重影响 Redis 的性能</li>
<li>在内存越来越便宜的今天，Redis 将会越来越受欢迎。</li>
<li>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</li>
</ul>
<h1 id="Redis-集群方案应该怎么做？都有哪些方案？"><a href="#Redis-集群方案应该怎么做？都有哪些方案？" class="headerlink" title="Redis 集群方案应该怎么做？都有哪些方案？"></a>Redis 集群方案应该怎么做？都有哪些方案？</h1><ul>
<li>twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 Redis 无任何区别，设置好它下属的多个 Redis 实例后，使用时在本需要连接 Redis 的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 Redis，将结果再返回 twemproxy。使用方式简便(相对 Redis 只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对Redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</li>
<li>codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点。</li>
<li>Redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</li>
<li>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 key 进行 hash 计算，然后去对应的 Redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</li>
</ul>
<h1 id="Redis-集群方案什么情况下会导致整个集群不可用？"><a href="#Redis-集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="Redis 集群方案什么情况下会导致整个集群不可用？"></a>Redis 集群方案什么情况下会导致整个集群不可用？</h1><ul>
<li>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</li>
</ul>
<h1 id="MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证-Redis-中的数据都是热点数据？"><a href="#MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证-Redis-中的数据都是热点数据？" class="headerlink" title="MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？"></a>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</h1><ul>
<li>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</li>
</ul>
<h1 id="Redis-有哪些适合的场景？"><a href="#Redis-有哪些适合的场景？" class="headerlink" title="Redis 有哪些适合的场景？"></a>Redis 有哪些适合的场景？</h1><h4 id="会话缓存（Session-Cache）"><a href="#会话缓存（Session-Cache）" class="headerlink" title="会话缓存（Session Cache）"></a>会话缓存（Session Cache）</h4><ul>
<li>最常用的一种使用 Redis 的情景是会话缓存（session cache）</li>
<li>用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化</li>
<li>当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</li>
<li>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档</li>
<li>甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</li>
</ul>
<h4 id="全页缓存（FPC）"><a href="#全页缓存（FPC）" class="headerlink" title="全页缓存（FPC）"></a>全页缓存（FPC）</h4><ul>
<li>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台</li>
<li>回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。</li>
<li>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。</li>
<li>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-Redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作</li>
<li>这使得 Redis 能作为一个很好的消息队列平台来使用</li>
<li>Redis 作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push&#x2F;pop 操作。</li>
<li>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</li>
</ul>
<h4 id="排行榜-计数器"><a href="#排行榜-计数器" class="headerlink" title="排行榜&#x2F;计数器"></a>排行榜&#x2F;计数器</h4><ul>
<li>Redis在内存中对数字进行递增或递减的操作实现的非常好</li>
<li>集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构</li>
<li>所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</li>
<li>当然，这是假定你是根据你用户的分数做递增的排序</li>
<li>如果你想返回用户及用户的分数，你需要这样执行：ZRANGE user_scores 0 10 WITHSCORES</li>
<li>Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</li>
</ul>
<h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h4><ul>
<li>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能</li>
<li>发布&#x2F;订阅的使用场景确实非常多</li>
<li>我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用 Redis 的发布&#x2F;订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</li>
</ul>
<h1 id="Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？"><a href="#Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？"></a>Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</h1><ul>
<li>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</li>
</ul>
<h1 id="Redis-和-Redisson-有什么关系？"><a href="#Redis-和-Redisson-有什么关系？" class="headerlink" title="Redis 和 Redisson 有什么关系？"></a>Redis 和 Redisson 有什么关系？</h1><ul>
<li>Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</li>
</ul>
<h1 id="Jedis-与-Redisson-对比有什么优缺点？"><a href="#Jedis-与-Redisson-对比有什么优缺点？" class="headerlink" title="Jedis 与 Redisson 对比有什么优缺点？"></a>Jedis 与 Redisson 对比有什么优缺点？</h1><ul>
<li>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；</li>
<li>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性</li>
<li>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li>
</ul>
<h1 id="Redis-如何设置密码及验证密码？"><a href="#Redis-如何设置密码及验证密码？" class="headerlink" title="Redis 如何设置密码及验证密码？"></a>Redis 如何设置密码及验证密码？</h1><ul>
<li>设置密码：config set requirepass 123456</li>
<li>授权密码：auth 123456</li>
</ul>
<h1 id="说说-Redis-哈希槽的概念？"><a href="#说说-Redis-哈希槽的概念？" class="headerlink" title="说说 Redis 哈希槽的概念？"></a>说说 Redis 哈希槽的概念？</h1><ul>
<li>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念</li>
<li>Redis 集群有 16384 个哈希槽，</li>
<li>每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分hash 槽。</li>
</ul>
<h1 id="Redis-集群的主从复制模型是怎样的？"><a href="#Redis-集群的主从复制模型是怎样的？" class="headerlink" title="Redis 集群的主从复制模型是怎样的？"></a>Redis 集群的主从复制模型是怎样的？</h1><ul>
<li>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品</li>
</ul>
<h1 id="Redis-集群会有写操作丢失吗？为什么？"><a href="#Redis-集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis 集群会有写操作丢失吗？为什么？"></a>Redis 集群会有写操作丢失吗？为什么？</h1><ul>
<li>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</li>
</ul>
<h1 id="Redis-集群之间是如何复制的？"><a href="#Redis-集群之间是如何复制的？" class="headerlink" title="Redis 集群之间是如何复制的？"></a>Redis 集群之间是如何复制的？</h1><ul>
<li>异步复制</li>
</ul>
<h1 id="Redis-集群最大节点个数是多少？"><a href="#Redis-集群最大节点个数是多少？" class="headerlink" title="Redis 集群最大节点个数是多少？"></a>Redis 集群最大节点个数是多少？</h1><ul>
<li>16384 个。</li>
</ul>
<h1 id="Redis-集群如何选择数据库？"><a href="#Redis-集群如何选择数据库？" class="headerlink" title="Redis 集群如何选择数据库？"></a>Redis 集群如何选择数据库？</h1><ul>
<li>Redis 集群目前无法做数据库选择，默认在 0 数据库。</li>
</ul>
<h1 id="怎么测试-Redis-的连通性？"><a href="#怎么测试-Redis-的连通性？" class="headerlink" title="怎么测试 Redis 的连通性？"></a>怎么测试 Redis 的连通性？</h1><ul>
<li>ping</li>
</ul>
<h1 id="Redis-中的管道有什么用？"><a href="#Redis-中的管道有什么用？" class="headerlink" title="Redis 中的管道有什么用？"></a>Redis 中的管道有什么用？</h1><ul>
<li>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应</li>
<li>这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复</li>
<li>这就是管道（pipelining），是一种几十年来广泛使用的技术</li>
<li>例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</li>
</ul>
<h1 id="怎么理解-Redis-事务？"><a href="#怎么理解-Redis-事务？" class="headerlink" title="怎么理解 Redis 事务？"></a>怎么理解 Redis 事务？</h1><ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行</li>
<li>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<h1 id="Redis-事务相关的命令有哪几个？"><a href="#Redis-事务相关的命令有哪几个？" class="headerlink" title="Redis 事务相关的命令有哪几个？"></a>Redis 事务相关的命令有哪几个？</h1><ul>
<li>MULTI、EXEC、DISCARD、WATCH</li>
</ul>
<h1 id="Redis-key-的过期时间和永久有效分别怎么设置？"><a href="#Redis-key-的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key 的过期时间和永久有效分别怎么设置？"></a>Redis key 的过期时间和永久有效分别怎么设置？</h1><ul>
<li>EXPIRE 和 PERSIST 命令。</li>
</ul>
<h1 id="Redis-如何做内存优化？"><a href="#Redis-如何做内存优化？" class="headerlink" title="Redis 如何做内存优化？"></a>Redis 如何做内存优化？</h1><ul>
<li>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小</li>
<li>所以你应该尽可能的将你的数据模型抽象到一个散列表里面</li>
<li>比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面</li>
</ul>
<h1 id="Redis-回收进程如何工作的？"><a href="#Redis-回收进程如何工作的？" class="headerlink" title="Redis 回收进程如何工作的？"></a>Redis 回收进程如何工作的？</h1><ul>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
<li>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</li>
</ul>
<h1 id="Redis-回收使用的是什么算法？"><a href="#Redis-回收使用的是什么算法？" class="headerlink" title="Redis 回收使用的是什么算法？"></a>Redis 回收使用的是什么算法？</h1><ul>
<li>LRU 算法</li>
</ul>
<h1 id="Redis-如何做大量数据插入？"><a href="#Redis-如何做大量数据插入？" class="headerlink" title="Redis 如何做大量数据插入？"></a>Redis 如何做大量数据插入？</h1><ul>
<li>Redis2.6 开始 Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</li>
</ul>
<h1 id="为什么要做-Redis-分区？"><a href="#为什么要做-Redis-分区？" class="headerlink" title="为什么要做 Redis 分区？"></a>为什么要做 Redis 分区？</h1><ul>
<li>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存</li>
<li>如果没有分区，你最多只能使用一台机器的内存</li>
<li>分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升</li>
<li>Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。</li>
</ul>
<h1 id="你知道有哪些-Redis-分区实现方案？"><a href="#你知道有哪些-Redis-分区实现方案？" class="headerlink" title="你知道有哪些 Redis 分区实现方案？"></a>你知道有哪些 Redis 分区实现方案？</h1><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取</li>
<li>大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。</li>
<li>代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。</li>
<li>Redis 和 memcached 的一种代理实现就是 Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个 Redis 实例，然后由 Redis将请求转发给正确的 Redis 节点</li>
<li>Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接redirected 到正确的 Redis 节点。</li>
</ul>
<h1 id="Redis-分区有什么缺点？"><a href="#Redis-分区有什么缺点？" class="headerlink" title="Redis 分区有什么缺点？"></a>Redis 分区有什么缺点？</h1><ul>
<li>涉及多个 key 的操作通常不会被支持</li>
<li>例如你不能对两个集合求交集，因为他们可能被存储到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个 key,则不能使用 Redis 事务</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning<br>granularity is the key, so it is not possible to shard a dataset with a single huge<br>key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机同时收集 RDB &#x2F; AOF 文件。</li>
<li>分区时动态扩容或缩容可能非常复杂</li>
<li>Redis 集群在运行时增加或者删除 Redis 节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性</li>
<li>然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h1 id="Redis-持久化数据和缓存怎么做扩容？"><a href="#Redis-持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis 持久化数据和缓存怎么做扩容？"></a>Redis 持久化数据和缓存怎么做扩容？</h1><ul>
<li>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</li>
</ul>
<h1 id="分布式-Redis-是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式-Redis-是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式 Redis 是前期做还是后期规模上来了再做好？为什么？"></a>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？</h1><ul>
<li>既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。- 即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</li>
<li>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</li>
<li>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）</li>
<li>一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</li>
</ul>
<h1 id="Twemproxy-是什么？"><a href="#Twemproxy-是什么？" class="headerlink" title="Twemproxy 是什么？"></a>Twemproxy 是什么？</h1><ul>
<li>Twemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis协议</li>
<li>它是单线程程序，使用 c 语言编写，运行起来非常快</li>
<li>它是采用 Apache 2.0 license的开源软件。</li>
<li>Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存时使用 Twemproxy)。</li>
<li>Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实例，然后让你的客户端去连接任意一个 Twemproxy 实例。</li>
<li>Twemproxy 是 Redis 客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</li>
</ul>
<h1 id="支持一致性哈希的客户端有哪些？"><a href="#支持一致性哈希的客户端有哪些？" class="headerlink" title="支持一致性哈希的客户端有哪些？"></a>支持一致性哈希的客户端有哪些？</h1><ul>
<li>Redis-rb、PRedis 等。</li>
</ul>
<h1 id="Redis-与其他-key-value-存储有什么不同？"><a href="#Redis-与其他-key-value-存储有什么不同？" class="headerlink" title="Redis 与其他 key-value 存储有什么不同？"></a>Redis 与其他 key-value 存储有什么不同？</h1><ul>
<li>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径</li>
<li>Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>
<li>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存</li>
<li>在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情</li>
<li>同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</li>
</ul>
<h1 id="Redis-的内存占用情况怎么样？"><a href="#Redis-的内存占用情况怎么样？" class="headerlink" title="Redis 的内存占用情况怎么样？"></a>Redis 的内存占用情况怎么样？</h1><ul>
<li>给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的32 位的 Mac 笔记本上 用了 100MB</li>
<li>同样的数据放到一个 key 里只需要 16MB， 这是因为键值有一个很大的开销</li>
<li>在 Memcached 上执行也是类似的结果，但是相对 Redis的开销要小一点点，因为 Redis 会记录类型信息引用计数等等。</li>
<li>当然，大键值对时两者的比例要好很多。</li>
<li>64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系统里指针占用了 8 个字节</li>
<li>但是，当然，64 位系统支持更大的内存，所以为了运行大型的 Redis 服务器或多或少的需要使用 64 位的系统。</li>
</ul>
<h1 id="都有哪些办法可以降低-Redis-的内存使用情况呢？"><a href="#都有哪些办法可以降低-Redis-的内存使用情况呢？" class="headerlink" title="都有哪些办法可以降低 Redis 的内存使用情况呢？"></a>都有哪些办法可以降低 Redis 的内存使用情况呢？</h1><ul>
<li>如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，</li>
<li>因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</li>
</ul>
<h1 id="查看-Redis-使用情况及状态信息用什么命令？"><a href="#查看-Redis-使用情况及状态信息用什么命令？" class="headerlink" title="查看 Redis 使用情况及状态信息用什么命令？"></a>查看 Redis 使用情况及状态信息用什么命令？</h1><ul>
<li>info</li>
</ul>
<h1 id="Redis-的内存用完了会发生什么？"><a href="#Redis-的内存用完了会发生什么？" class="headerlink" title="Redis 的内存用完了会发生什么？"></a>Redis 的内存用完了会发生什么？</h1><ul>
<li>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）</li>
<li>或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</li>
</ul>
<h1 id="Redis-是单线程的，如何提高多核-CPU-的利用率？"><a href="#Redis-是单线程的，如何提高多核-CPU-的利用率？" class="headerlink" title="Redis 是单线程的，如何提高多核 CPU 的利用率？"></a>Redis 是单线程的，如何提高多核 CPU 的利用率？</h1><ul>
<li>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，</li>
<li>所以，如果你想使用多个 CPU，你可以考虑一下分片（shard）。</li>
</ul>
<h1 id="一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set-他们最多能存放多少元素？"><a href="#一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set-他们最多能存放多少元素？" class="headerlink" title="一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？"></a>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</h1><ul>
<li>理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2亿 5 千万的 keys</li>
<li>任何 list、set、和 sorted set 都可以放 232 个元素。</li>
<li>换句话说，Redis 的存储极限是系统中的可用内存值。</li>
</ul>
<h1 id="Redis-常见性能问题和解决方案？"><a href="#Redis-常见性能问题和解决方案？" class="headerlink" title="Redis 常见性能问题和解决方案？"></a>Redis 常见性能问题和解决方案？</h1><ul>
<li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</li>
<li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内</li>
<li>尽量避免在压力很大的主库上增加从库</li>
<li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2<br>&lt;- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可<br>以立刻启用 Slave1 做 Master，其他不变。</li>
</ul>
<h1 id="如何选择合适的持久化方式？"><a href="#如何选择合适的持久化方式？" class="headerlink" title="如何选择合适的持久化方式？"></a>如何选择合适的持久化方式？</h1><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</li>
<li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</li>
</ul>
<h1 id="修改配置不重启-Redis-会实时生效吗？"><a href="#修改配置不重启-Redis-会实时生效吗？" class="headerlink" title="修改配置不重启 Redis 会实时生效吗？"></a>修改配置不重启 Redis 会实时生效吗？</h1><ul>
<li>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启</li>
<li>从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis</li>
<li>检索 ‘CONFIG GET *’ 命令获取更多信息。</li>
<li>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前CONFIG 命令还不支持的配置参数的时候。</li>
</ul>
<h1 id="使用过-Redis-做异步队列么，你是怎么用的？"><a href="#使用过-Redis-做异步队列么，你是怎么用的？" class="headerlink" title="使用过 Redis 做异步队列么，你是怎么用的？"></a>使用过 Redis 做异步队列么，你是怎么用的？</h1><ul>
<li>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</li>
<li>如果对方追问可不可以不用 sleep 呢？</li>
<li>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用 pub&#x2F;sub 主题订阅者模式，可以实现1:N 的消息队列。</li>
<li>如果对方追问 pub&#x2F;sub 有什么缺点？</li>
<li>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</li>
<li>如果对方追问 redis 如何实现延时队列？</li>
<li>我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</li>
</ul>
<h1 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h1><ul>
<li>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</li>
</ul>
<h1 id="Redis-最适合的场景？"><a href="#Redis-最适合的场景？" class="headerlink" title="Redis 最适合的场景？"></a>Redis 最适合的场景？</h1><h4 id="会话缓存（Session-Cache）-1"><a href="#会话缓存（Session-Cache）-1" class="headerlink" title="会话缓存（Session Cache）"></a>会话缓存（Session Cache）</h4><ul>
<li>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。</li>
</ul>
<h4 id="全页缓存（FPC）-1"><a href="#全页缓存（FPC）-1" class="headerlink" title="全页缓存（FPC）"></a>全页缓存（FPC）</h4><ul>
<li>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento提供一个插件来使用 Redis 作为全页缓存后端。 此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
</ul>
<h4 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h4><ul>
<li>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push&#x2F;pop 操作。 如果你快速的在 Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</li>
</ul>
<h4 id="排行榜-计数器-1"><a href="#排行榜-计数器-1" class="headerlink" title="排行榜&#x2F;计数器"></a>排行榜&#x2F;计数器</h4><ul>
<li>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</li>
</ul>
<h4 id="发布-订阅-1"><a href="#发布-订阅-1" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h4><ul>
<li>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用 Redis 的发布&#x2F;订阅功能来建立聊天系统！</li>
</ul>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring cloud</title>
    <url>/publishes/4a23c7da79c0.html</url>
    <content><![CDATA[<h1 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h1><ul>
<li>Spring Cloud 是一个基于 Spring Boot 的开发工具集</li>
<li>专为构建微服务架构而设计</li>
<li>它提供了一系列的工具和框架，使开发、部署和维护微服务变得更加简单和高效</li>
</ul>
<h1 id="Spring-Cloud-的一些核心概念"><a href="#Spring-Cloud-的一些核心概念" class="headerlink" title="Spring Cloud 的一些核心概念"></a>Spring Cloud 的一些核心概念</h1><ul>
<li>配置管理: Spring Cloud 提供工具来统一管理和维护在多个环境中的微服务配置，如开发、测试和生产环境。</li>
<li>服务发现: 它集成了服务发现服务器，如 Eureka，使得微服务可以自动注册自己并发现其他服务。</li>
<li>负载均衡: 通过集成 Ribbon 和其他工具，Spring Cloud 提供客户端侧的负载均衡，帮助分发请求到不同的实例。</li>
<li>断路器: 通过 Hystrix，Spring Cloud 提供了断路器模式，以确保在某个服务出现问题时，不会导致整个系统的崩溃。</li>
<li>API 网关: 通过 Zuul，Spring Cloud 提供了API网关解决方案，用于请求路由、过滤和负载均衡。</li>
<li>分布式跟踪: Spring Cloud 集成了 Zipkin 和 Sleuth，为微服务架构提供分布式日志追踪。</li>
<li>分布式数据管理: 提供了工具来处理在微服务架构中的数据一致性和分布式事务问题。</li>
<li>集成和适配: Spring Cloud 与许多常见的云平台和服务深度集成，例如 AWS、GCP 和 Azure，使得部署和管理微服务更加简单。</li>
</ul>
<h1 id="使用Spring-Cloud有什么优势"><a href="#使用Spring-Cloud有什么优势" class="headerlink" title="使用Spring Cloud有什么优势"></a>使用Spring Cloud有什么优势</h1><ul>
<li>耦合度比较低。不会影响其他模块的开发</li>
<li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</li>
<li>配置比较简单，基本用注解就能实现，不用使用过多的配置文件</li>
<li>微服务跨平台的，可以用任何一种语言开发</li>
<li>每个微服务可以有自己的独立的数据库也有用公共的数据库</li>
<li>直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</li>
</ul>
<h1 id="服务注册和发现是什么意思？Spring-Cloud如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud如何实现？"></a>服务注册和发现是什么意思？Spring Cloud如何实现？</h1><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><ul>
<li>服务注册：将服务实例的信息注册到服务注册中心</li>
<li>在微服务架构中，每个服务都是独立运行的，需要通过服务注册中心来管理和调用</li>
<li>服务注册中心是一个集中的服务实例的注册和发现的地方</li>
<li>当一个服务实例启动时，它会向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号等</li>
<li>其他服务可以通过服务注册中心查询到需要调用的服务的信息，从而实现服务之间的通信</li>
<li>Spring Cloud提供了多个服务注册中心的实现，如Eureka、Consul和Zookeeper，其中，Eureka是Spring Cloud的默认选择</li>
<li>每个服务实例在启动时，会向Eureka服务器注册自己的信息</li>
<li>Eureka服务器会维护一个服务注册表，用于保存所有已注册的服务实例信息</li>
<li>其他服务可以通过查询服务注册表来获取需要调用的服务的相关信息</li>
<li>服务注册的优势在于解耦了服务之间的直接依赖关系，使得服务之间可以动态地发现和调用</li>
<li>通过服务注册，可以实现服务的高可用性和负载均衡，当某个服务实例不可用时，可以自动剔除或替换，从而保证整个系统的稳定性和可靠性</li>
<li>同时，服务注册还能提供服务的版本管理、动态扩缩容等功能，为微服务架构带来更大的灵活性和可扩展性</li>
</ul>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul>
<li>服务发现是指在微服务架构中，通过服务注册中心来查询和发现可用的服务实例</li>
<li>在传统的单体应用中，服务的调用通常是通过硬编码的方式实现的，而在微服务架构中，由于服务实例的数量和位置可能会动态变化，因此需要一种机制来动态地发现和调用服务</li>
<li>Spring Cloud提供了多个服务发现的实现，例如Eureka、Consul和Zookeeper</li>
<li>服务发现的基本流程如下<ul>
<li>服务注册：当一个服务实例启动时，它会向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号等。注册后，服务注册中心会维护一个服务注册表，记录所有已注册的服务实例</li>
<li>服务查询：当需要调用某个服务时，服务消费者可以通过服务注册中心查询到该服务的可用实例信息。服务消费者可以根据需要的负载均衡策略，选择一个合适的服务实例进行调用。</li>
<li>服务调用：服务消费者通过获取到的服务实例信息，可以直接向服务提供者发送请求，进行服务调用。服务消费者可以通过负载均衡、容错机制等手段，提高系统的可用性和稳定性。</li>
</ul>
</li>
</ul>
<h1 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h1><ul>
<li>负载平衡的作用<ul>
<li>提高系统性能：通过将请求分发到多个服务器上，负载平衡可以避免单一服务器的过载情况，从而提高系统的整体吞吐量和响应速度。</li>
<li>增加系统可靠性：当某个服务器发生故障或不可用时，负载平衡可以将请求转发到其他正常工作的服务器上，确保系统的可用性和稳定性。</li>
<li>实现扩展性：负载平衡可以根据实际需求，添加或移除服务器，以适应流量的增加或减少，从而实现系统的弹性扩展。</li>
<li>实现会话保持：负载平衡可以确保同一个用户的连续请求都被转发到同一个服务器上，以保持用户会话的状态。</li>
</ul>
</li>
<li>常见的负载平衡算法有轮询、随机、最少连接等<ul>
<li>轮询算法是将请求按照顺序依次分发到每个服务器上</li>
<li>随机算法是随机选择一个服务器来处理请求</li>
<li>最少连接算法是将请求分发到当前连接数最少的服务器上</li>
</ul>
</li>
<li>负载平衡可以通过硬件设备（如负载均衡器）或软件方式实现，常用的软件负载均衡工具有Nginx、HAProxy、SpringCloud的Ribbon等。这些工具可以根据实际需求和场景选择，以提供高效的负载平衡服务。</li>
</ul>
<h1 id="什么是Hystrix？它如何实现容错？"><a href="#什么是Hystrix？它如何实现容错？" class="headerlink" title="什么是Hystrix？它如何实现容错？"></a>什么是Hystrix？它如何实现容错？</h1><ul>
<li>hystrix是Netlifx开源的一款容错框架，防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控(Hystrix Dashboard)等功能</li>
</ul>
<h4 id="hystrix被设计的目标"><a href="#hystrix被设计的目标" class="headerlink" title="hystrix被设计的目标"></a>hystrix被设计的目标</h4><ul>
<li>对通过第三方客户端库访问的依赖项（通常是通过网络）的延迟和故障进行保护和控制。</li>
<li>在复杂的分布式系统汇中阻止级联故障。</li>
<li>快速失败，快速恢复。</li>
<li>回退，尽可能优雅的降级。</li>
<li>启用近实时监控、警报和操作控制。</li>
</ul>
<h4 id="Hystrix使用场景"><a href="#Hystrix使用场景" class="headerlink" title="Hystrix使用场景"></a>Hystrix使用场景</h4><ul>
<li>调用超时时间比你自己定义的阈值要长。</li>
<li>线程池满了，该以来应该立即拒绝请求，而不是排队</li>
<li>在一段时间内，如果服务的错误百分比超过了一个阈值，就会触发一个断路器来停止对特定服务的所有请求，无论是手动还是自动的</li>
</ul>
<h4 id="Hystrix如何解决依赖隔离"><a href="#Hystrix如何解决依赖隔离" class="headerlink" title="Hystrix如何解决依赖隔离"></a>Hystrix如何解决依赖隔离</h4><ul>
<li>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中&#x2F;信号授权下执行。</li>
<li>可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</li>
<li>为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</li>
<li>依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</li>
<li>提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</li>
<li>提供近实时依赖的统计和监控</li>
</ul>
<h1 id="什么是Netflix-Feign？它的优点是什么？"><a href="#什么是Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是Netflix Feign？它的优点是什么？"></a>什么是Netflix Feign？它的优点是什么？</h1><h4 id="Feign是什么"><a href="#Feign是什么" class="headerlink" title="Feign是什么"></a>Feign是什么</h4><ul>
<li>Feign 是 Spring Cloud Netflix 组件中的一个轻量级 RESTful 的 HTTP 服务客户端</li>
<li>实现了负载均衡和 Rest 调用的开源框架</li>
<li>封装了 Ribbon 和 RestTemplate</li>
<li>实现了 WebService的面向接口编程，进一步降低了项目的耦合度</li>
<li>Feign 内置了 Ribbon，用来做客户端负载均衡调用服务注册中心的服务</li>
<li>Feign 本身并不支持 Spring MVC 的注解，它有一套自己的注解，为了更方便的使用，Spring Cloud 孵化了 OpenFeign</li>
<li>Feign 是一种声明式、模板化的 HTTP 客户端（仅在 Consumer 中使用）</li>
<li>Feign 的使用方式是：使用 Feign 的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。</li>
</ul>
<h4 id="Feign解决了什么问题"><a href="#Feign解决了什么问题" class="headerlink" title="Feign解决了什么问题"></a>Feign解决了什么问题</h4><ul>
<li>Feign 旨在使编写 JAVA HTTP 客户端变得更加容易</li>
<li>Feign 简化了 RestTemplate 代码，实现了 Ribbon负载均衡，使代码变得更加简洁，也少了客户端调用的代码，使用 Feign 实现负载均衡是首选方案</li>
<li>只需要你创建一个接口，然后在上面添加注解即可</li>
<li>Feign 是声明式服务调用组件，其核心就是：像调用本地方法一样调用远程方法，无感知远程 HTTP 请求</li>
<li>它解决了让开发者调用远程接口就跟调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP请求</li>
<li>无需关注与远程的交互细节，更无需关注分布式环境开发</li>
<li>它像 Dubbo 一样，Consumer 直接调用 Provider 接口方法，而不需要通过常规的 Http Client 构造请求再解析返回数据</li>
</ul>
<h1 id="什么是Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是Spring Cloud Bus？我们需要它吗？"></a>什么是Spring Cloud Bus？我们需要它吗？</h1><h4 id="什么是Spring-Cloud-Bus"><a href="#什么是Spring-Cloud-Bus" class="headerlink" title="什么是Spring Cloud Bus"></a>什么是Spring Cloud Bus</h4><ul>
<li>Spring Cloud Bus是Spring Cloud提供的一种用于实现分布式系统中消息传递和事件驱动的组件</li>
<li>Spring Cloud Bus是基于消息代理的分布式系统消息总线</li>
<li>它利用轻量级消息代理来连接各个分布式节点，实现节点之间的消息传递和事件驱动</li>
<li>Spring Cloud Bus的核心思想是通过消息广播机制，使得一次配置更新可以触发所有相关节点的配置刷新，从而实现分布式系统的配置管理和动态更新</li>
<li>通过消息广播机制和消息代理，它可以实现配置的动态刷新、事件的传递和驱动，以及系统的监控与管理</li>
</ul>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>引入依赖：在项目的pom.xml文件中添加Spring Cloud Bus相关的依赖<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>配置消息代理：在Spring Cloud配置文件中配置消息代理的地址和相关参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure></li>
<li>注册消息总线端点：在Spring Boot应用程序中注册消息总线的端点<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@RestController</span><br><span class="line">public class MyApp &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RefreshEndpoint refreshEndpoint;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/refresh&quot;)</span><br><span class="line">    public void refresh() &#123;</span><br><span class="line">        refreshEndpoint.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>刷新配置：通过发送POST请求到消息总线端点来触发配置的刷新<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">restTemplate.postForObject(&quot;http://localhost:8080/refresh&quot;, null, Void.class);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Spring-Cloud-Bus的核心组件"><a href="#Spring-Cloud-Bus的核心组件" class="headerlink" title="Spring Cloud Bus的核心组件"></a>Spring Cloud Bus的核心组件</h4><ul>
<li>消息代理：用于转发消息和事件的中间件，如RabbitMQ、Kafka等。</li>
<li>消息总线：通过消息代理将消息广播给所有相关节点。</li>
<li>消息生成器：用于生成和发送消息的组件。</li>
<li>消息接收器：用于接收和处理消息的组件。</li>
</ul>
<h4 id="Spring-Cloud-Bus的作用"><a href="#Spring-Cloud-Bus的作用" class="headerlink" title="Spring Cloud Bus的作用"></a>Spring Cloud Bus的作用</h4><ul>
<li>配置刷新：通过消息广播机制，实现配置的动态刷新，避免了每个节点都需要手动刷新配置的问题</li>
<li>事件驱动：通过消息代理的发布-订阅模式，实现事件的传递和驱动，使得各个节点能够响应和处理特定的事件</li>
<li>监控与管理：可以通过消息总线来收集系统的监控数据和指标，实现分布式系统的集中管理和监控</li>
</ul>
<h1 id="Spring-Cloud-19个技术"><a href="#Spring-Cloud-19个技术" class="headerlink" title="Spring Cloud 19个技术"></a>Spring Cloud 19个技术</h1><ul>
<li>Spring Cloud Config 配置中心，利用git集中管理程序的配置。</li>
<li>Spring Cloud Netflix 集成众多Netflix的开源软件</li>
<li>Spring Cloud Bus 消息总线，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化</li>
<li>Spring Cloud for Cloud Foundry 利用Pivotal Cloudfoundry集成你的应用程序</li>
<li>Spring Cloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。</li>
<li>Spring Cloud Cluster 基于Zookeeper, Redis, Hazelcast, Consul实现的领导选举和平民状态模式的抽象和实现。</li>
<li>Spring Cloud Consul 基于Hashicorp Consul实现的服务发现和配置管理。</li>
<li>Spring Cloud Security 在Zuul代理中为OAuth2 rest客户端和认证头转发提供负载均衡</li>
<li>Spring Cloud Sleuth SpringCloud应用的分布式追踪系统，和Zipkin，HTrace，ELK兼容。</li>
<li>Spring Cloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。</li>
<li>Spring Cloud Stream 基于Redis,Rabbit,Kafka实现的消息微服务，简单声明模型用以在Spring Cloud应用中收发消息。</li>
<li>Spring Cloud Stream App Starters 基于Spring Boot为外部系统提供spring的集成</li>
<li>Spring Cloud Task 短生命周期的微服务，为SpringBooot应用简单声明添加功能和非功能特性。</li>
<li>Spring Cloud Task App Starters</li>
<li>Spring Cloud Zookeeper 服务发现和配置管理基于Apache Zookeeper。</li>
<li>Spring Cloud for Amazon Web Services 快速和亚马逊网络服务集成。</li>
<li>Spring Cloud Connectors 便于PaaS应用在各种平台上连接到后端像数据库和消息经纪服务。</li>
<li>Spring Cloud Starters （项目已经终止并且在Angel.SR2后的版本和其他项目合并）</li>
<li>Spring Cloud CLI 插件用Groovy快速的创建Spring Cloud组件应用。</li>
<li>Spring Cloud共集成了19个子项目，里面都包含一个或者多个第三方的组件或者框架！</li>
</ul>
<h1 id="简单说说什么是-Feign？"><a href="#简单说说什么是-Feign？" class="headerlink" title="简单说说什么是 Feign？"></a>简单说说什么是 Feign？</h1><ul>
<li>Feign 是一种声明式、模板化的 HTTP 客户端技术(仅在 consumer 中使用)。</li>
</ul>
<h1 id="什么是-Eureka-注册中心？"><a href="#什么是-Eureka-注册中心？" class="headerlink" title="什么是 Eureka 注册中心？"></a>什么是 Eureka 注册中心？</h1><ul>
<li>Eureka 是 Netflix 开发的服务发现组件，本身是一个基于 REST 的服务</li>
<li>Spring Cloud将它集成在其子项目 spring-cloud-netflix 中，以实现 Spring Cloud 的服务注册于发现，同时还提供了负载均衡、故障转移等能力。</li>
</ul>
<h1 id="简单谈一下-Eureka-中的三种角色分别是什么？"><a href="#简单谈一下-Eureka-中的三种角色分别是什么？" class="headerlink" title="简单谈一下 Eureka 中的三种角色分别是什么？"></a>简单谈一下 Eureka 中的三种角色分别是什么？</h1><ul>
<li>Eureka Server：通过 Register、Get、Renew 等接口提供服务的注册和发现。</li>
<li>Application Service (Service Provider)：服务提供方把自身的服务实例注册到 Eureka Server 中</li>
<li>Application Client (Service Consumer)：服务调用方通过 Eureka Server 获取服务列表，消费服务。</li>
</ul>
<h1 id="什么是-Ribbon"><a href="#什么是-Ribbon" class="headerlink" title="什么是 Ribbon"></a>什么是 Ribbon</h1><ul>
<li>Ribbon 是一个基于 Http 和 TCP 的客服端负载均衡工具，它是基于 Netflix Ribbon实现的。</li>
<li>它不像 spring cloud 服务注册中心、配置中心、API 网关那样独立部署，但是它几乎存在于每个 spring cloud 微服务中。包括 feign 提供的声明式服务调用也是基于该 Ribbon<br>实现的。</li>
<li>ribbon 默认提供很多种负载均衡算法，例如 轮询、随机 等等。甚至包含自定义的负载均衡算法。</li>
</ul>
<h1 id="集中式与进程内负载均衡的区别"><a href="#集中式与进程内负载均衡的区别" class="headerlink" title="集中式与进程内负载均衡的区别"></a>集中式与进程内负载均衡的区别</h1><ul>
<li>目前业界主流的负载均衡方案可分成两类：<ul>
<li>第一类：集中式负载均衡, 即在 consumer 和 provider 之间使用独立的负载均衡设施(可以是硬件，如 F5, 也可以是软件，如 nginx), 由该设施负责把 访问请求 通过某种策略转发至 provider；</li>
<li>第二类：进程内负载均衡，将负载均衡逻辑集成到 consumer，consumer 从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的 provider。</li>
</ul>
</li>
<li>Ribbon 就属于后者，它只是一个类库，集成于 consumer 进程，consumer 通过它来获取到 provider 的地址。</li>
</ul>
<h1 id="Ribbon-的常见负载均衡策略有哪些？"><a href="#Ribbon-的常见负载均衡策略有哪些？" class="headerlink" title="Ribbon 的常见负载均衡策略有哪些？"></a>Ribbon 的常见负载均衡策略有哪些？</h1><ul>
<li>轮询策略（默认） RoundRobinRule<ul>
<li>轮询策略表示每次都顺序取下一个provider，比如一共有 5 个 provider，第 1 次取第 1 个，第 2 次取第 2 个，第3 次取第 3 个，以此类推</li>
</ul>
</li>
<li>权重轮询策略WeightedResponseTime Rule<ul>
<li>根据每个 provider 的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性越低。</li>
<li>原理：一开始为轮询策略，并开启一个计时器，每 30 秒收集一次每个provider 的平均响应时间，当信息足够时，给每个 provider 附上一个权重，并按权重随机选择 provider，高权越重的 provider 会被高概率选中。</li>
</ul>
</li>
<li>随机策略 RandomRule<ul>
<li>从 provider 列表中随机选择一个provider</li>
</ul>
</li>
<li>最少并发数策略 BestAvailableRule<ul>
<li>选择正在请求中的并发数最小的provider，除非这个 provider 在熔断中。</li>
</ul>
</li>
<li>在“选定的负载均衡策略”基础上进行重试机制RetryRule<ul>
<li>“选定的负载均衡策略”这个策略是轮询策略 RoundRobinRule</li>
<li>该重试策略先设定一个阈值时间段，如果在这个阈值时间段内当选择provider 不成功，则一直尝试采用“选定的负载均衡策略：轮询策略”最后选择一个可用的 provider</li>
</ul>
</li>
<li>可用性敏感策略 AvailabilityFilteringRule<ul>
<li>过滤性能差的 provider,有 2 种：<ul>
<li>第一种：过滤掉在 eureka 中处于一直连接失败 provider</li>
<li>第二种：过滤掉高并发的 provider</li>
</ul>
</li>
<li>以一个区域为单位考察可用性，对于不可用的区域整个丢弃，从剩下区域中选可用的 provider</li>
</ul>
</li>
<li>区域敏感性策略 ZoneAvoidanceRule<ul>
<li>如果这个ip区域内有一个或多个实例不可达或响应变慢，都会降低该 ip 区域内其他 ip 被选中的权重。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring cloud</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat</title>
    <url>/publishes/cc5f72fdfb9e.html</url>
    <content><![CDATA[<h1 id="Tomcat的缺省端口是多少，怎么修改？"><a href="#Tomcat的缺省端口是多少，怎么修改？" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改？"></a>Tomcat的缺省端口是多少，怎么修改？</h1><ul>
<li>找到Tomcat目录下的conf文件夹</li>
<li>进入conf文件夹里面找到server.xml文件</li>
<li>打开server.xml文件</li>
<li>在server.xml文件里面找到下列信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li>port&#x3D;”8080”改成你想要的端口</li>
</ul>
<h1 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h1><h4 id="bio：传统的Java-I-O操作，同步且阻塞IO。"><a href="#bio：传统的Java-I-O操作，同步且阻塞IO。" class="headerlink" title="bio：传统的Java I&#x2F;O操作，同步且阻塞IO。"></a>bio：传统的Java I&#x2F;O操作，同步且阻塞IO。</h4><ul>
<li>maxThreads&#x3D;”150”&#x2F;&#x2F;Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值200。可以根据机器的时期性能和内存大小调整，一般可以在400-500。最大可以在800左右。 </li>
<li>minSpareThreads&#x3D;”25”—Tomcat初始化时创建的线程数。默认值4。如果当前没有空闲线程，且没有超过maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。 </li>
<li>maxSpareThreads&#x3D;”75”–一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值50。一旦创建的线程超过此数值，Tomcat会关闭不再需要的线程。线程数可以大致上用 “同时在线人数每秒用户操作次数系统平均操作时间” 来计算。 </li>
<li>acceptCount&#x3D;”100”—-指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。如果当前可用线程数为0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。 </li>
<li>connectionTimeout&#x3D;”20000” –网络连接超时，默认值20000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li>
</ul>
<h4 id="nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。"><a href="#nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。" class="headerlink" title="nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。"></a>nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。</h4><ul>
<li>指定使用NIO模型来接受HTTP请求 </li>
<li>protocol&#x3D;”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol&#x3D;”HTTP&#x2F;1.1” </li>
<li>acceptorThreadCount&#x3D;”2” 使用NIO模型时接收线程的数目</li>
</ul>
<h4 id="aio-nio-2-：JDK7开始支持，异步非阻塞IO。"><a href="#aio-nio-2-：JDK7开始支持，异步非阻塞IO。" class="headerlink" title="aio(nio.2)：JDK7开始支持，异步非阻塞IO。"></a>aio(nio.2)：JDK7开始支持，异步非阻塞IO。</h4><ul>
<li><p>apr：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">      &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8000&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;</span><br><span class="line">    &lt;!-- minProcessors最小空闲连接线程数--&gt;</span><br><span class="line">    &lt;!-- maxProcessors最大连接线程数--&gt;</span><br><span class="line">    &lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;</span><br><span class="line">    &lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;</span><br><span class="line">    &lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; </span><br><span class="line">        connectionTimeout=&quot;20000&quot;</span><br><span class="line">        redirectPort=&quot;8443</span><br><span class="line">        maxThreads=“500” </span><br><span class="line">        minSpareThreads=“100” </span><br><span class="line">        maxSpareThreads=“200”</span><br><span class="line">        acceptCount=&quot;200&quot;</span><br><span class="line">        enableLookups=&quot;false&quot;       </span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他配置</p>
<ul>
<li>maxHttpHeaderSize&#x3D;”8192” http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。 </li>
<li>URIEncoding&#x3D;”UTF-8” 指定Tomcat容器的URL编码格式。 </li>
<li>disableUploadTimeout&#x3D;”true” 上传时是否使用超时机制 </li>
<li>enableLookups&#x3D;”false”–是否反查域名，默认值为true。为了提高处理能力，应设置为false </li>
<li>compression&#x3D;”on”   打开压缩功能 </li>
<li>compressionMinSize&#x3D;”10240” 启用压缩的输出内容大小，默认为2KB </li>
<li>noCompressionUserAgents&#x3D;”gozilla, traviata”   对于以下的浏览器，不启用压缩 </li>
<li>compressableMimeType&#x3D;”text&#x2F;html,text&#x2F;xml,text&#x2F;javascript,text&#x2F;css,text&#x2F;plain” 哪些资源类型需要压缩</li>
</ul>
</li>
</ul>
<h1 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h1><ul>
<li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li>
<li>在server.xml文件上配置<Context>节点，设置相关的属性即可</li>
<li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li>
</ul>
<h1 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h1><ul>
<li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析， 并读取servlet注册信息</li>
<li>然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。（有时候也是在第一次请求时实例化）在servlet注册时加上如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li>
</ul>
<h1 id="tomcat-如何优化？"><a href="#tomcat-如何优化？" class="headerlink" title="tomcat 如何优化？"></a>tomcat 如何优化？</h1><ul>
<li><p>优化连接配置.这里以tomcat7的参数配置为例，需要修改conf&#x2F;server.xml文件，修改连接数，关闭客户端dns查询。</p>
</li>
<li><p>参数解释：</p>
<ul>
<li>URIEncoding&#x3D;”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</li>
<li>maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</li>
<li>minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</li>
<li>enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</li>
<li>connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</li>
<li>maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</li>
<li>acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</li>
<li>maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。通常Windows是1000个左右，Linux是2000个左右。</li>
<li>useURIValidationHack:把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</li>
<li>enableLookups&#x3D;”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</li>
<li>disableUploadTimeout ：类似于Apache中的keeyalive一样</li>
</ul>
</li>
<li><p>给Tomcat配置gzip压缩(HTTP压缩)功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compression=”on” compressionMinSize=”2048″</span><br><span class="line">compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。</p>
</li>
<li><p>相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compression=”on” 打开压缩功能</span><br><span class="line">compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB</span><br><span class="line">noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</span><br><span class="line">compressableMimeType=”text/html,text/xml”　压缩类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置</p>
</li>
</ul>
<h1 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h1><ul>
<li>内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。 </li>
<li>具体设置如下： JAVA_OPTS&#x3D;”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio&#x3D;4 -XX:SurvivorRatio&#x3D;4” </li>
<li>其各项参数如下： <ul>
<li>-Xmx3550m：设置JVM最大可用内存为3550M。 </li>
<li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 </li>
<li>-Xmn2g：设置年轻代大小为2G。整个堆大小&#x3D;年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。 </li>
<li>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 </li>
<li>-XX:NewRatio&#x3D;4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5 </li>
<li>-XX:SurvivorRatio&#x3D;4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1&#x2F;6 </li>
<li>-XX:MaxPermSize&#x3D;16m:设置持久代大小为16m。 </li>
<li>-XX:MaxTenuringThreshold&#x3D;0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li>
</ul>
</li>
</ul>
<h1 id="垃圾回收策略调优"><a href="#垃圾回收策略调优" class="headerlink" title="垃圾回收策略调优"></a>垃圾回收策略调优</h1><ul>
<li>垃圾回收的设置也是在catalina.sh中，调整JAVA_OPTS变量。 </li>
<li>具体设置如下： JAVA_OPTS&#x3D;”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis&#x3D;100” </li>
<li>具体的垃圾回收策略及相应策略的各项参数如下： <ul>
<li>串行收集器（JDK1.5以前主要的回收方式） ：-XX:+UseSerialGC:设置串行收集器 </li>
<li>并行收集器（吞吐量优先） <ul>
<li>示例： java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis&#x3D;100 </li>
<li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 </li>
<li>-XX:ParallelGCThreads&#x3D;20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 </li>
<li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集 </li>
<li>-XX:MaxGCPauseMillis&#x3D;100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 </li>
<li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li>
</ul>
</li>
<li>并发收集器（响应时间优先） <ul>
<li>示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC </li>
<li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio&#x3D;4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。 </li>
<li>-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 </li>
<li>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 </li>
<li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="共享session处理"><a href="#共享session处理" class="headerlink" title="共享session处理"></a>共享session处理</h1><h4 id="使用Tomcat本身的Session复制功能"><a href="#使用Tomcat本身的Session复制功能" class="headerlink" title="使用Tomcat本身的Session复制功能"></a>使用Tomcat本身的Session复制功能</h4><ul>
<li>方案的有点是配置简单，缺点是当集群数量较多时，Session复制的时间会比较长，影响响应的效率</li>
</ul>
<h4 id="使用第三方来存放共享Session"><a href="#使用第三方来存放共享Session" class="headerlink" title="使用第三方来存放共享Session"></a>使用第三方来存放共享Session</h4><ul>
<li>目前用的较多的是使用memcached来管理共享Session，借助于memcached-sesson-manager来进行Tomcat的Session管理</li>
</ul>
<h4 id="使用黏性session的策略"><a href="#使用黏性session的策略" class="headerlink" title="使用黏性session的策略"></a>使用黏性session的策略</h4><ul>
<li>对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同一个用户的session可以由nginx或者apache交给同一个Tomcat来处理，这就是所谓的session sticky策略，目前应用也比较多 </li>
<li>nginx默认不包含session sticky模块，需要重新编译才行（windows下我也不知道怎么重新编译） </li>
<li>优点是处理效率高多了，缺点是强会话要求的场合不合适</li>
</ul>
<h1 id="添加JMS远程监控"><a href="#添加JMS远程监控" class="headerlink" title="添加JMS远程监控"></a>添加JMS远程监控</h1><ul>
<li>对于部署在局域网内其它机器上的Tomcat，可以打开JMX监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在JVM启动参数中配置即可，配置如下： <ul>
<li>-Dcom.sun.management.jmxremote.ssl&#x3D;false  -Dcom.sun.management.jmxremote.authenticate&#x3D;false </li>
<li>-Djava.rmi.server.hostname&#x3D;192.168.71.38 设置JVM的JMS监控监听的IP地址，主要是为了防止错误的监听成127.0.0.1这个内网地址 </li>
<li>-Dcom.sun.management.jmxremote.port&#x3D;1090 设置JVM的JMS监控的端口 </li>
<li>-Dcom.sun.management.jmxremote.ssl&#x3D;false 设置JVM的JMS监控不实用SSL </li>
<li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false 设置JVM的JMS监控不需要认证</li>
</ul>
</li>
</ul>
<h1 id="专业点的分析工具有"><a href="#专业点的分析工具有" class="headerlink" title="专业点的分析工具有"></a>专业点的分析工具有</h1><ul>
<li>IBM ISA，JProfiler、probe 等，具体监控及分析方式去网上搜索即可</li>
</ul>
<h1 id="关于Tomcat的session数目"><a href="#关于Tomcat的session数目" class="headerlink" title="关于Tomcat的session数目"></a>关于Tomcat的session数目</h1><ul>
<li>这个可以直接从Tomcat的web管理界面去查看即可；</li>
<li>或者借助于第三方工具Lambda Probe来查看，它相对于Tomcat自带的管理稍微多了点功能，但也不多 ；</li>
</ul>
<h1 id="监视Tomcat的内存使用情况"><a href="#监视Tomcat的内存使用情况" class="headerlink" title="监视Tomcat的内存使用情况"></a>监视Tomcat的内存使用情况</h1><ul>
<li>使用JDK自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等；</li>
<li>JDK自带的jvisualvm可以下载插件（如GC等），可以查看更丰富的信息。如果是分析本地的Tomcat的话，还可以进行内存抽样等，检查每个类的使用情况</li>
</ul>
<h1 id="打印类的加载情况及对象的回收情况"><a href="#打印类的加载情况及对象的回收情况" class="headerlink" title="打印类的加载情况及对象的回收情况"></a>打印类的加载情况及对象的回收情况</h1><ul>
<li>这个可以通过配置JVM的启动参数，打印这些信息（到屏幕（默认也会到catalina.log中）或者文件），具体参数如下： <ul>
<li>-XX:+PrintGC：输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] </li>
<li>-XX:+PrintGCDetails：输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] </li>
<li>-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用，输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] </li>
<li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds </li>
<li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds </li>
<li>-XX:PrintHeapAtGC: 打印GC前后的详细堆栈信息 </li>
<li>-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析 </li>
<li>-verbose:class 监视加载的类的情况 </li>
<li>-verbose:gc 在虚拟机发生内存回收时在输出设备显示信息 </li>
<li>-verbose:jni 输出native方法调用的相关情况，一般用于诊断jni调用错误信息</li>
</ul>
</li>
</ul>
<h1 id="Tomcat一个请求的完整过程"><a href="#Tomcat一个请求的完整过程" class="headerlink" title="Tomcat一个请求的完整过程"></a>Tomcat一个请求的完整过程</h1><ul>
<li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP&#x2F;1.1 Connector获得 </li>
<li>Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应 </li>
<li>Engine获得请求localhost&#x2F;yy&#x2F;index.jsp，匹配它所拥有的所有虚拟主机Host </li>
<li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机） </li>
<li>localhost Host获得请求&#x2F;yy&#x2F;index.jsp，匹配它所拥有的所有Context </li>
<li>Host匹配到路径为&#x2F;yy的Context（如果匹配不到就把该请求交给路径名为”“的Context去处理） </li>
<li>path&#x3D;”&#x2F;yy”的Context获得请求&#x2F;index.jsp，在它的mapping table中寻找对应的servlet </li>
<li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类 </li>
<li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法 </li>
<li>Context把执行完了之后的HttpServletResponse对象返回给Host </li>
<li>Host把HttpServletResponse对象返回给Engine </li>
<li>Engine把HttpServletResponse对象返回给Connector </li>
<li>Connector把HttpServletResponse对象返回给客户browser</li>
</ul>
<h1 id="Tomcat工作模式？"><a href="#Tomcat工作模式？" class="headerlink" title="Tomcat工作模式？"></a>Tomcat工作模式？</h1><ul>
<li>Tomcat是一个JSP&#x2F;Servlet容器</li>
<li>其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</li>
<li>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：<ul>
<li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li>
<li>Tomcat作为独立服务器：请求来自于web浏览器；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/publishes/c9fa4a3e43dd.html</url>
    <content><![CDATA[<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><ul>
<li>AOP(Aspect-Oriented Programming), 即 面向切面编程</li>
<li>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题</li>
<li>这些交叉问题与应用程序的主要业务逻辑不同</li>
<li>因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。</li>
</ul>
<h1 id="Spring中Bean的⽣命周期。"><a href="#Spring中Bean的⽣命周期。" class="headerlink" title="Spring中Bean的⽣命周期。"></a>Spring中Bean的⽣命周期。</h1><ul>
<li>Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅法-》调⽤InitializationBean的afterPropertiesSet()的⽅法-》调⽤定制的初始化⽅法callCustom的init-method-》调⽤BeanPostProsessor的后初始化⽅法-》Bean可以使⽤了 -》 容器关闭-》 调⽤DisposableBean的destroy⽅法-》调⽤定制的销毁⽅法CallCustom的destroy-method。</li>
<li>Spring对Bean进⾏实例化（相当于程序中的new Xx()）</li>
<li>Spring将值和Bean的引⽤注⼊进Bean对应的属性中</li>
<li>如果Bean实现了BeanNameAware接⼝，Spring将Bean的ID传递给setBeanName()⽅法（实现BeanNameAware清主要是为了通过Bean的引⽤来获得Bean的ID，⼀般业务中是很少有⽤到Bean的ID的）</li>
<li>如果Bean实现了BeanFactoryAware接⼝，Spring将调⽤setBeanDactory(BeanFactory bf)⽅法并把BeanFactory容器实例作为参数传⼊。（实现BeanFactoryAware 主要⽬的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</li>
<li>如果Bean实现了ApplicationContextAwaer接⼝，Spring容器将调⽤setApplicationContext(ApplicationContext ctx)⽅法，把y应⽤上下⽂作为参数传⼊.(作⽤与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调⽤setApplicationContext⽅法时会把它⾃⼰作为setApplicationContext 的参数传⼊，⽽Spring容器在调⽤setBeanDactory前需要程序员⾃⼰指定（注⼊）setBeanDactory⾥的参数BeanFactory )</li>
<li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessBeforeInitialization（预初始化）⽅法（作⽤是在Bean实例创建成功后对进⾏增强处理，如对Bean进⾏修改，增加某个功能）7.如果Bean实现了InitializingBean接⼝，Spring将调⽤它们的afterPropertiesSet⽅法，作⽤与在配置⽂件中对Bean使⽤init-method声明初始化的作⽤⼀样，都是在Bean的全部属性设置成功后执⾏的初始化⽅法。</li>
<li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessAfterInitialization（后初始化）⽅法（作⽤与7的⼀样，只不过7是在Bean初始化前执⾏的，⽽这个是在Bean初始化后执⾏的，时机不同 ）</li>
<li>经过以上的⼯作后，Bean将⼀直驻留在应⽤上下⽂中给应⽤使⽤，直到应⽤上下⽂被销毁</li>
<li>如果Bean实现了DispostbleBean接⼝，Spring将调⽤它的destory⽅法，作⽤与在配置⽂件中对Bean使⽤destory￾method属性的作⽤⼀样，都是在Bean实例销毁前执⾏的⽅法。</li>
</ul>
<h1 id="Spring-AOP解决了什么问题？怎么实现的？"><a href="#Spring-AOP解决了什么问题？怎么实现的？" class="headerlink" title="Spring AOP解决了什么问题？怎么实现的？"></a>Spring AOP解决了什么问题？怎么实现的？</h1><ul>
<li>作⽤<ul>
<li>AOP技术，利⽤⼀种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共⾏为封装到⼀个可重⽤模块，并将其名为“Aspect”，即⽅⾯</li>
<li>所谓“⽅⾯”，简单地说，就是将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li>
</ul>
</li>
<li>实现：<ul>
<li>⼀是采⽤动态代理技术，利⽤截取消息的⽅式，对该消息进⾏装饰，以取代原有对象⾏为的执⾏；</li>
<li>⼆是采⽤静态织⼊的⽅式，引⼊特定的语法创建“⽅⾯”，从⽽使得编译器可以在编译期间织⼊有关“⽅⾯”的代码。</li>
</ul>
</li>
<li>使⽤场景：<ul>
<li>Authentication 权限</li>
<li>Caching 缓存</li>
<li>Context passing 内容传递</li>
<li>Error handling 错误处理</li>
<li>Lazy loading　懒加载</li>
<li>Debugging　　调试</li>
<li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li>
<li>Performance optimization　性能优化</li>
<li>Persistence　　持久化</li>
<li>Resource pooling　资源池</li>
<li>Synchronization　同步</li>
<li>Transactions 事务</li>
</ul>
</li>
<li>⼏个概念：<ul>
<li>切⾯（Aspect）：对象操作过程中的截⾯，这可能是AOP中最为关键的术语。切⾯所要做的事就是专注于各⾃领域的逻辑实现，这样可以使得开发逻辑更加清晰，更加适合专业的分⼯合作。由于切⾯的隔离性，降低了耦合，这样就可以在不同的应⽤中将各个切⾯组合使⽤，从⽽是代码重⽤性⼤⼤增加。</li>
<li>连接点：程序运⾏过程中的某个阶段点，如某个⽅法的调⽤，或者异常的抛出。</li>
<li>处理逻辑（Advice）：在某⼀个连接点所采⽤的处理逻辑，处理逻辑的调⽤模式通常有三种：<ul>
<li>Around 在连接点前后插⼊预处理过程和后处理过程。</li>
<li>Before 仅在连接点钱出⼊处理过程。</li>
<li>Throw 在连接点抛出异常时进⾏异常处理。</li>
</ul>
</li>
<li>切点（PointCut）：⼀系列连接点的集合，它指明处理逻辑将在合适触发。</li>
</ul>
</li>
</ul>
<h1 id="Spring事务的传播属性是怎么回事？它会影响什么？"><a href="#Spring事务的传播属性是怎么回事？它会影响什么？" class="headerlink" title="Spring事务的传播属性是怎么回事？它会影响什么？"></a>Spring事务的传播属性是怎么回事？它会影响什么？</h1><ul>
<li>七个事务传播属性：<ul>
<li>PROPAGATION_REQUIRED – ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。</li>
<li>PROPAGATION_SUPPORTS – ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</li>
<li>PROPAGATION_MANDATORY – ⽀持当前事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATIONREQUIRESNEW – 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>PROPAGATIONNOTSUPPORTED – 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER – 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATIONNESTED – 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与PROPAGATIONREQUIRED类似的操作。</li>
</ul>
</li>
<li>五个隔离级别：<ul>
<li>ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.</li>
<li>另外四个与JDBC的隔离级别相对应：<ul>
<li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种隔离级别会产⽣脏读，不可重复读和幻读。</li>
<li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li>
<li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li>
<li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不可重复读外，还避免了幻读。</li>
</ul>
</li>
</ul>
</li>
<li>关键词：<ul>
<li>幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；</li>
<li>不可重复读：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；</li>
<li>脏读：事务1更新了记录，但没有提交，事务2读取了更新后的⾏，然后事务T1回滚，现在T2读取⽆效。</li>
</ul>
</li>
</ul>
<h1 id="Spring中BeanFactory和FactoryBean有什么区别？"><a href="#Spring中BeanFactory和FactoryBean有什么区别？" class="headerlink" title="Spring中BeanFactory和FactoryBean有什么区别？"></a>Spring中BeanFactory和FactoryBean有什么区别？</h1><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul>
<li>以Factory结尾，表示它是⼀个⼯⼚类(接⼝)，⽤于管理Bean的⼀个⼯⼚</li>
<li>在Spring中，BeanFactory是IOC容器的核⼼接⼝，它的职责包括：实例化、定位、配置应⽤程序中的对象及建⽴这些对象间的依赖。</li>
</ul>
<h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><ul>
<li>以Bean结尾，表示它是⼀个Bean，不同于普通Bean的是：它是实现了FactoryBean接⼝的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽不是FactoryBean本身</li>
<li>如果要获取FactoryBean对象，请在id前⾯加⼀个&amp;符号来获取。</li>
</ul>
<h1 id="Spring框架中IOC的原理是什么？"><a href="#Spring框架中IOC的原理是什么？" class="headerlink" title="Spring框架中IOC的原理是什么？"></a>Spring框架中IOC的原理是什么？</h1><ul>
<li>IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。 </li>
<li>在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</li>
<li>在系统运⾏中，动态的向某个对象提供它所需要的其他对象。 </li>
<li>依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li>
</ul>
<h1 id="spring的依赖注⼊有哪⼏种⽅式"><a href="#spring的依赖注⼊有哪⼏种⽅式" class="headerlink" title="spring的依赖注⼊有哪⼏种⽅式"></a>spring的依赖注⼊有哪⼏种⽅式</h1><ul>
<li>在Spring容器中为⼀个bean配置依赖注⼊有四种⽅式：<ul>
<li>使⽤属性的setter⽅法注⼊ 这是最常⽤的⽅式；</li>
<li>使⽤构造器注⼊；</li>
<li>使⽤Filed注⼊（⽤于注解⽅式）.</li>
<li>静态、实例⼯⼚的⽅法注⼊</li>
</ul>
</li>
</ul>
<h1 id="⽤Spring如何实现⼀个切⾯？"><a href="#⽤Spring如何实现⼀个切⾯？" class="headerlink" title="⽤Spring如何实现⼀个切⾯？"></a>⽤Spring如何实现⼀个切⾯？</h1><ul>
<li>@Aspect</li>
</ul>
<h1 id="Spring如何实现数据库事务？"><a href="#Spring如何实现数据库事务？" class="headerlink" title="Spring如何实现数据库事务？"></a>Spring如何实现数据库事务？</h1><ul>
<li>使⽤@Transactional注解或在配置⽂件⾥⾯配置</li>
</ul>
<h1 id="Spring加载次序Classloader"><a href="#Spring加载次序Classloader" class="headerlink" title="Spring加载次序Classloader"></a>Spring加载次序Classloader</h1><ul>
<li>先构造函数——&gt;然后是bean的set⽅法注⼊——&gt;InitializingBean的afterPropertiesSet⽅法——&gt;init-method⽅法；</li>
<li>InitializingBean接⼝为bean提供了初始化⽅法的⽅式，它只包括afterPropertiesSet⽅法，凡是继承该接⼝的类，在初始化bean的时候会执⾏该⽅法。系统则是先调⽤afterPropertiesSet⽅法，然后在调⽤init-method中指定的⽅法。</li>
<li>Spring装配Bean的过程：<ul>
<li>实例化; </li>
<li>设置属性值; </li>
<li>如果实现了BeanNameAware接⼝,调⽤setBeanName设置Bean的ID或者Name; </li>
<li>如果实现BeanFactoryAware接⼝,调⽤setBeanFactory 设置BeanFactory; </li>
<li>如果实现ApplicationContextAware,调⽤setApplicationContext设置ApplicationContext </li>
<li>调⽤BeanPostProcessor的预先初始化⽅法; </li>
<li>调⽤InitializingBean的afterPropertiesSet()⽅法; </li>
<li>调⽤定制init-method⽅法； </li>
<li>调⽤BeanPostProcessor的后初始化⽅法;</li>
</ul>
</li>
<li>Spring容器关闭过程：<ul>
<li>调⽤DisposableBean的destroy(); </li>
<li>调⽤定制的destroy-method⽅法;</li>
</ul>
</li>
</ul>
<h1 id="IOC控制反转与DI依赖注⼊"><a href="#IOC控制反转与DI依赖注⼊" class="headerlink" title="IOC控制反转与DI依赖注⼊"></a>IOC控制反转与DI依赖注⼊</h1><ul>
<li>IOC控制反转：是⼀种将对象交给容器去控制的设计思想，松耦合，⽅便单元测试，增加功能重⽤性；</li>
<li>DI依赖注⼊：组件之间依赖关系由容器在运⾏期决定，形象的说，即由容器动态的将某个依赖关系注⼊到组件之中。依赖注⼊的⽬的并⾮为软件系统带来更多功能，⽽是为了提升组件重⽤的频率，并为系统搭建⼀个灵活、可扩展的平台。通过依赖注⼊机制，我们只需要通过简单的配置，⽽⽆需任何代码就可指定⽬标需要的资源，完成⾃身的业务逻辑，⽽不需要关⼼具体的资源来⾃何处，由谁实现。</li>
<li>AOP⾯向切⾯编程：⾯向切⾯编程（AOP）完善spring的依赖注⼊（DI）。</li>
</ul>
<h1 id="spring事件的实现原理，写出常⽤的⼏个事件。"><a href="#spring事件的实现原理，写出常⽤的⼏个事件。" class="headerlink" title="spring事件的实现原理，写出常⽤的⼏个事件。"></a>spring事件的实现原理，写出常⽤的⼏个事件。</h1><ul>
<li>事件机制：Spring中的事件机制是⼀个观察者模式的实现，观察者模式就是⼀个⽬标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。</li>
<li>spring默认存在的事件：<ul>
<li>ContextStartedEvent：ApplicationContext启动后触发的事件</li>
<li>ContextStoppedEvent：ApplicationContext停⽌后触发的事件</li>
<li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件</li>
<li>ContextClosedEvent：ApplicationContext关闭后触发的事件</li>
</ul>
</li>
</ul>
<h1 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h1><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h1 id="列举-Spring-Framework-的优点"><a href="#列举-Spring-Framework-的优点" class="headerlink" title="列举 Spring Framework 的优点"></a>列举 Spring Framework 的优点</h1><ul>
<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>
<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>
<li>由于依赖注入和控制反转，JDBC 得以简化。</li>
<li>它是开源免费的。</li>
</ul>
<h1 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h1><ul>
<li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li>
<li>IOC - 控制反转</li>
<li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h1 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h1><ul>
<li>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
</li>
<li>数据访问&#x2F;集成 – 该层提供与数据库交互的支持。它包含以下模块：<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
</li>
<li>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
</li>
<li>AOP – 该层支持面向切面编程<ul>
<li>Instrumentation – 该层为类检测和类加载器实现提供支持。</li>
<li>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</li>
</ul>
</li>
<li>几个杂项模块:<ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
</li>
</ul>
<h1 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h1><ul>
<li>Spring 配置文件是 XML 文件</li>
<li>该文件主要包含类信息</li>
<li>它描述了这些类是如何配置以及相互引入的</li>
<li>但是，XML 配置文件冗长且更加干净</li>
<li>如果没有正确规划和编写，那么在大项目中管理变得非常困难。</li>
</ul>
<h1 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h1><ul>
<li>接口 - 定义功能。</li>
<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>
<li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li>
<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>
<li>用户程序 - 它使用接口。</li>
</ul>
<h1 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h1><ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h1 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h1><ul>
<li>Spring 框架的核心是 Spring 容器</li>
<li>容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期</li>
<li>Spring 容器使用依赖注入来管理组成应用程序的组件</li>
<li>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令</li>
<li>该元数据可以通过 XML，Java 注解或 Java 代码提供。</li>
</ul>
<h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><ul>
<li>在依赖注入中，您不必创建对象，但必须描述如何创建它们</li>
<li>您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务</li>
<li>由 IoC 容器将它们装配在一起。</li>
</ul>
<h1 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h1><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h1 id="列举-IoC-的一些好处。"><a href="#列举-IoC-的一些好处。" class="headerlink" title="列举 IoC 的一些好处。"></a>列举 IoC 的一些好处。</h1><ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h1 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h1><ul>
<li>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</li>
</ul>
<h1 id="什么是-spring-bean？"><a href="#什么是-spring-bean？" class="headerlink" title="什么是 spring bean？"></a>什么是 spring bean？</h1><ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<h1 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h1><ul>
<li>基于 xml 配置<ul>
<li>bean 所需的依赖项和服务在 XML 格式的配置文件中指定</li>
<li>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项</li>
<li>它们通常以 bean 标签开头</li>
</ul>
</li>
<li>基于注解配置<ul>
<li>可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配</li>
<li>默认情况下，Spring 容器中未打开注解装配</li>
<li>因此，您需要在使用它之前在 Spring 配置文件中启用它：<a href="context:annotation-config/">context:annotation-config/</a></li>
</ul>
</li>
<li>基于 Java API 配置<ul>
<li>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h1><ul>
<li>Spring bean 支持 5 种 scope：<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
</li>
<li>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</li>
</ul>
<h1 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h1><ul>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（<bean> 的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（<bean> 的 destroy-method 属性），那么将调用它。</li>
</ul>
<h1 id="什么是-spring-的内部-bean？"><a href="#什么是-spring-的内部-bean？" class="headerlink" title="什么是 spring 的内部 bean？"></a>什么是 spring 的内部 bean？</h1><ul>
<li>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean</li>
<li>为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg> 中提供了 <bean> 元素的使用</li>
<li>内部 bean 总是匿名的，它们总是作为原型。</li>
</ul>
<h1 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h1><ul>
<li>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配</li>
<li>Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</li>
</ul>
<h1 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h1><ul>
<li>Spring 容器能够自动装配 bean</li>
<li>也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</li>
<li>自动装配的不同模式：<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
</li>
</ul>
<h1 id="自动装配有什么局限？"><a href="#自动装配有什么局限？" class="headerlink" title="自动装配有什么局限？"></a>自动装配有什么局限？</h1><ul>
<li>覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h1 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h1><ul>
<li>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身</li>
<li>它可以作为 XML 设置的替代方案。例如：Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul>
<li>@Bean 注解扮演与元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
</li>
</ul>
<h1 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h1><ul>
<li>默认情况下，Spring 容器中未打开注解装配</li>
<li>要使用基于注解装配，我们必须通过配置&lt;context：annotation-config &#x2F;&gt; 元素在 Spring 配置文件中启用它</li>
</ul>
<h1 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h1><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h1 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h1><ul>
<li>Required 应用于 bean 属性 setter 方法</li>
<li>此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性</li>
<li>如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    @Required</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    public string getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h1><ul>
<li>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配</li>
<li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean</li>
<li>默认情况下，它是类型驱动的注入。</li>
</ul>
<h1 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h1><ul>
<li>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</li>
<li>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</li>
</ul>
<h1 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h1><ul>
<li>RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法</li>
<li>此注释可应用于两个级别：<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
</li>
</ul>
<h1 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h1><ul>
<li>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作</li>
<li>这使得用户容易在持久性技术之间切换</li>
<li>它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</li>
</ul>
<h1 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h1><pre><code>- JdbcTemplate
- SimpleJdbcTemplate
- NamedParameterJdbcTemplate
- SimpleJdbcInsert
- SimpleJdbcCall
</code></pre>
<h1 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h1><ul>
<li>我们可以通过两种方式使用 Spring 访问 Hibernate：<ul>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ul>
</li>
</ul>
<h1 id="列举-spring-支持的事务管理类型"><a href="#列举-spring-支持的事务管理类型" class="headerlink" title="列举 spring 支持的事务管理类型"></a>列举 spring 支持的事务管理类型</h1><ul>
<li>Spring 支持两种类型的事务管理：<ul>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ul>
</li>
</ul>
<h1 id="spring-支持哪些-ORM-框架"><a href="#spring-支持哪些-ORM-框架" class="headerlink" title="spring 支持哪些 ORM 框架"></a>spring 支持哪些 ORM 框架</h1><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h1 id="指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h1><ul>
<li>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</li>
<li>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</li>
</ul>
<h1 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h1><ul>
<li>实现 AOP 的技术，主要分为两大类：<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
</ul>
</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h1><ul>
<li>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</li>
<li>Spring AOP 仅支持方法级别的 PointCut；AspectJ 提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</li>
</ul>
<h1 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h1><ul>
<li>将 Advice 应用于目标对象后创建的对象称为代理</li>
<li>在客户端对象的情况下，目标对象和代理对象是相同的。</li>
<li>Advice + Target Object &#x3D; Proxy</li>
</ul>
<h1 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h1><ul>
<li>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）</li>
<li>在 Spring AOP 中，编织在运行时执行</li>
</ul>
<h1 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h1><ul>
<li>WebApplicationContext 是 ApplicationContext 的扩展</li>
<li>它具有 Web 应用程序所需的一些额外功能</li>
<li>它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</li>
</ul>
<h1 id="IoC-和-DI的区别？"><a href="#IoC-和-DI的区别？" class="headerlink" title="IoC 和 DI的区别？"></a>IoC 和 DI的区别？</h1><ul>
<li>IoC 控制反转，指将对象的创建权，反转到Spring容器</li>
<li>DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</li>
</ul>
<p> </p>
<h1 id="BeanFactory-接口和-ApplicationContext-接口有什么区别？"><a href="#BeanFactory-接口和-ApplicationContext-接口有什么区别？" class="headerlink" title="BeanFactory 接口和 ApplicationContext 接口有什么区别？"></a>BeanFactory 接口和 ApplicationContext 接口有什么区别？</h1><ul>
<li>ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。</li>
<li>ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));</span><br><span class="line">IHelloService helloService = (IHelloService) beanFactory.getBean(&quot;helloService&quot;);</span><br><span class="line">helloService.sayHello();</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="spring配置bean实例化有哪些方式？"><a href="#spring配置bean实例化有哪些方式？" class="headerlink" title="spring配置bean实例化有哪些方式？"></a>spring配置bean实例化有哪些方式？</h1><ul>
<li>使用类构造器实例化(默认无参数)</li>
<li>使用静态工厂方法实例化(简单工厂模式)</li>
<li>使用实例工厂方法实例化(工厂方法模式)</li>
</ul>
<h1 id="简单的说一下spring的生命周期？"><a href="#简单的说一下spring的生命周期？" class="headerlink" title="简单的说一下spring的生命周期？"></a>简单的说一下spring的生命周期？</h1><ul>
<li>instantiate bean对象实例化</li>
<li>populate properties 封装属性</li>
<li>如果Bean实现BeanNameAware 执行 setBeanName</li>
<li>如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext</li>
<li>如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)</li>
<li>如果Bean实现InitializingBean 执行 afterPropertiesSet </li>
<li>调用<bean init-method="init"> 指定初始化方法 init</li>
<li>如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization</li>
<li>执行业务处理</li>
<li>如果Bean实现 DisposableBean 执行 destroy</li>
<li>调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy</li>
</ul>
<h1 id="请介绍一下Spring框架中Bean的生命周期和作用域"><a href="#请介绍一下Spring框架中Bean的生命周期和作用域" class="headerlink" title="请介绍一下Spring框架中Bean的生命周期和作用域"></a>请介绍一下Spring框架中Bean的生命周期和作用域</h1><ul>
<li>bean定义：在配置文件里面用<bean></bean>来进行定义。</li>
<li>bean初始化，有两种方式初始化:<ul>
<li>在配置文件中通过指定init-method属性来完成</li>
<li>实现org.springframwork.beans.factory.InitializingBean接口</li>
</ul>
</li>
<li>bean调用：有三种方式可以得到bean实例，并进行调用</li>
<li>bean销毁，销毁有两种方式<ul>
<li>使用配置文件指定的destroy-method属性</li>
<li>实现org.springframwork.bean.factory.DisposeableBean接口</li>
</ul>
</li>
<li>作用域<ul>
<li>singleton：当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</li>
<li>prototype：Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域</li>
<li>request：在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global session：在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</li>
</ul>
</li>
</ul>
<h1 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h1><ul>
<li>BeanFactory：产生一个新的实例，可以实现单例模式</li>
<li>BeanWrapper：提供统一的get及set方法</li>
<li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li>
</ul>
<h1 id="Spring里面applicationContext-xml文件能不能改成其他文件名？"><a href="#Spring里面applicationContext-xml文件能不能改成其他文件名？" class="headerlink" title="Spring里面applicationContext.xml文件能不能改成其他文件名？"></a>Spring里面applicationContext.xml文件能不能改成其他文件名？</h1><ul>
<li>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化</li>
<li>缺省情况下， 它会在WEB-INF&#x2F;applicationContext.xml文件找Spring的配置</li>
<li>你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的位置</li>
</ul>
<p>11.Spring里面如何定义hibernate mapping？ </p>
<ul>
<li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li>
</ul>
<h1 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h1><ul>
<li>Spring使用ThreadLocal解决线程安全问题</li>
<li>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域</li>
<li>就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</li>
<li>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</li>
<li>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量</li>
<li>这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</li>
<li>而ThreadLocal则从另一个角度来解决多线程的并发访问</li>
<li>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突</li>
<li>因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li>
<li>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</li>
<li>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换</li>
<li>但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。</li>
<li>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li>
<li>前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li>
</ul>
<h1 id="介绍一下Spring的事物管理"><a href="#介绍一下Spring的事物管理" class="headerlink" title="介绍一下Spring的事物管理"></a>介绍一下Spring的事物管理</h1><ul>
<li>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</li>
<li>开发中为了避免这种情况一般都会进行事务管理</li>
<li>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能</li>
<li>spring提供了几个关于事务处理的类：<ul>
<li>TransactionDefinition &#x2F;&#x2F;事务属性定义</li>
<li>TranscationStatus &#x2F;&#x2F;代表了当前的事务，可以提交，回滚。</li>
<li>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。</li>
</ul>
</li>
<li>spring提供的事务管理可以分为两类：编程式的和声明式的<ul>
<li>编程式的，比较灵活，但是代码量大，存在重复的代码比较多</li>
<li>声明式的比编程式的更灵活。</li>
</ul>
</li>
<li>编程式主要使用transactionTemplate</li>
<li>省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.</li>
</ul>
<h1 id="AOP-通知有哪些类型？"><a href="#AOP-通知有哪些类型？" class="headerlink" title="AOP 通知有哪些类型？"></a>AOP 通知有哪些类型？</h1><ul>
<li>前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li>
<li>返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li>
<li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li>
<li>后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li>
<li>环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</li>
</ul>
<h1 id="什么是-spring"><a href="#什么是-spring" class="headerlink" title="什么是 spring?"></a>什么是 spring?</h1><ul>
<li>Spring 是个 java 企业级应用的开源开发框架</li>
<li>Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用</li>
<li>Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</li>
</ul>
<h1 id="使用-Spring-框架的好处是什么？"><a href="#使用-Spring-框架的好处是什么？" class="headerlink" title="使用 Spring 框架的好处是什么？"></a>使用 Spring 框架的好处是什么？</h1><ul>
<li>轻量：Spring 是轻量的，基本的版本大约 2MB</li>
<li>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li>
<li>容器：Spring 包含并管理应用中对象的生命周期和配置</li>
<li>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品</li>
<li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</li>
</ul>
<h1 id="ApplicationContext-通常的实现是什么？"><a href="#ApplicationContext-通常的实现是什么？" class="headerlink" title="ApplicationContext 通常的实现是什么？"></a>ApplicationContext 通常的实现是什么？</h1><ul>
<li>FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li>
<li>ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找bean 配置。</li>
<li>WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个WEB 应用的所有 bean。</li>
</ul>
<h1 id="一个-Spring-的应用看起来象什么？"><a href="#一个-Spring-的应用看起来象什么？" class="headerlink" title="一个 Spring 的应用看起来象什么？"></a>一个 Spring 的应用看起来象什么？</h1><ul>
<li>一个定义了一些功能的接口</li>
<li>这实现包括属性，它的 Setter ， getter 方法和函数等</li>
<li>Spring AOP</li>
<li>Spring 的 XML 配置文件</li>
<li>使用以上功能的客户端程序</li>
</ul>
<h1 id="哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？"><a href="#哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？" class="headerlink" title="哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？"></a>哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？</h1><ul>
<li>你两种依赖方式都可以使用，构造器注入和 Setter 方法注入</li>
<li>最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。</li>
</ul>
<h1 id="什么是-Spring-beans？"><a href="#什么是-Spring-beans？" class="headerlink" title="什么是 Spring beans？"></a>什么是 Spring beans？</h1><ul>
<li>Spring beans 是那些形成 Spring 应用的主干的 java 对象</li>
<li>它们被 Spring IOC 容器初始化，装配，和管理</li>
<li>这些 beans 通过容器中配置的元数据创建</li>
<li>比如，以 XML文件中<bean/> 的形式定义。</li>
<li>Spring 框架定义的 beans 都是单件 beans</li>
<li>在 bean tag 中有个属性”singleton”，如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean</li>
<li>默认是TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件</li>
</ul>
<h1 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h1><ul>
<li>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</li>
</ul>
<h1 id="如何给-Spring-容器提供配置元数据？"><a href="#如何给-Spring-容器提供配置元数据？" class="headerlink" title="如何给 Spring 容器提供配置元数据？"></a>如何给 Spring 容器提供配置元数据？</h1><ul>
<li>这里有三种重要的方法给 Spring 容器提供配置元数据。<ul>
<li>XML 配置文件。</li>
<li>基于注解的配置。</li>
<li>基于 java 的配置。</li>
</ul>
</li>
</ul>
<h1 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h1><ul>
<li>当定义一个<bean> 在 Spring 里，我们还能给这个 bean 声明一个作用域</li>
<li>它可以通过bean定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope属性必须设为singleton。</li>
</ul>
<h1 id="Spring-框架中的单例-bean-是线程安全的吗？"><a href="#Spring-框架中的单例-bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 bean 是线程安全的吗？"></a>Spring 框架中的单例 bean 是线程安全的吗？</h1><ul>
<li>不，Spring 框架中的单例 bean 不是线程安全的。</li>
</ul>
<h1 id="哪些是重要的-bean-生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的-bean-生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的 bean 生命周期方法？ 你能重载它们吗？"></a>哪些是重要的 bean 生命周期方法？ 你能重载它们吗？</h1><p>有- 两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时候被调用</p>
<ul>
<li>第二个方法是 teardown 它是在容器卸载类的时候被调用。</li>
<li>The bean 标签有两个重要的属性（init-method 和 destroy-method）</li>
<li>用它们你可 以 自 己 定 制 初 始 化 和 注 销 方 法</li>
<li>它 们 也 有 相 应 的 注 解 （ @PostConstruct 和@PreDestroy）。</li>
</ul>
<h1 id="在-Spring-中如何注入一个-java-集合？"><a href="#在-Spring-中如何注入一个-java-集合？" class="headerlink" title="在 Spring 中如何注入一个 java 集合？"></a>在 Spring 中如何注入一个 java 集合？</h1><ul>
<li>Spring 提供以下几种集合的配置元素：<ul>
<li><list>类型用于注入一列值，允许有相同的值。</li>
<li><set> 类型用于注入一组值，不允许有相同的值。</li>
<li><map> 类型用于注入一组键值对，键和值都可以为任意类型。</li>
<li><props>类型用于注入一组键值对，键和值都只能为 String 类型。</li>
</ul>
</li>
</ul>
<h1 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h1><ul>
<li>自动装配的局限性是：<ul>
<li>重写：你仍需用 <constructor-arg>和 <property> 配置来定义依赖，意味着总要重写自动装配。</li>
<li>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。</li>
<li>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li>
</ul>
</li>
</ul>
<h1 id="你可以在-Spring-中注入一个-null-和一个空字符串吗？"><a href="#你可以在-Spring-中注入一个-null-和一个空字符串吗？" class="headerlink" title="你可以在 Spring 中注入一个 null 和一个空字符串吗？"></a>你可以在 Spring 中注入一个 null 和一个空字符串吗？</h1><ul>
<li>可以。 Spring 注解</li>
</ul>
<h1 id="在-Spring-框架中如何更有效地使用-JDBC？"><a href="#在-Spring-框架中如何更有效地使用-JDBC？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC？"></a>在 Spring 框架中如何更有效地使用 JDBC？</h1><ul>
<li>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻</li>
<li>所以开发者只需写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</li>
<li>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li>
</ul>
<h1 id="Spring-对-DAO-的支持"><a href="#Spring-对-DAO-的支持" class="headerlink" title="Spring 对 DAO 的支持"></a>Spring 对 DAO 的支持</h1><ul>
<li>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，Hibernate or JDO 结合使用</li>
<li>这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</li>
</ul>
<h1 id="如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？"><a href="#如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？" class="headerlink" title="如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？"></a>如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</h1><ul>
<li>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul>
<li>配置 the Hibernate SessionFactory</li>
<li>继承 HibernateDaoSupport 实现一个 DAO</li>
<li>在 AOP 支持的事务中装配</li>
</ul>
</li>
</ul>
<h1 id="如何在spring的applicationContext-xml使用JNDI而不是DataSource"><a href="#如何在spring的applicationContext-xml使用JNDI而不是DataSource" class="headerlink" title="如何在spring的applicationContext.xml使用JNDI而不是DataSource"></a>如何在spring的applicationContext.xml使用JNDI而不是DataSource</h1><ul>
<li>可以使用”org.springframework.jndi.JndiObjectFactoryBean”来实现</li>
</ul>
<h1 id="在spring中是如何配置数据库驱动的"><a href="#在spring中是如何配置数据库驱动的" class="headerlink" title="在spring中是如何配置数据库驱动的"></a>在spring中是如何配置数据库驱动的</h1><ul>
<li>org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动</li>
</ul>
<h1 id="在web中如何配置spring"><a href="#在web中如何配置spring" class="headerlink" title="在web中如何配置spring"></a>在web中如何配置spring</h1><ul>
<li>在J2EE的web应用里面配置spring非常简单，最简单的只需要把spring得ContextLoaderListener添加到你的web.xml文件里面就可以了</li>
</ul>
<h1 id="在spring中如何定义hibernate-Mapping？"><a href="#在spring中如何定义hibernate-Mapping？" class="headerlink" title="在spring中如何定义hibernate Mapping？"></a>在spring中如何定义hibernate Mapping？</h1><ul>
<li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li>
</ul>
<h1 id="如何配置spring-struts？"><a href="#如何配置spring-struts？" class="headerlink" title="如何配置spring + struts？"></a>如何配置spring + struts？</h1><ul>
<li>在struts-config.xml加入一个插件，通过它加载applicationContext.xml</li>
<li>在struts-config.xml修改action-mapping标记，具体action交给了DelegateActionProxy</li>
<li>通过DelegateActionProxy进入一spring的环境。</li>
<li>在spring的applicationContext.xml加入<bean name=”/login” class=”“ singleton=”false”/></li>
</ul>
<h1 id="如何在spring中实现国际化"><a href="#如何在spring中实现国际化" class="headerlink" title="如何在spring中实现国际化?"></a>如何在spring中实现国际化?</h1><ul>
<li>在applicationContext.xml加载一个bean org.springframework.context.support.ResourceBundleMessageSource</li>
<li>在src目录下建多个properties文件</li>
<li>对于非英文的要用native2ascii -encoding gb2312 源目转化文件相关内容</li>
<li>其命名格式是message_语言_国家。</li>
<li>页面中的中显示提示信息，键名取键值。</li>
<li>当给定国家，系统会自动加载对应的国家的properties信息。</li>
<li>通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。</li>
</ul>
<h1 id="在spring中如何实现事件处理"><a href="#在spring中如何实现事件处理" class="headerlink" title="在spring中如何实现事件处理"></a>在spring中如何实现事件处理</h1><ul>
<li>事件 Extends ApplicationEvent</li>
<li>监听器 Implements ApplicationListener</li>
<li>事件源 Implements ApplicationContextAware</li>
<li>在applicationContext.xml中配置事件源、监听器</li>
<li>先得到事件源，调用事件源的方法，通知监听器。</li>
</ul>
<h1 id="如何将spring加入web容器中"><a href="#如何将spring加入web容器中" class="headerlink" title="如何将spring加入web容器中"></a>如何将spring加入web容器中</h1><ul>
<li>在web.xml中加入如下同容,在启动web服务器时加载&#x2F;WEB-INF&#x2F;applicationContext.xml中的内容。</li>
</ul>
<h1 id="Spring如何实现资源管理"><a href="#Spring如何实现资源管理" class="headerlink" title="Spring如何实现资源管理?"></a>Spring如何实现资源管理?</h1><ul>
<li>使用<ul>
<li>applicationContext.getResource(“classpath:文件名”):在src根目录下，在类路径下</li>
<li>applicationContext.getResource(“classpath:&#x2F;chap01&#x2F;文件名”): 以src根目录下的基准往下走。</li>
<li>applicationContext.getResource(“file:c:&#x2F;a.properties”)：在系统文件目录下。</li>
</ul>
</li>
</ul>
<h1 id="Spring的ApplicationContext的作用"><a href="#Spring的ApplicationContext的作用" class="headerlink" title="Spring的ApplicationContext的作用?"></a>Spring的ApplicationContext的作用?</h1><ul>
<li>beanFactory</li>
<li>国际化(getMesage)</li>
<li>资源管理:可以直接读取一个文件的内容(getResource)</li>
<li>加入web框架中(加入一个servlet或监听器)</li>
<li>事件处理</li>
</ul>
<h1 id="Hibernate工作原理及为什么要用？"><a href="#Hibernate工作原理及为什么要用？" class="headerlink" title="Hibernate工作原理及为什么要用？"></a>Hibernate工作原理及为什么要用？</h1><ul>
<li>原理：<ul>
<li>读取并解析配置文件</li>
<li>读取并解析映射信息，创建SessionFactory</li>
<li>打开Sesssion</li>
<li>创建事务Transation</li>
<li>持久化操作</li>
<li>提交事务</li>
<li>关闭Session</li>
<li>关闭SesstionFactory</li>
</ul>
</li>
<li>为什么要用：<ul>
<li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li>
<li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li>
<li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li>
<li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li>
</ul>
</li>
<li>Hibernate是如何延迟加载?<ul>
<li>Hibernate2延迟加载实现：a)实体对象  b)集合（Collection）</li>
<li>Hibernate3 提供了属性的延迟加载功能</li>
</ul>
</li>
<li>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</li>
<li>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)<ul>
<li>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</li>
</ul>
</li>
<li>说下Hibernate的缓存机制<ul>
<li>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</li>
<li>二级缓存：<ul>
<li>应用及缓存</li>
<li>分布式缓存<ul>
<li>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据</li>
</ul>
</li>
</ul>
</li>
<li>第三方缓存的实现</li>
</ul>
</li>
<li>Hibernate的查询方式<ul>
<li>Sql、Criteria,object comptosition</li>
<li>Hql：<ul>
<li>属性查询</li>
<li>参数查询、命名参数查询</li>
<li>关联查询</li>
<li>分页查询</li>
<li>统计函数</li>
</ul>
</li>
</ul>
</li>
<li>如何优化Hibernate？<ul>
<li>使用双向一对多关联，不使用单向一对多</li>
<li>灵活使用单向一对多关联</li>
<li>不用一对一，用多对一取代</li>
<li>配置对象缓存，不使用集合缓存</li>
<li>一对多集合使用Bag,多对多集合使用Set</li>
<li>继承类使用显式多态</li>
<li>表字段要少，表关联不要怕多，有二级缓存撑腰</li>
</ul>
</li>
</ul>
<h1 id="Spring中如何获取bean"><a href="#Spring中如何获取bean" class="headerlink" title="Spring中如何获取bean"></a>Spring中如何获取bean</h1><ul>
<li>通过xml配置文件</li>
<li>bean配置在xml里面，spring提供多种方式读取配置文件得到ApplicationContext.<ul>
<li>第一种方式：FileSystemXmlApplicationContext通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例:<ul>
<li>ApplicationContext ac &#x3D; new FileSystemXmlApplicationContext(”applicationContext.xml”)</li>
<li>ac.getBean(”beanName”);</li>
</ul>
</li>
<li>第二种方式：WebApplicationContextUtil在B&#x2F;S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext.例如：<ul>
<li>ApplicationContext ctx &#x3D; WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);</li>
<li>ApplicationContext ctx &#x3D;   WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</li>
<li>其中 servletContext sc 可以具体 换成 servlet.getServletContext()或者 this.getServletContext() 或者 request.getSession().getServletContext();</li>
<li>另外，由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象：</li>
<li>WebApplicationContext webApplicationContext &#x3D; (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Spring框架中的单例Beans是线程安全的么？"><a href="#Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="Spring框架中的单例Beans是线程安全的么？"></a>Spring框架中的单例Beans是线程安全的么？</h1><ul>
<li>Spring框架并没有对单例bean进行任何多线程的封装处理</li>
<li>关于单例bean的线程安全和并发问题需要开发者自行去搞定</li>
<li>但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的</li>
<li>如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。</li>
<li>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</li>
</ul>
<h1 id="如何向Spring-Bean中注入一个Java-util-Properties？"><a href="#如何向Spring-Bean中注入一个Java-util-Properties？" class="headerlink" title="如何向Spring Bean中注入一个Java.util.Properties？"></a>如何向Spring Bean中注入一个Java.util.Properties？</h1><ul>
<li>第一种方法是使用如下面代码所示的<props> 标签</li>
<li>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。</li>
</ul>
<h1 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h1><ul>
<li>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</li>
<li>我们可以创建bean用来监听在ApplicationContext 中发布的事件</li>
<li>ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li>
<li>Spring 提供了以下5中标准的事件：<ul>
<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li>
</ul>
</li>
<li>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。为了监听这个事件，还需要创建一个监听器，之后通过applicationContext接口的publishEvent()方法来发布自定义事件。</li>
</ul>
<h1 id="FileSystemResource和ClassPathResource有何区别？"><a href="#FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="FileSystemResource和ClassPathResource有何区别？"></a>FileSystemResource和ClassPathResource有何区别？</h1><ul>
<li>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径</li>
<li>在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。</li>
<li>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</li>
<li>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</li>
</ul>
<h1 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h1><ul>
<li>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：<ul>
<li>代理模式—在AOP和remoting中被用的比较多。</li>
<li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li>
<li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li>
<li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入—贯穿于BeanFactory &#x2F; ApplicationContext接口的核心理念。</li>
<li>工厂模式—BeanFactory用来创建对象的实例</li>
</ul>
</li>
</ul>
<p> </p>
<h1 id="开发中主要使用-Spring-的什么技术"><a href="#开发中主要使用-Spring-的什么技术" class="headerlink" title="开发中主要使用 Spring 的什么技术 ?"></a>开发中主要使用 Spring 的什么技术 ?</h1><ul>
<li>IOC 容器管理各层的组件</li>
<li>使用 AOP 配置声明式事务</li>
<li>整合其他框架</li>
</ul>
<h1 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h1><ul>
<li>大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</li>
</ul>
<h1 id="Spring-框架的事务管理有哪些优点？"><a href="#Spring-框架的事务管理有哪些优点？" class="headerlink" title="Spring 框架的事务管理有哪些优点？"></a>Spring 框架的事务管理有哪些优点？</h1><ul>
<li>它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供一个不变的编程模式。</li>
<li>它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API</li>
<li>它支持声明式事务管理。</li>
<li>它和 Spring 各种数据访问抽象层很好得集成。</li>
</ul>
<h1 id="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h1><ul>
<li>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul>
<li>配置 the Hibernate SessionFactory。</li>
<li>继承 HibernateDaoSupport 实现一个 DAO。</li>
<li>在 AOP 支持的事务中装配。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/publishes/554d7a59d68c.html</url>
    <content><![CDATA[<h1 id="zookeeper-都有哪些使用场景？"><a href="#zookeeper-都有哪些使用场景？" class="headerlink" title="zookeeper 都有哪些使用场景？"></a>zookeeper 都有哪些使用场景？</h1><ul>
<li>大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：<ul>
<li>分布式协调</li>
<li>分布式锁</li>
<li>元数据&#x2F;配置信息管理</li>
<li>HA高可用性</li>
</ul>
</li>
</ul>
<h4 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h4><ul>
<li>这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</li>
</ul>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul>
<li>对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</li>
</ul>
<h4 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据&#x2F;配置信息管理"></a>元数据&#x2F;配置信息管理</h4><ul>
<li>ookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？</li>
</ul>
<h4 id="HA高可用性"><a href="#HA高可用性" class="headerlink" title="HA高可用性"></a>HA高可用性</h4><ul>
<li>这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个重要进程一般会做主备两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。</li>
</ul>
<h1 id="什么是-ZooKeeper"><a href="#什么是-ZooKeeper" class="headerlink" title="什么是 ZooKeeper"></a>什么是 ZooKeeper</h1><h4 id="ZooKeeper-的由来"><a href="#ZooKeeper-的由来" class="headerlink" title="ZooKeeper 的由来"></a>ZooKeeper 的由来</h4><ul>
<li>Zookeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。</li>
</ul>
<h4 id="ZooKeeper-概览"><a href="#ZooKeeper-概览" class="headerlink" title="ZooKeeper 概览"></a>ZooKeeper 概览</h4><ul>
<li>ZooKeeper 是一个开源的分布式协调服务，ZooKeeper框架最初是在“Yahoo!”上构建的，用于以简单而稳健的方式访问他们的应用程序。 后来，Apache ZooKeeper成为Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 例如，Apache HBase使用ZooKeeper跟踪分布式数据的状态</li>
<li>ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</li>
<li>原语： 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</li>
<li>ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</li>
<li>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。</li>
</ul>
<h4 id="结合个人使用情况的讲一下-ZooKeeper"><a href="#结合个人使用情况的讲一下-ZooKeeper" class="headerlink" title="结合个人使用情况的讲一下 ZooKeeper"></a>结合个人使用情况的讲一下 ZooKeeper</h4><ul>
<li>在我自己做过的项目中，主要使用到了 ZooKeeper 作为 Dubbo 的注册中心(Dubbo 官方推荐使用 ZooKeeper注册中心)。</li>
<li>另外在搭建 solr 集群的时候，我使用 ZooKeeper 作为 solr 集群的管理工具。这时，ZooKeeper 主要提供下面几个功能：<ul>
<li>集群管理：容错、负载均衡</li>
<li>配置文件的集中管理</li>
<li>集群的入口</li>
</ul>
</li>
<li>我个人觉得在使用 ZooKeeper 的时候，最好是使用 集群版的 ZooKeeper 而不是单机版的。官网给出的架构图就描述的是一个集群版的 ZooKeeper 。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。</li>
</ul>
<h1 id="为什么最好使用奇数台服务器构成-ZooKeeper-集群？"><a href="#为什么最好使用奇数台服务器构成-ZooKeeper-集群？" class="headerlink" title="为什么最好使用奇数台服务器构成 ZooKeeper 集群？"></a>为什么最好使用奇数台服务器构成 ZooKeeper 集群？</h1><ul>
<li>我们知道在Zookeeper中 Leader 选举算法采用了Zab协议</li>
<li>Zab核心思想是当多数 Server 写成功，则任务数据写成功<ul>
<li>如果有3个Server，则最多允许1个Server 挂掉。</li>
<li>如果有4个Server，则同样最多允许1个Server挂掉。</li>
<li>既然3个或者4个Server，同样最多允许1个Server挂掉，那么它们的可靠性是一样的，所以选择奇数个ZooKeeper Server即可，这里选择3个Server。</li>
</ul>
</li>
</ul>
<h1 id="关于-ZooKeeper-的一些重要概念"><a href="#关于-ZooKeeper-的一些重要概念" class="headerlink" title="关于 ZooKeeper 的一些重要概念"></a>关于 ZooKeeper 的一些重要概念</h1><h4 id="重要概念总结"><a href="#重要概念总结" class="headerlink" title="重要概念总结"></a>重要概念总结</h4><ul>
<li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li>
<li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li>
<li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。</li>
<li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li>
<li>ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。</li>
<li>ZooKeeper 底层其实只提供了两个功能：<ul>
<li>管理（存储、读取）用户程序提交的数据；</li>
<li>为用户程序提交数据节点监听服务。</li>
</ul>
</li>
</ul>
<h4 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h4><ul>
<li>Session 指的是 ZooKeeper 服务器与客户端会话</li>
<li>在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接</li>
<li>客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</li>
<li>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</li>
</ul>
<h4 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h4><ul>
<li>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然而，在Zookeeper中，“节点”分为两类<ul>
<li>第一类同样是指构成集群的机器，我们称之为机器节点</li>
<li>第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</li>
</ul>
</li>
<li>Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree），由斜杠（&#x2F;）的进行分割的路径，就是一个Znode，例如&#x2F;foo&#x2F;path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</li>
<li>在Zookeeper中，node可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</li>
</ul>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><ul>
<li>在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 cversion（当前ZNode的ACL版本）。</li>
</ul>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><ul>
<li>Watcher（事件监听器），是Zookeeper中的一个很重要的特性</li>
<li>Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。</li>
</ul>
<h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><ul>
<li>Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</li>
<li>Zookeeper 定义了5种权限。</li>
<li>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</li>
</ul>
<h1 id="ZooKeeper-特点"><a href="#ZooKeeper-特点" class="headerlink" title="ZooKeeper 特点"></a>ZooKeeper 特点</h1><ul>
<li>顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>
<li>原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li>单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li>可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ul>
<h1 id="ZooKeeper-设计目标"><a href="#ZooKeeper-设计目标" class="headerlink" title="ZooKeeper 设计目标"></a>ZooKeeper 设计目标</h1><h4 id="简单的数据模型"><a href="#简单的数据模型" class="headerlink" title="简单的数据模型"></a>简单的数据模型</h4><ul>
<li>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似</li>
<li>名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录</li>
<li>与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。</li>
</ul>
<h4 id="可构建集群"><a href="#可构建集群" class="headerlink" title="可构建集群"></a>可构建集群</h4><ul>
<li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的</li>
<li>客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。</li>
<li>组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信</li>
<li>集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。</li>
</ul>
<h4 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h4><ul>
<li>对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。这个编号也叫做时间戳——zxid（Zookeeper Transaction Id）</li>
</ul>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><ul>
<li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li>
</ul>
<h1 id="ZooKeeper-集群角色介绍"><a href="#ZooKeeper-集群角色介绍" class="headerlink" title="ZooKeeper 集群角色介绍"></a>ZooKeeper 集群角色介绍</h1><ul>
<li>最典型集群模式： Master&#x2F;Slave 模式（主备模式）。在这种模式中，通常 Master服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</li>
<li>在 ZooKeeper 中没有选择传统的 Master&#x2F;Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色。</li>
<li>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器</li>
<li>Leader 既可以为客户端提供写服务又能提供读服务</li>
<li>除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</li>
</ul>
<h1 id="ZooKeeper-ZAB-协议-Paxos算法"><a href="#ZooKeeper-ZAB-协议-Paxos算法" class="headerlink" title="ZooKeeper &amp;ZAB 协议&amp;Paxos算法"></a>ZooKeeper &amp;ZAB 协议&amp;Paxos算法</h1><h4 id="ZAB-协议-Paxos算法"><a href="#ZAB-协议-Paxos算法" class="headerlink" title="ZAB 协议&amp;Paxos算法"></a>ZAB 协议&amp;Paxos算法</h4><ul>
<li>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</li>
</ul>
<h4 id="ZAB-协议介绍"><a href="#ZAB-协议介绍" class="headerlink" title="ZAB 协议介绍"></a>ZAB 协议介绍</h4><ul>
<li>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议</li>
<li>在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</li>
</ul>
<h4 id="ZAB-协议两种基本的模式：崩溃恢复和消息广播"><a href="#ZAB-协议两种基本的模式：崩溃恢复和消息广播" class="headerlink" title="ZAB 协议两种基本的模式：崩溃恢复和消息广播"></a>ZAB 协议两种基本的模式：崩溃恢复和消息广播</h4><ul>
<li>ZAB协议包括两种基本的模式，分别是 崩溃恢复和消息广播</li>
<li>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器</li>
<li>当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式</li>
<li>其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</li>
<li>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了</li>
<li>当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去</li>
<li>正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理</li>
<li>Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</li>
</ul>
<h1 id="Znode-节点类型有哪些？"><a href="#Znode-节点类型有哪些？" class="headerlink" title="Znode 节点类型有哪些？"></a>Znode 节点类型有哪些？</h1><ul>
<li>PERSISTENT 持久化节点: 所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点。否则不会因为创建该节点的客户端会话失效而消失。</li>
<li>PERSISTENT_SEQUENTIAL 持久顺序节点：这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在 ZK 中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK 会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 在创建节点的时候只需要传入节点 “&#x2F;test_”，这样之后，zookeeper 自动会给”test_”后面补充数字。</li>
<li>EPHEMERAL 临时节点：和持久节点不同的是，临时节点的生命周期和客户端会 话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。这里还要注意一件事，就是当你客户端会话失效后，所产生的节点也不是一下子就消失了，也要过一段时间，大概是 10 秒以内，可以试一下，本机操作生成节点，在服务器端用命令来查看当前的节点数目，你会发现客户端已经 stop，但是产生的节点还在。</li>
<li>EPHEMERAL_SEQUENTIAL 临时自动编号节点：此节点是属于临时节点，不过带有顺序，客户端会话结束节点就消失。</li>
</ul>
<h1 id="什么是-Znode？"><a href="#什么是-Znode？" class="headerlink" title="什么是 Znode？"></a>什么是 Znode？</h1><ul>
<li>在 Zookeeper 中，znode 是一个跟 Unix 文件系统路径相似的节点，可以往这个节点存储或获取数据。</li>
<li>Zookeeper 底层是一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为“znode”</li>
<li>zookeeper 中的数据是按照“树”结构进行存储的。而且 znode 节点还分为 4 中不同的类型。</li>
<li>每一个 znode 默认能够存储 1MB 的数据（对于记录状态性质的数据来说，够了）</li>
<li>可以使用 zkCli 命令，登录到 zookeeper 上，并通过 ls、create、delete、get、set等命令操作这些 znode 节点</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎</title>
    <url>/publishes/372274a5b315.html</url>
    <content><![CDATA[<h1 id="lucene-和-es"><a href="#lucene-和-es" class="headerlink" title="lucene 和 es"></a>lucene 和 es</h1><ul>
<li>lucene 是最先进、功能最强大的搜索库</li>
<li>如果直接基于 lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。</li>
<li>elasticsearch 基于 lucene，隐藏了 lucene 的复杂性，提供了简单易用的 restful api &#x2F; Java api 接口（另外还有其他语言的 api 接口）<ul>
<li>分布式的文档存储引擎</li>
<li>分布式的搜索引擎和分析引擎</li>
<li>分布式，支持 PB 级数据</li>
</ul>
</li>
</ul>
<h1 id="es-的核心概念"><a href="#es-的核心概念" class="headerlink" title="es 的核心概念"></a>es 的核心概念</h1><h4 id="Near-Realtime"><a href="#Near-Realtime" class="headerlink" title="Near Realtime"></a>Near Realtime</h4><ul>
<li>近实时，有两层意思：<ul>
<li>从写入数据到数据可以被搜索到有一个小延迟（大概是 1s）</li>
<li>基于 es 执行搜索和分析可以达到秒级</li>
</ul>
</li>
</ul>
<h4 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h4><ul>
<li>集群包含多个节点，每个节点属于哪个集群都是通过一个配置来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常。</li>
</ul>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><ul>
<li>Node 是集群中的一个节点，节点也有一个名称，默认是随机分配的。默认节点会去加入一个名称为 elasticsearch 的集群。</li>
<li>如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。</li>
</ul>
<h4 id="Document-field"><a href="#Document-field" class="headerlink" title="Document &amp; field"></a>Document &amp; field</h4><ul>
<li>文档是 es 中最小的数据单元，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据，通常用 json 数据结构来表示。</li>
<li>每个 index 下的 type，都可以存储多条 document。一个 document 里面有多个 field，每个 field 就是一个数据字段。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;product_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;product_name&quot;: &quot;iPhone X&quot;,</span><br><span class="line">    &quot;product_desc&quot;: &quot;苹果手机&quot;,</span><br><span class="line">    &quot;category_id&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;category_name&quot;: &quot;电子产品&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><ul>
<li>索引包含了一堆有相似结构的文档数据，比如商品索引<br>一个索引包含很多 document，一个索引就代表了一类相似或者相同的 ducument。</li>
</ul>
<h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><ul>
<li>类型，每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。</li>
<li>每个 type 下的 document 的 field 可能不太一样。</li>
</ul>
<h4 id="shard"><a href="#shard" class="headerlink" title="shard"></a>shard</h4><ul>
<li>单台机器无法存储大量数据，es 可以将一个索引中的数据切分为多个 shard，分布在多台服务器上存储</li>
<li>有了 shard 就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能</li>
<li>每个 shard 都是一个 lucene index。</li>
</ul>
<h4 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h4><ul>
<li>任何一个服务器随时可能故障或宕机，此时 shard 可能就会丢失，因此可以为每个 shard 创建多个 replica 副本。</li>
<li>replica 可以在 shard 故障时提供备用服务，保证数据不丢失，多个 replica 还可以提升搜索操作的吞吐量和性能。</li>
<li>primary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5个 replica shard，最小的高可用配置，是 2 台服务器。</li>
<li>这么说吧，shard 分为 primary shard 和 replica shard。而 primary shard 一般简称为 shard，而 replica shard 一般简称为 replica。</li>
</ul>
<h1 id="es-核心概念-vs-db-核心概念"><a href="#es-核心概念-vs-db-核心概念" class="headerlink" title="es 核心概念 vs. db 核心概念"></a>es 核心概念 vs. db 核心概念</h1><ul>
<li>es	dbindex	数据库type	数据表docuemnt	一行数据以上是一个简单的类比。</li>
</ul>
<h1 id="es-的分布式架构原理能说一下么（es-是如何实现分布式的啊）？"><a href="#es-的分布式架构原理能说一下么（es-是如何实现分布式的啊）？" class="headerlink" title="es 的分布式架构原理能说一下么（es 是如何实现分布式的啊）？"></a>es 的分布式架构原理能说一下么（es 是如何实现分布式的啊）？</h1><ul>
<li>ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 lucene 的。</li>
<li>核心思想就是在多台机器上启动多个 es 进程实例，组成了一个 es 集群。</li>
<li>es 中存储数据的基本单位是索引，比如说你现在要在 es 中存储一些订单数据，你就应该在 es 中创建一个索引 order_idx，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一张表。</li>
<li>index -&gt; type -&gt; mapping -&gt; document -&gt; field。</li>
<li>index 相当于 mysql 里的一张表。而 type 没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。假设有一个 index，是订单 index，里面专门是放订单数据的。就好比说你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。<br>所以就会在订单 index 里，建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。</li>
<li>很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（注意，mapping types这个概念在 ElasticSearch 7.X 已被完全移除，详细说明可以参考官方文档），你可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的表结构定义，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。</li>
<li>你搞一个索引，这个索引可以拆分成多个 shard，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是支持横向扩展，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是提高性能，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 primary shard，负责写入数据，但是还有几个 replica shard。primary shard 写入数据之后，会将数据同步到其他几个 replica shard 上去。</li>
<li>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</li>
<li>es 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</li>
<li>如果是非 master节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</li>
<li>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</li>
</ul>
<h1 id="es-写入数据的工作原理是什么啊？es-查询数据的工作原理是什么啊？底层的-lucene-介绍一下呗？倒排索引了解吗？"><a href="#es-写入数据的工作原理是什么啊？es-查询数据的工作原理是什么啊？底层的-lucene-介绍一下呗？倒排索引了解吗？" class="headerlink" title="es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？"></a>es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？</h1><h4 id="es-写数据过程"><a href="#es-写数据过程" class="headerlink" title="es 写数据过程"></a>es 写数据过程</h4><ul>
<li>客户端选择一个 node 发送请求过去，这个 node 就是 coordinating node（协调节点）。</li>
<li>coordinating node 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li>
<li>实际的 node 上的 primary shard 处理请求，然后将数据同步到 replica node。</li>
<li>coordinating node 如果发现 primary node 和所有 replica node 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<h4 id="es-读数据过程"><a href="#es-读数据过程" class="headerlink" title="es 读数据过程"></a>es 读数据过程</h4><ul>
<li>可以通过 doc id 来查询，会根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询。</li>
<li>客户端发送请求到任意一个 node，成为 coordinate node。</li>
<li>coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 coordinate node。</li>
<li>coordinate node 返回 document 给客户端。</li>
</ul>
<h4 id="es-搜索数据过程"><a href="#es-搜索数据过程" class="headerlink" title="es 搜索数据过程"></a>es 搜索数据过程</h4><ul>
<li>es 最强大的是做全文检索，就是比如你有三条数据：<ul>
<li>java真好玩儿啊</li>
<li>java好难学啊</li>
<li>j2ee特别牛</li>
</ul>
</li>
<li>你根据 java 关键词来搜索，将包含 java的 document 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</li>
<li>客户端发送请求到一个 coordinate node。</li>
<li>协调节点将搜索请求转发到所有的 shard 对应的 primary shard 或 replica shard，都可以。</li>
<li>query phase：每个 shard 将自己的搜索结果（其实就是一些 doc id）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>
<li>fetch phase：接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端。</li>
<li>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</li>
</ul>
<h4 id="写数据底层原理"><a href="#写数据底层原理" class="headerlink" title="写数据底层原理"></a>写数据底层原理</h4><ul>
<li>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</li>
<li>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file 中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache 。这个过程就是 refresh。</li>
<li>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file，每秒钟会产生一个新的磁盘文件 segment file，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。</li>
<li>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</li>
<li>操作系统里面，磁盘文件其实都有一个东西，叫做 os cache，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache，先进入操作系统级别的一个内存缓存中去。只要 buffer 中的数据被 refresh 操作刷入 os cache中，这个数据就可以被搜索到了。</li>
</ul>
<h5 id="为什么叫-es-是准实时的？"><a href="#为什么叫-es-是准实时的？" class="headerlink" title="为什么叫 es 是准实时的？"></a>为什么叫 es 是准实时的？</h5><ul>
<li>NRT，全称 near real-time。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。</li>
<li>可以通过 es 的 restful api 或者 java api，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache中，让数据立马就可以被搜索到。</li>
<li>只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</li>
<li>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file 中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。</li>
<li>commit 操作发生第一步，就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</li>
<li>这个 commit 操作叫做 flush。默认 30 分钟自动执行一次 flush，但如果 translog 过大，也会触发 flush。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</li>
<li>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</li>
<li>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</li>
<li>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的数据丢失。</li>
<li>总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。数据写入 segment file 之后，同时就建立好了倒排索引。</li>
</ul>
<h4 id="删除-更新数据底层原理"><a href="#删除-更新数据底层原理" class="headerlink" title="删除&#x2F;更新数据底层原理"></a>删除&#x2F;更新数据底层原理</h4><ul>
<li>如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。</li>
<li>如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。</li>
<li>buffer 每 refresh 一次，就会产生一个 segment file，所以默认情况下是 1 秒钟一个 segment file，这样下来 segment file 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，然后将新的 segment file 写入磁盘，这里会写一个 commit point，标识所有新的 segment file，然后打开 segment file 供搜索使用，同时删除旧的 segment file。</li>
</ul>
<h4 id="底层-lucene"><a href="#底层-lucene" class="headerlink" title="底层 lucene"></a>底层 lucene</h4><ul>
<li>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</li>
<li>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</li>
</ul>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><ul>
<li>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</li>
<li>那么，倒排索引就是关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</li>
<li>举个栗子。<ul>
<li>有以下文档：<ul>
<li>DocId	Doc</li>
<li>1	谷歌地图之父跳槽 Facebook</li>
<li>2	谷歌地图之父加盟 Facebook</li>
<li>3	谷歌地图创始人拉斯离开谷歌加盟 Facebook</li>
<li>4	谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</li>
<li>5	谷歌地图之父拉斯加盟社交网站 Facebook</li>
</ul>
</li>
</ul>
</li>
<li>对文档进行分词之后，得到以下倒排索引。<ul>
<li>WordId	Word	DocIds</li>
<li>1	谷歌	1,2,3,4,5</li>
<li>2	地图	1,2,3,4,5</li>
<li>3	之父	1,2,4,5</li>
<li>4	跳槽	1,4</li>
<li>5	Facebook	1,2,3,4,5</li>
<li>6	加盟	2,3,5</li>
<li>7	创始人	3</li>
<li>8	拉斯	3,5</li>
<li>9	离开	3</li>
<li>10	与	4</li>
<li>..	..	..</li>
</ul>
</li>
<li>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。<br>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 Facebook，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</li>
<li>要注意倒排索引的两个重要细节：<ul>
<li>倒排索引中的所有词项对应一个或多个文档；</li>
<li>倒排索引中的词项根据字典顺序升序排列</li>
</ul>
</li>
<li>上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。</li>
</ul>
<h1 id="es-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"><a href="#es-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？" class="headerlink" title="es 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"></a>es 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</h1><ul>
<li>es 性能优化是没有什么银弹的，啥意思呢？就是不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景。也许有的场景是你换个参数，或者调整一下语法，就可以搞定，但是绝对不是所有场景都可以这样。</li>
</ul>
<h4 id="性能优化的杀手锏——filesystem-cache"><a href="#性能优化的杀手锏——filesystem-cache" class="headerlink" title="性能优化的杀手锏——filesystem cache"></a>性能优化的杀手锏——filesystem cache</h4><ul>
<li>你往 es 里写的数据，实际上都写到磁盘文件里去了，查询的时候，操作系统会将磁盘文件里的数据自动缓存到 filesystem cache 里面去。</li>
<li>es 的搜索引擎严重依赖于底层的 filesystem cache，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的 idx segment file 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</li>
<li>性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1秒、5秒、10秒。但如果是走 filesystem cache，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</li>
<li>这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 64 * 3 &#x3D; 192G。每台机器给 es jvm heap 是 32G，那么剩下来留给 filesystem cache 的就是每台机器才 32G，总共集群里给 filesystem cache 的就是 32 * 3 &#x3D; 96G 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 1T 的磁盘容量，es 数据量是 1T，那么每台机器的数据量是 300G。这样性能好吗？ filesystem cache 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</li>
<li>归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</li>
<li>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要用来搜索的那些索引，如果内存留给 filesystem cache 的是 100G，那么你就将索引数据控制在 100G 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</li>
<li>比如说你现在有一行数据。id,name,age …. 30 个字段。但是你现在搜索，只需要根据 id,name,age 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 90% 的数据是不用来搜索的，结果硬是占据了 es 机器上的 filesystem cache 的空间，单条数据的数据量越大，就会导致 filesystem cahce 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的少数几个字段就可以了，比如说就写入 es id,name,age 三个字段，然后你可以把其他的字段数据存在 mysql&#x2F;hbase 里，我们一般是建议用 es + hbase 这么一个架构。</li>
<li>hbase 的特点是适用于海量数据的在线存储，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 doc id，然后根据 doc id 到 hbase 里去查询每个 doc id 对应的完整的数据，给查出来，再返回给前端。</li>
<li>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。</li>
</ul>
<h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><ul>
<li>假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 filesystem cache 一倍，比如说你写入一台机器 60G 数据，结果 filesystem cache 就 30G，还是有 30G 数据留在了磁盘上。其实可以做数据预热。</li>
<li>举个例子，拿微博来说，你可以把一些大V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 filesystem cache 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</li>
<li>或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 filesystem cache 里去。</li>
<li>对于那些你觉得比较热的、经常会有人访问的数据，最好做一个专门的缓存预热子系统，就是对热数据每隔一段时间，就提前访问一下，让数据进入 filesystem cache 里面去。这样下次别人访问的时候，性能一定会好很多。</li>
</ul>
<h4 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h4><ul>
<li>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据在被预热之后，尽量都让他们留在 filesystem os cache 里，别让冷数据给冲刷掉。</li>
<li>你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 filesystem cache 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。</li>
</ul>
<h4 id="document-模型设计"><a href="#document-模型设计" class="headerlink" title="document 模型设计"></a>document 模型设计</h4><ul>
<li>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。</li>
<li>最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</li>
<li>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join&#x2F;nested&#x2F;parent-child 搜索都要尽量避免，性能都很差的。</li>
</ul>
<h4 id="分页性能优化"><a href="#分页性能优化" class="headerlink" title="分页性能优化"></a>分页性能优化</h4><ul>
<li>es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</li>
<li>分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你必须得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</li>
<li>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</li>
<li>有什么解决方案吗？</li>
</ul>
<h5 id="不允许深度分页（默认深度分页性能很差）"><a href="#不允许深度分页（默认深度分页性能很差）" class="headerlink" title="不允许深度分页（默认深度分页性能很差）"></a>不允许深度分页（默认深度分页性能很差）</h5><ul>
<li>跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。</li>
<li>类似于 app 里的推荐商品不断下拉出来一页一页的</li>
<li>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 scroll api，关于如何使用，自行上网搜索。</li>
<li>scroll 会一次性给你生成所有数据的一个快照，然后每次滑动向后翻页就是通过游标 scroll_id 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</li>
<li>但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，不能随意跳到任何一页的场景。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。</li>
<li>初始化时必须指定 scroll 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</li>
<li>除了用 scroll api，你也可以用 search_after 来做，search_after 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</li>
</ul>
<h1 id="es-生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"><a href="#es-生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？" class="headerlink" title="es 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"></a>es 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</h1><ul>
<li>示例<ul>
<li>es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li>
<li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li>
<li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li>
</ul>
</li>
</ul>
<h1 id="什么是-Solr？"><a href="#什么是-Solr？" class="headerlink" title="什么是 Solr？"></a>什么是 Solr？</h1><ul>
<li>Solr 是一个独立的企业级搜索应用服务器，它对外提供类似于 Web-service 的 API接口。</li>
<li>Solr 是一个高性能，采用 Java 开发，基于 Lucene 的全文搜索服务器。同时对其进行了扩展，提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文检索引擎。</li>
<li>文档通过 Http 利用 XML 加到一个搜索集合中。查询该集合也是通过 http 收到一个 XML&#x2F;JSON 响应来实现。它的主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，提供一套强大 Data Schema 来定义字段，类型和设置文本分析，提供基于 Web 的管理界面等。</li>
</ul>
<h1 id="Solr-是由哪两个部分构成？"><a href="#Solr-是由哪两个部分构成？" class="headerlink" title="Solr 是由哪两个部分构成？"></a>Solr 是由哪两个部分构成？</h1><ul>
<li>如下两个部分<ul>
<li>Solr 的 web 服务</li>
<li>Solr 的索引库</li>
</ul>
</li>
</ul>
<h1 id="什么是正排索引？"><a href="#什么是正排索引？" class="headerlink" title="什么是正排索引？"></a>什么是正排索引？</h1><ul>
<li>正排索引是以文档的 ID 为关键字，索引文档中每个字的位置信息，查找时扫描索引中每个文档中字的信息直到找出所有包含查询关键字的文档。</li>
<li>但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。</li>
<li>尽管正排索引的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，否则实用性价值不大。</li>
</ul>
<h1 id="什么是倒排索引？"><a href="#什么是倒排索引？" class="headerlink" title="什么是倒排索引？"></a>什么是倒排索引？</h1><ul>
<li>对数据进行分析，抽取出数据中的词条，以词条作为 key，对应数据的存储位置作为 value，实现索引的存储。这种索引称为倒排索引。</li>
<li>当 solr 存储文档时，solr 会首先对文档数据进行分词，创建索引库和文档数据库。所谓的分词是指：将一段字符文本按照一定的规则分成若干个单词。</li>
</ul>
<h1 id="什么是全文检索？"><a href="#什么是全文检索？" class="headerlink" title="什么是全文检索？"></a>什么是全文检索？</h1><ul>
<li>我们生活中的数据总体分为两种：结构化数据和非结构化数据。<ul>
<li>结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li>非结构化数据：指不定长或无固定格式的数据，如邮件，word 文档等。</li>
</ul>
</li>
<li>非结构化数据又一种叫法叫全文数据。</li>
<li>按照数据的分类，搜索也分为两种：<ul>
<li>对结构化数据的搜索：如对数据库的搜索，用 SQL 语句。</li>
<li>对非结构化数据的搜索：如利用 windows 的搜索也可以搜索文件内容，</li>
</ul>
</li>
<li>全文检索： 就是一种将文件中所有文本与检索项匹配的文字资料检索方法。全文检索首先将要查询的目标文档中的词提取出来，组成索引，通过查询索引达到搜索目标文档的目的。这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。</li>
</ul>
]]></content>
      <categories>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/publishes/1e7ca447b43e.html</url>
    <content><![CDATA[<h1 id="⾼并发原则"><a href="#⾼并发原则" class="headerlink" title="⾼并发原则"></a>⾼并发原则</h1><h4 id="⽆状态"><a href="#⽆状态" class="headerlink" title="⽆状态"></a>⽆状态</h4><ul>
<li>⽆状态应⽤，便于⽔平扩展</li>
<li>有状态配置可通过配置中⼼实现⽆状态</li>
<li>实践: Disconf、Yaconf、Zookpeer、Consul、Confd、Diamond、Xdiamond等</li>
</ul>
<h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><ul>
<li>系统维度：按照系统功能、业务拆分，如购物⻋，结算，订单等</li>
<li>功能维度：对系统功能在做细粒度拆分</li>
<li>读写维度：根据读写⽐例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表</li>
<li>AOP维度： 根据访问特征，按照AOP进⾏拆分，⽐如商品⻚可分为CDN、⻚⾯渲染系统，CDN就是⼀个AOP系统</li>
<li>模块维度：对整体代码结构划分Web、Service、DAO</li>
</ul>
<h4 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h4><ul>
<li>服务化演进: 进程内服务-单机远程服务-集群⼿动注册服务-⾃动注册和发现服务-服务的分组、隔离、路由-服务治理</li>
<li>考虑服务分组、隔离、限流、⿊⽩名单、超时、重试机制、路由、故障补偿等</li>
<li>实践：利⽤Nginx、HaProxy、LVS等实现负载均衡，ZooKeeper、Consul等实现⾃动注册和发现服</li>
</ul>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul>
<li>⽬的: 服务解耦(⼀对多消费)、异步处理、流量削峰缓冲等</li>
<li>⼤流量缓冲： 牺牲强⼀致性，保证最终⼀致性(案例：库存扣减，现在Redis中做扣减，记录扣减⽇志，通过后台进程将扣减⽇志应⽤到DB)</li>
<li>数据校对: 解决异步消息机制下消息丢失问题</li>
</ul>
<h4 id="数据异构"><a href="#数据异构" class="headerlink" title="数据异构"></a>数据异构</h4><ul>
<li>数据异构: 通过消息队列机制接收数据变更，原⼦化存储</li>
<li>数据闭环: 屏蔽多从数据来源，将数据异构存储，形成闭环</li>
</ul>
<h4 id="缓存银弹"><a href="#缓存银弹" class="headerlink" title="缓存银弹"></a>缓存银弹</h4><ul>
<li>⽤户层:<ul>
<li>DNS缓存</li>
<li>浏览器DNS缓存</li>
<li>操作系统DNS缓存</li>
<li>本地DNS服务商缓存</li>
<li>DNS服务器缓存</li>
<li>客户端缓存<ul>
<li>浏览器缓存(Expires、Cache-Control、Last-Modified、Etag)* App</li>
<li>客户缓存(js&#x2F;css&#x2F;image…)</li>
</ul>
</li>
</ul>
</li>
<li>代理层：<ul>
<li>CDN缓存(⼀般基于ATS、Varnish、Nginx、Squid等构建,边缘节点-⼆级节点-中⼼节点-源站)</li>
</ul>
</li>
<li>接⼊层：<ul>
<li>Nginx为例：<ul>
<li>Proxy_cache： 代理缓存,可以存储到&#x2F;dev&#x2F;shm或者SSD</li>
<li>FastCGI Cache</li>
<li>Nginx+Lua+Redis: 业务数据缓存</li>
</ul>
</li>
<li>PHP为例：<ul>
<li>Opcache： 缓存PHP的Opcodes</li>
</ul>
</li>
</ul>
</li>
<li>应⽤层：<ul>
<li>⻚⾯静态化</li>
<li>业务数据缓存(Redis&#x2F;Memcached&#x2F;本地⽂件等)</li>
<li>消息队列</li>
</ul>
</li>
<li>数据层：<ul>
<li>NoSQL： Redis、Memcache、SSDB等</li>
<li>MySQL： Innodb&#x2F;MyISAM等Query Cache、Key Cache、Innodb</li>
<li>Buffer Size等</li>
</ul>
</li>
<li>系统层：<ul>
<li>CPU : L1&#x2F;L2&#x2F;L3 Cache&#x2F;NUMA</li>
<li>内存</li>
<li>磁盘：磁盘本身缓存、dirty_ratio&#x2F;dirty_background_ratio、阵列卡本身缓存</li>
<li>并发化</li>
</ul>
</li>
</ul>
<h1 id="⾼可⽤原则"><a href="#⾼可⽤原则" class="headerlink" title="⾼可⽤原则"></a>⾼可⽤原则</h1><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><ul>
<li>降级开关集中化管理：将开关配置信息推送到各个应⽤</li>
<li>可降级的多级读服务：如服务调⽤降级为只读本地缓存</li>
<li>开关前置化：如Nginx+lua(OpenResty)配置降级策略，引流流量；可基于此做灰度策略</li>
<li>业务降级：⾼并发下，保证核⼼功能，次要功能可由同步改为异步策略或屏蔽功能</li>
</ul>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul>
<li>⽬的: 防⽌恶意请求攻击或超出系统峰值</li>
<li>实践：<ul>
<li>恶意请求流量只访问到Cache</li>
<li>穿透后端应⽤的流量使⽤Nginx的limit处理</li>
<li>恶意IP使⽤Nginx Deny策略或者iptables拒绝</li>
</ul>
</li>
</ul>
<h4 id="切流量"><a href="#切流量" class="headerlink" title="切流量"></a>切流量</h4><ul>
<li>⽬的：屏蔽故障机器</li>
<li>实践:<ul>
<li>DNS: 更改域名解析⼊⼝，如DNSPOD可以添加备⽤IP，正常IP故障时，会⾃主切换到备⽤地址;⽣效实践较慢</li>
<li>HttpDNS: 为了绕过运营商LocalDNS实现的精准流量调度</li>
<li>LVS&#x2F;HaProxy&#x2F;Nginx: 摘除故障节点</li>
</ul>
</li>
</ul>
<h4 id="可回滚"><a href="#可回滚" class="headerlink" title="可回滚"></a>可回滚</h4><ul>
<li>发布版本失败时可随时快速回退到上⼀个稳定版本</li>
</ul>
<h1 id="业务设计原则"><a href="#业务设计原则" class="headerlink" title="业务设计原则"></a>业务设计原则</h1><ul>
<li>防重设计</li>
<li>幂等设计</li>
<li>流程定义</li>
<li>状态与状态机</li>
<li>后台系统操作可反馈</li>
<li>后台系统审批化</li>
<li>⽂档注释</li>
<li>备份</li>
</ul>
<h1 id="分布式与集群的区别"><a href="#分布式与集群的区别" class="headerlink" title="分布式与集群的区别"></a>分布式与集群的区别</h1><ul>
<li>分布式是指将不同的业务分布在不同的地⽅</li>
<li>⽽集群指的是将⼏台服务器集中在⼀起，实现同⼀业务</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h4 id="⼆阶段提交"><a href="#⼆阶段提交" class="headerlink" title="⼆阶段提交"></a>⼆阶段提交</h4><ul>
<li>概念：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中⽌操作。</li>
<li>作⽤：主要保证了分布式事务的原⼦性；第⼀阶段为准备阶段，第⼆阶段为提交阶段；</li>
<li>缺点：不仅要锁住参与者的所有资源，⽽且要锁住协调者资源，开销⼤。⼀句话总结就是：2PC效率很低，对⾼并发很不友好。</li>
</ul>
<h4 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h4><ul>
<li>概念：三阶段提交协议在协调者和参与者中都引⼊超时机制，并且把两阶段提交协议的第⼀个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</li>
<li>缺点：如果进⼊PreCommit后，Coordinator发出的是abort请求，假设只有⼀个Cohort收到并进⾏了abort操作，⽽其他对于系统状态未知的Cohort会根据3PC选择继续Commit，此时系统状态发⽣不⼀致性。</li>
</ul>
<h4 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h4><ul>
<li>概念：所谓柔性事务是相对强制锁表的刚性事务⽽⾔。流程⼊下：服务器A的事务如果执⾏顺利，那么事务A就先⾏提交，如果事务B也执⾏顺利，则事务B也提交，整个事务就算完成。但是如果事务B执⾏失败，事务B本身回滚，这时事务A已经被提交，所以需要执⾏⼀个补偿操作，将已经提交的事务A执⾏的操作作反操作，恢复到未执⾏前事务A的状态。</li>
<li>缺点：业务侵⼊性太强，还要补偿操作，缺乏普遍性，没法⼤规模推⼴。</li>
</ul>
<h1 id="消息最终⼀致性解决⽅案之RabbitMQ实现："><a href="#消息最终⼀致性解决⽅案之RabbitMQ实现：" class="headerlink" title="消息最终⼀致性解决⽅案之RabbitMQ实现："></a>消息最终⼀致性解决⽅案之RabbitMQ实现：</h1><ul>
<li>实现：发送⽅确认+消息持久化+消费者确认。</li>
</ul>
<h1 id="什么时候⽤到分布式开发："><a href="#什么时候⽤到分布式开发：" class="headerlink" title="什么时候⽤到分布式开发："></a>什么时候⽤到分布式开发：</h1><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>模块解耦：把模块拆分,使⽤接⼝通信,降低模块之间的耦合度.</li>
<li>项⽬拆分，不同团队负责不同的⼦项⽬：把项⽬拆分成若⼲个⼦项⽬,不同的团队负责不同的⼦项⽬.</li>
<li>提⾼项⽬扩展性：增加功能时只需要再增加⼀个⼦项⽬,调⽤其他系统的接⼝就可以。</li>
<li>分布式部署：可以灵活的进⾏分布式部署.</li>
<li>提⾼代码的复⽤性：⽐如service层,如果不采⽤分布式rest服务⽅式架构就会在⼿机wap商城,信商城,pc,android，ios每个端都要写⼀个service层逻辑,开发量⼤,难以维护⼀起升级,这时候可以采⽤分布式rest服务⽅式,公⽤⼀个service层。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>系统之间的交互要使⽤远程通信,接⼝开发增⼤⼯作量；</li>
<li>⽹络请求有延时；</li>
<li>事务处理⽐较麻烦，需要使⽤分布式事务。</li>
</ul>
<h1 id="cdn（异地多活）"><a href="#cdn（异地多活）" class="headerlink" title="cdn（异地多活）"></a>cdn（异地多活）</h1><h4 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h4><ul>
<li>异地多活指分布在异地的多个站点同时对外提供服务的业务场景。异地多活是⾼可⽤架构设计的⼀种，与传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。</li>
<li>两地容灾切换⽅案：容灾是异地多活中最核⼼的⼀环， 以两个城市异地多活部署架构图为例，在两个城市（城市1位于华南1地域、城市2位于华东1地域）均部署⼀套完整的业务系统。下单业务按照“user_id”％ 100 进⾏分⽚，在正常情况下：<ul>
<li>[00~49]分⽚所有的读写都在城市1的数据库实例主库。</li>
<li>[50～99]分⽚所有的读写都在城市2的数据库实例主库。</li>
<li>“城市1的数据库实例主库”和 “城市2的数据库实例主库”建⽴DTS双向复制。</li>
<li>当出现异常时，需要进⾏容灾切换。可能出现的场景有以下4种：<ul>
<li>将第2种、第3种异常情况，全部采⽤第2种⽅案进⾏处理，那么不管是所有的APP Server异常、所有的数据库异常、整个城市异常，就直接按照城市级容灾⽅案处理，直接将APP Server、数据库切换到到另⼀个城市。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多城异地多活"><a href="#多城异地多活" class="headerlink" title="多城异地多活"></a>多城异地多活</h4><ul>
<li>多城市异地多活模式指的是3个或者3个以上城市间部署异地多活</li>
<li>该模式下存在中⼼节点和单元节点：<ul>
<li>中⼼节点：指单元节点的增量数据都需要实时的同步到中⼼节点，同时中⼼节点将所有分⽚的增量数据同步到其他单元节点。</li>
<li>单元节点：即对应分⽚读写的节点，该节点需要将该分⽚的增量同步到中⼼节点，并且接收来⾃于中⼼节点的其他分⽚的增量数据。</li>
</ul>
</li>
</ul>
<h1 id="分布式环境下宕机的处理⽅案"><a href="#分布式环境下宕机的处理⽅案" class="headerlink" title="分布式环境下宕机的处理⽅案"></a>分布式环境下宕机的处理⽅案</h1><ul>
<li>dubbo：服务器宕机，zk临时被删除；</li>
<li>springcloud：每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。</li>
<li>apm监控</li>
</ul>
<h1 id="分布式、高并发、多线程，到底有什么区别？"><a href="#分布式、高并发、多线程，到底有什么区别？" class="headerlink" title="分布式、高并发、多线程，到底有什么区别？"></a>分布式、高并发、多线程，到底有什么区别？</h1><ul>
<li>当提起这三个词的时候，是不是很多人都认为分布式&#x3D;高并发&#x3D;多线程？</li>
<li>在一开始接触的时候，不少人都会将三者混淆，误以为所谓的分布式高并发的系统就是能同时供海量用户访问，而采用多线程手段不就是可以提供系统的并发能力吗</li>
<li>实际上，他们三个总是相伴而生，但侧重点又有不同</li>
</ul>
<h4 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h4><ul>
<li>分布式更多的一个概念，是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段</li>
<li>该领域需要解决的问题极多，在不同的技术层面上，又包括：分布式文件系统、分布式缓存、分布式数据库、分布式计算等，一些名词如Hadoop、zookeeper、MQ等都跟分布式有关</li>
<li>从理念上讲，分布式的实现有两种形式：<ul>
<li>水平扩展：当一台机器扛不住流量时，就通过添加机器的方式，将流量平分到所有服务器上，所有机器都可以提供相当的服务；</li>
<li>垂直拆分：前端有多种查询需求时，一台机器扛不住，可以将不同的需求分发到不同的机器上，比如A机器处理余票查询的请求，B机器处理支付的请求。</li>
</ul>
</li>
</ul>
<h4 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h4><ul>
<li>相对于分布式来讲，高并发在解决的问题上会集中一些，其反应的是同时有多少量：比如在线直播服务，同时有上万人观看</li>
<li>高并发可以通过分布式技术去解决，将并发流量分不到不同的物理服务器上</li>
<li>但除此之外，还可以有很多其他优化手段：比如使用缓存系统，将所有的，静态内容放到CDN等；还可以使用多线程技术将一台服务器的服务能力最大化。</li>
</ul>
<h4 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h4><ul>
<li>多线程是指从软件或者硬件上实现多个线程并发执行的技术</li>
<li>它更多的是解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行（实际是交替运行的）</li>
<li>多线程解决的问题是最明确的，手段也是比较单一的，基本上遇到的最大问题就是线程安全</li>
<li>在JAVA语言中，需要对JVM内存模型、指令重排等深入了解，才能写出一份高质量的多线程代码。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>分布式是从物理资源的角度去将不同的机器组成一个整体对外服务，技术范围非常广且难度非常大，有了这个基础，高并发、高吞吐等系统很容易构建；</li>
<li>高并发是从业务角度去描述系统的能力，实现高并发的手段可以采用分布式，也可以采用诸如缓存、CDN等，当然也包括多线程；</li>
<li>多线程则聚焦于如何使用编程语言将CPU调度能力最大化</li>
</ul>
<h1 id="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"><a href="#分布式服务接口的幂等性如何设计（比如不能重复扣款）？" class="headerlink" title="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"></a>分布式服务接口的幂等性如何设计（比如不能重复扣款）？</h1><ul>
<li>这个不是技术问题，这个没有通用的一个方法，这个应该结合业务来保证幂等性。</li>
<li>所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</li>
<li>其实保证幂等性主要是三点：<ul>
<li>对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单id，一个订单 id 最多支付一次。</li>
<li>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql中记录个状态，比如支付之前记录一条这个订单的支付流水。</li>
<li>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。</li>
</ul>
</li>
<li>实际运作过程中，你要结合自己的业务来，比如说利用 redis，用 orderId作为唯一键</li>
<li>只有成功插入这个支付流水，才可以执行实际的支付扣款。</li>
<li>要求是支付一个订单，必须插入一条支付流水，<code>order_id</code> 建一个唯一键unique key。你在支付一个订单之前，先插入一条支付流水，<code>order_id</code>就已经进去了。你就可以写一个标识到 redis 里面去，<code>set order_id payed</code>，下一次重复请求过来了，先查 redis 的 order_id 对应的 value，如果是payed就说明已经支付过了，你就别重复支付了。</li>
</ul>
<h1 id="分布式事务了解吗？你们是如何解决分布式事务问题的？"><a href="#分布式事务了解吗？你们是如何解决分布式事务问题的？" class="headerlink" title="分布式事务了解吗？你们是如何解决分布式事务问题的？"></a>分布式事务了解吗？你们是如何解决分布式事务问题的？</h1><ul>
<li>分布式事务的实现主要有以下 5 种方案：</li>
<li>XA 方案</li>
<li>TCC 方案</li>
<li>本地消息表</li>
<li>可靠消息最终一致性方案</li>
<li>最大努力通知方案</li>
</ul>
<h4 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案&#x2F;XA方案"></a>两阶段提交方案&#x2F;XA方案</h4><ul>
<li>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</li>
<li>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。</li>
<li>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</li>
<li>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</li>
<li>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</li>
<li>distributed-transacion-XA</li>
</ul>
<h4 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h4><ul>
<li>TCC 的全称是：Try、Confirm、Cancel。<ul>
<li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。</li>
<li>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。</li>
<li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li>
</ul>
</li>
<li>这种方案说实话几乎很少人使用，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大。</li>
<li>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</li>
<li>而且最好是你的各个业务执行的时间都比较短。</li>
<li>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</li>
<li>distributed-transacion-TCC</li>
</ul>
<h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><ul>
<li>本地消息表其实是国外的 ebay 搞出来的这么一套思想。这个大概意思是这样的：<ul>
<li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li>
<li>接着 A 系统将这个消息发送到 MQ 中去；</li>
<li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</li>
<li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li>
<li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li>
<li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B那边成功为止。</li>
</ul>
</li>
<li>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</li>
<li>distributed-transaction-local-message-table</li>
</ul>
<h4 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h4><ul>
<li>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ就支持消息事务。大概的意思就是：<ul>
<li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared消息发送失败那么就直接取消操作别执行了；</li>
<li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li>
<li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li>
<li>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li>
</ul>
</li>
<li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿。</li>
<li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用RocketMQ支持的，要不你就自己基于类似ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li>
<li>distributed-transaction-reliable-message</li>
</ul>
<h4 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h4><ul>
<li>这个方案的大致意思就是：<ul>
<li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li>
<li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li>
<li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li>
</ul>
</li>
</ul>
<h4 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h4><ul>
<li>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性</li>
<li>然后其他的一些场景基于阿里的 RocketMQ 来实现了分布式事务。</li>
<li>找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案</li>
<li>如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</li>
</ul>
<h1 id="分步式锁"><a href="#分步式锁" class="headerlink" title="分步式锁"></a>分步式锁</h1><ul>
<li>基本原理：⽤⼀个状态值表示锁，对锁的占⽤和释放通过状态值来标识。</li>
</ul>
<h4 id="三种分布式锁："><a href="#三种分布式锁：" class="headerlink" title="三种分布式锁："></a>三种分布式锁：</h4><h5 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h5><ul>
<li>基于zookeeper瞬时有序节点实现的分布式锁</li>
<li>⼤致思想即为：每个客户端对某个功能加锁时，在zookeeper上的与该功能对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点</li>
<li>判断是否获取锁的⽅式很简单，只需要判断有序节点中序号最⼩的⼀个</li>
<li>当释放锁的时候，只需将这个瞬时节点删除即可</li>
<li>同时，其可以避免服务宕机导致的锁⽆法释放，⽽产⽣的死锁问题。</li>
<li>优点<ul>
<li>锁安全性⾼，zk可持久化，且能实时监听获取锁的客户端状态</li>
<li>⼀旦客户端宕机，则瞬时节点随之消失，zk因⽽能第⼀时间释放锁</li>
<li>这也省去了⽤分布式缓存实现锁的过程中需要加⼊超时时间判断的这⼀逻辑。</li>
</ul>
</li>
<li>缺点<ul>
<li>性能开销⽐较⾼</li>
<li>因为其需要动态产⽣、销毁瞬时节点来实现锁功能</li>
<li>所以不太适合直接提供给⾼并发的场景使⽤</li>
</ul>
</li>
<li>实现<ul>
<li>可以直接采⽤zookeeper第三⽅库curator即可⽅便地实现分布式锁</li>
</ul>
</li>
<li>适⽤场景<ul>
<li>对可靠性要求⾮常⾼，且并发程度不⾼的场景下使⽤</li>
<li>如核⼼数据的定时全量&#x2F;增量同步等。</li>
</ul>
</li>
</ul>
<h5 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h5><ul>
<li>memcached带有add函数，利⽤add函数的特性即可实现分布式锁</li>
<li>add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。⽽add的话则相反，add会添加第⼀个到达的值，并返回true，后续的添加则都会返回false。利⽤该点即可很轻松地实现分布式锁。</li>
<li>优点：并发⾼效</li>
<li>缺点<ul>
<li>memcached采⽤列⼊LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。</li>
<li>memcached⽆法持久化，⼀旦重启，将导致信息丢失。</li>
</ul>
</li>
<li>使⽤场景<ul>
<li>⾼并发场景。需要<ul>
<li>加上超时时间避免死锁</li>
<li>提供⾜够⽀撑锁服务的内存空间</li>
<li>稳定的集群化管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h5><ul>
<li>redis分布式锁即可以结合zk分布式锁锁⾼度安全和memcached并发场景下效率很好的优点</li>
<li>其实现⽅式和memcached类似，采⽤setnx即可实现</li>
<li>需要注意的是，这⾥的redis也需要设置超时时间，以避免死锁。</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/publishes/32257fddc744.html</url>
    <content><![CDATA[<h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul>
<li>区别：<ul>
<li>InnoDB支持事务，MyISAM不支持</li>
<li>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>
<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</li>
<li>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</li>
<li>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>
</ul>
</li>
<li>如何选择：<ul>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ul>
</li>
</ul>
<h4 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h4><ul>
<li>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）</li>
<li>如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</li>
</ul>
<h4 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h4><ul>
<li>插入缓冲（insert buffer）</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h1 id="⾏锁，表锁，乐观锁，悲观锁？"><a href="#⾏锁，表锁，乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁，乐观锁，悲观锁？"></a>⾏锁，表锁，乐观锁，悲观锁？</h1><ul>
<li>⾏锁：数据库表中某一⾏被锁住。</li>
<li>表锁：整个数据库表被锁住。</li>
<li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不不会修改，具体实现是给表增加⼀个版本号的字段，在执行update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。</li>
<li>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。读数据的时候会上锁，直到update完成才释放锁，使⽤悲观锁要注意不要锁住整个表。</li>
</ul>
<h1 id="数据库隔离级别是什什么？有什么作用？"><a href="#数据库隔离级别是什什么？有什么作用？" class="headerlink" title="数据库隔离级别是什什么？有什么作用？"></a>数据库隔离级别是什什么？有什么作用？</h1><ul>
<li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。 这种隔离级别会产⽣生脏读，不可重复读和幻读。</li>
<li>ISOLATIONREADCOMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外⼀个事务不能读取该 事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li>
<li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了了保证一个事务不能读取另⼀个事务未提交的数据外，还保证了了避免不可重复读。</li>
<li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理理为顺序执行。除了防止脏读， 不可重复读外，还避免了幻读。</li>
</ul>
<h1 id="MySQL主备同步的基本原理理。"><a href="#MySQL主备同步的基本原理理。" class="headerlink" title="MySQL主备同步的基本原理理。"></a>MySQL主备同步的基本原理理。</h1><ul>
<li>mysql主备复制实现分成三个步骤：<ul>
<li>master将改变记录到⼆进制⽇志(binary log) 中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</li>
<li>slave将master的binary log events拷⻉到它的中继日志(relay log) ；</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ul>
</li>
</ul>
<h1 id="select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？"><a href="#select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</h1><ul>
<li>sql语句句执⾏行行顺序如下：</li>
<li>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</li>
</ul>
<h1 id="如何优化数据库性能"><a href="#如何优化数据库性能" class="headerlink" title="如何优化数据库性能"></a>如何优化数据库性能</h1><ul>
<li>索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署</li>
<li>选择合适的数据库引擎，合理使用索引</li>
<li>分页获取数据，只获取需要的字段</li>
<li>优化业务逻辑，减少数据库IO</li>
<li>分库分表</li>
<li>部署主从数据库</li>
<li>升级硬件</li>
</ul>
<h1 id="SQL什么情况下不会使用索引"><a href="#SQL什么情况下不会使用索引" class="headerlink" title="SQL什么情况下不会使用索引"></a>SQL什么情况下不会使用索引</h1><ul>
<li>不包含，不等于，函数</li>
<li>select * 可能导致不走索引；</li>
<li>空值会导致不走索引，因为hashset不能存空值；</li>
<li>索引列有函数运算，不走索引，可以在索引列列建⽴立⼀一个函数的索引。</li>
<li>隐式转换可能导致不走索引；</li>
<li>表的数据库小或者需要选择大部分数据，不走索引；</li>
<li>!&#x3D;或者&lt;&gt;可能导致不走索引；</li>
<li>字符型的索引列列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式</li>
<li>like ‘%liu’ 百分号在前不走索引；</li>
<li>not in, not exist不走索引；</li>
</ul>
<h1 id="一般在什什么字段上建索引"><a href="#一般在什什么字段上建索引" class="headerlink" title="一般在什什么字段上建索引"></a>一般在什什么字段上建索引</h1><ul>
<li>过滤数据最多的字段</li>
<li>表的主键、外键必须有索引；</li>
<li>数据量量超过300的表应该有索引；</li>
<li>经常与其他表进行行连接的表，在连接字段上应该建立索引；</li>
<li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>索引应该建在选择性高的字段上；</li>
<li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li>
<li>如何从一张表中查出name字段不包含”XYZ”的所有行？</li>
</ul>
<h1 id="如何解决高并发减库存问题"><a href="#如何解决高并发减库存问题" class="headerlink" title="如何解决高并发减库存问题"></a>如何解决高并发减库存问题</h1><ul>
<li>消息队列，异步处理，减库存加锁</li>
</ul>
<h1 id="数据库事务的几种粒度；"><a href="#数据库事务的几种粒度；" class="headerlink" title="数据库事务的几种粒度；"></a>数据库事务的几种粒度；</h1><ul>
<li>表锁定：对整个表的锁定。</li>
<li>行锁定：只锁定进⾏行更改的行，例如：insert，update，delete，都隐式采用行锁定。</li>
<li>数据库锁机制可分为多种粒度的： 数据库，表，页面，行</li>
<li>粒度越大，DBMS管理越容易，但是实现并发处理的能力就越差，表，页面，行</li>
</ul>
<h1 id="mysql调优"><a href="#mysql调优" class="headerlink" title="mysql调优"></a>mysql调优</h1><ul>
<li>explain select语句；</li>
<li>当只要一条数据时使用limit 1；</li>
<li>为搜索字段建索引；</li>
<li>避免select *；</li>
<li>字段尽量使用not null；</li>
<li>垂直分割；</li>
<li>拆分大的delete和insert语句：delete和insert会锁表；</li>
<li>分表分库分区</li>
</ul>
<h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><ul>
<li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li>
<li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li>
<li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li>
<li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><ul>
<li>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页</li>
<li>然后redo log按照时间或者空间等条件进行落盘</li>
<li>undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了</li>
<li>此时，事务还未 COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤用undo log进⾏事务回滚</li>
<li>事务执行COMMIT操作时，会将本事务相关的所有redo log都进⾏落盘，只有所有redo log落盘成功，才算COMMIT成功</li>
<li>然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发⽣了崩溃，则只使⽤用redo log恢复数据。</li>
</ul>
<h1 id="让你设计一个索引，你会怎么设计？"><a href="#让你设计一个索引，你会怎么设计？" class="headerlink" title="让你设计一个索引，你会怎么设计？"></a>让你设计一个索引，你会怎么设计？</h1><ul>
<li>mysql默认存储引擎innodb只显式支持B树索引</li>
<li>对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</li>
</ul>
<h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><ul>
<li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。<ul>
<li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li>
<li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li>
</ul>
</li>
<li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放<ul>
<li>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</li>
</ul>
</li>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li>
<li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置<ul>
<li>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销</li>
<li>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li>
</ul>
</li>
</ul>
<h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul>
<li>数据索引的存储是有序的</li>
<li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li>
<li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li>
</ul>
<h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul>
<li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li>
<li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li>
</ul>
<h4 id="哈希索引的优势"><a href="#哈希索引的优势" class="headerlink" title="哈希索引的优势"></a>哈希索引的优势</h4><ul>
<li>等值查询，哈希索引具有绝对优势</li>
<li>前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题</li>
</ul>
<h4 id="哈希索引不适用的场景"><a href="#哈希索引不适用的场景" class="headerlink" title="哈希索引不适用的场景"></a>哈希索引不适用的场景</h4><ul>
<li>不支持范围查询</li>
<li>不支持索引完成排序</li>
<li>不支持联合索引的最左前缀匹配规则</li>
<li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<ul>
<li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主</li>
<li>没有范围查询、没有排序的时候，特别适合采用哈希索引</li>
<li>仅等值查询<ul>
<li>select id, name from table where name&#x3D;’李明’;</li>
</ul>
</li>
</ul>
</li>
<li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li>
<li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li>
<li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li>
<li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li>
<li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read&#x2F;write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li>
</ul>
<h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul>
<li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li>
<li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li>
</ul>
<h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><h4 id="B-的磁盘读写代价更低。"><a href="#B-的磁盘读写代价更低。" class="headerlink" title="B+的磁盘读写代价更低。"></a>B+的磁盘读写代价更低。</h4><ul>
<li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li>
<li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多</li>
<li>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li>
</ul>
<h4 id="B-tree的查询效率更加稳定。"><a href="#B-tree的查询效率更加稳定。" class="headerlink" title="B+-tree的查询效率更加稳定。"></a>B+-tree的查询效率更加稳定。</h4><ul>
<li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引</li>
<li>所以任何关键字的查找必须走一条从根结点到叶子结点的路</li>
<li>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><ul>
<li>联合索引是两个或更多个列上的索引</li>
<li>对于联合索引Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li>
<li>例如索引是key index (a,b,c).<ul>
<li>可以支持a 、 a,b 、 a,b,c 3种组合进行查找</li>
<li>但不支持 b,c进行查找</li>
<li>当最左侧字段是常量引用时，索引就十分有效。</li>
</ul>
</li>
<li>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</li>
<li>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。</li>
<li>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</li>
</ul>
<h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul>
<li>表记录太少</li>
<li>经常插入、删除、修改的表</li>
<li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li>
<li>经常和主字段一块查询但主字段索引值比较多的表字段</li>
</ul>
<h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul>
<li>表分区是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分</li>
<li>从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li>
</ul>
<h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul>
<li>分表：指的是通过一定规则，将一张表分解成多张不同的表</li>
<li>比如将用户订单记录根据时间成多个表。</li>
<li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li>
</ul>
<h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><h4 id="存储更多数据"><a href="#存储更多数据" class="headerlink" title="存储更多数据"></a>存储更多数据</h4><ul>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li>
<li>和单个磁盘或者文件系统相比，可以存储更多数据</li>
</ul>
<h4 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h4><ul>
<li>在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率</li>
<li>涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li>
</ul>
<h4 id="分区表更容易维护"><a href="#分区表更容易维护" class="headerlink" title="分区表更容易维护"></a>分区表更容易维护</h4><ul>
<li>例如：想批量删除大量数据可以清除整个分区。</li>
</ul>
<h4 id="避免某些特殊的瓶颈"><a href="#避免某些特殊的瓶颈" class="headerlink" title="避免某些特殊的瓶颈"></a>避免某些特殊的瓶颈</h4><ul>
<li>例如InnoDB的单个索引的互斥访问，ext3文件系统的inode锁竞争等。</li>
</ul>
<h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ul>
<li>一个表最多只能有1024个分区</li>
<li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式</li>
<li>在MySQL5.5中提供了非整数表达式分区的支持。</li>
<li>如果分区字段中有主键或者唯一索引的列，那么有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li>
<li>分区表中无法使用外键约束</li>
<li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li>
</ul>
<h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><ul>
<li>命令：show variables like ‘%partition%’ 运行结果:</li>
<li>mysql&gt; show variables like ‘%partition%’;</li>
<li>have_partintioning 的值为YES，表示支持分区。</li>
</ul>
<h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><ul>
<li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li>
<li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li>
<li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li>
<li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li>
</ul>
<h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><ul>
<li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control)</li>
<li>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</li>
<li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</li>
<li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制</li>
<li>MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议</li>
<li>纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li>
<li>在MVCC并发控制中，读操作可以分成两类：<ul>
<li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li>
<li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li>
</ul>
</li>
</ul>
<h1 id="行级锁定的优缺点"><a href="#行级锁定的优缺点" class="headerlink" title="行级锁定的优缺点"></a>行级锁定的优缺点</h1><h4 id="行级锁定的优点"><a href="#行级锁定的优点" class="headerlink" title="行级锁定的优点"></a>行级锁定的优点</h4><ul>
<li>当在许多线程中访问不同的行时只存在少量锁定冲突</li>
<li>回滚时只有少量的更改</li>
<li>可以长时间锁定单一的行</li>
</ul>
<h4 id="行级锁定的缺点"><a href="#行级锁定的缺点" class="headerlink" title="行级锁定的缺点"></a>行级锁定的缺点</h4><ul>
<li>比页级或表级锁定占用更多的内存。</li>
<li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li>
<li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li>
<li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li>
</ul>
<h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul>
<li>key 是数据库的物理结构，它包含两层意义和作用<ul>
<li>一是约束（偏重于约束和规范数据库的结构完整性）</li>
<li>二是索引（辅助查询用的），包括primary key, unique key, foreign key 等</li>
</ul>
</li>
<li>index是数据库的物理结构<ul>
<li>它只是辅助查询的</li>
<li>它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储</li>
<li>索引要分类的话，分为前缀索引、全文本索引等；</li>
</ul>
</li>
</ul>
<h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><h4 id="字段名及字段配制合理性"><a href="#字段名及字段配制合理性" class="headerlink" title="字段名及字段配制合理性"></a>字段名及字段配制合理性</h4><ul>
<li>剔除关系不密切的字段；</li>
<li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li>
<li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li>
<li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li>
<li>字段名不要使用保留字或者关键字；</li>
<li>保持字段名和类型的一致性；</li>
<li>慎重选择数字类型；</li>
<li>给文本字段留足余量；</li>
</ul>
<h4 id="系统特殊字段处理及建成后建议"><a href="#系统特殊字段处理及建成后建议" class="headerlink" title="系统特殊字段处理及建成后建议"></a>系统特殊字段处理及建成后建议</h4><ul>
<li>添加删除标记（例如操作人、删除时间）；</li>
<li>建立版本机制；</li>
</ul>
<h4 id="表结构合理性配置"><a href="#表结构合理性配置" class="headerlink" title="表结构合理性配置"></a>表结构合理性配置</h4><ul>
<li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li>
<li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li>
</ul>
<h4 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h4><ul>
<li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li>
<li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li>
<li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li>
<li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li>
<li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li>
</ul>
<h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><h4 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF"></a>第一范式（1NF</h4><ul>
<li>字段具有原子性,不可再分</li>
<li>所有关系型数据库系统都满足第一范式</li>
<li>数据库表中的字段都是单一属性的，不可再分</li>
</ul>
<h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><ul>
<li>是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）</li>
<li>要求数据库表中的每个实例或行必须可以被惟一地区分</li>
<li>通常需要为表加上一个列，以存储各个实例的惟一标识</li>
<li>这个惟一属性列被称为主关键字或主键。</li>
</ul>
<h4 id="满足第三范式（3NF）"><a href="#满足第三范式（3NF）" class="headerlink" title="满足第三范式（3NF）"></a>满足第三范式（3NF）</h4><ul>
<li>必须先满足第二范式（2NF）</li>
<li>简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</li>
<li>所以第三范式具有如下特征<ul>
<li>每一列只有一个值</li>
<li>每一行都能区分</li>
<li>每一个表都不包含其他表已经包含的非主关键字信息。</li>
</ul>
</li>
</ul>
<h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><ul>
<li>用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</li>
<li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</li>
<li>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等</li>
<li>UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL</li>
<li>UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同<ul>
<li>对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录</li>
<li>对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</li>
</ul>
</li>
</ul>
<h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><ul>
<li>普通索引: 即针对数据库表创建索引</li>
<li>唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值</li>
<li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li>
<li>组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li>
</ul>
<h1 id="在mysql数据库中索引的工作机制是什么？"><a href="#在mysql数据库中索引的工作机制是什么？" class="headerlink" title="在mysql数据库中索引的工作机制是什么？"></a>在mysql数据库中索引的工作机制是什么？</h1><ul>
<li>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据</li>
<li>索引的实现通常使用B树及其变种B+树</li>
</ul>
<h1 id="MySQL的基础操作命令"><a href="#MySQL的基础操作命令" class="headerlink" title="MySQL的基础操作命令"></a>MySQL的基础操作命令</h1><ul>
<li>MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status</li>
<li>开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务</li>
<li>Shell 登入 MySQL: 运行命令 mysql -u root -p</li>
<li>列出所有数据库:运行命令 show databases;</li>
<li>切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库</li>
<li>列出某个数据库内所有表: show tables;</li>
<li>获取表内所有 Field 对象的名称和类型 :describe table_name;</li>
</ul>
<h1 id="mysql的复制原理以及流程"><a href="#mysql的复制原理以及流程" class="headerlink" title="mysql的复制原理以及流程"></a>mysql的复制原理以及流程</h1><ul>
<li>Mysql内建的复制功能是构建大型，高性能应用程序的基础</li>
<li>将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的</li>
<li>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器</li>
<li>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环</li>
<li>这些日志可以记录发送到从服务器的更新</li>
<li>当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置</li>
<li>从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新</li>
<li>过程如下<ul>
<li>主服务器把更新记录到二进制日志文件中</li>
<li>从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中</li>
<li>从服务器重做中继日志中的时间，把更新应用到自己的数据库上</li>
</ul>
</li>
</ul>
<h1 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型?"></a>mysql支持的复制类型?</h1><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><ul>
<li>在主服务器上执行的SQL语句，在从服务器上执行同样的语句</li>
<li>MySQL默认采用基于语句的复制，效率比较高</li>
<li>一旦发现没法精确复制时，会自动选着基于行的复制。</li>
</ul>
<h4 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h4><ul>
<li>把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持</li>
</ul>
<h4 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h4><ul>
<li>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</li>
</ul>
<h1 id="mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？"><a href="#mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？" class="headerlink" title="mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？"></a>mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</h1><ul>
<li>varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.</li>
<li>varchar(50)中50的涵义 : 最多存放50个字节</li>
<li>int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</li>
</ul>
<h1 id="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h1><ul>
<li>如果字段里面有大字段（text,blob）类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了</li>
<li>MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多</li>
<li>此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率</li>
<li>当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的</li>
<li>拆分开后，对字段的UPDAE就要UPDATE多个表了</li>
</ul>
<h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</h1><ul>
<li>InnoDB行锁是通过给索引上的索引项加锁来实现的</li>
<li>这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的</li>
<li>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li>
</ul>
<h1 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</h1><ul>
<li>由于utf8的每个字符最多占用3个字节</li>
<li>而MySQL定义行的长度不能超过65535</li>
<li>因此N的最大值计算方法为：(65535-1-2)&#x2F;3</li>
<li>减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</li>
</ul>
<h1 id="SELECT-和SELECT-全部字段的2种写法有何优缺点"><a href="#SELECT-和SELECT-全部字段的2种写法有何优缺点" class="headerlink" title="SELECT * 和SELECT 全部字段的2种写法有何优缺点?"></a>SELECT * 和SELECT 全部字段的2种写法有何优缺点?</h1><ul>
<li>前者要解析数据字典，后者不需要</li>
<li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li>
<li>表字段改名，前者不需要修改，后者需要改</li>
<li>后者可以建立索引进行优化，前者无法优化</li>
<li>后者的可读性比前者要高</li>
</ul>
<h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><ul>
<li>语法上：where 用表中列名，having用select结果别名</li>
<li>影响结果范围：where从表读出数据的行数，having返回客户端的行数</li>
<li>索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作</li>
<li>where后面不能使用聚集函数，having是专门使用聚集函数的。</li>
</ul>
<h1 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h1><ul>
<li>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c&#x3D;c+1;</li>
</ul>
<h1 id="MySQL的insert和update的select语句语法"><a href="#MySQL的insert和update的select语句语法" class="headerlink" title="MySQL的insert和update的select语句语法"></a>MySQL的insert和update的select语句语法</h1><ul>
<li>insert into student (stuid,stuname,deptid) select 10,’xzm’,3 from student where stuid &gt; 8;</li>
<li>update student a inner join student b on b.stuID&#x3D;10 set a.stuname&#x3D;concat(b.stuname, b.stuID) where a.stuID&#x3D;10 ;</li>
</ul>
<h1 id="Mysql-中有哪几种锁？"><a href="#Mysql-中有哪几种锁？" class="headerlink" title="Mysql 中有哪几种锁？"></a>Mysql 中有哪几种锁？</h1><ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低， 并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和 行锁之间，并发度一般。</li>
</ul>
<h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><ul>
<li>共有 5 种类型的表格：<ul>
<li>MyISAM</li>
<li>Heap</li>
<li>Merge</li>
<li>INNODB</li>
<li>ISAM</li>
</ul>
</li>
</ul>
<h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul>
<li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li>
<li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li>
</ul>
<h1 id="myisamchk-是用来做什么的？"><a href="#myisamchk-是用来做什么的？" class="headerlink" title="myisamchk 是用来做什么的？"></a>myisamchk 是用来做什么的？</h1><ul>
<li>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。</li>
</ul>
<h1 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h1><ul>
<li>在 MyISAM Static 上的所有字段有固定宽度</li>
<li>动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。</li>
<li>MyISAM Static 在受损情况下更容易恢复。</li>
</ul>
<h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><ul>
<li>每当行被更改时，时间戳字段将获取当前时间戳。</li>
</ul>
<h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><ul>
<li>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</li>
</ul>
<h1 id="数据库架构原则"><a href="#数据库架构原则" class="headerlink" title="数据库架构原则"></a>数据库架构原则</h1><ul>
<li>高可用</li>
<li>高性能</li>
<li>一致性</li>
<li>扩展性</li>
</ul>
<h1 id="常见的数据库架构方案"><a href="#常见的数据库架构方案" class="headerlink" title="常见的数据库架构方案"></a>常见的数据库架构方案</h1><h4 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h4><ul>
<li>只有主库提供读写服务，备库冗余作故障转移用</li>
<li>高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库</li>
<li>这个过程对业务层是透明的，无需修改代码或配置。 </li>
<li>高性能分析：读写都操作主库，很容易产生瓶颈</li>
<li>大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能</li>
<li>另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 </li>
<li>一致性分析：读写都操作主库，不存在数据一致性问题。 </li>
<li>扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 </li>
<li>可落地分析：两点影响落地使用<ul>
<li>第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案</li>
<li>第二，扩展性差，这点可以通过分库分表来扩展。</li>
</ul>
</li>
</ul>
<h4 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h4><ul>
<li>两个主库同时提供服务，负载均衡</li>
<li>高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务</li>
<li>这个过程对业务层是透明的，无需修改代码或配置。 </li>
<li>高性能分析：读写性能相比于方案一都得到提升，提升一倍。</li>
<li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li>
<li>扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）</li>
<li>如果非得在数据库架构层面扩展的话，扩展为方案四。 </li>
<li>可落地分析：两点影响落地使用<ul>
<li>第一，数据一致性问题，一致性解决方案可解决问题</li>
<li>第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。</li>
</ul>
</li>
</ul>
<h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><ul>
<li>一主多从，读写分离</li>
<li>高可用分析：主库单点，从库高可用</li>
<li>一旦主库挂了，写服务也就无法提供。 </li>
<li>高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能</li>
<li>读的性能提高了，整体性能也提高了。</li>
<li>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引</li>
<li>线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引</li>
<li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li>
<li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。</li>
<li>带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长）</li>
<li>可落地分析：两点影响落地使用<ul>
<li>第一，数据一致性问题，一致性解决方案可解决问题</li>
<li>第二，主库单点问题，笔者暂时没想到很好的解决方案。</li>
</ul>
</li>
<li>思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？</li>
</ul>
<h4 id="双主-主从架构"><a href="#双主-主从架构" class="headerlink" title="双主+主从架构"></a>双主+主从架构</h4><ul>
<li>看似完美的方案</li>
<li>高可用分析：高可用。 </li>
<li>高性能分析：高性能。 </li>
<li>一致性分析：存在数据一致性问题。请看，一致性解决方案 。</li>
<li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） </li>
<li>可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。</li>
</ul>
<h1 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h1><h4 id="主库和从库一致性解决方案"><a href="#主库和从库一致性解决方案" class="headerlink" title="主库和从库一致性解决方案"></a>主库和从库一致性解决方案</h4><ul>
<li>数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的</li>
<li>这个同步时间内主库和从库的数据会存在不一致的情况</li>
<li>如果同步过程中有读请求，那么读到的就是从库中的老数据。</li>
<li>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<ul>
<li>直接忽略，如果业务允许延时存在，那么就不去管它。 </li>
<li>强制读主，采用主备架构方案，读写都走主库</li>
<li>用缓存来扩展数据库读性能</li>
<li>有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</li>
</ul>
</li>
<li>选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。</li>
<li>读请求时，同样的方式生成key先去查Cache，再判断是否命中</li>
<li>若命中，则读主库，否则读从库</li>
<li>代价是多了一次缓存读写，基本可以忽略。</li>
<li>半同步复制，等主从同步完成，写请求才返回</li>
<li>就是大家常说的“半同步复制”semi-sync</li>
<li>这可以利用数据库原生功能，实现比较简单</li>
<li>代价是写请求时延增长，吞吐量降低。 </li>
<li>数据库中间件，引入开源（mycat等）或自研的数据库中间层</li>
<li>个人理解，思路同选择读主</li>
<li>数据库中间件的成本比较高，并且还多引入了一层</li>
</ul>
<h4 id="DB和缓存一致性解决方案"><a href="#DB和缓存一致性解决方案" class="headerlink" title="DB和缓存一致性解决方案"></a>DB和缓存一致性解决方案</h4><ul>
<li>先来看一下常用的缓存使用方式：<ul>
<li>第一步：淘汰缓存；</li>
<li>第二步：写入数据库；</li>
<li>第三步：读取缓存？返回：读取数据库；</li>
<li>第四步：读取数据库后写入缓存。</li>
</ul>
</li>
<li>注：如果按照这种方式，不会产生DB和缓存不一致问题，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据</li>
<li>设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！</li>
<li>加缓存和索引是通用的提升数据库性能的方式； </li>
<li>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。</li>
<li>阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。</li>
</ul>
<p> </p>
<h1 id="主从数据库不一致如何解决"><a href="#主从数据库不一致如何解决" class="headerlink" title="主从数据库不一致如何解决"></a>主从数据库不一致如何解决</h1><ul>
<li>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</li>
<li>忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</li>
<li>强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</li>
<li>选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</li>
</ul>
<h1 id="说出数据连接池的工作机制是什么"><a href="#说出数据连接池的工作机制是什么" class="headerlink" title="说出数据连接池的工作机制是什么?"></a>说出数据连接池的工作机制是什么?</h1><ul>
<li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接</li>
<li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙</li>
<li>如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定</li>
<li>当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</li>
</ul>
<h1 id="数据库创建索引的缺点？"><a href="#数据库创建索引的缺点？" class="headerlink" title="数据库创建索引的缺点？"></a>数据库创建索引的缺点？</h1><ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<h1 id="说一下数据库的存储过程？"><a href="#说一下数据库的存储过程？" class="headerlink" title="说一下数据库的存储过程？"></a>说一下数据库的存储过程？</h1><ul>
<li>存储过程与函数的区别：<ul>
<li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。</li>
<li>对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。</li>
<li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。</li>
</ul>
</li>
<li>存储过程的优点：<ul>
<li>执行速度更快 – 在数据库中保存的存储过程语句都是编译过的</li>
<li>允许模块化程序设计 – 类似方法的复用</li>
<li>提高系统安全性 – 防止SQL注入</li>
<li>减少网络流通量 – 只要传输存储过程的名称</li>
</ul>
</li>
<li>系统存储过程一般以sp开头，用户自定义的存储过程一般以usp开头</li>
</ul>
<h1 id="什么是基本表，什么是视图，两者的区别和联系是什么？"><a href="#什么是基本表，什么是视图，两者的区别和联系是什么？" class="headerlink" title="什么是基本表，什么是视图，两者的区别和联系是什么？"></a>什么是基本表，什么是视图，两者的区别和联系是什么？</h1><ul>
<li>它是从一个或几个基本表中导出的 表，是从现有基本表中抽取若干子集组成用户的“专用表”。</li>
<li>基本表：基本表的定义指建立基本关系模式,</li>
<li>而变更则是指对数据库中已存在的基本表进行删除与修改。</li>
<li>区别：<ul>
<li>视图是已经编译好的 sql 语句。而表不是</li>
<li>视图没有实际的物理记录。而表有。</li>
<li>表是内容，视图是窗口</li>
<li>表只用物理空间而视图不占用物理空间，</li>
</ul>
</li>
<li>视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改</li>
<li>表是内模式，试图是外模式</li>
<li>视图是查看数据表的一种方法，</li>
<li>可以查询数据表中某些字段构成的数据，</li>
<li>只是一些 SQL 语句的集合。从安全的角度说，</li>
<li>视图可以不给用户接触数据表，从而不知道表结构。</li>
<li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li>
<li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li>
<li>联系<ul>
<li>视图（view）是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。</li>
<li>视图是基本表的抽象和在逻辑意义上建立的新关系</li>
</ul>
</li>
</ul>
<h1 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM"></a>什么是 ORM</h1><ul>
<li>对象关系映射(Object Relation Mapping，简称 ORM)模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术</li>
<li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中</li>
<li>那么到底如何实现持久化呢？一种简单的方案时采用硬编码方式(jdbc 操作 sql 方式)，为每一种可能的数据库访问操作提供单独的方法。</li>
<li>这种方案存在以下不足：<ul>
<li>持久化层缺乏弹性，一旦出现业务需求变更，就必须修改持久化层的接口</li>
<li>持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层的相关程序代码，增加软件的维护难度。</li>
</ul>
</li>
<li>ORM 提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得 ORM 中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁，Java 典型的 ORM 框架有：Hibernate，ibatis(mybtis)，speedframework。</li>
<li>ORM 框架的方法论基于三个核心原则：<ul>
<li>简单：以最基本的形式建模数据</li>
<li>传达性：数据库结构被任何人都能理解的语言文档化</li>
<li>精确性：基于数据模型创建正确标准化了结构</li>
</ul>
</li>
</ul>
<h1 id="数据库连接池的原理"><a href="#数据库连接池的原理" class="headerlink" title="数据库连接池的原理"></a>数据库连接池的原理</h1><ul>
<li>传统连接方式:<ul>
<li>首先调用 Class.forName()方法加载数据库驱动，</li>
<li>然后调用 DriverManager.getConnection()方法建立连接.</li>
</ul>
</li>
<li>连接池技术:<ul>
<li>连接池解决方案是在应用程序启动时就预先建立多个数据库连接对象,然后将连接对象保存到连接池中。</li>
<li>当客户请求到来时,从池中取出一个连接对象为客户服务。</li>
<li>当请求完成时,客户程序调用 close()方法,将连接对象放回池中. </li>
<li>对于多于连接池中连接数的请求，排队等待。</li>
<li>应用程序还可根据连接池中连接的使用率，动态增加或减少池中的连接数。</li>
</ul>
</li>
</ul>
<h1 id="什么是纵向切分-垂直切分？"><a href="#什么是纵向切分-垂直切分？" class="headerlink" title="什么是纵向切分&#x2F;垂直切分？"></a>什么是纵向切分&#x2F;垂直切分？</h1><ul>
<li>就是把原本存储于一个库的数据存储到多个库上。</li>
<li>由于对数据库的读写都是对同一个库进行操作，所以单库并不能解决大规模并发写入的问题。</li>
<li>例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</li>
<li>优点<ul>
<li>减少增量数据写入时的锁对查询的影响。</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘 IO，时延变短。</li>
</ul>
</li>
<li>缺点：无法解决单表数据量太大的问题。</li>
</ul>
<h4 id="横向切分-水平切分"><a href="#横向切分-水平切分" class="headerlink" title="横向切分&#x2F;水平切分"></a>横向切分&#x2F;水平切分</h4><ul>
<li>把原本存储于一个表的数据分块存储到多个表上。当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，进行划分，然后存储到多个结构相同的表，和不同的库上。</li>
<li>例如，我们 userDB 中的 userTable 中数据量很大，那么可以把 userDB 切分为结构相同的多个 userDB：part0DB、part1DB 等，再将 userDB 上的 userTable，切分为很多userTable：userTable0、userTable1 等，然后将这些表按照一定的规则存储到多个 userDB上。</li>
<li>优点：<ul>
<li>单表的并发能力提高了，磁盘 I&#x2F;O 性能也提高了。</li>
<li>如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。</li>
</ul>
</li>
<li>缺点：无法实现表连接查询</li>
</ul>
<h1 id="什么是-MyCat？"><a href="#什么是-MyCat？" class="headerlink" title="什么是 MyCat？"></a>什么是 MyCat？</h1><ul>
<li>MyCat 是目前最流行的基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分离。</li>
<li>MyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。</li>
<li>MyCat 发展到目前的版本，已经不是一个单纯的 MySQL 代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL 等主流数据库，也支持 MongoDB 这种新型 NoSQL 方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那种存储方式，在 MyCat 里，都是一个传统的数据库表，支持标准的 SQL 语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度。</li>
</ul>
<h1 id="请说出两种以上扩大数据库的方式"><a href="#请说出两种以上扩大数据库的方式" class="headerlink" title="请说出两种以上扩大数据库的方式"></a>请说出两种以上扩大数据库的方式</h1><ul>
<li>修改现有表空间的大小；</li>
<li>向表空间插入一个新的数据文件</li>
</ul>
<h1 id="事务是什么？有哪些属性，并简要说明这些属性的含义"><a href="#事务是什么？有哪些属性，并简要说明这些属性的含义" class="headerlink" title="事务是什么？有哪些属性，并简要说明这些属性的含义"></a>事务是什么？有哪些属性，并简要说明这些属性的含义</h1><ul>
<li>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如 SQL，C++或 Java）书写的用户程序的执行所引起，并用形如 begin transaction 和 end transaction 语句（或函数调用）来界定。</li>
<li>事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。</li>
<li>事务应该具有 4 个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为 ACID特性。原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>
<h1 id="MyBatis-和-hibernate-的区别有哪些？"><a href="#MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="MyBatis 和 hibernate 的区别有哪些？"></a>MyBatis 和 hibernate 的区别有哪些？</h1><ul>
<li>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</li>
<li>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</li>
<li>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</li>
<li>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</li>
</ul>
<h1 id="Statement-PreparedStatement-CallableStatment-的区别。"><a href="#Statement-PreparedStatement-CallableStatment-的区别。" class="headerlink" title="Statement,PreparedStatement,CallableStatment 的区别。"></a>Statement,PreparedStatement,CallableStatment 的区别。</h1><ul>
<li>区别有以下几点：</li>
<li>Statement 是 PreparedStatement 和 CallableStatement 的父类；</li>
<li>Statement 是直接发送 Sql 语句到数据库，事先没有进行预编译。 PreparedStatement会将 sql 进行预编译，当 sql 语句要重复执行时，数据库会调用以前预编译好的 sql 语句，所以 PreparedStatement 在性能方面会更好；</li>
<li>PreparedStatement 在执行 sql 时，对传入的参数可以进行强制的类型转换。以保证数据格式与底层的数据库格式一致。</li>
<li>CallableStatement 适用与存储过程的查询表达语句</li>
</ul>
<h1 id="JDBC-为什么要使用-PreparedStatement-而不是-Statement"><a href="#JDBC-为什么要使用-PreparedStatement-而不是-Statement" class="headerlink" title="JDBC 为什么要使用 PreparedStatement 而不是 Statement"></a>JDBC 为什么要使用 PreparedStatement 而不是 Statement</h1><ul>
<li>PreparedStatement 是 用 来 执 行 SQL 查 询 语 句 的 API 之 一 ， Java 提 供 了 Statement 、PreparedStatement 和 CallableStatement 三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement 则是用于存储过程。</li>
</ul>
<h1 id="触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别："><a href="#触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：" class="headerlink" title="触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别："></a>触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：</h1><ul>
<li>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。</li>
<li>语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。</li>
</ul>
<h1 id="游标的作用？如何知道游标已经到了最后："><a href="#游标的作用？如何知道游标已经到了最后：" class="headerlink" title="游标的作用？如何知道游标已经到了最后："></a>游标的作用？如何知道游标已经到了最后：</h1><ul>
<li>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。</li>
</ul>
<h1 id="数据库中常用术语："><a href="#数据库中常用术语：" class="headerlink" title="数据库中常用术语："></a>数据库中常用术语：</h1><ul>
<li>ddl:数据定义语言 Create Drop Alter</li>
<li>dml:数据操纵语言 insert update delete select</li>
<li>dcl:数据控制语言 grant revoke</li>
<li>tcl:事务控制语言 commit rollback</li>
</ul>
<h1 id="NULL-是什么意思"><a href="#NULL-是什么意思" class="headerlink" title="NULL 是什么意思"></a>NULL 是什么意思</h1><ul>
<li>NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这个值的任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比较，并在逻辑上希望获得一个答案。</li>
<li>使用 IS NULL 来进行 NULL 判断‘</li>
</ul>
<h1 id="什么是基本表？什么是视图？"><a href="#什么是基本表？什么是视图？" class="headerlink" title="什么是基本表？什么是视图？"></a>什么是基本表？什么是视图？</h1><ul>
<li>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表</li>
</ul>
<h1 id="试述视图的优点？"><a href="#试述视图的优点？" class="headerlink" title="试述视图的优点？"></a>试述视图的优点？</h1><ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据；</li>
<li>视图为数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护。</li>
</ul>
<h1 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h1><ul>
<li>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。</li>
</ul>
<h1 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a>完整性约束包括哪些？</h1><ul>
<li>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</li>
<li>分为以下四类：<ul>
<li>实体完整性：规定表的每一行在表中是惟一的实体。</li>
<li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li>
<li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li>
<li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li>
</ul>
</li>
<li>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、<br>foreign key、check、UNIQUE) 。</li>
</ul>
<h1 id="解释-MySQL-外连接、内连接与自连接的区别"><a href="#解释-MySQL-外连接、内连接与自连接的区别" class="headerlink" title="解释 MySQL 外连接、内连接与自连接的区别"></a>解释 MySQL 外连接、内连接与自连接的区别</h1><ul>
<li>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</li>
<li>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。</li>
<li>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</li>
<li>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。</li>
</ul>
<h1 id="SQL-注入漏洞产生的原因？如何防止？"><a href="#SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL 注入漏洞产生的原因？如何防止？"></a>SQL 注入漏洞产生的原因？如何防止？</h1><ul>
<li>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。</li>
<li>防止 SQL 注入的方式：<ul>
<li>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置</li>
<li>执行 sql 语句时使用 addslashes 进行 sql 语句转换Sql 语句书写尽量不要省略双引号和单引号。</li>
<li>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。</li>
<li>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/publishes/98f0d77a0556.html</url>
    <content><![CDATA[<h1 id="说⼀下⼏种常⻅的排序算法和分别的复杂度"><a href="#说⼀下⼏种常⻅的排序算法和分别的复杂度" class="headerlink" title="说⼀下⼏种常⻅的排序算法和分别的复杂度"></a>说⼀下⼏种常⻅的排序算法和分别的复杂度</h1><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了.<ul>
<li>选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。</li>
<li>基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的分在右边。</li>
<li>可以肯定，如此⼀轮下来，这个枢轴的位置⼀定在最终位置上。</li>
<li>对两个⼦数组分别重复上述过程，直到每个数组只有⼀个元素。</li>
<li>排序完成。</li>
</ul>
</li>
<li>复杂度：O(n)</li>
<li>特点：快速排序是我们平常最常使⽤的⼀种排序算法,因为它速度快,效率⾼,是最优秀的⼀种排序算法.</li>
</ul>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li>原理：冒泡排序其实就是逐⼀⽐较交换,进⾏⾥外两次循环,外层循环为遍历所有数字,逐个确定每个位置,⾥层循环为确定了位置后,遍历所有后⾯没有确定位置的数字,与该位置的数字进⾏⽐较,只要⽐该位置的数字⼩,就和该位置的数字进⾏交换.</li>
<li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li>
<li>特点：冒泡排序在我们实际开发中,使⽤的还是⽐较少的.它更加适合数据规模⽐较少的时候,因为它的效率是⽐较低的,但是优点是逻辑简单,容易让我们记得.</li>
</ul>
<h4 id="直接插⼊排序"><a href="#直接插⼊排序" class="headerlink" title="直接插⼊排序"></a>直接插⼊排序</h4><ul>
<li>原理：直接插⼊排序是将从第⼆个数字开始,逐个拿出来,插⼊到之前排好序的数列⾥.</li>
<li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li>
</ul>
<h4 id="直接选择排序："><a href="#直接选择排序：" class="headerlink" title="直接选择排序："></a>直接选择排序：</h4><ul>
<li>原理：直接选择排序是从第⼀个位置开始遍历位置,找到剩余未排序的数据⾥最⼩的,找到最⼩的后,再做交换</li>
<li>复杂度：O(n^2)</li>
<li>特点：和冒泡排序⼀样,逻辑简单,但是效率不⾼,适合少量的数据排序</li>
</ul>
<h1 id="描述⼀下链式存储结构"><a href="#描述⼀下链式存储结构" class="headerlink" title="描述⼀下链式存储结构"></a>描述⼀下链式存储结构</h1><ul>
<li>线性结构的优点是可以实现随机读取，时间复杂度为O(1)，空间利⽤率⾼，缺点是进⾏插⼊和删除操作时⽐较麻烦，时间复杂度为O(n)，同时容量受限制，需要事先确定容量⼤⼩，容量过⼤，浪费空间资源，过⼩不能满⾜使⽤要求，会产⽣溢出问题。</li>
<li>链式存储结构的优点主要是插⼊和删除⾮常简单，前提条件是知道操作位置，时间复杂度是O(1)，但如果不知道操作位置则要定位元素，时间复杂度为O(n)，没有容量的限制，可以使⽤过程中动态分配的分配内存空间，不⽤担⼼溢出问题，但是它并不能实现随机读取，同时空间利⽤率不⾼。</li>
</ul>
<h1 id="如何遍历⼀颗⼆叉树"><a href="#如何遍历⼀颗⼆叉树" class="headerlink" title="如何遍历⼀颗⼆叉树"></a>如何遍历⼀颗⼆叉树</h1><ul>
<li>先输出节点的值，再递归遍历左右⼦树。中序和后序的递归类似，改变根节点输出位置即可。</li>
</ul>
<h1 id="倒排⼀个LinkedList"><a href="#倒排⼀个LinkedList" class="headerlink" title="倒排⼀个LinkedList"></a>倒排⼀个LinkedList</h1><ul>
<li>Collections.reverse(linkedList);</li>
</ul>
<h1 id="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"><a href="#⽤java写⼀个递归遍历⽬录下⾯的所有⽂件" class="headerlink" title="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"></a>⽤java写⼀个递归遍历⽬录下⾯的所有⽂件</h1><ul>
<li>File.listFiles()</li>
</ul>
<h1 id="⼆叉树与红⿊树："><a href="#⼆叉树与红⿊树：" class="headerlink" title="⼆叉树与红⿊树："></a>⼆叉树与红⿊树：</h1><h4 id="⼆叉树"><a href="#⼆叉树" class="headerlink" title="⼆叉树"></a>⼆叉树</h4><ul>
<li>左⼦树上所有结点的值均⼩于或等于它的根结点的值。</li>
<li>右⼦树上所有结点的值均⼤于或等于它的根结点的值。</li>
<li>左、右⼦树也分别为⼆叉排序树。</li>
<li>查找：⼆分查找（通过⼀层⼀层的⽐较⼤⼩来查找位置）：如查找值为10的节点：9–13–11–10</li>
<li>缺陷：插⼊容易变成线性形态，查找性能⼤打折扣，这时需要引⼊红⿊树来解决</li>
</ul>
<h4 id="红⿊树"><a href="#红⿊树" class="headerlink" title="红⿊树"></a>红⿊树</h4><ul>
<li>特点：是⼀种⾃平衡的⼆叉查找树，除了符合⼆叉树的特点之外，还符合以下⼏点：<ul>
<li>节点是红⾊或⿊⾊。</li>
<li>根节点是⿊⾊。</li>
<li>每个叶⼦节点都是⿊⾊的空节点（NIL节点）。</li>
<li>每个红⾊节点的两个⼦节点都是⿊⾊。(从每个叶⼦到根的所有路径上不能有两个连续的红⾊节点)</li>
<li>从任⼀节点到其每个叶⼦的所有路径都包含相同数⽬的⿊⾊节点。</li>
</ul>
</li>
<li>这些规则保证了红⿊树的⾃平衡。</li>
<li>红⿊树从根到叶⼦的最长路径不会超过最短路径的2倍。</li>
<li>提⾼寻址效率。</li>
<li>添加删除：通过⾃旋来保证平衡</li>
</ul>
<h1 id="b-tree、b-tree多叉树："><a href="#b-tree、b-tree多叉树：" class="headerlink" title="b-tree、b+tree多叉树："></a>b-tree、b+tree多叉树：</h1><h4 id="b-tree"><a href="#b-tree" class="headerlink" title="b-tree"></a>b-tree</h4><ul>
<li>⽂件系统</li>
<li>B树也称B-树,它是⼀颗多路平衡查找树</li>
<li>我们描述⼀颗B树时需要指定它的阶数，阶数表示了⼀个结点最多有多少个孩⼦结点，⼀般⽤字⺟m表示阶数</li>
<li>当m取2时，就是我们常⻅的⼆叉搜索树。</li>
<li>定义：<ul>
<li>每个结点最多有m-1个关键字。</li>
<li>根结点最少可以只有1个关键字。</li>
<li>⾮根结点⾄少有Math.ceil(m&#x2F;2)-1个关键字。</li>
<li>每个结点中的关键字都按照从⼩到⼤的顺序排列，每个关键字的左⼦树中的所有关键字都⼩于它，⽽右⼦树中的所有关键字都⼤于它。</li>
<li>所有叶⼦结点都位于同⼀层，或者说根结点到每个叶⼦结点的⻓度都相同。</li>
</ul>
</li>
<li>插⼊数据，向兄弟节点借，兄弟节点不够则向⽗节点借；</li>
</ul>
<h4 id="b-tree-1"><a href="#b-tree-1" class="headerlink" title="b+tree"></a>b+tree</h4><ul>
<li>mysql索引</li>
<li>定义：<ul>
<li>B+树包含2种类型的结点：内部结点（也称索引结点）和叶⼦结点。根结点本身即可以是内部结点，也可以是叶⼦结点。根结点的关键字个数最少可以只有1个。</li>
<li>B+树与B树最⼤的不同是内部结点不保存数据，只⽤于索引，所有数据（或者说记录）都保存在叶⼦结点中。</li>
<li>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个⼦树），阶数m同时限制了叶⼦结点最多存储m-1个记录。</li>
<li>内部结点中的key都按照从⼩到⼤的顺序排列，对于内部结点中的⼀个key，左树中的所有key都⼩于它，右⼦树中的key都⼤于等于它。叶⼦结点中的记录也按照key的⼤⼩排列。</li>
<li>每个叶⼦结点都存有相邻叶⼦结点的指针，叶⼦结点本身依关键字的⼤⼩⾃⼩⽽⼤顺序链接。</li>
</ul>
</li>
</ul>
<h1 id="谈谈数据结构，⽐如TreeMap："><a href="#谈谈数据结构，⽐如TreeMap：" class="headerlink" title="谈谈数据结构，⽐如TreeMap："></a>谈谈数据结构，⽐如TreeMap：</h1><ul>
<li>TreeMap实现了红⿊树的结构。</li>
</ul>
<h1 id="图的深度遍历和⼴度遍历"><a href="#图的深度遍历和⼴度遍历" class="headerlink" title="图的深度遍历和⼴度遍历"></a>图的深度遍历和⼴度遍历</h1><ul>
<li>深度优先遍历：深度优先遍历尽可能优先往深层次进⾏搜索</li>
<li>⼴度优先遍历：⼴度优先遍历按层次优先搜索最近的结点，⼀层⼀层往外搜索。</li>
</ul>
<h1 id="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"><a href="#说说java集合，每个集合下⾯有哪些实现类，及其数据结构" class="headerlink" title="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"></a>说说java集合，每个集合下⾯有哪些实现类，及其数据结构</h1><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li>概念<ul>
<li>在HashMap内部，采⽤了数组+链表的形式来组织键值对Entry&lt;Key,Value&gt;（利⽤数组的查询快+链表的插⼊删除快）</li>
<li>HashMap在存储键值对Entry&lt;Key,Value&gt;的时候，会根据Key的hashcode值，以某种映射关系，决定应当将这对键值对Entry&lt;Key,Value&gt;存储在HashMap中的什么位置上</li>
<li>在JDK1.7进⾏多线程put操作，之后遍历，直接死循环，CPU飙到100%，在JDK 1.8中进⾏多线程操作会出现节点和value值丢失，为什么JDK1.7与JDK1.8多线程操作会出现很⼤不同，是因为JDK 1.8的作者对resize⽅法进⾏了优化不会产⽣链表闭环。</li>
</ul>
</li>
<li>结构</li>
<li>HashMap扩容<ul>
<li>很简单的计算：由于默认的加载因⼦是0.75 ，那么，此时map的阀值是 16*0.75 &#x3D; 12，即添加第13 个键值对&lt;Key,Value&gt;的时候，map的容量会扩充⼀倍。</li>
<li>确实如此，但是为了尽可能第减少桶中的Entry&lt;Key,Value&gt;链表的长度，以提⾼HashMap的存取性能，确定的这个经验值</li>
</ul>
</li>
<li>扩容步骤：<ul>
<li>申请⼀个新的、⼤⼩为当前容量两倍的数组；</li>
<li>将旧数组的Entry[] table中的链表重新计算hash值，然后重新均匀地放置到新的扩充数组中；</li>
<li>释放旧的数组；</li>
</ul>
</li>
<li>为何扩容为原来的两倍（性能）：<ul>
<li>在HashMap通过键的哈希值进⾏定位桶位置的时候，调⽤了⼀个indexFor(hash, table.length);⽅法。</li>
<li>通过限制length是⼀个2的幂数，h &amp; (length-1)和h % length结果是⼀致的。</li>
<li>如果length是⼀个2的幂的数，那么length-1就会变成⼀个mask, 它会将hashcode低位取出来，</li>
<li>hashcode的低位实际就是余数，和取余操作相⽐，与操作会将性能提升很多。</li>
</ul>
</li>
<li>put流程<ul>
<li>获取这个Key的hashcode值，根据此值确定应该将这⼀对键值对存放在哪⼀个桶中，即确定要存放桶的索引；</li>
<li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul>
<li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,其中的Value值更新为新的Value值；返回旧值；</li>
<li>若不存在，则根据键值对&lt;Key,Value&gt; 创建⼀个新的Entry&lt;Key,Value&gt;对象，然后添加到这个桶的Entry&lt;Key,Value&gt;</li>
</ul>
</li>
<li>当前的HashMap的⼤⼩(即Entry&lt;key,Value&gt;节点的数⽬)是否超过了阀值，若超过了阀值(threshold)，</li>
<li>则增⼤HashMap的容量(即Entry[] table 的⼤⼩)，并且重新组织内部各个Entry&lt;Key,Value&gt;排列。</li>
</ul>
</li>
<li>get流程<ul>
<li>获取这个Key的hashcode值，根据此hashcode值决定应该从哪⼀个桶中查找；</li>
<li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul>
<li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,返回value</li>
<li>若不存在，返回null；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>红黑树是一种自平衡二叉查找树</li>
<li>它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用</li>
<li>它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。</li>
</ul>
<h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><ul>
<li>红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡</li>
<li>它的每个节点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父节点）。</li>
<li>红黑树的定义也是它的性质，有以下五条：<ul>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>所有叶子都是黑色（叶子是NIL节点）</li>
<li>如果一个节点是红的，则它的两个儿子都是黑的</li>
<li>从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
</li>
<li>这五个性质强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</li>
<li>为什么呢？性质4暗示着任何一个简单路径上不能有两个毗连的红色节点，这样，最短的可能路径全是黑色节点，最长的可能路径有交替的红色和黑色节点。同时根据性质5知道：所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</li>
</ul>
<h4 id="红黑树的基本操作"><a href="#红黑树的基本操作" class="headerlink" title="红黑树的基本操作"></a>红黑树的基本操作</h4><ul>
<li>因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同</li>
<li>然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质</li>
<li>恢复红黑树的性质需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)</li>
<li>虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次。</li>
</ul>
<h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><ul>
<li>插入操作可以概括为以下几个步骤：<ul>
<li>查找要插入的位置，时间复杂度为：O(N)</li>
<li>将新节点的color赋为红色</li>
<li>自下而上重新调整该树为红黑树</li>
</ul>
</li>
<li>其中，第(1)步的查找方法跟普通二叉查找树一样</li>
<li>第(2)步之所以将新插入的节点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的</li>
<li>但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整，这样简单多了</li>
<li>下面讨论步骤(3)的一些细节：<ul>
<li>设要插入的节点为N，其父节点为P，其父亲G的兄弟节点为U（即P和U是同一个节点的两个子节点）。</li>
<li>如果P是黑色的，则整棵树不必调整便是红黑树。</li>
<li>如果P是红色的（可知，其父节点G一定是黑色的），则插入z后，违背了性质4，需要进行调整</li>
<li>调整时分以下3种情况：<ul>
<li>N的叔叔U是红色的</li>
<li>N的叔叔U是黑色的，且N是右孩子</li>
<li>N的叔叔U是黑色的，且N是左孩子</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><ul>
<li>删除操作可以概括为以下几个步骤：<ul>
<li>查找要删除位置，时间复杂度为：O(N)</li>
<li>用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点）</li>
<li>如果删除节点的替换节点为黑色，则需重新调整该树为红黑树</li>
</ul>
</li>
<li>其中，第(1)步的查找方法跟普通二叉查找树一样</li>
<li>第(2)步之所以用后继节点替换删除节点，是因为这样可以保证该后继节点之上仍是一个红黑树，而后继节点可能是一个叶节点或者只有右子树的节点，这样只需用有节点替换后继节点即可达到删除的目的</li>
<li>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题</li>
<li>在第(3)步中，如果，如果删除节点为红色节点，则他的父亲和孩子全为黑节点，这样直接删除该节点即可，不必进行任何调整</li>
<li>如果删除节点是黑节点，分四种情况：<ul>
<li>设要删除的节点为N，其父节点为P，其兄弟节点为S。</li>
<li>由于N是黑色的，则P可能是黑色的，也可能是红色的，S也可能是黑色的或者红色的</li>
<li>S是红色的</li>
<li>S和S的孩子全是黑色的</li>
<li>S是黑色的，S的左孩子是红色，右孩子是黑色</li>
<li>S是黑色的，S的右孩子是红色</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>版本管理工具</title>
    <url>/publishes/aa3500b67dae.html</url>
    <content><![CDATA[<h1 id="svn和git的区别及适用场景"><a href="#svn和git的区别及适用场景" class="headerlink" title="svn和git的区别及适用场景"></a>svn和git的区别及适用场景</h1><h4 id="svn的优势"><a href="#svn的优势" class="headerlink" title="svn的优势"></a>svn的优势</h4><ul>
<li>优异的跨平台支持，对windows平台支持非常友好。</li>
<li>简单易用，安装后稍微培训下就知道怎么操作。</li>
<li>代码，需求，文档，涉及稿都可以用svn进行管理，适合不同部门的技术非技术的同事协作。</li>
</ul>
<h4 id="git的优势"><a href="#git的优势" class="headerlink" title="git的优势"></a>git的优势</h4><ul>
<li>去中心化：Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容是完全一样的（格式有点不同，是bare的）。虽然平时大家都是将代码提交到中央服务器上再统一pull别人的代码，但实际情况你可以总是pull张三的库，然后push给李四等等操作。</li>
<li>本地提交：本地提交好处主要有3点：<ul>
<li>一， 断网提交 </li>
<li>二， 小步提交。可以对自己的阶段成果有跟踪，并且提高每次变更的安全性</li>
<li>三，本地库。这个和断网提交是同一个实现，但从需求角度出发则略有不同，主要是说即使只有自己一个人开发项目，也可以轻易的让自己的代码有版本跟踪，而不需要去费力建个什么svn server。</li>
<li>四，本地回滚。这个其实是由于本地库的存在而产生的，但可以减少中央库上的冗余版本</li>
</ul>
</li>
<li>分支策略：在Git实际开发中分支的分离和merge是属于日常操作，开启和合并分支成本相比SVN要小得多：SVN是复制一份代码到分支目录，Git则是在分支点做一下标记。随便一次冲突就会自动产生分支，所以大家每天都在与分支打交道。这便是弱化了分支的概念，由于分支成本很小，因此使得按功能分支的开发模式（每个分支一个功能，开发完了再merge到主干）变得非常简单，大家可以完全不需要再因为担心SCM成本太高而选用主干开发模式（所有功能都在主干上开发，到了发版本前再分离出分支）。</li>
</ul>
<h4 id="两者的工作流对比"><a href="#两者的工作流对比" class="headerlink" title="两者的工作流对比"></a>两者的工作流对比</h4><h5 id="svn模式"><a href="#svn模式" class="headerlink" title="svn模式"></a>svn模式</h5><ul>
<li>写代码。</li>
<li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li>
<li>将本地代码提交到服务器。</li>
</ul>
<h5 id="git模式"><a href="#git模式" class="headerlink" title="git模式"></a>git模式</h5><ul>
<li>写代码。</li>
<li>提交到本地版本库。</li>
<li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li>
<li>将远程库与本地代码合并结果提交到本地版本库。</li>
<li>将本地版本库推到服务器。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>对比可以看出：分布式版本管理仅仅是增加了本地库这个概念，其余的概念与集中管理并无区别。——但是 svn 在与服务器同步之前无法提交代码，因而本地修改更容易出问题。</li>
<li>当研发成本比较低，协作开发人数不多，开发人员对于版本管理的水平参差不齐的时候，或者对于代码的安全性要求更高一点的时候，适合用svn。</li>
<li>而对于很多人参与开发，代码量比较大，或者高频次协作，跨公司，跨地域合作的情况下，更适合用git。</li>
</ul>
]]></content>
      <categories>
        <category>版本管理工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/publishes/fca1d6209800.html</url>
    <content><![CDATA[<h1 id="TCP建⽴连接的过程。"><a href="#TCP建⽴连接的过程。" class="headerlink" title="TCP建⽴连接的过程。"></a>TCP建⽴连接的过程。</h1><h4 id="三次握⼿"><a href="#三次握⼿" class="headerlink" title="三次握⼿"></a>三次握⼿</h4><ul>
<li>第⼀次握⼿(客户端发送syn包到服务器端)：客户端发送syn包到服务器端，进⼊syn_send状态，等待服务器端的确认；</li>
<li>第⼆次握⼿(服务器返回syn+ack包给客户端)：服务器端收到客户端的syn包，发送syn+ack包给客户端，进⼊syn_recv状态；</li>
<li>第三次握⼿(客服端返回ack包给服务端)：客户端收到服务器端的syn+ack包，发送个ack包到服务器端，⾄此，客户端与服务器端进⼊established状态；</li>
<li>握⼿过程中传送的包不包含任何数据，连接建⽴后才会开始传送数据，理想状态下，TCP连接⼀旦建⽴，在通信双⽅的任何⼀⽅主动关闭连接前，TCP连接都会⼀直保持下去。</li>
</ul>
<h1 id="TCP断开连接的过程。"><a href="#TCP断开连接的过程。" class="headerlink" title="TCP断开连接的过程。"></a>TCP断开连接的过程。</h1><h4 id="四次握⼿"><a href="#四次握⼿" class="headerlink" title="四次握⼿"></a>四次握⼿</h4><ul>
<li>第⼀次握⼿：主动关闭⽅发送fin包到被动关闭⽅，告诉被动关闭⽅我不会再给你发送数据了；</li>
<li>第⼆次握⼿：被动关闭⽅收到syn包，发送ack给对⽅，确认序号为收到序号+1；</li>
<li>第三次握⼿：被动关闭⽅也也发送fin包给主动关闭⽅，告诉对⽅我也不会给你发送数据了；</li>
<li>第四次握⼿：主动关闭⽅收到syn包，发送ack给对⽅，⾄此，完成四次握⼿；</li>
</ul>
<h1 id="浏览器发⽣302跳转背后的逻辑"><a href="#浏览器发⽣302跳转背后的逻辑" class="headerlink" title="浏览器发⽣302跳转背后的逻辑"></a>浏览器发⽣302跳转背后的逻辑</h1><ul>
<li>浏览器在原请求地址的响应的Location域找到要跳转的URI执⾏跳转。</li>
</ul>
<h4 id="浏览器输⼊URL后发⽣了什么"><a href="#浏览器输⼊URL后发⽣了什么" class="headerlink" title="浏览器输⼊URL后发⽣了什么"></a>浏览器输⼊URL后发⽣了什么</h4><ul>
<li>DNS域名解析；</li>
<li>建⽴TCP连接；</li>
<li>发送HTTP请求；</li>
<li>服务器处理请求；</li>
<li>返回响应结果；</li>
<li>关闭TCP连接；</li>
<li>浏览器解析HTML；</li>
<li>浏览器布局渲染；</li>
</ul>
<h1 id="HTTP协议的交互流程。-HTTP和HTTPS的差异，-SSL的交互流程？"><a href="#HTTP协议的交互流程。-HTTP和HTTPS的差异，-SSL的交互流程？" class="headerlink" title="HTTP协议的交互流程。 HTTP和HTTPS的差异， SSL的交互流程？"></a>HTTP协议的交互流程。 HTTP和HTTPS的差异， SSL的交互流程？</h1><h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h4><ul>
<li>建⽴TCP连接；</li>
<li>发送HTTP请求；</li>
<li>服务器处理请求；</li>
<li>返回响应结果；</li>
<li>关闭TCP连接；</li>
</ul>
<h5 id="http三次握⼿："><a href="#http三次握⼿：" class="headerlink" title="http三次握⼿："></a>http三次握⼿：</h5><ul>
<li>第⼀次握⼿：客户端发送syn包(syn&#x3D;j)到服务器，并进⼊SYN_SEND状态，等待服务器确认；</li>
<li>第⼆次握⼿：服务器收到syn包，必须确认客户的SYN（ack&#x3D;j+1），同时⾃⼰也发送⼀个SYN包（syn&#x3D;k），即<br>SYN+ACK包，此时服务器进⼊SYN_RECV状态；</li>
<li>第三次握⼿：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进⼊ESTABLISHED状态，完成三次握⼿。</li>
</ul>
<h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><ul>
<li>TTPS协议就是基于SSL的HTTP协议</li>
<li>HTTPS使⽤与HTTP不同的端⼝（HTTPS80 ， HTTPSS443）</li>
<li>提供了身份验证与加密通信⽅法，被⼴泛⽤于互联⽹上安全敏感的通信。</li>
<li>客户端请求SSL连接，并将⾃⼰⽀持的加密规则发给⽹站。</li>
<li>服务器端将⾃⼰的身份信息以证书形式发回给客户端。证书⾥⾯包含了⽹站地址，加密公钥，以及证书的颁发机构。</li>
<li>获得证书后，客户要做以下⼯作<ul>
<li>验证证书合法性</li>
<li>如果证书受信任，客户端会⽣成⼀串随机数的密码，并⽤证书提供的公钥进⾏加密。</li>
<li>将加密好的随机数发给服务器。</li>
<li>获得到客户端发的加密了的随机数之后，服务器⽤⾃⼰的私钥进⾏解密，得到这个随机数，把这个随机数作为对称加密的密钥。（利⽤⾮对称加密传输对称加密的密钥）</li>
<li>之后服务器与客户之间就可以⽤随机数对各⾃的信息进⾏加密，解密。</li>
</ul>
</li>
<li>注意的是：证书是⼀个公钥，这个公钥是进⾏加密⽤的。⽽私钥是进⾏解密⽤的。公钥任何都知道，私钥只有⾃⼰知道。这是⾮对称加密。⽽对称加密就是钥匙只有⼀把，我们都知道。</li>
<li>之所以⽤到对称加密，是因为对称加密的速度更快。⽽⾮对称加密的可靠性更⾼。</li>
<li>客户端请求–服务端发送证书（公钥）–客户端验证证书，并⽣成随机数，通过公钥加密后发送给服务端–服务端⽤私钥解密出随机数–对称加密传输数据。</li>
</ul>
<h4 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h4><ul>
<li>HTTPS协议需要申请证书。</li>
<li>HTTP是明⽂传输；HTTPS使⽤的是具有安全性的SSL加密传输协议</li>
<li>HTTP端⼝是80；HTTPS端⼝号是443</li>
<li>HTTP连接简单⽆状态；HTTPS由SSL+HTTP协议构件的可进⾏加密传输、身份验证的⽹络协议。</li>
</ul>
<h4 id="Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解"><a href="#Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解" class="headerlink" title="Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解?"></a>Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解?</h4><ul>
<li>Http是⼀种协议，Rest是⼀种软件架构⻛格。</li>
<li>URL定位资源，⽤HTTP动词（GET,POST,DELETE,DETC）描述操作。</li>
<li>GET表示查询、POST表示新建、PUT表示更新、DELETE表示删除等。<ul>
<li>GET &#x2F;api&#x2F;v1&#x2F;user 获取⽤户列表</li>
<li>GET &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 获取ID为1的⽤户</li>
<li>POST &#x2F;api&#x2F;v1&#x2F;user 新建⽤户</li>
<li>PUT &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 更新ID为1的⽤户信息</li>
<li>DELETE &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 删除ID为1的⽤户</li>
</ul>
</li>
<li>概念：REST（英⽂：Representational State Transfer，简称REST，表现层状态转化），指的是⼀组架构约束条件和原则。满⾜这些约束条件和原则的应⽤程序或设计就是 RESTful。</li>
<li>⼀种软件架构⻛格，设计⻛格⽽不是标准，只是提供了⼀组设计原则和约束条件。它主要⽤于客户端和服务器交互类的软件。基于这个⻛格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li>
<li>Restful架构：<ul>
<li>每⼀个URI代表⼀种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>客户端通过四个HTTP动词(GET⽤来获取资源，POST⽤来新建资源（也可以⽤于更新资源），PUT⽤来更新资源，DELETE⽤来删除资源。)，对服务器端资源进⾏操作，实现”表现层状态转化”。</li>
</ul>
</li>
</ul>
<h1 id="TCP的滑动窗⼝协议有什么⽤？讲讲原理。"><a href="#TCP的滑动窗⼝协议有什么⽤？讲讲原理。" class="headerlink" title="TCP的滑动窗⼝协议有什么⽤？讲讲原理。"></a>TCP的滑动窗⼝协议有什么⽤？讲讲原理。</h1><ul>
<li>滑动窗⼝协议是传输层进⾏流控的⼀种措施，接收⽅通过通告发送⽅⾃⼰的窗⼝⼤⼩，从⽽控制发送⽅的发送速度，从⽽达到防⽌发送⽅发送速度过快⽽导致来不及接受。</li>
</ul>
<h1 id="HTTP协议都有哪些⽅法？"><a href="#HTTP协议都有哪些⽅法？" class="headerlink" title="HTTP协议都有哪些⽅法？"></a>HTTP协议都有哪些⽅法？</h1><ul>
<li>GET 请求获取由Request-URI所标识的资源。</li>
<li>POST 在Request-URI所标识的资源后附加新的数据。</li>
<li>HEAD 请求获取由Request-URI所标识的资源的响应消息报头。</li>
<li>OPTIONS 请求查询服务器的性能，或查询与资源相关的选项和需求。</li>
<li>PUT 请求服务器存储⼀个资源，并⽤Request-URI作为其标识。</li>
<li>DELETE 请求服务器删除由Request-URI所标识的资源。</li>
<li>TRACE 请求服务器回送收到的请求信息，主要⽤语测试或诊断。</li>
</ul>
<h1 id="交换机与路由器的区别？"><a href="#交换机与路由器的区别？" class="headerlink" title="交换机与路由器的区别？"></a>交换机与路由器的区别？</h1><h4 id="⼯作层次不同"><a href="#⼯作层次不同" class="headerlink" title="⼯作层次不同"></a>⼯作层次不同</h4><ul>
<li>最初的交换机⼯作在OSI模型中的数据链路层，⼯作原理简单</li>
<li>路由器⼯作在OSI模型中的⽹络层，得更多协议信息，做更智能的转发决策</li>
</ul>
<h4 id="数据转发所依据的对象不同"><a href="#数据转发所依据的对象不同" class="headerlink" title="数据转发所依据的对象不同"></a>数据转发所依据的对象不同</h4><ul>
<li>交换机是利⽤物理地址（MAC地址），确定转发的⽬的地址。（MAC固化硬件，⼀般不可更改）</li>
<li>路由器是利⽤IP地址，确定转发的⽬的地址。（IP通常为⽹关或p系统⾃动分配的）</li>
</ul>
<h4 id="是否可以分割⼴播域"><a href="#是否可以分割⼴播域" class="headerlink" title="是否可以分割⼴播域"></a>是否可以分割⼴播域</h4><ul>
<li>传统的交换机可以分割冲突域，不能分割⼴播域，⽽路由器可以分割⼴播域</li>
<li>由交换机连接的⽹段仍然属于同⼀⼴播域，⼴播数据报会在交换机连接的所有⽹段上传播，某些情况导致通信拥堵和安全漏洞。</li>
<li>连接到路由器上的⽹段被分配成不同的⼴播域，所以，⼴播数据不穿过路由器</li>
<li>虽然三层交换机可以分割⼴播域，但是⼦⼴播域之间不能通信，还是需要路由器</li>
</ul>
<h4 id="路由器提供了防⽕墙的服务"><a href="#路由器提供了防⽕墙的服务" class="headerlink" title="路由器提供了防⽕墙的服务"></a>路由器提供了防⽕墙的服务</h4><ul>
<li>路由器仅仅转发特定地址的数据包，不传送不⽀持路由协议的数据包，不传送未知⽬标⽹络数据包，从⽽可以防⽌⼴播⻛暴</li>
</ul>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul>
<li>⼆层交换机上存在MAC表，三层交换机上存在路由表、MAC表、ARP表，路由器上存在路由表和ARP表。</li>
<li>总之，交换机在具体的城域⽹中扮演着VLAN透传的⻆⾊，就是桥。</li>
<li>路由器的每⼀个端⼝都是⼀个独⽴的⼴播域和冲突域，⽽交换机是只有⼀个⼴播域和端⼝数量的冲突域。</li>
</ul>
<h1 id="Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？"><a href="#Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？" class="headerlink" title="Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？"></a>Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？</h1><h4 id="socket⽹络通信"><a href="#socket⽹络通信" class="headerlink" title="socket⽹络通信"></a>socket⽹络通信</h4><ul>
<li>NIO流以及多线程处理技术：</li>
<li>BIO:阻塞式，线程池初始时创建⼀定量线程，超过则等待；</li>
<li>NIO:⾮阻塞式，不同的线程⼲专业的事情，提⾼系统吞吐量；</li>
<li>NIO+异步处理：让少量的线程做⼤量的事情；</li>
</ul>
<h4 id="Mina"><a href="#Mina" class="headerlink" title="Mina"></a>Mina</h4><ul>
<li>Apache Mina是⼀个能够帮助⽤户开发⾼性能和⾼伸缩性⽹络应⽤程序的框架。</li>
<li>它通过Java nio技术基于TCP&#x2F;IP和UDP&#x2F;IP协议提供了抽象的、事件驱动的、异步的API</li>
<li>采⽤⾮阻塞⽅式的异步传输，⽀持批量传输数据</li>
<li>mina框架简单⾼效，完成了底层的线程管理，内置编码器能够满⾜⼤多数⽤户的需求，省去了消息编码和解码的⼯作。</li>
</ul>
<h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><ul>
<li>本质是JBoss开发的⼀个jar包，⽬的是开发⾼性能、⾼可靠性的⽹络服务和客户端服务</li>
<li>提供异步⾮阻塞的、事件驱动的⽹络应⽤程序的NIO框架和⼯具</li>
<li>处理socket</li>
<li>通过Future-Listener机制，⽤户可以⽅便的主动获取或者通过通知机制获得IO操作结果。</li>
</ul>
<h1 id="http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）"><a href="#http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）" class="headerlink" title="http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）"></a>http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>HTTP协议是Hyper Text Transfer Protocol（超⽂本传输协议）的缩写,是⽤于从万维⽹（WWW:World Wide Web ）服务器传输超⽂本到本地浏览器的传送协议。</li>
<li>HTTP是⼀个基于TCP&#x2F;IP通信协议来传递数据（HTML ⽂件, 图⽚⽂件, 查询结果等）。</li>
<li>HTTP是⼀个属于应⽤层的⾯向对象的协议，由于其简捷、快速的⽅式，适⽤于分布式超媒体信息系统。它于1990年提出，经过⼏年的使⽤与发展，得到不断地完善和扩展。⽬前在WWW中使⽤的是HTTP&#x2F;1.0的第六版，HTTP&#x2F;1.1的规范化⼯作正在进⾏之中，⽽且HTTP-NG(Next Generation of HTTP)的建议已经提出。</li>
<li>HTTP协议⼯作于客户端-服务端架构为上。</li>
<li>浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求</li>
<li>Web服务器根据接收到的请求后，向客户端发送响应信息。</li>
</ul>
<h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul>
<li>简单快速：客户向服务器请求服务时，只需传送请求⽅法和路径。请求⽅法常⽤的有GET、HEAD、POST。每种⽅法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模⼩，因⽽通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>⽆连接：⽆连接的含义是限制每次连接只处理⼀个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采⽤这种⽅式可以节省传输时间。</li>
<li>⽆状态：HTTP协议是⽆状态协议。⽆状态是指协议对于事务处理没有记忆能⼒。缺少状态意味着如果后续处理需要前⾯的信息，则它必须重传，这样可能导致每次连接传送的数据量增⼤。另⼀⽅⾯，在服务器不需要先前信息时它的应答就较快。</li>
<li>⽀持B&#x2F;S及C&#x2F;S模式。</li>
</ul>
<h1 id="get与post区别"><a href="#get与post区别" class="headerlink" title="get与post区别"></a>get与post区别</h1><ul>
<li>表单的method如果为get,那么所有的参数信息都会显示在浏览器的地址栏，当我们使⽤浏览器地址栏输⼊⽹址的⽅式来发送请求时,那么该请求⼀定是get⽅式</li>
<li>对于get⽅式,底层是将所有参数附加在请求资源的后⾯⼀起传递的，对于post⽅式,底层是将所有参数附加在请求参数的最后⼀⾏的下⼀⾏的下⼀⾏，Get请求的数据是被附在url之后（HTTP协议头中），POST请求数据则放置在HTTP包的包体head中；</li>
<li>对于get,post⽅式,servlet不同处理：doGet()，doPost();</li>
<li>浏览器处理：重复访问使⽤GET⽅法请求的⻚⾯，浏览器会使⽤缓存处理后续请求。使⽤POST⽅法的form提交时，浏览器基于POST将产⽣永久改变的假设，将让⽤户进⾏提交确认。</li>
</ul>
<h1 id="rpc和http的区别，使⽤场景"><a href="#rpc和http的区别，使⽤场景" class="headerlink" title="rpc和http的区别，使⽤场景"></a>rpc和http的区别，使⽤场景</h1><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h5><ul>
<li>RPC，可以基于TCP协议，也可以基于HTTP协议</li>
<li>HTTP，基于HTTP协议</li>
</ul>
<h5 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h5><ul>
<li>RPC，使⽤⾃定义的TCP协议，可以让请求报⽂体积更⼩，或者使⽤HTTP2协议，也可以很好的减少报⽂的体积，提⾼传输效率</li>
<li>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多⽆⽤的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为⼀个RPC来使⽤的，这时标准RPC框架更多的是服务治理性能消耗，主要在于序列化和反序列化的耗时<br>RPC，可以基于thrift实现⾼效的⼆进制传输</li>
<li>HTTP，⼤部分是通过json来实现的，字节⼤⼩和序列化耗时都⽐thrift要更消耗性能</li>
</ul>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><ul>
<li>RPC，基本都⾃带了负载均衡策略</li>
<li>HTTP，需要配置Nginx，HAProxy来实现</li>
</ul>
<h5 id="服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）"><a href="#服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）" class="headerlink" title="服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）"></a>服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）</h5><ul>
<li>RPC，能做到⾃动通知，不影响上游</li>
<li>HTTP，需要事先通知，修改Nginx&#x2F;HAProxy配置</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。</li>
<li>HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。</li>
</ul>
<h1 id="说说TCP-UDP和socket-Http之间联系和区别"><a href="#说说TCP-UDP和socket-Http之间联系和区别" class="headerlink" title="说说TCP,UDP和socket,Http之间联系和区别"></a>说说TCP,UDP和socket,Http之间联系和区别</h1><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><ul>
<li>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。</li>
<li>在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。</li>
<li>在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。</li>
<li>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</li>
</ul>
<h5 id="TCP的优点"><a href="#TCP的优点" class="headerlink" title="TCP的优点"></a>TCP的优点</h5><ul>
<li>可靠，稳定</li>
<li>TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</li>
</ul>
<h5 id="TCP的缺点"><a href="#TCP的缺点" class="headerlink" title="TCP的缺点"></a>TCP的缺点</h5><ul>
<li>慢，效率低，占用系统资源高，易被攻击</li>
<li>TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。<br>由于TCP存在确认机制和三次握手机制，这些是导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</li>
</ul>
<h5 id="TCP应用场景"><a href="#TCP应用场景" class="headerlink" title="TCP应用场景"></a>TCP应用场景</h5><ul>
<li>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</li>
<li>在日常生活中，常见使用TCP协议的应用比如：浏览器使用HTTP，Outlook使用POP、SMTP，QQ文件传输等。</li>
</ul>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><ul>
<li>U- DP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。</li>
</ul>
<h5 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h5><ul>
<li>快，比TCP稍安全</li>
<li>UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……</li>
</ul>
<h5 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h5><ul>
<li>不可靠，不稳定</li>
<li>因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</li>
</ul>
<h5 id="UDP应用场景"><a href="#UDP应用场景" class="headerlink" title="UDP应用场景"></a>UDP应用场景</h5><ul>
<li>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。在日常生活中，常见使用UDP协议的应用比如：QQ语音、QQ视频、TFTP等。</li>
<li>TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。</li>
<li>TCP&#x2F;IP是个协议组，可分为三个层次：网络层、传输层和应用层。<ul>
<li>在网络层有：IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。</li>
<li>在传输层中有：TCP协议与UDP协议。</li>
<li>在应用层有：FTP、HTTP、TELNET、SMTP、DNS等协议。</li>
</ul>
</li>
<li>因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。</li>
<li>TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。</li>
<li>虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。</li>
</ul>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><ul>
<li>HTTP（超文本传输协议）是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。</li>
<li>HTTP是短连接：客户端发送请求都需要服务器端回送响应.请求结束后，主动释放链接，因此为短连接。通常的做法是，不需要任何数据，也要保持每隔一段时间向服务器发送”保持连接”的请求。这样可以保证客户端在服务器端是”上线”状态。</li>
<li>HTTP连接使用的是”请求-响应”方式，不仅在请求时建立连接，而且客户端向服务器端请求后，服务器才返回数据。</li>
</ul>
<h4 id="Socket协议"><a href="#Socket协议" class="headerlink" title="Socket协议"></a>Socket协议</h4><ul>
<li>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</li>
<li>建立网络通信连接至少要一对端口号（socket）。socket本质是编程接口（API），对TCP&#x2F;IP的封装，TCP&#x2F;IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</li>
</ul>
<h1 id="TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由"><a href="#TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由" class="headerlink" title="TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由"></a>TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由</h1><ul>
<li>三次握手是为了防止已失效的连接请求再次传送到服务器端</li>
<li>二次握手不可行，因为：如果由于网络不稳定，虽然客户端以前发送的连接请求已到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。</li>
</ul>
<h1 id="HTTP协议工作原理及其特点"><a href="#HTTP协议工作原理及其特点" class="headerlink" title="HTTP协议工作原理及其特点"></a>HTTP协议工作原理及其特点</h1><ul>
<li>超文本传输协议（HTTP：Hypertext Transport Protocol）是万维网应用层的协议，它通过两个程序实现：一个是客户端程序（各种浏览器），另一个是服务器 （常称Web服务器）。这两个通常运行在不同的主机上，通过交换报文来完成网页请求和响应，报文可简单分为请求报文和响应报文。</li>
<li>工作原理（流程）：<ul>
<li>客户机与服务器建立连接后，浏览器可以向web服务器发送请求并显示收到的网页，当用户在浏览器地址栏中输入一个URL或点击一个超连接时，浏览器就向服务器发出了HTTP请求，请求方式的格式为：统一资源标识符、协议版本号，后边是MIME（Multipurpose Internet Mail Extensions）信息包括请求修饰符、客户机信息和可能的内容</li>
<li>该请求被送往由URL指定的WEB服务器，WEB服务器接收到请求后，进行相应反映，其格式为：一个状态行包括信息的协议版本号、一个成功或错误的代码，后边服务器信息、实体信息和可能的内容</li>
<li>即以HTTP规定的格式送回所要求的文件或其他相关信息，再由用户计算机上的浏览器负责解释和显示</li>
</ul>
</li>
<li>特点：<ul>
<li>支持客户&#x2F;服务器模式。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ul>
</li>
</ul>
<h1 id="介绍OSI七层模型和TCP-IP模型"><a href="#介绍OSI七层模型和TCP-IP模型" class="headerlink" title="介绍OSI七层模型和TCP&#x2F;IP模型"></a>介绍OSI七层模型和TCP&#x2F;IP模型</h1><ul>
<li>OSI(Open System Interconnection)，开放式系统互联参考模型</li>
<li>是一个逻辑上的定义，一个规范，它把网络协议从逻辑上分为了7层</li>
<li>每一层都有相关、相对应的物理设备，比如常规的路由器是三层交换设备，常规的交换机是二层交换设备</li>
<li>OSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输</li>
<li>它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。</li>
<li>TCP&#x2F;IP协议是Internet最基本的协议、Internet国际互联网络的基础，主要由网络层的IP协议和传输层的TCP协议组成</li>
<li>TCP&#x2F;IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准</li>
<li>协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
<li>ISO制定的OSI参考模型的过于庞大、复杂招致了许多批评。伴随着互联网的流行，其本身所采用的TCP&#x2F;IP协议栈获得了更为广泛的应用和认可。在TCP&#x2F;IP参考模型中，去掉了OSI参考模型中的会话层和表示层（这两层的功能被合并到应用层实现）。同时将OSI参考模型中的数据链路层和物理层合并为主机到网络层</li>
</ul>
<h1 id="TCP协议和UDP协议的比较"><a href="#TCP协议和UDP协议的比较" class="headerlink" title="TCP协议和UDP协议的比较"></a>TCP协议和UDP协议的比较</h1><ul>
<li>TCP和UDP是TCP&#x2F;IP协议栈中传输层的两个协议，它们使用IP路由功能把数据包发送到目的地，从而为应用程序及应用层协议（包括：HTTP、SMTP、SNMP、FTP和Telnet）提供网络服务。</li>
<li>TCP的server和client之间通信就好比两个人打电话，需要互相知道对方的电话号码，然后开始对话。所以在两者的连接过程中间需要指定端口和地址。</li>
<li>UDP的server和client之间的通信就像两个人互相发信。我只需要知道对方的地址，然后就发信过去。对方是否收到我不知道，也不需要专门对口令似的来建立连接</li>
<li>具体区别如下：<ul>
<li>TCP是面向连接的传输。UDP是无连接的传输</li>
<li>TCP有流量控制、拥塞控制，检验数据数据按序到达，而UDP则相反。</li>
<li>TCP的路由选择只发生在建立连接的时候，而UDP的每个报文都要进行路由选择</li>
<li>TCP是可靠性传输，他的可靠性是由超时重发机制实现的，而UDP则是不可靠传输</li>
<li>UDP因为少了很多控制信息，所以传输速度比TCP速度快</li>
<li>TCP适合用于传输大量数据，UDP适合用于传输小量数据</li>
</ul>
</li>
</ul>
<h1 id="IP-TCP-UDP-HTTP-TCP-IP-Socket"><a href="#IP-TCP-UDP-HTTP-TCP-IP-Socket" class="headerlink" title="IP,TCP,UDP,HTTP,TCP&#x2F;IP,Socket"></a>IP,TCP,UDP,HTTP,TCP&#x2F;IP,Socket</h1><ul>
<li>IP 协议，为计算机网络相互连接进行通信而设计的协议。</li>
<li>TCP&#x2F;UDP 协议，基于二进制流的控制间传输协议。 TCP 是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但 TCP 的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性；而 UDP 不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说 UDP 是无连接的、不可靠的一种数据传输协议。</li>
<li>HTTP 协议，超文本传送协议(Hypertext Transfer Protocol )，HTTP 协议是建立在</li>
<li>TCP 协议之上的一种应用。</li>
<li>IP 协议对应于网络层，TCP 协议对应于传输层，而 HTTP 协议对应于应用层。注意</li>
<li>TPC&#x2F;IP 位于传输层，它主要用来解决数据如何在网络中传输，与 IP 协议要区分开。</li>
<li>IP 协议规定网络之间互连的协议；TPC&#x2F;IP 协议是传输层协议，主要解决数据如何在网络中传输；HTTP 是应用层协议，主要用于包装数据。</li>
<li>Socket 相当于调用接口(API)，用来调取 TCP&#x2F;IP 协议。</li>
</ul>
<h1 id="先来一个讲-TCP、UDP-和-HTTP-关系的"><a href="#先来一个讲-TCP、UDP-和-HTTP-关系的" class="headerlink" title="先来一个讲 TCP、UDP 和 HTTP 关系的"></a>先来一个讲 TCP、UDP 和 HTTP 关系的</h1><ul>
<li>TCP&#x2F;IP 是个协议组，可分为三个层次：网络层、传输层和应用层。</li>
<li>在网络层有 IP 协议、ICMP 协议、ARP 协议、RARP 协议和 BOOTP 协议。</li>
<li>在传输层中有 TCP 协议与 UDP 协议。</li>
<li>在应用层有 FTP、HTTP、TELNET、SMTP、DNS 等协议。</li>
<li>因此，HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。</li>
<li>HTTP 协议是建立在请求&#x2F;响应模型上的。首先由客户建立一条与服务器的 TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME 样式的消息。服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的 MIME 式样的消息。</li>
<li>HTTP&#x2F;1.0 为每一次 HTTP 的请求&#x2F;响应建立一条新的 TCP 链接，因此一个包含 HTML内容和图片的页面将需要建立多次的短期的 TCP 链接。一次 TCP 链接的建立将需要 3次握手。</li>
<li>另外，为了获得适当的传输速度，则需要 TCP 花费额外的回路链接时间（RTT）。每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，因此 HTTP&#x2F;1.1 提出了可持续链接的实现方法。HTTP&#x2F;1.1 将只建立一次 TCP的链接而重复地使用它传输一系列的请求&#x2F;响应消息，因此减少了链接建立的次数和经常性的链接开销。</li>
<li>结论：虽然 HTTP 本身是一个协议，但其最终还是基于 TCP 的。不过，目前，有人正在研究基于 TCP+UDP 混合的 HTTP 协议。</li>
</ul>
<h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><ul>
<li>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</li>
<li>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>tcp</tag>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/publishes/4f75e46c0d1c.html</url>
    <content><![CDATA[<h1 id="⼯⼚⽅法模式"><a href="#⼯⼚⽅法模式" class="headerlink" title="⼯⼚⽅法模式"></a>⼯⼚⽅法模式</h1><ul>
<li>利⽤创建同⼀接⼝的不同实例</li>
</ul>
<h4 id="普通⼯⼚模式"><a href="#普通⼯⼚模式" class="headerlink" title="普通⼯⼚模式"></a>普通⼯⼚模式</h4><ul>
<li>建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SendFactory &#123;</span><br><span class="line">    public Sender produce(String type) &#123;</span><br><span class="line">        if (&quot;mail&quot;.equals(type)) &#123;</span><br><span class="line">            return new MailSender();</span><br><span class="line">        &#125; else if (&quot;sms&quot;.equals(type)) &#123;</span><br><span class="line">            return new SmsSender();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;请输⼊正确的类型!&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多个⼯⼚⽅法模式"><a href="#多个⼯⼚⽅法模式" class="headerlink" title="多个⼯⼚⽅法模式"></a>多个⼯⼚⽅法模式</h4><ul>
<li>提供多个⼯⼚⽅法，分别创建对象；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SendFactory &#123;</span><br><span class="line">    public Sender produceMail()&#123;</span><br><span class="line">        return new MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">    public Sender produceSms()&#123;</span><br><span class="line">        return new SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态⼯⼚⽅法模式"><a href="#静态⼯⼚⽅法模式" class="headerlink" title="静态⼯⼚⽅法模式"></a>静态⼯⼚⽅法模式</h4><ul>
<li>将上⾯的多个⼯⼚⽅法置为静态的，不需要创建⼯⼚实例，直接调⽤即可；</li>
</ul>
<h4 id="适⽤场景"><a href="#适⽤场景" class="headerlink" title="适⽤场景"></a>适⽤场景</h4><ul>
<li>凡是出现了⼤量不同种类的产品需要创建，并且具有共同的接⼝时，可以通过⼯⼚⽅法模式进⾏创建</li>
<li>在以上的三种模式中，第⼀种如果传⼊的字符串有误，不能正确创建对象，第三种相对于第⼆种，不需要实例化⼯⼚类，所以，⼤多数情况下，我们会选⽤第三种——静态⼯⼚⽅法模式。</li>
</ul>
<h1 id="抽象⼯⼚模式"><a href="#抽象⼯⼚模式" class="headerlink" title="抽象⼯⼚模式"></a>抽象⼯⼚模式</h1><ul>
<li>多个⼯⼚</li>
<li>创建多个⼯⼚类，提⾼⼯⼚的扩展性，不⽤像上⾯⼀样如果增加产品则要去修改唯⼀的⼯⼚类；</li>
</ul>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul>
<li>保证对象只有⼀个实例</li>
<li>保证在⼀个 JVM 中，该对象只有⼀个实例存在；</li>
</ul>
<h4 id="适⽤场景："><a href="#适⽤场景：" class="headerlink" title="适⽤场景："></a>适⽤场景：</h4><ul>
<li>某些类创建⽐较频繁，对于⼀些⼤型的对象，这是⼀笔很⼤的系统开销。</li>
<li>省去了 new 操作符，降低了系统内存的使⽤频率，减轻 GC 压⼒。</li>
<li>有些类如交易所的核⼼交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。所以只有使⽤单例模式，才能保证核⼼交易服务器独⽴控制整个流程。</li>
</ul>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul>
<li>类初始化时创建单例，线程安全，适⽤于单例占内存⼩的场景，否则推荐使⽤懒汉式延迟加载；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton newInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul>
<li>需要创建单例实例的时候再创建，需要考虑线程安全(性能不太好)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static synchronized Singleton newInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h4><ul>
<li>效率⾼</li>
<li>解决问题：假如两个线程 A、B，A 执⾏了 if (instance &#x3D;&#x3D; null)语句，它会认为单例对象没有创建，此时线程切到 B 也执⾏了同样的语句，B 也认为单例对象没有创建，然后两个线程依次执⾏同步代码块，并分别创建了⼀个单例对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance = null;//volatile 的⼀个语义是禁⽌指令重排序优化</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;//2</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态内部类⽅式"><a href="#静态内部类⽅式" class="headerlink" title="静态内部类⽅式"></a>静态内部类⽅式</h4><ul>
<li>可以同时保证延迟加载和线程安全<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        public static Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton newInstance()&#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ul>
<li>使⽤枚举除了线程安全和防⽌反射调⽤构造器之外，还提供了⾃动序列化机制，防⽌反序列化的时候创建新的对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    instance;</span><br><span class="line">    public void whateverMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><ul>
<li>将⼀个对象作为原型，对其进⾏复制、克隆，产⽣⼀个和元对象类似的新对象；</li>
<li>核⼼：它的核⼼是原型类 Prototype，需要实现 Cloneable 接⼝，和重写 Object 类中的 clone ⽅法；</li>
<li>作⽤：使⽤原型模式创建对象⽐直接 new ⼀个对象在性能上要好的多，因为 Object 类的 clone ⽅法是⼀个本地⽅法，它直接操作内存<br>中的⼆进制流，特别是复制⼤对象时，性能的差别⾮常明显。</li>
</ul>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><ul>
<li>接⼝兼容</li>
<li>将某个类的接⼝转换成客户端期望的另⼀个接⼝表示，⽬的是消除由于接⼝不匹配所造成的类的兼容性问题。</li>
<li>类的适配器模式</li>
<li>对象的适配器模式</li>
<li>接⼝的适配器模式</li>
</ul>
<h4 id="使⽤场景"><a href="#使⽤场景" class="headerlink" title="使⽤场景"></a>使⽤场景</h4><ul>
<li>类的适配器模式：当希望将⼀个类转换成满⾜另⼀个新接⼝的类时，可以使⽤类的适配器模式，创建⼀个新类，继承原有的类，<br>实现新的接⼝即可。</li>
<li>对象的适配器模式：当希望将⼀个对象转换成满⾜另⼀个新接⼝的对象时，可以创建⼀个 Wrapper 类，持有原类的⼀个实例，在<br>Wrapper 类的⽅法中，调⽤实例的⽅法就⾏。</li>
<li>接⼝的适配器模式：当不希望实现⼀个接⼝中所有的⽅法时，可以创建⼀个抽象类 Wrapper，实现所有⽅法，我们写别的类的时<br>候，继承抽象类即可。</li>
</ul>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><ul>
<li>装饰模式就是给⼀个对象增加⼀些新的功能，⽽且是动态的，要求装饰对象和被装饰对象实现同⼀个接⼝，装饰对象持有被装饰对象的实例：</li>
</ul>
<h4 id="使⽤场景："><a href="#使⽤场景：" class="headerlink" title="使⽤场景："></a>使⽤场景：</h4><ul>
<li>需要扩展⼀个类的功能</li>
<li>动态的为⼀个对象增加功能，⽽且还能动态撤销。（继承不能做到这⼀点，继承的功能是静态的，不能动态增删。）</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><ul>
<li>持有被代理类的实例，进⾏操作前后控制</li>
<li>采⽤⼀个代理类调⽤原有的⽅法，且对产⽣的结果进⾏控制。</li>
</ul>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><ul>
<li>集合所有操作到⼀个类</li>
<li>外观模式是为了解决类与类之间的依赖关系的，像 spring ⼀样，可以将类和类之间的关系配置到配置⽂件中</li>
<li>⽽外观模式就是将他们的关系放在⼀个 Facade 类中，降低了类类之间的耦合度。</li>
</ul>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><ul>
<li>数据库驱动桥接</li>
<li>桥接模式就是把事物和其具体实现分开，使他们可以各⾃独⽴的变化</li>
<li>桥接的⽤意是：将抽象化与实现化解耦，使得⼆者可以独⽴变化，像我们常⽤的 JDBC 桥 DriverManager ⼀样，JDBC 进⾏连接数据库的时候，在各个数据库之间进⾏切换，基本不需要动太多的代码，甚⾄丝毫不⽤动，原因就是 JDBC 提供统⼀接⼝，每个数据库提供各⾃的实现，⽤⼀个叫做数据库驱动的程序来桥接就⾏了。</li>
</ul>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><ul>
<li>部分整体模式</li>
<li>组合模式有时⼜叫部分-整体模式在处理类似树形结构的问题时⽐较⽅便。</li>
</ul>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><ul>
<li>共享池、数据库连接池</li>
<li>享元模式的主要⽬的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与⼯⼚模式⼀起使⽤</li>
<li>当⼀个客户端请求时，⼯⼚需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建⼀个新对象，如数据库连接池；</li>
</ul>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><ul>
<li>多种算法封装</li>
<li>策略模式定义了⼀系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使⽤算法的客户</li>
<li>需要设计⼀个接⼝，为⼀系列实现类提供统⼀的⽅法，多个实现类实现该接⼝：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ICalculator cal = new Plus(); //ICalculator 是统⼀接⼝，Plus 是实现类(多个)</span><br><span class="line">int result = cal.calculate(exp); //jvm 根据实现类不同⽽调⽤不同实现类的⽅法</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="模板⽅法模式"><a href="#模板⽅法模式" class="headerlink" title="模板⽅法模式"></a>模板⽅法模式</h1><ul>
<li>抽象⽅法作为⻣架，具体逻辑让⼦类实现</li>
<li>定义⼀个操作中算法的框架，⽽将⼀些步骤延迟到⼦类中，使得⼦类可以不改变算法的结构即可重定义该算法中的某些特定步骤</li>
<li>完成公共动作和特殊动作的分离。</li>
</ul>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><ul>
<li>发布-订阅模式</li>
<li>当⼀个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是⼀种⼀对多的关系</li>
<li>类似于邮件订阅和 RSS 订阅，当你订阅了该⽂章，如果后续有更新，会及时通知你。</li>
</ul>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><ul>
<li>遍历集合</li>
<li>迭代器模式就是顺序访问聚集中的对象</li>
</ul>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><ul>
<li>多任务形成⼀条链，请求在链上传递</li>
<li>有多个对象，每个对象持有对下⼀个对象的引⽤，这样就会形成⼀条链，请求在这条链上传递，直到某⼀对象决定处理该请求</li>
<li>但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进⾏动态的调整。</li>
</ul>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><ul>
<li>实现请求和执⾏的解耦</li>
<li>命令模式的⽬的就是达到命令的发出者和执⾏者之间解耦，实现请求和执⾏分开，熟悉 Struts 的同学应该知道，Struts 其实就是⼀种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</li>
</ul>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><ul>
<li>保存和恢复对象状态</li>
<li>主要⽬的是保存⼀个对象的某个状态，以便在适当的时候恢复对象</li>
</ul>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><ul>
<li>对象状态改变时改变其⾏为</li>
<li>当对象的状态改变时，同时改变其⾏为</li>
<li>状态模式就两点<ul>
<li>可以通过改变状态来获得不同的⾏为</li>
<li>你的好友能同时看到你的变化</li>
</ul>
</li>
</ul>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><ul>
<li>数据接⼝稳定，但算法易变</li>
<li>访问者模式把数据结构和作⽤于结构上的操作解耦合，使得操作集合可相对⾃由地演化</li>
<li>访问者模式适⽤于数据结构相对稳定算法⼜易变化的系统</li>
<li>因为访问者模式使得算法操作增加变得容易</li>
<li>访问者模式就是⼀种分离对象数据结构与⾏为的⽅法，通过这种分离，可达到为⼀个被访问者动态添加新的操作⽽⽆需做其它的修改的效果</li>
</ul>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><ul>
<li>中介者模式也是⽤来降低类类之间的耦合的</li>
<li>如果使⽤中介者模式，只需关⼼和 Mediator 类的关系</li>
<li>具体类类之间的关系及调度交给 Mediator 就⾏，这有点像 spring 容器的作⽤。</li>
</ul>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><ul>
<li>对于⼀些固定⽂法构建⼀个解释句⼦的解释器，如正则表达式</li>
<li>解释器模式⽤来做各种各样的解释器，如正则表达式等的解释器。</li>
</ul>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><ul>
<li>创建复合对象</li>
<li>⼯⼚类模式提供的是创建单个类的模式，⽽建造者模式则是将各种产品集中起来进⾏管理，⽤来创建复合对象，所谓复合对象就是指某个类具有不同的属性</li>
</ul>
<h1 id="设计模式的六⼤原则："><a href="#设计模式的六⼤原则：" class="headerlink" title="设计模式的六⼤原则："></a>设计模式的六⼤原则：</h1><h4 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h4><ul>
<li>开闭原则就是说对扩展开放，对修改关闭</li>
<li>在程序需要进⾏拓展的时候，不能去修改原有的代码，实现⼀个热插拔的效果。</li>
<li>所以⼀句话概括就是：为了使程序的扩展性好，易于维护和升级</li>
<li>想要达到这样的效果，我们需要使⽤接⼝和抽象类，后⾯的具体设计中我们会提到这点。</li>
</ul>
<h4 id="⾥⽒代换原则（Liskov-Substitution-Principle-LSP）"><a href="#⾥⽒代换原则（Liskov-Substitution-Principle-LSP）" class="headerlink" title="⾥⽒代换原则（Liskov Substitution Principle LSP）"></a>⾥⽒代换原则（Liskov Substitution Principle LSP）</h4><ul>
<li>⾥⽒代换原则⾯向对象设计的基本原则之⼀</li>
<li>⾥⽒代换原则中说，任何基类可以出现的地⽅，⼦类⼀定可以出现</li>
<li>LSP 是继承复⽤的基⽯，只有当衍⽣类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复⽤，⽽衍⽣类也能够在基类的基础上增加新的⾏为</li>
<li>⾥⽒代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化</li>
<li>⽽基类与⼦类的继承关系就是抽象化的具体实现，所以⾥⽒代换原则是对实现抽象化的具体步骤的规范</li>
</ul>
<h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul>
<li>这个是开闭原则的基础，具体内容：真对接⼝编程，依赖于抽象⽽不依赖于具体。</li>
</ul>
<h4 id="接⼝隔离原则（Interface-Segregation-Principle）"><a href="#接⼝隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接⼝隔离原则（Interface Segregation Principle）"></a>接⼝隔离原则（Interface Segregation Principle）</h4><ul>
<li>使⽤多个隔离的接⼝，⽐使⽤单个接⼝要好</li>
<li>还是⼀个降低类之间的耦合度的意思</li>
<li>从这⼉我们看出，其实设计模式就是⼀个软件的设计思想，从⼤型软件架构出发，为了升级和维护⽅便</li>
<li>所以上⽂中多次出现：降低依赖，降低耦合。</li>
</ul>
<h4 id="迪⽶特法则（最少知道原则）（Demeter-Principle）"><a href="#迪⽶特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪⽶特法则（最少知道原则）（Demeter Principle）"></a>迪⽶特法则（最少知道原则）（Demeter Principle）</h4><ul>
<li>为什么叫最少知道原则，就是说：⼀个实体应当尽量少的与其他实体之间发⽣相互作⽤，使得系统功能模块相对独⽴。</li>
</ul>
<h4 id="合成复⽤原则（Composite-Reuse-Principle）"><a href="#合成复⽤原则（Composite-Reuse-Principle）" class="headerlink" title="合成复⽤原则（Composite Reuse Principle）"></a>合成复⽤原则（Composite Reuse Principle）</h4><ul>
<li>原则是尽量使⽤合成&#x2F;聚合的⽅式，⽽不是使⽤继承</li>
</ul>
<h1 id="jdk-中的设计模式"><a href="#jdk-中的设计模式" class="headerlink" title="jdk 中的设计模式"></a>jdk 中的设计模式</h1><h4 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h4><ul>
<li>java.lang.Runtime#getRuntime()</li>
<li>java.awt.Desktop#getDesktop()</li>
<li>java.lang.System#getSecurityManager()</li>
</ul>
<h4 id="责任链模式-1"><a href="#责任链模式-1" class="headerlink" title="责任链模式"></a>责任链模式</h4><ul>
<li>java.util.logging.Logger#log()</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
<h4 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h4><ul>
<li>java.util.Observer&#x2F; java.util.Observable（很少在现实世界中使⽤）</li>
<li>所有实现 java.util.EventListener（因此实际上各地的 Swing）</li>
<li>javax.servlet.http.HttpSessionBindingListener</li>
<li>javax.servlet.http.HttpSessionAttributeListener</li>
<li>javax.faces.event.PhaseListener</li>
</ul>
<h1 id="spring-中的设计模式："><a href="#spring-中的设计模式：" class="headerlink" title="spring 中的设计模式："></a>spring 中的设计模式：</h1><h4 id="简单⼯⼚"><a href="#简单⼯⼚" class="headerlink" title="简单⼯⼚"></a>简单⼯⼚</h4><ul>
<li>spring 中的 BeanFactory 就是简单⼯⼚模式的体现，根据传⼊⼀个唯⼀的标识来获得 bean 对象，但是否是在传⼊   参数后创建还是传⼊参数前创建这个要根据具体情况来定。</li>
<li>单例模式：Spring 下默认的 bean 均为 singleton。</li>
<li>代理模式：为其他对象提供⼀种代理以控制对这个对象的访问。 从结构上来看和 Decorator 模式类似，但 Proxy 是控制，更像   是⼀种对功能的限制，⽽ Decorator 是增加职责。 spring 的 Proxy 模式在 aop 中有体现，⽐如 JdkDynamicAopProxy 和 Cglib2AopProxy。</li>
<li>观察者模式：定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发⽣改变时，所有依赖于它的对象都得到通知并被⾃动更新。spring 中 Observer 模式常⽤的地⽅是 listener 的实现。如 ApplicationListener。</li>
</ul>
<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><ul>
<li>设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法</li>
<li>设计模式是代码可用性的延伸</li>
</ul>
<h1 id="使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="使用工厂模式最主要的好处是什么？在哪里使用？"></a>使用工厂模式最主要的好处是什么？在哪里使用？</h1><ul>
<li>工厂模式的最大好处是增加了创建对象时的封装层次</li>
<li>如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。</li>
</ul>
<h1 id="举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？"><a href="#举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？" class="headerlink" title="举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？"></a>举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</h1><ul>
<li>装饰模式增加强了单个对象的能力</li>
<li>Java IO 到处都使用了装饰模式，典型例子就是 Buffered 系列类如 BufferedReader 和 BufferedWriter，它们增强了 Reader 和 Writer 对象，以实现提升性能的 Buffer 层次的读取和写入。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列（MQ）</title>
    <url>/publishes/7e68be57c290.html</url>
    <content><![CDATA[<h1 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h1><ul>
<li>场景有很多，但是比较核心的有 3 个：解耦、异步、削峰。</li>
</ul>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><ul>
<li>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</li>
<li>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A系统要时时刻刻考虑BCDE四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？</li>
<li>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去MQ里面消费。如果新系统需要数据，直接从MQ里消费即可；如果某个系统不需要这条数据了，就取消对MQ消息的消费即可。这样下来，A系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</li>
<li>总结：通过一个 MQ，Pub&#x2F;Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</li>
<li>面试技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul>
<li>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近 1s，用户感觉慢。</li>
<li>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</li>
<li>如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了</li>
</ul>
<h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><ul>
<li>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</li>
<li>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</li>
<li>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</li>
</ul>
<h1 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h1><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>解耦、异步、削峰。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="系统可用性降低"><a href="#系统可用性降低" class="headerlink" title="系统可用性降低"></a>系统可用性降低</h5><ul>
<li>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的。</li>
</ul>
<h5 id="系统复杂度提高"><a href="#系统复杂度提高" class="headerlink" title="系统复杂度提高"></a>系统复杂度提高</h5><ul>
<li>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li>
</ul>
<h5 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h5><ul>
<li>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。<br>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</li>
</ul>
<h1 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点</h1><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td>-</td>
<td>-</td>
<td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody></table>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul>
<li>最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，不推荐用这个；</li>
<li>后来大家开始用 RabbitMQ，但是确实erlang语言阻止了大量的Java工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li>
<li>不过现在确实越来越多的公司会去用RocketMQ，确实很不错，阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给Apache，但GitHub上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li>
<li>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li>
<li>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
<h1 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h1><h4 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h4><ul>
<li>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</li>
<li>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</li>
</ul>
<h5 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h5><ul>
<li>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li>
</ul>
<h5 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h5><ul>
<li>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</li>
<li>这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</li>
</ul>
<h5 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h5><ul>
<li>这种模式，才是所谓的 RabbitMQ 的高可用模式</li>
<li>跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思</li>
<li>然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</li>
<li>那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li>
<li>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据</li>
<li>坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li>
</ul>
<h4 id="Kafka-的高可用性"><a href="#Kafka-的高可用性" class="headerlink" title="Kafka 的高可用性"></a>Kafka 的高可用性</h4><ul>
<li>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</li>
<li>这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</li>
<li>实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</li>
<li>Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1&#x2F;3 的数据就丢了，因此这个是做不到高可用的。</li>
<li>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。</li>
<li>只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</li>
<li>这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</li>
<li>写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</li>
<li>消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</li>
</ul>
<h1 id="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</h1><ul>
<li>RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题</li>
<li>因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。</li>
<li>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</li>
<li>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</li>
<li>举个栗子。有这么个场景。数据 1&#x2F;2&#x2F;3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152&#x2F;153&#x2F;154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了offset&#x3D;153的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 152 的 offset 并没有提交，kafka 也就不知道你已经消费了offset&#x3D;153这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 152 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</li>
<li>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 152 在数据库里插入了 2 次，那么数据就错啦。</li>
<li>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</li>
<li>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</li>
<li>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</li>
<li>所以第二个问题来了，怎么保证消息队列消费的幂等性？</li>
<li>其实还是得结合业务来思考，我这里给几个思路：<ul>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li>
</ul>
</li>
</ul>
<h1 id="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"><a href="#如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？" class="headerlink" title="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"></a>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</h1><ul>
<li>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</li>
</ul>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><h5 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h5><ul>
<li>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</li>
<li>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</li>
<li>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上吞吐量会下来，因为太耗性能。</li>
<li>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</li>
<li>事务机制和confirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</li>
<li>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</li>
</ul>
<h5 id="RabbitMQ-弄丢了数据"><a href="#RabbitMQ-弄丢了数据" class="headerlink" title="RabbitMQ 弄丢了数据"></a>RabbitMQ 弄丢了数据</h5><ul>
<li>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</li>
<li>设置持久化有两个步骤：<ul>
<li>创建 queue 的时候将其设置为持久化<br>  这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li>
<li>第二个是发送消息的时候将消息的deliveryMode设置为 2<br>  就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li>
</ul>
</li>
<li>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</li>
<li>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</li>
<li>所以，持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</li>
</ul>
<h5 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h5><ul>
<li>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</li>
<li>这个时候得用 RabbitMQ 提供的ack机制，简单来说，就是你必须关闭 RabbitMQ 的自动ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把。这样的话，如果你还没处理完，不就没有ack了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</li>
</ul>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><h5 id="消费端弄丢了数据-1"><a href="#消费端弄丢了数据-1" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h5><ul>
<li>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</li>
<li>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要关闭自动提交offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</li>
<li>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</li>
</ul>
<h5 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h5><ul>
<li>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</li>
<li>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</li>
<li>所以此时一般是要求起码设置如下 4 个参数：<ul>
<li>给 topic 设置replication.factor参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li>
<li>在 Kafka 服务端设置min.insync.replicas参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li>
<li>在 producer 端设置acks&#x3D;all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。</li>
<li>在 producer 端设置retries&#x3D;MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。</li>
</ul>
</li>
<li>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</li>
</ul>
<h5 id="生产者会不会弄丢数据"><a href="#生产者会不会弄丢数据" class="headerlink" title="生产者会不会弄丢数据"></a>生产者会不会弄丢数据</h5><ul>
<li>如果按照上述的思路设置了acks&#x3D;all，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了</li>
<li>如果没满足这个条件，生产者会自动不断的重试，重试无限次。</li>
</ul>
<h1 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h1><ul>
<li>举个例子，我们以前做过一个 mysql binlog 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）</li>
<li>常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</li>
<li>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 binlog 日志，接着这三条 binlog 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</li>
<li>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</li>
<li>先看看顺序会错乱的俩场景：<ul>
<li>RabbitMQ：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3。这不明显乱了。</li>
<li>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞多个线程来并发处理消息。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li>
</ul>
</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul>
<li>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点</li>
<li>或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li>
</ul>
<p> </p>
<h5 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h5><ul>
<li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li>
<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue</li>
<li>然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li>
</ul>
<h1 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h1><ul>
<li>先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。</li>
<li>大量消息在 mq 里积压了几个小时了还没解决。这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</li>
<li>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</li>
<li>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：<ul>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li>
<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据</li>
<li>这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li>
</ul>
</li>
</ul>
<h4 id="mq-中的消息过期失效了"><a href="#mq-中的消息过期失效了" class="headerlink" title="mq 中的消息过期失效了"></a>mq 中的消息过期失效了</h4><ul>
<li>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL</li>
<li>如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了</li>
<li>那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。</li>
<li>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息</li>
<li>我们可以采取一个方案，就是批量重导。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</li>
<li>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</li>
</ul>
<h4 id="mq-都快写满了"><a href="#mq-都快写满了" class="headerlink" title="mq 都快写满了"></a>mq 都快写满了</h4><ul>
<li>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</li>
</ul>
<h1 id="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"><a href="#如果让你写一个消息队列，该如何进行架构设计？说一下你的思路" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"></a>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</h1><ul>
<li>其实回答这类问题，说白了，不求你看过那技术的源码，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</li>
<li>比如说这个消息队列系统，我们从以下几个角度来考虑一下：<ul>
<li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li>
<li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li>
<li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li>
<li>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</li>
</ul>
</li>
<li>mq 肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</li>
</ul>
<h1 id="四款消息队列的对比"><a href="#四款消息队列的对比" class="headerlink" title="四款消息队列的对比"></a>四款消息队列的对比</h1><h4 id="MSMQ"><a href="#MSMQ" class="headerlink" title="MSMQ"></a>MSMQ</h4><ul>
<li>这是微软的产品里唯一被认为有价值的东西</li>
<li>这个东西并不复杂，除了接收和 发送，没有别的</li>
<li>它有一些硬性限制，比如最大消息体积是4MB</li>
<li>然而，通过和一些像MassTransit 或 NServiceBus这样的软件的连接，它完全可以解决这些问题。</li>
<li>优点：<ul>
<li>由于是异步通信，无论是发送方还是接收方都不用等待对方返回成功消息，就可以执行余下的代码，因而大大地提高了事物处理的能力</li>
<li>当信息传送过程中，信息发送机制具有一定功能的故障恢复能力；</li>
<li>MSMQ的消息传递机制使得消息通信的双方具有不同的物理平台成为可能。</li>
</ul>
</li>
</ul>
<h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><ul>
<li>特性列表:</li>
<li>多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li>
<li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)</li>
<li>对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性</li>
<li>通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上</li>
<li>支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li>
<li>支持通过JDBC和journal提供高速的消息持久化</li>
<li>从设计上保证了高性能的集群，客户端-服务器，点对点</li>
<li>支持Ajax</li>
<li>支持与Axis的整合</li>
<li>可以很容易得调用内嵌JMS provider，进行测试</li>
</ul>
<h4 id="RabbitMQ-2"><a href="#RabbitMQ-2" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><ul>
<li>它支持开放的高级消息队列协议 (AMQP，Advanced Message Queuing Protocol)</li>
<li>从根本上避免了生产厂商的封闭，使用任何语言的各种客户都可以从中受益</li>
<li>这种协议提供了相当复杂的消息传输模式，所以基本上不需要 MassTransit 或 NServiceBus 的配合</li>
</ul>
<h4 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h4><ul>
<li>ZeroMQ 是一个轻量级消息内核</li>
<li>它可用于C、C++、Python、.NET &#x2F;Mono、Fortran和Java语言<br>它运行在AIX ， FreeBSD的，基于HP - UX ， Linux和MacOS下， OpenBSD系统， OpenVMS ， QNX Neutrino， Solaris和Windows操作系统。</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul>
<li>ActiveMQ需要 在目标机器上安装Java，RabbitMQ需要Erlang环境。如果这个中 的一个被选中，我需要让系统维护的人去理解和维护他们以前不熟悉的运行库。</li>
<li>ActiveMQ,RabbitMQ 和 MSMQ 都需要启动服务进程，这些都可以监控和配置，另外一个就有问题了。</li>
<li>ZeroMQ，它没有中间件架构，不需要任何服务进程和运行时。事实上，你的应用程序端点扮演了这个服务角色。这让部署起来非常简单，但担心的是， 你没有地方可以观察它是否有问题出现。就目前我知道的，ZeroMQ仅提供非持久性的队列。你可以在需要的地方实现自己的审计和数据恢复功能</li>
<li>如果你希望一个应用程序发送消息越快越好，你选择ZeroMQ。当你不太在意偶然会丢失某些消息的情况下更有价值。</li>
<li>虽然说ZeroMQ的速度很惊人,但是对于数据就是生命的年代,我们宁可降低一些需求也不愿意丢失任何一条宝贵的数据,所以综合对比下来,我觉得RabbitMQ更适合.</li>
</ul>
<h1 id="消息中间件Kafka与RabbitMQ谁更胜一筹"><a href="#消息中间件Kafka与RabbitMQ谁更胜一筹" class="headerlink" title="消息中间件Kafka与RabbitMQ谁更胜一筹"></a>消息中间件Kafka与RabbitMQ谁更胜一筹</h1><ul>
<li>在 IM 这种讲究高并发、高消息吞吐的互联网场景下，MQ 消息中间件是个很重要的基础设施，它在 IM 系统的服务端架构中担当消息中转、消息削峰、消息交换异步化等角色。</li>
<li>当然，MQ 消息中间件的作用远不止于此，它的价值不仅仅存在于技术上，更重要的是改变了以往同步处理消息的思路。</li>
<li>比如进行 IM 消息历史存储时，传统的信息系统作法可能是收到一条消息就马上同步存入数据库，这种作法在小并发量的情况下可以很好的工作，但互联网大并发环境下就是灾难。</li>
<li>MQ 消息中间件可以理解为一个水池，水池的这头是消息生产者，水池的那头是消息消费者，生产者和消息者无需直接对接，这将带来很多好处：业务解耦、架构分布式化等，生产者和消费者互相完全透明。</li>
</ul>
<h1 id="什么是消息队列中间件"><a href="#什么是消息队列中间件" class="headerlink" title="什么是消息队列中间件"></a>什么是消息队列中间件</h1><ul>
<li>消息队列中间件(简称消息中间件)是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</li>
<li>通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。</li>
<li>目前开源的消息中间件可谓是琳琅满目，能让大家耳熟能详的就有很多，比如 ActiveMQ、RabbitMQ、Kafka、RocketMQ、ZeroMQ 等，不管选择其中的哪一款，都会有用的不趁手的地方，毕竟不是为你量身定制的。</li>
<li>可能有些大厂在长期的使用过程中积累了一定的经验，加上其消息队列的使用场景也相对稳定固化，或者目前市面上的消息中间件无法满足自身需求，同时它也具备足够的精力和人力而选择自研来为自己量身打造一款消息中间件。</li>
<li>但是绝大多数公司还是不会选择重复造轮子，那么选择一款适合自己的消息中间件显得尤为重要。</li>
<li>就算是前者，那么在自研出稳定且可靠的相关产品之前也会经历这样一个选型过程。</li>
<li>在整体架构中引入消息中间件，势必要考虑很多因素，比如成本及收益问题，怎么样才能达到最优的性价比?</li>
<li>虽然消息中间件种类繁多，但是各自都有各自的侧重点，选择合适自己、扬长避短无疑是最好的方式。如果你对此感到无所适从，本文或许可以参考一二。</li>
</ul>
<h4 id="各类消息队列简述"><a href="#各类消息队列简述" class="headerlink" title="各类消息队列简述"></a>各类消息队列简述</h4><h5 id="ActiveMQ-1"><a href="#ActiveMQ-1" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h5><ul>
<li>Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。</li>
<li>不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为 Apollo，号称下一代 ActiveMQ，有兴趣的同学可自行了解。</li>
</ul>
<h5 id="RabbitMQ-3"><a href="#RabbitMQ-3" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul>
<li>采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。</li>
<li>RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。</li>
</ul>
<h5 id="Kafka-2"><a href="#Kafka-2" class="headerlink" title="Kafka"></a>Kafka</h5><ul>
<li>起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。</li>
<li>它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用</li>
<li>目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</li>
</ul>
<h5 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h5><ul>
<li>是阿里开源的消息中间件，目前已经捐献给 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双 11 的洗礼，实力不容小觑。</li>
</ul>
<h5 id="ZeroMQ-1"><a href="#ZeroMQ-1" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h5><ul>
<li>号称史上最快的消息队列，基于 C 语言开发。ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩。</li>
<li>虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</li>
<li>目前市面上的消息中间件还有很多，比如腾讯系的 PhxQueue、CMQ、CKafka，又比如基于 Go 语言的 NSQ，有时人们也把类似 Redis 的产品也看做消息中间件的一种。</li>
</ul>
<h1 id="消息中间件选型要点"><a href="#消息中间件选型要点" class="headerlink" title="消息中间件选型要点"></a>消息中间件选型要点</h1><ul>
<li>衡量一款消息中间件是否符合需求，需要从多个维度进行考察。</li>
<li>首要的就是功能维度，这个直接决定了你能否最大程度上地实现开箱即用，进而缩短项目周期、降低成本等。</li>
<li>如果一款消息中间件的功能达不到想要的功能，那么就需要进行二次开发，这样会增加项目的技术难度、复杂度以及增大项目周期等。</li>
<li>消息中间件具体选型指标</li>
</ul>
<h4 id="功能维度"><a href="#功能维度" class="headerlink" title="功能维度"></a>功能维度</h4><h5 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h5><ul>
<li>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。</li>
<li>不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器(一般简单的称之为 Broker)中没有消息堆积。</li>
<li>那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</li>
</ul>
<h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><ul>
<li>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”，这个是延迟队列的一种典型应用场景。</li>
<li>延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</li>
<li>延迟队列一般分为两种：<ul>
<li>基于消息的延迟，是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。</li>
<li>基于队列的延迟，实际应用中大多采用这种，设置不同延迟级别的队列，比如5s、10s、30s、1min、5mins、10mins等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略(比如定时)即可投递超时的消息。</li>
</ul>
</li>
</ul>
<h5 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h5><ul>
<li>由于某些原因消息无法被正确投递，为了确保消息不会被无故丢弃，一般将其置于一个特殊角色的队列，这个队列称为死信队列。</li>
<li>与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认(Ack), 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。</li>
<li>为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</li>
</ul>
<h5 id="重试队列"><a href="#重试队列" class="headerlink" title="重试队列"></a>重试队列</h5><ul>
<li>其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。</li>
<li>与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。</li>
<li>举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息。</li>
<li>如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。</li>
<li>以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。</li>
<li>重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发;延迟队列作用一次，而重试队列的作用范围会向后传递。</li>
</ul>
<h5 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h5><ul>
<li>消费模式分为推(push)模式和拉(pull)模式：<ul>
<li>推模式，是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。</li>
<li>拉模式，是指消费端主动向 Broker 端请求拉取(一般是定时或者定量)消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。</li>
</ul>
</li>
</ul>
<h5 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h5><ul>
<li>消息一般有两种传递模式——点对点(P2P，Point-to-Point)模式和发布&#x2F;订阅(Pub&#x2F;Sub)模式：</li>
<li>对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。</li>
<li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题(Topic)，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。</li>
<li>主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布&#x2F;订阅模式在消息的一对多广播时采用。</li>
<li>RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。</li>
<li>但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组(Consumer Group)的概念看成是队列的概念。</li>
<li>不过对比来说，Kafka 中因为有了消息回溯功能的存在，对于广播消费的力度支持比 RabbitMQ 的要强。</li>
</ul>
<h5 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h5><ul>
<li>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息</li>
<li>消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。</li>
<li>对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失，一般很难追查。</li>
<li>如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头所在。</li>
<li>消息回溯的作用远不止于此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。</li>
</ul>
<h5 id="消息堆积-持久化"><a href="#消息堆积-持久化" class="headerlink" title="消息堆积+持久化"></a>消息堆积+持久化</h5><ul>
<li>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。</li>
<li>从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。</li>
<li>消息堆积分内存式堆积和磁盘式堆积：</li>
<li>RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘(换页动作会影响吞吐)，或者直接使用惰性队列来将消息直接持久化至磁盘中。</li>
<li>Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。</li>
<li>一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。</li>
<li>从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引《纽约时报》的案例，其直接将 Kafka 用作存储系统。</li>
</ul>
<h5 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h5><ul>
<li>对于分布式架构系统中的链路追踪(Trace)，大家一定不陌生</li>
<li>对于消息中间件，消息的链路追踪(以下简称消息追踪)同样重要，最通俗来理解，就是要知道消息从哪来，存在哪里以及发往哪里去。</li>
<li>基于此功能，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。</li>
</ul>
<h5 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h5><ul>
<li>消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。</li>
<li>就以 Kafka 而言，完全可以将不同类别的消息发送至不同的 Topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 Topic 中的消息进行分类。</li>
<li>不过，更加严格意义上的消息过滤，应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。</li>
<li>同样以 Kafka 为例，可以通过客户端提供的 Consumer Interceptor 接口或者 Kafka Stream 的 Filter 功能进行消息过滤。</li>
</ul>
<h5 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h5><ul>
<li>也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。</li>
<li>RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 VHost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。</li>
<li>VHost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。</li>
</ul>
<h5 id="多协议支持"><a href="#多协议支持" class="headerlink" title="多协议支持"></a>多协议支持</h5><ul>
<li>消息是信息的载体，为了让生产者和消费者都能理解所承载的信息(生产者需要知道如何构造消息，消费者需要知道如何解析消息)，它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。</li>
<li>有效的消息一定具有某种格式，而没有格式的消息是没有意义的。</li>
<li>一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等(消息领域中的 JMS 更多的是一个规范而不是一个协议)，支持的协议越多其应用范围就会越广，通用性越强。</li>
<li>比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。</li>
</ul>
<h5 id="跨语言支持"><a href="#跨语言支持" class="headerlink" title="跨语言支持"></a>跨语言支持</h5><ul>
<li>对很多公司而言，其技术栈体系中会有多种编程语言，如 C&#x2F;C++、Java、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。</li>
<li>跨语言的支持力度也从侧面反映出一个消息中间件的流行程度。</li>
</ul>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><ul>
<li>针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应</li>
<li>通常的流控方法有 Stop-and-Wait、滑动窗口以及令牌桶等。</li>
</ul>
<h5 id="消息顺序性"><a href="#消息顺序性" class="headerlink" title="消息顺序性"></a>消息顺序性</h5><ul>
<li>顾名思义，是指保证消息有序</li>
<li>这个功能有个很常见的应用场景就是 CDC(Change Data Chapture)。</li>
<li>以 MySQL 为例，如果其传输的 Binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1，造成数据不一致。</li>
</ul>
<h5 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h5><ul>
<li>在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制：<ul>
<li>身份认证，是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制。</li>
<li>权限控制，是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。</li>
</ul>
</li>
<li>对于 RabbitMQ 而言，其同样提供身份认证(TLS&#x2F;SSL、SASL)和权限控制(读写操作)的安全机制。</li>
</ul>
<h5 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h5><ul>
<li>确保消息在生产者和消费者之间进行传输，一般有三种传输保障(Delivery Guarantee)：<ul>
<li>At most once，至多一次，消息可能丢失，但绝不会重复传输。</li>
<li>At least once，至少一次，消息绝不会丢，但是可能会重复。</li>
<li>Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。</li>
</ul>
</li>
<li>对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</li>
<li>Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等。</li>
<li>而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS(Exactly Once Semantic)的能力。</li>
<li>不过如果要考虑全局的幂等，还需要从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。</li>
<li>以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法由消息中间件层面来保证的。</li>
<li>如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。</li>
</ul>
<h5 id="事务性消息"><a href="#事务性消息" class="headerlink" title="事务性消息"></a>事务性消息</h5><ul>
<li>事务本身是一个并不陌生的词汇，事务是由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。</li>
<li>支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。</li>
<li>消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度，有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得。<br>K- afka 在开启幂等、事务功能的时候会使其性能降低;RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大影响其性能。</li>
</ul>
<h5 id="性能指什么"><a href="#性能指什么" class="headerlink" title="性能指什么?"></a>性能指什么?</h5><ul>
<li>消息中间件的性能一般是指其吞吐量</li>
<li>虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级。</li>
<li>一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。</li>
<li>注明：消息中间件的吞吐量始终会受到硬件层面的限制。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过(1Gb&#x2F;8)&#x2F;100W，即约等于 134B。</li>
<li>换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。</li>
</ul>
<h5 id="性能的指标是什么"><a href="#性能的指标是什么" class="headerlink" title="性能的指标是什么?"></a>性能的指标是什么?</h5><ul>
<li>时延作为性能维度的一个重要指标，却往往在消息中间件领域被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。</li>
<li>消息中间件具备消息堆积的能力，消息堆积越大也就意味着端到端的时延也就越长，与此同时延时队列也是某些消息中间件的一大特色。那么为什么还要关注消息中间件的时延问题呢?</li>
<li>消息中间件能够解耦系统，对于一个时延较低的消息中间件而言，它可以让上游生产者发送消息之后可以迅速的返回，也可以让消费者更加快速的获取到消息，在没有堆积的情况下，可以让整体上下游的应用之间的级联动作更加高效。</li>
<li>虽然不建议在时效性很高的场景下使用消息中间件，但是如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。</li>
</ul>
<h4 id="可靠性-可用性"><a href="#可靠性-可用性" class="headerlink" title="可靠性+可用性"></a>可靠性+可用性</h4><ul>
<li>消息丢失是使用消息中间件时所不得不面对的一个痛点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素</li>
<li>尤其是在金融支付领域，消息可靠性尤为重要。</li>
<li>然而说到可靠性必然要说到可用性，注意这两者之间的区别：<ul>
<li>可靠性是指对消息不丢失的保障程度。</li>
<li>可用性是指无故障运行的时间百分比，通常用几个 9 来衡量。</li>
</ul>
</li>
<li>从狭义的角度来说，分布式系统架构是一致性协议理论的应用实现，对于消息可靠性和可用性而言也可以追溯到消息中间件背后的一致性协议：<ul>
<li>对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，通过 ISR(In-Sync-Replica)来保证多副本之间的同步，并且支持强一致性语义(通过 Acks 实现)。</li>
<li>对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。</li>
</ul>
</li>
<li>多副本可以保证在 Master 节点宕机异常之后可以提升 Slave 作为新的 Master 而继续提供服务来保障可用性。</li>
<li>Kafka 设计之初是为日志处理而生，给人们留下了数据可靠性要求不高的不良印象，但是随着版本的升级优化，其可靠性得到极大的增强，详细可以参考 KIP101。</li>
<li>就目前而言，在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多，随着 RabbitMQ 性能的不断提升和 Kafka 可靠性的进一步增强，相信彼此都能在以前不擅长的领域分得一杯羹。</li>
<li>同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘。</li>
<li>但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。</li>
<li>这里还要提及的一个方面是扩展能力，这里我狭隘地将此归纳到可用性这一维度，消息中间件的扩展能力能够增强其可用能力及范围，比如前面提到的 RabbitMQ 支持多种消息协议，这个就是基于其插件化的扩展实现。</li>
<li>还有从集群部署上来讲，归功于 Kafka 的水平扩展能力，其基本上可以达到线性容量提升的水平，在 LinkedIn 实践介绍中就提及了有部署超过千台设备的 Kafka 集群。</li>
</ul>
<h4 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h4><ul>
<li>在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复?</li>
<li>业务线流量有峰值有低谷，尤其是电商领域，那么怎样进行有效的容量评估，尤其是大促期间?脚踢电源、网线被挖等事件层出不穷，如何有效的做好异地多活?</li>
<li>这些都离不开消息中间件的衍生产品——运维管理。运维管理也可以进行进一步的细分，比如申请、审核、监控、告警、管理、容灾、部署等。</li>
<li>申请、审核很好理解，在源头对资源进行管控，既可以有效校正应用方的使用规范，配合监控也可以做好流量统计与流量评估工作。</li>
<li>一般申请、审核与公司内部系统交融性较大，不适合使用开源类的产品。</li>
<li>监控、告警也比较好理解，对消息中间件的使用进行全方位的监控，既可以为系统提供基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。</li>
<li>除了一般的监控项(比如硬件、GC 等)之外，消息中间件还需要关注端到端时延、消息审计、消息堆积等方面：</li>
<li>对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，但是社区内还有 AppDynamics、Collectd、DataDog、Ganglia、Munin、Nagios、New Relic、Prometheus、Zenoss 等多种优秀的产品。</li>
<li>Kafka 在此方面也毫不逊色，比如：Kafka Manager、Kafka Monitor、Kafka Offset Monitor、Burrow、Chaperone、Confluent Control Center 等产品，尤其是 Cruise 还可以提供自动化运维的功能。</li>
<li>不管是扩容、降级、版本升级、集群节点部署、还是故障处理都离不开管理工具的应用，一个配套完备的管理工具集可以在遇到变更时做到事半功倍。</li>
<li>故障可大可小，一般是一些应用异常，也可以是机器掉电、网络异常、磁盘损坏等单机故障，这些故障单机房内的多副本足以应付。</li>
<li>如果是机房故障就要涉及异地容灾了，关键点在于如何有效的进行数据复制，Kafka 可以参考 MirrorMarker、uReplicator 等产品，而 RabbitMQ 可以参考 Federation 和 Shovel。</li>
</ul>
<h4 id="社区力度及生态发展"><a href="#社区力度及生态发展" class="headerlink" title="社区力度及生态发展"></a>社区力度及生态发展</h4><ul>
<li>对于目前流行的编程语言而言，如 Java、Python，如果你在使用过程中遇到了一些异常，基本上可以通过搜索引擎的帮助来得到解决，因为一个产品用的人越多，踩过的坑也就越多，对应的解决方案也就越多。</li>
<li>消息中间件也同样适用，如果你选择了一种“生僻”的消息中间件，可能在某些方面运用的得心应手，但是版本更新缓慢、遇到棘手问题也难以得到社区的支持而越陷越深。</li>
<li>相反如果你选择了一种“流行”的消息中间件，其更新力度大，不仅可以迅速的弥补之前的不足，而且也能顺应技术的快速发展来变更一些新的功能，这样可以让你也“站在巨人的肩膀上”。</li>
<li>在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。</li>
</ul>
<h4 id="消息中间件选型误区总结"><a href="#消息中间件选型误区总结" class="headerlink" title="消息中间件选型误区总结"></a>消息中间件选型误区总结</h4><h5 id="选型误区"><a href="#选型误区" class="headerlink" title="选型误区"></a>选型误区</h5><ul>
<li>选型之前可以先问自己一个问题：是否真的需要一个消息中间件?</li>
<li>在搞清楚这个问题之后，还可以继续问自己一个问题：是否需要自己维护一套消息中间件?</li>
<li>很多初创型公司为了节省成本会选择直接购买消息中间件有关的云服务，自己只需要关注收发消息即可，其余的都可以外包出去。</li>
<li>很多人面对消息中间件有一种自研的冲动，你完全可以对 Java 中的 ArrayBlockingQueue 做一个简单的封装，你也可以基于文件、数据库、Redis 等底层存储封装而形成一个消息中间件。</li>
<li>消息中间件做为一个基础组件并没有想象中的那么简单，其背后还需要配套的管理运维整个生态的产品集。</li>
<li>自研还会有交接问题，如果文档不齐全、运作不规范将会带给新人噩梦般的体验。</li>
<li>是否真的有自研的必要?如果不是 KPI 的压迫可以先考虑下面这两个问题：<ul>
<li>目前市面上的消息中间件是否都真的无法满足目前的业务需求?</li>
<li>团队是否有足够的能力、人力、财力、精力来支持自研?</li>
</ul>
</li>
<li>很多人在做消息中间件选型时会参考网络上的很多对比类的文章，但是其专业性、严谨性、以及其政治立场问题都有待考证，需要带着怀疑的态度去审视这些文章。</li>
<li>比如有些文章会在没有任何限定条件及场景的情况下直接定义某款消息中间件最好。</li>
<li>还有些文章没有指明消息中间件版本及测试环境就来做功能和性能对比分析，诸如此类的文章都可以唾弃之。</li>
<li>消息中间件犹如小马过河，选择合适的才最重要。这需要贴合自身的业务需求，技术服务于业务，大体上可以根据上一节所提及的功能、性能等 6 个维度来一一进行筛选。更深层次的抉择在于你能否掌握其魂。</li>
<li>笔者鄙见：RabbitMQ 在于 Routing，而 Kafka 在于 Streaming，了解其根本对于自己能够对症下药选择到合适的消息中间件尤为重要。</li>
<li>消息中间件选型切忌一味的追求性能或者功能，性能可以优化，功能可以二次开发。</li>
<li>如果要在功能和性能方面做一个抉择的话，那么首选性能，因为总体上来说性能优化的空间没有功能扩展的空间大。然而看长期发展，生态又比性能以及功能都要重要。</li>
</ul>
<h5 id="可靠性误区"><a href="#可靠性误区" class="headerlink" title="可靠性误区"></a>可靠性误区</h5><ul>
<li>很多时候，可靠性方面也容易存在一个误区：想要找到一个产品来保证消息的绝对可靠，很不幸的是这世界上没有绝对的东西，只能说尽量趋于完美。</li>
<li>想要尽可能的保障消息的可靠性也并非单单只靠消息中间件本身，还要依赖于上下游，需要从生产端、服务端和消费端这 3 个维度去努力保证。</li>
<li>消息中间件选型还有一个考量标准就是尽量贴合团队自身的技术栈体系，虽然说没有蹩脚的消息中间件，只有蹩脚的程序员，但是让一个 C 栈的团队去深挖 PhxQueue 总比去深挖 Scala 编写的 Kafka 要容易的多。</li>
<li>消息中间件大道至简：一发一存一消费，没有最好的消息中间件，只有最合适的消息中间件</li>
</ul>
<h1 id="消息服务的应用场景有哪些？"><a href="#消息服务的应用场景有哪些？" class="headerlink" title="消息服务的应用场景有哪些？"></a>消息服务的应用场景有哪些？</h1><ul>
<li>如下 3 个场景都可以使用消息服务<ul>
<li>异步处理</li>
<li>应用的解耦</li>
<li>流量的削峰</li>
</ul>
</li>
</ul>
<h1 id="Zookeeper-对于-Kafka-的作用是什么？"><a href="#Zookeeper-对于-Kafka-的作用是什么？" class="headerlink" title="Zookeeper 对于 Kafka 的作用是什么？"></a>Zookeeper 对于 Kafka 的作用是什么？</h1><ul>
<li>Zookeeper 是一个开放源码的、高性能的协调服务，它用于 Kafka 的分布式应用。</li>
<li>Zookeeper 主要用于在集群中不同节点之间进行通信</li>
<li>在 Kafka 中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取<br>除此之外，它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等。</li>
</ul>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>面试技巧</title>
    <url>/publishes/64b56da2b088.html</url>
    <content><![CDATA[<h1 id="IT从业人员面试技巧"><a href="#IT从业人员面试技巧" class="headerlink" title="IT从业人员面试技巧"></a>IT从业人员面试技巧</h1><ul>
<li>一般来说，面试你的人都不是一个很好对付的人。别看他彬彬有礼，看上去笑眯眯的，很和气的样子。但没准儿一肚子坏水。有些人待人特别客气，说话还稍稍有点结巴的，更容易让人上当。所以，牢记一点，面试的时候保持高度警觉，对方不经意问出来的问题，很可能是他最想知道的。举例来说，我每次面试的时候，最喜欢说的话就是：哦，我不是HR的，你别拘束，咱们就当是聊天……</li>
<li>负责面试的人，一般有两种，一种是专门的人力资源部门。我不懂这一块，略过不谈。另外一种就是我这样的，负责某个部门的苦力头。一般来说，公司中层的苦力头，他的脑子里面都有一个模式，他的码头上需要一个什么样的人，他或她必须具备哪些技能。但这些考察都是次要的，他首先要搞清楚一点，那就是对方的人品!!!换句话说，能力是一个方面，但人品是门槛!!!如果他判定你人品有问题，那剩下的问题就没必要了。这里面就有很多陷阱，比如，你怎么评价前一家公司。你要是大说特说那公司怎么不好，我肯定要琢磨了，你昨天背叛少林，那今天会不会背叛武当?最好把离职原因淡淡一说，不要指责谁。我找工作的时候，一般都老实说，我自己能力不行，被公司淘汰了。其实大家肚子都揣着明白，不就是为了找个钱多点的地儿嘛。我经常问的一个陷阱问题就是：谈谈你的父母。其实这个问题一方面是考察对方的家庭教育，另外一方面是看看面试者怎么评价父母。这里面有个通常的逻辑，爹妈把他养这么大，说到自己的父母毫无感恩，感激之情，这种人招进来肯定不能成为合格的苦力。</li>
<li>总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li>
</ul>
<h4 id="面试到结束的时候，都会问到薪金标准。"><a href="#面试到结束的时候，都会问到薪金标准。" class="headerlink" title="面试到结束的时候，都会问到薪金标准。"></a>面试到结束的时候，都会问到薪金标准。</h4><ul>
<li>我不知道别的公司怎么操作的。我呆过的公司，都是定编定岗的，换句话说，招聘的时候，这个岗位的薪水是早就确定了。也就是说，对方问到薪金的时候，他已经在脑子里面很清楚公司的标准!!!一般说来，这个问题的目的是为了确定，他如果觉得你是个合适的苦力，那么，现在的薪金，你是不是会过来干活。问到薪金的时候，最好的回答是不回答，留到下一次面试再谈。或者可以反问，公司对于这个岗位定的薪金标准是多少。</li>
<li>一般来说，苦力头不会管你薪金多少的。好的苦力，苦力头甚至会为你向老板争取。</li>
<li>能够混到苦力头的位置上，面试你的人至少具有一定的能力，以及足够的胸怀。他在意的是能不能招到合适的人干活，薪金的问题不是问题。但过高的薪金，会把你抹掉。比如这个岗位，公司定的薪水是三千，你一张嘴，四千，那完了。对于应聘者，其实是很不公平的，你能做的就是接受这个标准或是不接受。如果是刚刚走出校门，月薪三千我想足够生活了。所以，如果对方的薪金标准，你要么不回答，要么就说三千，别要的太高。</li>
</ul>
<h4 id="一般面试都是在一个独立的私密空间进行。"><a href="#一般面试都是在一个独立的私密空间进行。" class="headerlink" title="一般面试都是在一个独立的私密空间进行。"></a>一般面试都是在一个独立的私密空间进行。</h4><ul>
<li>这里简单说说一些基本的礼貌。</li>
<li>进门要敲门，敲门是最基本的一点。</li>
<li>第二点，落座，别进去一屁股就坐上去了。最好等对方先坐下。当然，一般面试的人都很客气，招呼：坐，坐。</li>
<li>有时候进去之后，面试的人已经坐好了，那就别管了，坐在他的对面或他指定的位置就行。我这人比较心理阴暗，一般都是背对亮光坐。</li>
<li>当你结束时，至少客气招呼一声：谢谢您抽出时间面试我。</li>
<li>如果离开座位，顺手把椅子推好，这也是一个容易疏忽的地方。 </li>
<li>有些公司的前台小姑娘，是你去面试的时候最先面对的，那么临走的时候客气打声招呼。</li>
<li>我有个习惯，面试的时候带着名片，如果我觉得很合适，会把名片给对方，这样他便于有问题的话联络我。但是，亲爱的朋友，你去面试的时候，如果对方面前放着名片夹子，千万不要傻了吧叽的要名片。</li>
<li>面试结束的第二天，如果你有面试你的苦力头电话，那就发个短信，内容可以客套一下，就说感谢你昨天面试我之类的话，然后祝福一下，比如今天好心情，工作顺利等等。千万不要问对方结果。你的目的就是提醒他，显示你的存在就行了。</li>
<li>你等待的地方，可能是公司的公共区域，而面试的地方可能是会议室，或者像我这样的人，喜欢在自己的办公室谈。那么切忌，不要走在前面，也不要走路中间，走在边上就行，把中间的位置留给你未来的领导走。进门之前主动为对方开门，这种拍马屁的小花招可以多来一点。</li>
<li>面试的时候身体正直，自然一点就行。一般来说，不要用摩丝喷的脑袋跟刺猬一样。女孩子也不要用过于浓密的香水。这是谈事情，不是相亲。</li>
<li>谈话的过程中，不要抢话，语速也不要太快。我教大家一个小诀窍，我一般和人谈事情，一开始故意显得有点结巴。人说话结巴，会让人感觉对方很诚恳。但就开头一两句结巴就行，别一直结巴。</li>
<li>有些人面试的时候介绍自己会滔滔不绝，说话特快。其实这里面有个信息传递的问题，跟别人谈事情，语速太快，往往容易说错。对方接受起来也有问题。中等语速就可以了。</li>
<li>很多男士比较大大咧咧，往那儿一坐，二郎腿就搭上了。要是碰上我这样大大咧咧的，可能无所谓，要是碰到心理阴暗的，就会有负面影响。另外，很多人一紧张就爱抖腿，这样也不礼貌。面试其实就是一个自我介绍，不是演说，不要声音特大吐沫横飞的，平时说话的声音就行。</li>
<li>面试你的要是个女的那就算了，要是个男的，不用管自己的性别，大大方方招呼一声，你好，手伸过去，和他握个手。其实从握手就能看到一个人的个性，一般来说，握手短促有力，可能是我这样比较外向的性格。握的软绵绵的，对方可能比较内向。</li>
<li>不要紧张，表现得自然些，要有礼貌，别忘记和主考人招呼，说句”早晨好”。</li>
<li>举止要大方，不可闪缩，要保持自信。待主考人邀请你才可礼貌地坐下，不要太随便或左顾右盼;切忌装出懒洋洋和满不在乎的样子。</li>
<li>微笑可以减轻你内心的不安，更可以令面试的气氛变得融洽愉快。</li>
<li>让主考人知道你珍惜这次面试的机会。当主考人说话时，要眼望对方，并留心倾听。</li>
<li>让主考人先打开话匣子。答问题要直接了当，无须太繁复，也不要单说”是”或”不是”;否则，主考人会觉得你欠缺诚意。深入的谈话内容有助主考人对你作出确切的评估。</li>
<li>假如不太明白主考人的问题，应该礼貌地请他重复。不懂得回答的问题，不妨坦白承认。含糊其辞或乱吹牛会导至面试的失败。</li>
<li>不要打断主考人的说话，被要求就相同的问题重复作答也不能表示不耐烦，更切忌与主考人争辩。</li>
<li>主考人可能问你一些与面试或者申请的职位完全无关的问题，例如时人时事;目的在进一步了解你的思想及见识。</li>
<li>紧记在适当时机带出自已的优点和特长。但切勿显得过份自信或浮夸。</li>
<li>不要急着提出薪酬问题，最好让主考人先提出。</li>
<li>准备一些与该机构和申请的工作有关的问题在面试结束之前提出。这样能表现伙的积极，亦可给主考人留下良好印象。</li>
<li>最后，问清楚多久才知道面试结果。不要忘记向主考人道谢及说声”再见”才离去。</li>
</ul>
<h1 id="面试一家公司之前需要做的准备"><a href="#面试一家公司之前需要做的准备" class="headerlink" title="面试一家公司之前需要做的准备"></a>面试一家公司之前需要做的准备</h1><h4 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h4><ul>
<li>了解应聘公司；</li>
<li>了解应聘岗位</li>
<li>查该公司的资料，知道该公司是做什么的，发展情况，招聘的岗位的要求等</li>
<li>公司地点在哪里，交通是否方便，需提前多久出发；</li>
<li>公司类型如何？我应该如何着装？去咨询公司逃不掉正装，而去互联网公司这么穿，人家或许以为你是房产中介；</li>
<li>公司业务如何？上市了吗？财报如何？主要产品有哪些？</li>
<li>公司在中国有多少分支机构？最近有什么新动向？</li>
<li>公司所在行业有何新动向？发展趋势如何？</li>
<li>公司的竞争对手有哪些？公司在行业内排名如何？</li>
</ul>
<h4 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h4><ul>
<li>重温一下简历内容，确保每段经历都能用简短的语言复述；</li>
<li>带过的团队，做过的项目，组织过的活动，以STAR的形式准备好；</li>
<li>每一段经历，都应该准备实例和数据证明，会给面试官留下深刻印象；</li>
<li>准备几个感兴趣的问题，面试中如果没有获得解答，在电话通知环节，我们必须开口问，有诸多信息要确认：<ul>
<li>面试时间／地点</li>
<li>公司名称／岗位名称</li>
<li>联系人信息（一旦迟到，得提前打电话道歉）</li>
<li>面试官是谁（HR还是直线经理，或者都一次性面试掉）</li>
<li>需要准备什么材料（一般逃不掉学历证明，身份证复印件等资料）</li>
<li>针对面试岗位，需要额外准备什么材料（如：做设计，是不是要带设计稿？）</li>
</ul>
</li>
</ul>
<h1 id="人事面试技巧总结"><a href="#人事面试技巧总结" class="headerlink" title="人事面试技巧总结"></a>人事面试技巧总结</h1><ul>
<li>一定不要将公司的工作当作负担，一定要做好并且学到东西，这才是你下一次跳槽能够展示的东西，所以在公司工作，你拿着工资，而不只是在为公司打工，而是为自己的未来进行修炼，一定要有这方面的意识。总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li>
<li>人事这关也很重要，特别是工资方面，还有团队，工作方面？(重要)</li>
<li>对公司的主营业务要表现足够的兴趣，关系公司的发展？</li>
<li>3面就该和你谈谈钱的事情，你们的重点就是在于薪资，福利和以后的发展，这个时候就是公司对你展示他的潜力了，也是希望能留住你（招人也不容易），那么你对你自己的定位，和你的期望薪资就可以大胆的说出来， 不要因为不好意思而错过你要价的机会，因为一般进入公司后你想涨薪资就比较复杂了，而且这只是你的期望 ，面试官会对你提出他们会给你的工资， 也就是一个讨价还价的过程，总之在这个环节，你可以大胆提出你的期望薪资与发展方向（不要太离谱哈，当然你要作死我也不拦着你），和你的面试官慢慢讨论</li>
<li>试用期：在这个环节就是心态上注意，技术上展示你的能力，处事上和谐相处，重中之重是在于融入团队，你个人的力量是完不成整个项目的</li>
<li>对新公司的了解，公司发展情况，业务方向，特长等，如果在企业文化上也有优势，可以多夸下公司的的企业文化</li>
<li>期望的薪资，最好是了解了工作内容、加班情况、福利情况再谈待遇。最好先了解行情以免太高或太低。不要说太死了，看到对方表情不对就改口说可以商量，或者试探性的问一下对方能否接受，不行就说自己要高工资的原因并说明其实自己更看重发展机会，工资再少点也可以。不要轻易说自己能接受的最低工资，很可能他就给你这个最低的。如果对方能接受你的要求但是觉得有点偏高时，要说明自己凭什么可以拿这么高，并说明自己的优势对岗位的重要性。</li>
<li>要问公司的问题<ul>
<li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等。</li>
<li>所在部门的规模、发展计划，个人的成长机会。</li>
<li>自己的工作内容及可能的发展机会等。</li>
<li>向人事提问时最好不要一开始就谈工资，还有不要问太多可能留下不好印象的问题。问最基本的可能影响你去留的问题，其他问题可以进了再问，言多必失</li>
<li>面试前根据招聘信息的岗位要求多做相应准备</li>
</ul>
</li>
</ul>
<h4 id="你为什么来北京（城市）发展？"><a href="#你为什么来北京（城市）发展？" class="headerlink" title="你为什么来北京（城市）发展？"></a>你为什么来北京（城市）发展？</h4><ul>
<li>提出这个问题不要认为胡乱回答就行了，面试官是想看你什么原因，是否稳定。不会有哪家公司找一个很不稳定的人的。回答尽量夸城市，想在这里发展云云</li>
</ul>
<h4 id="你离职原因？"><a href="#你离职原因？" class="headerlink" title="你离职原因？"></a>你离职原因？</h4><ul>
<li>说到这个问题很多人都很头大，换工作的人清楚这个问题基本是必问的一个问题</li>
<li>这个问题很难回答，为什么呢？因为你如果说是公司的问题，这不好那不好，那么就很危险了，因为面试官会想，以后你从我们公司走出去是不是也这么说我们公司。说因为自己的原因呢，如果没好的理由，面试官也会想如果你来公司因为这些理由离开我公司呢，给人很不稳定的感觉</li>
<li>一般我会回答公司倒闭或者公司被收购、实习到期或者你本身确实有不得已的理由，比如公司发展和自己的发展不符合，等等，不要直接说公司或者自己的某些原因。除非没有好理由</li>
</ul>
<h4 id="为什么来我们公司？我们公司你了解多少？"><a href="#为什么来我们公司？我们公司你了解多少？" class="headerlink" title="为什么来我们公司？我们公司你了解多少？"></a>为什么来我们公司？我们公司你了解多少？</h4><ul>
<li>问这个就考察你的提前准备的资料了，既然这家公司通知你面试了，你肯定要去查相关资料，不需要详细的，但是你肯定要公司做什么的要知道</li>
<li>这个要考察自己巴拉巴拉的能力了，比如我觉得公司发展跟我想做的蛮符合的，我想珍惜这个机会…与公司同步发展云云</li>
</ul>
<h4 id="你认为你的优点和缺点有哪些？"><a href="#你认为你的优点和缺点有哪些？" class="headerlink" title="你认为你的优点和缺点有哪些？"></a>你认为你的优点和缺点有哪些？</h4><ul>
<li>不要认为这个问题很简单，吹吹牛就可以了。</li>
<li>首先你要清楚的知道，你的优点基本能在你工作中用到的，你的缺点千万不能出现在工作中。优点很好说，缺点就很难。优点比如，我工作认真踏实，团队意识强，学习能力强等等等，缺点你怎么说呢？好吃懒做，不思进取。这样回答基本就挂了。你必须自己的缺点和公司无关紧要的，经过面试经验，一般回答你自己生活上的，比如我花钱控制不了那么详细，就会引起对方的兴趣，那你干嘛了？你可以随便说了，我一般控制自己每月花一千，但是朋友聚会花了一千五。对金钱控制不好，这完全不影响你的工作。其他也可以自己想其他理由。</li>
</ul>
<h4 id="不知情况乱开价：-—-提前查好对应的工资基本水平"><a href="#不知情况乱开价：-—-提前查好对应的工资基本水平" class="headerlink" title="不知情况乱开价： —-提前查好对应的工资基本水平"></a>不知情况乱开价： —-提前查好对应的工资基本水平</h4><ul>
<li>说到薪资60%代表你有很大的机会被录用，可是你却狮子大开口的说薪资要求，企业怎么敢用一个漫不符合本身能力的人?如果不想吃亏，应聘前应多打听企业相关信息，不然就采取“依公司规定”的保守战略。不知行情胡乱开价，绝不让你的应聘倒扣200分。</li>
<li>北京这边的人力资源市场还是非常繁荣的，人才的流动性非常快，每年有两段流动高峰期。<ul>
<li>通常3<del>4月和9</del>10月是找工作高峰期：<ul>
<li>3~4月是大量人才拿到年终奖后跳槽的时期；</li>
<li>9~10月是各大高校毕业生求职时期；</li>
</ul>
</li>
<li>这两段时间都是企业释放大量岗位空缺的时间段，故而是求职旺季。</li>
</ul>
</li>
<li>跳槽也最好在这段时间，其它时间段最好不要跳槽，因为这时：一来岗位无空缺不好招人，二来公司人事会认为你是被裁员工印象不好，这样就不好谈价格了。</li>
<li>注意公司是以技能需求为驱动在人才市场里面找拥有目标技能的目标人群，而非以你所做项目为驱动，所以在简历里面技能项要分条重点表达，所做项目要辅助技能项做大致表达。</li>
<li>有些公司在行业里面有地位，是龙头老大，例如BAT、京东等的高并发系统架构方面的业务；平安等互联网金融的支付业务。这些公司的业务代表了行业规范，起到示范作用，能够学习到他们公司的这种权威性的技术或业务，以后可以到想效仿这些公司的其它小公司里面去，就可以有谈判的资本了，这就是在大公司的好处。（这就是为何在BAT工作的人，只要接触了BAT的核心技术，跳出来就那么值钱）</li>
<li>有些公司的某些部门，明明就不缺人，却天天打着招人的旗号，让人去面试。那么被猎头&#x2F;人事叫去面试之前，先问了解一些具体情况，有如下一些意识：<ul>
<li>从岗位角度问： 这个岗位是常年招聘的，还是最近刚招聘的。<ul>
<li>（如果是常年招聘的，那么最好不要过去了，人家公司上层可能都没有提供新员工名额，让你过去对你的要求是极高，你达到了或许有点希望，而且后面谈工资的时候对自己没有多少优势；如果是最近刚招聘的、岗位急着要人的，那么可以试试。）</li>
</ul>
</li>
<li>从部门角度问： 这个岗位所在的部门是什么情况，是由于业务扩展新成立的，还是一些老的部门。<ul>
<li>（如果是新成立一个部门，那么确实有可能要进新人，公司可能会放出岗位需求名额；如果是不是新成立的部门，是老部门，那么很可能这个岗位招人就不那么迫切。）</li>
</ul>
</li>
<li>从岗位职责要求角度问： 这个岗位的职责是什么，需要有什么技能的人选。<ul>
<li>（可以先让跟你打电话的猎头&#x2F;人事给你发一个JD邮件，你看看是否和你的技能、兴趣相符，如果相符则可以考虑是否过去；如果不相符，你都不知道他看了你的简历后怎么选的你，那你要么回信问清楚为何觉得我合适、贵岗位具体需要什么人做什么事情，如果没回音，就不要再管了，他们不要人的。不要怕把他们问烦了，他们如果真的缺人，那么不怕你多问，还怕你不来呢，问两句就烦，直接就说明他们本来就不确认，你去不去面试对他们影响不大。）</li>
</ul>
</li>
<li>面试过程中要有警觉： 如果最终还是去了，那么面试过程中也可以看到他们是否缺人。如果面试官上来就问你以前的项目，要你给他详细讲解，那么多半想把你当成免费的”老师“，你可以准备好一些素材给他讲；他问你有没有什么要问他的，你可以问他们要什么样技能的人，如果他们说的空泛不具体，不说需要具体掌握什么技能的，就是他们自己都不能详细表达岗位需求，那多半也不缺人。</li>
</ul>
</li>
<li>为何有些公司要这样“挖坑挖 ”呢？为何要设置那些长期招聘的岗位呢？ 呢<ul>
<li>第一、未雨绸缪。如果公司认为过段时间有人会离职，尤其是发完年终奖之前，那么就会提前做好准备，去招新人减少风险，而老员工未走新员工的招聘进度可以慢一点来。</li>
<li>第二、降低人力成本。如果公司当前人力成本太高，那么就想淘汰部分高价的老员工换来廉价新员工，那么会在老员工走之前招人，而新员工的招聘也可以慢一点来，招的到就招，招不到就不招，总之价格要压低。（这样的公司卸磨杀驴，不去也罢）</li>
<li>第三、换血。如果公司的部门当前好久没有换血了，对部门不是太有利，那么也是常年打着招聘的旗号招人，碰到真正有料的人选，如果成功压低了价格，也可以招进来，但公司不太缺人的情况下，不招也行。</li>
<li>第四、了解行业动态。这主要是部门某些人心术不正，让面试者赶来面试，当免费老师，以面试为名从面试者口中获取一些其它公司的技术内幕。（搞技术的人都不傻，出来混迟早要还的，心术不正败坏的是自己公司的名声。）</li>
</ul>
</li>
<li>面试官问你的职业规划？该怎么回答？回答这个问题要注意三点：<ul>
<li>接地气。也就是实实在在的说，不做作。这应该是在跟HR交流各个问题都要注意的，不要去学习面经上那些头头是道的回答，针对性并不强，不能把自己的特质表露出来，这对应聘双方都是无益的。搞清楚自己的想法，流畅的表达就行了（表达上也许需要一些技巧），至于如何搞清楚自己的想法，请看第二点。</li>
<li>预先做功课。了解自己和了解社会是一生都不应该停止的两个过程。在应聘之前，需要对自己和要应聘的行业、公司、岗位都有一定的了解，知道自己的兴趣点和竞争优势，在这个基础上才能够谈职业规划。</li>
<li>区分职业和工作。HR问你职业规划，也许只是在探寻你对这个岗位或公司的热衷度，判断你是无关痛痒的仅仅想要一份工作安身，还是对未来的发展有一定的方向，方向和目标自然不可能太具体，所以觉得难回答，但是，面试官想知道的其实是你对自己未来的期许是什么样子的，仅此而已。</li>
<li>参考：我希望在 我 **公司发展成为 公 “T”字形人才，短期目标，我希望能够接触尽可能多的知识面，努力扩展自己专业技能的 字 “横”，可以独立的完成工作中的每一个任务。长期目标，我希望自己在知识面足够宽的基础上，能够有一到两个方向的深入研究，深入自己工作中的一 长 ”竖“，早日独当一面，成为公司的中流砥柱，</li>
</ul>
</li>
</ul>
<h4 id="人事问工资该如何回答？"><a href="#人事问工资该如何回答？" class="headerlink" title="人事问工资该如何回答？"></a>人事问工资该如何回答？</h4><ul>
<li>2年工作经验：<ul>
<li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等</li>
<li>工作的内容，公司的发展</li>
<li>半年的时候去做大数据项目后加过一次薪，9000加到了12000.</li>
<li>12K——-17K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1000左右</li>
</ul>
</li>
<li>3年工作经验：<ul>
<li>17K——–23K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1400左右</li>
<li>具体的情况，根据面试的好坏做相应的调整，但是工资的税前和税后差额一般在2k—3k</li>
</ul>
</li>
<li>面试的本质不是一问一答，而是亮点展示</li>
</ul>
<h1 id="请介绍一下你自己"><a href="#请介绍一下你自己" class="headerlink" title="请介绍一下你自己"></a>请介绍一下你自己</h1><ul>
<li>这是面试官100%会问的问题，一般人回答这个问题过于平常，只说姓名、年龄、爱好、所学专业等，如果你用一分钟来重复你的简历，那么，你的印象加分没有了！</li>
<li>不妨坦诚自信地展现自我，重点突出与应聘职位相吻合的优势。你的相关能力和素质是企业最感兴趣的信息。因为，在许多情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。</li>
<li>回答范例：我叫XX，今年X岁，XXXX年毕业于XX大学。有3年的开发工作经验，我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，精通.Net技术体系，熟悉MVC。平常有时间看看博客，并且自己也喜欢在CSDN上写技术类的文章，与博友一起讨论。谢谢！</li>
</ul>
<h1 id="为什么来北京找工作？"><a href="#为什么来北京找工作？" class="headerlink" title="为什么来北京找工作？"></a>为什么来北京找工作？</h1><ul>
<li>面试官对异地求职者90%都会问的问题，主要考察你是否稳定，个人经验能力之外，排在第一位的就是稳定性，如果不够稳定，那么其余都是空谈。</li>
<li>回答范例：我来自河南，河南是一个农业大省，IT行业还不是很发达，我是学计算机专业的，也很喜欢这个行业，北京在国内IT行业发展是最快的，所以我想来这里谋求发展，学习更多的新技术，能够带来自我的提升。</li>
<li>注意：不要说以前公司有多么不好。也不要说哪个哥们混的很不错，羡慕才来北京。因为企业招人想要的都是能够长期工作的人，可能哪个哥们哪天在别的地方又混的更好了，你是不是还要跳槽？所以，只要说来学习更多新技术和管理经验就够了。</li>
</ul>
<h1 id="你为什么离开原来的公司？"><a href="#你为什么离开原来的公司？" class="headerlink" title="你为什么离开原来的公司？"></a>你为什么离开原来的公司？</h1><ul>
<li>最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在</li>
<li>避免把“离职原因”说得太详细、太具体</li>
<li>不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等</li>
<li>但也不能躲闪、回避，如“想换换环境”、“个人原因”等</li>
<li>不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等</li>
<li>尽量使解释的理由为应聘者个人形象添彩</li>
<li>相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</li>
<li>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。</li>
</ul>
<h1 id="你最大的缺点是什么？"><a href="#你最大的缺点是什么？" class="headerlink" title="你最大的缺点是什么？"></a>你最大的缺点是什么？</h1><ul>
<li>被面试官问的概率很大，也是HR的杀手锏和狠招，这个问题最难回答，通常面试官不希望听到求职直接回答的缺点是什么，如果求职者说自己小心眼、脾气大、工作效率低，企业肯定不会录用你。不要自作聪明地回答“我最大的缺点就是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。面试官喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上，突出优点的部分，面试官喜欢聪明的求职者。</li>
<li>回答范例：这个问题好难回答啊！我想想……（亲和力表现，也缓解了自己的紧张情绪）我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。</li>
</ul>
<h1 id="你未来3-5年的职业规划是怎样的？"><a href="#你未来3-5年的职业规划是怎样的？" class="headerlink" title="你未来3-5年的职业规划是怎样的？"></a>你未来3-5年的职业规划是怎样的？</h1><ul>
<li>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</li>
<li>回答范例：我希望从现在开始，1-2年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以从开发做到架构师。同时我也希望自己能够在企业的平台上得到进一步的职业能力提升。</li>
</ul>
<h1 id="你对薪资的要求？"><a href="#你对薪资的要求？" class="headerlink" title="你对薪资的要求？"></a>你对薪资的要求？</h1><ul>
<li>如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求职的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</li>
<li>回答范例一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。</li>
<li>如果你必须自己说出具体数目，那就不要说一个宽泛的范围，不要说7000-8000之间，那样你将只会得到最低限底的数字，也就是7000。最好给出一个具体的数字。</li>
</ul>
<h1 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h1><ul>
<li>大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司的规定上班”，如果还未辞去上一个工作，但上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</li>
</ul>
<h1 id="介绍一个你认为最熟悉的项目（项目经理）"><a href="#介绍一个你认为最熟悉的项目（项目经理）" class="headerlink" title="介绍一个你认为最熟悉的项目（项目经理）"></a>介绍一个你认为最熟悉的项目（项目经理）</h1><ul>
<li>这个问题在技术面试时常被问到，问这个问题的意图是想考察你的成长路径和编程习惯，因为，你最熟悉的项目往往是你成长最快的项目，那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹。所以，通过你对熟悉项目的描述，有经验的他会很快锁定你技术成长中的缺陷和闪光点，从而判断是否能够“为我所用”。</li>
<li>你最好拿出一个自己最擅长技术的那个项目进行介绍，他听完你的介绍后，会接下来进行提问，这样他所有问的问题，你都成竹在胸了。</li>
<li>切忌拿自己参与很少的项目来介绍，一旦他深入的询问很可能你会答非所问，反而造成更严重的影响。你大强以和他谈谈在那个项目中获得的经验，这样会引起此君的共鸣，有可能的话，说出一些你自己的小技巧，他会很高兴，同时这场面试也会很轻松，拿到Offer基本没问题了。</li>
</ul>
<h1 id="如果公司录用你，你将怎样开展工作？"><a href="#如果公司录用你，你将怎样开展工作？" class="headerlink" title="如果公司录用你，你将怎样开展工作？"></a>如果公司录用你，你将怎样开展工作？</h1><ul>
<li>很多企业在招聘开发人员时很看重是否能够尽快上手，所以回答这个问题时要“实打实”的回答，在回答中最好强调能够“尽快”投入开发工作中，这样领导就放心了，会觉得你不是一个只会盲目工作的人，而是一个按部就班，稳打稳扎的人。</li>
<li>回答范例：我对咱们公司的大体情况只有一个大概了解，在这个职位的工作性质仅仅是我自己的一个理解。作为这个职位而言，我想我首先要对本公司的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向、我们面向的客户性质等。第二我要了解所属部门在公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。第三，了解我参与项目的开发方式，架构方式，紧密配合领导工作，尽快投入具体的开发工作中。这就是我开展工作的计划。</li>
</ul>
<h1 id="你还有什么问题问我吗？"><a href="#你还有什么问题问我吗？" class="headerlink" title="你还有什么问题问我吗？"></a>你还有什么问题问我吗？</h1><ul>
<li>这个问题看上去可有可无，其实很关键，面试官不喜欢说“没有问题”的人，没有问题就是自寻死路，没有问题传达出你对公司缺乏兴趣，而只是来寻找一笔薪水。其实在面试过程中谦虚礼貌的问面试官怎么称呼，该部门工作中的信息，如项目情况，开发技术再或者说贵公司的晋升机制是什么样的等。表现出一种很积极主动的状态是非常讨巧的。也可以更多的了解到自己来的工作环境。企业很欢迎这样的求职者，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</li>
</ul>
<h1 id="你对加班的看法？"><a href="#你对加班的看法？" class="headerlink" title="你对加班的看法？"></a>你对加班的看法？</h1><ul>
<li>实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。</li>
<li>回答范例：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</li>
</ul>
<h1 id="你朋友对你的评价？"><a href="#你朋友对你的评价？" class="headerlink" title="你朋友对你的评价？"></a>你朋友对你的评价？</h1><ul>
<li>回答提示： 想从侧面了解一下你的性格及与人相处的问题。</li>
<li>回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。</li>
<li>回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。</li>
</ul>
<h1 id="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"><a href="#如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？" class="headerlink" title="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"></a>如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</h1><ul>
<li>回答提示：一段时间发现工作不适合我，有两种情况：<ul>
<li>如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</li>
<li>你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</li>
</ul>
</li>
</ul>
<h1 id="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"><a href="#在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？" class="headerlink" title="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"></a>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</h1><ul>
<li>原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。</li>
<li>如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。</li>
<li>还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</li>
</ul>
<h1 id="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"><a href="#如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？" class="headerlink" title="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"></a>如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</h1><ul>
<li>我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。</li>
<li>分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。</li>
<li>总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</li>
</ul>
<h1 id="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"><a href="#如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？" class="headerlink" title="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"></a>如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</h1><ul>
<li>我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：<ul>
<li>我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。</li>
<li>他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</li>
</ul>
</li>
</ul>
<h1 id="谈谈你对跳槽的看法？"><a href="#谈谈你对跳槽的看法？" class="headerlink" title="谈谈你对跳槽的看法？"></a>谈谈你对跳槽的看法？</h1><ul>
<li>正常的“跳槽”能促进人才合理流动，应该支持。</li>
<li>频繁的跳槽对单位和个人双方都不利，应该反对。</li>
</ul>
<h1 id="工作中你难以和同事、上司相处，你该怎么办？"><a href="#工作中你难以和同事、上司相处，你该怎么办？" class="headerlink" title="工作中你难以和同事、上司相处，你该怎么办？"></a>工作中你难以和同事、上司相处，你该怎么办？</h1><ul>
<li>我会服从领导的指挥，配合同事的工作。</li>
<li>我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话 我会努力改正。</li>
<li>如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。</li>
<li>作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。</li>
</ul>
<h1 id="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"><a href="#假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？" class="headerlink" title="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"></a>假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</h1><ul>
<li>成绩比较突出，得到领导的肯定是件好事情，以后更加努力。</li>
<li>检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。</li>
<li>工作中，切勿伤害别人的自尊心。</li>
<li>不再领导前拨弄是非。<br>。</li>
</ul>
<h1 id="请说出你选择这份工作的动机？"><a href="#请说出你选择这份工作的动机？" class="headerlink" title="请说出你选择这份工作的动机？"></a>请说出你选择这份工作的动机？</h1><ul>
<li>这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</li>
</ul>
<h1 id="你最擅长的技术方向是什么？"><a href="#你最擅长的技术方向是什么？" class="headerlink" title="你最擅长的技术方向是什么？"></a>你最擅长的技术方向是什么？</h1><ul>
<li>说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</li>
</ul>
<h1 id="你能为我们公司带来什么呢？"><a href="#你能为我们公司带来什么呢？" class="headerlink" title="你能为我们公司带来什么呢？"></a>你能为我们公司带来什么呢？</h1><ul>
<li>企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</li>
</ul>
<h1 id="最能概括你自己的三个词是什么？"><a href="#最能概括你自己的三个词是什么？" class="headerlink" title="最能概括你自己的三个词是什么？"></a>最能概括你自己的三个词是什么？</h1><ul>
<li>我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，</li>
</ul>
<h1 id="你的业余爱好是什么？"><a href="#你的业余爱好是什么？" class="headerlink" title="你的业余爱好是什么？"></a>你的业余爱好是什么？</h1><ul>
<li>找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。</li>
</ul>
<h1 id="作为被面试者给我打一下分？"><a href="#作为被面试者给我打一下分？" class="headerlink" title="作为被面试者给我打一下分？"></a>作为被面试者给我打一下分？</h1><ul>
<li>试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</li>
</ul>
<h1 id="你怎么理解你应聘的职位？"><a href="#你怎么理解你应聘的职位？" class="headerlink" title="你怎么理解你应聘的职位？"></a>你怎么理解你应聘的职位？</h1><ul>
<li>把岗位职责和任务及工作态度阐述一下。</li>
</ul>
<h1 id="喜欢这份工作的哪一点？"><a href="#喜欢这份工作的哪一点？" class="headerlink" title="喜欢这份工作的哪一点？"></a>喜欢这份工作的哪一点？</h1><ul>
<li>相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</li>
</ul>
<h1 id="说说你对行业、技术发展趋势的看法？"><a href="#说说你对行业、技术发展趋势的看法？" class="headerlink" title="说说你对行业、技术发展趋势的看法？"></a>说说你对行业、技术发展趋势的看法？</h1><ul>
<li>企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</li>
</ul>
<h1 id="对工作的期望与目标何在？"><a href="#对工作的期望与目标何在？" class="headerlink" title="对工作的期望与目标何在？"></a>对工作的期望与目标何在？</h1><ul>
<li>这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</li>
</ul>
<h1 id="说你的家庭"><a href="#说你的家庭" class="headerlink" title="说你的家庭"></a>说你的家庭</h1><ul>
<li>企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。</li>
<li>企业希望听到的重点也在于家庭对求职者的积极影响。</li>
<li>企业最喜欢听到的是：我很爱我的家庭，我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。</li>
<li>我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。</li>
<li>企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</li>
</ul>
<h1 id="就你申请的这个职位，你认为你还欠缺什么？"><a href="#就你申请的这个职位，你认为你还欠缺什么？" class="headerlink" title="就你申请的这个职位，你认为你还欠缺什么？"></a>就你申请的这个职位，你认为你还欠缺什么？</h1><ul>
<li>企业喜欢问求职者弱点，但精明的求职者一般不直接回答。</li>
<li>他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</li>
</ul>
<h1 id="你欣赏哪种性格的人？"><a href="#你欣赏哪种性格的人？" class="headerlink" title="你欣赏哪种性格的人？"></a>你欣赏哪种性格的人？</h1><ul>
<li>诚实、不死板而且容易相处的人、有“实际行动”的人。</li>
</ul>
<h1 id="你通常如何处理別人的批评？"><a href="#你通常如何处理別人的批评？" class="headerlink" title="你通常如何处理別人的批评？"></a>你通常如何处理別人的批评？</h1><ul>
<li>沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。</li>
<li>我会等大家冷靜下来再讨论。</li>
</ul>
<h1 id="你为什么愿意到我们公司来工作？"><a href="#你为什么愿意到我们公司来工作？" class="headerlink" title="你为什么愿意到我们公司来工作？"></a>你为什么愿意到我们公司来工作？</h1><ul>
<li>对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</li>
</ul>
<h1 id="你和别人发生过争执吗？你是怎样解决的？"><a href="#你和别人发生过争执吗？你是怎样解决的？" class="headerlink" title="你和别人发生过争执吗？你是怎样解决的？"></a>你和别人发生过争执吗？你是怎样解决的？</h1><ul>
<li>这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。</li>
<li>你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。</li>
<li>他们通过这个问题了解你的成熟度和处世能力。</li>
<li>在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</li>
</ul>
<h1 id="问题：你做过的哪件事最令自己感到骄傲？"><a href="#问题：你做过的哪件事最令自己感到骄傲？" class="headerlink" title="问题：你做过的哪件事最令自己感到骄傲？"></a>问题：你做过的哪件事最令自己感到骄傲？</h1><ul>
<li>这是考官给你的一个机会，让你展示自己把握命运的能力。</li>
<li>这会体现你潜在的领导能力以及你被提升的可能性。</li>
<li>假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐</li>
<li>记住：你的前途取决于你的知识、你的社交能力和综合表现。</li>
</ul>
<h1 id="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"><a href="#新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？" class="headerlink" title="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"></a>新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？</h1><ul>
<li>首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。</li>
<li>其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。</li>
<li>再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。</li>
<li>再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。</li>
<li>我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。</li>
</ul>
<h1 id="对这项工作，你有哪些可预见的困难？"><a href="#对这项工作，你有哪些可预见的困难？" class="headerlink" title="对这项工作，你有哪些可预见的困难？"></a>对这项工作，你有哪些可预见的困难？</h1><ul>
<li>不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。</li>
<li>可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。</li>
<li>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。</li>
<li>当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</li>
</ul>
<h1 id="怎样对待自己的失敗？"><a href="#怎样对待自己的失敗？" class="headerlink" title="怎样对待自己的失敗？"></a>怎样对待自己的失敗？</h1><ul>
<li>我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</li>
</ul>
<h1 id="什么会让你有成就感？"><a href="#什么会让你有成就感？" class="headerlink" title="什么会让你有成就感？"></a>什么会让你有成就感？</h1><ul>
<li>为贵公司竭力效劳，尽我所能，完成一个项目。</li>
</ul>
<h1 id="眼下你生活中最重要的是什么？"><a href="#眼下你生活中最重要的是什么？" class="headerlink" title="眼下你生活中最重要的是什么？"></a>眼下你生活中最重要的是什么？</h1><ul>
<li>对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。</li>
</ul>
<h1 id="与上级意见不一是，你将怎么办？"><a href="#与上级意见不一是，你将怎么办？" class="headerlink" title="与上级意见不一是，你将怎么办？"></a>与上级意见不一是，你将怎么办？</h1><ul>
<li><p>一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</p>
</li>
<li><p>如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</p>
</li>
<li><p>分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p>
</li>
<li><p>你工作经验欠缺，如何能胜任这项工作？</p>
</li>
<li><p>如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。</p>
</li>
<li><p>对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。</p>
</li>
<li><p>如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</p>
</li>
<li><p>点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p>
</li>
</ul>
<h1 id="你希望与什么样的上级共事？"><a href="#你希望与什么样的上级共事？" class="headerlink" title="你希望与什么样的上级共事？"></a>你希望与什么样的上级共事？</h1><ul>
<li>通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。</li>
<li>最好回避对上级具体的希望，多谈对自己的要求。</li>
<li>如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。</li>
<li>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</li>
</ul>
<h1 id="谈谈如何适应办公室工作的新环境？"><a href="#谈谈如何适应办公室工作的新环境？" class="headerlink" title="谈谈如何适应办公室工作的新环境？"></a>谈谈如何适应办公室工作的新环境？</h1><ul>
<li>办公室里每个人有各自的岗位与职责，不得擅离岗位。</li>
<li>根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。</li>
<li>多请示并及时汇报，遇到不明白的要虚心请教。</li>
<li>抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</li>
</ul>
<h1 id="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"><a href="#为了做好你工作份外之事，你该怎样获得他人的支持和帮助？" class="headerlink" title="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"></a>为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</h1><ul>
<li>每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</li>
</ul>
<h1 id="如果你在这次面试中没有被录用，你怎么打算？"><a href="#如果你在这次面试中没有被录用，你怎么打算？" class="headerlink" title="如果你在这次面试中没有被录用，你怎么打算？"></a>如果你在这次面试中没有被录用，你怎么打算？</h1><ul>
<li>现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。</li>
<li>我会从以下几个方面来正确看待这次失败：<ul>
<li>要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。</li>
<li>善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。</li>
<li>走出阴影，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。</li>
<li>认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的成绩。</li>
<li>再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞争。</li>
</ul>
</li>
</ul>
<h1 id="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"><a href="#假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？" class="headerlink" title="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"></a>假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？</h1><ul>
<li>我觉得工作是第一位的，但朋友间的情谊也是不能偏废的，这个问题我觉得要按照当时具体的情况来决定。</li>
<li>如果我的朋友晚上9点中的飞机，而我的加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。</li>
<li>如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。</li>
<li>如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。<ul>
<li>如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。</li>
<li>如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，相信他会理解，毕竟工作做完了就完了，朋友还是可以再见面的。</li>
</ul>
</li>
</ul>
<h1 id="谈谈你过去做过的成功案例？"><a href="#谈谈你过去做过的成功案例？" class="headerlink" title="谈谈你过去做过的成功案例？"></a>谈谈你过去做过的成功案例？</h1><ul>
<li>举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。</li>
<li>切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</li>
</ul>
<h1 id="谈谈你过去的工作经验中，最令你挫折的事情？"><a href="#谈谈你过去的工作经验中，最令你挫折的事情？" class="headerlink" title="谈谈你过去的工作经验中，最令你挫折的事情？"></a>谈谈你过去的工作经验中，最令你挫折的事情？</h1><ul>
<li>曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。</li>
<li>分析：借此了解你对挫折的容忍度及调解方式。</li>
</ul>
<h1 id="如何安排自己的时间？会不会排斥加班？"><a href="#如何安排自己的时间？会不会排斥加班？" class="headerlink" title="如何安排自己的时间？会不会排斥加班？"></a>如何安排自己的时间？会不会排斥加班？</h1><ul>
<li>基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。</li>
<li>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</li>
</ul>
<h1 id="为什么我们要在众多的面试者中选择你？"><a href="#为什么我们要在众多的面试者中选择你？" class="headerlink" title="为什么我们要在众多的面试者中选择你？"></a>为什么我们要在众多的面试者中选择你？</h1><ul>
<li>根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、ＥＱ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。</li>
<li>分析：别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。</li>
</ul>
<h1 id="你并非毕业于名牌院校？"><a href="#你并非毕业于名牌院校？" class="headerlink" title="你并非毕业于名牌院校？"></a>你并非毕业于名牌院校？</h1><ul>
<li>是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我想我更适合贵公司这个职位。</li>
</ul>
<h1 id="怎样看待学历和能力？"><a href="#怎样看待学历和能力？" class="headerlink" title="怎样看待学历和能力？"></a>怎样看待学历和能力？</h1><ul>
<li>学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？</li>
</ul>
<h1 id="工作中学习到了些什么？"><a href="#工作中学习到了些什么？" class="headerlink" title="工作中学习到了些什么？"></a>工作中学习到了些什么？</h1><ul>
<li>这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</li>
</ul>
<h1 id="想过创业吗？"><a href="#想过创业吗？" class="headerlink" title="想过创业吗？"></a>想过创业吗？</h1><ul>
<li>这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？</li>
</ul>
<h1 id="除了本公司外，还应聘了哪些公司？"><a href="#除了本公司外，还应聘了哪些公司？" class="headerlink" title="除了本公司外，还应聘了哪些公司？"></a>除了本公司外，还应聘了哪些公司？</h1><ul>
<li>很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</li>
</ul>
<h1 id="面试注意事项："><a href="#面试注意事项：" class="headerlink" title="面试注意事项："></a>面试注意事项：</h1><ul>
<li>在面试官面前千万不要抖脚，手脚不要动来动去，不能有小动作。</li>
<li>在面试过程中，千万不要跟面试官去争论，说话太冲，太能说、抢话说、乱说都不好，遇到难题，先思考一下，切记心浮气燥，表达时口气温和，谦虚。</li>
<li>如果面试过程中都不错，谈的也很好，之后却没有给Offer，完全是自己意料之外的情况，这个很有可能，或许是因为公司有了其他的人选，不用介意，更不要沮丧。</li>
<li>在面试过程中，切忌问关于公司计划、行业机密等相关的东西，不要打探公司的内幕，机密敏感性的问题不要问东问西。</li>
<li>千万要注意仪容仪表，要有礼貌，最好不要有口吃，口头表达，逻辑思维很重要，不要让面试官觉得你很幼稚，太过小孩子气，显的不够稳重踏实。</li>
<li>在去面试之前，要熟悉自己的简历，特别是工作经历，准备好关于一些离职原因、职业规划方面的问题的回答方式。</li>
<li>在面试过程中，80%的面试官会让做自我介绍，所以提前要准备一下，说出的内容既要和简历相符，又要有重点有突出的地方，不能像背简历一样。</li>
<li>面试完后，如果等待的时间较长，没有回应，就可能没有什么希望了，自己可以打电话去了解情况。</li>
<li>在面试过程中，谈到薪资的时候，如果没有说明是税后工资就是税前，假如是税前6000，这里面就包括了公司给交的公积金，还有其他五险要交的费用，拿到手差不多4000左右。</li>
</ul>
<h1 id="投递简历注意事项"><a href="#投递简历注意事项" class="headerlink" title="投递简历注意事项"></a>投递简历注意事项</h1><ul>
<li>投简历的时间最好在早上8点多钟，因为人事9点多开始收简历，收到的简历又都是按时间来排序的，所以一般早上8点到9点投的都会排在前面，人事当天就能看到。</li>
<li>写简历：<ul>
<li>现居住地最好能在企业附近，如果不在，只写北京，人事比较看重现居住地，如果你填写的现居地离公司远，基本上人事就不太愿意打电话了，因为她（他）怕你不会来。</li>
<li>期望薪资最好不要写在简历上，也不要填写在网上的简历上，具体薪资见面的时候再谈。</li>
<li>大部分的岗位招聘都有相应的硬性要求，比如：年龄、居住地点、工作年限等。如果自己不符合也没有关系，机会还有很多。</li>
<li>简历上的工作经历不能太多，否则人事会觉得你不够稳定。</li>
<li>开发工作，简历上的项目要抓住重点，放重要的技术点，不能千篇一律，简短、抓住中心。</li>
</ul>
</li>
</ul>
<h1 id="入职后试用期："><a href="#入职后试用期：" class="headerlink" title="入职后试用期："></a>入职后试用期：</h1><ul>
<li>到了公司之后，工作中不懂的地方要多问，跟同事搞好关系，多看看旁人在干什么～</li>
<li>有些同学被录用之后都还不知道自己的薪资待遇，也不知道公司有哪些福利，这是因为在面试过程中不敢多问。因此，如果在面试过程中，面试官已经比较明确的表达了想让你去上班后，你就可以在适当的时候问一些关于工作的情况，工资、福利待遇，上班时间，加班情况等等。</li>
</ul>
<h1 id="上家公司的组成架构"><a href="#上家公司的组成架构" class="headerlink" title="上家公司的组成架构"></a>上家公司的组成架构</h1><ul>
<li>根据你的公司来定即可</li>
</ul>
]]></content>
      <categories>
        <category>面试技巧</category>
      </categories>
      <tags>
        <tag>面试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/publishes/7fec0b877c88.html</url>
    <content><![CDATA[<h1 id="JSON及其作用"><a href="#JSON及其作用" class="headerlink" title="JSON及其作用"></a>JSON及其作用</h1><ul>
<li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式</li>
<li>同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据不须要任何特殊的 API 或工具包。</li>
<li>在JSON中，有两种结构：对象和数组。<ul>
<li>一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称&#x2F;值’ 对”之间运用 “,”（逗号）分隔。 名称用引号括起来；值如果是字符串则必须用括号，数值型则不须要。例如：<ul>
<li>var o&#x3D;{“xlid”:”cxh”,”xldigitid”:123456,”topscore”:2000,”topplaytime”:”2009-08-20”}；</li>
</ul>
</li>
<li>数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间运用 “,”（逗号）分隔。例如：<ul>
<li>var jsonranklist&#x3D;[{“xlid”:”cxh”,”xldigitid”:123456,”topscore”:2000,”topplaytime”:”2009-08-20”},{“xlid”:”zd”,”xldigitid”:123456,”topscore”:1500,”topplaytime”:”2009-11-20”}];</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>序列化</category>
      </categories>
      <tags>
        <tag>JSON</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/publishes/54eea449909d.html</url>
    <content><![CDATA[<h1 id="xml有哪些解析技术-区别是什么"><a href="#xml有哪些解析技术-区别是什么" class="headerlink" title="xml有哪些解析技术?区别是什么?"></a>xml有哪些解析技术?区别是什么?</h1><ul>
<li>有DOM,SAX,STAX等</li>
</ul>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><ul>
<li>处理大型文件时其性能下降的非常厉害</li>
<li>这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式</li>
<li>它顺序读取XML文件，不需要一次全部装载整个文件</li>
<li>当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问</li>
</ul>
<h4 id="STAX"><a href="#STAX" class="headerlink" title="STAX"></a>STAX</h4><ul>
<li>Streaming API for XML (StAX)</li>
</ul>
<h1 id="你在项目中用到了xml技术的哪些方面-如何实现的"><a href="#你在项目中用到了xml技术的哪些方面-如何实现的" class="headerlink" title="你在项目中用到了xml技术的哪些方面?如何实现的?"></a>你在项目中用到了xml技术的哪些方面?如何实现的?</h1><ul>
<li>用到了数据存贮，信息配置两方面</li>
<li>在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理</li>
<li>在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。</li>
</ul>
<h1 id="XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"><a href="#XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？" class="headerlink" title="XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"></a>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</h1><ul>
<li>两种形式 dtd  schema</li>
<li>本质区别<ul>
<li>schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)</li>
</ul>
</li>
<li>有DOM,SAX,STAX等</li>
</ul>
]]></content>
      <categories>
        <category>序列化</category>
      </categories>
      <tags>
        <tag>序列化</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/publishes/c0d8e27e97f4.html</url>
    <content><![CDATA[<h1 id="用什么关键字修饰同步方法"><a href="#用什么关键字修饰同步方法" class="headerlink" title="用什么关键字修饰同步方法"></a>用什么关键字修饰同步方法</h1><ul>
<li>用synchronized关键字修饰同步方法</li>
</ul>
<h1 id="stop-和suspend-方法为何不推荐使用"><a href="#stop-和suspend-方法为何不推荐使用" class="headerlink" title="stop()和suspend()方法为何不推荐使用"></a>stop()和suspend()方法为何不推荐使用</h1><ul>
<li>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</li>
<li>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</li>
</ul>
<h1 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h1><ul>
<li>最大的不同是在等待时wait会释放锁，而sleep一直持有锁</li>
<li>Wait通常被用于线程间交互，sleep通常被用于暂停执行</li>
<li>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li>
<li>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li>
<li>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。</li>
<li>wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。</li>
<li>sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器</li>
</ul>
<h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul>
<li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取</li>
<li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率</li>
</ul>
<h1 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h1><ul>
<li>启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态</li>
<li>一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码</li>
</ul>
<h1 id="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h1><ul>
<li>分几种情况：<ul>
<li>其他方法前是否加了synchronized关键字，如果没加，则能。</li>
<li>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</li>
<li>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</li>
<li>如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</li>
</ul>
</li>
</ul>
<h1 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h1><ul>
<li>一个程序中可以有多条执行线索同时执行</li>
<li>一个线程就是程序中的一条执行线索</li>
<li>每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行</li>
<li>每个程序至少都有一个线程，即main方法执行的那个线程</li>
<li>如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行。</li>
<li>线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身</li>
<li>Java中的线程有四种状态分别是：运行、就绪、挂起、结束</li>
<li>线程是操作系统能够进⾏运算调度的最⼩单位，它被包含在进程之中，是进程中的实际运作单位，可以使⽤多线程对进⾏运算提速</li>
</ul>
<h1 id="简述synchronized和java-util-concurrent-locks-Lock的异同"><a href="#简述synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="简述synchronized和java.util.concurrent.locks.Lock的异同"></a>简述synchronized和java.util.concurrent.locks.Lock的异同</h1><ul>
<li>主要相同点：Lock能完成synchronized所实现的所有功能</li>
<li>主要不同点<ul>
<li>Lock有比synchronized更精确的线程语义和更好的性能</li>
<li>ynchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放</li>
<li>Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁</li>
</ul>
</li>
</ul>
<h1 id="Synchronized和ReentrantLock有什么区别"><a href="#Synchronized和ReentrantLock有什么区别" class="headerlink" title="Synchronized和ReentrantLock有什么区别?"></a>Synchronized和ReentrantLock有什么区别?</h1><ul>
<li>synchronized是Java内建的同步机制,所以也有人称其为Intrinsic Locking（固有锁），它提供了互斥的语义和可见性,当一个线程已经获取当前锁时,其他试图获取的线程只能等待或者阻塞在那里。在Java  5以前,synchronized是仅有的同步手段,在代码中,synchronized可以用来修饰方法,也可以使用在特定的代码块上,本质上 synchronized方法等同于把方法全部语句用synchronized块包起来。</li>
<li>ReentrantLock,通常翻译为再入锁,是Java 5提供的锁实现,它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取,代码书写更加灵活。与此同时,ReentrantLock提供了很多实用的方法,能够实现很多synchronized无法做到的细节控制,但是在编码中也需要注意,必须要明确调用unlock()方法释放,不然就会一直持有该锁。synchronzied和ReentrantLock的性能不能一概而论,早期版本synchronized在很多场景下性能相差较大,在后续版本进行了较多改进,在低竞争场景中表现可能优于ReentrantLock。</li>
</ul>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul>
<li>可重⼊锁。可重⼊锁是指同⼀个线程可以多次获取同⼀把锁。ReentrantLock和synchronized都是可重⼊锁。</li>
<li>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，⽽ReentrantLock则提供了中断功能。</li>
<li>公平锁是指多个线程同时尝试获取同⼀把锁时，获取锁的顺序按照线程达到的顺序</li>
<li>⾮公平锁则允许线程“插队”</li>
<li>synchronized是⾮公平锁，⽽ReentrantLock的默认实现是⾮公平锁，但是也可以设置为公平锁。</li>
</ul>
<h4 id="CAS操作-CompareAndSwap"><a href="#CAS操作-CompareAndSwap" class="headerlink" title="CAS操作(CompareAndSwap)"></a>CAS操作(CompareAndSwap)</h4><ul>
<li>CAS操作简单的说就是⽐较并交换</li>
<li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)</li>
<li>如果内存位置的值与预期原值相匹配，那么处理器会⾃动将该位置值更新为新值。否则，处理器不做任何操作</li>
<li>⽆论哪种情况，它都会在 CAS 指令之前返回该位置的值</li>
<li>CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</li>
</ul>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ul>
<li>synchronized是java内置的关键字，它提供了⼀种独占的加锁⽅式</li>
<li>synchronized的获取和释放锁由JVM实现，⽤户不需要显示的释放锁，⾮常⽅便</li>
<li>然⽽synchronized也有⼀定的局限性：<ul>
<li>当线程尝试获取锁的时候，如果获取不到锁会⼀直阻塞。</li>
<li>如果获取锁的线程进⼊休眠或者阻塞，除⾮当前线程异常，否则其他线程尝试获取锁必须⼀直等待。</li>
</ul>
</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul>
<li>ReentrantLock它是JDK 1.5之后提供的API层⾯的互斥锁，需要lock()和unlock()⽅法配合try&#x2F;finally语句块来完成。</li>
<li>等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）</li>
<li>公平锁与⾮公平锁多个线程等待同⼀个锁时，必须按照申请锁的时间顺序获得锁</li>
<li>Synchronized锁⾮公平锁，ReentrantLock默认的构造函数是创建的⾮公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li>
</ul>
<h1 id="请说出你所知道的线程同步的方法"><a href="#请说出你所知道的线程同步的方法" class="headerlink" title="请说出你所知道的线程同步的方法"></a>请说出你所知道的线程同步的方法</h1><ul>
<li>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</li>
<li>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</li>
<li>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级</li>
<li>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li>
</ul>
<h1 id="同步有几种实现方法-都是什么"><a href="#同步有几种实现方法-都是什么" class="headerlink" title="同步有几种实现方法,都是什么?"></a>同步有几种实现方法,都是什么?</h1><ul>
<li>同步的实现方面有两种，分别是synchronized,wait与notify</li>
</ul>
<h1 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul>
<li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信</li>
<li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信</li>
<li>这种方式，本质上就是“共享内存”式的通信</li>
<li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行</li>
</ul>
<h4 id="while轮询的方式"><a href="#while轮询的方式" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul>
<li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()&#x3D;&#x3D;5)是否成立 ，从而实现了线程间的通信</li>
<li>但是这种方式会浪费CPU资源</li>
<li>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试某个条件是否成立</li>
<li>这种方式还存在另外一个问题：轮询的条件的可见性问题</li>
<li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li>
</ul>
<h4 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait&#x2F;notify机制"></a>wait&#x2F;notify机制</h4><ul>
<li>线程A要等待某个条件满足时(list.size()&#x3D;&#x3D;5)，才执行操作，线程B则向list中添加元素，改变list 的size</li>
<li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢</li>
<li>这里用到了Object类的 wait() 和 notify() 方法</li>
<li>当条件未满足时(list.size() !&#x3D;5)，线程A调用wait()放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</li>
<li>当条件满足时，线程B调用 notify()通知线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态</li>
<li>这种方式的一个好处就是CPU的利用率提高了，但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li>
</ul>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ul>
<li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li>
<li>分布式系统中说的两种通信机制：共享内存机制和消息通信机制</li>
<li>synchronized关键字和while轮询“属于”共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流</li>
<li>而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。</li>
</ul>
<h1 id="线程死锁及解决办法"><a href="#线程死锁及解决办法" class="headerlink" title="线程死锁及解决办法"></a>线程死锁及解决办法</h1><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><ul>
<li>所谓死锁： 是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁线程。</li>
<li>由于资源占用是互斥的，当某个线程提出申请资源后，使得有关线程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁</li>
<li>关键点：<ul>
<li>两个以上的线程</li>
<li>争夺共享的资源</li>
<li>它们各自不释放手中资源，除非有外力协助</li>
</ul>
</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul>
<li>让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y的拥有者分别等待对方的资源的问题。</li>
<li>将多个锁组成一组并放到同一个锁下</li>
<li>将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得容器对象的锁时，就可以通过检查变量来判断是否整个容器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试</li>
</ul>
<h1 id="锁分类的了解"><a href="#锁分类的了解" class="headerlink" title="锁分类的了解"></a>锁分类的了解</h1><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h4><ul>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁</li>
<li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象</li>
<li>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大</li>
<li>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁</li>
</ul>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul>
<li>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。</li>
<li>对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁</li>
</ul>
<h4 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁&#x2F;共享锁"></a>独享锁&#x2F;共享锁</h4><ul>
<li>独享锁是指该锁一次只能被一个线程所持有。</li>
<li>共享锁是指该锁可被多个线程所持有。</li>
<li>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。</li>
<li>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li>
<li>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</li>
<li>对于Synchronized而言，当然是独享锁。</li>
</ul>
<h4 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁&#x2F;读写锁"></a>互斥锁&#x2F;读写锁</h4><ul>
<li>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。</li>
<li>互斥锁在Java中的具体实现就是ReentrantLock</li>
<li>读写锁在Java中的具体实现就是ReadWriteLock</li>
</ul>
<h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h4><ul>
<li>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</li>
<li>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</li>
<li>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</li>
<li>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</li>
<li>悲观锁在Java中的使用，就是利用各种锁。</li>
<li>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li>
<li>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑</li>
<li>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接上了锁操作资源。</li>
</ul>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><ul>
<li>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</li>
<li>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。</li>
<li>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</li>
<li>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计</li>
<li>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作</li>
</ul>
<h4 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h4><ul>
<li>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</li>
<li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
<li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
<li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li>
</ul>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul>
<li>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区</li>
<li>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</li>
<li>⾃旋锁是SMP架构中的⼀种low-level的同步机制</li>
<li>当线程A想要获取⼀把⾃旋锁⽽该锁⼜被其它线程锁持有时，线程A会在⼀个循环中⾃旋以检测锁是不是已经可⽤了。</li>
<li>⾃选锁需要注意：<ul>
<li>由于⾃旋时不释放CPU，因⽽持有⾃旋锁的线程应该尽快释放⾃旋锁，否则等待该⾃旋锁的线程会⼀直在那⾥⾃旋，这就会浪费CPU时间</li>
<li>持有⾃旋锁的线程在sleep之前应该释放⾃旋锁以便其它线程可以获得⾃旋锁</li>
</ul>
</li>
<li>⽬前的JVM实现⾃旋会消耗CPU，如果⻓时间不调⽤doNotify⽅法，doWait⽅法会⼀直⾃旋，CPU会消耗太⼤</li>
<li>⾃旋锁⽐较适⽤于锁使⽤者保持锁时间⽐较短的情况，这种情况⾃旋锁的效率⽐较⾼</li>
<li>⾃旋锁是⼀种对多处理器相当有效的机制，⽽在单处理器⾮抢占式的系统中基本上没有作⽤</li>
</ul>
<h1 id="重入锁：ReentrantLock-详解"><a href="#重入锁：ReentrantLock-详解" class="headerlink" title="重入锁：ReentrantLock 详解"></a>重入锁：ReentrantLock 详解</h1><ul>
<li>在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的。除此之外，重入锁又自带一系列高逼格UBFF：可中断响应、锁申请等待限时、公平锁。另外可以结合Condition来使用，使其更是逼格满满。</li>
<li>使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对逻辑控制的灵活性远远大于synchronized关键字</li>
<li>需要注意，有加锁就必须有释放锁，而且加锁与释放锁的分数要相同，这里就引出了“重”字的概念</li>
</ul>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><ul>
<li>对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。</li>
<li>t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了死锁。但是，给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，正常执行完成。t2也会退出，但只是释放了资源并没有完成工作</li>
</ul>
<h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><ul>
<li>可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。</li>
<li>前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。</li>
<li>后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false</li>
</ul>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><ul>
<li>所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ReentrantLock-配合-Conditond-使用"><a href="#ReentrantLock-配合-Conditond-使用" class="headerlink" title="ReentrantLock 配合 Conditond 使用"></a>ReentrantLock 配合 Conditond 使用</h4><ul>
<li>配合关键字synchronized使用的方法如：await()、notify()、notifyAll()</li>
<li>ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象</li>
</ul>
<h1 id="深入理解Callable"><a href="#深入理解Callable" class="headerlink" title="深入理解Callable"></a>深入理解Callable</h1><ul>
<li>Callable和Runnbale一样代表着任务，区别在于Callable有返回值并且可以抛出异常</li>
<li>Callable接⼝使⽤泛型去定义它的返回类型</li>
<li>Executors类提供了⼀些有⽤的⽅法去在线程池中执⾏Callable内的任务</li>
<li>由于Callable任务是并⾏的，必须等待它返回的结果，java.util.concurrent.Future对象解决了这个问题</li>
<li>在线程池提交Callable任务后返回了⼀个Future对象，使⽤它可以知道Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()⽅法，等待Callable结束并获取它的执⾏结果</li>
</ul>
<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><ul>
<li>Future是一个接口，代表了一个异步计算的结果</li>
<li>接口中的方法用来检查计算是否完成、等待完成和得到计算的结果</li>
<li>当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了</li>
<li>如果想取消，那么调用cancel()方法</li>
<li>其他方法用于确定任务是正常完成还是取消了</li>
<li>一旦计算完成了，那么这个计算就不能被取消</li>
</ul>
<h4 id="FutureTask-是什么？"><a href="#FutureTask-是什么？" class="headerlink" title="FutureTask 是什么？"></a>FutureTask 是什么？</h4><ul>
<li>FutureTask 表示一个异步运算的任务，FutureTask 里面可以传入一个 Callable的具体实现类</li>
<li>可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、 取消任务等操作</li>
<li>FutureTask可⽤于异步获取执⾏结果或取消执⾏任务的场景</li>
<li>通过传⼊Runnable或者Callable的任务给FutureTask，直接调⽤其run⽅法或者放⼊线程池执⾏，之后可以在外部通过FutureTask的get⽅法异步获取执⾏结果</li>
<li>FutureTask⾮常适合⽤于耗时的计算，主线程可以在完成⾃⼰的任务后，再去获取结果</li>
<li>FutureTask还可以确保即使调⽤了多次run⽅法，它都只会执⾏⼀次Runnable或者Callable任务，或者通过cancel取消FutureTask的执⾏等</li>
<li>futuretask可⽤于执⾏多任务、以及避免⾼并发情况下多次创建数据机锁的出现。</li>
</ul>
<h4 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h4><ul>
<li><p>当将FutureTask提交给Executor后，Executor执行FutureTask时会执行其run方法</p>
</li>
<li><p>任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程</p>
</li>
<li><p>从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法</p>
</li>
<li><p>set方法：当Callable成功执行后，会调用set方法将结果传出</p>
</li>
<li><p>setException方法：该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程</p>
</li>
<li><p>get方法：当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。</p>
</li>
<li><p>在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待</p>
</li>
<li><p>awaitDone方法是如何将调用线程阻塞的,awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制</p>
</li>
<li><p>awaitDone方法中进入死循环后，主要有几步</p>
<ul>
<li>如果线程被中断了，移除节点，抛出异常</li>
<li>如果状态大于COMPLETING，那么直接返回</li>
<li>如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下</li>
<li>如果状态是NEW且节点为null，那么创建一个节点</li>
<li>如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程</li>
<li>如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点</li>
<li>如果没有限制时间，那么将线程无限挂起</li>
</ul>
</li>
<li><p>上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。</p>
</li>
<li><p>当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果</p>
</li>
<li><p>report会根据任务的状态不同返回不同的结果。</p>
<ul>
<li>如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果</li>
<li>如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException</li>
<li>如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException</li>
</ul>
</li>
<li><p>finishCompletion方法：在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程</p>
</li>
<li><p>finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环，释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。</p>
</li>
<li><p>cancel方法：用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了，如果是需要中断正在执行的任务，那么状态转换将会是NEW-&gt;INTERRPUTING-&gt;INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW-&gt;CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。</p>
</li>
<li><p>isDone方法：表明任务是否已经完成了，如果完成了，那么返回true，否则false，只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>Callable是一种可以返回结果的任务，这是它与Runnable的区别，但是通过适配器模式可以使Runnable与Callable类似</li>
<li>Future代表了一个异步的计算，可以从中得到计算结果、查看计算状态，其实现FutureTask可以被提交给Executor执行，多个线程可以从中得到计算结果</li>
<li>Callable和Future是配合使用的，当从Future中get结果时，如果结果还没被计算出来，那么线程将会被挂起，FutureTak内部使用一个单链表维持等待的线程；当计算结果出来后，将会对等待线程解除挂起，等待线程就都可以得到计算结果了。</li>
<li>Callable⽤于产⽣结果，Future⽤于获取结果</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h4 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h4><ul>
<li>发挥多核CPU 的优势，并发执⾏让系统运⾏的更快、更流畅，⽤户体验更好</li>
<li>防止阻塞：从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因 为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但 是单核 CPU 我们还是要应用多线程，就是为了防止阻塞</li>
<li>便于建模：这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么 就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成 几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运 行这几个任务，那就简单很多了。</li>
<li>使⽤多线程可以把程序中占据时间⻓的任务放到后台去处理，如图⽚、视屏的下载</li>
</ul>
<h4 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h4><ul>
<li>⼤量的线程降低代码的可读性；</li>
<li>更多的线程需要更多的内存空间</li>
<li>当多个线程对同⼀个资源出现争夺时候要注意线程安全的问题。</li>
</ul>
<h4 id="多线程的上下⽂切换"><a href="#多线程的上下⽂切换" class="headerlink" title="多线程的上下⽂切换"></a>多线程的上下⽂切换</h4><ul>
<li>CPU通过时间⽚分配算法来循环执⾏任务，当前任务执⾏⼀个时间⽚后会切换到下⼀个任务</li>
<li>在切换前会保存上⼀个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态</li>
</ul>
<h1 id="线程和进程的区别是什么"><a href="#线程和进程的区别是什么" class="headerlink" title="线程和进程的区别是什么"></a>线程和进程的区别是什么</h1><ul>
<li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式</li>
<li>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径</li>
<li>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些</li>
<li>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程</li>
</ul>
<h1 id="Java-实现线程有哪几种方式"><a href="#Java-实现线程有哪几种方式" class="headerlink" title="Java 实现线程有哪几种方式"></a>Java 实现线程有哪几种方式</h1><ul>
<li>继承 Thread 类实现多线程</li>
<li>实现 Runnable 接口方式实现多线程</li>
<li>使用 ExecutorService、Callable、Future 实现有返回结果的多线程</li>
</ul>
<h1 id="启动线程方法-start-和-run-有什么区别"><a href="#启动线程方法-start-和-run-有什么区别" class="headerlink" title="启动线程方法 start()和 run()有什么区别"></a>启动线程方法 start()和 run()有什么区别</h1><ul>
<li>只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代 码交替执行</li>
<li>如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码</li>
</ul>
<h1 id="一个线程的生命周期有哪几种状态？它们之间如何流转的？"><a href="#一个线程的生命周期有哪几种状态？它们之间如何流转的？" class="headerlink" title="一个线程的生命周期有哪几种状态？它们之间如何流转的？"></a>一个线程的生命周期有哪几种状态？它们之间如何流转的？</h1><ul>
<li>NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。</li>
<li>RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中 状态。</li>
<li>BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。</li>
<li>WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如 通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方 法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线 程就进入了 RUNNABLE 状态继续运行。</li>
<li>TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒 后线程重新进行 RUNNABLE 状态继续运行。</li>
<li>TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程 通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态</li>
</ul>
<h1 id="violatile-关键字的作用"><a href="#violatile-关键字的作用" class="headerlink" title="violatile 关键字的作用"></a>violatile 关键字的作用</h1><ul>
<li>volatile 关键字的作用主要有两个<ul>
<li>多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据</li>
<li>使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重要作用就是和CAS结合，保证了原子性</li>
</ul>
</li>
</ul>
<h1 id="新建-T1、T2、T3-三个线程，如何保证它们按顺序执行"><a href="#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证它们按顺序执行"></a>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行</h1><ul>
<li>用 join 方法。</li>
</ul>
<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><ul>
<li>什么是线程池？ 很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线 程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用</li>
<li>每个线程都要通过 new Thread(xxRunnable).start()的方 式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈</li>
<li>线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存</li>
</ul>
<h1 id="线程池⽤法与优势？"><a href="#线程池⽤法与优势？" class="headerlink" title="线程池⽤法与优势？"></a>线程池⽤法与优势？</h1><h4 id="ThreadPool-优点"><a href="#ThreadPool-优点" class="headerlink" title="ThreadPool 优点"></a>ThreadPool 优点</h4><ul>
<li>减少了创建和销毁线程的次数，每个⼯作线程都可以被重复利⽤，可执⾏多个任务</li>
<li>可以根据系统的承受能⼒，调整线程池中⼯作线线程的数⽬，防⽌因为因为消耗过多的内存，⽽把服务器累趴下</li>
<li>减少在创建和销毁线程上所花的时间以及系统资源的开销</li>
<li>如不使⽤线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存</li>
</ul>
<h4 id="⽐较重要的⼏个类"><a href="#⽐较重要的⼏个类" class="headerlink" title="⽐较重要的⼏个类"></a>⽐较重要的⼏个类</h4><ul>
<li>Java⾥⾯线程池的顶级接⼜是Executor，但是严格意义上讲Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具</li>
<li>真正的线程池接口是ExecutorService。</li>
</ul>
<h4 id="任务执⾏顺序："><a href="#任务执⾏顺序：" class="headerlink" title="任务执⾏顺序："></a>任务执⾏顺序：</h4><ul>
<li>ExecutorService 真正的线程池接⼝。</li>
<li>ScheduledExecutorService 能和Timer&#x2F;TimerTask类似，解决那些需要任务重复执⾏的问题。</li>
<li>ThreadPoolExecutor ExecutorService的默认实现。</li>
<li>ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接⼝实现，周期性任务调度的类实现。<ul>
<li>当线程数⼩于corePoolSize时，创建线程执⾏任务。</li>
<li>当线程数⼤于等于corePoolSize并且workQueue没有满时，放⼊workQueue中</li>
<li>线程数⼤于等于corePoolSize并且当workQueue满时，新任务新建线程运⾏，线程总数要⼩于maximumPoolSize</li>
<li>当线程总数等于maximumPoolSize并且workQueue满了的时候执⾏handler的rejectedExecution。也就是拒绝策略</li>
</ul>
</li>
</ul>
<h1 id="常用的几种线程池并讲讲其中的工作原理"><a href="#常用的几种线程池并讲讲其中的工作原理" class="headerlink" title="常用的几种线程池并讲讲其中的工作原理"></a>常用的几种线程池并讲讲其中的工作原理</h1><ul>
<li>线程池核心类：在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是我们线程池核心类</li>
<li>如何提交线程：如可以先随便定义一个固定大小的线程池 ExecutorService es &#x3D; Executors.newFixedThreadPool(3);提交一个线程es.submit(xxRunnble); es.execute(xxRunnble);</li>
<li>submit 和 execute 分别有什么区别呢<ul>
<li>execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多</li>
<li>submit 返回一个 Future 对象，如果想知道线程结果就使用 submit提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常</li>
</ul>
</li>
<li>如何关闭线程池<ul>
<li>es.shutdown(); 不再接受新的任务，之前提交的任务等执行结束再关闭线程池</li>
<li>es.shutdownNow();不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程 list 列表</li>
</ul>
</li>
</ul>
<h1 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier 和 CountDownLatch 的区别"></a>CyclicBarrier 和 CountDownLatch 的区别</h1><ul>
<li>都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上</li>
<li>CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值-1 而已，该线程继续运行</li>
<li>CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务</li>
<li>CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h1 id="什么是活锁、饥饿、无锁、死锁"><a href="#什么是活锁、饥饿、无锁、死锁" class="headerlink" title="什么是活锁、饥饿、无锁、死锁"></a>什么是活锁、饥饿、无锁、死锁</h1><ul>
<li>死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现了这三种情况，即线程不再活跃，不能再正常地执行下去了</li>
<li>死锁：死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁</li>
<li>活锁：活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。 </li>
<li>饥饿：我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源</li>
<li>无锁：无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功，可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合 下是非常高效的。</li>
</ul>
<h1 id="什么是原子性、可见性、有序性"><a href="#什么是原子性、可见性、有序性" class="headerlink" title="什么是原子性、可见性、有序性"></a>什么是原子性、可见性、有序性</h1><ul>
<li>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个 变量进行操作</li>
<li>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值</li>
<li>有序性我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序， 只是重排序会影响多线程执行的结果。</li>
</ul>
<h1 id="什么是守护线程？有什么用？"><a href="#什么是守护线程？有什么用？" class="headerlink" title="什么是守护线程？有什么用？"></a>什么是守护线程？有什么用？</h1><ul>
<li>与守护线程相对应的就是用户线程，守护线程就是守护用户线程</li>
<li>当用户线程全部执行完结束之后，守护线程才会跟着结束</li>
<li>也就是守护线程必须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线 程自然会退出</li>
</ul>
<h1 id="一个线程运行时发生异常会怎样"><a href="#一个线程运行时发生异常会怎样" class="headerlink" title="一个线程运行时发生异常会怎样"></a>一个线程运行时发生异常会怎样</h1><ul>
<li>如果异常没有被捕获该线程将会停止执行</li>
<li>Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口</li>
<li>当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理</li>
</ul>
<h1 id="线程-yield-方法有什么用"><a href="#线程-yield-方法有什么用" class="headerlink" title="线程 yield()方法有什么用"></a>线程 yield()方法有什么用</h1><ul>
<li>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行</li>
<li>它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</li>
</ul>
<h1 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h1><ul>
<li>所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的</li>
</ul>
<h1 id="Synchronized-有哪几种用法"><a href="#Synchronized-有哪几种用法" class="headerlink" title="Synchronized 有哪几种用法"></a>Synchronized 有哪几种用法</h1><ul>
<li>锁类、锁方法、锁代码块</li>
</ul>
<h1 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h1><h4 id="Fork-Join-框架是干什么的"><a href="#Fork-Join-框架是干什么的" class="headerlink" title="Fork&#x2F;Join 框架是干什么的"></a>Fork&#x2F;Join 框架是干什么的</h4><ul>
<li>大任务自动分散小任务，并发执行，合并小任务结果</li>
</ul>
<h4 id="Fork-Join-框架使用有哪些要注意的地方？"><a href="#Fork-Join-框架使用有哪些要注意的地方？" class="headerlink" title="Fork&#x2F;Join 框架使用有哪些要注意的地方？"></a>Fork&#x2F;Join 框架使用有哪些要注意的地方？</h4><ul>
<li>如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降； </li>
<li>如果函数的调用栈很深，会导致栈内存溢出；</li>
</ul>
<h1 id="线程数过多会造成什么异常"><a href="#线程数过多会造成什么异常" class="headerlink" title="线程数过多会造成什么异常"></a>线程数过多会造成什么异常</h1><ul>
<li>线程过多会造成栈溢出，也有可能会造成堆异常</li>
</ul>
<h1 id="说说线程安全的和不安全的集合"><a href="#说说线程安全的和不安全的集合" class="headerlink" title="说说线程安全的和不安全的集合"></a>说说线程安全的和不安全的集合</h1><ul>
<li>Java 中平时用的最多的 Map 集合就是 HashMap 了，它是线程不安全的。 看下面两个场景：<ul>
<li>当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线程安全不安全的问题了</li>
<li>当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个 HashMap了，对同个 HashMap 操作这时候就存在线程安全的问题了</li>
</ul>
</li>
</ul>
<h1 id="什么是-CAS-算法？在多线程中有哪些应用"><a href="#什么是-CAS-算法？在多线程中有哪些应用" class="headerlink" title="什么是 CAS 算法？在多线程中有哪些应用"></a>什么是 CAS 算法？在多线程中有哪些应用</h1><ul>
<li>CAS，全称为 Compare and Swap，即比较-替换</li>
<li>假设有三个操作数：内存值 V、 旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false</li>
<li>当然 CAS 一定要 volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功。</li>
<li>java.util.concurrent.atomic 包下面的 Atom*类都有 CAS 算法的应用。</li>
</ul>
<h1 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h1><ul>
<li>java.lang.Thread#holdsLock 方法</li>
</ul>
<h1 id="Jdk-中排查多线程问题用什么命令"><a href="#Jdk-中排查多线程问题用什么命令" class="headerlink" title="Jdk 中排查多线程问题用什么命令"></a>Jdk 中排查多线程问题用什么命令</h1><ul>
<li>jstack</li>
</ul>
<h1 id="线程同步需要注意什么"><a href="#线程同步需要注意什么" class="headerlink" title="线程同步需要注意什么"></a>线程同步需要注意什么</h1><ul>
<li>尽量缩小同步的范围，增加系统吞吐量</li>
<li>分布式同步锁无意义，要使用分布式锁</li>
<li>防止死锁，注意加锁顺序</li>
</ul>
<h1 id="线程-wait-方法使用有什么前提？"><a href="#线程-wait-方法使用有什么前提？" class="headerlink" title="线程 wait()方法使用有什么前提？"></a>线程 wait()方法使用有什么前提？</h1><ul>
<li>要在同步块中使用</li>
</ul>
<h1 id="线程之间如何传递数据？"><a href="#线程之间如何传递数据？" class="headerlink" title="线程之间如何传递数据？"></a>线程之间如何传递数据？</h1><ul>
<li>通过在线程之间共享对象就可以了，</li>
<li>然后通过wait&#x2F;notify&#x2F;notifyAll、await&#x2F;signal&#x2F;signalAll进行唤起和等待，比方说阻塞队列 BlockingQueue就是为线程之间共享数据而设计的</li>
</ul>
<h1 id="保证”可见性”有哪几种方式？"><a href="#保证”可见性”有哪几种方式？" class="headerlink" title="保证”可见性”有哪几种方式？"></a>保证”可见性”有哪几种方式？</h1><ul>
<li>synchronized 和 viotatile</li>
</ul>
<h1 id="说几个常用的-Lock-接口实现锁。"><a href="#说几个常用的-Lock-接口实现锁。" class="headerlink" title="说几个常用的 Lock 接口实现锁。"></a>说几个常用的 Lock 接口实现锁。</h1><ul>
<li>ReentrantLock、ReadWriteLock</li>
</ul>
<h1 id="ThreadLocal-是什么？有什么应用场景？"><a href="#ThreadLocal-是什么？有什么应用场景？" class="headerlink" title="ThreadLocal 是什么？有什么应用场景？"></a>ThreadLocal 是什么？有什么应用场景？</h1><ul>
<li>ThreadLocal 的作用是提供线程内的局部变量</li>
<li>这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。用来解决数据库连接、Session 管理等。</li>
</ul>
<h1 id="ReadWriteLock-有什么用？"><a href="#ReadWriteLock-有什么用？" class="headerlink" title="ReadWriteLock 有什么用？"></a>ReadWriteLock 有什么用？</h1><ul>
<li>ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现</li>
<li>实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能</li>
</ul>
<h1 id="怎么唤醒一个阻塞的线程？"><a href="#怎么唤醒一个阻塞的线程？" class="headerlink" title="怎么唤醒一个阻塞的线程？"></a>怎么唤醒一个阻塞的线程？</h1><ul>
<li>如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它</li>
<li>如果线程遇到了 IO 阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统</li>
</ul>
<h1 id="不可变对象对多线程有什么帮助？"><a href="#不可变对象对多线程有什么帮助？" class="headerlink" title="不可变对象对多线程有什么帮助？"></a>不可变对象对多线程有什么帮助？</h1><ul>
<li>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率</li>
</ul>
<h1 id="多线程上下文切换是什么意思？"><a href="#多线程上下文切换是什么意思？" class="headerlink" title="多线程上下文切换是什么意思？"></a>多线程上下文切换是什么意思？</h1><ul>
<li>多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</li>
</ul>
<h1 id="Java-中用到了什么线程调度算法？"><a href="#Java-中用到了什么线程调度算法？" class="headerlink" title="Java 中用到了什么线程调度算法？"></a>Java 中用到了什么线程调度算法？</h1><ul>
<li>抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</li>
</ul>
<h1 id="Thread-sleep-0-的作用是什么？"><a href="#Thread-sleep-0-的作用是什么？" class="headerlink" title="Thread.sleep(0)的作用是什么？"></a>Thread.sleep(0)的作用是什么？</h1><ul>
<li>由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制 权的一种操作</li>
</ul>
<h1 id="Hashtable-的-size-方法为什么要做同步？"><a href="#Hashtable-的-size-方法为什么要做同步？" class="headerlink" title="Hashtable 的 size()方法为什么要做同步？"></a>Hashtable 的 size()方法为什么要做同步？</h1><ul>
<li>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B则可以正常调用 size()方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对size++，线程 B 就已经读取 size了，那么对于线程 B 来说读取到的size 一定是不准 确的。而给 size()方法加了同步之后，意味着线程 B 调用size()方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性。</li>
</ul>
<h1 id="同步方法和同步块，哪种更好？"><a href="#同步方法和同步块，哪种更好？" class="headerlink" title="同步方法和同步块，哪种更好？"></a>同步方法和同步块，哪种更好？</h1><ul>
<li>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率</li>
<li>请知道一条原则：同步的范围越小越好。</li>
</ul>
<h1 id="Runnable-和-Thread-用哪个好？"><a href="#Runnable-和-Thread-用哪个好？" class="headerlink" title="Runnable 和 Thread 用哪个好？"></a>Runnable 和 Thread 用哪个好？</h1><ul>
<li>Java 不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也为了减少类之间的耦合性，Runnable 会更好</li>
</ul>
<h1 id="Java-中-notify-和-notifyAll-有什么区别？"><a href="#Java-中-notify-和-notifyAll-有什么区别？" class="headerlink" title="Java 中 notify 和 notifyAll 有什么区别？"></a>Java 中 notify 和 notifyAll 有什么区别？</h1><ul>
<li>notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行</li>
</ul>
<h1 id="为什么-wait-notify-notifyAll-这些方法不在-thread-类里面？"><a href="#为什么-wait-notify-notifyAll-这些方法不在-thread-类里面？" class="headerlink" title="为什么 wait&#x2F;notify&#x2F;notifyAll 这些方法不在 thread 类里面？"></a>为什么 wait&#x2F;notify&#x2F;notifyAll 这些方法不在 thread 类里面？</h1><ul>
<li>原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果 wait()方法定 义在 Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait， notify 和 notifyAll都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象</li>
</ul>
<h1 id="为什么-wait-和-notify-方法要在同步块中调用？"><a href="#为什么-wait-和-notify-方法要在同步块中调用？" class="headerlink" title="为什么 wait 和 notify 方法要在同步块中调用？"></a>为什么 wait 和 notify 方法要在同步块中调用？</h1><ul>
<li>为了避免 wait 和 notify 之间产生竞态条件</li>
<li>为Java API强制要求，否则会抛出IllegalMonitorStateException 异常</li>
</ul>
<h1 id="为什么你应该在循环中检查等待条件？"><a href="#为什么你应该在循环中检查等待条件？" class="headerlink" title="为什么你应该在循环中检查等待条件？"></a>为什么你应该在循环中检查等待条件？</h1><ul>
<li>处于等待状态的线程可能会收到错误警报和伪唤醒</li>
<li>如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出</li>
<li>因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因</li>
</ul>
<h1 id="你如何在-Java-中获取线程堆栈？"><a href="#你如何在-Java-中获取线程堆栈？" class="headerlink" title="你如何在 Java 中获取线程堆栈？"></a>你如何在 Java 中获取线程堆栈？</h1><ul>
<li>jstack 这个工具来获取，它对进程 id 进行操作，用 jps 这个工具找到 id。</li>
</ul>
<h1 id="如何创建线程安全的单例模式？"><a href="#如何创建线程安全的单例模式？" class="headerlink" title="如何创建线程安全的单例模式？"></a>如何创建线程安全的单例模式？</h1><ul>
<li>单例模式即一个 JVM 内存中只存在一个类的对象实例分类<ul>
<li>懒汉式 类加载的时候就创建实例</li>
<li>饿汉式 使用的时候才创建实例</li>
</ul>
</li>
</ul>
<h1 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h1><ul>
<li>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接</li>
<li>这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</li>
</ul>
<h1 id="提交任务时线程池队列已满会时发会生什么？"><a href="#提交任务时线程池队列已满会时发会生什么？" class="headerlink" title="提交任务时线程池队列已满会时发会生什么？"></a>提交任务时线程池队列已满会时发会生什么？</h1><ul>
<li>当线程数小于最大线程池数 maximumPoolSize 时就会创建新线程来处理</li>
<li>线程数大于等于最大线程池数 maximumPoolSize 时就会执行拒绝策略</li>
<li>如果你使⽤的LinkedBlockingQueue，也就是⽆界队列的话，没关系，继续添加任务到阻塞队列中等待执⾏，因为LinkedBlockingQueue可以近乎认为是⼀个⽆穷⼤的队列，可以⽆限存放任务；</li>
<li>如果你使⽤的是有界队列⽐⽅说ArrayBlockingQueue的话，任务⾸先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使⽤拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</li>
</ul>
<h1 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h1><ul>
<li>可以用join方法实现</li>
</ul>
<h1 id="在Java中Lock接口比synchronized块的优势是什么？"><a href="#在Java中Lock接口比synchronized块的优势是什么？" class="headerlink" title="在Java中Lock接口比synchronized块的优势是什么？"></a>在Java中Lock接口比synchronized块的优势是什么？</h1><ul>
<li>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁</li>
</ul>
<h1 id="你将如何使用threaddump？你将如何分析Thread-dump？"><a href="#你将如何使用threaddump？你将如何分析Thread-dump？" class="headerlink" title="你将如何使用threaddump？你将如何分析Thread dump？"></a>你将如何使用threaddump？你将如何分析Thread dump？</h1><ul>
<li>在UNIX中你可以使用kill -3，然后thread dump将会打印日志</li>
<li>在windows中你可以使用”CTRL+Break”</li>
</ul>
<h1 id="为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h1><ul>
<li>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码</li>
<li>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码</li>
</ul>
<h1 id="Java中你怎样唤醒一个阻塞的线程？"><a href="#Java中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java中你怎样唤醒一个阻塞的线程？"></a>Java中你怎样唤醒一个阻塞的线程？</h1><ul>
<li>如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程</li>
<li>如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它</li>
</ul>
<h1 id="Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h1><ul>
<li>通常利用Executors提供的通用线程池创建方法，去创建不同配置的线程池,主要区别在于不同的ExecutorService类型或者不同的初始参数</li>
<li>Executors目前提供了5种不同的线程池创建配置<ul>
<li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点:<ul>
<li>它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程</li>
<li>如果线程闲置的时间超过60S，则被终止并移出缓存</li>
<li>长时间闲置时，这种线程池不会消耗资源</li>
</ul>
</li>
<li>newFixedThreadPool(int  nThreads)：重用指定数目的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现，如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads</li>
<li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为1,操作一个无界的工作队列,所以它保证了所有任务的都是被顺序执行,最多会有一个任务处于活动状态,并且不允许使用者改造线程实例,因此可以避免其改变线程数目。</li>
<li>newSingleThreadScheduledExecutor()和newSecheduledThreadPool(int  corePoolSize),创建的是个ScheduledExecutorService,可以进行定时或周期性的工作调度,区别在于单一工作线程还是多个工作线程。</li>
</ul>
</li>
</ul>
<h1 id="⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？"><a href="#⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？" class="headerlink" title="⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？"></a>⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？</h1><ul>
<li>⾼并发、任务执⾏时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下⽂的切换</li>
<li>并发不⾼、任务执⾏时间⻓的业务要区分开看：<ul>
<li>假如是业务时间⻓集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占⽤CPU，所以不要让所有的CPU闲下来，可以加⼤线程池中的线程数⽬，让CPU处理更多的业务</li>
<li>假如是业务时间⻓集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）⼀样吧，线程池中的线程数设置得少⼀些，减少线程上下⽂的切换</li>
</ul>
</li>
<li>并发⾼、业务执⾏时间⻓，解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，看看这些业务⾥⾯某些数据是否能做缓存是第⼀步，增加服务器是第⼆步，⾄于线程池的设置，设置参考（2）。最后，业务执⾏时间⻓的问题，也可能需要分析⼀下，看看能不能使⽤中间件对任务进⾏拆分和解耦。</li>
</ul>
<h1 id="线程安全和线程不安全"><a href="#线程安全和线程不安全" class="headerlink" title="线程安全和线程不安全"></a>线程安全和线程不安全</h1><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul>
<li>线程安全就是多线程访问时，采⽤了加锁机制，当⼀个线程访问该类的某个数据时，进⾏保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使⽤。不会出现数据不⼀致或者数据污染。</li>
<li>线程安全是一个多线程环境下正确性的概念,也就是保证多线程环境下共享的可修改的状态的正确性,这里的状态反映在程序中其实可以看做是数据。</li>
<li>换个角度来看,如果状态不是共享的,或者不是可修改的,也就不存在线程安全问题,进而可以推理出保证线程安全的两个办法<ul>
<li>第一个是封装,我们可以将对象内部状态隐藏保护起来</li>
<li>第二个是不可变。</li>
</ul>
</li>
<li>线程安全需要保证几个基本特性<ul>
<li>原子性：简单来说就是相关操作不会中途被其他线程干扰,一般通过同步机制实现</li>
<li>可见性：是一个线程修改了某个共享变量,其状态能够立即被其他线程知晓,通常被解释为将线程本地状态反映到主内存中,volatile关键字就是负责保证可见性的</li>
<li>有序性：是保证线程内串行语义, 避免指令重排等</li>
</ul>
</li>
</ul>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><ul>
<li>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</li>
<li>线程安全问题都是由全局变量及静态变量引起的</li>
<li>若每个线程中对全局变量、静态变量只有读操作，⽽⽆写操作，⼀般来说，这个全局变量是线程安全的</li>
<li>若有多个线程同时执⾏写操作，⼀般都需要考虑线程同步，否则的话就可能影响线程安全</li>
</ul>
<h1 id="如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全"><a href="#如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全" class="headerlink" title="如何保证集合是线程安全的?	ConcurrentHashMap 如何实现高效的线程安全?"></a>如何保证集合是线程安全的?	ConcurrentHashMap 如何实现高效的线程安全?</h1><ul>
<li>在传统集合框架内部,除了Hashtable  Vector等同步容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个 同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等</li>
<li>Vector 是⽤同步⽅法来实现线程安全的, ⽽和它相似的ArrayList不是线程安全的</li>
</ul>
<h1 id="为什么需要ConcurrentHashMap"><a href="#为什么需要ConcurrentHashMap" class="headerlink" title="为什么需要ConcurrentHashMap?"></a>为什么需要ConcurrentHashMap?</h1><ul>
<li>Hashtable本身比较低效,因为它的实现基本就是put  get  size等各种方法加上”synchronized”</li>
<li>这就导致了所有并发操作都要竞争同一把锁,一个线程在进行同步操作时,其他线程只能等待,大大降低了并发操作的效率</li>
<li>HashMap不是线程安全的,那么能不能利用Collections提供的同步包装器来解决问题</li>
<li>实际上同步器只是利用 输入Map构造了另一个同步版本,所有操作不再声明为synchronized方法,但是还是利用</li>
<li>Hashtable或者同步包装版本,都只是适合在非高度并发的场景下</li>
</ul>
<h1 id="ConcurrentHashMap工作机制"><a href="#ConcurrentHashMap工作机制" class="headerlink" title="ConcurrentHashMap工作机制"></a>ConcurrentHashMap工作机制</h1><ul>
<li>在早期的ConcurrentHashMap,其实现是基于分离锁,也就是将内部进行分段,里面则是HashEntry的数据</li>
<li>和HashMap类似,哈希相同的条目也是以链表形式存放。(简单点来说,就是在ConcurrentHashMap中,把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中)在构造的时候,Segment的数量由所谓的concurrentcyLevel来决定,默认是16,也可以在相应构造函数直接指定。注意,Java需要它是2的幂数值,如果输入是类似15这种非幂值,会自动调整到16之类2的幂数值。</li>
<li>ConcurrentHashMap的工作机制就是通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li>
</ul>
<h1 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h1><ul>
<li>CAS（compare and swap）的缩写，中⽂翻译成⽐较并交换。</li>
<li>CAS 不通过JVM,直接利⽤java本地⽅ JNI（Java Native Interface为JAVA本地调⽤）,直接调⽤CPU 的cmpxchg（是汇编指令）指令</li>
<li>利⽤CPU的CAS指令，同时借助JNI来完成Java的⾮阻塞算法,实现原⼦操作。其它原⼦操作都是利⽤类似的特性完成的。</li>
<li>整个java.util.concurrent都是建⽴在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很⼤的提升。</li>
<li>CAS是项乐观锁技术，当多个线程尝试使⽤CAS同时更新同⼀个变量时，只有其中⼀个线程能更新变量的值，⽽其它线程都失败，失败的线程并不会被挂起，⽽是被告知这次竞争中失败，并可以再次尝试</li>
<li>使⽤CAS在线程冲突严重时，会⼤幅降低程序性能；CAS只适合于线程冲突较少的情况使⽤。</li>
<li>synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是⾃旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了⾼吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；⽽线程冲突严重的情况下，性能远⾼于CAS</li>
</ul>
<h1 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h1><ul>
<li>AbstractQueuedSynchronizer简称AQS，是⼀个⽤于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等</li>
<li>AQS解决了在实现同步容器时设计的⼤量细节问题。</li>
<li>AQS使⽤⼀个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护⼀个等待状态waitStatus。</li>
</ul>
<h1 id="什么是原⼦操作？在Java-Concurrency-API中有哪些原⼦类-atomic-classes-？"><a href="#什么是原⼦操作？在Java-Concurrency-API中有哪些原⼦类-atomic-classes-？" class="headerlink" title="什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？"></a>什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？</h1><ul>
<li>原⼦操作是指⼀个不受其他操作影响的操作任务单元</li>
<li>原⼦操作是在多线程环境下避免数据不⼀致必须的⼿段。</li>
<li>int++并不是⼀个原⼦操作，所以当⼀个线程读取它的值并加1时，另外⼀个线程有可能会读到之前的值，这就会引发错误。</li>
<li>为了解决这个问题，必须保证增加操作是原⼦的，在JDK1.5之前我们可以使⽤同步技术来做到这⼀点到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以⾃动的保证对于他们的操作是原⼦的并且不需要使⽤同步</li>
</ul>
<h1 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h1><ul>
<li>阻塞队列是⼀个在队列基础上⼜⽀持了两个附加操作的队列。<ul>
<li>⽀持阻塞的插⼊⽅法：队列满时，队列会阻塞插⼊元素的线程，直到队列不满。</li>
<li>⽀持阻塞的移除⽅法：队列空时，获取元素的线程会等待队列变为⾮空。</li>
</ul>
</li>
<li>JDK7提供了7个阻塞队列<ul>
<li>ArrayBlockingQueue ：⼀个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：⼀个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：⼀个⽀持优先级排序的⽆界阻塞队列。</li>
<li>DelayQueue：⼀个使⽤优先级队列实现的⽆界阻塞队列。</li>
<li>SynchronousQueue：⼀个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：⼀个由链表结构组成的⽆界阻塞队列。</li>
<li>LinkedBlockingDeque：⼀个由链表结构组成的双向阻塞队列。</li>
</ul>
</li>
</ul>
<h1 id="什么是同步容器和并发容器的实现？"><a href="#什么是同步容器和并发容器的实现？" class="headerlink" title="什么是同步容器和并发容器的实现？"></a>什么是同步容器和并发容器的实现？</h1><h4 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h4><ul>
<li>主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。</li>
<li>锁的粒度为当前对象整体。</li>
<li>迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。</li>
</ul>
<h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><ul>
<li>主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。</li>
<li>锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。</li>
<li>迭代器具有弱⼀致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</li>
<li>ConcurrentHashMap采⽤分段锁技术，同步容器中，是⼀个容器⼀个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若⼲段，每段维护⼀个锁，以达到⾼效的并发访问；</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h4 id="ThreadLocal的设计理念与作⽤？"><a href="#ThreadLocal的设计理念与作⽤？" class="headerlink" title="ThreadLocal的设计理念与作⽤？"></a>ThreadLocal的设计理念与作⽤？</h4><ul>
<li>Java中的ThreadLocal类允许我们创建只能被同⼀个线程读写的变量</li>
<li>如果⼀段代码含有⼀个ThreadLocal变量的引⽤，即使两个线程同时执⾏这段代码，它们也⽆法访问到对⽅的ThreadLocal变量</li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>线程局部变量</li>
<li>变量是同⼀个，但是每个线程都使⽤同⼀个初始值，也就是使⽤同⼀个变量的⼀个新的副本。这种情况之下ThreadLocal就⾮常适⽤，⽐如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是⼀个线程安全的变量。⽽我们每个线程都需要使⽤他，并且各⾃使⽤各⾃的。这种情况，ThreadLocal就⽐较好的解决了这个问题。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>从本质来讲，就是每个线程都维护了⼀个map，⽽这个map的key就是threadLocal，⽽值就是我们set的那个值</li>
<li>每次线程在get的时候，都从⾃⼰的变量中取值，既然从⾃⼰的变量中取值，那肯定就不存在线程安全问题</li>
<li>ThreadLocal这个变量的状态根本没有发⽣变化，他仅仅是充当⼀个key的⻆⾊，另外提供给每⼀个线程⼀个初始值。</li>
</ul>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>每个Thread对象内部都维护了⼀个ThreadLocalMap这样⼀个ThreadLocal的Map，可以存放若⼲个ThreadLocal。</li>
</ul>
<h4 id="应⽤场景"><a href="#应⽤场景" class="headerlink" title="应⽤场景"></a>应⽤场景</h4><ul>
<li>当很多线程需要多次使⽤同⼀个对象，并且需要该对象具有相同初始化值的时候最适合使⽤ThreadLocal。</li>
</ul>
<h1 id="Semaphore有什么作⽤？"><a href="#Semaphore有什么作⽤？" class="headerlink" title="Semaphore有什么作⽤？"></a>Semaphore有什么作⽤？</h1><ul>
<li>Semaphore就是⼀个信号量</li>
<li>作⽤是限制某段代码块的并发数</li>
</ul>
<h1 id="Hashtable的size-⽅法中明明只有⼀条语句”return-count”，为什么还要做同步？"><a href="#Hashtable的size-⽅法中明明只有⼀条语句”return-count”，为什么还要做同步？" class="headerlink" title="Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？"></a>Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？</h1><ul>
<li>同⼀时间只能有⼀条线程执⾏固定类的同步⽅法，但是对于类的⾮同步⽅法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执⾏Hashtable的put⽅法添加数据，线程B则可以正常调⽤size()⽅法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size⼀定是不准确的。</li>
<li>⽽给size()⽅法加了同步之后，意味着线程B调⽤size()⽅法只有在线程A调⽤put⽅法完毕之后才可以调⽤，这样就保证了线程安全性。</li>
</ul>
<h1 id="ConcurrentHashMap的并发度是什么？"><a href="#ConcurrentHashMap的并发度是什么？" class="headerlink" title="ConcurrentHashMap的并发度是什么？"></a>ConcurrentHashMap的并发度是什么？</h1><ul>
<li>⼯作机制（分⽚思想）：它引⼊了⼀个“分段锁”的概念，具体可以理解为把⼀个⼤的Map拆分成N个⼩的segment，根据key.hashCode()来决定把key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li>
<li>应⽤：当读&gt;写时使⽤，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；</li>
<li>hash冲突：<ul>
<li>简介：HashMap中调⽤hashCode()⽅法来计算hashCode。由于在Java中两个不同的对象可能有⼀样的hashCode,所以不同的键可能有⼀样hashCode，从⽽导致冲突的产⽣。</li>
<li>hash冲突解决：使⽤平衡树来代替链表，当同⼀hash中的元素数量超过特定的值便会由链表切换到平衡树</li>
</ul>
</li>
<li>⽆锁读：ConcurrentHashMap之所以有较好的并发性是因为ConcurrentHashMap是⽆锁读和加锁写，并且利⽤了分段锁（不是在所有的entry上加锁，⽽是在⼀部分entry上加锁）；读之前会先判断count(jdk1.6)，其中的count是被volatile修饰的(当变量被volatile修饰后，每次更改该变量的时候会将更改结果写到系统主内存中，利⽤多处理器的缓存⼀致性，其他处理器会发现⾃⼰的缓存⾏对应的内存地址被修改，就会将⾃⼰处理器的缓存⾏设置为失效，并强制从系统主内存获取最新的数据。)，故可以实现⽆锁读。</li>
<li>ConcurrentHashMap的并发度就是segment的⼤⼩，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最⼤优势。</li>
</ul>
<h1 id="ReentrantReadWriteLock读写锁的使⽤"><a href="#ReentrantReadWriteLock读写锁的使⽤" class="headerlink" title="ReentrantReadWriteLock读写锁的使⽤"></a>ReentrantReadWriteLock读写锁的使⽤</h1><ul>
<li>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm⾃⼰控制的，你只要上好相应的锁即可</li>
<li>如果你的代码只读数据，可以很多⼈同时读，但不能同时写，那就上读锁</li>
<li>如果你的代码修改数据，只能有⼀个⼈在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁</li>
</ul>
<h1 id="锁的等级：⽅法锁、对象锁、类锁"><a href="#锁的等级：⽅法锁、对象锁、类锁" class="headerlink" title="锁的等级：⽅法锁、对象锁、类锁?"></a>锁的等级：⽅法锁、对象锁、类锁?</h1><h4 id="⽅法锁（synchronized修饰⽅法时）"><a href="#⽅法锁（synchronized修饰⽅法时）" class="headerlink" title="⽅法锁（synchronized修饰⽅法时）"></a>⽅法锁（synchronized修饰⽅法时）</h4><pre><code>- 通过在⽅法声明中加⼊ synchronized关键字来声明 synchronized ⽅法。
- synchronized ⽅法控制对类成员变量的访问：
- 每个类实例对应⼀把锁，每个 synchronized ⽅法都必须获得调⽤该⽅法的类实例的锁⽅能执⾏，否则所属线程阻塞，⽅法⼀旦执⾏，就独占该锁，直到从该⽅法返回时才将锁释放，此后被阻塞的线程⽅能获得该锁，重新进⼊可执⾏状态
- 这种机制确保了同⼀时刻对于每⼀个类实例，其所有声明为 synchronized 的成员函数中⾄多只有⼀个处于可执⾏状态，从⽽有效避免了类成员变量的访问冲突。
</code></pre>
<h4 id="对象锁（synchronized修饰⽅法或代码块）"><a href="#对象锁（synchronized修饰⽅法或代码块）" class="headerlink" title="对象锁（synchronized修饰⽅法或代码块）"></a>对象锁（synchronized修饰⽅法或代码块）</h4><ul>
<li>当⼀个对象中有synchronized method或synchronized block的时候调⽤此对象的同步⽅法或进⼊其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调⽤者占⽤，则需要等待此锁被释放。（⽅法锁也是对象锁）</li>
<li>java的所有对象都含有1个互斥锁，这个锁由JVM⾃动获取和释放</li>
<li>线程进⼊synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待</li>
<li>synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁</li>
<li>这⾥也体现了⽤synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来⾃动释放。</li>
</ul>
<p>　</p>
<h4 id="类锁-synchronized-修饰静态的⽅法或代码块"><a href="#类锁-synchronized-修饰静态的⽅法或代码块" class="headerlink" title="类锁(synchronized 修饰静态的⽅法或代码块)"></a>类锁(synchronized 修饰静态的⽅法或代码块)</h4><ul>
<li>由于⼀个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有⼀份。所以，⼀旦⼀个静态的⽅法被申明为synchronized。此类所有的实例化对象在调⽤此⽅法，共⽤同⼀把锁，我们称之为类锁。</li>
<li>对象锁是⽤来控制实例⽅法之间的同步，类锁是⽤来控制静态⽅法（或静态变量互斥体）之间的同步</li>
</ul>
<h1 id="如果同步块内的线程抛出异常会发⽣什么？"><a href="#如果同步块内的线程抛出异常会发⽣什么？" class="headerlink" title="如果同步块内的线程抛出异常会发⽣什么？"></a>如果同步块内的线程抛出异常会发⽣什么？</h1><ul>
<li>synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁</li>
</ul>
<h1 id="并发编程（concurrency）并⾏编程（parallellism）有什么区别？"><a href="#并发编程（concurrency）并⾏编程（parallellism）有什么区别？" class="headerlink" title="并发编程（concurrency）并⾏编程（parallellism）有什么区别？"></a>并发编程（concurrency）并⾏编程（parallellism）有什么区别？</h1><ul>
<li>并⾏是指两个或者多个事件在同⼀时刻发⽣；⽽并发是指两个或多个事件在同⼀时间间隔发⽣。</li>
<li>并⾏是在不同实体上的多个事件，并发是在同⼀实体上的多个事件。</li>
<li>在⼀台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群所以并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能。</li>
</ul>
<h1 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h1><ul>
<li>volatile只能保证你数据的可⻅性，获取到的是最新的数据，不能保证原⼦性；</li>
<li>⽤AtomicInteger保证原⼦性。</li>
<li>synchronized既能保证共享变量可⻅性，也可以保证锁内操作的原⼦性。</li>
</ul>
<h1 id="⼀个线程如果出现了运⾏时异常会怎么样"><a href="#⼀个线程如果出现了运⾏时异常会怎么样" class="headerlink" title="⼀个线程如果出现了运⾏时异常会怎么样?"></a>⼀个线程如果出现了运⾏时异常会怎么样?</h1><ul>
<li>如果这个异常没有被捕获的话，这个线程就停⽌执⾏了。</li>
<li>另外重要的⼀点是：如果这个线程持有某个对象的监视器，那么这个对象监视器会被⽴即释放.</li>
</ul>
<h1 id="如何在两个线程之间共享数据"><a href="#如何在两个线程之间共享数据" class="headerlink" title="如何在两个线程之间共享数据?"></a>如何在两个线程之间共享数据?</h1><ul>
<li>通过在线程之间共享对象就可以了，然后通过wait&#x2F;notify&#x2F;notifyAll、await&#x2F;signal&#x2F;signalAll进⾏唤起和等待</li>
<li>⽐⽅说阻塞队列BlockingQueue就是为线程之间共享数据⽽设计的。</li>
</ul>
<h1 id="⽣产者消费者模型的作⽤是什么"><a href="#⽣产者消费者模型的作⽤是什么" class="headerlink" title="⽣产者消费者模型的作⽤是什么?"></a>⽣产者消费者模型的作⽤是什么?</h1><ul>
<li>通过平衡⽣产者的⽣产能⼒和消费者的消费能⼒来提升整个系统的运⾏效率，这是⽣产者消费者模型最重要的作⽤</li>
<li>解耦，这是⽣产者消费者模型附带的作⽤，解耦意味着⽣产者和消费者之间的联系少，联系越少越可以独⾃发展⽽不需要受到相互的制约。</li>
</ul>
<h1 id="怎么唤醒⼀个阻塞的线程"><a href="#怎么唤醒⼀个阻塞的线程" class="headerlink" title="怎么唤醒⼀个阻塞的线程?"></a>怎么唤醒⼀个阻塞的线程?</h1><ul>
<li>如果线程是因为调⽤了wait()、sleep()或者join()⽅法⽽导致的阻塞</li>
<li>suspend与resume，Java废弃suspend() 去挂起线程的原因，是因为suspend() 在导致线程暂停的同时，并不会释放任何锁资源。其他线程都⽆法访问被它占⽤的锁。直到对应的线程执⾏resume() ⽅法后，被挂起的线程才能继从⽽其它被阻塞在这个锁的线程才可以继续执⾏。但是，如果resume()操作出现在 suspend(之前执⾏，那么线程将⼀直处于挂起状态，同时⼀直占⽤锁，这就产⽣了死锁。⽽且，对于被挂起的线程，它的线程状态居然还是 Runnable。</li>
<li>wait与notify，wait与notify必须配合synchronized使⽤，因为调⽤之前必须持有锁，wait会⽴即释放锁，notify则是同步块执⾏完了才释放</li>
<li>await与singal，Condition类提供，⽽Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使⽤Lock锁后⽆法使⽤wait⽅法</li>
<li>park与unpark，LockSupport是⼀个⾮常⽅便实⽤的线程阻塞⼯具，它可以在线程任意位置让线程阻塞。和Thread.suspenf()相⽐，它弥补了由于resume()在前发⽣，导致线程⽆法继续执⾏的情况。和Object.wait()相⽐，它不需要先获得某个对象的锁，也不会抛出IException异常。可以唤醒指定线程。</li>
<li>如果线程遇到了IO阻塞，⽆能为⼒，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</li>
</ul>
<h1 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性?"></a>单例模式的线程安全性?</h1><ul>
<li>⾸先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建⼀次出来</li>
<li>单例模式有很多种的写法，我总结⼀下：<ul>
<li>饿汉式单例模式的写法：线程安全</li>
<li>懒汉式单例模式的写法：⾮线程安全</li>
<li>双检锁单例模式的写法：线程安全</li>
</ul>
</li>
</ul>
<h1 id="线程类的构造⽅法、静态块是被哪个线程调⽤的"><a href="#线程类的构造⽅法、静态块是被哪个线程调⽤的" class="headerlink" title="线程类的构造⽅法、静态块是被哪个线程调⽤的?"></a>线程类的构造⽅法、静态块是被哪个线程调⽤的?</h1><ul>
<li>线程类的构造⽅法、静态块是被new这个线程类所在的线程所调⽤的，⽽run⽅法⾥⾯的代码才是被线程⾃身所调⽤的。</li>
</ul>
<h1 id="同步⽅法和同步块，哪个是更好的选择"><a href="#同步⽅法和同步块，哪个是更好的选择" class="headerlink" title="同步⽅法和同步块，哪个是更好的选择?"></a>同步⽅法和同步块，哪个是更好的选择?</h1><ul>
<li>同步块是更好的选择，因为它不会锁住整个对象（当然也可以让它锁住整个对象）</li>
<li>同步⽅法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停⽌执⾏并需要等待获得这个对象上的锁。</li>
<li>synchronized(this)以及⾮static的synchronized⽅法（⾄于static synchronized⽅法请往下看），只能防⽌多个线程同时执⾏同⼀个对象的同步代码段。</li>
<li>如果要锁住多个对象⽅法，可以锁住⼀个固定的对象，或者锁住这个类的Class对象。</li>
<li>synchronized锁住的是括号⾥的对象，⽽不是代码</li>
<li>对于⾮static的synchronized⽅法，锁的就是对象本身也就是this。</li>
</ul>
<h1 id="如何检测死锁？怎么预防死锁？"><a href="#如何检测死锁？怎么预防死锁？" class="headerlink" title="如何检测死锁？怎么预防死锁？"></a>如何检测死锁？怎么预防死锁？</h1><ul>
<li>死锁是指两个或两个以上的进程在执⾏过程中，因争夺资源⽽造成的⼀种互相等待的现象，若⽆外⼒作⽤，它们都将⽆法推进下去。此时称系统处于死锁；</li>
</ul>
<h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><ul>
<li>互斥条件：进程对所分配到的资源不允许其他进程进⾏访问，若其他进程访问该资源，只能等待，直⾄占有该资源的进程使⽤完成后释放该资源</li>
<li>请求和保持条件：进程获得⼀定的资源之后，⼜对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但⼜对⾃⼰获得的资源保持不放</li>
<li>不可剥夺条件：是指进程已获得的资源，在未完成使⽤之前，不可被剥夺，只能在使⽤完后⾃⼰释放</li>
<li>环路等待条件：是指进程发⽣死锁后，若⼲进程之间形成⼀种头尾相接的循环等待资源关系</li>
</ul>
<h4 id="死锁产⽣的原因"><a href="#死锁产⽣的原因" class="headerlink" title="死锁产⽣的原因"></a>死锁产⽣的原因</h4><ul>
<li>因竞争资源发⽣死锁 现象：系统中供多个进程共享的资源的数⽬不⾜以满⾜全部进程的需要时，就会引起对诸资源的竞争⽽发⽣死锁现象</li>
<li>进程推进顺序不当发⽣死锁</li>
</ul>
<h4 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h4><ul>
<li>有两个容器，⼀个⽤于保存线程正在请求的锁，⼀个⽤于保存线程已经持有的锁</li>
<li>每次加锁之前都会做如下检测:<ul>
<li>检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来</li>
<li>遍历第⼀步中返回的线程，检查⾃⼰持有的锁是否正被其中任何⼀个线程请求，如果第⼆步返回真,表示出现了死锁</li>
</ul>
</li>
</ul>
<h4 id="死锁的解除与预防"><a href="#死锁的解除与预防" class="headerlink" title="死锁的解除与预防"></a>死锁的解除与预防</h4><ul>
<li>控制不要让四个必要条件成⽴。</li>
</ul>
<h1 id="HashMap在多线程环境下使⽤需要注意什么？"><a href="#HashMap在多线程环境下使⽤需要注意什么？" class="headerlink" title="HashMap在多线程环境下使⽤需要注意什么？"></a>HashMap在多线程环境下使⽤需要注意什么？</h1><ul>
<li>要注意死循环的问题，HashMap的put操作引发扩容，这个动作在多线程并发下会发⽣线程死循环的问题</li>
<li>多个线程同时扩容，造成数据丢失；</li>
<li>多线程扩容时导致Node链表形成环形结构造成.next()死循环，导致CPU利⽤率接近100%；</li>
</ul>
<h1 id="如何实现线程串⾏执⾏？"><a href="#如何实现线程串⾏执⾏？" class="headerlink" title="如何实现线程串⾏执⾏？"></a>如何实现线程串⾏执⾏？</h1><ul>
<li>为了控制线程执⾏的顺序，如ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执⾏三个线程，我们需要确定唤醒、等待的顺序</li>
<li>这时我们可以同时使⽤ Obj.wait()、Obj.notify()与synchronized(Obj)来实现这个⽬标。</li>
<li>线程中持有上⼀个线程类的对象锁以及⾃⼰的锁，由于这种依赖关系，该线程执⾏需要等待上个对象释放锁，从⽽保证类线程执⾏的顺序。</li>
<li>通常情况下，wait是线程在获取对象锁后，主动释放对象锁，同时本线程休眠，直到有其它线程调⽤对象的notify()唤醒该线程，才能继续获取对象锁，并继续执⾏</li>
<li>⽽notify()则是对等待对象锁的线程的唤醒操作</li>
<li>但值得注意的是notify()调⽤后，并不是⻢上就释放对象锁，⽽是在相应的synchronized(){}语句块执⾏结束</li>
<li>释放对象锁后，JVM会在执⾏wait()等待对象锁的线程中随机选取⼀线程，赋予其对象锁，唤醒线程，继续执⾏。</li>
</ul>
<h1 id="可以运⾏时kill掉⼀个线程吗？"><a href="#可以运⾏时kill掉⼀个线程吗？" class="headerlink" title="可以运⾏时kill掉⼀个线程吗？"></a>可以运⾏时kill掉⼀个线程吗？</h1><ul>
<li>不可以</li>
<li>只有当线程run⽅法或者主线程main⽅法结束，⼜或者抛出异常时，线程才会结束⽣命周期。</li>
</ul>
<h1 id="关于synchronized"><a href="#关于synchronized" class="headerlink" title="关于synchronized"></a>关于synchronized</h1><ul>
<li>在某个对象的所有synchronized⽅法中,在某个时刻只能有⼀个唯⼀的⼀个线程去访问这些synchronized⽅法</li>
<li>如果⼀个⽅法是synchronized⽅法,那么该synchronized关键字表示给当前对象上锁(即this)相当于synchronized(this){}</li>
<li>如果⼀个synchronized⽅法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管⽣成多少对象,其对应的class对象只有⼀个)</li>
</ul>
<h1 id="数据库死锁机制和解决⽅案"><a href="#数据库死锁机制和解决⽅案" class="headerlink" title="数据库死锁机制和解决⽅案"></a>数据库死锁机制和解决⽅案</h1><ul>
<li>死锁：死锁是指两个或者两个以上的事务在执⾏过程中，因争夺锁资源⽽造成的⼀种互相等待的现象。</li>
<li>处理机制：解决死锁最有⽤最简单的⽅法是不要有等待，将任何等待都转化为回滚，并且事务重新开始，但是有可能影响并发性能。<ul>
<li>超时回滚，innodb_lock_wait_time设置超时时间；</li>
<li>wait-for-graph⽅法：跟超时回滚⽐起来，这是⼀种更加主动的死锁检测⽅式。InnoDB引擎也采⽤这种⽅式。</li>
</ul>
</li>
</ul>
<h1 id="spring单例为什么没有安全问题-ThreadLocal"><a href="#spring单例为什么没有安全问题-ThreadLocal" class="headerlink" title="spring单例为什么没有安全问题(ThreadLocal)"></a>spring单例为什么没有安全问题(ThreadLocal)</h1><ul>
<li>ThreadLocal：spring使⽤ThreadLocal解决线程安全问题</li>
<li>ThreadLocal会为每⼀个线程提供⼀个独⽴的变量副本，从⽽隔离了多个线程对数据的访问冲突</li>
<li>单例：⽆状态的Bean(⽆状态就是⼀次操作，不能保存数据。⽆状态对象(Stateless Bean)，就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。)适合⽤不变模式，技术就是单例模式，这样可以共享实例，提⾼性能。</li>
</ul>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><ul>
<li>使⽤场景：使⽤线程池，以提⾼服务器性能；</li>
<li>组成：<ul>
<li>线程池管理器（ThreadPool）：⽤于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li>
<li>⼯作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执⾏任务；</li>
<li>任务接⼝（Task）：每个任务必须实现的接⼝，以供⼯作线程调度任务的执⾏，它主要规定了任务的⼊⼝，任务执⾏完后的收尾⼯作，任务的执⾏状态等；</li>
<li>任务队列（taskQueue）：⽤于存放没有处理的任务。提供⼀种缓冲机制。</li>
</ul>
</li>
<li>原理：线程池技术正是关注如何缩短或调整T1,T3时间的技术，从⽽提⾼服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者⼀些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</li>
<li>⼯作流程：<ul>
<li>线程池刚创建时，⾥⾯没有⼀个线程(也可以设置参数prestartAllCoreThreads启动预期数量主线程)</li>
<li>任务队列是作为参数传进来的</li>
<li>不过，就算队列⾥⾯有任务，线程池也不会⻢上执⾏它们。</li>
<li>当调⽤ execute() ⽅法添加⼀个任务时，线程池会做如下判断：<ul>
<li>如果正在运⾏的线程数量⼩于 corePoolSize，那么⻢上创建线程运⾏这个任务；</li>
<li>如果正在运⾏的线程数量⼤于或等于 corePoolSize，那么将这个任务放⼊队列；</li>
<li>如果这时候队列满了，⽽且正在运⾏的线程数量⼩于 maximumPoolSize，那么还是要创建⾮核⼼线程⽴刻运⾏这个任务；</li>
<li>如果队列满了，⽽且正在运⾏的线程数量⼤于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>
</ul>
</li>
<li>当⼀个线程完成任务时，它会从队列中取下⼀个任务来执⾏。</li>
<li>当⼀个线程⽆事可做，超过⼀定的时间（keepAliveTime）时，线程池会判断，如果当前运⾏的线程数⼤于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的⼤⼩。</li>
</ul>
</li>
</ul>
<h1 id="java线程如何启动"><a href="#java线程如何启动" class="headerlink" title="java线程如何启动"></a>java线程如何启动</h1><ul>
<li>继承Thread类；</li>
<li>实现Runnable接⼝</li>
<li>在函数体使⽤</li>
<li>⽐较：<ul>
<li>实现Runnable接⼝优势：<ul>
<li>适合多个相同的程序代码的线程去处理同⼀个资源</li>
<li>可以避免java中的单继承的限制</li>
<li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独⽴。</li>
</ul>
</li>
<li>继承Thread类优势：<ul>
<li>可以将线程类抽象出来，当需要使⽤抽象⼯⼚模式设计时。</li>
<li>多线程同步</li>
</ul>
</li>
<li>在函数体使⽤优势<ul>
<li>⽆需继承thread或者实现Runnable，缩⼩作⽤域。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="java中加锁的⽅式有哪些-如何实现怎么个写法"><a href="#java中加锁的⽅式有哪些-如何实现怎么个写法" class="headerlink" title="java中加锁的⽅式有哪些,如何实现怎么个写法"></a>java中加锁的⽅式有哪些,如何实现怎么个写法</h1><ul>
<li>java中有两种锁<ul>
<li>⼀种是⽅法锁或者对象锁(在⾮静态⽅法或者代码块上加锁)</li>
<li>第⼆种是类锁(在静态⽅法或者class上加锁)；</li>
</ul>
</li>
<li>注意<ul>
<li>其他线程可以访问未加锁的⽅法和代码</li>
<li>synchronized同时修饰静态⽅法和实例⽅法，但是运⾏结果是交替进⾏的，这证明了类锁和对象锁是两个不⼀样的锁，控制着不同的区域，它们是互不⼲扰的。</li>
</ul>
</li>
</ul>
<h1 id="如何保证数据不丢失："><a href="#如何保证数据不丢失：" class="headerlink" title="如何保证数据不丢失："></a>如何保证数据不丢失：</h1><ul>
<li>使⽤消息队列，消息持久化；</li>
<li>添加标志位：未处理 0，处理中 1，已处理 2。定时处理。</li>
</ul>
<h1 id="ThreadLocal为什么会发⽣内存泄漏？"><a href="#ThreadLocal为什么会发⽣内存泄漏？" class="headerlink" title="ThreadLocal为什么会发⽣内存泄漏？"></a>ThreadLocal为什么会发⽣内存泄漏？</h1><ul>
<li>ThreadLocal的实现是这样的：每个Thread 维护⼀个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。</li>
<li>也就是说 ThreadLocal 本身并不存储值，它只是作为⼀个 key 来让线程从 ThreadLocalMap 获取 value</li>
<li>ThreadLocalMap使⽤ThreadLocal的弱引⽤作为key，如果⼀个ThreadLocal没有外部强引⽤来引⽤它，那么系统 GC的时候，这个ThreadLocal势必会被回收，这样⼀来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会⼀直存在⼀条强引⽤链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远⽆法回收，造成内存泄漏。</li>
<li>预防办法：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap⾥所有key为null的value。</li>
<li>但是这些被动的预防措施并不能保证不会内存泄漏：<ul>
<li>使⽤static的ThreadLocal，延⻓了ThreadLocal的⽣命周期，可能导致内存泄漏。</li>
<li>分配使⽤了ThreadLocal⼜不再调⽤get(),set(),remove()⽅法，那么就会导致内存泄漏，因为这块内存⼀直存在。</li>
</ul>
</li>
</ul>
<h1 id="jdk8中对ConcurrentHashmap的改进"><a href="#jdk8中对ConcurrentHashmap的改进" class="headerlink" title="jdk8中对ConcurrentHashmap的改进"></a>jdk8中对ConcurrentHashmap的改进</h1><ul>
<li>Java 7为实现并⾏访问，引⼊了Segment这⼀结构，实现了分段锁，理论上最⼤并发度与Segment个数相等。</li>
<li>Java 8为进⼀步提⾼并发性，摒弃了分段锁的⽅案，⽽是直接使⽤⼀个⼤的数组。同时为了提⾼哈希碰撞下的寻址性能</li>
<li>Java 8在链表⻓度超过⼀定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红⿊树（寻址时间复杂度为O(long(N))）。</li>
</ul>
<h1 id="concurrent包下有哪些类？"><a href="#concurrent包下有哪些类？" class="headerlink" title="concurrent包下有哪些类？"></a>concurrent包下有哪些类？</h1><ul>
<li>ConcurrentHashMap、Future、FutureTask、AtomicInteger…</li>
</ul>
<h1 id="线程a-b-c-d运⾏任务，怎么保证当a-b-c线程执⾏完再执⾏d线程"><a href="#线程a-b-c-d运⾏任务，怎么保证当a-b-c线程执⾏完再执⾏d线程" class="headerlink" title="线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?"></a>线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?</h1><ul>
<li>CountDownLatch类<ul>
<li>⼀个同步辅助类，常⽤于某个条件发⽣后才能执⾏后续进程。给定计数初始化CountDownLatch，调⽤countDown(）⽅法，在计数到达零之前，await⽅法⼀直受阻塞。</li>
<li>重要⽅法为countdown()与await()；</li>
</ul>
</li>
<li>join⽅法<ul>
<li>将线程B加⼊到线程A的尾部，当A执⾏完后B才执⾏。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Thread t = new Thread(&quot;t1&quot;);</span><br><span class="line">    Thread t2 = new Thread(&quot;t2&quot;);</span><br><span class="line">    t.start();</span><br><span class="line">    t.join();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>notify、wait⽅法，Java中的唤醒与等待⽅法<ul>
<li>关键为synchronized代码块，参数线程间应相同，也常⽤Object作为参数。</li>
</ul>
</li>
</ul>
<h1 id="⾼并发系统如何做性能优化？如何防⽌库存超卖？"><a href="#⾼并发系统如何做性能优化？如何防⽌库存超卖？" class="headerlink" title="⾼并发系统如何做性能优化？如何防⽌库存超卖？"></a>⾼并发系统如何做性能优化？如何防⽌库存超卖？</h1><h4 id="⾼并发系统性能优化"><a href="#⾼并发系统性能优化" class="headerlink" title="⾼并发系统性能优化"></a>⾼并发系统性能优化</h4><ul>
<li>优化程序，优化服务配置，优化系统配置</li>
<li>尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。</li>
<li>⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。</li>
<li>优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。</li>
<li>优化数据库结构，多做索引，提⾼查询效率。</li>
<li>统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。</li>
<li>能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。</li>
<li>解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。</li>
</ul>
<h4 id="防⽌库存超卖"><a href="#防⽌库存超卖" class="headerlink" title="防⽌库存超卖"></a>防⽌库存超卖</h4><ul>
<li>悲观锁：在更新库存期间加锁，不允许其它线程修改；<ul>
<li>数据库锁：select xxx for update；</li>
<li>分布式锁；</li>
</ul>
</li>
<li>乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。</li>
<li>redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。</li>
<li>消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。</li>
<li>总结：总的来说，不能把压⼒放在数据库上，所以使⽤ “select xxx for update” 的⽅式在⾼并发的场景下是不可⾏的</li>
<li>FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤</li>
<li>所以相对来说，我会倾向于选择：乐观锁 &#x2F; 缓存锁 &#x2F; 分布式锁的⽅式。</li>
</ul>
<h1 id="线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？"><a href="#线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？" class="headerlink" title="线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？"></a>线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？</h1><ul>
<li>⼯⼚⽅法作⽤：ThreadPoolExecutor类就是Executor的实现类，但ThreadPoolExecutor在使⽤上并不是那么⽅便，在实例化时需要传⼊很多歌参数，还要考虑线程的并发数等与线程池运⾏效率有关的参数，所以官⽅建议使⽤Executors工厂类来创建线程池对象。</li>
</ul>
<h1 id="线程间的通信方式-1"><a href="#线程间的通信方式-1" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><ul>
<li>共享内存机制和消息通信机制</li>
</ul>
<h4 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h4><ul>
<li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。</li>
<li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。</li>
<li>这种方式，本质上就是“共享内存”式的通信</li>
<li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</li>
</ul>
<p> </p>
<h4 id="while轮询的方式-1"><a href="#while轮询的方式-1" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul>
<li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()&#x3D;&#x3D;5)是否成立 ，从而实现了线程间的通信</li>
<li>但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立</li>
<li>这种方式还存在另外一个问题：轮询的条件的可见性问题，关于内存可见性问题</li>
<li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li>
</ul>
<p> </p>
<h4 id="wait-notify机制-1"><a href="#wait-notify机制-1" class="headerlink" title="wait&#x2F;notify机制"></a>wait&#x2F;notify机制</h4><ul>
<li>线程A要等待某个条件满足时(list.size()&#x3D;&#x3D;5)，才执行操作</li>
<li>线程B则向list中添加元素，改变list 的size。</li>
<li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？</li>
<li>这里用到了Object类的 wait() 和 notify() 方法。</li>
<li>当条件未满足时(list.size() !&#x3D;5)，线程A调用wait() 放弃CPU，并进入阻塞状态。不像②while轮询那样占用CPU</li>
<li>当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。</li>
<li>这种方式的一个好处就是CPU的利用率提高了。</li>
<li>但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li>
</ul>
<p> </p>
<h4 id="管道通信-1"><a href="#管道通信-1" class="headerlink" title="管道通信"></a>管道通信</h4><ul>
<li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li>
</ul>
<h1 id="线程池的定义和优点"><a href="#线程池的定义和优点" class="headerlink" title="线程池的定义和优点"></a>线程池的定义和优点</h1><ul>
<li>线程池，从字面含义来看，是指管理一组同构工作线程的资源池</li>
<li>线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务</li>
<li>工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。</li>
<li>“在线程池中执行任务“”比“为每个线程分配一个任务”优势更多</li>
<li>通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销</li>
<li>另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性</li>
<li>通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</li>
</ul>
<h4 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h4><ul>
<li>默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） </li>
<li>当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  </li>
<li>当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  </li>
<li>当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。</li>
<li>当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 </li>
<li>如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。</li>
</ul>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><ul>
<li>如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来</li>
<li>在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待</li>
<li>常见的工作队列有以下几种，前三种用的最多。<ul>
<li>ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。</li>
<li>LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界&#x2F;无界队列，先进先出。</li>
<li>SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue才有实际价值.</li>
<li>PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。</li>
<li>DelayedWorkQueue：延迟的工作队列，无界队列。</li>
</ul>
</li>
</ul>
<h4 id="饱和策略（拒绝策略）"><a href="#饱和策略（拒绝策略）" class="headerlink" title="饱和策略（拒绝策略）"></a>饱和策略（拒绝策略）</h4><ul>
<li>当有界队列被填满后，饱和策略开始发挥作用</li>
<li>ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改</li>
<li>如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略</li>
<li>饱和策略有以下四种，一般使用默认的AbortPolicy。<ul>
<li>AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</li>
<li>DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。</li>
<li>DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。</li>
<li>CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。</li>
</ul>
</li>
</ul>
<h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><ul>
<li>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的</li>
<li>在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法</li>
<li>Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。<ul>
<li>DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。</li>
<li>PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。</li>
</ul>
</li>
<li>自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。</li>
</ul>
<h1 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？-1"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？-1" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h1><ul>
<li>可以用join方法实现。</li>
</ul>
<h1 id="在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"><a href="#在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？" class="headerlink" title="在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"></a>在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</h1><ul>
<li>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁</li>
<li>它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞</li>
</ul>
<h1 id="你将如何使用threaddump？你将如何分析Thread-dump？-1"><a href="#你将如何使用threaddump？你将如何分析Thread-dump？-1" class="headerlink" title="你将如何使用threaddump？你将如何分析Thread dump？"></a>你将如何使用threaddump？你将如何分析Thread dump？</h1><ul>
<li>在UNIX中你可以使用kill -3，然后thread dump将会打印日志</li>
<li>在windows中你可以使用”CTRL+Break”</li>
</ul>
<h1 id="violatile-关键字的作用？"><a href="#violatile-关键字的作用？" class="headerlink" title="violatile 关键字的作用？"></a>violatile 关键字的作用？</h1><ul>
<li>多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据</li>
<li>使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言</li>
<li>volatile 的一个重要作用就是和CAS结合，保证了原子性</li>
</ul>
<h1 id="怎么控制同一时间只有-3-个线程运行？"><a href="#怎么控制同一时间只有-3-个线程运行？" class="headerlink" title="怎么控制同一时间只有 3 个线程运行？"></a>怎么控制同一时间只有 3 个线程运行？</h1><p>用 Semaphore。</p>
<h1 id="线程池启动线程-submit-和-execute-方法有什么不同？"><a href="#线程池启动线程-submit-和-execute-方法有什么不同？" class="headerlink" title="线程池启动线程 submit()和 execute()方法有什么不同？"></a>线程池启动线程 submit()和 execute()方法有什么不同？</h1><ul>
<li>execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多。</li>
<li>submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常。</li>
</ul>
<h1 id="什么是原子性、可见性、有序性？"><a href="#什么是原子性、可见性、有序性？" class="headerlink" title="什么是原子性、可见性、有序性？"></a>什么是原子性、可见性、有序性？</h1><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul>
<li>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作</li>
<li>在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量 n++100 次，如果 n 初始值为 0，n 最后的值应该是 100，所以说它们是互不干扰的，这就是传说的中的原子性。但 n++并不是原子性的操作，要使用 AtomicInteger 保证原子性。</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><ul>
<li>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值</li>
<li>在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的值，而在多线程编程中就不一定了</li>
<li>每个线程都有自己的工作内存，线程先把共享变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值</li>
<li>像CPU 的缓存优化、硬件优化、指令重排及对 JVM 编译器的优化，都会出现可见性的问题。</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul>
<li>我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了</li>
<li>为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即<br>后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果</li>
<li>所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果</li>
<li>虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，只是重排序会影响多线程执行的结果。</li>
</ul>
<h1 id="多线程上下文切换是什么意思？-1"><a href="#多线程上下文切换是什么意思？-1" class="headerlink" title="多线程上下文切换是什么意思？"></a>多线程上下文切换是什么意思？</h1><p>多- 线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</p>
<h1 id="Java-中堆和栈有什么不同？"><a href="#Java-中堆和栈有什么不同？" class="headerlink" title="Java 中堆和栈有什么不同？"></a>Java 中堆和栈有什么不同？</h1><ul>
<li>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的</li>
<li>而堆是所有线程共享的一片公用内存区域</li>
<li>对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</li>
</ul>
<h1 id="你如何在-Java-中获取线程堆栈？-1"><a href="#你如何在-Java-中获取线程堆栈？-1" class="headerlink" title="你如何在 Java 中获取线程堆栈？"></a>你如何在 Java 中获取线程堆栈？</h1><ul>
<li>对于不同的操作系统，有多种方法来获得 Java 进程的线程堆栈</li>
<li>当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台</li>
<li>在 Windows 你可以使用 Ctrl + Break 组合键来获取线程堆栈，Linux 下用 kill -3 命令</li>
<li>你也可以用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。</li>
</ul>
<h1 id="什么是阻塞式方法？-1"><a href="#什么是阻塞式方法？-1" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h1><ul>
<li>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接</li>
<li>这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回</li>
<li>此外，还有异步和非阻塞式方法在任务完成前就返回。</li>
</ul>
<h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。-1"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。-1" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul>
<li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</li>
<li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</li>
</ul>
<h1 id="我们可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#我们可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="我们可以使用CocurrentHashMap来代替Hashtable吗？"></a>我们可以使用CocurrentHashMap来代替Hashtable吗？</h1><ul>
<li>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。</li>
<li>ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。</li>
<li>它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。</li>
<li>因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。</li>
<li>简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</li>
</ul>
<h1 id="sleep-和yield-有什么区别"><a href="#sleep-和yield-有什么区别" class="headerlink" title="sleep()和yield()有什么区别?"></a>sleep()和yield()有什么区别?</h1><ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li>
<li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li>
<li>sleep()方法比yield()方法（跟操作系统相关）具有更好的可移植性。</li>
</ul>
<p> </p>
<h1 id="如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全-1"><a href="#如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全-1" class="headerlink" title="如何保证集合是线程安全的?ConcurrentHashMap 如何实现高效的线程安全?"></a>如何保证集合是线程安全的?ConcurrentHashMap 如何实现高效的线程安全?</h1><ul>
<li>Java提供了不同层面的线程安全支持。在传统集合框架内部,除了Hashtable Vector等同步容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等。具体选择要看开发的场景需求,总体来说,并发包内提供的容器通用场景,远优于早期的简单同步实现。</li>
</ul>
<h1 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h1><ul>
<li>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</li>
</ul>
<h1 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h1><ul>
<li>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</li>
</ul>
<h1 id="volatile-修饰符的有过什么实践？"><a href="#volatile-修饰符的有过什么实践？" class="headerlink" title="volatile 修饰符的有过什么实践？"></a>volatile 修饰符的有过什么实践？</h1><ul>
<li>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是 64 位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（writebarrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</li>
</ul>
<h1 id="volatile-类型变量提供什么保证？"><a href="#volatile-类型变量提供什么保证？" class="headerlink" title="volatile 类型变量提供什么保证？"></a>volatile 类型变量提供什么保证？</h1><ul>
<li>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT 为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和long 就是原子的。</li>
</ul>
<h1 id="10-个线程和-2-个线程的同步代码，哪个更容易写？"><a href="#10-个线程和-2-个线程的同步代码，哪个更容易写？" class="headerlink" title="10 个线程和 2 个线程的同步代码，哪个更容易写？"></a>10 个线程和 2 个线程的同步代码，哪个更容易写？</h1><ul>
<li>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</li>
</ul>
<h1 id="你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</h1><ul>
<li>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The standard idiom for using the wait method</span><br><span class="line">synchronized (obj) &#123;</span><br><span class="line">while (condition does not hold)</span><br><span class="line">obj.wait(); // (Releases lock, and reacquires on wakeup)</span><br><span class="line">... // Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h1><ul>
<li>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。</li>
<li>一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</li>
</ul>
<h1 id="如何创建守护线程？"><a href="#如何创建守护线程？" class="headerlink" title="如何创建守护线程？"></a>如何创建守护线程？</h1><ul>
<li>使用 Thread 类的 setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用 start()方法前调用这个方法，否则会抛出IllegalThreadStateException 异常。</li>
</ul>
<h1 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h1><ul>
<li>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li>
</ul>
<h1 id="你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？"><a href="#你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？" class="headerlink" title="你如何确保 main()方法所在的线程是 Java 程序最后结束的线程？"></a>你如何确保 main()方法所在的线程是 Java 程序最后结束的线程？</h1><ul>
<li>我们可以使用 Thread 类的 join()方法来确保所有程序创建的线程在 main()方法退出前结束。</li>
</ul>
<h1 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h1><ul>
<li>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。</li>
<li>java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li>
</ul>
<h1 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h1><ul>
<li>我们可以使用 Thread 类的 Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。</li>
</ul>
<h1 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h1><ul>
<li>Volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子性的。</li>
<li>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
<h1 id="Java-中的-ReadWriteLock-是什么？"><a href="#Java-中的-ReadWriteLock-是什么？" class="headerlink" title="Java 中的 ReadWriteLock 是什么？"></a>Java 中的 ReadWriteLock 是什么？</h1><ul>
<li>读写锁是用来提升并发程序性能的锁分离技术的成果。</li>
</ul>
<h1 id="Java-中的同步集合与并发集合有什么区别？"><a href="#Java-中的同步集合与并发集合有什么区别？" class="headerlink" title="Java 中的同步集合与并发集合有什么区别？"></a>Java 中的同步集合与并发集合有什么区别？</h1><ul>
<li>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</li>
</ul>
<h1 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a>Java 中 interrupted 和 isInterrupted 方法的区别？</h1><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><ul>
<li>interrupt 方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</li>
<li>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</li>
</ul>
<h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted"></a>interrupted</h4><ul>
<li>查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</li>
<li>isInterrupted仅仅是查询当前线程的中断状态</li>
</ul>
<h1 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h1><ul>
<li>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：<ul>
<li>在单线程环境下不能改变程序运行的结果；</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
</li>
<li>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</li>
</ul>
<h1 id="CopyOnWriteArrayList-可以用于什么应用场景？"><a href="#CopyOnWriteArrayList-可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList 可以用于什么应用场景？"></a>CopyOnWriteArrayList 可以用于什么应用场景？</h1><ul>
<li>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</li>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc；</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</li>
<li>CopyOnWriteArrayList 透露的思想<ul>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ul>
</li>
</ul>
<h1 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h1><ul>
<li>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</li>
</ul>
<h1 id="什么是竞争条件？你怎样发现和解决竞争？"><a href="#什么是竞争条件？你怎样发现和解决竞争？" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争？"></a>什么是竞争条件？你怎样发现和解决竞争？</h1><ul>
<li>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。</li>
</ul>
<h1 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h1><ul>
<li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor 接口对象能执行我们的线程任务。</li>
<li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>
<li>使用 ThreadPoolExecutor 可以创建自定义线程池。</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。</li>
</ul>
<h1 id="在-java-中守护线程和本地线程区别？"><a href="#在-java-中守护线程和本地线程区别？" class="headerlink" title="在 java 中守护线程和本地线程区别？"></a>在 java 中守护线程和本地线程区别？</h1><ul>
<li>java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</li>
<li>任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。</li>
<li>两者的区别：<ul>
<li>唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</li>
</ul>
</li>
<li>扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</li>
</ul>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用性（HA）系统</title>
    <url>/publishes/3842b15435d5.html</url>
    <content><![CDATA[<h1 id="SOA-面向服务的架构"><a href="#SOA-面向服务的架构" class="headerlink" title="SOA(面向服务的架构)"></a>SOA(面向服务的架构)</h1><ul>
<li>面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来</li>
<li>接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言</li>
<li>这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。</li>
<li>对于一个SOA解决方案来说就需要能够满足这些场景的业务需求，能够解决其中的各种技术问题</li>
<li>需要解决的基本问题包括：<ul>
<li>服务的描述问题，描述服务提供哪些功能，适用服务有哪些要求</li>
<li>服务的注册和查找问题，定义好的服务信息在哪发布，如何发布，到哪查找，如何查找</li>
<li>服务通讯方式，包括具体如何向服务发送请求，并获取应答，支持什么样的交互方式。</li>
<li>服务流程问题，对服务流程的灵活定制，执行监控等提供管理</li>
<li>服务的管理问题，服务的提供，撤销，改变这些情况如何进行管理</li>
<li>服务质量问题，如何保障安全性，通讯的可靠性，以及事务完整性如何保证</li>
<li>整个系统的效率问题，包括查找效率，通讯效率，服务运行处理效率等</li>
<li>系统能够提供什么样的开发工具，支持什么样的开发模式，系统运行情况是否可以及时了解，是否可以及时获取故障信息，是否可以提供运行状态信息，以利于系统的优化。</li>
</ul>
</li>
</ul>
<h1 id="ESB（企业服务总线）"><a href="#ESB（企业服务总线）" class="headerlink" title="ESB（企业服务总线）"></a>ESB（企业服务总线）</h1><ul>
<li>ESB全称为Enterprise Service Bus，即企业服务总线</li>
<li>它是传统中间件技术与XML、Web服务等技术结合的产物</li>
<li>ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素。</li>
<li>大规模分布式的企业应用需要相对简单而实用的中间件技术来简化和统一越来越复杂、繁琐的企业级信息系统平台</li>
<li>面向服务体系架构（SOA）是能够将应用程序的不同功能单元通过服务之间定义良好的接口和契约联系起来</li>
<li>SOA使用户可以不受限制地重复使用软件、把各种资源互连起来，只要IT人员选用标准接口包装旧的应用程序、把新的应用程序构建成服务，那么其他应用系统就可以很方便的使用这些功能服务。</li>
</ul>
<h1 id="SOA-与-ESB的区别"><a href="#SOA-与-ESB的区别" class="headerlink" title="SOA 与 ESB的区别"></a>SOA 与 ESB的区别</h1><ul>
<li>SOA是一种方式或架构，用于具有自服务功能的应用程序，应用程序随后通过用户接口（UI）或经过工作流将其聚合成用户需要的功能</li>
<li>服务不仅是可复用代码的组件，更是运行程序的一部分，客户端可以不必合并它自己的代码直接调用该程序</li>
<li>服务是与业务相关的一个定义。</li>
<li>ESB是用于调节 SOA 中的调用者及服务提供者的机制</li>
<li>它使得调用者在不知道提供者或提供者使用的地址的情况下调用该服务</li>
<li>ESB 可在多个提供者、提供者的负载平衡及停止使用提供者（当失效时）之间进行选择，并且基于调用者的需求在提供者之间进行选择，这些提供者提供了各种质量级别的服务</li>
<li>ESB 能够调节同步或异步服务，事实上对于同一服务可以提供同步及异步的访问。</li>
<li>因此 SOA 和 ESB 是相对应的。具备 SOA 的应用程序应当使用 ESB 来调用它的服务。SOA 和 ESB 不必用 Web 服务实现。然而，经常需要 ESB 来调用服务，该服务提供自我描述及发现的能力，这由 Web 服务帮助完成。在 SOA 中经常需要由一种技术实现的调用者，它们用于调用由其它技术实现的服务，这也由 Web 服务帮助完成</li>
<li>所以 SOA、ESB 和 Web 服务都集中于创建这样的领域：一个应用程序中的功能在其它应用程序中也是可用的，本质是复用性。</li>
</ul>
<h1 id="SAAS-软件即服务"><a href="#SAAS-软件即服务" class="headerlink" title="SAAS (软件即服务)"></a>SAAS (软件即服务)</h1><ul>
<li>SaaS是Software-as-a-Service（软件即服务）的简称,它与“on-demand software”（按需软件），the application service provider(ASP，应用服务提供商)，hosted software(托管软件)所具有相似的含义</li>
<li>它是一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。</li>
<li>对企业来说，SaaS的优点：<ul>
<li>从技术方面来看：SaaS是简单的部署，不需要购买任何硬件，刚开始只需要简单注册即可。企业无需再配备IT方面的专业技术人员，同时又能得到最新的技术应用，满足企业对信息管理的需求。</li>
<li>从投资方面来看：企业只以相对低廉的“月费”方式投资，不用一次性投资到位，不占用过多的营运资金，从而缓解企业资金不足的压力；不用考虑成本折旧问题，并能及时获得最新硬件平台及最佳解决方案。</li>
<li>从维护和管理方面来看：由于企业采取租用的方式来进行物流业务管理，不需要专门的维护和管理人员，也不需要为维护和管理人员支付额外费用。很大程度上缓解企业在人力、财力上的压力，使其能够集中资金对核心业务进行有效的运营；SaaS能使用户在世界上都是一个完全独立的系统。如果您连接到网络，就可以访问系统。</li>
</ul>
</li>
<li>对企业来说，SaaS的缺点<ul>
<li>安全性：企业，尤其是大型企业，很不情愿使用SaaS正是因为安全问题，他们要保护他们的核心数据，不希望这些核心数据由第三方来负责。</li>
<li>标准化：SaaS解决方案缺乏标准化。这个行业刚刚起步，没有明确的解决办法，一家公司可以设计建立一个解决方案。鉴于复杂和高度可定制的ERP产品，这是一个冒险的建议。</li>
</ul>
</li>
</ul>
<h1 id="SOA和SaaS的区别"><a href="#SOA和SaaS的区别" class="headerlink" title="SOA和SaaS的区别"></a>SOA和SaaS的区别</h1><ul>
<li>SOA包括了关于软件是如何被架构起来的东西，而SaaS是关于软件是如何被应用的。</li>
<li>在SaaS当中，应用程序可以像任何服务一样被传递，就像你家中电话的语音一样，看起来似乎就是为你的需求量体裁衣得到的。而SOA的定义和这个无丝毫的联系。SOA支持的服务，都是些离散的可以再使用的事务处理，这些事务处理合起来就组成了一个业务流程，是从基本的系统中提取出来的抽象代码。</li>
<li>SOA是一个框架的方法，而SaaS是一种传递模型。</li>
<li>通过SaaS传递Web服务并不需要SOA。</li>
<li>SaaS主要是指一个软件企业向其它企业提供软件服务。而SOA一般是企业内部搭建系统的基础。SaaS注重的是提供服务的思维。而SOA注重的是实现服务的思维。</li>
</ul>
<h1 id="微服务架构模式（Microservice-Architect-Pattern）"><a href="#微服务架构模式（Microservice-Architect-Pattern）" class="headerlink" title="微服务架构模式（Microservice Architect Pattern）"></a>微服务架构模式（Microservice Architect Pattern）</h1><ul>
<li>近两年在服务的疯狂增长与云计算技术的进步，让微服务架构受到重点关注微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值</li>
<li>每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。</li>
<li>每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建</li>
</ul>
<h4 id="微服务架构优势"><a href="#微服务架构优势" class="headerlink" title="微服务架构优势"></a>微服务架构优势</h4><ul>
<li>微服务架构的本质，是用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题</li>
<li>微服务架构将服务拆分，分别采用相对独立的服务对各方面进行管理，彼此之间使用统一的接口来进行交流，架构变得复杂，优势也很明显：<ul>
<li>复杂度可控：在将应用分解的同时，规避了原本复杂度无止境的积累</li>
<li>每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界</li>
<li>由于体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。</li>
<li>独立部署：由于微服务具备独立的运行进程，所以每个微服务也可以独立部署</li>
<li>当某个微服务发生变更时无需编译、部署整个应用</li>
<li>由微服务组成的应用相当于具备一系列可并行的发布流程，使得发布更加高效，同时降低对生产环境所造成的风险，最终缩短应用交付周期。</li>
<li>技术选型灵活：微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。由于每个微服务相对简单，当需要对技术栈进行升级时所面临的风险较低，甚至完全重构一个微服务也是可行的。</li>
<li>容错：当某一组建发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用</li>
<li>在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。</li>
<li>扩展：单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</li>
</ul>
</li>
</ul>
<h1 id="SOA和微服务架构的区别"><a href="#SOA和微服务架构的区别" class="headerlink" title="SOA和微服务架构的区别"></a>SOA和微服务架构的区别</h1><ul>
<li>微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化。</li>
<li>微服务架构强调的第一个重点就是业务系统需要彻底的组件化和服务化，原有的单个业务系统会拆分为多个可以独立开发，设计，运行和运维的小应用。这些小应用之间通过服务完成交互和集成。每个小应用从前端web ui，到控制层，逻辑层，数据库访问，数据库都完全是独立的一套。在这里我们不用组件而用小应用这个词更加合适，每个小应用除了完成自身本身的业务功能外，重点就是还需要消费外部其它应用暴露的服务，同时自身也将自身的能力朝外部发布为服务。</li>
<li>首先对于应用本身暴露出来的服务，是和应用一起部署的，即服务本身并不单独部署，服务本身就是业务组件已有的接口能力发布和暴露出来的</li>
<li>其次微服务架构本身来源于互联网的思路，因此组件对外发布的服务强调了采用HTTP Rest API的方式来进行。</li>
<li>微服务的基本思想在于考虑围绕着业务领域组件来创建应用，这些就应用可独立地进行开发、管理和加速。在分散的组件中使用微服务云架构和平台使部署、管理和服务功能交付变得更加简单。</li>
</ul>
<h1 id="什么是高可用性"><a href="#什么是高可用性" class="headerlink" title="什么是高可用性"></a>什么是高可用性</h1><ul>
<li>高可用性（HA）系统是目前企业防止核心计算机系统因故障停机的最有效手段。</li>
</ul>
<h1 id="高可用性（HA）的功能"><a href="#高可用性（HA）的功能" class="headerlink" title="高可用性（HA）的功能"></a>高可用性（HA）的功能</h1><ul>
<li>软件故障监测与排除</li>
<li>备份和数据保护</li>
<li>管理站能够监视各站点的运行情况，能随时或定时报告系统运行状况，故障能及时报告和告警，并有必要的控制手段</li>
<li>实现错误隔离以及主、备份服务器间的服务切换</li>
</ul>
<h1 id="HA的工作方式"><a href="#HA的工作方式" class="headerlink" title="HA的工作方式"></a>HA的工作方式</h1><ul>
<li>HA有主从方式和双工方式两种工作模式</li>
<li>高可用性方案则利用更少的冗余部件同时由软件检测故障，一旦故障发生立即隔离损坏部件，通过提供故障恢复实现最大化系统和应用的可用性。</li>
<li>容错技术随着处理器速度的加快和价格的下跌而越来越多地转移到软件中</li>
<li>未来容错技术将完全在软件环境下完成，那时它和高可用性技术之间的差别也就随之消失了。</li>
</ul>
<h1 id="高可用性（HA）系统-需要解决的问题"><a href="#高可用性（HA）系统-需要解决的问题" class="headerlink" title="高可用性（HA）系统-需要解决的问题"></a>高可用性（HA）系统-需要解决的问题</h1><ul>
<li>负载均衡与反向代理</li>
<li>隔离</li>
<li>限流</li>
<li>降级</li>
<li>超时与重试</li>
<li>回滚</li>
<li>压力测试与应急预案</li>
</ul>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul>
<li>负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性</li>
<li>软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，如DNS Load Balance，CheckPoint Firewall-1 ConnectControl等，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。</li>
<li>软件解决方案缺点也较多，因为每台服务器上安装额外的软件运行会消耗系统不定量的资源，越是功能强大的模块，消耗得越多，所以当连接请求特别大的时候，软件本身会成为服务器工作成败的一个关键；软件可扩展性并不是很好，受到操作系统的限制；由于操作系统本身的Bug，往往会引起安全问题。 硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。</li>
</ul>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul>
<li>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li>
<li>代理服务器有三种：<ul>
<li>标准的代理缓冲服务器：一个标准的代理缓冲服务被用于缓存静态的网页（例如：html文件和图片文件等）到本地网络上的一台主机上（即代理服务器）。</li>
<li>透明代理缓冲服务器：透明代理缓冲服务和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。</li>
<li>反向代理缓冲服务器：反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。</li>
</ul>
</li>
<li>安全反向代理用途：<ul>
<li>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。</li>
<li>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息。</li>
<li>安全反向代理会造成各安全连接加密数据所涉及的系统开销而变慢。 SSL 提供了高速缓存机制，连接双方重复使用先前协商的安全参数，大大降低后续连接的系统开销。</li>
</ul>
</li>
</ul>
<h4 id="隔离术"><a href="#隔离术" class="headerlink" title="隔离术"></a>隔离术</h4><ul>
<li>线程隔离:<ul>
<li>线程隔离主要是指线程池隔离，在实际使用时，我们会把请求分类，然后交给不同的线程池处理。当一种业务的请求处理发生问题时，不会将故障扩散到其他线程池，从而保证其他服务可用。</li>
</ul>
</li>
<li>进程隔离<ul>
<li>由于传统的系统所有功能都集中在一个系统中，为了避免系统其中一个模块功能出现问题导致整个系统无法使用的情况发生，将其该系统拆分成多子系统实现物理隔离，故通过进程隔离使得某一个子系统出现问题时不影响到其他子系统。</li>
</ul>
</li>
<li>集群隔离<ul>
<li>随着调用方的增多，当秒杀（并发量特别大功能）类似的服务被刷新会影响到其他服务的稳定性时，应该考虑为秒杀（并发量特别大功能）类似的服务提供单独的服务集群，即分服务分组，这样当某一个分组出现问题时，不会影响到其他分组，从而实现了故障隔离愿景。</li>
</ul>
</li>
<li>机房隔离<ul>
<li>随着对系统可用性的要求，会进行多机房部署，每一个机房的服务都有自己的服务分组，本机房的服务应该只调用本机房的服务，不进行跨机房调用。其中，一个机房服务发生问题时，可以通过DNS&#x2F;负载均衡将请求全部切到另一个机房，或者考虑服务能自动重试其他机房的服务，从而提升系统可用性。</li>
</ul>
</li>
<li>读写隔离<ul>
<li>为了提高数据访问，一般采用redis主从模式将读和写进群分离，在正常情况下，当主redis集群出现问题时，从redis集群还是可以用的，从而不影响用户的访问。</li>
</ul>
</li>
<li>动静隔离<ul>
<li>例如当用户访问如结算页时，如果JS&#x2F;CSS等静态资源也在结算页系统中时，很可能因为访问量太大导致带宽被打满导致出现不可用。为了不影响结算等用户操作的功能，将其JS&#x2F;CSS等静态资源静态化与用户操作功能分开部署。</li>
</ul>
</li>
<li>资源隔离<ul>
<li>最常见的资源如磁盘、CPU、网络；对于宝贵的资源都会存在竞争问题。我们可以使用JIMDB数据同步时要dump数据，SSD盘容量用了50%以上，dump到同一块磁盘时遇到了容量不足的问题，我们通过单独挂一块SAS盘来专门同步数据。还有如使用Docker容器时，有的容器写磁盘非常频繁，因此要考虑为不同的容器挂载不同的磁盘。</li>
</ul>
</li>
</ul>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul>
<li>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流</li>
<li>缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发&#x2F;请求量，即限流。</li>
<li>限流的目的是通过对并发访问&#x2F;请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</li>
<li>一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</li>
</ul>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><ul>
<li>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</li>
<li>降级预案<ul>
<li>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</li>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ul>
</li>
<li>降级按照是否自动化可分为：自动开关降级和人工开关降级。</li>
<li>降级按照功能可分为：读服务降级、写服务降级。</li>
<li>降级按照处于的系统层次可分为：多级降级。</li>
<li>降级的功能点主要从服务端链路考虑，即根据用户访问的服务调用链路来梳理哪里需要降级：页面降级、页面片段降级、页面异步请求降级、服务功能降级、读降级、写降级</li>
<li>自动开关降级：超时降级、统计失败次数降级、故障降级、限流降级</li>
<li>人工开关降级：读服务降级、写服务降级</li>
</ul>
<h4 id="超时与重试"><a href="#超时与重试" class="headerlink" title="超时与重试"></a>超时与重试</h4><ul>
<li>在实际开发过程中，我们见过太多故障时因为没有设置超时或者设置得不对而造成的，而这些故障都是因为没有意识到超时设置的重要性而造成的。如果应用不设置超时，则可能会导致请求响应慢，慢请求积累导致连锁反应，甚至造成应用雪塌。而有些中间件或者框架在超时后进行重试（例如dubbo默认重试两次），读服务天然适合重试，但写服务大多不能重试（如写订单、支付等），重试次数太多会导致多倍请求流量。</li>
<li>例如模拟了Ddos攻击（分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户&#x2F;服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS，通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户&#x2F;服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。），后果可能是灾难，因此，务必设置合理的重试机制，并且应该和熔断、快速失败机制配合。所以在进行代码Review时，一定记得Review超时与重试机制。</li>
</ul>
<h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><ul>
<li>事务回滚<ul>
<li>在执行数据库SQL时，如果我们检测到哦事务提交冲突，那么事务中所有执行的SQL要进行回滚，目的是防止数据库出现数据不一致。</li>
</ul>
</li>
<li>代码库回滚<ul>
<li>在开发项目时一定要将代码维护到代码仓库，从而进行版本管理。有了版本控制系统后可记录代码的历史版本，在出现问题时候可以方便回滚。</li>
</ul>
</li>
<li>部署版本回滚<ul>
<li>代码测试完成后，接下来要进行系统部署，在部署时要考虑当代码逻辑出现错误后如何快速恢复</li>
</ul>
</li>
<li>数据版本回滚<ul>
<li>在设计消息队列时，重要业务会对消息队列进行副本处理，以便万一业务逻辑出现问题能进行历史数据回滚，从而修复问题。</li>
</ul>
</li>
<li>静态资源版本回滚<ul>
<li>静态化页面资源后，每次内容变更时我们都会生成一个全量新版本放到项目的文件目录中，从而保证版本可追溯，出现问题时能及时回滚。</li>
</ul>
</li>
</ul>
<h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><ul>
<li>线下压力测试<ul>
<li>通过如Jmeter，Apac，he ab 压力测试系统的某一个接口等（如登录、查询订单）或者某一个组件（例如数据库连接池），然后进行调优（如调优JVM参数，优化代码等），实现单个接口或者组件的性能最优。</li>
</ul>
</li>
<li>线上压力测试<ul>
<li>线上压力测试份方式非常多，按读分为读压、写压测和混合压测，按照数据仿真度分为仿真压力测试和引流压力测试，按照给用户提供服务分为隔离集群压力测试和线上集群压力测试。</li>
</ul>
</li>
<li>系统优化和容灾<ul>
<li>拿到全面的压力测试报告后，接下来就是分析报告，然后进行一些有这对性的优化，如硬件升级、系统扩容、参数调优、代码优化（代码同步改异步）、架构优化（如加缓存、读写分离、历史数据归档）等。在扩容时也需要考虑容灾，比如分组部署、跨机房部署。容灾是通过部署多组（单机房或多机房）相同系统，当其中一组出现问题时，可以切换到另一个分组，保证系统可用</li>
</ul>
</li>
</ul>
<h4 id="应急预案"><a href="#应急预案" class="headerlink" title="应急预案"></a>应急预案</h4><ul>
<li>在系统压力测试之后发现一些系统瓶颈，在系统优化之后会提升系统吐吞量并降低响应时间，容灾之后的系统可用性得以保障，但还是会存在一些风险，如网络抖动、某台机器负载过高、某个服务变慢、数据库Load值过高，为了防止因为这些问题而出现系统雪崩，需要针对这些情况制定应急预案，从而在出现突发情况时，有响应的措施来解决掉这些问题。</li>
<li>应急预案可按照如下几步进行：首先进行系统分级，然后进行全链路分析、配置监控，最后制定应急预案。</li>
</ul>
<h1 id="高并发系统需要解决的问题"><a href="#高并发系统需要解决的问题" class="headerlink" title="高并发系统需要解决的问题"></a>高并发系统需要解决的问题</h1><ul>
<li>应用缓存</li>
<li>HTTP缓存</li>
<li>多级缓存</li>
<li>池化</li>
<li>异步并发</li>
<li>扩容</li>
<li>队列</li>
</ul>
<h4 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h4><ul>
<li>堆缓存<ul>
<li>使用Java堆内存来存储缓存对象。使用堆缓存的好处是没有序列化&#x2F;反序列化，是最快的缓存。缺点也很明显，当缓存的数据量很大时，GC（垃圾回收）暂停时间会变长，存储容量受限于堆空间大小。一般通过软引用&#x2F;弱引用来存储缓存对象，即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。有Guava Cache、Ehcache 3.x、MapDB实现</li>
</ul>
</li>
<li>堆外缓存<ul>
<li>即缓存数据存储在堆外内存，可以减少GC暂停时间（堆对象转移到堆外，GC扫描和移动的对象变少），但是，读取数据时需要序列化&#x2F;反序列化，因此会比堆缓存要慢很多。有Ehcache 3.x、MapDB实现</li>
</ul>
</li>
<li>磁盘缓存<ul>
<li>即缓存数据存储在磁道上，在JVM重启时数据还存在的，而堆缓存&#x2F;堆外缓存数据会丢失，需要重新加载。有Ehcache 3.x、MapDB实现</li>
</ul>
</li>
<li>分布式缓存<ul>
<li>之前缓存提到是进程内缓存和磁盘缓存，在多JVM实例的情况下，会存在两个问题：<ul>
<li>单机容量问题；</li>
<li>数据一致性问题（多台JVM实例的缓存数据不一致怎么办？），这个问题不用纠结，既然数据允许缓存，则表示允许一定时间内的不一致，因此可以设置缓存数据的过期时间来定期更新数据；</li>
<li>缓存不命中时，需要回源到DB&#x2F;服务请求多变问题：每个实例在缓存不命中的情况下都会回源到DB加载数据，因此多实例后DB整体的访问量变多了解决办法是可以使用如一致性哈希分片算法。因此，这些情况可以考虑使用分布式缓存来解决。可以使用ehcache –clustered(配合 Terracotta server) 实现JAVA进程间分布式缓存。最好的办法是使用redis实现分布式缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><ul>
<li>浏览器缓存是指当我们使用浏览器访问一些网站页面或者http服务时，根据服务端返回的缓存设置响应头将响应内容缓存到浏览器，下次可以直接使用缓存内容或者仅需要去服务端验证内容是否过期即可。这样的好处可以减少浏览器和服务端之间来回传输的数据量，节省带宽提升性能。解决办法：内容不需要动态（计算、渲染等）速度更快，内容越接近于用户速度越快。像apache traffic server、squid、varnish、nginx等技术都可以来进行内容缓存。还有CDN就是用来加速用户访问的：即用户首先访问到全国各地的CDN节点（使用如ATS、Squid实现），如果CDN没命中，会回源到中央nginx集群，该集群如果没有命中缓存（该集群的缓存不是必须的，要根据实际命中情况等决定），最后回源到后端应用集群。</li>
</ul>
<h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><ul>
<li>分布式缓存</li>
</ul>
<h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><ul>
<li>在应用系统开发过程中，我们经常会用到池化技术，如对象池、连接池、线程池等，通过池化来减少一些消耗，以提升性能</li>
<li>对象池通过复用对象从而减少创建对象、垃圾回收 的开销。但是，池化不能太大，太大会影响GC时的扫描时间</li>
<li>连接池如数据库连接池、Redis连接池、Http连接池，通过复用TCP连接减少创建和释放连接的时间来提升性能</li>
<li>线程池也是类似的，通过复用线程提升性能。也就是说池化的目的就是通过复用技术提升性能。</li>
</ul>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul>
<li>读写分离：当数据库访问量还不是很大的时候，我们可以适当增加服务器，数据库主从复制的方式将读写分离</li>
<li>垂直分区：当写入操作一旦增加的时候，那么主从数据库将花更多的时间的放在数据同步上，这个时候服务器也是不堪重负的；那么就有了数据的垂直分区，数据的垂直分区思路是将写入操作比较频繁的数据表，如用户表_user,或者订单表_orders,那么我们就可以把这个两个表分离出来，放在不同的服务器，如果这两个表和其他表存在联表查询，那么就只能把原来的sql语句给拆分了，先查询一个表，在查询另一个，虽然说这个会消耗更过性能，但比起那种大量数据同步，负担还是减轻了不少；</li>
<li>水平分区：但是往往事情不尽人意，可能采取垂直分区能撑一段时间，由于网站太火了，访问量又每日100w,一下子蹦到了1000w,这个时候可以采取数据的进行分离，我们可以根据user的Id不同进行分配，如采取%2的形式，或者%10的形式，当然这种形式对以后的扩展有了很大的限制，当我由10个分区增加到20个的时候，所有的数据都得重新分区，那么将是一个的很庞大的计算量；以下提供几种常见的算法：<ul>
<li>哈希算法：就是采用user_id%的方式;</li>
<li>范围：可以根据user_id字符值范围分区，如1-1000为一区，1001-2000则是另一个区等；</li>
<li>映射关系：就是将user_id存在的所对应的分区放在数据库中保存，当用户操作时先去查询所在分区，再进行操作；</li>
</ul>
</li>
</ul>
<h4 id="扩容分布式数据库"><a href="#扩容分布式数据库" class="headerlink" title="扩容分布式数据库"></a>扩容分布式数据库</h4><ul>
<li>分布式数据库（终极方案）：TDSQL架构采用自动扩容机制、分表逻辑、扩容流程、容灾机制、强同步方案解决分布式数据库扩容方案</li>
<li>系统由三个模块组成：Scheduler、Agent、网关，三个模块的交互都是通过ZooKeeper完成，极大简化了各个节点之间的通信机制，相对于第二代HOLD的开发简单了很多。</li>
<li>Scheduler作为集群的管理调度中心，主要功能包括：<ul>
<li>管理set，提供创建、删除set、set内节点替换等工作</li>
<li>所有的DDL操作统一下发和调度</li>
<li>监控set内各个节点的存活状态，当set内主节点故障，发起高一致性主备切换流程</li>
<li>监控各个set的CPU、磁盘容量、各个表的资源消耗情况，必要的时候自动发起扩容流程</li>
<li>Scheduler自身的容灾通过ZooKeqzer的选举机制完成，保证中心控制节点无单点。</li>
</ul>
</li>
<li>Agent模块负责监控本机MySQL实例的运行情况，主要功能包括：<ul>
<li>用短连接的方式周期性访问本机的MySQL实例，检测是否可读、可写，若发生异常，会将异常信息上报到ZooKeeper，最终会由上面描述的Scheduler模块检测到这个异常情况，从而发起容灾切换；</li>
<li>检测主备复制的执行情况，会定期上报主备复制的延时和延迟的事务数，若发生了主备切换，自动向新主机重建主备，因此MySQL的主备不需要DBA干预，对于新增的实例会自动采用xtrabackup通过主机自动重建数据；</li>
<li>检测MySQL实例的CPU利用率和各个表的请求量、数据量、CPU利用率，上报到ZooKeeper，ZooKeeper通过全局的资源情况抉择如何扩容、缩容；监控是否有下发到自身的扩容任务，如有则会执行扩容流程（下面会有描述）；监控是否要发生容灾切换，并按计划执行主备切换流程。</li>
</ul>
</li>
<li>网关基于MySQL Proxy开发，在网络层、连接管理、SQL解析、路由等方面做了大量优化，主要特点和功能如下：<ul>
<li>解析SQL，将识别出的DDL语句直接存到ZooKeeper，让Keeper来统一调度；</li>
<li>Watch ZooKeeper的路由信息，拉取最新的路由表保存到本地文件和内存；</li>
<li>将SQL请求路由到对应的set，支持读写分离；</li>
<li>对接入的IP、用户名、密码进行鉴权；</li>
<li>记录完整的SQL执行信息，与秒级监控平台对接完成实时的SQL请求的时耗，成功率等指标监控分析；</li>
<li>对count、distinct、sum、avg、max、min、order by、group by等聚合类SQL一般需要访问后端的多个set，网关会分析结果并做合并再返回，暂不支持跨set join和分布式事务；</li>
</ul>
</li>
<li>网关无状态，既支持与业务部署到一起，也可以独立部署（可通过TGW或者LVS做容灾）。</li>
</ul>
<h4 id="扩容（-Canal分布式数据库同步系统）"><a href="#扩容（-Canal分布式数据库同步系统）" class="headerlink" title="扩容（ Canal分布式数据库同步系统）"></a>扩容（ Canal分布式数据库同步系统）</h4><ul>
<li>基于Canal开源产品，获取数据库增量日志数据。</li>
<li>典型管理系统架构，manager(web管理)+node(工作节点)<ul>
<li>manager运行时推送同步配置到node节点</li>
<li>node节点将同步状态反馈到manager上</li>
</ul>
</li>
<li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作. 互联网技术高并发-队列应用场景<ul>
<li>异步处理：使用队列的一个主要原因是进行异步处理，比如用户注册完成后，需要发送注册成功邮件&#x2F;新用户积分&#x2F;优惠卷等；缓存过期时，先返回过期数据，然后异步更新缓存、异步写日志等。</li>
<li>系统解耦：比如用户支付完成订单后，需要通知生产配货系统、发票系统、库存系统、推荐系统、搜索系统等进行业务处理。</li>
<li>数据同步：比如想把mysql变更的数据同步到Redis，或者将mysql数据同步到mongodb,或者让机房之间的数据同步，或者主从数据同步等，有相关软件：databus、canal、otter等。使用数据总线队列进行数据同步的好处是可以保证数据修改的有序。</li>
<li>流量削峰：系统的瓶颈一般在数据库上，比如扣减库存、下单等，此时可以考虑使用队列将变更请求暂时放入队列，通过缓存+队列暂存的方式将数据库流量削峰。同样，对于秒杀系统，下单服务会是该系统的瓶颈，此时可以使用队列进行排队和限流，从而保护下单服务，通过队列暂存或者队列限流进行流量削峰</li>
</ul>
</li>
</ul>
<h4 id="队列（-Canal-）"><a href="#队列（-Canal-）" class="headerlink" title="队列（ Canal ）"></a>队列（ Canal ）</h4><ul>
<li>Canal 同步缓存</li>
<li>Canal 下发任务给消息队列</li>
</ul>
]]></content>
      <categories>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>HA</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket</title>
    <url>/publishes/4181b8cf024e.html</url>
    <content><![CDATA[<h1 id="什么是Socket编程"><a href="#什么是Socket编程" class="headerlink" title="什么是Socket编程"></a>什么是Socket编程</h1><ul>
<li>所谓socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄</li>
<li>应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</li>
<li>我们开发的网络应用程序位于应用层，TCP和UDP属于传输层协议，在应用层如何使用传输层的服务呢？在应用层和传输层之间，则是使用套接字来进行分离。</li>
<li>套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者接收远程发来的数据；而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次的工作。</li>
<li>Socket实际是传输层供给应用层的编程接口。传输层则在网络层的基础上提供进程到进程问的逻辑通道，而应用层的进程则利用传输层向另一台主机的某一进程通信。Socket就是应用层与传输层之间的桥梁</li>
<li>使用Socket编程可以开发客户机和服务器应用程序，可以在本地网络上进行通信，也可通过Internet在全球范围内通信</li>
</ul>
<h1 id="简述基于TCP和UDP的Socket编程的主要步骤"><a href="#简述基于TCP和UDP的Socket编程的主要步骤" class="headerlink" title="简述基于TCP和UDP的Socket编程的主要步骤"></a>简述基于TCP和UDP的Socket编程的主要步骤</h1><ul>
<li>Java分别为TCP和UDP 两种通信协议提供了相应的Socket编程类，这些类存放在java.net包中</li>
<li>与TCP对应的是服务器的ServerSocket和客户端的Socket，与UDP对应的是DatagramSocket。</li>
<li>基于TCP创建的套接字可以叫做流套接字，服务器端相当于一个监听器，用来监听端口</li>
<li>服务器与客服端之间的通讯都是输入输出流来实现的</li>
<li>基于UDP的套接字就是数据报套接字，两个都要先构造好相应的数据包。</li>
</ul>
<h4 id="基于TCP协议的Socket编程的主要步骤"><a href="#基于TCP协议的Socket编程的主要步骤" class="headerlink" title="基于TCP协议的Socket编程的主要步骤"></a>基于TCP协议的Socket编程的主要步骤</h4><h5 id="服务器端（server）"><a href="#服务器端（server）" class="headerlink" title="服务器端（server）"></a>服务器端（server）</h5><ul>
<li>构建一个ServerSocket实例，指定本地的端口。这个socket就是用来监听指定端口的连接请求的。</li>
<li>重复如下几个步骤：<ul>
<li>调用socket的accept()方法来获得下面客户端的连接请求。通过accept()方法返回的socket实例，建立了一个和客户端的新连接。</li>
<li>通过这个返回的socket实例获取InputStream和OutputStream,可以通过这两个stream来分别读和写数据。</li>
<li>结束的时候调用socket实例的close()方法关闭socket连接。</li>
</ul>
</li>
</ul>
<h5 id="客户端（client）"><a href="#客户端（client）" class="headerlink" title="客户端（client）"></a>客户端（client）</h5><ul>
<li>构建Socket实例，通过指定的远程服务器地址和端口来建立连接。</li>
<li>通过Socket实例包含的InputStream和OutputStream来进行数据的读写。</li>
<li>操作结束后调用socket实例的close方法，关闭</li>
</ul>
<h4 id="基于UDP协议的Socket编程的主要步骤"><a href="#基于UDP协议的Socket编程的主要步骤" class="headerlink" title="基于UDP协议的Socket编程的主要步骤"></a>基于UDP协议的Socket编程的主要步骤</h4><h5 id="服务器端（server）-1"><a href="#服务器端（server）-1" class="headerlink" title="服务器端（server）"></a>服务器端（server）</h5><ul>
<li>构造DatagramSocket实例，指定本地端口。</li>
<li>通过DatagramSocket实例的receive方法接收DatagramPacket.DatagramPacket中间就包含了通信的内容。</li>
<li>通过DatagramSocket的send和receive方法来收和发DatagramPacket.</li>
</ul>
<h5 id="客户端（client）-1"><a href="#客户端（client）-1" class="headerlink" title="客户端（client）"></a>客户端（client）</h5><ul>
<li>构造DatagramSocket实例。</li>
<li>通过DatagramSocket实例的send和receive方法发送DatagramPacket报文。</li>
<li>结束后，调用DatagramSocket的close方法关闭。</li>
</ul>
<h1 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h1><ul>
<li>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</li>
<li>WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</li>
<li>WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</li>
<li>单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</li>
<li>Light -与 http 相比，WebSocket 消息数据交换要轻得多。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/publishes/3aaab7406978.html</url>
    <content><![CDATA[<h1 id="说明缓冲流的优点和原理"><a href="#说明缓冲流的优点和原理" class="headerlink" title="说明缓冲流的优点和原理"></a>说明缓冲流的优点和原理</h1><ul>
<li>不带缓冲的流的工作原理：它读取到一个字节&#x2F;字符，就向用户指定的路径写出去，读一个写一个，所以就慢了。</li>
<li>带缓冲的流的工作原理：读取到一个字节&#x2F;字符，先不输出，等凑足了缓冲的最大容量后一次性写出去，从而提高了工作效率</li>
<li>优点：减少对硬盘的读取次数，降低对硬盘的损耗。</li>
</ul>
<h1 id="列举常用字节输入流和输出流并说明其特点，至少5对。"><a href="#列举常用字节输入流和输出流并说明其特点，至少5对。" class="headerlink" title="列举常用字节输入流和输出流并说明其特点，至少5对。"></a>列举常用字节输入流和输出流并说明其特点，至少5对。</h1><ul>
<li>FileInputStream 从文件系统中的某个文件中获得输入字节。</li>
<li>FileOutputStream 从程序当中的数据，写入到指定文件。</li>
<li>ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。</li>
<li>ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪 read 方法要提供的下一个字节。</li>
<li>FilterInputStream 包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。FilterInputStream 类本身只是简单地重写那些将所有请求传递给所包含输入流的 InputStream 的所有方法。FilterInputStream 的子类可进一步重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</li>
<li>StringBufferInputStream此类允许应用程序创建输入流，在该流中读取的字节由字符串内容提供。应用程序还可以使用ByteArrayInputStream 从 byte 数组中读取字节。 只有字符串中每个字符的低八位可以由此类使用。ByteArrayOutputStream此类实现了一个输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</li>
<li>FileOutputStream文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。文件是否可用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。</li>
<li>FilterOutputStream类是过滤输出流的所有类的超类。这些流位于已存在的输出流（基础 输出流）之上，它们将已存在的输出流作为其基本数据接收器，但可能直接传输数据或提供一些额外的功能。 FilterOutputStream 类本身只是简单地重写那些将所有请求传递给所包含输出流的 OutputStream 的所有方法。FilterOutputStream 的子类可进一步地重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</li>
<li>ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。</li>
<li>PipedOutputStream可以将管道输出流连接到管道输入流来创建通信管道。管道输出流是管道的发送端。通常，数据由某个线程写入 PipedOutputStream 对象，并由其他线程从连接的 PipedInputStream 读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于毁坏状态。</li>
</ul>
<h1 id="字符流字节流联系区别；什么时候使用字节流和字符流"><a href="#字符流字节流联系区别；什么时候使用字节流和字符流" class="headerlink" title="字符流字节流联系区别；什么时候使用字节流和字符流?"></a>字符流字节流联系区别；什么时候使用字节流和字符流?</h1><ul>
<li>字符流和字节流是流的一种划分，按处理照流的数据单位进行的划分</li>
<li>两类都分为输入和输出操作</li>
<li>在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。这四个都是抽象类。</li>
<li>字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组</li>
<li>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的编码来处理，也就是要进行字符集的转化 这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联的。</li>
</ul>
<h1 id="输入流和输出流联系和区别，节点流和处理流联系和区别"><a href="#输入流和输出流联系和区别，节点流和处理流联系和区别" class="headerlink" title="输入流和输出流联系和区别，节点流和处理流联系和区别"></a>输入流和输出流联系和区别，节点流和处理流联系和区别</h1><ul>
<li>流就像管道一样，在程序和文件之间，输入输出的方向是针对程序而言，向程序中读入东西，就是输入流，从程序中向外读东西，就是输出流。</li>
<li>输入流是得到数据，输出流是输出数据，而节点流，处理流是流的另一种划分，按照功能不同进行的划分</li>
<li>节点流，可以从或向一个特定的地方(节点)读写数据</li>
<li>处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader</li>
<li>处理流的构造方法总是要带一个其他的流对象做参数</li>
<li>一个流对象经过其他流的多次包装，称为流的链接。</li>
</ul>
<h1 id="I-O-流两种流（字符、字节）、四个接口："><a href="#I-O-流两种流（字符、字节）、四个接口：" class="headerlink" title="I&#x2F;O 流两种流（字符、字节）、四个接口："></a>I&#x2F;O 流两种流（字符、字节）、四个接口：</h1><ul>
<li>Read&#x2F;Write，Input&#x2F;Output</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/publishes/a36cfa964151.html</url>
    <content><![CDATA[<h1 id="Java反射技术主要实现类有哪些，作用分别是什么？"><a href="#Java反射技术主要实现类有哪些，作用分别是什么？" class="headerlink" title="Java反射技术主要实现类有哪些，作用分别是什么？"></a>Java反射技术主要实现类有哪些，作用分别是什么？</h1><ul>
<li>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中</li>
<li>Class类：代表一个类</li>
<li>Field 类：代表类的成员变量(属性)</li>
<li>Method类：代表类的成员方法</li>
<li>Constructor 类：代表类的构造方法</li>
<li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li>
</ul>
<h1 id="反射的使用场合和作用、及其优缺点"><a href="#反射的使用场合和作用、及其优缺点" class="headerlink" title="反射的使用场合和作用、及其优缺点"></a>反射的使用场合和作用、及其优缺点</h1><ul>
<li>使用场合：在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息。</li>
<li>主要作用：通过反射可以使程序代码访问装载到JVM 中的类的内部信息，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息</li>
<li>反射的优点：反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类；反射是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的。Java反射技术应用领域很广，如软件测试、 EJB、JavaBean等；许多流行的开源框架例如Struts、Hibernate、Spring在实现过程中都采用了该技术</li>
<li>反射的缺点<ul>
<li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。</li>
<li>使用反射会模糊程序内部逻辑：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。</li>
</ul>
</li>
</ul>
<h1 id="Java-反射机制的作用？"><a href="#Java-反射机制的作用？" class="headerlink" title="Java 反射机制的作用？"></a>Java 反射机制的作用？</h1><ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
</ul>
<h1 id="JAVA-反射"><a href="#JAVA-反射" class="headerlink" title="JAVA 反射"></a>JAVA 反射</h1><h4 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h4><ul>
<li>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。</li>
</ul>
<h4 id="反射机制概念-（运行状态中知道类所有的属性和方法）"><a href="#反射机制概念-（运行状态中知道类所有的属性和方法）" class="headerlink" title="反射机制概念 （运行状态中知道类所有的属性和方法）"></a>反射机制概念 （运行状态中知道类所有的属性和方法）</h4><ul>
<li>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；</li>
<li>并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</li>
</ul>
<h4 id="反射的应用场合"><a href="#反射的应用场合" class="headerlink" title="反射的应用场合"></a>反射的应用场合</h4><ul>
<li>编译时类型和运行时类型</li>
<li>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：Person p&#x3D;new Student();其中编译时类型为 Person，运行时类型为 Student。的编译时类型无法获取具体方法程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。</li>
<li>然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/publishes/73098ee3eeb0.html</url>
    <content><![CDATA[<h1 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h1><ul>
<li>Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。</li>
<li>Java中还有一个Collections类，专门用来操作集合类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li>
</ul>
<h1 id="集合和数组的比较（为什么引入集合）"><a href="#集合和数组的比较（为什么引入集合）" class="headerlink" title="集合和数组的比较（为什么引入集合）"></a>集合和数组的比较（为什么引入集合）</h1><ul>
<li>数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框架类可适用于不同场合</li>
<li>具体如下：<ul>
<li>数组的效率高于集合类.</li>
<li>数组能存放基本数据类型和对象，而集合类中只能放对象。</li>
<li>数组容量固定且无法动态改变，集合类容量动态改变。</li>
<li>数组无法判断其中实际存有多少元素，length只告诉了array的容量。</li>
<li>集合有多种实现方式和不同的适用场合，而不像数组仅采用顺序表方式。</li>
<li>集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。</li>
</ul>
</li>
</ul>
<h1 id="TreeSet的原理和使用"><a href="#TreeSet的原理和使用" class="headerlink" title="TreeSet的原理和使用"></a>TreeSet的原理和使用</h1><ul>
<li>TreeSet集合，元素不允许重复且有序(自然顺序)</li>
<li>TreeSet采用树结构存储数据，存入元素时需要和树中元素进行对比，需要指定比较策略。</li>
<li>可以通过Comparable(外部比较器)和Comparator(内部比较器)来指定比较策略，实现了Comparable的系统类可以顺利存入TreeSet。自定义类可以实现Comparable接口来指定比较策略。</li>
<li>可创建Comparator接口实现类来指定比较策略，并通过TreeSet构造方法参数传入。这种方式尤其对系统类非常适用。</li>
</ul>
<h1 id="HashSet的使用和原理"><a href="#HashSet的使用和原理" class="headerlink" title="HashSet的使用和原理"></a>HashSet的使用和原理</h1><ul>
<li>哈希表的查询速度特别快，时间复杂度为O（1）。</li>
<li>HashMap、Hashtable、HashSet这些集合采用的是哈希表结构，需要用到hashCode哈希码，hashCode是一个整数值。</li>
<li>系统类已经覆盖了hashCode方法 自定义类如果要放入hash类集合，必须重写hashcode。如果不重写，调用的是Object的hashcode，而Object的hashCode实际上是地址。</li>
<li>向哈希表中添加数据的原理：当向集合Set中增加对象时，首先集合计算要增加对象的hashCode码，根据该值来得到一个位置用来存放当前对象，如在该位置没有一个对象存在的话，那么集合Set认为该对象在集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接着将准备增加到集合中的对象与该位置上的对象进行equals方法比较，如果该equals方法返回false,那么集合认为集合中不存在该对象，在进行一次散列，将该对象放到散列后计算出的新地址里。如果equals方法返回true，那么集合认为集合中已经存在该对象了，不会再将该对象增加到集合中了。</li>
<li>在哈希表中判断两个元素是否重复要使用到hashCode()和equals()。hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。</li>
<li>Y&#x3D;K(X) ：K是函数，X是哈希码，Y是地址</li>
</ul>
<h1 id="ArrayList和LinkedList的区别和联系"><a href="#ArrayList和LinkedList的区别和联系" class="headerlink" title="ArrayList和LinkedList的区别和联系"></a>ArrayList和LinkedList的区别和联系</h1><ul>
<li>相同点：两者都实现了List接口，都具有List中元素有序、不唯一的特点。</li>
<li>不同点：ArrayList实现了长度可变的数组，在内存中分配连续空间。遍历元素和随机访问元素的效率比较高；LinkedList采用链表存储方式。插入、删除元素时效率比较高</li>
</ul>
<h1 id="HashMap和Hashtable的区别和联系"><a href="#HashMap和Hashtable的区别和联系" class="headerlink" title="HashMap和Hashtable的区别和联系"></a>HashMap和Hashtable的区别和联系</h1><ul>
<li>相同点：实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</li>
<li>不同点：<ul>
<li>Hashtable是早期提供的接口，HashMap是新版JDK提供的接口</li>
<li>Hashtable继承Dictionary类，HashMap实现Map接口</li>
<li>Hashtable线程安全，HashMap线程非安全</li>
<li>Hashtable不允许null值，HashMap允许null值</li>
</ul>
</li>
</ul>
<h1 id="Vector和ArrayList的区别和联系"><a href="#Vector和ArrayList的区别和联系" class="headerlink" title="Vector和ArrayList的区别和联系"></a>Vector和ArrayList的区别和联系</h1><ul>
<li>相同点：<ul>
<li>实现原理相同—底层都使用数组</li>
<li>功能相同—实现增删改查等操作的方法相似</li>
<li>都是长度可变的数组结构，很多情况下可以互用</li>
</ul>
</li>
<li>不同点：<ul>
<li>Vector是早期JDK接口，ArrayList是替代Vector的新接口</li>
<li>Vector线程安全，ArrayList重速度轻安全，线程非安全</li>
<li>长度需增长时，Vector默认增长一倍，ArrayList增长50%</li>
</ul>
</li>
</ul>
<h1 id="Java集合体系结构"><a href="#Java集合体系结构" class="headerlink" title="Java集合体系结构"></a>Java集合体系结构</h1><ul>
<li>Collection 接口存储一组不唯一，无序的对象</li>
<li>List 接口存储一组不唯一，有序（插入顺序）的对象</li>
<li>Set 接口存储一组唯一，无序的对象</li>
<li>Map接口存储一组键值对象，提供key到value的映射。Key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</li>
</ul>
<h1 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h1><ul>
<li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li>
<li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</li>
<li>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li>
</ul>
<h1 id="List、Map、Set-三个接口，存取元素时，各有什么特点？"><a href="#List、Map、Set-三个接口，存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set 三个接口，存取元素时，各有什么特点？"></a>List、Map、Set 三个接口，存取元素时，各有什么特点？</h1><ul>
<li>List以特定索引来存取元素，可有重复元素。</li>
<li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）</li>
<li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一</li>
<li>Set和Map容器都有基于哈希存储和排序树（红黑树）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</li>
</ul>
<p> </p>
<h1 id="说出ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#说出ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="说出ArrayList、Vector、LinkedList 的存储性能和特性？"></a>说出ArrayList、Vector、LinkedList 的存储性能和特性？</h1><ul>
<li>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。</li>
<li>遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖）。同理，Stack类继承Vector也是不正确的。</li>
</ul>
<p> </p>
<h1 id="List、Set、Map-是否继承自-Collection-接口？"><a href="#List、Set、Map-是否继承自-Collection-接口？" class="headerlink" title="List、Set、Map 是否继承自 Collection 接口？"></a>List、Set、Map 是否继承自 Collection 接口？</h1><ul>
<li>List、Set 的父接口是 Collection，Map 不是其子接口，而是与Collection 接口是平行关系，互不包含。</li>
<li>Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</li>
</ul>
<h1 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的-sort（）方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的-sort（）方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？</h1><ul>
<li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li>
<li>TreeMap 要求存放的键值对映射的键必须实现 Comparable接口从而根据键对元素进行排序</li>
<li>Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li>
</ul>
<h1 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?</h1><ul>
<li>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。</li>
<li>equals()和&#x3D;&#x3D;方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值</li>
</ul>
<h1 id="List-和-Map-区别"><a href="#List-和-Map-区别" class="headerlink" title="List 和 Map 区别?"></a>List 和 Map 区别?</h1><ul>
<li>一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复</li>
<li>Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</li>
</ul>
<h1 id="你是怎么理解-java-的泛型的？"><a href="#你是怎么理解-java-的泛型的？" class="headerlink" title="你是怎么理解 java 的泛型的？"></a>你是怎么理解 java 的泛型的？</h1><ul>
<li>在 Java SE 1.5 之前，没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</li>
<li>泛型是 Java SE 1.5 的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>架构</title>
    <url>/publishes/fec4be92fa21.html</url>
    <content><![CDATA[<h1 id="什么是-ELK（ElasticSearch-Logstash-Kibana）"><a href="#什么是-ELK（ElasticSearch-Logstash-Kibana）" class="headerlink" title="什么是 ELK（ElasticSearch, Logstash, Kibana）"></a>什么是 ELK（ElasticSearch, Logstash, Kibana）</h1><ul>
<li>ELK 是三个工具的集合，Elasticsearch + Logstash + Kibana，这三个工具组合形成了<br>一套实用、易用的监控架构，很多公司利用它来搭建可视化的海量日志分析平台。</li>
</ul>
<h4 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h4><ul>
<li>ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口</li>
<li>Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li>
</ul>
<h4 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h4><ul>
<li>Logstash 是一个用于管理日志和事件的工具，你可以用它去收集日志、转换日志、解析日志并将他们作为数据提供给其它模块调用，例如搜索、存储等。</li>
</ul>
<h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><ul>
<li>Kibana 是一个优秀的前端日志展示框架，它可以非常详细的将日志转化为各种图表，为用户提供强大的数据可视化支持。</li>
</ul>
<h1 id="什么是网关服务？"><a href="#什么是网关服务？" class="headerlink" title="什么是网关服务？"></a>什么是网关服务？</h1><ul>
<li>网关服务，通常是外部访问服务的唯一接口，访问内部的所有服务都必须先经过网关服务。网关服务的主要功能是消息解析过滤，路由，转发等。</li>
</ul>
<h1 id="网关服务中，路由器的-4-种路由规则方法是什么？"><a href="#网关服务中，路由器的-4-种路由规则方法是什么？" class="headerlink" title="网关服务中，路由器的 4 种路由规则方法是什么？"></a>网关服务中，路由器的 4 种路由规则方法是什么？</h1><ul>
<li>采用 URL 指定路由方式</li>
<li>采用服务名称指定路由方式</li>
<li>路由的排除方法</li>
<li>路由的添加前缀方法</li>
</ul>
<h1 id="什么是服务的灾难性的雪崩效应？"><a href="#什么是服务的灾难性的雪崩效应？" class="headerlink" title="什么是服务的灾难性的雪崩效应？"></a>什么是服务的灾难性的雪崩效应？</h1><ul>
<li>在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问 A 服务，而 A 服务需要调用 B 服务，B 服务需要调用 C 服务，由于网络原因或者自身的原因，如果 B 服务或者 C 服务不能及时响应，A 服务将处于阻塞状态，直到 B 服务 C 服务响应。</li>
<li>此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应</li>
</ul>
<h1 id="如何解决灾难性雪崩效应？"><a href="#如何解决灾难性雪崩效应？" class="headerlink" title="如何解决灾难性雪崩效应？"></a>如何解决灾难性雪崩效应？</h1><ul>
<li>降级：超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值.</li>
<li>隔离（线程池隔离和信号量隔离）：限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。</li>
<li>熔断：当失败率(如因网络故障&#x2F;超时造成的失败率高)达到阀值自动触发降级，熔断器触发的快速失败会进行快速恢复。</li>
<li>缓存：提供了请求缓存。</li>
<li>请求合并：提供请求合并。</li>
</ul>
<h1 id="什么是声明式，有什么作用，解决什么问题？"><a href="#什么是声明式，有什么作用，解决什么问题？" class="headerlink" title="什么是声明式，有什么作用，解决什么问题？"></a>什么是声明式，有什么作用，解决什么问题？</h1><ul>
<li>声明式调用就像调用本地方法一样调用远程方法;无感知远程 http 请求。</li>
<li>Spring Cloud 的声明式调用, 可以做到使用 HTTP 请求远程服务时能就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。</li>
<li>它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规的 Http Client 构造请求再解析返回数据。</li>
<li>它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</li>
</ul>
<h1 id="什么是-AKF-拆分原则？"><a href="#什么是-AKF-拆分原则？" class="headerlink" title="什么是 AKF 拆分原则？"></a>什么是 AKF 拆分原则？</h1><ul>
<li>业界对于可扩展的系统架构设计有一个朴素的理念,就是：通过加机器就可以解决容量和可用性问题。(如果一台不行那就两台)。</li>
</ul>
<h1 id="简单讲一下-webservice-使用的场景"><a href="#简单讲一下-webservice-使用的场景" class="headerlink" title="简单讲一下 webservice 使用的场景"></a>简单讲一下 webservice 使用的场景</h1><ul>
<li>webservice 是一个 SOA(面向服务的编程)的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过 Internet 进行基于 http 协议的网络应用间的交互。</li>
<li>异构系统(不同的开发语言)的整合</li>
<li>不同客户端的整合 (浏览器、手机端(android\ios)、微信)</li>
<li>实实在在的例子：天气预报：可以通过实现 webservice 客户端调用远程天气服务实现的</li>
<li>单点登录：一个服务实现所有系统的登录</li>
</ul>
<h1 id="什么是-VSFTPD？"><a href="#什么是-VSFTPD？" class="headerlink" title="什么是 VSFTPD？"></a>什么是 VSFTPD？</h1><ul>
<li>vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。</li>
<li>vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX 等系统上面，是一个完全免费的、开放源代码的 ftp 服务器软件，支持很多其他的 FTP 服务器所不支持的特征。</li>
</ul>
<h1 id="项目的生命周期"><a href="#项目的生命周期" class="headerlink" title="项目的生命周期"></a>项目的生命周期</h1><ul>
<li>需求分析</li>
<li>概要设计</li>
<li>详细设计(用例图，流程图，类图)</li>
<li>数据库设计(powerdesigner)</li>
<li>代码开发（编写）</li>
<li>单元测试（junit 白盒测试）(开发人员) svn版本管理工具(提交，更新代码，文档)</li>
<li>集成测试 （黑盒测试，loadrunner（编写测试脚本）(高级测试)）</li>
<li>上线试运行 （用户自己体验）</li>
<li>压力测试（loadrunner）</li>
<li>正式上线</li>
<li>维护</li>
</ul>
<h1 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h1><ul>
<li>CND 一般包含分发服务系统、负载均衡系统和管理系统</li>
</ul>
<h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><ul>
<li>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。</li>
<li>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。</li>
<li>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。</li>
</ul>
<h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><ul>
<li>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</li>
<li>使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。</li>
<li>GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。</li>
<li>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个 Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。</li>
</ul>
<h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><ul>
<li>分为运营管理和网络管理子系统。</li>
<li>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。</li>
<li>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。包括用户管理、产品管理、计费管理、统计分析等。</li>
</ul>
<h1 id="RMI-实现方式"><a href="#RMI-实现方式" class="headerlink" title="RMI 实现方式"></a>RMI 实现方式</h1><ul>
<li>Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用</li>
<li>实现步骤<ul>
<li>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</li>
<li>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</li>
<li>运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类;</li>
<li>启动一个 RMI 注册表，以便驻留这些服务;</li>
<li>在 RMI 注册表中注册服务；</li>
<li>客户端查找远程对象，并调用远程方法；<ul>
<li>创建远程接口，继承 java.rmi.Remote 接口</li>
<li>实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类</li>
<li>生成 Stub 和 Skeleton;</li>
<li>执行 rmiregistry 命令注册服务</li>
<li>启动服务</li>
<li>客户端调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="什么是微服务中的反应性扩展？"><a href="#什么是微服务中的反应性扩展？" class="headerlink" title="什么是微服务中的反应性扩展？"></a>什么是微服务中的反应性扩展？</h1><ul>
<li>Reactive Extensions 也称为 Rx</li>
<li>这是一种设计方法，我们通过调用多个服务来收集结果，然后编译组合响应</li>
<li>这些调用可以是同步或异步，阻塞或非阻塞。Rx是分布式系统中非常流行的工具，与传统流程相反。</li>
</ul>
<h1 id="我们可以用微服务创建状态机吗？"><a href="#我们可以用微服务创建状态机吗？" class="headerlink" title="我们可以用微服务创建状态机吗？"></a>我们可以用微服务创建状态机吗？</h1><ul>
<li>我们知道拥有自己的数据库的每个微服务都是一个可独立部署的程序单元，这反过来又让我们可以创建一个状态机。因此，我们可以为特定的微服务指定不同的状态和事件。</li>
<li>例如，我们可以定义 Order 微服务。订单可以具有不同的状态。Order 状态的转换可以是 Order 微服务中的独立事件。</li>
</ul>
<h1 id="架构师在微服务架构中的角色是什么？"><a href="#架构师在微服务架构中的角色是什么？" class="headerlink" title="架构师在微服务架构中的角色是什么？"></a>架构师在微服务架构中的角色是什么？</h1><ul>
<li>微服务架构中的架构师扮演以下角色：<ul>
<li>决定整个软件系统的布局。</li>
<li>帮助确定组件的分区。因此，他们确保组件相互粘合，但不紧密耦合。</li>
<li>与开发人员共同编写代码，了解日常生活中面临的挑战。</li>
<li>为开发微服务的团队提供某些工具和技术的建议。</li>
<li>提供技术治理，以便技术开发团队遵循微服务原则。</li>
</ul>
</li>
</ul>
<h1 id="什么是持续监测？"><a href="#什么是持续监测？" class="headerlink" title="什么是持续监测？"></a>什么是持续监测？</h1><ul>
<li>持续监控深入监控覆盖范围，从浏览器内前端性能指标，到应用程序性能，再到主机虚拟化基础架构指标。</li>
</ul>
<h1 id="什么是金丝雀释放？"><a href="#什么是金丝雀释放？" class="headerlink" title="什么是金丝雀释放？"></a>什么是金丝雀释放？</h1><ul>
<li>Canary Releasing 是一种降低在生产中引入新软件版本的风险的技术。这是通过将变更缓慢地推广到一小部分用户，然后将其发布到整个基础架构，即将其提供给每个人来完成的。</li>
</ul>
<h1 id="什么是持续集成（CI）？"><a href="#什么是持续集成（CI）？" class="headerlink" title="什么是持续集成（CI）？"></a>什么是持续集成（CI）？</h1><ul>
<li>持续集成（CI）是每次团队成员提交版本控制更改时自动构建和测试代码的过程。</li>
<li>这鼓励开发人员通过在每个小任务完成后将更改合并到共享版本控制存储库来共享代码和单元测试。</li>
</ul>
<h1 id="您对-Mike-Cohn-的测试金字塔了解多少？"><a href="#您对-Mike-Cohn-的测试金字塔了解多少？" class="headerlink" title="您对 Mike Cohn 的测试金字塔了解多少？"></a>您对 Mike Cohn 的测试金字塔了解多少？</h1><ul>
<li>Mike Cohn 提供了一个名为 Test Pyramid 的模型。这描述了软件开发所需的自动化测试类型。</li>
<li>根据金字塔，第一层的测试数量应该最高。在服务层，测试次数应小于单元测试级别，但应大于端到端级别。</li>
</ul>
<h1 id="Mock-或-Stub-有什么区别？"><a href="#Mock-或-Stub-有什么区别？" class="headerlink" title="Mock 或 Stub 有什么区别？"></a>Mock 或 Stub 有什么区别？</h1><ul>
<li>存根<ul>
<li>一个有助于运行测试的虚拟对象。</li>
<li>在某些可以硬编码的条件下提供固定行为。</li>
<li>永远不会测试存根的任何其他行为。</li>
</ul>
</li>
<li>例如，对于空堆栈，您可以创建一个只为 empty（）方法返回 true 的存根。因此，这并不关心堆栈中是否存在元素。</li>
<li>嘲笑<ul>
<li>一个虚拟对象，其中最初设置了某些属性。</li>
<li>此对象的行为取决于 set 属性。</li>
<li>也可以测试对象的行为。</li>
</ul>
</li>
<li>例如，对于 Customer 对象，您可以通过设置名称和年龄来模拟它。您可以将 age设置为 12，然后测试 isAdult（）方法，该方法将在年龄大于 18 时返回 true。因此，您的 Mock Customer 对象适用于指定的条件。</li>
</ul>
<h1 id="我们如何在测试中消除非决定论？"><a href="#我们如何在测试中消除非决定论？" class="headerlink" title="我们如何在测试中消除非决定论？"></a>我们如何在测试中消除非决定论？</h1><ul>
<li>非确定性测试（NDT）基本上是不可靠的测试。所以，有时可能会发生它们通过，显然有时它们也可能会失败。当它们失败时，它们会重新运行通过。</li>
<li>从测试中删除非确定性的一些方法如下：<ul>
<li>隔离</li>
<li>异步</li>
<li>远程服务</li>
<li>隔离</li>
<li>时间</li>
<li>资源泄漏</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/publishes/c96491b71c82.html</url>
    <content><![CDATA[<h1 id="什么是-Maven？"><a href="#什么是-Maven？" class="headerlink" title="什么是 Maven？"></a>什么是 Maven？</h1><ul>
<li>Maven 使用项目对象模型(POM)的概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</li>
<li>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具</li>
<li>由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目</li>
<li>由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发布时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</li>
<li>Maven 的出现，解决了开发过程中的 jar 包升级及依赖的难题</li>
<li>它可以对项目依赖的 jar包进行管理，可以让你的项目保持基本的依赖，排除冗余 jar 包，并且可以让你非常轻松的对依赖的 jar 包进行版本升级</li>
<li>而这些仅仅是 Maven 最基本的功能，它可以在这基础上对项目进行清理、编译、测试、打包、发布等等构建项目的工作。</li>
<li>可以说，Maven 是现在 Java 社区中最强大的项目管理和项目构建工具，而更加值得庆幸的是，这样一个强大的工具，它的使用也是非常简单的。</li>
<li>现在，JavaEE 项目使用的开源软件都可以通过 Maven 来获取，并且，越来越多的公司也开始使用 Maven 来管理构建项目了。</li>
</ul>
<h1 id="Maven-和-ANT-的区别"><a href="#Maven-和-ANT-的区别" class="headerlink" title="Maven 和 ANT 的区别"></a>Maven 和 ANT 的区别</h1><ul>
<li>maven&amp;ant 同属 apach 是流行的构建工具。</li>
<li>都是为了简化软件开发而存在的。但是 maven 因为自身管理一个项目对象模型（project object model），这个模型其实就是抽象了一个项目的开发流程，它包含了一个项目的生命周期的各个阶段，并将这个周期固定下来，这也就是约定大于配置。约定大于配置的意思就是，我 maven 将项目开发的各个阶段固定起来了，每个文件的存放位置，每个阶段要生成什么文件、保存为什么格式并且要把它放在什么位置，我都固定好了。我知道一个软件是怎么开发出来，如果一个项目要使用 maven，可以，但你要遵循我的规则，文件目录不要乱建乱放，只有这样 maven 才会将源码用起来。这就是约定大于配置，因为 maven 已经将流程固定下来了，只要遵守约定，就不需要自己手动去配置了，这将大大地提高开发效率。- 就像是开车一样，只要知道点火、油门、方向、刹车，就可以将车子开东起来（当然出于安全和法律考虑，还是要考驾照的。），关于车子内部的传动原理，电气原理，工程原理，普通人并不需要了解多少，日常够用就好了。这也是约定大于配置的一个例子。配置就是自己造一辆车去开，有必要，有能力，有时间吗？</li>
<li>maven 的中央仓库和 pom.xml 文件。中央仓库统一存放了开发用到的各种 jar 包，要用时只需要添加依赖到 pom 文件中，maven 就会自动下载，当然为了方便一般会在本地建一个仓库，减少下载时间。pom 文件是 maven 的配置文件，maven 就是通过管理 pom 文件和一些核心插件来管理项目。当然我前面将 maven 拟人化了，其实 maven 是没有智力的，一切都是封装好的流程，只是 maven 将很多操作隐藏起来了。</li>
<li>ant 的 build.xml 文件。build 文件是 ant 的配置文件，ant 依靠它来执行操作，与 maven不同的是 ant 没有固定一条程序链。你想要执行什么操作以及操作之间的顺序和依赖关系，都需要手动添加到 build 文件中，一点一滴都要写清楚，否则 ant 就不会执行。</li>
<li>maven 和 ant 区别<ul>
<li>Maven 拥有约定，只要遵守约定，它就知道你的源代码在哪里。Maven 是声明式的。你需要做的只是创建一个 pom.xml 文件然后将源代码放到默认的目录。Maven 会帮你处理其它的事情。Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。缺点是运行许多默认目标。而 ant 没有约定，项目生命周期，它是命令式的。所有操作都要手动去创建、布置。甚至连build.xml 文件都需要手动创建。</li>
</ul>
</li>
</ul>
<h1 id="Maven-仓库是什么"><a href="#Maven-仓库是什么" class="headerlink" title="Maven 仓库是什么"></a>Maven 仓库是什么</h1><ul>
<li>Maven 仓库是基于简单文件系统存储的，集中化管理 Java API 资源（构件）的一个服务</li>
<li>仓库中的任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径</li>
<li>得益于 Maven 的坐标机制，任何 Maven 项目使用任何一个构件的方式都是完全相同的，Maven 可以在某个位置统一存储所有的 Maven 项目共享的构件，这个统一的位置就是仓库，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其它项目使用。</li>
<li>对于 Maven 来说，仓库分为两类：本地仓库和远程仓库。</li>
</ul>
<h1 id="Maven-的工程类型有哪些？"><a href="#Maven-的工程类型有哪些？" class="headerlink" title="Maven 的工程类型有哪些？"></a>Maven 的工程类型有哪些？</h1><h4 id="POM-工程"><a href="#POM-工程" class="headerlink" title="POM 工程"></a>POM 工程</h4><ul>
<li>POM 工程是逻辑工程。用在父级工程或聚合工程中。用来做 jar 包的版本控制。</li>
</ul>
<h4 id="JAR-工程"><a href="#JAR-工程" class="headerlink" title="JAR 工程"></a>JAR 工程</h4><ul>
<li>将会打包成 jar 用作 jar 包使用。即常见的本地工程 - Java Project。</li>
</ul>
<h4 id="WAR-工程"><a href="#WAR-工程" class="headerlink" title="WAR 工程"></a>WAR 工程</h4><ul>
<li>将会打包成 war，发布在服务器上的工程。如网站或服务。即常见的网络工程 -Dynamic Web Project。war 工程默认没有 WEB-INF 目录及 web.xml 配置文件，IDE通常会显示工程错误，提供完整工程结构可以解决。</li>
</ul>
<h1 id="Maven-常用命令有哪些？"><a href="#Maven-常用命令有哪些？" class="headerlink" title="Maven 常用命令有哪些？"></a>Maven 常用命令有哪些？</h1><ul>
<li>install 本地安装， 包含编译，打包，安装到本地仓库<ul>
<li>编译 - javac</li>
<li>打包 - jar， 将 java 代码打包为 jar 文件</li>
<li>安装到本地仓库 - 将打包的 jar 文件，保存到本地仓库目录中。</li>
</ul>
</li>
<li>clean<ul>
<li>清除已编译信息。</li>
<li>删除工程中的 target 目录。</li>
</ul>
</li>
<li>compile<ul>
<li>只编译。 javac 命令</li>
</ul>
</li>
<li>deploy<ul>
<li>部署。 常见于结合私服使用的命令。</li>
<li>相当于是 install+上传 jar 到私服。</li>
<li>包含编译，打包，安装到本地仓库，上传到私服仓库。</li>
</ul>
</li>
<li>package<ul>
<li>打包。 包含编译，打包两个功能。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>日志</title>
    <url>/publishes/193c3be66867.html</url>
    <content><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h4 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h4><ul>
<li>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带的 java.util.logging.Logger 等。</li>
</ul>
<h4 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h4><ul>
<li>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。Log4j 由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。<ul>
<li>Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制</li>
<li>Appenders : 指定了日志将打印到控制台还是文件中</li>
<li>Layout : 控制日志信息的显示格式</li>
</ul>
</li>
<li>Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为 DEBUG、INFO、WARN、ERROR 和 FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码。</li>
</ul>
<h4 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h4><ul>
<li>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。</li>
<li>Logback 主要由三个模块组成：logback-core，logback-classic。logback-access logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的 通用机制。</li>
<li>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J；</li>
<li>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与HTTP 访问相关的功能。</li>
</ul>
<h4 id="Logback-优点"><a href="#Logback-优点" class="headerlink" title="Logback 优点"></a>Logback 优点</h4><ul>
<li>同样的代码路径，Logback 执行更快</li>
<li>更充分的测试</li>
<li>原生实现了 SLF4J API（Log4J 还需要有一个中间转换层）</li>
<li>内容更丰富的文档</li>
<li>支持 XML 或者 Groovy 方式配置</li>
<li>配置文件自动热加载</li>
<li>从 IO 错误中优雅恢复</li>
<li>自动删除日志归档</li>
<li>自动压缩日志成为归档文件</li>
<li>支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件</li>
<li>支持配置文件中加入条件判断来适应不同的环境</li>
<li>更强大的过滤器</li>
<li>支持 SiftingAppender（可筛选 Appender）</li>
<li>异常栈信息带有包信息</li>
</ul>
<h4 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h4><ul>
<li>ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打造大规模日志实时处理系统。<ul>
<li>Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将日志索引并存储起来，方便业务方检索查询。</li>
<li>Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理。</li>
<li>Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方，比如各类饼图、直方图、区域图等。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Slf4j</tag>
        <tag>Log4j</tag>
        <tag>LogBack</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/publishes/39a9c27510d2.html</url>
    <content><![CDATA[<h1 id="您对微服务有何了解？"><a href="#您对微服务有何了解？" class="headerlink" title="您对微服务有何了解？"></a>您对微服务有何了解？</h1><ul>
<li>微服务，又称微服务 架构，是一种架构风格，它将应用程序构建为以业务领域为模型的小型自治服务集合 。</li>
<li>通俗地说，你必须看到蜜蜂如何通过对齐六角形蜡细胞来构建它们的蜂窝状物。</li>
<li>他们最初从使用各种材料的小部分开始，并继续从中构建一个大型蜂箱。这些细胞形成图案，产生坚固的结构，将蜂窝的特定部分固定在一起。这里，每个细胞独立于另一个细胞，但它也与其他细胞相关。这意味着对一个细胞的损害不会损害其他细胞，因此，蜜蜂可以在不影响完整蜂箱的情况下重建这些细胞。这里，每个六边形形状代表单独的服务组件。与蜜蜂的工作类似，每个敏捷团队都使用可用的框架和所选的技术堆栈构建单独的服务组件。就像在蜂箱中一样，每个服务组件形成一个强大的微服务架构，以提供更好的可扩展性。此外，敏捷团队可以单独处理每个服务组件的问题，而对整个应用程序没有影响或影响最小。</li>
</ul>
<h1 id="微服务架构有哪些优势？"><a href="#微服务架构有哪些优势？" class="headerlink" title="微服务架构有哪些优势？"></a>微服务架构有哪些优势？</h1><ul>
<li>独立开发 – 所有微服务都可以根据各自的功能轻松开发</li>
<li>独立部署 – 基于其服务，可以在任何应用程序中单独部署它们</li>
<li>故障隔离 – 即使应用程序的一项服务不起作用，系统仍可继续运行</li>
<li>混合技术堆栈 – 可以使用不同的语言和技术来构建同一应用程序的不同服务</li>
<li>粒度缩放 – 单个组件可根据需要进行缩放，无需将所有组件缩放在一起</li>
</ul>
<h1 id="微服务有哪些特点？"><a href="#微服务有哪些特点？" class="headerlink" title="微服务有哪些特点？"></a>微服务有哪些特点？</h1><ul>
<li>解耦 – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展</li>
<li>组件化 – 微服务被视为可以轻松更换和升级的独立组件</li>
<li>业务能力 – 微服务非常简单，专注于单一功能</li>
<li>自治 – 开发人员和团队可以彼此独立工作，从而提高速度</li>
<li>持续交付 – 通过软件创建，测试和批准的系统自动化，允许频繁发布软件</li>
<li>责任 – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品</li>
<li>分散治理 – 重点是使用正确的工具来做正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</li>
<li>敏捷 – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃</li>
</ul>
<h1 id="微服务架构如何运作？"><a href="#微服务架构如何运作？" class="headerlink" title="微服务架构如何运作？"></a>微服务架构如何运作？</h1><ul>
<li>微服务架构具有以下组件：<ul>
<li>客户端 – 来自不同设备的不同用户发送请求。</li>
<li>身份提供商 – 验证用户或客户身份并颁发安全令牌。</li>
<li>API 网关 – 处理客户端请求。</li>
<li>静态内容 – 容纳系统的所有内容。</li>
<li>管理 – 在节点上平衡服务并识别故障。</li>
<li>服务发现 – 查找微服务之间通信路径的指南。</li>
<li>内容交付网络 – 代理服务器及其数据中心的分布式网络。</li>
<li>远程服务 – 启用驻留在 IT 设备网络上的远程访问信息。</li>
</ul>
</li>
</ul>
<h1 id="单片，SOA-和微服务架构有什么区别？"><a href="#单片，SOA-和微服务架构有什么区别？" class="headerlink" title="单片，SOA 和微服务架构有什么区别？"></a>单片，SOA 和微服务架构有什么区别？</h1><ul>
<li>单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密封装。</li>
<li>一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数据传递，也可以涉及两个或多个协调某些活动的服务。</li>
<li>微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。</li>
</ul>
<h1 id="在使用微服务架构时，您面临哪些挑战？"><a href="#在使用微服务架构时，您面临哪些挑战？" class="headerlink" title="在使用微服务架构时，您面临哪些挑战？"></a>在使用微服务架构时，您面临哪些挑战？</h1><ul>
<li>开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。</li>
<li>自动化组件：难以自动化，因为有许多较小的组件。因此，对于每个组件，我们必须遵循 Build，Deploy 和 Monitor 的各个阶段。</li>
<li>易感性：将大量组件维护在一起变得难以部署，维护，监控和识别问题。它需要在所有组件周围具有很好的感知能力。</li>
<li>配置管理：有时在各种环境中维护组件的配置变得困难。</li>
<li>调试：很难找到错误的每一项服务。维护集中式日志记录和仪表板以调试问题至关重要。</li>
</ul>
<h1 id="什么是无所不在的语言？"><a href="#什么是无所不在的语言？" class="headerlink" title="什么是无所不在的语言？"></a>什么是无所不在的语言？</h1><ul>
<li>如果您必须定义泛在语言（UL），那么它是特定域的开发人员和用户使用的通用语言，通过该语言可以轻松解释域。</li>
<li>无处不在的语言必须非常清晰，以便它将所有团队成员放在同一页面上，并以机器可以理解的方式进行翻译。</li>
</ul>
<h1 id="什么是凝聚力？"><a href="#什么是凝聚力？" class="headerlink" title="什么是凝聚力？"></a>什么是凝聚力？</h1><ul>
<li>模块内部元素所属的程度被认为是凝聚力。</li>
</ul>
<h1 id="什么是耦合？"><a href="#什么是耦合？" class="headerlink" title="什么是耦合？"></a>什么是耦合？</h1><ul>
<li>组件之间依赖关系强度的度量被认为是耦合。一个好的设计总是被认为具有高内聚力和低耦合性。</li>
</ul>
<h1 id="什么是-REST-RESTful-以及它的用途是什么？"><a href="#什么是-REST-RESTful-以及它的用途是什么？" class="headerlink" title="什么是 REST &#x2F; RESTful 以及它的用途是什么？"></a>什么是 REST &#x2F; RESTful 以及它的用途是什么？</h1><ul>
<li>Representational State Transfer（REST）&#x2F; RESTful Web 服务是一种帮助计算机系统通过 Internet 进行通信的架构风格。这使得微服务更容易理解和实现。</li>
<li>微服务可以使用或不使用 RESTful API 实现，但使用 RESTful API 构建松散耦合的微服务总是更容易。</li>
</ul>
<h1 id="什么是-Spring-引导的执行器？"><a href="#什么是-Spring-引导的执行器？" class="headerlink" title="什么是 Spring 引导的执行器？"></a>什么是 Spring 引导的执行器？</h1><ul>
<li>Spring Boot 执行程序提供了 restful Web 服务，以访问生产环境中运行应用程序的当前状态。在执行器的帮助下，您可以检查各种指标并监控您的应用程序。</li>
</ul>
<h1 id="什么是-Spring-Cloud？"><a href="#什么是-Spring-Cloud？" class="headerlink" title="什么是 Spring Cloud？"></a>什么是 Spring Cloud？</h1><p> Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，领导选举，分布式会话，集群状态）。</p>
<h1 id="Spring-Cloud-解决了哪些问题？"><a href="#Spring-Cloud-解决了哪些问题？" class="headerlink" title="Spring Cloud 解决了哪些问题？"></a>Spring Cloud 解决了哪些问题？</h1><ul>
<li>在使用 Spring Boot 开发分布式微服务时，我们面临的问题很少由 Spring Cloud解决。</li>
<li>与分布式系统相关的复杂性 – 包括网络问题，延迟开销，带宽问题，安全问题。</li>
<li>处理服务发现的能力 – 服务发现允许集群中的进程和服务找到彼此并进行通信。</li>
<li>解决冗余问题 – 冗余问题经常发生在分布式系统中。</li>
<li>负载平衡 – 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布。</li>
<li>减少性能问题 – 减少因各种操作开销导致的性能问题。</li>
</ul>
<h1 id="在-Spring-MVC-应用程序中使用-WebMvcTest-注释有什么用处？"><a href="#在-Spring-MVC-应用程序中使用-WebMvcTest-注释有什么用处？" class="headerlink" title="在 Spring MVC 应用程序中使用 WebMvcTest 注释有什么用处？"></a>在 Spring MVC 应用程序中使用 WebMvcTest 注释有什么用处？</h1><ul>
<li>在测试目标只关注 Spring MVC 组件的情况下，WebMvcTest 注释用于单元测试Spring MVC 应用程序。在上面显示的快照中，我们只想启动 ToTestController。</li>
<li>执行此单元测试时，不会启动所有其他控制器和映射。</li>
</ul>
<h1 id="你能否给出关于休息和微服务的要点？"><a href="#你能否给出关于休息和微服务的要点？" class="headerlink" title="你能否给出关于休息和微服务的要点？"></a>你能否给出关于休息和微服务的要点？</h1><ul>
<li>虽然您可以通过多种方式实现微服务，但 REST over HTTP 是实现微服务的一种方式。REST 还可用于其他应用程序，如 Web 应用程序，API 设计和 MVC 应用程序，以提供业务数据。</li>
<li>微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用程序。</li>
<li>简而言之，您可以说 REST 是构建微服务的媒介。</li>
</ul>
<h1 id="什么是不同类型的微服务测试？"><a href="#什么是不同类型的微服务测试？" class="headerlink" title="什么是不同类型的微服务测试？"></a>什么是不同类型的微服务测试？</h1><ul>
<li>在使用微服务时，由于有多个微服务协同工作，测试变得非常复杂。因此，测试分为不同的级别。</li>
<li>在底层，我们有面向技术的测试，如单元测试和性能测试。这些是完全自动化的。</li>
<li>在中间层面，我们进行了诸如压力测试和可用性测试之类的探索性测试。</li>
<li>在顶层， 我们的 验收测试数量很少。这些验收测试有助于利益相关者理解和验证软件功能。</li>
</ul>
<h1 id="您对-Distributed-Transaction-有何了解？"><a href="#您对-Distributed-Transaction-有何了解？" class="headerlink" title="您对 Distributed Transaction 有何了解？"></a>您对 Distributed Transaction 有何了解？</h1><ul>
<li>分布式事务是指单个事件导致两个或多个不能以原子方式提交的单独数据源的突变的任何情况。在微服务的世界中，它变得更加复杂，因为每个服务都是一个工作单元，并且大多数时候多个服务必须协同工作才能使业务成功。</li>
</ul>
<h1 id="什么是-Idempotence-以及它在哪里使用？"><a href="#什么是-Idempotence-以及它在哪里使用？" class="headerlink" title="什么是 Idempotence 以及它在哪里使用？"></a>什么是 Idempotence 以及它在哪里使用？</h1><ul>
<li>幂等性是能够以这样的方式做两次事情的特性，即最终结果将保持不变，即好像它只做了一次。</li>
<li>用法：在远程服务或数据源中使用 Idempotence，这样当它多次接收指令时，它只处理指令一次。</li>
</ul>
<h1 id="什么是有界上下文？"><a href="#什么是有界上下文？" class="headerlink" title="什么是有界上下文？"></a>什么是有界上下文？</h1><ul>
<li>有界上下文是域驱动设计的核心模式。DDD 战略设计部门的重点是处理大型模型和团队。DDD 通过将大型模型划分为不同的有界上下文并明确其相互关系来处理大型模型。</li>
</ul>
<h1 id="什么是双因素身份验证？"><a href="#什么是双因素身份验证？" class="headerlink" title="什么是双因素身份验证？"></a>什么是双因素身份验证？</h1><ul>
<li>双因素身份验证为帐户登录过程启用第二级身份验证。</li>
<li>因此，假设用户必须只输入用户名和密码，那么这被认为是单因素身份验证。</li>
</ul>
<h1 id="什么是客户证书？"><a href="#什么是客户证书？" class="headerlink" title="什么是客户证书？"></a>什么是客户证书？</h1><ul>
<li>客户端系统用于向远程服务器发出经过身份验证的请求的一种数字证书称为客户端证书。客户端证书在许多相互认证设计中起着非常重要的作用，为请求者的身份提供了强有力的保证。</li>
</ul>
<h1 id="PACT-在微服务架构中的用途是什么？"><a href="#PACT-在微服务架构中的用途是什么？" class="headerlink" title="PACT 在微服务架构中的用途是什么？"></a>PACT 在微服务架构中的用途是什么？</h1><ul>
<li>PACT 是一个开源工具，允许测试服务提供者和消费者之间的交互，与合同隔离，从而提高微服务集成的可靠性。</li>
<li>微服务中的用法</li>
<li>用于在微服务中实现消费者驱动的合同。</li>
<li>测试微服务的消费者和提供者之间的消费者驱动的合同。</li>
<li>查看即将到来的批次</li>
</ul>
<h1 id="什么是-OAuth？"><a href="#什么是-OAuth？" class="headerlink" title="什么是 OAuth？"></a>什么是 OAuth？</h1><ul>
<li>OAuth 代表开放授权协议。这允许通过在 HTTP 服务上启用客户端应用程序（例如第三方提供商 Facebook，GitHub 等）来访问资源所有者的资源。因此，您可以在不使用其凭据的情况下与另一个站点共享存储在一个站点上的资源。</li>
</ul>
<h1 id="康威定律是什么？"><a href="#康威定律是什么？" class="headerlink" title="康威定律是什么？"></a>康威定律是什么？</h1><ul>
<li>“任何 设计 系统 的组 织（ 广泛 定义 ）都 将产 生一 种设 计， 其结 构是 组织 通信 结构的副 本。” – Mel Conway</li>
<li>该法律基本上试图传达这样一个事实：为了使软件模块起作用，整个团队应该进行良好的沟通。因此，系统的结构反映了产生它的组织的社会边界。</li>
</ul>
<h1 id="合同测试你懂什么？"><a href="#合同测试你懂什么？" class="headerlink" title="合同测试你懂什么？"></a>合同测试你懂什么？</h1><ul>
<li>根据 Martin Flower 的说法，合同测试是在外部服务边界进行的测试，用于验证其是否符合消费服务预期的合同。</li>
<li>此外，合同测试不会深入测试服务的行为。更确切地说，它测试该服务调用的输入＆输出包含所需的属性和所述响应延迟，吞吐量是允许的限度内。</li>
</ul>
<h1 id="什么是端到端微服务测试？"><a href="#什么是端到端微服务测试？" class="headerlink" title="什么是端到端微服务测试？"></a>什么是端到端微服务测试？</h1><ul>
<li>端到端测试验证了工作流中的每个流程都正常运行。这可确保系统作为一个整体协同工作并满足所有要求。</li>
<li>通俗地说，你可以说端到端测试是一种测试，在特定时期后测试所有东西。</li>
</ul>
<h1 id="Container-在微服务中的用途是什么？"><a href="#Container-在微服务中的用途是什么？" class="headerlink" title="Container 在微服务中的用途是什么？"></a>Container 在微服务中的用途是什么？</h1><ul>
<li>容器是管理基于微服务的应用程序以便单独开发和部署它们的好方法。您可以将微服务封装在容器映像及其依赖项中，然后可以使用它来滚动按需实例的微服务，而无需任何额外的工作。</li>
</ul>
<h1 id="什么是微服务架构中的-DRY？"><a href="#什么是微服务架构中的-DRY？" class="headerlink" title="什么是微服务架构中的 DRY？"></a>什么是微服务架构中的 DRY？</h1><ul>
<li>DRY 代表不要重复自己。它基本上促进了重用代码的概念。这导致开发和共享库，这反过来导致紧密耦合。</li>
</ul>
<h1 id="什么是消费者驱动的合同（CDC）？"><a href="#什么是消费者驱动的合同（CDC）？" class="headerlink" title="什么是消费者驱动的合同（CDC）？"></a>什么是消费者驱动的合同（CDC）？</h1><ul>
<li>这基本上是用于开发微服务的模式，以便它们可以被外部系统使用。当我们处理微服务时，有一个特定的提供者构建它，并且有一个或多个使用微服务的消费者。</li>
<li>通常，提供程序在 XML 文档中指定接口。但在消费者驱动的合同中，每个服务消费者都传达了提供商期望的接口。</li>
</ul>
<h1 id="Web，RESTful-API-在微服务中的作用是什么？"><a href="#Web，RESTful-API-在微服务中的作用是什么？" class="headerlink" title="Web，RESTful API 在微服务中的作用是什么？"></a>Web，RESTful API 在微服务中的作用是什么？</h1><ul>
<li>微服务架构基于一个概念，其中所有服务应该能够彼此交互以构建业务功能。因此，要实现这一点，每个微服务必须具有接口。这使得 Web API 成为微服务的一个非常重要的推动者。RESTful API 基于 Web 的开放网络原则，为构建微服务架构的各个组件之间的接口提供了最合理的模型。</li>
</ul>
<h1 id="您对微服务架构中的语义监控有何了解？"><a href="#您对微服务架构中的语义监控有何了解？" class="headerlink" title="您对微服务架构中的语义监控有何了解？"></a>您对微服务架构中的语义监控有何了解？</h1><ul>
<li>语义监控，也称为 综合监控， 将自动化测试与监控应用程序相结合，以检测业务失败因素。</li>
</ul>
<h1 id="我们如何进行跨功能测试？"><a href="#我们如何进行跨功能测试？" class="headerlink" title="我们如何进行跨功能测试？"></a>我们如何进行跨功能测试？</h1><ul>
<li>跨功能测试是对非功能性需求的验证，即那些无法像普通功能那样实现的需求。</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate</title>
    <url>/publishes/b1378143ed59.html</url>
    <content><![CDATA[<h1 id="介绍一下-Hibernate-的缓存"><a href="#介绍一下-Hibernate-的缓存" class="headerlink" title="介绍一下 Hibernate 的缓存"></a>介绍一下 Hibernate 的缓存</h1><h4 id="为什么要用-Hibernate-缓存？"><a href="#为什么要用-Hibernate-缓存？" class="headerlink" title="为什么要用 Hibernate 缓存？"></a>为什么要用 Hibernate 缓存？</h4><ul>
<li>Hibernate 是一种持久化层框架，经常访问物理数据库。</li>
<li>为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。</li>
<li>为了提高访问速度，把磁盘或者数据库访问变成内存访问</li>
</ul>
<h4 id="Hibernate-缓存原理是怎样的？"><a href="#Hibernate-缓存原理是怎样的？" class="headerlink" title="Hibernate 缓存原理是怎样的？"></a>Hibernate 缓存原理是怎样的？</h4><ul>
<li>Hibernate 缓存包括两大类：Hibernate一级缓存和 Hibernate 二级缓存</li>
</ul>
<h1 id="Hibernate-一级缓存又称为”session-的缓存”。"><a href="#Hibernate-一级缓存又称为”session-的缓存”。" class="headerlink" title="Hibernate 一级缓存又称为”session 的缓存”。"></a>Hibernate 一级缓存又称为”session 的缓存”。</h1><ul>
<li>session 缓存内置不能被卸载，session 的缓存是事务范围的缓存(session 对象的生命周期通常对应一个数据库事务或者一个应用事务)。</li>
<li>一级缓存中，持久化类的每个实例都具有唯一的 OID</li>
</ul>
<h1 id="Hibernate-的二级缓存又称为”sessionFactory-的缓存”。"><a href="#Hibernate-的二级缓存又称为”sessionFactory-的缓存”。" class="headerlink" title="Hibernate 的二级缓存又称为”sessionFactory 的缓存”。"></a>Hibernate 的二级缓存又称为”sessionFactory 的缓存”。</h1><ul>
<li>由于 sessionFactory 对象的生命周期和应用程序的整个过程对应，因此 Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。</li>
<li>第二级缓存是可选的，是一个可配置的插件，默认下 sessionFactory 不会启用这个插件。</li>
<li>什么样的数据适合存放到二级缓存中？<ul>
<li>很少被修改的数据 (帖子的最后回复时间)</li>
<li>经常被查询的数据 (电商的地点)</li>
<li>不是很重要的数据，允许出现偶尔并发的数据</li>
<li>不会被并发访问的数据</li>
<li>常量数据</li>
</ul>
</li>
<li>Hibernate 的二级缓存默认是不支持分布式缓存的，使用 memcache，redis等中央缓存来代替二级缓存</li>
</ul>
<h1 id="Hibernate-对象的状态"><a href="#Hibernate-对象的状态" class="headerlink" title="Hibernate 对象的状态"></a>Hibernate 对象的状态</h1><ul>
<li>临时状态&#x2F;瞬时状态(transient)：刚刚用 new 语句创建，没有被持久化，无 id，不处于 session 中(没有使用 session 的方法去操作临时对象)，该对象成为临时对象持久化状态，</li>
<li>托管状态(persistent)：已经被持久化，加入 session 的缓存中，session是没有关闭该状态的对象为持久化对象。</li>
<li>游离状态，脱管状态(detached)：已经被持久化，但不处于 session 中，该状态的对象为游离对象。</li>
<li>删除状态(removed)：对象有关联的 id，并且在 session 管理下，但是已经被计划(事务提交的时候，commit)删除，如果没有事务就不能删除相互转换</li>
</ul>
<h1 id="Session-的-save-、update-、merge-、lock-、saveOrUpdate-和-persist-方法有什么区别？"><a href="#Session-的-save-、update-、merge-、lock-、saveOrUpdate-和-persist-方法有什么区别？" class="headerlink" title="Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？"></a>Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？</h1><ul>
<li>Hibernate 的对象有三种状态：瞬态、持久态和游离态</li>
<li>游离状态的实例可以通过调用 save()、persist()或者 saveOrUpdate()方法进行持久化；脱管状态的实例可以通过调用 update()、0saveOrUpdate()、lock()或者 replicate()进行持久化</li>
<li>save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()或 merge()会引发 UPDATE 语句</li>
<li>save()和 update()的区别在于一个是将瞬态对象变成持久态，一个是将游离态对象变为持久态。</li>
<li>merge 方法可以完成 save()和 update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象</li>
<li>按照官方文档的说明<ul>
<li>persist()方法把一个瞬态的实例持久化，但是并”不保证”标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到 flush 的时间</li>
<li>persist”保证”，当它在一个事务外部被调用的时候并不触发一个 Insert 语句，当需要封装一个长会话流程的时候，一个 persist 这样的函数是需要的</li>
<li>save”不保证”第 2 条,它要返回标识符，所以它会立即执行 Insert 语句，不管是不是在事务内部还是外部</li>
<li>update()方法是把一个已经更改过的脱管状态的对象变成持久状态</li>
<li>lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。</li>
</ul>
</li>
</ul>
<h1 id="Session-的-load-和-get-方法的区别是什么？"><a href="#Session-的-load-和-get-方法的区别是什么？" class="headerlink" title="Session 的 load 和 get 方法的区别是什么？"></a>Session 的 load 和 get 方法的区别是什么？</h1><ul>
<li>主要有以下三项区别：<ul>
<li>如果没有找到符合条件的记录, get 方法返回 null,load 方法抛出异常</li>
<li>get 方法直接返回实体类对象, load 方法返回实体类对象的代理</li>
<li>在 Hibernate 3 之前，get 方法只在一级缓存(内部缓存)中进行数据查找, 如果没有找到对应的数据则越过二级缓存, 直接发出 SQL 语句完成数据读取; load 方法则可以充分利用二级缓存中的现有数据；当然从 Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的</li>
</ul>
</li>
<li>简单的说，对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过 get()方法去取的数据可以不存在。</li>
</ul>
<h1 id="SessionFactory-是线程安全的吗？Session-是线程安全的吗，两个线程能够共享同一个-Session-吗？"><a href="#SessionFactory-是线程安全的吗？Session-是线程安全的吗，两个线程能够共享同一个-Session-吗？" class="headerlink" title="SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？"></a>SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？</h1><ul>
<li>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将 SessionFactory 通过单例的模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。</li>
<li>Session 是由 SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的 session，可以使用 ThreadLocal 来取得当前的 session，无论你调用多少次 getCurrentSession()方法，返回的都是同一个 session。</li>
</ul>
<h1 id="Hibernate与JDBC的区别"><a href="#Hibernate与JDBC的区别" class="headerlink" title="Hibernate与JDBC的区别"></a>Hibernate与JDBC的区别</h1><ul>
<li>hibernate和jdbc主要区别就是，hibernate先检索缓存中的映射对象( 即hibernate操作的是对象)，而jdbc则是直接操作数据库.</li>
<li>Hibernate是JDBC的轻量级的对象封装，它是一个独立的对象持久层框架。Hibernate可以用在任何JDBC可以使用的场合</li>
<li>Hibernate是一个和JDBC密切关联的框架，所以Hibernate的兼容性和JDBC驱动，和数据库都有一定的关系，但是和使用它的Java程序，和App Server没有任何关系，也不存在兼容性问题。</li>
<li>如果正确的使用JDBC技术,它的执行效率一定比hibernate要好,因为hibernate是基于jdbc的技术.</li>
<li>JDBC使用的是SQL语句，Hibernate使用的是HQL语句，但是HQL语句最终还会隐式转换成SQL语句执行。</li>
</ul>
<h1 id="Hibernate中的两大配置文件"><a href="#Hibernate中的两大配置文件" class="headerlink" title="Hibernate中的两大配置文件"></a>Hibernate中的两大配置文件</h1><ul>
<li>*.hbm.xml：主键生成策略，映射关系，一对多，一对一的关系。</li>
<li>Hibernate.cfg.xml：方言(用哪个数据库)，数据库连接信息，包含*.hbm.xml内容，映射文件，也可以配事务。</li>
</ul>
<h1 id="Hibernate事务处理"><a href="#Hibernate事务处理" class="headerlink" title="Hibernate事务处理"></a>Hibernate事务处理</h1><ul>
<li>开启事务 session.beginTransaction();</li>
<li>执行相关的操作，如果成功则session.getTransaction().commit();</li>
<li>执行操作失败则 session.getTransaction.rollback();</li>
</ul>
<h1 id="Hibernate五大核心（类-接口）简述"><a href="#Hibernate五大核心（类-接口）简述" class="headerlink" title="Hibernate五大核心（类&#x2F;接口）简述"></a>Hibernate五大核心（类&#x2F;接口）简述</h1><ul>
<li>Configuration接口的作用是对Hibernate进行配置，以及对它进行启动。（加载		hibernate.cfg.xml）并创建一个SessionFactory对象。</li>
<li>SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建		Session对象。SessionFactory是线程安全的。</li>
<li>Session接口<ul>
<li>Session（会话）接口是Hibernate应用使用的主要接口。Session接口负责执行被持久化对象的CRUD操作(增删改查)。Session对象是非线程安全的。Session 相当于jdbc的connection</li>
</ul>
</li>
<li>Query与Criteria接口<ul>
<li>总之Query和Criteria接口负责执行各种数据库查询。</li>
</ul>
</li>
<li>Transaction接口<ul>
<li>Transaction（事务）负责操作相关的事务。</li>
</ul>
</li>
</ul>
<h1 id="Hibernate的运行原理"><a href="#Hibernate的运行原理" class="headerlink" title="Hibernate的运行原理"></a>Hibernate的运行原理</h1><ul>
<li>首先通过configuration去加载hibernate.cfg.xml这个配置文件，根据配置文件的信息去创建sessionFactory,sessionFactory是线程安全的，是一个session工厂，用来创建session,session是线程不安全的，相当于jdbc的connection，最后通过session去进行数据库的各种操作，在进行操作的时候通过transaction进行事务的控制。</li>
</ul>
<h1 id="Hibernate、Ibatis、Jdbc三者的区别"><a href="#Hibernate、Ibatis、Jdbc三者的区别" class="headerlink" title="Hibernate、Ibatis、Jdbc三者的区别"></a>Hibernate、Ibatis、Jdbc三者的区别</h1><ul>
<li>Hibernate属于全自动， Ibatis属于半自动，Jdbc属于手动，从开发效率上讲hibernate较高，ibatis居中，jdbc较低，从执行效率上讲hibernate较低，ibatis居中，jdbc较高，因为jdbc是手工写sql语句，程序员对sql的控制能力更大，可以根据业务需要进行优化，而ibatis虽然也可以对sql进行优化，但是他里面将resultset封装为实体的过程中采用了反射机制所以一定程度上影响了性能，而hibernate因为高度封装所以开发效率相对较高，但正因为这个原因，所以程序员在对sql语句的控制和优化方面相对比较弱，而且在将resultset封装成实体的过程中也采用了反射机制，所以在性能方面较低</li>
</ul>
<h1 id="Hibernate-中get-和-load的区别"><a href="#Hibernate-中get-和-load的区别" class="headerlink" title="Hibernate 中get 和 load的区别"></a>Hibernate 中get 和 load的区别</h1><ul>
<li>加载方式：<ul>
<li>load为延迟加载(返回的是一个只有id属性的代理,只有使用该对象属性时,才发出sql语句)；</li>
<li>get为立即加载(执行时,会立即向数据库发出sql语句)</li>
</ul>
</li>
<li>返回结果：<ul>
<li>load检索不到记录时,会抛ObjectNotFoundException异常</li>
<li>get检索不到记录时,会返回null</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/publishes/5352a96111d6.html</url>
    <content><![CDATA[<h1 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h1><ul>
<li>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架</li>
<li>Java反射的主要功能：<ul>
<li>确定一个对象的类</li>
<li>取出类的modifiers,数据成员,方法,构造器,和超类.</li>
<li>找出某个接口里定义的常量和方法说明.</li>
<li>创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).</li>
<li>取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.</li>
<li>在运行时刻调用动态对象的方法.</li>
</ul>
</li>
</ul>
<h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul>
<li>方法名称相同，参数的类型或个数不同</li>
<li>方法名称、参数类型、返回值类型全部相同</li>
<li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li>
<li>范围 发生在一个类中 发生在继承类中</li>
<li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li>
<li>反射的应用很多，很多框架都有用到<ul>
<li>spring 的 ioc&#x2F;di 也是反射…</li>
<li>javaBean和jsp之间调用也是反射…</li>
<li>struts的 FormBean 和页面之间…也是通过反射调用…</li>
<li>JDBC 的 classForName()也是反射…</li>
<li>hibernate的 find(Class clazz) 也是反射…</li>
<li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li>
</ul>
</li>
</ul>
<h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul>
<li>加载JDBC驱动程序</li>
<li>提供JDBC连接的URL</li>
<li>创建数据库的连接</li>
<li>创建一个Statement</li>
<li>执行SQL语句</li>
<li>处理结果</li>
<li>关闭JDBC对象</li>
</ul>
<h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><p>1.hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和<br>containsKey（）方法。<br>2.hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。<br>3.hashMap允许空键值，而hashTable不允许。<br>注意：<br>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状<br>态。<br>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p>
<h1 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h1><p>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是<br>用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过<br>key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象</p>
<h1 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h1><p>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上<br>都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更<br>好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>HashMap 的工作原理及代码实现<br>参考：<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，<br>当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时<br>间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，<br>16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一<br>个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来<br>决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步<br>机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只<br>是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个<br>Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此<br>HashTable已经被淘汰了。</p>
<h1 id="Java中创建线程主要有三种方式："><a href="#Java中创建线程主要有三种方式：" class="headerlink" title="Java中创建线程主要有三种方式："></a>Java中创建线程主要有三种方式：</h1><p>一、继承Thread类创建线程类<br>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完<br>成的任务。因此把run()方法称为执行体。<br>（2）创建Thread子类的实例，即创建了线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。getName()方法返<br>回调用该方法的线程的名字。<br>二、通过Runnable接口创建线程类<br>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是<br>该线程的线程执行体。<br>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该<br>Thread对象才是真正的线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>三、通过Callable和Future创建线程<br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且<br>有返回值。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对<br>象封装了该Callable对象的call()方法的返回值。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<h1 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h1><p>1、sleep()方法<br>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度<br>程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如<br>果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常<br>比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一<br>个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级<br>的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。<br>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的<br>线程有执行的机会。<br>2、yield()方法<br>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方<br>法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态<br>后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也<br>和sleep()方法不同。<br>3、join()方法<br>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，<br>B不能工作。<br>保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有<br>存活，则当前线程不需要停止。<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲<br>突。<br>在Java里，线程安全一般体现在两个方面：<br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关<br>键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有<br>synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，<br>问题就出现了。<br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在<br>java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>volatile 实现原理<br>聊聊并发（一）——深入分析Volatile的实现原理<br>悲观锁 乐观锁<br>乐观锁 悲观锁<br>是一种思想。可以用在很多方面。<br>比如数据库方面。<br>悲观锁就是for update（锁定查询的行）<br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读­<br>比较­写的操作。）<br>JDK方面：<br>悲观锁就是sync<br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。<br>乐观锁就认为，基本没人抢。<br>CAS 乐观锁<br>乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出<br>当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重<br>复读­比较­写的操作。<br>CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。<br>CAS顶多算是乐观锁写那一步操作的一种实现方式罢了，不用CAS自己加锁也是可以的。<br>ABA 问题<br>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A，当前线程的CAS<br>操作无法分辨当前V值是否发生过变化。<br>参考：<br>Java CAS 和ABA问题<br>乐观锁的业务场景及实现方式<br>乐观锁（Optimistic Lock）：<br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，<br>但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不<br>进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，<br>期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可<br>能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量<br>的查询操作，降低了系统的吞吐量。<br>核心篇<br>数据存储<br>MySQL 索引使用的注意事项<br>参考：<br>mysql索引使用技巧及注意事项<br>说说反模式设计<br>参考：<br>每个程序员要注意的 9 种反模式<br>说说分库与分表设计<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策<br>说说 SQL 优化之道<br>sql优化的几种方法<br>微服务哪些框架<br>Spring Cloud、Dubbo、Hsf等<br>你怎么理解 RPC 框架<br>RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这<br>个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。<br>说说 RPC 的实现原理<br>参考：<br>你应该知道的 RPC 原理<br>从零开始实现RPC框架 ­ RPC原理及实现</p>
<p>分布式<br>谈谈业务中使用分布式的场景<br>一、解决java集群的session共享的解决方案：<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>二、分布式事务的解决方案:<br>1.TCC解决方案：try confirm cancel。<br>参考：<br>为什么说传统分布式事务不再适用于微服务架构？<br>Session 分布式方案<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库<br>更多Java技术资料视频分享+QQ2118797017<br>来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>分布式锁的场景<br>比如交易系统的金额修改，同一时间只能又一个人操作，比如秒杀场景，同一时间只能一个<br>用户抢到，比如火车站抢票等等<br>分布式锁的实现方案<br>26. 基于数据库实现分布式锁<br>27. 基于缓存实现分布式锁<br>28. 基于Zookeeper实现分布式锁<br>参考：<br>分布式锁的多种实现方式<br>分布式事务<br>参考：<br>深入理解分布式事务,高并发下分布式事务的解决方案<br>集群与负载均衡的算法与实现<br>参考：<br>负载均衡算法及手段<br>说说分库与分表设计<br>参考：<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>安全&amp;性能<br>安全问题<br>安全要素与 STRIDE 威胁<br>防范常见的 Web 攻击<br>XSS攻击<br>跨站脚本攻击;<br>是什么：攻击者向有XSS漏洞的网站中输入恶意的HTML代码，当其浏览器浏览该网站<br>时，这段HTML代码会自­ ­ 动执行。（理论上所有可以输入的地方没有对输入的数据进<br>行处理，都会存在XSS攻击）;<br>危害： 盗取用户cookie，破坏页面结构，重定向到其他网站;<br>防御：对用户输入的信息进行处理，只允许合法的值;<br>CSRF攻击<br>跨站请求伪造<br>是什么：攻击者盗用了你的身份，以你的名义发送恶意请求;<br>危害：以你的名义发送邮件，盗取帐号，购买东西等;<br>原理： 首先个登录某网站，并在本地生成cookie;然后在不登出的情况下，访问危害网<br>站。<br>防御： 可以从服务端和客户端两方面进行考虑。但是在服务端的效果好。<br>a. 随机的cookie<br>b. 添加验证码<br>c. 不同的表单包含一个不同的伪随机值<br>注意：如果用户在一个站点上同时打开了两个不同的表单。CSRF保护措施不应该影响<br>到他对任何表单的提交<br>SQL注入<br>是什么：通过sql命令伪装成正常的http请求参数，传递到服务端，服务器执行sql命令<br>造成对数据库进行攻击<br>原理：sql语句伪造参数，然后在对参数机型拼接后形成破坏性的sql语句，最后导致数<br>据库收到攻击<br>防御：<br>a. 对参数进行转义<br>b. 数据库中的密码不应明文存储，可以对密码使用md5进行加密。<br>DDOS攻击（分布式拒绝服务攻击）<br>是什么：简单来说就是ifasong大量的请求使服务器瘫痪。<br>被攻击的原因：服务器带宽不足，不能挡住攻击者的攻击流量。<br>防御：<br>a. 最直接的方法就是增加带宽;<br>b. 使用硬件防火墙;<br>c. 优化资源使用提高 web server 的负载能力<br>服务端通信安全攻防<br>HTTPS 原理剖析<br>HTTPS 降级攻击<br>授权与认证<br>基于角色的访问控制<br>基于数据的访问控制<br>基于角色的访问控制，只验证访问数据的角色，但是没有对角色内的用户做细分。举个例<br>子，用户甲与用户乙都具有用一个角色，但是如果只建立基于角色的访问控制，那么用户甲<br>可以对用户乙的数据进行任意操作，从而发生了越权访问。因此，在业务场景中仅仅使用基<br>于角色的访问控制是不够的，还需要引入基于数据的访问控制。如果将基于角色的访问控制<br>视为一种垂直权限控制，那么，基于数据的访问控制就是一种水平权限控制。在业务场景<br>中，往往对基于数据的访问控制不够重视，举个例子，评论功能是一个非常常见的功能，用<br>户可以在客户端发起评论，回复评论，查看评论，删除评论等操作。一般情况下，只有本人<br>才可以删除自己的评论，如果此时，业务层面没有建立数据的访问控制，那么用户甲可以试<br>图绕过客户端，通过调用服务端RESTful API 接口，猜测评论 ID 并修改评论 ID 就可以删除<br>别人的评论。事实上，这是非常严重的越权操作。除此之外，用户之间往往也存在一些私有<br>的数据，而这些私有的数据在正常情况下，只有用户自己才能访问。<br>基于数据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引<br>起重视。这里，再次使用删除评论的案例，通过 Java 语言进行介绍。在这个案例中，核心<br>的代码片段在于，判断当前用户是否是评论的创建者，如果是则通过，不是则报出没有权限<br>的错误码。那么，这样就可以很好地防止数据的越权操作。<br>总结下，基于角色的访问控制是一种垂直权限控制，通过建立用户与角色的对应关系，使得<br>不同角色之间具有高低之分。用户根据拥有的角色进行操作与资源访问。基于数据的访问控<br>制是一种水平权限控制，它对角色内的用户做细分，确保用户的数据不能越权操作。基于数<br>据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引起重<br>视。<br>性能优化<br>性能指标有哪些<br>如何发现性能瓶颈<br>性能调优的常见手段<br>说说你在项目中如何进行性能调优</p>
<p>1.八种基本数据类型的大小，以及他们的封装类<br>double—Double  8位0.0d<br>float —Float   4位0.0f<br>long  —Long8位0L<br>int   —Integer 4位0<br>short —Short   2位(short)0<br>byte  —byte1位(byte)0<br>char  —Character   2位null\u0000<br>boolean   —Boolean  – false<br>2.引用数据类型<br>数组，类，接口<br>3.Switch能否用string做参数<br>以前只能支持byte、short、char、int，可以强转<br>Jdk7.0以后可以，整型、枚举类型、boolean、字符串都可以<br>4.equals与&#x3D;&#x3D;的区别*<br>&#x3D;&#x3D;比较的是2个对象的地址，而equals比较的是2个对象的内容<br>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。<br>Equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。<br>5.自动装箱，常量池<br>自动装箱：基本数据类型对象类型<br>自动拆箱：对象类型基本数据类型<br>常量池：Byte,Short,Integer,Long,Character在自动装箱时对于值从–128到127之间的值（共享），会存在内存中被重用<br>字符串常量池<br>常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s &#x3D; “java”这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。<br>6.Object有哪些公用方法<br>clone(),hashCode(),equals(),notify(),notifyAll(),wait(),getClass(),toString,finalize()<br>8.Hashcode的作用*<br>利用哈希算法，配合基于散列的集合一起正常运行，Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值，降低equals的调用，实现存放的值不会重复。<br>Note:重写equals必须重写hashcode方法，equals相等，hashcode也必须相等。<br>一般对于存放到Set集合或者Map中键值对的元素，需要按需要重写hashCode与equals方法，以保证唯一性！<br>例如hashset存放多个对象，重写equals和hashcode<br>两个对象相等，其HashCode一定相同;<br>两个对象不相等，其HashCode有可能相同;<br>HashCode相同的两个对象，不一定相等;<br>HashCode不相同的两个对象，一定不相等;<br>9.HashMap的hashcode的作用*<br>Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 equals方法可用于保证元素不重复，但是，如果每增加一个元素就检查一次，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次equals方法。这显然会大大降低效率。<br>HashMap的数据结构是 数组+链表形式存储数据，继承AbstractMap，实现Map接口，主要用于查找的快捷性。<br>10.为什么重载hashCode方法？*<br>一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是object对象，必须重载hashCode和equal方法。<br>11.ArrayList、LinkedList、Vector的区别*<br>ArrayList： 线程不安全，数组，适合查找，可自动扩容50%<br>三个构造器，无参，容量，Collection接口，transient Object[] elementData;不被序列化。<br>LinkedList：线程不安全，链表，审核插入，删除<br>Vector：   线程安全，数组，适合查找，可自动扩容100%<br>12.String、StringBuffer与StringBuilder的区别*<br>String 是final修饰的，字符串常量，String对象一旦创建之后该对象是不可更改的<br>StringBuffer 字符串变量，对象可变，线程安全，适合多线程下字符缓冲区大量操作<br>StringBuider 字符串变量，对象可变，线程不安全，适用单线程下载字符缓冲区进行大量操作的情况，都是继承AbstractStringBuilder super.容量为16<br>13.Map、Set、List、Queue、Stack的特点与用法。<br>Map map集合，k-v键值对存储<br>HashTable 和 HashMap 是 Map 的实现类   <br>HashTable 是线程安全的，不能存储 null 值   <br>HashMap 不是线程安全的，可以存储 null 值  <br>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。<br>Set 集合，无序，不重复<br>List 数组集合，ArrayList ， Vector ， LinkedList 是 List 的实现类<br>ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的<br>LinkedList 是线程不安全的，底层是由链表实现的   <br>Queue 队列，提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。<br>Stack 栈，继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。<br>HashMap和HashTable的区别<br>14.JDK7与JDK8中HashMap的实现*<br>JDK8在JDK7的基础上引入了红黑树-b，因为链表过长，会导致效率很低，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率<br>15.HashMap和ConcurrentHashMap的区别，HashMap的底层源码*<br>HashMap是线程不安全的，ConcurrentHashMap是线程安全的，适用于高并发，ConcurrentHashMap就是一个分段的hashtable，根据自定的hashcode算法生成的对象来获取对应hashcode的分段块进行加锁，不用整体加锁，提高了效率。<br>HashMap的get（key）方法是获取key的hash值，计算hash&amp;（n-1）得到在链表数组中的位置first&#x3D;tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可。<br>HashMap的put（key）方法是判断键值对数组tab[]是否为空或位null，否则以默认大小resize()；根据键值key计算hash值得到插入的数组索引i，如果tab[i]&#x3D;&#x3D;null,直接新建节点添加，否则判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可)，分别处理。<br>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比<em>Node.length）重新调整HashMap大小 变为原来2倍大小,扩容很耗时<br>16.ConcurrentHashMap能完全替代HashTable吗？<br>Hash table虽然性能上不如ConcurrentHashMap，但并不能完全被取代，两者的迭代器的一致性不同的，ConcurrentHashMap由于分段锁，弱一致性主要是为了提升效率。<br>强一致性就如hashtable一样，锁整个map。<br>17.为什么HashMap是线程不安全的</em><br>在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，如图中a1、a2，这个时候需要解决碰撞冲突，而解决冲突的办法上面已经说过，对于链表的结构在这里不再赘述，暂且不讨论是从链表头部插入还是从尾部初入，这个时候两个线程如果恰好都取到了对应位置的头结点e1，而最终的结果可想而知，a1、a2两个数据中势必会有一个会丢失<br>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。<br>18.多并发情况下HashMap是否还会产生死循环*<br>不会，jdk1.8版本以后已经没有这个问题了，没有transfer这个函数了do while可能造成的死循环，对原有造成死锁的关键原因点（新table复制在头端添加元素）改进为依次在末端添加新的元素<br>19.TreeMap、HashMap、LindedHashMap的区别*<br>LinkedHashMap可以保证HashMap集合有序。存入的顺序和取出的顺序一致。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。<br>HashMap不保证顺序，即为无序的，具有很快的访问速度。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步。<br>20.Collection包结构，与Collections的区别<br>Collection是个java.util下的接口，它是各种集合结构的父接口。<br>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<br>21.try?catch?finally，try里有return，finally还执行么<br>如果finally没有return 相同返回值变量，则返回try里面的return，否则finally 的return 值会影响 try里面return结果。<br>finally还是会执行的，除非中途遇到jvm退出。<br>22.Excption与Error包结构，OOM你遇到过哪些情况，SOF你遇到过哪些情况<br>都是Throwable的子类，Exception指出了合理的应用程序想要捕获的条件。Error 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件<br>Java Heap 溢出，虚拟机栈和本地方法栈溢出，运行时常量池溢出，方法区溢出<br>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br>23.Java(OOP)面向对象的三个特征与含义<br>封装：可见性封装，setget读写，将类的某些特征隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。<br>继承：子类继承父类，可以得到父类的全部属性和方法（除了父类中的构造方法），java中的多继承可以通过接口来实现。<br>多态：一种是编译时多态，另外一种是运行时多态，编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。<br>26.Static?class?与non?static?class的区别<br>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。<br>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。<br>27.foreach与正常for循环效率对比<br>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。<br>28.Java?IO与NIO*<br>NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I&#x2F;O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征<br>IO是面向流的，NIO是面向块（缓冲区）的。<br>IO是阻塞的，NIO是非阻塞的。<br>多连接，少数据可以用NIO<br>少连接，大数据可以用IO</p>
<h1 id="java反射的作用与原理"><a href="#java反射的作用与原理" class="headerlink" title="java反射的作用与原理"></a>java反射的作用与原理</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>在JAVA中，只有给定类的名字，就可以通过反射机制来获取类的所有信息，可以动态的创建对象和编译。<br>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。</p>
<h1 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h1><p>泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。<br>使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。<br>通过类型擦除来实现</p>
<h1 id="解析XML的几种方式的原理与特点：DOM、SAX"><a href="#解析XML的几种方式的原理与特点：DOM、SAX" class="headerlink" title="解析XML的几种方式的原理与特点：DOM、SAX"></a>解析XML的几种方式的原理与特点：DOM、SAX</h1><p>DOM分析器是把整个XML文档转化为DOM树放在内存中<br>SAX解析采用事件驱动，通过事件处理函数实现对xml文档的访问。</p>
<p>21.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？<br>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>22.Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？<br>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。<br>而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性<br>Put和读取多线程导致的问题。<br>23.ConcurrentHashMap的并发度是什么？*<br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势<br>24.ReentrantReadWriteLock读写锁的使用？<br>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 <br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；<br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！<br>36.高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？*<br>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看： 　　<br>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 　　<br>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换<br>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。<br>39.如果同步块内的线程抛出异常会发生什么？<br>只要退出了synchronized块，无论是正常还是异常，都会释放锁。<br>40.并发编程（concurrency）并行编程（parallellism）有什么区别？*<br>并发（concurrency）和并行（parallellism）是：<br>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>解释三：并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群<br>41.如何保证多线程下 i++ 结果正确？<br>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。<br>42.一个线程如果出现了运行时异常会怎么样?<br>如果该异常被捕获或抛出，则程序继续运行。 <br>如果异常没有被捕获该线程将会停止执行。 <br>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理<br>46.Java中用到的线程调度算法是什么*<br>操作系统的核心，它实际就是一个常驻内存的程序，不断地对线程队列进行扫描，利用特定的算法（时间片轮转法、优先级调度法、多级反馈队列调度法等）找出比当前占有CPU的线程更有CPU使用权的线程，并从之前的线程中收回处理器，再使待运行的线程占用处理器。<br>10.分派：静态分派与动态分派。<br>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的<br>动态分派：（重写）<br>数据结构与算法<br>1.链表与数组。<br>数组：ArrayList—静态分配内存，内存连续。数组元素在栈区。<br>链表：LinkedList—手持下一个人的地址，动态内存分配，内存不连续。数组元素在堆区<br>2.队列和栈，出栈与入栈。<br>queue队列是先进先出<br>入栈，s.push(x)<br>出栈，s.pop()<br>访问栈顶，s.top()<br>判断栈空，s.empty()<br>访问栈中的元素个数，s.size()<br>stack栈是先入后出<br>入队，q.push(x)<br>出队，q.pop()<br>访问队首元素，q.front()、访问队尾元素，q.back()<br>判断队列空，q.empty()<br>访问队列中的元素个数，q.size()<br>3.链表的删除、插入、反向。*<br>数据域，指针域，当前节点<br>删除需要找到上一个节点，然后指向下下节点，size减去1<br>插入，找上一个节点，设置next到新节点，新节点初始化上一节点的current.next<br>反向：head.getnext获取末尾节点，然后以此重新指向反转（递归反转法）<br>遍历反转法，按顺序依次反转。<br>4.字符串操作。<br>(1)字符串的连接<br>public String concat(String str) <br>该方法的参数为一个String类对象,作用是将参数中的字符串str连接到原来字符串的后面. <br>(2)求字符串的长度<br>public int length()<br>返回字串的长度,这里的长度指的是字符串中Unicode字符的数目.<br>(3)求字符串中某一位置的字符<br>public char charAt(int index)<br>该方法在一个特定的位置索引一个字符串,以得到字符串中指定位置的字符.值得注意的是,在字符串中第一个字符的索引是0,第二个字符的索引是1,依次类推,最后一个字符的索引是length()-1. <br>(4)字符串的比较<br>比较字符串可以利用String类提供的下列方法:<br>1)public int compareTo(String anotherString)<br>该方法比较两个字符串,和Character类提供的compareTo方法相似,Character类提供的compareTo方法比较的是两个字符类数据,而这里比较的是字符串数据.<br>其比较过程实际上是两个字符串中相同位置上的字符按Unicode中排列顺序逐个比较的结果.如果在整个比较过程中,没有发现任何不同的地方,则表明两个字符串是完全相等的,compareTo方法返回0;如果在比较过程中,发现了不同的地方,则比较过程会停下来,这时一定是两个字符串在某个位置上不相同,如果当前字符串在这个位置上的字符大于参数中的这个位置上的字符,compareTo方法返回一个大于0的整数,否则返回一个小于0的整数. <br>2)public boolean equals(Object anObject)<br>该方法比较两个字符串,和Character类提供的equals方法相似,因为它们都是重载Object类的方法.该方法比较当前字符串和参数字符串,在两个字符串相等的时候返回true,否则返回false.<br>3)public boolean equalsIgnoreCase(String anotherString)<br>该方法和equals方法相似,不同的地方在于,equalsIgnoreCase方法将忽略字母大小写的区别.<br>(5)从字符串中提取子串<br>利用String类提供的substring方法可以从一个大的字符串中提取一个子串,该方法有两种常用的形式:<br>1)public String substring(int beginIndex)<br>该方法从beginIndex位置起,从当前字符串中取出剩余的字符作为一个新的字符串返回.<br>2)public String substring(int beginIndex, int endIndex)<br>该方法从当前字符串中取出一个子串,该子串从beginIndex位置起至endIndex-1为结束.子串返的长度为endIndex-beginIndex. <br>(6)判断字符串的前缀和后缀<br>判断字符串的前缀是否为指定的字符串利用String类提供的下列方法:<br>1)public boolean startsWith(String prefix)<br>该方法用于判断当前字符串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>2)public boolean startsWith(String prefix, int toffset)<br>该方法用于判断当前字符串从toffset位置开始的子串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>判断字符串的后缀是否为指定的字符串利用String类提供的方法:<br>public boolean endsWith(String suffix)<br>该方法用于判断当前字符串的后缀是否和参数中指定的字符串suffix一致,如果是,返回true,否则返回false.<br>(7)字符串中单个字符的查找<br>字符串中单个字符的查找可以利用String类提供的下列方法:<br>1)public int indexOf(int ch)<br>该方法用于查找当前字符串中某一个特定字符ch出现的位置.该方法从头向后查找,如果在字符串中找到字符ch,则返回字符ch在字符串中第一次出现的位置;如果在整个字符串中没有找到字符ch,则返回-1. <br>2)public int indexOf(int ch, int fromIndex)<br>该方法和第一种方法类似,不同的地方在于,该方法从fromIndex位置向后查找,返回的仍然是字符ch在字符串第一次出现的位置. <br>3)public int lastIndexOf(int ch)<br>该方法和第一种方法类似,不同的地方在于,该方法从字符串的末尾位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>4)public int lastIndexOf(int ch, int fromIndex)<br>该方法和第二种方法类似,不同的地方在于,该方法从fromIndex位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>(8)字符串中子串的查找<br>字符串中子串的查找与字符串中单个字符的查找十分相似,可以利用String类提供的下列方法:<br>1)public int indexOf(String str)<br>2)public int indexOf(String str, int fromIndex)<br>3)public int lastIndexOf(String str)<br>4)public int lastIndexOf(String str, int fromIndex) <br>(9)字符串中字符大小写的转换<br>字符串中字符大小写的转换,可以利用String类提供的下列方法:<br>1)public String toLowerCase()<br>该方法将字符串中所有字符转换成小写,并返回转换后的新串.<br>2)public String toUpperCase()<br>该方法将字符串中所有字符转换成大写,并返回转换后的新串. <br>(10)字符串中多余空格的去除<br>public String trim()<br>该方法只是去掉开头和结尾的空格,并返回得到的新字符串.值得注意的是,在原来字符串中间的空格并不去掉. <br>(11)字符串中字符的替换<br>1)public String replace(char oldChar,char newChar)<br>该方法用字符newChar替换当前字符串中所有的字符oldChar,并返回一个新的字符串.<br>2)public String replaceFirst(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的第一个和字符串regex相一致的子串,并将产生的新字符串返回. <br>3)public String replaceAll(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的所有和字符串regex相一致的子串,并将产生的新字符串返回. <br>字符串变量与StringBuffer类 <br>1.创建StringBuffer类对象<br>StringBuffer类对象表示的是字符串变量,每一个StringBuffer类对象都是可以扩充和修改的字符串变量.以下是常用的StringBuffer类构造函数:<br>(1)public StringBuffer()<br>(2)public StringBuffer(int length) <br>(3)public StringBuffer(String str)  <br>5.Hash表的hash函数，冲突解决方法有哪些。<br>开放定址法或者叫再散列法；<br>1&gt;线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    2&gt;二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    3&gt;伪随机探测再散列：di&#x3D;伪随机序列；<br>再哈希法；<br>拉链法。<br>6.各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。<br>相连元素两两比较，大的往后放，第一次完毕后，最大值就出现在了最大索引处。同理，，继续，即可得到一个排好序的数组。<br>选择排序原理：<br>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i&#x3D;1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>插入排序原理：<br>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>归并排序的原理:<br>从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。<br>快速排序的原理:<br>从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。<br>堆排序的原理:<br>堆排序从小到大排序：首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，再将除了最后一个数的n-1个元素建立成大顶堆，再将最大元素和数组倒数第二个元素进行交换，重复直至堆大小减为1。<br>希尔排序的原理:<br>希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。<br>桶排序的原理:<br>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。<br>7.快排的partition函数与归并的Merge函数。<br>partition函数：双向扫描<br>Merge函数:最后再看每一组（一对）子表的归并，其原理是相同的，只是子表表长不同，换句话说，是子表的首记录号与尾记录号不同，把这个归并操作作为核心算法写成函数 merge <br>8.对冒泡与快排的改进。*<br>8.1 对冒泡的改进<br>    改进1：设置一个标志位，标志位代表在某一个冒泡遍历时候是否发生位置数据的交换，如果没有交换，则表明序列已经排序完成，否则继续排序。减少不必要的遍历。 <br>    改进2：再设置一个标志位，标志位是序列的某个下标，下标之后的代表已经排序完成，下标之前未排序，则遍历大于标志位时，不再遍历。减少一次遍历中已排完序的序列的遍历 <br>    改进3：在一次遍历时，同时找出最大值和最小值，从而提高效率。 <br>参考：排序算法（一）——冒泡排序及改进<br>8.2对快排的改进<br>基准的选取影响快排的效率，一般基准的选取有三种： <br>    1）固定位置。选序列第一位或者最后一位，算法的导论中提到的就是固定选择最后一位。 <br>    2）随机选取。对于序列中部分有序的情况，如果选择固定位置作为基准，会导致全序列都需要交换位置，这会使得效率低下。因此会采用随机选取数据作为基准。 <br>    3）三数取中。最佳划分是将序列划分成等长的两个子序列，因此提出三数取中的思想。取序列中，下标第一位，下标中间一位，下标最后一位的三个数进行排序，取排序结果中排中间的数据作为基准。（此外，也可以取5个数作为数据的基准。） <br>参考：三种快速排序以及快速排序的优化 <br>    针对以上三种情况中，三数取中效果最优，但是依然无法解决序列中出现重复情况，对此进行再次优化： <br>    优化1：当待排序序列的长度分割到一定大小后，使用插入排序。对于很小和部分有序的数组，快排不如插排好。 <br>    优化2：与基准值相同的不加入分割。在每一次分割结束后，可以把与基准相等的元素聚在一起，继续下次分割时，不用再对与基准相等元素分割。减少重复序列的反复分割 <br>    优化3：优化递归操作，快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。 <br>    这里提一下尾递归，如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归。需要说明的是递归调用必须整个函数体中最后执行的语句且它的返回值不属于表达式的一部分。 <br>尾递归的优点： <br>    1）尾递归通过迭代的方式，不存在子问题被多次计算的情况 <br>    2）尾递归的调用发生在方法的末尾，在计算过程中，完全可以把上一次留在堆栈的状态擦掉，保证程序以O(1)的空间复杂度运行。 <br>    可惜的是，在jvm中第二点并没有被优化。 <br>9.二分查找，与变种二分查找。<br>二分查找的中间下标：mid&#x3D;low+0.5∗(high−low)mid&#x3D;low+0.5∗(high−low) <br>    二分+插值： <br>    如果序列长度为1000，查找的关键字在10位置上，则还是需要从500中间开始二分查找，这样会产生多次无效查询，因此优化的方式就是更改分割的比例，采用三分，四分，分割位置：mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key)mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key) <br>    插值查找是根据要查找的关键字的key与查找表中最大最小记录的关键字比较之后的查找算法。 <br>    黄金分割比：用黄金分割比来作为mid值<br>10.二叉树、B+树、AVL树、红黑树、哈夫曼树。<br>二叉树：<br>二叉树的数据结构就不多说了，这里列举一些常见题目 <br>1）求解二叉树的节点 <br>    递归求解： <br>        a) 树为空，节点数为0 <br>        b) 二叉树节点个数 &#x3D; 左子树节点个数 + 右子树节点个数 + 1 <br>2）求二叉树的深度 <br>    递归解法： <br>        a）如果二叉树为空，二叉树的深度为0 <br>        b）如果二叉树不为空，二叉树的深度 &#x3D; max(左子树深度， 右子树深度) + 1 1.  先根遍历，中序遍历，后序遍历 <br>    依然递归求解 <br>4）广度优先 <br>    借助队列。 <br>5）将二叉查找树变为有序的双向链表 <br>    要求不能创建新节点，只调整指针。 <br>    递归解法： <br>        a）如果二叉树查找树为空，对应双向链表的第一个节点和最后一个节点是NULL <br>        b）如果二叉查找树不为空： <br>        设置参数flag，代表父节点与子节点的关系。如果修正的是左子树与父节点的关系，则递归返回的是序列最后的节点。 <br>6)求二叉树第K层的节点个数 <br>    递归解法： <br>        a）如果二叉树为空或者k&lt;1返回0 <br>        b）如果二叉树不为空并且k&#x3D;&#x3D;1，返回1 <br>        c）如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 <br>7)求二叉树中叶子节点的个数 <br>    递归解法： <br>        a）如果二叉树为空，返回0 <br>        b）如果二叉树不为空且左右子树为空，返回1 <br>        c）如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 <br>8)判断二叉树是不是平衡二叉树(AVL树) <br>    递归解法： <br>        a）如果二叉树为空，返回真 <br>        b）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假 <br>9)由前序遍历序列和中序遍历序列重建二叉树 <br>    二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。 <br>    递归解法： <br>        a）如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL; <br>        b）创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树 <br>10)判断是不是完全二叉树<br>11.二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。<br>12.图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。<br>13.KMP算法。<br>14.排列组合问题。<br>15.动态规划、贪心算法、分治算法。（一般不会问到）<br>16.大数据处理：类似10亿条数据找出最大的1000个数………等等<br>17.算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看数据库<br>1.事务四大特性（ACID）原子性、一致性、隔离性、持久性*<br>原子性：是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性: 是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。<br>隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。<br>事务之间的相互影响：脏读，不可重复读，幻读，丢失更新。<br>脏读 意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的<br>不可重复读 意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。<br>   幻读 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.<br>丢失更新 两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。<br>持久性：<br>意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<p>7.索引有B+索引和hash索引，各自的区别<br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。<br>在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。<br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。<br>8.B+索引数据结构，和B树的区别<br>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。<br>根节点至少有两个子节点<br>每个节点有M-1个key，并且以升序排列<br>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>其它节点至少有M&#x2F;2个子节点<br>B+树是对B树的一种变形树，它与B树的差异在于：<br>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</p>
<p>12.关系型数据库和非关系型数据库区别<br>1.关系型数据库通过外键关联来建立表与表之间的关系，<br>2.非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定</p>
<p>15.使用explain优化sql和索引<br>表的读取顺序<br>数据读取操作的操作类型<br>哪些索引可以使用<br>哪些索引被实际使用<br>表之间的引用<br>每张表有多少行被优化器查询<br>说了这么多使用explain的好处,那么实际上到底该怎么玩? 答案： explain + 待执行的sql<br>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化<br>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL<br>all: full table scan ;MySQL将遍历全表以找到匹配的行；<br>index ： index scan; index 和 all的区别在于index类型只遍历索引；<br>range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，&lt; ,&gt;等查询；<br>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；<br>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；<br>const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。<br>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句<br>key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：MySQL认为必须检查的用来返回请求数据的行数<br>Extra：关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。<br>16.long_query怎么解决*<br>慢查询日志：默认情况下，MySQL数据库是不开启慢查询日志的，long_query_time的默认值为10（即10秒，通常设置为1秒），即运行10秒以上的语句是慢查询语句。<br>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。<br>slow_query_log 慢查询开启状态。<br>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。<br>long_query_time 查询超过多少秒才记录。<br>17.内连接、外连接、交叉连接、笛卡儿积等<br>内连接(INNER JOIN)：  <br>    分为三种：等值连接、自然连接、不等连接<br>  <br>外连接(OUTER JOIN)：  <br>    分为三种：  <br>    左外连接(LEFT OUTER JOIN或LEFT JOIN)  <br>    右外连接(RIGHT OUTER JOIN或RIGHT JOIN)  <br>    全外连接(FULL OUTER JOIN或FULL JOIN)  交叉连接(CROSS JOIN)：  <br>    没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积<br>笛卡尔积是两个表每一个字段相互匹配，去掉where 或者inner join的等值 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。内连接: 只连接匹配的行。<br>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。<br>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。<br>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。<br>交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p>
<p>20.mysql并发情况下怎么解决（通过事务、隔离级别、锁）<br>MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。。。。。<br>需求分析：互联网单位 每天大量数据读取，写入，并发性高。<br>现有解决方式：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。<br>集群方案：解决DB宕机带来的单点DB不能访问问题。<br>读写分离策略：极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。<br>21.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）<br>Undo Log<br>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了UndoLog来实现多版本并发控制(简称：MVCC)。<br>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>之所以能同时保证原子性和持久化，是因为以下特点：<br>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。<br>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。<br>Redo Log<br>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。<br>22.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序<br>Join  where  limit  group by  having12.Spring如何解决循环依赖？<br>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。<br>Spring的单例对象的初始化主要分为三步：<br>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>（3）initializeBean：调用spring xml中的init 方法。<br>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。<br>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。<br>13.Spring 如何保证 Controller 并发的安全？*<br>在Controller中使用ThreadLocal变量<br>在spring配置文件Controller中声明 scope&#x3D;”prototype”，每次都创建新的controller<br>在控制器中不使用实例变量7.Netty的高性能表现在哪些方面*<br>异步非阻塞通信<br> Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都 是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。另外，由于Netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。<br>零拷贝<br>    1) Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>       2) Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>       3) Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>内存池<br>     随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty提供了基于内存池的缓冲区重用机制（PooledByteBuf）。<br>高效的Reactor线程模型1.  Reactor单线程模型；<br>       2) Reactor多线程模型；<br>       3) 主从Reactor多线程模型<br>无锁化的串行设计理念<br> 在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。<br>       为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。<br>       Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程 操作导致的锁的竞争，从性能角度看是最优的。<br>高效的并发编程<br>Netty的高效并发编程主要体现在如下几点：<br>       1) volatile的大量、正确使用;<br>       2) CAS和原子类的广泛使用；<br>       3) 线程安全容器的使用；<br>       4) 通过读写锁提升并发性能。<br>高性能的序列化框架<br>影响序列化性能的关键因素总结如下：<br>       1) 序列化后的码流大小（网络带宽的占用）；<br>       2) 序列化&amp;反序列化的性能（CPU资源占用）；<br>       3) 是否支持跨语言（异构系统的对接和开发语言切换）。<br>Netty默认提供了对Google Protobuf的支持，通过扩展Netty的编解码接口，用户可以实现其它的高性能序列化框架，例如Thrift的压缩二进制编解码框架。<br>灵活的TCP参数配置能力<br> 合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和SO_SNDBUF。如果设置不当，对性能的影响是非常大的。下面总结下对性能影响比较大的几个配置项：<br>       1) SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；<br>       2) SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；<br>       3) 软中断：如果Linux内核版本支持RPS（2.6.35以上版本），开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个 hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。<br>Netty在启动辅助类中可以灵活的配置TCP参数，满足不同的用户场景。<br>缓存<br>4.Redis的并发竞争问题如何解决<br>1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。  <br>2.服务器角度，利用setnx实现锁。<br>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。<br>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。<br>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p>
<p>3.Netty是如何使用线程池的，为什么这么使用*<br>EventExecutorGroup 自己实现了Future和submit<br>AbstractEventExecutorGroup，最上层实现的还是Executor接口<br>只不过通过 配置数量，配置线程模型</p>
<p>3.HTTP协议<br>http：+地址+端口+url<br>基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），B&#x2F;C架构<br>HTTP request请求：<br>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>GET说明请求类型为GET,[&#x2F;562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息<br>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<br>第三部分：空行，请求头部后面的空行是必须的<br>即使第四部分的请求数据为空，也必须有空行。<br>第四部分：请求数据也叫主体，可以添加任意的其他数据。<br>这个例子的请求数据为空。<br>HTTP之响应消息Response<br>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文<br>4.TCP协议：面向连接的、可靠的、基于字节流的传输层通信协议<br>IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。<br>简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包<br>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。5.一致性Hash算法*<br>一致性hash作为一个负载均衡算法，可以用在分布式缓存、数据库的分库分表等场景中，还可以应用在负载均衡器中作为作为负载均衡算法。在有多台服务器时，对于某个请求资源通过hash算法，映射到某一个台服务器，当增加或减少一台服务器时，可能会改变这些资源对应的hash值，这样可能导致一部分缓存或数据失效了。一致性hash就是尽可能在将同一个资源请求路由到同一台服务器中。<br>一致性哈希采用的做法如下：引入一个环的概念，如上面的第一个图。先将机器映射到这个环上，再将数据也通过相同的哈希函数映射到这个环上，数据存储在它顺时针走向的那台机器上。以环为中介，实现了数据与机器数目之间的解耦。这样，当机器的数目变化时，只会影响到增加或删除的那台机器所在的环的邻接机器的数据存储，而其他机器上的数据不受影响。</p>
<p>10.HTTP连接池实现原理<br>1、降低延迟：如果不采用连接池，每次连接发起Http请求的时候都会重新建立TCP连接(经历3次握手)，用完就会关闭连接(4次挥手)，如果采用连接池则减少了这部分时间损耗，别小看这几次握手，本人经过测试发现，基本上3倍的时间延迟<br>2、支持更大的并发：如果不采用连接池，每次连接都会打开一个端口，在大并发的情况下系统的端口资源很快就会被用完，导致无法建立新的连接<br>PoolingHttpClientConnectionManager<br>配置请求超时设置—RequestConfig<br>CloseableHttpClient 获取httpClient对象，post，get封装<br>12.数据库的实现原理分布式<br>1.什么是CAP定理<br>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本），换句话就是说，任何时刻，所用的应用程序都能访问得到相同的数据。<br>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性），换句话就是说，任何时候，任何应用程序都可以读写数据。<br>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，换句话说，系统可以跨网络分区线性的伸缩和扩展。<br>2.CAP 理论和 BASE 理论<br>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。<br>基本可用（Basically Available）<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。<br>软状态（ Soft State）<br>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。<br>最终一致性（ Eventual Consistency）<br>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。<br>3.CAP 理论1.  CAP理论<br>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。<br>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。<br>1.1 一致性（Consistency）<br>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。<br>1.2 可用性（Availability）<br>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。<br>1.3 分区容错性（Partition tolerance）<br>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。<br>4.CAP 理论和最终一致性<br>一言以蔽之：过程松，结果紧，最终结果必须保持一致性<br>最终一致性是弱一致性的一种特例。假如A首先write了一个值到存储系统，存储系统保证如果在A,B,C后续读取之前没有其它写操作更新同样的值的话，最终所有的读取操作都会读取到最A写入的最新值。此种情况下，如果没有失败发生的话，“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制技术中replica的个数（这个可以理解为master&#x2F;salve模式中，salve的个数），最终一致性方面最出名的系统可以说是DNS系统，当更新一个域名的IP以后，根据配置策略以及缓存控制策略的不同，最终所有的客户都会看到最新的值<br>5.最终一致性实现方式<br>6.一致性 Hash<br>7.分布式事务，两阶段提交。<br>两阶段提交涉及到多个节点的网络通信,通信时间如果过长,事务的相对时间也就会过长,那么锁定资源的时间也就长了.在高并发的服务中,就会存在严重的性能瓶颈</p>
<p>9.如何实现分布式Session*<br>2.  基于数据库的Session共享<br>3.  基于NFS共享文件系统<br>4.  基于memcached 的session，如何保证 memcached 本身的高可用性？<br>5.  基于resin&#x2F;tomcat web容器本身的session复制机制<br>6.  基于TT&#x2F;Redis 或 jbosscache 进行 session 共享。<br>7.  基于cookie 进行session共享<br>10.如何保证消息的一致性*11.负载均衡<br>负载均衡是高可用网络基础架构的的一个关键组成部分，有了负载均衡，我们通常可以将我们的应用服务器部署多台，然后通过负载均衡将用户的请求分发到不同的服务器用来提高网站、应用、数据库或其他服务的性能以及可靠性<br>12.正向代理（客户端代理）和反向代理（服务器端代理）*<br>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>（1）访问原来无法访问的资源，如google<br>     （2）可以做缓存，加速访问资源<br>　　（3）对客户端访问授权，上网进行认证<br>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息<br>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击<br>（2）负载均衡，通过反向代理服务器来优化网站的负载<br>nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。<br>13.CDN实现原理<br>（1）CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br>（2）大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。<br>CDN即内容分发网络，加速的意思，那么网站CND服务是网站加速服务。<br>CDN加速将网站的内容缓存在网络边缘（离用户接入网络最近的地方），然后在用户访问网站内容的时候，通过调度系统将用户的请求路由或者引导到离用户接入网络最近或者访问效果的缓存服务器上，有该缓存服务器为用户提供内容服务；相对于直接访问源站，这种方式缩短了用户和内容之间的网络距离，从而达到加速的效果<br>14.怎么提升系统的QPS和吞吐量*<br>QPS（TPS）：每秒钟request&#x2F;事务 数量<br>并发数：系统同时处理的request&#x2F;事务数<br>响应时间：一般取平均响应时间<br>简单而言通过增加集群来提升qps和吞吐量<br>实际上要比这个要复杂<br>首先我们需要知道系统的瓶颈<br>我们所知道的系统拓扑架构<br>对于rest接口而言<br>系统设施依次是：<br>dns<br>　　nginx<br>　　　　tomcat<br>　　　　　　db&#x2F;soa<br>首先我们可以通过增加集群来增加qps和吞吐量<br>其次考虑到负载均衡的问题，我们可以通过其他设施来保证集群节点的负载均衡，进一步提高系统qps<br>于是就有nginx集群+负载均衡<br>tomcat集群+负载均衡<br>到db&#x2F;soa这一层的时候，同样也可以通过增加集群+负载均衡的方式来解决<br>我们还可以在每一层增加缓存来应对热点数据<br>然而另外一个方面，可以系统拆分，服务拆分，分别针对瓶颈的系统单独增加集群和负载均衡来解决<br>同样db也可以分库分表，<br>因为单表超过1000万条数据时就很慢了，所以这个时候就需要库拆分，于是就有垂直拆分，水平拆分。　　　<br>异步化，可以不同调用的异步化，使用mq，比如发送短信，发送邮件等<br> <br>综上所述：<br>集群+负载均衡<br>增加缓存<br>系统拆分<br>分库分表<br>垂直拆分+水平拆分<br>异步化+MQ</p>
<p>16.描述一个服务从发布到被消费的详细过程*<br>创建接口服务<br>配置文件配置服务注册中心，配置接口服务<br>启动后，服务提供者启动时，向注册中心注册自己提供的服务，服务消费者在启动时，向注册中心订阅自己所需的服务<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br>17.分布式系统怎么做服务治理服务自动注册<br>客户端自动发现<br>变更下发<br>18.接口的幂等性的概念<br>在数学里，幂等有两种主要的定义：<br>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 即 s <em>s &#x3D; s<br>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) &#x3D; f(x)。<br>HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。如通过PUT接口将数据的Status置为1，无论是第一次执行还是多次执行，获取到的结果应该是相同的，即执行完成之后Status &#x3D;1。<br>orderStatus由0-&gt;1 是需要幂等性的<br>19.消息中间件如何解决消息丢失问题</em><br>消息持久化<br>ACK确认机制<br>设置集群镜像模式<br>1）单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。<br>2）普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。<br>3）镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案<br>消息补偿机制：息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。<br>20.Dubbo的服务请求失败怎么处理<br>因此，将应用拆分，并抽取出核心服务来解决上述问题，还要考虑负载均衡、服务监控、高可用性、服务隔离与降级、路由策略、完善的容错机制、序列化方案的选择、通信框架的选择、开发人员对底层细节无感知、服务升级兼容性等问题。Dubbo满足了以上所有需求。<br>21.重连机制会不会造成错误<br>dubbo在调用服务不成功时，默认会重试2次。<br>Dubbo的路由机制，会把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机制也能一定程度的保证服务的质量。<br>但是如果不合理的配置重试次数，当失败时会进行重试多次，这样在某个时间点出现性能问题，调用方再连续重复调用。<br>系统请求变为正常值的retries倍，系统压力会大增，容易引起服务雪崩，需要根据业务情况规划好如何进行异常处理，何时进行重试。<br>22.对分布式事务的理解<br>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。<br>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交，包括上面提到的消息事务+最终一致性、TCC模式，而完全控制就是完全实现两阶段提交。部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。<br>下单—涉及扣库存和更新订单状态。<br>23.如何实现负载均衡，有哪些算法可以实现？<br>既然要解决后端系统的承载能力：nginx的配置<br>均衡算法主要解决将请求如何发送给后端服务<br>随机（random）、轮训（round-robin）、一致哈希（consistent-hash）和主备（master-slave）。<br>24.Zookeeper的用途，选举的原理是什么？<br>分布式系统基本上都是主从结构，所以需要zookeeper进行协调服务，他做很多事情的，比如命名服务，配置管理，集群管理，分布式协调通知等等<br>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。1.服务器初始化时Leader选举<br>zookeeper由于其自身的性质，一般建议选取奇数个节点进行搭建分布式服务器集群。以3个节点组成的服务器集群为例，说明服务器初始化时的选举过程。启动第一台安装zookeeper的节点时，无法单独进行选举，启动第二台时，两节点之间进行通信，开始选举Leader。1）每个Server投出一票。他们两都选自己为Leader，投票的内容为（SID，ZXID）。SID即Server的id，安装zookeeper时配置文件中所配置的myid；ZXID，事务id，为节点的更新程度，ZXID越大，代表Server对Znode的操作越新。由于服务器初始化，每个Sever上的Znode为0，所以Server1投的票为（1,0），Server2为（2,0）。两Server将各自投票发给集群中其他机器。2）每个Server接收来自其他Server的投票。集群中的每个Server先判断投票有效性，如检查是不是本轮的投票，是不是来Looking状态的服务器投的票。3）对投票结果进行处理。先了解下处理规则</p>
<ul>
<li>首先对比ZXID。ZXID大的服务器优先作为Leader</li>
<li>若ZXID相同，比如初始化的时候，每个Server的ZXID都为0，就会比较myid，myid大的选出来做Leader。对于Server而言，他接受到的投票为（2,0），因为自身的票为（1,0），所以此时它会选举Server2为Leader，将自己的更新为（2,0）。而Server2收到的投票为Server1的（1,0）由于比他自己小，Server2的投票不变。Server1和Server2再次将票投出，投出的票都为（2,0）。4） 统计投票。每次投票之后，服务器都会统计投票信息，如果判定某个Server有过半的票数投它，那么该Server将会作为Leader。对于Server1和Server2而言,统计出已经有两台机器接收了（2,0）的投票信息，此时认为选出了Leader。5）改变服务器状态。当确定了Leader之后，每个Server更新自己的状态，Leader将状态更新为Leading，Follower将状态更新为Following。2.服务器运行期间的Leader选举<br>zookeeper运行期间，如果有新的Server加入，或者非Leader的Server宕机，那么Leader将会同步数据到新Server或者寻找其他备用Server替代宕机的Server。若Leader宕机，此时集群暂停对外服务，开始在内部选举新的Leader。假设当前集群中有Server1、Server2、Server3三台服务器，Server2为当前集群的Leader，由于意外情况，Server2宕机了，便开始进入选举状态。过程如下<br>1） 变更状态。其他的非Observer服务器将自己的状态改变为Looking，开始进入Leader选举。<br>2） 每个Server发出一个投票（myid，ZXID），由于此集群已经运行过，所以每个Server上的ZXID可能不同。假设Server1的ZXID为145，Server3的为122，第一轮投票中，Server1和Server3都投自己，票分别为（1，145）、（3,122）,将自己的票发送给集群中所有机器。<br>3） 每个Server接收接收来自其他Server的投票，降下来的步骤与启动时步骤相同。25.数据的垂直拆分水平拆分。<br>垂直拆分，对于表来说，可以按业务模型进行拆分<br>水平拆分，对于表来说，是分多个票取模存放到不同数据库<br>26.zookeeper原理和适用场景*<br>Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储， Zookeeper 作用主要是用来维护和监控存储的数据的状态变化，通过监控这些数据状态的变化，从而达到基于数据的集群管理<br>简单的说，zookeeper&#x3D;文件系统+通知机制。<br>ZooKeeper以Fast Paxos（帕克索斯）算法为基础，让集群中的每个zk实例数据保持一致。一般部署集群，机器数设置为奇数个，更容易满足&gt;N&#x2F;2的投票条件。<br>Zookeeper应用场景<br>统一命名服务<br>       分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别不同服务。类似于域名与ip之间对应关系，域名容易记住。通过名称来获取资源或服务的地址，提供者等信息按照层次结构组织服务&#x2F;应用名称可将服务名称以及地址信息写到Zookeeper上，客户端通过Zookeeper获取可用服务列表类。<br>配置管理<br>       分布式环境下，配置文件管理和同步是一个常见问题。一个集群中，所有节点的配置信息是一致的，比如Hadoop。对配置文件修改后，希望能够快速同步到各个节点上配置管理可交由Zookeeper实现。可将配置信息写入Zookeeper的一个znode上。各个节点监听这个znode。一旦znode中的数据被修改，zookeeper将通知各个节点。<br>集群管理<br>       分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态作出一些调整。Zookeeper可将节点信息写入Zookeeper的一个znode上。监听这个znode可获取它的实时状态变化。典型应用比如Hbase中Master状态监控与选举。<br>分布式通知&#x2F;协调<br>       分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。例如，NameNode须知道各DataNode的状态，JobTracker须知道各TaskTracker的状态。心跳检测机制和信息推送也是可通过Zookeeper实现。<br>分布式锁<br>       Zookeeper是强一致的。多个客户端同时在Zookeeper上创建相同znode，只有一个创建成功。Zookeeper实现锁的独占性。多个客户端同时在Zookeeper上创建相同znode ，创建成功的那个客户端得到锁，其他客户端等待。Zookeeper 控制锁的时序。各个客户端在某个znode下创建临时znode （类型为CreateMode. EPHEMERAL _SEQUENTIAL），这样，该znode可掌握全局访问时序。<br>分布式队列<br>       两种队列。当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。（可通过分布式锁实现）<br>       同步队列。一个job由多个task组成，只有所有任务完成后，job才运行完成。可为job创建一个&#x2F;job目录，然后在该目录下，为每个完成的task创建一个临时znode，一旦临时节点数目达到task总数，则job运行完成。<br>27.zookeeper watch机制<br>监视是一种简单的机制，使客户端收到关于ZooKeeper集合中的更改的通知。客户端可以在读取特定znode时设置Watches。Watches会向注册的客户端发送任何znode（客户端注册表）更改的通知。<br>Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。<br>28.redis&#x2F;zk节点宕机如何处理*<br>解决方法是连接从服务器，做save操作。将会在从服务器的data目录保存一份从服务器最新的dump.rdb文件。将这份dump.rdb文件拷贝到主服务器的data目录下。再重启主服务器。<br>29.分布式集群下如何做到唯一序列号*<br><a href="http://stor.51cto.com/art/201711/558600.htm">http://stor.51cto.com/art/201711/558600.htm</a><br>1、利用数据库递增，全数据库唯一。<br>优点：明显，可控。<br>缺点：单库单表，数据库压力大。<br>2、UUID， 生成的是length&#x3D;32的16进制格式的字符串，如果回退为byte数组共16个byte元素，即UUID是一个128bit长的数字，一般用16进制表示。<br>优点：对数据库压力减轻了。<br>缺点：但是排序怎么办？<br>此外还有UUID的变种，增加一个时间拼接，但是会造成id非常长。<br>3、twitter在把存储系统从MySQL迁移到Cassandra的过程中由于Cassandra没有顺序ID生成机制，于是自己开发了一套全局唯一ID生成服务：Snowflake。<br>41位的时间序列（精确到毫秒，41位的长度可以使用69年）<br>10位的机器标识（10位的长度最多支持部署1024个节点）<br>12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 最高位是符号位，始终为0。<br>优点：高性能，低延迟；独立的应用；按时间有序。<br>缺点：需要独立的开发和部署。<br>4、Redis生成ID<br>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作INCR和INCRBY来实现。<br>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。<br>30.用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗*<br>可靠消费<br>Redis：没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理<br>RabbitMQ：具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费<br>可靠发布<br>Reids：不提供，需自行实现<br>RabbitMQ：具有发布确认功能，保证消息被发布到服务器<br>高可用<br>Redis：采用主从模式，读写分离，但是故障转移还没有非常完善的官方解决方案<br>RabbitMQ：集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作<br>持久化<br>Redis：将整个Redis实例持久化到磁盘<br>RabbitMQ：队列，消息，都可以选择是否持久化<br>消费者负载均衡<br>Redis：不提供，需自行实现<br>RabbitMQ：根据消费者情况，进行消息的均衡分发<br>队列监控<br>Redis：不提供，需自行实现<br>RabbitMQ：后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）<br>流量控制<br>Redis：不提供，需自行实现<br>RabbitMQ：服务器过载的情况，对生产者速率会进行限制，保证服务可靠性<br>kafka，<br>activemq，<br>RocketMQ<br>31.MQ系统的数据如何保证不丢失<br>32.列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询<br>１、中间变量　＝ user_id%（库数量*每个库的表数量）;<br>２、库序号　＝　取整（中间变量／每个库的表数量）;<br>３、表序号　＝　中间变量％每个库的表数量;<br>Join连表查询，或者多sql查询系统架构<br>1.如何搭建一个高可用系统<br>容灾<br>集群<br>主备<br>熔断<br>限流<br>监控<br>降级<br>日志<br>分库分表<br>读写分离<br>Nginx反向代理<br>CDN加速<br>SSD硬盘持久化<br>自动备份<br>2.哪些设计模式可以增加系统的可扩展性<br>工厂模式<br>抽象工厂模式<br>观察者模式：很方便增加观察者，方便系统扩展<br>模板方法模式：很方便的实现不稳定的扩展点，完成功能的重用<br>适配器模式：可以很方便地对适配其他接口<br>代理模式：可以很方便在原来功能的基础上增加功能或者逻辑<br>责任链模式：可以很方便得增加拦截器&#x2F;过滤器实现对数据的处理，比如struts2的责任链<br>策略模式：通过新增策略从而改变原来的执行策略<br>3.介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。5.什么是高内聚低耦合，请举例子如何实现*<br>同一类功能放一块，如utils包，但是各个模块功能不依赖关联，这就是低耦合<br>接口、继承、多态也是低耦合的实现<br>6.什么情况用接口，什么情况用消息<br>接口的特点是同步调用，接口实时响应，阻塞等待<br>消息的特点是异步处理，非实时响应，消息发送后则返回，消息队列可以削峰<br>一般对实时性要求比较高的功能采用接口<br>对实时性要求不高的功能可以采用消息，削峰时可以采用消息<br>7.如果AB两个系统互相依赖，如何解除依赖*<br>A—&gt;B，同时B—&gt;A<br>解除这种双向依赖的话，需要在AB之外增加一个C，用C封装A依赖的B的那部分功能，让A改为依赖C，C依赖B<br>然后就是这样<br>A—&gt;C，C—-&gt;B，B—&gt;A<br>不过这样依然存在环路依赖<br>8.如何写一篇设计文档，目录是什么<br>基于此我认为主要会分为8个部分。分别为 项目背景，项目目标，需求分析，方案对比，概要设计，详细设计（存储模型设计，接口设计），开发以及上线计划，方案排期。<br>9.什么场景应该拆分系统，什么场景应该合并系统<br>拆分系统：<br>当系统通过集群的方式已经无法解决性能问题的时候，或者业务扩展到很大的时候，需要把拆分系统<br>按照业务的方式垂直拆分：将业务功能结合比较紧密的部分拆分成独立的系统，独立维护<br>按照性能瓶颈点拆分：将系统性能瓶颈点拆分出一个独立的系统，可以针对这个独立的系统集群部署，增加可伸缩性，提高系统整体的性能<br>合并系统：<br>或者系统间通过跨进程访问的性能损耗过高，可以将系统合并成一个系统，减少跨进程访问的消耗<br>10.系统和模块的区别，分别在什么场景下使用<br>系统和模块<br>系统是一个完整功能的系统，拥有独立的访问方式，和部署方式，拥有完整的生命周期，系统由模块组成<br>模块是系统的组成部分，不能单独工作，需要依附于系统才能发挥作用，通常是解决一定场景下的问题<br>系统用于系统性解决问题的方案<br>模块是针对单个问题方面的解决方案<br>11.实战能力<br>12.有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。<br>13.开发中有没有遇到什么技术问题？如何解决的<br>14.如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。<br>15.新浪微博是如何实现把微博推给订阅者<br>16.Google是如何在一秒内把搜索结果返回给用户的。<br>17.12306网站的订票系统如何实现，如何保证不会票不被超卖。<br>18.如何实现一个秒杀系统，保证只有几位用户能买到某件商品。<br>设计这个系统是一个考虑全面的问题，可以发散出很多问题，考察很多方面，不是仅仅回答通过redis的自减操作完成<br>比如简单的方案：<br>1，页面开启倒计时，要保证不能把下单接口暴露过早暴露出来，防止机器刷下单接口<br>2，前端限流，比如nginx对下单接口限流，命中限流则返回302到秒杀页<br>3，后端单独部署，独立域名和nginx，与线上正常运行的系统隔离开来，避免影响到线上环境<br>4，由于生成订单操作比较耗时，采用队列的方式来解耦下单成功和生成订单，针对进入后端的请求，采用redis自减，针对自减结果&gt;0的请求则认为下单成功，触发一个生成订单的消息，然后立即返回给用户结果<br>5，用户方面，针对秒杀成功有两种处理方式<br>　　a，用户端收到秒杀成功的结果，则开启提示页面，并进入倒计时，倒计时时间为订单生成的预估时间<br>　　b，秒杀成功后，给当前用户在redis中生成一个订单生成状态的标识，用户端开启提示页面，loading，并轮询后端订单生成状态，生成成功之后让前端跳转到订单页面<br>6，订单服务订阅下单系统发送的消息，并开始生成订单，生成订单成功之后更新redis中用户秒杀订单的状态为已生成订单</li>
</ul>
<p> <br>系统应该有页面和接口<br>页面用于展示用户界面，接口用于获取数据<br>界面：秒杀页面，秒杀成功页面，秒杀失败页面，命中限流页面（查看订单页面不算秒杀系统的功能）<br>接口：秒杀下单接口，秒杀成功获取订单生成状态接口TCP&#x2F;IP<br>1.OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议。*<br>OSI模型—应用层，表示层，回话层，传输层，网络层，数据链路层，物理层<br>1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 <br>2.数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 <br>3.网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 <br>4.传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 <br>5.会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） <br>6.表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 <br>7.应用层： 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。2.TCP与UDP的区别。*<br>TCP(Transmission Control Protocol)：传输控制协议<br>UDP(User Datagram Protocol)：用户数据报协议<br>TCP是面向连接的、可靠的、有序的、速度慢的协议；<br>UDP是无连接的、不可靠的、无序的、速度快的协议。<br>TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。<br>TCP无界有拥塞控制，UDP有界无拥塞控制。3.TCP报文结构。<br>1、端口号：用来标识同一台计算机的不同的应用进程。<br>1）源端口：源端口和IP地址的作用是标识报文的返回地址。<br>2）目的端口：端口指明接收方计算机上的应用程序接口。<br>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。<br>2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。<br>3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32&#x2F;8 &#x3D; 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。<br>4、保留：为将来定义新的用途保留，现在一般置0。<br>5、控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。<br>1）URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。<br>2）ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。<br>3）PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。<br>4）RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。<br>5）SYN：同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。<br>6）FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。<br>6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。<br>7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。<br>8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。<br>9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。<br>10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。<br>4.TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。<br>5.TCP拥塞控制。<br>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或者链路不会导致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制<br>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。<br>（1）在通信子网出现过多数据包的情况，使得网络的性能下降，甚至不能正常工作，这种现象就称为拥塞。<br>（2）网络拥塞的成因主要有三：1、处理器的速度太慢。2、线路容量的限制。3、节点输出包的能力小于输入包的能力。<br>（3）拥塞控制与流量控制是相关的，流量控制在数据链路层对一条通信路径上的流量进行控制，其的是保证发送者的发送速度不超过接收者的接收速度，它只涉及一全发送者和一个接收者，是局部控制。拥塞控制是对整个通信子网的流量进行控制，其目的是保证通信子网中的流量与其资源相匹配，使子网不会出现性能下降和恶化、甚至崩溃，是全局控制。<br>（4）拥塞控制的最终目标是：1、防止由于过载而使吞吐量下降，损失效率；2、合理分配网络资源；3、避免死锁；4、匹配传输速度。<br>（5）对拥塞控制，可用的方法有两类：开环控制和闭环控制。<br>1、开环控制的思想是通过良好的设计避免拥塞问题的出现，确保拥塞问题在开始时就不可能发生。开环控制方法包括何时接受新的通信何时丢弃包、丢弃哪些包。其特点是在作出决定时不考虑网络当前的状态。<br>2、闭环控制的思想是反馈控制。即通过将网络工作的动态信息反馈给网络中节点的有关进程，节点根据网络当前的动态信息，调整转发数据包的策略。闭环控制过程包括三部分： ①监视系统  检测网络发生或将要发生拥塞的时间和地点。②报告  将监视中检测到的信息传送到可以进行拥塞控制的节点。③决策  调整系统的操作行为，以解决问题。<br>（6）对应于开环控制的方法有：（基于拥塞预防）<br>1、预定缓冲区 2、合理分配缓冲区 3、通信量整形法（A、许可证算法，B、漏桶算法，C、令牌漏桶算法。）<br>对应于闭环控制的方法有：（基于拥塞抑制，即拥塞出现或即将出现时采取适当的措施进行控制，直到消除拥塞）<br>1、阻塞包法。 2、负载丢弃法<br>6.TCP滑动窗口与回退N针协议。<br>7.Http的报文结构。<br>（1）HTTP请求报文<br>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。（2）HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。<br>8.Http的状态码含义。<br>1xx: 信息<br>消息：	描述：<br>100 Continue	服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。<br>101 Switching Protocols	服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。<br>103 Checkpoint	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>2xx: 成功<br>消息：	描述：<br>200 OK	请求成功（这是对HTTP请求成功的标准应答。）<br>201 Created	请求被创建完成，同时新的资源被创建。<br>202 Accepted	供处理的请求已被接受，但是处理未完成。<br>203 Non-Authoritative Information	请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。<br>204 No Content	请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br>205 Reset Content	请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。<br>206 Partial Content	客户发送了一个带有Range头的GET请求，服务器完成了它。<br>3xx: 重定向<br>消息：	描述：<br>300 Multiple Choices	多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。<br>301 Moved Permanently	所请求的页面已经转移至新的 URL 。<br>302 Found	所请求的页面已经临时转移至新的 URL 。<br>303 See Other	所请求的页面可在别的 URL 下被找到。<br>304 Not Modified	未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br>305 Use Proxy	客户请求的文档应该通过Location头所指明的代理服务器提取。<br>306 Switch Proxy	目前已不再使用，但是代码依然被保留。<br>307 Temporary Redirect	被请求的页面已经临时移至新的 URL 。<br>308 Resume Incomplete	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>4xx: 客户端错误<br>消息：	描述：<br>400 Bad Request	因为语法错误，服务器未能理解请求。<br>401 Unauthorized	合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。<br>402 Payment Required	此代码尚无法使用。<br>403 Forbidden	合法请求，但对被请求页面的访问被禁止。<br>404 Not Found	服务器无法找到被请求的页面。<br>405 Method Not Allowed	请求中指定的方法不被允许。<br>406 Not Acceptable	服务器生成的响应无法被客户端所接受。<br>407 Proxy Authentication Required	用户必须首先使用代理服务器进行验证，这样请求才会被处理。<br>408 Request Timeout	请求超出了服务器的等待时间。<br>409 Conflict	由于冲突，请求无法被完成。<br>410 Gone	被请求的页面不可用。<br>411 Length Required	“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。<br>412 Precondition Failed	请求中的前提条件被服务器评估为失败。<br>413 Request Entity Too Large	由于所请求的实体太大，服务器不会接受请求。<br>414 Request-URI Too Long	由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。<br>415 Unsupported Media Type	由于媒介类型不被支持，服务器不会接受请求。<br>416 Requested Range Not Satisfiable	客户端请求部分文档，但是服务器不能提供被请求的部分。<br>417 Expectation Failed	服务器不能满足客户在请求中指定的请求头。<br>5xx: 服务器错误<br>消息：	描述：<br>500 Internal Server Error	请求未完成。服务器遇到不可预知的情况。<br>501 Not Implemented	请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。<br>502 Bad Gateway	请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。<br>503 Service Unavailable	服务器当前不可用（过载或者当机）。<br>504 Gateway Timeout	网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。<br>505 HTTP Version Not Supported	服务器不支持请求中指明的HTTP协议版本。<br>511 Network Authentication Required	用户需要提供身份验证来获取网络访问入口。9.Http?request的几种类型。*<br>1.  OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’<em>‘的请求来测试服务器的功能性。<br>2.  HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>3.  GET：向特定的资源发出请求。<br>4.  POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>5.  PUT：向指定资源位置上传其最新内容。<br>6.  DELETE：请求服务器删除Request-URI所标识的资源。<br>7.  TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>8.  CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>10.Http1.1和Http1.0的区别</em><br>长连接<br>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。<br>HTTP是基于TCP&#x2F;IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。<br>节约带宽<br>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。<br>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。<br>HOST域<br>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。<br>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。<br>11.Http怎么处理长连接。*<br>在HTTP1.0和HTTP1.1协议中都有对长连接的支持。其中HTTP1.0需要在request中增加Connection： keep-alive header才能够支持，而HTTP1.1默认支持。<br>http1.0请求与服务端的交互过程:<br>（1）客户端发出带有包含一个header：”Connection： keep-alive“的请求<br>（2）服务端接收到这个请求后,根据http1.0和”Connection： keep-alive“判断出这是一个长连接,就会在response的header中也增加”Connection： keep-alive“，同时不会关闭已建立的tcp连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>http1.1请求与服务端的交互过程:<br>（1）客户端发出http1.1的请求<br>（2）服务端收到http1.1后就认为这是一个长连接,会在返回的response设置Connection： keep-alive,同时不会关闭已建立的连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>基于http协议的长连接减少了请求,减少了建立连接的时间,但是每次交互都是由客户端发起的,客户端发送消息,服务端才能返回客户端消息。<br>12.Cookie与Session的作用于原理。<br>1.1 Cookie机制<br>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。<br>而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。<br>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。<br>1.2 Session机制<br>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。<br>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。<br>Java Web规范支持通过配置的方式禁用Cookie。下面举例说一下怎样通过配置禁止使用Cookie，可以使用重定向url。 <br>cookie数据保存在客户端，session数据保存在服务器端 <br>第一次请求服务器，生成session和sessionID，sessionID用cookie保存 <br>第二次请求服务器，携带seesionID，服务器从请求中取出sessionID<br>13.电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。<br>应用层：<br>连接：当我们输入一个url请求时，首先要建立socket连接，因为socket是通过ip和端口建立的，所有有一个DNS解析的过程，首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。现在已经拥有了目标ip和端口号，这样我们就可以打开socket连接了。<br>请求：连接成功建立后，开始向web服务器发送请求，这个请求一般是GET或POST命令（POST用于FORM参数的传递）。GET命令的格式为：　　GET 路径&#x2F;文件名 HTTP&#x2F;1.0<br>文件名指出所访问的文件，HTTP&#x2F;1.0指出Web浏览器使用的HTTP版本。现在可以发送GET命令：<br>GET &#x2F;mytest&#x2F;index.html HTTP&#x2F;1.0，<br>应用层：<br>1. DNS（53）：<br>我们输入的是一个URL需要转化成IP地址。首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。1.  HTTP（80）<br>HTTP协议的主要职责是生成针对目标web服务器的http请求报文（请求行、请求头部）<br>传输层<br>2.  TCP<br>将http请求报文分割成报文段，按序号分为多个报文段。（三次握手）<br>网络层<br>3.  IP<br>搜索目标的地址，一边中转一边传送。（路由）<br>4.  ARP<br>因为最终都要在数据链路层上进行传输，而数据链路层并不认识IP地址，所以ARP的职责就是把IP地址转换成数据链路层认识的MAC地址。<br>通过数据链路层到达目标机器之后<br>网络层<br>5.  RARP<br>这其实是ARP的逆过程，将MAC地址转换成Ip地址<br>传输层<br>6.  TCP<br>将接收到的报文段按序号进行重组。<br>应用层<br>7.  HTTP<br>14.Ping的整个过程。ICMP报文是什么。<br>ICMP（网际控制报文协议）：用来测试网络层是不是有故障，若有故障，该协议还能报告故障。Ping命令来使用这个协议<br>15.C&#x2F;S模式下使用socket通信，几个关键函数。*<br>client ： socket（ip，端口）<br>socket.close();<br>server：serversocket（端口）<br>socket &#x3D; server.accept()<br>16.IP地址分类。<br>IP地址分类（A类 B类 C类 D类 E类）<br>     IP地址由四段组成，每个字段是一个字节，8位，最大值是255，,<br>     IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。<br>  IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。<br>     IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。    全0和全1的都保留不用。<br>     A类：（1.0.0.0-126.0.0.0）（默认子网掩码：255.0.0.0或 0xFF000000）<br>     第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1<del>126之间。<br>     一般用于大型网络。<br>     B类：（128.1.0.0-191.255.0.0）（默认子网掩码：255.255.0.0或0xFFFF0000）<br>     前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128</del>191之间。<br>     一般用于中等规模网络。<br>     C类：（192.0.1.0-223.255.255.0）（子网掩码：255.255.255.0或 0xFFFFFF00）<br>     前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192<del>223之间。<br>     一般用于小型网络。<br>    D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224</del>239之间。一般用于多路广播用户[1]  。<br>    E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。<br>  回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。 <br>       一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP&#x2F;IP是否正常。<br>17.路由器与交换机区别。<br>一、工作所在的OSI层次不一样（根本区别，导致接下来的区别） <br>交换机工作在 OSI模型的数据链路层，所以工作原理比较简单； <br>路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。<br>二、数据转发所依据的对象也不一样。 <br>交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。 <br>路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。<br>三、是否可以分割广播域 <br>由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵； <br>连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。<br>18.网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。<br>19.推荐书籍：《TCP&#x2F;IP协议族》1．JDK,JRE,JVM(掌握)<br>(1)JVM<br>保证Java语言跨平台。针对不同的操心系统提供不同的JVM。<br>问题：java语言是跨平台的吗?JVM是跨平台的吗?<br>(2)JRE<br>java程序的运行环境。包括JVM和核心类库<br>(3)JDK<br>java开发环境。包括JRE和开发工具(javac,java)<br>(4)一个Java程序的开发流程<br>A:编写Java源程序<br>B:通过javac命令编译java程序，生成字节码文件<br>C:通过java命令运行字节码文件<br>2．主从数据库切换<br>一般使用多个dataSource，然后创建多个SessionFactory，入侵明显，修改多，session处理比较麻烦。<br>合适的方案使用AbstractRoutingDataSource实现类通过AOP或者手动处理实现动态使用我们的数据源，入侵低。determineTargetDataSource –<br>determineCurrentLookupKey<br>Why：如果主库故障，可以切换从库<br>Why：针对与mysql，怎么保证主从同步，怎么通知代码切换1.  Bean获取它所在的Spring容器，可以让该Bean实现ApplicationContextAware接口，Bean获取它所在的Spring容器，可以通过这个上下文环境对象得到Spring容器中的Bean。<br>Why：针对于非web项目的spring2.  ehcache:<br>String：字符串常量  每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉，<br>　　　StringBuffer：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>　　　StringBuilder：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>String 字符串常量 线程安全  操作少量数据<br>StringBuffer 字符串变量 线程安全 操作大量数据 速度慢  多线程适合用<br>StringBuilder 字符串变量  线程不安全  操作大量数据  速度快  单线程适合用<br>String str &#x3D; new String(“xyz”);创建了几个对象。<br>如果String常量池中，已经创建了”xyz”,则不会继续创建，此时只创建了一个对象new String(“xyz”);<br>如果String常量池中没有创建”xyz”,则会创建两个对象，一个对象的值是”xyz”,一个对象是new String(“xyz”);<br>6．关系型数据库和非关系型数据库种类和关系<br>数据库<br>类型	特性	优点	缺点<br>关系型数据库<br>SQLite、Oracle、mysql	1、关系型数据库，是指采用了关系模型来组织<br>数据的数据库；<br>2、关系型数据库的最大特点就是事务的一致性；<br>3、简单来说，关系模型指的就是二维表格模型，<br>而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。	1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。	1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、高并发读写需求；<br>4、海量数据的高效率读写；<br>非关系型数据库<br>MongoDb、redis、HBase	1、使用键值对存储数据；<br>2、分布式；<br>3、一般不支持ACID特性；<br>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。	1、无需经过sql层的解析，读写性能很高；<br>2、基于键值对，数据没有耦合性，容易扩展；<br>3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。	1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理，附加功能bi和报表等支持也不好；4.  Vector ,ArrayList 和LinkedList的区别？<br>  1、Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。<br>  2、Vector线程同步，ArrayList、LinkedList线程不同步。<br>  3、LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。<br>  4、ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省。8.注解<br>登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。9.反射<br>反射就是把java类中的各种成分映射成一个个的Java对象<br>可以获取类的相关信息，可以进行设置，可以代理<br>spring 的 ioc&#x2F;di 也是反射….<br>javaBean和jsp之间调用也是反射….<br>struts的 FormBean 和页面之间…也是通过反射调用….<br>JDBC 的 classForName()也是反射…..<br>hibernate的 find(Class clazz) 也是反射….<br>10.加载器11.ajax<br>运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换；2.  statement<br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>3.  数据库基础查询<br>1、 加载JDBC驱动程序： <br>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机）， <br>这通过java.lang.Class类的静态方法forName(String className)实现。 <br>例如：<br>try{<br>&#x2F;&#x2F;加载MySql的驱动类<br>Class.forName(“com.mysql.jdbc.Driver”) ;<br>}catch(ClassNotFoundException e){<br>System.out.println(“找不到驱动程序类 ，加载驱动失败！”);<br>e.printStackTrace() ;<br>}<br>成功加载后，会将Driver类的实例注册到DriverManager类中。<br>2、 提供JDBC连接的URL *   连接URL定义了连接数据库时的协议、子协议、数据源标识。 </p>
<ul>
<li>书写形式：协议：子协议：数据源标识<br>协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。 <br>数据源标识：标记找到数据库来源的地址与连接端口。 <br>例如： <br>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;gbk;useUnicode&#x3D;true;（MySql的连接URL） <br>表示使用Unicode字符集。如果characterEncoding设置为 gb2312或GBK，本参数必须设置为true 。characterEncoding&#x3D;gbk：字符编码方式。<br>3、创建数据库的连接 </li>
<li>要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。 </li>
<li>使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。<br>例如： &#x2F;&#x2F;连接MySql数据库，用户名和密码都是root<br>String url &#x3D; “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test” ;<br>String username &#x3D; “root” ;<br>String password &#x3D; “root” ;<br>try{<br>Connection con &#x3D; DriverManager.getConnection(url , username , password ) ;<br>}catch(SQLException se){<br>System.out.println(“数据库连接失败！”);<br>se.printStackTrace() ;<br>}<br>4、 创建一个Statement <br>•要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型： <br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>具体的实现方式： <br>Statement stmt &#x3D; con.createStatement() ; PreparedStatement pstmt &#x3D; con.prepareStatement(sql) ; CallableStatement cstmt &#x3D; con.prepareCall(“{CALL demoSp(? , ?)}”) ; <br>5、执行SQL语句 <br>Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute <br>1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。 <br>2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等 <br>3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码： <br>ResultSet rs &#x3D; stmt.executeQuery(“SELECT * FROM …”) ; int rows &#x3D; stmt.executeUpdate(“INSERT INTO …”) ; boolean flag &#x3D; stmt.execute(String sql) ; <br>6、处理结果 <br>两种情况： <br>1、执行更新返回的是本次操作影响到的记录数。 <br>2、执行查询返回的结果是一个ResultSet对象。 <br>• ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些 行中数据的访问。 <br>• 使用结果集（ResultSet）对象的访问方法获取数据： <br>while(rs.next()){ <br>String name &#x3D; rs.getString(“name”) ; <br>String pass &#x3D; rs.getString(1) ; &#x2F;&#x2F; 此方法比较高效 <br>} <br>（列是从左到右编号的，并且从列1开始）<br>7、关闭JDBC对象 <br>操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反： <br>1、关闭记录集 <br>2、关闭声明 <br>3、关闭连接对象</li>
</ul>
<p>17.使用Spring框架的好处是什么？<br>  轻量：Spring 是轻量的，基本的版本大约2MB。<br>  控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>  容器：Spring 包含并管理应用中对象的生命周期和配置。<br>  MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br>  事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br>  异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。1.  ~8等于多少？8&gt;&gt;&gt;2等于多少？<br>第一个答案是-9，第二个答案是2，无符号右移高位补0	。2.  子类能否重写父类的静态方法<br>不能，类对象，从属于对应的类。3.  什么是线程？<br>  线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。4.  线程和进程有什么区别？<br>  线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。5.  如何在Java中实现线程？<br>  两种方式：java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。6.  Java 关键字volatile 与 synchronized 作用与区别？<br>1，volatile<br>    它所修饰的变量不保留拷贝，直接访问主内存中的。<br>2，synchronized<br>    当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。24.不同的线程生命周期？<br>  当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。<br>        1.  程优先级的理解是什么？<br>  每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。26.是死锁(Deadlock)？如何分析和避免死锁？<br>  死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。<br>  分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。<br>  避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。27.么是线程安全？Vector是一个线程安全类吗？ <br>所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。28.Java中如何停止一个线程？<br>  Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程29.什么是ThreadLocal?<br>  ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。<br>  每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。30.Sleep()、suspend()和wait()之间有什么区别？<br>  Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。<br>  注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。<br>  object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()&#x2F;notify()与sleep()&#x2F;interrupt()类似，只是前者需要获取对象锁。31.什么是线程饿死，什么是活锁？<br>  当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI中线程活锁可能发生在以下情形：<br>  1，当所有线程在程序中执行Object.wait(0)，参数为0的wait方法。程序将发生活锁直到在相应的对象上有线程调用Object.notify()或者Object.notifyAll()。<br>  2，当所有线程卡在无限循环中。32.什么是Java Timer类？如何创建一个有特定时间间隔的任务？<br>  java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br>  java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。<br>33.Java中的同步集合与并发集合有什么区别？<br>  同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。<br>  在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。<br>  Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。34.同步方法和同步块，哪个是更好的选择？<br>  同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。35.么是线程池？ 为什么要使用它？<br>  创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。<br>  为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。<br>  从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。36．java中invokeAndWait 和 invokeLater有什么区别？<br>  这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。1.  多线程中的忙循环是什么?<br>  忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存。<br>  在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。2.  Array不可以用泛型？<br>是的，list的可以，推荐用list，List可以提供编译期的类型安全保证，而Array却不能。<br>int num&#x3D;Integer.valueOf(“12”);<br>int num2&#x3D;Integer.parseInt(“12”);<br>double num3&#x3D;Double.valueOf(“12.2”);<br>double num4&#x3D;Double.parseDouble(“12.2”);<br>&#x2F;&#x2F;其他的类似。通过基本数据类型的包装来的valueOf和parseXX来实现String转为XX<br>String a&#x3D;String.valueOf(“1234”);&#x2F;&#x2F;这里括号中几乎可以是任何类型<br>String b&#x3D;String.valueOf(true);<br>String c&#x3D;new Integer(12).toString();&#x2F;&#x2F;通过包装类的toString()也可以<br>String d&#x3D;new Double(2.3).toString();3.  AJAX有哪些有点和缺点？<br>优点：<br>  1、最大的一点是页面无刷新，用户的体验非常好。<br>  2、使用异步方式与服务器通信，具有更加迅速的响应能力。<br>  3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。<br>   4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。<br>缺点：<br>   1、ajax不支持浏览器back按钮。<br>   2、安全问题 AJAX暴露了与服务器交互的细节。<br>   3、对搜索引擎的支持比较弱。<br>   4、破坏了程序的异常机制。<br>   5、不容易调试。40.集合解析<br>List 和 Set 区别<br>List,Set都是继承自Collection接口<br>List特点：元素有放入顺序，元素可重复<br>Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉<br>（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）<br>Set和List对比：<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。<br>ArrayList 与 Vector 区别<br>public ArrayList(int initialCapacity)&#x2F;&#x2F;构造一个具有指定初始容量的空列表。<br>public ArrayList()&#x2F;&#x2F;构造一个初始容量为10的空列表。<br>public ArrayList(Collection&lt;?  extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 的元素的列表<br>Vector有四个构造方法：<br>public Vector()&#x2F;&#x2F;使用指定的初始容量和等于零的容量增量构造一个空向量。<br>public Vector(int initialCapacity)&#x2F;&#x2F;构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。<br>public Vector(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 中的元素的向量<br>public Vector(int initialCapacity,int capacityIncrement)&#x2F;&#x2F;使用指定的初始容量和容量增量构造一个空的向量<br>ArrayList和Vector都是用数组实现的，主要有这么三个区别：<br>Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；<br>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。<br>Vector可以设置增长因子，而ArrayList不可以。<br>Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。<br>适用场景分析：<br>Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。<br>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。<br>HashSet 和 HashMap 区别<br>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象<br>HashMap 和 ConcurrentHashMap 的区别<br>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。41.线程解析</p>
<ol>
<li>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore<br>CountDownLatch用法<br>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。<br>CyclicBarrier用法<br>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。<br>Semaphore用法<br>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。下面对上面说的三个辅助类进行一个总结：<br>　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。<br>　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。<br>说说 CountDownLatch 与 CyclicBarrier 区别<br>CountDownLatch	CyclicBarrier<br>减计数方式	加计数方式<br>计算为0时释放所有等待的线程	计数达到指定值时释放所有等待线程<br>计数为0时，无法重置	计数达到指定值时，计数置为0重新开始<br>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响	调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞<br>不可重复利用	可重复利用java.util.concurrent.Exchanger应用范例与原理浅析<br>此类提供对外的操作是同步的；<br>用于成对出现的线程之间交换数据；<br>可以视作双向的同步队列；<br>可应用于基因算法、流水线设计等场景。<br>ThreadLocal 原理分析<br>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。<br>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。<br>讲讲线程池的实现原理<br>线程池的几种方式<br>newFixedThreadPool(int nThreads) <br>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程<br>newCachedThreadPool() <br>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制<br>newSingleThreadExecutor() <br>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行<br>newScheduledThreadPool(int corePoolSize) <br>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br>线程的生命周期<br>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态<br>(1)生命周期的五种状态<br>新建（new Thread） <br>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 <br>例如：Thread t1&#x3D;new Thread();<br>就绪（runnable） <br>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();<br>运行（running） <br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。<br>死亡（dead） <br>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。<br>自然终止：正常运行run()方法后终止<br>异常终止：调用stop()方法让一个线程终止运行<br>堵塞（blocked） <br>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。<br>正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）1.  锁机制<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。 <br>在Java里，线程安全一般体现在两个方面： <br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。 <br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>Volatile<br>在多线程并发编程中synchronized和Volatile都扮演着重要的角色，Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。悲观锁 乐观锁<br>乐观锁 悲观锁 <br>是一种思想。可以用在很多方面。<br>比如数据库方面。 <br>悲观锁就是for update（锁定查询的行） <br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）<br>JDK方面： <br>悲观锁就是sync <br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。 <br>乐观锁就认为，基本没人抢。<br>乐观锁（Optimistic Lock）： <br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。数据存储分析<br>mysql索引使用技巧及注意事项<br> INSERT 与 UPDATE 语句在拥有索引的表中执行会花费更多的时间，而SELECT 语句却会执行得更快。这是因为，在进行插入或更新时，数据库也需要插入或更新索引值。<br>索引的类型：<br>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值<br>INDEX(普通索引)：允许出现相同的索引内容<br>PROMARY KEY(主键索引)：不允许出现相同的值<br>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维<br>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一<br>(1)使用ALTER TABLE语句创建索性<br>ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）<br>(2)使用CREATE INDEX语句对表增加索引<br>CREATE INDEX index_name ON table_name(username(length));<br>&#x2F;&#x2F;create只能添加这两种索引;<br>CREATE INDEX index_name ON table_name (column_list)<br>CREATE UNIQUE INDEX index_name ON table_name (column_list)<br>(3)删除索引<br>删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下：<br>drop index index_name on table_name ;alter table table_name drop index index_name ;alter table table_name drop primary key ;<br>(4) 组合索引与前缀索引<br>create table USER_DEMO<br>(<br>ID   int not null auto_increment comment ‘主键’,<br>LOGIN_NAME   varchar(100) not null comment ‘登录名’,<br>PASSWORD varchar(100) not null comment ‘密码’,<br>CITY varchar(30) not null comment ‘城市’,<br>AGE  int not null comment ‘年龄’,<br>SEX  int not null comment ‘性别(0:女 1：男)’,<br>primary key (ID)<br>);<br>ALTER TABLE USER_DEMO ADD INDEX name_city_age (LOGIN_NAME(16),CITY,AGE);索引的使用及注意事项<br>Explain select * from user where id&#x3D;1;<br>    1.索引不会包含有NULL的列<br>       只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。<br>    2.使用短索引<br>       对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。<br>    3.索引列排序<br>       mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。<br>    4.like语句操作<br>      一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。<br>    5.不要在列上进行运算<br>    6.不使用NOT IN 、&lt;&gt;、！&#x3D;操作，但&lt;,&lt;&#x3D;，&#x3D;，&gt;,&gt;&#x3D;,BETWEEN,IN是可以用到索引的<br>    7.索引要建立在经常进行select操作的字段上。<br>       这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。<br>    8.索引要建立在值比较唯一的字段上。<br>    9.对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。<br>    10.在where和join中出现的列需要建立索引。<br>    11.where的查询条件里有不等号(where column !&#x3D; …),mysql将无法使用索引。<br>    12.如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…),mysql将无法使用索引。<br>    13.在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。<br>分表与分库使用场景以及设计方式<br>对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表！场景：分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master<br>服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。<br>因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!<br>MySQL有三种锁的级别：页级、表级、行级。<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br>存储引擎的 InnoDB 与 MyISAM<br>1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。<br>2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用<br>3）InnoDB支持外键，MyISAM不支持<br>4）从MySQL5.5.5以后，InnoDB是默认引擎<br>5）InnoDB不支持FULLTEXT类型的索引<br>6）InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表<br>7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引<br>8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表<br>9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’<br>索引数据结构设相关的计算机原理<br>上文说过，二叉树、红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-&#x2F;+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-&#x2F;+Tree作为索引的理论基础。<br>当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，你需增加order by，并且order by字段需要建立索引。<br>   如果使用子查询去优化LIMIT的话，则子查询必须是连续的，某种意义来讲，子查询不应该有where条件，where会过滤数据，使数据失去连续性。<br>   如果你查询的记录比较大，并且数据传输量比较大，比如包含了text类型的field，则可以通过建立子查询。<br>分布式系统唯一ID生成方案汇总<br>关系型数据库 MySQL<br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。<br>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>文档数据库 MongoDB<br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。<br>列族数据库 HBase<br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。<br>全文搜索引擎 ElasticSearch<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。<br>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。<br>MongoDB 特性	优势<br>事务支持	MongoDB 目前只支持单文档事务，需要复杂事务支持的场景暂时不适合<br>灵活的文档模型	JSON 格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代<br>高可用复制集	满足数据高可靠、服务高可用的需求，运维简单，故障自动切换<br>可扩展分片集群	海量数据存储，服务能力水平扩展<br>高性能	mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足各种场景需求<br>强大的索引支持	地理位置索引可用于构建 各种 O2O 应用、文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求<br>Gridfs	解决文件存储的需求<br>aggregation &amp; mapreduce	解决数据分析场景需求，用户可以自己写查询语句或脚本，将请求都分发到 MongoDB 上完成<br>从目前阿里云 MongoDB 云数据库上的用户看，MongoDB 的应用已经渗透到各个领域，比如游戏、物流、电商、内容管理、社交、物联网、视频直播等，以下是几个实际的应用案例。<br>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新<br>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。<br>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能<br>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析<br>视频直播，使用 MongoDB 存储用户信息、礼物信息等redis内部数据结构深入浅出<br>redis 是 key-value 存储系统，其中 key 类型一般为字符串，而 value 类型则为 redis 对象（redis object），可以绑定各种类型的数据，譬如 string、list 和set，redis.h 中定义了 struct redisObject，它是一个简单优秀的数据结构Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>Redis 如何实现持久化1.  snapshotting(快照)<br>也是默认方式.(把数据做一个备份，将数据存储到文件)<br>快照是默认的持久化方式，这种方式是将内存中数据以快照的方式写到二进制文件中，默认的文件名称为dump.rdb.可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key键修改就自动做快照.<br> 2. Append-onlyfile(缩写aof)的方式        <br>aof方式:由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。aof比快照方式有更好的持久化性，是由于在使用aof时，redis会将每一个收到的写命令都通过write函数追加到文件中，当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。      <br>当然由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。可以通过配置文件告诉redis我们想要通过fsync函数强制os写入到磁盘的时机。<br>Redis 为什么是单线程的<br>要知道Redis的数据结构并不全是简单的Key-Value，还有列表，hash，map等等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，等等。这些操作还可以合成MULTI&#x2F;EXEC的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。这还带来一个恶果就是吞吐量虽然增大，但是响应延迟可能会增加。 <br>Redis在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用Lua脚本这样的功能。对于多线程来说这需要高得多的代价。44.使用传统的 Socket 开发挺简单的，我为什么要切换到 NIO 进行编程呢？<br>1.线程模型存在致命缺陷：一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>2.性能差：频繁的线程上下文切换导致 CPU 利用效率不高；<br>3.可靠性差：由于所有的 IO 操作都是同步的，所以业务线程只要进行 IO 操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br>4.采用非阻塞 IO（NIO）之后，同步阻塞 IO 的三个缺陷都将迎刃而解：<br>5.Nio 采用 Reactor 模式，一个 Reactor 线程聚合一个多路复用器 Selector，它可以同时注册、监听和轮询成百上千个 Channel，一个 IO 线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为 CPU 核数 + 1， N &lt; 进程可用的最大句柄数)；<br>6.由于 IO 线程总数有限，不会存在频繁的 IO 线程之间上下文切换和竞争，CPU 利用率高；<br>7.所有的 IO 操作都是异步的，即使业务线程直接进行 IO 操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。由于切换到 NIO 编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用 NIO 进行通信已经逐渐成为主流。# 什么是WebSockets？WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信信道。WebSocket是双向的 -使用WebSocket客户端或服务器可以发起消息发送。<br>WebSocket是全双工的 -客户端和服务器通信是相互独立的。<br>单个TCP连接 -初始连接使用HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信<br>Light -与http相比，WebSocket消息数据交换要轻得多。# 什么是CSRF攻击CSRF代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web应用程序上执行不需要的操作。CSRF攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。NOWCODER.COM<br>Java 面试题库<br>牛客网出品<br>NOWCODER.COM<br>Java 工程师校招面试题库导读<br>一、学习说明<br>本题库均来自海量真实校招面试题目大数据进行的整理，后续也会不断更新，可免费在线观<br>看，如需下载，也可在页面<br>载需要用牛币兑换，一次兑换可享受永久下载权限，因为后续会更新）<br>需要严肃说明的是：面试题库作为帮助同学准备面试的辅助资料，但是绝对不能作为备考唯<br>一途径，因为面试是一个考察真实水平的，不是背会了答案就可以的，需要你透彻理解的，<br>否则追问问题答不出来反而减分，毕竟技术面试中面试官最痛恨的就是背答案这个事情了。<br>学完这个题库，把此题库都理解透彻应对各家企业面试完全没有问题。（当然，要加上好的<br>项目以及透彻掌握）<br>另外，此面试题库中不包括面试中问到的项目，hr 面以及个人技术发展类。<br> 项目是比较个性化的，没办法作为一个题库来给大家参考，但是如果你有一个非常有含<br>金量的项目的话，是非常加分的，而且你的项目可能也会被问的多一些；<br> hr 面的话一般来说技术面通过的话个人没有太大的和公司不符合的问题都能通过；<br> 技术发展类的话这个就完全看自己啦，主要考察的会是你对技术的热爱和学习能力，比<br>如会问一些你是如何学习 xxx 技术的，或者能表达出你对技术的热爱的地方等等。此处<br>不做赘述。<br>那么抛开这些，Java 工程师中技术面中考察的占比如下：<br>需要注意的是：此图不绝对，因为实际面试中面试官会根据你的简历去问，比如你的项目多<br>NOWCODER.COM<br>可能就问的项目多一些，或者你说哪里精通可能面试官就多去问你这些。而且此图是根据题<br>库数据整理出来，并不是根据实际单场面试整理，比如基础部分不会考那么多，会从中抽着<br>考<br>但是面试中必考的点且占比非常大的有 Java 基础和算法。<br>决定你是否能拿 sp offer（高薪 offer）以及是否进名企的是项目和算法。<br>可以看出，算法除了是面试必过门槛以外，更是决定你是否能进名企或高薪 offer 的决定性<br>因素。<br>另外关于算法部分，想要系统的学习算法思想，实现高频面试题最优解等详细讲解的话可以<br>报名算法名企校招冲刺班或算法高薪校招冲刺班，你将能学到更先进的算法思想以及又一套<br>系统的校招高频题目的解题套路和方法论。<br>多出来的服务如下：<br>NOWCODER.COM<br>如果有什么问题，也可以加 qq 咨询 1440073724，如果是早鸟的话，还可以领取早鸟优惠哦<br>二、面试技巧<br>面试一般分为技术面和 hr 面，形式的话很少有群面，少部分企业可能会有一个交叉面，不<br>过总的来说，技术面基本就是考察你的专业技术水平的，hr 面的话主要是看这个人的综合<br>素质以及家庭情况符不符合公司要求，一般来讲，技术的话只要通过了技术面 hr 面基本上<br>是没有问题（也有少数企业 hr 面会刷很多人）<br>那我们主要来说技术面，技术面的话主要是考察专业技术知识和水平，我们是可以有一定的<br>技巧的，但是一定是基于有一定的能力水平的。<br>所以也慎重的告诉大家，技巧不是投机取巧，是起到辅助效果的，技术面最主要的还是要有<br>实力，这里是基于实力水平之上的技巧。<br>这里告诉大家面试中的几个技巧：<br>1、简历上做一个引导：<br>在词汇上做好区分，比如熟悉 Java，了解 python，精通 c 语言<br>这样的话对自己的掌握程度有个区分，也好让面试官有个着重去问，python 本来写的也只<br>是了解，自然就不会多问你深入的一些东西了。<br>2、在面试过程中做一个引导：<br>面试过程中尽量引导到自己熟知的一个领域，比如问到你说一下 DNS 寻址，然后你简单回<br>答（甚至这步也可以省略）之后，可以说一句，自己对这块可能不是特别熟悉，对计算机网<br>络中的运输层比较熟悉，如果有具体的，甚至可以再加一句，比如 TCP 和 UDP<br>这样的话你可以把整个面试过程往你熟知的地方引导，也能更倾向于体现出你的优势而不是<br>劣势，但是此方法仅限于掌握合适的度，比如有的知识点是必会的而你想往别处引就有点说<br>不过去了，比如让你说几个 Java 的关键字，你一个也说不上来，那可能就真的没辙了。<br>3、在自我介绍中做一个引导：<br>一般面试的开头都会有一个自我介绍，在这个位置你也可以尽情的为自己的优势方面去引导。<br>4、面试过程中展示出自信：<br>面试过程中的态度也要掌握好，不要自卑，也不要傲娇，自信的回答出每个问题，尤其遇到<br>不会的问题，要么做一些引导，实在不能引导也可以先打打擦边球，和面试官交流一下问题，<br>看起来像是没听懂题意，这个过程也可以再自己思考一下，如果觉得这个过程可以免了的话<br>也直接表明一下这个地方不太熟悉或者还没有掌握好，千万不要强行回答。<br>面试前的准备：<br>NOWCODER.COM<br>最重要的肯定是系统的学习了，有一个知识的框架，基础知识的牢靠程度等。<br>其中算法尤其重要，越来越多公司还会让你现场或者视频面试中手写代码；<br>另一大重要的和加分项就是项目，在面试前，一定要练习回答自己项目的三个问题：<br> 这是一个怎样的项目<br> 用到了什么技术，为什么用这项技术（以及每项技术很细的点以及扩展）<br> 过程中遇到了什么问题，怎么解决的。<br>那么话说回来，这个的前提是你要有一个好的项目，牛客网 CEO 叶向宇有带大家做项目，<br>感兴趣的可以去了解一下<br> 竞争力超过 70%求职者的项目：<br>（专属优惠码：DjPgy3x，每期限量前 100 个）<br> 竞争力超过 80%求职者的项目：<br>（专属优惠码：DMVSexJ，每期限量前 100 个）<br>知识都掌握好后，剩下的就是一个心态和模拟练习啦，因为你面试的少的话现场难免紧张，<br>而且没在那个环境下可能永远不知道自己回答的怎么样。<br>因为哪怕当你都会了的情况下，你的表达和心态就显得更重要了，会了但是没有表达的很清<br>晰就很吃亏了，牛客网这边有 AI 模拟面试，完全模拟了真实面试环境，正好大家可以真正<br>的去练习一下，还能收获一份面试报告：<br>面试后需要做的：<br>面试完了的话就不用太在意结果了，有限的时间就应该做事半功倍的事情，当然，要保持电<br>话邮箱畅通，不然别给你发 offer 你都不知道。<br>抛开这些，我们需要做的是及时将面试中的问题记录下来，尤其是自己回答的不够好的问题，<br>一定要花时间去研究，并解决这些问题，下次面试再遇到相同的问题就能很好的解决，当然，<br>即使不遇到，你这个习惯坚持住，后面也可以作为一个经历去跟面试官说，能表现出你对技<br>术的喜爱和钻研的一个态度，同时，每次面试后你会发现自己的不足，查缺补漏的好机会，<br>及时调整，在不断的调整和查缺补漏的过程中，你会越来越好。 三、面试考点导图<br>NOWCODER.COM<br>NOWCODER.COM<br>四、一对一答疑讲解戳这里<br>如果你对校招求职或者职业发展很困惑，欢迎与牛客网专业老师沟通，老师会帮你一对一讲<br>解答疑哦（可以扫下方二维码或者添加微信号：niukewang985）<br>NOWCODER.COM<br>目录<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>②关键字<br>③面向对象<br>④集合部分<br>2、Java 高级知识<br>①线程<br>②锁<br>③JDK<br>④反射<br>⑤JVM<br>⑥GC<br>⑦ IO 和 NIO，AIO<br>二、JavaEE 部分<br>1、Spring<br>①IoC 与 Bean 配置、管理<br>②AOP 与事务、权限控制<br>③S2SH 整合开发<br>④Spring，JPA 整合<br>2、Hibernate<br>①ORM 与持久化映射<br>②延迟加载、性能优化<br>③HQL 查询、条件查询、SQL 查询<br>④二级缓存与查询缓存<br>3、Struts<br>①MVC 模式与 Struts 体系<br>4、mybatis<br>5、MVC 框架<br>6、各框架对比与项目优化<br>7、JPA<br>①EJB<br>三、Java web 开发核心内容<br>1、web 编程基础<br>①Tomcat 服务器<br>NOWCODER.COM<br>②JSP 语法，EL，内置对象<br>③Listener 和 filter<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>②redis<br>③MVC 和 DAO<br>④JSTL、DisplayTag 等常见标签库的用法<br>3、Web 编程原理<br>① HTTP 协议<br>②请求&#x2F;相应架构原理<br>③web 容器<br>四、JDBC 编程<br>1、SQL 基础<br>2、JDBC 基础<br>①数据库<br>②数据库连接池<br>③事物管理，批处理<br>3、JDBC 进阶<br>五、XML 编程<br>1、XML 基础<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>六、计算机网络<br>1、网络概述<br>①关于分层<br>2、运输层<br>①TCP 与 UDP<br>②协议<br>3、网络层<br>①网际协议 IP<br>②网际控制报文协议 ICMP<br>③因特网的路由器选择协议<br>4、应用层<br>①域名系统 DNS<br>②电子邮件<br>NOWCODER.COM<br>七、操作系统<br>1、操作系统概论<br>2、进程的描述与控制<br>3、输入输出系统<br>4、存储器管理<br>5、处理机调度与死锁<br>八、算法与数据结构<br>1、哈希<br>2、树<br>3、遍历<br>4、链表<br>5、数组<br>6、排序<br>7、堆与栈<br>8、队列<br>9、高级算法<br>九、设计模式<br>1、结构型模式<br>①代理模式<br>②装饰模式<br>③适配器模式<br>2、创建型模式<br>①单例模式<br>3、行为型模式<br>①策略模式<br>②观察者模式<br>4、所有模式汇总<br>十、场景题<br>十一、UML<br>更多名企历年笔试真题可点击直接进行练习：<br>NOWCODER.COM<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>1、为什么重写 equals 还要重写 hashcode？<br>考点：java 基础<br>参考回答：<br>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()<br>方法继承于 Object 类，其 hashcode 码为默认的内存地址，这样即便有相同含义的两个对象，比<br>较也是不相等的。HashMap 中的比较 key 是这样的，先求出 key 的 hashcode(),比较其值是否相<br>等，若相等再比较 equals(),若相等则认为他们是相等的。若 equals()不相等则认为他们不相等。<br>如果只重写 hashcode()不重写 equals()方法，当比较 equals()时只是看他们是否为同一对象（即<br>进行内存地址的比较）,所以必定要两个方法一起重写。HashMap 用来判断 key 是否相等的方法，<br>其实是调用了 HashSet 判断加入元素 是否相等。重载 hashCode()是为了对同一个 key，能得到<br>相同的 Hash Code，这样 HashMap 就可以定位到我们指定的 key 上。重载 equals()是为了向<br>HashMap 表明当前对象和 key 上所保存的对象是相等的，这样我们才真正地获得了这个 key 所对<br>应的这个键值对。<br>2、说一下 map 的分类和常见的情况<br>考点：java 基础<br>参考回答：<br>java 为数据结构中的映射定义了一个接口 java.util.Map;它有四个实现类,分别是 HashMap<br>Hashtable LinkedHashMap 和 TreeMap.<br>Map 主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重<br>复。<br>Hashmap 是一个最常用的 Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的<br>值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap 最多只允许一条<br>记录的键为 Null;允许多条记录的值为 Null;HashMap 不支持线程的同步，即任一时刻可以有多<br>个线程同时写 HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections 的<br>synchronizedMap 方法使 HashMap 具有同步的能力，或者使用 ConcurrentHashMap。<br>Hashtable 与 HashMap 类似,它继承自 Dictionary 类，不同的是:它不允许记录的键或者值<br>为空;它支持线程的同步，即任一时刻只有一个线程能写 Hashtable,因此也导致了 Hashtable<br>在写入时会比较慢。<br>NOWCODER.COM<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排<br>序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，<br>遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和<br>容量无关，而 HashMap 的遍历速度和他的容量有关。<br>TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>一般情况下，我们用的最多的是 HashMap,在 Map 中插入、删除和定位元素，HashMap 是最<br>好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。如果需要输出的<br>顺序和输入的相同,那么用 LinkedHashMap 可以实现,它还可以按读取顺序来排列.<br>HashMap 是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的<br>值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。<br>HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的<br>不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的<br>能力。<br>Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，<br>即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。<br>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的<br>记录肯定是先插入的。<br>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，<br>也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？<br>考点：基础<br>参考回答：<br>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回<br>对象的 内存地址。<br>4、&#x3D;&#x3D;比较的是什么？<br>考点：基础<br>参考回答：<br>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，<br>“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。<br>NOWCODER.COM<br>5、若对一个类不重写，它的 equals()方法是如何比较的？<br>考点：基础<br>参考回答：<br>比较是对象的地址。<br>6、java8 新特性<br>考察点：java8<br>参考回答：<br>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。<br>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）<br>的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。<br>新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。<br>Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到<br>Java 中。<br>Date Time API − 加强对日期与时间的处理。<br>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许<br>我们在 JVM 上运行特定的 javascript 应用。<br>7、说说 Lamda 表达式的优缺点。<br>考察点：Java 基础<br>参考回答：<br>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。<br>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时<br>需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码<br>不容易让其他语言的程序员看懂。<br>8、一个十进制的数在内存中是怎么存的？<br>考察点：计算机基础<br>NOWCODER.COM<br>参考回答：<br>补码的形式。<br>9、为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？<br>考察点：计算机基础<br>参考回答：<br>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小<br>数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。<br>10、Java 支持的数据类型有哪些？什么是自动拆装箱？<br>考察点：JAVA 数据类型<br>参考回答：<br>Java 语言支持的 8 种基本数据类型是：<br>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：<br>把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。<br>11、什么是值传递和引用传递？<br>考察点：JAVA 引用传递<br>参考回答：<br>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。<br>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递. 12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不<br>是 ArrayList？<br>考察点：Array<br>NOWCODER.COM<br>参考回答：<br>Array 和 ArrayList 的不同点：<br>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。<br>Array 大小是固定的，ArrayList 的大小是动态变化的。<br>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类<br>型的时候，这种方式相对比较慢。<br>13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？<br>考察点：JAVA notation<br>参考回答：<br>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下<br>有多么好。<br>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般<br>使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一<br>个很好的说明。<br>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。<br>其函数表示是：<br>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));<br>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。<br>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使<br>用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好<br>的说明。<br>14、String 是最基本的数据类型吗?<br>考察点：数据类型<br>参考回答：<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效<br>率节省空间，我们应该用 StringBuffer 类。<br>15、int 和 Integer 有什么区别<br>考察点：数据类型<br>NOWCODER.COM<br>参考回答：<br>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据<br>类型，Integer 是 java 为 int 提供的封装类。<br>Java 为每个原始类型提供了封装类。<br>原始类型封装类<br>booleanBoolean<br>charCharacter<br>byteByte<br>shortShort<br>intInteger<br>longLong<br>floatFloat<br>doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同<br>的特征和用法，它们包括：大小和速<br>度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时<br>所指定的缺省值。对象引用实例变量<br>的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。<br>16、String 和 StringBuffer 的区别<br>考察点：数据类型<br>参考回答：<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多<br>个字符的字符数据。这个 String 类提供了<br>数值不可改变的字符串。而这个 StringBuffer 类提供的字符串进行修改。当你知道字符数据要<br>改变的时候你就可以使用 StringBuffer 。典型地，你可以使用 StringBuffers 来动态构造字符数据。<br>17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1<br>等，如何输出一个某种编码的字符串？<br>考察点：数据类型<br>参考回答：<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1″), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>NOWCODER.COM<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>18、int 和 Integer 有什么区别？<br>考察点：数据类型<br>参考回答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，<br>但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的<br>包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱<br>机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：*   原始类型: boolean，char，byte，short，int，long，float，double</li>
</ol>
<ul>
<li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<br>如：<br>class AutoUnboxingTest {<br>public static void main(String[] args) {<br>Integer a &#x3D; new Integer(3);<br>Integer b &#x3D; 3; &#x2F;&#x2F; 将 3 自动装箱成 Integer 类型<br>int c &#x3D; 3;<br>System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false 两个引用没有引用同一对象<br>System.out.println(a &#x3D;&#x3D; c); &#x2F;&#x2F; true a 自动拆箱成 int 类型再和 c 比较<br>}<br>}<br>19、&amp;和&amp;&amp;的区别？<br>考察点：运算符<br>参考回答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的<br>差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是<br>NOWCODER.COM<br>true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直<br>接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定<br>用户名不是 null 而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，<br>二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的<br>equals 比较，否则会产生 NullPointerException 异常。<br>20、在 Java 中，如何跳出当前的多重嵌套循环？<br>考察点：循环<br>参考回答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标<br>签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时<br>候甚至有相反的作用，所以这种语法其实不知道更好）<br>21、你能比较一下 Java 和 JavaSciprt 吗？<br>考察：Java&amp;JavaScript<br>参考回答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司<br>推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape<br>公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对<br>象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：</li>
<li>基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设<br>计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软<br>件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身<br>提供了非常丰富的内部对象供设计人员使用。</li>
<li>解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，<br>其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技<br>术来提升 JavaScript 的运行效率）</li>
<li>强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；<br>JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行<br>时检查推断其数据类型。</li>
<li>代码格式不一样。<br>22、简述正则表达式及其用途。<br>考察点：正则表达式<br>参考回答：<br>NOWCODER.COM<br>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式<br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的<br>信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大<br>的工具，绝大多数语言都提供了对正则表达式的支持。<br>23、Java 中是如何支持正则表达式操作的？<br>考察点：正则表达式<br>参考回答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、<br>replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰<br>富的 API 进行各种正则表达式操作，如：<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;<br>class RegExpTest {<br>public static void main(String[] args) {<br>String str &#x3D; “成都市(成华区)(武侯区)(高新区)”;<br>Pattern p &#x3D; Pattern.compile(“.*?(?&#x3D;\()”);<br>Matcher m &#x3D; p.matcher(str);<br>if(m.find()) {<br>System.out.println(m.group());<br>}<br>}<br>}<br>24、请你说说 Java 和 PHP 的区别？<br>考察点：Java 特性<br>参考回答：<br>PHP 暂时还不支持像 Java 那样 JIT 运行时编译热点代码,但是 PHP 具有 opcache 机制,能够<br>把脚本对应的 opcode 缓存在内存,PHP7 中还支持配置 opcache.file_cache 导出 opcode 到文件. 第三方的 Facebook HHVM 也支持 JIT.另外 PHP 官方基于 LLVM 围绕 opcache 机制构建的 Zend JIT<br>分支也正在开发测试中.在 php-src&#x2F;Zend&#x2F;bench.php 测试显示,PHP JIT 分支速度是 PHP 5.4 的<br>10 倍.<br>PHP 的库函数用 C 实现,而 Java 核心运行时类库(jdk&#x2F;jre&#x2F;lib&#x2F;rt.jar,大于 60MB)用 Java 编写<br>(jdk&#x2F;src.zip), 所以 Java 应用运行的时候,用户编写的代码以及引用的类库和框架都要在 JVM<br>上解释执行. Java 的 HotSpot 机制,直到有方法被执行 10000 次才会触发 JIT 编译, 在此之前运<br>行在解释模式下,以避免出现 JIT 编译花费的时间比方法解释执行消耗的时间还要多的情况.<br>PHP 内置模板引擎,自身就是模板语言.而 Java Web 需要使用 JSP 容器如 Tomcat 或第三方模<br>板引擎.<br>NOWCODER.COM<br>PHP 也可以运行在多线程模式下,比如 Apache 的 event MPM 和 Facebook 的 HHVM 都是多线程<br>架构.不管是多进程还是多线程的 PHP Web 运行模式,都不需要 PHP 开发者关心和控制,也就是说<br>PHP 开发者不需要写代码参与进程和线程的管理,这些都由 PHP-FPM&#x2F;HHVM&#x2F;Apache 实现.PHP-FPM<br>进程管理和并发实现并不需要 PHP 开发者关心,而 Java 多线程编程需要 Java 开发者编码参<br>与.PHP 一个 worker 进程崩溃,master 进程会自动新建一个新的 worker 进程,并不会导致 PHP 服<br>务崩溃.而 Java 多线程编程稍有不慎(比如没有捕获异常)就会导致 JVM 崩溃退出.对于 PHP-FPM<br>和 Apache MOD_PHP 来说,服务进程常驻内存,但一次请求释放一次资源,这种内存释放非常彻底.<br>PHP 基于引用计数的 GC 甚至都还没发挥作用程序就已经结束了。 ②关键字<br>1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什<br>么？如果修饰成员方法，锁住了什么？<br>考点：java 关键字<br>参考回答：<br>synchronized 修饰静态方法以及同步代码块的 synchronized (类.class)用法锁的是类，线<br>程想要执行对应同步代码，需要获得类锁。<br>synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。<br>2、介绍一下 volatile？<br>考察点：java 关键字<br>参考回答：<br>volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。比如我们所写的<br>代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，<br>这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高 CPU 的执行效<br>率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有<br>happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面<br>对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先 Java 内存模<br>型分为，主内存，工作内存。比如线程 A 从主内存把变量从主内存读到了自己的工作内存中，做<br>了加 1 的操作，但是此时没有将 i 的最新值刷新会主内存中，线程 B 此时读到的还是 i 的旧值。<br>加了 volatile 关键字的代码生成的汇编代码发现，会多出一个 lock 前缀指令。Lock 指令对 Intel<br>平台的 CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多<br>核之间数据不一致性问题。<br>3、锁有了解嘛，说一下 Synchronized 和 lock<br>考察点：java 关键字<br>NOWCODER.COM<br>参考回答：<br>synchronized 是 Java 的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证<br>在同一时刻最多只有一个线程执行该段代码。JDK1.5 以后引入了自旋锁、锁粗化、轻量级锁，<br>偏向锁来有优化关键字的性能。<br>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；<br>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock<br>在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock<br>时需要在 finally 块中释放锁；Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，<br>使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没<br>有成功获取锁，而 synchronized 却无法办到。<br>4、讲一讲 Java 里面的 final 关键字怎么用的？<br>考察点：关键字<br>参考回答：<br>当用 final 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他<br>被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注<br>意 final 类中的所有成员方法都会被隐式地指定为 final 方法。<br>“使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；<br>第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法<br>过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final<br>方法进行这些优化了。“<br>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；<br>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 ③面向对象<br>1、wait 方法底层原理<br>考察点：基础<br>参考回答：<br>ObjectSynchronizer::wait 方法通过 object 的对象中找到 ObjectMonitor 对象调用方法<br>void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)<br>通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队<br>列的末尾中然后在 ObjectMonitor::exit 释放锁，接着 thread_ParkEvent-&gt;park 也就是 wait。<br>NOWCODER.COM<br>2、Java 有哪些特性，举个多态的例子。<br>考察点：语言特性<br>参考回答：<br>封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据<br>发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）<br>3、String 为啥不可变？<br>考察点：面向对象<br>参考回答：<br>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不<br>能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对<br>象，引用类型指向的对象的状态也不能改变。<br>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字<br>节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以<br>在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串<br>是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得<br>数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不<br>可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安<br>全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，<br>这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的<br>所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计<br>算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是<br>HashMap 中的键往往都使用字符串的原因。<br>4、类和对象的区别<br>考察点：面向对象<br>参考回答：<br>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。<br>比如：“人”是一个类，而“教师”则是“人”的一个实例。<br>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性<br>的对象集合体。<br>5、请列举你所知道的 Object 类的方法。<br>考察点：面向对象<br>NOWCODER.COM<br>参考回答：<br>Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指<br>示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引<br>用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回<br>该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此<br>对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等<br>待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导<br>致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超<br>过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此<br>对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某<br>个实际时间量。<br>6、重载和重写的区别？相同参数不同返回值能重载吗？<br>考察点：重载<br>参考回答：<br>重载(Overloading)<br>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，<br>具有不同的参数个数&#x2F;类型。<br>重载 Overloading 是一个类中多态性的一种表现。<br>（2） Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同<br>的参数和不同的定义。<br>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是<br>多态性。<br>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可<br>以不相同。无法以返回型别作为重载函数的区分标准。<br>重写（Overriding）<br>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与<br>其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类<br>中的方法，而不需要重新编写相同的方法。<br>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的<br>重写。<br>方法重写又称方法覆盖。<br>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法<br>将覆盖原有的方法。<br>如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。<br>NOWCODER.COM<br>（3）子类函数的访问修饰权限不能少于父类的。<br>7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private<br>或者是 static 的方法？<br>考察点：static 变量<br>参考回答：<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情<br>况下被访问。<br>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编<br>译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。<br>8、String 能继承吗？<br>考察点：String<br>参考回答：<br>不能，char 数组用 final 修饰的。<br>9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？<br>考察点：类<br>参考回答：<br>StringBuffer 线程安全，StringBuilder 线程不安全，底层实现上的话，StringBuffer 其<br>实就是比 StringBuilder 多了 Synchronized 修饰符。<br>10、类加载机制，双亲委派模型，好处是什么？<br>考察点：类<br>参考回答：<br>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，<br>如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才<br>自己去加载。<br>使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次<br>关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最<br>终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各<br>种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的<br>话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现<br>NOWCODER.COM<br>多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的<br>Java 类，可以正常编译，但是永远无法被加载运行。<br>11、静态变量存在哪?<br>考察点：类<br>参考回答：<br>方法区<br>12、讲讲什么是泛型？<br>考察点：JAVA 泛型<br>参考回答：<br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法<br>时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，<br>类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;<br>调用时传入具体的类型（类型实参）。</li>
</ul>
<p>采用泛型写法后，在&#x2F;&#x2F;1 处想加入一个 Integer 类型的对象时会出现编译错误，通过<br>List&lt;String&gt;，直接限定了 list 集合中只能含有 String 类型的元素，从而在&#x2F;&#x2F;2 处无须进行强<br>制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是 String 类型<br>了。<br>13、解释 extends 和 super 泛型限定符-上界不存下界不取<br>考察点：JAVA 泛型<br>参考回答：<br>（1）泛型中上界和下界的定义<br>上界 &lt;? extend Fruit&gt;<br>下界 &lt;? super Apple&gt;<br>（2）上界和下界的特点<br>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）<br>下界的 list 只能 add，不能 get<br>（3）示例代码</p>
<p>（4）上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确<br>定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，<br>不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把<br>所有的子类向上转型为 Fruit。<br>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。<br>那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父<br>类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple<br>及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接<br>着呢，除了 Object，其他的都接不住。<br>NOWCODER.COM<br>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。<br>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引<br>用就必须得用 cast。<br>14、是否可以在 static 环境中访问非 static 变量？<br>考察点：static 变量<br>参考回答：<br>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机<br>载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，<br>编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。<br>15、谈谈如何通过反射创建对象？<br>考察点：类<br>参考回答：</p>
<ul>
<li>方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()</li>
<li>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器<br>（Constructor）对象并调用其 newInstance()方法创建对象，例如：<br>String.class.getConstructor(String.class).newInstance(“Hello”);<br>16、Java 支持多继承么？<br>考察点：JAVA 多继承<br>参考回答：<br>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口<br>支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子<br>接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</li>
</ul>
<p>18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。<br>考察点：comparable 接口<br>参考回答：<br>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象<br>排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两<br>个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()<br>方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也<br>是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回<br>true。</p>
<p>23、Static Nested Class 和 Inner Class 的不同<br>考察点：声明<br>参考回答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被<br>实例化。而通常的内部类需要在外部类实<br>例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义<br>为动态的(instance).Nested Class 的静态成员(Method)只能对 Outer Class 的静态成员(static<br>memebr)进行操作(ACCESS), 而不能 Access Outer Class 的动态成员(instance member).而<br>Nested Class 的动态成员(instance method) 却可以 Access Outer Class 的所有成员, 这个概<br>念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而 动<br>态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)<br>永远不可以 Access 跟 object 相关的动态成员(instance member),反过来就可以, 一个 CLASS<br>的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，<br>并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>考察点：对象<br>参考回答：<br>是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中<br>时，参数的值就是对该对象的引用。对象<br>的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。<br>25、Java 的接口和 C++的虚类的相同和不同处。<br>考察点：接口<br>参考回答：<br>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或<br>属性，现有的单继承机制就不能满足要求。<br>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，<br>该类要实现接口里面所有的方法和属<br>NOWCODER.COM<br>性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。<br>26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally<br>分别代表什么意义？在 try 块中可以抛出异常吗？<br>考察点：异常<br>参考回答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接<br>口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个<br>异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个<br>异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br>用 try 来指定一块预防所有”异常”的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指<br>定你想要捕捉的”异常”的类型。throw 语句用来明确地抛出一个”异常”。throws 用来标明一<br>个成员函数可能抛出的各种”异常”。Finally 为确保一段代码不管发生什么”异常”都被执行<br>一段代码。可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try<br>语句保护其他代码。每当遇到一个 try 语句，”异常“的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有<br>处理这种”异常”的 try 语句。<br>27、内部类可以引用他包含类的成员吗？有没有什么限制？<br>考察点：类<br>参考回答：<br>一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是 static 的，那么它<br>可以访问创建它的外部类对象的所有属性内部类如果是 sattic 的，即为 nested class，那么它<br>只可以访问创建它的外部类对象的所有 static 属性一般普通类只有 public 或 package 的访问修<br>饰，而内部类可以实现 static，protected，private 等访问修饰。当从外部类继承的时候，内<br>部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明<br>确地继承，就可以覆盖原来内部类的方法。<br>28、两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code 说法<br>是否正确？<br>考察点：对象<br>参考回答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当<br>相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals<br>方法返回 true），那么它们的 hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它<br>NOWCODER.COM<br>们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容<br>器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存<br>储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>30、如何通过反射获取和设置对象私有字段的值？<br>考察点：类<br>参考回答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段对象的<br>setAccessible(true)将其设置为可以访问，接下来就可以通过 get&#x2F;set 方法来获取&#x2F;设置字段的<br>值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段<br>的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如<br>ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得 dog 对象的主人的汽车的引擎的<br>ID 号。31、谈一下面向对象的”六原则一法则”。<br>考察点：Java 对象<br>参考回答：<br>NOWCODER.COM</p>
<ul>
<li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写<br>代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功<br>能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内<br>聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到<br>变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶<br>皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到<br>其他系统中使用的，这样才能实现软件复用的目标。）- 开闭原则：软件实体应当对扩展开放，<br>对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系<br>统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是<br>关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可<br>变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不<br>清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- 依赖倒<br>转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类<br>型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一<br>个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换<br>掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简<br>单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，<br>如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。<br>例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容<br>易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的<br>能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li>
<li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示<br>能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分<br>别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方<br>法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会<br>几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、<br>代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- 合成聚合复用<br>原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用<br>得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之<br>间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其<br>中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A<br>关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可<br>以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例<br>子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错<br>误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置<br>为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。<br>记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- 迪<br>米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂<br>的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter<br>不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的<br>请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内<br>存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到<br>一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设<br>备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。<br>NOWCODER.COM<br>32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？<br>考察点：接口<br>参考回答：<br>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的<br>前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使<br>用 iterate()方法可以减少性能开销。<br>② list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题<br>33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？<br>考察点：方法<br>参考回答：<br>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的<br>情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参<br>数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。<br>34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？<br>考察点：JAVA 构造函数<br>参考回答：<br>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提<br>供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。<br>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必<br>须有它自己唯一的参数列表。<br>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，<br>Java 不会创建默认的复制构造函数。<br>35、hashCode()和 equals()方法有什么联系？<br>考点：基础<br>参考回答：<br>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<br>➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>➁ 如果两个对象的 hashCode 相同，它们并不一定相同。<br>NOWCODER.COM<br>④集合部分<br>1、Map 和 ConcurrentHashMap 的区别？<br>考点：集合<br>参考回答：<br>hashmap 是线程不安全的，put 时在多线程情况下，会形成环从而导致死循环。<br>CoucurrentHashMap 是线程安全的，采用分段锁机制，减少锁的粒度。<br>2、hashMap 内部具体如何实现的？<br>考点：集合<br>参考回答：<br>Hashmap 基于数组实现的，通过对 key 的 hashcode &amp; 数组的长度得到在数组中位置，如当<br>前数组有元素，则数组当前元素 next 指向要插入的元素，这样来解决 hash 冲突的，形成了拉链<br>式的结构。put 时在多线程情况下，会形成环从而导致死循环。数组长度一般是 2n，从 0 开始编<br>号，所以 hashcode &amp; （2n-1），（2n-1）每一位都是 1，这样会让散列均匀。需要注意的是，<br>HashMap 在 JDK1.8 的版本中引入了红黑树结构做优化，当链表元素个数大于等于 8 时，链表转<br>换成树结构；若桶中链表元素个数小于等于 6 时，树结构还原成链表。因为红黑树的平均查找长<br>度是 log(n)，长度为 8 的时候，平均查找长度为 3，如果继续使用链表，平均查找长度为 8&#x2F;2&#x3D;4，<br>这才有转换为树的必要。链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，虽然速度也很快的，但是转化为<br>树结构和生成树的时间并不会太短。还有选择 6 和 8，中间有个差值 7 可以有效防止链表和树频<br>繁转换。假设一下，如果设计成链表个数超过 8 则链表转换成树结构，链表个数小于 8 则树结构<br>转换成链表，如果一个 HashMap 不停的插入、删除元素，链表个数在 8 左右徘徊，就会频繁的发<br>生树转链表、链表转树，效率会很低。<br>3、如果 hashMap 的 key 是一个自定义的类，怎么办？<br>考点：集合<br>参考回答：<br>使用 HashMap，如果 key 是自定义的类，就必须重写 hashcode()和 equals()。<br>4、ArrayList 和 LinkedList 的区别，如果一直在 list 的尾部添加元素，用哪<br>个效率高？<br>考点：集合<br>参考回答：<br>NOWCODER.COM<br>ArrayList 采用数组数组实现的，查找效率比 LinkedList 高。LinkedList 采用双向链表实<br>现的，插入和删除的效率比 ArrayList 要高。一直在 list 的尾部添加元素，LinkedList 效率要<br>高。<br>5、HashMap 底层，负载因子，为啥是 2^n？<br>考点：集合<br>参考回答：<br>负载因子默认是 0.75， 2^n 是为了让散列更加均匀，例如出现极端情况都散列在数组中的<br>一个下标，那么 hashmap 会由 O（1）复杂退化为 O（n）的。<br>6、ConcurrentHashMap 锁加在了哪些地方？<br>考点：集合<br>参考回答：<br>加在每个 Segment 上面。<br>7、TreeMap 底层，红黑树原理？<br>考点：集合<br>参考回答：<br>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证<br>当需要快速检索指定节点。<br>红黑树的插入、删除、遍历时间复杂度都为 O(lgN)，所以性能上低于哈希表。但是哈希表<br>无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑<br>树性质：<br>性质 1：每个节点要么是红色，要么是黑色。<br>性质 2：根节点永远是黑色的。<br>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。<br>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续<br>的红色节点）<br>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。<br>8、concurrenthashmap 有啥优势，1.7，1.8 区别？<br>NOWCODER.COM<br>考点：集合<br>参考回答：<br>Concurrenthashmap 线程安全的，1.7 是在 jdk1.7 中采用 Segment + HashEntry 的方式进<br>行实现的，lock 加在 Segment 上面。1.7size 计算是先采用不加锁的方式，连续计算元素的个数，<br>最多计算 3 次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果<br>前后两次计算结果都不同，则给每个 Segment 进行加锁，再计算一次元素的个数；<br>1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node + CAS + Synchronized 来<br>保证并发安全进行实现，1.8 中使用一个 volatile 类型的变量 baseCount 记录元素的个数，当<br>插入新数据或则删除数据时，会通过 addCount()方法更新 baseCount，通过累加 baseCount 和<br>CounterCell 数组中的数量，即可得到元素的总个数；<br>9、ArrayList 是否会越界？<br>考点：集合<br>参考回答：<br>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构 2. 对<br>于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList<br>并发 add()可能出现数组下标越界异常<br>10、什么是 TreeMap?<br>考察点：key-value 集合<br>参考回答：<br>TreeMap 是一个有序的 key-value 集合，基于红黑树（Red-Black tree）的 NavigableMap<br>实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，<br>具体取决于使用的构造方法。<br>TreeMap 的特性：<br>根节点是黑色<br>每个节点都只能是红色或者黑色<br>每个叶节点（NIL 节点，空节点）是黑色的。<br>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个<br>红色的节点。<br>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>NOWCODER.COM<br>11、ConcurrentHashMap 的原理是什么？<br>考察点：JAVA 内存模型<br>参考回答：<br>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封<br>装映射表的键 &#x2F; 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的<br>若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例<br>中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在<br>HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。<br>static final class HashEntry&lt;K,V&gt; {<br>final K key; &#x2F;&#x2F; 声明<br>key 为 final 型<br>final int hash; &#x2F;&#x2F; 声明 hash<br>值为 final 型<br>volatile V value; &#x2F;&#x2F; 声明 value 为<br>volatile 型<br>final HashEntry&lt;K,V&gt; next; &#x2F;&#x2F; 声明 next 为 final 型<br>HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) {<br>this.key &#x3D; key;<br>this.hash &#x3D; hash;<br>this.next &#x3D; next;<br>this.value &#x3D; value;<br>}<br>}<br>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰<br>撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，<br>所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry<br>对象后的结构图：<br>图 1. 插入三个节点后桶的结构示意图：<br>NOWCODER.COM<br>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。<br>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个<br>Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。<br>12、Java 集合类框架的基本接口有哪些？<br>考察点：JAVA 集合<br>参考回答：<br>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它<br>自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基<br>本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的 Collection。<br>List：有顺序的 collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。<br>13、为什么集合类没有实现 Cloneable 和 Serializable 接口？<br>考察点：JAVA 集合<br>参考回答：<br>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，<br>应该由集合类的具体实现来决定如何被克隆或者是序列化。<br>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创<br>建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果<br>你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应<br>用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化<br>14、什么是迭代器？<br>考察点：JAVA 迭代器<br>参考回答：<br>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接<br>口,<br>NOWCODER.COM<br>每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合<br>的元素进行迭代操作. 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出<br>ConcurrentModificationException<br>异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除. 15、Iterator 和 ListIterator 的区别是什么？<br>考察点：迭代器<br>参考回答：<br>Iterator 和 ListIterator 的区别是：<br>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。<br>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前<br>一个和后一个元素的索引，等等。<br>16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？<br>考察点：集合<br>参考回答：<br>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。<br>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的<br>类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全<br>失败的迭代器永远不会抛出这样的异常。<br>18、ArrayList 和 LinkedList 有什么区别？<br>考察点：ArrayList<br>参考回答：<br>NOWCODER.COM<br>ArrayList 和 LinkedList 都实现了 List 接口，他们有以下的不同点：<br>ArrayList 是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行随机<br>访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个<br>和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。<br>相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任<br>意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向<br>前一个元素，一个指向下一个元素。<br>19、ArrayList,Vector,LinkedList 的存储性能和特性是什么？<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索<br>引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector<br>由于使用了 synchronized 方法（线程<br>安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据<br>需要进行前向或后向遍历，但是插入数<br>据时只需要记录本项的前后项即可，所以插入速度较快。<br>20、Collection 和 Collections 的区别。<br>考察点：集合<br>参考回答：<br>Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.<br>Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、<br>线程安全化等操作。<br>21、你所知道的集合类都有哪些？主要方法？<br>考察点：集合<br>参考回答：<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可<br>变大小的列表，比较适合构建、存储和操<br>作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其<br>中每个键映射到一个值。</li>
</ul>
<p>23、阐述 ArrayList、Vector、LinkedList 的存储性能和特性<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操<br>作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector<br>是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使<br>用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号<br>索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号<br>索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速<br>度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、<br>BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和<br>LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具<br>类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢<br>模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。<br>24、List、Map、Set 三个接口存取元素时，各有什么特点？<br>考察点：List<br>参考回答：<br>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals()<br>方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一<br>或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理<br>论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的<br>键（key）构成排序树从而达到排序和去重的效果。<br>NOWCODER.COM<br>2、Java 高级知识<br>①线程<br>1、多线程中的 i++线程安全吗？为什么？<br>考察点：多线程<br>参考回答：<br>不安全。i++不是原子性操作。i++分为读取 i 值，对 i 值加一，再赋值给 i++，执行期中任<br>何一步都是有可能被其他线程抢占的。<br>2、如何线程安全的实现一个计数器？<br>考察点：多线程<br>参考回答：<br>可以使用加锁，比如 synchronized 或者 lock。也可以使用 Concurrent 包下的原子类。<br>3、多线程同步的方法<br>考察点：多线程<br>参考回答：<br>可以使用 synchronized、lock、volatile 和 ThreadLocal 来实现同步。<br>4、介绍一下生产者消费者模式？<br>考察点：线程<br>参考回答：<br>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储<br>空间，生产者向空间里生产数据，而消费者取走数据。<br>优点：支持并发、解耦。<br>5、线程，进程，然后线程创建有很大开销，怎么优化？<br>NOWCODER.COM<br>考察点：多线程<br>参考回答：<br>可以使用线程池。<br>6、线程池运行流程，参数，策略<br>考察点：线程池<br>参考回答：<br>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线<br>程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列<br>满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝<br>策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。<br>7、讲一下 AQS 吧。<br>考察点：多线程<br>参考回答：<br>AQS 其实就是一个可以给我们实现锁的框架<br>内部实现的关键是：先进先出的队列、state 状态<br>定义了内部类 ConditionObject<br>拥有两种线程模式独占模式和共享模式。<br>在 LOCK 包中的相关锁(常用的有 ReentrantLock、 ReadWriteLock)都是基于 AQS 来构建，<br>一般我们叫 AQS 为同步器。<br>10、Java 中有几种线程池？<br>考察点：线程池<br>参考回答：<br>1、newFixedThreadPool 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一<br>个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>2、newCachedThreadPool 创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1<br>分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个<br>工作线程。<br>3、newSingleThreadExecutor 创建一个单线程化的 Executor，即只创建唯一的工作者线程<br>来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特<br>色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个<br>线程是活动的 。<br>4、newScheduleThreadPool 创建一个定长的线程池，而且支持定时的以及周期性的任务执<br>行，类似于 Timer。(这种线程池原理暂还没完全了解透彻)<br>11、线程池有什么好处？<br>考察点：线程池<br>参考回答：<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。<br>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。<br>参考回答：<br>所谓回调，就是客户程序 C 调用服务程序 S 中的某个方法 A，然后 S 又在某个时候反过来调<br>用 C 中的某个方法 B，对于 C 来说，这个 B 便叫做回调方法。<br>17、同步方法和同步代码块的区别是什么？<br>考察点：JAVA 代码块同步<br>参考回答：<br>区别：<br>同步方法默认用 this 或者当前类 class 对象作为锁；<br>NOWCODER.COM<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步<br>问题的部分代码而不是整个方法；<br>18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同<br>步？<br>考察点：JAVA 线程同步<br>参考回答：<br>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一<br>个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行<br>同步代码。<br>26、线程的 sleep()方法和 yield()方法有什么区别？<br>考察点：线程<br>参考回答：<br>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行<br>的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）<br>状态；<br>③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。<br>27、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进<br>入此对象的 synchronized 方法 B？<br>考察点：线程<br>参考回答：<br>NOWCODER.COM<br>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的<br>synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被<br>取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。<br>28、请说出与线程同步以及线程调度相关的方法。<br>考察点：线程同步<br>参考回答：*   wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p>
<ul>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理<br>InterruptedException 异常；</li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一<br>个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让<br>它们竞争，只有获得锁的线程才能进入就绪状态；<br>通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。<br>Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()<br>方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），<br>信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须<br>得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必<br>须向信号量归还许可（调用 Semaphore 对象的 release()方法）。<br>29、举例说明同步和异步<br>考察点：线程<br>参考回答：<br>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据<br>以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就<br>必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个<br>需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，<br>在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是<br>非阻塞式操作。<br>31、说说线程的基本状态以及状态之间的关系？<br>考察点：线程<br>参考回答：<br>其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表<br>示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait()方法进入等待池，也可能是执行<br>同步方法或同步代码块进入等锁池，或者是调用了 sleep()方法或 join()方法等待休眠或其他线<br>程结束，或是因为发生了 I&#x2F;O 中断。<br>1、Java 中的 LongAdder 和 AtomicLong 的区别<br>考点：JDK<br>参考回答：<br>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到<br>修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在<br>大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合<br>ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。<br>虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger<br>NOWCODER.COM<br>的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字<br>进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元<br>cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进<br>行了有效的分离，提高了并行度。<br>2、JDK 和 JRE 的区别是什么？<br>考察点：JDK<br>参考回答：<br>Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet<br>需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其<br>他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应用程序。 ④反射<br>1、反射的实现与作用<br>考察点：反射<br>参考回答；<br>JAVA 语言编译之后会生成一个.class 文件，反射就是通过字节码文件找到某一个类、类中<br>的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构<br>造方法，Field：类中的属性对象，Method：类中的方法对象。<br>作用：反射机制指的是程序在运行时能够获取自身的信息。在 JAVA 中，只要给定类的名字，<br>那么就可以通过反射机制来获取类的所有信息。 ⑤JVM</li>
</ul>
<p>5、JAVA 虚拟机的作用?<br>考察点：java 虚拟机<br>参考回答：<br>解释运行字节码程序 消除平台相关性。<br>NOWCODER.COM<br>jvm 将 java 字节码解释为具体平台的具体指令。一般的高级语言如要在不同的平台上运行，<br>至少需要编译成不同的目标代码。而引入 JVM 后，Java 语言在不同平台上运行时不需要重新编<br>译。Java 语言使用模式 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言编译程序只<br>需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java<br>虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<br>假设一个场景，要求 stop the world 时间非常短，你会怎么设计垃圾回收机制？<br>绝大多数新创建的对象分配在 Eden 区。<br>在 Eden 区发生一次 GC 后，存活的对象移到其中一个 Survivor 区。<br>在 Eden 区发生一次 GC 后，对象是存放到 Survivor 区，这个 Survivor 区已经存在其他存活<br>的对象。<br>一旦一个 Survivor 区已满，存活的对象移动到另外一个 Survivor 区。然后之前那个空间已<br>满 Survivor 区将置为空，没有任何数据。<br>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。<br>9、jvm 是如何实现线程？<br>考察点：JVM<br>参考回答：<br>NOWCODER.COM<br>线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开。<br>一个进程里可以启动多条线程，各个线程可共享该进程的资源(内存地址，文件 IO 等)，又可以<br>独立调度。线程是 CPU 调度的基本单位。<br>主流 OS 都提供线程实现。Java 语言提供对线程操作的同一 API，每个已经执行 start()，<br>且还未结束的 java.lang.Thread 类的实例，代表了一个线程。<br>Thread 类的关键方法，都声明为 Native。这意味着这个方法无法或没有使用平台无关的手<br>段来实现，也可能是为了执行效率。<br>实现线程的方式<br>A.使用内核线程实现内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核支持<br>的线程。<br>内核来完成线程切换<br>内核通过调度器 Scheduler 调度线程，并将线程的任务映射到各个 CPU 上<br>程序使用内核线程的高级接口，轻量级进程(Light Weight Process,LWP)<br>用户态和内核态切换消耗内核资源<br>使用用户线程实现<br>系统内核不能感知线程存在的实现<br>用户线程的建立、同步、销毁和调度完全在用户态中完成<br>所有线程操作需要用户程序自己处理，复杂度高<br>用户线程加轻量级进程混合实现<br>轻量级进程作为用户线程和内核线程之间的桥梁<br>10、jvm 最大内存限制多少<br>考察点：JVM<br>参考回答：<br>(1)堆内存分配<br>JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1&#x2F;64；JVM 最大分配的内存由-Xmx 指<br>定，默认是物理内存的 1&#x2F;4。默认空余堆内存小 于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；<br>空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。因此服务器一般设置-Xms、 -Xmx 相等以避免在每次 GC 后调整堆的大小。<br>(2)非堆内存分配<br>JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1&#x2F;64；由 XX:MaxPermSize<br>设置最大非堆内存的大小，默认是物理内存的 1&#x2F;4。<br>NOWCODER.COM<br>(3)VM 最大内存<br>首先 JVM 内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM 内存的最大值跟<br>操作系统有很大的关系。简单的说就 32 位处理器虽 然可控内存空间有 4GB,但是具体的操作系<br>统会给一个限制，这个限制一般是 2GB-3GB（一般来说 Windows 系统下为 1.5G-2G，Linux 系 统<br>下为 2G-3G），而 64bit 以上的处理器就不会有限制了。<br>(3)下面是当前比较流行的几个不同公司不同版本 JVM 最大堆内存:<br>11、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？<br>考察点：JVM<br>参考回答：<br>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚<br>拟机执行的字节码文件。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或<br>者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。<br>12、描述一下 JVM 加载 class 文件的原理机制?<br>考察点：JVM<br>参考回答：<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的<br>Java 运行时系统组件。它负责在运行时查找和装入类文件的类。<br>Java 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，<br>而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的<br>加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要<br>的类。<br>NOWCODER.COM<br>类装载方式，有两种<br>（1）隐式装载， 程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载<br>对应的类到 jvm 中，<br>（2）显式装载， 通过 class.forname()等方法，显式加载需要的类 , 隐式加载与显式加载的<br>区别：两者本质是一样的。<br>Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行<br>的基础类(像是基类)完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了<br>节省内存开销。 ⑥GC<br>1、java 中内存泄露是啥，什么时候出现内存泄露？<br>考察点：内存泄漏<br>参考回答：<br>Java 中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就<br>是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。<br>2、minor gc 如果运行的很频繁，可能是什么原因引起的，minor gc 如果运行的<br>很慢，可能是什么原因引起的?<br>考察点：GC<br>参考回答：<br>可能是堆内存太小。<br>3、阐述 GC 算法<br>考察点：JVM<br>参考回答：<br>①GC（GarbageCollection 垃圾收集），GC 的对象是堆空间和永久区<br>②GC 算法包含：引用计数法，标记清除，标记压缩，复制算法。<br>③引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用<br>计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A<br>就不可能再被使用。<br>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：<br>标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开<br>始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有<br>未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对<br>象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正<br>NOWCODER.COM<br>在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对<br>象，交换两个内存的角色，完成垃圾回收。<br>4、GC 是什么? 为什么要有 GC?<br>考察点：回收<br>参考回答：<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，<br>忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监<br>测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显<br>示操作方法。<br>5、垃圾回收的优点和原理。并考虑 2 种回收机制<br>考察点：垃圾回收<br>参考回答：<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的<br>问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回<br>收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以<br>有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的<br>线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，<br>程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃<br>圾回收和标记垃圾回收，增量垃圾回收。<br>6、java 中会存在内存泄漏吗，请简单描述。<br>考察点：内存<br>参考回答：<br>Java 中的确存在 Java 的内存泄漏, 并且事态可以变得相当严重<br>Java garbage collector 自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的<br>其他程序上下文的内存泄漏. 但是 Java 应用程序依旧会有相当的内存泄漏. 查找原因会十分困<br>难. 有两类主要的 Java 内存泄漏:*   不再需要的对象引用</p>
<ul>
<li>未释放的系统资源<br>2.2 非必要的对象引用<br>Java 代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java 对<br>象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如<br>下问题:</li>
<li>在向数组添加对象以后遗漏了对于他们的处理</li>
<li>直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并<br>且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.</li>
<li>在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面<br>保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当<br>中.<br>NOWCODER.COM</li>
<li>允许一个长久执行的线程所引用的对象. 设置引用为 NULL 也无济于事, 在线程退出和空闲之<br>前, 对象不会被收集释放<br>2.3 未释放的系统资源<br>Java 方法可以定位 Java 实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java 常常通过<br>JNI(Java Native Interface)调用 C&#x2F;C++子程序定位这些资源. 7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办<br>法主动通知虚拟机进行垃圾回收？（垃圾回收）<br>考察点：垃圾回收<br>参考回答：<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆<br>(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当<br>GC 确定一些对象为”不可达”时，GC 就有责<br>任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。 ⑦ IO 和 NIO，AIO<br>1、怎么打印日志？<br>考察点：异常<br>参考回答：<br>cat &#x2F;var&#x2F;log&#x2F;*.log<br>如果日志在更新，如何实时查看 tail -f &#x2F;var&#x2F;log&#x2F;messages<br>还可以使用 watch -d -n 1 cat &#x2F;var&#x2F;log&#x2F;messages<br>-d 表示高亮不同的地方，-n 表示多少秒刷新一次。<br>2、运行时异常与一般异常有何异同？<br>考察点：异常<br>参考回答：<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异<br>常，但是并不要求必须声明抛出未被捕获的运行时异常。<br>3、error 和 exception 有什么区别?<br>考察点：异常<br>NOWCODER.COM<br>参考回答：<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。<br>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。<br>4、给我一个你最常见到的 runtime exception<br>考察点：异常<br>参考回答：<br>ArithmeticException,<br>ArrayStoreException,<br>BufferOverflowException,<br>BufferUnderflowException,<br>CannotRedoException,<br>CannotUndoException,<br>ClassCastException,<br>CMMException,<br>ConcurrentModificationException,<br>DOMException,<br>EmptyStackException,<br>IllegalArgumentException,<br>IllegalMonitorStateException,<br>IllegalPathStateException,<br>IllegalStateException,<br>ImagingOpException,<br>IndexOutOfBoundsException,<br>MissingResourceException,<br>NegativeArraySizeException,<br>NoSuchElementException,<br>NullPointerException,<br>ProfileDataException,<br>NOWCODER.COM<br>ProviderException,<br>RasterFormatException, SecurityException, SystemException,<br>UndeclaredThrowableException, UnmodifiableSetException,<br>UnsupportedOperationException<br>5、Java 中的异常处理机制的简单原理和应用。<br>考察点：异常<br>参考回答：<br>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。<br>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发<br>IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就<br>是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。<br>6、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，<br>请说出他们分别是哪些类？<br>考察点：stream<br>参考回答：<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于<br>InputStreamReader OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高<br>性能和使用方便。</li>
</ul>
<p>8、运行时异常与受检异常有什么区别？<br>考察点：异常<br>参考回答：<br>NOWCODER.COM<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序<br>运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求<br>方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异<br>常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用<br>给出了以下指导原则：*   不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流<br>而使用异常）</p>
<ul>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li>
<li>优先使用标准的异常</li>
<li>每个方法抛出的异常都要有文档</li>
<li>保持异常的原子性</li>
<li>不要在 catch 中忽略掉捕获到的异常<br>二、JavaEE 部分<br>3、Spring 里面注解用过没有？autowired 和 resource 区别？<br>考察点：Spring<br>参考回答：<br>1、共同点<br>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter<br>方法。<br>2、不同点<br>（1）@Autowired<br>@Autowired 为 Spring 提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired;只按照 byType 注入。<br>NOWCODER.COM<br>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存<br>在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）<br>来装配，可以结合@Qualifier 注解一起使用。<br>（2）@Resource<br>@Resource 默认按照 ByName 自动注入，由 J2EE 提供，需要导入包<br>javax.annotation.Resource。@Resource 有两个重要的属性：name 和 type，而 Spring 将<br>@Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以，如<br>果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入<br>策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。<br>4、@Controller 和@RestController 的区别？<br>考察点：spring<br>参考回答：<br>@RestController 注解相当于@ResponseBody ＋ @Controller 合在一起的作用<br>2、Struts 拦截器和 Spring AOP 区别？<br>考察点：框架<br>参考回答：<br>拦截器是 AOP 的一种实现，struts2 拦截器采用 xwork2 的 interceptor！而 spring 的 AOP<br>基于 IoC 基础,其底层采用动态代理与 CGLIB 代理两种方式结合的实现方式。<br>4、选择使用 Spring 框架的原因（Spring 框架为企业级开发带来的好处有哪些）？<br>考察点：框架<br>参考回答：<br>NOWCODER.COM</li>
<li>非侵入式：支持基于 POJO 的编程模式，不强制性的要求实现 Spring 框架中的接口或继承<br>Spring 框架中的类。</li>
<li>IoC 容器：IoC 容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如<br>果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建<br>和完整的回归测试。有了 IoC 容器，程序员再也不需要自己编写工厂、单例，这一点特别符合<br>Spring 的精神”不要重复的发明轮子”。</li>
<li>AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将<br>横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，<br>有了 AOP 程序员可以省去很多自己写代理类的工作。</li>
<li>MVC：Spring 的 MVC 框架为 Web 表示层提供了更好的解决方案。</li>
<li>事务管理：Spring 以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，<br>在不需要任何一行代码的情况下就能够完成事务管理。</li>
<li>其他：选择 Spring 框架的原因还远不止于此，Spring 为 Java 企业级开发提供了一站式选择，<br>你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到 Spring 存在的情<br>况下，在你的项目中使用 Spring 提供的各种优秀的功能。 ④Spring，JPA 整合<br>1、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？<br>考察点：框架<br>参考回答：<br>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中<br>的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统<br>中专注于实现数据持久化的相对独立的层面。<br>持久层设计的目标包括：</li>
<li>数据存储逻辑的分离，提供抽象化的数据访问接口。</li>
<li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。</li>
<li>资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。</li>
<li>数据抽象，提供更面向对象的数据操作。<br>持久层框架有：</li>
<li>Hibernate</li>
<li>MyBatis</li>
<li>TopLink</li>
<li>Guzz</li>
<li>jOOQ</li>
<li>Spring Data</li>
<li>ActiveJDBC<br>NOWCODER.COM<br>2、Hibernate<br>①ORM 与持久化映射<br>1、阐述实体对象的三种状态以及转换关系。<br>考察点：JAVA 实体<br>参考回答：<br>最新的 Hibernate 文档中为 Hibernate 对象定义了四种状态（原来是三种状态，面试的时候<br>基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or<br>persistent）、游状态（detached）和移除态（removed，以前 Hibernate 文档中定义的三种状<br>态中没有移除态），如下图所示，就以前的 Hibernate 文档中移除态被视为是瞬时态。<br>瞬时态：当 new 一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数<br>据的内存区域，如果没有变量引用这个对象，则会被 JVM 的垃圾回收机制回收。这个对象所保存<br>的数据与数据库没有任何关系，除非通过 Session 的 save()、saveOrUpdate()、persist()、merge()<br>方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对<br>象。<br>持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态<br>对象进行 delete 操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存<br>在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上<br>同步到数据库，直到数据库事务提交。<br>游离态：当 Session 进行了 close()、clear()、evict()或 flush()后，实体对象从持久态变成<br>游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除<br>掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象<br>是十分相似的，只是它还含有持久化标识。 ②延迟加载、性能优化<br>1、Hibernate 中 SessionFactory 是线程安全的吗？Session 是线程安全的吗（两<br>个线程能够共享同一个 Session 吗）？<br>考察点：session<br>参考回答：<br>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线<br>程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将<br>SessionFactory 通过单例模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象<br>（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。Session 是由<br>SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接<br>口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的<br>session，可以使用 ThreadLocal 将 session 和当前线程绑定在一起，这样可以让同一个线程获<br>得的总是同一个 session。Hibernate 3 中 SessionFactory 的 getCurrentSession()方法就可以<br>做到。<br>NOWCODER.COM<br>2、Hibernate 中 Session 的 load 和 get 方法的区别是什么？<br>考察点：请求方式<br>参考回答：<br>主要有以下三项区别：<br>① 如果没有找到符合条件的记录，get 方法返回 null，load 方法抛出异常。<br>② get 方法直接返回实体类对象，load 方法返回实体类对象的代理。<br>③ 在 Hibernate 3 之前，get 方法只在一级缓存中进行数据查找，如果没有找到对应的数据则<br>越过二级缓存，直接发出 SQL 语句完成数据读取；load 方法则可以从二级缓存中获取数据；从<br>Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。<br>对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加<br>载，如果没有数据就抛出异常，而通过 get()方法获取的数据可以不存在。<br>3、如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session<br>关闭的矛盾是如何处理的？<br>考察点：hibernate 框架<br>参考回答：<br>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate<br>使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load()方法加载数据或者一对多关联<br>映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给<br>用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据<br>库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。<br>延迟加载与 session 关闭的矛盾一般可以这样处理：<br>① 关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通<br>过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or<br>session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询<br>的开销都会变得很大。<br>② 在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized()<br>判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize()方法加载对象。<br>③ 使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提<br>供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。<br>4、简述 Hibernate 常见优化策略。<br>考察点：Hibernate<br>参考回答：<br>①制定合理的缓存策略（二级缓存、查询缓存）。<br>② 采用合理的 Session 管理机制。<br>③ 尽量使用延迟加载特性。<br>④ 设定合理的批处理参数。<br>⑤ 如果可以，选用 UUID 作为主键生成器。<br>⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。<br>⑦ 在开发过程中, 开启 hibernate.show_sql 选项查看生成的 SQL，从而了解底层的状况；开发<br>完成后关闭此选项。<br>NOWCODER.COM<br>⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观<br>的提升，但这些需要专业的 DBA（数据库管理员）提供支持。<br>5、锁机制有什么用？简述 Hibernate 的悲观锁和乐观锁机制。<br>考察点：锁<br>参考回答：<br>有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此<br>过程中数据被锁住不会被外界修改，这就是所谓的锁机制。<br>Hibernate 支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极<br>有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理<br>的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，<br>乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过<br>更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐<br>观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加 1，<br>然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的<br>当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate 中通过 Session 的 get()和<br>load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加<br>整型的版本字段再通过 XML 或@Version 注解进行配置。<br>使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了<br>空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间<br>换时间的策略。 ③HQL 查询、条件查询、SQL 查询<br>1、Hibernate 如何实现分页查询？<br>考察点：框架<br>参考回答：<br>通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()<br>方法）或查询条件（调用 Session 的 createCriteria()方法）、设置查询起始行数（调用 Query<br>或 Criteria 接口的 setFirstResult()方法）和最大查询行数（调用 Query 或 Criteria 接口的<br>setMaxResults()方法），并调用 Query 或 Criteria 接口的 list()方法，Hibernate 会自动生成<br>分页查询的 SQL 语句。 ④二级缓存与查询缓存<br>1、谈一谈 Hibernate 的一级缓存、二级缓存和查询缓存。<br>考察点：缓存<br>参考回答：<br>NOWCODER.COM<br>Hibernate 的 Session 提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实<br>体、修改持久化实体时，Session 并不会立即把这种改变提交到数据库，而是缓存在当前的<br>Session 中，除非显示调用了 Session 的 flush()方法或通过 close()方法关闭 Session。通过一<br>级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。<br>SessionFactory 级别的二级缓存是全局性的，所有的 Session 可以共享这个二级缓存。不过二<br>级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供<br>的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory 就会缓<br>存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。<br>一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓<br>存，可以使用查询缓存。查询缓存是将 HQL 或 SQL 语句以及它们的查询结果作为键值对进行缓存，<br>对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。<br>3、Struts<br>①MVC 模式与 Struts 体系<br>1、说说 STRUTS 的应用<br>考察点：STRUTS 架构<br>参考回答：<br>Struts 是采用 Java Servlet&#x2F;JavaServer Pages 技术，开发 Web 应用程序的开放源码的<br>framework。采用 Struts 能开发出基于 MVC(Model-View-Controller)设计模式的应用构架。<br>Struts 有如下的主要功能：<br>包含一个 controller servlet，能将用户的请求发送到相应的 Action 对象。二.JSP 自由<br>tag 库，并且在 controller servlet 中提供关联支持，帮助开发员创建交互式表单应用。<br>提供了一系列实用对象：XML 处理、通过 Java reflection APIs 自动处理 JavaBeans 属性、<br>国际化的提示和消息。<br>4、Mybatis<br>1、解释一下 MyBatis 中命名空间（namespace）的作用。<br>考察点：Mybatis<br>参考回答：<br>在大型项目中，可能存在大量的 SQL 语句，这时候为每个 SQL 语句起一个唯一的标识（ID）<br>就变得并不容易了。为了解决这个问题，在 MyBatis 中，可以为每个映射文件起一个唯一的命名<br>空间，这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只<br>要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不<br>会再产生冲突了。<br>NOWCODER.COM<br>2、MyBatis 中的动态 SQL 是什么意思？<br>考察点：SQL<br>参考回答：<br>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，<br>需要根据用户指定的条件动态生成 SQL 语句。如果不使用持久层框架我们可能需要自己拼装 SQL<br>语句，还好 MyBatis 提供了动态 SQL 的功能来解决这个问题。MyBatis 中用于实现动态 SQL 的元<br>素主要有：</li>
<li>if</li>
<li>choose &#x2F; when &#x2F; otherwise</li>
<li>trim</li>
<li>where</li>
<li>set</li>
<li>foreach<br>5、MVC<br>1、Spring MVC 注解的优点<br>考察点：spring mvc<br>参考回答：<br>1、XML 配置起来有时候冗长，此时注解可能是更好的选择，如 jpa 的实体映射；注解在处<br>理一些不变的元数据时有时候比 XML 方便的多，比如 springmvc 的数据绑定，如果用 xml 写的代<br>码会多的多；<br>2、注解最大的好处就是简化了 XML 配置；其实大部分注解一定确定后很少会改变，所以在<br>一些中小项目中使用注解反而提供了开发效率，所以没必要一头走到黑；<br>3、注解相对于 XML 的另一个好处是类型安全的，XML 只能在运行期才能发现问题。<br>2、springmvc 和 spring-boot 区别？<br>考察点：spring<br>参考回答：<br>总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA 等等。但<br>他们的基础都是 Spring 的 IOC 和 AOP，IOC 提供了依赖注入的容器，而 AOP 解决了面向切面的<br>编程，然后在此两者的基础上实现了其他衍生产品的高级功能；因为 Spring 的配置非常复杂，<br>各种 xml，properties 处理起来比较繁琐。于是为了简化开发者的使用，Spring 社区创造性地<br>推出了 Spring Boot，它遵循约定优于配置，极大降低了 Spring 使用门槛，<br>但又不失 Spring 原本灵活强大的功能。<br>3、SpringMVC 的运行机制，运行机制的每一部分的相关知识？<br>考察点：spring<br>NOWCODER.COM<br>参考回答：<br>1、用户发送请求时会先从 DispathcherServler 的 doService 方法开始，在该方法中会将<br>ApplicationContext、localeResolver、themeResolver 等对象添加到 request 中，紧接着就是<br>调用 doDispatch 方法。<br>2、进入该方法后首先会检查该请求是否是文件上传的请求(校验的规则是是否是 post 并且<br>contenttType 是否为 multipart&#x2F;为前缀)即调用的是 checkMultipart 方法；如果是的将 request<br>包装成 MultipartHttpServletRequest。<br>3、然后调用 getHandler 方法来匹配每个 HandlerMapping 对象，如果匹配成功会返回这个<br>Handle 的处理链 HandlerExecutionChain 对象，在获取该对象的内部其实也获取我们自定定义<br>的拦截器，并执行了其中的方法。<br>4、执行拦截器的 preHandle 方法，如果返回 false 执行 afterCompletion 方法并理解返回<br>5、通过上述获取到了 HandlerExecutionChain 对象，通过该对象的 getHandler()方法获得<br>一个 object 通过 HandlerAdapter 进行封装得到 HandlerAdapter 对象。<br>6、该对象调用 handle 方法来执行 Controller 中的方法，该对象如果返回一个 ModelAndView 给 DispatcherServlet。<br>7、DispatcherServlet借助ViewResolver完成逻辑试图名到真实视图对象的解析，得到View 后 DispatcherServlet 使用这个 View 对 ModelAndView 中的模型数据进行视图渲染。</li>
</ul>
<p>6、各框架对比与项目优化<br>1、Mybatis 和 Hibernate 区别？<br>NOWCODER.COM<br>考察点：Spring 框架<br>参考回答：1.  简介<br>Hibernate：Hibernate 是当前最流行的 ORM 框架之一，对 JDBC 提供了较为完整的封装。<br>Hibernate 的 O&#x2F;R Mapping 实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。<br>Mybatis：Mybatis 同样也是非常流行的 ORM 框架，主要着力点在于 POJO 与 SQL 之间的映<br>射关系。然后通过映射配置文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO 。<br>相对 Hibernate“O&#x2F;R”而言，Mybatis 是一种“Sql Mapping”的 ORM 实现。<br>2、缓存机制对比<br>相同点<br>Hibernate 和 Mybatis 的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己<br>的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。<br>不同点<br>Hibernate 的二级缓存配置在 SessionFactory 生成的配置文件中进行详细配置，然后再在<br>具体的表-对象映射中配置是那种缓存。<br>MyBatis 的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的<br>表可以自定义不同的缓存机制。并且 Mybatis 可以在命名空间中共享相同的缓存配置和实例，通<br>过 Cache-ref 来实现。<br>两者比较<br>因为 Hibernate 对查询对象有着良好的管理机制，用户无需关心 SQL。所以在使用二级缓存<br>时如果出现脏数据，系统会报出错误并提示。而 MyBatis 在这一方面，使用二级缓存时需要特别<br>小心。如果不能完全确定数据更新操作的波及范围，避免 Cache 的盲目使用。否则，脏数据的出<br>现会给系统的正常运行带来很大的隐患。<br>Mybatis：小巧、方便、高效、简单、直接、半自动化<br>Hibernate：强大、方便、高效、复杂、间接、全自动化<br>2、介绍一下你了解的 Java 领域的 Web Service 框架。<br>考察点：框架<br>参考回答：<br>Java 领域的 Web Service 框架很多，包括 Axis2（Axis 的升级版本）、Jersey（RESTful<br>的 Web Service 框架）、CXF（XFire 的延续版本）、Hessian、Turmeric、JBoss SOA 等，其中<br>绝大多数都是开源框架。<br>NOWCODER.COM<br>7、JPA<br>①EJB<br>1、EJB 是基于哪些技术实现的？并说出 SessionBean 和 EntityBean 的区别，<br>StatefulBean 和 StatelessBean 的区别。<br>考察点：JAVA EJB<br>参考回答：<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技<br>术实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用<br>其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象<br>视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种<br>的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的<br>实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是<br>说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会<br>消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者<br>的状态。<br>2、EJB 与 JAVA BEAN 的区别？<br>考察点：EJB<br>参考回答：<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java<br>类都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所以<br>Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于<br>实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，它是不<br>能被跨进程访问的。EnterpriseJava Bean 相当于 DCOM，即分布式组件。它是基于 Java 的远程<br>方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。但 EJB 必须被布署<br>在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正的 EJB 组件，而是通过<br>其容器访问。EJB 容器是 EJB 组件的代理， EJB 组件由容器所创建和管理。客户通过容器来访问<br>真正的 EJB 组件。<br>3、EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事<br>务的？<br>考察点：JAVA EJB<br>NOWCODER.COM<br>参考回答：<br>SessionBean： Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求<br>要建立一个 Bean 的实例时，EJB 容器不一定<br>要创建一个新的 Bean 的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户<br>机第一次调用一个 Stateful Session<br>Bean 时，容器必须立即在服务器中创建一个新的 Bean 实例，并关联到客户机上，以后此客户机<br>调用 Stateful Session Bean 的方法<br>时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不<br>是按照应用程序或者服务进程来说的。即使 EJB 容器崩溃了，Entity beans 也是存活的。Entity<br>Beans 生命周期能够被容器或者<br>Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、<br>Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。<br>4、EJB 的角色和三个对象是什么？<br>考察点：EJB<br>参考回答：<br>一个完整的基于 EJB 的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提<br>供，每个角色所作的工作必须遵循 Sun 公司<br>提供的 EJB 规范，以保证彼此之间的兼容性。这六个角色分别是 EJB 组件开发者（Enterprise Bean<br>Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供<br>者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System<br>Administrator）<br>三个对象是 Remote（Local）接口、Home（LocalHome）接口，Bean 类<br>5、说说 EJB 规范规定 EJB 中禁止的操作有哪些？<br>考察点：EJB<br>参考回答：<br>1.不能操作线程和线程 API(线程 API 指非线程对象的方法如 notify,wait 等)，<br>2.不能操作 awt，<br>3.不能实现服务器功能，<br>4.不能对静态属生存取，<br>5.不能使用 IO 操作直接存取文件系统，<br>6.不能加载本地库.，<br>7.不能将 this 作为变量和返回，<br>NOWCODER.COM<br>8.不能循环调用。<br>6、EJB 的激活机制是什么？<br>考察点：EJB<br>参考回答：<br>以 Stateful Session Bean 为例：其 Cache 大小决定了内存中可以同时存在的 Bean 实例的<br>数量，根据 MRU 或 NRU 算法，实例在激活和去<br>激活状态之间迁移，激活机制是当客户端调用某个 EJB 实例业务方法时，如果对应 EJB Object<br>发现自己没有绑定对应的 Bean 实例则从<br>其去激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。<br>7、EJB 的几种类型分别是什么<br>考察点：EJB<br>参考回答：<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean，会话<br>Bean 又可分为有状态（Stateful）和无状态（Stateless）两种，<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种。<br>8、EJB 需直接实现它的业务接口或 Home 接口吗，请简述理由。<br>考察点：EJB<br>参考回答：<br>在 EJB 中则至少要包括 10 个 class:<br>Bean 类，特定 App Server 的 Bean 实现类 Bean 的 remote 接口，特定 App Server 的 remote 接<br>口实现类，特定 App Server 的 remote 接口的实现类的 stub 类和 skeleton 类。<br>Bean 的 home 接口，特定 App Server 的 home 接口实现类，特定 App Server 的 home 接口的实现<br>类的 stub 类和 skeleton 类。<br>和 RMI 不同的是，EJB 中这 10 个 class 真正需要用户写的只有 3 个，Bean 类，remote 接口，home<br>接口，其它的 7 个究竟怎么生成，被打包在哪里，是否需要更多的类文件，否根据不同的 App<br>Server 表现出较大的差异。<br>Weblogic：<br>home 接口和 remote 接口的 weblogic 的实现类的 stub 类和 skeleton 类是在 EJB 被部署到<br>weblogic 的时候，由 weblogic 动态生成 stub 类和 skeleton 类的字节码，所以看不到这 4 个类<br>文件。<br>对于一次客户端远程调用 EJB，要经过两个远程对象的多次 RMI 循环。首先是通过 JNDI 查找 Home<br>接口，获得 Home 接口的实现类，这个过程其实相当复杂，首先是找到 Home 接口的 Weblogic 实<br>现类，然后创建一个 Home 接口的 Weblogic 实现类的 stub 类的对象实例，将它序列化传送给客<br>户端（注意 stub 类的实例是在第 1 次 RMI 循环中，由服务器动态发送给客户端的，因此不需要<br>客户端保存 Home 接口的 Weblogic 实现类的 stub 类），最后客户端获得该 stub 类的对象实例<br>（普通的 RMI 需要在客户端保存 stub 类，而 EJB 不需要，因为服务器会把 stub 类的对象实例发<br>送给客户端）。<br>客户端拿到服务器给它的 Home 接口的 Weblogic 实现类的 stub 类对象实例以后，调用 stub 类的<br>NOWCODER.COM<br>create 方法， (在代码上就是 home.create()，但是后台要做很多事情),于是经过第 2 次 RMI<br>循环，在服务器端，Home 接口的 Weblogic 实现类的 skeleton 类收到 stub 类的调用信息后，由<br>它再去调用 Home 接口的 Weblogic 实现类的 create 方法。<br>在服务端， Home 接口的 Weblogic 实现类的 create 方法再去调用 Bean 类的 Weblogic 实现类的<br>ejbCreate 方法，在服务端创建或者分配一个 EJB 实例，然后将这个 EJB 实例的远程接口的<br>Weblogic 实现类的 stub 类对象实例序列化发送给客户端。 三、Java web 编程<br>1、web 编程基础<br>①Tomcat 服务器<br>1、启动项目时如何实现不在链接里输入项目名就能启动?<br>考察点：tomcat<br>参考回答：<br>可在 taomcat 配置虚拟目录。<br>2、1 分钟之内只能处理 1000 个请求，你怎么实现，手撕代码?<br>考察点：tomcat<br>参考回答：<br>限流的几种方法：计数器，滑动窗口、漏桶法、令牌桶<br>3、什么时候用 assert<br>考察点：JAVA 调试<br>参考回答：<br>assertion (断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。<br>在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的<br>状态下，系统将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正确性。<br>assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常<br>是关闭的。<br>4、JAVA 应用服务器有那些？<br>考察点：服务器<br>参考回答：<br>NOWCODER.COM<br>BEA WebLogic Server，<br>IBM WebSphere Application Server，<br>Oracle9i Application Server<br>jBoss，<br>Tomcat<br>5、说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的<br>helloWorld.jsp 放入何目录下,然后在浏览器上就可打入主机？<br>考察点：目录结构<br>参考回答：<br>端口号&#x2F;&#x2F;helloword.jsp 就可以看到运行结果了? 又比如这其中用到了一个自己写的<br>javaBean 该如何办?<br>NOWCODER.COM<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果是<br>Web 应用，应用目录需要满足 Web 应用<br>目录要求，jsp 文件可以直接放在应用目录中，Javabean 需要放在应用目录的 WEB-INF 目录的<br>classes 目录中，设置服务器的缺省应用<br>将可以实现在浏览器上无需输入应用名。<br>6、jsp 有哪些动作?作用分别是什么?<br>考察点：JSP<br>参考回答：<br>JSP 共有以下 6 种基本动作 jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>jsp:setProperty：设置 JavaBean 的属性。 jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。<br>8、说一下表达式语言（EL）的隐式对象及其作用<br>考察点：EL<br>NOWCODER.COM<br>参考回答：<br>EL 的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、<br>paramValues、header（访问请求头）、headerValues、cookie（访问 cookie）、applicationScope<br>（访问 application 作用域）、sessionScope（访问 session 作用域）、requestScope（访问 request<br>作用域）、pageScope（访问 page 作用域）。<br>9、JSP 中的静态包含和动态包含有什么区别？<br>考察点：JSP<br>参考回答：<br>静态包含是通过 JSP 的 include指令包含页面，动态包含是通过 JSP 标准动作<a href="jsp:forward">jsp:forward</a><br>包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的<br>“contentType”属性应保持一致，因为两个页面会合二为一，只产生一个 class 文件，因此被包<br>含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含<br>的页面传递参数，包含页面和被包含页面是独立的，会编译出两个 class 文件，如果被包含的页<br>面不存在，不会产生编译错误，也不影响页面其他部分的执行。<br>例如：&lt;%– 静态包含 –%&gt;<br>&lt;%@ include file&#x3D;”…” %&gt;<br>&lt;%– 动态包含 –%&gt;<br>&lt;jsp:include page&#x3D;”…”&gt;<br>&lt;jsp:param name&#x3D;”…” value&#x3D;”…” &#x2F;&gt;<br>&lt;&#x2F;jsp:include&gt;<br>③Listener 和 Filter<br>1、过滤器有哪些作用和用法？<br>考察点：过滤器<br>参考回答：<br>Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在 Servlet<br>2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web 组件，它可以截取<br>客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当 Web 容器接受到一个对资源<br>的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进<br>行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发<br>送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器<br>中你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、<br>对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求<br>或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT 等。<br>和过滤器相关的接口主要有：Filter、FilterConfig 和 FilterChain。<br>3、说说 web.xml 文件中可以配置哪些内容？<br>考察点：xml 文件<br>参考回答：<br>web.xml 用于配置 Web 应用的相关信息，如：监听器（listener）、过滤器（filter）、Servlet、<br>相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：<br>①配置 Spring 上下文加载监听器加载 Spring 配置文件并创建 IoC 容器：<br>&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; &lt;listener&gt; &lt;listener-class&gt;<br>org.springframework.web.context.ContextLoaderListener &lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt;<br>②配置 Spring 的 OpenSessionInView 过滤器来解决延迟加载和 Hibernate 会话关闭的矛盾： &lt;filter&gt; &lt;filter-name&gt;openSessionInView&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;<br>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter &lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;<br>NOWCODER.COM<br>③配置会话超时时间为 10 分钟： &lt;session-config&gt; &lt;session-timeout&gt;10&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt;<br>④配置 404 和 Exception 的错误页面： &lt;error-page&gt; &lt;error-code&gt;404&lt;&#x2F;error-code&gt; &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;&#x2F;exception-type&gt; &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt;<br>⑤配置安全认证方式： &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;ProtectedArea&lt;&#x2F;web-resource-name&gt; &lt;url-pattern&gt;&#x2F;admin&#x2F;<em>&lt;&#x2F;url-pattern&gt; &lt;http-method&gt;GET&lt;&#x2F;http-method&gt; &lt;http-method&gt;POST&lt;&#x2F;http-method&gt; &lt;&#x2F;web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;&#x2F;role-name&gt; &lt;&#x2F;auth-constraint&gt; &lt;&#x2F;security-constraint&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;&#x2F;auth-method&gt; &lt;&#x2F;login-config&gt; &lt;security-role&gt; &lt;role-name&gt;admin&lt;&#x2F;role-name&gt; &lt;&#x2F;security-role&gt;<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>1、forward 与 redirect 区别，说一下你知道的状态码，redirect 的状态码是多<br>少？<br>考察点：Servlet<br>参考回答：<br>1.从地址栏显示来说<br>NOWCODER.COM<br>forward 是服务器请求资源,服务器直接访问目标地址的 URL,把那个 URL 的响应内容读取过<br>来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地<br>址栏还是原来的地址.<br>redirect 是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址<br>栏显示的是新的 URL.<br>2.从数据共享来说<br>forward:转发页面和转发到的页面可以共享 request 里面的数据.<br>redirect:不能共享数据.<br>3.从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.<br>4.从效率来说<br>forward:高.<br>redirect:低.<br>redirect 的状态码是 302<br>2、servlet 生命周期，是否单例，为什么是单例。<br>考察点：servlet<br>参考回答：<br>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：<br>Servlet 通过调用 init () 方法进行初始化。<br>Servlet 调用 service() 方法来处理客户端的请求。<br>Servlet 通过调用 destroy() 方法终止（结束）。<br>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。<br>Servlet 单实例，减少了产生 servlet 的开销；<br>3、说出 Servlet 的生命周期，并说出 Servlet 和 CGI 的区别。<br>考察点：servlet<br>参考回答：<br>NOWCODER.COM<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，<br>service 方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实<br>例销毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个实<br>例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，服务完<br>成后就销毁，所以效率上低于 servlet。<br>4、Servlet 执行时一般实现哪几个方法？<br>考察点：servlet<br>参考回答：<br>public void init(ServletConfig config)<br>public ServletConfig getServletConfig()<br>public String getServletInfo()<br>public void service(ServletRequest request,ServletResponse response)<br>public void destroy()<br>init ()方法在 servlet 的生命周期中仅执行一次，在服务器装载 servlet 时执行。缺省的 init()<br>方法通常是符合要求的，不过也可以根据需要进行 override，比如管理服务器端资源，一次性<br>装入 GIF 图像，初始化数据库连接等，缺省的 inti()方法设置了 servlet 的初始化参数，并用<br>它的 ServeltConfig 对象参数来启动配置，所以覆盖 init()方法时，应调用 super.init()以确<br>保仍然执行这些任务。service ()方法是 servlet 的核心，在调用 service()方法之前，应确保<br>已完成 init()方法。对于 HttpServlet，每当客户请求一个 HttpServlet 对象，该对象的 service()<br>方法就要被调用，HttpServlet 缺省的 service()方法的服务功能就是调用与 HTTP 请求的方法<br>相应的 do 功能，doPost()和 doGet()，所以对于 HttpServlet，一般都是重写 doPost()和 doGet()<br>方法。destroy()方法在 servlet 的生命周期中也仅执行一次，即在服务器停止卸载 servlet 时<br>执行，把 servlet 作为服务器进程的一部分关闭。缺省的 destroy()方法通常是符合要求的，但<br>也可以 override，比如在卸载 servlet 时将统计数字保存在文件中，或是关闭数据库连接<br>getServletConfig()方法返回一个 servletConfig 对象，该对象用来返回初始化参<br>servletContext。servletContext 接口提供有关 servlet 的环境信息。getServletInfo()方法<br>提供有关 servlet 的信息，如作者，版本，版权。<br>5、阐述一下阐述 Servlet 和 CGI 的区别?<br>考察点：servlet<br>参考回答：<br>Servlet与 CGI 的区别在于 Servlet 处于服务器进程中，它通过多线程方式运行其 service()<br>方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的<br>进程，服务完成后就销毁，所以效率上低于 Servlet。<br>6、说说 Servlet 接口中有哪些方法？<br>考察点：Servlet 接口<br>参考回答：<br>NOWCODER.COM<br>Servlet 接口定义了 5 个方法，其中前三个方法与 Servlet 生命周期相关：</em>   void init(ServletConfig config) throws ServletException</p>
<ul>
<li>void service(ServletRequest req, ServletResponse resp) throws ServletException,<br>java.io.IOException</li>
<li>void destory()</li>
<li>java.lang.String getServletInfo()</li>
<li>ServletConfig getServletConfig()<br>Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init()方法进行<br>Servlet 的初始化；请求到达时调用 Servlet 的 service()方法，service()方法会根据需要调用<br>与请求对应的 doGet 或 doPost 等方法；当服务器关闭或项目被卸载时服务<br>器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy()方法。<br>7、Servlet 3 中的异步处理指的是什么？<br>考察点：servlet<br>参考回答：<br>在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然<br>都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那<br>么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将<br>会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝<br>服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行<br>时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交<br>给 Executor 并立即返回即可。</li>
</ul>
<p>8、如何在基于 Java 的 Web 项目中实现文件上传和下载？<br>考察点：文件传输<br>参考回答：<br>在 Sevlet 3 以前，Servlet API 中没有支持上传功能的 API，因此要实现上传功能需要引<br>入第三方工具从 POST 请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们<br>推荐使用 Apache 的 commons-fileupload。<br>从 Servlet 3 开始，文件上传变得简单许多。</p>
<p>9、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()<br>方法？<br>考察点：servlet<br>参考回答：<br>HTML 的&lt;form&gt;元素有一个 method 属性，用来指定提交表单的方式，其值可以是 get 或 post。<br>我们自定义的 Servlet 一般情况下会重写 doGet()或 doPost()两个方法之一或全部，如果是 GET<br>请求就调用 doGet()方法，如果是 POST 请求就调用 doPost()方法，那为什么为什么这样呢？我<br>们自定义的 Servlet 通常继承自 HttpServlet，HttpServlet 继承自 GenericServlet 并重写了其<br>中的 service()方法，这个方法是 Servlet 接口中定义的。HttpServlet 重写的 service()方法<br>会先获取用户请求的方法，然后根据请求方法调用 doGet()、doPost()、doPut()、doDelete()<br>等方法，如果在自定义 Servlet 中重写了这些方法，那么显然会调用重写过的（自定义的）方法，<br>这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java 与模式》一书的第 37<br>章）。当然，自定义 Servlet 中也可以直接重写 service()方法，那么不管是哪种方式的请求，<br>都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。<br>10、Servlet 中如何获取用户提交的查询参数或表单数据？<br>考察点：servlet<br>参考回答：<br>可以通过请求对象（HttpServletRequest）的 getParameter()方法通过参数名获得参数值。<br>如果有包含多个值的参数（例如复选框），可以通过请求对象的 getParameterValues()方法获<br>得。当然也可以通过请求对象的 getParameterMap()获得一个参数名和参数值的映射（Map）。<br>11、Servlet 中如何获取用户配置的初始化参数以及服务器上下文参数？<br>考察点：初始化<br>参考回答：<br>可以通过重写 Servlet 接口的 init(ServletConfig)方法并通过 ServletConfig 对象的<br>getInitParameter()方法来获取 Servlet 的初始化参数。可以通过 ServletConfig 对象的<br>getServletContext()方法获取 ServletContext 对象，并通过该对象的 getInitParameter()方<br>法来获取服务器上下文参数。当然，ServletContext 对象也在处理用户请求的方法（如 doGet()<br>方法）中通过请求对象的 getServletContext()方法来获得。<br>NOWCODER.COM</p>
<p>3、请问 Java Web 开发的 Model 1 和 Model 2 分别指的是什么？<br>考察点：Model<br>参考回答：<br>Model 1 是以页面为中心的 Java Web 开发，使用 JSP+JavaBean 技术将页面显示逻辑和业务<br>逻辑处理分开，JSP 实现页面显示，JavaBean 对象用来保存数据和实现业务逻辑。Model 2 是基<br>于 MVC（模型-视图-控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视<br>图的彻底分离，利于团队开发和代码复用。 ④JSTL、DisplayTag 等常见标签库的用法<br>1、你的项目中使用过哪些 JSTL 标签？<br>考察点：JSTL<br>参考回答：<br>项目中主要使用了 JSTL 的核心标签库，包括&lt;c:if&gt;、&lt;c:choose&gt;、&lt;c: when&gt;、&lt;c: otherwise&gt;、<br>&lt;c:forEach&gt;等，主要用于构造循环和分支结构以控制显示逻辑。<br>虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库，但是实际开发中建议只使用核心<br>标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到<br>数据显示和业务逻辑的分离，这才是最佳实践。<br>2、使用标签库有什么好处？如何自定义 JSP 标签？（JSP 标签）<br>考察点：JSP 标签<br>参考回答：<br>使用标签库的好处包括以下几个方面：</p>
<ul>
<li>分离 JSP 页面的内容和逻辑，简化了 Web 开发；</li>
<li>开发者可以创建自定义标签来封装业务逻辑和显示逻辑；</li>
<li>标签具有很好的可移植性、可维护性和可重用性；</li>
<li>避免了对 Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在 JSP 中书写小脚本）<br>编写一个 Java 类实现实现 Tag&#x2F;BodyTag&#x2F;IterationTag 接口（开发中通常不直接实现这些<br>接口而是继承 TagSupport&#x2F;BodyTagSupport&#x2F;SimpleTagSupport 类，这是对缺省适配模式的应用），<br>重写 doStartTag()、doEndTag()等方法，定义标签要完成的功能：<br>NOWCODER.COM</li>
<li>编写扩展名为 tld 的标签描述文件对自定义标签进行部署，tld 文件通常放在 WEB-INF 文件夹<br>下或其子目录中</li>
<li>在 JSP 页面中使用 taglib 指令引用该标签库<br>3、Web 编程原理<br>①HTTP 协议<br>1、get 和 post 区别？<br>考察点：HTTP 请求<br>参考回答：<br>（1）在客户端， Get 方式在通过 URL 提交数据，数据 在 URL 中可以看到；POST 方式，数据<br>放置在 HTML HEADER 内提交。<br>（2）GET 方式提交的数据最多只能有 1024 字节，而 POST 则没有此限制。<br>（3）安全性问题。正如在（ 1 ）中提到，使用 Get 的时候，参数会显示在地址栏上，<br>而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get ；如果<br>用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post 为好。<br>安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同<br>一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，<br>GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从<br>自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的<br>一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。<br>POST 请求就不那么轻松了。 POST 表示可能改变服务器上的资源的请求。仍然以新闻站点<br>为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比<br>方说文章下面出现一条注解）。</li>
</ul>
<p>3、BS 与 CS 的联系与区别。<br>考察点：客户端&#x2F;服务器模式<br>NOWCODER.COM<br>参考回答：<br>C&#x2F;S 是 Client&#x2F;Server 的缩写。服务器通常采用高性能的 PC、工作站或小型机，并采用大型<br>数据库系统，如 Oracle、Sybase、Informix 或 SQL Server。客户端需要安装专用的客户端软件。<br>B&#x2F;Ｓ是 Brower&#x2F;Server 的缩写，客户机上只要安装一个浏览器（Browser），如 Netscape Navigator<br>或 Internet Explorer，服务器安<br>装 Oracle、Sybase、Informix 或 SQL Server 等数据库。在这种结构下，用户界面完全通过 WWW<br>浏览器实现，一部分事务逻辑在前端实<br>现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C&#x2F;S 与 B&#x2F;S 区别：<br>硬件环境不同:<br>C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供<br>连接和数据交换服务.<br>B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自<br>己管理. 有比 C&#x2F;S 更强的适应范围, 一<br>般只要有操作系统和浏览器就行<br>２．对安全要求不同<br>C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统<br>采用 C&#x2F;S 结构适宜. 可以通过 B&#x2F;S 发布<br>部分可公开信息.<br>B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同<br>C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.<br>B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比 C&#x2F;S 有更高<br>的要求 B&#x2F;S 结构的程序架构是发展的趋<br>势, 从 MS 的.Net 系列的 BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN<br>和 IBM 推的 JavaBean 构件技术等,使<br>B&#x2F;S 更加成熟. ４．软件重用不同<br>C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在 B&#x2F;S 要求下的构件的重用性好.<br>B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以<br>再利用,而不是做在墙上的石头桌子<br>５．系统维护不同<br>C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再<br>做一个全新的系统<br>B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从<br>网上自己下载安装就可以实现升级. ６．处理问题不同<br>C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应<br>该都是相同的系统<br>B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是 C&#x2F;S 无法作到的. 与操作系统<br>平台关系最小. ７．用户接口不同<br>C&#x2F;S 多是建立的 Window 平台上,表现方法有限,对程序员普遍要求较高<br>B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减<br>低开发成本. ８．信息流不同<br>C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低<br>B&#x2F;S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。<br>NOWCODER.COM<br>4、如何设置请求的编码以及响应内容的类型？<br>考察点：请求类型<br>参考回答：<br>通过请求对象（ServletRequest）的 setCharacterEncoding(String)方法可以设置请求的<br>编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java 程序都使用统一的<br>编码，最好的选择当然是 UTF-8；通过响应对象（ServletResponse）的 setContentType(String)<br>方法可以设置响应内容的类型，当然也可以通过 HttpServletResponsed 对象的<br>setHeader(String, String)方法来设置。<br>5、什么是 Web Service（Web 服务）？<br>考察点：web service<br>参考回答：<br>从表面上看，Web Service 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用<br>的 API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，<br>跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的 Web Service，那么无论你<br>用哪种编程语言开发的应用都可以通过调用它的 API 并传入城市信息来获得该城市的天气预报。<br>之所以称之为 Web Service，是因为它基于 HTTP 协议传输数据，这使得运行在不同机器上的不<br>同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。<br>SOA（Service-Oriented Architecture，面向服务的架构），SOA 是一种思想，它将应用程<br>序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种<br>形式的功能单元能够更好的集成。显然，Web Service 是 SOA 的一种较好的解决方案，它更多的<br>是一种标准，而不是一种具体的技术。<br>6、谈谈 Session 的 save()、update()、merge()、lock()、saveOrUpdate()和<br>persist()方法分别是做什么的？有什么区别？<br>考察点：session<br>参考回答：<br>Hibernate 的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态<br>（detached），如第 135 题中的图所示。瞬时态的实例可以通过调用 save()、persist()或者<br>saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()<br>或者 replicate()变成持久态。save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()<br>或 merge()会引发 UPDATE 语句。save()和 update()的区别在于一个是将瞬时态对象变成持久态，<br>一个是将游离态对象变为持久态。merge()方法可以完成 save()和 update()方法的功能，它的意<br>图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于 persist()方法，按照<br>官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填<br>入到持久化实例中，标识符的填入可能被推迟到 flush 的时间；② persist()方法保证当它在一<br>个事务外部被调用的时候并不触发一个 INSERT 语句，当需要封装一个长会话流程的时候，<br>persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执<br>行 INSERT 语句，不管是在事务内部还是外部。至于 lock()方法和 update()方法的区别，update()<br>方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱<br>管状态的对象变成持久状态。<br>NOWCODER.COM<br>7、大型网站在架构上应当考虑哪些问题？<br>考察点：Java 架构<br>参考回答：</p>
<ul>
<li>分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个<br>层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形<br>成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI&#x2F;RM）和 Internet 的 TCP&#x2F;IP<br>模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储<br>和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。<br>需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备<br>上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之<br>间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</li>
<li>分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚<br>低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模<br>块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另<br>一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</li>
<li>分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独<br>立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的<br>加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式<br>部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，<br>例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce<br>分布式计算框架来处理。</li>
<li>集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</li>
<li>缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓<br>存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。</li>
<li>异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，<br>二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影<br>响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用<br>Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能<br>推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</li>
<li>冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可<br>以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。 ③Web 容器<br>1、请对以下在 J2EE 中常用的名词进行解释(或简单描述)<br>考察点：J2EE<br>参考回答：<br>web 容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP,SERVLET<br>直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有 WEB 服务器来实现。例如：<br>TOMCAT,WEBLOGIC,WEBSPHERE 等。该容器提供的接口严格遵守 J2EE 规范中的 WEBAPPLICATION 标<br>准。我们把遵守以上标准的 WEB 服务器就叫做 J2EE 中的 WEB 容器。<br>Web container：实现 J2EE 体系结构中 Web 组件协议的容器。这个协议规定了一个 Web 组件运行<br>时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和 JSP 和<br>J2EE 平台 APIs 界面相同服务的容器。一个 Web container 由 Web 服务器或者 J2EE 服务器提供。<br>EJB 容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件 EJB<br>NOWCODER.COM<br>各种管理功能。只要满足 J2EE 规范的 EJB 放入该容器，马上就会被容器进行高效率的管理。并<br>且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了 J2EE 体<br>系结构中 EJB 组件规范的容器。这个规范指定了一个 Enterprise bean 的运行时环境，包括安全，<br>一致性，生命周期，事务，配置，和其他的服务。<br>JNDI：（Java Naming &amp; Directory Interface）JAVA 命名目录服务。主要提供的功能是：提供<br>一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布<br>式应用程序的功能。<br>JMS：（Java Message Service）JAVA 消息服务。主要实现各个应用程序之间的通讯。包括点对<br>点和广播。<br>JTA：（Java Transaction API）JAVA 事务服务。提供各种分布式事务服务。应用程序只需调用<br>其提供的接口即可。<br>JAF：（Java Action FrameWork）JAVA 安全认证框架。提供一些安全控制方面的框架。让开发<br>者通过各种部署和自定义实现自己的个性安全控制策略。<br>RMI&#x2F;IIOP: （Remote Method Invocation &#x2F;internet 对象请求中介协议）他们主要用于通过远<br>程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地<br>计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI<br>是 JAVA 特有的。RMI-IIOP 出现以前，只有 RMI 和 CORBA 两种选择来进行分布式程序设计。<br>RMI-IIOP 综合了 RMI 和 CORBA 的优点，克服了他们的缺点，使得程序员能更方便的编写分布式<br>程序设计，实现分布式计算。首先，RMI-IIOP 综合了 RMI 的简单性和 CORBA 的多语言性（兼容<br>性），其次 RMI-IIOP 克服了 RMI 只能用于 Java 的缺点和 CORBA 的复杂性。 四、JDBC 编程</li>
</ul>
<p>2、JDBC 基础<br>①数据库<br>1、数据库水平切分，垂直切分<br>考察点：数据库<br>参考回答：<br>NOWCODER.COM<br>垂直拆分就是要把表按模块划分到不同数据库表中（当然原则还是不破坏第三范式），这种<br>拆分在大型网站的演变过程中是很常见的。当一个网站还在很小的时候，只有小量的人来开发和<br>维护，各模块和表都在一起，当网站不断丰富和壮大的时候，也会变成多个子系统来支撑，这时<br>就有按模块和功能把表划分出来的需求。其实，相对于垂直切分更进一步的是服务化改造，说得<br>简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，<br>因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，淘宝在架构不断演<br>变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成独立<br>的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。<br>垂直拆分：单表大数据量依然存在性能瓶颈<br>水平拆分，上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量<br>的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。例如像计费<br>系统，通过按时间来划分表就比较合适，因为系统都是处理某一时间段的数据。而像 SaaS 应用，<br>通过按用户维度来划分数据比较合适，因为用户与用户之间的隔离的，一般不存在处理多个用户<br>数据的情况，简单的按 user_id 范围来水平切分。<br>通俗理解：水平拆分行，行数据拆分到不同表中， 垂直拆分列，表数据拆分到不同表中。</p>
<p>10、leftjoin 和 rightjoin 的区别？<br>考察点：表结构<br>参考回答：<br>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录<br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>比如：<br>表 A 记录如下：<br>aID aNum<br>1 a20050111<br>2 a20050112<br>3 a20050113<br>4 a20050114<br>5 a20050115<br>表 B 记录如下:<br>bID bName<br>1 2006032401<br>2 2006032402<br>3 2006032403<br>4 2006032404<br>8 2006032408<br>left join 是以 A 表的记录为基础的,A 可以看成左表,B 可以看成右表,left join 是以左表<br>为准的. 换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为:<br>A.aID &#x3D; B.bID).<br>B 表记录不足的地方均为 NULL. 11、数据库优化方法<br>考察点：数据库<br>参考回答：<br>（1）选取最适用的字段属性<br>MySQL 可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行<br>的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度<br>设得尽可能小。<br>例如，在定义邮政编码这个字段时，如果将其设置为 CHAR(255),显然给数据库增加了不必<br>要的空间，甚至使用 VARCHAR 这种类型也是多余的，因为 CHAR(6)就可以很好的完成任务了。同<br>样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段。<br>NOWCODER.COM<br>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为 NOTNULL，这样在将来<br>执行查询的时候，数据库不用去比较 NULL 值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL<br>中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。<br>这样，我们又可以提高数据库的性能。<br>（2）使用连接（JOIN）来代替子查询(Sub-Queries)<br>MySQL 从 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查<br>询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没<br>有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户 ID 取出<br>来，然后将结果传递给主查询<br>（3）使用联合(UNION)来代替手动创建的临时表<br>MySQL 从 4.0 的版本开始支持 union 查询，它可以把需要使用临时表的两条或更多的 select<br>查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据<br>库整齐、高效。使用 union 来创建查询的时候，我们只需要用 UNION 作为关键字把多个 select<br>语句连接起来就可以了，要注意的是所有 select 语句中的字段数目要想同。下面的例子就演示<br>了一个使用 UNION 的查询。<br>（4）事务<br>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样<br>的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时<br>候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句<br>运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两<br>个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，<br>造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。<br>要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失<br>败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以 BEGIN 关键字开始，COMMIT<br>关键字结束。在这之间的一条 SQL 操作失败，那么，ROLLBACK 命令就可以把数据库恢复到 BEGIN<br>开始之前的状态。<br>12、谈一下你对继承映射的理解。<br>考察点：映射<br>参考回答：<br>继承关系的映射策略有三种：<br>① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。<br>② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。<br>③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。<br>第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态<br>查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是<br>需要进行连接查询，不适合多态查询。<br>NOWCODER.COM<br>②数据库连接池<br>1、说出数据连接池的工作机制是什么?<br>考察点：连接池<br>参考回答：<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连<br>接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用<br>完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 ③事物管理，批处理<br>1、事务的 ACID 是指什么？<br>考察点：数据库<br>参考回答：</p>
<ul>
<li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导<br>致整个事务的失败； - 一致性(Consistent)：事务结束后系统状态是一致的； - 隔离性<br>(Isolated)：并发执行的事务彼此无法看到对方的中间状态； - 持久性(Durable)：事务完成后<br>所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建<br>数据。<br>关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，<br>只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括<br>3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类<br>丢失更新）。<br>2、JDBC 中如何进行事务处理？<br>考察点：数据库<br>参考回答：<br>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置手动提交事<br>务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中发生异常则通过 rollback()<br>进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代<br>码设置保存点并让事务回滚到指定的保存点。<br>NOWCODER.COM<br>3、JDBC 进阶<br>1、JDBC 的反射，反射都是什么？<br>考察点：jdbc<br>参考回答：<br>通过反射 com.mysql.jdbc.Driver 类，实例化该类的时候会执行该类内部的静态代码块，该<br>代码块会在 Java 实现的 DriverManager 类中注册自己,DriverManager 管理所有已经注册的驱动<br>类，当调用 DriverManager.geConnection 方法时会遍历这些驱动类，并尝试去连接数据库，只<br>要有一个能连接成功，就返回 Connection 对象，否则则报异常。</li>
</ul>
<p>4、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性<br>能？<br>考察点：JDBC 优化<br>NOWCODER.COM<br>参考回答：<br>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()方法指<br>定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用<br>PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。 五、XML 编程<br>1、XML 基础<br>1、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种<br>方式？<br>考察点：XML<br>参考回答：<br>a: 两种形式 dtd schema<br>b: 本质区别:schema 本身是 xml 的，可以被 XML 解析器解析(这也是从 DTD 上发展 schema 的根<br>本目的)<br>c:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这种结构占<br>用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML 的随机访问<br>SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文件，不需要一次全部装载<br>整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用<br>户通过在其回调事件中写入处理代码来处理 XML 文件，适合对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)<br>xml 文档有两种定义方法：<br>dtd：数据类型定义（data type definition），用以描述 XML 文档的文档结构，是早期的 XML<br>文档定义形式。<br>schema：其本身是基于 XML 语言编写的，在类型和语法上的限定能力比 dtd 强，处理也比较方便，<br>因为此正逐渐代替 dtd 成为新的模式定义语言。<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>1、WEB SERVICE 名词解释，JSWDL 开发包的介绍，JAXP、JAXM 的解释。SOAP、<br>UDDI,WSDL 解释。<br>考察点：web service<br>NOWCODER.COM<br>参考回答：<br>Web ServiceWeb Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 WebService 能与其他兼容的组件进行互操作。JAXP(Java API for<br>XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。这样在你的程序中你只要<br>使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。JAXM(Java API for XML<br>Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。WSDL 是一种 XML 格式，用于将网<br>络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格<br>式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。<br>相关的具体端点即组合成为抽象端点（服务）。SOAP 即简单对象访问协议(Simple Object Access<br>Protocol)，它是用于交换 XML 编码信息的轻量级协议。UDDI 的目的是为电子商务建立标准；UDDI<br>是一套基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范，同时也<br>包含一组使企业能将自身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标<br>准。soap 是 web service 最关键的技术，是 web service 中数据和方法调传输的介质。WSDL（web<br>service definition language）描述了 web service 的接口和功能。<br>2、请你谈谈对 SOAP、WSDL、UDDI 的了解？<br>考察点：协议&amp;语言<br>参考回答：</p>
<ul>
<li>SOAP：简单对象访问协议（Simple Object Access Protocol），是 Web Service 中交换<br>数据的一种协议规范。</li>
<li>WSDL：Web 服务描述语言（Web Service Description Language），它描述了 Web 服务的公共<br>接口。这是一个基于 XML 的关于如何与 Web 服务通讯和使用的服务描述；也就是描述与目录中列<br>出的 Web 服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作<br>和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。</li>
<li>UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它<br>是一个基于 XML 的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服<br>务。简单的说，UDDI 是访问各种 WSDL 的一个门面（可以参考设计模式中的门面模式）。<br>3、谈谈 Java 规范中和 Web Service 相关的规范有哪些？<br>考察点：规范<br>参考回答：<br>Java 规范中和 Web Service 相关的有三个：</li>
<li>JAX-WS(JSR 224)：这个规范是早期的基于 SOAP 的 Web Service 规范 JAX-RPC 的替代版本，它<br>并不提供向下兼容性，因为 RPC 样式的 WSDL 以及相关的 API 已经在 Java EE5 中被移除了。<br>WS-MetaData 是 JAX-WS 的依赖规范，提供了基于注解配置 Web Service 和 SOAP 消息的相关 API。</li>
<li>JAXM(JSR 67)：定义了发送和接收消息所需的 API,相当于 Web Service 的服务器端。</li>
<li>JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是 Java 针对 REST（Representation State Transfer）<br>架构风格制定的一套 Web Service 规范。REST 是一种软件架构模式，是一种风格，它不像 SOAP<br>那样本身承载着一种消息协议，(两种风格的 Web Service 均采用了 HTTP 做传输协议，因为 HTTP<br>协议能穿越防火墙，Java 的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因<br>此可以将 REST 视为基于 HTTP 协议的软件架构。REST 中最重要的两个概念是资源定位和资源操<br>作，而 HTTP 协议恰好完整的提供了这两个点。HTTP 协议中的 URI 可以完成资源定位，而 GET、<br>POST、OPTION、DELETE 方法可以完成资源操作。因此 REST 完全依赖 HTTP 协议就可以完成 Web<br>NOWCODER.COM<br>Service，而不像 SOAP 协议那样只利用了 HTTP 的传输特性，定位和操作都是由 SOAP 协议自身完<br>成的，也正是由于 SOAP 消息的存在使得基于 SOAP 的 Web Service 显得笨重而逐渐被淘汰。 六、计算机网络<br>1、网络概述<br>①关于分层<br>1、TCP 协议在哪一层？IP 协议在那一层？HTTP 在哪一层？<br>考察点：网络七层模型<br>参考回答：<br>运输层，网络层，应用层。<br>2、运输层<br>①TCP 与 UDP<br>1、讲一下 TCP 的连接和释放连接。<br>考察点：网络基础<br>参考回答：<br>三次握手的过程<br>1）主机 A 向主机 B 发送 TCP 连接请求数据包，其中包含主机 A 的初始序列号 seq(A)&#x3D;x。（其<br>中报文中同步标志位 SYN&#x3D;1，ACK&#x3D;0，表示这是一个 TCP 连接请求数据报文；序号 seq&#x3D;x，表明传<br>输数据时的第一个数据字节的序号是 x）；<br>2）主机 B 收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位 SYN&#x3D;1，ACK&#x3D;1，<br>表示这是一个 TCP 连接响应数据报文，并含主机 B 的初始序列号 seq(B)&#x3D;y，以及主机 B 对主机 A<br>初始序列号的确认号 ack(B)&#x3D;seq(A)+1&#x3D;x+1）<br>3）第三次，主机 A 收到主机 B 的确认报文后，还需作出确认，即发送一个序列号 seq(A)&#x3D;x+1；<br>确认号为 ack(A)&#x3D;y+1 的报文；<br>四次挥手过程<br>NOWCODER.COM<br>假设主机 A 为客户端，主机 B 为服务器，其释放 TCP 连接的过程如下：<br>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数<br>据传送，然后等待服务器的确认。其中终止标志位 FIN&#x3D;1，序列号 seq&#x3D;u。<br>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。<br>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。<br>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加<br>1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>三次握手<br>四次挥手<br>2、TCP 有哪些应用场景<br>考察点：TCP 协议<br>参考回答：<br>NOWCODER.COM<br>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一<br>些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议<br>3、tcp 为什么可靠<br>考察点：TCP<br>参考回答：<br>三次握手，超时重传，滑动窗口，拥塞控制。<br>4、tcp 为什么要建立连接<br>考察点：TCP<br>参考回答：<br>保证可靠传输。<br>5、阐述 TCP 的 4 次挥手<br>考察点：TCP 协议<br>参考回答：<br>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的<br>数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上<br>没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动<br>关闭，而另一方执行被动关闭。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服<br>务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。<br>（1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送。<br>（2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，<br>一个 FIN 将占用一个序号。<br>（3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A。<br>（4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。<br>NOWCODER.COM<br>②协议<br>1、讲一下浏览器从接收到一个 URL 到最后展示出页面，经历了哪些过程。tag<br>考察点：http 协议<br>参考回答：<br>1.DNS 解析 2.TCP 连接 3.发送 HTTP 请求 4.服务器处理请求并返回 HTTP 报文<br>5.浏览器解析渲染页面<br>2、http 和 https 的区别<br>考察点：http 协议<br>参考回答；<br>https 协议要申请证书到 ca，需要一定经济成本；2） http 是明文传输，https 是加密的安<br>全传输；3） 连接的端口不一样，http 是 80，https 是 443；4）http 连接很简单，没有状态；<br>https 是 ssl 加密的传输，身份认证的网络协议，相对 http 传输比较安全。<br>3、http 的请求有哪些，应答码 502 和 504 有什么区别<br>考察点：http 协议<br>参考回答：<br>OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送<br>‘*‘的请求来测试服务器的功能性。<br>HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以<br>在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>NOWCODER.COM<br>GET：向特定的资源发出请求。<br>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请<br>求体中。POST 请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>PUT：向指定资源位置上传其最新内容。<br>DELETE：请求服务器删除 Request-URI 所标识的资源。<br>TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求<br>方式也都可以通过这两种方式间接的来实现。<br>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识<br>出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。<br>4、http1.1 和 1.0 的区别<br>考察点：http<br>参考回答：<br>主要区别主要体现在：<br>缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判<br>断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since,<br>If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。<br>带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要<br>某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在<br>请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），<br>这样就方便了开发者自由的选择以便于充分利用带宽和连接。<br>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请<br>求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。<br>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中<br>的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以<br>存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求<br>消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad<br>Request）。<br>长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）<br>处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，<br>在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创<br>建连接的缺点。<br>NOWCODER.COM<br>5、说说 ssl 四次握手的过程<br>考察：HTTP 加密协议<br>参考回答：<br>1、 客户端发出请求<br>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello<br>请求。<br>2、服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。<br>3、客户端回应<br>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书<br>中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还<br>要继续通信。<br>4、服务器的最后回应<br>服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的”会话密<br>钥”。然后，向客户端最后发送下面信息。<br>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所<br>有内容的 hash 值，用来供客户端校验。<br>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通<br>的 HTTP 协议，只不过用”会话密钥”加密内容。<br>6、304 状态码有什么含义？<br>考察点：http<br>参考回答：<br>304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页<br>内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为<br>If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，<br>进而节省带宽和开销。<br>3、网络层<br>①网际协议 IP<br>1、arp 协议，arp 攻击<br>NOWCODER.COM<br>考察点：ARP 协议<br>参考回答：<br>地址解析协议。ARP 攻击的第一步就是 ARP 欺骗。由上述“ARP 协议的工作过程”我们知道，<br>ARP 协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正<br>确和快速的完成——ARP 协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在<br>向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现 ARP 应答中的 IP 地址和 MAC<br>地址中的信息是可以伪造的，并不一定是自己的真实 IP 地址和 MAC 地址，由此，ARP 欺骗就产<br>生了。 ②网际控制报文协议 ICMP<br>1、icmp 协议<br>考察点：ICMP 协议<br>参考回答：<br>它是 TCP&#x2F;IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息。控制消息是<br>指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用<br>户数据，但是对于用户数据的传递起着重要的作用。 ③因特网的路由器选择协议<br>1、讲一下路由器和交换机的区别？<br>考察点：路由器<br>参考回答：<br>交换机用于同一网络内部数据的快速传输转发决策通过查看二层头部完成转发不需要修改<br>数据帧工作在 TCP&#x2F;IP 协议的二层 —— 数据链路层工作简单，直接使用硬件处理路由器用于不<br>同网络间数据的跨网络传输转发决策通过查看三层头部完成转发需要修改 TTL ，IP 头部校验和<br>需要重新计算，数据帧需要重新封装工作在 TCP&#x2F;IP 协议的三层 —— 网络层工作复杂，使用软<br>件处理。<br>4、应用层<br>①域名系统 DNS<br>1、DNS 寻址过程<br>考察点：DNS<br>NOWCODER.COM<br>参考回答：<br>1、在浏览器中输入 <a href="http://www.qq.com/">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个<br>网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。<br>2、如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射<br>关系，如果有，直接返回，完成域名解析。<br>3、如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP&#x2F;ip 参数中<br>设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域<br>名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。<br>4、如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关<br>系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。<br>5、如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是<br>否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服<br>务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的<br>一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com<br>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS 服务器地<br>址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，<br>重复上面的动作，进行查询，直至找到 <a href="http://www.qq.com/">www.qq.com</a> 主机。<br>6、如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服<br>务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不<br>管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此<br>DNS 服务器再返回给客户机。<br>从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查<br>询。②电子邮件<br>1、负载均衡反向代理模式优点及缺点<br>考察点：反向代理<br>参考回答：<br>（1）反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然<br>后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接<br>的客户端，此时代理服务器对外就表现为一个服务器。<br>（2）反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转<br>发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。<br>（3）反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，<br>也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡<br>策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由<br>于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有<br>此优点）。<br>NOWCODER.COM<br>（4）其缺点主要表现在以下两个方面<br>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反<br>向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器<br>的负载均衡。<br>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接<br>请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的<br>瓶颈。<br>一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点<br>进行负载均衡，如 search 等。 七、操作系统<br>1、操作系统概论<br>1、CentOS 和 Linux 的关系？<br>考察点：操作系统<br>参考回答：<br>CentOS是Linux众多得发行版本之一，linux有三大发行版本（：Slackware、debian、redhat）, 而 Redhat 有收费的商业版和免费的开源版,商业版的业内称之为 RHEL 系列，CentOS 是来自于依<br>照开放源代码规定而公布的源代码重新编译而成。可以用 CentOS 替代商业版的 RHEL 使用。两者<br>的不同，CentOS 不包含封闭源代码软件，是免费的。<br>2、64 位和 32 位的区别？<br>考察点：<br>操作系统<br>参考回答：<br>操作系统只是硬件和应用软件中间的一个平台。32 位操作系统针对的 32 位的 CPU 设计。64<br>位操作系统针对的 64 位的 CPU 设计。<br>2、进程的描述与控制<br>1、怎么杀死进程？<br>考察点：进程<br>参考回答：<br>NOWCODER.COM<br>Kill pid<br>2、线程，进程区别<br>考察点：进程，线程<br>参考回答：<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，<br>一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路<br>径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个<br>进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要<br>差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。1.  简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li>
</ul>
<ol start="2">
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高<br>了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序<br>执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多<br>个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这<br>就是进程和线程的重要区别。<br>3、系统线程数量上限是多少？<br>考察点：线程<br>参考回答：<br>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。<br>这个限制可以在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;local_lim.h 中查看 ，对 linuxthreads 这个值一般<br>是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。<br>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程<br>栈大小，一般情况下，这个值是 8M&#x3D;8192KB。<br>4、进程和线程的区别是什么？<br>考察点：JAVA 进程<br>参考回答：<br>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。<br>线程又叫做轻量级进程。<br>NOWCODER.COM<br>5、解释一下 LINUX 下线程，GDI 类。<br>考察点：线程<br>参考回答：<br>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心<br>轻量级进程，而线程之间的管理在核外函数库中实现。<br>GDI 类为图像设备编程接口类库。<br>3、输入输出系统<br>1、socket 编程，BIO，NIO，epoll？<br>考察点：I&#x2F;O 多路复用<br>参考回答：<br>阻塞，非阻塞，io 多路复用，epoll 支持文件符数目没有限制，fd 集合只会从用户进程拷<br>贝到内核一次，自己维护一个事件队列，不用每次遍历 fd 集合发现是否有就绪状态。<br>4、存储器管理<br>1、什么是页式存储？<br>考察点：页式存储<br>参考回答：<br>主存被等分成大小相等的片，称为主存块，又称为实页。<br>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为 2n ,通常为 1KB、2KB、<br>2n KB 等<br>2、操作系统里的内存碎片你怎么理解，有什么解决办法？<br>考察点：内存碎片<br>参考回答：<br>内存碎片分为：内部碎片和外部碎片。<br>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；<br>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存<br>储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才<br>有可能利用这个存储块。<br>NOWCODER.COM<br>单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。<br>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存<br>空间的新进程的内存空闲区域。<br>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前<br>申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br>使用伙伴系统算法。<br>5、处理机调度与死锁<br>1、什么情况下会发生死锁，解决策略有哪些？<br>考察点：死锁<br>参考回答：<br>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个<br>进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如 CD-ROM 驱动器，打印机等<br>等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属<br>性所决定的。<br>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至<br>少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但<br>是，它在等待新资源之时，仍继续占用已占有的资源。<br>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源<br>的占有者进程自行释放。<br>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。<br>解决方法：银行家算法<br>2、系统 CPU 比较高是什么原因？<br>考察点：处理机<br>参考回答：<br>1、首先查看是哪些进程的 CPU 占用率最高（如下可以看到详细的路径）<br>ps -aux –sort -pcpu | more# 定位有问题的线程可以用如下命令ps -mp pid -o THREAD,tid,time | more<br>2、查看 JAVA 进程的每个线程的 CPU 占用率<br>ps -Lp 5798 cu | more # 5798 是查出来进程 PID<br>NOWCODER.COM<br>3、追踪线程，查看负载过高的原因，使用 JDK 下的一个工具<br>jstack 5798 # 5798 是 PID<br>jstack -J-d64 -m 5798 # -j-d64 指定 64 为系统<br>jstack 查出来的线程 ID 是 16 进制，可以把输出追加到文件，导出用记事本打开，再根据<br>系统中的线程 ID 去搜索查看该 ID 的线程运行内容，可以和开发一起排查。<br>3、系统如何提高并发性？<br>考察：操作系统综合性<br>参考回答：<br>1、提高 CPU 并发计算能力<br>（1）多进程&amp;多线程<br>（2）减少进程切换，使用线程，考虑进程绑定 CPU<br>（3）减少使用不必要的锁，考虑无锁编程<br>（4）考虑进程优先级<br>（5）关注系统负载<br>2、改进 I&#x2F;O 模型<br>(1)DMA 技术<br>(2)异步 I&#x2F;O<br>(3)改进多路 I&#x2F;O 就绪通知策略，epoll<br>(4)Sendfile<br>(5)内存映射<br>(6)直接 I&#x2F;O<br>八、算法与数据结构<br>1、哈希<br>1、hashset 存的数是有序的吗？<br>考察点：哈希<br>NOWCODER.COM<br>参考回答：<br>Hashset 是无序的。<br>2、Object 作为 HashMap 的 key 的话，对 Object 有什么要求吗？<br>考察点：哈希表<br>参考回答：<br>要求 Object 中 hashcode 不能变。<br>3、一致性哈希算法<br>考察点：哈希算法<br>参考回答：<br>先构造一个长度为 232 的整数环（这个环被称为一致性 Hash 环），根据节点名称的 Hash<br>值（其分布为[0, 232-1]）将服务器节点放置在这个 Hash 环上，然后根据数据的 Key 值计算得<br>到其 Hash 值（其分布也为[0, 232-1]），接着在 Hash 环上顺时针查找距离这个 Key 值的 Hash<br>值最近的服务器节点，完成 Key 到服务器的映射查找。<br>这种算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况<br>下尽量有多的请求命中原来路由到的服务器。<br>4、什么是 hashmap?<br>考察点：哈希表<br>参考回答：<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于 AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null。此<br>外，HashMap 中的映射不是有序的。<br>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表<br>中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前<br>可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该<br>哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少<br>了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操<br>作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便<br>最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生<br>rehash 操作。<br>hashmap 共有 4 个构造函数：<br>&#x2F;&#x2F; 默认构造函数。HashMap()<br>&#x2F;&#x2F; 指定“容量大小”的构造函数<br>NOWCODER.COM<br>HashMap(int capacity)<br>&#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数<br>HashMap(int capacity, float loadFactor)<br>&#x2F;&#x2F; 包含“子 Map”的构造函数<br>HashMap(Map&lt;? extends K, ? extends V&gt; map)<br>5、Java 中的 HashMap 的工作原理是什么？<br>考察点：JAVA 哈希表<br>参考回答：<br>HashMap 类有一个叫做 Entry 的内部类。这个 Entry 类包含了 key-value 作为实例变量。每<br>当往 hashmap 里面存放 key-value 对的时候，都会为它们实例化一个 Entry 对象，这个 Entry<br>对象就会存储在前面提到的 Entry 数组 table 中。Entry 具体存在 table 的那个位置是 根据 key<br>的 hashcode()方法计算出来的 hash 值（来决定）。<br>6、hashCode()和 equals()方法的重要性体现在什么地方？<br>考察点：JAVA 哈希表<br>参考回答：<br>Java 中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值<br>的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的<br>hash 值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这<br>两个方法的实现对 HashMap 的精确性和正确性是至关重要的。<br>2、树<br>1、说一下 B+树和 B-树？<br>考察点：树<br>参考回答：<br>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；<br>b+树查询必须查找到叶子节点，b 树只要匹配到即可不用管元素位置，因此 b+树查找更稳定<br>（并不慢）；<br>对于范围查找来说，b+树只需遍历叶子节点链表即可，b 树却需要重复地中序遍历。<br>2、怎么求一个二叉树的深度?手撕代码?<br>考察点：二叉树<br>NOWCODER.COM<br>参考回答：<br>public int maxDepth(TreeNode root) {<br>if (root &#x3D;&#x3D; null) {<br>return 0;<br>}<br>int left &#x3D; maxDepth(root.left);<br>int right &#x3D; maxDepth(root.right);<br>int bigger &#x3D; Math.max(left, right);<br>return bigger + 1;<br>}<br>3、算法题：二叉树层序遍历，进一步提问：要求每层打印出一个换行符<br>考察点：二叉树<br>参考回答：<br>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {<br>List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();<br>LinkedList&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;TreeNode&gt;();<br>if (root &#x3D;&#x3D; null) {<br>return res;<br>}<br>queue.offer(root);<br>while (queue.size() !&#x3D; 0) {<br>List&lt;Integer&gt; l &#x3D; new ArrayList&lt;Integer&gt;();<br>int size &#x3D; queue.size();<br>for (int i &#x3D; 0; i &lt; size; i++) {<br>TreeNode temp &#x3D; queue.poll();<br>l.add(temp.val);<br>if (temp.left !&#x3D; null) {<br>NOWCODER.COM<br>queue.offer(temp.left);<br>}<br>if (temp.right !&#x3D; null) {<br>queue.offer(temp.right);<br>}<br>}<br>res.add(l);<br>}<br>return res;<br>}<br>4、二叉树任意两个节点之间路径的最大长度<br>考察点：树<br>参考回答：<br>int maxDist(Tree root) {<br>&#x2F;&#x2F;如果树是空的，则返回 0<br>if(root &#x3D;&#x3D; NULL)<br>return 0;<br>if(root-&gt;left !&#x3D; NULL) {<br>root-&gt;lm &#x3D; maxDist(root-&gt;left) + 1;<br>}<br>if(root-&gt;right !&#x3D; NULL)<br>root-&gt;rm &#x3D; maxDist(root-&gt;right) + 1;<br>&#x2F;&#x2F;如果以该节点为根的子树中有最大的距离，那就更新最大距离<br>int sum &#x3D; root-&gt;rm + root-&gt;lm;<br>if(sum &gt; max) {<br>max &#x3D; sum;<br>NOWCODER.COM<br>}<br>return root-&gt;rm &gt; root-&gt;lm ? root-&gt;rm : root-&gt;lm;<br>}<br>5、如何实现二叉树的深度？<br>考察点：二叉树<br>参考回答：<br>实现二叉树的深度方式有两种，递归以及非递归。<br>①递归实现：<br>为了求树的深度，可以先求其左子树的深度和右子树的深度，可以用递归实现，递归的出口<br>就是节点为空。返回值为 0；<br>②非递归实现：<br>利用层次遍历的算法，设置变量 level 记录当前节点所在的层数，设置变量 last 指向当前<br>层的最后一个节点，当处理完当前层的最后一个节点，让 level 指向+1 操作。设置变量 cur 记<br>录当前层已经访问的节点的个数，当 cur 等于 last 时，表示该层访问结束。<br>层次遍历在求树的宽度、输出某一层节点，某一层节点个数，每一层节点个数都可以采取类<br>似的算法。<br>树的宽度：在树的深度算法基础上，加一个记录访问过的层节点个数最多的变量 max,在访<br>问每层前 max 与 last 比较，如果 max 比较大，max 不变，如果 max 小于 last，把 last 赋值给<br>max;<br>6、如何打印二叉树每层的节点？<br>考察点：二叉树<br>参考回答：</li>
</ol>
<p>4、bucket 如果用链表存储，它的缺点是什么？<br>考察点：链表<br>参考回答：<br>①查找速度慢，因为查找时，需要循环链表访问<br>②如果进行频繁插入和删除操作，会导致速度很慢。<br>5、如何判断链表检测环<br>考察点：链表<br>参考回答：<br>单链表有环，是指单链表中某个节点的 next 指针域指向的是链表中在它之前的某一个节点，<br>这样在链表的尾部形成一个环形结构。<br>&#x2F;&#x2F; 链表的节点结构如下 typedef struct node { int data; struct node *next; } NODE;<br>最常用方法：定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针<br>一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指<br>针走到了链表的末尾（next 指向 NULL）都没有追上第一个指针，那么链表就不是环形链表。<br>通过使用 STL 库中的 map 表进行映射。首先定义 map&lt;NODE , int&gt; m; 将一个 NODE * 指<br>针映射成数组的下标，并赋值为一个 int 类型的数值。然后从链表的头指针开始往后遍历，每<br>次遇到一个指针 p，就判断 m[p] 是否为 0。如果为 0，则将 m[p]赋值为 1，表示该节点第一次<br>访问；而如果 m[p]的值为 1，则说明这个节点已经被访问过一次了，于是就形成了环。</p>
<p>6、排序<br>1、排序算法知道哪些，时间复杂度是多少，解释一下快排？<br>考察点：快排<br>参考回答：<br>快排：快速排序有两个方向，左边的 i 下标一直往右走（当条件 a[i] &lt;&#x3D; a[center_index]<br>时），其中 center_index 是中枢元素的数组下标，一般取为数组第 0 个元素。<br>而右边的 j 下标一直往左走（当 a[j] &gt; a[center_index]时）。<br>如果 i 和 j 都走不动了，i &lt;&#x3D; j, 交换 a[i]和 a[j],重复上面的过程，直到 i&gt;j。交换 a[j]<br>和 a[center_index]，完成一趟快速排序。<br>2、如何得到一个数据流中的中位数？<br>考察点：排序<br>参考回答：<br>数据是从一个数据流中读出来的，数据的数目随着时间的变化而增加。如果用一个数据容器<br>来保存从流中读出来的数据，当有新的数据流中读出来时，这些数据就插入到数据容器中。<br>数组是最简单的容器。如果数组没有排序，可以用 Partition 函数找出数组中的中位数。<br>在没有排序的数组中插入一个数字和找出中位数的时间复杂度是 O(1)和 O(n)。<br>我们还可以往数组里插入新数据时让数组保持排序，这是由于可能要移动 O(n)个数，因此<br>需要 O(n)时间才能完成插入操作。在已经排好序的数组中找出中位数是一个简单的操作，只需<br>要 O(1)时间即可完成。<br>排序的链表时另外一个选择。我们需要 O(n)时间才能在链表中找到合适的位置插入新的数<br>据。如果定义两个指针指向链表的中间结点（如果链表的结点数目是奇数，那么这两个指针指向<br>同一个结点），那么可以在 O（1）时间得出中位数。此时时间效率与及基于排序的数组的时间<br>效率一样。<br>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有<br>排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大<br>NOWCODER.COM<br>数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆<br>中找出最小数。<br>因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右<br>边的数据容器。往堆中插入一个数据的时间效率是 O(logn)。由于只需 O(1)时间就可以得到位<br>于堆顶的数据，因此得到中位数的时间效率是 O(1)。<br>3、堆排序的原理是什么？<br>考察点：堆排序<br>参考回答：<br>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大<br>数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：<br>（1）最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。<br>（2）创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆。<br>（3）堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算<br>4、归并排序的原理是什么？<br>考察点：归并排序<br>参考回答：<br>（1）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and<br>Conquer）的一个非常典型的应用。<br>（2）首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个<br>数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那<br>直接将另一个数列的数据依次取出即可。<br>（3）解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组<br>A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让<br>这二组组内数据有序了？<br>NOWCODER.COM<br>可以将 A，B 组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这<br>个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，<br>再合并数列就完成了归并排序。<br>5、排序都有哪几种方法？请列举出来。<br>考察点：排序<br>参考回答：<br>排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），<br>选择排序（直接选择排序、堆排序），<br>归并排序，分配排序（箱排序、基数排序）<br>快速排序的伪代码。<br>&#x2F; &#x2F;使用快速排序方法对 a[ 0 :n- 1 ]排序<br>从 a[ 0 :n- 1 ]中选择一个元素作为 m i d d l e，该元素为支点<br>把余下的元素分割为两段 left 和 r i g h t，使得 l e f t 中的元素都小于等于支点，而 right<br>中的元素都大于等于支点<br>递归地使用快速排序方法对 left 进行排序<br>递归地使用快速排序方法对 right 进行排序<br>所得结果为 l e f t + m i d d l e + r i g h t<br>7、堆与栈<br>1、堆与栈的不同是什么？<br>考察点：堆，栈<br>参考回答：<br>（1）Java 的堆是一个运行时数据区，类的对象从中分配空间。通过比如：new 等指令建立，<br>不需要代码显式的释放，由垃圾回收来负责。<br>优点：可以动态地分配内存大小，垃圾收集器会自动回收垃圾数据。<br>缺点：由于其优点，所以存取速度较慢。<br>（2）栈：<br>其数据项的插入和删除都只能在称为栈顶的一端完成，后进先出。栈中存放一些基本类型的<br>变量 和 对象句柄。<br>优点：读取数度比堆要快，仅次于寄存器，栈数据可以共享。<br>NOWCODER.COM<br>缺点：比堆缺乏灵活性，存在栈中的数据大小与生存期必须是确定的。<br>举例：<br>String 是一个特殊的包装类数据。可以用：<br>String str &#x3D; new String(“csdn”);<br>String str &#x3D; “csdn”;<br>两种的形式来创建，第一种是用 new()来新建对象的，它会在存放于堆中。每调用一次就会<br>创建一个新的对象。而第二种是先在栈中创建一个对 String 类的对象引用变量 str，然后查找<br>栈中有没有存放”csdn”，如果没有，则将”csdn”存放进栈，并令 str 指向”abc”，如果已经<br>有”csdn” 则直接令 str 指向“csdn”。<br>2、heap 和 stack 有什么区别。<br>考察点：堆与栈<br>参考回答：<br>栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。<br>堆是栈的一个组成元素。<br>3、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。<br>考察点：堆栈<br>参考回答：<br>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都<br>使用内存中的栈空间；而通过 new 关键字和构造器创建的对象放在堆空间；程序中的字面量<br>（literal）如直接书写的 100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈<br>很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上<br>的虚拟内存都可以被当成堆空间来使用。<br>String str &#x3D; new String(“hello”);<br>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面<br>量放在静态区。<br>8、队列<br>1、什么是 Java 优先级队列(Priority Queue)？<br>考察点：队列<br>参考回答：<br>PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)<br>排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue 不允<br>NOWCODER.COM<br>许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，<br>PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。<br>2、id 全局唯一且自增，如何实现？<br>考察点：SnowFlake 雪花算法<br>参考回答；<br>SnowFlake 雪花算法<br>雪花 ID 生成的是一个 64 位的二进制正整数，然后转换成 10 进制的数。64 位二进制数由如<br>下部分组成：<br>snowflake id 生成规则<br>1 位标识符：始终是 0，由于 long 基本类型在 Java 中是带符号的，最高位是符号位，正数<br>是 0，负数是 1，所以 id 一般是正数，最高位是 0。<br>41 位时间戳：41 位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间<br>截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的 id 生成器开始使用的时间，<br>由我们程序来指定的。<br>10 位机器标识码：可以部署在 1024 个节点，如果机器分机房（IDC）部署，这 10 位可以由<br>5 位机房 ID + 5 位机器 ID 组成。<br>NOWCODER.COM<br>12 位序列：毫秒内的计数，12 位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)<br>产生 4096 个 ID 序号<br>优点<br>简单高效，生成速度快。<br>时间戳在高位，自增序列在低位，整个 ID 是趋势递增的，按照时间有序递增。<br>灵活度高，可以根据业务需求，调整 bit 位的划分，满足不同的需求。<br>缺点<br>依赖机器的时钟，如果服务器时钟回拨，会导致重复 ID 生成。<br>在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况。<br>3、如何设计算法压缩一段 URL？<br>考察点：MD5 加密算法<br>参考回答：<br>该算法主要使用 MD5 算法对原始链接进行加密（这里使用的 MD5 加密后的字符串长度为 32<br>位），然后对加密后的字符串进行处理以得到短链接的地址。<br>4、为什么要设计后缀表达式，有什么好处？<br>考察点：逆波兰表达式<br>参考回答：<br>后缀表达式又叫逆波兰表达式，逆波兰记法不需要括号来标识操作符的优先级。<br>5、LRU 算法的实现原理？<br>考察点：LRU 算法<br>参考回答：<br>①LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数<br>据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也很高”，反过来说“如果<br>数据最近这段时间一直都没有访问,那么将来被访问的概率也会很低”，两种理解是一样的；常<br>用于页面置换算法，为虚拟页式存储管理服务。<br>②达到这样一种情形的算法是最理想的：每次调换出的页面是所有内存页面中最迟将被使用<br>的；这可以最大限度的推迟页面调换，这种算法，被称为理想页面置换算法。可惜的是，这种算<br>法是无法实现的。<br>为了尽量减少与理想算法的差距，产生了各种精妙的算法，最近最少使用页面置换算法便是其中<br>一个。LRU 算法的提出，是基于这样一个事实：在前面几条指令中使用频繁的页面很可能在后面<br>的几条指令中频繁使用。反过来说，已经很久没有使用的页面很可能在未来较长的一段时间内不<br>NOWCODER.COM<br>会被用到 。这个，就是著名的局部性原理——比内存速度还要快的 cache，也是基于同样的原<br>理运行的。因此，我们只需要在每次调换时，找到最近最少使用的那个页面调出内存。<br>算法实现的关键<br>命中率：<br>当存在热点数据时，LRU 的效率很好，但偶发性的、周期性的批量操作会导致 LRU 命中率急剧<br>下降，缓存污染情况比较严重。<br>复杂度：<br>实现起来较为简单。<br>存储成本：<br>几乎没有空间上浪费。<br>代价：<br>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。 九、设计模式<br>1、结构型模式<br>①代理模式<br>1、java 中有哪些代理模式？<br>考察点：代理模式<br>参考回答：<br>静态代理，动态代理，Cglib 代理。<br>2、如何实现动态代理<br>考察点：动态代理流程<br>参考回答：<br>Java 实现动态代理的大致步骤如下：<br>1.定义一个委托类和公共接口。<br>2.自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是<br>指定运行时将生成的代理类需要完成的具体任务（包括 Preprocess 和 Postprocess），即代理<br>类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。<br>3.生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口<br>(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器<br>实例。<br>4.Java 实现动态代理主要涉及以下几个类：<br>NOWCODER.COM<br>①java.lang.reflect.Proxy: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承<br>了 Proxy 类，即 DynamicProxyClass extends Proxy。<br>②java.lang.reflect.InvocationHandler: 这里称他为”调用处理器”，他是一个接口，我<br>们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现<br>InvocationHandler 接口。<br>示例代码：<br>public final class <code>$Proxy1 extends Proxy implements Subject&#123; private InvocationHandler h; private $</code>Proxy1(){}<br>public $Proxy1(InvocationHandler h){<br>this.h &#x3D; h; }<br>public int request(int i){<br>Method method &#x3D; Subject.class.getMethod(“request”, new Class[]{int.class}); &#x2F;&#x2F;<br>创建 method 对象<br>return (Integer)h.invoke(this, method, new Object[]{new Integer(i)}); &#x2F;&#x2F;调用了<br>invoke 方法 } }<br>②适配器模式<br>1、IO 流熟悉吗，用的什么设计模式？<br>考察点：装饰模式，适配器模式<br>参考回答：<br>装饰模式和适配器模式<br>2、创建型模式<br>①单例模式<br>1、介绍一下单例模式？懒汉式的单例模式如何实现单例？<br>考察点：单例模式<br>参考回答：<br>NOWCODER.COM<br>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。优点：单例类只有一个<br>实例、共享资源，全局使用节省创建时间，提高性能。可以用静态内部实现，保证是懒加载就行<br>了，就是使用才会创建实例对象。<br>3、行为型模式<br>①策略模式<br>1、介绍一下策略模式？<br>考察点：策略模式<br>参考回答：<br>策略模式也叫政策模式，是一种行为型设计模式，是一种比较简单的设计模式。策略模式<br>采用了面向对象的继承和多态机制。略模式适合使用在：1.多个类只有在算法或行为上稍有不同<br>的场景。2.算法需要自由切换的场景。3.需要屏蔽算法规则的场景。 使用策略模式当然也有需<br>要注意的地方，那么就是策略类不要太多，如果一个策略家族的具体策略数量超过 4 个，则需要<br>考虑混合模式，解决策略类膨胀和对外暴露问题。在实际项目中，我们一般通过工厂方法模式来<br>实现策略类的声明。<br>优点：算法可以自由切换。2.避免使用多重条件判断。3.扩展性良好。 ②观察者模式<br>1、设计模式了解哪些，手写一下观察者模式？<br>考察点：观察者模式<br>参考回答：<br>NOWCODER.COM<br>观察者模式优点：<br>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个<br>具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个<br>具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，<br>因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然<br>跨越抽象化和具体化层次。<br>观察者模式缺点：<br>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费<br>很多时间。<br>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩<br>溃。在使用观察者模式是要特别注意这一点。<br>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方<br>式进行的。<br>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应<br>的机制使观察者知道所观察的对象是怎么发生变化的。<br>4、模式汇总<br>1、说说你所熟悉或听说过的 j2ee 中的几种常用模式?及对设计模式的一些看法<br>考察点：J2EE 设计模式<br>参考回答：<br>Session Facade Pattern：使用 SessionBean 访问 EntityBean Message Facade Pattern：<br>实现异步调用 EJB Command Pattern：使用 Command JavaBeans 取代 SessionBean，实现轻量级<br>访问 Data Transfer Object Factory：通过 DTO Factory 简化 EntityBean 数据提供特性 Generic<br>Attribute Access：通过 AttibuteAccess 接口简化 EntityBean 数据提供特性 Business<br>NOWCODER.COM<br>Interface：通过远程（本地）接口和 Bean 类实现相同接口规范业务逻辑一致性ＥＪＢ架构的设<br>计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率。项目越复杂，<br>项目队伍越庞大则越能体现良好设计的重要性。<br>2、j2ee 常用的设计模式？说明工厂模式。<br>考察点：j2ee 设计模式<br>参考回答：<br>Java 中的 23 种设计模式：<br>Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），Prototype<br>（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式），<br>Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元<br>模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor<br>（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），<br>Observer（观察者模式）， State（状态模式）， Strategy（策略模式），Template Method<br>（模板方法模式）， Chain Of Responsibleity（责任链模式）工厂模式：工厂模式是一种经常<br>被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通<br>常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了<br>不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需<br>要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员<br>可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。<br>3、开发中都用到了那些设计模式?用在什么场合?<br>考察点：设计模式<br>参考回答：<br>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核<br>心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用<br>到了 MVC 的设计模式。用来开发 JSP&#x2F;Servlet 或者 J2EE 的相关应用。简单工厂模式等。<br>4、简述一下你了解的 Java 设计模式<br>考察点：设计模式<br>参考回答：<br>所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一<br>个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。<br>设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模<br>式也会使新系统开发者更加容易理解其设计思路。<br>在 GoF 的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三<br>类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的<br>结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：<br>Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模<br>式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter<br>（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight<br>（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor<br>（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），<br>NOWCODER.COM<br>Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模<br>板方法模式）， Chain Of Responsibility（责任链模式）。 十、场景题<br>1、情景题：如果一个外卖配送单子要发布，现在有 200 个骑手都想要接这一单，如何保证只有<br>一个骑手接到单子？<br>2、场景题：美团首页每天会从 10000 个商家里面推荐 50 个商家置顶，每个商家有一个权值，你<br>如何来推荐？第二天怎么更新推荐的商家？<br>可以借鉴下 stackoverflow，视频网站等等的推荐算法。<br>3、场景题：微信抢红包问题<br>悲观锁，乐观锁，存储过程放在 mysql 数据库中。<br>4、场景题：1000 个任务，分给 10 个人做，你怎么分配，先在纸上写个最简单的版本，然后优<br>化。<br>全局队列，把 1000 任务放在一个队列里面，然后每个人都是取，完成任务。<br>分为 10 个队列，每个人分别到自己对应的队列中去取务。<br>5、场景题：保证发送消息的有序性，消息处理的有序性。<br>6、如何把一个文件快速下发到 100w 个服务器<br>7、给每个组分配不同的 IP 段，怎么设计一种结构使的快速得知 IP 是哪个组的?<br>8、10 亿个数，找出最大的 10 个。<br>建议一个大小为 10 的小根堆。<br>9、有几台机器存储着几亿淘宝搜索日志，你只有一台 2g 的电脑，怎么选出搜索热度最高的十个<br>搜索关键词？<br>10、分布式集群中如何保证线程安全？<br>11、给个淘宝场景，怎么设计一消息队列？<br>12、10 万个数，输出从小到大？<br>先划分成多个小文件，送进内存排序，然后再采用多路归并排序。<br>13、有十万个单词，找出重复次数最高十个？<br>十二、惊喜福利<br>此面试题库将根据当下面试形式大数据随时更新，如果你已获得下载权限，那么你可以终身<br>在牛币兑换中心里去兑换此面试题库的电子版，如果电子版有更新，会通过牛客站内信进行<br>通知（前提是你已获得下载权限）。<br>b.14. ⽹络相关：<br>a. tcp三次握⼿、四次挥⼿<br>b. http机制<br>c. https机制15. 项⽬亮点：16. 画架构图：17. 平时看过什么书？18. 接⼝与抽象类区别<br>1、⼀个类声明可否既是abstract的,⼜是final的? 不能,这两个修式符⽭盾（abstract就是要被继承）<br>2、抽象类不⼀定包含抽象⽅法<br>3、有抽象⽅法,则⼀定是抽象类<br>4、抽象类不能被实例化，⼀般⽤作基类使⽤；<br>a. 类可以实现多个接⼝但只能继承⼀个抽象类<br>b. 接⼝⾥⾯所有的⽅法都是Public的，抽象类允许Private、Protected⽅法<br>c. JDK8前接⼝⾥⾯所有的⽅法都是抽象的且不允许有静态⽅法，抽象类可以有普通、静态⽅法，JDK8 接⼝可以实现默认⽅法<br>和静态⽅法，前⾯加default、static关键字。19. java中的异常有哪⼏类，分别怎么使⽤？<br>分为错误和异常，异常⼜包括运⾏时异常、⾮运⾏时异常<br>a. 错误，如StackOverflowError、OutOfMemoryError<br>b. 异常：<br>i. 运⾏时异常，如NullPointerException、IndexOutOfBoundsException，都是RuntimeException及其⼦类<br>ii. ⾮运⾏时异常，如IOException、SQLException,都是Exception及其⼦类，这些异常是⼀定需要try catch捕获的20. 常⽤的集合类有哪些？⽐如list如何排序？<br>主要分为三类，Map、Set、List<br>a. Map: HashMap、LinkedHashMap、TreeMap<br>b. Set：HashSet、LinkedHashSet、TreeSet<br>c. List: ArrayList、LinkedList<br>1 Collections.sort(list);21. ArrayList和LinkedList内部实现⼤致是怎样的？他们之间的区别和优缺点？<br>a. ArrayList：内部使⽤数组的形式实现了存储，利⽤数组的下标进⾏元素的访问，因此对元素的随机访问速度⾮常快。因为是<br>数组，所以ArrayList在初始化的时候，有初始⼤⼩10，插⼊新元素的时候，会判断是否需要扩容，扩容的步⻓是0.5倍原容量，<br>扩容⽅式是利⽤数组的复制，因此有⼀定的开销。<br>b. LinkedList：内部使⽤双向链表的结构实现存储，LinkedList有⼀个内部类作为存放元素的单元，⾥⾯有三个属性，⽤来存放<br>元素本身以及前后2个单元的引⽤，另外LinkedList内部还有⼀个header属性，⽤来标识起始位置，LinkedList的第⼀个单元和<br>最后⼀个单元都会指向header，因此形成了⼀个双向的链表结构。<br>c. ArrayList查找较快，插⼊、删除较慢，LinkedList查找较慢，插⼊、删除较快。22. 内存溢出是怎么回事？举个例⼦。<br>a. 内存溢出 out of memory，是指程序在申请内存时，没有⾜够的内存空间供其使⽤，出现out of memory。<br>1 List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();<br>2 while (true) {<br>3 list.add(new Object());<br>4 }<br>b. 内存溢出可能的原因：<br>i. 程序中存在死循环<br>ii. 静态变量和静态⽅法太多了<br>iii. 内存泄漏：⽐如说⼀个静态的list，⼀直往⾥放值，⼜因为静态变量不会被释放，所以迟早是要内存溢出的<br>iv. ⼤对象过多：java中的⼤对象是直接进⼊⽼年代的，然后当多个⼤对象同时⼯作时造成程序的可⽤内存⾮常⼩，⽐如我<br>list中原本最多可以放1000个对象，因为可⽤内存太⼩，放了500个就放不下了。<br>v. 程序分配内存过⼩：还有⼀种很常⻅的情况，在把⼀个很⼤的程序直接导⼊，直接就内存溢出了，原因就是内存相对这<br>个程序就是太⼩了，需要⼿动增加内存。<br>c. 内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄漏堆<br>积后果很严重，⽆论多少内存,迟早会被占光。23. &#x3D;&#x3D;和equals的区别<br>&#x3D;&#x3D;是运算符，⽽equals是Object的基本⽅法，&#x3D;&#x3D;⽤于基本类型的数据的⽐较，或者是⽐较两个对象的引⽤是否相同，equals⽤<br>于⽐较两个对象的值是否相等，例如字符串的⽐较。24. hashCode⽅法的作⽤<br>1、hashCode的存在主要是⽤于查找的快捷性，为了配合基于散列的集合正常运⾏，如Hashtable，HashMap等，hashCode是<br>⽤来在散列存储结构中确定对象的存储地址的；<br>2、如果两个对象相同，就是适⽤于equals(java.lang.Object) ⽅法，那么这两个对象的hashCode⼀定要相同；<br>3、如果对象的equals⽅法被重写，那么对象的hashCode也尽量重写，并且产⽣hashCode使⽤的对象，⼀定要和equals⽅法中<br>使⽤的⼀致，否则就会违反上⾯提到的第2点；<br>4、两个对象的hashCode相同，并不⼀定表示两个对象就相同，也就是不⼀定适⽤于equals(java.lang.Object) ⽅法，只能够说<br>明这两个对象在散列存储结构中，它们存放在同⼀个桶⾥⾯。25. NIO是什么？适⽤于何种场景？<br>a. NIO是为了弥补IO操作的不⾜⽽诞⽣的，NIO的⼀些新特性有：⾮阻塞I&#x2F;O，选择器，缓冲以及管道。<br>b. 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候⽤NIO处理数据可<br>能是个很好的选择。(适⽤于⼩数据多连接)<br>c. ⽽如果只有少量的连接，⽽这些连接每次要发送⼤量的数据，这时候传统的IO更合适。使⽤哪种处理数据，需要在数据的响<br>应等待时间和检查缓冲区数据的时间上作⽐较来权衡选择。<br>d. NIO：<br>i. 概念：NIO(new IO)，是⼀种⾮阻塞式I&#x2F;O；java NIO采⽤了双向通道进⾏数据传输，在通道上我们可以注册我们感兴趣的<br>事件：连接事件、读写事件；NIO主要有三⼤核⼼部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)。传统IO基于字<br>节流和字符流进⾏操作，⽽NIO基于Channel和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区<br>写⼊到通道中。Selector(选择区)⽤于监听多个通道的事件（⽐如：连接打开，数据到达）。因此，单个线程可以监听多个<br>数据通道。<br>ii. 原理：26. 由⼀个专⻔的线程来处理所有的 IO 事件，并负责分发。27. 事件驱动机制：事件到的时候触发，⽽不是同步的去监视事件。28. 线程通讯：线程之间通过 wait,notify 等⽅式通讯。保证每次上下⽂切换都是有意义的。减少⽆谓的线程切换。29. Hashmap实现原理？如何保证HashMap线程安全？<br>a. HashMap简单说就是它根据键的hashCode值存储数据，⼤多数情况下可以直接定位到它的值，因⽽具有很快的访问速度，<br>但遍历顺序却是不确定的。<br>b. HashMap基于哈希表，底层结构由数组来实现，添加到集合中的元素以“key–value”形式保存到数组中，在数组中key–<br>value被包装成⼀个实体来处理—也就是上⾯Map接⼝中的Entry。<br>c. 在HashMap中，Entry[]保存了集合中所有的键值对，当我们需要快速存储、获取、删除集合中的元素时，HashMap会根据<br>hash算法来获得“键值对”在数组中存在的位置，以来实现对应的操作⽅法。<br>d. HashMap底层是采⽤数组来维护的.Entry静态内部类的数组<br>1 &#x2F;**<br>2 * The table, resized as necessary. Length MUST Always be a power of two.<br>3 *&#x2F;<br>4 transient Entry[] table;<br>5<br>6 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>7 final K key;<br>8 V value;<br>9 Entry&lt;K,V&gt; next;<br>10 final int hash;<br>11 ……<br>12 }<br>c. HashMap添加元素：将准备增加到map中的对象与该位置上的对象进⾏⽐较(equals⽅法),如果相同,那么就将该位置上的那<br>个对象(Entry类型)的value值替换掉,否则沿着该Entry的链继续重复上述过程,如果到链的最后任然没有找到与此对象相同的对象,那么这个<br>时候就会被增加到数组中,将数组中该位置上的那个Entry对象链到该对象的后⾯(先hashcode计算位置，如果找到相同位置便替换值，找<br>不到则重复hashcode计算，直到最后在添加到hashmap最后⾯；)<br>d. HashMap是基于哈希表的Map接⼝的⾮同步实现，允许null键值，但不保证映射的顺序；底层使⽤数组实现，数组中的每项<br>是⼀个链表；存储时根据key的hash算法来决定其存储位置；数组扩容需要重新计算扩容后每个元素在数组中的位置很耗性能；<br>e. ConcurrentHashMap是HashMap的线程安全实现，允许多个修改操作同时进⾏(使⽤了锁分离技术)，它使⽤了多个锁来控制<br>对hash表的不同段进⾏的修改，每个段其实就是⼀个⼩的hashtable，它们有⾃⼰的锁。使⽤了多个⼦hash表(段Segment)，允<br>许多个读操作并发进⾏，读操作并不需要锁，因为它的HashEntry⼏乎是不可变的：30. jvm内存结构？为什么需要GC？<br>a. 内存结构：<br>b. 垃圾回收：垃圾回收可以有效的防⽌内存泄漏，有效的使⽤可以使⽤的内存。垃圾回收器通常是作为⼀个单独的低优先级的<br>线程运⾏，不可预知的情况下对内存堆中已经死亡的或者⻓时间没有使⽤的对象进⾏清除和回收，程序员不能实时的调⽤垃圾<br>回收器对某个对象或所有对象进⾏垃圾回收。回收机制有分代复制垃圾回收、标记垃圾回收、增量垃圾回收等⽅式。31. NIO模型，select&#x2F;epoll的区别，多路复⽤的原理？<br>1、io多路复⽤：<br>1、概念：IO多路复⽤是指内核⼀旦发现进程指定的⼀个或者多个IO条件准备读取，它就通知该进程。<br>2、优势：与多进程和多线程技术相⽐，I&#x2F;O多路复⽤技术的最⼤优势是系统开销⼩，系统不必创建进程&#x2F;线程，也不必维护<br>这些进程&#x2F;线程，从⽽⼤⼤减⼩了系统的开销。<br>3、系统：⽬前⽀持I&#x2F;O多路复⽤的系统调⽤有 select，pselect，poll，epoll。<br>2、select：select⽬前⼏乎在所有的平台上⽀持，其良好跨平台⽀持也是它的⼀个优点。select的⼀个缺点在于单个进程能够<br>监视的⽂件描述符的数量存在最⼤限制，在Linux上⼀般为1024，可以通过修改宏定义甚⾄重新编译内核的⽅式提升这⼀限制，<br>但是这样也会造成效率的降低。<br>3、poll：它没有最⼤连接数的限制，原因是它是基于链表来存储的，但是同样有⼀个缺点：<br>a. ⼤量的fd的数组被整体复制于⽤户态和内核地址空间之间，⽽不管这样的复制是不是有意义。<br>b. poll还有⼀个特点是“⽔平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<br>epoll跟select都能提供多路I&#x2F;O复⽤的解决⽅案。在现在的Linux内核⾥有都能够⽀持，其中epoll是Linux所特有，⽽select则应该是<br>POSIX所规定，⼀般操作系统均有实现。32. java中⼀个字符占多少个字节？int，long，double占多少个字节？<br>a. 1字节： byte , boolean<br>b. 2字节： short , char<br>c. 4字节： int , float<br>d. 8字节： long , double33. 创建⼀个类的实例都有哪些⽅法？<br>1 Object o &#x3D; new Object();<br>2 Object o &#x3D; oo.clone();<br>3 Object o &#x3D; Class.forName(“xxx”).newInstance();34. final&#x2F;finaly&#x2F;finalize区别？<br>a. final是定义类、⽅法、字段的修饰符，表示类不可被继承，⽅法不能被重写，字段值不能被修改<br>b. finally是异常处理机制的关键字，表示最后执⾏<br>c. finalize是Object的⼀个⽅法，在对象被虚拟机回收时会判断是否执⾏该⽅法，当对象没有覆盖finalize⽅法，或者finalize⽅法<br>已经被虚拟机调⽤过，虚拟机将这两种情况都视为“没有必要执⾏”35. Session&#x2F;Cookie区别？<br>Session存储在服务器端，类型可以是任意的Java对象，Cookie存储在客户端，类型只能为字符串36. String&#x2F;StringBuffer&#x2F;StringBuilder的区别以及实现？<br>a. String、StringBuffer是线程安全的，StringBuilder不是<br>b. String不继承任何类，StringBuffer、StringBuilder继承⾃AbstractStringBuilder<br>StringBuffer线程安全但效率低，应该使⽤在多线程情况下；<br>StringBuilder线程不安全，在单线程情况下效率⾼；37. Servlet⽣命周期<br>a. Servlet⽣命周期分为三个阶段：<br>1、初始化阶段 调⽤init()⽅法<br>　　2、响应客户请求阶段　　调⽤service()⽅法<br>　　3、终⽌阶段　　调⽤destroy()⽅法38. 如何⽤java分配⼀段连续的1G的内存空间?需要注意些什么？<br>1 ByteBuffer.allocateDirect(1024<em>1024</em>1024);<br>要注意内存溢出问题。39. Java有⾃⼰的内存回收机制，但为什么还存在内存泄漏的问题呢？<br>a. ⾸先内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄<br>漏堆积后果很严重，⽆论多少内存,迟早会被占光。<br>b. ⽐如下⾯这段代码，list持有o的引⽤，o暂时是⽆法被JVM垃圾回收的，只有当list被垃圾回收或者o从对象list删除掉后，o才<br>能被JVM垃圾回收。<br>1 List list &#x3D; new ArrayList();<br>2 Object o &#x3D; new Object();<br>3 list.add(o);<br>4 o &#x3D; null;<br> 41. String s &#x3D; new String(“abc”)创建了⼏个String Object？<br>1、2个，会创建String对象在常量池和堆中。<br>2、String中的intern(),⾸先检查String pool是否有对应的字符串对象,如果有则返回，如果没有则在String pool中⽣成字符串，<br>并返回地址；<br>3.String中字⾯值”ab”之间拼接是在String pool中产⽣,⽽字⾯值与变量拼接字符串或者new String(“”)则是在堆中产⽣对象;42. 静态对象：<br>1.在main⽅法开始运⾏时需要注意static的先后顺序：静态变量和静态代码块(按代码先后顺序)—-匿名块和成员变量(按代码先<br>后顺序)—-构造函数—静态⽅法(调⽤时加载)<br>2.先执⾏⽗类的静态块,再执⾏⼦类的静态块,再执⾏⽗类的构造⽅法,再执⾏⼦类的构造⽅法<br>1、静态块&gt;构造⽅法；<br>2、⽗&gt;⼦43. final关键字：<br>1、⽤在类上不能被继承，abstract(需要被继承)和final不能共存；<br>2、⽤在⽅法上不能被重写<br>3、⽤在变量上表示⽅变量不能被改变<br>--对于final类的成员变量的初使化⽅式(基本数据类型)<br>1.申明变量时直接赋值<br>2.在构造⽅法中完成赋值,如果有多个构造⽅法,则每个都要完成final类变量的赋值<br>3.如果⼀个变量为static final则只能在申明时赋值<br>--对于final类型的引⽤变量来说,所谓的不能改变指的是该引⽤不能改变,值是可以改变的（如StringBuffer）<br>--为什么⼀般在public类final终态成员变量申明时要加static?<br>static对象存放在静态空间，不会在运⾏时被释放，可以节省内存，类的多个对象同时引⽤只有⼀份,没有多份拷⻉44. HashMap与HashTable的区别：<br>1.线程安全上,hashtable是同步的线程安全；hashmap是⾮同步的线程不安全，可接受null的值和value（hashtable不允许）；<br>2.对单线程来说,hashTable效率低<br>3、线程安全的类：vector(⽐arrayList多了同步机制，效率低不建议使⽤)、stack(堆栈类，先进后出)、hashtable(⽐hashmap<br>多了同步机制)、enumeration(枚举类)45. 多态：<br>1、多态条件：1.有继承 2. 有重写 3. 要有⽗类引⽤指向⼦类对象；如Animal a &#x3D; new Tiger();46. ⽗类或者接⼝引⽤指向⼦类或者实现该接⼝的类的对象；47. 多态是运⾏时⾏为,不是编绎时⾏为；48. 多态要有动态绑定，通过⽅法重写与⽅法重载来实现多态?? 这种说法是错误，因为⽅法重载是编译期决定好的,没有后期也就<br>是运⾏期的动态绑定；49. 集合删除：<br>注意: List底层为数组,删除时数组元素下标会被改变50. 跌代器调⽤.next()⽅法时,会检测是否有被修改过51. 如果要删除集合中的元素⼀定要⽤跌代器的remove()⽅法.52. 参数传递与引⽤传递：<br>1.基本数据类型传参,是数据值的拷⻉互不影响.<br>2.引⽤对象传参,是传地址,两个引⽤指向同⼀个对象,则对象改变两个引⽤也都改变(java编程只有值传递参数)53. hash冲突：<br>1、描述：当关键字值域远⼤于哈希表的⻓度，⽽且事先并不知道关键字的具体取值时，冲突就难免会发⽣。（两个或两个以上<br>的值hash计算的结果有相同的，造成冲突）<br>2、解决⽅法：<br>1、开放地址法：插⼊元素时，如果发⽣冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下⼀个空<br>槽，并将该元素放⼊该槽中（会导致相同hash值的元素挨在⼀起和其他hash值对应的槽被占⽤）。查找元素时，⾸先散列值所<br>指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到⼀个空槽，指示查找的元<br>素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）<br>2、链地址法：现⾏探测法的基本思想是将所有哈希地址为i的元素构成⼀个称为同义词链的单链表，并将单链表的头指针<br>存在哈希表的第i个单元中，因⽽查找、插⼊和删除主要在同义词链中进⾏。链地址法适⽤于经常进⾏插⼊和删除的情况。<br>3、在散列(双&#x2F;多重散列)：当发⽣冲突时，使⽤第⼆个、第三个、哈希函数计算地址，直到⽆冲突时。缺点：计算时间增<br>加。<br>4、建⽴⼀个公共溢出区：假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设⽴存储空间向量<br>OverTable[0..v]⽤以存储发⽣冲突的记录。54. 在java中⼀个字符能否表示⼀个汉字：<br>在java中,⼀个字符表示16位,相当于2个字节,⼀个汉字正好是2个字节55. ⼀致性hash：<br>1、⼀致性hash算法：我们的memcached客户端（这⾥我看的spymemcache的源码），使⽤了⼀致性hash算法ketama进⾏数据存储节点<br>的选择。与常规的hash算法思路不同，只是对我们要存储数据的key进⾏hash计算，分配到不同节点存储。⼀致性hash算法是对我们要存储数<br>据的服务器进⾏hash计算，进⽽确认每个key的存储位置。这⾥提到的⼀致性hash算法ketama的做法是：选择具体的机器节点不在只依赖需要<br>缓存数据的key的hash本身了，⽽是机器节点本身也进⾏了hash运算。<br>1、⼀致性hash算法是分布式系统中常⽤算法，设计⽬的是为了解决因特⽹中的热点(hot spot)问题。解决了P2P环境最为关键问<br>题—如何在动态⽹络拓扑中分布存储和路由；<br>2、⼀致性hash算法引⼊虚拟节点机制，解决服务节点少时数据倾斜问题(即对每⼀个服务节点计算多个哈希，每个计算结果位置都<br>放置⼀个此服务节点，称为虚拟节点。)；<br>2、具体做法：如果有⼀个写⼊缓存的请求，其中Key值为K，计算器hash值Hash(K)， Hash(K) 对应于图 – 1环中的某⼀个点，如果<br>该点对应没有映射到具体的某⼀个机器节点，那么顺时针查找，直到第⼀次找到有映射机器的节点，该节点就是确定的⽬标节点，如果超过了<br>2^32仍然找不到节点，则命中第⼀个机器节点。⽐如 Hash(K) 的值介于A~B之间，那么命中的机器节点应该是B节点（如上图 ）。<br>3、数据保存流程：<br>1、⾸先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。<br>2、然后采⽤同样的⽅法求出存储数据的键的哈希值，并映射到相同的圆上。<br>3、然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第⼀个服务器上。如果超过232仍然找不到服务器，就会保存到第<br>⼀台memcached服务器上。56. java反射机制<br>可以在运⾏时判断⼀个对象所属的类，构造⼀个类的对象，判断类具有的成员变量和⽅法，调⽤1个对象的⽅法。<br>4个关键的类：Class，Constructor，Field，Method。 getConstructor获得构造函数&#x2F;getDeclardConstructor；<br>getField&#x2F;getFields&#x2F;getDeclardFields获得类所⽣命的所有字段；getMethod&#x2F;getMethods&#x2F;getDeclardMethod获得类声明的所有⽅法，正<br>常⽅法是⼀个类创建对象，⽽反射是1个对象找到1个类。57. 幂等的处理⽅式：<br>接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。<br>⼀、查询操作是天然幂等<br>⼆、唯⼀索引，防⽌新增脏数据<br>三、token机制，防⽌⻚⾯重复提交<br>四、悲观锁 for update<br>五、乐观锁（通过版本号&#x2F;时间戳实现， 通过条件限制where avai_amount-#subAmount# &gt;&#x3D; 0）<br>六、分布式锁<br>七、状态机幂等（如果状态机已经处于下⼀个状态，这时候来了⼀个上⼀个状态的变更，理论上是不能够变更的，这样的话，保证<br>了有限状态机的幂等。）58. hashmap在jdk1.8中的改动?59. Jdk1.8以前是进⾏四次扰动计算，可能从速度功效各⽅⾯考虑，jdk1.8变成扰动⼀次，低16位和⾼16位进⾏异或计算。取模的时<br>候考虑取模运算的速度⽐较慢，改⽤与操作优化效率，很巧妙，hash table就没设计的这么好。60. JDK1.8⾥对hashmap最⼤的改变是引⼊了红⿊树，这⼀点在hash不均匀并且元素个数很多的情况时，对hashmap的性能提升⾮<br>常⼤。Hashmap的底层实现是使⽤⼀个entry数组存储，默认初始⼤⼩16，不过jdk8换了名字叫node，可能是因为引⼊了树，叫<br>node更合适吧，另外我也不喜欢entry这个名字，不能望⽂⽣义，我在刚学的时候还以为是什么神秘的东⻄呢，其实就是个键值对对<br>象⽽已。Node⾥有next引⽤指向下⼀个节点，因为hashmap解决冲突的思路是拉链法。61. 另外变化⽐较⼤的还有扩容机制，也就是resize⽅法。62. java 8 流式使⽤：<br>1 List&lt;Integer&gt; evens &#x3D; nums.stream().filter(num -&gt; num % 2 &#x3D;&#x3D; 0).collect(Collectors.toList());<br>2 &#x2F;&#x2F;1、stream()操作将集合转换成⼀个流，<br>3 &#x2F;&#x2F;2、filter()执⾏我们⾃定义的筛选处理，这⾥是通过lambda表达式筛选出所有偶数，<br>4 &#x2F;&#x2F;3、最后我们通过collect()对结果进⾏封装处理，并通过Collectors.toList()指定其封装成为⼀个List集合返回。63. java域的概念：<br>field，域是⼀种属性，可以是⼀个类变量，⼀个对象变量，⼀个对象⽅法变量或者是⼀个函数的参数。64. jdk1.8中ConcurrentHashMap size⼤于8时会转化成红⿊树，请问有什么作⽤，如果通过remove操作，size⼩于8了，会发⽣什<br>么？<br>put时如果链表size&gt;&#x3D;8并且table.length&gt;&#x3D;64，这时链表会转变成⼀个红⿊树（红⿊树是⼀个⾃平衡的⼆叉查找树，查找效率会从<br>链表的o(n)降低为o(logn)，效率是⾮常⼤的提⾼），但是remove不会逆转。65. 描述⼀下Hibernate的三个状态？<br>a. transient(瞬时状态)：new出来⼀个对象，还没被保存到数据库中<br>b. persistent(持久化状态)：对象已经保存到数据库中并且在hibernate session也存在该对象<br>c. detached(离线状态)：对象在数据库中存在，hibernate session不存在66. struts⼯作流程<br>1、客户端浏览器发出HTTP请求。<br>2、根据web.xml配置，该请求被FilterDispatcher接收。<br>3、根据struts.xml配置，找到需要调⽤的Action类和⽅法， 并通过IoC⽅式，将值注⼊给Aciton。<br>4、Action调⽤业务逻辑组件处理业务逻辑，这⼀步包含表单验证。<br>5、Action执⾏完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应⻚⾯。<br>6、返回HTTP响应到客户端浏览器。67. Hibernate对⼀⼆级缓存的使⽤， Lazy-Load的理解;<br>a. ⼀级缓存：hibernate的⼀级缓存是由session提供的，因此它只存在session的⽣命周期中。也就是说session关闭的时<br>候该session所管理的⼀级缓存也随之被清除。hibernate的⼀级缓存是session所内置的，默认开启，不能被卸载，也不<br>能进⾏任何配置。在缓存中的对象,具有持久性,session对象负责管理.⼀级缓存的优点是使⽤同⼀个session对象多次查询<br>同⼀个数据对象,仅对数据库查询⼀次。⼀级缓存采⽤的是Key-Value的MAP⽅式来实现的。在缓存实体对象时，对象的<br>主关键字ID是MAP的Key，实体对象就是对象的值。所以说⼀级缓存是以实体对象为单位进⾏存储的。访问的时候使⽤的<br>是主键关键字ID。⼀级缓存使⽤的是⾃动维护的功能。但可以通过session提供的⼿动⽅法对⼀级缓存的管理进⾏⼿动⼲<br>预。evict()⽅法⽤于将某个对象从session的⼀级缓存中清除。clear()⽅法⽤于将session缓存中的⽅法全部清除。<br>b. ⼆级缓存：⼆级缓存的实现原理与⼀级缓存是⼀样的。也是通过Key-Value的Map来实现对对象的缓存。⼆级缓存是作<br>⽤在SessionFactory范围内的。因此它可被所有的Session对象所共享。需要注意的是放⼊缓存中的数据不能有第三⽅的<br>应⽤对数据进⾏修改。⼆级缓存默认关闭，需要程序员⼿动开启，默认为ehcache实现.<br>c. 懒加载：当⽤到数据的时候才向数据库查询，这就是hibernate的懒加载特性。延迟加载策略能避免加载应⽤程序不需<br>要访问的关联对象，以提⾼应⽤程序的性能。68. mybatis如何实现批量提交？<br>a. 通过标签：</p>
<p>b. 通过ExecutorType.BATCH：<br>69. session机制？70. session是服务器的⽣成,并传⾄客户端浏览器,后续请求,都会通过URL重写传⾄服务器进⾏session⽐较.71. session是基于cookie72. session可以保存⽤户信息,但cookie如果浏览器被禁⽤,则⽆法保存⽤户信息73. 如果浏览器禁⽤会话cookie，则每次请求都⽆法将第⼀次请求获得的sessionId传⾄后台服务器.所以每次请求刷新⻚⾯服务<br>器都会⽣成新的sessionid给到浏览器74. 因HTTP协议为⽆状态的协议（⼀旦数据交互完毕，客户端和服务端的连接就会关闭，再次交换数据时需要建⽴新的连接）,需要<br>通过session或者cookie保存和跟踪⽤户信息<br>6、sessionID放在浏览器客户端cookie,其它信息放在服务器内存中，也可以做持久化管理memcached、redis中；75. Struts2表单重复提交问题（token拦截器）<br>1.访问⻚⾯前保存token(服务器后台⽣成的⼀串序列时间串放到session中)，并传⾄前台jsp⻚⾯中的隐藏域<br>2.提交时验证token,将前台的隐藏的token传⾄后台进⾏验证是否⼀致，提交随机⽣成新的token，可以防⽌重复提交；76. shiro：<br>1、定义：apache shiro是java的⼀个安全框架，简单易⽤，基本功能有：认证、授权、加密、会话管理、与Web集成、缓存<br>等。Shiro不会去维护⽤户、维护权限；这些需要我们⾃⼰去设计&#x2F;提供；然后通过相应的接⼝注⼊给Shiro即可(五张表)。<br>2、功能点：Authentication：身份认证&#x2F;登录，验证⽤户是不是拥有相应的身份；<br>Authorization：授权，即权限验证，验证某个已认证的⽤户是否拥有某个权限；即判断⽤户是否能做事情，常⻅的如：验<br>证某个⽤户是否拥有某个⻆⾊。或者细粒度的验证某个⽤户对某个资源是否具有某个权限；<br>Session Manager：会话管理，即⽤户登录后就是⼀次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通<br>JavaSE环境的，也可以是如Web环境的；<br>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，⽽不是明⽂存储；<br>Web Support：Web⽀持，可以⾮常容易的集成到Web环境；<br>Caching：缓存，⽐如⽤户登录后，其⽤户信息、拥有的⻆⾊&#x2F;权限不必每次去查，这样可以提⾼效率；<br>Concurrency：shiro⽀持多线程应⽤的并发验证，即如在⼀个线程中开启另⼀个线程，能把权限⾃动传播过去；<br>Testing：提供测试⽀持；<br>Run As：允许⼀个⽤户假装为另⼀个⽤户（如果他们允许）的身份进⾏访问；<br>Remember Me：记住我，这个是⾮常常⻅的功能，即⼀次登录后，下次再来的话不⽤登录了。<br>3、⼯作流程：<br>1、应⽤代码通过Subject(主体，代表当前”⽤户”)来进⾏认证和授权，⽽Subject⼜委托给SecurityManager(安全管理<br>器，shiro核⼼)；<br>2、我们需要给Shiro的SecurityManager注⼊Realm(域，Shiro从Realm获取安全数据（如⽤户、⻆⾊、权限）)，从⽽<br>让SecurityManager能得到合法的⽤户及其权限进⾏判断。1.  Tomcat Filter过滤器责任链模式,过滤器拦截器区别?<br>1、责任链模式：将⼀个事件处理流程分派到⼀组执⾏对象上去，这⼀组执⾏对象形成⼀个链式结构，事件处理请求在这⼀组执⾏对<br>象上进⾏传递。<br>2、过滤器和拦截器：<br>1、过滤器filter：是在java web中，你传⼊的request,response提前过滤掉⼀些信息，或者提前设置⼀些参数，然后<br>再传⼊servlet或者struts的 action进⾏业务逻辑，⽐如过滤掉⾮法url（不是login.do的地址请求，如果⽤户没有登陆都过滤<br>掉）,或者在传⼊servlet或者 struts的action前统⼀设置字符集，或者去除掉⼀些⾮法字符；<br>2、拦截器interceptor：是在⾯向切⾯编程的就是在你的service或者⼀个⽅法，前调⽤⼀个⽅法，或者在⽅法后调⽤⼀个<br>⽅法⽐如动态代理就是拦截器的简单实现，在你调⽤⽅法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调⽤⽅法后打印出<br>字符串，甚⾄在你抛出异常的时候做业务逻辑的操作。拦截是AOP的⼀种实现策略；<br>3、区别：<br>a. 拦截器是基于java的反射机制的，⽽过滤器是基于函数回调。<br>b. 拦截器不依赖于servlet容器，过滤器依赖与servlet容器。<br>c. 拦截器只能对action请求起作⽤，⽽过滤器则可以对⼏乎所有的请求起作⽤。<br>d. 拦截器可以访问action上下⽂、值栈⾥的对象，⽽过滤器不能访问。<br>e. 在action的⽣命周期中，拦截器可以多次被调⽤，⽽过滤器只能在容器初始化时被调⽤⼀次<br>2.  Git与Svn的区别：<br>1、Git是分布式的，⽽Svn不是；<br>2、GIT把内容按元数据⽅式存储，⽽SVN是按⽂件<br>3、分⽀不同：git分⽀切换很⽅便；svn分⽀就是版本库的另外⼀个⽬录；<br>4、GIT没有⼀个全局的版本号，⽽svn有，SVN的版本号实际是任何⼀个相应时间的源代码快照。<br>5、GIT的内容完整性要优于SVN(GIT的内容存储使⽤的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和⽹<br>络问题时降低对版本库的破坏。)<br>3.  Git命令底层原理：<br>4.  git init：使⽤git init初始化⼀个新的⽬录时，会⽣成⼀个.git的⽬录，该⽬录即为本地仓库。⼀个新初始化的本地仓库<br>是这样的：<br>1 !”” HEAD<br>2 !”” branches<br>3 !”” config<br>4 !”” description<br>5 !”” hooks<br>6 !”” objects<br>7 # !”” info<br>8 # <code>$&quot;&quot; pack 9 $</code>“” refs<br>10 !”” heads<br>11 $“” tags<br>description⽤于GitWeb程序<br>config配置特定于该仓库的设置（还记得git config的三个配置级别么）<br>hooks放置客户端或服务端的hook脚本<br>HEAD传说中的HEAD指针，指明当前处于哪个分⽀<br>objectsGit对象存储⽬录<br>refsGit引⽤存储⽬录<br>branches放置分⽀引⽤的⽬录<br>其中description、config和hooks这些不在讨论中，后⽂会直接忽略。<br>5.  git add：Git commit之前先要通过git add添加⽂件：<br>可以看到，多了⼀个index⽂件。并且在objects⽬录下多了⼀个9f的⽬录，其中多了⼀个<br>4d96d5b00d98959ea9960f069585ce42b1349a⽂件。<br>其实9f4d96d5b00d98959ea9960f069585ce42b1349a就是⼀个Git对象，称为blob对象。<br>6.  git commit：<br>7.  JSP的执⾏过程：<br>1）客户端发出请求。<br>2）Web容器将JSP转译成Servlet源代码。<br>3）Web容器将产⽣的源代码进⾏编译。<br>4）Web容器加载编译后的代码并执⾏。<br>5）把执⾏结果响应⾄客户端。<br>8.  ZK⾼可⽤：<br>9.  ZooKeeper 运⾏期间，集群中⾄少有过半的机器保存了最新数据。集群超过半数的机器能够正常⼯作，集群就能够对<br>外提供服务。<br>10. zookeeper有什么功能，选举算法如何进⾏：<br>1、选举算法：<br>1、Fast Leader(领导者选举)选举算法：<br>1.server启动时默认选举⾃⼰，并向整个集群⼴播<br>2.收到消息时，通过3层判断：选举轮数，zxid，server id⼤⼩判断是否同意对⽅，如果同意，则修改⾃⼰的选<br>票，并向集群⼴播<br>3.QuorumCnxManager负责IO处理，每2个server建⽴⼀个连接，只允许id⼤的server连id⼩的server，每个<br>server启动单独的读写线程处理，使⽤阻塞IO<br>4.默认超过半数机器同意时，则选举成功，修改⾃身状态为LEADING或FOLLOWING<br>5.Obserer机器不参与选举<br>2、原理：选举结果的影响权重关系是:⾸先看数据id,数据id⼤者胜出;其次再判断leader id,leader id⼤者胜出。<br>3、举例：<br>假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数<br>据量这⼀点上,都是⼀样的.假设这些服务器依序启动,来看看会发⽣什么.1.  服务器1启动,此时只有它⼀台服务器启动了,它发出去的报没有任何响应,所以它的选举状态⼀直是LOOKING<br>状态；<br>2.  服务器2启动,它与最开始启动的服务器1进⾏通信,互相交换⾃⼰的选举结果,由于两者都没有历史数据,所以id<br>值较⼤的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例⼦中的半数以上是3),所以服务器1,2<br>还是继续保持LOOKING状态.<br>3.  服务器3启动,根据前⾯的理论分析,服务器3成为服务器1,2,3中的⽼⼤,⽽与上⾯不同的是,此时有三台服务器<br>选举了它,所以它成为了这次选举的leader.<br>4.  服务器4启动,根据前⾯的分析,理论上服务器4应该是服务器1,2,3,4中最⼤的,但是由于前⾯已经有半数以上的<br>服务器选举了服务器3,所以它只能接收当⼩弟的命了.<br>5.  服务器5启动,同4⼀样,当⼩弟.<br>4、zookeeper管理员指南：<br>1、集群中过半存活即可⽤，故集群选择奇数台机器；1.  RPC、RMI、MQ、SOAP：<br>1、RPC:远程过程调⽤协议，采⽤C&#x2F;S模式，分布式跨语⾔平台，更多⽤于同步调⽤，⽐如Web Service(SOAP)；<br>2、RMI:远程⽅法调⽤，依赖于java远程消息交换协议，要求服务端与客户端都为java编写；每个⽅法都具有⽅法签名，只有签名<br>匹配才可以调⽤，返回值是基本类型和对象；<br>3、MQ:队列，更多⽤于异步传输；<br>4、SOAP最主要的⼯作是使⽤标准的XML描述了RPC的请求信息(URI&#x2F;类&#x2F;⽅法&#x2F;参数&#x2F;返回值)。理论上，SOAP就是⼀段xml，你可<br>以通过http,smtp等发送它(复制到软盘上，叫快递公司送去也⾏?)。同样SOAP也是跨语⾔的。<br>2.  Netty⾼性能：<br>1、NIO异步⾮阻塞通信<br>2、“零拷⻉”<br>3、内存池ByteBuf<br>4、Netty提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。<br>5、⾼效的Reactor线程模型：Reactor单线程(多线程、主从)模型，指的是所有的IO操作都在同⼀个NIO线程上⾯完成<br>6、为了尽可能提升性能，Netty采⽤了串⾏⽆锁化设计，在IO线程内部进⾏串⾏操作，避免多线程竞争导致的性能下降。表⾯上<br>看，串⾏化设计似乎CPU利⽤率不⾼，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串⾏化的线程并⾏运<br>⾏，这种局部⽆锁化的串⾏线程设计相⽐⼀个队列-多个⼯作线程模型性能更优。<br>7、⾼效的并发编程：Netty的⾼效并发编程主要体现在如下⼏点：1.  volatile的⼤量、正确使⽤;<br>2.  CAS和原⼦类的⼴泛使⽤；<br>3.  线程安全容器的使⽤；<br>4.  通过读写锁提升并发性能。<br>8、⾼效的序列化框架：<br>9、灵活的TCP参数配置能⼒：合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和<br>SO_SNDBUF。如果设置不当，对性能的影响是⾮常⼤的。1.  如何保证服务的幂等性？<br>1、概念：接⼝的幂等性实际上就是接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。有些<br>接⼝可以天然的实现幂等性，⽐如查询接⼝，对于查询来说，你查询⼀次和两次，对于系统来说，没有任何影响，查出<br>的结果也是⼀样。<br>2、GET幂等：值得注意，幂等性指的是作⽤于结果⽽⾮资源本身。怎么理解呢？例如，这个HTTP GET⽅法可能会每次<br>得到不同的返回内容，但并不影响资源。<br>3、POST⾮幂等：因为它会对资源本身产⽣影响，每次调⽤都会有新的资源产⽣，因此不满⾜幂等性。<br>4、如何保证幂等性：<br>1、全局唯⼀id：如果使⽤全局唯⼀ID，就是根据业务的操作和内容⽣成⼀个全局ID，在执⾏操作前先根据这个全局唯<br>⼀ID是否存在，来判断这个操作是否已经执⾏。如果不存在则把全局ID，存储到存储系统中，⽐如数据库、redis等。如<br>果存在则表示该⽅法已经执⾏。<br>从⼯程的⻆度来说，使⽤全局ID做幂等可以作为⼀个业务的基础的微服务存在，在很多的微服务中都会⽤到这样的<br>服务，在每个微服务中都完成这样的功能，会存在⼯作量重复。另外打造⼀个⾼可靠的幂等服务还需要考虑很多问题，<br>⽐如⼀台机器虽然把全局ID先写⼊了存储，但是在写⼊之后挂了，这就需要引⼊全局ID的超时机制。<br>使⽤全局唯⼀ID是⼀个通⽤⽅案，可以⽀持插⼊、更新、删除业务操作。但是这个⽅案看起来很美但是实现起来⽐<br>较麻烦，下⾯的⽅案适⽤于特定的场景，但是实现起来⽐较简单。<br>2、去重表：这种⽅法适⽤于在业务中有唯⼀标的插⼊场景中，⽐如在以上的⽀付场景中，如果⼀个订单只会⽀付⼀<br>次，所以订单ID可以作为唯⼀标识。这时，我们就可以建⼀张去重表，并且把唯⼀标识作为唯⼀索引，在我们实现时，<br>把创建⽀付单据和写⼊去去重表，放在⼀个事务中，如果重复创建，数据库会抛出唯⼀约束异常，操作就会回滚。<br>3、插⼊或更新：这种⽅法插⼊并且有唯⼀索引的情况，⽐如我们要关联商品品类，其中商品的ID和品类的ID可以构成<br>唯⼀索引，并且在数据表中也增加了唯⼀索引。这时就可以使⽤InsertOrUpdate操作。在mysql数据库中如下：<br>1 insert into goods_category (goods_id,category_id,create_time,update_time)<br>2 values(#{goodsId},#{categoryId},now(),now())<br>3 on DUPLICATE KEY UPDATE<br>4 update_time&#x3D;now()<br>4、多版本控制：这种⽅法适合在更新的场景中，⽐如我们要更新商品的名字，这时我们就可以在更新的接⼝中增加⼀<br>个版本号，来做幂等<br>1 boolean updateGoodsName(int id,String newName,int version);<br>在实现时可以如下<br>1 update goods set name&#x3D;#{newName},version&#x3D;#{version} where id&#x3D;#{id} and version&lt;${version}<br>5、状态机控制：这种⽅法适合在有状态机流转的情况下，⽐如就会订单的创建和付款，订单的付款肯定是在之前，这<br>时我们可以通过在设计状态字段时，使⽤int类型，并且通过值类型的⼤⼩来做幂等，⽐如订单的创建为0，付款成功为<br>100。付款失败为99<br>在做状态机更新时，我们就这可以这样控制<br>1 update <code>order</code> set status&#x3D;#{status} where id&#x3D;#{id} and status&lt;#{status}<br>2.  zookeeper⼯作原理？<br>1、定义：zookeeper是⼀种为分布式应⽤所设计的⾼可⽤、⾼性能且⼀致的开源协调服务，它提供了⼀项基本服务：分<br>布式锁服务。后来摸索出了其他使⽤⽅法：配置维护、组服务、分布式消息队列、分布式通知&#x2F;协调等。<br>2、特点：<br>1、能够⽤在⼤型分布式系统中；<br>2、具有⼀致性、可⽤性、容错性，不会因为⼀个节点的错误⽽崩溃；<br>3、⽤途：⽤户⼤型分布式系统，作协调服务⻆⾊；<br>1、分布式锁应⽤：通过对集群进⾏master选举，来解决分布式系统中的单点故障（⼀主n从，主挂全挂）。<br>2、协调服务；<br>3、注册中⼼；<br>4、原理：<br>术语：<br>数据结构Znode：zookeeper数据采⽤树形层次结构，和标准⽂件系统⾮常相似，树中每个节点被称为Znode；<br>通知机制Watcher：zookeeper可以为所有的读操作（exists()、getChilden()及getData()）设置watch，<br>watch事件是⼀次性出发器，当watch的对象状态发⽣改变时，将会触发次对象上watch所对应的事件。watch事件将被异步的发送<br>给客户端，并且zookeeper为watch机制提供了有序的⼀致性保证。<br>基本流程：分布式锁应⽤场景<br>1、传统的⼀主n从分布式系统，容易发⽣单点故障，传统解决⽅式是增加⼀个备⽤节点，定期给主节点发送Ping包，主<br>节点回复ack，但是如果⽹络原因ack丢失，那么会出现两个主节点，造成数据混乱。<br>2、zookeeper的引⼊可以管理两个主节点，其中挂了⼀个，会将另外⼀个作为新的主节点，挂的节点回来时担任备⽤节<br>点；<br>3.  cap理论：<br>1、概念：⼀个分布式系统最多只能同时满⾜⼀致性（Consistency）、可⽤性（Availability）和分区容错性（Partition<br>tolerance）这三项中的两项。<br>2、⼀致性：更新操作成功并返回客户端完成后，所有节点在同⼀时间的数据完全⼀致，所以，⼀致性，说的就是数据⼀<br>致性。<br>3、可⽤性：服务⼀直可⽤，⽽且是正常响应时间。<br>4、分区容错性：分布式系统在遇到某节点或⽹络分区故障的时候，仍然能够对外提供满⾜⼀致性和可⽤性的服务。Java 基础<br>1.JDK 和 JRE 有什么区别？<br>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。<br>2.&#x3D;&#x3D; 和 equals 的区别是什么？<br>&#x3D;&#x3D; 解读<br>对于基本类型和引用类型 &#x3D;&#x3D; 的作用效果是不同的，如下所示：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：<br>String x &#x3D; “string”;<br>String y &#x3D; “string”;<br>String z &#x3D; new String(“string”);<br>System.out.println(xy); &#x2F;&#x2F; true<br>System.out.println(xz); &#x2F;&#x2F; false<br>System.out.println(x.equals(y)); &#x2F;&#x2F; true<br>System.out.println(x.equals(z)); &#x2F;&#x2F; true<br>代码解读：因为 x 和 y 指向的是同一个引用，所以 &#x3D;&#x3D; 也是 true，而 new String()方法则重写开辟了内存空间，所以 &#x3D;&#x3D; 结果为 false，而 equals 比较的一直是值，所以结果都为 true。<br>equals 解读<br>equals 本质上就是 &#x3D;&#x3D;，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。<br>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：<br>class Cat {<br>public Cat(String name) {<br>this.name &#x3D; name;<br>}<br>private String name;public String getName() {<br>return name;<br>}public void setName(String name) {<br>this.name &#x3D; name;<br>}<br>}<br>Cat c1 &#x3D; new Cat(“王磊”);<br>Cat c2 &#x3D; new Cat(“王磊”);<br>System.out.println(c1.equals(c2)); &#x2F;&#x2F; false<br>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：<br>public boolean equals(Object obj) {<br>return (this &#x3D;&#x3D; obj);<br>}<br>原来 equals 本质上就是 &#x3D;&#x3D;。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：<br>String s1 &#x3D; new String(“老王”);<br>String s2 &#x3D; new String(“老王”);<br>System.out.println(s1.equals(s2)); &#x2F;&#x2F; true<br>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：<br>public boolean equals(Object anObject) {<br>if (this &#x3D;&#x3D; anObject) {<br>return true;<br>}<br>if (anObject instanceof String) {<br>String anotherString &#x3D; (String)anObject;<br>int n &#x3D; value.length;<br>if (n &#x3D;&#x3D; anotherString.value.length) {<br>char v1[] &#x3D; value;<br>char v2[] &#x3D; anotherString.value;<br>int i &#x3D; 0;<br>while (n– !&#x3D; 0) {<br>if (v1[i] !&#x3D; v2[i])<br>return false;<br>i++;<br>}<br>return true;<br>}<br>}<br>return false;<br>}<br>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br>总结 ：&#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。<br>3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？<br>不对，两个对象的 hashCode() 相同，equals() 不一定 true。<br>代码示例：<br>String str1 &#x3D; “通话”;<br>String str2 &#x3D; “重地”;<br>System. out. println(String. format(“str1：%d | str2：%d”, str1. hashCode(),str2. hashCode()));<br>System. out. println(str1. equals(str2));<br>执行的结果：<br>str1：1179395 | str2：1179395<br>false<br>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。<br>4.final 在 Java 中有什么作用？<br>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。<br>5.Java 中的 Math. round(-1. 5) 等于多少？<br>等于 -1，Math. round 四舍五入大于 0. 5 向上取整的。<br>6.String 属于基础的数据类型吗？<br>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。<br>7.Java 中操作字符串都有哪些类？它们之间有什么区别？<br>操作字符串的类有：String、StringBuffer、StringBuilder。<br>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br>8.String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？<br>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。<br>9.如何将字符串反转？<br>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br>示例代码：<br>&#x2F;&#x2F; StringBuffer reverse<br>StringBuffer stringBuffer &#x3D; new StringBuffer();<br>stringBuffer. append(“abcdefg”);<br>System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba<br>&#x2F;&#x2F; StringBuilder reverse<br>StringBuilder stringBuilder &#x3D; new StringBuilder();<br>stringBuilder. append(“abcdefg”);<br>System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba1.  String 类的常用方法都有那些？<br>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。<br>2.  抽象类必须要有抽象方法吗？<br>不需要，抽象类不一定非要有抽象方法。<br>示例代码：<br>abstract class Cat {<br>public static void sayHi() {<br>System. out. println(“hi~”);<br>}<br>}<br>上面代码，抽象类并没有抽象方法但完全可以正常运行。<br>12.普通类和抽象类有哪些区别？<br>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。<br>13.抽象类能使用 final 修饰吗？<br>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：<br>编译器保存图</p>
<p>15.Java 中 IO 流分为几种？<br>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。<br>16.BIO、NIO、AIO 有什么区别？<br>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。<br>17.Files的常用方法都有哪些？<br>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。<br>容器<br>18.Java 容器都有哪些？<br>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：<br>Collection<br>List<br>ArrayList<br>LinkedList<br>Vector<br>Stack<br>Set<br>HashSet<br>LinkedHashSet<br>TreeSet<br>Map<br>HashMap<br>LinkedHashMap<br>TreeMap<br>ConcurrentHashMap<br>Hashtable<br>3.  Collection 和 Collections 有什么区别？<br>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。<br>4.  List、Set、Map 之间的区别是什么？<br>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：<br>区别图<br>22.如何决定使用 HashMap 还是 TreeMap？<br>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。<br>23.说一下 HashMap 的实现原理？<br>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。<br>24.说一下 HashSet 的实现原理？<br>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。<br>25.ArrayList 和 LinkedList 的区别是什么？<br>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。<br>26.如何实现数组和 List 之间的转换？<br>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：<br>&#x2F;&#x2F; list to array<br>List list &#x3D; new ArrayList();<br>list. add(“王磊”);<br>list. add(“的博客”);<br>list. toArray();<br>&#x2F;&#x2F; array to list<br>String[] array &#x3D; new String[]{“王磊”,“的博客”};<br>Arrays. asList(array);<br>5.  ArrayList 和 Vector 的区别是什么？<br>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。<br>6.  Array 和 ArrayList 有何区别？<br>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。<br>7.  在 Queue 中 poll()和 remove()有什么区别？<br>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。<br>代码示例：<br>Queue queue &#x3D; new LinkedList();<br>queue. offer(“string”); &#x2F;&#x2F; add<br>System. out. println(queue. poll());<br>System. out. println(queue. remove());<br>System. out. println(queue. size());<br>8.  哪些集合类是线程安全的？<br>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。<br>31.迭代器 Iterator 是什么？<br>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。<br>32.Iterator 怎么使用？有什么特点？<br>Iterator 使用代码如下：<br>List list &#x3D; new ArrayList&lt;&gt;();<br>Iterator it &#x3D; list. iterator();<br>while(it. hasNext()){<br>String obj &#x3D; it. next();<br>System. out. println(obj);<br>}<br>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。<br>33.Iterator 和 ListIterator 有什么区别？<br>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。<br>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。<br>34.怎么确保一个集合不能被修改？<br>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下：<br>List list &#x3D; new ArrayList&lt;&gt;();<br>list. add(“x”);<br>Collection clist &#x3D; Collections. unmodifiableCollection(list);<br>clist. add(“y”); &#x2F;&#x2F; 运行时此行报错<br>System. out. println(list. size());<br>多线程<br>9.  并行和并发有什么区别？<br>并行：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>并发：多个处理器或多核处理器同时处理多个任务。<br>如下图：<br>并发和并行<br>并发 &#x3D; 两个队列和一台咖啡机。<br>并行 &#x3D; 两个队列和两台咖啡机。<br>36.线程和进程的区别？<br>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。<br>37.守护线程是什么？<br>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。<br>47.在 Java 程序中怎么保证多线程的运行安全？<br>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：<br>Lock lock &#x3D; new ReentrantLock();<br>lock. lock();<br>try {<br>System. out. println(“获得锁”);<br>} catch (Exception e) {<br>&#x2F;&#x2F; TODO: handle exception<br>} finally {<br>System. out. println(“释放锁”);<br>lock. unlock();<br>}<br>13. 多线程中 synchronized 锁升级的原理是什么？<br>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。<br>52.说一下 synchronized 底层实现原理？<br>synchronized 是由一对 monitorenter&#x2F;monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。<br>53.synchronized 和 volatile 的区别是什么？<br>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。<br>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>14. 说一下 atomic 的原理？<br>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>反射<br>15. 什么是反射？<br>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<ol start="16">
<li>动态代理是什么？有哪些应用？<br>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。<br>60.怎么实现动态代理？<br>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。<br>对象拷贝</li>
<li>为什么要使用克隆？<br>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。<br>62.如何实现对象克隆？<br>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。<br>63.深拷贝和浅拷贝区别是什么？<br>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。<br>Java Web<br>64.JSP 和 servlet 有什么区别？<br>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。<br>71.如何避免 SQL 注入？<br>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。<br>72.什么是 XSS 攻击，如何避免？<br>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br>预防 XSS 的核心是必须对输入的数据做过滤处理。<br>73.什么是 CSRF 攻击，如何避免？<br>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br>防御手段：<br>验证请求来源地址；<br>关键操作添加验证码；<br>在请求地址添加 token 并验证。<br>异常</li>
<li>throw 和 throws 的区别？<br>throw：是真实抛出一个异常。<br>throws：是声明可能会抛出一个异常。</li>
<li>try-catch-finally 中哪个部分可以省略？<br>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。<br>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？<br>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。<br>78.常见的异常类有哪些？<br>NullPointerException 空指针异常<br>ClassNotFoundException 指定类不存在<br>NumberFormatException 字符串转换为数字异常<br>IndexOutOfBoundsException 数组下标越界异常<br>ClassCastException 数据类型转换异常<br>FileNotFoundException 文件未找到异常<br>NoSuchMethodException 方法不存在异常<br>IOException IO 异常<br>SocketException Socket 异常<br>网络<br>79.http 响应码 301 和 302 代表的是什么？有什么区别？<br>301：永久重定向。<br>302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。<br>80.forward 和 redirect 的区别？<br>forward 是转发 和 redirect 是重定向：<br>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；<br>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；<br>效率：forward 比 redirect 效率高。</li>
<li>简述 tcp 和 udp的区别？<br>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：<br>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；<br>tcp 提供可靠的服务（数据传输），udp 无法保证；<br>tcp 面向字节流，udp 面向报文；<br>tcp 数据传输慢，udp 数据传输快；<br>83.说一下 tcp 粘包是怎么产生的？<br>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<br>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li>
<li>OSI 的七层模型都有哪些？<br>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>数据链路层：负责建立和管理节点间的链路。<br>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。<br>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>会话层：向两个实体的表示层提供建立和使用连接的方法。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。<br>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>
<li>get 和 post 请求有哪些区别？<br>get 请求会被浏览器主动缓存，而 post 不会。<br>get 传递参数有大小限制，而 post 没有。<br>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li>
<li>如何实现跨域？<br>实现跨域有以下几种方案：<br>服务器端运行跨域 设置 CORS 等于 *；<br>在单个接口使用注解 @CrossOrigin 运行跨域；<br>使用 jsonp 跨域；</li>
<li>说一下 JSONP 实现原理？<br>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。<br>设计模式</li>
<li>为什么要使用 spring？<br>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。<br>spring 提供了事务支持，使得事务操作变的更加方便。<br>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。<br>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。<br>106.spring boot 核心配置文件是什么？<br>spring boot 核心的两个配置文件：<br>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li>
<li>spring boot 配置文件有哪几种类型？它们有什么区别？<br>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。<br>. properties 配置如下：<br>spring. RabbitMQ. port&#x3D;5672<br>. yml 配置如下：<br>spring:<br>RabbitMQ:<br>port: 5672<br>. yml 格式不支持 @PropertySource 注解导入。<br>108.spring boot 有哪些方式可以实现热部署？<br>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，沟上自动编译或手动重新编译。<br>109.jpa 和 hibernate 有什么区别？<br>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。<br>110.什么是 spring cloud？<br>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。<br>111.spring cloud 断路器的作用是什么？<br>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。<br>112.spring cloud 的核心组件有哪些？<br>Eureka：服务注册于发现。<br>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。<br>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。<br>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。<br>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。<br>Hibernate<br>113.为什么要使用 hibernate？<br>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。<br>可以很方便的进行数据库的移植工作。<br>提供了缓存机制，是程序执行更改的高效。<br>114.什么是 ORM 框架？<br>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。<br>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。<br>115.hibernate 中如何在控制台查看打印的 SQL 语句？<br>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。<br>116.hibernate 有几种查询方式？<br>三种：hql、原生 SQL、条件查询 Criteria。<br>117.hibernate 实体类可以被定义为 final 吗？<br>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。<br>118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？<br>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。<br>119.hibernate 是如何工作的？<br>读取并解析配置文件。<br>读取并解析映射文件，创建 SessionFactory。<br>打开 Session。<br>创建事务。<br>进行持久化操作。<br>提交事务。<br>关闭 Session。<br>关闭 SessionFactory。<br>120.get()和 load()的区别？<br>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。<br>load()支持延迟加载；get() 不支持延迟加载。<br>121.说一下 hibernate 的缓存机制？<br>hibernate 常用的缓存有一级缓存和二级缓存：<br>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；<br>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。<br>122.hibernate 对象有哪些状态？<br>临时&#x2F;瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>持久化状态：当调用 Session 的 save&#x2F;saveOrupdate&#x2F;get&#x2F;load&#x2F;list 等方法的时候，对象就是持久化状态。<br>游离状态：Session 关闭之后对象就是游离状态。<br>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？<br>getCurrentSession 会绑定当前线程，而 openSession 则不会。<br>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。<br>124.hibernate 实体类必须要有无参构造函数吗？为什么？<br>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。<br>MyBatis</li>
<li>MyBatis 中 #{}和 的区别是什么？#是预编译处理，{}的区别是什么？#{}是预编译处理，的区别是什么？#是预编译处理，{}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。<br>126.MyBatis 有几种分页方式？<br>分页方式：逻辑分页和物理分页。<br>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。<br>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。<br>127.RowBounds 是一次性查询全部结果吗？为什么？<br>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更的数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。<br>Fetch Size 官方相关文档：<a href="http://t/">http://t</a>. cn&#x2F;EfSE2g3<br>128.MyBatis 逻辑分页和物理分页的区别是什么？<br>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。<br>129.MyBatis 是否支持延迟加载？延迟加载的原理是什么？<br>MyBatis 支持延迟加载，设置 lazyLoadingEnabled&#x3D;true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。<br>130.说一下 MyBatis 的一级缓存和二级缓存？<br>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session&#x2F;二级缓存 Mapper)进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ol>
<p>132.MyBatis 有哪些执行器（Executor）？<br>MyBatis 有三种基本的Executor执行器：<br>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；<br>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；<br>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。<br>38. MyBatis 分页插件的实现原理是什么？<br>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。<br>134.MyBatis 如何编写一个自定义插件？<br>自定义插件实现原理<br>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：<br>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；<br>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；<br>ParameterHandler：拦截参数的处理；<br>ResultSetHandler：拦截结果集的处理。<br>自定义插件实现关键<br>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：<br>public interface Interceptor {<br>Object intercept(Invocation invocation) throws Throwable;<br>Object plugin(Object target);<br>void setProperties(Properties properties);<br>}<br>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；<br>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；<br>intercept 方法就是要进行拦截的时候要执行的方法。<br>自定义插件实现示例<br>官方插件实现：<br>@Intercepts({@Signature(type &#x3D; Executor. class, method &#x3D; “query”,<br>args &#x3D; {MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class})})<br>public class TestInterceptor implements Interceptor {<br>public Object intercept(Invocation invocation) throws Throwable {<br>Object target &#x3D; invocation. getTarget(); &#x2F;&#x2F;被代理对象<br>Method method &#x3D; invocation. getMethod(); &#x2F;&#x2F;代理方法<br>Object[] args &#x3D; invocation. getArgs(); &#x2F;&#x2F;方法参数<br>&#x2F;&#x2F; do something . . . . . . 方法拦截前执行代码块<br>Object result &#x3D; invocation. proceed();<br>&#x2F;&#x2F; do something . . . . . . . 方法拦截后执行代码块<br>return result;<br>}<br>public Object plugin(Object target) {<br>return Plugin. wrap(target, this);<br>}<br>}<br>RabbitMQ<br>39. RabbitMQ 的使用场景有哪些？<br>抢购活动，削峰填谷，防止系统崩塌。<br>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。<br>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。<br>40. RabbitMQ 有哪些重要的角色？<br>RabbitMQ 中重要的角色有：生产者、消费者和代理：<br>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。<br>41. RabbitMQ 有哪些重要的组件？<br>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。<br>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。<br>42. RabbitMQ 中 vhost 的作用是什么？<br>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。<br>139.RabbitMQ 的消息是怎么发送的？<br>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。<br>140.RabbitMQ 怎么保证消息的稳定性？<br>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。<br>141.RabbitMQ 怎么避免消息丢失？<br>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。<br>142.要保证消息持久化成功的条件有哪些？<br>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。<br>143.RabbitMQ 持久化有什么缺点？<br>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。<br>144.RabbitMQ 有几种广播类型？<br>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。<br>145.RabbitMQ 怎么实现延迟消息队列？<br>延迟队列的实现有两种方式：<br>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。<br>43. RabbitMQ 集群有什么用？<br>集群主要有以下两个用途：<br>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。<br>44. RabbitMQ 节点的类型有哪些？<br>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。<br>45. RabbitMQ 集群搭建需要注意哪些问题？<br>各节点之间使用“–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。<br>46. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？<br>不是，原因有以下两个：<br>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。<br>47. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？<br>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<br>不能创建队列<br>不能创建交换器<br>不能创建绑定<br>不能添加用户<br>不能更改权限<br>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。<br>151.RabbitMQ 对集群节点停止顺序有要求吗？<br>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。<br>Kafka<br>48. kafka 可以脱离 zookeeper 单独使用吗？为什么？<br>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。<br>153.kafka 有几种数据保留的策略？<br>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。<br>154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？<br>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。<br>155.什么情况会导致 kafka 运行变慢？<br>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈<br>156.使用 kafka 集群需要注意什么？<br>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。<br>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。<br>Zookeeper<br>157.zookeeper 是什么？<br>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>158.zookeeper 都有哪些功能？<br>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。<br>159.zookeeper 有几种部署模式？<br>zookeeper 有三种部署模式：<br>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。<br>49. zookeeper 怎么保证主从节点的状态同步？<br>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。<br>161.集群中为什么要有主节点？<br>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。<br>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？<br>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。<br>163.说一下 zookeeper 的通知机制？<br>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。<br>MySQL<br>50. 数据库的三范式是什么？<br>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。<br>51. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？<br>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。<br>166.如何获取当前数据库版本？<br>使用 select version() 获取当前 MySQL 数据库版本。<br>167.说一下 ACID 是什么？<br>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>168.char 和 varchar 的区别是什么？<br>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。<br>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。<br>169.float 和 double 的区别是什么？<br>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。<br>170.MySQL 的内连接、左连接、右连接有什么区别？<br>内连接关键字：inner join；左连接：left join；右连接：right join。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。<br>171.MySQL 索引是怎么实现的？<br>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。<br>172.怎么验证 MySQL 的索引是否满足需求？<br>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br>explain 语法：explain select * from table where type&#x3D;1。<br>173.说一下数据库的事务隔离？<br>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：<br>transaction-isolation &#x3D; REPEATABLE-READ<br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。<br>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。<br>177.MySQL 问题排查都有哪些手段？<br>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。<br>185.Redis 支持的 Java 客户端都有哪些？<br>支持的 Java 客户端有 Redisson、jedis、lettuce 等。<br>186.jedis 和 Redisson 有哪些区别？<br>jedis：提供了比较全面的 Redis 命令的支持。<br>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p>
<p>191.Redis 如何做内存优化？<br>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。<br>192.Redis 淘汰策略有哪些？<br>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。<br>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。<br>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。<br>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。<br>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。<br>193.Redis 常见的性能问题有哪些？该如何解决？<br>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。<br>JVM<br>194.说一下 JVM 的主要组成部分？及其作用？<br>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）<br>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。<br>195.说一下 JVM 运行时数据区？<br>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：<br>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；<br>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<br>196.说一下堆栈的区别？<br>功能方面：堆是用来存放对象的，栈是用来执行程序的。<br>共享性：堆是线程共享的，栈是线程私有的。<br>空间大小：堆大小远远大于栈。<br>197.队列和栈是什么？有什么区别？<br>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。<br>198.什么是双亲委派模型？<br>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br>类加载器分类：<br>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。<br>199.说一下类加载的执行过程？<br>类加载分为以下 5 个步骤：<br>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。<br>57. 怎么判断对象是否可以被回收？<br>一般有两种方法来判断：<br>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。<br>58. Java 中都有哪些引用类型？<br>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。<br>207.说一下 JVM 调优的工具？<br>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。<br>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。<br>62. 常用的 JVM 调优的参数都有哪些？<br>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。<br>一、Java 基础部分</p>
<ol>
<li>JAVA 的基本数据类型有哪些 ? String 是不是基本数据类型 ?<br>Java 有 8 种基本数据类型: byte int short long double float Boolean char<br>byte int short long 都属于整数类型. Double float 属于浮点类型. Boolean 为布尔类型<br>Char 为字符型<br>String 不是基本数据类型.它定义的为对象</li>
<li>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>可以有多个类，但只能有一个 public 的类，并且 public 的类名必须与文件名相一致。</li>
<li>Java 有没有 goto?<br>java 中的保留字，现在没有在 java 中使用。</li>
<li>说说&amp;和&amp;&amp;的区别. &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都<br>为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。<br>&amp;&amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，例如，对<br>于 if(str !&#x3D; null &amp;&amp; !str.equals(“”))表达式，当 str 为 null 时，后面的表达式不会执行，所以不<br>会出现 NullPointerException 如果将&amp;&amp;改为&amp;，则会抛出 NullPointerException 异常。If(x&#x3D;&#x3D;33<br>&amp; ++y&gt;0) y 会增长，If(x&#x3D;&#x3D;33 &amp;&amp; ++y&gt;0)不会增长<br>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是 boolean 类型时，&amp;表示按位与操作，<br>我们通常使用 0x0f 来与一个整数进行&amp;运算，来获取该整数的最低 4 个 bit 位，例如，0x31<br>&amp; 0x0f 的结果为 0x01。<br>备注：这道题先说两者的共同点，再说出&amp;&amp;和&amp;的特殊之处，并列举一些经典的例子来表<br>明自己理解透彻深入、实际经验丰富。</li>
<li>在 JAVA 中如何跳出当前的多重嵌套循环？<br>在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环<br>体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如，<br>另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里<br>层循环体代码的控制，例如，要在二维数组中查找到某个数字。</li>
<li>switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上?<br>在 switch（expr1）中，expr1 只能是一个整数表达式或者枚举常量（更大字体），整数表达<br>式可以是 int 基本类型或 Integer 包装类型，由于，byte,short,char 都可以隐含转换为 int，所<br>以，这些类型以及这些类型的包装类型也是可以的。显然，long 和 String 类型都不符合 switch<br>的语法规定，并且不能被隐式转换成 int 类型，所以，它们不能作用于 swtich 语句中。</li>
<li>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 由于 s1+1 运算时会自动提升表达式的类型，所以结果是 int 型，<br>再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误。<br>对于 short s1 &#x3D; 1; s1 +&#x3D; 1;由于 +&#x3D; 是 java 语言规定的运算符，java 编译器会对它进行特殊处<br>理，因此可以正确编译。</li>
<li>char 型变量中能不能存贮一个中文汉字?为什么?<br>char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，<br>char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码<br>字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占<br>用两个字节，所以，char 类型的变量也是占用两个字节。</li>
<li>用最有效率的方法算出 2 乘以 8 等於几?<br>2 &lt;&lt; 3，<br>因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3<br>位即可，而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2 &lt;&lt;<br>3。</li>
<li>请设计一个一百亿的计算器<br>首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要<br>知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的<br>面向对象的设计思想。<br>首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一<br>定的范围的，为了便于讲解和理解，我们先以 byte 类型的整数为例，它用 1 个字节进行存<br>储，表示的最大数值范围为-128 到+127。-1 在内存中对应的二进制数据为 11111111，如果<br>两个-1 相加，不考虑 Java 运算时的类型提升，运算后会产生进位，二进制结果为 1,11111110，<br>由于进位后超过了 byte 类型的存储空间，所以进位部分被舍弃，即最终的结果为 11111110，<br>也就是-2，这正好利用溢位的方式实现了负数的运算。-128 在内存中对应的二进制数据为<br>10000000，如果两个-128 相加，不考虑 Java 运算时的类型提升，运算后会产生进位，二进<br>制结果为 1,00000000，由于进位后超过了 byte 类型的存储空间，所以进位部分被舍弃，即<br>最终的结果为 00000000，也就是 0，这样的结果显然不是我们期望的，这说明计算机中的算<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。<br>由于 Java 中涉及表达式运算时的类型自动提升，我们无法用 byte 类型来做演示这种问题和<br>现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下：<br>int a &#x3D; Integer.MAX_VALUE;<br>int b &#x3D; Integer.MAX_VALUE;<br>int sum &#x3D; a + b;<br>System.out.println(“a&#x3D;”+a+”,b&#x3D;”+b+”,sum&#x3D;”+sum);<br>先不考虑 long 类型，由于 int 的正数范围为 2 的 31 次方，表示的最大数值约等于<br>2<em>1000</em>1000*1000，也就是 20 亿的大小，所以，要实现一个一百亿的计算器，我们得自己<br>设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大<br>概功能如下：<br>（1）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数<br>（2）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中<br>（3）提供加减乘除的功能<br>public class BigInteger{<br>int sign;<br>byte[] val;<br>public Biginteger(String val){<br>sign &#x3D; ;<br>val &#x3D; ;<br>}<br>public BigInteger add(BigInteger other){<br>}<br>public BigInteger subtract(BigInteger other){<br>}<br>public BigInteger multiply(BigInteger other){<br>}<br>public BigInteger divide(BigInteger other){<br>}<br>}<br>备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看 jdk 中自带<br>的 java.math.BigInteger 类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整<br>代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你<br>不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证<br>明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什<br>么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，<br>拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，<br>体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这<br>也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能<br>力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一<br>千元。</li>
<li>使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？<br>使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>还是可以改变的。例如，对于如下语句：<br>final StringBuffer a&#x3D;new StringBuffer(“immutable”);<br>执行如下语句将报告编译期错误：<br>a&#x3D;new StringBuffer(“”);<br>但是，执行如下语句则可以通过编译：<br>a.append(“ broken!”);<br>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：<br>public void method(final StringBuffer param){<br>}<br>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：<br>param.append(“a”);</li>
<li>“&#x3D;&#x3D;”和 equals 方法究竟有什么区别？<br>&#x3D;&#x3D;操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存<br>储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用&#x3D;&#x3D;操作<br>符。<br>如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块<br>内存（堆内存），变量也占用一块内存，例如 Objet obj &#x3D; new Object();变量 obj 是一个内存，<br>new Object()是另一个内存，此时，变量 obj 所对应的内存中存储的数值就是对象占用的那块<br>内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要<br>看这两个变量所对应的内存中的数值是否相等，这时候就需要用&#x3D;&#x3D;操作符进行比较。<br>equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相<br>同，它比较的两个对象是独立的。例如，对于下面的代码：<br>String a&#x3D;new String(“foo”);<br>String b&#x3D;new String(“foo”);<br>两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向了其中一个对象，这是两个<br>不同的对象，它们的首地址是不同的，即 a 和 b 中存储的数值是不相同的，所以，表达式<br>a&#x3D;&#x3D;b 将返回 false，而这两个对象中的内容是相同的，所以，表达式 a.equals(b)将返回 true。<br>在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input &#x3D; …;input.equals(“quit”)，许多人稍不注意就使用&#x3D;&#x3D;进行比较了，这是错误的，随便从网上<br>找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都<br>是使用 equals 方法。<br>如果一个类没有自己定义 equals 方法，那么它将继承 Object 类的 equals 方法，Object 类的<br>equals 方法的实现代码如下：<br>boolean equals(Object o){<br>return this&#x3D;&#x3D;o;<br>}<br>这说明，如果一个类没有自己定义 equals 方法，它默认的 equals 方法（从 Object 类继承的）<br>就是使用&#x3D;&#x3D;操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals<br>和使用&#x3D;&#x3D;会得到同样的结果，如果比较的是两个独立的对象则总返回 false。如果你编写的<br>类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖 equals 方法，由<br>你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。</li>
<li>静态变量和实例变量的区别？<br>语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量<br>才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所<br>以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分<br>配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来<br>使用，静态变量则可以直接使用类名来引用。<br>例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并<br>且每创建一个实例对象，这个 staticVar 就会加 1；但是，每创建一个实例对象，就会分配一<br>个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。<br>public class VariantTest{<br>public static int staticVar &#x3D; 0;<br>public int instanceVar &#x3D; 0;<br>public VariantTest(){<br>staticVar++;<br>instanceVar++;<br>System.out.println(“staticVar&#x3D;” + staticVar + ”,instanceVar&#x3D;” + instanceVar);<br>}<br>}<br>备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，<br>体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！</li>
<li>是否可从一个 static 方法内发出对非 static 方法的调用？<br>不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对<br>象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一<br>个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非<br>static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，<br>一个 static 方法内部发出对非 static 方法的调用。</li>
<li>Integer 与 int 的区别<br>int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 java<br>为 int 提供的封装类。int 的默认值为 0，而 Integer 的默认值为 null，即 Integer 可以区分出<br>未赋值和值为 0 的区别，int 则无法表达出未赋值的情况，例如，要想表达出没有参加考试<br>和考试成绩为 0 的区别，则只能使用 Integer。在 JSP 开发中，Integer 的默认为 null，所以用<br>el 表达式在文本框中显示时，值为空白字符串，而 int 默认的默认值为 0，所以用 el 表达式<br>在文本框中显示时，结果为 0，所以，int 不适合作为 web 层的表单数据的类型。<br>在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可以根据其值是否为 null<br>而判断一个对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中<br>设置其 unsaved-value 属性为 0。<br>另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer<br>中还定义了表示整数的最大值和最小值的常量。</li>
<li>Math.round(11.5)等於多少? Math.round(-11.5)等於多少?<br>Math 类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英<br>文名称的含义相对应，例如，ceil 的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)<br>的结果为 12,Math.ceil(-11.3)的结果是-11；floor 的英文意义是地板，该方法就表示向下取整，<br>Math.ceil(11.6)的结果为 11,Math.ceil(-11.6)的结果是-12；最难掌握的是 round 方法，它表示<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>“四舍五入”，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，<br>Math.round(11.5)的结果为 12，Math.round(-11.5)的结果为-11。</li>
<li>下面的代码有什么不妥之处?</li>
<li>if(username.equals(“zxx”){}<br>2.int x &#x3D; 1;<br>return x&#x3D;&#x3D;1?true:false;</li>
<li>请说出作用域 public，private，protected，以及不写时的区别<br>说明：如果在修饰的元素上面没有写任何访问修饰符，则表示 friendly。<br>作用域 当前类 同一 package 子孙类 其他 package<br>public √ √ √ √<br>protected √ √ √ ×<br>friendly √ √ × ×<br>private √ × × ×<br>备注：只要记住了有 4 种访问权限，4 个访问范围，然后将全选和范围在水平和垂直方向上<br>分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。</li>
<li>Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型?<br>Overload 是重载的意思，Override 是覆盖的意思，也就是重写。<br>重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相<br>同（即参数个数或类型不同）。<br>重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类<br>创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个<br>完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法<br>时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决<br>父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能<br>更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增<br>加了一个全新的方法。<br>至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这<br>个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也<br>可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它<br>们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因<br>为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，<br>我们调用 map.remove(key)方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接<br>收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回<br>类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型<br>来判断。<br>override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达<br>到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法<br>进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，<br>我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：<br>1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；<br>2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；<br>3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>4、被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行<br>覆盖。<br>overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的<br>方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数<br>样式，来选择合适的方法执行。在使用重载要注意以下的几点：<br>1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不<br>同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，<br>但是不能为 fun(int,int)）；<br>2、不能通过访问权限、返回类型、抛出的异常进行重载；<br>3、方法的异常类型和数目不会对重载造成影响；<br>4、对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进<br>行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</li>
<li>同学贡献的一些题?<br>1.搞了多个重载方法，参数分别是 int ,char,和 double，然后将 double x &#x3D; 2，传递进去，会选<br>择哪个方法？<br>2.说说对 javaee 中的 session 的理解，你是怎么用 session 的？cvs&#x2F;svn 下载<br>3.jdk 中哪些类是不能继承的：System,String,StringBuffer 等。<br>4.在 eclipse 中调试时，怎样查看一个变量的值。<br>5.判断身份证：要么是 15 位，要么是 18 位，最后一位可以为字母，并写程序提出其中的年<br>月日。<br>6.一个房子里有椅子，椅子有腿和背，房子与椅子是什么关系，椅子与腿和背是什么关系？<br>7.如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关<br>联。椅子与腿和背时组合关系。<br>8.说说 has a 与 is a 的区别。<br>9.工厂模式的类图</li>
<li>线程如何同步和通讯？<br>同学回答说 synchronized 方法或代码块！面试官似乎不太满意！<br>只有多个 synchronized 代码块使用的是同一个监视器对象，这些 synchronized 代码块之间才<br>具有线程互斥的效果，假如 a 代码块用 obj1 作为监视器对象，假如 b 代码块用 obj2 作为监<br>视器对象，那么，两个并发的线程可以同时分别进入这两个代码块中。 …这里还可以分析<br>一下同步的原理。<br>对于同步方法的分析，所用的同步监视器对象是 this<br>接着对于静态同步方法的分析，所用的同步监视器对象是该类的 Class 对象<br>接着对如何实现代码块与方法的同步进行分析。</li>
<li>ClassLoader 如何加载 class ？<br>jvm 里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap 类加载负责<br>加载 jre&#x2F;lib&#x2F;rt.jar 中的类， 我们平时用的 jdk 中的类都位于 rt.jar 中。extclassloader 负责加载<br>jar&#x2F;lib&#x2F;ext&#x2F;*.jar 中的类，appclassloader 负责 classpath 指定的目录或 jar 中的类。除了 bootstrap<br>之外，其他的类加载器本身也都是 java 类，它们的父类是 ClassLoader。</li>
<li>Servlet 的生命周期？<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销<br>毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个<br>实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，<br>服务完成后就销毁，所以效率上低于 servlet</li>
<li>抽象类的作用？</li>
<li>ArrayList 如何实现插入的数据按自定义的方式有序存放？<br>class MyBean implements Comparable{<br>public int compareTo(Object obj){<br>if(! obj instanceof MyBean)<br>throw new ClassCastException() &#x2F;&#x2F;具体异常的名称，我要查 jdk 文档。<br>MyBean other &#x3D; (MyBean) obj;<br>return age &gt; other.age?1:age&#x3D;&#x3D; other.age?0:-1;<br>}<br>}<br>class MyTreeSet {<br>private ArrayList datas &#x3D; new ArrayList();<br>public void add(Object obj){<br>for(int i&#x3D;0;i&lt;datas.size();i++){<br>if(obj.compareTo(datas.get(i) !&#x3D; 1){<br>datas.add(i,obj);<br>}<br>}<br>}<br>}</li>
<li>分层设计的好处？<br>把各个功能按调用流程进行了模块化，模块化带来的好处就是可以随意组合，举例说明：如<br>果要注册一个用户，流程为显示界面并通过界面接收用户的输入，接着进行业务逻辑处理，<br>在处理业务逻辑又访问数据库，如果我们将这些步骤全部按流水帐的方式放在一个方法中编<br>写，这也是可以的，但这其中的坏处就是，当界面要修改时，由于代码全在一个方法内，可<br>能会碰坏业务逻辑和数据库访问的码，同样，当修改业务逻辑或数据库访问的代码时，也会<br>碰坏其他部分的代码。分层就是要把界面部分、业务逻辑部分、数据库访问部分的代码放在<br>各自独立的方法或类中编写，这样就不会出现牵一发而动全身的问题了。这样分层后，还可<br>以方便切换各层，譬如原来的界面是 Swing，现在要改成 BS 界面，如果最初是按分层设计<br>的，这时候不需要涉及业务和数据访问的代码，只需编写一条 web 界面就可以了。<br>下面的仅供参考，不建议照搬照套，一定要改成自己的语言，发现内心的感受：<br>分层的好处：1.实现了软件之间的解耦；2.便于进行分工；3.便于维护；4.提高软件组件的重<br>用；5.便于替换某种产品，比如持久层用的是 hibernate,需要更换产品用 toplink，就不用其他<br>业务代码，直接把配置一改；6.便于产品功能的扩展；7.便于适用用户需求的不断变化</li>
<li>序列化接口的 id 有什么用？<br>对象经常要通过 IO 进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某<br>种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”Person，既然大家都要这么干，并且没<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有个统一的干法，于是，sun 公司就提出一种统一的解决方案，它会把对象变成某个格式进<br>行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想<br>能被 sun 的这种方案处理，必须实现 Serializable 接口。<br>ObjectOutputStream.writeObject(obj);<br>Object obj &#x3D; ObjectInputStream.readObject();<br>假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了<br>另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun 的 jdk 就<br>会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本<br>号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，<br>则直接报版本号不同的错!</li>
<li>StringBuffer 与 StringBuilder 的区别？<br>因为 StringBuilder sbuilder &#x3D; ;是线程不安全的，运行效率高，如果一个字符串变量是在方法<br>里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用 StringBuilder。<br>如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用<br>StringBuffer。</li>
<li>hashCode 方法的作用？<br>首先，想要明白 hashCode 的作用，你必须要先知道 Java 中的集合。<br>总的来说，Java 中的集合（Collection）有两类，一类是 List，再有一类是 Set。你知道<br>它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重<br>复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该<br>依据什么来判断呢？这就是 Object.equals 方法了。但是，如果每增加一个元素就检查一次，<br>那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中<br>现在已经有 1000 个元素，那么第 1001 个元素加入集合时，它就要调用 1000 次 equals 方法。<br>这显然会大大降低效率。于是，Java 采用了哈希表的原理。可以简单理解，hashCode 方法<br>实际上返回的就是对象存储的物理地址（实际可能并不是）。这样一来，当集合要添加新的<br>元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。<br>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果<br>这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，<br>不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用 equals<br>方法的次数就大大降低了，几乎只需要一两次。<br>所以，Java 对于 eqauls 方法和 hashCode 方法是这样规定的：<br>1、如果两个对象相同，那么它们的 hashCode 值一定要相同；<br>2、如果两个对象的 hashCode 相同，它们并不一定相同<br>上面说的对象相同指的是用 eqauls 方法比较。<br>你当然可以不按要求去做了，但你会发现，相同的对象可以出现在 Set 集合中。同时，增<br>加新元素的效率会大大下降。</li>
<li>webservice 问得很多</li>
<li>设计出计算任意正整数的阶层？</li>
<li>在 oracle 数据库中需要查询出前 8 条记录的 sql 语句怎么写？</li>
<li>什么是 SOA，谈谈你的 SOA 的理解。service orientied architecture？<br>SOA 是指为了解决在 Internet 环境下业务集成的需要，通过连接能完成特定任务的独立功能<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实体实现的一种软件系统架构。1.  软件系统架构：SOA 不是一种语言，也不是一种具体的技术而是一种软件系统架构，<br>它尝试给出在特定环境下推荐采用的一种架构，从这个角度上来说，它更像一种模式<br>(Pattern)。因此它与很多已有的软件技术比如面向对象技术，是互补的而非互斥的。它们分<br>别面向不同的应用场景，用来满足不同的特定需求。</li>
<li>SOA 的使用范围：需求决定同时也限制功能。SOA 并不是包治百病的万灵丹，它最<br>主要的应用场合在于解决在 Internet 环境下的不同商业应用之间的业务集成问题。1.  如何实现线程间的通讯？<br>在 Java 语言中，提供了各种各样的输入输出流（stream）,使我们能够很方便的对数据进行<br>操作，其中，管道（pipe）流是一种特殊的流，用于在不同线程（threads）间直接传送数据。<br>一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同<br>线程间的通讯。无需求助于类似临时文件之类的东西。本文在简要介绍管道的基本概念后，<br>将以一个具体的实例 pipeapp 加以详细说明。<br>1．管道的创建与使用<br>Java 提供了两个特殊的专门的类专门用于处理管道，它们就是 pipedinputstream 类和<br>pipeoutputstream 类。<br>Pipedinputstream 代表了数据在管道中的输出端，也就是线程向管道读数据的一端；<br>pipeoutputstream 代表了数据在管道中的输入端，也就是线程向管道写数据的一端，这两个<br>类一起使用可以提供数据的管道流。<br>为了创建一个管道流，我们必须首先创建一个 pipeoutstream 对象，然后，创建<br>pipeinputstream 对象，实例如下：<br>pipeout&#x3D; new pipedyoutstream();<br>pipein&#x3D; new pipedputsteam(pipepout); 一旦创建了一个管道后，就可以象操作文件一样对管道进行数据的读写。<br>2．演示程序： pipeapp<br>应用程序由三个程序组成：主线程（pipeapp.Java）及由主线程启动的两个二级线程<br>（ythread.Java 和 zthread.Java）,它们使用管道来处理数据。程序从一个内容为一行一行”x” 字母的”input.txt”文件中读取数据，使用管道传输数据，第一次是利用线程 ythread 将数据”x” 转换为”y”，最后利用线程 zthread 将”y”转换为”z”,之后，程序在屏幕上显示修改后的数据。<br>主线程 （pipeapp.Java）<br>在 main()方法中，程序首先创建一个应用对象：pipeapp pipeapp&#x3D;new pipeapp();<br>由于程序中流操作都需要使用 IOException 异常处理，所以设置了一个 try 块。在 try 中，为<br>了从源文件中读取数据，程序为”input.txt”文件创建了一个输入流 Xfileln,:<br>fileinputstream xfileln&#x3D; new fileinputstream(“input.txt”);<br>新的输入流传递给 changetoy()方法，让线程 ythread 能读取该文件：<br>inputstream ylnpipe &#x3D;pipeapp.changetoy(xfileln);<br>changetoy()方法创建将输入数据”x”改变到”y”的线程 ythread,并返回该线程的输入管道：<br>inputstream zlnpipe &#x3D; pipeapp.changetoz(ylnpipe);<br>changetoz()方法启动将数据从”y”改变到”z”的线程 zehread,主程序将使用从 changetoz()<br>返回的输入管道。得到以修改的数据。<br>然后，程序将管道输入流定位到 datainputstream 对象，使程序能够使用 readline()方法读<br>取数据：<br>datainputstream inputstream &#x3D; new datainputstream(zlnpiepe);<br>创建了输入流以后，程序就可以以行一行的读取数据病显示在屏幕上。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>String str&#x3D; inputstream.readline();<br>While(str!&#x3D;null){<br>system.out.println(str);<br>str&#x3D;inputstream.readline();<br>}<br>显示完成之后，程序关闭输入流：<br>inputstream.close();<br>changetoy()方法<br>changetoy()方法首先通过传递一个参数 inputstream 给 datainputstream 对象来定位资源的<br>输入流，使程序能使用 readline()方法从流中读取数据：<br>datainputstream xfileln &#x3D;new datainutstream(inputstream)；<br>然后，changetoy()创建输出管道和输入管道：<br>pipeoutstream pipeout &#x3D; new pipeoutputstream();<br>pipeinputstream pipeln &#x3D; new pipedinputsteam(pipeout);<br>为了能够使用 println()方法输出修改的后的文本行到管道，程序将输出管道定位到<br>printstream 对象：<br>printstream printstream &#x3D; new printstream(pipeout);<br>现在，程序可以创建将数据从 x 改变到 y 的线程，该线程是 ythread 类的一个对象，他<br>传递两个参数：输入文件（xfileln）和输出管道（调用 printstream）<br>ythread ythread &#x3D;new thread(xfileln,printstream);<br>之后，程序启动线程：<br>changetoz（）方法<br>changetoz()方法与 changetoy()方法很相似，他从 changetoy()返回的输入流开始：<br>datainputstream yfileln&#x3D; new datainputstream(inputstream);<br>程序创建一个新的管道：<br>pipedoutstream pipeout2 &#x3D; new pipedoutputstream();<br>pipedinputstream pipeln2 &#x3D; new pipedinputsream(pipeout2);<br>该线程通过这个新的管道发出修改后的数据（输入流 pipeln2）给主程序。</li>
</ol>
<p>Ythread 类和 Zthread 类<br>由于 ythread 类与 zthread 类基本一样，在此仅以 ythread 为例加以说明。<br>Ythread 的构造器接收两个参数：输入的文件和第一个管道的输出端，构造器存储这两<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>个参数作为类的数据成员：<br>Ythread(datainputstream xfileln,pringstream printstream){<br>this.xfileln &#x3D; xfileln;<br>this.printstream &#x3D; printstream;<br>}<br>线程通过 run()方法来处理数据。首先读取一行数据，确保 xstring 不为空的情况下循环<br>执行：<br>string xstring &#x3D; xfileln.readline();<br>每读一行数据，完成一次转换<br>string ystring &#x3D; xstring.replace(‘x’,’y’);<br>然后将修改后的数据输出到管道的输出端：<br>prinstream.prinrln(ystring);<br>为了确保所有缓冲区的数据完全进入管道的输出端：<br>pringstram.flush();<br>循环完成后，线程关闭管道输出流：<br>pringstram.close();<br>ythread 类的源程序如下：<br>6.  构造器 Constructor 是否可被 override?<br>构造器 Constructor 不能被继承，因此不能重写 Override，但可以被重载 Overload。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>7.  接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具<br>体类(concrete class)? 抽象类中是否可以有静态的 main 方法？<br>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类<br>中可以有静态的 main 方法。<br>备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是 java<br>语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道<br>理不提供，那答案就是肯定的了。<br>只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有 abstract 方法。<br>8.  写 clone()方法时，通常都有一行代码，是什么？<br>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己<br>的成员。<br>9.  谈谈你对面向对象的理解<br>面向对象是一种程序的设计方法，或者说它是一种程序设计范型，其基本思想是使用对象，<br>类，继承，封装，消息等基本概念来进行程序设计。<br>它是从现实世界中客观存在的事物（即对象）出发来构造软件系统，并在系统构造中尽可能<br>运用人类的自然思维方式，强调直接以问题域（现实世界）中的事物为中心来思考问题，认<br>识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的对象，作为系统的基本<br>构成单位（而不是用一些与现实世界中的事物相关比较远，并且没有对应关系的其它概念来<br>构造系统）。这可以使系统直接地映射问题域，保持问题域中事物及其相互关系的本来面貌。<br>它可以有不同层次的理解：<br>从世界观的角度可以认为：面向对象的基本哲学是认为世界是由各种各样具有自己的运动规<br>律和内部状态的对象所组成的；不同对象之间的相互作用和通讯构成了完整的现实世界。因<br>此，人们应当按照现实世界这个本来面貌来理解世界，直接通过对象及其相互关系来反映世<br>界。这样建立起来的系统才能符合现实世界的本来面目。<br>从方法学的角度可以认为：面向对象的方法是面向对象的世界观在开发方法中的直接运用。<br>它强调系统的结构应该直接与现实世界的结构相对应，应该围绕现实世界中的对象来构造系<br>统，而不是围绕功能来构造系统。<br>从程序设计的角度来看，面向对象的程序设计语言必须有描述对象及其相互之间关系的语言<br>成分。这些程序设计语言可以归纳为以下几类：系统中一切皆为对象；对象是属性及其操作<br>的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间<br>的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息<br>的序列。<br>10. 面向对象的特征有哪些方面？<br>面向对象的编程语言有封装、继承 、抽象、多态等 4 个主要的特征。<br>1．封装：<br>封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、<br>低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装<br>的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就<br>是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变<br>量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要<br>记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只<br>有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同<br>一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类<br>中。<br>例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个<br>对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中<br>定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两<br>个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配<br>在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个<br>体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例<br>子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配<br>给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能<br>完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动<br>作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。<br>2．抽象：<br>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些<br>事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与<br>当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是<br>抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个 Person 类，如下：<br>class Person{<br>String name;<br>int age;<br>}<br>人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上<br>面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些<br>与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及<br>的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。<br>3．继承：<br>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在<br>的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适<br>合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一<br>种关系，提高了软件的可重用性和可扩展性。<br>4．多态：<br>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编<br>程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，<br>该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<br>因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到<br>各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以<br>改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性<br>增强了软件的灵活性和扩展性。例如，下面代码中的 UserDao 是一个接口，它定义引用变量<br>userDao 指向的实例对象由 daofactory.getDao()在执行的时候返回，有时候指向的是<br>UserJdbcDao 这个实现，有时候指向的是 UserHibernateDao 这个实现，这样，不用修改源代<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>码，就可以改变 userDao 指向的具体类实现，从而导致 userDao.insertUser()方法调用的具体<br>代码也随之改变，即有时候调用的是 UserJdbcDao 的 insertUser 方法，有时候调用的是<br>UserHibernateDao 的 insertUser 方法：<br>UserDao userDao &#x3D; daofactory.getDao();<br>userDao.insertUser(user);<br>比喻：人吃饭，你看到的是左手，还是右手？<br>11. java 中实现多态的机制是什么？<br>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方<br>法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运<br>行的那个对象的方法，而不是引用变量的类型中定义的方法。<br>12. abstract class 和 interface 有什么区别?<br>含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方<br>法的类必须定义为 abstract class，abstract class 类中的方法不必是抽象的。abstract class 类中<br>定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方<br>法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。<br>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口<br>中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final。<br>下面比较一下两者的语法区别：<br>1.抽象类可以有构造方法，接口中不能有构造方法。<br>2.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象<br>的普通方法。<br>4.抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型,虽然 eclipse 下不报<br>错，但应该也不行），但接口抽象方法只能是 public 类型的，并且默认即为 public abstract<br>类型。<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任<br>意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。<br>7.一个类可以实现多个接口，但只能继承一个抽象类。<br>下面接着再说说两者在应用上的区别：<br>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类<br>在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个<br>典型应用，假设某个项目的所有 Servlet 类都要用相同的方式进行权限判断、记录访问日志<br>和处理异常，那么就可以定义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在<br>抽象基类的 service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中<br>只是完成各自的业务逻辑代码，伪代码如下：<br>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。<br>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，<br>最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普<br>通成员变量和方法（包括抽象方法），静态变量和方法，继承性等 6 个方面逐一去比较回答，<br>接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功<br>底。<br>13. abstract 的 method 是 否可 同 时是 static,是 否可 同 时是 native， 是否 可 同时 是<br>synchronized?<br>abstract 的 method 不可以是 static 的，因为抽象的方法是要被子类实现的，而 static 与子类<br>扯不上关系！<br>native 方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问<br>题，所以，它也不能是抽象的，不能与 abstract 混用。例如，FileOutputSteam 类要和硬件打<br>交道，底层的实现用的是操作系统相关的 api 实现，例如，在 windows 用 c 语言实现的，所<br>以，查看 jdk 的源代码，可以发现 FileOutputStream 的 open 方法的定义如下：<br>private native void open(String name) throws FileNotFoundException;<br>如果我们要用 java 调用别人写的 c 语言函数，我们是无法直接调用的，我们需要按照 java<br>的要求写一个 c 语言的函数，又我们的这个 c 语言函数去调用别人的 c 语言函数。由于我们<br>的 c 语言函数是按 java 的要求来写的，我们这个 c 语言函数就可以与 java 对接上，java 那<br>边的对接方式就是定义出与我们这个 c 函数相对应的方法，java 中对应的方法不需要写具体<br>的代码，但需要在前面声明 native。<br>关于 synchronized 与 abstract 合用的问题，我觉得也不行，因为在我几年的学习和开发中，<br>从来没见到过这种情况，并且我觉得 synchronized 应该是作用在一个具体的方法上才有意<br>义。而且，方法上的 synchronized 同步所使用的同步锁对象是 this，而抽象方法上无法确定<br>this 是什么。<br>14. 什么是内部类？Static Nested Class 和 Inner Class 的不同？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>使用 static 声明的内部类就是外部类，可以通过外部类.内部类直接访问。<br>普通内部类是不能够直接被外部所访问的，需要通过外部类实例在找到内部类实例。<br>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特<br>性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放<br>到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。<br>我想可能是既然静态成员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，<br>所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该<br>被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，<br>也可以定义在外部类的方法体中，如下所示：<br>在方法体外面定义的内部类的访问类型可以是 public,protecte,默认的，private 等 4 种类型，<br>这就好像类中定义的成员变量有 4 种访问类型一样，它们决定这个内部类的定义对其他类是<br>否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象<br>时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对<br>象，代码如下：<br>Outer outer &#x3D; new Outer();<br>Outer.Inner1 inner1 &#x3D; outer.new Innner1();<br>在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，<br>但这种内部类的前面可以使用 final 或 abstract 修饰符。这种内部类对其他类是不可见的其他<br>类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部<br>类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局<br>部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但<br>是，该局部变量前必须加 final 修饰符。<br>对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误信息就可以马上<br>了解到。<br>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同<br>时，还创建了该子类的实例对象，无需为该子类定义名称：<br>public class Outer {<br>public void start() {<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>new Thread(new Runnable() {<br>public void run() {<br>};<br>}).start();<br>}<br>}<br>最后，在方法外部定义的内部类前面可以加上 static 关键字，从而成为 Static Nested Class，<br>它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class 与普通类<br>在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定<br>义成 public、protected、默认的、private 等多种类型，而普通类只能定义成 public 和默认的<br>这两种类型。在外面引用 Static Nested Class 类的名称为“外部类名.内部类名”。在外面不<br>需要创建外部类的实例对象，就可以直接创建 Static Nested Class，例如，假设 Inner 是定义<br>在 Outer 类中的 Static Nested Class，那么可以使用如下语句创建 Inner 类：<br>Outer.Inner inner &#x3D; new Outer.Inner();<br>由于 static Nested Class 不依赖于外部类的实例对象，所以，static Nested Class 能访问外部类<br>的非 static 成员变量。当在外部访问 Static Nested Class 时，可以直接使用 Static Nested Class<br>的名字，而不需要加上外部类的名字了，在 Static Nested Class 中也可以直接引用外部类的<br>static 的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是 Static Nested Class，这时候不能在类前面加 static 关键字，<br>静态方法中的 Static Nested Class 与普通方法中的内部类的应用方式很相似，它除了可以直<br>接访问外部类中的 static 的成员变量，还可以访问静态方法中的局部变量，但是，该局部变<br>量前必须加 final 修饰符。<br>备注：首先根据你印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可<br>以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知<br>识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。<br>15. 内部类可以引用它的包含类的成员吗？有没有什么限制？<br>完全可以。如果不是静态内部类，那没有什么限制！<br>如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员<br>变量，而只能访问外部类中的静态成员，例如，下面的代码：</p>
<p>答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问<br>外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情<br>况，让人家吃惊。<br>16. Anonymous Inner Class (匿名内部类) 是否可继承其它类，是否可以 implements 接<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>口?<br>可以继承其他类或实现其他接口。不仅是可以，而是必须!因为匿名内部类就是在抽象类和<br>接口的基础上发展起来的。<br>17. class.forName 的作用？<br>调用该访问 返回一个以字符串指定类名的类的对象。<br>返回字节码，返回字节码的方式有几种:<br>①：这份字节码曾经被加载过已经存在 java 虚拟机中了直接返回。<br>②：java 虚拟机中还没有这份字节码 用类加载器去加载 把加载进来的字节码缓存在虚拟机<br>中，以后再得到这个字节码就不用再加载。<br>得到字节码对应的实例对象: 类名.class ; 对象.getClass(),例如 new Date; 类名.class，<br>例如，System.class<br>对 象 .getClass() ， 例 如 ， new Date().getClass() Class.forName( “ 类 名 ” ) ， 例 如 ，<br>Class.forName(“java.util.Date”);<br>③：静态方法去查询或者加载这个字符串所对应哪个类的字节码<br>因为在写源程序的时候还不知道类的名字，在我运行的时候人家传递我一个字符串，这个字<br>符串里面包含了一个类的名字，再写程序的时候把 java.util.Date 换成一个字符串变量， 等<br>程序运行起来的时候这个变量的值从一个配置文件里面装再进来，这个类的名字在写原程序<br>的时候不用知道而是等运行的时候给我临时送进来。<br>》》》》》》》》》》》》》》》》》》》》》》》》》》》《《《《《《《《《《《《《《《《《《《《《《《《《《《《《<br>按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，<br>则返回代表该字节码的 Class 实例对象，否则，按类加载器的委托机制去搜索和加载该类，<br>如果所有的类加载器都无法加载到该类，则抛出 ClassNotFoundException。加载完这个 Class<br>字节码后，接着就可以使用 Class 字节码的 newInstance 方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时<br>才能确定，这时候就需要使用 Class.forName 去动态加载该类，这个类名通常是在配置文件<br>中配置的，例如，spring 的 ioc 中每次依赖注入的具体类就是这样配置的，jdbc 的驱动类名<br>通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类<br>名<br>18. super.getClass()方法调用？<br>下面程序的输出结果是多少？<br>import java.util.Date;<br>public class Test extends Date{<br>public static void main(String[] args) {<br>new Test().test();<br>}<br>public void test(){<br>System.out.println(super.getClass().getName());<br>}<br>}<br>很奇怪，结果是 Test<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>这属于脑筋急转弯的题目，在一个 qq 群有个网友正好问过这个问题，我觉得挺有趣，就研<br>究了一下，没想到今天还被你面到了，哈哈。<br>在 test 方法中，直接调用 getClass().getName()方法，返回的是 Test 类名<br>由于 getClass()在 Object 类中定义成了 final，子类不能覆盖该方法，所以，在 test 方法中调<br>用 getClass().getName()方法，其实就是在调用从父类继承的 getClass()方法，等效于调用<br>super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是 Test。<br>如果想得到父类的名称，应该用如下代码：<br>getClass().getSuperClass().getName();<br>19. String 是最基本的数据类型吗?<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型，因此不可继承这个类、不能修改这个类。为提高效率节省空<br>间，我们应用 StringBuffer 类。<br>20. String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的 String 对象中的内容<br>到底变了没有？<br>没有。因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。这段<br>代码中，s 原先指向一个 String 对象，内容是 “Hello”，然后我们对 s 进行了+操作，那么 s<br>所指向那个对象是否发生了改变呢？答案是没有。这时，s 不指向原来那个对象，而指向了<br>另一个 String 对象，内容为”Hello world!”，原来那个对象还存在于内存中，只是 s 这个引用<br>变量不再指向它了。<br>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，<br>或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。因为<br>String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来<br>表示。这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生<br>成一个新的对象。并且，这两种类的对象转换十分容易。<br>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如<br>我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这<br>样做：<br>public class Demo {<br>private String s;<br>public Demo() {<br>s &#x3D; “Initial Value”;<br>}<br>}<br>而非 s &#x3D; new String(“Initial Value”);<br>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String<br>对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，<br>多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。<br>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表<br>同一个 String 对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是<br>否相同。<br>至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多<br>Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变<br>类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不<br>同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一<br>个可变版本，即 StringBuffer。<br>21. 是否可以继承 String 类?<br>String 类是 final 类故不可以继承. 55. String s &#x3D; new String(“xyz”);创建了几个 String Object? 二者之间有什么区别？<br>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多<br>少遍，都是缓冲区中的那一个。New String 每写一遍，就创建一个新的对象，它一句那个常<br>量”xyz”对象的内容来创建出一个新 String 对象。如果以前就用过’xyz’，这句代表就不会创<br>建”xyz”自己了，直接从缓冲区拿。<br>22. String 和 StringBuffer 的区别？<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多个<br>字符的字符数据。这个 String 类提供了数值不可改变的字符串。而这个 StringBuffer 类提供<br>的字符串进行修改。当你知道字符数据要改变的时候你就可以使用 StringBuffer。典型地，<br>你可以使用 StringBuffers 来动态构造字符数据。另外，String 实现了 equals 方法，new<br>String(“abc”).equals(new String(“abc”)的结果为 true,而 StringBuffer 没有实现 equals 方法，所<br>以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为 false。接着要举一个具<br>体的例子来说明，我们要把 1 到 100 的所有数字拼起来，组成一个串。<br>StringBuffer sbf &#x3D; new StringBuffer();<br>for(int i&#x3D;0;i&lt;100;i++){<br>sbf.append(i);<br>}<br>上面的代码效率很高，因为只创建了一个 StringBuffer 对象，而下面的代码效率很低，因为<br>创建了 101 个对象。<br>String str &#x3D; new String();<br>for(int i&#x3D;0;i&lt;100;i++){<br>str &#x3D; str + i;<br>}<br>在讲两者区别时，应把循环的次数搞成 10000，然后用 endTime-beginTime 来比较两者执行<br>的时间差异，最后还要讲讲 StringBuilder 与 StringBuffer 的区别。<br>String 覆盖了 equals 方法和 hashCode 方法，而 StringBuffer 没有覆盖 equals 方法和 hashCode<br>方法，所以，将 StringBuffer 对象存储进 Java 集合类中时会出现问题。<br>23. 如何把一段逗号分割的字符串转换成一个数组?<br>如果不查 jdk api，我很难写出来！我可以说说我的思路：用正则表达式，代码大概为：<br>String [] result &#x3D; orgStr.split(“,”);<br>用 StingTokenizer ,代码为：StringTokenizer tokener &#x3D; StringTokenizer(orgStr,”,”);<br>String [] result &#x3D; new String[tokener .countTokens()];<br>Int i&#x3D;0;<br>while(tokener.hasNext(){result[i++]&#x3D;toker.nextToken();}<br>24. 数组有没有 length()这个方法? String 有没有 length()这个方法？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>数组没有 length()这个方法，有 length 的属性。String 有有 length()这个方法。<br>25. 下面这条语句一共创建了多少个对象：String s&#x3D;”a”+”b”+”c”+”d”？<br>答：对于如下代码：<br>String s1 &#x3D; “a”;<br>String s2 &#x3D; s1 + “b”;<br>String s3 &#x3D; “a” + “b”;<br>System.out.println(s2 &#x3D;&#x3D; “ab”);<br>System.out.println(s3 &#x3D;&#x3D; “ab”);<br>第一条语句打印的结果为 false，第二条语句打印的结果为 true，这说明 javac 编译可以对字<br>符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译<br>时去掉其中的加号，直接将其编译成一个这些常量相连的结果。<br>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所<br>以，上面的代码应该只创建了一个 String 对象。写如下两行代码，<br>String s &#x3D; “a” + “b” + “c” + “d”;<br>System.out.println(s &#x3D;&#x3D; “abcd”);<br>最终打印的结果应该为 true。<br>26. try {}里有一 return 语句，那紧跟在这个 try 后的 finally {}里的 code 是否被执行，什<br>么时候被执行，在 return 前还是后?<br>也许你的答案是在 return 之前，但往更细地说，我的答案是在 return 中间执行，请看下面程<br>序代码的运行结果：<br>public class Test {<br>public static void main(String[] args) {<br>System.out.println(new Test().test());<br>}<br>static int test(){<br>int x &#x3D; 1;<br>try{<br>return x;<br>}<br>finally{<br>++x;<br>}<br>}<br>}<br>运行结果是 1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐<br>子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓<br>返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说<br>这话之前放进罐子里的。<br>29. error 和 exception 有什么区别?<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程<br>序运行正常，从不会发生的情况。<br>Error 表示有 JVM 进行处理的,是 JVM 出错. Exctption 是可以用程序进行处理的,使用 try…catch 进行处理. 65. Java 中的异常处理机制的简单原理和应用。<br>异常是指 java 程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很<br>相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个<br>对象来表示，Java 使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封<br>装到一个对象来表示的，该对象中包含有异常的信息。<br>Java 对异常进行了分类，不同类型的异常分别用不同的 Java 类表示，所有异常的根类为<br>java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception，Error 表示应<br>用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程<br>死锁等系统问题。Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普<br>通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问<br>题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者<br>让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常<br>（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化<br>或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样<br>的异常后，程序不应该死掉。<br>java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处<br>理或用 throws 声明继续抛给上层调用方法处理，所以普通异常也称为 checked 异常，而系统<br>异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用 throws 声明，所以<br>系统异常也称为 unchecked 异常。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉<br>的错误，程序不应该死掉的错误；<br>30. 请写出你最常见到的 5 个 runtime exception。<br>这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面<br>的异常，你不一定真要回答出 5 个具体的系统异常，但你要能够说出什么是系统异常，以及<br>几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，<br>那就用中文吧，有总比没有强！<br>所 谓 系 统 异 常 ， 就 是 ….. ， 它 们 都 是 RuntimeException 的 子 类 ， 在 jdk doc 中 查<br>RuntimeException 类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比<br>较 有 印 象 的 系 统 异 常 有 ： NullPointerException 、 ArrayIndexOutOfBoundsException 、<br>ClassCastException。<br>31. java 如何进行异常处理，throws,throw,try,catch,finally 代表什么意义？在 try 块中可<br>以抛出异常吗？<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。<br>在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到<br>这个异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一<br>个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来<br>处理；<br>try 用来指定一块预防所有“异常”的程序；<br>catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的类型；<br>throw 语句用来明确地抛出一个“异常”；<br>throws 用来标明一个成员函数可能抛出的各种“异常”；<br>finally 为确保一段代码不管发生什么“异常”都被执行一段代码；<br>可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try 语<br>句保护其他代码。每当遇到一个 try 语句，“异常”的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇<br>到有处理这种“异常”的 try 语句。<br>32. 在 java 中如何进行 socket 编程。<br>答：Sockets 有两种主要的操作方式:面向连接的和无连接的。<br>无连接的操作使用数据报协议.这个模式下的 socket 不需要连接一个目的的 socket,它只是简<br>单地投出数据报.无连接的操作是快速的和高效的,但是数据安全性不佳.面向连接的操作使<br>用 TCP 协议.一个这个模式下的 socket 必须在发送数据之前与目的地的 socket 取得一个连接. 一旦连接建立了,sockets 就可以使用一个流接口:打开-读-写-关闭.所有的发送的信息都会在<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>另一端以同样的顺序被接收.面向连接的操作比无连接的操作效率更低,但是数据的安全性更<br>高. 在服务器，使用 ServerSocket 监听指定的端口，端口可以随意指定（由于 1024 以下的端口<br>通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于 1024 的端口），<br>等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。在客户端，使用<br>Socket 对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话<br>完成后，关闭 Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个 1024<br>以上的端口。<br>40. 线程的基本概念、线程的基本状态以及状态之间的关系<br>一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程<br>上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，<br>即 main 方法执行的那个线程。如果只是一个 cpu，它怎么能够同时执行多段程序呢？这是<br>从宏观上来看的，cpu 一会执行 a 线索，一会执行 b 线索，切换时间很快，给人的感觉是 a,b<br>在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一<br>会为 a 传数据，一会为 b 传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。<br>状态：就绪，运行，synchronize 阻塞，wait 和 sleep 挂起，结束。wait 必须在 synchronized<br>内部调用。<br>调用线程的 start 方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状<br>态，遇到 synchronized 语句时，由运行状态转为阻塞，当 synchronized 获得锁后，由阻塞转<br>为运行，在这种情况可以调用 wait 方法转为挂起状态，当线程关联的代码执行完后，线程<br>变为结束状态。<br>44. 介绍 Collection 框架的结构<br>答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。<br>Collection<br>├List<br>│├LinkedList<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>│├ArrayList<br>│└Vector<br>│ └Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap<br>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素<br>（Elements）<br>Map 提供 key 到 value 的映射<br>45. Collection 框架中实现比较要实现什么接口<br>comparable&#x2F;comparator<br>46. ArrayList 和 Vector 的区别<br>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存<br>储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位<br>置索引号取出某个元素，并且其中的数据是允许重复的，这是 HashSet 之类的集合的最大不<br>同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本<br>来题目问的与 hashset 没有任何关系，但为了说清楚 ArrayList 与 Vector 的功能，我们使用对<br>比方式，更有利于说明问题）。<br>接着才说 ArrayList 与 Vector 的区别，这主要包括两个方面：. （1）同步性：<br>Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安<br>全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用<br>ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是<br>使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。<br>(备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全问题，记住 Vector 与<br>Hashtable 是旧的，是 java 一诞生就提供的，它们是线程安全的，ArrayList 与 HashMap 是 java2<br>时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。)<br>（2）数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量<br>时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加一个<br>存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率<br>之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没<br>有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始<br>的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方<br>法。<br>总结：即 Vector 增长原来的一倍，ArrayList 增加原来的 0.5 倍。<br>49. List, Set, Map 是否继承自 Collection 接口?<br>List，Set 是，Map 不是<br>50. List、Map、Set 三个接口，存取元素时，各有什么特点？<br>这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内<br>容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不<br>明白。<br>首先，List 与 Set 具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接<br>口，叫 Collection。Set 里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不<br>是仅仅是相同）的对象 ，即假设 Set 集合中有了一个 A 对象，现在我要向 Set 集合再存入<br>一个 B 对象，但 B 对象与 A 对象 equals 相等，则 B 对象存储不进去，所以，Set 集合的 add<br>方法有一个 boolean 的返回值，当集合中没有某个元素，此时 add 方法可成功加入该元素时，<br>则返回 true，当集合含有与某个元素 equals 相等的元素时，此时 add 方法无法加入该元素，<br>返回结果为 false。Set 取元素时，没法说取第几个，只能以 Iterator 接口取得所有的元素，<br>再逐一遍历各个元素。<br>List 表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我<br>们多次调用 add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>到的顺序排序。有时候，也可以插队，即调用 add(int index,Obj e)方法，就可以指定当前对<br>象在集合中的存放位置。一个对象可以被反复存储进 List 中，每调用一次 add 方法，这个对<br>象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用<br>一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指向了<br>这个对象，如图 x 所示。List 除了可以以 Iterator 接口取得所有的元素，再逐一遍历各个元<br>素之外，还可以调用 get(index i)来明确说明取第几个。<br>Map 与 List 和 Set 不同，它是双列的集合，其中有 put 方法，定义如下：put(obj key,obj value)，<br>每次存储时，要存储一对 key&#x2F;value，不能存储重复的 key，这个重复的规则也是按 equals<br>比较相等。取则可以根据 key 获得相应的 value，即 get(Object key)返回值为 key 所对应的<br>value。另外，也可以获得所有的 key 的结合，还可以获得所有的 value 的结合，还可以获得<br>key 和 value 组合成的 Map.Entry 对象的集合。<br>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存<br>key-value 值，value 可多值。<br>HashSet 按照 hashcode 值的某种运算方式进行存储，而不是直接按 hashCode 值的大小进行<br>存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65 在 hashSet 中的存储顺序不是 62,65,78，<br>LinkedHashSet 按插入的顺序存储，那被存储对象的 hashcode 方法还有什么作用呢？我们想<br>想!hashset 集合比较两个对象是否相等，首先看 hashcode 方法是否相等，然后看 equals 方法<br>是否相等。new 两个 Student 插入到 HashSet 中，看 HashSet 的 size，实现 hashcode 和 equals<br>方法后再看 size。<br>同一个对象可以在 Vector 中加入多次。往集合里面加元素，相当于集合里用一根绳子连接<br>到了目标对象。往 HashSet 中却加不了多次的。<br>51. 说出 ArrayList,Vector, LinkedList 的存储性能和特性<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增<br>加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存<br>操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），<br>通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进<br>行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。<br>LinkedList 也是线程不安全的，LinkedList 提供了一些方法，使得 LinkedList 可以被当作堆<br>栈和队列来使用。<br>52. 去掉一个 Vector 集合中重复的元素<br>Vector newVector &#x3D; new Vector();<br>For (int i&#x3D;0;i&lt;vector.size();i++){<br>Object obj &#x3D; vector.get(i);<br>53. if(!newVector.contains(obj);<br>newVector.add(obj);<br>}<br>还有一种简单的方式，HashSet set &#x3D; new HashSet(vector);<br>54. Collection 和 Collections 的区别。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>Collection： 是集合类的上级接口，继承与他的接口主要有 Set 和 List. Collections：是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、<br>排序、线程安全化等操作。<br>55. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是<br>equals()? 它们有何区别?<br>Set 里的元素是不能重复的，元素重复与否是使用 equals()方法进行判断的。<br>equals()和&#x3D;&#x3D;方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个分<br>离的对象的内容和类型相配的话，返回真值。<br>56. 链表和数组的区别？<br>创建数组时，必须明确说明数组的长度,(即数组中元素的个数),以便在内存中留出一块空间<br>存放所有的数组元素,数组中各数据元素在内存中是顺序存放的。<br>创建链表时，不需要给出链表中元素(称为节点)的个数,可以先只创建一个链表头,其他元素<br>在需要时动态地创建并加入到链表,链表的数据无素在内存中不是连续存放的。<br>57. 你所知道的集合类都有哪些？主要方法？<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变<br>大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索<br>引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），<br>其中每个键映射到一个值。<br>ArrayList&#x2F;VectorList<br>Collection<br>HashSet&#x2F;TreeSetSet<br>PropetiesHashTable<br>Map<br>Treemap&#x2F;HashMap<br>我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，<br>我记得不是很清楚，对于 set，大概的方法是 add,remove, contains；对于 map，大概的方法<br>就是 put,remove，contains 等，因为，我只要在 eclispe 下按点操作符，很自然的这些方法就<br>出来了。我记住的一些思想就是 List 类会有 get(int index)这样的方法，因为它可以按顺序取<br>元素，而 set 类中没有 get(int index)这样的方法。List 和 set 都可以迭代出所有元素，迭代时<br>先要得到一个 iterator 对象，所以，set 和 list 类都有一个 iterator 方法，用于返回那个 iterator<br>对象。map 可以返回三个集合，一个是返回所有的 key 的集合，另外一个返回的是所有 value<br>的集合，再一个返回的 key 和 value 组合成的 EntrySet 对象的集合，map 也有 get 方法，参<br>数是 key，返回值是 key 对应的 value。<br>58. 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code，这句话对不对?<br>对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode<br>值就必须相等。<br>如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode<br>不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没有理由不实<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>现，通常都会去实现的。<br>59. TreeSet 里面放对象，如同时放入父类和子类实例对象，比较时使用的是父类的<br>compareTo 方法，还是子类的 compareTo 方法，还是抛异常！<br>（应该是没有针对问题的确切的答案，当前的 add 方法放入的是哪个对象，就调用哪个对象<br>的 compareTo 方法，至于这个 compareTo 方法怎么做，就看当前这个对象的类中是如何编写<br>这个方法的）</p>
<ol start="60">
<li><p>说出一些常用的类，包，接口，请各举 5 个<br>要让人家感觉你对 java ee 开发很熟，所以，不能仅仅只列 core java 中的那些东西，要多列<br>你在做 ssh 项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。<br>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer<br>java.util.Date，System，Class，List,HashMap<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>常 用 的 包 ： java.lang java.io java.util<br>java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate<br>常 用 的 接 口 ： Remote List Map Document<br>NodeList ,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate) 、<br>Session(Hibernate),HttpSession</p>
</li>
<li><p>java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出<br>他们分别是哪些类？<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于 InputStreamReader<br>OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</p>
</li>
<li><p>字节流与字符流的区别<br>要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数<br>据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进<br>行描述，这个抽象描述方式起名为 IO 流，对应的抽象类为 OutputStream 和 InputStream ，<br>不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。<br>在实际应用中，经常需要把完全是字符的一段文本输出去或读进来，用字节流可以吗？计算<br>机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的<br>字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，<br>我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。<br>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进<br>行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写<br>入底层设备，这为我们向 IO 设别写入或读取字符串提供了一点点方便。<br>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某<br>种编码的字节形式，读取也是反之的道理。<br>讲解字节流与字符流关系的代码案例：</p>
</li>
<li><p>描述一下 JVM 加载 class 文件的原理机制?<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的 Java<br>运行时系统组件。它负责在运行时查找和装入类文件的类。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p>
</li>
<li><p>heap 和 stack 有什么区别。<br>java 的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会<br>为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结<br>束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。<br>堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new<br>创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final<br>修饰后，放在堆中，而不是栈中。</p>
</li>
<li><p>GC 是什么? 为什么要有 GC?<br>GC：垃圾回收，使用 GC 可以进行垃圾空间释放操作。<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘<br>记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动<br>监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存<br>的显示操作方法。</p>
</li>
<li><p>垃圾回收的优点和原理。并考虑 2 种回收机制。<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的问<br>题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾<br>回收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收<br>可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的<br>低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进<br>行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回<br>收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。<br>简单答法:将无用的空间对象进行释放. 俩中回收机制:自动回收和手工调用 System.gc()方法,实际上调用 System.gc 就相当于调用了<br>Runtime.getRuntime().gc()方法. 104. 垃圾回收器的基本原理是？垃圾回收器可以马上回收内存吗？如何主动通知虚拟机<br>进行垃圾回收？<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对<br>象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回<br>收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。</p>
</li>
<li><p>什么时候用 assert。<br>JDK1.4 之后增加的新关键字——assert，表示断言，即程序执行到某个地方之后值肯定是预<br>计好的；一般开发中很少使用 assert；要想使用断言，就必须使用-ea 参数。<br>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在<br>实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确<br>的状态下，assert 将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正<br>确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检<br>查通常是关闭的。</p>
</li>
<li><p>java 中会存在内存泄漏吗，请简单描述。<br>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java 中有垃圾<br>回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被<br>垃圾回收器从内存中清除掉。由于 Java 使用有向图的方式进行垃圾回收管理，可以消除引<br>用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可<br>以回收它们的，例如下面的代码可以看到这种情况的内存回收：</p>
</li>
</ol>
<p>java 中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存<br>泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不<br>能被回收，这就是 java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对<br>象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃<br>圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了<br>一个对象放在缓存中(例如放在一个全局 map 对象中)，然后一直不再使用它，这个对象一直<br>被缓存引用，但却不再被使用。<br>检查 java 中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某<br>个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。<br>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引<br>用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外<br>部类对象将不会被垃圾回收，这也会造成内存泄露。<br>下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，<br>而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中<br>消失，将那个元素所在的位置的值设置为 null 即可）：<br>我实在想不到比那个堆栈更经典的例子了,以致于我还要引用别人的例子，下面的例子不是<br>我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可<br>是那时我说是我自己想到的也没有人相信的。</p>
<p>上面的原理应该很简单，假如堆栈加了 10 个元素，然后全部弹出来，虽然堆栈是空的，没<br>有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，<br>无法回收。<br>但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪<br>费了几个 K 内存而已，反正我们的内存都上 G 了，哪里会有什么影响，再说这个东西很快<br>就会被回收的，有什么关系。下面看两个例子。<br>例子 1</p>
<p>因为是 static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果<br>你的 Stack 最多有 100 个对象，那么最多也就只有 100 个对象无法被回收其实这个应该很容<br>易理解，Stack 内部持有 100 个引用，最坏的情况就是他们都是无用的，因为我们一旦放新<br>的进取，以前的引用自然消失！<br>内存泄露的另外一种情况：当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合<br>中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的<br>参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet<br>集合中单独删除当前对象，造成内存泄露。<br>70. 能不能自己写个类，也叫 java.lang.String？<br>可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去<br>加载 jre.jar 包中的那个 java.lang.String。由于在 tomcat 的 web 应用程序中，都是由 webapp<br>自己的类加载器先自己加载 WEB-INF&#x2F;classess 目录中的类，然后才委托上级的类加载器加<br>载，如果我们在 tomcat 的 web 应用程序中写一个 java.lang.String，这时候 Servlet 程序加载<br>的就是我们自己写的 java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了<br>java.lang.String 类的都将出现问题。<br>虽然 java 提供了 endorsed 技术，可以覆盖 jdk 中的某些类，具体做法是….。但是，能够被<br>覆盖的类是有限制范围，反正不包括 java.lang 这样的包中的类。<br>（下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题<br>目泄露了）例如，运行下面的程序：<br>package java.lang;<br>public class String {<br>public static void main(String[] args) {<br>System.out.println(“string”);<br>}<br>}<br>报告的错误如下：<br>java.lang.NoSuchMethodError: main<br>Exception in thread “main” 这是因为加载了 jre 自带的 java.lang.String，而该类中没有 main 方法。 二、Java 代码查错<br>abstract class Name {<br>private String name;<br>public abstract boolean isStupidName(String name) {}<br>}<br>大侠们，这有何错误?<br>答案: 错。abstract method 必须以分号结尾，且不带花括号。<br>2.public class Something {<br>void doSomething () {<br>private String s &#x3D; “”;<br>int l &#x3D; s.length();<br>}<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有错吗?<br>答案: 错。局部变量前不能放置任何访问修饰符 (private，public，和 protected)。final 可以<br>用来修饰局部变量<br>(final 如同 abstract 和 strictfp，都是非访问修饰符，strictfp 只能修饰 class 和 method 而非<br>variable)。<br>3.abstract class Something {<br>private abstract String doSomething ();<br>}<br>这好像没什么错吧?<br>答案: 错。abstract 的methods不能以private修饰。abstract的 methods就是让子类 implement(实<br>现)具体细节的，怎么可以用 private 把 abstract<br>method 封锁起来呢? (同理，abstract method 前不能加 final)。<br>4.public class Something {<br>public int addOne(final int x) {<br>return ++x;<br>}<br>}<br>这个比较明显。<br>答案: 错。int x 被修饰成 final，意味着 x 不能在 addOne method 中被修改。<br>5.public class Something {<br>public static void main(String[] args) {<br>Other o &#x3D; new Other();<br>new Something().addOne(o);<br>}<br>public void addOne(final Other o) {<br>o.i++;<br>}<br>}<br>class Other {<br>public int i;<br>}<br>和上面的很相似，都是关于 final 的问题，这有错吗?<br>答案: 正确。在 addOne method 中，参数 o 被修饰成 final。如果在 addOne method 里我们修<br>改了 o 的 reference<br>(比如: o &#x3D; new Other();)，那么如同上例这题也是错的。但这里修改的是 o 的 member vairable<br>(成员变量)，而 o 的 reference 并没有改变。<br>6.class Something {<br>int i;<br>public void doSomething() {<br>System.out.println(“i &#x3D; “ + i);<br>}<br>}<br>有什么错呢? 看不出来啊。<br>答案: 正确。输出的是”i &#x3D; 0”。int i 属於 instant variable (实例变量，或叫成员变量)。instant<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>variable 有 default value。int 的 default value 是 0。<br>7.class Something {<br>final int i;<br>public void doSomething() {<br>System.out.println(“i &#x3D; “ + i);<br>}<br>}<br>和上面一题只有一个地方不同，就是多了一个 final。这难道就错了吗?<br>答案: 错。final int i 是个 final 的 instant variable (实例变量，或叫成员变量)。final 的 instant<br>variable 没有 default value，必须在 constructor (构造器)结束之前被赋予一个明确的值。可以<br>修改为”final int i &#x3D; 0;”。<br>8.public class Something {<br>public static void main(String[] args) {<br>Something s &#x3D; new Something();<br>System.out.println(“s.doSomething() returns “ + doSomething());<br>}<br>public String doSomething() {<br>return “Do something …”;<br>}<br>}<br>看上去很完美。<br>答案: 错。看上去在 main 里 call doSomething 没有什么问题，毕竟两个 methods 都在同一个<br>class 里。但仔细看，main 是 static 的。static method 不能直接 call non-static methods。可改<br>成”System.out.println(“s.doSomething() returns “ + s.doSomething());”。同理，static method 不<br>能访问 non-static instant variable。<br>9.此处，Something 类的文件名叫 OtherThing.java<br>class Something {<br>private static void main(String[] something_to_do) {<br>System.out.println(“Do something …”);<br>}<br>}<br>这个好像很明显。<br>答案: 正确。从来没有人说过 Java 的 Class 名字必须和其文件名相同。但 public class 的名字<br>必须和文件名相同。<br>10．interface A{<br>int x &#x3D; 0;<br>}<br>class B{<br>int x &#x3D;1;<br>}<br>class C extends B implements A {<br>public void pX(){<br>System.out.println(x);<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public static void main(String[] args) {<br>new C().pX();<br>}<br>}<br>答案：错误。在编译时会发生错误(错误描述不同的 JVM 有不同的信息，意思就是未明确的<br>x 调用，两个 x 都匹配（就象在同时 import java.util 和 java.sql 两个包时直接声明 Date 一样）。<br>对于父类的变量,可以用 super.x 来明确，而接口的属性默认隐含为 public static final.所以可<br>以通过 A.x 来明确。<br>11.interface Playable {<br>void play();<br>}<br>interface Bounceable {<br>void play();<br>}<br>interface Rollable extends Playable, Bounceable {<br>Ball ball &#x3D; new Ball(“PingPang”);<br>}<br>class Ball implements Rollable {<br>private String name;<br>public String getName() {<br>return name;<br>}<br>public Ball(String name) {<br>this.name &#x3D; name;<br>}<br>public void play() {<br>ball &#x3D; new Ball(“Football”);<br>System.out.println(ball.getName());<br>}<br>}<br>这个错误不容易发现。<br>答案: 错。”interface Rollable extends Playable, Bounceable”没有问题。interface 可继承多个<br>interfaces，所以这里没错。问题出在 interface Rollable 里的”Ball ball &#x3D; new Ball(“PingPang”);”。<br>任何在 interface 里声明的 interface variable (接口变量，也可称成员变量)，默认为 public static<br>final。也就是说”Ball ball &#x3D; new Ball(“PingPang”);”实际上是”public static final Ball ball &#x3D; new<br>Ball(“PingPang”);”。在 Ball 类的 Play()方法中，”ball &#x3D; new Ball(“Football”);”改变了 ball 的<br>reference，而这里的 ball 来自 Rollable interface，Rollable interface 里的 ball 是 public static final<br>的，final 的 object 是不能被改变 reference 的。因此编译器将在”ball &#x3D; new Ball(“Football”);” 这里显示有错。 三、算法与编程<br>71. 用 java 实现一种排序；java 类实现序列化的方法(二种)？ 如在 collection 框架中，<br>实现比较要实现什么样的接口？</p>
<p>JAVA 类实现序例化的方法是实现 java.io.Serializable 接口<br>Collection 框架中实现比较要实现 Comparable 接口和 Comparator 接口<br>127. 说说你用过那些 ajax 技术和框架，说说它们的区别<br>答:去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存<br>五、Java web 部分<br>128. Tomcat 的优化经验<br>答:去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。<br>有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存<br>129. HTTP 的请求过程？<br>当点击一个链接时,浏览器首先找到站点的 IP 地址,这是通过 DNS 来实现的,在找到 IP 地址后<br>就可以建立 TCP 连接了,连接建立后我们就可以发送请求了.但这个请求是什么样子的呢 ?<br>我们现在假设点击了一个从 <a href="http://www.webmonkey.com/HTML/96/47/Index2A">www.webmonkey.com/HTML/96/47/Index2A</a> , HTML 点击了<br><a href="WWW.GRIPY.ORG/MATTARG/">WWW.GRIPY.ORG/MATTARG/</a> 这时浏览器会发出下面的请求:<br>Get&#x2F;MATTARG&#x2F;HTML&#x2F;1.0<br>User-Agent: Mozilla&#x2F;2.0(macitosh;1;PPC)<br>Accept: text&#x2F;html: <em>&#x2F;</em> Cookie: name &#x3D; value<br>Refetet: <a href="http://www.webmonkey.com/html/96/47/index2a.html">http://www.webmonkey.com/html/96/47/index2a.html</a><br>Host: <a href="http://www.gtippy.org/">www.gtippy.org</a><br>第一行称为请求,它告诉服务器从 MATTMARG 取得文件,这是的目录一般是要加 &#x2F; 的,下面<br>几行通知服务器你所使用的浏览器是什么类型,你所接收的数据是什么类型,如果你以前访问<br>过这个站点,站点可能向你发送了 Cookie ,如果你已经有了一个这样的 Cookie ,浏览器会将<br>这个 Cookie 返回给服务器, referer 行通知服务器用户从哪一页到达此页的. 下面服务器就要返回文件了,每次服务器返回文件时,都要返回一个 Http&#x2F;1.0 响应,同进带有<br>状态码,在此之后是述内部的头信息,下面就是一个响应:<br>HTTP&#x2F;1.0 200 Pound<br>Data: Mon 10 Feb 1997 23:48:22 GMT<br>Server: Apache&#x2F;1.1 1 Hot&amp;ired&#x2F;1.0<br>Content-type: text&#x2F;html<br>Last-Moditied: Tues,11 Feb 1997 22:45:55 GMT<br>不同的数据可能返回不同的 Content-type ，因此不同的内容需要不同的 Content-type ，因<br>此有时候这个过程是很慢的。<br>130. HTTP 请求的 GET 与 POST 方式的区别<br>答：Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST<br>方法。二者主要区别如下：<br>1）Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据；<br>2）Get 将表单中数据按照 variable&#x3D;value 的形式，添加到 action 所指向的 URL 后面，<br>并且两者使用“?”连接，而各个变量之间使用“&amp;”连接；Post 是将表单中的数据放在 form<br>的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL；<br>3）Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中；Post 的所有操作对<br>用户来说都是不可见的；<br>4）Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，<br>所以在上传文件只能使用 Post；<br>5）Get 限制 Form 表单的数据集必须为 ASCII 字符，而 Post 支持整个 ISO10646 字符集；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>6）Get 是 Form 的默认方法。<br>131. 解释一下什么是 servlet？<br>Servlet 是一种独立于平台和协议的服务器端的 Java 技术，可以用来生成动态的 Web 页面。<br>与传统的 CGI（计算机图形接口）和许多其他类似 CGI 技术相比，Servlet 具有更好的可移<br>植性、更强大的功能，更少的投资，更高的效率，更好的安全性等特点。<br>Servlet 是使用 Java Servlet 应用程序接口（API）及相关类和方法的 Java 程序。Java 语言<br>能够实现的功能，Servlet 基本上都能实现（除了图形界面之外）。Servlet 主要用于处理客<br>户端传来的 Http 请求，并返回一个响应。通常所说的 Servlet 就是指 HttpServlet，用于处理<br>Http 请求，其能够处理的请求有 doGet()、doPost()、service()等方法。在开发 Servlet 时，可<br>以直接继承 javax.servlet.http.HttpServlet。<br>Servlet 需要在 web.xml 中进行描述，例如：映射执行 Servlet 的名字，配置 Servlet 类、初<br>始化参数，进行安全配置、URL 映射和设置启动的优先权等。Servlet 不仅可以生成 HTML<br>脚本输出，也可以生成二进制表单输出。<br>Servlet 应用范围很广泛，我们现在用的很多流行的框架技术，其最基本的代码离不开<br>Servelt 的支持。比如我所熟悉的 SSH 框架，Spring 容器启动时，要在 web.xml 中装载 Spring<br>容器的 ActionContext 类来初始化 Spring 的一些参数，如进行依赖注入、数据库表的映射、<br>初始化系统的安全配置设置 read 等属性等一些相关操作。<br>132. 说一说 Servlet 的生命周期?<br>答:servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。<br>这个生存期由 javax.servlet.Servlet 接口的 init,service 和 destroy 方法表达。<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service<br>方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销<br>毁的时候调用其 destroy 方法。<br>web 容器加载 servlet，生命周期开始。通过调用 servlet 的 init()方法进行 servlet 的初始化。<br>通过调用 service()方法实现，根据请求的不同调用不同的 do***()方法。结束服务，web 容<br>器调用 servlet 的 destroy()方法。<br>133. Servlet 的基本架构<br>package test;<br>import java.io.IOException;<br>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>public class ServletName extends HttpServlet {<br>public void doPost(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public void doGet(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>}<br>}<br>134. SERVLET API 中 forward()与 redirect()的区别？<br>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后<br>者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的<br>地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量<br>使用 forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳<br>转到一个其它服务器上的资源，则必须使用 sendRedirect()方法。<br>135. 什么情况下调用 doGet()和 doPost()？<br>Jsp 页面中的 FORM 标签里的 method 属性为 get 时调用 doGet()，为 post 时调用 doPost()。<br>136. Request 对象的主要方法：<br>setAttribute(String name,Object)：设置名字为 name 的 request 的参数值<br>getAttribute(String name)：返回由 name 指定的属性值<br>getAttributeNames()：返回 request 对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有 Cookie 对象，结果是一个 Cookie 数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的 Body 的长度<br>getHeader(String name)：获得 HTTP 协议定义的文件头信息<br>getHeaders(String name)：返回指定名字的 request Header 的所有值，结果是一个枚举的实例<br>getHeaderNames()：返回所以 request Header 的名字，结果是一个枚举的实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有 name 指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实<br>例<br>getParametervalues(String name)：获得有 name 指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的 IP 地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关 Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性<br>137. 简述 HttpSession 的作用、使用方法，可用代码说明。<br>HttpSession 中 可 以 跟 踪 并 储 存 用 户 信 息 ， 把 值 设 置 到 属 性 中 ， 有 2 个 方 法 ：<br>setAttribute(),getAttrribute()；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>例如：在一个方法中用 session.setAttribute(“student”,student);在 session 中设置一个属性名为<br>student,值为一个名为 student 的对象。而后可在同一 session 范围内用 getAttribute(“student”)<br>取出该属性，得到 student 对象。<br>138. 请画出 Servlet 2.2 以上 Web Application 的基本目录结构<br>答：目录结构如下图所示：<br>webapps<br>|<br>Applocation<br>| __________________<br>| |<br>JSP 页面 WEB-INF<br>| ___________________<br>| | |<br>classes lib web.xml<br>139. cookie 和 session 的区别？<br>注意 cookie 有时候禁不掉<br>Cookie session<br>存储在客户端 存储在服务器端<br>两种类型<br>有声明周期<br>无声明周期<br>两种实现方式<br>依赖于 cookie<br>url 重写<br>父路径不能访问子路径的 cookie 同一个 session 的窗口共享一个 session<br>典型应用：<br>3 个月不用再登陆<br>购物车（<a href="http://www.china-pub.com/%EF%BC%89">http://www.china-pub.com/）</a><br>典型应用：<br>用户登陆<br>购物车也可以用 session 实现。·<br>不可靠 可靠<br>140. forward 和 redirect 的区别<br>forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读<br>取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，<br>所以它的地址栏中还是原来的地址。<br>redirect 就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏<br>览器会用刚才请求的所有参数重新请求，所以 session,request 参数都可以获取。<br>141. request.getAttribute() 和 request.getParameter() 有何区别?<br>当你要传递普通的数据类型给下一个页面时，你在下一个页面中就可以用 getParameter()方<br>法来获得上一个页面传递过来的数据了！（普通的数据类型是指 int,float,double,string 等在<br>Java 中常用的基本类型，但是在下一个页面中你用 getParameter()方法获得的值永远只能时<br>String 类型的，你可以把 String 类型转换为你所需要的类型！）<br>当你要传递一个对象给下一个页面时，你就要使用 getAttribut()方法了！如：你要把一个 List<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>或 Map 传递到下一个页面，这时你就必须要用 setAttribut()和 getAttribut()方法传递数据了！<br>从更深层次的考虑，getParameter()方法传递数据，只会从 WEB 客户端传递到 WEB 服务器，<br>代表 HTTP 请求数据，getParameter()方法返回 String 类型的数据！setAttribut()和 getAttribut()<br>方法传递的数据只会在 WEB 服务器内部，在具有转发关系的 WEB 组件之间传递，这两个<br>方法能设置 Object 类型的共享数据！<br>142. jsp 有哪些内置对象?作用分别是什么? 分别有什么方法？<br>答:JSP 共有以下 9 个内置的对象：<br>request 用户端请求，此请求会包含来自 GET&#x2F;POST 请求的参数<br>response 网页传回用户端的回应<br>pageContext 网页的属性是在这里管理<br>session 与请求有关的会话期<br>application servlet 正在执行的内容<br>out 用来传送回应的输出<br>config servlet 的构架部件<br>page JSP 网页本身<br>exception 针对错误网页，未捕捉的例外<br>request：表示 HttpServletRequest 对象。它包含了有关浏览器请求的信息，并且提供了几个<br>用于获取 cookie, header, 和 session 数据的有用的方法。<br>response：表示 HttpServletResponse 对象，并提供了几个用于设置送回 浏览器的响应的方法<br>（如 cookies,头信息等）<br>out：对象是 javax.jsp.JspWriter 的一个实例，并提供了几个方法使你能用于向浏览器回送输<br>出结果。<br>pageContext：表示一个 javax.servlet.jsp.PageContext 对象。它是用于方便存取各种范围的名<br>字空间、servlet 相关的对象的 API，并且包装了通用的 servlet 相关功能的方法。<br>session：表示一个请求的 javax.servlet.http.HttpSession 对象。Session 可以存贮用户的状态信<br>息<br>applicaton ：表示一个 javax.servle.ServletContext 对象。这有助于查找有关 servlet 引擎和<br>servlet 环境的信息<br>config：表示一个 javax.servlet.ServletConfig 对象。该对象用于存取 servlet 实例的初始化参<br>数。<br>page：表示从该页面产生的一个 servlet 实例<br>143. 介绍在 JSP 中如何使用 JavaBeans？<br>答：在 JSP 中使用 JavaBean 常用的动作有：<br>1）&lt;jsp:useBean &#x2F;&gt;：用来创建和查找 bean 对象；<br>2）&lt;jsp:setProperty &#x2F;&gt;：用来设置 bean 的属性，即调用其 setXxx()方法；<br>3）&lt;jsp:getProperty &#x2F;&gt;：用来获得 bean 的属性，即调用其 getXxx()方法。<br>144. jsp 有哪些动作?作用分别是什么?<br>（这个问题似乎不重要，不明白为何有此题）<br>答:JSP 共有以下 6 种基本动作<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>jsp:setProperty：设置 JavaBean 的属性。<br>jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记<br>145. JSP 的常用指令<br>isErrorPage(是否能使用 Exception 对象)，isELIgnored(是否忽略表达式)<br>146. jsp 的四种范围？<br>答：a.page 是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类<br>（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括<br>被编译成 servlet 的 JSP 页面<br>b.request 是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越<br>多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系）<br>c.session 是代表与用于某个 Web 客户机的一个用户体验相关对象和属性。一个 Web<br>会话可以也经常会跨越多个客户机请求<br>d.application 是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个<br>Web 应用程序，包括多个页面、请求和会话的一个全局作用域。<br>147. JSP 中动态 INCLUDE 与静态 INCLUDE 的区别？<br>答：动态 INCLUDE 用 jsp:include 动作实现<br>&lt;jsp:include page&#x3D;included.jsp flush&#x3D;true &#x2F;&gt;它总是会检查所含文件中的变化，适合用于包含动<br>态页面，并且可以带参数 静态 INCLUDE 用 include 伪码实现,定不会检查所含文件的变化，<br>适用于包含静态页面 &lt;%@ include file&#x3D;included.htm %&gt;<br>148. 两种跳转方式分别是什么?有什么区别?<br>（下面的回答严重错误，应该是想问 forward 和 sendRedirect 的区别，毕竟出题的人不是专<br>业搞文字艺术的人，可能表达能力并不见得很强，用词不一定精准，加之其自身的技术面也<br>可能存在一些问题，不一定真正将他的意思表达清楚了，严格意思上来讲，一些题目可能根<br>本就无人能答，所以，答题时要掌握主动，只要把自己知道的表达清楚就够了，而不要去推<br>敲原始题目的具体含义是什么，不要一味想着是在答题）<br>答：有两种，分别为：<br>&lt;jsp:include page&#x3D;included.jsp flush&#x3D;true&gt;<br>&lt;jsp:forward page&#x3D; nextpage.jsp&#x2F;&gt;<br>前者页面不会转向 include 所指的页面，只是显示该页的结果，主页面还是原来的页面。执<br>行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。<br>相当于 go to 语句. 149. 页面间对象传递的方法<br>request，session，application，cookie 等<br>150. 过滤器有哪些作用？<br>答：可以验证客户是否来自可信的网络，可以对客户提交的数据进行重新编码，可以从系统<br>里获得配置的信息，可以过滤掉客户的某些不应该出现的词汇，可以验证用户是否登录，可<br>以验证客户的浏览器是否支持当前的应用，可以记录系统的日志等等。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>151. 过滤器的用法？（对客户端的请求统一编码和对客户端进行认证）<br>答：首先要实现（implements）Filter 接口，同时覆盖 Filter 接口的三个方法：<br>init(FilterConfig config) &#x2F;&#x2F;用于获得 FilterConfig 对象；<br>doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &#x2F;&#x2F;进行过滤处<br>理一些业务；<br>destroy() &#x2F;&#x2F;销毁 Filter。<br>152. JSP 和 Servlet 中的请求转发分别如何实现？<br>答：JSP 中的请求转发可利用 forward 动作实现：&lt;jsp:forward &#x2F;&gt;；<br>Serlvet 中实现请求转发的方式为：<br>getServletContext().getRequestDispatcher(path).forward(req,res)。<br>153. JSP 和 Servlet 有哪些相同点和不同点，他们之间的联系是什么？<br>JSP 是 Servlet 技术的扩展，本质上是 Servlet 的简易方式，更强调应用的外表表达。JSP 编<br>译后是”类 servlet”。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件<br>中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成<br>一个扩展名为.jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。<br>154. 详细描述 MVC。<br>答：基于 Java 的 Web 应用系统采用 MVC 架构模式，即 model（模型）、view（视图）、control<br>（控制）分离设计；这是目前 WEB 应用服务系统的主流设计方向。<br>Model：即处理业务逻辑的模块，每一种处理一个模块；<br>View：负责页面显示，显示 MODEL 处理结果给用户，主要实现数据到页面转换过程；<br>Control：负责每个请求的分发，把 FORM 数据传递给 MODEL 处理，把处理结果的数<br>据传递给 VIEW 显示。<br>155. MVC 的各个部分都有那些技术来实现?如何实现?<br>答:MVC 是 Model－View－Controller 的简写。Model 代表的是应用的业务逻辑（通过<br>JavaBean，EJB 组件实现）， View 是应用的表示面（由 JSP 页面产生），Controller 是提<br>供应用的处理过程控制（一般是一个 Servlet），通过这种设计模型把应用逻辑，处理过程<br>和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。<br>156. 在 web 应用开发过程中经常遇到输出某种编码字符，如 iso8859-1 等，如何输出一个<br>某种编码字符串？<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1”), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>157. 现在输入 n 个数字，以逗号，分开；然后可选择升或者降序排序；按提交键就在另一<br>页面显示按什么排序，结果为，提供 reset.(答案有点疑惑,问题有点不清不楚)<br>答案（1） public static String[] splitStringByComma(String source){<br>if(source&#x3D;&#x3D;null||source.trim().equals(“”))<br>return null;<br>StringTokenizer commaToker &#x3D; new StringTokenizer(source,”,”);<br>String[] result &#x3D; new String[commaToker.countTokens()];<br>int i&#x3D;0;<br>while(commaToker.hasMoreTokens()){<br>result[i] &#x3D; commaToker.nextToken();<br>i++;<br>}<br>return result;<br>}<br>循环遍历 String 数组<br>Integer.parseInt(String s)变成 int 类型<br>组成 int 数组<br>Arrays.sort(int[] a), a 数组升序<br>降序可以从尾部开始输出<br>158. 说出数据连接池的工作机制是什么?<br>答：J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客<br>户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没<br>有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用<br>的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>159. javascript 的优缺点和内置对象。<br>答：1）优点：简单易用，与 Java 有类似的语法，可以使用任何文本编辑工具编写，只需要<br>浏览器就可执行程序，并且事先不用编译，逐行执行，无需进行严格的变量声明，而且内置<br>大量现成对象，编写少量程序可以完成目标；<br>2）缺点：不适合开发大型应用程序；<br>3）Javascript 有 11 种内置对象： Array、String、Date、Math、Boolean、Number、<br>Function、Global、Error、RegExp、Object。 六、数据库部分<br>160. 存储过程和函数的区别<br>存储过程是用户定义的一系列 sql 语句的集合，涉及特定表或其它对象的任务，用户可以调<br>用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉<br>及特定用户表。</p>
<ol start="162">
<li><p>游标的作用？如何知道游标已经到了最后？<br>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS 可以判断是否到了最后，<br>通常此变量不等于 0 表示出错或到了最后。</p>
</li>
<li><p>触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何<br>区别？<br>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触<br>发器可以获取事件之前和新的字段值。 语句级触发器可以在语句执行前或后执行，而行级<br>触发在触发器所影响的每一行触发一次。</p>
</li>
<li><p>存储过程，触发器，范式，事务的概念及作用？<br>存储过程：是数据库管理系统里的一个很重要的对象。用它可以封装一些功能。把多个 SQL<br>语句封装到存储过程里面。起到封装功能的作用。类似面向对象里，封装对象的一个功能一<br>样。几乎任何可写成批处理的 Transact-SQL 代码都可用于创建存储过程。<br>触发器：触发器是在用户进行某项操作的时候，会触发触发器的执行。它类似于 JAVA 中图<br>形截面编程里的事件操作一样，是触发执行。和存储过程的主要区别在于：存储过程类似<br>JAVA 里面的对象一样，进行功能的封装（方法）。在调用的时候才会执行。而触发器只能<br>在别的操作执行的时候才会触发触发器的执行。<br>事务：类似于 JAVA 里面线程的同步一样，作为一个单元执行。它有四大特性：原子性，隔<br>离性，一致性，持久性。在 SQL SERVER 2000 里面还支持存储点的用法。大家都知道，事<br>务是做为一个单元运行，要么全部执行，要么全部不执行。但是有时候我们可以保证事务的<br>一部分可能正确执行，并且这些执行可以直接刷新到数据库里面。那么我们就可以在这个事<br>务的中间部分设置一个或者多个存储点。这样在这个事务大单元里就分成了几个小部分。如<br>果上面的部分执行正确，下面的部分执行错误，那么就没必要回滚整个事务，只需要回滚到<br>存储点的地方就可以了<br>范式：目地：规范化目的是使结构更合理，消除存储异常，使数据冗余尽量小，便于插入、<br>删除和更新<br>原则：遵从概念单一化 “一事一地”原则，即一个关系模式描述一个实体或实体间的一种联<br>系。规范的实质就是概念的单一化。<br>方法：将关系模式投影分解成两个或两个以上的关系模式。<br>要求：分解后的关系模式集合应当与原关系模式”等价”，即经过自然联接可以恢复原关系而<br>不丢失信息，并保持属性间合理联系。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p>
</li>
<li><p>写一个 SQL Server 中的存储过程:<br>以下为一个带有一个输入参数 Vdeptno ,返回部门为 Vdeptnor 的所有职员的信息. create procedure Emp_dept<br>@Vdeptno number(2) AS<br>begin<br>select * from emp where deptno&#x3D;@Vdeptno<br>end</p>
</li>
<li><p>写一个 Oracle 中的存储过程:<br>带 IN 参数的过程<br>create or replace procedure addnew(dno IN number, name IN varchar2, location IN varchar2)IS<br>begin<br>insert into dept values(dno,name,location);<br>dbms_output.put_line(‘1 record inserted’);<br>end;<br>带 OUT 参数的过程<br>create or replace procedure getsal(name IN varchar2, salary OUT number)AS<br>begin<br>select sal into salary from emp where ename&#x3D;name;<br>end;</p>
</li>
<li><p>数据库 SQL 语句题<br>106、有 3 个表（15 分钟）：【基础】<br>Student 学生表 (学号，姓名，性别，年龄，组织部门)<br>Course 课程表 (编号，课程名称)<br>Sc 选课表 (学号，课程编号，成绩)<br>表结构如下：<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>1）写一个 SQL 语句，查询选修了’计算机原理’的学生学号和姓名（3 分钟）<br>2）写一个 SQL 语句，查询’周星驰’同学选修了的课程名字（3 分钟）<br>3）写一个 SQL 语句，查询选修了 5 门课程的学生学号和姓名（9 分钟）<br>答：1）SQL 语句如下：<br>select stu.sno, stu.sname from Student stu<br>where (select count(<em>) from sc where sno&#x3D;stu.sno and cno &#x3D;<br>(select cno from Course where cname&#x3D;’计算机原理’)) !&#x3D; 0;<br>2）SQL 语句如下：<br>select cname from Course<br>where cno in ( select cno from sc where sno &#x3D;<br>(select sno from Student where sname&#x3D;’周星驰’));<br>3）SQL 语句如下：<br>select stu.sno, stu.sname from student stu<br>where (select count(</em>) from sc where sno&#x3D;stu.sno) &#x3D; 5;<br>107、有三张表,学生表 S,课程 C,学生课程表 SC,学生可以选修多门课程,一门课程可以被多个<br>学生选修,通过 SC 表关联。【基础】<br>1）写出建表语句；<br>2）写出 SQL 语句,查询选修了所有选修课程的学生；<br>3）写出 SQL 语句,查询选修了至少 5 门以上的课程的学生。<br>答：1）建表语句如下（mysql 数据库）：<br>create table s(id integer primary key, name varchar(20));<br>create table c(id integer primary key, name varchar(20));<br>create table sc(<br>sid integer references s(id), cid integer references c(id), primary key(sid,cid)<br>);<br>2）SQL 语句如下：<br>select stu.id, stu.name from s stu<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>where (select count(<em>) from sc where sid&#x3D;stu.id) &#x3D; (select count(</em>) from c);<br>3）SQL 语句如下：<br>select stu.id, stu.name from s stu<br>where (select count(*) from sc where sid&#x3D;stu.id)&gt;&#x3D;5;<br>108、数据库表(Test)结构如下：【基础】<br>ID NAME AGE MANAGER(所属主管人 ID)<br>106 A 30 104<br>109 B 19 104<br>104 C 20 111<br>107 D 35 109<br>112 E 25 120<br>119 F 45 NULL<br>要求:列出所有年龄比所属主管年龄大的人的 ID 和名字?<br>答：SQL 语句如下：<br>select employee.name from test employee<br>where employee.age &gt; (select manager.age from test manager<br>where manager.id&#x3D;employee.manager);<br>109、有如下两张表：【中等难度】<br>表 city： 表 state：<br>欲得到如下结果：<br>City No City Name State No State Name<br>BJ 北京 （Null） （Null）<br>DL 大连 LN 辽宁<br>GZ 广州 GD 广东<br>SH 上海 （Null） （Null）<br>写相应的 SQL 语句。<br>答：SQL 语句为：<br>SELECT C.CITYNO, C.CITYNAME, C.STATENO, S.STATENAME<br>FROM CITY C, STATE S<br>WHERE C.STATENO&#x3D;S.STATENO(+)<br>ORDER BY(C.CITYNO);</p>
</li>
<li><p>用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。<br>employee:<br>eid,ename,salary,deptid;<br>select * from employee order by deptid desc,salary</p>
</li>
<li><p>列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序<br>CityNo CityName StateNo<br>BJ 北京 （Null）<br>SH 上海 （Null）<br>GZ 广州 GD<br>DL 大连 LN<br>State No State Name<br>GD 广东<br>LN 辽宁<br>SD 山东<br>NMG 内蒙古<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>创建表：<br>mysql&gt; create table employee921(id int primary key auto_increment,name varchar(5<br>0),salary bigint,deptid int);<br>插入实验数据：<br>mysql&gt; insert into employee921 values(null,’zs’,1000,1),(null,’ls’,1100,1),(null<br>,’ww’,1100,1),(null,’zl’,900,1) ,(null,’zl’,1000,2), (null,’zl’,900,2) ,(null,’z<br>l’,1000,2) , (null,’zl’,1100,2);<br>编写 sql 语句：<br>（）select avg(salary) from employee921 group by deptid;<br>（）mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 where deptid &#x3D;<br>tid);<br>效率低的一个语句，仅供学习参考使用（在 group by 之后不能使用 where，只能使用<br>having，在 group by 之前可以使用 where，即表示对过滤后的结果分组）：<br>mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 group by deptid<br>having deptid &#x3D; tid);<br>（）select count(*) ,tid<br>from (<br>select employee921.id,employee921.name,employee921.salary,employee921.deptid tid<br>from employee921<br>where salary &gt;<br>(select avg(salary) from employee921 where deptid &#x3D; tid)<br>) as t<br>group by tid ;<br>另外一种方式：关联查询<br>select a.ename,a.salary,a.deptid<br>from emp a, (select deptd,avg(salary) avgsal from emp group by deptid ) b<br>where a.deptid&#x3D;b.deptid and a.salary&gt;b.avgsal;</p>
</li>
<li><p>存储过程与触发器必须讲，经常被面试到?<br>create procedure insert_Student (_name varchar(50),_age int ,out _id int)<br>begin<br>insert into student value(null,_name,_age);<br>select max(stuId) into _id from student;<br>end;<br>call insert_Student(‘wfz’,23,@id);<br>select @id;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>mysql&gt; create trigger update_Student BEFORE update on student FOR EACH ROW<br>-&gt; select * from student;<br>触发器不允许返回结果<br>create trigger update_Student BEFORE update on student FOR EACH ROW<br>insert into student value(null,’zxx’,28);<br>mysql 的触发器目前不能对当前表进行操作<br>create trigger update_Student BEFORE update on student FOR EACH ROW<br>delete from articles where id&#x3D;8;<br>这个例子不是很好，最好是用删除一个用户时，顺带删除该用户的所有帖子<br>这里要注意使用 OLD.id<br>触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，<br>其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而 UCH<br>没有用触发器，效率和数据处理能力都很低。<br>存储过程的实验步骤：<br>mysql&gt; delimiter |<br>mysql&gt; create procedure insertArticle_Procedure (pTitle varchar(50),pBid int,out<br>pId int)<br>-&gt; begin<br>-&gt; insert into article1 value(null,pTitle,pBid); -&gt; select max(id) into pId from article1; -&gt; end; -&gt; |<br>Query OK, 0 rows affected (0.05 sec)<br>mysql&gt; call insertArticle_Procedure(‘中国北京’,1,@pid); -&gt; |<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; delimiter ;<br>mysql&gt; select @pid;<br>+——+<br>| @pid |<br>+——+<br>| 3 |<br>+——+<br>1 row in set (0.00 sec)<br>mysql&gt; select * from article1;<br>+—-+————–+——+<br>| id | title | bid |<br>+—-+————–+——+<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>| 1 | test | 1 |<br>| 2 | chuanzhiboke | 1 |<br>| 3 | 中国北京 | 1 |<br>+—-+————–+——+<br>3 rows in set (0.00 sec)<br>触发器的实验步骤：<br>create table board1(id int primary key auto_increment,name varchar(50),ar<br>ticleCount int);<br>create table article1(id int primary key auto_increment,title varchar(50)<br>,bid int references board1(id));<br>delimiter |<br>create trigger insertArticle_Trigger after insert on article1 for each ro<br>w begin<br>-&gt; update board1 set articleCount&#x3D;articleCount+1 where id&#x3D; NEW.bid; -&gt; end; -&gt; |<br>delimiter ;<br>insert into board1 value (null,’test’,0);<br>insert into article1 value(null,’test’,1);<br>还有，每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，<br>用触发器做效率就很高。下次课设计这样一个案例，写触发器时，对于最后发帖时间可能需<br>要用 declare 方式声明一个变量，或者是用 NEW.posttime 来生成。</p>
</li>
<li><p>数据库三范式是什么?<br>第一范式（1NF）：字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式）<br>数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一<br>个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的<br>字段。<br>第二范式（2NF）：第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足<br>第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以<br>被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被<br>称为主关键字或主键。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依<br>赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一<br>部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通<br>常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非<br>部分依赖于主关键字。<br>第三范式的要求如下： 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。所以<br>第三范式具有如下特征：<br>1，每一列只有一个值 。2，每一行都能区分。3，每一个表都不包含其他表已经包含<br>的非主关键字信息。<br>例如，帖子表中只能出现发帖人的 id，而不能出现发帖人的 id，还同时出现发帖人姓名，<br>否则，只要出现同一发帖人 id 的所有记录，它们中的姓名部分都必须严格保持一致，这就<br>是数据冗余。</p>
</li>
<li><p>说出一些数据库优化方面的经验?<br>用 PreparedStatement 一般来说比 Statement 性能高：一个 sql 发给服务器执行，步骤：语法<br>检查、语义分析， 编译，缓存<br>“inert into user values(1,1,1)”-二进制<br>“inert into user values(2,2,2)”-二进制<br>“inert into user values(?,?,?)”-二进制<br>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就<br>去掉外键。（比喻：就好比免检产品，就是为了提高效率，充分相信产品的制造商）<br>（对于 hibernate 来说，就应该有一个变化：empleyee-&gt;Deptment 对象，现在设计时就成了<br>employeedeptid）<br>看 mysql 帮助文档子查询章节的最后部分，例如，根据扫描的原理，下面的子查询语句要比<br>第二条关联查询的效率高：</p>
</li>
<li><p>select e.name,e.salary where e.managerid&#x3D;(select id from employee where name&#x3D;’zxx’);</p>
</li>
<li><p>select e.name,e.salary,m.name,m.salary from employees e,employees m where<br>e.managerid &#x3D; m.id and m.name&#x3D;’zxx’;<br>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等<br>将姓名和密码单独从用户表中独立出来。这可以是非常好的一对一的案例哟！<br>sql 语句全部大写，特别是列名和表名都大写。特别是 sql 命令的缓存功能，更加需要统一<br>大小写，sql 语句发给 oracle 服务器语法检查和编译成为内部指令缓存和执行指令。<br>根据缓存的特点，不要拼凑条件，而是用?和 PreparedStatment<br>还有索引对查询性能的改进也是值得关注的。<br>备注：下面是关于性能的讨论举例<br>4 航班 3 个城市<br>m*n<br>select * from flight,city where flight.startcityid&#x3D;city.cityid and city.name&#x3D;’beijing’;<br>m + n<br>select * from flight where startcityid &#x3D; (select cityid from city where cityname&#x3D;’beijing’);<br>select flight.id,’beijing’,flight.flightTime from flight where startcityid &#x3D; (select cityid from city<br>where cityname&#x3D;’beijing’)</p>
</li>
<li><p>union 和 union all 有什么不同?<br>假设我们有一个表 Student，包括以下字段与数据：<br>drop table student;<br>create table student<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(<br>id int primary key, name nvarchar2(50) not null, score number not null<br>);<br>insert into student values(1,’Aaron’,78);<br>insert into student values(2,’Bill’,76);<br>insert into student values(3,’Cindy’,89);<br>insert into student values(4,’Damon’,90);<br>insert into student values(5,’Ella’,73);<br>insert into student values(6,’Frado’,61);<br>insert into student values(7,’Gill’,99);<br>insert into student values(8,’Hellen’,56);<br>insert into student values(9,’Ivan’,93);<br>insert into student values(10,’Jay’,90);<br>commit;<br>Union 和 Union All 的区别。<br>select *from studentwhere id &lt; 4union<br>select *from studentwhere id &gt; 2 and id &lt; 6<br>结果将是<br>1 Aaron 78<br>2 Bill 76<br>3 Cindy 89<br>4 Damon 90<br>5 Ella 73<br>如果换成 Union All 连接两个结果集，则返回结果是：<br>1 Aaron 78<br>2 Bill 76<br>3 Cindy 89<br>3 Cindy 89<br>4 Damon 90<br>5 Ella 73<br>可以看到，Union 和 Union All 的区别之一在于对重复结果的处理。<br>UNION 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进<br>行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常<br>见的是过程表与历史表 UNION。如：<br>select * from gc_dfys<br>union<br>select * from ls_jg_dfys<br>这个 SQL 在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后<br>返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。<br>而 UNION ALL 只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有<br>重复的数据，那么返回的结果集就会包含重复的数据了。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>从效率上说，UNION ALL 要比 UNION 快很多，所以，如果可以确认合并的两个结果集<br>中不包含重复的数据的话，那么就使用 UNION ALL，</p>
</li>
<li><p>分页语句<br>取出 sql 表中第 31 到 40 的记录（以自动增长 ID 为主键）<br>sql server 方案 1：<br>select top 10 * from t where id not in (select top 30 id from t order by id ) orde by id<br>sql server 方案 2：<br>select top 10 * from t where id in (select top 40 id from t order by id) order by id desc<br>mysql 方案：select * from t order by id limit 30,10<br>oracle 方案：select * from (select rownum r,* from t where r&lt;&#x3D;40) where r&gt;30<br>——————–待整理进去的内容————————————- pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>1.分页技术 1（直接利用 sql 语句进行分页，效率最高和最推荐的）<br>mysql:sql &#x3D; “select * from articles limit “ + (pageNo-1)<em>pageSize + “,” + pageSize;<br>oracle: sql &#x3D; “select * from “ +”(select rownum r,</em> from “ +”(select * from articles order by<br>postime desc)” +”where rownum&lt;&#x3D; “ + pageNo*pageSize +”) tmp “ +”where r&gt;” +<br>(pageNo-1)*pageSize;<br>注释：第 7 行保证 rownum 的顺序是确定的，因为 oracle 的索引会造成 rownum 返回不同的<br>值<br>简洋提示：没有 order by 时，rownum 按顺序输出，一旦有了 order by，rownum 不按顺序输<br>出了，这说明 rownum 是排序前的编号。如果对 order by 从句中的字段建立了索引，那么，<br>rownum 也是按顺序输出的，因为这时候生成原始的查询结果集时会参照索引表的顺序来构<br>建。<br>sqlserver:sql &#x3D; “select top 10 * from id not id(select top “ + (pageNo-1)*pageSize + “id from<br>articles)” DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D; cn.prepareSatement(sql);<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>while(rs.next()){<br>out.println(rs.getString(1));<br>}<br>2.不可滚动的游标<br>pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>cn &#x3D; null<br>stmt &#x3D; null;<br>rs &#x3D; null;<br>try{<br>sqlserver:sql &#x3D; “select * from articles”;<br>DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D; cn.prepareSatement(sql);<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>for(int j&#x3D;0;j&lt;(pageNo-1)*pageSize;j++){<br>rs.next();<br>}<br>int i&#x3D;0;<br>while(rs.next() &amp;&amp; i&lt;10){<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly{<br>if(rs!&#x3D;null)try{rs.close();}catch(Exception e){}<br>if(stm……… if(cn………… }<br>3.可滚动的游标<br>pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>cn &#x3D; null<br>stmt &#x3D; null;<br>rs &#x3D; null;<br>try{<br>sqlserver:sql &#x3D; “select * from articles”;<br>DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D;<br>cn.prepareSatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,…);<br>&#x2F;&#x2F;根据上面这行代码的异常 SQLFeatureNotSupportedException，就可判断驱动是否支持可滚<br>动游标<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>rs.absolute((pageNo-1)*pageSize)<br>int i&#x3D;0;<br>while(rs.next() &amp;&amp; i&lt;10){<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly{<br>if(rs!&#x3D;null)try{rs.close();}catch(Exception e){}<br>if(stm……… if(cn………… }</p>
</li>
<li><p>用一条 SQL 语句 查询出每门课都大于 80 分的学生姓名<br>name kecheng fenshu<br>张三 语文 81<br>张三 数学 75<br>李四 语文 76<br>李四 数学 90<br>王五 语文 81<br>王五 数学 100<br>王五 英语 90<br>准备数据的 sql 代码：<br>create table score(id int primary key auto_increment,name varchar(20),subject varchar(20),score<br>int);<br>insert into score values<br>(null,’张三’,’语文’,81), (null,’张三’,’数学’,75), (null,’李四’,’语文’,76), (null,’李四’,’数学’,90), (null,’王五’,’语文’,81), (null,’王五’,’数学’,100), (null,’王五 ‘,’英语’,90);<br>提示：当百思不得其解时，请理想思维，把小变成大做，把大变成小做，<br>答案：<br>A: select distinct name from score where name not in (select distinct name from score where<br>score&lt;&#x3D;80)<br>B:select distince name t1 from score where 80&lt; all (select score from score where name&#x3D;t1);</p>
</li>
<li><p>所有部门之间的比赛组合<br>一个叫 department 的表，里面只有一个字段 name,一共有 4 条纪录，分别是 a,b,c,d,对应四个<br>球对，现在四个球对进行比赛，用一条 sql 语句显示所有可能的比赛组合.<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>答：select a.name, b.name from team a, team b where a.name &lt; b.name</p>
</li>
<li><p>每个月份的发生额都比 101 科目多的科目<br>请用 SQL 语句实现：从 TestDB 数据表中查询出所有月份的发生额都比 101 科目相应月份的<br>发生额高的科目。请注意：TestDB 中有很多科目，都有 1－12 月份的发生额。<br>AccID：科目代码，Occmonth：发生额月份，DebitOccur：发生额。<br>数据库名：JcyAudit，数据集：Select * from TestDB<br>准备数据的 sql 代码：<br>drop table if exists TestDB;<br>create table TestDB(id int primary key auto_increment,AccID varchar(20), Occmonth date, DebitOccur bigint);<br>insert into TestDB values<br>(null,’101’,’1988-1-1’,100), (null,’101’,’1988-2-1’,110), (null,’101’,’1988-3-1’,120), (null,’101’,’1988-4-1’,100), (null,’101’,’1988-5-1’,100), (null,’101’,’1988-6-1’,100), (null,’101’,’1988-7-1’,100), (null,’101’,’1988-8-1’,100); –复制上面的数据，故意把第一个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’102’,’1988-1-1’,90), (null,’102’,’1988-2-1’,110), (null,’102’,’1988-3-1’,120), (null,’102’,’1988-4-1’,100), (null,’102’,’1988-5-1’,100), (null,’102’,’1988-6-1’,100), (null,’102’,’1988-7-1’,100), (null,’102’,’1988-8-1’,100); –复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’103’,’1988-1-1’,150), (null,’103’,’1988-2-1’,160), (null,’103’,’1988-3-1’,180), (null,’103’,’1988-4-1’,120), (null,’103’,’1988-5-1’,120), (null,’103’,’1988-6-1’,120), (null,’103’,’1988-7-1’,120), (null,’103’,’1988-8-1’,120); –复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’104’,’1988-1-1’,130), (null,’104’,’1988-2-1’,130), (null,’104’,’1988-3-1’,140),<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(null,’104’,’1988-4-1’,150), (null,’104’,’1988-5-1’,160), (null,’104’,’1988-6-1’,170), (null,’104’,’1988-7-1’,180), (null,’104’,’1988-8-1’,140); –复制最上面的数据，故意把第二个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’105’,’1988-1-1’,100), (null,’105’,’1988-2-1’,80), (null,’105’,’1988-3-1’,120), (null,’105’,’1988-4-1’,100), (null,’105’,’1988-5-1’,100), (null,’105’,’1988-6-1’,100), (null,’105’,’1988-7-1’,100), (null,’105’,’1988-8-1’,100);<br>答案：<br>select distinct AccID from TestDB<br>where AccID not in<br>(select TestDB.AccIDfrom TestDB, (select * from TestDB where AccID&#x3D;’101’) as db101<br>where TestDB.Occmonth&#x3D;db101.Occmonth and TestDB.DebitOccur&lt;&#x3D;db101.DebitOccur<br>);</p>
</li>
<li><p>统计每年每月的信息<br>year month amount<br>1991 1 1.1<br>1991 2 1.2<br>1991 3 1.3<br>1991 4 1.4<br>1992 1 2.1<br>1992 2 2.2<br>1992 3 2.3<br>1992 4 2.4<br>查成这样一个结果<br>year m1 m2 m3 m4<br>1991 1.1 1.2 1.3 1.4<br>1992 2.1 2.2 2.3 2.4<br>提示：这个与工资条非常类似，与学生的科目成绩也很相似。<br>准备 sql 语句：<br>drop table if exists sales;<br>create table sales(id int auto_increment primary key,year varchar(10), month varchar(10), amount<br>float(2,1));<br>insert into sales values<br>(null,’1991’,’1’,1.1),<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(null,’1991’,’2’,1.2), (null,’1991’,’3’,1.3), (null,’1991’,’4’,1.4), (null,’1992’,’1’,2.1), (null,’1992’,’2’,2.2), (null,’1992’,’3’,2.3), (null,’1992’,’4’,2.4);<br>答案一、select sales.year , (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘1’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘2’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘3’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) as ‘4’ from sales group by year;</p>
</li>
<li><p>显示文章标题，发帖人、最后回复时间<br>表：id,title,postuser,postdate,parentid<br>准备 sql 语句：<br>drop table if exists articles;<br>create table articles(id int auto_increment primary key,title varchar(50), postuser varchar(10), postdate datetime,parentid int references articles(id));<br>insert into articles values<br>(null,’第一条’,’张三’,’1998-10-10 12:32:32’,null), (null,’第二条’,’张三’,’1998-10-10 12:34:32’,null), (null,’第一条回复 1’,’李四’,’1998-10-10 12:35:32’,1), (null,’第二条回复 1’,’李四’,’1998-10-10 12:36:32’,2), (null,’第一条回复 2’,’王五’,’1998-10-10 12:37:32’,1), (null,’第一条回复 3’,’李四’,’1998-10-10 12:38:32’,1), (null,’第二条回复 2’,’李四’,’1998-10-10 12:39:32’,2), (null,’第一条回复 4’,’王五’,’1998-10-10 12:39:40’,1);<br>答案：<br>select a.title,a.postuser, (select max(postdate) from articles where parentid&#x3D;a.id) reply<br>from articles a where a.parentid is null;<br>注释：子查询可以用在选择列中，也可用于 where 的比较条件中，还可以用于 from 从句中。</p>
</li>
<li><p>删除除了 id 号不同,其他都相同的学生冗余信息<br>2.学生表 如下:<br>id 号 学号 姓名 课程编号 课程名称 分数<br>1 2005001 张三 0001 数学 69<br>2 2005002 李四 0001 数学 89<br>3 2005001 张三 0001 数学 69<br>A: delete from tablename where id 号 not in(select min(id 号) from tablename group by 学号,姓<br>名,课程编号,课程名称,分数)<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实验：<br>create table student2(id int auto_increment primary key,code varchar(20),name varchar(20));<br>insert into student2 values(null,’2005001’,’张三’),(null,’2005002’,’李四’),(null,’2005001’,’张三’);<br>&#x2F;&#x2F;如下语句，mysql 报告错误，可能删除依赖后面统计语句，而删除又导致统计语句结果不<br>一致。<br>delete from student2 where id not in(select min(id) from student2 group by name);<br>&#x2F;&#x2F;但是，如下语句没有问题：<br>select * from student2 where id not in(select min(id) from student2 group by name);<br>&#x2F;&#x2F;于是，我想先把分组的结果做成虚表，然后从虚表中选出结果，最后再将结果作为删除的<br>条件数据。<br>delete from student2 where id not in(select mid from (select min(id) mid<br>from student2 group by name) as t);<br>或者：<br>delete from student2 where id not in(select min(id) from (select * from s<br>tudent2) as t group by t.name);</p>
</li>
<li><p>航空网的几个航班查询题：<br>表结构如下：<br>flight{flightID,StartCityID ,endCityID,StartTime}<br>city{cityID, CityName)<br>实验环境：<br>create table city(cityID int auto_increment primary key,cityName varchar(20));<br>create table flight (flightID int auto_increment primary key, StartCityID int references city(cityID), endCityID int references city(cityID), StartTime timestamp);<br>&#x2F;&#x2F;航班本来应该没有日期部分才好，但是下面的题目当中涉及到了日期<br>insert into city values(null,’北京’),(null,’上海’),(null,’广州’);<br>insert into flight values<br>(null,1,2,’9:37:23’),(null,1,3,’9:37:23’),(null,1,2,’10:37:23’),(null,2,3,’10:37:23’);<br>1、查询起飞城市是北京的所有航班，按到达城市的名字排序<br>参与运算的列是我起码能够显示出来的那些列，但最终我不一定把它们显示出来。各个表组<br>合出来的中间结果字段中必须包含所有运算的字段。<br>select * from flight f,city c<br>where f.endcityid &#x3D; c.cityid and startcityid &#x3D;<br>(select c1.cityid from city c1 where c1.cityname &#x3D; “北京”)<br>order by c.cityname asc;<br>mysql&gt; select flight.flightid,’北京’ startcity, e.cityname from flight,city e wh<br>ere flight.endcityid&#x3D;e.cityid and flight.startcityid&#x3D;(select cityid from city wh<br>ere cityname&#x3D;’北京’);<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>mysql&gt; select flight.flightid,s.cityname,e.cityname from flight,city s,city e wh<br>ere flight.startcityid&#x3D;s.cityid and s.cityname&#x3D;’北京’ and flight.endCityId&#x3D;e.cit<br>yID order by e.cityName desc;<br>2、查询北京到上海的所有航班纪录（起飞城市，到达城市，起飞时间，航班号）<br>select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID&#x3D;c1.cityID<br>and f.endCityID&#x3D;c2.cityID<br>and c1.cityName&#x3D;’北京’ and c2.cityName&#x3D;’上海’ 3、查询具体某一天（2005-5-8）的北京到上海的的航班次数<br>select count(<em>) from<br>(select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID&#x3D;c1.cityID<br>and f.endCityID&#x3D;c2.cityID<br>and c1.cityName&#x3D;’北京’ and c2.cityName&#x3D;’上海’ and 查帮助获得的某个日期处理函数(startTime) like ‘2005-5-8%’ mysql 中提取日期部分进行比较的示例代码如下：<br>select * from flight where date_format(starttime,’%Y-%m-%d’)&#x3D;’1998-01-02’ 182. 查出比经理薪水还高的员工信息：<br>Drop table if not exists employees;<br>create table employees(id int primary key auto_increment,name varchar(50)<br>,salary int,managerid int references employees(id));<br>insert into employees values (null,’ lhm’,10000,null), (null,’ zxx’,15000,1<br>),(null,’flx’,9000,1),(null,’tg’,10000,2),(null,’wzg’,10000,3);<br>Wzg 大于 flx,lhm 大于 zxx<br>解题思路：<br>根据 sql 语句的查询特点，是逐行进行运算，不可能两行同时参与运算。<br>涉及了员工薪水和经理薪水，所有，一行记录要同时包含两个薪水，所有想到要把这个表自<br>关联组合一下。<br>首先要组合出一个包含有各个员工及该员工的经理信息的长记录，譬如，左半部分是员工，<br>右半部分是经理。而迪卡尔积会组合出很多垃圾信息，先去除这些垃圾信息。<br>select e.</em> from employees e,employees m where e.managerid&#x3D;m.id and e.sala<br>ry&gt;m.salary;</p>
</li>
<li><p>求出小于 45 岁的各个老师所带的大于 12 岁的学生人数<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>数据库中有 3 个表 teacher 表，student 表，tea_stu 关系表。<br>teacher 表 teaID name age<br>student 表 stuID name age<br>teacher_student 表 teaID stuID<br>要求用一条 sql 查询出这样的结果<br>1.显示的字段要有老师 name, age 每个老师所带的学生人数<br>2.只列出老师 age 为 40 以下，学生 age 为 12 以上的记录<br>预 备 知 识 : 1.sql 语 句 是 对 每 一 条 记 录 依 次 处 理 ， 条 件 为 真 则 执 行 动 作<br>（select,insert,delete,update）<br>2.只要是迪卡尔积，就会产生“垃圾”信息，所以，只要迪卡尔积了，我们首先<br>就要想到清除“垃圾”信息<br>实验准备： drop table if exists tea_stu;<br>drop table if exists teacher;<br>drop table if exists student;<br>create table teacher(teaID int primary key,name varchar(50),age int);<br>create table student(stuID int primary key,name varchar(50),age int);<br>create table tea_stu(teaID int references teacher(teaID),stuID int references<br>student(stuID));<br>insert into teacher values(1,’zxx’,45), (2,’lhm’,25) , (3,’wzg’,26) , (4,’tg’,27);<br>insert into student values(1,’wy’,11), (2,’dh’,25) , (3,’ysq’,26) , (4,’mxc’,27);<br>insert into tea_stu values(1,1), (1,2), (1,3);<br>insert into tea_stu values(2,2), (2,3), (2,4);<br>insert into tea_stu values(3,3), (3,4), (3,1);<br>insert into tea_stu values(4,4), (4,1), (4,2) , (4,3);<br>结果：23,32,43<br>解题思路：（真实面试答题时，也要写出每个分析步骤，如果纸张不够，就找别人要）<br>1.要会统计分组信息，统计信息放在中间表中：<br>select teaid,count(<em>) from tea_stu group by teaid;<br>2.接着其实应该是筛除掉小于 12 岁的学生，然后再进行统计，中间表必须与 student 关联才<br>能得到 12 岁以下学生和把该学生记录从中间表中剔除，代码是：<br>select tea_stu.teaid,count(</em>) total from student,tea_stu<br>where student.stuid&#x3D;tea_stu.stuid and student.age&gt;12 group by tea_stu.teaid<br>3.接着把上面的结果做成虚表与 teacher 进行关联，并筛除大于 45 的老师<br>select teacher.teaid,teacher.name,total from teacher ,(select tea_stu.tea<br>id,count(*) total from student,tea_stu where student.stuid&#x3D;tea_stu.stuid and stu<br>dent.age&gt;12 group by tea_stu.teaid) as tea_stu2 where teacher.teaid&#x3D;tea_stu2.tea<br>id and teacher.age&lt;45;</p>
</li>
<li><p>求出发帖最多的人：<br>select authorid,count(<em>) total from articles<br>group by authorid<br>having total&#x3D;(select max(total2) from (select count(</em>) total2 from articles group by authorid) as t);<br>select t.authorid,max(t.total) from（select authorid,count(<em>) total from articles ）as t<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>这条语句不行，因为 max 只有一列，不能与其他列混淆。<br>select authorid,count(</em>) total from articles<br>group by authorid having total&#x3D;max(total)也不行。</p>
</li>
<li><p>一个用户表中有一个积分字段，假如数据库中有 100 多万个用户，若要在每年第一天<br>凌晨将积分清零，你将考虑什么，你将想什么办法解决?<br>alter table drop column score;<br>alter table add colunm score int;<br>可能会很快，但是需要试验，试验不能拿真实的环境来操刀，并且要注意，<br>这样的操作时无法回滚的，在我的印象中，只有 inert update delete 等 DML 语句才能回滚，<br>对于 create table,drop table ,alter table 等 DDL 语句是不能回滚。<br>解决方案一，update user set score&#x3D;0;<br>解决方案二，假设上面的代码要执行好长时间，超出我们的容忍范围，那我就 alter table user<br>drop column score;alter table user add column score int。<br>下面代码实现每年的那个凌晨时刻进行清零。<br>Runnable runnable &#x3D;<br>new Runnable(){<br>public void run(){<br>clearDb();<br>schedule(this,new Date(new Date().getYear()+1,0,0));<br>}<br>};<br>schedule(runnable, new Date(new Date().getYear()+1,0,1));</p>
</li>
<li><p>一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。<br>select count(*) as num,tb.id from tb, (select role from tb where id&#x3D;xxx) as t1<br>where tb.role &#x3D; t1.role and tb.id !&#x3D; t1.id<br>group by tb.id<br>having num &#x3D; select count(role) from tb where id&#x3D;xxx;</p>
</li>
<li><p>xxx 公司的 sql 面试<br>Table EMPLOYEES Structure:<br>EMPLOYEE_ID NUMBER Primary Key, FIRST_NAME VARCHAR2(25), LAST_NAME VARCHAR2(25), Salary number(8,2), HiredDate DATE, Departmentid number(2)<br>Table Departments Structure:<br>Departmentid number(2) Primary Key, DepartmentName VARCHAR2(25).<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(2）基于上述 EMPLOYEES 表写出查询：写出雇用日期在今年的，或者工资在[1000,2000]<br>之间的，或者员工姓名（last_name）以’Obama’打头的所有员工，列出这些员工的全部个人<br>信息。（4 分）<br>select * from employees<br>where Year(hiredDate) &#x3D; Year(date())<br>or (salary between 1000 and 200)<br>or left(last_name,3)&#x3D;’abc’;<br>(3) 基于上述 EMPLOYEES 表写出查询：查出部门平均工资大于 1800 元的部门的所有员工，<br>列出这些员工的全部个人信息。<br>mysql&gt; select id,name,salary,deptid did from employee1 where (select avg(salary)<br>from employee1 where deptid &#x3D; did) &gt; 1800;<br>(4) 基于上述 EMPLOYEES 表写出查询：查出个人工资高于其所在部门平均工资的员工，<br>列出这些员工的全部个人信息及该员工工资高出部门平均工资百分比。（5 分）<br>select employee1.*,(employee1.salary-t.avgSalary)*100&#x2F;employee1.salary<br>from employee1, (select deptid,avg(salary) avgSalary from employee1 group by deptid) as t<br>where employee1.deptid &#x3D; t.deptid and employee1.salary&gt;t.avgSalary;</p>
</li>
<li><p>注册 Jdbc 驱动程序的三种方式?<br>如下:</p>
</li>
<li><p>Class.forName(“com.mysql.jdbc.Driver”);</p>
</li>
<li><p>System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”);</p>
</li>
<li><p>DriverManager.registerDriver(new com.mysql.jdbc.Driver());<br>1 中，不需要.newInstance()<br>2 中，通过系统的属性设置即可<br>3 中，是看起来比较直观的一种方式，注册相应的 db 的 jdbc 驱动，<br>总结：推荐 1，和 2 两种方式。<br>原因：3 在编译时需要导入对应的 lib。1，2 不需要。<br>补充：2 的方式的话，可以同时导入多个 jdbc 驱动，中间用冒号“：”分开</p>
</li>
<li><p>用 JDBC 如何调用存储过程<br>代码如下：<br>package com.huawei.interview.lym;<br>import java.sql.CallableStatement;<br>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;<br>import java.sql.Types;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public class JdbcTest {<br>public static void main(String[] args) {<br>Connection cn &#x3D; null;<br>CallableStatement cstmt &#x3D; null;<br>try {<br>&#x2F;&#x2F;这里最好不要这么干，因为驱动名写死在程序中了<br>Class.forName(“com.mysql.jdbc.Driver”);<br>&#x2F;&#x2F;实际项目中，这里应用 DataSource 数据，如果用框架，<br>&#x2F;&#x2F;这个数据源不需要我们编码创建，我们只需 Datasource ds &#x3D; context.lookup()<br>&#x2F;&#x2F;cn &#x3D; ds.getConnection();<br>cn &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;&#x2F;test”,”root”,”root”);<br>cstmt &#x3D; cn.prepareCall(“{call insert_Student(?,?,?)}”);<br>cstmt.registerOutParameter(3,Types.INTEGER);<br>cstmt.setString(1, “wangwu”);<br>cstmt.setInt(2, 25);<br>cstmt.execute();<br>&#x2F;&#x2F;get 第几个，不同的数据库不一样，建议不写<br>System.out.println(cstmt.getString(3));<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>finally{<br>&#x2F;<em>try{cstmt.close();}catch(Exception e){}<br>try{cn.close();}catch(Exception e){}</em>&#x2F;<br>try {<br>if(cstmt !&#x3D; null)<br>cstmt.close();<br>if(cn !&#x3D; null)<br>cn.close();<br>} catch (SQLException e) {<br>e.printStackTrace();<br>}<br>}<br>}</p>
</li>
<li><p>JDBC 中的 PreparedStatement 相比 Statement 的好处<br>答：一个 sql 命令发给服务器去执行的步骤为：语法检查，语义分析，编译成内部指令，缓<br>存指令，执行指令等过程。<br>select * from student where id &#x3D;3—-缓存–xxxxx 二进制命令<br>select * from student where id &#x3D;3—-直接取-xxxxx 二进制命令<br>select * from student where id &#x3D;4— -会怎么干？<br>如果当初是 select * from student where id &#x3D;?— -又会怎么干？<br>上面说的是性能提高<br>可以防止 sql 注入。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p>
</li>
<li><p>写一个用 jdbc 连接并访问 oracle 数据的程序代码, 能够完成修改和查询工作。<br>public void testJdbc(){<br>Connection con &#x3D; null;<br>PreparedStatement ps &#x3D; null;<br>ResultSet rs &#x3D; null;<br>try{<br>&#x2F;&#x2F;step1：注册驱动；<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>&#x2F;&#x2F;step 2：获取数据库连接；<br>con&#x3D;DriverManager.getConnection( “jdbc:oracle:thin:@192.168.0.39:1521:TARENADB”, “sd0605”,”sd0605”);<br>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>查 询</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>&#x2F;<br>&#x2F;&#x2F;step 3：创建 Statement；<br>String sql &#x3D; “SELECT id, fname, lname, age, FROM Person_Tbl”;<br>ps &#x3D; con.prepareStatement(sql);<br>&#x2F;&#x2F;step 4 ：执行查询语句，获取结果集；<br>rs &#x3D; ps.executeQuery();<br>&#x2F;&#x2F;step 5：处理结果集—输出结果集中保存的查询结果；<br>while (rs.next()){<br>System.out.print(“id &#x3D; “ + rs.getLong(“id”));<br>System.out.print(“ , fname &#x3D; “ + rs.getString(“fname”));<br>System.out.print(“ , lname &#x3D; “ + rs.getString(“lname”));<br>System.out.print(“ , age &#x3D; “ + rs.getInt(“age”));<br>}<br>&#x2F;***<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>JDBC 修 改</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F;<br>sql &#x3D; “UPDATE Person_Tbl SET age&#x3D;23 WHERE id &#x3D; ?”;<br>ps &#x3D; con.prepareStatement(sql);<br>ps.setLong(1, 88);<br>int rows &#x3D; ps.executeUpdate();<br>System.out.println(rows + “ rows affected.”);<br>} catch (Exception e){<br>e.printStackTrace();<br>} finally{<br>try{<br>con.close(); &#x2F;&#x2F;关闭数据库连接，以释放资源。<br>} catch (Exception e1) {<br>}<br>}<br>}</p>
</li>
<li><p>Class.forName 的作用?为什么要用?<br>答：按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载<br>过，则返回代表该字节码的 Class 实例对象，否则，按类加载器的委托机制去搜索和加载该<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>类，如果所有的类加载器都无法加载到该类，则抛出 ClassNotFoundException。加载完这个<br>Class 字节码后，接着就可以使用 Class 字节码的 newInstance 方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时<br>才能确定，这时候就需要使用 Class.forName 去动态加载该类，这个类名通常是在配置文件<br>中配置的，例如，spring 的 ioc 中每次依赖注入的具体类就是这样配置的，jdbc 的驱动类名<br>通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类<br>名。</p>
</li>
<li><p>大数据量下的分页解决方法。<br>答：最好的办法是利用 sql 语句进行分页，这样每次查询出的结果集中就只包含某页的数据<br>内容。再 sql 语句无法实现分页的情况下，可以考虑对大的结果集通过游标定位方式来获取<br>某页的数据。<br>sql 语句分页，不同的数据库下的分页方案各不一样，下面是主流的三种数据库的分页 sql：<br>sql server:<br>String sql &#x3D; “select top “ + pageSize + “ * from students where id not in” +<br>“(select top “ + pageSize * (pageNumber-1) + “ id from students order by id)” +<br>“order by id”;<br>mysql:String sql &#x3D; “select * from students order by id limit “ + pageSize*(pageNumber-1) + “,” +<br>pageSize;<br>oracle:String sql &#x3D; “select * from “ + (select <em>,rownum rid from (select * from students order<br>by postime desc) where rid&lt;&#x3D;” + pagesize</em>pagenumber + “) as t” + “where t&gt;” +<br>pageSize*(pageNumber-1);</p>
</li>
<li><p>用 JDBC 查询学生成绩单, 把主要代码写出来（考试概率极大）. Connection cn &#x3D; null;<br>PreparedStatement pstmt &#x3D;null;<br>Resultset rs &#x3D; null;<br>try{<br>Class.forname(driveClassName);<br>cn &#x3D; DriverManager.getConnection(url,username,password);<br>pstmt &#x3D; cn.prepareStatement(“select score.* from score ,student “ +<br>“where score.stuId &#x3D; student.id and student.name &#x3D; ?”);<br>pstmt.setString(1,studentName);<br>Resultset rs &#x3D; pstmt.executeQuery();<br>while(rs.next()){<br>system.out.println(rs.getInt(“subject”) + “ ” + rs.getFloat(“score”) );<br>}<br>}catch(Exception e){e.printStackTrace();}<br>finally{<br>if(rs !&#x3D; null) try{ rs.close() }catch(exception e){}<br>if(pstmt !&#x3D; null) try{pstmt.close()}catch(exception e){}<br>if(cn !&#x3D; null) try{ cn.close() }catch(exception e){}<br>}</p>
</li>
<li><p>这段代码有什么不足之处?<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>try {<br>Connection conn &#x3D; …;<br>Statement stmt &#x3D; …;<br>ResultSet rs &#x3D; stmt.executeQuery(“select * from table1”);<br>while(rs.next()) {<br>}<br>} catch(Exception ex) {<br>}<br>答：没有 finally 语句来关闭各个对象，另外，使用 finally 之后，要把变量的定义放在 try 语<br>句块的外面，以便在 try 语句块之外的 finally 块中仍可以访问这些变量。</p>
</li>
<li><p>说出数据连接池的工作机制是什么?<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空<br>闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池<br>连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>实现方式，返回的 Connection 是原始 Connection 的代理，代理 Connection 的 close 方法不是<br>真正关连接，而是把它代理的 Connection 对象还回到连接池中。</p>
</li>
<li><p>为什么要用 ORM? 和 JDBC 有何不一样?<br>orm 是一种思想，就是把 object 转变成数据库中的记录，或者把数据库中的记录转变成<br>objecdt，我们可以用 jdbc 来实现这种思想，其实，如果我们的项目是严格按照 oop 方式编<br>写的话，我们的 jdbc 程序不管是有意还是无意，就已经在实现 orm 的工作了。<br>现在有许多 orm 工具，它们底层调用 jdbc 来实现了 orm 工作，我们直接使用这些工具，就<br>省去了直接使用 jdbc 的繁琐细节，提高了开发效率，现在用的较多的 orm 工具是 hibernate。<br>也听说一些其他 orm 工具，如 toplink,ojb 等。</p>
</li>
<li><p>JDBC，Hibernate 分页怎样实现？<br>答：方法分别为：</p>
</li>
</ol>
<ol>
<li>Hibernate 的分页：<br>Query query &#x3D; session.createQuery(“from Student”);<br>query.setFirstResult(firstResult);&#x2F;&#x2F;设置每页开始的记录号<br>query.setMaxResults(resultNumber);&#x2F;&#x2F;设置每页显示的记录数<br>Collection students &#x3D; query.list();</li>
<li>JDBC 的分页：根据不同的数据库采用不同的 sql 分页语句<br>例 如 : Oracle 中 的 sql 语 句 为 : “SELECT * FROM (SELECT a.*, rownum r FROM<br>TB_STUDENT) WHERE r between 2 and 10” 查询从记录号 2 到记录号 10 之间的所有记录<br>七、 XML 部分</li>
</ol>
<ol start="200">
<li><p>xml 有哪些解析技术?区别是什么?<br>答:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>种结构占用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML<br>的随机访问 SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文<br>件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结<br>束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理 XML 文件，适合<br>对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)</p>
</li>
<li><p>你在项目中用到了 xml 技术的哪些方面?如何实现的?<br>答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成<br>XML 文件，然后将 XML 文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩<br>后再同 XML 文件中还原相关信息进行处理。在做软件配置时，利用 XML 可以很方便的进<br>行，软件的各种配置参数都存贮在 XML 文件中。</p>
</li>
<li><p>谈谈你对 SSH 的理解<br>典型的 JavaEE 三层结构，分为表现层、中间层（业务逻辑层）和数据服务层。三层体系将<br>业务规则、数据访问及合法性校验等工作放在中间层处理。客户端不直接与数据库交互，而<br>是通过组件与中间层建立连接，再由中间层与数据库交互。<br>表现层是传统的 JSP 技术，自 1999 年问世以来，经过多年的发展，其广泛的应用和稳定的<br>表现，为其作为表现层技术打下了坚实的基础。<br>中间层采用的是流行的 Spring+Hibernate，为了将控制层与业务逻辑层分离，又细分为以下<br>几种。<br>Web 层，就是 MVC 模式里面的“C”（controller），负责控制业务逻辑层与表现层的交互，<br>调用业务逻辑层，并将业务数据返回给表现层作组织表现，该系统的 MVC 框架采用 Struts。<br>Service 层（就是业务逻辑层），负责实现业务逻辑。业务逻辑层以 DAO 层为基础，通过对<br>DAO 组件的正面模式包装，完成系统所要求的业务逻辑。<br>DAO 层，负责与持久化对象交互。该层封装了数据的增、删、查、改的操作。<br>PO，持久化对象。通过实体关系映射工具将关系型数据库的数据映射成对象，很方便地实<br>现以面向对象方式操作数据库，该系统采用 Hibernate 作为 ORM 框架。<br>Spring 的作用贯穿了整个中间层，将 Web 层、Service 层、DAO 层及 PO 无缝整合，其数据<br>服务层用来存放数据。</p>
</li>
<li><p>谈谈你对 Hibernate 的理解。</p>
</li>
<li><p>面向对象设计的软件内部运行过程可以理解成就是在不断创建各种新对象、建立对象之<br>间的关系，调用对象的方法来改变各个对象的状态和对象消亡的过程，不管程序运行的过程<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>和操作怎么样，本质上都是要得到一个结果，程序上一个时刻和下一个时刻的运行结果的差<br>异就表现在内存中的对象状态发生了变化。<br>2.为了在关机和内存空间不够的状况下，保持程序的运行状态，需要将内存中的对象状态保<br>存到持久化设备和从持久化设备中恢复出对象的状态，通常都是保存到关系数据库来保存大<br>量对象信息。从 Java 程序的运行功能上来讲，保存对象状态的功能相比系统运行的其他功<br>能来说，应该是一个很不起眼的附属功能，java 采用 jdbc 来实现这个功能，这个不起眼的<br>功能却要编写大量的代码，而做的事情仅仅是保存对象和恢复对象，并且那些大量的 jdbc<br>代码并没有什么技术含量，基本上是采用一套例行公事的标准代码模板来编写，是一种苦活<br>和重复性的工作。<br>3.通过数据库保存 java 程序运行时产生的对象和恢复对象，其实就是实现了 java 对象与关<br>系数据库记录的映射关系，称为 ORM（即 Object Relation Mapping），人们可以通过封装<br>JDBC 代码来实现了这种功能，封装出来的产品称之为 ORM 框架，Hibernate 就是其中的一<br>种流行 ORM 框架。使用 Hibernate 框架，不用写 JDBC 代码，仅仅是调用一个 save 方法，<br>就可以将对象保存到关系数据库中，仅仅是调用一个 get 方法，就可以从数据库中加载出一<br>个对象。<br>4.使用 Hibernate 的基本流程是：配置 Configuration 对象、产生 SessionFactory、创建 session<br>对象，启动事务，完成 CRUD 操作，提交事务，关闭 session。<br>5.使用 Hibernate 时，先要配置 hibernate.cfg.xml 文件，其中配置数据库连接信息和方言等，<br>还要为每个实体配置相应的 hbm.xml 文件，hibernate.cfg.xml 文件中需要登记每个 hbm.xml<br>文件。<br>6.在应用 Hibernate 时，重点要了解 Session 的缓存原理，级联，延迟加载和 hql 查询。</p>
</li>
<li><p>hibernate 中的 update()和 saveOrUpdate()的区别，session 的 load()和 get()的区别。</p>
</li>
<li><p>简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件. 216. Hibernate 的应用（Hibernate 的结构）？<br>答：&#x2F;&#x2F;首先获得 SessionFactory 的对象<br>SessionFactory sessionFactory &#x3D; new Configuration().configure().buildSessionFactory();<br>&#x2F;&#x2F;然后获得 session 的对象<br>Session session &#x3D; sessionFactory.openSession();<br>&#x2F;&#x2F;其次获得 Transaction 的对象<br>Transaction tx &#x3D; session.beginTransaction();<br>&#x2F;&#x2F;执行相关的数据库操作:增,删,改,查<br>session.save(user); &#x2F;&#x2F;增加, user 是 User 类的对象<br>session.delete(user); &#x2F;&#x2F;删除<br>session.update(user); &#x2F;&#x2F;更新<br>Query query &#x3D; session.createQuery(“from User”); &#x2F;&#x2F;查询<br>List list &#x3D; query.list();<br>&#x2F;&#x2F;提交事务<br>tx.commit();<br>&#x2F;&#x2F;如果有异常,我们还要作事务的回滚,恢复到操作之前<br>tx.rollback();<br>&#x2F;&#x2F;最后还要关闭 session,释放资源<br>session.close()</p>
</li>
<li><p>112、Hibernate 有哪 5 个核心接口？<br>答：Configuration 接口：配置 Hibernate，根据其启动 hibernate，创建 SessionFactory 对象；<br>SessionFactory 接口：初始化 Hibernate，充当数据存储源的代理，创建 session 对象，<br>sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量<br>级、二级缓存；<br>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个<br>线程共享同一个 session，是轻量级、一级缓存；<br>Transaction 接口：管理事务；<br>Query 和 Criteria 接口：执行数据库的查询。</p>
</li>
<li><p>iBatis 与 Hibernate 有什么不同?<br>相同点：屏蔽 jdbc api 的底层访问细节，使用我们不用与 jdbc api 打交道，就可以访问数据。<br>jdbc api 编程流程固定，还将 sql 语句与 java 代码混杂在了一起，经常需要拼凑 sql 语句，细<br>节很繁琐。<br>ibatis 的好处：屏蔽 jdbc api 的底层访问细节；将 sql 语句与 java 代码进行分离;提供了将结<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>果集自动封装称为实体对象和对象的集合的功能，queryForList 返回对象集合，用<br>queryForObject 返回单个对象；提供了自动将实体对象的属性传递给 sql 语句的参数。<br>Hibernate 是一个全自动的 orm 映射工具，它可以自动生成 sql 语句,ibatis 需要我们自己在 xml<br>配置文件中写 sql 语句，hibernate 要比 ibatis 功能负责和强大很多。因为 hibernate 自动生成<br>sql 语句，我们无法控制该语句，我们就无法去写特定的高效率的 sql。对于一些不太复杂的<br>sql 查询，hibernate 可以很好帮我们完成，但是，对于特别复杂的查询，hibernate 就很难适<br>应了，这时候用 ibatis 就是不错的选择，因为 ibatis 还是由我们自己写 sql 语句。</p>
</li>
<li><p>写 Hibernate 的一对多和多对一双向关联的 orm 配置?</p>
</li>
<li><p>什么是 ORM？<br>答：对象关系映射（Object—Relational Mapping，简称 ORM）是一种为了解决面向对象与<br>面向关系数据库存在的互不匹配的现象的技术；简单的说，ORM 是通过使用描述对象和数<br>据库之间映射的元数据，将 java 程序中的对象自动持久化到关系数据库中；本质上就是将<br>数据从一种形式转换到另外一种形式。</p>
</li>
<li><p>hibernate 的 inverse 属性的作用?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p>
</li>
<li><p>在 DAO 中如何体现 DAO 设计模式?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p>
</li>
<li><p>spring+Hibernate 中委托方案怎么配置?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p>
</li>
<li><p>spring+Hibernate 中委托方案怎么配置?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p>
</li>
<li><p>hibernate 进行多表查询每表中各取几个字段，就是说查询出的结果集没有一个实体<br>类与之对应如何解决<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p>
</li>
<li><p>应用服务器与 WEB SERVER 的区别？</p>
</li>
<li><p>应用服务器有那些？<br>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，<br>Tomcat</p>
</li>
<li><p>J2EE 是什么？<br>答:Je22 是 Sun 公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的<br>企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为<br>不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客<br>户层(clietn tier)组件,web 层和组件,Business 层和组件,企业信息系统(EIS)层。<br>一个另类的回答：j2ee 就是增删改查。</p>
</li>
<li><p>J2EE 是技术还是平台还是框架？ 什么是 J2EE?<br>J2EE 本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br>J2EE 也是一个框架，包括 JDBC、JNDI、RMI、JMS、EJB、JTA 等技术。</p>
</li>
<li><p>如何设定的 weblogic 的热启动模式(开发模式)与产品发布模式?<br>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启<br>动文件或者 commenv 文件，增加 set PRODUCTION_MODE&#x3D;true。</p>
</li>
<li><p>说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的 helloWorld.jsp<br>放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp 就可以看<br>到运行结果了? 又比如这其中用到了一个自己写的 javaBean 该如何办?<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果<br>是 Web 应用，应用目录需要满足 Web 应用目录要求，jsp 文件可以直接放在应用目录中，<br>Javabean 需要放在应用目录的 WEB-INF 目录的 classes 目录中，设置服务器的缺省应用将可<br>以实现在浏览器上无需输入应用名。</p>
</li>
<li><p>在 weblogic 中发布 ejb 需涉及到哪些配置文件<br>不 同 类 型 的 EJB 涉 及 的 配 置 文 件 不 同 ， 都 涉 及 到 的 配 置 文 件 包 括<br>ejb-jar.xml,weblogic-ejb-jar.xmlCMP 实体 Bean 一般还需要 weblogic-cmp-rdbms-jar.xml</p>
</li>
<li><p>如何在 weblogic 中进行 ssl 配置与客户端的认证配置或说说 j2ee(标准)进行 ssl 的配<br>置?<br>缺省安装中使用 DemoIdentity.jks 和 DemoTrust.jks KeyStore 实现 SSL，需要配置服务器使<br>用 Enable SSL，配置其端口，在产品模式下需要从 CA 获取私有密钥和数字证书，创建 identity<br>和 trust keystore，装载获得的密钥和数字证书。可以配置此 SSL 连接是单向还是双向的。</p>
</li>
<li><p>如何查看在 weblogic 中已经发布的 EJB?<br>可以使用管理控制台，在它的 Deployment 中可以查看所有已发布的 EJB<br>十一、 ejb 部分</p>
</li>
<li><p>EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和<br>StatelessBean 区别。<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技术<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调<br>用其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对<br>象视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的<br>Session Bean 都可以将系统逻辑放在 method 之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean<br>的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就<br>是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗<br>J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状<br>态。</p>
</li>
<li><p>简要讲一下 EJB 的 7 个 Transaction Level?</p>
</li>
<li><p>EJB 与 JAVA BEAN 的区别？<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类<br>都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所<br>以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用<br>于实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，<br>它是不能被跨进程访问的。Enterprise Java Bean 相当于 DCOM，即分布式组件。它是基于<br>Java 的远程方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。<br>但 EJB 必须被布署在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正<br>的 EJB 组件，而是通过其容器访问。EJB 容器是 EJB 组件的代理，EJB 组件由容器所创建<br>和管理。客户通过容器来访问真正的 EJB 组件。</p>
</li>
<li><p>EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？<br>SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立<br>一个 Bean 的实例时，EJB 容器不一定要创建一个新的 Bean 的实例供客户机调用，而是随便<br>找一个现有的实例提供给客户机。当客户机第一次调用一个 Stateful Session Bean 时，容器<br>必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful<br>Session Bean 的方法时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不是按照应用程序或者服务进程来说的。即使 EJB 容器<br>崩溃了，Entity beans 也是存活的。Entity Beans 生命周期能够被容器或者 Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。</p>
</li>
<li><p>EJB 容器提供的服务<br>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</p>
</li>
<li><p>EJB 的激活机制<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>以Stateful Session Bean 为例：其 Cache大小决定了内存中可以同时存在的Bean实例的数量，<br>根据 MRU 或 NRU 算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某<br>个 EJB 实例业务方法时，如果对应 EJB Object 发现自己没有绑定对应的 Bean 实例则从其去<br>激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。</p>
</li>
<li><p>EJB 的几种类型<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean<br>会话 Bean 又可分为有状态（Stateful）和无状态（Stateless）两种<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种</p>
</li>
<li><p>客服端调用 EJB 对象的几个基本步骤<br>设置 JNDI 服务工厂以及 JNDI 服务地址系统属性，查找 Home 接口，从 Home 接口调用 Create<br>方法创建 Remote 接口，通过 Remote 接口调用其业务方法。 十二、 webservice 部分</p>
</li>
<li><p>名词解释：①WEB SERVICE ②JAXP ③JAXM ④SOAP ⑤UDDI ⑥WSDL。<br>JSWDL 开发包的介绍。<br>Web Service：Web Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 Web Service 能与其他兼容的组件进行互操作。<br>JAXP：(Java API for XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。<br>这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改<br>代码。<br>JAXM：(Java API for XML Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。<br>SOAP：即简单对象访问协议(Simple Object Access Protocol)，它是用于交换 XML 编码信息<br>的轻量级协议。<br>UDDI：的目的是为电子商务建立标准；UDDI 是一套基于 Web 的、分布式的、为 Web Service<br>提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的 Web Service<br>注册，以使别的企业能够发现的访问协议的实现标准。<br>WSDL：是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信<br>息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑<br>定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服<br>务）。</p>
</li>
<li><p>CORBA 是什么?用途是什么?<br>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象<br>管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为：用不同的程序<br>设计语言书写在不同的进程中运行，为不同的操作系统开发。</p>
</li>
</ol>
<p>1、什么是 Mybatis？<br>1、Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时<br>只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建<br>statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性<br>能，灵活度高。<br>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数<br>据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过<br>java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最<br>后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返<br>回 result 的过程）。<br>2、Mybaits 的优点：<br>1、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任<br>何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML<br>标签，支持编写动态 SQL 语句，并可重用。<br>2、与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不<br>需要手动开关连接；<br>3、很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要<br>JDBC 支持的数据库 MyBatis 都支持）。<br>4、能够与 Spring 很好的集成；<br>5、提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射<br>标签，支持对象关系组件维护。<br>3、MyBatis 框架的缺点：<br>1、SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写<br>SQL 语句的功底有一定要求。<br>2、SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。<br>4、MyBatis 框架适用场合：<br>1、MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。<br>2、对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是<br>不错的选择。</p>
<p>6、#{}和<code>$&#123;&#125;的区别是什么？ #&#123;&#125;是预编译处理，$</code>{}是字符串替换。<br>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的<br>set 方法来赋值；<br>Mybatis 在处理<code>$&#123;&#125;时，就是把$</code>{}替换成变量的值。<br>使用#{}可以有效的防止 SQL 注入，提高系统安全性。<br>7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？<br>第 1 种： 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类<br>的属性名一致。<br>第 2 种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。</p>
<p>文件，都会写一个 Dao 接口与之对应，<br>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，<br>参数不同时，方法能重载吗？<br>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；<br>接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的<br>参数，就是传递给 sql 的参数。<br>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符<br>串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个 &lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个<br>MapperStatement 对象。<br>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯<br>一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为<br>findStudentById 的 MapperStatement。<br>Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻<br>找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK<br>动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而<br>执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</p>
<p>13、如何获取自动生成的(主)键值?<br>insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。<br>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入<br>的参数对象中。</p>
<p>14、在 mapper 中如何传递多个参数?<br>1、第一种：<br>DAO 层的函数<br>2、第二种： 使用 @param 注解:<br>3、第三种：多个参数封装成 map</p>
<p>15、Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？<br>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理<br>是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。<br>Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose<br>| when | otherwise | bind。<br>16、Xml 映射文件中，除了常见的 select|insert|updae|delete<br>标签之外，还有哪些标签？<br>答：&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、 &lt;selectKey&gt;，加上动态 sql 的 9 个标签，其中&lt;sql&gt;为 sql 片段标签，通过 &lt;include&gt;标签引入 sql 片段，&lt;selectKey&gt;为不支持自增的主键生成策略标<br>签。<br>17、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？<br>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配<br>置 namespace，那么 id 不能重复；<br>原因就是 namespace+id 是作为 Map&lt;String, MapperStatement&gt;的 key<br>使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。<br>有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然<br>也就不同。<br>18、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动<br>的区别在哪里？<br>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联<br>集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis<br>在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自<br>动 ORM 映射工具。</p>
<p>20、MyBatis 实现一对一有几种方式?具体怎么操作的？<br>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在<br>resultMap 里面配置 association 节点配置一对一的类就可以完成；<br>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面<br>查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。<br>21、MyBatis 实现一对多有几种方式,怎么操作的？<br>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在<br>resultMap 里面的 collection 节点配置一对多的类就可以完成；嵌套查询是先查<br>一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过<br>配置 collection,但另外一个表的查询通过 select 节点配置。<br>22、Mybatis 是否支持延迟加载？如果支持，它的实现原理是<br>什么？<br>答：Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加<br>载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis<br>配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。<br>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦<br>截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是<br>null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，<br>然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()<br>方法的调用。这就是延迟加载的基本原理。<br>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都<br>是一样的。<br>23、Mybatis 的一级、二级缓存:<br>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为<br>Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就<br>将清空，默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap<br>存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，<br>如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要<br>实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br>&lt;cache&#x2F;&gt; ；<br>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存<br>Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将<br>被 clear。<br>25、使用 MyBatis 的 mapper 接口调用时有哪些要求？<br>1、Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；<br>2、Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的<br>parameterType 的类型相同；<br>3、Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的<br>resultType 的类型相同；<br>4、Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。<br>26、Mapper 编写有哪几种方式？<br>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写<br>mapper 接口，mapper 接口实现类、mapper.xml 文件。<br>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：<br>第三种：使用 mapper 扫描器：</p>
<p>ZooKeeper 面试题1.  ZooKeeper 面试题？<br>ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群<br>中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用<br>的接口和性能高效、功能稳定的系统提供给用户。<br>分布式应用程序可以基于 Zookeeper 实现诸如数据发布&#x2F;订阅、负载均衡、命名<br>服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。<br>Zookeeper 保证了如下分布式一致性特性：<br>1、顺序一致性<br>2、原子性<br>3、单一视图<br>4、可靠性<br>5、实时性（最终一致性）<br>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了<br>监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些<br>请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，<br>随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。<br>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个<br>更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。<br>而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个<br>zookeeper 最新的 zxid。<br>2.  ZooKeeper 提供了什么？<br>1、文件系统<br>2、通知机制<br>3.  Zookeeper 文件系统<br>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不<br>同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放<br>数据而目录节点不行。<br>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这<br>种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为<br>1M。<br>4.  ZAB 协议？<br>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广<br>播协议。<br>ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。<br>当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导<br>致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进<br>入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务<br>器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader<br>服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始<br>接收客户端的事务请求生成事物提案来进行事务请求处理。<br>5.  四种类型的数据节点 Znode<br>1、PERSISTENT-持久节点<br>除非手动删除，否则节点一直存在于 Zookeeper 上<br>2、EPHEMERAL-临时节点<br>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与<br>zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都<br>会被移除。<br>3、PERSISTENT_SEQUENTIAL-持久顺序节点<br>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维<br>护的自增整型数字。<br>4、EPHEMERAL_SEQUENTIAL-临时顺序节点<br>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的<br>自增整型数字。<br>6.  Zookeeper Watcher 机制 – 数据变更通知<br>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务<br>端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通<br>知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出<br>业务上的改变。<br>工作机制：<br>1、客户端注册 watcher<br>2、服务端处理 watcher<br>3、客户端回调 watcher<br>Watcher 特性总结：<br>1、一次性<br>无论是服务端还是客户端，一旦一个 Watcher 被触发，Zookeeper 都会将其从相<br>应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频<br>繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的<br>压力都非常大。<br>2、客户端串行执行<br>客户端 Watcher 回调的过程是一个串行同步的过程。<br>3、轻量<br>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具<br>体内容。<br>3.2、客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对<br>象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。<br>4、watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步<br>的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于<br>网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身<br>提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode<br>发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。<br>Zookeeper 只能保证最终的一致性，而无法保证强一致性。<br>5、注册 watcher getData、exists、getChildren<br>6、触发 watcher create、delete、setData<br>7、当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。<br>当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接<br>时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全<br>透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode<br>的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上<br>之前又删除了，这种情况下，这个 watch 事件可能会被丢失。<br>7.  客户端注册 Watcher 实现<br>1、调用 getData()&#x2F;getChildren()&#x2F;exist()三个 API，传入 Watcher 对象<br>2、标记请求 request，封装 Watcher 到 WatchRegistration<br>3、封装成 Packet 对象，发服务端发送 request<br>4、收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理<br>5、请求返回，完成注册。<br>8.  服务端处理 Watcher 实现<br>1、服务端接收 Watcher 并存储<br>接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点<br>的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现<br>了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在<br>WatcherManager 的 WatchTable 和 watch2Paths 中去。<br>2、Watcher 触发<br>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：<br>2.1 封装 WatchedEvent<br>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路<br>径封装成一个 WatchedEvent 对象<br>2.2 查询 Watcher<br>从 WatchTable 中根据节点路径查找 Watcher<br>2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher<br>2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里<br>可以看出 Watcher 在服务端是一次性的，触发一次就失效了）<br>3、调用 process 方法来触发 Watcher<br>这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。<br>9.  客户端回调 Watcher<br>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。<br>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。<br>10. ACL 权限控制机制<br>UGO（User&#x2F;Group&#x2F;Others）<br>目前在 Linux&#x2F;Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗<br>粒度的文件系统权限控制模式。<br>ACL（Access Control List）访问控制列表<br>包括三个方面：<br>权限模式（Scheme）<br>1、IP：从 IP 地址粒度进行权限控制<br>2、Digest：最常用，用类似于 username:password 的权限标识来进行权限配<br>置，便于区分不同应用来进行权限控制<br>3、World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标<br>识“world:anyone”<br>4、Super：超级用户<br>授权对象<br>授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。<br>权限 Permission<br>1、CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点<br>2、DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点<br>3、READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内<br>容或子节点列表等<br>4、WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作<br>5、ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置<br>操作<br>11. Chroot 特性<br>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名<br>空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将<br>会被限制在其自己的命名空间下。<br>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对<br>应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相<br>互隔离非常有帮助。<br>12. 会话管理<br>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进<br>行不同区块的隔离处理以及同一区块的统一处理。<br>分配原则：每个会话的“下次超时时间点”（ExpirationTime）<br>计算公式：<br>ExpirationTime_ &#x3D; currentTime + sessionTimeout<br>ExpirationTime &#x3D; (ExpirationTime_ &#x2F; ExpirationInrerval + 1) *<br>ExpirationInterval , ExpirationInterval 是指 Zookeeper 会话超时检查时间<br>间隔，默认 tickTime<br>13. 服务器角色<br>Leader<br>1、事务请求的唯一调度和处理者，保证集群事务处理的顺序性<br>2、集群内部各服务的调度者<br>Follower<br>1、处理客户端的非事务请求，转发事务请求给 Leader 服务器<br>2、参与事务请求 Proposal 的投票<br>3、参与 Leader 选举投票<br>Observer<br>1、3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提<br>升集群的非事务处理能力<br>2、处理客户端的非事务请求，转发事务请求给 Leader 服务器<br>3、不参与任何形式的投票<br>14. Zookeeper 下 Server 工作状态<br>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。<br>1、LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中<br>没有 Leader，因此需要进入 Leader 选举状态。<br>2、FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。<br>3、LEADING：领导者状态。表明当前服务器角色是 Leader。<br>4、OBSERVING：观察者状态。表明当前服务器角色是 Observer。<br>15. 数据同步<br>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）回向<br>Leader 服务器进行注册。当 Learner 服务器想 Leader 服务器完成注册后，进入<br>数据同步环节。<br>数据同步流程：（均以消息传递的方式进行）<br>Learner 向 Learder 注册<br>数据同步<br>同步确认<br>Zookeeper 的数据同步通常分为四类：<br>1、直接差异化同步（DIFF 同步）<br>2、先回滚再差异化同步（TRUNC+DIFF 同步）<br>3、仅回滚同步（TRUNC 同步）<br>4、全量同步（SNAP 同步）<br>在进行数据同步前，Leader 服务器会完成数据同步初始化：<br>peerLastZxid：<br> 从 learner 服务器注册时发送的 ACKEPOCH 消息中提取 lastZxid（该<br>Learner 服务器最后处理的 ZXID）<br>minCommittedLog：<br> Leader 服务器 Proposal 缓存队列 committedLog 中最小 ZXID<br>maxCommittedLog：<br> Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID<br>直接差异化同步（DIFF 同步）<br> 场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog<br>之间<br>先回滚再差异化同步（TRUNC+DIFF 同步）<br> 场景：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没<br>有的事务记录，那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader<br>服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID<br>仅回滚同步（TRUNC 同步）<br> 场景：peerLastZxid 大于 maxCommittedLog<br>全量同步（SNAP 同步）<br> 场景一：peerLastZxid 小于 minCommittedLog<br> 场景二：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等<br>于 lastProcessZxid<br>16. zookeeper 是如何保证事务的顺序一致性的？<br>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被<br>提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时<br>期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch<br>会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两<br>阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能<br>执行并且能够成功，那么就会开始执行。<br>17. 分布式集群中为什么会有 Master？<br>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机<br>器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行<br>leader 选举。<br>18. zk 节点宕机如何处理？<br>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保<br>证当一个节点宕机时，其他节点会继续提供服务。<br>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数<br>据是有多个副本的，数据并不会丢失；<br>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。<br>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK<br>节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。<br>所以<br>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)<br>2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;&#x3D;1)<br>19. zookeeper 负载均衡和 nginx 负载均衡区别<br>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写<br>插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。<br>20. Zookeeper 有哪几种几种部署模式？<br>部署模式：单机模式、伪集群模式、集群模式。<br>21. 集群最少要几台机器，集群规则是怎样的?<br>集群规则为 2N+1 台，N&gt;0，即 3 台。<br>22. 集群支持动态添加机器吗？<br>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：<br>全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的<br>会话。<br>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供<br>服务。这是比较常用的方式。<br>3.5 版本开始支持动态扩容。<br>23. Zookeeper 对节点的 watch监听通知是永久的吗？为什么<br>不是永久的?<br>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch<br>的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，<br>以便通知它们。<br>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况<br>下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。<br>一般是客户端执行 getData(“&#x2F;节点 A”,true)，如果节点 A 发生了变更或删除，<br>客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没<br>有设置 watch 事件，就不再给客户端发送。<br>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我<br>只要最新的数据即可。<br>24. Zookeeper 的 java 客户端都有哪些？<br>java 客户端：zk 自带的 zkclient 及 Apache 开源的 Curator。<br>25. chubby 是什么，和 zookeeper 比你怎么看？<br>chubby 是 google 的，完全实现 paxos 算法，不开源。zookeeper 是 chubby<br>的开源实现，使用 zab 协议，paxos 算法的变种。<br>26. 说几个 zookeeper 常用的命令。<br>常用命令：ls get set create delete 等。<br>27. ZAB 和 Paxos 算法的联系与区别？<br>相同点：<br>1、两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程<br>的运行<br>2、Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提<br>案进行提交<br>3、ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader<br>周期，Paxos 中名字为 Ballot<br>不同点：<br>ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建<br>分布式一致性状态机系统。<br>28. Zookeeper 的典型应用场景<br>Zookeeper 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员<br>可以使用它来进行分布式数据的发布和订阅。<br>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机<br>制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：<br>1、数据发布&#x2F;订阅<br>2、负载均衡<br>3、命名服务<br>4、分布式协调&#x2F;通知<br>5、集群管理<br>6、Master 选举<br>7、分布式锁<br>8、分布式队列<br>29. 数据发布&#x2F;订阅<br>介绍<br>数据发布&#x2F;订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者<br>进行数据订阅。<br>目的<br>动态获取数据（配置信息）<br>实现数据（配置信息）的集中式管理和数据的动态更新<br>设计模式<br>Push 模式<br>Pull 模式<br>数据（配置信息）特性<br>1、数据量通常比较小<br>2、数据内容在运行时会发生动态更新<br>3、集群中各机器共享，配置一致<br>如：机器列表信息、运行时开关配置、数据库配置信息等<br>基于 Zookeeper 的实现方式<br> 数据存储：将数据（配置信息）存储到 Zookeeper 上的一个数据节点<br> 数据获取：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并<br>在该节点上注册一个数据变更 Watcher<br> 数据变更：当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper<br>会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即<br>可。<br>30. 负载均衡<br>zk 的命名服务<br>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局<br>的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，<br>或者一个远程的对象等等。<br>分布式通知和协调<br>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，<br>然后 zk 将这些变化发送给注册了这个节点的 watcher 的所有客户端。<br>对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工<br>作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时<br>的全局情况。<br>zk 的命名服务（文件系统）<br>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局<br>的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，<br>提供的服务的地址，或者一个远程的对象等等。<br>zk 的配置管理（文件系统、通知机制）<br>程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有<br>配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的<br>内容，利用 watcher 通知给各个客户端，从而更改配置。<br>Zookeeper 队列管理（文件系统、通知机制）<br>两种类型的队列：<br>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有<br>成员到达。<br>2、队列按照 FIFO 方式进行入队和出队操作。<br>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。<br>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按<br>编号。在特定的目录下创建 PERSISTENT_SEQUENTIAL 节点，创建成功时<br>Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下<br>Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内<br>容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持<br>久化的，所以不必担心队列消息的丢失问题。</p>
<p>7、服务提供者能实现失效踢出是什么原理？<br>服务失效踢出基于 zookeeper 的临时节点原理。<br>8、服务上线怎么不影响旧版本？<br>采用多版本开发，不影响旧版本。<br>9、如何解决服务调用链过长的问题？<br>可以结合 zipkin 实现分布式服务追踪。</p>
<p>12、同一个服务多个注册的情况下可以直连某一个服务吗？<br>可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。<br>13、画一画服务注册与发现的流程图？<br>14、Dubbo 集群容错有几种方案？<br>集群容错方案 说明<br>Failover Cluster 失败自动切换，自动重试其它服务器（默认）<br>Failfast Cluster 快速失败，立即报错，只发起一次调用<br>Failsafe Cluster 失败安全，出现异常时，直接忽略<br>Failback Cluster 失败自动恢复，记录失败请求，定时重发<br>Forking Cluster 并行调用多个服务器，只要一个成功即返回<br>Broadcast Cluster 广播逐个调用所有提供者，任意一个报错则报错<br>15、Dubbo 服务降级，失败重试怎么做？<br>可以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修<br>改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口<br>名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑<br>16、Dubbo 使用过程中都遇到了些什么问题？<br>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解<br>无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确<br>17、Dubbo Monitor 实现原理？<br>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是<br>先走 filter 链，然后才进行真正的业务逻辑处理。<br>默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。<br>1、MonitorFilter 向 DubboMonitor 发送数据<br>2、DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到<br>ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个<br>含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，<br>调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕<br>一个，就重置当前的 Statistics 的 AtomicReference<br>3、SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队<br>列大写为 100000）<br>4、SimpleMonitorService 使用一个后台线程（线程名为：<br>DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以<br>死循环的形式来写）<br>5、SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：<br>DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</p>
<p>19、Dubbo 配置文件是如何加载到 Spring 中的？<br>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自<br>定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，<br>NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为<br>需要加载的 bean 对象！<br>20、Dubbo SPI 和 Java SPI 区别？<br>JDK SPI<br>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展吃实话很耗时，但<br>也没用上，很浪费资源。<br>所以只希望加载某个的实现，就不现实了<br>DUBBO SPI<br>1，对 Dubbo 进行扩展，不需要改动 Dubbo 的源码<br>2，延迟加载，可以一次只加载自己想要加载的扩展实现。<br>3，增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其<br>它扩展点。<br>3，Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。<br>21、Dubbo 支持分布式事务吗？<br>目前暂时不支持，可与通过 tcc-transaction 框架实现<br>介绍：tcc-transaction 是开源的 TCC 补偿性分布式事务框架<br>Git 地址：<br>TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。<br>22、Dubbo 可以对结果进行缓存吗？<br>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作<br>量<br>&lt;dubbo:reference cache&#x3D;”true” &#x2F;&gt;<br>其实比普通的配置文件就多了一个标签 cache&#x3D;”true”<br>23、服务上线怎么兼容旧版本？<br>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不<br>同的服务相互间不引用。这个和服务分组的概念有一点类似。<br>24、Dubbo 必须依赖的包有哪些？<br>Dubbo 必须依赖 JDK，其他为可选。<br>25、Dubbo telnet 命令能做什么？<br>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。<br>Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令<br>连接服务<br>telnet localhost 20880 &#x2F;&#x2F;键入回车进入 Dubbo 命令模式。<br>查看服务列表<br>dubbo&gt;ls<br>com.test.TestService<br>dubbo&gt;ls com.test.TestService<br>create<br>delete<br>query<br> ls (list services and methods)<br> ls : 显示服务列表。<br> ls -l : 显示服务详细信息列表。<br> ls XxxService：显示服务的方法列表。<br> ls -l XxxService：显示服务的方法详细信息列表。<br>26、Dubbo 支持服务降级吗？<br>以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修改<br>为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名<br>称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑<br>27、Dubbo 如何优雅停机？<br>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用<br>kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才<br>会执行。<br>28、Dubbo 和 Dubbox 之间的区别？<br>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如<br>加了服务可 Restful 调用，更新了开源组件等。</p>
<p>30、你还了解别的分布式框架吗？<br>别的还有 spring 的 spring cloud，facebook 的 thrift，twitter 的 finagle 等</p>
<p>仅索引层面调优手段：<br>1.1、设计阶段调优<br>1、根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索<br>引；<br>2、使用别名进行索引管理；<br>3、每天凌晨定时对索引做 force_merge 操作，以释放空间；<br>4、采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink<br>操作，以缩减存储；<br>5、采取 curator 进行索引的生命周期管理；<br>6、仅针对需要分词的字段，合理的设置分词器；<br>7、Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。……..<br>1.2、写入调优<br>1、写入前副本数设置为 0；<br>2、写入前关闭 refresh_interval 设置为-1，禁用刷新机制；<br>3、写入过程中：采取 bulk 批量写入；<br>4、写入后恢复副本数和刷新间隔；<br>5、尽量使用自动生成的 id。<br>1.3、查询调优<br>1、禁用 wildcard；<br>2、禁用批量 terms（成百上千的场景）；<br>3、充分利用倒排索引机制，能 keyword 类型尽量 keyword；<br>4、数据量大时候，可以先基于时间敲定索引再检索；<br>5、设置合理的路由机制。<br>1.4、其他调优<br>部署调优，业务调优等。<br>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。<br>2、elasticsearch 的倒排索引是什么<br>面试官：想了解你对基础概念的认知。<br>解答：通俗解释一下就可以。<br>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。<br>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表<br>即为倒排索引。<br>有了倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了<br>检索效率。<br>学术的解答方式：<br>倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文<br>档中出现过，由两部分组成——词典和倒排表。<br>加分项：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结<br>构。<br>lucene 从 4+版本后开始大量使用的数据结构是 FST。FST 有两个优点：<br>1、空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；<br>2、查询速度快。O(len(str))的查询时间复杂度。<br>3、elasticsearch 索引数据多了怎么办，如何调优，部署<br>面试官：想了解大数据量的运维能力。<br>解答：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，<br>这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户<br>检索或者其他业务受到影响。<br>如何调优，正如问题 1 所说，这里细化一下：<br>3.1 动态索引层面<br>基于模板+时间+rollover api 滚动创建索引，举例：设计阶段定义：blog 索<br>引的模板格式为：blog_index_时间戳的形式，每天递增数据。<br>这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线 2 的<br>32 次幂-1，索引存储达到了 TB+甚至更大。<br>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。<br>3.2 存储层面<br>冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。<br>对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，<br>节省存储空间和检索效率。<br>3.3 部署层面<br>一旦之前没有规划，这里就属于应急策略。<br>结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注<br>意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。<br>4、elasticsearch 是如何实现 master 选举的<br>面试官：想了解 ES 集群的底层原理，不再只关注业务层面了。<br>解答：<br>前置前提：<br>1、只有候选主节点（master：true）的节点才能成为主节点。<br>2、最小主节点数（min_master_nodes）的目的是防止脑裂。<br>这个我看了各种网上分析的版本和源码分析的书籍，云里雾里。<br>核对了一下代码，核心入口为 findMaster，选择主节点成功返回对应 Master，否<br>则返回 null。选举流程大致描述如下：<br>第一步：确认候选主节点数达标，elasticsearch.yml 设置的值<br>discovery.zen.minimum_master_nodes；<br>第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；<br>若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。<br>题外话：获取节点 id 的方法。<br>1GET &#x2F;_cat&#x2F;nodes?v&amp;h&#x3D;ip,port,heapPercent,heapMax,id,name<br>2ip port heapPercent heapMax id name<br>5、详细描述一下 Elasticsearch 索引文档的过程<br>面试官：想了解 ES 的底层原理，不再只关注业务层面了。<br>解答：<br>这里的索引文档应该理解为文档写入 ES，创建索引的过程。<br>文档写入包含：单文档写入和批量 bulk 写入，这里只解释一下：单文档写入流程。<br>记住官方文档中的这个图。<br>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由&#x2F;协调节点，<br>请求的节点扮演路由节点的角色。）<br>第二步：节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转<br>到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。<br>第三步：节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1<br>和节点 2 的副本分片上，等待结果返回。所有的副本分片都报告成功，节点 3 将<br>向协调节点（节点 1）报告成功，节点 1 向请求客户端报告写入成功。<br>如果面试官再问：第二步中的文档获取分片的过程？<br>回答：借助路由算法获取，路由算法就是根据路由和文档 id 计算目标的分片 id 的<br>过程。<br>1shard &#x3D; hash(*routing) % (num_of_primary_shards)<br>6、详细描述一下 Elasticsearch 搜索的过程？<br>面试官：想了解 ES 搜索的底层原理，不再只关注业务层面了。<br>解答：<br>搜索拆解为“query then fetch” 两个阶段。<br>query 阶段的目的：定位到位置，但不取。<br>步骤拆解如下：<br>1、假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本<br>分片中）的一个。<br>2、每个分片在本地进行查询，结果返回到本地有序的优先队列中。<br>3、第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。<br>fetch 阶段的目的：取数据。<br>路由节点获取所有文档，返回给客户端。<br>7、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法<br>面试官：想了解对 ES 集群的运维能力。<br>解答：<br>1、关闭缓存 swap;<br>2、堆内存设置为：Min（节点内存&#x2F;2, 32GB）;<br>3、设置最大文件句柄数；<br>4、线程池+队列大小根据业务需要做调整；<br>5、磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单<br>节点存储故障。</p>
<p>9、Elasticsearch 是如何实现 Master 选举的？<br>1、Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之<br>间通过这个 RPC 来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪<br>些节点需要 ping 通）这两部分；<br>2、对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排<br>序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第 0 位）<br>节点，暂且认为它是 master 节点。<br>3、如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n&#x2F;2+1）并<br>且该节点自己也选举自己，那这个节点就是 master。否则重新选举一直到满足上<br>述条件。<br>4、补充：master 节点的职责主要包括集群、节点和索引的管理，不负责文档级<br>别的管理；data 节点可以关闭 http 功能*。<br>10、Elasticsearch 中的节点（比如共 20 个），其中的 10 个<br>选了一个 master，另外 10 个选了另一个 master，怎么办？<br>1、当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量<br>（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解<br>决脑裂问题；<br>2、当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data<br>节点，避免脑裂问题。<br>11、客户端在和集群连接时，如何选择特定的节点执行请求的？<br>1、TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并<br>不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮<br>询 的方式与这些地址进行通信。<br>12、详细描述一下 Elasticsearch 索引文档的过程。<br>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合<br>适的分片。<br>shard &#x3D; hash(document_id) % (num_of_primary_shards)<br>1、当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory<br>Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Momery<br>Buffer 到 Filesystem Cache 的过程就叫做 refresh；<br>2、当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会<br>丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请<br>求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中<br>时，才会清除掉，这个过程叫做 flush；<br>3、在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync<br>将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一<br>个新的 translog。<br>4、flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认<br>为 512M）时；<br>补充：关于 Lucene 的 Segement：<br>1、Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。<br>2、段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重<br>建索引。<br>3、对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗<br>CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。<br>4、为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并<br>段到磁盘，并删除那些旧的小段。<br>13、详细描述一下 Elasticsearch 更新和删除文档的过程。<br>1、删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不<br>能被删除或者改动以展示其变更；<br>2、磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真<br>的被删除，而是在.del 文件中被标记为删除。该文档依然能匹配查询，但是会在<br>结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入<br>新段。<br>3、在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新<br>时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。<br>旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。<br>14、详细描述一下 Elasticsearch 搜索的过程。<br>1、搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；<br>2、在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分<br>片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的<br>优先队列。<br>PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory<br>Buffer，所以搜索是近实时的。<br>3、每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并<br>这些值到自己的优先队列中来产生一个全局排序后的结果列表。<br>4、接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片<br>提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回<br>文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。<br>5、补充：Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分<br>片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增<br>加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，<br>但是性能会变差。*<br>15、在 Elasticsearch 中，是怎么根据一个词找到对应的倒排索<br>引的？<br>SEE：<br> Lucene 的索引文件格式(1)<br> Lucene 的索引文件格式(2)<br>16、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方<br>法？<br>1、64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。<br>少于 8 GB 会适得其反。<br>2、如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多<br>个内核提供的额外并发远胜过稍微快一点点的时钟频率。<br>3、如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查<br>询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。<br>4、即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群<br>跨越大的地理距离。<br>5、请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在<br>Elasticsearch 的几个地方，使用 Java 的本地序列化。<br>6、通过设置 gateway.recover_after_nodes、gateway.expected_nodes、<br>gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可<br>能会让数据恢复从数个小时缩短为几秒钟。<br>7、Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只<br>有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。<br>8、不要随意修改垃圾回收器（CMS）和各个线程池的大小。<br>9、把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过<br>ES_HEAP_SIZE 环境变量设置。<br>10、内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个<br>100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起<br>来。 不难看出 swapping 对于性能是多么可怕。<br>11、Lucene 使用了大量 的文件。同时，Elasticsearch 在节点和 HTTP 客户端<br>之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你<br>应该增加你的文件描述符，设置一个很大的值，如 64,000。<br>补充：索引阶段性能提升方法<br>1、使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。<br>2、存储：使用 SSD<br>3、段和合并：Elasticsearch 默认值是 20 MB&#x2F;s，对机械磁盘应该是个不错的设<br>置。如果你用的是 SSD，可以考虑提高到 100–200 MB&#x2F;s。如果你在做批量导入，<br>完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加<br>index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的<br>值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。<br>4、如果你的搜索结果不需要近实时的准确度，考虑把每个索引的<br>index.refresh_interval 改到 30s。<br>5、如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副<br>本。<br>17、对于 GC 方面，在使用 Elasticsearch 时要注意什么？<br>1、SEE：<br>2、倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment<br>memory 增长趋势。<br>3、各类缓存，field cache, filter cache, indexing cache, bulk queue 等等，要<br>设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓<br>存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache<br>等“自欺欺人”的方式来释放内存。<br>4、避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用<br>scan &amp; scroll api 来实现。<br>5、cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集<br>群通过 tribe node 连接。<br>6、想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做<br>持续的监控。<br>18、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？<br>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，<br>即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对<br>我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到<br>基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；<br>小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内<br>存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。<br>19、在并发情况下，Elasticsearch 如果保证读写一致？<br>1、可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用<br>层来处理具体的冲突；<br>2、另外对于写操作，一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum，即只<br>有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络<br>等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点<br>上重建。<br>3、对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副<br>本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜<br>索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。<br>20、如何监控 Elasticsearch 集群状态？<br>Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你<br>的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
