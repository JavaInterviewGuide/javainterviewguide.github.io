<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker</title>
    <url>/publishes/52555cb3db5d.html</url>
    <content><![CDATA[<h1 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h1><ul>
<li>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</li>
<li>容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li>
<li>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</li>
<li>容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li>
<li>容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</li>
</ul>
<h1 id="物理机、虚拟机与容器"><a href="#物理机、虚拟机与容器" class="headerlink" title="物理机、虚拟机与容器"></a>物理机、虚拟机与容器</h1><ul>
<li>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的</li>
<li>虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统</li>
<li>因此容器的隔离级别会稍低一些。</li>
</ul>
<h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><ul>
<li>Docker是世界领先的软件容器平台。</li>
<li>Docker使用Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li>
<li>由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器</li>
<li>Docke最初实现是基于LXC。</li>
<li>Docker能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</li>
<li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li>
</ul>
<h1 id="Docker思想"><a href="#Docker思想" class="headerlink" title="Docker思想"></a>Docker思想</h1><ul>
<li>集装箱</li>
<li>标准化： ①运输方式、②存储方式、 ③API接口</li>
<li>隔离</li>
</ul>
<h1 id="Docker容器的特点"><a href="#Docker容器的特点" class="headerlink" title="Docker容器的特点"></a>Docker容器的特点</h1><ul>
<li>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li>
<li>标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</li>
<li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li>
</ul>
<h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><ul>
<li>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境</li>
<li>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</li>
<li>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</li>
<li>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</li>
<li>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</li>
<li>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</li>
</ul>
<h1 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h1><ul>
<li>简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</li>
<li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</li>
<li>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。</li>
<li>虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。</li>
</ul>
<h1 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h1><ul>
<li>Docker包括三个基本概念：<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
</li>
</ul>
<h4 id="镜像（Image）——一个特殊的文件系统"><a href="#镜像（Image）——一个特殊的文件系统" class="headerlink" title="镜像（Image）——一个特殊的文件系统"></a>镜像（Image）——一个特殊的文件系统</h4><ul>
<li>操作系统分为内核和用户空间</li>
<li>对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持</li>
<li>而Docker镜像（Image），就相当于是一个root文件系统。</li>
<li>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</li>
<li>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li>
<li>Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。</li>
<li>镜像实际是由多层文件系统联合组成。</li>
<li>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</li>
<li>分层存储的特征还使得镜像的复用、定制变的更为容易</li>
<li>甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</li>
</ul>
<h4 id="容器（Container）——镜像运行时的实体"><a href="#容器（Container）——镜像运行时的实体" class="headerlink" title="容器（Container）——镜像运行时的实体"></a>容器（Container）——镜像运行时的实体</h4><ul>
<li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</li>
<li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</li>
<li>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</li>
<li>按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li>
</ul>
<h4 id="仓库（Repository）——集中存放镜像文件的地方"><a href="#仓库（Repository）——集中存放镜像文件的地方" class="headerlink" title="仓库（Repository）——集中存放镜像文件的地方"></a>仓库（Repository）——集中存放镜像文件的地方</h4><ul>
<li>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</li>
<li>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</li>
<li>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。</li>
<li>这里补充一下Docker Registry公开服务和私有Docker Registry的概念：<ul>
<li>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub，这也是默认的Registry，并拥有大量的高质量的官方镜像。</li>
<li>除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</li>
</ul>
</li>
</ul>
<h1 id="Build，Ship，and-Run"><a href="#Build，Ship，and-Run" class="headerlink" title="Build，Ship，and Run"></a>Build，Ship，and Run</h1><ul>
<li>Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。</li>
<li>Ship（运输镜像）：主机和仓库间运输，这里的仓库就像是超级码头一样。</li>
<li>Run （运行镜像）：运行的镜像就是一个容器，容器就是运行程序的地方。</li>
<li>Docker运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。</li>
</ul>
<h1 id="Docker-的目的是什么？"><a href="#Docker-的目的是什么？" class="headerlink" title="Docker 的目的是什么？"></a>Docker 的目的是什么？</h1><ul>
<li>Docker 提供了一个可用于托管任何应用程序的容器环境。在此，软件应用程序和支持它的依赖项紧密打包在一起。</li>
<li>因此，这个打包的产品被称为 Container，因为它是由 Docker 完成的，所以它被称为 Docker 容器！</li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/publishes/b9efb3c36627.html</url>
    <content><![CDATA[<h1 id="Dubbo是什么？"><a href="#Dubbo是什么？" class="headerlink" title="Dubbo是什么？"></a>Dubbo是什么？</h1><ul>
<li>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案</li>
<li>简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）</li>
<li>其核心部分包含:<ul>
<li>远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>
<li>集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
<li>自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>
</ul>
</li>
</ul>
<h1 id="Dubbo能做什么？"><a href="#Dubbo能做什么？" class="headerlink" title="Dubbo能做什么？"></a>Dubbo能做什么？</h1><ul>
<li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li>
<li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li>
<li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li>
<li>Dubbo采用全spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。</li>
<li>之前使用Web Service，我想测试接口可以通过模拟消息的方式通过soapui或LR进行功能测试或性能测试。但现在使用Dubbo，接口之间不能直接交互，我尝试通过模拟消费者地址测试，结果不堪入目，再而使用jmeter通过junit进行测试，但还是需要往dubbo上去注册，如果再不给提供源代码的前提下，这个测试用例不好写啊….</li>
</ul>
<h1 id="dubbo的架构"><a href="#dubbo的架构" class="headerlink" title="dubbo的架构"></a>dubbo的架构</h1><ul>
<li>Provider: 暴露服务的服务提供方。</li>
<li>Consumer: 调用远程服务的服务消费方。</li>
<li>Registry: 服务注册与发现的注册中心。</li>
<li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li>
<li>Container: 服务运行容器。</li>
<li>这点我觉得非常好，角色分明，可以根据每个节点角色的状态来确定该服务是否正常。</li>
<li>调用关系说明：<ul>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
</li>
</ul>
<h1 id="Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么"><a href="#Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么" class="headerlink" title="Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么"></a>Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么</h1><ul>
<li>可以通信的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用；</li>
<li>注册中心对等集群，任意一台宕机后，将会切换到另一台；注册中心全部宕机后，服务的提供者和消费者仍能通过本地缓存通讯。服务提供者无状态，任一台 宕机后，不影响使用；服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复；</li>
<li>挂掉是不要紧的，但前提是你没有增加新的服务，如果你要调用新的服务，则是不能办到的。</li>
</ul>
<h1 id="dubbo服务负载均衡策略"><a href="#dubbo服务负载均衡策略" class="headerlink" title="dubbo服务负载均衡策略"></a>dubbo服务负载均衡策略</h1><ul>
<li>随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。(权重可以在dubbo管控台配置)</li>
<li>轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
<li>一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数Hash，如果要修改，请配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>缺省用160份虚拟节点，如果要修改，请配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Dubbo在安全机制方面是如何解决的"><a href="#Dubbo在安全机制方面是如何解决的" class="headerlink" title="Dubbo在安全机制方面是如何解决的"></a>Dubbo在安全机制方面是如何解决的</h1><ul>
<li>Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。</li>
</ul>
<h1 id="dubbo连接注册中心和直连的区别"><a href="#dubbo连接注册中心和直连的区别" class="headerlink" title="dubbo连接注册中心和直连的区别"></a>dubbo连接注册中心和直连的区别</h1><ul>
<li>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，<br>点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，</li>
<li>服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</li>
</ul>
<h1 id="dubbo服务集群配置（集群容错模式）"><a href="#dubbo服务集群配置（集群容错模式）" class="headerlink" title="dubbo服务集群配置（集群容错模式）"></a>dubbo服务集群配置（集群容错模式）</h1><ul>
<li>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。可以自行扩展集群容错策略</li>
</ul>
<h4 id="Failover-Cluster-默认"><a href="#Failover-Cluster-默认" class="headerlink" title="Failover Cluster(默认)"></a>Failover Cluster(默认)</h4><ul>
<li>失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过retries&#x3D;”2”来设置重试次数(不含第一次)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service retries=&quot;2&quot; cluster=&quot;failover&quot;/&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference retries=&quot;2&quot; cluster=&quot;failover&quot;/&gt;</span><br><span class="line">         cluster=&quot;failover&quot;可以不用写,因为默认就是failover</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Failfast-Cluster"><a href="#Failfast-Cluster" class="headerlink" title="Failfast Cluster"></a>Failfast Cluster</h4><ul>
<li>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dubbo:service cluster=&quot;failfast&quot; /&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference cluster=&quot;failfast&quot; /&gt;</span><br><span class="line">    cluster=&quot;failfast&quot;和 把cluster=&quot;failover&quot;、retries=&quot;0&quot;是一样的效果,retries=&quot;0&quot;就是不重试</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Failsafe-Cluster"><a href="#Failsafe-Cluster" class="headerlink" title="Failsafe Cluster"></a>Failsafe Cluster</h4><ul>
<li>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Failback-Cluster"><a href="#Failback-Cluster" class="headerlink" title="Failback Cluster"></a>Failback Cluster</h4><ul>
<li>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service cluster=&quot;failback&quot; /&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference cluster=&quot;failback&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Forking-Cluster"><a href="#Forking-Cluster" class="headerlink" title="Forking Cluster"></a>Forking Cluster</h4><ul>
<li>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks&#x3D;”2”来设置最大并行数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service cluster=“forking&quot; forks=&quot;2&quot;/&gt;</span><br><span class="line">         或：</span><br><span class="line">         &lt;dubbo:reference cluster=“forking&quot; forks=&quot;2&quot;/&gt;</span><br><span class="line">服务端服务级别</span><br><span class="line">　　　　&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">　　客户端服务级别</span><br><span class="line">　　　　&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">　　服务端方法级别　　　&lt;dubbo:service interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt; &lt;/dubbo:service&gt;</span><br><span class="line">客户端方法级别　        &lt;dubbo:reference interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&gt; &lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="dubbo通信协议dubbo协议为什么要消费者比提供者个数多："><a href="#dubbo通信协议dubbo协议为什么要消费者比提供者个数多：" class="headerlink" title="dubbo通信协议dubbo协议为什么要消费者比提供者个数多："></a>dubbo通信协议dubbo协议为什么要消费者比提供者个数多：</h1><ul>
<li>因dubbo协议采用单一长连接，假设网络为千兆网卡(1024Mbit&#x3D;128MByte)，根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，理论上1个服务提供者需要20个服务消费者才能压满网卡。</li>
</ul>
<h1 id="dubbo通信协议dubbo协议为什么不能传大包"><a href="#dubbo通信协议dubbo协议为什么不能传大包" class="headerlink" title="dubbo通信协议dubbo协议为什么不能传大包"></a>dubbo通信协议dubbo协议为什么不能传大包</h1><ul>
<li>因dubbo协议采用单一长连接，</li>
<li>如果每次请求的数据包大小为500KByte，假设网络为千兆网卡(1024Mbit&#x3D;128MByte)，每条连接最大7MByte(不同的环境可能不一样，供参考)，</li>
<li>单个服务提供者的TPS(每秒处理事务数)最大为：128MByte &#x2F; 500KByte &#x3D; 262。</li>
<li>单个消费者调用单个服务提供者的TPS(每秒处理事务数)最大为：7MByte &#x2F; 500KByte &#x3D; 14。</li>
<li>如果能接受，可以考虑使用，否则网络将成为瓶颈。</li>
</ul>
<h1 id="dubbo通信协议dubbo协议为什么采用异步单一长连接"><a href="#dubbo通信协议dubbo协议为什么采用异步单一长连接" class="headerlink" title="dubbo通信协议dubbo协议为什么采用异步单一长连接"></a>dubbo通信协议dubbo协议为什么采用异步单一长连接</h1><ul>
<li>因为服务的现状大都是服务提供者少，通常只有几台机器，</li>
<li>而服务的消费者多，可能整个网站都在访问该服务，</li>
<li>比如Morgan的提供者只有6台提供者，却有上百台消费者，每天有1.5亿次调用，</li>
<li>如果采用常规的hessian服务，服务提供者很容易就被压跨，</li>
<li>通过单一连接，保证单一消费者不会压死提供者，</li>
<li>长连接，减少连接握手验证等，</li>
<li>并使用异步IO，复用线程池，防止C10K问题。</li>
</ul>
<h1 id="dubbo通信协议dubbo协议适用范围和适用场景"><a href="#dubbo通信协议dubbo协议适用范围和适用场景" class="headerlink" title="dubbo通信协议dubbo协议适用范围和适用场景"></a>dubbo通信协议dubbo协议适用范围和适用场景</h1><ul>
<li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。</li>
<li>适用场景：常规远程服务方法调用</li>
<li>dubbo协议补充：<ul>
<li>连接个数：单连接</li>
<li>连接方式：长连接</li>
<li>传输协议：TCP</li>
<li>传输方式：NIO异步传输</li>
<li>序列化：Hessian二进制序列化</li>
</ul>
</li>
</ul>
<h1 id="RMI协议"><a href="#RMI协议" class="headerlink" title="RMI协议"></a>RMI协议</h1><ul>
<li>RMI协议采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式，Java标准的远程调用协议。</li>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：TCP</li>
<li>传输方式：同步传输</li>
<li>序列化：Java标准二进制序列化</li>
<li>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。</li>
<li>适用场景：常规远程服务方法调用，与原生RMI服务互操作</li>
</ul>
<h1 id="Hessian协议"><a href="#Hessian协议" class="headerlink" title="Hessian协议"></a>Hessian协议</h1><ul>
<li>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现</li>
<li>基于Hessian的远程调用协议。</li>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：Hessian二进制序列化</li>
<li>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</li>
<li>适用场景：页面传输，文件传输，或与原生hessian服务互操作</li>
</ul>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><ul>
<li>采用Spring的HttpInvoker实现</li>
<li>基于http表单的远程调用协议。</li>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：表单序列化（JSON）</li>
<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。</li>
<li>适用场景：需同时给应用程序和浏览器JS使用的服务。</li>
</ul>
<h1 id="Webservice"><a href="#Webservice" class="headerlink" title="Webservice"></a>Webservice</h1><ul>
<li>基于CXF的frontend-simple和transports-http实现</li>
<li>基于WebService的远程调用协议。</li>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：SOAP文本序列化</li>
<li>适用场景：系统集成，跨语言调用。</li>
</ul>
<h1 id="Thrif"><a href="#Thrif" class="headerlink" title="Thrif"></a>Thrif</h1><ul>
<li>Thrift是Facebook捐给Apache的一个RPC框架，当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如service name，magic number等</li>
</ul>
<h1 id="为什么要⽤Dubbo？"><a href="#为什么要⽤Dubbo？" class="headerlink" title="为什么要⽤Dubbo？"></a>为什么要⽤Dubbo？</h1><ul>
<li>因为是阿⾥开源项⽬，国内很多互联⽹公司都在⽤，已经经过很多线上考验。</li>
<li>内部使⽤了 Netty、Zookeeper，保证了⾼性能⾼可⽤性。</li>
<li>使⽤ Dubbo 可以将核⼼业务抽取出来，作为独⽴的服务，逐渐形成稳定的服务中⼼，可⽤于提⾼业务复⽤灵活扩展，使前端应⽤能更快速的响应多变的市场需求。</li>
<li>最重要的⼀点是，分布式架构可以承受更⼤规模的并发流量。</li>
</ul>
<h1 id="Dubbo-和-Spring-Cloud-有什么区别？"><a href="#Dubbo-和-Spring-Cloud-有什么区别？" class="headerlink" title="Dubbo 和 Spring Cloud 有什么区别？"></a>Dubbo 和 Spring Cloud 有什么区别？</h1><ul>
<li>两个没关联，如果硬要说区别，有以下⼏点。<ul>
<li><p>通信⽅式不同</p>
<ul>
<li>Dubbo 使⽤的是 RPC 通信，⽽ Spring Cloud 使⽤的是 HTTP RESTFul ⽅式。</li>
<li>dubbo由于是⼆进制的传输，占⽤带宽会更少（基于netty等）；springCloud是http协议传输，带宽会⽐较多，同时使⽤http协议（http+restful api）⼀般会使⽤JSON报⽂，消耗会更⼤。</li>
</ul>
</li>
<li><p>dubbo的开发难度较⼤，原因是dubbo的jar包依赖（存在代码级别的强依赖）问题很多⼤型⼯程⽆法解决；</p>
</li>
<li><p>springcloud的接⼝协议约定⽐较⾃由且松散，需要有强有⼒的⾏政措施来限制接⼝⽆序升级。</p>
</li>
<li><p>dubbo的改进是通过dubbofilter，很多东⻄没有，需要⾃⼰继承，如监控，如⽇志，如限流，如追踪。</p>
</li>
<li><p>springcloud具有配置管理、服务发现、断路器、智能路由、微代理、控制总线、⼀次性token、全局锁、选主、分布式会话和集群状态等，满⾜了构建微服务所需的所有解决⽅案。</p>
</li>
<li><p>组成部分不同</p>
</li>
</ul>
</li>
</ul>
<h1 id="dubbo都⽀持什么协议，推荐⽤哪种？"><a href="#dubbo都⽀持什么协议，推荐⽤哪种？" class="headerlink" title="dubbo都⽀持什么协议，推荐⽤哪种？"></a>dubbo都⽀持什么协议，推荐⽤哪种？</h1><ul>
<li>dubbo:&#x2F;&#x2F;（推荐）</li>
<li>rmi:&#x2F;&#x2F;</li>
<li>hessian:&#x2F;&#x2F;</li>
<li>http:&#x2F;&#x2F;</li>
<li>webservice:&#x2F;&#x2F;</li>
<li>thrift:&#x2F;&#x2F;</li>
<li>memcached:&#x2F;&#x2F;</li>
<li>redis:&#x2F;&#x2F;</li>
<li>rest:&#x2F;&#x2F;</li>
</ul>
<h1 id="Dubbo需要-Web-容器吗？"><a href="#Dubbo需要-Web-容器吗？" class="headerlink" title="Dubbo需要 Web 容器吗？"></a>Dubbo需要 Web 容器吗？</h1><ul>
<li>不需要，如果硬要⽤ Web 容器，只会增加复杂性，也浪费资源。</li>
</ul>
<h1 id="Dubbo内置了哪⼏种服务容器？"><a href="#Dubbo内置了哪⼏种服务容器？" class="headerlink" title="Dubbo内置了哪⼏种服务容器？"></a>Dubbo内置了哪⼏种服务容器？</h1><ul>
<li>Spring Container</li>
<li>Jetty Container</li>
<li>Log4j Container</li>
<li>Dubbo 的服务容器只是⼀个简单的 Main ⽅法，并加载⼀个简单的 Spring 容器，⽤于暴露服务。</li>
</ul>
<h1 id="Dubbo默认使⽤什么注册中⼼，还有别的选择吗？"><a href="#Dubbo默认使⽤什么注册中⼼，还有别的选择吗？" class="headerlink" title="Dubbo默认使⽤什么注册中⼼，还有别的选择吗？"></a>Dubbo默认使⽤什么注册中⼼，还有别的选择吗？</h1><ul>
<li>推荐使⽤ Zookeeper 作为注册中⼼，还有 Redis、Multicast、Simple 注册中⼼，但不推荐。</li>
<li>redis⽅案需要服务器时间同步，且性能消耗过⼤。</li>
</ul>
<h1 id="Dubbo有哪⼏种配置⽅式？"><a href="#Dubbo有哪⼏种配置⽅式？" class="headerlink" title="Dubbo有哪⼏种配置⽅式？"></a>Dubbo有哪⼏种配置⽅式？</h1><ul>
<li>Spring 配置⽅式</li>
<li>Java API 配置⽅式</li>
</ul>
<h1 id="在-Provider-上可以配置的-Consumer-端的属性有哪些？"><a href="#在-Provider-上可以配置的-Consumer-端的属性有哪些？" class="headerlink" title="在 Provider 上可以配置的 Consumer 端的属性有哪些？"></a>在 Provider 上可以配置的 Consumer 端的属性有哪些？</h1><ul>
<li>timeout：⽅法调⽤超时</li>
<li>retries：失败重试次数，默认重试 2 次</li>
<li>loadbalance：负载均衡算法，默认随机</li>
<li>actives 消费者端，最⼤并发调⽤限制</li>
</ul>
<h1 id="Dubbo启动时如果依赖的服务不可⽤会怎样？"><a href="#Dubbo启动时如果依赖的服务不可⽤会怎样？" class="headerlink" title="Dubbo启动时如果依赖的服务不可⽤会怎样？"></a>Dubbo启动时如果依赖的服务不可⽤会怎样？</h1><ul>
<li>Dubbo 缺省会在启动时检查依赖的服务是否可⽤，不可⽤时会抛出异常，阻⽌ Spring 初始化完成，默认 check&#x3D;”true”，可以通过 check&#x3D;”false” 关闭检查。</li>
</ul>
<h1 id="Dubbo推荐使⽤什么序列化框架，你知道的还有哪些？"><a href="#Dubbo推荐使⽤什么序列化框架，你知道的还有哪些？" class="headerlink" title="Dubbo推荐使⽤什么序列化框架，你知道的还有哪些？"></a>Dubbo推荐使⽤什么序列化框架，你知道的还有哪些？</h1><ul>
<li>推荐使⽤Hessian序列化，还有Duddo、FastJson、Java⾃带序列化。</li>
</ul>
<h1 id="Dubbo默认使⽤的是什么通信框架，还有别的选择吗？"><a href="#Dubbo默认使⽤的是什么通信框架，还有别的选择吗？" class="headerlink" title="Dubbo默认使⽤的是什么通信框架，还有别的选择吗？"></a>Dubbo默认使⽤的是什么通信框架，还有别的选择吗？</h1><ul>
<li>Dubbo 默认使⽤ Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。</li>
</ul>
<h1 id="注册了多个同⼀样的服务，如果测试指定的某⼀个服务呢？"><a href="#注册了多个同⼀样的服务，如果测试指定的某⼀个服务呢？" class="headerlink" title="注册了多个同⼀样的服务，如果测试指定的某⼀个服务呢？"></a>注册了多个同⼀样的服务，如果测试指定的某⼀个服务呢？</h1><ul>
<li>可以配置环境点对点直连，绕过注册中⼼，将以服务接⼝为单位，忽略注册中⼼的提供者列表。</li>
</ul>
<h1 id="Dubbo⽀持服务多协议吗？"><a href="#Dubbo⽀持服务多协议吗？" class="headerlink" title="Dubbo⽀持服务多协议吗？"></a>Dubbo⽀持服务多协议吗？</h1><ul>
<li>Dubbo 允许配置多协议，在不同服务上⽀持不同协议或者同⼀服务上同时⽀持多种协议。</li>
</ul>
<h1 id="当⼀个服务接⼝有多种实现时怎么做？"><a href="#当⼀个服务接⼝有多种实现时怎么做？" class="headerlink" title="当⼀个服务接⼝有多种实现时怎么做？"></a>当⼀个服务接⼝有多种实现时怎么做？</h1><ul>
<li>当⼀个接⼝有多种实现时，可以⽤ group 属性来分组，服务提供⽅和消费⽅都指定同⼀个 group 即可。</li>
</ul>
<h1 id="服务上线怎么兼容旧版本？"><a href="#服务上线怎么兼容旧版本？" class="headerlink" title="服务上线怎么兼容旧版本？"></a>服务上线怎么兼容旧版本？</h1><ul>
<li>可以⽤版本号（version）过渡，多个不同版本的服务注册到注册中⼼，版本号不同的服务相互间不引⽤。这个和服务分组的概念有⼀点类似。</li>
</ul>
<h1 id="Dubbo可以对结果进⾏缓存吗？"><a href="#Dubbo可以对结果进⾏缓存吗？" class="headerlink" title="Dubbo可以对结果进⾏缓存吗？"></a>Dubbo可以对结果进⾏缓存吗？</h1><ul>
<li>可以，Dubbo 提供了声明式缓存，⽤于加速热⻔数据的访问速度，以减少⽤户加缓存的⼯作量。</li>
</ul>
<h1 id="Dubbo服务之间的调⽤是阻塞的吗？"><a href="#Dubbo服务之间的调⽤是阻塞的吗？" class="headerlink" title="Dubbo服务之间的调⽤是阻塞的吗？"></a>Dubbo服务之间的调⽤是阻塞的吗？</h1><ul>
<li>默认是同步等待结果阻塞的，⽀持异步调⽤。</li>
<li>Dubbo 是基于 NIO 的⾮阻塞实现并⾏调⽤，客户端不需要启动多线程即可完成并⾏调⽤多个远程服务，相对多线程开销较⼩，异步调⽤会返回⼀个 Future 对象。</li>
</ul>
<h1 id="Dubbo⽀持分布式事务吗？"><a href="#Dubbo⽀持分布式事务吗？" class="headerlink" title="Dubbo⽀持分布式事务吗？"></a>Dubbo⽀持分布式事务吗？</h1><ul>
<li>⽬前暂时不⽀持，后续可能采⽤基于 JTA&#x2F;XA 规范实现，如以图所示。</li>
</ul>
<h1 id="Dubbo-telnet-命令能做什么？"><a href="#Dubbo-telnet-命令能做什么？" class="headerlink" title="Dubbo telnet 命令能做什么？"></a>Dubbo telnet 命令能做什么？</h1><ul>
<li>dubbo 通过 telnet 命令来进⾏服务治理</li>
<li>telnet localhost 8090</li>
</ul>
<h1 id="Dubbo⽀持服务降级吗？"><a href="#Dubbo⽀持服务降级吗？" class="headerlink" title="Dubbo⽀持服务降级吗？"></a>Dubbo⽀持服务降级吗？</h1><ul>
<li>Dubbo 2.2.0 以上版本⽀持。</li>
</ul>
<h1 id="Dubbo如何优雅停机？"><a href="#Dubbo如何优雅停机？" class="headerlink" title="Dubbo如何优雅停机？"></a>Dubbo如何优雅停机？</h1><ul>
<li>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使⽤ kill -9 PID 等强制关闭指令，是不会执⾏优雅停机的，只有通过 kill PID 时，才会执⾏。</li>
</ul>
<h1 id="服务提供者能实现失效踢出是什么原理？"><a href="#服务提供者能实现失效踢出是什么原理？" class="headerlink" title="服务提供者能实现失效踢出是什么原理？"></a>服务提供者能实现失效踢出是什么原理？</h1><ul>
<li>服务失效踢出基于 Zookeeper 的临时节点原理。 （服务机器会在zk上注册⼀个临时节点，服务失效则临时节点被删除）</li>
</ul>
<h1 id="如何解决服务调⽤链过⻓的问题？"><a href="#如何解决服务调⽤链过⻓的问题？" class="headerlink" title="如何解决服务调⽤链过⻓的问题？"></a>如何解决服务调⽤链过⻓的问题？</h1><ul>
<li>Dubbo 可以使⽤ Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪，当然还有其他很多⽅案。</li>
</ul>
<h1 id="服务读写推荐的容错策略是怎样的？"><a href="#服务读写推荐的容错策略是怎样的？" class="headerlink" title="服务读写推荐的容错策略是怎样的？"></a>服务读写推荐的容错策略是怎样的？</h1><ul>
<li>读操作建议使⽤ Failover 失败⾃动切换，默认重试两次其他服务器。</li>
<li>写操作建议使⽤ Failfast 快速失败，发⼀次调⽤失败就⽴即报错。</li>
</ul>
<h1 id="Dubbo必须依赖的包有哪些？"><a href="#Dubbo必须依赖的包有哪些？" class="headerlink" title="Dubbo必须依赖的包有哪些？"></a>Dubbo必须依赖的包有哪些？</h1><ul>
<li>Dubbo 必须依赖 JDK，其他为可选。</li>
</ul>
<h1 id="Dubbo的管理控制台能做什么？"><a href="#Dubbo的管理控制台能做什么？" class="headerlink" title="Dubbo的管理控制台能做什么？"></a>Dubbo的管理控制台能做什么？</h1><ul>
<li>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。</li>
</ul>
<h1 id="说说-Dubbo-服务暴露的过程。"><a href="#说说-Dubbo-服务暴露的过程。" class="headerlink" title="说说 Dubbo 服务暴露的过程。"></a>说说 Dubbo 服务暴露的过程。</h1><ul>
<li>Dubbo 会在 Spring 实例化完 bean 之后，</li>
<li>在刷新容器最后⼀步发布 ContextRefreshEvent 事件的时候，</li>
<li>通知实现了ApplicationListener 的 ServiceBean 类进⾏回调 onApplicationEvent 事件⽅法，</li>
<li>Dubbo 会在这个⽅法中调⽤ ServiceBean ⽗类ServiceConfig 的 export ⽅法，</li>
<li>⽽该⽅法真正实现了服务的（异步或者⾮异步）发布。</li>
</ul>
<h1 id="Dubbo-停⽌维护了吗？"><a href="#Dubbo-停⽌维护了吗？" class="headerlink" title="Dubbo 停⽌维护了吗？"></a>Dubbo 停⽌维护了吗？</h1><ul>
<li>2014 年开始停⽌维护过⼏年，17 年开始重新维护，并进⼊了 Apache 项⽬。</li>
</ul>
<h1 id="Dubbo-和-Dubbox-有什么区别？"><a href="#Dubbo-和-Dubbox-有什么区别？" class="headerlink" title="Dubbo 和 Dubbox 有什么区别？"></a>Dubbo 和 Dubbox 有什么区别？</h1><ul>
<li>Dubbox 是继 Dubbo 停⽌维护后，当当⽹基于 Dubbo 做的⼀个扩展项⽬，如加了服务可 Restful 调⽤，更新了开源组件等。</li>
</ul>
<h1 id="你还了解别的分布式框架吗？"><a href="#你还了解别的分布式框架吗？" class="headerlink" title="你还了解别的分布式框架吗？"></a>你还了解别的分布式框架吗？</h1><ul>
<li>别的还有 Spring cloud、Facebook 的 Thrift、Twitter 的 Finagle 等。</li>
</ul>
<h1 id="Dubbo-能集成-Spring-Boot-吗？"><a href="#Dubbo-能集成-Spring-Boot-吗？" class="headerlink" title="Dubbo 能集成 Spring Boot 吗？"></a>Dubbo 能集成 Spring Boot 吗？</h1><ul>
<li>可以的，项⽬地址如下。</li>
<li><a href="https://github.com/apache/incubator-dubbo-spring-boot-project">https://github.com/apache/incubator-dubbo-spring-boot-project</a></li>
</ul>
<h1 id="在使⽤过程中都遇到了些什么问题？"><a href="#在使⽤过程中都遇到了些什么问题？" class="headerlink" title="在使⽤过程中都遇到了些什么问题？"></a>在使⽤过程中都遇到了些什么问题？</h1><ul>
<li>单⼀⻓连接和NIO异步通讯，适合⼤并发⼩数据量的服务调⽤，以及消费者远⼤于提供者。Dubbo 的设计⽬的是为了满⾜⾼并发⼩数据量的 rpc 调⽤，在⼤数据量下的性能表现并不好，建议使⽤ rmi 或 http 协议。</li>
</ul>
<h1 id="你觉得⽤-Dubbo-好还是-Spring-Cloud-好？"><a href="#你觉得⽤-Dubbo-好还是-Spring-Cloud-好？" class="headerlink" title="你觉得⽤ Dubbo 好还是 Spring Cloud 好？"></a>你觉得⽤ Dubbo 好还是 Spring Cloud 好？</h1><ul>
<li>扩展性的问题，没有好坏，只有适合不适合，不过我好像更倾向于使⽤ Dubbo, Spring Cloud 版本升级太快，组件更新替换太频繁，配置太繁琐，还有很多我觉得是没有 Dubbo 顺⼿的地⽅……</li>
</ul>
<h1 id="Dubbo-是什么"><a href="#Dubbo-是什么" class="headerlink" title="Dubbo 是什么"></a>Dubbo 是什么</h1><ul>
<li>Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</li>
<li>主要核心部件：<ul>
<li>Remoting: 网络通信框架，实现了 sync-over-async 和 request-response 消息机制. RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能</li>
<li>Registry: 服务目录框架用于服务的注册和服务事件发布和订阅</li>
<li>Dubbo服务集群-集群容错模式</li>
<li>Dubbo 服务提供者集群与负载均衡</li>
</ul>
</li>
</ul>
<h1 id="Dubbo-执行流程什么是？"><a href="#Dubbo-执行流程什么是？" class="headerlink" title="Dubbo 执行流程什么是？"></a>Dubbo 执行流程什么是？</h1><ul>
<li>start: 启动 Spring 容器时,自动启动 Dubbo 的 Provider</li>
<li>register: Dubbo 的 Provider 在启动后自动会去注册中心注册内容.注册的内容包括:<ul>
<li>Provider 的 IP</li>
<li>Provider 的端口.</li>
<li>Provider 对外提供的接口列表.哪些方法.哪些接口类</li>
<li>Dubbo 的版本.</li>
<li>访问 Provider 的协议.</li>
</ul>
</li>
<li>subscribe: 订阅.当 Consumer 启动时,自动去 Registry 获取到所已注册的服务的信息.</li>
<li>notify: 通知.当 Provider 的信息发生变化时, 自动由 Registry 向 Consumer 推送通知.</li>
<li>invoke: 调用. Consumer 调用 Provider 中方法<ul>
<li>同步请求.消耗一定性能.但是必须是同步请求,因为需要接收调用方法后的结果.</li>
</ul>
</li>
<li>count:次数. 每隔 2 分钟,provoider 和 consumer 自动向 Monitor 发送访问次数.Monitor 进行统计.</li>
</ul>
<h1 id="Dubbo-可以对结果进行缓存吗？"><a href="#Dubbo-可以对结果进行缓存吗？" class="headerlink" title="Dubbo 可以对结果进行缓存吗？"></a>Dubbo 可以对结果进行缓存吗？</h1><ul>
<li>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cache</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其实比普通的配置文件就多了一个标签 <code>cache=&quot;true&quot;</code></li>
</ul>
<h1 id="Dubbo-支持分布式事务吗？"><a href="#Dubbo-支持分布式事务吗？" class="headerlink" title="Dubbo 支持分布式事务吗？"></a>Dubbo 支持分布式事务吗？</h1><ul>
<li>目前暂时不支持，可与通过 tcc-transaction 框架实现</li>
<li>介绍：tcc-transaction 是开源的 TCC 补偿性分布式事务框架</li>
<li>TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。</li>
</ul>
<h1 id="Dubbo-SPI-和-Java-SPI-区别？"><a href="#Dubbo-SPI-和-Java-SPI-区别？" class="headerlink" title="Dubbo SPI 和 Java SPI 区别？"></a>Dubbo SPI 和 Java SPI 区别？</h1><h4 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h4><ul>
<li>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展吃实话很耗时，但也没用上，很浪费资源。</li>
<li>所以只希望加载某个的实现，就不现实了</li>
</ul>
<h4 id="DUBBO-SPI"><a href="#DUBBO-SPI" class="headerlink" title="DUBBO SPI"></a>DUBBO SPI</h4><ul>
<li>对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</li>
<li>延迟加载，可以一次只加载自己想要加载的扩展实现。</li>
<li>增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>
<li>Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</li>
</ul>
<h1 id="Dubbo-配置文件是如何加载到-Spring-中的？"><a href="#Dubbo-配置文件是如何加载到-Spring-中的？" class="headerlink" title="Dubbo 配置文件是如何加载到 Spring 中的？"></a>Dubbo 配置文件是如何加载到 Spring 中的？</h1><ul>
<li>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为需要加载的 bean 对象！</li>
</ul>
<h1 id="Dubbo-Monitor-实现原理？"><a href="#Dubbo-Monitor-实现原理？" class="headerlink" title="Dubbo Monitor 实现原理？"></a>Dubbo Monitor 实现原理？</h1><ul>
<li>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是先走 filter 链，然后才进行真正的业务逻辑处理。</li>
<li>默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。<ul>
<li>MonitorFilter 向 DubboMonitor 发送数据</li>
<li>DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕一个，就重置当前的 Statistics 的 AtomicReference</li>
</ul>
</li>
<li>SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队列大写为 100000）</li>
<li>SimpleMonitorService 使用一个后台线程（线程名为：DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以<br>死循环的形式来写）</li>
<li>SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</li>
</ul>
<h1 id="Dubbo-服务降级，失败重试怎么做？"><a href="#Dubbo-服务降级，失败重试怎么做？" class="headerlink" title="Dubbo 服务降级，失败重试怎么做？"></a>Dubbo 服务降级，失败重试怎么做？</h1><ul>
<li>可以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑</li>
</ul>
<h1 id="Dubbo-集群容错有几种方案？"><a href="#Dubbo-集群容错有几种方案？" class="headerlink" title="Dubbo 集群容错有几种方案？"></a>Dubbo 集群容错有几种方案？</h1><ul>
<li>Failover Cluster 失败自动切换，自动重试其它服务器（默认）</li>
<li>Failfast Cluster 快速失败，立即报错，只发起一次调用</li>
<li>Failsafe Cluster 失败安全，出现异常时，直接忽略</li>
<li>Failback Cluster 失败自动恢复，记录失败请求，定时重发</li>
<li>Forking Cluster 并行调用多个服务器，只要一个成功即返回</li>
<li>Broadcast Cluster 广播逐个调用所有提供者，任意一个报错则报错</li>
</ul>
<h1 id="同一个服务多个注册的情况下可以直连某一个服务吗？"><a href="#同一个服务多个注册的情况下可以直连某一个服务吗？" class="headerlink" title="同一个服务多个注册的情况下可以直连某一个服务吗？"></a>同一个服务多个注册的情况下可以直连某一个服务吗？</h1><ul>
<li>可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。</li>
</ul>
<h1 id="服务提供者能实现失效踢出是什么原理？-1"><a href="#服务提供者能实现失效踢出是什么原理？-1" class="headerlink" title="服务提供者能实现失效踢出是什么原理？"></a>服务提供者能实现失效踢出是什么原理？</h1><ul>
<li>服务失效踢出基于 zookeeper 的临时节点原理。</li>
</ul>
<h1 id="服务上线怎么不影响旧版本？"><a href="#服务上线怎么不影响旧版本？" class="headerlink" title="服务上线怎么不影响旧版本？"></a>服务上线怎么不影响旧版本？</h1><ul>
<li>采用多版本开发，不影响旧版本。</li>
</ul>
<h1 id="如何解决服务调用链过长的问题？"><a href="#如何解决服务调用链过长的问题？" class="headerlink" title="如何解决服务调用链过长的问题？"></a>如何解决服务调用链过长的问题？</h1><ul>
<li>可以结合 zipkin 实现分布式服务追踪。</li>
</ul>
<h1 id="Dubbo的服务请求失败怎么处理"><a href="#Dubbo的服务请求失败怎么处理" class="headerlink" title="Dubbo的服务请求失败怎么处理"></a>Dubbo的服务请求失败怎么处理</h1><ul>
<li>因此，将应用拆分，并抽取出核心服务来解决上述问题，还要考虑负载均衡、服务监控、高可用性、服务隔离与降级、路由策略、完善的容错机制、序列化方案的选择、通信框架的选择、开发人员对底层细节无感知、服务升级兼容性等问题。Dubbo满足了以上所有需求。</li>
</ul>
<h1 id="重连机制会不会造成错误"><a href="#重连机制会不会造成错误" class="headerlink" title="重连机制会不会造成错误"></a>重连机制会不会造成错误</h1><ul>
<li>dubbo在调用服务不成功时，默认会重试2次。</li>
<li>Dubbo的路由机制，会把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机制也能一定程度的保证服务的质量。</li>
<li>但是如果不合理的配置重试次数，当失败时会进行重试多次，这样在某个时间点出现性能问题，调用方再连续重复调用。</li>
<li>系统请求变为正常值的retries倍，系统压力会大增，容易引起服务雪崩，需要根据业务情况规划好如何进行异常处理，何时进行重试。</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java web</title>
    <url>/publishes/e002a9c6759b.html</url>
    <content><![CDATA[<h1 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service?"></a>什么是Web Service?</h1><ul>
<li>Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。</li>
<li>使用的技术：HTTP、XML、SOAP（简单对象访问协议）、WSDL</li>
<li>优点：跨平台、跨语言、跨系统</li>
<li>SOAP协议:<ul>
<li>SOAP协议（Simple Object Access Protocal,简单对象访问协议）</li>
<li>Tcp&#x2F;iphttp-&gt;soap，soap 通过xml文件传送信息</li>
</ul>
</li>
<li>缺点：<ul>
<li>WebService使用了XML对数据封装，会造成大量的数据要在网络中传输。</li>
<li>WebService规范没有规定任何与实现相关的细节，包括对象模型、编程语言，这一点，它不如CORBA。</li>
</ul>
</li>
</ul>
<h1 id="什么是Web容器"><a href="#什么是Web容器" class="headerlink" title="什么是Web容器?"></a>什么是Web容器?</h1><ul>
<li>实现J2EE规范中web协议的应用</li>
<li>该协议定义了web程序的运行时环境,包括:并发性,安全性,生命周期管理等等.</li>
<li>就是在tomcat、weblogic下运行jsp、servlet、struts</li>
</ul>
<h1 id="应用服务器有那些？"><a href="#应用服务器有那些？" class="headerlink" title="应用服务器有那些？"></a>应用服务器有那些？</h1><ul>
<li>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat</li>
</ul>
<h1 id="如何给weblogic指定大小的内存"><a href="#如何给weblogic指定大小的内存" class="headerlink" title="如何给weblogic指定大小的内存?"></a>如何给weblogic指定大小的内存?</h1><ul>
<li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li>
</ul>
<h1 id="如何设定的weblogic的热启动模式-开发模式-与产品发布模式"><a href="#如何设定的weblogic的热启动模式-开发模式-与产品发布模式" class="headerlink" title="如何设定的weblogic的热启动模式(开发模式)与产品发布模式?"></a>如何设定的weblogic的热启动模式(开发模式)与产品发布模式?</h1><ul>
<li>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一</li>
<li>或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE&#x3D;true。</li>
</ul>
<h1 id="如何启动时不需输入用户名与密码"><a href="#如何启动时不需输入用户名与密码" class="headerlink" title="如何启动时不需输入用户名与密码?"></a>如何启动时不需输入用户名与密码?</h1><ul>
<li>修改服务启动文件，增加 WLS_USER和WLS_PW项</li>
<li>也可以在boot.properties文件中增加加密过的用户名和密码.</li>
</ul>
<h1 id="在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中"><a href="#在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中" class="headerlink" title="在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?"></a>在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?</h1><ul>
<li>保存在此Domain的config.xml文件中，它是服务器的核心配置文件。</li>
</ul>
<h1 id="说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办"><a href="#说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办" class="headerlink" title="说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?"></a>说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?</h1><ul>
<li>Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问</li>
<li>如果是Web应用，应用目录需要满足Web应用目录要求</li>
<li>jsp文件可以直接放在应用目录中</li>
<li>Javabean需要放在应用目录的WEB-INF目录的classes目录中</li>
<li>设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。</li>
</ul>
<h1 id="CORBA是什么-用途是什么"><a href="#CORBA是什么-用途是什么" class="headerlink" title="CORBA是什么?用途是什么?"></a>CORBA是什么?用途是什么?</h1><ul>
<li>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)</li>
<li>由对象管理组织 (Object Management Group，缩写为 OMG)标准化</li>
<li>它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议</li>
<li>其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。</li>
</ul>
<h1 id="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"><a href="#说说在weblogic中开发消息Bean时的persistent与non-persisten的差别" class="headerlink" title="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"></a>说说在weblogic中开发消息Bean时的persistent与non-persisten的差别</h1><ul>
<li>persistent方式的MDB可以保证消息传递的可靠性</li>
<li>也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来</li>
<li>而non－persistent方式的消息将被丢弃。</li>
</ul>
<h1 id="WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。"><a href="#WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。" class="headerlink" title="WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。"></a>WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</h1><ul>
<li>Web Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。</li>
<li>JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口，这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。</li>
<li>JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。</li>
<li>WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。</li>
<li>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。</li>
<li>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。</li>
</ul>
<h1 id="简单说说tomcat的配置？"><a href="#简单说说tomcat的配置？" class="headerlink" title="简单说说tomcat的配置？"></a>简单说说tomcat的配置？</h1><ul>
<li>JAVA_HOME&#x3D;JDK的根目录</li>
<li>CATALINA_HOME&#x3D;tomcat的根目录</li>
<li>CATALINA-HOME\conf\server.xml:可以配置tomcat的端口，可以配置tomcat中下连接池。</li>
<li>CATALINA-HOME\common\lib:存放公用的类包</li>
</ul>
<h1 id="JSP中动态INCLUDE与静态INCLUDE的区别？"><a href="#JSP中动态INCLUDE与静态INCLUDE的区别？" class="headerlink" title="JSP中动态INCLUDE与静态INCLUDE的区别？"></a>JSP中动态INCLUDE与静态INCLUDE的区别？</h1><ul>
<li>jsp:include:在运行时调用另一个页面，变量是可以重复的。</li>
<li>&lt;%@include file&#x3D;””%&gt;:在转译时合在一起，会成为同一个类，变量不可以重复。</li>
<li>&lt;@include file&gt;:在将jsp生成servlet类前将两个文件和在一起，生成一个java类，一起运行的。所以是一家子，当中的变量名不能重名。</li>
<li>&lt;jsp:include page&gt;:是两个类，是一个调用关系，在运行时动态的调用，不是一家子，可以重复变量。</li>
</ul>
<h1 id="forward和redirect的区别？"><a href="#forward和redirect的区别？" class="headerlink" title="forward和redirect的区别？"></a>forward和redirect的区别？</h1><ul>
<li>forward: 转发，在下一个页面中，request保留上一个页面中的request的所有值</li>
<li>redirect: 跳转，不传递request对象。</li>
</ul>
<h1 id="Servlet的体系结构是什么"><a href="#Servlet的体系结构是什么" class="headerlink" title="Servlet的体系结构是什么?"></a>Servlet的体系结构是什么?</h1><ul>
<li>Servlet</li>
<li>GenericServlet</li>
<li>HttpServlet</li>
</ul>
<h1 id="如何实现一个自定义的servlet"><a href="#如何实现一个自定义的servlet" class="headerlink" title="如何实现一个自定义的servlet?"></a>如何实现一个自定义的servlet?</h1><ul>
<li>extends HttpServlet 并覆盖doPost或doGet方法</li>
<li>在web.xml中进行部署</li>
</ul>
<h1 id="Servlet的生命周期是什么"><a href="#Servlet的生命周期是什么" class="headerlink" title="Servlet的生命周期是什么?"></a>Servlet的生命周期是什么?</h1><ul>
<li>Init </li>
<li>多次执行doGet或doPost  </li>
<li>destroy</li>
</ul>
<h1 id="jsp就是一个servlet是否正确"><a href="#jsp就是一个servlet是否正确" class="headerlink" title="jsp就是一个servlet是否正确?"></a>jsp就是一个servlet是否正确?</h1><ul>
<li>对</li>
</ul>
<h1 id="请罗列jsp中的脚本、指令及动作"><a href="#请罗列jsp中的脚本、指令及动作" class="headerlink" title="请罗列jsp中的脚本、指令及动作?"></a>请罗列jsp中的脚本、指令及动作?</h1><ul>
<li>脚本：&lt;%%&gt;  &lt;%&#x3D;%&gt;  &lt;%!%&gt; &lt;%—-%&gt;</li>
<li>指令<ul>
<li>&lt;%@page contentType&#x3D;”text&#x2F;html;charset&#x3D;utf-8” language&#x3D;”java” import&#x3D;””%&gt;</li>
<li>&lt;%@include file&#x3D;””%&gt;</li>
<li>&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</li>
</ul>
</li>
<li>动作:<ul>
<li>&lt;jsp:useBean class&#x3D;”” id&#x3D;”” scope&#x3D;””&gt;  在scope中如果没有实例化一个对象，如果有直接用以前的。</li>
<li>&lt;jsp:getProperty name&#x3D;”” property&#x3D;””&gt;  向一个bean中设置属性值</li>
<li>&lt;jsp:forward &gt;  jsp页的转发</li>
<li>&lt;jsp:include page&#x3D;””&gt;  导入一个jsp页面</li>
</ul>
</li>
</ul>
<h1 id="JSP的内置对象及方法"><a href="#JSP的内置对象及方法" class="headerlink" title="JSP的内置对象及方法"></a>JSP的内置对象及方法</h1><ul>
<li>Request  request表示HttpServletRequest对象。取客户端表单域信息及cookie, header, 和session </li>
<li>response response表示HttpServletResponse对象，对客户端的响应返回文本、写cookies。</li>
<li>out out 向客户端打印html文本. </li>
<li>pageContext :当前jsp页面的上下文环境，可以得到session、request、application等内置对象，在自定义标签中使用的很多。</li>
<li>session session表示一个请求的javax.servlet.http.HttpSession对象。Session一个用户多个页面共享同一变量。</li>
<li>application applicaton 表示一个javax.servle.ServletContext对象。存放容器级的变量。</li>
<li>config config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 </li>
<li>page page表示从该页面产生的一个servlet实例</li>
<li>exception:异常，当iserrorpage&#x3D;true</li>
</ul>
<h1 id="说出在JSP页面里是怎么分页的"><a href="#说出在JSP页面里是怎么分页的" class="headerlink" title="说出在JSP页面里是怎么分页的?"></a>说出在JSP页面里是怎么分页的?</h1><ul>
<li>页面需要保存以下参数：(数据库的分页及比较)<ul>
<li>总行数：根据sql语句得到总行数</li>
<li>每页显示行数：设定值</li>
<li>当前页数：请求参数</li>
</ul>
</li>
<li>页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。</li>
</ul>
<h1 id="描述JSP和Servlet的区别、共同点、各自应用的范围"><a href="#描述JSP和Servlet的区别、共同点、各自应用的范围" class="headerlink" title="描述JSP和Servlet的区别、共同点、各自应用的范围"></a>描述JSP和Servlet的区别、共同点、各自应用的范围</h1><ul>
<li>Jsp主要在于页面的显示动态生成页面，可以与html标记一起使用，其还是要生成为一个servlet。</li>
<li>Servlet：主要是控制的处理，如调用业务层，跳转不同的jsp页面。</li>
<li>Mvc:<ul>
<li>Jsp:v</li>
<li>Servlet:c</li>
</ul>
</li>
</ul>
<h1 id="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"><a href="#在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？" class="headerlink" title="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"></a>在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？</h1><ul>
<li>Request.getparameter(“”)</li>
<li>&lt;%&#x3D;application.getRealPath(“aa.jsp”) %&gt;</li>
</ul>
<h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。</h1><ul>
<li>Cookie:主要用在保存客户端，其值在客户端与服务端之间传送，不安全，存储的数据量有限。</li>
<li>Session:保存在服务端，每一个session在服务端有一个sessionID作一个标识。存储的数据量大，安全性高。占用服务端的内存资源。</li>
</ul>
<h1 id="说明Jsp中errorPage的作用，应用范围。"><a href="#说明Jsp中errorPage的作用，应用范围。" class="headerlink" title="说明Jsp中errorPage的作用，应用范围。"></a>说明Jsp中errorPage的作用，应用范围。</h1><ul>
<li>正常页面中：%@page erropage&#x3D;”error.jsp”%</li>
<li>错误页面：&lt;%@page iserrorpage&#x3D;”true”%&gt;</li>
<li>有一内置对象:exception</li>
</ul>
<h1 id="介绍在Jsp中如何使用JavaBeans"><a href="#介绍在Jsp中如何使用JavaBeans" class="headerlink" title="介绍在Jsp中如何使用JavaBeans"></a>介绍在Jsp中如何使用JavaBeans</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;jsp:useBean class=”” id=”” scope=””/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	New 类();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h1 id="简单介绍JSP的标记库"><a href="#简单介绍JSP的标记库" class="headerlink" title="简单介绍JSP的标记库"></a>简单介绍JSP的标记库</h1><ul>
<li><p>做一个标记处理类 extends TagSupport</p>
</li>
<li><p>通过tld说明标记处理的类的前缀及后缀</p>
</li>
<li><p>在web.xml中说明tld文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;taglib&gt;</span><br><span class="line">		&lt;taglib-uri&gt;</span><br><span class="line">		&lt;taglib-location&gt;</span><br><span class="line">&lt;taglib&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在jsp页面是引用tld&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</p>
</li>
</ul>
<h1 id="Servlet中的核心类有那些，各有什么特点"><a href="#Servlet中的核心类有那些，各有什么特点" class="headerlink" title="Servlet中的核心类有那些，各有什么特点?"></a>Servlet中的核心类有那些，各有什么特点?</h1><ul>
<li>ServletContext：容器，放置全局变量<ul>
<li>setAtribute()</li>
<li>getAttribute()</li>
</ul>
</li>
<li>ServletConfig：一个servlet的配置<ul>
<li>getInitParameter(”名称”)</li>
</ul>
</li>
<li>HttpServletRequest：封装的所有的请求<ul>
<li>getParameterValue(”名称”)</li>
<li>getParameterValues(”称”)</li>
</ul>
</li>
<li>getSession();<ul>
<li>getAttribute(” 名称”);</li>
<li>getRequestDispatch(”a.jsp”).forward(request,response)</li>
</ul>
</li>
<li>HttpServletResponse：响应<ul>
<li>getOut();</li>
<li>sendRedirect(””)</li>
</ul>
<p>							</p>
</li>
<li>HttpSession：一个用户多个页面共享同一变量<ul>
<li>setAttribute(””,””)</li>
</ul>
</li>
</ul>
<h1 id="Servlet中重要的包有那些，有什么区别"><a href="#Servlet中重要的包有那些，有什么区别" class="headerlink" title="Servlet中重要的包有那些，有什么区别?"></a>Servlet中重要的包有那些，有什么区别?</h1><ul>
<li>javax.servlet.<em>；javax.servlet.http.</em>;</li>
</ul>
<h1 id="说出Servlet的生命周期，并说出Servlet和CGI的区别？"><a href="#说出Servlet的生命周期，并说出Servlet和CGI的区别？" class="headerlink" title="说出Servlet的生命周期，并说出Servlet和CGI的区别？"></a>说出Servlet的生命周期，并说出Servlet和CGI的区别？</h1><ul>
<li>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</li>
<li>与cgi的区别在于servlet处理服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li>
</ul>
<h1 id="什么情况下调用doGet-和doPost-？"><a href="#什么情况下调用doGet-和doPost-？" class="headerlink" title="什么情况下调用doGet()和doPost()？"></a>什么情况下调用doGet()和doPost()？</h1><ul>
<li>Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。</li>
</ul>
<h1 id="如何现实servlet的单线程模式"><a href="#如何现实servlet的单线程模式" class="headerlink" title="如何现实servlet的单线程模式"></a>如何现实servlet的单线程模式</h1><ul>
<li>在doGet及doPost方法前加入synchoronized</li>
<li>JSP：&lt;%@ page isThreadSafe&#x3D;”true”%&gt;</li>
</ul>
<h1 id="Request对象的主要方法："><a href="#Request对象的主要方法：" class="headerlink" title="Request对象的主要方法："></a>Request对象的主要方法：</h1><ul>
<li>setAttribute(String name,Object)：设置名字为name的request的参数值</li>
<li>getAttribute(String name)：返回由name指定的属性值</li>
<li>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例</li>
<li>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组</li>
<li>getCharacterEncoding()：返回请求中的字符编码方式</li>
<li>getContentLength()：返回请求的Body的长度</li>
<li>getInputStream()：返回请求的输入流，用于获得请求中的数据</li>
<li>getMethod()：获得客户端向服务器端传送数据的方法</li>
<li>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值</li>
<li>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li>
<li>getParameterValues(String name)：获得有name指定的参数的所有值</li>
<li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li>
<li>getQueryString()：获得查询字符串</li>
<li>getRequestURI()：获取发出请求字符串的客户端地址</li>
<li>getRemoteAddr()：获取客户端的IP地址</li>
<li>getRemoteHost()：获取客户端的名字</li>
<li>getSession([Boolean create])：返回和请求相关Session</li>
<li>getServerName()：获取服务器的名字</li>
<li>getServletPath()：获取客户端所请求的脚本文件的路径</li>
<li>getServerPort()：获取服务器的端口号</li>
<li>removeAttribute(String name)：删除请求中的一个属性</li>
</ul>
<h1 id="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"><a href="#我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"></a>我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Public String translate (String str) &#123;</span><br><span class="line">  String tempStr = &quot;&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">    tempStr = new String(str.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);</span><br><span class="line">    tempStr = tempStr.trim();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Exception e) &#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  return tempStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Servlet执行时一般实现哪几个方法"><a href="#Servlet执行时一般实现哪几个方法" class="headerlink" title="Servlet执行时一般实现哪几个方法?"></a>Servlet执行时一般实现哪几个方法?</h1><ul>
<li>public void init(ServletConfig config)</li>
<li>public ServletConfig getServletConfig()</li>
<li>public String getServletInfo()</li>
<li>public void service(ServletRequest request,ServletResponse response)</li>
<li>public void destroy()</li>
</ul>
<h1 id="jsp有哪些内置对象-作用分别是什么："><a href="#jsp有哪些内置对象-作用分别是什么：" class="headerlink" title="jsp有哪些内置对象?作用分别是什么："></a>jsp有哪些内置对象?作用分别是什么：</h1><ul>
<li>JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）： <ul>
<li>request 用户端请求，此请求会包含来自GET&#x2F;POST请求的参数 </li>
<li>response 网页传回用户端的回应 </li>
<li>pageContext 网页的属性是在这里管理 </li>
<li>session 与请求有关的会话期 </li>
<li>application servlet 正在执行的内容 </li>
<li>out 用来传送回应的输出 </li>
<li>config servlet的构架部件 </li>
<li>page JSP网页本身 </li>
<li>exception 针对错误网页，未捕捉的例外。</li>
</ul>
</li>
</ul>
<h1 id="jsp有哪些动作-作用分别是什么："><a href="#jsp有哪些动作-作用分别是什么：" class="headerlink" title="jsp有哪些动作?作用分别是什么："></a>jsp有哪些动作?作用分别是什么：</h1><ul>
<li>JSP共有以下6种基本动作 <ul>
<li>jsp:include：在页面被请求的时候引入一个文件。 </li>
<li>jsp:useBean：寻找或者实例化一个JavaBean。 </li>
<li>jsp:setProperty：设置JavaBean的属性。 </li>
<li>jsp:getProperty：输出某个JavaBean的属性。 </li>
<li>jsp:forward：把请求转到一个新的页面。 </li>
<li>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。</li>
</ul>
</li>
</ul>
<h1 id="说一说Servlet的生命周期："><a href="#说一说Servlet的生命周期：" class="headerlink" title="说一说Servlet的生命周期："></a>说一说Servlet的生命周期：</h1><ul>
<li>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束</li>
<li>这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。</li>
</ul>
<h1 id="JAVA-SERVLET-API中forward-与redirect-的区别："><a href="#JAVA-SERVLET-API中forward-与redirect-的区别：" class="headerlink" title="JAVA SERVLET API中forward() 与redirect()的区别："></a>JAVA SERVLET API中forward() 与redirect()的区别：</h1><ul>
<li>前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接，从浏览器的地址栏中可以看到跳转后的链接地址</li>
<li>前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。</li>
</ul>
<h1 id="MVC的各个部分都有那些技术来实现-如何实现："><a href="#MVC的各个部分都有那些技术来实现-如何实现：" class="headerlink" title="MVC的各个部分都有那些技术来实现?如何实现："></a>MVC的各个部分都有那些技术来实现?如何实现：</h1><ul>
<li>MVC是Model－View－Controller的简写</li>
<li>“Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）</li>
<li>“View” 是应用的表示面（由JSP页面产生）</li>
<li>“Controller” 是提供应用的处理过程控制（一般是一个Servlet）</li>
<li>通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。</li>
</ul>
<h1 id="J2EE是什么："><a href="#J2EE是什么：" class="headerlink" title="J2EE是什么："></a>J2EE是什么：</h1><ul>
<li>Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model)</li>
<li>在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中</li>
<li>所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。</li>
</ul>
<h1 id="STRUTS的应用-如STRUTS架构-："><a href="#STRUTS的应用-如STRUTS架构-：" class="headerlink" title="STRUTS的应用(如STRUTS架构) ："></a>STRUTS的应用(如STRUTS架构) ：</h1><ul>
<li>Struts是采用Java Servlet&#x2F;JavaServer Pages技术，开发Web应用程序的开放源码的framework</li>
<li>采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架</li>
<li>Struts有如下的主要功能： <ul>
<li>包含一个controller servlet，能将用户的请求发送到相应的Action对象。 </li>
<li>JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 </li>
<li>提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。</li>
</ul>
</li>
</ul>
<h1 id="开发中都用到了那些设计模式-用在什么场合："><a href="#开发中都用到了那些设计模式-用在什么场合：" class="headerlink" title="开发中都用到了那些设计模式?用在什么场合："></a>开发中都用到了那些设计模式?用在什么场合：</h1><ul>
<li>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心</li>
<li>通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作</li>
<li>主要用到了MVC的设计模式</li>
<li>用来开发JSP&#x2F;Servlet或者J2EE的相关应用</li>
<li>简单工厂模式等。</li>
</ul>
<h1 id="四种会话跟踪技术："><a href="#四种会话跟踪技术：" class="headerlink" title="四种会话跟踪技术："></a>四种会话跟踪技术：</h1><ul>
<li>cookie,url重写,session,隐藏域。</li>
</ul>
<h1 id="J2EE是技术还是平台还是框架："><a href="#J2EE是技术还是平台还是框架：" class="headerlink" title="J2EE是技术还是平台还是框架："></a>J2EE是技术还是平台还是框架：</h1><ul>
<li>J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。</li>
<li>J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。</li>
</ul>
<h1 id="EJB的角色和三个对象："><a href="#EJB的角色和三个对象：" class="headerlink" title="EJB的角色和三个对象："></a>EJB的角色和三个对象：</h1><ul>
<li>一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性</li>
<li>这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类</li>
</ul>
<h1 id="EJB容器提供的服务："><a href="#EJB容器提供的服务：" class="headerlink" title="EJB容器提供的服务："></a>EJB容器提供的服务：</h1><ul>
<li>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</li>
</ul>
<h1 id="EJB规范规定EJB中禁止的操作有哪些："><a href="#EJB规范规定EJB中禁止的操作有哪些：" class="headerlink" title="EJB规范规定EJB中禁止的操作有哪些："></a>EJB规范规定EJB中禁止的操作有哪些：</h1><ul>
<li>不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，</li>
<li>不能操作awt，</li>
<li>不能实现服务器功能，</li>
<li>不能对静态属生存取，</li>
<li>不能使用IO操作直接存取文件系统，</li>
<li>不能加载本地库.，</li>
<li>不能将this作为变量和返回，</li>
<li>不能循环调用。</li>
</ul>
<h1 id="说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法："><a href="#说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法：" class="headerlink" title="说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法："></a>说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法：</h1><ul>
<li>Session Facade Pattern：使用SessionBean访问EntityBean；</li>
<li>Message Facade Pattern：实现异步调用</li>
<li>EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问；</li>
<li>Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性；</li>
<li>Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性；</li>
<li>Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性；</li>
<li>ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率</li>
<li>项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。</li>
</ul>
<h1 id="UML方面："><a href="#UML方面：" class="headerlink" title="UML方面："></a>UML方面：</h1><ul>
<li>标准建模语言UML</li>
<li>用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。</li>
</ul>
<h1 id="说出一些常用的类，包，接口，请各举5个常用的类："><a href="#说出一些常用的类，包，接口，请各举5个常用的类：" class="headerlink" title="说出一些常用的类，包，接口，请各举5个常用的类："></a>说出一些常用的类，包，接口，请各举5个常用的类：</h1><ul>
<li>常用的类：BufferedReader  BufferedWriter  FileReader  FileWirter  String  Integer；</li>
<li>常用的包：java.lang  java.awt  java.io  java.util  java.sql；</li>
<li>常用的接口：Remote  List  Map  Document  NodeList</li>
</ul>
<h1 id="应用服务器与WEB-SERVER的区别："><a href="#应用服务器与WEB-SERVER的区别：" class="headerlink" title="应用服务器与WEB SERVER的区别："></a>应用服务器与WEB SERVER的区别：</h1><ul>
<li>应用服务器：Weblogic、Tomcat、Jboss； WEB SERVER：IIS、 Apache</li>
</ul>
<h1 id="BS与CS的联系与区别："><a href="#BS与CS的联系与区别：" class="headerlink" title="BS与CS的联系与区别："></a>BS与CS的联系与区别：</h1><ul>
<li>C&#x2F;S是Client&#x2F;Server的缩写</li>
<li>服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server</li>
<li>客户端需要安装专用的客户端软件</li>
<li>B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库</li>
<li>在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。</li>
<li>浏览器通过Ｗeb Server 同数据库进行数据交互。</li>
</ul>
<h4 id="C-S-与-B-S-区别"><a href="#C-S-与-B-S-区别" class="headerlink" title="C&#x2F;S 与 B&#x2F;S 区别"></a>C&#x2F;S 与 B&#x2F;S 区别</h4><ul>
<li>硬件环境不同: C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C&#x2F;S更强的适应范围, 一般只要有操作系统和浏览器就行 </li>
<li>对安全要求不同 ：C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C&#x2F;S 结构适宜. 可以通过B&#x2F;S发布部分可公开信息.B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。</li>
<li>对程序架构不同 ：　C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C&#x2F;S有更高的要求 B&#x2F;S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B&#x2F;S更加成熟. </li>
<li>软件重用不同： C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性好.　B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。</li>
<li>系统维护不同  ：C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级. </li>
<li>处理问题不同 ：C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C&#x2F;S无法作到的. 与操作系统平台关系最小. </li>
<li>用户接口不同： C&#x2F;S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本. </li>
<li>信息流不同 ：　C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B&#x2F;S 信息流向可变化,        B-B B-C B-G等信息、流向的变化, 更像交易中心</li>
</ul>
<h1 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h1><ul>
<li>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址</li>
<li>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</li>
</ul>
<h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理</h1><ul>
<li>Session用于保存每个用户的专用信息</li>
<li>每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID）</li>
<li>她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右)</li>
<li>Session中的信息保存在Web服务器内容中,保存的数据量可大可小</li>
<li>当 Session超时或被关闭时将自动释放保存的数据信息</li>
<li>由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低</li>
<li>对于小量的数据,使用Session对象保存还是一个不错的选择</li>
<li>Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置</li>
<li>如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止</li>
<li>如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期</li>
<li>Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据</li>
<li>由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性</li>
<li>session工作原理<ul>
<li>当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。</li>
<li>然后，服务器开辟一块内存，对应于该Session ID。</li>
<li>服务器再将该Session ID写入浏览器的cookie。</li>
<li>服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。</li>
<li>当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。</li>
<li>然后，服务检查该Session ID所对应的内存是否有效。</li>
<li>如果有效，就读出内存中的值。</li>
<li>如果无效，就建立新的Session。</li>
</ul>
</li>
</ul>
<h1 id="Servlet的生命周期分为3个阶段-和CGI的区别？"><a href="#Servlet的生命周期分为3个阶段-和CGI的区别？" class="headerlink" title="Servlet的生命周期分为3个阶段:?  和CGI的区别？"></a>Servlet的生命周期分为3个阶段:?  和CGI的区别？</h1><ul>
<li>Servlet的生命周期主要由3个过程组成。<ul>
<li>init()方法：服务器初始化servlet。</li>
<li>service()方法：初始化完毕，servlet对象调用该方法响应客户的请求。</li>
<li>destroy()方法：调用该方法消灭servlet对象。</li>
</ul>
</li>
<li>其中，init()方法只在servlet第一次被请求加载的时候被调用一次，当有客户再请求servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。</li>
<li>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li>
</ul>
<h1 id="浏览器页面与T0MCat的交互过程？"><a href="#浏览器页面与T0MCat的交互过程？" class="headerlink" title="浏览器页面与T0MCat的交互过程？"></a>浏览器页面与T0MCat的交互过程？</h1><ul>
<li>当一个JSP页面第一次被访问的时候，JSP引擎将执行以下步骤：<ul>
<li>将JSP页面翻译成一个Servlet，这个Servlet是一个java文件，同时也是一个完整的java程序</li>
<li>JSP引擎调用java编译器对这个Servlet进行编译，得到可执行文件class</li>
<li>JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户端</li>
</ul>
</li>
<li>以上三个步骤仅仅在JSP页面第一次被访问时才会执行，以后的访问速度会因为class文件已经生成而大大提高<br>当JSP引擎接到一个客户端的访问请求时，首先判断请求的JSP页面是否比对应的Servlet新，如果新，对应的JSP需要重新编译。</li>
</ul>
<h1 id="JSP内置对象作用，如何取Cookie的方法"><a href="#JSP内置对象作用，如何取Cookie的方法" class="headerlink" title="JSP内置对象作用，如何取Cookie的方法"></a>JSP内置对象作用，如何取Cookie的方法</h1><ul>
<li>使用request对象的getCookies()方法取cookies</li>
</ul>
<h1 id="JAVA事件有哪些模式？"><a href="#JAVA事件有哪些模式？" class="headerlink" title="JAVA事件有哪些模式？"></a>JAVA事件有哪些模式？</h1><ul>
<li>事件直接驱动模式。它的第一个要求就是性能的要求，需要直接而且快，是必须经常使用的，主要适合于迅速处理 前台的命令，往往是系统架构的重要部分，也是流程控制的主要模式。</li>
<li>监控式事件模式是借助第三者来监控和触发事件，特点是： 有一个观察者置身事外在定期独立运行着。</li>
</ul>
<h1 id="uml三要素"><a href="#uml三要素" class="headerlink" title="uml三要素."></a>uml三要素.</h1><ul>
<li>事物、关系、图</li>
</ul>
<h1 id="Session的具体用法？"><a href="#Session的具体用法？" class="headerlink" title="Session的具体用法？"></a>Session的具体用法？</h1><ul>
<li>Session用来保存每一个用户的专有信息，比如像用户登录验证、购物车。</li>
</ul>
<h1 id="请裂举session、cookie、viewstated的应用范围"><a href="#请裂举session、cookie、viewstated的应用范围" class="headerlink" title="请裂举session、cookie、viewstated的应用范围"></a>请裂举session、cookie、viewstated的应用范围</h1><ul>
<li>Session 服务器端维护， 某个用户活动时间 + 延迟时间（默认20分钟），</li>
<li>Cookie 客户端维护， 程序可指定生命周期，</li>
<li>ViewState 小量数据，一个web页面的生命期</li>
</ul>
<h1 id="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"><a href="#用什么方法使服务器关闭之后，session所保存的信息不会丢失？" class="headerlink" title="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"></a>用什么方法使服务器关闭之后，session所保存的信息不会丢失？</h1><ul>
<li>将session信息保存到数据库中或文件中</li>
</ul>
<h4 id="写客户端Cookie的方式"><a href="#写客户端Cookie的方式" class="headerlink" title="写客户端Cookie的方式"></a>写客户端Cookie的方式</h4><ul>
<li>当用户登陆成功以后，把网站域名、用户名、密码、token、session有效时间全部采用cookie的形式写入到客户端的cookie里面</li>
<li>如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务</li>
<li>当然，如果cookie过期，或者无效，自然就不让用户继续服务了</li>
<li>当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？</li>
</ul>
<h4 id="服务器之间Session数据同步的方式"><a href="#服务器之间Session数据同步的方式" class="headerlink" title="服务器之间Session数据同步的方式"></a>服务器之间Session数据同步的方式</h4><ul>
<li>假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了</li>
<li>缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。</li>
</ul>
<h4 id="利用NFS共享Session数据的方式"><a href="#利用NFS共享Session数据的方式" class="headerlink" title="利用NFS共享Session数据的方式"></a>利用NFS共享Session数据的方式</h4><ul>
<li>其实这个方案和下面的Mysql方案类似，只是存储方式不一样</li>
<li>大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台NFS服务器上的，不论用户访问那太Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了</li>
<li>缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。</li>
</ul>
<h4 id="利用Mysql数据库共享Session数据的方式"><a href="#利用Mysql数据库共享Session数据的方式" class="headerlink" title="利用Mysql数据库共享Session数据的方式"></a>利用Mysql数据库共享Session数据的方式</h4><ul>
<li>这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上</li>
<li>所有Web服务器都来这台Mysql服务器来获取Session数据</li>
<li>缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql数据的方式。</li>
</ul>
<h1 id="使用硬件设备"><a href="#使用硬件设备" class="headerlink" title="使用硬件设备"></a>使用硬件设备</h1><ul>
<li>这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了</li>
<li>目前很多门户网站采用这种方式</li>
<li>缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的。</li>
</ul>
<h1 id="过滤器有哪些作用和用法？"><a href="#过滤器有哪些作用和用法？" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h1><ul>
<li>对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤</li>
<li>当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联</li>
<li>如果有，那么容器将把请求交给过滤器进行处理</li>
<li>在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源</li>
<li>当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常- 见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。</li>
<li>和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain</li>
</ul>
<h1 id="监听器有哪些作用和用法？"><a href="#监听器有哪些作用和用法？" class="headerlink" title="监听器有哪些作用和用法？"></a>监听器有哪些作用和用法？</h1><ul>
<li>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：<ul>
<li>ServletContextListener：对Servlet上下文的创建和销毁进行监听。</li>
<li>ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。</li>
<li>HttpSessionListener：对Session的创建和销毁进行监听。补充：session的销毁有两种情况：1session超时（可以在web.xml中通过&lt;session-config&gt;&#x2F;&lt;session-timeout&gt;标签配置超时时间）；2通过调用session对象的invalidate()方法使session失效。</li>
<li>HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。</li>
<li>ServletRequestListener：对请求对象的初始化和销毁进行监听。</li>
<li>ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</li>
</ul>
</li>
</ul>
<h1 id="实现会话跟踪的技术有哪些？"><a href="#实现会话跟踪的技术有哪些？" class="headerlink" title="实现会话跟踪的技术有哪些？"></a>实现会话跟踪的技术有哪些？</h1><ul>
<li>由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。</li>
</ul>
<h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><ul>
<li>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</li>
</ul>
<h4 id="设置表单隐藏域"><a href="#设置表单隐藏域" class="headerlink" title="设置表单隐藏域"></a>设置表单隐藏域</h4><ul>
<li>将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。</li>
<li>这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul>
<li>cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间</li>
<li>当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份</li>
<li>会话中可以为用户保存信息</li>
<li>会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的</li>
<li>如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪</li>
<li>当然，在使用cookie时要注意几点<ul>
<li>首先不要在cookie中存放敏感信息</li>
<li>其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中</li>
<li>再者浏览器通常只允许一个站点最多存放20个cookie</li>
<li>当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。</li>
</ul>
</li>
</ul>
<h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><ul>
<li>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的</li>
<li>当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession</li>
<li>可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象</li>
<li>与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能</li>
<li>添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</li>
</ul>
<h1 id="JSP-和Servlet-有有什么关系？"><a href="#JSP-和Servlet-有有什么关系？" class="headerlink" title="JSP 和Servlet 有有什么关系？"></a>JSP 和Servlet 有有什么关系？</h1><ul>
<li>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容</li>
<li>JSP本质上是Servlet的一种简易形式， JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成</li>
<li>Servlet和JSP最主要的不同点在于，Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML分离开来</li>
<li>而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp 的文件（有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然，这个说法还是很片面的）</li>
<li>JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</li>
</ul>
<h1 id="常用的Web容器"><a href="#常用的Web容器" class="headerlink" title="常用的Web容器"></a>常用的Web容器</h1><ul>
<li>Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器</li>
<li>选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等</li>
<li>下面是对常用服务器的简介：<ul>
<li>IIS：Microsoft的Web服务器产品为Internet Information Services。IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。</li>
<li>Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。</li>
<li>WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要，范围从简单到高级直到企业级。</li>
<li>WebLogic：BEA WebLogic Server是一种多功能、基于标准的Web应用服务器，为企业构建自己的应用提供了坚实的基础。各种应用开发、部署所有关键性的任务，无论是集成各种系统和数据库，还是提交服务、跨Internet协作，Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发，基于Internet的企业都选择它来开发、部署最佳的应用。BEA WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础，它们以 Internet的容量和速度，在连网的企业之间共享信息、提交服务，实现协作自动化。</li>
<li>Apache：目前Apache仍然是世界上用得最多的Web服务器，市场占有率约为60%左右。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。</li>
<li>Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。TomcatServer实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。</li>
<li>Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</li>
</ul>
</li>
</ul>
<h1 id="MVC原理"><a href="#MVC原理" class="headerlink" title="MVC原理"></a>MVC原理</h1><ul>
<li>MVC是一种程序开发设计模式,它实现了显示模块与功能模块的分离</li>
<li>提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、控制器三层。<ul>
<li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li>
<li>视图(view) 用户与之交互的界面、在web中视图一般由jsp,html组成</li>
<li>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用</li>
</ul>
</li>
</ul>
<h4 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h4><ul>
<li>降低代码耦合性。在MVC模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。</li>
<li>有利于分工合作。在MVC模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。</li>
<li>有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。</li>
</ul>
<h4 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h4><ul>
<li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li>
<li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li>
<li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li>
<li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难。</li>
</ul>
<h1 id="JSP的执行过程"><a href="#JSP的执行过程" class="headerlink" title="JSP的执行过程"></a>JSP的执行过程</h1><ul>
<li>在JSP运行过程中，首先由客户端发出请求，Web服务器接收到请求后，如果是第一次访问某个jsp页面，Web服务器对它进行以下3个操作。<ul>
<li>翻译：由.jsp变为.java,由JSP引擎实现。</li>
<li>编译：由.java变为.class,由 Java编译器实现。</li>
<li>执行：由.class变为.html,用Java虚拟机执行编译文件,然后将执行结果返回给Web服务器，并最终返回给客户端</li>
</ul>
</li>
<li>如果不是第一次访问某个JSP页面，则只执行第三步。所以第一次访问JSP较慢。</li>
</ul>
<h1 id="CGI-Servlet-JSP的比较"><a href="#CGI-Servlet-JSP的比较" class="headerlink" title="CGI&#x2F;Servlet&#x2F;JSP的比较"></a>CGI&#x2F;Servlet&#x2F;JSP的比较</h1><ul>
<li>CGI(Common Gateway Interface)，通用网关接口,是一种根据请求信息动态产生回应内容的技术。通过CGI，Web 服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于每个请求，都要产生一个新的进程进行处理。</li>
<li>Servlet 是在服务器上运行的小程序。在实际运行的时候Java Servlet与Web服务器会融为一体。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。</li>
<li>JSP从本质上说就是Servlet。JSP技术产生于Servlet之后，两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。</li>
<li>与CGI相比，Servlet效率更高。Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet 。</li>
<li>与CGI相比，Servlet更容易使用，功能更强大，具有更好的可移植性，更节省投资。在未来的技术发展过程中，Servlet有可能彻底取代CGI。</li>
</ul>
<h1 id="JSP-ASP-PHP的比较"><a href="#JSP-ASP-PHP的比较" class="headerlink" title="JSP&#x2F;ASP&#x2F;PHP的比较"></a>JSP&#x2F;ASP&#x2F;PHP的比较</h1><ul>
<li>ASP(Active Server Pages),JSP(JavaServer Pages),PHP(Hypertext Preprocessor)是目前主流的三种动态网页语言。</li>
<li>ASP是微软（Microsoft）所开发的一种后台脚本语言，它的语法和Visual BASIC类似，可以像SSI（Server Side Include）那样把后台脚本代码内嵌到HTML页面中。虽然ASP简单易用，但是它自身存在着许多缺陷，最重要的就是安全性问题。</li>
<li>PHP是一种跨平台的服务器端的嵌入式脚本语言。它大量地借用C,Java和Perl语言的语法, 并耦合PHP自己的特性,使WEB开发者能够快速地写出动态产生页面。它支持目前绝大多数数据库。</li>
<li>JSP是一个简化的Servlet，它是由Sun公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML中插入Java程序段和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。</li>
<li>ASP优点:无需编译、易于生成、独立于浏览器、面向对象、与任何ActiveX scripting 语言兼容、源程序码不会外漏。</li>
<li>ASP缺点:<ul>
<li>Windows本身的所有问题都会一成不变的也累加到了它的身上。安全性、稳定性、跨平台性都会因为与NT的捆绑而显现出来。</li>
<li>ASP由于使用了COM组件所以它会变的十分强大，但是这样的强大由于Windows NT系统最初的设计问题而会引发大量的安全问题。只要在这样的组件或是操作中一不注意，那么外部攻击就可以取得相当高的权限而导致网站瘫痪或者数据丢失。</li>
<li>还无法完全实现一些企业级的功能：完全的集群、负载均横。</li>
</ul>
</li>
<li>PHP优点：<ul>
<li>一种能快速学习、跨平台、有良好数据库交互能力的开发语言。</li>
<li>简单轻便，易学易用。</li>
<li>与Apache及其它扩展库结合紧密。</li>
</ul>
</li>
<li>PHP缺点：<ul>
<li>数据库支持的极大变化。</li>
<li>不适合应用于大型电子商务站点。</li>
</ul>
</li>
<li>JSP优点：<ul>
<li>一处编写随处运行。</li>
<li>系统的多台平支持。</li>
<li>强大的的可伸缩性。</li>
<li>多样化和功能强大的开发工具支持。</li>
</ul>
</li>
<li>JSP缺点：<ul>
<li>与ASP一样，Java的一些优势正是它致命的问题所在。</li>
<li>开发速度慢</li>
</ul>
</li>
</ul>
<h1 id="http的响应码"><a href="#http的响应码" class="headerlink" title="http的响应码"></a>http的响应码</h1><ul>
<li>200 - 确定。客户端请求已成功</li>
<li>302 - 临时移动转移，请求的内容已临时移动新的位置</li>
<li>404 - 未找到文件或目录</li>
<li>500 - 服务器内部错误</li>
</ul>
<h1 id="Session域和request域什么区别？"><a href="#Session域和request域什么区别？" class="headerlink" title="Session域和request域什么区别？"></a>Session域和request域什么区别？</h1><ul>
<li>作用域：存放数据，获取数据（传递数据）</li>
<li>有效的作用域：生命周期，作用范围</li>
<li>http<ul>
<li>生命周期 ：一次请求之间</li>
<li>作用范围：所有被请求转发过的servlet都能获取到httpSession:</li>
</ul>
</li>
<li>Servelt<ul>
<li>生命周期：一次会话</li>
<li>作用范围：所有的servlet都可以获取到servletContex:</li>
</ul>
</li>
<li>Request:<ul>
<li>生命周期：从项目开始运行到服务器关闭</li>
<li>作用范围：所有的servlet都可以获取到</li>
</ul>
</li>
<li>作用域如何选用？<ul>
<li>httpServeltRequest：和当前请求有关的信息</li>
<li>httpSession：和当前用户有关的信息</li>
<li>servletContex：访问量比较大，不易更改</li>
</ul>
</li>
</ul>
<h1 id="如何给weblogic定内存的大小？"><a href="#如何给weblogic定内存的大小？" class="headerlink" title="如何给weblogic定内存的大小？"></a>如何给weblogic定内存的大小？</h1><ul>
<li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li>
</ul>
<h1 id="Java-Web-开发的-Model-1-和-Model-2-分别指的是什么？"><a href="#Java-Web-开发的-Model-1-和-Model-2-分别指的是什么？" class="headerlink" title="Java Web 开发的 Model 1 和 Model 2 分别指的是什么？"></a>Java Web 开发的 Model 1 和 Model 2 分别指的是什么？</h1><ul>
<li>Model 1 是以页面为中心的 Java Web 开发，只适合非常小型的应用程序，Model 2是基于 MVC 架构模式的应用，这一点在前文的面试题中已经详细讲解过了</li>
<li>说说什么是框架：框架(framework)是一个框子–》指约束性，也是一个架子–》指支撑性 IT 语境中的框架，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，在此结构上可以根据具体问题扩展、按插更多的组成部分，从而更迅速和方便地架构完整的解决问题的方案。<ul>
<li>框架本身一般不完整到可以解决特定问题，但是可以帮助您快速解决特定问题：没有框架所有的工作都从零开始做，有了框架，为我们提供了一定的功能。我们就可以在框架的基础上开发，极大的解决了生产力。不同的框架，是为了解决不同领域的问题，一定要为了解决问题才去学习框架。</li>
<li>框架天生就是为了扩展而设计的</li>
<li>框架里面可以为后续的组件提供很多辅助性、支撑性的方便易用的实用工具(utilities)，也就是框架时常配套一些帮组解决某类问题的库(libraries）或工具（tools）</li>
</ul>
</li>
</ul>
<h1 id="简单说一下-MVC-框架？"><a href="#简单说一下-MVC-框架？" class="headerlink" title="简单说一下 MVC 框架？"></a>简单说一下 MVC 框架？</h1><ul>
<li>是为了解决传统 MVC 模式(jsp+servlet+javabean)一些问题而出现的框架</li>
<li>传统 MVC 模式模式问题：<ul>
<li>所有的 Servlet 和 Servlet 映射都要配置在 web.xml 中，如果项目太大，web.xml就太庞大并且不能实现模块化管理。</li>
<li>Servlet 的主要功能就是接受参数、调用逻辑、跳转页面，比如像其他字符编码、文件上传等功能也要写在 Servlet 中，不能让 Servlet 主要功能而需要做处理一些特例。</li>
<li>接受参数比较麻烦，(String name &#x3D; request.getParameter(“name”))，不能通过 model 接受，只能单个接收，接收完成后转换封装 model。</li>
<li>跳转页面方式比较单一(forward,redirect)，并且当我们的页面名称发生改变时需要改变 Servlet 源代码。</li>
</ul>
</li>
<li>现在比较常用的 MVC 框架：<ul>
<li>webwork</li>
<li>Struts</li>
<li>Struts2</li>
<li>SpringMVC</li>
</ul>
</li>
</ul>
<h1 id="模式完成分页功能的基本思路是什么？"><a href="#模式完成分页功能的基本思路是什么？" class="headerlink" title="模式完成分页功能的基本思路是什么？"></a>模式完成分页功能的基本思路是什么？</h1><ul>
<li>页面提交页码(第几页)到 Servlet 中</li>
<li>Servlet 接收到页码后，将页码传递给分页工具类(PageBean)</li>
<li>Servlet 中调用 Service 层传入 PageBean 对象</li>
<li>Service 层调用 DAO 层传入 PageBean 对象</li>
<li>Servlet 中得到查询出来的数据，并 setAttrivute 保存</li>
<li>在页面中得到(getAttribute)数据，遍历输出</li>
</ul>
<h1 id="MVC-模式及其优缺点"><a href="#MVC-模式及其优缺点" class="headerlink" title="MVC 模式及其优缺点"></a>MVC 模式及其优缺点</h1><h4 id="MVC-原理"><a href="#MVC-原理" class="headerlink" title="MVC 原理"></a>MVC 原理</h4><ul>
<li>MVC 是一种程序开发设计模式,它实现了显示模块与功能模块的分离</li>
<li>提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度</li>
<li>它主要分模型、视图、控制器三层。<ul>
<li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li>
<li>视图(view) 用户与之交互的界面、在 web 中视图一般由 jsp,html 组成</li>
<li>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用</li>
</ul>
</li>
</ul>
<h4 id="MVC-的优点"><a href="#MVC-的优点" class="headerlink" title="MVC 的优点"></a>MVC 的优点</h4><ul>
<li>降低代码耦合性。在 MVC 模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。</li>
<li>有利于分工合作。在 MVC 模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的 JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。</li>
<li>有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。</li>
</ul>
<h4 id="MVC-的不足之处"><a href="#MVC-的不足之处" class="headerlink" title="MVC 的不足之处"></a>MVC 的不足之处</h4><ul>
<li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循 MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li>
<li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li>
<li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li>
<li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应 MVC 需要和建立分离的部件的代价是很高的，从而造成 MVC 使用的困难。</li>
</ul>
<h1 id="说说你对容器的理解"><a href="#说说你对容器的理解" class="headerlink" title="说说你对容器的理解"></a>说说你对容器的理解</h1><ul>
<li>容器也是 java 程序，它的主要作用是为应用程序提供运行环境</li>
<li>容器用来接管安全性、并发性、事务处理、交换到辅助存储器和其它服务的责任</li>
<li>以 tomcat 为例：Tomcat 是一个后台服务进程，其它的 servlet（相当于 DLL）是在 Tomcat容器内运行,Broswer 只与 Tomcat 通迅; Tomcat 接受 browser 的请求，经过一系列动作（如果是静态网页，那么装载，按 http 协议形成响应流;如果是动态的如 JSP，那就要调用 JDK 中的 servlet.jsp 接口，解释形成静态网页，按 http 协议生成响应流发送回browser）后，形成静态网页，返回响应。</li>
</ul>
<h1 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h1><ul>
<li>同源策略&#x2F;SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略</li>
<li>如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源</li>
</ul>
<h1 id="什么是-JsonP？"><a href="#什么是-JsonP？" class="headerlink" title="什么是 JsonP？"></a>什么是 JsonP？</h1><ul>
<li>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</li>
</ul>
<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><ul>
<li>跨域是指一个域（网站）下的文档或脚本试图去请求另一个域（网站）下的资源。</li>
</ul>
<h1 id="怎么防止重复提交"><a href="#怎么防止重复提交" class="headerlink" title="怎么防止重复提交"></a>怎么防止重复提交</h1><ul>
<li>禁掉提交按钮。表单提交后使用 Javascript 使提交按钮 disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把 Javascript 给禁止掉，这种方法就无效了。</li>
<li>Post&#x2F;Redirect&#x2F;Get 模式。在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按 F5 导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</li>
<li>在 session 中存放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。</li>
<li>在数据库里添加约束。在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。</li>
</ul>
<h1 id="阐述-Session-加载实体对象的过程。"><a href="#阐述-Session-加载实体对象的过程。" class="headerlink" title="阐述 Session 加载实体对象的过程。"></a>阐述 Session 加载实体对象的过程。</h1><ul>
<li>Session 加载实体对象的步骤是：<ul>
<li>Session 在调用数据库查询功能之前, 首先会在缓存中进行查询, 在一级缓存中, 通过实体类型和主键进行查找, 如果一级缓存查找命中且数据状态合法, 则直接返回</li>
<li>如果一级缓存没有命中, 接下来 Session 会在当前 NonExists 记录(相当于一个查询黑名单, 如果出现重复的无效查询可以迅速判断, 从而提升性能)中进行查找, 如果NonExists 中存在同样的查询条件,则返回 null</li>
<li>对于 load 方法, 如果一级缓存查询失败则查询二级缓存, 如果二级缓存命中则直接返回</li>
<li>如果之前的查询都未命中, 则发出 SQL 语句, 如果查询未发现对应记录则将此次查询添加到 Session 的 NonExists 中加以记录, 并返回 null</li>
<li>根据映射配置和 SQL 语句得到 ResultSet,并创建对应的实体对象</li>
<li>将对象纳入 Session(一级缓存)管理</li>
<li>执行拦截器的 onLoad 方法(如果有对应的拦截器)</li>
<li>将数据对象纳入二级缓存</li>
<li>返回数据对象</li>
</ul>
</li>
</ul>
<h1 id="Servlet-3-中的异步处理指的是什么？"><a href="#Servlet-3-中的异步处理指的是什么？" class="headerlink" title="Servlet 3 中的异步处理指的是什么？"></a>Servlet 3 中的异步处理指的是什么？</h1><ul>
<li>在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交给 Executor（如果不清楚请查看前文关于多线程和线程池的部分）并立即返回即可。</li>
</ul>
<h1 id="过滤器有哪些作用和用法？-1"><a href="#过滤器有哪些作用和用法？-1" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h1><ul>
<li>Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在Servlet 2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web 容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果<br>有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。</li>
<li>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT等。</li>
<li>和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain</li>
</ul>
<h1 id="静态网页和动态网页的联系和区别"><a href="#静态网页和动态网页的联系和区别" class="headerlink" title="静态网页和动态网页的联系和区别"></a>静态网页和动态网页的联系和区别</h1><ul>
<li>联系：<ul>
<li>静态网页是网站建设的基础，静态网页和动态网页都要使用到 HTMl 语言。  </li>
<li>静态网页是相对于动态网页而言，指没有后台数据库、不含程序和不可交互的网页、是标准的 HTML 文件，它的文件扩展名是.htm 或.html。你编的是什么它显示的就是什么、不会有任何改变。</li>
<li>静态网页和动态网页之间并不矛盾，为了网站适应搜索引擎检索的需要，动态网站可以采用静动结合的原则，适合采用动态网页的地方用动态网页，如果必要使用静态网页，则可以考虑用静态网页的方法来实现，在同一个网站上，动态网页内容和静态网页内容同时存在也是很常见的事情。</li>
</ul>
</li>
<li>区别：<ul>
<li>程序是否在服务器端运行，是重要标志。在服务器端运行的程序、网页、组件，属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如 ASP、PHP、JSP、ASP.net、CGI 等。运行于客户端的程序、网页、插件、组件，属于静态网页，例如 html页、Flash、javascript、VBscript 等等，它们是永远不变的。</li>
<li>编程技术不同。静态网页和动态网页主要根据网页制作的语言来区分。静态网页使用语言：HTML。 动态网页使用语言：HTML＋ASP 或 HTML＋PHP 或 HTML＋JSP 等其它网站动态语言。</li>
<li>被搜索引擎收录情况不同。由于编程技术不容，静态网页是纯粹 HTML 格式的网页，页面内容稳定，不论是网页是否被访问，页面都被保存在网站服务器上，很容易被搜索引擎收录。而动态网页的内容是当用户点击请求时才从数据库中调出返回给用户一个网页的内容，并不是存放在服务器上的独立文件，相比较于静态网页而言，动态网页很难被搜索引擎收录。</li>
<li>用户访问速度不同。用户访问动态网页时，网页在获得搜索指令后经过数据库的调查匹配，再将与指令相符的内容传递给服务器，通过服务器的编译将网页编译成标准的 HTML 代码，从而传递给用户浏览器，多个读取过程大大降低了用户的访问速度。而静态网页不同，由于网页内容直接存取在服务器上，省去了服务器的编译过程，用户访问网页速度很快。</li>
<li>制作和后期维护工作量不同。动态网页的设计以数据库技术为基础，可以实现多种功能，降低了网站维护的工作量。而静态网页由于没有数据库的支持，网页内容更改时需要直接修改代码，在网站内容制作和维护中，所需的工作量更大。动态网页与静态网页各有特点，网站设计师在网页设计时，主要根据网站的功能需求和网站内容多少选择不同网页。如，网站包含信息量太大时，就需要选择动态网页，反之，则选择静态网页。</li>
</ul>
</li>
</ul>
<h1 id="Session-的基本原理是什么？"><a href="#Session-的基本原理是什么？" class="headerlink" title="Session 的基本原理是什么？"></a>Session 的基本原理是什么？</h1><ul>
<li>Session 对象的原理在于，服务器可以为客户端创建并维护一个所谓的 Session 对象，用于存放数据。在创建 Session 对象的同时，服务器将会为该 Session 对象产生一个唯一编号，这个编号称之为 SessionID，服务器以 Cookie 的方式将 SessionID 存放在客户端。当浏览器再次访问该服务器时，会将 SessionID 作为 Cookie 信息带到服务器，服务器可以通过该SessionID 检索到以前的 Session 对象，并对其进行访问。需要注意的是，此时的 Cookie 中仅仅保存了一个 SessionID，而相对较多的会话数据保存在服务器端对应的 Session 对象中，由服务器来统一维护，这样一定程度保证了会话数据安全性，但增加了服务器端的内存开销。</li>
<li>存放在客户端的用于保存 SessionID 的 Cookie 会在浏览器关闭时清除。我们把用户打开一个浏览器访问某个应用开始，到关闭浏览器为止交互过程称为一个 “会话”。在一个“会话”过程中，可能会向同一个应用发出了多次请求，这些请求将共享一个 Session 对象，因为这些请求携带了相同的 SessionID 信息。Session 对象的正常使用要依赖于 Cookie。如果考虑到客户端浏览器可能出于安全的考虑禁用了 Cookie，应该使用 URL 重写的方式使 Session 在客户端禁用 Cookie 的情况下继续生效。</li>
</ul>
<h1 id="谈谈对-XML-的理解？说明-Web-应用中-Web-xml-文件的作用？"><a href="#谈谈对-XML-的理解？说明-Web-应用中-Web-xml-文件的作用？" class="headerlink" title="谈谈对 XML 的理解？说明 Web 应用中 Web.xml 文件的作用？"></a>谈谈对 XML 的理解？说明 Web 应用中 Web.xml 文件的作用？</h1><ul>
<li>XML（Extensible Markup Language）即可扩展标记语言，它与 HTML 一样，都是SGML(Standard Generalized Markup Language,标准通用标记语言)。Xml 是 Internet 环境中跨平台的，依赖于内容的技术，是当前处理结构化文档信息的有力工具。扩展标记语言 XML 是一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式建立，虽然 XML 占用的空间比二进制数据要占用更多的空间，但 XML 极其简单易于掌握和使用。</li>
<li>web.xml 的作用是配置欢迎页，servlet，filter，listener 等的。</li>
</ul>
<h1 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h1><ul>
<li>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</li>
</ul>
<h1 id="如何查看在-weblogic-中已经发布的-EJB"><a href="#如何查看在-weblogic-中已经发布的-EJB" class="headerlink" title="如何查看在 weblogic 中已经发布的 EJB?"></a>如何查看在 weblogic 中已经发布的 EJB?</h1><ul>
<li>可以使用管理控制台，在它的 Deployment 中可以查看所有已发布的 EJB</li>
</ul>
<h1 id="EJB-基于哪些技术实现的？说出-SessionBean-和-EntityBean-区别，StatefulBean-和StatelessBean-区别。"><a href="#EJB-基于哪些技术实现的？说出-SessionBean-和-EntityBean-区别，StatefulBean-和StatelessBean-区别。" class="headerlink" title="EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和StatelessBean 区别。"></a>EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和StatelessBean 区别。</h1><ul>
<li>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技术实现。</li>
<li>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。</li>
<li>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。</li>
<li>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。</li>
<li>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的Session Bean 都可以将系统逻辑放在 method 之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。</li>
</ul>
<h1 id="EJB-包括（SessionBean-EntityBean）说出他们的生命周期，及如何管理事务的？"><a href="#EJB-包括（SessionBean-EntityBean）说出他们的生命周期，及如何管理事务的？" class="headerlink" title="EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？"></a>EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？</h1><ul>
<li>SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立一个 Bean 的实例时，EJB 容器不一定要创建一个新的 Bean 的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个 Stateful Session Bean 时，容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用StatefulSession Bean 的方法时容器会把调用分派到与此客户机相关联的 Bean 实例。</li>
<li>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，Entity beans 就一直存活。而不是按照应用程序或者服务进程来说的。即使 EJB 容器崩溃了，Entity beans 也是存活的。Entity Beans 生命周期能够被容器或者 Beans 自己管理。</li>
<li>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems的 Transaction Service（JTS）、Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。</li>
</ul>
<h1 id="EJB-的激活机制"><a href="#EJB-的激活机制" class="headerlink" title="EJB 的激活机制"></a>EJB 的激活机制</h1><ul>
<li>以Stateful Session Bean 为例：其 Cache大小决定了内存中可以同时存在的Bean实例的数量，根据 MRU 或 NRU 算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某个 EJB 实例业务方法时，如果对应 EJB Object 发现自己没有绑定对应的 Bean 实例则从其去激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对应的 ejbActive 和 ejbPassivate 方法。</li>
</ul>
<h1 id="EJB-的几种类型"><a href="#EJB-的几种类型" class="headerlink" title="EJB 的几种类型"></a>EJB 的几种类型</h1><ul>
<li>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean</li>
<li>会话 Bean 又可分为有状态（Stateful）和无状态（Stateless）两种</li>
<li>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种</li>
</ul>
<h1 id="客服端调用-EJB-对象的几个基本步骤"><a href="#客服端调用-EJB-对象的几个基本步骤" class="headerlink" title="客服端调用 EJB 对象的几个基本步骤"></a>客服端调用 EJB 对象的几个基本步骤</h1><ul>
<li>设置 JNDI 服务工厂以及 JNDI 服务地址系统属性，查找 Home 接口，从 Home 接口调用 Create方法创建 Remote 接口，通过 Remote 接口调用其业务方法</li>
</ul>
<h1 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h1><ul>
<li>实现跨域有以下几种方案：<ul>
<li>服务器端运行跨域 设置 CORS 等于 *；</li>
<li>在单个接口使用注解 @CrossOrigin 运行跨域；</li>
<li>使用 jsonp 跨域；</li>
</ul>
</li>
</ul>
<h1 id="如何避免-SQL-注入？"><a href="#如何避免-SQL-注入？" class="headerlink" title="如何避免 SQL 注入？"></a>如何避免 SQL 注入？</h1><ul>
<li>使用预处理 PreparedStatement。</li>
<li>使用正则表达式过滤掉字符中的特殊字符。</li>
</ul>
<h1 id="什么是-XSS-攻击，如何避免？"><a href="#什么是-XSS-攻击，如何避免？" class="headerlink" title="什么是 XSS 攻击，如何避免？"></a>什么是 XSS 攻击，如何避免？</h1><ul>
<li>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</li>
<li>预防 XSS 的核心是必须对输入的数据做过滤处理。</li>
</ul>
<h1 id="什么是-CSRF-攻击，如何避免？"><a href="#什么是-CSRF-攻击，如何避免？" class="headerlink" title="什么是 CSRF 攻击，如何避免？"></a>什么是 CSRF 攻击，如何避免？</h1><ul>
<li>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</li>
<li>防御手段：<ul>
<li>验证请求来源地址；</li>
<li>关键操作添加验证码；</li>
<li>在请求地址添加 token 并验证。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/publishes/22829df8f04f.html</url>
    <content><![CDATA[<h1 id="获得Class对象的⽅式"><a href="#获得Class对象的⽅式" class="headerlink" title="获得Class对象的⽅式"></a>获得Class对象的⽅式</h1><ul>
<li>静态类的.class语法：GuideUtil.class</li>
<li>普通类对象的getClass()⽅法：new Test().getClass()</li>
<li>通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”);</li>
<li>对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE</li>
</ul>
<h1 id="在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>在 Java 中，为什么不允许从静态方法中访问非静态变量？</h1><ul>
<li>因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联</li>
</ul>
<h1 id="在-Java-中，什么时候用重载，什么时候用重写？"><a href="#在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="在 Java 中，什么时候用重载，什么时候用重写？"></a>在 Java 中，什么时候用重载，什么时候用重写？</h1><ul>
<li>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding）</li>
<li>而重载（overloading）是用不同的输入做同一件事</li>
<li>在 Java 中，重载的方法签名不同，而重写并不是。</li>
</ul>
<h1 id="举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>举例说明什么情况下会更倾向于使用抽象类而不是接口？</h1><ul>
<li>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求</li>
<li>在 Java 中，你只能继承一个类，但可以实现多个接口</li>
<li>所以一旦你继承了一个类，你就失去了继承其他类的机会了。</li>
<li>接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable(注：这里的意思是指如果把 Runnable 等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</li>
<li>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</li>
<li>如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择</li>
<li>有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</li>
</ul>
<h1 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h1><ul>
<li>调用该访问返回一个以字符串指定类名的类的对象。</li>
</ul>
<h1 id="Jdo是什么"><a href="#Jdo是什么" class="headerlink" title="Jdo是什么?"></a>Jdo是什么?</h1><ul>
<li>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API</li>
<li>JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）</li>
<li>这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上</li>
<li>另外，JDO很灵活，因为它可以在任何数据底层上运行</li>
<li>JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。</li>
</ul>
<h1 id="HashMap-，HashTable-区别"><a href="#HashMap-，HashTable-区别" class="headerlink" title="HashMap ，HashTable 区别"></a>HashMap ，HashTable 区别</h1><ul>
<li>默认容量不同。扩容不同</li>
<li>线程安全性，HashTable 安全</li>
<li>效率不同 HashTable 要慢因为加锁</li>
</ul>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul>
<li>数组 + 链表方式存储</li>
<li>默认容量：11(质数 为宜)</li>
<li>put:<ul>
<li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li>
<li>若在链表中找到了，则替换旧值，若未找到则继续</li>
<li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li>
<li>将新元素加到链表头部</li>
<li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。</li>
</ul>
</li>
</ul>
<h1 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h1><ul>
<li>默认的负载因子大小为0.75</li>
<li>也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组来重新调整map的大小，并将原来的对象放入新的bucket数组中。</li>
<li>这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</li>
</ul>
<h1 id="EJB与JavaBean的区别？"><a href="#EJB与JavaBean的区别？" class="headerlink" title="EJB与JavaBean的区别？"></a>EJB与JavaBean的区别？</h1><ul>
<li>Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于JavaBean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器。另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。</li>
<li>Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。</li>
</ul>
<h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</li>
<li>下面列出了使用封装的一些好处：<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交互提高模块化</li>
</ul>
</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul>
<li>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</li>
</ul>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul>
<li>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</li>
</ul>
<h1 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h1><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul>
<li>修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。</li>
</ul>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul>
<li>在异常处理时提供 finally 块来执行任何清除操作</li>
<li>如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</li>
</ul>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ul>
<li>方法名</li>
<li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</li>
<li>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</li>
</ul>
<h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h4 id="override（重写）"><a href="#override（重写）" class="headerlink" title="override（重写）"></a>override（重写）</h4><ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为final不能被重写。</li>
</ul>
<h4 id="overload（重载）"><a href="#overload（重载）" class="headerlink" title="overload（重载）"></a>overload（重载）</h4><ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
<h1 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h1><ul>
<li>接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。</li>
<li>还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。</li>
</ul>
<h1 id="Java1-7与1-8-1-9-10-新特性"><a href="#Java1-7与1-8-1-9-10-新特性" class="headerlink" title="Java1.7与1.8,1.9,10 新特性"></a>Java1.7与1.8,1.9,10 新特性</h1><h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4><ul>
<li>switch中可以使用字串了</li>
<li>运用List tempList &#x3D; new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断</li>
<li>语法上支持集合，而不一定是数组</li>
<li>新增一些取环境信息的工具方法</li>
<li>Boolean类型反转，空指针安全,参与位运算</li>
<li>两个char间的equals</li>
<li>安全的加减乘除</li>
<li>map集合支持并发请求，且可以写成 Map map &#x3D; {name:”xxx”,age:18};</li>
</ul>
<h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><ul>
<li>允许在接口中有默认方法实现</li>
<li>Lambda表达式</li>
<li>函数式接口</li>
<li>方法和构造函数引用</li>
<li>Lambda的范围</li>
<li>内置函数式接口</li>
<li>Streams</li>
<li>Parallel Streams</li>
<li>Map</li>
<li>时间日期API</li>
<li>Annotations</li>
</ul>
<h4 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h4><ul>
<li>Jigsaw 项目;模块化源码</li>
<li>简化进程API</li>
<li>轻量级 JSON API</li>
<li>钱和货币的API</li>
<li>改善锁争用机制</li>
<li>代码分段缓存</li>
<li>智能Java编译, 第二阶段</li>
<li>HTTP 2.0客户端</li>
<li>Kulla计划: Java的REPL实现</li>
</ul>
<h1 id="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"><a href="#解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI" class="headerlink" title="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"></a>解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI</h1><ul>
<li>web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。</li>
<li>EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。</li>
<li>JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</li>
<li>JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</li>
<li>JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</li>
<li>JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</li>
<li>RMI&#x2F;IIOP:（Remote Method Invocation &#x2F;internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。</li>
</ul>
<h1 id="Class类的作用？生成Class对象的方法有哪些？"><a href="#Class类的作用？生成Class对象的方法有哪些？" class="headerlink" title="Class类的作用？生成Class对象的方法有哪些？"></a>Class类的作用？生成Class对象的方法有哪些？</h1><ul>
<li>Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类</li>
<li>Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口</li>
<li>方法示例<ul>
<li>getClass()</li>
<li>getSuperClass()</li>
<li>.class</li>
<li>.TYPE</li>
</ul>
</li>
</ul>
<h1 id="序列化的定义、实现和注意事项"><a href="#序列化的定义、实现和注意事项" class="headerlink" title="序列化的定义、实现和注意事项"></a>序列化的定义、实现和注意事项</h1><ul>
<li>想把一个对象写在硬盘上或者网络上，对其进行序列化，把他序列化成为一个字节流。</li>
<li>实现和注意事项：<ul>
<li>实现接口Serializable Serializable接口中没有任何的方法，实现该接口的类不需要实现额外的方法。</li>
<li>如果对象中的某个属性是对象类型，必须也实现Serializable接口才可以，序列化对静态变量无效</li>
<li>如果不希望某个属性参与序列化，不是将其static，而是transient</li>
</ul>
</li>
<li>串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存</li>
<li>序列化版本不兼容</li>
</ul>
<h1 id="java-sql-Date和java-util-Date的联系和区别"><a href="#java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="java.sql.Date和java.util.Date的联系和区别"></a>java.sql.Date和java.util.Date的联系和区别</h1><ul>
<li>java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</li>
<li>JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002&#x2F;05&#x2F;22 5:00:57 PM的字段，读取日期时得到的是2002&#x2F;05&#x2F;22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.sql.Timestamp类比java.util.Date类精确度要高。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用…</li>
<li>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。</li>
</ul>
<h1 id="String-s-new-String-“xyz”-创建几个String-Object"><a href="#String-s-new-String-“xyz”-创建几个String-Object" class="headerlink" title="String s &#x3D; new String(“xyz”);创建几个String Object?"></a>String s &#x3D; new String(“xyz”);创建几个String Object?</h1><ul>
<li>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个</li>
<li>New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象</li>
<li>如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</li>
</ul>
<h1 id="String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？"><a href="#String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？" class="headerlink" title="String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？"></a>String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？</h1><ul>
<li>没有改变。</li>
<li>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</li>
</ul>
<h1 id="基本数据类型有哪些"><a href="#基本数据类型有哪些" class="headerlink" title="基本数据类型有哪些"></a>基本数据类型有哪些</h1><ul>
<li>byte、short、char、int、long、float、double、boolean</li>
</ul>
<h1 id="String、StringBuffer、StringBuilder区别与联系"><a href="#String、StringBuffer、StringBuilder区别与联系" class="headerlink" title="String、StringBuffer、StringBuilder区别与联系"></a>String、StringBuffer、StringBuilder区别与联系</h1><ul>
<li>String类是字符序列不可变的类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。</li>
<li>StringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setChartAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String</li>
<li>JDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder</li>
</ul>
<h1 id="String类为什么是final的"><a href="#String类为什么是final的" class="headerlink" title="String类为什么是final的"></a>String类为什么是final的</h1><ul>
<li>为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。</li>
<li>为了安全。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的， 和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的， 这不就成了核心病毒了么？</li>
<li>不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性， 如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点；</li>
</ul>
<h1 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h1><ul>
<li>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</li>
<li>int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</li>
<li>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</li>
<li>Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</li>
</ul>
<h1 id="异常处理中throws和throw的区别"><a href="#异常处理中throws和throw的区别" class="headerlink" title="异常处理中throws和throw的区别"></a>异常处理中throws和throw的区别</h1><ul>
<li>作用不同：<ul>
<li>throw用于程序员自行产生并抛出异常；</li>
<li>throws用于声明在该方法内抛出了异常</li>
</ul>
</li>
<li>使用的位置不同：<ul>
<li>throw位于方法体内部，可以作为单独语句使用；</li>
<li>throws必须跟在方法参数列表的后面，不能单独使用。</li>
</ul>
</li>
<li>内容不同：<ul>
<li>throw抛出一个异常对象，且只能是一个；</li>
<li>throws后面跟异常类，而且可以有多个。</li>
</ul>
</li>
</ul>
<h1 id="Java异常处理try-catch-finally的执行过程"><a href="#Java异常处理try-catch-finally的执行过程" class="headerlink" title="Java异常处理try-catch-finally的执行过程"></a>Java异常处理try-catch-finally的执行过程</h1><ul>
<li>try-catch-finally程序块的执行流程以及执行结果比较复杂。</li>
<li>基本执行过程如下：<ul>
<li>程序首先执行可能发生异常的try语句块。</li>
<li>如果try语句没有出现异常则执行完后跳至finally语句块执行；</li>
<li>如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。</li>
<li>catch语句块可以有多个，分别捕获不同类型的异常。</li>
<li>catch语句块执行完后程序会继续执行finally语句块。</li>
</ul>
</li>
<li>finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。需要注意的是即使try和catch块中存在return语句，finally语句也会执行，是在执行完finally语句后再通过return退出。</li>
</ul>
<h1 id="运行时异常与受检异常有何异同"><a href="#运行时异常与受检异常有何异同" class="headerlink" title="运行时异常与受检异常有何异同"></a>运行时异常与受检异常有何异同</h1><ul>
<li>运行时异常：包括RuntimeaException及其所有子类。不要求程序必须对它们作出处理，比如InputMismatchException、ArithmeticException、NullPointerException等。即使没有显示使用try-catch或throws进行处理，仍旧可以进行编译和运行(其实是JVM隐式的使用try-catch或throws进行处理)。如果运行时发生异常，会输出异常的堆栈信息并中止程序执行。</li>
<li>Checked异常（非运行时异常）：除了运行时异常外的其他异常类都是Checked异常，程序必须捕获或者声明抛出这种异常，否则出现编译错误，无法通过编译。处理方式包括两种：通过try-catch捕获异常，通过throws声明抛出异常从而交给上一级调用方法处理。</li>
</ul>
<h1 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h1><ul>
<li>Error类，表示仅靠程序本身无法恢复的严重错误，比如说内存溢出、动态链接异常、虚拟机错误。应用程序不应该抛出这种类型的对象。假如出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。所以在进行程序设计时，应该更关注Exception类。</li>
<li>Exception类，由Java应用程序抛出和处理的非严重错误，比如所需文件没有找到、零作除数，数组下标越界等。它的各种不同子类分别对应不同类型异常。可分为两类：Checked异常和Runtime异常</li>
</ul>
<h1 id="和equals的区别和联系"><a href="#和equals的区别和联系" class="headerlink" title="&#x3D;&#x3D;和equals的区别和联系"></a>&#x3D;&#x3D;和equals的区别和联系</h1><ul>
<li>“&#x3D;&#x3D;”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</li>
<li>“&#x3D;&#x3D;”使用情况如下：<ul>
<li>基本类型，比较的是值</li>
<li>引用类型，比较的是地址</li>
<li>不能比较没有父子关系的两个对象</li>
</ul>
</li>
<li>equals()方法使用如下：<ul>
<li>系统类一般已经覆盖了equals()，比较的是内容。</li>
<li>用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this &#x3D;&#x3D; obj);）</li>
<li>用户自定义类需要覆盖父类的equals()</li>
</ul>
</li>
<li>注意：Object的&#x3D;&#x3D;和equals比较的都是地址，作用相同</li>
</ul>
<h1 id="继承条件下构造方法的执行过程"><a href="#继承条件下构造方法的执行过程" class="headerlink" title="继承条件下构造方法的执行过程"></a>继承条件下构造方法的执行过程</h1><ul>
<li>继承条件下构造方法的调用规则如下：<ul>
<li>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</li>
<li>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li>
<li>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</li>
</ul>
</li>
<li>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li>
</ul>
<h1 id="权限修饰符的区别"><a href="#权限修饰符的区别" class="headerlink" title="权限修饰符的区别"></a>权限修饰符的区别</h1><ul>
<li>类的访问权限只有两种<ul>
<li>public 公共的   可被同一项目中所有的类访问。 (必须与文件名同名)</li>
<li>default 默认的  可被同一个包中的类访问。</li>
</ul>
</li>
<li>成员（成员变量或成员方法）访问权限共有四种：<ul>
<li>public 公共的  可以被项目中所有的类访问。(项目可见性)</li>
<li>protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）</li>
<li>default 默认的被这个类本身访问；被同一个包中的类访问。（包可见性）</li>
<li>private 私有的只能被这个类本身访问。（类可见性）</li>
</ul>
</li>
</ul>
<h1 id="final和abstract关键字的作用"><a href="#final和abstract关键字的作用" class="headerlink" title="final和abstract关键字的作用"></a>final和abstract关键字的作用</h1><ul>
<li>final和abstract是功能相反的两个关键字，可以对比记忆</li>
<li>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</li>
<li>final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</li>
<li>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li>
</ul>
<h1 id="static关键字的作用（修饰变量、方法、代码块）"><a href="#static关键字的作用（修饰变量、方法、代码块）" class="headerlink" title="static关键字的作用（修饰变量、方法、代码块）"></a>static关键字的作用（修饰变量、方法、代码块）</h1><ul>
<li>static可以修饰变量、方法、代码块和内部类</li>
<li>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</li>
<li>static变量和非static变量的区别(都是成员变量，不是局部变量)<ul>
<li>在内存中份数不同<ul>
<li>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</li>
<li>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</li>
</ul>
</li>
<li>在内存中存放的位置不同<ul>
<li>静态变量存在方法区中，实例变量存在堆内存中</li>
</ul>
</li>
<li>访问的方式不同<ul>
<li>实例变量： 对象名.变量名  stu1.name&#x3D;”小明明”;</li>
<li>静态变量：对象名.变量名  stu1.schoolName&#x3D;”西二旗小学”; 不推荐如此使用</li>
<li>类名.变量名  Student.schoolName&#x3D;”东三旗小学”; 推荐使用</li>
</ul>
</li>
<li>在内存中分配空间的时间不同<ul>
<li>实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候</li>
<li>Student.schoolName&#x3D;”东三旗小学”;或者Student stu1 &#x3D; new Student(“小明”,”男”,20,98);</li>
<li>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</li>
<li>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</li>
<li>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="this和super关键字的作用"><a href="#this和super关键字的作用" class="headerlink" title="this和super关键字的作用"></a>this和super关键字的作用</h1><ul>
<li>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题</li>
<li>this可以调用成员变量，不能调用局部变量</li>
<li>this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句，而且在静态方法当中不允许出现this关键字。</li>
<li>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</li>
<li>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</li>
</ul>
<h1 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h1><ul>
<li>面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li>
<li>封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</li>
<li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</li>
</ul>
<h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><ul>
<li>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</li>
<li>类和对象好比图纸和实物的关系，模具和铸件的关系。</li>
</ul>
<h1 id="可变参数的作用和特点"><a href="#可变参数的作用和特点" class="headerlink" title="可变参数的作用和特点"></a>可变参数的作用和特点</h1><ul>
<li>可变参数<ul>
<li>可变参数的形式  …</li>
<li>可变参数只能是方法的形参</li>
<li>可变参数对应的实参可以0,1,2…..个，也可以是一个数组</li>
<li>在可变参数的方法中，将可变参数当做数组来处理</li>
<li>可变参数最多有一个，只能是最后一个</li>
<li>可变参数好处：方便  简单  减少重载方法的数量</li>
<li>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</li>
</ul>
</li>
<li>数组做形参和可变参数做形参联系和区别</li>
<li>联系：<br>  -实参都可以是数组；2.方法体中，可变参数当做数组来处理</li>
<li>区别：<ul>
<li>个数不同	可变参数只能有一个数组参数可以多个</li>
<li>位置不同	可变参数只能是最后一个	数组参数位置任意</li>
<li>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</li>
</ul>
</li>
</ul>
<h1 id="递归的定义和优缺点"><a href="#递归的定义和优缺点" class="headerlink" title="递归的定义和优缺点"></a>递归的定义和优缺点</h1><ul>
<li>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</li>
<li>递归算法解决问题的特点：<ul>
<li>递归就是在过程或函数里调用自身。</li>
<li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
<li>递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</li>
<li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</li>
</ul>
</li>
</ul>
<h1 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h1><ul>
<li>break: 结束当前循环并退出当前循环体。</li>
<li>break还可以退出switch语句</li>
<li>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。</li>
</ul>
<h1 id="while和do-while循环的区别"><a href="#while和do-while循环的区别" class="headerlink" title="while和do-while循环的区别"></a>while和do-while循环的区别</h1><ul>
<li>while先判断后执行，第一次判断为false,循环体一次都不执行</li>
<li>do while先执行 后判断，最少执行1次。</li>
<li>如果while循环第一次判断为true, 则两种循环没有区别。</li>
</ul>
<h1 id="用最有效率的方法算出2乘以8等于多少"><a href="#用最有效率的方法算出2乘以8等于多少" class="headerlink" title="用最有效率的方法算出2乘以8等于多少"></a>用最有效率的方法算出2乘以8等于多少</h1><ul>
<li>使用位运算来实现效率最高</li>
<li>位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数</li>
<li>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高</li>
<li>所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</li>
</ul>
<h1 id="和-的区别和联系，-和-的区别和联系"><a href="#和-的区别和联系，-和-的区别和联系" class="headerlink" title="&amp;和&amp;&amp;的区别和联系，|和||的区别和联系"></a>&amp;和&amp;&amp;的区别和联系，|和||的区别和联系</h1><ul>
<li>&amp;和&amp;&amp;的联系(共同点)：<ul>
<li>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</li>
<li>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</li>
<li>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</li>
<li>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li>
<li>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li>
<li>表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</li>
</ul>
</li>
<li>&amp;和&amp;&amp;的区别(不同点)<ul>
<li>&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。</li>
<li>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</li>
<li>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</li>
<li>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</li>
<li>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</li>
</ul>
</li>
<li>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</li>
</ul>
<h1 id="i-和-i的异同之处"><a href="#i-和-i的异同之处" class="headerlink" title="i++和++i的异同之处"></a>i++和++i的异同之处</h1><ul>
<li>共同点：<ul>
<li>i++和++i都是变量自增1，都等价于i&#x3D;i+1</li>
<li>如果i++,++i是一条单独的语句，两者没有任何区别</li>
<li>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</li>
</ul>
</li>
<li>不同点：<ul>
<li>如果i++,++i不是一条单独的语句，他们就有区别</li>
<li>i++ ：先运算后增1。如：int x&#x3D;5;</li>
<li>int y&#x3D;x++;</li>
<li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li>
<li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;5++i ： 先增1后运算。如： </li>
<li>int x&#x3D;5;</li>
<li>int y&#x3D;++x;</li>
<li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li>
<li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;6334.</li>
</ul>
</li>
</ul>
<h1 id="JDK-JRE-JVM三者关系概括如下："><a href="#JDK-JRE-JVM三者关系概括如下：" class="headerlink" title="JDK,JRE,JVM三者关系概括如下："></a>JDK,JRE,JVM三者关系概括如下：</h1><ul>
<li>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE</li>
<li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了</li>
<li>JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li>
</ul>
<h1 id="Java跨平台原理"><a href="#Java跨平台原理" class="headerlink" title="Java跨平台原理"></a>Java跨平台原理</h1><ul>
<li>C&#x2F;C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</li>
<li>Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</li>
<li>字节码文件不面向任何具体平台，只面向虚拟机。</li>
<li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li>
<li>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C&#x2F;C++要低。</li>
<li>Java的跨平台原理决定了其性能没有C&#x2F;C++高</li>
</ul>
<h1 id="Java的安全性"><a href="#Java的安全性" class="headerlink" title="Java的安全性"></a>Java的安全性</h1><ul>
<li>语言层次的安全性主要体现在：<ul>
<li>Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</li>
<li>垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。</li>
<li>异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</li>
<li>强制类型转换：只有在满足强制转换规则的情况下才能强转成功。</li>
</ul>
</li>
<li>底层的安全性可以从以下方面来说明<ul>
<li>Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。</li>
</ul>
</li>
<li>在运行环境提供了四级安全性保障机制：<ul>
<li>字节码校验器 -类装载器 -运行时内存布局 -文件访问限制</li>
</ul>
</li>
</ul>
<h1 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h1><ul>
<li>对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术</li>
<li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（可以用XML或者是注解），将Java程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</li>
</ul>
<h1 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h1><ul>
<li>DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作</li>
<li>为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中</li>
<li>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法</li>
<li>在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储</li>
<li>DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</li>
</ul>
<h1 id="UML是什么？UML中有哪些图？"><a href="#UML是什么？UML中有哪些图？" class="headerlink" title="UML是什么？UML中有哪些图？"></a>UML是什么？UML中有哪些图？</h1><ul>
<li>UML是统一建模语言（Unified Modeling Language）的缩写，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为</li>
<li>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等</li>
<li>在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</li>
</ul>
<h1 id="Java-中有几种类型的流？"><a href="#Java-中有几种类型的流？" class="headerlink" title="Java 中有几种类型的流？"></a>Java 中有几种类型的流？</h1><ul>
<li>两种流分别是字节流，字符流。</li>
<li>字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer</li>
<li>在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</li>
<li>关于Java的IO需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</li>
</ul>
<h1 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h1><ul>
<li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间</li>
<li>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</li>
<li>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</li>
</ul>
<h1 id="什么时候用assert？"><a href="#什么时候用assert？" class="headerlink" title="什么时候用assert？"></a>什么时候用assert？</h1><ul>
<li>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制</li>
<li>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。</li>
</ul>
<h1 id="比较一下Java-和JavaSciprt"><a href="#比较一下Java-和JavaSciprt" class="headerlink" title="比较一下Java 和JavaSciprt"></a>比较一下Java 和JavaSciprt</h1><ul>
<li>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。</li>
<li>下面对两种语言间的异同作如下比较：<ul>
<li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</li>
<li>解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</li>
<li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</li>
<li>代码格式不一样。</li>
</ul>
</li>
<li>上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</li>
</ul>
<p> </p>
<h1 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h1><ul>
<li><p>代码如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s1 = &quot;你好&quot;;</span><br><span class="line">String s2 = newString(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); </span><br></pre></td></tr></table></figure>
</li>
<li><p>在String类的构造方法当中，存在一个字符集设置的方法</p>
</li>
</ul>
<h1 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h1><ul>
<li>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</li>
<li>如果要访问外部类的局部变量，此时局部变量必须使用final修饰，否则无法访问。</li>
</ul>
<h1 id="匿名内部类是否可以继承其它类？是否可以实现接口？"><a href="#匿名内部类是否可以继承其它类？是否可以实现接口？" class="headerlink" title="匿名内部类是否可以继承其它类？是否可以实现接口？"></a>匿名内部类是否可以继承其它类？是否可以实现接口？</h1><ul>
<li>可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。</li>
</ul>
<h1 id="一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h1><ul>
<li>可以，但一个源文件中最多只能有一个公开类（public class）</li>
<li>而且文件名必须和公开类的类名完全保持一致。</li>
</ul>
<p> </p>
<h1 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h1><ul>
<li>接口可以继承接口</li>
<li>抽象类可以实现(implements)接口，抽象类可以继承具体类</li>
<li>抽象类中可以有静态的main方法。</li>
</ul>
<h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><ul>
<li>有两种方式：<ul>
<li>实现Cloneable接口并重写Object类中的clone()方法；</li>
<li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</li>
</ul>
</li>
<li>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</li>
</ul>
<h1 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h1><ul>
<li>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</li>
</ul>
<p> </p>
<h1 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h1><ul>
<li>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝</li>
<li>实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存</li>
<li>两者的相同点：都有默认值而且在类的任何地方都可以调用</li>
</ul>
<h1 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h1><ul>
<li>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的</li>
<li>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li>
<li>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li>
</ul>
<h1 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h1><ul>
<li>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）</li>
<li>然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露</li>
<li>一个例子就是hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象</li>
</ul>
<h1 id="静态内部类和内部类有什么区别"><a href="#静态内部类和内部类有什么区别" class="headerlink" title="静态内部类和内部类有什么区别"></a>静态内部类和内部类有什么区别</h1><ul>
<li>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</li>
<li>内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</li>
<li>在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类</li>
<li>Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class</li>
<li>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</li>
<li>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化</li>
</ul>
<h1 id="char-型变量中能不能存贮一个中文汉字-为什么"><a href="#char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char 型变量中能不能存贮一个中文汉字?为什么?"></a>char 型变量中能不能存贮一个中文汉字?为什么?</h1><ul>
<li>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦</li>
</ul>
<h1 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h1><ul>
<li>是值传递</li>
<li>Java 编程语言只有值传递参数</li>
<li>当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用</li>
<li>对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。</li>
</ul>
<h1 id="是否可以继承String-类"><a href="#是否可以继承String-类" class="headerlink" title="是否可以继承String 类?"></a>是否可以继承String 类?</h1><ul>
<li>String 类是final类，不可以被继承。</li>
</ul>
<h1 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</h1><ul>
<li>不对</li>
<li>如果两个对象x和y满足x.equals(y) &#x3D;&#x3D;++++ true，它们的哈希码（hash code）应当相同</li>
<li>Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同</li>
</ul>
<h1 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）?"></a>构造器（constructor）是否可被重写（override）?</h1><ul>
<li>构造器不能被继承，因此不能被重写，但可以被重载。</li>
</ul>
<h1 id="在Java-中，如何跳出当前的多重嵌套循环？"><a href="#在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java 中，如何跳出当前的多重嵌套循环？"></a>在Java 中，如何跳出当前的多重嵌套循环？</h1><ul>
<li>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</li>
<li>Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好</li>
</ul>
<h1 id="数组有没有length-方法-String-有没有length-方法？"><a href="#数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="数组有没有length()方法?String 有没有length()方法？"></a>数组有没有length()方法?String 有没有length()方法？</h1><ul>
<li>数组没有length()方法，有length 的属性</li>
<li>String 有length()方法</li>
<li>JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</li>
</ul>
<h1 id="swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h1><ul>
<li>早期的JDK中，switch（expr）中，expr可以是byte、short、char、int</li>
<li>从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举</li>
<li>从JDK 1.7版开始，还可以是字符串（String）</li>
<li>长整型（long）是不可以的。</li>
</ul>
<h1 id="Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?"></a>Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h1><ul>
<li>Math.round(11.5)的返回值是12</li>
<li>Math.round(-11.5)的返回值是-11</li>
<li>四舍五入的原理是在参数上加0.5然后进行下取整。</li>
</ul>
<p> </p>
<h1 id="解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h1><ul>
<li><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间</p>
</li>
<li><p>而通过new关键字和构造器创建的对象放在堆空间</p>
</li>
<li><p>程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中</p>
</li>
<li><p>栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“hello”);</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。</p>
</li>
<li><p>较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p>
</li>
</ul>
<h1 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h1><ul>
<li>&amp;运算符有两种用法<ul>
<li>按位与</li>
<li>逻辑与</li>
</ul>
</li>
<li>&amp;&amp;运算符是短路与运算</li>
<li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true</li>
<li>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</li>
<li>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常</li>
<li>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</li>
</ul>
<h1 id="Java-有没有goto"><a href="#Java-有没有goto" class="headerlink" title="Java 有没有goto?"></a>Java 有没有goto?</h1><ul>
<li>goto 是Java中的保留字，在目前版本的Java中没有使用</li>
<li>其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字</li>
</ul>
<h1 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?</h1><ul>
<li>对于short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型</li>
<li>而short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为s1+&#x3D; 1;相当于s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。</li>
</ul>
<h1 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确?"></a>float f&#x3D;3.4;是否正确?</h1><ul>
<li>不正确</li>
<li>3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成float f &#x3D;3.4F;。</li>
</ul>
<h1 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h1><ul>
<li>不是</li>
<li>Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</li>
</ul>
<h1 id="访问修饰符的区别？"><a href="#访问修饰符的区别？" class="headerlink" title="访问修饰符的区别？"></a>访问修饰符的区别？</h1><table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同包</th>
<th>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ul>
<li>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</li>
</ul>
<p> </p>
<h1 id="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><a href="#如果变量用final修饰，则怎样？如果方法final修饰，则怎样？" class="headerlink" title="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"></a>如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</h1><ul>
<li>用final修饰的类不能被扩展，也就是说不可能有子类；</li>
<li>用final修饰的方法不能被替换或隐藏：<ul>
<li>使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</li>
<li>使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏	（hidden）；</li>
</ul>
</li>
<li>用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：<ul>
<li>静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，		赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，	赋值只能在其声明中通过初始化表达式完成；</li>
<li>实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通	过初始化表达式完成，也可以在实例初始化块或构造器中进行；</li>
<li>方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体	（body）结束，在此期间其值不能改变；</li>
<li>构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，	同时被初始化为对应实参值，终止于构造器体结束，在此期间其值不能改变；</li>
<li>异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化	为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</li>
<li>局部变量在其值被访问之前必须被明确赋值；</li>
</ul>
</li>
</ul>
<h1 id="成员变量用static修饰和不用static修饰有什么区别？"><a href="#成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="成员变量用static修饰和不用static修饰有什么区别？"></a>成员变量用static修饰和不用static修饰有什么区别？</h1><ul>
<li>两个变量的生命周期不同。<ul>
<li>成员变量随着对象的创建而存在，随着对象的被回收而释放。</li>
<li>静态变量随着类的加载而存在，随着类的消失而消失。</li>
</ul>
</li>
<li>调用方式不同。<ul>
<li>成员变量只能被对象调用。</li>
<li>静态变量可以被对象调用，还可以被类名调用。</li>
<li>对象调用：p.country</li>
<li>类名调用 ：Person.country</li>
</ul>
</li>
<li>别名不同。<ul>
<li>成员变量也称为实例变量。</li>
<li>静态变量称为类变量。</li>
</ul>
<p> </p>
</li>
<li>数据存储位置不同。<ul>
<li>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.</li>
<li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.</li>
</ul>
</li>
</ul>
<h1 id="System-out-println-‘a’-1-的结果是"><a href="#System-out-println-‘a’-1-的结果是" class="headerlink" title="System.out.println(‘a’+1);的结果是"></a>System.out.println(‘a’+1);的结果是</h1><ul>
<li>‘a’是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98</li>
</ul>
<h1 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h1><ul>
<li>NullPointerException：一般都是在null对象上调用方法了。</li>
<li>NumberFormatException：继承IllegalArgumentException，字符串转换为数字时。</li>
<li>StringIndexOutOfBoundsException：字符串越界</li>
<li>ClassCastException:类型转换错误</li>
</ul>
<h1 id="200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><a href="#200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？" class="headerlink" title="200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"></a>200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</h1><ul>
<li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li>
<li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序</li>
<li>Collections 工具类的sort方法有两种重载的形式<ul>
<li>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较</li>
<li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li>
</ul>
</li>
</ul>
<h1 id="199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><a href="#199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？" class="headerlink" title="199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"></a>199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</h1><ul>
<li>构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法</li>
</ul>
<h1 id="char型变量中能不能存储一个中文汉字？"><a href="#char型变量中能不能存储一个中文汉字？" class="headerlink" title="char型变量中能不能存储一个中文汉字？"></a>char型变量中能不能存储一个中文汉字？</h1><ul>
<li>java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。</li>
<li>char 在java中是2个字节，所以可以存储中文</li>
</ul>
<h1 id="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"><a href="#创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。" class="headerlink" title="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"></a>创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</h1><ul>
<li>用一个for循环创建线程对象并调用start方法启动线程。</li>
</ul>
<h1 id="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><a href="#Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？" class="headerlink" title="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"></a>Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</h1><ul>
<li>Map的实现类有HashMap,LinkedHashMap,TreeMap</li>
<li>HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序；TreeMap默认是自然升序）</li>
<li>LinkedHashMap底层存储结构是哈希表+链表，链表记录了添加数据的顺序</li>
<li>TreeMap底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性</li>
<li>LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表</li>
</ul>
<h1 id="try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？"><a href="#try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？" class="headerlink" title="try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？"></a>try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？</h1><ul>
<li>在异常处理时提供 finally 块来执行任何清除操作。</li>
<li>如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。</li>
<li>finally中语句不执行的唯一情况中执行了System.exit(0)语句。</li>
</ul>
<h1 id="什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>什么是编译型语言，什么是解释型语言？java可以归类到那种？</h1><ul>
<li>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。</li>
<li>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。</li>
<li>解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。</li>
<li>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C&#x2F;C++、Pascal&#x2F;Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。</li>
<li>JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</li>
</ul>
<h1 id="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h1><ul>
<li>final修饰基本类型变量，其值不能改变。</li>
<li>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li>
</ul>
<h1 id="Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="Class类的getDeclaredFields()方法与getFields()的区别？"></a>Class类的getDeclaredFields()方法与getFields()的区别？</h1><ul>
<li>getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法</li>
<li>getFields(): 只能获取所有public声43明的方法, 包括继承的方法</li>
</ul>
<h1 id="103-可序列化对象为什么要定义serialversionUID值"><a href="#103-可序列化对象为什么要定义serialversionUID值" class="headerlink" title="103.可序列化对象为什么要定义serialversionUID值?"></a>103.可序列化对象为什么要定义serialversionUID值?</h1><ul>
<li>SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容</li>
<li>如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常</li>
<li>如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</li>
</ul>
<h1 id="GC线程是否为守护线程？"><a href="#GC线程是否为守护线程？" class="headerlink" title="GC线程是否为守护线程？"></a>GC线程是否为守护线程？</h1><ul>
<li>GC线程是守护线程</li>
<li>线程分为守护线程和非守护线程（即用户线程）。只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。</li>
</ul>
<h1 id="不通过构造函数也能创建对象么"><a href="#不通过构造函数也能创建对象么" class="headerlink" title="不通过构造函数也能创建对象么"></a>不通过构造函数也能创建对象么</h1><ul>
<li>是</li>
<li>Java创建对象的几种方式：<ul>
<li>用new语句创建对象，这是最常见的创建对象的方法。</li>
<li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li>
<li>调用对象的clone()方法。</li>
<li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ul>
</li>
<li>(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。</li>
</ul>
<h1 id="同步代码块和同步方法有什么区别"><a href="#同步代码块和同步方法有什么区别" class="headerlink" title="同步代码块和同步方法有什么区别"></a>同步代码块和同步方法有什么区别</h1><ul>
<li>相同点：同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为this，那么同步方法和同步代码块没有太大的区别。</li>
<li>区别：同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</li>
</ul>
<h1 id="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><a href="#Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？" class="headerlink" title="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"></a>Java中，如果Manager是Employee的子类，那么Pair<Manager>是Pair<Employee>的子类吗？</h1><ul>
<li>不是，两者没有任何关联。</li>
</ul>
<h1 id="简述Java中如何实现多态"><a href="#简述Java中如何实现多态" class="headerlink" title="简述Java中如何实现多态"></a>简述Java中如何实现多态</h1><ul>
<li>实现多态有三个前提条件：<ul>
<li>继承的存在；（继承是多态的基础，没有继承就没有多态）。</li>
<li>子类重写父类的方法。（多态下会调用子类重写后的方法）。</li>
<li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</li>
</ul>
</li>
<li>最后使用父类的引用变量调用子类重写的方法即可实现多态。</li>
</ul>
<h1 id="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h1><ul>
<li>在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt;K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt;K, V&gt;可以理解为HashMap&lt;Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型</li>
<li>引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。</li>
</ul>
<h1 id="对象在虚拟机的大小中可不可以用size-of取出。"><a href="#对象在虚拟机的大小中可不可以用size-of取出。" class="headerlink" title="对象在虚拟机的大小中可不可以用size of取出。"></a>对象在虚拟机的大小中可不可以用size of取出。</h1><ul>
<li>可以</li>
</ul>
<h1 id="什么是-JMS？"><a href="#什么是-JMS？" class="headerlink" title="什么是 JMS？"></a>什么是 JMS？</h1><ul>
<li>JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。</li>
</ul>
<h1 id="JMS-有哪些模型？"><a href="#JMS-有哪些模型？" class="headerlink" title="JMS 有哪些模型？"></a>JMS 有哪些模型？</h1><ul>
<li>JMS 消息机制主要分为两种模型：PTP 模型和 Pub&#x2F;Sub 模型。</li>
</ul>
<h4 id="PTP-模型"><a href="#PTP-模型" class="headerlink" title="PTP 模型"></a>PTP 模型</h4><ul>
<li>（Point to Point 对点模型) 每一个消息传递给一个消息消费者，保证消息传递给消息消费者，且消息不会同时被多个消费者接收。如果消息消费者暂时不在连接范围内，JMS 会自动保证消息不会丢失，直到消息消费者进入连接，消息将自动送达。因此，JMS 需要将消息保存到永久性介质上，例如数据库或者文件。</li>
</ul>
<h4 id="Pub-Sub-模型"><a href="#Pub-Sub-模型" class="headerlink" title="Pub-Sub 模型"></a>Pub-Sub 模型</h4><ul>
<li>(publish-subscription 发布者订阅者模型)每个主题可以拥有多个订阅者。JMS 系统负责将消息的副本传给该主题的每个订阅者。如果希望每一条消息都能够被处理，那么应该使用 PTP 消息模型。如果并不要求消息都必须被消息消费者接收到的情况下，可使用 pub-sub 消息模型。Pub-Sub 模型可以在一对多的消息广播时使用。</li>
</ul>
<h1 id="为什么不能根据返回类型来区分重载，为什么？"><a href="#为什么不能根据返回类型来区分重载，为什么？" class="headerlink" title="为什么不能根据返回类型来区分重载，为什么？"></a>为什么不能根据返回类型来区分重载，为什么？</h1><ul>
<li>方法的重载，即使返回值类型不同，也不能改变实现功能相同或类似这一既定事实</li>
<li>同时方法的重载只是要求两同三不同，即在同一个类中，相同的方法名称，参数列表当中的参数类型、个数、顺序不同；跟权限修饰符和返回值类无关</li>
</ul>
<h1 id="Java-中-byte-表示的数值范围是什么？"><a href="#Java-中-byte-表示的数值范围是什么？" class="headerlink" title="Java 中 byte 表示的数值范围是什么？"></a>Java 中 byte 表示的数值范围是什么？</h1><ul>
<li>范围是-128 至 127</li>
</ul>
<h1 id="在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？"><a href="#在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？" class="headerlink" title="在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？"></a>在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？</h1><ul>
<li>不正确。</li>
<li>通常情况下，进行比较判断的处理，switch 和 if-else 可以互相转换来写；</li>
<li>if-else 作用的范围比 switch-case 作用范围要大，但是当 switch-case 和 if-else 都可以用的情况下，通常推荐使用 switch-case。</li>
</ul>
<h1 id="Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？"><a href="#Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？" class="headerlink" title="Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？"></a>Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？</h1><ul>
<li>Java 程序中创建新的类对象，使用关键字 new 是正确的</li>
<li>回收无用的类对象使用关键字 free 是错误的.</li>
</ul>
<h1 id="存在使-i-1"><a href="#存在使-i-1" class="headerlink" title="存在使 i+1&lt;i 的数么?"></a>存在使 i+1&lt;i 的数么?</h1><ul>
<li>存在, int 的最大值, 加 1 后变为负数.</li>
</ul>
<h1 id="Java-中-Math-random（）-Math-random（）值为？"><a href="#Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="Java 中 Math.random（）&#x2F; Math.random（）值为？"></a>Java 中 Math.random（）&#x2F; Math.random（）值为？</h1><ul>
<li>如果除数与被除数均不为 0.0 的话，则取值范围为[0, +∞]。+∞在 Java 中显示的结果为 Infinity。</li>
<li>如果除数与被除数均为 0.0 的话，则运行结果为 NaN（Not a Number 的简写），计算错误。</li>
</ul>
<h1 id="匿名内部类可不可以继承或实现接口。为什么？"><a href="#匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="匿名内部类可不可以继承或实现接口。为什么？"></a>匿名内部类可不可以继承或实现接口。为什么？</h1><ul>
<li>匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现.</li>
<li>由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把<br>创建对象的任务交给了父类去完成。</li>
<li>在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。</li>
<li>因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。</li>
</ul>
<h1 id="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？"><a href="#说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？" class="headerlink" title="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？"></a>说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？</h1><ul>
<li>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；比如申请了一个 integer,但给它存了long 才能存下的数，那就是内存溢出。</li>
<li>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li>
<li>memory leak 会最终会导致 out of memory！</li>
</ul>
<h1 id="为什么为基本类型引入包装类"><a href="#为什么为基本类型引入包装类" class="headerlink" title="为什么为基本类型引入包装类"></a>为什么为基本类型引入包装类</h1><ul>
<li>基本数据类型有方便之处，简单、高效。</li>
<li>但是 Java 中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是 Object）。</li>
<li>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</li>
<li>包装类和基本数据类型之间的转换<ul>
<li>包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</li>
<li>包装类——-new WrapperClass(primitive) new WrapperClass(string)——基本数据类型</li>
</ul>
</li>
<li>自动装箱和自动拆箱<ul>
<li>JDK1.5 提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换</li>
</ul>
</li>
<li>包装类还可以实现基本类型变量和字符串之间的转换<ul>
<li>基本类型变量&lt;————String.valueof()————&gt;字符串</li>
<li>基本类型变量&lt;————WrapperClass.parseXxx(string)————字符串</li>
</ul>
</li>
</ul>
<h1 id="谈谈-Java-的多态"><a href="#谈谈-Java-的多态" class="headerlink" title="谈谈 Java 的多态"></a>谈谈 Java 的多态</h1><ul>
<li>实现多态的三个条件（前提条件，向上转型、向下转型）<ul>
<li>继承的存在；（继承是多态的基础，没有继承就没有多态）</li>
<li>子类重写父类的方法。（多态下会调用子类重写后的方法）</li>
<li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）</li>
</ul>
</li>
<li>向上转型 Student person &#x3D; new Student()</li>
<li>将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。</li>
<li>此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法此时通过父类引用变量无法调用子类特有的方法。</li>
<li>向下转型 Student stu &#x3D; (Student)person;</li>
<li>将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类型，否则将出现 ClassCastException，不是任意的强制转换向下转型时可以结合使用 instanceof 运算符进行强制类型转换，比如出现转换异常—ClassCastException</li>
</ul>
<h1 id="if-多分支语句和-switch-多分支语句的异同之处"><a href="#if-多分支语句和-switch-多分支语句的异同之处" class="headerlink" title="if 多分支语句和 switch 多分支语句的异同之处"></a>if 多分支语句和 switch 多分支语句的异同之处</h1><ul>
<li>相同之处：都是分支语句，多超过一种的情况进行判断处理。</li>
<li>不同之处：<ul>
<li>switch 更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有 break 跳出），不加判断地执行下去;而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。</li>
<li>switch 为等值判断（不允许比如&gt;&#x3D; &lt;&#x3D;），而 if 为等值和区间都可以，if 的使用范围大。</li>
</ul>
</li>
</ul>
<h1 id="基本数据类型的类型转换规则"><a href="#基本数据类型的类型转换规则" class="headerlink" title="基本数据类型的类型转换规则"></a>基本数据类型的类型转换规则</h1><ul>
<li>基本类型转换分为自动转换和强制转换。</li>
<li>自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的<br>范围。</li>
<li>强制转换规则：高级变为低级需要强制转换。</li>
<li>如何转换：<ul>
<li>赋值运算符“&#x3D;”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</li>
<li>赋值运算符“&#x3D;”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 &#x3D;&#x3D; 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li>
<li>可以将整型常量直接赋值给 byte, short, char 等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li>
</ul>
</li>
</ul>
<h1 id="Java-三种注释类型"><a href="#Java-三种注释类型" class="headerlink" title="Java 三种注释类型"></a>Java 三种注释类型</h1><ul>
<li>共有单行注释、多行注释、文档注释 3 种注释类型</li>
</ul>
<h1 id="谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么"><a href="#谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么" class="headerlink" title="谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?"></a>谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?</h1><ul>
<li>Java本身是一种面向对象的语言,最显著的特点有两个方面,一个是所谓的”书写一次,到处运行”;能够非常容易地获得跨平台能力;另外就是垃圾收集器(GC)，Java通过垃圾收集器回收分配内存,大部分情况下,程序员不需要自己操心内存的分配和回收。我们日常接触到JRE或者JDK。JRE也就是Java运行环境,包含了JVM和Java类库,以及一些模块等。而JDK可以看作是JRE的一个超集,提供了更多的工具,比如编译器 各种诊断工具。</li>
<li>“对于Java是解释执行”这句话,这个说法不准确。我们开发的Java的源代码,首先通过Javac编译成为字节码,然后在运行时通过Java虚拟机内嵌的解释器将字节码转换为最终的机器码。但是常见的JVM,比如我们大数据情况使用的Oracle JDK提供的HostpotJVM,提供了JIT编译器,就是通常所说的动态编译器,JIT能够在运行时将热点代码(高频调用的方法和代码块)编译成机器码,这种情况下部分热点就属于编译执行,而不是解释执行。这样类似于缓存技术,运行时在遇到热点代码可以直接执行,而不是先解释在执行。</li>
</ul>
<h1 id="NoClassDeFoundError和ClassNotFoundException的区别"><a href="#NoClassDeFoundError和ClassNotFoundException的区别" class="headerlink" title="NoClassDeFoundError和ClassNotFoundException的区别?"></a>NoClassDeFoundError和ClassNotFoundException的区别?</h1><ul>
<li>首先NoClassDeFoundError是一个错误,ClassNotFoundException是一个异常。ClassNotFoundException的产生原因,Java支持使用Class.froName方法来动态地加载类,任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中,如果这个类在类路径中没有被找到,那么此时就会在运行时抛出ClassNotFoundException异常。另外还有一个导致ClassNotFoundException的原因就是,当一个类已经被某个类加载器加载到内存中,此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li>
<li>NoClassDeFoundError产生的原因在于:如果JVM或者ClassLoader实例尝试加载类的时候找不到类的定义。例如要查找的类在编译的时候是存在的,运行的时候找不到了。这个时候就会导致NoClassDefFoundError。造成该问题的原因可能是打包过程中漏掉了部分类,或者jar包出现损坏或者篡改。解决这个问题的办法就是查找那些在开发期间存在与类路径下,但在运行期间却不在类路径下的类。</li>
</ul>
<h1 id="一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数"><a href="#一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数" class="headerlink" title="一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?"></a>一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?</h1><ul>
<li>用 super 关键字,子类去调用父类的方法，如：super.myMethod();子类去调用父类的构造函数，如：super()</li>
</ul>
<h1 id="Bit-和-Byte-是什么意思-它们之间有什么关系"><a href="#Bit-和-Byte-是什么意思-它们之间有什么关系" class="headerlink" title="Bit 和 Byte 是什么意思?它们之间有什么关系?"></a>Bit 和 Byte 是什么意思?它们之间有什么关系?</h1><ul>
<li>bit 中文名称是位，是用以描述电脑数据量的最小单位。</li>
<li>byte（字节）是计算机信息技术用于计量存储容量和传输容量的一种计量单位 1byte&#x3D;8bit</li>
</ul>
<h1 id="什么是-java-序列化，如何实现-java-序列化？"><a href="#什么是-java-序列化，如何实现-java-序列化？" class="headerlink" title="什么是 java 序列化，如何实现 java 序列化？"></a>什么是 java 序列化，如何实现 java 序列化？</h1><ul>
<li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；</li>
<li>序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream) 来 构 造 一 个 ObjectOutputStream( 对 象 流 ) 对 象 ， 接 着 ， 使 用ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。</li>
</ul>
<h1 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h1><ul>
<li>Lambda表达式的本质只是一个”语法糖”,由编译器推断并帮我们转换包装为常规的代码,因此我们可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘。</li>
<li>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许我们通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。</li>
<li>Lambda表达式还增强了集合库。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。</li>
</ul>
<h1 id="获取用键盘输入常用的的两种方法"><a href="#获取用键盘输入常用的的两种方法" class="headerlink" title="获取用键盘输入常用的的两种方法"></a>获取用键盘输入常用的的两种方法</h1><ul>
<li>通过 Scanner</li>
<li>通过 BufferedReader</li>
</ul>
<h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><ul>
<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>
<li>拆箱：将包装类型转换为基本数据类型；</li>
</ul>
<h1 id="JAVA-复制"><a href="#JAVA-复制" class="headerlink" title="JAVA 复制"></a>JAVA 复制</h1><ul>
<li>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</li>
</ul>
<h4 id="直接赋值复制"><a href="#直接赋值复制" class="headerlink" title="直接赋值复制"></a>直接赋值复制</h4><ul>
<li>直接赋值。在 Java 中，A a1 &#x3D; a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。</li>
</ul>
<h4 id="浅复制（复制引用但不复制引用的对象）"><a href="#浅复制（复制引用但不复制引用的对象）" class="headerlink" title="浅复制（复制引用但不复制引用的对象）"></a>浅复制（复制引用但不复制引用的对象）</h4><ul>
<li>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。</li>
<li>因此，原始对象及其副本引用同一个对象。</li>
</ul>
<h4 id="深复制（复制对象和其应用对象）"><a href="#深复制（复制对象和其应用对象）" class="headerlink" title="深复制（复制对象和其应用对象）"></a>深复制（复制对象和其应用对象）</h4><ul>
<li>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</li>
</ul>
<h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><ul>
<li>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List&lt;Object&gt;和 List&lt;String&gt;等类型，在编译之后</li>
<li>都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</li>
<li>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</li>
</ul>
<h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h1><ul>
<li>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数</li>
<li>例 如 List&lt;?&gt; 在逻辑上是 List&lt;String&gt;,List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt;的父类。</li>
</ul>
<h1 id="创建对象的两种方法"><a href="#创建对象的两种方法" class="headerlink" title="创建对象的两种方法"></a>创建对象的两种方法</h1><ul>
<li>Class 对象的 newInstance()<ul>
<li>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</li>
</ul>
</li>
<li>调用 Constructor 对象的 newInstance()<ul>
<li>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</li>
</ul>
</li>
</ul>
<h1 id="Java-中，Serializable-与-Externalizable-的区别？"><a href="#Java-中，Serializable-与-Externalizable-的区别？" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别？"></a>Java 中，Serializable 与 Externalizable 的区别？</h1><ul>
<li>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</li>
</ul>
<h1 id="OOP-中的-组合、聚合和关联有什么区别？"><a href="#OOP-中的-组合、聚合和关联有什么区别？" class="headerlink" title="OOP 中的 组合、聚合和关联有什么区别？"></a>OOP 中的 组合、聚合和关联有什么区别？</h1><ul>
<li>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B组合的，则 A 不存在的话，B 一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</li>
</ul>
<h1 id="Java-中，嵌套公共静态类与顶级类有什么不同？"><a href="#Java-中，嵌套公共静态类与顶级类有什么不同？" class="headerlink" title="Java 中，嵌套公共静态类与顶级类有什么不同？"></a>Java 中，嵌套公共静态类与顶级类有什么不同？</h1><ul>
<li>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</li>
</ul>
<h1 id="继承和组合之间有什么不同？"><a href="#继承和组合之间有什么不同？" class="headerlink" title="继承和组合之间有什么不同？"></a>继承和组合之间有什么不同？</h1><ul>
<li>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</li>
</ul>
<h1 id="我们能自己写一个容器类，然后使用-for-each-循环码？"><a href="#我们能自己写一个容器类，然后使用-for-each-循环码？" class="headerlink" title="我们能自己写一个容器类，然后使用 for-each 循环码？"></a>我们能自己写一个容器类，然后使用 for-each 循环码？</h1><ul>
<li>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</li>
</ul>
<h1 id="写一段代码在遍历-ArrayList-时移除一个元素？"><a href="#写一段代码在遍历-ArrayList-时移除一个元素？" class="headerlink" title="写一段代码在遍历 ArrayList 时移除一个元素？"></a>写一段代码在遍历 ArrayList 时移除一个元素？</h1><ul>
<li>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</li>
</ul>
<h1 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a>Java 中的 HashSet，内部是如何工作的？</h1><ul>
<li>HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。</li>
</ul>
<h1 id="Java-中的-TreeMap-是采用什么树实现的？"><a href="#Java-中的-TreeMap-是采用什么树实现的？" class="headerlink" title="Java 中的 TreeMap 是采用什么树实现的？"></a>Java 中的 TreeMap 是采用什么树实现的？</h1><ul>
<li>Java 中的 TreeMap 是使用红黑树实现的。</li>
</ul>
<h1 id="Java-中的-LinkedList-是单向链表还是双向链表？"><a href="#Java-中的-LinkedList-是单向链表还是双向链表？" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表？"></a>Java 中的 LinkedList 是单向链表还是双向链表？</h1><ul>
<li>是双向链表，你可以检查 JDK 的源码</li>
</ul>
<h1 id="Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？</h1><ul>
<li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li>
</ul>
<h1 id="poll-方法和-remove-方法的区别？"><a href="#poll-方法和-remove-方法的区别？" class="headerlink" title="poll() 方法和 remove() 方法的区别？"></a>poll() 方法和 remove() 方法的区别？</h1><ul>
<li>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</li>
</ul>
<h1 id="Java-中的编译期常量是什么？使用它又什么风险？"><a href="#Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="Java 中的编译期常量是什么？使用它又什么风险？"></a>Java 中的编译期常量是什么？使用它又什么风险？</h1><ul>
<li>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</li>
</ul>
<h1 id="我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？"><a href="#我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？" class="headerlink" title="我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？"></a>我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？</h1><ul>
<li>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</li>
</ul>
<h1 id="3-0-1-0-3-将会返回什么？true-还是-false？"><a href="#3-0-1-0-3-将会返回什么？true-还是-false？" class="headerlink" title="3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？"></a>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？</h1><ul>
<li>false，因为有些浮点数不能完全精确的表示出来。</li>
</ul>
<h1 id="int-和-Integer-哪个会占用更多的内存？"><a href="#int-和-Integer-哪个会占用更多的内存？" class="headerlink" title="int 和 Integer 哪个会占用更多的内存？"></a>int 和 Integer 哪个会占用更多的内存？</h1><ul>
<li>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。</li>
<li>但是 int 是一个原始类型的数据，所以占用的空间更少。</li>
</ul>
<h1 id="为什么-Java-中的-String-是不可变的（Immutable）？"><a href="#为什么-Java-中的-String-是不可变的（Immutable）？" class="headerlink" title="为什么 Java 中的 String 是不可变的（Immutable）？"></a>为什么 Java 中的 String 是不可变的（Immutable）？</h1><ul>
<li>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。</li>
</ul>
<h1 id="我们能在-Switch-中使用-String-吗？"><a href="#我们能在-Switch-中使用-String-吗？" class="headerlink" title="我们能在 Switch 中使用 String 吗？"></a>我们能在 Switch 中使用 String 吗？</h1><ul>
<li>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</li>
</ul>
<h1 id="Java-中的构造器链是什么？"><a href="#Java-中的构造器链是什么？" class="headerlink" title="Java 中的构造器链是什么？"></a>Java 中的构造器链是什么？</h1><ul>
<li>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</li>
</ul>
<h1 id="什么是-Busy-spin？我们为什么要使用它？"><a href="#什么是-Busy-spin？我们为什么要使用它？" class="headerlink" title="什么是 Busy spin？我们为什么要使用它？"></a>什么是 Busy spin？我们为什么要使用它？</h1><ul>
<li>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。</li>
<li>所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</li>
</ul>
<h1 id="Swing-是线程安全的？"><a href="#Swing-是线程安全的？" class="headerlink" title="Swing 是线程安全的？"></a>Swing 是线程安全的？</h1><ul>
<li>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。</li>
<li>这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</li>
</ul>
<h1 id="什么是线程局部变量？"><a href="#什么是线程局部变量？" class="headerlink" title="什么是线程局部变量？"></a>什么是线程局部变量？</h1><ul>
<li>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</li>
</ul>
<h1 id="Java-中应该使用什么数据类型来代表价格？"><a href="#Java-中应该使用什么数据类型来代表价格？" class="headerlink" title="Java 中应该使用什么数据类型来代表价格？"></a>Java 中应该使用什么数据类型来代表价格？</h1><ul>
<li>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的double 类型。</li>
</ul>
<h1 id="怎么将-byte-转换为-String？"><a href="#怎么将-byte-转换为-String？" class="headerlink" title="怎么将 byte 转换为 String？"></a>怎么将 byte 转换为 String？</h1><ul>
<li>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</li>
</ul>
<h1 id="我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h1><ul>
<li>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。</li>
</ul>
<h1 id="哪个类包含-clone-方法？是-Cloneable-还是-Object？"><a href="#哪个类包含-clone-方法？是-Cloneable-还是-Object？" class="headerlink" title="哪个类包含 clone 方法？是 Cloneable 还是 Object？"></a>哪个类包含 clone 方法？是 Cloneable 还是 Object？</h1><ul>
<li>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由c 或 c++ 或 其他本地语言实现的。</li>
</ul>
<h1 id="Java-中-操作符是线程安全的吗？"><a href="#Java-中-操作符是线程安全的吗？" class="headerlink" title="Java 中 ++ 操作符是线程安全的吗？"></a>Java 中 ++ 操作符是线程安全的吗？</h1><p> 不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p>
<h1 id="a-a-b-与-a-b-的区别"><a href="#a-a-b-与-a-b-的区别" class="headerlink" title="a &#x3D; a + b 与 a +&#x3D; b 的区别"></a>a &#x3D; a + b 与 a +&#x3D; b 的区别</h1><ul>
<li>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是a +&#x3D; b 没问题，如下：<ul>
<li>byte a &#x3D; 127;</li>
<li>byte b &#x3D; 127;</li>
<li>b &#x3D; a + b; &#x2F;&#x2F; error : cannot convert from int to byte</li>
<li>b +&#x3D; a; &#x2F;&#x2F; ok</li>
</ul>
</li>
</ul>
<h1 id="什么是多线程环境下的伪共享（false-sharing）？"><a href="#什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="什么是多线程环境下的伪共享（false sharing）？"></a>什么是多线程环境下的伪共享（false sharing）？</h1><ul>
<li>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行</li>
</ul>
<h1 id="89、简述一下面向对象的”六原则一法则”。"><a href="#89、简述一下面向对象的”六原则一法则”。" class="headerlink" title="89、简述一下面向对象的”六原则一法则”。"></a>89、简述一下面向对象的”六原则一法则”。</h1><ul>
<li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</li>
<li>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</li>
<li>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li>
<li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</li>
<li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</li>
</ul>
<h1 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h1><ul>
<li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li>
</ul>
<h1 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h1><ul>
<li>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</li>
</ul>
<h1 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h1><ul>
<li>动态代理是运行时动态生成代理类。</li>
<li>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</li>
</ul>
<h1 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h1><ul>
<li>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</li>
</ul>
<h1 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h1><ul>
<li>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</li>
</ul>
<h1 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h1><ul>
<li>Files.exists()：检测文件路径是否存在。</li>
<li>Files.createFile()：创建文件。</li>
<li>Files.createDirectory()：创建文件夹。</li>
<li>Files.delete()：删除一个文件或目录。</li>
<li>Files.copy()：复制文件。</li>
<li>Files.move()：移动文件。</li>
<li>Files.size()：查看文件个数。</li>
<li>Files.read()：读取文件。</li>
<li>Files.write()：写入文件。</li>
</ul>
<h1 id="Java-中的异常处理机制的简单原理和应用。"><a href="#Java-中的异常处理机制的简单原理和应用。" class="headerlink" title="Java 中的异常处理机制的简单原理和应用。"></a>Java 中的异常处理机制的简单原理和应用。</h1><ul>
<li>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。</li>
<li>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。</li>
</ul>
<h1 id="Java-中的-LongAdder-和-AtomicLong-的区别"><a href="#Java-中的-LongAdder-和-AtomicLong-的区别" class="headerlink" title="Java 中的 LongAdder 和 AtomicLong 的区别"></a>Java 中的 LongAdder 和 AtomicLong 的区别</h1><ul>
<li>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进行了有效的分离，提高了并行度。</li>
</ul>
<h1 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h1><ul>
<li>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</li>
<li>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。</li>
</ul>
<h1 id="Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h1><ul>
<li>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。</li>
<li>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</li>
<li>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数。</li>
</ul>
<h1 id="请问-Query-接口的-list-方法和-iterate-方法有什么区别？"><a href="#请问-Query-接口的-list-方法和-iterate-方法有什么区别？" class="headerlink" title="请问 Query 接口的 list 方法和 iterate 方法有什么区别？"></a>请问 Query 接口的 list 方法和 iterate 方法有什么区别？</h1><ul>
<li>list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用 iterate()方法可以减少性能开销。</li>
<li>list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题</li>
</ul>
<h1 id="Java-的接口和-C-的虚类的相同和不同处。"><a href="#Java-的接口和-C-的虚类的相同和不同处。" class="headerlink" title="Java 的接口和 C++的虚类的相同和不同处。"></a>Java 的接口和 C++的虚类的相同和不同处。</h1><ul>
<li>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。</li>
<li>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。</li>
</ul>
<h1 id="Java-支持多继承么？"><a href="#Java-支持多继承么？" class="headerlink" title="Java 支持多继承么？"></a>Java 支持多继承么？</h1><ul>
<li>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</li>
</ul>
<h1 id="解释-extends-和-super-泛型限定符-上界不存下界不取"><a href="#解释-extends-和-super-泛型限定符-上界不存下界不取" class="headerlink" title="解释 extends 和 super 泛型限定符-上界不存下界不取"></a>解释 extends 和 super 泛型限定符-上界不存下界不取</h1><ul>
<li>泛型中上界和下界的定义<ul>
<li>上界 &lt;? extend Fruit&gt;</li>
<li>下界 &lt;? super Apple&gt;</li>
</ul>
</li>
<li>上界和下界的特点<ul>
<li>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）</li>
<li>下界的 list 只能 add，不能 get</li>
</ul>
</li>
<li>上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把所有的子类向上转型为 Fruit。</li>
<li>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接着呢，除了 Object，其他的都接不住。</li>
<li>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。</li>
<li>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引用就必须得用 cast。</li>
</ul>
<h1 id="”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？"><a href="#”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？" class="headerlink" title="”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？"></a>”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？</h1><ul>
<li>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</li>
<li>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。</li>
</ul>
<h1 id="你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？</h1><ul>
<li>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</li>
<li>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一个很好的说明。</li>
<li>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。</li>
<li>其函数表示是：<ul>
<li>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));</li>
<li>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。</li>
<li>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好的说明。</li>
</ul>
</li>
</ul>
<h1 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h1><ul>
<li>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</li>
<li>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递.</li>
</ul>
<h1 id="为啥有时会出现-4-0-3-6-0-40000001-这种现象？"><a href="#为啥有时会出现-4-0-3-6-0-40000001-这种现象？" class="headerlink" title="为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？"></a>为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？</h1><ul>
<li>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。</li>
</ul>
<h1 id="说说-Lamda-表达式的优缺点。"><a href="#说说-Lamda-表达式的优缺点。" class="headerlink" title="说说 Lamda 表达式的优缺点。"></a>说说 Lamda 表达式的优缺点。</h1><ul>
<li>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。</li>
<li>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</li>
</ul>
<h1 id="若对一个类不重写，它的-equals-方法是如何比较的？"><a href="#若对一个类不重写，它的-equals-方法是如何比较的？" class="headerlink" title="若对一个类不重写，它的 equals()方法是如何比较的？"></a>若对一个类不重写，它的 equals()方法是如何比较的？</h1><ul>
<li>比较是对象的地址。</li>
</ul>
<h1 id="比较的是什么？"><a href="#比较的是什么？" class="headerlink" title="&#x3D;&#x3D;比较的是什么？"></a>&#x3D;&#x3D;比较的是什么？</h1><ul>
<li>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。</li>
</ul>
<h1 id="Object-若不重写-hashCode-的话，hashCode-如何计算出来的？"><a href="#Object-若不重写-hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="Object 若不重写 hashCode()的话，hashCode()如何计算出来的？"></a>Object 若不重写 hashCode()的话，hashCode()如何计算出来的？</h1><ul>
<li>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。</li>
</ul>
<h1 id="Hash表的hash函数，冲突解决方法有哪些。"><a href="#Hash表的hash函数，冲突解决方法有哪些。" class="headerlink" title="Hash表的hash函数，冲突解决方法有哪些。"></a>Hash表的hash函数，冲突解决方法有哪些。</h1><ul>
<li>开放定址法或者叫再散列法；<ul>
<li>线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    - 二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    - 伪随机探测再散列：di&#x3D;伪随机序列；</li>
</ul>
</li>
<li>再哈希法；</li>
<li>拉链法。</li>
</ul>
<h1 id="分派：静态分派与动态分派。"><a href="#分派：静态分派与动态分派。" class="headerlink" title="分派：静态分派与动态分派。"></a>分派：静态分派与动态分派。</h1><ul>
<li>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的</li>
<li>动态分派：（重写）</li>
</ul>
<h1 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样?"></a>一个线程如果出现了运行时异常会怎么样?</h1><ul>
<li>如果该异常被捕获或抛出，则程序继续运行。 </li>
<li>如果异常没有被捕获该线程将会停止执行。 </li>
<li>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理</li>
</ul>
<h1 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h1><ul>
<li>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。</li>
</ul>
<h1 id="并发编程（concurrency）并行编程（parallellism）有什么区别？"><a href="#并发编程（concurrency）并行编程（parallellism）有什么区别？" class="headerlink" title="并发编程（concurrency）并行编程（parallellism）有什么区别？*"></a>并发编程（concurrency）并行编程（parallellism）有什么区别？*</h1><ul>
<li>并发（concurrency）和并行（parallellism）是：<ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>
<li>并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群</li>
</ul>
</li>
</ul>
<h1 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h1><ul>
<li>只要退出了synchronized块，无论是正常还是异常，都会释放锁。</li>
</ul>
<h1 id="foreach与正常for循环效率对比"><a href="#foreach与正常for循环效率对比" class="headerlink" title="foreach与正常for循环效率对比"></a>foreach与正常for循环效率对比</h1><ul>
<li>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。</li>
</ul>
<h1 id="Static-class-与non-static-class的区别"><a href="#Static-class-与non-static-class的区别" class="headerlink" title="Static?class?与non?static?class的区别"></a>Static?class?与non?static?class的区别</h1><ul>
<li>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。</li>
<li>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。</li>
</ul>
<h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul>
<li>加载JDBC驱动程序</li>
<li>提供JDBC连接的URL</li>
<li>创建数据库的连接</li>
<li>创建一个Statement</li>
<li>执行SQL语句</li>
<li>处理结果</li>
<li>关闭JDBC对象</li>
</ul>
<h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul>
<li>方法名称相同，参数的类型或个数不同</li>
<li>方法名称、参数类型、返回值类型全部相同</li>
<li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li>
<li>范围 发生在一个类中 发生在继承类中</li>
<li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li>
<li>反射的应用很多，很多框架都有用到<ul>
<li>spring 的 ioc&#x2F;di 也是反射…</li>
<li>javaBean和jsp之间调用也是反射…</li>
<li>struts的 FormBean 和页面之间…也是通过反射调用…</li>
<li>JDBC 的 classForName()也是反射…</li>
<li>hibernate的 find(Class clazz) 也是反射…</li>
<li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li>
</ul>
</li>
</ul>
<h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>虚拟机把描述类的数据⽂件（字节码）加载到内存，并对数据进⾏验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使⽤的java类型（java.lang.Class对象）</li>
<li>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</li>
</ul>
<h4 id="类⽣命周期"><a href="#类⽣命周期" class="headerlink" title="类⽣命周期"></a>类⽣命周期</h4><ul>
<li>类加载过程：读取⼆进制字节流到JVM—&gt;验证格式语义等—&gt;为静态变量分配内存空间—&gt;常量池引⽤解析—&gt;执⾏static标识的代码<ul>
<li>a. 加载过程：通过⼀个类的全限定名来获取定义此类的⼆进制字节流，将这个字节流所代表的静态存储结构转化为⽅法区的运⾏时数据结构。在内存中(⽅法区)⽣成⼀个代表这个类的java.lang.Class对象，作为⽅法区这个类的各种数据的访问⼊⼝；</li>
<li>b. 验证过程：为了确保Class⽂件的字节流中包含的信息符合当前虚拟机的要求，⽂件格式验证、元数据验证、字节码验证、符号引⽤验证；</li>
<li>c. 准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在⽅法区中进⾏分配；准备阶段，static对象会被设置默认值，static ﬁnal对象会被赋上给予的值。</li>
<li>d. 解析阶段：虚拟机将常量池内的符号引⽤替换为直接引⽤的过程。<ul>
<li>i. 符号引⽤：字符串，引⽤对象不⼀定被加载；</li>
<li>ii. 直接引⽤：指针或者地址偏移量，引⽤对象⼀定在内存中。</li>
</ul>
</li>
<li>e. 初始化阶段：类初始化阶段是类加载过程的最后⼀步。初始化阶段就是执⾏类构造器<clint>()⽅法的过程。</li>
<li>f. 使⽤阶段</li>
<li>g. 卸载阶段：</li>
</ul>
</li>
</ul>
<h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><ul>
<li>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</li>
<li>主要有一下四种类加载器:<ul>
<li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li>
<li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li>
</ul>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li>java默认提供三个类加载器：<ul>
<li>a. 启动类加载器（BootStrap ClassLoader） 启动ClassLoader（sun.boot.class.path）：最顶层的加载类，主要加载jdk中的核⼼库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。Bootstrap ClassLoader不继承⾃ClassLoader，因为它不是⼀个普通的Java类，底层由C++编写，已嵌⼊到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核⼼类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</li>
<li>b. 扩展类加载器（Extension ClassLoader）扩展ClassLoader（java.ext.dirs）：扩展的类加载器，加载⽬录%JRE_HOME%\lib\ext⽬录下的jar包和class⽂件。还可以加载-D java.ext.dirs选项指定的⽬录。</li>
<li>c. App ClassLoader应⽤ClassLoader&#x2F;系统ClassLoader（java.class.path）：也称为SystemAppClass 加载当前应⽤的classpath的所有类。除了BootStrap ClassLoader，每个ClassLoader都有⼀个Parent作为⽗亲。</li>
</ul>
</li>
<li>双亲委派机制：<ul>
<li>定义：当⼀个ClassLoader实例需要加载某个类时，它会试图亲⾃搜索某个类之前，先把这个任务委托给它的⽗类加载器，这个过程是由上⾄下依次检查的，⾸先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader进⾏加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的⽂件系统或⽹络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类⽣成⼀个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</li>
<li>作⽤：<ul>
<li>避免重复加载；</li>
<li>考虑到安全因素，避免⾃定义的类去替代系统类，如String。</li>
<li>JVM如何判定两个class是否相同？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，⽽且要判断是否由同⼀个类加载器实例加载的。只有两者同时满⾜的情况下，JVM才认为这两个class是相同的。<ul>
<li>⾃底向上检查类是否已经加载；</li>
<li>⾃顶向下尝试加载类。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>custom classloader：⾃定义classloader<ul>
<li>Java中提供的默认ClassLoader，只加载指定⽬录下的jar和class，如果我们想加载其它位置的类或jar时，就需要定义⾃⼰的ClassLoader。</li>
<li>步骤：<ul>
<li>继承java.lang.ClassLoader</li>
<li>重写⽗类的findClass⽅法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="引起类加载的五个⾏为"><a href="#引起类加载的五个⾏为" class="headerlink" title="引起类加载的五个⾏为"></a>引起类加载的五个⾏为</h4><ul>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li>
<li>反射调⽤的时候，如果类没有进⾏过初始化，则需要先触发其初始化</li>
<li>⼦类初始化的时候，如果其⽗类还没初始化，则需先触发其⽗类的初始化</li>
<li>虚拟机执⾏主类的时候(有 main(string[] args))</li>
<li>JDK1.7 动态语⾔⽀持</li>
</ul>
<h4 id="java对象创建时机"><a href="#java对象创建时机" class="headerlink" title="java对象创建时机"></a>java对象创建时机</h4><ul>
<li>使⽤new关键字创建对象</li>
<li>使⽤Class类的newInstance⽅法(反射机制)</li>
<li>使⽤Constructor类的newInstance⽅法(反射机制)</li>
<li>使⽤Clone⽅法创建对象</li>
<li>使⽤(反)序列化机制创建对象</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机（JVM）</title>
    <url>/publishes/8270315bab4b.html</url>
    <content><![CDATA[<h1 id="什么是垃圾收集（GC）"><a href="#什么是垃圾收集（GC）" class="headerlink" title="什么是垃圾收集（GC）"></a>什么是垃圾收集（GC）</h1><p>垃圾收集（GC），是Java虚拟机释放内存的机制，目的在于清除不再使用的对象。</p>
<p>GC通过确定对象是否被活动对象引用来确定是否收集该对象，判断是否可以收集的方式是对象引用遍历。对象引用遍历从一组对象（GC Root）开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象到达，则将它作为垃圾收集的目标对象。在对象遍历阶段，GC必须记住哪些对象可以到达，以便后续删除不可到达的对象，这个过程称为标记（marking）对象。</p>
<p>下一步，GC要删除不可到达的对象。删除对象分两种情况，清除和压缩。如果GC只是扫描堆栈，删除未标记的对象，并释放它们的内存，这叫做清除（sweeping），清除的问题在于会造成内存碎片，也就是内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大。如果GC将对象进行移动规整，这叫做压缩（compact），这样可以重新组织内存中的对象，避免内存碎片。</p>
<p>Java中可作为GC Root的对象有：虚拟机栈中引用的对象（本地变量表）、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中引用的对象（Native对象）。</p>
<p>有3个内存区域不需要垃圾回收：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期和线程是同步的，随着线程的销毁，他们占用的内存会自动释放。只有方法区和堆区需要进行垃圾回收。</p>
<h1 id="几种垃圾回收机制"><a href="#几种垃圾回收机制" class="headerlink" title="几种垃圾回收机制"></a>几种垃圾回收机制</h1><p><strong>标记-清除收集器</strong><br>这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片。</p>
<p><strong>标记-压缩收集器</strong><br>有时也叫标记-清除-压缩收集器，与标记-清除收集器有相同的标记阶段，在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种收集器也停止其他操作。由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。该算法适用于旧生代。</p>
<p><strong>复制收集器</strong><br>这种收集器将堆栈分为两个域，常称为半空间，每次仅使用一半的空间，JVM生成的新对象则放在另一半空间中，GC运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域。当存活的对象较少时，复制算法会比较高效，新生代的Eden区就是采用这种算法，其带来的成本是需要一块额外的空闲空间和对象的移动。</p>
<p><strong>增量收集器</strong><br>增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾，这会造成较小的应用程序中断。</p>
<p><strong>分代收集器</strong><br>这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象。JVM生成的新对象一般放在其中的某个域中，过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中。分代收集器对不同的域使用不同的算法以优化性能。</p>
<p><strong>并发收集器</strong><br>并发收集器与应用程序同时运行，这些收集器在某点上（比如压缩时）一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低。</p>
<p><strong>并行收集器</strong><br>并行收集器使用某种传统的算法，并使用多线程并行的执行它们的工作。</p>
<h1 id="Sun-HotSpot-虚拟机"><a href="#Sun-HotSpot-虚拟机" class="headerlink" title="Sun HotSpot 虚拟机"></a>Sun HotSpot 虚拟机</h1><p>Sun HotSpot 使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域。JVM生成的所有新对象放在新域中，一旦对象经历了一定数量的垃圾收集循环后，便进入旧域。在永久域中存储class和method对象。可使用<code>-Xms</code>和<code>-Xmx</code>控制整个堆的原始大小或最大值。</p>
<p>默认状态下，HotSpot在新域中使用复制收集器，对旧域使用标记-清除-压缩收集器。新域一般分为三个部分：Eden空间、2个救助空间。Eden用于生成新的对象，当Eden充满时，收集器停止应用程序，把所有可到达对象复制到from救助空间，一旦当前的from救助空间充满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们达到进入旧域的所需年龄并转入旧域。</p>
<p>在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。如果能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能只适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价。</p>
<h1 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h1><p>JVM中的堆，一般分为三大部分：新生代、老年代、永久代。</p>
<p><strong>新生代（Youn Generation）</strong><br>主要是用来存放新生的对象，一般占据堆的1&#x2F;3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。Eden区是Java新对象的出生地，但如果新创建的对象占用内存很大，则直接分配到老年代。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。ServivorTo是保留了一次MinorGC过程中的幸存者。ServivorFrom是上一次GC的幸存者，作为这一次GC的被扫描者。当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。</p>
<p>MinorGC的过程采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则复制到老年代区）；同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</p>
<p><strong>老年代（Old Generation）</strong><br>老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时，也会提前触发一次MajorGC进行垃圾回收腾出空间。MajorGC采用标记—清除算法，首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p>
<p><strong>永久代（Permanent Generation）</strong><br>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在被加载的时候被放入永久区域。它和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代，元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代之间最大的区别在于，元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中。这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。在Sun的JVM中就是方法区的意思，尽管大多数JVM没有这一代。</p>
<h1 id="Major-GC和Full-GC区别"><a href="#Major-GC和Full-GC区别" class="headerlink" title="Major GC和Full GC区别"></a>Major GC和Full GC区别</h1><p>Full GC收集young gen、old gen、perm gen；Major GC，有时又叫old gc，只收集old gen。</p>
<h1 id="常⽤的GC策略和触发时机"><a href="#常⽤的GC策略和触发时机" class="headerlink" title="常⽤的GC策略和触发时机"></a>常⽤的GC策略和触发时机</h1><p><strong>YGC（Young GC）</strong><br>Young GC是对新⽣代堆进⾏GC。频率⽐较⾼，因为⼤部分对象的存活寿命较短，在新⽣代⾥被回收。性能耗费较⼩。触发时机是Eden区空间不⾜。</p>
<p><strong>FGC（Full GC）</strong><br>Full GC是全堆范围的GC。默认堆空间使⽤到达80%(可调整)的时候会触发FGC。以我们⽣产环境为例，⼀般⽐较少会触发FGC，有时10天或⼀周左右会有⼀次。触发时机是Old空间不⾜或者Perm空间不⾜。</p>
<h1 id="什么时候会触发一个对象的回收"><a href="#什么时候会触发一个对象的回收" class="headerlink" title="什么时候会触发一个对象的回收"></a>什么时候会触发一个对象的回收</h1><ul>
<li>对象没有引用</li>
<li>作用域发生未捕获异常</li>
<li>程序在作用域正常执行完毕</li>
<li>程序执行了System.exit()</li>
<li>程序发生意外终止（被杀进程等）</li>
</ul>
<h1 id="Java中存在四种引用"><a href="#Java中存在四种引用" class="headerlink" title="Java中存在四种引用"></a>Java中存在四种引用</h1><p><strong>强引用</strong><br>只要引用存在，垃圾回收器永远不会回收。new出来的对象都是强引用，GC无论如何都不会回收，即使抛出OOM异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p><strong>软引用</strong><br>非必须引用，只有当JVM内存不足时才会被回收，内存溢出之前进行回收，可以通过以下代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">sf.get(); <span class="comment">// 有时候会返回null</span></span><br></pre></td></tr></table></figure>
<p>这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象。当这个对象被标记为需要回收的对象时，则返回null。软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p>
<p><strong>弱引用</strong><br>第二次垃圾回收时回收，可以通过如下代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wf.get(); <span class="comment">// 有时候会返回null</span></span><br><span class="line">wf.isEnQueued(); <span class="comment">// 返回是否被垃圾回收器标记为即将回收的垃圾</span></span><br></pre></td></tr></table></figure>
<p>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记，只要GC,就会立马回收，不管内存是否充足。</p>
<p><strong>虚引用（幽灵&#x2F;幻影引用）</strong><br>垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj=<span class="literal">null</span>;</span><br><span class="line">pf.get(); <span class="comment">// 永远返回null</span></span><br><span class="line">pf.isEnQueued(); <span class="comment">// 返回从内存中已经删除</span></span><br></pre></td></tr></table></figure>
<p>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。它唯一的作用就是做一些跟踪记录，辅助finalize函数的使用。</p>
<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p>JVM把内存划分成了如下5个区域：方法区（Method Area）、堆区（Heap）、虚拟机栈（VM Stack）、本地方法栈（Native Method Stack）、程序计数器（Program Counter Register）。线程共享区域包含包括堆和方法区。线程不共享区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。</p>
<p><strong>方法区（Method Area）</strong><br>主要存放类与类之间关系的数据，而这部分数据被加载到内存之后，基本上是不会发生变更的。方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出<code>OutOfMemory：PermGen Space</code>异常。在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation）。一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载。方法区的数据因为回收率非常小，而成本又比较高，一般认为是“性价比”非常差的，所以Sun自己的虚拟机HotSpot中是不回收的。但是在现在高性能分布式J2EE的系统中，我们大量用到了反射、动态代理、CGLIB、JSP和OSGI等，这些类频繁的调用自定义类加载器，都需要动态的加载和卸载了，以保证永久带不会溢出，他们通过自定义的类加载器进行了各项操作，因此在实际的应用开发中，类也是被经常加载和卸载的，方法区也是会被回收的。</p>
<p>方法区的回收条件非常苛刻，只有同时满足以下三个条件才会被回收：该类的所有实例都已经被回收；加载该类的ClassLoad已经被回收；Class对象无法通过任何途径访问(包括反射)，该类对应的反射类java.lang.Class对象没有被任何地方引用。</p>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的<code>intern()</code>方法，作用是String类维护了一个常量池，如果调用的字符<code>&quot;hello&quot;</code>已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。保存装载的类的元信息包括类型的常量池，字段、⽅法信息，⽅法字节码。jdk6时，String等常量信息置于⽅法区，jdk7移到了堆中，通常和永久区（Perm）关联在⼀起。</p>
<p><strong>堆区（Heap）</strong><br>堆区是GC最频繁的，也是理解GC机制最重要的区域。堆区由所有线程共享，在虚拟机启动时创建。堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。应⽤系统对象都保存在java堆中。对分代GC来说，堆也是分代的。</p>
<p><strong>虚拟机栈（VM Stack）</strong><br>虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样。每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。局部变量表中存储着方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：内存空间可以在编译期间就确定，运行时不再改变。虚拟机栈定义了两种异常类型：StackOverFlowError（栈溢出）和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError，不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</p>
<p><strong>本地方法栈（Native Method Stack）</strong><br>本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法。在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</p>
<p><strong>程序计数器（Program Counter Register）(PC寄存器)</strong><br>主要用于记录线程执行的行号等一些信息，这块区域也是被认为是唯一一块不会内存溢出的区域。在SunHostSpot的虚拟机中，对于程序计数器是不回收的。每个线程拥有⼀个pc寄存器，指向下⼀条指令的地址。程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序员无法操作它。 它的作用是，JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。每个程序计数器只能记录一个线程的行号，因此它是线程私有的，如果程序当前正在执行的是一个java方法，则程序计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则计数器的值为空。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><strong>Serial收集器</strong><br>Serial收集器属于串行收集器。比较适合于只有一个处理器的系统。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，直到它回收结束为止，因此又号称“Stop The World”的垃圾回收器。串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld。在串行处理器中minor和major GC过程都是用一个线程进行回收的。</p>
<p><strong>ParNew收集器</strong><br>ParNew收集器其实就是多线程版本的Serial收集器。同样有Stop The World的问题，它是多CPU模式下的首选回收器，该回收器在单CPU的环境下回收效率远远低于Serial收集器。它是Server模式下的默认收集器。它可以与CMS GC配合。</p>
<p><strong>ParallelScavenge</strong><br>ParallelScavenge又被称为是吞吐量优先的收集器。ParallelScavenge所提到的吞吐量&#x3D;程序运行时间&#x2F;(JVM执行回收的时间+程序运行时间)，假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在交互不多的云端，比较适合使用该回收器。在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式。</p>
<p><strong>ParallelOld</strong><br>ParallelOld是老生代并行收集器的一种，使用标记整理算法，是老生代吞吐量优先的一个收集器。Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</p>
<p><strong>SerialOld</strong><br>SerialOld是旧生代Client模式下的默认收集器，单线程执行。Serial Old是Serial收集器的老年代版本。它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。</p>
<p><strong>CMS</strong><br>CMS又称响应时间优先（最短回收停顿）的回收器。使用并发模式回收垃圾。CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。</p>
<p>CMS对CPU是非常敏感的，它的回收线程数&#x3D;（CPU+3）&#x2F;4，因此当CPU是2核的时候，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。</p>
<p>CMS模式主要分为4个过程。在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程。并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。CMS为了确保能够扫描到所有的对象，避免在Initial Marking中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack中，如依赖的对象地址在其之后，则仅标记该对象。在进行Concurrent Marking时minor GC也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS为了应对这样的并发现象，提供了一个Mod Union Table来进行记录，在这个Mod Union Table中记录每次minor GC后修改了的Card的信息。这也是ParallelScavenge不能和CMS一起使用的原因。由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收。</p>
<p>收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间。常见的B&#x2F;S架构的应用就适合这种收集器，因为其高并发、高响应的特点。CMS收集器的优点：并发收集、低停顿，但远没有达到完美。CMS收集器的缺点：CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降；CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC；</p>
<p><strong>GarbageFirst(G1)</strong><br>他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间。相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿。</p>
<h1 id="JVM的内存分配与回收策略"><a href="#JVM的内存分配与回收策略" class="headerlink" title="JVM的内存分配与回收策略"></a>JVM的内存分配与回收策略</h1><p>优先在Edon上分配对象，对象直接进入老生代。年长者（长期存活对象）进入老生代。担保GC（担保minorGC），就是担保minorGC能够满足当前的存储空间，而无需触发老生代的回收，由于大部分对象都是朝生夕死的，因此，在实际开发中这种很起效。但是也有可能会发生担保失败的情况，当担保失败的时候会触发FullGC，但是失败毕竟是少数，因此这种一般是很划算的。默认情况是是开启担保的，无需设置参数。</p>
<h1 id="当对象A创建之后，对象A在各个区之间的流转过程"><a href="#当对象A创建之后，对象A在各个区之间的流转过程" class="headerlink" title="当对象A创建之后，对象A在各个区之间的流转过程"></a>当对象A创建之后，对象A在各个区之间的流转过程</h1><p>对象A被new出来之后，是被存放在Eden（伊甸园）区的。当发⽣⼀次GC后，Eden区存活下来的对象A会被复制到s1区，s0中存活的对象也会被复制到s1中。如果对象年龄超过阈值年龄（默认15岁），会被复制到⽼年区。部分对象也需要⽼年代分担。GC会清空Eden和s0中存储的所有对象；交换s0和s1的⻆⾊； 重复上⾯的步骤。</p>
<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>每⼀个线程有⼀个⼯作内存，和主存独⽴。⼯作内存存放主存中变量的值的拷⻉。对于普通变量，⼀个线程中更新的值，不能⻢上反应在其他变量中，如果需要在其他线程中⽴即可⻅，需要使⽤volatile关键字。volatile不能代替锁，⼀般认为volatile⽐锁性能好（不绝对）。</p>
<h1 id="Java-中堆和栈有什么不同"><a href="#Java-中堆和栈有什么不同" class="headerlink" title="Java 中堆和栈有什么不同"></a>Java 中堆和栈有什么不同</h1><p>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><p><strong>调优时机</strong><br>heap 内存（⽼年代）持续上涨达到设置的最⼤内存值；Full GC 次数频繁；GC 停顿时间过⻓（超过1秒）；应⽤出现OutOfMemory 等内存异常；应⽤中有使⽤本地缓存且占⽤⼤量内存空间；系统吞吐量与响应性能不⾼或下降。</p>
<p><strong>调优原则</strong><br>多数的Java应⽤不需要在服务器上进⾏JVM优化；多数导致GC问题的Java应⽤，都不是因为我们参数设置错误，⽽是代码问题；在应⽤上线之前，先考虑将机器的JVM参数设置到最优（最适合）；减少创建对象的数量；减少使⽤全局变量和⼤对象；JVM优化是到最后不得已才采⽤的⼿段；在实际使⽤中，分析GC情况优化代码⽐优化JVM参数更好。</p>
<p><strong>调优⽬标</strong><br>GC低停顿；GC低频率；低内存占⽤；⾼吞吐量。</p>
<p><strong>调优步骤</strong><br>分析GC⽇志及dump⽂件，判断是否需要优化，确定瓶颈问题点；确定JVM调优量化⽬标；确定JVM调优参数（根据历史JVM参数来调整）；调优⼀台服务器，对⽐观察调优前后的差异；不断的分析和调整，知道找到合适的JVM参数配置；找到最合适的参数，将这些参数应⽤到所有服务器，并进⾏后续跟踪。</p>
<h1 id="触发full-gc的场景及应对策略"><a href="#触发full-gc的场景及应对策略" class="headerlink" title="触发full gc的场景及应对策略"></a>触发full gc的场景及应对策略</h1><ul>
<li><code>System.gc()</code>⽅法的调⽤，应对策略：通过<code>-XX:+DisableExplicitGC</code>来禁⽌调⽤<code>System.gc()</code>;</li>
<li>⽼年代代空间不⾜，应对策略：让对象在Minor GC阶段被回收，让对象在新⽣代多存活⼀段时间，不要创建过⼤的对象及数组;</li>
<li>永⽣区空间不⾜，应对策略：增⼤PermGen空间；</li>
<li>GC时出现promotionfailed和concurrent mode failure，应对策略：增⼤survivor space；</li>
<li>Minor GC后晋升到旧⽣代的对象⼤⼩⼤于⽼年代的剩余空间，应对策略：增⼤Tenured space 或下调<code>CMSInitiatingOccupancyFraction=60</code>；</li>
<li>内存持续增涨达到上限导致Full GC，应对策略：通过dumpheap 分析是否存在内存泄漏。</li>
</ul>
<h1 id="如何查看JVM内存使⽤情况"><a href="#如何查看JVM内存使⽤情况" class="headerlink" title="如何查看JVM内存使⽤情况"></a>如何查看JVM内存使⽤情况</h1><p>可以使⽤JDK⾃带的JConsole、JVisualVM、JMap、JHat等⼯具，或者使⽤第三⽅⼯具，⽐如 Eclipse Memory Analyzer。</p>
<h1 id="内存溢出的可能原因和解决⽅法"><a href="#内存溢出的可能原因和解决⽅法" class="headerlink" title="内存溢出的可能原因和解决⽅法"></a>内存溢出的可能原因和解决⽅法</h1><p><strong>内存溢出原因</strong><br>数据加载过多，如一次性从数据库中取出过多数据；集合类中有对对象的引⽤，⽤完后没有清空或者集合对象未置空导致引⽤存在等，使得JVM⽆法回收；死循环，过多重复对象；启动参数内存值设定的过⼩。</p>
<p><strong>解决⽅法</strong><br>修改JVM启动参数，加内存(-Xms，-Xmx)；错误⽇志，是否还有其他错误；代码⾛查。</p>
<h1 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h1><p>未对作废数据内存单元置为null，尽早释放⽆⽤对象的引⽤，使⽤临时变量时，让引⽤变量在推出活动域后⾃动设置为null，暗示垃圾收集器收集；程序避免⽤String拼接，⽤StringBuffer，因为每个String会占⽤内存⼀块区域；尽量少⽤静态变量（全局不会回收）；不要集中创建对象尤其⼤对象，可以使⽤流操作；尽量使⽤对象池，不再循环中创建对象，优化配置；创建对象到单例getInstance中，对象⽆法回收被单例引⽤；服务器session时间设置过⻓也会引起内存泄漏。</p>
<h1 id="⽅法区oom"><a href="#⽅法区oom" class="headerlink" title="⽅法区oom"></a>⽅法区oom</h1><p>原因是运⾏时产⽣⼤量的类去填满⽅法区，直到溢出。⽅法区⽤于存放Class的相关信息，如：类名，访问修饰符，常量池，字符描述，⽅法描述等。</p>
<h1 id="哪些情况下对象会进⼊⽼年代"><a href="#哪些情况下对象会进⼊⽼年代" class="headerlink" title="哪些情况下对象会进⼊⽼年代"></a>哪些情况下对象会进⼊⽼年代</h1><p>新⽣代对象每次经历⼀次minor gc，年龄会加1，当达到年龄阈值（默认为15岁）会直接进⼊⽼年代；⼤对象直接进⼊⽼年代；新⽣代复制算法需要⼀个survivor区进⾏轮换备份，如果出现⼤量对象在minor gc后仍然存活的情况时，就需要⽼年代进⾏分配担保，让survivor⽆法容纳的对象直接进⼊⽼年代；如果在Survivor空间中相同年龄所有对象⼤⼩的总和⼤于Survivor空间的⼀半，年龄⼤于或等于该年龄的对象就可以直接进⼊年⽼代。</p>
<h1 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h1><p>GC的时候必须要等到Java线程都进入到safepoint的时候VMThread才能开始执行GC。SafePoint包括：循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)、方法返回前、调用方法的call之后、抛出异常的位置。</p>
<h1 id="简述Java垃圾回收机制"><a href="#简述Java垃圾回收机制" class="headerlink" title="简述Java垃圾回收机制"></a>简述Java垃圾回收机制</h1><p>在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。   </p>
<h1 id="查看配置JVM内存信息"><a href="#查看配置JVM内存信息" class="headerlink" title="查看配置JVM内存信息"></a>查看配置JVM内存信息</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().maxMemory(); <span class="comment">// 最大可用内存，对应-Xmx</span></span><br><span class="line">Runtime.getRuntime().freeMemory(); <span class="comment">// 当前JVM空闲内存</span></span><br><span class="line">Runtime.getRuntime().totalMemory(); <span class="comment">// 当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和</span></span><br></pre></td></tr></table></figure>

<h1 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h1><ul>
<li><code>-server</code>启用服务器模式（如果CPU多，服务器机建议使用此项）</li>
<li><code>-Xms</code>设置启动JVM时的堆内存空间</li>
<li><code>-Xmx</code>设置堆内存最⼤限制</li>
<li><code>-XX:NewRatio</code>设置新⽣代和⽼年代的占⽐</li>
<li><code>-XX:NewSize</code>设置新⽣代空间</li>
<li><code>-XX:SurvivorRatio</code>设置伊甸园空间和幸存者空间的占⽐</li>
<li><code>-XX:MaxTenuringThreshold</code>设置对象进⼊⽼年代的年龄阈值</li>
<li>设定垃圾回收器<ul>
<li>年轻代：<code>-XX:+UseParNewGC</code></li>
<li>⽼年代：<code>-XX:+UseConcMarkSweepGC</code></li>
</ul>
</li>
</ul>
<h1 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h1><ul>
<li>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</li>
<li>jps，JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</li>
<li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li>
<li>jmap，JVM Memory Map命令用于生成heap dump文件</li>
<li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li>
<li>jstack，用于生成java虚拟机当前时刻的线程快照</li>
<li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数</li>
<li>jstack可以看当前栈的情况，jmap查看内存，jhat 进行dump堆的信息</li>
<li>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto</li>
<li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li>
<li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等</li>
<li>GChisto，一款专业分析gc日志的工具</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/publishes/b3085e36f5dd.html</url>
    <content><![CDATA[<h1 id="什么是Kafka"><a href="#什么是Kafka" class="headerlink" title="什么是Kafka"></a>什么是Kafka</h1><ul>
<li>Kafka是一个分布式发布&#x2F;订阅消息系统</li>
<li>它是一个可扩展的，容错的发布-订阅消息系统，它使我们能够构建分布式应用程序</li>
<li>这是一个Apache顶级项目</li>
<li>Kafka适合离线和在线消息消费</li>
</ul>
<h1 id="什么情况会导致kafka运行变慢？"><a href="#什么情况会导致kafka运行变慢？" class="headerlink" title="什么情况会导致kafka运行变慢？"></a>什么情况会导致kafka运行变慢？</h1><ul>
<li>cpu性能瓶颈</li>
<li>磁盘读写瓶颈</li>
<li>网络瓶颈</li>
</ul>
<h1 id="kafka可以脱离zookeeper单独使用吗？为什么？"><a href="#kafka可以脱离zookeeper单独使用吗？为什么？" class="headerlink" title="kafka可以脱离zookeeper单独使用吗？为什么？"></a>kafka可以脱离zookeeper单独使用吗？为什么？</h1><ul>
<li>不能</li>
<li>因为kafka使用zookeeper管理和协调kafka的节点服务器</li>
</ul>
<h1 id="kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？"><a href="#kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？" class="headerlink" title="kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？"></a>kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候kafka将如何处理？</h1><ul>
<li>这个时候kafka会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据</li>
</ul>
<h1 id="kafka有几种数据保留的策略？"><a href="#kafka有几种数据保留的策略？" class="headerlink" title="kafka有几种数据保留的策略？"></a>kafka有几种数据保留的策略？</h1><ul>
<li>两种<ul>
<li>按照过期时间保留</li>
<li>按照存储的消息大小保留</li>
</ul>
</li>
</ul>
<h1 id="Zookeeper对于kafka的作用是什么？"><a href="#Zookeeper对于kafka的作用是什么？" class="headerlink" title="Zookeeper对于kafka的作用是什么？"></a>Zookeeper对于kafka的作用是什么？</h1><ul>
<li>Zookeeper主要用于在集群中不同节点之间进行通信</li>
<li>在kafka中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取</li>
<li>它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等</li>
</ul>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>消息队列</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/publishes/f17ba5c005d6.html</url>
    <content><![CDATA[<h1 id="使⽤两种命令创建⼀个⽂件？"><a href="#使⽤两种命令创建⼀个⽂件？" class="headerlink" title="使⽤两种命令创建⼀个⽂件？"></a>使⽤两种命令创建⼀个⽂件？</h1><ul>
<li>touch a.txt</li>
<li>vi a.txt</li>
<li>mkdir abc</li>
<li>cat &gt; a.txt 建⽴⼀⽂件，然后把接下来的键盘输⼊写⼊⽂件，直到按Ctrl+D为⽌.</li>
</ul>
<h1 id="硬链接和软连接的区别？"><a href="#硬链接和软连接的区别？" class="headerlink" title="硬链接和软连接的区别？"></a>硬链接和软连接的区别？</h1><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul>
<li>⽂件有相同的 inode 及 data block；</li>
<li>只能对已存在的⽂件进⾏创建；</li>
<li>不能交叉⽂件系统进⾏硬链接的创建；</li>
<li>不能对⽬录进⾏创建，只可对⽂件创建；</li>
<li>删除⼀个硬链接⽂件并不影响其他有相同 inode 号的⽂件。</li>
</ul>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><ul>
<li>软链接有⾃⼰的⽂件属性及权限等；</li>
<li>可对不存在的⽂件或⽬录创建软链接；</li>
<li>软链接可交叉⽂件系统；</li>
<li>软链接可对⽂件或⽬录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的⽂件，但若被指向的原⽂件被删除，则相关软连接被称为死链接（即 dangling<br>link，若被指向路径⽂件被重新创建，死链接可恢复为正常的软链接）。</li>
</ul>
<h1 id="linux常⽤命令有哪些"><a href="#linux常⽤命令有哪些" class="headerlink" title="linux常⽤命令有哪些"></a>linux常⽤命令有哪些</h1><ul>
<li>查找关闭端⼝进程 netstat -nlp | grep :3306 kill pid</li>
<li>删除⽂件 rm -rf</li>
<li>查找⽇志 cat xx.log | grep ‘xxx’ | more</li>
<li>解压tar.gz tar -xzvf file.tar.gz</li>
<li>创建⽂件 touch filename cat &gt; filename</li>
<li>修改⽂件 vi</li>
</ul>
<h1 id="怎么查看⼀个java线程的资源耗⽤"><a href="#怎么查看⼀个java线程的资源耗⽤" class="headerlink" title="怎么查看⼀个java线程的资源耗⽤"></a>怎么查看⼀个java线程的资源耗⽤</h1><ul>
<li>linux下，所有的java内部线程，其实都对应了⼀个进程id，也就是说，linux上的jvm将java程序中的线程映射为操作系统进程。</li>
<li>jps -lvm或者ps -ef | grep java查看当前机器上运⾏的Java应⽤进程</li>
<li>top -Hp pid可以查看Java所有线程的资源耗⽤</li>
<li>printf “%x\n” pid等到线程ID的16进制</li>
<li>jstack Java应⽤进程ID | grep 线程ID的16进制</li>
</ul>
<h1 id="Load过⾼的可能性有哪些？"><a href="#Load过⾼的可能性有哪些？" class="headerlink" title="Load过⾼的可能性有哪些？"></a>Load过⾼的可能性有哪些？</h1><ul>
<li>cpu load的飙升，⼀⽅⾯可能和full gc的次数增⼤有关，⼀⽅⾯可能和死循环有关系</li>
</ul>
<h1 id="etc-hosts⽂件什么作⽤"><a href="#etc-hosts⽂件什么作⽤" class="headerlink" title="&#x2F;etc&#x2F;hosts⽂件什么作⽤"></a>&#x2F;etc&#x2F;hosts⽂件什么作⽤</h1><ul>
<li>在当前主机给ip设置别名，通过该别名可以访问到该ip地址，通过别名、ip访问的效果是⼀样的</li>
</ul>
<h1 id="如何快速的将⼀个⽂本中的”abc”转换成”xyz”？"><a href="#如何快速的将⼀个⽂本中的”abc”转换成”xyz”？" class="headerlink" title="如何快速的将⼀个⽂本中的”abc”转换成”xyz”？"></a>如何快速的将⼀个⽂本中的”abc”转换成”xyz”？</h1><ul>
<li>vi filename编辑⽂本，按Esc键，输⼊:%s&#x2F;abc&#x2F;xyz&#x2F;g</li>
</ul>
<h1 id="如何在log⽂件中搜索找出error的⽇志？"><a href="#如何在log⽂件中搜索找出error的⽇志？" class="headerlink" title="如何在log⽂件中搜索找出error的⽇志？"></a>如何在log⽂件中搜索找出error的⽇志？</h1><ul>
<li>cat xx.log | grep ‘error’</li>
</ul>
<h1 id="发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件"><a href="#发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件" class="headerlink" title="发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件?"></a>发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件?</h1><ul>
<li>find . -type f -size +100M | xargs du -h | sort -nr</li>
</ul>
<h1 id="Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）"><a href="#Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）" class="headerlink" title="Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）"></a>Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）</h1><h4 id="业务⽇志相关"><a href="#业务⽇志相关" class="headerlink" title="业务⽇志相关"></a>业务⽇志相关</h4><ul>
<li>less或者more</li>
<li>grep</li>
<li>tail -f filename</li>
<li>切忌vim直接打开⼤⽇志⽂件，因为会直接加载到内存的</li>
</ul>
<h4 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h4><ul>
<li>登录线上库，show processlist查看数据库连接情况</li>
</ul>
<h4 id="jvm相关："><a href="#jvm相关：" class="headerlink" title="jvm相关："></a>jvm相关：</h4><ul>
<li>jps显示java进程</li>
<li>jinfo实时查看和调整jvm参数</li>
<li>jstat监控jvm各种运⾏状态信息；</li>
<li>jstack(Stack Trace for Java)命令⽤于⽣成JVM进程当前时刻的线程的调⽤堆栈，可以⽤来定位线程间死锁、<br>锁等待、等待外部资源等</li>
<li>jmap(Memory Map for Java) 命令⽤于⽣成堆转储快照dump⽂件，除了这种⽅式还可以通过-<br>XX:HeapDumpOnOutOfMemoryError参数，可以在虚拟机发⽣OOM的时候⾃动⽣成堆的dump⽂件，或者kill -3<br>命令发出进程退出信号”吓唬”⼀下虚拟机，也能拿到dump⽂件。</li>
</ul>
<h4 id="oom问题："><a href="#oom问题：" class="headerlink" title="oom问题："></a>oom问题：</h4><ul>
<li>配置了-XX:+HeapDumpOnOutOfMemoryError, 在发⽣OOM的时候会在-XX:HeapDumpPath⽣成堆的dump⽂<br>件，结合MAT，可以对dump⽂件进⾏分析，查找出发⽣OOM的原因。</li>
<li>另外⼿动dump堆快照，可以使⽤命令jmap -dump:format&#x3D;b,file&#x3D;file_name pid 或者kill -3 pid</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul>
<li>jps -v</li>
<li>jstack -l pid</li>
</ul>
<h4 id="线程block、线程数暴涨："><a href="#线程block、线程数暴涨：" class="headerlink" title="线程block、线程数暴涨："></a>线程block、线程数暴涨：</h4><ul>
<li>jstack -l pid |wc -l</li>
<li>jstack -l pid |grep “BLOCKED”|wc -l</li>
<li>jstack -l pid |grep “Waiting on condition”|wc -l<br>线程block问题⼀般是等待io、等待⽹络、等待监视器锁等造成，可能会导致请求超时、造成造成线程数暴涨导致系统502等。</li>
</ul>
<h4 id="服务器问题："><a href="#服务器问题：" class="headerlink" title="服务器问题："></a>服务器问题：</h4><h5 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h5><ul>
<li>top</li>
</ul>
<h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><ul>
<li>free -m -c10 -s1：<ul>
<li>-m：以MB为单位显示，其他的有-k -g -b</li>
<li>-s: 间隔多少秒持续观察内存使⽤状况</li>
<li>-c:观察多少次</li>
</ul>
</li>
<li>vmstat 1 10：1表示每隔1s输出⼀次,10 表示输出10次<ul>
<li>r: 运⾏队列中进程数量，这个值也可以判断是否需要增加CPU。（⻓期⼤于1）</li>
<li>b: 等待IO的进程数量。</li>
</ul>
</li>
</ul>
<h5 id="io"><a href="#io" class="headerlink" title="io"></a>io</h5><ul>
<li>iostat -m 1 10：<ul>
<li>-m：某些使⽤block为单位的列强制使⽤MB为单位</li>
<li>1 10：数据显示每隔1秒刷新⼀次，共显示10次</li>
</ul>
</li>
</ul>
<h5 id="⽹络"><a href="#⽹络" class="headerlink" title="⽹络"></a>⽹络</h5><ul>
<li>netstat -antp：<ul>
<li>-a (all)显示所有选项，默认不显示LISTEN相关</li>
<li>-t (tcp)仅显示tcp相关选项</li>
<li>-u (udp)仅显示udp相关选项</li>
<li>-n 拒绝显示别名，能显示数字的全部转化成数字。</li>
<li>-l 仅列出有在 Listen (监听) 的服服务状态</li>
<li>-p 显示建⽴相关链接的程序名</li>
</ul>
</li>
</ul>
<h1 id="Thread-dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）"><a href="#Thread-dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）" class="headerlink" title="Thread dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）"></a>Thread dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）</h1><h4 id="Thread-Dump-能诊断的问题"><a href="#Thread-Dump-能诊断的问题" class="headerlink" title="Thread Dump 能诊断的问题"></a>Thread Dump 能诊断的问题</h4><ul>
<li>查找内存泄露，常⻅的是程序⾥load⼤量的数据到缓存；</li>
<li>发现死锁线程；</li>
</ul>
<h4 id="如何抓取Thread-Dump信息："><a href="#如何抓取Thread-Dump信息：" class="headerlink" title="如何抓取Thread Dump信息："></a>如何抓取Thread Dump信息：</h4><ul>
<li>⼀般当服务器挂起,崩溃或者性能底下时,就需要抓取服务器的线程堆栈(Thread Dump)⽤于后续的分析. 在实际运⾏中，往往⼀次 dump的信息，还不⾜以确认问题。为了反映线程状态的动态变化，需要接连多次做threaddump，每次间隔10-20s，建议⾄少产⽣三次 dump信息，如果每次 dump都指向同⼀个问题，我们才确定问题的典型性。</li>
</ul>
<h4 id="linux命令获取"><a href="#linux命令获取" class="headerlink" title="linux命令获取"></a>linux命令获取</h4><ul>
<li>ps –ef | grep java</li>
<li>kill -3 <pid></li>
</ul>
<h4 id="jdk⾃带⼯具获取"><a href="#jdk⾃带⼯具获取" class="headerlink" title="jdk⾃带⼯具获取"></a>jdk⾃带⼯具获取</h4><ul>
<li>jps 或 ps –ef|grepjava (获取PID)</li>
<li>jstack [-l ]<pid> | tee -a jstack.log (获取ThreadDump)</li>
</ul>
<h1 id="如何查看Java应⽤的线程信息？"><a href="#如何查看Java应⽤的线程信息？" class="headerlink" title="如何查看Java应⽤的线程信息？"></a>如何查看Java应⽤的线程信息？</h1><ul>
<li>通过top命令拿到线程的pid后使⽤jstack命令</li>
</ul>
<h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1><ul>
<li>wc -l</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Memcached</title>
    <url>/publishes/fe062138c36d.html</url>
    <content><![CDATA[<h1 id="memcached是怎么工作的？"><a href="#memcached是怎么工作的？" class="headerlink" title="memcached是怎么工作的？"></a>memcached是怎么工作的？</h1><ul>
<li>Memcached的神奇来自两阶段哈希（two-stage hash）</li>
<li>Memcached就像一个巨大的、存储了很多&lt;key,value&gt;对的哈希表。通过key，可以存储或查询任意的数据。 </li>
<li>客户端可以把数据存储在多台memcached上。当查询数据时，客户端首先参考节点列表计算出key的哈希值（阶段一哈希），进而选中一个节点；客户端将请求发送给选中的节点，然后memcached节点通过一个内部的哈希算法（阶段二哈希），查找真正的数据（item）。 </li>
<li>举个列子，假设有3个客户端1, 2, 3，3台memcached A, B, C：Client 1想把数据”barbaz”以key “foo”存储。Client 1首先参考节点列表（A, B, C），计算key “foo”的哈希值，假设memcached B被选中。接着，Client 1直接connect到memcached B，通过key “foo”把数据”barbaz”存储进去。Client 2使用与Client 1相同的客户端库（意味着阶段一的哈希算法相同），也拥有同样的memcached列表（A, B, C）。 于是，经过相同的哈希计算（阶段一），Client 2计算出key “foo”在memcached B上，然后它直接请求memcached B，得到数据”barbaz”。 </li>
<li>各种客户端在memcached中数据的存储形式是不同的（perl Storable, php serialize, java hibernate, JSON等）。一些客户端实现的哈希算法也不一样。但是，memcached服务器端的行为总是一致的。 </li>
<li>最后，从实现的角度看，memcached是一个非阻塞的、基于事件的服务器程序。这种架构可以很好地解决C10K problem ，并具有极佳的可扩展性。</li>
</ul>
<p> </p>
<h1 id="memcached最大的优势是什么？"><a href="#memcached最大的优势是什么？" class="headerlink" title="memcached最大的优势是什么？"></a>memcached最大的优势是什么？</h1><ul>
<li>Memcached最大的好处就是它带来了极佳的水平可扩展性，特别是在一个巨大的系统中</li>
<li>由于客户端自己做了一次哈希，那么我们很容易增加大量memcached到集群中</li>
<li>memcached之间没有相互通信，因此不会增加 memcached的负载；没有多播协议，不会网络通信量爆炸（implode）。memcached的集群很好用。内存不够了？增加几台 memcached吧；CPU不够用了？再增加几台吧；有多余的内存？在增加几台吧，不要浪费了。 </li>
<li>基于memcached的基本原则，可以相当轻松地构建出不同类型的缓存架构。</li>
</ul>
<h1 id="memcached和MySQL的query-cache相比，有什么优缺点？"><a href="#memcached和MySQL的query-cache相比，有什么优缺点？" class="headerlink" title="memcached和MySQL的query cache相比，有什么优缺点？"></a>memcached和MySQL的query cache相比，有什么优缺点？</h1><ul>
<li>把memcached引入应用中，还是需要不少工作量的</li>
<li>MySQL有个使用方便的query cache，可以自动地缓存SQL查询的结果，被缓存的SQL查询可以被反复地快速执行。</li>
</ul>
<h4 id="Memcached与之相比，怎么样呢"><a href="#Memcached与之相比，怎么样呢" class="headerlink" title="Memcached与之相比，怎么样呢"></a>Memcached与之相比，怎么样呢</h4><ul>
<li>MySQL的query cache是集中式的，连接到该query cache的MySQL服务器都会受益。 </li>
<li>当您修改表时，MySQL的query cache会立刻被刷新（flush）</li>
<li>存储一个memcached item只需要很少的时间，但是当写操作很频繁时，MySQL的query cache会经常让所有缓存数据都失效。 </li>
<li>在多核CPU上，MySQL的query cache会遇到扩展问题（scalability issues）。在多核CPU上，query cache会增加一个全局锁（global lock）, 由于需要刷新更多的缓存数据，速度会变得更慢。 </li>
<li>在 MySQL的query cache中，我们是不能存储任意的数据的（只能是SQL查询结果）。而利用memcached，我们可以搭建出各种高效的缓存。比如，可以执行多个独立的查询，构建出一个用户对象（user object），然后将用户对象缓存到memcached中。而query cache是SQL语句级别的，不可能做到这一点。在小的网站中，query cache会有所帮助，但随着网站规模的增加，query cache的弊将大于利。 </li>
<li>query cache能够利用的内存容量受到MySQL服务器空闲内存空间的限制。给数据库服务器增加更多的内存来缓存数据，固然是很好的。但是，有了memcached，只要您有空闲的内存，都可以用来增加memcached集群的规模，然后您就可以缓存更多的数据。</li>
</ul>
<p> </p>
<h1 id="memcached和服务器的local-cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？"><a href="#memcached和服务器的local-cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？" class="headerlink" title="memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？"></a>memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？</h1><ul>
<li>首先，local cache有许多与上面(query cache)相同的问题</li>
<li>local cache能够利用的内存容量受到（单台）服务器空闲内存空间的限制</li>
<li>不过，local cache有一点比memcached和query cache都要好，那就是它不但可以存储任意的数据，而且没有网络存取的延迟。 </li>
<li>local cache的数据查询更快</li>
<li>考虑把highly common的数据放在local cache中吧。如果每个页面都需要加载一些数量较少的数据，考虑把它们放在local cached吧。 </li>
<li>local cache缺少集体失效（group invalidation）的特性。在memcached集群中，删除或更新一个key会让所有的观察者觉察到。但是在local cache中, 我们只能通知所有的服务器刷新cache（很慢，不具扩展性），或者仅仅依赖缓存超时失效机制。 </li>
<li>local cache面临着严重的内存限制，这一点上面已经提到。</li>
</ul>
<p> </p>
<h1 id="memcached的cache机制是怎样的？"><a href="#memcached的cache机制是怎样的？" class="headerlink" title="memcached的cache机制是怎样的？"></a>memcached的cache机制是怎样的？</h1><ul>
<li>Memcached主要的cache机制是LRU（最近最少用）算法+超时失效</li>
<li>当您存数据到memcached中，可以指定该数据在缓存中可以呆多久Which is forever, or some time in the future</li>
<li>如果memcached的内存不够用了，过期的slabs会优先被替换，接着就轮到最老的未被使用的slabs。</li>
</ul>
<p> </p>
<h1 id="memcached如何实现冗余机制？"><a href="#memcached如何实现冗余机制？" class="headerlink" title="memcached如何实现冗余机制？"></a>memcached如何实现冗余机制？</h1><ul>
<li>不实现！我们对这个问题感到很惊讶</li>
<li>Memcached应该是应用的缓存层</li>
<li>它的设计本身就不带有任何冗余机制</li>
<li>如果一个memcached节点失去了所有数据，您应该可以从数据源（比如数据库）再次获取到数据</li>
<li>您应该特别注意，您的应用应该可以容忍节点的失效</li>
<li>不要写一些糟糕的查询代码，寄希望于 memcached来保证一切！如果您担心节点失效会大大加重数据库的负担，那么您可以采取一些办法。比如您可以增加更多的节点（来减少丢失一个节点的影响），热备节点（在其他节点down了的时候接管IP），等等。</li>
</ul>
<p> </p>
<h1 id="memcached如何处理容错的？"><a href="#memcached如何处理容错的？" class="headerlink" title="memcached如何处理容错的？"></a>memcached如何处理容错的？</h1><ul>
<li>不处理！</li>
<li>在memcached节点失效的情况下，集群没有必要做任何容错处理</li>
<li>如果发生了节点失效，应对的措施完全取决于用户</li>
<li>节点失效时，下面列出几种方案供您选择： <ul>
<li>忽略它！在失效节点被恢复或替换之前，还有很多其他节点可以应对节点失效带来的影响</li>
<li>把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下（余数式哈希算法），客户端添加或移除节点，会导致所有的缓存数据不可用！因为哈希参照的节点列表变化了，大部分key会因为哈希值的改变而被映射到（与原来）不同的节点上。 </li>
<li>启动热备节点，接管失效节点所占用的IP。这样可以防止哈希紊乱（hashing chaos）。 </li>
<li>如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈希算法（consistent hashing）</li>
<li>两次哈希（reshing）。当客户端存取数据时，如果发现一个节点down了，就再做一次哈希（哈希算法与前一次不同），重新选择另一个节点（需要注意的时，客户端并没有把down的节点从节点列表中移除，下次还是有可能先哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和坏的节点上都可能存在脏数据（stale data）。</li>
</ul>
</li>
</ul>
<p> </p>
<h1 id="如何将memcached中item批量导入导出？"><a href="#如何将memcached中item批量导入导出？" class="headerlink" title="如何将memcached中item批量导入导出？"></a>如何将memcached中item批量导入导出？</h1><ul>
<li>您不应该这样做！</li>
<li>Memcached是一个非阻塞的服务器</li>
<li>任何可能导致memcached暂停或瞬时拒绝服务的操作都应该值得深思熟虑</li>
<li>向 memcached中批量导入数据往往不是您真正想要的</li>
<li>想象看，如果缓存数据在导出导入之间发生了变化，您就需要处理脏数据了；如果缓存数据在导出导入之间过期了，您又怎么处理这些数据呢？ </li>
<li>因此，批量导出导入数据并不像您想象中的那么有用。不过在一个场景倒是很有用。如果您有大量的从不变化的数据，并且希望缓存很快热（warm）起来，批量导入缓存数据是很有帮助的。虽然这个场景并不典型，但却经常发生，因此我们会考虑在将来实现批量导出导入的功能。</li>
</ul>
<p> </p>
<h1 id="memcached是如何做身份验证的？"><a href="#memcached是如何做身份验证的？" class="headerlink" title="memcached是如何做身份验证的？"></a>memcached是如何做身份验证的？</h1><ul>
<li>没有身份认证机制！</li>
<li>memcached是运行在应用下层的软件（身份验证应该是应用上层的职责）</li>
<li>memcached的客户端和服务器端之所以是轻量级的，部分原因就是完全没有实现身份验证机制。这样，memcached可以很快地创建新连接，服务器端也无需任何配置。 </li>
<li>如果您希望限制访问，您可以使用防火墙，或者让memcached监听unix domain socket。</li>
</ul>
<p> </p>
<h1 id="memcached的多线程是什么？如何使用它们？"><a href="#memcached的多线程是什么？如何使用它们？" class="headerlink" title="memcached的多线程是什么？如何使用它们？"></a>memcached的多线程是什么？如何使用它们？</h1><ul>
<li>线程就是定律（threads rule）！</li>
<li>多线程模式允许memcached能够充分利用多个CPU，并在CPU之间共享所有的缓存数据</li>
<li>memcached使用一种简单的锁机制来保证数据更新操作的互斥</li>
<li>相比在同一个物理机器上运行多个memcached实例，这种方式能够更有效地处理multi gets。 </li>
<li>如果您的系统负载并不重，也许您不需要启用多线程工作模式</li>
<li>如果您在运行一个拥有大规模硬件的、庞大的网站，您将会看到多线程的好处。 </li>
<li>简单地总结一下：命令解析（memcached在这里花了大部分时间）可以运行在多线程模式下。memcached内部对数据的操作是基于很多全局锁的（因此这部分工作不是多线程的）。未来对多线程模式的改进，将移除大量的全局锁，提高memcached在负载极高的场景下的性能。</li>
</ul>
<p> </p>
<h1 id="memcached能接受的key的最大长度是多少？"><a href="#memcached能接受的key的最大长度是多少？" class="headerlink" title="memcached能接受的key的最大长度是多少？"></a>memcached能接受的key的最大长度是多少？</h1><ul>
<li>key的最大长度是250个字符</li>
<li>需要注意的是，250是memcached服务器端内部的限制，如果您使用的客户端支持”key的前缀”或类似特性，那么key（前缀+原始key）的最大长度是可以超过250个字符的</li>
<li>我们推荐使用使用较短的key，因为可以节省内存和带宽。</li>
</ul>
<p> </p>
<h1 id="memcached对item的过期时间有什么限制？"><a href="#memcached对item的过期时间有什么限制？" class="headerlink" title="memcached对item的过期时间有什么限制？"></a>memcached对item的过期时间有什么限制？</h1><ul>
<li>过期时间最大可以达到30天</li>
<li>memcached把传入的过期时间（时间段）解释成时间点后，一旦到了这个时间点，memcached就把item置为失效状态。</li>
</ul>
<p> </p>
<h1 id="memcached最大能存储多大的单个item？"><a href="#memcached最大能存储多大的单个item？" class="headerlink" title="memcached最大能存储多大的单个item？"></a>memcached最大能存储多大的单个item？</h1><ul>
<li>1MB</li>
<li>如果你的数据大于1MB，可以考虑在客户端压缩或拆分到多个key中。</li>
</ul>
<p> </p>
<h1 id="为什么单个item的大小被限制在1M-byte之内？"><a href="#为什么单个item的大小被限制在1M-byte之内？" class="headerlink" title="为什么单个item的大小被限制在1M byte之内？"></a>为什么单个item的大小被限制在1M byte之内？</h1><ul>
<li>简单的回答：因为内存分配器的算法就是这样的。 </li>
<li>详细的回答：Memcached的内存存储引擎（引擎将来可插拔…），使用slabs来管理内存。内存被分成大小不等的slabs chunks（先分成大小相等的slabs，然后每个slab被分成大小相等chunks，不同slab的chunk大小是不相等的）。chunk的大小依次从一个最小数开始，按某个因子增长，直到达到最大的可能值。 </li>
<li>如果最小值为400B，最大值是1MB，因子是1.20，各个slab的chunk的大小依次是：slab1 – 400B slab2 – 480B slab3 – 576B … </li>
<li>slab中chunk越大，它和前面的slab之间的间隙就越大。因此，最大值越大，内存利用率越低。Memcached必须为每个slab预先分配内存，因此如果设置了较小的因子和较大的最大值，会需要更多的内存。 </li>
<li>还有其他原因使得您不要这样向memcached中存取很大的数据…不要尝试把巨大的网页放到mencached中。把这样大的数据结构load和unpack到内存中需要花费很长的时间，从而导致您的网站性能反而不好。 </li>
<li>如果您确实需要存储大于1MB的数据，你可以修改slabs.c:POWER_BLOCK的值，然后重新编译memcached；或者使用低效的malloc&#x2F;free。其他的建议包括数据库、MogileFS等。</li>
</ul>
<p> </p>
<h1 id="我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？"><a href="#我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？" class="headerlink" title="我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？"></a>我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？</h1><ul>
<li>Memcache客户端仅根据哈希算法来决定将某个key存储在哪个节点上，而不考虑节点的内存大小</li>
<li>因此，您可以在不同的节点上使用大小不等的缓存。但是一般都是这样做的：拥有较多内存的节点上可以运行多个memcached实例，每个实例使用的内存跟其他节点上的实例相同。</li>
</ul>
<p> </p>
<h1 id="LRU算法，slab分配，如何减少内存碎⽚"><a href="#LRU算法，slab分配，如何减少内存碎⽚" class="headerlink" title="LRU算法，slab分配，如何减少内存碎⽚"></a>LRU算法，slab分配，如何减少内存碎⽚</h1><ul>
<li>memcached预先将分配的内存分割成各种尺⼨的块(chunk)，并把尺⼨相同的块分成组(chunk的集合)，以此克服内<br>存碎⽚化问题</li>
</ul>
<h1 id="memcached-是原子的吗？"><a href="#memcached-是原子的吗？" class="headerlink" title="memcached 是原子的吗？"></a>memcached 是原子的吗？</h1><ul>
<li>所有的被发送到 memcached 的单个命令是完全原子的。如果您针对同一份数据同时发送了一个 set 命令和一个 get 命令，它们不会影响对方。它们将被串行化、先后执行。即使在多线程模式，所有的命令都是原子的，除非程序有 bug:)命令序列不是原子的。如果您通过 get 命令获取了一个 item，修改了它，然后想把它 set 回 memcached，我们不保证这个 item 没有被其他进程（process，未必是操作系统中的进程）操作过。在并发的情况下，您也可能覆写了一个被其他进程 set 的 item。</li>
<li>memcached 1.2.5 以及更高版本，提供了 gets 和 cas 命令，它们可以解决上面的问题。如果您使用 gets 命令查询某个 key 的 item，memcached 会给您返回该 item 当前值的唯一标识。如果您覆写了这个 item 并想把它写回到 memcached中，您可以通过 cas 命令把那个唯一标识一起发送给 memcached。如果该 item存放在 memcached 中的唯一标识与您提供的一致，您的写操作将会成功。如果另一个进程在这期间也修改了这个 item，那么该 item 存放在 memcached 中的唯一标识将会改变，您的写操作就会失败</li>
</ul>
<h1 id="memcached-能够更有效地使用内存吗？"><a href="#memcached-能够更有效地使用内存吗？" class="headerlink" title="memcached 能够更有效地使用内存吗？"></a>memcached 能够更有效地使用内存吗？</h1><ul>
<li>Memcache 客户端仅根据哈希算法来决定将某个 key 存储在哪个节点上，而不考虑节点的内存大小。因此，您可以在不同的节点上使用大小不等的缓存。但是一般都是这样做的：拥有较多内存的节点上可以运行多个 memcached 实例，每个实例使用的内存跟其他节点上的实例相同。</li>
</ul>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/publishes/dffc02696193.html</url>
    <content><![CDATA[<h1 id="不可重复读和幻读到底有什么区别呢？"><a href="#不可重复读和幻读到底有什么区别呢？" class="headerlink" title="不可重复读和幻读到底有什么区别呢？"></a>不可重复读和幻读到底有什么区别呢？</h1><ul>
<li>不可重复读是读取了其他事务更改的数据，针对update操作</li>
<li>解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。</li>
<li>幻读是读取了其他事务新增的数据，针对insert操作</li>
<li>解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。</li>
</ul>
<h1 id="MySQL千万级的大表要怎么优化"><a href="#MySQL千万级的大表要怎么优化" class="headerlink" title="MySQL千万级的大表要怎么优化"></a>MySQL千万级的大表要怎么优化</h1><ul>
<li>读写分离、水平拆分、垂直拆分</li>
<li>如何设计或优化千万级别的大表？此外无其他信息，个人觉得这个话题有点范，就只好简单说下该如何做，对于一个存储设计，必须考虑业务特点，收集的信息如下：<ul>
<li>数据的容量：1-3年内会大概多少条数据，每条数据大概多少字节；</li>
<li>数据项：是否有大字段，那些字段的值是否经常被更新；</li>
<li>数据查询SQL条件：哪些数据项的列名称经常出现在WHERE、GROUP BY、ORDER BY子句中等；</li>
<li>数据更新类SQL条件：有多少列经常出现UPDATE或DELETE 的WHERE子句中；</li>
<li>SQL量的统计比，如：SELECT：UPDATE+DELETE：INSERT&#x3D;多少？</li>
<li>预计大表及相关联的SQL，每天总的执行量在何数量级？</li>
<li>表中的数据：更新为主的业务 还是 查询为主的业务 ？</li>
<li>打算采用什么数据库物理服务器，以及数据库服务器架构？</li>
<li>并发如何？</li>
<li>存储引擎选择InnoDB还是MyISAM？</li>
</ul>
</li>
<li>大致明白以上10个问题，至于如何设计此类的大表，应该什么都清楚了！</li>
<li>至于优化若是指创建好的表，不能变动表结构的话，那建议InnoDB引擎，多利用点内存，减轻磁盘IO负载，因为IO往往是数据库服务器的瓶颈</li>
<li>另外对优化索引结构去解决性能问题的话，建议优先考虑修改类SQL语句，使他们更快些，不得已只靠索引组织结构的方式，当然此话前提是， 索引已经创建的非常好，若是读为主，可以考虑打开query_cache，以及调整一些参数值：sort_buffer_size,read_buffer_size,read_rnd_buffer_size,join_buffer_size</li>
<li>以及调整一些参数值：sort_buffer_size,read_buffer_size,read_rnd_buffer_size,join_buffer_size</li>
</ul>
<h1 id="union和union-all有什么不同"><a href="#union和union-all有什么不同" class="headerlink" title="union和union all有什么不同?"></a>union和union all有什么不同?</h1><ul>
<li>Union和Union All的区别之一在于对重复结果的处理。</li>
<li>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION</li>
<li>而UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。</li>
<li>从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL，</li>
</ul>
<h1 id="oracle中除了数据库备份，还有什么方法备份？"><a href="#oracle中除了数据库备份，还有什么方法备份？" class="headerlink" title="oracle中除了数据库备份，还有什么方法备份？"></a>oracle中除了数据库备份，还有什么方法备份？</h1><ul>
<li>Oracle数据库有三种标准的备份方法，它们分别是导出&#x2F;导入(EXP&#x2F;IMP)、热备份和冷备份</li>
<li>导出备份是一种逻辑备份，冷备份和热备份是物理备份。</li>
</ul>
<h1 id="truncate与delete的区别？（delete-from-table和truncate-table-tablea的区别！）"><a href="#truncate与delete的区别？（delete-from-table和truncate-table-tablea的区别！）" class="headerlink" title="truncate与delete的区别？（delete from table和truncate table tablea的区别！）"></a>truncate与delete的区别？（delete from table和truncate table tablea的区别！）</h1><ul>
<li>truncate是DDL語言</li>
<li>delete是DML語言 DDL語言是自動提交的，命令完成就不可回滾.truncate的速度也比delete要快得多.</li>
<li>相同点:truncate和不带where子句的delete, 以及drop都会删除表内的数据  </li>
<li>不同点:  <ul>
<li>truncate和 delete只删除数据不删除表的结构(定义)  </li>
<li>drop语句将删除表的结构被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程&#x2F;函数将保留,但是变为invalid状态.  </li>
<li>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.  </li>
<li>truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.  </li>
<li>delete语句不影响表所占用的extent, 高水线(high watermark)保持原位置不动  </li>
<li>显然drop语句将表所占用的空间全部释放  </li>
<li>truncate 语句缺省情况下见空间释放到 minextents个 extent,除非使用reuse storage;   truncate会将高水线复位(回到最开始).</li>
</ul>
</li>
<li>速度,一般来说: drop&gt; truncate &gt; delete  </li>
<li>安全性:小心使用drop 和truncate,尤其没有备份的时候.否则哭都来不及  </li>
<li>使用上,想删除部分数据行用delete,注意带上where子句. 回滚段要足够大.  </li>
<li>想删除表,当然用drop  </li>
<li>想保留表而将所有数据删除. 如果和事务无关,用truncate即可. 如果和事务有关,或者想触发trigger,还是用delete.</li>
</ul>
<h1 id="Oracle冷备份的通常步骤"><a href="#Oracle冷备份的通常步骤" class="headerlink" title="Oracle冷备份的通常步骤"></a>Oracle冷备份的通常步骤</h1><ul>
<li>正常关闭数据库</li>
<li>备份所有重要的文件到备份目录（数据文件、控制文件、重做日志文件等）</li>
<li>完成备份后启动数据库用冷备份进行恢复时，只需要将所有文件恢复到原有位置，就可以启动数据库了</li>
<li>关闭数据库  SQL&gt;shutdown</li>
<li>备份文件到备份的目录</li>
<li>然后启动数据库 ＃sqlplus “&#x2F;as sysdba”SQL&gt;startup</li>
<li>冷备份完毕！！</li>
</ul>
<h1 id="对数据库的访问是怎么实现的"><a href="#对数据库的访问是怎么实现的" class="headerlink" title="对数据库的访问是怎么实现的"></a>对数据库的访问是怎么实现的</h1><ul>
<li>将对持久层数据库的基本添加，修改，查找等操作提取到BaseDAO中</li>
<li>采用JavaBean对数据进行封装，以便对持久层的数据能够很好的处理，实现BaseDAO设计对数据库访问的便捷</li>
<li>业务组件通过DAO 的委托接口调用DAO对象，使得上层组件不 直接依赖于DAO的实现类.</li>
</ul>
<h1 id="Mysql-的技术特点是什么？"><a href="#Mysql-的技术特点是什么？" class="headerlink" title="Mysql 的技术特点是什么？"></a>Mysql 的技术特点是什么？</h1><ul>
<li>Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。</li>
</ul>
<h1 id="Heap-表是什么？"><a href="#Heap-表是什么？" class="headerlink" title="Heap 表是什么？"></a>Heap 表是什么？</h1><ul>
<li>HEAP 表存在于内存中，用于临时高速存储。</li>
<li>BLOB 或 TEXT 字段是不允许的</li>
<li>只能使用比较运算符&#x3D;，&lt;，&gt;，&#x3D;&gt;，&#x3D; &lt;</li>
<li>HEAP 表不支持 AUTO_INCREMENT</li>
<li>索引不可为 NULL</li>
</ul>
<h1 id="Mysql-服务器默认端口是什么？"><a href="#Mysql-服务器默认端口是什么？" class="headerlink" title="Mysql 服务器默认端口是什么？"></a>Mysql 服务器默认端口是什么？</h1><ul>
<li>Mysql 服务器的默认端口是 3306。</li>
</ul>
<h1 id="与-Oracle-相比，Mysql-有什么优势？"><a href="#与-Oracle-相比，Mysql-有什么优势？" class="headerlink" title="与 Oracle 相比，Mysql 有什么优势？"></a>与 Oracle 相比，Mysql 有什么优势？</h1><ul>
<li>Mysql 是开源软件，随时可用，无需付费。</li>
<li>Mysql 是便携式的</li>
<li>带有命令提示符的 GUI。</li>
<li>使用 Mysql 查询浏览器支持管理</li>
</ul>
<h1 id="如何区分-FLOAT-和-DOUBLE？"><a href="#如何区分-FLOAT-和-DOUBLE？" class="headerlink" title="如何区分 FLOAT 和 DOUBLE？"></a>如何区分 FLOAT 和 DOUBLE？</h1><ul>
<li>以下是 FLOAT 和 DOUBLE 的区别：<ul>
<li>浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。</li>
<li>浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。</li>
</ul>
</li>
</ul>
<h1 id="区分-CHAR-LENGTH-和-LENGTH？"><a href="#区分-CHAR-LENGTH-和-LENGTH？" class="headerlink" title="区分 CHAR_LENGTH 和 LENGTH？"></a>区分 CHAR_LENGTH 和 LENGTH？</h1><ul>
<li>CHAR_LENGTH 是字符数，而 LENGTH 是字节数</li>
<li>Latin 字符的这两个数据是相同的，但是对于 Unicode 和其他编码，它们是不同的。</li>
</ul>
<h1 id="在-Mysql-中-ENUM-的用法是什么？"><a href="#在-Mysql-中-ENUM-的用法是什么？" class="headerlink" title="在 Mysql 中 ENUM 的用法是什么？"></a>在 Mysql 中 ENUM 的用法是什么？</h1><ul>
<li>ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。</li>
<li>Create table size(name ENUM(‘Smail,’Medium’,’Large’));</li>
</ul>
<h1 id="如何定义-REGEXP？"><a href="#如何定义-REGEXP？" class="headerlink" title="如何定义 REGEXP？"></a>如何定义 REGEXP？</h1><ul>
<li>REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置。</li>
</ul>
<h1 id="列的字符串类型可以是什么？"><a href="#列的字符串类型可以是什么？" class="headerlink" title="列的字符串类型可以是什么？"></a>列的字符串类型可以是什么？</h1><ul>
<li>字符串类型是：<ul>
<li>SET</li>
<li>BLOB</li>
<li>ENUM</li>
<li>CHAR</li>
<li>TEXT</li>
<li>VARCHAR</li>
</ul>
</li>
</ul>
<h1 id="如何获取当前的-Mysql-版本？"><a href="#如何获取当前的-Mysql-版本？" class="headerlink" title="如何获取当前的 Mysql 版本？"></a>如何获取当前的 Mysql 版本？</h1><ul>
<li>SELECT VERSION();用于获取当前 Mysql 的版本。</li>
</ul>
<h1 id="Mysql-中使用什么存储引擎？"><a href="#Mysql-中使用什么存储引擎？" class="headerlink" title="Mysql 中使用什么存储引擎？"></a>Mysql 中使用什么存储引擎？</h1><ul>
<li>存储引擎称为表类型，数据使用各种技术存储在文件中。</li>
<li>技术涉及：<ul>
<li>Storage mechanism</li>
<li>Locking levels</li>
<li>Indexing</li>
<li>Capabilities and functions.</li>
</ul>
</li>
</ul>
<h1 id="Mysql-驱动程序是什么？"><a href="#Mysql-驱动程序是什么？" class="headerlink" title="Mysql 驱动程序是什么？"></a>Mysql 驱动程序是什么？</h1><ul>
<li>以下是 Mysql 中可用的驱动程序：<ul>
<li>PHP 驱动程序</li>
<li>JDBC 驱动程序</li>
<li>ODBC 驱动程序</li>
<li>CWRAPPER PYTHON驱动程序 </li>
<li>PERL 驱动程序 </li>
<li>RUBY 驱动程序 </li>
<li>CAP11PHP 驱动程序</li>
</ul>
</li>
</ul>
<h1 id="TIMESTAMP-在-UPDATE-CURRENT-TIMESTAMP-数据类型上做什么？"><a href="#TIMESTAMP-在-UPDATE-CURRENT-TIMESTAMP-数据类型上做什么？" class="headerlink" title="TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？"></a>TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？</h1><ul>
<li>创建表时 TIMESTAMP 列用 Zero 更新</li>
<li>只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。</li>
</ul>
<h1 id="如何使用-Unix-shell-登录-Mysql？"><a href="#如何使用-Unix-shell-登录-Mysql？" class="headerlink" title="如何使用 Unix shell 登录 Mysql？"></a>如何使用 Unix shell 登录 Mysql？</h1><ul>
<li>mysql -h hostname -u</li>
</ul>
<h1 id="如何控制-HEAP-表的最大尺寸？"><a href="#如何控制-HEAP-表的最大尺寸？" class="headerlink" title="如何控制 HEAP 表的最大尺寸？"></a>如何控制 HEAP 表的最大尺寸？</h1><ul>
<li>Heal 表的大小可通过称为 max_heap_table_size 的 Mysql 配置变量来控制。</li>
</ul>
<h1 id="federated-表是什么？"><a href="#federated-表是什么？" class="headerlink" title="federated 表是什么？"></a>federated 表是什么？</h1><ul>
<li>federated 表，允许访问位于其他服务器数据库上的表。</li>
</ul>
<h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h1><ul>
<li>LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。</li>
</ul>
<h1 id="你怎么看到为表格定义的所有索引？"><a href="#你怎么看到为表格定义的所有索引？" class="headerlink" title="你怎么看到为表格定义的所有索引？"></a>你怎么看到为表格定义的所有索引？</h1><ul>
<li>索引是通过以下方式为表格定义的：SHOW INDEX FROM</li>
</ul>
<h1 id="LIKE-声明中的％和-是什么意思？"><a href="#LIKE-声明中的％和-是什么意思？" class="headerlink" title="LIKE 声明中的％和_是什么意思？"></a>LIKE 声明中的％和_是什么意思？</h1><ul>
<li>％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。</li>
</ul>
<h1 id="如何在-Unix-和-Mysql-时间戳之间进行转换？"><a href="#如何在-Unix-和-Mysql-时间戳之间进行转换？" class="headerlink" title="如何在 Unix 和 Mysql 时间戳之间进行转换？"></a>如何在 Unix 和 Mysql 时间戳之间进行转换？</h1><ul>
<li>UNIX_TIMESTAMP 是从 Mysql 时间戳转换为 Unix 时间戳的命令</li>
<li>FROM_UNIXTIME 是从 Unix 时间戳转换为 Mysql 时间戳的命令</li>
</ul>
<h1 id="列对比运算符是什么？"><a href="#列对比运算符是什么？" class="headerlink" title="列对比运算符是什么？"></a>列对比运算符是什么？</h1><ul>
<li>在 SELECT 语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，OR 或 LIKE 运算符。</li>
</ul>
<h1 id="LIKE-和-REGEXP-操作有什么区别？"><a href="#LIKE-和-REGEXP-操作有什么区别？" class="headerlink" title="LIKE 和 REGEXP 操作有什么区别？"></a>LIKE 和 REGEXP 操作有什么区别？</h1><ul>
<li>LIKE 和 REGEXP 运算符用于表示^和％。</li>
<li>SELECT * FROM employee WHERE emp_name REGEXP “^b”;</li>
<li>SELECT * FROM employee WHERE emp_name LIKE “%b”;</li>
</ul>
<h1 id="BLOB-和-TEXT-有什么区别？"><a href="#BLOB-和-TEXT-有什么区别？" class="headerlink" title="BLOB 和 TEXT 有什么区别？"></a>BLOB 和 TEXT 有什么区别？</h1><ul>
<li>BLOB 是一个二进制对象，可以容纳可变数量的数据</li>
<li>有四种类型的 BLOB<ul>
<li>TINYBLOB</li>
<li>BLOB</li>
<li>MEDIUMBLOB</li>
<li>LONGBLOB</li>
</ul>
</li>
<li>它们只能在所能容纳价值的最大长度上有所不同。</li>
<li>TEXT 是一个不区分大小写的 BLOB</li>
<li>四种 TEXT 类型<ul>
<li>TINYTEXT</li>
<li>TEXT</li>
<li>MEDIUMTEXT </li>
<li>LONGTEXT</li>
</ul>
</li>
<li>它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。</li>
<li>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT值不区分大小写。</li>
</ul>
<h1 id="mysql-fetch-array-和-mysql-fetch-object-的区别是什么？"><a href="#mysql-fetch-array-和-mysql-fetch-object-的区别是什么？" class="headerlink" title="mysql_fetch_array 和 mysql_fetch_object 的区别是什么？"></a>mysql_fetch_array 和 mysql_fetch_object 的区别是什么？</h1><ul>
<li>mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。</li>
<li>mysql_fetch_object - 从数据库返回结果行作为对象。</li>
</ul>
<h1 id="我们如何在-mysql-中运行批处理模式？"><a href="#我们如何在-mysql-中运行批处理模式？" class="headerlink" title="我们如何在 mysql 中运行批处理模式？"></a>我们如何在 mysql 中运行批处理模式？</h1><ul>
<li>以下命令用于在批处理模式下运行：<ul>
<li>mysql;</li>
<li>mysql mysql.out</li>
</ul>
</li>
</ul>
<h1 id="MyISAM-表格将在哪里存储，并且还提供其存储格式？"><a href="#MyISAM-表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="MyISAM 表格将在哪里存储，并且还提供其存储格式？"></a>MyISAM 表格将在哪里存储，并且还提供其存储格式？</h1><ul>
<li>每个 MyISAM 表格以三种格式存储在磁盘上：<ul>
<li>·“.frm”文件存储表定义</li>
<li>·数据文件具有“.MYD”（MYData）扩展名</li>
<li>索引文件具有“.MYI”（MYIndex）扩展名</li>
</ul>
</li>
</ul>
<h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><ul>
<li>共有 5 种类型的表格：<ul>
<li>MyISAM</li>
<li>Heap</li>
<li>Merge</li>
<li>INNODB</li>
<li>ISAM</li>
</ul>
</li>
<li>MyISAM 是 Mysql 的默认存储引擎。</li>
</ul>
<h1 id="ISAM-是什么？"><a href="#ISAM-是什么？" class="headerlink" title="ISAM 是什么？"></a>ISAM 是什么？</h1><ul>
<li>ISAM 简称为索引顺序访问方法</li>
<li>它是由 IBM 开发的，用于在磁带等辅助存储系统上存储和检索数据。</li>
</ul>
<h1 id="InnoDB-是什么？"><a href="#InnoDB-是什么？" class="headerlink" title="InnoDB 是什么？"></a>InnoDB 是什么？</h1><ul>
<li>lnnoDB 是一个由 Oracle 公司开发的 Innobase Oy 事务安全存储引擎。</li>
</ul>
<h1 id="Mysql-如何优化-DISTINCT？"><a href="#Mysql-如何优化-DISTINCT？" class="headerlink" title="Mysql 如何优化 DISTINCT？"></a>Mysql 如何优化 DISTINCT？</h1><ul>
<li>DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。</li>
<li>SELECT DISTINCT t1.a FROM t1,t2 where t1.a&#x3D;t2.a;</li>
</ul>
<h1 id="如何输入字符为十六进制数字？"><a href="#如何输入字符为十六进制数字？" class="headerlink" title="如何输入字符为十六进制数字？"></a>如何输入字符为十六进制数字？</h1><ul>
<li>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。</li>
<li>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。</li>
</ul>
<h1 id="如何显示前-50-行？"><a href="#如何显示前-50-行？" class="headerlink" title="如何显示前 50 行？"></a>如何显示前 50 行？</h1><ul>
<li>在 Mysql 中，使用以下代码查询显示前 50 行：</li>
<li>SELECT*FROM LIMIT 0,50;</li>
</ul>
<h1 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><ul>
<li>任何标准表最多可以创建 16 个索引列。</li>
</ul>
<h1 id="NOW（）和-CURRENT-DATE（）有什么区别？"><a href="#NOW（）和-CURRENT-DATE（）有什么区别？" class="headerlink" title="NOW（）和 CURRENT_DATE（）有什么区别？"></a>NOW（）和 CURRENT_DATE（）有什么区别？</h1><ul>
<li>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</li>
<li>CURRENT_DATE（）仅显示当前年份，月份和日期。</li>
</ul>
<h1 id="Mysql-表中允许有多少个-TRIGGERS？"><a href="#Mysql-表中允许有多少个-TRIGGERS？" class="headerlink" title="Mysql 表中允许有多少个 TRIGGERS？"></a>Mysql 表中允许有多少个 TRIGGERS？</h1><ul>
<li>在 Mysql 表中允许有六个触发器，如下：<ul>
<li>BEFORE INSERT</li>
<li>AFTER INSERT</li>
<li>BEFORE UPDATE</li>
<li>AFTER UPDATE</li>
<li>BEFORE DELETE</li>
<li>AFTER DELETE</li>
</ul>
</li>
</ul>
<h1 id="什么是非标准字符串类型？"><a href="#什么是非标准字符串类型？" class="headerlink" title="什么是非标准字符串类型？"></a>什么是非标准字符串类型？</h1><ul>
<li>以下是非标准字符串类型：<ul>
<li>TINYTEXT</li>
<li>TEXT</li>
<li>MEDIUMTEXT</li>
<li>LONGTEXT</li>
</ul>
</li>
</ul>
<h1 id="解释访问控制列表"><a href="#解释访问控制列表" class="headerlink" title="解释访问控制列表"></a>解释访问控制列表</h1><ul>
<li>ACL（访问控制列表）是与对象关联的权限列表</li>
<li>这个列表是 Mysql 服务器安全模型的基础，它有助于排除用户无法连接的问题。</li>
<li>Mysql 将 ACL（也称为授权表）缓存在内存中</li>
<li>当用户尝试认证或运行命令时，Mysql 会按照预定的顺序检查 ACL 的认证信息和权限。</li>
</ul>
<h1 id="MYSQL-支持事务吗？"><a href="#MYSQL-支持事务吗？" class="headerlink" title="MYSQL 支持事务吗？"></a>MYSQL 支持事务吗？</h1><ul>
<li>在缺省模式下，MYSQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql 是不支持事务的。</li>
<li>但是如果你的 MYSQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的 MYSQL 就可以使用事务处理,使用 SET AUTOCOMMIT&#x3D;0 就可以使 MYSQL 允许在非 autocommit 模式，在非autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK 来回滚你的更改。</li>
</ul>
<h1 id="mysql-里记录货币用什么字段类型好"><a href="#mysql-里记录货币用什么字段类型好" class="headerlink" title="mysql 里记录货币用什么字段类型好"></a>mysql 里记录货币用什么字段类型好</h1><ul>
<li>NUMERIC 和 DECIMAL 类型被 Mysql 实现为同样的类型，这在 SQL92 标准允许</li>
<li>他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据</li>
<li>当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。</li>
</ul>
<h1 id="MYSQL-数据表在什么情况下容易损坏？"><a href="#MYSQL-数据表在什么情况下容易损坏？" class="headerlink" title="MYSQL 数据表在什么情况下容易损坏？"></a>MYSQL 数据表在什么情况下容易损坏？</h1><ul>
<li>服务器突然断电导致数据文件损坏。</li>
<li>强制关机，没有先关闭 mysql 服务等。</li>
</ul>
<h1 id="mysql-有关权限的表都有哪几个？"><a href="#mysql-有关权限的表都有哪几个？" class="headerlink" title="mysql 有关权限的表都有哪几个？"></a>mysql 有关权限的表都有哪几个？</h1><ul>
<li>Mysql 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里</li>
<li>由mysql_install_db 脚本初始化</li>
<li>这些权限表分别 user，db，table_priv，columns_priv 和host。</li>
</ul>
<h1 id="一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，"><a href="#一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，" class="headerlink" title="一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，"></a>一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，</h1><ul>
<li>删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？</li>
<li>如果表的类型是MylSAM，那么是18因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失</li>
<li>如果表的类型是InnoDB，那么是15InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。</li>
</ul>
<h1 id="Myql-中的事务回滚机制概述"><a href="#Myql-中的事务回滚机制概述" class="headerlink" title="Myql 中的事务回滚机制概述"></a>Myql 中的事务回滚机制概述</h1><ul>
<li>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</li>
<li>要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚</li>
</ul>
<h1 id="可以使用多少列创建索引？-1"><a href="#可以使用多少列创建索引？-1" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h1><ul>
<li>任何标准表最多可以创建 16 个索引列。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/publishes/2f1abbd5b4e4.html</url>
    <content><![CDATA[<h1 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h1><ul>
<li>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<ul>
<li>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</li>
</ul>
</li>
<li>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<ul>
<li>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li>
</ul>
</li>
<li>向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<ul>
<li>解决：Mybatis自动将java对象映射至sql语句。</li>
</ul>
</li>
<li>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<ul>
<li>解决：Mybatis自动将sql执行结果映射至java对象。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h1><ul>
<li>创建SqlSessionFactory</li>
<li>通过SqlSessionFactory创建SqlSession</li>
<li>通过sqlsession执行数据库操作</li>
<li>调用session.commit()提交事务</li>
<li>调用session.close()关闭会话</li>
</ul>
<h1 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h1><ul>
<li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li>
<li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li>
<li>Hibernate对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O&#x2F;R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li>
<li>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</li>
</ul>
<p> </p>
<h1 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h1><ul>
<li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同</li>
<li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</li>
<li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li>
<li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li>
</ul>
<h1 id="SqlMapConfig-xml中配置有哪些内容？"><a href="#SqlMapConfig-xml中配置有哪些内容？" class="headerlink" title="SqlMapConfig.xml中配置有哪些内容？"></a>SqlMapConfig.xml中配置有哪些内容？</h1><ul>
<li>SqlMapConfig.xml中配置的内容和顺序如下： <ul>
<li>properties（属性）</li>
<li>settings（配置）</li>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）</li>
<li>environments（环境集合属性对象）</li>
<li>environment（环境子属性对象）</li>
<li>transactionManager（事务管理）</li>
<li>dataSource（数据源）</li>
<li>mappers（映射器）</li>
</ul>
</li>
</ul>
<h1 id="简单的说一下MyBatis的一级缓存和二级缓存？"><a href="#简单的说一下MyBatis的一级缓存和二级缓存？" class="headerlink" title="简单的说一下MyBatis的一级缓存和二级缓存？"></a>简单的说一下MyBatis的一级缓存和二级缓存？</h1><ul>
<li>Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。</li>
<li>Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象</li>
<li>Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。</li>
</ul>
<h1 id="Mapper编写有哪几种方式？"><a href="#Mapper编写有哪几种方式？" class="headerlink" title="Mapper编写有哪几种方式？"></a>Mapper编写有哪几种方式？</h1><h4 id="接口实现类继承SqlSessionDaoSupport"><a href="#接口实现类继承SqlSessionDaoSupport" class="headerlink" title="接口实现类继承SqlSessionDaoSupport"></a>接口实现类继承SqlSessionDaoSupport</h4><ul>
<li><p>使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件</p>
</li>
<li><p>在sqlMapConfig.xml中配置mapper.xml的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义mapper接口</p>
</li>
<li><p>实现类集成SqlSessionDaoSupport</p>
</li>
<li><p>mapper方法中可以this.getSqlSession()进行数据增删改查。</p>
</li>
<li><p>spring 配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot; &quot; class=&quot;mapper接口的实现&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用org-mybatis-spring-mapper-MapperFactoryBean"><a href="#使用org-mybatis-spring-mapper-MapperFactoryBean" class="headerlink" title="使用org.mybatis.spring.mapper.MapperFactoryBean"></a>使用org.mybatis.spring.mapper.MapperFactoryBean</h4><ul>
<li><p>在sqlMapConfig.xml中配置mapper.xml的位置</p>
</li>
<li><p>如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义mapper接口</p>
</li>
<li><p>注意</p>
<ul>
<li>mapper.xml中的namespace为mapper接口的地址</li>
<li>mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</li>
</ul>
</li>
<li><p>Spring中定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;mapperInterface&quot;   value=&quot;mapper接口地址&quot; /&gt;  </span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </span><br><span class="line">4&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用mapper扫描器"><a href="#使用mapper扫描器" class="headerlink" title="使用mapper扫描器"></a>使用mapper扫描器</h4><ul>
<li><p>mapper.xml文件编写，</p>
</li>
<li><p>注意：<br>-mapper.xml中的namespace为mapper接口的地址<br>-mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</p>
<ul>
<li>如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置</li>
</ul>
<p> </p>
</li>
<li><p>定义mapper接口</p>
<ul>
<li>注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录</li>
</ul>
</li>
<li><p>配置mapper扫描器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;mapper接口包地址&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用扫描器后从spring容器中获取mapper的实现对象</p>
</li>
<li><p>扫描器将接口通过代理方法生成实现对象，要spring容器中自动注册，名称为mapper 接口的名称。</p>
</li>
</ul>
<h1 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h1><ul>
<li>#{}是预编译处理，${}是字符串替换。</li>
<li>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set方法来赋值；</li>
<li>Mybatis 在处理${}时，就是把${}替换成变量的值。</li>
<li>使用#{}可以有效的防止 SQL 注入，提高系统安全性。</li>
</ul>
<h1 id="通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，"><a href="#通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，" class="headerlink" title="通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，"></a>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，</h1><ul>
<li>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</li>
<li>Dao 接口，就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement</li>
<li>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao 下面 id &#x3D; findStudentById 的MappedStatement。在 Mybatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个 MappedStatement 对象。</li>
<li>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li>
<li>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement 所代表的 sql，然后将 sql 执行结果返回。</li>
</ul>
<h1 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><ul>
<li>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</li>
<li>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</li>
</ul>
<h1 id="Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><ul>
<li>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系</li>
<li>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</li>
</ul>
<h1 id="Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h1><ul>
<li>注：这道题出自京东面试官。</li>
<li>还有很多其他的标签，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中为sql片段标签，通过标签引入 sql 片段，为不支持自增的主键生成策略标签。</li>
</ul>
<h1 id="简述-Mybatis-的插件运行原理，以及如何编写一个插件"><a href="#简述-Mybatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述 Mybatis 的插件运行原理，以及如何编写一个插件"></a>简述 Mybatis 的插件运行原理，以及如何编写一个插件</h1><ul>
<li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li>
<li>实现 Mybatis 的 Interceptor 接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</li>
</ul>
<h1 id="一级、二级缓存"><a href="#一级、二级缓存" class="headerlink" title="一级、二级缓存"></a>一级、二级缓存</h1><ul>
<li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。</li>
<li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如Ehcache</li>
<li>要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：<cache/></li>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存Session&#x2F;二级缓存Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ul>
<h1 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><ul>
<li>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载</li>
<li>association 指的就是一对一，collection 指的就是一对多查询</li>
<li>在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。</li>
<li>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li>
</ul>
<h1 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h1><ul>
<li>虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。</li>
<li>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</li>
</ul>
<h1 id="简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h1><ul>
<li>Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部</li>
<li>在 Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultMap>标签会被解析为ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。</li>
</ul>
<h1 id="ibatis-中的-与-的区别"><a href="#ibatis-中的-与-的区别" class="headerlink" title="ibatis 中的#与$的区别"></a>ibatis 中的#与$的区别</h1><ul>
<li>#是把传入的数据当作字符串，如#field#传入的是id,则sql语句生成是这样，order by “id”,这当然会报错．．</li>
<li>$传入的数据直接生成在sql里，如#field#传入的是id,则sql语句生成是这样，order by id, 这就对了．</li>
<li>#方式能够很大程度防止sql注入．</li>
<li>$方式无法方式sql注入．</li>
<li>$方式一般用于传入数据库对象．例如传入表名.</li>
<li>一般能用#的就别用$.</li>
</ul>
<h1 id="什么情况下用注解绑定-什么情况下用-xml-绑定？"><a href="#什么情况下用注解绑定-什么情况下用-xml-绑定？" class="headerlink" title="什么情况下用注解绑定,什么情况下用 xml 绑定？"></a>什么情况下用注解绑定,什么情况下用 xml 绑定？</h1><ul>
<li>当 Sql 语句比较简单时候,用注解绑定</li>
<li>当 SQL 语句比较复杂时候,用 xml 绑定,</li>
<li>一般用 xml 绑定的比较多</li>
</ul>
<h1 id="MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>MyBatis 实现一对一有几种方式?具体怎么操作的？</h1><ul>
<li>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap 里面配置 association 节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过 select 属性配置。</li>
</ul>
<h1 id="MyBatis-接口绑定有几种实现方式-分别是怎么实现的"><a href="#MyBatis-接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="MyBatis 接口绑定有几种实现方式,分别是怎么实现的?"></a>MyBatis 接口绑定有几种实现方式,分别是怎么实现的?</h1><ul>
<li>接口绑定有两种实现方式<ul>
<li>一种是通过注解绑定,就是在接口的方法上面加上@Select@Update 等注解里面包含 Sql 语句来绑定</li>
<li>另外一种就是通过 xml 里面写 SQL来绑定,在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名.</li>
</ul>
</li>
</ul>
<h1 id="Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？-1"><a href="#Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？-1" class="headerlink" title="Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><ul>
<li>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</li>
<li>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis一样可以正常工作。</li>
<li>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</li>
</ul>
<h1 id="使用-MyBatis-的-mapper-接口调用时有哪些要求？"><a href="#使用-MyBatis-的-mapper-接口调用时有哪些要求？" class="headerlink" title="使用 MyBatis 的 mapper 接口调用时有哪些要求？"></a>使用 MyBatis 的 mapper 接口调用时有哪些要求？</h1><ul>
<li>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同</li>
<li>Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的parameterType 的类型相同</li>
<li>Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的resultType 的类型相同</li>
<li>Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。</li>
</ul>
<h1 id="MyBatis-里面的动态-Sql-是怎么设定的-用什么语法"><a href="#MyBatis-里面的动态-Sql-是怎么设定的-用什么语法" class="headerlink" title="MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?"></a>MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?</h1><ul>
<li>MyBatis 里面的动态 Sql 一般是通过 if 节点来实现,通过 OGNL 语法来实现,但是如果要写的完整,必须配合 where,trim 节点,where 节点是判断包含节点有内容就插入where,否则不插入,trim 节点是用来判断如果动态语句是以 and 或 or 开始,那么会自动把这个 and 或者 or 取掉。</li>
</ul>
<h1 id="Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"><a href="#Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？" class="headerlink" title="Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"></a>Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h1><ul>
<li>能</li>
<li>Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为selectList()即可。</li>
<li>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql查询，就可以把主对象和其关联对象查出来。</li>
</ul>
<h1 id="什么是-MyBatis-的接口绑定-有什么好处？"><a href="#什么是-MyBatis-的接口绑定-有什么好处？" class="headerlink" title="什么是 MyBatis 的接口绑定,有什么好处？"></a>什么是 MyBatis 的接口绑定,有什么好处？</h1><ul>
<li>接口映射就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定,我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置.</li>
</ul>
<h1 id="简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？-1"><a href="#简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？-1" class="headerlink" title="简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h1><ul>
<li>Mybatis 将所有Xml 配置信息都封装到All-In-One 重量级对象 Configuration内部</li>
<li>在 Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultMap>标签会被解析为ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、 <insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。</li>
</ul>
<h1 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h1><ul>
<li>Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，不过 mybatis 可以通过 XML 或注解方式灵活配置要运行的sql 语句，并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成 java 对象。</li>
<li>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 sql 映射文件，工作量大。</li>
<li>Hibernate 对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O&#x2F;R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</li>
</ul>
<h1 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h1><ul>
<li>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</li>
</ul>
<h1 id="Mybatis-是如何进行分页的？分页插件的原理是什么？-1"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？-1" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><ul>
<li>Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。</li>
<li>分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql。</li>
<li>select * from student，拦截 sql 后重写为：select t.* from （select * from student）t limit 0，10</li>
</ul>
<h1 id="MyBatis-实现一对多有几种方式-怎么操作的？"><a href="#MyBatis-实现一对多有几种方式-怎么操作的？" class="headerlink" title="MyBatis 实现一对多有几种方式,怎么操作的？"></a>MyBatis 实现一对多有几种方式,怎么操作的？</h1><ul>
<li>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap 里面的 collection 节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。</li>
</ul>
<h1 id="MyBatis-实现一对一有几种方式-具体怎么操作的？-1"><a href="#MyBatis-实现一对一有几种方式-具体怎么操作的？-1" class="headerlink" title="MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>MyBatis 实现一对一有几种方式?具体怎么操作的？</h1><ul>
<li>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap 里面配置 association 节点配置一对一的类就可以完成；<br>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。</li>
</ul>
<h1 id="为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h1><ul>
<li>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</li>
</ul>
<h1 id="Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#Mybatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h1><ul>
<li>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；<br>原因就是 namespace+id 是作为 Map&lt;String, MapperStatement&gt;的 key使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</li>
</ul>
<h1 id="Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql？"><a href="#Mybatis-动态-sql-有什么用？执行原理？有哪些动态-sql？" class="headerlink" title="Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？"></a>Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？</h1><ul>
<li>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。</li>
<li>Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</li>
</ul>
<h1 id="在-mapper-中如何传递多个参数"><a href="#在-mapper-中如何传递多个参数" class="headerlink" title="在 mapper 中如何传递多个参数?"></a>在 mapper 中如何传递多个参数?</h1><ul>
<li>第一种：DAO 层的函数</li>
<li>第二种： 使用 @param 注解:</li>
<li>第三种：多个参数封装成 map</li>
</ul>
<h1 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h1><ul>
<li>insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。</li>
<li>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。</li>
</ul>
<h1 id="当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h1><ul>
<li>第 1 种： 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li>
<li>第 2 种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。</li>
</ul>
<h1 id="Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h1><ul>
<li>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。</li>
<li>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个 &lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MapperStatement 对象。</li>
<li>Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</li>
</ul>
<h1 id="什么是-Mybatis？"><a href="#什么是-Mybatis？" class="headerlink" title="什么是 Mybatis？"></a>什么是 Mybatis？</h1><ul>
<li>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</li>
<li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返回 result 的过程）。</li>
</ul>
<h4 id="Mybaits-的优点"><a href="#Mybaits-的优点" class="headerlink" title="Mybaits 的优点"></a>Mybaits 的优点</h4><ul>
<li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML标签，支持编写动态 SQL 语句，并可重用。</li>
<li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li>
<li>很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC 支持的数据库 MyBatis 都支持）。</li>
<li>能够与 Spring 很好的集成；</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li>
</ul>
<h4 id="MyBatis-框架的缺点"><a href="#MyBatis-框架的缺点" class="headerlink" title="MyBatis 框架的缺点"></a>MyBatis 框架的缺点</h4><ul>
<li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL 语句的功底有一定要求。</li>
<li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ul>
<h4 id="MyBatis-框架适用场合"><a href="#MyBatis-框架适用场合" class="headerlink" title="MyBatis 框架适用场合"></a>MyBatis 框架适用场合</h4><ul>
<li>MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。</li>
<li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是不错的选择。</li>
</ul>
<h1 id="解释一下-MyBatis-中命名空间（namespace）的作用。"><a href="#解释一下-MyBatis-中命名空间（namespace）的作用。" class="headerlink" title="解释一下 MyBatis 中命名空间（namespace）的作用。"></a>解释一下 MyBatis 中命名空间（namespace）的作用。</h1><ul>
<li>在大型项目中，可能存在大量的 SQL 语句，这时候为每个 SQL 语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在 MyBatis 中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不会再产生冲突了。</li>
</ul>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/publishes/b318dfbd2190.html</url>
    <content><![CDATA[<h1 id="BIO、NIO和AIO的区别？"><a href="#BIO、NIO和AIO的区别？" class="headerlink" title="BIO、NIO和AIO的区别？"></a>BIO、NIO和AIO的区别？</h1><ul>
<li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</li>
<li>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</li>
<li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li>
<li>AIO：一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的。</li>
<li>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I&#x2F;O，I&#x2F;O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。</li>
<li>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作</li>
<li>如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<h1 id="NIO的组成"><a href="#NIO的组成" class="headerlink" title="NIO的组成"></a>NIO的组成</h1><ul>
<li>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</li>
<li>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</li>
<li>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。</li>
<li>rewind方法 ： 重绕此缓冲区，将position置为0</li>
<li>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I&#x2F;O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</li>
<li>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！</li>
<li>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</li>
<li>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</li>
<li>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</li>
<li>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取<br>-NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</li>
</ul>
<h1 id="Netty的特点？"><a href="#Netty的特点？" class="headerlink" title="Netty的特点？"></a>Netty的特点？</h1><ul>
<li>一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持</li>
<li>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。</li>
<li>采用多种decoder&#x2F;encoder 支持，对TCP粘包&#x2F;分包进行自动化处理</li>
<li>可使用接受&#x2F;处理线程池，提高连接效率，对重连、心跳检测的简单支持</li>
<li>可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf</li>
<li>通过引用计数器及时申请释放不再引用的对象，降低了GC频率</li>
<li>使用单线程串行化的方式，高效的Reactor线程模型</li>
<li>大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用</li>
</ul>
<h1 id="Netty的线程模型？"><a href="#Netty的线程模型？" class="headerlink" title="Netty的线程模型？"></a>Netty的线程模型？</h1><ul>
<li>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池</li>
<li>其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池</li>
<li>其中work线程池负责请求的read和write事件，由对应的Handler处理。</li>
</ul>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><ul>
<li>所有I&#x2F;O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的</li>
<li>既要接收客户端的连接请求,向服务端发起连接，又要发送&#x2F;读取请求或应答&#x2F;响应消息</li>
<li>一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</li>
</ul>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul>
<li>有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求</li>
<li>NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送</li>
<li>1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题</li>
<li>但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</li>
</ul>
<h4 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h4><ul>
<li>Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I&#x2F;O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；</li>
</ul>
<h1 id="TCP-粘包-拆包的原因及解决方法？"><a href="#TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="TCP 粘包&#x2F;拆包的原因及解决方法？"></a>TCP 粘包&#x2F;拆包的原因及解决方法？</h1><ul>
<li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li>
</ul>
<h4 id="TCP粘包-分包的原因："><a href="#TCP粘包-分包的原因：" class="headerlink" title="TCP粘包&#x2F;分包的原因："></a>TCP粘包&#x2F;分包的原因：</h4><ul>
<li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象</li>
<li>而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</li>
<li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li>
<li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>消息定长：FixedLengthFrameDecoder类</li>
<li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
<h1 id="了解哪几种序列化协议？"><a href="#了解哪几种序列化协议？" class="headerlink" title="了解哪几种序列化协议？"></a>了解哪几种序列化协议？</h1><ul>
<li>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；</li>
<li>反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</li>
<li>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</li>
</ul>
<h4 id="Java默认提供的序列化"><a href="#Java默认提供的序列化" class="headerlink" title="Java默认提供的序列化"></a>Java默认提供的序列化</h4><ul>
<li>无法跨语言、序列化后的码流太大、序列化的性能差</li>
</ul>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><ul>
<li>优点：人机可读性好，可指定元素或特性的名称</li>
<li>缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽</li>
<li>适用场景：当做配置文件存储数据，实时数据转换。</li>
</ul>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul>
<li>是一种轻量级的数据交换格式</li>
<li>优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快</li>
<li>缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大</li>
<li>适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li>
</ul>
<h4 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h4><ul>
<li>采用一种“假定有序快速匹配”的算法</li>
<li>优点：接口简单易用、目前java语言中最快的json库</li>
<li>缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全</li>
<li>适用场景：协议交互、Web输出、Android客户端</li>
</ul>
<h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><ul>
<li>不仅是序列化协议，还是一个RPC框架</li>
<li>优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码</li>
<li>缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议</li>
<li>适用场景：分布式系统的RPC解决方案</li>
</ul>
<h4 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h4><ul>
<li>Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题</li>
<li>优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现</li>
<li>缺点：对于习惯于静态类型语言的用户不直观</li>
<li>适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</li>
</ul>
<h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><ul>
<li>将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性</li>
<li>优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护</li>
<li>缺点：需要依赖于工具生成代码、支持的语言相对较少</li>
<li>适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li>protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可</li>
<li>Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口</li>
<li>Message pack 一个高效的二进制序列化格式</li>
<li>Hessian 采用二进制协议的轻量级remoting onhttp工具</li>
<li>kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）</li>
</ul>
<h1 id="如何选择序列化协议？"><a href="#如何选择序列化协议？" class="headerlink" title="如何选择序列化协议？"></a>如何选择序列化协议？</h1><h4 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h4><ul>
<li>对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。</li>
<li>基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选</li>
<li>对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</li>
<li>对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</li>
<li>当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</li>
<li>对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。</li>
<li>对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯</li>
<li>由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</li>
<li>如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</li>
<li>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</li>
<li>protobuf的数据类型有多种<ul>
<li>bool、double、float、int32、int64、string、bytes、enum、message</li>
<li>protobuf的限定符：<ul>
<li>required: 必须赋值，不能为空</li>
<li>optional:字段可以赋值，也可以不赋值</li>
<li>repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="protobuf的基本规则"><a href="#protobuf的基本规则" class="headerlink" title="protobuf的基本规则"></a>protobuf的基本规则</h4><ul>
<li>每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段</li>
<li>repeated表示的字段可以包含0个或多个数据</li>
<li>[1,15]之内的标识号在编码的时候会占用一个字节（常用）</li>
<li>[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。</li>
<li>protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。</li>
<li>编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder &#x3D; UserProto.User.newBuilder();builder.build()；</li>
<li>Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类</li>
<li>将StringBuilder转换为ByteBuf类型：copiedBuffer()方法</li>
</ul>
<h1 id="Netty的零拷贝实现？"><a href="#Netty的零拷贝实现？" class="headerlink" title="Netty的零拷贝实现？"></a>Netty的零拷贝实现？</h1><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝</li>
<li>堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中</li>
<li>ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li>
<li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer</li>
<li>addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li>
<li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li>
<li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</li>
<li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li>
<li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。</li>
</ul>
<h1 id="Netty的高性能表现在哪些方面？"><a href="#Netty的高性能表现在哪些方面？" class="headerlink" title="Netty的高性能表现在哪些方面？"></a>Netty的高性能表现在哪些方面？</h1><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><ul>
<li>对服务端：会定时清除闲置会话inactive(netty5)</li>
<li>对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态</li>
</ul>
<h4 id="串行无锁化设计"><a href="#串行无锁化设计" class="headerlink" title="串行无锁化设计"></a>串行无锁化设计</h4><ul>
<li>即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁</li>
<li>表面上看，串行化设计似乎CPU利用率不高，并发程度不够</li>
<li>但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</li>
</ul>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul>
<li>链路有效性检测：链路空闲检测机制，读&#x2F;写空闲超时机制</li>
<li>内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护</li>
<li>优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</li>
</ul>
<h4 id="Netty安全性"><a href="#Netty安全性" class="headerlink" title="Netty安全性"></a>Netty安全性</h4><ul>
<li>支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。</li>
</ul>
<h4 id="高效并发编程的体现"><a href="#高效并发编程的体现" class="headerlink" title="高效并发编程的体现"></a>高效并发编程的体现</h4><ul>
<li>volatile的大量、正确使用</li>
<li>CAS和原子类的广泛使用</li>
<li>线程安全容器的使用</li>
<li>通过读写锁提升并发性能</li>
<li>IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）</li>
</ul>
<h4 id="流量整型的作用（变压器）"><a href="#流量整型的作用（变压器）" class="headerlink" title="流量整型的作用（变压器）"></a>流量整型的作用（变压器）</h4><ul>
<li>防止由于上下游网关性能不均衡导致下游网关被压垮，业务流中断</li>
<li>防止由于通信模块接收消息过快，后端业务线程处理不及时导致撑死问题。</li>
</ul>
<h4 id="TCP参数配置"><a href="#TCP参数配置" class="headerlink" title="TCP参数配置"></a>TCP参数配置</h4><ul>
<li>SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K</li>
<li>SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率</li>
<li>但是对于时延敏感的应用场景需要关闭该优化算法；</li>
</ul>
<h1 id="NIOEventLoopGroup源码？"><a href="#NIOEventLoopGroup源码？" class="headerlink" title="NIOEventLoopGroup源码？"></a>NIOEventLoopGroup源码？</h1><ul>
<li>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。</li>
<li>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素</li>
<li>如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回</li>
<li>如果taskQueue没有元素，执行 select(oldWakenUp) 方法</li>
<li>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。</li>
<li>rebuildSelector方法先通过openSelector方法创建一个新的selector</li>
<li>然后将old selector的selectionKey执行cancel</li>
<li>最后将old selector的channel重新注册到新的selector中</li>
<li>rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</li>
<li>接下来调用processSelectedKeys 方法（处理I&#x2F;O任务），当selectedKeys !&#x3D; null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。</li>
<li>最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。</li>
<li>每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。</li>
<li>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head</li>
<li>Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。</li>
</ul>
<h4 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h4><ul>
<li>首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成</li>
<li>Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址</li>
<li>当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了</li>
<li>大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。</li>
</ul>
<h4 id="ByteBuf的特点"><a href="#ByteBuf的特点" class="headerlink" title="ByteBuf的特点"></a>ByteBuf的特点</h4><ul>
<li>支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）</li>
<li>不需要调用flip()来切换读&#x2F;写模式，读取和写入索引分开</li>
<li>方法链</li>
<li>引用计数基于AtomicIntegerFieldUpdater用于内存回收</li>
<li>PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象</li>
<li>UnpooledHeapByteBuf每次都会新建一个缓冲区对象。</li>
</ul>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/publishes/726ed62e2d44.html</url>
    <content><![CDATA[<h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><ul>
<li>Nginx应该是现在最火的web和反向代理服务器，没有之一</li>
<li>它是一款诞生于俄罗斯的高性能web服务器，尤其在高并发情况下，相较Apache，有优异的表现。</li>
</ul>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><ul>
<li>Nginx擅长处理静态文件，是非常好的图片、文件服务器</li>
<li>把所有的静态资源的放到nginx上，可以使应用动静分离，性能更好</li>
</ul>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><ul>
<li>Nginx通过反向代理可以实现服务的负载均衡，避免了服务器单节点故障，把请求按照一定的策略转发到不同的服务器上，达到负载的效果。</li>
</ul>
<h6 id="常用的负载均衡策略有"><a href="#常用的负载均衡策略有" class="headerlink" title="常用的负载均衡策略有"></a>常用的负载均衡策略有</h6><ul>
<li>轮询 <ul>
<li>将请求按顺序轮流地分配到后端服务器上</li>
<li>它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li>
</ul>
</li>
<li>加权轮询<ul>
<li>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同</li>
<li>给配置高、负载低的机器配置更高的权重，让其处理更多的请；</li>
<li>而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li>
</ul>
</li>
<li>ip_hash（源地址哈希法）<ul>
<li>根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问服务器的序号。</li>
<li>采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li>
</ul>
</li>
<li>随机<ul>
<li>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。</li>
</ul>
</li>
<li>least_conn（最小连接数法）<ul>
<li>由于后端服务器的配置不尽相同，对于请求的处理有快有慢</li>
<li>最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li>
</ul>
</li>
</ul>
<h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><ul>
<li>Nginx的限流模块，是基于漏桶算法实现的，在高并发的场景下非常实用，如下图：</li>
</ul>
<h6 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h6><ul>
<li>limit_req_zone定义在http块中，$binary_remote_addr 表示保存客户端IP地址的二进制形式。</li>
<li>Zone定义IP状态及URL访问频率的共享内存区域。<br>-zone&#x3D;keyword标识区域的名字，以及冒号后面跟区域大小。16000个IP地址的状态信息约1MB，所以示例中区域可以存储160000个IP地址。</li>
<li>Rate定义最大请求速率。示例中速率不能超过每秒100个请求。</li>
</ul>
<h6 id="设置限流"><a href="#设置限流" class="headerlink" title="设置限流"></a>设置限流</h6><ul>
<li>burst排队大小，nodelay不限制单个请求间的时间。</li>
</ul>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul>
<li>浏览器缓存，静态资源缓存用expire。</li>
<li>代理层缓存</li>
</ul>
<h5 id="黑白名单"><a href="#黑白名单" class="headerlink" title="黑白名单"></a>黑白名单</h5><ul>
<li>不限流白名单</li>
<li>黑名单</li>
</ul>
<h1 id="Nginx性能调优："><a href="#Nginx性能调优：" class="headerlink" title="Nginx性能调优："></a>Nginx性能调优：</h1><ul>
<li>增加同时打开⽂件数open files数量；</li>
<li>处理⼤量静态⽂件的磁盘I&#x2F;O时(此时worker进程是单线程的)，增加CPU核⼼数Worker Processes数量，提⾼计算能⼒；</li>
<li>如果⽹站流量很⾼，则可以提升worker进程连接数Worker Connections(默认1024)；</li>
<li>控制keep alive在10s-20s之间，减少连接的时间开销；</li>
<li>合理设置open file cache时间提⾼处理效率；</li>
<li>提⾼⽹路带宽；</li>
<li>开启压缩传输数据gzip，设置压缩级别gzip_comp_level为1-2，再⾼效果不明显并且浪费CPU了；</li>
<li>扩展机器数量。</li>
</ul>
<h1 id="Nginx-有哪些作用？"><a href="#Nginx-有哪些作用？" class="headerlink" title="Nginx 有哪些作用？"></a>Nginx 有哪些作用？</h1><ul>
<li>http 协议代理</li>
<li>搭建虚拟主机</li>
<li>服务的反向代理</li>
<li>在反向代理中配置集群的负载均衡</li>
</ul>
<h1 id="什么是正向代理？"><a href="#什么是正向代理？" class="headerlink" title="什么是正向代理？"></a>什么是正向代理？</h1><ul>
<li>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</li>
</ul>
<h1 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h1><ul>
<li>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li>
</ul>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/publishes/0777702c9d7f.html</url>
    <content><![CDATA[<h1 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h1><ul>
<li>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。</li>
<li>当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。</li>
<li>除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</li>
<li>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。</li>
<li>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</li>
<li>RPC 在我们熟知的各种中间件中都有它的身影。</li>
<li>Nginx&#x2F;Redis&#x2F;MySQL&#x2F;Dubbo&#x2F;Hadoop&#x2F;Spark&#x2F;Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的</li>
<li>我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。</li>
</ul>
<h1 id="Nginx-与-RPC"><a href="#Nginx-与-RPC" class="headerlink" title="Nginx 与 RPC"></a>Nginx 与 RPC</h1><ul>
<li>Ngnix 是互联网企业使用最为广泛的代理服务器。</li>
<li>它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务</li>
<li>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互</li>
<li>也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。</li>
<li>你说的没错，不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</li>
<li>uWSGI 是著名的 Python 容器，使用它可以启动 uwsgi 协议的服务器对外提供服务。</li>
<li>uwsgi 通讯协议在 Python 语言体系里使用非常普遍，如果一个企业内部使用 Python 语言栈搭建 Web 服务，那么他们在生产环境部署 Python 应用的时候不是在使用 HTTP 协议就是在使用 uwsgi 协议来和 Nginx 之间建立通讯。</li>
<li>Fastcgi 协议在 PHP 语言体系里非常常见，Nginx 和 PHP-fpm 进程之间一般较常使用 Fastcgi 协议进行通讯。</li>
</ul>
<h1 id="Hadoop-与-RPC"><a href="#Hadoop-与-RPC" class="headerlink" title="Hadoop 与 RPC"></a>Hadoop 与 RPC</h1><ul>
<li>在大数据技术领域，RPC 也占据了非常重要的地位</li>
<li>大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在</li>
<li>大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。</li>
<li>比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</li>
</ul>
<h1 id="TensorFlow-与-RPC"><a href="#TensorFlow-与-RPC" class="headerlink" title="TensorFlow 与 RPC"></a>TensorFlow 与 RPC</h1><ul>
<li>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯</li>
<li>Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</li>
</ul>
<h1 id="Http-与-RPC"><a href="#Http-与-RPC" class="headerlink" title="Http 与 RPC"></a>Http 与 RPC</h1><ul>
<li>HTTP 调用其实也是一种特殊的 RPC</li>
<li>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。</li>
<li>HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</li>
<li>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了</li>
<li>所以在后文我们不再明确强调 RPC 和 HTTP 请求调用之间的细微区别了，直接统一称之为 RPC。</li>
</ul>
<h1 id="HTTP-VS-RPC-（普通话-VS-方言）"><a href="#HTTP-VS-RPC-（普通话-VS-方言）" class="headerlink" title="HTTP VS RPC （普通话 VS 方言）"></a>HTTP VS RPC （普通话 VS 方言）</h1><ul>
<li>HTTP 与 RPC 的关系就好比普通话与方言的关系</li>
<li>要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本</li>
<li>但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源</li>
<li>整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。</li>
<li>如果再深入一点说，普通话本质上也是一种方言，只不过它是官方的方言，使用最为广泛的方言，相比而言其它方言都是小语种，小语种之中也会有几个使用比较广泛比较特色的方言占比也会比较大。</li>
<li>这就好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</li>
</ul>
<h1 id="换个角度看世界"><a href="#换个角度看世界" class="headerlink" title="换个角度看世界"></a>换个角度看世界</h1><ul>
<li>分布式子系统交互方案，除了 RPC 技术之外还有数据库、消息队列和缓存。但其实这三者本质上是 RPC 技术的一个应用组合。</li>
<li>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。</li>
<li>如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL</li>
<li>在互联网企业里一般都会使用这种主从读写分离的数据库</li>
<li>一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来</li>
<li>这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</li>
</ul>
]]></content>
      <categories>
        <category>rpc</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC</title>
    <url>/publishes/235b69f65d9c.html</url>
    <content><![CDATA[<h1 id="什么是SpringMvc？"><a href="#什么是SpringMvc？" class="headerlink" title="什么是SpringMvc？"></a>什么是SpringMvc？</h1><ul>
<li>SpringMvc是spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。</li>
</ul>
<h1 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h1><ul>
<li>它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成. </li>
<li>不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的) </li>
<li>可以任意使用各种视图技术,而不仅仅局限于JSP </li>
<li>支持各种请求资源的映射策略 </li>
<li>它应是易于扩展的</li>
</ul>
<h1 id="SpringMVC工作原理？"><a href="#SpringMVC工作原理？" class="headerlink" title="SpringMVC工作原理？"></a>SpringMVC工作原理？</h1><h4 id="简要回答"><a href="#简要回答" class="headerlink" title="简要回答"></a>简要回答</h4><ul>
<li>客户端发送请求到DispatcherServlet </li>
<li>DispatcherServlet查询handlerMapping找到处理请求的Controller </li>
<li>Controller调用业务逻辑后，返回ModelAndView </li>
<li>DispatcherServlet查询ModelAndView，找到指定视图 </li>
<li>视图将结果返回到客户端</li>
</ul>
<h4 id="详细回答"><a href="#详细回答" class="headerlink" title="详细回答"></a>详细回答</h4><ul>
<li>用户发送请求至前端控制器DispatcherServlet。 </li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li>
<li>Controller执行完成返回ModelAndView。 </li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 </li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li>
<li>ViewReslover解析后返回具体View。 </li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>
<li>DispatcherServlet响应用户。</li>
</ul>
<h4 id="详细回答2"><a href="#详细回答2" class="headerlink" title="详细回答2"></a>详细回答2</h4><ul>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器</li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户</li>
</ul>
<h1 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h1><ul>
<li><p>在web.xml中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上可以解决post请求乱码问题</p>
</li>
<li><p>对于get请求中文参数出现乱码解决方法有两个：</p>
<ul>
<li><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外一种方法对参数进行重新编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p>
</li>
</ul>
<h1 id="SpringMVC与Struts2的主要区别？"><a href="#SpringMVC与Struts2的主要区别？" class="headerlink" title="SpringMVC与Struts2的主要区别？"></a>SpringMVC与Struts2的主要区别？</h1><ul>
<li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。Jsp视图解析器默认使用jstl。</li>
<li>springmvc是基于方法开发，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
</ul>
<h1 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h1><ul>
<li>是单例模式</li>
<li>所以在多线程访问的时候有线程安全问题</li>
<li>不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</li>
</ul>
<h1 id="SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</h1><ul>
<li>一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。</li>
</ul>
<h1 id="RequestMapping注解用在类上面有什么作用？"><a href="#RequestMapping注解用在类上面有什么作用？" class="headerlink" title="@RequestMapping注解用在类上面有什么作用？"></a>@RequestMapping注解用在类上面有什么作用？</h1><ul>
<li>是一个用来处理请求地址映射的注解，可用于类或方法上</li>
<li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li>
</ul>
<h1 id="怎么样把某个请求映射到特定的方法上面？"><a href="#怎么样把某个请求映射到特定的方法上面？" class="headerlink" title="怎么样把某个请求映射到特定的方法上面？"></a>怎么样把某个请求映射到特定的方法上面？</h1><ul>
<li>直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径</li>
</ul>
<h1 id="如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？"><a href="#如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？" class="headerlink" title="如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？"></a>如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？</h1><ul>
<li>可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET</li>
</ul>
<h1 id="怎么样在方法里面得到Request-或者Session？"><a href="#怎么样在方法里面得到Request-或者Session？" class="headerlink" title="怎么样在方法里面得到Request,或者Session？"></a>怎么样在方法里面得到Request,或者Session？</h1><ul>
<li>直接在方法的形参中声明request,SpringMvc就自动把request对象传入</li>
</ul>
<h1 id="我想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#我想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="我想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>我想在拦截的方法里面得到从前台传入的参数,怎么得到？</h1><ul>
<li>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样</li>
</ul>
<h1 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h1><ul>
<li>直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</li>
</ul>
<h1 id="SpringMvc中函数的返回值是什么？"><a href="#SpringMvc中函数的返回值是什么？" class="headerlink" title="SpringMvc中函数的返回值是什么？"></a>SpringMvc中函数的返回值是什么？</h1><ul>
<li>返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。</li>
</ul>
<h1 id="SpringMVC怎么样设定重定向和转发的？"><a href="#SpringMVC怎么样设定重定向和转发的？" class="headerlink" title="SpringMVC怎么样设定重定向和转发的？"></a>SpringMVC怎么样设定重定向和转发的？</h1><ul>
<li>在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name&#x3D;method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:<a href="http://www.baidu.com/">http://www.baidu.com</a>“</li>
</ul>
<h1 id="SpringMvc用什么对象从后台向前台传递数据的？"><a href="#SpringMvc用什么对象从后台向前台传递数据的？" class="headerlink" title="SpringMvc用什么对象从后台向前台传递数据的？"></a>SpringMvc用什么对象从后台向前台传递数据的？</h1><ul>
<li>通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。</li>
</ul>
<h1 id="SpringMvc中有个类把视图和数据都合并的一起的-叫什么？"><a href="#SpringMvc中有个类把视图和数据都合并的一起的-叫什么？" class="headerlink" title="SpringMvc中有个类把视图和数据都合并的一起的,叫什么？"></a>SpringMvc中有个类把视图和数据都合并的一起的,叫什么？</h1><ul>
<li>叫ModelAndView。</li>
</ul>
<h1 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h1><ul>
<li>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key</li>
</ul>
<h1 id="SpringMvc怎么和AJAX相互调用的？"><a href="#SpringMvc怎么和AJAX相互调用的？" class="headerlink" title="SpringMvc怎么和AJAX相互调用的？"></a>SpringMvc怎么和AJAX相互调用的？</h1><ul>
<li>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。 </li>
<li>具体步骤如下 ：<ul>
<li>加入Jackson.jar </li>
<li>在配置文件中配置json的映射 </li>
<li>在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</li>
</ul>
</li>
</ul>
<h1 id="当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？"><a href="#当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？" class="headerlink" title="当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？"></a>当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</h1><ul>
<li>要加上@ResponseBody注解</li>
</ul>
<h1 id="SpringMvc里面拦截器是怎么写的"><a href="#SpringMvc里面拦截器是怎么写的" class="headerlink" title="SpringMvc里面拦截器是怎么写的"></a>SpringMvc里面拦截器是怎么写的</h1><ul>
<li>有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;    </span><br><span class="line">    &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;   </span><br><span class="line">    &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.et.action.MyHandlerInterceptor&quot;&gt;&lt;/bean&gt;    </span><br><span class="line">    &lt;!-- 只针对部分请求拦截 --&gt;    </span><br><span class="line">    &lt;mvc:interceptor&gt;       </span><br><span class="line">        &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;       </span><br><span class="line">        &lt;bean class=&quot;com.et.action.MyHandlerInterceptorAdapter&quot; /&gt;  </span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="讲下SpringMvc的执行流程"><a href="#讲下SpringMvc的执行流程" class="headerlink" title="讲下SpringMvc的执行流程"></a>讲下SpringMvc的执行流程</h1><ul>
<li>系统启动的时候根据配置文件创建spring的容器</li>
<li>首先是发送http请求到核心控制器disPatherServlet</li>
<li>spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类</li>
<li>在进业务类时进行数据封装，在封装前可能会涉及到类型转换</li>
<li>执行完业务类后使用ModelAndView进行视图转发</li>
<li>数据放在model中，用map传递数据进行页面显示</li>
</ul>
<h1 id="框架的优缺点SpringMVC-Struts2等…"><a href="#框架的优缺点SpringMVC-Struts2等…" class="headerlink" title="框架的优缺点SpringMVC,Struts2等…"></a>框架的优缺点SpringMVC,Struts2等…</h1><ul>
<li>Struts2是类级别拦截，参数为类中所有⽅法共有，⼀个Action对应⼀个request上下⽂，SpringMVC是⽅法级别拦截，参数为对应⽅法所有；</li>
<li>由于Struts2需要针对每个request进⾏封装，把request，session等servlet⽣命周期的变量封装成⼀个⼀个Map，供给每个Action使⽤，并保证线程安全，所以在原则上，是⽐较耗费内存的。</li>
<li>拦截器实现机制上，Struts2有以⾃⼰的interceptor机制，SpringMVC⽤的是独⽴的AOP⽅式，这样导致Struts2的配置⽂件量还是⽐SpringMVC⼤。</li>
<li>SpringMVC的⼊⼝是servlet，⽽Struts2是filter</li>
<li>SpringMVC集成了Ajax，使⽤⾮常⽅便，只需⼀个注解@ResponseBody就可以实现，然后直接返回响应⽂本即可，⽽Struts2拦截器集成了Ajax，在Action中处理时⼀般必须安装插件或者⾃⼰写代码集成进去，使⽤起来也相对不⽅便。</li>
<li>SpringMVC开发效率和性能⾼于Struts2。</li>
<li>SpringMVC配置少，零配置。</li>
</ul>
<h1 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h1><ul>
<li>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序</li>
<li>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</li>
</ul>
]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/publishes/5788a7088796.html</url>
    <content><![CDATA[<h1 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h1><ul>
<li>如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了。</li>
<li>我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除 + 定期删除两种策略对过期键删除。</li>
<li>如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。</li>
<li>这就是缓存雪崩：Redis挂掉了，请求全部走数据库。</li>
<li>缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！</li>
</ul>
<h1 id="如何解决缓存雪崩"><a href="#如何解决缓存雪崩" class="headerlink" title="如何解决缓存雪崩"></a>如何解决缓存雪崩</h1><ul>
<li>使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间</li>
<li>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</li>
<li>大多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队，加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。</li>
<li>还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存</li>
<li>对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：<ul>
<li>事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。</li>
<li>事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li>
<li>事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
</li>
</ul>
<h1 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h1><ul>
<li>缓存穿透是指查询一个一定不存在的数据</li>
<li>由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存</li>
<li>这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。</li>
<li>这就是缓存穿透：请求的数据在缓存大量不命中，导致请求走数据库。</li>
<li>缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！</li>
</ul>
<h1 id="如何解决缓存穿透"><a href="#如何解决缓存穿透" class="headerlink" title="如何解决缓存穿透"></a>如何解决缓存穿透</h1><ul>
<li>解决缓存穿透也有两种方案：<ul>
<li>由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！</li>
<li>当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间</li>
</ul>
</li>
</ul>
<h1 id="缓存与数据库双写一致"><a href="#缓存与数据库双写一致" class="headerlink" title="缓存与数据库双写一致"></a>缓存与数据库双写一致</h1><ul>
<li>对于读操作，流程是这样的<ul>
<li>如果我们的数据在缓存里边有，那么就直接取缓存的。</li>
<li>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。最后将数据返回给请求</li>
</ul>
</li>
</ul>
<h1 id="什么是缓存与数据库双写一致问题"><a href="#什么是缓存与数据库双写一致问题" class="headerlink" title="什么是缓存与数据库双写一致问题"></a>什么是缓存与数据库双写一致问题</h1><ul>
<li>如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要更新时候呢？各种情况很可能就造成数据库和缓存的数据不一致了。</li>
<li>这里不一致指的是：数据库的数据跟缓存的数据不一致</li>
<li>从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。</li>
<li>因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</li>
</ul>
<h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><ul>
<li>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统</li>
<li>这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li>
<li>解决思路：<ul>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ul>
</li>
</ul>
<h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><ul>
<li>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<ul>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ul>
</li>
<li>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂</li>
</ul>
<h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><ul>
<li>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。</li>
<li>系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</li>
<li>降级的最终目的是保证核心服务可用，即使是有损的</li>
<li>而且有些服务是无法降级的（如加入购物车、结算）。</li>
<li>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅，从而梳理出哪些必须誓死保护，哪些可降级</li>
<li>比如可以参考日志级别设置预案：<ul>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ul>
</li>
</ul>
<h1 id="为什么使用-Redis"><a href="#为什么使用-Redis" class="headerlink" title="为什么使用 Redis"></a>为什么使用 Redis</h1><ul>
<li>主要是从两个角度去考虑：性能和并发。</li>
<li>当然，Redis 还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件，如 ZooKpeer 等代替，并不是非要使用 Redis</li>
<li>因此，这个问题主要从性能和并发两个角度去答</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，就特别适合将运行结果放入缓存</li>
<li>这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</li>
</ul>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ul>
<li>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。</li>
<li>这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库。</li>
</ul>
<h4 id="使用-Redis-有什么缺点"><a href="#使用-Redis-有什么缺点" class="headerlink" title="使用 Redis 有什么缺点"></a>使用 Redis 有什么缺点</h4><ul>
<li>回答主要是四个问题：<ul>
<li>缓存和数据库双写一致性问题</li>
<li>缓存雪崩问题</li>
<li>缓存击穿问题</li>
<li>缓存的并发竞争问题</li>
</ul>
</li>
</ul>
<h4 id="单线程的-Redis-为什么这么快"><a href="#单线程的-Redis-为什么这么快" class="headerlink" title="单线程的 Redis 为什么这么快"></a>单线程的 Redis 为什么这么快</h4><ul>
<li>回答主要是以下三点：<ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞 I&#x2F;O 多路复用机制</li>
</ul>
</li>
</ul>
<h4 id="I-O-多路复用机制"><a href="#I-O-多路复用机制" class="headerlink" title="I&#x2F;O 多路复用机制"></a>I&#x2F;O 多路复用机制</h4><ul>
<li>简单来说，就是我们的 redis-client 在操作的时候，会产生具有不同事件类型的 Socket。</li>
<li>在服务端，有一段 I&#x2F;O 多路复用程序，将其置入队列之中</li>
<li>然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</li>
<li>需要说明的是，这个 I&#x2F;O 多路复用机制，Redis 还提供了 select、epoll、evport、kqueue 等多路复用函数库，大家可以自行去了解。</li>
</ul>
<h1 id="Redis-的数据类型，以及每种数据类型的使用场景"><a href="#Redis-的数据类型，以及每种数据类型的使用场景" class="headerlink" title="Redis 的数据类型，以及每种数据类型的使用场景"></a>Redis 的数据类型，以及每种数据类型的使用场景</h1><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li>常规的 set&#x2F;get 操作，Value 可以是 String 也可以是数字</li>
<li>一般做一些复杂的计数功能的缓存</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><ul>
<li>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。</li>
<li>我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li>使用 List 的数据结构，可以做简单的消息队列的功能</li>
<li>可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li>因为 Set 堆放的是一堆不重复值的集合，所以可以做全局去重的功能</li>
<li>为什么不用 JVM 自带的 Set 进行去重？因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</li>
<li>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</li>
</ul>
<h4 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h4><ul>
<li>Sorted Set多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。</li>
<li>可以做排行榜应用，取 TOP N 操作</li>
<li>Sorted Set 可以用来做延时任务</li>
<li>最后一个应用就是可以做范围查找。</li>
</ul>
<h1 id="Redis-的过期策略以及内存淘汰机制"><a href="#Redis-的过期策略以及内存淘汰机制" class="headerlink" title="Redis 的过期策略以及内存淘汰机制"></a>Redis 的过期策略以及内存淘汰机制</h1><ul>
<li>Redis 采用的是定期删除+惰性删除策略。</li>
</ul>
<h4 id="为什么不用定时删除策略"><a href="#为什么不用定时删除策略" class="headerlink" title="为什么不用定时删除策略"></a>为什么不用定时删除策略</h4><ul>
<li>定时删除，用一个定时器来负责监视 Key，过期则自动删除</li>
<li>虽然内存及时释放，但是十分消耗 CPU 资源。</li>
<li>在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。</li>
</ul>
<h4 id="定期删除-惰性删除是如何工作"><a href="#定期删除-惰性删除是如何工作" class="headerlink" title="定期删除+惰性删除是如何工作"></a>定期删除+惰性删除是如何工作</h4><ul>
<li>定期删除，Redis 默认每隔 100ms 检查，是否有过期的 Key，有过期 Key 则删除。</li>
<li>需要说明的是，Redis 不是每隔 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。</li>
<li>如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。</li>
<li>也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。</li>
<li>采用定期删除+惰性删除就没其他问题了么?不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。</li>
<li>在 redis.conf 中有一行配置：maxmemory-policy volatile-lru</li>
<li>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)：<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。</li>
</ul>
</li>
<li>PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。</li>
</ul>
<h1 id="Redis-和数据库双写一致性问题"><a href="#Redis-和数据库双写一致性问题" class="headerlink" title="Redis 和数据库双写一致性问题"></a>Redis 和数据库双写一致性问题</h1><ul>
<li>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性</li>
<li>数据库和缓存双写，就必然会存在不一致的问题。</li>
<li>首先，采取正确更新策略，先更新数据库，再删缓存</li>
<li>其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li>
</ul>
<h1 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h1><h4 id="如果对这个-Key-操作，不要求顺序"><a href="#如果对这个-Key-操作，不要求顺序" class="headerlink" title="如果对这个 Key 操作，不要求顺序"></a>如果对这个 Key 操作，不要求顺序</h4><ul>
<li>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。</li>
</ul>
<h4 id="如果对这个-Key-操作，要求顺序"><a href="#如果对这个-Key-操作，要求顺序" class="headerlink" title="如果对这个 Key 操作，要求顺序"></a>如果对这个 Key 操作，要求顺序</h4><ul>
<li>假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。</li>
<li>期望按照 key1 的 value 值按照 valueA &gt; valueB &gt; valueC 的顺序变化</li>
<li>这种时候我们在数据写入数据库的时候，需要保存一个时间戳。</li>
<li>假设时间戳如下：<ul>
<li>系统A key 1 {valueA 3:00}</li>
<li>系统B key 1 {valueB 3:05}</li>
<li>系统C key 1 {valueC 3:10}</li>
</ul>
</li>
<li>那么，假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。</li>
<li>其他方法，比如利用队列，将 set 方法变成串行访问也可以。总之，灵活变通。</li>
</ul>
<h1 id="分布式缓存，⼀致性hash"><a href="#分布式缓存，⼀致性hash" class="headerlink" title="分布式缓存，⼀致性hash"></a>分布式缓存，⼀致性hash</h1><ul>
<li>⼀致性hash算法：⼀致性hash算法是对我们要存储数据的服务器进⾏hash计算，进⽽确认每个key的存储位置</li>
<li>这⾥提到的⼀致性hash算法ketama的做法是：选择具体的机器节点不在只依赖需要缓存数据的key的hash本身了，⽽是机器节点本身也进⾏了hash运<br>算。</li>
<li>⼀致性hash算法是分布式系统中常⽤算法，设计⽬的是为了解决因特⽹中的热点(hot spot)问题</li>
<li>解决了P2P环境最为关键问题—如何在动态⽹络拓扑中分布存储和路由；</li>
<li>⼀致性hash算法引⼊虚拟节点机制，解决服务节点少时数据倾斜问题(即对每⼀个服务节点计算多个哈希，每个计算结果位置都放置⼀个此服务节点，称为虚拟节点。)；</li>
<li>具体做法：如果有⼀个写⼊缓存的请求，其中Key值为K，计算器hash值Hash(K)， Hash(K) 对应于图 – 1环中的某⼀个点，如果该点对应没有映射到具体的某⼀个机器节点，那么顺时针查找，直到第⼀次找到有映射机器的节点，该节点就是确定的⽬标节点，如果超过了2^32仍然找不到节点，则命中第⼀个机器节点</li>
<li>⽐如 Hash(K) 的值介于A~B之间，那么命中的机器节点应该是B节点（如上图 ）。</li>
<li>数据保存流程：<ul>
<li>⾸先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。</li>
<li>然后采⽤同样的⽅法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第⼀个服务器上。如果超过232仍然找不到服务器，就会保存到第⼀台memcached服务器上。</li>
</ul>
</li>
</ul>
<h1 id="如何解决缓存单机热点问题"><a href="#如何解决缓存单机热点问题" class="headerlink" title="如何解决缓存单机热点问题"></a>如何解决缓存单机热点问题</h1><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>缓存服务器⾃身有限流保持<ul>
<li>缓存服务器数量 * 单机能够承受的qps &gt; ⽤户最⼤的QPS 就会触发限流保护</li>
<li>针对这个原因：可以做横向扩容。加机器即可</li>
</ul>
</li>
<li>⽤户访问过来cache服务器集中打到⼀台上⾯了<ul>
<li>⼤流量并没有按预期的那样分摊到不同的cache机器上导致出现单机热点。(热点数据)</li>
<li>针对这个原因：只要计算cache-hash算法不出问题，那基本上可以做到缓存的随机分布均匀的</li>
</ul>
</li>
<li>缓存⾥⾯的value过⼤<ul>
<li>导致虽然QPS不⾼，但⽹络流量（qps * 单个value的⼤⼩）还是过⼤，触发了cache机器单台机器的⽹络流量限流；</li>
<li>针对这个原因：需要把⼤value进⾏精简，部分可以放在本机内存⽽不需要⾛远程获取这种⽅式的。</li>
</ul>
</li>
</ul>
<h4 id="解决⽅法"><a href="#解决⽅法" class="headerlink" title="解决⽅法"></a>解决⽅法</h4><ul>
<li>针对cache中元素key的访问监控</li>
<li>⼀旦发现cache有qps限流或⽹络⼤⼩限流时，能够通过监控看到到底是哪个key并发访问量过⼤导致，或者哪些key返回的value⼤⼩较⼤</li>
<li>再结合cache散列算法，通过⼀定的规则动态修改key值去平摊到各个cache机器上去。</li>
</ul>
<h1 id="memcache与redis的区别"><a href="#memcache与redis的区别" class="headerlink" title="memcache与redis的区别"></a>memcache与redis的区别</h1><ul>
<li>Redis中，并不是所有的数据都⼀直存储在内存中的，这是和Memcached相⽐⼀个最⼤的区别。</li>
<li>Memcache仅仅⽀持简单的k&#x2F;v类型的数据，Redis同时还提供String, list，set，hash等数据结构的存储。</li>
<li>Redis⽀持数据的备份，即master-slave模式的数据备份。</li>
<li>Redis⽀持数据的持久化，可以将内存中的数据保持在磁盘中（rdb定时快照和aof实时记录操作命令的⽇志备<br>份），重启的时候可以再次加载进⾏使⽤。Redis在很多⽅⾯具备数据库的特征，或者说就是⼀个数据库系统，⽽<br>Memcached只是简单的K&#x2F;V缓存</li>
<li>Redis可以做⼀些聚合、排序操作。</li>
<li>memcache使⽤cas乐观锁做⼀致性：拿版本号，操作，对⽐版本号，如果⼀致就操作，不⼀致就放弃任何操作；</li>
<li>⼤数据memcached性能更⾼。由于Redis只使⽤单核，⽽Memcached可以使⽤多核，所以平均每⼀个核上<br>Redis在存储⼩数据时⽐Memcached性能更⾼。⽽在100k以上的数据中，Memcached性能要⾼于Redis 。</li>
</ul>
<h1 id="redis-本身有持久化，为什么还要写进-mysql-呢？"><a href="#redis-本身有持久化，为什么还要写进-mysql-呢？" class="headerlink" title="redis 本身有持久化，为什么还要写进 mysql 呢？"></a>redis 本身有持久化，为什么还要写进 mysql 呢？</h1><ul>
<li>RDB：快照形式是直接把内存中的数据保存到⼀个 dump ⽂件中，定时保存，保存策略。</li>
<li>AOF：把所有的对Redis的服务器进⾏修改的命令都存到⼀个⽂件⾥，命令的集合。</li>
<li>RDB会丢数据，AOF性能不⾏</li>
<li>有改动先插⼊数据库，再插缓存，⽐较靠谱但性能⼀般；</li>
<li>有改动先插缓存，批量更新到数据库，靠谱度略差，但性能好。</li>
</ul>
<h1 id="redis的数据结构和各种应⽤场景？"><a href="#redis的数据结构和各种应⽤场景？" class="headerlink" title="redis的数据结构和各种应⽤场景？"></a>redis的数据结构和各种应⽤场景？</h1><ul>
<li>更多的数据结构；</li>
<li>可持久化；</li>
<li>计数器；</li>
<li>发布-订阅功能；</li>
<li>事务功能；</li>
<li>过期回调功能；</li>
<li>队列功能；</li>
<li>排序、聚合查询功能。</li>
</ul>
<h1 id="redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高"><a href="#redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高" class="headerlink" title="redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高"></a>redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高</h1><ul>
<li>区别：<ul>
<li>mc可缓存图片和视频。rd支持除k&#x2F;v更多的数据结构;</li>
<li>rd可以使用虚拟内存，rd可持久化和aof灾难恢复，rd通过主从支持数据备份;</li>
<li>rd可以做消息队列。</li>
</ul>
</li>
<li>原因：mc多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。</li>
</ul>
<h1 id="redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？"><a href="#redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？" class="headerlink" title="redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？"></a>redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？</h1><ul>
<li>主从复制实现<ul>
<li>主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数据恢复到内存中</li>
<li>之后再每次增加新数据的时候，主节点以类似于mysql的二进制日志方式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放。</li>
</ul>
</li>
<li>分片方式：<ul>
<li>客户端分片</li>
<li>基于代理的分片<ul>
<li>Twemproxy</li>
<li>codis</li>
</ul>
</li>
<li>路由查询分片</li>
</ul>
</li>
<li>Redis-cluster（本身提供了自动将数据分散到Redis Cluster不同节点的能力，整个数据集合的某个数据子集存储在哪个节点对于用户来说是透明的）</li>
<li>redis-cluster分片原理<ul>
<li>Cluster中有一个16384长度的槽(虚拟槽)，编号分别为0-16383</li>
<li>每个Master节点都会负责一部分的槽，当有某个key被映射到某个Master负责的槽，那么这个Master负责为这个key提供服务</li>
<li>至于哪个Master节点负责哪个槽，可以由用户指定，也可以在初始化的时候自动生成，只有Master才拥有槽的所有权</li>
<li>Master节点维护着一个16384&#x2F;8字节的位序列，Master节点用bit来标识对于某个槽自己是否拥有</li>
<li>比如对于编号为1的槽，Master只要判断序列的第二位（索引从0开始）是不是为1即可</li>
<li>这种结构很容易添加或者删除节点</li>
<li>比如如果我想新添加个节点D, 我需要从节点A、B、 C中得部分槽到D上。</li>
</ul>
</li>
</ul>
<h1 id="使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？"><a href="#使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？" class="headerlink" title="使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？"></a>使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？</h1><ul>
<li>redis:<ul>
<li>线程A setnx(上锁的对象,超时时的时间戳t1)，如果返回true，获得锁。</li>
<li>线程B 用get获取t1,与当前时间戳比较,判断是是否超时,没超时false,若超时执行第3步;</li>
<li>计算新的超时时间t2,使用getset命令返回t3(该值可能其他线程已经修改过),如果t1&#x3D;&#x3D;t3，获得锁，如果t1!&#x3D;t3说明锁被其他线程获取了。</li>
<li>获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）。</li>
</ul>
</li>
<li>zk:<ul>
<li>客户端对某个方法加锁时，在zk上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点node1;</li>
<li>客户端获取该路径下所有已经创建的子节点，如果发现自己创建的node1的序号是最小的，就认为这个客户端获得了锁。</li>
<li>如果发现node1不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。</li>
<li>获取锁后，处理完逻辑，删除自己创建的node1即可。</li>
</ul>
</li>
<li>区别:zk性能差一些，开销大，实现简单。</li>
</ul>
<h1 id="知道redis的持久化吗？底层如何实现的？有什么优点缺点？"><a href="#知道redis的持久化吗？底层如何实现的？有什么优点缺点？" class="headerlink" title="知道redis的持久化吗？底层如何实现的？有什么优点缺点？"></a>知道redis的持久化吗？底层如何实现的？有什么优点缺点？</h1><ul>
<li>RDB(Redis DataBase:在不同的时间点将redis的数据生成的快照同步到磁盘等介质上)<ul>
<li>内存到硬盘的快照，定期更新</li>
<li>缺点：耗时，耗性能(fork+io操作)，易丢失数据。</li>
</ul>
</li>
<li>AOF(Append Only File：将redis所执行过的所有指令都记录下来，在下次redis重启时，只需要执行指令就可以了)<ul>
<li>写日志</li>
<li>缺点：体积大，恢复速度慢。</li>
</ul>
</li>
<li>bgsave做镜像全量持久化，aof做增量持久化</li>
<li>因为bgsave会消耗比较长的时间，不够实时，在停机的时候会导致大量的数据丢失，需要aof来配合</li>
<li>在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复</li>
<li>Redis会定期做aof重写，压缩aof文件日志大小</li>
<li>Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性</li>
<li>bgsave的原理，fork和cow, </li>
<li>fork是指redis通过创建子进程来进行bgsave操作</li>
<li>cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li>
</ul>
<h1 id="redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？"><a href="#redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？" class="headerlink" title="redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？"></a>redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？</h1><ul>
<li>过期策略:<ul>
<li>定时过期(一key一定时器)</li>
<li>惰性过期：只有使用key时才判断key是否已过期，过期则清除</li>
<li>定期过期：前两者折中。</li>
</ul>
</li>
<li>LRU:new LinkedHashMap&lt;K, V&gt;(capacity, DEFAULT_LOAD_FACTORY, true);&#x2F;&#x2F;第三个参数置为true，代表linkedlist按访问顺序排序，可作为LRU缓存；设为false代表按插入顺序排序，可作为FIFO缓存</li>
<li>LRU算法实现<ul>
<li>通过双向链表来实现，新数据插入到链表头部</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
</li>
<li>LinkedHashMap：HashMap和双向链表合二为一即是LinkedHashMap。HashMap是无序的，LinkedHashMap通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插入顺序（默认），也可以是访问顺序。</li>
</ul>
<h1 id="在选择缓存时，什么时候选择redis，什么时候选择memcached"><a href="#在选择缓存时，什么时候选择redis，什么时候选择memcached" class="headerlink" title="在选择缓存时，什么时候选择redis，什么时候选择memcached"></a>在选择缓存时，什么时候选择redis，什么时候选择memcached</h1><h4 id="选择redis的情况"><a href="#选择redis的情况" class="headerlink" title="选择redis的情况"></a>选择redis的情况</h4><ul>
<li>复杂数据结构，value的数据是哈希，列表，集合，有序集合等这种情况下，会选择redis, 因为memcache无法满足这些数据结构，最典型的的使用场景是，用户订单列表，用户消息，帖子评论等。</li>
<li>需要进行数据的持久化功能，但是注意，不要把redis当成数据库使用，如果redis挂了，内存能够快速恢复热数据，不会将压力瞬间压在数据库上，没有cache预热的过程。对于只读和数据一致性要求不高的场景可以采用持久化存储</li>
<li>高可用，redis支持集群，可以实现主动复制，读写分离，而对于memcache如果想要实现高可用，需要进行二次开发。</li>
<li>存储的内容比较大，memcache存储的value最大为1M。</li>
</ul>
<h4 id="选择memcache的场景"><a href="#选择memcache的场景" class="headerlink" title="选择memcache的场景"></a>选择memcache的场景</h4><ul>
<li>纯KV,数据量非常大的业务，使用memcache更合适，原因是，<ul>
<li>memcache的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时间，redis是临时申请空间，可能导致碎片化。</li>
<li>虚拟内存使用，memcache将所有的数据存储在物理内存里，redis有自己的vm机制，理论上能够存储比物理内存更多的数据，当数据超量时，引发swap,把冷数据刷新到磁盘上，从这点上，数据量大时，memcache更快</li>
<li>网络模型，memcache使用非阻塞的IO复用模型，redis也是使用非阻塞的IO复用模型，但是redis还提供了一些非KV存储之外的排序，聚合功能，复杂的CPU计算，会阻塞整个IO调度，从这点上由于redis提供的功能较多，memcache更快些</li>
<li>线程模型，memcache使用多线程，主线程监听，worker子线程接受请求，执行读写，这个过程可能存在锁冲突。redis使用的单线程，虽然无锁冲突，但是难以利用多核的特性提升吞吐量。</li>
</ul>
</li>
</ul>
<h1 id="Redis常见的性能问题和解决方案"><a href="#Redis常见的性能问题和解决方案" class="headerlink" title="Redis常见的性能问题和解决方案"></a>Redis常见的性能问题和解决方案</h1><ul>
<li>master最好不要做持久化工作，如RDB内存快照和AOF日志文件</li>
<li>如果数据比较重要，某个slave开启AOF备份，策略设置成每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，master和Slave最好在一个局域网内</li>
<li>尽量避免在压力大得主库上增加从库</li>
<li>主从复制不要采用网状结构，尽量是线性结构，<code>Master&lt;-- Slave1 &lt;--Slave2</code></li>
</ul>
<h1 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来</h1><ul>
<li>使用keys指令可以扫出指定模式的key列表。</li>
<li>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</li>
<li>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复</li>
<li>这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</li>
</ul>
<h1 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h1><ul>
<li>使用list类型保存数据信息</li>
<li>rpush生产消息</li>
<li>lpop消费消息</li>
<li>当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息</li>
<li>如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来</li>
<li>redis可以通过pub&#x2F;sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</li>
</ul>
<h1 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h1><ul>
<li>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><ul>
<li>通常会采取的一种方式是主从架构Master&#x2F;Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。</li>
<li>redis-server –port 6380 –slaveof <master-ip> <master-port>，配置当前服务为某Redis服务的Slave</li>
<li>SLAVEOF host port命令，将当前服务器状态从Master修改为别的服务器的Slave</li>
<li>redis&gt;SLAVEOF 192.169.0.110 6379，将服务器转换为Slave</li>
<li>redis&gt;SLAVEOF NO ONE 将服务器状态重新恢复到Master，不会丢弃已同步的数据</li>
<li>配置方式：启动时，服务器读取配置文件，并自动成为指定服务器的从服务器</li>
<li>slaveof <master-ip> <master-port></li>
<li>slaveof 127.0.0.1 6379</li>
</ul>
<h1 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h1><ul>
<li>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： <ul>
<li>从服务器连接主服务器，发送SYNC命令； </li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ul>
</li>
</ul>
<h1 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h1><ul>
<li>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </li>
<li>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</li>
</ul>
<p> </p>
<h1 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h1><ul>
<li>主从刚刚连接的时候，进行全量同步；</li>
<li>全同步结束后，进行增量同步</li>
<li>当然，如果有需要，slave 在任何时候都可以发起全量同步</li>
<li>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li>
<li>如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</li>
<li>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</li>
<li>不持久化的主服务器自动重启非常危险呢？</li>
</ul>
<h1 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h1><ul>
<li>反客为主的自动版，能够后台监控Master库是否故障，如果故障了根据投票数自动将slave库转换为主库</li>
<li>一组sentinel能同时监控多个Master。</li>
<li>使用步骤：<ul>
<li>在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；</li>
<li>配置哨兵，在sentinel.conf文件中填入内容：<ul>
<li>sentinel monitor 被监控数据库名字（自己起名字） ip port 1</li>
<li>说明：上面最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机。</li>
</ul>
</li>
<li>启动哨兵模式：<ul>
<li>命令键入：redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</li>
<li>注：上述sentinel.conf路径按各自实际情况配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h1><ul>
<li>延时，由于所有的写操作都是在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟</li>
<li>当系统很繁忙的时候，延迟问题会更加严重</li>
<li>Slave机器数量的增加也会使得这个问题更加严重。</li>
</ul>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><ul>
<li>redis cluster在设计的时候，就考虑到了去中心化，去中间件</li>
<li>也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态</li>
<li>每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li>
<li>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的</li>
<li>redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384</li>
<li>Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步</li>
<li>当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据</li>
<li>只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。</li>
<li>需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</li>
</ul>
<h1 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h1><ul>
<li>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存</li>
<li>因为纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。</li>
<li>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等</li>
<li>另外 Redis 也可以对存入的Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。</li>
<li>Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
</ul>
<h1 id="Redis-相比-memcached-有哪些优势？"><a href="#Redis-相比-memcached-有哪些优势？" class="headerlink" title="Redis 相比 memcached 有哪些优势？"></a>Redis 相比 memcached 有哪些优势？</h1><ul>
<li>memcached 所有的值均是简单的字符串，Redis 作为其替代者，支持更为丰富的数据类型</li>
<li>Redis 的速度比 memcached 快很多</li>
<li>Redis 可以持久化其数据</li>
</ul>
<h1 id="Redis-主要消耗什么物理资源？"><a href="#Redis-主要消耗什么物理资源？" class="headerlink" title="Redis 主要消耗什么物理资源？"></a>Redis 主要消耗什么物理资源？</h1><ul>
<li>内存。</li>
</ul>
<h1 id="Redis-的全称是什么？"><a href="#Redis-的全称是什么？" class="headerlink" title="Redis 的全称是什么？"></a>Redis 的全称是什么？</h1><ul>
<li>Remote Dictionary Server。</li>
</ul>
<h1 id="Redis-官方为什么不提供-Windows-版本？"><a href="#Redis-官方为什么不提供-Windows-版本？" class="headerlink" title="Redis 官方为什么不提供 Windows 版本？"></a>Redis 官方为什么不提供 Windows 版本？</h1><ul>
<li>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。</li>
</ul>
<h1 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h1><ul>
<li>512M</li>
</ul>
<h1 id="为什么-Redis-需要把所有数据放到内存中？"><a href="#为什么-Redis-需要把所有数据放到内存中？" class="headerlink" title="为什么 Redis 需要把所有数据放到内存中？"></a>为什么 Redis 需要把所有数据放到内存中？</h1><ul>
<li>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。</li>
<li>所以 Redis 具有快速和数据持久化的特征</li>
<li>如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重影响 Redis 的性能</li>
<li>在内存越来越便宜的今天，Redis 将会越来越受欢迎。</li>
<li>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</li>
</ul>
<h1 id="Redis-集群方案应该怎么做？都有哪些方案？"><a href="#Redis-集群方案应该怎么做？都有哪些方案？" class="headerlink" title="Redis 集群方案应该怎么做？都有哪些方案？"></a>Redis 集群方案应该怎么做？都有哪些方案？</h1><ul>
<li>twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 Redis 无任何区别，设置好它下属的多个 Redis 实例后，使用时在本需要连接 Redis 的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 Redis，将结果再返回 twemproxy。使用方式简便(相对 Redis 只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对Redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</li>
<li>codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点。</li>
<li>Redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</li>
<li>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 key 进行 hash 计算，然后去对应的 Redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</li>
</ul>
<h1 id="Redis-集群方案什么情况下会导致整个集群不可用？"><a href="#Redis-集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="Redis 集群方案什么情况下会导致整个集群不可用？"></a>Redis 集群方案什么情况下会导致整个集群不可用？</h1><ul>
<li>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</li>
</ul>
<h1 id="MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证-Redis-中的数据都是热点数据？"><a href="#MySQL-里有-2000w-数据，Redis-中只存-20w-的数据，如何保证-Redis-中的数据都是热点数据？" class="headerlink" title="MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？"></a>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</h1><ul>
<li>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</li>
</ul>
<h1 id="Redis-有哪些适合的场景？"><a href="#Redis-有哪些适合的场景？" class="headerlink" title="Redis 有哪些适合的场景？"></a>Redis 有哪些适合的场景？</h1><h4 id="会话缓存（Session-Cache）"><a href="#会话缓存（Session-Cache）" class="headerlink" title="会话缓存（Session Cache）"></a>会话缓存（Session Cache）</h4><ul>
<li>最常用的一种使用 Redis 的情景是会话缓存（session cache）</li>
<li>用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化</li>
<li>当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</li>
<li>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档</li>
<li>甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</li>
</ul>
<h4 id="全页缓存（FPC）"><a href="#全页缓存（FPC）" class="headerlink" title="全页缓存（FPC）"></a>全页缓存（FPC）</h4><ul>
<li>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台</li>
<li>回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。</li>
<li>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。</li>
<li>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-Redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作</li>
<li>这使得 Redis 能作为一个很好的消息队列平台来使用</li>
<li>Redis 作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push&#x2F;pop 操作。</li>
<li>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</li>
</ul>
<h4 id="排行榜-计数器"><a href="#排行榜-计数器" class="headerlink" title="排行榜&#x2F;计数器"></a>排行榜&#x2F;计数器</h4><ul>
<li>Redis在内存中对数字进行递增或递减的操作实现的非常好</li>
<li>集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构</li>
<li>所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</li>
<li>当然，这是假定你是根据你用户的分数做递增的排序</li>
<li>如果你想返回用户及用户的分数，你需要这样执行：ZRANGE user_scores 0 10 WITHSCORES</li>
<li>Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</li>
</ul>
<h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h4><ul>
<li>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能</li>
<li>发布&#x2F;订阅的使用场景确实非常多</li>
<li>我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用 Redis 的发布&#x2F;订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</li>
</ul>
<h1 id="Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？"><a href="#Redis-支持的-Java-客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？"></a>Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</h1><ul>
<li>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</li>
</ul>
<h1 id="Redis-和-Redisson-有什么关系？"><a href="#Redis-和-Redisson-有什么关系？" class="headerlink" title="Redis 和 Redisson 有什么关系？"></a>Redis 和 Redisson 有什么关系？</h1><ul>
<li>Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</li>
</ul>
<h1 id="Jedis-与-Redisson-对比有什么优缺点？"><a href="#Jedis-与-Redisson-对比有什么优缺点？" class="headerlink" title="Jedis 与 Redisson 对比有什么优缺点？"></a>Jedis 与 Redisson 对比有什么优缺点？</h1><ul>
<li>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；</li>
<li>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性</li>
<li>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li>
</ul>
<h1 id="Redis-如何设置密码及验证密码？"><a href="#Redis-如何设置密码及验证密码？" class="headerlink" title="Redis 如何设置密码及验证密码？"></a>Redis 如何设置密码及验证密码？</h1><ul>
<li>设置密码：config set requirepass 123456</li>
<li>授权密码：auth 123456</li>
</ul>
<h1 id="说说-Redis-哈希槽的概念？"><a href="#说说-Redis-哈希槽的概念？" class="headerlink" title="说说 Redis 哈希槽的概念？"></a>说说 Redis 哈希槽的概念？</h1><ul>
<li>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念</li>
<li>Redis 集群有 16384 个哈希槽，</li>
<li>每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分hash 槽。</li>
</ul>
<h1 id="Redis-集群的主从复制模型是怎样的？"><a href="#Redis-集群的主从复制模型是怎样的？" class="headerlink" title="Redis 集群的主从复制模型是怎样的？"></a>Redis 集群的主从复制模型是怎样的？</h1><ul>
<li>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品</li>
</ul>
<h1 id="Redis-集群会有写操作丢失吗？为什么？"><a href="#Redis-集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis 集群会有写操作丢失吗？为什么？"></a>Redis 集群会有写操作丢失吗？为什么？</h1><ul>
<li>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</li>
</ul>
<h1 id="Redis-集群之间是如何复制的？"><a href="#Redis-集群之间是如何复制的？" class="headerlink" title="Redis 集群之间是如何复制的？"></a>Redis 集群之间是如何复制的？</h1><ul>
<li>异步复制</li>
</ul>
<h1 id="Redis-集群最大节点个数是多少？"><a href="#Redis-集群最大节点个数是多少？" class="headerlink" title="Redis 集群最大节点个数是多少？"></a>Redis 集群最大节点个数是多少？</h1><ul>
<li>16384 个。</li>
</ul>
<h1 id="Redis-集群如何选择数据库？"><a href="#Redis-集群如何选择数据库？" class="headerlink" title="Redis 集群如何选择数据库？"></a>Redis 集群如何选择数据库？</h1><ul>
<li>Redis 集群目前无法做数据库选择，默认在 0 数据库。</li>
</ul>
<h1 id="怎么测试-Redis-的连通性？"><a href="#怎么测试-Redis-的连通性？" class="headerlink" title="怎么测试 Redis 的连通性？"></a>怎么测试 Redis 的连通性？</h1><ul>
<li>ping</li>
</ul>
<h1 id="Redis-中的管道有什么用？"><a href="#Redis-中的管道有什么用？" class="headerlink" title="Redis 中的管道有什么用？"></a>Redis 中的管道有什么用？</h1><ul>
<li>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应</li>
<li>这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复</li>
<li>这就是管道（pipelining），是一种几十年来广泛使用的技术</li>
<li>例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</li>
</ul>
<h1 id="怎么理解-Redis-事务？"><a href="#怎么理解-Redis-事务？" class="headerlink" title="怎么理解 Redis 事务？"></a>怎么理解 Redis 事务？</h1><ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行</li>
<li>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<h1 id="Redis-事务相关的命令有哪几个？"><a href="#Redis-事务相关的命令有哪几个？" class="headerlink" title="Redis 事务相关的命令有哪几个？"></a>Redis 事务相关的命令有哪几个？</h1><ul>
<li>MULTI、EXEC、DISCARD、WATCH</li>
</ul>
<h1 id="Redis-key-的过期时间和永久有效分别怎么设置？"><a href="#Redis-key-的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key 的过期时间和永久有效分别怎么设置？"></a>Redis key 的过期时间和永久有效分别怎么设置？</h1><ul>
<li>EXPIRE 和 PERSIST 命令。</li>
</ul>
<h1 id="Redis-如何做内存优化？"><a href="#Redis-如何做内存优化？" class="headerlink" title="Redis 如何做内存优化？"></a>Redis 如何做内存优化？</h1><ul>
<li>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小</li>
<li>所以你应该尽可能的将你的数据模型抽象到一个散列表里面</li>
<li>比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面</li>
</ul>
<h1 id="Redis-回收进程如何工作的？"><a href="#Redis-回收进程如何工作的？" class="headerlink" title="Redis 回收进程如何工作的？"></a>Redis 回收进程如何工作的？</h1><ul>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
<li>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</li>
</ul>
<h1 id="Redis-回收使用的是什么算法？"><a href="#Redis-回收使用的是什么算法？" class="headerlink" title="Redis 回收使用的是什么算法？"></a>Redis 回收使用的是什么算法？</h1><ul>
<li>LRU 算法</li>
</ul>
<h1 id="Redis-如何做大量数据插入？"><a href="#Redis-如何做大量数据插入？" class="headerlink" title="Redis 如何做大量数据插入？"></a>Redis 如何做大量数据插入？</h1><ul>
<li>Redis2.6 开始 Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</li>
</ul>
<h1 id="为什么要做-Redis-分区？"><a href="#为什么要做-Redis-分区？" class="headerlink" title="为什么要做 Redis 分区？"></a>为什么要做 Redis 分区？</h1><ul>
<li>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存</li>
<li>如果没有分区，你最多只能使用一台机器的内存</li>
<li>分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升</li>
<li>Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。</li>
</ul>
<h1 id="你知道有哪些-Redis-分区实现方案？"><a href="#你知道有哪些-Redis-分区实现方案？" class="headerlink" title="你知道有哪些 Redis 分区实现方案？"></a>你知道有哪些 Redis 分区实现方案？</h1><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取</li>
<li>大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。</li>
<li>代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。</li>
<li>Redis 和 memcached 的一种代理实现就是 Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个 Redis 实例，然后由 Redis将请求转发给正确的 Redis 节点</li>
<li>Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接redirected 到正确的 Redis 节点。</li>
</ul>
<h1 id="Redis-分区有什么缺点？"><a href="#Redis-分区有什么缺点？" class="headerlink" title="Redis 分区有什么缺点？"></a>Redis 分区有什么缺点？</h1><ul>
<li>涉及多个 key 的操作通常不会被支持</li>
<li>例如你不能对两个集合求交集，因为他们可能被存储到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个 key,则不能使用 Redis 事务</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning<br>granularity is the key, so it is not possible to shard a dataset with a single huge<br>key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主机同时收集 RDB &#x2F; AOF 文件。</li>
<li>分区时动态扩容或缩容可能非常复杂</li>
<li>Redis 集群在运行时增加或者删除 Redis 节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性</li>
<li>然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h1 id="Redis-持久化数据和缓存怎么做扩容？"><a href="#Redis-持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis 持久化数据和缓存怎么做扩容？"></a>Redis 持久化数据和缓存怎么做扩容？</h1><ul>
<li>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</li>
</ul>
<h1 id="分布式-Redis-是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式-Redis-是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式 Redis 是前期做还是后期规模上来了再做好？为什么？"></a>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？</h1><ul>
<li>既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。- 即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</li>
<li>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</li>
<li>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）</li>
<li>一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</li>
</ul>
<h1 id="Twemproxy-是什么？"><a href="#Twemproxy-是什么？" class="headerlink" title="Twemproxy 是什么？"></a>Twemproxy 是什么？</h1><ul>
<li>Twemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis协议</li>
<li>它是单线程程序，使用 c 语言编写，运行起来非常快</li>
<li>它是采用 Apache 2.0 license的开源软件。</li>
<li>Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存时使用 Twemproxy)。</li>
<li>Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实例，然后让你的客户端去连接任意一个 Twemproxy 实例。</li>
<li>Twemproxy 是 Redis 客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</li>
</ul>
<h1 id="支持一致性哈希的客户端有哪些？"><a href="#支持一致性哈希的客户端有哪些？" class="headerlink" title="支持一致性哈希的客户端有哪些？"></a>支持一致性哈希的客户端有哪些？</h1><ul>
<li>Redis-rb、PRedis 等。</li>
</ul>
<h1 id="Redis-与其他-key-value-存储有什么不同？"><a href="#Redis-与其他-key-value-存储有什么不同？" class="headerlink" title="Redis 与其他 key-value 存储有什么不同？"></a>Redis 与其他 key-value 存储有什么不同？</h1><ul>
<li>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径</li>
<li>Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>
<li>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存</li>
<li>在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情</li>
<li>同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</li>
</ul>
<h1 id="Redis-的内存占用情况怎么样？"><a href="#Redis-的内存占用情况怎么样？" class="headerlink" title="Redis 的内存占用情况怎么样？"></a>Redis 的内存占用情况怎么样？</h1><ul>
<li>给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的32 位的 Mac 笔记本上 用了 100MB</li>
<li>同样的数据放到一个 key 里只需要 16MB， 这是因为键值有一个很大的开销</li>
<li>在 Memcached 上执行也是类似的结果，但是相对 Redis的开销要小一点点，因为 Redis 会记录类型信息引用计数等等。</li>
<li>当然，大键值对时两者的比例要好很多。</li>
<li>64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系统里指针占用了 8 个字节</li>
<li>但是，当然，64 位系统支持更大的内存，所以为了运行大型的 Redis 服务器或多或少的需要使用 64 位的系统。</li>
</ul>
<h1 id="都有哪些办法可以降低-Redis-的内存使用情况呢？"><a href="#都有哪些办法可以降低-Redis-的内存使用情况呢？" class="headerlink" title="都有哪些办法可以降低 Redis 的内存使用情况呢？"></a>都有哪些办法可以降低 Redis 的内存使用情况呢？</h1><ul>
<li>如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，</li>
<li>因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</li>
</ul>
<h1 id="查看-Redis-使用情况及状态信息用什么命令？"><a href="#查看-Redis-使用情况及状态信息用什么命令？" class="headerlink" title="查看 Redis 使用情况及状态信息用什么命令？"></a>查看 Redis 使用情况及状态信息用什么命令？</h1><ul>
<li>info</li>
</ul>
<h1 id="Redis-的内存用完了会发生什么？"><a href="#Redis-的内存用完了会发生什么？" class="headerlink" title="Redis 的内存用完了会发生什么？"></a>Redis 的内存用完了会发生什么？</h1><ul>
<li>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）</li>
<li>或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</li>
</ul>
<h1 id="Redis-是单线程的，如何提高多核-CPU-的利用率？"><a href="#Redis-是单线程的，如何提高多核-CPU-的利用率？" class="headerlink" title="Redis 是单线程的，如何提高多核 CPU 的利用率？"></a>Redis 是单线程的，如何提高多核 CPU 的利用率？</h1><ul>
<li>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，</li>
<li>所以，如果你想使用多个 CPU，你可以考虑一下分片（shard）。</li>
</ul>
<h1 id="一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set-他们最多能存放多少元素？"><a href="#一个-Redis-实例最多能存放多少的-keys？List、Set、Sorted-Set-他们最多能存放多少元素？" class="headerlink" title="一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？"></a>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</h1><ul>
<li>理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2亿 5 千万的 keys</li>
<li>任何 list、set、和 sorted set 都可以放 232 个元素。</li>
<li>换句话说，Redis 的存储极限是系统中的可用内存值。</li>
</ul>
<h1 id="Redis-常见性能问题和解决方案？"><a href="#Redis-常见性能问题和解决方案？" class="headerlink" title="Redis 常见性能问题和解决方案？"></a>Redis 常见性能问题和解决方案？</h1><ul>
<li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</li>
<li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内</li>
<li>尽量避免在压力很大的主库上增加从库</li>
<li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2<br>&lt;- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可<br>以立刻启用 Slave1 做 Master，其他不变。</li>
</ul>
<h1 id="如何选择合适的持久化方式？"><a href="#如何选择合适的持久化方式？" class="headerlink" title="如何选择合适的持久化方式？"></a>如何选择合适的持久化方式？</h1><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</li>
<li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</li>
</ul>
<h1 id="修改配置不重启-Redis-会实时生效吗？"><a href="#修改配置不重启-Redis-会实时生效吗？" class="headerlink" title="修改配置不重启 Redis 会实时生效吗？"></a>修改配置不重启 Redis 会实时生效吗？</h1><ul>
<li>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启</li>
<li>从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis</li>
<li>检索 ‘CONFIG GET *’ 命令获取更多信息。</li>
<li>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前CONFIG 命令还不支持的配置参数的时候。</li>
</ul>
<h1 id="使用过-Redis-做异步队列么，你是怎么用的？"><a href="#使用过-Redis-做异步队列么，你是怎么用的？" class="headerlink" title="使用过 Redis 做异步队列么，你是怎么用的？"></a>使用过 Redis 做异步队列么，你是怎么用的？</h1><ul>
<li>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</li>
<li>如果对方追问可不可以不用 sleep 呢？</li>
<li>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用 pub&#x2F;sub 主题订阅者模式，可以实现1:N 的消息队列。</li>
<li>如果对方追问 pub&#x2F;sub 有什么缺点？</li>
<li>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</li>
<li>如果对方追问 redis 如何实现延时队列？</li>
<li>我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</li>
</ul>
<h1 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h1><ul>
<li>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</li>
</ul>
<h1 id="Redis-最适合的场景？"><a href="#Redis-最适合的场景？" class="headerlink" title="Redis 最适合的场景？"></a>Redis 最适合的场景？</h1><h4 id="会话缓存（Session-Cache）-1"><a href="#会话缓存（Session-Cache）-1" class="headerlink" title="会话缓存（Session Cache）"></a>会话缓存（Session Cache）</h4><ul>
<li>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。</li>
</ul>
<h4 id="全页缓存（FPC）-1"><a href="#全页缓存（FPC）-1" class="headerlink" title="全页缓存（FPC）"></a>全页缓存（FPC）</h4><ul>
<li>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento提供一个插件来使用 Redis 作为全页缓存后端。 此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li>
</ul>
<h4 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h4><ul>
<li>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push&#x2F;pop 操作。 如果你快速的在 Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</li>
</ul>
<h4 id="排行榜-计数器-1"><a href="#排行榜-计数器-1" class="headerlink" title="排行榜&#x2F;计数器"></a>排行榜&#x2F;计数器</h4><ul>
<li>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</li>
</ul>
<h4 id="发布-订阅-1"><a href="#发布-订阅-1" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h4><ul>
<li>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用 Redis 的发布&#x2F;订阅功能来建立聊天系统！</li>
</ul>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot</title>
    <url>/publishes/4d12791836df.html</url>
    <content><![CDATA[<h1 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h1><ul>
<li>多年来，随着新功能的增加，spring变得越来越复杂。</li>
<li>如果必须启动一个新的Spring项目，我们必须添加构建路径或添加Maven依赖关系，配置应用程序服务器，添加spring配置。</li>
<li>因此，开始一个新的spring项目需要很多努力，因为我们现在必须从头开始做所有事情。</li>
<li>Spring Boot是解决这个问题的方法。Spring Boot已经建立在现有spring框架之上。使用spring启动，我们避免了之前我们必须做的所有样板代码和配置。</li>
<li>因此，Spring Boot可以帮助我们以最少的工作量，更加健壮地使用现有的Spring功能。</li>
</ul>
<h1 id="Spring-Boot有哪些优点"><a href="#Spring-Boot有哪些优点" class="headerlink" title="Spring Boot有哪些优点"></a>Spring Boot有哪些优点</h1><ul>
<li>减少开发，测试时间和努力。</li>
<li>使用JavaConfig有助于避免使用XML。</li>
<li>避免大量的Maven导入和各种版本冲突。</li>
<li>提供意见发展方法。</li>
<li>通过提供默认值快速开始开发。</li>
<li>没有单独的Web服务器需要。这意味着你不再需要启动Tomcat，Glassfish或其他任何东西。</li>
<li>需要更少的配置 因为没有web.xml文件。只需添加用@ Configuration注释的类，然后添加用@Bean注释的方法，Spring将自动加载对象并像以前一样对其进行管理。您甚至可以将@Autowired添加到bean方法中，以使Spring自动装入需要的依赖关系中。</li>
<li>基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active &#x3D; {enviornment}。在加载主应用程序属性文件后，Spring将在（application{environment} .properties）中加载后续的应用程序属性文件。</li>
</ul>
<h1 id="什么是JavaConfig"><a href="#什么是JavaConfig" class="headerlink" title="什么是JavaConfig"></a>什么是JavaConfig</h1><ul>
<li>Spring JavaConfig提供了配置Spring IoC容器的纯Java方法</li>
<li>因此它有助于避免使用XML配置</li>
<li>使用JavaConfig的优点在于：<ul>
<li>面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。</li>
<li>减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。</li>
</ul>
</li>
<li>JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。</li>
<li>从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。</li>
<li>类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。</li>
</ul>
<h1 id="如何重新加载Spring-Boot上的更改，而无需重新启动服务器？"><a href="#如何重新加载Spring-Boot上的更改，而无需重新启动服务器？" class="headerlink" title="如何重新加载Spring Boot上的更改，而无需重新启动服务器？"></a>如何重新加载Spring Boot上的更改，而无需重新启动服务器？</h1><ul>
<li>这可以使用DEV工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat将重新启动。</li>
<li>Spring Boot有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力</li>
<li>Java开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。</li>
<li>开发人员可以重新加载Spring Boot上的更改，而无需重新启动服务器</li>
<li>这将消除每次手动部署更改的需要</li>
<li>Spring Boot在发布它的第一个版本时没有这个功能。</li>
<li>这是开发人员最需要的功能</li>
<li>DevTools模块完全满足开发人员的需求</li>
<li>该模块将在生产环境中被禁用</li>
<li>它还提供H2数据库控制台以更好地测试应用程序。</li>
</ul>
<h1 id="Spring-Boot中的监视器是什么？"><a href="#Spring-Boot中的监视器是什么？" class="headerlink" title="Spring Boot中的监视器是什么？"></a>Spring Boot中的监视器是什么？</h1><ul>
<li>Spring boot actuator是spring启动框架中的重要功能之一</li>
<li>Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。</li>
<li>有几个指标必须在生产环境中进行检查和监控</li>
<li>即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息</li>
<li>监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</li>
</ul>
<h1 id="如何在Spring-Boot中禁用Actuator端点安全性？"><a href="#如何在Spring-Boot中禁用Actuator端点安全性？" class="headerlink" title="如何在Spring Boot中禁用Actuator端点安全性？"></a>如何在Spring Boot中禁用Actuator端点安全性？</h1><ul>
<li>默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。</li>
<li>安全性是使用标准的HttpServletRequest.isUserInRole方法实施的</li>
<li>我们可以使用management.security.enabled &#x3D; false 来禁用安全性</li>
<li>只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</li>
</ul>
<h1 id="如何在自定义端口上运行Spring-Boot应用程序？"><a href="#如何在自定义端口上运行Spring-Boot应用程序？" class="headerlink" title="如何在自定义端口上运行Spring Boot应用程序？"></a>如何在自定义端口上运行Spring Boot应用程序？</h1><ul>
<li>为了在自定义端口上运行Spring Boot应用程序，您可以在application.properties中指定端口。</li>
<li>server.port &#x3D; 8090</li>
</ul>
<h1 id="什么是YAML？"><a href="#什么是YAML？" class="headerlink" title="什么是YAML？"></a>什么是YAML？</h1><ul>
<li>YAML是一种人类可读的数据序列化语言</li>
<li>它通常用于配置文件。</li>
<li>与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML文件就更加结构化，而且更少混淆</li>
<li>可以看出YAML具有分层配置数据。</li>
</ul>
<h1 id="如何实现Spring-Boot应用程序的安全性？"><a href="#如何实现Spring-Boot应用程序的安全性？" class="headerlink" title="如何实现Spring Boot应用程序的安全性？"></a>如何实现Spring Boot应用程序的安全性？</h1><ul>
<li>为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置</li>
<li>它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。</li>
</ul>
<h1 id="如何集成Spring-Boot和ActiveMQ？"><a href="#如何集成Spring-Boot和ActiveMQ？" class="headerlink" title="如何集成Spring Boot和ActiveMQ？"></a>如何集成Spring Boot和ActiveMQ？</h1><ul>
<li>对于集成Spring Boot和ActiveMQ，我们使用spring-boot-starter-activemq依赖关系</li>
<li>它只需要很少的配置，并且不需要样板代码</li>
</ul>
<h1 id="如何使用Spring-Boot实现分页和排序？"><a href="#如何使用Spring-Boot实现分页和排序？" class="headerlink" title="如何使用Spring Boot实现分页和排序？"></a>如何使用Spring Boot实现分页和排序？</h1><ul>
<li>使用Spring Boot实现分页非常简单</li>
<li>使用Spring Data-JPA可以实现将可分页的org.springframework.data.domain.Pageable传递给存储库方法</li>
</ul>
<h1 id="什么是Swagger？你用Spring-Boot实现了它吗？"><a href="#什么是Swagger？你用Spring-Boot实现了它吗？" class="headerlink" title="什么是Swagger？你用Spring Boot实现了它吗？"></a>什么是Swagger？你用Spring Boot实现了它吗？</h1><ul>
<li>Swagger广泛用于可视化API</li>
<li>使用Swagger UI为前端开发人员提供在线沙箱</li>
<li>Swagger是用于生成RESTful Web服务的可视化表示的工具，规范和完整框架实现</li>
<li>它使文档能够以与服务器相同的速度更新</li>
<li>当通过Swagger正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互</li>
<li>因此，Swagger消除了调用服务时的猜测。</li>
</ul>
<h1 id="什么是Spring-Profiles？"><a href="#什么是Spring-Profiles？" class="headerlink" title="什么是Spring Profiles？"></a>什么是Spring Profiles？</h1><ul>
<li>Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean</li>
<li>因此，当应用程序在开发中运行时，只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载</li>
<li>假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档</li>
<li>这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单。</li>
</ul>
<h1 id="什么是Spring-Batch？"><a href="#什么是Spring-Batch？" class="headerlink" title="什么是Spring Batch？"></a>什么是Spring Batch？</h1><ul>
<li>Spring Boot Batch提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理</li>
<li>它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业</li>
<li>简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息</li>
</ul>
<h1 id="什么是FreeMarker模板？"><a href="#什么是FreeMarker模板？" class="headerlink" title="什么是FreeMarker模板？"></a>什么是FreeMarker模板？</h1><ul>
<li>FreeMarker是一个基于Java的模板引擎，最初专注于使用MVC软件架构进行动态网页生成</li>
<li>使用Freemarker的主要优点是表示层和业务层的完全分离</li>
<li>程序员可以处理应用程序代码，而设计人员可以处理html页面设计</li>
<li>最后使用freemarker可以将这些结合起来，给出最终的输出页面。</li>
</ul>
<h1 id="如何使用Spring-Boot实现异常处理？"><a href="#如何使用Spring-Boot实现异常处理？" class="headerlink" title="如何使用Spring Boot实现异常处理？"></a>如何使用Spring Boot实现异常处理？</h1><ul>
<li>Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法</li>
<li>我们通过实现一个ControlerAdvice类，来处理控制器类抛出的所有异常。</li>
</ul>
<h1 id="您使用了哪些starter-maven依赖项？"><a href="#您使用了哪些starter-maven依赖项？" class="headerlink" title="您使用了哪些starter maven依赖项？"></a>您使用了哪些starter maven依赖项？</h1><ul>
<li>使用了下面的一些依赖项<ul>
<li>spring-boot-starter-activemq</li>
<li>spring-boot-starter-security</li>
<li>spring-boot-starter-web</li>
</ul>
</li>
<li>这有助于增加更少的依赖关系，并减少版本的冲突。</li>
</ul>
<h1 id="如何监视所有Spring-Boot微服务"><a href="#如何监视所有Spring-Boot微服务" class="headerlink" title="如何监视所有Spring Boot微服务"></a>如何监视所有Spring Boot微服务</h1><ul>
<li>Spring Boot提供监视器端点以监控各个微服务的度量</li>
<li>这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助</li>
<li>但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况</li>
<li>想象一下涉及50个应用程序的微服务，管理员将不得不击中所有50个应用程序的执行终端。</li>
</ul>
<h1 id="SpringBoot项⽬启动时执⾏特定的⽅法"><a href="#SpringBoot项⽬启动时执⾏特定的⽅法" class="headerlink" title="SpringBoot项⽬启动时执⾏特定的⽅法"></a>SpringBoot项⽬启动时执⾏特定的⽅法</h1><ul>
<li>我们可以通过实现ApplicationRunner和CommandLineRunner，来实现，他们都是在SpringApplication 执⾏之后开始执⾏的</li>
</ul>
<h1 id="SpringBoot的启动过程"><a href="#SpringBoot的启动过程" class="headerlink" title="SpringBoot的启动过程"></a>SpringBoot的启动过程</h1><ul>
<li>通过 SpringFactoriesLoader加载 META-INF&#x2F;spring.factories⽂件，获取并创建 SpringApplicationRunListener对象</li>
<li>然后由 SpringApplicationRunListener来发出 starting 消息</li>
<li>创建参数，并配置当前 SpringBoot 应⽤将要使⽤的 Environment</li>
<li>完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息</li>
<li>创建 ApplicationContext</li>
<li>初始化 ApplicationContext，并设置 Environment，加载相关配置等</li>
<li>由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应⽤使⽤的 ApplicationContext已准备OK</li>
<li>将各种 beans 装载⼊ ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知SpringBoot 应⽤使⽤的 ApplicationContext已装填OK</li>
<li>refresh ApplicationContext，完成IoC容器可⽤的最后⼀步</li>
<li>由 SpringApplicationRunListener来发出 started 消息</li>
<li>完成最终的程序的启动</li>
<li>由 SpringApplicationRunListener来发出 running 消息，告知程序已运⾏起来了</li>
</ul>
<h1 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h1><ul>
<li>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。</li>
<li>为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</li>
</ul>
<h1 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h1><ul>
<li>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法</li>
<li>我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常</li>
</ul>
<h1 id="spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="spring boot 配置文件有哪几种类型？它们有什么区别？"></a>spring boot 配置文件有哪几种类型？它们有什么区别？</h1><ul>
<li>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</li>
<li>. yml 格式不支持 @PropertySource 注解导入。</li>
</ul>
<h1 id="spring-boot-核心配置文件是什么？"><a href="#spring-boot-核心配置文件是什么？" class="headerlink" title="spring boot 核心配置文件是什么？"></a>spring boot 核心配置文件是什么？</h1><ul>
<li>spring boot 核心的两个配置文件：<ul>
<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li>
<li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring cloud</title>
    <url>/publishes/4a23c7da79c0.html</url>
    <content><![CDATA[<h1 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h1><ul>
<li>Spring Cloud 是一个基于 Spring Boot 的开发工具集</li>
<li>专为构建微服务架构而设计</li>
<li>它提供了一系列的工具和框架，使开发、部署和维护微服务变得更加简单和高效</li>
</ul>
<h1 id="Spring-Cloud-的一些核心概念"><a href="#Spring-Cloud-的一些核心概念" class="headerlink" title="Spring Cloud 的一些核心概念"></a>Spring Cloud 的一些核心概念</h1><ul>
<li>配置管理: Spring Cloud 提供工具来统一管理和维护在多个环境中的微服务配置，如开发、测试和生产环境。</li>
<li>服务发现: 它集成了服务发现服务器，如 Eureka，使得微服务可以自动注册自己并发现其他服务。</li>
<li>负载均衡: 通过集成 Ribbon 和其他工具，Spring Cloud 提供客户端侧的负载均衡，帮助分发请求到不同的实例。</li>
<li>断路器: 通过 Hystrix，Spring Cloud 提供了断路器模式，以确保在某个服务出现问题时，不会导致整个系统的崩溃。</li>
<li>API 网关: 通过 Zuul，Spring Cloud 提供了API网关解决方案，用于请求路由、过滤和负载均衡。</li>
<li>分布式跟踪: Spring Cloud 集成了 Zipkin 和 Sleuth，为微服务架构提供分布式日志追踪。</li>
<li>分布式数据管理: 提供了工具来处理在微服务架构中的数据一致性和分布式事务问题。</li>
<li>集成和适配: Spring Cloud 与许多常见的云平台和服务深度集成，例如 AWS、GCP 和 Azure，使得部署和管理微服务更加简单。</li>
</ul>
<h1 id="使用Spring-Cloud有什么优势"><a href="#使用Spring-Cloud有什么优势" class="headerlink" title="使用Spring Cloud有什么优势"></a>使用Spring Cloud有什么优势</h1><ul>
<li>耦合度比较低。不会影响其他模块的开发</li>
<li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</li>
<li>配置比较简单，基本用注解就能实现，不用使用过多的配置文件</li>
<li>微服务跨平台的，可以用任何一种语言开发</li>
<li>每个微服务可以有自己的独立的数据库也有用公共的数据库</li>
<li>直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</li>
</ul>
<h1 id="服务注册和发现是什么意思？Spring-Cloud如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud如何实现？"></a>服务注册和发现是什么意思？Spring Cloud如何实现？</h1><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><ul>
<li>服务注册：将服务实例的信息注册到服务注册中心</li>
<li>在微服务架构中，每个服务都是独立运行的，需要通过服务注册中心来管理和调用</li>
<li>服务注册中心是一个集中的服务实例的注册和发现的地方</li>
<li>当一个服务实例启动时，它会向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号等</li>
<li>其他服务可以通过服务注册中心查询到需要调用的服务的信息，从而实现服务之间的通信</li>
<li>Spring Cloud提供了多个服务注册中心的实现，如Eureka、Consul和Zookeeper，其中，Eureka是Spring Cloud的默认选择</li>
<li>每个服务实例在启动时，会向Eureka服务器注册自己的信息</li>
<li>Eureka服务器会维护一个服务注册表，用于保存所有已注册的服务实例信息</li>
<li>其他服务可以通过查询服务注册表来获取需要调用的服务的相关信息</li>
<li>服务注册的优势在于解耦了服务之间的直接依赖关系，使得服务之间可以动态地发现和调用</li>
<li>通过服务注册，可以实现服务的高可用性和负载均衡，当某个服务实例不可用时，可以自动剔除或替换，从而保证整个系统的稳定性和可靠性</li>
<li>同时，服务注册还能提供服务的版本管理、动态扩缩容等功能，为微服务架构带来更大的灵活性和可扩展性</li>
</ul>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul>
<li>服务发现是指在微服务架构中，通过服务注册中心来查询和发现可用的服务实例</li>
<li>在传统的单体应用中，服务的调用通常是通过硬编码的方式实现的，而在微服务架构中，由于服务实例的数量和位置可能会动态变化，因此需要一种机制来动态地发现和调用服务</li>
<li>Spring Cloud提供了多个服务发现的实现，例如Eureka、Consul和Zookeeper</li>
<li>服务发现的基本流程如下<ul>
<li>服务注册：当一个服务实例启动时，它会向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号等。注册后，服务注册中心会维护一个服务注册表，记录所有已注册的服务实例</li>
<li>服务查询：当需要调用某个服务时，服务消费者可以通过服务注册中心查询到该服务的可用实例信息。服务消费者可以根据需要的负载均衡策略，选择一个合适的服务实例进行调用。</li>
<li>服务调用：服务消费者通过获取到的服务实例信息，可以直接向服务提供者发送请求，进行服务调用。服务消费者可以通过负载均衡、容错机制等手段，提高系统的可用性和稳定性。</li>
</ul>
</li>
</ul>
<h1 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h1><ul>
<li>负载平衡的作用<ul>
<li>提高系统性能：通过将请求分发到多个服务器上，负载平衡可以避免单一服务器的过载情况，从而提高系统的整体吞吐量和响应速度。</li>
<li>增加系统可靠性：当某个服务器发生故障或不可用时，负载平衡可以将请求转发到其他正常工作的服务器上，确保系统的可用性和稳定性。</li>
<li>实现扩展性：负载平衡可以根据实际需求，添加或移除服务器，以适应流量的增加或减少，从而实现系统的弹性扩展。</li>
<li>实现会话保持：负载平衡可以确保同一个用户的连续请求都被转发到同一个服务器上，以保持用户会话的状态。</li>
</ul>
</li>
<li>常见的负载平衡算法有轮询、随机、最少连接等<ul>
<li>轮询算法是将请求按照顺序依次分发到每个服务器上</li>
<li>随机算法是随机选择一个服务器来处理请求</li>
<li>最少连接算法是将请求分发到当前连接数最少的服务器上</li>
</ul>
</li>
<li>负载平衡可以通过硬件设备（如负载均衡器）或软件方式实现，常用的软件负载均衡工具有Nginx、HAProxy、SpringCloud的Ribbon等。这些工具可以根据实际需求和场景选择，以提供高效的负载平衡服务。</li>
</ul>
<h1 id="什么是Hystrix？它如何实现容错？"><a href="#什么是Hystrix？它如何实现容错？" class="headerlink" title="什么是Hystrix？它如何实现容错？"></a>什么是Hystrix？它如何实现容错？</h1><ul>
<li>hystrix是Netlifx开源的一款容错框架，防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控(Hystrix Dashboard)等功能</li>
</ul>
<h4 id="hystrix被设计的目标"><a href="#hystrix被设计的目标" class="headerlink" title="hystrix被设计的目标"></a>hystrix被设计的目标</h4><ul>
<li>对通过第三方客户端库访问的依赖项（通常是通过网络）的延迟和故障进行保护和控制。</li>
<li>在复杂的分布式系统汇中阻止级联故障。</li>
<li>快速失败，快速恢复。</li>
<li>回退，尽可能优雅的降级。</li>
<li>启用近实时监控、警报和操作控制。</li>
</ul>
<h4 id="Hystrix使用场景"><a href="#Hystrix使用场景" class="headerlink" title="Hystrix使用场景"></a>Hystrix使用场景</h4><ul>
<li>调用超时时间比你自己定义的阈值要长。</li>
<li>线程池满了，该以来应该立即拒绝请求，而不是排队</li>
<li>在一段时间内，如果服务的错误百分比超过了一个阈值，就会触发一个断路器来停止对特定服务的所有请求，无论是手动还是自动的</li>
</ul>
<h4 id="Hystrix如何解决依赖隔离"><a href="#Hystrix如何解决依赖隔离" class="headerlink" title="Hystrix如何解决依赖隔离"></a>Hystrix如何解决依赖隔离</h4><ul>
<li>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中&#x2F;信号授权下执行。</li>
<li>可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</li>
<li>为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</li>
<li>依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</li>
<li>提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</li>
<li>提供近实时依赖的统计和监控</li>
</ul>
<h1 id="什么是Netflix-Feign？它的优点是什么？"><a href="#什么是Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是Netflix Feign？它的优点是什么？"></a>什么是Netflix Feign？它的优点是什么？</h1><h4 id="Feign是什么"><a href="#Feign是什么" class="headerlink" title="Feign是什么"></a>Feign是什么</h4><ul>
<li>Feign 是 Spring Cloud Netflix 组件中的一个轻量级 RESTful 的 HTTP 服务客户端</li>
<li>实现了负载均衡和 Rest 调用的开源框架</li>
<li>封装了 Ribbon 和 RestTemplate</li>
<li>实现了 WebService的面向接口编程，进一步降低了项目的耦合度</li>
<li>Feign 内置了 Ribbon，用来做客户端负载均衡调用服务注册中心的服务</li>
<li>Feign 本身并不支持 Spring MVC 的注解，它有一套自己的注解，为了更方便的使用，Spring Cloud 孵化了 OpenFeign</li>
<li>Feign 是一种声明式、模板化的 HTTP 客户端（仅在 Consumer 中使用）</li>
<li>Feign 的使用方式是：使用 Feign 的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。</li>
</ul>
<h4 id="Feign解决了什么问题"><a href="#Feign解决了什么问题" class="headerlink" title="Feign解决了什么问题"></a>Feign解决了什么问题</h4><ul>
<li>Feign 旨在使编写 JAVA HTTP 客户端变得更加容易</li>
<li>Feign 简化了 RestTemplate 代码，实现了 Ribbon负载均衡，使代码变得更加简洁，也少了客户端调用的代码，使用 Feign 实现负载均衡是首选方案</li>
<li>只需要你创建一个接口，然后在上面添加注解即可</li>
<li>Feign 是声明式服务调用组件，其核心就是：像调用本地方法一样调用远程方法，无感知远程 HTTP 请求</li>
<li>它解决了让开发者调用远程接口就跟调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP请求</li>
<li>无需关注与远程的交互细节，更无需关注分布式环境开发</li>
<li>它像 Dubbo 一样，Consumer 直接调用 Provider 接口方法，而不需要通过常规的 Http Client 构造请求再解析返回数据</li>
</ul>
<h1 id="什么是Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是Spring Cloud Bus？我们需要它吗？"></a>什么是Spring Cloud Bus？我们需要它吗？</h1><h4 id="什么是Spring-Cloud-Bus"><a href="#什么是Spring-Cloud-Bus" class="headerlink" title="什么是Spring Cloud Bus"></a>什么是Spring Cloud Bus</h4><ul>
<li>Spring Cloud Bus是Spring Cloud提供的一种用于实现分布式系统中消息传递和事件驱动的组件</li>
<li>Spring Cloud Bus是基于消息代理的分布式系统消息总线</li>
<li>它利用轻量级消息代理来连接各个分布式节点，实现节点之间的消息传递和事件驱动</li>
<li>Spring Cloud Bus的核心思想是通过消息广播机制，使得一次配置更新可以触发所有相关节点的配置刷新，从而实现分布式系统的配置管理和动态更新</li>
<li>通过消息广播机制和消息代理，它可以实现配置的动态刷新、事件的传递和驱动，以及系统的监控与管理</li>
</ul>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>引入依赖：在项目的pom.xml文件中添加Spring Cloud Bus相关的依赖<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>配置消息代理：在Spring Cloud配置文件中配置消息代理的地址和相关参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure></li>
<li>注册消息总线端点：在Spring Boot应用程序中注册消息总线的端点<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@RestController</span><br><span class="line">public class MyApp &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RefreshEndpoint refreshEndpoint;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/refresh&quot;)</span><br><span class="line">    public void refresh() &#123;</span><br><span class="line">        refreshEndpoint.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>刷新配置：通过发送POST请求到消息总线端点来触发配置的刷新<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">restTemplate.postForObject(&quot;http://localhost:8080/refresh&quot;, null, Void.class);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Spring-Cloud-Bus的核心组件"><a href="#Spring-Cloud-Bus的核心组件" class="headerlink" title="Spring Cloud Bus的核心组件"></a>Spring Cloud Bus的核心组件</h4><ul>
<li>消息代理：用于转发消息和事件的中间件，如RabbitMQ、Kafka等。</li>
<li>消息总线：通过消息代理将消息广播给所有相关节点。</li>
<li>消息生成器：用于生成和发送消息的组件。</li>
<li>消息接收器：用于接收和处理消息的组件。</li>
</ul>
<h4 id="Spring-Cloud-Bus的作用"><a href="#Spring-Cloud-Bus的作用" class="headerlink" title="Spring Cloud Bus的作用"></a>Spring Cloud Bus的作用</h4><ul>
<li>配置刷新：通过消息广播机制，实现配置的动态刷新，避免了每个节点都需要手动刷新配置的问题</li>
<li>事件驱动：通过消息代理的发布-订阅模式，实现事件的传递和驱动，使得各个节点能够响应和处理特定的事件</li>
<li>监控与管理：可以通过消息总线来收集系统的监控数据和指标，实现分布式系统的集中管理和监控</li>
</ul>
<h1 id="Spring-Cloud-19个技术"><a href="#Spring-Cloud-19个技术" class="headerlink" title="Spring Cloud 19个技术"></a>Spring Cloud 19个技术</h1><ul>
<li>Spring Cloud Config 配置中心，利用git集中管理程序的配置。</li>
<li>Spring Cloud Netflix 集成众多Netflix的开源软件</li>
<li>Spring Cloud Bus 消息总线，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化</li>
<li>Spring Cloud for Cloud Foundry 利用Pivotal Cloudfoundry集成你的应用程序</li>
<li>Spring Cloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。</li>
<li>Spring Cloud Cluster 基于Zookeeper, Redis, Hazelcast, Consul实现的领导选举和平民状态模式的抽象和实现。</li>
<li>Spring Cloud Consul 基于Hashicorp Consul实现的服务发现和配置管理。</li>
<li>Spring Cloud Security 在Zuul代理中为OAuth2 rest客户端和认证头转发提供负载均衡</li>
<li>Spring Cloud Sleuth SpringCloud应用的分布式追踪系统，和Zipkin，HTrace，ELK兼容。</li>
<li>Spring Cloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。</li>
<li>Spring Cloud Stream 基于Redis,Rabbit,Kafka实现的消息微服务，简单声明模型用以在Spring Cloud应用中收发消息。</li>
<li>Spring Cloud Stream App Starters 基于Spring Boot为外部系统提供spring的集成</li>
<li>Spring Cloud Task 短生命周期的微服务，为SpringBooot应用简单声明添加功能和非功能特性。</li>
<li>Spring Cloud Task App Starters</li>
<li>Spring Cloud Zookeeper 服务发现和配置管理基于Apache Zookeeper。</li>
<li>Spring Cloud for Amazon Web Services 快速和亚马逊网络服务集成。</li>
<li>Spring Cloud Connectors 便于PaaS应用在各种平台上连接到后端像数据库和消息经纪服务。</li>
<li>Spring Cloud Starters （项目已经终止并且在Angel.SR2后的版本和其他项目合并）</li>
<li>Spring Cloud CLI 插件用Groovy快速的创建Spring Cloud组件应用。</li>
<li>Spring Cloud共集成了19个子项目，里面都包含一个或者多个第三方的组件或者框架！</li>
</ul>
<h1 id="简单说说什么是-Feign？"><a href="#简单说说什么是-Feign？" class="headerlink" title="简单说说什么是 Feign？"></a>简单说说什么是 Feign？</h1><ul>
<li>Feign 是一种声明式、模板化的 HTTP 客户端技术(仅在 consumer 中使用)。</li>
</ul>
<h1 id="什么是-Eureka-注册中心？"><a href="#什么是-Eureka-注册中心？" class="headerlink" title="什么是 Eureka 注册中心？"></a>什么是 Eureka 注册中心？</h1><ul>
<li>Eureka 是 Netflix 开发的服务发现组件，本身是一个基于 REST 的服务</li>
<li>Spring Cloud将它集成在其子项目 spring-cloud-netflix 中，以实现 Spring Cloud 的服务注册于发现，同时还提供了负载均衡、故障转移等能力。</li>
</ul>
<h1 id="简单谈一下-Eureka-中的三种角色分别是什么？"><a href="#简单谈一下-Eureka-中的三种角色分别是什么？" class="headerlink" title="简单谈一下 Eureka 中的三种角色分别是什么？"></a>简单谈一下 Eureka 中的三种角色分别是什么？</h1><ul>
<li>Eureka Server：通过 Register、Get、Renew 等接口提供服务的注册和发现。</li>
<li>Application Service (Service Provider)：服务提供方把自身的服务实例注册到 Eureka Server 中</li>
<li>Application Client (Service Consumer)：服务调用方通过 Eureka Server 获取服务列表，消费服务。</li>
</ul>
<h1 id="什么是-Ribbon"><a href="#什么是-Ribbon" class="headerlink" title="什么是 Ribbon"></a>什么是 Ribbon</h1><ul>
<li>Ribbon 是一个基于 Http 和 TCP 的客服端负载均衡工具，它是基于 Netflix Ribbon实现的。</li>
<li>它不像 spring cloud 服务注册中心、配置中心、API 网关那样独立部署，但是它几乎存在于每个 spring cloud 微服务中。包括 feign 提供的声明式服务调用也是基于该 Ribbon<br>实现的。</li>
<li>ribbon 默认提供很多种负载均衡算法，例如 轮询、随机 等等。甚至包含自定义的负载均衡算法。</li>
</ul>
<h1 id="集中式与进程内负载均衡的区别"><a href="#集中式与进程内负载均衡的区别" class="headerlink" title="集中式与进程内负载均衡的区别"></a>集中式与进程内负载均衡的区别</h1><ul>
<li>目前业界主流的负载均衡方案可分成两类：<ul>
<li>第一类：集中式负载均衡, 即在 consumer 和 provider 之间使用独立的负载均衡设施(可以是硬件，如 F5, 也可以是软件，如 nginx), 由该设施负责把 访问请求 通过某种策略转发至 provider；</li>
<li>第二类：进程内负载均衡，将负载均衡逻辑集成到 consumer，consumer 从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的 provider。</li>
</ul>
</li>
<li>Ribbon 就属于后者，它只是一个类库，集成于 consumer 进程，consumer 通过它来获取到 provider 的地址。</li>
</ul>
<h1 id="Ribbon-的常见负载均衡策略有哪些？"><a href="#Ribbon-的常见负载均衡策略有哪些？" class="headerlink" title="Ribbon 的常见负载均衡策略有哪些？"></a>Ribbon 的常见负载均衡策略有哪些？</h1><ul>
<li>轮询策略（默认） RoundRobinRule<ul>
<li>轮询策略表示每次都顺序取下一个provider，比如一共有 5 个 provider，第 1 次取第 1 个，第 2 次取第 2 个，第3 次取第 3 个，以此类推</li>
</ul>
</li>
<li>权重轮询策略WeightedResponseTime Rule<ul>
<li>根据每个 provider 的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性越低。</li>
<li>原理：一开始为轮询策略，并开启一个计时器，每 30 秒收集一次每个provider 的平均响应时间，当信息足够时，给每个 provider 附上一个权重，并按权重随机选择 provider，高权越重的 provider 会被高概率选中。</li>
</ul>
</li>
<li>随机策略 RandomRule<ul>
<li>从 provider 列表中随机选择一个provider</li>
</ul>
</li>
<li>最少并发数策略 BestAvailableRule<ul>
<li>选择正在请求中的并发数最小的provider，除非这个 provider 在熔断中。</li>
</ul>
</li>
<li>在“选定的负载均衡策略”基础上进行重试机制RetryRule<ul>
<li>“选定的负载均衡策略”这个策略是轮询策略 RoundRobinRule</li>
<li>该重试策略先设定一个阈值时间段，如果在这个阈值时间段内当选择provider 不成功，则一直尝试采用“选定的负载均衡策略：轮询策略”最后选择一个可用的 provider</li>
</ul>
</li>
<li>可用性敏感策略 AvailabilityFilteringRule<ul>
<li>过滤性能差的 provider,有 2 种：<ul>
<li>第一种：过滤掉在 eureka 中处于一直连接失败 provider</li>
<li>第二种：过滤掉高并发的 provider</li>
</ul>
</li>
<li>以一个区域为单位考察可用性，对于不可用的区域整个丢弃，从剩下区域中选可用的 provider</li>
</ul>
</li>
<li>区域敏感性策略 ZoneAvoidanceRule<ul>
<li>如果这个ip区域内有一个或多个实例不可达或响应变慢，都会降低该 ip 区域内其他 ip 被选中的权重。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring cloud</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/publishes/c9fa4a3e43dd.html</url>
    <content><![CDATA[<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><ul>
<li>AOP(Aspect-Oriented Programming), 即 面向切面编程</li>
<li>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题</li>
<li>这些交叉问题与应用程序的主要业务逻辑不同</li>
<li>因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。</li>
</ul>
<h1 id="Spring中Bean的⽣命周期。"><a href="#Spring中Bean的⽣命周期。" class="headerlink" title="Spring中Bean的⽣命周期。"></a>Spring中Bean的⽣命周期。</h1><ul>
<li>Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅法-》调⽤InitializationBean的afterPropertiesSet()的⽅法-》调⽤定制的初始化⽅法callCustom的init-method-》调⽤BeanPostProsessor的后初始化⽅法-》Bean可以使⽤了 -》 容器关闭-》 调⽤DisposableBean的destroy⽅法-》调⽤定制的销毁⽅法CallCustom的destroy-method。</li>
<li>Spring对Bean进⾏实例化（相当于程序中的new Xx()）</li>
<li>Spring将值和Bean的引⽤注⼊进Bean对应的属性中</li>
<li>如果Bean实现了BeanNameAware接⼝，Spring将Bean的ID传递给setBeanName()⽅法（实现BeanNameAware清主要是为了通过Bean的引⽤来获得Bean的ID，⼀般业务中是很少有⽤到Bean的ID的）</li>
<li>如果Bean实现了BeanFactoryAware接⼝，Spring将调⽤setBeanDactory(BeanFactory bf)⽅法并把BeanFactory容器实例作为参数传⼊。（实现BeanFactoryAware 主要⽬的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</li>
<li>如果Bean实现了ApplicationContextAwaer接⼝，Spring容器将调⽤setApplicationContext(ApplicationContext ctx)⽅法，把y应⽤上下⽂作为参数传⼊.(作⽤与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调⽤setApplicationContext⽅法时会把它⾃⼰作为setApplicationContext 的参数传⼊，⽽Spring容器在调⽤setBeanDactory前需要程序员⾃⼰指定（注⼊）setBeanDactory⾥的参数BeanFactory )</li>
<li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessBeforeInitialization（预初始化）⽅法（作⽤是在Bean实例创建成功后对进⾏增强处理，如对Bean进⾏修改，增加某个功能）7.如果Bean实现了InitializingBean接⼝，Spring将调⽤它们的afterPropertiesSet⽅法，作⽤与在配置⽂件中对Bean使⽤init-method声明初始化的作⽤⼀样，都是在Bean的全部属性设置成功后执⾏的初始化⽅法。</li>
<li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessAfterInitialization（后初始化）⽅法（作⽤与7的⼀样，只不过7是在Bean初始化前执⾏的，⽽这个是在Bean初始化后执⾏的，时机不同 ）</li>
<li>经过以上的⼯作后，Bean将⼀直驻留在应⽤上下⽂中给应⽤使⽤，直到应⽤上下⽂被销毁</li>
<li>如果Bean实现了DispostbleBean接⼝，Spring将调⽤它的destory⽅法，作⽤与在配置⽂件中对Bean使⽤destory￾method属性的作⽤⼀样，都是在Bean实例销毁前执⾏的⽅法。</li>
</ul>
<h1 id="Spring-AOP解决了什么问题？怎么实现的？"><a href="#Spring-AOP解决了什么问题？怎么实现的？" class="headerlink" title="Spring AOP解决了什么问题？怎么实现的？"></a>Spring AOP解决了什么问题？怎么实现的？</h1><ul>
<li>作⽤<ul>
<li>AOP技术，利⽤⼀种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共⾏为封装到⼀个可重⽤模块，并将其名为“Aspect”，即⽅⾯</li>
<li>所谓“⽅⾯”，简单地说，就是将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li>
</ul>
</li>
<li>实现：<ul>
<li>⼀是采⽤动态代理技术，利⽤截取消息的⽅式，对该消息进⾏装饰，以取代原有对象⾏为的执⾏；</li>
<li>⼆是采⽤静态织⼊的⽅式，引⼊特定的语法创建“⽅⾯”，从⽽使得编译器可以在编译期间织⼊有关“⽅⾯”的代码。</li>
</ul>
</li>
<li>使⽤场景：<ul>
<li>Authentication 权限</li>
<li>Caching 缓存</li>
<li>Context passing 内容传递</li>
<li>Error handling 错误处理</li>
<li>Lazy loading　懒加载</li>
<li>Debugging　　调试</li>
<li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li>
<li>Performance optimization　性能优化</li>
<li>Persistence　　持久化</li>
<li>Resource pooling　资源池</li>
<li>Synchronization　同步</li>
<li>Transactions 事务</li>
</ul>
</li>
<li>⼏个概念：<ul>
<li>切⾯（Aspect）：对象操作过程中的截⾯，这可能是AOP中最为关键的术语。切⾯所要做的事就是专注于各⾃领域的逻辑实现，这样可以使得开发逻辑更加清晰，更加适合专业的分⼯合作。由于切⾯的隔离性，降低了耦合，这样就可以在不同的应⽤中将各个切⾯组合使⽤，从⽽是代码重⽤性⼤⼤增加。</li>
<li>连接点：程序运⾏过程中的某个阶段点，如某个⽅法的调⽤，或者异常的抛出。</li>
<li>处理逻辑（Advice）：在某⼀个连接点所采⽤的处理逻辑，处理逻辑的调⽤模式通常有三种：<ul>
<li>Around 在连接点前后插⼊预处理过程和后处理过程。</li>
<li>Before 仅在连接点钱出⼊处理过程。</li>
<li>Throw 在连接点抛出异常时进⾏异常处理。</li>
</ul>
</li>
<li>切点（PointCut）：⼀系列连接点的集合，它指明处理逻辑将在合适触发。</li>
</ul>
</li>
</ul>
<h1 id="Spring事务的传播属性是怎么回事？它会影响什么？"><a href="#Spring事务的传播属性是怎么回事？它会影响什么？" class="headerlink" title="Spring事务的传播属性是怎么回事？它会影响什么？"></a>Spring事务的传播属性是怎么回事？它会影响什么？</h1><ul>
<li>七个事务传播属性：<ul>
<li>PROPAGATION_REQUIRED – ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。</li>
<li>PROPAGATION_SUPPORTS – ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</li>
<li>PROPAGATION_MANDATORY – ⽀持当前事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATIONREQUIRESNEW – 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>PROPAGATIONNOTSUPPORTED – 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER – 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATIONNESTED – 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与PROPAGATIONREQUIRED类似的操作。</li>
</ul>
</li>
<li>五个隔离级别：<ul>
<li>ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.</li>
<li>另外四个与JDBC的隔离级别相对应：<ul>
<li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种隔离级别会产⽣脏读，不可重复读和幻读。</li>
<li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li>
<li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li>
<li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不可重复读外，还避免了幻读。</li>
</ul>
</li>
</ul>
</li>
<li>关键词：<ul>
<li>幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；</li>
<li>不可重复读：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；</li>
<li>脏读：事务1更新了记录，但没有提交，事务2读取了更新后的⾏，然后事务T1回滚，现在T2读取⽆效。</li>
</ul>
</li>
</ul>
<h1 id="Spring中BeanFactory和FactoryBean有什么区别？"><a href="#Spring中BeanFactory和FactoryBean有什么区别？" class="headerlink" title="Spring中BeanFactory和FactoryBean有什么区别？"></a>Spring中BeanFactory和FactoryBean有什么区别？</h1><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul>
<li>以Factory结尾，表示它是⼀个⼯⼚类(接⼝)，⽤于管理Bean的⼀个⼯⼚</li>
<li>在Spring中，BeanFactory是IOC容器的核⼼接⼝，它的职责包括：实例化、定位、配置应⽤程序中的对象及建⽴这些对象间的依赖。</li>
</ul>
<h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><ul>
<li>以Bean结尾，表示它是⼀个Bean，不同于普通Bean的是：它是实现了FactoryBean接⼝的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽不是FactoryBean本身</li>
<li>如果要获取FactoryBean对象，请在id前⾯加⼀个&amp;符号来获取。</li>
</ul>
<h1 id="Spring框架中IOC的原理是什么？"><a href="#Spring框架中IOC的原理是什么？" class="headerlink" title="Spring框架中IOC的原理是什么？"></a>Spring框架中IOC的原理是什么？</h1><ul>
<li>IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。 </li>
<li>在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</li>
<li>在系统运⾏中，动态的向某个对象提供它所需要的其他对象。 </li>
<li>依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li>
</ul>
<h1 id="spring的依赖注⼊有哪⼏种⽅式"><a href="#spring的依赖注⼊有哪⼏种⽅式" class="headerlink" title="spring的依赖注⼊有哪⼏种⽅式"></a>spring的依赖注⼊有哪⼏种⽅式</h1><ul>
<li>在Spring容器中为⼀个bean配置依赖注⼊有四种⽅式：<ul>
<li>使⽤属性的setter⽅法注⼊ 这是最常⽤的⽅式；</li>
<li>使⽤构造器注⼊；</li>
<li>使⽤Filed注⼊（⽤于注解⽅式）.</li>
<li>静态、实例⼯⼚的⽅法注⼊</li>
</ul>
</li>
</ul>
<h1 id="⽤Spring如何实现⼀个切⾯？"><a href="#⽤Spring如何实现⼀个切⾯？" class="headerlink" title="⽤Spring如何实现⼀个切⾯？"></a>⽤Spring如何实现⼀个切⾯？</h1><ul>
<li>@Aspect</li>
</ul>
<h1 id="Spring如何实现数据库事务？"><a href="#Spring如何实现数据库事务？" class="headerlink" title="Spring如何实现数据库事务？"></a>Spring如何实现数据库事务？</h1><ul>
<li>使⽤@Transactional注解或在配置⽂件⾥⾯配置</li>
</ul>
<h1 id="Spring加载次序Classloader"><a href="#Spring加载次序Classloader" class="headerlink" title="Spring加载次序Classloader"></a>Spring加载次序Classloader</h1><ul>
<li>先构造函数——&gt;然后是bean的set⽅法注⼊——&gt;InitializingBean的afterPropertiesSet⽅法——&gt;init-method⽅法；</li>
<li>InitializingBean接⼝为bean提供了初始化⽅法的⽅式，它只包括afterPropertiesSet⽅法，凡是继承该接⼝的类，在初始化bean的时候会执⾏该⽅法。系统则是先调⽤afterPropertiesSet⽅法，然后在调⽤init-method中指定的⽅法。</li>
<li>Spring装配Bean的过程：<ul>
<li>实例化; </li>
<li>设置属性值; </li>
<li>如果实现了BeanNameAware接⼝,调⽤setBeanName设置Bean的ID或者Name; </li>
<li>如果实现BeanFactoryAware接⼝,调⽤setBeanFactory 设置BeanFactory; </li>
<li>如果实现ApplicationContextAware,调⽤setApplicationContext设置ApplicationContext </li>
<li>调⽤BeanPostProcessor的预先初始化⽅法; </li>
<li>调⽤InitializingBean的afterPropertiesSet()⽅法; </li>
<li>调⽤定制init-method⽅法； </li>
<li>调⽤BeanPostProcessor的后初始化⽅法;</li>
</ul>
</li>
<li>Spring容器关闭过程：<ul>
<li>调⽤DisposableBean的destroy(); </li>
<li>调⽤定制的destroy-method⽅法;</li>
</ul>
</li>
</ul>
<h1 id="IOC控制反转与DI依赖注⼊"><a href="#IOC控制反转与DI依赖注⼊" class="headerlink" title="IOC控制反转与DI依赖注⼊"></a>IOC控制反转与DI依赖注⼊</h1><ul>
<li>IOC控制反转：是⼀种将对象交给容器去控制的设计思想，松耦合，⽅便单元测试，增加功能重⽤性；</li>
<li>DI依赖注⼊：组件之间依赖关系由容器在运⾏期决定，形象的说，即由容器动态的将某个依赖关系注⼊到组件之中。依赖注⼊的⽬的并⾮为软件系统带来更多功能，⽽是为了提升组件重⽤的频率，并为系统搭建⼀个灵活、可扩展的平台。通过依赖注⼊机制，我们只需要通过简单的配置，⽽⽆需任何代码就可指定⽬标需要的资源，完成⾃身的业务逻辑，⽽不需要关⼼具体的资源来⾃何处，由谁实现。</li>
<li>AOP⾯向切⾯编程：⾯向切⾯编程（AOP）完善spring的依赖注⼊（DI）。</li>
</ul>
<h1 id="spring事件的实现原理，写出常⽤的⼏个事件。"><a href="#spring事件的实现原理，写出常⽤的⼏个事件。" class="headerlink" title="spring事件的实现原理，写出常⽤的⼏个事件。"></a>spring事件的实现原理，写出常⽤的⼏个事件。</h1><ul>
<li>事件机制：Spring中的事件机制是⼀个观察者模式的实现，观察者模式就是⼀个⽬标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。</li>
<li>spring默认存在的事件：<ul>
<li>ContextStartedEvent：ApplicationContext启动后触发的事件</li>
<li>ContextStoppedEvent：ApplicationContext停⽌后触发的事件</li>
<li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件</li>
<li>ContextClosedEvent：ApplicationContext关闭后触发的事件</li>
</ul>
</li>
</ul>
<h1 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h1><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h1 id="列举-Spring-Framework-的优点"><a href="#列举-Spring-Framework-的优点" class="headerlink" title="列举 Spring Framework 的优点"></a>列举 Spring Framework 的优点</h1><ul>
<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>
<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>
<li>由于依赖注入和控制反转，JDBC 得以简化。</li>
<li>它是开源免费的。</li>
</ul>
<h1 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h1><ul>
<li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li>
<li>IOC - 控制反转</li>
<li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h1 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h1><ul>
<li>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
</li>
<li>数据访问&#x2F;集成 – 该层提供与数据库交互的支持。它包含以下模块：<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
</li>
<li>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
</li>
<li>AOP – 该层支持面向切面编程<ul>
<li>Instrumentation – 该层为类检测和类加载器实现提供支持。</li>
<li>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</li>
</ul>
</li>
<li>几个杂项模块:<ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
</li>
</ul>
<h1 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h1><ul>
<li>Spring 配置文件是 XML 文件</li>
<li>该文件主要包含类信息</li>
<li>它描述了这些类是如何配置以及相互引入的</li>
<li>但是，XML 配置文件冗长且更加干净</li>
<li>如果没有正确规划和编写，那么在大项目中管理变得非常困难。</li>
</ul>
<h1 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h1><ul>
<li>接口 - 定义功能。</li>
<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>
<li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li>
<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>
<li>用户程序 - 它使用接口。</li>
</ul>
<h1 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h1><ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h1 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h1><ul>
<li>Spring 框架的核心是 Spring 容器</li>
<li>容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期</li>
<li>Spring 容器使用依赖注入来管理组成应用程序的组件</li>
<li>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令</li>
<li>该元数据可以通过 XML，Java 注解或 Java 代码提供。</li>
</ul>
<h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><ul>
<li>在依赖注入中，您不必创建对象，但必须描述如何创建它们</li>
<li>您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务</li>
<li>由 IoC 容器将它们装配在一起。</li>
</ul>
<h1 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h1><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h1 id="列举-IoC-的一些好处。"><a href="#列举-IoC-的一些好处。" class="headerlink" title="列举 IoC 的一些好处。"></a>列举 IoC 的一些好处。</h1><ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h1 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h1><ul>
<li>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</li>
</ul>
<h1 id="什么是-spring-bean？"><a href="#什么是-spring-bean？" class="headerlink" title="什么是 spring bean？"></a>什么是 spring bean？</h1><ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<h1 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h1><ul>
<li>基于 xml 配置<ul>
<li>bean 所需的依赖项和服务在 XML 格式的配置文件中指定</li>
<li>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项</li>
<li>它们通常以 bean 标签开头</li>
</ul>
</li>
<li>基于注解配置<ul>
<li>可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配</li>
<li>默认情况下，Spring 容器中未打开注解装配</li>
<li>因此，您需要在使用它之前在 Spring 配置文件中启用它：<a href="context:annotation-config/">context:annotation-config/</a></li>
</ul>
</li>
<li>基于 Java API 配置<ul>
<li>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h1><ul>
<li>Spring bean 支持 5 种 scope：<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
</li>
<li>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</li>
</ul>
<h1 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h1><ul>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（<bean> 的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（<bean> 的 destroy-method 属性），那么将调用它。</li>
</ul>
<h1 id="什么是-spring-的内部-bean？"><a href="#什么是-spring-的内部-bean？" class="headerlink" title="什么是 spring 的内部 bean？"></a>什么是 spring 的内部 bean？</h1><ul>
<li>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean</li>
<li>为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或 <constructor-arg> 中提供了 <bean> 元素的使用</li>
<li>内部 bean 总是匿名的，它们总是作为原型。</li>
</ul>
<h1 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h1><ul>
<li>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配</li>
<li>Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</li>
</ul>
<h1 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h1><ul>
<li>Spring 容器能够自动装配 bean</li>
<li>也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</li>
<li>自动装配的不同模式：<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
</li>
</ul>
<h1 id="自动装配有什么局限？"><a href="#自动装配有什么局限？" class="headerlink" title="自动装配有什么局限？"></a>自动装配有什么局限？</h1><ul>
<li>覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h1 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h1><ul>
<li>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身</li>
<li>它可以作为 XML 设置的替代方案。例如：Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul>
<li>@Bean 注解扮演与元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
</li>
</ul>
<h1 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h1><ul>
<li>默认情况下，Spring 容器中未打开注解装配</li>
<li>要使用基于注解装配，我们必须通过配置&lt;context：annotation-config &#x2F;&gt; 元素在 Spring 配置文件中启用它</li>
</ul>
<h1 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h1><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h1 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h1><ul>
<li>Required 应用于 bean 属性 setter 方法</li>
<li>此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性</li>
<li>如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    @Required</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    public string getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h1><ul>
<li>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配</li>
<li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean</li>
<li>默认情况下，它是类型驱动的注入。</li>
</ul>
<h1 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h1><ul>
<li>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</li>
<li>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</li>
</ul>
<h1 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h1><ul>
<li>RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法</li>
<li>此注释可应用于两个级别：<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
</li>
</ul>
<h1 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h1><ul>
<li>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作</li>
<li>这使得用户容易在持久性技术之间切换</li>
<li>它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</li>
</ul>
<h1 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h1><pre><code>- JdbcTemplate
- SimpleJdbcTemplate
- NamedParameterJdbcTemplate
- SimpleJdbcInsert
- SimpleJdbcCall
</code></pre>
<h1 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h1><ul>
<li>我们可以通过两种方式使用 Spring 访问 Hibernate：<ul>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ul>
</li>
</ul>
<h1 id="列举-spring-支持的事务管理类型"><a href="#列举-spring-支持的事务管理类型" class="headerlink" title="列举 spring 支持的事务管理类型"></a>列举 spring 支持的事务管理类型</h1><ul>
<li>Spring 支持两种类型的事务管理：<ul>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ul>
</li>
</ul>
<h1 id="spring-支持哪些-ORM-框架"><a href="#spring-支持哪些-ORM-框架" class="headerlink" title="spring 支持哪些 ORM 框架"></a>spring 支持哪些 ORM 框架</h1><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h1 id="指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h1><ul>
<li>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</li>
<li>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</li>
</ul>
<h1 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h1><ul>
<li>实现 AOP 的技术，主要分为两大类：<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
</ul>
</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h1><ul>
<li>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</li>
<li>Spring AOP 仅支持方法级别的 PointCut；AspectJ 提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</li>
</ul>
<h1 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h1><ul>
<li>将 Advice 应用于目标对象后创建的对象称为代理</li>
<li>在客户端对象的情况下，目标对象和代理对象是相同的。</li>
<li>Advice + Target Object &#x3D; Proxy</li>
</ul>
<h1 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h1><ul>
<li>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）</li>
<li>在 Spring AOP 中，编织在运行时执行</li>
</ul>
<h1 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h1><ul>
<li>WebApplicationContext 是 ApplicationContext 的扩展</li>
<li>它具有 Web 应用程序所需的一些额外功能</li>
<li>它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</li>
</ul>
<h1 id="IoC-和-DI的区别？"><a href="#IoC-和-DI的区别？" class="headerlink" title="IoC 和 DI的区别？"></a>IoC 和 DI的区别？</h1><ul>
<li>IoC 控制反转，指将对象的创建权，反转到Spring容器</li>
<li>DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</li>
</ul>
<p> </p>
<h1 id="BeanFactory-接口和-ApplicationContext-接口有什么区别？"><a href="#BeanFactory-接口和-ApplicationContext-接口有什么区别？" class="headerlink" title="BeanFactory 接口和 ApplicationContext 接口有什么区别？"></a>BeanFactory 接口和 ApplicationContext 接口有什么区别？</h1><ul>
<li>ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。</li>
<li>ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));</span><br><span class="line">IHelloService helloService = (IHelloService) beanFactory.getBean(&quot;helloService&quot;);</span><br><span class="line">helloService.sayHello();</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="spring配置bean实例化有哪些方式？"><a href="#spring配置bean实例化有哪些方式？" class="headerlink" title="spring配置bean实例化有哪些方式？"></a>spring配置bean实例化有哪些方式？</h1><ul>
<li>使用类构造器实例化(默认无参数)</li>
<li>使用静态工厂方法实例化(简单工厂模式)</li>
<li>使用实例工厂方法实例化(工厂方法模式)</li>
</ul>
<h1 id="简单的说一下spring的生命周期？"><a href="#简单的说一下spring的生命周期？" class="headerlink" title="简单的说一下spring的生命周期？"></a>简单的说一下spring的生命周期？</h1><ul>
<li>instantiate bean对象实例化</li>
<li>populate properties 封装属性</li>
<li>如果Bean实现BeanNameAware 执行 setBeanName</li>
<li>如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext</li>
<li>如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)</li>
<li>如果Bean实现InitializingBean 执行 afterPropertiesSet </li>
<li>调用<bean init-method="init"> 指定初始化方法 init</li>
<li>如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization</li>
<li>执行业务处理</li>
<li>如果Bean实现 DisposableBean 执行 destroy</li>
<li>调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy</li>
</ul>
<h1 id="请介绍一下Spring框架中Bean的生命周期和作用域"><a href="#请介绍一下Spring框架中Bean的生命周期和作用域" class="headerlink" title="请介绍一下Spring框架中Bean的生命周期和作用域"></a>请介绍一下Spring框架中Bean的生命周期和作用域</h1><ul>
<li>bean定义：在配置文件里面用<bean></bean>来进行定义。</li>
<li>bean初始化，有两种方式初始化:<ul>
<li>在配置文件中通过指定init-method属性来完成</li>
<li>实现org.springframwork.beans.factory.InitializingBean接口</li>
</ul>
</li>
<li>bean调用：有三种方式可以得到bean实例，并进行调用</li>
<li>bean销毁，销毁有两种方式<ul>
<li>使用配置文件指定的destroy-method属性</li>
<li>实现org.springframwork.bean.factory.DisposeableBean接口</li>
</ul>
</li>
<li>作用域<ul>
<li>singleton：当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</li>
<li>prototype：Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域</li>
<li>request：在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global session：在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</li>
</ul>
</li>
</ul>
<h1 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h1><ul>
<li>BeanFactory：产生一个新的实例，可以实现单例模式</li>
<li>BeanWrapper：提供统一的get及set方法</li>
<li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li>
</ul>
<h1 id="Spring里面applicationContext-xml文件能不能改成其他文件名？"><a href="#Spring里面applicationContext-xml文件能不能改成其他文件名？" class="headerlink" title="Spring里面applicationContext.xml文件能不能改成其他文件名？"></a>Spring里面applicationContext.xml文件能不能改成其他文件名？</h1><ul>
<li>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化</li>
<li>缺省情况下， 它会在WEB-INF&#x2F;applicationContext.xml文件找Spring的配置</li>
<li>你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的位置</li>
</ul>
<p>11.Spring里面如何定义hibernate mapping？ </p>
<ul>
<li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li>
</ul>
<h1 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h1><ul>
<li>Spring使用ThreadLocal解决线程安全问题</li>
<li>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域</li>
<li>就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</li>
<li>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</li>
<li>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量</li>
<li>这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</li>
<li>而ThreadLocal则从另一个角度来解决多线程的并发访问</li>
<li>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突</li>
<li>因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li>
<li>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</li>
<li>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换</li>
<li>但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。</li>
<li>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li>
<li>前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li>
</ul>
<h1 id="介绍一下Spring的事物管理"><a href="#介绍一下Spring的事物管理" class="headerlink" title="介绍一下Spring的事物管理"></a>介绍一下Spring的事物管理</h1><ul>
<li>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</li>
<li>开发中为了避免这种情况一般都会进行事务管理</li>
<li>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能</li>
<li>spring提供了几个关于事务处理的类：<ul>
<li>TransactionDefinition &#x2F;&#x2F;事务属性定义</li>
<li>TranscationStatus &#x2F;&#x2F;代表了当前的事务，可以提交，回滚。</li>
<li>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。</li>
</ul>
</li>
<li>spring提供的事务管理可以分为两类：编程式的和声明式的<ul>
<li>编程式的，比较灵活，但是代码量大，存在重复的代码比较多</li>
<li>声明式的比编程式的更灵活。</li>
</ul>
</li>
<li>编程式主要使用transactionTemplate</li>
<li>省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.</li>
</ul>
<h1 id="AOP-通知有哪些类型？"><a href="#AOP-通知有哪些类型？" class="headerlink" title="AOP 通知有哪些类型？"></a>AOP 通知有哪些类型？</h1><ul>
<li>前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li>
<li>返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li>
<li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li>
<li>后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li>
<li>环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</li>
</ul>
<h1 id="什么是-spring"><a href="#什么是-spring" class="headerlink" title="什么是 spring?"></a>什么是 spring?</h1><ul>
<li>Spring 是个 java 企业级应用的开源开发框架</li>
<li>Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用</li>
<li>Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</li>
</ul>
<h1 id="使用-Spring-框架的好处是什么？"><a href="#使用-Spring-框架的好处是什么？" class="headerlink" title="使用 Spring 框架的好处是什么？"></a>使用 Spring 框架的好处是什么？</h1><ul>
<li>轻量：Spring 是轻量的，基本的版本大约 2MB</li>
<li>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li>
<li>容器：Spring 包含并管理应用中对象的生命周期和配置</li>
<li>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品</li>
<li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</li>
</ul>
<h1 id="ApplicationContext-通常的实现是什么？"><a href="#ApplicationContext-通常的实现是什么？" class="headerlink" title="ApplicationContext 通常的实现是什么？"></a>ApplicationContext 通常的实现是什么？</h1><ul>
<li>FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li>
<li>ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找bean 配置。</li>
<li>WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个WEB 应用的所有 bean。</li>
</ul>
<h1 id="一个-Spring-的应用看起来象什么？"><a href="#一个-Spring-的应用看起来象什么？" class="headerlink" title="一个 Spring 的应用看起来象什么？"></a>一个 Spring 的应用看起来象什么？</h1><ul>
<li>一个定义了一些功能的接口</li>
<li>这实现包括属性，它的 Setter ， getter 方法和函数等</li>
<li>Spring AOP</li>
<li>Spring 的 XML 配置文件</li>
<li>使用以上功能的客户端程序</li>
</ul>
<h1 id="哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？"><a href="#哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？" class="headerlink" title="哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？"></a>哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？</h1><ul>
<li>你两种依赖方式都可以使用，构造器注入和 Setter 方法注入</li>
<li>最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。</li>
</ul>
<h1 id="什么是-Spring-beans？"><a href="#什么是-Spring-beans？" class="headerlink" title="什么是 Spring beans？"></a>什么是 Spring beans？</h1><ul>
<li>Spring beans 是那些形成 Spring 应用的主干的 java 对象</li>
<li>它们被 Spring IOC 容器初始化，装配，和管理</li>
<li>这些 beans 通过容器中配置的元数据创建</li>
<li>比如，以 XML文件中<bean/> 的形式定义。</li>
<li>Spring 框架定义的 beans 都是单件 beans</li>
<li>在 bean tag 中有个属性”singleton”，如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean</li>
<li>默认是TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件</li>
</ul>
<h1 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h1><ul>
<li>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</li>
</ul>
<h1 id="如何给-Spring-容器提供配置元数据？"><a href="#如何给-Spring-容器提供配置元数据？" class="headerlink" title="如何给 Spring 容器提供配置元数据？"></a>如何给 Spring 容器提供配置元数据？</h1><ul>
<li>这里有三种重要的方法给 Spring 容器提供配置元数据。<ul>
<li>XML 配置文件。</li>
<li>基于注解的配置。</li>
<li>基于 java 的配置。</li>
</ul>
</li>
</ul>
<h1 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h1><ul>
<li>当定义一个<bean> 在 Spring 里，我们还能给这个 bean 声明一个作用域</li>
<li>它可以通过bean定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope属性必须设为singleton。</li>
</ul>
<h1 id="Spring-框架中的单例-bean-是线程安全的吗？"><a href="#Spring-框架中的单例-bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 bean 是线程安全的吗？"></a>Spring 框架中的单例 bean 是线程安全的吗？</h1><ul>
<li>不，Spring 框架中的单例 bean 不是线程安全的。</li>
</ul>
<h1 id="哪些是重要的-bean-生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的-bean-生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的 bean 生命周期方法？ 你能重载它们吗？"></a>哪些是重要的 bean 生命周期方法？ 你能重载它们吗？</h1><p>有- 两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时候被调用</p>
<ul>
<li>第二个方法是 teardown 它是在容器卸载类的时候被调用。</li>
<li>The bean 标签有两个重要的属性（init-method 和 destroy-method）</li>
<li>用它们你可 以 自 己 定 制 初 始 化 和 注 销 方 法</li>
<li>它 们 也 有 相 应 的 注 解 （ @PostConstruct 和@PreDestroy）。</li>
</ul>
<h1 id="在-Spring-中如何注入一个-java-集合？"><a href="#在-Spring-中如何注入一个-java-集合？" class="headerlink" title="在 Spring 中如何注入一个 java 集合？"></a>在 Spring 中如何注入一个 java 集合？</h1><ul>
<li>Spring 提供以下几种集合的配置元素：<ul>
<li><list>类型用于注入一列值，允许有相同的值。</li>
<li><set> 类型用于注入一组值，不允许有相同的值。</li>
<li><map> 类型用于注入一组键值对，键和值都可以为任意类型。</li>
<li><props>类型用于注入一组键值对，键和值都只能为 String 类型。</li>
</ul>
</li>
</ul>
<h1 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h1><ul>
<li>自动装配的局限性是：<ul>
<li>重写：你仍需用 <constructor-arg>和 <property> 配置来定义依赖，意味着总要重写自动装配。</li>
<li>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。</li>
<li>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li>
</ul>
</li>
</ul>
<h1 id="你可以在-Spring-中注入一个-null-和一个空字符串吗？"><a href="#你可以在-Spring-中注入一个-null-和一个空字符串吗？" class="headerlink" title="你可以在 Spring 中注入一个 null 和一个空字符串吗？"></a>你可以在 Spring 中注入一个 null 和一个空字符串吗？</h1><ul>
<li>可以。 Spring 注解</li>
</ul>
<h1 id="在-Spring-框架中如何更有效地使用-JDBC？"><a href="#在-Spring-框架中如何更有效地使用-JDBC？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC？"></a>在 Spring 框架中如何更有效地使用 JDBC？</h1><ul>
<li>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻</li>
<li>所以开发者只需写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</li>
<li>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li>
</ul>
<h1 id="Spring-对-DAO-的支持"><a href="#Spring-对-DAO-的支持" class="headerlink" title="Spring 对 DAO 的支持"></a>Spring 对 DAO 的支持</h1><ul>
<li>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，Hibernate or JDO 结合使用</li>
<li>这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</li>
</ul>
<h1 id="如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？"><a href="#如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？" class="headerlink" title="如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？"></a>如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</h1><ul>
<li>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul>
<li>配置 the Hibernate SessionFactory</li>
<li>继承 HibernateDaoSupport 实现一个 DAO</li>
<li>在 AOP 支持的事务中装配</li>
</ul>
</li>
</ul>
<h1 id="如何在spring的applicationContext-xml使用JNDI而不是DataSource"><a href="#如何在spring的applicationContext-xml使用JNDI而不是DataSource" class="headerlink" title="如何在spring的applicationContext.xml使用JNDI而不是DataSource"></a>如何在spring的applicationContext.xml使用JNDI而不是DataSource</h1><ul>
<li>可以使用”org.springframework.jndi.JndiObjectFactoryBean”来实现</li>
</ul>
<h1 id="在spring中是如何配置数据库驱动的"><a href="#在spring中是如何配置数据库驱动的" class="headerlink" title="在spring中是如何配置数据库驱动的"></a>在spring中是如何配置数据库驱动的</h1><ul>
<li>org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动</li>
</ul>
<h1 id="在web中如何配置spring"><a href="#在web中如何配置spring" class="headerlink" title="在web中如何配置spring"></a>在web中如何配置spring</h1><ul>
<li>在J2EE的web应用里面配置spring非常简单，最简单的只需要把spring得ContextLoaderListener添加到你的web.xml文件里面就可以了</li>
</ul>
<h1 id="在spring中如何定义hibernate-Mapping？"><a href="#在spring中如何定义hibernate-Mapping？" class="headerlink" title="在spring中如何定义hibernate Mapping？"></a>在spring中如何定义hibernate Mapping？</h1><ul>
<li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li>
</ul>
<h1 id="如何配置spring-struts？"><a href="#如何配置spring-struts？" class="headerlink" title="如何配置spring + struts？"></a>如何配置spring + struts？</h1><ul>
<li>在struts-config.xml加入一个插件，通过它加载applicationContext.xml</li>
<li>在struts-config.xml修改action-mapping标记，具体action交给了DelegateActionProxy</li>
<li>通过DelegateActionProxy进入一spring的环境。</li>
<li>在spring的applicationContext.xml加入<bean name=”/login” class=”“ singleton=”false”/></li>
</ul>
<h1 id="如何在spring中实现国际化"><a href="#如何在spring中实现国际化" class="headerlink" title="如何在spring中实现国际化?"></a>如何在spring中实现国际化?</h1><ul>
<li>在applicationContext.xml加载一个bean org.springframework.context.support.ResourceBundleMessageSource</li>
<li>在src目录下建多个properties文件</li>
<li>对于非英文的要用native2ascii -encoding gb2312 源目转化文件相关内容</li>
<li>其命名格式是message_语言_国家。</li>
<li>页面中的中显示提示信息，键名取键值。</li>
<li>当给定国家，系统会自动加载对应的国家的properties信息。</li>
<li>通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。</li>
</ul>
<h1 id="在spring中如何实现事件处理"><a href="#在spring中如何实现事件处理" class="headerlink" title="在spring中如何实现事件处理"></a>在spring中如何实现事件处理</h1><ul>
<li>事件 Extends ApplicationEvent</li>
<li>监听器 Implements ApplicationListener</li>
<li>事件源 Implements ApplicationContextAware</li>
<li>在applicationContext.xml中配置事件源、监听器</li>
<li>先得到事件源，调用事件源的方法，通知监听器。</li>
</ul>
<h1 id="如何将spring加入web容器中"><a href="#如何将spring加入web容器中" class="headerlink" title="如何将spring加入web容器中"></a>如何将spring加入web容器中</h1><ul>
<li>在web.xml中加入如下同容,在启动web服务器时加载&#x2F;WEB-INF&#x2F;applicationContext.xml中的内容。</li>
</ul>
<h1 id="Spring如何实现资源管理"><a href="#Spring如何实现资源管理" class="headerlink" title="Spring如何实现资源管理?"></a>Spring如何实现资源管理?</h1><ul>
<li>使用<ul>
<li>applicationContext.getResource(“classpath:文件名”):在src根目录下，在类路径下</li>
<li>applicationContext.getResource(“classpath:&#x2F;chap01&#x2F;文件名”): 以src根目录下的基准往下走。</li>
<li>applicationContext.getResource(“file:c:&#x2F;a.properties”)：在系统文件目录下。</li>
</ul>
</li>
</ul>
<h1 id="Spring的ApplicationContext的作用"><a href="#Spring的ApplicationContext的作用" class="headerlink" title="Spring的ApplicationContext的作用?"></a>Spring的ApplicationContext的作用?</h1><ul>
<li>beanFactory</li>
<li>国际化(getMesage)</li>
<li>资源管理:可以直接读取一个文件的内容(getResource)</li>
<li>加入web框架中(加入一个servlet或监听器)</li>
<li>事件处理</li>
</ul>
<h1 id="Hibernate工作原理及为什么要用？"><a href="#Hibernate工作原理及为什么要用？" class="headerlink" title="Hibernate工作原理及为什么要用？"></a>Hibernate工作原理及为什么要用？</h1><ul>
<li>原理：<ul>
<li>读取并解析配置文件</li>
<li>读取并解析映射信息，创建SessionFactory</li>
<li>打开Sesssion</li>
<li>创建事务Transation</li>
<li>持久化操作</li>
<li>提交事务</li>
<li>关闭Session</li>
<li>关闭SesstionFactory</li>
</ul>
</li>
<li>为什么要用：<ul>
<li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li>
<li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li>
<li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li>
<li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li>
</ul>
</li>
<li>Hibernate是如何延迟加载?<ul>
<li>Hibernate2延迟加载实现：a)实体对象  b)集合（Collection）</li>
<li>Hibernate3 提供了属性的延迟加载功能</li>
</ul>
</li>
<li>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</li>
<li>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)<ul>
<li>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</li>
</ul>
</li>
<li>说下Hibernate的缓存机制<ul>
<li>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</li>
<li>二级缓存：<ul>
<li>应用及缓存</li>
<li>分布式缓存<ul>
<li>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据</li>
</ul>
</li>
</ul>
</li>
<li>第三方缓存的实现</li>
</ul>
</li>
<li>Hibernate的查询方式<ul>
<li>Sql、Criteria,object comptosition</li>
<li>Hql：<ul>
<li>属性查询</li>
<li>参数查询、命名参数查询</li>
<li>关联查询</li>
<li>分页查询</li>
<li>统计函数</li>
</ul>
</li>
</ul>
</li>
<li>如何优化Hibernate？<ul>
<li>使用双向一对多关联，不使用单向一对多</li>
<li>灵活使用单向一对多关联</li>
<li>不用一对一，用多对一取代</li>
<li>配置对象缓存，不使用集合缓存</li>
<li>一对多集合使用Bag,多对多集合使用Set</li>
<li>继承类使用显式多态</li>
<li>表字段要少，表关联不要怕多，有二级缓存撑腰</li>
</ul>
</li>
</ul>
<h1 id="Spring中如何获取bean"><a href="#Spring中如何获取bean" class="headerlink" title="Spring中如何获取bean"></a>Spring中如何获取bean</h1><ul>
<li>通过xml配置文件</li>
<li>bean配置在xml里面，spring提供多种方式读取配置文件得到ApplicationContext.<ul>
<li>第一种方式：FileSystemXmlApplicationContext通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例:<ul>
<li>ApplicationContext ac &#x3D; new FileSystemXmlApplicationContext(”applicationContext.xml”)</li>
<li>ac.getBean(”beanName”);</li>
</ul>
</li>
<li>第二种方式：WebApplicationContextUtil在B&#x2F;S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext.例如：<ul>
<li>ApplicationContext ctx &#x3D; WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);</li>
<li>ApplicationContext ctx &#x3D;   WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</li>
<li>其中 servletContext sc 可以具体 换成 servlet.getServletContext()或者 this.getServletContext() 或者 request.getSession().getServletContext();</li>
<li>另外，由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象：</li>
<li>WebApplicationContext webApplicationContext &#x3D; (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Spring框架中的单例Beans是线程安全的么？"><a href="#Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="Spring框架中的单例Beans是线程安全的么？"></a>Spring框架中的单例Beans是线程安全的么？</h1><ul>
<li>Spring框架并没有对单例bean进行任何多线程的封装处理</li>
<li>关于单例bean的线程安全和并发问题需要开发者自行去搞定</li>
<li>但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的</li>
<li>如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。</li>
<li>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</li>
</ul>
<h1 id="如何向Spring-Bean中注入一个Java-util-Properties？"><a href="#如何向Spring-Bean中注入一个Java-util-Properties？" class="headerlink" title="如何向Spring Bean中注入一个Java.util.Properties？"></a>如何向Spring Bean中注入一个Java.util.Properties？</h1><ul>
<li>第一种方法是使用如下面代码所示的<props> 标签</li>
<li>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。</li>
</ul>
<h1 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h1><ul>
<li>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</li>
<li>我们可以创建bean用来监听在ApplicationContext 中发布的事件</li>
<li>ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li>
<li>Spring 提供了以下5中标准的事件：<ul>
<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li>
</ul>
</li>
<li>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。为了监听这个事件，还需要创建一个监听器，之后通过applicationContext接口的publishEvent()方法来发布自定义事件。</li>
</ul>
<h1 id="FileSystemResource和ClassPathResource有何区别？"><a href="#FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="FileSystemResource和ClassPathResource有何区别？"></a>FileSystemResource和ClassPathResource有何区别？</h1><ul>
<li>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径</li>
<li>在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。</li>
<li>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</li>
<li>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</li>
</ul>
<h1 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h1><ul>
<li>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：<ul>
<li>代理模式—在AOP和remoting中被用的比较多。</li>
<li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li>
<li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li>
<li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入—贯穿于BeanFactory &#x2F; ApplicationContext接口的核心理念。</li>
<li>工厂模式—BeanFactory用来创建对象的实例</li>
</ul>
</li>
</ul>
<p> </p>
<h1 id="开发中主要使用-Spring-的什么技术"><a href="#开发中主要使用-Spring-的什么技术" class="headerlink" title="开发中主要使用 Spring 的什么技术 ?"></a>开发中主要使用 Spring 的什么技术 ?</h1><ul>
<li>IOC 容器管理各层的组件</li>
<li>使用 AOP 配置声明式事务</li>
<li>整合其他框架</li>
</ul>
<h1 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h1><ul>
<li>大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</li>
</ul>
<h1 id="Spring-框架的事务管理有哪些优点？"><a href="#Spring-框架的事务管理有哪些优点？" class="headerlink" title="Spring 框架的事务管理有哪些优点？"></a>Spring 框架的事务管理有哪些优点？</h1><ul>
<li>它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供一个不变的编程模式。</li>
<li>它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API</li>
<li>它支持声明式事务管理。</li>
<li>它和 Spring 各种数据访问抽象层很好得集成。</li>
</ul>
<h1 id="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h1><ul>
<li>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul>
<li>配置 the Hibernate SessionFactory。</li>
<li>继承 HibernateDaoSupport 实现一个 DAO。</li>
<li>在 AOP 支持的事务中装配。</li>
</ul>
</li>
</ul>
<h1 id="springmvc-和-spring-boot-区别？"><a href="#springmvc-和-spring-boot-区别？" class="headerlink" title="springmvc 和 spring-boot 区别？"></a>springmvc 和 spring-boot 区别？</h1><ul>
<li>总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA 等等。但他们的基础都是 Spring 的 IOC 和 AOP，IOC 提供了依赖注入的容器，而 AOP 解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；因为 Spring 的配置非常复杂，各种 xml，properties 处理起来比较繁琐。于是为了简化开发者的使用，Spring 社区创造性地推出了 Spring Boot，它遵循约定优于配置，极大降低了 Spring 使用门槛，但又不失 Spring 原本灵活强大的功能。</li>
</ul>
<h1 id="Spring-里面注解用过没有？autowired-和-resource-区别？"><a href="#Spring-里面注解用过没有？autowired-和-resource-区别？" class="headerlink" title="Spring 里面注解用过没有？autowired 和 resource 区别？"></a>Spring 里面注解用过没有？autowired 和 resource 区别？</h1><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul>
<li>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter方法。</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>@Autowired<ul>
<li>@Autowired 为 Spring 提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照 byType 注入。</li>
<li>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier 注解一起使用。</li>
</ul>
</li>
<li>@Resource<ul>
<li>@Resource 默认按照 ByName 自动注入，由 J2EE 提供，需要导入包javax.annotation.Resource。@Resource 有两个重要的属性：name 和 type，而 Spring 将@Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以，如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。</li>
</ul>
</li>
</ul>
<h1 id="Controller-和-RestController-的区别？"><a href="#Controller-和-RestController-的区别？" class="headerlink" title="@Controller 和@RestController 的区别？"></a>@Controller 和@RestController 的区别？</h1><ul>
<li>@RestController 注解相当于@ResponseBody ＋ @Controller 合在一起的作用</li>
</ul>
<h1 id="Spring-如何保证-Controller-并发的安全？"><a href="#Spring-如何保证-Controller-并发的安全？" class="headerlink" title="Spring 如何保证 Controller 并发的安全？"></a>Spring 如何保证 Controller 并发的安全？</h1><ul>
<li>在Controller中使用ThreadLocal变量</li>
<li>在spring配置文件Controller中声明 scope&#x3D;”prototype”，每次都创建新的controller</li>
<li>在控制器中不使用实例变量</li>
</ul>
<h1 id="Spring如何解决循环依赖？"><a href="#Spring如何解决循环依赖？" class="headerlink" title="Spring如何解决循环依赖？"></a>Spring如何解决循环依赖？</h1><ul>
<li>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。</li>
<li>Spring的单例对象的初始化主要分为三步：<ul>
<li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</li>
<li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充</li>
<li>initializeBean：调用spring xml中的init 方法。</li>
</ul>
</li>
<li>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。</li>
<li>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</li>
</ul>
<h1 id="查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序"></a>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序</h1><ul>
<li>Join  where  limit  group by  having</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat</title>
    <url>/publishes/cc5f72fdfb9e.html</url>
    <content><![CDATA[<h1 id="Tomcat的缺省端口是多少，怎么修改？"><a href="#Tomcat的缺省端口是多少，怎么修改？" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改？"></a>Tomcat的缺省端口是多少，怎么修改？</h1><ul>
<li>找到Tomcat目录下的conf文件夹</li>
<li>进入conf文件夹里面找到server.xml文件</li>
<li>打开server.xml文件</li>
<li>在server.xml文件里面找到下列信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li>port&#x3D;”8080”改成你想要的端口</li>
</ul>
<h1 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h1><h4 id="bio：传统的Java-I-O操作，同步且阻塞IO。"><a href="#bio：传统的Java-I-O操作，同步且阻塞IO。" class="headerlink" title="bio：传统的Java I&#x2F;O操作，同步且阻塞IO。"></a>bio：传统的Java I&#x2F;O操作，同步且阻塞IO。</h4><ul>
<li>maxThreads&#x3D;”150”&#x2F;&#x2F;Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值200。可以根据机器的时期性能和内存大小调整，一般可以在400-500。最大可以在800左右。 </li>
<li>minSpareThreads&#x3D;”25”—Tomcat初始化时创建的线程数。默认值4。如果当前没有空闲线程，且没有超过maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。 </li>
<li>maxSpareThreads&#x3D;”75”–一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值50。一旦创建的线程超过此数值，Tomcat会关闭不再需要的线程。线程数可以大致上用 “同时在线人数每秒用户操作次数系统平均操作时间” 来计算。 </li>
<li>acceptCount&#x3D;”100”—-指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。如果当前可用线程数为0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。 </li>
<li>connectionTimeout&#x3D;”20000” –网络连接超时，默认值20000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li>
</ul>
<h4 id="nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。"><a href="#nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。" class="headerlink" title="nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。"></a>nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。</h4><ul>
<li>指定使用NIO模型来接受HTTP请求 </li>
<li>protocol&#x3D;”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol&#x3D;”HTTP&#x2F;1.1” </li>
<li>acceptorThreadCount&#x3D;”2” 使用NIO模型时接收线程的数目</li>
</ul>
<h4 id="aio-nio-2-：JDK7开始支持，异步非阻塞IO。"><a href="#aio-nio-2-：JDK7开始支持，异步非阻塞IO。" class="headerlink" title="aio(nio.2)：JDK7开始支持，异步非阻塞IO。"></a>aio(nio.2)：JDK7开始支持，异步非阻塞IO。</h4><ul>
<li><p>apr：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">      &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8000&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;</span><br><span class="line">    &lt;!-- minProcessors最小空闲连接线程数--&gt;</span><br><span class="line">    &lt;!-- maxProcessors最大连接线程数--&gt;</span><br><span class="line">    &lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;</span><br><span class="line">    &lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;</span><br><span class="line">    &lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; </span><br><span class="line">        connectionTimeout=&quot;20000&quot;</span><br><span class="line">        redirectPort=&quot;8443</span><br><span class="line">        maxThreads=“500” </span><br><span class="line">        minSpareThreads=“100” </span><br><span class="line">        maxSpareThreads=“200”</span><br><span class="line">        acceptCount=&quot;200&quot;</span><br><span class="line">        enableLookups=&quot;false&quot;       </span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他配置</p>
<ul>
<li>maxHttpHeaderSize&#x3D;”8192” http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。 </li>
<li>URIEncoding&#x3D;”UTF-8” 指定Tomcat容器的URL编码格式。 </li>
<li>disableUploadTimeout&#x3D;”true” 上传时是否使用超时机制 </li>
<li>enableLookups&#x3D;”false”–是否反查域名，默认值为true。为了提高处理能力，应设置为false </li>
<li>compression&#x3D;”on”   打开压缩功能 </li>
<li>compressionMinSize&#x3D;”10240” 启用压缩的输出内容大小，默认为2KB </li>
<li>noCompressionUserAgents&#x3D;”gozilla, traviata”   对于以下的浏览器，不启用压缩 </li>
<li>compressableMimeType&#x3D;”text&#x2F;html,text&#x2F;xml,text&#x2F;javascript,text&#x2F;css,text&#x2F;plain” 哪些资源类型需要压缩</li>
</ul>
</li>
</ul>
<h1 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h1><ul>
<li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li>
<li>在server.xml文件上配置<Context>节点，设置相关的属性即可</li>
<li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li>
</ul>
<h1 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h1><ul>
<li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析， 并读取servlet注册信息</li>
<li>然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。（有时候也是在第一次请求时实例化）在servlet注册时加上如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li>
</ul>
<h1 id="tomcat-如何优化？"><a href="#tomcat-如何优化？" class="headerlink" title="tomcat 如何优化？"></a>tomcat 如何优化？</h1><ul>
<li><p>优化连接配置.这里以tomcat7的参数配置为例，需要修改conf&#x2F;server.xml文件，修改连接数，关闭客户端dns查询。</p>
</li>
<li><p>参数解释：</p>
<ul>
<li>URIEncoding&#x3D;”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</li>
<li>maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</li>
<li>minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</li>
<li>enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</li>
<li>connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</li>
<li>maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</li>
<li>acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</li>
<li>maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。通常Windows是1000个左右，Linux是2000个左右。</li>
<li>useURIValidationHack:把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</li>
<li>enableLookups&#x3D;”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</li>
<li>disableUploadTimeout ：类似于Apache中的keeyalive一样</li>
</ul>
</li>
<li><p>给Tomcat配置gzip压缩(HTTP压缩)功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compression=”on” compressionMinSize=”2048″</span><br><span class="line">compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。</p>
</li>
<li><p>相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compression=”on” 打开压缩功能</span><br><span class="line">compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB</span><br><span class="line">noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</span><br><span class="line">compressableMimeType=”text/html,text/xml”　压缩类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置</p>
</li>
</ul>
<h1 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h1><ul>
<li>内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。 </li>
<li>具体设置如下： JAVA_OPTS&#x3D;”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio&#x3D;4 -XX:SurvivorRatio&#x3D;4” </li>
<li>其各项参数如下： <ul>
<li>-Xmx3550m：设置JVM最大可用内存为3550M。 </li>
<li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 </li>
<li>-Xmn2g：设置年轻代大小为2G。整个堆大小&#x3D;年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。 </li>
<li>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 </li>
<li>-XX:NewRatio&#x3D;4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5 </li>
<li>-XX:SurvivorRatio&#x3D;4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1&#x2F;6 </li>
<li>-XX:MaxPermSize&#x3D;16m:设置持久代大小为16m。 </li>
<li>-XX:MaxTenuringThreshold&#x3D;0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li>
</ul>
</li>
</ul>
<h1 id="垃圾回收策略调优"><a href="#垃圾回收策略调优" class="headerlink" title="垃圾回收策略调优"></a>垃圾回收策略调优</h1><ul>
<li>垃圾回收的设置也是在catalina.sh中，调整JAVA_OPTS变量。 </li>
<li>具体设置如下： JAVA_OPTS&#x3D;”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis&#x3D;100” </li>
<li>具体的垃圾回收策略及相应策略的各项参数如下： <ul>
<li>串行收集器（JDK1.5以前主要的回收方式） ：-XX:+UseSerialGC:设置串行收集器 </li>
<li>并行收集器（吞吐量优先） <ul>
<li>示例： java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis&#x3D;100 </li>
<li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 </li>
<li>-XX:ParallelGCThreads&#x3D;20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 </li>
<li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集 </li>
<li>-XX:MaxGCPauseMillis&#x3D;100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 </li>
<li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li>
</ul>
</li>
<li>并发收集器（响应时间优先） <ul>
<li>示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC </li>
<li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio&#x3D;4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。 </li>
<li>-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 </li>
<li>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 </li>
<li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="共享session处理"><a href="#共享session处理" class="headerlink" title="共享session处理"></a>共享session处理</h1><h4 id="使用Tomcat本身的Session复制功能"><a href="#使用Tomcat本身的Session复制功能" class="headerlink" title="使用Tomcat本身的Session复制功能"></a>使用Tomcat本身的Session复制功能</h4><ul>
<li>方案的有点是配置简单，缺点是当集群数量较多时，Session复制的时间会比较长，影响响应的效率</li>
</ul>
<h4 id="使用第三方来存放共享Session"><a href="#使用第三方来存放共享Session" class="headerlink" title="使用第三方来存放共享Session"></a>使用第三方来存放共享Session</h4><ul>
<li>目前用的较多的是使用memcached来管理共享Session，借助于memcached-sesson-manager来进行Tomcat的Session管理</li>
</ul>
<h4 id="使用黏性session的策略"><a href="#使用黏性session的策略" class="headerlink" title="使用黏性session的策略"></a>使用黏性session的策略</h4><ul>
<li>对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同一个用户的session可以由nginx或者apache交给同一个Tomcat来处理，这就是所谓的session sticky策略，目前应用也比较多 </li>
<li>nginx默认不包含session sticky模块，需要重新编译才行（windows下我也不知道怎么重新编译） </li>
<li>优点是处理效率高多了，缺点是强会话要求的场合不合适</li>
</ul>
<h1 id="添加JMS远程监控"><a href="#添加JMS远程监控" class="headerlink" title="添加JMS远程监控"></a>添加JMS远程监控</h1><ul>
<li>对于部署在局域网内其它机器上的Tomcat，可以打开JMX监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在JVM启动参数中配置即可，配置如下： <ul>
<li>-Dcom.sun.management.jmxremote.ssl&#x3D;false  -Dcom.sun.management.jmxremote.authenticate&#x3D;false </li>
<li>-Djava.rmi.server.hostname&#x3D;192.168.71.38 设置JVM的JMS监控监听的IP地址，主要是为了防止错误的监听成127.0.0.1这个内网地址 </li>
<li>-Dcom.sun.management.jmxremote.port&#x3D;1090 设置JVM的JMS监控的端口 </li>
<li>-Dcom.sun.management.jmxremote.ssl&#x3D;false 设置JVM的JMS监控不实用SSL </li>
<li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false 设置JVM的JMS监控不需要认证</li>
</ul>
</li>
</ul>
<h1 id="专业点的分析工具有"><a href="#专业点的分析工具有" class="headerlink" title="专业点的分析工具有"></a>专业点的分析工具有</h1><ul>
<li>IBM ISA，JProfiler、probe 等，具体监控及分析方式去网上搜索即可</li>
</ul>
<h1 id="关于Tomcat的session数目"><a href="#关于Tomcat的session数目" class="headerlink" title="关于Tomcat的session数目"></a>关于Tomcat的session数目</h1><ul>
<li>这个可以直接从Tomcat的web管理界面去查看即可；</li>
<li>或者借助于第三方工具Lambda Probe来查看，它相对于Tomcat自带的管理稍微多了点功能，但也不多 ；</li>
</ul>
<h1 id="监视Tomcat的内存使用情况"><a href="#监视Tomcat的内存使用情况" class="headerlink" title="监视Tomcat的内存使用情况"></a>监视Tomcat的内存使用情况</h1><ul>
<li>使用JDK自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等；</li>
<li>JDK自带的jvisualvm可以下载插件（如GC等），可以查看更丰富的信息。如果是分析本地的Tomcat的话，还可以进行内存抽样等，检查每个类的使用情况</li>
</ul>
<h1 id="打印类的加载情况及对象的回收情况"><a href="#打印类的加载情况及对象的回收情况" class="headerlink" title="打印类的加载情况及对象的回收情况"></a>打印类的加载情况及对象的回收情况</h1><ul>
<li>这个可以通过配置JVM的启动参数，打印这些信息（到屏幕（默认也会到catalina.log中）或者文件），具体参数如下： <ul>
<li>-XX:+PrintGC：输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] </li>
<li>-XX:+PrintGCDetails：输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] </li>
<li>-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用，输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] </li>
<li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds </li>
<li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds </li>
<li>-XX:PrintHeapAtGC: 打印GC前后的详细堆栈信息 </li>
<li>-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析 </li>
<li>-verbose:class 监视加载的类的情况 </li>
<li>-verbose:gc 在虚拟机发生内存回收时在输出设备显示信息 </li>
<li>-verbose:jni 输出native方法调用的相关情况，一般用于诊断jni调用错误信息</li>
</ul>
</li>
</ul>
<h1 id="Tomcat一个请求的完整过程"><a href="#Tomcat一个请求的完整过程" class="headerlink" title="Tomcat一个请求的完整过程"></a>Tomcat一个请求的完整过程</h1><ul>
<li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP&#x2F;1.1 Connector获得 </li>
<li>Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应 </li>
<li>Engine获得请求localhost&#x2F;yy&#x2F;index.jsp，匹配它所拥有的所有虚拟主机Host </li>
<li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机） </li>
<li>localhost Host获得请求&#x2F;yy&#x2F;index.jsp，匹配它所拥有的所有Context </li>
<li>Host匹配到路径为&#x2F;yy的Context（如果匹配不到就把该请求交给路径名为”“的Context去处理） </li>
<li>path&#x3D;”&#x2F;yy”的Context获得请求&#x2F;index.jsp，在它的mapping table中寻找对应的servlet </li>
<li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类 </li>
<li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法 </li>
<li>Context把执行完了之后的HttpServletResponse对象返回给Host </li>
<li>Host把HttpServletResponse对象返回给Engine </li>
<li>Engine把HttpServletResponse对象返回给Connector </li>
<li>Connector把HttpServletResponse对象返回给客户browser</li>
</ul>
<h1 id="Tomcat工作模式？"><a href="#Tomcat工作模式？" class="headerlink" title="Tomcat工作模式？"></a>Tomcat工作模式？</h1><ul>
<li>Tomcat是一个JSP&#x2F;Servlet容器</li>
<li>其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</li>
<li>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：<ul>
<li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li>
<li>Tomcat作为独立服务器：请求来自于web浏览器；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/publishes/1e7ca447b43e.html</url>
    <content><![CDATA[<h1 id="高并发原则"><a href="#高并发原则" class="headerlink" title="高并发原则"></a>高并发原则</h1><ul>
<li>⽆状态<ul>
<li>⽆状态应⽤，便于⽔平扩展</li>
<li>有状态配置可通过配置中⼼实现⽆状态</li>
<li>实践: Disconf、Yaconf、Zookpeer、Consul、Confd、Diamond、Xdiamond等</li>
</ul>
</li>
<li>拆分<ul>
<li>系统维度：按照系统功能、业务拆分，如购物⻋，结算，订单等</li>
<li>功能维度：对系统功能在做细粒度拆分</li>
<li>读写维度：根据读写⽐例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表</li>
<li>AOP维度： 根据访问特征，按照AOP进⾏拆分，⽐如商品⻚可分为CDN、⻚⾯渲染系统，CDN就是⼀个AOP系统</li>
<li>模块维度：对整体代码结构划分Web、Service、DAO</li>
</ul>
</li>
<li>服务化<ul>
<li>服务化演进: 进程内服务-单机远程服务-集群⼿动注册服务-⾃动注册和发现服务-服务的分组、隔离、路由-服务治理</li>
<li>考虑服务分组、隔离、限流、⿊⽩名单、超时、重试机制、路由、故障补偿等</li>
<li>实践：利⽤Nginx、HaProxy、LVS等实现负载均衡，ZooKeeper、Consul等实现⾃动注册和发现服</li>
</ul>
</li>
<li>消息队列<ul>
<li>⽬的: 服务解耦(⼀对多消费)、异步处理、流量削峰缓冲等</li>
<li>⼤流量缓冲： 牺牲强⼀致性，保证最终⼀致性(案例：库存扣减，现在Redis中做扣减，记录扣减⽇志，通过后台进程将扣减⽇志应⽤到DB)</li>
<li>数据校对: 解决异步消息机制下消息丢失问题</li>
</ul>
</li>
<li>数据异构<ul>
<li>数据异构: 通过消息队列机制接收数据变更，原⼦化存储</li>
<li>数据闭环: 屏蔽多从数据来源，将数据异构存储，形成闭环</li>
</ul>
</li>
<li>缓存银弹<ul>
<li>⽤户层:<ul>
<li>DNS缓存</li>
<li>浏览器DNS缓存</li>
<li>操作系统DNS缓存</li>
<li>本地DNS服务商缓存</li>
<li>DNS服务器缓存</li>
<li>客户端缓存<ul>
<li>浏览器缓存(Expires、Cache-Control、Last-Modified、Etag)* App</li>
<li>客户缓存(js&#x2F;css&#x2F;image…)</li>
</ul>
</li>
</ul>
</li>
<li>代理层：<ul>
<li>CDN缓存(⼀般基于ATS、Varnish、Nginx、Squid等构建,边缘节点-⼆级节点-中⼼节点-源站)</li>
</ul>
</li>
<li>接⼊层：<ul>
<li>Nginx为例：<ul>
<li>Proxy_cache： 代理缓存,可以存储到&#x2F;dev&#x2F;shm或者SSD</li>
<li>FastCGI Cache</li>
<li>Nginx+Lua+Redis: 业务数据缓存</li>
</ul>
</li>
<li>PHP为例：<ul>
<li>Opcache： 缓存PHP的Opcodes</li>
</ul>
</li>
</ul>
</li>
<li>应⽤层：<ul>
<li>⻚⾯静态化</li>
<li>业务数据缓存(Redis&#x2F;Memcached&#x2F;本地⽂件等)</li>
<li>消息队列</li>
</ul>
</li>
<li>数据层：<ul>
<li>NoSQL： Redis、Memcache、SSDB等</li>
<li>MySQL： Innodb&#x2F;MyISAM等Query Cache、Key Cache、Innodb</li>
<li>Buffer Size等</li>
</ul>
</li>
<li>系统层：<ul>
<li>CPU : L1&#x2F;L2&#x2F;L3 Cache&#x2F;NUMA</li>
<li>内存</li>
<li>磁盘：磁盘本身缓存、dirty_ratio&#x2F;dirty_background_ratio、阵列卡本身缓存</li>
<li>并发化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="⾼可⽤原则"><a href="#⾼可⽤原则" class="headerlink" title="⾼可⽤原则"></a>⾼可⽤原则</h1><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><ul>
<li>降级开关集中化管理：将开关配置信息推送到各个应⽤</li>
<li>可降级的多级读服务：如服务调⽤降级为只读本地缓存</li>
<li>开关前置化：如Nginx+lua(OpenResty)配置降级策略，引流流量；可基于此做灰度策略</li>
<li>业务降级：⾼并发下，保证核⼼功能，次要功能可由同步改为异步策略或屏蔽功能</li>
</ul>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><ul>
<li>⽬的: 防⽌恶意请求攻击或超出系统峰值</li>
<li>实践：<ul>
<li>恶意请求流量只访问到Cache</li>
<li>穿透后端应⽤的流量使⽤Nginx的limit处理</li>
<li>恶意IP使⽤Nginx Deny策略或者iptables拒绝</li>
</ul>
</li>
</ul>
<h2 id="切流量"><a href="#切流量" class="headerlink" title="切流量"></a>切流量</h2><ul>
<li>⽬的：屏蔽故障机器</li>
<li>实践:<ul>
<li>DNS: 更改域名解析⼊⼝，如DNSPOD可以添加备⽤IP，正常IP故障时，会⾃主切换到备⽤地址;⽣效实践较慢</li>
<li>HttpDNS: 为了绕过运营商LocalDNS实现的精准流量调度</li>
<li>LVS&#x2F;HaProxy&#x2F;Nginx: 摘除故障节点</li>
</ul>
</li>
</ul>
<h2 id="可回滚"><a href="#可回滚" class="headerlink" title="可回滚"></a>可回滚</h2><ul>
<li>发布版本失败时可随时快速回退到上⼀个稳定版本</li>
</ul>
<h1 id="业务设计原则"><a href="#业务设计原则" class="headerlink" title="业务设计原则"></a>业务设计原则</h1><ul>
<li>防重设计</li>
<li>幂等设计</li>
<li>流程定义</li>
<li>状态与状态机</li>
<li>后台系统操作可反馈</li>
<li>后台系统审批化</li>
<li>⽂档注释</li>
<li>备份</li>
</ul>
<h1 id="分布式与集群的区别"><a href="#分布式与集群的区别" class="headerlink" title="分布式与集群的区别"></a>分布式与集群的区别</h1><ul>
<li>分布式是指将不同的业务分布在不同的地⽅</li>
<li>⽽集群指的是将⼏台服务器集中在⼀起，实现同⼀业务</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="⼆阶段提交"><a href="#⼆阶段提交" class="headerlink" title="⼆阶段提交"></a>⼆阶段提交</h2><ul>
<li>概念：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中⽌操作。</li>
<li>作⽤：主要保证了分布式事务的原⼦性；第⼀阶段为准备阶段，第⼆阶段为提交阶段；</li>
<li>缺点：不仅要锁住参与者的所有资源，⽽且要锁住协调者资源，开销⼤。⼀句话总结就是：2PC效率很低，对⾼并发很不友好。</li>
</ul>
<h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><ul>
<li>概念：三阶段提交协议在协调者和参与者中都引⼊超时机制，并且把两阶段提交协议的第⼀个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</li>
<li>缺点：如果进⼊PreCommit后，Coordinator发出的是abort请求，假设只有⼀个Cohort收到并进⾏了abort操作，⽽其他对于系统状态未知的Cohort会根据3PC选择继续Commit，此时系统状态发⽣不⼀致性。</li>
</ul>
<h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><ul>
<li>概念：所谓柔性事务是相对强制锁表的刚性事务⽽⾔。流程⼊下：服务器A的事务如果执⾏顺利，那么事务A就先⾏提交，如果事务B也执⾏顺利，则事务B也提交，整个事务就算完成。但是如果事务B执⾏失败，事务B本身回滚，这时事务A已经被提交，所以需要执⾏⼀个补偿操作，将已经提交的事务A执⾏的操作作反操作，恢复到未执⾏前事务A的状态。</li>
<li>缺点：业务侵⼊性太强，还要补偿操作，缺乏普遍性，没法⼤规模推⼴。</li>
</ul>
<h1 id="消息最终⼀致性解决⽅案之RabbitMQ实现："><a href="#消息最终⼀致性解决⽅案之RabbitMQ实现：" class="headerlink" title="消息最终⼀致性解决⽅案之RabbitMQ实现："></a>消息最终⼀致性解决⽅案之RabbitMQ实现：</h1><ul>
<li>实现：发送⽅确认+消息持久化+消费者确认。</li>
</ul>
<h1 id="什么时候⽤到分布式开发："><a href="#什么时候⽤到分布式开发：" class="headerlink" title="什么时候⽤到分布式开发："></a>什么时候⽤到分布式开发：</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>模块解耦：把模块拆分,使⽤接⼝通信,降低模块之间的耦合度.</li>
<li>项⽬拆分，不同团队负责不同的⼦项⽬：把项⽬拆分成若⼲个⼦项⽬,不同的团队负责不同的⼦项⽬.</li>
<li>提⾼项⽬扩展性：增加功能时只需要再增加⼀个⼦项⽬,调⽤其他系统的接⼝就可以。</li>
<li>分布式部署：可以灵活的进⾏分布式部署.</li>
<li>提⾼代码的复⽤性：⽐如service层,如果不采⽤分布式rest服务⽅式架构就会在⼿机wap商城,信商城,pc,android，ios每个端都要写⼀个service层逻辑,开发量⼤,难以维护⼀起升级,这时候可以采⽤分布式rest服务⽅式,公⽤⼀个service层。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>系统之间的交互要使⽤远程通信,接⼝开发增⼤⼯作量；</li>
<li>⽹络请求有延时；</li>
<li>事务处理⽐较麻烦，需要使⽤分布式事务。</li>
</ul>
<h1 id="cdn（异地多活）"><a href="#cdn（异地多活）" class="headerlink" title="cdn（异地多活）"></a>cdn（异地多活）</h1><h2 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h2><ul>
<li>异地多活指分布在异地的多个站点同时对外提供服务的业务场景。异地多活是⾼可⽤架构设计的⼀种，与传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。</li>
<li>两地容灾切换⽅案：容灾是异地多活中最核⼼的⼀环， 以两个城市异地多活部署架构图为例，在两个城市（城市1位于华南1地域、城市2位于华东1地域）均部署⼀套完整的业务系统。下单业务按照“user_id”％ 100 进⾏分⽚，在正常情况下：<ul>
<li>[00~49]分⽚所有的读写都在城市1的数据库实例主库。</li>
<li>[50～99]分⽚所有的读写都在城市2的数据库实例主库。</li>
<li>“城市1的数据库实例主库”和 “城市2的数据库实例主库”建⽴DTS双向复制。</li>
<li>当出现异常时，需要进⾏容灾切换。可能出现的场景有以下4种：<ul>
<li>将第2种、第3种异常情况，全部采⽤第2种⽅案进⾏处理，那么不管是所有的APP Server异常、所有的数据库异常、整个城市异常，就直接按照城市级容灾⽅案处理，直接将APP Server、数据库切换到到另⼀个城市。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="多城异地多活"><a href="#多城异地多活" class="headerlink" title="多城异地多活"></a>多城异地多活</h2><ul>
<li>多城市异地多活模式指的是3个或者3个以上城市间部署异地多活</li>
<li>该模式下存在中⼼节点和单元节点：<ul>
<li>中⼼节点：指单元节点的增量数据都需要实时的同步到中⼼节点，同时中⼼节点将所有分⽚的增量数据同步到其他单元节点。</li>
<li>单元节点：即对应分⽚读写的节点，该节点需要将该分⽚的增量同步到中⼼节点，并且接收来⾃于中⼼节点的其他分⽚的增量数据。</li>
</ul>
</li>
</ul>
<h1 id="分布式环境下宕机的处理⽅案"><a href="#分布式环境下宕机的处理⽅案" class="headerlink" title="分布式环境下宕机的处理⽅案"></a>分布式环境下宕机的处理⽅案</h1><ul>
<li>dubbo：服务器宕机，zk临时被删除；</li>
<li>springcloud：每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。</li>
<li>apm监控</li>
</ul>
<h1 id="分布式、高并发、多线程，到底有什么区别？"><a href="#分布式、高并发、多线程，到底有什么区别？" class="headerlink" title="分布式、高并发、多线程，到底有什么区别？"></a>分布式、高并发、多线程，到底有什么区别？</h1><ul>
<li>当提起这三个词的时候，是不是很多人都认为分布式&#x3D;高并发&#x3D;多线程？</li>
<li>在一开始接触的时候，不少人都会将三者混淆，误以为所谓的分布式高并发的系统就是能同时供海量用户访问，而采用多线程手段不就是可以提供系统的并发能力吗</li>
<li>实际上，他们三个总是相伴而生，但侧重点又有不同</li>
</ul>
<h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><ul>
<li>分布式更多的一个概念，是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段</li>
<li>该领域需要解决的问题极多，在不同的技术层面上，又包括：分布式文件系统、分布式缓存、分布式数据库、分布式计算等，一些名词如Hadoop、zookeeper、MQ等都跟分布式有关</li>
<li>从理念上讲，分布式的实现有两种形式：<ul>
<li>水平扩展：当一台机器扛不住流量时，就通过添加机器的方式，将流量平分到所有服务器上，所有机器都可以提供相当的服务；</li>
<li>垂直拆分：前端有多种查询需求时，一台机器扛不住，可以将不同的需求分发到不同的机器上，比如A机器处理余票查询的请求，B机器处理支付的请求。</li>
</ul>
</li>
</ul>
<h2 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h2><ul>
<li>相对于分布式来讲，高并发在解决的问题上会集中一些，其反应的是同时有多少量：比如在线直播服务，同时有上万人观看</li>
<li>高并发可以通过分布式技术去解决，将并发流量分不到不同的物理服务器上</li>
<li>但除此之外，还可以有很多其他优化手段：比如使用缓存系统，将所有的，静态内容放到CDN等；还可以使用多线程技术将一台服务器的服务能力最大化。</li>
</ul>
<h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><ul>
<li>多线程是指从软件或者硬件上实现多个线程并发执行的技术</li>
<li>它更多的是解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行（实际是交替运行的）</li>
<li>多线程解决的问题是最明确的，手段也是比较单一的，基本上遇到的最大问题就是线程安全</li>
<li>在JAVA语言中，需要对JVM内存模型、指令重排等深入了解，才能写出一份高质量的多线程代码。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>分布式是从物理资源的角度去将不同的机器组成一个整体对外服务，技术范围非常广且难度非常大，有了这个基础，高并发、高吞吐等系统很容易构建；</li>
<li>高并发是从业务角度去描述系统的能力，实现高并发的手段可以采用分布式，也可以采用诸如缓存、CDN等，当然也包括多线程；</li>
<li>多线程则聚焦于如何使用编程语言将CPU调度能力最大化</li>
</ul>
<h1 id="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"><a href="#分布式服务接口的幂等性如何设计（比如不能重复扣款）？" class="headerlink" title="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"></a>分布式服务接口的幂等性如何设计（比如不能重复扣款）？</h1><ul>
<li>这个不是技术问题，这个没有通用的一个方法，这个应该结合业务来保证幂等性。</li>
<li>所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</li>
<li>其实保证幂等性主要是三点：<ul>
<li>对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单id，一个订单 id 最多支付一次。</li>
<li>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql中记录个状态，比如支付之前记录一条这个订单的支付流水。</li>
<li>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。</li>
</ul>
</li>
<li>实际运作过程中，你要结合自己的业务来，比如说利用 redis，用 orderId作为唯一键</li>
<li>只有成功插入这个支付流水，才可以执行实际的支付扣款。</li>
<li>要求是支付一个订单，必须插入一条支付流水，<code>order_id</code> 建一个唯一键unique key。你在支付一个订单之前，先插入一条支付流水，<code>order_id</code>就已经进去了。你就可以写一个标识到 redis 里面去，<code>set order_id payed</code>，下一次重复请求过来了，先查 redis 的 order_id 对应的 value，如果是payed就说明已经支付过了，你就别重复支付了。</li>
</ul>
<h1 id="分布式事务了解吗？你们是如何解决分布式事务问题的？"><a href="#分布式事务了解吗？你们是如何解决分布式事务问题的？" class="headerlink" title="分布式事务了解吗？你们是如何解决分布式事务问题的？"></a>分布式事务了解吗？你们是如何解决分布式事务问题的？</h1><ul>
<li>分布式事务的实现主要有以下 5 种方案：</li>
<li>XA 方案</li>
<li>TCC 方案</li>
<li>本地消息表</li>
<li>可靠消息最终一致性方案</li>
<li>最大努力通知方案</li>
</ul>
<h2 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案&#x2F;XA方案"></a>两阶段提交方案&#x2F;XA方案</h2><ul>
<li>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</li>
<li>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。</li>
<li>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</li>
<li>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</li>
<li>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</li>
<li>distributed-transacion-XA</li>
</ul>
<h2 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h2><ul>
<li>TCC 的全称是：Try、Confirm、Cancel。<ul>
<li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。</li>
<li>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。</li>
<li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li>
</ul>
</li>
<li>这种方案说实话几乎很少人使用，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大。</li>
<li>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</li>
<li>而且最好是你的各个业务执行的时间都比较短。</li>
<li>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</li>
<li>distributed-transacion-TCC</li>
</ul>
<h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><ul>
<li>本地消息表其实是国外的 ebay 搞出来的这么一套思想。这个大概意思是这样的：<ul>
<li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li>
<li>接着 A 系统将这个消息发送到 MQ 中去；</li>
<li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</li>
<li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li>
<li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li>
<li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B那边成功为止。</li>
</ul>
</li>
<li>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</li>
<li>distributed-transaction-local-message-table</li>
</ul>
<h2 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h2><ul>
<li>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ就支持消息事务。大概的意思就是：<ul>
<li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared消息发送失败那么就直接取消操作别执行了；</li>
<li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li>
<li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li>
<li>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li>
</ul>
</li>
<li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿。</li>
<li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用RocketMQ支持的，要不你就自己基于类似ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li>
<li>distributed-transaction-reliable-message</li>
</ul>
<h2 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h2><ul>
<li>这个方案的大致意思就是：<ul>
<li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li>
<li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li>
<li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li>
</ul>
</li>
</ul>
<h2 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h2><ul>
<li>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性</li>
<li>然后其他的一些场景基于阿里的 RocketMQ 来实现了分布式事务。</li>
<li>找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案</li>
<li>如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</li>
</ul>
<h1 id="分步式锁"><a href="#分步式锁" class="headerlink" title="分步式锁"></a>分步式锁</h1><ul>
<li>基本原理：⽤⼀个状态值表示锁，对锁的占⽤和释放通过状态值来标识。</li>
</ul>
<h2 id="三种分布式锁："><a href="#三种分布式锁：" class="headerlink" title="三种分布式锁："></a>三种分布式锁：</h2><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li>基于zookeeper瞬时有序节点实现的分布式锁</li>
<li>⼤致思想即为：每个客户端对某个功能加锁时，在zookeeper上的与该功能对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点</li>
<li>判断是否获取锁的⽅式很简单，只需要判断有序节点中序号最⼩的⼀个</li>
<li>当释放锁的时候，只需将这个瞬时节点删除即可</li>
<li>同时，其可以避免服务宕机导致的锁⽆法释放，⽽产⽣的死锁问题。</li>
<li>优点<ul>
<li>锁安全性⾼，zk可持久化，且能实时监听获取锁的客户端状态</li>
<li>⼀旦客户端宕机，则瞬时节点随之消失，zk因⽽能第⼀时间释放锁</li>
<li>这也省去了⽤分布式缓存实现锁的过程中需要加⼊超时时间判断的这⼀逻辑。</li>
</ul>
</li>
<li>缺点<ul>
<li>性能开销⽐较⾼</li>
<li>因为其需要动态产⽣、销毁瞬时节点来实现锁功能</li>
<li>所以不太适合直接提供给⾼并发的场景使⽤</li>
</ul>
</li>
<li>实现<ul>
<li>可以直接采⽤zookeeper第三⽅库curator即可⽅便地实现分布式锁</li>
</ul>
</li>
<li>适⽤场景<ul>
<li>对可靠性要求⾮常⾼，且并发程度不⾼的场景下使⽤</li>
<li>如核⼼数据的定时全量&#x2F;增量同步等。</li>
</ul>
</li>
</ul>
<h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><ul>
<li>memcached带有add函数，利⽤add函数的特性即可实现分布式锁</li>
<li>add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。⽽add的话则相反，add会添加第⼀个到达的值，并返回true，后续的添加则都会返回false。利⽤该点即可很轻松地实现分布式锁。</li>
<li>优点：并发⾼效</li>
<li>缺点<ul>
<li>memcached采⽤列⼊LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。</li>
<li>memcached⽆法持久化，⼀旦重启，将导致信息丢失。</li>
</ul>
</li>
<li>使⽤场景<ul>
<li>⾼并发场景。需要<ul>
<li>加上超时时间避免死锁</li>
<li>提供⾜够⽀撑锁服务的内存空间</li>
<li>稳定的集群化管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul>
<li>redis分布式锁即可以结合zk分布式锁锁⾼度安全和memcached并发场景下效率很好的优点</li>
<li>其实现⽅式和memcached类似，采⽤setnx即可实现</li>
<li>需要注意的是，这⾥的redis也需要设置超时时间，以避免死锁。</li>
</ul>
<h1 id="你还了解别的分布式框架吗？"><a href="#你还了解别的分布式框架吗？" class="headerlink" title="你还了解别的分布式框架吗？"></a>你还了解别的分布式框架吗？</h1><ul>
<li>别的还有 spring 的 spring cloud，facebook 的 thrift，twitter 的 finagle 等</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/publishes/554d7a59d68c.html</url>
    <content><![CDATA[<h1 id="zookeeper-都有哪些使用场景？"><a href="#zookeeper-都有哪些使用场景？" class="headerlink" title="zookeeper 都有哪些使用场景？"></a>zookeeper 都有哪些使用场景？</h1><ul>
<li>大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：<ul>
<li>分布式协调</li>
<li>分布式锁</li>
<li>元数据&#x2F;配置信息管理</li>
<li>HA高可用性</li>
</ul>
</li>
</ul>
<h4 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h4><ul>
<li>这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</li>
</ul>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul>
<li>对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</li>
</ul>
<h4 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据&#x2F;配置信息管理"></a>元数据&#x2F;配置信息管理</h4><ul>
<li>ookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？</li>
</ul>
<h4 id="HA高可用性"><a href="#HA高可用性" class="headerlink" title="HA高可用性"></a>HA高可用性</h4><ul>
<li>这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个重要进程一般会做主备两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。</li>
</ul>
<h1 id="什么是-ZooKeeper"><a href="#什么是-ZooKeeper" class="headerlink" title="什么是 ZooKeeper"></a>什么是 ZooKeeper</h1><h4 id="ZooKeeper-的由来"><a href="#ZooKeeper-的由来" class="headerlink" title="ZooKeeper 的由来"></a>ZooKeeper 的由来</h4><ul>
<li>Zookeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。</li>
</ul>
<h4 id="ZooKeeper-概览"><a href="#ZooKeeper-概览" class="headerlink" title="ZooKeeper 概览"></a>ZooKeeper 概览</h4><ul>
<li>ZooKeeper 是一个开源的分布式协调服务，ZooKeeper框架最初是在“Yahoo!”上构建的，用于以简单而稳健的方式访问他们的应用程序。 后来，Apache ZooKeeper成为Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 例如，Apache HBase使用ZooKeeper跟踪分布式数据的状态</li>
<li>ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</li>
<li>原语： 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</li>
<li>ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</li>
<li>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。</li>
</ul>
<h4 id="结合个人使用情况的讲一下-ZooKeeper"><a href="#结合个人使用情况的讲一下-ZooKeeper" class="headerlink" title="结合个人使用情况的讲一下 ZooKeeper"></a>结合个人使用情况的讲一下 ZooKeeper</h4><ul>
<li>在我自己做过的项目中，主要使用到了 ZooKeeper 作为 Dubbo 的注册中心(Dubbo 官方推荐使用 ZooKeeper注册中心)。</li>
<li>另外在搭建 solr 集群的时候，我使用 ZooKeeper 作为 solr 集群的管理工具。这时，ZooKeeper 主要提供下面几个功能：<ul>
<li>集群管理：容错、负载均衡</li>
<li>配置文件的集中管理</li>
<li>集群的入口</li>
</ul>
</li>
<li>我个人觉得在使用 ZooKeeper 的时候，最好是使用 集群版的 ZooKeeper 而不是单机版的。官网给出的架构图就描述的是一个集群版的 ZooKeeper 。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。</li>
</ul>
<h1 id="为什么最好使用奇数台服务器构成-ZooKeeper-集群？"><a href="#为什么最好使用奇数台服务器构成-ZooKeeper-集群？" class="headerlink" title="为什么最好使用奇数台服务器构成 ZooKeeper 集群？"></a>为什么最好使用奇数台服务器构成 ZooKeeper 集群？</h1><ul>
<li>我们知道在Zookeeper中 Leader 选举算法采用了Zab协议</li>
<li>Zab核心思想是当多数 Server 写成功，则任务数据写成功<ul>
<li>如果有3个Server，则最多允许1个Server 挂掉。</li>
<li>如果有4个Server，则同样最多允许1个Server挂掉。</li>
<li>既然3个或者4个Server，同样最多允许1个Server挂掉，那么它们的可靠性是一样的，所以选择奇数个ZooKeeper Server即可，这里选择3个Server。</li>
</ul>
</li>
</ul>
<h1 id="关于-ZooKeeper-的一些重要概念"><a href="#关于-ZooKeeper-的一些重要概念" class="headerlink" title="关于 ZooKeeper 的一些重要概念"></a>关于 ZooKeeper 的一些重要概念</h1><h4 id="重要概念总结"><a href="#重要概念总结" class="headerlink" title="重要概念总结"></a>重要概念总结</h4><ul>
<li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li>
<li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li>
<li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。</li>
<li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li>
<li>ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。</li>
<li>ZooKeeper 底层其实只提供了两个功能：<ul>
<li>管理（存储、读取）用户程序提交的数据；</li>
<li>为用户程序提交数据节点监听服务。</li>
</ul>
</li>
</ul>
<h4 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h4><ul>
<li>Session 指的是 ZooKeeper 服务器与客户端会话</li>
<li>在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接</li>
<li>客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</li>
<li>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</li>
</ul>
<h4 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h4><ul>
<li>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然而，在Zookeeper中，“节点”分为两类<ul>
<li>第一类同样是指构成集群的机器，我们称之为机器节点</li>
<li>第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</li>
</ul>
</li>
<li>Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree），由斜杠（&#x2F;）的进行分割的路径，就是一个Znode，例如&#x2F;foo&#x2F;path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</li>
<li>在Zookeeper中，node可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</li>
</ul>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><ul>
<li>在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 cversion（当前ZNode的ACL版本）。</li>
</ul>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><ul>
<li>Watcher（事件监听器），是Zookeeper中的一个很重要的特性</li>
<li>Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。</li>
</ul>
<h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><ul>
<li>Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</li>
<li>Zookeeper 定义了5种权限。</li>
<li>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</li>
</ul>
<h1 id="ZooKeeper-特点"><a href="#ZooKeeper-特点" class="headerlink" title="ZooKeeper 特点"></a>ZooKeeper 特点</h1><ul>
<li>顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>
<li>原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li>单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li>可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ul>
<h1 id="ZooKeeper-设计目标"><a href="#ZooKeeper-设计目标" class="headerlink" title="ZooKeeper 设计目标"></a>ZooKeeper 设计目标</h1><h4 id="简单的数据模型"><a href="#简单的数据模型" class="headerlink" title="简单的数据模型"></a>简单的数据模型</h4><ul>
<li>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似</li>
<li>名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录</li>
<li>与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。</li>
</ul>
<h4 id="可构建集群"><a href="#可构建集群" class="headerlink" title="可构建集群"></a>可构建集群</h4><ul>
<li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的</li>
<li>客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。</li>
<li>组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信</li>
<li>集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。</li>
</ul>
<h4 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h4><ul>
<li>对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。这个编号也叫做时间戳——zxid（Zookeeper Transaction Id）</li>
</ul>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><ul>
<li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li>
</ul>
<h1 id="ZooKeeper-集群角色介绍"><a href="#ZooKeeper-集群角色介绍" class="headerlink" title="ZooKeeper 集群角色介绍"></a>ZooKeeper 集群角色介绍</h1><ul>
<li>最典型集群模式： Master&#x2F;Slave 模式（主备模式）。在这种模式中，通常 Master服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</li>
<li>在 ZooKeeper 中没有选择传统的 Master&#x2F;Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色。</li>
<li>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器</li>
<li>Leader 既可以为客户端提供写服务又能提供读服务</li>
<li>除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</li>
</ul>
<h1 id="ZooKeeper-ZAB-协议-Paxos算法"><a href="#ZooKeeper-ZAB-协议-Paxos算法" class="headerlink" title="ZooKeeper &amp;ZAB 协议&amp;Paxos算法"></a>ZooKeeper &amp;ZAB 协议&amp;Paxos算法</h1><h4 id="ZAB-协议-Paxos算法"><a href="#ZAB-协议-Paxos算法" class="headerlink" title="ZAB 协议&amp;Paxos算法"></a>ZAB 协议&amp;Paxos算法</h4><ul>
<li>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</li>
</ul>
<h4 id="ZAB-协议介绍"><a href="#ZAB-协议介绍" class="headerlink" title="ZAB 协议介绍"></a>ZAB 协议介绍</h4><ul>
<li>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议</li>
<li>在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</li>
</ul>
<h4 id="ZAB-协议两种基本的模式：崩溃恢复和消息广播"><a href="#ZAB-协议两种基本的模式：崩溃恢复和消息广播" class="headerlink" title="ZAB 协议两种基本的模式：崩溃恢复和消息广播"></a>ZAB 协议两种基本的模式：崩溃恢复和消息广播</h4><ul>
<li>ZAB协议包括两种基本的模式，分别是 崩溃恢复和消息广播</li>
<li>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器</li>
<li>当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式</li>
<li>其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</li>
<li>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了</li>
<li>当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去</li>
<li>正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理</li>
<li>Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</li>
</ul>
<h1 id="Znode-节点类型有哪些？"><a href="#Znode-节点类型有哪些？" class="headerlink" title="Znode 节点类型有哪些？"></a>Znode 节点类型有哪些？</h1><ul>
<li>PERSISTENT 持久化节点: 所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点。否则不会因为创建该节点的客户端会话失效而消失。</li>
<li>PERSISTENT_SEQUENTIAL 持久顺序节点：这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在 ZK 中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK 会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 在创建节点的时候只需要传入节点 “&#x2F;test_”，这样之后，zookeeper 自动会给”test_”后面补充数字。</li>
<li>EPHEMERAL 临时节点：和持久节点不同的是，临时节点的生命周期和客户端会 话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。这里还要注意一件事，就是当你客户端会话失效后，所产生的节点也不是一下子就消失了，也要过一段时间，大概是 10 秒以内，可以试一下，本机操作生成节点，在服务器端用命令来查看当前的节点数目，你会发现客户端已经 stop，但是产生的节点还在。</li>
<li>EPHEMERAL_SEQUENTIAL 临时自动编号节点：此节点是属于临时节点，不过带有顺序，客户端会话结束节点就消失。</li>
</ul>
<h1 id="什么是-Znode？"><a href="#什么是-Znode？" class="headerlink" title="什么是 Znode？"></a>什么是 Znode？</h1><ul>
<li>在 Zookeeper 中，znode 是一个跟 Unix 文件系统路径相似的节点，可以往这个节点存储或获取数据。</li>
<li>Zookeeper 底层是一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为“znode”</li>
<li>zookeeper 中的数据是按照“树”结构进行存储的。而且 znode 节点还分为 4 中不同的类型。</li>
<li>每一个 znode 默认能够存储 1MB 的数据（对于记录状态性质的数据来说，够了）</li>
<li>可以使用 zkCli 命令，登录到 zookeeper 上，并通过 ls、create、delete、get、set等命令操作这些 znode 节点</li>
</ul>
<h1 id="Zookeeper-的典型应用场景"><a href="#Zookeeper-的典型应用场景" class="headerlink" title="Zookeeper 的典型应用场景"></a>Zookeeper 的典型应用场景</h1><ul>
<li>Zookeeper 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。<br>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：<ul>
<li>数据发布&#x2F;订阅</li>
<li>负载均衡</li>
<li>命名服务</li>
<li>分布式协调&#x2F;通知</li>
<li>集群管理</li>
<li>Master 选举</li>
<li>分布式锁</li>
<li>分布式队列</li>
</ul>
</li>
</ul>
<h1 id="chubby-是什么，和-zookeeper-比你怎么看？"><a href="#chubby-是什么，和-zookeeper-比你怎么看？" class="headerlink" title="chubby 是什么，和 zookeeper 比你怎么看？"></a>chubby 是什么，和 zookeeper 比你怎么看？</h1><ul>
<li>chubby 是 google 的，完全实现 paxos 算法，不开源。zookeeper 是 chubby的开源实现，使用 zab 协议，paxos 算法的变种。</li>
</ul>
<h1 id="Zookeeper-的-java-客户端都有哪些？"><a href="#Zookeeper-的-java-客户端都有哪些？" class="headerlink" title="Zookeeper 的 java 客户端都有哪些？"></a>Zookeeper 的 java 客户端都有哪些？</h1><ul>
<li>java 客户端：zk 自带的 zkclient 及 Apache 开源的 Curator。</li>
</ul>
<h1 id="Zookeeper-对节点的-watch监听通知是永久的吗？为什么不是永久的"><a href="#Zookeeper-对节点的-watch监听通知是永久的吗？为什么不是永久的" class="headerlink" title="Zookeeper 对节点的 watch监听通知是永久的吗？为什么不是永久的?"></a>Zookeeper 对节点的 watch监听通知是永久的吗？为什么不是永久的?</h1><ul>
<li>不是</li>
<li>官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</li>
<li>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。</li>
<li>一般是客户端执行 getData(“&#x2F;节点 A”,true)，如果节点 A 发生了变更或删除，客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没有设置 watch 事件，就不再给客户端发送。</li>
<li>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</li>
</ul>
<h1 id="集群支持动态添加机器吗？"><a href="#集群支持动态添加机器吗？" class="headerlink" title="集群支持动态添加机器吗？"></a>集群支持动态添加机器吗？</h1><ul>
<li>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的<br>会话。</li>
<li>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。</li>
<li>3.5 版本开始支持动态扩容。</li>
</ul>
<h1 id="集群最少要几台机器，集群规则是怎样的"><a href="#集群最少要几台机器，集群规则是怎样的" class="headerlink" title="集群最少要几台机器，集群规则是怎样的?"></a>集群最少要几台机器，集群规则是怎样的?</h1><ul>
<li>集群规则为 2N+1 台，N&gt;0，即 3 台。</li>
</ul>
<h1 id="Zookeeper-有哪几种几种部署模式？"><a href="#Zookeeper-有哪几种几种部署模式？" class="headerlink" title="Zookeeper 有哪几种几种部署模式？"></a>Zookeeper 有哪几种几种部署模式？</h1><ul>
<li>部署模式：单机模式、伪集群模式、集群模式。</li>
</ul>
<h1 id="zookeeper-负载均衡和-nginx-负载均衡区别"><a href="#zookeeper-负载均衡和-nginx-负载均衡区别" class="headerlink" title="zookeeper 负载均衡和 nginx 负载均衡区别"></a>zookeeper 负载均衡和 nginx 负载均衡区别</h1><ul>
<li>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。</li>
</ul>
<h1 id="zk-节点宕机如何处理？"><a href="#zk-节点宕机如何处理？" class="headerlink" title="zk 节点宕机如何处理？"></a>zk 节点宕机如何处理？</h1><ul>
<li>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</li>
<li>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</li>
<li>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</li>
<li>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5) 2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;&#x3D;1)</li>
</ul>
<h1 id="zookeeper-是如何保证事务的顺序一致性的？"><a href="#zookeeper-是如何保证事务的顺序一致性的？" class="headerlink" title="zookeeper 是如何保证事务的顺序一致性的？"></a>zookeeper 是如何保证事务的顺序一致性的？</h1><ul>
<li>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</li>
</ul>
<h1 id="分布式集群中为什么会有-Master？"><a href="#分布式集群中为什么会有-Master？" class="headerlink" title="分布式集群中为什么会有 Master？"></a>分布式集群中为什么会有 Master？</h1><ul>
<li>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行leader 选举。</li>
</ul>
<h1 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h1><ul>
<li>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）回向Leader 服务器进行注册。当 Learner 服务器想 Leader 服务器完成注册后，进入数据同步环节。</li>
<li>数据同步流程：（均以消息传递的方式进行）</li>
<li>Learner 向 Learder 注册</li>
<li>数据同步</li>
<li>同步确认</li>
<li>Zookeeper 的数据同步通常分为四类：<ul>
<li>直接差异化同步（DIFF 同步）</li>
<li>先回滚再差异化同步（TRUNC+DIFF 同步）</li>
<li>仅回滚同步（TRUNC 同步）</li>
<li>全量同步（SNAP 同步）</li>
</ul>
</li>
<li>在进行数据同步前，Leader 服务器会完成数据同步初始化：</li>
<li>peerLastZxid：<ul>
<li>从 learner 服务器注册时发送的 ACKEPOCH 消息中提取 lastZxid（该Learner 服务器最后处理的 ZXID）<br>minCommittedLog：</li>
</ul>
</li>
<li>Leader 服务器 Proposal 缓存队列 committedLog 中最小 ZXID maxCommittedLog：</li>
<li>Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID直接差异化同步（DIFF 同步）</li>
<li>场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog之间</li>
<li>先回滚再差异化同步（TRUNC+DIFF 同步）</li>
<li>场景：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没有的事务记录，那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader</li>
<li>服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID仅回滚同步（TRUNC 同步）</li>
<li>场景：peerLastZxid 大于 maxCommittedLog</li>
<li>全量同步（SNAP 同步）</li>
<li>场景一：peerLastZxid 小于 minCommittedLog</li>
<li>场景二：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等于 lastProcessZxid</li>
</ul>
<h1 id="Zookeeper-下-Server-工作状态"><a href="#Zookeeper-下-Server-工作状态" class="headerlink" title="Zookeeper 下 Server 工作状态"></a>Zookeeper 下 Server 工作状态</h1><ul>
<li>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。<ul>
<li>LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</li>
<li>FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</li>
<li>LEADING：领导者状态。表明当前服务器角色是 Leader。</li>
<li>OBSERVING：观察者状态。表明当前服务器角色是 Observer。</li>
</ul>
</li>
</ul>
<h1 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h1><h4 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h4><ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各服务的调度者</li>
</ul>
<h4 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h4><ul>
<li>处理客户端的非事务请求，转发事务请求给 Leader 服务器</li>
<li>参与事务请求 Proposal 的投票</li>
<li>参与 Leader 选举投票</li>
</ul>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><ul>
<li>3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</li>
<li>处理客户端的非事务请求，转发事务请求给 Leader 服务器</li>
<li>不参与任何形式的投票</li>
</ul>
<h1 id="ZooKeeper-提供了什么？"><a href="#ZooKeeper-提供了什么？" class="headerlink" title="ZooKeeper 提供了什么？"></a>ZooKeeper 提供了什么？</h1><ul>
<li>文件系统</li>
<li>通知机制</li>
</ul>
<h1 id="Zookeeper-文件系统"><a href="#Zookeeper-文件系统" class="headerlink" title="Zookeeper 文件系统"></a>Zookeeper 文件系统</h1><ul>
<li>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</li>
<li>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。</li>
</ul>
<h1 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h1><ul>
<li>PERSISTENT-持久节点<ul>
<li>除非手动删除，否则节点一直存在于 Zookeeper 上</li>
</ul>
</li>
<li>EPHEMERAL-临时节点<ul>
<li>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</li>
</ul>
</li>
<li>PERSISTENT_SEQUENTIAL-持久顺序节点<ul>
<li>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li>
</ul>
</li>
<li>EPHEMERAL_SEQUENTIAL-临时顺序节点<ul>
<li>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li>
</ul>
</li>
</ul>
<h1 id="客户端注册-Watcher-实现"><a href="#客户端注册-Watcher-实现" class="headerlink" title="客户端注册 Watcher 实现"></a>客户端注册 Watcher 实现</h1><ul>
<li>调用 getData()&#x2F;getChildren()&#x2F;exist()三个 API，传入 Watcher 对象</li>
<li>标记请求 request，封装 Watcher 到 WatchRegistration</li>
<li>封装成 Packet 对象，发服务端发送 request</li>
<li>收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理</li>
<li>请求返回，完成注册。</li>
</ul>
<h1 id="服务端处理-Watcher-实现"><a href="#服务端处理-Watcher-实现" class="headerlink" title="服务端处理 Watcher 实现"></a>服务端处理 Watcher 实现</h1><ul>
<li>服务端接收 Watcher 并存储接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在WatcherManager 的 WatchTable 和 watch2Paths 中去。</li>
<li>Watcher 触发</li>
<li>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：<ul>
<li>封装 WatchedEvent<ul>
<li>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个 WatchedEvent 对象</li>
</ul>
</li>
<li>查询 Watcher<ul>
<li>从 WatchTable 中根据节点路径查找 Watcher</li>
</ul>
</li>
<li>没找到；说明没有客户端在该数据节点上注册过 Watcher</li>
<li>找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里可以看出 Watcher 在服务端是一次性的，触发一次就失效了）</li>
<li>调用 process 方法来触发 Watcher 这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。</li>
</ul>
</li>
</ul>
<h1 id="客户端回调-Watcher"><a href="#客户端回调-Watcher" class="headerlink" title="客户端回调 Watcher"></a>客户端回调 Watcher</h1><ul>
<li>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。</li>
<li>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。</li>
</ul>
<h1 id="ACL-权限控制机制"><a href="#ACL-权限控制机制" class="headerlink" title="ACL 权限控制机制"></a>ACL 权限控制机制</h1><ul>
<li>UGO（User&#x2F;Group&#x2F;Others）目前在 Linux&#x2F;Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗粒度的文件系统权限控制模式。</li>
<li>ACL（Access Control List）访问控制列表包括三个方面：</li>
</ul>
<h4 id="权限模式（Scheme）"><a href="#权限模式（Scheme）" class="headerlink" title="权限模式（Scheme）"></a>权限模式（Scheme）</h4><ul>
<li>IP：从 IP 地址粒度进行权限控制</li>
<li>Digest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制</li>
<li>World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标识“world:anyone”</li>
<li>Super：超级用户</li>
</ul>
<h4 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h4><ul>
<li>授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。</li>
</ul>
<h4 id="权限-Permission"><a href="#权限-Permission" class="headerlink" title="权限 Permission"></a>权限 Permission</h4><ul>
<li>CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点</li>
<li>DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点</li>
<li>READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等</li>
<li>WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作</li>
<li>ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置操作</li>
</ul>
<h1 id="Chroot-特性"><a href="#Chroot-特性" class="headerlink" title="Chroot 特性"></a>Chroot 特性</h1><ul>
<li>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。</li>
<li>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相互隔离非常有帮助。</li>
</ul>
<h1 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h1><ul>
<li>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。</li>
<li>分配原则：每个会话的“下次超时时间点”（ExpirationTime）</li>
<li>计算公式：</li>
<li>ExpirationTime_ &#x3D; currentTime + sessionTimeout</li>
<li>ExpirationTime &#x3D; (ExpirationTime_ &#x2F; ExpirationInrerval + 1) * ExpirationInterval </li>
<li>ExpirationInterval 是指 Zookeeper 会话超时检查时间间隔，默认 tickTime</li>
</ul>
<h1 id="zookeeper-怎么保证主从节点的状态同步？"><a href="#zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="zookeeper 怎么保证主从节点的状态同步？"></a>zookeeper 怎么保证主从节点的状态同步？</h1><ul>
<li>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</li>
</ul>
<h1 id="集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h1><ul>
<li>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</li>
</ul>
<h1 id="说一下-zookeeper-的通知机制？"><a href="#说一下-zookeeper-的通知机制？" class="headerlink" title="说一下 zookeeper 的通知机制？"></a>说一下 zookeeper 的通知机制？</h1><ul>
<li>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</li>
</ul>
<h1 id="cap理论："><a href="#cap理论：" class="headerlink" title="cap理论："></a>cap理论：</h1><ul>
<li>概念：⼀个分布式系统最多只能同时满⾜⼀致性（Consistency）、可⽤性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</li>
<li>⼀致性：更新操作成功并返回客户端完成后，所有节点在同⼀时间的数据完全⼀致，所以，⼀致性，说的就是数据⼀致性。</li>
<li>可⽤性：服务⼀直可⽤，⽽且是正常响应时间。</li>
<li>分区容错性：分布式系统在遇到某节点或⽹络分区故障的时候，仍然能够对外提供满⾜⼀致性和可⽤性的服务。</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/publishes/c0d8e27e97f4.html</url>
    <content><![CDATA[<h1 id="用什么关键字修饰同步方法"><a href="#用什么关键字修饰同步方法" class="headerlink" title="用什么关键字修饰同步方法"></a>用什么关键字修饰同步方法</h1><ul>
<li>用synchronized关键字修饰同步方法</li>
</ul>
<h1 id="stop-和suspend-方法为何不推荐使用"><a href="#stop-和suspend-方法为何不推荐使用" class="headerlink" title="stop()和suspend()方法为何不推荐使用"></a>stop()和suspend()方法为何不推荐使用</h1><ul>
<li>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</li>
<li>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</li>
</ul>
<h1 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h1><ul>
<li>最大的不同是在等待时wait会释放锁，而sleep一直持有锁</li>
<li>Wait通常被用于线程间交互，sleep通常被用于暂停执行</li>
<li>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li>
<li>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li>
<li>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。</li>
<li>wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。</li>
<li>sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器</li>
</ul>
<h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul>
<li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取</li>
<li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率</li>
</ul>
<h1 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h1><ul>
<li>启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态</li>
<li>一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码</li>
</ul>
<h1 id="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h1><ul>
<li>分几种情况：<ul>
<li>其他方法前是否加了synchronized关键字，如果没加，则能。</li>
<li>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</li>
<li>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</li>
<li>如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</li>
</ul>
</li>
</ul>
<h1 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h1><ul>
<li>一个程序中可以有多条执行线索同时执行</li>
<li>一个线程就是程序中的一条执行线索</li>
<li>每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行</li>
<li>每个程序至少都有一个线程，即main方法执行的那个线程</li>
<li>如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行。</li>
<li>线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身</li>
<li>Java中的线程有四种状态分别是：运行、就绪、挂起、结束</li>
<li>线程是操作系统能够进⾏运算调度的最⼩单位，它被包含在进程之中，是进程中的实际运作单位，可以使⽤多线程对进⾏运算提速</li>
</ul>
<h1 id="简述synchronized和java-util-concurrent-locks-Lock的异同"><a href="#简述synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="简述synchronized和java.util.concurrent.locks.Lock的异同"></a>简述synchronized和java.util.concurrent.locks.Lock的异同</h1><ul>
<li>主要相同点：Lock能完成synchronized所实现的所有功能</li>
<li>主要不同点<ul>
<li>Lock有比synchronized更精确的线程语义和更好的性能</li>
<li>ynchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放</li>
<li>Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁</li>
</ul>
</li>
</ul>
<h1 id="Synchronized和ReentrantLock有什么区别"><a href="#Synchronized和ReentrantLock有什么区别" class="headerlink" title="Synchronized和ReentrantLock有什么区别?"></a>Synchronized和ReentrantLock有什么区别?</h1><ul>
<li>synchronized是Java内建的同步机制,所以也有人称其为Intrinsic Locking（固有锁），它提供了互斥的语义和可见性,当一个线程已经获取当前锁时,其他试图获取的线程只能等待或者阻塞在那里。在Java  5以前,synchronized是仅有的同步手段,在代码中,synchronized可以用来修饰方法,也可以使用在特定的代码块上,本质上 synchronized方法等同于把方法全部语句用synchronized块包起来。</li>
<li>ReentrantLock,通常翻译为再入锁,是Java 5提供的锁实现,它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取,代码书写更加灵活。与此同时,ReentrantLock提供了很多实用的方法,能够实现很多synchronized无法做到的细节控制,但是在编码中也需要注意,必须要明确调用unlock()方法释放,不然就会一直持有该锁。synchronzied和ReentrantLock的性能不能一概而论,早期版本synchronized在很多场景下性能相差较大,在后续版本进行了较多改进,在低竞争场景中表现可能优于ReentrantLock。</li>
</ul>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul>
<li>可重⼊锁。可重⼊锁是指同⼀个线程可以多次获取同⼀把锁。ReentrantLock和synchronized都是可重⼊锁。</li>
<li>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，⽽ReentrantLock则提供了中断功能。</li>
<li>公平锁是指多个线程同时尝试获取同⼀把锁时，获取锁的顺序按照线程达到的顺序</li>
<li>⾮公平锁则允许线程“插队”</li>
<li>synchronized是⾮公平锁，⽽ReentrantLock的默认实现是⾮公平锁，但是也可以设置为公平锁。</li>
</ul>
<h4 id="CAS操作-CompareAndSwap"><a href="#CAS操作-CompareAndSwap" class="headerlink" title="CAS操作(CompareAndSwap)"></a>CAS操作(CompareAndSwap)</h4><ul>
<li>CAS操作简单的说就是⽐较并交换</li>
<li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)</li>
<li>如果内存位置的值与预期原值相匹配，那么处理器会⾃动将该位置值更新为新值。否则，处理器不做任何操作</li>
<li>⽆论哪种情况，它都会在 CAS 指令之前返回该位置的值</li>
<li>CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</li>
</ul>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ul>
<li>synchronized是java内置的关键字，它提供了⼀种独占的加锁⽅式</li>
<li>synchronized的获取和释放锁由JVM实现，⽤户不需要显示的释放锁，⾮常⽅便</li>
<li>然⽽synchronized也有⼀定的局限性：<ul>
<li>当线程尝试获取锁的时候，如果获取不到锁会⼀直阻塞。</li>
<li>如果获取锁的线程进⼊休眠或者阻塞，除⾮当前线程异常，否则其他线程尝试获取锁必须⼀直等待。</li>
</ul>
</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul>
<li>ReentrantLock它是JDK 1.5之后提供的API层⾯的互斥锁，需要lock()和unlock()⽅法配合try&#x2F;finally语句块来完成。</li>
<li>等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）</li>
<li>公平锁与⾮公平锁多个线程等待同⼀个锁时，必须按照申请锁的时间顺序获得锁</li>
<li>Synchronized锁⾮公平锁，ReentrantLock默认的构造函数是创建的⾮公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li>
</ul>
<h1 id="请说出你所知道的线程同步的方法"><a href="#请说出你所知道的线程同步的方法" class="headerlink" title="请说出你所知道的线程同步的方法"></a>请说出你所知道的线程同步的方法</h1><ul>
<li>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</li>
<li>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</li>
<li>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级</li>
<li>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li>
</ul>
<h1 id="同步有几种实现方法-都是什么"><a href="#同步有几种实现方法-都是什么" class="headerlink" title="同步有几种实现方法,都是什么?"></a>同步有几种实现方法,都是什么?</h1><ul>
<li>同步的实现方面有两种，分别是synchronized,wait与notify</li>
</ul>
<h1 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul>
<li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信</li>
<li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信</li>
<li>这种方式，本质上就是“共享内存”式的通信</li>
<li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行</li>
</ul>
<h4 id="while轮询的方式"><a href="#while轮询的方式" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul>
<li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()&#x3D;&#x3D;5)是否成立 ，从而实现了线程间的通信</li>
<li>但是这种方式会浪费CPU资源</li>
<li>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试某个条件是否成立</li>
<li>这种方式还存在另外一个问题：轮询的条件的可见性问题</li>
<li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li>
</ul>
<h4 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait&#x2F;notify机制"></a>wait&#x2F;notify机制</h4><ul>
<li>线程A要等待某个条件满足时(list.size()&#x3D;&#x3D;5)，才执行操作，线程B则向list中添加元素，改变list 的size</li>
<li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢</li>
<li>这里用到了Object类的 wait() 和 notify() 方法</li>
<li>当条件未满足时(list.size() !&#x3D;5)，线程A调用wait()放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</li>
<li>当条件满足时，线程B调用 notify()通知线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态</li>
<li>这种方式的一个好处就是CPU的利用率提高了，但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li>
</ul>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ul>
<li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li>
<li>分布式系统中说的两种通信机制：共享内存机制和消息通信机制</li>
<li>synchronized关键字和while轮询“属于”共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流</li>
<li>而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。</li>
</ul>
<h1 id="线程死锁及解决办法"><a href="#线程死锁及解决办法" class="headerlink" title="线程死锁及解决办法"></a>线程死锁及解决办法</h1><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><ul>
<li>所谓死锁： 是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁线程。</li>
<li>由于资源占用是互斥的，当某个线程提出申请资源后，使得有关线程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁</li>
<li>关键点：<ul>
<li>两个以上的线程</li>
<li>争夺共享的资源</li>
<li>它们各自不释放手中资源，除非有外力协助</li>
</ul>
</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul>
<li>让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y的拥有者分别等待对方的资源的问题。</li>
<li>将多个锁组成一组并放到同一个锁下</li>
<li>将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得容器对象的锁时，就可以通过检查变量来判断是否整个容器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试</li>
</ul>
<h1 id="锁分类的了解"><a href="#锁分类的了解" class="headerlink" title="锁分类的了解"></a>锁分类的了解</h1><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h4><ul>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁</li>
<li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象</li>
<li>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大</li>
<li>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁</li>
</ul>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul>
<li>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。</li>
<li>对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁</li>
</ul>
<h4 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁&#x2F;共享锁"></a>独享锁&#x2F;共享锁</h4><ul>
<li>独享锁是指该锁一次只能被一个线程所持有。</li>
<li>共享锁是指该锁可被多个线程所持有。</li>
<li>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。</li>
<li>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li>
<li>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</li>
<li>对于Synchronized而言，当然是独享锁。</li>
</ul>
<h4 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁&#x2F;读写锁"></a>互斥锁&#x2F;读写锁</h4><ul>
<li>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。</li>
<li>互斥锁在Java中的具体实现就是ReentrantLock</li>
<li>读写锁在Java中的具体实现就是ReadWriteLock</li>
</ul>
<h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h4><ul>
<li>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</li>
<li>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</li>
<li>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</li>
<li>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</li>
<li>悲观锁在Java中的使用，就是利用各种锁。</li>
<li>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li>
<li>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑</li>
<li>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接上了锁操作资源。</li>
</ul>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><ul>
<li>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</li>
<li>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。</li>
<li>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</li>
<li>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计</li>
<li>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作</li>
</ul>
<h4 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h4><ul>
<li>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</li>
<li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
<li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
<li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li>
</ul>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul>
<li>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区</li>
<li>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</li>
<li>⾃旋锁是SMP架构中的⼀种low-level的同步机制</li>
<li>当线程A想要获取⼀把⾃旋锁⽽该锁⼜被其它线程锁持有时，线程A会在⼀个循环中⾃旋以检测锁是不是已经可⽤了。</li>
<li>⾃选锁需要注意：<ul>
<li>由于⾃旋时不释放CPU，因⽽持有⾃旋锁的线程应该尽快释放⾃旋锁，否则等待该⾃旋锁的线程会⼀直在那⾥⾃旋，这就会浪费CPU时间</li>
<li>持有⾃旋锁的线程在sleep之前应该释放⾃旋锁以便其它线程可以获得⾃旋锁</li>
</ul>
</li>
<li>⽬前的JVM实现⾃旋会消耗CPU，如果⻓时间不调⽤doNotify⽅法，doWait⽅法会⼀直⾃旋，CPU会消耗太⼤</li>
<li>⾃旋锁⽐较适⽤于锁使⽤者保持锁时间⽐较短的情况，这种情况⾃旋锁的效率⽐较⾼</li>
<li>⾃旋锁是⼀种对多处理器相当有效的机制，⽽在单处理器⾮抢占式的系统中基本上没有作⽤</li>
</ul>
<h1 id="重入锁：ReentrantLock-详解"><a href="#重入锁：ReentrantLock-详解" class="headerlink" title="重入锁：ReentrantLock 详解"></a>重入锁：ReentrantLock 详解</h1><ul>
<li>在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的。除此之外，重入锁又自带一系列高逼格UBFF：可中断响应、锁申请等待限时、公平锁。另外可以结合Condition来使用，使其更是逼格满满。</li>
<li>使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对逻辑控制的灵活性远远大于synchronized关键字</li>
<li>需要注意，有加锁就必须有释放锁，而且加锁与释放锁的分数要相同，这里就引出了“重”字的概念</li>
</ul>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><ul>
<li>对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。</li>
<li>t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了死锁。但是，给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，正常执行完成。t2也会退出，但只是释放了资源并没有完成工作</li>
</ul>
<h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><ul>
<li>可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。</li>
<li>前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。</li>
<li>后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false</li>
</ul>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><ul>
<li>所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ReentrantLock-配合-Conditond-使用"><a href="#ReentrantLock-配合-Conditond-使用" class="headerlink" title="ReentrantLock 配合 Conditond 使用"></a>ReentrantLock 配合 Conditond 使用</h4><ul>
<li>配合关键字synchronized使用的方法如：await()、notify()、notifyAll()</li>
<li>ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象</li>
</ul>
<h1 id="深入理解Callable"><a href="#深入理解Callable" class="headerlink" title="深入理解Callable"></a>深入理解Callable</h1><ul>
<li>Callable和Runnbale一样代表着任务，区别在于Callable有返回值并且可以抛出异常</li>
<li>Callable接⼝使⽤泛型去定义它的返回类型</li>
<li>Executors类提供了⼀些有⽤的⽅法去在线程池中执⾏Callable内的任务</li>
<li>由于Callable任务是并⾏的，必须等待它返回的结果，java.util.concurrent.Future对象解决了这个问题</li>
<li>在线程池提交Callable任务后返回了⼀个Future对象，使⽤它可以知道Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()⽅法，等待Callable结束并获取它的执⾏结果</li>
</ul>
<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><ul>
<li>Future是一个接口，代表了一个异步计算的结果</li>
<li>接口中的方法用来检查计算是否完成、等待完成和得到计算的结果</li>
<li>当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了</li>
<li>如果想取消，那么调用cancel()方法</li>
<li>其他方法用于确定任务是正常完成还是取消了</li>
<li>一旦计算完成了，那么这个计算就不能被取消</li>
</ul>
<h4 id="FutureTask-是什么？"><a href="#FutureTask-是什么？" class="headerlink" title="FutureTask 是什么？"></a>FutureTask 是什么？</h4><ul>
<li>FutureTask 表示一个异步运算的任务，FutureTask 里面可以传入一个 Callable的具体实现类</li>
<li>可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、 取消任务等操作</li>
<li>FutureTask可⽤于异步获取执⾏结果或取消执⾏任务的场景</li>
<li>通过传⼊Runnable或者Callable的任务给FutureTask，直接调⽤其run⽅法或者放⼊线程池执⾏，之后可以在外部通过FutureTask的get⽅法异步获取执⾏结果</li>
<li>FutureTask⾮常适合⽤于耗时的计算，主线程可以在完成⾃⼰的任务后，再去获取结果</li>
<li>FutureTask还可以确保即使调⽤了多次run⽅法，它都只会执⾏⼀次Runnable或者Callable任务，或者通过cancel取消FutureTask的执⾏等</li>
<li>futuretask可⽤于执⾏多任务、以及避免⾼并发情况下多次创建数据机锁的出现。</li>
</ul>
<h4 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h4><ul>
<li><p>当将FutureTask提交给Executor后，Executor执行FutureTask时会执行其run方法</p>
</li>
<li><p>任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程</p>
</li>
<li><p>从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法</p>
</li>
<li><p>set方法：当Callable成功执行后，会调用set方法将结果传出</p>
</li>
<li><p>setException方法：该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程</p>
</li>
<li><p>get方法：当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。</p>
</li>
<li><p>在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待</p>
</li>
<li><p>awaitDone方法是如何将调用线程阻塞的,awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制</p>
</li>
<li><p>awaitDone方法中进入死循环后，主要有几步</p>
<ul>
<li>如果线程被中断了，移除节点，抛出异常</li>
<li>如果状态大于COMPLETING，那么直接返回</li>
<li>如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下</li>
<li>如果状态是NEW且节点为null，那么创建一个节点</li>
<li>如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程</li>
<li>如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点</li>
<li>如果没有限制时间，那么将线程无限挂起</li>
</ul>
</li>
<li><p>上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。</p>
</li>
<li><p>当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果</p>
</li>
<li><p>report会根据任务的状态不同返回不同的结果。</p>
<ul>
<li>如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果</li>
<li>如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException</li>
<li>如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException</li>
</ul>
</li>
<li><p>finishCompletion方法：在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程</p>
</li>
<li><p>finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环，释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。</p>
</li>
<li><p>cancel方法：用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了，如果是需要中断正在执行的任务，那么状态转换将会是NEW-&gt;INTERRPUTING-&gt;INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW-&gt;CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。</p>
</li>
<li><p>isDone方法：表明任务是否已经完成了，如果完成了，那么返回true，否则false，只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>Callable是一种可以返回结果的任务，这是它与Runnable的区别，但是通过适配器模式可以使Runnable与Callable类似</li>
<li>Future代表了一个异步的计算，可以从中得到计算结果、查看计算状态，其实现FutureTask可以被提交给Executor执行，多个线程可以从中得到计算结果</li>
<li>Callable和Future是配合使用的，当从Future中get结果时，如果结果还没被计算出来，那么线程将会被挂起，FutureTak内部使用一个单链表维持等待的线程；当计算结果出来后，将会对等待线程解除挂起，等待线程就都可以得到计算结果了。</li>
<li>Callable⽤于产⽣结果，Future⽤于获取结果</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h4 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h4><ul>
<li>发挥多核CPU 的优势，并发执⾏让系统运⾏的更快、更流畅，⽤户体验更好</li>
<li>防止阻塞：从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因 为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但 是单核 CPU 我们还是要应用多线程，就是为了防止阻塞</li>
<li>便于建模：这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么 就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成 几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运 行这几个任务，那就简单很多了。</li>
<li>使⽤多线程可以把程序中占据时间⻓的任务放到后台去处理，如图⽚、视屏的下载</li>
</ul>
<h4 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h4><ul>
<li>⼤量的线程降低代码的可读性；</li>
<li>更多的线程需要更多的内存空间</li>
<li>当多个线程对同⼀个资源出现争夺时候要注意线程安全的问题。</li>
</ul>
<h4 id="多线程的上下⽂切换"><a href="#多线程的上下⽂切换" class="headerlink" title="多线程的上下⽂切换"></a>多线程的上下⽂切换</h4><ul>
<li>CPU通过时间⽚分配算法来循环执⾏任务，当前任务执⾏⼀个时间⽚后会切换到下⼀个任务</li>
<li>在切换前会保存上⼀个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态</li>
</ul>
<h1 id="线程和进程的区别是什么"><a href="#线程和进程的区别是什么" class="headerlink" title="线程和进程的区别是什么"></a>线程和进程的区别是什么</h1><ul>
<li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式</li>
<li>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径</li>
<li>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些</li>
<li>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程</li>
</ul>
<h1 id="Java-实现线程有哪几种方式"><a href="#Java-实现线程有哪几种方式" class="headerlink" title="Java 实现线程有哪几种方式"></a>Java 实现线程有哪几种方式</h1><ul>
<li>继承 Thread 类实现多线程</li>
<li>实现 Runnable 接口方式实现多线程</li>
<li>使用 ExecutorService、Callable、Future 实现有返回结果的多线程</li>
</ul>
<h1 id="启动线程方法-start-和-run-有什么区别"><a href="#启动线程方法-start-和-run-有什么区别" class="headerlink" title="启动线程方法 start()和 run()有什么区别"></a>启动线程方法 start()和 run()有什么区别</h1><ul>
<li>只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代 码交替执行</li>
<li>如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码</li>
</ul>
<h1 id="一个线程的生命周期有哪几种状态？它们之间如何流转的？"><a href="#一个线程的生命周期有哪几种状态？它们之间如何流转的？" class="headerlink" title="一个线程的生命周期有哪几种状态？它们之间如何流转的？"></a>一个线程的生命周期有哪几种状态？它们之间如何流转的？</h1><ul>
<li>NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。</li>
<li>RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中 状态。</li>
<li>BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。</li>
<li>WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如 通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方 法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线 程就进入了 RUNNABLE 状态继续运行。</li>
<li>TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒 后线程重新进行 RUNNABLE 状态继续运行。</li>
<li>TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程 通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态</li>
</ul>
<h1 id="violatile-关键字的作用"><a href="#violatile-关键字的作用" class="headerlink" title="violatile 关键字的作用"></a>violatile 关键字的作用</h1><ul>
<li>volatile 关键字的作用主要有两个<ul>
<li>多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据</li>
<li>使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重要作用就是和CAS结合，保证了原子性</li>
</ul>
</li>
</ul>
<h1 id="新建-T1、T2、T3-三个线程，如何保证它们按顺序执行"><a href="#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证它们按顺序执行"></a>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行</h1><ul>
<li>用 join 方法。</li>
</ul>
<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><ul>
<li>什么是线程池？ 很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线 程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用</li>
<li>每个线程都要通过 new Thread(xxRunnable).start()的方 式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈</li>
<li>线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存</li>
</ul>
<h1 id="线程池⽤法与优势？"><a href="#线程池⽤法与优势？" class="headerlink" title="线程池⽤法与优势？"></a>线程池⽤法与优势？</h1><h4 id="ThreadPool-优点"><a href="#ThreadPool-优点" class="headerlink" title="ThreadPool 优点"></a>ThreadPool 优点</h4><ul>
<li>减少了创建和销毁线程的次数，每个⼯作线程都可以被重复利⽤，可执⾏多个任务</li>
<li>可以根据系统的承受能⼒，调整线程池中⼯作线线程的数⽬，防⽌因为因为消耗过多的内存，⽽把服务器累趴下</li>
<li>减少在创建和销毁线程上所花的时间以及系统资源的开销</li>
<li>如不使⽤线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存</li>
</ul>
<h4 id="⽐较重要的⼏个类"><a href="#⽐较重要的⼏个类" class="headerlink" title="⽐较重要的⼏个类"></a>⽐较重要的⼏个类</h4><ul>
<li>Java⾥⾯线程池的顶级接⼜是Executor，但是严格意义上讲Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具</li>
<li>真正的线程池接口是ExecutorService。</li>
</ul>
<h4 id="任务执⾏顺序："><a href="#任务执⾏顺序：" class="headerlink" title="任务执⾏顺序："></a>任务执⾏顺序：</h4><ul>
<li>ExecutorService 真正的线程池接⼝。</li>
<li>ScheduledExecutorService 能和Timer&#x2F;TimerTask类似，解决那些需要任务重复执⾏的问题。</li>
<li>ThreadPoolExecutor ExecutorService的默认实现。</li>
<li>ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接⼝实现，周期性任务调度的类实现。<ul>
<li>当线程数⼩于corePoolSize时，创建线程执⾏任务。</li>
<li>当线程数⼤于等于corePoolSize并且workQueue没有满时，放⼊workQueue中</li>
<li>线程数⼤于等于corePoolSize并且当workQueue满时，新任务新建线程运⾏，线程总数要⼩于maximumPoolSize</li>
<li>当线程总数等于maximumPoolSize并且workQueue满了的时候执⾏handler的rejectedExecution。也就是拒绝策略</li>
</ul>
</li>
</ul>
<h1 id="常用的几种线程池并讲讲其中的工作原理"><a href="#常用的几种线程池并讲讲其中的工作原理" class="headerlink" title="常用的几种线程池并讲讲其中的工作原理"></a>常用的几种线程池并讲讲其中的工作原理</h1><ul>
<li>线程池核心类：在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是我们线程池核心类</li>
<li>如何提交线程：如可以先随便定义一个固定大小的线程池 ExecutorService es &#x3D; Executors.newFixedThreadPool(3);提交一个线程es.submit(xxRunnble); es.execute(xxRunnble);</li>
<li>submit 和 execute 分别有什么区别呢<ul>
<li>execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多</li>
<li>submit 返回一个 Future 对象，如果想知道线程结果就使用 submit提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常</li>
</ul>
</li>
<li>如何关闭线程池<ul>
<li>es.shutdown(); 不再接受新的任务，之前提交的任务等执行结束再关闭线程池</li>
<li>es.shutdownNow();不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程 list 列表</li>
</ul>
</li>
</ul>
<h1 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier 和 CountDownLatch 的区别"></a>CyclicBarrier 和 CountDownLatch 的区别</h1><ul>
<li>都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上</li>
<li>CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值-1 而已，该线程继续运行</li>
<li>CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务</li>
<li>CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h1 id="什么是活锁、饥饿、无锁、死锁"><a href="#什么是活锁、饥饿、无锁、死锁" class="headerlink" title="什么是活锁、饥饿、无锁、死锁"></a>什么是活锁、饥饿、无锁、死锁</h1><ul>
<li>死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现了这三种情况，即线程不再活跃，不能再正常地执行下去了</li>
<li>死锁：死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁</li>
<li>活锁：活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。 </li>
<li>饥饿：我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源</li>
<li>无锁：无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功，可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合 下是非常高效的。</li>
</ul>
<h1 id="什么是原子性、可见性、有序性"><a href="#什么是原子性、可见性、有序性" class="headerlink" title="什么是原子性、可见性、有序性"></a>什么是原子性、可见性、有序性</h1><ul>
<li>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个 变量进行操作</li>
<li>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值</li>
<li>有序性我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序， 只是重排序会影响多线程执行的结果。</li>
</ul>
<h1 id="什么是守护线程？有什么用？"><a href="#什么是守护线程？有什么用？" class="headerlink" title="什么是守护线程？有什么用？"></a>什么是守护线程？有什么用？</h1><ul>
<li>与守护线程相对应的就是用户线程，守护线程就是守护用户线程</li>
<li>当用户线程全部执行完结束之后，守护线程才会跟着结束</li>
<li>也就是守护线程必须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线 程自然会退出</li>
</ul>
<h1 id="一个线程运行时发生异常会怎样"><a href="#一个线程运行时发生异常会怎样" class="headerlink" title="一个线程运行时发生异常会怎样"></a>一个线程运行时发生异常会怎样</h1><ul>
<li>如果异常没有被捕获该线程将会停止执行</li>
<li>Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口</li>
<li>当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理</li>
</ul>
<h1 id="线程-yield-方法有什么用"><a href="#线程-yield-方法有什么用" class="headerlink" title="线程 yield()方法有什么用"></a>线程 yield()方法有什么用</h1><ul>
<li>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行</li>
<li>它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</li>
</ul>
<h1 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h1><ul>
<li>所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的</li>
</ul>
<h1 id="Synchronized-有哪几种用法"><a href="#Synchronized-有哪几种用法" class="headerlink" title="Synchronized 有哪几种用法"></a>Synchronized 有哪几种用法</h1><ul>
<li>锁类、锁方法、锁代码块</li>
</ul>
<h1 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h1><h4 id="Fork-Join-框架是干什么的"><a href="#Fork-Join-框架是干什么的" class="headerlink" title="Fork&#x2F;Join 框架是干什么的"></a>Fork&#x2F;Join 框架是干什么的</h4><ul>
<li>大任务自动分散小任务，并发执行，合并小任务结果</li>
</ul>
<h4 id="Fork-Join-框架使用有哪些要注意的地方？"><a href="#Fork-Join-框架使用有哪些要注意的地方？" class="headerlink" title="Fork&#x2F;Join 框架使用有哪些要注意的地方？"></a>Fork&#x2F;Join 框架使用有哪些要注意的地方？</h4><ul>
<li>如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降； </li>
<li>如果函数的调用栈很深，会导致栈内存溢出；</li>
</ul>
<h1 id="线程数过多会造成什么异常"><a href="#线程数过多会造成什么异常" class="headerlink" title="线程数过多会造成什么异常"></a>线程数过多会造成什么异常</h1><ul>
<li>线程过多会造成栈溢出，也有可能会造成堆异常</li>
</ul>
<h1 id="说说线程安全的和不安全的集合"><a href="#说说线程安全的和不安全的集合" class="headerlink" title="说说线程安全的和不安全的集合"></a>说说线程安全的和不安全的集合</h1><ul>
<li>Java 中平时用的最多的 Map 集合就是 HashMap 了，它是线程不安全的。 看下面两个场景：<ul>
<li>当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线程安全不安全的问题了</li>
<li>当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个 HashMap了，对同个 HashMap 操作这时候就存在线程安全的问题了</li>
</ul>
</li>
</ul>
<h1 id="什么是-CAS-算法？在多线程中有哪些应用"><a href="#什么是-CAS-算法？在多线程中有哪些应用" class="headerlink" title="什么是 CAS 算法？在多线程中有哪些应用"></a>什么是 CAS 算法？在多线程中有哪些应用</h1><ul>
<li>CAS，全称为 Compare and Swap，即比较-替换</li>
<li>假设有三个操作数：内存值 V、 旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false</li>
<li>当然 CAS 一定要 volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功。</li>
<li>java.util.concurrent.atomic 包下面的 Atom*类都有 CAS 算法的应用。</li>
</ul>
<h1 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h1><ul>
<li>java.lang.Thread#holdsLock 方法</li>
</ul>
<h1 id="Jdk-中排查多线程问题用什么命令"><a href="#Jdk-中排查多线程问题用什么命令" class="headerlink" title="Jdk 中排查多线程问题用什么命令"></a>Jdk 中排查多线程问题用什么命令</h1><ul>
<li>jstack</li>
</ul>
<h1 id="线程同步需要注意什么"><a href="#线程同步需要注意什么" class="headerlink" title="线程同步需要注意什么"></a>线程同步需要注意什么</h1><ul>
<li>尽量缩小同步的范围，增加系统吞吐量</li>
<li>分布式同步锁无意义，要使用分布式锁</li>
<li>防止死锁，注意加锁顺序</li>
</ul>
<h1 id="线程-wait-方法使用有什么前提？"><a href="#线程-wait-方法使用有什么前提？" class="headerlink" title="线程 wait()方法使用有什么前提？"></a>线程 wait()方法使用有什么前提？</h1><ul>
<li>要在同步块中使用</li>
</ul>
<h1 id="线程之间如何传递数据？"><a href="#线程之间如何传递数据？" class="headerlink" title="线程之间如何传递数据？"></a>线程之间如何传递数据？</h1><ul>
<li>通过在线程之间共享对象就可以了，</li>
<li>然后通过wait&#x2F;notify&#x2F;notifyAll、await&#x2F;signal&#x2F;signalAll进行唤起和等待，比方说阻塞队列 BlockingQueue就是为线程之间共享数据而设计的</li>
</ul>
<h1 id="保证”可见性”有哪几种方式？"><a href="#保证”可见性”有哪几种方式？" class="headerlink" title="保证”可见性”有哪几种方式？"></a>保证”可见性”有哪几种方式？</h1><ul>
<li>synchronized 和 viotatile</li>
</ul>
<h1 id="说几个常用的-Lock-接口实现锁。"><a href="#说几个常用的-Lock-接口实现锁。" class="headerlink" title="说几个常用的 Lock 接口实现锁。"></a>说几个常用的 Lock 接口实现锁。</h1><ul>
<li>ReentrantLock、ReadWriteLock</li>
</ul>
<h1 id="ThreadLocal-是什么？有什么应用场景？"><a href="#ThreadLocal-是什么？有什么应用场景？" class="headerlink" title="ThreadLocal 是什么？有什么应用场景？"></a>ThreadLocal 是什么？有什么应用场景？</h1><ul>
<li>ThreadLocal 的作用是提供线程内的局部变量</li>
<li>这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。用来解决数据库连接、Session 管理等。</li>
</ul>
<h1 id="ReadWriteLock-有什么用？"><a href="#ReadWriteLock-有什么用？" class="headerlink" title="ReadWriteLock 有什么用？"></a>ReadWriteLock 有什么用？</h1><ul>
<li>ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现</li>
<li>实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能</li>
</ul>
<h1 id="怎么唤醒一个阻塞的线程？"><a href="#怎么唤醒一个阻塞的线程？" class="headerlink" title="怎么唤醒一个阻塞的线程？"></a>怎么唤醒一个阻塞的线程？</h1><ul>
<li>如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它</li>
<li>如果线程遇到了 IO 阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统</li>
</ul>
<h1 id="不可变对象对多线程有什么帮助？"><a href="#不可变对象对多线程有什么帮助？" class="headerlink" title="不可变对象对多线程有什么帮助？"></a>不可变对象对多线程有什么帮助？</h1><ul>
<li>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率</li>
</ul>
<h1 id="多线程上下文切换是什么意思？"><a href="#多线程上下文切换是什么意思？" class="headerlink" title="多线程上下文切换是什么意思？"></a>多线程上下文切换是什么意思？</h1><ul>
<li>多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</li>
</ul>
<h1 id="Java-中用到了什么线程调度算法？"><a href="#Java-中用到了什么线程调度算法？" class="headerlink" title="Java 中用到了什么线程调度算法？"></a>Java 中用到了什么线程调度算法？</h1><ul>
<li>抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</li>
</ul>
<h1 id="Thread-sleep-0-的作用是什么？"><a href="#Thread-sleep-0-的作用是什么？" class="headerlink" title="Thread.sleep(0)的作用是什么？"></a>Thread.sleep(0)的作用是什么？</h1><ul>
<li>由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制 权的一种操作</li>
</ul>
<h1 id="Hashtable-的-size-方法为什么要做同步？"><a href="#Hashtable-的-size-方法为什么要做同步？" class="headerlink" title="Hashtable 的 size()方法为什么要做同步？"></a>Hashtable 的 size()方法为什么要做同步？</h1><ul>
<li>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B则可以正常调用 size()方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对size++，线程 B 就已经读取 size了，那么对于线程 B 来说读取到的size 一定是不准 确的。而给 size()方法加了同步之后，意味着线程 B 调用size()方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性。</li>
</ul>
<h1 id="同步方法和同步块，哪种更好？"><a href="#同步方法和同步块，哪种更好？" class="headerlink" title="同步方法和同步块，哪种更好？"></a>同步方法和同步块，哪种更好？</h1><ul>
<li>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率</li>
<li>请知道一条原则：同步的范围越小越好。</li>
</ul>
<h1 id="Runnable-和-Thread-用哪个好？"><a href="#Runnable-和-Thread-用哪个好？" class="headerlink" title="Runnable 和 Thread 用哪个好？"></a>Runnable 和 Thread 用哪个好？</h1><ul>
<li>Java 不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也为了减少类之间的耦合性，Runnable 会更好</li>
</ul>
<h1 id="Java-中-notify-和-notifyAll-有什么区别？"><a href="#Java-中-notify-和-notifyAll-有什么区别？" class="headerlink" title="Java 中 notify 和 notifyAll 有什么区别？"></a>Java 中 notify 和 notifyAll 有什么区别？</h1><ul>
<li>notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行</li>
</ul>
<h1 id="为什么-wait-notify-notifyAll-这些方法不在-thread-类里面？"><a href="#为什么-wait-notify-notifyAll-这些方法不在-thread-类里面？" class="headerlink" title="为什么 wait&#x2F;notify&#x2F;notifyAll 这些方法不在 thread 类里面？"></a>为什么 wait&#x2F;notify&#x2F;notifyAll 这些方法不在 thread 类里面？</h1><ul>
<li>原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果 wait()方法定 义在 Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait， notify 和 notifyAll都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象</li>
</ul>
<h1 id="为什么-wait-和-notify-方法要在同步块中调用？"><a href="#为什么-wait-和-notify-方法要在同步块中调用？" class="headerlink" title="为什么 wait 和 notify 方法要在同步块中调用？"></a>为什么 wait 和 notify 方法要在同步块中调用？</h1><ul>
<li>为了避免 wait 和 notify 之间产生竞态条件</li>
<li>为Java API强制要求，否则会抛出IllegalMonitorStateException 异常</li>
</ul>
<h1 id="为什么你应该在循环中检查等待条件？"><a href="#为什么你应该在循环中检查等待条件？" class="headerlink" title="为什么你应该在循环中检查等待条件？"></a>为什么你应该在循环中检查等待条件？</h1><ul>
<li>处于等待状态的线程可能会收到错误警报和伪唤醒</li>
<li>如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出</li>
<li>因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因</li>
</ul>
<h1 id="你如何在-Java-中获取线程堆栈？"><a href="#你如何在-Java-中获取线程堆栈？" class="headerlink" title="你如何在 Java 中获取线程堆栈？"></a>你如何在 Java 中获取线程堆栈？</h1><ul>
<li>jstack 这个工具来获取，它对进程 id 进行操作，用 jps 这个工具找到 id。</li>
</ul>
<h1 id="如何创建线程安全的单例模式？"><a href="#如何创建线程安全的单例模式？" class="headerlink" title="如何创建线程安全的单例模式？"></a>如何创建线程安全的单例模式？</h1><ul>
<li>单例模式即一个 JVM 内存中只存在一个类的对象实例分类<ul>
<li>懒汉式 类加载的时候就创建实例</li>
<li>饿汉式 使用的时候才创建实例</li>
</ul>
</li>
</ul>
<h1 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h1><ul>
<li>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接</li>
<li>这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</li>
</ul>
<h1 id="提交任务时线程池队列已满会时发会生什么？"><a href="#提交任务时线程池队列已满会时发会生什么？" class="headerlink" title="提交任务时线程池队列已满会时发会生什么？"></a>提交任务时线程池队列已满会时发会生什么？</h1><ul>
<li>当线程数小于最大线程池数 maximumPoolSize 时就会创建新线程来处理</li>
<li>线程数大于等于最大线程池数 maximumPoolSize 时就会执行拒绝策略</li>
<li>如果你使⽤的LinkedBlockingQueue，也就是⽆界队列的话，没关系，继续添加任务到阻塞队列中等待执⾏，因为LinkedBlockingQueue可以近乎认为是⼀个⽆穷⼤的队列，可以⽆限存放任务；</li>
<li>如果你使⽤的是有界队列⽐⽅说ArrayBlockingQueue的话，任务⾸先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使⽤拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</li>
</ul>
<h1 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h1><ul>
<li>可以用join方法实现</li>
</ul>
<h1 id="在Java中Lock接口比synchronized块的优势是什么？"><a href="#在Java中Lock接口比synchronized块的优势是什么？" class="headerlink" title="在Java中Lock接口比synchronized块的优势是什么？"></a>在Java中Lock接口比synchronized块的优势是什么？</h1><ul>
<li>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁</li>
</ul>
<h1 id="你将如何使用threaddump？你将如何分析Thread-dump？"><a href="#你将如何使用threaddump？你将如何分析Thread-dump？" class="headerlink" title="你将如何使用threaddump？你将如何分析Thread dump？"></a>你将如何使用threaddump？你将如何分析Thread dump？</h1><ul>
<li>在UNIX中你可以使用kill -3，然后thread dump将会打印日志</li>
<li>在windows中你可以使用”CTRL+Break”</li>
</ul>
<h1 id="为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h1><ul>
<li>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码</li>
<li>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码</li>
</ul>
<h1 id="Java中你怎样唤醒一个阻塞的线程？"><a href="#Java中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java中你怎样唤醒一个阻塞的线程？"></a>Java中你怎样唤醒一个阻塞的线程？</h1><ul>
<li>如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程</li>
<li>如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它</li>
</ul>
<h1 id="Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h1><ul>
<li>通常利用Executors提供的通用线程池创建方法，去创建不同配置的线程池,主要区别在于不同的ExecutorService类型或者不同的初始参数</li>
<li>Executors目前提供了5种不同的线程池创建配置<ul>
<li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点:<ul>
<li>它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程</li>
<li>如果线程闲置的时间超过60S，则被终止并移出缓存</li>
<li>长时间闲置时，这种线程池不会消耗资源</li>
</ul>
</li>
<li>newFixedThreadPool(int  nThreads)：重用指定数目的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现，如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads</li>
<li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为1,操作一个无界的工作队列,所以它保证了所有任务的都是被顺序执行,最多会有一个任务处于活动状态,并且不允许使用者改造线程实例,因此可以避免其改变线程数目。</li>
<li>newSingleThreadScheduledExecutor()和newSecheduledThreadPool(int  corePoolSize),创建的是个ScheduledExecutorService,可以进行定时或周期性的工作调度,区别在于单一工作线程还是多个工作线程。</li>
</ul>
</li>
</ul>
<h1 id="⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？"><a href="#⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？" class="headerlink" title="⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？"></a>⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？</h1><ul>
<li>⾼并发、任务执⾏时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下⽂的切换</li>
<li>并发不⾼、任务执⾏时间⻓的业务要区分开看：<ul>
<li>假如是业务时间⻓集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占⽤CPU，所以不要让所有的CPU闲下来，可以加⼤线程池中的线程数⽬，让CPU处理更多的业务</li>
<li>假如是业务时间⻓集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）⼀样吧，线程池中的线程数设置得少⼀些，减少线程上下⽂的切换</li>
</ul>
</li>
<li>并发⾼、业务执⾏时间⻓，解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，看看这些业务⾥⾯某些数据是否能做缓存是第⼀步，增加服务器是第⼆步，⾄于线程池的设置，设置参考（2）。最后，业务执⾏时间⻓的问题，也可能需要分析⼀下，看看能不能使⽤中间件对任务进⾏拆分和解耦。</li>
</ul>
<h1 id="线程安全和线程不安全"><a href="#线程安全和线程不安全" class="headerlink" title="线程安全和线程不安全"></a>线程安全和线程不安全</h1><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul>
<li>线程安全就是多线程访问时，采⽤了加锁机制，当⼀个线程访问该类的某个数据时，进⾏保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使⽤。不会出现数据不⼀致或者数据污染。</li>
<li>线程安全是一个多线程环境下正确性的概念,也就是保证多线程环境下共享的可修改的状态的正确性,这里的状态反映在程序中其实可以看做是数据。</li>
<li>换个角度来看,如果状态不是共享的,或者不是可修改的,也就不存在线程安全问题,进而可以推理出保证线程安全的两个办法<ul>
<li>第一个是封装,我们可以将对象内部状态隐藏保护起来</li>
<li>第二个是不可变。</li>
</ul>
</li>
<li>线程安全需要保证几个基本特性<ul>
<li>原子性：简单来说就是相关操作不会中途被其他线程干扰,一般通过同步机制实现</li>
<li>可见性：是一个线程修改了某个共享变量,其状态能够立即被其他线程知晓,通常被解释为将线程本地状态反映到主内存中,volatile关键字就是负责保证可见性的</li>
<li>有序性：是保证线程内串行语义, 避免指令重排等</li>
</ul>
</li>
</ul>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><ul>
<li>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</li>
<li>线程安全问题都是由全局变量及静态变量引起的</li>
<li>若每个线程中对全局变量、静态变量只有读操作，⽽⽆写操作，⼀般来说，这个全局变量是线程安全的</li>
<li>若有多个线程同时执⾏写操作，⼀般都需要考虑线程同步，否则的话就可能影响线程安全</li>
</ul>
<h1 id="如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全"><a href="#如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全" class="headerlink" title="如何保证集合是线程安全的?	ConcurrentHashMap 如何实现高效的线程安全?"></a>如何保证集合是线程安全的?	ConcurrentHashMap 如何实现高效的线程安全?</h1><ul>
<li>在传统集合框架内部,除了Hashtable  Vector等同步容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个 同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等</li>
<li>Vector 是⽤同步⽅法来实现线程安全的, ⽽和它相似的ArrayList不是线程安全的</li>
</ul>
<h1 id="为什么需要ConcurrentHashMap"><a href="#为什么需要ConcurrentHashMap" class="headerlink" title="为什么需要ConcurrentHashMap?"></a>为什么需要ConcurrentHashMap?</h1><ul>
<li>Hashtable本身比较低效,因为它的实现基本就是put  get  size等各种方法加上”synchronized”</li>
<li>这就导致了所有并发操作都要竞争同一把锁,一个线程在进行同步操作时,其他线程只能等待,大大降低了并发操作的效率</li>
<li>HashMap不是线程安全的,那么能不能利用Collections提供的同步包装器来解决问题</li>
<li>实际上同步器只是利用 输入Map构造了另一个同步版本,所有操作不再声明为synchronized方法,但是还是利用</li>
<li>Hashtable或者同步包装版本,都只是适合在非高度并发的场景下</li>
</ul>
<h1 id="ConcurrentHashMap工作机制"><a href="#ConcurrentHashMap工作机制" class="headerlink" title="ConcurrentHashMap工作机制"></a>ConcurrentHashMap工作机制</h1><ul>
<li>在早期的ConcurrentHashMap,其实现是基于分离锁,也就是将内部进行分段,里面则是HashEntry的数据</li>
<li>和HashMap类似,哈希相同的条目也是以链表形式存放。(简单点来说,就是在ConcurrentHashMap中,把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中)在构造的时候,Segment的数量由所谓的concurrentcyLevel来决定,默认是16,也可以在相应构造函数直接指定。注意,Java需要它是2的幂数值,如果输入是类似15这种非幂值,会自动调整到16之类2的幂数值。</li>
<li>ConcurrentHashMap的工作机制就是通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li>
</ul>
<h1 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h1><ul>
<li>CAS（compare and swap）的缩写，中⽂翻译成⽐较并交换。</li>
<li>CAS 不通过JVM,直接利⽤java本地⽅ JNI（Java Native Interface为JAVA本地调⽤）,直接调⽤CPU 的cmpxchg（是汇编指令）指令</li>
<li>利⽤CPU的CAS指令，同时借助JNI来完成Java的⾮阻塞算法,实现原⼦操作。其它原⼦操作都是利⽤类似的特性完成的。</li>
<li>整个java.util.concurrent都是建⽴在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很⼤的提升。</li>
<li>CAS是项乐观锁技术，当多个线程尝试使⽤CAS同时更新同⼀个变量时，只有其中⼀个线程能更新变量的值，⽽其它线程都失败，失败的线程并不会被挂起，⽽是被告知这次竞争中失败，并可以再次尝试</li>
<li>使⽤CAS在线程冲突严重时，会⼤幅降低程序性能；CAS只适合于线程冲突较少的情况使⽤。</li>
<li>synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是⾃旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了⾼吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；⽽线程冲突严重的情况下，性能远⾼于CAS</li>
</ul>
<h1 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h1><ul>
<li>AbstractQueuedSynchronizer简称AQS，是⼀个⽤于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等</li>
<li>AQS解决了在实现同步容器时设计的⼤量细节问题。</li>
<li>AQS使⽤⼀个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护⼀个等待状态waitStatus。</li>
</ul>
<h1 id="什么是原⼦操作？在Java-Concurrency-API中有哪些原⼦类-atomic-classes-？"><a href="#什么是原⼦操作？在Java-Concurrency-API中有哪些原⼦类-atomic-classes-？" class="headerlink" title="什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？"></a>什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？</h1><ul>
<li>原⼦操作是指⼀个不受其他操作影响的操作任务单元</li>
<li>原⼦操作是在多线程环境下避免数据不⼀致必须的⼿段。</li>
<li>int++并不是⼀个原⼦操作，所以当⼀个线程读取它的值并加1时，另外⼀个线程有可能会读到之前的值，这就会引发错误。</li>
<li>为了解决这个问题，必须保证增加操作是原⼦的，在JDK1.5之前我们可以使⽤同步技术来做到这⼀点到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以⾃动的保证对于他们的操作是原⼦的并且不需要使⽤同步</li>
</ul>
<h1 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h1><ul>
<li>阻塞队列是⼀个在队列基础上⼜⽀持了两个附加操作的队列。<ul>
<li>⽀持阻塞的插⼊⽅法：队列满时，队列会阻塞插⼊元素的线程，直到队列不满。</li>
<li>⽀持阻塞的移除⽅法：队列空时，获取元素的线程会等待队列变为⾮空。</li>
</ul>
</li>
<li>JDK7提供了7个阻塞队列<ul>
<li>ArrayBlockingQueue ：⼀个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：⼀个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：⼀个⽀持优先级排序的⽆界阻塞队列。</li>
<li>DelayQueue：⼀个使⽤优先级队列实现的⽆界阻塞队列。</li>
<li>SynchronousQueue：⼀个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：⼀个由链表结构组成的⽆界阻塞队列。</li>
<li>LinkedBlockingDeque：⼀个由链表结构组成的双向阻塞队列。</li>
</ul>
</li>
</ul>
<h1 id="什么是同步容器和并发容器的实现？"><a href="#什么是同步容器和并发容器的实现？" class="headerlink" title="什么是同步容器和并发容器的实现？"></a>什么是同步容器和并发容器的实现？</h1><h4 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h4><ul>
<li>主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。</li>
<li>锁的粒度为当前对象整体。</li>
<li>迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。</li>
</ul>
<h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><ul>
<li>主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。</li>
<li>锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。</li>
<li>迭代器具有弱⼀致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</li>
<li>ConcurrentHashMap采⽤分段锁技术，同步容器中，是⼀个容器⼀个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若⼲段，每段维护⼀个锁，以达到⾼效的并发访问；</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h4 id="ThreadLocal的设计理念与作⽤？"><a href="#ThreadLocal的设计理念与作⽤？" class="headerlink" title="ThreadLocal的设计理念与作⽤？"></a>ThreadLocal的设计理念与作⽤？</h4><ul>
<li>Java中的ThreadLocal类允许我们创建只能被同⼀个线程读写的变量</li>
<li>如果⼀段代码含有⼀个ThreadLocal变量的引⽤，即使两个线程同时执⾏这段代码，它们也⽆法访问到对⽅的ThreadLocal变量</li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>线程局部变量</li>
<li>变量是同⼀个，但是每个线程都使⽤同⼀个初始值，也就是使⽤同⼀个变量的⼀个新的副本。这种情况之下ThreadLocal就⾮常适⽤，⽐如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是⼀个线程安全的变量。⽽我们每个线程都需要使⽤他，并且各⾃使⽤各⾃的。这种情况，ThreadLocal就⽐较好的解决了这个问题。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>从本质来讲，就是每个线程都维护了⼀个map，⽽这个map的key就是threadLocal，⽽值就是我们set的那个值</li>
<li>每次线程在get的时候，都从⾃⼰的变量中取值，既然从⾃⼰的变量中取值，那肯定就不存在线程安全问题</li>
<li>ThreadLocal这个变量的状态根本没有发⽣变化，他仅仅是充当⼀个key的⻆⾊，另外提供给每⼀个线程⼀个初始值。</li>
</ul>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>每个Thread对象内部都维护了⼀个ThreadLocalMap这样⼀个ThreadLocal的Map，可以存放若⼲个ThreadLocal。</li>
</ul>
<h4 id="应⽤场景"><a href="#应⽤场景" class="headerlink" title="应⽤场景"></a>应⽤场景</h4><ul>
<li>当很多线程需要多次使⽤同⼀个对象，并且需要该对象具有相同初始化值的时候最适合使⽤ThreadLocal。</li>
</ul>
<h1 id="Semaphore有什么作⽤？"><a href="#Semaphore有什么作⽤？" class="headerlink" title="Semaphore有什么作⽤？"></a>Semaphore有什么作⽤？</h1><ul>
<li>Semaphore就是⼀个信号量</li>
<li>作⽤是限制某段代码块的并发数</li>
</ul>
<h1 id="Hashtable的size-⽅法中明明只有⼀条语句”return-count”，为什么还要做同步？"><a href="#Hashtable的size-⽅法中明明只有⼀条语句”return-count”，为什么还要做同步？" class="headerlink" title="Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？"></a>Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？</h1><ul>
<li>同⼀时间只能有⼀条线程执⾏固定类的同步⽅法，但是对于类的⾮同步⽅法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执⾏Hashtable的put⽅法添加数据，线程B则可以正常调⽤size()⽅法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size⼀定是不准确的。</li>
<li>⽽给size()⽅法加了同步之后，意味着线程B调⽤size()⽅法只有在线程A调⽤put⽅法完毕之后才可以调⽤，这样就保证了线程安全性。</li>
</ul>
<h1 id="ConcurrentHashMap的并发度是什么？"><a href="#ConcurrentHashMap的并发度是什么？" class="headerlink" title="ConcurrentHashMap的并发度是什么？"></a>ConcurrentHashMap的并发度是什么？</h1><ul>
<li>⼯作机制（分⽚思想）：它引⼊了⼀个“分段锁”的概念，具体可以理解为把⼀个⼤的Map拆分成N个⼩的segment，根据key.hashCode()来决定把key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li>
<li>应⽤：当读&gt;写时使⽤，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；</li>
<li>hash冲突：<ul>
<li>简介：HashMap中调⽤hashCode()⽅法来计算hashCode。由于在Java中两个不同的对象可能有⼀样的hashCode,所以不同的键可能有⼀样hashCode，从⽽导致冲突的产⽣。</li>
<li>hash冲突解决：使⽤平衡树来代替链表，当同⼀hash中的元素数量超过特定的值便会由链表切换到平衡树</li>
</ul>
</li>
<li>⽆锁读：ConcurrentHashMap之所以有较好的并发性是因为ConcurrentHashMap是⽆锁读和加锁写，并且利⽤了分段锁（不是在所有的entry上加锁，⽽是在⼀部分entry上加锁）；读之前会先判断count(jdk1.6)，其中的count是被volatile修饰的(当变量被volatile修饰后，每次更改该变量的时候会将更改结果写到系统主内存中，利⽤多处理器的缓存⼀致性，其他处理器会发现⾃⼰的缓存⾏对应的内存地址被修改，就会将⾃⼰处理器的缓存⾏设置为失效，并强制从系统主内存获取最新的数据。)，故可以实现⽆锁读。</li>
<li>ConcurrentHashMap的并发度就是segment的⼤⼩，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最⼤优势。</li>
</ul>
<h1 id="ReentrantReadWriteLock读写锁的使⽤"><a href="#ReentrantReadWriteLock读写锁的使⽤" class="headerlink" title="ReentrantReadWriteLock读写锁的使⽤"></a>ReentrantReadWriteLock读写锁的使⽤</h1><ul>
<li>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm⾃⼰控制的，你只要上好相应的锁即可</li>
<li>如果你的代码只读数据，可以很多⼈同时读，但不能同时写，那就上读锁</li>
<li>如果你的代码修改数据，只能有⼀个⼈在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁</li>
</ul>
<h1 id="锁的等级：⽅法锁、对象锁、类锁"><a href="#锁的等级：⽅法锁、对象锁、类锁" class="headerlink" title="锁的等级：⽅法锁、对象锁、类锁?"></a>锁的等级：⽅法锁、对象锁、类锁?</h1><h4 id="⽅法锁（synchronized修饰⽅法时）"><a href="#⽅法锁（synchronized修饰⽅法时）" class="headerlink" title="⽅法锁（synchronized修饰⽅法时）"></a>⽅法锁（synchronized修饰⽅法时）</h4><pre><code>- 通过在⽅法声明中加⼊ synchronized关键字来声明 synchronized ⽅法。
- synchronized ⽅法控制对类成员变量的访问：
- 每个类实例对应⼀把锁，每个 synchronized ⽅法都必须获得调⽤该⽅法的类实例的锁⽅能执⾏，否则所属线程阻塞，⽅法⼀旦执⾏，就独占该锁，直到从该⽅法返回时才将锁释放，此后被阻塞的线程⽅能获得该锁，重新进⼊可执⾏状态
- 这种机制确保了同⼀时刻对于每⼀个类实例，其所有声明为 synchronized 的成员函数中⾄多只有⼀个处于可执⾏状态，从⽽有效避免了类成员变量的访问冲突。
</code></pre>
<h4 id="对象锁（synchronized修饰⽅法或代码块）"><a href="#对象锁（synchronized修饰⽅法或代码块）" class="headerlink" title="对象锁（synchronized修饰⽅法或代码块）"></a>对象锁（synchronized修饰⽅法或代码块）</h4><ul>
<li>当⼀个对象中有synchronized method或synchronized block的时候调⽤此对象的同步⽅法或进⼊其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调⽤者占⽤，则需要等待此锁被释放。（⽅法锁也是对象锁）</li>
<li>java的所有对象都含有1个互斥锁，这个锁由JVM⾃动获取和释放</li>
<li>线程进⼊synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待</li>
<li>synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁</li>
<li>这⾥也体现了⽤synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来⾃动释放。</li>
</ul>
<p>　</p>
<h4 id="类锁-synchronized-修饰静态的⽅法或代码块"><a href="#类锁-synchronized-修饰静态的⽅法或代码块" class="headerlink" title="类锁(synchronized 修饰静态的⽅法或代码块)"></a>类锁(synchronized 修饰静态的⽅法或代码块)</h4><ul>
<li>由于⼀个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有⼀份。所以，⼀旦⼀个静态的⽅法被申明为synchronized。此类所有的实例化对象在调⽤此⽅法，共⽤同⼀把锁，我们称之为类锁。</li>
<li>对象锁是⽤来控制实例⽅法之间的同步，类锁是⽤来控制静态⽅法（或静态变量互斥体）之间的同步</li>
</ul>
<h1 id="如果同步块内的线程抛出异常会发⽣什么？"><a href="#如果同步块内的线程抛出异常会发⽣什么？" class="headerlink" title="如果同步块内的线程抛出异常会发⽣什么？"></a>如果同步块内的线程抛出异常会发⽣什么？</h1><ul>
<li>synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁</li>
</ul>
<h1 id="并发编程（concurrency）并⾏编程（parallellism）有什么区别？"><a href="#并发编程（concurrency）并⾏编程（parallellism）有什么区别？" class="headerlink" title="并发编程（concurrency）并⾏编程（parallellism）有什么区别？"></a>并发编程（concurrency）并⾏编程（parallellism）有什么区别？</h1><ul>
<li>并⾏是指两个或者多个事件在同⼀时刻发⽣；⽽并发是指两个或多个事件在同⼀时间间隔发⽣。</li>
<li>并⾏是在不同实体上的多个事件，并发是在同⼀实体上的多个事件。</li>
<li>在⼀台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群所以并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能。</li>
</ul>
<h1 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h1><ul>
<li>volatile只能保证你数据的可⻅性，获取到的是最新的数据，不能保证原⼦性；</li>
<li>⽤AtomicInteger保证原⼦性。</li>
<li>synchronized既能保证共享变量可⻅性，也可以保证锁内操作的原⼦性。</li>
</ul>
<h1 id="⼀个线程如果出现了运⾏时异常会怎么样"><a href="#⼀个线程如果出现了运⾏时异常会怎么样" class="headerlink" title="⼀个线程如果出现了运⾏时异常会怎么样?"></a>⼀个线程如果出现了运⾏时异常会怎么样?</h1><ul>
<li>如果这个异常没有被捕获的话，这个线程就停⽌执⾏了。</li>
<li>另外重要的⼀点是：如果这个线程持有某个对象的监视器，那么这个对象监视器会被⽴即释放.</li>
</ul>
<h1 id="如何在两个线程之间共享数据"><a href="#如何在两个线程之间共享数据" class="headerlink" title="如何在两个线程之间共享数据?"></a>如何在两个线程之间共享数据?</h1><ul>
<li>通过在线程之间共享对象就可以了，然后通过wait&#x2F;notify&#x2F;notifyAll、await&#x2F;signal&#x2F;signalAll进⾏唤起和等待</li>
<li>⽐⽅说阻塞队列BlockingQueue就是为线程之间共享数据⽽设计的。</li>
</ul>
<h1 id="⽣产者消费者模型的作⽤是什么"><a href="#⽣产者消费者模型的作⽤是什么" class="headerlink" title="⽣产者消费者模型的作⽤是什么?"></a>⽣产者消费者模型的作⽤是什么?</h1><ul>
<li>通过平衡⽣产者的⽣产能⼒和消费者的消费能⼒来提升整个系统的运⾏效率，这是⽣产者消费者模型最重要的作⽤</li>
<li>解耦，这是⽣产者消费者模型附带的作⽤，解耦意味着⽣产者和消费者之间的联系少，联系越少越可以独⾃发展⽽不需要受到相互的制约。</li>
</ul>
<h1 id="怎么唤醒⼀个阻塞的线程"><a href="#怎么唤醒⼀个阻塞的线程" class="headerlink" title="怎么唤醒⼀个阻塞的线程?"></a>怎么唤醒⼀个阻塞的线程?</h1><ul>
<li>如果线程是因为调⽤了wait()、sleep()或者join()⽅法⽽导致的阻塞</li>
<li>suspend与resume，Java废弃suspend() 去挂起线程的原因，是因为suspend() 在导致线程暂停的同时，并不会释放任何锁资源。其他线程都⽆法访问被它占⽤的锁。直到对应的线程执⾏resume() ⽅法后，被挂起的线程才能继从⽽其它被阻塞在这个锁的线程才可以继续执⾏。但是，如果resume()操作出现在 suspend(之前执⾏，那么线程将⼀直处于挂起状态，同时⼀直占⽤锁，这就产⽣了死锁。⽽且，对于被挂起的线程，它的线程状态居然还是 Runnable。</li>
<li>wait与notify，wait与notify必须配合synchronized使⽤，因为调⽤之前必须持有锁，wait会⽴即释放锁，notify则是同步块执⾏完了才释放</li>
<li>await与singal，Condition类提供，⽽Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使⽤Lock锁后⽆法使⽤wait⽅法</li>
<li>park与unpark，LockSupport是⼀个⾮常⽅便实⽤的线程阻塞⼯具，它可以在线程任意位置让线程阻塞。和Thread.suspenf()相⽐，它弥补了由于resume()在前发⽣，导致线程⽆法继续执⾏的情况。和Object.wait()相⽐，它不需要先获得某个对象的锁，也不会抛出IException异常。可以唤醒指定线程。</li>
<li>如果线程遇到了IO阻塞，⽆能为⼒，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</li>
</ul>
<h1 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性?"></a>单例模式的线程安全性?</h1><ul>
<li>⾸先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建⼀次出来</li>
<li>单例模式有很多种的写法，我总结⼀下：<ul>
<li>饿汉式单例模式的写法：线程安全</li>
<li>懒汉式单例模式的写法：⾮线程安全</li>
<li>双检锁单例模式的写法：线程安全</li>
</ul>
</li>
</ul>
<h1 id="线程类的构造⽅法、静态块是被哪个线程调⽤的"><a href="#线程类的构造⽅法、静态块是被哪个线程调⽤的" class="headerlink" title="线程类的构造⽅法、静态块是被哪个线程调⽤的?"></a>线程类的构造⽅法、静态块是被哪个线程调⽤的?</h1><ul>
<li>线程类的构造⽅法、静态块是被new这个线程类所在的线程所调⽤的，⽽run⽅法⾥⾯的代码才是被线程⾃身所调⽤的。</li>
</ul>
<h1 id="同步⽅法和同步块，哪个是更好的选择"><a href="#同步⽅法和同步块，哪个是更好的选择" class="headerlink" title="同步⽅法和同步块，哪个是更好的选择?"></a>同步⽅法和同步块，哪个是更好的选择?</h1><ul>
<li>同步块是更好的选择，因为它不会锁住整个对象（当然也可以让它锁住整个对象）</li>
<li>同步⽅法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停⽌执⾏并需要等待获得这个对象上的锁。</li>
<li>synchronized(this)以及⾮static的synchronized⽅法（⾄于static synchronized⽅法请往下看），只能防⽌多个线程同时执⾏同⼀个对象的同步代码段。</li>
<li>如果要锁住多个对象⽅法，可以锁住⼀个固定的对象，或者锁住这个类的Class对象。</li>
<li>synchronized锁住的是括号⾥的对象，⽽不是代码</li>
<li>对于⾮static的synchronized⽅法，锁的就是对象本身也就是this。</li>
</ul>
<h1 id="如何检测死锁？怎么预防死锁？"><a href="#如何检测死锁？怎么预防死锁？" class="headerlink" title="如何检测死锁？怎么预防死锁？"></a>如何检测死锁？怎么预防死锁？</h1><ul>
<li>死锁是指两个或两个以上的进程在执⾏过程中，因争夺资源⽽造成的⼀种互相等待的现象，若⽆外⼒作⽤，它们都将⽆法推进下去。此时称系统处于死锁；</li>
</ul>
<h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><ul>
<li>互斥条件：进程对所分配到的资源不允许其他进程进⾏访问，若其他进程访问该资源，只能等待，直⾄占有该资源的进程使⽤完成后释放该资源</li>
<li>请求和保持条件：进程获得⼀定的资源之后，⼜对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但⼜对⾃⼰获得的资源保持不放</li>
<li>不可剥夺条件：是指进程已获得的资源，在未完成使⽤之前，不可被剥夺，只能在使⽤完后⾃⼰释放</li>
<li>环路等待条件：是指进程发⽣死锁后，若⼲进程之间形成⼀种头尾相接的循环等待资源关系</li>
</ul>
<h4 id="死锁产⽣的原因"><a href="#死锁产⽣的原因" class="headerlink" title="死锁产⽣的原因"></a>死锁产⽣的原因</h4><ul>
<li>因竞争资源发⽣死锁 现象：系统中供多个进程共享的资源的数⽬不⾜以满⾜全部进程的需要时，就会引起对诸资源的竞争⽽发⽣死锁现象</li>
<li>进程推进顺序不当发⽣死锁</li>
</ul>
<h4 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h4><ul>
<li>有两个容器，⼀个⽤于保存线程正在请求的锁，⼀个⽤于保存线程已经持有的锁</li>
<li>每次加锁之前都会做如下检测:<ul>
<li>检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来</li>
<li>遍历第⼀步中返回的线程，检查⾃⼰持有的锁是否正被其中任何⼀个线程请求，如果第⼆步返回真,表示出现了死锁</li>
</ul>
</li>
</ul>
<h4 id="死锁的解除与预防"><a href="#死锁的解除与预防" class="headerlink" title="死锁的解除与预防"></a>死锁的解除与预防</h4><ul>
<li>控制不要让四个必要条件成⽴。</li>
</ul>
<h1 id="HashMap在多线程环境下使⽤需要注意什么？"><a href="#HashMap在多线程环境下使⽤需要注意什么？" class="headerlink" title="HashMap在多线程环境下使⽤需要注意什么？"></a>HashMap在多线程环境下使⽤需要注意什么？</h1><ul>
<li>要注意死循环的问题，HashMap的put操作引发扩容，这个动作在多线程并发下会发⽣线程死循环的问题</li>
<li>多个线程同时扩容，造成数据丢失；</li>
<li>多线程扩容时导致Node链表形成环形结构造成.next()死循环，导致CPU利⽤率接近100%；</li>
</ul>
<h1 id="如何实现线程串⾏执⾏？"><a href="#如何实现线程串⾏执⾏？" class="headerlink" title="如何实现线程串⾏执⾏？"></a>如何实现线程串⾏执⾏？</h1><ul>
<li>为了控制线程执⾏的顺序，如ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执⾏三个线程，我们需要确定唤醒、等待的顺序</li>
<li>这时我们可以同时使⽤ Obj.wait()、Obj.notify()与synchronized(Obj)来实现这个⽬标。</li>
<li>线程中持有上⼀个线程类的对象锁以及⾃⼰的锁，由于这种依赖关系，该线程执⾏需要等待上个对象释放锁，从⽽保证类线程执⾏的顺序。</li>
<li>通常情况下，wait是线程在获取对象锁后，主动释放对象锁，同时本线程休眠，直到有其它线程调⽤对象的notify()唤醒该线程，才能继续获取对象锁，并继续执⾏</li>
<li>⽽notify()则是对等待对象锁的线程的唤醒操作</li>
<li>但值得注意的是notify()调⽤后，并不是⻢上就释放对象锁，⽽是在相应的synchronized(){}语句块执⾏结束</li>
<li>释放对象锁后，JVM会在执⾏wait()等待对象锁的线程中随机选取⼀线程，赋予其对象锁，唤醒线程，继续执⾏。</li>
</ul>
<h1 id="可以运⾏时kill掉⼀个线程吗？"><a href="#可以运⾏时kill掉⼀个线程吗？" class="headerlink" title="可以运⾏时kill掉⼀个线程吗？"></a>可以运⾏时kill掉⼀个线程吗？</h1><ul>
<li>不可以</li>
<li>只有当线程run⽅法或者主线程main⽅法结束，⼜或者抛出异常时，线程才会结束⽣命周期。</li>
</ul>
<h1 id="关于synchronized"><a href="#关于synchronized" class="headerlink" title="关于synchronized"></a>关于synchronized</h1><ul>
<li>在某个对象的所有synchronized⽅法中,在某个时刻只能有⼀个唯⼀的⼀个线程去访问这些synchronized⽅法</li>
<li>如果⼀个⽅法是synchronized⽅法,那么该synchronized关键字表示给当前对象上锁(即this)相当于synchronized(this){}</li>
<li>如果⼀个synchronized⽅法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管⽣成多少对象,其对应的class对象只有⼀个)</li>
</ul>
<h1 id="数据库死锁机制和解决⽅案"><a href="#数据库死锁机制和解决⽅案" class="headerlink" title="数据库死锁机制和解决⽅案"></a>数据库死锁机制和解决⽅案</h1><ul>
<li>死锁：死锁是指两个或者两个以上的事务在执⾏过程中，因争夺锁资源⽽造成的⼀种互相等待的现象。</li>
<li>处理机制：解决死锁最有⽤最简单的⽅法是不要有等待，将任何等待都转化为回滚，并且事务重新开始，但是有可能影响并发性能。<ul>
<li>超时回滚，innodb_lock_wait_time设置超时时间；</li>
<li>wait-for-graph⽅法：跟超时回滚⽐起来，这是⼀种更加主动的死锁检测⽅式。InnoDB引擎也采⽤这种⽅式。</li>
</ul>
</li>
</ul>
<h1 id="spring单例为什么没有安全问题-ThreadLocal"><a href="#spring单例为什么没有安全问题-ThreadLocal" class="headerlink" title="spring单例为什么没有安全问题(ThreadLocal)"></a>spring单例为什么没有安全问题(ThreadLocal)</h1><ul>
<li>ThreadLocal：spring使⽤ThreadLocal解决线程安全问题</li>
<li>ThreadLocal会为每⼀个线程提供⼀个独⽴的变量副本，从⽽隔离了多个线程对数据的访问冲突</li>
<li>单例：⽆状态的Bean(⽆状态就是⼀次操作，不能保存数据。⽆状态对象(Stateless Bean)，就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。)适合⽤不变模式，技术就是单例模式，这样可以共享实例，提⾼性能。</li>
</ul>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><ul>
<li>使⽤场景：使⽤线程池，以提⾼服务器性能；</li>
<li>组成：<ul>
<li>线程池管理器（ThreadPool）：⽤于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li>
<li>⼯作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执⾏任务；</li>
<li>任务接⼝（Task）：每个任务必须实现的接⼝，以供⼯作线程调度任务的执⾏，它主要规定了任务的⼊⼝，任务执⾏完后的收尾⼯作，任务的执⾏状态等；</li>
<li>任务队列（taskQueue）：⽤于存放没有处理的任务。提供⼀种缓冲机制。</li>
</ul>
</li>
<li>原理：线程池技术正是关注如何缩短或调整T1,T3时间的技术，从⽽提⾼服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者⼀些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</li>
<li>⼯作流程：<ul>
<li>线程池刚创建时，⾥⾯没有⼀个线程(也可以设置参数prestartAllCoreThreads启动预期数量主线程)</li>
<li>任务队列是作为参数传进来的</li>
<li>不过，就算队列⾥⾯有任务，线程池也不会⻢上执⾏它们。</li>
<li>当调⽤ execute() ⽅法添加⼀个任务时，线程池会做如下判断：<ul>
<li>如果正在运⾏的线程数量⼩于 corePoolSize，那么⻢上创建线程运⾏这个任务；</li>
<li>如果正在运⾏的线程数量⼤于或等于 corePoolSize，那么将这个任务放⼊队列；</li>
<li>如果这时候队列满了，⽽且正在运⾏的线程数量⼩于 maximumPoolSize，那么还是要创建⾮核⼼线程⽴刻运⾏这个任务；</li>
<li>如果队列满了，⽽且正在运⾏的线程数量⼤于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>
</ul>
</li>
<li>当⼀个线程完成任务时，它会从队列中取下⼀个任务来执⾏。</li>
<li>当⼀个线程⽆事可做，超过⼀定的时间（keepAliveTime）时，线程池会判断，如果当前运⾏的线程数⼤于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的⼤⼩。</li>
</ul>
</li>
</ul>
<h1 id="java线程如何启动"><a href="#java线程如何启动" class="headerlink" title="java线程如何启动"></a>java线程如何启动</h1><ul>
<li>继承Thread类；</li>
<li>实现Runnable接⼝</li>
<li>在函数体使⽤</li>
<li>⽐较：<ul>
<li>实现Runnable接⼝优势：<ul>
<li>适合多个相同的程序代码的线程去处理同⼀个资源</li>
<li>可以避免java中的单继承的限制</li>
<li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独⽴。</li>
</ul>
</li>
<li>继承Thread类优势：<ul>
<li>可以将线程类抽象出来，当需要使⽤抽象⼯⼚模式设计时。</li>
<li>多线程同步</li>
</ul>
</li>
<li>在函数体使⽤优势<ul>
<li>⽆需继承thread或者实现Runnable，缩⼩作⽤域。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="java中加锁的⽅式有哪些-如何实现怎么个写法"><a href="#java中加锁的⽅式有哪些-如何实现怎么个写法" class="headerlink" title="java中加锁的⽅式有哪些,如何实现怎么个写法"></a>java中加锁的⽅式有哪些,如何实现怎么个写法</h1><ul>
<li>java中有两种锁<ul>
<li>⼀种是⽅法锁或者对象锁(在⾮静态⽅法或者代码块上加锁)</li>
<li>第⼆种是类锁(在静态⽅法或者class上加锁)；</li>
</ul>
</li>
<li>注意<ul>
<li>其他线程可以访问未加锁的⽅法和代码</li>
<li>synchronized同时修饰静态⽅法和实例⽅法，但是运⾏结果是交替进⾏的，这证明了类锁和对象锁是两个不⼀样的锁，控制着不同的区域，它们是互不⼲扰的。</li>
</ul>
</li>
</ul>
<h1 id="如何保证数据不丢失："><a href="#如何保证数据不丢失：" class="headerlink" title="如何保证数据不丢失："></a>如何保证数据不丢失：</h1><ul>
<li>使⽤消息队列，消息持久化；</li>
<li>添加标志位：未处理 0，处理中 1，已处理 2。定时处理。</li>
</ul>
<h1 id="ThreadLocal为什么会发⽣内存泄漏？"><a href="#ThreadLocal为什么会发⽣内存泄漏？" class="headerlink" title="ThreadLocal为什么会发⽣内存泄漏？"></a>ThreadLocal为什么会发⽣内存泄漏？</h1><ul>
<li>ThreadLocal的实现是这样的：每个Thread 维护⼀个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。</li>
<li>也就是说 ThreadLocal 本身并不存储值，它只是作为⼀个 key 来让线程从 ThreadLocalMap 获取 value</li>
<li>ThreadLocalMap使⽤ThreadLocal的弱引⽤作为key，如果⼀个ThreadLocal没有外部强引⽤来引⽤它，那么系统 GC的时候，这个ThreadLocal势必会被回收，这样⼀来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会⼀直存在⼀条强引⽤链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远⽆法回收，造成内存泄漏。</li>
<li>预防办法：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap⾥所有key为null的value。</li>
<li>但是这些被动的预防措施并不能保证不会内存泄漏：<ul>
<li>使⽤static的ThreadLocal，延⻓了ThreadLocal的⽣命周期，可能导致内存泄漏。</li>
<li>分配使⽤了ThreadLocal⼜不再调⽤get(),set(),remove()⽅法，那么就会导致内存泄漏，因为这块内存⼀直存在。</li>
</ul>
</li>
</ul>
<h1 id="jdk8中对ConcurrentHashmap的改进"><a href="#jdk8中对ConcurrentHashmap的改进" class="headerlink" title="jdk8中对ConcurrentHashmap的改进"></a>jdk8中对ConcurrentHashmap的改进</h1><ul>
<li>Java 7为实现并⾏访问，引⼊了Segment这⼀结构，实现了分段锁，理论上最⼤并发度与Segment个数相等。</li>
<li>Java 8为进⼀步提⾼并发性，摒弃了分段锁的⽅案，⽽是直接使⽤⼀个⼤的数组。同时为了提⾼哈希碰撞下的寻址性能</li>
<li>Java 8在链表⻓度超过⼀定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红⿊树（寻址时间复杂度为O(long(N))）。</li>
</ul>
<h1 id="concurrent包下有哪些类？"><a href="#concurrent包下有哪些类？" class="headerlink" title="concurrent包下有哪些类？"></a>concurrent包下有哪些类？</h1><ul>
<li>ConcurrentHashMap、Future、FutureTask、AtomicInteger…</li>
</ul>
<h1 id="线程a-b-c-d运⾏任务，怎么保证当a-b-c线程执⾏完再执⾏d线程"><a href="#线程a-b-c-d运⾏任务，怎么保证当a-b-c线程执⾏完再执⾏d线程" class="headerlink" title="线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?"></a>线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?</h1><ul>
<li>CountDownLatch类<ul>
<li>⼀个同步辅助类，常⽤于某个条件发⽣后才能执⾏后续进程。给定计数初始化CountDownLatch，调⽤countDown(）⽅法，在计数到达零之前，await⽅法⼀直受阻塞。</li>
<li>重要⽅法为countdown()与await()；</li>
</ul>
</li>
<li>join⽅法<ul>
<li>将线程B加⼊到线程A的尾部，当A执⾏完后B才执⾏。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Thread t = new Thread(&quot;t1&quot;);</span><br><span class="line">    Thread t2 = new Thread(&quot;t2&quot;);</span><br><span class="line">    t.start();</span><br><span class="line">    t.join();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>notify、wait⽅法，Java中的唤醒与等待⽅法<ul>
<li>关键为synchronized代码块，参数线程间应相同，也常⽤Object作为参数。</li>
</ul>
</li>
</ul>
<h1 id="⾼并发系统如何做性能优化？如何防⽌库存超卖？"><a href="#⾼并发系统如何做性能优化？如何防⽌库存超卖？" class="headerlink" title="⾼并发系统如何做性能优化？如何防⽌库存超卖？"></a>⾼并发系统如何做性能优化？如何防⽌库存超卖？</h1><h4 id="⾼并发系统性能优化"><a href="#⾼并发系统性能优化" class="headerlink" title="⾼并发系统性能优化"></a>⾼并发系统性能优化</h4><ul>
<li>优化程序，优化服务配置，优化系统配置</li>
<li>尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。</li>
<li>⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。</li>
<li>优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。</li>
<li>优化数据库结构，多做索引，提⾼查询效率。</li>
<li>统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。</li>
<li>能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。</li>
<li>解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。</li>
</ul>
<h4 id="防⽌库存超卖"><a href="#防⽌库存超卖" class="headerlink" title="防⽌库存超卖"></a>防⽌库存超卖</h4><ul>
<li>悲观锁：在更新库存期间加锁，不允许其它线程修改；<ul>
<li>数据库锁：select xxx for update；</li>
<li>分布式锁；</li>
</ul>
</li>
<li>乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。</li>
<li>redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。</li>
<li>消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。</li>
<li>总结：总的来说，不能把压⼒放在数据库上，所以使⽤ “select xxx for update” 的⽅式在⾼并发的场景下是不可⾏的</li>
<li>FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤</li>
<li>所以相对来说，我会倾向于选择：乐观锁 &#x2F; 缓存锁 &#x2F; 分布式锁的⽅式。</li>
</ul>
<h1 id="线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？"><a href="#线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？" class="headerlink" title="线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？"></a>线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？</h1><ul>
<li>⼯⼚⽅法作⽤：ThreadPoolExecutor类就是Executor的实现类，但ThreadPoolExecutor在使⽤上并不是那么⽅便，在实例化时需要传⼊很多歌参数，还要考虑线程的并发数等与线程池运⾏效率有关的参数，所以官⽅建议使⽤Executors工厂类来创建线程池对象。</li>
</ul>
<h1 id="线程间的通信方式-1"><a href="#线程间的通信方式-1" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><ul>
<li>共享内存机制和消息通信机制</li>
</ul>
<h4 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h4><ul>
<li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。</li>
<li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。</li>
<li>这种方式，本质上就是“共享内存”式的通信</li>
<li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</li>
</ul>
<p> </p>
<h4 id="while轮询的方式-1"><a href="#while轮询的方式-1" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul>
<li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()&#x3D;&#x3D;5)是否成立 ，从而实现了线程间的通信</li>
<li>但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立</li>
<li>这种方式还存在另外一个问题：轮询的条件的可见性问题，关于内存可见性问题</li>
<li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li>
</ul>
<p> </p>
<h4 id="wait-notify机制-1"><a href="#wait-notify机制-1" class="headerlink" title="wait&#x2F;notify机制"></a>wait&#x2F;notify机制</h4><ul>
<li>线程A要等待某个条件满足时(list.size()&#x3D;&#x3D;5)，才执行操作</li>
<li>线程B则向list中添加元素，改变list 的size。</li>
<li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？</li>
<li>这里用到了Object类的 wait() 和 notify() 方法。</li>
<li>当条件未满足时(list.size() !&#x3D;5)，线程A调用wait() 放弃CPU，并进入阻塞状态。不像②while轮询那样占用CPU</li>
<li>当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。</li>
<li>这种方式的一个好处就是CPU的利用率提高了。</li>
<li>但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li>
</ul>
<p> </p>
<h4 id="管道通信-1"><a href="#管道通信-1" class="headerlink" title="管道通信"></a>管道通信</h4><ul>
<li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li>
</ul>
<h1 id="线程池的定义和优点"><a href="#线程池的定义和优点" class="headerlink" title="线程池的定义和优点"></a>线程池的定义和优点</h1><ul>
<li>线程池，从字面含义来看，是指管理一组同构工作线程的资源池</li>
<li>线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务</li>
<li>工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。</li>
<li>“在线程池中执行任务“”比“为每个线程分配一个任务”优势更多</li>
<li>通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销</li>
<li>另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性</li>
<li>通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</li>
</ul>
<h4 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h4><ul>
<li>默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） </li>
<li>当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  </li>
<li>当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  </li>
<li>当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。</li>
<li>当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 </li>
<li>如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。</li>
</ul>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><ul>
<li>如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来</li>
<li>在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待</li>
<li>常见的工作队列有以下几种，前三种用的最多。<ul>
<li>ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。</li>
<li>LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界&#x2F;无界队列，先进先出。</li>
<li>SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue才有实际价值.</li>
<li>PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。</li>
<li>DelayedWorkQueue：延迟的工作队列，无界队列。</li>
</ul>
</li>
</ul>
<h4 id="饱和策略（拒绝策略）"><a href="#饱和策略（拒绝策略）" class="headerlink" title="饱和策略（拒绝策略）"></a>饱和策略（拒绝策略）</h4><ul>
<li>当有界队列被填满后，饱和策略开始发挥作用</li>
<li>ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改</li>
<li>如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略</li>
<li>饱和策略有以下四种，一般使用默认的AbortPolicy。<ul>
<li>AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</li>
<li>DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。</li>
<li>DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。</li>
<li>CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。</li>
</ul>
</li>
</ul>
<h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><ul>
<li>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的</li>
<li>在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法</li>
<li>Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。<ul>
<li>DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。</li>
<li>PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。</li>
</ul>
</li>
<li>自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。</li>
</ul>
<h1 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？-1"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？-1" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h1><ul>
<li>可以用join方法实现。</li>
</ul>
<h1 id="在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"><a href="#在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？" class="headerlink" title="在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"></a>在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</h1><ul>
<li>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁</li>
<li>它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞</li>
</ul>
<h1 id="你将如何使用threaddump？你将如何分析Thread-dump？-1"><a href="#你将如何使用threaddump？你将如何分析Thread-dump？-1" class="headerlink" title="你将如何使用threaddump？你将如何分析Thread dump？"></a>你将如何使用threaddump？你将如何分析Thread dump？</h1><ul>
<li>在UNIX中你可以使用kill -3，然后thread dump将会打印日志</li>
<li>在windows中你可以使用”CTRL+Break”</li>
</ul>
<h1 id="violatile-关键字的作用？"><a href="#violatile-关键字的作用？" class="headerlink" title="violatile 关键字的作用？"></a>violatile 关键字的作用？</h1><ul>
<li>多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据</li>
<li>使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言</li>
<li>volatile 的一个重要作用就是和CAS结合，保证了原子性</li>
</ul>
<h1 id="怎么控制同一时间只有-3-个线程运行？"><a href="#怎么控制同一时间只有-3-个线程运行？" class="headerlink" title="怎么控制同一时间只有 3 个线程运行？"></a>怎么控制同一时间只有 3 个线程运行？</h1><p>用 Semaphore。</p>
<h1 id="线程池启动线程-submit-和-execute-方法有什么不同？"><a href="#线程池启动线程-submit-和-execute-方法有什么不同？" class="headerlink" title="线程池启动线程 submit()和 execute()方法有什么不同？"></a>线程池启动线程 submit()和 execute()方法有什么不同？</h1><ul>
<li>execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多。</li>
<li>submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常。</li>
</ul>
<h1 id="什么是原子性、可见性、有序性？"><a href="#什么是原子性、可见性、有序性？" class="headerlink" title="什么是原子性、可见性、有序性？"></a>什么是原子性、可见性、有序性？</h1><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul>
<li>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作</li>
<li>在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量 n++100 次，如果 n 初始值为 0，n 最后的值应该是 100，所以说它们是互不干扰的，这就是传说的中的原子性。但 n++并不是原子性的操作，要使用 AtomicInteger 保证原子性。</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><ul>
<li>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值</li>
<li>在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的值，而在多线程编程中就不一定了</li>
<li>每个线程都有自己的工作内存，线程先把共享变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值</li>
<li>像CPU 的缓存优化、硬件优化、指令重排及对 JVM 编译器的优化，都会出现可见性的问题。</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul>
<li>我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了</li>
<li>为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即<br>后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果</li>
<li>所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果</li>
<li>虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，只是重排序会影响多线程执行的结果。</li>
</ul>
<h1 id="多线程上下文切换是什么意思？-1"><a href="#多线程上下文切换是什么意思？-1" class="headerlink" title="多线程上下文切换是什么意思？"></a>多线程上下文切换是什么意思？</h1><p>多- 线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</p>
<h1 id="Java-中堆和栈有什么不同？"><a href="#Java-中堆和栈有什么不同？" class="headerlink" title="Java 中堆和栈有什么不同？"></a>Java 中堆和栈有什么不同？</h1><ul>
<li>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的</li>
<li>而堆是所有线程共享的一片公用内存区域</li>
<li>对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</li>
</ul>
<h1 id="你如何在-Java-中获取线程堆栈？-1"><a href="#你如何在-Java-中获取线程堆栈？-1" class="headerlink" title="你如何在 Java 中获取线程堆栈？"></a>你如何在 Java 中获取线程堆栈？</h1><ul>
<li>对于不同的操作系统，有多种方法来获得 Java 进程的线程堆栈</li>
<li>当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台</li>
<li>在 Windows 你可以使用 Ctrl + Break 组合键来获取线程堆栈，Linux 下用 kill -3 命令</li>
<li>你也可以用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。</li>
</ul>
<h1 id="什么是阻塞式方法？-1"><a href="#什么是阻塞式方法？-1" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h1><ul>
<li>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接</li>
<li>这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回</li>
<li>此外，还有异步和非阻塞式方法在任务完成前就返回。</li>
</ul>
<h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。-1"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。-1" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul>
<li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</li>
<li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</li>
</ul>
<h1 id="我们可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#我们可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="我们可以使用CocurrentHashMap来代替Hashtable吗？"></a>我们可以使用CocurrentHashMap来代替Hashtable吗？</h1><ul>
<li>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。</li>
<li>ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。</li>
<li>它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。</li>
<li>因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。</li>
<li>简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</li>
</ul>
<h1 id="sleep-和yield-有什么区别"><a href="#sleep-和yield-有什么区别" class="headerlink" title="sleep()和yield()有什么区别?"></a>sleep()和yield()有什么区别?</h1><ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li>
<li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li>
<li>sleep()方法比yield()方法（跟操作系统相关）具有更好的可移植性。</li>
</ul>
<p> </p>
<h1 id="如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全-1"><a href="#如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全-1" class="headerlink" title="如何保证集合是线程安全的?ConcurrentHashMap 如何实现高效的线程安全?"></a>如何保证集合是线程安全的?ConcurrentHashMap 如何实现高效的线程安全?</h1><ul>
<li>Java提供了不同层面的线程安全支持。在传统集合框架内部,除了Hashtable Vector等同步容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等。具体选择要看开发的场景需求,总体来说,并发包内提供的容器通用场景,远优于早期的简单同步实现。</li>
</ul>
<h1 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h1><ul>
<li>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</li>
</ul>
<h1 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h1><ul>
<li>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</li>
</ul>
<h1 id="volatile-修饰符的有过什么实践？"><a href="#volatile-修饰符的有过什么实践？" class="headerlink" title="volatile 修饰符的有过什么实践？"></a>volatile 修饰符的有过什么实践？</h1><ul>
<li>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是 64 位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（writebarrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</li>
</ul>
<h1 id="volatile-类型变量提供什么保证？"><a href="#volatile-类型变量提供什么保证？" class="headerlink" title="volatile 类型变量提供什么保证？"></a>volatile 类型变量提供什么保证？</h1><ul>
<li>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT 为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和long 就是原子的。</li>
</ul>
<h1 id="10-个线程和-2-个线程的同步代码，哪个更容易写？"><a href="#10-个线程和-2-个线程的同步代码，哪个更容易写？" class="headerlink" title="10 个线程和 2 个线程的同步代码，哪个更容易写？"></a>10 个线程和 2 个线程的同步代码，哪个更容易写？</h1><ul>
<li>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</li>
</ul>
<h1 id="你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</h1><ul>
<li>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The standard idiom for using the wait method</span><br><span class="line">synchronized (obj) &#123;</span><br><span class="line">while (condition does not hold)</span><br><span class="line">obj.wait(); // (Releases lock, and reacquires on wakeup)</span><br><span class="line">... // Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h1><ul>
<li>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。</li>
<li>一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</li>
</ul>
<h1 id="如何创建守护线程？"><a href="#如何创建守护线程？" class="headerlink" title="如何创建守护线程？"></a>如何创建守护线程？</h1><ul>
<li>使用 Thread 类的 setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用 start()方法前调用这个方法，否则会抛出IllegalThreadStateException 异常。</li>
</ul>
<h1 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h1><ul>
<li>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li>
</ul>
<h1 id="你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？"><a href="#你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？" class="headerlink" title="你如何确保 main()方法所在的线程是 Java 程序最后结束的线程？"></a>你如何确保 main()方法所在的线程是 Java 程序最后结束的线程？</h1><ul>
<li>我们可以使用 Thread 类的 join()方法来确保所有程序创建的线程在 main()方法退出前结束。</li>
</ul>
<h1 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h1><ul>
<li>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。</li>
<li>java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li>
</ul>
<h1 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h1><ul>
<li>我们可以使用 Thread 类的 Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。</li>
</ul>
<h1 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h1><ul>
<li>Volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子性的。</li>
<li>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
<h1 id="Java-中的-ReadWriteLock-是什么？"><a href="#Java-中的-ReadWriteLock-是什么？" class="headerlink" title="Java 中的 ReadWriteLock 是什么？"></a>Java 中的 ReadWriteLock 是什么？</h1><ul>
<li>读写锁是用来提升并发程序性能的锁分离技术的成果。</li>
</ul>
<h1 id="Java-中的同步集合与并发集合有什么区别？"><a href="#Java-中的同步集合与并发集合有什么区别？" class="headerlink" title="Java 中的同步集合与并发集合有什么区别？"></a>Java 中的同步集合与并发集合有什么区别？</h1><ul>
<li>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</li>
</ul>
<h1 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a>Java 中 interrupted 和 isInterrupted 方法的区别？</h1><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><ul>
<li>interrupt 方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</li>
<li>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</li>
</ul>
<h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted"></a>interrupted</h4><ul>
<li>查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</li>
<li>isInterrupted仅仅是查询当前线程的中断状态</li>
</ul>
<h1 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h1><ul>
<li>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：<ul>
<li>在单线程环境下不能改变程序运行的结果；</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
</li>
<li>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</li>
</ul>
<h1 id="CopyOnWriteArrayList-可以用于什么应用场景？"><a href="#CopyOnWriteArrayList-可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList 可以用于什么应用场景？"></a>CopyOnWriteArrayList 可以用于什么应用场景？</h1><ul>
<li>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</li>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc；</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</li>
<li>CopyOnWriteArrayList 透露的思想<ul>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ul>
</li>
</ul>
<h1 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h1><ul>
<li>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</li>
</ul>
<h1 id="什么是竞争条件？你怎样发现和解决竞争？"><a href="#什么是竞争条件？你怎样发现和解决竞争？" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争？"></a>什么是竞争条件？你怎样发现和解决竞争？</h1><ul>
<li>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。</li>
</ul>
<h1 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h1><ul>
<li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor 接口对象能执行我们的线程任务。</li>
<li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>
<li>使用 ThreadPoolExecutor 可以创建自定义线程池。</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。</li>
</ul>
<h1 id="在-java-中守护线程和本地线程区别？"><a href="#在-java-中守护线程和本地线程区别？" class="headerlink" title="在 java 中守护线程和本地线程区别？"></a>在 java 中守护线程和本地线程区别？</h1><ul>
<li>java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</li>
<li>任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。</li>
<li>两者的区别：<ul>
<li>唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</li>
</ul>
</li>
<li>扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</li>
</ul>
<h1 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h1><ul>
<li>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</li>
</ul>
<h1 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h1><ul>
<li>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</li>
</ul>
<h1 id="concurrenthashmap-有啥优势，1-7，1-8-区别？"><a href="#concurrenthashmap-有啥优势，1-7，1-8-区别？" class="headerlink" title="concurrenthashmap 有啥优势，1.7，1.8 区别？"></a>concurrenthashmap 有啥优势，1.7，1.8 区别？</h1><ul>
<li>Concurrenthashmap 线程安全的，1.7 是在 jdk1.7 中采用 Segment + HashEntry 的方式进行实现的，lock 加在 Segment 上面。1.7size 计算是先采用不加锁的方式，连续计算元素的个数，最多计算 3 次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个 Segment 进行加锁，再计算一次元素的个数；</li>
<li>1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node + CAS + Synchronized 来保证并发安全进行实现，1.8 中使用一个 volatile 类型的变量 baseCount 记录元素的个数，当插入新数据或则删除数据时，会通过 addCount()方法更新 baseCount，通过累加 baseCount 和CounterCell 数组中的数量，即可得到元素的总个数；</li>
</ul>
<h1 id="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"><a href="#高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"></a>高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h1><ul>
<li>高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</li>
<li>并发不高、任务执行时间长的业务要区分开看： 　　<ul>
<li>假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 　　</li>
<li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li>
</ul>
</li>
<li>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li>
</ul>
<h1 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h1><h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h4><ul>
<li>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。</li>
<li>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</li>
</ul>
<h4 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h4><ul>
<li>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。</li>
</ul>
<h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h4><p>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。<br>保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。</p>
<h1 id="Java中创建线程主要有三种方式"><a href="#Java中创建线程主要有三种方式" class="headerlink" title="Java中创建线程主要有三种方式"></a>Java中创建线程主要有三种方式</h1><h4 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h4><ul>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
<li>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。getName()方法返回调用该方法的线程的名字。</li>
</ul>
<h4 id="通过Runnable接口创建线程类"><a href="#通过Runnable接口创建线程类" class="headerlink" title="通过Runnable接口创建线程类"></a>通过Runnable接口创建线程类</h4><ul>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 </li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ul>
<h4 id="通过Callable和Future创建线程"><a href="#通过Callable和Future创建线程" class="headerlink" title="通过Callable和Future创建线程"></a>通过Callable和Future创建线程</h4><ul>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</li>
</ul>
<h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><ul>
<li>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</li>
<li>hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。</li>
<li>hashMap允许空键值，而hashTable不允许。</li>
<li>注意：<ul>
<li>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</li>
<li>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</li>
</ul>
</li>
</ul>
<h1 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h1><ul>
<li>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。</li>
<li>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。</li>
<li>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象</li>
</ul>
<h1 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h1><ul>
<li>ConcurrentHashMap是线程安全的HashMap的实现。<ul>
<li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。</li>
<li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li>
</ul>
</li>
<li>ConcurrentHashMap 的工作原理及代码实现<ul>
<li>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。</li>
<li>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，16。</li>
<li>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/publishes/32257fddc744.html</url>
    <content><![CDATA[<h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul>
<li>区别：<ul>
<li>InnoDB支持事务，MyISAM不支持</li>
<li>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>
<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</li>
<li>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</li>
<li>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>
</ul>
</li>
<li>如何选择：<ul>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ul>
</li>
</ul>
<h4 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h4><ul>
<li>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）</li>
<li>如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</li>
</ul>
<h4 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h4><ul>
<li>插入缓冲（insert buffer）</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h1 id="⾏锁，表锁，乐观锁，悲观锁？"><a href="#⾏锁，表锁，乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁，乐观锁，悲观锁？"></a>⾏锁，表锁，乐观锁，悲观锁？</h1><ul>
<li>⾏锁：数据库表中某一⾏被锁住。</li>
<li>表锁：整个数据库表被锁住。</li>
<li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不不会修改，具体实现是给表增加⼀个版本号的字段，在执行update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。</li>
<li>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。读数据的时候会上锁，直到update完成才释放锁，使⽤悲观锁要注意不要锁住整个表。</li>
</ul>
<h1 id="数据库隔离级别是什什么？有什么作用？"><a href="#数据库隔离级别是什什么？有什么作用？" class="headerlink" title="数据库隔离级别是什什么？有什么作用？"></a>数据库隔离级别是什什么？有什么作用？</h1><ul>
<li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。 这种隔离级别会产⽣生脏读，不可重复读和幻读。</li>
<li>ISOLATIONREADCOMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外⼀个事务不能读取该 事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li>
<li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了了保证一个事务不能读取另⼀个事务未提交的数据外，还保证了了避免不可重复读。</li>
<li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理理为顺序执行。除了防止脏读， 不可重复读外，还避免了幻读。</li>
</ul>
<h1 id="MySQL主备同步的基本原理理。"><a href="#MySQL主备同步的基本原理理。" class="headerlink" title="MySQL主备同步的基本原理理。"></a>MySQL主备同步的基本原理理。</h1><ul>
<li>mysql主备复制实现分成三个步骤：<ul>
<li>master将改变记录到⼆进制⽇志(binary log) 中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</li>
<li>slave将master的binary log events拷⻉到它的中继日志(relay log) ；</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ul>
</li>
</ul>
<h1 id="select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？"><a href="#select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</h1><ul>
<li>sql语句句执⾏行行顺序如下：</li>
<li>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</li>
</ul>
<h1 id="如何优化数据库性能"><a href="#如何优化数据库性能" class="headerlink" title="如何优化数据库性能"></a>如何优化数据库性能</h1><ul>
<li>索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署</li>
<li>选择合适的数据库引擎，合理使用索引</li>
<li>分页获取数据，只获取需要的字段</li>
<li>优化业务逻辑，减少数据库IO</li>
<li>分库分表</li>
<li>部署主从数据库</li>
<li>升级硬件</li>
</ul>
<h1 id="SQL什么情况下不会使用索引"><a href="#SQL什么情况下不会使用索引" class="headerlink" title="SQL什么情况下不会使用索引"></a>SQL什么情况下不会使用索引</h1><ul>
<li>不包含，不等于，函数</li>
<li>select * 可能导致不走索引；</li>
<li>空值会导致不走索引，因为hashset不能存空值；</li>
<li>索引列有函数运算，不走索引，可以在索引列列建⽴立⼀一个函数的索引。</li>
<li>隐式转换可能导致不走索引；</li>
<li>表的数据库小或者需要选择大部分数据，不走索引；</li>
<li>!&#x3D;或者&lt;&gt;可能导致不走索引；</li>
<li>字符型的索引列列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式</li>
<li>like ‘%liu’ 百分号在前不走索引；</li>
<li>not in, not exist不走索引；</li>
</ul>
<h1 id="一般在什什么字段上建索引"><a href="#一般在什什么字段上建索引" class="headerlink" title="一般在什什么字段上建索引"></a>一般在什什么字段上建索引</h1><ul>
<li>过滤数据最多的字段</li>
<li>表的主键、外键必须有索引；</li>
<li>数据量量超过300的表应该有索引；</li>
<li>经常与其他表进行行连接的表，在连接字段上应该建立索引；</li>
<li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>索引应该建在选择性高的字段上；</li>
<li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li>
<li>如何从一张表中查出name字段不包含”XYZ”的所有行？</li>
</ul>
<h1 id="如何解决高并发减库存问题"><a href="#如何解决高并发减库存问题" class="headerlink" title="如何解决高并发减库存问题"></a>如何解决高并发减库存问题</h1><ul>
<li>消息队列，异步处理，减库存加锁</li>
</ul>
<h1 id="数据库事务的几种粒度；"><a href="#数据库事务的几种粒度；" class="headerlink" title="数据库事务的几种粒度；"></a>数据库事务的几种粒度；</h1><ul>
<li>表锁定：对整个表的锁定。</li>
<li>行锁定：只锁定进⾏行更改的行，例如：insert，update，delete，都隐式采用行锁定。</li>
<li>数据库锁机制可分为多种粒度的： 数据库，表，页面，行</li>
<li>粒度越大，DBMS管理越容易，但是实现并发处理的能力就越差，表，页面，行</li>
</ul>
<h1 id="mysql调优"><a href="#mysql调优" class="headerlink" title="mysql调优"></a>mysql调优</h1><ul>
<li>explain select语句；</li>
<li>当只要一条数据时使用limit 1；</li>
<li>为搜索字段建索引；</li>
<li>避免select *；</li>
<li>字段尽量使用not null；</li>
<li>垂直分割；</li>
<li>拆分大的delete和insert语句：delete和insert会锁表；</li>
<li>分表分库分区</li>
</ul>
<h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><ul>
<li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li>
<li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li>
<li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li>
<li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><ul>
<li>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页</li>
<li>然后redo log按照时间或者空间等条件进行落盘</li>
<li>undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了</li>
<li>此时，事务还未 COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤用undo log进⾏事务回滚</li>
<li>事务执行COMMIT操作时，会将本事务相关的所有redo log都进⾏落盘，只有所有redo log落盘成功，才算COMMIT成功</li>
<li>然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发⽣了崩溃，则只使⽤用redo log恢复数据。</li>
</ul>
<h1 id="让你设计一个索引，你会怎么设计？"><a href="#让你设计一个索引，你会怎么设计？" class="headerlink" title="让你设计一个索引，你会怎么设计？"></a>让你设计一个索引，你会怎么设计？</h1><ul>
<li>mysql默认存储引擎innodb只显式支持B树索引</li>
<li>对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</li>
</ul>
<h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><ul>
<li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。<ul>
<li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li>
<li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li>
</ul>
</li>
<li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放<ul>
<li>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</li>
</ul>
</li>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li>
<li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置<ul>
<li>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销</li>
<li>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li>
</ul>
</li>
</ul>
<h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul>
<li>数据索引的存储是有序的</li>
<li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li>
<li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li>
</ul>
<h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul>
<li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li>
<li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li>
</ul>
<h4 id="哈希索引的优势"><a href="#哈希索引的优势" class="headerlink" title="哈希索引的优势"></a>哈希索引的优势</h4><ul>
<li>等值查询，哈希索引具有绝对优势</li>
<li>前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题</li>
</ul>
<h4 id="哈希索引不适用的场景"><a href="#哈希索引不适用的场景" class="headerlink" title="哈希索引不适用的场景"></a>哈希索引不适用的场景</h4><ul>
<li>不支持范围查询</li>
<li>不支持索引完成排序</li>
<li>不支持联合索引的最左前缀匹配规则</li>
<li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<ul>
<li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主</li>
<li>没有范围查询、没有排序的时候，特别适合采用哈希索引</li>
<li>仅等值查询<ul>
<li>select id, name from table where name&#x3D;’李明’;</li>
</ul>
</li>
</ul>
</li>
<li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li>
<li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li>
<li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li>
<li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li>
<li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read&#x2F;write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li>
</ul>
<h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul>
<li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li>
<li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li>
</ul>
<h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><h4 id="B-的磁盘读写代价更低。"><a href="#B-的磁盘读写代价更低。" class="headerlink" title="B+的磁盘读写代价更低。"></a>B+的磁盘读写代价更低。</h4><ul>
<li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li>
<li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多</li>
<li>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li>
</ul>
<h4 id="B-tree的查询效率更加稳定。"><a href="#B-tree的查询效率更加稳定。" class="headerlink" title="B+-tree的查询效率更加稳定。"></a>B+-tree的查询效率更加稳定。</h4><ul>
<li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引</li>
<li>所以任何关键字的查找必须走一条从根结点到叶子结点的路</li>
<li>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><ul>
<li>联合索引是两个或更多个列上的索引</li>
<li>对于联合索引Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li>
<li>例如索引是key index (a,b,c).<ul>
<li>可以支持a 、 a,b 、 a,b,c 3种组合进行查找</li>
<li>但不支持 b,c进行查找</li>
<li>当最左侧字段是常量引用时，索引就十分有效。</li>
</ul>
</li>
<li>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</li>
<li>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。</li>
<li>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</li>
</ul>
<h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul>
<li>表记录太少</li>
<li>经常插入、删除、修改的表</li>
<li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li>
<li>经常和主字段一块查询但主字段索引值比较多的表字段</li>
</ul>
<h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul>
<li>表分区是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分</li>
<li>从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li>
</ul>
<h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul>
<li>分表：指的是通过一定规则，将一张表分解成多张不同的表</li>
<li>比如将用户订单记录根据时间成多个表。</li>
<li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li>
</ul>
<h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><h4 id="存储更多数据"><a href="#存储更多数据" class="headerlink" title="存储更多数据"></a>存储更多数据</h4><ul>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li>
<li>和单个磁盘或者文件系统相比，可以存储更多数据</li>
</ul>
<h4 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h4><ul>
<li>在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率</li>
<li>涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li>
</ul>
<h4 id="分区表更容易维护"><a href="#分区表更容易维护" class="headerlink" title="分区表更容易维护"></a>分区表更容易维护</h4><ul>
<li>例如：想批量删除大量数据可以清除整个分区。</li>
</ul>
<h4 id="避免某些特殊的瓶颈"><a href="#避免某些特殊的瓶颈" class="headerlink" title="避免某些特殊的瓶颈"></a>避免某些特殊的瓶颈</h4><ul>
<li>例如InnoDB的单个索引的互斥访问，ext3文件系统的inode锁竞争等。</li>
</ul>
<h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ul>
<li>一个表最多只能有1024个分区</li>
<li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式</li>
<li>在MySQL5.5中提供了非整数表达式分区的支持。</li>
<li>如果分区字段中有主键或者唯一索引的列，那么有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li>
<li>分区表中无法使用外键约束</li>
<li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li>
</ul>
<h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><ul>
<li>命令：show variables like ‘%partition%’ 运行结果:</li>
<li>mysql&gt; show variables like ‘%partition%’;</li>
<li>have_partintioning 的值为YES，表示支持分区。</li>
</ul>
<h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><ul>
<li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li>
<li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li>
<li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li>
<li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li>
</ul>
<h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><ul>
<li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control)</li>
<li>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</li>
<li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</li>
<li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制</li>
<li>MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议</li>
<li>纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li>
<li>在MVCC并发控制中，读操作可以分成两类：<ul>
<li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li>
<li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li>
</ul>
</li>
</ul>
<h1 id="行级锁定的优缺点"><a href="#行级锁定的优缺点" class="headerlink" title="行级锁定的优缺点"></a>行级锁定的优缺点</h1><h4 id="行级锁定的优点"><a href="#行级锁定的优点" class="headerlink" title="行级锁定的优点"></a>行级锁定的优点</h4><ul>
<li>当在许多线程中访问不同的行时只存在少量锁定冲突</li>
<li>回滚时只有少量的更改</li>
<li>可以长时间锁定单一的行</li>
</ul>
<h4 id="行级锁定的缺点"><a href="#行级锁定的缺点" class="headerlink" title="行级锁定的缺点"></a>行级锁定的缺点</h4><ul>
<li>比页级或表级锁定占用更多的内存。</li>
<li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li>
<li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li>
<li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li>
</ul>
<h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul>
<li>key 是数据库的物理结构，它包含两层意义和作用<ul>
<li>一是约束（偏重于约束和规范数据库的结构完整性）</li>
<li>二是索引（辅助查询用的），包括primary key, unique key, foreign key 等</li>
</ul>
</li>
<li>index是数据库的物理结构<ul>
<li>它只是辅助查询的</li>
<li>它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储</li>
<li>索引要分类的话，分为前缀索引、全文本索引等；</li>
</ul>
</li>
</ul>
<h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><h4 id="字段名及字段配制合理性"><a href="#字段名及字段配制合理性" class="headerlink" title="字段名及字段配制合理性"></a>字段名及字段配制合理性</h4><ul>
<li>剔除关系不密切的字段；</li>
<li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li>
<li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li>
<li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li>
<li>字段名不要使用保留字或者关键字；</li>
<li>保持字段名和类型的一致性；</li>
<li>慎重选择数字类型；</li>
<li>给文本字段留足余量；</li>
</ul>
<h4 id="系统特殊字段处理及建成后建议"><a href="#系统特殊字段处理及建成后建议" class="headerlink" title="系统特殊字段处理及建成后建议"></a>系统特殊字段处理及建成后建议</h4><ul>
<li>添加删除标记（例如操作人、删除时间）；</li>
<li>建立版本机制；</li>
</ul>
<h4 id="表结构合理性配置"><a href="#表结构合理性配置" class="headerlink" title="表结构合理性配置"></a>表结构合理性配置</h4><ul>
<li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li>
<li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li>
</ul>
<h4 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h4><ul>
<li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li>
<li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li>
<li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li>
<li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li>
<li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li>
</ul>
<h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><h4 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF"></a>第一范式（1NF</h4><ul>
<li>字段具有原子性,不可再分</li>
<li>所有关系型数据库系统都满足第一范式</li>
<li>数据库表中的字段都是单一属性的，不可再分</li>
</ul>
<h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><ul>
<li>是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）</li>
<li>要求数据库表中的每个实例或行必须可以被惟一地区分</li>
<li>通常需要为表加上一个列，以存储各个实例的惟一标识</li>
<li>这个惟一属性列被称为主关键字或主键。</li>
</ul>
<h4 id="满足第三范式（3NF）"><a href="#满足第三范式（3NF）" class="headerlink" title="满足第三范式（3NF）"></a>满足第三范式（3NF）</h4><ul>
<li>必须先满足第二范式（2NF）</li>
<li>简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</li>
<li>所以第三范式具有如下特征<ul>
<li>每一列只有一个值</li>
<li>每一行都能区分</li>
<li>每一个表都不包含其他表已经包含的非主关键字信息。</li>
</ul>
</li>
</ul>
<h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><ul>
<li>用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</li>
<li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</li>
<li>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等</li>
<li>UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL</li>
<li>UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同<ul>
<li>对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录</li>
<li>对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</li>
</ul>
</li>
</ul>
<h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><ul>
<li>普通索引: 即针对数据库表创建索引</li>
<li>唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值</li>
<li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li>
<li>组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li>
</ul>
<h1 id="在mysql数据库中索引的工作机制是什么？"><a href="#在mysql数据库中索引的工作机制是什么？" class="headerlink" title="在mysql数据库中索引的工作机制是什么？"></a>在mysql数据库中索引的工作机制是什么？</h1><ul>
<li>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据</li>
<li>索引的实现通常使用B树及其变种B+树</li>
</ul>
<h1 id="MySQL的基础操作命令"><a href="#MySQL的基础操作命令" class="headerlink" title="MySQL的基础操作命令"></a>MySQL的基础操作命令</h1><ul>
<li>MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status</li>
<li>开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务</li>
<li>Shell 登入 MySQL: 运行命令 mysql -u root -p</li>
<li>列出所有数据库:运行命令 show databases;</li>
<li>切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库</li>
<li>列出某个数据库内所有表: show tables;</li>
<li>获取表内所有 Field 对象的名称和类型 :describe table_name;</li>
</ul>
<h1 id="mysql的复制原理以及流程"><a href="#mysql的复制原理以及流程" class="headerlink" title="mysql的复制原理以及流程"></a>mysql的复制原理以及流程</h1><ul>
<li>Mysql内建的复制功能是构建大型，高性能应用程序的基础</li>
<li>将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的</li>
<li>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器</li>
<li>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环</li>
<li>这些日志可以记录发送到从服务器的更新</li>
<li>当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置</li>
<li>从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新</li>
<li>过程如下<ul>
<li>主服务器把更新记录到二进制日志文件中</li>
<li>从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中</li>
<li>从服务器重做中继日志中的时间，把更新应用到自己的数据库上</li>
</ul>
</li>
</ul>
<h1 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型?"></a>mysql支持的复制类型?</h1><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><ul>
<li>在主服务器上执行的SQL语句，在从服务器上执行同样的语句</li>
<li>MySQL默认采用基于语句的复制，效率比较高</li>
<li>一旦发现没法精确复制时，会自动选着基于行的复制。</li>
</ul>
<h4 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h4><ul>
<li>把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持</li>
</ul>
<h4 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h4><ul>
<li>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</li>
</ul>
<h1 id="mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？"><a href="#mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？" class="headerlink" title="mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？"></a>mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</h1><ul>
<li>varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.</li>
<li>varchar(50)中50的涵义 : 最多存放50个字节</li>
<li>int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</li>
</ul>
<h1 id="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h1><ul>
<li>如果字段里面有大字段（text,blob）类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了</li>
<li>MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多</li>
<li>此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率</li>
<li>当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的</li>
<li>拆分开后，对字段的UPDAE就要UPDATE多个表了</li>
</ul>
<h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</h1><ul>
<li>InnoDB行锁是通过给索引上的索引项加锁来实现的</li>
<li>这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的</li>
<li>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li>
</ul>
<h1 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</h1><ul>
<li>由于utf8的每个字符最多占用3个字节</li>
<li>而MySQL定义行的长度不能超过65535</li>
<li>因此N的最大值计算方法为：(65535-1-2)&#x2F;3</li>
<li>减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</li>
</ul>
<h1 id="SELECT-和SELECT-全部字段的2种写法有何优缺点"><a href="#SELECT-和SELECT-全部字段的2种写法有何优缺点" class="headerlink" title="SELECT * 和SELECT 全部字段的2种写法有何优缺点?"></a>SELECT * 和SELECT 全部字段的2种写法有何优缺点?</h1><ul>
<li>前者要解析数据字典，后者不需要</li>
<li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li>
<li>表字段改名，前者不需要修改，后者需要改</li>
<li>后者可以建立索引进行优化，前者无法优化</li>
<li>后者的可读性比前者要高</li>
</ul>
<h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><ul>
<li>语法上：where 用表中列名，having用select结果别名</li>
<li>影响结果范围：where从表读出数据的行数，having返回客户端的行数</li>
<li>索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作</li>
<li>where后面不能使用聚集函数，having是专门使用聚集函数的。</li>
</ul>
<h1 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h1><ul>
<li>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c&#x3D;c+1;</li>
</ul>
<h1 id="MySQL的insert和update的select语句语法"><a href="#MySQL的insert和update的select语句语法" class="headerlink" title="MySQL的insert和update的select语句语法"></a>MySQL的insert和update的select语句语法</h1><ul>
<li>insert into student (stuid,stuname,deptid) select 10,’xzm’,3 from student where stuid &gt; 8;</li>
<li>update student a inner join student b on b.stuID&#x3D;10 set a.stuname&#x3D;concat(b.stuname, b.stuID) where a.stuID&#x3D;10 ;</li>
</ul>
<h1 id="Mysql-中有哪几种锁？"><a href="#Mysql-中有哪几种锁？" class="headerlink" title="Mysql 中有哪几种锁？"></a>Mysql 中有哪几种锁？</h1><ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低， 并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和 行锁之间，并发度一般。</li>
</ul>
<h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><ul>
<li>共有 5 种类型的表格：<ul>
<li>MyISAM</li>
<li>Heap</li>
<li>Merge</li>
<li>INNODB</li>
<li>ISAM</li>
</ul>
</li>
</ul>
<h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul>
<li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li>
<li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li>
</ul>
<h1 id="myisamchk-是用来做什么的？"><a href="#myisamchk-是用来做什么的？" class="headerlink" title="myisamchk 是用来做什么的？"></a>myisamchk 是用来做什么的？</h1><ul>
<li>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。</li>
</ul>
<h1 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h1><ul>
<li>在 MyISAM Static 上的所有字段有固定宽度</li>
<li>动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。</li>
<li>MyISAM Static 在受损情况下更容易恢复。</li>
</ul>
<h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><ul>
<li>每当行被更改时，时间戳字段将获取当前时间戳。</li>
</ul>
<h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><ul>
<li>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</li>
</ul>
<h1 id="数据库架构原则"><a href="#数据库架构原则" class="headerlink" title="数据库架构原则"></a>数据库架构原则</h1><ul>
<li>高可用</li>
<li>高性能</li>
<li>一致性</li>
<li>扩展性</li>
</ul>
<h1 id="常见的数据库架构方案"><a href="#常见的数据库架构方案" class="headerlink" title="常见的数据库架构方案"></a>常见的数据库架构方案</h1><h4 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h4><ul>
<li>只有主库提供读写服务，备库冗余作故障转移用</li>
<li>高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库</li>
<li>这个过程对业务层是透明的，无需修改代码或配置。 </li>
<li>高性能分析：读写都操作主库，很容易产生瓶颈</li>
<li>大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能</li>
<li>另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 </li>
<li>一致性分析：读写都操作主库，不存在数据一致性问题。 </li>
<li>扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 </li>
<li>可落地分析：两点影响落地使用<ul>
<li>第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案</li>
<li>第二，扩展性差，这点可以通过分库分表来扩展。</li>
</ul>
</li>
</ul>
<h4 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h4><ul>
<li>两个主库同时提供服务，负载均衡</li>
<li>高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务</li>
<li>这个过程对业务层是透明的，无需修改代码或配置。 </li>
<li>高性能分析：读写性能相比于方案一都得到提升，提升一倍。</li>
<li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li>
<li>扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）</li>
<li>如果非得在数据库架构层面扩展的话，扩展为方案四。 </li>
<li>可落地分析：两点影响落地使用<ul>
<li>第一，数据一致性问题，一致性解决方案可解决问题</li>
<li>第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。</li>
</ul>
</li>
</ul>
<h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><ul>
<li>一主多从，读写分离</li>
<li>高可用分析：主库单点，从库高可用</li>
<li>一旦主库挂了，写服务也就无法提供。 </li>
<li>高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能</li>
<li>读的性能提高了，整体性能也提高了。</li>
<li>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引</li>
<li>线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引</li>
<li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li>
<li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。</li>
<li>带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长）</li>
<li>可落地分析：两点影响落地使用<ul>
<li>第一，数据一致性问题，一致性解决方案可解决问题</li>
<li>第二，主库单点问题，笔者暂时没想到很好的解决方案。</li>
</ul>
</li>
<li>思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？</li>
</ul>
<h4 id="双主-主从架构"><a href="#双主-主从架构" class="headerlink" title="双主+主从架构"></a>双主+主从架构</h4><ul>
<li>看似完美的方案</li>
<li>高可用分析：高可用。 </li>
<li>高性能分析：高性能。 </li>
<li>一致性分析：存在数据一致性问题。请看，一致性解决方案 。</li>
<li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） </li>
<li>可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。</li>
</ul>
<h1 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h1><h4 id="主库和从库一致性解决方案"><a href="#主库和从库一致性解决方案" class="headerlink" title="主库和从库一致性解决方案"></a>主库和从库一致性解决方案</h4><ul>
<li>数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的</li>
<li>这个同步时间内主库和从库的数据会存在不一致的情况</li>
<li>如果同步过程中有读请求，那么读到的就是从库中的老数据。</li>
<li>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<ul>
<li>直接忽略，如果业务允许延时存在，那么就不去管它。 </li>
<li>强制读主，采用主备架构方案，读写都走主库</li>
<li>用缓存来扩展数据库读性能</li>
<li>有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</li>
</ul>
</li>
<li>选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。</li>
<li>读请求时，同样的方式生成key先去查Cache，再判断是否命中</li>
<li>若命中，则读主库，否则读从库</li>
<li>代价是多了一次缓存读写，基本可以忽略。</li>
<li>半同步复制，等主从同步完成，写请求才返回</li>
<li>就是大家常说的“半同步复制”semi-sync</li>
<li>这可以利用数据库原生功能，实现比较简单</li>
<li>代价是写请求时延增长，吞吐量降低。 </li>
<li>数据库中间件，引入开源（mycat等）或自研的数据库中间层</li>
<li>个人理解，思路同选择读主</li>
<li>数据库中间件的成本比较高，并且还多引入了一层</li>
</ul>
<h4 id="DB和缓存一致性解决方案"><a href="#DB和缓存一致性解决方案" class="headerlink" title="DB和缓存一致性解决方案"></a>DB和缓存一致性解决方案</h4><ul>
<li>先来看一下常用的缓存使用方式：<ul>
<li>第一步：淘汰缓存；</li>
<li>第二步：写入数据库；</li>
<li>第三步：读取缓存？返回：读取数据库；</li>
<li>第四步：读取数据库后写入缓存。</li>
</ul>
</li>
<li>注：如果按照这种方式，不会产生DB和缓存不一致问题，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据</li>
<li>设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！</li>
<li>加缓存和索引是通用的提升数据库性能的方式； </li>
<li>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。</li>
<li>阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。</li>
</ul>
<p> </p>
<h1 id="主从数据库不一致如何解决"><a href="#主从数据库不一致如何解决" class="headerlink" title="主从数据库不一致如何解决"></a>主从数据库不一致如何解决</h1><ul>
<li>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</li>
<li>忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</li>
<li>强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</li>
<li>选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</li>
</ul>
<h1 id="说出数据连接池的工作机制是什么"><a href="#说出数据连接池的工作机制是什么" class="headerlink" title="说出数据连接池的工作机制是什么?"></a>说出数据连接池的工作机制是什么?</h1><ul>
<li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接</li>
<li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙</li>
<li>如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定</li>
<li>当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</li>
</ul>
<h1 id="数据库创建索引的缺点？"><a href="#数据库创建索引的缺点？" class="headerlink" title="数据库创建索引的缺点？"></a>数据库创建索引的缺点？</h1><ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<h1 id="说一下数据库的存储过程？"><a href="#说一下数据库的存储过程？" class="headerlink" title="说一下数据库的存储过程？"></a>说一下数据库的存储过程？</h1><ul>
<li>存储过程与函数的区别：<ul>
<li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。</li>
<li>对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。</li>
<li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。</li>
</ul>
</li>
<li>存储过程的优点：<ul>
<li>执行速度更快 – 在数据库中保存的存储过程语句都是编译过的</li>
<li>允许模块化程序设计 – 类似方法的复用</li>
<li>提高系统安全性 – 防止SQL注入</li>
<li>减少网络流通量 – 只要传输存储过程的名称</li>
</ul>
</li>
<li>系统存储过程一般以sp开头，用户自定义的存储过程一般以usp开头</li>
</ul>
<h1 id="什么是基本表，什么是视图，两者的区别和联系是什么？"><a href="#什么是基本表，什么是视图，两者的区别和联系是什么？" class="headerlink" title="什么是基本表，什么是视图，两者的区别和联系是什么？"></a>什么是基本表，什么是视图，两者的区别和联系是什么？</h1><ul>
<li>它是从一个或几个基本表中导出的 表，是从现有基本表中抽取若干子集组成用户的“专用表”。</li>
<li>基本表：基本表的定义指建立基本关系模式,</li>
<li>而变更则是指对数据库中已存在的基本表进行删除与修改。</li>
<li>区别：<ul>
<li>视图是已经编译好的 sql 语句。而表不是</li>
<li>视图没有实际的物理记录。而表有。</li>
<li>表是内容，视图是窗口</li>
<li>表只用物理空间而视图不占用物理空间，</li>
</ul>
</li>
<li>视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改</li>
<li>表是内模式，试图是外模式</li>
<li>视图是查看数据表的一种方法，</li>
<li>可以查询数据表中某些字段构成的数据，</li>
<li>只是一些 SQL 语句的集合。从安全的角度说，</li>
<li>视图可以不给用户接触数据表，从而不知道表结构。</li>
<li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li>
<li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li>
<li>联系<ul>
<li>视图（view）是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。</li>
<li>视图是基本表的抽象和在逻辑意义上建立的新关系</li>
</ul>
</li>
</ul>
<h1 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM"></a>什么是 ORM</h1><ul>
<li>对象关系映射(Object Relation Mapping，简称 ORM)模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术</li>
<li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中</li>
<li>那么到底如何实现持久化呢？一种简单的方案时采用硬编码方式(jdbc 操作 sql 方式)，为每一种可能的数据库访问操作提供单独的方法。</li>
<li>这种方案存在以下不足：<ul>
<li>持久化层缺乏弹性，一旦出现业务需求变更，就必须修改持久化层的接口</li>
<li>持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层的相关程序代码，增加软件的维护难度。</li>
</ul>
</li>
<li>ORM 提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得 ORM 中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁，Java 典型的 ORM 框架有：Hibernate，ibatis(mybtis)，speedframework。</li>
<li>ORM 框架的方法论基于三个核心原则：<ul>
<li>简单：以最基本的形式建模数据</li>
<li>传达性：数据库结构被任何人都能理解的语言文档化</li>
<li>精确性：基于数据模型创建正确标准化了结构</li>
</ul>
</li>
</ul>
<h1 id="数据库连接池的原理"><a href="#数据库连接池的原理" class="headerlink" title="数据库连接池的原理"></a>数据库连接池的原理</h1><ul>
<li>传统连接方式:<ul>
<li>首先调用 Class.forName()方法加载数据库驱动，</li>
<li>然后调用 DriverManager.getConnection()方法建立连接.</li>
</ul>
</li>
<li>连接池技术:<ul>
<li>连接池解决方案是在应用程序启动时就预先建立多个数据库连接对象,然后将连接对象保存到连接池中。</li>
<li>当客户请求到来时,从池中取出一个连接对象为客户服务。</li>
<li>当请求完成时,客户程序调用 close()方法,将连接对象放回池中. </li>
<li>对于多于连接池中连接数的请求，排队等待。</li>
<li>应用程序还可根据连接池中连接的使用率，动态增加或减少池中的连接数。</li>
</ul>
</li>
</ul>
<h1 id="什么是纵向切分-垂直切分？"><a href="#什么是纵向切分-垂直切分？" class="headerlink" title="什么是纵向切分&#x2F;垂直切分？"></a>什么是纵向切分&#x2F;垂直切分？</h1><ul>
<li>就是把原本存储于一个库的数据存储到多个库上。</li>
<li>由于对数据库的读写都是对同一个库进行操作，所以单库并不能解决大规模并发写入的问题。</li>
<li>例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</li>
<li>优点<ul>
<li>减少增量数据写入时的锁对查询的影响。</li>
<li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘 IO，时延变短。</li>
</ul>
</li>
<li>缺点：无法解决单表数据量太大的问题。</li>
</ul>
<h4 id="横向切分-水平切分"><a href="#横向切分-水平切分" class="headerlink" title="横向切分&#x2F;水平切分"></a>横向切分&#x2F;水平切分</h4><ul>
<li>把原本存储于一个表的数据分块存储到多个表上。当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，进行划分，然后存储到多个结构相同的表，和不同的库上。</li>
<li>例如，我们 userDB 中的 userTable 中数据量很大，那么可以把 userDB 切分为结构相同的多个 userDB：part0DB、part1DB 等，再将 userDB 上的 userTable，切分为很多userTable：userTable0、userTable1 等，然后将这些表按照一定的规则存储到多个 userDB上。</li>
<li>优点：<ul>
<li>单表的并发能力提高了，磁盘 I&#x2F;O 性能也提高了。</li>
<li>如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。</li>
</ul>
</li>
<li>缺点：无法实现表连接查询</li>
</ul>
<h1 id="什么是-MyCat？"><a href="#什么是-MyCat？" class="headerlink" title="什么是 MyCat？"></a>什么是 MyCat？</h1><ul>
<li>MyCat 是目前最流行的基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分离。</li>
<li>MyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。</li>
<li>MyCat 发展到目前的版本，已经不是一个单纯的 MySQL 代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL 等主流数据库，也支持 MongoDB 这种新型 NoSQL 方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那种存储方式，在 MyCat 里，都是一个传统的数据库表，支持标准的 SQL 语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度。</li>
</ul>
<h1 id="请说出两种以上扩大数据库的方式"><a href="#请说出两种以上扩大数据库的方式" class="headerlink" title="请说出两种以上扩大数据库的方式"></a>请说出两种以上扩大数据库的方式</h1><ul>
<li>修改现有表空间的大小；</li>
<li>向表空间插入一个新的数据文件</li>
</ul>
<h1 id="事务是什么？有哪些属性，并简要说明这些属性的含义"><a href="#事务是什么？有哪些属性，并简要说明这些属性的含义" class="headerlink" title="事务是什么？有哪些属性，并简要说明这些属性的含义"></a>事务是什么？有哪些属性，并简要说明这些属性的含义</h1><ul>
<li>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如 SQL，C++或 Java）书写的用户程序的执行所引起，并用形如 begin transaction 和 end transaction 语句（或函数调用）来界定。</li>
<li>事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。</li>
<li>事务应该具有 4 个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为 ACID特性。原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>
<h1 id="MyBatis-和-hibernate-的区别有哪些？"><a href="#MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="MyBatis 和 hibernate 的区别有哪些？"></a>MyBatis 和 hibernate 的区别有哪些？</h1><ul>
<li>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</li>
<li>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</li>
<li>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</li>
<li>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</li>
</ul>
<h1 id="Statement-PreparedStatement-CallableStatment-的区别。"><a href="#Statement-PreparedStatement-CallableStatment-的区别。" class="headerlink" title="Statement,PreparedStatement,CallableStatment 的区别。"></a>Statement,PreparedStatement,CallableStatment 的区别。</h1><ul>
<li>区别有以下几点：</li>
<li>Statement 是 PreparedStatement 和 CallableStatement 的父类；</li>
<li>Statement 是直接发送 Sql 语句到数据库，事先没有进行预编译。 PreparedStatement会将 sql 进行预编译，当 sql 语句要重复执行时，数据库会调用以前预编译好的 sql 语句，所以 PreparedStatement 在性能方面会更好；</li>
<li>PreparedStatement 在执行 sql 时，对传入的参数可以进行强制的类型转换。以保证数据格式与底层的数据库格式一致。</li>
<li>CallableStatement 适用与存储过程的查询表达语句</li>
</ul>
<h1 id="JDBC-为什么要使用-PreparedStatement-而不是-Statement"><a href="#JDBC-为什么要使用-PreparedStatement-而不是-Statement" class="headerlink" title="JDBC 为什么要使用 PreparedStatement 而不是 Statement"></a>JDBC 为什么要使用 PreparedStatement 而不是 Statement</h1><ul>
<li>PreparedStatement 是 用 来 执 行 SQL 查 询 语 句 的 API 之 一 ， Java 提 供 了 Statement 、PreparedStatement 和 CallableStatement 三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement 则是用于存储过程。</li>
</ul>
<h1 id="触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别："><a href="#触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：" class="headerlink" title="触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别："></a>触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：</h1><ul>
<li>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。</li>
<li>语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。</li>
</ul>
<h1 id="游标的作用？如何知道游标已经到了最后："><a href="#游标的作用？如何知道游标已经到了最后：" class="headerlink" title="游标的作用？如何知道游标已经到了最后："></a>游标的作用？如何知道游标已经到了最后：</h1><ul>
<li>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。</li>
</ul>
<h1 id="数据库中常用术语："><a href="#数据库中常用术语：" class="headerlink" title="数据库中常用术语："></a>数据库中常用术语：</h1><ul>
<li>ddl:数据定义语言 Create Drop Alter</li>
<li>dml:数据操纵语言 insert update delete select</li>
<li>dcl:数据控制语言 grant revoke</li>
<li>tcl:事务控制语言 commit rollback</li>
</ul>
<h1 id="NULL-是什么意思"><a href="#NULL-是什么意思" class="headerlink" title="NULL 是什么意思"></a>NULL 是什么意思</h1><ul>
<li>NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这个值的任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比较，并在逻辑上希望获得一个答案。</li>
<li>使用 IS NULL 来进行 NULL 判断‘</li>
</ul>
<h1 id="什么是基本表？什么是视图？"><a href="#什么是基本表？什么是视图？" class="headerlink" title="什么是基本表？什么是视图？"></a>什么是基本表？什么是视图？</h1><ul>
<li>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表</li>
</ul>
<h1 id="试述视图的优点？"><a href="#试述视图的优点？" class="headerlink" title="试述视图的优点？"></a>试述视图的优点？</h1><ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据；</li>
<li>视图为数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护。</li>
</ul>
<h1 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h1><ul>
<li>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。</li>
</ul>
<h1 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a>完整性约束包括哪些？</h1><ul>
<li>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</li>
<li>分为以下四类：<ul>
<li>实体完整性：规定表的每一行在表中是惟一的实体。</li>
<li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li>
<li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li>
<li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li>
</ul>
</li>
<li>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、<br>foreign key、check、UNIQUE) 。</li>
</ul>
<h1 id="解释-MySQL-外连接、内连接与自连接的区别"><a href="#解释-MySQL-外连接、内连接与自连接的区别" class="headerlink" title="解释 MySQL 外连接、内连接与自连接的区别"></a>解释 MySQL 外连接、内连接与自连接的区别</h1><ul>
<li>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</li>
<li>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。</li>
<li>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</li>
<li>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。</li>
</ul>
<h1 id="SQL-注入漏洞产生的原因？如何防止？"><a href="#SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL 注入漏洞产生的原因？如何防止？"></a>SQL 注入漏洞产生的原因？如何防止？</h1><ul>
<li>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。</li>
<li>防止 SQL 注入的方式：<ul>
<li>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置</li>
<li>执行 sql 语句时使用 addslashes 进行 sql 语句转换Sql 语句书写尽量不要省略双引号和单引号。</li>
<li>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。</li>
<li>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</li>
</ul>
</li>
</ul>
<h1 id="存储过程和函数的区别"><a href="#存储过程和函数的区别" class="headerlink" title="存储过程和函数的区别"></a>存储过程和函数的区别</h1><ul>
<li>存储过程是用户定义的一系列 sql 语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。</li>
</ul>
<h1 id="关系型数据库和非关系型数据库种类和关系"><a href="#关系型数据库和非关系型数据库种类和关系" class="headerlink" title="关系型数据库和非关系型数据库种类和关系"></a>关系型数据库和非关系型数据库种类和关系</h1><ul>
<li>数据库</li>
<li>类型	特性	优点	缺点</li>
</ul>
<h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><ul>
<li>SQLite、Oracle、mysql	1、关系型数据库，是指采用了关系模型来组织数据的数据库；</li>
<li>关系型数据库的最大特点就是事务的一致性；</li>
<li>简单来说，关系模型指的就是二维表格模型，</li>
<li>而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。<ul>
<li>容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</li>
<li>使用方便：通用的SQL语言使得操作关系型数据库非常方便；</li>
<li>易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；</li>
<li>支持SQL，可用于复杂的查询。</li>
</ul>
</li>
<li>为了维护一致性所付出的巨大代价就是其读写性能比较差；</li>
<li>固定的表结构；</li>
<li>高并发读写需求；</li>
<li>海量数据的高效率读写；</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ul>
<li>非关系型数据库</li>
<li>MongoDb、redis、HBase</li>
<li>使用键值对存储数据；</li>
<li>分布式；</li>
<li>一般不支持ACID特性；</li>
<li>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。	<ul>
<li>无需经过sql层的解析，读写性能很高；</li>
<li>基于键值对，数据没有耦合性，容易扩展；</li>
<li>存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。</li>
</ul>
<p>	</p>
</li>
<li>不提供sql支持，学习和使用成本较高；</li>
<li>无事务处理，附加功能bi和报表等支持也不好；</li>
</ul>
<h1 id="内连接、外连接、交叉连接、笛卡儿积等"><a href="#内连接、外连接、交叉连接、笛卡儿积等" class="headerlink" title="内连接、外连接、交叉连接、笛卡儿积等"></a>内连接、外连接、交叉连接、笛卡儿积等</h1><ul>
<li>内连接(INNER JOIN)：  <ul>
<li>分为三种：等值连接、自然连接、不等连接</li>
</ul>
</li>
<li>外连接(OUTER JOIN)：  </li>
<li>分为三种：  <ul>
<li>左外连接(LEFT OUTER JOIN或LEFT JOIN)  </li>
<li>右外连接(RIGHT OUTER JOIN或RIGHT JOIN)  </li>
<li>全外连接(FULL OUTER JOIN或FULL JOIN)  交叉连接(CROSS JOIN)：没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积</li>
</ul>
</li>
<li>笛卡尔积是两个表每一个字段相互匹配，去掉where 或者inner join的等值 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。内连接: 只连接匹配的行。</li>
<li>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。</li>
<li>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。</li>
<li>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</li>
<li>交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎</title>
    <url>/publishes/372274a5b315.html</url>
    <content><![CDATA[<h1 id="lucene-和-es"><a href="#lucene-和-es" class="headerlink" title="lucene 和 es"></a>lucene 和 es</h1><ul>
<li>lucene 是最先进、功能最强大的搜索库</li>
<li>如果直接基于 lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。</li>
<li>elasticsearch 基于 lucene，隐藏了 lucene 的复杂性，提供了简单易用的 restful api &#x2F; Java api 接口（另外还有其他语言的 api 接口）<ul>
<li>分布式的文档存储引擎</li>
<li>分布式的搜索引擎和分析引擎</li>
<li>分布式，支持 PB 级数据</li>
</ul>
</li>
</ul>
<h1 id="es-的核心概念"><a href="#es-的核心概念" class="headerlink" title="es 的核心概念"></a>es 的核心概念</h1><h4 id="Near-Realtime"><a href="#Near-Realtime" class="headerlink" title="Near Realtime"></a>Near Realtime</h4><ul>
<li>近实时，有两层意思：<ul>
<li>从写入数据到数据可以被搜索到有一个小延迟（大概是 1s）</li>
<li>基于 es 执行搜索和分析可以达到秒级</li>
</ul>
</li>
</ul>
<h4 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h4><ul>
<li>集群包含多个节点，每个节点属于哪个集群都是通过一个配置来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常。</li>
</ul>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><ul>
<li>Node 是集群中的一个节点，节点也有一个名称，默认是随机分配的。默认节点会去加入一个名称为 elasticsearch 的集群。</li>
<li>如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。</li>
</ul>
<h4 id="Document-field"><a href="#Document-field" class="headerlink" title="Document &amp; field"></a>Document &amp; field</h4><ul>
<li>文档是 es 中最小的数据单元，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据，通常用 json 数据结构来表示。</li>
<li>每个 index 下的 type，都可以存储多条 document。一个 document 里面有多个 field，每个 field 就是一个数据字段。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;product_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;product_name&quot;: &quot;iPhone X&quot;,</span><br><span class="line">    &quot;product_desc&quot;: &quot;苹果手机&quot;,</span><br><span class="line">    &quot;category_id&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;category_name&quot;: &quot;电子产品&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><ul>
<li>索引包含了一堆有相似结构的文档数据，比如商品索引<br>一个索引包含很多 document，一个索引就代表了一类相似或者相同的 ducument。</li>
</ul>
<h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><ul>
<li>类型，每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。</li>
<li>每个 type 下的 document 的 field 可能不太一样。</li>
</ul>
<h4 id="shard"><a href="#shard" class="headerlink" title="shard"></a>shard</h4><ul>
<li>单台机器无法存储大量数据，es 可以将一个索引中的数据切分为多个 shard，分布在多台服务器上存储</li>
<li>有了 shard 就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能</li>
<li>每个 shard 都是一个 lucene index。</li>
</ul>
<h4 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h4><ul>
<li>任何一个服务器随时可能故障或宕机，此时 shard 可能就会丢失，因此可以为每个 shard 创建多个 replica 副本。</li>
<li>replica 可以在 shard 故障时提供备用服务，保证数据不丢失，多个 replica 还可以提升搜索操作的吞吐量和性能。</li>
<li>primary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5个 replica shard，最小的高可用配置，是 2 台服务器。</li>
<li>这么说吧，shard 分为 primary shard 和 replica shard。而 primary shard 一般简称为 shard，而 replica shard 一般简称为 replica。</li>
</ul>
<h1 id="es-核心概念-vs-db-核心概念"><a href="#es-核心概念-vs-db-核心概念" class="headerlink" title="es 核心概念 vs. db 核心概念"></a>es 核心概念 vs. db 核心概念</h1><ul>
<li>es	dbindex	数据库type	数据表docuemnt	一行数据以上是一个简单的类比。</li>
</ul>
<h1 id="es-的分布式架构原理能说一下么（es-是如何实现分布式的啊）？"><a href="#es-的分布式架构原理能说一下么（es-是如何实现分布式的啊）？" class="headerlink" title="es 的分布式架构原理能说一下么（es 是如何实现分布式的啊）？"></a>es 的分布式架构原理能说一下么（es 是如何实现分布式的啊）？</h1><ul>
<li>ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 lucene 的。</li>
<li>核心思想就是在多台机器上启动多个 es 进程实例，组成了一个 es 集群。</li>
<li>es 中存储数据的基本单位是索引，比如说你现在要在 es 中存储一些订单数据，你就应该在 es 中创建一个索引 order_idx，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一张表。</li>
<li>index -&gt; type -&gt; mapping -&gt; document -&gt; field。</li>
<li>index 相当于 mysql 里的一张表。而 type 没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。假设有一个 index，是订单 index，里面专门是放订单数据的。就好比说你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。<br>所以就会在订单 index 里，建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。</li>
<li>很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（注意，mapping types这个概念在 ElasticSearch 7.X 已被完全移除，详细说明可以参考官方文档），你可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的表结构定义，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。</li>
<li>你搞一个索引，这个索引可以拆分成多个 shard，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是支持横向扩展，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是提高性能，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 primary shard，负责写入数据，但是还有几个 replica shard。primary shard 写入数据之后，会将数据同步到其他几个 replica shard 上去。</li>
<li>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</li>
<li>es 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</li>
<li>如果是非 master节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</li>
<li>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</li>
</ul>
<h1 id="es-写入数据的工作原理是什么啊？es-查询数据的工作原理是什么啊？底层的-lucene-介绍一下呗？倒排索引了解吗？"><a href="#es-写入数据的工作原理是什么啊？es-查询数据的工作原理是什么啊？底层的-lucene-介绍一下呗？倒排索引了解吗？" class="headerlink" title="es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？"></a>es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？</h1><h4 id="es-写数据过程"><a href="#es-写数据过程" class="headerlink" title="es 写数据过程"></a>es 写数据过程</h4><ul>
<li>客户端选择一个 node 发送请求过去，这个 node 就是 coordinating node（协调节点）。</li>
<li>coordinating node 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li>
<li>实际的 node 上的 primary shard 处理请求，然后将数据同步到 replica node。</li>
<li>coordinating node 如果发现 primary node 和所有 replica node 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<h4 id="es-读数据过程"><a href="#es-读数据过程" class="headerlink" title="es 读数据过程"></a>es 读数据过程</h4><ul>
<li>可以通过 doc id 来查询，会根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询。</li>
<li>客户端发送请求到任意一个 node，成为 coordinate node。</li>
<li>coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 coordinate node。</li>
<li>coordinate node 返回 document 给客户端。</li>
</ul>
<h4 id="es-搜索数据过程"><a href="#es-搜索数据过程" class="headerlink" title="es 搜索数据过程"></a>es 搜索数据过程</h4><ul>
<li>es 最强大的是做全文检索，就是比如你有三条数据：<ul>
<li>java真好玩儿啊</li>
<li>java好难学啊</li>
<li>j2ee特别牛</li>
</ul>
</li>
<li>你根据 java 关键词来搜索，将包含 java的 document 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</li>
<li>客户端发送请求到一个 coordinate node。</li>
<li>协调节点将搜索请求转发到所有的 shard 对应的 primary shard 或 replica shard，都可以。</li>
<li>query phase：每个 shard 将自己的搜索结果（其实就是一些 doc id）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>
<li>fetch phase：接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端。</li>
<li>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</li>
</ul>
<h4 id="写数据底层原理"><a href="#写数据底层原理" class="headerlink" title="写数据底层原理"></a>写数据底层原理</h4><ul>
<li>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</li>
<li>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file 中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache 。这个过程就是 refresh。</li>
<li>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file，每秒钟会产生一个新的磁盘文件 segment file，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。</li>
<li>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</li>
<li>操作系统里面，磁盘文件其实都有一个东西，叫做 os cache，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache，先进入操作系统级别的一个内存缓存中去。只要 buffer 中的数据被 refresh 操作刷入 os cache中，这个数据就可以被搜索到了。</li>
</ul>
<h5 id="为什么叫-es-是准实时的？"><a href="#为什么叫-es-是准实时的？" class="headerlink" title="为什么叫 es 是准实时的？"></a>为什么叫 es 是准实时的？</h5><ul>
<li>NRT，全称 near real-time。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。</li>
<li>可以通过 es 的 restful api 或者 java api，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache中，让数据立马就可以被搜索到。</li>
<li>只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</li>
<li>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file 中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。</li>
<li>commit 操作发生第一步，就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</li>
<li>这个 commit 操作叫做 flush。默认 30 分钟自动执行一次 flush，但如果 translog 过大，也会触发 flush。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</li>
<li>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</li>
<li>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</li>
<li>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的数据丢失。</li>
<li>总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。数据写入 segment file 之后，同时就建立好了倒排索引。</li>
</ul>
<h4 id="删除-更新数据底层原理"><a href="#删除-更新数据底层原理" class="headerlink" title="删除&#x2F;更新数据底层原理"></a>删除&#x2F;更新数据底层原理</h4><ul>
<li>如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。</li>
<li>如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。</li>
<li>buffer 每 refresh 一次，就会产生一个 segment file，所以默认情况下是 1 秒钟一个 segment file，这样下来 segment file 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，然后将新的 segment file 写入磁盘，这里会写一个 commit point，标识所有新的 segment file，然后打开 segment file 供搜索使用，同时删除旧的 segment file。</li>
</ul>
<h4 id="底层-lucene"><a href="#底层-lucene" class="headerlink" title="底层 lucene"></a>底层 lucene</h4><ul>
<li>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</li>
<li>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</li>
</ul>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><ul>
<li>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</li>
<li>那么，倒排索引就是关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</li>
<li>举个栗子。<ul>
<li>有以下文档：<ul>
<li>DocId	Doc</li>
<li>1	谷歌地图之父跳槽 Facebook</li>
<li>2	谷歌地图之父加盟 Facebook</li>
<li>3	谷歌地图创始人拉斯离开谷歌加盟 Facebook</li>
<li>4	谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</li>
<li>5	谷歌地图之父拉斯加盟社交网站 Facebook</li>
</ul>
</li>
</ul>
</li>
<li>对文档进行分词之后，得到以下倒排索引。<ul>
<li>WordId	Word	DocIds</li>
<li>1	谷歌	1,2,3,4,5</li>
<li>2	地图	1,2,3,4,5</li>
<li>3	之父	1,2,4,5</li>
<li>4	跳槽	1,4</li>
<li>5	Facebook	1,2,3,4,5</li>
<li>6	加盟	2,3,5</li>
<li>7	创始人	3</li>
<li>8	拉斯	3,5</li>
<li>9	离开	3</li>
<li>10	与	4</li>
<li>..	..	..</li>
</ul>
</li>
<li>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。<br>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 Facebook，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</li>
<li>要注意倒排索引的两个重要细节：<ul>
<li>倒排索引中的所有词项对应一个或多个文档；</li>
<li>倒排索引中的词项根据字典顺序升序排列</li>
</ul>
</li>
<li>上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。</li>
</ul>
<h1 id="es-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"><a href="#es-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？" class="headerlink" title="es 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"></a>es 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</h1><ul>
<li>es 性能优化是没有什么银弹的，啥意思呢？就是不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景。也许有的场景是你换个参数，或者调整一下语法，就可以搞定，但是绝对不是所有场景都可以这样。</li>
</ul>
<h4 id="性能优化的杀手锏——filesystem-cache"><a href="#性能优化的杀手锏——filesystem-cache" class="headerlink" title="性能优化的杀手锏——filesystem cache"></a>性能优化的杀手锏——filesystem cache</h4><ul>
<li>你往 es 里写的数据，实际上都写到磁盘文件里去了，查询的时候，操作系统会将磁盘文件里的数据自动缓存到 filesystem cache 里面去。</li>
<li>es 的搜索引擎严重依赖于底层的 filesystem cache，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的 idx segment file 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</li>
<li>性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1秒、5秒、10秒。但如果是走 filesystem cache，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</li>
<li>这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 64 * 3 &#x3D; 192G。每台机器给 es jvm heap 是 32G，那么剩下来留给 filesystem cache 的就是每台机器才 32G，总共集群里给 filesystem cache 的就是 32 * 3 &#x3D; 96G 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 1T 的磁盘容量，es 数据量是 1T，那么每台机器的数据量是 300G。这样性能好吗？ filesystem cache 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</li>
<li>归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</li>
<li>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要用来搜索的那些索引，如果内存留给 filesystem cache 的是 100G，那么你就将索引数据控制在 100G 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</li>
<li>比如说你现在有一行数据。id,name,age …. 30 个字段。但是你现在搜索，只需要根据 id,name,age 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 90% 的数据是不用来搜索的，结果硬是占据了 es 机器上的 filesystem cache 的空间，单条数据的数据量越大，就会导致 filesystem cahce 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的少数几个字段就可以了，比如说就写入 es id,name,age 三个字段，然后你可以把其他的字段数据存在 mysql&#x2F;hbase 里，我们一般是建议用 es + hbase 这么一个架构。</li>
<li>hbase 的特点是适用于海量数据的在线存储，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 doc id，然后根据 doc id 到 hbase 里去查询每个 doc id 对应的完整的数据，给查出来，再返回给前端。</li>
<li>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。</li>
</ul>
<h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><ul>
<li>假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 filesystem cache 一倍，比如说你写入一台机器 60G 数据，结果 filesystem cache 就 30G，还是有 30G 数据留在了磁盘上。其实可以做数据预热。</li>
<li>举个例子，拿微博来说，你可以把一些大V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 filesystem cache 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</li>
<li>或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 filesystem cache 里去。</li>
<li>对于那些你觉得比较热的、经常会有人访问的数据，最好做一个专门的缓存预热子系统，就是对热数据每隔一段时间，就提前访问一下，让数据进入 filesystem cache 里面去。这样下次别人访问的时候，性能一定会好很多。</li>
</ul>
<h4 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h4><ul>
<li>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据在被预热之后，尽量都让他们留在 filesystem os cache 里，别让冷数据给冲刷掉。</li>
<li>你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 filesystem cache 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。</li>
</ul>
<h4 id="document-模型设计"><a href="#document-模型设计" class="headerlink" title="document 模型设计"></a>document 模型设计</h4><ul>
<li>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。</li>
<li>最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</li>
<li>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join&#x2F;nested&#x2F;parent-child 搜索都要尽量避免，性能都很差的。</li>
</ul>
<h4 id="分页性能优化"><a href="#分页性能优化" class="headerlink" title="分页性能优化"></a>分页性能优化</h4><ul>
<li>es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</li>
<li>分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你必须得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</li>
<li>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</li>
<li>有什么解决方案吗？</li>
</ul>
<h5 id="不允许深度分页（默认深度分页性能很差）"><a href="#不允许深度分页（默认深度分页性能很差）" class="headerlink" title="不允许深度分页（默认深度分页性能很差）"></a>不允许深度分页（默认深度分页性能很差）</h5><ul>
<li>跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。</li>
<li>类似于 app 里的推荐商品不断下拉出来一页一页的</li>
<li>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 scroll api，关于如何使用，自行上网搜索。</li>
<li>scroll 会一次性给你生成所有数据的一个快照，然后每次滑动向后翻页就是通过游标 scroll_id 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</li>
<li>但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，不能随意跳到任何一页的场景。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。</li>
<li>初始化时必须指定 scroll 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</li>
<li>除了用 scroll api，你也可以用 search_after 来做，search_after 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</li>
</ul>
<h1 id="es-生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"><a href="#es-生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？" class="headerlink" title="es 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"></a>es 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</h1><ul>
<li>示例<ul>
<li>es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li>
<li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li>
<li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li>
</ul>
</li>
</ul>
<h1 id="什么是-Solr？"><a href="#什么是-Solr？" class="headerlink" title="什么是 Solr？"></a>什么是 Solr？</h1><ul>
<li>Solr 是一个独立的企业级搜索应用服务器，它对外提供类似于 Web-service 的 API接口。</li>
<li>Solr 是一个高性能，采用 Java 开发，基于 Lucene 的全文搜索服务器。同时对其进行了扩展，提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文检索引擎。</li>
<li>文档通过 Http 利用 XML 加到一个搜索集合中。查询该集合也是通过 http 收到一个 XML&#x2F;JSON 响应来实现。它的主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，提供一套强大 Data Schema 来定义字段，类型和设置文本分析，提供基于 Web 的管理界面等。</li>
</ul>
<h1 id="Solr-是由哪两个部分构成？"><a href="#Solr-是由哪两个部分构成？" class="headerlink" title="Solr 是由哪两个部分构成？"></a>Solr 是由哪两个部分构成？</h1><ul>
<li>如下两个部分<ul>
<li>Solr 的 web 服务</li>
<li>Solr 的索引库</li>
</ul>
</li>
</ul>
<h1 id="什么是正排索引？"><a href="#什么是正排索引？" class="headerlink" title="什么是正排索引？"></a>什么是正排索引？</h1><ul>
<li>正排索引是以文档的 ID 为关键字，索引文档中每个字的位置信息，查找时扫描索引中每个文档中字的信息直到找出所有包含查询关键字的文档。</li>
<li>但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。</li>
<li>尽管正排索引的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，否则实用性价值不大。</li>
</ul>
<h1 id="什么是倒排索引？"><a href="#什么是倒排索引？" class="headerlink" title="什么是倒排索引？"></a>什么是倒排索引？</h1><ul>
<li>对数据进行分析，抽取出数据中的词条，以词条作为 key，对应数据的存储位置作为 value，实现索引的存储。这种索引称为倒排索引。</li>
<li>当 solr 存储文档时，solr 会首先对文档数据进行分词，创建索引库和文档数据库。所谓的分词是指：将一段字符文本按照一定的规则分成若干个单词。</li>
</ul>
<h1 id="什么是全文检索？"><a href="#什么是全文检索？" class="headerlink" title="什么是全文检索？"></a>什么是全文检索？</h1><ul>
<li>我们生活中的数据总体分为两种：结构化数据和非结构化数据。<ul>
<li>结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li>非结构化数据：指不定长或无固定格式的数据，如邮件，word 文档等。</li>
</ul>
</li>
<li>非结构化数据又一种叫法叫全文数据。</li>
<li>按照数据的分类，搜索也分为两种：<ul>
<li>对结构化数据的搜索：如对数据库的搜索，用 SQL 语句。</li>
<li>对非结构化数据的搜索：如利用 windows 的搜索也可以搜索文件内容，</li>
</ul>
</li>
<li>全文检索： 就是一种将文件中所有文本与检索项匹配的文字资料检索方法。全文检索首先将要查询的目标文档中的词提取出来，组成索引，通过查询索引达到搜索目标文档的目的。这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。</li>
</ul>
<h1 id="如何监控-Elasticsearch-集群状态？"><a href="#如何监控-Elasticsearch-集群状态？" class="headerlink" title="如何监控 Elasticsearch 集群状态？"></a>如何监控 Elasticsearch 集群状态？</h1><ul>
<li>Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch</li>
<li>你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。</li>
</ul>
<h1 id="在并发情况下，Elasticsearch-如果保证读写一致？"><a href="#在并发情况下，Elasticsearch-如果保证读写一致？" class="headerlink" title="在并发情况下，Elasticsearch 如果保证读写一致？"></a>在并发情况下，Elasticsearch 如果保证读写一致？</h1><ul>
<li>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</li>
<li>另外对于写操作，一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</li>
<li>对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。</li>
</ul>
<h1 id="Elasticsearch-对于大数据量（上亿量级）的聚合如何实现？"><a href="#Elasticsearch-对于大数据量（上亿量级）的聚合如何实现？" class="headerlink" title="Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？"></a>Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？</h1><ul>
<li>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</li>
</ul>
<h1 id="对于-GC-方面，在使用-Elasticsearch-时要注意什么？"><a href="#对于-GC-方面，在使用-Elasticsearch-时要注意什么？" class="headerlink" title="对于 GC 方面，在使用 Elasticsearch 时要注意什么？"></a>对于 GC 方面，在使用 Elasticsearch 时要注意什么？</h1><ul>
<li>倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segmentmemory 增长趋势。</li>
<li>各类缓存，field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache等“自欺欺人”的方式来释放内存。</li>
<li>避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan &amp; scroll api 来实现。</li>
<li>cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node 连接。</li>
<li>想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控。</li>
</ul>
<h1 id="Lucene-使用了大量-的文件。同时，Elasticsearch-在节点和-HTTP-客户端"><a href="#Lucene-使用了大量-的文件。同时，Elasticsearch-在节点和-HTTP-客户端" class="headerlink" title="Lucene 使用了大量 的文件。同时，Elasticsearch 在节点和 HTTP 客户端"></a>Lucene 使用了大量 的文件。同时，Elasticsearch 在节点和 HTTP 客户端</h1><ul>
<li>之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。</li>
<li>补充：索引阶段性能提升方法</li>
<li>使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。</li>
<li>存储：使用 SSD</li>
<li>段和合并：Elasticsearch 默认值是 20 MB&#x2F;s，对机械磁盘应该是个不错的设置。如果你用的是 SSD，可以考虑提高到 100–200 MB&#x2F;s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。</li>
<li>如果你的搜索结果不需要近实时的准确度，考虑把每个索引的index.refresh_interval 改到 30s。</li>
<li>如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副本。</li>
</ul>
<h1 id="Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法？"><a href="#Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法？" class="headerlink" title="Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？"></a>Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</h1><ul>
<li>64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。少于 8 GB 会适得其反。</li>
<li>如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。</li>
<li>如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。</li>
<li>即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。</li>
<li>请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在Elasticsearch 的几个地方，使用 Java 的本地序列化。</li>
<li>通过设置 gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。</li>
<li>Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。</li>
<li>不要随意修改垃圾回收器（CMS）和各个线程池的大小。</li>
<li>把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过ES_HEAP_SIZE 环境变量设置。</li>
<li>内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。</li>
</ul>
<h1 id="详细描述一下-Elasticsearch-搜索的过程。"><a href="#详细描述一下-Elasticsearch-搜索的过程。" class="headerlink" title="详细描述一下 Elasticsearch 搜索的过程。"></a>详细描述一下 Elasticsearch 搜索的过程。</h1><ul>
<li>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</li>
<li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。</li>
<li>PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 MemoryBuffer，所以搜索是近实时的。</li>
<li>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li>
<li>接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</li>
<li>补充：Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。*</li>
</ul>
<h1 id="详细描述一下-Elasticsearch-更新和删除文档的过程。"><a href="#详细描述一下-Elasticsearch-更新和删除文档的过程。" class="headerlink" title="详细描述一下 Elasticsearch 更新和删除文档的过程。"></a>详细描述一下 Elasticsearch 更新和删除文档的过程。</h1><ul>
<li>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</li>
<li>磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在.del 文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。</li>
<li>在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</li>
</ul>
<h1 id="详细描述一下-Elasticsearch-索引文档的过程。"><a href="#详细描述一下-Elasticsearch-索引文档的过程。" class="headerlink" title="详细描述一下 Elasticsearch 索引文档的过程。"></a>详细描述一下 Elasticsearch 索引文档的过程。</h1><ul>
<li>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片。shard &#x3D; hash(document_id) % (num_of_primary_shards)</li>
<li>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 MemoryBuffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 MomeryBuffer 到 Filesystem Cache 的过程就叫做 refresh；</li>
<li>当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；</li>
<li>在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</li>
<li>flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</li>
<li>补充：关于 Lucene 的 Segement：<ul>
<li>Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。</li>
<li>段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重建索引。</li>
<li>对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。</li>
<li>为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。</li>
</ul>
</li>
</ul>
<h1 id="客户端在和集群连接时，如何选择特定的节点执行请求的？"><a href="#客户端在和集群连接时，如何选择特定的节点执行请求的？" class="headerlink" title="客户端在和集群连接时，如何选择特定的节点执行请求的？"></a>客户端在和集群连接时，如何选择特定的节点执行请求的？</h1><ul>
<li>TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮询 的方式与这些地址进行通信。</li>
</ul>
<h1 id="Elasticsearch-中的节点（比如共-20-个），其中的-10-个"><a href="#Elasticsearch-中的节点（比如共-20-个），其中的-10-个" class="headerlink" title="Elasticsearch 中的节点（比如共 20 个），其中的 10 个"></a>Elasticsearch 中的节点（比如共 20 个），其中的 10 个</h1><ul>
<li>选了一个 master，另外 10 个选了另一个 master，怎么办？</li>
<li>当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</li>
<li>当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data节点，避免脑裂问题。</li>
</ul>
<h1 id="Elasticsearch-是如何实现-Master-选举的？"><a href="#Elasticsearch-是如何实现-Master-选举的？" class="headerlink" title="Elasticsearch 是如何实现 Master 选举的？"></a>Elasticsearch 是如何实现 Master 选举的？</h1><ul>
<li>Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个 RPC 来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分；</li>
<li>对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</li>
<li>如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n&#x2F;2+1）并且该节点自己也选举自己，那这个节点就是 master。否则重新选举一直到满足上述条件。</li>
<li>补充：master 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data 节点可以关闭 http 功能*。</li>
</ul>
<h1 id="Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法"><a href="#Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法" class="headerlink" title="Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法"></a>Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法</h1><ul>
<li>关闭缓存 swap;</li>
<li>堆内存设置为：Min（节点内存&#x2F;2, 32GB）;</li>
<li>设置最大文件句柄数；</li>
<li>线程池+队列大小根据业务需要做调整；</li>
<li>磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单节点存储故障。</li>
</ul>
<h1 id="详细描述一下-Elasticsearch-搜索的过程？"><a href="#详细描述一下-Elasticsearch-搜索的过程？" class="headerlink" title="详细描述一下 Elasticsearch 搜索的过程？"></a>详细描述一下 Elasticsearch 搜索的过程？</h1><ul>
<li>搜索拆解为“query then fetch” 两个阶段。</li>
<li>query 阶段的目的：定位到位置，但不取。</li>
<li>步骤拆解如下：<ul>
<li>假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本分片中）的一个。</li>
<li>每个分片在本地进行查询，结果返回到本地有序的优先队列中。</li>
<li>第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。fetch 阶段的目的：取数据。路由节点获取所有文档，返回给客户端。</li>
</ul>
</li>
</ul>
<h1 id="elasticsearch-索引数据多了怎么办，如何调优，部署"><a href="#elasticsearch-索引数据多了怎么办，如何调优，部署" class="headerlink" title="elasticsearch 索引数据多了怎么办，如何调优，部署"></a>elasticsearch 索引数据多了怎么办，如何调优，部署</h1><ul>
<li>索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户检索或者其他业务受到影响。</li>
<li>如何调优，正如问题 1 所说，这里细化一下：</li>
</ul>
<h4 id="动态索引层面"><a href="#动态索引层面" class="headerlink" title="动态索引层面"></a>动态索引层面</h4><ul>
<li>基于模板+时间+rollover api 滚动创建索引，举例：设计阶段定义：blog 索引的模板格式为：blog_index_时间戳的形式，每天递增数据。这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线 2 的32 次幂-1，索引存储达到了 TB+甚至更大。一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</li>
</ul>
<h4 id="存储层面"><a href="#存储层面" class="headerlink" title="存储层面"></a>存储层面</h4><ul>
<li>冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，节省存储空间和检索效率。</li>
</ul>
<h4 id="部署层面"><a href="#部署层面" class="headerlink" title="部署层面"></a>部署层面</h4><ul>
<li>一旦之前没有规划，这里就属于应急策略。结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。</li>
</ul>
]]></content>
      <categories>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/publishes/98f0d77a0556.html</url>
    <content><![CDATA[<h1 id="说⼀下⼏种常⻅的排序算法和分别的复杂度"><a href="#说⼀下⼏种常⻅的排序算法和分别的复杂度" class="headerlink" title="说⼀下⼏种常⻅的排序算法和分别的复杂度"></a>说⼀下⼏种常⻅的排序算法和分别的复杂度</h1><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了.<ul>
<li>选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。</li>
<li>基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的分在右边。</li>
<li>可以肯定，如此⼀轮下来，这个枢轴的位置⼀定在最终位置上。</li>
<li>对两个⼦数组分别重复上述过程，直到每个数组只有⼀个元素。</li>
<li>排序完成。</li>
</ul>
</li>
<li>复杂度：O(n)</li>
<li>特点：快速排序是我们平常最常使⽤的⼀种排序算法,因为它速度快,效率⾼,是最优秀的⼀种排序算法.</li>
</ul>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li>原理：冒泡排序其实就是逐⼀⽐较交换,进⾏⾥外两次循环,外层循环为遍历所有数字,逐个确定每个位置,⾥层循环为确定了位置后,遍历所有后⾯没有确定位置的数字,与该位置的数字进⾏⽐较,只要⽐该位置的数字⼩,就和该位置的数字进⾏交换.</li>
<li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li>
<li>特点：冒泡排序在我们实际开发中,使⽤的还是⽐较少的.它更加适合数据规模⽐较少的时候,因为它的效率是⽐较低的,但是优点是逻辑简单,容易让我们记得.</li>
</ul>
<h4 id="直接插⼊排序"><a href="#直接插⼊排序" class="headerlink" title="直接插⼊排序"></a>直接插⼊排序</h4><ul>
<li>原理：直接插⼊排序是将从第⼆个数字开始,逐个拿出来,插⼊到之前排好序的数列⾥.</li>
<li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li>
</ul>
<h4 id="直接选择排序："><a href="#直接选择排序：" class="headerlink" title="直接选择排序："></a>直接选择排序：</h4><ul>
<li>原理：直接选择排序是从第⼀个位置开始遍历位置,找到剩余未排序的数据⾥最⼩的,找到最⼩的后,再做交换</li>
<li>复杂度：O(n^2)</li>
<li>特点：和冒泡排序⼀样,逻辑简单,但是效率不⾼,适合少量的数据排序</li>
</ul>
<h1 id="描述⼀下链式存储结构"><a href="#描述⼀下链式存储结构" class="headerlink" title="描述⼀下链式存储结构"></a>描述⼀下链式存储结构</h1><ul>
<li>线性结构的优点是可以实现随机读取，时间复杂度为O(1)，空间利⽤率⾼，缺点是进⾏插⼊和删除操作时⽐较麻烦，时间复杂度为O(n)，同时容量受限制，需要事先确定容量⼤⼩，容量过⼤，浪费空间资源，过⼩不能满⾜使⽤要求，会产⽣溢出问题。</li>
<li>链式存储结构的优点主要是插⼊和删除⾮常简单，前提条件是知道操作位置，时间复杂度是O(1)，但如果不知道操作位置则要定位元素，时间复杂度为O(n)，没有容量的限制，可以使⽤过程中动态分配的分配内存空间，不⽤担⼼溢出问题，但是它并不能实现随机读取，同时空间利⽤率不⾼。</li>
</ul>
<h1 id="如何遍历⼀颗⼆叉树"><a href="#如何遍历⼀颗⼆叉树" class="headerlink" title="如何遍历⼀颗⼆叉树"></a>如何遍历⼀颗⼆叉树</h1><ul>
<li>先输出节点的值，再递归遍历左右⼦树。中序和后序的递归类似，改变根节点输出位置即可。</li>
</ul>
<h1 id="倒排⼀个LinkedList"><a href="#倒排⼀个LinkedList" class="headerlink" title="倒排⼀个LinkedList"></a>倒排⼀个LinkedList</h1><ul>
<li>Collections.reverse(linkedList);</li>
</ul>
<h1 id="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"><a href="#⽤java写⼀个递归遍历⽬录下⾯的所有⽂件" class="headerlink" title="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"></a>⽤java写⼀个递归遍历⽬录下⾯的所有⽂件</h1><ul>
<li>File.listFiles()</li>
</ul>
<h1 id="⼆叉树与红⿊树："><a href="#⼆叉树与红⿊树：" class="headerlink" title="⼆叉树与红⿊树："></a>⼆叉树与红⿊树：</h1><h4 id="⼆叉树"><a href="#⼆叉树" class="headerlink" title="⼆叉树"></a>⼆叉树</h4><ul>
<li>左⼦树上所有结点的值均⼩于或等于它的根结点的值。</li>
<li>右⼦树上所有结点的值均⼤于或等于它的根结点的值。</li>
<li>左、右⼦树也分别为⼆叉排序树。</li>
<li>查找：⼆分查找（通过⼀层⼀层的⽐较⼤⼩来查找位置）：如查找值为10的节点：9–13–11–10</li>
<li>缺陷：插⼊容易变成线性形态，查找性能⼤打折扣，这时需要引⼊红⿊树来解决</li>
</ul>
<h4 id="红⿊树"><a href="#红⿊树" class="headerlink" title="红⿊树"></a>红⿊树</h4><ul>
<li>特点：是⼀种⾃平衡的⼆叉查找树，除了符合⼆叉树的特点之外，还符合以下⼏点：<ul>
<li>节点是红⾊或⿊⾊。</li>
<li>根节点是⿊⾊。</li>
<li>每个叶⼦节点都是⿊⾊的空节点（NIL节点）。</li>
<li>每个红⾊节点的两个⼦节点都是⿊⾊。(从每个叶⼦到根的所有路径上不能有两个连续的红⾊节点)</li>
<li>从任⼀节点到其每个叶⼦的所有路径都包含相同数⽬的⿊⾊节点。</li>
</ul>
</li>
<li>这些规则保证了红⿊树的⾃平衡。</li>
<li>红⿊树从根到叶⼦的最长路径不会超过最短路径的2倍。</li>
<li>提⾼寻址效率。</li>
<li>添加删除：通过⾃旋来保证平衡</li>
</ul>
<h1 id="b-tree、b-tree多叉树："><a href="#b-tree、b-tree多叉树：" class="headerlink" title="b-tree、b+tree多叉树："></a>b-tree、b+tree多叉树：</h1><h4 id="b-tree"><a href="#b-tree" class="headerlink" title="b-tree"></a>b-tree</h4><ul>
<li>⽂件系统</li>
<li>B树也称B-树,它是⼀颗多路平衡查找树</li>
<li>我们描述⼀颗B树时需要指定它的阶数，阶数表示了⼀个结点最多有多少个孩⼦结点，⼀般⽤字⺟m表示阶数</li>
<li>当m取2时，就是我们常⻅的⼆叉搜索树。</li>
<li>定义：<ul>
<li>每个结点最多有m-1个关键字。</li>
<li>根结点最少可以只有1个关键字。</li>
<li>⾮根结点⾄少有Math.ceil(m&#x2F;2)-1个关键字。</li>
<li>每个结点中的关键字都按照从⼩到⼤的顺序排列，每个关键字的左⼦树中的所有关键字都⼩于它，⽽右⼦树中的所有关键字都⼤于它。</li>
<li>所有叶⼦结点都位于同⼀层，或者说根结点到每个叶⼦结点的⻓度都相同。</li>
</ul>
</li>
<li>插⼊数据，向兄弟节点借，兄弟节点不够则向⽗节点借；</li>
</ul>
<h4 id="b-tree-1"><a href="#b-tree-1" class="headerlink" title="b+tree"></a>b+tree</h4><ul>
<li>mysql索引</li>
<li>定义：<ul>
<li>B+树包含2种类型的结点：内部结点（也称索引结点）和叶⼦结点。根结点本身即可以是内部结点，也可以是叶⼦结点。根结点的关键字个数最少可以只有1个。</li>
<li>B+树与B树最⼤的不同是内部结点不保存数据，只⽤于索引，所有数据（或者说记录）都保存在叶⼦结点中。</li>
<li>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个⼦树），阶数m同时限制了叶⼦结点最多存储m-1个记录。</li>
<li>内部结点中的key都按照从⼩到⼤的顺序排列，对于内部结点中的⼀个key，左树中的所有key都⼩于它，右⼦树中的key都⼤于等于它。叶⼦结点中的记录也按照key的⼤⼩排列。</li>
<li>每个叶⼦结点都存有相邻叶⼦结点的指针，叶⼦结点本身依关键字的⼤⼩⾃⼩⽽⼤顺序链接。</li>
</ul>
</li>
</ul>
<h1 id="谈谈数据结构，⽐如TreeMap："><a href="#谈谈数据结构，⽐如TreeMap：" class="headerlink" title="谈谈数据结构，⽐如TreeMap："></a>谈谈数据结构，⽐如TreeMap：</h1><ul>
<li>TreeMap实现了红⿊树的结构。</li>
</ul>
<h1 id="图的深度遍历和⼴度遍历"><a href="#图的深度遍历和⼴度遍历" class="headerlink" title="图的深度遍历和⼴度遍历"></a>图的深度遍历和⼴度遍历</h1><ul>
<li>深度优先遍历：深度优先遍历尽可能优先往深层次进⾏搜索</li>
<li>⼴度优先遍历：⼴度优先遍历按层次优先搜索最近的结点，⼀层⼀层往外搜索。</li>
</ul>
<h1 id="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"><a href="#说说java集合，每个集合下⾯有哪些实现类，及其数据结构" class="headerlink" title="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"></a>说说java集合，每个集合下⾯有哪些实现类，及其数据结构</h1><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li>概念<ul>
<li>在HashMap内部，采⽤了数组+链表的形式来组织键值对Entry&lt;Key,Value&gt;（利⽤数组的查询快+链表的插⼊删除快）</li>
<li>HashMap在存储键值对Entry&lt;Key,Value&gt;的时候，会根据Key的hashcode值，以某种映射关系，决定应当将这对键值对Entry&lt;Key,Value&gt;存储在HashMap中的什么位置上</li>
<li>在JDK1.7进⾏多线程put操作，之后遍历，直接死循环，CPU飙到100%，在JDK 1.8中进⾏多线程操作会出现节点和value值丢失，为什么JDK1.7与JDK1.8多线程操作会出现很⼤不同，是因为JDK 1.8的作者对resize⽅法进⾏了优化不会产⽣链表闭环。</li>
</ul>
</li>
<li>结构</li>
<li>HashMap扩容<ul>
<li>很简单的计算：由于默认的加载因⼦是0.75 ，那么，此时map的阀值是 16*0.75 &#x3D; 12，即添加第13 个键值对&lt;Key,Value&gt;的时候，map的容量会扩充⼀倍。</li>
<li>确实如此，但是为了尽可能第减少桶中的Entry&lt;Key,Value&gt;链表的长度，以提⾼HashMap的存取性能，确定的这个经验值</li>
</ul>
</li>
<li>扩容步骤：<ul>
<li>申请⼀个新的、⼤⼩为当前容量两倍的数组；</li>
<li>将旧数组的Entry[] table中的链表重新计算hash值，然后重新均匀地放置到新的扩充数组中；</li>
<li>释放旧的数组；</li>
</ul>
</li>
<li>为何扩容为原来的两倍（性能）：<ul>
<li>在HashMap通过键的哈希值进⾏定位桶位置的时候，调⽤了⼀个indexFor(hash, table.length);⽅法。</li>
<li>通过限制length是⼀个2的幂数，h &amp; (length-1)和h % length结果是⼀致的。</li>
<li>如果length是⼀个2的幂的数，那么length-1就会变成⼀个mask, 它会将hashcode低位取出来，</li>
<li>hashcode的低位实际就是余数，和取余操作相⽐，与操作会将性能提升很多。</li>
</ul>
</li>
<li>put流程<ul>
<li>获取这个Key的hashcode值，根据此值确定应该将这⼀对键值对存放在哪⼀个桶中，即确定要存放桶的索引；</li>
<li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul>
<li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,其中的Value值更新为新的Value值；返回旧值；</li>
<li>若不存在，则根据键值对&lt;Key,Value&gt; 创建⼀个新的Entry&lt;Key,Value&gt;对象，然后添加到这个桶的Entry&lt;Key,Value&gt;</li>
</ul>
</li>
<li>当前的HashMap的⼤⼩(即Entry&lt;key,Value&gt;节点的数⽬)是否超过了阀值，若超过了阀值(threshold)，</li>
<li>则增⼤HashMap的容量(即Entry[] table 的⼤⼩)，并且重新组织内部各个Entry&lt;Key,Value&gt;排列。</li>
</ul>
</li>
<li>get流程<ul>
<li>获取这个Key的hashcode值，根据此hashcode值决定应该从哪⼀个桶中查找；</li>
<li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul>
<li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,返回value</li>
<li>若不存在，返回null；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>红黑树是一种自平衡二叉查找树</li>
<li>它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用</li>
<li>它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。</li>
</ul>
<h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><ul>
<li>红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡</li>
<li>它的每个节点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父节点）。</li>
<li>红黑树的定义也是它的性质，有以下五条：<ul>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>所有叶子都是黑色（叶子是NIL节点）</li>
<li>如果一个节点是红的，则它的两个儿子都是黑的</li>
<li>从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
</li>
<li>这五个性质强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</li>
<li>为什么呢？性质4暗示着任何一个简单路径上不能有两个毗连的红色节点，这样，最短的可能路径全是黑色节点，最长的可能路径有交替的红色和黑色节点。同时根据性质5知道：所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</li>
</ul>
<h4 id="红黑树的基本操作"><a href="#红黑树的基本操作" class="headerlink" title="红黑树的基本操作"></a>红黑树的基本操作</h4><ul>
<li>因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同</li>
<li>然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质</li>
<li>恢复红黑树的性质需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)</li>
<li>虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次。</li>
</ul>
<h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><ul>
<li>插入操作可以概括为以下几个步骤：<ul>
<li>查找要插入的位置，时间复杂度为：O(N)</li>
<li>将新节点的color赋为红色</li>
<li>自下而上重新调整该树为红黑树</li>
</ul>
</li>
<li>其中，第(1)步的查找方法跟普通二叉查找树一样</li>
<li>第(2)步之所以将新插入的节点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的</li>
<li>但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整，这样简单多了</li>
<li>下面讨论步骤(3)的一些细节：<ul>
<li>设要插入的节点为N，其父节点为P，其父亲G的兄弟节点为U（即P和U是同一个节点的两个子节点）。</li>
<li>如果P是黑色的，则整棵树不必调整便是红黑树。</li>
<li>如果P是红色的（可知，其父节点G一定是黑色的），则插入z后，违背了性质4，需要进行调整</li>
<li>调整时分以下3种情况：<ul>
<li>N的叔叔U是红色的</li>
<li>N的叔叔U是黑色的，且N是右孩子</li>
<li>N的叔叔U是黑色的，且N是左孩子</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><ul>
<li>删除操作可以概括为以下几个步骤：<ul>
<li>查找要删除位置，时间复杂度为：O(N)</li>
<li>用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点）</li>
<li>如果删除节点的替换节点为黑色，则需重新调整该树为红黑树</li>
</ul>
</li>
<li>其中，第(1)步的查找方法跟普通二叉查找树一样</li>
<li>第(2)步之所以用后继节点替换删除节点，是因为这样可以保证该后继节点之上仍是一个红黑树，而后继节点可能是一个叶节点或者只有右子树的节点，这样只需用有节点替换后继节点即可达到删除的目的</li>
<li>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题</li>
<li>在第(3)步中，如果，如果删除节点为红色节点，则他的父亲和孩子全为黑节点，这样直接删除该节点即可，不必进行任何调整</li>
<li>如果删除节点是黑节点，分四种情况：<ul>
<li>设要删除的节点为N，其父节点为P，其兄弟节点为S。</li>
<li>由于N是黑色的，则P可能是黑色的，也可能是红色的，S也可能是黑色的或者红色的</li>
<li>S是红色的</li>
<li>S和S的孩子全是黑色的</li>
<li>S是黑色的，S的左孩子是红色，右孩子是黑色</li>
<li>S是黑色的，S的右孩子是红色</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列（MQ）</title>
    <url>/publishes/7e68be57c290.html</url>
    <content><![CDATA[<h1 id="什么是消息队列中间件"><a href="#什么是消息队列中间件" class="headerlink" title="什么是消息队列中间件"></a>什么是消息队列中间件</h1><ul>
<li>消息队列中间件（简称消息中间件）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成</li>
<li>通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能</li>
<li>ActiveMQ<ul>
<li>Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信</li>
</ul>
</li>
<li>RabbitMQ<ul>
<li>采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息</li>
<li>RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的</li>
</ul>
</li>
<li>Kafka<ul>
<li>起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，现已捐献给 Apache 基金会</li>
<li>它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用</li>
<li>目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成</li>
</ul>
</li>
<li>RocketMQ<ul>
<li>是阿里开源的消息中间件，目前已经捐献给 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双 11 的洗礼，实力不容小觑</li>
</ul>
</li>
<li>ZeroMQ<ul>
<li>号称史上最快的消息队列，基于 C 语言开发</li>
<li>ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩。</li>
<li>虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</li>
</ul>
</li>
<li>目前市面上的消息中间件还有很多，比如腾讯系的 PhxQueue、CMQ、CKafka，又比如基于 Go 语言的 NSQ，有时人们也把类似 Redis 的产品也看做消息中间件的一种</li>
</ul>
<h1 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h1><ul>
<li>场景有很多，但是比较核心的有 3 个：解耦、异步、削峰。</li>
<li>解耦<ul>
<li>假如A系统需要发送数据到BCD三个系统，通过接口调用发送。如果新系统E也要这个数据，C系统现在不需要这个数据了，A系统就需要通过新接口发给E系统，并且把C系统的调用去掉</li>
<li>在这个场景中，A系统跟其它系统严重耦合，A系统要时刻考虑BCDE四个系统是否正确收到数据，要不要重发</li>
<li>如果使用MQ，A系统产生一条数据，发送到MQ里面去，哪个系统需要数据自己去MQ里面消费。如果新系统需要数据，直接从MQ里消费即可；如果某个系统不需要这条数据了，就取消对MQ消息的消费即可。这样下来，A系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</li>
<li>通过一个MQ，发布订阅这么一个模型，A系统就跟其它系统彻底解耦了。</li>
<li>面试技巧：考虑一下你负责的系统中是否有类似的场景，有的话在简历中体现出来这块东西，用MQ作解耦。</li>
</ul>
</li>
<li>异步<ul>
<li>A系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近1s。</li>
<li>如果使用MQ，那么 A系统连续发送 3 条消息到MQ队列中，假如耗时 5ms，A系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms</li>
</ul>
</li>
<li>削峰<ul>
<li>每天 0:00 到 12:00，A系统每秒并发请求数量50个。12:00 ~ 13:00，每秒并发请求数量会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，可能导致系统崩溃，用户也就没法再使用系统了。但是高峰期一过，到了下午的时候，又成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</li>
<li>如果使用MQ，每秒 5k 个请求写入MQ，A系统每秒钟最多处理 2k 个请求。A系统从MQ中慢慢拉取请求，每秒钟就拉取 2k 个请求，这样下来，哪怕是高峰期的时候，A系统也绝对不会挂掉。而MQ每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在MQ中。这个短暂的高峰期积压是可以的，因为高峰期过了之后，每秒钟就 50 个请求进MQ，但是 A系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A系统就会快速将积压的消息给解决掉。</li>
</ul>
</li>
</ul>
<h1 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h1><ul>
<li>优点<ul>
<li>解耦、异步、削峰。</li>
</ul>
</li>
<li>缺点<ul>
<li>系统可用性降低：系统引入的外部依赖越多，越容易挂掉</li>
<li>系统复杂度提高：加个MQ进来，要解决重复消费、消息丢失、消息传递的顺序性等问题</li>
<li>一致性问题：如果消费数据的多个系统，有个别系统处理失败了，就会导致数据不一致了</li>
</ul>
</li>
</ul>
<h1 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点</h1><ul>
<li>对比</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td>-</td>
<td>-</td>
<td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody></table>
<ul>
<li>建议<ul>
<li>ActiveMQ，现在用的不多了，没经过大规模吞吐量场景的验证，社区不是很活跃，不推荐用这个；</li>
<li>RabbitMQ，erlang语言阻止了大量的Java工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是是开源的，有比较稳定的支持，活跃度也高；</li>
<li>RocketMQ，阿里出品，社区不是很活跃，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li>
<li>中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择</li>
<li>大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择</li>
<li>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
</li>
</ul>
<h1 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h1><h2 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h2><ul>
<li>RabbitMQ 是基于主从（非分布式）做高可用性的</li>
<li>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式</li>
</ul>
<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><ul>
<li>单机模式，是 Demo 级别的，一般生产环境不用单机模式。</li>
</ul>
<h3 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h3><ul>
<li>在多台机器上启动多个 RabbitMQ 实例</li>
<li>创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据</li>
<li>元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例</li>
<li>消费的时候，如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来</li>
<li>没做到所谓的分布式，就是个普通集群</li>
<li>要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈</li>
<li>如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据</li>
<li>所以这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作</li>
</ul>
<h3 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h3><ul>
<li>这种模式才是所谓的 RabbitMQ 的高可用模式</li>
<li>在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，即每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据</li>
<li>写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上</li>
<li>任何一个机器宕机了，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据</li>
<li>坏处在于<ul>
<li>性能开销大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重</li>
<li>这不是分布式的，没有扩展性可言，如果某个 queue 负载很重，加机器的话，新增的机器也包含了这个 queue 的所有数据，没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li>
</ul>
</li>
</ul>
<h2 id="Kafka-的高可用性"><a href="#Kafka-的高可用性" class="headerlink" title="Kafka 的高可用性"></a>Kafka 的高可用性</h2><ul>
<li>Kafka是分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据</li>
<li>Kafka 一个最基本的架构认识<ul>
<li>由多个 broker 组成，每个 broker 是一个节点</li>
<li>你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</li>
<li>每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本</li>
<li>所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower</li>
<li>写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可</li>
</ul>
</li>
<li>如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本</li>
<li>如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可，这就有所谓的高可用性了</li>
<li>写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者（当然，这只是其中一种模式，还可以适当调整这个行为）</li>
<li>消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到</li>
</ul>
<h1 id="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</h1><ul>
<li>RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题</li>
<li>因为这问题通常不是MQ自己保证的，是由我们开发来保证的</li>
<li>挑一个 Kafka 来举个例子，说说怎么重复消费吧</li>
<li>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示已经消费过了，下次就从上次消费到的 offset 来继续消费</li>
<li>但是系统出故障了，导致 consumer 有些消息处理了，但是没来得及提交 offset，重启之后，少数消息会再次消费一次，那么就会导致重复消费</li>
<li>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致数据在数据库里插入了 2 次，那么数据就错啦</li>
<li>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</li>
<li>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</li>
<li>保证消息队列消费的幂等性还是得结合业务来思考<ul>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li>
</ul>
</li>
</ul>
<h1 id="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"><a href="#如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？" class="headerlink" title="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"></a>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</h1><ul>
<li>数据的丢失问题，可能出现在生产者、MQ、消费者中</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul>
<li>生产者弄丢了数据<ul>
<li>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，如网络问题等。</li>
<li>选择用 RabbitMQ 提供的事务功能<ul>
<li>生产者发送数据之前开启 RabbitMQ 事务channel.txSelect</li>
<li>然后发送消息</li>
<li>如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息</li>
<li>如果收到了消息，那么可以提交事务channel.txCommit。</li>
<li>事务的缺点是吞吐量会下来，因为太耗性能</li>
</ul>
</li>
<li>开启confirm模式<ul>
<li>在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，告诉你说这个消息 ok 了</li>
<li>如果 RabbitMQ 没能处理这个消息，会回调你的一个nack接口，告诉你这个消息接收失败，你可以重试</li>
<li>而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发</li>
</ul>
</li>
<li>事务机制和confirm机制最大的不同在于<ul>
<li>事务机制是同步的，你提交一个事务之后会阻塞在那儿</li>
<li>confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了</li>
</ul>
</li>
<li>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</li>
</ul>
</li>
<li>RabbitMQ 弄丢了数据<ul>
<li>就是 RabbitMQ 自己弄丢了数据</li>
<li>这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢</li>
<li>除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</li>
<li>设置持久化有两个步骤：<ul>
<li>创建 queue 的时候将其设置为持久化，这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的</li>
<li>发送消息的时候将消息的deliveryMode设置为 2，就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去</li>
</ul>
</li>
<li>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据</li>
<li>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失</li>
<li>所以，持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到ack，你也是可以自己重发的</li>
</ul>
</li>
<li>消费端弄丢了数据<ul>
<li>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，RabbitMQ 认为你都消费了，这数据就丢了。</li>
<li>这个时候得用 RabbitMQ 提供的ack机制<ul>
<li>就是关闭 RabbitMQ 的自动ack</li>
<li>可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把</li>
<li>这样的话，如果你还没处理完，不就没有ack了，RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul>
<li>消费端弄丢了数据<ul>
<li>唯一可能导致消费者弄丢数据的情况，就是消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实消息还没处理，系统挂了，此时这条消息就丢了</li>
<li>需要关闭自动提交offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢</li>
</ul>
</li>
<li>Kafka弄丢了数据<ul>
<li>如果Kafka某个broker宕机，然后重新选举 partition 的 leader，此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，这就丢了一些数据</li>
<li>所以此时一般是要求起码设置如下 4 个参数<ul>
<li>给 topic 设置replication.factor参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本</li>
<li>在 Kafka 服务端设置min.insync.replicas参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower</li>
<li>在 producer 端设置acks&#x3D;all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了</li>
<li>在 producer 端设置retries&#x3D;MAX（很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试</li>
</ul>
</li>
<li>按照上述要求配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失</li>
</ul>
</li>
<li>生产者会不会弄丢数据<ul>
<li>如果按照上述的思路设置了acks&#x3D;all，一定不会丢</li>
<li>因为leader接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了，如果没满足这个条件，生产者会自动不断的重试，重试无限次</li>
</ul>
</li>
</ul>
<h1 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h1><ul>
<li>消息顺序错乱场景<ul>
<li>RabbitMQ：一个 queue，多个 consumer<ul>
<li>比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列</li>
<li>有三个消费者分别从MQ中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3，顺序就乱了。</li>
</ul>
</li>
<li>Kafka：一个 topic，一个 partition，一个consumer，consumer是多线程的<ul>
<li>生产者在写的时候，其实可以指定一个 key，比如订单 id 作为 key，那么这个数据一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的</li>
<li>消费者从 partition 中取出来数据的时候，也一定是有顺序的</li>
<li>如果消费用多个线程来并发处理消息，顺序可能就乱掉了</li>
</ul>
</li>
</ul>
</li>
<li>解决方案<ul>
<li>RabbitMQ<ul>
<li>拆分多个 queue，每个 queue 一个 consumer</li>
<li>或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理</li>
</ul>
</li>
<li>Kafka<ul>
<li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个</li>
<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue，然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="有几百万消息持续积压几小时，说说怎么解决？"><a href="#有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="有几百万消息持续积压几小时，说说怎么解决？"></a>有几百万消息持续积压几小时，说说怎么解决？</h1><ul>
<li>先假设一个场景，我们现在消费端出故障了，然后大量消息在MQ里积压，大量消息在MQ里积压了几个小时了还没解决。这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕，一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来</li>
<li>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：<ul>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉</li>
<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue</li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据</li>
<li>这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据</li>
<li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息</li>
</ul>
</li>
</ul>
<h1 id="如何解决消息队列的延时以及过期失效问题？"><a href="#如何解决消息队列的延时以及过期失效问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？"></a>如何解决消息队列的延时以及过期失效问题？</h1><ul>
<li>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL，如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了</li>
<li>这个情况下，我们可以采取一个方案，就是批量重导，就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入MQ里面去，把白天丢的数据给他补回来</li>
<li>假设 1 万个订单积压在MQ里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到MQ里去再补一次</li>
</ul>
<h1 id="消息队列满了以后该怎么处理？"><a href="#消息队列满了以后该怎么处理？" class="headerlink" title="消息队列满了以后该怎么处理？"></a>消息队列满了以后该怎么处理？</h1><ul>
<li>如果消息积压在MQ里，你很长时间都没有处理掉，此时导致MQ都快写满了<ul>
<li>临时写程序，接入数据来消费，消费一个丢弃一个</li>
<li>都不要了，快速消费掉所有的消息。然后走批量重导的方案，到了晚上再补数据</li>
</ul>
</li>
</ul>
<h1 id="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"><a href="#如果让你写一个消息队列，该如何进行架构设计？说一下你的思路" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"></a>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</h1><ul>
<li>其实回答这类问题，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好</li>
<li>比如说这个消息队列系统，我们从以下几个角度来考虑一下<ul>
<li>可伸缩性<ul>
<li>就是需要的时候快速扩容，就可以增加吞吐量和容量，设计个分布式的系统，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据，如果现在资源不够了，给 topic 增加 partition，然后做数据迁移，增加机器，就可以存放更多数据，提供更高的吞吐量了</li>
</ul>
</li>
<li>数据要落地磁盘<ul>
<li>落磁盘才能保证别进程挂了数据就丢了，那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路</li>
</ul>
</li>
<li>高可用性<ul>
<li>具体参考kafka的高可用保障机制，多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务</li>
</ul>
</li>
<li>能不能支持数据 0 丢失<ul>
<li>可以的，参考 kafka 数据零丢失方案</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="四款消息队列的对比"><a href="#四款消息队列的对比" class="headerlink" title="四款消息队列的对比"></a>四款消息队列的对比</h1><h2 id="MSMQ"><a href="#MSMQ" class="headerlink" title="MSMQ"></a>MSMQ</h2><ul>
<li>这是微软的产品里唯一被认为有价值的东西</li>
<li>这个东西并不复杂，除了接收和发送，没有别的</li>
<li>它有一些硬性限制，比如最大消息体积是4MB，然而，通过和一些像MassTransit 或 NServiceBus这样的软件的连接，它完全可以解决这些问题</li>
<li>优点：<ul>
<li>由于是异步通信，无论是发送方还是接收方都不用等待对方返回成功消息，就可以执行余下的代码，因而大大地提高了事物处理的能力</li>
<li>当信息传送过程中，信息发送机制具有一定功能的故障恢复能力</li>
<li>MSMQ的消息传递机制使得消息通信的双方具有不同的物理平台成为可能</li>
</ul>
</li>
</ul>
<h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><ul>
<li>多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li>
<li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务）</li>
<li>对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性</li>
<li>通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic）的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上</li>
<li>支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li>
<li>支持通过JDBC和journal提供高速的消息持久化</li>
<li>从设计上保证了高性能的集群，客户端-服务器，点对点</li>
<li>支持Ajax</li>
<li>支持与Axis的整合</li>
<li>可以很容易得调用内嵌JMS provider，进行测试</li>
</ul>
<h2 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul>
<li>它支持开放的高级消息队列协议 (AMQP，Advanced Message Queuing Protocol)</li>
<li>从根本上避免了生产厂商的封闭，使用任何语言的各种客户都可以从中受益</li>
<li>这种协议提供了相当复杂的消息传输模式，所以基本上不需要 MassTransit 或 NServiceBus 的配合</li>
</ul>
<h2 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h2><ul>
<li>ZeroMQ 是一个轻量级消息内核</li>
<li>它可用于C、C++、Python、.NET &#x2F;Mono、Fortran和Java语言</li>
<li>它运行在AIX ， FreeBSD的，基于HP - UX ， Linux和MacOS下， OpenBSD系统， OpenVMS ， QNX Neutrino， Solaris和Windows操作系统。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>ActiveMQ需要在目标机器上安装Java，RabbitMQ需要Erlang环境</li>
<li>ActiveMQ,RabbitMQ 和 MSMQ 都需要启动服务进程，这些都可以监控和配置，另外一个就有问题了</li>
<li>ZeroMQ，它没有中间件架构，不需要任何服务进程和运行时，事实上，你的应用程序端点扮演了这个服务角色，这让部署起来非常简单，但担心的是，你没有地方可以观察它是否有问题出现。就目前我知道的，ZeroMQ仅提供非持久性的队列，你可以在需要的地方实现自己的审计和数据恢复功能</li>
<li>如果你希望一个应用程序发送消息越快越好，你选择ZeroMQ，当你不太在意偶然会丢失某些消息的情况下更有价值</li>
<li>虽然说ZeroMQ的速度很惊人，但是对于数据就是生命的年代，我们宁可降低一些需求也不愿意丢失任何一条宝贵的数据，所以综合对比下来，我觉得RabbitMQ更适合</li>
</ul>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>ActiveMQ</tag>
        <tag>RabbitMQ</tag>
        <tag>Kafka</tag>
        <tag>RocketMQ</tag>
        <tag>ZeroMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/publishes/fca1d6209800.html</url>
    <content><![CDATA[<h1 id="TCP建⽴连接的过程。"><a href="#TCP建⽴连接的过程。" class="headerlink" title="TCP建⽴连接的过程。"></a>TCP建⽴连接的过程。</h1><h4 id="三次握⼿"><a href="#三次握⼿" class="headerlink" title="三次握⼿"></a>三次握⼿</h4><ul>
<li>第⼀次握⼿(客户端发送syn包到服务器端)：客户端发送syn包到服务器端，进⼊syn_send状态，等待服务器端的确认；</li>
<li>第⼆次握⼿(服务器返回syn+ack包给客户端)：服务器端收到客户端的syn包，发送syn+ack包给客户端，进⼊syn_recv状态；</li>
<li>第三次握⼿(客服端返回ack包给服务端)：客户端收到服务器端的syn+ack包，发送个ack包到服务器端，⾄此，客户端与服务器端进⼊established状态；</li>
<li>握⼿过程中传送的包不包含任何数据，连接建⽴后才会开始传送数据，理想状态下，TCP连接⼀旦建⽴，在通信双⽅的任何⼀⽅主动关闭连接前，TCP连接都会⼀直保持下去。</li>
</ul>
<h1 id="TCP断开连接的过程。"><a href="#TCP断开连接的过程。" class="headerlink" title="TCP断开连接的过程。"></a>TCP断开连接的过程。</h1><h4 id="四次握⼿"><a href="#四次握⼿" class="headerlink" title="四次握⼿"></a>四次握⼿</h4><ul>
<li>第⼀次握⼿：主动关闭⽅发送fin包到被动关闭⽅，告诉被动关闭⽅我不会再给你发送数据了；</li>
<li>第⼆次握⼿：被动关闭⽅收到syn包，发送ack给对⽅，确认序号为收到序号+1；</li>
<li>第三次握⼿：被动关闭⽅也也发送fin包给主动关闭⽅，告诉对⽅我也不会给你发送数据了；</li>
<li>第四次握⼿：主动关闭⽅收到syn包，发送ack给对⽅，⾄此，完成四次握⼿；</li>
</ul>
<h1 id="浏览器发⽣302跳转背后的逻辑"><a href="#浏览器发⽣302跳转背后的逻辑" class="headerlink" title="浏览器发⽣302跳转背后的逻辑"></a>浏览器发⽣302跳转背后的逻辑</h1><ul>
<li>浏览器在原请求地址的响应的Location域找到要跳转的URI执⾏跳转。</li>
</ul>
<h4 id="浏览器输⼊URL后发⽣了什么"><a href="#浏览器输⼊URL后发⽣了什么" class="headerlink" title="浏览器输⼊URL后发⽣了什么"></a>浏览器输⼊URL后发⽣了什么</h4><ul>
<li>DNS域名解析；</li>
<li>建⽴TCP连接；</li>
<li>发送HTTP请求；</li>
<li>服务器处理请求；</li>
<li>返回响应结果；</li>
<li>关闭TCP连接；</li>
<li>浏览器解析HTML；</li>
<li>浏览器布局渲染；</li>
</ul>
<h1 id="HTTP协议的交互流程。-HTTP和HTTPS的差异，-SSL的交互流程？"><a href="#HTTP协议的交互流程。-HTTP和HTTPS的差异，-SSL的交互流程？" class="headerlink" title="HTTP协议的交互流程。 HTTP和HTTPS的差异， SSL的交互流程？"></a>HTTP协议的交互流程。 HTTP和HTTPS的差异， SSL的交互流程？</h1><h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h4><ul>
<li>建⽴TCP连接；</li>
<li>发送HTTP请求；</li>
<li>服务器处理请求；</li>
<li>返回响应结果；</li>
<li>关闭TCP连接；</li>
</ul>
<h5 id="http三次握⼿："><a href="#http三次握⼿：" class="headerlink" title="http三次握⼿："></a>http三次握⼿：</h5><ul>
<li>第⼀次握⼿：客户端发送syn包(syn&#x3D;j)到服务器，并进⼊SYN_SEND状态，等待服务器确认；</li>
<li>第⼆次握⼿：服务器收到syn包，必须确认客户的SYN（ack&#x3D;j+1），同时⾃⼰也发送⼀个SYN包（syn&#x3D;k），即<br>SYN+ACK包，此时服务器进⼊SYN_RECV状态；</li>
<li>第三次握⼿：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进⼊ESTABLISHED状态，完成三次握⼿。</li>
</ul>
<h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><ul>
<li>TTPS协议就是基于SSL的HTTP协议</li>
<li>HTTPS使⽤与HTTP不同的端⼝（HTTPS80 ， HTTPSS443）</li>
<li>提供了身份验证与加密通信⽅法，被⼴泛⽤于互联⽹上安全敏感的通信。</li>
<li>客户端请求SSL连接，并将⾃⼰⽀持的加密规则发给⽹站。</li>
<li>服务器端将⾃⼰的身份信息以证书形式发回给客户端。证书⾥⾯包含了⽹站地址，加密公钥，以及证书的颁发机构。</li>
<li>获得证书后，客户要做以下⼯作<ul>
<li>验证证书合法性</li>
<li>如果证书受信任，客户端会⽣成⼀串随机数的密码，并⽤证书提供的公钥进⾏加密。</li>
<li>将加密好的随机数发给服务器。</li>
<li>获得到客户端发的加密了的随机数之后，服务器⽤⾃⼰的私钥进⾏解密，得到这个随机数，把这个随机数作为对称加密的密钥。（利⽤⾮对称加密传输对称加密的密钥）</li>
<li>之后服务器与客户之间就可以⽤随机数对各⾃的信息进⾏加密，解密。</li>
</ul>
</li>
<li>注意的是：证书是⼀个公钥，这个公钥是进⾏加密⽤的。⽽私钥是进⾏解密⽤的。公钥任何都知道，私钥只有⾃⼰知道。这是⾮对称加密。⽽对称加密就是钥匙只有⼀把，我们都知道。</li>
<li>之所以⽤到对称加密，是因为对称加密的速度更快。⽽⾮对称加密的可靠性更⾼。</li>
<li>客户端请求–服务端发送证书（公钥）–客户端验证证书，并⽣成随机数，通过公钥加密后发送给服务端–服务端⽤私钥解密出随机数–对称加密传输数据。</li>
</ul>
<h4 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h4><ul>
<li>HTTPS协议需要申请证书。</li>
<li>HTTP是明⽂传输；HTTPS使⽤的是具有安全性的SSL加密传输协议</li>
<li>HTTP端⼝是80；HTTPS端⼝号是443</li>
<li>HTTP连接简单⽆状态；HTTPS由SSL+HTTP协议构件的可进⾏加密传输、身份验证的⽹络协议。</li>
</ul>
<h4 id="Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解"><a href="#Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解" class="headerlink" title="Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解?"></a>Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解?</h4><ul>
<li>Http是⼀种协议，Rest是⼀种软件架构⻛格。</li>
<li>URL定位资源，⽤HTTP动词（GET,POST,DELETE,DETC）描述操作。</li>
<li>GET表示查询、POST表示新建、PUT表示更新、DELETE表示删除等。<ul>
<li>GET &#x2F;api&#x2F;v1&#x2F;user 获取⽤户列表</li>
<li>GET &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 获取ID为1的⽤户</li>
<li>POST &#x2F;api&#x2F;v1&#x2F;user 新建⽤户</li>
<li>PUT &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 更新ID为1的⽤户信息</li>
<li>DELETE &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 删除ID为1的⽤户</li>
</ul>
</li>
<li>概念：REST（英⽂：Representational State Transfer，简称REST，表现层状态转化），指的是⼀组架构约束条件和原则。满⾜这些约束条件和原则的应⽤程序或设计就是 RESTful。</li>
<li>⼀种软件架构⻛格，设计⻛格⽽不是标准，只是提供了⼀组设计原则和约束条件。它主要⽤于客户端和服务器交互类的软件。基于这个⻛格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li>
<li>Restful架构：<ul>
<li>每⼀个URI代表⼀种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>客户端通过四个HTTP动词(GET⽤来获取资源，POST⽤来新建资源（也可以⽤于更新资源），PUT⽤来更新资源，DELETE⽤来删除资源。)，对服务器端资源进⾏操作，实现”表现层状态转化”。</li>
</ul>
</li>
</ul>
<h1 id="TCP的滑动窗⼝协议有什么⽤？讲讲原理。"><a href="#TCP的滑动窗⼝协议有什么⽤？讲讲原理。" class="headerlink" title="TCP的滑动窗⼝协议有什么⽤？讲讲原理。"></a>TCP的滑动窗⼝协议有什么⽤？讲讲原理。</h1><ul>
<li>滑动窗⼝协议是传输层进⾏流控的⼀种措施，接收⽅通过通告发送⽅⾃⼰的窗⼝⼤⼩，从⽽控制发送⽅的发送速度，从⽽达到防⽌发送⽅发送速度过快⽽导致来不及接受。</li>
</ul>
<h1 id="HTTP协议都有哪些⽅法？"><a href="#HTTP协议都有哪些⽅法？" class="headerlink" title="HTTP协议都有哪些⽅法？"></a>HTTP协议都有哪些⽅法？</h1><ul>
<li>GET 请求获取由Request-URI所标识的资源。</li>
<li>POST 在Request-URI所标识的资源后附加新的数据。</li>
<li>HEAD 请求获取由Request-URI所标识的资源的响应消息报头。</li>
<li>OPTIONS 请求查询服务器的性能，或查询与资源相关的选项和需求。</li>
<li>PUT 请求服务器存储⼀个资源，并⽤Request-URI作为其标识。</li>
<li>DELETE 请求服务器删除由Request-URI所标识的资源。</li>
<li>TRACE 请求服务器回送收到的请求信息，主要⽤语测试或诊断。</li>
</ul>
<h1 id="交换机与路由器的区别？"><a href="#交换机与路由器的区别？" class="headerlink" title="交换机与路由器的区别？"></a>交换机与路由器的区别？</h1><h4 id="⼯作层次不同"><a href="#⼯作层次不同" class="headerlink" title="⼯作层次不同"></a>⼯作层次不同</h4><ul>
<li>最初的交换机⼯作在OSI模型中的数据链路层，⼯作原理简单</li>
<li>路由器⼯作在OSI模型中的⽹络层，得更多协议信息，做更智能的转发决策</li>
</ul>
<h4 id="数据转发所依据的对象不同"><a href="#数据转发所依据的对象不同" class="headerlink" title="数据转发所依据的对象不同"></a>数据转发所依据的对象不同</h4><ul>
<li>交换机是利⽤物理地址（MAC地址），确定转发的⽬的地址。（MAC固化硬件，⼀般不可更改）</li>
<li>路由器是利⽤IP地址，确定转发的⽬的地址。（IP通常为⽹关或p系统⾃动分配的）</li>
</ul>
<h4 id="是否可以分割⼴播域"><a href="#是否可以分割⼴播域" class="headerlink" title="是否可以分割⼴播域"></a>是否可以分割⼴播域</h4><ul>
<li>传统的交换机可以分割冲突域，不能分割⼴播域，⽽路由器可以分割⼴播域</li>
<li>由交换机连接的⽹段仍然属于同⼀⼴播域，⼴播数据报会在交换机连接的所有⽹段上传播，某些情况导致通信拥堵和安全漏洞。</li>
<li>连接到路由器上的⽹段被分配成不同的⼴播域，所以，⼴播数据不穿过路由器</li>
<li>虽然三层交换机可以分割⼴播域，但是⼦⼴播域之间不能通信，还是需要路由器</li>
</ul>
<h4 id="路由器提供了防⽕墙的服务"><a href="#路由器提供了防⽕墙的服务" class="headerlink" title="路由器提供了防⽕墙的服务"></a>路由器提供了防⽕墙的服务</h4><ul>
<li>路由器仅仅转发特定地址的数据包，不传送不⽀持路由协议的数据包，不传送未知⽬标⽹络数据包，从⽽可以防⽌⼴播⻛暴</li>
</ul>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul>
<li>⼆层交换机上存在MAC表，三层交换机上存在路由表、MAC表、ARP表，路由器上存在路由表和ARP表。</li>
<li>总之，交换机在具体的城域⽹中扮演着VLAN透传的⻆⾊，就是桥。</li>
<li>路由器的每⼀个端⼝都是⼀个独⽴的⼴播域和冲突域，⽽交换机是只有⼀个⼴播域和端⼝数量的冲突域。</li>
</ul>
<h1 id="Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？"><a href="#Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？" class="headerlink" title="Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？"></a>Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？</h1><h4 id="socket⽹络通信"><a href="#socket⽹络通信" class="headerlink" title="socket⽹络通信"></a>socket⽹络通信</h4><ul>
<li>NIO流以及多线程处理技术：</li>
<li>BIO:阻塞式，线程池初始时创建⼀定量线程，超过则等待；</li>
<li>NIO:⾮阻塞式，不同的线程⼲专业的事情，提⾼系统吞吐量；</li>
<li>NIO+异步处理：让少量的线程做⼤量的事情；</li>
</ul>
<h4 id="Mina"><a href="#Mina" class="headerlink" title="Mina"></a>Mina</h4><ul>
<li>Apache Mina是⼀个能够帮助⽤户开发⾼性能和⾼伸缩性⽹络应⽤程序的框架。</li>
<li>它通过Java nio技术基于TCP&#x2F;IP和UDP&#x2F;IP协议提供了抽象的、事件驱动的、异步的API</li>
<li>采⽤⾮阻塞⽅式的异步传输，⽀持批量传输数据</li>
<li>mina框架简单⾼效，完成了底层的线程管理，内置编码器能够满⾜⼤多数⽤户的需求，省去了消息编码和解码的⼯作。</li>
</ul>
<h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><ul>
<li>本质是JBoss开发的⼀个jar包，⽬的是开发⾼性能、⾼可靠性的⽹络服务和客户端服务</li>
<li>提供异步⾮阻塞的、事件驱动的⽹络应⽤程序的NIO框架和⼯具</li>
<li>处理socket</li>
<li>通过Future-Listener机制，⽤户可以⽅便的主动获取或者通过通知机制获得IO操作结果。</li>
</ul>
<h1 id="http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）"><a href="#http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）" class="headerlink" title="http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）"></a>http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>HTTP协议是Hyper Text Transfer Protocol（超⽂本传输协议）的缩写,是⽤于从万维⽹（WWW:World Wide Web ）服务器传输超⽂本到本地浏览器的传送协议。</li>
<li>HTTP是⼀个基于TCP&#x2F;IP通信协议来传递数据（HTML ⽂件, 图⽚⽂件, 查询结果等）。</li>
<li>HTTP是⼀个属于应⽤层的⾯向对象的协议，由于其简捷、快速的⽅式，适⽤于分布式超媒体信息系统。它于1990年提出，经过⼏年的使⽤与发展，得到不断地完善和扩展。⽬前在WWW中使⽤的是HTTP&#x2F;1.0的第六版，HTTP&#x2F;1.1的规范化⼯作正在进⾏之中，⽽且HTTP-NG(Next Generation of HTTP)的建议已经提出。</li>
<li>HTTP协议⼯作于客户端-服务端架构为上。</li>
<li>浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求</li>
<li>Web服务器根据接收到的请求后，向客户端发送响应信息。</li>
</ul>
<h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul>
<li>简单快速：客户向服务器请求服务时，只需传送请求⽅法和路径。请求⽅法常⽤的有GET、HEAD、POST。每种⽅法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模⼩，因⽽通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>⽆连接：⽆连接的含义是限制每次连接只处理⼀个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采⽤这种⽅式可以节省传输时间。</li>
<li>⽆状态：HTTP协议是⽆状态协议。⽆状态是指协议对于事务处理没有记忆能⼒。缺少状态意味着如果后续处理需要前⾯的信息，则它必须重传，这样可能导致每次连接传送的数据量增⼤。另⼀⽅⾯，在服务器不需要先前信息时它的应答就较快。</li>
<li>⽀持B&#x2F;S及C&#x2F;S模式。</li>
</ul>
<h1 id="get与post区别"><a href="#get与post区别" class="headerlink" title="get与post区别"></a>get与post区别</h1><ul>
<li>表单的method如果为get,那么所有的参数信息都会显示在浏览器的地址栏，当我们使⽤浏览器地址栏输⼊⽹址的⽅式来发送请求时,那么该请求⼀定是get⽅式</li>
<li>对于get⽅式,底层是将所有参数附加在请求资源的后⾯⼀起传递的，对于post⽅式,底层是将所有参数附加在请求参数的最后⼀⾏的下⼀⾏的下⼀⾏，Get请求的数据是被附在url之后（HTTP协议头中），POST请求数据则放置在HTTP包的包体head中；</li>
<li>对于get,post⽅式,servlet不同处理：doGet()，doPost();</li>
<li>浏览器处理：重复访问使⽤GET⽅法请求的⻚⾯，浏览器会使⽤缓存处理后续请求。使⽤POST⽅法的form提交时，浏览器基于POST将产⽣永久改变的假设，将让⽤户进⾏提交确认。</li>
</ul>
<h1 id="rpc和http的区别，使⽤场景"><a href="#rpc和http的区别，使⽤场景" class="headerlink" title="rpc和http的区别，使⽤场景"></a>rpc和http的区别，使⽤场景</h1><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h5><ul>
<li>RPC，可以基于TCP协议，也可以基于HTTP协议</li>
<li>HTTP，基于HTTP协议</li>
</ul>
<h5 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h5><ul>
<li>RPC，使⽤⾃定义的TCP协议，可以让请求报⽂体积更⼩，或者使⽤HTTP2协议，也可以很好的减少报⽂的体积，提⾼传输效率</li>
<li>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多⽆⽤的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为⼀个RPC来使⽤的，这时标准RPC框架更多的是服务治理性能消耗，主要在于序列化和反序列化的耗时<br>RPC，可以基于thrift实现⾼效的⼆进制传输</li>
<li>HTTP，⼤部分是通过json来实现的，字节⼤⼩和序列化耗时都⽐thrift要更消耗性能</li>
</ul>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><ul>
<li>RPC，基本都⾃带了负载均衡策略</li>
<li>HTTP，需要配置Nginx，HAProxy来实现</li>
</ul>
<h5 id="服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）"><a href="#服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）" class="headerlink" title="服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）"></a>服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）</h5><ul>
<li>RPC，能做到⾃动通知，不影响上游</li>
<li>HTTP，需要事先通知，修改Nginx&#x2F;HAProxy配置</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。</li>
<li>HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。</li>
</ul>
<h1 id="说说TCP-UDP和socket-Http之间联系和区别"><a href="#说说TCP-UDP和socket-Http之间联系和区别" class="headerlink" title="说说TCP,UDP和socket,Http之间联系和区别"></a>说说TCP,UDP和socket,Http之间联系和区别</h1><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><ul>
<li>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。</li>
<li>在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。</li>
<li>在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。</li>
<li>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</li>
</ul>
<h5 id="TCP的优点"><a href="#TCP的优点" class="headerlink" title="TCP的优点"></a>TCP的优点</h5><ul>
<li>可靠，稳定</li>
<li>TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</li>
</ul>
<h5 id="TCP的缺点"><a href="#TCP的缺点" class="headerlink" title="TCP的缺点"></a>TCP的缺点</h5><ul>
<li>慢，效率低，占用系统资源高，易被攻击</li>
<li>TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。<br>由于TCP存在确认机制和三次握手机制，这些是导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</li>
</ul>
<h5 id="TCP应用场景"><a href="#TCP应用场景" class="headerlink" title="TCP应用场景"></a>TCP应用场景</h5><ul>
<li>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</li>
<li>在日常生活中，常见使用TCP协议的应用比如：浏览器使用HTTP，Outlook使用POP、SMTP，QQ文件传输等。</li>
</ul>
<h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><ul>
<li>U- DP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。</li>
</ul>
<h5 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h5><ul>
<li>快，比TCP稍安全</li>
<li>UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……</li>
</ul>
<h5 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h5><ul>
<li>不可靠，不稳定</li>
<li>因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</li>
</ul>
<h5 id="UDP应用场景"><a href="#UDP应用场景" class="headerlink" title="UDP应用场景"></a>UDP应用场景</h5><ul>
<li>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。在日常生活中，常见使用UDP协议的应用比如：QQ语音、QQ视频、TFTP等。</li>
<li>TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。</li>
<li>TCP&#x2F;IP是个协议组，可分为三个层次：网络层、传输层和应用层。<ul>
<li>在网络层有：IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。</li>
<li>在传输层中有：TCP协议与UDP协议。</li>
<li>在应用层有：FTP、HTTP、TELNET、SMTP、DNS等协议。</li>
</ul>
</li>
<li>因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。</li>
<li>TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。</li>
<li>虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。</li>
</ul>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><ul>
<li>HTTP（超文本传输协议）是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。</li>
<li>HTTP是短连接：客户端发送请求都需要服务器端回送响应.请求结束后，主动释放链接，因此为短连接。通常的做法是，不需要任何数据，也要保持每隔一段时间向服务器发送”保持连接”的请求。这样可以保证客户端在服务器端是”上线”状态。</li>
<li>HTTP连接使用的是”请求-响应”方式，不仅在请求时建立连接，而且客户端向服务器端请求后，服务器才返回数据。</li>
</ul>
<h4 id="Socket协议"><a href="#Socket协议" class="headerlink" title="Socket协议"></a>Socket协议</h4><ul>
<li>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</li>
<li>建立网络通信连接至少要一对端口号（socket）。socket本质是编程接口（API），对TCP&#x2F;IP的封装，TCP&#x2F;IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</li>
</ul>
<h1 id="TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由"><a href="#TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由" class="headerlink" title="TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由"></a>TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由</h1><ul>
<li>三次握手是为了防止已失效的连接请求再次传送到服务器端</li>
<li>二次握手不可行，因为：如果由于网络不稳定，虽然客户端以前发送的连接请求已到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。</li>
</ul>
<h1 id="HTTP协议工作原理及其特点"><a href="#HTTP协议工作原理及其特点" class="headerlink" title="HTTP协议工作原理及其特点"></a>HTTP协议工作原理及其特点</h1><ul>
<li>超文本传输协议（HTTP：Hypertext Transport Protocol）是万维网应用层的协议，它通过两个程序实现：一个是客户端程序（各种浏览器），另一个是服务器 （常称Web服务器）。这两个通常运行在不同的主机上，通过交换报文来完成网页请求和响应，报文可简单分为请求报文和响应报文。</li>
<li>工作原理（流程）：<ul>
<li>客户机与服务器建立连接后，浏览器可以向web服务器发送请求并显示收到的网页，当用户在浏览器地址栏中输入一个URL或点击一个超连接时，浏览器就向服务器发出了HTTP请求，请求方式的格式为：统一资源标识符、协议版本号，后边是MIME（Multipurpose Internet Mail Extensions）信息包括请求修饰符、客户机信息和可能的内容</li>
<li>该请求被送往由URL指定的WEB服务器，WEB服务器接收到请求后，进行相应反映，其格式为：一个状态行包括信息的协议版本号、一个成功或错误的代码，后边服务器信息、实体信息和可能的内容</li>
<li>即以HTTP规定的格式送回所要求的文件或其他相关信息，再由用户计算机上的浏览器负责解释和显示</li>
</ul>
</li>
<li>特点：<ul>
<li>支持客户&#x2F;服务器模式。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ul>
</li>
</ul>
<h1 id="介绍OSI七层模型和TCP-IP模型"><a href="#介绍OSI七层模型和TCP-IP模型" class="headerlink" title="介绍OSI七层模型和TCP&#x2F;IP模型"></a>介绍OSI七层模型和TCP&#x2F;IP模型</h1><ul>
<li>OSI(Open System Interconnection)，开放式系统互联参考模型</li>
<li>是一个逻辑上的定义，一个规范，它把网络协议从逻辑上分为了7层</li>
<li>每一层都有相关、相对应的物理设备，比如常规的路由器是三层交换设备，常规的交换机是二层交换设备</li>
<li>OSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输</li>
<li>它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。</li>
<li>TCP&#x2F;IP协议是Internet最基本的协议、Internet国际互联网络的基础，主要由网络层的IP协议和传输层的TCP协议组成</li>
<li>TCP&#x2F;IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准</li>
<li>协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
<li>ISO制定的OSI参考模型的过于庞大、复杂招致了许多批评。伴随着互联网的流行，其本身所采用的TCP&#x2F;IP协议栈获得了更为广泛的应用和认可。在TCP&#x2F;IP参考模型中，去掉了OSI参考模型中的会话层和表示层（这两层的功能被合并到应用层实现）。同时将OSI参考模型中的数据链路层和物理层合并为主机到网络层</li>
</ul>
<h1 id="TCP协议和UDP协议的比较"><a href="#TCP协议和UDP协议的比较" class="headerlink" title="TCP协议和UDP协议的比较"></a>TCP协议和UDP协议的比较</h1><ul>
<li>TCP和UDP是TCP&#x2F;IP协议栈中传输层的两个协议，它们使用IP路由功能把数据包发送到目的地，从而为应用程序及应用层协议（包括：HTTP、SMTP、SNMP、FTP和Telnet）提供网络服务。</li>
<li>TCP的server和client之间通信就好比两个人打电话，需要互相知道对方的电话号码，然后开始对话。所以在两者的连接过程中间需要指定端口和地址。</li>
<li>UDP的server和client之间的通信就像两个人互相发信。我只需要知道对方的地址，然后就发信过去。对方是否收到我不知道，也不需要专门对口令似的来建立连接</li>
<li>具体区别如下：<ul>
<li>TCP是面向连接的传输。UDP是无连接的传输</li>
<li>TCP有流量控制、拥塞控制，检验数据数据按序到达，而UDP则相反。</li>
<li>TCP的路由选择只发生在建立连接的时候，而UDP的每个报文都要进行路由选择</li>
<li>TCP是可靠性传输，他的可靠性是由超时重发机制实现的，而UDP则是不可靠传输</li>
<li>UDP因为少了很多控制信息，所以传输速度比TCP速度快</li>
<li>TCP适合用于传输大量数据，UDP适合用于传输小量数据</li>
</ul>
</li>
</ul>
<h1 id="IP-TCP-UDP-HTTP-TCP-IP-Socket"><a href="#IP-TCP-UDP-HTTP-TCP-IP-Socket" class="headerlink" title="IP,TCP,UDP,HTTP,TCP&#x2F;IP,Socket"></a>IP,TCP,UDP,HTTP,TCP&#x2F;IP,Socket</h1><ul>
<li>IP 协议，为计算机网络相互连接进行通信而设计的协议。</li>
<li>TCP&#x2F;UDP 协议，基于二进制流的控制间传输协议。 TCP 是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但 TCP 的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性；而 UDP 不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说 UDP 是无连接的、不可靠的一种数据传输协议。</li>
<li>HTTP 协议，超文本传送协议(Hypertext Transfer Protocol )，HTTP 协议是建立在</li>
<li>TCP 协议之上的一种应用。</li>
<li>IP 协议对应于网络层，TCP 协议对应于传输层，而 HTTP 协议对应于应用层。注意</li>
<li>TPC&#x2F;IP 位于传输层，它主要用来解决数据如何在网络中传输，与 IP 协议要区分开。</li>
<li>IP 协议规定网络之间互连的协议；TPC&#x2F;IP 协议是传输层协议，主要解决数据如何在网络中传输；HTTP 是应用层协议，主要用于包装数据。</li>
<li>Socket 相当于调用接口(API)，用来调取 TCP&#x2F;IP 协议。</li>
</ul>
<h1 id="先来一个讲-TCP、UDP-和-HTTP-关系的"><a href="#先来一个讲-TCP、UDP-和-HTTP-关系的" class="headerlink" title="先来一个讲 TCP、UDP 和 HTTP 关系的"></a>先来一个讲 TCP、UDP 和 HTTP 关系的</h1><ul>
<li>TCP&#x2F;IP 是个协议组，可分为三个层次：网络层、传输层和应用层。</li>
<li>在网络层有 IP 协议、ICMP 协议、ARP 协议、RARP 协议和 BOOTP 协议。</li>
<li>在传输层中有 TCP 协议与 UDP 协议。</li>
<li>在应用层有 FTP、HTTP、TELNET、SMTP、DNS 等协议。</li>
<li>因此，HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。</li>
<li>HTTP 协议是建立在请求&#x2F;响应模型上的。首先由客户建立一条与服务器的 TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME 样式的消息。服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的 MIME 式样的消息。</li>
<li>HTTP&#x2F;1.0 为每一次 HTTP 的请求&#x2F;响应建立一条新的 TCP 链接，因此一个包含 HTML内容和图片的页面将需要建立多次的短期的 TCP 链接。一次 TCP 链接的建立将需要 3次握手。</li>
<li>另外，为了获得适当的传输速度，则需要 TCP 花费额外的回路链接时间（RTT）。每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，因此 HTTP&#x2F;1.1 提出了可持续链接的实现方法。HTTP&#x2F;1.1 将只建立一次 TCP的链接而重复地使用它传输一系列的请求&#x2F;响应消息，因此减少了链接建立的次数和经常性的链接开销。</li>
<li>结论：虽然 HTTP 本身是一个协议，但其最终还是基于 TCP 的。不过，目前，有人正在研究基于 TCP+UDP 混合的 HTTP 协议。</li>
</ul>
<h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><ul>
<li>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</li>
<li>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>tcp</tag>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>版本管理工具</title>
    <url>/publishes/aa3500b67dae.html</url>
    <content><![CDATA[<h1 id="svn和git的区别及适用场景"><a href="#svn和git的区别及适用场景" class="headerlink" title="svn和git的区别及适用场景"></a>svn和git的区别及适用场景</h1><h4 id="svn的优势"><a href="#svn的优势" class="headerlink" title="svn的优势"></a>svn的优势</h4><ul>
<li>优异的跨平台支持，对windows平台支持非常友好。</li>
<li>简单易用，安装后稍微培训下就知道怎么操作。</li>
<li>代码，需求，文档，涉及稿都可以用svn进行管理，适合不同部门的技术非技术的同事协作。</li>
</ul>
<h4 id="git的优势"><a href="#git的优势" class="headerlink" title="git的优势"></a>git的优势</h4><ul>
<li>去中心化：Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容是完全一样的（格式有点不同，是bare的）。虽然平时大家都是将代码提交到中央服务器上再统一pull别人的代码，但实际情况你可以总是pull张三的库，然后push给李四等等操作。</li>
<li>本地提交：本地提交好处主要有3点：<ul>
<li>一， 断网提交 </li>
<li>二， 小步提交。可以对自己的阶段成果有跟踪，并且提高每次变更的安全性</li>
<li>三，本地库。这个和断网提交是同一个实现，但从需求角度出发则略有不同，主要是说即使只有自己一个人开发项目，也可以轻易的让自己的代码有版本跟踪，而不需要去费力建个什么svn server。</li>
<li>四，本地回滚。这个其实是由于本地库的存在而产生的，但可以减少中央库上的冗余版本</li>
</ul>
</li>
<li>分支策略：在Git实际开发中分支的分离和merge是属于日常操作，开启和合并分支成本相比SVN要小得多：SVN是复制一份代码到分支目录，Git则是在分支点做一下标记。随便一次冲突就会自动产生分支，所以大家每天都在与分支打交道。这便是弱化了分支的概念，由于分支成本很小，因此使得按功能分支的开发模式（每个分支一个功能，开发完了再merge到主干）变得非常简单，大家可以完全不需要再因为担心SCM成本太高而选用主干开发模式（所有功能都在主干上开发，到了发版本前再分离出分支）。</li>
</ul>
<h4 id="两者的工作流对比"><a href="#两者的工作流对比" class="headerlink" title="两者的工作流对比"></a>两者的工作流对比</h4><h5 id="svn模式"><a href="#svn模式" class="headerlink" title="svn模式"></a>svn模式</h5><ul>
<li>写代码。</li>
<li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li>
<li>将本地代码提交到服务器。</li>
</ul>
<h5 id="git模式"><a href="#git模式" class="headerlink" title="git模式"></a>git模式</h5><ul>
<li>写代码。</li>
<li>提交到本地版本库。</li>
<li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li>
<li>将远程库与本地代码合并结果提交到本地版本库。</li>
<li>将本地版本库推到服务器。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>对比可以看出：分布式版本管理仅仅是增加了本地库这个概念，其余的概念与集中管理并无区别。——但是 svn 在与服务器同步之前无法提交代码，因而本地修改更容易出问题。</li>
<li>当研发成本比较低，协作开发人数不多，开发人员对于版本管理的水平参差不齐的时候，或者对于代码的安全性要求更高一点的时候，适合用svn。</li>
<li>而对于很多人参与开发，代码量比较大，或者高频次协作，跨公司，跨地域合作的情况下，更适合用git。</li>
</ul>
]]></content>
      <categories>
        <category>版本管理工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/publishes/4f75e46c0d1c.html</url>
    <content><![CDATA[<h1 id="⼯⼚⽅法模式"><a href="#⼯⼚⽅法模式" class="headerlink" title="⼯⼚⽅法模式"></a>⼯⼚⽅法模式</h1><ul>
<li>利⽤创建同⼀接⼝的不同实例</li>
</ul>
<h4 id="普通⼯⼚模式"><a href="#普通⼯⼚模式" class="headerlink" title="普通⼯⼚模式"></a>普通⼯⼚模式</h4><ul>
<li>建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SendFactory &#123;</span><br><span class="line">    public Sender produce(String type) &#123;</span><br><span class="line">        if (&quot;mail&quot;.equals(type)) &#123;</span><br><span class="line">            return new MailSender();</span><br><span class="line">        &#125; else if (&quot;sms&quot;.equals(type)) &#123;</span><br><span class="line">            return new SmsSender();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;请输⼊正确的类型!&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多个⼯⼚⽅法模式"><a href="#多个⼯⼚⽅法模式" class="headerlink" title="多个⼯⼚⽅法模式"></a>多个⼯⼚⽅法模式</h4><ul>
<li>提供多个⼯⼚⽅法，分别创建对象；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SendFactory &#123;</span><br><span class="line">    public Sender produceMail()&#123;</span><br><span class="line">        return new MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">    public Sender produceSms()&#123;</span><br><span class="line">        return new SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态⼯⼚⽅法模式"><a href="#静态⼯⼚⽅法模式" class="headerlink" title="静态⼯⼚⽅法模式"></a>静态⼯⼚⽅法模式</h4><ul>
<li>将上⾯的多个⼯⼚⽅法置为静态的，不需要创建⼯⼚实例，直接调⽤即可；</li>
</ul>
<h4 id="适⽤场景"><a href="#适⽤场景" class="headerlink" title="适⽤场景"></a>适⽤场景</h4><ul>
<li>凡是出现了⼤量不同种类的产品需要创建，并且具有共同的接⼝时，可以通过⼯⼚⽅法模式进⾏创建</li>
<li>在以上的三种模式中，第⼀种如果传⼊的字符串有误，不能正确创建对象，第三种相对于第⼆种，不需要实例化⼯⼚类，所以，⼤多数情况下，我们会选⽤第三种——静态⼯⼚⽅法模式。</li>
</ul>
<h1 id="抽象⼯⼚模式"><a href="#抽象⼯⼚模式" class="headerlink" title="抽象⼯⼚模式"></a>抽象⼯⼚模式</h1><ul>
<li>多个⼯⼚</li>
<li>创建多个⼯⼚类，提⾼⼯⼚的扩展性，不⽤像上⾯⼀样如果增加产品则要去修改唯⼀的⼯⼚类；</li>
</ul>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul>
<li>保证对象只有⼀个实例</li>
<li>保证在⼀个 JVM 中，该对象只有⼀个实例存在；</li>
</ul>
<h4 id="适⽤场景："><a href="#适⽤场景：" class="headerlink" title="适⽤场景："></a>适⽤场景：</h4><ul>
<li>某些类创建⽐较频繁，对于⼀些⼤型的对象，这是⼀笔很⼤的系统开销。</li>
<li>省去了 new 操作符，降低了系统内存的使⽤频率，减轻 GC 压⼒。</li>
<li>有些类如交易所的核⼼交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。所以只有使⽤单例模式，才能保证核⼼交易服务器独⽴控制整个流程。</li>
</ul>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul>
<li>类初始化时创建单例，线程安全，适⽤于单例占内存⼩的场景，否则推荐使⽤懒汉式延迟加载；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton newInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul>
<li>需要创建单例实例的时候再创建，需要考虑线程安全(性能不太好)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static synchronized Singleton newInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h4><ul>
<li>效率⾼</li>
<li>解决问题：假如两个线程 A、B，A 执⾏了 if (instance &#x3D;&#x3D; null)语句，它会认为单例对象没有创建，此时线程切到 B 也执⾏了同样的语句，B 也认为单例对象没有创建，然后两个线程依次执⾏同步代码块，并分别创建了⼀个单例对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance = null;//volatile 的⼀个语义是禁⽌指令重排序优化</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;//2</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态内部类⽅式"><a href="#静态内部类⽅式" class="headerlink" title="静态内部类⽅式"></a>静态内部类⽅式</h4><ul>
<li>可以同时保证延迟加载和线程安全<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        public static Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton newInstance()&#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ul>
<li>使⽤枚举除了线程安全和防⽌反射调⽤构造器之外，还提供了⾃动序列化机制，防⽌反序列化的时候创建新的对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    instance;</span><br><span class="line">    public void whateverMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><ul>
<li>将⼀个对象作为原型，对其进⾏复制、克隆，产⽣⼀个和元对象类似的新对象；</li>
<li>核⼼：它的核⼼是原型类 Prototype，需要实现 Cloneable 接⼝，和重写 Object 类中的 clone ⽅法；</li>
<li>作⽤：使⽤原型模式创建对象⽐直接 new ⼀个对象在性能上要好的多，因为 Object 类的 clone ⽅法是⼀个本地⽅法，它直接操作内存<br>中的⼆进制流，特别是复制⼤对象时，性能的差别⾮常明显。</li>
</ul>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><ul>
<li>接⼝兼容</li>
<li>将某个类的接⼝转换成客户端期望的另⼀个接⼝表示，⽬的是消除由于接⼝不匹配所造成的类的兼容性问题。</li>
<li>类的适配器模式</li>
<li>对象的适配器模式</li>
<li>接⼝的适配器模式</li>
</ul>
<h4 id="使⽤场景"><a href="#使⽤场景" class="headerlink" title="使⽤场景"></a>使⽤场景</h4><ul>
<li>类的适配器模式：当希望将⼀个类转换成满⾜另⼀个新接⼝的类时，可以使⽤类的适配器模式，创建⼀个新类，继承原有的类，<br>实现新的接⼝即可。</li>
<li>对象的适配器模式：当希望将⼀个对象转换成满⾜另⼀个新接⼝的对象时，可以创建⼀个 Wrapper 类，持有原类的⼀个实例，在<br>Wrapper 类的⽅法中，调⽤实例的⽅法就⾏。</li>
<li>接⼝的适配器模式：当不希望实现⼀个接⼝中所有的⽅法时，可以创建⼀个抽象类 Wrapper，实现所有⽅法，我们写别的类的时<br>候，继承抽象类即可。</li>
</ul>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><ul>
<li>装饰模式就是给⼀个对象增加⼀些新的功能，⽽且是动态的，要求装饰对象和被装饰对象实现同⼀个接⼝，装饰对象持有被装饰对象的实例：</li>
</ul>
<h4 id="使⽤场景："><a href="#使⽤场景：" class="headerlink" title="使⽤场景："></a>使⽤场景：</h4><ul>
<li>需要扩展⼀个类的功能</li>
<li>动态的为⼀个对象增加功能，⽽且还能动态撤销。（继承不能做到这⼀点，继承的功能是静态的，不能动态增删。）</li>
</ul>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><ul>
<li>持有被代理类的实例，进⾏操作前后控制</li>
<li>采⽤⼀个代理类调⽤原有的⽅法，且对产⽣的结果进⾏控制。</li>
</ul>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><ul>
<li>集合所有操作到⼀个类</li>
<li>外观模式是为了解决类与类之间的依赖关系的，像 spring ⼀样，可以将类和类之间的关系配置到配置⽂件中</li>
<li>⽽外观模式就是将他们的关系放在⼀个 Facade 类中，降低了类类之间的耦合度。</li>
</ul>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><ul>
<li>数据库驱动桥接</li>
<li>桥接模式就是把事物和其具体实现分开，使他们可以各⾃独⽴的变化</li>
<li>桥接的⽤意是：将抽象化与实现化解耦，使得⼆者可以独⽴变化，像我们常⽤的 JDBC 桥 DriverManager ⼀样，JDBC 进⾏连接数据库的时候，在各个数据库之间进⾏切换，基本不需要动太多的代码，甚⾄丝毫不⽤动，原因就是 JDBC 提供统⼀接⼝，每个数据库提供各⾃的实现，⽤⼀个叫做数据库驱动的程序来桥接就⾏了。</li>
</ul>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><ul>
<li>部分整体模式</li>
<li>组合模式有时⼜叫部分-整体模式在处理类似树形结构的问题时⽐较⽅便。</li>
</ul>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><ul>
<li>共享池、数据库连接池</li>
<li>享元模式的主要⽬的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与⼯⼚模式⼀起使⽤</li>
<li>当⼀个客户端请求时，⼯⼚需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建⼀个新对象，如数据库连接池；</li>
</ul>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><ul>
<li>多种算法封装</li>
<li>策略模式定义了⼀系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使⽤算法的客户</li>
<li>需要设计⼀个接⼝，为⼀系列实现类提供统⼀的⽅法，多个实现类实现该接⼝：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ICalculator cal = new Plus(); //ICalculator 是统⼀接⼝，Plus 是实现类(多个)</span><br><span class="line">int result = cal.calculate(exp); //jvm 根据实现类不同⽽调⽤不同实现类的⽅法</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="模板⽅法模式"><a href="#模板⽅法模式" class="headerlink" title="模板⽅法模式"></a>模板⽅法模式</h1><ul>
<li>抽象⽅法作为⻣架，具体逻辑让⼦类实现</li>
<li>定义⼀个操作中算法的框架，⽽将⼀些步骤延迟到⼦类中，使得⼦类可以不改变算法的结构即可重定义该算法中的某些特定步骤</li>
<li>完成公共动作和特殊动作的分离。</li>
</ul>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><ul>
<li>发布-订阅模式</li>
<li>当⼀个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是⼀种⼀对多的关系</li>
<li>类似于邮件订阅和 RSS 订阅，当你订阅了该⽂章，如果后续有更新，会及时通知你。</li>
</ul>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><ul>
<li>遍历集合</li>
<li>迭代器模式就是顺序访问聚集中的对象</li>
</ul>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><ul>
<li>多任务形成⼀条链，请求在链上传递</li>
<li>有多个对象，每个对象持有对下⼀个对象的引⽤，这样就会形成⼀条链，请求在这条链上传递，直到某⼀对象决定处理该请求</li>
<li>但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进⾏动态的调整。</li>
</ul>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><ul>
<li>实现请求和执⾏的解耦</li>
<li>命令模式的⽬的就是达到命令的发出者和执⾏者之间解耦，实现请求和执⾏分开，熟悉 Struts 的同学应该知道，Struts 其实就是⼀种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</li>
</ul>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><ul>
<li>保存和恢复对象状态</li>
<li>主要⽬的是保存⼀个对象的某个状态，以便在适当的时候恢复对象</li>
</ul>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><ul>
<li>对象状态改变时改变其⾏为</li>
<li>当对象的状态改变时，同时改变其⾏为</li>
<li>状态模式就两点<ul>
<li>可以通过改变状态来获得不同的⾏为</li>
<li>你的好友能同时看到你的变化</li>
</ul>
</li>
</ul>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><ul>
<li>数据接⼝稳定，但算法易变</li>
<li>访问者模式把数据结构和作⽤于结构上的操作解耦合，使得操作集合可相对⾃由地演化</li>
<li>访问者模式适⽤于数据结构相对稳定算法⼜易变化的系统</li>
<li>因为访问者模式使得算法操作增加变得容易</li>
<li>访问者模式就是⼀种分离对象数据结构与⾏为的⽅法，通过这种分离，可达到为⼀个被访问者动态添加新的操作⽽⽆需做其它的修改的效果</li>
</ul>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><ul>
<li>中介者模式也是⽤来降低类类之间的耦合的</li>
<li>如果使⽤中介者模式，只需关⼼和 Mediator 类的关系</li>
<li>具体类类之间的关系及调度交给 Mediator 就⾏，这有点像 spring 容器的作⽤。</li>
</ul>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><ul>
<li>对于⼀些固定⽂法构建⼀个解释句⼦的解释器，如正则表达式</li>
<li>解释器模式⽤来做各种各样的解释器，如正则表达式等的解释器。</li>
</ul>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><ul>
<li>创建复合对象</li>
<li>⼯⼚类模式提供的是创建单个类的模式，⽽建造者模式则是将各种产品集中起来进⾏管理，⽤来创建复合对象，所谓复合对象就是指某个类具有不同的属性</li>
</ul>
<h1 id="设计模式的六⼤原则："><a href="#设计模式的六⼤原则：" class="headerlink" title="设计模式的六⼤原则："></a>设计模式的六⼤原则：</h1><h4 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h4><ul>
<li>开闭原则就是说对扩展开放，对修改关闭</li>
<li>在程序需要进⾏拓展的时候，不能去修改原有的代码，实现⼀个热插拔的效果。</li>
<li>所以⼀句话概括就是：为了使程序的扩展性好，易于维护和升级</li>
<li>想要达到这样的效果，我们需要使⽤接⼝和抽象类，后⾯的具体设计中我们会提到这点。</li>
</ul>
<h4 id="⾥⽒代换原则（Liskov-Substitution-Principle-LSP）"><a href="#⾥⽒代换原则（Liskov-Substitution-Principle-LSP）" class="headerlink" title="⾥⽒代换原则（Liskov Substitution Principle LSP）"></a>⾥⽒代换原则（Liskov Substitution Principle LSP）</h4><ul>
<li>⾥⽒代换原则⾯向对象设计的基本原则之⼀</li>
<li>⾥⽒代换原则中说，任何基类可以出现的地⽅，⼦类⼀定可以出现</li>
<li>LSP 是继承复⽤的基⽯，只有当衍⽣类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复⽤，⽽衍⽣类也能够在基类的基础上增加新的⾏为</li>
<li>⾥⽒代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化</li>
<li>⽽基类与⼦类的继承关系就是抽象化的具体实现，所以⾥⽒代换原则是对实现抽象化的具体步骤的规范</li>
</ul>
<h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul>
<li>这个是开闭原则的基础，具体内容：真对接⼝编程，依赖于抽象⽽不依赖于具体。</li>
</ul>
<h4 id="接⼝隔离原则（Interface-Segregation-Principle）"><a href="#接⼝隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接⼝隔离原则（Interface Segregation Principle）"></a>接⼝隔离原则（Interface Segregation Principle）</h4><ul>
<li>使⽤多个隔离的接⼝，⽐使⽤单个接⼝要好</li>
<li>还是⼀个降低类之间的耦合度的意思</li>
<li>从这⼉我们看出，其实设计模式就是⼀个软件的设计思想，从⼤型软件架构出发，为了升级和维护⽅便</li>
<li>所以上⽂中多次出现：降低依赖，降低耦合。</li>
</ul>
<h4 id="迪⽶特法则（最少知道原则）（Demeter-Principle）"><a href="#迪⽶特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪⽶特法则（最少知道原则）（Demeter Principle）"></a>迪⽶特法则（最少知道原则）（Demeter Principle）</h4><ul>
<li>为什么叫最少知道原则，就是说：⼀个实体应当尽量少的与其他实体之间发⽣相互作⽤，使得系统功能模块相对独⽴。</li>
</ul>
<h4 id="合成复⽤原则（Composite-Reuse-Principle）"><a href="#合成复⽤原则（Composite-Reuse-Principle）" class="headerlink" title="合成复⽤原则（Composite Reuse Principle）"></a>合成复⽤原则（Composite Reuse Principle）</h4><ul>
<li>原则是尽量使⽤合成&#x2F;聚合的⽅式，⽽不是使⽤继承</li>
</ul>
<h1 id="jdk-中的设计模式"><a href="#jdk-中的设计模式" class="headerlink" title="jdk 中的设计模式"></a>jdk 中的设计模式</h1><h4 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h4><ul>
<li>java.lang.Runtime#getRuntime()</li>
<li>java.awt.Desktop#getDesktop()</li>
<li>java.lang.System#getSecurityManager()</li>
</ul>
<h4 id="责任链模式-1"><a href="#责任链模式-1" class="headerlink" title="责任链模式"></a>责任链模式</h4><ul>
<li>java.util.logging.Logger#log()</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
<h4 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h4><ul>
<li>java.util.Observer&#x2F; java.util.Observable（很少在现实世界中使⽤）</li>
<li>所有实现 java.util.EventListener（因此实际上各地的 Swing）</li>
<li>javax.servlet.http.HttpSessionBindingListener</li>
<li>javax.servlet.http.HttpSessionAttributeListener</li>
<li>javax.faces.event.PhaseListener</li>
</ul>
<h1 id="spring-中的设计模式："><a href="#spring-中的设计模式：" class="headerlink" title="spring 中的设计模式："></a>spring 中的设计模式：</h1><h4 id="简单⼯⼚"><a href="#简单⼯⼚" class="headerlink" title="简单⼯⼚"></a>简单⼯⼚</h4><ul>
<li>spring 中的 BeanFactory 就是简单⼯⼚模式的体现，根据传⼊⼀个唯⼀的标识来获得 bean 对象，但是否是在传⼊   参数后创建还是传⼊参数前创建这个要根据具体情况来定。</li>
<li>单例模式：Spring 下默认的 bean 均为 singleton。</li>
<li>代理模式：为其他对象提供⼀种代理以控制对这个对象的访问。 从结构上来看和 Decorator 模式类似，但 Proxy 是控制，更像   是⼀种对功能的限制，⽽ Decorator 是增加职责。 spring 的 Proxy 模式在 aop 中有体现，⽐如 JdkDynamicAopProxy 和 Cglib2AopProxy。</li>
<li>观察者模式：定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发⽣改变时，所有依赖于它的对象都得到通知并被⾃动更新。spring 中 Observer 模式常⽤的地⽅是 listener 的实现。如 ApplicationListener。</li>
</ul>
<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><ul>
<li>设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法</li>
<li>设计模式是代码可用性的延伸</li>
</ul>
<h1 id="使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="使用工厂模式最主要的好处是什么？在哪里使用？"></a>使用工厂模式最主要的好处是什么？在哪里使用？</h1><ul>
<li>工厂模式的最大好处是增加了创建对象时的封装层次</li>
<li>如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。</li>
</ul>
<h1 id="举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？"><a href="#举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？" class="headerlink" title="举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？"></a>举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</h1><ul>
<li>装饰模式增加强了单个对象的能力</li>
<li>Java IO 到处都使用了装饰模式，典型例子就是 Buffered 系列类如 BufferedReader 和 BufferedWriter，它们增强了 Reader 和 Writer 对象，以实现提升性能的 Buffer 层次的读取和写入。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/publishes/7fec0b877c88.html</url>
    <content><![CDATA[<h1 id="JSON及其作用"><a href="#JSON及其作用" class="headerlink" title="JSON及其作用"></a>JSON及其作用</h1><ul>
<li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式</li>
<li>JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据不须要任何特殊的 API 或工具包</li>
<li>在JSON中，有两种结构：对象和数组</li>
<li>对象<ul>
<li>一个对象以“{”（左括号）开始，“}”（右括号）结束</li>
<li>每个“名称”后跟一个“:”（冒号）；“‘名称&#x2F;值’ 对”之间运用 “,”（逗号）分隔</li>
<li>名称用引号括起来；值如果是字符串则必须用括号，数值型则不须要</li>
<li>例如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;<span class="string">&quot;xlid&quot;</span>:<span class="string">&quot;cxh&quot;</span>,<span class="string">&quot;xldigitid&quot;</span>:<span class="number">123456</span>,<span class="string">&quot;topscore&quot;</span>:<span class="number">2000</span>,<span class="string">&quot;topplaytime&quot;</span>:<span class="string">&quot;2009-08-20&quot;</span>&#125;；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数组<ul>
<li>数组是值（value）的有序集合</li>
<li>一个数组以“[”（左中括号）开始，“]”（右中括号）结束</li>
<li>值之间运用 “,”（逗号）分隔</li>
<li>例如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonranklist=[&#123;<span class="string">&quot;xlid&quot;</span>:<span class="string">&quot;cxh&quot;</span>,<span class="string">&quot;xldigitid&quot;</span>:<span class="number">123456</span>,<span class="string">&quot;topscore&quot;</span>:<span class="number">2000</span>,<span class="string">&quot;topplaytime&quot;</span>:<span class="string">&quot;2009-08-20&quot;</span>&#125;,&#123;<span class="string">&quot;xlid&quot;</span>:<span class="string">&quot;zd&quot;</span>,<span class="string">&quot;xldigitid&quot;</span>:<span class="number">123456</span>,<span class="string">&quot;topscore&quot;</span>:<span class="number">1500</span>,<span class="string">&quot;topplaytime&quot;</span>:<span class="string">&quot;2009-11-20&quot;</span>&#125;];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>序列化</category>
      </categories>
      <tags>
        <tag>JSON</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>面试技巧</title>
    <url>/publishes/64b56da2b088.html</url>
    <content><![CDATA[<h1 id="IT从业人员面试技巧"><a href="#IT从业人员面试技巧" class="headerlink" title="IT从业人员面试技巧"></a>IT从业人员面试技巧</h1><ul>
<li>一般来说，面试你的人都不是一个很好对付的人。别看他彬彬有礼，看上去笑眯眯的，很和气的样子。但没准儿一肚子坏水。有些人待人特别客气，说话还稍稍有点结巴的，更容易让人上当。所以，牢记一点，面试的时候保持高度警觉，对方不经意问出来的问题，很可能是他最想知道的。举例来说，我每次面试的时候，最喜欢说的话就是：哦，我不是HR的，你别拘束，咱们就当是聊天……</li>
<li>负责面试的人，一般有两种，一种是专门的人力资源部门。我不懂这一块，略过不谈。另外一种就是我这样的，负责某个部门的苦力头。一般来说，公司中层的苦力头，他的脑子里面都有一个模式，他的码头上需要一个什么样的人，他或她必须具备哪些技能。但这些考察都是次要的，他首先要搞清楚一点，那就是对方的人品!!!换句话说，能力是一个方面，但人品是门槛!!!如果他判定你人品有问题，那剩下的问题就没必要了。这里面就有很多陷阱，比如，你怎么评价前一家公司。你要是大说特说那公司怎么不好，我肯定要琢磨了，你昨天背叛少林，那今天会不会背叛武当?最好把离职原因淡淡一说，不要指责谁。我找工作的时候，一般都老实说，我自己能力不行，被公司淘汰了。其实大家肚子都揣着明白，不就是为了找个钱多点的地儿嘛。我经常问的一个陷阱问题就是：谈谈你的父母。其实这个问题一方面是考察对方的家庭教育，另外一方面是看看面试者怎么评价父母。这里面有个通常的逻辑，爹妈把他养这么大，说到自己的父母毫无感恩，感激之情，这种人招进来肯定不能成为合格的苦力。</li>
<li>总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li>
</ul>
<h4 id="面试到结束的时候，都会问到薪金标准。"><a href="#面试到结束的时候，都会问到薪金标准。" class="headerlink" title="面试到结束的时候，都会问到薪金标准。"></a>面试到结束的时候，都会问到薪金标准。</h4><ul>
<li>我不知道别的公司怎么操作的。我呆过的公司，都是定编定岗的，换句话说，招聘的时候，这个岗位的薪水是早就确定了。也就是说，对方问到薪金的时候，他已经在脑子里面很清楚公司的标准!!!一般说来，这个问题的目的是为了确定，他如果觉得你是个合适的苦力，那么，现在的薪金，你是不是会过来干活。问到薪金的时候，最好的回答是不回答，留到下一次面试再谈。或者可以反问，公司对于这个岗位定的薪金标准是多少。</li>
<li>一般来说，苦力头不会管你薪金多少的。好的苦力，苦力头甚至会为你向老板争取。</li>
<li>能够混到苦力头的位置上，面试你的人至少具有一定的能力，以及足够的胸怀。他在意的是能不能招到合适的人干活，薪金的问题不是问题。但过高的薪金，会把你抹掉。比如这个岗位，公司定的薪水是三千，你一张嘴，四千，那完了。对于应聘者，其实是很不公平的，你能做的就是接受这个标准或是不接受。如果是刚刚走出校门，月薪三千我想足够生活了。所以，如果对方的薪金标准，你要么不回答，要么就说三千，别要的太高。</li>
</ul>
<h4 id="一般面试都是在一个独立的私密空间进行。"><a href="#一般面试都是在一个独立的私密空间进行。" class="headerlink" title="一般面试都是在一个独立的私密空间进行。"></a>一般面试都是在一个独立的私密空间进行。</h4><ul>
<li>这里简单说说一些基本的礼貌。</li>
<li>进门要敲门，敲门是最基本的一点。</li>
<li>第二点，落座，别进去一屁股就坐上去了。最好等对方先坐下。当然，一般面试的人都很客气，招呼：坐，坐。</li>
<li>有时候进去之后，面试的人已经坐好了，那就别管了，坐在他的对面或他指定的位置就行。我这人比较心理阴暗，一般都是背对亮光坐。</li>
<li>当你结束时，至少客气招呼一声：谢谢您抽出时间面试我。</li>
<li>如果离开座位，顺手把椅子推好，这也是一个容易疏忽的地方。 </li>
<li>有些公司的前台小姑娘，是你去面试的时候最先面对的，那么临走的时候客气打声招呼。</li>
<li>我有个习惯，面试的时候带着名片，如果我觉得很合适，会把名片给对方，这样他便于有问题的话联络我。但是，亲爱的朋友，你去面试的时候，如果对方面前放着名片夹子，千万不要傻了吧叽的要名片。</li>
<li>面试结束的第二天，如果你有面试你的苦力头电话，那就发个短信，内容可以客套一下，就说感谢你昨天面试我之类的话，然后祝福一下，比如今天好心情，工作顺利等等。千万不要问对方结果。你的目的就是提醒他，显示你的存在就行了。</li>
<li>你等待的地方，可能是公司的公共区域，而面试的地方可能是会议室，或者像我这样的人，喜欢在自己的办公室谈。那么切忌，不要走在前面，也不要走路中间，走在边上就行，把中间的位置留给你未来的领导走。进门之前主动为对方开门，这种拍马屁的小花招可以多来一点。</li>
<li>面试的时候身体正直，自然一点就行。一般来说，不要用摩丝喷的脑袋跟刺猬一样。女孩子也不要用过于浓密的香水。这是谈事情，不是相亲。</li>
<li>谈话的过程中，不要抢话，语速也不要太快。我教大家一个小诀窍，我一般和人谈事情，一开始故意显得有点结巴。人说话结巴，会让人感觉对方很诚恳。但就开头一两句结巴就行，别一直结巴。</li>
<li>有些人面试的时候介绍自己会滔滔不绝，说话特快。其实这里面有个信息传递的问题，跟别人谈事情，语速太快，往往容易说错。对方接受起来也有问题。中等语速就可以了。</li>
<li>很多男士比较大大咧咧，往那儿一坐，二郎腿就搭上了。要是碰上我这样大大咧咧的，可能无所谓，要是碰到心理阴暗的，就会有负面影响。另外，很多人一紧张就爱抖腿，这样也不礼貌。面试其实就是一个自我介绍，不是演说，不要声音特大吐沫横飞的，平时说话的声音就行。</li>
<li>面试你的要是个女的那就算了，要是个男的，不用管自己的性别，大大方方招呼一声，你好，手伸过去，和他握个手。其实从握手就能看到一个人的个性，一般来说，握手短促有力，可能是我这样比较外向的性格。握的软绵绵的，对方可能比较内向。</li>
<li>不要紧张，表现得自然些，要有礼貌，别忘记和主考人招呼，说句”早晨好”。</li>
<li>举止要大方，不可闪缩，要保持自信。待主考人邀请你才可礼貌地坐下，不要太随便或左顾右盼;切忌装出懒洋洋和满不在乎的样子。</li>
<li>微笑可以减轻你内心的不安，更可以令面试的气氛变得融洽愉快。</li>
<li>让主考人知道你珍惜这次面试的机会。当主考人说话时，要眼望对方，并留心倾听。</li>
<li>让主考人先打开话匣子。答问题要直接了当，无须太繁复，也不要单说”是”或”不是”;否则，主考人会觉得你欠缺诚意。深入的谈话内容有助主考人对你作出确切的评估。</li>
<li>假如不太明白主考人的问题，应该礼貌地请他重复。不懂得回答的问题，不妨坦白承认。含糊其辞或乱吹牛会导至面试的失败。</li>
<li>不要打断主考人的说话，被要求就相同的问题重复作答也不能表示不耐烦，更切忌与主考人争辩。</li>
<li>主考人可能问你一些与面试或者申请的职位完全无关的问题，例如时人时事;目的在进一步了解你的思想及见识。</li>
<li>紧记在适当时机带出自已的优点和特长。但切勿显得过份自信或浮夸。</li>
<li>不要急着提出薪酬问题，最好让主考人先提出。</li>
<li>准备一些与该机构和申请的工作有关的问题在面试结束之前提出。这样能表现伙的积极，亦可给主考人留下良好印象。</li>
<li>最后，问清楚多久才知道面试结果。不要忘记向主考人道谢及说声”再见”才离去。</li>
</ul>
<h1 id="面试一家公司之前需要做的准备"><a href="#面试一家公司之前需要做的准备" class="headerlink" title="面试一家公司之前需要做的准备"></a>面试一家公司之前需要做的准备</h1><h4 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h4><ul>
<li>了解应聘公司；</li>
<li>了解应聘岗位</li>
<li>查该公司的资料，知道该公司是做什么的，发展情况，招聘的岗位的要求等</li>
<li>公司地点在哪里，交通是否方便，需提前多久出发；</li>
<li>公司类型如何？我应该如何着装？去咨询公司逃不掉正装，而去互联网公司这么穿，人家或许以为你是房产中介；</li>
<li>公司业务如何？上市了吗？财报如何？主要产品有哪些？</li>
<li>公司在中国有多少分支机构？最近有什么新动向？</li>
<li>公司所在行业有何新动向？发展趋势如何？</li>
<li>公司的竞争对手有哪些？公司在行业内排名如何？</li>
</ul>
<h4 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h4><ul>
<li>重温一下简历内容，确保每段经历都能用简短的语言复述；</li>
<li>带过的团队，做过的项目，组织过的活动，以STAR的形式准备好；</li>
<li>每一段经历，都应该准备实例和数据证明，会给面试官留下深刻印象；</li>
<li>准备几个感兴趣的问题，面试中如果没有获得解答，在电话通知环节，我们必须开口问，有诸多信息要确认：<ul>
<li>面试时间／地点</li>
<li>公司名称／岗位名称</li>
<li>联系人信息（一旦迟到，得提前打电话道歉）</li>
<li>面试官是谁（HR还是直线经理，或者都一次性面试掉）</li>
<li>需要准备什么材料（一般逃不掉学历证明，身份证复印件等资料）</li>
<li>针对面试岗位，需要额外准备什么材料（如：做设计，是不是要带设计稿？）</li>
</ul>
</li>
</ul>
<h1 id="人事面试技巧总结"><a href="#人事面试技巧总结" class="headerlink" title="人事面试技巧总结"></a>人事面试技巧总结</h1><ul>
<li>一定不要将公司的工作当作负担，一定要做好并且学到东西，这才是你下一次跳槽能够展示的东西，所以在公司工作，你拿着工资，而不只是在为公司打工，而是为自己的未来进行修炼，一定要有这方面的意识。总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li>
<li>人事这关也很重要，特别是工资方面，还有团队，工作方面？(重要)</li>
<li>对公司的主营业务要表现足够的兴趣，关系公司的发展？</li>
<li>3面就该和你谈谈钱的事情，你们的重点就是在于薪资，福利和以后的发展，这个时候就是公司对你展示他的潜力了，也是希望能留住你（招人也不容易），那么你对你自己的定位，和你的期望薪资就可以大胆的说出来， 不要因为不好意思而错过你要价的机会，因为一般进入公司后你想涨薪资就比较复杂了，而且这只是你的期望 ，面试官会对你提出他们会给你的工资， 也就是一个讨价还价的过程，总之在这个环节，你可以大胆提出你的期望薪资与发展方向（不要太离谱哈，当然你要作死我也不拦着你），和你的面试官慢慢讨论</li>
<li>试用期：在这个环节就是心态上注意，技术上展示你的能力，处事上和谐相处，重中之重是在于融入团队，你个人的力量是完不成整个项目的</li>
<li>对新公司的了解，公司发展情况，业务方向，特长等，如果在企业文化上也有优势，可以多夸下公司的的企业文化</li>
<li>期望的薪资，最好是了解了工作内容、加班情况、福利情况再谈待遇。最好先了解行情以免太高或太低。不要说太死了，看到对方表情不对就改口说可以商量，或者试探性的问一下对方能否接受，不行就说自己要高工资的原因并说明其实自己更看重发展机会，工资再少点也可以。不要轻易说自己能接受的最低工资，很可能他就给你这个最低的。如果对方能接受你的要求但是觉得有点偏高时，要说明自己凭什么可以拿这么高，并说明自己的优势对岗位的重要性。</li>
<li>要问公司的问题<ul>
<li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等。</li>
<li>所在部门的规模、发展计划，个人的成长机会。</li>
<li>自己的工作内容及可能的发展机会等。</li>
<li>向人事提问时最好不要一开始就谈工资，还有不要问太多可能留下不好印象的问题。问最基本的可能影响你去留的问题，其他问题可以进了再问，言多必失</li>
<li>面试前根据招聘信息的岗位要求多做相应准备</li>
</ul>
</li>
</ul>
<h4 id="你为什么来北京（城市）发展？"><a href="#你为什么来北京（城市）发展？" class="headerlink" title="你为什么来北京（城市）发展？"></a>你为什么来北京（城市）发展？</h4><ul>
<li>提出这个问题不要认为胡乱回答就行了，面试官是想看你什么原因，是否稳定。不会有哪家公司找一个很不稳定的人的。回答尽量夸城市，想在这里发展云云</li>
</ul>
<h4 id="你离职原因？"><a href="#你离职原因？" class="headerlink" title="你离职原因？"></a>你离职原因？</h4><ul>
<li>说到这个问题很多人都很头大，换工作的人清楚这个问题基本是必问的一个问题</li>
<li>这个问题很难回答，为什么呢？因为你如果说是公司的问题，这不好那不好，那么就很危险了，因为面试官会想，以后你从我们公司走出去是不是也这么说我们公司。说因为自己的原因呢，如果没好的理由，面试官也会想如果你来公司因为这些理由离开我公司呢，给人很不稳定的感觉</li>
<li>一般我会回答公司倒闭或者公司被收购、实习到期或者你本身确实有不得已的理由，比如公司发展和自己的发展不符合，等等，不要直接说公司或者自己的某些原因。除非没有好理由</li>
</ul>
<h4 id="为什么来我们公司？我们公司你了解多少？"><a href="#为什么来我们公司？我们公司你了解多少？" class="headerlink" title="为什么来我们公司？我们公司你了解多少？"></a>为什么来我们公司？我们公司你了解多少？</h4><ul>
<li>问这个就考察你的提前准备的资料了，既然这家公司通知你面试了，你肯定要去查相关资料，不需要详细的，但是你肯定要公司做什么的要知道</li>
<li>这个要考察自己巴拉巴拉的能力了，比如我觉得公司发展跟我想做的蛮符合的，我想珍惜这个机会…与公司同步发展云云</li>
</ul>
<h4 id="你认为你的优点和缺点有哪些？"><a href="#你认为你的优点和缺点有哪些？" class="headerlink" title="你认为你的优点和缺点有哪些？"></a>你认为你的优点和缺点有哪些？</h4><ul>
<li>不要认为这个问题很简单，吹吹牛就可以了。</li>
<li>首先你要清楚的知道，你的优点基本能在你工作中用到的，你的缺点千万不能出现在工作中。优点很好说，缺点就很难。优点比如，我工作认真踏实，团队意识强，学习能力强等等等，缺点你怎么说呢？好吃懒做，不思进取。这样回答基本就挂了。你必须自己的缺点和公司无关紧要的，经过面试经验，一般回答你自己生活上的，比如我花钱控制不了那么详细，就会引起对方的兴趣，那你干嘛了？你可以随便说了，我一般控制自己每月花一千，但是朋友聚会花了一千五。对金钱控制不好，这完全不影响你的工作。其他也可以自己想其他理由。</li>
</ul>
<h4 id="不知情况乱开价：-—-提前查好对应的工资基本水平"><a href="#不知情况乱开价：-—-提前查好对应的工资基本水平" class="headerlink" title="不知情况乱开价： —-提前查好对应的工资基本水平"></a>不知情况乱开价： —-提前查好对应的工资基本水平</h4><ul>
<li>说到薪资60%代表你有很大的机会被录用，可是你却狮子大开口的说薪资要求，企业怎么敢用一个漫不符合本身能力的人?如果不想吃亏，应聘前应多打听企业相关信息，不然就采取“依公司规定”的保守战略。不知行情胡乱开价，绝不让你的应聘倒扣200分。</li>
<li>北京这边的人力资源市场还是非常繁荣的，人才的流动性非常快，每年有两段流动高峰期。<ul>
<li>通常3<del>4月和9</del>10月是找工作高峰期：<ul>
<li>3~4月是大量人才拿到年终奖后跳槽的时期；</li>
<li>9~10月是各大高校毕业生求职时期；</li>
</ul>
</li>
<li>这两段时间都是企业释放大量岗位空缺的时间段，故而是求职旺季。</li>
</ul>
</li>
<li>跳槽也最好在这段时间，其它时间段最好不要跳槽，因为这时：一来岗位无空缺不好招人，二来公司人事会认为你是被裁员工印象不好，这样就不好谈价格了。</li>
<li>注意公司是以技能需求为驱动在人才市场里面找拥有目标技能的目标人群，而非以你所做项目为驱动，所以在简历里面技能项要分条重点表达，所做项目要辅助技能项做大致表达。</li>
<li>有些公司在行业里面有地位，是龙头老大，例如BAT、京东等的高并发系统架构方面的业务；平安等互联网金融的支付业务。这些公司的业务代表了行业规范，起到示范作用，能够学习到他们公司的这种权威性的技术或业务，以后可以到想效仿这些公司的其它小公司里面去，就可以有谈判的资本了，这就是在大公司的好处。（这就是为何在BAT工作的人，只要接触了BAT的核心技术，跳出来就那么值钱）</li>
<li>有些公司的某些部门，明明就不缺人，却天天打着招人的旗号，让人去面试。那么被猎头&#x2F;人事叫去面试之前，先问了解一些具体情况，有如下一些意识：<ul>
<li>从岗位角度问： 这个岗位是常年招聘的，还是最近刚招聘的。<ul>
<li>（如果是常年招聘的，那么最好不要过去了，人家公司上层可能都没有提供新员工名额，让你过去对你的要求是极高，你达到了或许有点希望，而且后面谈工资的时候对自己没有多少优势；如果是最近刚招聘的、岗位急着要人的，那么可以试试。）</li>
</ul>
</li>
<li>从部门角度问： 这个岗位所在的部门是什么情况，是由于业务扩展新成立的，还是一些老的部门。<ul>
<li>（如果是新成立一个部门，那么确实有可能要进新人，公司可能会放出岗位需求名额；如果是不是新成立的部门，是老部门，那么很可能这个岗位招人就不那么迫切。）</li>
</ul>
</li>
<li>从岗位职责要求角度问： 这个岗位的职责是什么，需要有什么技能的人选。<ul>
<li>（可以先让跟你打电话的猎头&#x2F;人事给你发一个JD邮件，你看看是否和你的技能、兴趣相符，如果相符则可以考虑是否过去；如果不相符，你都不知道他看了你的简历后怎么选的你，那你要么回信问清楚为何觉得我合适、贵岗位具体需要什么人做什么事情，如果没回音，就不要再管了，他们不要人的。不要怕把他们问烦了，他们如果真的缺人，那么不怕你多问，还怕你不来呢，问两句就烦，直接就说明他们本来就不确认，你去不去面试对他们影响不大。）</li>
</ul>
</li>
<li>面试过程中要有警觉： 如果最终还是去了，那么面试过程中也可以看到他们是否缺人。如果面试官上来就问你以前的项目，要你给他详细讲解，那么多半想把你当成免费的”老师“，你可以准备好一些素材给他讲；他问你有没有什么要问他的，你可以问他们要什么样技能的人，如果他们说的空泛不具体，不说需要具体掌握什么技能的，就是他们自己都不能详细表达岗位需求，那多半也不缺人。</li>
</ul>
</li>
<li>为何有些公司要这样“挖坑挖 ”呢？为何要设置那些长期招聘的岗位呢？ 呢<ul>
<li>第一、未雨绸缪。如果公司认为过段时间有人会离职，尤其是发完年终奖之前，那么就会提前做好准备，去招新人减少风险，而老员工未走新员工的招聘进度可以慢一点来。</li>
<li>第二、降低人力成本。如果公司当前人力成本太高，那么就想淘汰部分高价的老员工换来廉价新员工，那么会在老员工走之前招人，而新员工的招聘也可以慢一点来，招的到就招，招不到就不招，总之价格要压低。（这样的公司卸磨杀驴，不去也罢）</li>
<li>第三、换血。如果公司的部门当前好久没有换血了，对部门不是太有利，那么也是常年打着招聘的旗号招人，碰到真正有料的人选，如果成功压低了价格，也可以招进来，但公司不太缺人的情况下，不招也行。</li>
<li>第四、了解行业动态。这主要是部门某些人心术不正，让面试者赶来面试，当免费老师，以面试为名从面试者口中获取一些其它公司的技术内幕。（搞技术的人都不傻，出来混迟早要还的，心术不正败坏的是自己公司的名声。）</li>
</ul>
</li>
<li>面试官问你的职业规划？该怎么回答？回答这个问题要注意三点：<ul>
<li>接地气。也就是实实在在的说，不做作。这应该是在跟HR交流各个问题都要注意的，不要去学习面经上那些头头是道的回答，针对性并不强，不能把自己的特质表露出来，这对应聘双方都是无益的。搞清楚自己的想法，流畅的表达就行了（表达上也许需要一些技巧），至于如何搞清楚自己的想法，请看第二点。</li>
<li>预先做功课。了解自己和了解社会是一生都不应该停止的两个过程。在应聘之前，需要对自己和要应聘的行业、公司、岗位都有一定的了解，知道自己的兴趣点和竞争优势，在这个基础上才能够谈职业规划。</li>
<li>区分职业和工作。HR问你职业规划，也许只是在探寻你对这个岗位或公司的热衷度，判断你是无关痛痒的仅仅想要一份工作安身，还是对未来的发展有一定的方向，方向和目标自然不可能太具体，所以觉得难回答，但是，面试官想知道的其实是你对自己未来的期许是什么样子的，仅此而已。</li>
<li>参考：我希望在 我 **公司发展成为 公 “T”字形人才，短期目标，我希望能够接触尽可能多的知识面，努力扩展自己专业技能的 字 “横”，可以独立的完成工作中的每一个任务。长期目标，我希望自己在知识面足够宽的基础上，能够有一到两个方向的深入研究，深入自己工作中的一 长 ”竖“，早日独当一面，成为公司的中流砥柱，</li>
</ul>
</li>
</ul>
<h4 id="人事问工资该如何回答？"><a href="#人事问工资该如何回答？" class="headerlink" title="人事问工资该如何回答？"></a>人事问工资该如何回答？</h4><ul>
<li>2年工作经验：<ul>
<li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等</li>
<li>工作的内容，公司的发展</li>
<li>半年的时候去做大数据项目后加过一次薪，9000加到了12000.</li>
<li>12K——-17K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1000左右</li>
</ul>
</li>
<li>3年工作经验：<ul>
<li>17K——–23K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1400左右</li>
<li>具体的情况，根据面试的好坏做相应的调整，但是工资的税前和税后差额一般在2k—3k</li>
</ul>
</li>
<li>面试的本质不是一问一答，而是亮点展示</li>
</ul>
<h1 id="请介绍一下你自己"><a href="#请介绍一下你自己" class="headerlink" title="请介绍一下你自己"></a>请介绍一下你自己</h1><ul>
<li>这是面试官100%会问的问题，一般人回答这个问题过于平常，只说姓名、年龄、爱好、所学专业等，如果你用一分钟来重复你的简历，那么，你的印象加分没有了！</li>
<li>不妨坦诚自信地展现自我，重点突出与应聘职位相吻合的优势。你的相关能力和素质是企业最感兴趣的信息。因为，在许多情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。</li>
<li>回答范例：我叫XX，今年X岁，XXXX年毕业于XX大学。有3年的开发工作经验，我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，精通.Net技术体系，熟悉MVC。平常有时间看看博客，并且自己也喜欢在CSDN上写技术类的文章，与博友一起讨论。谢谢！</li>
</ul>
<h1 id="为什么来北京找工作？"><a href="#为什么来北京找工作？" class="headerlink" title="为什么来北京找工作？"></a>为什么来北京找工作？</h1><ul>
<li>面试官对异地求职者90%都会问的问题，主要考察你是否稳定，个人经验能力之外，排在第一位的就是稳定性，如果不够稳定，那么其余都是空谈。</li>
<li>回答范例：我来自河南，河南是一个农业大省，IT行业还不是很发达，我是学计算机专业的，也很喜欢这个行业，北京在国内IT行业发展是最快的，所以我想来这里谋求发展，学习更多的新技术，能够带来自我的提升。</li>
<li>注意：不要说以前公司有多么不好。也不要说哪个哥们混的很不错，羡慕才来北京。因为企业招人想要的都是能够长期工作的人，可能哪个哥们哪天在别的地方又混的更好了，你是不是还要跳槽？所以，只要说来学习更多新技术和管理经验就够了。</li>
</ul>
<h1 id="你为什么离开原来的公司？"><a href="#你为什么离开原来的公司？" class="headerlink" title="你为什么离开原来的公司？"></a>你为什么离开原来的公司？</h1><ul>
<li>最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在</li>
<li>避免把“离职原因”说得太详细、太具体</li>
<li>不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等</li>
<li>但也不能躲闪、回避，如“想换换环境”、“个人原因”等</li>
<li>不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等</li>
<li>尽量使解释的理由为应聘者个人形象添彩</li>
<li>相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</li>
<li>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。</li>
</ul>
<h1 id="你最大的缺点是什么？"><a href="#你最大的缺点是什么？" class="headerlink" title="你最大的缺点是什么？"></a>你最大的缺点是什么？</h1><ul>
<li>被面试官问的概率很大，也是HR的杀手锏和狠招，这个问题最难回答，通常面试官不希望听到求职直接回答的缺点是什么，如果求职者说自己小心眼、脾气大、工作效率低，企业肯定不会录用你。不要自作聪明地回答“我最大的缺点就是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。面试官喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上，突出优点的部分，面试官喜欢聪明的求职者。</li>
<li>回答范例：这个问题好难回答啊！我想想……（亲和力表现，也缓解了自己的紧张情绪）我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。</li>
</ul>
<h1 id="你未来3-5年的职业规划是怎样的？"><a href="#你未来3-5年的职业规划是怎样的？" class="headerlink" title="你未来3-5年的职业规划是怎样的？"></a>你未来3-5年的职业规划是怎样的？</h1><ul>
<li>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</li>
<li>回答范例：我希望从现在开始，1-2年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以从开发做到架构师。同时我也希望自己能够在企业的平台上得到进一步的职业能力提升。</li>
</ul>
<h1 id="你对薪资的要求？"><a href="#你对薪资的要求？" class="headerlink" title="你对薪资的要求？"></a>你对薪资的要求？</h1><ul>
<li>如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求职的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</li>
<li>回答范例一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。</li>
<li>如果你必须自己说出具体数目，那就不要说一个宽泛的范围，不要说7000-8000之间，那样你将只会得到最低限底的数字，也就是7000。最好给出一个具体的数字。</li>
</ul>
<h1 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h1><ul>
<li>大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司的规定上班”，如果还未辞去上一个工作，但上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</li>
</ul>
<h1 id="介绍一个你认为最熟悉的项目（项目经理）"><a href="#介绍一个你认为最熟悉的项目（项目经理）" class="headerlink" title="介绍一个你认为最熟悉的项目（项目经理）"></a>介绍一个你认为最熟悉的项目（项目经理）</h1><ul>
<li>这个问题在技术面试时常被问到，问这个问题的意图是想考察你的成长路径和编程习惯，因为，你最熟悉的项目往往是你成长最快的项目，那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹。所以，通过你对熟悉项目的描述，有经验的他会很快锁定你技术成长中的缺陷和闪光点，从而判断是否能够“为我所用”。</li>
<li>你最好拿出一个自己最擅长技术的那个项目进行介绍，他听完你的介绍后，会接下来进行提问，这样他所有问的问题，你都成竹在胸了。</li>
<li>切忌拿自己参与很少的项目来介绍，一旦他深入的询问很可能你会答非所问，反而造成更严重的影响。你大强以和他谈谈在那个项目中获得的经验，这样会引起此君的共鸣，有可能的话，说出一些你自己的小技巧，他会很高兴，同时这场面试也会很轻松，拿到Offer基本没问题了。</li>
</ul>
<h1 id="如果公司录用你，你将怎样开展工作？"><a href="#如果公司录用你，你将怎样开展工作？" class="headerlink" title="如果公司录用你，你将怎样开展工作？"></a>如果公司录用你，你将怎样开展工作？</h1><ul>
<li>很多企业在招聘开发人员时很看重是否能够尽快上手，所以回答这个问题时要“实打实”的回答，在回答中最好强调能够“尽快”投入开发工作中，这样领导就放心了，会觉得你不是一个只会盲目工作的人，而是一个按部就班，稳打稳扎的人。</li>
<li>回答范例：我对咱们公司的大体情况只有一个大概了解，在这个职位的工作性质仅仅是我自己的一个理解。作为这个职位而言，我想我首先要对本公司的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向、我们面向的客户性质等。第二我要了解所属部门在公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。第三，了解我参与项目的开发方式，架构方式，紧密配合领导工作，尽快投入具体的开发工作中。这就是我开展工作的计划。</li>
</ul>
<h1 id="你还有什么问题问我吗？"><a href="#你还有什么问题问我吗？" class="headerlink" title="你还有什么问题问我吗？"></a>你还有什么问题问我吗？</h1><ul>
<li>这个问题看上去可有可无，其实很关键，面试官不喜欢说“没有问题”的人，没有问题就是自寻死路，没有问题传达出你对公司缺乏兴趣，而只是来寻找一笔薪水。其实在面试过程中谦虚礼貌的问面试官怎么称呼，该部门工作中的信息，如项目情况，开发技术再或者说贵公司的晋升机制是什么样的等。表现出一种很积极主动的状态是非常讨巧的。也可以更多的了解到自己来的工作环境。企业很欢迎这样的求职者，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</li>
</ul>
<h1 id="你对加班的看法？"><a href="#你对加班的看法？" class="headerlink" title="你对加班的看法？"></a>你对加班的看法？</h1><ul>
<li>实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。</li>
<li>回答范例：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</li>
</ul>
<h1 id="你朋友对你的评价？"><a href="#你朋友对你的评价？" class="headerlink" title="你朋友对你的评价？"></a>你朋友对你的评价？</h1><ul>
<li>回答提示： 想从侧面了解一下你的性格及与人相处的问题。</li>
<li>回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。</li>
<li>回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。</li>
</ul>
<h1 id="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"><a href="#如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？" class="headerlink" title="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"></a>如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</h1><ul>
<li>回答提示：一段时间发现工作不适合我，有两种情况：<ul>
<li>如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</li>
<li>你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</li>
</ul>
</li>
</ul>
<h1 id="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"><a href="#在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？" class="headerlink" title="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"></a>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</h1><ul>
<li>原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。</li>
<li>如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。</li>
<li>还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</li>
</ul>
<h1 id="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"><a href="#如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？" class="headerlink" title="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"></a>如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</h1><ul>
<li>我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。</li>
<li>分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。</li>
<li>总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</li>
</ul>
<h1 id="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"><a href="#如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？" class="headerlink" title="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"></a>如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</h1><ul>
<li>我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：<ul>
<li>我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。</li>
<li>他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</li>
</ul>
</li>
</ul>
<h1 id="谈谈你对跳槽的看法？"><a href="#谈谈你对跳槽的看法？" class="headerlink" title="谈谈你对跳槽的看法？"></a>谈谈你对跳槽的看法？</h1><ul>
<li>正常的“跳槽”能促进人才合理流动，应该支持。</li>
<li>频繁的跳槽对单位和个人双方都不利，应该反对。</li>
</ul>
<h1 id="工作中你难以和同事、上司相处，你该怎么办？"><a href="#工作中你难以和同事、上司相处，你该怎么办？" class="headerlink" title="工作中你难以和同事、上司相处，你该怎么办？"></a>工作中你难以和同事、上司相处，你该怎么办？</h1><ul>
<li>我会服从领导的指挥，配合同事的工作。</li>
<li>我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话 我会努力改正。</li>
<li>如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。</li>
<li>作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。</li>
</ul>
<h1 id="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"><a href="#假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？" class="headerlink" title="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"></a>假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</h1><ul>
<li>成绩比较突出，得到领导的肯定是件好事情，以后更加努力。</li>
<li>检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。</li>
<li>工作中，切勿伤害别人的自尊心。</li>
<li>不再领导前拨弄是非。<br>。</li>
</ul>
<h1 id="请说出你选择这份工作的动机？"><a href="#请说出你选择这份工作的动机？" class="headerlink" title="请说出你选择这份工作的动机？"></a>请说出你选择这份工作的动机？</h1><ul>
<li>这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</li>
</ul>
<h1 id="你最擅长的技术方向是什么？"><a href="#你最擅长的技术方向是什么？" class="headerlink" title="你最擅长的技术方向是什么？"></a>你最擅长的技术方向是什么？</h1><ul>
<li>说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</li>
</ul>
<h1 id="你能为我们公司带来什么呢？"><a href="#你能为我们公司带来什么呢？" class="headerlink" title="你能为我们公司带来什么呢？"></a>你能为我们公司带来什么呢？</h1><ul>
<li>企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</li>
</ul>
<h1 id="最能概括你自己的三个词是什么？"><a href="#最能概括你自己的三个词是什么？" class="headerlink" title="最能概括你自己的三个词是什么？"></a>最能概括你自己的三个词是什么？</h1><ul>
<li>我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，</li>
</ul>
<h1 id="你的业余爱好是什么？"><a href="#你的业余爱好是什么？" class="headerlink" title="你的业余爱好是什么？"></a>你的业余爱好是什么？</h1><ul>
<li>找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。</li>
</ul>
<h1 id="作为被面试者给我打一下分？"><a href="#作为被面试者给我打一下分？" class="headerlink" title="作为被面试者给我打一下分？"></a>作为被面试者给我打一下分？</h1><ul>
<li>试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</li>
</ul>
<h1 id="你怎么理解你应聘的职位？"><a href="#你怎么理解你应聘的职位？" class="headerlink" title="你怎么理解你应聘的职位？"></a>你怎么理解你应聘的职位？</h1><ul>
<li>把岗位职责和任务及工作态度阐述一下。</li>
</ul>
<h1 id="喜欢这份工作的哪一点？"><a href="#喜欢这份工作的哪一点？" class="headerlink" title="喜欢这份工作的哪一点？"></a>喜欢这份工作的哪一点？</h1><ul>
<li>相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</li>
</ul>
<h1 id="说说你对行业、技术发展趋势的看法？"><a href="#说说你对行业、技术发展趋势的看法？" class="headerlink" title="说说你对行业、技术发展趋势的看法？"></a>说说你对行业、技术发展趋势的看法？</h1><ul>
<li>企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</li>
</ul>
<h1 id="对工作的期望与目标何在？"><a href="#对工作的期望与目标何在？" class="headerlink" title="对工作的期望与目标何在？"></a>对工作的期望与目标何在？</h1><ul>
<li>这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</li>
</ul>
<h1 id="说你的家庭"><a href="#说你的家庭" class="headerlink" title="说你的家庭"></a>说你的家庭</h1><ul>
<li>企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。</li>
<li>企业希望听到的重点也在于家庭对求职者的积极影响。</li>
<li>企业最喜欢听到的是：我很爱我的家庭，我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。</li>
<li>我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。</li>
<li>企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</li>
</ul>
<h1 id="就你申请的这个职位，你认为你还欠缺什么？"><a href="#就你申请的这个职位，你认为你还欠缺什么？" class="headerlink" title="就你申请的这个职位，你认为你还欠缺什么？"></a>就你申请的这个职位，你认为你还欠缺什么？</h1><ul>
<li>企业喜欢问求职者弱点，但精明的求职者一般不直接回答。</li>
<li>他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</li>
</ul>
<h1 id="你欣赏哪种性格的人？"><a href="#你欣赏哪种性格的人？" class="headerlink" title="你欣赏哪种性格的人？"></a>你欣赏哪种性格的人？</h1><ul>
<li>诚实、不死板而且容易相处的人、有“实际行动”的人。</li>
</ul>
<h1 id="你通常如何处理別人的批评？"><a href="#你通常如何处理別人的批评？" class="headerlink" title="你通常如何处理別人的批评？"></a>你通常如何处理別人的批评？</h1><ul>
<li>沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。</li>
<li>我会等大家冷靜下来再讨论。</li>
</ul>
<h1 id="你为什么愿意到我们公司来工作？"><a href="#你为什么愿意到我们公司来工作？" class="headerlink" title="你为什么愿意到我们公司来工作？"></a>你为什么愿意到我们公司来工作？</h1><ul>
<li>对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</li>
</ul>
<h1 id="你和别人发生过争执吗？你是怎样解决的？"><a href="#你和别人发生过争执吗？你是怎样解决的？" class="headerlink" title="你和别人发生过争执吗？你是怎样解决的？"></a>你和别人发生过争执吗？你是怎样解决的？</h1><ul>
<li>这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。</li>
<li>你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。</li>
<li>他们通过这个问题了解你的成熟度和处世能力。</li>
<li>在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</li>
</ul>
<h1 id="问题：你做过的哪件事最令自己感到骄傲？"><a href="#问题：你做过的哪件事最令自己感到骄傲？" class="headerlink" title="问题：你做过的哪件事最令自己感到骄傲？"></a>问题：你做过的哪件事最令自己感到骄傲？</h1><ul>
<li>这是考官给你的一个机会，让你展示自己把握命运的能力。</li>
<li>这会体现你潜在的领导能力以及你被提升的可能性。</li>
<li>假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐</li>
<li>记住：你的前途取决于你的知识、你的社交能力和综合表现。</li>
</ul>
<h1 id="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"><a href="#新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？" class="headerlink" title="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"></a>新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？</h1><ul>
<li>首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。</li>
<li>其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。</li>
<li>再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。</li>
<li>再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。</li>
<li>我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。</li>
</ul>
<h1 id="对这项工作，你有哪些可预见的困难？"><a href="#对这项工作，你有哪些可预见的困难？" class="headerlink" title="对这项工作，你有哪些可预见的困难？"></a>对这项工作，你有哪些可预见的困难？</h1><ul>
<li>不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。</li>
<li>可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。</li>
<li>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。</li>
<li>当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</li>
</ul>
<h1 id="怎样对待自己的失敗？"><a href="#怎样对待自己的失敗？" class="headerlink" title="怎样对待自己的失敗？"></a>怎样对待自己的失敗？</h1><ul>
<li>我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</li>
</ul>
<h1 id="什么会让你有成就感？"><a href="#什么会让你有成就感？" class="headerlink" title="什么会让你有成就感？"></a>什么会让你有成就感？</h1><ul>
<li>为贵公司竭力效劳，尽我所能，完成一个项目。</li>
</ul>
<h1 id="眼下你生活中最重要的是什么？"><a href="#眼下你生活中最重要的是什么？" class="headerlink" title="眼下你生活中最重要的是什么？"></a>眼下你生活中最重要的是什么？</h1><ul>
<li>对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。</li>
</ul>
<h1 id="与上级意见不一是，你将怎么办？"><a href="#与上级意见不一是，你将怎么办？" class="headerlink" title="与上级意见不一是，你将怎么办？"></a>与上级意见不一是，你将怎么办？</h1><ul>
<li><p>一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</p>
</li>
<li><p>如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</p>
</li>
<li><p>分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p>
</li>
<li><p>你工作经验欠缺，如何能胜任这项工作？</p>
</li>
<li><p>如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。</p>
</li>
<li><p>对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。</p>
</li>
<li><p>如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</p>
</li>
<li><p>点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p>
</li>
</ul>
<h1 id="你希望与什么样的上级共事？"><a href="#你希望与什么样的上级共事？" class="headerlink" title="你希望与什么样的上级共事？"></a>你希望与什么样的上级共事？</h1><ul>
<li>通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。</li>
<li>最好回避对上级具体的希望，多谈对自己的要求。</li>
<li>如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。</li>
<li>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</li>
</ul>
<h1 id="谈谈如何适应办公室工作的新环境？"><a href="#谈谈如何适应办公室工作的新环境？" class="headerlink" title="谈谈如何适应办公室工作的新环境？"></a>谈谈如何适应办公室工作的新环境？</h1><ul>
<li>办公室里每个人有各自的岗位与职责，不得擅离岗位。</li>
<li>根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。</li>
<li>多请示并及时汇报，遇到不明白的要虚心请教。</li>
<li>抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</li>
</ul>
<h1 id="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"><a href="#为了做好你工作份外之事，你该怎样获得他人的支持和帮助？" class="headerlink" title="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"></a>为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</h1><ul>
<li>每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</li>
</ul>
<h1 id="如果你在这次面试中没有被录用，你怎么打算？"><a href="#如果你在这次面试中没有被录用，你怎么打算？" class="headerlink" title="如果你在这次面试中没有被录用，你怎么打算？"></a>如果你在这次面试中没有被录用，你怎么打算？</h1><ul>
<li>现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。</li>
<li>我会从以下几个方面来正确看待这次失败：<ul>
<li>要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。</li>
<li>善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。</li>
<li>走出阴影，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。</li>
<li>认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的成绩。</li>
<li>再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞争。</li>
</ul>
</li>
</ul>
<h1 id="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"><a href="#假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？" class="headerlink" title="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"></a>假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？</h1><ul>
<li>我觉得工作是第一位的，但朋友间的情谊也是不能偏废的，这个问题我觉得要按照当时具体的情况来决定。</li>
<li>如果我的朋友晚上9点中的飞机，而我的加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。</li>
<li>如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。</li>
<li>如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。<ul>
<li>如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。</li>
<li>如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，相信他会理解，毕竟工作做完了就完了，朋友还是可以再见面的。</li>
</ul>
</li>
</ul>
<h1 id="谈谈你过去做过的成功案例？"><a href="#谈谈你过去做过的成功案例？" class="headerlink" title="谈谈你过去做过的成功案例？"></a>谈谈你过去做过的成功案例？</h1><ul>
<li>举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。</li>
<li>切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</li>
</ul>
<h1 id="谈谈你过去的工作经验中，最令你挫折的事情？"><a href="#谈谈你过去的工作经验中，最令你挫折的事情？" class="headerlink" title="谈谈你过去的工作经验中，最令你挫折的事情？"></a>谈谈你过去的工作经验中，最令你挫折的事情？</h1><ul>
<li>曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。</li>
<li>分析：借此了解你对挫折的容忍度及调解方式。</li>
</ul>
<h1 id="如何安排自己的时间？会不会排斥加班？"><a href="#如何安排自己的时间？会不会排斥加班？" class="headerlink" title="如何安排自己的时间？会不会排斥加班？"></a>如何安排自己的时间？会不会排斥加班？</h1><ul>
<li>基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。</li>
<li>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</li>
</ul>
<h1 id="为什么我们要在众多的面试者中选择你？"><a href="#为什么我们要在众多的面试者中选择你？" class="headerlink" title="为什么我们要在众多的面试者中选择你？"></a>为什么我们要在众多的面试者中选择你？</h1><ul>
<li>根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、ＥＱ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。</li>
<li>分析：别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。</li>
</ul>
<h1 id="你并非毕业于名牌院校？"><a href="#你并非毕业于名牌院校？" class="headerlink" title="你并非毕业于名牌院校？"></a>你并非毕业于名牌院校？</h1><ul>
<li>是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我想我更适合贵公司这个职位。</li>
</ul>
<h1 id="怎样看待学历和能力？"><a href="#怎样看待学历和能力？" class="headerlink" title="怎样看待学历和能力？"></a>怎样看待学历和能力？</h1><ul>
<li>学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？</li>
</ul>
<h1 id="工作中学习到了些什么？"><a href="#工作中学习到了些什么？" class="headerlink" title="工作中学习到了些什么？"></a>工作中学习到了些什么？</h1><ul>
<li>这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</li>
</ul>
<h1 id="想过创业吗？"><a href="#想过创业吗？" class="headerlink" title="想过创业吗？"></a>想过创业吗？</h1><ul>
<li>这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？</li>
</ul>
<h1 id="除了本公司外，还应聘了哪些公司？"><a href="#除了本公司外，还应聘了哪些公司？" class="headerlink" title="除了本公司外，还应聘了哪些公司？"></a>除了本公司外，还应聘了哪些公司？</h1><ul>
<li>很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</li>
</ul>
<h1 id="面试注意事项："><a href="#面试注意事项：" class="headerlink" title="面试注意事项："></a>面试注意事项：</h1><ul>
<li>在面试官面前千万不要抖脚，手脚不要动来动去，不能有小动作。</li>
<li>在面试过程中，千万不要跟面试官去争论，说话太冲，太能说、抢话说、乱说都不好，遇到难题，先思考一下，切记心浮气燥，表达时口气温和，谦虚。</li>
<li>如果面试过程中都不错，谈的也很好，之后却没有给Offer，完全是自己意料之外的情况，这个很有可能，或许是因为公司有了其他的人选，不用介意，更不要沮丧。</li>
<li>在面试过程中，切忌问关于公司计划、行业机密等相关的东西，不要打探公司的内幕，机密敏感性的问题不要问东问西。</li>
<li>千万要注意仪容仪表，要有礼貌，最好不要有口吃，口头表达，逻辑思维很重要，不要让面试官觉得你很幼稚，太过小孩子气，显的不够稳重踏实。</li>
<li>在去面试之前，要熟悉自己的简历，特别是工作经历，准备好关于一些离职原因、职业规划方面的问题的回答方式。</li>
<li>在面试过程中，80%的面试官会让做自我介绍，所以提前要准备一下，说出的内容既要和简历相符，又要有重点有突出的地方，不能像背简历一样。</li>
<li>面试完后，如果等待的时间较长，没有回应，就可能没有什么希望了，自己可以打电话去了解情况。</li>
<li>在面试过程中，谈到薪资的时候，如果没有说明是税后工资就是税前，假如是税前6000，这里面就包括了公司给交的公积金，还有其他五险要交的费用，拿到手差不多4000左右。</li>
</ul>
<h1 id="投递简历注意事项"><a href="#投递简历注意事项" class="headerlink" title="投递简历注意事项"></a>投递简历注意事项</h1><ul>
<li>投简历的时间最好在早上8点多钟，因为人事9点多开始收简历，收到的简历又都是按时间来排序的，所以一般早上8点到9点投的都会排在前面，人事当天就能看到。</li>
<li>写简历：<ul>
<li>现居住地最好能在企业附近，如果不在，只写北京，人事比较看重现居住地，如果你填写的现居地离公司远，基本上人事就不太愿意打电话了，因为她（他）怕你不会来。</li>
<li>期望薪资最好不要写在简历上，也不要填写在网上的简历上，具体薪资见面的时候再谈。</li>
<li>大部分的岗位招聘都有相应的硬性要求，比如：年龄、居住地点、工作年限等。如果自己不符合也没有关系，机会还有很多。</li>
<li>简历上的工作经历不能太多，否则人事会觉得你不够稳定。</li>
<li>开发工作，简历上的项目要抓住重点，放重要的技术点，不能千篇一律，简短、抓住中心。</li>
</ul>
</li>
</ul>
<h1 id="入职后试用期："><a href="#入职后试用期：" class="headerlink" title="入职后试用期："></a>入职后试用期：</h1><ul>
<li>到了公司之后，工作中不懂的地方要多问，跟同事搞好关系，多看看旁人在干什么～</li>
<li>有些同学被录用之后都还不知道自己的薪资待遇，也不知道公司有哪些福利，这是因为在面试过程中不敢多问。因此，如果在面试过程中，面试官已经比较明确的表达了想让你去上班后，你就可以在适当的时候问一些关于工作的情况，工资、福利待遇，上班时间，加班情况等等。</li>
</ul>
<h1 id="上家公司的组成架构"><a href="#上家公司的组成架构" class="headerlink" title="上家公司的组成架构"></a>上家公司的组成架构</h1><ul>
<li>根据你的公司来定即可</li>
</ul>
<h1 id="从下面几个方面来准备面试"><a href="#从下面几个方面来准备面试" class="headerlink" title="从下面几个方面来准备面试"></a>从下面几个方面来准备面试</h1><ul>
<li>自我介绍。（你可千万这样介绍：“我叫某某，性别，来自哪里，学校是那个，自己爱干什么”，记住：多说点简历上没有的，多说点自己哪里比别人强！）</li>
<li>自己面试中可能涉及哪些知识点、那些知识点是重点。</li>
<li>面试中哪些问题会被经常问到、面试中自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li>
<li>自己的简历该如何写。<ul>
<li>“80%的offer掌握在20%的人手中” 这句话也不是不无道理的。决定你面试能否成功的因素中实力固然占有很大一部分比例，但是如果你的心态或者说运气不好的话，依然无法拿到满意的 offer。运气暂且不谈，就拿心态来说，千万不要因为面试失败而气馁或者说怀疑自己的能力，面试失败之后多总结一下失败的原因，后面你就会发现自己会越来越强大。</li>
<li>另外，大家要明确的很重要的几点是：<ul>
<li>写在简历上的东西一定要慎重，这可能是面试官大量提问的地方；</li>
<li>大部分应届生找工作的硬伤是没有工作经验或实习经历；</li>
<li>将自己的项目经历完美的展示出来非常重要。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="如何准备一场面试"><a href="#如何准备一场面试" class="headerlink" title="如何准备一场面试"></a>如何准备一场面试</h1><ul>
<li>不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。 我其实特别不喜欢那种临近考试就提前背啊记啊各种题的行为，非常反对！我觉得这种方法特别极端，而且在稍有一点经验的面试官面前是根本没有用的。建议大家还是一步一个脚印踏踏实实地走。</li>
</ul>
<h1 id="面试必知"><a href="#面试必知" class="headerlink" title="面试必知"></a>面试必知</h1><ul>
<li>下面几点概括起来就是：了解自己的能力、要应聘的公司、自己要应聘的岗位，提前做好自己我介绍以及项目介绍等<br>等方面的功课，确保你能在面试过程中简短清晰的回答出来（可以用Star法则来组织自己的语言）。</li>
<li>准备自己的自我介绍<ul>
<li>从HR面、技术面到高管面&#x2F;部门主管面，面试官一般会让你先自我介绍一下，所以好好准备自己的自我介绍真的非常重要。网上一般建议的是准备好两份自我介绍：一份对hr说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节，项目经验，经历那些就一语带过。</li>
</ul>
</li>
<li>关于着装<ul>
<li>穿西装、打领带、小皮鞋？NO！NO！NO！这是互联网公司面试又不是去走红毯，所以你只需要穿的简单大方就好，不需要太正式。</li>
</ul>
</li>
<li>如果需要笔试就提前刷一些笔试题<ul>
<li>平时空闲时间多的可以刷一下笔试题目（牛客网上有很多）。但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。</li>
</ul>
</li>
<li>花时间一些逻辑题<ul>
<li>面试中发现有些公司都有逻辑题测试环节，并且都把逻辑笔试成绩作为很重要的一个参考。</li>
</ul>
</li>
<li>准备好自己的项目介绍<ul>
<li>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：1.  对项目整体设计的一个感受（面试官可能会让你画系统的架构图）</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ul>
</li>
<li>提前了解公司以及要应聘的岗位<ul>
<li>面试之前一定要提前对要应聘的公司以及岗位有所了解，这一点对于喜欢海投的同学来说要格外注意。如果你去一个公司面试连公司的主要业务或者主要产品都不了解的话，那么面试官打心里肯定会觉得你并没有很重视他们公司，所以他们为什么要重视你呢？你也要提前了解你所要应聘岗位对你的专业能力或者其他能力的要求，比如有的岗位就是需要英语水平比较高，需要你通过六级或者托福雅思，假如你不满足的话，那就没必要再去投递简历面试了。</li>
</ul>
</li>
<li>提前准备技术面试<ul>
<li>搞清楚自己面试中可能涉及哪些知识点、那些知识点是重点。面试中哪些问题会被经常问到、自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li>
</ul>
</li>
<li>面试之前做好定向复习<ul>
<li>所谓定向复习就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</li>
</ul>
</li>
<li>面试之后复盘<ul>
<li>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！</li>
</ul>
</li>
</ul>
<h1 id="简历该如何写"><a href="#简历该如何写" class="headerlink" title="简历该如何写"></a>简历该如何写</h1><ul>
<li>俗话说的好：“工欲善其事，必先利其器”。准备一份好的简历对于能不能找到一份好工作起到了至关重要的作用。</li>
</ul>
<h4 id="为什么说简历很重要？"><a href="#为什么说简历很重要？" class="headerlink" title="为什么说简历很重要？"></a>为什么说简历很重要？</h4><ul>
<li>HR的筛选</li>
<li>一般情况下你的简历上注明你会的东西才会被问到（Java、数据结构、网络、算法这些基础是每个人必问的），比如写了你会 redis,那面试官就很大概率会问你 redis 的一些问题。比如：redis的常见数据类型及应用场景、redis是单线程为什么还这么快、 redis 和 memcached 的区别、redis 内存淘汰机制等等。</li>
<li>你不会的东西就不要写在简历上</li>
<li>你要考虑你该如何才能让你的亮点在简历中凸显出来，比如：你在某某项目做了什么事情解决了什么问题（只要有项目就一定有要解决的问题）、你的某一个项目里使用了什么技术后整体性能和并发量提升了很多等等。</li>
</ul>
<h4 id="这3点你必须知道"><a href="#这3点你必须知道" class="headerlink" title="这3点你必须知道"></a>这3点你必须知道</h4><ul>
<li>大部分公司的HR都说我们不看重学历（骗你的！）</li>
<li>大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的工作</li>
<li>写在简历上的东西一定要慎重，这是面试官大量提问的地方；</li>
<li>将自己的项目经历完美的展示出来非常重要。</li>
</ul>
<h4 id="你必须知道的两大法则"><a href="#你必须知道的两大法则" class="headerlink" title="你必须知道的两大法则"></a>你必须知道的两大法则</h4><h5 id="STAR法则（Situation-Task-Action-Result）"><a href="#STAR法则（Situation-Task-Action-Result）" class="headerlink" title="STAR法则（Situation Task Action Result）"></a>STAR法则（Situation Task Action Result）</h5><ul>
<li>Situation： 事情是在什么情况下发生；</li>
<li>Task:： 你是如何明确你的任务的；</li>
<li>Action： 针对这样的情况分析，你采用了什么行动方式；</li>
<li>Result： 结果怎样，在这样的情况下你学习到了什么。</li>
<li>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</li>
</ul>
<h5 id="FAB-法则（Feature-Advantage-Benefit）"><a href="#FAB-法则（Feature-Advantage-Benefit）" class="headerlink" title="FAB 法则（Feature Advantage Benefit）"></a>FAB 法则（Feature Advantage Benefit）</h5><ul>
<li>Feature： 是什么；</li>
<li>Advantage： 比别人好在哪些地方；</li>
<li>Benefit： 如果雇佣你，招聘方会得到什么好处。</li>
<li>简单来说，这个法则主要是让你的面试官知道你的优势、招了你之后对公司有什么帮助。</li>
</ul>
<h4 id="项目经历怎么写？"><a href="#项目经历怎么写？" class="headerlink" title="项目经历怎么写？"></a>项目经历怎么写？</h4><ul>
<li>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：<ul>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ul>
</li>
</ul>
<h4 id="专业技能该怎么写？"><a href="#专业技能该怎么写？" class="headerlink" title="专业技能该怎么写？"></a>专业技能该怎么写？</h4><ul>
<li>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可</li>
</ul>
<h4 id="开源程序员简历模板分享"><a href="#开源程序员简历模板分享" class="headerlink" title="开源程序员简历模板分享"></a>开源程序员简历模板分享</h4><ul>
<li>分享一个Github上开源的程序员简历模板。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C&#x2F;C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板 。</li>
</ul>
<h4 id="其他的一些关于写简历的小tips"><a href="#其他的一些关于写简历的小tips" class="headerlink" title="其他的一些关于写简历的小tips"></a>其他的一些关于写简历的小tips</h4><ul>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ul>
<h1 id="如果面试官问你“你有什么问题问我吗？”时，你该如何回答"><a href="#如果面试官问你“你有什么问题问我吗？”时，你该如何回答" class="headerlink" title="如果面试官问你“你有什么问题问我吗？”时，你该如何回答"></a>如果面试官问你“你有什么问题问我吗？”时，你该如何回答</h1><ul>
<li>我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了你这么多问题了，你有什么问题问我吗？”。这个时候很多人内心就会陷入短暂的纠结中:我该问吗？不问的话面试官会不会对我影响不好？问什么问题？问这个问题会不会让面试官对我的影响不好啊？</li>
</ul>
<h4 id="这个问题对最终面试结果的影响到底大不大"><a href="#这个问题对最终面试结果的影响到底大不大" class="headerlink" title="这个问题对最终面试结果的影响到底大不大?"></a>这个问题对最终面试结果的影响到底大不大?</h4><ul>
<li>就技术面试而言，回答这个问题的时候，只要你不是触碰到你所面试的公司的雷区，那么我觉得这对你能不能拿到最终offer来说影响确实是不大的。我说这些并不代表你就可以直接对面试官说：“我没问题了。”，笔主当时面试的时候确实也说过挺多次“没问题要问了。”，最终也没有导致笔主被pass掉（可能是前面表现比较好，哈哈，自恋一下）。我现在回想起来，觉得自己当时做法其实挺不对的。面试本身就是一个双向选择的过程，你对这个问题的- 回答也会侧面反映出你对这次面试的上心程度，你的问题是否有价值，也影响了你最终的选择与公司是否选择你。</li>
<li>面试官在技术面试中主要考察的还是你这样个人到底有没有胜任这个工作的能力以及你是否适合公司未来的发展需要，很多公司还需要你认同它的文化，我觉得你只要不是太笨，应该不会栽在这里。除非你和另外一个人在能力上相同，但是只能在你们两个人中选一个，那么这个问题才对你能不能拿到offer至关重要。有准备总比没准备好，给面试官留一个好的影响总归是没错的。</li>
<li>但是，就非技术面试来说，我觉得好好回答这个问题对你最终的结果还是比较重要的。</li>
<li>总的来说不管是技术面试还是非技术面试，如果你想赢得公司的青睐和尊重，我觉得我们都应该重视这个问题。</li>
</ul>
<h4 id="真诚一点-不要问太-Low-的问题"><a href="#真诚一点-不要问太-Low-的问题" class="headerlink" title="真诚一点,不要问太 Low 的问题"></a>真诚一点,不要问太 Low 的问题</h4><ul>
<li>回答这个问题很重要的一点就是你没有必要放低自己的姿态问一些很虚或者故意讨好面试官的问题，也不要把自己从面经上学到的东西照搬下来使用。面试官也不是傻子，特别是那种特别有经验的面试官，你是真心诚意的问问题，还是从别处照搬问题来讨好面试官，人家可能一听就听出来了。总的来说，还是要真诚。除此之外，不要问太Low的问题，会显得你整个人格局比较小或者说你根本没有准备（侧面反映你对这家公司不伤心，既然你不上心，为什么要要你呢）。举例几个比较 Low 的问题，大家看看自己有没有问过其中的问题：<ul>
<li>贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？）</li>
<li>贵公司的男女比例如何？（考虑脱单？记住你是来工作的！）</li>
<li>贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！）</li>
</ul>
</li>
</ul>
<h4 id="有哪些有价值的问题值得问"><a href="#有哪些有价值的问题值得问" class="headerlink" title="有哪些有价值的问题值得问?"></a>有哪些有价值的问题值得问?</h4><ul>
<li>针对这个问题。笔主专门找了几个专门做HR工作的小哥哥小姐姐们询问并且查阅了挺多前辈们的回答，然后结合自己的实际经历，我概括了下面几个比较适合问的问题。</li>
<li>面对HR或者其他Level比较低的面试官时<ul>
<li>能不能谈谈你作为一个公司老员工对公司的感受? (这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离。)</li>
<li>能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?有什么地方你觉得还不太好或者可以继续完善吗？ （类似第一个问题，都是问面试官个人对于公司的看法，）</li>
<li>我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)</li>
<li>接下来我会有一段空档期，有什么值得注意或者建议学习的吗？ （体现出你对工作比较上心，自助学习意识比较强。）</li>
<li>这个岗位为什么还在招人？ (岗位真实性和价值咨询)</li>
<li>大概什么时候能给我回复呢？ (终面的时候，如果面试官没有说的话，可以问一下)</li>
</ul>
</li>
<li>面对部门领导<ul>
<li>部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</li>
<li>未来如果我要加入这个团队，你对我的期望是什么？ （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）</li>
<li>公司对新入职的员工的培养机制是什么样的呢？ （正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心）</li>
<li>以您来看，这个岗位未来在公司内部的发展如何？ (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)</li>
<li>团队现在面临的最大挑战是什么？ (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)</li>
</ul>
</li>
<li>面对Level比较高的(比如总裁,老板)<ul>
<li>贵公司的发展目标和方向是什么？ （看下公司的发展是否满足自己的期望）</li>
<li>与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？ （充分了解自己的优势和劣势）</li>
<li>公司现在面临的最大挑战是什么？</li>
</ul>
</li>
</ul>
<h1 id="面试官问你的优点是什么，应该如何回答"><a href="#面试官问你的优点是什么，应该如何回答" class="headerlink" title="面试官问你的优点是什么，应该如何回答?"></a>面试官问你的优点是什么，应该如何回答?</h1><ul>
<li>回答这样的问题，最好能够结合你要应聘的职位来做针对性回答。一般面试官问这个问题的时候，很可能会只让你说几个你觉得最能体现你能力的优点，为了避免自己在面试过程中不知道该说自己的那些优点，你可以在面试之前好好准备一下。 面试的时候最好可以说几个你要应聘的职位所做的事情需要的优点或者说你要应聘的公司比较看重的优点(企业文化)。</li>
</ul>
<h1 id="面试官问你的缺点是什么，应该如何回答"><a href="#面试官问你的缺点是什么，应该如何回答" class="headerlink" title="面试官问你的缺点是什么，应该如何回答?"></a>面试官问你的缺点是什么，应该如何回答?</h1><ul>
<li>缺点肯定不能是目标岗位需要的关键能力！！！</li>
<li>总之，记住一点，面试官问你这个问题的话，你可以说一些不影响你这个职位工作需要的一些缺点。比如你面试后端工程师，面试官问你的缺点是什么的话，你可以这样说：自己比较内向，平时不太爱与人交流，但是考虑到以后可能要和客户沟通，自己正在努力改。</li>
</ul>
]]></content>
      <categories>
        <category>面试技巧</category>
      </categories>
      <tags>
        <tag>面试技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用性（HA）系统</title>
    <url>/publishes/3842b15435d5.html</url>
    <content><![CDATA[<h1 id="SOA-面向服务的架构"><a href="#SOA-面向服务的架构" class="headerlink" title="SOA(面向服务的架构)"></a>SOA(面向服务的架构)</h1><ul>
<li>面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来</li>
<li>接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言</li>
<li>这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。</li>
<li>对于一个SOA解决方案来说就需要能够满足这些场景的业务需求，能够解决其中的各种技术问题</li>
<li>需要解决的基本问题包括：<ul>
<li>服务的描述问题，描述服务提供哪些功能，适用服务有哪些要求</li>
<li>服务的注册和查找问题，定义好的服务信息在哪发布，如何发布，到哪查找，如何查找</li>
<li>服务通讯方式，包括具体如何向服务发送请求，并获取应答，支持什么样的交互方式。</li>
<li>服务流程问题，对服务流程的灵活定制，执行监控等提供管理</li>
<li>服务的管理问题，服务的提供，撤销，改变这些情况如何进行管理</li>
<li>服务质量问题，如何保障安全性，通讯的可靠性，以及事务完整性如何保证</li>
<li>整个系统的效率问题，包括查找效率，通讯效率，服务运行处理效率等</li>
<li>系统能够提供什么样的开发工具，支持什么样的开发模式，系统运行情况是否可以及时了解，是否可以及时获取故障信息，是否可以提供运行状态信息，以利于系统的优化。</li>
</ul>
</li>
</ul>
<h1 id="ESB（企业服务总线）"><a href="#ESB（企业服务总线）" class="headerlink" title="ESB（企业服务总线）"></a>ESB（企业服务总线）</h1><ul>
<li>ESB全称为Enterprise Service Bus，即企业服务总线</li>
<li>它是传统中间件技术与XML、Web服务等技术结合的产物</li>
<li>ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素。</li>
<li>大规模分布式的企业应用需要相对简单而实用的中间件技术来简化和统一越来越复杂、繁琐的企业级信息系统平台</li>
<li>面向服务体系架构（SOA）是能够将应用程序的不同功能单元通过服务之间定义良好的接口和契约联系起来</li>
<li>SOA使用户可以不受限制地重复使用软件、把各种资源互连起来，只要IT人员选用标准接口包装旧的应用程序、把新的应用程序构建成服务，那么其他应用系统就可以很方便的使用这些功能服务。</li>
</ul>
<h1 id="SOA-与-ESB的区别"><a href="#SOA-与-ESB的区别" class="headerlink" title="SOA 与 ESB的区别"></a>SOA 与 ESB的区别</h1><ul>
<li>SOA是一种方式或架构，用于具有自服务功能的应用程序，应用程序随后通过用户接口（UI）或经过工作流将其聚合成用户需要的功能</li>
<li>服务不仅是可复用代码的组件，更是运行程序的一部分，客户端可以不必合并它自己的代码直接调用该程序</li>
<li>服务是与业务相关的一个定义。</li>
<li>ESB是用于调节 SOA 中的调用者及服务提供者的机制</li>
<li>它使得调用者在不知道提供者或提供者使用的地址的情况下调用该服务</li>
<li>ESB 可在多个提供者、提供者的负载平衡及停止使用提供者（当失效时）之间进行选择，并且基于调用者的需求在提供者之间进行选择，这些提供者提供了各种质量级别的服务</li>
<li>ESB 能够调节同步或异步服务，事实上对于同一服务可以提供同步及异步的访问。</li>
<li>因此 SOA 和 ESB 是相对应的。具备 SOA 的应用程序应当使用 ESB 来调用它的服务。SOA 和 ESB 不必用 Web 服务实现。然而，经常需要 ESB 来调用服务，该服务提供自我描述及发现的能力，这由 Web 服务帮助完成。在 SOA 中经常需要由一种技术实现的调用者，它们用于调用由其它技术实现的服务，这也由 Web 服务帮助完成</li>
<li>所以 SOA、ESB 和 Web 服务都集中于创建这样的领域：一个应用程序中的功能在其它应用程序中也是可用的，本质是复用性。</li>
</ul>
<h1 id="SAAS-软件即服务"><a href="#SAAS-软件即服务" class="headerlink" title="SAAS (软件即服务)"></a>SAAS (软件即服务)</h1><ul>
<li>SaaS是Software-as-a-Service（软件即服务）的简称,它与“on-demand software”（按需软件），the application service provider(ASP，应用服务提供商)，hosted software(托管软件)所具有相似的含义</li>
<li>它是一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。</li>
<li>对企业来说，SaaS的优点：<ul>
<li>从技术方面来看：SaaS是简单的部署，不需要购买任何硬件，刚开始只需要简单注册即可。企业无需再配备IT方面的专业技术人员，同时又能得到最新的技术应用，满足企业对信息管理的需求。</li>
<li>从投资方面来看：企业只以相对低廉的“月费”方式投资，不用一次性投资到位，不占用过多的营运资金，从而缓解企业资金不足的压力；不用考虑成本折旧问题，并能及时获得最新硬件平台及最佳解决方案。</li>
<li>从维护和管理方面来看：由于企业采取租用的方式来进行物流业务管理，不需要专门的维护和管理人员，也不需要为维护和管理人员支付额外费用。很大程度上缓解企业在人力、财力上的压力，使其能够集中资金对核心业务进行有效的运营；SaaS能使用户在世界上都是一个完全独立的系统。如果您连接到网络，就可以访问系统。</li>
</ul>
</li>
<li>对企业来说，SaaS的缺点<ul>
<li>安全性：企业，尤其是大型企业，很不情愿使用SaaS正是因为安全问题，他们要保护他们的核心数据，不希望这些核心数据由第三方来负责。</li>
<li>标准化：SaaS解决方案缺乏标准化。这个行业刚刚起步，没有明确的解决办法，一家公司可以设计建立一个解决方案。鉴于复杂和高度可定制的ERP产品，这是一个冒险的建议。</li>
</ul>
</li>
</ul>
<h1 id="SOA和SaaS的区别"><a href="#SOA和SaaS的区别" class="headerlink" title="SOA和SaaS的区别"></a>SOA和SaaS的区别</h1><ul>
<li>SOA包括了关于软件是如何被架构起来的东西，而SaaS是关于软件是如何被应用的。</li>
<li>在SaaS当中，应用程序可以像任何服务一样被传递，就像你家中电话的语音一样，看起来似乎就是为你的需求量体裁衣得到的。而SOA的定义和这个无丝毫的联系。SOA支持的服务，都是些离散的可以再使用的事务处理，这些事务处理合起来就组成了一个业务流程，是从基本的系统中提取出来的抽象代码。</li>
<li>SOA是一个框架的方法，而SaaS是一种传递模型。</li>
<li>通过SaaS传递Web服务并不需要SOA。</li>
<li>SaaS主要是指一个软件企业向其它企业提供软件服务。而SOA一般是企业内部搭建系统的基础。SaaS注重的是提供服务的思维。而SOA注重的是实现服务的思维。</li>
</ul>
<h1 id="微服务架构模式（Microservice-Architect-Pattern）"><a href="#微服务架构模式（Microservice-Architect-Pattern）" class="headerlink" title="微服务架构模式（Microservice Architect Pattern）"></a>微服务架构模式（Microservice Architect Pattern）</h1><ul>
<li>近两年在服务的疯狂增长与云计算技术的进步，让微服务架构受到重点关注微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值</li>
<li>每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。</li>
<li>每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建</li>
</ul>
<h4 id="微服务架构优势"><a href="#微服务架构优势" class="headerlink" title="微服务架构优势"></a>微服务架构优势</h4><ul>
<li>微服务架构的本质，是用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题</li>
<li>微服务架构将服务拆分，分别采用相对独立的服务对各方面进行管理，彼此之间使用统一的接口来进行交流，架构变得复杂，优势也很明显：<ul>
<li>复杂度可控：在将应用分解的同时，规避了原本复杂度无止境的积累</li>
<li>每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界</li>
<li>由于体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。</li>
<li>独立部署：由于微服务具备独立的运行进程，所以每个微服务也可以独立部署</li>
<li>当某个微服务发生变更时无需编译、部署整个应用</li>
<li>由微服务组成的应用相当于具备一系列可并行的发布流程，使得发布更加高效，同时降低对生产环境所造成的风险，最终缩短应用交付周期。</li>
<li>技术选型灵活：微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。由于每个微服务相对简单，当需要对技术栈进行升级时所面临的风险较低，甚至完全重构一个微服务也是可行的。</li>
<li>容错：当某一组建发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用</li>
<li>在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。</li>
<li>扩展：单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</li>
</ul>
</li>
</ul>
<h1 id="SOA和微服务架构的区别"><a href="#SOA和微服务架构的区别" class="headerlink" title="SOA和微服务架构的区别"></a>SOA和微服务架构的区别</h1><ul>
<li>微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化。</li>
<li>微服务架构强调的第一个重点就是业务系统需要彻底的组件化和服务化，原有的单个业务系统会拆分为多个可以独立开发，设计，运行和运维的小应用。这些小应用之间通过服务完成交互和集成。每个小应用从前端web ui，到控制层，逻辑层，数据库访问，数据库都完全是独立的一套。在这里我们不用组件而用小应用这个词更加合适，每个小应用除了完成自身本身的业务功能外，重点就是还需要消费外部其它应用暴露的服务，同时自身也将自身的能力朝外部发布为服务。</li>
<li>首先对于应用本身暴露出来的服务，是和应用一起部署的，即服务本身并不单独部署，服务本身就是业务组件已有的接口能力发布和暴露出来的</li>
<li>其次微服务架构本身来源于互联网的思路，因此组件对外发布的服务强调了采用HTTP Rest API的方式来进行。</li>
<li>微服务的基本思想在于考虑围绕着业务领域组件来创建应用，这些就应用可独立地进行开发、管理和加速。在分散的组件中使用微服务云架构和平台使部署、管理和服务功能交付变得更加简单。</li>
</ul>
<h1 id="什么是高可用性"><a href="#什么是高可用性" class="headerlink" title="什么是高可用性"></a>什么是高可用性</h1><ul>
<li>高可用性（HA）系统是目前企业防止核心计算机系统因故障停机的最有效手段。</li>
</ul>
<h1 id="高可用性（HA）的功能"><a href="#高可用性（HA）的功能" class="headerlink" title="高可用性（HA）的功能"></a>高可用性（HA）的功能</h1><ul>
<li>软件故障监测与排除</li>
<li>备份和数据保护</li>
<li>管理站能够监视各站点的运行情况，能随时或定时报告系统运行状况，故障能及时报告和告警，并有必要的控制手段</li>
<li>实现错误隔离以及主、备份服务器间的服务切换</li>
</ul>
<h1 id="HA的工作方式"><a href="#HA的工作方式" class="headerlink" title="HA的工作方式"></a>HA的工作方式</h1><ul>
<li>HA有主从方式和双工方式两种工作模式</li>
<li>高可用性方案则利用更少的冗余部件同时由软件检测故障，一旦故障发生立即隔离损坏部件，通过提供故障恢复实现最大化系统和应用的可用性。</li>
<li>容错技术随着处理器速度的加快和价格的下跌而越来越多地转移到软件中</li>
<li>未来容错技术将完全在软件环境下完成，那时它和高可用性技术之间的差别也就随之消失了。</li>
</ul>
<h1 id="高可用性（HA）系统-需要解决的问题"><a href="#高可用性（HA）系统-需要解决的问题" class="headerlink" title="高可用性（HA）系统-需要解决的问题"></a>高可用性（HA）系统-需要解决的问题</h1><ul>
<li>负载均衡与反向代理</li>
<li>隔离</li>
<li>限流</li>
<li>降级</li>
<li>超时与重试</li>
<li>回滚</li>
<li>压力测试与应急预案</li>
</ul>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul>
<li>负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性</li>
<li>软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，如DNS Load Balance，CheckPoint Firewall-1 ConnectControl等，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。</li>
<li>软件解决方案缺点也较多，因为每台服务器上安装额外的软件运行会消耗系统不定量的资源，越是功能强大的模块，消耗得越多，所以当连接请求特别大的时候，软件本身会成为服务器工作成败的一个关键；软件可扩展性并不是很好，受到操作系统的限制；由于操作系统本身的Bug，往往会引起安全问题。 硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。</li>
</ul>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul>
<li>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li>
<li>代理服务器有三种：<ul>
<li>标准的代理缓冲服务器：一个标准的代理缓冲服务被用于缓存静态的网页（例如：html文件和图片文件等）到本地网络上的一台主机上（即代理服务器）。</li>
<li>透明代理缓冲服务器：透明代理缓冲服务和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。</li>
<li>反向代理缓冲服务器：反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。</li>
</ul>
</li>
<li>安全反向代理用途：<ul>
<li>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。</li>
<li>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息。</li>
<li>安全反向代理会造成各安全连接加密数据所涉及的系统开销而变慢。 SSL 提供了高速缓存机制，连接双方重复使用先前协商的安全参数，大大降低后续连接的系统开销。</li>
</ul>
</li>
</ul>
<h4 id="隔离术"><a href="#隔离术" class="headerlink" title="隔离术"></a>隔离术</h4><ul>
<li>线程隔离:<ul>
<li>线程隔离主要是指线程池隔离，在实际使用时，我们会把请求分类，然后交给不同的线程池处理。当一种业务的请求处理发生问题时，不会将故障扩散到其他线程池，从而保证其他服务可用。</li>
</ul>
</li>
<li>进程隔离<ul>
<li>由于传统的系统所有功能都集中在一个系统中，为了避免系统其中一个模块功能出现问题导致整个系统无法使用的情况发生，将其该系统拆分成多子系统实现物理隔离，故通过进程隔离使得某一个子系统出现问题时不影响到其他子系统。</li>
</ul>
</li>
<li>集群隔离<ul>
<li>随着调用方的增多，当秒杀（并发量特别大功能）类似的服务被刷新会影响到其他服务的稳定性时，应该考虑为秒杀（并发量特别大功能）类似的服务提供单独的服务集群，即分服务分组，这样当某一个分组出现问题时，不会影响到其他分组，从而实现了故障隔离愿景。</li>
</ul>
</li>
<li>机房隔离<ul>
<li>随着对系统可用性的要求，会进行多机房部署，每一个机房的服务都有自己的服务分组，本机房的服务应该只调用本机房的服务，不进行跨机房调用。其中，一个机房服务发生问题时，可以通过DNS&#x2F;负载均衡将请求全部切到另一个机房，或者考虑服务能自动重试其他机房的服务，从而提升系统可用性。</li>
</ul>
</li>
<li>读写隔离<ul>
<li>为了提高数据访问，一般采用redis主从模式将读和写进群分离，在正常情况下，当主redis集群出现问题时，从redis集群还是可以用的，从而不影响用户的访问。</li>
</ul>
</li>
<li>动静隔离<ul>
<li>例如当用户访问如结算页时，如果JS&#x2F;CSS等静态资源也在结算页系统中时，很可能因为访问量太大导致带宽被打满导致出现不可用。为了不影响结算等用户操作的功能，将其JS&#x2F;CSS等静态资源静态化与用户操作功能分开部署。</li>
</ul>
</li>
<li>资源隔离<ul>
<li>最常见的资源如磁盘、CPU、网络；对于宝贵的资源都会存在竞争问题。我们可以使用JIMDB数据同步时要dump数据，SSD盘容量用了50%以上，dump到同一块磁盘时遇到了容量不足的问题，我们通过单独挂一块SAS盘来专门同步数据。还有如使用Docker容器时，有的容器写磁盘非常频繁，因此要考虑为不同的容器挂载不同的磁盘。</li>
</ul>
</li>
</ul>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul>
<li>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流</li>
<li>缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发&#x2F;请求量，即限流。</li>
<li>限流的目的是通过对并发访问&#x2F;请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</li>
<li>一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</li>
</ul>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><ul>
<li>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</li>
<li>降级预案<ul>
<li>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</li>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ul>
</li>
<li>降级按照是否自动化可分为：自动开关降级和人工开关降级。</li>
<li>降级按照功能可分为：读服务降级、写服务降级。</li>
<li>降级按照处于的系统层次可分为：多级降级。</li>
<li>降级的功能点主要从服务端链路考虑，即根据用户访问的服务调用链路来梳理哪里需要降级：页面降级、页面片段降级、页面异步请求降级、服务功能降级、读降级、写降级</li>
<li>自动开关降级：超时降级、统计失败次数降级、故障降级、限流降级</li>
<li>人工开关降级：读服务降级、写服务降级</li>
</ul>
<h4 id="超时与重试"><a href="#超时与重试" class="headerlink" title="超时与重试"></a>超时与重试</h4><ul>
<li>在实际开发过程中，我们见过太多故障时因为没有设置超时或者设置得不对而造成的，而这些故障都是因为没有意识到超时设置的重要性而造成的。如果应用不设置超时，则可能会导致请求响应慢，慢请求积累导致连锁反应，甚至造成应用雪塌。而有些中间件或者框架在超时后进行重试（例如dubbo默认重试两次），读服务天然适合重试，但写服务大多不能重试（如写订单、支付等），重试次数太多会导致多倍请求流量。</li>
<li>例如模拟了Ddos攻击（分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户&#x2F;服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS，通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户&#x2F;服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。），后果可能是灾难，因此，务必设置合理的重试机制，并且应该和熔断、快速失败机制配合。所以在进行代码Review时，一定记得Review超时与重试机制。</li>
</ul>
<h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><ul>
<li>事务回滚<ul>
<li>在执行数据库SQL时，如果我们检测到哦事务提交冲突，那么事务中所有执行的SQL要进行回滚，目的是防止数据库出现数据不一致。</li>
</ul>
</li>
<li>代码库回滚<ul>
<li>在开发项目时一定要将代码维护到代码仓库，从而进行版本管理。有了版本控制系统后可记录代码的历史版本，在出现问题时候可以方便回滚。</li>
</ul>
</li>
<li>部署版本回滚<ul>
<li>代码测试完成后，接下来要进行系统部署，在部署时要考虑当代码逻辑出现错误后如何快速恢复</li>
</ul>
</li>
<li>数据版本回滚<ul>
<li>在设计消息队列时，重要业务会对消息队列进行副本处理，以便万一业务逻辑出现问题能进行历史数据回滚，从而修复问题。</li>
</ul>
</li>
<li>静态资源版本回滚<ul>
<li>静态化页面资源后，每次内容变更时我们都会生成一个全量新版本放到项目的文件目录中，从而保证版本可追溯，出现问题时能及时回滚。</li>
</ul>
</li>
</ul>
<h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><ul>
<li>线下压力测试<ul>
<li>通过如Jmeter，Apac，he ab 压力测试系统的某一个接口等（如登录、查询订单）或者某一个组件（例如数据库连接池），然后进行调优（如调优JVM参数，优化代码等），实现单个接口或者组件的性能最优。</li>
</ul>
</li>
<li>线上压力测试<ul>
<li>线上压力测试份方式非常多，按读分为读压、写压测和混合压测，按照数据仿真度分为仿真压力测试和引流压力测试，按照给用户提供服务分为隔离集群压力测试和线上集群压力测试。</li>
</ul>
</li>
<li>系统优化和容灾<ul>
<li>拿到全面的压力测试报告后，接下来就是分析报告，然后进行一些有这对性的优化，如硬件升级、系统扩容、参数调优、代码优化（代码同步改异步）、架构优化（如加缓存、读写分离、历史数据归档）等。在扩容时也需要考虑容灾，比如分组部署、跨机房部署。容灾是通过部署多组（单机房或多机房）相同系统，当其中一组出现问题时，可以切换到另一个分组，保证系统可用</li>
</ul>
</li>
</ul>
<h4 id="应急预案"><a href="#应急预案" class="headerlink" title="应急预案"></a>应急预案</h4><ul>
<li>在系统压力测试之后发现一些系统瓶颈，在系统优化之后会提升系统吐吞量并降低响应时间，容灾之后的系统可用性得以保障，但还是会存在一些风险，如网络抖动、某台机器负载过高、某个服务变慢、数据库Load值过高，为了防止因为这些问题而出现系统雪崩，需要针对这些情况制定应急预案，从而在出现突发情况时，有响应的措施来解决掉这些问题。</li>
<li>应急预案可按照如下几步进行：首先进行系统分级，然后进行全链路分析、配置监控，最后制定应急预案。</li>
</ul>
<h1 id="高并发系统需要解决的问题"><a href="#高并发系统需要解决的问题" class="headerlink" title="高并发系统需要解决的问题"></a>高并发系统需要解决的问题</h1><ul>
<li>应用缓存</li>
<li>HTTP缓存</li>
<li>多级缓存</li>
<li>池化</li>
<li>异步并发</li>
<li>扩容</li>
<li>队列</li>
</ul>
<h4 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h4><ul>
<li>堆缓存<ul>
<li>使用Java堆内存来存储缓存对象。使用堆缓存的好处是没有序列化&#x2F;反序列化，是最快的缓存。缺点也很明显，当缓存的数据量很大时，GC（垃圾回收）暂停时间会变长，存储容量受限于堆空间大小。一般通过软引用&#x2F;弱引用来存储缓存对象，即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。有Guava Cache、Ehcache 3.x、MapDB实现</li>
</ul>
</li>
<li>堆外缓存<ul>
<li>即缓存数据存储在堆外内存，可以减少GC暂停时间（堆对象转移到堆外，GC扫描和移动的对象变少），但是，读取数据时需要序列化&#x2F;反序列化，因此会比堆缓存要慢很多。有Ehcache 3.x、MapDB实现</li>
</ul>
</li>
<li>磁盘缓存<ul>
<li>即缓存数据存储在磁道上，在JVM重启时数据还存在的，而堆缓存&#x2F;堆外缓存数据会丢失，需要重新加载。有Ehcache 3.x、MapDB实现</li>
</ul>
</li>
<li>分布式缓存<ul>
<li>之前缓存提到是进程内缓存和磁盘缓存，在多JVM实例的情况下，会存在两个问题：<ul>
<li>单机容量问题；</li>
<li>数据一致性问题（多台JVM实例的缓存数据不一致怎么办？），这个问题不用纠结，既然数据允许缓存，则表示允许一定时间内的不一致，因此可以设置缓存数据的过期时间来定期更新数据；</li>
<li>缓存不命中时，需要回源到DB&#x2F;服务请求多变问题：每个实例在缓存不命中的情况下都会回源到DB加载数据，因此多实例后DB整体的访问量变多了解决办法是可以使用如一致性哈希分片算法。因此，这些情况可以考虑使用分布式缓存来解决。可以使用ehcache –clustered(配合 Terracotta server) 实现JAVA进程间分布式缓存。最好的办法是使用redis实现分布式缓存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><ul>
<li>浏览器缓存是指当我们使用浏览器访问一些网站页面或者http服务时，根据服务端返回的缓存设置响应头将响应内容缓存到浏览器，下次可以直接使用缓存内容或者仅需要去服务端验证内容是否过期即可。这样的好处可以减少浏览器和服务端之间来回传输的数据量，节省带宽提升性能。解决办法：内容不需要动态（计算、渲染等）速度更快，内容越接近于用户速度越快。像apache traffic server、squid、varnish、nginx等技术都可以来进行内容缓存。还有CDN就是用来加速用户访问的：即用户首先访问到全国各地的CDN节点（使用如ATS、Squid实现），如果CDN没命中，会回源到中央nginx集群，该集群如果没有命中缓存（该集群的缓存不是必须的，要根据实际命中情况等决定），最后回源到后端应用集群。</li>
</ul>
<h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><ul>
<li>分布式缓存</li>
</ul>
<h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><ul>
<li>在应用系统开发过程中，我们经常会用到池化技术，如对象池、连接池、线程池等，通过池化来减少一些消耗，以提升性能</li>
<li>对象池通过复用对象从而减少创建对象、垃圾回收 的开销。但是，池化不能太大，太大会影响GC时的扫描时间</li>
<li>连接池如数据库连接池、Redis连接池、Http连接池，通过复用TCP连接减少创建和释放连接的时间来提升性能</li>
<li>线程池也是类似的，通过复用线程提升性能。也就是说池化的目的就是通过复用技术提升性能。</li>
</ul>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul>
<li>读写分离：当数据库访问量还不是很大的时候，我们可以适当增加服务器，数据库主从复制的方式将读写分离</li>
<li>垂直分区：当写入操作一旦增加的时候，那么主从数据库将花更多的时间的放在数据同步上，这个时候服务器也是不堪重负的；那么就有了数据的垂直分区，数据的垂直分区思路是将写入操作比较频繁的数据表，如用户表_user,或者订单表_orders,那么我们就可以把这个两个表分离出来，放在不同的服务器，如果这两个表和其他表存在联表查询，那么就只能把原来的sql语句给拆分了，先查询一个表，在查询另一个，虽然说这个会消耗更过性能，但比起那种大量数据同步，负担还是减轻了不少；</li>
<li>水平分区：但是往往事情不尽人意，可能采取垂直分区能撑一段时间，由于网站太火了，访问量又每日100w,一下子蹦到了1000w,这个时候可以采取数据的进行分离，我们可以根据user的Id不同进行分配，如采取%2的形式，或者%10的形式，当然这种形式对以后的扩展有了很大的限制，当我由10个分区增加到20个的时候，所有的数据都得重新分区，那么将是一个的很庞大的计算量；以下提供几种常见的算法：<ul>
<li>哈希算法：就是采用user_id%的方式;</li>
<li>范围：可以根据user_id字符值范围分区，如1-1000为一区，1001-2000则是另一个区等；</li>
<li>映射关系：就是将user_id存在的所对应的分区放在数据库中保存，当用户操作时先去查询所在分区，再进行操作；</li>
</ul>
</li>
</ul>
<h4 id="扩容分布式数据库"><a href="#扩容分布式数据库" class="headerlink" title="扩容分布式数据库"></a>扩容分布式数据库</h4><ul>
<li>分布式数据库（终极方案）：TDSQL架构采用自动扩容机制、分表逻辑、扩容流程、容灾机制、强同步方案解决分布式数据库扩容方案</li>
<li>系统由三个模块组成：Scheduler、Agent、网关，三个模块的交互都是通过ZooKeeper完成，极大简化了各个节点之间的通信机制，相对于第二代HOLD的开发简单了很多。</li>
<li>Scheduler作为集群的管理调度中心，主要功能包括：<ul>
<li>管理set，提供创建、删除set、set内节点替换等工作</li>
<li>所有的DDL操作统一下发和调度</li>
<li>监控set内各个节点的存活状态，当set内主节点故障，发起高一致性主备切换流程</li>
<li>监控各个set的CPU、磁盘容量、各个表的资源消耗情况，必要的时候自动发起扩容流程</li>
<li>Scheduler自身的容灾通过ZooKeqzer的选举机制完成，保证中心控制节点无单点。</li>
</ul>
</li>
<li>Agent模块负责监控本机MySQL实例的运行情况，主要功能包括：<ul>
<li>用短连接的方式周期性访问本机的MySQL实例，检测是否可读、可写，若发生异常，会将异常信息上报到ZooKeeper，最终会由上面描述的Scheduler模块检测到这个异常情况，从而发起容灾切换；</li>
<li>检测主备复制的执行情况，会定期上报主备复制的延时和延迟的事务数，若发生了主备切换，自动向新主机重建主备，因此MySQL的主备不需要DBA干预，对于新增的实例会自动采用xtrabackup通过主机自动重建数据；</li>
<li>检测MySQL实例的CPU利用率和各个表的请求量、数据量、CPU利用率，上报到ZooKeeper，ZooKeeper通过全局的资源情况抉择如何扩容、缩容；监控是否有下发到自身的扩容任务，如有则会执行扩容流程（下面会有描述）；监控是否要发生容灾切换，并按计划执行主备切换流程。</li>
</ul>
</li>
<li>网关基于MySQL Proxy开发，在网络层、连接管理、SQL解析、路由等方面做了大量优化，主要特点和功能如下：<ul>
<li>解析SQL，将识别出的DDL语句直接存到ZooKeeper，让Keeper来统一调度；</li>
<li>Watch ZooKeeper的路由信息，拉取最新的路由表保存到本地文件和内存；</li>
<li>将SQL请求路由到对应的set，支持读写分离；</li>
<li>对接入的IP、用户名、密码进行鉴权；</li>
<li>记录完整的SQL执行信息，与秒级监控平台对接完成实时的SQL请求的时耗，成功率等指标监控分析；</li>
<li>对count、distinct、sum、avg、max、min、order by、group by等聚合类SQL一般需要访问后端的多个set，网关会分析结果并做合并再返回，暂不支持跨set join和分布式事务；</li>
</ul>
</li>
<li>网关无状态，既支持与业务部署到一起，也可以独立部署（可通过TGW或者LVS做容灾）。</li>
</ul>
<h4 id="扩容（-Canal分布式数据库同步系统）"><a href="#扩容（-Canal分布式数据库同步系统）" class="headerlink" title="扩容（ Canal分布式数据库同步系统）"></a>扩容（ Canal分布式数据库同步系统）</h4><ul>
<li>基于Canal开源产品，获取数据库增量日志数据。</li>
<li>典型管理系统架构，manager(web管理)+node(工作节点)<ul>
<li>manager运行时推送同步配置到node节点</li>
<li>node节点将同步状态反馈到manager上</li>
</ul>
</li>
<li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作. 互联网技术高并发-队列应用场景<ul>
<li>异步处理：使用队列的一个主要原因是进行异步处理，比如用户注册完成后，需要发送注册成功邮件&#x2F;新用户积分&#x2F;优惠卷等；缓存过期时，先返回过期数据，然后异步更新缓存、异步写日志等。</li>
<li>系统解耦：比如用户支付完成订单后，需要通知生产配货系统、发票系统、库存系统、推荐系统、搜索系统等进行业务处理。</li>
<li>数据同步：比如想把mysql变更的数据同步到Redis，或者将mysql数据同步到mongodb,或者让机房之间的数据同步，或者主从数据同步等，有相关软件：databus、canal、otter等。使用数据总线队列进行数据同步的好处是可以保证数据修改的有序。</li>
<li>流量削峰：系统的瓶颈一般在数据库上，比如扣减库存、下单等，此时可以考虑使用队列将变更请求暂时放入队列，通过缓存+队列暂存的方式将数据库流量削峰。同样，对于秒杀系统，下单服务会是该系统的瓶颈，此时可以使用队列进行排队和限流，从而保护下单服务，通过队列暂存或者队列限流进行流量削峰</li>
</ul>
</li>
</ul>
<h4 id="队列（-Canal-）"><a href="#队列（-Canal-）" class="headerlink" title="队列（ Canal ）"></a>队列（ Canal ）</h4><ul>
<li>Canal 同步缓存</li>
<li>Canal 下发任务给消息队列</li>
</ul>
]]></content>
      <categories>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>HA</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/publishes/54eea449909d.html</url>
    <content><![CDATA[<h1 id="xml有哪些解析技术-区别是什么"><a href="#xml有哪些解析技术-区别是什么" class="headerlink" title="xml有哪些解析技术?区别是什么?"></a>xml有哪些解析技术?区别是什么?</h1><ul>
<li>有DOM，SAX，STAX等</li>
<li>DOM<ul>
<li>处理大型文件时其性能下降的非常厉害</li>
<li>这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存，适合对XML的随机访问</li>
</ul>
</li>
<li>SAX<ul>
<li>SAX是事件驱动型的XML解析方式</li>
<li>它顺序读取XML文件，不需要一次全部装载整个文件</li>
<li>当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问</li>
</ul>
</li>
<li>STAX<ul>
<li>Streaming API for XML (StAX)</li>
</ul>
</li>
</ul>
<h1 id="你在项目中用到了xml技术的哪些方面-如何实现的"><a href="#你在项目中用到了xml技术的哪些方面-如何实现的" class="headerlink" title="你在项目中用到了xml技术的哪些方面?如何实现的?"></a>你在项目中用到了xml技术的哪些方面?如何实现的?</h1><ul>
<li>用到了数据存贮，信息配置两方面</li>
<li>在做数据交换平台时，将数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理</li>
<li>在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中</li>
</ul>
<h1 id="XML文档定义有几种形式？它们之间有何本质区别？"><a href="#XML文档定义有几种形式？它们之间有何本质区别？" class="headerlink" title="XML文档定义有几种形式？它们之间有何本质区别？"></a>XML文档定义有几种形式？它们之间有何本质区别？</h1><ul>
<li>两种形式：dtd和schema</li>
<li>本质区别：schema本身是xml的，可以被XML解析器解析，这也是从DTD上发展schema的根本目的</li>
</ul>
]]></content>
      <categories>
        <category>序列化</category>
      </categories>
      <tags>
        <tag>序列化</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/publishes/3aaab7406978.html</url>
    <content><![CDATA[<h1 id="说明缓冲流的优点和原理"><a href="#说明缓冲流的优点和原理" class="headerlink" title="说明缓冲流的优点和原理"></a>说明缓冲流的优点和原理</h1><ul>
<li>不带缓冲的流的工作原理：它读取到一个字节&#x2F;字符，就向用户指定的路径写出去，读一个写一个，所以就慢了。</li>
<li>带缓冲的流的工作原理：读取到一个字节&#x2F;字符，先不输出，等凑足了缓冲的最大容量后一次性写出去，从而提高了工作效率</li>
<li>优点：减少对硬盘的读取次数，降低对硬盘的损耗。</li>
</ul>
<h1 id="列举常用字节输入流和输出流并说明其特点，至少5对。"><a href="#列举常用字节输入流和输出流并说明其特点，至少5对。" class="headerlink" title="列举常用字节输入流和输出流并说明其特点，至少5对。"></a>列举常用字节输入流和输出流并说明其特点，至少5对。</h1><ul>
<li>FileInputStream 从文件系统中的某个文件中获得输入字节。</li>
<li>FileOutputStream 从程序当中的数据，写入到指定文件。</li>
<li>ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。</li>
<li>ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪 read 方法要提供的下一个字节。</li>
<li>FilterInputStream 包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。FilterInputStream 类本身只是简单地重写那些将所有请求传递给所包含输入流的 InputStream 的所有方法。FilterInputStream 的子类可进一步重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</li>
<li>StringBufferInputStream此类允许应用程序创建输入流，在该流中读取的字节由字符串内容提供。应用程序还可以使用ByteArrayInputStream 从 byte 数组中读取字节。 只有字符串中每个字符的低八位可以由此类使用。ByteArrayOutputStream此类实现了一个输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</li>
<li>FileOutputStream文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。文件是否可用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。</li>
<li>FilterOutputStream类是过滤输出流的所有类的超类。这些流位于已存在的输出流（基础 输出流）之上，它们将已存在的输出流作为其基本数据接收器，但可能直接传输数据或提供一些额外的功能。 FilterOutputStream 类本身只是简单地重写那些将所有请求传递给所包含输出流的 OutputStream 的所有方法。FilterOutputStream 的子类可进一步地重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</li>
<li>ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。</li>
<li>PipedOutputStream可以将管道输出流连接到管道输入流来创建通信管道。管道输出流是管道的发送端。通常，数据由某个线程写入 PipedOutputStream 对象，并由其他线程从连接的 PipedInputStream 读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于毁坏状态。</li>
</ul>
<h1 id="字符流字节流联系区别；什么时候使用字节流和字符流"><a href="#字符流字节流联系区别；什么时候使用字节流和字符流" class="headerlink" title="字符流字节流联系区别；什么时候使用字节流和字符流?"></a>字符流字节流联系区别；什么时候使用字节流和字符流?</h1><ul>
<li>字符流和字节流是流的一种划分，按处理照流的数据单位进行的划分</li>
<li>两类都分为输入和输出操作</li>
<li>在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。这四个都是抽象类。</li>
<li>字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组</li>
<li>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的编码来处理，也就是要进行字符集的转化 这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联的。</li>
</ul>
<h1 id="输入流和输出流联系和区别，节点流和处理流联系和区别"><a href="#输入流和输出流联系和区别，节点流和处理流联系和区别" class="headerlink" title="输入流和输出流联系和区别，节点流和处理流联系和区别"></a>输入流和输出流联系和区别，节点流和处理流联系和区别</h1><ul>
<li>流就像管道一样，在程序和文件之间，输入输出的方向是针对程序而言，向程序中读入东西，就是输入流，从程序中向外读东西，就是输出流。</li>
<li>输入流是得到数据，输出流是输出数据，而节点流，处理流是流的另一种划分，按照功能不同进行的划分</li>
<li>节点流，可以从或向一个特定的地方(节点)读写数据</li>
<li>处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader</li>
<li>处理流的构造方法总是要带一个其他的流对象做参数</li>
<li>一个流对象经过其他流的多次包装，称为流的链接。</li>
</ul>
<h1 id="I-O-流两种流（字符、字节）、四个接口："><a href="#I-O-流两种流（字符、字节）、四个接口：" class="headerlink" title="I&#x2F;O 流两种流（字符、字节）、四个接口："></a>I&#x2F;O 流两种流（字符、字节）、四个接口：</h1><ul>
<li>Read&#x2F;Write，Input&#x2F;Output</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket</title>
    <url>/publishes/4181b8cf024e.html</url>
    <content><![CDATA[<h1 id="什么是Socket编程"><a href="#什么是Socket编程" class="headerlink" title="什么是Socket编程"></a>什么是Socket编程</h1><ul>
<li>所谓socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄</li>
<li>应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</li>
<li>我们开发的网络应用程序位于应用层，TCP和UDP属于传输层协议，在应用层如何使用传输层的服务呢？在应用层和传输层之间，则是使用套接字来进行分离。</li>
<li>套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者接收远程发来的数据；而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次的工作。</li>
<li>Socket实际是传输层供给应用层的编程接口。传输层则在网络层的基础上提供进程到进程问的逻辑通道，而应用层的进程则利用传输层向另一台主机的某一进程通信。Socket就是应用层与传输层之间的桥梁</li>
<li>使用Socket编程可以开发客户机和服务器应用程序，可以在本地网络上进行通信，也可通过Internet在全球范围内通信</li>
</ul>
<h1 id="简述基于TCP和UDP的Socket编程的主要步骤"><a href="#简述基于TCP和UDP的Socket编程的主要步骤" class="headerlink" title="简述基于TCP和UDP的Socket编程的主要步骤"></a>简述基于TCP和UDP的Socket编程的主要步骤</h1><ul>
<li>Java分别为TCP和UDP 两种通信协议提供了相应的Socket编程类，这些类存放在java.net包中</li>
<li>与TCP对应的是服务器的ServerSocket和客户端的Socket，与UDP对应的是DatagramSocket。</li>
<li>基于TCP创建的套接字可以叫做流套接字，服务器端相当于一个监听器，用来监听端口</li>
<li>服务器与客服端之间的通讯都是输入输出流来实现的</li>
<li>基于UDP的套接字就是数据报套接字，两个都要先构造好相应的数据包。</li>
</ul>
<h4 id="基于TCP协议的Socket编程的主要步骤"><a href="#基于TCP协议的Socket编程的主要步骤" class="headerlink" title="基于TCP协议的Socket编程的主要步骤"></a>基于TCP协议的Socket编程的主要步骤</h4><h5 id="服务器端（server）"><a href="#服务器端（server）" class="headerlink" title="服务器端（server）"></a>服务器端（server）</h5><ul>
<li>构建一个ServerSocket实例，指定本地的端口。这个socket就是用来监听指定端口的连接请求的。</li>
<li>重复如下几个步骤：<ul>
<li>调用socket的accept()方法来获得下面客户端的连接请求。通过accept()方法返回的socket实例，建立了一个和客户端的新连接。</li>
<li>通过这个返回的socket实例获取InputStream和OutputStream,可以通过这两个stream来分别读和写数据。</li>
<li>结束的时候调用socket实例的close()方法关闭socket连接。</li>
</ul>
</li>
</ul>
<h5 id="客户端（client）"><a href="#客户端（client）" class="headerlink" title="客户端（client）"></a>客户端（client）</h5><ul>
<li>构建Socket实例，通过指定的远程服务器地址和端口来建立连接。</li>
<li>通过Socket实例包含的InputStream和OutputStream来进行数据的读写。</li>
<li>操作结束后调用socket实例的close方法，关闭</li>
</ul>
<h4 id="基于UDP协议的Socket编程的主要步骤"><a href="#基于UDP协议的Socket编程的主要步骤" class="headerlink" title="基于UDP协议的Socket编程的主要步骤"></a>基于UDP协议的Socket编程的主要步骤</h4><h5 id="服务器端（server）-1"><a href="#服务器端（server）-1" class="headerlink" title="服务器端（server）"></a>服务器端（server）</h5><ul>
<li>构造DatagramSocket实例，指定本地端口。</li>
<li>通过DatagramSocket实例的receive方法接收DatagramPacket.DatagramPacket中间就包含了通信的内容。</li>
<li>通过DatagramSocket的send和receive方法来收和发DatagramPacket.</li>
</ul>
<h5 id="客户端（client）-1"><a href="#客户端（client）-1" class="headerlink" title="客户端（client）"></a>客户端（client）</h5><ul>
<li>构造DatagramSocket实例。</li>
<li>通过DatagramSocket实例的send和receive方法发送DatagramPacket报文。</li>
<li>结束后，调用DatagramSocket的close方法关闭。</li>
</ul>
<h1 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h1><ul>
<li>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</li>
<li>WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</li>
<li>WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</li>
<li>单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</li>
<li>Light -与 http 相比，WebSocket 消息数据交换要轻得多。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/publishes/a36cfa964151.html</url>
    <content><![CDATA[<h1 id="Java反射技术主要实现类有哪些，作用分别是什么？"><a href="#Java反射技术主要实现类有哪些，作用分别是什么？" class="headerlink" title="Java反射技术主要实现类有哪些，作用分别是什么？"></a>Java反射技术主要实现类有哪些，作用分别是什么？</h1><ul>
<li>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中</li>
<li>Class类：代表一个类</li>
<li>Field 类：代表类的成员变量(属性)</li>
<li>Method类：代表类的成员方法</li>
<li>Constructor 类：代表类的构造方法</li>
<li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li>
</ul>
<h1 id="反射的使用场合和作用、及其优缺点"><a href="#反射的使用场合和作用、及其优缺点" class="headerlink" title="反射的使用场合和作用、及其优缺点"></a>反射的使用场合和作用、及其优缺点</h1><ul>
<li>使用场合：在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息。</li>
<li>主要作用：通过反射可以使程序代码访问装载到JVM 中的类的内部信息，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息</li>
<li>反射的优点：反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类；反射是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的。Java反射技术应用领域很广，如软件测试、 EJB、JavaBean等；许多流行的开源框架例如Struts、Hibernate、Spring在实现过程中都采用了该技术</li>
<li>反射的缺点<ul>
<li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。</li>
<li>使用反射会模糊程序内部逻辑：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。</li>
</ul>
</li>
</ul>
<h1 id="Java-反射机制的作用？"><a href="#Java-反射机制的作用？" class="headerlink" title="Java 反射机制的作用？"></a>Java 反射机制的作用？</h1><ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
</ul>
<h1 id="JAVA-反射"><a href="#JAVA-反射" class="headerlink" title="JAVA 反射"></a>JAVA 反射</h1><h4 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h4><ul>
<li>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。</li>
</ul>
<h4 id="反射机制概念-（运行状态中知道类所有的属性和方法）"><a href="#反射机制概念-（运行状态中知道类所有的属性和方法）" class="headerlink" title="反射机制概念 （运行状态中知道类所有的属性和方法）"></a>反射机制概念 （运行状态中知道类所有的属性和方法）</h4><ul>
<li>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；</li>
<li>并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</li>
</ul>
<h4 id="反射的应用场合"><a href="#反射的应用场合" class="headerlink" title="反射的应用场合"></a>反射的应用场合</h4><ul>
<li>编译时类型和运行时类型</li>
<li>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：Person p&#x3D;new Student();其中编译时类型为 Person，运行时类型为 Student。的编译时类型无法获取具体方法程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。</li>
<li>然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</li>
</ul>
<h1 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h1><ul>
<li>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架</li>
<li>Java反射的主要功能：<ul>
<li>确定一个对象的类</li>
<li>取出类的modifiers,数据成员,方法,构造器,和超类.</li>
<li>找出某个接口里定义的常量和方法说明.</li>
<li>创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).</li>
<li>取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.</li>
<li>在运行时刻调用动态对象的方法.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/publishes/73098ee3eeb0.html</url>
    <content><![CDATA[<h1 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h1><ul>
<li>Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。</li>
<li>Java中还有一个Collections类，专门用来操作集合类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li>
</ul>
<h1 id="集合和数组的比较（为什么引入集合）"><a href="#集合和数组的比较（为什么引入集合）" class="headerlink" title="集合和数组的比较（为什么引入集合）"></a>集合和数组的比较（为什么引入集合）</h1><ul>
<li>数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框架类可适用于不同场合</li>
<li>具体如下：<ul>
<li>数组的效率高于集合类.</li>
<li>数组能存放基本数据类型和对象，而集合类中只能放对象。</li>
<li>数组容量固定且无法动态改变，集合类容量动态改变。</li>
<li>数组无法判断其中实际存有多少元素，length只告诉了array的容量。</li>
<li>集合有多种实现方式和不同的适用场合，而不像数组仅采用顺序表方式。</li>
<li>集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。</li>
</ul>
</li>
</ul>
<h1 id="TreeSet的原理和使用"><a href="#TreeSet的原理和使用" class="headerlink" title="TreeSet的原理和使用"></a>TreeSet的原理和使用</h1><ul>
<li>TreeSet集合，元素不允许重复且有序(自然顺序)</li>
<li>TreeSet采用树结构存储数据，存入元素时需要和树中元素进行对比，需要指定比较策略。</li>
<li>可以通过Comparable(外部比较器)和Comparator(内部比较器)来指定比较策略，实现了Comparable的系统类可以顺利存入TreeSet。自定义类可以实现Comparable接口来指定比较策略。</li>
<li>可创建Comparator接口实现类来指定比较策略，并通过TreeSet构造方法参数传入。这种方式尤其对系统类非常适用。</li>
</ul>
<h1 id="HashSet的使用和原理"><a href="#HashSet的使用和原理" class="headerlink" title="HashSet的使用和原理"></a>HashSet的使用和原理</h1><ul>
<li>哈希表的查询速度特别快，时间复杂度为O（1）。</li>
<li>HashMap、Hashtable、HashSet这些集合采用的是哈希表结构，需要用到hashCode哈希码，hashCode是一个整数值。</li>
<li>系统类已经覆盖了hashCode方法 自定义类如果要放入hash类集合，必须重写hashcode。如果不重写，调用的是Object的hashcode，而Object的hashCode实际上是地址。</li>
<li>向哈希表中添加数据的原理：当向集合Set中增加对象时，首先集合计算要增加对象的hashCode码，根据该值来得到一个位置用来存放当前对象，如在该位置没有一个对象存在的话，那么集合Set认为该对象在集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接着将准备增加到集合中的对象与该位置上的对象进行equals方法比较，如果该equals方法返回false,那么集合认为集合中不存在该对象，在进行一次散列，将该对象放到散列后计算出的新地址里。如果equals方法返回true，那么集合认为集合中已经存在该对象了，不会再将该对象增加到集合中了。</li>
<li>在哈希表中判断两个元素是否重复要使用到hashCode()和equals()。hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。</li>
<li>Y&#x3D;K(X) ：K是函数，X是哈希码，Y是地址</li>
</ul>
<h1 id="ArrayList和LinkedList的区别和联系"><a href="#ArrayList和LinkedList的区别和联系" class="headerlink" title="ArrayList和LinkedList的区别和联系"></a>ArrayList和LinkedList的区别和联系</h1><ul>
<li>相同点：两者都实现了List接口，都具有List中元素有序、不唯一的特点。</li>
<li>不同点：ArrayList实现了长度可变的数组，在内存中分配连续空间。遍历元素和随机访问元素的效率比较高；LinkedList采用链表存储方式。插入、删除元素时效率比较高</li>
</ul>
<h1 id="HashMap和Hashtable的区别和联系"><a href="#HashMap和Hashtable的区别和联系" class="headerlink" title="HashMap和Hashtable的区别和联系"></a>HashMap和Hashtable的区别和联系</h1><ul>
<li>相同点：实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</li>
<li>不同点：<ul>
<li>Hashtable是早期提供的接口，HashMap是新版JDK提供的接口</li>
<li>Hashtable继承Dictionary类，HashMap实现Map接口</li>
<li>Hashtable线程安全，HashMap线程非安全</li>
<li>Hashtable不允许null值，HashMap允许null值</li>
</ul>
</li>
</ul>
<h1 id="Vector和ArrayList的区别和联系"><a href="#Vector和ArrayList的区别和联系" class="headerlink" title="Vector和ArrayList的区别和联系"></a>Vector和ArrayList的区别和联系</h1><ul>
<li>相同点：<ul>
<li>实现原理相同—底层都使用数组</li>
<li>功能相同—实现增删改查等操作的方法相似</li>
<li>都是长度可变的数组结构，很多情况下可以互用</li>
</ul>
</li>
<li>不同点：<ul>
<li>Vector是早期JDK接口，ArrayList是替代Vector的新接口</li>
<li>Vector线程安全，ArrayList重速度轻安全，线程非安全</li>
<li>长度需增长时，Vector默认增长一倍，ArrayList增长50%</li>
</ul>
</li>
</ul>
<h1 id="Java集合体系结构"><a href="#Java集合体系结构" class="headerlink" title="Java集合体系结构"></a>Java集合体系结构</h1><ul>
<li>Collection 接口存储一组不唯一，无序的对象</li>
<li>List 接口存储一组不唯一，有序（插入顺序）的对象</li>
<li>Set 接口存储一组唯一，无序的对象</li>
<li>Map接口存储一组键值对象，提供key到value的映射。Key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</li>
</ul>
<h1 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h1><ul>
<li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li>
<li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</li>
<li>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li>
</ul>
<h1 id="List、Map、Set-三个接口，存取元素时，各有什么特点？"><a href="#List、Map、Set-三个接口，存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set 三个接口，存取元素时，各有什么特点？"></a>List、Map、Set 三个接口，存取元素时，各有什么特点？</h1><ul>
<li>List以特定索引来存取元素，可有重复元素。</li>
<li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）</li>
<li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一</li>
<li>Set和Map容器都有基于哈希存储和排序树（红黑树）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</li>
</ul>
<p> </p>
<h1 id="说出ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#说出ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="说出ArrayList、Vector、LinkedList 的存储性能和特性？"></a>说出ArrayList、Vector、LinkedList 的存储性能和特性？</h1><ul>
<li>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。</li>
<li>遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖）。同理，Stack类继承Vector也是不正确的。</li>
</ul>
<p> </p>
<h1 id="List、Set、Map-是否继承自-Collection-接口？"><a href="#List、Set、Map-是否继承自-Collection-接口？" class="headerlink" title="List、Set、Map 是否继承自 Collection 接口？"></a>List、Set、Map 是否继承自 Collection 接口？</h1><ul>
<li>List、Set 的父接口是 Collection，Map 不是其子接口，而是与Collection 接口是平行关系，互不包含。</li>
<li>Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</li>
</ul>
<h1 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的-sort（）方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的-sort（）方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？</h1><ul>
<li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li>
<li>TreeMap 要求存放的键值对映射的键必须实现 Comparable接口从而根据键对元素进行排序</li>
<li>Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li>
</ul>
<h1 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?</h1><ul>
<li>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。</li>
<li>equals()和&#x3D;&#x3D;方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值</li>
</ul>
<h1 id="List-和-Map-区别"><a href="#List-和-Map-区别" class="headerlink" title="List 和 Map 区别?"></a>List 和 Map 区别?</h1><ul>
<li>一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复</li>
<li>Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</li>
</ul>
<h1 id="你是怎么理解-java-的泛型的？"><a href="#你是怎么理解-java-的泛型的？" class="headerlink" title="你是怎么理解 java 的泛型的？"></a>你是怎么理解 java 的泛型的？</h1><ul>
<li>在 Java SE 1.5 之前，没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</li>
<li>泛型是 Java SE 1.5 的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</li>
</ul>
<h1 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h1><ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li>
<li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h1 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h1><ul>
<li>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接口,每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合的元素进行迭代操作. 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除.</li>
</ul>
<h1 id="为什么集合类没有实现-Cloneable-和-Serializable-接口？"><a href="#为什么集合类没有实现-Cloneable-和-Serializable-接口？" class="headerlink" title="为什么集合类没有实现 Cloneable 和 Serializable 接口？"></a>为什么集合类没有实现 Cloneable 和 Serializable 接口？</h1><ul>
<li>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</li>
<li>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。</li>
<li>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化</li>
</ul>
<h1 id="Java-集合类框架的基本接口有哪些？"><a href="#Java-集合类框架的基本接口有哪些？" class="headerlink" title="Java 集合类框架的基本接口有哪些？"></a>Java 集合类框架的基本接口有哪些？</h1><ul>
<li>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</li>
<li>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基本的接口有：<ul>
<li>Collection：代表一组对象，每一个对象都是它的子元素。</li>
<li>Set：不包含重复元素的 Collection。</li>
<li>List：有顺序的 collection，并且可以包含重复元素。</li>
<li>Map：可以把键(key)映射到值(value)的对象，键不能重复。</li>
</ul>
</li>
</ul>
<h1 id="ArrayList-是否会越界？"><a href="#ArrayList-是否会越界？" class="headerlink" title="ArrayList 是否会越界？"></a>ArrayList 是否会越界？</h1><ul>
<li>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构</li>
<li>对于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList并发 add()可能出现数组下标越界异常</li>
</ul>
<h1 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？"><a href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？"></a>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</h1><ul>
<li>Array 和 ArrayList 的不同点：<ul>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li>
<li>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li>
</ul>
</li>
</ul>
<h1 id="Map、Set、List、Queue、Stack的特点与用法。"><a href="#Map、Set、List、Queue、Stack的特点与用法。" class="headerlink" title="Map、Set、List、Queue、Stack的特点与用法。"></a>Map、Set、List、Queue、Stack的特点与用法。</h1><ul>
<li>Map map集合，k-v键值对存储</li>
<li>HashTable 和 HashMap 是 Map 的实现类   </li>
<li>HashTable 是线程安全的，不能存储 null 值   </li>
<li>HashMap 不是线程安全的，可以存储 null 值  </li>
<li>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。</li>
<li>Set 集合，无序，不重复</li>
<li>List 数组集合，ArrayList ， Vector ， LinkedList 是 List 的实现类</li>
<li>ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的</li>
<li>LinkedList 是线程不安全的，底层是由链表实现的   </li>
<li>Queue 队列，提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。</li>
<li>Stack 栈，继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate</title>
    <url>/publishes/b1378143ed59.html</url>
    <content><![CDATA[<h1 id="介绍一下-Hibernate-的缓存"><a href="#介绍一下-Hibernate-的缓存" class="headerlink" title="介绍一下 Hibernate 的缓存"></a>介绍一下 Hibernate 的缓存</h1><h4 id="为什么要用-Hibernate-缓存？"><a href="#为什么要用-Hibernate-缓存？" class="headerlink" title="为什么要用 Hibernate 缓存？"></a>为什么要用 Hibernate 缓存？</h4><ul>
<li>Hibernate 是一种持久化层框架，经常访问物理数据库。</li>
<li>为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。</li>
<li>为了提高访问速度，把磁盘或者数据库访问变成内存访问</li>
</ul>
<h4 id="Hibernate-缓存原理是怎样的？"><a href="#Hibernate-缓存原理是怎样的？" class="headerlink" title="Hibernate 缓存原理是怎样的？"></a>Hibernate 缓存原理是怎样的？</h4><ul>
<li>Hibernate 缓存包括两大类：Hibernate一级缓存和 Hibernate 二级缓存</li>
</ul>
<h1 id="Hibernate-一级缓存又称为”session-的缓存”。"><a href="#Hibernate-一级缓存又称为”session-的缓存”。" class="headerlink" title="Hibernate 一级缓存又称为”session 的缓存”。"></a>Hibernate 一级缓存又称为”session 的缓存”。</h1><ul>
<li>session 缓存内置不能被卸载，session 的缓存是事务范围的缓存(session 对象的生命周期通常对应一个数据库事务或者一个应用事务)。</li>
<li>一级缓存中，持久化类的每个实例都具有唯一的 OID</li>
</ul>
<h1 id="Hibernate-的二级缓存又称为”sessionFactory-的缓存”。"><a href="#Hibernate-的二级缓存又称为”sessionFactory-的缓存”。" class="headerlink" title="Hibernate 的二级缓存又称为”sessionFactory 的缓存”。"></a>Hibernate 的二级缓存又称为”sessionFactory 的缓存”。</h1><ul>
<li>由于 sessionFactory 对象的生命周期和应用程序的整个过程对应，因此 Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。</li>
<li>第二级缓存是可选的，是一个可配置的插件，默认下 sessionFactory 不会启用这个插件。</li>
<li>什么样的数据适合存放到二级缓存中？<ul>
<li>很少被修改的数据 (帖子的最后回复时间)</li>
<li>经常被查询的数据 (电商的地点)</li>
<li>不是很重要的数据，允许出现偶尔并发的数据</li>
<li>不会被并发访问的数据</li>
<li>常量数据</li>
</ul>
</li>
<li>Hibernate 的二级缓存默认是不支持分布式缓存的，使用 memcache，redis等中央缓存来代替二级缓存</li>
</ul>
<h1 id="Hibernate-对象的状态"><a href="#Hibernate-对象的状态" class="headerlink" title="Hibernate 对象的状态"></a>Hibernate 对象的状态</h1><ul>
<li>临时状态&#x2F;瞬时状态(transient)：刚刚用 new 语句创建，没有被持久化，无 id，不处于 session 中(没有使用 session 的方法去操作临时对象)，该对象成为临时对象持久化状态，</li>
<li>托管状态(persistent)：已经被持久化，加入 session 的缓存中，session是没有关闭该状态的对象为持久化对象。</li>
<li>游离状态，脱管状态(detached)：已经被持久化，但不处于 session 中，该状态的对象为游离对象。</li>
<li>删除状态(removed)：对象有关联的 id，并且在 session 管理下，但是已经被计划(事务提交的时候，commit)删除，如果没有事务就不能删除相互转换</li>
</ul>
<h1 id="Session-的-save-、update-、merge-、lock-、saveOrUpdate-和-persist-方法有什么区别？"><a href="#Session-的-save-、update-、merge-、lock-、saveOrUpdate-和-persist-方法有什么区别？" class="headerlink" title="Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？"></a>Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？</h1><ul>
<li>Hibernate 的对象有三种状态：瞬态、持久态和游离态</li>
<li>游离状态的实例可以通过调用 save()、persist()或者 saveOrUpdate()方法进行持久化；脱管状态的实例可以通过调用 update()、0saveOrUpdate()、lock()或者 replicate()进行持久化</li>
<li>save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()或 merge()会引发 UPDATE 语句</li>
<li>save()和 update()的区别在于一个是将瞬态对象变成持久态，一个是将游离态对象变为持久态。</li>
<li>merge 方法可以完成 save()和 update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象</li>
<li>按照官方文档的说明<ul>
<li>persist()方法把一个瞬态的实例持久化，但是并”不保证”标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到 flush 的时间</li>
<li>persist”保证”，当它在一个事务外部被调用的时候并不触发一个 Insert 语句，当需要封装一个长会话流程的时候，一个 persist 这样的函数是需要的</li>
<li>save”不保证”第 2 条,它要返回标识符，所以它会立即执行 Insert 语句，不管是不是在事务内部还是外部</li>
<li>update()方法是把一个已经更改过的脱管状态的对象变成持久状态</li>
<li>lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。</li>
</ul>
</li>
</ul>
<h1 id="Session-的-load-和-get-方法的区别是什么？"><a href="#Session-的-load-和-get-方法的区别是什么？" class="headerlink" title="Session 的 load 和 get 方法的区别是什么？"></a>Session 的 load 和 get 方法的区别是什么？</h1><ul>
<li>主要有以下三项区别：<ul>
<li>如果没有找到符合条件的记录, get 方法返回 null,load 方法抛出异常</li>
<li>get 方法直接返回实体类对象, load 方法返回实体类对象的代理</li>
<li>在 Hibernate 3 之前，get 方法只在一级缓存(内部缓存)中进行数据查找, 如果没有找到对应的数据则越过二级缓存, 直接发出 SQL 语句完成数据读取; load 方法则可以充分利用二级缓存中的现有数据；当然从 Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的</li>
</ul>
</li>
<li>简单的说，对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过 get()方法去取的数据可以不存在。</li>
</ul>
<h1 id="SessionFactory-是线程安全的吗？Session-是线程安全的吗，两个线程能够共享同一个-Session-吗？"><a href="#SessionFactory-是线程安全的吗？Session-是线程安全的吗，两个线程能够共享同一个-Session-吗？" class="headerlink" title="SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？"></a>SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？</h1><ul>
<li>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将 SessionFactory 通过单例的模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。</li>
<li>Session 是由 SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的 session，可以使用 ThreadLocal 来取得当前的 session，无论你调用多少次 getCurrentSession()方法，返回的都是同一个 session。</li>
</ul>
<h1 id="Hibernate与JDBC的区别"><a href="#Hibernate与JDBC的区别" class="headerlink" title="Hibernate与JDBC的区别"></a>Hibernate与JDBC的区别</h1><ul>
<li>hibernate和jdbc主要区别就是，hibernate先检索缓存中的映射对象( 即hibernate操作的是对象)，而jdbc则是直接操作数据库.</li>
<li>Hibernate是JDBC的轻量级的对象封装，它是一个独立的对象持久层框架。Hibernate可以用在任何JDBC可以使用的场合</li>
<li>Hibernate是一个和JDBC密切关联的框架，所以Hibernate的兼容性和JDBC驱动，和数据库都有一定的关系，但是和使用它的Java程序，和App Server没有任何关系，也不存在兼容性问题。</li>
<li>如果正确的使用JDBC技术,它的执行效率一定比hibernate要好,因为hibernate是基于jdbc的技术.</li>
<li>JDBC使用的是SQL语句，Hibernate使用的是HQL语句，但是HQL语句最终还会隐式转换成SQL语句执行。</li>
</ul>
<h1 id="Hibernate中的两大配置文件"><a href="#Hibernate中的两大配置文件" class="headerlink" title="Hibernate中的两大配置文件"></a>Hibernate中的两大配置文件</h1><ul>
<li>*.hbm.xml：主键生成策略，映射关系，一对多，一对一的关系。</li>
<li>Hibernate.cfg.xml：方言(用哪个数据库)，数据库连接信息，包含*.hbm.xml内容，映射文件，也可以配事务。</li>
</ul>
<h1 id="Hibernate事务处理"><a href="#Hibernate事务处理" class="headerlink" title="Hibernate事务处理"></a>Hibernate事务处理</h1><ul>
<li>开启事务 session.beginTransaction();</li>
<li>执行相关的操作，如果成功则session.getTransaction().commit();</li>
<li>执行操作失败则 session.getTransaction.rollback();</li>
</ul>
<h1 id="Hibernate五大核心（类-接口）简述"><a href="#Hibernate五大核心（类-接口）简述" class="headerlink" title="Hibernate五大核心（类&#x2F;接口）简述"></a>Hibernate五大核心（类&#x2F;接口）简述</h1><ul>
<li>Configuration接口的作用是对Hibernate进行配置，以及对它进行启动。（加载		hibernate.cfg.xml）并创建一个SessionFactory对象。</li>
<li>SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建		Session对象。SessionFactory是线程安全的。</li>
<li>Session接口<ul>
<li>Session（会话）接口是Hibernate应用使用的主要接口。Session接口负责执行被持久化对象的CRUD操作(增删改查)。Session对象是非线程安全的。Session 相当于jdbc的connection</li>
</ul>
</li>
<li>Query与Criteria接口<ul>
<li>总之Query和Criteria接口负责执行各种数据库查询。</li>
</ul>
</li>
<li>Transaction接口<ul>
<li>Transaction（事务）负责操作相关的事务。</li>
</ul>
</li>
</ul>
<h1 id="Hibernate的运行原理"><a href="#Hibernate的运行原理" class="headerlink" title="Hibernate的运行原理"></a>Hibernate的运行原理</h1><ul>
<li>首先通过configuration去加载hibernate.cfg.xml这个配置文件，根据配置文件的信息去创建sessionFactory,sessionFactory是线程安全的，是一个session工厂，用来创建session,session是线程不安全的，相当于jdbc的connection，最后通过session去进行数据库的各种操作，在进行操作的时候通过transaction进行事务的控制。</li>
</ul>
<h1 id="Hibernate、Ibatis、Jdbc三者的区别"><a href="#Hibernate、Ibatis、Jdbc三者的区别" class="headerlink" title="Hibernate、Ibatis、Jdbc三者的区别"></a>Hibernate、Ibatis、Jdbc三者的区别</h1><ul>
<li>Hibernate属于全自动， Ibatis属于半自动，Jdbc属于手动，从开发效率上讲hibernate较高，ibatis居中，jdbc较低，从执行效率上讲hibernate较低，ibatis居中，jdbc较高，因为jdbc是手工写sql语句，程序员对sql的控制能力更大，可以根据业务需要进行优化，而ibatis虽然也可以对sql进行优化，但是他里面将resultset封装为实体的过程中采用了反射机制所以一定程度上影响了性能，而hibernate因为高度封装所以开发效率相对较高，但正因为这个原因，所以程序员在对sql语句的控制和优化方面相对比较弱，而且在将resultset封装成实体的过程中也采用了反射机制，所以在性能方面较低</li>
</ul>
<h1 id="Hibernate-中get-和-load的区别"><a href="#Hibernate-中get-和-load的区别" class="headerlink" title="Hibernate 中get 和 load的区别"></a>Hibernate 中get 和 load的区别</h1><ul>
<li>加载方式：<ul>
<li>load为延迟加载(返回的是一个只有id属性的代理,只有使用该对象属性时,才发出sql语句)；</li>
<li>get为立即加载(执行时,会立即向数据库发出sql语句)</li>
</ul>
</li>
<li>返回结果：<ul>
<li>load检索不到记录时,会抛ObjectNotFoundException异常</li>
<li>get检索不到记录时,会返回null</li>
</ul>
</li>
</ul>
<h1 id="Hibernate-的应用（Hibernate-的结构）？"><a href="#Hibernate-的应用（Hibernate-的结构）？" class="headerlink" title="Hibernate 的应用（Hibernate 的结构）？"></a>Hibernate 的应用（Hibernate 的结构）？</h1><ul>
<li>首先获得 SessionFactory 的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure().buildSessionFactory();</span><br><span class="line"><span class="comment">//然后获得 session 的对象</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="comment">//其次获得 Transaction 的对象</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"><span class="comment">//执行相关的数据库操作:增,删,改,查</span></span><br><span class="line">session.save(user); <span class="comment">//增加, user 是 User 类的对象</span></span><br><span class="line">session.delete(user); <span class="comment">//删除</span></span><br><span class="line">session.update(user); <span class="comment">//更新</span></span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(“from User”); <span class="comment">//查询</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">tx.commit();</span><br><span class="line"><span class="comment">//如果有异常,我们还要作事务的回滚,恢复到操作之前</span></span><br><span class="line">tx.rollback();</span><br><span class="line"><span class="comment">//最后还要关闭 session,释放资源</span></span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>

<h1 id="Hibernate-有哪-5-个核心接口？"><a href="#Hibernate-有哪-5-个核心接口？" class="headerlink" title="Hibernate 有哪 5 个核心接口？"></a>Hibernate 有哪 5 个核心接口？</h1><ul>
<li>Configuration 接口：配置 Hibernate，根据其启动 hibernate，创建 SessionFactory 对象；</li>
<li>SessionFactory 接口：初始化 Hibernate，充当数据存储源的代理，创建 session 对象，sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级、二级缓存；</li>
<li>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个线程共享同一个 session，是轻量级、一级缓存；</li>
<li>Transaction 接口：管理事务；</li>
<li>Query 和 Criteria 接口：执行数据库的查询。</li>
</ul>
<h1 id="在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h1><ul>
<li>getCurrentSession 会绑定当前线程，而 openSession 则不会。</li>
<li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</li>
</ul>
<h1 id="hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="hibernate 实体类必须要有无参构造函数吗？为什么？"></a>hibernate 实体类必须要有无参构造函数吗？为什么？</h1><ul>
<li>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</li>
</ul>
<h1 id="hibernate-对象有哪些状态？"><a href="#hibernate-对象有哪些状态？" class="headerlink" title="hibernate 对象有哪些状态？"></a>hibernate 对象有哪些状态？</h1><ul>
<li>临时&#x2F;瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</li>
<li>持久化状态：当调用 Session 的 save&#x2F;saveOrupdate&#x2F;get&#x2F;load&#x2F;list 等方法的时候，对象就是持久化状态。</li>
<li>游离状态：Session 关闭之后对象就是游离状态。</li>
</ul>
<h1 id="说一下-hibernate-的缓存机制？"><a href="#说一下-hibernate-的缓存机制？" class="headerlink" title="说一下 hibernate 的缓存机制？"></a>说一下 hibernate 的缓存机制？</h1><ul>
<li>hibernate 常用的缓存有一级缓存和二级缓存：<ul>
<li>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</li>
<li>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</li>
</ul>
</li>
</ul>
<h1 id="hibernate-是如何工作的？"><a href="#hibernate-是如何工作的？" class="headerlink" title="hibernate 是如何工作的？"></a>hibernate 是如何工作的？</h1><ul>
<li>读取并解析配置文件。</li>
<li>读取并解析映射文件，创建 SessionFactory。</li>
<li>打开 Session。</li>
<li>创建事务。</li>
<li>进行持久化操作。</li>
<li>提交事务。</li>
<li>关闭 Session。</li>
<li>关闭 SessionFactory。</li>
</ul>
<h1 id="hibernate-有几种查询方式？"><a href="#hibernate-有几种查询方式？" class="headerlink" title="hibernate 有几种查询方式？"></a>hibernate 有几种查询方式？</h1><ul>
<li>三种：hql、原生 SQL、条件查询 Criteria。</li>
</ul>
<h1 id="hibernate-实体类可以被定义为-final-吗？"><a href="#hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="hibernate 实体类可以被定义为 final 吗？"></a>hibernate 实体类可以被定义为 final 吗？</h1><ul>
<li>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</li>
</ul>
<h1 id="在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h1><ul>
<li>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</li>
</ul>
<h1 id="jpa-和-hibernate-有什么区别？"><a href="#jpa-和-hibernate-有什么区别？" class="headerlink" title="jpa 和 hibernate 有什么区别？"></a>jpa 和 hibernate 有什么区别？</h1><ul>
<li>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</li>
</ul>
<h1 id="如何理解-Hibernate-的延迟加载机制？在实际应用中，延迟加载与-Session关闭的矛盾是如何处理的？"><a href="#如何理解-Hibernate-的延迟加载机制？在实际应用中，延迟加载与-Session关闭的矛盾是如何处理的？" class="headerlink" title="如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session关闭的矛盾是如何处理的？"></a>如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session关闭的矛盾是如何处理的？</h1><ul>
<li>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。</li>
<li>延迟加载与 session 关闭的矛盾一般可以这样处理：<ul>
<li>关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session orsession was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。</li>
<li>在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize()方法加载对象。</li>
<li>使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>架构</title>
    <url>/publishes/fec4be92fa21.html</url>
    <content><![CDATA[<h1 id="什么是-ELK（ElasticSearch-Logstash-Kibana）"><a href="#什么是-ELK（ElasticSearch-Logstash-Kibana）" class="headerlink" title="什么是 ELK（ElasticSearch, Logstash, Kibana）"></a>什么是 ELK（ElasticSearch, Logstash, Kibana）</h1><ul>
<li>ELK 是三个工具的集合，Elasticsearch + Logstash + Kibana，这三个工具组合形成了<br>一套实用、易用的监控架构，很多公司利用它来搭建可视化的海量日志分析平台。</li>
</ul>
<h4 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h4><ul>
<li>ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口</li>
<li>Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li>
</ul>
<h4 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h4><ul>
<li>Logstash 是一个用于管理日志和事件的工具，你可以用它去收集日志、转换日志、解析日志并将他们作为数据提供给其它模块调用，例如搜索、存储等。</li>
</ul>
<h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><ul>
<li>Kibana 是一个优秀的前端日志展示框架，它可以非常详细的将日志转化为各种图表，为用户提供强大的数据可视化支持。</li>
</ul>
<h1 id="什么是网关服务？"><a href="#什么是网关服务？" class="headerlink" title="什么是网关服务？"></a>什么是网关服务？</h1><ul>
<li>网关服务，通常是外部访问服务的唯一接口，访问内部的所有服务都必须先经过网关服务。网关服务的主要功能是消息解析过滤，路由，转发等。</li>
</ul>
<h1 id="网关服务中，路由器的-4-种路由规则方法是什么？"><a href="#网关服务中，路由器的-4-种路由规则方法是什么？" class="headerlink" title="网关服务中，路由器的 4 种路由规则方法是什么？"></a>网关服务中，路由器的 4 种路由规则方法是什么？</h1><ul>
<li>采用 URL 指定路由方式</li>
<li>采用服务名称指定路由方式</li>
<li>路由的排除方法</li>
<li>路由的添加前缀方法</li>
</ul>
<h1 id="什么是服务的灾难性的雪崩效应？"><a href="#什么是服务的灾难性的雪崩效应？" class="headerlink" title="什么是服务的灾难性的雪崩效应？"></a>什么是服务的灾难性的雪崩效应？</h1><ul>
<li>在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问 A 服务，而 A 服务需要调用 B 服务，B 服务需要调用 C 服务，由于网络原因或者自身的原因，如果 B 服务或者 C 服务不能及时响应，A 服务将处于阻塞状态，直到 B 服务 C 服务响应。</li>
<li>此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应</li>
</ul>
<h1 id="如何解决灾难性雪崩效应？"><a href="#如何解决灾难性雪崩效应？" class="headerlink" title="如何解决灾难性雪崩效应？"></a>如何解决灾难性雪崩效应？</h1><ul>
<li>降级：超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值.</li>
<li>隔离（线程池隔离和信号量隔离）：限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。</li>
<li>熔断：当失败率(如因网络故障&#x2F;超时造成的失败率高)达到阀值自动触发降级，熔断器触发的快速失败会进行快速恢复。</li>
<li>缓存：提供了请求缓存。</li>
<li>请求合并：提供请求合并。</li>
</ul>
<h1 id="什么是声明式，有什么作用，解决什么问题？"><a href="#什么是声明式，有什么作用，解决什么问题？" class="headerlink" title="什么是声明式，有什么作用，解决什么问题？"></a>什么是声明式，有什么作用，解决什么问题？</h1><ul>
<li>声明式调用就像调用本地方法一样调用远程方法;无感知远程 http 请求。</li>
<li>Spring Cloud 的声明式调用, 可以做到使用 HTTP 请求远程服务时能就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。</li>
<li>它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规的 Http Client 构造请求再解析返回数据。</li>
<li>它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</li>
</ul>
<h1 id="什么是-AKF-拆分原则？"><a href="#什么是-AKF-拆分原则？" class="headerlink" title="什么是 AKF 拆分原则？"></a>什么是 AKF 拆分原则？</h1><ul>
<li>业界对于可扩展的系统架构设计有一个朴素的理念,就是：通过加机器就可以解决容量和可用性问题。(如果一台不行那就两台)。</li>
</ul>
<h1 id="简单讲一下-webservice-使用的场景"><a href="#简单讲一下-webservice-使用的场景" class="headerlink" title="简单讲一下 webservice 使用的场景"></a>简单讲一下 webservice 使用的场景</h1><ul>
<li>webservice 是一个 SOA(面向服务的编程)的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过 Internet 进行基于 http 协议的网络应用间的交互。</li>
<li>异构系统(不同的开发语言)的整合</li>
<li>不同客户端的整合 (浏览器、手机端(android\ios)、微信)</li>
<li>实实在在的例子：天气预报：可以通过实现 webservice 客户端调用远程天气服务实现的</li>
<li>单点登录：一个服务实现所有系统的登录</li>
</ul>
<h1 id="什么是-VSFTPD？"><a href="#什么是-VSFTPD？" class="headerlink" title="什么是 VSFTPD？"></a>什么是 VSFTPD？</h1><ul>
<li>vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。</li>
<li>vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX 等系统上面，是一个完全免费的、开放源代码的 ftp 服务器软件，支持很多其他的 FTP 服务器所不支持的特征。</li>
</ul>
<h1 id="项目的生命周期"><a href="#项目的生命周期" class="headerlink" title="项目的生命周期"></a>项目的生命周期</h1><ul>
<li>需求分析</li>
<li>概要设计</li>
<li>详细设计(用例图，流程图，类图)</li>
<li>数据库设计(powerdesigner)</li>
<li>代码开发（编写）</li>
<li>单元测试（junit 白盒测试）(开发人员) svn版本管理工具(提交，更新代码，文档)</li>
<li>集成测试 （黑盒测试，loadrunner（编写测试脚本）(高级测试)）</li>
<li>上线试运行 （用户自己体验）</li>
<li>压力测试（loadrunner）</li>
<li>正式上线</li>
<li>维护</li>
</ul>
<h1 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h1><ul>
<li>CND 一般包含分发服务系统、负载均衡系统和管理系统</li>
</ul>
<h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><ul>
<li>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。</li>
<li>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。</li>
<li>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。</li>
</ul>
<h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><ul>
<li>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</li>
<li>使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。</li>
<li>GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。</li>
<li>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个 Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。</li>
</ul>
<h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><ul>
<li>分为运营管理和网络管理子系统。</li>
<li>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。</li>
<li>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。包括用户管理、产品管理、计费管理、统计分析等。</li>
</ul>
<h1 id="RMI-实现方式"><a href="#RMI-实现方式" class="headerlink" title="RMI 实现方式"></a>RMI 实现方式</h1><ul>
<li>Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用</li>
<li>实现步骤<ul>
<li>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</li>
<li>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</li>
<li>运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类;</li>
<li>启动一个 RMI 注册表，以便驻留这些服务;</li>
<li>在 RMI 注册表中注册服务；</li>
<li>客户端查找远程对象，并调用远程方法；<ul>
<li>创建远程接口，继承 java.rmi.Remote 接口</li>
<li>实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类</li>
<li>生成 Stub 和 Skeleton;</li>
<li>执行 rmiregistry 命令注册服务</li>
<li>启动服务</li>
<li>客户端调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="什么是微服务中的反应性扩展？"><a href="#什么是微服务中的反应性扩展？" class="headerlink" title="什么是微服务中的反应性扩展？"></a>什么是微服务中的反应性扩展？</h1><ul>
<li>Reactive Extensions 也称为 Rx</li>
<li>这是一种设计方法，我们通过调用多个服务来收集结果，然后编译组合响应</li>
<li>这些调用可以是同步或异步，阻塞或非阻塞。Rx是分布式系统中非常流行的工具，与传统流程相反。</li>
</ul>
<h1 id="我们可以用微服务创建状态机吗？"><a href="#我们可以用微服务创建状态机吗？" class="headerlink" title="我们可以用微服务创建状态机吗？"></a>我们可以用微服务创建状态机吗？</h1><ul>
<li>我们知道拥有自己的数据库的每个微服务都是一个可独立部署的程序单元，这反过来又让我们可以创建一个状态机。因此，我们可以为特定的微服务指定不同的状态和事件。</li>
<li>例如，我们可以定义 Order 微服务。订单可以具有不同的状态。Order 状态的转换可以是 Order 微服务中的独立事件。</li>
</ul>
<h1 id="架构师在微服务架构中的角色是什么？"><a href="#架构师在微服务架构中的角色是什么？" class="headerlink" title="架构师在微服务架构中的角色是什么？"></a>架构师在微服务架构中的角色是什么？</h1><ul>
<li>微服务架构中的架构师扮演以下角色：<ul>
<li>决定整个软件系统的布局。</li>
<li>帮助确定组件的分区。因此，他们确保组件相互粘合，但不紧密耦合。</li>
<li>与开发人员共同编写代码，了解日常生活中面临的挑战。</li>
<li>为开发微服务的团队提供某些工具和技术的建议。</li>
<li>提供技术治理，以便技术开发团队遵循微服务原则。</li>
</ul>
</li>
</ul>
<h1 id="什么是持续监测？"><a href="#什么是持续监测？" class="headerlink" title="什么是持续监测？"></a>什么是持续监测？</h1><ul>
<li>持续监控深入监控覆盖范围，从浏览器内前端性能指标，到应用程序性能，再到主机虚拟化基础架构指标。</li>
</ul>
<h1 id="什么是金丝雀释放？"><a href="#什么是金丝雀释放？" class="headerlink" title="什么是金丝雀释放？"></a>什么是金丝雀释放？</h1><ul>
<li>Canary Releasing 是一种降低在生产中引入新软件版本的风险的技术。这是通过将变更缓慢地推广到一小部分用户，然后将其发布到整个基础架构，即将其提供给每个人来完成的。</li>
</ul>
<h1 id="什么是持续集成（CI）？"><a href="#什么是持续集成（CI）？" class="headerlink" title="什么是持续集成（CI）？"></a>什么是持续集成（CI）？</h1><ul>
<li>持续集成（CI）是每次团队成员提交版本控制更改时自动构建和测试代码的过程。</li>
<li>这鼓励开发人员通过在每个小任务完成后将更改合并到共享版本控制存储库来共享代码和单元测试。</li>
</ul>
<h1 id="您对-Mike-Cohn-的测试金字塔了解多少？"><a href="#您对-Mike-Cohn-的测试金字塔了解多少？" class="headerlink" title="您对 Mike Cohn 的测试金字塔了解多少？"></a>您对 Mike Cohn 的测试金字塔了解多少？</h1><ul>
<li>Mike Cohn 提供了一个名为 Test Pyramid 的模型。这描述了软件开发所需的自动化测试类型。</li>
<li>根据金字塔，第一层的测试数量应该最高。在服务层，测试次数应小于单元测试级别，但应大于端到端级别。</li>
</ul>
<h1 id="Mock-或-Stub-有什么区别？"><a href="#Mock-或-Stub-有什么区别？" class="headerlink" title="Mock 或 Stub 有什么区别？"></a>Mock 或 Stub 有什么区别？</h1><ul>
<li>存根<ul>
<li>一个有助于运行测试的虚拟对象。</li>
<li>在某些可以硬编码的条件下提供固定行为。</li>
<li>永远不会测试存根的任何其他行为。</li>
</ul>
</li>
<li>例如，对于空堆栈，您可以创建一个只为 empty（）方法返回 true 的存根。因此，这并不关心堆栈中是否存在元素。</li>
<li>嘲笑<ul>
<li>一个虚拟对象，其中最初设置了某些属性。</li>
<li>此对象的行为取决于 set 属性。</li>
<li>也可以测试对象的行为。</li>
</ul>
</li>
<li>例如，对于 Customer 对象，您可以通过设置名称和年龄来模拟它。您可以将 age设置为 12，然后测试 isAdult（）方法，该方法将在年龄大于 18 时返回 true。因此，您的 Mock Customer 对象适用于指定的条件。</li>
</ul>
<h1 id="我们如何在测试中消除非决定论？"><a href="#我们如何在测试中消除非决定论？" class="headerlink" title="我们如何在测试中消除非决定论？"></a>我们如何在测试中消除非决定论？</h1><ul>
<li>非确定性测试（NDT）基本上是不可靠的测试。所以，有时可能会发生它们通过，显然有时它们也可能会失败。当它们失败时，它们会重新运行通过。</li>
<li>从测试中删除非确定性的一些方法如下：<ul>
<li>隔离</li>
<li>异步</li>
<li>远程服务</li>
<li>隔离</li>
<li>时间</li>
<li>资源泄漏</li>
</ul>
</li>
</ul>
<h1 id="负载均衡反向代理模式优点及缺点"><a href="#负载均衡反向代理模式优点及缺点" class="headerlink" title="负载均衡反向代理模式优点及缺点"></a>负载均衡反向代理模式优点及缺点</h1><ul>
<li>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</li>
<li>反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。</li>
<li>反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有此优点）。</li>
<li>其缺点主要表现在以下两个方面<ul>
<li>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器的负载均衡。</li>
<li>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。</li>
</ul>
</li>
<li>般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点进行负载均衡，如 search 等。</li>
</ul>
<h1 id="大型网站在架构上应当考虑哪些问题？"><a href="#大型网站在架构上应当考虑哪些问题？" class="headerlink" title="大型网站在架构上应当考虑哪些问题？"></a>大型网站在架构上应当考虑哪些问题？</h1><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><ul>
<li>分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI&#x2F;RM）和 Internet 的 TCP&#x2F;IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</li>
</ul>
<h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><ul>
<li>分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</li>
</ul>
<h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><ul>
<li>除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce分布式计算框架来处理。</li>
</ul>
<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><ul>
<li>集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</li>
</ul>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul>
<li>所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul>
<li>异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</li>
</ul>
<h4 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h4><ul>
<li>各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</li>
</ul>
<h1 id="正向代理（客户端代理）和反向代理（服务器端代理）"><a href="#正向代理（客户端代理）和反向代理（服务器端代理）" class="headerlink" title="正向代理（客户端代理）和反向代理（服务器端代理）*"></a>正向代理（客户端代理）和反向代理（服务器端代理）*</h1><ul>
<li>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<ul>
<li>访问原来无法访问的资源，如google</li>
<li>可以做缓存，加速访问资源</li>
<li>对客户端访问授权，上网进行认证</li>
<li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>
</ul>
</li>
<li>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<ul>
<li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li>
<li>负载均衡，通过反向代理服务器来优化网站的负载</li>
</ul>
</li>
<li>nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。</li>
</ul>
<h1 id="如何实现分布式Session"><a href="#如何实现分布式Session" class="headerlink" title="如何实现分布式Session"></a>如何实现分布式Session</h1><ul>
<li>基于数据库的Session共享</li>
<li>基于NFS共享文件系统</li>
<li>基于memcached 的session，如何保证 memcached 本身的高可用性？</li>
<li>基于resin&#x2F;tomcat web容器本身的session复制机制</li>
<li>基于TT&#x2F;Redis 或 jbosscache 进行 session 共享。</li>
<li>基于cookie 进行session共享</li>
</ul>
<h1 id="CAP-理论和-BASE-理论"><a href="#CAP-理论和-BASE-理论" class="headerlink" title="CAP 理论和 BASE 理论"></a>CAP 理论和 BASE 理论</h1><ul>
<li>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</li>
<li>基本可用（Basically Available）</li>
<li>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</li>
<li>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</li>
<li>软状态（ Soft State）</li>
<li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</li>
<li>最终一致性（ Eventual Consistency）</li>
<li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li>
</ul>
<h1 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h1><ul>
<li>c是指client，而10k则是一万的意思。c10k就是单机同时并发一万个请求。同理c100k则是同时并发十万个请求，如今百万请求也十分常见了。</li>
</ul>
<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><ul>
<li>一致性哈希算法在1997年由麻省理工学院提出,是一种特殊的哈希算法,目的是解决分布式缓存的问题。 [1] 在移除或者添加一个服务器时,能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table,DHT) 中存在的动态伸缩等问题</li>
</ul>
<h1 id="DDD设计模式"><a href="#DDD设计模式" class="headerlink" title="DDD设计模式"></a>DDD设计模式</h1><ul>
<li>领域驱动设计原则:DDD倡导将领域模型作为核心设计元素,通过使用领域模型中的领域对象、值对象和领域服务来解决问题</li>
</ul>
<h1 id="消息中间件选型要点"><a href="#消息中间件选型要点" class="headerlink" title="消息中间件选型要点"></a>消息中间件选型要点</h1><h2 id="功能维度"><a href="#功能维度" class="headerlink" title="功能维度"></a>功能维度</h2><ul>
<li>优先级队列<ul>
<li>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证</li>
<li>优先级也是需要有一个前提的，生产者的速度大于消费者的速度，否则，生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的</li>
</ul>
</li>
<li>延迟队列<ul>
<li>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”，这个是延迟队列的一种典型应用场景。</li>
<li>延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</li>
<li>延迟队列一般分为两种：<ul>
<li>基于消息的延迟，是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。</li>
<li>基于队列的延迟，实际应用中大多采用这种，设置不同延迟级别的队列，比如5s、10s、30s、1min、5mins、10mins等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略(比如定时)即可投递超时的消息。</li>
</ul>
</li>
</ul>
</li>
<li>死信队列<ul>
<li>由于某些原因消息无法被正确投递，为了确保消息不会被无故丢弃，一般将其置于一个特殊角色的队列，这个队列称为死信队列。</li>
<li>与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认(Ack), 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。</li>
<li>为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</li>
</ul>
</li>
<li>重试队列<ul>
<li>其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。</li>
<li>与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。</li>
<li>举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息。</li>
<li>如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。</li>
<li>以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。</li>
<li>重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发;延迟队列作用一次，而重试队列的作用范围会向后传递。</li>
</ul>
</li>
<li>消费模式<ul>
<li>消费模式分为推(push)模式和拉(pull)模式：<ul>
<li>推模式，是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。</li>
<li>拉模式，是指消费端主动向 Broker 端请求拉取(一般是定时或者定量)消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。</li>
</ul>
</li>
</ul>
</li>
<li>广播消费<ul>
<li>消息一般有两种传递模式——点对点(P2P，Point-to-Point)模式和发布&#x2F;订阅(Pub&#x2F;Sub)模式：</li>
<li>对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。</li>
<li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题(Topic)，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。</li>
<li>主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布&#x2F;订阅模式在消息的一对多广播时采用。</li>
<li>RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。</li>
<li>但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组(Consumer Group)的概念看成是队列的概念。</li>
<li>不过对比来说，Kafka 中因为有了消息回溯功能的存在，对于广播消费的力度支持比 RabbitMQ 的要强。</li>
</ul>
</li>
<li>消息回溯<ul>
<li>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息</li>
<li>消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。</li>
<li>对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失，一般很难追查。</li>
<li>如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头所在。</li>
<li>消息回溯的作用远不止于此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。</li>
</ul>
</li>
<li>消息堆积+持久化<ul>
<li>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。</li>
<li>从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。</li>
<li>消息堆积分内存式堆积和磁盘式堆积：</li>
<li>RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘(换页动作会影响吞吐)，或者直接使用惰性队列来将消息直接持久化至磁盘中。</li>
<li>Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。</li>
<li>一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。</li>
<li>从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引《纽约时报》的案例，其直接将 Kafka 用作存储系统。</li>
</ul>
</li>
<li>消息追踪<ul>
<li>对于分布式架构系统中的链路追踪(Trace)，大家一定不陌生</li>
<li>对于消息中间件，消息的链路追踪(以下简称消息追踪)同样重要，最通俗来理解，就是要知道消息从哪来，存在哪里以及发往哪里去。</li>
<li>基于此功能，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。</li>
</ul>
</li>
<li>消息过滤<ul>
<li>消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。</li>
<li>就以 Kafka 而言，完全可以将不同类别的消息发送至不同的 Topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 Topic 中的消息进行分类。</li>
<li>不过，更加严格意义上的消息过滤，应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。</li>
<li>同样以 Kafka 为例，可以通过客户端提供的 Consumer Interceptor 接口或者 Kafka Stream 的 Filter 功能进行消息过滤。</li>
</ul>
</li>
<li>多租户<ul>
<li>也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。</li>
<li>RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 VHost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。</li>
<li>VHost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。</li>
</ul>
</li>
<li>多协议支持<ul>
<li>消息是信息的载体，为了让生产者和消费者都能理解所承载的信息(生产者需要知道如何构造消息，消费者需要知道如何解析消息)，它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。</li>
<li>有效的消息一定具有某种格式，而没有格式的消息是没有意义的。</li>
<li>一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等(消息领域中的 JMS 更多的是一个规范而不是一个协议)，支持的协议越多其应用范围就会越广，通用性越强。</li>
<li>比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。</li>
</ul>
</li>
<li>跨语言支持<ul>
<li>对很多公司而言，其技术栈体系中会有多种编程语言，如 C&#x2F;C++、Java、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。</li>
<li>跨语言的支持力度也从侧面反映出一个消息中间件的流行程度。</li>
</ul>
</li>
<li>流量控制<ul>
<li>针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应</li>
<li>通常的流控方法有 Stop-and-Wait、滑动窗口以及令牌桶等。</li>
</ul>
</li>
<li>消息顺序性<ul>
<li>顾名思义，是指保证消息有序</li>
<li>这个功能有个很常见的应用场景就是 CDC(Change Data Chapture)。</li>
<li>以 MySQL 为例，如果其传输的 Binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1，造成数据不一致。</li>
</ul>
</li>
<li>安全机制<ul>
<li>在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制：<ul>
<li>身份认证，是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制。</li>
<li>权限控制，是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。</li>
</ul>
</li>
<li>对于 RabbitMQ 而言，其同样提供身份认证(TLS&#x2F;SSL、SASL)和权限控制(读写操作)的安全机制。</li>
</ul>
</li>
<li>消息幂等性<ul>
<li>确保消息在生产者和消费者之间进行传输，一般有三种传输保障(Delivery Guarantee)：<ul>
<li>At most once，至多一次，消息可能丢失，但绝不会重复传输。</li>
<li>At least once，至少一次，消息绝不会丢，但是可能会重复。</li>
<li>Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。</li>
</ul>
</li>
<li>对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</li>
<li>Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等。</li>
<li>而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS(Exactly Once Semantic)的能力。</li>
<li>不过如果要考虑全局的幂等，还需要从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。</li>
<li>以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法由消息中间件层面来保证的。</li>
<li>如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。</li>
</ul>
</li>
<li>事务性消息<ul>
<li>事务本身是一个并不陌生的词汇，事务是由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。</li>
<li>支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。</li>
<li>消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。</li>
</ul>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度，有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得。<br>K- afka 在开启幂等、事务功能的时候会使其性能降低;RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大影响其性能。</li>
<li>性能指什么?<ul>
<li>消息中间件的性能一般是指其吞吐量</li>
<li>虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级。</li>
<li>一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。</li>
<li>注明：消息中间件的吞吐量始终会受到硬件层面的限制。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过(1Gb&#x2F;8)&#x2F;100W，即约等于 134B。</li>
<li>换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。</li>
</ul>
</li>
<li>性能的指标是什么?<ul>
<li>时延作为性能维度的一个重要指标，却往往在消息中间件领域被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。</li>
<li>消息中间件具备消息堆积的能力，消息堆积越大也就意味着端到端的时延也就越长，与此同时延时队列也是某些消息中间件的一大特色。那么为什么还要关注消息中间件的时延问题呢?</li>
<li>消息中间件能够解耦系统，对于一个时延较低的消息中间件而言，它可以让上游生产者发送消息之后可以迅速的返回，也可以让消费者更加快速的获取到消息，在没有堆积的情况下，可以让整体上下游的应用之间的级联动作更加高效。</li>
<li>虽然不建议在时效性很高的场景下使用消息中间件，但是如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。</li>
</ul>
</li>
</ul>
<h2 id="可靠性-可用性"><a href="#可靠性-可用性" class="headerlink" title="可靠性+可用性"></a>可靠性+可用性</h2><ul>
<li>消息丢失是使用消息中间件时所不得不面对的一个痛点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素</li>
<li>尤其是在金融支付领域，消息可靠性尤为重要。</li>
<li>然而说到可靠性必然要说到可用性，注意这两者之间的区别：<ul>
<li>可靠性是指对消息不丢失的保障程度。</li>
<li>可用性是指无故障运行的时间百分比，通常用几个 9 来衡量。</li>
</ul>
</li>
<li>从狭义的角度来说，分布式系统架构是一致性协议理论的应用实现，对于消息可靠性和可用性而言也可以追溯到消息中间件背后的一致性协议：<ul>
<li>对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，通过 ISR(In-Sync-Replica)来保证多副本之间的同步，并且支持强一致性语义(通过 Acks 实现)。</li>
<li>对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。</li>
</ul>
</li>
<li>多副本可以保证在 Master 节点宕机异常之后可以提升 Slave 作为新的 Master 而继续提供服务来保障可用性。</li>
<li>Kafka 设计之初是为日志处理而生，给人们留下了数据可靠性要求不高的不良印象，但是随着版本的升级优化，其可靠性得到极大的增强，详细可以参考 KIP101。</li>
<li>就目前而言，在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多，随着 RabbitMQ 性能的不断提升和 Kafka 可靠性的进一步增强，相信彼此都能在以前不擅长的领域分得一杯羹。</li>
<li>同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘。</li>
<li>但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。</li>
<li>这里还要提及的一个方面是扩展能力，这里我狭隘地将此归纳到可用性这一维度，消息中间件的扩展能力能够增强其可用能力及范围，比如前面提到的 RabbitMQ 支持多种消息协议，这个就是基于其插件化的扩展实现。</li>
<li>还有从集群部署上来讲，归功于 Kafka 的水平扩展能力，其基本上可以达到线性容量提升的水平，在 LinkedIn 实践介绍中就提及了有部署超过千台设备的 Kafka 集群。</li>
</ul>
<h2 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h2><ul>
<li>在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复?</li>
<li>业务线流量有峰值有低谷，尤其是电商领域，那么怎样进行有效的容量评估，尤其是大促期间?脚踢电源、网线被挖等事件层出不穷，如何有效的做好异地多活?</li>
<li>这些都离不开消息中间件的衍生产品——运维管理。运维管理也可以进行进一步的细分，比如申请、审核、监控、告警、管理、容灾、部署等。</li>
<li>申请、审核很好理解，在源头对资源进行管控，既可以有效校正应用方的使用规范，配合监控也可以做好流量统计与流量评估工作。</li>
<li>一般申请、审核与公司内部系统交融性较大，不适合使用开源类的产品。</li>
<li>监控、告警也比较好理解，对消息中间件的使用进行全方位的监控，既可以为系统提供基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。</li>
<li>除了一般的监控项(比如硬件、GC 等)之外，消息中间件还需要关注端到端时延、消息审计、消息堆积等方面：</li>
<li>对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，但是社区内还有 AppDynamics、Collectd、DataDog、Ganglia、Munin、Nagios、New Relic、Prometheus、Zenoss 等多种优秀的产品。</li>
<li>Kafka 在此方面也毫不逊色，比如：Kafka Manager、Kafka Monitor、Kafka Offset Monitor、Burrow、Chaperone、Confluent Control Center 等产品，尤其是 Cruise 还可以提供自动化运维的功能。</li>
<li>不管是扩容、降级、版本升级、集群节点部署、还是故障处理都离不开管理工具的应用，一个配套完备的管理工具集可以在遇到变更时做到事半功倍。</li>
<li>故障可大可小，一般是一些应用异常，也可以是机器掉电、网络异常、磁盘损坏等单机故障，这些故障单机房内的多副本足以应付。</li>
<li>如果是机房故障就要涉及异地容灾了，关键点在于如何有效的进行数据复制，Kafka 可以参考 MirrorMarker、uReplicator 等产品，而 RabbitMQ 可以参考 Federation 和 Shovel。</li>
</ul>
<h2 id="社区力度及生态发展"><a href="#社区力度及生态发展" class="headerlink" title="社区力度及生态发展"></a>社区力度及生态发展</h2><ul>
<li>对于目前流行的编程语言而言，如 Java、Python，如果你在使用过程中遇到了一些异常，基本上可以通过搜索引擎的帮助来得到解决，因为一个产品用的人越多，踩过的坑也就越多，对应的解决方案也就越多。</li>
<li>消息中间件也同样适用，如果你选择了一种“生僻”的消息中间件，可能在某些方面运用的得心应手，但是版本更新缓慢、遇到棘手问题也难以得到社区的支持而越陷越深。</li>
<li>相反如果你选择了一种“流行”的消息中间件，其更新力度大，不仅可以迅速的弥补之前的不足，而且也能顺应技术的快速发展来变更一些新的功能，这样可以让你也“站在巨人的肩膀上”。</li>
<li>在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。</li>
</ul>
<h2 id="消息中间件选型误区总结"><a href="#消息中间件选型误区总结" class="headerlink" title="消息中间件选型误区总结"></a>消息中间件选型误区总结</h2><ul>
<li>选型误区<ul>
<li>选型之前可以先问自己一个问题：是否真的需要一个消息中间件?</li>
<li>在搞清楚这个问题之后，还可以继续问自己一个问题：是否需要自己维护一套消息中间件?</li>
<li>很多初创型公司为了节省成本会选择直接购买消息中间件有关的云服务，自己只需要关注收发消息即可，其余的都可以外包出去。</li>
<li>很多人面对消息中间件有一种自研的冲动，你完全可以对 Java 中的 ArrayBlockingQueue 做一个简单的封装，你也可以基于文件、数据库、Redis 等底层存储封装而形成一个消息中间件。</li>
<li>消息中间件做为一个基础组件并没有想象中的那么简单，其背后还需要配套的管理运维整个生态的产品集。</li>
<li>自研还会有交接问题，如果文档不齐全、运作不规范将会带给新人噩梦般的体验。</li>
<li>是否真的有自研的必要?如果不是 KPI 的压迫可以先考虑下面这两个问题：<ul>
<li>目前市面上的消息中间件是否都真的无法满足目前的业务需求?</li>
<li>团队是否有足够的能力、人力、财力、精力来支持自研?</li>
</ul>
</li>
<li>很多人在做消息中间件选型时会参考网络上的很多对比类的文章，但是其专业性、严谨性、以及其政治立场问题都有待考证，需要带着怀疑的态度去审视这些文章。</li>
<li>比如有些文章会在没有任何限定条件及场景的情况下直接定义某款消息中间件最好。</li>
<li>还有些文章没有指明消息中间件版本及测试环境就来做功能和性能对比分析，诸如此类的文章都可以唾弃之。</li>
<li>消息中间件犹如小马过河，选择合适的才最重要。这需要贴合自身的业务需求，技术服务于业务，大体上可以根据上一节所提及的功能、性能等 6 个维度来一一进行筛选。更深层次的抉择在于你能否掌握其魂。</li>
<li>笔者鄙见：RabbitMQ 在于 Routing，而 Kafka 在于 Streaming，了解其根本对于自己能够对症下药选择到合适的消息中间件尤为重要。</li>
<li>消息中间件选型切忌一味的追求性能或者功能，性能可以优化，功能可以二次开发。</li>
<li>如果要在功能和性能方面做一个抉择的话，那么首选性能，因为总体上来说性能优化的空间没有功能扩展的空间大。然而看长期发展，生态又比性能以及功能都要重要。</li>
</ul>
</li>
<li>可靠性误区<ul>
<li>很多时候，可靠性方面也容易存在一个误区：想要找到一个产品来保证消息的绝对可靠，很不幸的是这世界上没有绝对的东西，只能说尽量趋于完美。</li>
<li>想要尽可能的保障消息的可靠性也并非单单只靠消息中间件本身，还要依赖于上下游，需要从生产端、服务端和消费端这 3 个维度去努力保证。</li>
<li>消息中间件选型还有一个考量标准就是尽量贴合团队自身的技术栈体系，虽然说没有蹩脚的消息中间件，只有蹩脚的程序员，但是让一个 C 栈的团队去深挖 PhxQueue 总比去深挖 Scala 编写的 Kafka 要容易的多。</li>
<li>消息中间件大道至简：一发一存一消费，没有最好的消息中间件，只有最合适的消息中间件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/publishes/c96491b71c82.html</url>
    <content><![CDATA[<h1 id="什么是-Maven？"><a href="#什么是-Maven？" class="headerlink" title="什么是 Maven？"></a>什么是 Maven？</h1><ul>
<li>Maven 使用项目对象模型(POM)的概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</li>
<li>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具</li>
<li>由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目</li>
<li>由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发布时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</li>
<li>Maven 的出现，解决了开发过程中的 jar 包升级及依赖的难题</li>
<li>它可以对项目依赖的 jar包进行管理，可以让你的项目保持基本的依赖，排除冗余 jar 包，并且可以让你非常轻松的对依赖的 jar 包进行版本升级</li>
<li>而这些仅仅是 Maven 最基本的功能，它可以在这基础上对项目进行清理、编译、测试、打包、发布等等构建项目的工作。</li>
<li>可以说，Maven 是现在 Java 社区中最强大的项目管理和项目构建工具，而更加值得庆幸的是，这样一个强大的工具，它的使用也是非常简单的。</li>
<li>现在，JavaEE 项目使用的开源软件都可以通过 Maven 来获取，并且，越来越多的公司也开始使用 Maven 来管理构建项目了。</li>
</ul>
<h1 id="Maven-和-ANT-的区别"><a href="#Maven-和-ANT-的区别" class="headerlink" title="Maven 和 ANT 的区别"></a>Maven 和 ANT 的区别</h1><ul>
<li>maven&amp;ant 同属 apach 是流行的构建工具。</li>
<li>都是为了简化软件开发而存在的。但是 maven 因为自身管理一个项目对象模型（project object model），这个模型其实就是抽象了一个项目的开发流程，它包含了一个项目的生命周期的各个阶段，并将这个周期固定下来，这也就是约定大于配置。约定大于配置的意思就是，我 maven 将项目开发的各个阶段固定起来了，每个文件的存放位置，每个阶段要生成什么文件、保存为什么格式并且要把它放在什么位置，我都固定好了。我知道一个软件是怎么开发出来，如果一个项目要使用 maven，可以，但你要遵循我的规则，文件目录不要乱建乱放，只有这样 maven 才会将源码用起来。这就是约定大于配置，因为 maven 已经将流程固定下来了，只要遵守约定，就不需要自己手动去配置了，这将大大地提高开发效率。- 就像是开车一样，只要知道点火、油门、方向、刹车，就可以将车子开东起来（当然出于安全和法律考虑，还是要考驾照的。），关于车子内部的传动原理，电气原理，工程原理，普通人并不需要了解多少，日常够用就好了。这也是约定大于配置的一个例子。配置就是自己造一辆车去开，有必要，有能力，有时间吗？</li>
<li>maven 的中央仓库和 pom.xml 文件。中央仓库统一存放了开发用到的各种 jar 包，要用时只需要添加依赖到 pom 文件中，maven 就会自动下载，当然为了方便一般会在本地建一个仓库，减少下载时间。pom 文件是 maven 的配置文件，maven 就是通过管理 pom 文件和一些核心插件来管理项目。当然我前面将 maven 拟人化了，其实 maven 是没有智力的，一切都是封装好的流程，只是 maven 将很多操作隐藏起来了。</li>
<li>ant 的 build.xml 文件。build 文件是 ant 的配置文件，ant 依靠它来执行操作，与 maven不同的是 ant 没有固定一条程序链。你想要执行什么操作以及操作之间的顺序和依赖关系，都需要手动添加到 build 文件中，一点一滴都要写清楚，否则 ant 就不会执行。</li>
<li>maven 和 ant 区别<ul>
<li>Maven 拥有约定，只要遵守约定，它就知道你的源代码在哪里。Maven 是声明式的。你需要做的只是创建一个 pom.xml 文件然后将源代码放到默认的目录。Maven 会帮你处理其它的事情。Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。缺点是运行许多默认目标。而 ant 没有约定，项目生命周期，它是命令式的。所有操作都要手动去创建、布置。甚至连build.xml 文件都需要手动创建。</li>
</ul>
</li>
</ul>
<h1 id="Maven-仓库是什么"><a href="#Maven-仓库是什么" class="headerlink" title="Maven 仓库是什么"></a>Maven 仓库是什么</h1><ul>
<li>Maven 仓库是基于简单文件系统存储的，集中化管理 Java API 资源（构件）的一个服务</li>
<li>仓库中的任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径</li>
<li>得益于 Maven 的坐标机制，任何 Maven 项目使用任何一个构件的方式都是完全相同的，Maven 可以在某个位置统一存储所有的 Maven 项目共享的构件，这个统一的位置就是仓库，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其它项目使用。</li>
<li>对于 Maven 来说，仓库分为两类：本地仓库和远程仓库。</li>
</ul>
<h1 id="Maven-的工程类型有哪些？"><a href="#Maven-的工程类型有哪些？" class="headerlink" title="Maven 的工程类型有哪些？"></a>Maven 的工程类型有哪些？</h1><h4 id="POM-工程"><a href="#POM-工程" class="headerlink" title="POM 工程"></a>POM 工程</h4><ul>
<li>POM 工程是逻辑工程。用在父级工程或聚合工程中。用来做 jar 包的版本控制。</li>
</ul>
<h4 id="JAR-工程"><a href="#JAR-工程" class="headerlink" title="JAR 工程"></a>JAR 工程</h4><ul>
<li>将会打包成 jar 用作 jar 包使用。即常见的本地工程 - Java Project。</li>
</ul>
<h4 id="WAR-工程"><a href="#WAR-工程" class="headerlink" title="WAR 工程"></a>WAR 工程</h4><ul>
<li>将会打包成 war，发布在服务器上的工程。如网站或服务。即常见的网络工程 -Dynamic Web Project。war 工程默认没有 WEB-INF 目录及 web.xml 配置文件，IDE通常会显示工程错误，提供完整工程结构可以解决。</li>
</ul>
<h1 id="Maven-常用命令有哪些？"><a href="#Maven-常用命令有哪些？" class="headerlink" title="Maven 常用命令有哪些？"></a>Maven 常用命令有哪些？</h1><ul>
<li>install 本地安装， 包含编译，打包，安装到本地仓库<ul>
<li>编译 - javac</li>
<li>打包 - jar， 将 java 代码打包为 jar 文件</li>
<li>安装到本地仓库 - 将打包的 jar 文件，保存到本地仓库目录中。</li>
</ul>
</li>
<li>clean<ul>
<li>清除已编译信息。</li>
<li>删除工程中的 target 目录。</li>
</ul>
</li>
<li>compile<ul>
<li>只编译。 javac 命令</li>
</ul>
</li>
<li>deploy<ul>
<li>部署。 常见于结合私服使用的命令。</li>
<li>相当于是 install+上传 jar 到私服。</li>
<li>包含编译，打包，安装到本地仓库，上传到私服仓库。</li>
</ul>
</li>
<li>package<ul>
<li>打包。 包含编译，打包两个功能。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>日志</title>
    <url>/publishes/193c3be66867.html</url>
    <content><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h4 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h4><ul>
<li>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带的 java.util.logging.Logger 等。</li>
</ul>
<h4 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h4><ul>
<li>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。Log4j 由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。<ul>
<li>Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制</li>
<li>Appenders : 指定了日志将打印到控制台还是文件中</li>
<li>Layout : 控制日志信息的显示格式</li>
</ul>
</li>
<li>Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为 DEBUG、INFO、WARN、ERROR 和 FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码。</li>
</ul>
<h4 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h4><ul>
<li>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。</li>
<li>Logback 主要由三个模块组成：logback-core，logback-classic。logback-access logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的 通用机制。</li>
<li>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J；</li>
<li>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与HTTP 访问相关的功能。</li>
</ul>
<h4 id="Logback-优点"><a href="#Logback-优点" class="headerlink" title="Logback 优点"></a>Logback 优点</h4><ul>
<li>同样的代码路径，Logback 执行更快</li>
<li>更充分的测试</li>
<li>原生实现了 SLF4J API（Log4J 还需要有一个中间转换层）</li>
<li>内容更丰富的文档</li>
<li>支持 XML 或者 Groovy 方式配置</li>
<li>配置文件自动热加载</li>
<li>从 IO 错误中优雅恢复</li>
<li>自动删除日志归档</li>
<li>自动压缩日志成为归档文件</li>
<li>支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件</li>
<li>支持配置文件中加入条件判断来适应不同的环境</li>
<li>更强大的过滤器</li>
<li>支持 SiftingAppender（可筛选 Appender）</li>
<li>异常栈信息带有包信息</li>
</ul>
<h4 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h4><ul>
<li>ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打造大规模日志实时处理系统。<ul>
<li>Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将日志索引并存储起来，方便业务方检索查询。</li>
<li>Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理。</li>
<li>Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方，比如各类饼图、直方图、区域图等。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Slf4j</tag>
        <tag>Log4j</tag>
        <tag>LogBack</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/publishes/39a9c27510d2.html</url>
    <content><![CDATA[<h1 id="您对微服务有何了解？"><a href="#您对微服务有何了解？" class="headerlink" title="您对微服务有何了解？"></a>您对微服务有何了解？</h1><ul>
<li>微服务，又称微服务 架构，是一种架构风格，它将应用程序构建为以业务领域为模型的小型自治服务集合 。</li>
<li>通俗地说，你必须看到蜜蜂如何通过对齐六角形蜡细胞来构建它们的蜂窝状物。</li>
<li>他们最初从使用各种材料的小部分开始，并继续从中构建一个大型蜂箱。这些细胞形成图案，产生坚固的结构，将蜂窝的特定部分固定在一起。这里，每个细胞独立于另一个细胞，但它也与其他细胞相关。这意味着对一个细胞的损害不会损害其他细胞，因此，蜜蜂可以在不影响完整蜂箱的情况下重建这些细胞。这里，每个六边形形状代表单独的服务组件。与蜜蜂的工作类似，每个敏捷团队都使用可用的框架和所选的技术堆栈构建单独的服务组件。就像在蜂箱中一样，每个服务组件形成一个强大的微服务架构，以提供更好的可扩展性。此外，敏捷团队可以单独处理每个服务组件的问题，而对整个应用程序没有影响或影响最小。</li>
</ul>
<h1 id="微服务架构有哪些优势？"><a href="#微服务架构有哪些优势？" class="headerlink" title="微服务架构有哪些优势？"></a>微服务架构有哪些优势？</h1><ul>
<li>独立开发 – 所有微服务都可以根据各自的功能轻松开发</li>
<li>独立部署 – 基于其服务，可以在任何应用程序中单独部署它们</li>
<li>故障隔离 – 即使应用程序的一项服务不起作用，系统仍可继续运行</li>
<li>混合技术堆栈 – 可以使用不同的语言和技术来构建同一应用程序的不同服务</li>
<li>粒度缩放 – 单个组件可根据需要进行缩放，无需将所有组件缩放在一起</li>
</ul>
<h1 id="微服务有哪些特点？"><a href="#微服务有哪些特点？" class="headerlink" title="微服务有哪些特点？"></a>微服务有哪些特点？</h1><ul>
<li>解耦 – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展</li>
<li>组件化 – 微服务被视为可以轻松更换和升级的独立组件</li>
<li>业务能力 – 微服务非常简单，专注于单一功能</li>
<li>自治 – 开发人员和团队可以彼此独立工作，从而提高速度</li>
<li>持续交付 – 通过软件创建，测试和批准的系统自动化，允许频繁发布软件</li>
<li>责任 – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品</li>
<li>分散治理 – 重点是使用正确的工具来做正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</li>
<li>敏捷 – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃</li>
</ul>
<h1 id="微服务架构如何运作？"><a href="#微服务架构如何运作？" class="headerlink" title="微服务架构如何运作？"></a>微服务架构如何运作？</h1><ul>
<li>微服务架构具有以下组件：<ul>
<li>客户端 – 来自不同设备的不同用户发送请求。</li>
<li>身份提供商 – 验证用户或客户身份并颁发安全令牌。</li>
<li>API 网关 – 处理客户端请求。</li>
<li>静态内容 – 容纳系统的所有内容。</li>
<li>管理 – 在节点上平衡服务并识别故障。</li>
<li>服务发现 – 查找微服务之间通信路径的指南。</li>
<li>内容交付网络 – 代理服务器及其数据中心的分布式网络。</li>
<li>远程服务 – 启用驻留在 IT 设备网络上的远程访问信息。</li>
</ul>
</li>
</ul>
<h1 id="单片，SOA-和微服务架构有什么区别？"><a href="#单片，SOA-和微服务架构有什么区别？" class="headerlink" title="单片，SOA 和微服务架构有什么区别？"></a>单片，SOA 和微服务架构有什么区别？</h1><ul>
<li>单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密封装。</li>
<li>一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数据传递，也可以涉及两个或多个协调某些活动的服务。</li>
<li>微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。</li>
</ul>
<h1 id="在使用微服务架构时，您面临哪些挑战？"><a href="#在使用微服务架构时，您面临哪些挑战？" class="headerlink" title="在使用微服务架构时，您面临哪些挑战？"></a>在使用微服务架构时，您面临哪些挑战？</h1><ul>
<li>开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。</li>
<li>自动化组件：难以自动化，因为有许多较小的组件。因此，对于每个组件，我们必须遵循 Build，Deploy 和 Monitor 的各个阶段。</li>
<li>易感性：将大量组件维护在一起变得难以部署，维护，监控和识别问题。它需要在所有组件周围具有很好的感知能力。</li>
<li>配置管理：有时在各种环境中维护组件的配置变得困难。</li>
<li>调试：很难找到错误的每一项服务。维护集中式日志记录和仪表板以调试问题至关重要。</li>
</ul>
<h1 id="什么是无所不在的语言？"><a href="#什么是无所不在的语言？" class="headerlink" title="什么是无所不在的语言？"></a>什么是无所不在的语言？</h1><ul>
<li>如果您必须定义泛在语言（UL），那么它是特定域的开发人员和用户使用的通用语言，通过该语言可以轻松解释域。</li>
<li>无处不在的语言必须非常清晰，以便它将所有团队成员放在同一页面上，并以机器可以理解的方式进行翻译。</li>
</ul>
<h1 id="什么是凝聚力？"><a href="#什么是凝聚力？" class="headerlink" title="什么是凝聚力？"></a>什么是凝聚力？</h1><ul>
<li>模块内部元素所属的程度被认为是凝聚力。</li>
</ul>
<h1 id="什么是耦合？"><a href="#什么是耦合？" class="headerlink" title="什么是耦合？"></a>什么是耦合？</h1><ul>
<li>组件之间依赖关系强度的度量被认为是耦合。一个好的设计总是被认为具有高内聚力和低耦合性。</li>
</ul>
<h1 id="什么是-REST-RESTful-以及它的用途是什么？"><a href="#什么是-REST-RESTful-以及它的用途是什么？" class="headerlink" title="什么是 REST &#x2F; RESTful 以及它的用途是什么？"></a>什么是 REST &#x2F; RESTful 以及它的用途是什么？</h1><ul>
<li>Representational State Transfer（REST）&#x2F; RESTful Web 服务是一种帮助计算机系统通过 Internet 进行通信的架构风格。这使得微服务更容易理解和实现。</li>
<li>微服务可以使用或不使用 RESTful API 实现，但使用 RESTful API 构建松散耦合的微服务总是更容易。</li>
</ul>
<h1 id="什么是-Spring-引导的执行器？"><a href="#什么是-Spring-引导的执行器？" class="headerlink" title="什么是 Spring 引导的执行器？"></a>什么是 Spring 引导的执行器？</h1><ul>
<li>Spring Boot 执行程序提供了 restful Web 服务，以访问生产环境中运行应用程序的当前状态。在执行器的帮助下，您可以检查各种指标并监控您的应用程序。</li>
</ul>
<h1 id="什么是-Spring-Cloud？"><a href="#什么是-Spring-Cloud？" class="headerlink" title="什么是 Spring Cloud？"></a>什么是 Spring Cloud？</h1><p> Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，领导选举，分布式会话，集群状态）。</p>
<h1 id="Spring-Cloud-解决了哪些问题？"><a href="#Spring-Cloud-解决了哪些问题？" class="headerlink" title="Spring Cloud 解决了哪些问题？"></a>Spring Cloud 解决了哪些问题？</h1><ul>
<li>在使用 Spring Boot 开发分布式微服务时，我们面临的问题很少由 Spring Cloud解决。</li>
<li>与分布式系统相关的复杂性 – 包括网络问题，延迟开销，带宽问题，安全问题。</li>
<li>处理服务发现的能力 – 服务发现允许集群中的进程和服务找到彼此并进行通信。</li>
<li>解决冗余问题 – 冗余问题经常发生在分布式系统中。</li>
<li>负载平衡 – 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布。</li>
<li>减少性能问题 – 减少因各种操作开销导致的性能问题。</li>
</ul>
<h1 id="在-Spring-MVC-应用程序中使用-WebMvcTest-注释有什么用处？"><a href="#在-Spring-MVC-应用程序中使用-WebMvcTest-注释有什么用处？" class="headerlink" title="在 Spring MVC 应用程序中使用 WebMvcTest 注释有什么用处？"></a>在 Spring MVC 应用程序中使用 WebMvcTest 注释有什么用处？</h1><ul>
<li>在测试目标只关注 Spring MVC 组件的情况下，WebMvcTest 注释用于单元测试Spring MVC 应用程序。在上面显示的快照中，我们只想启动 ToTestController。</li>
<li>执行此单元测试时，不会启动所有其他控制器和映射。</li>
</ul>
<h1 id="你能否给出关于休息和微服务的要点？"><a href="#你能否给出关于休息和微服务的要点？" class="headerlink" title="你能否给出关于休息和微服务的要点？"></a>你能否给出关于休息和微服务的要点？</h1><ul>
<li>虽然您可以通过多种方式实现微服务，但 REST over HTTP 是实现微服务的一种方式。REST 还可用于其他应用程序，如 Web 应用程序，API 设计和 MVC 应用程序，以提供业务数据。</li>
<li>微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用程序。</li>
<li>简而言之，您可以说 REST 是构建微服务的媒介。</li>
</ul>
<h1 id="什么是不同类型的微服务测试？"><a href="#什么是不同类型的微服务测试？" class="headerlink" title="什么是不同类型的微服务测试？"></a>什么是不同类型的微服务测试？</h1><ul>
<li>在使用微服务时，由于有多个微服务协同工作，测试变得非常复杂。因此，测试分为不同的级别。</li>
<li>在底层，我们有面向技术的测试，如单元测试和性能测试。这些是完全自动化的。</li>
<li>在中间层面，我们进行了诸如压力测试和可用性测试之类的探索性测试。</li>
<li>在顶层， 我们的 验收测试数量很少。这些验收测试有助于利益相关者理解和验证软件功能。</li>
</ul>
<h1 id="您对-Distributed-Transaction-有何了解？"><a href="#您对-Distributed-Transaction-有何了解？" class="headerlink" title="您对 Distributed Transaction 有何了解？"></a>您对 Distributed Transaction 有何了解？</h1><ul>
<li>分布式事务是指单个事件导致两个或多个不能以原子方式提交的单独数据源的突变的任何情况。在微服务的世界中，它变得更加复杂，因为每个服务都是一个工作单元，并且大多数时候多个服务必须协同工作才能使业务成功。</li>
</ul>
<h1 id="什么是-Idempotence-以及它在哪里使用？"><a href="#什么是-Idempotence-以及它在哪里使用？" class="headerlink" title="什么是 Idempotence 以及它在哪里使用？"></a>什么是 Idempotence 以及它在哪里使用？</h1><ul>
<li>幂等性是能够以这样的方式做两次事情的特性，即最终结果将保持不变，即好像它只做了一次。</li>
<li>用法：在远程服务或数据源中使用 Idempotence，这样当它多次接收指令时，它只处理指令一次。</li>
</ul>
<h1 id="什么是有界上下文？"><a href="#什么是有界上下文？" class="headerlink" title="什么是有界上下文？"></a>什么是有界上下文？</h1><ul>
<li>有界上下文是域驱动设计的核心模式。DDD 战略设计部门的重点是处理大型模型和团队。DDD 通过将大型模型划分为不同的有界上下文并明确其相互关系来处理大型模型。</li>
</ul>
<h1 id="什么是双因素身份验证？"><a href="#什么是双因素身份验证？" class="headerlink" title="什么是双因素身份验证？"></a>什么是双因素身份验证？</h1><ul>
<li>双因素身份验证为帐户登录过程启用第二级身份验证。</li>
<li>因此，假设用户必须只输入用户名和密码，那么这被认为是单因素身份验证。</li>
</ul>
<h1 id="什么是客户证书？"><a href="#什么是客户证书？" class="headerlink" title="什么是客户证书？"></a>什么是客户证书？</h1><ul>
<li>客户端系统用于向远程服务器发出经过身份验证的请求的一种数字证书称为客户端证书。客户端证书在许多相互认证设计中起着非常重要的作用，为请求者的身份提供了强有力的保证。</li>
</ul>
<h1 id="PACT-在微服务架构中的用途是什么？"><a href="#PACT-在微服务架构中的用途是什么？" class="headerlink" title="PACT 在微服务架构中的用途是什么？"></a>PACT 在微服务架构中的用途是什么？</h1><ul>
<li>PACT 是一个开源工具，允许测试服务提供者和消费者之间的交互，与合同隔离，从而提高微服务集成的可靠性。</li>
<li>微服务中的用法</li>
<li>用于在微服务中实现消费者驱动的合同。</li>
<li>测试微服务的消费者和提供者之间的消费者驱动的合同。</li>
<li>查看即将到来的批次</li>
</ul>
<h1 id="什么是-OAuth？"><a href="#什么是-OAuth？" class="headerlink" title="什么是 OAuth？"></a>什么是 OAuth？</h1><ul>
<li>OAuth 代表开放授权协议。这允许通过在 HTTP 服务上启用客户端应用程序（例如第三方提供商 Facebook，GitHub 等）来访问资源所有者的资源。因此，您可以在不使用其凭据的情况下与另一个站点共享存储在一个站点上的资源。</li>
</ul>
<h1 id="康威定律是什么？"><a href="#康威定律是什么？" class="headerlink" title="康威定律是什么？"></a>康威定律是什么？</h1><ul>
<li>“任何 设计 系统 的组 织（ 广泛 定义 ）都 将产 生一 种设 计， 其结 构是 组织 通信 结构的副 本。” – Mel Conway</li>
<li>该法律基本上试图传达这样一个事实：为了使软件模块起作用，整个团队应该进行良好的沟通。因此，系统的结构反映了产生它的组织的社会边界。</li>
</ul>
<h1 id="合同测试你懂什么？"><a href="#合同测试你懂什么？" class="headerlink" title="合同测试你懂什么？"></a>合同测试你懂什么？</h1><ul>
<li>根据 Martin Flower 的说法，合同测试是在外部服务边界进行的测试，用于验证其是否符合消费服务预期的合同。</li>
<li>此外，合同测试不会深入测试服务的行为。更确切地说，它测试该服务调用的输入＆输出包含所需的属性和所述响应延迟，吞吐量是允许的限度内。</li>
</ul>
<h1 id="什么是端到端微服务测试？"><a href="#什么是端到端微服务测试？" class="headerlink" title="什么是端到端微服务测试？"></a>什么是端到端微服务测试？</h1><ul>
<li>端到端测试验证了工作流中的每个流程都正常运行。这可确保系统作为一个整体协同工作并满足所有要求。</li>
<li>通俗地说，你可以说端到端测试是一种测试，在特定时期后测试所有东西。</li>
</ul>
<h1 id="Container-在微服务中的用途是什么？"><a href="#Container-在微服务中的用途是什么？" class="headerlink" title="Container 在微服务中的用途是什么？"></a>Container 在微服务中的用途是什么？</h1><ul>
<li>容器是管理基于微服务的应用程序以便单独开发和部署它们的好方法。您可以将微服务封装在容器映像及其依赖项中，然后可以使用它来滚动按需实例的微服务，而无需任何额外的工作。</li>
</ul>
<h1 id="什么是微服务架构中的-DRY？"><a href="#什么是微服务架构中的-DRY？" class="headerlink" title="什么是微服务架构中的 DRY？"></a>什么是微服务架构中的 DRY？</h1><ul>
<li>DRY 代表不要重复自己。它基本上促进了重用代码的概念。这导致开发和共享库，这反过来导致紧密耦合。</li>
</ul>
<h1 id="什么是消费者驱动的合同（CDC）？"><a href="#什么是消费者驱动的合同（CDC）？" class="headerlink" title="什么是消费者驱动的合同（CDC）？"></a>什么是消费者驱动的合同（CDC）？</h1><ul>
<li>这基本上是用于开发微服务的模式，以便它们可以被外部系统使用。当我们处理微服务时，有一个特定的提供者构建它，并且有一个或多个使用微服务的消费者。</li>
<li>通常，提供程序在 XML 文档中指定接口。但在消费者驱动的合同中，每个服务消费者都传达了提供商期望的接口。</li>
</ul>
<h1 id="Web，RESTful-API-在微服务中的作用是什么？"><a href="#Web，RESTful-API-在微服务中的作用是什么？" class="headerlink" title="Web，RESTful API 在微服务中的作用是什么？"></a>Web，RESTful API 在微服务中的作用是什么？</h1><ul>
<li>微服务架构基于一个概念，其中所有服务应该能够彼此交互以构建业务功能。因此，要实现这一点，每个微服务必须具有接口。这使得 Web API 成为微服务的一个非常重要的推动者。RESTful API 基于 Web 的开放网络原则，为构建微服务架构的各个组件之间的接口提供了最合理的模型。</li>
</ul>
<h1 id="您对微服务架构中的语义监控有何了解？"><a href="#您对微服务架构中的语义监控有何了解？" class="headerlink" title="您对微服务架构中的语义监控有何了解？"></a>您对微服务架构中的语义监控有何了解？</h1><ul>
<li>语义监控，也称为 综合监控， 将自动化测试与监控应用程序相结合，以检测业务失败因素。</li>
</ul>
<h1 id="我们如何进行跨功能测试？"><a href="#我们如何进行跨功能测试？" class="headerlink" title="我们如何进行跨功能测试？"></a>我们如何进行跨功能测试？</h1><ul>
<li>跨功能测试是对非功能性需求的验证，即那些无法像普通功能那样实现的需求。</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/publishes/6a0bdde6e107.html</url>
    <content><![CDATA[<h1 id="RabbitMQ-有哪些重要的角色？"><a href="#RabbitMQ-有哪些重要的角色？" class="headerlink" title="RabbitMQ 有哪些重要的角色？"></a>RabbitMQ 有哪些重要的角色？</h1><ul>
<li>生产者：消息的创建者，负责创建和推送数据到消息服务器</li>
<li>消费者：消息的接收方，用于处理数据和确认消息</li>
<li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色</li>
</ul>
<h1 id="RabbitMQ-有哪些重要的组件？"><a href="#RabbitMQ-有哪些重要的组件？" class="headerlink" title="RabbitMQ 有哪些重要的组件？"></a>RabbitMQ 有哪些重要的组件？</h1><ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用</li>
<li>Channel（信道）：消息推送使用的通道</li>
<li>Exchange（交换器）：用于接受、分配消息</li>
<li>Queue（队列）：用于存储生产者的消息</li>
<li>RoutingKey（路由键）：用于把生产者的数据分配到交换器上</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上</li>
</ul>
<h1 id="RabbitMQ-中-vhost-的作用是什么？"><a href="#RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="RabbitMQ 中 vhost 的作用是什么？"></a>RabbitMQ 中 vhost 的作用是什么？</h1><ul>
<li>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机</li>
<li>每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制</li>
</ul>
<h1 id="RabbitMQ的消息是怎么发送的？"><a href="#RabbitMQ的消息是怎么发送的？" class="headerlink" title="RabbitMQ的消息是怎么发送的？"></a>RabbitMQ的消息是怎么发送的？</h1><ul>
<li>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息</li>
<li>客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证，你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel）</li>
<li>认证就是你发送给 rabbit 服务器的用户名和密码</li>
<li>信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的</li>
</ul>
<h1 id="RabbitMQ-怎么保证消息的稳定性？"><a href="#RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="RabbitMQ 怎么保证消息的稳定性？"></a>RabbitMQ 怎么保证消息的稳定性？</h1><ul>
<li>提供了事务的功能</li>
<li>通过将 channel 设置为 confirm（确认）模式</li>
</ul>
<h1 id="RabbitMQ-怎么避免消息丢失？"><a href="#RabbitMQ-怎么避免消息丢失？" class="headerlink" title="RabbitMQ 怎么避免消息丢失？"></a>RabbitMQ 怎么避免消息丢失？</h1><ul>
<li>把消息持久化磁盘，保证服务器重启消息不丢失</li>
<li>每个集群中至少有一个物理磁盘，保证消息落入磁盘</li>
</ul>
<h1 id="RabbitMQ-持久化有什么缺点？"><a href="#RabbitMQ-持久化有什么缺点？" class="headerlink" title="RabbitMQ 持久化有什么缺点？"></a>RabbitMQ 持久化有什么缺点？</h1><ul>
<li>降低了服务器的吞吐量</li>
<li>因为使用的是磁盘而非内存存储，从而降低了吞吐量</li>
<li>可尽量使用 ssd 硬盘来缓解吞吐量的问题</li>
</ul>
<h1 id="RabbitMQ有几种广播类型？"><a href="#RabbitMQ有几种广播类型？" class="headerlink" title="RabbitMQ有几种广播类型？"></a>RabbitMQ有几种广播类型？</h1><ul>
<li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发。</li>
<li>headers：与 direct 类似，只是性能很差，此类型几乎用不到</li>
<li>fanout：分发模式，把消费分发给所有订阅者</li>
<li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到</li>
</ul>
<h1 id="RabbitMQ-怎么实现延迟消息队列？"><a href="#RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="RabbitMQ 怎么实现延迟消息队列？"></a>RabbitMQ 怎么实现延迟消息队列？</h1><ul>
<li>延迟队列的实现有两种方式：<ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能</li>
<li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ-集群有什么用？"><a href="#RabbitMQ-集群有什么用？" class="headerlink" title="RabbitMQ 集群有什么用？"></a>RabbitMQ 集群有什么用？</h1><ul>
<li>集群主要有以下两个用途：<ul>
<li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用</li>
<li>高容量：集群可以承载更多的消息量</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ-节点的类型有哪些？"><a href="#RabbitMQ-节点的类型有哪些？" class="headerlink" title="RabbitMQ 节点的类型有哪些？"></a>RabbitMQ 节点的类型有哪些？</h1><ul>
<li>磁盘节点：消息会存储到磁盘</li>
<li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型</li>
</ul>
<h1 id="RabbitMQ-集群搭建需要注意哪些问题？"><a href="#RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="RabbitMQ 集群搭建需要注意哪些问题？"></a>RabbitMQ 集群搭建需要注意哪些问题？</h1><ul>
<li>各节点之间使用“–link”连接，此属性不能忽略</li>
<li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证</li>
<li>整个集群中必须包含一个磁盘节点</li>
</ul>
<h1 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h1><ul>
<li>不是</li>
<li>原因有以下两个<ul>
<li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据</li>
<li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h1><ul>
<li>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点</li>
<li>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西</li>
</ul>
</li>
</ul>
<h1 id="RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗？"></a>RabbitMQ 对集群节点停止顺序有要求吗？</h1><ul>
<li>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点</li>
<li>如果顺序恰好相反的话，可能会造成消息的丢失</li>
</ul>
<h1 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h1><ul>
<li>以下四个条件都满足才能保证消息持久化成功<ul>
<li>声明队列必须设置持久化 durable 设置为 true</li>
<li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）</li>
<li>消息已经到达持久化交换器</li>
<li>消息已经到达持久化队列</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
