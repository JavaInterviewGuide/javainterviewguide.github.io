<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java后端面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/2/index.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/2/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java后端面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/fe062138c36d.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/fe062138c36d.html" class="post-title-link" itemprop="url">Memcached</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:10:21 / 修改时间：16:11:00" itemprop="dateCreated datePublished" datetime="2023-12-20T16:10:21+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>memcached是怎么工作的？ </p><p>Memcached的神奇来自两阶段哈希（two-stage hash）。Memcached就像一个巨大的、存储了很多&lt;key,value&gt;对的哈希表。通过key，可以存储或查询任意的数据。 </p><p>客户端可以把数据存储在多台memcached上。当查询数据时，客户端首先参考节点列表计算出key的哈希值（阶段一哈希），进而选中一个节点；客户端将请求发送给选中的节点，然后memcached节点通过一个内部的哈希算法（阶段二哈希），查找真正的数据（item）。 </p><p>举个列子，假设有3个客户端1, 2, 3，3台memcached A, B, C： <br>Client 1想把数据”barbaz”以key “foo”存储。Client 1首先参考节点列表（A, B, C），计算key “foo”的哈希值，假设memcached B被选中。接着，Client 1直接connect到memcached B，通过key “foo”把数据”barbaz”存储进去。　　Client 2使用与Client 1相同的客户端库（意味着阶段一的哈希算法相同），也拥有同样的memcached列表（A, B, C）。 <br>于是，经过相同的哈希计算（阶段一），Client 2计算出key “foo”在memcached B上，然后它直接请求memcached B，得到数据”barbaz”。 </p><p>各种客户端在memcached中数据的存储形式是不同的（perl Storable, php serialize, java hibernate, JSON等）。一些客户端实现的哈希算法也不一样。但是，memcached服务器端的行为总是一致的。 </p><p>最后，从实现的角度看，memcached是一个非阻塞的、基于事件的服务器程序。这种架构可以很好地解决C10K problem ，并具有极佳的可扩展性。 </p><p>可以参考A Story of Caching ，这篇文章简单解释了客户端与memcached是如何交互的。 </p><p>memcached最大的优势是什么？ </p><p>请仔细阅读上面的问题（即memcached是如何工作的）。Memcached最大的好处就是它带来了极佳的水平可扩展性，特别是在一个巨大的系统中。由于客户端自己做了一次哈希，那么我们很容易增加大量memcached到集群中。memcached之间没有相互通信，因此不会增加 memcached的负载；没有多播协议，不会网络通信量爆炸（implode）。memcached的集群很好用。内存不够了？增加几台 memcached吧；CPU不够用了？再增加几台吧；有多余的内存？在增加几台吧，不要浪费了。 </p><p>基于memcached的基本原则，可以相当轻松地构建出不同类型的缓存架构。除了这篇FAQ，在其他地方很容易找到详细资料的。 </p><p>看看下面的几个问题吧，它们在memcached、服务器的local cache和MySQL的query cache之间做了比较。这几个问题会让您有更全面的认识。 </p><p>memcached和MySQL的query cache相比，有什么优缺点？ </p><p>把memcached引入应用中，还是需要不少工作量的。MySQL有个使用方便的query cache，可以自动地缓存SQL查询的结果，被缓存的SQL查询可以被反复地快速执行。Memcached与之相比，怎么样呢？MySQL的query cache是集中式的，连接到该query cache的MySQL服务器都会受益。 </p><ul><li><p>当您修改表时，MySQL的query cache会立刻被刷新（flush）。存储一个memcached item只需要很少的时间，但是当写操作很频繁时，MySQL的query cache会经常让所有缓存数据都失效。 </p></li><li><p>在多核CPU上，MySQL的query cache会遇到扩展问题（scalability issues）。在多核CPU上，query cache会增加一个全局锁（global lock）, 由于需要刷新更多的缓存数据，速度会变得更慢。 </p></li><li><p>在 MySQL的query cache中，我们是不能存储任意的数据的（只能是SQL查询结果）。而利用memcached，我们可以搭建出各种高效的缓存。比如，可以执行多个独立的查询，构建出一个用户对象（user object），然后将用户对象缓存到memcached中。而query cache是SQL语句级别的，不可能做到这一点。在小的网站中，query cache会有所帮助，但随着网站规模的增加，query cache的弊将大于利。 </p></li><li><p>query cache能够利用的内存容量受到MySQL服务器空闲内存空间的限制。给数据库服务器增加更多的内存来缓存数据，固然是很好的。但是，有了memcached，只要您有空闲的内存，都可以用来增加memcached集群的规模，然后您就可以缓存更多的数据。 </p></li></ul><p>memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？ </p><p>首先，local cache有许多与上面(query cache)相同的问题。local cache能够利用的内存容量受到（单台）服务器空闲内存空间的限制。不过，local cache有一点比memcached和query cache都要好，那就是它不但可以存储任意的数据，而且没有网络存取的延迟。 </p><ul><li><p>local cache的数据查询更快。考虑把highly common的数据放在local cache中吧。如果每个页面都需要加载一些数量较少的数据，考虑把它们放在local cached吧。 </p></li><li><p>local cache缺少集体失效（group invalidation）的特性。在memcached集群中，删除或更新一个key会让所有的观察者觉察到。但是在local cache中, 我们只能通知所有的服务器刷新cache（很慢，不具扩展性），或者仅仅依赖缓存超时失效机制。 </p></li><li><p>local cache面临着严重的内存限制，这一点上面已经提到。 </p></li></ul><p>memcached的cache机制是怎样的？ </p><p>Memcached主要的cache机制是LRU（最近最少用）算法+超时失效。当您存数据到memcached中，可以指定该数据在缓存中可以呆多久Which is forever, or some time in the future。如果memcached的内存不够用了，过期的slabs会优先被替换，接着就轮到最老的未被使用的slabs。 </p><p>memcached如何实现冗余机制？ <br>不实现！我们对这个问题感到很惊讶。Memcached应该是应用的缓存层。它的设计本身就不带有任何冗余机制。如果一个memcached节点失去了所有数据，您应该可以从数据源（比如数据库）再次获取到数据。您应该特别注意，您的应用应该可以容忍节点的失效。不要写一些糟糕的查询代码，寄希望于 memcached来保证一切！如果您担心节点失效会大大加重数据库的负担，那么您可以采取一些办法。比如您可以增加更多的节点（来减少丢失一个节点的影响），热备节点（在其他节点down了的时候接管IP），等等。 </p><p>memcached如何处理容错的？ <br>不处理！:) 在memcached节点失效的情况下，集群没有必要做任何容错处理。如果发生了节点失效，应对的措施完全取决于用户。节点失效时，下面列出几种方案供您选择： </p><ul><li><p>忽略它！ 在失效节点被恢复或替换之前，还有很多其他节点可以应对节点失效带来的影响。 </p></li><li><p>把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下（余数式哈希算法），客户端添加或移除节点，会导致所有的缓存数据不可用！因为哈希参照的节点列表变化了，大部分key会因为哈希值的改变而被映射到（与原来）不同的节点上。 </p></li><li><p>启动热备节点，接管失效节点所占用的IP。这样可以防止哈希紊乱（hashing chaos）。 </p></li><li><p>如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈希算法（consistent hashing）。您可以百度一下一致性哈希算法。支持一致性哈希的客户端已经很成熟，而且被广泛使用。去尝试一下吧！ </p></li><li><p>两次哈希（reshing）。当客户端存取数据时，如果发现一个节点down了，就再做一次哈希（哈希算法与前一次不同），重新选择另一个节点（需要注意的时，客户端并没有把down的节点从节点列表中移除，下次还是有可能先哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和坏的节点上都可能存在脏数据（stale data）。 </p></li></ul><p>如何将memcached中item批量导入导出？ </p><p>您不应该这样做！Memcached是一个非阻塞的服务器。任何可能导致memcached暂停或瞬时拒绝服务的操作都应该值得深思熟虑。向 memcached中批量导入数据往往不是您真正想要的！想象看，如果缓存数据在导出导入之间发生了变化，您就需要处理脏数据了；如果缓存数据在导出导入之间过期了，您又怎么处理这些数据呢？ </p><p>因此，批量导出导入数据并不像您想象中的那么有用。不过在一个场景倒是很有用。如果您有大量的从不变化的数据，并且希望缓存很快热（warm）起来，批量导入缓存数据是很有帮助的。虽然这个场景并不典型，但却经常发生，因此我们会考虑在将来实现批量导出导入的功能。 </p><p>Steven Grimm，一如既往地,，在邮件列表中给出了另一个很好的例子：<a target="_blank" rel="noopener" href="http://lists.danga.com/pipermail/memcached/2007-July/004802.html">http://lists.danga.com/pipermail/memcached/2007-July/004802.html</a> 。 </p><p>我需要把memcached中的item批量导出导入，怎么办？ </p><p>好吧好吧。如果您需要批量导出导入，最可能的原因一般是重新生成缓存数据需要消耗很长的时间，或者数据库坏了让您饱受痛苦。 </p><p>如果一个memcached节点down了让您很痛苦，那么您还会陷入其他很多麻烦。您的系统太脆弱了。您需要做一些优化工作。比如处理”惊群”问题（比如 memcached节点都失效了，反复的查询让您的数据库不堪重负…这个问题在FAQ的其他提到过），或者优化不好的查询。记住，Memcached 并不是您逃避优化查询的借口。 </p><p>如果您的麻烦仅仅是重新生成缓存数据需要消耗很长时间（15秒到超过5分钟），您可以考虑重新使用数据库。这里给出一些提示： </p><ul><li>使用MogileFS（或者CouchDB等类似的软件）在存储item。把item计算出来并dump到磁盘上。MogileFS可以很方便地覆写 item，并提供快速地访问。您甚至可以把MogileFS中的item缓存在memcached中，这样可以加快读取速度。 MogileFS+Memcached的组合可以加快缓存不命中时的响应速度，提高网站的可用性。 </li><li>重新使用MySQL。MySQL的InnoDB主键查询的速度非常快。如果大部分缓存数据都可以放到VARCHAR字段中，那么主键查询的性能将更好。从 memcached中按key查询几乎等价于MySQL的主键查询：将key 哈希到64-bit的整数，然后将数据存储到MySQL中。您可以把原始（不做哈希）的key存储都普通的字段中，然后建立二级索引来加快查询…key被动地失效，批量删除失效的key，等等。 </li></ul><p>上面的方法都可以引入memcached，在重启memcached的时候仍然提供很好的性能。由于您不需要当心”hot”的item被 memcached LRU算法突然淘汰，用户再也不用花几分钟来等待重新生成缓存数据（当缓存数据突然从内存中消失时），因此上面的方法可以全面提高性能。 </p><p>关于这些方法的细节，详见博客：<a target="_blank" rel="noopener" href="http://dormando.livejournal.com/495593.html">http://dormando.livejournal.com/495593.html</a> 。 </p><p>memcached是如何做身份验证的？ <br>没有身份认证机制！memcached是运行在应用下层的软件（身份验证应该是应用上层的职责）。memcached的客户端和服务器端之所以是轻量级的，部分原因就是完全没有实现身份验证机制。这样，memcached可以很快地创建新连接，服务器端也无需任何配置。 </p><p>如果您希望限制访问，您可以使用防火墙，或者让memcached监听unix domain socket。 </p><p>memcached的多线程是什么？如何使用它们？ <br>线程就是定律（threads rule）！在Steven Grimm和Facebook的努力下，memcached 1.2及更高版本拥有了多线程模式。多线程模式允许memcached能够充分利用多个CPU，并在CPU之间共享所有的缓存数据。memcached使用一种简单的锁机制来保证数据更新操作的互斥。相比在同一个物理机器上运行多个memcached实例，这种方式能够更有效地处理multi gets。 </p><p>如果您的系统负载并不重，也许您不需要启用多线程工作模式。如果您在运行一个拥有大规模硬件的、庞大的网站，您将会看到多线程的好处。 </p><p>简单地总结一下：命令解析（memcached在这里花了大部分时间）可以运行在多线程模式下。memcached内部对数据的操作是基于很多全局锁的（因此这部分工作不是多线程的）。未来对多线程模式的改进，将移除大量的全局锁，提高memcached在负载极高的场景下的性能。 </p><p>memcached能接受的key的最大长度是多少？ <br>key的最大长度是250个字符。需要注意的是，250是memcached服务器端内部的限制，如果您使用的客户端支持”key的前缀”或类似特性，那么key（前缀+原始key）的最大长度是可以超过250个字符的。我们推荐使用使用较短的key，因为可以节省内存和带宽。 </p><p>memcached对item的过期时间有什么限制？ <br>过期时间最大可以达到30天。memcached把传入的过期时间（时间段）解释成时间点后，一旦到了这个时间点，memcached就把item置为失效状态。这是一个简单但obscure的机制。 </p><p>memcached最大能存储多大的单个item？ <br>1MB。如果你的数据大于1MB，可以考虑在客户端压缩或拆分到多个key中。 </p><p>为什么单个item的大小被限制在1M byte之内？ </p><p>简单的回答：因为内存分配器的算法就是这样的。 </p><p>详细的回答：Memcached的内存存储引擎（引擎将来可插拔…），使用slabs来管理内存。内存被分成大小不等的slabs chunks（先分成大小相等的slabs，然后每个slab被分成大小相等chunks，不同slab的chunk大小是不相等的）。chunk的大小依次从一个最小数开始，按某个因子增长，直到达到最大的可能值。 </p><p>如果最小值为400B，最大值是1MB，因子是1.20，各个slab的chunk的大小依次是：slab1 – 400B slab2 – 480B slab3 – 576B … </p><p>slab中chunk越大，它和前面的slab之间的间隙就越大。因此，最大值越大，内存利用率越低。Memcached必须为每个slab预先分配内存，因此如果设置了较小的因子和较大的最大值，会需要更多的内存。 </p><p>还有其他原因使得您不要这样向memcached中存取很大的数据…不要尝试把巨大的网页放到mencached中。把这样大的数据结构load和unpack到内存中需要花费很长的时间，从而导致您的网站性能反而不好。 </p><p>如果您确实需要存储大于1MB的数据，你可以修改slabs.c:POWER_BLOCK的值，然后重新编译memcached；或者使用低效的malloc/free。其他的建议包括数据库、MogileFS等。 </p><p>我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？ <br>Memcache客户端仅根据哈希算法来决定将某个key存储在哪个节点上，而不考虑节点的内存大小。因此，您可以在不同的节点上使用大小不等的缓存。但是一般都是这样做的：拥有较多内存的节点上可以运行多个memcached实例，每个实例使用的内存跟其他节点上的实例相同。 </p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/2f1abbd5b4e4.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/2f1abbd5b4e4.html" class="post-title-link" itemprop="url">Mybatis</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:08:45 / 修改时间：16:09:01" itemprop="dateCreated datePublished" datetime="2023-12-20T16:08:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Mybatis部分<br>1.JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？<br>① 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</p><p>② Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p><p>③ 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<br>解决： Mybatis自动将java对象映射至sql语句。</p><p>④ 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象。<br>2.MyBatis编程步骤是什么样的？<br>① 创建SqlSessionFactory<br>② 通过SqlSessionFactory创建SqlSession<br>③ 通过sqlsession执行数据库操作<br>④ 调用session.commit()提交事务<br>⑤ 调用session.close()关闭会话<br>3.MyBatis与Hibernate有哪些不同？<br>    Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。<br> <br>    Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。<br> <br>    Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。<br>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 <br>4.使用MyBatis的mapper接口调用时有哪些要求？<br>①  Mapper接口方法名和mapper.xml中定义的每个sql的id相同<br>②  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同<br>③  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同<br>④  Mapper.xml文件中的namespace即是mapper接口的类路径。<br>5.SqlMapConfig.xml中配置有哪些内容？<br>SqlMapConfig.xml中配置的内容和顺序如下： <br>properties（属性）<br>settings（配置）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境集合属性对象）<br>environment（环境子属性对象）<br>transactionManager（事务管理）<br>dataSource（数据源）<br>mappers（映射器）<br>6.简单的说一下MyBatis的一级缓存和二级缓存？<br>Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象</p><p>Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。<br>7.Mapper编写有哪几种方式？<br>①接口实现类继承SqlSessionDaoSupport<br>使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件<br>1、在sqlMapConfig.xml中配置mapper.xml的位置</p><p>1<mappers><br>2    <mapper resource="mapper.xml文件的地址"><br>3    <mapper resource="mapper.xml文件的地址"><br>4</mappers></p><p>2、定义mapper接口<br>3、实现类集成SqlSessionDaoSupport<br>mapper方法中可以this.getSqlSession()进行数据增删改查。<br>4、spring 配置</p><p>1<bean class="mapper接口的实现"><br>2    <property name="sqlSessionFactory" ref="sqlSessionFactory"></property><br>3</bean><br>②使用org.mybatis.spring.mapper.MapperFactoryBean</p><p>1、在sqlMapConfig.xml中配置mapper.xml的位置<br>如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置</p><p>1<mappers><br>2    <mapper resource="mapper.xml文件的地址"><br>3    <mapper resource="mapper.xml文件的地址"><br>4</mappers></p><p>2、定义mapper接口<br>注意<br>1、mapper.xml中的namespace为mapper接口的地址<br>2、mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致<br>3、 Spring中定义</p><p>1<bean class="org.mybatis.spring.mapper.MapperFactoryBean"><br>2    <property name="mapperInterface" value="mapper接口地址">  <br>3    <property name="sqlSessionFactory" ref="sqlSessionFactory">  <br>4</bean><br>③使用mapper扫描器</p><p>1、mapper.xml文件编写，<br>注意：<br>mapper.xml中的namespace为mapper接口的地址<br>mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致<br>如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置 <br>2、定义mapper接口<br>注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录<br>3、配置mapper扫描器</p><p>1<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"><br>2    <property name="basePackage" value="mapper接口包地址"></property><br>3    <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"> <br>4</bean><br>4、使用扫描器后从spring容器中获取mapper的实现对象</p><p>扫描器将接口通过代理方法生成实现对象，要spring容器中自动注册，名称为mapper 接口的名称。</p><ol><li>#{}和${}的区别是什么？<br>#{}是预编译处理，${}是字符串替换。<br>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set<br>方法来赋值；<br>Mybatis 在处理${}时，就是把${}替换成变量的值。<br>使用#{}可以有效的防止 SQL 注入，提高系统安全性。</li><li>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，<br>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，<br>参数不同时，方法能重载吗？<br>Dao 接口，就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace<br>的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，<br>就是传递给 sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+<br>方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement，举例：<br>com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为<br>com.mybatis3.mappers.StudentDao 下面 id = findStudentById 的<br>MappedStatement。在 Mybatis 中，每一个<select>、<insert>、<update>、<delete><br>标签，都会被解析为一个 MappedStatement 对象。<br>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。<br>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao<br>接 口 生 成 代 理 proxy 对 象 ， 代 理 对 象 proxy 会 拦 截 接 口 方 法 ， 转 而 执 行<br>MappedStatement 所代表的 sql，然后将 sql 执行结果返回。</delete></update></insert></select></li><li>Mybatis 是如何进行分页的？分页插件的原理是什么？<br>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，<br>而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使<br>用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的<br>拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分<br>页语句和物理分页参数。</li><li>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？<br>都有哪些映射形式？<br>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。第二<br>种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，<br>对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小<br>写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。<br>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象<br>的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</resultmap></li><li>Xml 映射文件中，除了常见的 select|insert|update|delete 标<br>签之外，还有哪些标签？<br>注：这道题出自京东面试官。<br>还 有 很 多 其 他 的 标 签 ， 加 上 动 态 sql 的 9 个 标 签 ，<br>trim|where|set|foreach|if|choose|when|otherwise|bind 等 ， 其 中 为 sql 片<br>段标签，通过标签引入 sql 片段，为不支持自增的主键生成策略标签。</li><li>简述 Mybatis 的插件运行原理，以及如何编写一个插件<br>Mybatis 仅 可 以 编 写 针 对 ParameterHandler 、 ResultSetHandler 、<br>StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，<br>为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象<br>的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当<br>然，只会拦截那些你指定需要拦截的方法。实现 Mybatis 的 Interceptor 接口并复写<br>intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，<br>记住，还需要在配置文件中配置你编写的插件。</li><li>一级、二级缓存<br>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为<br>Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将<br>清空。<br>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存<br>储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如<br>Ehcache。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：<cache><br>3 ） 对 于 缓 存 数 据 更 新 机 制 ， 当 某 一 个 作 用 域 ( 一 级 缓 存 Session/ 二 级 缓 存<br>Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将<br>被 clear。</li><li>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什<br>么？<br>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，<br>association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文<br>件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。<br>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截<br>器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null<br>值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调<br>用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的<br>调用。这就是延迟加载的基本原理。</li><li>Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标<br>签的内容，请问，B 标签能否定义在 A 标签的后面，还是说<br>必须定义在 A 标签的前面？<br>虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可<br>以定义在任何地方，Mybatis 都可以正确识别。<br>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，<br>尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，<br>包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标<br>签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</li><li>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之<br>间的映射关系？<br>Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内<br>部。在 Xml 映射文件中，<parametermap>标签会被解析为 ParameterMap 对象，<br>其每个子元素会被解析为 ParameterMapping 对象。<resultmap>标签会被解析为<br>ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、<br><insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签<br>内的 sql 会被解析为 BoundSql 对象。</delete></update></insert></select></resultmap></parametermap></li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/b318dfbd2190.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/b318dfbd2190.html" class="post-title-link" itemprop="url">Netty</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:07:22 / 修改时间：16:30:10" itemprop="dateCreated datePublished" datetime="2023-12-20T16:07:22+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>1.BIO、NIO和AIO的区别？<br>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。<br>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。<br>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br>AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</p><p>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的。</p><p>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。</p><p>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</p><p>2.NIO的组成？<br>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</p><p>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式<br>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。<br>rewind方法 ： 重绕此缓冲区，将position置为0<br>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</p><p>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！</p><p>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</p><p>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</p><p>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</p><p>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取</p><p>NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</p><p>3.Netty的特点？<br>一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持<br>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。<br>采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理<br>可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持<br>可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf<br>通过引用计数器及时申请释放不再引用的对象，降低了GC频率<br>使用单线程串行化的方式，高效的Reactor线程模型<br>大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用<br>4.Netty的线程模型？<br>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。</p><p>单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</p><p>多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</p><p>主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；</p><p>5.TCP 粘包/拆包的原因及解决方法？<br>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p><p>TCP粘包/分包的原因：</p><p>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；<br>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包<br>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。<br>解决方法</p><p>消息定长：FixedLengthFrameDecoder类<br>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder<br>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。<br>6.了解哪几种序列化协议？<br>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</p><p>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</p><p>Java默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差</p><p>XML，优点：人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。</p><p>JSON，是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</p><p>Fastjson，采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前java语言中最快的json库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web输出、Android客户端</p><p>Thrift，不仅是序列化协议，还是一个RPC框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的RPC解决方案</p><p>Avro，Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</p><p>Protobuf，将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</p><p>其它</p><p>protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可<br>Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口<br>Message pack 一个高效的二进制序列化格式<br>Hessian 采用二进制协议的轻量级remoting onhttp工具<br>kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）<br>7.如何选择序列化协议？<br>具体场景</p><p>对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。<br>基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。<br>对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。<br>当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。<br>对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。<br>对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。<br>如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。<br>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。<br>protobuf的数据类型有多种：bool、double、float、int32、int64、string、bytes、enum、message。protobuf的限定符：required: 必须赋值，不能为空、optional:字段可以赋值，也可以不赋值、repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；</p><p>protobuf的基本规则：每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段；repeated表示的字段可以包含0个或多个数据；[1,15]之内的标识号在编码的时候会占用一个字节（常用），[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。</p><p>protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。</p><p>编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder = UserProto.User.newBuilder();builder.build()；</p><p>Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类</p><p>将StringBuilder转换为ByteBuf类型：copiedBuffer()方法</p><p>8.Netty的零拷贝实现？<br>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</p><p>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</p><p>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。</p><p>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</p><p>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</p><p>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。</p><p>9.Netty的高性能表现在哪些方面？<br>心跳，对服务端：会定时清除闲置会话inactive(netty5)，对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态</p><p>串行无锁化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</p><p>可靠性，链路有效性检测：链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</p><p>Netty安全性：支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。</p><p>高效并发编程的体现：volatile的大量、正确使用；CAS和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）</p><p>流量整型的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。</p><p>TCP参数配置：SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</p><p>10.NIOEventLoopGroup源码？</p><p>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。</p><p>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回。如果taskQueue没有元素，执行 select(oldWakenUp) 方法</p><p>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。</p><p>rebuildSelector方法先通过openSelector方法创建一个新的selector。然后将old selector的selectionKey执行cancel。最后将old selector的channel重新注册到新的selector中。rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</p><p>接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。</p><p>最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。</p><p>每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。</p><p>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。</p><p>内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。</p><p>ByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读/写模式，读取和写入索引分开；方法链；引用计数基于AtomicIntegerFieldUpdater用于内存回收；PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/0777702c9d7f.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/0777702c9d7f.html" class="post-title-link" itemprop="url">RPC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:06:30 / 修改时间：16:06:42" itemprop="dateCreated datePublished" datetime="2023-12-20T16:06:30+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rpc/" itemprop="url" rel="index"><span itemprop="name">rpc</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>为什么说程序员到了不得不掌握RPC的时候了！</p><p>原文标题：《深入理解RPC——RPC在企业服务中的核心价值》<br>随着企业 IT 服务的不断发展，单台服务器逐渐无法承受用户日益增长的请求压力时，就需要多台服务器联合起来构成「服务集群」共同对外提供服务。同时业务服务会随着产品需求的增多越来越肿，架构上必须进行服务拆分，一个完整的大型服务会被打散成很多很多独立的小服务，每个小服务会由独立的进程去管理来对外提供服务，这就是「微服务」。<br>当用户的请求到来时，我们需要将用户的请求分散到多个服务去各自处理，然后又需要将这些子服务的结果汇总起来呈现给用户。那么服务之间该使用何种方式进行交互就是需要解决的核心问题。RPC 就是为解决服务之间信息交互而发明和存在的。<br>一、什么是 RPC ？<br>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</p><p>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。<br>RPC 在我们熟知的各种中间件中都有它的身影。Nginx/Redis/MySQL/Dubbo/Hadoop/Spark/Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。<br>二、Nginx 与 RPC<br>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。如图，Django 是 Python 技术栈最流行的 Web 框架。</p><p>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。</p><p>你说的没错，不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。如上图所示，uWSGI 是著名的 Python 容器，使用它可以启动 uwsgi 协议的服务器对外提供服务。<br>uwsgi 通讯协议在 Python 语言体系里使用非常普遍，如果一个企业内部使用 Python 语言栈搭建 Web 服务，那么他们在生产环境部署 Python 应用的时候不是在使用 HTTP 协议就是在使用 uwsgi 协议来和 Nginx 之间建立通讯。</p><p>Fastcgi 协议在 PHP 语言体系里非常常见，Nginx 和 PHP-fpm 进程之间一般较常使用 Fastcgi 协议进行通讯。<br>三、Hadoop 与 RPC<br>在大数据技术领域，RPC 也占据了非常重要的地位。大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在。大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。</p><p>比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。<br>四、TensorFlow 与 RPC<br>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯。Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</p><p>五、HTTP 调用其实也是一种特殊的 RPC<br>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</p><p>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了。所以在后文我们不再明确强调 RPC 和 HTTP 请求调用之间的细微区别了，直接统一称之为 RPC。</p><p>六、HTTP VS RPC （普通话 VS 方言）<br>HTTP 与 RPC 的关系就好比普通话与方言的关系。要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本。但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源。整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。虽然国家一直在提倡使用普通话交流，但是这么多年过去了，你回一趟家乡探个亲什么的就会发现身边的人还是流行说方言。<br>如果再深入一点说，普通话本质上也是一种方言，只不过它是官方的方言，使用最为广泛的方言，相比而言其它方言都是小语种，小语种之中也会有几个使用比较广泛比较特色的方言占比也会比较大。这就好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。<br>七、换个角度看世界<br>如果两个子系统没有在网络上进行分离，而是运行在同一个操作系统实例之上的两个进程时，它们之间的通信手段还可以更加丰富。除了以上提到的几种分布式解决方案之外，还有共享内存、信号量、文件系统、内核消息队列、管道等，本质上都是通过操作系统内核机制来进行数据和消息的交互而无须经过网络协议栈。<br>但在现代企业服务中，这种单机应用已经非常少见了，因为单机应用意味着单点故障 —— “一人摔跤全家跌倒”。业务子系统往往都需要经物理网络栈进行隔离，因此分布式解决方案在要求高可用无间断服务的企业环境里便大有作为，这也让 RPC 迎来自己大放异彩的时代。<br>前文提到的分布式子系统交互方案，除了 RPC 技术之外还有数据库、消息队列和缓存。但其实这三者本质上是 RPC 技术的一个应用组合。我们可以将数据库服务理解为下面这张图：</p><p>可以看出，子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL。在互联网企业里一般都会使用这种主从读写分离的数据库。一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来。这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</p><p>八、小结<br>现在，读者应该可以深刻理解 RPC 在互联网企业技术中的重要地位。从技术复杂性角度，也应该可以明白为什么说对 RPC 技术的理解水平是评判一个程序员是不是高级程序员的重要标准之一。<br>在下一节，我们将对 RPC 的交互原理进行深入的学习，先把地基打牢，再开始实战开发。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/235b69f65d9c.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/235b69f65d9c.html" class="post-title-link" itemprop="url">Spring MVC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:05:16 / 修改时间：16:05:42" itemprop="dateCreated datePublished" datetime="2023-12-20T16:05:16+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring-MVC/" itemprop="url" rel="index"><span itemprop="name">Spring MVC</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>SpringMVC部分<br>1.简单的谈一下SpringMVC的工作流程？</p><p>流程<br>1、用户发送请求至前端控制器DispatcherServlet<br>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>3、处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。<br>4、DispatcherServlet调用HandlerAdapter处理器适配器<br>5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。<br>6、Controller执行完成返回ModelAndView<br>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet<br>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>9、ViewReslover解析后返回具体View<br>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。<br>11、DispatcherServlet响应用户<br>2.如何解决POST请求中文乱码问题，GET的又如何处理呢？<br>在web.xml中加入：</p><p>1<filter><br>2    <filter-name>CharacterEncodingFilter</filter-name><br>3    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class><br>4    <init-param><br>5        <param-name>encoding</param-name><br>6        <param-value>utf-8</param-value><br>7    </init-param><br>8</filter><br>9<filter-mapping><br>10    <filter-name>CharacterEncodingFilter</filter-name><br>11    <url-pattern>/*</url-pattern><br>12</filter-mapping><br>以上可以解决post请求乱码问题。对于get请求中文参数出现乱码解决方法有两个：<br>修改tomcat配置文件添加编码与工程编码一致，如下：</p><p>1<connector uriencoding="utf-8" connectiontimeout="20000" port="8080" protocol="HTTP/1.1" redirectport="8443"></p><p> 另外一种方法对参数进行重新编码：</p><p>1String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),”utf-8”)</p><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码<br>3.SpringMVC与Struts2的主要区别？<br>①springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。<br>②springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。<br>③Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。 Jsp视图解析器默认使用jstl。</p><p>1、什么是SpringMvc？<br>答：SpringMvc是spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。<br>2、Spring MVC的优点：<br>答：</p><p>1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成. </p><p> 2）不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的) </p><p> 3）可以任意使用各种视图技术,而不仅仅局限于JSP </p><p> 4）支持各种请求资源的映射策略 </p><p> 5）它应是易于扩展的</p><p>3、SpringMVC工作原理？<br>答：</p><p> 1）客户端发送请求到DispatcherServlet </p><p> 2）DispatcherServlet查询handlerMapping找到处理请求的Controller </p><p> 3）Controller调用业务逻辑后，返回ModelAndView </p><p> 4）DispatcherServlet查询ModelAndView，找到指定视图 </p><p> 5）视图将结果返回到客户端</p><p>4、SpringMVC流程？<br>答： </p><p> 1）用户发送请求至前端控制器DispatcherServlet。 </p><p> 2）DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p><p> 3）处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </p><p> 4）DispatcherServlet调用HandlerAdapter处理器适配器。 </p><p> 5）HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </p><p> 6）Controller执行完成返回ModelAndView。 </p><p> 7）HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 </p><p> 8）DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </p><p> 9）ViewReslover解析后返回具体View。 </p><p> 10）DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </p><p> 11）DispatcherServlet响应用户。</p><p>6、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？<br>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。<br>7、如果你也用过struts2.简单介绍下springMVC和struts2的区别有哪些?<br>答： </p><p> 1）springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</p><p> 2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p><p> 3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p><p>8、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？<br>答：一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。<br>9、 @RequestMapping注解用在类上面有什么作用？<br>答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>10、怎么样把某个请求映射到特定的方法上面？<br>答：直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径<br>11、如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？<br>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET<br>12、怎么样在方法里面得到Request,或者Session？<br>答：直接在方法的形参中声明request,SpringMvc就自动把request对象传入<br>13、我想在拦截的方法里面得到从前台传入的参数,怎么得到？<br>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样<br>14、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？<br>答：直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。<br>15、SpringMvc中函数的返回值是什么？<br>答：返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。<br>16、SpringMVC怎么样设定重定向和转发的？<br>答：在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name=method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a><br>17、SpringMvc用什么对象从后台向前台传递数据的？<br>答：通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。<br>18、SpringMvc中有个类把视图和数据都合并的一起的,叫什么？<br>答：叫ModelAndView。<br>19、怎么样把ModelMap里面的数据放入Session里面？<br>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key<br>20、SpringMvc怎么和AJAX相互调用的？<br>答：</p><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。 </p><p> 具体步骤如下 ：</p><p>     1）加入Jackson.jar </p><p>     2）在配置文件中配置json的映射 </p><p>     3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</p><p>21、当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？<br>答：要加上@ResponseBody注解<br>22、SpringMvc里面拦截器是怎么写的<br>答：有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可： </p><p><a href="mvc:interceptors">mvc:interceptors</a><br><br><bean id="myInterceptor" class="com.et.action.MyHandlerInterceptor"></bean><br><br><a href="mvc:interceptor">mvc:interceptor</a><br>&lt;mvc:mapping path=”/modelMap.do” /&gt;<br><bean class="com.et.action.MyHandlerInterceptorAdapter"><br><br><br>23、讲下SpringMvc的执行流程<br>答：系统启动的时候根据配置文件创建spring的容器, 首先是发送http请求到核心控制器disPatherServlet，spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用ModelAndView进行视图转发，数据放在model中，用map传递数据进行页面显示。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/c9fa4a3e43dd.html" class="post-title-link" itemprop="url">Spring</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:03:58 / 修改时间：18:26:54" itemprop="dateCreated datePublished" datetime="2023-12-20T16:03:58+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><p>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题。这些交叉问题与应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。</p><ol><li>Spring中Bean的⽣命周期。<br>Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅<br>法-》调⽤InitializationBean的afterPropertiesSet()的⽅法-》调⽤定制的初始化⽅法callCustom的init-method-》调⽤<br>BeanPostProsessor的后初始化⽅法-》Bean可以使⽤了 -》 容器关闭-》 调⽤DisposableBean的destroy⽅法-》调⽤定<br>制的销毁⽅法CallCustom的destroy-method。<br>1、Spring对Bean进⾏实例化（相当于程序中的new Xx()）<br>2、Spring将值和Bean的引⽤注⼊进Bean对应的属性中<br>3、如果Bean实现了BeanNameAware接⼝，Spring将Bean的ID传递给setBeanName()⽅法（实现BeanNameAware清主<br>要是为了通过Bean的引⽤来获得Bean的ID，⼀般业务中是很少有⽤到Bean的ID的）<br>4、如果Bean实现了BeanFactoryAware接⼝，Spring将调⽤setBeanDactory(BeanFactory bf)⽅法并把BeanFactory容器<br>实例作为参数传⼊。（实现BeanFactoryAware 主要⽬的是为了获取Spring容器，如Bean通过Spring容器发布事件等）<br>5、如果Bean实现了ApplicationContextAwaer接⼝，Spring容器将调⽤setApplicationContext(ApplicationContext ctx)<br>⽅法，把y应⽤上下⽂作为参数传⼊.(作⽤与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调⽤<br>setApplicationContext⽅法时会把它⾃⼰作为setApplicationContext 的参数传⼊，⽽Spring容器在调⽤setBeanDactory<br>前需要程序员⾃⼰指定（注⼊）setBeanDactory⾥的参数BeanFactory )<br>7、如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessBeforeInitialization（预初始化）⽅法（作<br>⽤是在Bean实例创建成功后对进⾏增强处理，如对Bean进⾏修改，增加某个功能）7.如果Bean实现了InitializingBean接<br>⼝，Spring将调⽤它们的afterPropertiesSet⽅法，作⽤与在配置⽂件中对Bean使⽤init-method声明初始化的作⽤⼀样，<br>都是在Bean的全部属性设置成功后执⾏的初始化⽅法。<br>8、如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessAfterInitialization（后初始化）⽅法（作<br>⽤与7的⼀样，只不过7是在Bean初始化前执⾏的，⽽这个是在Bean初始化后执⾏的，时机不同 )<br>9、经过以上的⼯作后，Bean将⼀直驻留在应⽤上下⽂中给应⽤使⽤，直到应⽤上下⽂被销毁<br>10、如果Bean实现了DispostbleBean接⼝，Spring将调⽤它的destory⽅法，作⽤与在配置⽂件中对Bean使⽤destory￾method属性的作⽤⼀样，都是在Bean实例销毁前执⾏的⽅法。</li><li>SpringBoot项⽬启动时执⾏特定的⽅法：<br>我们可以通过实现ApplicationRunner和CommandLineRunner，来实现，他们都是在SpringApplication 执⾏之后开始执<br>⾏的。</li><li>SpringMVC处理请求的流程。<br>1、请求解析和匹配DipatcherServlet路径：客户端发出⼀个http请求给web服务器，web服务器对http请求进⾏解析，<br>如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet.<br>2、匹配处理器Handler：DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http⽅法、请求报⽂头<br>和请求参数Cookie等）以及HandlerMapping的配置找到处理请求的处理器（Handler）。<br>3-4、处理器进⾏处理：DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给<br>Handler（Handler将具体的处理进⾏封装），再由具体的HandlerAdapter对Handler进⾏具体的调⽤。<br>5、处理器返回逻辑视图ModelAndView对象给DispatcherServlet：Handler对数据处理完成以后将返回⼀个<br>ModelAndView()对象给DispatcherServlet。<br>6、Dispatcher通过ViewResolver将逻辑视图转化为正式视图view：Handler返回的ModelAndView()只是⼀个逻辑视<br>图并不是⼀个正式的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。<br>7、Dispatcher通过model解析出ModelAndView()中的参数进⾏解析最终展现出完整的view并返回给客户端。</li><li>Spring AOP解决了什么问题？怎么实现的？<br>a. <a target="_blank" rel="noopener" href="https://blog.csdn.net/moreevan/article/details/11977115/">https://blog.csdn.net/moreevan/article/details/11977115/</a><br>b. 作⽤：AOP技术，利⽤⼀种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共⾏为封装到⼀<br>个可重⽤模块，并将其名为“Aspect”，即⽅⾯。所谓“⽅⾯”，简单地说，就是将那些与业务⽆关，却为业务模块所共同<br>调⽤的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。<br>c. 实现：<br>i. ⼀是采⽤动态代理技术，利⽤截取消息的⽅式，对该消息进⾏装饰，以取代原有对象⾏为的执⾏；<br>ii. ⼆是采⽤静态织⼊的⽅式，引⼊特定的语法创建“⽅⾯”，从⽽使得编译器可以在编译期间织⼊有关“⽅⾯”的代<br>码。<br>d. 使⽤场景：</li><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading　懒加载</li><li>Debugging　　调试</li><li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li><li>Performance optimization　性能优化</li><li>Persistence　　持久化</li><li>Resource pooling　资源池</li><li>Synchronization　同步</li><li>Transactions 事务<br>e. ⼏个概念：</li><li>切⾯（Aspect）：对象操作过程中的截⾯，这可能是AOP中最为关键的术语。切⾯所要做的事就是专注于各⾃领域<br>的逻辑实现，这样可以使得开发逻辑更加清晰，更加适合专业的分⼯合作。由于切⾯的隔离性，降低了耦合，这样<br>就可以在不同的应⽤中将各个切⾯组合使⽤，从⽽是代码重⽤性⼤⼤增加。</li><li>连接点：程序运⾏过程中的某个阶段点，如某个⽅法的调⽤，或者异常的抛出。</li><li>处理逻辑（Advice）：在某⼀个连接点所采⽤的处理逻辑，处理逻辑的调⽤模式通常有三种：<br>a.Around 在连接点前后插⼊预处理过程和后处理过程。<br>b.Before 仅在连接点钱出⼊处理过程。<br>b.Throw 在连接点抛出异常时进⾏异常处理。<br>Advice有的译为“通知”，说法不⼀，我侧重于“处理逻辑”出⾃于Spring开发指南⼀⽂。</li><li>切点（PointCut）：⼀系列连接点的集合，它指明处理逻辑将在合适触发。</li><li>Spring事务的传播属性是怎么回事？它会影响什么？<br>a. 七个事传播属性：</li><li>PROPAGATION_REQUIRED – ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。</li><li>PROPAGATION_SUPPORTS – ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</li><li>PROPAGATION_MANDATORY – ⽀持当前事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATIONREQUIRESNEW – 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATIONNOTSUPPORTED – 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER – 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</li><li>PROPAGATIONNESTED – 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与<br>PROPAGATIONREQUIRED类似的操作。<br>b. 五个隔离级别：</li><li>ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.</li><li>另外四个与JDBC的隔离级别相对应：</li><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数<br>据。这种隔离级别会产⽣脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取<br>该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证<br>⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏<br>读，不可重复读外，还避免了幻读。<br>c. 关键词：<br>1、幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；<br>2、不可重复读：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；<br>3、脏读：事务1更新了记录，但没有提交，事务2读取了更新后的⾏，然后事务T1回滚，现在T2读取⽆效。</li><li>Spring中BeanFactory和FactoryBean有什么区别？<br>a. BeanFactory，以Factory结尾，表示它是⼀个⼯⼚类(接⼝)，⽤于管理Bean的⼀个⼯⼚。在Spring中，BeanFactory是<br>IOC容器的核⼼接⼝，它的职责包括：实例化、定位、配置应⽤程序中的对象及建⽴这些对象间的依赖。<br>b. FactoryBean以Bean结尾，表示它是⼀个Bean，不同于普通Bean的是：它是实现了FactoryBean接⼝的Bean，根据该<br>Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽不是FactoryBean本身，如果要获<br>取FactoryBean对象，请在id前⾯加⼀个&amp;符号来获取。</li><li>Spring框架中IOC的原理是什么？<br>(1). IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权<br>由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的<br>关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系<br>由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。<br>(2). 在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后<br>spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由<br>spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对<br>象，现在是所有对象都被spring控制，所以这叫控制反转。<br>(3). 在系统运⾏中，动态的向某个对象提供它所需要的其他对象。<br>(4). 依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中<br>的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者<br>的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优<br>点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li><li>spring的依赖注⼊有哪⼏种⽅式<br>在Spring容器中为⼀个bean配置依赖注⼊有四种⽅式：</li><li>使⽤属性的setter⽅法注⼊ 这是最常⽤的⽅式；</li><li>使⽤构造器注⼊；</li><li>使⽤Filed注⼊（⽤于注解⽅式）.</li><li>静态、实例⼯⼚的⽅法注⼊</li><li>⽤Spring如何实现⼀个切⾯？<br>1 @Aspect<br>2 @Component<br>3 public class LockAspect {<br>4 @Pointcut(“@annotation(xx.xx)”)<br>5 public void pointcut() {<br>6<br>7 }<br>8<br>9 @Around(“pointcut()”)<br>10 public Object arount(ProceedingJoinPoint point) throws Throwable {<br>11 …<br>12 try {<br>13 return point.proceed();<br>14 } catch (Exception e) {<br>15 throw e;<br>16 } finally {<br>17 …<br>18 }<br>19 }<br>20 }</li><li>Spring如何实现数据库事务？<br>使⽤@Transactional注解或在配置⽂件⾥⾯配置</li><li>Spring加载次序Classloader<br>1、先构造函数——&gt;然后是bean的set⽅法注⼊——&gt;InitializingBean的afterPropertiesSet⽅法——&gt;init-method⽅法；<br>2、InitializingBean接⼝为bean提供了初始化⽅法的⽅式，它只包括afterPropertiesSet⽅法，凡是继承该接⼝的类，在<br>初始化bean的时候会执⾏该⽅法。系统则是先调⽤afterPropertiesSet⽅法，然后在调⽤init-method中指定的⽅法。<br>3、Spring装配Bean的过程：</li><li>实例化;</li><li>设置属性值;</li><li>如果实现了BeanNameAware接⼝,调⽤setBeanName设置Bean的ID或者Name;</li><li>如果实现BeanFactoryAware接⼝,调⽤setBeanFactory 设置BeanFactory;</li><li>如果实现ApplicationContextAware,调⽤setApplicationContext设置ApplicationContext</li><li>调⽤BeanPostProcessor的预先初始化⽅法;</li><li>调⽤InitializingBean的afterPropertiesSet()⽅法;</li><li>调⽤定制init-method⽅法；</li><li>调⽤BeanPostProcessor的后初始化⽅法;<br>4、Spring容器关闭过程：</li><li>调⽤DisposableBean的destroy();</li><li>调⽤定制的destroy-method⽅法;</li><li>框架的优缺点SpringMVC,Struts2等…<br>1、Struts2是类级别拦截，参数为类中所有⽅法共有，⼀个Action对应⼀个request上下⽂，SpringMVC是⽅法级别拦截，参<br>数为对应⽅法所有；<br>2、由于Struts2需要针对每个request进⾏封装，把request，session等servlet⽣命周期的变量封装成⼀个⼀个Map，供给<br>每个Action使⽤，并保证线程安全，所以在原则上，是⽐较耗费内存的。<br>3、拦截器实现机制上，Struts2有以⾃⼰的interceptor机制，SpringMVC⽤的是独⽴的AOP⽅式，这样导致Struts2的配置⽂<br>件量还是⽐SpringMVC⼤。<br>4、SpringMVC的⼊⼝是servlet，⽽Struts2是filter<br>5、SpringMVC集成了Ajax，使⽤⾮常⽅便，只需⼀个注解@ResponseBody就可以实现，然后直接返回响应⽂本即可，⽽<br>Struts2拦截器集成了Ajax，在Action中处理时⼀般必须安装插件或者⾃⼰写代码集成进去，使⽤起来也相对不⽅便。<br>6、SpringMVC开发效率和性能⾼于Struts2。<br>7、SpringMVC配置少，零配置。</li><li>IOC控制反转与DI依赖注⼊：<br>1、IOC控制反转：是⼀种将对象交给容器去控制的设计思想，松耦合，⽅便单元测试，增加功能重⽤性；<br>2、DI依赖注⼊：组件之间依赖关系由容器在运⾏期决定，形象的说，即由容器动态的将某个依赖关系注⼊到组件之中。依赖注⼊的<br>⽬的并⾮为软件系统带来更多功能，⽽是为了提升组件重⽤的频率，并为系统搭建⼀个灵活、可扩展的平台。通过依赖注⼊机制，我们只<br>需要通过简单的配置，⽽⽆需任何代码就可指定⽬标需要的资源，完成⾃身的业务逻辑，⽽不需要关⼼具体的资源来⾃何处，由谁实现。<br>3、AOP⾯向切⾯编程：⾯向切⾯编程（AOP）完善spring的依赖注⼊（DI）。</li><li>AOP开发：</li><li>导⼊aop依赖包：<br>1<dependency><br>2<groupid>org.springframework</groupid><br>3<artifactid>spring-aspects</artifactid><br>4<version>4.3.12.RELEASE</version><br>5</dependency></li><li>创建切⾯类：<br>1 /**<br>2 * ⽇志切⾯类<br>3 *<br>4 * @author xuan<br>5 * @date 2018/11/1<br>6 <em>/<br>7 @Aspect<br>8 public class LogAspects {<br>9 /</em>*<br>10 * 公共的切⼊点表达式<br>11 * 1、本类引⽤<br>12 * 2、其他的切⾯引⽤<br>13 *<br>14 * @author xuan<br>15 * @date 2018/11/1<br>16 <em>/<br>17 @Pointcut(value = “execution(public int com.test.aop.MathCalculator.</em>(..))”)<br>18 public void pointCut(){}<br>19<br>20 /**<br>21 * 前置通知<br>22 *<br>23 * 在⽬标⽅法之前切⼊，切⼊点表达式（指在哪个⽅法切⼊）<br>24 * joinPoint参数⼀定要出现在参数列表第⼀位，放在后⾯会报错<br>25 *<br>26 * @author xuan<br>27 * @date 2018/11/1<br>28 */<br>29 @Before(value = “pointCut()”)<br>30 public void logStart(JoinPoint joinPoint) {<br>31 String methodName = joinPoint.getSignature().getName();<br>32 Object[] args = joinPoint.getArgs();<br>33 System.out.println(methodName + “运⾏。。。参数列表是：” + Arrays.toString(args));<br>34 }<br>35<br>36 @After(value = “pointCut()”)<br>37 public void logEnd() {<br>38 System.out.println(“除法结束。。。”);<br>39 }<br>40<br>41 @AfterReturning(value = “pointCut()”, returning = “result”)<br>42 public void logReturn(JoinPoint joinPoint, Object result) {<br>43 String methodName = joinPoint.getSignature().getName();<br>44 System.out.println(methodName + “正常返回。。。计算结果：” + result);<br>45 }<br>46<br>47 @AfterThrowing(value = “pointCut()”, throwing = “exception”)<br>48 public void logException(JoinPoint joinPoint, Exception exception){<br>49 String methodName = joinPoint.getSignature().getName();<br>50 System.out.println(methodName + “异常，异常信息：” + exception);<br>51 }<br>52<br>53 }<br>通知⽅法类型：<br>前置通知（logStart）：在⽬标⽅法运⾏之前运⾏；<br>后置通知（logEnd）：在⽬标⽅法运⾏结束之后运⾏；<br>返回通知（logReturn）：在⽬标⽅法正常返回之后运⾏；<br>异常通知（logException）：在⽬标⽅法出现异常是运⾏；<br>环绕通知（动态代理）：⼿动推荐⽬标⽅法运⾏（joinPoint.procced()）。</li><li>将切⾯类和⽬标类都加⼊到容器中，并开启基于注解的aop动态代理<br>1 public class MathCalculator {<br>2 public int div(int i, int j) {<br>3 System.out.println(“MathCalculator.div…..”);<br>4 return i/j;<br>5 }<br>6<br>7 }<br>8<br>9<br>10 /**<br>11 * aop<br>12 * 在程序运⾏期间动态的将某段代码切⼊到指定⽅法指定位置进⾏运⾏的编程⽅式<br>13 * ‘@EnableAspectJAutoProxy’：开启基于注解的aop动态代理<br>14 *<br>15 * @author xuan<br>16 * @date 2018/11/1<br>17 <em>/<br>18 @Configuration<br>19 @EnableAspectJAutoProxy<br>20 public class MainConfigOfAOP {<br>21<br>22 /</em>*<br>23 * 业务逻辑类加⼊容器中<br>24 *<br>25 * @author xuan<br>26 * @date 2018/11/1<br>27 <em>/<br>28 @Bean<br>29 public MathCalculator calculator() {<br>30 return new MathCalculator();<br>31 }<br>32<br>33 /</em>*<br>34 * 切⾯类加⼊容器中<br>35 *<br>36 * @author xuan<br>37 * @date 2018/11/1<br>38 */<br>39 @Bean<br>40 public LogAspects logAspects(){<br>41 return new LogAspects();<br>42 }<br>43 }</li><li>测试：<br>1 @Test<br>2 public void test01() {<br>3 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP<br>4 MathCalculator calculator = applicationContext.getBean(MathCalculator.class);<br>5 calculator.div(1, 0);<br>6 }</li><li>事务配置：</li><li>@EnableTransactionManagement开启事务配置功能；</li><li>容器中配置DataSource、JdbcTemplate、PlatformTransactionManager三个Bean实例；</li><li>使⽤@Transactional注解开启事务。<br>1 @EnableTransactionManagement<br>2 @Configuration<br>3 @ComponentScan(“com.test.tx”)<br>4 public class TxConfig {<br>5 @Bean<br>6 public DataSource dataSource() {<br>7 DruidDataSource dataSource = new DruidDataSource();<br>8 dataSource.setUrl(“jdbc:mysql://127.0.0.1:3306/xxx?useSSL=false”);<br>9 dataSource.setUsername(“xxx”);<br>10 dataSource.setPassword(“xxx”);<br>11 dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);<br>12 return dataSource;<br>13 }<br>14<br>15 @Bean<br>16 public JdbcTemplate jdbcTemplate() {<br>17 return new JdbcTemplate(dataSource());<br>18 }<br>19<br>20 /**<br>21 * 注册事务管理器<br>22 *<br>23 * @author xuan<br>24 * @date 2018/11/3<br>25 <em>/<br>26 @Bean<br>27 public PlatformTransactionManager transactionManager() {<br>28 return new DataSourceTransactionManager(dataSource());<br>29 }<br>30 }<br>31<br>32 @Service<br>33 public class UserService {<br>34<br>35 @Autowired<br>36 private UserDao userDao;<br>37<br>38 /</em>*<br>39 * 添加⽤户<br>40 *<br>41 * @author xuan<br>42 * @date 2018/11/3<br>43 */<br>44 @Transactional<br>45 public void insertUser() {<br>46 User user = new User(“zhangsan”, 27);<br>47 userDao.insert(user);<br>48 }<br>49 }</li><li>springboot的启动过程：<br>a. 通过 SpringFactoriesLoader加载 META-INF/spring.factories⽂件，获取并创建 SpringApplicationRunListener对象<br>b. 然后由 SpringApplicationRunListener来发出 starting 消息<br>c. 创建参数，并配置当前 SpringBoot 应⽤将要使⽤的 Environment<br>d. 完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息<br>e. 创建 ApplicationContext<br>f. 初始化 ApplicationContext，并设置 Environment，加载相关配置等<br>g. 由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应⽤使⽤的 ApplicationContext已准<br>备OK<br>h. 将各种 beans 装载⼊ ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知<br>SpringBoot 应⽤使⽤的 ApplicationContext已装填OK<br>i. refresh ApplicationContext，完成IoC容器可⽤的最后⼀步<br>j. 由 SpringApplicationRunListener来发出 started 消息<br>k. 完成最终的程序的启动<br>l. 由 SpringApplicationRunListener来发出 running 消息，告知程序已运⾏起来了</li><li>spring事件的实现原理，写出常⽤的⼏个事件。<br>a. 事件机制：Spring中的事件机制是⼀个观察者模式的实现.观察者模式就是⼀个⽬标对象管理所有相依于它的观察者对<br>象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。<br>b. spring默认存在的事件：</li><li>ContextStartedEvent：ApplicationContext启动后触发的事件</li><li>ContextStoppedEvent：ApplicationContext停⽌后触发的事件</li><li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件</li><li>ContextClosedEvent：ApplicationContext关闭后触发的事件</li></ol><p>Spring 面试问题 TOP 50（干货推荐收藏必备）<br>Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。<br>1、一般问题<br>1.1. 不同版本的 Spring Framework 有哪些主要功能？</p><p>1.2. 什么是 Spring Framework？<br>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。<br>它是轻量级、松散耦合的。<br>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。<br>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。<br>1.3. 列举 Spring Framework 的优点。<br>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。<br>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。<br>由于依赖注入和控制反转，JDBC 得以简化。<br>它是开源免费的。<br>1.4. Spring Framework 有哪些不同的功能？<br>轻量级 - Spring 在代码量和透明度方面都很轻便。<br>IOC - 控制反转<br>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。<br>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。<br>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。<br>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。<br>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。<br>1.5. Spring Framework 中有多少个模块，它们分别是什么？</p><p>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：<br>Spring Core<br>Spring Bean<br>SpEL (Spring Expression Language)<br>Spring Context<br>数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：<br>JDBC (Java DataBase Connectivity)<br>ORM (Object Relational Mapping)<br>OXM (Object XML Mappers)<br>JMS (Java Messaging Service)<br>Transaction<br>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<br>Web<br>Web – Servlet<br>Web – Socket<br>Web – Portlet<br>AOP – 该层支持面向切面编程<br>Instrumentation – 该层为类检测和类加载器实现提供支持。<br>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。<br>几个杂项模块:<br>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。<br>Aspects – 该模块为与 AspectJ 的集成提供支持。<br>1.6. 什么是 Spring 配置文件？<br>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。<br>1.7. Spring 应用程序有哪些不同组件？<br>Spring 应用一般有以下组件：<br>接口 - 定义功能。<br>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。<br>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。<br>Bean 配置文件 - 包含类的信息以及如何配置它们。<br>用户程序 - 它使用接口。<br>1.8. 使用 Spring 有哪些方式？<br>使用 Spring 有以下方式：<br>作为一个成熟的 Spring Web 应用程序。<br>作为第三方 Web 框架，使用 Spring Frameworks 中间层。<br>用于远程使用。<br>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。<br>2、依赖注入（Ioc）<br>2.1. 什么是 Spring IOC 容器？<br>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p><p>2.2. 什么是依赖注入？<br>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。<br>2.3. 可以通过多少种方式完成依赖注入？<br>通常，依赖注入可以通过三种方式完成，即：<br>构造函数注入<br>setter 注入<br>接口注入<br>在 Spring Framework 中，仅使用构造函数和 setter 注入。<br>2.4. 区分构造函数注入和 setter 注入。<br>构造函数注入setter 注入没有部分注入有部分注入不会覆盖 setter 属性会覆盖 setter 属性任意修改都会创建一个新实例任意修改不会创建一个新实例适用于设置很多属性适用于设置少量属性<br>2.5. spring 中有多少种 IOC 容器？<br>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。<br>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。<br>2.6. 区分 BeanFactory 和 ApplicationContext。<br>BeanFactoryApplicationContext它使用懒加载它使用即时加载它使用语法显式提供资源对象它自己创建和管理资源对象不支持国际化支持国际化不支持基于依赖的注解支持基于依赖的注解<br>2.7. 列举 IoC 的一些好处。<br>IoC 的一些好处是：<br>它将最小化应用程序中的代码量。<br>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。<br>它以最小的影响和最少的侵入机制促进松耦合。<br>它支持即时的实例化和延迟加载服务。<br>2.8. Spring IoC 的实现机制。<br>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：<br>interface Fruit {<br>public abstract void eat();<br>}<br>class Apple implements Fruit {<br>public void eat(){<br>System.out.println(“Apple”);<br>}<br>}<br>class Orange implements Fruit {<br>public void eat(){<br>System.out.println(“Orange”);<br>}<br>}<br>class Factory {<br>public static Fruit getInstance(String ClassName) {<br>Fruit f=null;<br>try {<br>f=(Fruit)Class.forName(ClassName).newInstance();<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>return f;<br>}<br>}<br>class Client {<br>public static void main(String[] a) {<br>Fruit f=Factory.getInstance(“io.github.dunwu.spring.Apple”);<br>if(f!=null){<br>f.eat();<br>}<br>}<br>}<br>3. Beans<br>3.1. 什么是 spring bean？<br>它们是构成用户应用程序主干的对象。<br>Bean 由 Spring IoC 容器管理。<br>它们由 Spring IoC 容器实例化，配置，装配和管理。<br>Bean 是基于用户提供给容器的配置元数据创建。<br>3.2. spring 提供了哪些配置方式？<br>基于 xml 配置<br>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：<br><bean id="studentbean" class="org.edureka.firstSpring.StudentBean"><br><property name="name" value="Edureka"></property><br></bean><br>基于注解配置<br>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：<br><beans><br><a href="context:annotation-config/">context:annotation-config/</a></beans></p>基于 Java API 配置 Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。 1.@Bean 注解扮演与<bean>元素相同的角色。 2.@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。 例如： @Configuration public class StudentConfig { @Bean public StudentBean myStudent() { return new StudentBean(); } } 3.3. spring 支持集中 bean scope？ Spring bean 支持 5 种 scope： Singleton - 每个 Spring IoC 容器仅有一个单实例。 Prototype - 每次请求都会产生一个新的实例。 Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。 Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。 Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。 仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。 3.4. spring bean 容器的生命周期是什么样的？ spring bean 容器的生命周期流程如下： 1.Spring 容器根据配置中的 bean 定义中实例化 bean。 2.Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。 3.如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。 4.如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。 5.如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。 6.如果为 bean 指定了 init 方法（<bean>的 init-method 属性），那么将调用它。 7.最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。 8.如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。 9.如果为 bean 指定了 destroy 方法（<bean>的 destroy-method 属性），那么将调用它。<p>3.5. 什么是 spring 的内部 bean？<br>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg>中提供了<bean>元素的使用。内部 bean 总是匿名的，它们总是作为原型。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</bean></constructor-arg></property></p><pre><code>Student.java
public class Student &#123;
private Person person;
//Setters and Getters
&#125;
public class Person &#123;
private String name;
private String address;
//Setters and Getters
&#125;
bean.xml
&lt;bean id=“StudentBean&quot; class=&quot;com.edureka.Student&quot;&gt;
&lt;property name=&quot;person&quot;&gt;
&lt;!--This is inner bean --&gt;
&lt;bean class=&quot;com.edureka.Person&quot;&gt;
&lt;property name=&quot;name&quot; value=“Scott&quot;&gt;&lt;/property&gt;
&lt;property name=&quot;address&quot; value=“Bangalore&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>3.6. 什么是 spring 装配<br>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。<br>3.7. 自动装配有哪些方式？<br>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。<br>自动装配的不同模式：<br>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。<br>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。<br>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。<br>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。<br>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。<br>3.8. 自动装配有什么局限？<br>覆盖的可能性 - 您始终可以使用<constructor-arg>和<property>设置指定依赖项，这将覆盖自动装配。<br>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。<br>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。<br>4、注解<br>4.1. 什么是基于注解的容器配置<br>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：<br>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<br>@Bean 注解扮演与<br>元素相同的角色。<br>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。<br>例如：<br>@Configuration<br>public class StudentConfig {<br>@Bean<br>public StudentBean myStudent() {<br>return new StudentBean();<br>}<br>}<br>4.2. 如何在 spring 中启动注解装配？<br>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。<br>4.3. @Component, @Controller, @Repository, @Service 有何区别？<br>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。<br>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。<br>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。<br>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。<br>4.4. @Required 注解有什么用？<br>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<br>示例：<br>public class Employee {<br>private String name;<br>@Required<br>public void setName(String name){<br>this.name=name;<br>}<br>public string getName(){<br>return name;<br>}<br>}<br>4.5. @Autowired 注解有什么用？<br>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。<br>public class Employee {<br>private String name;<br>@Autowired<br>public void setName(String name) {<br>this.name=name;<br>}<br>public string getName(){<br>return name;<br>}<br>}<br>4.6. @Qualifier 注解有什么用？<br>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。<br>Employee.java<br>public class Employee {<br>private String name;<br>@Autowired<br>public void setName(String name) {<br>this.name=name;<br>}<br>public string getName() {<br>return name;<br>}<br>}<br>EmpAccount.java<br>public class EmpAccount {<br>private Employee emp;<br>@Autowired<br>@Qualifier(emp1)<br>public void showName() {<br>System.out.println(“Employee name : ”+emp.getName);<br>}<br>}<br>4.7. @RequestMapping 注解有什么用？<br>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：<br>类级别：映射请求的 URL<br>方法级别：映射 URL 以及 HTTP 请求方法<br>5、数据访问<br>5.1. spring DAO 有什么用？<br>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。<br>5.2. 列举 Spring DAO 抛出的异常。</property></constructor-arg></p><p>5.3. spring JDBC API 中存在哪些类？<br>JdbcTemplate<br>SimpleJdbcTemplate<br>NamedParameterJdbcTemplate<br>SimpleJdbcInsert<br>SimpleJdbcCall<br>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？<br>我们可以通过两种方式使用 Spring 访问 Hibernate：<br>1.使用 Hibernate 模板和回调进行控制反转<br>2.扩展 HibernateDAOSupport 并应用 AOP 拦截器节点<br>5.5. 列举 spring 支持的事务管理类型<br>Spring 支持两种类型的事务管理：<br>1.程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。<br>2.声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。<br>5.6. spring 支持哪些 ORM 框架<br>Hibernate<br>iBatis<br>JPA<br>JDO<br>OJB<br>6、AOP<br>6.1. 什么是 AOP？<br>AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)<br>6.2. 什么是 Aspect？<br>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:<br>1.如何通过 pointcut 和 advice 定位到特定的 joinpoint 上<br>2.如何在 advice 中编写切面代码.<br>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p><p>6.3. 什么是切点（JoinPoint）<br>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<br>在 Spring AOP 中, join point 总是方法的执行点。<br>6.4. 什么是通知（Advice）？<br>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。<br>6.5. 有哪些类型的通知（Advice）？<br>Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。<br>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。<br>After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。<br>After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。<br>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。<br>6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。<br>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。<br>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。<br>6.7. AOP 有哪些实现方式？<br>实现 AOP 的技术，主要分为两大类：<br>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<br>编译时编织（特殊编译器实现）<br>类加载时编织（特殊的类加载器实现）。<br>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<br>JDK 动态代理<br>CGLIB<br>6.8. Spring AOP and AspectJ AOP 有什么区别？<br>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。<br>6.9. 如何理解 Spring 中的代理？<br>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<br>Advice + Target Object = Proxy<br>6.10. 什么是编织（Weaving）？<br>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p><p>7、MVC<br>7.1. Spring MVC 框架有什么用？<br>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。<br>7.2. 描述一下 DispatcherServlet 的工作流程<br>DispatcherServlet 的工作流程可以用一幅图来说明：</p><p>1.向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。<br>2.DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。<br>3.DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。<br>4.提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<br>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。<br>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。<br>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。<br>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。<br>1.Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；<br>2.根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。<br>3.ViewResolver 结合Model和View，来渲染视图。<br>4.视图负责将渲染结果返回给客户端。<br>7.3. 介绍一下 WebApplicationContext<br>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p><p>Spring部分<br>1.谈谈你对spring IOC和DI的理解，它们有什么区别？<br>IoC Inverse of Control 反转控制的概念，就是将原本在程序中手动创建UserService对象的控制权，交由Spring框架管理，简单说，就是创建UserService对象控制权被反转到了Spring框架<br>DI：Dependency Injection 依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件 </p><p>面试题： IoC 和 DI的区别？ <br>IoC 控制反转，指将对象的创建权，反转到Spring容器 ， DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入 <br>2.BeanFactory 接口和 ApplicationContext 接口有什么区别 ？<br>    ①ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。<br>    ②ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现 <br>开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory </p><p>BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(“applicationContext.xml”));<br>IHelloService helloService = (IHelloService) beanFactory.getBean(“helloService”);<br>helloService.sayHello();<br>3.spring配置bean实例化有哪些方式？<br>    1）使用类构造器实例化(默认无参数)</p><p><bean id="bean1" class="cn.itcast.spring.b_instance.Bean1"></bean><br>    2）使用静态工厂方法实例化(简单工厂模式)</p><p>//下面这段配置的含义：调用Bean2Factory的getBean2方法得到bean2<br><bean id="bean2" class="cn.itcast.spring.b_instance.Bean2Factory" factory-method="getBean2"></bean><br>    3）使用实例工厂方法实例化(工厂方法模式)</p><p>//先创建工厂实例bean3Facory，再通过工厂实例创建目标bean实例<br><bean id="bean3Factory" class="cn.itcast.spring.b_instance.Bean3Factory"></bean><br><bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"></bean><br>4.简单的说一下spring的生命周期？<br>    1)在配置 <bean> 元素，通过 init-method 指定Bean的初始化方法，通过 destroy-method 指定Bean销毁方法 </bean></p><p><bean id="lifeCycleBean" class="cn.itcast.spring.d_lifecycle.LifeCycleBean" init-method="setup" destroy-method="teardown"></bean><br>需要注意的问题：</p><p>    *  destroy-method 只对 scope=”singleton” 有效  <br>    *  销毁方法，必须关闭ApplicationContext对象(手动调用)，才会被调用</p><p>ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>applicationContext.close();<br>    2)Bean的完整生命周期 （十一步骤）【了解内容，但是对于spring内部操作理解有一定帮助】<br>①instantiate bean对象实例化<br>②populate properties 封装属性<br>③如果Bean实现BeanNameAware 执行 setBeanName<br>④如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext<br>⑤如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)</p><p>public class MyBeanPostProcessor implements BeanPostProcessor {<br>public Object postProcessAfterInitialization(Object bean, String beanName)<br>throws BeansException {<br>System.out.println(“第八步：后处理Bean，after初始化。”);<br>//后处理Bean，在这里加上一个动态代理，就把这个Bean给修改了。<br>return bean;//返回bean，表示没有修改，如果使用动态代理，返回代理对象，那么就修改了。<br>}<br>public Object postProcessBeforeInitialization(Object bean, String beanName)<br>throws BeansException {<br>System.out.println(“第五步：后处理Bean的：before初始化！！”);<br>//后处理Bean，在这里加上一个动态代理，就把这个Bean给修改了。<br>return bean;//返回bean本身，表示没有修改。<br>}<br>}<br>注意：这个前处理Bean和后处理Bean会对所有的Bean进行拦截。<br>⑥如果Bean实现InitializingBean 执行 afterPropertiesSet </p><p>⑦调用<bean init-method="init"> 指定初始化方法 init<br>⑧如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization<br>⑨执行业务处理<br>⑩如果Bean实现 DisposableBean 执行 destroy<br>⑪调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy<br>5.请介绍一下Spring框架中Bean的生命周期和作用域 </bean></bean></p><p>(1)bean定义<br>    在配置文件里面用<bean></bean>来进行定义。<br>(2)bean初始化<br>    有两种方式初始化:<br>A.在配置文件中通过指定init-method属性来完成<br>B.实现org.springframwork.beans.factory.InitializingBean接口<br>(3)bean调用<br>    有三种方式可以得到bean实例，并进行调用<br>(4)bean销毁<br>    销毁有两种方式<br>A.使用配置文件指定的destroy-method属性<br>B.实现org.springframwork.bean.factory.DisposeableBean接口<br>##作用域<br>singleton<br>当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。<br>prototype<br>Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域<br>request<br>在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。<br>session<br>在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>global session<br>在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</p><p>6.Bean注入属性有哪几种方式？</p><p>spring支持构造器注入和setter方法注入<br>    构造器注入，通过 <constructor-arg> 元素完成注入<br>    setter方法注入， 通过<property> 元素完成注入【开发中常用方式】<br>7.什么是AOP，AOP的作用是什么？<br>面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足，除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理 <br>Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP 提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上。允许用户实现自定义切面，用AOP来完善OOP的使用,可以把Spring AOP看作是对Spring的一种增强 </property></constructor-arg></p><p>8.Spring的核心类有哪些，各有什么作用？<br>BeanFactory：产生一个新的实例，可以实现单例模式<br>BeanWrapper：提供统一的get及set方法<br>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能<br>9.Spring里面如何配置数据库驱动？<br>使用”org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动。示例如下： <br>1<bean id="”dataSource”"> <br>2    <property name="”driverClassName”"> <br>3       <value>org.hsqldb.jdbcDriver</value><br>4    </property> <br>5<br>6   <property name="”url”"> <br>7        <value>jdbc:hsqldb:db/appfuse</value> <br>8    </property> <br>9<br>10    <property name="”username”"><value>abc</value></property> <br>11    <property name="”password”"><value>abc</value></property> <br>12</bean> <br>10.Spring里面applicationContext.xml文件能不能改成其他文件名？ <br>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化。缺省情况下， 它会在WEB-INF/applicationContext.xml文件找Spring的配置。 你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的 位置。示例如下： </context-param></p><p>1<listener> <br>2    <listener-class>org.springframework.web.context.ContextLoaderListener<br>3        <context-param> <br>4        <param-name>contextConfigLocation</param-name> <br>5        <param-value>/WEB-INF/xyz.xml</param-value> <br>6        </context-param>    <br>7    </listener-class> <br>8</listener> <br>11.Spring里面如何定义hibernate mapping？ </p><p>添加hibernate mapping 文件到web/WEB-INF目录下的applicationContext.xml文件里面。示例如下： <br>1<property name="”mappingResources”"> <br>2    <list> <br>3        <value>org/appfuse/model/User.hbm.xml</value> <br>4    </list> <br>5</property><br>12.Spring如何处理线程并发问题？<br>Spring使用ThreadLocal解决线程安全问题<br>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。<br>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。<br>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。<br>而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<br>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。<br>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。<br>13.为什么要有事物传播行为？</p><p>14.介绍一下Spring的事物管理<br>    事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。<br>开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管 理，可以通过Spring的注入来完成此功能。spring提供了几个关于事务处理的类：<br>TransactionDefinition //事务属性定义<br>TranscationStatus //代表了当前的事务，可以提交，回滚。<br>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。<br>一般事务定义步骤：</p><p>1TransactionDefinition td = new TransactionDefinition();<br>2TransactionStatus ts = transactionManager.getTransaction(td);<br>3try{ <br>4    //do sth<br>5    transactionManager.commit(ts);<br>6}catch(Exception e){<br>7    transactionManager.rollback(ts);<br>8}<br>    spring提供的事务管理可以分为两类：编程式的和声明式的。编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的更灵活。</p><p>编程式主要使用transactionTemplate。省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.</p><p>1void add(){<br>2    transactionTemplate.execute( new TransactionCallback(){<br>3        pulic Object doInTransaction(TransactionStatus ts){<br>4         //do sth<br>5        }<br>6    }<br>7}<br>声明式：</p><p>使用TransactionProxyFactoryBean:PROPAGATION_REQUIRED PROPAGATION_REQUIRED PROPAGATION_REQUIRED,readOnly<br>围绕Poxy的动态代理 能够自动的提交和回滚事务<br>org.springframework.transaction.interceptor.TransactionProxyFactoryBean<br>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。<br>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。<br>PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与 PROPAGATION_REQUIRED类似的操作。<br>15.解释一下Spring AOP里面的几个名词<br>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@AspectJ风格）来实现。<br>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。 在Spring AOP中，一个连接点 总是 代表一个方法的执行。 通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息。<br>通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。 通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。<br>切入点（Pointcut）：匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。 切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。<br>引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。 Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。<br>目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（advised） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。<br>AOP代理（AOP Proxy）： AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 注意：Spring 2.0最新引入的基于模式（schema-based）风格和@AspectJ注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。<br>织入（Weaving）：把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。 这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。 Spring和其他纯Java AOP框架一样，在运行时完成织入。</p><p>16.通知有哪些类型？<br>前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。<br>返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。<br>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。<br>后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。<br>环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。<br> <br>环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。<br>切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</p><p>Spring 概述</p><ol><li>什么是 spring?<br>Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，<br>但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企<br>业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</li><li>使用 Spring 框架的好处是什么？<br>轻量：Spring 是轻量的，基本的版本大约 2MB<br>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是<br>创建或查找依赖的对象们<br>面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服<br>务分开<br>容器：Spring 包含并管理应用中对象的生命周期和配置<br>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的<br>替代品<br>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全<br>局事务（JTA）<br>异 常 处 理 ： Spring 提 供 方 便 的 API 把 具 体 技 术 相 关 的 异 常 （ 比 如 由 JDBC ，<br>Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</li><li>Spring 由哪些模块组成？<br>以下是 Spring 框架的基本模块：<br>Core module<br>Bean module<br>Context module<br>Expression Language module<br>JDBC module<br>ORM module<br>OXM module<br>Java Messaging Service(JMS) module<br>Transaction module<br>Web module<br>Web-Servlet module<br>Web-Struts module<br>Web-Portlet module</li><li>核心容器（应用上下文) 模块<br>这是基本的 Spring 模块，提供 spring 框架的基础功能，BeanFactory 是 任何以<br>spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使 Spring 成为一<br>个容器。</li><li>BeanFactory – BeanFactory 实现举例<br>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖<br>从正真的应用代码中分离。最常用的 BeanFactory 实现是 XmlBeanFactory 类。</li><li>XMLBeanFactory<br>最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory ，它根<br>据 XML 文件中的定义加载 beans。该容器从 XML 文件读取配置元数据并用它去创<br>建一个完全配置的系统或应用。</li><li>解释 AOP 模块<br>AOP 模块用于发给我们的 Spring 应用做面向切面的开发， 很多支持由 AOP 联盟提<br>供，这样就确保了 Spring 和其他 AOP 框架的共通性。这个模块将元数据编程引入<br>Spring。</li><li>解释 JDBC 抽象和 DAO 模块<br>通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源错<br>误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常<br>访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务管理服务。</li><li>解释对象/关系映射集成模块<br>Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象/关系映射<br>映射(ORM)工具，Spring 支持集成主流的 ORM 框架，如 Hiberate,JDO 和 iBATIS<br>SQL Maps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。</li><li>解释 WEB 模块<br>Spring 的 WEB 模块是构建在 application context 模块基础之上，提供一个适合<br>web 应用的上下文。这个模块也包括支持多种面向 web 的任务，如透明地处理多个<br>文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对 Jakarta Struts<br>的支持。</li><li>Spring 配置文件<br>Spring 配置文件是个 XML 文件，这个文件包含了类信息，描述了如何配置它们，<br>以及如何相互调用。</li><li>什么是 Spring IOC 容器？<br>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，<br>并且管理这些对象的整个生命周期。</li><li>IOC 的优点是什么？<br>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要<br>单例和 JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器<br>支持加载服务时的饿汉式初始化和懒加载。</li><li>ApplicationContext 通常的实现是什么？<br> FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans<br>的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。<br> ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans<br>的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找<br>bean 配置。<br> WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个<br>WEB 应用的所有 bean。</li><li>Bean 工厂和 Application contexts 有什么区别？<br>Application contexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源<br>（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内<br>的 对 象 上 执 行 的 那 些 不 得 不 由 bean 工 厂 以 程 序 化 方 式 处 理 的 操 作 ， 可 以 在<br>Application contexts 中 以 声 明 的 方 式 处 理 。 Application contexts 实 现 了<br>MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</li><li>一个 Spring 的应用看起来象什么？<br> 一个定义了一些功能的接口<br> 这实现包括属性，它的 Setter ， getter 方法和函数等<br> Spring AOP<br> Spring 的 XML 配置文件<br> 使用以上功能的客户端程序<br>依赖注入</li><li>什么是 Spring 的依赖注入？<br>依赖注入，是 IOC 的一个方面，是个通常的概念，它有多种解释。这概念是说你不<br>用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，<br>但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC 容器）负责把<br>他们组装起来。</li><li>有哪些不同类型的 IOC（依赖注入）方式？<br>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一<br>系列参数，每个参数代表一个对其他类的依赖。<br>Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂 方<br>法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注<br>入。</li><li>哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？<br>你两种依赖方式都可以使用，构造器注入和 Setter 方法注入。最好的解决方案是用<br>构造器参数实现强制依赖，setter 方法实现可选依赖。<br>Spring Beans</li><li>什么是 Spring beans？<br>Spring beans 是那些形成 Spring 应用的主干的 java 对象。它们被 Spring IOC 容<br>器初始化，装配，和管理。这些 beans 通过容器中配置的元数据创建。比如，以 XML<br>文件中<bean>的形式定义。<br>Spring 框架定义的 beans 都是单件 beans。在 bean tag 中有个属性”singleton”，<br>如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean。默认是<br>TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件。点击这里一图 Spring<br>Bean 的生命周期。</li><li>一个 Spring Bean 定义 包含什么？<br>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个<br>bean，它的生命周期详情及它的依赖。</li><li>如何给 Spring 容器提供配置元数据？<br>这里有三种重要的方法给 Spring 容器提供配置元数据。<br> XML 配置文件。<br> 基于注解的配置。<br> 基于 java 的配置。</li><li>你怎样定义类的作用域？<br>当定义一个<bean>在 Spring 里，我们还能给这个 bean 声明一个作用域。它可以<br>通过 bean 定义中的 scope 属性来定义。如，当 Spring 要在需要的时候每次生产一<br>个新的 bean 实例，bean 的 scope 属性被指定为 prototype。另一方面，一个 bean<br>每 次 使 用 的 时 候 必 须 返 回 同 一 个 实 例 ， 这 个 bean 的 scope 属 性 必 须 设 为<br>singleton。</bean></li><li>解释 Spring 支持的几种 bean 的作用域<br>Spring 框架支持以下五种 bean 的作用域：<br> singleton : bean 在每个 Spring ioc 容器中只有一个实例。<br> prototype：一个 bean 的定义可以有多个实例。<br> request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring<br>ApplicationContext 情形下有效。<br> session：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域<br>仅在基于 web 的 Spring ApplicationContext 情形下有效。<br> global-session：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实<br>例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。<br> 缺省的 Spring bean 的作用域是 Singleton。</li><li>Spring 框架中的单例 bean 是线程安全的吗？<br>不，Spring 框架中的单例 bean 不是线程安全的。</li><li>解释 Spring 框架中 bean 的生命周期<br>Spring 容器 从 XML 文件中读取 bean 的定义，并实例化 bean。<br>Spring 根据 bean 的定义填充所有的属性。<br>如 果 bean 实 现 了 BeanNameAware 接 口 ， Spring 传 递 bean 的 ID 到<br>setBeanName 方法。<br>如 果 Bean 实 现 了 BeanFactoryAware 接 口 ， Spring 传 递 beanfactory 给<br>setBeanFactory 方法。<br>如 果 有 任 何 与 bean 相 关 联 的 BeanPostProcessors ， Spring 会 在<br>postProcesserBeforeInitialization()方法内调用它们。<br>如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，如果 bean<br>声明了初始化方法，调用此初始化方法。<br>如 果 有 BeanPostProcessors 和 bean 关 联 ， 这 些 bean 的<br>postProcessAfterInitialization() 方法将被调用。<br>如果 bean 实现了 DisposableBean，它将调用 destroy()方法。<br>点击这里一图 Spring Bean 的生命周期。</li><li>哪些是重要的 bean 生命周期方法？ 你能重载它们吗？<br>有两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时<br>候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。<br>The bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你<br>可 以 自 己 定 制 初 始 化 和 注 销 方 法 。 它 们 也 有 相 应 的 注 解 （ @PostConstruct 和<br>@PreDestroy）。</li><li>什么是 Spring 的内部 bean？<br>当一个 bean 仅被用作另一个 bean 的属性时，它能被声明为一个内部 bean，为了<br>定义 inner bean，在 Spring 的 基于 XML 的 配置元数据中，可以在<property><br>或<constructor-arg>元素内使用<bean>元素，内部 bean 通常是匿名的，它<br>们的 Scope 一般是 prototype。</li><li>在 Spring 中如何注入一个 java 集合？<br>Spring 提供以下几种集合的配置元素：<br><list>类型用于注入一列值，允许有相同的值。<br><set>类型用于注入一组值，不允许有相同的值。<br><map>类型用于注入一组键值对，键和值都可以为任意类型。<br><props>类型用于注入一组键值对，键和值都只能为 String 类型。</props></map></set></list></li><li>什么是 bean 装配？<br>装配，或 bean 装配是指在 Spring 容器中把 bean 组装到一起，前提是容器需要知<br>道 bean 的依赖关系，如何通过依赖注入来把它们装配到一起。</li><li>什么是 bean 的自动装配？<br>Spring 容 器 能 够 自 动 装 配 相 互 合 作 的 bean ， 这 意 味 着 容 器 不 需 要<br><constructor-arg>和<property>配置，能通过 Bean 工厂自动处理 bean 之间的协<br>作。</property></constructor-arg></li><li>解释不同方式的自动装配<br>有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入<br>no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。<br>byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire<br>属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的<br>bean。<br>byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire<br>属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的<br>bean。如果有多个 bean 符合条件，则抛出错误。<br>constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定<br>的带参数的构造器参数类型，将会抛出异常。<br>autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType<br>方式。</li><li>自动装配有哪些局限性？<br>自动装配的局限性是：<br>重写：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要<br>重写自动装配。<br>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。<br>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</property></constructor-arg></li><li>你可以在 Spring 中注入一个 null 和一个空字符串吗？<br>可以。 Spring 注解</li><li>什么是基于 Java 的 Spring 注解配置? 给一些注解的例子<br>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring<br>配置而非通过 XML 文件。<br>以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring<br>IOC 容器使用。另一个例子是@Bean 注解，它表示此方法将要返回一个对象，作为<br>一个 bean 注册进 Spring 应用上下文。点击这里学习 JAVA 几大元注解。</li><li>什么是基于注解的容器配置？<br>相对于 XML 文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的<br>声明。<br>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而<br>不是使用 xml 表述 bean 的装配关系。</li><li>怎样开启注解装配？<br>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在 Spring 配置文<br>件中配置 <a href="context:annotation-config/">context:annotation-config/</a>元素。</li><li>@Required 注解<br>这个注解表明 bean 的属性必须在配置的时候设置，通过一个 bean 定义的显式的属<br>性 值 或 通 过 自 动 装 配 ， 若 @Required 注 解 的 bean 属 性 未 被 设 置 ， 容 器 将 抛 出<br>BeanInitializationException。</li><li>@Autowired 注解<br>@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它<br>的用法和@Required 一样，修饰 setter 方法、构造器、属性或者具有任意名称和/<br>或多个参数的 PN 方法。</li><li>@Qualifier 注解<br>当 有 多 个 相同 类 型 的 bean 却 只 有 一 个需 要 自 动 装 配 时 ，将 @Qualifier 注 解 和<br>@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的 bean。点击这<br>里学习更多常用注解。 Spring 数据访问</li><li>在 Spring 框架中如何更有效地使用 JDBC？<br>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需<br>写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的<br>模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</li><li>JdbcTemplate<br>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类<br>型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li><li>Spring 对 DAO 的支持<br>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，<br>Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会<br>捕获每种技术特有的异常。</li><li>使用 Spring 通过什么方式访问 Hibernate？<br>在 Spring 中有两种方式访问 Hibernate：<br>控制反转 Hibernate Template 和 Callback<br>继承 HibernateDAOSupport 提供一个 AOP 拦截器</li><li>Spring 支持的 ORM<br>Spring 支持以下 ORM：<br>Hibernate<br>iBatis<br>JPA (Java Persistence API)<br>TopLink<br>JDO (Java Data Objects)<br>OJB</li><li>如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？<br>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<br>配置 the Hibernate SessionFactory<br>继承 HibernateDaoSupport 实现一个 DAO<br>在 AOP 支持的事务中装配</li><li>Spring 支持的事务管理类型<br>Spring 支持两种类型的事务管理：<br>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是<br>难维护。<br>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML<br>配置来管理事务。</li><li>Spring 框架的事务管理有哪些优点？<br>它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供一个不变<br>的编程模式。<br>它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API 如<br>它支持声明式事务管理。<br>它和 Spring 各种数据访问抽象层很好得集成。</li><li>你更倾向用那种事务管理类型？<br>大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因<br>此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，<br>虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。 Spring 面向切面编程（AOP）</li><li>解释 AOP<br>面向切面的编程，或 AOP， 是一种编程技术，允许程序模块化横向切割关注点，或<br>横切典型的责任划分，如日志和事务管理。</li><li>Aspect 切面<br>AOP 核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组<br>API 提供横切功能。比如，一个日志模块可以被称作日志的 AOP 切面。根据需求的<br>不同，一个应用程序可以有若干切面。在 Spring AOP 中，切面通过带有@Aspect<br>注解的类实现。</li><li>在 Spring AOP 中，关注点和横切关注的区别是什么？<br>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个<br>功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，<br>比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横<br>切关注点。</li><li>连接点<br>连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个 AOP 切面，它<br>实际上是个应用程序执行 Spring AOP 的位置。</li><li>通知<br>通 知 是 个 在 方 法 执 行 前 或 执 行 后 要 做 的 动 作 ， 实 际 上 是 程 序 执 行 时 要 通 过<br>SpringAOP 框架触发的代码段。<br>Spring 切面可以应用五种类型的通知：<br>before：前置通知，在一个方法执行前被调用<br>after：在方法执行之后调用的通知，无论方法执行是否成功<br>after-returning：仅当方法成功完成后执行的通知<br>after-throwing：在方法抛出异常退出时执行的通知<br>around：在方法执行之前和之后调用的通知</li><li>切点<br>切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式<br>指明切入点。</li><li>什么是引入？<br>引入允许我们在已存在的类中增加新的方法和属性。</li><li>什么是目标对象？<br>被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）<br>对象。</li><li>什么是代理？<br>代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样<br>的。</li><li>有几种不同类型的自动代理？<br>BeanNameAutoProxyCreator<br>DefaultAdvisorAutoProxyCreator<br>Metadata autoproxying</li><li>什么是织入。什么是织入应用的不同点？<br>织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。<br>织入可以在编译时，加载时，或运行时完成。</li><li>解释基于 XML Schema 方式的切面实现<br>在这种情况下，切面由常规类以及基于 XML 的配置实现。</li><li>解释基于注解的切面实现<br>在这种情况下(基于@AspectJ 的实现)，涉及到的切面声明的风格与带有 java5 标注<br>的普通 java 类一致。 Spring 的 MVC</li><li>什么是 Spring 的 MVC 框架？<br>Spring 配备构建 Web 应用的全功能 MVC 框架。Spring 可以很便捷地和其他 MVC<br>框架集成，如 Struts，Spring 的 MVC 框架用控制反转把业务对象和控制逻辑清晰<br>地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</li><li>DispatcherServlet<br>Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP<br>请求和响应。</li><li>WebApplicationContext<br>WebApplicationContext 继承了 ApplicationContext 并增加了一些 WEB 应用<br>必备的特有功能，它不同于一般的 ApplicationContext ，因为它能处理主题，并找<br>到被关联的 servlet。</li><li>什么是 Spring MVC 框架的控制器？<br>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用<br>户输入并将其转换为一个由视图呈现给用户的模型。Spring 用一个非常抽象的方式<br>实现了一个控制层，允许用户创建多种用途的控制器。</li><li>@Controller 注解<br>该注解表明该类扮演控制器的角色，Spring 不需要你继承任何其他控制器基类或引<br>用 Servlet API。</li><li>@RequestMapping 注解<br>该注解是用来映射一个 URL 到一个类或一个特定的方处理法上。</li></ol><ul><li>Spring的优点有什么?</li></ul><p>1.Spring是分层的架构，你可以选择使用你需要的层而不用管不需要的部分<br>2.Spring是POJO编程，POJO编程使得可持续构建和可测试能力提高<br>3.依赖注入和IoC使得JDBC操作简单化<br>4.Spring是开源的免费的<br>5.Spring使得对象管理集中化合简单化</p><ul><li>描述一下spring中实现DI（dependency injection）的几种方式<br>方式一：接口注入，在实际中得到了普遍应用，即使在IOC的概念尚未确立时，这样的方法也已经频繁出现在我们的代码中。<br>方式二：Type2 IoC: Setter injection对象创建之后，将被依赖对象通过set方法设置进去<br>方式三：Type3 IoC: Constructor injection对象创建时，被依赖对象以构造方法参数的方式注入<br>Spring的方式</li><li>简单描述下IOC(inversion of control)的理解<br>一个类需要用到某个接口的方法，我们需要将类A和接口B的实现关联起来，最简单的方法是类A中创建一个对于接口B的实现C的实例，但这种方法显然两者的依赖（Dependency）太大了。而IoC的方法是只在类A中定义好用于关联接口B的实现的方法，将类A，接口B和接口B的实现C放入IoC的 容器（Container）中，通过一定的配置由容器（Container）来实现类A与接口B的实现C的关联。</li><li>Spring对很多ORM框架提供了很好支持，描述下在spring使用hibernate的方法<br>在context中定义DataSource，创建SessionFactoy，设置参数；DAO类继承HibernateDaoSupport，实现具体接口，从中获得HibernateTemplate进行具体操作。在使用中如果遇到OpenSessionInView的问题，可以添加OpenSessionInViewFilter或OpenSessionInViewInterceptor</li><li>请介绍下spring的事务管理<br>spring提供了几个关于事务处理的类：<br>TransactionDefinition //事务属性定义<br>TranscationStatus //代表了当前的事务，可以提交，回滚。<br>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类AbstractPlatformTransactionManager,我们使用的事务管理类例如DataSourceTransactionManager等都是这个类的子类。<br>一般事务定义步骤：<br>TransactionDefinition td = new TransactionDefinition();<br>TransactionStatus ts = transactionManager.getTransaction(td);<br>try<br>{ //do sth<br>transactionManager.commit(ts);<br>}<br>catch(Exception e){transactionManager.rollback(ts);}<br>spring提供的事务管理可以分为两类：编程式的和声明式的。编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的更灵活。<br>编程式主要使用transactionTemplate。省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.<br>void add()<br>{<br>transactionTemplate.execute( new TransactionCallback(){<br>pulic Object doInTransaction(TransactionStatus ts)<br>{ //do sth}<br>}<br>}<br>声明式：<br>使用TransactionProxyFactoryBean:</li></ul><p>PROPAGATION_REQUIRED PROPAGATION_REQUIRED PROPAGATION_REQUIRED,readOnly<br>围绕Poxy的动态代理 能够自动的提交和回滚事务<br>org.springframework.transaction.interceptor.TransactionProxyFactoryBean<br>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。<br>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。<br>PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p><ul><li>如何在spring的applicationContext.xml使用JNDI而不是DataSource<br>可以使用”org.springframework.jndi.JndiObjectFactoryBean”来实现。示例如下：<bean id="”dataSource”">   <property name="”jndiName”">       <value>java:comp/env/jdbc/appfuse</value>   </property></bean></li><li>在spring中是如何配置数据库驱动的<br>org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动。示例如下：<bean id="”dataSource”">   <property name="”driverClassName”">       <value>org.hsqldb.jdbcDriver</value>   </property>   <property name="”url”">       <value>jdbc:hsqldb:db/appfuse</value>   </property>   <property name="”username”"><value>sa</value></property>   <property name="”password”"><value></value></property></bean></li><li>spring中的applicationContext.xml能不能改为其他名字<br>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化。缺省情况下， 它会在WEB-INF/applicationContext.xml文件找Spring的配置。 你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的位置。示例如下：<listener>   <listener-class>org.springframework.web.context.ContextLoaderListener      <context-param>       <param-name>contextConfigLocation</param-name>       <param-value>/WEB-INF/xyz.xml</param-value>   </context-param>     </listener-class></listener></context-param></li><li>在web中如何配置spring<br>在J2EE的web应用里面配置spring非常简单，最简单的只需要把spring得ContextLoaderListener添加到你的web.xml文件里面就可以了，示例如下：<listener>   <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class></listener></li><li>在spring中如何定义hibernate Mapping？<br>添加hibernate mapping 文件到web/WEB-INF目录下的applicationContext.xml文件里面。示例如下：<property name="”mappingResources”">   <list>       <value>org/appfuse/model/User.hbm.xml</value>   </list></property></li><li>两种依赖注入的类型是什么?<br>两种依赖注入的类型分别是setter注入和构造方法注入。<br>setter注入： 一般情况下所有的java bean, 我们都会使用setter方法和getter方法去设置和获取属性的值，示例如下：<br>public class namebean {<br>     String      name;  <br>     public void setName(String a) {<br>        name = a; }<br>     public String getName() {<br>        return name; }<br>    }<br>我们会创建一个bean的实例然后设置属性的值，spring的配置文件如下：<br><bean id="”bean1″  "><br>  <property name="”name”"><br>      <value>tom</value><br>  </property></bean>Spring会调用setName方法来只是name熟悉为tom 构造方法注入：构造方法注入中，我们使用带参数的构造方法如下： public class namebean {      String name;      public namebean(String a) {         name = a;      }    } 我们会在创建bean实例的时候以new namebean(”tom”)的方式来设置name属性, Spring配置文件如下：<bean id="”bean1″ ">   <constructor-arg>      <value>My Bean Value</value>  </constructor-arg></bean>使用constructor-arg标签来设置构造方法的参数。</li><li>解释一下Dependency Injection(DI)和IOC（inversion of control）?<br>参考答案：依赖注入DI是一个程序设计模式和架构模型， 一些时候也称作控制反转，尽管在技术上来讲，依赖注入是一个IOC的特殊实现，依赖注入是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个数据库连接已参数的形式传到一个对象的结构方法里面而不是在那个对象内部自行创建一个连接。控制反转和依赖注入的基本思想就是把类的依赖从类内部转化到外部以减少依赖<br>应用控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所以，控制反转是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转</li><li>Spring中BeanFactory和ApplicationContext的作用和区别<br>作用：</li></ul><ol><li>BeanFactory负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。</li><li>ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：<br>a. 国际化支持<br>b. 资源访问：Resource rs = ctx. getResource(”classpath:config.properties”), “file:c:/config.properties”<br>c. 事件传递：通过实现ApplicationContextAware接口</li><li>常用的获取ApplicationContext的方法：<br>FileSystemXmlApplicationContext：从文件系统或者url指定的xml配置文件创建，参数为配置文件名或文件名数组<br>ClassPathXmlApplicationContext：从classpath的xml配置文件创建，可以从jar包中读取配置文件<br>WebApplicationContextUtils：从web应用的根目录读取配置文件，需要先在web.xml中配置，可以配置监听器或者servlet来实现<listener><listener-class>org.springframework.web.context.ContextLoaderListener</listener-class></listener><servlet><servlet-name>context</servlet-name><servlet-class>org.springframework.web.context.ContextLoaderServlet</servlet-class><load-on-startup>1</load-on-startup></servlet>这两种方式都默认配置文件为web-inf/applicationContext.xml，也可使用context-param指定配置文件<context-param><param-name>contextConfigLocation</param-name><param-value>/WEB-INF/myApplicationContext.xml</param-value></context-param></li></ol><ul><li>在web环境下如何配置applicationContext.xml文件<listener>  <listener-class>   org.springframework.web.context.ContextLoaderListener   </listener-class> </listener> 或：  <servlet>  <servlet-name>context</servlet-name>   <servlet-class>    org.springframework.web.context.ContextLoaderServlet    </servlet-class>  <load-on-startup>1</load-on-startup> </servlet> 通过如下方法取出applicationContext实例:  ApplicationContext ac=WebApplicationContextUtils.getWebApplicationContext(this.getServletContext);</li><li>如何配置spring + struts？<br>在struts-config.xml加入一个插件，通过它加载applicationContext.xml<br>在struts-config.xml修改action-mapping标记，具体action交给了DelegateActionProxy<br>通过DelegateActionProxy进入一spring的环境。<br>在spring的applicationContext.xml加入&lt;bean name=”/login” class=”” singleton=”false”/&gt;</li><li>Spring 和 hibernate的配置文件中的主要类型有哪些？如何配置?<br>在myeclipse中先加入spring环境再加入hibernate环境。<br> 如果spring与hibernate结合在一起可以不需要hibernate.cfg.xml文件是否正确?<br> spring+hibernate的配置文件中的主要类有那些?如何配置?<br>  dataSource<br>  sessionFactory:hibernate.cfg.xml<br>  transactionManager<br>  userDao (extends HibernateDaoSupport) <br>   sessionFactory<br>  facade<br>  proxy<br>   sessionFactory<br>   transactionManager<br>   facade</li><li>在spring中如何配置容器的事物管理，相关的类有哪些?<br>Datasouce<br>   transactionManager<br>   userDao要注入<br>    Datasouce<br>   Proxy代理<br>    Target:userDao：代理对象(目标对象)<br>    transactionAttributes(那些方法需要事务处理)<br>    transactionManager(事务处理服务)</li><li>在spring中如何配代码的事务管理器<br>Datasouce<br>   transactionManager<br>   userDao要注入<br>    Datasouce<br>    transactionManager<br>  通过如下类实现<br>    TransactionTemplate<br>    JdbcTemplate</li><li>Spring中有几种事物管理，分别是什么?<br>代码管理的事务处理<br>TransactonTemplate的execute方法中的内部类TransactionCallback中的doInTransaction方法中使用。<br>public void make()<br> { <br>  TransactionTemplate jtm=new TransactionTemplate(this.getTransactionManager());<br>  jtm.execute(new myClass1());<br> }<br> public class myClass1 implements TransactionCallback<br> {<br>  public Object doInTransaction(TransactionStatus trans)<br>  {<br>   JdbcTemplate jdbc=new JdbcTemplate(dataSource);<br>   jdbc.execute(”insert into customer(customerName) values(’b’)”);<br>   jdbc.execute(”insert into customer(customerName) values(’b’)”);<br>   return null;<br>  }  <br> }<br>   容器管理的事务处理</li><li>spring中的jdbc与传统的jdbc有什么区别?<br>Spring的jdbc:节省代码，不管连接(Connection)，不管事务、不管异常、不管关闭(con.close() ps.close )<br>  JdbcTemplate(dataSource):增、删、改、查<br>  TransactionTemplate(transactionManager):进行事务处理</li><li>Spring配置的主要标签有什么?有什么作用?<beans>   <bean id="””" class="””" init="””" destroy="””" singleton="””">    <property name="””">     <value></value>    </property>    <property name="””">     <ref local></ref>    </property>   </bean></beans></li><li>如何在spring中实现国际化?<br>在applicationContext.xml加载一个bean<bean id="”messageSource”" class="”org.springframework.context.support.ResourceBundleMessageSource”">  <property name="”basename”">   <value>message</value>  </property></bean> 在src目录下建多个properties文件  对于非英文的要用native2ascii -encoding gb2312 源  目转化文件相关内容  其命名格式是message_语言_国家。  页面中的中显示提示信息，键名取键值。  当给定国家，系统会自动加载对应的国家的properties信息。  通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。</li><li>在spring中如何实现事件处理<br>事件<br>  Extends ApplicationEvent<br>监听器<br>  Implements ApplicationListener<br>事件源<br>  Implements ApplicationContextAware<br>在applicationContext.xml中配置事件源、监听器<br>先得到事件源，调用事件源的方法，通知监听器。</li><li>如何将spring加入web容器中<br>在web.xml中加入如下同容,在启动web服务器时加载/WEB-INF/applicationContext.xml中的内容。<servlet><servlet-name>context</servlet-name><servlet-class>org.springframework.web.context.ContextLoaderServlet</servlet-class><load-on-startup>1</load-on-startup></servlet>通过如下类得到ApplicationContext实例    WebApplicationContextUtils.getWebApplicationContext</li><li>Spring如何实现资源管理?<br>使用<br>applicationContext.getResource(“classpath:文件名”):在src根目录下，在类路径下<br>applicationContext.getResource(“classpath:/chap01/文件名”): 以src根目录下的基准往下走。<br>applicationContext.getResource(“file:c:/a.properties”)：在系统文件目录下。</li><li>Spring的ApplicationContext的作用?<br>beanFactory<br>国际化(getMesage)<br>资源管理:可以直接读取一个文件的内容(getResource)<br>加入web框架中(加入一个servlet或监听器)<br>事件处理</li><li>spring的核心是什么，各有什么作用？<br>BeanFactory：产生一个新的实例，可以实现单例模式<br>BeanWrapper：提供统一的get及set方法<br>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li><li>Spring中aop的关键名词有哪些？各有什么作用?<br>拦截器: 代理<br>装备(advice)<br>目标对象<br>关切点:条件<br>连接点:方法、属性</li><li>Spring与struts的区别？<br>strusts：是一种基于MVC模式的一个web层的处理。<br>Spring:提供了通用的服务，ioc/di aop,关心的不仅仅web层，应当j2ee整体的一个服务，可以很容易融合不同的技术struts hibernate ibatis ejb remote springJDBC springMVC</li><li>spring与struts的面试题</li></ul><p>1.struts<br>Action是不是线程安全的？如果不是，有什么方式可以保证Action的线程安全？如果是，说明原因<br>2.MVC，分析一下struts是如何实现MVC的<br>3.struts中的几个关键对象的作用(说说几个关键对象的作用)<br>4.spring<br>说说AOP和IOC的概念以及在spring中是如何应用的<br>5.Hibernate有哪几种查询数据的方式<br>6.load()和get()的区别<br>回答：<br>1.Struts1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1 Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。<br>Struts2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）<br>2.struts是用一组类,servlet 和jsp规范实现mvc的<br>3.ActionFrom ActionServlet Action struts-config.xml<br>4.spring的核心就是IOC,通过指定对象的创建办法,描述对象与服务之间的关系,而不生成对象<br>5.3种,hql 条件查询() 原生sql<br>6.load()方法认为该数据一定存在,可以放心的使用代理来延时加载 ,如果使用过程中发现了问题,就抛出异常;<br>get()方法一定要获取到真实的数据,否则返回null</p><ul><li>Spring, hibernate ,struts面试题<br>Hibernate工作原理及为什么要用？<br>原理：</li></ul><ol><li>读取并解析配置文件</li><li>读取并解析映射信息，创建SessionFactory</li><li>打开Sesssion</li><li>创建事务Transation</li><li>持久化操作</li><li>提交事务</li><li>关闭Session</li><li>关闭SesstionFactory<br>为什么要用：</li></ol><ul><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。<br>Hibernate是如何延迟加载?</li><li>Hibernate2延迟加载实现：a)实体对象  b)集合（Collection）</li><li>Hibernate3 提供了属性的延迟加载功能<br>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。<br>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)<br>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、<br>说下Hibernate的缓存机制</li><li>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</li><li>二级缓存：<br>a)应用及缓存<br>b)分布式缓存<br>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非              关键数据<br>c)  第三方缓存的实现<br>Hibernate的查询方式<br>Sql、Criteria,object comptosition<br>Hql：</li><li>属性查询</li><li>参数查询、命名参数查询</li><li>关联查询</li><li>分页查询</li><li>统计函数<br>如何优化Hibernate？</li><li>使用双向一对多关联，不使用单向一对多</li><li>灵活使用单向一对多关联</li><li>不用一对一，用多对一取代</li><li>配置对象缓存，不使用集合缓存</li><li>一对多集合使用Bag,多对多集合使用Set</li><li>继承类使用显式多态</li><li>表字段要少，表关联不要怕多，有二级缓存撑腰<br>Struts工作机制？为什么要使用Struts？<br>工作机制：<br>Struts的工作流程:<br>在web应用启动时就会加载初始化ActionServlet,ActionServlet从struts-config.xml文件中读取配置信息,把它们存放到各种配置对象当ActionServlet接收到一个客户请求时,将执行如下流程.<br>(1)检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息;<br>(2)如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中;<br>(3)根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法;<br>(4)如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActuibErrors对象, 就表示表单验证成功;<br>(5)ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的Action实例不存在,就先创建这个实例,然后调用Action的execute()方法;<br>(6)Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给ActionForward对象指向的JSP组件;<br>(7)ActionForward对象指向JSP组件生成动态网页,返回给客户;<br>为什么要用：<br>JSP、Servlet、JavaBean技术的出现给我们构建强大的企业应用系统提供了可能。但用这些技术构建的系统非常的繁乱，所以在此之上，我们需要一个规则、一个把这些技术组织起来的规则，这就是框架，Struts便应运而生。<br>基于Struts开发的应用由3类组件构成：控制器组件、模型组件、视图组件<br>Struts的validate框架是如何验证的？<br>在struts配置文件中配置具体的错误提示，再在FormBean中的validate()方法具体调用。<br>说下Struts的设计模式<br>MVC模式:  web应用程序启动时就会加载并初始化ActionServler。用户提交表单时，一个配置好的ActionForm对象被创建，并被填入表单相应的数据，ActionServler根据Struts-config.xml 文件配置好的设置决定是否需要表单验证，如果需要就调用ActionForm的Validate（）验证后选择将请求发送到哪个Action，如果 Action不存在，ActionServlet会先创建这个对象，然后调用Action的execute（）方法。Execute（）从 ActionForm对象中获取数据，完成业务逻辑，返回一个ActionForward对象，ActionServlet再把客户请求转发给 ActionForward对象指定的jsp组件，ActionForward对象指定的jsp生成动态的网页，返回给客户。<br>单例模式<br>Factory(工厂模式)：<br>定义一个基类===》实现基类方法（子类通过不同的方法）===》定义一个工厂类（生成子类实例）<br>===》开发人员调用基类方法<br>Proxy(代理模式)<br>spring工作机制及为什么要用?</li></ul><p>1.spring mvc请所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责负责对请求进行真正的处理工作。<br>2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.<br>3.DispatcherServlet请请求提交到目标Controller<br>4.Controller进行业务逻辑处理后，会返回一个ModelAndView<br>5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象<br>6.视图对象负责渲染返回给客户端。<br>为什么用：<br>AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP 后，公共服务   （比 如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。<br>IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC 就像反      过来的 JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight construction），每一个对象都是用     其协作对象构造的。因此是由容器管理协作对象（collaborator）。<br>Spring即使一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 JavaBean 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。</p><ul><li><p>一些spring与hibernate的面试题<br>1、 简述你对IoC（Inversion of Control）的理解，描述一下Spring中实现DI（Dependency Injection）的几种方式。<br>2、 Spring的Bean有多种作用域，包括：<br>singleton、prototype、request、session、global session、application、自定义<br>3、 简单描述Spring framework与Struts的不同之处，整合Spring与Struts有哪些方法，哪种最好，为什么？<br>4、 Hibernate中的update()和saveOrUpdate()的区别<br>5、 Spring对多种ORM框架提供了很好的支持，简单描述在Spring中使用Hibernate的方法，并结合事务管理。<br>答案：<br>1、好莱坞原则€€€€不要打电话找我，我会打给你的。IoC将创建的职责从应用程序代码搬到了框架中。Spring对Setter注入和构造方法注入提供支持。（详见<a target="_blank" rel="noopener" href="http://martinfowler.com/articles/injection.html%EF%BC%8C%E4%BB%A5%E5%8F%8Ahttp">http://martinfowler.com/articles/injection.html，以及http</a>: //<a target="_blank" rel="noopener" href="http://www.redsaga.com/spring_ref/2.0/html/beans.html#beans-factory-">www.redsaga.com/spring_ref/2.0/html/beans.html#beans-factory-</a> collaborators）<br>2、 除application（详见Spring framework 2.0 Reference的3.4节bean的作用域）<br>3、 Spring是完整的一站式框架，而Struts仅是MVC框架，且着重于MVC中的C。Spring有三种方式整合Struts：使用 Spring 的 ActionSupport 类整合 Struts；使用 Spring 的 DelegatingRequestProcessor 覆盖 Struts 的 RequestProcessor；将 Struts Action 管理委托给 Spring 框架，动作委托最好。（详见使用Spring 更好地处理Struts 动作）<br>Spring 2.0新增一种方式：AutowiringRequestProcessor。（详见<a target="_blank" rel="noopener" href="http://www.javaeye.com/topic/24239%EF%BC%89">http://www.javaeye.com/topic/24239）</a><br>4、 saveOrUpdate()方法可以实现update()的功能，但会多些步骤，具体如下：<br>如果对象在该session中已经被持久化，不进行操作；<br>对象的标识符属性(identifier property)在数据库中不存在或者是个暂时的值，调用save()方法保存它；<br>如果session中的另一个对象有相同的标识符抛出一个异常；<br>以上皆不符合则调用update()更新之。<br>5、 在context中定义DataSource，创建SessionFactoy，设置参数；DAO类继承HibernateDaoSupport，实现具体接口，从中获得HibernateTemplate进行具体操作。<br>在使用中如果遇到OpenSessionInView的问题，可以添加OpenSessionInViewFilter或OpenSessionInViewInterceptor。（详见Spring framework 2.0 Reference的12.2节Hibernate）<br>声明式事务需声明事务管理器，在context中设置指定属性，用确定和。</p></li><li><p>在spring中如何更加高效的使用JDBC<br>使用Spring框架提供的模板类JdbcTemplete可以是JDBC更加高效<br>代码如下：JdbcTemplate template = new JdbcTemplate(myDataSource);<br>DAO类的例子：<br>public class StudentDaoJdbc implements StudentDao {<br>private JdbcTemplate jdbcTemplate;<br>public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {<br>this.jdbcTemplate = jdbcTemplate;<br>}<br>more..<br>}<br>配置文件：</p><pre><code>&lt;bean id=”jdbcTemplate” class=”org.springframework.jdbc.core.JdbcTemplate”&gt;
&lt;property name=”dataSource”&gt;
&lt;ref bean=”dataSource”/&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=”studentDao” class=”StudentDaoJdbc”&gt;
&lt;property name=”jdbcTemplate”&gt;
&lt;ref bean=”jdbcTemplate”/&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=”courseDao” class=”CourseDaoJdbc”&gt;
&lt;property name=”jdbcTemplate”&gt;
&lt;ref bean=”jdbcTemplate”/&gt;
&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li><li><p>在spring如何创建一个数据连接池<br>```</p><bean id="”dataSource”" class="”org.apache.commons.dbcp.BasicDataSource”"><property name="”driver”"><value>${db.driver}</value></property><property name="”url”"><value>${db.url}</value></property><property name="”username”"><value>${db.username}</value></property><property name="”password”"><value>${db.password}</value></property></bean></li><li><p>在spring中如何配置一个bean来从JNDI到dataSource</p><bean id="”dataSource”" class="”org.springframework.jndi.JndiObjectFactoryBean”"><property name="”jndiName”"><value>java:comp/env/jdbc/myDatasource</value></property></bean>```</li><li><p>请介绍下spring中bean的作用域<br>在spring2.0之前bean只有2种作用域即：singleton(单例)、non-singleton（也称 prototype），Spring2.0以后，增加了session、request、global session三种专用于Web应用程序上下文的Bean。因此，默认情况下Spring2.0现在有五种类型的Bean。</p><bean id="”role”" class="”spring.chapter2.maryGame.Role”" scope="”singleton”/">这里的scope就是用来配置spring bean的作用域，它标识bean的作用域。 在spring2.0之前bean只有2种作用域即：singleton(单例)、non-singleton（也称 prototype），Spring2.0以后，增加了session、request、global session三种专用于Web应用程序上下文的Bean。因此，默认情况下Spring2.0现在有五种类型的Bean。当然，Spring2.0对 Bean的类型的设计进行了重构，并设计出灵活的Bean类型支持，理论上可以有无数多种类型的Bean，用户可以根据自己的需要，增加新的Bean类型，满足实际应用需求。 1、singleton作用域 当一个bean的作用域设置为singleton，那么Spring IOC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。换言之，当把一个bean定义设置为singleton作用域时，Spring IOC容器只会创建该bean定义的唯一实例。这个单一实例会被存储到单例缓存（singleton cache）中，并且所有针对该bean的后续请求和引用都将返回被缓存的对象实例，这里要注意的是singleton作用域和GOF设计模式中的单例是完全不同的，单例设计模式表示一个ClassLoader中只有一个class存在，而这里的singleton则表示一个容器对应一个bean，也就是说当一个bean被标识为singleton时候，spring的IOC容器中只会存在一个该bean。 配置实例： ```<bean id="”role”" class="”spring.chapter2.maryGame.Role”" scope="”singleton”/">或者<bean id="”role”" class="”spring.chapter2.maryGame.Role”" singleton="”true”/">``` 2、prototype prototype作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）都会产生一个新的bean实例，相当于一个new的操作，对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个 prototype bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。（让Spring容器释放被singleton作用域bean占用资源的一种可行方式是，通过使用 bean的后置处理器，该处理器持有要被清除的bean的引用。） 配置实例：</bean></bean></bean></li></ul><pre><code>&lt;bean id=”role” class=”spring.chapter2.maryGame.Role” scope=”prototype”/&gt;
或者
&lt;beanid=”role” class=”spring.chapter2.maryGame.Role” singleton=”false”/&gt;
</code></pre><p>3、request<br>request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，配置实例：<br>request、session、global session使用的时候，首先要在初始化web的web.xml中做如下配置：<br>如果你使用的是Servlet 2.4及以上的web容器，那么你仅需要在web应用的XML声明文件web.xml中增加下述ContextListener即可：<br><web-app><br>…<br><listener><br><listener-class>org.springframework.web.context.request.RequestContextListener</listener-class><br></listener><br>…<br></web-app><br>如果是Servlet2.4以前的web容器,那么你要使用一个javax.servlet.Filter的实现：<br><web-app><br>..<br><filter><br><filter-name>requestContextFilter</filter-name><br><filter-class>org.springframework.web.filter.RequestContextFilter</filter-class><br></filter><br><filter-mapping><br><filter-name>requestContextFilter</filter-name><br><url-pattern>/*</url-pattern><br></filter-mapping><br>…<br></web-app><br>接着既可以配置bean的作用域了：<br><bean id="”role”" class="”spring.chapter2.maryGame.Role”" scope="”request”/"><br>4、session<br>session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效，配置实例：<br>配置实例：<br>和request配置实例的前提一样，配置好web启动文件就可以如下配置：<br><bean id="”role”" class="”spring.chapter2.maryGame.Role”" scope="”session”/"><br>5、global session<br>global session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个 portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。如果你在web中使用global session作用域来标识bean，那么，web会自动当成session类型来使用。<br>配置实例：<br>和request配置实例的前提一样，配置好web启动文件就可以如下配置：<br>&lt;bean id=”role” class=”spring.chapter2.maryGame.Role” scope=”global session”/&gt;<br>6、自定义bean装配作用域<br>在spring 2.0中作用域是可以任意扩展的，你可以自定义作用域，甚至你也可以重新定义已有的作用域（但是你不能覆盖singleton和 prototype），spring的作用域由接口org.springframework.beans.factory.config.Scope来定义，自定义自己的作用域只要实现该接口即可，下面给个实例：<br>我们建立一个线程的scope，该scope在表示一个线程中有效，代码如下：<br>publicclass MyScope implements Scope …{<br>privatefinal ThreadLocal threadScope = new ThreadLocal() …{<br>protected Object initialValue() …{<br>returnnew HashMap();<br>}<br>};<br>public Object get(String name, ObjectFactory objectFactory) …{<br>Map scope = (Map) threadScope.get();<br>Object object = scope.get(name);<br>if(object==null) …{<br>object = objectFactory.getObject();<br>scope.put(name, object);<br>}<br>return object;<br>}<br>public Object remove(String name) …{<br>Map scope = (Map) threadScope.get();<br>return scope.remove(name);<br>}<br>publicvoid registerDestructionCallback(String name, Runnable callback) …{<br>}<br>public String getConversationId() …{<br>// TODO Auto-generated method stub<br>returnnull;<br>}<br>}</bean></bean></p><ul><li>请介绍 一下spring的bean的生命周期<br>一、Bean的定义<br>Spring通常通过配置文件定义Bean。如：<?xml version=”1.0″ encoding=”UTF-8″?> &lt;beans xmlns=”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/beans%E2%80%9D">http://www.springframework.org/schema/beans”</a><br>xmlns:xsi=”<a target="_blank" rel="noopener" href="http://www.w3.org/2001/XMLSchema-instance%E2%80%9D">http://www.w3.org/2001/XMLSchema-instance”</a><br>xsi:schemaLocation=”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> <a target="_blank" rel="noopener" href="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd%E2%80%9D&gt;">http://www.springframework.org/schema/beans/spring-beans-2.0.xsd”&gt;</a><bean id="”HelloWorld”" class="”com.pqf.beans.HelloWorld”"><property name="”msg”"><value>HelloWorld</value></property></bean>这个配置文件就定义了一个标识为 HelloWorld 的Bean。在一个配置文档中可以定义多个Bean。 二、Bean的初始化 有两种方式初始化Bean。 1、在配置文档中通过指定init-method 属性来完成 在Bean的类中实现一个初始化Bean属性的方法，如init()，如： public class HelloWorld{ public String msg=null; public Date date=null; public void init() { msg=”HelloWorld”; date=new Date(); } …… } 然后，在配置文件中设置init-mothod属性：<bean id="”HelloWorld”" class="”com.pqf.beans.HelloWorld”" init-mothod="”init”"></bean>2、实现 org.springframwork.beans.factory.InitializingBean接口 Bean实现InitializingBean接口，并且增加 afterPropertiesSet() 方法： public class HelloWorld implement InitializingBean { public String msg=null; public Date date=null; public void afterPropertiesSet() { msg=”向全世界问好！”; date=new Date(); } …… } 那么，当这个Bean的所有属性被Spring的BeanFactory设置完后，会自动调用afterPropertiesSet()方法对Bean进行初始化，于是，配置文件就不用指定 init-method属性了。 三、Bean的调用 有三种方式可以得到Bean并进行调用： 1、使用BeanWrapper HelloWorld hw=new HelloWorld(); BeanWrapper bw=new BeanWrapperImpl(hw); bw.setPropertyvalue(”msg”,”HelloWorld”); system.out.println(bw.getPropertyCalue(”msg”)); 2、使用BeanFactory InputStream is=new FileInputStream(”config.xml”); XmlBeanFactory factory=new XmlBeanFactory(is); HelloWorld hw=(HelloWorld) factory.getBean(”HelloWorld”); system.out.println(hw.getMsg()); 3、使用ApplicationConttext ApplicationContext actx=new FleSystemXmlApplicationContext(”config.xml”); HelloWorld hw=(HelloWorld) actx.getBean(”HelloWorld”); System.out.println(hw.getMsg()); 四、Bean的销毁 1、使用配置文件中的 destory-method 属性 与初始化属性 init-methods类似，在Bean的类中实现一个撤销Bean的方法，然后在配置文件中通过 destory-method指定，那么当bean销毁时，Spring将自动调用指定的销毁方法。 2、实现 org.springframwork.bean.factory.DisposebleBean接口 如果实现了DisposebleBean接口，那么Spring将自动调用bean中的Destory方法进行销毁，所以，Bean中必须提供Destory方法。</li><li>Spring中如何获取bean<br>通过xml配置文件<br>bean配置在xml里面，spring提供多种方式读取配置文件得到ApplicationContext.<br>第一种方式：FileSystemXmlApplicationContext<br>通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例:<br>ApplicationContext ac = new FileSystemXmlApplicationContext(”applicationContext.xml”)<br>ac.getBean(”beanName”);<br>第二种方式：WebApplicationContextUtil<br>在B/S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext.例如：<br>ApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);<br>ApplicationContext ctx =   WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);<br>其中 servletContext sc 可以具体 换成 servlet.getServletContext()或者 this.getServletContext() 或者 request.getSession().getServletContext();<br>另外，由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象：<br>WebApplicationContext webApplicationContext = (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</li><li>Spring框架有哪几部分组成?<br>Spring框架有七个模块组成组成，这7个模块(或组件)均可以单独存在，也可以与其它一个或多个模块联合使用，主要功能表现如下：<br>☞ Spring 核心容器（Core）：提供Spring框架的基本功能。核心容器的主要组件是BeanFactory，她是工厂模式的实现。BeanFactory使用控制反转（Ioc）模式将应用程序的配置和依赖性规范与实际的应用代码程序分开。<br>☞ Spring AOP：通过配置管理特性，Spring AOP模块直接面向方面的编程功能集成到了Spring框架中，所以可以很容易的使Spring框架管理的任何对象支持 AOP。Spring AOP模块为基于Spring的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，不用依赖于EJB组件，就可以将声明性事务管理集成到应用程序中。<br>☞ Spring ORM：Spring框架集成了若干ORM框架,从而提供了ORM的对象关系工具,其中包括 JDO、Hibernate、iBatis和TopLink。所有这些都遵从Spring的通用事务和DAO异常层结构。<br>☞ Spring DAO：JDBC DAO抽象层提供了有意义的异常层次的结构，可用该结构来管理异常处理和不同数据供应商抛出的异常错误信息。异常层次结构简化了错误处理，并且大大的降低 了需要编写的异常代码数量（例如，打开和关系连接）。Spring DAO的面向JDBC的异常遵从通用的DAO异常层结构。<br>☞ Spring WEB：Web上下文模块建立在上下文模块（Context）的基础之上，为基于Web服务的应用程序提供了上下文的服务。所以Spring框架支持 Jakarta Struts的集成。Web模块还简化了处理多部分请求及将请求参数绑定到域对象的工作。<br>☞ Spring上下文（Context）：Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化校验和调度功能。<br>☞ Spring MVC：Spring的MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的，MVC容纳的大量视图技术，包括JSP、Velocity、Tiles、iText和Pol</li><li>使用spring有什么好处?<br>◆Spring能有效地组织你的中间层对象,无论你是否选择使用了EJB。如果你仅仅使用了Struts或其他的包含了J2EE特有APIs的framework，你会发现Spring关注了遗留下的问题，。<br>◆Spring能消除在许多工程上对Singleton的过多使用。根据我的经验，这是一个主要的问题，它减少了系统的可测试性和面向对象特性。<br>◆Spring能消除使用各种各样格式的属性定制文件的需要,在整个应用和工程中，可通过一种 一致的方法来进行配置。曾经感到迷惑，一个特定类要查找迷幻般的属性关键字或系统属性,为此不得不读Javadoc乃至源编码吗？有了Spring，你可 很简单地看到类的JavaBean属性。倒置控制的使用(在下面讨论)帮助完成这种简化。<br>◆Spring能通过接口而不是类促进好的编程习惯，减少编程代价到几乎为零。<br>◆Spring被设计为让使用它创建的应用尽可能少的依赖于他的APIs。在Spring应用中的大多数业务对象没有依赖于Spring。<br>◆使用Spring构建的应用程序易于单元测试。<br>◆Spring能使EJB的使用成为一个实现选择,而不是应用架构的必然选择。你能选择用POJOs或local EJBs来实现业务接口，却不会影响调用代码。<br>◆Spring帮助你解决许多问题而无需使用EJB。Spring能提供一种EJB的替换物，它们适于许多web应用。例如,Spring能使用AOP提供声明性事务而不通过使用EJB容器，如果你仅仅需要与单个的数据库打交道，甚至不需要JTA实现。<br>■Spring为数据存取提供了一致的框架,不论是使用JDBC或O/R mapping产品（如Hibernate）。<br>Spring确实使你能通过最简单可行的解决办法解决你的问题。这些特性是有很大价值的。<br>总结起来，Spring有如下优点：<br>◆低侵入式设计，代码污染极低<br>◆ 独立于各种应用服务器，可以真正实现Write Once,Run Anywhere的承诺<br>◆Spring的DI机制降低了业务对象替换的复杂性<br>◆Spring并不完全依赖于Spring，开发者可自由选用Spring框架的部分或全部</li><li>什么是spring，它有什么特点?<br>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。<br>◆轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并 且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。<br>◆控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不 是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。<br>◆面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的 业务逻辑与系统级服务（例如审计（auditing）和事务（）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们 并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。<br>◆容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是 一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生 成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。<br>◆框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li></ul><p>1.简单介绍下java？Spring的AOP，IOC的讲述 对struts2的了解，1，2的比较 xml的了解 J2ee的webserviced的协议？<br>Spring AOP:代理机制 Spring提供的自动代理机制<br>Spring的IoC来实组件之间的依赖关系注入, 使控制层与业务实现分离，即客户通过<br>调用业务委托接口来调用具体的业务组件的实例，避免控制层与业务层的藕合带来的维护<br>或升级困难。由Spring为DAO生成代理对象来为DAO添加事务服务，由IoC容器DAO的代理实例注入到业务组件中,业务组件通过DAO的委托接口调用DAO对象，使得上层组件不直接依赖于DAO的实现类，使得持久层更换或修改不影响上层组件。<br>2.Spring工作原理<br>内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射,反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过配置类达到的<br>Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明 管理的（Spring根据这些配置 内部通过反射去动态的组装对象）要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能</p><p>3.解释一下IOC,以及spring的举例<br>IOC称为控制反转，也叫依赖注入，ioc是Spring的核心组件，它通过配置文件，将需要创建的对象以池的方式管理，将实例注入到需要的对象中区，是对象依赖于注入而不依赖于实现，解决了各个组件的耦合度，使得项目在后期的维护和扩展上非常方便。 如在ssh框架整合中，我们将datasource对象注入给sessionFactory，再将sessionFactory注入给dao组件，再将dao组件注入给struts的Action组件，在将action对象注入给struts的拦截器。<br>4.整合spring 与struts的方法，那种最好，为什么？<br>答：1.第一种方法:<br>Struts的Action继承Spring的ActionSupport类，并在Action中获取Spring的ApplicationContext。这是最简单的一种整合方式，但有三个缺点：第一，Struts与Spring紧密耦合，不能改换到其他IoC容器；第二，难以使用Spring AOP特性；第三，对于需要使用DispatchAction的Struts应用无能为力。<br>2.第二种方法:<br>在Struts的配置文件中，以Spring的DelegatingRequestProcessor类代替Struts的RequestProcessor类，并在Spring的配置文件中定义与Struts配置文件中<action-mappings>对应的bean，从而将Struts的Action与Spring分开，并把Struts的动作置于Spring的控制之下。这种整合方式的优点是将不再依赖Spring这个特定的IoC容器，但必须依赖Struts的RequestProcessor类。<br>3.第三种方法:<br>通过Spring的DelegatingActionProxy类代理Struts的动作，即在Struts配置文件中，定义<action-mappings>的type属性全部改为DelegatingActionProxy，而不是具体的类名，并在Spring配置文件中定义与Struts动作映射对应的bean，从而将Struts的Action与Spring分开，并把Struts的动作置于Spring的控制之下。无疑，这是最灵活的一种整合方式。 </action-mappings></action-mappings></p><p>5.springframework与struts的不同之处<br>答：1. SpringFramework是一个采用了反转控制（InversionofControl,Ioc）策略的基于J2EE 的轻量级应用框架。核心是IoC容器，对于其它应用，如数据库访问，日志等，SpringFramework多使用现有的、成熟的框架。它采用了模块化的方式，各模块可以共同使用，也可以单独使用其中的一个模块。<br>2．struts2利用成熟的struts1和webwork整合使之操作更加方便;</p><p>6.spring使用了哪些设计模式，这样用有什么好处？<br>Dao模式 通过实现DAO,我们达到了解耦合的目的,使的程序更加的健壮,但复杂性增加了；</p><p>7.spring对多种ORM 框架提供了很好的支持，结合事务管理描述spring中使用Hibernate的方法。<br>答：spring中采用aop模式注入hibernate的sessionfactory和事务管理,在dao中调用.Spring集成hibernate有两种方式,一是dao层只与hibernate有关, 不使用任何spring 的api, 然后把dao注入到ioc容器.二是使用spring的hibernateDaoSupport.事务管理也可以只使用hibernate的事务管理.</p><p>8.问spring的AOP，mvc到底是怎么优化程序的结构？<br>SpringAOP主要提供了Pointcut、Aspects等以及它们如何被织入应用程序、代理的方式等等进行优化的控制。而Spring MVC里面前端控制器叫做DispatcherServlet。里面充当Action的组件叫做Controller，返回的视图层对象叫做ModelAndView，提交和返回都可能要经过过滤。从而提高程序可读性和稳定性。</p><p>以下为spring常见面试问题：<br> <br>1、什么是Spring框架？Spring框架有哪些主要模块？<br>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。<br> <br>Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。<br>Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。<br>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p><p> <br>2、使用Spring框架能带来哪些好处？<br> <br>下面列举了一些使用Spring框架带来的主要好处：<br>Dependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。<br>与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。<br>Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。<br>Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。<br>要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。<br>Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。<br>Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。<br>3、什么是控制反转(IOC)？什么是依赖注入？<br>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。<br>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。<br>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？<br>在Java中依然注入有以下三种实现方式：<br>1.构造器注入<br>2.Setter方法注入<br>3.接口注入<br>4、请解释下Spring框架中的IoC？<br>Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。<br>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。<br>org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。<br>IOC:把对象的创建、初始化、销毁交给spring来管理，而不是由开发者控制，实现控制反转。</p><p> <br>5、BeanFactory和ApplicationContext有什么区别？<br> <br>BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。<br>BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含 了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。<br>从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但applicationcontext在此基础上还提供了其他的功能。<br>1.提供了支持国际化的文本消息<br>2.统一的资源文件读取方式<br>3.已在监听器中注册的bean的事件<br>以下是三种较常见的 ApplicationContext 实现方式：<br>1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中<br>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);<br> <br>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。<br> <br>ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);<br> <br> <br>3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。<br> <br>4.AnnotationConfigApplicationContext(基于Java配置启动容器)  </p><p> </p><p> <br>6、Spring有几种配置方式？<br> <br>将Spring配置到应用开发中有以下三种方式：<br>1.基于XML的配置<br>2.基于注解的配置<br>3.基于Java的配置<br>7、如何用基于XML配置的方式配置Spring？<br>在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。<br>SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）<br>Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。<br>如：  </beans></p><beans><bean name="viewResolver" class="org.springframework.web.servlet.view.BeanNameViewResolver"><bean name="jsonTemplate" class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"><bean id="restTemplate" class="org.springframework.web.client.RestTemplate"></beans><p> <br>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。</p><web-app><display-name>Archetype Created Web Application</display-name><servlet><servlet-name>spring</servlet-name><servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class><load-on-startup>1</load-on-startup></servlet><servlet-mapping><servlet-name>spring</servlet-name><url-pattern>/</url-pattern></servlet-mapping></web-app><p> <br> <br> <br>8、如何用基于Java配置的方式配置Spring？<br> <br>Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个 新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与<bean> 元素类似。被 @Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的 内部调用@bean方法来设置嵌入bean的依赖关系。<br>最简单的@Configuration 声明类请参考下面的代码：</p><p>@Configuration<br>public class AppConfig{<br>@Bean<br>public MyService myService() {<br>return new MyServiceImpl();<br>}<br>}</p><p> <br>对于上面的@Beans配置文件相同的XML配置文件如下：<br><beans><br><bean id="myService" class="com.somnus.services.MyServiceImpl"><br></beans><br> <br>上述配置方式的实例化方式如下：利用AnnotationConfigApplicationContext 类进行实例化<br> <br>public static void main(String[] args) {<br>ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);<br>MyService myService = ctx.getBean(MyService.class);<br>myService.doStuff();<br>}<br> <br>要使用组件组建扫描，仅需用@Configuration进行注解即可：<br>@Configuration<br>@ComponentScan(basePackages = “com.somnus”)<br>public class AppConfig {<br>…<br>}<br> <br> <br>在上面的例子中，com.acme包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照Sring bean定义进行注册。<br>如果你要在你的web应用开发中选用上述的配置的方式的话，需要用AnnotationConfigWebApplicationContext 类来读 取配置文件，可以用来配置Spring的Servlet监听器ContextLoaderListener或者Spring MVC的DispatcherServlet。</p><web-app><context-param><param-name>contextClass</param-name><param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value></context-param><pre><code>&lt;!-- Configuration locations must consist of one or more comma- or space-delimited    
    fully-qualified @Configuration classes. Fully-qualified packages may also be    
    specified for component-scanning --&gt;    
&lt;context-param&gt;    
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    
    &lt;param-value&gt;com.howtodoinjava.AppConfig&lt;/param-value&gt;    
&lt;/context-param&gt;    
 
&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;    
&lt;listener&gt;    
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    
&lt;/listener&gt;    
 
&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;    
&lt;servlet&gt;    
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    
    &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext    
        instead of the default XmlWebApplicationContext --&gt;    
    &lt;init-param&gt;    
        &lt;param-name&gt;contextClass&lt;/param-name&gt;    
        &lt;param-value&gt;    
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext    
        &lt;/param-value&gt;    
    &lt;/init-param&gt;    
    &lt;!-- Again, config locations must consist of one or more comma- or space-delimited    
        and fully-qualified @Configuration classes --&gt;    
    &lt;init-param&gt;    
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    
        &lt;param-value&gt;com.howtodoinjava.web.MvcConfig&lt;/param-value&gt;    
    &lt;/init-param&gt;    
&lt;/servlet&gt;    
 
&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;    
&lt;servlet-mapping&gt;    
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    
    &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;    
&lt;/servlet-mapping&gt;    
</code></pre><p>&lt;/web-app</p><p> <br> <br> <br> <br>9、怎样用注解的方式配置Spring？<br>Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的 内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结 果。<br>注解装配在Spring中是默认关闭的。所以需要在Spring文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。<br><beans><br><a href="context:annotation-config/">context:annotation-config/</a><br><br></beans><br> <br> <br>在 <a href="context:annotation-config/">context:annotation-config/</a>标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。<br>下面是几种比较重要的注解类型：<br>1.@Required：该注解应用于设值方法。<br>2.@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。<br>3.@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。<br>4.JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy。<br>10、请解释Spring Bean的生命周期？<br>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。<br>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。<br>1.初始化之后调用的回调方法。<br>2.销毁之前调用的回调方法。<br>Spring框架提供了以下四种方式来管理bean的生命周期事件：<br>InitializingBean和DisposableBean回调接口<br>针对特殊行为的其他Aware接口<br>Bean配置文件中的Custom init()方法和destroy()方法<br>@PostConstruct和@PreDestroy注解方式<br>使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下：<br><beans><br><bean id="demoBean" class="com.somnus.task.DemoBean" init-method="customInit" destroy-method="customDestroy"></bean><br></beans><br> <br> <br> <br>11、Spring Bean的作用域之间有什么区别？<br>Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：<br>1.singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。<br>2.prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。<br>3.request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。<br>4.Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。<br>5.global- session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果 你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。<br>全局作用域与Servlet中的session作用域效果相同。<br> <br>12、什么是Spring inner beans？<br> <br>在Spring框架中，无论何时bean被使用时，当仅被调用了一个属性。一个明智的做法是将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。<br>比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们的要做的是创建一个Person的实例，然后在Customer内部使用。<br>public class Customer{<br>private Person person;<br>//Setters and Getters<br>}   </p><p>public class Person{<br>private String name;<br>private String address;<br>private int age;<br>//Setters and Getters<br>}</p><p> <br> <br> <br> <br>内部bean的声明方式如下：</p><bean id="CustomerBean" class="com.somnus.common.Customer"><property name="person"><bean class="com.howtodoinjava.common.Person"><property name="name" value="lokesh"><property name="address" value="India"><property name="age" value="34"></bean></property></bean><p> <br> <br> <br> <br>13、Spring框架中的单例Beans是线程安全的么？<br>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。<br>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p><p> <br>14、请举例说明如何在Spring中注入一个Java Collection？<br> <br>Spring提供了以下四种集合类的配置元素：<br><list> :   该标签用来装配可重复的list值。<br><set> :    该标签用来装配没有重复的set值。<br><map>:   该标签可用来注入键和值可以为任何类型的键值对。<br><props> : 该标签支持注入键和值都是字符串类型的键值对。<br>下面看一下具体的例子：</props></map></set></list></p><beans><bean id="javaCollection" class="com.howtodoinjava.JavaCollection"><property name="customList"><list><value>INDIA</value><value>Pakistan</value><value>USA</value><value>UK</value></list></property><pre><code> &lt;!-- java.util.Set --&gt;    
 &lt;property name=&quot;customSet&quot;&gt;    
    &lt;set&gt;    
       &lt;value&gt;INDIA&lt;/value&gt;    
       &lt;value&gt;Pakistan&lt;/value&gt;    
       &lt;value&gt;USA&lt;/value&gt;    
       &lt;value&gt;UK&lt;/value&gt;    
    &lt;/set&gt;    
  &lt;/property&gt;    
 
 &lt;!-- java.util.Map --&gt;    
 &lt;property name=&quot;customMap&quot;&gt;    
    &lt;map&gt;    
       &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt;    
       &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt;    
       &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt;    
       &lt;entry key=&quot;4&quot; value=&quot;UK&quot;/&gt;    
    &lt;/map&gt;    
  &lt;/property&gt;    
 
&lt;!-- java.util.Properties --&gt;    
&lt;property name=&quot;customProperies&quot;&gt;    
    &lt;props&gt;    
        &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt;    
        &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt;    
    &lt;/props&gt;    
&lt;/property&gt;    
 
</code></pre></bean></beans><p> <br> <br> <br> <br>15、如何向Spring Bean中注入一个Java.util.Properties？<br>第一种方法是使用如下面代码所示的<props> 标签：</props></p><bean id="adminUser" class="com.somnus.common.Customer"><pre><code>&lt;!-- java.util.Properties --&gt;    
&lt;property name=&quot;emails&quot;&gt;    
    &lt;props&gt;    
        &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt;    
        &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt;    
    &lt;/props&gt;    
&lt;/property&gt;    
 
</code></pre></bean><p> <br> <br>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。<br> <br>16、请解释Spring Bean的自动装配？<br> <br>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring容器还可以自动装配合作关系bean之间的关联关系。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。<br>下面的XML配置文件表明了如何根据名称将一个bean设置为自动装配：<br> <br><bean id="employeeDAO" class="com.howtodoinjava.EmployeeDAOImpl" autowire="byName"><br> <br> <br> <br>除了bean配置文件中提供的自动装配模式，还可以使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在按照如下的配置方式在Spring配置文件进行配置才可以使用。<br>&lt;context:annotation-config /&gt;<br> <br> <br> <br>也可以通过在配置文件中配置AutowiredAnnotationBeanPostProcessor 达到相同的效果。<br> <br><bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"><br> <br> <br> <br>配置好以后就可以使用@Autowired来标注了。<br>@Autowired<br>public EmployeeDAOImpl ( EmployeeManager manager ) {<br>this.manager = manager;<br>}      </p><p> <br>17、请解释自动装配模式的区别？<br> <br>在Spring框架中共有5种自动装配，让我们逐一分析。<br>1.no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。<br>2.byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。<br>3.byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。<br>4.constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。<br>5.autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。<br>18、如何开启基于注解的自动装配？<br>要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：<br>1、引入配置文件中的<bean>下引入 <a href="context:annotation-config">context:annotation-config</a><br><beans><br>&lt;context:annotation-config /&gt;<br></beans><br> <br> <br> <br>2、在bean配置文件中直接引入AutowiredAnnotationBeanPostProcessor<br><beans><br><bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"><br></beans>        </bean></p><p>19、请举例解释@Required注解？<br>在产品级别的应用中，IoC容器可能声明了数十万了bean，bean与bean之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在<bean>中设置“dependency-check”来解决这个问题。<br>在应用程序的生命周期中，你可能不大愿意花时间在验证所有bean的属性是否按照上下文文件正确配置。或者你宁可验证某个bean的特定属性是否被正确的设置。即使是用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。<br>需要用如下的方式使用来标明bean的设值方法。  </bean></p><p>public class EmployeeFactoryBean extends AbstractFactoryBean<object>{<br>private String designation;<br>public String getDesignation() {<br>return designation;<br>}<br>@Required<br>public void setDesignation(String designation) {<br>this.designation = designation;<br>}<br>//more code here<br>}</object></p><p> <br> <br> <br>RequiredAnnotationBeanPostProcessor是Spring中的后置处理用来验证被@Required 注解的bean属性是否被正确的设置了。在使用RequiredAnnotationBeanPostProcesso来验证bean属性之前，首先要在IoC容器中对其进行注册：<br> <br> <br><bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"><br> <br> <br> <br>但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个BeanInitializationException 异常。<br> <br>20、请举例解释@Autowired注解？<br> <br>@Autowired注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired注解可以像@Required注解、构造器一样被用于在bean的设值方法上自动装配bean的属性，一个参数或者带有任意名称或带有多个参数的方法。<br>比如，可以在设值方法上使用@Autowired注解来替代配置文件中的 <property>元素。当Spring容器在setter方法上找到@Autowired注解时，会尝试用byType 自动装配。<br>当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个bean时将会被自动装配，即便在配置文件中使用<constructor-arg> 元素。</constructor-arg></property></p><p>public class TextEditor {<br>private SpellChecker spellChecker;<br>@Autowired<br>public TextEditor(SpellChecker spellChecker){<br>System.out.println(“Inside TextEditor constructor.” );<br>this.spellChecker = spellChecker;<br>}<br>public void spellCheck(){<br>spellChecker.checkSpelling();<br>}<br>}</p><p> <br> <br>下面是没有构造参数的配置方式：  </p><beans><p><a href="context:annotation-config/">context:annotation-config/</a></p><bean id="textEditor" class="com.howtodoinjava.TextEditor"><bean id="spellChecker" class="com.howtodoinjava.SpellChecker"></beans><p>     </p><p> <br>21、请举例说明@Qualifier注解？<br> <br>@Qualifier注解意味着可以在被标注bean的字段上可以自动装配。Qualifier注解可以用来取消Spring不能取消的bean应用。<br>下面的示例将会在Customer的person属性中自动装配person的值。<br>public class Customer{<br>@Autowired<br>private Person person;<br>}<br> <br> <br> <br>下面我们要在配置文件中来配置Person类。  </p><bean id="customer" class="com.somnus.common.Customer"><bean id="personA" class="com.somnus.common.Person"><property name="name" value="lokesh"></bean><bean id="personB" class="com.somnus.common.Person"><property name="name" value="alex"></bean><p> <br> <br>  <br> <br>Spring会知道要自动装配哪个person bean么？不会的，但是运行上面的示例时，会抛出下面的异常：<br> <br>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException:<br>No unique bean of type [com.howtodoinjava.common.Person] is defined:<br>expected single matching bean but found 2: [personA, personB]<br> <br> <br> <br>要解决上面的问题，需要使用 @Quanlifier注解来告诉Spring容器要装配哪个bean：<br> <br>public class Customer{<br>@Autowired<br>@Qualifier(“personA”)<br>private Person person;<br>}      </p><p>22、构造方法注入和设值注入有什么区别？<br>请注意以下明显的区别：<br>1.在设值注入方法支持大部分的依赖注入，如果我们仅需 要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法 注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。<br>2.设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。<br>3.在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。<br>4.在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。<br>23、Spring框架中有哪些不同类型的事件？<br>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。<br>我们可以创建bean用来监听在ApplicationContext 中发布的事件。ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><p>public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt;{<br>@Override<br>public void onApplicationEvent(ApplicationEvent applicationEvent)<br>{<br>//process event<br>}<br>}</p><p>     </p><p>Spring 提供了以下5中标准的事件：<br>1.上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。<br>2.上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。<br>3.上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。<br>4.上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。<br>5.请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。<br>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。<br>public class CustomApplicationEvent extends ApplicationEvent{<br>public CustomApplicationEvent ( Object source, final String msg ){<br>super(source);<br>System.out.println(“Created a Custom event”);<br>}<br>}<br> <br> <br> <br>为了监听这个事件，还需要创建一个监听器：<br>public class CustomEventListener implements ApplicationListener &lt; CustomApplicationEvent &gt;{<br>@Override<br>public void onApplicationEvent(CustomApplicationEvent applicationEvent) {<br>//handle event<br>}<br>}      </p><p>之后通过applicationContext接口的publishEvent()方法来发布自定义事件。<br>CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext, “Test message”);<br>applicationContext.publishEvent(customEvent);      </p><p>24、FileSystemResource和ClassPathResource有何区别？<br>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。<br>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。<br>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。<br>25、Spring 框架中都用到了哪些设计模式？<br>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：<br>o代理模式—在AOP和remoting中被用的比较多。<br>o单例模式—在spring配置文件中定义的bean默认为单例模式。<br>o模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。<br>o前端控制器—Spring提供了DispatcherServlet来对请求进行分发。<br>o视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。<br>o依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。<br>o工厂模式—BeanFactory用来创建对象的实例      </p><ol><li>开发中主要使用 Spring 的什么技术 ?<br>①. IOC 容器管理各层的组件<br>②. 使用 AOP 配置声明式事务<br>③. 整合其他框架.  </li><li>简述 AOP 和 IOC 概念 AOP:<br>Aspect Oriented Program, 面向(方面)切面的编程;Filter(过滤器) 也是一种 AOP. AOP 是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充. AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点.可以举例通过事务说明.</li></ol><p> <br>IOC: Invert Of Control, 控制反转. 也成为 DI(依赖注入)其思想是反转 资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源.作为 回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送 给它所管理的组件,组件所要做的仅是选择一种合适的方式来接受资源. 这种行 为也被称为查找的被动形式<br> <br>3. 在 Spring 中如何配置 Bean ?<br>Bean 的配置方式: 通过全类名（反射）、通过工厂方法（静态工厂方法 &amp; 实 例工厂方法）、FactoryBean<br> <br>4. IOC 容器对 Bean 的生命周期:<br>①. 通过构造器或工厂方法创建 Bean 实例<br>②. 为 Bean 的属性设置值和对其他 Bean 的引用<br>③ . 将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的 postProcessBeforeInitialization 方法<br>④. 调用 Bean 的初始化方法(init-method)<br>⑤ . 将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的 postProcessAfterInitialization 方法<br>⑦. Bean 可以使用了<br>⑧. 当容器关闭时, 调用 Bean 的销毁方法(destroy-method)</p><p>Spring源码分析之IoC<br>一、 什么是Ioc/DI？<br>二、 Spring IOC体系结构<br>(1) BeanFactory<br>(2) BeanDefinition<br>三、 IoC容器的初始化<br>1、 XmlBeanFactory(屌丝IOC)的整个流程<br>2、 FileSystemXmlApplicationContext 的IOC容器流程<br>1、高富帅IOC解剖<br>2、 设置资源加载器和资源定位<br>3、AbstractApplicationContext的refresh函数载入Bean定义过程：<br>4、AbstractApplicationContext子类的refreshBeanFactory()方法：<br>5、AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法：<br>6、AbstractBeanDefinitionReader读取Bean定义资源：<br>7、资源加载器获取要读入的资源：<br>8、XmlBeanDefinitionReader加载Bean定义资源：<br>9、DocumentLoader将Bean定义资源转换为Document对象：<br>10、XmlBeanDefinitionReader解析载入的Bean定义资源文件：<br>11、DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析：<br>12、BeanDefinitionParserDelegate解析Bean定义资源文件中的<bean>元素：<br>13、BeanDefinitionParserDelegate解析<property>元素：<br>14、解析<property>元素的子元素：<br>15、解析<list>子元素：<br>16、解析过后的BeanDefinition在IoC容器中的注册：<br>17、DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition：<br>总结：<br>四、IOC容器的依赖注入<br>1、依赖注入发生的时间<br>2、AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean：<br>3、AbstractAutowireCapableBeanFactory创建Bean实例对象：<br>4、createBeanInstance方法创建Bean的java实例对象：<br>5、SimpleInstantiationStrategy类使用默认的无参构造方法创建Bean实例化对象：<br>6、populateBean方法对Bean属性的依赖注入：<br>7、BeanDefinitionValueResolver解析属性值：<br>8、BeanWrapperImpl对Bean属性的依赖注入：<br>五、IoC容器的高级特性<br>1、介绍<br>2、Spring IoC容器的lazy-init属性实现预实例化：<br>(1) .refresh()<br>(2).finishBeanFactoryInitialization处理预实例化Bean：<br>(3) .DefaultListableBeanFactory对配置lazy-init属性单态Bean的预实例化：<br>3、FactoryBean的实现：<br>(1).FactoryBean的源码如下：<br>(2). AbstractBeanFactory的getBean方法调用FactoryBean：<br>(3)、AbstractBeanFactory生产Bean实例对象：<br>(4).工厂Bean的实现类getObject方法创建Bean实例对象：<br>4.BeanPostProcessor后置处理器的实现：<br>(1).BeanPostProcessor的源码如下：<br>(2).AbstractAutowireCapableBeanFactory类对容器生成的Bean添加后置处理器：<br>(3).initializeBean方法为容器产生的Bean实例对象添加BeanPostProcessor后置处理器：<br>(4).AdvisorAdapterRegistrationManager在Bean对象初始化后注册通知适配器：<br>5.Spring IoC容器autowiring实现原理：<br>(1). AbstractAutoWireCapableBeanFactory对Bean实例进行属性依赖注入：<br>(2).Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入：<br>(3).DefaultSingletonBeanRegistry的registerDependentBean方法对属性注入：<br> <br>一、什么是Ioc/DI？<br>    IoC 容器：最主要是完成了完成对象的创建和依赖的管理注入等等。<br>先从我们自己设计这样一个视角来考虑：<br>所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。<br>对象和对象关系怎么表示？<br>可以用 xml ， properties 文件等语义化配置文件表示。<br>描述对象关系的文件存放在哪里？<br>可能是 classpath ， filesystem ，或者是 URL 网络资源， servletContext 等。<br>回到正题，有了配置文件，还需要对配置文件解析。<br>不同的配置文件对对象的描述不一样，如标准的，自定义声明式的，如何统一？ 在内部需要有一个统一的关于对象的定义，所有外部的描述都必须转化成统一的描述定义。<br>如何对不同的配置文件进行解析？需要对不同的配置文件语法，采用不同的解析器<br> <br>二、 Spring IOC体系结构？<br>(1) BeanFactory<br>         Spring Bean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，其相互关系如下：</list></property></property></bean></p><p> <br>其中BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范，BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为.<br>最基本的IOC容器接口BeanFactory  </p><p>1 public interface BeanFactory {<br>2<br>3 //对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，<br>4 //如果需要得到工厂本身，需要转义<br>5 String FACTORY_BEAN_PREFIX = “&amp;”;<br>6<br>7 //根据bean的名字，获取在IOC容器中得到bean实例<br>8 Object getBean(String name) throws BeansException;<br>9<br>10 //根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。<br>11 Object getBean(String name, Class requiredType) throws BeansException;<br>12<br>13 //提供对bean的检索，看看是否在IOC容器有这个名字的bean<br>14 boolean containsBean(String name);<br>15<br>16 //根据bean名字得到bean实例，并同时判断这个bean是不是单例<br>17 boolean isSingleton(String name) throws NoSuchBeanDefinitionException;<br>18<br>19 //得到bean实例的Class类型<br>20 Class getType(String name) throws NoSuchBeanDefinitionException;<br>21<br>22 //得到bean的别名，如果根据别名检索，那么其原名也会被检索出来<br>23 String[] getAliases(String name);<br>24<br>}</p><p> <br> <br> <br>在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的bean是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。<br> <br>            而要知道工厂是如何产生对象的，我们需要看具体的IOC容器实现，spring提供了许多IOC容器的实现。比如XmlBeanFactory，ClasspathXmlApplicationContext等。其中XmlBeanFactory就是针对最基本的ioc容器的实现，这个IOC容器可以读取XML文件定义的BeanDefinition（XML文件中对bean的描述）,如果说XmlBeanFactory是容器中的屌丝，ApplicationContext应该算容器中的高帅富.<br> <br>            ApplicationContext是Spring提供的一个高级的IoC容器，它除了能够提供IoC容器的基本功能外，还为用户提供了以下的附加服务。<br> <br>从ApplicationContext接口的实现，我们看出其特点：<br> <br>         1.  支持信息源，可以实现国际化。（实现MessageSource接口）<br> <br>         2.  访问资源。(实现ResourcePatternResolver接口，这个后面要讲)<br> <br>         3.  支持应用事件。(实现ApplicationEventPublisher接口)<br> <br> <br> <br>(2) BeanDefinition<br> <br>         SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的，其继承体系如下：</p><p> <br>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成：</p><p>三、IoC容器的初始化？<br>       IoC容器的初始化包括BeanDefinition的Resource定位、载入和注册这三个基本的过程。我们以ApplicationContext为例讲解，ApplicationContext系列容器也许是我们最熟悉的，因为web项目中使用的XmlWebApplicationContext就属于这个继承体系，还有ClasspathXmlApplicationContext等，其继承体系如下图所示：</p><p> <br>ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的bean定义环境。<br> <br>下面我们分别简单地演示一下两种ioc容器的创建过程<br>1、XmlBeanFactory(屌丝IOC)的整个流程<br> <br>通过XmlBeanFactory的源码，我们可以发现:  </p><p>public class XmlBeanFactory extends DefaultListableBeanFactory{</p><pre><code> private final XmlBeanDefinitionReader reader; 


 public XmlBeanFactory(Resource resource)throws BeansException&#123;
     this(resource, null);
 &#125;
 

 public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory)
      throws BeansException&#123;
     super(parentBeanFactory);
     this.reader = new XmlBeanDefinitionReader(this);
     this.reader.loadBeanDefinitions(resource);
&#125;
</code></pre><p>}</p><p>   </p><p>//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息<br>ClassPathResource resource =new ClassPathResource(“application-context.xml”);<br>//创建DefaultListableBeanFactory<br>DefaultListableBeanFactory factory =new DefaultListableBeanFactory();<br>//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory<br>XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(factory);<br>//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用<br>reader.loadBeanDefinitions(resource);</p><p>通过前面的源码，this.reader = new XmlBeanDefinitionReader(this); 中其中this 传的是factory对象<br> <br> <br>2、FileSystemXmlApplicationContext 的IOC容器流程<br> <br>1、高富帅IOC解剖<br> <br> <br> <br>1   ApplicationContext =new FileSystemXmlApplicationContext(xmlPath);<br> <br>先看其构造函数：<br> <br>   调用构造函数：</p><p>/**</p><ul><li>Create a new FileSystemXmlApplicationContext, loading the definitions</li><li>from the given XML files and automatically refreshing the context.</li><li>@param configLocations array of file paths</li><li>@throws BeansException if context creation failed</li><li>/public FileSystemXmlApplicationContext(String… configLocations) throws BeansException {<pre><code>  this(configLocations, true, null);
</code></pre>}</li></ul><p>实际调用</p><p>public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)<br>throws BeansException {<br>super(parent);<br>setConfigLocations(configLocations);<br>if (refresh) {<br>refresh();<br>}<br>}</p><p> <br> <br>2、设置资源加载器和资源定位<br> <br>通过分析FileSystemXmlApplicationContext的源代码可以知道，在创建FileSystemXmlApplicationContext容器时，构造方法做以下两项重要工作：<br>首先，调用父类容器的构造方法(super(parent)方法)为容器设置好Bean资源加载器。<br>然后，再调用父类AbstractRefreshableConfigApplicationContext的setConfigLocations(configLocations)方法设置Bean定义资源文件的定位路径。<br>通过追踪FileSystemXmlApplicationContext的继承体系，发现其父类的父类AbstractApplicationContext中初始化IoC容器所做的主要源码如下：  </p><p>public abstract class AbstractApplicationContext extends DefaultResourceLoader<br>implements ConfigurableApplicationContext, DisposableBean {<br>//静态初始化块，在整个容器创建过程中只执行一次<br>static {<br>//为了避免应用程序在Weblogic8.1关闭时出现类加载异常加载问题，加载IoC容<br>//器关闭事件(ContextClosedEvent)类<br>ContextClosedEvent.class.getName();<br>}<br>//FileSystemXmlApplicationContext调用父类构造方法调用的就是该方法<br>public AbstractApplicationContext(ApplicationContext parent) {<br>this.parent = parent;<br>this.resourcePatternResolver = getResourcePatternResolver();<br>}<br>//获取一个Spring Source的加载器用于读入Spring Bean定义资源文件<br>protected ResourcePatternResolver getResourcePatternResolver() {<br>// AbstractApplicationContext继承DefaultResourceLoader，也是一个S<br>//Spring资源加载器，其getResource(String location)方法用于载入资源<br>return new PathMatchingResourcePatternResolver(this);<br>}<br>……<br>}</p><p> <br> <br> <br> <br>AbstractApplicationContext构造方法中调用PathMatchingResourcePatternResolver的构造方法创建Spring资源加载器：<br> <br>public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {<br>Assert.notNull(resourceLoader, “ResourceLoader must not be null”);<br>//设置Spring的资源加载器<br>this.resourceLoader = resourceLoader;<br>}<br> <br>在设置容器的资源加载器之后，接下来FileSystemXmlApplicationContet执行setConfigLocations方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean定义资源文件的定位，该方法的源码如下：  </p><pre><code>//处理单个资源文件路径为一个字符串的情况  
public void setConfigLocation(String location) &#123;  
   //String CONFIG_LOCATION_DELIMITERS = &quot;,; /t/n&quot;;  
   //即多个资源文件路径之间用” ,; /t/n”分隔，解析成数组形式  
    setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));  
&#125;  

//解析Bean定义资源文件的路径，处理多个资源文件字符串数组  
 public void setConfigLocations(String[] locations) &#123;  
    if (locations != null) &#123;  
        Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);  
        this.configLocations = new String[locations.length];  
        for (int i = 0; i &lt; locations.length; i++) &#123;  
            // resolvePath为同一个类中将字符串解析为路径的方法  
            this.configLocations[i] = resolvePath(locations[i]).trim();  
        &#125;  
    &#125;  
    else &#123;  
        this.configLocations = null;  
    &#125;  
&#125; 
</code></pre><p> <br> <br>通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个Spring Bean定义资源文件，也可以使用字符串数组，即下面两种方式都是可以的：<br>a.    ClasspathResource res = new ClasspathResource(“a.xml,b.xml,……”);<br>多个资源文件路径之间可以是用” ,; /t/n”等分隔。<br>b.    ClasspathResource res = new ClasspathResource(newString[]{“a.xml”,”b.xml”,……});<br>至此，Spring IoC容器在初始化时将配置的Bean定义资源文件定位为Spring封装的Resource。<br> <br>3、AbstractApplicationContext的refresh函数载入Bean定义过程：<br> <br>Spring IoC容器对Bean定义资源的载入是从refresh()函数开始的，refresh()是一个模板方法，refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入<br>FileSystemXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh()函数启动整个IoC容器对Bean定义的载入过程：  </p><p>1 public void refresh() throws BeansException, IllegalStateException {<br>2 synchronized (this.startupShutdownMonitor) {<br>3 //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识<br>4 prepareRefresh();<br>5 //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从<br>6 //子类的refreshBeanFactory()方法启动<br>7 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>8 //为BeanFactory配置容器特性，例如类加载器、事件处理器等<br>9 prepareBeanFactory(beanFactory);<br>10 try {<br>11 //为容器的某些子类指定特殊的BeanPost事件处理器<br>12 postProcessBeanFactory(beanFactory);<br>13 //调用所有注册的BeanFactoryPostProcessor的Bean<br>14 invokeBeanFactoryPostProcessors(beanFactory);<br>15 //为BeanFactory注册BeanPost事件处理器.<br>16 //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件<br>17 registerBeanPostProcessors(beanFactory);<br>18 //初始化信息源，和国际化相关.<br>19 initMessageSource();<br>20 //初始化容器事件传播器.<br>21 initApplicationEventMulticaster();<br>22 //调用子类的某些特殊Bean初始化方法<br>23 onRefresh();<br>24 //为事件传播器注册事件监听器.<br>25 registerListeners();<br>26 //初始化所有剩余的单态Bean.<br>27 finishBeanFactoryInitialization(beanFactory);<br>28 //初始化容器的生命周期事件处理器，并发布容器的生命周期事件<br>29 finishRefresh();<br>30 }<br>31 catch (BeansException ex) {<br>32 //销毁以创建的单态Bean<br>33 destroyBeans();<br>34 //取消refresh操作，重置容器的同步标识.<br>35 cancelRefresh(ex);<br>36 throw ex;<br>37 }<br>38 }<br>39 }</p><p> <br>refresh()方法主要为IoC容器Bean的生命周期管理提供条件，Spring IoC容器载入Bean定义资源文件从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。<br> <br> refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入<br> <br>AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()方法，启动容器载入Bean定义资源文件的过程，代码如下：</p><pre><code>protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;  
    //这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法
     refreshBeanFactory();  
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();  
    if (logger.isDebugEnabled()) &#123;  
        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);  
    &#125;  
    return beanFactory;  
&#125; 
</code></pre><p> <br>AbstractApplicationContext子类的refreshBeanFactory()方法：<br> <br>   AbstractApplicationContext类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类AbstractRefreshableApplicationContext实现的    refreshBeanFactory()方法，方法的源码如下：  </p><p>1 protected final void refreshBeanFactory() throws BeansException {<br>2 if (hasBeanFactory()) {//如果已经有容器，销毁容器中的bean，关闭容器<br>3 destroyBeans();<br>4 closeBeanFactory();<br>5 }<br>6 try {<br>7 //创建IoC容器<br>8 DefaultListableBeanFactory beanFactory = createBeanFactory();<br>9 beanFactory.setSerializationId(getId());<br>10 //对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等<br>11 customizeBeanFactory(beanFactory);<br>12 //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器<br>13 loadBeanDefinitions(beanFactory);<br>14 synchronized (this.beanFactoryMonitor) {<br>15 this.beanFactory = beanFactory;<br>16 }<br>17 }<br>18 catch (IOException ex) {<br>19 throw new ApplicationContextException(“I/O error parsing bean definition source for “ + getDisplayName(), ex);<br>20 }<br>21 }</p><p> <br> <br> <br> <br> <br> <br>在这个方法中，先判断BeanFactory是否存在，如果存在则先销毁beans并关闭beanFactory，接着创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean<br> <br>定义。<br> <br> <br> <br>5、AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法：<br> <br> <br> <br>AbstractRefreshableApplicationContext中只定义了抽象的loadBeanDefinitions方法，容器真正调用的是其子类AbstractXmlApplicationContext对该方法的实现，AbstractXmlApplicationContext的主要源码如下：<br> <br>loadBeanDefinitions方法同样是抽象方法，是由其子类实现的，也即在AbstractXmlApplicationContext中。  </p><p>1 public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {<br>2 ……<br>3 //实现父类抽象的载入Bean定义方法<br>4 @Override<br>5 protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {<br>6 //创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容 器使用该读取器读取Bean定义资源<br>7 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);<br>8 //为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的<br>9 //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器<br>10 beanDefinitionReader.setResourceLoader(this);<br>11 //为Bean读取器设置SAX xml解析器<br>12 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));<br>13 //当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制<br>14 initBeanDefinitionReader(beanDefinitionReader);<br>15 //Bean读取器真正实现加载的方法<br>16 loadBeanDefinitions(beanDefinitionReader);<br>17 }<br>18 //Xml Bean读取器加载Bean定义资源<br>19 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {<br>20 //获取Bean定义资源的定位<br>21 Resource[] configResources = getConfigResources();<br>22 if (configResources != null) {<br>23 //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位<br>24 //的Bean定义资源<br>25 reader.loadBeanDefinitions(configResources);<br>26 }<br>27 //如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源<br>28 String[] configLocations = getConfigLocations();<br>29 if (configLocations != null) {<br>30 //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位<br>31 //的Bean定义资源<br>32 reader.loadBeanDefinitions(configLocations);<br>33 }<br>34 }<br>35 //这里又使用了一个委托模式，调用子类的获取Bean定义资源定位的方法<br>36 //该方法在ClassPathXmlApplicationContext中进行实现，对于我们<br>37 //举例分析源码的FileSystemXmlApplicationContext没有使用该方法<br>38 protected Resource[] getConfigResources() {<br>39 return null;<br>40 } ……<br>41}</p><p> <br> <br> <br> <br> <br> <br>Xml Bean读取器(XmlBeanDefinitionReader)调用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions方法读取Bean定义资源。<br> <br>由于我们使用FileSystemXmlApplicationContext作为例子分析，因此getConfigResources的返回值为null，因此程序执行reader.loadBeanDefinitions(configLocations)分支。<br> <br> <br> <br>6、AbstractBeanDefinitionReader读取Bean定义资源：<br> <br> <br> <br>AbstractBeanDefinitionReader的loadBeanDefinitions方法源码如下：<br> <br> 可以到org.springframework.beans.factory.support看一下BeanDefinitionReader的结构</p><p> <br> <br>在其抽象父类AbstractBeanDefinitionReader中定义了载入过程  </p><p>1 //重载方法，调用下面的loadBeanDefinitions(String, Set<resource>);方法<br>2 public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {<br>3 return loadBeanDefinitions(location, null);<br>4 }<br>5 public int loadBeanDefinitions(String location, Set<resource>actualResources) throws BeanDefinitionStoreException {<br>6 //获取在IoC容器初始化过程中设置的资源加载器<br>7 ResourceLoader resourceLoader = getResourceLoader();<br>8 if (resourceLoader == null) {<br>9 throw new BeanDefinitionStoreException(<br>10 “Cannot import bean definitions from location [“ + location + “]: no ResourceLoader available”);<br>11 }<br>12 if (resourceLoader instanceof ResourcePatternResolver) {<br>13 try {<br>14 //将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源<br>15 //加载多个指定位置的Bean定义资源文件<br>16 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>17 //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能<br>18 int loadCount = loadBeanDefinitions(resources);<br>19 if (actualResources != null) {<br>20 for (Resource resource : resources) {<br>21 actualResources.add(resource);<br>22 }<br>23 }<br>24 if (logger.isDebugEnabled()) {<br>25 logger.debug(“Loaded “ + loadCount + “ bean definitions from location pattern [“ + location + “]”);<br>26 }<br>27 return loadCount;<br>28 }<br>29 catch (IOException ex) {<br>30 throw new BeanDefinitionStoreException(<br>31 “Could not resolve bean definition resource pattern [“ + location + “]”, ex);<br>32 }<br>33 }<br>34 else {<br>35 //将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源<br>36 //加载单个指定位置的Bean定义资源文件<br>37 Resource resource = resourceLoader.getResource(location);<br>38 //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能<br>39 int loadCount = loadBeanDefinitions(resource);<br>40 if (actualResources != null) {<br>41 actualResources.add(resource);<br>42 }<br>43 if (logger.isDebugEnabled()) {<br>44 logger.debug(“Loaded “ + loadCount + “ bean definitions from location [“ + location + “]”);<br>45 }<br>46 return loadCount;<br>47 }<br>48 }<br>49 //重载方法，调用loadBeanDefinitions(String);<br>50 public int loadBeanDefinitions(String… locations) throws BeanDefinitionStoreException {<br>51 Assert.notNull(locations, “Location array must not be null”);<br>52 int counter = 0;<br>53 for (String location : locations) {<br>54 counter += loadBeanDefinitions(location);<br>55 }<br>56 return counter;<br>}</resource></resource></p><p> <br> <br> <br> <br> <br>loadBeanDefinitions(Resource…resources)方法和上面分析的3个方法类似，同样也是调用XmlBeanDefinitionReader的loadBeanDefinitions方法。<br> <br>从对AbstractBeanDefinitionReader的loadBeanDefinitions方法源码分析可以看出该方法做了以下两件事：<br> <br>首先，调用资源加载器的获取资源方法resourceLoader.getResource(location)，获取到要加载的资源。<br> <br>其次，真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinitions方法。<br> <br> <br>看到第8、16行，结合上面的ResourceLoader与ApplicationContext的继承关系图，可以知道此时调用的是DefaultResourceLoader中的getSource()方法定位Resource，因为FileSystemXmlApplicationContext本身就是DefaultResourceLoader的实现类，所以此时又回到了FileSystemXmlApplicationContext中来。<br> <br>7、资源加载器获取要读入的资源：<br> <br>XmlBeanDefinitionReader通过调用其父类DefaultResourceLoader的getResource方法获取要加载的资源，其源码如下  </p><p>1 //获取Resource的具体实现方法<br>2 public Resource getResource(String location) {<br>3 Assert.notNull(location, “Location must not be null”);<br>4 //如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象<br>5 if (location.startsWith(CLASSPATH_URL_PREFIX)) {<br>6 return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());<br>7 }<br>8 try {<br>9 // 如果是URL 方式，使用UrlResource 作为bean 文件的资源对象<br>10 URL url = new URL(location);<br>11 return new UrlResource(url);<br>12 }<br>13 catch (MalformedURLException ex) {<br>14 }<br>15 //如果既不是classpath标识，又不是URL标识的Resource定位，则调用<br>16 //容器本身的getResourceByPath方法获取Resource<br>17 return getResourceByPath(location);<br>18<br>19 }</p><p> <br>FileSystemXmlApplicationContext容器提供了getResourceByPath方法的实现，就是为了处理既不是classpath标识，又不是URL标识的Resource定位这种情况。  </p><p>protected Resource getResourceByPath(String path) {<br>if (path != null &amp;&amp; path.startsWith(“/“)) {<br>path = path.substring(1);<br>}<br>//这里使用文件系统资源对象来定义bean 文件<br>return new FileSystemResource(path);<br>}</p><p> <br>这样代码就回到了 FileSystemXmlApplicationContext 中来，他提供了FileSystemResource 来完成从文件系统得到配置文件的资源定义。<br>这样，就可以从文件系统路径上对IOC 配置文件进行加载 - 当然我们可以按照这个逻辑从任何地方加载，在Spring 中我们看到它提供 的各种资源抽象，比如ClassPathResource, URLResource,FileSystemResource 等来供我们使用。上面我们看到的是定位Resource 的一个过程，而这只是加载过程的一部分.<br>     <br> <br> <br>8、XmlBeanDefinitionReader加载Bean定义资源：<br>     <br>     Bean定义的Resource得到了<br>     继续回到XmlBeanDefinitionReader的loadBeanDefinitions(Resource …)方法看到代表bean文件的资源定义以后的载入过程。</p><p>1 //XmlBeanDefinitionReader加载资源的入口方法<br>2 public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {<br>3 //将读入的XML资源进行特殊编码处理<br>4 return loadBeanDefinitions(new EncodedResource(resource));<br>5 }<br>//这里是载入XML形式Bean定义资源文件方法<br>6 public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {<br>7 …….<br>8 try {<br>9 //将资源文件转为InputStream的IO流<br>10 InputStream inputStream = encodedResource.getResource().getInputStream();<br>11 try {<br>12 //从InputStream中得到XML的解析源<br>13 InputSource inputSource = new InputSource(inputStream);<br>14 if (encodedResource.getEncoding() != null) {<br>15 inputSource.setEncoding(encodedResource.getEncoding());<br>16 }<br>17 //这里是具体的读取过程<br>18 return doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>19 }<br>20 finally {<br>21 //关闭从Resource中得到的IO流<br>22 inputStream.close();<br>23 }<br>24 }<br>25 ………<br>26}<br>27 //从特定XML文件中实际载入Bean定义资源的方法<br>28 protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)<br>29 throws BeanDefinitionStoreException {<br>30 try {<br>31 int validationMode = getValidationModeForResource(resource);<br>32 //将XML文件转换为DOM对象，解析过程由documentLoader实现<br>33 Document doc = this.documentLoader.loadDocument(<br>34 inputSource, this.entityResolver, this.errorHandler, validationMode, this.namespaceAware);<br>35 //这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则<br>36 return registerBeanDefinitions(doc, resource);<br>37 }<br>38 …….<br>}</p><p> <br> <br> <br> <br> <br>通过源码分析，载入Bean定义资源文件的最后一步是将Bean定义资源转换为Document对象，该过程由documentLoader实现<br> <br>    <br> <br>9、DocumentLoader将Bean定义资源转换为Document对象：<br> <br>      <br> <br>DocumentLoader将Bean定义资源转换成Document对象的源码如下：  </p><p>1 //使用标准的JAXP将载入的Bean定义资源转换成document对象<br>2 public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,<br>3 ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {<br>4 //创建文件解析器工厂<br>5 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);<br>6 if (logger.isDebugEnabled()) {<br>7 logger.debug(“Using JAXP provider [“ + factory.getClass().getName() + “]”);<br>8 }<br>9 //创建文档解析器<br>10 DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);<br>11 //解析Spring的Bean定义资源<br>12 return builder.parse(inputSource);<br>13 }<br>14 protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)<br>15 throws ParserConfigurationException {<br>16 //创建文档解析工厂<br>17 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();<br>18 factory.setNamespaceAware(namespaceAware);<br>19 //设置解析XML的校验<br>20 if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {<br>21 factory.setValidating(true);<br>22 if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {<br>23 factory.setNamespaceAware(true);<br>24 try {<br>25 factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);<br>26 }<br>27 catch (IllegalArgumentException ex) {<br>28 ParserConfigurationException pcex = new ParserConfigurationException(<br>29 “Unable to validate using XSD: Your JAXP provider [“ + factory +<br>30 “] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? “ +<br>31 “Upgrade to Apache Xerces (or Java 1.5) for full XSD support.”);<br>32 pcex.initCause(ex);<br>33 throw pcex;<br>34 }<br>35 }<br>36 }<br>37 return factory;<br>38 }</p><p> <br>该解析过程调用JavaEE标准的JAXP标准进行处理。<br>至此Spring IoC容器根据定位的Bean定义资源文件，将其加载读入并转换成为Document对象过程完成。<br> <br> <br>接下来我们要继续分析Spring IoC容器将载入的Bean定义资源文件转换为Document对象之后，是如何将其解析为Spring IoC管理的Bean对象并将其注册到容器中的。<br> <br>10、XmlBeanDefinitionReader解析载入的Bean定义资源文件：<br> <br> XmlBeanDefinitionReader类中的doLoadBeanDefinitions方法是从特定XML文件中实际载入Bean定义资源的方法，该方法在载入Bean定义资源之后将其转换为Document对象，接下来调用registerBeanDefinitions启动Spring IoC容器对Bean定义的解析过程，registerBeanDefinitions方法源码如下：  </p><p>1 //按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构<br>2 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {<br>3 //得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析<br>4 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<br>5 //获得容器中注册的Bean数量<br>6 int countBefore = getRegistry().getBeanDefinitionCount();<br>7 //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成<br>8 documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>9 //统计解析的Bean数量<br>10 return getRegistry().getBeanDefinitionCount() - countBefore;<br>11 }<br>12 //创建BeanDefinitionDocumentReader对象，解析Document对象<br>13 protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {<br>14 return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));<br>}</p><p> <br>Bean定义资源的载入解析分为以下两个过程：<br>首先，通过调用XML解析器将Bean定义资源文件转换得到Document对象，但是这些Document对象并没有按照Spring的Bean规则进行解析。这一步是载入的过程<br>其次，在完成通用的XML解析之后，按照Spring的Bean规则对Document对象进行解析。<br>按照Spring的Bean规则对Document对象解析的过程是在接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader中实现的。<br> <br>11、DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析：<br> <br>BeanDefinitionDocumentReader接口通过registerBeanDefinitions方法调用其实现类DefaultBeanDefinitionDocumentReader对Document对象进行解析，解析的代码如下：        </p><p>1 //根据Spring DTD对Bean的定义规则解析Bean定义Document对象<br>2 public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {<br>3 //获得XML描述符<br>4 this.readerContext = readerContext;<br>5 logger.debug(“Loading bean definitions”);<br>6 //获得Document的根元素<br>7 Element root = doc.getDocumentElement();<br>8 //具体的解析过程由BeanDefinitionParserDelegate实现，<br>9 //BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素<br>10 BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);<br>11 //在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性<br>12 preProcessXml(root);<br>13 //从Document的根元素开始进行Bean定义的Document对象<br>14 parseBeanDefinitions(root, delegate);<br>15 //在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性<br>16 postProcessXml(root);<br>17 }<br>18 //创建BeanDefinitionParserDelegate，用于完成真正的解析过程<br>19 protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root) {<br>20 BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);<br>21 //BeanDefinitionParserDelegate初始化Document根元素<br>22 delegate.initDefaults(root);<br>23 return delegate;<br>24 }<br>25 //使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象<br>26 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {<br>27 //Bean定义的Document对象使用了Spring默认的XML命名空间<br>28 if (delegate.isDefaultNamespace(root)) {<br>29 //获取Bean定义的Document对象根元素的所有子节点<br>30 NodeList nl = root.getChildNodes();<br>31 for (int i = 0; i &lt; nl.getLength(); i++) {<br>32 Node node = nl.item(i);<br>33 //获得Document节点是XML元素节点<br>34 if (node instanceof Element) {<br>35 Element ele = (Element) node;<br>36 //Bean定义的Document的元素节点使用的是Spring默认的XML命名空间<br>37 if (delegate.isDefaultNamespace(ele)) {<br>38 //使用Spring的Bean规则解析元素节点<br>39 parseDefaultElement(ele, delegate);<br>40 }<br>41 else {<br>42 //没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点<br>43 delegate.parseCustomElement(ele);<br>44 }<br>45 }<br>46 }<br>47 }<br>48 else {<br>49 //Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的<br>50 //解析规则解析Document根节点<br>51 delegate.parseCustomElement(root);<br>52 }<br>53 }<br>54 //使用Spring的Bean规则解析Document元素节点<br>55 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {<br>56 //如果元素节点是<import>导入元素，进行导入解析<br>57 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {<br>58 importBeanDefinitionResource(ele);<br>59 }<br>60 //如果元素节点是<alias>别名元素，进行别名解析<br>61 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {<br>62 processAliasRegistration(ele);<br>63 }<br>64 //元素节点既不是导入元素，也不是别名元素，即普通的<bean>元素，<br>65 //按照Spring的Bean规则解析元素<br>66 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {<br>67 processBeanDefinition(ele, delegate);<br>68 }<br>69 }<br>70 //解析<import>导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中<br>71 protected void importBeanDefinitionResource(Element ele) {<br>72 //获取给定的导入元素的location属性<br>73 String location = ele.getAttribute(RESOURCE_ATTRIBUTE);<br>74 //如果导入元素的location属性值为空，则没有导入任何资源，直接返回<br>75 if (!StringUtils.hasText(location)) {<br>76 getReaderContext().error(“Resource location must not be empty”, ele);<br>77 return;<br>78 }<br>79 //使用系统变量值解析location属性值<br>80 location = SystemPropertyUtils.resolvePlaceholders(location);<br>81 Set<resource>actualResources = new LinkedHashSet<resource>(4);<br>82 //标识给定的导入元素的location是否是绝对路径<br>83 boolean absoluteLocation = false;<br>84 try {<br>85 absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();<br>86 }<br>87 catch (URISyntaxException ex) {<br>88 //给定的导入元素的location不是绝对路径<br>89 }<br>90 //给定的导入元素的location是绝对路径<br>91 if (absoluteLocation) {<br>92 try {<br>93 //使用资源读入器加载给定路径的Bean定义资源<br>94 int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);<br>95 if (logger.isDebugEnabled()) {<br>96 logger.debug(“Imported “ + importCount + “ bean definitions from URL location [“ + location + “]”);<br>97 }<br>98 }<br>99 catch (BeanDefinitionStoreException ex) {<br>100 getReaderContext().error(<br>101 “Failed to import bean definitions from URL location [“ + location + “]”, ele, ex);<br>102 }<br>103 }<br>104 else {<br>105 //给定的导入元素的location是相对路径<br>106 try {<br>107 int importCount;<br>108 //将给定导入元素的location封装为相对路径资源<br>109 Resource relativeResource = getReaderContext().getResource().createRelative(location);<br>110 //封装的相对路径资源存在<br>111 if (relativeResource.exists()) {<br>112 //使用资源读入器加载Bean定义资源<br>113 importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);<br>114 actualResources.add(relativeResource);<br>115 }<br>116 //封装的相对路径资源不存在<br>117 else {<br>118 //获取Spring IoC容器资源读入器的基本路径<br>119 String baseLocation = getReaderContext().getResource().getURL().toString();<br>120 //根据Spring IoC容器资源读入器的基本路径加载给定导入<br>121 //路径的资源<br>122 importCount = getReaderContext().getReader().loadBeanDefinitions(<br>123 StringUtils.applyRelativePath(baseLocation, location), actualResources);<br>124 }<br>125 if (logger.isDebugEnabled()) {<br>126 logger.debug(“Imported “ + importCount + “ bean definitions from relative location [“ + location + “]”);<br>127 }<br>128 }<br>129 catch (IOException ex) {<br>130 getReaderContext().error(“Failed to resolve current resource location”, ele, ex);<br>131 }<br>132 catch (BeanDefinitionStoreException ex) {<br>133 getReaderContext().error(“Failed to import bean definitions from relative location [“ + location + “]”,<br>134 ele, ex);<br>135 }<br>136 }<br>137 Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);<br>138 //在解析完<import>元素之后，发送容器导入其他资源处理完成事件<br>139 getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));<br>140 }<br>141 //解析<alias>别名元素，为Bean向Spring IoC容器注册别名<br>142 protected void processAliasRegistration(Element ele) {<br>143 //获取<alias>别名元素中name的属性值<br>144 String name = ele.getAttribute(NAME_ATTRIBUTE);<br>145 //获取<alias>别名元素中alias的属性值<br>146 String alias = ele.getAttribute(ALIAS_ATTRIBUTE);<br>147 boolean valid = true;<br>148 //<alias>别名元素的name属性值为空<br>149 if (!StringUtils.hasText(name)) {<br>150 getReaderContext().error(“Name must not be empty”, ele);<br>151 valid = false;<br>152 }<br>153 //<alias>别名元素的alias属性值为空<br>154 if (!StringUtils.hasText(alias)) {<br>155 getReaderContext().error(“Alias must not be empty”, ele);<br>156 valid = false;<br>157 }<br>158 if (valid) {<br>159 try {<br>160 //向容器的资源读入器注册别名<br>161 getReaderContext().getRegistry().registerAlias(name, alias);<br>162 }<br>163 catch (Exception ex) {<br>164 getReaderContext().error(“Failed to register alias ‘“ + alias +<br>165 “‘ for bean with name ‘“ + name + “‘“, ele, ex);<br>166 }<br>167 //在解析完<alias>元素之后，发送容器别名处理完成事件<br>168 getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));<br>169 }<br>170 }<br>171 //解析Bean定义资源Document对象的普通元素<br>172 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {<br>173 // BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类<br>174 //对Document对象中<bean>元素的解析由BeanDefinitionParserDelegate实现 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<br>175 if (bdHolder != null) {<br>176 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>177 try {<br>178 //向Spring IoC容器注册解析得到的Bean定义，这是Bean定义向IoC容器注册的入口<br>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>179 }<br>180 catch (BeanDefinitionStoreException ex) {<br>181 getReaderContext().error(“Failed to register bean definition with name ‘“ +<br>182 bdHolder.getBeanName() + “‘“, ele, ex);<br>183 }<br>184 //在完成向Spring IoC容器注册解析得到的Bean定义之后，发送注册事件<br>185 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));<br>186 }<br>187 }</bean></alias></alias></alias></alias></alias></alias></import></resource></resource></import></bean></alias></import></p><p> <br> <br> <br> <br>通过上述Spring IoC容器对载入的Bean定义Document解析可以看出，我们使用Spring时，在Spring配置文件中可以使用<import>元素来导入IoC容器所需要的其他资源，Spring IoC容器在解析时会首先将指定导入的资源加载进容器中。使用<ailas>别名时，Spring IoC容器首先将别名元素所定义的别名注册到容器中。<br> <br>对于既不是<import>元素，又不是<alias>元素的元素，即Spring配置文件中普通的<bean>元素的解析由BeanDefinitionParserDelegate类的parseBeanDefinitionElement方法来实现。<br> <br> <br> <br>12、BeanDefinitionParserDelegate解析Bean定义资源文件中的<bean>元素：<br> <br> <br> <br>Bean定义资源文件中的<import>和<alias>元素解析在DefaultBeanDefinitionDocumentReader中已经完成，对Bean定义资源文件中使用最多的<bean>元素交由BeanDefinitionParserDelegate来解析，其解析实现的源码如下：  </bean></alias></import></bean></bean></alias></import></ailas></import></p><p>1 //解析<bean>元素的入口<br>2 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {<br>3 return parseBeanDefinitionElement(ele, null);<br>4 }<br>5 //解析Bean定义资源文件中的<bean>元素，这个方法中主要处理<bean>元素的id，name<br>6 //和别名属性<br>7 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {<br>8 //获取<bean>元素中的id属性值<br>9 String id = ele.getAttribute(ID_ATTRIBUTE);<br>10 //获取<bean>元素中的name属性值<br>11 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);<br>12 ////获取<bean>元素中的alias属性值<br>13 List<string>aliases = new ArrayList<string>();<br>14 //将<bean>元素中的所有name属性值存放到别名中<br>15 if (StringUtils.hasLength(nameAttr)) {<br>16 String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);<br>17 aliases.addAll(Arrays.asList(nameArr));<br>18 }<br>19 String beanName = id;<br>20 //如果<bean>元素中没有配置id属性时，将别名中的第一个值赋值给beanName<br>21 if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {<br>22 beanName = aliases.remove(0);<br>23 if (logger.isDebugEnabled()) {<br>24 logger.debug(“No XML ‘id’ specified - using ‘“ + beanName +<br>25 “‘ as bean name and “ + aliases + “ as aliases”);<br>26 }<br>27 }<br>28 //检查<bean>元素所配置的id或者name的唯一性，containingBean标识<bean><br>29 //元素中是否包含子<bean>元素<br>30 if (containingBean == null) {<br>31 //检查<bean>元素所配置的id、name或者别名是否重复<br>32 checkNameUniqueness(beanName, aliases, ele);<br>33 }<br>34 //详细对<bean>元素中配置的Bean定义进行解析的地方<br>35 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);<br>36 if (beanDefinition != null) {<br>37 if (!StringUtils.hasText(beanName)) {<br>38 try {<br>39 if (containingBean != null) {<br>40 //如果<bean>元素中没有配置id、别名或者name，且没有包含子//<bean>元素，为解析的Bean生成一个唯一beanName并注册<br>41 beanName = BeanDefinitionReaderUtils.generateBeanName(<br>42 beanDefinition, this.readerContext.getRegistry(), true);<br>43 }<br>44 else {<br>45 //如果<bean>元素中没有配置id、别名或者name，且包含了子//<bean>元素，为解析的Bean使用别名向IoC容器注册<br>46 beanName = this.readerContext.generateBeanName(beanDefinition);<br>47 //为解析的Bean使用别名注册时，为了向后兼容 //Spring1.2/2.0，给别名添加类名后缀<br>48 String beanClassName = beanDefinition.getBeanClassName();<br>49 if (beanClassName != null &amp;&amp;<br>50 beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;<br>51 !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {<br>52 aliases.add(beanClassName);<br>53 }<br>54 }<br>55 if (logger.isDebugEnabled()) {<br>56 logger.debug(“Neither XML ‘id’ nor ‘name’ specified - “ +<br>57 “using generated bean name [“ + beanName + “]”);<br>58 }<br>59 }<br>60 catch (Exception ex) {<br>61 error(ex.getMessage(), ele);<br>62 return null;<br>63 }<br>64 }<br>65 String[] aliasesArray = StringUtils.toStringArray(aliases);<br>66 return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);<br>67 }<br>68 //当解析出错时，返回null<br>69 return null;<br>70 }<br>71 //详细对<bean>元素中配置的Bean定义其他属性进行解析，由于上面的方法中已经对//Bean的id、name和别名等属性进行了处理，该方法中主要处理除这三个以外的其他属性数据<br>72 public AbstractBeanDefinition parseBeanDefinitionElement(<br>73 Element ele, String beanName, BeanDefinition containingBean) {<br>74 //记录解析的<bean><br>75 this.parseState.push(new BeanEntry(beanName));<br>76 //这里只读取<bean>元素中配置的class名字，然后载入到BeanDefinition中去<br>77 //只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成<br>78 String className = null;<br>79 if (ele.hasAttribute(CLASS_ATTRIBUTE)) {<br>80 className = ele.getAttribute(CLASS_ATTRIBUTE).trim();<br>81 }<br>82 try {<br>83 String parent = null;<br>84 //如果<bean>元素中配置了parent属性，则获取parent属性的值<br>85 if (ele.hasAttribute(PARENT_ATTRIBUTE)) {<br>86 parent = ele.getAttribute(PARENT_ATTRIBUTE);<br>87 }<br>88 //根据<bean>元素配置的class名称和parent属性值创建BeanDefinition<br>89 //为载入Bean定义信息做准备<br>90 AbstractBeanDefinition bd = createBeanDefinition(className, parent);<br>91 //对当前的<bean>元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等<br>92 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br>93 //为<bean>元素解析的Bean设置description信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));<br>94 //对<bean>元素的meta(元信息)属性解析<br>95 parseMetaElements(ele, bd);<br>96 //对<bean>元素的lookup-method属性解析<br>97 parseLookupOverrideSubElements(ele, bd.getMethodOverrides());<br>98 //对<bean>元素的replaced-method属性解析<br>99 parseReplacedMethodSubElements(ele, bd.getMethodOverrides());<br>100 //解析<bean>元素的构造方法设置<br>101 parseConstructorArgElements(ele, bd);<br>102 //解析<bean>元素的<property>设置<br>103 parsePropertyElements(ele, bd);<br>104 //解析<bean>元素的qualifier属性<br>105 parseQualifierElements(ele, bd);<br>106 //为当前解析的Bean设置所需的资源和依赖对象<br>107 bd.setResource(this.readerContext.getResource());<br>108 bd.setSource(extractSource(ele));<br>109 return bd;<br>110 }<br>111 catch (ClassNotFoundException ex) {<br>112 error(“Bean class [“ + className + “] not found”, ele, ex);<br>113 }<br>114 catch (NoClassDefFoundError err) {<br>115 error(“Class that bean class [“ + className + “] depends on not found”, ele, err);<br>116 }<br>117 catch (Throwable ex) {<br>118 error(“Unexpected failure during bean definition parsing”, ele, ex);<br>119 }<br>120 finally {<br>121 this.parseState.pop();<br>122 }<br>123 //解析<bean>元素出错时，返回null<br>124 return null;<br>125 }</bean></bean></property></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></string></string></bean></bean></bean></bean></bean></bean></p><p> <br> <br> <br> <br> <br>只要使用过Spring，对Spring配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在Spring配置文件中<bean>元素的中配置的属性就是通过该方法解析和设置到Bean中去的。<br> <br>注意：在解析<bean>元素过程中没有创建和实例化Bean对象，只是创建了Bean对象的定义类BeanDefinition，将<bean>元素中的配置信息设置到BeanDefinition中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的Bean对象。<br> <br>上面方法中一些对一些配置如元信息(meta)、qualifier等的解析，我们在Spring中配置时使用的也不多，我们在使用Spring的<bean>元素时，配置最多的是<property>属性，因此我们下面继续分析源码，了解Bean的属性在解析时是如何设置的。<br> <br> <br> <br>13、BeanDefinitionParserDelegate解析<property>元素：<br> <br> <br> <br>BeanDefinitionParserDelegate在解析<bean>调用parsePropertyElements方法解析<bean>元素中的<property>属性子元素，解析源码如下：  </property></bean></bean></property></property></bean></bean></bean></bean></p><p>1 //解析<bean>元素中的<property>子元素<br>2 public void parsePropertyElements(Element beanEle, BeanDefinition bd) {<br>3 //获取<bean>元素中所有的子元素<br>4 NodeList nl = beanEle.getChildNodes();<br>5 for (int i = 0; i &lt; nl.getLength(); i++) {<br>6 Node node = nl.item(i);<br>7 //如果子元素是<property>子元素，则调用解析<property>子元素方法解析<br>8 if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {<br>9 parsePropertyElement((Element) node, bd);<br>10 }<br>11 }<br>12 }<br>13 //解析<property>元素<br>14 public void parsePropertyElement(Element ele, BeanDefinition bd) {<br>15 //获取<property>元素的名字<br>16 String propertyName = ele.getAttribute(NAME_ATTRIBUTE);<br>17 if (!StringUtils.hasLength(propertyName)) {<br>18 error(“Tag ‘property’ must have a ‘name’ attribute”, ele);<br>19 return;<br>20 }<br>21 this.parseState.push(new PropertyEntry(propertyName));<br>22 try {<br>23 //如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。<br>24 //即如果在同一个Bean中配置同名的property，则只有第一个起作用<br>25 if (bd.getPropertyValues().contains(propertyName)) {<br>26 error(“Multiple ‘property’ definitions for property ‘“ + propertyName + “‘“, ele);<br>27 return;<br>28 }<br>29 //解析获取property的值<br>30 Object val = parsePropertyValue(ele, bd, propertyName);<br>31 //根据property的名字和值创建property实例<br>32 PropertyValue pv = new PropertyValue(propertyName, val);<br>33 //解析<property>元素中的属性<br>34 parseMetaElements(ele, pv);<br>35 pv.setSource(extractSource(ele));<br>36 bd.getPropertyValues().addPropertyValue(pv);<br>37 }<br>38 finally {<br>39 this.parseState.pop();<br>40 }<br>41 }<br>42 //解析获取property值<br>43 public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) {<br>44 String elementName = (propertyName != null) ?<br>45 “<property>element for property ‘“ + propertyName + “‘“ :<br>46 “<constructor-arg>element”;<br>47 //获取<property>的所有子元素，只能是其中一种类型:ref,value,list等<br>48 NodeList nl = ele.getChildNodes();<br>49 Element subElement = null;<br>50 for (int i = 0; i &lt; nl.getLength(); i++) {<br>51 Node node = nl.item(i);<br>52 //子元素不是description和meta属性<br>53 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;<br>54 !nodeNameEquals(node, META_ELEMENT)) {<br>55 if (subElement != null) {<br>56 error(elementName + “ must not contain more than one sub-element”, ele);<br>57 }<br>58 else {//当前<property>元素包含有子元素<br>59 subElement = (Element) node;<br>60 }<br>61 }<br>62 }<br>63 //判断property的属性值是ref还是value，不允许既是ref又是value<br>64 boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);<br>65 boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);<br>66 if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||<br>67 ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) {<br>68 error(elementName +<br>69 “ is only allowed to contain either ‘ref’ attribute OR ‘value’ attribute OR sub-element”, ele);<br>70 }<br>71 //如果属性是ref，创建一个ref的数据对象RuntimeBeanReference，这个对象<br>72 //封装了ref信息<br>73 if (hasRefAttribute) {<br>74 String refName = ele.getAttribute(REF_ATTRIBUTE);<br>75 if (!StringUtils.hasText(refName)) {<br>76 error(elementName + “ contains empty ‘ref’ attribute”, ele);<br>77 }<br>78 //一个指向运行时所依赖对象的引用<br>79 RuntimeBeanReference ref = new RuntimeBeanReference(refName);<br>80 //设置这个ref的数据对象是被当前的property对象所引用<br>81 ref.setSource(extractSource(ele));<br>82 return ref;<br>83 }<br>84 //如果属性是value，创建一个value的数据对象TypedStringValue，这个对象<br>85 //封装了value信息<br>86 else if (hasValueAttribute) {<br>87 //一个持有String类型值的对象<br>88 TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));<br>89 //设置这个value数据对象是被当前的property对象所引用<br>90 valueHolder.setSource(extractSource(ele));<br>91 return valueHolder;<br>92 }<br>93 //如果当前<property>元素还有子元素<br>94 else if (subElement != null) {<br>95 //解析<property>的子元素<br>96 return parsePropertySubElement(subElement, bd);<br>97 }<br>98 else {<br>99 //propery属性中既不是ref，也不是value属性，解析出错返回null error(elementName + “ must specify a ref or value”, ele);<br>100 return null;<br>101 }<br>}</property></property></property></property></constructor-arg></property></property></property></property></property></property></bean></property></bean></p><p> <br> <br> <br> <br> <br>通过对上述源码的分析，我们可以了解在Spring配置文件中，<bean>元素中<property>元素的相关配置是如何处理的：<br> <br>a. ref被封装为指向依赖对象一个引用。<br> <br>b.value配置都会封装成一个字符串类型的对象。<br> <br>c.ref和value都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来。<br> <br>在方法的最后对于<property>元素的子元素通过parsePropertySubElement 方法解析，我们继续分析该方法的源码，了解其解析过程。<br> <br> <br> <br>14、解析<property>元素的子元素：<br> <br> <br> <br>在BeanDefinitionParserDelegate类中的parsePropertySubElement方法对<property>中的子元素解析，源码如下：  </property></property></property></property></bean></p><p>1 //解析<property>元素中ref,value或者集合等子元素<br>2 public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) {<br>3 //如果<property>没有使用Spring默认的命名空间，则使用用户自定义的规则解析//内嵌元素<br>4 if (!isDefaultNamespace(ele)) {<br>5 return parseNestedCustomElement(ele, bd);<br>6 }<br>7 //如果子元素是bean，则使用解析<bean>元素的方法解析<br>8 else if (nodeNameEquals(ele, BEAN_ELEMENT)) {<br>9 BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);<br>10 if (nestedBd != null) {<br>11 nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);<br>12 }<br>13 return nestedBd;<br>14 }<br>15 //如果子元素是ref，ref中只能有以下3个属性：bean、local、parent<br>16 else if (nodeNameEquals(ele, REF_ELEMENT)) {<br>17 //获取<property>元素中的bean属性值，引用其他解析的Bean的名称<br>18 //可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则<br>19 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);<br>20 boolean toParent = false;<br>21 if (!StringUtils.hasLength(refName)) {<br>22 //获取<property>元素中的local属性值，引用同一个Xml文件中配置<br>23 //的Bean的id，local和ref不同，local只能引用同一个配置文件中的Bean<br>24 refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);<br>25 if (!StringUtils.hasLength(refName)) {<br>26 //获取<property>元素中parent属性值，引用父级容器中的Bean<br>27 refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);<br>28 toParent = true;<br>29 if (!StringUtils.hasLength(refName)) {<br>30 error(“‘bean’, ‘local’ or ‘parent’ is required for<ref>element”, ele);<br>31 return null;<br>32 }<br>33 }<br>34 }<br>35 //没有配置ref的目标属性值<br>36 if (!StringUtils.hasText(refName)) {<br>37 error(“<ref>element contains empty target attribute”, ele);<br>38 return null;<br>39 }<br>40 //创建ref类型数据，指向被引用的对象<br>41 RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);<br>42 //设置引用类型值是被当前子元素所引用<br>43 ref.setSource(extractSource(ele));<br>44 return ref;<br>45 }<br>46 //如果子元素是<idref>，使用解析ref元素的方法解析<br>47 else if (nodeNameEquals(ele, IDREF_ELEMENT)) {<br>48 return parseIdRefElement(ele);<br>49 }<br>50 //如果子元素是<value>，使用解析value元素的方法解析<br>51 else if (nodeNameEquals(ele, VALUE_ELEMENT)) {<br>52 return parseValueElement(ele, defaultValueType);<br>53 }<br>54 //如果子元素是null，为<property>设置一个封装null值的字符串数据<br>55 else if (nodeNameEquals(ele, NULL_ELEMENT)) {<br>56 TypedStringValue nullHolder = new TypedStringValue(null);<br>57 nullHolder.setSource(extractSource(ele));<br>58 return nullHolder;<br>59 }<br>60 //如果子元素是<array>，使用解析array集合子元素的方法解析<br>61 else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {<br>62 return parseArrayElement(ele, bd);<br>63 }<br>64 //如果子元素是<list>，使用解析list集合子元素的方法解析<br>65 else if (nodeNameEquals(ele, LIST_ELEMENT)) {<br>66 return parseListElement(ele, bd);<br>67 }<br>68 //如果子元素是<set>，使用解析set集合子元素的方法解析<br>69 else if (nodeNameEquals(ele, SET_ELEMENT)) {<br>70 return parseSetElement(ele, bd);<br>71 }<br>72 //如果子元素是<map>，使用解析map集合子元素的方法解析<br>73 else if (nodeNameEquals(ele, MAP_ELEMENT)) {<br>74 return parseMapElement(ele, bd);<br>75 }<br>76 //如果子元素是<props>，使用解析props集合子元素的方法解析<br>77 else if (nodeNameEquals(ele, PROPS_ELEMENT)) {<br>78 return parsePropsElement(ele);<br>79 }<br>80 //既不是ref，又不是value，也不是集合，则子元素配置错误，返回null<br>81 else {<br>82 error(“Unknown property sub-element: [“ + ele.getNodeName() + “]”, ele);<br>83 return null;<br>84 }<br>}</props></map></set></list></array></property></value></idref></ref></ref></property></property></property></bean></property></property></p><p> <br> <br>通过上述源码分析，我们明白了在Spring配置文件中，对<property>元素中配置的Array、List、Set、Map、Prop等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如ManagedList、ManagedArray、ManagedSet等，这些Managed类是Spring对象BeanDefiniton的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对<list>集合元素的解析方法进行源码分析，了解其实现过程。<br> <br>15、解析<list>子元素：<br> <br>在BeanDefinitionParserDelegate类中的parseListElement方法就是具体实现解析<property>元素中的<list>集合子元素，源码如下：  </list></property></list></list></property></p><p>1 //解析<list>集合子元素<br>2 public List parseListElement(Element collectionEle, BeanDefinition bd) {<br>3 //获取<list>元素中的value-type属性，即获取集合元素的数据类型<br>4 String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);<br>5 //获取<list>集合元素中的所有子节点<br>6 NodeList nl = collectionEle.getChildNodes();<br>7 //Spring中将List封装为ManagedList<br>8 ManagedList<object>target = new ManagedList<object>(nl.getLength());<br>9 target.setSource(extractSource(collectionEle));<br>10 //设置集合目标数据类型<br>11 target.setElementTypeName(defaultElementType);<br>12 target.setMergeEnabled(parseMergeAttribute(collectionEle));<br>13 //具体的<list>元素解析<br>14 parseCollectionElements(nl, target, bd, defaultElementType);<br>15 return target;<br>16 }<br>17 //具体解析<list>集合元素，<array>、<list>和<set>都使用该方法解析<br>18 protected void parseCollectionElements(<br>19 NodeList elementNodes, Collection<object>target, BeanDefinition bd, String defaultElementType) {<br>20 //遍历集合所有节点<br>21 for (int i = 0; i &lt; elementNodes.getLength(); i++) {<br>22 Node node = elementNodes.item(i);<br>23 //节点不是description节点<br>24 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {<br>25 //将解析的元素加入集合中，递归调用下一个子元素<br>26 target.add(parsePropertySubElement((Element) node, bd, defaultElementType));<br>27 }<br>28 }<br>}</object></set></list></array></list></list></object></object></list></list></list></p><p> <br> <br> <br> <br> <br> <br>经过对Spring Bean定义资源文件转换的Document对象中的元素层层解析，Spring IoC现在已经将XML形式定义的Bean定义资源文件转换为Spring IoC所识别的数据结构——BeanDefinition，它是Bean定义资源文件中配置的POJO对象在Spring IoC容器中的映射，我们可以通过AbstractBeanDefinition为入口，荣IoC容器进行索引、查询和操作。<br>通过Spring IoC容器对Bean定义资源的解析后，IoC容器大致完成了管理Bean对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在IoC容器中BeanDefinition存储的只是一些静态信息，接下来需要向容器注册Bean定义信息才能全部完成IoC容器的初始化过程<br> <br>16、解析过后的BeanDefinition在IoC容器中的注册：<br> <br>让我们继续跟踪程序的执行顺序，接下来会到我们第3步中分析DefaultBeanDefinitionDocumentReader对Bean定义转换的Document对象解析的流程中，在其parseDefaultElement方法中完成对Document对象的解析后得到封装BeanDefinition的BeanDefinitionHold对象，然后调用BeanDefinitionReaderUtils的registerBeanDefinition方法向IoC容器注册解析的Bean，BeanDefinitionReaderUtils的注册的源码如下：  </p><p>//将解析的BeanDefinitionHold注册到容器中<br>public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)<br>throws BeanDefinitionStoreException {<br>//获取解析的BeanDefinition的名称<br>String beanName = definitionHolder.getBeanName();<br>//向IoC容器注册BeanDefinition<br>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<br>//如果解析的BeanDefinition有别名，向容器为其注册别名<br>String[] aliases = definitionHolder.getAliases();<br>if (aliases != null) {<br>for (String aliase : aliases) {<br>registry.registerAlias(beanName, aliase);<br>}<br>}<br>}</p><p> <br>当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是DefaultListableBeanFactory。<br> <br>17、DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition：<br> <br>DefaultListableBeanFactory中使用一个HashMap的集合对象存放IoC容器中注册解析的BeanDefinition，向IoC容器注册的主要源码如下：</p><p>1 //存储注册的俄BeanDefinition<br>2 private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();<br>3 //向IoC容器注册解析的BeanDefiniton<br>4 public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)<br>5 throws BeanDefinitionStoreException {<br>6 Assert.hasText(beanName, “Bean name must not be empty”);<br>7 Assert.notNull(beanDefinition, “BeanDefinition must not be null”);<br>8 //校验解析的BeanDefiniton<br>9 if (beanDefinition instanceof AbstractBeanDefinition) {<br>10 try {<br>11 ((AbstractBeanDefinition) beanDefinition).validate();<br>12 }<br>13 catch (BeanDefinitionValidationException ex) {<br>14 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,<br>15 “Validation of bean definition failed”, ex);<br>16 }<br>17 }<br>18 //注册的过程中需要线程同步，以保证数据的一致性<br>19 synchronized (this.beanDefinitionMap) {<br>20 Object oldBeanDefinition = this.beanDefinitionMap.get(beanName);<br>21 //检查是否有同名的BeanDefinition已经在IoC容器中注册，如果已经注册，<br>22 //并且不允许覆盖已注册的Bean，则抛出注册失败异常<br>23 if (oldBeanDefinition != null) {<br>24 if (!this.allowBeanDefinitionOverriding) {<br>25 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,<br>26 “Cannot register bean definition [“ + beanDefinition + “] for bean ‘“ + beanName +<br>27 “‘: There is already [“ + oldBeanDefinition + “] bound.”);<br>28 }<br>29 else {//如果允许覆盖，则同名的Bean，后注册的覆盖先注册的<br>30 if (this.logger.isInfoEnabled()) {<br>31 this.logger.info(“Overriding bean definition for bean ‘“ + beanName +<br>32 “‘: replacing [“ + oldBeanDefinition + “] with [“ + beanDefinition + “]”);<br>33 }<br>34 }<br>35 }<br>36 //IoC容器中没有已经注册同名的Bean，按正常注册流程注册<br>37 else {<br>38 this.beanDefinitionNames.add(beanName);<br>39 this.frozenBeanDefinitionNames = null;<br>40 }<br>41 this.beanDefinitionMap.put(beanName, beanDefinition);<br>42 //重置所有已经注册过的BeanDefinition的缓存<br>43 resetBeanDefinition(beanName);<br>44 }<br>}</p><p> <br>至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现  在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些的注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。<br> <br>总结：<br>     现在通过上面的代码，总结一下IOC容器初始化的基本步骤：<br>u 初始化的入口在容器实现中的 refresh()调用来完成<br>u 对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition,其中的大致过程如下：通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置。如果是 XmlBeanFactory作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition  这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的， 容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.<br>u 然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。 Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在ServletContext 中的框架实现。具体可以参见以后的文章 <br>在使用 Spring IOC 容器的时候我们还需要区别两个概念:<br>       Beanfactory 和 Factory bean，其中 BeanFactory 指的是 IOC 容器的编程抽象，比如 ApplicationContext， XmlBeanFactory 等，这些都是 IOC 容器的具体表现，需要使用什么样的容器由客户决定,但 Spring 为我们提供了丰富的选择。 FactoryBean 只是一个可以在 IOC而容器中被管理的一个 bean,是对各种处理过程和资源使用的抽象,Factory bean 在需要时产生另一个对象，而不返回 FactoryBean本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean 都实现特殊的org.springframework.beans.factory.FactoryBean 接口，当使用容器中 factory bean 的时候，该容器不会返回 factory bean 本身,而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 Factory bean 的实现，其中包括:对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等，这些我们都可以看成是具体的工厂,看成是SPRING 为我们建立好的工厂。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了<br>     <br> <br>四、IOC容器的依赖注入<br>1、依赖注入发生的时间<br>当Spring IoC容器完成了Bean定义资源的定位、载入和解析注册以后，IoC容器中已经管理类Bean定义的相关数据，但是此时IoC容器还没有对所管理的Bean进行依赖注入，依赖注入在以下两种情况发生：<br>(1).用户第一次通过getBean方法向IoC容索要Bean时，IoC容器触发依赖注入。<br>(2).当用户在Bean定义资源中为<bean>元素配置了lazy-init属性，即让容器在解析注册Bean定义时进行预实例化，触发依赖注入。<br>BeanFactory接口定义了Spring IoC容器的基本功能规范，是Spring IoC容器所应遵守的最底层和最基本的编程规范。BeanFactory接口中定义了几个getBean方法，就是用户向IoC容器索取管理的Bean的方法，我们通过分析其子类的具体实现，理解Spring IoC容器在用户索取Bean时如何完成依赖注入。</bean></p><p> <br>在BeanFactory中我们看到getBean（String…）函数，它的具体实现在AbstractBeanFactory中<br> <br>2、AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean：<br> <br>AbstractBeanFactory的getBean相关方法的源码如下：  </p><p>1 //获取IoC容器中指定名称的Bean<br>2 public Object getBean(String name) throws BeansException {<br>3 //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>4 return doGetBean(name, null, null, false);<br>5 }<br>6 //获取IoC容器中指定名称和类型的Bean<br>7 public<t>T getBean(String name, Class<t>requiredType) throws BeansException {<br>8 //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>9 return doGetBean(name, requiredType, null, false);<br>10 }<br>11 //获取IoC容器中指定名称和参数的Bean<br>12 public Object getBean(String name, Object… args) throws BeansException {<br>13 //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>14 return doGetBean(name, null, args, false);<br>15 }<br>16 //获取IoC容器中指定名称、类型和参数的Bean<br>17 public<t>T getBean(String name, Class<t>requiredType, Object… args) throws BeansException {<br>18 //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>19 return doGetBean(name, requiredType, args, false);<br>20 }<br>21 //真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方<br>22 @SuppressWarnings(“unchecked”)<br>23 protected<t>T doGetBean(<br>24 final String name, final Class<t>requiredType, final Object[] args, boolean typeCheckOnly)<br>25 throws BeansException {<br>26 //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖<br>27 //如果指定的是别名，将别名转换为规范的Bean名称<br>28 final String beanName = transformedBeanName(name);<br>29 Object bean;<br>30 //先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整<br>31 //个IoC容器中只创建一次，不需要重复创建<br>32 Object sharedInstance = getSingleton(beanName);<br>33 //IoC容器创建单态模式Bean实例对象<br>34 if (sharedInstance != null &amp;&amp; args == null) {<br>35 if (logger.isDebugEnabled()) {<br>36 //如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回<br>37 //已经创建的Bean<br>38 if (isSingletonCurrentlyInCreation(beanName)) {<br>39 logger.debug(“Returning eagerly cached instance of singleton bean ‘“ + beanName +<br>40 “‘ that is not fully initialized yet - a consequence of a circular reference”);<br>41 }<br>42 else {<br>43 logger.debug(“Returning cached instance of singleton bean ‘“ + beanName + “‘“);<br>44 }<br>45 }<br>46 //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理<br>47 //注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是<br>48 //创建创建对象的工厂Bean，两者之间有区别<br>49 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);<br>50 }<br>51 else {//缓存没有正在创建的单态模式Bean<br>52 //缓存中已经有已经创建的原型模式Bean，但是由于循环引用的问题导致实<br>53 //例化对象失败<br>54 if (isPrototypeCurrentlyInCreation(beanName)) {<br>55 throw new BeanCurrentlyInCreationException(beanName);<br>56 }<br>57 //对IoC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否<br>58 //能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器<br>59 //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找<br>60 BeanFactory parentBeanFactory = getParentBeanFactory();<br>61 //当前容器的父级容器存在，且当前容器中不存在指定名称的Bean<br>62 if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {<br>63 //解析指定Bean名称的原始名称<br>64 String nameToLookup = originalBeanName(name);<br>65 if (args != null) {<br>66 //委派父级容器根据指定名称和显式的参数查找<br>67 return (T) parentBeanFactory.getBean(nameToLookup, args);<br>68 }<br>69 else {<br>70 //委派父级容器根据指定名称和类型查找<br>71 return parentBeanFactory.getBean(nameToLookup, requiredType);<br>72 }<br>73 }<br>74 //创建的Bean是否需要进行类型验证，一般不需要<br>75 if (!typeCheckOnly) {<br>76 //向容器标记指定的Bean已经被创建<br>77 markBeanAsCreated(beanName);<br>78 }<br>79 //根据指定Bean名称获取其父级的Bean定义，主要解决Bean继承时子类<br>80 //合并父类公共属性问题<br>81 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);<br>82 checkMergedBeanDefinition(mbd, beanName, args);<br>83 //获取当前Bean所有依赖Bean的名称<br>84 String[] dependsOn = mbd.getDependsOn();<br>85 //如果当前Bean有依赖Bean<br>86 if (dependsOn != null) {<br>87 for (String dependsOnBean : dependsOn) {<br>88 //递归调用getBean方法，获取当前Bean的依赖Bean<br>89 getBean(dependsOnBean);<br>90 //把被依赖Bean注册给当前依赖的Bean<br>91 registerDependentBean(dependsOnBean, beanName);<br>92 }<br>93 }<br>94 //创建单态模式Bean的实例对象<br>95 if (mbd.isSingleton()) {<br>96 //这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象<br>97 sharedInstance = getSingleton(beanName, new ObjectFactory() {<br>98 public Object getObject() throws BeansException {<br>99 try {<br>100 //创建一个指定Bean实例对象，如果有父级继承，则合并子//类和父类的定义<br>101 return createBean(beanName, mbd, args);<br>102 }<br>103 catch (BeansException ex) {<br>104 //显式地从容器单态模式Bean缓存中清除实例对象<br>105 destroySingleton(beanName);<br>106 throw ex;<br>107 }<br>108 }<br>109 });<br>110 //获取给定Bean的实例对象<br>111 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>112 }<br>113 //IoC容器创建原型模式Bean实例对象<br>114 else if (mbd.isPrototype()) {<br>115 //原型模式(Prototype)是每次都会创建一个新的对象<br>116 Object prototypeInstance = null;<br>117 try {<br>118 //回调beforePrototypeCreation方法，默认的功能是注册当前创//建的原型对象<br>119 beforePrototypeCreation(beanName);<br>120 //创建指定Bean对象实例<br>121 prototypeInstance = createBean(beanName, mbd, args);<br>122 }<br>123 finally {<br>124 //回调afterPrototypeCreation方法，默认的功能告诉IoC容器指//定Bean的原型对象不再创建了<br>125 afterPrototypeCreation(beanName);<br>126 }<br>127 //获取给定Bean的实例对象<br>128 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>129 }<br>130 //要创建的Bean既不是单态模式，也不是原型模式，则根据Bean定义资源中<br>131 //配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中<br>132 //比较常用，如：request、session、application等生命周期<br>133 else {<br>134 String scopeName = mbd.getScope();<br>135 final Scope scope = this.scopes.get(scopeName);<br>136 //Bean定义资源中没有配置生命周期范围，则Bean定义不合法<br>137 if (scope == null) {<br>138 throw new IllegalStateException(“No Scope registered for scope ‘“ + scopeName + “‘“);<br>139 }<br>140 try {<br>141 //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例<br>142 Object scopedInstance = scope.get(beanName, new ObjectFactory() {<br>143 public Object getObject() throws BeansException {<br>144 beforePrototypeCreation(beanName);<br>145 try {<br>146 return createBean(beanName, mbd, args);<br>147 }<br>148 finally {<br>149 afterPrototypeCreation(beanName);<br>150 }<br>151 }<br>152 });<br>153 //获取给定Bean的实例对象<br>154 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>155 }<br>156 catch (IllegalStateException ex) {<br>157 throw new BeanCreationException(beanName,<br>158 “Scope ‘“ + scopeName + “‘ is not active for the current thread; “ +<br>159 “consider defining a scoped proxy for this bean if you intend to refer to it from a singleton”,<br>160 ex);<br>161 }<br>162 }<br>163 }<br>164 //对创建的Bean实例对象进行类型检查<br>165 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) {<br>166 throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());<br>167 }<br>168 return (T) bean;<br>169 }</t></t></t></t></t></t></p><p> <br> <br> <br> <br> <br> <br>通过上面对向IoC容器获取Bean方法的分析，我们可以看到在Spring中，如果Bean定义的单态模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean定义还可以扩展为指定其生命周期范围。<br>上面的源码只是定义了根据Bean定义的模式，采取的不同创建Bean实例对象的策略，具体的Bean实例对象的创建过程由实现了ObejctFactory接口的匿名内部类的createBean方法完成，ObejctFactory使用委派模式，具体的Bean实例创建过程交由其实现类AbstractAutowireCapableBeanFactory完成，我们继续分析AbstractAutowireCapableBeanFactory的createBean方法的源码，理解其创建Bean实例的具体实现过程。<br> <br>3、AbstractAutowireCapableBeanFactory创建Bean实例对象：<br>AbstractAutowireCapableBeanFactory类实现了ObejctFactory接口，创建容器指定的Bean实例对象，同时还对创建的Bean实例对象进行初始化处理。其创建Bean实例对象的方法源码如下：  </p><p>1 //创建Bean实例对象<br>2 protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)<br>3 throws BeanCreationException {<br>4 if (logger.isDebugEnabled()) {<br>5 logger.debug(“Creating instance of bean ‘“ + beanName + “‘“);<br>6 }<br>7 //判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载<br>8 resolveBeanClass(mbd, beanName);<br>9 //校验和准备Bean中的方法覆盖<br>10 try {<br>11 mbd.prepareMethodOverrides();<br>12 }<br>13 catch (BeanDefinitionValidationException ex) {<br>14 throw new BeanDefinitionStoreException(mbd.getResourceDescription(),<br>15 beanName, “Validation of method overrides failed”, ex);<br>16 }<br>17 try {<br>18 //如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建//Bean的代理对象<br>19 Object bean = resolveBeforeInstantiation(beanName, mbd);<br>20 if (bean != null) {<br>21 return bean;<br>22 }<br>23 }<br>24 catch (Throwable ex) {<br>25 throw new BeanCreationException(mbd.getResourceDescription(), beanName,<br>26 “BeanPostProcessor before instantiation of bean failed”, ex);<br>27 }<br>28 //创建Bean的入口<br>29 Object beanInstance = doCreateBean(beanName, mbd, args);<br>30 if (logger.isDebugEnabled()) {<br>31 logger.debug(“Finished creating instance of bean ‘“ + beanName + “‘“);<br>32 }<br>33 return beanInstance;<br>34 }<br>35 //真正创建Bean的方法<br>36 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {<br>37 //封装被创建的Bean对象<br>38 BeanWrapper instanceWrapper = null;<br>39 if (mbd.isSingleton()){//单态模式的Bean，先从容器中缓存中获取同名Bean<br>40 instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);<br>41 }<br>42 if (instanceWrapper == null) {<br>43 //创建实例对象<br>44 instanceWrapper = createBeanInstance(beanName, mbd, args);<br>45 }<br>46 final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);<br>47 //获取实例化对象的类型<br>48 Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);<br>49 //调用PostProcessor后置处理器<br>50 synchronized (mbd.postProcessingLock) {<br>51 if (!mbd.postProcessed) {<br>52 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>53 mbd.postProcessed = true;<br>54 }<br>55 }<br>56 // Eagerly cache singletons to be able to resolve circular references<br>57 //向容器中缓存单态模式的Bean对象，以防循环引用<br>58 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;<br>59 isSingletonCurrentlyInCreation(beanName));<br>60 if (earlySingletonExposure) {<br>61 if (logger.isDebugEnabled()) {<br>62 logger.debug(“Eagerly caching bean ‘“ + beanName +<br>63 “‘ to allow for resolving potential circular references”);<br>64 }<br>65 //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用<br>66 addSingletonFactory(beanName, new ObjectFactory() {<br>67 public Object getObject() throws BeansException {<br>68 return getEarlyBeanReference(beanName, mbd, bean);<br>69 }<br>70 });<br>71 }<br>72 //Bean对象的初始化，依赖注入在此触发<br>73 //这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean<br>74 Object exposedObject = bean;<br>75 try {<br>76 //将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象<br>77 populateBean(beanName, mbd, instanceWrapper);<br>78 if (exposedObject != null) {<br>79 //初始化Bean对象<br>80 exposedObject = initializeBean(beanName, exposedObject, mbd);<br>81 }<br>82 }<br>83 catch (Throwable ex) {<br>84 if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {<br>85 throw (BeanCreationException) ex;<br>86 }<br>87 else {<br>88 throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Initialization of bean failed”, ex);<br>89 }<br>90 }<br>91 if (earlySingletonExposure) {<br>92 //获取指定名称的已注册的单态模式Bean对象<br>93 Object earlySingletonReference = getSingleton(beanName, false);<br>94 if (earlySingletonReference != null) {<br>95 //根据名称获取的以注册的Bean和正在实例化的Bean是同一个<br>96 if (exposedObject == bean) {<br>97 //当前实例化的Bean初始化完成<br>98 exposedObject = earlySingletonReference;<br>99 }<br>100 //当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象<br>101 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {<br>102 String[] dependentBeans = getDependentBeans(beanName);<br>103 Set<string>actualDependentBeans = new LinkedHashSet<string>(dependentBeans.length);<br>104 //获取当前Bean所依赖的其他Bean<br>105 for (String dependentBean : dependentBeans) {<br>106 //对依赖Bean进行类型检查<br>107 if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {<br>108 actualDependentBeans.add(dependentBean);<br>109 }<br>110 }<br>111 if (!actualDependentBeans.isEmpty()) {<br>112 throw new BeanCurrentlyInCreationException(beanName,<br>113 “Bean with name ‘“ + beanName + “‘ has been injected into other beans [“ +<br>114 StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>115 “] in its raw version as part of a circular reference, but has eventually been “ +<br>116 “wrapped. This means that said other beans do not use the final version of the “ +<br>117 “bean. This is often the result of over-eager type matching - consider using “ +<br>118 “‘getBeanNamesOfType’ with the ‘allowEagerInit’ flag turned off, for example.”);<br>119 }<br>120 }<br>121 }<br>122 }<br>123 //注册完成依赖注入的Bean<br>124 try {<br>125 registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>126 }<br>127 catch (BeanDefinitionValidationException ex) {<br>128 throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Invalid destruction signature”, ex);<br>129 }<br>130 return exposedObject;<br>}</string></string></p><p> <br> <br>通过对方法源码的分析，我们看到具体的依赖注入实现在以下两个方法中：<br>(1).createBeanInstance：生成Bean所包含的java对象实例。<br>(2).populateBean ：对Bean属性的依赖注入进行处理。<br> <br>下面继续分析这两个方法的代码实现。<br>4、createBeanInstance方法创建Bean的java实例对象：<br>在createBeanInstance方法中，根据指定的初始化策略，使用静态工厂、工厂方法或者容器的自动装配特性生成java实例对象，创建对象的源码如下：  </p><p>1 //创建Bean的实例对象<br>2 protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {<br>3 //检查确认Bean是可实例化的<br>4 Class beanClass = resolveBeanClass(mbd, beanName);<br>5 //使用工厂方法对Bean进行实例化<br>6 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {<br>7 throw new BeanCreationException(mbd.getResourceDescription(), beanName,<br>8 “Bean class isn’t public, and non-public access not allowed: “ + beanClass.getName());<br>9 }<br>10 if (mbd.getFactoryMethodName() != null) {<br>11 //调用工厂方法实例化<br>12 return instantiateUsingFactoryMethod(beanName, mbd, args);<br>13 }<br>14 //使用容器的自动装配方法进行实例化<br>15 boolean resolved = false;<br>16 boolean autowireNecessary = false;<br>17 if (args == null) {<br>18 synchronized (mbd.constructorArgumentLock) {<br>19 if (mbd.resolvedConstructorOrFactoryMethod != null) {<br>20 resolved = true;<br>21 autowireNecessary = mbd.constructorArgumentsResolved;<br>22 }<br>23 }<br>24 }<br>25 if (resolved) {<br>26 if (autowireNecessary) {<br>27 //配置了自动装配属性，使用容器的自动装配实例化<br>28 //容器的自动装配是根据参数类型匹配Bean的构造方法<br>29 return autowireConstructor(beanName, mbd, null, null);<br>30 }<br>31 else {<br>32 //使用默认的无参构造方法实例化<br>33 return instantiateBean(beanName, mbd);<br>34 }<br>35 }<br>36 //使用Bean的构造方法进行实例化<br>37 Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<br>38 if (ctors != null ||<br>39 mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||<br>40 mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {<br>41 //使用容器的自动装配特性，调用匹配的构造方法实例化<br>42 return autowireConstructor(beanName, mbd, ctors, args);<br>43 }<br>44 //使用默认的无参构造方法实例化<br>45 return instantiateBean(beanName, mbd);<br>46 }<br>47 //使用默认的无参构造方法实例化Bean对象<br>48 protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {<br>49 try {<br>50 Object beanInstance;<br>51 final BeanFactory parent = this;<br>52 //获取系统的安全管理接口，JDK标准的安全管理API<br>53 if (System.getSecurityManager() != null) {<br>54 //这里是一个匿名内置类，根据实例化策略创建实例对象<br>55 beanInstance = AccessController.doPrivileged(new PrivilegedAction<object>() {<br>56 public Object run() {<br>57 return getInstantiationStrategy().instantiate(mbd, beanName, parent);<br>58 }<br>59 }, getAccessControlContext());<br>60 }<br>61 else {<br>62 //将实例化的对象封装起来<br>63 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);<br>64 }<br>65 BeanWrapper bw = new BeanWrapperImpl(beanInstance);<br>66 initBeanWrapper(bw);<br>67 return bw;<br>68 }<br>69 catch (Throwable ex) {<br>70 throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Instantiation of bean failed”, ex);<br>71 }<br>72 }</object></p><p> <br> <br>经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的Bean的实例化相当比较清楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用的默认无参构造方法就需要使用相应的初始化策略(JDK的反射机制或者CGLIB)来进行初始化了，在方法getInstantiationStrategy().instantiate中就具体实现类使用初始策略实例化对象。<br> <br>5、SimpleInstantiationStrategy类使用默认的无参构造方法创建Bean实例化对象：<br>在使用默认的无参构造方法创建Bean的实例化对象时，方法getInstantiationStrategy().instantiate调用了SimpleInstantiationStrategy类中的实例化Bean的方法，其源码如下：  </p><p>1 //使用初始化策略实例化Bean对象<br>2 public Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner) {<br>3 //如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法<br>4 if (beanDefinition.getMethodOverrides().isEmpty()) {<br>5 Constructor<?> constructorToUse;  
6            synchronized (beanDefinition.constructorArgumentLock) {  
7                //获取对象的构造方法或工厂方法  
8                constructorToUse = (Constructor<?>) beanDefinition.resolvedConstructorOrFactoryMethod;<br>9 //如果没有构造方法且没有工厂方法<br>10 if (constructorToUse == null) {<br>11 //使用JDK的反射机制，判断要实例化的Bean是否是接口<br>12 final Class clazz = beanDefinition.getBeanClass();<br>13 if (clazz.isInterface()) {<br>14 throw new BeanInstantiationException(clazz, “Specified class is an interface”);<br>15 }<br>16 try {<br>17 if (System.getSecurityManager() != null) {<br>18 //这里是一个匿名内置类，使用反射机制获取Bean的构造方法<br>19 constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<constructor>() {<br>20 public Constructor run() throws Exception {<br>21 return clazz.getDeclaredConstructor((Class[]) null);<br>22 }<br>23 });<br>24 }<br>25 else {<br>26 constructorToUse = clazz.getDeclaredConstructor((Class[]) null);<br>27 }<br>28 beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;<br>29 }<br>30 catch (Exception ex) {<br>31 throw new BeanInstantiationException(clazz, “No default constructor found”, ex);<br>32 }<br>33 }<br>34 }<br>35 //使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化<br>36 return BeanUtils.instantiateClass(constructorToUse);<br>37 }<br>38 else {<br>39 //使用CGLIB来实例化对象<br>40 return instantiateWithMethodInjection(beanDefinition, beanName, owner);<br>41 }<br>}</constructor></p><p> <br> <br>通过上面的代码分析，我们看到了如果Bean有方法被覆盖了，则使用JDK的反射机制进行实例化，否则，使用CGLIB进行实例化。<br>instantiateWithMethodInjection方法调用SimpleInstantiationStrategy的子类CglibSubclassingInstantiationStrategy使用CGLIB来进行初始化，其源码如下：  </p><p>1 //使用CGLIB进行Bean对象实例化<br>2 public Object instantiate(Constructor ctor, Object[] args) {<br>3 //CGLIB中的类<br>4 Enhancer enhancer = new Enhancer();<br>5 //将Bean本身作为其基类<br>6 enhancer.setSuperclass(this.beanDefinition.getBeanClass());<br>7 enhancer.setCallbackFilter(new CallbackFilterImpl());<br>8 enhancer.setCallbacks(new Callback[] {<br>9 NoOp.INSTANCE,<br>10 new LookupOverrideMethodInterceptor(),<br>11 new ReplaceOverrideMethodInterceptor()<br>12 });<br>13 //使用CGLIB的create方法生成实例对象<br>14 return (ctor == null) ?<br>15 enhancer.create() :<br>16 enhancer.create(ctor.getParameterTypes(), args);<br>17 }</p><p> <br> <br>CGLIB是一个常用的字节码生成器的类库，它提供了一系列API实现java字节码的生成和转换功能。我们在学习JDK的动态代理时都知道，JDK的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用CGLIB。<br> <br>6、populateBean方法对Bean属性的依赖注入：<br>在第3步的分析中我们已经了解到Bean的依赖注入分为以下两个过程：<br>(1).createBeanInstance：生成Bean所包含的java对象实例。<br>(2).populateBean ：对Bean属性的依赖注入进行处理。<br>第4、5步中我们已经分析了容器初始化生成Bean所包含的Java实例对象的过程，现在我们继续分析生成对象后，Spring IoC容器是如何将Bean的属性依赖关系注入Bean实例对象中并设置好的，属性依赖注入的代码如下：  </p><p>1 //将Bean属性设置到生成的实例对象上<br>2 protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) {<br>3 //获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值<br>4 PropertyValues pvs = mbd.getPropertyValues();<br>5 //实例对象为null<br>6 if (bw == null) {<br>7 //属性值不为空<br>8 if (!pvs.isEmpty()) {<br>9 throw new BeanCreationException(<br>10 mbd.getResourceDescription(), beanName, “Cannot apply property values to null instance”);<br>11 }<br>12 else {<br>13 //实例对象为null，属性值也为空，不需要设置属性值，直接返回<br>14 return;<br>15 }<br>16 }<br>17 //在设置属性之前调用Bean的PostProcessor后置处理器<br>18 boolean continueWithPropertyPopulation = true;<br>19 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {<br>20 for (BeanPostProcessor bp : getBeanPostProcessors()) {<br>21 if (bp instanceof InstantiationAwareBeanPostProcessor) {<br>22 InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<br>23 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {<br>24 continueWithPropertyPopulation = false;<br>25 break;<br>26 }<br>27 }<br>28 }<br>29 }<br>30 if (!continueWithPropertyPopulation) {<br>31 return;<br>32 }<br>33 //依赖注入开始，首先处理autowire自动装配的注入<br>34 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||<br>35 mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {<br>36 MutablePropertyValues newPvs = new MutablePropertyValues(pvs);<br>37 //对autowire自动装配的处理，根据Bean名称自动装配注入<br>38 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {<br>39 autowireByName(beanName, mbd, bw, newPvs);<br>40 }<br>41 //根据Bean类型自动装配注入<br>42 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {<br>43 autowireByType(beanName, mbd, bw, newPvs);<br>44 }<br>45 pvs = newPvs;<br>46 }<br>47 //检查容器是否持有用于处理单态模式Bean关闭时的后置处理器<br>48 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();<br>49 //Bean实例对象没有依赖，即没有继承基类<br>50 boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);<br>51 if (hasInstAwareBpps || needsDepCheck) {<br>52 //从实例对象中提取属性描述符<br>53 PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw);<br>54 if (hasInstAwareBpps) {<br>55 for (BeanPostProcessor bp : getBeanPostProcessors()) {<br>56 if (bp instanceof InstantiationAwareBeanPostProcessor) {<br>57 InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<br>58 //使用BeanPostProcessor处理器处理属性值<br>59 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>60 if (pvs == null) {<br>61 return;<br>62 }<br>63 }<br>64 }<br>65 }<br>66 if (needsDepCheck) {<br>67 //为要设置的属性进行依赖检查<br>68 checkDependencies(beanName, mbd, filteredPds, pvs);<br>69 }<br>70 }<br>71 //对属性进行注入<br>72 applyPropertyValues(beanName, mbd, bw, pvs);<br>73 }<br>74 //解析并注入依赖属性的过程<br>75 protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {<br>76 if (pvs == null || pvs.isEmpty()) {<br>77 return;<br>78 }<br>79 //封装属性值<br>80 MutablePropertyValues mpvs = null;<br>81 List<propertyvalue>original;<br>82 if (System.getSecurityManager()!= null) {<br>83 if (bw instanceof BeanWrapperImpl) {<br>84 //设置安全上下文，JDK安全机制<br>85 ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());<br>86 }<br>87 }<br>88 if (pvs instanceof MutablePropertyValues) {<br>89 mpvs = (MutablePropertyValues) pvs;<br>90 //属性值已经转换<br>91 if (mpvs.isConverted()) {<br>92 try {<br>93 //为实例化对象设置属性值<br>94 bw.setPropertyValues(mpvs);<br>95 return;<br>96 }<br>97 catch (BeansException ex) {<br>98 throw new BeanCreationException(<br>99 mbd.getResourceDescription(), beanName, “Error setting property values”, ex);<br>100 }<br>101 }<br>102 //获取属性值对象的原始类型值<br>103 original = mpvs.getPropertyValueList();<br>104 }<br>105 else {<br>106 original = Arrays.asList(pvs.getPropertyValues());<br>107 }<br>108 //获取用户自定义的类型转换<br>109 TypeConverter converter = getCustomTypeConverter();<br>110 if (converter == null) {<br>111 converter = bw;<br>112 }<br>113 //创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象<br>114 //的实际值<br>115 BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);<br>116 //为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中<br>117 List<propertyvalue>deepCopy = new ArrayList<propertyvalue>(original.size());<br>118 boolean resolveNecessary = false;<br>119 for (PropertyValue pv : original) {<br>120 //属性值不需要转换<br>121 if (pv.isConverted()) {<br>122 deepCopy.add(pv);<br>123 }<br>124 //属性值需要转换<br>125 else {<br>126 String propertyName = pv.getName();<br>127 //原始的属性值，即转换之前的属性值<br>128 Object originalValue = pv.getValue();<br>129 //转换属性值，例如将引用转换为IoC容器中实例化对象引用<br>130 Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);<br>131 //转换之后的属性值<br>132 Object convertedValue = resolvedValue;<br>133 //属性值是否可以转换<br>134 boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;<br>135 !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);<br>136 if (convertible) {<br>137 //使用用户自定义的类型转换器转换属性值<br>138 convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);<br>139 }<br>140 //存储转换后的属性值，避免每次属性注入时的转换工作<br>141 if (resolvedValue == originalValue) {<br>142 if (convertible) {<br>143 //设置属性转换之后的值<br>144 pv.setConvertedValue(convertedValue);<br>145 }<br>146 deepCopy.add(pv);<br>147 }<br>148 //属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是<br>149 //动态生成的字符串，且属性的原始值不是集合或者数组类型<br>150 else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;<br>151 !((TypedStringValue) originalValue).isDynamic() &amp;&amp;<br>152 !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {<br>153 pv.setConvertedValue(convertedValue);<br>154 deepCopy.add(pv);<br>155 }<br>156 else {<br>157 resolveNecessary = true;<br>158 //重新封装属性的值<br>159 deepCopy.add(new PropertyValue(pv, convertedValue));<br>160 }<br>161 }<br>162 }<br>163 if (mpvs != null &amp;&amp; !resolveNecessary) {<br>164 //标记属性值已经转换过<br>165 mpvs.setConverted();<br>166 }<br>167 //进行属性依赖注入<br>168 try {<br>169 bw.setPropertyValues(new MutablePropertyValues(deepCopy));<br>170 }<br>171 catch (BeansException ex) {<br>172 throw new BeanCreationException(<br>173 mbd.getResourceDescription(), beanName, “Error setting property values”, ex);<br>174 }<br>}</propertyvalue></propertyvalue></propertyvalue></p><p> <br>分析上述代码，我们可以看出，对属性的注入过程分以下两种情况：<br>(1).属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入。<br>(2).属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。<br>对属性值的解析是在BeanDefinitionValueResolver类中的resolveValueIfNecessary方法中进行的，对属性值的依赖注入是通过bw.setPropertyValues方法实现的，在分析属性值的依赖注入之前，我们先分析一下对属性值的解析过程。<br> <br>7、BeanDefinitionValueResolver解析属性值：<br> <br>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个Bean实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由resolveValueIfNecessary方法实现，其源码如下：  </p><p>1 //解析属性值，对注入类型进行转换<br>2 public Object resolveValueIfNecessary(Object argName, Object value) {<br>3 //对引用类型的属性进行解析<br>4 if (value instanceof RuntimeBeanReference) {<br>5 RuntimeBeanReference ref = (RuntimeBeanReference) value;<br>6 //调用引用类型属性的解析方法<br>7 return resolveReference(argName, ref);<br>8 }<br>9 //对属性值是引用容器中另一个Bean名称的解析<br>10 else if (value instanceof RuntimeBeanNameReference) {<br>11 String refName = ((RuntimeBeanNameReference) value).getBeanName();<br>12 refName = String.valueOf(evaluate(refName));<br>13 //从容器中获取指定名称的Bean<br>14 if (!this.beanFactory.containsBean(refName)) {<br>15 throw new BeanDefinitionStoreException(<br>16 “Invalid bean name ‘“ + refName + “‘ in bean reference for “ + argName);<br>17 }<br>18 return refName;<br>19 }<br>20 //对Bean类型属性的解析，主要是Bean中的内部类<br>21 else if (value instanceof BeanDefinitionHolder) {<br>22 BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;<br>23 return resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());<br>24 }<br>25 else if (value instanceof BeanDefinition) {<br>26 BeanDefinition bd = (BeanDefinition) value;<br>27 return resolveInnerBean(argName, “(inner bean)”, bd);<br>28 }<br>29 //对集合数组类型的属性解析<br>30 else if (value instanceof ManagedArray) {<br>31 ManagedArray array = (ManagedArray) value;<br>32 //获取数组的类型<br>33 Class elementType = array.resolvedElementType;<br>34 if (elementType == null) {<br>35 //获取数组元素的类型<br>36 String elementTypeName = array.getElementTypeName();<br>37 if (StringUtils.hasText(elementTypeName)) {<br>38 try {<br>39 //使用反射机制创建指定类型的对象<br>40 elementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader());<br>41 array.resolvedElementType = elementType;<br>42 }<br>43 catch (Throwable ex) {<br>44 throw new BeanCreationException(<br>45 this.beanDefinition.getResourceDescription(), this.beanName,<br>46 “Error resolving array type for “ + argName, ex);<br>47 }<br>48 }<br>49 //没有获取到数组的类型，也没有获取到数组元素的类型，则直接设置数<br>50 //组的类型为Object<br>51 else {<br>52 elementType = Object.class;<br>53 }<br>54 }<br>55 //创建指定类型的数组<br>56 return resolveManagedArray(argName, (List<?>) value, elementType);  
57        }  
58        //解析list类型的属性值  
59        else if (value instanceof ManagedList) {  
60            return resolveManagedList(argName, (List<?>) value);<br>61 }<br>62 //解析set类型的属性值<br>63 else if (value instanceof ManagedSet) {<br>64 return resolveManagedSet(argName, (Set<?>) value);  
65        }  
66        //解析map类型的属性值  
67        else if (value instanceof ManagedMap) {  
68            return resolveManagedMap(argName, (Map<?, ?>) value);<br>69 }<br>70 //解析props类型的属性值，props其实就是key和value均为字符串的map<br>71 else if (value instanceof ManagedProperties) {<br>72 Properties original = (Properties) value;<br>73 //创建一个拷贝，用于作为解析后的返回值<br>74 Properties copy = new Properties();<br>75 for (Map.Entry propEntry : original.entrySet()) {<br>76 Object propKey = propEntry.getKey();<br>77 Object propValue = propEntry.getValue();<br>78 if (propKey instanceof TypedStringValue) {<br>79 propKey = evaluate((TypedStringValue) propKey);<br>80 }<br>81 if (propValue instanceof TypedStringValue) {<br>82 propValue = evaluate((TypedStringValue) propValue);<br>83 }<br>84 copy.put(propKey, propValue);<br>85 }<br>86 return copy;<br>87 }<br>88 //解析字符串类型的属性值<br>89 else if (value instanceof TypedStringValue) {<br>90 TypedStringValue typedStringValue = (TypedStringValue) value;<br>91 Object valueObject = evaluate(typedStringValue);<br>92 try {<br>93 //获取属性的目标类型<br>94 Class<?> resolvedTargetType = resolveTargetType(typedStringValue);  
95                if (resolvedTargetType != null) {  
96                    //对目标类型的属性进行解析，递归调用  
97                    return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);  
98                }  
99                //没有获取到属性的目标对象，则按Object类型返回  
100                else {  
101                    return valueObject;  
102                }  
103            }  
104            catch (Throwable ex) {  
105                throw new BeanCreationException(  
106                        this.beanDefinition.getResourceDescription(), this.beanName,  
107                        "Error converting typed String value for " + argName, ex);  
108            }  
109        }  
110        else {  
111            return evaluate(value);  
112        }  
113    }  
114    //解析引用类型的属性值  
115    private Object resolveReference(Object argName, RuntimeBeanReference ref) {  
116        try {  
117            //获取引用的Bean名称  
118            String refName = ref.getBeanName();  
119            refName = String.valueOf(evaluate(refName));  
120            //如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象  
121            if (ref.isToParent()) {  
122                if (this.beanFactory.getParentBeanFactory() == null) {  
123                    throw new BeanCreationException(  
124                            this.beanDefinition.getResourceDescription(), this.beanName,  
125                            "Can't resolve reference to bean '" + refName +  
126                            "' in parent factory: no parent factory available");  
127                }  
128                return this.beanFactory.getParentBeanFactory().getBean(refName);  
129            }  
130            //从当前的容器中获取指定的引用Bean对象，如果指定的Bean没有被实例化  
131            //则会递归触发引用Bean的初始化和依赖注入  
132            else {  
133                Object bean = this.beanFactory.getBean(refName);  
134                //将当前实例化对象的依赖引用对象  
135                this.beanFactory.registerDependentBean(refName, this.beanName);  
136                return bean;  
137            }  
138        }  
139        catch (BeansException ex) {  
140            throw new BeanCreationException(  
141                    this.beanDefinition.getResourceDescription(), this.beanName,  
142                    "Cannot resolve reference to bean '" + ref.getBeanName() + "' while setting " + argName, ex);  
143        }  
144    }   
145    //解析array类型的属性  
146    private Object resolveManagedArray(Object argName, List<?> ml, Class elementType) {<br>147 //创建一个指定类型的数组，用于存放和返回解析后的数组<br>148 Object resolved = Array.newInstance(elementType, ml.size());<br>149 for (int i = 0; i &lt; ml.size(); i++) {<br>150 //递归解析array的每一个元素，并将解析后的值设置到resolved数组中，索引为i<br>151 Array.set(resolved, i,<br>152 resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i)));<br>153 }<br>154 return resolved;<br>155 }<br>156 //解析list类型的属性<br>157 private List resolveManagedList(Object argName, List<?> ml) {  
158        List<Object> resolved = new ArrayList<Object>(ml.size());  
159        for (int i = 0; i < ml.size(); i++) {  
160            //递归解析list的每一个元素  
161            resolved.add(  
162                resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i)));  
163        }  
164        return resolved;  
165    }  
166    //解析set类型的属性  
167    private Set resolveManagedSet(Object argName, Set<?> ms) {<br>168 Set<object>resolved = new LinkedHashSet<object>(ms.size());<br>169 int i = 0;<br>170 //递归解析set的每一个元素<br>171 for (Object m : ms) {<br>172 resolved.add(resolveValueIfNecessary(new KeyedArgName(argName, i), m));<br>173 i++;<br>174 }<br>175 return resolved;<br>176 }<br>177 //解析map类型的属性<br>178 private Map resolveManagedMap(Object argName, Map<?, ?> mm) {<br>179 Map&lt;Object, Object&gt; resolved = new LinkedHashMap&lt;Object, Object&gt;(mm.size());<br>180 //递归解析map中每一个元素的key和value<br>181 for (Map.Entry entry : mm.entrySet()) {<br>182 Object resolvedKey = resolveValueIfNecessary(argName, entry.getKey());<br>183 Object resolvedValue = resolveValueIfNecessary(<br>184 new KeyedArgName(argName, entry.getKey()), entry.getValue());<br>185 resolved.put(resolvedKey, resolvedValue);<br>186 }<br>187 return resolved;<br>188 }</object></object></p><p> <br> <br> <br> <br> <br>通过上面的代码分析，我们明白了Spring是如何将引用类型，内部类以及集合类型等属性进行解析的，属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是Bean对象实例设置到它所依赖的Bean对象属性上去，在第7步中我们已经说过，依赖注入是通过bw.setPropertyValues方法实现的，该方法也使用了委托模式，在BeanWrapper接口中至少定义了方法声明，依赖注入的具体实现交由其实现类BeanWrapperImpl来完成，下面我们就分析依BeanWrapperImpl中赖注入相关的源码。<br> <br>8、BeanWrapperImpl对Bean属性的依赖注入：<br> <br>BeanWrapperImpl类主要是对容器中完成初始化的Bean实例对象进行属性的依赖注入，即把Bean对象设置到它所依赖的另一个Bean的属性中去，依赖注入的相关源码如下：  </p><p>1 //实现属性依赖注入功能<br>2 private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {<br>3 //PropertyTokenHolder主要保存属性的名称、路径，以及集合的size等信息<br>4 String propertyName = tokens.canonicalName;<br>5 String actualName = tokens.actualName;<br>6 //keys是用来保存集合类型属性的size<br>7 if (tokens.keys != null) {<br>8 //将属性信息拷贝<br>9 PropertyTokenHolder getterTokens = new PropertyTokenHolder();<br>10 getterTokens.canonicalName = tokens.canonicalName;<br>11 getterTokens.actualName = tokens.actualName;<br>12 getterTokens.keys = new String[tokens.keys.length - 1];<br>13 System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);<br>14 Object propValue;<br>15 try {<br>16 //获取属性值，该方法内部使用JDK的内省( Introspector)机制，调用属性//的getter(readerMethod)方法，获取属性的值<br>17 propValue = getPropertyValue(getterTokens);<br>18 }<br>19 catch (NotReadablePropertyException ex) {<br>20 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,<br>21 “Cannot access indexed value in property referenced “ +<br>22 “in indexed property path ‘“ + propertyName + “‘“, ex);<br>23 }<br>24 //获取集合类型属性的长度<br>25 String key = tokens.keys[tokens.keys.length - 1];<br>26 if (propValue == null) {<br>27 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,<br>28 “Cannot access indexed value in property referenced “ +<br>29 “in indexed property path ‘“ + propertyName + “‘: returned null”);<br>30 }<br>31 //注入array类型的属性值<br>32 else if (propValue.getClass().isArray()) {<br>33 //获取属性的描述符<br>34 PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);<br>35 //获取数组的类型<br>36 Class requiredType = propValue.getClass().getComponentType();<br>37 //获取数组的长度<br>38 int arrayIndex = Integer.parseInt(key);<br>39 Object oldValue = null;<br>40 try {<br>41 //获取数组以前初始化的值<br>42 if (isExtractOldValueForEditor()) {<br>43 oldValue = Array.get(propValue, arrayIndex);<br>44 }<br>45 //将属性的值赋值给数组中的元素<br>46 Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,<br>47 new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));<br>48 Array.set(propValue, arrayIndex, convertedValue);<br>49 }<br>50 catch (IndexOutOfBoundsException ex) {<br>51 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,<br>52 “Invalid array index in property path ‘“ + propertyName + “‘“, ex);<br>53 }<br>54 }<br>55 //注入list类型的属性值<br>56 else if (propValue instanceof List) {<br>57 PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);<br>58 //获取list集合的类型<br>59 Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(<br>60 pd.getReadMethod(), tokens.keys.length);<br>61 List list = (List) propValue;<br>62 //获取list集合的size<br>63 int index = Integer.parseInt(key);<br>64 Object oldValue = null;<br>65 if (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) {<br>66 oldValue = list.get(index);<br>67 }<br>68 //获取list解析后的属性值<br>69 Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,<br>70 new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));<br>71 if (index &lt; list.size()) {<br>72 //为list属性赋值<br>73 list.set(index, convertedValue);<br>74 }<br>75 //如果list的长度大于属性值的长度，则多余的元素赋值为null<br>76 else if (index &gt;= list.size()) {<br>77 for (int i = list.size(); i &lt; index; i++) {<br>78 try {<br>79 list.add(null);<br>80 }<br>81 catch (NullPointerException ex) {<br>82 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,<br>83 “Cannot set element with index “ + index + “ in List of size “ +<br>84 list.size() + “, accessed using property path ‘“ + propertyName +<br>85 “‘: List does not support filling up gaps with null elements”);<br>86 }<br>87 }<br>88 list.add(convertedValue);<br>89 }<br>90 }<br>91 //注入map类型的属性值<br>92 else if (propValue instanceof Map) {<br>93 PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);<br>94 //获取map集合key的类型<br>95 Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(<br>96 pd.getReadMethod(), tokens.keys.length);<br>97 //获取map集合value的类型<br>98 Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(<br>99 pd.getReadMethod(), tokens.keys.length);<br>100 Map map = (Map) propValue;<br>101 //解析map类型属性key值<br>102 Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType,<br>103 new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));<br>104 Object oldValue = null;<br>105 if (isExtractOldValueForEditor()) {<br>106 oldValue = map.get(convertedMapKey);<br>107 }<br>108 //解析map类型属性value值<br>109 Object convertedMapValue = convertIfNecessary(<br>110 propertyName, oldValue, pv.getValue(), mapValueType,<br>111 new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));<br>112 //将解析后的key和value值赋值给map集合属性<br>113 map.put(convertedMapKey, convertedMapValue);<br>114 }<br>115 else {<br>116 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,<br>117 “Property referenced in indexed property path ‘“ + propertyName +<br>118 “‘ is neither an array nor a List nor a Map; returned value was [“ + pv.getValue() + “]”);<br>119 }<br>120 }<br>121 //对非集合类型的属性注入<br>122 else {<br>123 PropertyDescriptor pd = pv.resolvedDescriptor;<br>124 if (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {<br>125 pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);<br>126 //无法获取到属性名或者属性没有提供setter(写方法)方法<br>127 if (pd == null || pd.getWriteMethod() == null) {<br>128 //如果属性值是可选的，即不是必须的，则忽略该属性值<br>129 if (pv.isOptional()) {<br>130 logger.debug(“Ignoring optional value for property ‘“ + actualName +<br>131 “‘ - property not found on bean class [“ + getRootClass().getName() + “]”);<br>132 return;<br>133 }<br>134 //如果属性值是必须的，则抛出无法给属性赋值，因为每天提供setter方法异常<br>135 else {<br>136 PropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());<br>137 throw new NotWritablePropertyException(<br>138 getRootClass(), this.nestedPath + propertyName,<br>139 matches.buildErrorMessage(), matches.getPossibleMatches());<br>140 }<br>141 }<br>142 pv.getOriginalPropertyValue().resolvedDescriptor = pd;<br>143 }<br>144 Object oldValue = null;<br>145 try {<br>146 Object originalValue = pv.getValue();<br>147 Object valueToApply = originalValue;<br>148 if (!Boolean.FALSE.equals(pv.conversionNecessary)) {<br>149 if (pv.isConverted()) {<br>150 valueToApply = pv.getConvertedValue();<br>151 }<br>152 else {<br>153 if (isExtractOldValueForEditor() &amp;&amp; pd.getReadMethod() != null) {<br>154 //获取属性的getter方法(读方法)，JDK内省机制<br>155 final Method readMethod = pd.getReadMethod();<br>156 //如果属性的getter方法不是public访问控制权限的，即访问控制权限比较严格，<br>157 //则使用JDK的反射机制强行访问非public的方法(暴力读取属性值)<br>158 if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &amp;&amp;<br>159 !readMethod.isAccessible()) {<br>160 if (System.getSecurityManager()!= null) {<br>161 //匿名内部类，根据权限修改属性的读取控制限制<br>162 AccessController.doPrivileged(new PrivilegedAction<object>() {<br>163 public Object run() {<br>164 readMethod.setAccessible(true);<br>165 return null;<br>166 }<br>167 });<br>168 }<br>169 else {<br>170 readMethod.setAccessible(true);<br>171 }<br>172 }<br>173 try {<br>174 //属性没有提供getter方法时，调用潜在的读取属性值//的方法，获取属性值<br>175 if (System.getSecurityManager() != null) {<br>176 oldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<object>() {<br>177 public Object run() throws Exception {<br>178 return readMethod.invoke(object);<br>179 }<br>180 }, acc);<br>181 }<br>182 else {<br>183 oldValue = readMethod.invoke(object);<br>184 }<br>185 }<br>186 catch (Exception ex) {<br>187 if (ex instanceof PrivilegedActionException) {<br>188 ex = ((PrivilegedActionException) ex).getException();<br>189 }<br>190 if (logger.isDebugEnabled()) {<br>191 logger.debug(“Could not read previous value of property ‘“ +<br>192 this.nestedPath + propertyName + “‘“, ex);<br>193 }<br>194 }<br>195 }<br>196 //设置属性的注入值<br>197 valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);<br>198 }<br>199 pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);<br>200 }<br>201 //根据JDK的内省机制，获取属性的setter(写方法)方法<br>202 final Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?<br>203 ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :<br>204 pd.getWriteMethod());<br>205 //如果属性的setter方法是非public，即访问控制权限比较严格，则使用JDK的反射机制，<br>206 //强行设置setter方法可访问(暴力为属性赋值)<br>207 if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) &amp;&amp; !writeMethod.isAccessible()) {<br>208 //如果使用了JDK的安全机制，则需要权限验证<br>209 if (System.getSecurityManager()!= null) {<br>210 AccessController.doPrivileged(new PrivilegedAction<object>() {<br>211 public Object run() {<br>212 writeMethod.setAccessible(true);<br>213 return null;<br>214 }<br>215 });<br>216 }<br>217 else {<br>218 writeMethod.setAccessible(true);<br>219 }<br>220 }<br>221 final Object value = valueToApply;<br>222 if (System.getSecurityManager() != null) {<br>223 try {<br>224 //将属性值设置到属性上去<br>225 AccessController.doPrivileged(new PrivilegedExceptionAction<object>() {<br>226 public Object run() throws Exception {<br>227 writeMethod.invoke(object, value);<br>228 return null;<br>229 }<br>230 }, acc);<br>231 }<br>232 catch (PrivilegedActionException ex) {<br>233 throw ex.getException();<br>234 }<br>235 }<br>236 else {<br>237 writeMethod.invoke(this.object, value);<br>238 }<br>239 }<br>240 catch (TypeMismatchException ex) {<br>241 throw ex;<br>242 }<br>243 catch (InvocationTargetException ex) {<br>244 PropertyChangeEvent propertyChangeEvent =<br>245 new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());<br>246 if (ex.getTargetException() instanceof ClassCastException) {<br>247 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());<br>248 }<br>249 else {<br>250 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());<br>251 }<br>252 }<br>253 catch (Exception ex) {<br>254 PropertyChangeEvent pce =<br>255 new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());<br>256 throw new MethodInvocationException(pce, ex);<br>257 }<br>258 }<br>}</object></object></object></object></p><p> <br> <br> <br>通过对上面注入依赖代码的分析，我们已经明白了Spring IoC容器是如何将属性的值注入到Bean实例对象中去的：<br>(1).对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。<br>(2).对于非集合类型的属性，大量使用了JDK的反射和内省机制，通过属性的getter方法(reader method)获取指定属性注入以前的值，同时调用属性的setter方法(writer method)为属性设置注入后的值。看到这里相信很多人都明白了Spring的setter注入原理。<br>至此Spring IoC容器对Bean定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在Spring IoC容器中管理了一系列靠依赖关系联系起来的Bean，程序不需要应用自己手动创建所需的对象，Spring IoC容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖，这就是Spring核心功能的控制反转和依赖注入的相关功能。<br>五、IoC容器的高级特性<br>1、介绍<br>      通过前面4篇文章对Spring IoC容器的源码分析，我们已经基本上了解了Spring IoC容器对Bean定义资源的定位、读入和解析过程，同时也清楚了当用户通过getBean方法向IoC容器获取被管理的Bean时，IoC容器对Bean进行的初始化和依赖注入过程，这些是Spring IoC容器的基本功能特性。Spring IoC容器还有一些高级特性，如使用lazy-init属性对Bean预初始化、FactoryBean产生或者修饰Bean对象的生成、IoC容器初始化Bean过程中使用BeanPostProcessor后置处理器对Bean声明周期事件管理和IoC容器的autowiring自动装配功能等。<br>2、Spring IoC容器的lazy-init属性实现预实例化：<br>      通过前面我们对IoC容器的实现和工作原理分析，我们知道IoC容器的初始化过程就是对Bean定义资源的定位、载入和注册，此时容器对Bean的依赖注入并没有发生，依赖注入主要是在应用程序第一次向容器索取Bean时，通过getBean方法的调用完成。<br>当Bean定义资源的<bean>元素中配置了lazy-init属性时，容器将会在初始化的时候对所配置的Bean进行预实例化，Bean的依赖注入在容器初始化的时候就已经完成。这样，当应用程序第一次向容器索取被管理的Bean时，就不用再初始化和对Bean进行依赖注入了，直接从容器中获取已经完成依赖注入的现成Bean，可以提高应用第一次向容器获取Bean的性能。<br>下面我们通过代码分析容器预实例化的实现过程：<br>(1).refresh()<br>先从IoC容器的初始会过程开始，通过前面文章分析，我们知道IoC容器读入已经定位的Bean定义资源是从refresh方法开始的，我们首先从AbstractApplicationContext类的refresh方法入手分析，源码如下：</bean></p><p>1 //容器初始化的过程，读入Bean定义资源，并解析注册<br>2 public void refresh() throws BeansException, IllegalStateException {<br>3 synchronized (this.startupShutdownMonitor) {<br>4 //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识<br>5 prepareRefresh();<br>6 //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从<br>7 //子类的refreshBeanFactory()方法启动<br>8 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>9 //为BeanFactory配置容器特性，例如类加载器、事件处理器等<br>10 prepareBeanFactory(beanFactory);<br>11 try {<br>12 //为容器的某些子类指定特殊的BeanPost事件处理器<br>13 postProcessBeanFactory(beanFactory);<br>14 //调用所有注册的BeanFactoryPostProcessor的Bean<br>15 invokeBeanFactoryPostProcessors(beanFactory);<br>16 //为BeanFactory注册BeanPost事件处理器.<br>17 //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件<br>18 registerBeanPostProcessors(beanFactory);<br>19 //初始化信息源，和国际化相关.<br>20 initMessageSource();<br>21 //初始化容器事件传播器.<br>22 initApplicationEventMulticaster();<br>23 //调用子类的某些特殊Bean初始化方法<br>24 onRefresh();<br>25 //为事件传播器注册事件监听器.<br>26 registerListeners();<br>27 //这里是对容器lazy-init属性进行处理的入口方法<br>28 finishBeanFactoryInitialization(beanFactory);<br>29 //初始化容器的生命周期事件处理器，并发布容器的生命周期事件<br>30 finishRefresh();<br>31 }<br>32 catch (BeansException ex) {<br>33 //销毁以创建的单态Bean<br>34 destroyBeans();<br>35 //取消refresh操作，重置容器的同步标识.<br>36 cancelRefresh(ex);<br>37 throw ex;<br>38 }<br>39 }<br>}</p><p> <br> <br> <br> <br> <br> <br> <br> <br>在refresh方法中ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory();启动了Bean定义资源的载入、注册过程，而finishBeanFactoryInitialization方法是对注册后的Bean定义中的预实例化(lazy-init=false，Spring默认就是预实例化，即为true)的Bean进行处理的地方。<br> <br>(2).finishBeanFactoryInitialization处理预实例化Bean：<br> <br>当Bean定义资源被载入IoC容器之后，容器将Bean定义资源解析为容器内部的数据结构BeanDefinition注册到容器中，AbstractApplicationContext类中的finishBeanFactoryInitialization方法对配置了预实例化属性的Bean进行预初始化过程，源码如下：</p><p>1 //对配置了lazy-init属性的Bean进行预实例化处理<br>2 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {<br>3 //这是Spring3以后新加的代码，为容器指定一个转换服务(ConversionService)<br>4 //在对某些Bean属性进行转换时使用<br>5 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;<br>6 beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {<br>7 beanFactory.setConversionService(<br>8 beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));<br>9 }<br>10 //为了类型匹配，停止使用临时的类加载器<br>11 beanFactory.setTempClassLoader(null);<br>12 //缓存容器中所有注册的BeanDefinition元数据，以防被修改<br>13 beanFactory.freezeConfiguration();<br>14 //对配置了lazy-init属性的单态模式Bean进行预实例化处理<br>15 beanFactory.preInstantiateSingletons();<br>}</p><p> <br>ConfigurableListableBeanFactory是一个接口，其preInstantiateSingletons方法由其子类DefaultListableBeanFactory提供。  <br>(3)、DefaultListableBeanFactory对配置lazy-init属性单态Bean的预实例化：  </p><p>1//对配置lazy-init属性单态Bean的预实例化<br>2public void preInstantiateSingletons() throws BeansException {<br>3 if (this.logger.isInfoEnabled()) {<br>4 this.logger.info(“Pre-instantiating singletons in “ + this);<br>5 }<br>6 //在对配置lazy-init属性单态Bean的预实例化过程中，必须多线程同步，以确保数据一致性<br>7 synchronized (this.beanDefinitionMap) {<br>8 for (String beanName : this.beanDefinitionNames) {<br>9 //获取指定名称的Bean定义<br>10 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);<br>11 //Bean不是抽象的，是单态模式的，且lazy-init属性配置为false<br>12 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {<br>13 //如果指定名称的bean是创建容器的Bean<br>14 if (isFactoryBean(beanName)) {<br>15 //FACTORY_BEAN_PREFIX=”&amp;”，当Bean名称前面加”&amp;”符号<br>16 //时，获取的是产生容器对象本身，而不是容器产生的Bean.<br>17 //调用getBean方法，触发容器对Bean实例化和依赖注入过程<br>18 final FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName);<br>19 //标识是否需要预实例化<br>20 boolean isEagerInit;<br>21 if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {<br>22 //一个匿名内部类<br>23 isEagerInit = AccessController.doPrivileged(new PrivilegedAction<boolean>() {<br>24 public Boolean run() {<br>25 return ((SmartFactoryBean) factory).isEagerInit();<br>26 }<br>27 }, getAccessControlContext());<br>28 }<br>29 else {<br>30 isEagerInit = factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean) factory).isEagerInit();<br>31 }<br>32 if (isEagerInit) {<br>33 //调用getBean方法，触发容器对Bean实例化和依赖注入过程<br>34 getBean(beanName);<br>35 }<br>36 }<br>37 else {<br>38 //调用getBean方法，触发容器对Bean实例化和依赖注入过程<br>39 getBean(beanName);<br>40 }<br>41 }<br>42 }<br>43 }<br>}</boolean></p><p> <br> <br>通过对lazy-init处理源码的分析，我们可以看出，如果设置了lazy-init属性，则容器在完成Bean定义的注册之后，会通过getBean方法，触发对指定Bean的初始化和依赖注入过程，这样当应用第一次向容器索取所需的Bean时，容器不再需要对Bean进行初始化和依赖注入，直接从已经完成实例化和依赖注入的Bean中取一个线程的Bean，这样就提高了第一次获取Bean的性能。<br>3、FactoryBean的实现：<br>       在Spring中，有两个很容易混淆的类：BeanFactory和FactoryBean。<br>BeanFactory：Bean工厂，是一个工厂(Factory)，我们Spring IoC容器的最顶层接口就是这个BeanFactory，它的作用是管理Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。<br>FactoryBean：工厂Bean，是一个Bean，作用是产生其他bean实例。通常情况下，这种bean没有什么特别的要求，仅需要提供一个工厂方法，该方法用来返回其他bean实例。通常情况下，bean无须自己实现工厂模式，Spring容器担任工厂角色；但少数情况下，容器中的bean本身就是工厂，其作用是产生其它bean实例。<br>当用户使用容器本身时，可以使用转义字符”&amp;”来得到FactoryBean本身，以区别通过FactoryBean产生的实例对象和FactoryBean对象本身。在BeanFactory中通过如下代码定义了该转义字符：<br>StringFACTORY_BEAN_PREFIX = “&amp;”;<br>如果myJndiObject是一个FactoryBean，则使用&amp;myJndiObject得到的是myJndiObject对象，而不是myJndiObject产生出来的对象。<br>(1).FactoryBean的源码如下：</p><p>//工厂Bean，用于产生其他对象<br>public interface FactoryBean<t>{<br>//获取容器管理的对象实例<br>T getObject() throws Exception;<br>//获取Bean工厂创建的对象的类型<br>Class&lt;?&gt; getObjectType();<br>//Bean工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例<br>//对象，每次请求都返回同一个实例对象<br>boolean isSingleton();<br>}</t></p><p> <br>(2). AbstractBeanFactory的getBean方法调用FactoryBean：<br>在前面我们分析Spring Ioc容器实例化Bean并进行依赖注入过程的源码时，提到在getBean方法触发容器实例化Bean的时候会调用AbstractBeanFactory的doGetBean方法来进行实例化的过程，源码如下：</p><p>1 //真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方<br>2 @SuppressWarnings(“unchecked”)<br>3 protected<t>T doGetBean(<br>4 final String name, final Class<t>requiredType, final Object[] args, boolean typeCheckOnly)<br>5 throws BeansException {<br>6 //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖<br>7 //如果指定的是别名，将别名转换为规范的Bean名称<br>8 final String beanName = transformedBeanName(name);<br>9 Object bean;<br>10 //先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整<br>11 //个IoC容器中只创建一次，不需要重复创建<br>12 Object sharedInstance = getSingleton(beanName);<br>13 //IoC容器创建单态模式Bean实例对象<br>14 if (sharedInstance != null &amp;&amp; args == null) {<br>15 if (logger.isDebugEnabled()) {<br>16 //如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回<br>17 //已经创建的Bean<br>18 if (isSingletonCurrentlyInCreation(beanName)) {<br>19 logger.debug(“Returning eagerly cached instance of singleton bean ‘“ + beanName +<br>20 “‘ that is not fully initialized yet - a consequence of a circular reference”);<br>21 }<br>22 else {<br>23 logger.debug(“Returning cached instance of singleton bean ‘“ + beanName + “‘“);<br>24 }<br>25 }<br>26 //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理<br>27 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);<br>28 }<br>29 ……<br>30 }<br>31 //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理<br>32 protected Object getObjectForBeanInstance(<br>33 Object beanInstance, String name, String beanName, RootBeanDefinition mbd) {<br>34 //容器已经得到了Bean实例对象，这个实例对象可能是一个普通的Bean，也可能是<br>35 //一个工厂Bean，如果是一个工厂Bean，则使用它创建一个Bean实例对象，如果<br>36 //调用本身就想获得一个容器的引用，则指定返回这个工厂Bean实例对象<br>37 //如果指定的名称是容器的解引用(dereference，即是对象本身而非内存地址)，<br>38 //且Bean实例也不是创建Bean实例对象的工厂Bean<br>39 if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) {<br>40 throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());<br>41 }<br>42 //如果Bean实例不是工厂Bean，或者指定名称是容器的解引用，调用者向获取对<br>43 //容器的引用，则直接返回当前的Bean实例<br>44 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {<br>45 return beanInstance;<br>46 }<br>47 //处理指定名称不是容器的解引用，或者根据名称获取的Bean实例对象是一个工厂Bean<br>48 //使用工厂Bean创建一个Bean的实例对象<br>49 Object object = null;<br>50 if (mbd == null) {<br>51 //从Bean工厂缓存中获取给定名称的Bean实例对象<br>52 object = getCachedObjectForFactoryBean(beanName);<br>53 }<br>54 //让Bean工厂生产给定名称的Bean对象实例<br>55 if (object == null) {<br>56 FactoryBean factory = (FactoryBean) beanInstance;<br>57 //如果从Bean工厂生产的Bean是单态模式的，则缓存<br>58 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {<br>59 //从容器中获取指定名称的Bean定义，如果继承基类，则合并基类相关属性<br>60 mbd = getMergedLocalBeanDefinition(beanName);<br>61 }<br>62 //如果从容器得到Bean定义信息，并且Bean定义信息不是虚构的，则让工厂<br>63 //Bean生产Bean实例对象<br>64 boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());<br>65 //调用FactoryBeanRegistrySupport类的getObjectFromFactoryBean<br>66 //方法，实现工厂Bean生产Bean对象实例的过程<br>67 object = getObjectFromFactoryBean(factory, beanName, !synthetic);<br>68 }<br>69 return object;<br>}</t></t></p><p> <br> <br> <br> <br>在上面获取给定Bean的实例对象的getObjectForBeanInstance方法中，会调用FactoryBeanRegistrySupport类的getObjectFromFactoryBean方法，该方法实现了Bean工厂生产Bean实例对象。<br> <br>Dereference(解引用)：一个在C/C++中应用比较多的术语，在C++中，”*”是解引用符号，而”&amp;”是引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。<br> <br>(3)、AbstractBeanFactory生产Bean实例对象：<br> <br>AbstractBeanFactory类中生产Bean实例对象的主要源码如下：</p><p>71 //Bean工厂生产Bean实例对象<br>72 protected Object getObjectFromFactoryBean(FactoryBean factory, String beanName, boolean shouldPostProcess) {<br>73 //Bean工厂是单态模式，并且Bean工厂缓存中存在指定名称的Bean实例对象<br>74 if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {<br>75 //多线程同步，以防止数据不一致<br>76 synchronized (getSingletonMutex()) {<br>77 //直接从Bean工厂缓存中获取指定名称的Bean实例对象<br>78 Object object = this.factoryBeanObjectCache.get(beanName);<br>79 //Bean工厂缓存中没有指定名称的实例对象，则生产该实例对象<br>80 if (object == null) {<br>81 //调用Bean工厂的getObject方法生产指定Bean的实例对象<br>82 object = doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);<br>83 //将生产的实例对象添加到Bean工厂缓存中<br>84 this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));<br>85 }<br>86 return (object != NULL_OBJECT ? object : null);<br>87 }<br>88 }<br>89 //调用Bean工厂的getObject方法生产指定Bean的实例对象<br>90 else {<br>91 return doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);<br>92 }<br>93 }<br>94 //调用Bean工厂的getObject方法生产指定Bean的实例对象<br>95 private Object doGetObjectFromFactoryBean(<br>96 final FactoryBean factory, final String beanName, final boolean shouldPostProcess)<br>97 throws BeanCreationException {<br>98 Object object;<br>99 try {<br>100 if (System.getSecurityManager() != null) {<br>101 AccessControlContext acc = getAccessControlContext();<br>102 try {<br>103 //实现PrivilegedExceptionAction接口的匿名内置类<br>104 //根据JVM检查权限，然后决定BeanFactory创建实例对象<br>105 object = AccessController.doPrivileged(new PrivilegedExceptionAction<object>() {<br>106 public Object run() throws Exception {<br>107 //调用BeanFactory接口实现类的创建对象方法<br>108 return factory.getObject();<br>109 }<br>110 }, acc);<br>111 }<br>112 catch (PrivilegedActionException pae) {<br>113 throw pae.getException();<br>114 }<br>115 }<br>116 else {<br>117 //调用BeanFactory接口实现类的创建对象方法<br>118 object = factory.getObject();<br>119 }<br>120 }<br>121 catch (FactoryBeanNotInitializedException ex) {<br>122 throw new BeanCurrentlyInCreationException(beanName, ex.toString());<br>123 }<br>124 catch (Throwable ex) {<br>125 throw new BeanCreationException(beanName, “FactoryBean threw exception on object creation”, ex);<br>126 }<br>127 //创建出来的实例对象为null，或者因为单态对象正在创建而返回null<br>128 if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {<br>129 throw new BeanCurrentlyInCreationException(<br>130 beanName, “FactoryBean which is currently in creation returned null from getObject”);<br>131 }<br>132 //为创建出来的Bean实例对象添加BeanPostProcessor后置处理器<br>133 if (object != null &amp;&amp; shouldPostProcess) {<br>134 try {<br>135 object = postProcessObjectFromFactoryBean(object, beanName);<br>136 }<br>137 catch (Throwable ex) {<br>138 throw new BeanCreationException(beanName, “Post-processing of the FactoryBean’s object failed”, ex);<br>139 }<br>140 }<br>141 return object;<br>}</object></p><p> <br>从上面的源码分析中，我们可以看出，BeanFactory接口调用其实现类的getObject方法来实现创建Bean实例对象的功能。<br>(4).工厂Bean的实现类getObject方法创建Bean实例对象：<br>FactoryBean的实现类有非常多，比如：Proxy、RMI、JNDI、ServletContextFactoryBean等等，FactoryBean接口为Spring容器提供了一个很好的封装机制，具体的getObject有不同的实现类根据不同的实现策略来具体提供，我们分析一个最简单的AnnotationTestFactoryBean的实现源码：</p><p>143 public class AnnotationTestBeanFactory implements FactoryBean<ijmxtestbean>{<br>144 private final FactoryCreatedAnnotationTestBean instance = new FactoryCreatedAnnotationTestBean();<br>145 public AnnotationTestBeanFactory() {<br>146 this.instance.setName(“FACTORY”);<br>147 }<br>148 //AnnotationTestBeanFactory产生Bean实例对象的实现<br>149 public IJmxTestBean getObject() throws Exception {<br>150 return this.instance;<br>151 }<br>152 public Class&lt;? extends IJmxTestBean&gt; getObjectType() {<br>153 return FactoryCreatedAnnotationTestBean.class;<br>154 }<br>155 public boolean isSingleton() {<br>156 return true;<br>157 }<br>}</ijmxtestbean></p><p>其他的Proxy，RMI，JNDI等等，都是根据相应的策略提供getObject的实现。这里不做一一分析，这已经不是Spring的核心功能，有需要的时候再去深入研究。<br>4.BeanPostProcessor后置处理器的实现：<br>BeanPostProcessor后置处理器是Spring IoC容器经常使用到的一个特性，这个Bean后置处理器是一个监听器，可以监听容器触发的Bean声明周期事件。后置处理器向容器注册以后，容器中管理的Bean就具备了接收IoC容器事件回调的能力。<br>BeanPostProcessor的使用非常简单，只需要提供一个实现接口BeanPostProcessor的实现类，然后在Bean的配置文件中设置即可。<br>(1).BeanPostProcessor的源码如下：</p><p>1 package org.springframework.beans.factory.config;<br>2 import org.springframework.beans.BeansException;<br>3 public interface BeanPostProcessor {<br>4 //为在Bean的初始化前提供回调入口<br>5 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;<br>6 //为在Bean的初始化之后提供回调入口<br>7 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;<br>}</p><p> <br>这两个回调的入口都是和容器管理的Bean的生命周期事件紧密相关，可以为用户提供在Spring IoC容器初始化Bean过程中自定义的处理操作。<br>(2).AbstractAutowireCapableBeanFactory类对容器生成的Bean添加后置处理器：<br>BeanPostProcessor后置处理器的调用发生在Spring IoC容器完成对Bean实例对象的创建和属性的依赖注入完成之后，在对Spring依赖注入的源码分析过程中我们知道，当应用程序第一次调用getBean方法(lazy-init预实例化除外)向Spring IoC容器索取指定Bean时触发Spring IoC容器创建Bean实例对象并进行依赖注入的过程，其中真正实现创建Bean对象并进行依赖注入的方法是AbstractAutowireCapableBeanFactory类的doCreateBean方法，主要源码如下：</p><p>1 //真正创建Bean的方法<br>2 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {<br>3 //创建Bean实例对象<br>4 ……<br>5 try {<br>6 //对Bean属性进行依赖注入<br>7 populateBean(beanName, mbd, instanceWrapper);<br>8 if (exposedObject != null) {<br>9 //在对Bean实例对象生成和依赖注入完成以后，开始对Bean实例对象<br>10 //进行初始化 ，为Bean实例对象应用BeanPostProcessor后置处理器<br>11 exposedObject = initializeBean(beanName, exposedObject, mbd);<br>12 }<br>13 }<br>14 catch (Throwable ex) {<br>15 if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {<br>16 throw (BeanCreationException) ex;<br>17 }<br>18 ……<br>19 //为应用返回所需要的实例对象<br>20 return exposedObject;<br>}</p><p> <br> <br>从上面的代码中我们知道，为Bean实例对象添加BeanPostProcessor后置处理器的入口的是initializeBean方法。<br> <br>(3).initializeBean方法为容器产生的Bean实例对象添加BeanPostProcessor后置处理器：<br> <br>同样在AbstractAutowireCapableBeanFactory类中，initializeBean方法实现为容器创建的Bean实例对象添加BeanPostProcessor后置处理器，源码如下：</p><p>1 //初始容器创建的Bean实例对象，为其添加BeanPostProcessor后置处理器<br>2 protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {<br>3 //JDK的安全机制验证权限<br>4 if (System.getSecurityManager() != null) {<br>5 //实现PrivilegedAction接口的匿名内部类<br>6 AccessController.doPrivileged(new PrivilegedAction<object>() {<br>7 public Object run() {<br>8 invokeAwareMethods(beanName, bean);<br>9 return null;<br>10 }<br>11 }, getAccessControlContext());<br>12 }<br>13 else {<br>14 //为Bean实例对象包装相关属性，如名称，类加载器，所属容器等信息<br>15 invokeAwareMethods(beanName, bean);<br>16 }<br>17 Object wrappedBean = bean;<br>18 //对BeanPostProcessor后置处理器的postProcessBeforeInitialization<br>19 //回调方法的调用，为Bean实例初始化前做一些处理<br>20 if (mbd == null || !mbd.isSynthetic()) {<br>21 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>22 }<br>23 //调用Bean实例对象初始化的方法，这个初始化方法是在Spring Bean定义配置<br>24 //文件中通过init-method属性指定的<br>25 try {<br>26 invokeInitMethods(beanName, wrappedBean, mbd);<br>27 }<br>28 catch (Throwable ex) {<br>29 throw new BeanCreationException(<br>30 (mbd != null ? mbd.getResourceDescription() : null),<br>31 beanName, “Invocation of init method failed”, ex);<br>32 }<br>33 //对BeanPostProcessor后置处理器的postProcessAfterInitialization<br>34 //回调方法的调用，为Bean实例初始化之后做一些处理<br>35 if (mbd == null || !mbd.isSynthetic()) {<br>36 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>37 }<br>38 return wrappedBean;<br>39 }<br>40 //调用BeanPostProcessor后置处理器实例对象初始化之前的处理方法<br>41 public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)<br>42 throws BeansException {<br>43 Object result = existingBean;<br>44 //遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器<br>45 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {<br>46 //调用Bean实例所有的后置处理中的初始化前处理方法，为Bean实例对象在<br>47 //初始化之前做一些自定义的处理操作<br>48 result = beanProcessor.postProcessBeforeInitialization(result, beanName);<br>49 if (result == null) {<br>50 return result;<br>51 }<br>52 }<br>53 return result;<br>54 }<br>55 //调用BeanPostProcessor后置处理器实例对象初始化之后的处理方法<br>56 public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)<br>57 throws BeansException {<br>58 Object result = existingBean;<br>59 //遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器<br>60 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {<br>61 //调用Bean实例所有的后置处理中的初始化后处理方法，为Bean实例对象在<br>62 //初始化之后做一些自定义的处理操作<br>63 result = beanProcessor.postProcessAfterInitialization(result, beanName);<br>64 if (result == null) {<br>65 return result;<br>66 }<br>67 }<br>68 return result;<br>}</object></p><p> <br> <br>BeanPostProcessor是一个接口，其初始化前的操作方法和初始化后的操作方法均委托其实现子类来实现，在Spring中，BeanPostProcessor的实现子类非常的多，分别完成不同的操作，如：AOP面向切面编程的注册通知适配器、Bean对象的数据校验、Bean继承属性/方法的合并等等，我们以最简单的AOP切面织入来简单了解其主要的功能。<br> <br>(4).AdvisorAdapterRegistrationManager在Bean对象初始化后注册通知适配器：<br> <br>AdvisorAdapterRegistrationManager是BeanPostProcessor的一个实现类，其主要的作用为容器中管理的Bean注册一个面向切面编程的通知适配器，以便在Spring容器为所管理的Bean进行面向切面编程时提供方便，其源码如下：</p><p>1 //为容器中管理的Bean注册一个面向切面编程的通知适配器<br>2 public class AdvisorAdapterRegistrationManager implements BeanPostProcessor {<br>3 //容器中负责管理切面通知适配器注册的对象<br>4 private AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();<br>5 public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry) {<br>6 this.advisorAdapterRegistry = advisorAdapterRegistry;<br>7 }<br>8 //BeanPostProcessor在Bean对象初始化前的操作<br>9 public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<br>10 //没有做任何操作，直接返回容器创建的Bean对象<br>11 return bean;<br>12 }<br>13 //BeanPostProcessor在Bean对象初始化后的操作<br>14 public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<br>15 if (bean instanceof AdvisorAdapter){<br>16 //如果容器创建的Bean实例对象是一个切面通知适配器，则向容器的注册<br>this.advisorAdapterRegistry.registerAdvisorAdapter((AdvisorAdapter) bean);<br>17 }<br>18 return bean;<br>19 }<br>}</p><p> <br> <br>其他的BeanPostProcessor接口实现类的也类似，都是对Bean对象使用到的一些特性进行处理，或者向IoC容器中注册，为创建的Bean实例对象做一些自定义的功能增加，这些操作是容器初始化Bean时自动触发的，不需要认为的干预。<br> <br>5.Spring IoC容器autowiring实现原理：<br> <br>Spring IoC容器提供了两种管理Bean依赖关系的方式：<br> <br>a.      显式管理：通过BeanDefinition的属性值和构造方法实现Bean依赖关系管理。<br> <br>b． autowiring：Spring IoC容器的依赖自动装配功能，不需要对Bean属性的依赖关系做显式的声明，只需要在配置好autowiring属性，IoC容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的Bean，从而自动地完成依赖注入。<br> <br>通过对autowiring自动装配特性的理解，我们知道容器对Bean的自动装配发生在容器对Bean依赖注入的过程中。在前面对Spring IoC容器的依赖注入过程源码分析中，我们已经知道了容器对Bean实例对象的属性注入的处理发生在AbstractAutoWireCapableBeanFactory类中的populateBean方法中，我们通过程序流程分析autowiring的实现原理：<br> <br>(1). AbstractAutoWireCapableBeanFactory对Bean实例进行属性依赖注入：<br> <br>应用第一次通过getBean方法(配置了lazy-init预实例化属性的除外)向IoC容器索取Bean时，容器创建Bean实例对象，并且对Bean实例对象进行属性依赖注入，AbstractAutoWireCapableBeanFactory的populateBean方法就是实现Bean属性依赖注入的功能，其主要源码如下：</p><p>1 protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) {<br>2 //获取Bean定义的属性值，并对属性值进行处理<br>3 PropertyValues pvs = mbd.getPropertyValues();<br>4 ……<br>5 //对依赖注入处理，首先处理autowiring自动装配的依赖注入<br>6 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||<br>7 mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {<br>8 MutablePropertyValues newPvs = new MutablePropertyValues(pvs);<br>9 //根据Bean名称进行autowiring自动装配处理<br>10 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {<br>11 autowireByName(beanName, mbd, bw, newPvs);<br>12 }<br>13 //根据Bean类型进行autowiring自动装配处理<br>14 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {<br>15 autowireByType(beanName, mbd, bw, newPvs);<br>16 }<br>17 }<br>18 //对非autowiring的属性进行依赖注入处理<br>19 ……<br>}</p><p> <br> <br>(2).Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入：</p><p>1 //根据名称对属性进行自动依赖注入<br>2 protected void autowireByName(<br>3 String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {<br>4 //对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符串，URL等//都是简单属性)进行处理<br>5 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);<br>6 for (String propertyName : propertyNames) {<br>7 //如果Spring IoC容器中包含指定名称的Bean<br>8 if (containsBean(propertyName)) {<br>9 //调用getBean方法向IoC容器索取指定名称的Bean实例，迭代触发属性的//初始化和依赖注入<br>10 Object bean = getBean(propertyName);<br>11 //为指定名称的属性赋予属性值<br>12 pvs.add(propertyName, bean);<br>13 //指定名称属性注册依赖Bean名称，进行属性依赖注入<br>14 registerDependentBean(propertyName, beanName);<br>15 if (logger.isDebugEnabled()) {<br>16 logger.debug(“Added autowiring by name from bean name ‘“ + beanName +<br>17 “‘ via property ‘“ + propertyName + “‘ to bean named ‘“ + propertyName + “‘“);<br>18 }<br>19 }<br>20 else {<br>21 if (logger.isTraceEnabled()) {<br>22 logger.trace(“Not autowiring property ‘“ + propertyName + “‘ of bean ‘“ + beanName +<br>23 “‘ by name: no matching bean found”);<br>24 }<br>25 }<br>26 }<br>27 }<br>28 //根据类型对属性进行自动依赖注入<br>29 protected void autowireByType(<br>30 String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {<br>31 //获取用户定义的类型转换器<br>32 TypeConverter converter = getCustomTypeConverter();<br>33 if (converter == null) {<br>34 converter = bw;<br>35 }<br>36 //存放解析的要注入的属性<br>37 Set<string>autowiredBeanNames = new LinkedHashSet<string>(4);<br>38 //对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符<br>39 //URL等都是简单属性)进行处理<br>40 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);<br>41 for (String propertyName : propertyNames) {<br>42 try {<br>43 //获取指定属性名称的属性描述器<br>44 PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);<br>45 //不对Object类型的属性进行autowiring自动依赖注入<br>46 if (!Object.class.equals(pd.getPropertyType())) {<br>47 //获取属性的setter方法<br>48 MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);<br>49 //检查指定类型是否可以被转换为目标对象的类型<br>50 boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());<br>51 //创建一个要被注入的依赖描述<br>52 DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);<br>53 //根据容器的Bean定义解析依赖关系，返回所有要被注入的Bean对象<br>54 Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);<br>55 if (autowiredArgument != null) {<br>56 //为属性赋值所引用的对象<br>57 pvs.add(propertyName, autowiredArgument);<br>58 }<br>59 for (String autowiredBeanName : autowiredBeanNames) {<br>60 //指定名称属性注册依赖Bean名称，进行属性依赖注入<br>61 registerDependentBean(autowiredBeanName, beanName);<br>62 if (logger.isDebugEnabled()) {<br>63 logger.debug(“Autowiring by type from bean name ‘“ + beanName + “‘ via property ‘“ +<br>64 propertyName + “‘ to bean named ‘“ + autowiredBeanName + “‘“);<br>65 }<br>66 }<br>67 //释放已自动注入的属性<br>68 autowiredBeanNames.clear();<br>69 }<br>70 }<br>71 catch (BeansException ex) {<br>72 throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);<br>73 }<br>74 }<br>}</string></string></p><p> <br>通过上面的源码分析，我们可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依赖注入要稍微简单一些，但是真正实现属性注入的是DefaultSingletonBeanRegistry类的registerDependentBean方法。<br>(3).DefaultSingletonBeanRegistry的registerDependentBean方法对属性注入：</p><p>1 //为指定的Bean注入依赖的Bean<br>2 public void registerDependentBean(String beanName, String dependentBeanName) {<br>3 //处理Bean名称，将别名转换为规范的Bean名称<br>4 String canonicalName = canonicalName(beanName);<br>5 //多线程同步，保证容器内数据的一致性<br>6 //先从容器中：bean名称–&gt;全部依赖Bean名称集合找查找给定名称Bean的依赖Bean<br>7 synchronized (this.dependentBeanMap) {<br>8 //获取给定名称Bean的所有依赖Bean名称<br>9 Set<string>dependentBeans = this.dependentBeanMap.get(canonicalName);<br>10 if (dependentBeans == null) {<br>11 //为Bean设置依赖Bean信息<br>12 dependentBeans = new LinkedHashSet<string>(8);<br>13 this.dependentBeanMap.put(canonicalName, dependentBeans);<br>14 }<br>15 //向容器中：bean名称–&gt;全部依赖Bean名称集合添加Bean的依赖信息<br>16 //即，将Bean所依赖的Bean添加到容器的集合中<br>17 dependentBeans.add(dependentBeanName);<br>18 }<br>19 //从容器中：bean名称–&gt;指定名称Bean的依赖Bean集合找查找给定名称<br>20 //Bean的依赖Bean<br>21 synchronized (this.dependenciesForBeanMap) {<br>22 Set<string>dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);<br>23 if (dependenciesForBean == null) {<br>24 dependenciesForBean = new LinkedHashSet<string>(8);<br>25 this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);<br>26 }<br>27 //向容器中：bean名称–&gt;指定Bean的依赖Bean名称集合添加Bean的依赖信息<br>28 //即，将Bean所依赖的Bean添加到容器的集合中<br>29 dependenciesForBean.add(canonicalName);<br>30 }<br>}</string></string></string></string></p><p> <br> <br>通过对autowiring的源码分析，我们可以看出，autowiring的实现过程：<br> <br>a.    对Bean的属性迭代调用getBean方法，完成依赖Bean的初始化和依赖注入。<br> <br>b.    将依赖Bean的属性引用设置到被依赖的Bean属性上。<br> <br>c.     将依赖Bean的名称和被依赖Bean的名称存储在IoC容器的集合中。<br> <br>Spring IoC容器的autowiring属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，自动属性依赖注入也有不足，首先，Bean的依赖关系在配置文件中无法很清楚地看出来，对于维护造成一定困难。其次，由于自动依赖注入是Spring容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑。</p></web-app></bean></bean></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/cc5f72fdfb9e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/cc5f72fdfb9e.html" class="post-title-link" itemprop="url">Tomcat</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:02:31 / 修改时间：16:02:55" itemprop="dateCreated datePublished" datetime="2023-12-20T16:02:31+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>1、Tomcat的缺省端口是多少，怎么修改？</p><p>1）找到Tomcat目录下的conf文件夹</p><p>2）进入conf文件夹里面找到server.xml文件</p><p>3）打开server.xml文件</p><p>4）在server.xml文件里面找到下列信息</p><connector connectiontimeout="20000" port="8080" protocol="HTTP/1.1" redirectport="8443" uriencoding="utf-8">port="8080"改成你想要的端口<p>2、tomcat 有哪几种Connector 运行模式(优化)？</p><p>bio：传统的Java I/O操作，同步且阻塞IO。<br>maxThreads=”150”//Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值200。可以根据机器的时期性能和内存大小调整，一般可以在400-500。最大可以在800左右。<br>minSpareThreads=”25”—Tomcat初始化时创建的线程数。默认值4。如果当前没有空闲线程，且没有超过maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。<br>maxSpareThreads=”75”–一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值50。一旦创建的线程超过此数值，Tomcat会关闭不再需要的线程。线程数可以大致上用 “同时在线人数每秒用户操作次数系统平均操作时间” 来计算。<br>acceptCount=”100”—-指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。如果当前可用线程数为0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。<br>connectionTimeout=”20000” –网络连接超时，默认值20000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</p><p>nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。<br>指定使用NIO模型来接受HTTP请求<br>protocol=”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol=”HTTP/1.1”<br>acceptorThreadCount=”2” 使用NIO模型时接收线程的数目</p><p>aio(nio.2)：JDK7开始支持，异步非阻塞IO。<br>apr：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。</p><pre><code>&lt;!--
      &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8000&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;
    --&gt;
    &lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;
    &lt;!-- minProcessors最小空闲连接线程数--&gt;
    &lt;!-- maxProcessors最大连接线程数--&gt;
    &lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;
    &lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;
    &lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; 
        connectionTimeout=&quot;20000&quot;
        redirectPort=&quot;8443
        maxThreads=“500” 
        minSpareThreads=“100” 
        maxSpareThreads=“200”
        acceptCount=&quot;200&quot;
        enableLookups=&quot;false&quot;       
    /&gt;
</code></pre><p>其他配置<br>maxHttpHeaderSize=”8192” http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。<br>URIEncoding=”UTF-8” 指定Tomcat容器的URL编码格式。<br>disableUploadTimeout=”true” 上传时是否使用超时机制<br>enableLookups=”false”–是否反查域名，默认值为true。为了提高处理能力，应设置为false<br>compression=”on” 打开压缩功能<br>compressionMinSize=”10240” 启用压缩的输出内容大小，默认为2KB<br>noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩<br>compressableMimeType=”text/html,text/xml,text/javascript,text/css,text/plain” 哪些资源类型需要压缩</p><p>3、Tomcat有几种部署方式？</p><p>1）直接把Web项目放在webapps下，Tomcat会自动将其部署</p><p>2）在server.xml文件上配置<context>节点，设置相关的属性即可</context></p><p>3）通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。</p><p>编写XML的方式来进行设置。</p><p>4、tomcat容器是如何创建servlet类实例？用到了什么原理？</p><p>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析，</p><p>并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。</p><p>（有时候也是在第一次请求时实例化）在servlet注册时加上如果为正数，则在一开始就实例化，</p><p>如果不写或为负数，则第一次请求实例化。</p><p>5.tomcat 如何优化？</p><p>1、优化连接配置.这里以tomcat7的参数配置为例，需要修改conf/server.xml文件，修改连接数，关闭客户端dns查询。</p><p>参数解释：</p><p>URIEncoding=”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</p><p>maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</p><p>minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</p><p>enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</p><p>connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</p><p>maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</p><p>acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</p><p>maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。</p><p>通常Windows是1000个左右，Linux是2000个左右。</p><p>useURIValidationHack:</p><p>我们来看一下tomcat中的一段源码：</p><p>【security】</p><p>if (connector.getUseURIValidationHack()) {</p><p>String uri = validate(request.getRequestURI());</p><p>if (uri == null) {</p><p>res.setStatus(400);</p><p>res.setMessage(“Invalid URI”);</p><p>throw new IOException(“Invalid URI”);</p><p>} else {</p><p>req.requestURI().setString(uri);</p><p>// Redoing the URI decoding</p><p>req.decodedURI().duplicate(req.requestURI());</p><p>req.getURLDecoder().convert(req.decodedURI(), true);</p><p>可以看到如果把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</p><p>enableLookups=”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</p><p>disableUploadTimeout ：类似于Apache中的keeyalive一样</p><p>给Tomcat配置gzip压缩(HTTP压缩)功能</p><p>compression=”on” compressionMinSize=”2048″</p><p>compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</p><p>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p><p>1)compression=”on” 打开压缩功能</p><p>2)compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB</p><p>3)noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</p><p>4)compressableMimeType=”text/html,text/xml”　压缩类型</p><p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置，对吧？</p><p>&lt;!–enable tomcat ssl–&gt;</p><p>&lt;Connector port=”8443″ protocol=”HTTP/1.1″</p><p>URIEncoding=”UTF-8″ minSpareThreads=”25″ maxSpareThreads=”75″</p><p>enableLookups=”false” disableUploadTimeout=”true” connectionTimeout=”20000″</p><p>acceptCount=”300″ maxThreads=”300″ maxProcessors=”1000″ minProcessors=”5″</p><p>useURIValidationHack=”false”</p><p>compression=”on” compressionMinSize=”2048″</p><p>compressableMimeType=”text/html,text/xml,text/javascript,text/css,text/plain”</p><p>SSLEnabled=”true”</p><p>scheme=”https” secure=”true”</p><p>clientAuth=”false” sslProtocol=”TLS”</p><p>keystoreFile=”d:/tomcat2/conf/shnlap93.jks” keystorePass=”aaaaaa”</p><p>/&gt;</p><p>好了，所有的Tomcat优化的地方都加上了。</p><p>6.内存调优</p><p>内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。<br>具体设置如下：<br>JAVA_OPTS=”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4”<br>其各项参数如下：<br>-Xmx3550m：设置JVM最大可用内存为3550M。<br>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<br>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5<br>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6<br>-XX:MaxPermSize=16m:设置持久代大小为16m。<br>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。<br>7.垃圾回收策略调优</p><p>垃圾回收的设置也是在catalina.sh中，调整JAVA_OPTS变量。<br>具体设置如下：<br>JAVA_OPTS=”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100”<br>具体的垃圾回收策略及相应策略的各项参数如下：<br>串行收集器（JDK1.5以前主要的回收方式）<br>-XX:+UseSerialGC:设置串行收集器<br>并行收集器（吞吐量优先）<br>示例：<br>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</p><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。<br>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。<br>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集<br>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。<br>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。<br>并发收集器（响应时间优先）<br>示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC<br>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。<br>-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。<br>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。<br>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p><p>8.共享session处理</p><p>目前的处理方式有如下几种：<br>1).使用Tomcat本身的Session复制功能<br>参考<a target="_blank" rel="noopener" href="http://ajita.iteye.com/blog/1715312%EF%BC%88Session%E5%A4%8D%E5%88%B6%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%89">http://ajita.iteye.com/blog/1715312（Session复制的配置）</a><br>方案的有点是配置简单，缺点是当集群数量较多时，Session复制的时间会比较长，影响响应的效率<br>2).使用第三方来存放共享Session<br>目前用的较多的是使用memcached来管理共享Session，借助于memcached-sesson-manager来进行Tomcat的Session管理<br>参考<a target="_blank" rel="noopener" href="http://ajita.iteye.com/blog/1716320%EF%BC%88%E4%BD%BF%E7%94%A8MSM%E7%AE%A1%E7%90%86Tomcat%E9%9B%86%E7%BE%A4session%EF%BC%89">http://ajita.iteye.com/blog/1716320（使用MSM管理Tomcat集群session）</a><br>3).使用黏性session的策略<br>对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同一个用户的session可以由nginx或者apache交给同一个Tomcat来处理，这就是所谓的session sticky策略，目前应用也比较多<br>参考：<a target="_blank" rel="noopener" href="http://ajita.iteye.com/blog/1848665%EF%BC%88tomcat">http://ajita.iteye.com/blog/1848665（tomcat</a> session sticky）<br>nginx默认不包含session sticky模块，需要重新编译才行（windows下我也不知道怎么重新编译）<br>优点是处理效率高多了，缺点是强会话要求的场合不合适<br>8.添加JMS远程监控</p><p>对于部署在局域网内其它机器上的Tomcat，可以打开JMX监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在JVM启动参数中配置即可，配置如下：<br>-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false<br>-Djava.rmi.server.hostname=192.168.71.38 设置JVM的JMS监控监听的IP地址，主要是为了防止错误的监听成127.0.0.1这个内网地址<br>-Dcom.sun.management.jmxremote.port=1090 设置JVM的JMS监控的端口<br>-Dcom.sun.management.jmxremote.ssl=false 设置JVM的JMS监控不实用SSL<br>-Dcom.sun.management.jmxremote.authenticate=false 设置JVM的JMS监控不需要认证</p><p>9.专业点的分析工具有</p><p>IBM ISA，JProfiler、probe 等，具体监控及分析方式去网上搜索即可</p><p>10.关于Tomcat的session数目</p><p>这个可以直接从Tomcat的web管理界面去查看即可 ；<br>或者借助于第三方工具Lambda Probe来查看，它相对于Tomcat自带的管理稍微多了点功能，但也不多 ；</p><p>11.监视Tomcat的内存使用情况</p><p>使用JDK自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等；<br>JDK自带的jvisualvm可以下载插件（如GC等），可以查看更丰富的信息。如果是分析本地的Tomcat的话，还可以进行内存抽样等，检查每个类的使用情况</p><p>12.打印类的加载情况及对象的回收情况</p><p>这个可以通过配置JVM的启动参数，打印这些信息（到屏幕（默认也会到catalina.log中）或者文件），具体参数如下：<br>-XX:+PrintGC：输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]<br>-XX:+PrintGCDetails：输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]<br>-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用，输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]<br>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds<br>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds<br>-XX:PrintHeapAtGC: 打印GC前后的详细堆栈信息<br>-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析<br>-verbose:class 监视加载的类的情况<br>-verbose:gc 在虚拟机发生内存回收时在输出设备显示信息<br>-verbose:jni 输出native方法调用的相关情况，一般用于诊断jni调用错误信息</p><p>13.Tomcat一个请求的完整过程</p><p>Ng:(nginx)</p><p>upstream yy_001{<br>server 10.99.99.99:8080;<br>server 10.99.99.100:8080;</p><pre><code>    hash $**; 

    healthcheck_enabled; 
    healthcheck_delay 3000; 
    healthcheck_timeout 1000; 
    healthcheck_failcount 2; 
    healthcheck_send &#39;GET /healthcheck.html HTTP/1.0&#39; &#39;Host: wo.com&#39; &#39;Connection: close&#39;; 
&#125;

 server &#123;
    include base.conf;
    server_name  wo.de.tian;
     ...
    location /yy/ &#123; 
        proxy_pass http://yy_001;
    &#125;
</code></pre><p>首先 dns 解析 wo.de.tian机器，一般是ng服务器ip地址<br>然后 ng根据server的配置，寻找路径为 yy/的机器列表，ip和端口<br>最后 选择其中一台机器进行访问—-&gt;下面为详细过程</p><ol><li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得</li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应</li><li>Engine获得请求localhost/yy/index.jsp，匹配它所拥有的所有虚拟主机Host</li><li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）</li><li>localhost Host获得请求/yy/index.jsp，匹配它所拥有的所有Context</li><li>Host匹配到路径为/yy的Context（如果匹配不到就把该请求交给路径名为”“的Context去处理）</li><li>path=”/yy”的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类</li><li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host</li><li>Host把HttpServletResponse对象返回给Engine</li><li>Engine把HttpServletResponse对象返回给Connector</li><li>Connector把HttpServletResponse对象返回给客户browser</li></ol><p>14.Tomcat工作模式？</p><p>Tomcat是一个JSP/Servlet容器。其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</p><p>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</p><p>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</p><p>Tomcat作为独立服务器：请求来自于web浏览器；</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/aa3500b67dae.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/aa3500b67dae.html" class="post-title-link" itemprop="url">版本管理工具</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:00:42" itemprop="dateCreated datePublished" datetime="2023-12-20T16:00:42+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 11:52:57" itemprop="dateModified" datetime="2023-12-24T11:52:57+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">版本管理工具</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="svn和git的区别及适用场景"><a href="#svn和git的区别及适用场景" class="headerlink" title="svn和git的区别及适用场景"></a>svn和git的区别及适用场景</h1><h4 id="svn的优势"><a href="#svn的优势" class="headerlink" title="svn的优势"></a>svn的优势</h4><ul><li>优异的跨平台支持，对windows平台支持非常友好。</li><li>简单易用，安装后稍微培训下就知道怎么操作。</li><li>代码，需求，文档，涉及稿都可以用svn进行管理，适合不同部门的技术非技术的同事协作。</li></ul><h4 id="git的优势"><a href="#git的优势" class="headerlink" title="git的优势"></a>git的优势</h4><ul><li>去中心化：Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容是完全一样的（格式有点不同，是bare的）。虽然平时大家都是将代码提交到中央服务器上再统一pull别人的代码，但实际情况你可以总是pull张三的库，然后push给李四等等操作。</li><li>本地提交：本地提交好处主要有3点：<ul><li>一， 断网提交</li><li>二， 小步提交。可以对自己的阶段成果有跟踪，并且提高每次变更的安全性</li><li>三，本地库。这个和断网提交是同一个实现，但从需求角度出发则略有不同，主要是说即使只有自己一个人开发项目，也可以轻易的让自己的代码有版本跟踪，而不需要去费力建个什么svn server。</li><li>四，本地回滚。这个其实是由于本地库的存在而产生的，但可以减少中央库上的冗余版本</li></ul></li><li>分支策略：在Git实际开发中分支的分离和merge是属于日常操作，开启和合并分支成本相比SVN要小得多：SVN是复制一份代码到分支目录，Git则是在分支点做一下标记。随便一次冲突就会自动产生分支，所以大家每天都在与分支打交道。这便是弱化了分支的概念，由于分支成本很小，因此使得按功能分支的开发模式（每个分支一个功能，开发完了再merge到主干）变得非常简单，大家可以完全不需要再因为担心SCM成本太高而选用主干开发模式（所有功能都在主干上开发，到了发版本前再分离出分支）。</li></ul><h4 id="两者的工作流对比"><a href="#两者的工作流对比" class="headerlink" title="两者的工作流对比"></a>两者的工作流对比</h4><h5 id="svn模式"><a href="#svn模式" class="headerlink" title="svn模式"></a>svn模式</h5><ul><li>写代码。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将本地代码提交到服务器。</li></ul><h5 id="git模式"><a href="#git模式" class="headerlink" title="git模式"></a>git模式</h5><ul><li>写代码。</li><li>提交到本地版本库。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将远程库与本地代码合并结果提交到本地版本库。</li><li>将本地版本库推到服务器。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>对比可以看出：分布式版本管理仅仅是增加了本地库这个概念，其余的概念与集中管理并无区别。——但是 svn 在与服务器同步之前无法提交代码，因而本地修改更容易出问题。</li><li>当研发成本比较低，协作开发人数不多，开发人员对于版本管理的水平参差不齐的时候，或者对于代码的安全性要求更高一点的时候，适合用svn。</li><li>而对于很多人参与开发，代码量比较大，或者高频次协作，跨公司，跨地域合作的情况下，更适合用git。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/726ed62e2d44.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/726ed62e2d44.html" class="post-title-link" itemprop="url">Nginx</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:59:00" itemprop="dateCreated datePublished" datetime="2023-12-20T15:59:00+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-23 18:19:15" itemprop="dateModified" datetime="2023-12-23T18:19:15+08:00">2023-12-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nginx/" itemprop="url" rel="index"><span itemprop="name">nginx</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Nginx应该是现在最火的web和反向代理服务器，没有之一。她是一款诞生于俄罗斯的高性能web服务器，尤其在高并发情况下，相较Apache，有优异的表现。<br>那除了负载均衡，她还有什么其他的用途呢，下面我们来看下。<br>一、静态代理<br>Nginx擅长处理静态文件，是非常好的图片、文件服务器。把所有的静态资源的放到nginx上，可以使应用动静分离，性能更好。<br>二、负载均衡<br>Nginx通过反向代理可以实现服务的负载均衡，避免了服务器单节点故障，把请求按照一定的策略转发到不同的服务器上，达到负载的效果。</p><p>常用的负载均衡策略有：<br>1、轮询<br>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。<br>2、加权轮询<br>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。<br>给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。<br>3、ip_hash（源地址哈希法）<br>根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问服务器的序号。<br>采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。<br>4、随机<br>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。<br>5、least_conn（最小连接数法）<br>由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。<br>三、限流<br>Nginx的限流模块，是基于漏桶算法实现的，在高并发的场景下非常实用，如下图：</p><p>1、配置参数<br>1）limit_req_zone定义在http块中，$binary_remote_addr 表示保存客户端IP地址的二进制形式。<br>2）Zone定义IP状态及URL访问频率的共享内存区域。<br>zone=keyword标识区域的名字，以及冒号后面跟区域大小。16000个IP地址的状态信息约1MB，所以示例中区域可以存储160000个IP地址。<br>3）Rate定义最大请求速率。示例中速率不能超过每秒100个请求。<br>2、设置限流<br>burst排队大小，nodelay不限制单个请求间的时间。<br>四、缓存<br>1、浏览器缓存，静态资源缓存用expire。</p><p>2、代理层缓存</p><p>五、黑白名单<br>1、不限流白名单</p><p>2、黑名单</p><h1 id="Nginx性能调优："><a href="#Nginx性能调优：" class="headerlink" title="Nginx性能调优："></a>Nginx性能调优：</h1><p>1、增加同时打开⽂件数open files数量；<br>2、处理⼤量静态⽂件的磁盘I/O时(此时worker进程是单线程的)，增加CPU<br>核⼼数Worker Processes数量，提⾼计算能⼒；<br>3、如果⽹站流量很⾼，则可以提升worker进程连接数Worker<br>Connections(默认1024)；<br>4、控制keep alive在10s-20s之间，减少连接的时间开销；<br>5、合理设置open file cache时间提⾼处理效率；<br>6、提⾼⽹路带宽；<br>7、开启压缩传输数据gzip，设置压缩级别gzip_comp_level为1-2，再⾼<br>效果不明显并且浪费CPU了；<br>8、扩展机器数量。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/64b56da2b088.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/64b56da2b088.html" class="post-title-link" itemprop="url">面试技巧</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:57:12 / 修改时间：15:57:37" itemprop="dateCreated datePublished" datetime="2023-12-20T15:57:12+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">面试技巧</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li>面试技巧</li></ul><p>IT从业人员面试技巧</p><pre><code>一般来说，面试你的人都不是一个很好对付的人。别看他彬彬有礼，看上去笑眯眯的，很和气的样子。但没准儿一肚子坏水。
有些人待人特别客气，说话还稍稍有点结巴的，更容易让人上当。 
</code></pre><p>所以，牢记一点，面试的时候保持高度警觉，对方不经意问出来的问题，很可能是他最想知道的。<br>举例来说，我每次面试的时候，最喜欢说的话就是：哦，我不是HR的，你别拘束，咱们就当是聊天……<br>负责面试的人，一般有两种，一种是专门的人力资源部门。我不懂这一块，略过不谈。<br>另外一种就是我这样的，负责某个部门的苦力头。<br>一般来说，公司中层的苦力头，他的脑子里面都有一个模式，他的码头上需要一个什么样的人，他或她必须具备哪些技能。但这些考察都是次要的，他首先要搞清楚一点，那就是对方的人品!!!<br>换句话说，能力是一个方面，但人品是门槛!!!如果他判定你人品有问题，那剩下的问题就没必要了。<br>这里面就有很多陷阱，比如，你怎么评价前一家公司。你要是大说特说那公司怎么不好，我肯定要琢磨了，你昨天背叛少林，那今天会不会背叛武当?<br>最好把离职原因淡淡一说，不要指责谁。我找工作的时候，一般都老实说，我自己能力不行，被公司淘汰了。其实大家肚子都揣着明白，不就是为了找个钱多点的地儿嘛。<br>我经常问的一个陷阱问题就是：谈谈你的父母。<br>其实这个问题一方面是考察对方的家庭教育，另外一方面是看看面试者怎么评价父母。这里面有个通常的逻辑，爹妈把他养这么大，说到自己的父母毫无感恩，感激之情，这种人招进来肯定不能成为合格的苦力。<br>总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</p><p>面试到结束的时候，都会问到薪金标准。<br>我不知道别的公司怎么操作的。我呆过的公司，都是定编定岗的，换句话说，招聘的时候，这个岗位的薪水是早就确定了。<br>也就是说，对方问到薪金的时候，他已经在脑子里面很清楚公司的标准!!!<br>一般说来，这个问题的目的是为了确定，他如果觉得你是个合适的苦力，那么，现在的薪金，你是不是会过来干活。<br>问到薪金的时候，最好的回答是不回答，留到下一次面试再谈。或者可以反问，公司对于这个岗位定的薪金标准是多少。<br>一般来说，苦力头不会管你薪金多少的。好的苦力，苦力头甚至会为你向老板争取。<br>能够混到苦力头的位置上，面试你的人至少具有一定的能力，以及足够的胸怀。他在意的是能不能招到合适的人干活，薪金的问题不是问题。<br>但过高的薪金，会把你抹掉。比如这个岗位，公司定的薪水是三千，你一张嘴，四千，那完了。<br>对于应聘者，其实是很不公平的，你能做的就是接受这个标准或是不接受。<br>如果是刚刚走出校门，月薪三千我想足够生活了。所以，如果对方的薪金标准， 你要么不回答，要么就说三千，别要的太高。<br>一般面试都是在一个独立的私密空间进行。<br>这里简单说说一些基本的礼貌。<br>进门要敲门，敲门是最基本的一点。<br>第二点，落座，别进去一屁股就坐上去了。最好等对方先坐下。当然，一般面试的人都很客气，招呼：坐，坐。<br>有时候进去之后，面试的人已经坐好了，那就别管了，坐在他的对面或他指定的位置就行。我这人比较心理阴暗，一般都是背对亮光坐。<br>当你结束时，至少客气招呼一声：谢谢您抽出时间面试我。<br>如果离开座位，顺手把椅子推好，这也是一个容易疏忽的地方。</p><pre><code> 有些公司的前台小姑娘，是你去面试的时候最先面对的，那么临走的时候客气打声招呼。
我有个习惯，面试的时候带着名片，如果我觉得很合适，会把名片给对方，这样他便于有问题的话联络我。
但是，亲爱的朋友，你去面试的时候，如果对方面前放着名片夹子，千万不要傻了吧叽的要名片。
面试结束的第二天，如果你有面试你的苦力头电话，那就发个短信，内容可以客套一下，就说感谢你昨天面试我之类的话，然后祝福一下，比如今天好心情，工作顺利等等。千万不要问对方结果。你的目的就是提醒他，显示你的存在就行了。
你等待的地方，可能是公司的公共区域，而面试的地方可能是会议室，或者像我这样的人，喜欢在自己的办公室谈。
那么切忌，不要走在前面，也不要走路中间，走在边上就行，把中间的位置留给你未来的领导走。进门之前主动为对方开门，这种拍马屁的小花招可以多来一点。
面试的时候身体正直，自然一点就行。一般来说，不要用摩丝喷的脑袋跟刺猬一样。女孩子也不要用过于浓密的香水。这是谈事情，不是相亲。
谈话的过程中，不要抢话，语速也不要太快。我教大家一个小诀窍，我一般和人谈事情，一开始故意显得有点结巴。人说话结巴，会让人感觉对方很诚恳。   但就开头一两句结巴就行，别一直结巴。
有些人面试的时候介绍自己会滔滔不绝，说话特快。其实这里面有个信息传递的问题，跟别人谈事情，语速太快，往往容易说错。对方接受起来也有问题。中等语速就可以了。
很多男士比较大大咧咧，往那儿一坐，二郎腿就搭上了。要是碰上我这样大大咧咧的，可能无所谓，要是碰到心理阴暗的，就会有负面影响。
另外，很多人一紧张就爱抖腿，这样也不礼貌。
</code></pre><p>面试其实就是一个自我介绍，不是演说，不要声音特大吐沫横飞的，平时说话的声音就行。</p><pre><code> 面试你的要是个女的那就算了，要是个男的，不用管自己的性别，大大方方招呼一声，你好，手伸过去，和他握个手。
其实从握手就能看到一个人的个性，一般来说，握手短促有力，可能是我这样比较外向的性格。握的软绵绵的，对方可能比较内向。
</code></pre><p>1.不要紧张，表现得自然些，要有礼貌，别忘记和主考人招呼，说句”早晨好”。<br>2.举止要大方，不可闪缩，要保持自信。待主考人邀请你才可礼貌地坐下，不 要太随便或左顾右盼;切忌装出懒洋洋和满不在乎的样子。<br>3.微笑可以减轻你内心的不安，更可以令面试的气氛变得融洽愉快。<br>4.让主考人知道你珍惜这次面试的机会。当主考人说话时，要眼望对方，并留心倾听。<br>5.让主考人先打开话匣子。答问题要直接了当，无须太繁复，也不要单说”是”或”不是”;否则，主考人会觉得你欠缺诚意。深入的谈话内容有助主考人对你作出确切的评估。<br>6.假如伙不太明白主考人的问题，应该礼貌地请他重复。不懂得回答的问题，不妨坦白承认。含糊其辞或乱吹牛会导至面试的失败。<br>7.不要打断主考人的说话，被要求就相同的问题重复作答也不能表示不耐烦，更切忌与主考人争辩。<br>8.主考人可能问你一些与面试或者申请的职位完全无关的问题，例如时人时事;目的在进一步了解你的思想及见识。<br>9.紧记在适当时机带出自已的优点和特长。但切勿显得过份自信或浮夸。<br>10.不要急着提出薪酬问题，最好让主考人先提出。<br>11.准备一些与该机构和申请的工作有关的问题在面试结束之前提出。这样能表现伙的积极，亦可给主考人留下良好印象。<br>12.最后，问清楚多久才知道面试结果。不要忘记向主考人道谢及说声”再见”才离去。</p><p>面试一家公司之前需要做的准备<br>第一：</p><ol><li>了解应聘公司；</li><li>了解应聘岗位<br>查该公司的资料，知道该公司是做什么的，发展情况，招聘的岗位的要求等<br>公司地点在哪里，交通是否方便，需提前多久出发；<br>公司类型如何？我应该如何着装？去咨询公司逃不掉正装，而去互联网公司这么穿，人家或许以为你是房产中介；<br>公司业务如何？上市了吗？财报如何？主要产品有哪些？<br>公司在中国有多少分支机构？最近有什么新动向？<br>公司所在行业有何新动向？发展趋势如何？<br>公司的竞争对手有哪些？公司在行业内排名如何？<br>第二：<br>我的建议是：<br>重温一下简历内容，确保每段经历都能用简短的语言复述；<br>带过的团队，做过的项目，组织过的活动，以STAR的形式准备好；<br>每一段经历，都应该准备实例和数据证明，会给面试官留下深刻印象；<br>准备几个感兴趣的问题，面试中如果没有获得解答<br>在电话通知环节，我们必须开口问，有诸多信息要确认：</li><li>面试时间／地点</li><li>公司名称／岗位名称</li><li>联系人信息（一旦迟到，得提前打电话道歉）</li><li>面试官是谁（HR还是直线经理，或者都一次性面试掉）</li><li>需要准备什么材料（一般逃不掉学历证明，身份证复印件等资料）</li><li>针对面试岗位，需要额外准备什么材料（如：做设计，是不是要带设计稿？）<br>关于这家公司： 关<br>5、用<a target="_blank" rel="noopener" href="http://news.baidu.com搜索公司名称、创始人名字,认真读完前5页新闻/">http://news.baidu.com搜索公司名称、创始人名字，认真读完前5页新闻</a><br>6、能够不假思索地，用三句话描述清楚这家公司的业务流程<br>7、能够不假思索地，说出3-5个这家公司的品牌产品、品牌活动、举办的重大事件的主题<br>8、了解这家公司是处于哪个阶段（初创期、高速成长期、逐渐成熟期），以便推测对方需要的团队是什么状态<br>9、能说出3-5家，这家公司的竞争对手/业务比较接近的公司<br>如何提问题：</li></ol><p>人事面试技巧总结<br>一定不要将公司的工作当作负担，一定要做好并且学到东西，这才是你下一次跳槽能够展示的东西，所以在公司工作，你拿着工资，而不只是在为公司打工，而是为自己的未来进行修炼，一定要有这方面的意识。<br>总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的<br>问题，可能里面处处陷阱!!!<br>1：人事这关也很重要，特别是工资方面，还有团队，工作方面？(重要)<br>2：对公司的主营业务要表现足够的兴趣，关系公司的发展？<br>3：3面就该和你谈谈钱的事情，你们的重点就是在于薪资，福利和以后的发展，这个时候就是公司对你展示他的潜力了，也是希望能留住你（招人也不容易），那么你对你自己的定位，和你的期望薪资就可以大胆<br>的说出来 ， 不要因为不好意思而错过你要价的机会，因为一般进入公司后你想涨薪资就比较复杂了，而且这只是你的期望 ，面试官会对你提出他们会给你的工资， 也就是一个讨价还价的过程<br>总之在这个环节，你可以大胆提出你的期望薪资与发展方向（不要太离谱哈，当然你要作死我也不拦着你），和你的面试官慢慢讨论<br>4：试用期：在这个环节就是心态上注意，技术上展示你的能力，处事上和谐相处，重中之重是在于融入团队，你个人的力量是完不成整个项目的<br>5：对新公司的了解，公司发展情况，业务方向，特长等，如果在企业文化上也有优势，可以多夸下公司的的企业文化<br>6：期望的薪资，最好是了解了工作内容、加班情况、福利情况再谈待遇<br>期望的薪资，最好是了解了工作内容、加班情况、福利情况再谈待遇。最好先了解行情以免太高或太低。不要说太死了，看到对方表情不对就改口说可以商量，或者试探性的问一下对方能否接受，不行就说自己要<br>高工资的原因并说明其实自己更看重发展机会，工资再少点也可以。不要轻易说自己能接受的最低工资，很可能他就给你这个最低的。如果对方能接受你的要求但是觉得有点偏高时，要说明自己凭什么可以拿这么<br>高，并说明自己的优势对岗位的重要性。<br>要问公司的问题： 要<br>１.薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等。<br>２.所在部门的规模、发展计划，个人的成长机会。<br>３.自己的工作内容及可能的发展机会等。<br>向人事提问时最好不要一开始就谈工资，还有不要问太多可能留下不好印象的问题。问最基本的可能影响你去留的问题，其他问题可以进了再问，言多必失<br>4.面试前根据招聘信息的岗位要求多做相应准备<br>你为什么来北京（城市）发展？ 你<br>提出这个问题不要认为胡乱回答就行了，面试官是想看你什么原因，是否稳定。不会有哪家公司找一个很不稳定的人的。回答尽量夸城市，想在这里发展云云<br>你离职原因？ 你<br>说到这个问题很多人都很头大，换工作的人清楚这个问题基本是必问的一个问题。这个问题很难回答，为什么呢？因为你如果说是公司的问题，这不好那不好，那么就很危险了，因为面试官会想，以后你从我们公<br>司走出去是不是也这么说我们公司。说因为自己的原因呢，如果没好的理由，面试官也会想如果你来公司因为这些理由离开我公司呢，给人很不稳定的感觉。一般我会回答公司倒闭或者公司被收购、实习到期或者<br>你本身确实有不得已的理由，比如公司发展和自己的发展不符合，等等，不要直接说公司或者自己的某些原因。除非没有好理由<br>为什么来我们公司？我们公司你了解多少？ 为 —-提前了解面试的公司 提<br>问这个就考察你的提前准备的资料了，既然这家公司通知你面试了，你肯定要去查相关资料，不需要详细的，但是你肯定要公司做什么的要知道。这个要考察自己巴拉巴拉的能力了，比如我觉得公司发展跟我想做<br>的蛮符合的，我想珍惜这个机会…与公司同步发展云云<br>你认为你的优点和缺点有哪些？ 你<br>不要认为这个问题很简单，吹吹牛就可以了。首先你要清楚的知道，你的优点基本能在你工作中用到的，你的缺点千万不能出现在工作中。优点很好说，缺点就很难。优点比如，我工作认真踏实，团队意识强，学<br>习能力强等等等，缺点你怎么说呢？好吃懒做，不思进取。这样回答基本就挂了。你必须自己的缺点和公司无关紧要的，经过面试经验，一般回答你自己生活上的，比如我花钱控制不了那么详细，就会引起对方的<br>兴趣，那你干嘛了？你可以随便说了，我一般控制自己每月花一千，但是朋友聚会花了一千五。对金钱控制不好，这完全不影响你的工作。其他也可以自己想其他理由。<br>禁忌禁 9：不知情况乱开价 ： —-提前查好对应的工资基本水平 提<br>说到薪资60%代表你有很大的机会被录用，可是你却狮子大开口的说薪资要求，企业怎么敢用一个漫不符合本身能力的人?如果不想吃亏，应聘前应多打听企业相关信息，不然就采取“依公司规定”的保守战略。不知<br>行情胡乱开价，绝不让你的应聘倒扣200分。<br>A.北京这边的人力资源市场还是非常繁荣的，人才的流动性非常快，每年有两段流动高峰期。 北<br>1.通常3<del>4月和9</del>10月是找工作高峰期：<br>3<del>4月是大量人才拿到年终奖后跳槽的时期；<br>9</del>10月是各大高校毕业生求职时期；<br>这两段时间都是企业释放大量岗位空缺的时间段，故而是求职旺季。<br>2. 跳槽也最好在这段时间，其它时间段最好不要跳槽，因为这时：<br>一来岗位无空缺不好招人，二来公司人事会认为你是被裁员工印象不好，这样就不好谈价格了。<br>2.注意公司是以技能需求为驱动在人才市场里面找拥有目标技能的目标人群，而非以你所做项目为驱动，所以在简历里面技能项要分条重点表达，所做项目要辅助技能项做大致表达。<br>4.有些公司在行业里面有地位，是龙头老大，例如BAT、京东等的高并发系统架构方面的业务；平安等互联网金融的支付业务。这些公司的业务代表了行业规范，起到示范作用，能够学习到他们公司的这种权威性<br>的技术或业务，以后可以到想效仿这些公司的其它小公司里面去，就可以有谈判的资本了，这就是在大公司的好处。（这就是为何在BAT工作的人，只要接触了BAT的核心技术，跳出来就那么值钱）<br>C.有些公司的某些部门，明明就不缺人，却天天打着招人的旗号，让人去面试。那么被猎头/人事叫去面试之前，先问了解一些具体情况，有如下一些意识：<br>1.从岗位角度问： 从 这个岗位是常年招聘的，还是最近刚招聘的。<br>（如果是常年招聘的，那么最好不要过去了，人家公司上层可能都没有提供新员工名额，让你过去对你的要求是极高，你达到了或许有点希望，而且后面谈工资的时候对自己没有多少优势；如果是最近刚招聘的、<br>岗位急着要人的，那么可以试试。）<br>2.从部门角度问： 从 这个岗位所在的部门是什么情况，是由于业务扩展新成立的，还是一些老的部门。<br>（如果是新成立一个部门，那么确实有可能要进新人，公司可能会放出岗位需求名额；如果是不是新成立的部门，是老部门，那么很可能这个岗位招人就不那么迫切。）<br>3.从岗位职责要求角度问： 从 这个岗位的职责是什么，需要有什么技能的人选。<br>（可以先让跟你打电话的猎头/人事给你发一个JD邮件，你看看是否和你的技能、兴趣相符，如果相符则可以考虑是否过去；如果不相符，你都不知道他看了你的简历后怎么选的你，那你要么回信问清楚为何觉得我<br>合适、贵岗位具体需要什么人做什么事情，如果没回音，就不要再管了，他们不要人的。不要怕把他们问烦了，他们如果真的缺人，那么不怕你多问，还怕你不来呢，问两句就烦，直接就说明他们本来就不确认，<br>你去不去面试对他们影响不大。）<br>4.面试过程中要有警觉： 面 如果最终还是去了，那么面试过程中也可以看到他们是否缺人。如果面试官上来就问你以前的项目，要你给他详细讲解，那么多半想把你当成免费的”老师“，你可以准备好一些素材给他<br>讲；他问你有没有什么要问他的，你可以问他们要什么样技能的人，如果他们说的空泛不具体，不说需要具体掌握什么技能的，就是他们自己都不能详细表达岗位需求，那多半也不缺人。<br>5.为何有些公司要这样 为 “挖坑挖 ”呢？为何要设置那些长期招聘的岗位呢？ 呢<br>第一、未雨绸缪。如果公司认为过段时间有人会离职，尤其是发完年终奖之前，那么就会提前做好准备，去招新人减少风险，而老员工未走新员工的招聘进度可以慢一点来。<br>第二、降低人力成本。如果公司当前人力成本太高，那么就想淘汰部分高价的老员工换来廉价新员工，那么会在老员工走之前招人，而新员工的招聘也可以慢一点来，招的到就招，招不到就不招，总之价格要压<br>低。（这样的公司卸磨杀驴，不去也罢）<br>第三、换血。如果公司的部门当前好久没有换血了，对部门不是太有利，那么也是常年打着招聘的旗号招人，碰到真正有料的人选，如果成功压低了价格，也可以招进来，但公司不太缺人的情况下，不招也行。<br>第四、了解行业动态。这主要是部门某些人心术不正，让面试者赶来面试，当免费老师，以面试为名从面试者口中获取一些其它公司的技术内幕。（搞技术的人都不傻，出来混迟早要还的，心术不正败坏的是自己<br>公司的名声。）<br>6.面试官问你的职业规划？该怎么回答？<br>谢邀。窃以为，回答这个问题要注意三点：<br>1、接地气。 、 也就是实实在在的说，不做作。这应该是在跟HR交流各个问题都要注意的，不要去学习面经上那些头头是道的回答，针对性并不强，不能把自己的特质表露出来，这对应聘双方都是无益的。搞清楚自<br>己的想法，流畅的表达就行了（表达上也许需要一些技巧），至于如何搞清楚自己的想法，请看第二点。<br>2、预先做功课。 、 了解自己和了解社会是一生都不应该停止的两个过程。在应聘之前，需要对自己和要应聘的行业、公司、岗位都有一定的了解，知道自己的兴趣点和竞争优势，在这个基础上才能够谈职业规划。<br>3、区分职业和工作。 、 HR问你职业规划，也许只是在探寻你对这个岗位或公司的热衷度，判断你是无关痛痒的仅仅想要一份工作安身，还是对未来的发展有一定的方向，方向和目标自然不可能太具体，所以lz觉得<br>难回答，但是，面试官想知道的其实是你对自己未来的期许是什么样子的，仅此而已。<br>参考：我希望在 我 **公司发展成为 公 “T”字形人才，短期目标，我希望能够接触尽可能多的知识面，努力扩展自己专业技能的 字 “横”，可以独立的完成工作中的每一个任务。 ，<br>长期目标，我希望自己在知识面足够宽的基础上，能够有一到两个方向的深入研究，深入自己工作中的一 长 ”竖“，早日独当一面，成为公司的中流砥柱 ，<br>人事问工资该如何回答？<br>2年工作经验：<br>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等<br>工作的内容，公司的发展<br>半年的时候去做大数据项目后加过一次薪，9000加到了12000.<br>12K——-17K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1000左右<br>3年工作经验：<br>17K——–23K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1400左右<br>具体的情况，根据面试的好坏做相应的调整，但是工资的税前和税后差额一般在2k—3k<br>面试的本质不是一问一答，而是亮点展示 面<br>面试时问到服务器的问题：<br>磁盘：插拔式的2T磁盘<br>内存：16G 核数：16核32线程的</p><p>面试问题汇总<br>1、请介绍一下你自己<br>这是面试官100%会问的问题，一般人回答这个问题过于平常，只说姓名、年龄、爱好、所学专业等，如果你用一分钟来重复你的简历，那么，你的印象加分没有了！<br>不妨坦诚自信地展现自我，重点突出与应聘职位相吻合的优势。你的相关能力和素质是企业最感兴趣的信息。因为，在许多情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。<br>回答范例：我叫XX，今年X岁，XXXX年毕业于XX大学。有3年的开发工作经验，我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，精通.Net技术体系，熟悉MVC。平常有时间看看博客，并且自己也喜欢在CSDN上写技术类的文章，与博友一起讨论。谢谢！<br>2、为什么来北京找工作？<br>面试官对异地求职者90%都会问的问题，主要考察你是否稳定，个人经验能力之外，排在第一位的就是稳定性，如果不够稳定，那么其余都是空谈。<br>回答范例：我来自河南，河南是一个农业大省，IT行业还不是很发达，我是学计算机专业的，也很喜欢这个行业，北京在国内IT行业发展是最快的，所以我想来这里谋求发展，学习更多的新技术，能够带来自我的提升。<br>注意：不要说以前公司有多么不好。也不要说哪个哥们混的很不错，羡慕才来北京。因为企业招人想要的都是能够长期工作的人，可能哪个哥们哪天在别的地方又混的更好了，你是不是还要跳槽？所以，只要说来学习更多新技术和管理经验就够了。<br>3、你为什么离开原来的公司？<br>回答提示：①最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在。②避免把“离职原因”说得太详细、太具体。③不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等。④但也不能躲闪、回避，如“想换换环境”、“个人原因”等。⑤不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。⑥尽量使解释的理由为应聘者个人形象添彩。⑦相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。<br>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。<br>4、你最大的缺点是什么？<br>被面试官问的概率很大，也是HR的杀手锏和狠招，这个问题最难回答，通常面试官不希望听到求职直接回答的缺点是什么，如果求职者说自己小心眼、脾气大、工作效率低，企业肯定不会录用你。不要自作聪明地回答“我最大的缺点就是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。面试官喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上，突出优点的部分，面试官喜欢聪明的求职者。<br>回答范例：这个问题好难回答啊！我想想……（亲和力表现，也缓解了自己的紧张情绪）<br>我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。<br>5、你未来3-5年的职业规划是怎样的？<br>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。<br>回答范例：我希望从现在开始，1-2年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以从开发做到架构师。同时我也希望自己能够在企业的平台上得到进一步的职业能力提升。<br>6、你对薪资的要求？<br>如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求职的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。<br>回答范例一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。<br>如果你必须自己说出具体数目，那就不要说一个宽泛的范围，不要说7000-8000之间，那样你将只会得到最低限底的数字，也就是7000。最好给出一个具体的数字。<br>7、什么时候能入职？<br>大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司的规定上班”，如果还未辞去上一个工作，但上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。<br>8、介绍一个你认为最熟悉的项目（项目经理）<br>这个问题在技术面试时常被问到，问这个问题的意图是想考察你的成长路径和编程习惯，因为，你最熟悉的项目往往是你成长最快的项目，那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹。所以，通过你对熟悉项目的描述，有经验的他会很快锁定你技术成长中的缺陷和闪光点，从而判断是否能够“为我所用”。<br>你最好拿出一个自己最擅长技术的那个项目进行介绍，他听完你的介绍后，会接下来进行提问，这样他所有问的问题，你都成竹在胸了。<br>切忌拿自己参与很少的项目来介绍，一旦他深入的询问很可能你会答非所问，反而造成更严重的影响。你大强以和他谈谈在那个项目中获得的经验，这样会引起此君的共鸣，有可能的话，说出一些你自己的小技巧，他会很高兴，同时这场面试也会很轻松，拿到Offer基本没问题了。<br>9、如果公司录用你，你将怎样开展工作？<br>很多企业在招聘开发人员时很看重是否能够尽快上手，所以回答这个问题时要“实打实”的回答，在回答中最好强调能够“尽快”投入开发工作中，这样领导就放心了，会觉得你不是一个只会盲目工作的人，而是一个按部就班，稳打稳扎的人。<br>回答范例：我对咱们公司的大体情况只有一个大概了解，在这个职位的工作性质仅仅是我自己的一个理解。作为这个职位而言，我想我首先要对本公司的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向、我们面向的客户性质等。第二我要了解所属部门在公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。第三，了解我参与项目的开发方式，架构方式，紧密配合领导工作，尽快投入具体的开发工作中。这就是我开展工作的计划。<br>10、你还有什么问题问我吗？<br>这个问题看上去可有可无，其实很关键，面试官不喜欢说“没有问题”的人，没有问题就是自寻死路，没有问题传达出你对公司缺乏兴趣，而只是来寻找一笔薪水。其实在面试过程中谦虚礼貌的问面试官怎么称呼，该部门工作中的信息，如项目情况，开发技术再或者说贵公司的晋升机制是什么样的等。表现出一种很积极主动的状态是非常讨巧的。也可以更多的了解到自己来的工作环境。企业很欢迎这样的求职者，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。<br>11、你对加班的看法？<br>实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。<br>回答范例：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。<br>12、你朋友对你的评价？<br>回答提示： 想从侧面了解一下你的性格及与人相处的问题。<br>回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。<br>回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。<br>13、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？<br>回答提示：一段时间发现工作不适合我，有两种情况：①如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。<br>14、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？<br>回答提示：①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。<br>15、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？<br>回答提示：①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。<br>③总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。<br>16、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？<br>回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。<br>17、谈谈你对跳槽的看法？<br>回答提示：①正常的“跳槽”能促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。<br>18、工作中你难以和同事、上司相处，你该怎么办？<br>回答提示：①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话 我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。<br>19、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？<br>回答提示：①成绩比较突出，得到领导的肯定是件好事情，以后更加努力。②检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。③工作中，切勿伤害别人的自尊心。④不再领导前拨弄是非。<br>20、你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加？<br>回答提示：公司组织参加，就是传智播客的培训课程（可以多谈谈自己学的技术）。<br>21、你对于我们公司了解多少？<br>回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过5海外经销商。<br>22、请说出你选择这份工作的动机？<br>回答提示：这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。<br>23、你最擅长的技术方向是什么？<br>回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。<br>24、你能为我们公司带来什么呢？<br>回答提示：企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。<br>25、最能概括你自己的三个词是什么？<br>回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，<br>26、你的业余爱好是什么？<br>回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。<br>27、作为被面试者给我打一下分？<br>回答提示：试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。<br>28、你怎么理解你应聘的职位？<br>回答提示：把岗位职责和任务及工作态度阐述一下。<br>29、喜欢这份工作的哪一点？<br>回答提示：相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。<br>30、说说你对行业、技术发展趋势的看法？<br>回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。<br>31、对工作的期望与目标何在？<br>回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。<br>32、说你的家庭？<br>回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭，我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。<br>33、就你申请的这个职位，你认为你还欠缺什么？<br>回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。<br>34、你欣赏哪种性格的人？<br>回答提示：诚实、不死板而且容易相处的人、有“实际行动”的人。<br>35、你通常如何处理別人的批评？<br>回答提示：①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷靜下来再讨论。<br>36、你为什么愿意到我们公司来工作？<br>回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。<br>37、你和别人发生过争执吗？你是怎样解决的？<br>回答提示：这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。<br>38、问题：你做过的哪件事最令自己感到骄傲？<br>回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。<br>39、新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？<br>回答提示：(1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。(2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。(3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。(4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。(5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。<br>40、对这项工作，你有哪些可预见的困难？<br>回答提示：①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。<br>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。<br>41、怎样对待自己的失敗？<br>回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。<br>42、什么会让你有成就感？<br>回答提示：为贵公司竭力效劳，尽我所能，完成一个项目。<br>43、眼下你生活中最重要的是什么？<br>回答提示：对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。<br>44、与上级意见不一是，你将怎么办？<br>回答提示：①一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”②如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”<br>分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。<br>45、你工作经验欠缺，如何能胜任这项工作？<br>常规思路：①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。③如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”<br>点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。<br>46、你希望与什么样的上级共事？<br>回答提示：①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。③如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。<br>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。<br>47、谈谈如何适应办公室工作的新环境？<br>回答提示：①办公室里每个人有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。<br>48、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？<br>回答提示：每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。<br>49、如果你在这次面试中没有被录用，你怎么打算？<br>回答提示：现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞争。<br>50、假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？<br>回答提示：我觉得工作是第一位的，但朋友间的情谊也是不能偏废的，这个问题我觉得要按照当时具体的情况来决定。①如果我的朋友晚上9点中的飞机，而我的加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。②如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。③如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。（1）如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。（2）如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，相信他会理解，毕竟工作做完了就完了，朋友还是可以再见面的。<br>51、谈谈你过去做过的成功案例？<br>回答提示：举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。<br>52、谈谈你过去的工作经验中，最令你挫折的事情？<br>回答提示：曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。<br>分析：借此了解你对挫折的容忍度及调解方式。<br>53、如何安排自己的时间？会不会排斥加班？<br>回答提示：基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。<br>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。<br>54、为什么我们要在众多的面试者中选择你？<br>回答提示：根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、ＥＱ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。<br>分析：别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。<br>55、你并非毕业于名牌院校？<br>回答提示：是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我想我更适合贵公司这个职位。<br>56、怎样看待学历和能力？<br>回答提示：学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？<br>57、工作中学习到了些什么？<br>回答提示：这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。<br>58、想过创业吗？<br>回答提示：这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？<br>59、除了本公司外，还应聘了哪些公司？<br>回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。<br>60、面试注意事项：<br>1，在面试官面前千万不要抖脚，手脚不要动来动去，不能有小动作。<br>2，在面试过程中，千万不要跟面试官去争论，说话太冲，太能说、抢话说、乱说都不好，遇到难题，先思考一下，切记心浮气燥，表达时口气温和，谦虚。<br>3，如果面试过程中都不错，谈的也很好，之后却没有给Offer，完全是自己意料之外的情况，这个很有可能，或许是因为公司有了其他的人选，不用介意，更不要沮丧。<br>4，在面试过程中，切忌问关于公司计划、行业机密等相关的东西，不要打探公司的内幕，机密敏感性的问题不要问东问西。<br>5，千万要注意仪容仪表，要有礼貌，最好不要有口吃，口头表达，逻辑思维很重要，不要让面试官觉得你很幼稚，太过小孩子气，显的不够稳重踏实。<br>6，在去面试之前，要熟悉自己的简历，特别是工作经历，准备好关于一些离职原因、职业规划方面的问题的回答方式。<br>7，在面试过程中，80%的面试官会让做自我介绍，所以提前要准备一下，说出的内容既要和简历相符，又要有重点有突出的地方，不能像背简历一样。<br>8，面试完后，如果等待的时间较长，没有回应，就可能没有什么希望了，自己可以打电话去了解情况。<br>9，在面试过程中，谈到薪资的时候，如果没有说明是税后工资就是税前，假如是税前6000，这里面就包括了公司给交的公积金，还有其他五险要交的费用，拿到手差不多4000左右。<br>61、投递简历注意事项<br>1，投简历的时间最好在早上8点多钟，因为人事9点多开始收简历，收到的简历又都是按时间来排序的，所以一般早上8点到9点投的都会排在前面，人事当天就能看到。<br>写简历：<br>1，现居住地最好能在企业附近，如果不在，只写北京，人事比较看重现居住地，如果你填写的现居地离公司远，基本上人事就不太愿意打电话了，因为她（他）怕你不会来。<br>2，期望薪资最好不要写在简历上，也不要填写在网上的简历上，具体薪资见面的时候再谈。<br>3，大部分的岗位招聘都有相应的硬性要求，比如：年龄、居住地点、工作年限等。如果自己不符合也没有关系，机会还有很多。<br>4，简历上的工作经历不能太多，否则人事会觉得你不够稳定。<br>5，开发工作，简历上的项目要抓住重点，放重要的技术点，不能千篇一律，简短、抓住中心。<br>62、入职后试用期：<br>1，到了公司之后，工作中不懂的地方要多问，跟同事搞好关系，多看看旁人在干什么～<br>2，有些同学被录用之后都还不知道自己的薪资待遇，也不知道公司有哪些福利，这是因为在面试过程中不敢多问。因此，如果在面试过程中，面试官已经比较明确的表达了想让你去上班后，你就可以在适当的时候问一些关于工作的情况，工资、福利待遇，上班时间，加班情况等等。<br>63、上家公司的组成架构：<br>根据你的公司来定即可。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span><a class="page-number" href="/default-index/page/3/">3</a><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/3/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>