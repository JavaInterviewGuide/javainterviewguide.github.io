<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java后端面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/2/index.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/2/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java后端面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">26</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/fe062138c36d.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/fe062138c36d.html" class="post-title-link" itemprop="url">Memcached</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:10:21" itemprop="dateCreated datePublished" datetime="2023-12-20T16:10:21+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-25 22:51:49" itemprop="dateModified" datetime="2023-12-25T22:51:49+08:00">2023-12-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="memcached是怎么工作的？"><a href="#memcached是怎么工作的？" class="headerlink" title="memcached是怎么工作的？"></a>memcached是怎么工作的？</h1><ul><li>Memcached的神奇来自两阶段哈希（two-stage hash）</li><li>Memcached就像一个巨大的、存储了很多&lt;key,value&gt;对的哈希表。通过key，可以存储或查询任意的数据。 </li><li>客户端可以把数据存储在多台memcached上。当查询数据时，客户端首先参考节点列表计算出key的哈希值（阶段一哈希），进而选中一个节点；客户端将请求发送给选中的节点，然后memcached节点通过一个内部的哈希算法（阶段二哈希），查找真正的数据（item）。 </li><li>举个列子，假设有3个客户端1, 2, 3，3台memcached A, B, C：Client 1想把数据”barbaz”以key “foo”存储。Client 1首先参考节点列表（A, B, C），计算key “foo”的哈希值，假设memcached B被选中。接着，Client 1直接connect到memcached B，通过key “foo”把数据”barbaz”存储进去。Client 2使用与Client 1相同的客户端库（意味着阶段一的哈希算法相同），也拥有同样的memcached列表（A, B, C）。 于是，经过相同的哈希计算（阶段一），Client 2计算出key “foo”在memcached B上，然后它直接请求memcached B，得到数据”barbaz”。 </li><li>各种客户端在memcached中数据的存储形式是不同的（perl Storable, php serialize, java hibernate, JSON等）。一些客户端实现的哈希算法也不一样。但是，memcached服务器端的行为总是一致的。 </li><li>最后，从实现的角度看，memcached是一个非阻塞的、基于事件的服务器程序。这种架构可以很好地解决C10K problem ，并具有极佳的可扩展性。 </li></ul><h1 id="memcached最大的优势是什么？"><a href="#memcached最大的优势是什么？" class="headerlink" title="memcached最大的优势是什么？"></a>memcached最大的优势是什么？</h1><ul><li>Memcached最大的好处就是它带来了极佳的水平可扩展性，特别是在一个巨大的系统中</li><li>由于客户端自己做了一次哈希，那么我们很容易增加大量memcached到集群中</li><li>memcached之间没有相互通信，因此不会增加 memcached的负载；没有多播协议，不会网络通信量爆炸（implode）。memcached的集群很好用。内存不够了？增加几台 memcached吧；CPU不够用了？再增加几台吧；有多余的内存？在增加几台吧，不要浪费了。 </li><li>基于memcached的基本原则，可以相当轻松地构建出不同类型的缓存架构。</li></ul><h1 id="memcached和MySQL的query-cache相比，有什么优缺点？"><a href="#memcached和MySQL的query-cache相比，有什么优缺点？" class="headerlink" title="memcached和MySQL的query cache相比，有什么优缺点？"></a>memcached和MySQL的query cache相比，有什么优缺点？</h1><ul><li>把memcached引入应用中，还是需要不少工作量的</li><li>MySQL有个使用方便的query cache，可以自动地缓存SQL查询的结果，被缓存的SQL查询可以被反复地快速执行。</li></ul><h4 id="Memcached与之相比，怎么样呢"><a href="#Memcached与之相比，怎么样呢" class="headerlink" title="Memcached与之相比，怎么样呢"></a>Memcached与之相比，怎么样呢</h4><ul><li>MySQL的query cache是集中式的，连接到该query cache的MySQL服务器都会受益。 </li><li>当您修改表时，MySQL的query cache会立刻被刷新（flush）</li><li>存储一个memcached item只需要很少的时间，但是当写操作很频繁时，MySQL的query cache会经常让所有缓存数据都失效。 </li><li>在多核CPU上，MySQL的query cache会遇到扩展问题（scalability issues）。在多核CPU上，query cache会增加一个全局锁（global lock）, 由于需要刷新更多的缓存数据，速度会变得更慢。 </li><li>在 MySQL的query cache中，我们是不能存储任意的数据的（只能是SQL查询结果）。而利用memcached，我们可以搭建出各种高效的缓存。比如，可以执行多个独立的查询，构建出一个用户对象（user object），然后将用户对象缓存到memcached中。而query cache是SQL语句级别的，不可能做到这一点。在小的网站中，query cache会有所帮助，但随着网站规模的增加，query cache的弊将大于利。 </li><li>query cache能够利用的内存容量受到MySQL服务器空闲内存空间的限制。给数据库服务器增加更多的内存来缓存数据，固然是很好的。但是，有了memcached，只要您有空闲的内存，都可以用来增加memcached集群的规模，然后您就可以缓存更多的数据。 </li></ul><h1 id="memcached和服务器的local-cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？"><a href="#memcached和服务器的local-cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？" class="headerlink" title="memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？"></a>memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？</h1><ul><li>首先，local cache有许多与上面(query cache)相同的问题</li><li>local cache能够利用的内存容量受到（单台）服务器空闲内存空间的限制</li><li>不过，local cache有一点比memcached和query cache都要好，那就是它不但可以存储任意的数据，而且没有网络存取的延迟。 </li><li>local cache的数据查询更快</li><li>考虑把highly common的数据放在local cache中吧。如果每个页面都需要加载一些数量较少的数据，考虑把它们放在local cached吧。 </li><li>local cache缺少集体失效（group invalidation）的特性。在memcached集群中，删除或更新一个key会让所有的观察者觉察到。但是在local cache中, 我们只能通知所有的服务器刷新cache（很慢，不具扩展性），或者仅仅依赖缓存超时失效机制。 </li><li>local cache面临着严重的内存限制，这一点上面已经提到。 </li></ul><h1 id="memcached的cache机制是怎样的？"><a href="#memcached的cache机制是怎样的？" class="headerlink" title="memcached的cache机制是怎样的？"></a>memcached的cache机制是怎样的？</h1><ul><li>Memcached主要的cache机制是LRU（最近最少用）算法+超时失效</li><li>当您存数据到memcached中，可以指定该数据在缓存中可以呆多久Which is forever, or some time in the future</li><li>如果memcached的内存不够用了，过期的slabs会优先被替换，接着就轮到最老的未被使用的slabs。 </li></ul><h1 id="memcached如何实现冗余机制？"><a href="#memcached如何实现冗余机制？" class="headerlink" title="memcached如何实现冗余机制？"></a>memcached如何实现冗余机制？</h1><ul><li>不实现！我们对这个问题感到很惊讶</li><li>Memcached应该是应用的缓存层</li><li>它的设计本身就不带有任何冗余机制</li><li>如果一个memcached节点失去了所有数据，您应该可以从数据源（比如数据库）再次获取到数据</li><li>您应该特别注意，您的应用应该可以容忍节点的失效</li><li>不要写一些糟糕的查询代码，寄希望于 memcached来保证一切！如果您担心节点失效会大大加重数据库的负担，那么您可以采取一些办法。比如您可以增加更多的节点（来减少丢失一个节点的影响），热备节点（在其他节点down了的时候接管IP），等等。 </li></ul><h1 id="memcached如何处理容错的？"><a href="#memcached如何处理容错的？" class="headerlink" title="memcached如何处理容错的？"></a>memcached如何处理容错的？</h1><ul><li>不处理！</li><li>在memcached节点失效的情况下，集群没有必要做任何容错处理</li><li>如果发生了节点失效，应对的措施完全取决于用户</li><li>节点失效时，下面列出几种方案供您选择： <ul><li>忽略它！在失效节点被恢复或替换之前，还有很多其他节点可以应对节点失效带来的影响</li><li>把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下（余数式哈希算法），客户端添加或移除节点，会导致所有的缓存数据不可用！因为哈希参照的节点列表变化了，大部分key会因为哈希值的改变而被映射到（与原来）不同的节点上。 </li><li>启动热备节点，接管失效节点所占用的IP。这样可以防止哈希紊乱（hashing chaos）。 </li><li>如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈希算法（consistent hashing）</li><li>两次哈希（reshing）。当客户端存取数据时，如果发现一个节点down了，就再做一次哈希（哈希算法与前一次不同），重新选择另一个节点（需要注意的时，客户端并没有把down的节点从节点列表中移除，下次还是有可能先哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和坏的节点上都可能存在脏数据（stale data）。 </li></ul></li></ul><h1 id="如何将memcached中item批量导入导出？"><a href="#如何将memcached中item批量导入导出？" class="headerlink" title="如何将memcached中item批量导入导出？"></a>如何将memcached中item批量导入导出？</h1><ul><li>您不应该这样做！</li><li>Memcached是一个非阻塞的服务器</li><li>任何可能导致memcached暂停或瞬时拒绝服务的操作都应该值得深思熟虑</li><li>向 memcached中批量导入数据往往不是您真正想要的</li><li>想象看，如果缓存数据在导出导入之间发生了变化，您就需要处理脏数据了；如果缓存数据在导出导入之间过期了，您又怎么处理这些数据呢？ </li><li>因此，批量导出导入数据并不像您想象中的那么有用。不过在一个场景倒是很有用。如果您有大量的从不变化的数据，并且希望缓存很快热（warm）起来，批量导入缓存数据是很有帮助的。虽然这个场景并不典型，但却经常发生，因此我们会考虑在将来实现批量导出导入的功能。 </li></ul><h1 id="memcached是如何做身份验证的？"><a href="#memcached是如何做身份验证的？" class="headerlink" title="memcached是如何做身份验证的？"></a>memcached是如何做身份验证的？</h1><ul><li>没有身份认证机制！</li><li>memcached是运行在应用下层的软件（身份验证应该是应用上层的职责）</li><li>memcached的客户端和服务器端之所以是轻量级的，部分原因就是完全没有实现身份验证机制。这样，memcached可以很快地创建新连接，服务器端也无需任何配置。 </li><li>如果您希望限制访问，您可以使用防火墙，或者让memcached监听unix domain socket。 </li></ul><h1 id="memcached的多线程是什么？如何使用它们？"><a href="#memcached的多线程是什么？如何使用它们？" class="headerlink" title="memcached的多线程是什么？如何使用它们？"></a>memcached的多线程是什么？如何使用它们？</h1><ul><li>线程就是定律（threads rule）！</li><li>多线程模式允许memcached能够充分利用多个CPU，并在CPU之间共享所有的缓存数据</li><li>memcached使用一种简单的锁机制来保证数据更新操作的互斥</li><li>相比在同一个物理机器上运行多个memcached实例，这种方式能够更有效地处理multi gets。 </li><li>如果您的系统负载并不重，也许您不需要启用多线程工作模式</li><li>如果您在运行一个拥有大规模硬件的、庞大的网站，您将会看到多线程的好处。 </li><li>简单地总结一下：命令解析（memcached在这里花了大部分时间）可以运行在多线程模式下。memcached内部对数据的操作是基于很多全局锁的（因此这部分工作不是多线程的）。未来对多线程模式的改进，将移除大量的全局锁，提高memcached在负载极高的场景下的性能。 </li></ul><h1 id="memcached能接受的key的最大长度是多少？"><a href="#memcached能接受的key的最大长度是多少？" class="headerlink" title="memcached能接受的key的最大长度是多少？"></a>memcached能接受的key的最大长度是多少？</h1><ul><li>key的最大长度是250个字符</li><li>需要注意的是，250是memcached服务器端内部的限制，如果您使用的客户端支持”key的前缀”或类似特性，那么key（前缀+原始key）的最大长度是可以超过250个字符的</li><li>我们推荐使用使用较短的key，因为可以节省内存和带宽。 </li></ul><h1 id="memcached对item的过期时间有什么限制？"><a href="#memcached对item的过期时间有什么限制？" class="headerlink" title="memcached对item的过期时间有什么限制？"></a>memcached对item的过期时间有什么限制？</h1><ul><li>过期时间最大可以达到30天</li><li>memcached把传入的过期时间（时间段）解释成时间点后，一旦到了这个时间点，memcached就把item置为失效状态。 </li></ul><h1 id="memcached最大能存储多大的单个item？"><a href="#memcached最大能存储多大的单个item？" class="headerlink" title="memcached最大能存储多大的单个item？"></a>memcached最大能存储多大的单个item？</h1><ul><li>1MB</li><li>如果你的数据大于1MB，可以考虑在客户端压缩或拆分到多个key中。 </li></ul><h1 id="为什么单个item的大小被限制在1M-byte之内？"><a href="#为什么单个item的大小被限制在1M-byte之内？" class="headerlink" title="为什么单个item的大小被限制在1M byte之内？"></a>为什么单个item的大小被限制在1M byte之内？</h1><ul><li>简单的回答：因为内存分配器的算法就是这样的。 </li><li>详细的回答：Memcached的内存存储引擎（引擎将来可插拔…），使用slabs来管理内存。内存被分成大小不等的slabs chunks（先分成大小相等的slabs，然后每个slab被分成大小相等chunks，不同slab的chunk大小是不相等的）。chunk的大小依次从一个最小数开始，按某个因子增长，直到达到最大的可能值。 </li><li>如果最小值为400B，最大值是1MB，因子是1.20，各个slab的chunk的大小依次是：slab1 – 400B slab2 – 480B slab3 – 576B … </li><li>slab中chunk越大，它和前面的slab之间的间隙就越大。因此，最大值越大，内存利用率越低。Memcached必须为每个slab预先分配内存，因此如果设置了较小的因子和较大的最大值，会需要更多的内存。 </li><li>还有其他原因使得您不要这样向memcached中存取很大的数据…不要尝试把巨大的网页放到mencached中。把这样大的数据结构load和unpack到内存中需要花费很长的时间，从而导致您的网站性能反而不好。 </li><li>如果您确实需要存储大于1MB的数据，你可以修改slabs.c:POWER_BLOCK的值，然后重新编译memcached；或者使用低效的malloc/free。其他的建议包括数据库、MogileFS等。 </li></ul><h1 id="我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？"><a href="#我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？" class="headerlink" title="我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？"></a>我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？</h1><ul><li>Memcache客户端仅根据哈希算法来决定将某个key存储在哪个节点上，而不考虑节点的内存大小</li><li>因此，您可以在不同的节点上使用大小不等的缓存。但是一般都是这样做的：拥有较多内存的节点上可以运行多个memcached实例，每个实例使用的内存跟其他节点上的实例相同。 </li></ul><h1 id="LRU算法，slab分配，如何减少内存碎⽚"><a href="#LRU算法，slab分配，如何减少内存碎⽚" class="headerlink" title="LRU算法，slab分配，如何减少内存碎⽚"></a>LRU算法，slab分配，如何减少内存碎⽚</h1><ul><li>memcached预先将分配的内存分割成各种尺⼨的块(chunk)，并把尺⼨相同的块分成组(chunk的集合)，以此克服内<br>存碎⽚化问题</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/2f1abbd5b4e4.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/2f1abbd5b4e4.html" class="post-title-link" itemprop="url">Mybatis</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:08:45" itemprop="dateCreated datePublished" datetime="2023-12-20T16:08:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-25 11:09:25" itemprop="dateModified" datetime="2023-12-25T11:09:25+08:00">2023-12-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h1><ul><li>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<ul><li>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</li></ul></li><li>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<ul><li>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li></ul></li><li>向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<ul><li>解决：Mybatis自动将java对象映射至sql语句。</li></ul></li><li>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<ul><li>解决：Mybatis自动将sql执行结果映射至java对象。</li></ul></li></ul><h1 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h1><ul><li>创建SqlSessionFactory</li><li>通过SqlSessionFactory创建SqlSession</li><li>通过sqlsession执行数据库操作</li><li>调用session.commit()提交事务</li><li>调用session.close()关闭会话</li></ul><h1 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h1><ul><li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li><li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li><li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li><li>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 </li></ul><h1 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h1><ul><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ul><h1 id="SqlMapConfig-xml中配置有哪些内容？"><a href="#SqlMapConfig-xml中配置有哪些内容？" class="headerlink" title="SqlMapConfig.xml中配置有哪些内容？"></a>SqlMapConfig.xml中配置有哪些内容？</h1><ul><li>SqlMapConfig.xml中配置的内容和顺序如下： <ul><li>properties（属性）</li><li>settings（配置）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environments（环境集合属性对象）</li><li>environment（环境子属性对象）</li><li>transactionManager（事务管理）</li><li>dataSource（数据源）</li><li>mappers（映射器）</li></ul></li></ul><h1 id="简单的说一下MyBatis的一级缓存和二级缓存？"><a href="#简单的说一下MyBatis的一级缓存和二级缓存？" class="headerlink" title="简单的说一下MyBatis的一级缓存和二级缓存？"></a>简单的说一下MyBatis的一级缓存和二级缓存？</h1><ul><li>Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。</li><li>Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象</li><li>Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。</li></ul><h1 id="Mapper编写有哪几种方式？"><a href="#Mapper编写有哪几种方式？" class="headerlink" title="Mapper编写有哪几种方式？"></a>Mapper编写有哪几种方式？</h1><h4 id="接口实现类继承SqlSessionDaoSupport"><a href="#接口实现类继承SqlSessionDaoSupport" class="headerlink" title="接口实现类继承SqlSessionDaoSupport"></a>接口实现类继承SqlSessionDaoSupport</h4><ul><li><p>使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件</p></li><li><p>在sqlMapConfig.xml中配置mapper.xml的位置</p><pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;
    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;
&lt;/mappers&gt;
</code></pre></li><li><p>定义mapper接口</p></li><li><p>实现类集成SqlSessionDaoSupport</p></li><li><p>mapper方法中可以this.getSqlSession()进行数据增删改查。</p></li><li><p>spring 配置</p><pre><code>&lt;bean id=&quot; &quot; class=&quot;mapper接口的实现&quot;&gt;
    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li></ul><h4 id="使用org-mybatis-spring-mapper-MapperFactoryBean"><a href="#使用org-mybatis-spring-mapper-MapperFactoryBean" class="headerlink" title="使用org.mybatis.spring.mapper.MapperFactoryBean"></a>使用org.mybatis.spring.mapper.MapperFactoryBean</h4><ul><li><p>在sqlMapConfig.xml中配置mapper.xml的位置</p></li><li><p>如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置</p><pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;
    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;
&lt;/mappers&gt;
</code></pre></li><li><p>定义mapper接口</p></li><li><p>注意</p><ul><li>mapper.xml中的namespace为mapper接口的地址</li><li>mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</li></ul></li><li><p>Spring中定义</p><pre><code>&lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
    &lt;property name=&quot;mapperInterface&quot;   value=&quot;mapper接口地址&quot; /&gt;  
    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  
4&lt;/bean&gt;
</code></pre></li></ul><h4 id="使用mapper扫描器"><a href="#使用mapper扫描器" class="headerlink" title="使用mapper扫描器"></a>使用mapper扫描器</h4><ul><li><p>mapper.xml文件编写，</p></li><li><p>注意：<br>-mapper.xml中的namespace为mapper接口的地址<br>-mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</p><ul><li>如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置 </li></ul></li><li><p>定义mapper接口</p><ul><li>注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录</li></ul></li><li><p>配置mapper扫描器</p><pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;mapper接口包地址&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; 
&lt;/bean&gt;
</code></pre></li><li><p>使用扫描器后从spring容器中获取mapper的实现对象</p></li><li><p>扫描器将接口通过代理方法生成实现对象，要spring容器中自动注册，名称为mapper 接口的名称。</p></li></ul><h1 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h1><ul><li>#{}是预编译处理，${}是字符串替换。</li><li>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set方法来赋值；</li><li>Mybatis 在处理${}时，就是把${}替换成变量的值。</li><li>使用#{}可以有效的防止 SQL 注入，提高系统安全性。</li></ul><h1 id="通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，"><a href="#通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，" class="headerlink" title="通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，"></a>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，</h1><ul><li>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</li><li>Dao 接口，就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement</li><li>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao 下面 id = findStudentById 的MappedStatement。在 Mybatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个 MappedStatement 对象。</delete></update></insert></select></li><li>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li><li>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement 所代表的 sql，然后将 sql 执行结果返回。</li></ul><h1 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><ul><li>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</li><li>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</li></ul><h1 id="Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><ul><li>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系</resultmap></li><li>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</li></ul><h1 id="Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h1><ul><li>注：这道题出自京东面试官。</li><li>还有很多其他的标签，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中为sql片段标签，通过标签引入 sql 片段，为不支持自增的主键生成策略标签。</li></ul><h1 id="简述-Mybatis-的插件运行原理，以及如何编写一个插件"><a href="#简述-Mybatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述 Mybatis 的插件运行原理，以及如何编写一个插件"></a>简述 Mybatis 的插件运行原理，以及如何编写一个插件</h1><ul><li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li><li>实现 Mybatis 的 Interceptor 接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</li></ul><h1 id="一级、二级缓存"><a href="#一级、二级缓存" class="headerlink" title="一级、二级缓存"></a>一级、二级缓存</h1><ul><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如Ehcache</li><li>要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：<cache></li><li>对于缓存数据更新机制，当某一个作用域(一级缓存Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ul><h1 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><ul><li>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载</li><li>association 指的就是一对一，collection 指的就是一对多查询</li><li>在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。</li><li>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li></ul><h1 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h1><ul><li>虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。</li><li>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</li></ul><h1 id="简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h1><ul><li>Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部</li><li>在 Xml 映射文件中，<parametermap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultmap>标签会被解析为ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。</delete></update></insert></select></resultmap></parametermap></li></ul><h1 id="ibatis-中的-与-的区别"><a href="#ibatis-中的-与-的区别" class="headerlink" title="ibatis 中的#与$的区别"></a>ibatis 中的#与$的区别</h1><ul><li>#是把传入的数据当作字符串，如#field#传入的是id,则sql语句生成是这样，order by “id”,这当然会报错．．</li><li>$传入的数据直接生成在sql里，如#field#传入的是id,则sql语句生成是这样，order by id, 这就对了．</li><li>#方式能够很大程度防止sql注入．</li><li>$方式无法方式sql注入．</li><li>$方式一般用于传入数据库对象．例如传入表名.</li><li>一般能用#的就别用$.</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/b318dfbd2190.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/b318dfbd2190.html" class="post-title-link" itemprop="url">Netty</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:07:22" itemprop="dateCreated datePublished" datetime="2023-12-20T16:07:22+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-25 13:04:15" itemprop="dateModified" datetime="2023-12-25T13:04:15+08:00">2023-12-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="BIO、NIO和AIO的区别？"><a href="#BIO、NIO和AIO的区别？" class="headerlink" title="BIO、NIO和AIO的区别？"></a>BIO、NIO和AIO的区别？</h1><ul><li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</li><li>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</li><li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li><li>AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的。</li><li>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。</li><li>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作</li><li>如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul><h1 id="NIO的组成"><a href="#NIO的组成" class="headerlink" title="NIO的组成"></a>NIO的组成</h1><ul><li>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</li><li>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</li><li>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。</li><li>rewind方法 ： 重绕此缓冲区，将position置为0</li><li>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</li><li>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！</li><li>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</li><li>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</li><li>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</li><li>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取</li><li>NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</li></ul><h1 id="Netty的特点？"><a href="#Netty的特点？" class="headerlink" title="Netty的特点？"></a>Netty的特点？</h1><ul><li>一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持</li><li>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。</li><li>采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理</li><li>可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持</li><li>可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf</li><li>通过引用计数器及时申请释放不再引用的对象，降低了GC频率</li><li>使用单线程串行化的方式，高效的Reactor线程模型</li><li>大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用</li></ul><h1 id="Netty的线程模型？"><a href="#Netty的线程模型？" class="headerlink" title="Netty的线程模型？"></a>Netty的线程模型？</h1><ul><li>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池</li><li>其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池</li><li>其中work线程池负责请求的read和write事件，由对应的Handler处理。</li></ul><h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><ul><li>所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的</li><li>既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息</li><li>一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul><li>有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求</li><li>NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送</li><li>1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题</li><li>但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</li></ul><h4 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h4><ul><li>Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；</li></ul><h1 id="TCP-粘包-拆包的原因及解决方法？"><a href="#TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="TCP 粘包/拆包的原因及解决方法？"></a>TCP 粘包/拆包的原因及解决方法？</h1><ul><li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li></ul><h4 id="TCP粘包-分包的原因："><a href="#TCP粘包-分包的原因：" class="headerlink" title="TCP粘包/分包的原因："></a>TCP粘包/分包的原因：</h4><ul><li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象</li><li>而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</li><li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li><li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>消息定长：FixedLengthFrameDecoder类</li><li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</li><li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li></ul><h1 id="了解哪几种序列化协议？"><a href="#了解哪几种序列化协议？" class="headerlink" title="了解哪几种序列化协议？"></a>了解哪几种序列化协议？</h1><ul><li>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；</li><li>反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</li><li>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</li></ul><h4 id="Java默认提供的序列化"><a href="#Java默认提供的序列化" class="headerlink" title="Java默认提供的序列化"></a>Java默认提供的序列化</h4><ul><li>无法跨语言、序列化后的码流太大、序列化的性能差</li></ul><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><ul><li>优点：人机可读性好，可指定元素或特性的名称</li><li>缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽</li><li>适用场景：当做配置文件存储数据，实时数据转换。</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul><li>是一种轻量级的数据交换格式</li><li>优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快</li><li>缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大</li><li>适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li></ul><h4 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h4><ul><li>采用一种“假定有序快速匹配”的算法</li><li>优点：接口简单易用、目前java语言中最快的json库</li><li>缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全</li><li>适用场景：协议交互、Web输出、Android客户端</li></ul><h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><ul><li>不仅是序列化协议，还是一个RPC框架</li><li>优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码</li><li>缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议</li><li>适用场景：分布式系统的RPC解决方案</li></ul><h4 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h4><ul><li>Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题</li><li>优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现</li><li>缺点：对于习惯于静态类型语言的用户不直观</li><li>适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</li></ul><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><ul><li>将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性</li><li>优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护</li><li>缺点：需要依赖于工具生成代码、支持的语言相对较少</li><li>适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可</li><li>Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口</li><li>Message pack 一个高效的二进制序列化格式</li><li>Hessian 采用二进制协议的轻量级remoting onhttp工具</li><li>kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）</li></ul><h1 id="如何选择序列化协议？"><a href="#如何选择序列化协议？" class="headerlink" title="如何选择序列化协议？"></a>如何选择序列化协议？</h1><h4 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h4><ul><li>对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。</li><li>基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选</li><li>对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</li><li>对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</li><li>当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</li><li>对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。</li><li>对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯</li><li>由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</li><li>如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</li><li>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</li><li>protobuf的数据类型有多种<ul><li>bool、double、float、int32、int64、string、bytes、enum、message</li><li>protobuf的限定符：<ul><li>required: 必须赋值，不能为空</li><li>optional:字段可以赋值，也可以不赋值</li><li>repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；</li></ul></li></ul></li></ul><h4 id="protobuf的基本规则"><a href="#protobuf的基本规则" class="headerlink" title="protobuf的基本规则"></a>protobuf的基本规则</h4><ul><li>每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段</li><li>repeated表示的字段可以包含0个或多个数据</li><li>[1,15]之内的标识号在编码的时候会占用一个字节（常用）</li><li>[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。</li><li>protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。</li><li>编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder = UserProto.User.newBuilder();builder.build()；</li><li>Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类</li><li>将StringBuilder转换为ByteBuf类型：copiedBuffer()方法</li></ul><h1 id="Netty的零拷贝实现？"><a href="#Netty的零拷贝实现？" class="headerlink" title="Netty的零拷贝实现？"></a>Netty的零拷贝实现？</h1><ul><li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝</li><li>堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中</li><li>ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li><li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer</li><li>addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li><li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li><li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</li><li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li><li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。</li></ul><h1 id="Netty的高性能表现在哪些方面？"><a href="#Netty的高性能表现在哪些方面？" class="headerlink" title="Netty的高性能表现在哪些方面？"></a>Netty的高性能表现在哪些方面？</h1><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><ul><li>对服务端：会定时清除闲置会话inactive(netty5)</li><li>对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态</li></ul><h4 id="串行无锁化设计"><a href="#串行无锁化设计" class="headerlink" title="串行无锁化设计"></a>串行无锁化设计</h4><ul><li>即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁</li><li>表面上看，串行化设计似乎CPU利用率不高，并发程度不够</li><li>但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</li></ul><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul><li>链路有效性检测：链路空闲检测机制，读/写空闲超时机制</li><li>内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护</li><li>优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</li></ul><h4 id="Netty安全性"><a href="#Netty安全性" class="headerlink" title="Netty安全性"></a>Netty安全性</h4><ul><li>支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。</li></ul><h4 id="高效并发编程的体现"><a href="#高效并发编程的体现" class="headerlink" title="高效并发编程的体现"></a>高效并发编程的体现</h4><ul><li>volatile的大量、正确使用</li><li>CAS和原子类的广泛使用</li><li>线程安全容器的使用</li><li>通过读写锁提升并发性能</li><li>IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）</li></ul><h4 id="流量整型的作用（变压器）"><a href="#流量整型的作用（变压器）" class="headerlink" title="流量整型的作用（变压器）"></a>流量整型的作用（变压器）</h4><ul><li>防止由于上下游网关性能不均衡导致下游网关被压垮，业务流中断</li><li>防止由于通信模块接收消息过快，后端业务线程处理不及时导致撑死问题。</li></ul><h4 id="TCP参数配置"><a href="#TCP参数配置" class="headerlink" title="TCP参数配置"></a>TCP参数配置</h4><ul><li>SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K</li><li>SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率</li><li>但是对于时延敏感的应用场景需要关闭该优化算法；</li></ul><h1 id="NIOEventLoopGroup源码？"><a href="#NIOEventLoopGroup源码？" class="headerlink" title="NIOEventLoopGroup源码？"></a>NIOEventLoopGroup源码？</h1><ul><li>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。</li><li>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素</li><li>如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回</li><li>如果taskQueue没有元素，执行 select(oldWakenUp) 方法</li><li>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。</li><li>rebuildSelector方法先通过openSelector方法创建一个新的selector</li><li>然后将old selector的selectionKey执行cancel</li><li>最后将old selector的channel重新注册到新的selector中</li><li>rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</li><li>接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。</li><li>最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。</li><li>每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。</li><li>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head</li><li>Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。</li></ul><h4 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h4><ul><li>首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成</li><li>Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址</li><li>当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了</li><li>大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。</li></ul><h4 id="ByteBuf的特点"><a href="#ByteBuf的特点" class="headerlink" title="ByteBuf的特点"></a>ByteBuf的特点</h4><ul><li>支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）</li><li>不需要调用flip()来切换读/写模式，读取和写入索引分开</li><li>方法链</li><li>引用计数基于AtomicIntegerFieldUpdater用于内存回收</li><li>PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象</li><li>UnpooledHeapByteBuf每次都会新建一个缓冲区对象。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/0777702c9d7f.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/0777702c9d7f.html" class="post-title-link" itemprop="url">RPC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:06:30" itemprop="dateCreated datePublished" datetime="2023-12-20T16:06:30+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 16:13:22" itemprop="dateModified" datetime="2023-12-24T16:13:22+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rpc/" itemprop="url" rel="index"><span itemprop="name">rpc</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h1><ul><li>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。</li><li>当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。</li><li>除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</li><li>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。</li><li>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</li><li>RPC 在我们熟知的各种中间件中都有它的身影。</li><li>Nginx/Redis/MySQL/Dubbo/Hadoop/Spark/Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的</li><li>我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。</li></ul><h1 id="Nginx-与-RPC"><a href="#Nginx-与-RPC" class="headerlink" title="Nginx 与 RPC"></a>Nginx 与 RPC</h1><ul><li>Ngnix 是互联网企业使用最为广泛的代理服务器。</li><li>它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务</li><li>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互</li><li>也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。</li><li>你说的没错，不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</li><li>uWSGI 是著名的 Python 容器，使用它可以启动 uwsgi 协议的服务器对外提供服务。</li><li>uwsgi 通讯协议在 Python 语言体系里使用非常普遍，如果一个企业内部使用 Python 语言栈搭建 Web 服务，那么他们在生产环境部署 Python 应用的时候不是在使用 HTTP 协议就是在使用 uwsgi 协议来和 Nginx 之间建立通讯。</li><li>Fastcgi 协议在 PHP 语言体系里非常常见，Nginx 和 PHP-fpm 进程之间一般较常使用 Fastcgi 协议进行通讯。</li></ul><h1 id="Hadoop-与-RPC"><a href="#Hadoop-与-RPC" class="headerlink" title="Hadoop 与 RPC"></a>Hadoop 与 RPC</h1><ul><li>在大数据技术领域，RPC 也占据了非常重要的地位</li><li>大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在</li><li>大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。</li><li>比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</li></ul><h1 id="TensorFlow-与-RPC"><a href="#TensorFlow-与-RPC" class="headerlink" title="TensorFlow 与 RPC"></a>TensorFlow 与 RPC</h1><ul><li>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯</li><li>Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</li></ul><h1 id="Http-与-RPC"><a href="#Http-与-RPC" class="headerlink" title="Http 与 RPC"></a>Http 与 RPC</h1><ul><li>HTTP 调用其实也是一种特殊的 RPC</li><li>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。</li><li>HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</li><li>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了</li><li>所以在后文我们不再明确强调 RPC 和 HTTP 请求调用之间的细微区别了，直接统一称之为 RPC。</li></ul><h1 id="HTTP-VS-RPC-（普通话-VS-方言）"><a href="#HTTP-VS-RPC-（普通话-VS-方言）" class="headerlink" title="HTTP VS RPC （普通话 VS 方言）"></a>HTTP VS RPC （普通话 VS 方言）</h1><ul><li>HTTP 与 RPC 的关系就好比普通话与方言的关系</li><li>要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本</li><li>但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源</li><li>整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。</li><li>如果再深入一点说，普通话本质上也是一种方言，只不过它是官方的方言，使用最为广泛的方言，相比而言其它方言都是小语种，小语种之中也会有几个使用比较广泛比较特色的方言占比也会比较大。</li><li>这就好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</li></ul><h1 id="换个角度看世界"><a href="#换个角度看世界" class="headerlink" title="换个角度看世界"></a>换个角度看世界</h1><ul><li>分布式子系统交互方案，除了 RPC 技术之外还有数据库、消息队列和缓存。但其实这三者本质上是 RPC 技术的一个应用组合。</li><li>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。</li><li>如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL</li><li>在互联网企业里一般都会使用这种主从读写分离的数据库</li><li>一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来</li><li>这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/235b69f65d9c.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/235b69f65d9c.html" class="post-title-link" itemprop="url">Spring MVC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:05:16" itemprop="dateCreated datePublished" datetime="2023-12-20T16:05:16+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-27 16:25:51" itemprop="dateModified" datetime="2023-12-27T16:25:51+08:00">2023-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring-MVC/" itemprop="url" rel="index"><span itemprop="name">Spring MVC</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是SpringMvc？"><a href="#什么是SpringMvc？" class="headerlink" title="什么是SpringMvc？"></a>什么是SpringMvc？</h1><ul><li>SpringMvc是spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。</li></ul><h1 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h1><ul><li>它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成. </li><li>不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的) </li><li>可以任意使用各种视图技术,而不仅仅局限于JSP </li><li>支持各种请求资源的映射策略 </li><li>它应是易于扩展的</li></ul><h1 id="SpringMVC工作原理？"><a href="#SpringMVC工作原理？" class="headerlink" title="SpringMVC工作原理？"></a>SpringMVC工作原理？</h1><h4 id="简要回答"><a href="#简要回答" class="headerlink" title="简要回答"></a>简要回答</h4><ul><li>客户端发送请求到DispatcherServlet </li><li>DispatcherServlet查询handlerMapping找到处理请求的Controller </li><li>Controller调用业务逻辑后，返回ModelAndView </li><li>DispatcherServlet查询ModelAndView，找到指定视图 </li><li>视图将结果返回到客户端</li></ul><h4 id="详细回答"><a href="#详细回答" class="headerlink" title="详细回答"></a>详细回答</h4><ul><li>用户发送请求至前端控制器DispatcherServlet。 </li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li><li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li><li>Controller执行完成返回ModelAndView。 </li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 </li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li><li>ViewReslover解析后返回具体View。 </li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li><li>DispatcherServlet响应用户。</li></ul><h4 id="详细回答2"><a href="#详细回答2" class="headerlink" title="详细回答2"></a>详细回答2</h4><ul><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter处理器适配器</li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户</li></ul><h1 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h1><ul><li><p>在web.xml中加入：</p><pre><code>&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre></li><li><p>以上可以解决post请求乱码问题</p></li><li><p>对于get请求中文参数出现乱码解决方法有两个：</p><ul><li><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p><pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;
</code></pre></li><li><p>另外一种方法对参数进行重新编码：</p><pre><code>String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)
</code></pre></li></ul></li><li><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p></li></ul><h1 id="SpringMVC与Struts2的主要区别？"><a href="#SpringMVC与Struts2的主要区别？" class="headerlink" title="SpringMVC与Struts2的主要区别？"></a>SpringMVC与Struts2的主要区别？</h1><ul><li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li><li>springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li><li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。Jsp视图解析器默认使用jstl。</li><li>springmvc是基于方法开发，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li></ul><h1 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h1><ul><li>是单例模式</li><li>所以在多线程访问的时候有线程安全问题</li><li>不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</li></ul><h1 id="SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</h1><ul><li>一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。</li></ul><h1 id="RequestMapping注解用在类上面有什么作用？"><a href="#RequestMapping注解用在类上面有什么作用？" class="headerlink" title="@RequestMapping注解用在类上面有什么作用？"></a>@RequestMapping注解用在类上面有什么作用？</h1><ul><li>是一个用来处理请求地址映射的注解，可用于类或方法上</li><li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li></ul><h1 id="怎么样把某个请求映射到特定的方法上面？"><a href="#怎么样把某个请求映射到特定的方法上面？" class="headerlink" title="怎么样把某个请求映射到特定的方法上面？"></a>怎么样把某个请求映射到特定的方法上面？</h1><ul><li>直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径</li></ul><h1 id="如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？"><a href="#如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？" class="headerlink" title="如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？"></a>如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？</h1><ul><li>可以在@RequestMapping注解里面加上method=RequestMethod.GET</li></ul><h1 id="怎么样在方法里面得到Request-或者Session？"><a href="#怎么样在方法里面得到Request-或者Session？" class="headerlink" title="怎么样在方法里面得到Request,或者Session？"></a>怎么样在方法里面得到Request,或者Session？</h1><ul><li>直接在方法的形参中声明request,SpringMvc就自动把request对象传入</li></ul><h1 id="我想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#我想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="我想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>我想在拦截的方法里面得到从前台传入的参数,怎么得到？</h1><ul><li>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样</li></ul><h1 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h1><ul><li>直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</li></ul><h1 id="SpringMvc中函数的返回值是什么？"><a href="#SpringMvc中函数的返回值是什么？" class="headerlink" title="SpringMvc中函数的返回值是什么？"></a>SpringMvc中函数的返回值是什么？</h1><ul><li>返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。</li></ul><h1 id="SpringMVC怎么样设定重定向和转发的？"><a href="#SpringMVC怎么样设定重定向和转发的？" class="headerlink" title="SpringMVC怎么样设定重定向和转发的？"></a>SpringMVC怎么样设定重定向和转发的？</h1><ul><li>在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name=method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a></li></ul><h1 id="SpringMvc用什么对象从后台向前台传递数据的？"><a href="#SpringMvc用什么对象从后台向前台传递数据的？" class="headerlink" title="SpringMvc用什么对象从后台向前台传递数据的？"></a>SpringMvc用什么对象从后台向前台传递数据的？</h1><ul><li>通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。</li></ul><h1 id="SpringMvc中有个类把视图和数据都合并的一起的-叫什么？"><a href="#SpringMvc中有个类把视图和数据都合并的一起的-叫什么？" class="headerlink" title="SpringMvc中有个类把视图和数据都合并的一起的,叫什么？"></a>SpringMvc中有个类把视图和数据都合并的一起的,叫什么？</h1><ul><li>叫ModelAndView。</li></ul><h1 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h1><ul><li>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key</li></ul><h1 id="SpringMvc怎么和AJAX相互调用的？"><a href="#SpringMvc怎么和AJAX相互调用的？" class="headerlink" title="SpringMvc怎么和AJAX相互调用的？"></a>SpringMvc怎么和AJAX相互调用的？</h1><ul><li>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。 </li><li>具体步骤如下 ：<ul><li>加入Jackson.jar </li><li>在配置文件中配置json的映射 </li><li>在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</li></ul></li></ul><h1 id="当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？"><a href="#当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？" class="headerlink" title="当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？"></a>当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</h1><ul><li>要加上@ResponseBody注解</li></ul><h1 id="SpringMvc里面拦截器是怎么写的"><a href="#SpringMvc里面拦截器是怎么写的" class="headerlink" title="SpringMvc里面拦截器是怎么写的"></a>SpringMvc里面拦截器是怎么写的</h1><ul><li>有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可： <pre><code>&lt;!-- 配置SpringMvc的拦截器 --&gt;
&lt;mvc:interceptors&gt;    
  &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;   
  &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.et.action.MyHandlerInterceptor&quot;&gt;&lt;/bean&gt;    
  &lt;!-- 只针对部分请求拦截 --&gt;    
  &lt;mvc:interceptor&gt;       
      &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;       
      &lt;bean class=&quot;com.et.action.MyHandlerInterceptorAdapter&quot; /&gt;  
  &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre></li></ul><h1 id="讲下SpringMvc的执行流程"><a href="#讲下SpringMvc的执行流程" class="headerlink" title="讲下SpringMvc的执行流程"></a>讲下SpringMvc的执行流程</h1><ul><li>系统启动的时候根据配置文件创建spring的容器</li><li>首先是发送http请求到核心控制器disPatherServlet</li><li>spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类</li><li>在进业务类时进行数据封装，在封装前可能会涉及到类型转换</li><li>执行完业务类后使用ModelAndView进行视图转发</li><li>数据放在model中，用map传递数据进行页面显示</li></ul><h1 id="框架的优缺点SpringMVC-Struts2等…"><a href="#框架的优缺点SpringMVC-Struts2等…" class="headerlink" title="框架的优缺点SpringMVC,Struts2等…"></a>框架的优缺点SpringMVC,Struts2等…</h1><ul><li>Struts2是类级别拦截，参数为类中所有⽅法共有，⼀个Action对应⼀个request上下⽂，SpringMVC是⽅法级别拦截，参数为对应⽅法所有；</li><li>由于Struts2需要针对每个request进⾏封装，把request，session等servlet⽣命周期的变量封装成⼀个⼀个Map，供给每个Action使⽤，并保证线程安全，所以在原则上，是⽐较耗费内存的。</li><li>拦截器实现机制上，Struts2有以⾃⼰的interceptor机制，SpringMVC⽤的是独⽴的AOP⽅式，这样导致Struts2的配置⽂件量还是⽐SpringMVC⼤。</li><li>SpringMVC的⼊⼝是servlet，⽽Struts2是filter</li><li>SpringMVC集成了Ajax，使⽤⾮常⽅便，只需⼀个注解@ResponseBody就可以实现，然后直接返回响应⽂本即可，⽽Struts2拦截器集成了Ajax，在Action中处理时⼀般必须安装插件或者⾃⼰写代码集成进去，使⽤起来也相对不⽅便。</li><li>SpringMVC开发效率和性能⾼于Struts2。</li><li>SpringMVC配置少，零配置。</li></ul><h1 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h1><ul><li>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序</li><li>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/c9fa4a3e43dd.html" class="post-title-link" itemprop="url">Spring</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:03:58" itemprop="dateCreated datePublished" datetime="2023-12-20T16:03:58+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-27 17:13:50" itemprop="dateModified" datetime="2023-12-27T17:13:50+08:00">2023-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><ul><li>AOP(Aspect-Oriented Programming), 即 面向切面编程</li><li>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题</li><li>这些交叉问题与应用程序的主要业务逻辑不同</li><li>因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。</li></ul><h1 id="Spring中Bean的⽣命周期。"><a href="#Spring中Bean的⽣命周期。" class="headerlink" title="Spring中Bean的⽣命周期。"></a>Spring中Bean的⽣命周期。</h1><ul><li>Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅法-》调⽤InitializationBean的afterPropertiesSet()的⽅法-》调⽤定制的初始化⽅法callCustom的init-method-》调⽤BeanPostProsessor的后初始化⽅法-》Bean可以使⽤了 -》 容器关闭-》 调⽤DisposableBean的destroy⽅法-》调⽤定制的销毁⽅法CallCustom的destroy-method。</li><li>Spring对Bean进⾏实例化（相当于程序中的new Xx()）</li><li>Spring将值和Bean的引⽤注⼊进Bean对应的属性中</li><li>如果Bean实现了BeanNameAware接⼝，Spring将Bean的ID传递给setBeanName()⽅法（实现BeanNameAware清主要是为了通过Bean的引⽤来获得Bean的ID，⼀般业务中是很少有⽤到Bean的ID的）</li><li>如果Bean实现了BeanFactoryAware接⼝，Spring将调⽤setBeanDactory(BeanFactory bf)⽅法并把BeanFactory容器实例作为参数传⼊。（实现BeanFactoryAware 主要⽬的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</li><li>如果Bean实现了ApplicationContextAwaer接⼝，Spring容器将调⽤setApplicationContext(ApplicationContext ctx)⽅法，把y应⽤上下⽂作为参数传⼊.(作⽤与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调⽤setApplicationContext⽅法时会把它⾃⼰作为setApplicationContext 的参数传⼊，⽽Spring容器在调⽤setBeanDactory前需要程序员⾃⼰指定（注⼊）setBeanDactory⾥的参数BeanFactory )</li><li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessBeforeInitialization（预初始化）⽅法（作⽤是在Bean实例创建成功后对进⾏增强处理，如对Bean进⾏修改，增加某个功能）7.如果Bean实现了InitializingBean接⼝，Spring将调⽤它们的afterPropertiesSet⽅法，作⽤与在配置⽂件中对Bean使⽤init-method声明初始化的作⽤⼀样，都是在Bean的全部属性设置成功后执⾏的初始化⽅法。</li><li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessAfterInitialization（后初始化）⽅法（作⽤与7的⼀样，只不过7是在Bean初始化前执⾏的，⽽这个是在Bean初始化后执⾏的，时机不同 ）</li><li>经过以上的⼯作后，Bean将⼀直驻留在应⽤上下⽂中给应⽤使⽤，直到应⽤上下⽂被销毁</li><li>如果Bean实现了DispostbleBean接⼝，Spring将调⽤它的destory⽅法，作⽤与在配置⽂件中对Bean使⽤destory￾method属性的作⽤⼀样，都是在Bean实例销毁前执⾏的⽅法。</li></ul><h1 id="Spring-AOP解决了什么问题？怎么实现的？"><a href="#Spring-AOP解决了什么问题？怎么实现的？" class="headerlink" title="Spring AOP解决了什么问题？怎么实现的？"></a>Spring AOP解决了什么问题？怎么实现的？</h1><ul><li>作⽤<ul><li>AOP技术，利⽤⼀种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共⾏为封装到⼀个可重⽤模块，并将其名为“Aspect”，即⽅⾯</li><li>所谓“⽅⾯”，简单地说，就是将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li></ul></li><li>实现：<ul><li>⼀是采⽤动态代理技术，利⽤截取消息的⽅式，对该消息进⾏装饰，以取代原有对象⾏为的执⾏；</li><li>⼆是采⽤静态织⼊的⽅式，引⼊特定的语法创建“⽅⾯”，从⽽使得编译器可以在编译期间织⼊有关“⽅⾯”的代码。</li></ul></li><li>使⽤场景：<ul><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading　懒加载</li><li>Debugging　　调试</li><li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li><li>Performance optimization　性能优化</li><li>Persistence　　持久化</li><li>Resource pooling　资源池</li><li>Synchronization　同步</li><li>Transactions 事务</li></ul></li><li>⼏个概念：<ul><li>切⾯（Aspect）：对象操作过程中的截⾯，这可能是AOP中最为关键的术语。切⾯所要做的事就是专注于各⾃领域的逻辑实现，这样可以使得开发逻辑更加清晰，更加适合专业的分⼯合作。由于切⾯的隔离性，降低了耦合，这样就可以在不同的应⽤中将各个切⾯组合使⽤，从⽽是代码重⽤性⼤⼤增加。</li><li>连接点：程序运⾏过程中的某个阶段点，如某个⽅法的调⽤，或者异常的抛出。</li><li>处理逻辑（Advice）：在某⼀个连接点所采⽤的处理逻辑，处理逻辑的调⽤模式通常有三种：<ul><li>Around 在连接点前后插⼊预处理过程和后处理过程。</li><li>Before 仅在连接点钱出⼊处理过程。</li><li>Throw 在连接点抛出异常时进⾏异常处理。</li></ul></li><li>切点（PointCut）：⼀系列连接点的集合，它指明处理逻辑将在合适触发。</li></ul></li></ul><h1 id="Spring事务的传播属性是怎么回事？它会影响什么？"><a href="#Spring事务的传播属性是怎么回事？它会影响什么？" class="headerlink" title="Spring事务的传播属性是怎么回事？它会影响什么？"></a>Spring事务的传播属性是怎么回事？它会影响什么？</h1><ul><li>七个事务传播属性：<ul><li>PROPAGATION_REQUIRED – ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。</li><li>PROPAGATION_SUPPORTS – ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</li><li>PROPAGATION_MANDATORY – ⽀持当前事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATIONREQUIRESNEW – 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATIONNOTSUPPORTED – 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER – 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</li><li>PROPAGATIONNESTED – 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与PROPAGATIONREQUIRED类似的操作。</li></ul></li><li>五个隔离级别：<ul><li>ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.</li><li>另外四个与JDBC的隔离级别相对应：<ul><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种隔离级别会产⽣脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不可重复读外，还避免了幻读。</li></ul></li></ul></li><li>关键词：<ul><li>幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；</li><li>不可重复读：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；</li><li>脏读：事务1更新了记录，但没有提交，事务2读取了更新后的⾏，然后事务T1回滚，现在T2读取⽆效。</li></ul></li></ul><h1 id="Spring中BeanFactory和FactoryBean有什么区别？"><a href="#Spring中BeanFactory和FactoryBean有什么区别？" class="headerlink" title="Spring中BeanFactory和FactoryBean有什么区别？"></a>Spring中BeanFactory和FactoryBean有什么区别？</h1><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul><li>以Factory结尾，表示它是⼀个⼯⼚类(接⼝)，⽤于管理Bean的⼀个⼯⼚</li><li>在Spring中，BeanFactory是IOC容器的核⼼接⼝，它的职责包括：实例化、定位、配置应⽤程序中的对象及建⽴这些对象间的依赖。</li></ul><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><ul><li>以Bean结尾，表示它是⼀个Bean，不同于普通Bean的是：它是实现了FactoryBean接⼝的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽不是FactoryBean本身</li><li>如果要获取FactoryBean对象，请在id前⾯加⼀个&amp;符号来获取。</li></ul><h1 id="Spring框架中IOC的原理是什么？"><a href="#Spring框架中IOC的原理是什么？" class="headerlink" title="Spring框架中IOC的原理是什么？"></a>Spring框架中IOC的原理是什么？</h1><ul><li>IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。</li><li>在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</li><li>在系统运⾏中，动态的向某个对象提供它所需要的其他对象。</li><li>依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li></ul><h1 id="spring的依赖注⼊有哪⼏种⽅式"><a href="#spring的依赖注⼊有哪⼏种⽅式" class="headerlink" title="spring的依赖注⼊有哪⼏种⽅式"></a>spring的依赖注⼊有哪⼏种⽅式</h1><ul><li>在Spring容器中为⼀个bean配置依赖注⼊有四种⽅式：<ul><li>使⽤属性的setter⽅法注⼊ 这是最常⽤的⽅式；</li><li>使⽤构造器注⼊；</li><li>使⽤Filed注⼊（⽤于注解⽅式）.</li><li>静态、实例⼯⼚的⽅法注⼊</li></ul></li></ul><h1 id="⽤Spring如何实现⼀个切⾯？"><a href="#⽤Spring如何实现⼀个切⾯？" class="headerlink" title="⽤Spring如何实现⼀个切⾯？"></a>⽤Spring如何实现⼀个切⾯？</h1><ul><li>@Aspect</li></ul><h1 id="Spring如何实现数据库事务？"><a href="#Spring如何实现数据库事务？" class="headerlink" title="Spring如何实现数据库事务？"></a>Spring如何实现数据库事务？</h1><ul><li>使⽤@Transactional注解或在配置⽂件⾥⾯配置</li></ul><h1 id="Spring加载次序Classloader"><a href="#Spring加载次序Classloader" class="headerlink" title="Spring加载次序Classloader"></a>Spring加载次序Classloader</h1><ul><li>先构造函数——&gt;然后是bean的set⽅法注⼊——&gt;InitializingBean的afterPropertiesSet⽅法——&gt;init-method⽅法；</li><li>InitializingBean接⼝为bean提供了初始化⽅法的⽅式，它只包括afterPropertiesSet⽅法，凡是继承该接⼝的类，在初始化bean的时候会执⾏该⽅法。系统则是先调⽤afterPropertiesSet⽅法，然后在调⽤init-method中指定的⽅法。</li><li>Spring装配Bean的过程：<ul><li>实例化;</li><li>设置属性值;</li><li>如果实现了BeanNameAware接⼝,调⽤setBeanName设置Bean的ID或者Name;</li><li>如果实现BeanFactoryAware接⼝,调⽤setBeanFactory 设置BeanFactory;</li><li>如果实现ApplicationContextAware,调⽤setApplicationContext设置ApplicationContext</li><li>调⽤BeanPostProcessor的预先初始化⽅法;</li><li>调⽤InitializingBean的afterPropertiesSet()⽅法;</li><li>调⽤定制init-method⽅法；</li><li>调⽤BeanPostProcessor的后初始化⽅法;</li></ul></li><li>Spring容器关闭过程：<ul><li>调⽤DisposableBean的destroy();</li><li>调⽤定制的destroy-method⽅法;</li></ul></li></ul><h1 id="IOC控制反转与DI依赖注⼊"><a href="#IOC控制反转与DI依赖注⼊" class="headerlink" title="IOC控制反转与DI依赖注⼊"></a>IOC控制反转与DI依赖注⼊</h1><ul><li>IOC控制反转：是⼀种将对象交给容器去控制的设计思想，松耦合，⽅便单元测试，增加功能重⽤性；</li><li>DI依赖注⼊：组件之间依赖关系由容器在运⾏期决定，形象的说，即由容器动态的将某个依赖关系注⼊到组件之中。依赖注⼊的⽬的并⾮为软件系统带来更多功能，⽽是为了提升组件重⽤的频率，并为系统搭建⼀个灵活、可扩展的平台。通过依赖注⼊机制，我们只需要通过简单的配置，⽽⽆需任何代码就可指定⽬标需要的资源，完成⾃身的业务逻辑，⽽不需要关⼼具体的资源来⾃何处，由谁实现。</li><li>AOP⾯向切⾯编程：⾯向切⾯编程（AOP）完善spring的依赖注⼊（DI）。</li></ul><h1 id="spring事件的实现原理，写出常⽤的⼏个事件。"><a href="#spring事件的实现原理，写出常⽤的⼏个事件。" class="headerlink" title="spring事件的实现原理，写出常⽤的⼏个事件。"></a>spring事件的实现原理，写出常⽤的⼏个事件。</h1><ul><li>事件机制：Spring中的事件机制是⼀个观察者模式的实现，观察者模式就是⼀个⽬标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。</li><li>spring默认存在的事件：<ul><li>ContextStartedEvent：ApplicationContext启动后触发的事件</li><li>ContextStoppedEvent：ApplicationContext停⽌后触发的事件</li><li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件</li><li>ContextClosedEvent：ApplicationContext关闭后触发的事件</li></ul></li></ul><h1 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h1><ul><li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li><li>它是轻量级、松散耦合的。</li><li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li><li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li></ul><h1 id="列举-Spring-Framework-的优点"><a href="#列举-Spring-Framework-的优点" class="headerlink" title="列举 Spring Framework 的优点"></a>列举 Spring Framework 的优点</h1><ul><li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li><li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li><li>由于依赖注入和控制反转，JDBC 得以简化。</li><li>它是开源免费的。</li></ul><h1 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h1><ul><li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li><li>IOC - 控制反转</li><li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li><li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li><li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li><li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li><li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li></ul><h1 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h1><ul><li>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：<ul><li>Spring Core</li><li>Spring Bean</li><li>SpEL (Spring Expression Language)</li><li>Spring Context</li></ul></li><li>数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：<ul><li>JDBC (Java DataBase Connectivity)</li><li>ORM (Object Relational Mapping)</li><li>OXM (Object XML Mappers)</li><li>JMS (Java Messaging Service)</li><li>Transaction</li></ul></li><li>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<ul><li>Web</li><li>Web – Servlet</li><li>Web – Socket</li><li>Web – Portlet</li></ul></li><li>AOP – 该层支持面向切面编程<ul><li>Instrumentation – 该层为类检测和类加载器实现提供支持。</li><li>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</li></ul></li><li>几个杂项模块:<ul><li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li><li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li></ul></li></ul><h1 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h1><ul><li>Spring 配置文件是 XML 文件</li><li>该文件主要包含类信息</li><li>它描述了这些类是如何配置以及相互引入的</li><li>但是，XML 配置文件冗长且更加干净</li><li>如果没有正确规划和编写，那么在大项目中管理变得非常困难。</li></ul><h1 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h1><ul><li>接口 - 定义功能。</li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li><li>用户程序 - 它使用接口。</li></ul><h1 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h1><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>用于远程使用。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li></ul><h1 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h1><ul><li>Spring 框架的核心是 Spring 容器</li><li>容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期</li><li>Spring 容器使用依赖注入来管理组成应用程序的组件</li><li>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令</li><li>该元数据可以通过 XML，Java 注解或 Java 代码提供。</li></ul><h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><ul><li>在依赖注入中，您不必创建对象，但必须描述如何创建它们</li><li>您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务</li><li>由 IoC 容器将它们装配在一起。</li></ul><h1 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h1><ul><li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li><li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h1 id="列举-IoC-的一些好处。"><a href="#列举-IoC-的一些好处。" class="headerlink" title="列举 IoC 的一些好处。"></a>列举 IoC 的一些好处。</h1><ul><li>它将最小化应用程序中的代码量。</li><li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li><li>它以最小的影响和最少的侵入机制促进松耦合。</li><li>它支持即时的实例化和延迟加载服务。</li></ul><h1 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h1><ul><li>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</li></ul><h1 id="什么是-spring-bean？"><a href="#什么是-spring-bean？" class="headerlink" title="什么是 spring bean？"></a>什么是 spring bean？</h1><ul><li>它们是构成用户应用程序主干的对象。</li><li>Bean 由 Spring IoC 容器管理。</li><li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li><li>Bean 是基于用户提供给容器的配置元数据创建。</li></ul><h1 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h1><ul><li>基于 xml 配置<ul><li>bean 所需的依赖项和服务在 XML 格式的配置文件中指定</li><li>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项</li><li>它们通常以 bean 标签开头</li></ul></li><li>基于注解配置<ul><li>可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配</li><li>默认情况下，Spring 容器中未打开注解装配</li><li>因此，您需要在使用它之前在 Spring 配置文件中启用它：<a href="context:annotation-config/">context:annotation-config/</a></li></ul></li><li>基于 Java API 配置<ul><li>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul><li>@Bean 注解扮演与<bean>元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul></li></ul></li></ul><h1 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h1><ul><li>Spring bean 支持 5 种 scope：<ul><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li></ul></li><li>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</li></ul><h1 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h1><ul><li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li><li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li><li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li><li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li><li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li><li>如果为 bean 指定了 init 方法（<bean>的 init-method 属性），那么将调用它。</bean></li><li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li><li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li><li>如果为 bean 指定了 destroy 方法（<bean>的 destroy-method 属性），那么将调用它。</bean></li></ul><h1 id="什么是-spring-的内部-bean？"><a href="#什么是-spring-的内部-bean？" class="headerlink" title="什么是 spring 的内部 bean？"></a>什么是 spring 的内部 bean？</h1><ul><li>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean</li><li>为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg>中提供了<bean>元素的使用</bean></constructor-arg></property></li><li>内部 bean 总是匿名的，它们总是作为原型。</li></ul><h1 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h1><ul><li>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配</li><li>Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</li></ul><h1 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h1><ul><li>Spring 容器能够自动装配 bean</li><li>也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</li><li>自动装配的不同模式：<ul><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ul></li></ul><h1 id="自动装配有什么局限？"><a href="#自动装配有什么局限？" class="headerlink" title="自动装配有什么局限？"></a>自动装配有什么局限？</h1><ul><li>覆盖的可能性 - 您始终可以使用<constructor-arg>和<property>设置指定依赖项，这将覆盖自动装配。</property></constructor-arg></li><li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li><li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li></ul><h1 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h1><ul><li>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身</li><li>它可以作为 XML 设置的替代方案。例如：Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul><li>@Bean 注解扮演与元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul></li></ul><h1 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h1><ul><li>默认情况下，Spring 容器中未打开注解装配</li><li>要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它</li></ul><h1 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h1><ul><li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li><li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h1 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h1><ul><li>Required 应用于 bean 属性 setter 方法</li><li>此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性</li><li>如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<pre><code>public class Employee &#123;
  private String name;
  @Required
  public void setName(String name)&#123;
      this.name=name;
  &#125;
  public string getName()&#123;
      return name;
  &#125;
&#125;
</code></pre></li></ul><h1 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h1><ul><li>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配</li><li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean</li><li>默认情况下，它是类型驱动的注入。</li></ul><h1 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h1><ul><li>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</li><li>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</li></ul><h1 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h1><ul><li>RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法</li><li>此注释可应用于两个级别：<ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul></li></ul><h1 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h1><ul><li>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作</li><li>这使得用户容易在持久性技术之间切换</li><li>它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</li></ul><h1 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h1><pre><code>- JdbcTemplate
- SimpleJdbcTemplate
- NamedParameterJdbcTemplate
- SimpleJdbcInsert
- SimpleJdbcCall
</code></pre><h1 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h1><ul><li>我们可以通过两种方式使用 Spring 访问 Hibernate：<ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul></li></ul><h1 id="列举-spring-支持的事务管理类型"><a href="#列举-spring-支持的事务管理类型" class="headerlink" title="列举 spring 支持的事务管理类型"></a>列举 spring 支持的事务管理类型</h1><ul><li>Spring 支持两种类型的事务管理：<ul><li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li><li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li></ul></li></ul><h1 id="spring-支持哪些-ORM-框架"><a href="#spring-支持哪些-ORM-框架" class="headerlink" title="spring 支持哪些 ORM 框架"></a>spring 支持哪些 ORM 框架</h1><ul><li>Hibernate</li><li>iBatis</li><li>JPA</li><li>JDO</li><li>OJB</li></ul><h1 id="指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h1><ul><li>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</li><li>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</li></ul><h1 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h1><ul><li>实现 AOP 的技术，主要分为两大类：<ul><li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul></li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul><li>JDK 动态代理</li><li>CGLIB</li></ul></li></ul></li></ul><h1 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h1><ul><li>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</li><li>Spring AOP 仅支持方法级别的 PointCut；AspectJ 提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</li></ul><h1 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h1><ul><li>将 Advice 应用于目标对象后创建的对象称为代理</li><li>在客户端对象的情况下，目标对象和代理对象是相同的。</li><li>Advice + Target Object = Proxy</li></ul><h1 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h1><ul><li>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）</li><li>在 Spring AOP 中，编织在运行时执行</li></ul><h1 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h1><ul><li>WebApplicationContext 是 ApplicationContext 的扩展</li><li>它具有 Web 应用程序所需的一些额外功能</li><li>它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</li></ul><h1 id="IoC-和-DI的区别？"><a href="#IoC-和-DI的区别？" class="headerlink" title="IoC 和 DI的区别？"></a>IoC 和 DI的区别？</h1><ul><li>IoC 控制反转，指将对象的创建权，反转到Spring容器</li><li>DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入 </li></ul><h1 id="BeanFactory-接口和-ApplicationContext-接口有什么区别？"><a href="#BeanFactory-接口和-ApplicationContext-接口有什么区别？" class="headerlink" title="BeanFactory 接口和 ApplicationContext 接口有什么区别？"></a>BeanFactory 接口和 ApplicationContext 接口有什么区别？</h1><ul><li>ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。</li><li>ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory <pre><code>BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));
IHelloService helloService = (IHelloService) beanFactory.getBean(&quot;helloService&quot;);
helloService.sayHello();
</code></pre></li></ul><h1 id="spring配置bean实例化有哪些方式？"><a href="#spring配置bean实例化有哪些方式？" class="headerlink" title="spring配置bean实例化有哪些方式？"></a>spring配置bean实例化有哪些方式？</h1><ul><li>使用类构造器实例化(默认无参数)</li><li>使用静态工厂方法实例化(简单工厂模式)</li><li>使用实例工厂方法实例化(工厂方法模式)</li></ul><h1 id="简单的说一下spring的生命周期？"><a href="#简单的说一下spring的生命周期？" class="headerlink" title="简单的说一下spring的生命周期？"></a>简单的说一下spring的生命周期？</h1><ul><li>instantiate bean对象实例化</li><li>populate properties 封装属性</li><li>如果Bean实现BeanNameAware 执行 setBeanName</li><li>如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext</li><li>如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)</li><li>如果Bean实现InitializingBean 执行 afterPropertiesSet </li><li>调用<bean init-method="init"> 指定初始化方法 init</bean></li><li>如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization</li><li>执行业务处理</li><li>如果Bean实现 DisposableBean 执行 destroy</li><li>调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy</bean></li></ul><h1 id="请介绍一下Spring框架中Bean的生命周期和作用域"><a href="#请介绍一下Spring框架中Bean的生命周期和作用域" class="headerlink" title="请介绍一下Spring框架中Bean的生命周期和作用域"></a>请介绍一下Spring框架中Bean的生命周期和作用域</h1><ul><li>bean定义：在配置文件里面用<bean></bean>来进行定义。</li><li>bean初始化，有两种方式初始化:<ul><li>在配置文件中通过指定init-method属性来完成</li><li>实现org.springframwork.beans.factory.InitializingBean接口</li></ul></li><li>bean调用：有三种方式可以得到bean实例，并进行调用</li><li>bean销毁，销毁有两种方式<ul><li>使用配置文件指定的destroy-method属性</li><li>实现org.springframwork.bean.factory.DisposeableBean接口</li></ul></li><li>作用域<ul><li>singleton：当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</li><li>prototype：Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域</li><li>request：在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>global session：在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</li></ul></li></ul><h1 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h1><ul><li>BeanFactory：产生一个新的实例，可以实现单例模式</li><li>BeanWrapper：提供统一的get及set方法</li><li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li></ul><h1 id="Spring里面applicationContext-xml文件能不能改成其他文件名？"><a href="#Spring里面applicationContext-xml文件能不能改成其他文件名？" class="headerlink" title="Spring里面applicationContext.xml文件能不能改成其他文件名？"></a>Spring里面applicationContext.xml文件能不能改成其他文件名？</h1><ul><li>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化</li><li>缺省情况下， 它会在WEB-INF/applicationContext.xml文件找Spring的配置</li><li>你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的位置</context-param></li></ul><p>11.Spring里面如何定义hibernate mapping？ </p><ul><li>添加hibernate mapping 文件到web/WEB-INF目录下的applicationContext.xml文件里面</li></ul><h1 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h1><ul><li>Spring使用ThreadLocal解决线程安全问题</li><li>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域</li><li>就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</li><li>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</li><li>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量</li><li>这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</li><li>而ThreadLocal则从另一个角度来解决多线程的并发访问</li><li>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突</li><li>因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li><li>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</li><li>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换</li><li>但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。</li><li>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li><li>前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li></ul><h1 id="介绍一下Spring的事物管理"><a href="#介绍一下Spring的事物管理" class="headerlink" title="介绍一下Spring的事物管理"></a>介绍一下Spring的事物管理</h1><ul><li>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</li><li>开发中为了避免这种情况一般都会进行事务管理</li><li>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能</li><li>spring提供了几个关于事务处理的类：<ul><li>TransactionDefinition //事务属性定义</li><li>TranscationStatus //代表了当前的事务，可以提交，回滚。</li><li>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。</li></ul></li><li>spring提供的事务管理可以分为两类：编程式的和声明式的<ul><li>编程式的，比较灵活，但是代码量大，存在重复的代码比较多</li><li>声明式的比编程式的更灵活。</li></ul></li><li>编程式主要使用transactionTemplate</li><li>省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.</li></ul><h1 id="AOP-通知有哪些类型？"><a href="#AOP-通知有哪些类型？" class="headerlink" title="AOP 通知有哪些类型？"></a>AOP 通知有哪些类型？</h1><ul><li>前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li><li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li><li>后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li><li>环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</li></ul><h1 id="什么是-spring"><a href="#什么是-spring" class="headerlink" title="什么是 spring?"></a>什么是 spring?</h1><ul><li>Spring 是个 java 企业级应用的开源开发框架</li><li>Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用</li><li>Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</li></ul><h1 id="使用-Spring-框架的好处是什么？"><a href="#使用-Spring-框架的好处是什么？" class="headerlink" title="使用 Spring 框架的好处是什么？"></a>使用 Spring 框架的好处是什么？</h1><ul><li>轻量：Spring 是轻量的，基本的版本大约 2MB</li><li>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li><li>容器：Spring 包含并管理应用中对象的生命周期和配置</li><li>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品</li><li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li><li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</li></ul><h1 id="ApplicationContext-通常的实现是什么？"><a href="#ApplicationContext-通常的实现是什么？" class="headerlink" title="ApplicationContext 通常的实现是什么？"></a>ApplicationContext 通常的实现是什么？</h1><ul><li>FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li>ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找bean 配置。</li><li>WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个WEB 应用的所有 bean。</li></ul><h1 id="一个-Spring-的应用看起来象什么？"><a href="#一个-Spring-的应用看起来象什么？" class="headerlink" title="一个 Spring 的应用看起来象什么？"></a>一个 Spring 的应用看起来象什么？</h1><ul><li>一个定义了一些功能的接口</li><li>这实现包括属性，它的 Setter ， getter 方法和函数等</li><li>Spring AOP</li><li>Spring 的 XML 配置文件</li><li>使用以上功能的客户端程序</li></ul><h1 id="哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？"><a href="#哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？" class="headerlink" title="哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？"></a>哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？</h1><ul><li>你两种依赖方式都可以使用，构造器注入和 Setter 方法注入</li><li>最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。</li></ul><h1 id="什么是-Spring-beans？"><a href="#什么是-Spring-beans？" class="headerlink" title="什么是 Spring beans？"></a>什么是 Spring beans？</h1><ul><li>Spring beans 是那些形成 Spring 应用的主干的 java 对象</li><li>它们被 Spring IOC 容器初始化，装配，和管理</li><li>这些 beans 通过容器中配置的元数据创建</li><li>比如，以 XML文件中<bean>的形式定义。</li><li>Spring 框架定义的 beans 都是单件 beans</li><li>在 bean tag 中有个属性”singleton”，如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean</li><li>默认是TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件</li></ul><h1 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h1><ul><li>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</li></ul><h1 id="如何给-Spring-容器提供配置元数据？"><a href="#如何给-Spring-容器提供配置元数据？" class="headerlink" title="如何给 Spring 容器提供配置元数据？"></a>如何给 Spring 容器提供配置元数据？</h1><ul><li>这里有三种重要的方法给 Spring 容器提供配置元数据。<ul><li>XML 配置文件。</li><li>基于注解的配置。</li><li>基于 java 的配置。</li></ul></li></ul><h1 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h1><ul><li>当定义一个<bean>在 Spring 里，我们还能给这个 bean 声明一个作用域</bean></li><li>它可以通过bean定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope属性必须设为singleton。</li></ul><h1 id="Spring-框架中的单例-bean-是线程安全的吗？"><a href="#Spring-框架中的单例-bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 bean 是线程安全的吗？"></a>Spring 框架中的单例 bean 是线程安全的吗？</h1><ul><li>不，Spring 框架中的单例 bean 不是线程安全的。</li></ul><h1 id="哪些是重要的-bean-生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的-bean-生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的 bean 生命周期方法？ 你能重载它们吗？"></a>哪些是重要的 bean 生命周期方法？ 你能重载它们吗？</h1><p>有- 两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时候被调用</p><ul><li>第二个方法是 teardown 它是在容器卸载类的时候被调用。</li><li>The bean 标签有两个重要的属性（init-method 和 destroy-method）</li><li>用它们你可 以 自 己 定 制 初 始 化 和 注 销 方 法</li><li>它 们 也 有 相 应 的 注 解 （ @PostConstruct 和@PreDestroy）。</li></ul><h1 id="在-Spring-中如何注入一个-java-集合？"><a href="#在-Spring-中如何注入一个-java-集合？" class="headerlink" title="在 Spring 中如何注入一个 java 集合？"></a>在 Spring 中如何注入一个 java 集合？</h1><ul><li>Spring 提供以下几种集合的配置元素：<ul><li><list>类型用于注入一列值，允许有相同的值。</list></li><li><set>类型用于注入一组值，不允许有相同的值。</set></li><li><map>类型用于注入一组键值对，键和值都可以为任意类型。</map></li><li><props>类型用于注入一组键值对，键和值都只能为 String 类型。</props></li></ul></li></ul><h1 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h1><ul><li>自动装配的局限性是：<ul><li>重写：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></li><li>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。</li><li>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li></ul></li></ul><h1 id="你可以在-Spring-中注入一个-null-和一个空字符串吗？"><a href="#你可以在-Spring-中注入一个-null-和一个空字符串吗？" class="headerlink" title="你可以在 Spring 中注入一个 null 和一个空字符串吗？"></a>你可以在 Spring 中注入一个 null 和一个空字符串吗？</h1><ul><li>可以。 Spring 注解</li></ul><h1 id="在-Spring-框架中如何更有效地使用-JDBC？"><a href="#在-Spring-框架中如何更有效地使用-JDBC？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC？"></a>在 Spring 框架中如何更有效地使用 JDBC？</h1><ul><li>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻</li><li>所以开发者只需写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</li><li>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li></ul><h1 id="Spring-对-DAO-的支持"><a href="#Spring-对-DAO-的支持" class="headerlink" title="Spring 对 DAO 的支持"></a>Spring 对 DAO 的支持</h1><ul><li>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，Hibernate or JDO 结合使用</li><li>这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</li></ul><h1 id="如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？"><a href="#如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？" class="headerlink" title="如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？"></a>如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</h1><ul><li>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul><li>配置 the Hibernate SessionFactory</li><li>继承 HibernateDaoSupport 实现一个 DAO</li><li>在 AOP 支持的事务中装配</li></ul></li></ul><h1 id="如何在spring的applicationContext-xml使用JNDI而不是DataSource"><a href="#如何在spring的applicationContext-xml使用JNDI而不是DataSource" class="headerlink" title="如何在spring的applicationContext.xml使用JNDI而不是DataSource"></a>如何在spring的applicationContext.xml使用JNDI而不是DataSource</h1><ul><li>可以使用”org.springframework.jndi.JndiObjectFactoryBean”来实现</li></ul><h1 id="在spring中是如何配置数据库驱动的"><a href="#在spring中是如何配置数据库驱动的" class="headerlink" title="在spring中是如何配置数据库驱动的"></a>在spring中是如何配置数据库驱动的</h1><ul><li>org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动</li></ul><h1 id="在web中如何配置spring"><a href="#在web中如何配置spring" class="headerlink" title="在web中如何配置spring"></a>在web中如何配置spring</h1><ul><li>在J2EE的web应用里面配置spring非常简单，最简单的只需要把spring得ContextLoaderListener添加到你的web.xml文件里面就可以了</li></ul><h1 id="在spring中如何定义hibernate-Mapping？"><a href="#在spring中如何定义hibernate-Mapping？" class="headerlink" title="在spring中如何定义hibernate Mapping？"></a>在spring中如何定义hibernate Mapping？</h1><ul><li>添加hibernate mapping 文件到web/WEB-INF目录下的applicationContext.xml文件里面</li></ul><h1 id="如何配置spring-struts？"><a href="#如何配置spring-struts？" class="headerlink" title="如何配置spring + struts？"></a>如何配置spring + struts？</h1><ul><li>在struts-config.xml加入一个插件，通过它加载applicationContext.xml</li><li>在struts-config.xml修改action-mapping标记，具体action交给了DelegateActionProxy</li><li>通过DelegateActionProxy进入一spring的环境。</li><li>在spring的applicationContext.xml加入<bean name="”/login”" class="”“" singleton="”false”/"></bean></li></ul><h1 id="如何在spring中实现国际化"><a href="#如何在spring中实现国际化" class="headerlink" title="如何在spring中实现国际化?"></a>如何在spring中实现国际化?</h1><ul><li>在applicationContext.xml加载一个bean org.springframework.context.support.ResourceBundleMessageSource</li><li>在src目录下建多个properties文件</li><li>对于非英文的要用native2ascii -encoding gb2312 源目转化文件相关内容</li><li>其命名格式是message_语言_国家。</li><li>页面中的中显示提示信息，键名取键值。</li><li>当给定国家，系统会自动加载对应的国家的properties信息。</li><li>通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。</li></ul><h1 id="在spring中如何实现事件处理"><a href="#在spring中如何实现事件处理" class="headerlink" title="在spring中如何实现事件处理"></a>在spring中如何实现事件处理</h1><ul><li>事件 Extends ApplicationEvent</li><li>监听器 Implements ApplicationListener</li><li>事件源 Implements ApplicationContextAware</li><li>在applicationContext.xml中配置事件源、监听器</li><li>先得到事件源，调用事件源的方法，通知监听器。</li></ul><h1 id="如何将spring加入web容器中"><a href="#如何将spring加入web容器中" class="headerlink" title="如何将spring加入web容器中"></a>如何将spring加入web容器中</h1><ul><li>在web.xml中加入如下同容,在启动web服务器时加载/WEB-INF/applicationContext.xml中的内容。</li></ul><h1 id="Spring如何实现资源管理"><a href="#Spring如何实现资源管理" class="headerlink" title="Spring如何实现资源管理?"></a>Spring如何实现资源管理?</h1><ul><li>使用<ul><li>applicationContext.getResource(“classpath:文件名”):在src根目录下，在类路径下</li><li>applicationContext.getResource(“classpath:/chap01/文件名”): 以src根目录下的基准往下走。</li><li>applicationContext.getResource(“file:c:/a.properties”)：在系统文件目录下。</li></ul></li></ul><h1 id="Spring的ApplicationContext的作用"><a href="#Spring的ApplicationContext的作用" class="headerlink" title="Spring的ApplicationContext的作用?"></a>Spring的ApplicationContext的作用?</h1><ul><li>beanFactory</li><li>国际化(getMesage)</li><li>资源管理:可以直接读取一个文件的内容(getResource)</li><li>加入web框架中(加入一个servlet或监听器)</li><li>事件处理</li></ul><h1 id="Hibernate工作原理及为什么要用？"><a href="#Hibernate工作原理及为什么要用？" class="headerlink" title="Hibernate工作原理及为什么要用？"></a>Hibernate工作原理及为什么要用？</h1><ul><li>原理：<ul><li>读取并解析配置文件</li><li>读取并解析映射信息，创建SessionFactory</li><li>打开Sesssion</li><li>创建事务Transation</li><li>持久化操作</li><li>提交事务</li><li>关闭Session</li><li>关闭SesstionFactory</li></ul></li><li>为什么要用：<ul><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li></ul></li><li>Hibernate是如何延迟加载?<ul><li>Hibernate2延迟加载实现：a)实体对象  b)集合（Collection）</li><li>Hibernate3 提供了属性的延迟加载功能</li></ul></li><li>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</li><li>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)<ul><li>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</li></ul></li><li>说下Hibernate的缓存机制<ul><li>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</li><li>二级缓存：<ul><li>应用及缓存</li><li>分布式缓存<ul><li>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据</li></ul></li></ul></li><li>第三方缓存的实现</li></ul></li><li>Hibernate的查询方式<ul><li>Sql、Criteria,object comptosition</li><li>Hql：<ul><li>属性查询</li><li>参数查询、命名参数查询</li><li>关联查询</li><li>分页查询</li><li>统计函数</li></ul></li></ul></li><li>如何优化Hibernate？<ul><li>使用双向一对多关联，不使用单向一对多</li><li>灵活使用单向一对多关联</li><li>不用一对一，用多对一取代</li><li>配置对象缓存，不使用集合缓存</li><li>一对多集合使用Bag,多对多集合使用Set</li><li>继承类使用显式多态</li><li>表字段要少，表关联不要怕多，有二级缓存撑腰</li></ul></li></ul><h1 id="Spring中如何获取bean"><a href="#Spring中如何获取bean" class="headerlink" title="Spring中如何获取bean"></a>Spring中如何获取bean</h1><ul><li>通过xml配置文件</li><li>bean配置在xml里面，spring提供多种方式读取配置文件得到ApplicationContext.<ul><li>第一种方式：FileSystemXmlApplicationContext通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例:<ul><li>ApplicationContext ac = new FileSystemXmlApplicationContext(”applicationContext.xml”)</li><li>ac.getBean(”beanName”);</li></ul></li><li>第二种方式：WebApplicationContextUtil在B/S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext.例如：<ul><li>ApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);</li><li>ApplicationContext ctx =   WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</li><li>其中 servletContext sc 可以具体 换成 servlet.getServletContext()或者 this.getServletContext() 或者 request.getSession().getServletContext();</li><li>另外，由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象：</li><li>WebApplicationContext webApplicationContext = (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</li></ul></li></ul></li></ul><h1 id="Spring框架中的单例Beans是线程安全的么？"><a href="#Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="Spring框架中的单例Beans是线程安全的么？"></a>Spring框架中的单例Beans是线程安全的么？</h1><ul><li>Spring框架并没有对单例bean进行任何多线程的封装处理</li><li>关于单例bean的线程安全和并发问题需要开发者自行去搞定</li><li>但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的</li><li>如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。</li><li>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</li></ul><h1 id="如何向Spring-Bean中注入一个Java-util-Properties？"><a href="#如何向Spring-Bean中注入一个Java-util-Properties？" class="headerlink" title="如何向Spring Bean中注入一个Java.util.Properties？"></a>如何向Spring Bean中注入一个Java.util.Properties？</h1><ul><li>第一种方法是使用如下面代码所示的<props> 标签</props></li><li>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。</li></ul><h1 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h1><ul><li>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</li><li>我们可以创建bean用来监听在ApplicationContext 中发布的事件</li><li>ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li><li>Spring 提供了以下5中标准的事件：<ul><li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li></ul></li><li>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。为了监听这个事件，还需要创建一个监听器，之后通过applicationContext接口的publishEvent()方法来发布自定义事件。</li></ul><h1 id="FileSystemResource和ClassPathResource有何区别？"><a href="#FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="FileSystemResource和ClassPathResource有何区别？"></a>FileSystemResource和ClassPathResource有何区别？</h1><ul><li>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径</li><li>在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。</li><li>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</li><li>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</li></ul><h1 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h1><ul><li>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：<ul><li>代理模式—在AOP和remoting中被用的比较多。</li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。</li><li>工厂模式—BeanFactory用来创建对象的实例</li></ul></li></ul><p> </p><h1 id="开发中主要使用-Spring-的什么技术"><a href="#开发中主要使用-Spring-的什么技术" class="headerlink" title="开发中主要使用 Spring 的什么技术 ?"></a>开发中主要使用 Spring 的什么技术 ?</h1><ul><li>IOC 容器管理各层的组件</li><li>使用 AOP 配置声明式事务</li><li>整合其他框架</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/cc5f72fdfb9e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/cc5f72fdfb9e.html" class="post-title-link" itemprop="url">Tomcat</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:02:31" itemprop="dateCreated datePublished" datetime="2023-12-20T16:02:31+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 20:49:47" itemprop="dateModified" datetime="2023-12-24T20:49:47+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Tomcat的缺省端口是多少，怎么修改？"><a href="#Tomcat的缺省端口是多少，怎么修改？" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改？"></a>Tomcat的缺省端口是多少，怎么修改？</h1><ul><li>找到Tomcat目录下的conf文件夹</li><li>进入conf文件夹里面找到server.xml文件</li><li>打开server.xml文件</li><li>在server.xml文件里面找到下列信息<pre><code>&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;
</code></pre></li><li>port=”8080”改成你想要的端口</li></ul><h1 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h1><h4 id="bio：传统的Java-I-O操作，同步且阻塞IO。"><a href="#bio：传统的Java-I-O操作，同步且阻塞IO。" class="headerlink" title="bio：传统的Java I/O操作，同步且阻塞IO。"></a>bio：传统的Java I/O操作，同步且阻塞IO。</h4><ul><li>maxThreads=”150”//Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值200。可以根据机器的时期性能和内存大小调整，一般可以在400-500。最大可以在800左右。</li><li>minSpareThreads=”25”—Tomcat初始化时创建的线程数。默认值4。如果当前没有空闲线程，且没有超过maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。</li><li>maxSpareThreads=”75”–一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值50。一旦创建的线程超过此数值，Tomcat会关闭不再需要的线程。线程数可以大致上用 “同时在线人数每秒用户操作次数系统平均操作时间” 来计算。</li><li>acceptCount=”100”—-指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。如果当前可用线程数为0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。</li><li>connectionTimeout=”20000” –网络连接超时，默认值20000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li></ul><h4 id="nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。"><a href="#nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。" class="headerlink" title="nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。"></a>nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。</h4><ul><li>指定使用NIO模型来接受HTTP请求</li><li>protocol=”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol=”HTTP/1.1”</li><li>acceptorThreadCount=”2” 使用NIO模型时接收线程的数目</li></ul><h4 id="aio-nio-2-：JDK7开始支持，异步非阻塞IO。"><a href="#aio-nio-2-：JDK7开始支持，异步非阻塞IO。" class="headerlink" title="aio(nio.2)：JDK7开始支持，异步非阻塞IO。"></a>aio(nio.2)：JDK7开始支持，异步非阻塞IO。</h4><ul><li><p>apr：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。</p><pre><code>&lt;!--
    &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8000&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;
  --&gt;
  &lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;
  &lt;!-- minProcessors最小空闲连接线程数--&gt;
  &lt;!-- maxProcessors最大连接线程数--&gt;
  &lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;
  &lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;
  &lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; 
      connectionTimeout=&quot;20000&quot;
      redirectPort=&quot;8443
      maxThreads=“500” 
      minSpareThreads=“100” 
      maxSpareThreads=“200”
      acceptCount=&quot;200&quot;
      enableLookups=&quot;false&quot;       
  /&gt;
</code></pre></li><li><p>其他配置</p><ul><li>maxHttpHeaderSize=”8192” http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。</li><li>URIEncoding=”UTF-8” 指定Tomcat容器的URL编码格式。</li><li>disableUploadTimeout=”true” 上传时是否使用超时机制</li><li>enableLookups=”false”–是否反查域名，默认值为true。为了提高处理能力，应设置为false</li><li>compression=”on” 打开压缩功能</li><li>compressionMinSize=”10240” 启用压缩的输出内容大小，默认为2KB</li><li>noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</li><li>compressableMimeType=”text/html,text/xml,text/javascript,text/css,text/plain” 哪些资源类型需要压缩</li></ul></li></ul><h1 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h1><ul><li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li><li>在server.xml文件上配置<context>节点，设置相关的属性即可</context></li><li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li></ul><h1 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h1><ul><li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析， 并读取servlet注册信息</li><li>然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。（有时候也是在第一次请求时实例化）在servlet注册时加上如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li></ul><h1 id="tomcat-如何优化？"><a href="#tomcat-如何优化？" class="headerlink" title="tomcat 如何优化？"></a>tomcat 如何优化？</h1><ul><li><p>优化连接配置.这里以tomcat7的参数配置为例，需要修改conf/server.xml文件，修改连接数，关闭客户端dns查询。</p></li><li><p>参数解释：</p><ul><li>URIEncoding=”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</li><li>maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</li><li>minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</li><li>enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</li><li>connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</li><li>maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</li><li>acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</li><li>maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。通常Windows是1000个左右，Linux是2000个左右。</li><li>useURIValidationHack:把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</li><li>enableLookups=”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</li><li>disableUploadTimeout ：类似于Apache中的keeyalive一样</li></ul></li><li><p>给Tomcat配置gzip压缩(HTTP压缩)功能</p><pre><code>compression=”on” compressionMinSize=”2048″
compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”
</code></pre></li><li><p>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。</p></li><li><p>相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p><pre><code>compression=”on” 打开压缩功能
compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB
noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩
compressableMimeType=”text/html,text/xml”　压缩类型
</code></pre></li><li><p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置</p></li></ul><h1 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h1><ul><li>内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。</li><li>具体设置如下： JAVA_OPTS=”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4”</li><li>其各项参数如下：<ul><li>-Xmx3550m：设置JVM最大可用内存为3550M。</li><li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</li><li>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li><li>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</li><li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</li><li>-XX:MaxPermSize=16m:设置持久代大小为16m。</li><li>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li></ul></li></ul><h1 id="垃圾回收策略调优"><a href="#垃圾回收策略调优" class="headerlink" title="垃圾回收策略调优"></a>垃圾回收策略调优</h1><ul><li>垃圾回收的设置也是在catalina.sh中，调整JAVA_OPTS变量。</li><li>具体设置如下： JAVA_OPTS=”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100”</li><li>具体的垃圾回收策略及相应策略的各项参数如下：<ul><li>串行收集器（JDK1.5以前主要的回收方式） ：-XX:+UseSerialGC:设置串行收集器</li><li>并行收集器（吞吐量优先）<ul><li>示例： java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</li><li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集</li><li>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li></ul></li><li>并发收集器（响应时间优先）<ul><li>示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC</li><li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</li><li>-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li><li>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</li><li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li></ul></li></ul></li></ul><h1 id="共享session处理"><a href="#共享session处理" class="headerlink" title="共享session处理"></a>共享session处理</h1><h4 id="使用Tomcat本身的Session复制功能"><a href="#使用Tomcat本身的Session复制功能" class="headerlink" title="使用Tomcat本身的Session复制功能"></a>使用Tomcat本身的Session复制功能</h4><ul><li>方案的有点是配置简单，缺点是当集群数量较多时，Session复制的时间会比较长，影响响应的效率</li></ul><h4 id="使用第三方来存放共享Session"><a href="#使用第三方来存放共享Session" class="headerlink" title="使用第三方来存放共享Session"></a>使用第三方来存放共享Session</h4><ul><li>目前用的较多的是使用memcached来管理共享Session，借助于memcached-sesson-manager来进行Tomcat的Session管理</li></ul><h4 id="使用黏性session的策略"><a href="#使用黏性session的策略" class="headerlink" title="使用黏性session的策略"></a>使用黏性session的策略</h4><ul><li>对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同一个用户的session可以由nginx或者apache交给同一个Tomcat来处理，这就是所谓的session sticky策略，目前应用也比较多</li><li>nginx默认不包含session sticky模块，需要重新编译才行（windows下我也不知道怎么重新编译）</li><li>优点是处理效率高多了，缺点是强会话要求的场合不合适</li></ul><h1 id="添加JMS远程监控"><a href="#添加JMS远程监控" class="headerlink" title="添加JMS远程监控"></a>添加JMS远程监控</h1><ul><li>对于部署在局域网内其它机器上的Tomcat，可以打开JMX监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在JVM启动参数中配置即可，配置如下：<ul><li>-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false</li><li>-Djava.rmi.server.hostname=192.168.71.38 设置JVM的JMS监控监听的IP地址，主要是为了防止错误的监听成127.0.0.1这个内网地址</li><li>-Dcom.sun.management.jmxremote.port=1090 设置JVM的JMS监控的端口</li><li>-Dcom.sun.management.jmxremote.ssl=false 设置JVM的JMS监控不实用SSL</li><li>-Dcom.sun.management.jmxremote.authenticate=false 设置JVM的JMS监控不需要认证</li></ul></li></ul><h1 id="专业点的分析工具有"><a href="#专业点的分析工具有" class="headerlink" title="专业点的分析工具有"></a>专业点的分析工具有</h1><ul><li>IBM ISA，JProfiler、probe 等，具体监控及分析方式去网上搜索即可</li></ul><h1 id="关于Tomcat的session数目"><a href="#关于Tomcat的session数目" class="headerlink" title="关于Tomcat的session数目"></a>关于Tomcat的session数目</h1><ul><li>这个可以直接从Tomcat的web管理界面去查看即可；</li><li>或者借助于第三方工具Lambda Probe来查看，它相对于Tomcat自带的管理稍微多了点功能，但也不多 ；</li></ul><h1 id="监视Tomcat的内存使用情况"><a href="#监视Tomcat的内存使用情况" class="headerlink" title="监视Tomcat的内存使用情况"></a>监视Tomcat的内存使用情况</h1><ul><li>使用JDK自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等；</li><li>JDK自带的jvisualvm可以下载插件（如GC等），可以查看更丰富的信息。如果是分析本地的Tomcat的话，还可以进行内存抽样等，检查每个类的使用情况</li></ul><h1 id="打印类的加载情况及对象的回收情况"><a href="#打印类的加载情况及对象的回收情况" class="headerlink" title="打印类的加载情况及对象的回收情况"></a>打印类的加载情况及对象的回收情况</h1><ul><li>这个可以通过配置JVM的启动参数，打印这些信息（到屏幕（默认也会到catalina.log中）或者文件），具体参数如下：<ul><li>-XX:+PrintGC：输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</li><li>-XX:+PrintGCDetails：输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</li><li>-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用，输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</li><li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds</li><li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds</li><li>-XX:PrintHeapAtGC: 打印GC前后的详细堆栈信息</li><li>-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析</li><li>-verbose:class 监视加载的类的情况</li><li>-verbose:gc 在虚拟机发生内存回收时在输出设备显示信息</li><li>-verbose:jni 输出native方法调用的相关情况，一般用于诊断jni调用错误信息</li></ul></li></ul><h1 id="Tomcat一个请求的完整过程"><a href="#Tomcat一个请求的完整过程" class="headerlink" title="Tomcat一个请求的完整过程"></a>Tomcat一个请求的完整过程</h1><ul><li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得</li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应</li><li>Engine获得请求localhost/yy/index.jsp，匹配它所拥有的所有虚拟主机Host</li><li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）</li><li>localhost Host获得请求/yy/index.jsp，匹配它所拥有的所有Context</li><li>Host匹配到路径为/yy的Context（如果匹配不到就把该请求交给路径名为”“的Context去处理）</li><li>path=”/yy”的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类</li><li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host</li><li>Host把HttpServletResponse对象返回给Engine</li><li>Engine把HttpServletResponse对象返回给Connector</li><li>Connector把HttpServletResponse对象返回给客户browser</li></ul><h1 id="Tomcat工作模式？"><a href="#Tomcat工作模式？" class="headerlink" title="Tomcat工作模式？"></a>Tomcat工作模式？</h1><ul><li>Tomcat是一个JSP/Servlet容器</li><li>其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</li><li>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：<ul><li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li><li>Tomcat作为独立服务器：请求来自于web浏览器；</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/aa3500b67dae.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/aa3500b67dae.html" class="post-title-link" itemprop="url">版本管理工具</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:00:42" itemprop="dateCreated datePublished" datetime="2023-12-20T16:00:42+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 11:52:57" itemprop="dateModified" datetime="2023-12-24T11:52:57+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">版本管理工具</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="svn和git的区别及适用场景"><a href="#svn和git的区别及适用场景" class="headerlink" title="svn和git的区别及适用场景"></a>svn和git的区别及适用场景</h1><h4 id="svn的优势"><a href="#svn的优势" class="headerlink" title="svn的优势"></a>svn的优势</h4><ul><li>优异的跨平台支持，对windows平台支持非常友好。</li><li>简单易用，安装后稍微培训下就知道怎么操作。</li><li>代码，需求，文档，涉及稿都可以用svn进行管理，适合不同部门的技术非技术的同事协作。</li></ul><h4 id="git的优势"><a href="#git的优势" class="headerlink" title="git的优势"></a>git的优势</h4><ul><li>去中心化：Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容是完全一样的（格式有点不同，是bare的）。虽然平时大家都是将代码提交到中央服务器上再统一pull别人的代码，但实际情况你可以总是pull张三的库，然后push给李四等等操作。</li><li>本地提交：本地提交好处主要有3点：<ul><li>一， 断网提交</li><li>二， 小步提交。可以对自己的阶段成果有跟踪，并且提高每次变更的安全性</li><li>三，本地库。这个和断网提交是同一个实现，但从需求角度出发则略有不同，主要是说即使只有自己一个人开发项目，也可以轻易的让自己的代码有版本跟踪，而不需要去费力建个什么svn server。</li><li>四，本地回滚。这个其实是由于本地库的存在而产生的，但可以减少中央库上的冗余版本</li></ul></li><li>分支策略：在Git实际开发中分支的分离和merge是属于日常操作，开启和合并分支成本相比SVN要小得多：SVN是复制一份代码到分支目录，Git则是在分支点做一下标记。随便一次冲突就会自动产生分支，所以大家每天都在与分支打交道。这便是弱化了分支的概念，由于分支成本很小，因此使得按功能分支的开发模式（每个分支一个功能，开发完了再merge到主干）变得非常简单，大家可以完全不需要再因为担心SCM成本太高而选用主干开发模式（所有功能都在主干上开发，到了发版本前再分离出分支）。</li></ul><h4 id="两者的工作流对比"><a href="#两者的工作流对比" class="headerlink" title="两者的工作流对比"></a>两者的工作流对比</h4><h5 id="svn模式"><a href="#svn模式" class="headerlink" title="svn模式"></a>svn模式</h5><ul><li>写代码。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将本地代码提交到服务器。</li></ul><h5 id="git模式"><a href="#git模式" class="headerlink" title="git模式"></a>git模式</h5><ul><li>写代码。</li><li>提交到本地版本库。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将远程库与本地代码合并结果提交到本地版本库。</li><li>将本地版本库推到服务器。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>对比可以看出：分布式版本管理仅仅是增加了本地库这个概念，其余的概念与集中管理并无区别。——但是 svn 在与服务器同步之前无法提交代码，因而本地修改更容易出问题。</li><li>当研发成本比较低，协作开发人数不多，开发人员对于版本管理的水平参差不齐的时候，或者对于代码的安全性要求更高一点的时候，适合用svn。</li><li>而对于很多人参与开发，代码量比较大，或者高频次协作，跨公司，跨地域合作的情况下，更适合用git。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/726ed62e2d44.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/726ed62e2d44.html" class="post-title-link" itemprop="url">Nginx</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:59:00" itemprop="dateCreated datePublished" datetime="2023-12-20T15:59:00+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 16:21:48" itemprop="dateModified" datetime="2023-12-24T16:21:48+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nginx/" itemprop="url" rel="index"><span itemprop="name">nginx</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><ul><li>Nginx应该是现在最火的web和反向代理服务器，没有之一</li><li>它是一款诞生于俄罗斯的高性能web服务器，尤其在高并发情况下，相较Apache，有优异的表现。</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><ul><li>Nginx擅长处理静态文件，是非常好的图片、文件服务器</li><li>把所有的静态资源的放到nginx上，可以使应用动静分离，性能更好</li></ul><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><ul><li>Nginx通过反向代理可以实现服务的负载均衡，避免了服务器单节点故障，把请求按照一定的策略转发到不同的服务器上，达到负载的效果。</li></ul><h6 id="常用的负载均衡策略有"><a href="#常用的负载均衡策略有" class="headerlink" title="常用的负载均衡策略有"></a>常用的负载均衡策略有</h6><ul><li>轮询<ul><li>将请求按顺序轮流地分配到后端服务器上</li><li>它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li></ul></li><li>加权轮询<ul><li>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同</li><li>给配置高、负载低的机器配置更高的权重，让其处理更多的请；</li><li>而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li></ul></li><li>ip_hash（源地址哈希法）<ul><li>根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问服务器的序号。</li><li>采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li></ul></li><li>随机<ul><li>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。</li></ul></li><li>least_conn（最小连接数法）<ul><li>由于后端服务器的配置不尽相同，对于请求的处理有快有慢</li><li>最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li></ul></li></ul><h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><ul><li>Nginx的限流模块，是基于漏桶算法实现的，在高并发的场景下非常实用，如下图：</li></ul><h6 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h6><ul><li>limit_req_zone定义在http块中，$binary_remote_addr 表示保存客户端IP地址的二进制形式。</li><li>Zone定义IP状态及URL访问频率的共享内存区域。<br>-zone=keyword标识区域的名字，以及冒号后面跟区域大小。16000个IP地址的状态信息约1MB，所以示例中区域可以存储160000个IP地址。</li><li>Rate定义最大请求速率。示例中速率不能超过每秒100个请求。</li></ul><h6 id="设置限流"><a href="#设置限流" class="headerlink" title="设置限流"></a>设置限流</h6><ul><li>burst排队大小，nodelay不限制单个请求间的时间。</li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul><li>浏览器缓存，静态资源缓存用expire。</li><li>代理层缓存</li></ul><h5 id="黑白名单"><a href="#黑白名单" class="headerlink" title="黑白名单"></a>黑白名单</h5><ul><li>不限流白名单</li><li>黑名单</li></ul><h1 id="Nginx性能调优："><a href="#Nginx性能调优：" class="headerlink" title="Nginx性能调优："></a>Nginx性能调优：</h1><ul><li>增加同时打开⽂件数open files数量；</li><li>处理⼤量静态⽂件的磁盘I/O时(此时worker进程是单线程的)，增加CPU核⼼数Worker Processes数量，提⾼计算能⼒；</li><li>如果⽹站流量很⾼，则可以提升worker进程连接数Worker Connections(默认1024)；</li><li>控制keep alive在10s-20s之间，减少连接的时间开销；</li><li>合理设置open file cache时间提⾼处理效率；</li><li>提⾼⽹路带宽；</li><li>开启压缩传输数据gzip，设置压缩级别gzip_comp_level为1-2，再⾼效果不明显并且浪费CPU了；</li><li>扩展机器数量。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/64b56da2b088.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/64b56da2b088.html" class="post-title-link" itemprop="url">面试技巧</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:57:12" itemprop="dateCreated datePublished" datetime="2023-12-20T15:57:12+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 13:27:06" itemprop="dateModified" datetime="2023-12-24T13:27:06+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">面试技巧</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="IT从业人员面试技巧"><a href="#IT从业人员面试技巧" class="headerlink" title="IT从业人员面试技巧"></a>IT从业人员面试技巧</h1><ul><li>一般来说，面试你的人都不是一个很好对付的人。别看他彬彬有礼，看上去笑眯眯的，很和气的样子。但没准儿一肚子坏水。有些人待人特别客气，说话还稍稍有点结巴的，更容易让人上当。所以，牢记一点，面试的时候保持高度警觉，对方不经意问出来的问题，很可能是他最想知道的。举例来说，我每次面试的时候，最喜欢说的话就是：哦，我不是HR的，你别拘束，咱们就当是聊天……</li><li>负责面试的人，一般有两种，一种是专门的人力资源部门。我不懂这一块，略过不谈。另外一种就是我这样的，负责某个部门的苦力头。一般来说，公司中层的苦力头，他的脑子里面都有一个模式，他的码头上需要一个什么样的人，他或她必须具备哪些技能。但这些考察都是次要的，他首先要搞清楚一点，那就是对方的人品!!!换句话说，能力是一个方面，但人品是门槛!!!如果他判定你人品有问题，那剩下的问题就没必要了。这里面就有很多陷阱，比如，你怎么评价前一家公司。你要是大说特说那公司怎么不好，我肯定要琢磨了，你昨天背叛少林，那今天会不会背叛武当?最好把离职原因淡淡一说，不要指责谁。我找工作的时候，一般都老实说，我自己能力不行，被公司淘汰了。其实大家肚子都揣着明白，不就是为了找个钱多点的地儿嘛。我经常问的一个陷阱问题就是：谈谈你的父母。其实这个问题一方面是考察对方的家庭教育，另外一方面是看看面试者怎么评价父母。这里面有个通常的逻辑，爹妈把他养这么大，说到自己的父母毫无感恩，感激之情，这种人招进来肯定不能成为合格的苦力。</li><li>总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li></ul><h4 id="面试到结束的时候，都会问到薪金标准。"><a href="#面试到结束的时候，都会问到薪金标准。" class="headerlink" title="面试到结束的时候，都会问到薪金标准。"></a>面试到结束的时候，都会问到薪金标准。</h4><ul><li>我不知道别的公司怎么操作的。我呆过的公司，都是定编定岗的，换句话说，招聘的时候，这个岗位的薪水是早就确定了。也就是说，对方问到薪金的时候，他已经在脑子里面很清楚公司的标准!!!一般说来，这个问题的目的是为了确定，他如果觉得你是个合适的苦力，那么，现在的薪金，你是不是会过来干活。问到薪金的时候，最好的回答是不回答，留到下一次面试再谈。或者可以反问，公司对于这个岗位定的薪金标准是多少。</li><li>一般来说，苦力头不会管你薪金多少的。好的苦力，苦力头甚至会为你向老板争取。</li><li>能够混到苦力头的位置上，面试你的人至少具有一定的能力，以及足够的胸怀。他在意的是能不能招到合适的人干活，薪金的问题不是问题。但过高的薪金，会把你抹掉。比如这个岗位，公司定的薪水是三千，你一张嘴，四千，那完了。对于应聘者，其实是很不公平的，你能做的就是接受这个标准或是不接受。如果是刚刚走出校门，月薪三千我想足够生活了。所以，如果对方的薪金标准，你要么不回答，要么就说三千，别要的太高。</li></ul><h4 id="一般面试都是在一个独立的私密空间进行。"><a href="#一般面试都是在一个独立的私密空间进行。" class="headerlink" title="一般面试都是在一个独立的私密空间进行。"></a>一般面试都是在一个独立的私密空间进行。</h4><ul><li>这里简单说说一些基本的礼貌。</li><li>进门要敲门，敲门是最基本的一点。</li><li>第二点，落座，别进去一屁股就坐上去了。最好等对方先坐下。当然，一般面试的人都很客气，招呼：坐，坐。</li><li>有时候进去之后，面试的人已经坐好了，那就别管了，坐在他的对面或他指定的位置就行。我这人比较心理阴暗，一般都是背对亮光坐。</li><li>当你结束时，至少客气招呼一声：谢谢您抽出时间面试我。</li><li>如果离开座位，顺手把椅子推好，这也是一个容易疏忽的地方。</li><li>有些公司的前台小姑娘，是你去面试的时候最先面对的，那么临走的时候客气打声招呼。</li><li>我有个习惯，面试的时候带着名片，如果我觉得很合适，会把名片给对方，这样他便于有问题的话联络我。但是，亲爱的朋友，你去面试的时候，如果对方面前放着名片夹子，千万不要傻了吧叽的要名片。</li><li>面试结束的第二天，如果你有面试你的苦力头电话，那就发个短信，内容可以客套一下，就说感谢你昨天面试我之类的话，然后祝福一下，比如今天好心情，工作顺利等等。千万不要问对方结果。你的目的就是提醒他，显示你的存在就行了。</li><li>你等待的地方，可能是公司的公共区域，而面试的地方可能是会议室，或者像我这样的人，喜欢在自己的办公室谈。那么切忌，不要走在前面，也不要走路中间，走在边上就行，把中间的位置留给你未来的领导走。进门之前主动为对方开门，这种拍马屁的小花招可以多来一点。</li><li>面试的时候身体正直，自然一点就行。一般来说，不要用摩丝喷的脑袋跟刺猬一样。女孩子也不要用过于浓密的香水。这是谈事情，不是相亲。</li><li>谈话的过程中，不要抢话，语速也不要太快。我教大家一个小诀窍，我一般和人谈事情，一开始故意显得有点结巴。人说话结巴，会让人感觉对方很诚恳。但就开头一两句结巴就行，别一直结巴。</li><li>有些人面试的时候介绍自己会滔滔不绝，说话特快。其实这里面有个信息传递的问题，跟别人谈事情，语速太快，往往容易说错。对方接受起来也有问题。中等语速就可以了。</li><li>很多男士比较大大咧咧，往那儿一坐，二郎腿就搭上了。要是碰上我这样大大咧咧的，可能无所谓，要是碰到心理阴暗的，就会有负面影响。另外，很多人一紧张就爱抖腿，这样也不礼貌。面试其实就是一个自我介绍，不是演说，不要声音特大吐沫横飞的，平时说话的声音就行。</li><li>面试你的要是个女的那就算了，要是个男的，不用管自己的性别，大大方方招呼一声，你好，手伸过去，和他握个手。其实从握手就能看到一个人的个性，一般来说，握手短促有力，可能是我这样比较外向的性格。握的软绵绵的，对方可能比较内向。</li><li>不要紧张，表现得自然些，要有礼貌，别忘记和主考人招呼，说句”早晨好”。</li><li>举止要大方，不可闪缩，要保持自信。待主考人邀请你才可礼貌地坐下，不要太随便或左顾右盼;切忌装出懒洋洋和满不在乎的样子。</li><li>微笑可以减轻你内心的不安，更可以令面试的气氛变得融洽愉快。</li><li>让主考人知道你珍惜这次面试的机会。当主考人说话时，要眼望对方，并留心倾听。</li><li>让主考人先打开话匣子。答问题要直接了当，无须太繁复，也不要单说”是”或”不是”;否则，主考人会觉得你欠缺诚意。深入的谈话内容有助主考人对你作出确切的评估。</li><li>假如不太明白主考人的问题，应该礼貌地请他重复。不懂得回答的问题，不妨坦白承认。含糊其辞或乱吹牛会导至面试的失败。</li><li>不要打断主考人的说话，被要求就相同的问题重复作答也不能表示不耐烦，更切忌与主考人争辩。</li><li>主考人可能问你一些与面试或者申请的职位完全无关的问题，例如时人时事;目的在进一步了解你的思想及见识。</li><li>紧记在适当时机带出自已的优点和特长。但切勿显得过份自信或浮夸。</li><li>不要急着提出薪酬问题，最好让主考人先提出。</li><li>准备一些与该机构和申请的工作有关的问题在面试结束之前提出。这样能表现伙的积极，亦可给主考人留下良好印象。</li><li>最后，问清楚多久才知道面试结果。不要忘记向主考人道谢及说声”再见”才离去。</li></ul><h1 id="面试一家公司之前需要做的准备"><a href="#面试一家公司之前需要做的准备" class="headerlink" title="面试一家公司之前需要做的准备"></a>面试一家公司之前需要做的准备</h1><h4 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h4><ul><li>了解应聘公司；</li><li>了解应聘岗位</li><li>查该公司的资料，知道该公司是做什么的，发展情况，招聘的岗位的要求等</li><li>公司地点在哪里，交通是否方便，需提前多久出发；</li><li>公司类型如何？我应该如何着装？去咨询公司逃不掉正装，而去互联网公司这么穿，人家或许以为你是房产中介；</li><li>公司业务如何？上市了吗？财报如何？主要产品有哪些？</li><li>公司在中国有多少分支机构？最近有什么新动向？</li><li>公司所在行业有何新动向？发展趋势如何？</li><li>公司的竞争对手有哪些？公司在行业内排名如何？</li></ul><h4 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h4><ul><li>重温一下简历内容，确保每段经历都能用简短的语言复述；</li><li>带过的团队，做过的项目，组织过的活动，以STAR的形式准备好；</li><li>每一段经历，都应该准备实例和数据证明，会给面试官留下深刻印象；</li><li>准备几个感兴趣的问题，面试中如果没有获得解答，在电话通知环节，我们必须开口问，有诸多信息要确认：<ul><li>面试时间／地点</li><li>公司名称／岗位名称</li><li>联系人信息（一旦迟到，得提前打电话道歉）</li><li>面试官是谁（HR还是直线经理，或者都一次性面试掉）</li><li>需要准备什么材料（一般逃不掉学历证明，身份证复印件等资料）</li><li>针对面试岗位，需要额外准备什么材料（如：做设计，是不是要带设计稿？）</li></ul></li></ul><h1 id="人事面试技巧总结"><a href="#人事面试技巧总结" class="headerlink" title="人事面试技巧总结"></a>人事面试技巧总结</h1><ul><li>一定不要将公司的工作当作负担，一定要做好并且学到东西，这才是你下一次跳槽能够展示的东西，所以在公司工作，你拿着工资，而不只是在为公司打工，而是为自己的未来进行修炼，一定要有这方面的意识。总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li><li>人事这关也很重要，特别是工资方面，还有团队，工作方面？(重要)</li><li>对公司的主营业务要表现足够的兴趣，关系公司的发展？</li><li>3面就该和你谈谈钱的事情，你们的重点就是在于薪资，福利和以后的发展，这个时候就是公司对你展示他的潜力了，也是希望能留住你（招人也不容易），那么你对你自己的定位，和你的期望薪资就可以大胆的说出来， 不要因为不好意思而错过你要价的机会，因为一般进入公司后你想涨薪资就比较复杂了，而且这只是你的期望 ，面试官会对你提出他们会给你的工资， 也就是一个讨价还价的过程，总之在这个环节，你可以大胆提出你的期望薪资与发展方向（不要太离谱哈，当然你要作死我也不拦着你），和你的面试官慢慢讨论</li><li>试用期：在这个环节就是心态上注意，技术上展示你的能力，处事上和谐相处，重中之重是在于融入团队，你个人的力量是完不成整个项目的</li><li>对新公司的了解，公司发展情况，业务方向，特长等，如果在企业文化上也有优势，可以多夸下公司的的企业文化</li><li>期望的薪资，最好是了解了工作内容、加班情况、福利情况再谈待遇。最好先了解行情以免太高或太低。不要说太死了，看到对方表情不对就改口说可以商量，或者试探性的问一下对方能否接受，不行就说自己要高工资的原因并说明其实自己更看重发展机会，工资再少点也可以。不要轻易说自己能接受的最低工资，很可能他就给你这个最低的。如果对方能接受你的要求但是觉得有点偏高时，要说明自己凭什么可以拿这么高，并说明自己的优势对岗位的重要性。</li><li>要问公司的问题<ul><li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等。</li><li>所在部门的规模、发展计划，个人的成长机会。</li><li>自己的工作内容及可能的发展机会等。</li><li>向人事提问时最好不要一开始就谈工资，还有不要问太多可能留下不好印象的问题。问最基本的可能影响你去留的问题，其他问题可以进了再问，言多必失</li><li>面试前根据招聘信息的岗位要求多做相应准备</li></ul></li></ul><h4 id="你为什么来北京（城市）发展？"><a href="#你为什么来北京（城市）发展？" class="headerlink" title="你为什么来北京（城市）发展？"></a>你为什么来北京（城市）发展？</h4><ul><li>提出这个问题不要认为胡乱回答就行了，面试官是想看你什么原因，是否稳定。不会有哪家公司找一个很不稳定的人的。回答尽量夸城市，想在这里发展云云</li></ul><h4 id="你离职原因？"><a href="#你离职原因？" class="headerlink" title="你离职原因？"></a>你离职原因？</h4><ul><li>说到这个问题很多人都很头大，换工作的人清楚这个问题基本是必问的一个问题</li><li>这个问题很难回答，为什么呢？因为你如果说是公司的问题，这不好那不好，那么就很危险了，因为面试官会想，以后你从我们公司走出去是不是也这么说我们公司。说因为自己的原因呢，如果没好的理由，面试官也会想如果你来公司因为这些理由离开我公司呢，给人很不稳定的感觉</li><li>一般我会回答公司倒闭或者公司被收购、实习到期或者你本身确实有不得已的理由，比如公司发展和自己的发展不符合，等等，不要直接说公司或者自己的某些原因。除非没有好理由</li></ul><h4 id="为什么来我们公司？我们公司你了解多少？"><a href="#为什么来我们公司？我们公司你了解多少？" class="headerlink" title="为什么来我们公司？我们公司你了解多少？"></a>为什么来我们公司？我们公司你了解多少？</h4><ul><li>问这个就考察你的提前准备的资料了，既然这家公司通知你面试了，你肯定要去查相关资料，不需要详细的，但是你肯定要公司做什么的要知道</li><li>这个要考察自己巴拉巴拉的能力了，比如我觉得公司发展跟我想做的蛮符合的，我想珍惜这个机会…与公司同步发展云云</li></ul><h4 id="你认为你的优点和缺点有哪些？"><a href="#你认为你的优点和缺点有哪些？" class="headerlink" title="你认为你的优点和缺点有哪些？"></a>你认为你的优点和缺点有哪些？</h4><ul><li>不要认为这个问题很简单，吹吹牛就可以了。</li><li>首先你要清楚的知道，你的优点基本能在你工作中用到的，你的缺点千万不能出现在工作中。优点很好说，缺点就很难。优点比如，我工作认真踏实，团队意识强，学习能力强等等等，缺点你怎么说呢？好吃懒做，不思进取。这样回答基本就挂了。你必须自己的缺点和公司无关紧要的，经过面试经验，一般回答你自己生活上的，比如我花钱控制不了那么详细，就会引起对方的兴趣，那你干嘛了？你可以随便说了，我一般控制自己每月花一千，但是朋友聚会花了一千五。对金钱控制不好，这完全不影响你的工作。其他也可以自己想其他理由。</li></ul><h4 id="不知情况乱开价：-—-提前查好对应的工资基本水平"><a href="#不知情况乱开价：-—-提前查好对应的工资基本水平" class="headerlink" title="不知情况乱开价： —-提前查好对应的工资基本水平"></a>不知情况乱开价： —-提前查好对应的工资基本水平</h4><ul><li>说到薪资60%代表你有很大的机会被录用，可是你却狮子大开口的说薪资要求，企业怎么敢用一个漫不符合本身能力的人?如果不想吃亏，应聘前应多打听企业相关信息，不然就采取“依公司规定”的保守战略。不知行情胡乱开价，绝不让你的应聘倒扣200分。</li><li>北京这边的人力资源市场还是非常繁荣的，人才的流动性非常快，每年有两段流动高峰期。<ul><li>通常3<del>4月和9</del>10月是找工作高峰期：<ul><li>3~4月是大量人才拿到年终奖后跳槽的时期；</li><li>9~10月是各大高校毕业生求职时期；</li></ul></li><li>这两段时间都是企业释放大量岗位空缺的时间段，故而是求职旺季。</li></ul></li><li>跳槽也最好在这段时间，其它时间段最好不要跳槽，因为这时：一来岗位无空缺不好招人，二来公司人事会认为你是被裁员工印象不好，这样就不好谈价格了。</li><li>注意公司是以技能需求为驱动在人才市场里面找拥有目标技能的目标人群，而非以你所做项目为驱动，所以在简历里面技能项要分条重点表达，所做项目要辅助技能项做大致表达。</li><li>有些公司在行业里面有地位，是龙头老大，例如BAT、京东等的高并发系统架构方面的业务；平安等互联网金融的支付业务。这些公司的业务代表了行业规范，起到示范作用，能够学习到他们公司的这种权威性的技术或业务，以后可以到想效仿这些公司的其它小公司里面去，就可以有谈判的资本了，这就是在大公司的好处。（这就是为何在BAT工作的人，只要接触了BAT的核心技术，跳出来就那么值钱）</li><li>有些公司的某些部门，明明就不缺人，却天天打着招人的旗号，让人去面试。那么被猎头/人事叫去面试之前，先问了解一些具体情况，有如下一些意识：<ul><li>从岗位角度问： 这个岗位是常年招聘的，还是最近刚招聘的。<ul><li>（如果是常年招聘的，那么最好不要过去了，人家公司上层可能都没有提供新员工名额，让你过去对你的要求是极高，你达到了或许有点希望，而且后面谈工资的时候对自己没有多少优势；如果是最近刚招聘的、岗位急着要人的，那么可以试试。）</li></ul></li><li>从部门角度问： 这个岗位所在的部门是什么情况，是由于业务扩展新成立的，还是一些老的部门。<ul><li>（如果是新成立一个部门，那么确实有可能要进新人，公司可能会放出岗位需求名额；如果是不是新成立的部门，是老部门，那么很可能这个岗位招人就不那么迫切。）</li></ul></li><li>从岗位职责要求角度问： 这个岗位的职责是什么，需要有什么技能的人选。<ul><li>（可以先让跟你打电话的猎头/人事给你发一个JD邮件，你看看是否和你的技能、兴趣相符，如果相符则可以考虑是否过去；如果不相符，你都不知道他看了你的简历后怎么选的你，那你要么回信问清楚为何觉得我合适、贵岗位具体需要什么人做什么事情，如果没回音，就不要再管了，他们不要人的。不要怕把他们问烦了，他们如果真的缺人，那么不怕你多问，还怕你不来呢，问两句就烦，直接就说明他们本来就不确认，你去不去面试对他们影响不大。）</li></ul></li><li>面试过程中要有警觉： 如果最终还是去了，那么面试过程中也可以看到他们是否缺人。如果面试官上来就问你以前的项目，要你给他详细讲解，那么多半想把你当成免费的”老师“，你可以准备好一些素材给他讲；他问你有没有什么要问他的，你可以问他们要什么样技能的人，如果他们说的空泛不具体，不说需要具体掌握什么技能的，就是他们自己都不能详细表达岗位需求，那多半也不缺人。</li></ul></li><li>为何有些公司要这样“挖坑挖 ”呢？为何要设置那些长期招聘的岗位呢？ 呢<ul><li>第一、未雨绸缪。如果公司认为过段时间有人会离职，尤其是发完年终奖之前，那么就会提前做好准备，去招新人减少风险，而老员工未走新员工的招聘进度可以慢一点来。</li><li>第二、降低人力成本。如果公司当前人力成本太高，那么就想淘汰部分高价的老员工换来廉价新员工，那么会在老员工走之前招人，而新员工的招聘也可以慢一点来，招的到就招，招不到就不招，总之价格要压低。（这样的公司卸磨杀驴，不去也罢）</li><li>第三、换血。如果公司的部门当前好久没有换血了，对部门不是太有利，那么也是常年打着招聘的旗号招人，碰到真正有料的人选，如果成功压低了价格，也可以招进来，但公司不太缺人的情况下，不招也行。</li><li>第四、了解行业动态。这主要是部门某些人心术不正，让面试者赶来面试，当免费老师，以面试为名从面试者口中获取一些其它公司的技术内幕。（搞技术的人都不傻，出来混迟早要还的，心术不正败坏的是自己公司的名声。）</li></ul></li><li>面试官问你的职业规划？该怎么回答？回答这个问题要注意三点：<ul><li>接地气。也就是实实在在的说，不做作。这应该是在跟HR交流各个问题都要注意的，不要去学习面经上那些头头是道的回答，针对性并不强，不能把自己的特质表露出来，这对应聘双方都是无益的。搞清楚自己的想法，流畅的表达就行了（表达上也许需要一些技巧），至于如何搞清楚自己的想法，请看第二点。</li><li>预先做功课。了解自己和了解社会是一生都不应该停止的两个过程。在应聘之前，需要对自己和要应聘的行业、公司、岗位都有一定的了解，知道自己的兴趣点和竞争优势，在这个基础上才能够谈职业规划。</li><li>区分职业和工作。HR问你职业规划，也许只是在探寻你对这个岗位或公司的热衷度，判断你是无关痛痒的仅仅想要一份工作安身，还是对未来的发展有一定的方向，方向和目标自然不可能太具体，所以觉得难回答，但是，面试官想知道的其实是你对自己未来的期许是什么样子的，仅此而已。</li><li>参考：我希望在 我 **公司发展成为 公 “T”字形人才，短期目标，我希望能够接触尽可能多的知识面，努力扩展自己专业技能的 字 “横”，可以独立的完成工作中的每一个任务。长期目标，我希望自己在知识面足够宽的基础上，能够有一到两个方向的深入研究，深入自己工作中的一 长 ”竖“，早日独当一面，成为公司的中流砥柱，</li></ul></li></ul><h4 id="人事问工资该如何回答？"><a href="#人事问工资该如何回答？" class="headerlink" title="人事问工资该如何回答？"></a>人事问工资该如何回答？</h4><ul><li>2年工作经验：<ul><li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等</li><li>工作的内容，公司的发展</li><li>半年的时候去做大数据项目后加过一次薪，9000加到了12000.</li><li>12K——-17K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1000左右</li></ul></li><li>3年工作经验：<ul><li>17K——–23K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1400左右</li><li>具体的情况，根据面试的好坏做相应的调整，但是工资的税前和税后差额一般在2k—3k</li></ul></li><li>面试的本质不是一问一答，而是亮点展示</li></ul><h1 id="请介绍一下你自己"><a href="#请介绍一下你自己" class="headerlink" title="请介绍一下你自己"></a>请介绍一下你自己</h1><ul><li>这是面试官100%会问的问题，一般人回答这个问题过于平常，只说姓名、年龄、爱好、所学专业等，如果你用一分钟来重复你的简历，那么，你的印象加分没有了！</li><li>不妨坦诚自信地展现自我，重点突出与应聘职位相吻合的优势。你的相关能力和素质是企业最感兴趣的信息。因为，在许多情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。</li><li>回答范例：我叫XX，今年X岁，XXXX年毕业于XX大学。有3年的开发工作经验，我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，精通.Net技术体系，熟悉MVC。平常有时间看看博客，并且自己也喜欢在CSDN上写技术类的文章，与博友一起讨论。谢谢！</li></ul><h1 id="为什么来北京找工作？"><a href="#为什么来北京找工作？" class="headerlink" title="为什么来北京找工作？"></a>为什么来北京找工作？</h1><ul><li>面试官对异地求职者90%都会问的问题，主要考察你是否稳定，个人经验能力之外，排在第一位的就是稳定性，如果不够稳定，那么其余都是空谈。</li><li>回答范例：我来自河南，河南是一个农业大省，IT行业还不是很发达，我是学计算机专业的，也很喜欢这个行业，北京在国内IT行业发展是最快的，所以我想来这里谋求发展，学习更多的新技术，能够带来自我的提升。</li><li>注意：不要说以前公司有多么不好。也不要说哪个哥们混的很不错，羡慕才来北京。因为企业招人想要的都是能够长期工作的人，可能哪个哥们哪天在别的地方又混的更好了，你是不是还要跳槽？所以，只要说来学习更多新技术和管理经验就够了。</li></ul><h1 id="你为什么离开原来的公司？"><a href="#你为什么离开原来的公司？" class="headerlink" title="你为什么离开原来的公司？"></a>你为什么离开原来的公司？</h1><ul><li>最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在</li><li>避免把“离职原因”说得太详细、太具体</li><li>不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等</li><li>但也不能躲闪、回避，如“想换换环境”、“个人原因”等</li><li>不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等</li><li>尽量使解释的理由为应聘者个人形象添彩</li><li>相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</li><li>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。</li></ul><h1 id="你最大的缺点是什么？"><a href="#你最大的缺点是什么？" class="headerlink" title="你最大的缺点是什么？"></a>你最大的缺点是什么？</h1><ul><li>被面试官问的概率很大，也是HR的杀手锏和狠招，这个问题最难回答，通常面试官不希望听到求职直接回答的缺点是什么，如果求职者说自己小心眼、脾气大、工作效率低，企业肯定不会录用你。不要自作聪明地回答“我最大的缺点就是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。面试官喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上，突出优点的部分，面试官喜欢聪明的求职者。</li><li>回答范例：这个问题好难回答啊！我想想……（亲和力表现，也缓解了自己的紧张情绪）我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。</li></ul><h1 id="你未来3-5年的职业规划是怎样的？"><a href="#你未来3-5年的职业规划是怎样的？" class="headerlink" title="你未来3-5年的职业规划是怎样的？"></a>你未来3-5年的职业规划是怎样的？</h1><ul><li>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</li><li>回答范例：我希望从现在开始，1-2年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以从开发做到架构师。同时我也希望自己能够在企业的平台上得到进一步的职业能力提升。</li></ul><h1 id="你对薪资的要求？"><a href="#你对薪资的要求？" class="headerlink" title="你对薪资的要求？"></a>你对薪资的要求？</h1><ul><li>如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求职的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</li><li>回答范例一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。</li><li>如果你必须自己说出具体数目，那就不要说一个宽泛的范围，不要说7000-8000之间，那样你将只会得到最低限底的数字，也就是7000。最好给出一个具体的数字。</li></ul><h1 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h1><ul><li>大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司的规定上班”，如果还未辞去上一个工作，但上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</li></ul><h1 id="介绍一个你认为最熟悉的项目（项目经理）"><a href="#介绍一个你认为最熟悉的项目（项目经理）" class="headerlink" title="介绍一个你认为最熟悉的项目（项目经理）"></a>介绍一个你认为最熟悉的项目（项目经理）</h1><ul><li>这个问题在技术面试时常被问到，问这个问题的意图是想考察你的成长路径和编程习惯，因为，你最熟悉的项目往往是你成长最快的项目，那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹。所以，通过你对熟悉项目的描述，有经验的他会很快锁定你技术成长中的缺陷和闪光点，从而判断是否能够“为我所用”。</li><li>你最好拿出一个自己最擅长技术的那个项目进行介绍，他听完你的介绍后，会接下来进行提问，这样他所有问的问题，你都成竹在胸了。</li><li>切忌拿自己参与很少的项目来介绍，一旦他深入的询问很可能你会答非所问，反而造成更严重的影响。你大强以和他谈谈在那个项目中获得的经验，这样会引起此君的共鸣，有可能的话，说出一些你自己的小技巧，他会很高兴，同时这场面试也会很轻松，拿到Offer基本没问题了。</li></ul><h1 id="如果公司录用你，你将怎样开展工作？"><a href="#如果公司录用你，你将怎样开展工作？" class="headerlink" title="如果公司录用你，你将怎样开展工作？"></a>如果公司录用你，你将怎样开展工作？</h1><ul><li>很多企业在招聘开发人员时很看重是否能够尽快上手，所以回答这个问题时要“实打实”的回答，在回答中最好强调能够“尽快”投入开发工作中，这样领导就放心了，会觉得你不是一个只会盲目工作的人，而是一个按部就班，稳打稳扎的人。</li><li>回答范例：我对咱们公司的大体情况只有一个大概了解，在这个职位的工作性质仅仅是我自己的一个理解。作为这个职位而言，我想我首先要对本公司的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向、我们面向的客户性质等。第二我要了解所属部门在公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。第三，了解我参与项目的开发方式，架构方式，紧密配合领导工作，尽快投入具体的开发工作中。这就是我开展工作的计划。</li></ul><h1 id="你还有什么问题问我吗？"><a href="#你还有什么问题问我吗？" class="headerlink" title="你还有什么问题问我吗？"></a>你还有什么问题问我吗？</h1><ul><li>这个问题看上去可有可无，其实很关键，面试官不喜欢说“没有问题”的人，没有问题就是自寻死路，没有问题传达出你对公司缺乏兴趣，而只是来寻找一笔薪水。其实在面试过程中谦虚礼貌的问面试官怎么称呼，该部门工作中的信息，如项目情况，开发技术再或者说贵公司的晋升机制是什么样的等。表现出一种很积极主动的状态是非常讨巧的。也可以更多的了解到自己来的工作环境。企业很欢迎这样的求职者，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</li></ul><h1 id="你对加班的看法？"><a href="#你对加班的看法？" class="headerlink" title="你对加班的看法？"></a>你对加班的看法？</h1><ul><li>实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。</li><li>回答范例：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</li></ul><h1 id="你朋友对你的评价？"><a href="#你朋友对你的评价？" class="headerlink" title="你朋友对你的评价？"></a>你朋友对你的评价？</h1><ul><li>回答提示： 想从侧面了解一下你的性格及与人相处的问题。</li><li>回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。</li><li>回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。</li></ul><h1 id="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"><a href="#如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？" class="headerlink" title="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"></a>如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</h1><ul><li>回答提示：一段时间发现工作不适合我，有两种情况：<ul><li>如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</li><li>你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</li></ul></li></ul><h1 id="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"><a href="#在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？" class="headerlink" title="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"></a>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</h1><ul><li>原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。</li><li>如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。</li><li>还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</li></ul><h1 id="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"><a href="#如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？" class="headerlink" title="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"></a>如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</h1><ul><li>我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。</li><li>分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。</li><li>总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</li></ul><h1 id="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"><a href="#如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？" class="headerlink" title="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"></a>如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</h1><ul><li>我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：<ul><li>我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。</li><li>他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</li></ul></li></ul><h1 id="谈谈你对跳槽的看法？"><a href="#谈谈你对跳槽的看法？" class="headerlink" title="谈谈你对跳槽的看法？"></a>谈谈你对跳槽的看法？</h1><ul><li>正常的“跳槽”能促进人才合理流动，应该支持。</li><li>频繁的跳槽对单位和个人双方都不利，应该反对。</li></ul><h1 id="工作中你难以和同事、上司相处，你该怎么办？"><a href="#工作中你难以和同事、上司相处，你该怎么办？" class="headerlink" title="工作中你难以和同事、上司相处，你该怎么办？"></a>工作中你难以和同事、上司相处，你该怎么办？</h1><ul><li>我会服从领导的指挥，配合同事的工作。</li><li>我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话 我会努力改正。</li><li>如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。</li><li>作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。</li></ul><h1 id="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"><a href="#假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？" class="headerlink" title="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"></a>假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</h1><ul><li>成绩比较突出，得到领导的肯定是件好事情，以后更加努力。</li><li>检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。</li><li>工作中，切勿伤害别人的自尊心。</li><li>不再领导前拨弄是非。<br>。<h1 id="请说出你选择这份工作的动机？"><a href="#请说出你选择这份工作的动机？" class="headerlink" title="请说出你选择这份工作的动机？"></a>请说出你选择这份工作的动机？</h1></li><li>这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</li></ul><h1 id="你最擅长的技术方向是什么？"><a href="#你最擅长的技术方向是什么？" class="headerlink" title="你最擅长的技术方向是什么？"></a>你最擅长的技术方向是什么？</h1><ul><li>说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</li></ul><h1 id="你能为我们公司带来什么呢？"><a href="#你能为我们公司带来什么呢？" class="headerlink" title="你能为我们公司带来什么呢？"></a>你能为我们公司带来什么呢？</h1><ul><li>企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</li></ul><h1 id="最能概括你自己的三个词是什么？"><a href="#最能概括你自己的三个词是什么？" class="headerlink" title="最能概括你自己的三个词是什么？"></a>最能概括你自己的三个词是什么？</h1><ul><li>我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，</li></ul><h1 id="你的业余爱好是什么？"><a href="#你的业余爱好是什么？" class="headerlink" title="你的业余爱好是什么？"></a>你的业余爱好是什么？</h1><ul><li>找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。</li></ul><h1 id="作为被面试者给我打一下分？"><a href="#作为被面试者给我打一下分？" class="headerlink" title="作为被面试者给我打一下分？"></a>作为被面试者给我打一下分？</h1><ul><li>试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</li></ul><h1 id="你怎么理解你应聘的职位？"><a href="#你怎么理解你应聘的职位？" class="headerlink" title="你怎么理解你应聘的职位？"></a>你怎么理解你应聘的职位？</h1><ul><li>把岗位职责和任务及工作态度阐述一下。</li></ul><h1 id="喜欢这份工作的哪一点？"><a href="#喜欢这份工作的哪一点？" class="headerlink" title="喜欢这份工作的哪一点？"></a>喜欢这份工作的哪一点？</h1><ul><li>相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</li></ul><h1 id="说说你对行业、技术发展趋势的看法？"><a href="#说说你对行业、技术发展趋势的看法？" class="headerlink" title="说说你对行业、技术发展趋势的看法？"></a>说说你对行业、技术发展趋势的看法？</h1><ul><li>企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</li></ul><h1 id="对工作的期望与目标何在？"><a href="#对工作的期望与目标何在？" class="headerlink" title="对工作的期望与目标何在？"></a>对工作的期望与目标何在？</h1><ul><li>这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</li></ul><h1 id="说你的家庭"><a href="#说你的家庭" class="headerlink" title="说你的家庭"></a>说你的家庭</h1><ul><li>企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。</li><li>企业希望听到的重点也在于家庭对求职者的积极影响。</li><li>企业最喜欢听到的是：我很爱我的家庭，我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。</li><li>我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。</li><li>企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</li></ul><h1 id="就你申请的这个职位，你认为你还欠缺什么？"><a href="#就你申请的这个职位，你认为你还欠缺什么？" class="headerlink" title="就你申请的这个职位，你认为你还欠缺什么？"></a>就你申请的这个职位，你认为你还欠缺什么？</h1><ul><li>企业喜欢问求职者弱点，但精明的求职者一般不直接回答。</li><li>他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</li></ul><h1 id="你欣赏哪种性格的人？"><a href="#你欣赏哪种性格的人？" class="headerlink" title="你欣赏哪种性格的人？"></a>你欣赏哪种性格的人？</h1><ul><li>诚实、不死板而且容易相处的人、有“实际行动”的人。</li></ul><h1 id="你通常如何处理別人的批评？"><a href="#你通常如何处理別人的批评？" class="headerlink" title="你通常如何处理別人的批评？"></a>你通常如何处理別人的批评？</h1><ul><li>沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。</li><li>我会等大家冷靜下来再讨论。</li></ul><h1 id="你为什么愿意到我们公司来工作？"><a href="#你为什么愿意到我们公司来工作？" class="headerlink" title="你为什么愿意到我们公司来工作？"></a>你为什么愿意到我们公司来工作？</h1><ul><li>对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</li></ul><h1 id="你和别人发生过争执吗？你是怎样解决的？"><a href="#你和别人发生过争执吗？你是怎样解决的？" class="headerlink" title="你和别人发生过争执吗？你是怎样解决的？"></a>你和别人发生过争执吗？你是怎样解决的？</h1><ul><li>这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。</li><li>你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。</li><li>他们通过这个问题了解你的成熟度和处世能力。</li><li>在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</li></ul><h1 id="问题：你做过的哪件事最令自己感到骄傲？"><a href="#问题：你做过的哪件事最令自己感到骄傲？" class="headerlink" title="问题：你做过的哪件事最令自己感到骄傲？"></a>问题：你做过的哪件事最令自己感到骄傲？</h1><ul><li>这是考官给你的一个机会，让你展示自己把握命运的能力。</li><li>这会体现你潜在的领导能力以及你被提升的可能性。</li><li>假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐</li><li>记住：你的前途取决于你的知识、你的社交能力和综合表现。</li></ul><h1 id="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"><a href="#新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？" class="headerlink" title="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"></a>新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？</h1><ul><li>首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。</li><li>其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。</li><li>再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。</li><li>再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。</li><li>我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。</li></ul><h1 id="对这项工作，你有哪些可预见的困难？"><a href="#对这项工作，你有哪些可预见的困难？" class="headerlink" title="对这项工作，你有哪些可预见的困难？"></a>对这项工作，你有哪些可预见的困难？</h1><ul><li>不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。</li><li>可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。</li><li>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。</li><li>当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</li></ul><h1 id="怎样对待自己的失敗？"><a href="#怎样对待自己的失敗？" class="headerlink" title="怎样对待自己的失敗？"></a>怎样对待自己的失敗？</h1><ul><li>我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</li></ul><h1 id="什么会让你有成就感？"><a href="#什么会让你有成就感？" class="headerlink" title="什么会让你有成就感？"></a>什么会让你有成就感？</h1><ul><li>为贵公司竭力效劳，尽我所能，完成一个项目。</li></ul><h1 id="眼下你生活中最重要的是什么？"><a href="#眼下你生活中最重要的是什么？" class="headerlink" title="眼下你生活中最重要的是什么？"></a>眼下你生活中最重要的是什么？</h1><ul><li>对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。</li></ul><h1 id="与上级意见不一是，你将怎么办？"><a href="#与上级意见不一是，你将怎么办？" class="headerlink" title="与上级意见不一是，你将怎么办？"></a>与上级意见不一是，你将怎么办？</h1><ul><li><p>一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</p></li><li><p>如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</p></li><li><p>分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p></li><li><p>你工作经验欠缺，如何能胜任这项工作？</p></li><li><p>如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。</p></li><li><p>对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。</p></li><li><p>如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</p></li><li><p>点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p></li></ul><h1 id="你希望与什么样的上级共事？"><a href="#你希望与什么样的上级共事？" class="headerlink" title="你希望与什么样的上级共事？"></a>你希望与什么样的上级共事？</h1><ul><li>通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。</li><li>最好回避对上级具体的希望，多谈对自己的要求。</li><li>如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。</li><li>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</li></ul><h1 id="谈谈如何适应办公室工作的新环境？"><a href="#谈谈如何适应办公室工作的新环境？" class="headerlink" title="谈谈如何适应办公室工作的新环境？"></a>谈谈如何适应办公室工作的新环境？</h1><ul><li>办公室里每个人有各自的岗位与职责，不得擅离岗位。</li><li>根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。</li><li>多请示并及时汇报，遇到不明白的要虚心请教。</li><li>抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</li></ul><h1 id="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"><a href="#为了做好你工作份外之事，你该怎样获得他人的支持和帮助？" class="headerlink" title="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"></a>为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</h1><ul><li>每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</li></ul><h1 id="如果你在这次面试中没有被录用，你怎么打算？"><a href="#如果你在这次面试中没有被录用，你怎么打算？" class="headerlink" title="如果你在这次面试中没有被录用，你怎么打算？"></a>如果你在这次面试中没有被录用，你怎么打算？</h1><ul><li>现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。</li><li>我会从以下几个方面来正确看待这次失败：<ul><li>要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。</li><li>善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。</li><li>走出阴影，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。</li><li>认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的成绩。</li><li>再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞争。</li></ul></li></ul><h1 id="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"><a href="#假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？" class="headerlink" title="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"></a>假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？</h1><ul><li>我觉得工作是第一位的，但朋友间的情谊也是不能偏废的，这个问题我觉得要按照当时具体的情况来决定。</li><li>如果我的朋友晚上9点中的飞机，而我的加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。</li><li>如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。</li><li>如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。<ul><li>如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。</li><li>如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，相信他会理解，毕竟工作做完了就完了，朋友还是可以再见面的。</li></ul></li></ul><h1 id="谈谈你过去做过的成功案例？"><a href="#谈谈你过去做过的成功案例？" class="headerlink" title="谈谈你过去做过的成功案例？"></a>谈谈你过去做过的成功案例？</h1><ul><li>举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。</li><li>切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</li></ul><h1 id="谈谈你过去的工作经验中，最令你挫折的事情？"><a href="#谈谈你过去的工作经验中，最令你挫折的事情？" class="headerlink" title="谈谈你过去的工作经验中，最令你挫折的事情？"></a>谈谈你过去的工作经验中，最令你挫折的事情？</h1><ul><li>曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。</li><li>分析：借此了解你对挫折的容忍度及调解方式。</li></ul><h1 id="如何安排自己的时间？会不会排斥加班？"><a href="#如何安排自己的时间？会不会排斥加班？" class="headerlink" title="如何安排自己的时间？会不会排斥加班？"></a>如何安排自己的时间？会不会排斥加班？</h1><ul><li>基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。</li><li>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</li></ul><h1 id="为什么我们要在众多的面试者中选择你？"><a href="#为什么我们要在众多的面试者中选择你？" class="headerlink" title="为什么我们要在众多的面试者中选择你？"></a>为什么我们要在众多的面试者中选择你？</h1><ul><li>根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、ＥＱ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。</li><li>分析：别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。</li></ul><h1 id="你并非毕业于名牌院校？"><a href="#你并非毕业于名牌院校？" class="headerlink" title="你并非毕业于名牌院校？"></a>你并非毕业于名牌院校？</h1><ul><li>是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我想我更适合贵公司这个职位。</li></ul><h1 id="怎样看待学历和能力？"><a href="#怎样看待学历和能力？" class="headerlink" title="怎样看待学历和能力？"></a>怎样看待学历和能力？</h1><ul><li>学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？</li></ul><h1 id="工作中学习到了些什么？"><a href="#工作中学习到了些什么？" class="headerlink" title="工作中学习到了些什么？"></a>工作中学习到了些什么？</h1><ul><li>这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</li></ul><h1 id="想过创业吗？"><a href="#想过创业吗？" class="headerlink" title="想过创业吗？"></a>想过创业吗？</h1><ul><li>这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？</li></ul><h1 id="除了本公司外，还应聘了哪些公司？"><a href="#除了本公司外，还应聘了哪些公司？" class="headerlink" title="除了本公司外，还应聘了哪些公司？"></a>除了本公司外，还应聘了哪些公司？</h1><ul><li>很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</li></ul><h1 id="面试注意事项："><a href="#面试注意事项：" class="headerlink" title="面试注意事项："></a>面试注意事项：</h1><ul><li>在面试官面前千万不要抖脚，手脚不要动来动去，不能有小动作。</li><li>在面试过程中，千万不要跟面试官去争论，说话太冲，太能说、抢话说、乱说都不好，遇到难题，先思考一下，切记心浮气燥，表达时口气温和，谦虚。</li><li>如果面试过程中都不错，谈的也很好，之后却没有给Offer，完全是自己意料之外的情况，这个很有可能，或许是因为公司有了其他的人选，不用介意，更不要沮丧。</li><li>在面试过程中，切忌问关于公司计划、行业机密等相关的东西，不要打探公司的内幕，机密敏感性的问题不要问东问西。</li><li>千万要注意仪容仪表，要有礼貌，最好不要有口吃，口头表达，逻辑思维很重要，不要让面试官觉得你很幼稚，太过小孩子气，显的不够稳重踏实。</li><li>在去面试之前，要熟悉自己的简历，特别是工作经历，准备好关于一些离职原因、职业规划方面的问题的回答方式。</li><li>在面试过程中，80%的面试官会让做自我介绍，所以提前要准备一下，说出的内容既要和简历相符，又要有重点有突出的地方，不能像背简历一样。</li><li>面试完后，如果等待的时间较长，没有回应，就可能没有什么希望了，自己可以打电话去了解情况。</li><li>在面试过程中，谈到薪资的时候，如果没有说明是税后工资就是税前，假如是税前6000，这里面就包括了公司给交的公积金，还有其他五险要交的费用，拿到手差不多4000左右。</li></ul><h1 id="投递简历注意事项"><a href="#投递简历注意事项" class="headerlink" title="投递简历注意事项"></a>投递简历注意事项</h1><ul><li>投简历的时间最好在早上8点多钟，因为人事9点多开始收简历，收到的简历又都是按时间来排序的，所以一般早上8点到9点投的都会排在前面，人事当天就能看到。</li><li>写简历：<ul><li>现居住地最好能在企业附近，如果不在，只写北京，人事比较看重现居住地，如果你填写的现居地离公司远，基本上人事就不太愿意打电话了，因为她（他）怕你不会来。</li><li>期望薪资最好不要写在简历上，也不要填写在网上的简历上，具体薪资见面的时候再谈。</li><li>大部分的岗位招聘都有相应的硬性要求，比如：年龄、居住地点、工作年限等。如果自己不符合也没有关系，机会还有很多。</li><li>简历上的工作经历不能太多，否则人事会觉得你不够稳定。</li><li>开发工作，简历上的项目要抓住重点，放重要的技术点，不能千篇一律，简短、抓住中心。</li></ul></li></ul><h1 id="入职后试用期："><a href="#入职后试用期：" class="headerlink" title="入职后试用期："></a>入职后试用期：</h1><ul><li>到了公司之后，工作中不懂的地方要多问，跟同事搞好关系，多看看旁人在干什么～</li><li>有些同学被录用之后都还不知道自己的薪资待遇，也不知道公司有哪些福利，这是因为在面试过程中不敢多问。因此，如果在面试过程中，面试官已经比较明确的表达了想让你去上班后，你就可以在适当的时候问一些关于工作的情况，工资、福利待遇，上班时间，加班情况等等。</li></ul><h1 id="上家公司的组成架构"><a href="#上家公司的组成架构" class="headerlink" title="上家公司的组成架构"></a>上家公司的组成架构</h1><ul><li>根据你的公司来定即可</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span><a class="page-number" href="/default-index/page/3/">3</a><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/3/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>