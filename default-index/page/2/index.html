<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/2/index.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/2/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">28</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">47</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/f17ba5c005d6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/f17ba5c005d6.html" class="post-title-link" itemprop="url">Linux</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:14:12" itemprop="dateCreated datePublished" datetime="2023-12-20T16:14:12+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 11:46:25" itemprop="dateModified" datetime="2023-12-24T11:46:25+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="使⽤两种命令创建⼀个⽂件？"><a href="#使⽤两种命令创建⼀个⽂件？" class="headerlink" title="使⽤两种命令创建⼀个⽂件？"></a>使⽤两种命令创建⼀个⽂件？</h1><ul><li>touch a.txt</li><li>vi a.txt</li><li>mkdir abc</li><li>cat &gt; a.txt 建⽴⼀⽂件，然后把接下来的键盘输⼊写⼊⽂件，直到按Ctrl+D为⽌.</li></ul><h1 id="硬链接和软连接的区别？"><a href="#硬链接和软连接的区别？" class="headerlink" title="硬链接和软连接的区别？"></a>硬链接和软连接的区别？</h1><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul><li>⽂件有相同的 inode 及 data block；</li><li>只能对已存在的⽂件进⾏创建；</li><li>不能交叉⽂件系统进⾏硬链接的创建；</li><li>不能对⽬录进⾏创建，只可对⽂件创建；</li><li>删除⼀个硬链接⽂件并不影响其他有相同 inode 号的⽂件。</li></ul><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><ul><li>软链接有⾃⼰的⽂件属性及权限等；</li><li>可对不存在的⽂件或⽬录创建软链接；</li><li>软链接可交叉⽂件系统；</li><li>软链接可对⽂件或⽬录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的⽂件，但若被指向的原⽂件被删除，则相关软连接被称为死链接（即 dangling<br>link，若被指向路径⽂件被重新创建，死链接可恢复为正常的软链接）。</li></ul><h1 id="linux常⽤命令有哪些"><a href="#linux常⽤命令有哪些" class="headerlink" title="linux常⽤命令有哪些"></a>linux常⽤命令有哪些</h1><ul><li>查找关闭端⼝进程 netstat -nlp | grep :3306 kill pid</li><li>删除⽂件 rm -rf</li><li>查找⽇志 cat xx.log | grep ‘xxx’ | more</li><li>解压tar.gz tar -xzvf file.tar.gz</li><li>创建⽂件 touch filename cat &gt; filename</li><li>修改⽂件 vi</li></ul><h1 id="怎么查看⼀个java线程的资源耗⽤"><a href="#怎么查看⼀个java线程的资源耗⽤" class="headerlink" title="怎么查看⼀个java线程的资源耗⽤"></a>怎么查看⼀个java线程的资源耗⽤</h1><ul><li>linux下，所有的java内部线程，其实都对应了⼀个进程id，也就是说，linux上的jvm将java程序中的线程映射为操作系统进程。</li><li>jps -lvm或者ps -ef | grep java查看当前机器上运⾏的Java应⽤进程</li><li>top -Hp pid可以查看Java所有线程的资源耗⽤</li><li>printf “%x\n” pid等到线程ID的16进制</li><li>jstack Java应⽤进程ID | grep 线程ID的16进制</li></ul><h1 id="Load过⾼的可能性有哪些？"><a href="#Load过⾼的可能性有哪些？" class="headerlink" title="Load过⾼的可能性有哪些？"></a>Load过⾼的可能性有哪些？</h1><ul><li>cpu load的飙升，⼀⽅⾯可能和full gc的次数增⼤有关，⼀⽅⾯可能和死循环有关系</li></ul><h1 id="etc-hosts⽂件什么作⽤"><a href="#etc-hosts⽂件什么作⽤" class="headerlink" title="&#x2F;etc&#x2F;hosts⽂件什么作⽤"></a>&#x2F;etc&#x2F;hosts⽂件什么作⽤</h1><ul><li>在当前主机给ip设置别名，通过该别名可以访问到该ip地址，通过别名、ip访问的效果是⼀样的</li></ul><h1 id="如何快速的将⼀个⽂本中的”abc”转换成”xyz”？"><a href="#如何快速的将⼀个⽂本中的”abc”转换成”xyz”？" class="headerlink" title="如何快速的将⼀个⽂本中的”abc”转换成”xyz”？"></a>如何快速的将⼀个⽂本中的”abc”转换成”xyz”？</h1><ul><li>vi filename编辑⽂本，按Esc键，输⼊:%s&#x2F;abc&#x2F;xyz&#x2F;g</li></ul><h1 id="如何在log⽂件中搜索找出error的⽇志？"><a href="#如何在log⽂件中搜索找出error的⽇志？" class="headerlink" title="如何在log⽂件中搜索找出error的⽇志？"></a>如何在log⽂件中搜索找出error的⽇志？</h1><ul><li>cat xx.log | grep ‘error’</li></ul><h1 id="发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件"><a href="#发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件" class="headerlink" title="发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件?"></a>发现硬盘空间不够，如何快速找出占⽤空间最⼤的⽂件?</h1><ul><li>find . -type f -size +100M | xargs du -h | sort -nr</li></ul><h1 id="Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）"><a href="#Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）" class="headerlink" title="Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）"></a>Java服务端问题排查（OOM，CPU⾼，Load⾼，类冲突）</h1><h4 id="业务⽇志相关"><a href="#业务⽇志相关" class="headerlink" title="业务⽇志相关"></a>业务⽇志相关</h4><ul><li>less或者more</li><li>grep</li><li>tail -f filename</li><li>切忌vim直接打开⼤⽇志⽂件，因为会直接加载到内存的</li></ul><h4 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h4><ul><li>登录线上库，show processlist查看数据库连接情况</li></ul><h4 id="jvm相关："><a href="#jvm相关：" class="headerlink" title="jvm相关："></a>jvm相关：</h4><ul><li>jps显示java进程</li><li>jinfo实时查看和调整jvm参数</li><li>jstat监控jvm各种运⾏状态信息；</li><li>jstack(Stack Trace for Java)命令⽤于⽣成JVM进程当前时刻的线程的调⽤堆栈，可以⽤来定位线程间死锁、<br>锁等待、等待外部资源等</li><li>jmap(Memory Map for Java) 命令⽤于⽣成堆转储快照dump⽂件，除了这种⽅式还可以通过-<br>XX:HeapDumpOnOutOfMemoryError参数，可以在虚拟机发⽣OOM的时候⾃动⽣成堆的dump⽂件，或者kill -3<br>命令发出进程退出信号”吓唬”⼀下虚拟机，也能拿到dump⽂件。</li></ul><h4 id="oom问题："><a href="#oom问题：" class="headerlink" title="oom问题："></a>oom问题：</h4><ul><li>配置了-XX:+HeapDumpOnOutOfMemoryError, 在发⽣OOM的时候会在-XX:HeapDumpPath⽣成堆的dump⽂<br>件，结合MAT，可以对dump⽂件进⾏分析，查找出发⽣OOM的原因。</li><li>另外⼿动dump堆快照，可以使⽤命令jmap -dump:format&#x3D;b,file&#x3D;file_name pid 或者kill -3 pid</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>jps -v</li><li>jstack -l pid</li></ul><h4 id="线程block、线程数暴涨："><a href="#线程block、线程数暴涨：" class="headerlink" title="线程block、线程数暴涨："></a>线程block、线程数暴涨：</h4><ul><li>jstack -l pid |wc -l</li><li>jstack -l pid |grep “BLOCKED”|wc -l</li><li>jstack -l pid |grep “Waiting on condition”|wc -l<br>线程block问题⼀般是等待io、等待⽹络、等待监视器锁等造成，可能会导致请求超时、造成造成线程数暴涨导致系统502等。</li></ul><h4 id="服务器问题："><a href="#服务器问题：" class="headerlink" title="服务器问题："></a>服务器问题：</h4><h5 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h5><ul><li>top</li></ul><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><ul><li>free -m -c10 -s1：<ul><li>-m：以MB为单位显示，其他的有-k -g -b</li><li>-s: 间隔多少秒持续观察内存使⽤状况</li><li>-c:观察多少次</li></ul></li><li>vmstat 1 10：1表示每隔1s输出⼀次,10 表示输出10次<ul><li>r: 运⾏队列中进程数量，这个值也可以判断是否需要增加CPU。（⻓期⼤于1）</li><li>b: 等待IO的进程数量。</li></ul></li></ul><h5 id="io"><a href="#io" class="headerlink" title="io"></a>io</h5><ul><li>iostat -m 1 10：<ul><li>-m：某些使⽤block为单位的列强制使⽤MB为单位</li><li>1 10：数据显示每隔1秒刷新⼀次，共显示10次</li></ul></li></ul><h5 id="⽹络"><a href="#⽹络" class="headerlink" title="⽹络"></a>⽹络</h5><ul><li>netstat -antp：<ul><li>-a (all)显示所有选项，默认不显示LISTEN相关</li><li>-t (tcp)仅显示tcp相关选项</li><li>-u (udp)仅显示udp相关选项</li><li>-n 拒绝显示别名，能显示数字的全部转化成数字。</li><li>-l 仅列出有在 Listen (监听) 的服服务状态</li><li>-p 显示建⽴相关链接的程序名</li></ul></li></ul><h1 id="Thread-dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）"><a href="#Thread-dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）" class="headerlink" title="Thread dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）"></a>Thread dump⽂件如何分析（Runnable，锁，代码栈，操作系统线程id关联）</h1><h4 id="Thread-Dump-能诊断的问题"><a href="#Thread-Dump-能诊断的问题" class="headerlink" title="Thread Dump 能诊断的问题"></a>Thread Dump 能诊断的问题</h4><ul><li>查找内存泄露，常⻅的是程序⾥load⼤量的数据到缓存；</li><li>发现死锁线程；</li></ul><h4 id="如何抓取Thread-Dump信息："><a href="#如何抓取Thread-Dump信息：" class="headerlink" title="如何抓取Thread Dump信息："></a>如何抓取Thread Dump信息：</h4><ul><li>⼀般当服务器挂起,崩溃或者性能底下时,就需要抓取服务器的线程堆栈(Thread Dump)⽤于后续的分析. 在实际运⾏中，往往⼀次 dump的信息，还不⾜以确认问题。为了反映线程状态的动态变化，需要接连多次做threaddump，每次间隔10-20s，建议⾄少产⽣三次 dump信息，如果每次 dump都指向同⼀个问题，我们才确定问题的典型性。</li></ul><h4 id="linux命令获取"><a href="#linux命令获取" class="headerlink" title="linux命令获取"></a>linux命令获取</h4><ul><li>ps –ef | grep java</li><li>kill -3<pid></pid></li></ul><h4 id="jdk⾃带⼯具获取"><a href="#jdk⾃带⼯具获取" class="headerlink" title="jdk⾃带⼯具获取"></a>jdk⾃带⼯具获取</h4><ul><li>jps 或 ps –ef|grepjava (获取PID)</li><li>jstack [-l ]<pid>| tee -a jstack.log (获取ThreadDump)</pid></li></ul><h1 id="如何查看Java应⽤的线程信息？"><a href="#如何查看Java应⽤的线程信息？" class="headerlink" title="如何查看Java应⽤的线程信息？"></a>如何查看Java应⽤的线程信息？</h1><ul><li>通过top命令拿到线程的pid后使⽤jstack命令</li></ul><h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1><ul><li>wc -l</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/fca1d6209800.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/fca1d6209800.html" class="post-title-link" itemprop="url">计算机网络</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:11:54" itemprop="dateCreated datePublished" datetime="2023-12-20T16:11:54+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-28 14:00:00" itemprop="dateModified" datetime="2023-12-28T14:00:00+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="TCP建⽴连接的过程。"><a href="#TCP建⽴连接的过程。" class="headerlink" title="TCP建⽴连接的过程。"></a>TCP建⽴连接的过程。</h1><h4 id="三次握⼿"><a href="#三次握⼿" class="headerlink" title="三次握⼿"></a>三次握⼿</h4><ul><li>第⼀次握⼿(客户端发送syn包到服务器端)：客户端发送syn包到服务器端，进⼊syn_send状态，等待服务器端的确认；</li><li>第⼆次握⼿(服务器返回syn+ack包给客户端)：服务器端收到客户端的syn包，发送syn+ack包给客户端，进⼊syn_recv状态；</li><li>第三次握⼿(客服端返回ack包给服务端)：客户端收到服务器端的syn+ack包，发送个ack包到服务器端，⾄此，客户端与服务器端进⼊established状态；</li><li>握⼿过程中传送的包不包含任何数据，连接建⽴后才会开始传送数据，理想状态下，TCP连接⼀旦建⽴，在通信双⽅的任何⼀⽅主动关闭连接前，TCP连接都会⼀直保持下去。</li></ul><h1 id="TCP断开连接的过程。"><a href="#TCP断开连接的过程。" class="headerlink" title="TCP断开连接的过程。"></a>TCP断开连接的过程。</h1><h4 id="四次握⼿"><a href="#四次握⼿" class="headerlink" title="四次握⼿"></a>四次握⼿</h4><ul><li>第⼀次握⼿：主动关闭⽅发送fin包到被动关闭⽅，告诉被动关闭⽅我不会再给你发送数据了；</li><li>第⼆次握⼿：被动关闭⽅收到syn包，发送ack给对⽅，确认序号为收到序号+1；</li><li>第三次握⼿：被动关闭⽅也也发送fin包给主动关闭⽅，告诉对⽅我也不会给你发送数据了；</li><li>第四次握⼿：主动关闭⽅收到syn包，发送ack给对⽅，⾄此，完成四次握⼿；</li></ul><h1 id="浏览器发⽣302跳转背后的逻辑"><a href="#浏览器发⽣302跳转背后的逻辑" class="headerlink" title="浏览器发⽣302跳转背后的逻辑"></a>浏览器发⽣302跳转背后的逻辑</h1><ul><li>浏览器在原请求地址的响应的Location域找到要跳转的URI执⾏跳转。</li></ul><h4 id="浏览器输⼊URL后发⽣了什么"><a href="#浏览器输⼊URL后发⽣了什么" class="headerlink" title="浏览器输⼊URL后发⽣了什么"></a>浏览器输⼊URL后发⽣了什么</h4><ul><li>DNS域名解析；</li><li>建⽴TCP连接；</li><li>发送HTTP请求；</li><li>服务器处理请求；</li><li>返回响应结果；</li><li>关闭TCP连接；</li><li>浏览器解析HTML；</li><li>浏览器布局渲染；</li></ul><h1 id="HTTP协议的交互流程。-HTTP和HTTPS的差异，-SSL的交互流程？"><a href="#HTTP协议的交互流程。-HTTP和HTTPS的差异，-SSL的交互流程？" class="headerlink" title="HTTP协议的交互流程。 HTTP和HTTPS的差异， SSL的交互流程？"></a>HTTP协议的交互流程。 HTTP和HTTPS的差异， SSL的交互流程？</h1><h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h4><ul><li>建⽴TCP连接；</li><li>发送HTTP请求；</li><li>服务器处理请求；</li><li>返回响应结果；</li><li>关闭TCP连接；</li></ul><h5 id="http三次握⼿："><a href="#http三次握⼿：" class="headerlink" title="http三次握⼿："></a>http三次握⼿：</h5><ul><li>第⼀次握⼿：客户端发送syn包(syn&#x3D;j)到服务器，并进⼊SYN_SEND状态，等待服务器确认；</li><li>第⼆次握⼿：服务器收到syn包，必须确认客户的SYN（ack&#x3D;j+1），同时⾃⼰也发送⼀个SYN包（syn&#x3D;k），即<br>SYN+ACK包，此时服务器进⼊SYN_RECV状态；</li><li>第三次握⼿：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;k+1)，此包发送完毕，客户端和服务器进⼊ESTABLISHED状态，完成三次握⼿。</li></ul><h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><ul><li>TTPS协议就是基于SSL的HTTP协议</li><li>HTTPS使⽤与HTTP不同的端⼝（HTTPS80 ， HTTPSS443）</li><li>提供了身份验证与加密通信⽅法，被⼴泛⽤于互联⽹上安全敏感的通信。</li><li>客户端请求SSL连接，并将⾃⼰⽀持的加密规则发给⽹站。</li><li>服务器端将⾃⼰的身份信息以证书形式发回给客户端。证书⾥⾯包含了⽹站地址，加密公钥，以及证书的颁发机构。</li><li>获得证书后，客户要做以下⼯作<ul><li>验证证书合法性</li><li>如果证书受信任，客户端会⽣成⼀串随机数的密码，并⽤证书提供的公钥进⾏加密。</li><li>将加密好的随机数发给服务器。</li><li>获得到客户端发的加密了的随机数之后，服务器⽤⾃⼰的私钥进⾏解密，得到这个随机数，把这个随机数作为对称加密的密钥。（利⽤⾮对称加密传输对称加密的密钥）</li><li>之后服务器与客户之间就可以⽤随机数对各⾃的信息进⾏加密，解密。</li></ul></li><li>注意的是：证书是⼀个公钥，这个公钥是进⾏加密⽤的。⽽私钥是进⾏解密⽤的。公钥任何都知道，私钥只有⾃⼰知道。这是⾮对称加密。⽽对称加密就是钥匙只有⼀把，我们都知道。</li><li>之所以⽤到对称加密，是因为对称加密的速度更快。⽽⾮对称加密的可靠性更⾼。</li><li>客户端请求–服务端发送证书（公钥）–客户端验证证书，并⽣成随机数，通过公钥加密后发送给服务端–服务端⽤私钥解密出随机数–对称加密传输数据。</li></ul><h4 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h4><ul><li>HTTPS协议需要申请证书。</li><li>HTTP是明⽂传输；HTTPS使⽤的是具有安全性的SSL加密传输协议</li><li>HTTP端⼝是80；HTTPS端⼝号是443</li><li>HTTP连接简单⽆状态；HTTPS由SSL+HTTP协议构件的可进⾏加密传输、身份验证的⽹络协议。</li></ul><h4 id="Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解"><a href="#Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解" class="headerlink" title="Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解?"></a>Rest和Http什么关系？⼤家都说Rest很轻置，你对Rest⻛格如何理解?</h4><ul><li>Http是⼀种协议，Rest是⼀种软件架构⻛格。</li><li>URL定位资源，⽤HTTP动词（GET,POST,DELETE,DETC）描述操作。</li><li>GET表示查询、POST表示新建、PUT表示更新、DELETE表示删除等。<ul><li>GET &#x2F;api&#x2F;v1&#x2F;user 获取⽤户列表</li><li>GET &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 获取ID为1的⽤户</li><li>POST &#x2F;api&#x2F;v1&#x2F;user 新建⽤户</li><li>PUT &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 更新ID为1的⽤户信息</li><li>DELETE &#x2F;api&#x2F;v1&#x2F;user&#x2F;1 删除ID为1的⽤户</li></ul></li><li>概念：REST（英⽂：Representational State Transfer，简称REST，表现层状态转化），指的是⼀组架构约束条件和原则。满⾜这些约束条件和原则的应⽤程序或设计就是 RESTful。</li><li>⼀种软件架构⻛格，设计⻛格⽽不是标准，只是提供了⼀组设计原则和约束条件。它主要⽤于客户端和服务器交互类的软件。基于这个⻛格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li><li>Restful架构：<ul><li>每⼀个URI代表⼀种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现层；</li><li>客户端通过四个HTTP动词(GET⽤来获取资源，POST⽤来新建资源（也可以⽤于更新资源），PUT⽤来更新资源，DELETE⽤来删除资源。)，对服务器端资源进⾏操作，实现”表现层状态转化”。</li></ul></li></ul><h1 id="TCP的滑动窗⼝协议有什么⽤？讲讲原理。"><a href="#TCP的滑动窗⼝协议有什么⽤？讲讲原理。" class="headerlink" title="TCP的滑动窗⼝协议有什么⽤？讲讲原理。"></a>TCP的滑动窗⼝协议有什么⽤？讲讲原理。</h1><ul><li>滑动窗⼝协议是传输层进⾏流控的⼀种措施，接收⽅通过通告发送⽅⾃⼰的窗⼝⼤⼩，从⽽控制发送⽅的发送速度，从⽽达到防⽌发送⽅发送速度过快⽽导致来不及接受。</li></ul><h1 id="HTTP协议都有哪些⽅法？"><a href="#HTTP协议都有哪些⽅法？" class="headerlink" title="HTTP协议都有哪些⽅法？"></a>HTTP协议都有哪些⽅法？</h1><ul><li>GET 请求获取由Request-URI所标识的资源。</li><li>POST 在Request-URI所标识的资源后附加新的数据。</li><li>HEAD 请求获取由Request-URI所标识的资源的响应消息报头。</li><li>OPTIONS 请求查询服务器的性能，或查询与资源相关的选项和需求。</li><li>PUT 请求服务器存储⼀个资源，并⽤Request-URI作为其标识。</li><li>DELETE 请求服务器删除由Request-URI所标识的资源。</li><li>TRACE 请求服务器回送收到的请求信息，主要⽤语测试或诊断。</li></ul><h1 id="交换机与路由器的区别？"><a href="#交换机与路由器的区别？" class="headerlink" title="交换机与路由器的区别？"></a>交换机与路由器的区别？</h1><h4 id="⼯作层次不同"><a href="#⼯作层次不同" class="headerlink" title="⼯作层次不同"></a>⼯作层次不同</h4><ul><li>最初的交换机⼯作在OSI模型中的数据链路层，⼯作原理简单</li><li>路由器⼯作在OSI模型中的⽹络层，得更多协议信息，做更智能的转发决策</li></ul><h4 id="数据转发所依据的对象不同"><a href="#数据转发所依据的对象不同" class="headerlink" title="数据转发所依据的对象不同"></a>数据转发所依据的对象不同</h4><ul><li>交换机是利⽤物理地址（MAC地址），确定转发的⽬的地址。（MAC固化硬件，⼀般不可更改）</li><li>路由器是利⽤IP地址，确定转发的⽬的地址。（IP通常为⽹关或p系统⾃动分配的）</li></ul><h4 id="是否可以分割⼴播域"><a href="#是否可以分割⼴播域" class="headerlink" title="是否可以分割⼴播域"></a>是否可以分割⼴播域</h4><ul><li>传统的交换机可以分割冲突域，不能分割⼴播域，⽽路由器可以分割⼴播域</li><li>由交换机连接的⽹段仍然属于同⼀⼴播域，⼴播数据报会在交换机连接的所有⽹段上传播，某些情况导致通信拥堵和安全漏洞。</li><li>连接到路由器上的⽹段被分配成不同的⼴播域，所以，⼴播数据不穿过路由器</li><li>虽然三层交换机可以分割⼴播域，但是⼦⼴播域之间不能通信，还是需要路由器</li></ul><h4 id="路由器提供了防⽕墙的服务"><a href="#路由器提供了防⽕墙的服务" class="headerlink" title="路由器提供了防⽕墙的服务"></a>路由器提供了防⽕墙的服务</h4><ul><li>路由器仅仅转发特定地址的数据包，不传送不⽀持路由协议的数据包，不传送未知⽬标⽹络数据包，从⽽可以防⽌⼴播⻛暴</li></ul><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul><li>⼆层交换机上存在MAC表，三层交换机上存在路由表、MAC表、ARP表，路由器上存在路由表和ARP表。</li><li>总之，交换机在具体的城域⽹中扮演着VLAN透传的⻆⾊，就是桥。</li><li>路由器的每⼀个端⼝都是⼀个独⽴的⼴播域和冲突域，⽽交换机是只有⼀个⼴播域和端⼝数量的冲突域。</li></ul><h1 id="Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？"><a href="#Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？" class="headerlink" title="Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？"></a>Socket⽹络通信、NIO流以及多线程处理技术，Netty、Mina？</h1><h4 id="socket⽹络通信"><a href="#socket⽹络通信" class="headerlink" title="socket⽹络通信"></a>socket⽹络通信</h4><ul><li>NIO流以及多线程处理技术：</li><li>BIO:阻塞式，线程池初始时创建⼀定量线程，超过则等待；</li><li>NIO:⾮阻塞式，不同的线程⼲专业的事情，提⾼系统吞吐量；</li><li>NIO+异步处理：让少量的线程做⼤量的事情；</li></ul><h4 id="Mina"><a href="#Mina" class="headerlink" title="Mina"></a>Mina</h4><ul><li>Apache Mina是⼀个能够帮助⽤户开发⾼性能和⾼伸缩性⽹络应⽤程序的框架。</li><li>它通过Java nio技术基于TCP&#x2F;IP和UDP&#x2F;IP协议提供了抽象的、事件驱动的、异步的API</li><li>采⽤⾮阻塞⽅式的异步传输，⽀持批量传输数据</li><li>mina框架简单⾼效，完成了底层的线程管理，内置编码器能够满⾜⼤多数⽤户的需求，省去了消息编码和解码的⼯作。</li></ul><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><ul><li>本质是JBoss开发的⼀个jar包，⽬的是开发⾼性能、⾼可靠性的⽹络服务和客户端服务</li><li>提供异步⾮阻塞的、事件驱动的⽹络应⽤程序的NIO框架和⼯具</li><li>处理socket</li><li>通过Future-Listener机制，⽤户可以⽅便的主动获取或者通过通知机制获得IO操作结果。</li></ul><h1 id="http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）"><a href="#http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）" class="headerlink" title="http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）"></a>http协议（报⽂结构，断点续传，多线程下载，什么是⻓连接）</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>HTTP协议是Hyper Text Transfer Protocol（超⽂本传输协议）的缩写,是⽤于从万维⽹（WWW:World Wide Web ）服务器传输超⽂本到本地浏览器的传送协议。</li><li>HTTP是⼀个基于TCP&#x2F;IP通信协议来传递数据（HTML ⽂件, 图⽚⽂件, 查询结果等）。</li><li>HTTP是⼀个属于应⽤层的⾯向对象的协议，由于其简捷、快速的⽅式，适⽤于分布式超媒体信息系统。它于1990年提出，经过⼏年的使⽤与发展，得到不断地完善和扩展。⽬前在WWW中使⽤的是HTTP&#x2F;1.0的第六版，HTTP&#x2F;1.1的规范化⼯作正在进⾏之中，⽽且HTTP-NG(Next Generation of HTTP)的建议已经提出。</li><li>HTTP协议⼯作于客户端-服务端架构为上。</li><li>浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求</li><li>Web服务器根据接收到的请求后，向客户端发送响应信息。</li></ul><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul><li>简单快速：客户向服务器请求服务时，只需传送请求⽅法和路径。请求⽅法常⽤的有GET、HEAD、POST。每种⽅法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模⼩，因⽽通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>⽆连接：⽆连接的含义是限制每次连接只处理⼀个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采⽤这种⽅式可以节省传输时间。</li><li>⽆状态：HTTP协议是⽆状态协议。⽆状态是指协议对于事务处理没有记忆能⼒。缺少状态意味着如果后续处理需要前⾯的信息，则它必须重传，这样可能导致每次连接传送的数据量增⼤。另⼀⽅⾯，在服务器不需要先前信息时它的应答就较快。</li><li>⽀持B&#x2F;S及C&#x2F;S模式。</li></ul><h1 id="get与post区别"><a href="#get与post区别" class="headerlink" title="get与post区别"></a>get与post区别</h1><ul><li>表单的method如果为get,那么所有的参数信息都会显示在浏览器的地址栏，当我们使⽤浏览器地址栏输⼊⽹址的⽅式来发送请求时,那么该请求⼀定是get⽅式</li><li>对于get⽅式,底层是将所有参数附加在请求资源的后⾯⼀起传递的，对于post⽅式,底层是将所有参数附加在请求参数的最后⼀⾏的下⼀⾏的下⼀⾏，Get请求的数据是被附在url之后（HTTP协议头中），POST请求数据则放置在HTTP包的包体head中；</li><li>对于get,post⽅式,servlet不同处理：doGet()，doPost();</li><li>浏览器处理：重复访问使⽤GET⽅法请求的⻚⾯，浏览器会使⽤缓存处理后续请求。使⽤POST⽅法的form提交时，浏览器基于POST将产⽣永久改变的假设，将让⽤户进⾏提交确认。</li></ul><h1 id="rpc和http的区别，使⽤场景"><a href="#rpc和http的区别，使⽤场景" class="headerlink" title="rpc和http的区别，使⽤场景"></a>rpc和http的区别，使⽤场景</h1><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h5><ul><li>RPC，可以基于TCP协议，也可以基于HTTP协议</li><li>HTTP，基于HTTP协议</li></ul><h5 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h5><ul><li>RPC，使⽤⾃定义的TCP协议，可以让请求报⽂体积更⼩，或者使⽤HTTP2协议，也可以很好的减少报⽂的体积，提⾼传输效率</li><li>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多⽆⽤的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为⼀个RPC来使⽤的，这时标准RPC框架更多的是服务治理性能消耗，主要在于序列化和反序列化的耗时<br>RPC，可以基于thrift实现⾼效的⼆进制传输</li><li>HTTP，⼤部分是通过json来实现的，字节⼤⼩和序列化耗时都⽐thrift要更消耗性能</li></ul><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><ul><li>RPC，基本都⾃带了负载均衡策略</li><li>HTTP，需要配置Nginx，HAProxy来实现</li></ul><h5 id="服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）"><a href="#服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）" class="headerlink" title="服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）"></a>服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）</h5><ul><li>RPC，能做到⾃动通知，不影响上游</li><li>HTTP，需要事先通知，修改Nginx&#x2F;HAProxy配置</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。</li><li>HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。</li></ul><h1 id="说说TCP-UDP和socket-Http之间联系和区别"><a href="#说说TCP-UDP和socket-Http之间联系和区别" class="headerlink" title="说说TCP,UDP和socket,Http之间联系和区别"></a>说说TCP,UDP和socket,Http之间联系和区别</h1><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><ul><li>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。</li><li>在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。</li><li>在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。</li><li>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</li></ul><h5 id="TCP的优点"><a href="#TCP的优点" class="headerlink" title="TCP的优点"></a>TCP的优点</h5><ul><li>可靠，稳定</li><li>TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</li></ul><h5 id="TCP的缺点"><a href="#TCP的缺点" class="headerlink" title="TCP的缺点"></a>TCP的缺点</h5><ul><li>慢，效率低，占用系统资源高，易被攻击</li><li>TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。<br>由于TCP存在确认机制和三次握手机制，这些是导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</li></ul><h5 id="TCP应用场景"><a href="#TCP应用场景" class="headerlink" title="TCP应用场景"></a>TCP应用场景</h5><ul><li>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</li><li>在日常生活中，常见使用TCP协议的应用比如：浏览器使用HTTP，Outlook使用POP、SMTP，QQ文件传输等。</li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><ul><li>U- DP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。</li></ul><h5 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h5><ul><li>快，比TCP稍安全</li><li>UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……</li></ul><h5 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h5><ul><li>不可靠，不稳定</li><li>因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</li></ul><h5 id="UDP应用场景"><a href="#UDP应用场景" class="headerlink" title="UDP应用场景"></a>UDP应用场景</h5><ul><li>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。在日常生活中，常见使用UDP协议的应用比如：QQ语音、QQ视频、TFTP等。</li><li>TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。</li><li>TCP&#x2F;IP是个协议组，可分为三个层次：网络层、传输层和应用层。<ul><li>在网络层有：IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。</li><li>在传输层中有：TCP协议与UDP协议。</li><li>在应用层有：FTP、HTTP、TELNET、SMTP、DNS等协议。</li></ul></li><li>因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。</li><li>TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。</li><li>虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。</li></ul><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><ul><li>HTTP（超文本传输协议）是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。</li><li>HTTP是短连接：客户端发送请求都需要服务器端回送响应.请求结束后，主动释放链接，因此为短连接。通常的做法是，不需要任何数据，也要保持每隔一段时间向服务器发送”保持连接”的请求。这样可以保证客户端在服务器端是”上线”状态。</li><li>HTTP连接使用的是”请求-响应”方式，不仅在请求时建立连接，而且客户端向服务器端请求后，服务器才返回数据。</li></ul><h4 id="Socket协议"><a href="#Socket协议" class="headerlink" title="Socket协议"></a>Socket协议</h4><ul><li>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</li><li>建立网络通信连接至少要一对端口号（socket）。socket本质是编程接口（API），对TCP&#x2F;IP的封装，TCP&#x2F;IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</li></ul><h1 id="TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由"><a href="#TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由" class="headerlink" title="TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由"></a>TCP为何采用三次握手来建立连接，若采用二次握手可以么，请说明理由</h1><ul><li>三次握手是为了防止已失效的连接请求再次传送到服务器端</li><li>二次握手不可行，因为：如果由于网络不稳定，虽然客户端以前发送的连接请求已到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/fe062138c36d.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/fe062138c36d.html" class="post-title-link" itemprop="url">Memcached</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:10:21" itemprop="dateCreated datePublished" datetime="2023-12-20T16:10:21+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-25 22:51:49" itemprop="dateModified" datetime="2023-12-25T22:51:49+08:00">2023-12-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="memcached是怎么工作的？"><a href="#memcached是怎么工作的？" class="headerlink" title="memcached是怎么工作的？"></a>memcached是怎么工作的？</h1><ul><li>Memcached的神奇来自两阶段哈希（two-stage hash）</li><li>Memcached就像一个巨大的、存储了很多&lt;key,value&gt;对的哈希表。通过key，可以存储或查询任意的数据。 </li><li>客户端可以把数据存储在多台memcached上。当查询数据时，客户端首先参考节点列表计算出key的哈希值（阶段一哈希），进而选中一个节点；客户端将请求发送给选中的节点，然后memcached节点通过一个内部的哈希算法（阶段二哈希），查找真正的数据（item）。 </li><li>举个列子，假设有3个客户端1, 2, 3，3台memcached A, B, C：Client 1想把数据”barbaz”以key “foo”存储。Client 1首先参考节点列表（A, B, C），计算key “foo”的哈希值，假设memcached B被选中。接着，Client 1直接connect到memcached B，通过key “foo”把数据”barbaz”存储进去。Client 2使用与Client 1相同的客户端库（意味着阶段一的哈希算法相同），也拥有同样的memcached列表（A, B, C）。 于是，经过相同的哈希计算（阶段一），Client 2计算出key “foo”在memcached B上，然后它直接请求memcached B，得到数据”barbaz”。 </li><li>各种客户端在memcached中数据的存储形式是不同的（perl Storable, php serialize, java hibernate, JSON等）。一些客户端实现的哈希算法也不一样。但是，memcached服务器端的行为总是一致的。 </li><li>最后，从实现的角度看，memcached是一个非阻塞的、基于事件的服务器程序。这种架构可以很好地解决C10K problem ，并具有极佳的可扩展性。</li></ul><p> </p><h1 id="memcached最大的优势是什么？"><a href="#memcached最大的优势是什么？" class="headerlink" title="memcached最大的优势是什么？"></a>memcached最大的优势是什么？</h1><ul><li>Memcached最大的好处就是它带来了极佳的水平可扩展性，特别是在一个巨大的系统中</li><li>由于客户端自己做了一次哈希，那么我们很容易增加大量memcached到集群中</li><li>memcached之间没有相互通信，因此不会增加 memcached的负载；没有多播协议，不会网络通信量爆炸（implode）。memcached的集群很好用。内存不够了？增加几台 memcached吧；CPU不够用了？再增加几台吧；有多余的内存？在增加几台吧，不要浪费了。 </li><li>基于memcached的基本原则，可以相当轻松地构建出不同类型的缓存架构。</li></ul><h1 id="memcached和MySQL的query-cache相比，有什么优缺点？"><a href="#memcached和MySQL的query-cache相比，有什么优缺点？" class="headerlink" title="memcached和MySQL的query cache相比，有什么优缺点？"></a>memcached和MySQL的query cache相比，有什么优缺点？</h1><ul><li>把memcached引入应用中，还是需要不少工作量的</li><li>MySQL有个使用方便的query cache，可以自动地缓存SQL查询的结果，被缓存的SQL查询可以被反复地快速执行。</li></ul><h4 id="Memcached与之相比，怎么样呢"><a href="#Memcached与之相比，怎么样呢" class="headerlink" title="Memcached与之相比，怎么样呢"></a>Memcached与之相比，怎么样呢</h4><ul><li>MySQL的query cache是集中式的，连接到该query cache的MySQL服务器都会受益。 </li><li>当您修改表时，MySQL的query cache会立刻被刷新（flush）</li><li>存储一个memcached item只需要很少的时间，但是当写操作很频繁时，MySQL的query cache会经常让所有缓存数据都失效。 </li><li>在多核CPU上，MySQL的query cache会遇到扩展问题（scalability issues）。在多核CPU上，query cache会增加一个全局锁（global lock）, 由于需要刷新更多的缓存数据，速度会变得更慢。 </li><li>在 MySQL的query cache中，我们是不能存储任意的数据的（只能是SQL查询结果）。而利用memcached，我们可以搭建出各种高效的缓存。比如，可以执行多个独立的查询，构建出一个用户对象（user object），然后将用户对象缓存到memcached中。而query cache是SQL语句级别的，不可能做到这一点。在小的网站中，query cache会有所帮助，但随着网站规模的增加，query cache的弊将大于利。 </li><li>query cache能够利用的内存容量受到MySQL服务器空闲内存空间的限制。给数据库服务器增加更多的内存来缓存数据，固然是很好的。但是，有了memcached，只要您有空闲的内存，都可以用来增加memcached集群的规模，然后您就可以缓存更多的数据。</li></ul><p> </p><h1 id="memcached和服务器的local-cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？"><a href="#memcached和服务器的local-cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？" class="headerlink" title="memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？"></a>memcached和服务器的local cache（比如PHP的APC、mmap文件等）相比，有什么优缺点？</h1><ul><li>首先，local cache有许多与上面(query cache)相同的问题</li><li>local cache能够利用的内存容量受到（单台）服务器空闲内存空间的限制</li><li>不过，local cache有一点比memcached和query cache都要好，那就是它不但可以存储任意的数据，而且没有网络存取的延迟。 </li><li>local cache的数据查询更快</li><li>考虑把highly common的数据放在local cache中吧。如果每个页面都需要加载一些数量较少的数据，考虑把它们放在local cached吧。 </li><li>local cache缺少集体失效（group invalidation）的特性。在memcached集群中，删除或更新一个key会让所有的观察者觉察到。但是在local cache中, 我们只能通知所有的服务器刷新cache（很慢，不具扩展性），或者仅仅依赖缓存超时失效机制。 </li><li>local cache面临着严重的内存限制，这一点上面已经提到。</li></ul><p> </p><h1 id="memcached的cache机制是怎样的？"><a href="#memcached的cache机制是怎样的？" class="headerlink" title="memcached的cache机制是怎样的？"></a>memcached的cache机制是怎样的？</h1><ul><li>Memcached主要的cache机制是LRU（最近最少用）算法+超时失效</li><li>当您存数据到memcached中，可以指定该数据在缓存中可以呆多久Which is forever, or some time in the future</li><li>如果memcached的内存不够用了，过期的slabs会优先被替换，接着就轮到最老的未被使用的slabs。</li></ul><p> </p><h1 id="memcached如何实现冗余机制？"><a href="#memcached如何实现冗余机制？" class="headerlink" title="memcached如何实现冗余机制？"></a>memcached如何实现冗余机制？</h1><ul><li>不实现！我们对这个问题感到很惊讶</li><li>Memcached应该是应用的缓存层</li><li>它的设计本身就不带有任何冗余机制</li><li>如果一个memcached节点失去了所有数据，您应该可以从数据源（比如数据库）再次获取到数据</li><li>您应该特别注意，您的应用应该可以容忍节点的失效</li><li>不要写一些糟糕的查询代码，寄希望于 memcached来保证一切！如果您担心节点失效会大大加重数据库的负担，那么您可以采取一些办法。比如您可以增加更多的节点（来减少丢失一个节点的影响），热备节点（在其他节点down了的时候接管IP），等等。</li></ul><p> </p><h1 id="memcached如何处理容错的？"><a href="#memcached如何处理容错的？" class="headerlink" title="memcached如何处理容错的？"></a>memcached如何处理容错的？</h1><ul><li>不处理！</li><li>在memcached节点失效的情况下，集群没有必要做任何容错处理</li><li>如果发生了节点失效，应对的措施完全取决于用户</li><li>节点失效时，下面列出几种方案供您选择： <ul><li>忽略它！在失效节点被恢复或替换之前，还有很多其他节点可以应对节点失效带来的影响</li><li>把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下（余数式哈希算法），客户端添加或移除节点，会导致所有的缓存数据不可用！因为哈希参照的节点列表变化了，大部分key会因为哈希值的改变而被映射到（与原来）不同的节点上。 </li><li>启动热备节点，接管失效节点所占用的IP。这样可以防止哈希紊乱（hashing chaos）。 </li><li>如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈希算法（consistent hashing）</li><li>两次哈希（reshing）。当客户端存取数据时，如果发现一个节点down了，就再做一次哈希（哈希算法与前一次不同），重新选择另一个节点（需要注意的时，客户端并没有把down的节点从节点列表中移除，下次还是有可能先哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和坏的节点上都可能存在脏数据（stale data）。</li></ul></li></ul><p> </p><h1 id="如何将memcached中item批量导入导出？"><a href="#如何将memcached中item批量导入导出？" class="headerlink" title="如何将memcached中item批量导入导出？"></a>如何将memcached中item批量导入导出？</h1><ul><li>您不应该这样做！</li><li>Memcached是一个非阻塞的服务器</li><li>任何可能导致memcached暂停或瞬时拒绝服务的操作都应该值得深思熟虑</li><li>向 memcached中批量导入数据往往不是您真正想要的</li><li>想象看，如果缓存数据在导出导入之间发生了变化，您就需要处理脏数据了；如果缓存数据在导出导入之间过期了，您又怎么处理这些数据呢？ </li><li>因此，批量导出导入数据并不像您想象中的那么有用。不过在一个场景倒是很有用。如果您有大量的从不变化的数据，并且希望缓存很快热（warm）起来，批量导入缓存数据是很有帮助的。虽然这个场景并不典型，但却经常发生，因此我们会考虑在将来实现批量导出导入的功能。</li></ul><p> </p><h1 id="memcached是如何做身份验证的？"><a href="#memcached是如何做身份验证的？" class="headerlink" title="memcached是如何做身份验证的？"></a>memcached是如何做身份验证的？</h1><ul><li>没有身份认证机制！</li><li>memcached是运行在应用下层的软件（身份验证应该是应用上层的职责）</li><li>memcached的客户端和服务器端之所以是轻量级的，部分原因就是完全没有实现身份验证机制。这样，memcached可以很快地创建新连接，服务器端也无需任何配置。 </li><li>如果您希望限制访问，您可以使用防火墙，或者让memcached监听unix domain socket。</li></ul><p> </p><h1 id="memcached的多线程是什么？如何使用它们？"><a href="#memcached的多线程是什么？如何使用它们？" class="headerlink" title="memcached的多线程是什么？如何使用它们？"></a>memcached的多线程是什么？如何使用它们？</h1><ul><li>线程就是定律（threads rule）！</li><li>多线程模式允许memcached能够充分利用多个CPU，并在CPU之间共享所有的缓存数据</li><li>memcached使用一种简单的锁机制来保证数据更新操作的互斥</li><li>相比在同一个物理机器上运行多个memcached实例，这种方式能够更有效地处理multi gets。 </li><li>如果您的系统负载并不重，也许您不需要启用多线程工作模式</li><li>如果您在运行一个拥有大规模硬件的、庞大的网站，您将会看到多线程的好处。 </li><li>简单地总结一下：命令解析（memcached在这里花了大部分时间）可以运行在多线程模式下。memcached内部对数据的操作是基于很多全局锁的（因此这部分工作不是多线程的）。未来对多线程模式的改进，将移除大量的全局锁，提高memcached在负载极高的场景下的性能。</li></ul><p> </p><h1 id="memcached能接受的key的最大长度是多少？"><a href="#memcached能接受的key的最大长度是多少？" class="headerlink" title="memcached能接受的key的最大长度是多少？"></a>memcached能接受的key的最大长度是多少？</h1><ul><li>key的最大长度是250个字符</li><li>需要注意的是，250是memcached服务器端内部的限制，如果您使用的客户端支持”key的前缀”或类似特性，那么key（前缀+原始key）的最大长度是可以超过250个字符的</li><li>我们推荐使用使用较短的key，因为可以节省内存和带宽。</li></ul><p> </p><h1 id="memcached对item的过期时间有什么限制？"><a href="#memcached对item的过期时间有什么限制？" class="headerlink" title="memcached对item的过期时间有什么限制？"></a>memcached对item的过期时间有什么限制？</h1><ul><li>过期时间最大可以达到30天</li><li>memcached把传入的过期时间（时间段）解释成时间点后，一旦到了这个时间点，memcached就把item置为失效状态。</li></ul><p> </p><h1 id="memcached最大能存储多大的单个item？"><a href="#memcached最大能存储多大的单个item？" class="headerlink" title="memcached最大能存储多大的单个item？"></a>memcached最大能存储多大的单个item？</h1><ul><li>1MB</li><li>如果你的数据大于1MB，可以考虑在客户端压缩或拆分到多个key中。</li></ul><p> </p><h1 id="为什么单个item的大小被限制在1M-byte之内？"><a href="#为什么单个item的大小被限制在1M-byte之内？" class="headerlink" title="为什么单个item的大小被限制在1M byte之内？"></a>为什么单个item的大小被限制在1M byte之内？</h1><ul><li>简单的回答：因为内存分配器的算法就是这样的。 </li><li>详细的回答：Memcached的内存存储引擎（引擎将来可插拔…），使用slabs来管理内存。内存被分成大小不等的slabs chunks（先分成大小相等的slabs，然后每个slab被分成大小相等chunks，不同slab的chunk大小是不相等的）。chunk的大小依次从一个最小数开始，按某个因子增长，直到达到最大的可能值。 </li><li>如果最小值为400B，最大值是1MB，因子是1.20，各个slab的chunk的大小依次是：slab1 – 400B slab2 – 480B slab3 – 576B … </li><li>slab中chunk越大，它和前面的slab之间的间隙就越大。因此，最大值越大，内存利用率越低。Memcached必须为每个slab预先分配内存，因此如果设置了较小的因子和较大的最大值，会需要更多的内存。 </li><li>还有其他原因使得您不要这样向memcached中存取很大的数据…不要尝试把巨大的网页放到mencached中。把这样大的数据结构load和unpack到内存中需要花费很长的时间，从而导致您的网站性能反而不好。 </li><li>如果您确实需要存储大于1MB的数据，你可以修改slabs.c:POWER_BLOCK的值，然后重新编译memcached；或者使用低效的malloc&#x2F;free。其他的建议包括数据库、MogileFS等。</li></ul><p> </p><h1 id="我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？"><a href="#我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？" class="headerlink" title="我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？"></a>我可以在不同的memcached节点上使用大小不等的缓存空间吗？这么做之后，memcached能够更有效地使用内存吗？</h1><ul><li>Memcache客户端仅根据哈希算法来决定将某个key存储在哪个节点上，而不考虑节点的内存大小</li><li>因此，您可以在不同的节点上使用大小不等的缓存。但是一般都是这样做的：拥有较多内存的节点上可以运行多个memcached实例，每个实例使用的内存跟其他节点上的实例相同。</li></ul><p> </p><h1 id="LRU算法，slab分配，如何减少内存碎⽚"><a href="#LRU算法，slab分配，如何减少内存碎⽚" class="headerlink" title="LRU算法，slab分配，如何减少内存碎⽚"></a>LRU算法，slab分配，如何减少内存碎⽚</h1><ul><li>memcached预先将分配的内存分割成各种尺⼨的块(chunk)，并把尺⼨相同的块分成组(chunk的集合)，以此克服内<br>存碎⽚化问题</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/2f1abbd5b4e4.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/2f1abbd5b4e4.html" class="post-title-link" itemprop="url">Mybatis</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:08:45" itemprop="dateCreated datePublished" datetime="2023-12-20T16:08:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-25 11:09:25" itemprop="dateModified" datetime="2023-12-25T11:09:25+08:00">2023-12-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h1><ul><li>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<ul><li>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</li></ul></li><li>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<ul><li>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li></ul></li><li>向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<ul><li>解决：Mybatis自动将java对象映射至sql语句。</li></ul></li><li>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<ul><li>解决：Mybatis自动将sql执行结果映射至java对象。</li></ul></li></ul><h1 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h1><ul><li>创建SqlSessionFactory</li><li>通过SqlSessionFactory创建SqlSession</li><li>通过sqlsession执行数据库操作</li><li>调用session.commit()提交事务</li><li>调用session.close()关闭会话</li></ul><h1 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h1><ul><li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li><li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li><li>Hibernate对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O&#x2F;R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li><li>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</li></ul><p> </p><h1 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h1><ul><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ul><h1 id="SqlMapConfig-xml中配置有哪些内容？"><a href="#SqlMapConfig-xml中配置有哪些内容？" class="headerlink" title="SqlMapConfig.xml中配置有哪些内容？"></a>SqlMapConfig.xml中配置有哪些内容？</h1><ul><li>SqlMapConfig.xml中配置的内容和顺序如下： <ul><li>properties（属性）</li><li>settings（配置）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environments（环境集合属性对象）</li><li>environment（环境子属性对象）</li><li>transactionManager（事务管理）</li><li>dataSource（数据源）</li><li>mappers（映射器）</li></ul></li></ul><h1 id="简单的说一下MyBatis的一级缓存和二级缓存？"><a href="#简单的说一下MyBatis的一级缓存和二级缓存？" class="headerlink" title="简单的说一下MyBatis的一级缓存和二级缓存？"></a>简单的说一下MyBatis的一级缓存和二级缓存？</h1><ul><li>Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。</li><li>Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象</li><li>Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。</li></ul><h1 id="Mapper编写有哪几种方式？"><a href="#Mapper编写有哪几种方式？" class="headerlink" title="Mapper编写有哪几种方式？"></a>Mapper编写有哪几种方式？</h1><h4 id="接口实现类继承SqlSessionDaoSupport"><a href="#接口实现类继承SqlSessionDaoSupport" class="headerlink" title="接口实现类继承SqlSessionDaoSupport"></a>接口实现类继承SqlSessionDaoSupport</h4><ul><li><p>使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件</p></li><li><p>在sqlMapConfig.xml中配置mapper.xml的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义mapper接口</p></li><li><p>实现类集成SqlSessionDaoSupport</p></li><li><p>mapper方法中可以this.getSqlSession()进行数据增删改查。</p></li><li><p>spring 配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot; &quot; class=&quot;mapper接口的实现&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用org-mybatis-spring-mapper-MapperFactoryBean"><a href="#使用org-mybatis-spring-mapper-MapperFactoryBean" class="headerlink" title="使用org.mybatis.spring.mapper.MapperFactoryBean"></a>使用org.mybatis.spring.mapper.MapperFactoryBean</h4><ul><li><p>在sqlMapConfig.xml中配置mapper.xml的位置</p></li><li><p>如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper.xml文件的地址&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义mapper接口</p></li><li><p>注意</p><ul><li>mapper.xml中的namespace为mapper接口的地址</li><li>mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</li></ul></li><li><p>Spring中定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;mapperInterface&quot;   value=&quot;mapper接口地址&quot; /&gt;  </span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;  </span><br><span class="line">4&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用mapper扫描器"><a href="#使用mapper扫描器" class="headerlink" title="使用mapper扫描器"></a>使用mapper扫描器</h4><ul><li><p>mapper.xml文件编写，</p></li><li><p>注意：<br>-mapper.xml中的namespace为mapper接口的地址<br>-mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</p><ul><li>如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置</li></ul><p> </p></li><li><p>定义mapper接口</p><ul><li>注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录</li></ul></li><li><p>配置mapper扫描器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;mapper接口包地址&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用扫描器后从spring容器中获取mapper的实现对象</p></li><li><p>扫描器将接口通过代理方法生成实现对象，要spring容器中自动注册，名称为mapper 接口的名称。</p></li></ul><h1 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h1><ul><li>#{}是预编译处理，${}是字符串替换。</li><li>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set方法来赋值；</li><li>Mybatis 在处理${}时，就是把${}替换成变量的值。</li><li>使用#{}可以有效的防止 SQL 注入，提高系统安全性。</li></ul><h1 id="通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，"><a href="#通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，" class="headerlink" title="通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，"></a>通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，</h1><ul><li>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</li><li>Dao 接口，就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement</li><li>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao 下面 id &#x3D; findStudentById 的MappedStatement。在 Mybatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个 MappedStatement 对象。</delete></update></insert></select></li><li>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li><li>Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement 所代表的 sql，然后将 sql 执行结果返回。</li></ul><h1 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h1><ul><li>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</li><li>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</li></ul><h1 id="Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><ul><li>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系</resultmap></li><li>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</li></ul><h1 id="Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h1><ul><li>注：这道题出自京东面试官。</li><li>还有很多其他的标签，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中为sql片段标签，通过标签引入 sql 片段，为不支持自增的主键生成策略标签。</li></ul><h1 id="简述-Mybatis-的插件运行原理，以及如何编写一个插件"><a href="#简述-Mybatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述 Mybatis 的插件运行原理，以及如何编写一个插件"></a>简述 Mybatis 的插件运行原理，以及如何编写一个插件</h1><ul><li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li><li>实现 Mybatis 的 Interceptor 接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。</li></ul><h1 id="一级、二级缓存"><a href="#一级、二级缓存" class="headerlink" title="一级、二级缓存"></a>一级、二级缓存</h1><ul><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空。</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如Ehcache</li><li>要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：<cache></li><li>对于缓存数据更新机制，当某一个作用域(一级缓存Session&#x2F;二级缓存Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ul><h1 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h1><ul><li>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载</li><li>association 指的就是一对一，collection 指的就是一对多查询</li><li>在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。</li><li>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li></ul><h1 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h1><ul><li>虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。</li><li>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</li></ul><h1 id="简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-Xml-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系？</h1><ul><li>Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部</li><li>在 Xml 映射文件中，<parametermap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultmap>标签会被解析为ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。</delete></update></insert></select></resultmap></parametermap></li></ul><h1 id="ibatis-中的-与-的区别"><a href="#ibatis-中的-与-的区别" class="headerlink" title="ibatis 中的#与$的区别"></a>ibatis 中的#与$的区别</h1><ul><li>#是把传入的数据当作字符串，如#field#传入的是id,则sql语句生成是这样，order by “id”,这当然会报错．．</li><li>$传入的数据直接生成在sql里，如#field#传入的是id,则sql语句生成是这样，order by id, 这就对了．</li><li>#方式能够很大程度防止sql注入．</li><li>$方式无法方式sql注入．</li><li>$方式一般用于传入数据库对象．例如传入表名.</li><li>一般能用#的就别用$.</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/b318dfbd2190.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/b318dfbd2190.html" class="post-title-link" itemprop="url">Netty</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:07:22" itemprop="dateCreated datePublished" datetime="2023-12-20T16:07:22+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-25 13:04:15" itemprop="dateModified" datetime="2023-12-25T13:04:15+08:00">2023-12-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="BIO、NIO和AIO的区别？"><a href="#BIO、NIO和AIO的区别？" class="headerlink" title="BIO、NIO和AIO的区别？"></a>BIO、NIO和AIO的区别？</h1><ul><li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</li><li>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</li><li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li><li>AIO：一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的Stream是单向的，而NIO的channel是双向的。</li><li>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I&#x2F;O，I&#x2F;O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。</li><li>在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作</li><li>如在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul><h1 id="NIO的组成"><a href="#NIO的组成" class="headerlink" title="NIO的组成"></a>NIO的组成</h1><ul><li>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的</li><li>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</li><li>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。</li><li>rewind方法 ： 重绕此缓冲区，将position置为0</li><li>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I&#x2F;O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</li><li>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！</li><li>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</li><li>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</li><li>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</li><li>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取<br>-NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</li></ul><h1 id="Netty的特点？"><a href="#Netty的特点？" class="headerlink" title="Netty的特点？"></a>Netty的特点？</h1><ul><li>一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持</li><li>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。</li><li>采用多种decoder&#x2F;encoder 支持，对TCP粘包&#x2F;分包进行自动化处理</li><li>可使用接受&#x2F;处理线程池，提高连接效率，对重连、心跳检测的简单支持</li><li>可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf</li><li>通过引用计数器及时申请释放不再引用的对象，降低了GC频率</li><li>使用单线程串行化的方式，高效的Reactor线程模型</li><li>大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用</li></ul><h1 id="Netty的线程模型？"><a href="#Netty的线程模型？" class="headerlink" title="Netty的线程模型？"></a>Netty的线程模型？</h1><ul><li>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池</li><li>其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池</li><li>其中work线程池负责请求的read和write事件，由对应的Handler处理。</li></ul><h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><ul><li>所有I&#x2F;O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的</li><li>既要接收客户端的连接请求,向服务端发起连接，又要发送&#x2F;读取请求或应答&#x2F;响应消息</li><li>一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><ul><li>有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求</li><li>NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送</li><li>1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题</li><li>但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</li></ul><h4 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h4><ul><li>Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I&#x2F;O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；</li></ul><h1 id="TCP-粘包-拆包的原因及解决方法？"><a href="#TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="TCP 粘包&#x2F;拆包的原因及解决方法？"></a>TCP 粘包&#x2F;拆包的原因及解决方法？</h1><ul><li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li></ul><h4 id="TCP粘包-分包的原因："><a href="#TCP粘包-分包的原因：" class="headerlink" title="TCP粘包&#x2F;分包的原因："></a>TCP粘包&#x2F;分包的原因：</h4><ul><li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象</li><li>而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</li><li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li><li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>消息定长：FixedLengthFrameDecoder类</li><li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</li><li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li></ul><h1 id="了解哪几种序列化协议？"><a href="#了解哪几种序列化协议？" class="headerlink" title="了解哪几种序列化协议？"></a>了解哪几种序列化协议？</h1><ul><li>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；</li><li>反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</li><li>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</li></ul><h4 id="Java默认提供的序列化"><a href="#Java默认提供的序列化" class="headerlink" title="Java默认提供的序列化"></a>Java默认提供的序列化</h4><ul><li>无法跨语言、序列化后的码流太大、序列化的性能差</li></ul><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><ul><li>优点：人机可读性好，可指定元素或特性的名称</li><li>缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽</li><li>适用场景：当做配置文件存储数据，实时数据转换。</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul><li>是一种轻量级的数据交换格式</li><li>优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快</li><li>缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大</li><li>适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li></ul><h4 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h4><ul><li>采用一种“假定有序快速匹配”的算法</li><li>优点：接口简单易用、目前java语言中最快的json库</li><li>缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全</li><li>适用场景：协议交互、Web输出、Android客户端</li></ul><h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><ul><li>不仅是序列化协议，还是一个RPC框架</li><li>优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码</li><li>缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议</li><li>适用场景：分布式系统的RPC解决方案</li></ul><h4 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h4><ul><li>Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题</li><li>优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现</li><li>缺点：对于习惯于静态类型语言的用户不直观</li><li>适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</li></ul><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><ul><li>将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性</li><li>优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护</li><li>缺点：需要依赖于工具生成代码、支持的语言相对较少</li><li>适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可</li><li>Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口</li><li>Message pack 一个高效的二进制序列化格式</li><li>Hessian 采用二进制协议的轻量级remoting onhttp工具</li><li>kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）</li></ul><h1 id="如何选择序列化协议？"><a href="#如何选择序列化协议？" class="headerlink" title="如何选择序列化协议？"></a>如何选择序列化协议？</h1><h4 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h4><ul><li>对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。</li><li>基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选</li><li>对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</li><li>对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</li><li>当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</li><li>对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。</li><li>对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯</li><li>由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</li><li>如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</li><li>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</li><li>protobuf的数据类型有多种<ul><li>bool、double、float、int32、int64、string、bytes、enum、message</li><li>protobuf的限定符：<ul><li>required: 必须赋值，不能为空</li><li>optional:字段可以赋值，也可以不赋值</li><li>repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；</li></ul></li></ul></li></ul><h4 id="protobuf的基本规则"><a href="#protobuf的基本规则" class="headerlink" title="protobuf的基本规则"></a>protobuf的基本规则</h4><ul><li>每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段</li><li>repeated表示的字段可以包含0个或多个数据</li><li>[1,15]之内的标识号在编码的时候会占用一个字节（常用）</li><li>[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。</li><li>protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。</li><li>编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder &#x3D; UserProto.User.newBuilder();builder.build()；</li><li>Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类</li><li>将StringBuilder转换为ByteBuf类型：copiedBuffer()方法</li></ul><h1 id="Netty的零拷贝实现？"><a href="#Netty的零拷贝实现？" class="headerlink" title="Netty的零拷贝实现？"></a>Netty的零拷贝实现？</h1><ul><li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝</li><li>堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中</li><li>ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li><li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer</li><li>addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li><li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li><li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</li><li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li><li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。</li></ul><h1 id="Netty的高性能表现在哪些方面？"><a href="#Netty的高性能表现在哪些方面？" class="headerlink" title="Netty的高性能表现在哪些方面？"></a>Netty的高性能表现在哪些方面？</h1><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><ul><li>对服务端：会定时清除闲置会话inactive(netty5)</li><li>对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态</li></ul><h4 id="串行无锁化设计"><a href="#串行无锁化设计" class="headerlink" title="串行无锁化设计"></a>串行无锁化设计</h4><ul><li>即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁</li><li>表面上看，串行化设计似乎CPU利用率不高，并发程度不够</li><li>但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</li></ul><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul><li>链路有效性检测：链路空闲检测机制，读&#x2F;写空闲超时机制</li><li>内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护</li><li>优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</li></ul><h4 id="Netty安全性"><a href="#Netty安全性" class="headerlink" title="Netty安全性"></a>Netty安全性</h4><ul><li>支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。</li></ul><h4 id="高效并发编程的体现"><a href="#高效并发编程的体现" class="headerlink" title="高效并发编程的体现"></a>高效并发编程的体现</h4><ul><li>volatile的大量、正确使用</li><li>CAS和原子类的广泛使用</li><li>线程安全容器的使用</li><li>通过读写锁提升并发性能</li><li>IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）</li></ul><h4 id="流量整型的作用（变压器）"><a href="#流量整型的作用（变压器）" class="headerlink" title="流量整型的作用（变压器）"></a>流量整型的作用（变压器）</h4><ul><li>防止由于上下游网关性能不均衡导致下游网关被压垮，业务流中断</li><li>防止由于通信模块接收消息过快，后端业务线程处理不及时导致撑死问题。</li></ul><h4 id="TCP参数配置"><a href="#TCP参数配置" class="headerlink" title="TCP参数配置"></a>TCP参数配置</h4><ul><li>SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K</li><li>SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率</li><li>但是对于时延敏感的应用场景需要关闭该优化算法；</li></ul><h1 id="NIOEventLoopGroup源码？"><a href="#NIOEventLoopGroup源码？" class="headerlink" title="NIOEventLoopGroup源码？"></a>NIOEventLoopGroup源码？</h1><ul><li>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。</li><li>线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素</li><li>如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回</li><li>如果taskQueue没有元素，执行 select(oldWakenUp) 方法</li><li>select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。</li><li>rebuildSelector方法先通过openSelector方法创建一个新的selector</li><li>然后将old selector的selectionKey执行cancel</li><li>最后将old selector的channel重新注册到新的selector中</li><li>rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。</li><li>接下来调用processSelectedKeys 方法（处理I&#x2F;O任务），当selectedKeys !&#x3D; null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。</li><li>最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。</li><li>每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。</li><li>Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head</li><li>Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。</li></ul><h4 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h4><ul><li>首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成</li><li>Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址</li><li>当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了</li><li>大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。</li></ul><h4 id="ByteBuf的特点"><a href="#ByteBuf的特点" class="headerlink" title="ByteBuf的特点"></a>ByteBuf的特点</h4><ul><li>支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）</li><li>不需要调用flip()来切换读&#x2F;写模式，读取和写入索引分开</li><li>方法链</li><li>引用计数基于AtomicIntegerFieldUpdater用于内存回收</li><li>PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象</li><li>UnpooledHeapByteBuf每次都会新建一个缓冲区对象。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/0777702c9d7f.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/0777702c9d7f.html" class="post-title-link" itemprop="url">RPC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:06:30" itemprop="dateCreated datePublished" datetime="2023-12-20T16:06:30+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 16:13:22" itemprop="dateModified" datetime="2023-12-24T16:13:22+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rpc/" itemprop="url" rel="index"><span itemprop="name">rpc</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h1><ul><li>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。</li><li>当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。</li><li>除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</li><li>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。</li><li>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</li><li>RPC 在我们熟知的各种中间件中都有它的身影。</li><li>Nginx&#x2F;Redis&#x2F;MySQL&#x2F;Dubbo&#x2F;Hadoop&#x2F;Spark&#x2F;Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的</li><li>我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。</li></ul><h1 id="Nginx-与-RPC"><a href="#Nginx-与-RPC" class="headerlink" title="Nginx 与 RPC"></a>Nginx 与 RPC</h1><ul><li>Ngnix 是互联网企业使用最为广泛的代理服务器。</li><li>它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务</li><li>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互</li><li>也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。</li><li>你说的没错，不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</li><li>uWSGI 是著名的 Python 容器，使用它可以启动 uwsgi 协议的服务器对外提供服务。</li><li>uwsgi 通讯协议在 Python 语言体系里使用非常普遍，如果一个企业内部使用 Python 语言栈搭建 Web 服务，那么他们在生产环境部署 Python 应用的时候不是在使用 HTTP 协议就是在使用 uwsgi 协议来和 Nginx 之间建立通讯。</li><li>Fastcgi 协议在 PHP 语言体系里非常常见，Nginx 和 PHP-fpm 进程之间一般较常使用 Fastcgi 协议进行通讯。</li></ul><h1 id="Hadoop-与-RPC"><a href="#Hadoop-与-RPC" class="headerlink" title="Hadoop 与 RPC"></a>Hadoop 与 RPC</h1><ul><li>在大数据技术领域，RPC 也占据了非常重要的地位</li><li>大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在</li><li>大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。</li><li>比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</li></ul><h1 id="TensorFlow-与-RPC"><a href="#TensorFlow-与-RPC" class="headerlink" title="TensorFlow 与 RPC"></a>TensorFlow 与 RPC</h1><ul><li>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯</li><li>Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</li></ul><h1 id="Http-与-RPC"><a href="#Http-与-RPC" class="headerlink" title="Http 与 RPC"></a>Http 与 RPC</h1><ul><li>HTTP 调用其实也是一种特殊的 RPC</li><li>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。</li><li>HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</li><li>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了</li><li>所以在后文我们不再明确强调 RPC 和 HTTP 请求调用之间的细微区别了，直接统一称之为 RPC。</li></ul><h1 id="HTTP-VS-RPC-（普通话-VS-方言）"><a href="#HTTP-VS-RPC-（普通话-VS-方言）" class="headerlink" title="HTTP VS RPC （普通话 VS 方言）"></a>HTTP VS RPC （普通话 VS 方言）</h1><ul><li>HTTP 与 RPC 的关系就好比普通话与方言的关系</li><li>要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本</li><li>但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源</li><li>整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。</li><li>如果再深入一点说，普通话本质上也是一种方言，只不过它是官方的方言，使用最为广泛的方言，相比而言其它方言都是小语种，小语种之中也会有几个使用比较广泛比较特色的方言占比也会比较大。</li><li>这就好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</li></ul><h1 id="换个角度看世界"><a href="#换个角度看世界" class="headerlink" title="换个角度看世界"></a>换个角度看世界</h1><ul><li>分布式子系统交互方案，除了 RPC 技术之外还有数据库、消息队列和缓存。但其实这三者本质上是 RPC 技术的一个应用组合。</li><li>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。</li><li>如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL</li><li>在互联网企业里一般都会使用这种主从读写分离的数据库</li><li>一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来</li><li>这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/235b69f65d9c.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/235b69f65d9c.html" class="post-title-link" itemprop="url">Spring MVC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:05:16" itemprop="dateCreated datePublished" datetime="2023-12-20T16:05:16+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-27 16:25:51" itemprop="dateModified" datetime="2023-12-27T16:25:51+08:00">2023-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring-MVC/" itemprop="url" rel="index"><span itemprop="name">Spring MVC</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是SpringMvc？"><a href="#什么是SpringMvc？" class="headerlink" title="什么是SpringMvc？"></a>什么是SpringMvc？</h1><ul><li>SpringMvc是spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。</li></ul><h1 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h1><ul><li>它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成. </li><li>不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的) </li><li>可以任意使用各种视图技术,而不仅仅局限于JSP </li><li>支持各种请求资源的映射策略 </li><li>它应是易于扩展的</li></ul><h1 id="SpringMVC工作原理？"><a href="#SpringMVC工作原理？" class="headerlink" title="SpringMVC工作原理？"></a>SpringMVC工作原理？</h1><h4 id="简要回答"><a href="#简要回答" class="headerlink" title="简要回答"></a>简要回答</h4><ul><li>客户端发送请求到DispatcherServlet </li><li>DispatcherServlet查询handlerMapping找到处理请求的Controller </li><li>Controller调用业务逻辑后，返回ModelAndView </li><li>DispatcherServlet查询ModelAndView，找到指定视图 </li><li>视图将结果返回到客户端</li></ul><h4 id="详细回答"><a href="#详细回答" class="headerlink" title="详细回答"></a>详细回答</h4><ul><li>用户发送请求至前端控制器DispatcherServlet。 </li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li><li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li><li>Controller执行完成返回ModelAndView。 </li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 </li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li><li>ViewReslover解析后返回具体View。 </li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li><li>DispatcherServlet响应用户。</li></ul><h4 id="详细回答2"><a href="#详细回答2" class="headerlink" title="详细回答2"></a>详细回答2</h4><ul><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter处理器适配器</li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户</li></ul><h1 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h1><ul><li><p>在web.xml中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li><li><p>以上可以解决post请求乱码问题</p></li><li><p>对于get请求中文参数出现乱码解决方法有两个：</p><ul><li><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>另外一种方法对参数进行重新编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p></li></ul><h1 id="SpringMVC与Struts2的主要区别？"><a href="#SpringMVC与Struts2的主要区别？" class="headerlink" title="SpringMVC与Struts2的主要区别？"></a>SpringMVC与Struts2的主要区别？</h1><ul><li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li><li>springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li><li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。Jsp视图解析器默认使用jstl。</li><li>springmvc是基于方法开发，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li></ul><h1 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h1><ul><li>是单例模式</li><li>所以在多线程访问的时候有线程安全问题</li><li>不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</li></ul><h1 id="SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</h1><ul><li>一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。</li></ul><h1 id="RequestMapping注解用在类上面有什么作用？"><a href="#RequestMapping注解用在类上面有什么作用？" class="headerlink" title="@RequestMapping注解用在类上面有什么作用？"></a>@RequestMapping注解用在类上面有什么作用？</h1><ul><li>是一个用来处理请求地址映射的注解，可用于类或方法上</li><li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li></ul><h1 id="怎么样把某个请求映射到特定的方法上面？"><a href="#怎么样把某个请求映射到特定的方法上面？" class="headerlink" title="怎么样把某个请求映射到特定的方法上面？"></a>怎么样把某个请求映射到特定的方法上面？</h1><ul><li>直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径</li></ul><h1 id="如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？"><a href="#如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？" class="headerlink" title="如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？"></a>如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？</h1><ul><li>可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET</li></ul><h1 id="怎么样在方法里面得到Request-或者Session？"><a href="#怎么样在方法里面得到Request-或者Session？" class="headerlink" title="怎么样在方法里面得到Request,或者Session？"></a>怎么样在方法里面得到Request,或者Session？</h1><ul><li>直接在方法的形参中声明request,SpringMvc就自动把request对象传入</li></ul><h1 id="我想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#我想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="我想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>我想在拦截的方法里面得到从前台传入的参数,怎么得到？</h1><ul><li>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样</li></ul><h1 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h1><ul><li>直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</li></ul><h1 id="SpringMvc中函数的返回值是什么？"><a href="#SpringMvc中函数的返回值是什么？" class="headerlink" title="SpringMvc中函数的返回值是什么？"></a>SpringMvc中函数的返回值是什么？</h1><ul><li>返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。</li></ul><h1 id="SpringMVC怎么样设定重定向和转发的？"><a href="#SpringMVC怎么样设定重定向和转发的？" class="headerlink" title="SpringMVC怎么样设定重定向和转发的？"></a>SpringMVC怎么样设定重定向和转发的？</h1><ul><li>在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name&#x3D;method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:<a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a>“</li></ul><h1 id="SpringMvc用什么对象从后台向前台传递数据的？"><a href="#SpringMvc用什么对象从后台向前台传递数据的？" class="headerlink" title="SpringMvc用什么对象从后台向前台传递数据的？"></a>SpringMvc用什么对象从后台向前台传递数据的？</h1><ul><li>通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。</li></ul><h1 id="SpringMvc中有个类把视图和数据都合并的一起的-叫什么？"><a href="#SpringMvc中有个类把视图和数据都合并的一起的-叫什么？" class="headerlink" title="SpringMvc中有个类把视图和数据都合并的一起的,叫什么？"></a>SpringMvc中有个类把视图和数据都合并的一起的,叫什么？</h1><ul><li>叫ModelAndView。</li></ul><h1 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h1><ul><li>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key</li></ul><h1 id="SpringMvc怎么和AJAX相互调用的？"><a href="#SpringMvc怎么和AJAX相互调用的？" class="headerlink" title="SpringMvc怎么和AJAX相互调用的？"></a>SpringMvc怎么和AJAX相互调用的？</h1><ul><li>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。 </li><li>具体步骤如下 ：<ul><li>加入Jackson.jar </li><li>在配置文件中配置json的映射 </li><li>在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</li></ul></li></ul><h1 id="当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？"><a href="#当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？" class="headerlink" title="当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？"></a>当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</h1><ul><li>要加上@ResponseBody注解</li></ul><h1 id="SpringMvc里面拦截器是怎么写的"><a href="#SpringMvc里面拦截器是怎么写的" class="headerlink" title="SpringMvc里面拦截器是怎么写的"></a>SpringMvc里面拦截器是怎么写的</h1><ul><li>有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;    </span><br><span class="line">    &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;   </span><br><span class="line">    &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.et.action.MyHandlerInterceptor&quot;&gt;&lt;/bean&gt;    </span><br><span class="line">    &lt;!-- 只针对部分请求拦截 --&gt;    </span><br><span class="line">    &lt;mvc:interceptor&gt;       </span><br><span class="line">        &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;       </span><br><span class="line">        &lt;bean class=&quot;com.et.action.MyHandlerInterceptorAdapter&quot; /&gt;  </span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="讲下SpringMvc的执行流程"><a href="#讲下SpringMvc的执行流程" class="headerlink" title="讲下SpringMvc的执行流程"></a>讲下SpringMvc的执行流程</h1><ul><li>系统启动的时候根据配置文件创建spring的容器</li><li>首先是发送http请求到核心控制器disPatherServlet</li><li>spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类</li><li>在进业务类时进行数据封装，在封装前可能会涉及到类型转换</li><li>执行完业务类后使用ModelAndView进行视图转发</li><li>数据放在model中，用map传递数据进行页面显示</li></ul><h1 id="框架的优缺点SpringMVC-Struts2等…"><a href="#框架的优缺点SpringMVC-Struts2等…" class="headerlink" title="框架的优缺点SpringMVC,Struts2等…"></a>框架的优缺点SpringMVC,Struts2等…</h1><ul><li>Struts2是类级别拦截，参数为类中所有⽅法共有，⼀个Action对应⼀个request上下⽂，SpringMVC是⽅法级别拦截，参数为对应⽅法所有；</li><li>由于Struts2需要针对每个request进⾏封装，把request，session等servlet⽣命周期的变量封装成⼀个⼀个Map，供给每个Action使⽤，并保证线程安全，所以在原则上，是⽐较耗费内存的。</li><li>拦截器实现机制上，Struts2有以⾃⼰的interceptor机制，SpringMVC⽤的是独⽴的AOP⽅式，这样导致Struts2的配置⽂件量还是⽐SpringMVC⼤。</li><li>SpringMVC的⼊⼝是servlet，⽽Struts2是filter</li><li>SpringMVC集成了Ajax，使⽤⾮常⽅便，只需⼀个注解@ResponseBody就可以实现，然后直接返回响应⽂本即可，⽽Struts2拦截器集成了Ajax，在Action中处理时⼀般必须安装插件或者⾃⼰写代码集成进去，使⽤起来也相对不⽅便。</li><li>SpringMVC开发效率和性能⾼于Struts2。</li><li>SpringMVC配置少，零配置。</li></ul><h1 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h1><ul><li>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序</li><li>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/c9fa4a3e43dd.html" class="post-title-link" itemprop="url">Spring</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:03:58" itemprop="dateCreated datePublished" datetime="2023-12-20T16:03:58+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-27 17:13:50" itemprop="dateModified" datetime="2023-12-27T17:13:50+08:00">2023-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>25k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>22 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><ul><li>AOP(Aspect-Oriented Programming), 即 面向切面编程</li><li>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题</li><li>这些交叉问题与应用程序的主要业务逻辑不同</li><li>因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。</li></ul><h1 id="Spring中Bean的⽣命周期。"><a href="#Spring中Bean的⽣命周期。" class="headerlink" title="Spring中Bean的⽣命周期。"></a>Spring中Bean的⽣命周期。</h1><ul><li>Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅法-》调⽤InitializationBean的afterPropertiesSet()的⽅法-》调⽤定制的初始化⽅法callCustom的init-method-》调⽤BeanPostProsessor的后初始化⽅法-》Bean可以使⽤了 -》 容器关闭-》 调⽤DisposableBean的destroy⽅法-》调⽤定制的销毁⽅法CallCustom的destroy-method。</li><li>Spring对Bean进⾏实例化（相当于程序中的new Xx()）</li><li>Spring将值和Bean的引⽤注⼊进Bean对应的属性中</li><li>如果Bean实现了BeanNameAware接⼝，Spring将Bean的ID传递给setBeanName()⽅法（实现BeanNameAware清主要是为了通过Bean的引⽤来获得Bean的ID，⼀般业务中是很少有⽤到Bean的ID的）</li><li>如果Bean实现了BeanFactoryAware接⼝，Spring将调⽤setBeanDactory(BeanFactory bf)⽅法并把BeanFactory容器实例作为参数传⼊。（实现BeanFactoryAware 主要⽬的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</li><li>如果Bean实现了ApplicationContextAwaer接⼝，Spring容器将调⽤setApplicationContext(ApplicationContext ctx)⽅法，把y应⽤上下⽂作为参数传⼊.(作⽤与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调⽤setApplicationContext⽅法时会把它⾃⼰作为setApplicationContext 的参数传⼊，⽽Spring容器在调⽤setBeanDactory前需要程序员⾃⼰指定（注⼊）setBeanDactory⾥的参数BeanFactory )</li><li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessBeforeInitialization（预初始化）⽅法（作⽤是在Bean实例创建成功后对进⾏增强处理，如对Bean进⾏修改，增加某个功能）7.如果Bean实现了InitializingBean接⼝，Spring将调⽤它们的afterPropertiesSet⽅法，作⽤与在配置⽂件中对Bean使⽤init-method声明初始化的作⽤⼀样，都是在Bean的全部属性设置成功后执⾏的初始化⽅法。</li><li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessAfterInitialization（后初始化）⽅法（作⽤与7的⼀样，只不过7是在Bean初始化前执⾏的，⽽这个是在Bean初始化后执⾏的，时机不同 ）</li><li>经过以上的⼯作后，Bean将⼀直驻留在应⽤上下⽂中给应⽤使⽤，直到应⽤上下⽂被销毁</li><li>如果Bean实现了DispostbleBean接⼝，Spring将调⽤它的destory⽅法，作⽤与在配置⽂件中对Bean使⽤destory￾method属性的作⽤⼀样，都是在Bean实例销毁前执⾏的⽅法。</li></ul><h1 id="Spring-AOP解决了什么问题？怎么实现的？"><a href="#Spring-AOP解决了什么问题？怎么实现的？" class="headerlink" title="Spring AOP解决了什么问题？怎么实现的？"></a>Spring AOP解决了什么问题？怎么实现的？</h1><ul><li>作⽤<ul><li>AOP技术，利⽤⼀种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共⾏为封装到⼀个可重⽤模块，并将其名为“Aspect”，即⽅⾯</li><li>所谓“⽅⾯”，简单地说，就是将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li></ul></li><li>实现：<ul><li>⼀是采⽤动态代理技术，利⽤截取消息的⽅式，对该消息进⾏装饰，以取代原有对象⾏为的执⾏；</li><li>⼆是采⽤静态织⼊的⽅式，引⼊特定的语法创建“⽅⾯”，从⽽使得编译器可以在编译期间织⼊有关“⽅⾯”的代码。</li></ul></li><li>使⽤场景：<ul><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading　懒加载</li><li>Debugging　　调试</li><li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li><li>Performance optimization　性能优化</li><li>Persistence　　持久化</li><li>Resource pooling　资源池</li><li>Synchronization　同步</li><li>Transactions 事务</li></ul></li><li>⼏个概念：<ul><li>切⾯（Aspect）：对象操作过程中的截⾯，这可能是AOP中最为关键的术语。切⾯所要做的事就是专注于各⾃领域的逻辑实现，这样可以使得开发逻辑更加清晰，更加适合专业的分⼯合作。由于切⾯的隔离性，降低了耦合，这样就可以在不同的应⽤中将各个切⾯组合使⽤，从⽽是代码重⽤性⼤⼤增加。</li><li>连接点：程序运⾏过程中的某个阶段点，如某个⽅法的调⽤，或者异常的抛出。</li><li>处理逻辑（Advice）：在某⼀个连接点所采⽤的处理逻辑，处理逻辑的调⽤模式通常有三种：<ul><li>Around 在连接点前后插⼊预处理过程和后处理过程。</li><li>Before 仅在连接点钱出⼊处理过程。</li><li>Throw 在连接点抛出异常时进⾏异常处理。</li></ul></li><li>切点（PointCut）：⼀系列连接点的集合，它指明处理逻辑将在合适触发。</li></ul></li></ul><h1 id="Spring事务的传播属性是怎么回事？它会影响什么？"><a href="#Spring事务的传播属性是怎么回事？它会影响什么？" class="headerlink" title="Spring事务的传播属性是怎么回事？它会影响什么？"></a>Spring事务的传播属性是怎么回事？它会影响什么？</h1><ul><li>七个事务传播属性：<ul><li>PROPAGATION_REQUIRED – ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。</li><li>PROPAGATION_SUPPORTS – ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</li><li>PROPAGATION_MANDATORY – ⽀持当前事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATIONREQUIRESNEW – 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATIONNOTSUPPORTED – 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER – 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</li><li>PROPAGATIONNESTED – 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与PROPAGATIONREQUIRED类似的操作。</li></ul></li><li>五个隔离级别：<ul><li>ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.</li><li>另外四个与JDBC的隔离级别相对应：<ul><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种隔离级别会产⽣脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不可重复读外，还避免了幻读。</li></ul></li></ul></li><li>关键词：<ul><li>幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；</li><li>不可重复读：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；</li><li>脏读：事务1更新了记录，但没有提交，事务2读取了更新后的⾏，然后事务T1回滚，现在T2读取⽆效。</li></ul></li></ul><h1 id="Spring中BeanFactory和FactoryBean有什么区别？"><a href="#Spring中BeanFactory和FactoryBean有什么区别？" class="headerlink" title="Spring中BeanFactory和FactoryBean有什么区别？"></a>Spring中BeanFactory和FactoryBean有什么区别？</h1><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul><li>以Factory结尾，表示它是⼀个⼯⼚类(接⼝)，⽤于管理Bean的⼀个⼯⼚</li><li>在Spring中，BeanFactory是IOC容器的核⼼接⼝，它的职责包括：实例化、定位、配置应⽤程序中的对象及建⽴这些对象间的依赖。</li></ul><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><ul><li>以Bean结尾，表示它是⼀个Bean，不同于普通Bean的是：它是实现了FactoryBean接⼝的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽不是FactoryBean本身</li><li>如果要获取FactoryBean对象，请在id前⾯加⼀个&amp;符号来获取。</li></ul><h1 id="Spring框架中IOC的原理是什么？"><a href="#Spring框架中IOC的原理是什么？" class="headerlink" title="Spring框架中IOC的原理是什么？"></a>Spring框架中IOC的原理是什么？</h1><ul><li>IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。</li><li>在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</li><li>在系统运⾏中，动态的向某个对象提供它所需要的其他对象。</li><li>依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li></ul><h1 id="spring的依赖注⼊有哪⼏种⽅式"><a href="#spring的依赖注⼊有哪⼏种⽅式" class="headerlink" title="spring的依赖注⼊有哪⼏种⽅式"></a>spring的依赖注⼊有哪⼏种⽅式</h1><ul><li>在Spring容器中为⼀个bean配置依赖注⼊有四种⽅式：<ul><li>使⽤属性的setter⽅法注⼊ 这是最常⽤的⽅式；</li><li>使⽤构造器注⼊；</li><li>使⽤Filed注⼊（⽤于注解⽅式）.</li><li>静态、实例⼯⼚的⽅法注⼊</li></ul></li></ul><h1 id="⽤Spring如何实现⼀个切⾯？"><a href="#⽤Spring如何实现⼀个切⾯？" class="headerlink" title="⽤Spring如何实现⼀个切⾯？"></a>⽤Spring如何实现⼀个切⾯？</h1><ul><li>@Aspect</li></ul><h1 id="Spring如何实现数据库事务？"><a href="#Spring如何实现数据库事务？" class="headerlink" title="Spring如何实现数据库事务？"></a>Spring如何实现数据库事务？</h1><ul><li>使⽤@Transactional注解或在配置⽂件⾥⾯配置</li></ul><h1 id="Spring加载次序Classloader"><a href="#Spring加载次序Classloader" class="headerlink" title="Spring加载次序Classloader"></a>Spring加载次序Classloader</h1><ul><li>先构造函数——&gt;然后是bean的set⽅法注⼊——&gt;InitializingBean的afterPropertiesSet⽅法——&gt;init-method⽅法；</li><li>InitializingBean接⼝为bean提供了初始化⽅法的⽅式，它只包括afterPropertiesSet⽅法，凡是继承该接⼝的类，在初始化bean的时候会执⾏该⽅法。系统则是先调⽤afterPropertiesSet⽅法，然后在调⽤init-method中指定的⽅法。</li><li>Spring装配Bean的过程：<ul><li>实例化;</li><li>设置属性值;</li><li>如果实现了BeanNameAware接⼝,调⽤setBeanName设置Bean的ID或者Name;</li><li>如果实现BeanFactoryAware接⼝,调⽤setBeanFactory 设置BeanFactory;</li><li>如果实现ApplicationContextAware,调⽤setApplicationContext设置ApplicationContext</li><li>调⽤BeanPostProcessor的预先初始化⽅法;</li><li>调⽤InitializingBean的afterPropertiesSet()⽅法;</li><li>调⽤定制init-method⽅法；</li><li>调⽤BeanPostProcessor的后初始化⽅法;</li></ul></li><li>Spring容器关闭过程：<ul><li>调⽤DisposableBean的destroy();</li><li>调⽤定制的destroy-method⽅法;</li></ul></li></ul><h1 id="IOC控制反转与DI依赖注⼊"><a href="#IOC控制反转与DI依赖注⼊" class="headerlink" title="IOC控制反转与DI依赖注⼊"></a>IOC控制反转与DI依赖注⼊</h1><ul><li>IOC控制反转：是⼀种将对象交给容器去控制的设计思想，松耦合，⽅便单元测试，增加功能重⽤性；</li><li>DI依赖注⼊：组件之间依赖关系由容器在运⾏期决定，形象的说，即由容器动态的将某个依赖关系注⼊到组件之中。依赖注⼊的⽬的并⾮为软件系统带来更多功能，⽽是为了提升组件重⽤的频率，并为系统搭建⼀个灵活、可扩展的平台。通过依赖注⼊机制，我们只需要通过简单的配置，⽽⽆需任何代码就可指定⽬标需要的资源，完成⾃身的业务逻辑，⽽不需要关⼼具体的资源来⾃何处，由谁实现。</li><li>AOP⾯向切⾯编程：⾯向切⾯编程（AOP）完善spring的依赖注⼊（DI）。</li></ul><h1 id="spring事件的实现原理，写出常⽤的⼏个事件。"><a href="#spring事件的实现原理，写出常⽤的⼏个事件。" class="headerlink" title="spring事件的实现原理，写出常⽤的⼏个事件。"></a>spring事件的实现原理，写出常⽤的⼏个事件。</h1><ul><li>事件机制：Spring中的事件机制是⼀个观察者模式的实现，观察者模式就是⼀个⽬标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。</li><li>spring默认存在的事件：<ul><li>ContextStartedEvent：ApplicationContext启动后触发的事件</li><li>ContextStoppedEvent：ApplicationContext停⽌后触发的事件</li><li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件</li><li>ContextClosedEvent：ApplicationContext关闭后触发的事件</li></ul></li></ul><h1 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h1><ul><li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li><li>它是轻量级、松散耦合的。</li><li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li><li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li></ul><h1 id="列举-Spring-Framework-的优点"><a href="#列举-Spring-Framework-的优点" class="headerlink" title="列举 Spring Framework 的优点"></a>列举 Spring Framework 的优点</h1><ul><li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li><li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li><li>由于依赖注入和控制反转，JDBC 得以简化。</li><li>它是开源免费的。</li></ul><h1 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h1><ul><li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li><li>IOC - 控制反转</li><li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li><li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li><li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li><li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li><li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li></ul><h1 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h1><ul><li>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：<ul><li>Spring Core</li><li>Spring Bean</li><li>SpEL (Spring Expression Language)</li><li>Spring Context</li></ul></li><li>数据访问&#x2F;集成 – 该层提供与数据库交互的支持。它包含以下模块：<ul><li>JDBC (Java DataBase Connectivity)</li><li>ORM (Object Relational Mapping)</li><li>OXM (Object XML Mappers)</li><li>JMS (Java Messaging Service)</li><li>Transaction</li></ul></li><li>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<ul><li>Web</li><li>Web – Servlet</li><li>Web – Socket</li><li>Web – Portlet</li></ul></li><li>AOP – 该层支持面向切面编程<ul><li>Instrumentation – 该层为类检测和类加载器实现提供支持。</li><li>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</li></ul></li><li>几个杂项模块:<ul><li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li><li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li></ul></li></ul><h1 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h1><ul><li>Spring 配置文件是 XML 文件</li><li>该文件主要包含类信息</li><li>它描述了这些类是如何配置以及相互引入的</li><li>但是，XML 配置文件冗长且更加干净</li><li>如果没有正确规划和编写，那么在大项目中管理变得非常困难。</li></ul><h1 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h1><ul><li>接口 - 定义功能。</li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li><li>用户程序 - 它使用接口。</li></ul><h1 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h1><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>用于远程使用。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li></ul><h1 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h1><ul><li>Spring 框架的核心是 Spring 容器</li><li>容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期</li><li>Spring 容器使用依赖注入来管理组成应用程序的组件</li><li>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令</li><li>该元数据可以通过 XML，Java 注解或 Java 代码提供。</li></ul><h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><ul><li>在依赖注入中，您不必创建对象，但必须描述如何创建它们</li><li>您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务</li><li>由 IoC 容器将它们装配在一起。</li></ul><h1 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h1><ul><li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li><li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h1 id="列举-IoC-的一些好处。"><a href="#列举-IoC-的一些好处。" class="headerlink" title="列举 IoC 的一些好处。"></a>列举 IoC 的一些好处。</h1><ul><li>它将最小化应用程序中的代码量。</li><li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li><li>它以最小的影响和最少的侵入机制促进松耦合。</li><li>它支持即时的实例化和延迟加载服务。</li></ul><h1 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h1><ul><li>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</li></ul><h1 id="什么是-spring-bean？"><a href="#什么是-spring-bean？" class="headerlink" title="什么是 spring bean？"></a>什么是 spring bean？</h1><ul><li>它们是构成用户应用程序主干的对象。</li><li>Bean 由 Spring IoC 容器管理。</li><li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li><li>Bean 是基于用户提供给容器的配置元数据创建。</li></ul><h1 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h1><ul><li>基于 xml 配置<ul><li>bean 所需的依赖项和服务在 XML 格式的配置文件中指定</li><li>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项</li><li>它们通常以 bean 标签开头</li></ul></li><li>基于注解配置<ul><li>可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配</li><li>默认情况下，Spring 容器中未打开注解装配</li><li>因此，您需要在使用它之前在 Spring 配置文件中启用它：<a href="context:annotation-config/">context:annotation-config/</a></li></ul></li><li>基于 Java API 配置<ul><li>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul><li>@Bean 注解扮演与<bean>元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul></li></ul></li></ul><h1 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h1><ul><li>Spring bean 支持 5 种 scope：<ul><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li></ul></li><li>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</li></ul><h1 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h1><ul><li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li><li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li><li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li><li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li><li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li><li>如果为 bean 指定了 init 方法（<bean>的 init-method 属性），那么将调用它。</bean></li><li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li><li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li><li>如果为 bean 指定了 destroy 方法（<bean>的 destroy-method 属性），那么将调用它。</bean></li></ul><h1 id="什么是-spring-的内部-bean？"><a href="#什么是-spring-的内部-bean？" class="headerlink" title="什么是 spring 的内部 bean？"></a>什么是 spring 的内部 bean？</h1><ul><li>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean</li><li>为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg>中提供了<bean>元素的使用</bean></constructor-arg></property></li><li>内部 bean 总是匿名的，它们总是作为原型。</li></ul><h1 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h1><ul><li>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配</li><li>Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</li></ul><h1 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h1><ul><li>Spring 容器能够自动装配 bean</li><li>也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</li><li>自动装配的不同模式：<ul><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ul></li></ul><h1 id="自动装配有什么局限？"><a href="#自动装配有什么局限？" class="headerlink" title="自动装配有什么局限？"></a>自动装配有什么局限？</h1><ul><li>覆盖的可能性 - 您始终可以使用<constructor-arg>和<property>设置指定依赖项，这将覆盖自动装配。</property></constructor-arg></li><li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li><li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li></ul><h1 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h1><ul><li>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身</li><li>它可以作为 XML 设置的替代方案。例如：Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul><li>@Bean 注解扮演与元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul></li></ul><h1 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h1><ul><li>默认情况下，Spring 容器中未打开注解装配</li><li>要使用基于注解装配，我们必须通过配置&lt;context：annotation-config &#x2F;&gt; 元素在 Spring 配置文件中启用它</li></ul><h1 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h1><ul><li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li><li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h1 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h1><ul><li>Required 应用于 bean 属性 setter 方法</li><li>此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性</li><li>如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    @Required</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    public string getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h1><ul><li>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配</li><li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean</li><li>默认情况下，它是类型驱动的注入。</li></ul><h1 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h1><ul><li>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</li><li>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</li></ul><h1 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h1><ul><li>RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法</li><li>此注释可应用于两个级别：<ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul></li></ul><h1 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h1><ul><li>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作</li><li>这使得用户容易在持久性技术之间切换</li><li>它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</li></ul><h1 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h1><pre><code>- JdbcTemplate
- SimpleJdbcTemplate
- NamedParameterJdbcTemplate
- SimpleJdbcInsert
- SimpleJdbcCall
</code></pre><h1 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h1><ul><li>我们可以通过两种方式使用 Spring 访问 Hibernate：<ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul></li></ul><h1 id="列举-spring-支持的事务管理类型"><a href="#列举-spring-支持的事务管理类型" class="headerlink" title="列举 spring 支持的事务管理类型"></a>列举 spring 支持的事务管理类型</h1><ul><li>Spring 支持两种类型的事务管理：<ul><li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li><li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li></ul></li></ul><h1 id="spring-支持哪些-ORM-框架"><a href="#spring-支持哪些-ORM-框架" class="headerlink" title="spring 支持哪些 ORM 框架"></a>spring 支持哪些 ORM 框架</h1><ul><li>Hibernate</li><li>iBatis</li><li>JPA</li><li>JDO</li><li>OJB</li></ul><h1 id="指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h1><ul><li>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</li><li>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</li></ul><h1 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h1><ul><li>实现 AOP 的技术，主要分为两大类：<ul><li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul></li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul><li>JDK 动态代理</li><li>CGLIB</li></ul></li></ul></li></ul><h1 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h1><ul><li>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</li><li>Spring AOP 仅支持方法级别的 PointCut；AspectJ 提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</li></ul><h1 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h1><ul><li>将 Advice 应用于目标对象后创建的对象称为代理</li><li>在客户端对象的情况下，目标对象和代理对象是相同的。</li><li>Advice + Target Object &#x3D; Proxy</li></ul><h1 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h1><ul><li>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）</li><li>在 Spring AOP 中，编织在运行时执行</li></ul><h1 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h1><ul><li>WebApplicationContext 是 ApplicationContext 的扩展</li><li>它具有 Web 应用程序所需的一些额外功能</li><li>它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</li></ul><h1 id="IoC-和-DI的区别？"><a href="#IoC-和-DI的区别？" class="headerlink" title="IoC 和 DI的区别？"></a>IoC 和 DI的区别？</h1><ul><li>IoC 控制反转，指将对象的创建权，反转到Spring容器</li><li>DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</li></ul><p> </p><h1 id="BeanFactory-接口和-ApplicationContext-接口有什么区别？"><a href="#BeanFactory-接口和-ApplicationContext-接口有什么区别？" class="headerlink" title="BeanFactory 接口和 ApplicationContext 接口有什么区别？"></a>BeanFactory 接口和 ApplicationContext 接口有什么区别？</h1><ul><li>ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。</li><li>ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));</span><br><span class="line">IHelloService helloService = (IHelloService) beanFactory.getBean(&quot;helloService&quot;);</span><br><span class="line">helloService.sayHello();</span><br></pre></td></tr></table></figure></li></ul><h1 id="spring配置bean实例化有哪些方式？"><a href="#spring配置bean实例化有哪些方式？" class="headerlink" title="spring配置bean实例化有哪些方式？"></a>spring配置bean实例化有哪些方式？</h1><ul><li>使用类构造器实例化(默认无参数)</li><li>使用静态工厂方法实例化(简单工厂模式)</li><li>使用实例工厂方法实例化(工厂方法模式)</li></ul><h1 id="简单的说一下spring的生命周期？"><a href="#简单的说一下spring的生命周期？" class="headerlink" title="简单的说一下spring的生命周期？"></a>简单的说一下spring的生命周期？</h1><ul><li>instantiate bean对象实例化</li><li>populate properties 封装属性</li><li>如果Bean实现BeanNameAware 执行 setBeanName</li><li>如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext</li><li>如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)</li><li>如果Bean实现InitializingBean 执行 afterPropertiesSet </li><li>调用<bean init-method="init"> 指定初始化方法 init</bean></li><li>如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization</li><li>执行业务处理</li><li>如果Bean实现 DisposableBean 执行 destroy</li><li>调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy</bean></li></ul><h1 id="请介绍一下Spring框架中Bean的生命周期和作用域"><a href="#请介绍一下Spring框架中Bean的生命周期和作用域" class="headerlink" title="请介绍一下Spring框架中Bean的生命周期和作用域"></a>请介绍一下Spring框架中Bean的生命周期和作用域</h1><ul><li>bean定义：在配置文件里面用<bean></bean>来进行定义。</li><li>bean初始化，有两种方式初始化:<ul><li>在配置文件中通过指定init-method属性来完成</li><li>实现org.springframwork.beans.factory.InitializingBean接口</li></ul></li><li>bean调用：有三种方式可以得到bean实例，并进行调用</li><li>bean销毁，销毁有两种方式<ul><li>使用配置文件指定的destroy-method属性</li><li>实现org.springframwork.bean.factory.DisposeableBean接口</li></ul></li><li>作用域<ul><li>singleton：当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</li><li>prototype：Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域</li><li>request：在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>global session：在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</li></ul></li></ul><h1 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h1><ul><li>BeanFactory：产生一个新的实例，可以实现单例模式</li><li>BeanWrapper：提供统一的get及set方法</li><li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li></ul><h1 id="Spring里面applicationContext-xml文件能不能改成其他文件名？"><a href="#Spring里面applicationContext-xml文件能不能改成其他文件名？" class="headerlink" title="Spring里面applicationContext.xml文件能不能改成其他文件名？"></a>Spring里面applicationContext.xml文件能不能改成其他文件名？</h1><ul><li>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化</li><li>缺省情况下， 它会在WEB-INF&#x2F;applicationContext.xml文件找Spring的配置</li><li>你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的位置</context-param></li></ul><p>11.Spring里面如何定义hibernate mapping？ </p><ul><li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li></ul><h1 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h1><ul><li>Spring使用ThreadLocal解决线程安全问题</li><li>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域</li><li>就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</li><li>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</li><li>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量</li><li>这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</li><li>而ThreadLocal则从另一个角度来解决多线程的并发访问</li><li>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突</li><li>因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li><li>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</li><li>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换</li><li>但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。</li><li>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li><li>前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li></ul><h1 id="介绍一下Spring的事物管理"><a href="#介绍一下Spring的事物管理" class="headerlink" title="介绍一下Spring的事物管理"></a>介绍一下Spring的事物管理</h1><ul><li>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</li><li>开发中为了避免这种情况一般都会进行事务管理</li><li>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能</li><li>spring提供了几个关于事务处理的类：<ul><li>TransactionDefinition &#x2F;&#x2F;事务属性定义</li><li>TranscationStatus &#x2F;&#x2F;代表了当前的事务，可以提交，回滚。</li><li>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。</li></ul></li><li>spring提供的事务管理可以分为两类：编程式的和声明式的<ul><li>编程式的，比较灵活，但是代码量大，存在重复的代码比较多</li><li>声明式的比编程式的更灵活。</li></ul></li><li>编程式主要使用transactionTemplate</li><li>省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.</li></ul><h1 id="AOP-通知有哪些类型？"><a href="#AOP-通知有哪些类型？" class="headerlink" title="AOP 通知有哪些类型？"></a>AOP 通知有哪些类型？</h1><ul><li>前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li><li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li><li>后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li><li>环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</li></ul><h1 id="什么是-spring"><a href="#什么是-spring" class="headerlink" title="什么是 spring?"></a>什么是 spring?</h1><ul><li>Spring 是个 java 企业级应用的开源开发框架</li><li>Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用</li><li>Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</li></ul><h1 id="使用-Spring-框架的好处是什么？"><a href="#使用-Spring-框架的好处是什么？" class="headerlink" title="使用 Spring 框架的好处是什么？"></a>使用 Spring 框架的好处是什么？</h1><ul><li>轻量：Spring 是轻量的，基本的版本大约 2MB</li><li>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li><li>容器：Spring 包含并管理应用中对象的生命周期和配置</li><li>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品</li><li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li><li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</li></ul><h1 id="ApplicationContext-通常的实现是什么？"><a href="#ApplicationContext-通常的实现是什么？" class="headerlink" title="ApplicationContext 通常的实现是什么？"></a>ApplicationContext 通常的实现是什么？</h1><ul><li>FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li>ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找bean 配置。</li><li>WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个WEB 应用的所有 bean。</li></ul><h1 id="一个-Spring-的应用看起来象什么？"><a href="#一个-Spring-的应用看起来象什么？" class="headerlink" title="一个 Spring 的应用看起来象什么？"></a>一个 Spring 的应用看起来象什么？</h1><ul><li>一个定义了一些功能的接口</li><li>这实现包括属性，它的 Setter ， getter 方法和函数等</li><li>Spring AOP</li><li>Spring 的 XML 配置文件</li><li>使用以上功能的客户端程序</li></ul><h1 id="哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？"><a href="#哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？" class="headerlink" title="哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？"></a>哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？</h1><ul><li>你两种依赖方式都可以使用，构造器注入和 Setter 方法注入</li><li>最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。</li></ul><h1 id="什么是-Spring-beans？"><a href="#什么是-Spring-beans？" class="headerlink" title="什么是 Spring beans？"></a>什么是 Spring beans？</h1><ul><li>Spring beans 是那些形成 Spring 应用的主干的 java 对象</li><li>它们被 Spring IOC 容器初始化，装配，和管理</li><li>这些 beans 通过容器中配置的元数据创建</li><li>比如，以 XML文件中<bean>的形式定义。</li><li>Spring 框架定义的 beans 都是单件 beans</li><li>在 bean tag 中有个属性”singleton”，如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean</li><li>默认是TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件</li></ul><h1 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h1><ul><li>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</li></ul><h1 id="如何给-Spring-容器提供配置元数据？"><a href="#如何给-Spring-容器提供配置元数据？" class="headerlink" title="如何给 Spring 容器提供配置元数据？"></a>如何给 Spring 容器提供配置元数据？</h1><ul><li>这里有三种重要的方法给 Spring 容器提供配置元数据。<ul><li>XML 配置文件。</li><li>基于注解的配置。</li><li>基于 java 的配置。</li></ul></li></ul><h1 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h1><ul><li>当定义一个<bean>在 Spring 里，我们还能给这个 bean 声明一个作用域</bean></li><li>它可以通过bean定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope属性必须设为singleton。</li></ul><h1 id="Spring-框架中的单例-bean-是线程安全的吗？"><a href="#Spring-框架中的单例-bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 bean 是线程安全的吗？"></a>Spring 框架中的单例 bean 是线程安全的吗？</h1><ul><li>不，Spring 框架中的单例 bean 不是线程安全的。</li></ul><h1 id="哪些是重要的-bean-生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的-bean-生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的 bean 生命周期方法？ 你能重载它们吗？"></a>哪些是重要的 bean 生命周期方法？ 你能重载它们吗？</h1><p>有- 两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时候被调用</p><ul><li>第二个方法是 teardown 它是在容器卸载类的时候被调用。</li><li>The bean 标签有两个重要的属性（init-method 和 destroy-method）</li><li>用它们你可 以 自 己 定 制 初 始 化 和 注 销 方 法</li><li>它 们 也 有 相 应 的 注 解 （ @PostConstruct 和@PreDestroy）。</li></ul><h1 id="在-Spring-中如何注入一个-java-集合？"><a href="#在-Spring-中如何注入一个-java-集合？" class="headerlink" title="在 Spring 中如何注入一个 java 集合？"></a>在 Spring 中如何注入一个 java 集合？</h1><ul><li>Spring 提供以下几种集合的配置元素：<ul><li><list>类型用于注入一列值，允许有相同的值。</list></li><li><set>类型用于注入一组值，不允许有相同的值。</set></li><li><map>类型用于注入一组键值对，键和值都可以为任意类型。</map></li><li><props>类型用于注入一组键值对，键和值都只能为 String 类型。</props></li></ul></li></ul><h1 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h1><ul><li>自动装配的局限性是：<ul><li>重写：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></li><li>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。</li><li>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li></ul></li></ul><h1 id="你可以在-Spring-中注入一个-null-和一个空字符串吗？"><a href="#你可以在-Spring-中注入一个-null-和一个空字符串吗？" class="headerlink" title="你可以在 Spring 中注入一个 null 和一个空字符串吗？"></a>你可以在 Spring 中注入一个 null 和一个空字符串吗？</h1><ul><li>可以。 Spring 注解</li></ul><h1 id="在-Spring-框架中如何更有效地使用-JDBC？"><a href="#在-Spring-框架中如何更有效地使用-JDBC？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC？"></a>在 Spring 框架中如何更有效地使用 JDBC？</h1><ul><li>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻</li><li>所以开发者只需写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</li><li>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li></ul><h1 id="Spring-对-DAO-的支持"><a href="#Spring-对-DAO-的支持" class="headerlink" title="Spring 对 DAO 的支持"></a>Spring 对 DAO 的支持</h1><ul><li>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，Hibernate or JDO 结合使用</li><li>这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</li></ul><h1 id="如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？"><a href="#如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？" class="headerlink" title="如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？"></a>如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</h1><ul><li>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul><li>配置 the Hibernate SessionFactory</li><li>继承 HibernateDaoSupport 实现一个 DAO</li><li>在 AOP 支持的事务中装配</li></ul></li></ul><h1 id="如何在spring的applicationContext-xml使用JNDI而不是DataSource"><a href="#如何在spring的applicationContext-xml使用JNDI而不是DataSource" class="headerlink" title="如何在spring的applicationContext.xml使用JNDI而不是DataSource"></a>如何在spring的applicationContext.xml使用JNDI而不是DataSource</h1><ul><li>可以使用”org.springframework.jndi.JndiObjectFactoryBean”来实现</li></ul><h1 id="在spring中是如何配置数据库驱动的"><a href="#在spring中是如何配置数据库驱动的" class="headerlink" title="在spring中是如何配置数据库驱动的"></a>在spring中是如何配置数据库驱动的</h1><ul><li>org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动</li></ul><h1 id="在web中如何配置spring"><a href="#在web中如何配置spring" class="headerlink" title="在web中如何配置spring"></a>在web中如何配置spring</h1><ul><li>在J2EE的web应用里面配置spring非常简单，最简单的只需要把spring得ContextLoaderListener添加到你的web.xml文件里面就可以了</li></ul><h1 id="在spring中如何定义hibernate-Mapping？"><a href="#在spring中如何定义hibernate-Mapping？" class="headerlink" title="在spring中如何定义hibernate Mapping？"></a>在spring中如何定义hibernate Mapping？</h1><ul><li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li></ul><h1 id="如何配置spring-struts？"><a href="#如何配置spring-struts？" class="headerlink" title="如何配置spring + struts？"></a>如何配置spring + struts？</h1><ul><li>在struts-config.xml加入一个插件，通过它加载applicationContext.xml</li><li>在struts-config.xml修改action-mapping标记，具体action交给了DelegateActionProxy</li><li>通过DelegateActionProxy进入一spring的环境。</li><li>在spring的applicationContext.xml加入<bean name="”/login”" class="”“" singleton="”false”/"></bean></li></ul><h1 id="如何在spring中实现国际化"><a href="#如何在spring中实现国际化" class="headerlink" title="如何在spring中实现国际化?"></a>如何在spring中实现国际化?</h1><ul><li>在applicationContext.xml加载一个bean org.springframework.context.support.ResourceBundleMessageSource</li><li>在src目录下建多个properties文件</li><li>对于非英文的要用native2ascii -encoding gb2312 源目转化文件相关内容</li><li>其命名格式是message_语言_国家。</li><li>页面中的中显示提示信息，键名取键值。</li><li>当给定国家，系统会自动加载对应的国家的properties信息。</li><li>通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。</li></ul><h1 id="在spring中如何实现事件处理"><a href="#在spring中如何实现事件处理" class="headerlink" title="在spring中如何实现事件处理"></a>在spring中如何实现事件处理</h1><ul><li>事件 Extends ApplicationEvent</li><li>监听器 Implements ApplicationListener</li><li>事件源 Implements ApplicationContextAware</li><li>在applicationContext.xml中配置事件源、监听器</li><li>先得到事件源，调用事件源的方法，通知监听器。</li></ul><h1 id="如何将spring加入web容器中"><a href="#如何将spring加入web容器中" class="headerlink" title="如何将spring加入web容器中"></a>如何将spring加入web容器中</h1><ul><li>在web.xml中加入如下同容,在启动web服务器时加载&#x2F;WEB-INF&#x2F;applicationContext.xml中的内容。</li></ul><h1 id="Spring如何实现资源管理"><a href="#Spring如何实现资源管理" class="headerlink" title="Spring如何实现资源管理?"></a>Spring如何实现资源管理?</h1><ul><li>使用<ul><li>applicationContext.getResource(“classpath:文件名”):在src根目录下，在类路径下</li><li>applicationContext.getResource(“classpath:&#x2F;chap01&#x2F;文件名”): 以src根目录下的基准往下走。</li><li>applicationContext.getResource(“file:c:&#x2F;a.properties”)：在系统文件目录下。</li></ul></li></ul><h1 id="Spring的ApplicationContext的作用"><a href="#Spring的ApplicationContext的作用" class="headerlink" title="Spring的ApplicationContext的作用?"></a>Spring的ApplicationContext的作用?</h1><ul><li>beanFactory</li><li>国际化(getMesage)</li><li>资源管理:可以直接读取一个文件的内容(getResource)</li><li>加入web框架中(加入一个servlet或监听器)</li><li>事件处理</li></ul><h1 id="Hibernate工作原理及为什么要用？"><a href="#Hibernate工作原理及为什么要用？" class="headerlink" title="Hibernate工作原理及为什么要用？"></a>Hibernate工作原理及为什么要用？</h1><ul><li>原理：<ul><li>读取并解析配置文件</li><li>读取并解析映射信息，创建SessionFactory</li><li>打开Sesssion</li><li>创建事务Transation</li><li>持久化操作</li><li>提交事务</li><li>关闭Session</li><li>关闭SesstionFactory</li></ul></li><li>为什么要用：<ul><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li></ul></li><li>Hibernate是如何延迟加载?<ul><li>Hibernate2延迟加载实现：a)实体对象  b)集合（Collection）</li><li>Hibernate3 提供了属性的延迟加载功能</li></ul></li><li>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</li><li>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)<ul><li>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</li></ul></li><li>说下Hibernate的缓存机制<ul><li>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</li><li>二级缓存：<ul><li>应用及缓存</li><li>分布式缓存<ul><li>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据</li></ul></li></ul></li><li>第三方缓存的实现</li></ul></li><li>Hibernate的查询方式<ul><li>Sql、Criteria,object comptosition</li><li>Hql：<ul><li>属性查询</li><li>参数查询、命名参数查询</li><li>关联查询</li><li>分页查询</li><li>统计函数</li></ul></li></ul></li><li>如何优化Hibernate？<ul><li>使用双向一对多关联，不使用单向一对多</li><li>灵活使用单向一对多关联</li><li>不用一对一，用多对一取代</li><li>配置对象缓存，不使用集合缓存</li><li>一对多集合使用Bag,多对多集合使用Set</li><li>继承类使用显式多态</li><li>表字段要少，表关联不要怕多，有二级缓存撑腰</li></ul></li></ul><h1 id="Spring中如何获取bean"><a href="#Spring中如何获取bean" class="headerlink" title="Spring中如何获取bean"></a>Spring中如何获取bean</h1><ul><li>通过xml配置文件</li><li>bean配置在xml里面，spring提供多种方式读取配置文件得到ApplicationContext.<ul><li>第一种方式：FileSystemXmlApplicationContext通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例:<ul><li>ApplicationContext ac &#x3D; new FileSystemXmlApplicationContext(”applicationContext.xml”)</li><li>ac.getBean(”beanName”);</li></ul></li><li>第二种方式：WebApplicationContextUtil在B&#x2F;S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext.例如：<ul><li>ApplicationContext ctx &#x3D; WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);</li><li>ApplicationContext ctx &#x3D;   WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</li><li>其中 servletContext sc 可以具体 换成 servlet.getServletContext()或者 this.getServletContext() 或者 request.getSession().getServletContext();</li><li>另外，由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象：</li><li>WebApplicationContext webApplicationContext &#x3D; (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</li></ul></li></ul></li></ul><h1 id="Spring框架中的单例Beans是线程安全的么？"><a href="#Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="Spring框架中的单例Beans是线程安全的么？"></a>Spring框架中的单例Beans是线程安全的么？</h1><ul><li>Spring框架并没有对单例bean进行任何多线程的封装处理</li><li>关于单例bean的线程安全和并发问题需要开发者自行去搞定</li><li>但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的</li><li>如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。</li><li>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</li></ul><h1 id="如何向Spring-Bean中注入一个Java-util-Properties？"><a href="#如何向Spring-Bean中注入一个Java-util-Properties？" class="headerlink" title="如何向Spring Bean中注入一个Java.util.Properties？"></a>如何向Spring Bean中注入一个Java.util.Properties？</h1><ul><li>第一种方法是使用如下面代码所示的<props> 标签</props></li><li>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。</li></ul><h1 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h1><ul><li>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</li><li>我们可以创建bean用来监听在ApplicationContext 中发布的事件</li><li>ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li><li>Spring 提供了以下5中标准的事件：<ul><li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li></ul></li><li>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。为了监听这个事件，还需要创建一个监听器，之后通过applicationContext接口的publishEvent()方法来发布自定义事件。</li></ul><h1 id="FileSystemResource和ClassPathResource有何区别？"><a href="#FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="FileSystemResource和ClassPathResource有何区别？"></a>FileSystemResource和ClassPathResource有何区别？</h1><ul><li>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径</li><li>在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。</li><li>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</li><li>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</li></ul><h1 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h1><ul><li>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：<ul><li>代理模式—在AOP和remoting中被用的比较多。</li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory &#x2F; ApplicationContext接口的核心理念。</li><li>工厂模式—BeanFactory用来创建对象的实例</li></ul></li></ul><p> </p><h1 id="开发中主要使用-Spring-的什么技术"><a href="#开发中主要使用-Spring-的什么技术" class="headerlink" title="开发中主要使用 Spring 的什么技术 ?"></a>开发中主要使用 Spring 的什么技术 ?</h1><ul><li>IOC 容器管理各层的组件</li><li>使用 AOP 配置声明式事务</li><li>整合其他框架</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/cc5f72fdfb9e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/cc5f72fdfb9e.html" class="post-title-link" itemprop="url">Tomcat</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:02:31" itemprop="dateCreated datePublished" datetime="2023-12-20T16:02:31+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 20:49:47" itemprop="dateModified" datetime="2023-12-24T20:49:47+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Tomcat的缺省端口是多少，怎么修改？"><a href="#Tomcat的缺省端口是多少，怎么修改？" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改？"></a>Tomcat的缺省端口是多少，怎么修改？</h1><ul><li>找到Tomcat目录下的conf文件夹</li><li>进入conf文件夹里面找到server.xml文件</li><li>打开server.xml文件</li><li>在server.xml文件里面找到下列信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li>port&#x3D;”8080”改成你想要的端口</li></ul><h1 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h1><h4 id="bio：传统的Java-I-O操作，同步且阻塞IO。"><a href="#bio：传统的Java-I-O操作，同步且阻塞IO。" class="headerlink" title="bio：传统的Java I&#x2F;O操作，同步且阻塞IO。"></a>bio：传统的Java I&#x2F;O操作，同步且阻塞IO。</h4><ul><li>maxThreads&#x3D;”150”&#x2F;&#x2F;Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值200。可以根据机器的时期性能和内存大小调整，一般可以在400-500。最大可以在800左右。</li><li>minSpareThreads&#x3D;”25”—Tomcat初始化时创建的线程数。默认值4。如果当前没有空闲线程，且没有超过maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。</li><li>maxSpareThreads&#x3D;”75”–一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值50。一旦创建的线程超过此数值，Tomcat会关闭不再需要的线程。线程数可以大致上用 “同时在线人数每秒用户操作次数系统平均操作时间” 来计算。</li><li>acceptCount&#x3D;”100”—-指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。如果当前可用线程数为0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。</li><li>connectionTimeout&#x3D;”20000” –网络连接超时，默认值20000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li></ul><h4 id="nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。"><a href="#nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。" class="headerlink" title="nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。"></a>nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。</h4><ul><li>指定使用NIO模型来接受HTTP请求</li><li>protocol&#x3D;”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol&#x3D;”HTTP&#x2F;1.1”</li><li>acceptorThreadCount&#x3D;”2” 使用NIO模型时接收线程的数目</li></ul><h4 id="aio-nio-2-：JDK7开始支持，异步非阻塞IO。"><a href="#aio-nio-2-：JDK7开始支持，异步非阻塞IO。" class="headerlink" title="aio(nio.2)：JDK7开始支持，异步非阻塞IO。"></a>aio(nio.2)：JDK7开始支持，异步非阻塞IO。</h4><ul><li><p>apr：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">      &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8000&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;</span><br><span class="line">    &lt;!-- minProcessors最小空闲连接线程数--&gt;</span><br><span class="line">    &lt;!-- maxProcessors最大连接线程数--&gt;</span><br><span class="line">    &lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;</span><br><span class="line">    &lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;</span><br><span class="line">    &lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; </span><br><span class="line">        connectionTimeout=&quot;20000&quot;</span><br><span class="line">        redirectPort=&quot;8443</span><br><span class="line">        maxThreads=“500” </span><br><span class="line">        minSpareThreads=“100” </span><br><span class="line">        maxSpareThreads=“200”</span><br><span class="line">        acceptCount=&quot;200&quot;</span><br><span class="line">        enableLookups=&quot;false&quot;       </span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></li><li><p>其他配置</p><ul><li>maxHttpHeaderSize&#x3D;”8192” http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。</li><li>URIEncoding&#x3D;”UTF-8” 指定Tomcat容器的URL编码格式。</li><li>disableUploadTimeout&#x3D;”true” 上传时是否使用超时机制</li><li>enableLookups&#x3D;”false”–是否反查域名，默认值为true。为了提高处理能力，应设置为false</li><li>compression&#x3D;”on” 打开压缩功能</li><li>compressionMinSize&#x3D;”10240” 启用压缩的输出内容大小，默认为2KB</li><li>noCompressionUserAgents&#x3D;”gozilla, traviata” 对于以下的浏览器，不启用压缩</li><li>compressableMimeType&#x3D;”text&#x2F;html,text&#x2F;xml,text&#x2F;javascript,text&#x2F;css,text&#x2F;plain” 哪些资源类型需要压缩</li></ul></li></ul><h1 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h1><ul><li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li><li>在server.xml文件上配置<context>节点，设置相关的属性即可</context></li><li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li></ul><h1 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h1><ul><li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析， 并读取servlet注册信息</li><li>然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。（有时候也是在第一次请求时实例化）在servlet注册时加上如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li></ul><h1 id="tomcat-如何优化？"><a href="#tomcat-如何优化？" class="headerlink" title="tomcat 如何优化？"></a>tomcat 如何优化？</h1><ul><li><p>优化连接配置.这里以tomcat7的参数配置为例，需要修改conf&#x2F;server.xml文件，修改连接数，关闭客户端dns查询。</p></li><li><p>参数解释：</p><ul><li>URIEncoding&#x3D;”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</li><li>maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</li><li>minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</li><li>enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</li><li>connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</li><li>maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</li><li>acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</li><li>maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。通常Windows是1000个左右，Linux是2000个左右。</li><li>useURIValidationHack:把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</li><li>enableLookups&#x3D;”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</li><li>disableUploadTimeout ：类似于Apache中的keeyalive一样</li></ul></li><li><p>给Tomcat配置gzip压缩(HTTP压缩)功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compression=”on” compressionMinSize=”2048″</span><br><span class="line">compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</span><br></pre></td></tr></table></figure></li><li><p>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。</p></li><li><p>相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compression=”on” 打开压缩功能</span><br><span class="line">compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB</span><br><span class="line">noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</span><br><span class="line">compressableMimeType=”text/html,text/xml”　压缩类型</span><br></pre></td></tr></table></figure></li><li><p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置</p></li></ul><h1 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h1><ul><li>内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。</li><li>具体设置如下： JAVA_OPTS&#x3D;”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio&#x3D;4 -XX:SurvivorRatio&#x3D;4”</li><li>其各项参数如下：<ul><li>-Xmx3550m：设置JVM最大可用内存为3550M。</li><li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xmn2g：设置年轻代大小为2G。整个堆大小&#x3D;年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</li><li>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li><li>-XX:NewRatio&#x3D;4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5</li><li>-XX:SurvivorRatio&#x3D;4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1&#x2F;6</li><li>-XX:MaxPermSize&#x3D;16m:设置持久代大小为16m。</li><li>-XX:MaxTenuringThreshold&#x3D;0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li></ul></li></ul><h1 id="垃圾回收策略调优"><a href="#垃圾回收策略调优" class="headerlink" title="垃圾回收策略调优"></a>垃圾回收策略调优</h1><ul><li>垃圾回收的设置也是在catalina.sh中，调整JAVA_OPTS变量。</li><li>具体设置如下： JAVA_OPTS&#x3D;”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis&#x3D;100”</li><li>具体的垃圾回收策略及相应策略的各项参数如下：<ul><li>串行收集器（JDK1.5以前主要的回收方式） ：-XX:+UseSerialGC:设置串行收集器</li><li>并行收集器（吞吐量优先）<ul><li>示例： java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis&#x3D;100</li><li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</li><li>-XX:ParallelGCThreads&#x3D;20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集</li><li>-XX:MaxGCPauseMillis&#x3D;100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li></ul></li><li>并发收集器（响应时间优先）<ul><li>示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC</li><li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio&#x3D;4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</li><li>-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li><li>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</li><li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li></ul></li></ul></li></ul><h1 id="共享session处理"><a href="#共享session处理" class="headerlink" title="共享session处理"></a>共享session处理</h1><h4 id="使用Tomcat本身的Session复制功能"><a href="#使用Tomcat本身的Session复制功能" class="headerlink" title="使用Tomcat本身的Session复制功能"></a>使用Tomcat本身的Session复制功能</h4><ul><li>方案的有点是配置简单，缺点是当集群数量较多时，Session复制的时间会比较长，影响响应的效率</li></ul><h4 id="使用第三方来存放共享Session"><a href="#使用第三方来存放共享Session" class="headerlink" title="使用第三方来存放共享Session"></a>使用第三方来存放共享Session</h4><ul><li>目前用的较多的是使用memcached来管理共享Session，借助于memcached-sesson-manager来进行Tomcat的Session管理</li></ul><h4 id="使用黏性session的策略"><a href="#使用黏性session的策略" class="headerlink" title="使用黏性session的策略"></a>使用黏性session的策略</h4><ul><li>对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同一个用户的session可以由nginx或者apache交给同一个Tomcat来处理，这就是所谓的session sticky策略，目前应用也比较多</li><li>nginx默认不包含session sticky模块，需要重新编译才行（windows下我也不知道怎么重新编译）</li><li>优点是处理效率高多了，缺点是强会话要求的场合不合适</li></ul><h1 id="添加JMS远程监控"><a href="#添加JMS远程监控" class="headerlink" title="添加JMS远程监控"></a>添加JMS远程监控</h1><ul><li>对于部署在局域网内其它机器上的Tomcat，可以打开JMX监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在JVM启动参数中配置即可，配置如下：<ul><li>-Dcom.sun.management.jmxremote.ssl&#x3D;false -Dcom.sun.management.jmxremote.authenticate&#x3D;false</li><li>-Djava.rmi.server.hostname&#x3D;192.168.71.38 设置JVM的JMS监控监听的IP地址，主要是为了防止错误的监听成127.0.0.1这个内网地址</li><li>-Dcom.sun.management.jmxremote.port&#x3D;1090 设置JVM的JMS监控的端口</li><li>-Dcom.sun.management.jmxremote.ssl&#x3D;false 设置JVM的JMS监控不实用SSL</li><li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false 设置JVM的JMS监控不需要认证</li></ul></li></ul><h1 id="专业点的分析工具有"><a href="#专业点的分析工具有" class="headerlink" title="专业点的分析工具有"></a>专业点的分析工具有</h1><ul><li>IBM ISA，JProfiler、probe 等，具体监控及分析方式去网上搜索即可</li></ul><h1 id="关于Tomcat的session数目"><a href="#关于Tomcat的session数目" class="headerlink" title="关于Tomcat的session数目"></a>关于Tomcat的session数目</h1><ul><li>这个可以直接从Tomcat的web管理界面去查看即可；</li><li>或者借助于第三方工具Lambda Probe来查看，它相对于Tomcat自带的管理稍微多了点功能，但也不多 ；</li></ul><h1 id="监视Tomcat的内存使用情况"><a href="#监视Tomcat的内存使用情况" class="headerlink" title="监视Tomcat的内存使用情况"></a>监视Tomcat的内存使用情况</h1><ul><li>使用JDK自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等；</li><li>JDK自带的jvisualvm可以下载插件（如GC等），可以查看更丰富的信息。如果是分析本地的Tomcat的话，还可以进行内存抽样等，检查每个类的使用情况</li></ul><h1 id="打印类的加载情况及对象的回收情况"><a href="#打印类的加载情况及对象的回收情况" class="headerlink" title="打印类的加载情况及对象的回收情况"></a>打印类的加载情况及对象的回收情况</h1><ul><li>这个可以通过配置JVM的启动参数，打印这些信息（到屏幕（默认也会到catalina.log中）或者文件），具体参数如下：<ul><li>-XX:+PrintGC：输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</li><li>-XX:+PrintGCDetails：输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</li><li>-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用，输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</li><li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds</li><li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds</li><li>-XX:PrintHeapAtGC: 打印GC前后的详细堆栈信息</li><li>-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析</li><li>-verbose:class 监视加载的类的情况</li><li>-verbose:gc 在虚拟机发生内存回收时在输出设备显示信息</li><li>-verbose:jni 输出native方法调用的相关情况，一般用于诊断jni调用错误信息</li></ul></li></ul><h1 id="Tomcat一个请求的完整过程"><a href="#Tomcat一个请求的完整过程" class="headerlink" title="Tomcat一个请求的完整过程"></a>Tomcat一个请求的完整过程</h1><ul><li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP&#x2F;1.1 Connector获得</li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应</li><li>Engine获得请求localhost&#x2F;yy&#x2F;index.jsp，匹配它所拥有的所有虚拟主机Host</li><li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）</li><li>localhost Host获得请求&#x2F;yy&#x2F;index.jsp，匹配它所拥有的所有Context</li><li>Host匹配到路径为&#x2F;yy的Context（如果匹配不到就把该请求交给路径名为”“的Context去处理）</li><li>path&#x3D;”&#x2F;yy”的Context获得请求&#x2F;index.jsp，在它的mapping table中寻找对应的servlet</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类</li><li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host</li><li>Host把HttpServletResponse对象返回给Engine</li><li>Engine把HttpServletResponse对象返回给Connector</li><li>Connector把HttpServletResponse对象返回给客户browser</li></ul><h1 id="Tomcat工作模式？"><a href="#Tomcat工作模式？" class="headerlink" title="Tomcat工作模式？"></a>Tomcat工作模式？</h1><ul><li>Tomcat是一个JSP&#x2F;Servlet容器</li><li>其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</li><li>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：<ul><li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li><li>Tomcat作为独立服务器：请求来自于web浏览器；</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/aa3500b67dae.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/aa3500b67dae.html" class="post-title-link" itemprop="url">版本管理工具</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:00:42" itemprop="dateCreated datePublished" datetime="2023-12-20T16:00:42+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 11:52:57" itemprop="dateModified" datetime="2023-12-24T11:52:57+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">版本管理工具</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="svn和git的区别及适用场景"><a href="#svn和git的区别及适用场景" class="headerlink" title="svn和git的区别及适用场景"></a>svn和git的区别及适用场景</h1><h4 id="svn的优势"><a href="#svn的优势" class="headerlink" title="svn的优势"></a>svn的优势</h4><ul><li>优异的跨平台支持，对windows平台支持非常友好。</li><li>简单易用，安装后稍微培训下就知道怎么操作。</li><li>代码，需求，文档，涉及稿都可以用svn进行管理，适合不同部门的技术非技术的同事协作。</li></ul><h4 id="git的优势"><a href="#git的优势" class="headerlink" title="git的优势"></a>git的优势</h4><ul><li>去中心化：Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容是完全一样的（格式有点不同，是bare的）。虽然平时大家都是将代码提交到中央服务器上再统一pull别人的代码，但实际情况你可以总是pull张三的库，然后push给李四等等操作。</li><li>本地提交：本地提交好处主要有3点：<ul><li>一， 断网提交</li><li>二， 小步提交。可以对自己的阶段成果有跟踪，并且提高每次变更的安全性</li><li>三，本地库。这个和断网提交是同一个实现，但从需求角度出发则略有不同，主要是说即使只有自己一个人开发项目，也可以轻易的让自己的代码有版本跟踪，而不需要去费力建个什么svn server。</li><li>四，本地回滚。这个其实是由于本地库的存在而产生的，但可以减少中央库上的冗余版本</li></ul></li><li>分支策略：在Git实际开发中分支的分离和merge是属于日常操作，开启和合并分支成本相比SVN要小得多：SVN是复制一份代码到分支目录，Git则是在分支点做一下标记。随便一次冲突就会自动产生分支，所以大家每天都在与分支打交道。这便是弱化了分支的概念，由于分支成本很小，因此使得按功能分支的开发模式（每个分支一个功能，开发完了再merge到主干）变得非常简单，大家可以完全不需要再因为担心SCM成本太高而选用主干开发模式（所有功能都在主干上开发，到了发版本前再分离出分支）。</li></ul><h4 id="两者的工作流对比"><a href="#两者的工作流对比" class="headerlink" title="两者的工作流对比"></a>两者的工作流对比</h4><h5 id="svn模式"><a href="#svn模式" class="headerlink" title="svn模式"></a>svn模式</h5><ul><li>写代码。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将本地代码提交到服务器。</li></ul><h5 id="git模式"><a href="#git模式" class="headerlink" title="git模式"></a>git模式</h5><ul><li>写代码。</li><li>提交到本地版本库。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将远程库与本地代码合并结果提交到本地版本库。</li><li>将本地版本库推到服务器。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>对比可以看出：分布式版本管理仅仅是增加了本地库这个概念，其余的概念与集中管理并无区别。——但是 svn 在与服务器同步之前无法提交代码，因而本地修改更容易出问题。</li><li>当研发成本比较低，协作开发人数不多，开发人员对于版本管理的水平参差不齐的时候，或者对于代码的安全性要求更高一点的时候，适合用svn。</li><li>而对于很多人参与开发，代码量比较大，或者高频次协作，跨公司，跨地域合作的情况下，更适合用git。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span><a class="page-number" href="/default-index/page/3/">3</a><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/3/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">2.6m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">39:05</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>