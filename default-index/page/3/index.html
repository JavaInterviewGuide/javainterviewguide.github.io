<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/3/index.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/3/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">28</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">48</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/aa3500b67dae.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/aa3500b67dae.html" class="post-title-link" itemprop="url">版本管理工具</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:00:42" itemprop="dateCreated datePublished" datetime="2023-12-20T16:00:42+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 11:52:57" itemprop="dateModified" datetime="2023-12-24T11:52:57+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">版本管理工具</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="svn和git的区别及适用场景"><a href="#svn和git的区别及适用场景" class="headerlink" title="svn和git的区别及适用场景"></a>svn和git的区别及适用场景</h1><h4 id="svn的优势"><a href="#svn的优势" class="headerlink" title="svn的优势"></a>svn的优势</h4><ul><li>优异的跨平台支持，对windows平台支持非常友好。</li><li>简单易用，安装后稍微培训下就知道怎么操作。</li><li>代码，需求，文档，涉及稿都可以用svn进行管理，适合不同部门的技术非技术的同事协作。</li></ul><h4 id="git的优势"><a href="#git的优势" class="headerlink" title="git的优势"></a>git的优势</h4><ul><li>去中心化：Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容是完全一样的（格式有点不同，是bare的）。虽然平时大家都是将代码提交到中央服务器上再统一pull别人的代码，但实际情况你可以总是pull张三的库，然后push给李四等等操作。</li><li>本地提交：本地提交好处主要有3点：<ul><li>一， 断网提交</li><li>二， 小步提交。可以对自己的阶段成果有跟踪，并且提高每次变更的安全性</li><li>三，本地库。这个和断网提交是同一个实现，但从需求角度出发则略有不同，主要是说即使只有自己一个人开发项目，也可以轻易的让自己的代码有版本跟踪，而不需要去费力建个什么svn server。</li><li>四，本地回滚。这个其实是由于本地库的存在而产生的，但可以减少中央库上的冗余版本</li></ul></li><li>分支策略：在Git实际开发中分支的分离和merge是属于日常操作，开启和合并分支成本相比SVN要小得多：SVN是复制一份代码到分支目录，Git则是在分支点做一下标记。随便一次冲突就会自动产生分支，所以大家每天都在与分支打交道。这便是弱化了分支的概念，由于分支成本很小，因此使得按功能分支的开发模式（每个分支一个功能，开发完了再merge到主干）变得非常简单，大家可以完全不需要再因为担心SCM成本太高而选用主干开发模式（所有功能都在主干上开发，到了发版本前再分离出分支）。</li></ul><h4 id="两者的工作流对比"><a href="#两者的工作流对比" class="headerlink" title="两者的工作流对比"></a>两者的工作流对比</h4><h5 id="svn模式"><a href="#svn模式" class="headerlink" title="svn模式"></a>svn模式</h5><ul><li>写代码。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将本地代码提交到服务器。</li></ul><h5 id="git模式"><a href="#git模式" class="headerlink" title="git模式"></a>git模式</h5><ul><li>写代码。</li><li>提交到本地版本库。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将远程库与本地代码合并结果提交到本地版本库。</li><li>将本地版本库推到服务器。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>对比可以看出：分布式版本管理仅仅是增加了本地库这个概念，其余的概念与集中管理并无区别。——但是 svn 在与服务器同步之前无法提交代码，因而本地修改更容易出问题。</li><li>当研发成本比较低，协作开发人数不多，开发人员对于版本管理的水平参差不齐的时候，或者对于代码的安全性要求更高一点的时候，适合用svn。</li><li>而对于很多人参与开发，代码量比较大，或者高频次协作，跨公司，跨地域合作的情况下，更适合用git。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/726ed62e2d44.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/726ed62e2d44.html" class="post-title-link" itemprop="url">Nginx</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:59:00" itemprop="dateCreated datePublished" datetime="2023-12-20T15:59:00+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 16:21:48" itemprop="dateModified" datetime="2023-12-24T16:21:48+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nginx/" itemprop="url" rel="index"><span itemprop="name">nginx</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><ul><li>Nginx应该是现在最火的web和反向代理服务器，没有之一</li><li>它是一款诞生于俄罗斯的高性能web服务器，尤其在高并发情况下，相较Apache，有优异的表现。</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><ul><li>Nginx擅长处理静态文件，是非常好的图片、文件服务器</li><li>把所有的静态资源的放到nginx上，可以使应用动静分离，性能更好</li></ul><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><ul><li>Nginx通过反向代理可以实现服务的负载均衡，避免了服务器单节点故障，把请求按照一定的策略转发到不同的服务器上，达到负载的效果。</li></ul><h6 id="常用的负载均衡策略有"><a href="#常用的负载均衡策略有" class="headerlink" title="常用的负载均衡策略有"></a>常用的负载均衡策略有</h6><ul><li>轮询<ul><li>将请求按顺序轮流地分配到后端服务器上</li><li>它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li></ul></li><li>加权轮询<ul><li>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同</li><li>给配置高、负载低的机器配置更高的权重，让其处理更多的请；</li><li>而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li></ul></li><li>ip_hash（源地址哈希法）<ul><li>根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问服务器的序号。</li><li>采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li></ul></li><li>随机<ul><li>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。</li></ul></li><li>least_conn（最小连接数法）<ul><li>由于后端服务器的配置不尽相同，对于请求的处理有快有慢</li><li>最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li></ul></li></ul><h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><ul><li>Nginx的限流模块，是基于漏桶算法实现的，在高并发的场景下非常实用，如下图：</li></ul><h6 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h6><ul><li>limit_req_zone定义在http块中，$binary_remote_addr 表示保存客户端IP地址的二进制形式。</li><li>Zone定义IP状态及URL访问频率的共享内存区域。<br>-zone&#x3D;keyword标识区域的名字，以及冒号后面跟区域大小。16000个IP地址的状态信息约1MB，所以示例中区域可以存储160000个IP地址。</li><li>Rate定义最大请求速率。示例中速率不能超过每秒100个请求。</li></ul><h6 id="设置限流"><a href="#设置限流" class="headerlink" title="设置限流"></a>设置限流</h6><ul><li>burst排队大小，nodelay不限制单个请求间的时间。</li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul><li>浏览器缓存，静态资源缓存用expire。</li><li>代理层缓存</li></ul><h5 id="黑白名单"><a href="#黑白名单" class="headerlink" title="黑白名单"></a>黑白名单</h5><ul><li>不限流白名单</li><li>黑名单</li></ul><h1 id="Nginx性能调优："><a href="#Nginx性能调优：" class="headerlink" title="Nginx性能调优："></a>Nginx性能调优：</h1><ul><li>增加同时打开⽂件数open files数量；</li><li>处理⼤量静态⽂件的磁盘I&#x2F;O时(此时worker进程是单线程的)，增加CPU核⼼数Worker Processes数量，提⾼计算能⼒；</li><li>如果⽹站流量很⾼，则可以提升worker进程连接数Worker Connections(默认1024)；</li><li>控制keep alive在10s-20s之间，减少连接的时间开销；</li><li>合理设置open file cache时间提⾼处理效率；</li><li>提⾼⽹路带宽；</li><li>开启压缩传输数据gzip，设置压缩级别gzip_comp_level为1-2，再⾼效果不明显并且浪费CPU了；</li><li>扩展机器数量。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/64b56da2b088.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/64b56da2b088.html" class="post-title-link" itemprop="url">面试技巧</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:57:12" itemprop="dateCreated datePublished" datetime="2023-12-20T15:57:12+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 13:27:06" itemprop="dateModified" datetime="2023-12-24T13:27:06+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">面试技巧</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="IT从业人员面试技巧"><a href="#IT从业人员面试技巧" class="headerlink" title="IT从业人员面试技巧"></a>IT从业人员面试技巧</h1><ul><li>一般来说，面试你的人都不是一个很好对付的人。别看他彬彬有礼，看上去笑眯眯的，很和气的样子。但没准儿一肚子坏水。有些人待人特别客气，说话还稍稍有点结巴的，更容易让人上当。所以，牢记一点，面试的时候保持高度警觉，对方不经意问出来的问题，很可能是他最想知道的。举例来说，我每次面试的时候，最喜欢说的话就是：哦，我不是HR的，你别拘束，咱们就当是聊天……</li><li>负责面试的人，一般有两种，一种是专门的人力资源部门。我不懂这一块，略过不谈。另外一种就是我这样的，负责某个部门的苦力头。一般来说，公司中层的苦力头，他的脑子里面都有一个模式，他的码头上需要一个什么样的人，他或她必须具备哪些技能。但这些考察都是次要的，他首先要搞清楚一点，那就是对方的人品!!!换句话说，能力是一个方面，但人品是门槛!!!如果他判定你人品有问题，那剩下的问题就没必要了。这里面就有很多陷阱，比如，你怎么评价前一家公司。你要是大说特说那公司怎么不好，我肯定要琢磨了，你昨天背叛少林，那今天会不会背叛武当?最好把离职原因淡淡一说，不要指责谁。我找工作的时候，一般都老实说，我自己能力不行，被公司淘汰了。其实大家肚子都揣着明白，不就是为了找个钱多点的地儿嘛。我经常问的一个陷阱问题就是：谈谈你的父母。其实这个问题一方面是考察对方的家庭教育，另外一方面是看看面试者怎么评价父母。这里面有个通常的逻辑，爹妈把他养这么大，说到自己的父母毫无感恩，感激之情，这种人招进来肯定不能成为合格的苦力。</li><li>总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li></ul><h4 id="面试到结束的时候，都会问到薪金标准。"><a href="#面试到结束的时候，都会问到薪金标准。" class="headerlink" title="面试到结束的时候，都会问到薪金标准。"></a>面试到结束的时候，都会问到薪金标准。</h4><ul><li>我不知道别的公司怎么操作的。我呆过的公司，都是定编定岗的，换句话说，招聘的时候，这个岗位的薪水是早就确定了。也就是说，对方问到薪金的时候，他已经在脑子里面很清楚公司的标准!!!一般说来，这个问题的目的是为了确定，他如果觉得你是个合适的苦力，那么，现在的薪金，你是不是会过来干活。问到薪金的时候，最好的回答是不回答，留到下一次面试再谈。或者可以反问，公司对于这个岗位定的薪金标准是多少。</li><li>一般来说，苦力头不会管你薪金多少的。好的苦力，苦力头甚至会为你向老板争取。</li><li>能够混到苦力头的位置上，面试你的人至少具有一定的能力，以及足够的胸怀。他在意的是能不能招到合适的人干活，薪金的问题不是问题。但过高的薪金，会把你抹掉。比如这个岗位，公司定的薪水是三千，你一张嘴，四千，那完了。对于应聘者，其实是很不公平的，你能做的就是接受这个标准或是不接受。如果是刚刚走出校门，月薪三千我想足够生活了。所以，如果对方的薪金标准，你要么不回答，要么就说三千，别要的太高。</li></ul><h4 id="一般面试都是在一个独立的私密空间进行。"><a href="#一般面试都是在一个独立的私密空间进行。" class="headerlink" title="一般面试都是在一个独立的私密空间进行。"></a>一般面试都是在一个独立的私密空间进行。</h4><ul><li>这里简单说说一些基本的礼貌。</li><li>进门要敲门，敲门是最基本的一点。</li><li>第二点，落座，别进去一屁股就坐上去了。最好等对方先坐下。当然，一般面试的人都很客气，招呼：坐，坐。</li><li>有时候进去之后，面试的人已经坐好了，那就别管了，坐在他的对面或他指定的位置就行。我这人比较心理阴暗，一般都是背对亮光坐。</li><li>当你结束时，至少客气招呼一声：谢谢您抽出时间面试我。</li><li>如果离开座位，顺手把椅子推好，这也是一个容易疏忽的地方。</li><li>有些公司的前台小姑娘，是你去面试的时候最先面对的，那么临走的时候客气打声招呼。</li><li>我有个习惯，面试的时候带着名片，如果我觉得很合适，会把名片给对方，这样他便于有问题的话联络我。但是，亲爱的朋友，你去面试的时候，如果对方面前放着名片夹子，千万不要傻了吧叽的要名片。</li><li>面试结束的第二天，如果你有面试你的苦力头电话，那就发个短信，内容可以客套一下，就说感谢你昨天面试我之类的话，然后祝福一下，比如今天好心情，工作顺利等等。千万不要问对方结果。你的目的就是提醒他，显示你的存在就行了。</li><li>你等待的地方，可能是公司的公共区域，而面试的地方可能是会议室，或者像我这样的人，喜欢在自己的办公室谈。那么切忌，不要走在前面，也不要走路中间，走在边上就行，把中间的位置留给你未来的领导走。进门之前主动为对方开门，这种拍马屁的小花招可以多来一点。</li><li>面试的时候身体正直，自然一点就行。一般来说，不要用摩丝喷的脑袋跟刺猬一样。女孩子也不要用过于浓密的香水。这是谈事情，不是相亲。</li><li>谈话的过程中，不要抢话，语速也不要太快。我教大家一个小诀窍，我一般和人谈事情，一开始故意显得有点结巴。人说话结巴，会让人感觉对方很诚恳。但就开头一两句结巴就行，别一直结巴。</li><li>有些人面试的时候介绍自己会滔滔不绝，说话特快。其实这里面有个信息传递的问题，跟别人谈事情，语速太快，往往容易说错。对方接受起来也有问题。中等语速就可以了。</li><li>很多男士比较大大咧咧，往那儿一坐，二郎腿就搭上了。要是碰上我这样大大咧咧的，可能无所谓，要是碰到心理阴暗的，就会有负面影响。另外，很多人一紧张就爱抖腿，这样也不礼貌。面试其实就是一个自我介绍，不是演说，不要声音特大吐沫横飞的，平时说话的声音就行。</li><li>面试你的要是个女的那就算了，要是个男的，不用管自己的性别，大大方方招呼一声，你好，手伸过去，和他握个手。其实从握手就能看到一个人的个性，一般来说，握手短促有力，可能是我这样比较外向的性格。握的软绵绵的，对方可能比较内向。</li><li>不要紧张，表现得自然些，要有礼貌，别忘记和主考人招呼，说句”早晨好”。</li><li>举止要大方，不可闪缩，要保持自信。待主考人邀请你才可礼貌地坐下，不要太随便或左顾右盼;切忌装出懒洋洋和满不在乎的样子。</li><li>微笑可以减轻你内心的不安，更可以令面试的气氛变得融洽愉快。</li><li>让主考人知道你珍惜这次面试的机会。当主考人说话时，要眼望对方，并留心倾听。</li><li>让主考人先打开话匣子。答问题要直接了当，无须太繁复，也不要单说”是”或”不是”;否则，主考人会觉得你欠缺诚意。深入的谈话内容有助主考人对你作出确切的评估。</li><li>假如不太明白主考人的问题，应该礼貌地请他重复。不懂得回答的问题，不妨坦白承认。含糊其辞或乱吹牛会导至面试的失败。</li><li>不要打断主考人的说话，被要求就相同的问题重复作答也不能表示不耐烦，更切忌与主考人争辩。</li><li>主考人可能问你一些与面试或者申请的职位完全无关的问题，例如时人时事;目的在进一步了解你的思想及见识。</li><li>紧记在适当时机带出自已的优点和特长。但切勿显得过份自信或浮夸。</li><li>不要急着提出薪酬问题，最好让主考人先提出。</li><li>准备一些与该机构和申请的工作有关的问题在面试结束之前提出。这样能表现伙的积极，亦可给主考人留下良好印象。</li><li>最后，问清楚多久才知道面试结果。不要忘记向主考人道谢及说声”再见”才离去。</li></ul><h1 id="面试一家公司之前需要做的准备"><a href="#面试一家公司之前需要做的准备" class="headerlink" title="面试一家公司之前需要做的准备"></a>面试一家公司之前需要做的准备</h1><h4 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h4><ul><li>了解应聘公司；</li><li>了解应聘岗位</li><li>查该公司的资料，知道该公司是做什么的，发展情况，招聘的岗位的要求等</li><li>公司地点在哪里，交通是否方便，需提前多久出发；</li><li>公司类型如何？我应该如何着装？去咨询公司逃不掉正装，而去互联网公司这么穿，人家或许以为你是房产中介；</li><li>公司业务如何？上市了吗？财报如何？主要产品有哪些？</li><li>公司在中国有多少分支机构？最近有什么新动向？</li><li>公司所在行业有何新动向？发展趋势如何？</li><li>公司的竞争对手有哪些？公司在行业内排名如何？</li></ul><h4 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h4><ul><li>重温一下简历内容，确保每段经历都能用简短的语言复述；</li><li>带过的团队，做过的项目，组织过的活动，以STAR的形式准备好；</li><li>每一段经历，都应该准备实例和数据证明，会给面试官留下深刻印象；</li><li>准备几个感兴趣的问题，面试中如果没有获得解答，在电话通知环节，我们必须开口问，有诸多信息要确认：<ul><li>面试时间／地点</li><li>公司名称／岗位名称</li><li>联系人信息（一旦迟到，得提前打电话道歉）</li><li>面试官是谁（HR还是直线经理，或者都一次性面试掉）</li><li>需要准备什么材料（一般逃不掉学历证明，身份证复印件等资料）</li><li>针对面试岗位，需要额外准备什么材料（如：做设计，是不是要带设计稿？）</li></ul></li></ul><h1 id="人事面试技巧总结"><a href="#人事面试技巧总结" class="headerlink" title="人事面试技巧总结"></a>人事面试技巧总结</h1><ul><li>一定不要将公司的工作当作负担，一定要做好并且学到东西，这才是你下一次跳槽能够展示的东西，所以在公司工作，你拿着工资，而不只是在为公司打工，而是为自己的未来进行修炼，一定要有这方面的意识。总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li><li>人事这关也很重要，特别是工资方面，还有团队，工作方面？(重要)</li><li>对公司的主营业务要表现足够的兴趣，关系公司的发展？</li><li>3面就该和你谈谈钱的事情，你们的重点就是在于薪资，福利和以后的发展，这个时候就是公司对你展示他的潜力了，也是希望能留住你（招人也不容易），那么你对你自己的定位，和你的期望薪资就可以大胆的说出来， 不要因为不好意思而错过你要价的机会，因为一般进入公司后你想涨薪资就比较复杂了，而且这只是你的期望 ，面试官会对你提出他们会给你的工资， 也就是一个讨价还价的过程，总之在这个环节，你可以大胆提出你的期望薪资与发展方向（不要太离谱哈，当然你要作死我也不拦着你），和你的面试官慢慢讨论</li><li>试用期：在这个环节就是心态上注意，技术上展示你的能力，处事上和谐相处，重中之重是在于融入团队，你个人的力量是完不成整个项目的</li><li>对新公司的了解，公司发展情况，业务方向，特长等，如果在企业文化上也有优势，可以多夸下公司的的企业文化</li><li>期望的薪资，最好是了解了工作内容、加班情况、福利情况再谈待遇。最好先了解行情以免太高或太低。不要说太死了，看到对方表情不对就改口说可以商量，或者试探性的问一下对方能否接受，不行就说自己要高工资的原因并说明其实自己更看重发展机会，工资再少点也可以。不要轻易说自己能接受的最低工资，很可能他就给你这个最低的。如果对方能接受你的要求但是觉得有点偏高时，要说明自己凭什么可以拿这么高，并说明自己的优势对岗位的重要性。</li><li>要问公司的问题<ul><li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等。</li><li>所在部门的规模、发展计划，个人的成长机会。</li><li>自己的工作内容及可能的发展机会等。</li><li>向人事提问时最好不要一开始就谈工资，还有不要问太多可能留下不好印象的问题。问最基本的可能影响你去留的问题，其他问题可以进了再问，言多必失</li><li>面试前根据招聘信息的岗位要求多做相应准备</li></ul></li></ul><h4 id="你为什么来北京（城市）发展？"><a href="#你为什么来北京（城市）发展？" class="headerlink" title="你为什么来北京（城市）发展？"></a>你为什么来北京（城市）发展？</h4><ul><li>提出这个问题不要认为胡乱回答就行了，面试官是想看你什么原因，是否稳定。不会有哪家公司找一个很不稳定的人的。回答尽量夸城市，想在这里发展云云</li></ul><h4 id="你离职原因？"><a href="#你离职原因？" class="headerlink" title="你离职原因？"></a>你离职原因？</h4><ul><li>说到这个问题很多人都很头大，换工作的人清楚这个问题基本是必问的一个问题</li><li>这个问题很难回答，为什么呢？因为你如果说是公司的问题，这不好那不好，那么就很危险了，因为面试官会想，以后你从我们公司走出去是不是也这么说我们公司。说因为自己的原因呢，如果没好的理由，面试官也会想如果你来公司因为这些理由离开我公司呢，给人很不稳定的感觉</li><li>一般我会回答公司倒闭或者公司被收购、实习到期或者你本身确实有不得已的理由，比如公司发展和自己的发展不符合，等等，不要直接说公司或者自己的某些原因。除非没有好理由</li></ul><h4 id="为什么来我们公司？我们公司你了解多少？"><a href="#为什么来我们公司？我们公司你了解多少？" class="headerlink" title="为什么来我们公司？我们公司你了解多少？"></a>为什么来我们公司？我们公司你了解多少？</h4><ul><li>问这个就考察你的提前准备的资料了，既然这家公司通知你面试了，你肯定要去查相关资料，不需要详细的，但是你肯定要公司做什么的要知道</li><li>这个要考察自己巴拉巴拉的能力了，比如我觉得公司发展跟我想做的蛮符合的，我想珍惜这个机会…与公司同步发展云云</li></ul><h4 id="你认为你的优点和缺点有哪些？"><a href="#你认为你的优点和缺点有哪些？" class="headerlink" title="你认为你的优点和缺点有哪些？"></a>你认为你的优点和缺点有哪些？</h4><ul><li>不要认为这个问题很简单，吹吹牛就可以了。</li><li>首先你要清楚的知道，你的优点基本能在你工作中用到的，你的缺点千万不能出现在工作中。优点很好说，缺点就很难。优点比如，我工作认真踏实，团队意识强，学习能力强等等等，缺点你怎么说呢？好吃懒做，不思进取。这样回答基本就挂了。你必须自己的缺点和公司无关紧要的，经过面试经验，一般回答你自己生活上的，比如我花钱控制不了那么详细，就会引起对方的兴趣，那你干嘛了？你可以随便说了，我一般控制自己每月花一千，但是朋友聚会花了一千五。对金钱控制不好，这完全不影响你的工作。其他也可以自己想其他理由。</li></ul><h4 id="不知情况乱开价：-—-提前查好对应的工资基本水平"><a href="#不知情况乱开价：-—-提前查好对应的工资基本水平" class="headerlink" title="不知情况乱开价： —-提前查好对应的工资基本水平"></a>不知情况乱开价： —-提前查好对应的工资基本水平</h4><ul><li>说到薪资60%代表你有很大的机会被录用，可是你却狮子大开口的说薪资要求，企业怎么敢用一个漫不符合本身能力的人?如果不想吃亏，应聘前应多打听企业相关信息，不然就采取“依公司规定”的保守战略。不知行情胡乱开价，绝不让你的应聘倒扣200分。</li><li>北京这边的人力资源市场还是非常繁荣的，人才的流动性非常快，每年有两段流动高峰期。<ul><li>通常3<del>4月和9</del>10月是找工作高峰期：<ul><li>3~4月是大量人才拿到年终奖后跳槽的时期；</li><li>9~10月是各大高校毕业生求职时期；</li></ul></li><li>这两段时间都是企业释放大量岗位空缺的时间段，故而是求职旺季。</li></ul></li><li>跳槽也最好在这段时间，其它时间段最好不要跳槽，因为这时：一来岗位无空缺不好招人，二来公司人事会认为你是被裁员工印象不好，这样就不好谈价格了。</li><li>注意公司是以技能需求为驱动在人才市场里面找拥有目标技能的目标人群，而非以你所做项目为驱动，所以在简历里面技能项要分条重点表达，所做项目要辅助技能项做大致表达。</li><li>有些公司在行业里面有地位，是龙头老大，例如BAT、京东等的高并发系统架构方面的业务；平安等互联网金融的支付业务。这些公司的业务代表了行业规范，起到示范作用，能够学习到他们公司的这种权威性的技术或业务，以后可以到想效仿这些公司的其它小公司里面去，就可以有谈判的资本了，这就是在大公司的好处。（这就是为何在BAT工作的人，只要接触了BAT的核心技术，跳出来就那么值钱）</li><li>有些公司的某些部门，明明就不缺人，却天天打着招人的旗号，让人去面试。那么被猎头&#x2F;人事叫去面试之前，先问了解一些具体情况，有如下一些意识：<ul><li>从岗位角度问： 这个岗位是常年招聘的，还是最近刚招聘的。<ul><li>（如果是常年招聘的，那么最好不要过去了，人家公司上层可能都没有提供新员工名额，让你过去对你的要求是极高，你达到了或许有点希望，而且后面谈工资的时候对自己没有多少优势；如果是最近刚招聘的、岗位急着要人的，那么可以试试。）</li></ul></li><li>从部门角度问： 这个岗位所在的部门是什么情况，是由于业务扩展新成立的，还是一些老的部门。<ul><li>（如果是新成立一个部门，那么确实有可能要进新人，公司可能会放出岗位需求名额；如果是不是新成立的部门，是老部门，那么很可能这个岗位招人就不那么迫切。）</li></ul></li><li>从岗位职责要求角度问： 这个岗位的职责是什么，需要有什么技能的人选。<ul><li>（可以先让跟你打电话的猎头&#x2F;人事给你发一个JD邮件，你看看是否和你的技能、兴趣相符，如果相符则可以考虑是否过去；如果不相符，你都不知道他看了你的简历后怎么选的你，那你要么回信问清楚为何觉得我合适、贵岗位具体需要什么人做什么事情，如果没回音，就不要再管了，他们不要人的。不要怕把他们问烦了，他们如果真的缺人，那么不怕你多问，还怕你不来呢，问两句就烦，直接就说明他们本来就不确认，你去不去面试对他们影响不大。）</li></ul></li><li>面试过程中要有警觉： 如果最终还是去了，那么面试过程中也可以看到他们是否缺人。如果面试官上来就问你以前的项目，要你给他详细讲解，那么多半想把你当成免费的”老师“，你可以准备好一些素材给他讲；他问你有没有什么要问他的，你可以问他们要什么样技能的人，如果他们说的空泛不具体，不说需要具体掌握什么技能的，就是他们自己都不能详细表达岗位需求，那多半也不缺人。</li></ul></li><li>为何有些公司要这样“挖坑挖 ”呢？为何要设置那些长期招聘的岗位呢？ 呢<ul><li>第一、未雨绸缪。如果公司认为过段时间有人会离职，尤其是发完年终奖之前，那么就会提前做好准备，去招新人减少风险，而老员工未走新员工的招聘进度可以慢一点来。</li><li>第二、降低人力成本。如果公司当前人力成本太高，那么就想淘汰部分高价的老员工换来廉价新员工，那么会在老员工走之前招人，而新员工的招聘也可以慢一点来，招的到就招，招不到就不招，总之价格要压低。（这样的公司卸磨杀驴，不去也罢）</li><li>第三、换血。如果公司的部门当前好久没有换血了，对部门不是太有利，那么也是常年打着招聘的旗号招人，碰到真正有料的人选，如果成功压低了价格，也可以招进来，但公司不太缺人的情况下，不招也行。</li><li>第四、了解行业动态。这主要是部门某些人心术不正，让面试者赶来面试，当免费老师，以面试为名从面试者口中获取一些其它公司的技术内幕。（搞技术的人都不傻，出来混迟早要还的，心术不正败坏的是自己公司的名声。）</li></ul></li><li>面试官问你的职业规划？该怎么回答？回答这个问题要注意三点：<ul><li>接地气。也就是实实在在的说，不做作。这应该是在跟HR交流各个问题都要注意的，不要去学习面经上那些头头是道的回答，针对性并不强，不能把自己的特质表露出来，这对应聘双方都是无益的。搞清楚自己的想法，流畅的表达就行了（表达上也许需要一些技巧），至于如何搞清楚自己的想法，请看第二点。</li><li>预先做功课。了解自己和了解社会是一生都不应该停止的两个过程。在应聘之前，需要对自己和要应聘的行业、公司、岗位都有一定的了解，知道自己的兴趣点和竞争优势，在这个基础上才能够谈职业规划。</li><li>区分职业和工作。HR问你职业规划，也许只是在探寻你对这个岗位或公司的热衷度，判断你是无关痛痒的仅仅想要一份工作安身，还是对未来的发展有一定的方向，方向和目标自然不可能太具体，所以觉得难回答，但是，面试官想知道的其实是你对自己未来的期许是什么样子的，仅此而已。</li><li>参考：我希望在 我 **公司发展成为 公 “T”字形人才，短期目标，我希望能够接触尽可能多的知识面，努力扩展自己专业技能的 字 “横”，可以独立的完成工作中的每一个任务。长期目标，我希望自己在知识面足够宽的基础上，能够有一到两个方向的深入研究，深入自己工作中的一 长 ”竖“，早日独当一面，成为公司的中流砥柱，</li></ul></li></ul><h4 id="人事问工资该如何回答？"><a href="#人事问工资该如何回答？" class="headerlink" title="人事问工资该如何回答？"></a>人事问工资该如何回答？</h4><ul><li>2年工作经验：<ul><li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等</li><li>工作的内容，公司的发展</li><li>半年的时候去做大数据项目后加过一次薪，9000加到了12000.</li><li>12K——-17K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1000左右</li></ul></li><li>3年工作经验：<ul><li>17K——–23K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1400左右</li><li>具体的情况，根据面试的好坏做相应的调整，但是工资的税前和税后差额一般在2k—3k</li></ul></li><li>面试的本质不是一问一答，而是亮点展示</li></ul><h1 id="请介绍一下你自己"><a href="#请介绍一下你自己" class="headerlink" title="请介绍一下你自己"></a>请介绍一下你自己</h1><ul><li>这是面试官100%会问的问题，一般人回答这个问题过于平常，只说姓名、年龄、爱好、所学专业等，如果你用一分钟来重复你的简历，那么，你的印象加分没有了！</li><li>不妨坦诚自信地展现自我，重点突出与应聘职位相吻合的优势。你的相关能力和素质是企业最感兴趣的信息。因为，在许多情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。</li><li>回答范例：我叫XX，今年X岁，XXXX年毕业于XX大学。有3年的开发工作经验，我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，精通.Net技术体系，熟悉MVC。平常有时间看看博客，并且自己也喜欢在CSDN上写技术类的文章，与博友一起讨论。谢谢！</li></ul><h1 id="为什么来北京找工作？"><a href="#为什么来北京找工作？" class="headerlink" title="为什么来北京找工作？"></a>为什么来北京找工作？</h1><ul><li>面试官对异地求职者90%都会问的问题，主要考察你是否稳定，个人经验能力之外，排在第一位的就是稳定性，如果不够稳定，那么其余都是空谈。</li><li>回答范例：我来自河南，河南是一个农业大省，IT行业还不是很发达，我是学计算机专业的，也很喜欢这个行业，北京在国内IT行业发展是最快的，所以我想来这里谋求发展，学习更多的新技术，能够带来自我的提升。</li><li>注意：不要说以前公司有多么不好。也不要说哪个哥们混的很不错，羡慕才来北京。因为企业招人想要的都是能够长期工作的人，可能哪个哥们哪天在别的地方又混的更好了，你是不是还要跳槽？所以，只要说来学习更多新技术和管理经验就够了。</li></ul><h1 id="你为什么离开原来的公司？"><a href="#你为什么离开原来的公司？" class="headerlink" title="你为什么离开原来的公司？"></a>你为什么离开原来的公司？</h1><ul><li>最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在</li><li>避免把“离职原因”说得太详细、太具体</li><li>不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等</li><li>但也不能躲闪、回避，如“想换换环境”、“个人原因”等</li><li>不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等</li><li>尽量使解释的理由为应聘者个人形象添彩</li><li>相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</li><li>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。</li></ul><h1 id="你最大的缺点是什么？"><a href="#你最大的缺点是什么？" class="headerlink" title="你最大的缺点是什么？"></a>你最大的缺点是什么？</h1><ul><li>被面试官问的概率很大，也是HR的杀手锏和狠招，这个问题最难回答，通常面试官不希望听到求职直接回答的缺点是什么，如果求职者说自己小心眼、脾气大、工作效率低，企业肯定不会录用你。不要自作聪明地回答“我最大的缺点就是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。面试官喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上，突出优点的部分，面试官喜欢聪明的求职者。</li><li>回答范例：这个问题好难回答啊！我想想……（亲和力表现，也缓解了自己的紧张情绪）我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。</li></ul><h1 id="你未来3-5年的职业规划是怎样的？"><a href="#你未来3-5年的职业规划是怎样的？" class="headerlink" title="你未来3-5年的职业规划是怎样的？"></a>你未来3-5年的职业规划是怎样的？</h1><ul><li>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</li><li>回答范例：我希望从现在开始，1-2年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以从开发做到架构师。同时我也希望自己能够在企业的平台上得到进一步的职业能力提升。</li></ul><h1 id="你对薪资的要求？"><a href="#你对薪资的要求？" class="headerlink" title="你对薪资的要求？"></a>你对薪资的要求？</h1><ul><li>如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求职的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</li><li>回答范例一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。</li><li>如果你必须自己说出具体数目，那就不要说一个宽泛的范围，不要说7000-8000之间，那样你将只会得到最低限底的数字，也就是7000。最好给出一个具体的数字。</li></ul><h1 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h1><ul><li>大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司的规定上班”，如果还未辞去上一个工作，但上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</li></ul><h1 id="介绍一个你认为最熟悉的项目（项目经理）"><a href="#介绍一个你认为最熟悉的项目（项目经理）" class="headerlink" title="介绍一个你认为最熟悉的项目（项目经理）"></a>介绍一个你认为最熟悉的项目（项目经理）</h1><ul><li>这个问题在技术面试时常被问到，问这个问题的意图是想考察你的成长路径和编程习惯，因为，你最熟悉的项目往往是你成长最快的项目，那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹。所以，通过你对熟悉项目的描述，有经验的他会很快锁定你技术成长中的缺陷和闪光点，从而判断是否能够“为我所用”。</li><li>你最好拿出一个自己最擅长技术的那个项目进行介绍，他听完你的介绍后，会接下来进行提问，这样他所有问的问题，你都成竹在胸了。</li><li>切忌拿自己参与很少的项目来介绍，一旦他深入的询问很可能你会答非所问，反而造成更严重的影响。你大强以和他谈谈在那个项目中获得的经验，这样会引起此君的共鸣，有可能的话，说出一些你自己的小技巧，他会很高兴，同时这场面试也会很轻松，拿到Offer基本没问题了。</li></ul><h1 id="如果公司录用你，你将怎样开展工作？"><a href="#如果公司录用你，你将怎样开展工作？" class="headerlink" title="如果公司录用你，你将怎样开展工作？"></a>如果公司录用你，你将怎样开展工作？</h1><ul><li>很多企业在招聘开发人员时很看重是否能够尽快上手，所以回答这个问题时要“实打实”的回答，在回答中最好强调能够“尽快”投入开发工作中，这样领导就放心了，会觉得你不是一个只会盲目工作的人，而是一个按部就班，稳打稳扎的人。</li><li>回答范例：我对咱们公司的大体情况只有一个大概了解，在这个职位的工作性质仅仅是我自己的一个理解。作为这个职位而言，我想我首先要对本公司的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向、我们面向的客户性质等。第二我要了解所属部门在公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。第三，了解我参与项目的开发方式，架构方式，紧密配合领导工作，尽快投入具体的开发工作中。这就是我开展工作的计划。</li></ul><h1 id="你还有什么问题问我吗？"><a href="#你还有什么问题问我吗？" class="headerlink" title="你还有什么问题问我吗？"></a>你还有什么问题问我吗？</h1><ul><li>这个问题看上去可有可无，其实很关键，面试官不喜欢说“没有问题”的人，没有问题就是自寻死路，没有问题传达出你对公司缺乏兴趣，而只是来寻找一笔薪水。其实在面试过程中谦虚礼貌的问面试官怎么称呼，该部门工作中的信息，如项目情况，开发技术再或者说贵公司的晋升机制是什么样的等。表现出一种很积极主动的状态是非常讨巧的。也可以更多的了解到自己来的工作环境。企业很欢迎这样的求职者，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</li></ul><h1 id="你对加班的看法？"><a href="#你对加班的看法？" class="headerlink" title="你对加班的看法？"></a>你对加班的看法？</h1><ul><li>实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。</li><li>回答范例：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</li></ul><h1 id="你朋友对你的评价？"><a href="#你朋友对你的评价？" class="headerlink" title="你朋友对你的评价？"></a>你朋友对你的评价？</h1><ul><li>回答提示： 想从侧面了解一下你的性格及与人相处的问题。</li><li>回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。</li><li>回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。</li></ul><h1 id="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"><a href="#如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？" class="headerlink" title="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"></a>如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</h1><ul><li>回答提示：一段时间发现工作不适合我，有两种情况：<ul><li>如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</li><li>你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</li></ul></li></ul><h1 id="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"><a href="#在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？" class="headerlink" title="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"></a>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</h1><ul><li>原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。</li><li>如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。</li><li>还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</li></ul><h1 id="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"><a href="#如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？" class="headerlink" title="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"></a>如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</h1><ul><li>我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。</li><li>分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。</li><li>总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</li></ul><h1 id="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"><a href="#如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？" class="headerlink" title="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"></a>如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</h1><ul><li>我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：<ul><li>我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。</li><li>他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</li></ul></li></ul><h1 id="谈谈你对跳槽的看法？"><a href="#谈谈你对跳槽的看法？" class="headerlink" title="谈谈你对跳槽的看法？"></a>谈谈你对跳槽的看法？</h1><ul><li>正常的“跳槽”能促进人才合理流动，应该支持。</li><li>频繁的跳槽对单位和个人双方都不利，应该反对。</li></ul><h1 id="工作中你难以和同事、上司相处，你该怎么办？"><a href="#工作中你难以和同事、上司相处，你该怎么办？" class="headerlink" title="工作中你难以和同事、上司相处，你该怎么办？"></a>工作中你难以和同事、上司相处，你该怎么办？</h1><ul><li>我会服从领导的指挥，配合同事的工作。</li><li>我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话 我会努力改正。</li><li>如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。</li><li>作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。</li></ul><h1 id="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"><a href="#假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？" class="headerlink" title="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"></a>假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</h1><ul><li>成绩比较突出，得到领导的肯定是件好事情，以后更加努力。</li><li>检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。</li><li>工作中，切勿伤害别人的自尊心。</li><li>不再领导前拨弄是非。<br>。</li></ul><h1 id="请说出你选择这份工作的动机？"><a href="#请说出你选择这份工作的动机？" class="headerlink" title="请说出你选择这份工作的动机？"></a>请说出你选择这份工作的动机？</h1><ul><li>这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</li></ul><h1 id="你最擅长的技术方向是什么？"><a href="#你最擅长的技术方向是什么？" class="headerlink" title="你最擅长的技术方向是什么？"></a>你最擅长的技术方向是什么？</h1><ul><li>说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</li></ul><h1 id="你能为我们公司带来什么呢？"><a href="#你能为我们公司带来什么呢？" class="headerlink" title="你能为我们公司带来什么呢？"></a>你能为我们公司带来什么呢？</h1><ul><li>企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</li></ul><h1 id="最能概括你自己的三个词是什么？"><a href="#最能概括你自己的三个词是什么？" class="headerlink" title="最能概括你自己的三个词是什么？"></a>最能概括你自己的三个词是什么？</h1><ul><li>我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，</li></ul><h1 id="你的业余爱好是什么？"><a href="#你的业余爱好是什么？" class="headerlink" title="你的业余爱好是什么？"></a>你的业余爱好是什么？</h1><ul><li>找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。</li></ul><h1 id="作为被面试者给我打一下分？"><a href="#作为被面试者给我打一下分？" class="headerlink" title="作为被面试者给我打一下分？"></a>作为被面试者给我打一下分？</h1><ul><li>试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</li></ul><h1 id="你怎么理解你应聘的职位？"><a href="#你怎么理解你应聘的职位？" class="headerlink" title="你怎么理解你应聘的职位？"></a>你怎么理解你应聘的职位？</h1><ul><li>把岗位职责和任务及工作态度阐述一下。</li></ul><h1 id="喜欢这份工作的哪一点？"><a href="#喜欢这份工作的哪一点？" class="headerlink" title="喜欢这份工作的哪一点？"></a>喜欢这份工作的哪一点？</h1><ul><li>相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</li></ul><h1 id="说说你对行业、技术发展趋势的看法？"><a href="#说说你对行业、技术发展趋势的看法？" class="headerlink" title="说说你对行业、技术发展趋势的看法？"></a>说说你对行业、技术发展趋势的看法？</h1><ul><li>企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</li></ul><h1 id="对工作的期望与目标何在？"><a href="#对工作的期望与目标何在？" class="headerlink" title="对工作的期望与目标何在？"></a>对工作的期望与目标何在？</h1><ul><li>这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</li></ul><h1 id="说你的家庭"><a href="#说你的家庭" class="headerlink" title="说你的家庭"></a>说你的家庭</h1><ul><li>企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。</li><li>企业希望听到的重点也在于家庭对求职者的积极影响。</li><li>企业最喜欢听到的是：我很爱我的家庭，我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。</li><li>我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。</li><li>企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</li></ul><h1 id="就你申请的这个职位，你认为你还欠缺什么？"><a href="#就你申请的这个职位，你认为你还欠缺什么？" class="headerlink" title="就你申请的这个职位，你认为你还欠缺什么？"></a>就你申请的这个职位，你认为你还欠缺什么？</h1><ul><li>企业喜欢问求职者弱点，但精明的求职者一般不直接回答。</li><li>他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</li></ul><h1 id="你欣赏哪种性格的人？"><a href="#你欣赏哪种性格的人？" class="headerlink" title="你欣赏哪种性格的人？"></a>你欣赏哪种性格的人？</h1><ul><li>诚实、不死板而且容易相处的人、有“实际行动”的人。</li></ul><h1 id="你通常如何处理別人的批评？"><a href="#你通常如何处理別人的批评？" class="headerlink" title="你通常如何处理別人的批评？"></a>你通常如何处理別人的批评？</h1><ul><li>沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。</li><li>我会等大家冷靜下来再讨论。</li></ul><h1 id="你为什么愿意到我们公司来工作？"><a href="#你为什么愿意到我们公司来工作？" class="headerlink" title="你为什么愿意到我们公司来工作？"></a>你为什么愿意到我们公司来工作？</h1><ul><li>对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</li></ul><h1 id="你和别人发生过争执吗？你是怎样解决的？"><a href="#你和别人发生过争执吗？你是怎样解决的？" class="headerlink" title="你和别人发生过争执吗？你是怎样解决的？"></a>你和别人发生过争执吗？你是怎样解决的？</h1><ul><li>这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。</li><li>你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。</li><li>他们通过这个问题了解你的成熟度和处世能力。</li><li>在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</li></ul><h1 id="问题：你做过的哪件事最令自己感到骄傲？"><a href="#问题：你做过的哪件事最令自己感到骄傲？" class="headerlink" title="问题：你做过的哪件事最令自己感到骄傲？"></a>问题：你做过的哪件事最令自己感到骄傲？</h1><ul><li>这是考官给你的一个机会，让你展示自己把握命运的能力。</li><li>这会体现你潜在的领导能力以及你被提升的可能性。</li><li>假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐</li><li>记住：你的前途取决于你的知识、你的社交能力和综合表现。</li></ul><h1 id="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"><a href="#新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？" class="headerlink" title="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"></a>新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？</h1><ul><li>首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。</li><li>其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。</li><li>再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。</li><li>再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。</li><li>我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。</li></ul><h1 id="对这项工作，你有哪些可预见的困难？"><a href="#对这项工作，你有哪些可预见的困难？" class="headerlink" title="对这项工作，你有哪些可预见的困难？"></a>对这项工作，你有哪些可预见的困难？</h1><ul><li>不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。</li><li>可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。</li><li>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。</li><li>当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</li></ul><h1 id="怎样对待自己的失敗？"><a href="#怎样对待自己的失敗？" class="headerlink" title="怎样对待自己的失敗？"></a>怎样对待自己的失敗？</h1><ul><li>我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</li></ul><h1 id="什么会让你有成就感？"><a href="#什么会让你有成就感？" class="headerlink" title="什么会让你有成就感？"></a>什么会让你有成就感？</h1><ul><li>为贵公司竭力效劳，尽我所能，完成一个项目。</li></ul><h1 id="眼下你生活中最重要的是什么？"><a href="#眼下你生活中最重要的是什么？" class="headerlink" title="眼下你生活中最重要的是什么？"></a>眼下你生活中最重要的是什么？</h1><ul><li>对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。</li></ul><h1 id="与上级意见不一是，你将怎么办？"><a href="#与上级意见不一是，你将怎么办？" class="headerlink" title="与上级意见不一是，你将怎么办？"></a>与上级意见不一是，你将怎么办？</h1><ul><li><p>一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</p></li><li><p>如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</p></li><li><p>分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p></li><li><p>你工作经验欠缺，如何能胜任这项工作？</p></li><li><p>如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。</p></li><li><p>对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。</p></li><li><p>如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</p></li><li><p>点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p></li></ul><h1 id="你希望与什么样的上级共事？"><a href="#你希望与什么样的上级共事？" class="headerlink" title="你希望与什么样的上级共事？"></a>你希望与什么样的上级共事？</h1><ul><li>通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。</li><li>最好回避对上级具体的希望，多谈对自己的要求。</li><li>如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。</li><li>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</li></ul><h1 id="谈谈如何适应办公室工作的新环境？"><a href="#谈谈如何适应办公室工作的新环境？" class="headerlink" title="谈谈如何适应办公室工作的新环境？"></a>谈谈如何适应办公室工作的新环境？</h1><ul><li>办公室里每个人有各自的岗位与职责，不得擅离岗位。</li><li>根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。</li><li>多请示并及时汇报，遇到不明白的要虚心请教。</li><li>抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</li></ul><h1 id="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"><a href="#为了做好你工作份外之事，你该怎样获得他人的支持和帮助？" class="headerlink" title="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"></a>为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</h1><ul><li>每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</li></ul><h1 id="如果你在这次面试中没有被录用，你怎么打算？"><a href="#如果你在这次面试中没有被录用，你怎么打算？" class="headerlink" title="如果你在这次面试中没有被录用，你怎么打算？"></a>如果你在这次面试中没有被录用，你怎么打算？</h1><ul><li>现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。</li><li>我会从以下几个方面来正确看待这次失败：<ul><li>要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。</li><li>善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。</li><li>走出阴影，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。</li><li>认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的成绩。</li><li>再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞争。</li></ul></li></ul><h1 id="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"><a href="#假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？" class="headerlink" title="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"></a>假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？</h1><ul><li>我觉得工作是第一位的，但朋友间的情谊也是不能偏废的，这个问题我觉得要按照当时具体的情况来决定。</li><li>如果我的朋友晚上9点中的飞机，而我的加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。</li><li>如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。</li><li>如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。<ul><li>如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。</li><li>如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，相信他会理解，毕竟工作做完了就完了，朋友还是可以再见面的。</li></ul></li></ul><h1 id="谈谈你过去做过的成功案例？"><a href="#谈谈你过去做过的成功案例？" class="headerlink" title="谈谈你过去做过的成功案例？"></a>谈谈你过去做过的成功案例？</h1><ul><li>举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。</li><li>切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</li></ul><h1 id="谈谈你过去的工作经验中，最令你挫折的事情？"><a href="#谈谈你过去的工作经验中，最令你挫折的事情？" class="headerlink" title="谈谈你过去的工作经验中，最令你挫折的事情？"></a>谈谈你过去的工作经验中，最令你挫折的事情？</h1><ul><li>曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。</li><li>分析：借此了解你对挫折的容忍度及调解方式。</li></ul><h1 id="如何安排自己的时间？会不会排斥加班？"><a href="#如何安排自己的时间？会不会排斥加班？" class="headerlink" title="如何安排自己的时间？会不会排斥加班？"></a>如何安排自己的时间？会不会排斥加班？</h1><ul><li>基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。</li><li>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</li></ul><h1 id="为什么我们要在众多的面试者中选择你？"><a href="#为什么我们要在众多的面试者中选择你？" class="headerlink" title="为什么我们要在众多的面试者中选择你？"></a>为什么我们要在众多的面试者中选择你？</h1><ul><li>根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、ＥＱ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。</li><li>分析：别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。</li></ul><h1 id="你并非毕业于名牌院校？"><a href="#你并非毕业于名牌院校？" class="headerlink" title="你并非毕业于名牌院校？"></a>你并非毕业于名牌院校？</h1><ul><li>是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我想我更适合贵公司这个职位。</li></ul><h1 id="怎样看待学历和能力？"><a href="#怎样看待学历和能力？" class="headerlink" title="怎样看待学历和能力？"></a>怎样看待学历和能力？</h1><ul><li>学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？</li></ul><h1 id="工作中学习到了些什么？"><a href="#工作中学习到了些什么？" class="headerlink" title="工作中学习到了些什么？"></a>工作中学习到了些什么？</h1><ul><li>这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</li></ul><h1 id="想过创业吗？"><a href="#想过创业吗？" class="headerlink" title="想过创业吗？"></a>想过创业吗？</h1><ul><li>这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？</li></ul><h1 id="除了本公司外，还应聘了哪些公司？"><a href="#除了本公司外，还应聘了哪些公司？" class="headerlink" title="除了本公司外，还应聘了哪些公司？"></a>除了本公司外，还应聘了哪些公司？</h1><ul><li>很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</li></ul><h1 id="面试注意事项："><a href="#面试注意事项：" class="headerlink" title="面试注意事项："></a>面试注意事项：</h1><ul><li>在面试官面前千万不要抖脚，手脚不要动来动去，不能有小动作。</li><li>在面试过程中，千万不要跟面试官去争论，说话太冲，太能说、抢话说、乱说都不好，遇到难题，先思考一下，切记心浮气燥，表达时口气温和，谦虚。</li><li>如果面试过程中都不错，谈的也很好，之后却没有给Offer，完全是自己意料之外的情况，这个很有可能，或许是因为公司有了其他的人选，不用介意，更不要沮丧。</li><li>在面试过程中，切忌问关于公司计划、行业机密等相关的东西，不要打探公司的内幕，机密敏感性的问题不要问东问西。</li><li>千万要注意仪容仪表，要有礼貌，最好不要有口吃，口头表达，逻辑思维很重要，不要让面试官觉得你很幼稚，太过小孩子气，显的不够稳重踏实。</li><li>在去面试之前，要熟悉自己的简历，特别是工作经历，准备好关于一些离职原因、职业规划方面的问题的回答方式。</li><li>在面试过程中，80%的面试官会让做自我介绍，所以提前要准备一下，说出的内容既要和简历相符，又要有重点有突出的地方，不能像背简历一样。</li><li>面试完后，如果等待的时间较长，没有回应，就可能没有什么希望了，自己可以打电话去了解情况。</li><li>在面试过程中，谈到薪资的时候，如果没有说明是税后工资就是税前，假如是税前6000，这里面就包括了公司给交的公积金，还有其他五险要交的费用，拿到手差不多4000左右。</li></ul><h1 id="投递简历注意事项"><a href="#投递简历注意事项" class="headerlink" title="投递简历注意事项"></a>投递简历注意事项</h1><ul><li>投简历的时间最好在早上8点多钟，因为人事9点多开始收简历，收到的简历又都是按时间来排序的，所以一般早上8点到9点投的都会排在前面，人事当天就能看到。</li><li>写简历：<ul><li>现居住地最好能在企业附近，如果不在，只写北京，人事比较看重现居住地，如果你填写的现居地离公司远，基本上人事就不太愿意打电话了，因为她（他）怕你不会来。</li><li>期望薪资最好不要写在简历上，也不要填写在网上的简历上，具体薪资见面的时候再谈。</li><li>大部分的岗位招聘都有相应的硬性要求，比如：年龄、居住地点、工作年限等。如果自己不符合也没有关系，机会还有很多。</li><li>简历上的工作经历不能太多，否则人事会觉得你不够稳定。</li><li>开发工作，简历上的项目要抓住重点，放重要的技术点，不能千篇一律，简短、抓住中心。</li></ul></li></ul><h1 id="入职后试用期："><a href="#入职后试用期：" class="headerlink" title="入职后试用期："></a>入职后试用期：</h1><ul><li>到了公司之后，工作中不懂的地方要多问，跟同事搞好关系，多看看旁人在干什么～</li><li>有些同学被录用之后都还不知道自己的薪资待遇，也不知道公司有哪些福利，这是因为在面试过程中不敢多问。因此，如果在面试过程中，面试官已经比较明确的表达了想让你去上班后，你就可以在适当的时候问一些关于工作的情况，工资、福利待遇，上班时间，加班情况等等。</li></ul><h1 id="上家公司的组成架构"><a href="#上家公司的组成架构" class="headerlink" title="上家公司的组成架构"></a>上家公司的组成架构</h1><ul><li>根据你的公司来定即可</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/98f0d77a0556.html" class="post-title-link" itemprop="url">数据结构与算法</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:35:25" itemprop="dateCreated datePublished" datetime="2023-12-20T15:35:25+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-26 20:27:05" itemprop="dateModified" datetime="2023-12-26T20:27:05+08:00">2023-12-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说⼀下⼏种常⻅的排序算法和分别的复杂度"><a href="#说⼀下⼏种常⻅的排序算法和分别的复杂度" class="headerlink" title="说⼀下⼏种常⻅的排序算法和分别的复杂度"></a>说⼀下⼏种常⻅的排序算法和分别的复杂度</h1><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li>原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了.<ul><li>选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。</li><li>基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的分在右边。</li><li>可以肯定，如此⼀轮下来，这个枢轴的位置⼀定在最终位置上。</li><li>对两个⼦数组分别重复上述过程，直到每个数组只有⼀个元素。</li><li>排序完成。</li></ul></li><li>复杂度：O(n)</li><li>特点：快速排序是我们平常最常使⽤的⼀种排序算法,因为它速度快,效率⾼,是最优秀的⼀种排序算法.</li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li>原理：冒泡排序其实就是逐⼀⽐较交换,进⾏⾥外两次循环,外层循环为遍历所有数字,逐个确定每个位置,⾥层循环为确定了位置后,遍历所有后⾯没有确定位置的数字,与该位置的数字进⾏⽐较,只要⽐该位置的数字⼩,就和该位置的数字进⾏交换.</li><li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li><li>特点：冒泡排序在我们实际开发中,使⽤的还是⽐较少的.它更加适合数据规模⽐较少的时候,因为它的效率是⽐较低的,但是优点是逻辑简单,容易让我们记得.</li></ul><h4 id="直接插⼊排序"><a href="#直接插⼊排序" class="headerlink" title="直接插⼊排序"></a>直接插⼊排序</h4><ul><li>原理：直接插⼊排序是将从第⼆个数字开始,逐个拿出来,插⼊到之前排好序的数列⾥.</li><li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li></ul><h4 id="直接选择排序："><a href="#直接选择排序：" class="headerlink" title="直接选择排序："></a>直接选择排序：</h4><ul><li>原理：直接选择排序是从第⼀个位置开始遍历位置,找到剩余未排序的数据⾥最⼩的,找到最⼩的后,再做交换</li><li>复杂度：O(n^2)</li><li>特点：和冒泡排序⼀样,逻辑简单,但是效率不⾼,适合少量的数据排序</li></ul><h1 id="描述⼀下链式存储结构"><a href="#描述⼀下链式存储结构" class="headerlink" title="描述⼀下链式存储结构"></a>描述⼀下链式存储结构</h1><ul><li>线性结构的优点是可以实现随机读取，时间复杂度为O(1)，空间利⽤率⾼，缺点是进⾏插⼊和删除操作时⽐较麻烦，时间复杂度为O(n)，同时容量受限制，需要事先确定容量⼤⼩，容量过⼤，浪费空间资源，过⼩不能满⾜使⽤要求，会产⽣溢出问题。</li><li>链式存储结构的优点主要是插⼊和删除⾮常简单，前提条件是知道操作位置，时间复杂度是O(1)，但如果不知道操作位置则要定位元素，时间复杂度为O(n)，没有容量的限制，可以使⽤过程中动态分配的分配内存空间，不⽤担⼼溢出问题，但是它并不能实现随机读取，同时空间利⽤率不⾼。</li></ul><h1 id="如何遍历⼀颗⼆叉树"><a href="#如何遍历⼀颗⼆叉树" class="headerlink" title="如何遍历⼀颗⼆叉树"></a>如何遍历⼀颗⼆叉树</h1><ul><li>先输出节点的值，再递归遍历左右⼦树。中序和后序的递归类似，改变根节点输出位置即可。</li></ul><h1 id="倒排⼀个LinkedList"><a href="#倒排⼀个LinkedList" class="headerlink" title="倒排⼀个LinkedList"></a>倒排⼀个LinkedList</h1><ul><li>Collections.reverse(linkedList);</li></ul><h1 id="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"><a href="#⽤java写⼀个递归遍历⽬录下⾯的所有⽂件" class="headerlink" title="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"></a>⽤java写⼀个递归遍历⽬录下⾯的所有⽂件</h1><ul><li>File.listFiles()</li></ul><h1 id="⼆叉树与红⿊树："><a href="#⼆叉树与红⿊树：" class="headerlink" title="⼆叉树与红⿊树："></a>⼆叉树与红⿊树：</h1><h4 id="⼆叉树"><a href="#⼆叉树" class="headerlink" title="⼆叉树"></a>⼆叉树</h4><ul><li>左⼦树上所有结点的值均⼩于或等于它的根结点的值。</li><li>右⼦树上所有结点的值均⼤于或等于它的根结点的值。</li><li>左、右⼦树也分别为⼆叉排序树。</li><li>查找：⼆分查找（通过⼀层⼀层的⽐较⼤⼩来查找位置）：如查找值为10的节点：9–13–11–10</li><li>缺陷：插⼊容易变成线性形态，查找性能⼤打折扣，这时需要引⼊红⿊树来解决</li></ul><h4 id="红⿊树"><a href="#红⿊树" class="headerlink" title="红⿊树"></a>红⿊树</h4><ul><li>特点：是⼀种⾃平衡的⼆叉查找树，除了符合⼆叉树的特点之外，还符合以下⼏点：<ul><li>节点是红⾊或⿊⾊。</li><li>根节点是⿊⾊。</li><li>每个叶⼦节点都是⿊⾊的空节点（NIL节点）。</li><li>每个红⾊节点的两个⼦节点都是⿊⾊。(从每个叶⼦到根的所有路径上不能有两个连续的红⾊节点)</li><li>从任⼀节点到其每个叶⼦的所有路径都包含相同数⽬的⿊⾊节点。</li></ul></li><li>这些规则保证了红⿊树的⾃平衡。</li><li>红⿊树从根到叶⼦的最长路径不会超过最短路径的2倍。</li><li>提⾼寻址效率。</li><li>添加删除：通过⾃旋来保证平衡</li></ul><h1 id="b-tree、b-tree多叉树："><a href="#b-tree、b-tree多叉树：" class="headerlink" title="b-tree、b+tree多叉树："></a>b-tree、b+tree多叉树：</h1><h4 id="b-tree"><a href="#b-tree" class="headerlink" title="b-tree"></a>b-tree</h4><ul><li>⽂件系统</li><li>B树也称B-树,它是⼀颗多路平衡查找树</li><li>我们描述⼀颗B树时需要指定它的阶数，阶数表示了⼀个结点最多有多少个孩⼦结点，⼀般⽤字⺟m表示阶数</li><li>当m取2时，就是我们常⻅的⼆叉搜索树。</li><li>定义：<ul><li>每个结点最多有m-1个关键字。</li><li>根结点最少可以只有1个关键字。</li><li>⾮根结点⾄少有Math.ceil(m&#x2F;2)-1个关键字。</li><li>每个结点中的关键字都按照从⼩到⼤的顺序排列，每个关键字的左⼦树中的所有关键字都⼩于它，⽽右⼦树中的所有关键字都⼤于它。</li><li>所有叶⼦结点都位于同⼀层，或者说根结点到每个叶⼦结点的⻓度都相同。</li></ul></li><li>插⼊数据，向兄弟节点借，兄弟节点不够则向⽗节点借；</li></ul><h4 id="b-tree-1"><a href="#b-tree-1" class="headerlink" title="b+tree"></a>b+tree</h4><ul><li>mysql索引</li><li>定义：<ul><li>B+树包含2种类型的结点：内部结点（也称索引结点）和叶⼦结点。根结点本身即可以是内部结点，也可以是叶⼦结点。根结点的关键字个数最少可以只有1个。</li><li>B+树与B树最⼤的不同是内部结点不保存数据，只⽤于索引，所有数据（或者说记录）都保存在叶⼦结点中。</li><li>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个⼦树），阶数m同时限制了叶⼦结点最多存储m-1个记录。</li><li>内部结点中的key都按照从⼩到⼤的顺序排列，对于内部结点中的⼀个key，左树中的所有key都⼩于它，右⼦树中的key都⼤于等于它。叶⼦结点中的记录也按照key的⼤⼩排列。</li><li>每个叶⼦结点都存有相邻叶⼦结点的指针，叶⼦结点本身依关键字的⼤⼩⾃⼩⽽⼤顺序链接。</li></ul></li></ul><h1 id="谈谈数据结构，⽐如TreeMap："><a href="#谈谈数据结构，⽐如TreeMap：" class="headerlink" title="谈谈数据结构，⽐如TreeMap："></a>谈谈数据结构，⽐如TreeMap：</h1><ul><li>TreeMap实现了红⿊树的结构。</li></ul><h1 id="图的深度遍历和⼴度遍历"><a href="#图的深度遍历和⼴度遍历" class="headerlink" title="图的深度遍历和⼴度遍历"></a>图的深度遍历和⼴度遍历</h1><ul><li>深度优先遍历：深度优先遍历尽可能优先往深层次进⾏搜索</li><li>⼴度优先遍历：⼴度优先遍历按层次优先搜索最近的结点，⼀层⼀层往外搜索。</li></ul><h1 id="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"><a href="#说说java集合，每个集合下⾯有哪些实现类，及其数据结构" class="headerlink" title="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"></a>说说java集合，每个集合下⾯有哪些实现类，及其数据结构</h1><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li>概念<ul><li>在HashMap内部，采⽤了数组+链表的形式来组织键值对Entry&lt;Key,Value&gt;（利⽤数组的查询快+链表的插⼊删除快）</li><li>HashMap在存储键值对Entry&lt;Key,Value&gt;的时候，会根据Key的hashcode值，以某种映射关系，决定应当将这对键值对Entry&lt;Key,Value&gt;存储在HashMap中的什么位置上</li><li>在JDK1.7进⾏多线程put操作，之后遍历，直接死循环，CPU飙到100%，在JDK 1.8中进⾏多线程操作会出现节点和value值丢失，为什么JDK1.7与JDK1.8多线程操作会出现很⼤不同，是因为JDK 1.8的作者对resize⽅法进⾏了优化不会产⽣链表闭环。</li></ul></li><li>结构</li><li>HashMap扩容<ul><li>很简单的计算：由于默认的加载因⼦是0.75 ，那么，此时map的阀值是 16*0.75 &#x3D; 12，即添加第13 个键值对&lt;Key,Value&gt;的时候，map的容量会扩充⼀倍。</li><li>确实如此，但是为了尽可能第减少桶中的Entry&lt;Key,Value&gt;链表的长度，以提⾼HashMap的存取性能，确定的这个经验值</li></ul></li><li>扩容步骤：<ul><li>申请⼀个新的、⼤⼩为当前容量两倍的数组；</li><li>将旧数组的Entry[] table中的链表重新计算hash值，然后重新均匀地放置到新的扩充数组中；</li><li>释放旧的数组；</li></ul></li><li>为何扩容为原来的两倍（性能）：<ul><li>在HashMap通过键的哈希值进⾏定位桶位置的时候，调⽤了⼀个indexFor(hash, table.length);⽅法。</li><li>通过限制length是⼀个2的幂数，h &amp; (length-1)和h % length结果是⼀致的。</li><li>如果length是⼀个2的幂的数，那么length-1就会变成⼀个mask, 它会将hashcode低位取出来，</li><li>hashcode的低位实际就是余数，和取余操作相⽐，与操作会将性能提升很多。</li></ul></li><li>put流程<ul><li>获取这个Key的hashcode值，根据此值确定应该将这⼀对键值对存放在哪⼀个桶中，即确定要存放桶的索引；</li><li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul><li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,其中的Value值更新为新的Value值；返回旧值；</li><li>若不存在，则根据键值对&lt;Key,Value&gt; 创建⼀个新的Entry&lt;Key,Value&gt;对象，然后添加到这个桶的Entry&lt;Key,Value&gt;</li></ul></li><li>当前的HashMap的⼤⼩(即Entry&lt;key,Value&gt;节点的数⽬)是否超过了阀值，若超过了阀值(threshold)，</li><li>则增⼤HashMap的容量(即Entry[] table 的⼤⼩)，并且重新组织内部各个Entry&lt;Key,Value&gt;排列。</li></ul></li><li>get流程<ul><li>获取这个Key的hashcode值，根据此hashcode值决定应该从哪⼀个桶中查找；</li><li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul><li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,返回value</li><li>若不存在，返回null；</li></ul></li></ul></li></ul><h1 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>红黑树是一种自平衡二叉查找树</li><li>它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用</li><li>它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。</li></ul><h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><ul><li>红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡</li><li>它的每个节点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父节点）。</li><li>红黑树的定义也是它的性质，有以下五条：<ul><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色（叶子是NIL节点）</li><li>如果一个节点是红的，则它的两个儿子都是黑的</li><li>从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。</li></ul></li><li>这五个性质强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</li><li>为什么呢？性质4暗示着任何一个简单路径上不能有两个毗连的红色节点，这样，最短的可能路径全是黑色节点，最长的可能路径有交替的红色和黑色节点。同时根据性质5知道：所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</li></ul><h4 id="红黑树的基本操作"><a href="#红黑树的基本操作" class="headerlink" title="红黑树的基本操作"></a>红黑树的基本操作</h4><ul><li>因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同</li><li>然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质</li><li>恢复红黑树的性质需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)</li><li>虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次。</li></ul><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><ul><li>插入操作可以概括为以下几个步骤：<ul><li>查找要插入的位置，时间复杂度为：O(N)</li><li>将新节点的color赋为红色</li><li>自下而上重新调整该树为红黑树</li></ul></li><li>其中，第(1)步的查找方法跟普通二叉查找树一样</li><li>第(2)步之所以将新插入的节点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的</li><li>但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整，这样简单多了</li><li>下面讨论步骤(3)的一些细节：<ul><li>设要插入的节点为N，其父节点为P，其父亲G的兄弟节点为U（即P和U是同一个节点的两个子节点）。</li><li>如果P是黑色的，则整棵树不必调整便是红黑树。</li><li>如果P是红色的（可知，其父节点G一定是黑色的），则插入z后，违背了性质4，需要进行调整</li><li>调整时分以下3种情况：<ul><li>N的叔叔U是红色的</li><li>N的叔叔U是黑色的，且N是右孩子</li><li>N的叔叔U是黑色的，且N是左孩子</li></ul></li></ul></li></ul><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><ul><li>删除操作可以概括为以下几个步骤：<ul><li>查找要删除位置，时间复杂度为：O(N)</li><li>用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点）</li><li>如果删除节点的替换节点为黑色，则需重新调整该树为红黑树</li></ul></li><li>其中，第(1)步的查找方法跟普通二叉查找树一样</li><li>第(2)步之所以用后继节点替换删除节点，是因为这样可以保证该后继节点之上仍是一个红黑树，而后继节点可能是一个叶节点或者只有右子树的节点，这样只需用有节点替换后继节点即可达到删除的目的</li><li>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题</li><li>在第(3)步中，如果，如果删除节点为红色节点，则他的父亲和孩子全为黑节点，这样直接删除该节点即可，不必进行任何调整</li><li>如果删除节点是黑节点，分四种情况：<ul><li>设要删除的节点为N，其父节点为P，其兄弟节点为S。</li><li>由于N是黑色的，则P可能是黑色的，也可能是红色的，S也可能是黑色的或者红色的</li><li>S是红色的</li><li>S和S的孩子全是黑色的</li><li>S是黑色的，S的左孩子是红色，右孩子是黑色</li><li>S是黑色的，S的右孩子是红色</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/e002a9c6759b.html" class="post-title-link" itemprop="url">Java web</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:32:02" itemprop="dateCreated datePublished" datetime="2023-12-20T15:32:02+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-28 16:01:13" itemprop="dateModified" datetime="2023-12-28T16:01:13+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-web/" itemprop="url" rel="index"><span itemprop="name">Java web</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>18 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service?"></a>什么是Web Service?</h1><ul><li>Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。</li><li>使用的技术：HTTP、XML、SOAP（简单对象访问协议）、WSDL</li><li>优点：跨平台、跨语言、跨系统</li><li>SOAP协议:<ul><li>SOAP协议（Simple Object Access Protocal,简单对象访问协议）</li><li>Tcp&#x2F;iphttp-&gt;soap，soap 通过xml文件传送信息</li></ul></li><li>缺点：<ul><li>WebService使用了XML对数据封装，会造成大量的数据要在网络中传输。</li><li>WebService规范没有规定任何与实现相关的细节，包括对象模型、编程语言，这一点，它不如CORBA。</li></ul></li></ul><h1 id="什么是Web容器"><a href="#什么是Web容器" class="headerlink" title="什么是Web容器?"></a>什么是Web容器?</h1><ul><li>实现J2EE规范中web协议的应用</li><li>该协议定义了web程序的运行时环境,包括:并发性,安全性,生命周期管理等等.</li><li>就是在tomcat、weblogic下运行jsp、servlet、struts</li></ul><h1 id="应用服务器有那些？"><a href="#应用服务器有那些？" class="headerlink" title="应用服务器有那些？"></a>应用服务器有那些？</h1><ul><li>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat</li></ul><h1 id="如何给weblogic指定大小的内存"><a href="#如何给weblogic指定大小的内存" class="headerlink" title="如何给weblogic指定大小的内存?"></a>如何给weblogic指定大小的内存?</h1><ul><li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li></ul><h1 id="如何设定的weblogic的热启动模式-开发模式-与产品发布模式"><a href="#如何设定的weblogic的热启动模式-开发模式-与产品发布模式" class="headerlink" title="如何设定的weblogic的热启动模式(开发模式)与产品发布模式?"></a>如何设定的weblogic的热启动模式(开发模式)与产品发布模式?</h1><ul><li>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一</li><li>或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE&#x3D;true。</li></ul><h1 id="如何启动时不需输入用户名与密码"><a href="#如何启动时不需输入用户名与密码" class="headerlink" title="如何启动时不需输入用户名与密码?"></a>如何启动时不需输入用户名与密码?</h1><ul><li>修改服务启动文件，增加 WLS_USER和WLS_PW项</li><li>也可以在boot.properties文件中增加加密过的用户名和密码.</li></ul><h1 id="在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中"><a href="#在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中" class="headerlink" title="在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?"></a>在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?</h1><ul><li>保存在此Domain的config.xml文件中，它是服务器的核心配置文件。</li></ul><h1 id="说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办"><a href="#说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办" class="headerlink" title="说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?"></a>说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?</h1><ul><li>Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问</li><li>如果是Web应用，应用目录需要满足Web应用目录要求</li><li>jsp文件可以直接放在应用目录中</li><li>Javabean需要放在应用目录的WEB-INF目录的classes目录中</li><li>设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。</li></ul><h1 id="CORBA是什么-用途是什么"><a href="#CORBA是什么-用途是什么" class="headerlink" title="CORBA是什么?用途是什么?"></a>CORBA是什么?用途是什么?</h1><ul><li>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)</li><li>由对象管理组织 (Object Management Group，缩写为 OMG)标准化</li><li>它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议</li><li>其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。</li></ul><h1 id="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"><a href="#说说在weblogic中开发消息Bean时的persistent与non-persisten的差别" class="headerlink" title="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"></a>说说在weblogic中开发消息Bean时的persistent与non-persisten的差别</h1><ul><li>persistent方式的MDB可以保证消息传递的可靠性</li><li>也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来</li><li>而non－persistent方式的消息将被丢弃。</li></ul><h1 id="WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。"><a href="#WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。" class="headerlink" title="WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。"></a>WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</h1><ul><li>Web Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。</li><li>JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口，这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。</li><li>JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。</li><li>WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。</li><li>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。</li><li>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。</li></ul><h1 id="简单说说tomcat的配置？"><a href="#简单说说tomcat的配置？" class="headerlink" title="简单说说tomcat的配置？"></a>简单说说tomcat的配置？</h1><ul><li>JAVA_HOME&#x3D;JDK的根目录</li><li>CATALINA_HOME&#x3D;tomcat的根目录</li><li>CATALINA-HOME\conf\server.xml:可以配置tomcat的端口，可以配置tomcat中下连接池。</li><li>CATALINA-HOME\common\lib:存放公用的类包</li></ul><h1 id="JSP中动态INCLUDE与静态INCLUDE的区别？"><a href="#JSP中动态INCLUDE与静态INCLUDE的区别？" class="headerlink" title="JSP中动态INCLUDE与静态INCLUDE的区别？"></a>JSP中动态INCLUDE与静态INCLUDE的区别？</h1><ul><li>jsp:include:在运行时调用另一个页面，变量是可以重复的。</li><li>&lt;%@include file&#x3D;””%&gt;:在转译时合在一起，会成为同一个类，变量不可以重复。</li><li>&lt;@include file&gt;:在将jsp生成servlet类前将两个文件和在一起，生成一个java类，一起运行的。所以是一家子，当中的变量名不能重名。</li><li>&lt;jsp:include page&gt;:是两个类，是一个调用关系，在运行时动态的调用，不是一家子，可以重复变量。</li></ul><h1 id="forward和redirect的区别？"><a href="#forward和redirect的区别？" class="headerlink" title="forward和redirect的区别？"></a>forward和redirect的区别？</h1><ul><li>forward: 转发，在下一个页面中，request保留上一个页面中的request的所有值</li><li>redirect: 跳转，不传递request对象。</li></ul><h1 id="Servlet的体系结构是什么"><a href="#Servlet的体系结构是什么" class="headerlink" title="Servlet的体系结构是什么?"></a>Servlet的体系结构是什么?</h1><ul><li>Servlet</li><li>GenericServlet</li><li>HttpServlet</li></ul><h1 id="如何实现一个自定义的servlet"><a href="#如何实现一个自定义的servlet" class="headerlink" title="如何实现一个自定义的servlet?"></a>如何实现一个自定义的servlet?</h1><ul><li>extends HttpServlet 并覆盖doPost或doGet方法</li><li>在web.xml中进行部署</li></ul><h1 id="Servlet的生命周期是什么"><a href="#Servlet的生命周期是什么" class="headerlink" title="Servlet的生命周期是什么?"></a>Servlet的生命周期是什么?</h1><ul><li>Init</li><li>多次执行doGet或doPost</li><li>destroy</li></ul><h1 id="jsp就是一个servlet是否正确"><a href="#jsp就是一个servlet是否正确" class="headerlink" title="jsp就是一个servlet是否正确?"></a>jsp就是一个servlet是否正确?</h1><ul><li>对</li></ul><h1 id="请罗列jsp中的脚本、指令及动作"><a href="#请罗列jsp中的脚本、指令及动作" class="headerlink" title="请罗列jsp中的脚本、指令及动作?"></a>请罗列jsp中的脚本、指令及动作?</h1><ul><li>脚本：&lt;%%&gt; &lt;%&#x3D;%&gt; &lt;%!%&gt; &lt;%—-%&gt;</li><li>指令<ul><li>&lt;%@page contentType&#x3D;”text&#x2F;html;charset&#x3D;utf-8” language&#x3D;”java” import&#x3D;””%&gt;</li><li>&lt;%@include file&#x3D;””%&gt;</li><li>&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</li></ul></li><li>动作:<ul><li>&lt;jsp:useBean class&#x3D;”” id&#x3D;”” scope&#x3D;””&gt; 在scope中如果没有实例化一个对象，如果有直接用以前的。</li><li>&lt;jsp:getProperty name&#x3D;”” property&#x3D;””&gt; 向一个bean中设置属性值</li><li>&lt;jsp:forward &gt; jsp页的转发</li><li>&lt;jsp:include page&#x3D;””&gt; 导入一个jsp页面</li></ul></li></ul><h1 id="JSP的内置对象及方法"><a href="#JSP的内置对象及方法" class="headerlink" title="JSP的内置对象及方法"></a>JSP的内置对象及方法</h1><ul><li>Request request表示HttpServletRequest对象。取客户端表单域信息及cookie, header, 和session</li><li>response response表示HttpServletResponse对象，对客户端的响应返回文本、写cookies。</li><li>out out 向客户端打印html文本.</li><li>pageContext :当前jsp页面的上下文环境，可以得到session、request、application等内置对象，在自定义标签中使用的很多。</li><li>session session表示一个请求的javax.servlet.http.HttpSession对象。Session一个用户多个页面共享同一变量。</li><li>application applicaton 表示一个javax.servle.ServletContext对象。存放容器级的变量。</li><li>config config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。</li><li>page page表示从该页面产生的一个servlet实例</li><li>exception:异常，当iserrorpage&#x3D;true</li></ul><h1 id="说出在JSP页面里是怎么分页的"><a href="#说出在JSP页面里是怎么分页的" class="headerlink" title="说出在JSP页面里是怎么分页的?"></a>说出在JSP页面里是怎么分页的?</h1><ul><li>页面需要保存以下参数：(数据库的分页及比较)<ul><li>总行数：根据sql语句得到总行数</li><li>每页显示行数：设定值</li><li>当前页数：请求参数</li></ul></li><li>页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。</li></ul><h1 id="描述JSP和Servlet的区别、共同点、各自应用的范围"><a href="#描述JSP和Servlet的区别、共同点、各自应用的范围" class="headerlink" title="描述JSP和Servlet的区别、共同点、各自应用的范围"></a>描述JSP和Servlet的区别、共同点、各自应用的范围</h1><ul><li>Jsp主要在于页面的显示动态生成页面，可以与html标记一起使用，其还是要生成为一个servlet。</li><li>Servlet：主要是控制的处理，如调用业务层，跳转不同的jsp页面。</li><li>Mvc:<ul><li>Jsp:v</li><li>Servlet:c</li></ul></li></ul><h1 id="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"><a href="#在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？" class="headerlink" title="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"></a>在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？</h1><ul><li>Request.getparameter(“”)</li><li>&lt;%&#x3D;application.getRealPath(“aa.jsp”) %&gt;</li></ul><h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。</h1><ul><li>Cookie:主要用在保存客户端，其值在客户端与服务端之间传送，不安全，存储的数据量有限。</li><li>Session:保存在服务端，每一个session在服务端有一个sessionID作一个标识。存储的数据量大，安全性高。占用服务端的内存资源。</li></ul><h1 id="说明Jsp中errorPage的作用，应用范围。"><a href="#说明Jsp中errorPage的作用，应用范围。" class="headerlink" title="说明Jsp中errorPage的作用，应用范围。"></a>说明Jsp中errorPage的作用，应用范围。</h1><ul><li>正常页面中：%@page erropage&#x3D;”error.jsp”%</li><li>错误页面：&lt;%@page iserrorpage&#x3D;”true”%&gt;</li><li>有一内置对象:exception</li></ul><h1 id="介绍在Jsp中如何使用JavaBeans"><a href="#介绍在Jsp中如何使用JavaBeans" class="headerlink" title="介绍在Jsp中如何使用JavaBeans"></a>介绍在Jsp中如何使用JavaBeans</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean class=”” id=”” scope=””/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	New 类();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="简单介绍JSP的标记库"><a href="#简单介绍JSP的标记库" class="headerlink" title="简单介绍JSP的标记库"></a>简单介绍JSP的标记库</h1><ul><li><p>做一个标记处理类 extends TagSupport</p></li><li><p>通过tld说明标记处理的类的前缀及后缀</p></li><li><p>在web.xml中说明tld文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;taglib&gt;</span><br><span class="line">		&lt;taglib-uri&gt;</span><br><span class="line">		&lt;taglib-location&gt;</span><br><span class="line">&lt;taglib&gt;</span><br></pre></td></tr></table></figure></li><li><p>在jsp页面是引用tld&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</p></li></ul><h1 id="Servlet中的核心类有那些，各有什么特点"><a href="#Servlet中的核心类有那些，各有什么特点" class="headerlink" title="Servlet中的核心类有那些，各有什么特点?"></a>Servlet中的核心类有那些，各有什么特点?</h1><ul><li>ServletContext：容器，放置全局变量<ul><li>setAtribute()</li><li>getAttribute()</li></ul></li><li>ServletConfig：一个servlet的配置<ul><li>getInitParameter(”名称”)</li></ul></li><li>HttpServletRequest：封装的所有的请求<ul><li>getParameterValue(”名称”)</li><li>getParameterValues(”称”)</li></ul></li><li>getSession();<ul><li>getAttribute(” 名称”);</li><li>getRequestDispatch(”a.jsp”).forward(request,response)</li></ul></li><li>HttpServletResponse：响应<ul><li>getOut();</li><li>sendRedirect(””)</li></ul><p></p></li><li>HttpSession：一个用户多个页面共享同一变量<ul><li>setAttribute(””,””)</li></ul></li></ul><h1 id="Servlet中重要的包有那些，有什么区别"><a href="#Servlet中重要的包有那些，有什么区别" class="headerlink" title="Servlet中重要的包有那些，有什么区别?"></a>Servlet中重要的包有那些，有什么区别?</h1><ul><li>javax.servlet.<em>；javax.servlet.http.</em>;</li></ul><h1 id="说出Servlet的生命周期，并说出Servlet和CGI的区别？"><a href="#说出Servlet的生命周期，并说出Servlet和CGI的区别？" class="headerlink" title="说出Servlet的生命周期，并说出Servlet和CGI的区别？"></a>说出Servlet的生命周期，并说出Servlet和CGI的区别？</h1><ul><li>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</li><li>与cgi的区别在于servlet处理服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li></ul><h1 id="什么情况下调用doGet-和doPost-？"><a href="#什么情况下调用doGet-和doPost-？" class="headerlink" title="什么情况下调用doGet()和doPost()？"></a>什么情况下调用doGet()和doPost()？</h1><ul><li>Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。</li></ul><h1 id="如何现实servlet的单线程模式"><a href="#如何现实servlet的单线程模式" class="headerlink" title="如何现实servlet的单线程模式"></a>如何现实servlet的单线程模式</h1><ul><li>在doGet及doPost方法前加入synchoronized</li><li>JSP：&lt;%@ page isThreadSafe&#x3D;”true”%&gt;</li></ul><h1 id="Request对象的主要方法："><a href="#Request对象的主要方法：" class="headerlink" title="Request对象的主要方法："></a>Request对象的主要方法：</h1><ul><li>setAttribute(String name,Object)：设置名字为name的request的参数值</li><li>getAttribute(String name)：返回由name指定的属性值</li><li>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例</li><li>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组</li><li>getCharacterEncoding()：返回请求中的字符编码方式</li><li>getContentLength()：返回请求的Body的长度</li><li>getInputStream()：返回请求的输入流，用于获得请求中的数据</li><li>getMethod()：获得客户端向服务器端传送数据的方法</li><li>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值</li><li>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li><li>getParameterValues(String name)：获得有name指定的参数的所有值</li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li><li>getQueryString()：获得查询字符串</li><li>getRequestURI()：获取发出请求字符串的客户端地址</li><li>getRemoteAddr()：获取客户端的IP地址</li><li>getRemoteHost()：获取客户端的名字</li><li>getSession([Boolean create])：返回和请求相关Session</li><li>getServerName()：获取服务器的名字</li><li>getServletPath()：获取客户端所请求的脚本文件的路径</li><li>getServerPort()：获取服务器的端口号</li><li>removeAttribute(String name)：删除请求中的一个属性</li></ul><h1 id="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"><a href="#我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"></a>我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Public String translate (String str) &#123;</span><br><span class="line">  String tempStr = &quot;&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">    tempStr = new String(str.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);</span><br><span class="line">    tempStr = tempStr.trim();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Exception e) &#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  return tempStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Servlet执行时一般实现哪几个方法"><a href="#Servlet执行时一般实现哪几个方法" class="headerlink" title="Servlet执行时一般实现哪几个方法?"></a>Servlet执行时一般实现哪几个方法?</h1><ul><li>public void init(ServletConfig config)</li><li>public ServletConfig getServletConfig()</li><li>public String getServletInfo()</li><li>public void service(ServletRequest request,ServletResponse response)</li><li>public void destroy()</li></ul><h1 id="jsp有哪些内置对象-作用分别是什么："><a href="#jsp有哪些内置对象-作用分别是什么：" class="headerlink" title="jsp有哪些内置对象?作用分别是什么："></a>jsp有哪些内置对象?作用分别是什么：</h1><ul><li>JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：<ul><li>request 用户端请求，此请求会包含来自GET&#x2F;POST请求的参数</li><li>response 网页传回用户端的回应</li><li>pageContext 网页的属性是在这里管理</li><li>session 与请求有关的会话期</li><li>application servlet 正在执行的内容</li><li>out 用来传送回应的输出</li><li>config servlet的构架部件</li><li>page JSP网页本身</li><li>exception 针对错误网页，未捕捉的例外。</li></ul></li></ul><h1 id="jsp有哪些动作-作用分别是什么："><a href="#jsp有哪些动作-作用分别是什么：" class="headerlink" title="jsp有哪些动作?作用分别是什么："></a>jsp有哪些动作?作用分别是什么：</h1><ul><li>JSP共有以下6种基本动作<ul><li>jsp:include：在页面被请求的时候引入一个文件。</li><li>jsp:useBean：寻找或者实例化一个JavaBean。</li><li>jsp:setProperty：设置JavaBean的属性。</li><li>jsp:getProperty：输出某个JavaBean的属性。</li><li>jsp:forward：把请求转到一个新的页面。</li><li>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。</li></ul></li></ul><h1 id="说一说Servlet的生命周期："><a href="#说一说Servlet的生命周期：" class="headerlink" title="说一说Servlet的生命周期："></a>说一说Servlet的生命周期：</h1><ul><li>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束</li><li>这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。</li></ul><h1 id="JAVA-SERVLET-API中forward-与redirect-的区别："><a href="#JAVA-SERVLET-API中forward-与redirect-的区别：" class="headerlink" title="JAVA SERVLET API中forward() 与redirect()的区别："></a>JAVA SERVLET API中forward() 与redirect()的区别：</h1><ul><li>前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接，从浏览器的地址栏中可以看到跳转后的链接地址</li><li>前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。</li></ul><h1 id="MVC的各个部分都有那些技术来实现-如何实现："><a href="#MVC的各个部分都有那些技术来实现-如何实现：" class="headerlink" title="MVC的各个部分都有那些技术来实现?如何实现："></a>MVC的各个部分都有那些技术来实现?如何实现：</h1><ul><li>MVC是Model－View－Controller的简写</li><li>“Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）</li><li>“View” 是应用的表示面（由JSP页面产生）</li><li>“Controller” 是提供应用的处理过程控制（一般是一个Servlet）</li><li>通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。</li></ul><h1 id="J2EE是什么："><a href="#J2EE是什么：" class="headerlink" title="J2EE是什么："></a>J2EE是什么：</h1><ul><li>Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model)</li><li>在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中</li><li>所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。</li></ul><h1 id="STRUTS的应用-如STRUTS架构-："><a href="#STRUTS的应用-如STRUTS架构-：" class="headerlink" title="STRUTS的应用(如STRUTS架构) ："></a>STRUTS的应用(如STRUTS架构) ：</h1><ul><li>Struts是采用Java Servlet&#x2F;JavaServer Pages技术，开发Web应用程序的开放源码的framework</li><li>采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架</li><li>Struts有如下的主要功能：<ul><li>包含一个controller servlet，能将用户的请求发送到相应的Action对象。</li><li>JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。</li><li>提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。</li></ul></li></ul><h1 id="开发中都用到了那些设计模式-用在什么场合："><a href="#开发中都用到了那些设计模式-用在什么场合：" class="headerlink" title="开发中都用到了那些设计模式?用在什么场合："></a>开发中都用到了那些设计模式?用在什么场合：</h1><ul><li>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心</li><li>通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作</li><li>主要用到了MVC的设计模式</li><li>用来开发JSP&#x2F;Servlet或者J2EE的相关应用</li><li>简单工厂模式等。</li></ul><h1 id="四种会话跟踪技术："><a href="#四种会话跟踪技术：" class="headerlink" title="四种会话跟踪技术："></a>四种会话跟踪技术：</h1><ul><li>cookie,url重写,session,隐藏域。</li></ul><h1 id="J2EE是技术还是平台还是框架："><a href="#J2EE是技术还是平台还是框架：" class="headerlink" title="J2EE是技术还是平台还是框架："></a>J2EE是技术还是平台还是框架：</h1><ul><li>J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。</li><li>J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。</li></ul><h1 id="EJB的角色和三个对象："><a href="#EJB的角色和三个对象：" class="headerlink" title="EJB的角色和三个对象："></a>EJB的角色和三个对象：</h1><ul><li>一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性</li><li>这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类</li></ul><h1 id="EJB容器提供的服务："><a href="#EJB容器提供的服务：" class="headerlink" title="EJB容器提供的服务："></a>EJB容器提供的服务：</h1><ul><li>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</li></ul><h1 id="EJB规范规定EJB中禁止的操作有哪些："><a href="#EJB规范规定EJB中禁止的操作有哪些：" class="headerlink" title="EJB规范规定EJB中禁止的操作有哪些："></a>EJB规范规定EJB中禁止的操作有哪些：</h1><ul><li>不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，</li><li>不能操作awt，</li><li>不能实现服务器功能，</li><li>不能对静态属生存取，</li><li>不能使用IO操作直接存取文件系统，</li><li>不能加载本地库.，</li><li>不能将this作为变量和返回，</li><li>不能循环调用。</li></ul><h1 id="说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法："><a href="#说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法：" class="headerlink" title="说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法："></a>说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法：</h1><ul><li>Session Facade Pattern：使用SessionBean访问EntityBean；</li><li>Message Facade Pattern：实现异步调用</li><li>EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问；</li><li>Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性；</li><li>Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性；</li><li>Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性；</li><li>ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率</li><li>项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。</li></ul><h1 id="UML方面："><a href="#UML方面：" class="headerlink" title="UML方面："></a>UML方面：</h1><ul><li>标准建模语言UML</li><li>用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。</li></ul><h1 id="说出一些常用的类，包，接口，请各举5个常用的类："><a href="#说出一些常用的类，包，接口，请各举5个常用的类：" class="headerlink" title="说出一些常用的类，包，接口，请各举5个常用的类："></a>说出一些常用的类，包，接口，请各举5个常用的类：</h1><ul><li>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer；</li><li>常用的包：java.lang java.awt java.io java.util java.sql；</li><li>常用的接口：Remote List Map Document NodeList</li></ul><h1 id="应用服务器与WEB-SERVER的区别："><a href="#应用服务器与WEB-SERVER的区别：" class="headerlink" title="应用服务器与WEB SERVER的区别："></a>应用服务器与WEB SERVER的区别：</h1><ul><li>应用服务器：Weblogic、Tomcat、Jboss； WEB SERVER：IIS、 Apache</li></ul><h1 id="BS与CS的联系与区别："><a href="#BS与CS的联系与区别：" class="headerlink" title="BS与CS的联系与区别："></a>BS与CS的联系与区别：</h1><ul><li>C&#x2F;S是Client&#x2F;Server的缩写</li><li>服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server</li><li>客户端需要安装专用的客户端软件</li><li>B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库</li><li>在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。</li><li>浏览器通过Ｗeb Server 同数据库进行数据交互。</li></ul><h4 id="C-S-与-B-S-区别"><a href="#C-S-与-B-S-区别" class="headerlink" title="C&#x2F;S 与 B&#x2F;S 区别"></a>C&#x2F;S 与 B&#x2F;S 区别</h4><ul><li>硬件环境不同: C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C&#x2F;S更强的适应范围, 一般只要有操作系统和浏览器就行</li><li>对安全要求不同 ：C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C&#x2F;S 结构适宜. 可以通过B&#x2F;S发布部分可公开信息.B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。</li><li>对程序架构不同 ：　C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C&#x2F;S有更高的要求 B&#x2F;S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B&#x2F;S更加成熟.</li><li>软件重用不同： C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性好.　B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。</li><li>系统维护不同 ：C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.</li><li>处理问题不同 ：C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C&#x2F;S无法作到的. 与操作系统平台关系最小.</li><li>用户接口不同： C&#x2F;S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.</li><li>信息流不同 ：　C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B&#x2F;S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心</li></ul><h1 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h1><ul><li>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址</li><li>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</li></ul><h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理</h1><ul><li>Session用于保存每个用户的专用信息</li><li>每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID）</li><li>她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右)</li><li>Session中的信息保存在Web服务器内容中,保存的数据量可大可小</li><li>当 Session超时或被关闭时将自动释放保存的数据信息</li><li>由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低</li><li>对于小量的数据,使用Session对象保存还是一个不错的选择</li><li>Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置</li><li>如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止</li><li>如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期</li><li>Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据</li><li>由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性</li><li>session工作原理<ul><li>当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。</li><li>然后，服务器开辟一块内存，对应于该Session ID。</li><li>服务器再将该Session ID写入浏览器的cookie。</li><li>服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。</li><li>当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。</li><li>然后，服务检查该Session ID所对应的内存是否有效。</li><li>如果有效，就读出内存中的值。</li><li>如果无效，就建立新的Session。</li></ul></li></ul><h1 id="Servlet的生命周期分为3个阶段-和CGI的区别？"><a href="#Servlet的生命周期分为3个阶段-和CGI的区别？" class="headerlink" title="Servlet的生命周期分为3个阶段:?  和CGI的区别？"></a>Servlet的生命周期分为3个阶段:? 和CGI的区别？</h1><ul><li>Servlet的生命周期主要由3个过程组成。<ul><li>init()方法：服务器初始化servlet。</li><li>service()方法：初始化完毕，servlet对象调用该方法响应客户的请求。</li><li>destroy()方法：调用该方法消灭servlet对象。</li></ul></li><li>其中，init()方法只在servlet第一次被请求加载的时候被调用一次，当有客户再请求servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。</li><li>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li></ul><h1 id="浏览器页面与T0MCat的交互过程？"><a href="#浏览器页面与T0MCat的交互过程？" class="headerlink" title="浏览器页面与T0MCat的交互过程？"></a>浏览器页面与T0MCat的交互过程？</h1><ul><li>当一个JSP页面第一次被访问的时候，JSP引擎将执行以下步骤：<ul><li>将JSP页面翻译成一个Servlet，这个Servlet是一个java文件，同时也是一个完整的java程序</li><li>JSP引擎调用java编译器对这个Servlet进行编译，得到可执行文件class</li><li>JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户端</li></ul></li><li>以上三个步骤仅仅在JSP页面第一次被访问时才会执行，以后的访问速度会因为class文件已经生成而大大提高<br>当JSP引擎接到一个客户端的访问请求时，首先判断请求的JSP页面是否比对应的Servlet新，如果新，对应的JSP需要重新编译。</li></ul><h1 id="JSP内置对象作用，如何取Cookie的方法"><a href="#JSP内置对象作用，如何取Cookie的方法" class="headerlink" title="JSP内置对象作用，如何取Cookie的方法"></a>JSP内置对象作用，如何取Cookie的方法</h1><ul><li>使用request对象的getCookies()方法取cookies</li></ul><h1 id="JAVA事件有哪些模式？"><a href="#JAVA事件有哪些模式？" class="headerlink" title="JAVA事件有哪些模式？"></a>JAVA事件有哪些模式？</h1><ul><li>事件直接驱动模式。它的第一个要求就是性能的要求，需要直接而且快，是必须经常使用的，主要适合于迅速处理 前台的命令，往往是系统架构的重要部分，也是流程控制的主要模式。</li><li>监控式事件模式是借助第三者来监控和触发事件，特点是： 有一个观察者置身事外在定期独立运行着。</li></ul><h1 id="uml三要素"><a href="#uml三要素" class="headerlink" title="uml三要素."></a>uml三要素.</h1><ul><li>事物、关系、图</li></ul><h1 id="Session的具体用法？"><a href="#Session的具体用法？" class="headerlink" title="Session的具体用法？"></a>Session的具体用法？</h1><ul><li>Session用来保存每一个用户的专有信息，比如像用户登录验证、购物车。</li></ul><h1 id="请裂举session、cookie、viewstated的应用范围"><a href="#请裂举session、cookie、viewstated的应用范围" class="headerlink" title="请裂举session、cookie、viewstated的应用范围"></a>请裂举session、cookie、viewstated的应用范围</h1><ul><li>Session 服务器端维护， 某个用户活动时间 + 延迟时间（默认20分钟），</li><li>Cookie 客户端维护， 程序可指定生命周期，</li><li>ViewState 小量数据，一个web页面的生命期</li></ul><h1 id="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"><a href="#用什么方法使服务器关闭之后，session所保存的信息不会丢失？" class="headerlink" title="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"></a>用什么方法使服务器关闭之后，session所保存的信息不会丢失？</h1><ul><li>将session信息保存到数据库中或文件中</li></ul><h4 id="写客户端Cookie的方式"><a href="#写客户端Cookie的方式" class="headerlink" title="写客户端Cookie的方式"></a>写客户端Cookie的方式</h4><ul><li>当用户登陆成功以后，把网站域名、用户名、密码、token、session有效时间全部采用cookie的形式写入到客户端的cookie里面</li><li>如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务</li><li>当然，如果cookie过期，或者无效，自然就不让用户继续服务了</li><li>当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？</li></ul><h4 id="服务器之间Session数据同步的方式"><a href="#服务器之间Session数据同步的方式" class="headerlink" title="服务器之间Session数据同步的方式"></a>服务器之间Session数据同步的方式</h4><ul><li>假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了</li><li>缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。</li></ul><h4 id="利用NFS共享Session数据的方式"><a href="#利用NFS共享Session数据的方式" class="headerlink" title="利用NFS共享Session数据的方式"></a>利用NFS共享Session数据的方式</h4><ul><li>其实这个方案和下面的Mysql方案类似，只是存储方式不一样</li><li>大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台NFS服务器上的，不论用户访问那太Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了</li><li>缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。</li></ul><h4 id="利用Mysql数据库共享Session数据的方式"><a href="#利用Mysql数据库共享Session数据的方式" class="headerlink" title="利用Mysql数据库共享Session数据的方式"></a>利用Mysql数据库共享Session数据的方式</h4><ul><li>这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上</li><li>所有Web服务器都来这台Mysql服务器来获取Session数据</li><li>缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql数据的方式。</li></ul><h1 id="使用硬件设备"><a href="#使用硬件设备" class="headerlink" title="使用硬件设备"></a>使用硬件设备</h1><ul><li>这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了</li><li>目前很多门户网站采用这种方式</li><li>缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的。</li></ul><h1 id="过滤器有哪些作用和用法？"><a href="#过滤器有哪些作用和用法？" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h1><ul><li>对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤</li><li>当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联</li><li>如果有，那么容器将把请求交给过滤器进行处理</li><li>在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源</li><li>当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常- 见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。</li><li>和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain</li></ul><h1 id="监听器有哪些作用和用法？"><a href="#监听器有哪些作用和用法？" class="headerlink" title="监听器有哪些作用和用法？"></a>监听器有哪些作用和用法？</h1><ul><li>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：<ul><li>ServletContextListener：对Servlet上下文的创建和销毁进行监听。</li><li>ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。</li><li>HttpSessionListener：对Session的创建和销毁进行监听。补充：session的销毁有两种情况：1session超时（可以在web.xml中通过&lt;session-config&gt;&#x2F;&lt;session-timeout&gt;标签配置超时时间）；2通过调用session对象的invalidate()方法使session失效。</li><li>HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。</li><li>ServletRequestListener：对请求对象的初始化和销毁进行监听。</li><li>ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</li></ul></li></ul><h1 id="实现会话跟踪的技术有哪些？"><a href="#实现会话跟踪的技术有哪些？" class="headerlink" title="实现会话跟踪的技术有哪些？"></a>实现会话跟踪的技术有哪些？</h1><ul><li>由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。</li></ul><h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><ul><li>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</li></ul><h4 id="设置表单隐藏域"><a href="#设置表单隐藏域" class="headerlink" title="设置表单隐藏域"></a>设置表单隐藏域</h4><ul><li>将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。</li><li>这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。</li></ul><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul><li>cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间</li><li>当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份</li><li>会话中可以为用户保存信息</li><li>会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的</li><li>如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪</li><li>当然，在使用cookie时要注意几点<ul><li>首先不要在cookie中存放敏感信息</li><li>其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中</li><li>再者浏览器通常只允许一个站点最多存放20个cookie</li><li>当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。</li></ul></li></ul><h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><ul><li>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的</li><li>当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession</li><li>可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象</li><li>与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能</li><li>添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</li></ul><h1 id="JSP-和Servlet-有有什么关系？"><a href="#JSP-和Servlet-有有什么关系？" class="headerlink" title="JSP 和Servlet 有有什么关系？"></a>JSP 和Servlet 有有什么关系？</h1><ul><li>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容</li><li>JSP本质上是Servlet的一种简易形式， JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成</li><li>Servlet和JSP最主要的不同点在于，Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML分离开来</li><li>而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp 的文件（有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然，这个说法还是很片面的）</li><li>JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</li></ul><h1 id="常用的Web容器"><a href="#常用的Web容器" class="headerlink" title="常用的Web容器"></a>常用的Web容器</h1><ul><li>Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器</li><li>选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等</li><li>下面是对常用服务器的简介：<ul><li>IIS：Microsoft的Web服务器产品为Internet Information Services。IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。</li><li>Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。</li><li>WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要，范围从简单到高级直到企业级。</li><li>WebLogic：BEA WebLogic Server是一种多功能、基于标准的Web应用服务器，为企业构建自己的应用提供了坚实的基础。各种应用开发、部署所有关键性的任务，无论是集成各种系统和数据库，还是提交服务、跨Internet协作，Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发，基于Internet的企业都选择它来开发、部署最佳的应用。BEA WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础，它们以 Internet的容量和速度，在连网的企业之间共享信息、提交服务，实现协作自动化。</li><li>Apache：目前Apache仍然是世界上用得最多的Web服务器，市场占有率约为60%左右。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。</li><li>Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。TomcatServer实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。</li><li>Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</li></ul></li></ul><h1 id="MVC原理"><a href="#MVC原理" class="headerlink" title="MVC原理"></a>MVC原理</h1><ul><li>MVC是一种程序开发设计模式,它实现了显示模块与功能模块的分离</li><li>提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、控制器三层。<ul><li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li><li>视图(view) 用户与之交互的界面、在web中视图一般由jsp,html组成</li><li>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用</li></ul></li></ul><h4 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h4><ul><li>降低代码耦合性。在MVC模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。</li><li>有利于分工合作。在MVC模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。</li><li>有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。</li></ul><h4 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h4><ul><li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li><li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li><li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li><li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/32257fddc744.html" class="post-title-link" itemprop="url">数据库</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:19:45" itemprop="dateCreated datePublished" datetime="2023-12-20T15:19:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-28 14:04:43" itemprop="dateModified" datetime="2023-12-28T14:04:43+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul><li>区别：<ul><li>InnoDB支持事务，MyISAM不支持</li><li>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</li><li>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ul></li><li>如何选择：<ul><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ul></li></ul><h4 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h4><ul><li>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）</li><li>如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</li></ul><h4 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h4><ul><li>插入缓冲（insert buffer）</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h1 id="⾏锁，表锁，乐观锁，悲观锁？"><a href="#⾏锁，表锁，乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁，乐观锁，悲观锁？"></a>⾏锁，表锁，乐观锁，悲观锁？</h1><ul><li>⾏锁：数据库表中某一⾏被锁住。</li><li>表锁：整个数据库表被锁住。</li><li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不不会修改，具体实现是给表增加⼀个版本号的字段，在执行update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。</li><li>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。读数据的时候会上锁，直到update完成才释放锁，使⽤悲观锁要注意不要锁住整个表。</li></ul><h1 id="数据库隔离级别是什什么？有什么作用？"><a href="#数据库隔离级别是什什么？有什么作用？" class="headerlink" title="数据库隔离级别是什什么？有什么作用？"></a>数据库隔离级别是什什么？有什么作用？</h1><ul><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。 这种隔离级别会产⽣生脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外⼀个事务不能读取该 事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了了保证一个事务不能读取另⼀个事务未提交的数据外，还保证了了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理理为顺序执行。除了防止脏读， 不可重复读外，还避免了幻读。</li></ul><h1 id="MySQL主备同步的基本原理理。"><a href="#MySQL主备同步的基本原理理。" class="headerlink" title="MySQL主备同步的基本原理理。"></a>MySQL主备同步的基本原理理。</h1><ul><li>mysql主备复制实现分成三个步骤：<ul><li>master将改变记录到⼆进制⽇志(binary log) 中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</li><li>slave将master的binary log events拷⻉到它的中继日志(relay log) ；</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ul></li></ul><h1 id="select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？"><a href="#select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</h1><ul><li>sql语句句执⾏行行顺序如下：</li><li>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</li></ul><h1 id="如何优化数据库性能"><a href="#如何优化数据库性能" class="headerlink" title="如何优化数据库性能"></a>如何优化数据库性能</h1><ul><li>索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署</li><li>选择合适的数据库引擎，合理使用索引</li><li>分页获取数据，只获取需要的字段</li><li>优化业务逻辑，减少数据库IO</li><li>分库分表</li><li>部署主从数据库</li><li>升级硬件</li></ul><h1 id="SQL什么情况下不会使用索引"><a href="#SQL什么情况下不会使用索引" class="headerlink" title="SQL什么情况下不会使用索引"></a>SQL什么情况下不会使用索引</h1><ul><li>不包含，不等于，函数</li><li>select * 可能导致不走索引；</li><li>空值会导致不走索引，因为hashset不能存空值；</li><li>索引列有函数运算，不走索引，可以在索引列列建⽴立⼀一个函数的索引。</li><li>隐式转换可能导致不走索引；</li><li>表的数据库小或者需要选择大部分数据，不走索引；</li><li>!&#x3D;或者&lt;&gt;可能导致不走索引；</li><li>字符型的索引列列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式</li><li>like ‘%liu’ 百分号在前不走索引；</li><li>not in, not exist不走索引；</li></ul><h1 id="一般在什什么字段上建索引"><a href="#一般在什什么字段上建索引" class="headerlink" title="一般在什什么字段上建索引"></a>一般在什什么字段上建索引</h1><ul><li>过滤数据最多的字段</li><li>表的主键、外键必须有索引；</li><li>数据量量超过300的表应该有索引；</li><li>经常与其他表进行行连接的表，在连接字段上应该建立索引；</li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>如何从一张表中查出name字段不包含”XYZ”的所有行？</li></ul><h1 id="如何解决高并发减库存问题"><a href="#如何解决高并发减库存问题" class="headerlink" title="如何解决高并发减库存问题"></a>如何解决高并发减库存问题</h1><ul><li>消息队列，异步处理，减库存加锁</li></ul><h1 id="数据库事务的几种粒度；"><a href="#数据库事务的几种粒度；" class="headerlink" title="数据库事务的几种粒度；"></a>数据库事务的几种粒度；</h1><ul><li>表锁定：对整个表的锁定。</li><li>行锁定：只锁定进⾏行更改的行，例如：insert，update，delete，都隐式采用行锁定。</li><li>数据库锁机制可分为多种粒度的： 数据库，表，页面，行</li><li>粒度越大，DBMS管理越容易，但是实现并发处理的能力就越差，表，页面，行</li></ul><h1 id="mysql调优"><a href="#mysql调优" class="headerlink" title="mysql调优"></a>mysql调优</h1><ul><li>explain select语句；</li><li>当只要一条数据时使用limit 1；</li><li>为搜索字段建索引；</li><li>避免select *；</li><li>字段尽量使用not null；</li><li>垂直分割；</li><li>拆分大的delete和insert语句：delete和insert会锁表；</li><li>分表分库分区</li></ul><h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><ul><li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li><li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><ul><li>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页</li><li>然后redo log按照时间或者空间等条件进行落盘</li><li>undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了</li><li>此时，事务还未 COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤用undo log进⾏事务回滚</li><li>事务执行COMMIT操作时，会将本事务相关的所有redo log都进⾏落盘，只有所有redo log落盘成功，才算COMMIT成功</li><li>然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发⽣了崩溃，则只使⽤用redo log恢复数据。</li></ul><h1 id="让你设计一个索引，你会怎么设计？"><a href="#让你设计一个索引，你会怎么设计？" class="headerlink" title="让你设计一个索引，你会怎么设计？"></a>让你设计一个索引，你会怎么设计？</h1><ul><li>mysql默认存储引擎innodb只显式支持B树索引</li><li>对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</li></ul><h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><ul><li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。<ul><li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li><li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li></ul></li><li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放<ul><li>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</li></ul></li><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置<ul><li>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销</li><li>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li></ul></li></ul><h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ul><h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul><li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li><li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li></ul><h4 id="哈希索引的优势"><a href="#哈希索引的优势" class="headerlink" title="哈希索引的优势"></a>哈希索引的优势</h4><ul><li>等值查询，哈希索引具有绝对优势</li><li>前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题</li></ul><h4 id="哈希索引不适用的场景"><a href="#哈希索引不适用的场景" class="headerlink" title="哈希索引不适用的场景"></a>哈希索引不适用的场景</h4><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li><li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<ul><li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主</li><li>没有范围查询、没有排序的时候，特别适合采用哈希索引</li><li>仅等值查询<ul><li>select id, name from table where name&#x3D;’李明’;</li></ul></li></ul></li><li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li><li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li><li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li><li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li><li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read&#x2F;write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li></ul><h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li></ul><h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><h4 id="B-的磁盘读写代价更低。"><a href="#B-的磁盘读写代价更低。" class="headerlink" title="B+的磁盘读写代价更低。"></a>B+的磁盘读写代价更低。</h4><ul><li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li><li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多</li><li>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li></ul><h4 id="B-tree的查询效率更加稳定。"><a href="#B-tree的查询效率更加稳定。" class="headerlink" title="B+-tree的查询效率更加稳定。"></a>B+-tree的查询效率更加稳定。</h4><ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引</li><li>所以任何关键字的查找必须走一条从根结点到叶子结点的路</li><li>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><ul><li>联合索引是两个或更多个列上的索引</li><li>对于联合索引Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li><li>例如索引是key index (a,b,c).<ul><li>可以支持a 、 a,b 、 a,b,c 3种组合进行查找</li><li>但不支持 b,c进行查找</li><li>当最左侧字段是常量引用时，索引就十分有效。</li></ul></li><li>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</li><li>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。</li><li>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</li></ul><h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul><li>表记录太少</li><li>经常插入、删除、修改的表</li><li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul><li>表分区是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分</li><li>从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li></ul><h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul><li>分表：指的是通过一定规则，将一张表分解成多张不同的表</li><li>比如将用户订单记录根据时间成多个表。</li><li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li></ul><h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><h4 id="存储更多数据"><a href="#存储更多数据" class="headerlink" title="存储更多数据"></a>存储更多数据</h4><ul><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li><li>和单个磁盘或者文件系统相比，可以存储更多数据</li></ul><h4 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h4><ul><li>在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率</li><li>涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li></ul><h4 id="分区表更容易维护"><a href="#分区表更容易维护" class="headerlink" title="分区表更容易维护"></a>分区表更容易维护</h4><ul><li>例如：想批量删除大量数据可以清除整个分区。</li></ul><h4 id="避免某些特殊的瓶颈"><a href="#避免某些特殊的瓶颈" class="headerlink" title="避免某些特殊的瓶颈"></a>避免某些特殊的瓶颈</h4><ul><li>例如InnoDB的单个索引的互斥访问，ext3文件系统的inode锁竞争等。</li></ul><h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式</li><li>在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><ul><li>命令：show variables like ‘%partition%’ 运行结果:</li><li>mysql&gt; show variables like ‘%partition%’;</li><li>have_partintioning 的值为YES，表示支持分区。</li></ul><h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><ul><li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><ul><li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control)</li><li>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</li><li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</li><li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制</li><li>MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议</li><li>纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li><li>在MVCC并发控制中，读操作可以分成两类：<ul><li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li><li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li></ul></li></ul><h1 id="行级锁定的优缺点"><a href="#行级锁定的优缺点" class="headerlink" title="行级锁定的优缺点"></a>行级锁定的优缺点</h1><h4 id="行级锁定的优点"><a href="#行级锁定的优点" class="headerlink" title="行级锁定的优点"></a>行级锁定的优点</h4><ul><li>当在许多线程中访问不同的行时只存在少量锁定冲突</li><li>回滚时只有少量的更改</li><li>可以长时间锁定单一的行</li></ul><h4 id="行级锁定的缺点"><a href="#行级锁定的缺点" class="headerlink" title="行级锁定的缺点"></a>行级锁定的缺点</h4><ul><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul><li>key 是数据库的物理结构，它包含两层意义和作用<ul><li>一是约束（偏重于约束和规范数据库的结构完整性）</li><li>二是索引（辅助查询用的），包括primary key, unique key, foreign key 等</li></ul></li><li>index是数据库的物理结构<ul><li>它只是辅助查询的</li><li>它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储</li><li>索引要分类的话，分为前缀索引、全文本索引等；</li></ul></li></ul><h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><h4 id="字段名及字段配制合理性"><a href="#字段名及字段配制合理性" class="headerlink" title="字段名及字段配制合理性"></a>字段名及字段配制合理性</h4><ul><li>剔除关系不密切的字段；</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul><h4 id="系统特殊字段处理及建成后建议"><a href="#系统特殊字段处理及建成后建议" class="headerlink" title="系统特殊字段处理及建成后建议"></a>系统特殊字段处理及建成后建议</h4><ul><li>添加删除标记（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul><h4 id="表结构合理性配置"><a href="#表结构合理性配置" class="headerlink" title="表结构合理性配置"></a>表结构合理性配置</h4><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><h4 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h4><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul><h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><h4 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF"></a>第一范式（1NF</h4><ul><li>字段具有原子性,不可再分</li><li>所有关系型数据库系统都满足第一范式</li><li>数据库表中的字段都是单一属性的，不可再分</li></ul><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><ul><li>是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）</li><li>要求数据库表中的每个实例或行必须可以被惟一地区分</li><li>通常需要为表加上一个列，以存储各个实例的惟一标识</li><li>这个惟一属性列被称为主关键字或主键。</li></ul><h4 id="满足第三范式（3NF）"><a href="#满足第三范式（3NF）" class="headerlink" title="满足第三范式（3NF）"></a>满足第三范式（3NF）</h4><ul><li>必须先满足第二范式（2NF）</li><li>简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</li><li>所以第三范式具有如下特征<ul><li>每一列只有一个值</li><li>每一行都能区分</li><li>每一个表都不包含其他表已经包含的非主关键字信息。</li></ul></li></ul><h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><ul><li>用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</li><li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</li><li>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等</li><li>UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL</li><li>UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同<ul><li>对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录</li><li>对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</li></ul></li></ul><h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><ul><li>普通索引: 即针对数据库表创建索引</li><li>唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值</li><li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li><li>组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li></ul><h1 id="在mysql数据库中索引的工作机制是什么？"><a href="#在mysql数据库中索引的工作机制是什么？" class="headerlink" title="在mysql数据库中索引的工作机制是什么？"></a>在mysql数据库中索引的工作机制是什么？</h1><ul><li>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据</li><li>索引的实现通常使用B树及其变种B+树</li></ul><h1 id="MySQL的基础操作命令"><a href="#MySQL的基础操作命令" class="headerlink" title="MySQL的基础操作命令"></a>MySQL的基础操作命令</h1><ul><li>MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status</li><li>开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务</li><li>Shell 登入 MySQL: 运行命令 mysql -u root -p</li><li>列出所有数据库:运行命令 show databases;</li><li>切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库</li><li>列出某个数据库内所有表: show tables;</li><li>获取表内所有 Field 对象的名称和类型 :describe table_name;</li></ul><h1 id="mysql的复制原理以及流程"><a href="#mysql的复制原理以及流程" class="headerlink" title="mysql的复制原理以及流程"></a>mysql的复制原理以及流程</h1><ul><li>Mysql内建的复制功能是构建大型，高性能应用程序的基础</li><li>将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的</li><li>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器</li><li>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环</li><li>这些日志可以记录发送到从服务器的更新</li><li>当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置</li><li>从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新</li><li>过程如下<ul><li>主服务器把更新记录到二进制日志文件中</li><li>从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中</li><li>从服务器重做中继日志中的时间，把更新应用到自己的数据库上</li></ul></li></ul><h1 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型?"></a>mysql支持的复制类型?</h1><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><ul><li>在主服务器上执行的SQL语句，在从服务器上执行同样的语句</li><li>MySQL默认采用基于语句的复制，效率比较高</li><li>一旦发现没法精确复制时，会自动选着基于行的复制。</li></ul><h4 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h4><ul><li>把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持</li></ul><h4 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h4><ul><li>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</li></ul><h1 id="mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？"><a href="#mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？" class="headerlink" title="mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？"></a>mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</h1><ul><li>varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.</li><li>varchar(50)中50的涵义 : 最多存放50个字节</li><li>int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</li></ul><h1 id="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h1><ul><li>如果字段里面有大字段（text,blob）类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了</li><li>MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多</li><li>此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率</li><li>当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的</li><li>拆分开后，对字段的UPDAE就要UPDATE多个表了</li></ul><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</h1><ul><li>InnoDB行锁是通过给索引上的索引项加锁来实现的</li><li>这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的</li><li>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li></ul><h1 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</h1><ul><li>由于utf8的每个字符最多占用3个字节</li><li>而MySQL定义行的长度不能超过65535</li><li>因此N的最大值计算方法为：(65535-1-2)&#x2F;3</li><li>减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</li></ul><h1 id="SELECT-和SELECT-全部字段的2种写法有何优缺点"><a href="#SELECT-和SELECT-全部字段的2种写法有何优缺点" class="headerlink" title="SELECT * 和SELECT 全部字段的2种写法有何优缺点?"></a>SELECT * 和SELECT 全部字段的2种写法有何优缺点?</h1><ul><li>前者要解析数据字典，后者不需要</li><li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li><li>表字段改名，前者不需要修改，后者需要改</li><li>后者可以建立索引进行优化，前者无法优化</li><li>后者的可读性比前者要高</li></ul><h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><ul><li>语法上：where 用表中列名，having用select结果别名</li><li>影响结果范围：where从表读出数据的行数，having返回客户端的行数</li><li>索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作</li><li>where后面不能使用聚集函数，having是专门使用聚集函数的。</li></ul><h1 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h1><ul><li>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c&#x3D;c+1;</li></ul><h1 id="MySQL的insert和update的select语句语法"><a href="#MySQL的insert和update的select语句语法" class="headerlink" title="MySQL的insert和update的select语句语法"></a>MySQL的insert和update的select语句语法</h1><ul><li>insert into student (stuid,stuname,deptid) select 10,’xzm’,3 from student where stuid &gt; 8;</li><li>update student a inner join student b on b.stuID&#x3D;10 set a.stuname&#x3D;concat(b.stuname, b.stuID) where a.stuID&#x3D;10 ;</li></ul><h1 id="Mysql-中有哪几种锁？"><a href="#Mysql-中有哪几种锁？" class="headerlink" title="Mysql 中有哪几种锁？"></a>Mysql 中有哪几种锁？</h1><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低， 并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和 行锁之间，并发度一般。</li></ul><h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><ul><li>共有 5 种类型的表格：<ul><li>MyISAM</li><li>Heap</li><li>Merge</li><li>INNODB</li><li>ISAM</li></ul></li></ul><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul><li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li><li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li></ul><h1 id="myisamchk-是用来做什么的？"><a href="#myisamchk-是用来做什么的？" class="headerlink" title="myisamchk 是用来做什么的？"></a>myisamchk 是用来做什么的？</h1><ul><li>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。</li></ul><h1 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h1><ul><li>在 MyISAM Static 上的所有字段有固定宽度</li><li>动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。</li><li>MyISAM Static 在受损情况下更容易恢复。</li></ul><h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><ul><li>每当行被更改时，时间戳字段将获取当前时间戳。</li></ul><h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><ul><li>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</li></ul><h1 id="数据库架构原则"><a href="#数据库架构原则" class="headerlink" title="数据库架构原则"></a>数据库架构原则</h1><ul><li>高可用</li><li>高性能</li><li>一致性</li><li>扩展性</li></ul><h1 id="常见的数据库架构方案"><a href="#常见的数据库架构方案" class="headerlink" title="常见的数据库架构方案"></a>常见的数据库架构方案</h1><h4 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h4><ul><li>只有主库提供读写服务，备库冗余作故障转移用</li><li>高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写都操作主库，很容易产生瓶颈</li><li>大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能</li><li>另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 </li><li>一致性分析：读写都操作主库，不存在数据一致性问题。 </li><li>扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案</li><li>第二，扩展性差，这点可以通过分库分表来扩展。</li></ul></li></ul><h4 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h4><ul><li>两个主库同时提供服务，负载均衡</li><li>高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写性能相比于方案一都得到提升，提升一倍。</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）</li><li>如果非得在数据库架构层面扩展的话，扩展为方案四。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。</li></ul></li></ul><h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><ul><li>一主多从，读写分离</li><li>高可用分析：主库单点，从库高可用</li><li>一旦主库挂了，写服务也就无法提供。 </li><li>高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能</li><li>读的性能提高了，整体性能也提高了。</li><li>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引</li><li>线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。</li><li>带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长）</li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主库单点问题，笔者暂时没想到很好的解决方案。</li></ul></li><li>思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？</li></ul><h4 id="双主-主从架构"><a href="#双主-主从架构" class="headerlink" title="双主+主从架构"></a>双主+主从架构</h4><ul><li>看似完美的方案</li><li>高可用分析：高可用。 </li><li>高性能分析：高性能。 </li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案 。</li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） </li><li>可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。</li></ul><h1 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h1><h4 id="主库和从库一致性解决方案"><a href="#主库和从库一致性解决方案" class="headerlink" title="主库和从库一致性解决方案"></a>主库和从库一致性解决方案</h4><ul><li>数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的</li><li>这个同步时间内主库和从库的数据会存在不一致的情况</li><li>如果同步过程中有读请求，那么读到的就是从库中的老数据。</li><li>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<ul><li>直接忽略，如果业务允许延时存在，那么就不去管它。 </li><li>强制读主，采用主备架构方案，读写都走主库</li><li>用缓存来扩展数据库读性能</li><li>有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</li></ul></li><li>选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。</li><li>读请求时，同样的方式生成key先去查Cache，再判断是否命中</li><li>若命中，则读主库，否则读从库</li><li>代价是多了一次缓存读写，基本可以忽略。</li><li>半同步复制，等主从同步完成，写请求才返回</li><li>就是大家常说的“半同步复制”semi-sync</li><li>这可以利用数据库原生功能，实现比较简单</li><li>代价是写请求时延增长，吞吐量降低。 </li><li>数据库中间件，引入开源（mycat等）或自研的数据库中间层</li><li>个人理解，思路同选择读主</li><li>数据库中间件的成本比较高，并且还多引入了一层</li></ul><h4 id="DB和缓存一致性解决方案"><a href="#DB和缓存一致性解决方案" class="headerlink" title="DB和缓存一致性解决方案"></a>DB和缓存一致性解决方案</h4><ul><li>先来看一下常用的缓存使用方式：<ul><li>第一步：淘汰缓存；</li><li>第二步：写入数据库；</li><li>第三步：读取缓存？返回：读取数据库；</li><li>第四步：读取数据库后写入缓存。</li></ul></li><li>注：如果按照这种方式，不会产生DB和缓存不一致问题，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据</li><li>设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！</li><li>加缓存和索引是通用的提升数据库性能的方式； </li><li>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。</li><li>阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。</li></ul><p> </p><h1 id="主从数据库不一致如何解决"><a href="#主从数据库不一致如何解决" class="headerlink" title="主从数据库不一致如何解决"></a>主从数据库不一致如何解决</h1><ul><li>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</li><li>忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</li><li>强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</li><li>选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</li></ul><h1 id="说出数据连接池的工作机制是什么"><a href="#说出数据连接池的工作机制是什么" class="headerlink" title="说出数据连接池的工作机制是什么?"></a>说出数据连接池的工作机制是什么?</h1><ul><li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接</li><li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙</li><li>如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定</li><li>当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</li></ul><h1 id="数据库创建索引的缺点？"><a href="#数据库创建索引的缺点？" class="headerlink" title="数据库创建索引的缺点？"></a>数据库创建索引的缺点？</h1><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h1 id="说一下数据库的存储过程？"><a href="#说一下数据库的存储过程？" class="headerlink" title="说一下数据库的存储过程？"></a>说一下数据库的存储过程？</h1><ul><li>存储过程与函数的区别：<ul><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。</li><li>对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。</li><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。</li></ul></li><li>存储过程的优点：<ul><li>执行速度更快 – 在数据库中保存的存储过程语句都是编译过的</li><li>允许模块化程序设计 – 类似方法的复用</li><li>提高系统安全性 – 防止SQL注入</li><li>减少网络流通量 – 只要传输存储过程的名称</li></ul></li><li>系统存储过程一般以sp开头，用户自定义的存储过程一般以usp开头</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/4a23c7da79c0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/4a23c7da79c0.html" class="post-title-link" itemprop="url">Spring cloud</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:16:45" itemprop="dateCreated datePublished" datetime="2023-12-20T15:16:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-28 12:32:01" itemprop="dateModified" datetime="2023-12-28T12:32:01+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring-cloud/" itemprop="url" rel="index"><span itemprop="name">Spring cloud</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.9k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h1><ul><li>Spring Cloud 是一个基于 Spring Boot 的开发工具集</li><li>专为构建微服务架构而设计</li><li>它提供了一系列的工具和框架，使开发、部署和维护微服务变得更加简单和高效</li></ul><h1 id="Spring-Cloud-的一些核心概念"><a href="#Spring-Cloud-的一些核心概念" class="headerlink" title="Spring Cloud 的一些核心概念"></a>Spring Cloud 的一些核心概念</h1><ul><li>配置管理: Spring Cloud 提供工具来统一管理和维护在多个环境中的微服务配置，如开发、测试和生产环境。</li><li>服务发现: 它集成了服务发现服务器，如 Eureka，使得微服务可以自动注册自己并发现其他服务。</li><li>负载均衡: 通过集成 Ribbon 和其他工具，Spring Cloud 提供客户端侧的负载均衡，帮助分发请求到不同的实例。</li><li>断路器: 通过 Hystrix，Spring Cloud 提供了断路器模式，以确保在某个服务出现问题时，不会导致整个系统的崩溃。</li><li>API 网关: 通过 Zuul，Spring Cloud 提供了API网关解决方案，用于请求路由、过滤和负载均衡。</li><li>分布式跟踪: Spring Cloud 集成了 Zipkin 和 Sleuth，为微服务架构提供分布式日志追踪。</li><li>分布式数据管理: 提供了工具来处理在微服务架构中的数据一致性和分布式事务问题。</li><li>集成和适配: Spring Cloud 与许多常见的云平台和服务深度集成，例如 AWS、GCP 和 Azure，使得部署和管理微服务更加简单。</li></ul><h1 id="使用Spring-Cloud有什么优势"><a href="#使用Spring-Cloud有什么优势" class="headerlink" title="使用Spring Cloud有什么优势"></a>使用Spring Cloud有什么优势</h1><ul><li>耦合度比较低。不会影响其他模块的开发</li><li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</li><li>配置比较简单，基本用注解就能实现，不用使用过多的配置文件</li><li>微服务跨平台的，可以用任何一种语言开发</li><li>每个微服务可以有自己的独立的数据库也有用公共的数据库</li><li>直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</li></ul><h1 id="服务注册和发现是什么意思？Spring-Cloud如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud如何实现？"></a>服务注册和发现是什么意思？Spring Cloud如何实现？</h1><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><ul><li>服务注册：将服务实例的信息注册到服务注册中心</li><li>在微服务架构中，每个服务都是独立运行的，需要通过服务注册中心来管理和调用</li><li>服务注册中心是一个集中的服务实例的注册和发现的地方</li><li>当一个服务实例启动时，它会向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号等</li><li>其他服务可以通过服务注册中心查询到需要调用的服务的信息，从而实现服务之间的通信</li><li>Spring Cloud提供了多个服务注册中心的实现，如Eureka、Consul和Zookeeper，其中，Eureka是Spring Cloud的默认选择</li><li>每个服务实例在启动时，会向Eureka服务器注册自己的信息</li><li>Eureka服务器会维护一个服务注册表，用于保存所有已注册的服务实例信息</li><li>其他服务可以通过查询服务注册表来获取需要调用的服务的相关信息</li><li>服务注册的优势在于解耦了服务之间的直接依赖关系，使得服务之间可以动态地发现和调用</li><li>通过服务注册，可以实现服务的高可用性和负载均衡，当某个服务实例不可用时，可以自动剔除或替换，从而保证整个系统的稳定性和可靠性</li><li>同时，服务注册还能提供服务的版本管理、动态扩缩容等功能，为微服务架构带来更大的灵活性和可扩展性</li></ul><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul><li>服务发现是指在微服务架构中，通过服务注册中心来查询和发现可用的服务实例</li><li>在传统的单体应用中，服务的调用通常是通过硬编码的方式实现的，而在微服务架构中，由于服务实例的数量和位置可能会动态变化，因此需要一种机制来动态地发现和调用服务</li><li>Spring Cloud提供了多个服务发现的实现，例如Eureka、Consul和Zookeeper</li><li>服务发现的基本流程如下<ul><li>服务注册：当一个服务实例启动时，它会向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号等。注册后，服务注册中心会维护一个服务注册表，记录所有已注册的服务实例</li><li>服务查询：当需要调用某个服务时，服务消费者可以通过服务注册中心查询到该服务的可用实例信息。服务消费者可以根据需要的负载均衡策略，选择一个合适的服务实例进行调用。</li><li>服务调用：服务消费者通过获取到的服务实例信息，可以直接向服务提供者发送请求，进行服务调用。服务消费者可以通过负载均衡、容错机制等手段，提高系统的可用性和稳定性。</li></ul></li></ul><h1 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h1><ul><li>负载平衡的作用<ul><li>提高系统性能：通过将请求分发到多个服务器上，负载平衡可以避免单一服务器的过载情况，从而提高系统的整体吞吐量和响应速度。</li><li>增加系统可靠性：当某个服务器发生故障或不可用时，负载平衡可以将请求转发到其他正常工作的服务器上，确保系统的可用性和稳定性。</li><li>实现扩展性：负载平衡可以根据实际需求，添加或移除服务器，以适应流量的增加或减少，从而实现系统的弹性扩展。</li><li>实现会话保持：负载平衡可以确保同一个用户的连续请求都被转发到同一个服务器上，以保持用户会话的状态。</li></ul></li><li>常见的负载平衡算法有轮询、随机、最少连接等<ul><li>轮询算法是将请求按照顺序依次分发到每个服务器上</li><li>随机算法是随机选择一个服务器来处理请求</li><li>最少连接算法是将请求分发到当前连接数最少的服务器上</li></ul></li><li>负载平衡可以通过硬件设备（如负载均衡器）或软件方式实现，常用的软件负载均衡工具有Nginx、HAProxy、SpringCloud的Ribbon等。这些工具可以根据实际需求和场景选择，以提供高效的负载平衡服务。</li></ul><h1 id="什么是Hystrix？它如何实现容错？"><a href="#什么是Hystrix？它如何实现容错？" class="headerlink" title="什么是Hystrix？它如何实现容错？"></a>什么是Hystrix？它如何实现容错？</h1><ul><li>hystrix是Netlifx开源的一款容错框架，防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控(Hystrix Dashboard)等功能</li></ul><h4 id="hystrix被设计的目标"><a href="#hystrix被设计的目标" class="headerlink" title="hystrix被设计的目标"></a>hystrix被设计的目标</h4><ul><li>对通过第三方客户端库访问的依赖项（通常是通过网络）的延迟和故障进行保护和控制。</li><li>在复杂的分布式系统汇中阻止级联故障。</li><li>快速失败，快速恢复。</li><li>回退，尽可能优雅的降级。</li><li>启用近实时监控、警报和操作控制。</li></ul><h4 id="Hystrix使用场景"><a href="#Hystrix使用场景" class="headerlink" title="Hystrix使用场景"></a>Hystrix使用场景</h4><ul><li>调用超时时间比你自己定义的阈值要长。</li><li>线程池满了，该以来应该立即拒绝请求，而不是排队</li><li>在一段时间内，如果服务的错误百分比超过了一个阈值，就会触发一个断路器来停止对特定服务的所有请求，无论是手动还是自动的</li></ul><h4 id="Hystrix如何解决依赖隔离"><a href="#Hystrix如何解决依赖隔离" class="headerlink" title="Hystrix如何解决依赖隔离"></a>Hystrix如何解决依赖隔离</h4><ul><li>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中&#x2F;信号授权下执行。</li><li>可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</li><li>为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</li><li>依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</li><li>提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</li><li>提供近实时依赖的统计和监控</li></ul><h1 id="什么是Netflix-Feign？它的优点是什么？"><a href="#什么是Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是Netflix Feign？它的优点是什么？"></a>什么是Netflix Feign？它的优点是什么？</h1><h4 id="Feign是什么"><a href="#Feign是什么" class="headerlink" title="Feign是什么"></a>Feign是什么</h4><ul><li>Feign 是 Spring Cloud Netflix 组件中的一个轻量级 RESTful 的 HTTP 服务客户端</li><li>实现了负载均衡和 Rest 调用的开源框架</li><li>封装了 Ribbon 和 RestTemplate</li><li>实现了 WebService的面向接口编程，进一步降低了项目的耦合度</li><li>Feign 内置了 Ribbon，用来做客户端负载均衡调用服务注册中心的服务</li><li>Feign 本身并不支持 Spring MVC 的注解，它有一套自己的注解，为了更方便的使用，Spring Cloud 孵化了 OpenFeign</li><li>Feign 是一种声明式、模板化的 HTTP 客户端（仅在 Consumer 中使用）</li><li>Feign 的使用方式是：使用 Feign 的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。</li></ul><h4 id="Feign解决了什么问题"><a href="#Feign解决了什么问题" class="headerlink" title="Feign解决了什么问题"></a>Feign解决了什么问题</h4><ul><li>Feign 旨在使编写 JAVA HTTP 客户端变得更加容易</li><li>Feign 简化了 RestTemplate 代码，实现了 Ribbon负载均衡，使代码变得更加简洁，也少了客户端调用的代码，使用 Feign 实现负载均衡是首选方案</li><li>只需要你创建一个接口，然后在上面添加注解即可</li><li>Feign 是声明式服务调用组件，其核心就是：像调用本地方法一样调用远程方法，无感知远程 HTTP 请求</li><li>它解决了让开发者调用远程接口就跟调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP请求</li><li>无需关注与远程的交互细节，更无需关注分布式环境开发</li><li>它像 Dubbo 一样，Consumer 直接调用 Provider 接口方法，而不需要通过常规的 Http Client 构造请求再解析返回数据</li></ul><h1 id="什么是Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是Spring Cloud Bus？我们需要它吗？"></a>什么是Spring Cloud Bus？我们需要它吗？</h1><h4 id="什么是Spring-Cloud-Bus"><a href="#什么是Spring-Cloud-Bus" class="headerlink" title="什么是Spring Cloud Bus"></a>什么是Spring Cloud Bus</h4><ul><li>Spring Cloud Bus是Spring Cloud提供的一种用于实现分布式系统中消息传递和事件驱动的组件</li><li>Spring Cloud Bus是基于消息代理的分布式系统消息总线</li><li>它利用轻量级消息代理来连接各个分布式节点，实现节点之间的消息传递和事件驱动</li><li>Spring Cloud Bus的核心思想是通过消息广播机制，使得一次配置更新可以触发所有相关节点的配置刷新，从而实现分布式系统的配置管理和动态更新</li><li>通过消息广播机制和消息代理，它可以实现配置的动态刷新、事件的传递和驱动，以及系统的监控与管理</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>引入依赖：在项目的pom.xml文件中添加Spring Cloud Bus相关的依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>配置消息代理：在Spring Cloud配置文件中配置消息代理的地址和相关参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure></li><li>注册消息总线端点：在Spring Boot应用程序中注册消息总线的端点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@RestController</span><br><span class="line">public class MyApp &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RefreshEndpoint refreshEndpoint;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/refresh&quot;)</span><br><span class="line">    public void refresh() &#123;</span><br><span class="line">        refreshEndpoint.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>刷新配置：通过发送POST请求到消息总线端点来触发配置的刷新<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">restTemplate.postForObject(&quot;http://localhost:8080/refresh&quot;, null, Void.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Spring-Cloud-Bus的核心组件"><a href="#Spring-Cloud-Bus的核心组件" class="headerlink" title="Spring Cloud Bus的核心组件"></a>Spring Cloud Bus的核心组件</h4><ul><li>消息代理：用于转发消息和事件的中间件，如RabbitMQ、Kafka等。</li><li>消息总线：通过消息代理将消息广播给所有相关节点。</li><li>消息生成器：用于生成和发送消息的组件。</li><li>消息接收器：用于接收和处理消息的组件。</li></ul><h4 id="Spring-Cloud-Bus的作用"><a href="#Spring-Cloud-Bus的作用" class="headerlink" title="Spring Cloud Bus的作用"></a>Spring Cloud Bus的作用</h4><ul><li>配置刷新：通过消息广播机制，实现配置的动态刷新，避免了每个节点都需要手动刷新配置的问题</li><li>事件驱动：通过消息代理的发布-订阅模式，实现事件的传递和驱动，使得各个节点能够响应和处理特定的事件</li><li>监控与管理：可以通过消息总线来收集系统的监控数据和指标，实现分布式系统的集中管理和监控</li></ul><h1 id="Spring-Cloud-19个技术"><a href="#Spring-Cloud-19个技术" class="headerlink" title="Spring Cloud 19个技术"></a>Spring Cloud 19个技术</h1><ul><li>Spring Cloud Config 配置中心，利用git集中管理程序的配置。</li><li>Spring Cloud Netflix 集成众多Netflix的开源软件</li><li>Spring Cloud Bus 消息总线，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化</li><li>Spring Cloud for Cloud Foundry 利用Pivotal Cloudfoundry集成你的应用程序</li><li>Spring Cloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。</li><li>Spring Cloud Cluster 基于Zookeeper, Redis, Hazelcast, Consul实现的领导选举和平民状态模式的抽象和实现。</li><li>Spring Cloud Consul 基于Hashicorp Consul实现的服务发现和配置管理。</li><li>Spring Cloud Security 在Zuul代理中为OAuth2 rest客户端和认证头转发提供负载均衡</li><li>Spring Cloud Sleuth SpringCloud应用的分布式追踪系统，和Zipkin，HTrace，ELK兼容。</li><li>Spring Cloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。</li><li>Spring Cloud Stream 基于Redis,Rabbit,Kafka实现的消息微服务，简单声明模型用以在Spring Cloud应用中收发消息。</li><li>Spring Cloud Stream App Starters 基于Spring Boot为外部系统提供spring的集成</li><li>Spring Cloud Task 短生命周期的微服务，为SpringBooot应用简单声明添加功能和非功能特性。</li><li>Spring Cloud Task App Starters</li><li>Spring Cloud Zookeeper 服务发现和配置管理基于Apache Zookeeper。</li><li>Spring Cloud for Amazon Web Services 快速和亚马逊网络服务集成。</li><li>Spring Cloud Connectors 便于PaaS应用在各种平台上连接到后端像数据库和消息经纪服务。</li><li>Spring Cloud Starters （项目已经终止并且在Angel.SR2后的版本和其他项目合并）</li><li>Spring Cloud CLI 插件用Groovy快速的创建Spring Cloud组件应用。</li><li>Spring Cloud共集成了19个子项目，里面都包含一个或者多个第三方的组件或者框架！</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/8270315bab4b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/8270315bab4b.html" class="post-title-link" itemprop="url">Java虚拟机（JVM）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:08:40 / 修改时间：15:09:12" itemprop="dateCreated datePublished" datetime="2023-12-20T15:08:40+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="gc概述"><a href="#gc概述" class="headerlink" title="gc概述"></a>gc概述</h1><ul><li>垃圾收集机制是指jvm用于释放那些不再使用的对象所占用的内存</li><li>java语言并不要求jvm有gc，也没有规定gc如何工作</li><li>不过常用的jvm都有gc，而且大多数gc都使用类似的算法管理内存和执行收集操作</li><li>垃圾收集的目的在于清除不再使用的对象</li><li>gc通过确定对象是否被活动对象引用来确定是否收集该对象</li><li>gc首先要判断该对象是否是时候可以收集，两种常用的方法是引用计数和对象引用遍历<ul><li>引用计数<ul><li>引用计数存储对特定对象的所有引用数</li><li>当应用程序创建引用以及引用超出范围时，jvm必须适当增减引用数</li><li>当某对象的引用数为0时，便可以进行垃圾收集</li></ul></li><li>对象引用遍历<ul><li>早期的jvm使用引用计数，现在大多数jvm采用对象引用遍历</li><li>对象引用遍历从一组对象（GC ROOT）开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象</li><li>如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集</li><li>在对象遍历阶段，gc必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象</li><li>下一步，gc要删除不可到达的对象</li><li>删除时，有些gc只是简单的扫描堆栈，删除未标记的对象，并释放它们的内存以生成新的对象，这叫做清除（sweeping）</li><li>这种方法的问题在于内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大</li><li>因此，许多gc可以重新组织内存中的对象，并进行压缩（compact），形成可利用的空间</li><li>为此，gc需要停止其他的活动活动，这种方法意味着所有与应用程序相关的工作停止，只有gc运行，结果，在响应期间增减了许多混杂请求</li><li>另外，更复杂的gc不断增加或同时运行以减少或者清除应用程序的中断，有的gc使用单线程完成这项工作，有的则采用多线程以增加效率。</li><li>java中可作为GC Root的对象有<ul><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native对象）</li></ul></li></ul></li></ul></li><li>有3个内存区域是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。</li></ul><h1 id="几种垃圾回收机制"><a href="#几种垃圾回收机制" class="headerlink" title="几种垃圾回收机制"></a>几种垃圾回收机制</h1><h4 id="标记-清除收集器"><a href="#标记-清除收集器" class="headerlink" title="标记-清除收集器"></a>标记-清除收集器</h4><ul><li>这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存</li><li>这种收集器一般使用单线程工作并停止其他操作</li><li>标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片</li></ul><h4 id="标记-压缩收集器"><a href="#标记-压缩收集器" class="headerlink" title="标记-压缩收集器"></a>标记-压缩收集器</h4><ul><li>有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段</li><li>在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈</li><li>这种收集器也停止其他操作</li><li>由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。（该算法适用于旧生代）</li></ul><h4 id="复制收集器"><a href="#复制收集器" class="headerlink" title="复制收集器"></a>复制收集器</h4><ul><li>这种收集器将堆栈分为两个域，常称为半空间</li><li>每次仅使用一半的空间，jvm生成的新对象则放在另一半空间中</li><li>gc运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈</li><li>这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低</li><li>复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域</li><li>当存活的对象较少时，复制算法会比较高效（新生代的Eden区就是采用这种算法），其带来的成本是需要一块额外的空闲空间和对象的移动</li></ul><h4 id="增量收集器"><a href="#增量收集器" class="headerlink" title="增量收集器"></a>增量收集器</h4><ul><li>增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾</li><li>这会造成较小的应用程序中断</li></ul><h4 id="分代收集器"><a href="#分代收集器" class="headerlink" title="分代收集器"></a>分代收集器</h4><ul><li>这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象</li><li>jvm生成的新对象一般放在其中的某个域中，过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中</li><li>分代收集器对不同的域使用不同的算法以优化性能</li></ul><h4 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h4><ul><li>并发收集器与应用程序同时运行</li><li>这些收集器在某点上（比如压缩时）一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低</li></ul><h4 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h4><ul><li>并行收集器使用某种传统的算法并使用多线程并行的执行它们的工作</li><li>在多cpu机器上使用多线程技术可以显著的提高java应用程序的可扩展性</li></ul><h1 id="Sun-HotSpot"><a href="#Sun-HotSpot" class="headerlink" title="Sun HotSpot"></a>Sun HotSpot</h1><ul><li>Sun HotSpot 使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域</li><li>Jvm生成的所有新对象放在新域中</li><li>一旦对象经历了一定数量的垃圾收集循环后，便获得使用期并进入旧域</li><li>在永久域中jvm则存储class和method对象</li><li>就配置而言，永久域是一个独立域并且不认为是堆的一部分</li><li>可使用-Xms和-Xmx 控制整个堆的原始大小或最大值</li><li>默认状态下，HotSpot在新域中使用复制收集器，该域一般分为三个部分<ul><li>第一部分为Eden，用于生成新的对象</li><li>另两部分称为救助空间，当Eden充满时，收集器停止应用程序，把所有可到达对象复制到当前的from救助空间，一旦当前的from救助空间充满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们获得使用期并转入旧域</li></ul></li><li>默认状态下HotSpot对新域使用复制收集器，对旧域使用标记－清除－压缩收集器</li><li>在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。如果能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价</li></ul><h1 id="如何从JVM中获取信息来进行调整"><a href="#如何从JVM中获取信息来进行调整" class="headerlink" title="如何从JVM中获取信息来进行调整"></a>如何从JVM中获取信息来进行调整</h1><ul><li>-verbose.gc开关可显示gc的操作内容。打开它，可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等。</li><li>打开-xx：+ printgcdetails开关，可以详细了解gc中的变化</li><li>打开-XX： + PrintGCTimeStamps开关，可以了解这些垃圾收集发生的时间，自jvm启动以后以秒计量</li><li>通过-xx： + PrintHeapAtGC开关了解堆的更详细的信息</li><li>为了了解新域的情况，可以通过-XX：&#x3D;PrintTenuringDistribution开关了解获得使用期的对象权。</li></ul><h1 id="查看配置JVM内存信息"><a href="#查看配置JVM内存信息" class="headerlink" title="查看配置JVM内存信息"></a>查看配置JVM内存信息</h1><ul><li>Runtime.getRuntime().maxMemory();&#x2F;&#x2F;最大可用内存，对应-Xmx</li><li>Runtime.getRuntime().freeMemory();&#x2F;&#x2F;当前JVM空闲内存</li><li>Runtime.getRuntime().totalMemory();&#x2F;&#x2F;当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和</li></ul><h4 id="关于maxMemory-，freeMemory-和totalMemory-："><a href="#关于maxMemory-，freeMemory-和totalMemory-：" class="headerlink" title="关于maxMemory()，freeMemory()和totalMemory()："></a>关于maxMemory()，freeMemory()和totalMemory()：</h4><ul><li>maxMemory()为JVM的最大可用内存，可通过-Xmx设置，默认值为物理内存的1&#x2F;4，设值不能高于计算机物理内存；</li><li>totalMemory()为当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和，会随着JVM使用内存的增加而增加；</li><li>freeMemory()为当前JVM空闲内存，因为JVM只有在需要内存时才占用物理内存使用，所以freeMemory()的值一般情况下都很小，而JVM实际可用内存并不等于freeMemory()，而应该等于maxMemory()-totalMemory()+freeMemory()。及其配置JVM内存分配。</li></ul><h1 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h1><ul><li>JVM的新生代、老年代、MinorGC、MajorGC</li><li>JVM中的堆，一般分为三大部分：新生代、老年代、永久代</li></ul><h4 id="新生代（Youn-Generation）"><a href="#新生代（Youn-Generation）" class="headerlink" title="新生代（Youn Generation）"></a>新生代（Youn Generation）</h4><ul><li>主要是用来存放新生的对象</li><li>一般占据堆的1&#x2F;3空间</li><li>由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收</li><li>新生代又分为 Eden区、ServivorFrom、ServivorTo三个区<ul><li>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收</li><li>ServivorTo：保留了一次MinorGC过程中的幸存者</li><li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者</li></ul></li><li>当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。</li><li>MinorGC的过程：采用复制算法<ul><li>首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则赋值到老年代区）</li><li>同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）</li><li>然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</li></ul></li><li>新建的对象都是从新生代分配内存，Eden区不足的时候，会把存活的对象转移到Survivor区</li></ul><h4 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h4><ul><li>老年代的对象比较稳定，所以MajorGC不会频繁执行</li><li>在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发</li><li>当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间</li><li>MajorGC采用标记—清除算法：<ul><li>首先扫描一次所有老年代，标记出存活的对象</li><li>然后回收没有标记的对象</li></ul></li><li>MajorGC的耗时比较长，因为要扫描再回收</li><li>MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配</li><li>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常</li><li>旧生代用于存放新生代多次回收依然存活的对象，如缓存对象。当旧生代满了的时候就需要对旧生代进行回收，旧生代的垃圾回收称作Major GC</li></ul><h4 id="永久代（Permanent-Generation）"><a href="#永久代（Permanent-Generation）" class="headerlink" title="永久代（Permanent Generation）"></a>永久代（Permanent Generation）</h4><ul><li>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息</li><li>Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常</li><li>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现</li><li>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</li><li>类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中</li><li>这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制</li><li>在Sun 的JVM中就是方法区的意思，尽管大多数JVM没有这一代</li></ul><h4 id="Major-GC和Full-GC区别"><a href="#Major-GC和Full-GC区别" class="headerlink" title="Major GC和Full GC区别"></a>Major GC和Full GC区别</h4><ul><li>Full GC：收集young gen、old gen、perm gen</li><li>Major GC：有时又叫old gc，只收集old gen</li></ul><h1 id="常⽤的GC策略和触发时机"><a href="#常⽤的GC策略和触发时机" class="headerlink" title="常⽤的GC策略和触发时机"></a>常⽤的GC策略和触发时机</h1><h4 id="YGC-Young-GC"><a href="#YGC-Young-GC" class="headerlink" title="YGC(Young GC)"></a>YGC(Young GC)</h4><ul><li>概念：对新⽣代堆进⾏GC。频率⽐较⾼，因为⼤部分对象的存活寿命较短，在新⽣代⾥被回收。性能耗费较⼩。</li><li>触发时机：Eden区空间不⾜</li></ul><h4 id="FGC-Full-GC"><a href="#FGC-Full-GC" class="headerlink" title="FGC(Full GC)"></a>FGC(Full GC)</h4><ul><li>概念：全堆范围的GC。默认堆空间使⽤到达80%(可调整)的时候会触发FGC。以我们⽣产环境为例，⼀般⽐较少会触发FGC，有时10天或⼀周左右会有⼀次。</li><li>触发时机：<ul><li>Old空间不⾜</li><li>Perm空间不⾜</li></ul></li></ul><h4 id="显示调⽤System-gc-，包括RMI等的定时触发"><a href="#显示调⽤System-gc-，包括RMI等的定时触发" class="headerlink" title="显示调⽤System.gc() ，包括RMI等的定时触发"></a>显示调⽤System.gc() ，包括RMI等的定时触发</h4><h4 id="YGC时的悲观策略"><a href="#YGC时的悲观策略" class="headerlink" title="YGC时的悲观策略"></a>YGC时的悲观策略</h4><h4 id="dump-live的内存信息时-jmap-–dump-live-。"><a href="#dump-live的内存信息时-jmap-–dump-live-。" class="headerlink" title="dump live的内存信息时(jmap –dump:live)。"></a>dump live的内存信息时(jmap –dump:live)。</h4><h1 id="深入理解JVM–JVM垃圾回收机制"><a href="#深入理解JVM–JVM垃圾回收机制" class="headerlink" title="深入理解JVM–JVM垃圾回收机制"></a>深入理解JVM–JVM垃圾回收机制</h1><h4 id="GC为我们做了什么操作呢？"><a href="#GC为我们做了什么操作呢？" class="headerlink" title="GC为我们做了什么操作呢？"></a>GC为我们做了什么操作呢？</h4><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><h4 id="学习GC作用"><a href="#学习GC作用" class="headerlink" title="学习GC作用"></a>学习GC作用</h4><ul><li>排查内存溢出</li><li>排查内存泄漏</li><li>性能调优，排查并发瓶颈</li></ul><h4 id="什么时候会触发一个对象的回收"><a href="#什么时候会触发一个对象的回收" class="headerlink" title="什么时候会触发一个对象的回收"></a>什么时候会触发一个对象的回收</h4><ul><li>对象没有引用</li><li>作用域发生未捕获异常</li><li>程序在作用域正常执行完毕</li><li>程序执行了System.exit()</li><li>程序发生意外终止（被杀进程等）</li></ul><h1 id="Java中存在四种引用"><a href="#Java中存在四种引用" class="headerlink" title="Java中存在四种引用"></a>Java中存在四种引用</h1><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>只要引用存在，垃圾回收器永远不会回收</li><li>Object obj &#x3D; new Object();</li><li>new出来的对象都是强引用，GC无论如何都不会回收，即使抛出OOM异常</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul><li>非必须引用，内存溢出之前进行回收，可以通过以下代码实现</li><li>只有当JVM内存不足时才会被回收<br>Object obj &#x3D; new Object();<br>SoftReference<object>sf &#x3D; new SoftReference<object>(obj);<br>obj &#x3D; null;<br>sf.get();&#x2F;&#x2F;有时候会返回null<br>这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；<br>软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</object></object></li></ul><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul><li>第二次垃圾回收时回收，可以通过如下代码实现<br>Object obj &#x3D; new Object();<br>WeakReference<object>wf &#x3D; new WeakReference<object>(obj);<br>obj &#x3D; null;<br>wf.get();&#x2F;&#x2F;有时候会返回null<br>wf.isEnQueued();&#x2F;&#x2F;返回是否被垃圾回收器标记为即将回收的垃圾<br>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。<br>弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器</object></object></li><li>只要GC,就会立马回收，不管内存是否充足</li></ul><h4 id="虚引用（幽灵-幻影引用）"><a href="#虚引用（幽灵-幻影引用）" class="headerlink" title="虚引用（幽灵&#x2F;幻影引用）"></a>虚引用（幽灵&#x2F;幻影引用）</h4><ul><li>垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现<br>Object obj &#x3D; new Object();<br>PhantomReference<object>pf &#x3D; new PhantomReference<object>(obj);<br>obj&#x3D;null;<br>pf.get();&#x2F;&#x2F;永远返回null<br>pf.isEnQueued();&#x2F;&#x2F;返回从内存中已经删除<br>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。<br>虚引用主要用于检测对象是否已经从内存中删除。</object></object></li><li>它唯一的作用就是做一些跟踪记录，辅助finalize函数的使用</li></ul><h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><p>JVM把内存划分成了如下几个区域：<br>1.方法区（Method Area）<br>2.堆区（Heap）<br>3.虚拟机栈（VM Stack）<br>4.本地方法栈（Native Method Stack）<br>5.程序计数器（Program Counter Register）<br>其中，方法区和堆所有线程共享。</p><ul><li>线程不共享区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的</li><li>线程共享区域 线程共享区域包含：堆和方法区</li></ul><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><ul><li>主要存放类与类之间关系的数据，而这部分数据被加载到内存之后，基本上是不会发生变更的</li><li>方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息</li><li>方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常</li><li>在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation）</li><li>一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载</li><li>在方法区上进行GC，条件相当苛刻而且困难。</li><li>方法区的数据因为回收率非常小，而成本又比较高，一般认为是“性价比”非常差的，所以Sun自己的虚拟机HotSpot中是不回收的！但是在现在高性能分布式J2EE的系统中，我们大量用到了反射、动态代理、CGLIB、JSP和OSGI等，这些类频繁的调用自定义类加载器，都需要动态的加载和卸载了，以保证永久带不会溢出，他们通过自定义的类加载器进行了各项操作，因此在实际的应用开发中，类也是被经常加载和卸载的，方法区也是会被回收的！但是方法区的回收条件非常苛刻，只有同时满足以下三个条件才会被回收！<ul><li>该类的所有实例都已经被回收</li><li>加载该类的ClassLoad已经被回收</li><li>Class对象无法通过任何途径访问(包括反射)，该类对应的反射类java.lang.Class对象没有被任何地方引用</li></ul></li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用</li><li>一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</li><li>保存装载的类的元信息：类型的常量池，字段、⽅法信息，⽅法字节码</li><li>jdk6时，String等常量信息置于⽅法区，jdk7移到了堆中</li><li>通常和永久区（Perm）关联在⼀起</li></ul><h4 id="堆区（Heap）"><a href="#堆区（Heap）" class="headerlink" title="堆区（Heap）"></a>堆区（Heap）</h4><ul><li>Java堆中的数据基本上是朝生夕死的，我们用完之后要马上回收的，而Java栈和本地方法栈中的数据，因为有后进先出的原则，当我取下面的数据之前，必须要把栈顶的元素出栈，因此回收率可认为是100%</li><li>堆区是GC最频繁的，也是理解GC机制最重要的区域</li><li>堆区由所有线程共享，在虚拟机启动时创建</li><li>堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。</li><li>应⽤系统对象都保存在java堆中</li><li>所有线程共享java堆</li><li>对分代GC来说，堆也是分代的</li></ul><h4 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h4><ul><li>虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈</li><li>局部变量表中存储着方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：内存空间可以在编译期间就确定，运行时不再改变</li><li>虚拟机栈定义了两种异常类型：StackOverFlowError(栈溢出)和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError；不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</li><li>线程私有</li><li>栈由⼀系列帧组成（因此java栈也叫做帧栈）</li><li>帧保存⼀个⽅法的局部变量（局部变量表）、操作数栈、常量池指针</li><li>每⼀次⽅法调⽤创建⼀个帧，并压栈</li></ul><h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><ul><li>本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态</li><li>本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法</li><li>在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</li></ul><h4 id="程序计数器（Program-Counter-Register）-PC寄存器"><a href="#程序计数器（Program-Counter-Register）-PC寄存器" class="headerlink" title="程序计数器（Program Counter Register）(PC寄存器)"></a>程序计数器（Program Counter Register）(PC寄存器)</h4><ul><li>主要用于记录线程执行的行号等一些信息，这块区域也是被认为是唯一一块不会内存溢出的区域。在SunHostSpot的虚拟机中，对于程序计数器是不回收的</li><li>每个线程拥有⼀个pc寄存器，指向下⼀条指令的地址</li><li>程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它</li><li>它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的</li><li>每个程序计数器只能记录一个线程的行号，因此它是线程私有的</li><li>如果程序当前正在执行的是一个java方法，则程序计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则计数器的值为空</li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ul><li>属于串行收集器</li><li>Serial收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下ServerVM 4核4GB以下机器的默认垃圾回收器</li><li>比较适合于只有一个处理器的系统</li><li>串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World”的垃圾回收器</li><li>串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。</li><li>Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</li><li>在串行处理器中minor和major GC过程都是用一个线程进行回收的</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul><li>ParNew收集器其实就是多线程版本的Serial收集器</li><li>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器</li><li>它可以与CMS GC配合，所以，更加有理由将他用于server端</li></ul><h4 id="ParallelScavenge"><a href="#ParallelScavenge" class="headerlink" title="ParallelScavenge"></a>ParallelScavenge</h4><ul><li>ParallelScavenge又被称为是吞吐量优先的收集器</li><li>ParallelScavenge所提到的吞吐量&#x3D;程序运行时间&#x2F;(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%，在交互不多的云端，比较适合使用该回收器。</li><li>在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式</li></ul><h1 id="ParallelOld"><a href="#ParallelOld" class="headerlink" title="ParallelOld"></a>ParallelOld</h1><ul><li>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器</li><li>这个收集器是JDK1.6之后刚引入的一款收集器，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先</li><li>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法</li></ul><h4 id="SerialOld"><a href="#SerialOld" class="headerlink" title="SerialOld"></a>SerialOld</h4><ul><li>SerialOld是旧生代Client模式下的默认收集器，单线程执行</li><li>在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器</li><li>Serial Old是Serial收集器的老年代版本</li><li>它同样使用一个单线程执行收集，使用“标记-整理”算法</li><li>主要使用在Client模式下的虚拟机</li></ul><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><ul><li>CMS又称响应时间优先(最短回收停顿)的回收器</li><li>使用并发模式回收垃圾</li><li>使用标记-清除算法</li><li>CMS对CPU是非常敏感的，它的回收线程数&#x3D;（CPU+3）&#x2F;4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%</li><li>CMS模式主要分为4个过程</li><li>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程</li><li>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</li><li>CMS为了确保能够扫描到所有的对象，避免在Initial Marking中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack中，如依赖的对象地址在其之后，则仅标记该对象。在进行Concurrent Marking时minor GC也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS为了应对这样的并发现象，提供了一个Mod Union Table来进行记录，在这个Mod Union Table中记录每次minor GC后修改了的Card的信息。这也是ParallelScavenge不能和CMS一起使用的原因。</li><li>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收</li><li>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收</li><li>该收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间</li><li>常见的B&#x2F;S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清楚算法实现的</li><li>CMS收集器的优点：并发收集、低停顿，但远没有达到完美</li><li>CMS收集器的缺点：<ul><li>CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。</li><li>CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。</li><li>CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。</li></ul></li></ul><h4 id="GarbageFirst-G1"><a href="#GarbageFirst-G1" class="headerlink" title="GarbageFirst(G1)"></a>GarbageFirst(G1)</h4><ul><li>SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器</li><li>他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间</li><li>相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿</li></ul><h4 id="RTSJ垃圾收集器"><a href="#RTSJ垃圾收集器" class="headerlink" title="RTSJ垃圾收集器"></a>RTSJ垃圾收集器</h4><ul><li>RTSJ垃圾收集器，用于Java实时编程</li></ul><h1 id="JVM的内存分配与回收策略"><a href="#JVM的内存分配与回收策略" class="headerlink" title="JVM的内存分配与回收策略"></a>JVM的内存分配与回收策略</h1><ul><li>优先在Edon上分配对象</li><li>大对象直接进入老生代</li><li>年长者(长期存活对象)进入老生代</li><li>群体效应(大批中年对象进入老生代)</li><li>担保GC(担保minorGC)<ul><li>担保GC就是担保minorGC能够满足当前的存储空间，而无需触发老生代的回收，由于大部分对象都是朝生夕死的，因此，在实际开发中这种很起效，但是也有可能会发生担保失败的情况，当担保失败的时候会触发FullGC，但是失败毕竟是少数，因此这种一般是很划算的。</li><li>默认情况是是开启担保的，无需设置参数</li></ul></li></ul><h1 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h1><ul><li>每⼀个线程有⼀个⼯作内存，和主存独⽴</li><li>⼯作内存存放主存中变量的值的拷⻉</li><li>对于普通变量，⼀个线程中更新的值，不能⻢上反应在其他变量中；如果需要在其他线程中⽴即可⻅，需要使⽤volatile关键字</li><li>volatile不能代替锁，⼀般认为volatile⽐锁性能好(不绝对)，使⽤volatile的条件是语义是否满⾜应⽤</li><li>可⻅性：⼀个线程修改了变量，其他线程可以⽴即知道。<ul><li>volatile；</li><li>synchronized（unlock之前，写变量值回主存）</li><li>final（⼀旦初始化完成，其他线程可⻅）</li></ul></li></ul><h1 id="Java-中堆和栈有什么不同"><a href="#Java-中堆和栈有什么不同" class="headerlink" title="Java 中堆和栈有什么不同"></a>Java 中堆和栈有什么不同</h1><ul><li>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的</li><li>而堆是所有线程共享的一片公用内存区域</li><li>对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</li></ul><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>虚拟机把描述类的数据⽂件（字节码）加载到内存，并对数据进⾏验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使⽤的java类型（java.lang.Class对象）</li><li>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</li></ul><h4 id="类⽣命周期"><a href="#类⽣命周期" class="headerlink" title="类⽣命周期"></a>类⽣命周期</h4><ul><li>类加载过程：读取⼆进制字节流到jvm—&gt;验证格式语义等—&gt;为静态变量分配内存空间—&gt;常量池引⽤解析—&gt;执⾏static标识的代码<ul><li>a. 加载过程：通过⼀个类的全限定名来获取定义此类的⼆进制字节流，将这个字节流所代表的静态存储结构转化为⽅法区的运⾏时数据结构。在内存中(⽅法区)⽣成⼀个代表这个类的java.lang.Class对象，作为⽅法区这个类的各种数据的访问⼊⼝；</li><li>b. 验证过程：为了确保Class⽂件的字节流中包含的信息符合当前虚拟机的要求，⽂件格式验证、元数据验证、字节码验证、符号引⽤验证；</li><li>c. 准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在⽅法区中进⾏分配；准备阶段，static对象会被设置默认值，static ﬁnal对象会被赋上给予的值。</li><li>d. 解析阶段：虚拟机将常量池内的符号引⽤替换为直接引⽤的过程。<ul><li>i. 符号引⽤：字符串，引⽤对象不⼀定被加载；</li><li>ii. 直接引⽤：指针或者地址偏移量，引⽤对象⼀定在内存中。</li></ul></li><li>e. 初始化阶段：类初始化阶段是类加载过程的最后⼀步。初始化阶段就是执⾏类构造器<clint>()⽅法的过程。</clint></li><li>f. 使⽤阶段</li><li>g. 卸载阶段：</li></ul></li></ul><h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><ul><li>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</li><li>主要有一下四种类加载器:<ul><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ul></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li>java默认提供三个类加载器：<ul><li>a. 启动类加载器（BootStrap ClassLoader） 启动ClassLoader（sun.boot.class.path）：最顶层的加载类，主要加载jdk中的核⼼库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。Bootstrap ClassLoader不继承⾃ClassLoader，因为它不是⼀个普通的Java类，底层由C++编写，已嵌⼊到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核⼼类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</li><li>b. 扩展类加载器（Extension ClassLoader）扩展ClassLoader（java.ext.dirs）：扩展的类加载器，加载⽬录%JRE_HOME%\lib\ext⽬录下的jar包和class⽂件。还可以加载-D java.ext.dirs选项指定的⽬录。</li><li>c. App ClassLoader应⽤ClassLoader&#x2F;系统ClassLoader（java.class.path）：也称为SystemAppClass 加载当前应⽤的classpath的所有类。除了BootStrap ClassLoader，每个ClassLoader都有⼀个Parent作为⽗亲。</li></ul></li><li>双亲委派机制：<ul><li>定义：当⼀个ClassLoader实例需要加载某个类时，它会试图亲⾃搜索某个类之前，先把这个任务委托给它的⽗类加载器，这个过程是由上⾄下依次检查的，⾸先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader进⾏加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的⽂件系统或⽹络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类⽣成⼀个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</li><li>作⽤：<ul><li>避免重复加载；</li><li>考虑到安全因素，避免⾃定义的类去替代系统类，如String。</li><li>jvm如何判定两个class是否相同？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，⽽且要判断是否由同⼀个类加载器实例加载的。只有两者同时满⾜的情况下，JVM才认为这两个class是相同的。<ul><li>⾃底向上检查类是否已经加载；</li><li>⾃顶向下尝试加载类。</li></ul></li></ul></li></ul></li><li>custom classloader：⾃定义classloader<ul><li>Java中提供的默认ClassLoader，只加载指定⽬录下的jar和class，如果我们想加载其它位置的类或jar时，就需要定义⾃⼰的ClassLoader。</li><li>步骤：<ul><li>继承java.lang.ClassLoader</li><li>重写⽗类的findClass⽅法</li></ul></li></ul></li></ul><h4 id="引起类加载的五个⾏为"><a href="#引起类加载的五个⾏为" class="headerlink" title="引起类加载的五个⾏为"></a>引起类加载的五个⾏为</h4><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li><li>反射调⽤的时候，如果类没有进⾏过初始化，则需要先触发其初始化</li><li>⼦类初始化的时候，如果其⽗类还没初始化，则需先触发其⽗类的初始化</li><li>虚拟机执⾏主类的时候(有 main(string[] args))</li><li>JDK1.7 动态语⾔⽀持</li></ul><h4 id="java对象创建时机"><a href="#java对象创建时机" class="headerlink" title="java对象创建时机"></a>java对象创建时机</h4><ul><li>使⽤new关键字创建对象</li><li>使⽤Class类的newInstance⽅法(反射机制)</li><li>使⽤Constructor类的newInstance⽅法(反射机制)</li><li>使⽤Clone⽅法创建对象</li><li>使⽤(反)序列化机制创建对象</li></ul><h1 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h1><h4 id="调优时机"><a href="#调优时机" class="headerlink" title="调优时机"></a>调优时机</h4><ul><li>heap 内存（⽼年代）持续上涨达到设置的最⼤内存值；</li><li>Full GC 次数频繁；</li><li>GC 停顿时间过⻓（超过1秒）；</li><li>应⽤出现OutOfMemory 等内存异常；</li><li>应⽤中有使⽤本地缓存且占⽤⼤量内存空间；</li><li>系统吞吐量与响应性能不⾼或下降。</li></ul><h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><ul><li>多数的Java应⽤不需要在服务器上进⾏JVM优化；</li><li>多数导致GC问题的Java应⽤，都不是因为我们参数设置错误，⽽是代码问题；</li><li>在应⽤上线之前，先考虑将机器的JVM参数设置到最优（最适合）；</li><li>减少创建对象的数量；</li><li>减少使⽤全局变量和⼤对象；</li><li>JVM优化是到最后不得已才采⽤的⼿段；</li><li>在实际使⽤中，分析GC情况优化代码⽐优化JVM参数更好；</li></ul><h4 id="调优⽬标"><a href="#调优⽬标" class="headerlink" title="调优⽬标"></a>调优⽬标</h4><ul><li>GC低停顿；</li><li>GC低频率；</li><li>低内存占⽤；</li><li>⾼吞吐量；</li></ul><h4 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a>调优步骤</h4><ul><li>分析GC⽇志及dump⽂件，判断是否需要优化，确定瓶颈问题点；</li><li>确定jvm调优量化⽬标；</li><li>确定jvm调优参数（根据历史jvm参数来调整）；</li><li>调优⼀台服务器，对⽐观察调优前后的差异；</li><li>不断的分析和调整，知道找到合适的jvm参数配置；</li><li>找到最合适的参数，将这些参数应⽤到所有服务器，并进⾏后续跟踪。</li></ul><h1 id="jvm调优参数"><a href="#jvm调优参数" class="headerlink" title="jvm调优参数"></a>jvm调优参数</h1><ul><li>设定堆内存⼤⼩，这是最基本的。</li><li>-Xms：启动JVM时的堆内存空间。</li><li>-Xmx：堆内存最⼤限制。</li><li>设定新⽣代⼤⼩。</li><li>新⽣代不宜太⼩，否则会有⼤量对象涌⼊⽼年代。</li><li>-XX:NewRatio：新⽣代和⽼年代的占⽐。</li><li>-XX:NewSize：新⽣代空间。</li><li>-XX:SurvivorRatio：伊甸园空间和幸存者空间的占⽐。</li><li>-XX:MaxTenuringThreshold：对象进⼊⽼年代的年龄阈值。</li><li>设定垃圾回收器<ul><li>年轻代：-XX:+UseParNewGC。</li><li>⽼年代：-XX:+UseConcMarkSweepGC。</li><li>CMS可以将STW时间降到最低，但是不对内存进⾏压缩，有可能出现“并⾏模式失败”。⽐如⽼年代空间还有300MB空间，但是⼀些10MB的对象⽆法被顺序的存储。这时候会触发压缩处理，但是CMS GC模式下的压缩处理时间要⽐Parallel GC⻓很多。</li><li>G1采⽤”标记-整理“算法，解决了内存碎⽚问题，建⽴了可预测的停顿时间类型，能让使⽤者指定在⼀个⻓度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。</li></ul></li></ul><h1 id="触发full-gc的场景及应对策略"><a href="#触发full-gc的场景及应对策略" class="headerlink" title="触发full gc的场景及应对策略"></a>触发full gc的场景及应对策略</h1><ul><li>System.gc()⽅法的调⽤，应对策略：通过-XX:+DisableExpl icitGC来禁⽌调⽤System.gc ;</li><li>⽼年代代空间不⾜，应对策略：让对象在Minor GC阶段被回收，让对象在新⽣代多存活⼀段时间，不要创建过⼤的对象及数组;</li><li>永⽣区空间不⾜，应对策略：增⼤PermGen空间；</li><li>GC时出现promotionfailed和concurrent mode failure，应对策略：增⼤survivor space；</li><li>Minor GC后晋升到旧⽣代的对象⼤⼩⼤于⽼年代的剩余空间，应对策略：增⼤Tenured space 或下调CMSInitiatingOccupancyFraction&#x3D;60；</li><li>内存持续增涨达到上限导致Full GC，应对策略：通过dumpheap 分析是否存在内存泄漏。</li></ul><h1 id="简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述java内存分配与回收策率以及Minor GC和Major GC"></a>简述java内存分配与回收策率以及Minor GC和Major GC</h1><ul><li>对象优先在堆的Eden区分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将直接进入老年代</li><li>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc&#x2F;Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度</li></ul><h1 id="如何查看jvm内存使⽤情况"><a href="#如何查看jvm内存使⽤情况" class="headerlink" title="如何查看jvm内存使⽤情况"></a>如何查看jvm内存使⽤情况</h1><ul><li>可以使⽤JDK⾃带的JConsole、JVisualVM、JMap、JHat等⼯具，或者使⽤第三⽅⼯具，⽐如 Eclipse Memory Analyzer</li></ul><h1 id="内存溢出的可能原因和解决⽅法"><a href="#内存溢出的可能原因和解决⽅法" class="headerlink" title="内存溢出的可能原因和解决⽅法"></a>内存溢出的可能原因和解决⽅法</h1><h4 id="内存溢出原因"><a href="#内存溢出原因" class="headerlink" title="内存溢出原因"></a>内存溢出原因</h4><ul><li>数据加载过多，如1次从数据库中取出过多数据</li><li>集合类中有对对象的引⽤，⽤完后没有清空或者集合对象未置空导致引⽤存在等，是的JVM⽆法回收</li><li>死循环，过多重复对象</li><li>第三⽅软件的bug</li><li>启动参数内存值设定的过⼩</li></ul><h4 id="解决⽅法"><a href="#解决⽅法" class="headerlink" title="解决⽅法"></a>解决⽅法</h4><ul><li>修改JVM启动参数，加内存(-Xms，-Xmx)</li><li>错误⽇志，是否还有其他错误</li><li>代码⾛查</li></ul><h1 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h1><ul><li>未对作废数据内存单元置为null，尽早释放⽆⽤对象的引⽤，使⽤临时变量时，让引⽤变量在推出活动域后⾃动设置为null，暗示垃圾收集器收集；</li><li>程序避免⽤String拼接，⽤StringBuffer，因为每个String会占⽤内存⼀块区域；</li><li>尽量少⽤静态变量（全局不会回收）；</li><li>不要集中创建对象尤其⼤对象，可以使⽤流操作；</li><li>尽量使⽤对象池，不再循环中创建对象，优化配置；</li><li>创建对象到单例getInstance中，对象⽆法回收被单例引⽤；</li><li>服务器session时间设置过⻓也会引起内存泄漏。</li></ul><h1 id="⽅法区oom"><a href="#⽅法区oom" class="headerlink" title="⽅法区oom"></a>⽅法区oom</h1><ul><li>⽅法区⽤于存放Class的相关信息，如：类名，访问修饰符，常量池，字符描述，⽅法描述等。</li><li>原因：运⾏时产⽣⼤量的类去填满⽅法区，直到溢出。</li></ul><h1 id="哪些情况下对象会进⼊⽼年代"><a href="#哪些情况下对象会进⼊⽼年代" class="headerlink" title="哪些情况下对象会进⼊⽼年代"></a>哪些情况下对象会进⼊⽼年代</h1><ul><li>新⽣代对象每次经历⼀次minor gc，年龄会加1，当达到年龄阈值（默认为15岁）会直接进⼊⽼年代</li><li>⼤对象直接进⼊⽼年代</li><li>新⽣代复制算法需要⼀个survivor区进⾏轮换备份，如果出现⼤量对象在minor gc后仍然存活的情况时，就需要⽼年代进⾏分配担保，让survivor⽆法容纳的对象直接进⼊⽼年代</li><li>如果在Survivor空间中相同年龄所有对象⼤⼩的总和⼤于Survivor空间的⼀半，年龄⼤于或等于该年龄的对象就可以直接进⼊年⽼代</li></ul><h1 id="当对象A创建之后，对象A在各个区之间的流转过程"><a href="#当对象A创建之后，对象A在各个区之间的流转过程" class="headerlink" title="当对象A创建之后，对象A在各个区之间的流转过程"></a>当对象A创建之后，对象A在各个区之间的流转过程</h1><ul><li>对象A被new出来之后，是被存放在Eden（伊甸园）区的</li><li>当发⽣⼀次GC后，Eden区存活下来的对象A会被复制到s1区，s0中存活的对象也会被复制到s1中。如果对象年龄超过阈值年龄（默认15岁），会被复制到⽼年区。部分对象也需要⽼年代分担。<br>c. GC会清空Eden和s0中存储的所有对象；<br>d. 交换s0和s1的⻆⾊；<br>e. 重复上⾯的步骤。</li></ul><h1 id="jvm体系总体分四大块"><a href="#jvm体系总体分四大块" class="headerlink" title="jvm体系总体分四大块"></a>jvm体系总体分四大块</h1><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul><h1 id="调优命令"><a href="#调优命令" class="headerlink" title="调优命令"></a>调优命令</h1><ul><li>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</li><li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>jstack，用于生成java虚拟机当前时刻的线程快照</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数</li><li>jstack可以看当前栈的情况，jmap查看内存，jhat 进行dump堆的信息</li></ul><h1 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h1><ul><li>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto</li><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等</li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>GChisto，一款专业分析gc日志的工具</li></ul><h1 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h1><ul><li>比如GC的时候必须要等到Java线程都进入到safepoint的时候VMThread才能开始执行GC，</li><li>循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)</li><li>方法返回前</li><li>调用方法的call之后</li><li>抛出异常的位置</li></ul><h1 id="简述java垃圾回收机制"><a href="#简述java垃圾回收机制" class="headerlink" title="简述java垃圾回收机制"></a>简述java垃圾回收机制</h1><ul><li>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行</li><li>在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</li></ul><h1 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h1><ul><li>－server 启用服务器模式（如果CPU多，服务器机建议使用此项）</li><li>－Xms，－Xmx一般设为同样大小。 800m</li><li>－Xmn 是将NewSize与MaxNewSize设为一致。320m</li><li>－XX：PerSize 64m</li><li>－XX：NewSize 320m 此值设大可调大新对象区，减少Full GC次数</li><li>－XX：MaxNewSize 320m</li><li>－XX：NewRato NewSize设了可不设。4</li><li>－XX： SurvivorRatio 4</li><li>－XX：userParNewGC 可用来设置并行收集</li><li>－XX：ParallelGCThreads 可用来增加并行度 4</li><li>－XXUseParallelGC 设置后可以使用并行清除收集器</li><li>－XX：UseAdaptiveSizePolicy 与上面一个联合使用效果更好，利用它可以自动优化新域大小以及救助空间比值</li><li>-XmxJavaHeap最大值，默认值为物理内存的1&#x2F;4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；</li><li>-XmsJavaHeap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/c0d8e27e97f4.html" class="post-title-link" itemprop="url">多线程</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:06:48" itemprop="dateCreated datePublished" datetime="2023-12-20T15:06:48+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-28 13:48:11" itemprop="dateModified" datetime="2023-12-28T13:48:11+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>42k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>38 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="用什么关键字修饰同步方法"><a href="#用什么关键字修饰同步方法" class="headerlink" title="用什么关键字修饰同步方法"></a>用什么关键字修饰同步方法</h1><ul><li>用synchronized关键字修饰同步方法</li></ul><h1 id="stop-和suspend-方法为何不推荐使用"><a href="#stop-和suspend-方法为何不推荐使用" class="headerlink" title="stop()和suspend()方法为何不推荐使用"></a>stop()和suspend()方法为何不推荐使用</h1><ul><li>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</li><li>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</li></ul><h1 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h1><ul><li>最大的不同是在等待时wait会释放锁，而sleep一直持有锁</li><li>Wait通常被用于线程间交互，sleep通常被用于暂停执行</li><li>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li><li>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li><li>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。</li><li>wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。</li><li>sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器</li></ul><h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul><li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取</li><li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率</li></ul><h1 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h1><ul><li>启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态</li><li>一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码</li></ul><h1 id="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h1><ul><li>分几种情况：<ul><li>其他方法前是否加了synchronized关键字，如果没加，则能。</li><li>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</li><li>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</li><li>如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</li></ul></li></ul><h1 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h1><ul><li>一个程序中可以有多条执行线索同时执行</li><li>一个线程就是程序中的一条执行线索</li><li>每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行</li><li>每个程序至少都有一个线程，即main方法执行的那个线程</li><li>如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行。</li><li>线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身</li><li>Java中的线程有四种状态分别是：运行、就绪、挂起、结束</li><li>线程是操作系统能够进⾏运算调度的最⼩单位，它被包含在进程之中，是进程中的实际运作单位，可以使⽤多线程对进⾏运算提速</li></ul><h1 id="简述synchronized和java-util-concurrent-locks-Lock的异同"><a href="#简述synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="简述synchronized和java.util.concurrent.locks.Lock的异同"></a>简述synchronized和java.util.concurrent.locks.Lock的异同</h1><ul><li>主要相同点：Lock能完成synchronized所实现的所有功能</li><li>主要不同点<ul><li>Lock有比synchronized更精确的线程语义和更好的性能</li><li>ynchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放</li><li>Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁</li></ul></li></ul><h1 id="Synchronized和ReentrantLock有什么区别"><a href="#Synchronized和ReentrantLock有什么区别" class="headerlink" title="Synchronized和ReentrantLock有什么区别?"></a>Synchronized和ReentrantLock有什么区别?</h1><ul><li>synchronized是Java内建的同步机制,所以也有人称其为Intrinsic Locking（固有锁），它提供了互斥的语义和可见性,当一个线程已经获取当前锁时,其他试图获取的线程只能等待或者阻塞在那里。在Java 5以前,synchronized是仅有的同步手段,在代码中,synchronized可以用来修饰方法,也可以使用在特定的代码块上,本质上 synchronized方法等同于把方法全部语句用synchronized块包起来。</li><li>ReentrantLock,通常翻译为再入锁,是Java 5提供的锁实现,它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取,代码书写更加灵活。与此同时,ReentrantLock提供了很多实用的方法,能够实现很多synchronized无法做到的细节控制,但是在编码中也需要注意,必须要明确调用unlock()方法释放,不然就会一直持有该锁。synchronzied和ReentrantLock的性能不能一概而论,早期版本synchronized在很多场景下性能相差较大,在后续版本进行了较多改进,在低竞争场景中表现可能优于ReentrantLock。</li></ul><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>可重⼊锁。可重⼊锁是指同⼀个线程可以多次获取同⼀把锁。ReentrantLock和synchronized都是可重⼊锁。</li><li>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，⽽ReentrantLock则提供了中断功能。</li><li>公平锁是指多个线程同时尝试获取同⼀把锁时，获取锁的顺序按照线程达到的顺序</li><li>⾮公平锁则允许线程“插队”</li><li>synchronized是⾮公平锁，⽽ReentrantLock的默认实现是⾮公平锁，但是也可以设置为公平锁。</li></ul><h4 id="CAS操作-CompareAndSwap"><a href="#CAS操作-CompareAndSwap" class="headerlink" title="CAS操作(CompareAndSwap)"></a>CAS操作(CompareAndSwap)</h4><ul><li>CAS操作简单的说就是⽐较并交换</li><li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)</li><li>如果内存位置的值与预期原值相匹配，那么处理器会⾃动将该位置值更新为新值。否则，处理器不做任何操作</li><li>⽆论哪种情况，它都会在 CAS 指令之前返回该位置的值</li><li>CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</li></ul><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ul><li>synchronized是java内置的关键字，它提供了⼀种独占的加锁⽅式</li><li>synchronized的获取和释放锁由JVM实现，⽤户不需要显示的释放锁，⾮常⽅便</li><li>然⽽synchronized也有⼀定的局限性：<ul><li>当线程尝试获取锁的时候，如果获取不到锁会⼀直阻塞。</li><li>如果获取锁的线程进⼊休眠或者阻塞，除⾮当前线程异常，否则其他线程尝试获取锁必须⼀直等待。</li></ul></li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul><li>ReentrantLock它是JDK 1.5之后提供的API层⾯的互斥锁，需要lock()和unlock()⽅法配合try&#x2F;finally语句块来完成。</li><li>等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）</li><li>公平锁与⾮公平锁多个线程等待同⼀个锁时，必须按照申请锁的时间顺序获得锁</li><li>Synchronized锁⾮公平锁，ReentrantLock默认的构造函数是创建的⾮公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li></ul><h1 id="请说出你所知道的线程同步的方法"><a href="#请说出你所知道的线程同步的方法" class="headerlink" title="请说出你所知道的线程同步的方法"></a>请说出你所知道的线程同步的方法</h1><ul><li>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</li><li>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</li><li>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级</li><li>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li></ul><h1 id="同步有几种实现方法-都是什么"><a href="#同步有几种实现方法-都是什么" class="headerlink" title="同步有几种实现方法,都是什么?"></a>同步有几种实现方法,都是什么?</h1><ul><li>同步的实现方面有两种，分别是synchronized,wait与notify</li></ul><h1 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信</li><li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信</li><li>这种方式，本质上就是“共享内存”式的通信</li><li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行</li></ul><h4 id="while轮询的方式"><a href="#while轮询的方式" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul><li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()&#x3D;&#x3D;5)是否成立 ，从而实现了线程间的通信</li><li>但是这种方式会浪费CPU资源</li><li>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试某个条件是否成立</li><li>这种方式还存在另外一个问题：轮询的条件的可见性问题</li><li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li></ul><h4 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait&#x2F;notify机制"></a>wait&#x2F;notify机制</h4><ul><li>线程A要等待某个条件满足时(list.size()&#x3D;&#x3D;5)，才执行操作，线程B则向list中添加元素，改变list 的size</li><li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢</li><li>这里用到了Object类的 wait() 和 notify() 方法</li><li>当条件未满足时(list.size() !&#x3D;5)，线程A调用wait()放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</li><li>当条件满足时，线程B调用 notify()通知线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态</li><li>这种方式的一个好处就是CPU的利用率提高了，但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ul><li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li><li>分布式系统中说的两种通信机制：共享内存机制和消息通信机制</li><li>synchronized关键字和while轮询“属于”共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流</li><li>而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。</li></ul><h1 id="线程死锁及解决办法"><a href="#线程死锁及解决办法" class="headerlink" title="线程死锁及解决办法"></a>线程死锁及解决办法</h1><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><ul><li>所谓死锁： 是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁线程。</li><li>由于资源占用是互斥的，当某个线程提出申请资源后，使得有关线程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁</li><li>关键点：<ul><li>两个以上的线程</li><li>争夺共享的资源</li><li>它们各自不释放手中资源，除非有外力协助</li></ul></li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y的拥有者分别等待对方的资源的问题。</li><li>将多个锁组成一组并放到同一个锁下</li><li>将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得容器对象的锁时，就可以通过检查变量来判断是否整个容器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试</li></ul><h1 id="锁分类的了解"><a href="#锁分类的了解" class="headerlink" title="锁分类的了解"></a>锁分类的了解</h1><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h4><ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁</li><li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象</li><li>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大</li><li>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁</li></ul><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul><li>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。</li><li>对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁</li></ul><h4 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁&#x2F;共享锁"></a>独享锁&#x2F;共享锁</h4><ul><li>独享锁是指该锁一次只能被一个线程所持有。</li><li>共享锁是指该锁可被多个线程所持有。</li><li>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。</li><li>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li><li>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</li><li>对于Synchronized而言，当然是独享锁。</li></ul><h4 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁&#x2F;读写锁"></a>互斥锁&#x2F;读写锁</h4><ul><li>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。</li><li>互斥锁在Java中的具体实现就是ReentrantLock</li><li>读写锁在Java中的具体实现就是ReadWriteLock</li></ul><h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h4><ul><li>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</li><li>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</li><li>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</li><li>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</li><li>悲观锁在Java中的使用，就是利用各种锁。</li><li>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li><li>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑</li><li>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接上了锁操作资源。</li></ul><h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><ul><li>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</li><li>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。</li><li>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</li><li>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计</li><li>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作</li></ul><h4 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h4><ul><li>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</li><li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li><li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li><li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li></ul><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul><li>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区</li><li>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</li><li>⾃旋锁是SMP架构中的⼀种low-level的同步机制</li><li>当线程A想要获取⼀把⾃旋锁⽽该锁⼜被其它线程锁持有时，线程A会在⼀个循环中⾃旋以检测锁是不是已经可⽤了。</li><li>⾃选锁需要注意：<ul><li>由于⾃旋时不释放CPU，因⽽持有⾃旋锁的线程应该尽快释放⾃旋锁，否则等待该⾃旋锁的线程会⼀直在那⾥⾃旋，这就会浪费CPU时间</li><li>持有⾃旋锁的线程在sleep之前应该释放⾃旋锁以便其它线程可以获得⾃旋锁</li></ul></li><li>⽬前的JVM实现⾃旋会消耗CPU，如果⻓时间不调⽤doNotify⽅法，doWait⽅法会⼀直⾃旋，CPU会消耗太⼤</li><li>⾃旋锁⽐较适⽤于锁使⽤者保持锁时间⽐较短的情况，这种情况⾃旋锁的效率⽐较⾼</li><li>⾃旋锁是⼀种对多处理器相当有效的机制，⽽在单处理器⾮抢占式的系统中基本上没有作⽤</li></ul><h1 id="重入锁：ReentrantLock-详解"><a href="#重入锁：ReentrantLock-详解" class="headerlink" title="重入锁：ReentrantLock 详解"></a>重入锁：ReentrantLock 详解</h1><ul><li>在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的。除此之外，重入锁又自带一系列高逼格UBFF：可中断响应、锁申请等待限时、公平锁。另外可以结合Condition来使用，使其更是逼格满满。</li><li>使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对逻辑控制的灵活性远远大于synchronized关键字</li><li>需要注意，有加锁就必须有释放锁，而且加锁与释放锁的分数要相同，这里就引出了“重”字的概念</li></ul><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><ul><li>对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。</li><li>t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了死锁。但是，给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，正常执行完成。t2也会退出，但只是释放了资源并没有完成工作</li></ul><h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><ul><li>可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。</li><li>前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。</li><li>后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false</li></ul><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><ul><li>所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="ReentrantLock-配合-Conditond-使用"><a href="#ReentrantLock-配合-Conditond-使用" class="headerlink" title="ReentrantLock 配合 Conditond 使用"></a>ReentrantLock 配合 Conditond 使用</h4><ul><li>配合关键字synchronized使用的方法如：await()、notify()、notifyAll()</li><li>ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象</li></ul><h1 id="深入理解Callable"><a href="#深入理解Callable" class="headerlink" title="深入理解Callable"></a>深入理解Callable</h1><ul><li>Callable和Runnbale一样代表着任务，区别在于Callable有返回值并且可以抛出异常</li><li>Callable接⼝使⽤泛型去定义它的返回类型</li><li>Executors类提供了⼀些有⽤的⽅法去在线程池中执⾏Callable内的任务</li><li>由于Callable任务是并⾏的，必须等待它返回的结果，java.util.concurrent.Future对象解决了这个问题</li><li>在线程池提交Callable任务后返回了⼀个Future对象，使⽤它可以知道Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()⽅法，等待Callable结束并获取它的执⾏结果</li></ul><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><ul><li>Future是一个接口，代表了一个异步计算的结果</li><li>接口中的方法用来检查计算是否完成、等待完成和得到计算的结果</li><li>当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了</li><li>如果想取消，那么调用cancel()方法</li><li>其他方法用于确定任务是正常完成还是取消了</li><li>一旦计算完成了，那么这个计算就不能被取消</li></ul><h4 id="FutureTask-是什么？"><a href="#FutureTask-是什么？" class="headerlink" title="FutureTask 是什么？"></a>FutureTask 是什么？</h4><ul><li>FutureTask 表示一个异步运算的任务，FutureTask 里面可以传入一个 Callable的具体实现类</li><li>可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、 取消任务等操作</li><li>FutureTask可⽤于异步获取执⾏结果或取消执⾏任务的场景</li><li>通过传⼊Runnable或者Callable的任务给FutureTask，直接调⽤其run⽅法或者放⼊线程池执⾏，之后可以在外部通过FutureTask的get⽅法异步获取执⾏结果</li><li>FutureTask⾮常适合⽤于耗时的计算，主线程可以在完成⾃⼰的任务后，再去获取结果</li><li>FutureTask还可以确保即使调⽤了多次run⽅法，它都只会执⾏⼀次Runnable或者Callable任务，或者通过cancel取消FutureTask的执⾏等</li><li>futuretask可⽤于执⾏多任务、以及避免⾼并发情况下多次创建数据机锁的出现。</li></ul><h4 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h4><ul><li><p>当将FutureTask提交给Executor后，Executor执行FutureTask时会执行其run方法</p></li><li><p>任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程</p></li><li><p>从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法</p></li><li><p>set方法：当Callable成功执行后，会调用set方法将结果传出</p></li><li><p>setException方法：该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程</p></li><li><p>get方法：当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。</p></li><li><p>在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待</p></li><li><p>awaitDone方法是如何将调用线程阻塞的,awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制</p></li><li><p>awaitDone方法中进入死循环后，主要有几步</p><ul><li>如果线程被中断了，移除节点，抛出异常</li><li>如果状态大于COMPLETING，那么直接返回</li><li>如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下</li><li>如果状态是NEW且节点为null，那么创建一个节点</li><li>如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程</li><li>如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点</li><li>如果没有限制时间，那么将线程无限挂起</li></ul></li><li><p>上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。</p></li><li><p>当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果</p></li><li><p>report会根据任务的状态不同返回不同的结果。</p><ul><li>如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果</li><li>如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException</li><li>如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException</li></ul></li><li><p>finishCompletion方法：在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程</p></li><li><p>finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环，释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。</p></li><li><p>cancel方法：用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了，如果是需要中断正在执行的任务，那么状态转换将会是NEW-&gt;INTERRPUTING-&gt;INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW-&gt;CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。</p></li><li><p>isDone方法：表明任务是否已经完成了，如果完成了，那么返回true，否则false，只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Callable是一种可以返回结果的任务，这是它与Runnable的区别，但是通过适配器模式可以使Runnable与Callable类似</li><li>Future代表了一个异步的计算，可以从中得到计算结果、查看计算状态，其实现FutureTask可以被提交给Executor执行，多个线程可以从中得到计算结果</li><li>Callable和Future是配合使用的，当从Future中get结果时，如果结果还没被计算出来，那么线程将会被挂起，FutureTak内部使用一个单链表维持等待的线程；当计算结果出来后，将会对等待线程解除挂起，等待线程就都可以得到计算结果了。</li><li>Callable⽤于产⽣结果，Future⽤于获取结果</li></ul><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h4 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h4><ul><li>发挥多核CPU 的优势，并发执⾏让系统运⾏的更快、更流畅，⽤户体验更好</li><li>防止阻塞：从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因 为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但 是单核 CPU 我们还是要应用多线程，就是为了防止阻塞</li><li>便于建模：这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么 就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成 几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运 行这几个任务，那就简单很多了。</li><li>使⽤多线程可以把程序中占据时间⻓的任务放到后台去处理，如图⽚、视屏的下载</li></ul><h4 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h4><ul><li>⼤量的线程降低代码的可读性；</li><li>更多的线程需要更多的内存空间</li><li>当多个线程对同⼀个资源出现争夺时候要注意线程安全的问题。</li></ul><h4 id="多线程的上下⽂切换"><a href="#多线程的上下⽂切换" class="headerlink" title="多线程的上下⽂切换"></a>多线程的上下⽂切换</h4><ul><li>CPU通过时间⽚分配算法来循环执⾏任务，当前任务执⾏⼀个时间⽚后会切换到下⼀个任务</li><li>在切换前会保存上⼀个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态</li></ul><h1 id="线程和进程的区别是什么"><a href="#线程和进程的区别是什么" class="headerlink" title="线程和进程的区别是什么"></a>线程和进程的区别是什么</h1><ul><li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式</li><li>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径</li><li>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些</li><li>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程</li></ul><h1 id="Java-实现线程有哪几种方式"><a href="#Java-实现线程有哪几种方式" class="headerlink" title="Java 实现线程有哪几种方式"></a>Java 实现线程有哪几种方式</h1><ul><li>继承 Thread 类实现多线程</li><li>实现 Runnable 接口方式实现多线程</li><li>使用 ExecutorService、Callable、Future 实现有返回结果的多线程</li></ul><h1 id="启动线程方法-start-和-run-有什么区别"><a href="#启动线程方法-start-和-run-有什么区别" class="headerlink" title="启动线程方法 start()和 run()有什么区别"></a>启动线程方法 start()和 run()有什么区别</h1><ul><li>只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代 码交替执行</li><li>如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码</li></ul><h1 id="一个线程的生命周期有哪几种状态？它们之间如何流转的？"><a href="#一个线程的生命周期有哪几种状态？它们之间如何流转的？" class="headerlink" title="一个线程的生命周期有哪几种状态？它们之间如何流转的？"></a>一个线程的生命周期有哪几种状态？它们之间如何流转的？</h1><ul><li>NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。</li><li>RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中 状态。</li><li>BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。</li><li>WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如 通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方 法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线 程就进入了 RUNNABLE 状态继续运行。</li><li>TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒 后线程重新进行 RUNNABLE 状态继续运行。</li><li>TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程 通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态</li></ul><h1 id="violatile-关键字的作用"><a href="#violatile-关键字的作用" class="headerlink" title="violatile 关键字的作用"></a>violatile 关键字的作用</h1><ul><li>volatile 关键字的作用主要有两个<ul><li>多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据</li><li>使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重要作用就是和CAS结合，保证了原子性</li></ul></li></ul><h1 id="新建-T1、T2、T3-三个线程，如何保证它们按顺序执行"><a href="#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证它们按顺序执行"></a>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行</h1><ul><li>用 join 方法。</li></ul><h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><ul><li>什么是线程池？ 很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线 程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用</li><li>每个线程都要通过 new Thread(xxRunnable).start()的方 式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈</li><li>线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存</li></ul><h1 id="线程池⽤法与优势？"><a href="#线程池⽤法与优势？" class="headerlink" title="线程池⽤法与优势？"></a>线程池⽤法与优势？</h1><h4 id="ThreadPool-优点"><a href="#ThreadPool-优点" class="headerlink" title="ThreadPool 优点"></a>ThreadPool 优点</h4><ul><li>减少了创建和销毁线程的次数，每个⼯作线程都可以被重复利⽤，可执⾏多个任务</li><li>可以根据系统的承受能⼒，调整线程池中⼯作线线程的数⽬，防⽌因为因为消耗过多的内存，⽽把服务器累趴下</li><li>减少在创建和销毁线程上所花的时间以及系统资源的开销</li><li>如不使⽤线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存</li></ul><h4 id="⽐较重要的⼏个类"><a href="#⽐较重要的⼏个类" class="headerlink" title="⽐较重要的⼏个类"></a>⽐较重要的⼏个类</h4><ul><li>Java⾥⾯线程池的顶级接⼜是Executor，但是严格意义上讲Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具</li><li>真正的线程池接口是ExecutorService。</li></ul><h4 id="任务执⾏顺序："><a href="#任务执⾏顺序：" class="headerlink" title="任务执⾏顺序："></a>任务执⾏顺序：</h4><ul><li>ExecutorService 真正的线程池接⼝。</li><li>ScheduledExecutorService 能和Timer&#x2F;TimerTask类似，解决那些需要任务重复执⾏的问题。</li><li>ThreadPoolExecutor ExecutorService的默认实现。</li><li>ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接⼝实现，周期性任务调度的类实现。<ul><li>当线程数⼩于corePoolSize时，创建线程执⾏任务。</li><li>当线程数⼤于等于corePoolSize并且workQueue没有满时，放⼊workQueue中</li><li>线程数⼤于等于corePoolSize并且当workQueue满时，新任务新建线程运⾏，线程总数要⼩于maximumPoolSize</li><li>当线程总数等于maximumPoolSize并且workQueue满了的时候执⾏handler的rejectedExecution。也就是拒绝策略</li></ul></li></ul><h1 id="常用的几种线程池并讲讲其中的工作原理"><a href="#常用的几种线程池并讲讲其中的工作原理" class="headerlink" title="常用的几种线程池并讲讲其中的工作原理"></a>常用的几种线程池并讲讲其中的工作原理</h1><ul><li>线程池核心类：在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是我们线程池核心类</li><li>如何提交线程：如可以先随便定义一个固定大小的线程池 ExecutorService es &#x3D; Executors.newFixedThreadPool(3);提交一个线程es.submit(xxRunnble); es.execute(xxRunnble);</li><li>submit 和 execute 分别有什么区别呢<ul><li>execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多</li><li>submit 返回一个 Future 对象，如果想知道线程结果就使用 submit提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常</li></ul></li><li>如何关闭线程池<ul><li>es.shutdown(); 不再接受新的任务，之前提交的任务等执行结束再关闭线程池</li><li>es.shutdownNow();不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程 list 列表</li></ul></li></ul><h1 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier 和 CountDownLatch 的区别"></a>CyclicBarrier 和 CountDownLatch 的区别</h1><ul><li>都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上</li><li>CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值-1 而已，该线程继续运行</li><li>CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务</li><li>CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为0该CountDownLatch就不可再用了</li></ul><h1 id="什么是活锁、饥饿、无锁、死锁"><a href="#什么是活锁、饥饿、无锁、死锁" class="headerlink" title="什么是活锁、饥饿、无锁、死锁"></a>什么是活锁、饥饿、无锁、死锁</h1><ul><li>死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现了这三种情况，即线程不再活跃，不能再正常地执行下去了</li><li>死锁：死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁</li><li>活锁：活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。</li><li>饥饿：我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源</li><li>无锁：无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功，可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合 下是非常高效的。</li></ul><h1 id="什么是原子性、可见性、有序性"><a href="#什么是原子性、可见性、有序性" class="headerlink" title="什么是原子性、可见性、有序性"></a>什么是原子性、可见性、有序性</h1><ul><li>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个 变量进行操作</li><li>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值</li><li>有序性我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序， 只是重排序会影响多线程执行的结果。</li></ul><h1 id="什么是守护线程？有什么用？"><a href="#什么是守护线程？有什么用？" class="headerlink" title="什么是守护线程？有什么用？"></a>什么是守护线程？有什么用？</h1><ul><li>与守护线程相对应的就是用户线程，守护线程就是守护用户线程</li><li>当用户线程全部执行完结束之后，守护线程才会跟着结束</li><li>也就是守护线程必须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线 程自然会退出</li></ul><h1 id="一个线程运行时发生异常会怎样"><a href="#一个线程运行时发生异常会怎样" class="headerlink" title="一个线程运行时发生异常会怎样"></a>一个线程运行时发生异常会怎样</h1><ul><li>如果异常没有被捕获该线程将会停止执行</li><li>Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口</li><li>当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理</li></ul><h1 id="线程-yield-方法有什么用"><a href="#线程-yield-方法有什么用" class="headerlink" title="线程 yield()方法有什么用"></a>线程 yield()方法有什么用</h1><ul><li>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行</li><li>它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</li></ul><h1 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h1><ul><li>所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的</li></ul><h1 id="Synchronized-有哪几种用法"><a href="#Synchronized-有哪几种用法" class="headerlink" title="Synchronized 有哪几种用法"></a>Synchronized 有哪几种用法</h1><ul><li>锁类、锁方法、锁代码块</li></ul><h1 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h1><h4 id="Fork-Join-框架是干什么的"><a href="#Fork-Join-框架是干什么的" class="headerlink" title="Fork&#x2F;Join 框架是干什么的"></a>Fork&#x2F;Join 框架是干什么的</h4><ul><li>大任务自动分散小任务，并发执行，合并小任务结果</li></ul><h4 id="Fork-Join-框架使用有哪些要注意的地方？"><a href="#Fork-Join-框架使用有哪些要注意的地方？" class="headerlink" title="Fork&#x2F;Join 框架使用有哪些要注意的地方？"></a>Fork&#x2F;Join 框架使用有哪些要注意的地方？</h4><ul><li>如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；</li><li>如果函数的调用栈很深，会导致栈内存溢出；</li></ul><h1 id="线程数过多会造成什么异常"><a href="#线程数过多会造成什么异常" class="headerlink" title="线程数过多会造成什么异常"></a>线程数过多会造成什么异常</h1><ul><li>线程过多会造成栈溢出，也有可能会造成堆异常</li></ul><h1 id="说说线程安全的和不安全的集合"><a href="#说说线程安全的和不安全的集合" class="headerlink" title="说说线程安全的和不安全的集合"></a>说说线程安全的和不安全的集合</h1><ul><li>Java 中平时用的最多的 Map 集合就是 HashMap 了，它是线程不安全的。 看下面两个场景：<ul><li>当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线程安全不安全的问题了</li><li>当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个 HashMap了，对同个 HashMap 操作这时候就存在线程安全的问题了</li></ul></li></ul><h1 id="什么是-CAS-算法？在多线程中有哪些应用"><a href="#什么是-CAS-算法？在多线程中有哪些应用" class="headerlink" title="什么是 CAS 算法？在多线程中有哪些应用"></a>什么是 CAS 算法？在多线程中有哪些应用</h1><ul><li>CAS，全称为 Compare and Swap，即比较-替换</li><li>假设有三个操作数：内存值 V、 旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false</li><li>当然 CAS 一定要 volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功。</li><li>java.util.concurrent.atomic 包下面的 Atom*类都有 CAS 算法的应用。</li></ul><h1 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h1><ul><li>java.lang.Thread#holdsLock 方法</li></ul><h1 id="Jdk-中排查多线程问题用什么命令"><a href="#Jdk-中排查多线程问题用什么命令" class="headerlink" title="Jdk 中排查多线程问题用什么命令"></a>Jdk 中排查多线程问题用什么命令</h1><ul><li>jstack</li></ul><h1 id="线程同步需要注意什么"><a href="#线程同步需要注意什么" class="headerlink" title="线程同步需要注意什么"></a>线程同步需要注意什么</h1><ul><li>尽量缩小同步的范围，增加系统吞吐量</li><li>分布式同步锁无意义，要使用分布式锁</li><li>防止死锁，注意加锁顺序</li></ul><h1 id="线程-wait-方法使用有什么前提？"><a href="#线程-wait-方法使用有什么前提？" class="headerlink" title="线程 wait()方法使用有什么前提？"></a>线程 wait()方法使用有什么前提？</h1><ul><li>要在同步块中使用</li></ul><h1 id="线程之间如何传递数据？"><a href="#线程之间如何传递数据？" class="headerlink" title="线程之间如何传递数据？"></a>线程之间如何传递数据？</h1><ul><li>通过在线程之间共享对象就可以了，</li><li>然后通过wait&#x2F;notify&#x2F;notifyAll、await&#x2F;signal&#x2F;signalAll进行唤起和等待，比方说阻塞队列 BlockingQueue就是为线程之间共享数据而设计的</li></ul><h1 id="保证”可见性”有哪几种方式？"><a href="#保证”可见性”有哪几种方式？" class="headerlink" title="保证”可见性”有哪几种方式？"></a>保证”可见性”有哪几种方式？</h1><ul><li>synchronized 和 viotatile</li></ul><h1 id="说几个常用的-Lock-接口实现锁。"><a href="#说几个常用的-Lock-接口实现锁。" class="headerlink" title="说几个常用的 Lock 接口实现锁。"></a>说几个常用的 Lock 接口实现锁。</h1><ul><li>ReentrantLock、ReadWriteLock</li></ul><h1 id="ThreadLocal-是什么？有什么应用场景？"><a href="#ThreadLocal-是什么？有什么应用场景？" class="headerlink" title="ThreadLocal 是什么？有什么应用场景？"></a>ThreadLocal 是什么？有什么应用场景？</h1><ul><li>ThreadLocal 的作用是提供线程内的局部变量</li><li>这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。用来解决数据库连接、Session 管理等。</li></ul><h1 id="ReadWriteLock-有什么用？"><a href="#ReadWriteLock-有什么用？" class="headerlink" title="ReadWriteLock 有什么用？"></a>ReadWriteLock 有什么用？</h1><ul><li>ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现</li><li>实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能</li></ul><h1 id="怎么唤醒一个阻塞的线程？"><a href="#怎么唤醒一个阻塞的线程？" class="headerlink" title="怎么唤醒一个阻塞的线程？"></a>怎么唤醒一个阻塞的线程？</h1><ul><li>如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它</li><li>如果线程遇到了 IO 阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统</li></ul><h1 id="不可变对象对多线程有什么帮助？"><a href="#不可变对象对多线程有什么帮助？" class="headerlink" title="不可变对象对多线程有什么帮助？"></a>不可变对象对多线程有什么帮助？</h1><ul><li>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率</li></ul><h1 id="多线程上下文切换是什么意思？"><a href="#多线程上下文切换是什么意思？" class="headerlink" title="多线程上下文切换是什么意思？"></a>多线程上下文切换是什么意思？</h1><ul><li>多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</li></ul><h1 id="Java-中用到了什么线程调度算法？"><a href="#Java-中用到了什么线程调度算法？" class="headerlink" title="Java 中用到了什么线程调度算法？"></a>Java 中用到了什么线程调度算法？</h1><ul><li>抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</li></ul><h1 id="Thread-sleep-0-的作用是什么？"><a href="#Thread-sleep-0-的作用是什么？" class="headerlink" title="Thread.sleep(0)的作用是什么？"></a>Thread.sleep(0)的作用是什么？</h1><ul><li>由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制 权的一种操作</li></ul><h1 id="Hashtable-的-size-方法为什么要做同步？"><a href="#Hashtable-的-size-方法为什么要做同步？" class="headerlink" title="Hashtable 的 size()方法为什么要做同步？"></a>Hashtable 的 size()方法为什么要做同步？</h1><ul><li>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B则可以正常调用 size()方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对size++，线程 B 就已经读取 size了，那么对于线程 B 来说读取到的size 一定是不准 确的。而给 size()方法加了同步之后，意味着线程 B 调用size()方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性。</li></ul><h1 id="同步方法和同步块，哪种更好？"><a href="#同步方法和同步块，哪种更好？" class="headerlink" title="同步方法和同步块，哪种更好？"></a>同步方法和同步块，哪种更好？</h1><ul><li>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率</li><li>请知道一条原则：同步的范围越小越好。</li></ul><h1 id="Runnable-和-Thread-用哪个好？"><a href="#Runnable-和-Thread-用哪个好？" class="headerlink" title="Runnable 和 Thread 用哪个好？"></a>Runnable 和 Thread 用哪个好？</h1><ul><li>Java 不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也为了减少类之间的耦合性，Runnable 会更好</li></ul><h1 id="Java-中-notify-和-notifyAll-有什么区别？"><a href="#Java-中-notify-和-notifyAll-有什么区别？" class="headerlink" title="Java 中 notify 和 notifyAll 有什么区别？"></a>Java 中 notify 和 notifyAll 有什么区别？</h1><ul><li>notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行</li></ul><h1 id="为什么-wait-notify-notifyAll-这些方法不在-thread-类里面？"><a href="#为什么-wait-notify-notifyAll-这些方法不在-thread-类里面？" class="headerlink" title="为什么 wait&#x2F;notify&#x2F;notifyAll 这些方法不在 thread 类里面？"></a>为什么 wait&#x2F;notify&#x2F;notifyAll 这些方法不在 thread 类里面？</h1><ul><li>原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果 wait()方法定 义在 Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait， notify 和 notifyAll都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象</li></ul><h1 id="为什么-wait-和-notify-方法要在同步块中调用？"><a href="#为什么-wait-和-notify-方法要在同步块中调用？" class="headerlink" title="为什么 wait 和 notify 方法要在同步块中调用？"></a>为什么 wait 和 notify 方法要在同步块中调用？</h1><ul><li>为了避免 wait 和 notify 之间产生竞态条件</li><li>为Java API强制要求，否则会抛出IllegalMonitorStateException 异常</li></ul><h1 id="为什么你应该在循环中检查等待条件？"><a href="#为什么你应该在循环中检查等待条件？" class="headerlink" title="为什么你应该在循环中检查等待条件？"></a>为什么你应该在循环中检查等待条件？</h1><ul><li>处于等待状态的线程可能会收到错误警报和伪唤醒</li><li>如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出</li><li>因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因</li></ul><h1 id="你如何在-Java-中获取线程堆栈？"><a href="#你如何在-Java-中获取线程堆栈？" class="headerlink" title="你如何在 Java 中获取线程堆栈？"></a>你如何在 Java 中获取线程堆栈？</h1><ul><li>jstack 这个工具来获取，它对进程 id 进行操作，用 jps 这个工具找到 id。</li></ul><h1 id="如何创建线程安全的单例模式？"><a href="#如何创建线程安全的单例模式？" class="headerlink" title="如何创建线程安全的单例模式？"></a>如何创建线程安全的单例模式？</h1><ul><li>单例模式即一个 JVM 内存中只存在一个类的对象实例分类<ul><li>懒汉式 类加载的时候就创建实例</li><li>饿汉式 使用的时候才创建实例</li></ul></li></ul><h1 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h1><ul><li>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接</li><li>这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</li></ul><h1 id="提交任务时线程池队列已满会时发会生什么？"><a href="#提交任务时线程池队列已满会时发会生什么？" class="headerlink" title="提交任务时线程池队列已满会时发会生什么？"></a>提交任务时线程池队列已满会时发会生什么？</h1><ul><li>当线程数小于最大线程池数 maximumPoolSize 时就会创建新线程来处理</li><li>线程数大于等于最大线程池数 maximumPoolSize 时就会执行拒绝策略</li><li>如果你使⽤的LinkedBlockingQueue，也就是⽆界队列的话，没关系，继续添加任务到阻塞队列中等待执⾏，因为LinkedBlockingQueue可以近乎认为是⼀个⽆穷⼤的队列，可以⽆限存放任务；</li><li>如果你使⽤的是有界队列⽐⽅说ArrayBlockingQueue的话，任务⾸先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使⽤拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</li></ul><h1 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h1><ul><li>可以用join方法实现</li></ul><h1 id="在Java中Lock接口比synchronized块的优势是什么？"><a href="#在Java中Lock接口比synchronized块的优势是什么？" class="headerlink" title="在Java中Lock接口比synchronized块的优势是什么？"></a>在Java中Lock接口比synchronized块的优势是什么？</h1><ul><li>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁</li></ul><h1 id="你将如何使用threaddump？你将如何分析Thread-dump？"><a href="#你将如何使用threaddump？你将如何分析Thread-dump？" class="headerlink" title="你将如何使用threaddump？你将如何分析Thread dump？"></a>你将如何使用threaddump？你将如何分析Thread dump？</h1><ul><li>在UNIX中你可以使用kill -3，然后thread dump将会打印日志</li><li>在windows中你可以使用”CTRL+Break”</li></ul><h1 id="为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h1><ul><li>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码</li><li>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码</li></ul><h1 id="Java中你怎样唤醒一个阻塞的线程？"><a href="#Java中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java中你怎样唤醒一个阻塞的线程？"></a>Java中你怎样唤醒一个阻塞的线程？</h1><ul><li>如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程</li><li>如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它</li></ul><h1 id="Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h1><ul><li>通常利用Executors提供的通用线程池创建方法，去创建不同配置的线程池,主要区别在于不同的ExecutorService类型或者不同的初始参数</li><li>Executors目前提供了5种不同的线程池创建配置<ul><li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点:<ul><li>它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程</li><li>如果线程闲置的时间超过60S，则被终止并移出缓存</li><li>长时间闲置时，这种线程池不会消耗资源</li></ul></li><li>newFixedThreadPool(int nThreads)：重用指定数目的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现，如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads</li><li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为1,操作一个无界的工作队列,所以它保证了所有任务的都是被顺序执行,最多会有一个任务处于活动状态,并且不允许使用者改造线程实例,因此可以避免其改变线程数目。</li><li>newSingleThreadScheduledExecutor()和newSecheduledThreadPool(int corePoolSize),创建的是个ScheduledExecutorService,可以进行定时或周期性的工作调度,区别在于单一工作线程还是多个工作线程。</li></ul></li></ul><h1 id="⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？"><a href="#⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？" class="headerlink" title="⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？"></a>⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？</h1><ul><li>⾼并发、任务执⾏时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下⽂的切换</li><li>并发不⾼、任务执⾏时间⻓的业务要区分开看：<ul><li>假如是业务时间⻓集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占⽤CPU，所以不要让所有的CPU闲下来，可以加⼤线程池中的线程数⽬，让CPU处理更多的业务</li><li>假如是业务时间⻓集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）⼀样吧，线程池中的线程数设置得少⼀些，减少线程上下⽂的切换</li></ul></li><li>并发⾼、业务执⾏时间⻓，解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，看看这些业务⾥⾯某些数据是否能做缓存是第⼀步，增加服务器是第⼆步，⾄于线程池的设置，设置参考（2）。最后，业务执⾏时间⻓的问题，也可能需要分析⼀下，看看能不能使⽤中间件对任务进⾏拆分和解耦。</li></ul><h1 id="线程安全和线程不安全"><a href="#线程安全和线程不安全" class="headerlink" title="线程安全和线程不安全"></a>线程安全和线程不安全</h1><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul><li>线程安全就是多线程访问时，采⽤了加锁机制，当⼀个线程访问该类的某个数据时，进⾏保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使⽤。不会出现数据不⼀致或者数据污染。</li><li>线程安全是一个多线程环境下正确性的概念,也就是保证多线程环境下共享的可修改的状态的正确性,这里的状态反映在程序中其实可以看做是数据。</li><li>换个角度来看,如果状态不是共享的,或者不是可修改的,也就不存在线程安全问题,进而可以推理出保证线程安全的两个办法<ul><li>第一个是封装,我们可以将对象内部状态隐藏保护起来</li><li>第二个是不可变。</li></ul></li><li>线程安全需要保证几个基本特性<ul><li>原子性：简单来说就是相关操作不会中途被其他线程干扰,一般通过同步机制实现</li><li>可见性：是一个线程修改了某个共享变量,其状态能够立即被其他线程知晓,通常被解释为将线程本地状态反映到主内存中,volatile关键字就是负责保证可见性的</li><li>有序性：是保证线程内串行语义, 避免指令重排等</li></ul></li></ul><h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><ul><li>线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</li><li>线程安全问题都是由全局变量及静态变量引起的</li><li>若每个线程中对全局变量、静态变量只有读操作，⽽⽆写操作，⼀般来说，这个全局变量是线程安全的</li><li>若有多个线程同时执⾏写操作，⼀般都需要考虑线程同步，否则的话就可能影响线程安全</li></ul><h1 id="如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全"><a href="#如何保证集合是线程安全的-ConcurrentHashMap-如何实现高效的线程安全" class="headerlink" title="如何保证集合是线程安全的?	ConcurrentHashMap 如何实现高效的线程安全?"></a>如何保证集合是线程安全的?	ConcurrentHashMap 如何实现高效的线程安全?</h1><ul><li>在传统集合框架内部,除了Hashtable Vector等同步容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个 同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等</li><li>Vector 是⽤同步⽅法来实现线程安全的, ⽽和它相似的ArrayList不是线程安全的</li></ul><h1 id="为什么需要ConcurrentHashMap"><a href="#为什么需要ConcurrentHashMap" class="headerlink" title="为什么需要ConcurrentHashMap?"></a>为什么需要ConcurrentHashMap?</h1><ul><li>Hashtable本身比较低效,因为它的实现基本就是put get size等各种方法加上”synchronized”</li><li>这就导致了所有并发操作都要竞争同一把锁,一个线程在进行同步操作时,其他线程只能等待,大大降低了并发操作的效率</li><li>HashMap不是线程安全的,那么能不能利用Collections提供的同步包装器来解决问题</li><li>实际上同步器只是利用 输入Map构造了另一个同步版本,所有操作不再声明为synchronized方法,但是还是利用</li><li>Hashtable或者同步包装版本,都只是适合在非高度并发的场景下</li></ul><h1 id="ConcurrentHashMap工作机制"><a href="#ConcurrentHashMap工作机制" class="headerlink" title="ConcurrentHashMap工作机制"></a>ConcurrentHashMap工作机制</h1><ul><li>在早期的ConcurrentHashMap,其实现是基于分离锁,也就是将内部进行分段,里面则是HashEntry的数据</li><li>和HashMap类似,哈希相同的条目也是以链表形式存放。(简单点来说,就是在ConcurrentHashMap中,把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中)在构造的时候,Segment的数量由所谓的concurrentcyLevel来决定,默认是16,也可以在相应构造函数直接指定。注意,Java需要它是2的幂数值,如果输入是类似15这种非幂值,会自动调整到16之类2的幂数值。</li><li>ConcurrentHashMap的工作机制就是通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li></ul><h1 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h1><ul><li>CAS（compare and swap）的缩写，中⽂翻译成⽐较并交换。</li><li>CAS 不通过JVM,直接利⽤java本地⽅ JNI（Java Native Interface为JAVA本地调⽤）,直接调⽤CPU 的cmpxchg（是汇编指令）指令</li><li>利⽤CPU的CAS指令，同时借助JNI来完成Java的⾮阻塞算法,实现原⼦操作。其它原⼦操作都是利⽤类似的特性完成的。</li><li>整个java.util.concurrent都是建⽴在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很⼤的提升。</li><li>CAS是项乐观锁技术，当多个线程尝试使⽤CAS同时更新同⼀个变量时，只有其中⼀个线程能更新变量的值，⽽其它线程都失败，失败的线程并不会被挂起，⽽是被告知这次竞争中失败，并可以再次尝试</li><li>使⽤CAS在线程冲突严重时，会⼤幅降低程序性能；CAS只适合于线程冲突较少的情况使⽤。</li><li>synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是⾃旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了⾼吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；⽽线程冲突严重的情况下，性能远⾼于CAS</li></ul><h1 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h1><ul><li>AbstractQueuedSynchronizer简称AQS，是⼀个⽤于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等</li><li>AQS解决了在实现同步容器时设计的⼤量细节问题。</li><li>AQS使⽤⼀个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护⼀个等待状态waitStatus。</li></ul><h1 id="什么是原⼦操作？在Java-Concurrency-API中有哪些原⼦类-atomic-classes-？"><a href="#什么是原⼦操作？在Java-Concurrency-API中有哪些原⼦类-atomic-classes-？" class="headerlink" title="什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？"></a>什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？</h1><ul><li>原⼦操作是指⼀个不受其他操作影响的操作任务单元</li><li>原⼦操作是在多线程环境下避免数据不⼀致必须的⼿段。</li><li>int++并不是⼀个原⼦操作，所以当⼀个线程读取它的值并加1时，另外⼀个线程有可能会读到之前的值，这就会引发错误。</li><li>为了解决这个问题，必须保证增加操作是原⼦的，在JDK1.5之前我们可以使⽤同步技术来做到这⼀点到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以⾃动的保证对于他们的操作是原⼦的并且不需要使⽤同步</li></ul><h1 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h1><ul><li>阻塞队列是⼀个在队列基础上⼜⽀持了两个附加操作的队列。<ul><li>⽀持阻塞的插⼊⽅法：队列满时，队列会阻塞插⼊元素的线程，直到队列不满。</li><li>⽀持阻塞的移除⽅法：队列空时，获取元素的线程会等待队列变为⾮空。</li></ul></li><li>JDK7提供了7个阻塞队列<ul><li>ArrayBlockingQueue ：⼀个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：⼀个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：⼀个⽀持优先级排序的⽆界阻塞队列。</li><li>DelayQueue：⼀个使⽤优先级队列实现的⽆界阻塞队列。</li><li>SynchronousQueue：⼀个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：⼀个由链表结构组成的⽆界阻塞队列。</li><li>LinkedBlockingDeque：⼀个由链表结构组成的双向阻塞队列。</li></ul></li></ul><h1 id="什么是同步容器和并发容器的实现？"><a href="#什么是同步容器和并发容器的实现？" class="headerlink" title="什么是同步容器和并发容器的实现？"></a>什么是同步容器和并发容器的实现？</h1><h4 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h4><ul><li>主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。</li><li>锁的粒度为当前对象整体。</li><li>迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。</li></ul><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><ul><li>主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。</li><li>锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。</li><li>迭代器具有弱⼀致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</li><li>ConcurrentHashMap采⽤分段锁技术，同步容器中，是⼀个容器⼀个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若⼲段，每段维护⼀个锁，以达到⾼效的并发访问；</li></ul><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h4 id="ThreadLocal的设计理念与作⽤？"><a href="#ThreadLocal的设计理念与作⽤？" class="headerlink" title="ThreadLocal的设计理念与作⽤？"></a>ThreadLocal的设计理念与作⽤？</h4><ul><li>Java中的ThreadLocal类允许我们创建只能被同⼀个线程读写的变量</li><li>如果⼀段代码含有⼀个ThreadLocal变量的引⽤，即使两个线程同时执⾏这段代码，它们也⽆法访问到对⽅的ThreadLocal变量</li></ul><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>线程局部变量</li><li>变量是同⼀个，但是每个线程都使⽤同⼀个初始值，也就是使⽤同⼀个变量的⼀个新的副本。这种情况之下ThreadLocal就⾮常适⽤，⽐如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是⼀个线程安全的变量。⽽我们每个线程都需要使⽤他，并且各⾃使⽤各⾃的。这种情况，ThreadLocal就⽐较好的解决了这个问题。</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>从本质来讲，就是每个线程都维护了⼀个map，⽽这个map的key就是threadLocal，⽽值就是我们set的那个值</li><li>每次线程在get的时候，都从⾃⼰的变量中取值，既然从⾃⼰的变量中取值，那肯定就不存在线程安全问题</li><li>ThreadLocal这个变量的状态根本没有发⽣变化，他仅仅是充当⼀个key的⻆⾊，另外提供给每⼀个线程⼀个初始值。</li></ul><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><ul><li>每个Thread对象内部都维护了⼀个ThreadLocalMap这样⼀个ThreadLocal的Map，可以存放若⼲个ThreadLocal。</li></ul><h4 id="应⽤场景"><a href="#应⽤场景" class="headerlink" title="应⽤场景"></a>应⽤场景</h4><ul><li>当很多线程需要多次使⽤同⼀个对象，并且需要该对象具有相同初始化值的时候最适合使⽤ThreadLocal。</li></ul><h1 id="Semaphore有什么作⽤？"><a href="#Semaphore有什么作⽤？" class="headerlink" title="Semaphore有什么作⽤？"></a>Semaphore有什么作⽤？</h1><ul><li>Semaphore就是⼀个信号量</li><li>作⽤是限制某段代码块的并发数</li></ul><h1 id="Hashtable的size-⽅法中明明只有⼀条语句”return-count”，为什么还要做同步？"><a href="#Hashtable的size-⽅法中明明只有⼀条语句”return-count”，为什么还要做同步？" class="headerlink" title="Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？"></a>Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？</h1><ul><li>同⼀时间只能有⼀条线程执⾏固定类的同步⽅法，但是对于类的⾮同步⽅法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执⾏Hashtable的put⽅法添加数据，线程B则可以正常调⽤size()⽅法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size⼀定是不准确的。</li><li>⽽给size()⽅法加了同步之后，意味着线程B调⽤size()⽅法只有在线程A调⽤put⽅法完毕之后才可以调⽤，这样就保证了线程安全性。</li></ul><h1 id="ConcurrentHashMap的并发度是什么？"><a href="#ConcurrentHashMap的并发度是什么？" class="headerlink" title="ConcurrentHashMap的并发度是什么？"></a>ConcurrentHashMap的并发度是什么？</h1><ul><li>⼯作机制（分⽚思想）：它引⼊了⼀个“分段锁”的概念，具体可以理解为把⼀个⼤的Map拆分成N个⼩的segment，根据key.hashCode()来决定把key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li><li>应⽤：当读&gt;写时使⽤，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；</li><li>hash冲突：<ul><li>简介：HashMap中调⽤hashCode()⽅法来计算hashCode。由于在Java中两个不同的对象可能有⼀样的hashCode,所以不同的键可能有⼀样hashCode，从⽽导致冲突的产⽣。</li><li>hash冲突解决：使⽤平衡树来代替链表，当同⼀hash中的元素数量超过特定的值便会由链表切换到平衡树</li></ul></li><li>⽆锁读：ConcurrentHashMap之所以有较好的并发性是因为ConcurrentHashMap是⽆锁读和加锁写，并且利⽤了分段锁（不是在所有的entry上加锁，⽽是在⼀部分entry上加锁）；读之前会先判断count(jdk1.6)，其中的count是被volatile修饰的(当变量被volatile修饰后，每次更改该变量的时候会将更改结果写到系统主内存中，利⽤多处理器的缓存⼀致性，其他处理器会发现⾃⼰的缓存⾏对应的内存地址被修改，就会将⾃⼰处理器的缓存⾏设置为失效，并强制从系统主内存获取最新的数据。)，故可以实现⽆锁读。</li><li>ConcurrentHashMap的并发度就是segment的⼤⼩，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最⼤优势。</li></ul><h1 id="ReentrantReadWriteLock读写锁的使⽤"><a href="#ReentrantReadWriteLock读写锁的使⽤" class="headerlink" title="ReentrantReadWriteLock读写锁的使⽤"></a>ReentrantReadWriteLock读写锁的使⽤</h1><ul><li>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm⾃⼰控制的，你只要上好相应的锁即可</li><li>如果你的代码只读数据，可以很多⼈同时读，但不能同时写，那就上读锁</li><li>如果你的代码修改数据，只能有⼀个⼈在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁</li></ul><h1 id="锁的等级：⽅法锁、对象锁、类锁"><a href="#锁的等级：⽅法锁、对象锁、类锁" class="headerlink" title="锁的等级：⽅法锁、对象锁、类锁?"></a>锁的等级：⽅法锁、对象锁、类锁?</h1><h4 id="⽅法锁（synchronized修饰⽅法时）"><a href="#⽅法锁（synchronized修饰⽅法时）" class="headerlink" title="⽅法锁（synchronized修饰⽅法时）"></a>⽅法锁（synchronized修饰⽅法时）</h4><pre><code>- 通过在⽅法声明中加⼊ synchronized关键字来声明 synchronized ⽅法。
- synchronized ⽅法控制对类成员变量的访问：
- 每个类实例对应⼀把锁，每个 synchronized ⽅法都必须获得调⽤该⽅法的类实例的锁⽅能执⾏，否则所属线程阻塞，⽅法⼀旦执⾏，就独占该锁，直到从该⽅法返回时才将锁释放，此后被阻塞的线程⽅能获得该锁，重新进⼊可执⾏状态
- 这种机制确保了同⼀时刻对于每⼀个类实例，其所有声明为 synchronized 的成员函数中⾄多只有⼀个处于可执⾏状态，从⽽有效避免了类成员变量的访问冲突。
</code></pre><h4 id="对象锁（synchronized修饰⽅法或代码块）"><a href="#对象锁（synchronized修饰⽅法或代码块）" class="headerlink" title="对象锁（synchronized修饰⽅法或代码块）"></a>对象锁（synchronized修饰⽅法或代码块）</h4><ul><li>当⼀个对象中有synchronized method或synchronized block的时候调⽤此对象的同步⽅法或进⼊其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调⽤者占⽤，则需要等待此锁被释放。（⽅法锁也是对象锁）</li><li>java的所有对象都含有1个互斥锁，这个锁由JVM⾃动获取和释放</li><li>线程进⼊synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待</li><li>synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁</li><li>这⾥也体现了⽤synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来⾃动释放。</li></ul><p>　</p><h4 id="类锁-synchronized-修饰静态的⽅法或代码块"><a href="#类锁-synchronized-修饰静态的⽅法或代码块" class="headerlink" title="类锁(synchronized 修饰静态的⽅法或代码块)"></a>类锁(synchronized 修饰静态的⽅法或代码块)</h4><ul><li>由于⼀个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有⼀份。所以，⼀旦⼀个静态的⽅法被申明为synchronized。此类所有的实例化对象在调⽤此⽅法，共⽤同⼀把锁，我们称之为类锁。</li><li>对象锁是⽤来控制实例⽅法之间的同步，类锁是⽤来控制静态⽅法（或静态变量互斥体）之间的同步</li></ul><h1 id="如果同步块内的线程抛出异常会发⽣什么？"><a href="#如果同步块内的线程抛出异常会发⽣什么？" class="headerlink" title="如果同步块内的线程抛出异常会发⽣什么？"></a>如果同步块内的线程抛出异常会发⽣什么？</h1><ul><li>synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁</li></ul><h1 id="并发编程（concurrency）并⾏编程（parallellism）有什么区别？"><a href="#并发编程（concurrency）并⾏编程（parallellism）有什么区别？" class="headerlink" title="并发编程（concurrency）并⾏编程（parallellism）有什么区别？"></a>并发编程（concurrency）并⾏编程（parallellism）有什么区别？</h1><ul><li>并⾏是指两个或者多个事件在同⼀时刻发⽣；⽽并发是指两个或多个事件在同⼀时间间隔发⽣。</li><li>并⾏是在不同实体上的多个事件，并发是在同⼀实体上的多个事件。</li><li>在⼀台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群所以并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能。</li></ul><h1 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h1><ul><li>volatile只能保证你数据的可⻅性，获取到的是最新的数据，不能保证原⼦性；</li><li>⽤AtomicInteger保证原⼦性。</li><li>synchronized既能保证共享变量可⻅性，也可以保证锁内操作的原⼦性。</li></ul><h1 id="⼀个线程如果出现了运⾏时异常会怎么样"><a href="#⼀个线程如果出现了运⾏时异常会怎么样" class="headerlink" title="⼀个线程如果出现了运⾏时异常会怎么样?"></a>⼀个线程如果出现了运⾏时异常会怎么样?</h1><ul><li>如果这个异常没有被捕获的话，这个线程就停⽌执⾏了。</li><li>另外重要的⼀点是：如果这个线程持有某个对象的监视器，那么这个对象监视器会被⽴即释放.</li></ul><h1 id="如何在两个线程之间共享数据"><a href="#如何在两个线程之间共享数据" class="headerlink" title="如何在两个线程之间共享数据?"></a>如何在两个线程之间共享数据?</h1><ul><li>通过在线程之间共享对象就可以了，然后通过wait&#x2F;notify&#x2F;notifyAll、await&#x2F;signal&#x2F;signalAll进⾏唤起和等待</li><li>⽐⽅说阻塞队列BlockingQueue就是为线程之间共享数据⽽设计的。</li></ul><h1 id="⽣产者消费者模型的作⽤是什么"><a href="#⽣产者消费者模型的作⽤是什么" class="headerlink" title="⽣产者消费者模型的作⽤是什么?"></a>⽣产者消费者模型的作⽤是什么?</h1><ul><li>通过平衡⽣产者的⽣产能⼒和消费者的消费能⼒来提升整个系统的运⾏效率，这是⽣产者消费者模型最重要的作⽤</li><li>解耦，这是⽣产者消费者模型附带的作⽤，解耦意味着⽣产者和消费者之间的联系少，联系越少越可以独⾃发展⽽不需要受到相互的制约。</li></ul><h1 id="怎么唤醒⼀个阻塞的线程"><a href="#怎么唤醒⼀个阻塞的线程" class="headerlink" title="怎么唤醒⼀个阻塞的线程?"></a>怎么唤醒⼀个阻塞的线程?</h1><ul><li>如果线程是因为调⽤了wait()、sleep()或者join()⽅法⽽导致的阻塞</li><li>suspend与resume，Java废弃suspend() 去挂起线程的原因，是因为suspend() 在导致线程暂停的同时，并不会释放任何锁资源。其他线程都⽆法访问被它占⽤的锁。直到对应的线程执⾏resume() ⽅法后，被挂起的线程才能继从⽽其它被阻塞在这个锁的线程才可以继续执⾏。但是，如果resume()操作出现在 suspend(之前执⾏，那么线程将⼀直处于挂起状态，同时⼀直占⽤锁，这就产⽣了死锁。⽽且，对于被挂起的线程，它的线程状态居然还是 Runnable。</li><li>wait与notify，wait与notify必须配合synchronized使⽤，因为调⽤之前必须持有锁，wait会⽴即释放锁，notify则是同步块执⾏完了才释放</li><li>await与singal，Condition类提供，⽽Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使⽤Lock锁后⽆法使⽤wait⽅法</li><li>park与unpark，LockSupport是⼀个⾮常⽅便实⽤的线程阻塞⼯具，它可以在线程任意位置让线程阻塞。和Thread.suspenf()相⽐，它弥补了由于resume()在前发⽣，导致线程⽆法继续执⾏的情况。和Object.wait()相⽐，它不需要先获得某个对象的锁，也不会抛出IException异常。可以唤醒指定线程。</li><li>如果线程遇到了IO阻塞，⽆能为⼒，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</li></ul><h1 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性?"></a>单例模式的线程安全性?</h1><ul><li>⾸先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建⼀次出来</li><li>单例模式有很多种的写法，我总结⼀下：<ul><li>饿汉式单例模式的写法：线程安全</li><li>懒汉式单例模式的写法：⾮线程安全</li><li>双检锁单例模式的写法：线程安全</li></ul></li></ul><h1 id="线程类的构造⽅法、静态块是被哪个线程调⽤的"><a href="#线程类的构造⽅法、静态块是被哪个线程调⽤的" class="headerlink" title="线程类的构造⽅法、静态块是被哪个线程调⽤的?"></a>线程类的构造⽅法、静态块是被哪个线程调⽤的?</h1><ul><li>线程类的构造⽅法、静态块是被new这个线程类所在的线程所调⽤的，⽽run⽅法⾥⾯的代码才是被线程⾃身所调⽤的。</li></ul><h1 id="同步⽅法和同步块，哪个是更好的选择"><a href="#同步⽅法和同步块，哪个是更好的选择" class="headerlink" title="同步⽅法和同步块，哪个是更好的选择?"></a>同步⽅法和同步块，哪个是更好的选择?</h1><ul><li>同步块是更好的选择，因为它不会锁住整个对象（当然也可以让它锁住整个对象）</li><li>同步⽅法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停⽌执⾏并需要等待获得这个对象上的锁。</li><li>synchronized(this)以及⾮static的synchronized⽅法（⾄于static synchronized⽅法请往下看），只能防⽌多个线程同时执⾏同⼀个对象的同步代码段。</li><li>如果要锁住多个对象⽅法，可以锁住⼀个固定的对象，或者锁住这个类的Class对象。</li><li>synchronized锁住的是括号⾥的对象，⽽不是代码</li><li>对于⾮static的synchronized⽅法，锁的就是对象本身也就是this。</li></ul><h1 id="如何检测死锁？怎么预防死锁？"><a href="#如何检测死锁？怎么预防死锁？" class="headerlink" title="如何检测死锁？怎么预防死锁？"></a>如何检测死锁？怎么预防死锁？</h1><ul><li>死锁是指两个或两个以上的进程在执⾏过程中，因争夺资源⽽造成的⼀种互相等待的现象，若⽆外⼒作⽤，它们都将⽆法推进下去。此时称系统处于死锁；</li></ul><h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><ul><li>互斥条件：进程对所分配到的资源不允许其他进程进⾏访问，若其他进程访问该资源，只能等待，直⾄占有该资源的进程使⽤完成后释放该资源</li><li>请求和保持条件：进程获得⼀定的资源之后，⼜对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但⼜对⾃⼰获得的资源保持不放</li><li>不可剥夺条件：是指进程已获得的资源，在未完成使⽤之前，不可被剥夺，只能在使⽤完后⾃⼰释放</li><li>环路等待条件：是指进程发⽣死锁后，若⼲进程之间形成⼀种头尾相接的循环等待资源关系</li></ul><h4 id="死锁产⽣的原因"><a href="#死锁产⽣的原因" class="headerlink" title="死锁产⽣的原因"></a>死锁产⽣的原因</h4><ul><li>因竞争资源发⽣死锁 现象：系统中供多个进程共享的资源的数⽬不⾜以满⾜全部进程的需要时，就会引起对诸资源的竞争⽽发⽣死锁现象</li><li>进程推进顺序不当发⽣死锁</li></ul><h4 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h4><ul><li>有两个容器，⼀个⽤于保存线程正在请求的锁，⼀个⽤于保存线程已经持有的锁</li><li>每次加锁之前都会做如下检测:<ul><li>检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来</li><li>遍历第⼀步中返回的线程，检查⾃⼰持有的锁是否正被其中任何⼀个线程请求，如果第⼆步返回真,表示出现了死锁</li></ul></li></ul><h4 id="死锁的解除与预防"><a href="#死锁的解除与预防" class="headerlink" title="死锁的解除与预防"></a>死锁的解除与预防</h4><ul><li>控制不要让四个必要条件成⽴。</li></ul><h1 id="HashMap在多线程环境下使⽤需要注意什么？"><a href="#HashMap在多线程环境下使⽤需要注意什么？" class="headerlink" title="HashMap在多线程环境下使⽤需要注意什么？"></a>HashMap在多线程环境下使⽤需要注意什么？</h1><ul><li>要注意死循环的问题，HashMap的put操作引发扩容，这个动作在多线程并发下会发⽣线程死循环的问题</li><li>多个线程同时扩容，造成数据丢失；</li><li>多线程扩容时导致Node链表形成环形结构造成.next()死循环，导致CPU利⽤率接近100%；</li></ul><h1 id="如何实现线程串⾏执⾏？"><a href="#如何实现线程串⾏执⾏？" class="headerlink" title="如何实现线程串⾏执⾏？"></a>如何实现线程串⾏执⾏？</h1><ul><li>为了控制线程执⾏的顺序，如ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执⾏三个线程，我们需要确定唤醒、等待的顺序</li><li>这时我们可以同时使⽤ Obj.wait()、Obj.notify()与synchronized(Obj)来实现这个⽬标。</li><li>线程中持有上⼀个线程类的对象锁以及⾃⼰的锁，由于这种依赖关系，该线程执⾏需要等待上个对象释放锁，从⽽保证类线程执⾏的顺序。</li><li>通常情况下，wait是线程在获取对象锁后，主动释放对象锁，同时本线程休眠，直到有其它线程调⽤对象的notify()唤醒该线程，才能继续获取对象锁，并继续执⾏</li><li>⽽notify()则是对等待对象锁的线程的唤醒操作</li><li>但值得注意的是notify()调⽤后，并不是⻢上就释放对象锁，⽽是在相应的synchronized(){}语句块执⾏结束</li><li>释放对象锁后，JVM会在执⾏wait()等待对象锁的线程中随机选取⼀线程，赋予其对象锁，唤醒线程，继续执⾏。</li></ul><h1 id="可以运⾏时kill掉⼀个线程吗？"><a href="#可以运⾏时kill掉⼀个线程吗？" class="headerlink" title="可以运⾏时kill掉⼀个线程吗？"></a>可以运⾏时kill掉⼀个线程吗？</h1><ul><li>不可以</li><li>只有当线程run⽅法或者主线程main⽅法结束，⼜或者抛出异常时，线程才会结束⽣命周期。</li></ul><h1 id="关于synchronized"><a href="#关于synchronized" class="headerlink" title="关于synchronized"></a>关于synchronized</h1><ul><li>在某个对象的所有synchronized⽅法中,在某个时刻只能有⼀个唯⼀的⼀个线程去访问这些synchronized⽅法</li><li>如果⼀个⽅法是synchronized⽅法,那么该synchronized关键字表示给当前对象上锁(即this)相当于synchronized(this){}</li><li>如果⼀个synchronized⽅法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管⽣成多少对象,其对应的class对象只有⼀个)</li></ul><h1 id="数据库死锁机制和解决⽅案"><a href="#数据库死锁机制和解决⽅案" class="headerlink" title="数据库死锁机制和解决⽅案"></a>数据库死锁机制和解决⽅案</h1><ul><li>死锁：死锁是指两个或者两个以上的事务在执⾏过程中，因争夺锁资源⽽造成的⼀种互相等待的现象。</li><li>处理机制：解决死锁最有⽤最简单的⽅法是不要有等待，将任何等待都转化为回滚，并且事务重新开始，但是有可能影响并发性能。<ul><li>超时回滚，innodb_lock_wait_time设置超时时间；</li><li>wait-for-graph⽅法：跟超时回滚⽐起来，这是⼀种更加主动的死锁检测⽅式。InnoDB引擎也采⽤这种⽅式。</li></ul></li></ul><h1 id="spring单例为什么没有安全问题-ThreadLocal"><a href="#spring单例为什么没有安全问题-ThreadLocal" class="headerlink" title="spring单例为什么没有安全问题(ThreadLocal)"></a>spring单例为什么没有安全问题(ThreadLocal)</h1><ul><li>ThreadLocal：spring使⽤ThreadLocal解决线程安全问题</li><li>ThreadLocal会为每⼀个线程提供⼀个独⽴的变量副本，从⽽隔离了多个线程对数据的访问冲突</li><li>单例：⽆状态的Bean(⽆状态就是⼀次操作，不能保存数据。⽆状态对象(Stateless Bean)，就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。)适合⽤不变模式，技术就是单例模式，这样可以共享实例，提⾼性能。</li></ul><h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><ul><li>使⽤场景：使⽤线程池，以提⾼服务器性能；</li><li>组成：<ul><li>线程池管理器（ThreadPool）：⽤于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li><li>⼯作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执⾏任务；</li><li>任务接⼝（Task）：每个任务必须实现的接⼝，以供⼯作线程调度任务的执⾏，它主要规定了任务的⼊⼝，任务执⾏完后的收尾⼯作，任务的执⾏状态等；</li><li>任务队列（taskQueue）：⽤于存放没有处理的任务。提供⼀种缓冲机制。</li></ul></li><li>原理：线程池技术正是关注如何缩短或调整T1,T3时间的技术，从⽽提⾼服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者⼀些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</li><li>⼯作流程：<ul><li>线程池刚创建时，⾥⾯没有⼀个线程(也可以设置参数prestartAllCoreThreads启动预期数量主线程)</li><li>任务队列是作为参数传进来的</li><li>不过，就算队列⾥⾯有任务，线程池也不会⻢上执⾏它们。</li><li>当调⽤ execute() ⽅法添加⼀个任务时，线程池会做如下判断：<ul><li>如果正在运⾏的线程数量⼩于 corePoolSize，那么⻢上创建线程运⾏这个任务；</li><li>如果正在运⾏的线程数量⼤于或等于 corePoolSize，那么将这个任务放⼊队列；</li><li>如果这时候队列满了，⽽且正在运⾏的线程数量⼩于 maximumPoolSize，那么还是要创建⾮核⼼线程⽴刻运⾏这个任务；</li><li>如果队列满了，⽽且正在运⾏的线程数量⼤于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li></ul></li><li>当⼀个线程完成任务时，它会从队列中取下⼀个任务来执⾏。</li><li>当⼀个线程⽆事可做，超过⼀定的时间（keepAliveTime）时，线程池会判断，如果当前运⾏的线程数⼤于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的⼤⼩。</li></ul></li></ul><h1 id="java线程如何启动"><a href="#java线程如何启动" class="headerlink" title="java线程如何启动"></a>java线程如何启动</h1><ul><li>继承Thread类；</li><li>实现Runnable接⼝</li><li>在函数体使⽤</li><li>⽐较：<ul><li>实现Runnable接⼝优势：<ul><li>适合多个相同的程序代码的线程去处理同⼀个资源</li><li>可以避免java中的单继承的限制</li><li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独⽴。</li></ul></li><li>继承Thread类优势：<ul><li>可以将线程类抽象出来，当需要使⽤抽象⼯⼚模式设计时。</li><li>多线程同步</li></ul></li><li>在函数体使⽤优势<ul><li>⽆需继承thread或者实现Runnable，缩⼩作⽤域。</li></ul></li></ul></li></ul><h1 id="java中加锁的⽅式有哪些-如何实现怎么个写法"><a href="#java中加锁的⽅式有哪些-如何实现怎么个写法" class="headerlink" title="java中加锁的⽅式有哪些,如何实现怎么个写法"></a>java中加锁的⽅式有哪些,如何实现怎么个写法</h1><ul><li>java中有两种锁<ul><li>⼀种是⽅法锁或者对象锁(在⾮静态⽅法或者代码块上加锁)</li><li>第⼆种是类锁(在静态⽅法或者class上加锁)；</li></ul></li><li>注意<ul><li>其他线程可以访问未加锁的⽅法和代码</li><li>synchronized同时修饰静态⽅法和实例⽅法，但是运⾏结果是交替进⾏的，这证明了类锁和对象锁是两个不⼀样的锁，控制着不同的区域，它们是互不⼲扰的。</li></ul></li></ul><h1 id="如何保证数据不丢失："><a href="#如何保证数据不丢失：" class="headerlink" title="如何保证数据不丢失："></a>如何保证数据不丢失：</h1><ul><li>使⽤消息队列，消息持久化；</li><li>添加标志位：未处理 0，处理中 1，已处理 2。定时处理。</li></ul><h1 id="ThreadLocal为什么会发⽣内存泄漏？"><a href="#ThreadLocal为什么会发⽣内存泄漏？" class="headerlink" title="ThreadLocal为什么会发⽣内存泄漏？"></a>ThreadLocal为什么会发⽣内存泄漏？</h1><ul><li>ThreadLocal的实现是这样的：每个Thread 维护⼀个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。</li><li>也就是说 ThreadLocal 本身并不存储值，它只是作为⼀个 key 来让线程从 ThreadLocalMap 获取 value</li><li>ThreadLocalMap使⽤ThreadLocal的弱引⽤作为key，如果⼀个ThreadLocal没有外部强引⽤来引⽤它，那么系统 GC的时候，这个ThreadLocal势必会被回收，这样⼀来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会⼀直存在⼀条强引⽤链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远⽆法回收，造成内存泄漏。</li><li>预防办法：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap⾥所有key为null的value。</li><li>但是这些被动的预防措施并不能保证不会内存泄漏：<ul><li>使⽤static的ThreadLocal，延⻓了ThreadLocal的⽣命周期，可能导致内存泄漏。</li><li>分配使⽤了ThreadLocal⼜不再调⽤get(),set(),remove()⽅法，那么就会导致内存泄漏，因为这块内存⼀直存在。</li></ul></li></ul><h1 id="jdk8中对ConcurrentHashmap的改进"><a href="#jdk8中对ConcurrentHashmap的改进" class="headerlink" title="jdk8中对ConcurrentHashmap的改进"></a>jdk8中对ConcurrentHashmap的改进</h1><ul><li>Java 7为实现并⾏访问，引⼊了Segment这⼀结构，实现了分段锁，理论上最⼤并发度与Segment个数相等。</li><li>Java 8为进⼀步提⾼并发性，摒弃了分段锁的⽅案，⽽是直接使⽤⼀个⼤的数组。同时为了提⾼哈希碰撞下的寻址性能</li><li>Java 8在链表⻓度超过⼀定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红⿊树（寻址时间复杂度为O(long(N))）。</li></ul><h1 id="concurrent包下有哪些类？"><a href="#concurrent包下有哪些类？" class="headerlink" title="concurrent包下有哪些类？"></a>concurrent包下有哪些类？</h1><ul><li>ConcurrentHashMap、Future、FutureTask、AtomicInteger…</li></ul><h1 id="线程a-b-c-d运⾏任务，怎么保证当a-b-c线程执⾏完再执⾏d线程"><a href="#线程a-b-c-d运⾏任务，怎么保证当a-b-c线程执⾏完再执⾏d线程" class="headerlink" title="线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?"></a>线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?</h1><ul><li>CountDownLatch类<ul><li>⼀个同步辅助类，常⽤于某个条件发⽣后才能执⾏后续进程。给定计数初始化CountDownLatch，调⽤countDown(）⽅法，在计数到达零之前，await⽅法⼀直受阻塞。</li><li>重要⽅法为countdown()与await()；</li></ul></li><li>join⽅法<ul><li>将线程B加⼊到线程A的尾部，当A执⾏完后B才执⾏。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Thread t = new Thread(&quot;t1&quot;);</span><br><span class="line">    Thread t2 = new Thread(&quot;t2&quot;);</span><br><span class="line">    t.start();</span><br><span class="line">    t.join();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>notify、wait⽅法，Java中的唤醒与等待⽅法<ul><li>关键为synchronized代码块，参数线程间应相同，也常⽤Object作为参数。</li></ul></li></ul><h1 id="⾼并发系统如何做性能优化？如何防⽌库存超卖？"><a href="#⾼并发系统如何做性能优化？如何防⽌库存超卖？" class="headerlink" title="⾼并发系统如何做性能优化？如何防⽌库存超卖？"></a>⾼并发系统如何做性能优化？如何防⽌库存超卖？</h1><h4 id="⾼并发系统性能优化"><a href="#⾼并发系统性能优化" class="headerlink" title="⾼并发系统性能优化"></a>⾼并发系统性能优化</h4><ul><li>优化程序，优化服务配置，优化系统配置</li><li>尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。</li><li>⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。</li><li>优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。</li><li>优化数据库结构，多做索引，提⾼查询效率。</li><li>统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。</li><li>能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。</li><li>解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。</li></ul><h4 id="防⽌库存超卖"><a href="#防⽌库存超卖" class="headerlink" title="防⽌库存超卖"></a>防⽌库存超卖</h4><ul><li>悲观锁：在更新库存期间加锁，不允许其它线程修改；<ul><li>数据库锁：select xxx for update；</li><li>分布式锁；</li></ul></li><li>乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。</li><li>redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。</li><li>消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。</li><li>总结：总的来说，不能把压⼒放在数据库上，所以使⽤ “select xxx for update” 的⽅式在⾼并发的场景下是不可⾏的</li><li>FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤</li><li>所以相对来说，我会倾向于选择：乐观锁 &#x2F; 缓存锁 &#x2F; 分布式锁的⽅式。</li></ul><h1 id="线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？"><a href="#线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？" class="headerlink" title="线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？"></a>线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？</h1><ul><li>⼯⼚⽅法作⽤：ThreadPoolExecutor类就是Executor的实现类，但ThreadPoolExecutor在使⽤上并不是那么⽅便，在实例化时需要传⼊很多歌参数，还要考虑线程的并发数等与线程池运⾏效率有关的参数，所以官⽅建议使⽤Executors工厂类来创建线程池对象。</li></ul><h1 id="线程间的通信方式-1"><a href="#线程间的通信方式-1" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><ul><li>共享内存机制和消息通信机制</li></ul><h4 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h4><ul><li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。</li><li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。</li><li>这种方式，本质上就是“共享内存”式的通信</li><li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</li></ul><p> </p><h4 id="while轮询的方式-1"><a href="#while轮询的方式-1" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul><li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()&#x3D;&#x3D;5)是否成立 ，从而实现了线程间的通信</li><li>但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立</li><li>这种方式还存在另外一个问题：轮询的条件的可见性问题，关于内存可见性问题</li><li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li></ul><p> </p><h4 id="wait-notify机制-1"><a href="#wait-notify机制-1" class="headerlink" title="wait&#x2F;notify机制"></a>wait&#x2F;notify机制</h4><ul><li>线程A要等待某个条件满足时(list.size()&#x3D;&#x3D;5)，才执行操作</li><li>线程B则向list中添加元素，改变list 的size。</li><li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？</li><li>这里用到了Object类的 wait() 和 notify() 方法。</li><li>当条件未满足时(list.size() !&#x3D;5)，线程A调用wait() 放弃CPU，并进入阻塞状态。不像②while轮询那样占用CPU</li><li>当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。</li><li>这种方式的一个好处就是CPU的利用率提高了。</li><li>但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li></ul><p> </p><h4 id="管道通信-1"><a href="#管道通信-1" class="headerlink" title="管道通信"></a>管道通信</h4><ul><li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li></ul><h1 id="线程池的定义和优点"><a href="#线程池的定义和优点" class="headerlink" title="线程池的定义和优点"></a>线程池的定义和优点</h1><ul><li>线程池，从字面含义来看，是指管理一组同构工作线程的资源池</li><li>线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务</li><li>工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。</li><li>“在线程池中执行任务“”比“为每个线程分配一个任务”优势更多</li><li>通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销</li><li>另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性</li><li>通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</li></ul><h4 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h4><ul><li>默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） </li><li>当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  </li><li>当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  </li><li>当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。</li><li>当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 </li><li>如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。</li></ul><h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><ul><li>如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来</li><li>在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待</li><li>常见的工作队列有以下几种，前三种用的最多。<ul><li>ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。</li><li>LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界&#x2F;无界队列，先进先出。</li><li>SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue才有实际价值.</li><li>PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。</li><li>DelayedWorkQueue：延迟的工作队列，无界队列。</li></ul></li></ul><h4 id="饱和策略（拒绝策略）"><a href="#饱和策略（拒绝策略）" class="headerlink" title="饱和策略（拒绝策略）"></a>饱和策略（拒绝策略）</h4><ul><li>当有界队列被填满后，饱和策略开始发挥作用</li><li>ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改</li><li>如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略</li><li>饱和策略有以下四种，一般使用默认的AbortPolicy。<ul><li>AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</li><li>DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。</li><li>DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。</li><li>CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。</li></ul></li></ul><h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><ul><li>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的</li><li>在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法</li><li>Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。<ul><li>DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。</li><li>PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。</li></ul></li><li>自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。</li></ul><h1 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？-1"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？-1" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？"></a>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h1><ul><li>可以用join方法实现。</li></ul><h1 id="在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"><a href="#在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？" class="headerlink" title="在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"></a>在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</h1><ul><li>lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁</li><li>它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞</li></ul><h1 id="你将如何使用threaddump？你将如何分析Thread-dump？-1"><a href="#你将如何使用threaddump？你将如何分析Thread-dump？-1" class="headerlink" title="你将如何使用threaddump？你将如何分析Thread dump？"></a>你将如何使用threaddump？你将如何分析Thread dump？</h1><ul><li>在UNIX中你可以使用kill -3，然后thread dump将会打印日志</li><li>在windows中你可以使用”CTRL+Break”</li></ul><h1 id="violatile-关键字的作用？"><a href="#violatile-关键字的作用？" class="headerlink" title="violatile 关键字的作用？"></a>violatile 关键字的作用？</h1><ul><li>多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据</li><li>使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言</li><li>volatile 的一个重要作用就是和CAS结合，保证了原子性</li></ul><h1 id="怎么控制同一时间只有-3-个线程运行？"><a href="#怎么控制同一时间只有-3-个线程运行？" class="headerlink" title="怎么控制同一时间只有 3 个线程运行？"></a>怎么控制同一时间只有 3 个线程运行？</h1><p>用 Semaphore。</p><h1 id="线程池启动线程-submit-和-execute-方法有什么不同？"><a href="#线程池启动线程-submit-和-execute-方法有什么不同？" class="headerlink" title="线程池启动线程 submit()和 execute()方法有什么不同？"></a>线程池启动线程 submit()和 execute()方法有什么不同？</h1><ul><li>execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多。</li><li>submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常。</li></ul><h1 id="什么是原子性、可见性、有序性？"><a href="#什么是原子性、可见性、有序性？" class="headerlink" title="什么是原子性、可见性、有序性？"></a>什么是原子性、可见性、有序性？</h1><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul><li>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作</li><li>在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量 n++100 次，如果 n 初始值为 0，n 最后的值应该是 100，所以说它们是互不干扰的，这就是传说的中的原子性。但 n++并不是原子性的操作，要使用 AtomicInteger 保证原子性。</li></ul><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><ul><li>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值</li><li>在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的值，而在多线程编程中就不一定了</li><li>每个线程都有自己的工作内存，线程先把共享变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值</li><li>像CPU 的缓存优化、硬件优化、指令重排及对 JVM 编译器的优化，都会出现可见性的问题。</li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul><li>我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了</li><li>为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即<br>后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果</li><li>所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果</li><li>虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，只是重排序会影响多线程执行的结果。</li></ul><h1 id="多线程上下文切换是什么意思？-1"><a href="#多线程上下文切换是什么意思？-1" class="headerlink" title="多线程上下文切换是什么意思？"></a>多线程上下文切换是什么意思？</h1><p>多- 线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</p><h1 id="Java-中堆和栈有什么不同？"><a href="#Java-中堆和栈有什么不同？" class="headerlink" title="Java 中堆和栈有什么不同？"></a>Java 中堆和栈有什么不同？</h1><ul><li>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的</li><li>而堆是所有线程共享的一片公用内存区域</li><li>对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</li></ul><h1 id="你如何在-Java-中获取线程堆栈？-1"><a href="#你如何在-Java-中获取线程堆栈？-1" class="headerlink" title="你如何在 Java 中获取线程堆栈？"></a>你如何在 Java 中获取线程堆栈？</h1><ul><li>对于不同的操作系统，有多种方法来获得 Java 进程的线程堆栈</li><li>当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台</li><li>在 Windows 你可以使用 Ctrl + Break 组合键来获取线程堆栈，Linux 下用 kill -3 命令</li><li>你也可以用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。</li></ul><h1 id="什么是阻塞式方法？-1"><a href="#什么是阻塞式方法？-1" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h1><ul><li>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接</li><li>这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回</li><li>此外，还有异步和非阻塞式方法在任务完成前就返回。</li></ul><h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。-1"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。-1" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul><li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</li><li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</li></ul><h1 id="我们可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#我们可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="我们可以使用CocurrentHashMap来代替Hashtable吗？"></a>我们可以使用CocurrentHashMap来代替Hashtable吗？</h1><ul><li>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。</li><li>ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。</li><li>它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。</li><li>因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。</li><li>简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/1e7ca447b43e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/1e7ca447b43e.html" class="post-title-link" itemprop="url">分布式</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:04:09" itemprop="dateCreated datePublished" datetime="2023-12-20T15:04:09+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-28 12:54:48" itemprop="dateModified" datetime="2023-12-28T12:54:48+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="⾼并发原则"><a href="#⾼并发原则" class="headerlink" title="⾼并发原则"></a>⾼并发原则</h1><h4 id="⽆状态"><a href="#⽆状态" class="headerlink" title="⽆状态"></a>⽆状态</h4><ul><li>⽆状态应⽤，便于⽔平扩展</li><li>有状态配置可通过配置中⼼实现⽆状态</li><li>实践: Disconf、Yaconf、Zookpeer、Consul、Confd、Diamond、Xdiamond等</li></ul><h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><ul><li>系统维度：按照系统功能、业务拆分，如购物⻋，结算，订单等</li><li>功能维度：对系统功能在做细粒度拆分</li><li>读写维度：根据读写⽐例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表</li><li>AOP维度： 根据访问特征，按照AOP进⾏拆分，⽐如商品⻚可分为CDN、⻚⾯渲染系统，CDN就是⼀个AOP系统</li><li>模块维度：对整体代码结构划分Web、Service、DAO</li></ul><h4 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h4><ul><li>服务化演进: 进程内服务-单机远程服务-集群⼿动注册服务-⾃动注册和发现服务-服务的分组、隔离、路由-服务治理</li><li>考虑服务分组、隔离、限流、⿊⽩名单、超时、重试机制、路由、故障补偿等</li><li>实践：利⽤Nginx、HaProxy、LVS等实现负载均衡，ZooKeeper、Consul等实现⾃动注册和发现服</li></ul><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul><li>⽬的: 服务解耦(⼀对多消费)、异步处理、流量削峰缓冲等</li><li>⼤流量缓冲： 牺牲强⼀致性，保证最终⼀致性(案例：库存扣减，现在Redis中做扣减，记录扣减⽇志，通过后台进程将扣减⽇志应⽤到DB)</li><li>数据校对: 解决异步消息机制下消息丢失问题</li></ul><h4 id="数据异构"><a href="#数据异构" class="headerlink" title="数据异构"></a>数据异构</h4><ul><li>数据异构: 通过消息队列机制接收数据变更，原⼦化存储</li><li>数据闭环: 屏蔽多从数据来源，将数据异构存储，形成闭环</li></ul><h4 id="缓存银弹"><a href="#缓存银弹" class="headerlink" title="缓存银弹"></a>缓存银弹</h4><ul><li>⽤户层:<ul><li>DNS缓存</li><li>浏览器DNS缓存</li><li>操作系统DNS缓存</li><li>本地DNS服务商缓存</li><li>DNS服务器缓存</li><li>客户端缓存<ul><li>浏览器缓存(Expires、Cache-Control、Last-Modified、Etag)* App</li><li>客户缓存(js&#x2F;css&#x2F;image…)</li></ul></li></ul></li><li>代理层：<ul><li>CDN缓存(⼀般基于ATS、Varnish、Nginx、Squid等构建,边缘节点-⼆级节点-中⼼节点-源站)</li></ul></li><li>接⼊层：<ul><li>Nginx为例：<ul><li>Proxy_cache： 代理缓存,可以存储到&#x2F;dev&#x2F;shm或者SSD</li><li>FastCGI Cache</li><li>Nginx+Lua+Redis: 业务数据缓存</li></ul></li><li>PHP为例：<ul><li>Opcache： 缓存PHP的Opcodes</li></ul></li></ul></li><li>应⽤层：<ul><li>⻚⾯静态化</li><li>业务数据缓存(Redis&#x2F;Memcached&#x2F;本地⽂件等)</li><li>消息队列</li></ul></li><li>数据层：<ul><li>NoSQL： Redis、Memcache、SSDB等</li><li>MySQL： Innodb&#x2F;MyISAM等Query Cache、Key Cache、Innodb</li><li>Buffer Size等</li></ul></li><li>系统层：<ul><li>CPU : L1&#x2F;L2&#x2F;L3 Cache&#x2F;NUMA</li><li>内存</li><li>磁盘：磁盘本身缓存、dirty_ratio&#x2F;dirty_background_ratio、阵列卡本身缓存</li><li>并发化</li></ul></li></ul><h1 id="⾼可⽤原则"><a href="#⾼可⽤原则" class="headerlink" title="⾼可⽤原则"></a>⾼可⽤原则</h1><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><ul><li>降级开关集中化管理：将开关配置信息推送到各个应⽤</li><li>可降级的多级读服务：如服务调⽤降级为只读本地缓存</li><li>开关前置化：如Nginx+lua(OpenResty)配置降级策略，引流流量；可基于此做灰度策略</li><li>业务降级：⾼并发下，保证核⼼功能，次要功能可由同步改为异步策略或屏蔽功能</li></ul><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul><li>⽬的: 防⽌恶意请求攻击或超出系统峰值</li><li>实践：<ul><li>恶意请求流量只访问到Cache</li><li>穿透后端应⽤的流量使⽤Nginx的limit处理</li><li>恶意IP使⽤Nginx Deny策略或者iptables拒绝</li></ul></li></ul><h4 id="切流量"><a href="#切流量" class="headerlink" title="切流量"></a>切流量</h4><ul><li>⽬的：屏蔽故障机器</li><li>实践:<ul><li>DNS: 更改域名解析⼊⼝，如DNSPOD可以添加备⽤IP，正常IP故障时，会⾃主切换到备⽤地址;⽣效实践较慢</li><li>HttpDNS: 为了绕过运营商LocalDNS实现的精准流量调度</li><li>LVS&#x2F;HaProxy&#x2F;Nginx: 摘除故障节点</li></ul></li></ul><h4 id="可回滚"><a href="#可回滚" class="headerlink" title="可回滚"></a>可回滚</h4><ul><li>发布版本失败时可随时快速回退到上⼀个稳定版本</li></ul><h1 id="业务设计原则"><a href="#业务设计原则" class="headerlink" title="业务设计原则"></a>业务设计原则</h1><ul><li>防重设计</li><li>幂等设计</li><li>流程定义</li><li>状态与状态机</li><li>后台系统操作可反馈</li><li>后台系统审批化</li><li>⽂档注释</li><li>备份</li></ul><h1 id="分布式与集群的区别"><a href="#分布式与集群的区别" class="headerlink" title="分布式与集群的区别"></a>分布式与集群的区别</h1><ul><li>分布式是指将不同的业务分布在不同的地⽅</li><li>⽽集群指的是将⼏台服务器集中在⼀起，实现同⼀业务</li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h4 id="⼆阶段提交"><a href="#⼆阶段提交" class="headerlink" title="⼆阶段提交"></a>⼆阶段提交</h4><ul><li>概念：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中⽌操作。</li><li>作⽤：主要保证了分布式事务的原⼦性；第⼀阶段为准备阶段，第⼆阶段为提交阶段；</li><li>缺点：不仅要锁住参与者的所有资源，⽽且要锁住协调者资源，开销⼤。⼀句话总结就是：2PC效率很低，对⾼并发很不友好。</li></ul><h4 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h4><ul><li>概念：三阶段提交协议在协调者和参与者中都引⼊超时机制，并且把两阶段提交协议的第⼀个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</li><li>缺点：如果进⼊PreCommit后，Coordinator发出的是abort请求，假设只有⼀个Cohort收到并进⾏了abort操作，⽽其他对于系统状态未知的Cohort会根据3PC选择继续Commit，此时系统状态发⽣不⼀致性。</li></ul><h4 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h4><ul><li>概念：所谓柔性事务是相对强制锁表的刚性事务⽽⾔。流程⼊下：服务器A的事务如果执⾏顺利，那么事务A就先⾏提交，如果事务B也执⾏顺利，则事务B也提交，整个事务就算完成。但是如果事务B执⾏失败，事务B本身回滚，这时事务A已经被提交，所以需要执⾏⼀个补偿操作，将已经提交的事务A执⾏的操作作反操作，恢复到未执⾏前事务A的状态。</li><li>缺点：业务侵⼊性太强，还要补偿操作，缺乏普遍性，没法⼤规模推⼴。</li></ul><h1 id="消息最终⼀致性解决⽅案之RabbitMQ实现："><a href="#消息最终⼀致性解决⽅案之RabbitMQ实现：" class="headerlink" title="消息最终⼀致性解决⽅案之RabbitMQ实现："></a>消息最终⼀致性解决⽅案之RabbitMQ实现：</h1><ul><li>实现：发送⽅确认+消息持久化+消费者确认。</li></ul><h1 id="什么时候⽤到分布式开发："><a href="#什么时候⽤到分布式开发：" class="headerlink" title="什么时候⽤到分布式开发："></a>什么时候⽤到分布式开发：</h1><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>模块解耦：把模块拆分,使⽤接⼝通信,降低模块之间的耦合度.</li><li>项⽬拆分，不同团队负责不同的⼦项⽬：把项⽬拆分成若⼲个⼦项⽬,不同的团队负责不同的⼦项⽬.</li><li>提⾼项⽬扩展性：增加功能时只需要再增加⼀个⼦项⽬,调⽤其他系统的接⼝就可以。</li><li>分布式部署：可以灵活的进⾏分布式部署.</li><li>提⾼代码的复⽤性：⽐如service层,如果不采⽤分布式rest服务⽅式架构就会在⼿机wap商城,信商城,pc,android，ios每个端都要写⼀个service层逻辑,开发量⼤,难以维护⼀起升级,这时候可以采⽤分布式rest服务⽅式,公⽤⼀个service层。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>系统之间的交互要使⽤远程通信,接⼝开发增⼤⼯作量；</li><li>⽹络请求有延时；</li><li>事务处理⽐较麻烦，需要使⽤分布式事务。</li></ul><h1 id="cdn（异地多活）"><a href="#cdn（异地多活）" class="headerlink" title="cdn（异地多活）"></a>cdn（异地多活）</h1><h4 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h4><ul><li>异地多活指分布在异地的多个站点同时对外提供服务的业务场景。异地多活是⾼可⽤架构设计的⼀种，与传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。</li><li>两地容灾切换⽅案：容灾是异地多活中最核⼼的⼀环， 以两个城市异地多活部署架构图为例，在两个城市（城市1位于华南1地域、城市2位于华东1地域）均部署⼀套完整的业务系统。下单业务按照“user_id”％ 100 进⾏分⽚，在正常情况下：<ul><li>[00~49]分⽚所有的读写都在城市1的数据库实例主库。</li><li>[50～99]分⽚所有的读写都在城市2的数据库实例主库。</li><li>“城市1的数据库实例主库”和 “城市2的数据库实例主库”建⽴DTS双向复制。</li><li>当出现异常时，需要进⾏容灾切换。可能出现的场景有以下4种：<ul><li>将第2种、第3种异常情况，全部采⽤第2种⽅案进⾏处理，那么不管是所有的APP Server异常、所有的数据库异常、整个城市异常，就直接按照城市级容灾⽅案处理，直接将APP Server、数据库切换到到另⼀个城市。</li></ul></li></ul></li></ul><h4 id="多城异地多活"><a href="#多城异地多活" class="headerlink" title="多城异地多活"></a>多城异地多活</h4><ul><li>多城市异地多活模式指的是3个或者3个以上城市间部署异地多活</li><li>该模式下存在中⼼节点和单元节点：<ul><li>中⼼节点：指单元节点的增量数据都需要实时的同步到中⼼节点，同时中⼼节点将所有分⽚的增量数据同步到其他单元节点。</li><li>单元节点：即对应分⽚读写的节点，该节点需要将该分⽚的增量同步到中⼼节点，并且接收来⾃于中⼼节点的其他分⽚的增量数据。</li></ul></li></ul><h1 id="分布式环境下宕机的处理⽅案"><a href="#分布式环境下宕机的处理⽅案" class="headerlink" title="分布式环境下宕机的处理⽅案"></a>分布式环境下宕机的处理⽅案</h1><ul><li>dubbo：服务器宕机，zk临时被删除；</li><li>springcloud：每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。</li><li>apm监控</li></ul><h1 id="分布式、高并发、多线程，到底有什么区别？"><a href="#分布式、高并发、多线程，到底有什么区别？" class="headerlink" title="分布式、高并发、多线程，到底有什么区别？"></a>分布式、高并发、多线程，到底有什么区别？</h1><ul><li>当提起这三个词的时候，是不是很多人都认为分布式&#x3D;高并发&#x3D;多线程？</li><li>在一开始接触的时候，不少人都会将三者混淆，误以为所谓的分布式高并发的系统就是能同时供海量用户访问，而采用多线程手段不就是可以提供系统的并发能力吗</li><li>实际上，他们三个总是相伴而生，但侧重点又有不同</li></ul><h4 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h4><ul><li>分布式更多的一个概念，是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段</li><li>该领域需要解决的问题极多，在不同的技术层面上，又包括：分布式文件系统、分布式缓存、分布式数据库、分布式计算等，一些名词如Hadoop、zookeeper、MQ等都跟分布式有关</li><li>从理念上讲，分布式的实现有两种形式：<ul><li>水平扩展：当一台机器扛不住流量时，就通过添加机器的方式，将流量平分到所有服务器上，所有机器都可以提供相当的服务；</li><li>垂直拆分：前端有多种查询需求时，一台机器扛不住，可以将不同的需求分发到不同的机器上，比如A机器处理余票查询的请求，B机器处理支付的请求。</li></ul></li></ul><h4 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h4><ul><li>相对于分布式来讲，高并发在解决的问题上会集中一些，其反应的是同时有多少量：比如在线直播服务，同时有上万人观看</li><li>高并发可以通过分布式技术去解决，将并发流量分不到不同的物理服务器上</li><li>但除此之外，还可以有很多其他优化手段：比如使用缓存系统，将所有的，静态内容放到CDN等；还可以使用多线程技术将一台服务器的服务能力最大化。</li></ul><h4 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h4><ul><li>多线程是指从软件或者硬件上实现多个线程并发执行的技术</li><li>它更多的是解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行（实际是交替运行的）</li><li>多线程解决的问题是最明确的，手段也是比较单一的，基本上遇到的最大问题就是线程安全</li><li>在JAVA语言中，需要对JVM内存模型、指令重排等深入了解，才能写出一份高质量的多线程代码。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>分布式是从物理资源的角度去将不同的机器组成一个整体对外服务，技术范围非常广且难度非常大，有了这个基础，高并发、高吞吐等系统很容易构建；</li><li>高并发是从业务角度去描述系统的能力，实现高并发的手段可以采用分布式，也可以采用诸如缓存、CDN等，当然也包括多线程；</li><li>多线程则聚焦于如何使用编程语言将CPU调度能力最大化</li></ul><h1 id="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"><a href="#分布式服务接口的幂等性如何设计（比如不能重复扣款）？" class="headerlink" title="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"></a>分布式服务接口的幂等性如何设计（比如不能重复扣款）？</h1><ul><li>这个不是技术问题，这个没有通用的一个方法，这个应该结合业务来保证幂等性。</li><li>所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</li><li>其实保证幂等性主要是三点：<ul><li>对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单id，一个订单 id 最多支付一次。</li><li>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql中记录个状态，比如支付之前记录一条这个订单的支付流水。</li><li>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。</li></ul></li><li>实际运作过程中，你要结合自己的业务来，比如说利用 redis，用 orderId作为唯一键</li><li>只有成功插入这个支付流水，才可以执行实际的支付扣款。</li><li>要求是支付一个订单，必须插入一条支付流水，<code>order_id</code> 建一个唯一键unique key。你在支付一个订单之前，先插入一条支付流水，<code>order_id</code>就已经进去了。你就可以写一个标识到 redis 里面去，<code>set order_id payed</code>，下一次重复请求过来了，先查 redis 的 order_id 对应的 value，如果是payed就说明已经支付过了，你就别重复支付了。</li></ul><h1 id="分布式事务了解吗？你们是如何解决分布式事务问题的？"><a href="#分布式事务了解吗？你们是如何解决分布式事务问题的？" class="headerlink" title="分布式事务了解吗？你们是如何解决分布式事务问题的？"></a>分布式事务了解吗？你们是如何解决分布式事务问题的？</h1><ul><li>分布式事务的实现主要有以下 5 种方案：</li><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h4 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案&#x2F;XA方案"></a>两阶段提交方案&#x2F;XA方案</h4><ul><li>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</li><li>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。</li><li>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</li><li>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</li><li>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</li><li>distributed-transacion-XA</li></ul><h4 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h4><ul><li>TCC 的全称是：Try、Confirm、Cancel。<ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。</li><li>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul></li><li>这种方案说实话几乎很少人使用，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大。</li><li>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</li><li>而且最好是你的各个业务执行的时间都比较短。</li><li>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</li><li>distributed-transacion-TCC</li></ul><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><ul><li>本地消息表其实是国外的 ebay 搞出来的这么一套思想。这个大概意思是这样的：<ul><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B那边成功为止。</li></ul></li><li>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</li><li>distributed-transaction-local-message-table</li></ul><h4 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h4><ul><li>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ就支持消息事务。大概的意思就是：<ul><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li></ul></li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用RocketMQ支持的，要不你就自己基于类似ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li><li>distributed-transaction-reliable-message</li></ul><h4 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h4><ul><li>这个方案的大致意思就是：<ul><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ul></li></ul><h4 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h4><ul><li>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性</li><li>然后其他的一些场景基于阿里的 RocketMQ 来实现了分布式事务。</li><li>找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案</li><li>如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</li></ul><h1 id="分步式锁"><a href="#分步式锁" class="headerlink" title="分步式锁"></a>分步式锁</h1><ul><li>基本原理：⽤⼀个状态值表示锁，对锁的占⽤和释放通过状态值来标识。</li></ul><h4 id="三种分布式锁："><a href="#三种分布式锁：" class="headerlink" title="三种分布式锁："></a>三种分布式锁：</h4><h5 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h5><ul><li>基于zookeeper瞬时有序节点实现的分布式锁</li><li>⼤致思想即为：每个客户端对某个功能加锁时，在zookeeper上的与该功能对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点</li><li>判断是否获取锁的⽅式很简单，只需要判断有序节点中序号最⼩的⼀个</li><li>当释放锁的时候，只需将这个瞬时节点删除即可</li><li>同时，其可以避免服务宕机导致的锁⽆法释放，⽽产⽣的死锁问题。</li><li>优点<ul><li>锁安全性⾼，zk可持久化，且能实时监听获取锁的客户端状态</li><li>⼀旦客户端宕机，则瞬时节点随之消失，zk因⽽能第⼀时间释放锁</li><li>这也省去了⽤分布式缓存实现锁的过程中需要加⼊超时时间判断的这⼀逻辑。</li></ul></li><li>缺点<ul><li>性能开销⽐较⾼</li><li>因为其需要动态产⽣、销毁瞬时节点来实现锁功能</li><li>所以不太适合直接提供给⾼并发的场景使⽤</li></ul></li><li>实现<ul><li>可以直接采⽤zookeeper第三⽅库curator即可⽅便地实现分布式锁</li></ul></li><li>适⽤场景<ul><li>对可靠性要求⾮常⾼，且并发程度不⾼的场景下使⽤</li><li>如核⼼数据的定时全量&#x2F;增量同步等。</li></ul></li></ul><h5 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h5><ul><li>memcached带有add函数，利⽤add函数的特性即可实现分布式锁</li><li>add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。⽽add的话则相反，add会添加第⼀个到达的值，并返回true，后续的添加则都会返回false。利⽤该点即可很轻松地实现分布式锁。</li><li>优点：并发⾼效</li><li>缺点<ul><li>memcached采⽤列⼊LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。</li><li>memcached⽆法持久化，⼀旦重启，将导致信息丢失。</li></ul></li><li>使⽤场景<ul><li>⾼并发场景。需要<ul><li>加上超时时间避免死锁</li><li>提供⾜够⽀撑锁服务的内存空间</li><li>稳定的集群化管理</li></ul></li></ul></li></ul><h5 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h5><ul><li>redis分布式锁即可以结合zk分布式锁锁⾼度安全和memcached并发场景下效率很好的优点</li><li>其实现⽅式和memcached类似，采⽤setnx即可实现</li><li>需要注意的是，这⾥的redis也需要设置超时时间，以避免死锁。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><a class="page-number" href="/default-index/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/4/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">2.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">36:53</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>