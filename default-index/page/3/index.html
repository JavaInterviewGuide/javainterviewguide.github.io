<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/3/index.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/3/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">38</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">29</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">52</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/0777702c9d7f.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/0777702c9d7f.html" class="post-title-link" itemprop="url">RPC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:06:30" itemprop="dateCreated datePublished" datetime="2023-12-20T16:06:30+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 16:13:22" itemprop="dateModified" datetime="2023-12-24T16:13:22+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rpc/" itemprop="url" rel="index"><span itemprop="name">rpc</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h1><ul><li>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。</li><li>当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。</li><li>除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</li><li>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。</li><li>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</li><li>RPC 在我们熟知的各种中间件中都有它的身影。</li><li>Nginx&#x2F;Redis&#x2F;MySQL&#x2F;Dubbo&#x2F;Hadoop&#x2F;Spark&#x2F;Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的</li><li>我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。</li></ul><h1 id="Nginx-与-RPC"><a href="#Nginx-与-RPC" class="headerlink" title="Nginx 与 RPC"></a>Nginx 与 RPC</h1><ul><li>Ngnix 是互联网企业使用最为广泛的代理服务器。</li><li>它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务</li><li>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互</li><li>也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。</li><li>你说的没错，不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</li><li>uWSGI 是著名的 Python 容器，使用它可以启动 uwsgi 协议的服务器对外提供服务。</li><li>uwsgi 通讯协议在 Python 语言体系里使用非常普遍，如果一个企业内部使用 Python 语言栈搭建 Web 服务，那么他们在生产环境部署 Python 应用的时候不是在使用 HTTP 协议就是在使用 uwsgi 协议来和 Nginx 之间建立通讯。</li><li>Fastcgi 协议在 PHP 语言体系里非常常见，Nginx 和 PHP-fpm 进程之间一般较常使用 Fastcgi 协议进行通讯。</li></ul><h1 id="Hadoop-与-RPC"><a href="#Hadoop-与-RPC" class="headerlink" title="Hadoop 与 RPC"></a>Hadoop 与 RPC</h1><ul><li>在大数据技术领域，RPC 也占据了非常重要的地位</li><li>大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在</li><li>大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。</li><li>比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</li></ul><h1 id="TensorFlow-与-RPC"><a href="#TensorFlow-与-RPC" class="headerlink" title="TensorFlow 与 RPC"></a>TensorFlow 与 RPC</h1><ul><li>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯</li><li>Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</li></ul><h1 id="Http-与-RPC"><a href="#Http-与-RPC" class="headerlink" title="Http 与 RPC"></a>Http 与 RPC</h1><ul><li>HTTP 调用其实也是一种特殊的 RPC</li><li>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。</li><li>HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</li><li>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了</li><li>所以在后文我们不再明确强调 RPC 和 HTTP 请求调用之间的细微区别了，直接统一称之为 RPC。</li></ul><h1 id="HTTP-VS-RPC-（普通话-VS-方言）"><a href="#HTTP-VS-RPC-（普通话-VS-方言）" class="headerlink" title="HTTP VS RPC （普通话 VS 方言）"></a>HTTP VS RPC （普通话 VS 方言）</h1><ul><li>HTTP 与 RPC 的关系就好比普通话与方言的关系</li><li>要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本</li><li>但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源</li><li>整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。</li><li>如果再深入一点说，普通话本质上也是一种方言，只不过它是官方的方言，使用最为广泛的方言，相比而言其它方言都是小语种，小语种之中也会有几个使用比较广泛比较特色的方言占比也会比较大。</li><li>这就好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</li></ul><h1 id="换个角度看世界"><a href="#换个角度看世界" class="headerlink" title="换个角度看世界"></a>换个角度看世界</h1><ul><li>分布式子系统交互方案，除了 RPC 技术之外还有数据库、消息队列和缓存。但其实这三者本质上是 RPC 技术的一个应用组合。</li><li>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。</li><li>如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL</li><li>在互联网企业里一般都会使用这种主从读写分离的数据库</li><li>一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来</li><li>这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/235b69f65d9c.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/235b69f65d9c.html" class="post-title-link" itemprop="url">Spring MVC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:05:16" itemprop="dateCreated datePublished" datetime="2023-12-20T16:05:16+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-27 16:25:51" itemprop="dateModified" datetime="2023-12-27T16:25:51+08:00">2023-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring-MVC/" itemprop="url" rel="index"><span itemprop="name">Spring MVC</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是SpringMvc？"><a href="#什么是SpringMvc？" class="headerlink" title="什么是SpringMvc？"></a>什么是SpringMvc？</h1><ul><li>SpringMvc是spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。</li></ul><h1 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h1><ul><li>它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成. </li><li>不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的) </li><li>可以任意使用各种视图技术,而不仅仅局限于JSP </li><li>支持各种请求资源的映射策略 </li><li>它应是易于扩展的</li></ul><h1 id="SpringMVC工作原理？"><a href="#SpringMVC工作原理？" class="headerlink" title="SpringMVC工作原理？"></a>SpringMVC工作原理？</h1><h4 id="简要回答"><a href="#简要回答" class="headerlink" title="简要回答"></a>简要回答</h4><ul><li>客户端发送请求到DispatcherServlet </li><li>DispatcherServlet查询handlerMapping找到处理请求的Controller </li><li>Controller调用业务逻辑后，返回ModelAndView </li><li>DispatcherServlet查询ModelAndView，找到指定视图 </li><li>视图将结果返回到客户端</li></ul><h4 id="详细回答"><a href="#详细回答" class="headerlink" title="详细回答"></a>详细回答</h4><ul><li>用户发送请求至前端控制器DispatcherServlet。 </li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li><li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li><li>Controller执行完成返回ModelAndView。 </li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 </li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li><li>ViewReslover解析后返回具体View。 </li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li><li>DispatcherServlet响应用户。</li></ul><h4 id="详细回答2"><a href="#详细回答2" class="headerlink" title="详细回答2"></a>详细回答2</h4><ul><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet调用HandlerAdapter处理器适配器</li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户</li></ul><h1 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h1><ul><li><p>在web.xml中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li><li><p>以上可以解决post请求乱码问题</p></li><li><p>对于get请求中文参数出现乱码解决方法有两个：</p><ul><li><p>修改tomcat配置文件添加编码与工程编码一致，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>另外一种方法对参数进行重新编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</p></li></ul><h1 id="SpringMVC与Struts2的主要区别？"><a href="#SpringMVC与Struts2的主要区别？" class="headerlink" title="SpringMVC与Struts2的主要区别？"></a>SpringMVC与Struts2的主要区别？</h1><ul><li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li><li>springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li><li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。Jsp视图解析器默认使用jstl。</li><li>springmvc是基于方法开发，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li></ul><h1 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h1><ul><li>是单例模式</li><li>所以在多线程访问的时候有线程安全问题</li><li>不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</li></ul><h1 id="SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</h1><ul><li>一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。</li></ul><h1 id="RequestMapping注解用在类上面有什么作用？"><a href="#RequestMapping注解用在类上面有什么作用？" class="headerlink" title="@RequestMapping注解用在类上面有什么作用？"></a>@RequestMapping注解用在类上面有什么作用？</h1><ul><li>是一个用来处理请求地址映射的注解，可用于类或方法上</li><li>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li></ul><h1 id="怎么样把某个请求映射到特定的方法上面？"><a href="#怎么样把某个请求映射到特定的方法上面？" class="headerlink" title="怎么样把某个请求映射到特定的方法上面？"></a>怎么样把某个请求映射到特定的方法上面？</h1><ul><li>直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径</li></ul><h1 id="如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？"><a href="#如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？" class="headerlink" title="如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？"></a>如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？</h1><ul><li>可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET</li></ul><h1 id="怎么样在方法里面得到Request-或者Session？"><a href="#怎么样在方法里面得到Request-或者Session？" class="headerlink" title="怎么样在方法里面得到Request,或者Session？"></a>怎么样在方法里面得到Request,或者Session？</h1><ul><li>直接在方法的形参中声明request,SpringMvc就自动把request对象传入</li></ul><h1 id="我想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#我想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="我想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>我想在拦截的方法里面得到从前台传入的参数,怎么得到？</h1><ul><li>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样</li></ul><h1 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h1><ul><li>直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</li></ul><h1 id="SpringMvc中函数的返回值是什么？"><a href="#SpringMvc中函数的返回值是什么？" class="headerlink" title="SpringMvc中函数的返回值是什么？"></a>SpringMvc中函数的返回值是什么？</h1><ul><li>返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。</li></ul><h1 id="SpringMVC怎么样设定重定向和转发的？"><a href="#SpringMVC怎么样设定重定向和转发的？" class="headerlink" title="SpringMVC怎么样设定重定向和转发的？"></a>SpringMVC怎么样设定重定向和转发的？</h1><ul><li>在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name&#x3D;method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:<a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a>“</li></ul><h1 id="SpringMvc用什么对象从后台向前台传递数据的？"><a href="#SpringMvc用什么对象从后台向前台传递数据的？" class="headerlink" title="SpringMvc用什么对象从后台向前台传递数据的？"></a>SpringMvc用什么对象从后台向前台传递数据的？</h1><ul><li>通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。</li></ul><h1 id="SpringMvc中有个类把视图和数据都合并的一起的-叫什么？"><a href="#SpringMvc中有个类把视图和数据都合并的一起的-叫什么？" class="headerlink" title="SpringMvc中有个类把视图和数据都合并的一起的,叫什么？"></a>SpringMvc中有个类把视图和数据都合并的一起的,叫什么？</h1><ul><li>叫ModelAndView。</li></ul><h1 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h1><ul><li>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key</li></ul><h1 id="SpringMvc怎么和AJAX相互调用的？"><a href="#SpringMvc怎么和AJAX相互调用的？" class="headerlink" title="SpringMvc怎么和AJAX相互调用的？"></a>SpringMvc怎么和AJAX相互调用的？</h1><ul><li>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。 </li><li>具体步骤如下 ：<ul><li>加入Jackson.jar </li><li>在配置文件中配置json的映射 </li><li>在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</li></ul></li></ul><h1 id="当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？"><a href="#当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？" class="headerlink" title="当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？"></a>当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</h1><ul><li>要加上@ResponseBody注解</li></ul><h1 id="SpringMvc里面拦截器是怎么写的"><a href="#SpringMvc里面拦截器是怎么写的" class="headerlink" title="SpringMvc里面拦截器是怎么写的"></a>SpringMvc里面拦截器是怎么写的</h1><ul><li>有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;    </span><br><span class="line">    &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;   </span><br><span class="line">    &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.et.action.MyHandlerInterceptor&quot;&gt;&lt;/bean&gt;    </span><br><span class="line">    &lt;!-- 只针对部分请求拦截 --&gt;    </span><br><span class="line">    &lt;mvc:interceptor&gt;       </span><br><span class="line">        &lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;       </span><br><span class="line">        &lt;bean class=&quot;com.et.action.MyHandlerInterceptorAdapter&quot; /&gt;  </span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="讲下SpringMvc的执行流程"><a href="#讲下SpringMvc的执行流程" class="headerlink" title="讲下SpringMvc的执行流程"></a>讲下SpringMvc的执行流程</h1><ul><li>系统启动的时候根据配置文件创建spring的容器</li><li>首先是发送http请求到核心控制器disPatherServlet</li><li>spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类</li><li>在进业务类时进行数据封装，在封装前可能会涉及到类型转换</li><li>执行完业务类后使用ModelAndView进行视图转发</li><li>数据放在model中，用map传递数据进行页面显示</li></ul><h1 id="框架的优缺点SpringMVC-Struts2等…"><a href="#框架的优缺点SpringMVC-Struts2等…" class="headerlink" title="框架的优缺点SpringMVC,Struts2等…"></a>框架的优缺点SpringMVC,Struts2等…</h1><ul><li>Struts2是类级别拦截，参数为类中所有⽅法共有，⼀个Action对应⼀个request上下⽂，SpringMVC是⽅法级别拦截，参数为对应⽅法所有；</li><li>由于Struts2需要针对每个request进⾏封装，把request，session等servlet⽣命周期的变量封装成⼀个⼀个Map，供给每个Action使⽤，并保证线程安全，所以在原则上，是⽐较耗费内存的。</li><li>拦截器实现机制上，Struts2有以⾃⼰的interceptor机制，SpringMVC⽤的是独⽴的AOP⽅式，这样导致Struts2的配置⽂件量还是⽐SpringMVC⼤。</li><li>SpringMVC的⼊⼝是servlet，⽽Struts2是filter</li><li>SpringMVC集成了Ajax，使⽤⾮常⽅便，只需⼀个注解@ResponseBody就可以实现，然后直接返回响应⽂本即可，⽽Struts2拦截器集成了Ajax，在Action中处理时⼀般必须安装插件或者⾃⼰写代码集成进去，使⽤起来也相对不⽅便。</li><li>SpringMVC开发效率和性能⾼于Struts2。</li><li>SpringMVC配置少，零配置。</li></ul><h1 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h1><ul><li>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序</li><li>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/c9fa4a3e43dd.html" class="post-title-link" itemprop="url">Spring</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:03:58" itemprop="dateCreated datePublished" datetime="2023-12-20T16:03:58+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-27 17:13:50" itemprop="dateModified" datetime="2023-12-27T17:13:50+08:00">2023-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>25k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>22 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><ul><li>AOP(Aspect-Oriented Programming), 即 面向切面编程</li><li>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题</li><li>这些交叉问题与应用程序的主要业务逻辑不同</li><li>因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。</li></ul><h1 id="Spring中Bean的⽣命周期。"><a href="#Spring中Bean的⽣命周期。" class="headerlink" title="Spring中Bean的⽣命周期。"></a>Spring中Bean的⽣命周期。</h1><ul><li>Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅法-》调⽤InitializationBean的afterPropertiesSet()的⽅法-》调⽤定制的初始化⽅法callCustom的init-method-》调⽤BeanPostProsessor的后初始化⽅法-》Bean可以使⽤了 -》 容器关闭-》 调⽤DisposableBean的destroy⽅法-》调⽤定制的销毁⽅法CallCustom的destroy-method。</li><li>Spring对Bean进⾏实例化（相当于程序中的new Xx()）</li><li>Spring将值和Bean的引⽤注⼊进Bean对应的属性中</li><li>如果Bean实现了BeanNameAware接⼝，Spring将Bean的ID传递给setBeanName()⽅法（实现BeanNameAware清主要是为了通过Bean的引⽤来获得Bean的ID，⼀般业务中是很少有⽤到Bean的ID的）</li><li>如果Bean实现了BeanFactoryAware接⼝，Spring将调⽤setBeanDactory(BeanFactory bf)⽅法并把BeanFactory容器实例作为参数传⼊。（实现BeanFactoryAware 主要⽬的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</li><li>如果Bean实现了ApplicationContextAwaer接⼝，Spring容器将调⽤setApplicationContext(ApplicationContext ctx)⽅法，把y应⽤上下⽂作为参数传⼊.(作⽤与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调⽤setApplicationContext⽅法时会把它⾃⼰作为setApplicationContext 的参数传⼊，⽽Spring容器在调⽤setBeanDactory前需要程序员⾃⼰指定（注⼊）setBeanDactory⾥的参数BeanFactory )</li><li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessBeforeInitialization（预初始化）⽅法（作⽤是在Bean实例创建成功后对进⾏增强处理，如对Bean进⾏修改，增加某个功能）7.如果Bean实现了InitializingBean接⼝，Spring将调⽤它们的afterPropertiesSet⽅法，作⽤与在配置⽂件中对Bean使⽤init-method声明初始化的作⽤⼀样，都是在Bean的全部属性设置成功后执⾏的初始化⽅法。</li><li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessAfterInitialization（后初始化）⽅法（作⽤与7的⼀样，只不过7是在Bean初始化前执⾏的，⽽这个是在Bean初始化后执⾏的，时机不同 ）</li><li>经过以上的⼯作后，Bean将⼀直驻留在应⽤上下⽂中给应⽤使⽤，直到应⽤上下⽂被销毁</li><li>如果Bean实现了DispostbleBean接⼝，Spring将调⽤它的destory⽅法，作⽤与在配置⽂件中对Bean使⽤destory￾method属性的作⽤⼀样，都是在Bean实例销毁前执⾏的⽅法。</li></ul><h1 id="Spring-AOP解决了什么问题？怎么实现的？"><a href="#Spring-AOP解决了什么问题？怎么实现的？" class="headerlink" title="Spring AOP解决了什么问题？怎么实现的？"></a>Spring AOP解决了什么问题？怎么实现的？</h1><ul><li>作⽤<ul><li>AOP技术，利⽤⼀种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共⾏为封装到⼀个可重⽤模块，并将其名为“Aspect”，即⽅⾯</li><li>所谓“⽅⾯”，简单地说，就是将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li></ul></li><li>实现：<ul><li>⼀是采⽤动态代理技术，利⽤截取消息的⽅式，对该消息进⾏装饰，以取代原有对象⾏为的执⾏；</li><li>⼆是采⽤静态织⼊的⽅式，引⼊特定的语法创建“⽅⾯”，从⽽使得编译器可以在编译期间织⼊有关“⽅⾯”的代码。</li></ul></li><li>使⽤场景：<ul><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading　懒加载</li><li>Debugging　　调试</li><li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li><li>Performance optimization　性能优化</li><li>Persistence　　持久化</li><li>Resource pooling　资源池</li><li>Synchronization　同步</li><li>Transactions 事务</li></ul></li><li>⼏个概念：<ul><li>切⾯（Aspect）：对象操作过程中的截⾯，这可能是AOP中最为关键的术语。切⾯所要做的事就是专注于各⾃领域的逻辑实现，这样可以使得开发逻辑更加清晰，更加适合专业的分⼯合作。由于切⾯的隔离性，降低了耦合，这样就可以在不同的应⽤中将各个切⾯组合使⽤，从⽽是代码重⽤性⼤⼤增加。</li><li>连接点：程序运⾏过程中的某个阶段点，如某个⽅法的调⽤，或者异常的抛出。</li><li>处理逻辑（Advice）：在某⼀个连接点所采⽤的处理逻辑，处理逻辑的调⽤模式通常有三种：<ul><li>Around 在连接点前后插⼊预处理过程和后处理过程。</li><li>Before 仅在连接点钱出⼊处理过程。</li><li>Throw 在连接点抛出异常时进⾏异常处理。</li></ul></li><li>切点（PointCut）：⼀系列连接点的集合，它指明处理逻辑将在合适触发。</li></ul></li></ul><h1 id="Spring事务的传播属性是怎么回事？它会影响什么？"><a href="#Spring事务的传播属性是怎么回事？它会影响什么？" class="headerlink" title="Spring事务的传播属性是怎么回事？它会影响什么？"></a>Spring事务的传播属性是怎么回事？它会影响什么？</h1><ul><li>七个事务传播属性：<ul><li>PROPAGATION_REQUIRED – ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。</li><li>PROPAGATION_SUPPORTS – ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</li><li>PROPAGATION_MANDATORY – ⽀持当前事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATIONREQUIRESNEW – 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATIONNOTSUPPORTED – 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER – 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</li><li>PROPAGATIONNESTED – 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与PROPAGATIONREQUIRED类似的操作。</li></ul></li><li>五个隔离级别：<ul><li>ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.</li><li>另外四个与JDBC的隔离级别相对应：<ul><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种隔离级别会产⽣脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不可重复读外，还避免了幻读。</li></ul></li></ul></li><li>关键词：<ul><li>幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；</li><li>不可重复读：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；</li><li>脏读：事务1更新了记录，但没有提交，事务2读取了更新后的⾏，然后事务T1回滚，现在T2读取⽆效。</li></ul></li></ul><h1 id="Spring中BeanFactory和FactoryBean有什么区别？"><a href="#Spring中BeanFactory和FactoryBean有什么区别？" class="headerlink" title="Spring中BeanFactory和FactoryBean有什么区别？"></a>Spring中BeanFactory和FactoryBean有什么区别？</h1><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul><li>以Factory结尾，表示它是⼀个⼯⼚类(接⼝)，⽤于管理Bean的⼀个⼯⼚</li><li>在Spring中，BeanFactory是IOC容器的核⼼接⼝，它的职责包括：实例化、定位、配置应⽤程序中的对象及建⽴这些对象间的依赖。</li></ul><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><ul><li>以Bean结尾，表示它是⼀个Bean，不同于普通Bean的是：它是实现了FactoryBean接⼝的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽不是FactoryBean本身</li><li>如果要获取FactoryBean对象，请在id前⾯加⼀个&amp;符号来获取。</li></ul><h1 id="Spring框架中IOC的原理是什么？"><a href="#Spring框架中IOC的原理是什么？" class="headerlink" title="Spring框架中IOC的原理是什么？"></a>Spring框架中IOC的原理是什么？</h1><ul><li>IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。</li><li>在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</li><li>在系统运⾏中，动态的向某个对象提供它所需要的其他对象。</li><li>依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li></ul><h1 id="spring的依赖注⼊有哪⼏种⽅式"><a href="#spring的依赖注⼊有哪⼏种⽅式" class="headerlink" title="spring的依赖注⼊有哪⼏种⽅式"></a>spring的依赖注⼊有哪⼏种⽅式</h1><ul><li>在Spring容器中为⼀个bean配置依赖注⼊有四种⽅式：<ul><li>使⽤属性的setter⽅法注⼊ 这是最常⽤的⽅式；</li><li>使⽤构造器注⼊；</li><li>使⽤Filed注⼊（⽤于注解⽅式）.</li><li>静态、实例⼯⼚的⽅法注⼊</li></ul></li></ul><h1 id="⽤Spring如何实现⼀个切⾯？"><a href="#⽤Spring如何实现⼀个切⾯？" class="headerlink" title="⽤Spring如何实现⼀个切⾯？"></a>⽤Spring如何实现⼀个切⾯？</h1><ul><li>@Aspect</li></ul><h1 id="Spring如何实现数据库事务？"><a href="#Spring如何实现数据库事务？" class="headerlink" title="Spring如何实现数据库事务？"></a>Spring如何实现数据库事务？</h1><ul><li>使⽤@Transactional注解或在配置⽂件⾥⾯配置</li></ul><h1 id="Spring加载次序Classloader"><a href="#Spring加载次序Classloader" class="headerlink" title="Spring加载次序Classloader"></a>Spring加载次序Classloader</h1><ul><li>先构造函数——&gt;然后是bean的set⽅法注⼊——&gt;InitializingBean的afterPropertiesSet⽅法——&gt;init-method⽅法；</li><li>InitializingBean接⼝为bean提供了初始化⽅法的⽅式，它只包括afterPropertiesSet⽅法，凡是继承该接⼝的类，在初始化bean的时候会执⾏该⽅法。系统则是先调⽤afterPropertiesSet⽅法，然后在调⽤init-method中指定的⽅法。</li><li>Spring装配Bean的过程：<ul><li>实例化;</li><li>设置属性值;</li><li>如果实现了BeanNameAware接⼝,调⽤setBeanName设置Bean的ID或者Name;</li><li>如果实现BeanFactoryAware接⼝,调⽤setBeanFactory 设置BeanFactory;</li><li>如果实现ApplicationContextAware,调⽤setApplicationContext设置ApplicationContext</li><li>调⽤BeanPostProcessor的预先初始化⽅法;</li><li>调⽤InitializingBean的afterPropertiesSet()⽅法;</li><li>调⽤定制init-method⽅法；</li><li>调⽤BeanPostProcessor的后初始化⽅法;</li></ul></li><li>Spring容器关闭过程：<ul><li>调⽤DisposableBean的destroy();</li><li>调⽤定制的destroy-method⽅法;</li></ul></li></ul><h1 id="IOC控制反转与DI依赖注⼊"><a href="#IOC控制反转与DI依赖注⼊" class="headerlink" title="IOC控制反转与DI依赖注⼊"></a>IOC控制反转与DI依赖注⼊</h1><ul><li>IOC控制反转：是⼀种将对象交给容器去控制的设计思想，松耦合，⽅便单元测试，增加功能重⽤性；</li><li>DI依赖注⼊：组件之间依赖关系由容器在运⾏期决定，形象的说，即由容器动态的将某个依赖关系注⼊到组件之中。依赖注⼊的⽬的并⾮为软件系统带来更多功能，⽽是为了提升组件重⽤的频率，并为系统搭建⼀个灵活、可扩展的平台。通过依赖注⼊机制，我们只需要通过简单的配置，⽽⽆需任何代码就可指定⽬标需要的资源，完成⾃身的业务逻辑，⽽不需要关⼼具体的资源来⾃何处，由谁实现。</li><li>AOP⾯向切⾯编程：⾯向切⾯编程（AOP）完善spring的依赖注⼊（DI）。</li></ul><h1 id="spring事件的实现原理，写出常⽤的⼏个事件。"><a href="#spring事件的实现原理，写出常⽤的⼏个事件。" class="headerlink" title="spring事件的实现原理，写出常⽤的⼏个事件。"></a>spring事件的实现原理，写出常⽤的⼏个事件。</h1><ul><li>事件机制：Spring中的事件机制是⼀个观察者模式的实现，观察者模式就是⼀个⽬标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。</li><li>spring默认存在的事件：<ul><li>ContextStartedEvent：ApplicationContext启动后触发的事件</li><li>ContextStoppedEvent：ApplicationContext停⽌后触发的事件</li><li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件</li><li>ContextClosedEvent：ApplicationContext关闭后触发的事件</li></ul></li></ul><h1 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h1><ul><li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li><li>它是轻量级、松散耦合的。</li><li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li><li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li></ul><h1 id="列举-Spring-Framework-的优点"><a href="#列举-Spring-Framework-的优点" class="headerlink" title="列举 Spring Framework 的优点"></a>列举 Spring Framework 的优点</h1><ul><li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li><li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li><li>由于依赖注入和控制反转，JDBC 得以简化。</li><li>它是开源免费的。</li></ul><h1 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h1><ul><li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li><li>IOC - 控制反转</li><li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li><li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li><li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li><li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li><li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li></ul><h1 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h1><ul><li>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：<ul><li>Spring Core</li><li>Spring Bean</li><li>SpEL (Spring Expression Language)</li><li>Spring Context</li></ul></li><li>数据访问&#x2F;集成 – 该层提供与数据库交互的支持。它包含以下模块：<ul><li>JDBC (Java DataBase Connectivity)</li><li>ORM (Object Relational Mapping)</li><li>OXM (Object XML Mappers)</li><li>JMS (Java Messaging Service)</li><li>Transaction</li></ul></li><li>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<ul><li>Web</li><li>Web – Servlet</li><li>Web – Socket</li><li>Web – Portlet</li></ul></li><li>AOP – 该层支持面向切面编程<ul><li>Instrumentation – 该层为类检测和类加载器实现提供支持。</li><li>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</li></ul></li><li>几个杂项模块:<ul><li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li><li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li></ul></li></ul><h1 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h1><ul><li>Spring 配置文件是 XML 文件</li><li>该文件主要包含类信息</li><li>它描述了这些类是如何配置以及相互引入的</li><li>但是，XML 配置文件冗长且更加干净</li><li>如果没有正确规划和编写，那么在大项目中管理变得非常困难。</li></ul><h1 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h1><ul><li>接口 - 定义功能。</li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li><li>用户程序 - 它使用接口。</li></ul><h1 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h1><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>用于远程使用。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li></ul><h1 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h1><ul><li>Spring 框架的核心是 Spring 容器</li><li>容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期</li><li>Spring 容器使用依赖注入来管理组成应用程序的组件</li><li>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令</li><li>该元数据可以通过 XML，Java 注解或 Java 代码提供。</li></ul><h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><ul><li>在依赖注入中，您不必创建对象，但必须描述如何创建它们</li><li>您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务</li><li>由 IoC 容器将它们装配在一起。</li></ul><h1 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h1><ul><li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li><li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h1 id="列举-IoC-的一些好处。"><a href="#列举-IoC-的一些好处。" class="headerlink" title="列举 IoC 的一些好处。"></a>列举 IoC 的一些好处。</h1><ul><li>它将最小化应用程序中的代码量。</li><li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li><li>它以最小的影响和最少的侵入机制促进松耦合。</li><li>它支持即时的实例化和延迟加载服务。</li></ul><h1 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h1><ul><li>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</li></ul><h1 id="什么是-spring-bean？"><a href="#什么是-spring-bean？" class="headerlink" title="什么是 spring bean？"></a>什么是 spring bean？</h1><ul><li>它们是构成用户应用程序主干的对象。</li><li>Bean 由 Spring IoC 容器管理。</li><li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li><li>Bean 是基于用户提供给容器的配置元数据创建。</li></ul><h1 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h1><ul><li>基于 xml 配置<ul><li>bean 所需的依赖项和服务在 XML 格式的配置文件中指定</li><li>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项</li><li>它们通常以 bean 标签开头</li></ul></li><li>基于注解配置<ul><li>可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配</li><li>默认情况下，Spring 容器中未打开注解装配</li><li>因此，您需要在使用它之前在 Spring 配置文件中启用它：<a href="context:annotation-config/">context:annotation-config/</a></li></ul></li><li>基于 Java API 配置<ul><li>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul><li>@Bean 注解扮演与<bean>元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul></li></ul></li></ul><h1 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h1><ul><li>Spring bean 支持 5 种 scope：<ul><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li></ul></li><li>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</li></ul><h1 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h1><ul><li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li><li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li><li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li><li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li><li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li><li>如果为 bean 指定了 init 方法（<bean>的 init-method 属性），那么将调用它。</bean></li><li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li><li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li><li>如果为 bean 指定了 destroy 方法（<bean>的 destroy-method 属性），那么将调用它。</bean></li></ul><h1 id="什么是-spring-的内部-bean？"><a href="#什么是-spring-的内部-bean？" class="headerlink" title="什么是 spring 的内部 bean？"></a>什么是 spring 的内部 bean？</h1><ul><li>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean</li><li>为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg>中提供了<bean>元素的使用</bean></constructor-arg></property></li><li>内部 bean 总是匿名的，它们总是作为原型。</li></ul><h1 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h1><ul><li>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配</li><li>Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</li></ul><h1 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h1><ul><li>Spring 容器能够自动装配 bean</li><li>也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</li><li>自动装配的不同模式：<ul><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ul></li></ul><h1 id="自动装配有什么局限？"><a href="#自动装配有什么局限？" class="headerlink" title="自动装配有什么局限？"></a>自动装配有什么局限？</h1><ul><li>覆盖的可能性 - 您始终可以使用<constructor-arg>和<property>设置指定依赖项，这将覆盖自动装配。</property></constructor-arg></li><li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li><li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li></ul><h1 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h1><ul><li>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身</li><li>它可以作为 XML 设置的替代方案。例如：Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul><li>@Bean 注解扮演与元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul></li></ul><h1 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h1><ul><li>默认情况下，Spring 容器中未打开注解装配</li><li>要使用基于注解装配，我们必须通过配置&lt;context：annotation-config &#x2F;&gt; 元素在 Spring 配置文件中启用它</li></ul><h1 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h1><ul><li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li><li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h1 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h1><ul><li>Required 应用于 bean 属性 setter 方法</li><li>此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性</li><li>如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    @Required</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    public string getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h1><ul><li>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配</li><li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean</li><li>默认情况下，它是类型驱动的注入。</li></ul><h1 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h1><ul><li>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</li><li>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</li></ul><h1 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h1><ul><li>RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法</li><li>此注释可应用于两个级别：<ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul></li></ul><h1 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h1><ul><li>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作</li><li>这使得用户容易在持久性技术之间切换</li><li>它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</li></ul><h1 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h1><pre><code>- JdbcTemplate
- SimpleJdbcTemplate
- NamedParameterJdbcTemplate
- SimpleJdbcInsert
- SimpleJdbcCall
</code></pre><h1 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h1><ul><li>我们可以通过两种方式使用 Spring 访问 Hibernate：<ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul></li></ul><h1 id="列举-spring-支持的事务管理类型"><a href="#列举-spring-支持的事务管理类型" class="headerlink" title="列举 spring 支持的事务管理类型"></a>列举 spring 支持的事务管理类型</h1><ul><li>Spring 支持两种类型的事务管理：<ul><li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li><li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li></ul></li></ul><h1 id="spring-支持哪些-ORM-框架"><a href="#spring-支持哪些-ORM-框架" class="headerlink" title="spring 支持哪些 ORM 框架"></a>spring 支持哪些 ORM 框架</h1><ul><li>Hibernate</li><li>iBatis</li><li>JPA</li><li>JDO</li><li>OJB</li></ul><h1 id="指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h1><ul><li>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</li><li>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</li></ul><h1 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h1><ul><li>实现 AOP 的技术，主要分为两大类：<ul><li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul></li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul><li>JDK 动态代理</li><li>CGLIB</li></ul></li></ul></li></ul><h1 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h1><ul><li>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</li><li>Spring AOP 仅支持方法级别的 PointCut；AspectJ 提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</li></ul><h1 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h1><ul><li>将 Advice 应用于目标对象后创建的对象称为代理</li><li>在客户端对象的情况下，目标对象和代理对象是相同的。</li><li>Advice + Target Object &#x3D; Proxy</li></ul><h1 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h1><ul><li>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）</li><li>在 Spring AOP 中，编织在运行时执行</li></ul><h1 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h1><ul><li>WebApplicationContext 是 ApplicationContext 的扩展</li><li>它具有 Web 应用程序所需的一些额外功能</li><li>它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</li></ul><h1 id="IoC-和-DI的区别？"><a href="#IoC-和-DI的区别？" class="headerlink" title="IoC 和 DI的区别？"></a>IoC 和 DI的区别？</h1><ul><li>IoC 控制反转，指将对象的创建权，反转到Spring容器</li><li>DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</li></ul><p> </p><h1 id="BeanFactory-接口和-ApplicationContext-接口有什么区别？"><a href="#BeanFactory-接口和-ApplicationContext-接口有什么区别？" class="headerlink" title="BeanFactory 接口和 ApplicationContext 接口有什么区别？"></a>BeanFactory 接口和 ApplicationContext 接口有什么区别？</h1><ul><li>ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。</li><li>ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));</span><br><span class="line">IHelloService helloService = (IHelloService) beanFactory.getBean(&quot;helloService&quot;);</span><br><span class="line">helloService.sayHello();</span><br></pre></td></tr></table></figure></li></ul><h1 id="spring配置bean实例化有哪些方式？"><a href="#spring配置bean实例化有哪些方式？" class="headerlink" title="spring配置bean实例化有哪些方式？"></a>spring配置bean实例化有哪些方式？</h1><ul><li>使用类构造器实例化(默认无参数)</li><li>使用静态工厂方法实例化(简单工厂模式)</li><li>使用实例工厂方法实例化(工厂方法模式)</li></ul><h1 id="简单的说一下spring的生命周期？"><a href="#简单的说一下spring的生命周期？" class="headerlink" title="简单的说一下spring的生命周期？"></a>简单的说一下spring的生命周期？</h1><ul><li>instantiate bean对象实例化</li><li>populate properties 封装属性</li><li>如果Bean实现BeanNameAware 执行 setBeanName</li><li>如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext</li><li>如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)</li><li>如果Bean实现InitializingBean 执行 afterPropertiesSet </li><li>调用<bean init-method="init"> 指定初始化方法 init</bean></li><li>如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization</li><li>执行业务处理</li><li>如果Bean实现 DisposableBean 执行 destroy</li><li>调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy</bean></li></ul><h1 id="请介绍一下Spring框架中Bean的生命周期和作用域"><a href="#请介绍一下Spring框架中Bean的生命周期和作用域" class="headerlink" title="请介绍一下Spring框架中Bean的生命周期和作用域"></a>请介绍一下Spring框架中Bean的生命周期和作用域</h1><ul><li>bean定义：在配置文件里面用<bean></bean>来进行定义。</li><li>bean初始化，有两种方式初始化:<ul><li>在配置文件中通过指定init-method属性来完成</li><li>实现org.springframwork.beans.factory.InitializingBean接口</li></ul></li><li>bean调用：有三种方式可以得到bean实例，并进行调用</li><li>bean销毁，销毁有两种方式<ul><li>使用配置文件指定的destroy-method属性</li><li>实现org.springframwork.bean.factory.DisposeableBean接口</li></ul></li><li>作用域<ul><li>singleton：当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</li><li>prototype：Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域</li><li>request：在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>global session：在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</li></ul></li></ul><h1 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h1><ul><li>BeanFactory：产生一个新的实例，可以实现单例模式</li><li>BeanWrapper：提供统一的get及set方法</li><li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li></ul><h1 id="Spring里面applicationContext-xml文件能不能改成其他文件名？"><a href="#Spring里面applicationContext-xml文件能不能改成其他文件名？" class="headerlink" title="Spring里面applicationContext.xml文件能不能改成其他文件名？"></a>Spring里面applicationContext.xml文件能不能改成其他文件名？</h1><ul><li>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化</li><li>缺省情况下， 它会在WEB-INF&#x2F;applicationContext.xml文件找Spring的配置</li><li>你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的位置</context-param></li></ul><p>11.Spring里面如何定义hibernate mapping？ </p><ul><li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li></ul><h1 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h1><ul><li>Spring使用ThreadLocal解决线程安全问题</li><li>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域</li><li>就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</li><li>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</li><li>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量</li><li>这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</li><li>而ThreadLocal则从另一个角度来解决多线程的并发访问</li><li>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突</li><li>因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li><li>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</li><li>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换</li><li>但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。</li><li>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li><li>前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li></ul><h1 id="介绍一下Spring的事物管理"><a href="#介绍一下Spring的事物管理" class="headerlink" title="介绍一下Spring的事物管理"></a>介绍一下Spring的事物管理</h1><ul><li>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</li><li>开发中为了避免这种情况一般都会进行事务管理</li><li>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能</li><li>spring提供了几个关于事务处理的类：<ul><li>TransactionDefinition &#x2F;&#x2F;事务属性定义</li><li>TranscationStatus &#x2F;&#x2F;代表了当前的事务，可以提交，回滚。</li><li>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。</li></ul></li><li>spring提供的事务管理可以分为两类：编程式的和声明式的<ul><li>编程式的，比较灵活，但是代码量大，存在重复的代码比较多</li><li>声明式的比编程式的更灵活。</li></ul></li><li>编程式主要使用transactionTemplate</li><li>省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.</li></ul><h1 id="AOP-通知有哪些类型？"><a href="#AOP-通知有哪些类型？" class="headerlink" title="AOP 通知有哪些类型？"></a>AOP 通知有哪些类型？</h1><ul><li>前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li><li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li><li>后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li><li>环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</li></ul><h1 id="什么是-spring"><a href="#什么是-spring" class="headerlink" title="什么是 spring?"></a>什么是 spring?</h1><ul><li>Spring 是个 java 企业级应用的开源开发框架</li><li>Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用</li><li>Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</li></ul><h1 id="使用-Spring-框架的好处是什么？"><a href="#使用-Spring-框架的好处是什么？" class="headerlink" title="使用 Spring 框架的好处是什么？"></a>使用 Spring 框架的好处是什么？</h1><ul><li>轻量：Spring 是轻量的，基本的版本大约 2MB</li><li>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li><li>容器：Spring 包含并管理应用中对象的生命周期和配置</li><li>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品</li><li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li><li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</li></ul><h1 id="ApplicationContext-通常的实现是什么？"><a href="#ApplicationContext-通常的实现是什么？" class="headerlink" title="ApplicationContext 通常的实现是什么？"></a>ApplicationContext 通常的实现是什么？</h1><ul><li>FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li>ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找bean 配置。</li><li>WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个WEB 应用的所有 bean。</li></ul><h1 id="一个-Spring-的应用看起来象什么？"><a href="#一个-Spring-的应用看起来象什么？" class="headerlink" title="一个 Spring 的应用看起来象什么？"></a>一个 Spring 的应用看起来象什么？</h1><ul><li>一个定义了一些功能的接口</li><li>这实现包括属性，它的 Setter ， getter 方法和函数等</li><li>Spring AOP</li><li>Spring 的 XML 配置文件</li><li>使用以上功能的客户端程序</li></ul><h1 id="哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？"><a href="#哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？" class="headerlink" title="哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？"></a>哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？</h1><ul><li>你两种依赖方式都可以使用，构造器注入和 Setter 方法注入</li><li>最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。</li></ul><h1 id="什么是-Spring-beans？"><a href="#什么是-Spring-beans？" class="headerlink" title="什么是 Spring beans？"></a>什么是 Spring beans？</h1><ul><li>Spring beans 是那些形成 Spring 应用的主干的 java 对象</li><li>它们被 Spring IOC 容器初始化，装配，和管理</li><li>这些 beans 通过容器中配置的元数据创建</li><li>比如，以 XML文件中<bean>的形式定义。</li><li>Spring 框架定义的 beans 都是单件 beans</li><li>在 bean tag 中有个属性”singleton”，如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean</li><li>默认是TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件</li></ul><h1 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h1><ul><li>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</li></ul><h1 id="如何给-Spring-容器提供配置元数据？"><a href="#如何给-Spring-容器提供配置元数据？" class="headerlink" title="如何给 Spring 容器提供配置元数据？"></a>如何给 Spring 容器提供配置元数据？</h1><ul><li>这里有三种重要的方法给 Spring 容器提供配置元数据。<ul><li>XML 配置文件。</li><li>基于注解的配置。</li><li>基于 java 的配置。</li></ul></li></ul><h1 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h1><ul><li>当定义一个<bean>在 Spring 里，我们还能给这个 bean 声明一个作用域</bean></li><li>它可以通过bean定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope属性必须设为singleton。</li></ul><h1 id="Spring-框架中的单例-bean-是线程安全的吗？"><a href="#Spring-框架中的单例-bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 bean 是线程安全的吗？"></a>Spring 框架中的单例 bean 是线程安全的吗？</h1><ul><li>不，Spring 框架中的单例 bean 不是线程安全的。</li></ul><h1 id="哪些是重要的-bean-生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的-bean-生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的 bean 生命周期方法？ 你能重载它们吗？"></a>哪些是重要的 bean 生命周期方法？ 你能重载它们吗？</h1><p>有- 两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时候被调用</p><ul><li>第二个方法是 teardown 它是在容器卸载类的时候被调用。</li><li>The bean 标签有两个重要的属性（init-method 和 destroy-method）</li><li>用它们你可 以 自 己 定 制 初 始 化 和 注 销 方 法</li><li>它 们 也 有 相 应 的 注 解 （ @PostConstruct 和@PreDestroy）。</li></ul><h1 id="在-Spring-中如何注入一个-java-集合？"><a href="#在-Spring-中如何注入一个-java-集合？" class="headerlink" title="在 Spring 中如何注入一个 java 集合？"></a>在 Spring 中如何注入一个 java 集合？</h1><ul><li>Spring 提供以下几种集合的配置元素：<ul><li><list>类型用于注入一列值，允许有相同的值。</list></li><li><set>类型用于注入一组值，不允许有相同的值。</set></li><li><map>类型用于注入一组键值对，键和值都可以为任意类型。</map></li><li><props>类型用于注入一组键值对，键和值都只能为 String 类型。</props></li></ul></li></ul><h1 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h1><ul><li>自动装配的局限性是：<ul><li>重写：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></li><li>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。</li><li>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li></ul></li></ul><h1 id="你可以在-Spring-中注入一个-null-和一个空字符串吗？"><a href="#你可以在-Spring-中注入一个-null-和一个空字符串吗？" class="headerlink" title="你可以在 Spring 中注入一个 null 和一个空字符串吗？"></a>你可以在 Spring 中注入一个 null 和一个空字符串吗？</h1><ul><li>可以。 Spring 注解</li></ul><h1 id="在-Spring-框架中如何更有效地使用-JDBC？"><a href="#在-Spring-框架中如何更有效地使用-JDBC？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC？"></a>在 Spring 框架中如何更有效地使用 JDBC？</h1><ul><li>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻</li><li>所以开发者只需写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</li><li>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li></ul><h1 id="Spring-对-DAO-的支持"><a href="#Spring-对-DAO-的支持" class="headerlink" title="Spring 对 DAO 的支持"></a>Spring 对 DAO 的支持</h1><ul><li>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，Hibernate or JDO 结合使用</li><li>这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</li></ul><h1 id="如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？"><a href="#如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？" class="headerlink" title="如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？"></a>如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</h1><ul><li>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul><li>配置 the Hibernate SessionFactory</li><li>继承 HibernateDaoSupport 实现一个 DAO</li><li>在 AOP 支持的事务中装配</li></ul></li></ul><h1 id="如何在spring的applicationContext-xml使用JNDI而不是DataSource"><a href="#如何在spring的applicationContext-xml使用JNDI而不是DataSource" class="headerlink" title="如何在spring的applicationContext.xml使用JNDI而不是DataSource"></a>如何在spring的applicationContext.xml使用JNDI而不是DataSource</h1><ul><li>可以使用”org.springframework.jndi.JndiObjectFactoryBean”来实现</li></ul><h1 id="在spring中是如何配置数据库驱动的"><a href="#在spring中是如何配置数据库驱动的" class="headerlink" title="在spring中是如何配置数据库驱动的"></a>在spring中是如何配置数据库驱动的</h1><ul><li>org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动</li></ul><h1 id="在web中如何配置spring"><a href="#在web中如何配置spring" class="headerlink" title="在web中如何配置spring"></a>在web中如何配置spring</h1><ul><li>在J2EE的web应用里面配置spring非常简单，最简单的只需要把spring得ContextLoaderListener添加到你的web.xml文件里面就可以了</li></ul><h1 id="在spring中如何定义hibernate-Mapping？"><a href="#在spring中如何定义hibernate-Mapping？" class="headerlink" title="在spring中如何定义hibernate Mapping？"></a>在spring中如何定义hibernate Mapping？</h1><ul><li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li></ul><h1 id="如何配置spring-struts？"><a href="#如何配置spring-struts？" class="headerlink" title="如何配置spring + struts？"></a>如何配置spring + struts？</h1><ul><li>在struts-config.xml加入一个插件，通过它加载applicationContext.xml</li><li>在struts-config.xml修改action-mapping标记，具体action交给了DelegateActionProxy</li><li>通过DelegateActionProxy进入一spring的环境。</li><li>在spring的applicationContext.xml加入<bean name="”/login”" class="”“" singleton="”false”/"></bean></li></ul><h1 id="如何在spring中实现国际化"><a href="#如何在spring中实现国际化" class="headerlink" title="如何在spring中实现国际化?"></a>如何在spring中实现国际化?</h1><ul><li>在applicationContext.xml加载一个bean org.springframework.context.support.ResourceBundleMessageSource</li><li>在src目录下建多个properties文件</li><li>对于非英文的要用native2ascii -encoding gb2312 源目转化文件相关内容</li><li>其命名格式是message_语言_国家。</li><li>页面中的中显示提示信息，键名取键值。</li><li>当给定国家，系统会自动加载对应的国家的properties信息。</li><li>通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。</li></ul><h1 id="在spring中如何实现事件处理"><a href="#在spring中如何实现事件处理" class="headerlink" title="在spring中如何实现事件处理"></a>在spring中如何实现事件处理</h1><ul><li>事件 Extends ApplicationEvent</li><li>监听器 Implements ApplicationListener</li><li>事件源 Implements ApplicationContextAware</li><li>在applicationContext.xml中配置事件源、监听器</li><li>先得到事件源，调用事件源的方法，通知监听器。</li></ul><h1 id="如何将spring加入web容器中"><a href="#如何将spring加入web容器中" class="headerlink" title="如何将spring加入web容器中"></a>如何将spring加入web容器中</h1><ul><li>在web.xml中加入如下同容,在启动web服务器时加载&#x2F;WEB-INF&#x2F;applicationContext.xml中的内容。</li></ul><h1 id="Spring如何实现资源管理"><a href="#Spring如何实现资源管理" class="headerlink" title="Spring如何实现资源管理?"></a>Spring如何实现资源管理?</h1><ul><li>使用<ul><li>applicationContext.getResource(“classpath:文件名”):在src根目录下，在类路径下</li><li>applicationContext.getResource(“classpath:&#x2F;chap01&#x2F;文件名”): 以src根目录下的基准往下走。</li><li>applicationContext.getResource(“file:c:&#x2F;a.properties”)：在系统文件目录下。</li></ul></li></ul><h1 id="Spring的ApplicationContext的作用"><a href="#Spring的ApplicationContext的作用" class="headerlink" title="Spring的ApplicationContext的作用?"></a>Spring的ApplicationContext的作用?</h1><ul><li>beanFactory</li><li>国际化(getMesage)</li><li>资源管理:可以直接读取一个文件的内容(getResource)</li><li>加入web框架中(加入一个servlet或监听器)</li><li>事件处理</li></ul><h1 id="Hibernate工作原理及为什么要用？"><a href="#Hibernate工作原理及为什么要用？" class="headerlink" title="Hibernate工作原理及为什么要用？"></a>Hibernate工作原理及为什么要用？</h1><ul><li>原理：<ul><li>读取并解析配置文件</li><li>读取并解析映射信息，创建SessionFactory</li><li>打开Sesssion</li><li>创建事务Transation</li><li>持久化操作</li><li>提交事务</li><li>关闭Session</li><li>关闭SesstionFactory</li></ul></li><li>为什么要用：<ul><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li></ul></li><li>Hibernate是如何延迟加载?<ul><li>Hibernate2延迟加载实现：a)实体对象  b)集合（Collection）</li><li>Hibernate3 提供了属性的延迟加载功能</li></ul></li><li>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</li><li>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)<ul><li>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</li></ul></li><li>说下Hibernate的缓存机制<ul><li>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</li><li>二级缓存：<ul><li>应用及缓存</li><li>分布式缓存<ul><li>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据</li></ul></li></ul></li><li>第三方缓存的实现</li></ul></li><li>Hibernate的查询方式<ul><li>Sql、Criteria,object comptosition</li><li>Hql：<ul><li>属性查询</li><li>参数查询、命名参数查询</li><li>关联查询</li><li>分页查询</li><li>统计函数</li></ul></li></ul></li><li>如何优化Hibernate？<ul><li>使用双向一对多关联，不使用单向一对多</li><li>灵活使用单向一对多关联</li><li>不用一对一，用多对一取代</li><li>配置对象缓存，不使用集合缓存</li><li>一对多集合使用Bag,多对多集合使用Set</li><li>继承类使用显式多态</li><li>表字段要少，表关联不要怕多，有二级缓存撑腰</li></ul></li></ul><h1 id="Spring中如何获取bean"><a href="#Spring中如何获取bean" class="headerlink" title="Spring中如何获取bean"></a>Spring中如何获取bean</h1><ul><li>通过xml配置文件</li><li>bean配置在xml里面，spring提供多种方式读取配置文件得到ApplicationContext.<ul><li>第一种方式：FileSystemXmlApplicationContext通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例:<ul><li>ApplicationContext ac &#x3D; new FileSystemXmlApplicationContext(”applicationContext.xml”)</li><li>ac.getBean(”beanName”);</li></ul></li><li>第二种方式：WebApplicationContextUtil在B&#x2F;S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext.例如：<ul><li>ApplicationContext ctx &#x3D; WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);</li><li>ApplicationContext ctx &#x3D;   WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</li><li>其中 servletContext sc 可以具体 换成 servlet.getServletContext()或者 this.getServletContext() 或者 request.getSession().getServletContext();</li><li>另外，由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象：</li><li>WebApplicationContext webApplicationContext &#x3D; (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</li></ul></li></ul></li></ul><h1 id="Spring框架中的单例Beans是线程安全的么？"><a href="#Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="Spring框架中的单例Beans是线程安全的么？"></a>Spring框架中的单例Beans是线程安全的么？</h1><ul><li>Spring框架并没有对单例bean进行任何多线程的封装处理</li><li>关于单例bean的线程安全和并发问题需要开发者自行去搞定</li><li>但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的</li><li>如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。</li><li>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</li></ul><h1 id="如何向Spring-Bean中注入一个Java-util-Properties？"><a href="#如何向Spring-Bean中注入一个Java-util-Properties？" class="headerlink" title="如何向Spring Bean中注入一个Java.util.Properties？"></a>如何向Spring Bean中注入一个Java.util.Properties？</h1><ul><li>第一种方法是使用如下面代码所示的<props> 标签</props></li><li>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。</li></ul><h1 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h1><ul><li>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</li><li>我们可以创建bean用来监听在ApplicationContext 中发布的事件</li><li>ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li><li>Spring 提供了以下5中标准的事件：<ul><li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li></ul></li><li>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。为了监听这个事件，还需要创建一个监听器，之后通过applicationContext接口的publishEvent()方法来发布自定义事件。</li></ul><h1 id="FileSystemResource和ClassPathResource有何区别？"><a href="#FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="FileSystemResource和ClassPathResource有何区别？"></a>FileSystemResource和ClassPathResource有何区别？</h1><ul><li>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径</li><li>在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。</li><li>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</li><li>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</li></ul><h1 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h1><ul><li>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：<ul><li>代理模式—在AOP和remoting中被用的比较多。</li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory &#x2F; ApplicationContext接口的核心理念。</li><li>工厂模式—BeanFactory用来创建对象的实例</li></ul></li></ul><p> </p><h1 id="开发中主要使用-Spring-的什么技术"><a href="#开发中主要使用-Spring-的什么技术" class="headerlink" title="开发中主要使用 Spring 的什么技术 ?"></a>开发中主要使用 Spring 的什么技术 ?</h1><ul><li>IOC 容器管理各层的组件</li><li>使用 AOP 配置声明式事务</li><li>整合其他框架</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/cc5f72fdfb9e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/cc5f72fdfb9e.html" class="post-title-link" itemprop="url">Tomcat</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:02:31" itemprop="dateCreated datePublished" datetime="2023-12-20T16:02:31+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 20:49:47" itemprop="dateModified" datetime="2023-12-24T20:49:47+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Tomcat的缺省端口是多少，怎么修改？"><a href="#Tomcat的缺省端口是多少，怎么修改？" class="headerlink" title="Tomcat的缺省端口是多少，怎么修改？"></a>Tomcat的缺省端口是多少，怎么修改？</h1><ul><li>找到Tomcat目录下的conf文件夹</li><li>进入conf文件夹里面找到server.xml文件</li><li>打开server.xml文件</li><li>在server.xml文件里面找到下列信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li>port&#x3D;”8080”改成你想要的端口</li></ul><h1 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a>tomcat 有哪几种Connector 运行模式(优化)？</h1><h4 id="bio：传统的Java-I-O操作，同步且阻塞IO。"><a href="#bio：传统的Java-I-O操作，同步且阻塞IO。" class="headerlink" title="bio：传统的Java I&#x2F;O操作，同步且阻塞IO。"></a>bio：传统的Java I&#x2F;O操作，同步且阻塞IO。</h4><ul><li>maxThreads&#x3D;”150”&#x2F;&#x2F;Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值200。可以根据机器的时期性能和内存大小调整，一般可以在400-500。最大可以在800左右。</li><li>minSpareThreads&#x3D;”25”—Tomcat初始化时创建的线程数。默认值4。如果当前没有空闲线程，且没有超过maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。</li><li>maxSpareThreads&#x3D;”75”–一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值50。一旦创建的线程超过此数值，Tomcat会关闭不再需要的线程。线程数可以大致上用 “同时在线人数每秒用户操作次数系统平均操作时间” 来计算。</li><li>acceptCount&#x3D;”100”—-指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。如果当前可用线程数为0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。</li><li>connectionTimeout&#x3D;”20000” –网络连接超时，默认值20000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li></ul><h4 id="nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。"><a href="#nio：JDK1-4开始支持，同步阻塞或同步非阻塞IO。" class="headerlink" title="nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。"></a>nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。</h4><ul><li>指定使用NIO模型来接受HTTP请求</li><li>protocol&#x3D;”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol&#x3D;”HTTP&#x2F;1.1”</li><li>acceptorThreadCount&#x3D;”2” 使用NIO模型时接收线程的数目</li></ul><h4 id="aio-nio-2-：JDK7开始支持，异步非阻塞IO。"><a href="#aio-nio-2-：JDK7开始支持，异步非阻塞IO。" class="headerlink" title="aio(nio.2)：JDK7开始支持，异步非阻塞IO。"></a>aio(nio.2)：JDK7开始支持，异步非阻塞IO。</h4><ul><li><p>apr：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">      &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8000&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;</span><br><span class="line">    &lt;!-- minProcessors最小空闲连接线程数--&gt;</span><br><span class="line">    &lt;!-- maxProcessors最大连接线程数--&gt;</span><br><span class="line">    &lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;</span><br><span class="line">    &lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;</span><br><span class="line">    &lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; </span><br><span class="line">        connectionTimeout=&quot;20000&quot;</span><br><span class="line">        redirectPort=&quot;8443</span><br><span class="line">        maxThreads=“500” </span><br><span class="line">        minSpareThreads=“100” </span><br><span class="line">        maxSpareThreads=“200”</span><br><span class="line">        acceptCount=&quot;200&quot;</span><br><span class="line">        enableLookups=&quot;false&quot;       </span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></li><li><p>其他配置</p><ul><li>maxHttpHeaderSize&#x3D;”8192” http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。</li><li>URIEncoding&#x3D;”UTF-8” 指定Tomcat容器的URL编码格式。</li><li>disableUploadTimeout&#x3D;”true” 上传时是否使用超时机制</li><li>enableLookups&#x3D;”false”–是否反查域名，默认值为true。为了提高处理能力，应设置为false</li><li>compression&#x3D;”on” 打开压缩功能</li><li>compressionMinSize&#x3D;”10240” 启用压缩的输出内容大小，默认为2KB</li><li>noCompressionUserAgents&#x3D;”gozilla, traviata” 对于以下的浏览器，不启用压缩</li><li>compressableMimeType&#x3D;”text&#x2F;html,text&#x2F;xml,text&#x2F;javascript,text&#x2F;css,text&#x2F;plain” 哪些资源类型需要压缩</li></ul></li></ul><h1 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h1><ul><li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li><li>在server.xml文件上配置<context>节点，设置相关的属性即可</context></li><li>通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li></ul><h1 id="tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>tomcat容器是如何创建servlet类实例？用到了什么原理？</h1><ul><li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析， 并读取servlet注册信息</li><li>然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。（有时候也是在第一次请求时实例化）在servlet注册时加上如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li></ul><h1 id="tomcat-如何优化？"><a href="#tomcat-如何优化？" class="headerlink" title="tomcat 如何优化？"></a>tomcat 如何优化？</h1><ul><li><p>优化连接配置.这里以tomcat7的参数配置为例，需要修改conf&#x2F;server.xml文件，修改连接数，关闭客户端dns查询。</p></li><li><p>参数解释：</p><ul><li>URIEncoding&#x3D;”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</li><li>maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</li><li>minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</li><li>enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</li><li>connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</li><li>maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</li><li>acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</li><li>maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。通常Windows是1000个左右，Linux是2000个左右。</li><li>useURIValidationHack:把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</li><li>enableLookups&#x3D;”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</li><li>disableUploadTimeout ：类似于Apache中的keeyalive一样</li></ul></li><li><p>给Tomcat配置gzip压缩(HTTP压缩)功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compression=”on” compressionMinSize=”2048″</span><br><span class="line">compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</span><br></pre></td></tr></table></figure></li><li><p>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。</p></li><li><p>相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compression=”on” 打开压缩功能</span><br><span class="line">compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB</span><br><span class="line">noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</span><br><span class="line">compressableMimeType=”text/html,text/xml”　压缩类型</span><br></pre></td></tr></table></figure></li><li><p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置</p></li></ul><h1 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h1><ul><li>内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。</li><li>具体设置如下： JAVA_OPTS&#x3D;”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio&#x3D;4 -XX:SurvivorRatio&#x3D;4”</li><li>其各项参数如下：<ul><li>-Xmx3550m：设置JVM最大可用内存为3550M。</li><li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xmn2g：设置年轻代大小为2G。整个堆大小&#x3D;年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</li><li>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li><li>-XX:NewRatio&#x3D;4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5</li><li>-XX:SurvivorRatio&#x3D;4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1&#x2F;6</li><li>-XX:MaxPermSize&#x3D;16m:设置持久代大小为16m。</li><li>-XX:MaxTenuringThreshold&#x3D;0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li></ul></li></ul><h1 id="垃圾回收策略调优"><a href="#垃圾回收策略调优" class="headerlink" title="垃圾回收策略调优"></a>垃圾回收策略调优</h1><ul><li>垃圾回收的设置也是在catalina.sh中，调整JAVA_OPTS变量。</li><li>具体设置如下： JAVA_OPTS&#x3D;”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis&#x3D;100”</li><li>具体的垃圾回收策略及相应策略的各项参数如下：<ul><li>串行收集器（JDK1.5以前主要的回收方式） ：-XX:+UseSerialGC:设置串行收集器</li><li>并行收集器（吞吐量优先）<ul><li>示例： java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis&#x3D;100</li><li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</li><li>-XX:ParallelGCThreads&#x3D;20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集</li><li>-XX:MaxGCPauseMillis&#x3D;100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li></ul></li><li>并发收集器（响应时间优先）<ul><li>示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC</li><li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio&#x3D;4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</li><li>-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li><li>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</li><li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li></ul></li></ul></li></ul><h1 id="共享session处理"><a href="#共享session处理" class="headerlink" title="共享session处理"></a>共享session处理</h1><h4 id="使用Tomcat本身的Session复制功能"><a href="#使用Tomcat本身的Session复制功能" class="headerlink" title="使用Tomcat本身的Session复制功能"></a>使用Tomcat本身的Session复制功能</h4><ul><li>方案的有点是配置简单，缺点是当集群数量较多时，Session复制的时间会比较长，影响响应的效率</li></ul><h4 id="使用第三方来存放共享Session"><a href="#使用第三方来存放共享Session" class="headerlink" title="使用第三方来存放共享Session"></a>使用第三方来存放共享Session</h4><ul><li>目前用的较多的是使用memcached来管理共享Session，借助于memcached-sesson-manager来进行Tomcat的Session管理</li></ul><h4 id="使用黏性session的策略"><a href="#使用黏性session的策略" class="headerlink" title="使用黏性session的策略"></a>使用黏性session的策略</h4><ul><li>对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同一个用户的session可以由nginx或者apache交给同一个Tomcat来处理，这就是所谓的session sticky策略，目前应用也比较多</li><li>nginx默认不包含session sticky模块，需要重新编译才行（windows下我也不知道怎么重新编译）</li><li>优点是处理效率高多了，缺点是强会话要求的场合不合适</li></ul><h1 id="添加JMS远程监控"><a href="#添加JMS远程监控" class="headerlink" title="添加JMS远程监控"></a>添加JMS远程监控</h1><ul><li>对于部署在局域网内其它机器上的Tomcat，可以打开JMX监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在JVM启动参数中配置即可，配置如下：<ul><li>-Dcom.sun.management.jmxremote.ssl&#x3D;false -Dcom.sun.management.jmxremote.authenticate&#x3D;false</li><li>-Djava.rmi.server.hostname&#x3D;192.168.71.38 设置JVM的JMS监控监听的IP地址，主要是为了防止错误的监听成127.0.0.1这个内网地址</li><li>-Dcom.sun.management.jmxremote.port&#x3D;1090 设置JVM的JMS监控的端口</li><li>-Dcom.sun.management.jmxremote.ssl&#x3D;false 设置JVM的JMS监控不实用SSL</li><li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false 设置JVM的JMS监控不需要认证</li></ul></li></ul><h1 id="专业点的分析工具有"><a href="#专业点的分析工具有" class="headerlink" title="专业点的分析工具有"></a>专业点的分析工具有</h1><ul><li>IBM ISA，JProfiler、probe 等，具体监控及分析方式去网上搜索即可</li></ul><h1 id="关于Tomcat的session数目"><a href="#关于Tomcat的session数目" class="headerlink" title="关于Tomcat的session数目"></a>关于Tomcat的session数目</h1><ul><li>这个可以直接从Tomcat的web管理界面去查看即可；</li><li>或者借助于第三方工具Lambda Probe来查看，它相对于Tomcat自带的管理稍微多了点功能，但也不多 ；</li></ul><h1 id="监视Tomcat的内存使用情况"><a href="#监视Tomcat的内存使用情况" class="headerlink" title="监视Tomcat的内存使用情况"></a>监视Tomcat的内存使用情况</h1><ul><li>使用JDK自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等；</li><li>JDK自带的jvisualvm可以下载插件（如GC等），可以查看更丰富的信息。如果是分析本地的Tomcat的话，还可以进行内存抽样等，检查每个类的使用情况</li></ul><h1 id="打印类的加载情况及对象的回收情况"><a href="#打印类的加载情况及对象的回收情况" class="headerlink" title="打印类的加载情况及对象的回收情况"></a>打印类的加载情况及对象的回收情况</h1><ul><li>这个可以通过配置JVM的启动参数，打印这些信息（到屏幕（默认也会到catalina.log中）或者文件），具体参数如下：<ul><li>-XX:+PrintGC：输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</li><li>-XX:+PrintGCDetails：输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</li><li>-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用，输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</li><li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds</li><li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds</li><li>-XX:PrintHeapAtGC: 打印GC前后的详细堆栈信息</li><li>-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析</li><li>-verbose:class 监视加载的类的情况</li><li>-verbose:gc 在虚拟机发生内存回收时在输出设备显示信息</li><li>-verbose:jni 输出native方法调用的相关情况，一般用于诊断jni调用错误信息</li></ul></li></ul><h1 id="Tomcat一个请求的完整过程"><a href="#Tomcat一个请求的完整过程" class="headerlink" title="Tomcat一个请求的完整过程"></a>Tomcat一个请求的完整过程</h1><ul><li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP&#x2F;1.1 Connector获得</li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应</li><li>Engine获得请求localhost&#x2F;yy&#x2F;index.jsp，匹配它所拥有的所有虚拟主机Host</li><li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）</li><li>localhost Host获得请求&#x2F;yy&#x2F;index.jsp，匹配它所拥有的所有Context</li><li>Host匹配到路径为&#x2F;yy的Context（如果匹配不到就把该请求交给路径名为”“的Context去处理）</li><li>path&#x3D;”&#x2F;yy”的Context获得请求&#x2F;index.jsp，在它的mapping table中寻找对应的servlet</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类</li><li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host</li><li>Host把HttpServletResponse对象返回给Engine</li><li>Engine把HttpServletResponse对象返回给Connector</li><li>Connector把HttpServletResponse对象返回给客户browser</li></ul><h1 id="Tomcat工作模式？"><a href="#Tomcat工作模式？" class="headerlink" title="Tomcat工作模式？"></a>Tomcat工作模式？</h1><ul><li>Tomcat是一个JSP&#x2F;Servlet容器</li><li>其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</li><li>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：<ul><li>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li><li>Tomcat作为独立服务器：请求来自于web浏览器；</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/aa3500b67dae.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/aa3500b67dae.html" class="post-title-link" itemprop="url">版本管理工具</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:00:42" itemprop="dateCreated datePublished" datetime="2023-12-20T16:00:42+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 11:52:57" itemprop="dateModified" datetime="2023-12-24T11:52:57+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">版本管理工具</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="svn和git的区别及适用场景"><a href="#svn和git的区别及适用场景" class="headerlink" title="svn和git的区别及适用场景"></a>svn和git的区别及适用场景</h1><h4 id="svn的优势"><a href="#svn的优势" class="headerlink" title="svn的优势"></a>svn的优势</h4><ul><li>优异的跨平台支持，对windows平台支持非常友好。</li><li>简单易用，安装后稍微培训下就知道怎么操作。</li><li>代码，需求，文档，涉及稿都可以用svn进行管理，适合不同部门的技术非技术的同事协作。</li></ul><h4 id="git的优势"><a href="#git的优势" class="headerlink" title="git的优势"></a>git的优势</h4><ul><li>去中心化：Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容是完全一样的（格式有点不同，是bare的）。虽然平时大家都是将代码提交到中央服务器上再统一pull别人的代码，但实际情况你可以总是pull张三的库，然后push给李四等等操作。</li><li>本地提交：本地提交好处主要有3点：<ul><li>一， 断网提交</li><li>二， 小步提交。可以对自己的阶段成果有跟踪，并且提高每次变更的安全性</li><li>三，本地库。这个和断网提交是同一个实现，但从需求角度出发则略有不同，主要是说即使只有自己一个人开发项目，也可以轻易的让自己的代码有版本跟踪，而不需要去费力建个什么svn server。</li><li>四，本地回滚。这个其实是由于本地库的存在而产生的，但可以减少中央库上的冗余版本</li></ul></li><li>分支策略：在Git实际开发中分支的分离和merge是属于日常操作，开启和合并分支成本相比SVN要小得多：SVN是复制一份代码到分支目录，Git则是在分支点做一下标记。随便一次冲突就会自动产生分支，所以大家每天都在与分支打交道。这便是弱化了分支的概念，由于分支成本很小，因此使得按功能分支的开发模式（每个分支一个功能，开发完了再merge到主干）变得非常简单，大家可以完全不需要再因为担心SCM成本太高而选用主干开发模式（所有功能都在主干上开发，到了发版本前再分离出分支）。</li></ul><h4 id="两者的工作流对比"><a href="#两者的工作流对比" class="headerlink" title="两者的工作流对比"></a>两者的工作流对比</h4><h5 id="svn模式"><a href="#svn模式" class="headerlink" title="svn模式"></a>svn模式</h5><ul><li>写代码。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将本地代码提交到服务器。</li></ul><h5 id="git模式"><a href="#git模式" class="headerlink" title="git模式"></a>git模式</h5><ul><li>写代码。</li><li>提交到本地版本库。</li><li>从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突。</li><li>将远程库与本地代码合并结果提交到本地版本库。</li><li>将本地版本库推到服务器。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>对比可以看出：分布式版本管理仅仅是增加了本地库这个概念，其余的概念与集中管理并无区别。——但是 svn 在与服务器同步之前无法提交代码，因而本地修改更容易出问题。</li><li>当研发成本比较低，协作开发人数不多，开发人员对于版本管理的水平参差不齐的时候，或者对于代码的安全性要求更高一点的时候，适合用svn。</li><li>而对于很多人参与开发，代码量比较大，或者高频次协作，跨公司，跨地域合作的情况下，更适合用git。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/726ed62e2d44.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/726ed62e2d44.html" class="post-title-link" itemprop="url">Nginx</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:59:00" itemprop="dateCreated datePublished" datetime="2023-12-20T15:59:00+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 16:21:48" itemprop="dateModified" datetime="2023-12-24T16:21:48+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nginx/" itemprop="url" rel="index"><span itemprop="name">nginx</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><ul><li>Nginx应该是现在最火的web和反向代理服务器，没有之一</li><li>它是一款诞生于俄罗斯的高性能web服务器，尤其在高并发情况下，相较Apache，有优异的表现。</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><ul><li>Nginx擅长处理静态文件，是非常好的图片、文件服务器</li><li>把所有的静态资源的放到nginx上，可以使应用动静分离，性能更好</li></ul><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><ul><li>Nginx通过反向代理可以实现服务的负载均衡，避免了服务器单节点故障，把请求按照一定的策略转发到不同的服务器上，达到负载的效果。</li></ul><h6 id="常用的负载均衡策略有"><a href="#常用的负载均衡策略有" class="headerlink" title="常用的负载均衡策略有"></a>常用的负载均衡策略有</h6><ul><li>轮询<ul><li>将请求按顺序轮流地分配到后端服务器上</li><li>它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li></ul></li><li>加权轮询<ul><li>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同</li><li>给配置高、负载低的机器配置更高的权重，让其处理更多的请；</li><li>而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li></ul></li><li>ip_hash（源地址哈希法）<ul><li>根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问服务器的序号。</li><li>采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li></ul></li><li>随机<ul><li>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。</li></ul></li><li>least_conn（最小连接数法）<ul><li>由于后端服务器的配置不尽相同，对于请求的处理有快有慢</li><li>最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li></ul></li></ul><h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><ul><li>Nginx的限流模块，是基于漏桶算法实现的，在高并发的场景下非常实用，如下图：</li></ul><h6 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h6><ul><li>limit_req_zone定义在http块中，$binary_remote_addr 表示保存客户端IP地址的二进制形式。</li><li>Zone定义IP状态及URL访问频率的共享内存区域。<br>-zone&#x3D;keyword标识区域的名字，以及冒号后面跟区域大小。16000个IP地址的状态信息约1MB，所以示例中区域可以存储160000个IP地址。</li><li>Rate定义最大请求速率。示例中速率不能超过每秒100个请求。</li></ul><h6 id="设置限流"><a href="#设置限流" class="headerlink" title="设置限流"></a>设置限流</h6><ul><li>burst排队大小，nodelay不限制单个请求间的时间。</li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul><li>浏览器缓存，静态资源缓存用expire。</li><li>代理层缓存</li></ul><h5 id="黑白名单"><a href="#黑白名单" class="headerlink" title="黑白名单"></a>黑白名单</h5><ul><li>不限流白名单</li><li>黑名单</li></ul><h1 id="Nginx性能调优："><a href="#Nginx性能调优：" class="headerlink" title="Nginx性能调优："></a>Nginx性能调优：</h1><ul><li>增加同时打开⽂件数open files数量；</li><li>处理⼤量静态⽂件的磁盘I&#x2F;O时(此时worker进程是单线程的)，增加CPU核⼼数Worker Processes数量，提⾼计算能⼒；</li><li>如果⽹站流量很⾼，则可以提升worker进程连接数Worker Connections(默认1024)；</li><li>控制keep alive在10s-20s之间，减少连接的时间开销；</li><li>合理设置open file cache时间提⾼处理效率；</li><li>提⾼⽹路带宽；</li><li>开启压缩传输数据gzip，设置压缩级别gzip_comp_level为1-2，再⾼效果不明显并且浪费CPU了；</li><li>扩展机器数量。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/64b56da2b088.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/64b56da2b088.html" class="post-title-link" itemprop="url">面试技巧</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:57:12" itemprop="dateCreated datePublished" datetime="2023-12-20T15:57:12+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 13:27:06" itemprop="dateModified" datetime="2023-12-24T13:27:06+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">面试技巧</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="IT从业人员面试技巧"><a href="#IT从业人员面试技巧" class="headerlink" title="IT从业人员面试技巧"></a>IT从业人员面试技巧</h1><ul><li>一般来说，面试你的人都不是一个很好对付的人。别看他彬彬有礼，看上去笑眯眯的，很和气的样子。但没准儿一肚子坏水。有些人待人特别客气，说话还稍稍有点结巴的，更容易让人上当。所以，牢记一点，面试的时候保持高度警觉，对方不经意问出来的问题，很可能是他最想知道的。举例来说，我每次面试的时候，最喜欢说的话就是：哦，我不是HR的，你别拘束，咱们就当是聊天……</li><li>负责面试的人，一般有两种，一种是专门的人力资源部门。我不懂这一块，略过不谈。另外一种就是我这样的，负责某个部门的苦力头。一般来说，公司中层的苦力头，他的脑子里面都有一个模式，他的码头上需要一个什么样的人，他或她必须具备哪些技能。但这些考察都是次要的，他首先要搞清楚一点，那就是对方的人品!!!换句话说，能力是一个方面，但人品是门槛!!!如果他判定你人品有问题，那剩下的问题就没必要了。这里面就有很多陷阱，比如，你怎么评价前一家公司。你要是大说特说那公司怎么不好，我肯定要琢磨了，你昨天背叛少林，那今天会不会背叛武当?最好把离职原因淡淡一说，不要指责谁。我找工作的时候，一般都老实说，我自己能力不行，被公司淘汰了。其实大家肚子都揣着明白，不就是为了找个钱多点的地儿嘛。我经常问的一个陷阱问题就是：谈谈你的父母。其实这个问题一方面是考察对方的家庭教育，另外一方面是看看面试者怎么评价父母。这里面有个通常的逻辑，爹妈把他养这么大，说到自己的父母毫无感恩，感激之情，这种人招进来肯定不能成为合格的苦力。</li><li>总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li></ul><h4 id="面试到结束的时候，都会问到薪金标准。"><a href="#面试到结束的时候，都会问到薪金标准。" class="headerlink" title="面试到结束的时候，都会问到薪金标准。"></a>面试到结束的时候，都会问到薪金标准。</h4><ul><li>我不知道别的公司怎么操作的。我呆过的公司，都是定编定岗的，换句话说，招聘的时候，这个岗位的薪水是早就确定了。也就是说，对方问到薪金的时候，他已经在脑子里面很清楚公司的标准!!!一般说来，这个问题的目的是为了确定，他如果觉得你是个合适的苦力，那么，现在的薪金，你是不是会过来干活。问到薪金的时候，最好的回答是不回答，留到下一次面试再谈。或者可以反问，公司对于这个岗位定的薪金标准是多少。</li><li>一般来说，苦力头不会管你薪金多少的。好的苦力，苦力头甚至会为你向老板争取。</li><li>能够混到苦力头的位置上，面试你的人至少具有一定的能力，以及足够的胸怀。他在意的是能不能招到合适的人干活，薪金的问题不是问题。但过高的薪金，会把你抹掉。比如这个岗位，公司定的薪水是三千，你一张嘴，四千，那完了。对于应聘者，其实是很不公平的，你能做的就是接受这个标准或是不接受。如果是刚刚走出校门，月薪三千我想足够生活了。所以，如果对方的薪金标准，你要么不回答，要么就说三千，别要的太高。</li></ul><h4 id="一般面试都是在一个独立的私密空间进行。"><a href="#一般面试都是在一个独立的私密空间进行。" class="headerlink" title="一般面试都是在一个独立的私密空间进行。"></a>一般面试都是在一个独立的私密空间进行。</h4><ul><li>这里简单说说一些基本的礼貌。</li><li>进门要敲门，敲门是最基本的一点。</li><li>第二点，落座，别进去一屁股就坐上去了。最好等对方先坐下。当然，一般面试的人都很客气，招呼：坐，坐。</li><li>有时候进去之后，面试的人已经坐好了，那就别管了，坐在他的对面或他指定的位置就行。我这人比较心理阴暗，一般都是背对亮光坐。</li><li>当你结束时，至少客气招呼一声：谢谢您抽出时间面试我。</li><li>如果离开座位，顺手把椅子推好，这也是一个容易疏忽的地方。</li><li>有些公司的前台小姑娘，是你去面试的时候最先面对的，那么临走的时候客气打声招呼。</li><li>我有个习惯，面试的时候带着名片，如果我觉得很合适，会把名片给对方，这样他便于有问题的话联络我。但是，亲爱的朋友，你去面试的时候，如果对方面前放着名片夹子，千万不要傻了吧叽的要名片。</li><li>面试结束的第二天，如果你有面试你的苦力头电话，那就发个短信，内容可以客套一下，就说感谢你昨天面试我之类的话，然后祝福一下，比如今天好心情，工作顺利等等。千万不要问对方结果。你的目的就是提醒他，显示你的存在就行了。</li><li>你等待的地方，可能是公司的公共区域，而面试的地方可能是会议室，或者像我这样的人，喜欢在自己的办公室谈。那么切忌，不要走在前面，也不要走路中间，走在边上就行，把中间的位置留给你未来的领导走。进门之前主动为对方开门，这种拍马屁的小花招可以多来一点。</li><li>面试的时候身体正直，自然一点就行。一般来说，不要用摩丝喷的脑袋跟刺猬一样。女孩子也不要用过于浓密的香水。这是谈事情，不是相亲。</li><li>谈话的过程中，不要抢话，语速也不要太快。我教大家一个小诀窍，我一般和人谈事情，一开始故意显得有点结巴。人说话结巴，会让人感觉对方很诚恳。但就开头一两句结巴就行，别一直结巴。</li><li>有些人面试的时候介绍自己会滔滔不绝，说话特快。其实这里面有个信息传递的问题，跟别人谈事情，语速太快，往往容易说错。对方接受起来也有问题。中等语速就可以了。</li><li>很多男士比较大大咧咧，往那儿一坐，二郎腿就搭上了。要是碰上我这样大大咧咧的，可能无所谓，要是碰到心理阴暗的，就会有负面影响。另外，很多人一紧张就爱抖腿，这样也不礼貌。面试其实就是一个自我介绍，不是演说，不要声音特大吐沫横飞的，平时说话的声音就行。</li><li>面试你的要是个女的那就算了，要是个男的，不用管自己的性别，大大方方招呼一声，你好，手伸过去，和他握个手。其实从握手就能看到一个人的个性，一般来说，握手短促有力，可能是我这样比较外向的性格。握的软绵绵的，对方可能比较内向。</li><li>不要紧张，表现得自然些，要有礼貌，别忘记和主考人招呼，说句”早晨好”。</li><li>举止要大方，不可闪缩，要保持自信。待主考人邀请你才可礼貌地坐下，不要太随便或左顾右盼;切忌装出懒洋洋和满不在乎的样子。</li><li>微笑可以减轻你内心的不安，更可以令面试的气氛变得融洽愉快。</li><li>让主考人知道你珍惜这次面试的机会。当主考人说话时，要眼望对方，并留心倾听。</li><li>让主考人先打开话匣子。答问题要直接了当，无须太繁复，也不要单说”是”或”不是”;否则，主考人会觉得你欠缺诚意。深入的谈话内容有助主考人对你作出确切的评估。</li><li>假如不太明白主考人的问题，应该礼貌地请他重复。不懂得回答的问题，不妨坦白承认。含糊其辞或乱吹牛会导至面试的失败。</li><li>不要打断主考人的说话，被要求就相同的问题重复作答也不能表示不耐烦，更切忌与主考人争辩。</li><li>主考人可能问你一些与面试或者申请的职位完全无关的问题，例如时人时事;目的在进一步了解你的思想及见识。</li><li>紧记在适当时机带出自已的优点和特长。但切勿显得过份自信或浮夸。</li><li>不要急着提出薪酬问题，最好让主考人先提出。</li><li>准备一些与该机构和申请的工作有关的问题在面试结束之前提出。这样能表现伙的积极，亦可给主考人留下良好印象。</li><li>最后，问清楚多久才知道面试结果。不要忘记向主考人道谢及说声”再见”才离去。</li></ul><h1 id="面试一家公司之前需要做的准备"><a href="#面试一家公司之前需要做的准备" class="headerlink" title="面试一家公司之前需要做的准备"></a>面试一家公司之前需要做的准备</h1><h4 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h4><ul><li>了解应聘公司；</li><li>了解应聘岗位</li><li>查该公司的资料，知道该公司是做什么的，发展情况，招聘的岗位的要求等</li><li>公司地点在哪里，交通是否方便，需提前多久出发；</li><li>公司类型如何？我应该如何着装？去咨询公司逃不掉正装，而去互联网公司这么穿，人家或许以为你是房产中介；</li><li>公司业务如何？上市了吗？财报如何？主要产品有哪些？</li><li>公司在中国有多少分支机构？最近有什么新动向？</li><li>公司所在行业有何新动向？发展趋势如何？</li><li>公司的竞争对手有哪些？公司在行业内排名如何？</li></ul><h4 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h4><ul><li>重温一下简历内容，确保每段经历都能用简短的语言复述；</li><li>带过的团队，做过的项目，组织过的活动，以STAR的形式准备好；</li><li>每一段经历，都应该准备实例和数据证明，会给面试官留下深刻印象；</li><li>准备几个感兴趣的问题，面试中如果没有获得解答，在电话通知环节，我们必须开口问，有诸多信息要确认：<ul><li>面试时间／地点</li><li>公司名称／岗位名称</li><li>联系人信息（一旦迟到，得提前打电话道歉）</li><li>面试官是谁（HR还是直线经理，或者都一次性面试掉）</li><li>需要准备什么材料（一般逃不掉学历证明，身份证复印件等资料）</li><li>针对面试岗位，需要额外准备什么材料（如：做设计，是不是要带设计稿？）</li></ul></li></ul><h1 id="人事面试技巧总结"><a href="#人事面试技巧总结" class="headerlink" title="人事面试技巧总结"></a>人事面试技巧总结</h1><ul><li>一定不要将公司的工作当作负担，一定要做好并且学到东西，这才是你下一次跳槽能够展示的东西，所以在公司工作，你拿着工资，而不只是在为公司打工，而是为自己的未来进行修炼，一定要有这方面的意识。总之，面试的时候要牢记一点，面试你的那个混蛋，不管他有多和善，但他问的问题，可能里面处处陷阱!!!</li><li>人事这关也很重要，特别是工资方面，还有团队，工作方面？(重要)</li><li>对公司的主营业务要表现足够的兴趣，关系公司的发展？</li><li>3面就该和你谈谈钱的事情，你们的重点就是在于薪资，福利和以后的发展，这个时候就是公司对你展示他的潜力了，也是希望能留住你（招人也不容易），那么你对你自己的定位，和你的期望薪资就可以大胆的说出来， 不要因为不好意思而错过你要价的机会，因为一般进入公司后你想涨薪资就比较复杂了，而且这只是你的期望 ，面试官会对你提出他们会给你的工资， 也就是一个讨价还价的过程，总之在这个环节，你可以大胆提出你的期望薪资与发展方向（不要太离谱哈，当然你要作死我也不拦着你），和你的面试官慢慢讨论</li><li>试用期：在这个环节就是心态上注意，技术上展示你的能力，处事上和谐相处，重中之重是在于融入团队，你个人的力量是完不成整个项目的</li><li>对新公司的了解，公司发展情况，业务方向，特长等，如果在企业文化上也有优势，可以多夸下公司的的企业文化</li><li>期望的薪资，最好是了解了工作内容、加班情况、福利情况再谈待遇。最好先了解行情以免太高或太低。不要说太死了，看到对方表情不对就改口说可以商量，或者试探性的问一下对方能否接受，不行就说自己要高工资的原因并说明其实自己更看重发展机会，工资再少点也可以。不要轻易说自己能接受的最低工资，很可能他就给你这个最低的。如果对方能接受你的要求但是觉得有点偏高时，要说明自己凭什么可以拿这么高，并说明自己的优势对岗位的重要性。</li><li>要问公司的问题<ul><li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等。</li><li>所在部门的规模、发展计划，个人的成长机会。</li><li>自己的工作内容及可能的发展机会等。</li><li>向人事提问时最好不要一开始就谈工资，还有不要问太多可能留下不好印象的问题。问最基本的可能影响你去留的问题，其他问题可以进了再问，言多必失</li><li>面试前根据招聘信息的岗位要求多做相应准备</li></ul></li></ul><h4 id="你为什么来北京（城市）发展？"><a href="#你为什么来北京（城市）发展？" class="headerlink" title="你为什么来北京（城市）发展？"></a>你为什么来北京（城市）发展？</h4><ul><li>提出这个问题不要认为胡乱回答就行了，面试官是想看你什么原因，是否稳定。不会有哪家公司找一个很不稳定的人的。回答尽量夸城市，想在这里发展云云</li></ul><h4 id="你离职原因？"><a href="#你离职原因？" class="headerlink" title="你离职原因？"></a>你离职原因？</h4><ul><li>说到这个问题很多人都很头大，换工作的人清楚这个问题基本是必问的一个问题</li><li>这个问题很难回答，为什么呢？因为你如果说是公司的问题，这不好那不好，那么就很危险了，因为面试官会想，以后你从我们公司走出去是不是也这么说我们公司。说因为自己的原因呢，如果没好的理由，面试官也会想如果你来公司因为这些理由离开我公司呢，给人很不稳定的感觉</li><li>一般我会回答公司倒闭或者公司被收购、实习到期或者你本身确实有不得已的理由，比如公司发展和自己的发展不符合，等等，不要直接说公司或者自己的某些原因。除非没有好理由</li></ul><h4 id="为什么来我们公司？我们公司你了解多少？"><a href="#为什么来我们公司？我们公司你了解多少？" class="headerlink" title="为什么来我们公司？我们公司你了解多少？"></a>为什么来我们公司？我们公司你了解多少？</h4><ul><li>问这个就考察你的提前准备的资料了，既然这家公司通知你面试了，你肯定要去查相关资料，不需要详细的，但是你肯定要公司做什么的要知道</li><li>这个要考察自己巴拉巴拉的能力了，比如我觉得公司发展跟我想做的蛮符合的，我想珍惜这个机会…与公司同步发展云云</li></ul><h4 id="你认为你的优点和缺点有哪些？"><a href="#你认为你的优点和缺点有哪些？" class="headerlink" title="你认为你的优点和缺点有哪些？"></a>你认为你的优点和缺点有哪些？</h4><ul><li>不要认为这个问题很简单，吹吹牛就可以了。</li><li>首先你要清楚的知道，你的优点基本能在你工作中用到的，你的缺点千万不能出现在工作中。优点很好说，缺点就很难。优点比如，我工作认真踏实，团队意识强，学习能力强等等等，缺点你怎么说呢？好吃懒做，不思进取。这样回答基本就挂了。你必须自己的缺点和公司无关紧要的，经过面试经验，一般回答你自己生活上的，比如我花钱控制不了那么详细，就会引起对方的兴趣，那你干嘛了？你可以随便说了，我一般控制自己每月花一千，但是朋友聚会花了一千五。对金钱控制不好，这完全不影响你的工作。其他也可以自己想其他理由。</li></ul><h4 id="不知情况乱开价：-—-提前查好对应的工资基本水平"><a href="#不知情况乱开价：-—-提前查好对应的工资基本水平" class="headerlink" title="不知情况乱开价： —-提前查好对应的工资基本水平"></a>不知情况乱开价： —-提前查好对应的工资基本水平</h4><ul><li>说到薪资60%代表你有很大的机会被录用，可是你却狮子大开口的说薪资要求，企业怎么敢用一个漫不符合本身能力的人?如果不想吃亏，应聘前应多打听企业相关信息，不然就采取“依公司规定”的保守战略。不知行情胡乱开价，绝不让你的应聘倒扣200分。</li><li>北京这边的人力资源市场还是非常繁荣的，人才的流动性非常快，每年有两段流动高峰期。<ul><li>通常3<del>4月和9</del>10月是找工作高峰期：<ul><li>3~4月是大量人才拿到年终奖后跳槽的时期；</li><li>9~10月是各大高校毕业生求职时期；</li></ul></li><li>这两段时间都是企业释放大量岗位空缺的时间段，故而是求职旺季。</li></ul></li><li>跳槽也最好在这段时间，其它时间段最好不要跳槽，因为这时：一来岗位无空缺不好招人，二来公司人事会认为你是被裁员工印象不好，这样就不好谈价格了。</li><li>注意公司是以技能需求为驱动在人才市场里面找拥有目标技能的目标人群，而非以你所做项目为驱动，所以在简历里面技能项要分条重点表达，所做项目要辅助技能项做大致表达。</li><li>有些公司在行业里面有地位，是龙头老大，例如BAT、京东等的高并发系统架构方面的业务；平安等互联网金融的支付业务。这些公司的业务代表了行业规范，起到示范作用，能够学习到他们公司的这种权威性的技术或业务，以后可以到想效仿这些公司的其它小公司里面去，就可以有谈判的资本了，这就是在大公司的好处。（这就是为何在BAT工作的人，只要接触了BAT的核心技术，跳出来就那么值钱）</li><li>有些公司的某些部门，明明就不缺人，却天天打着招人的旗号，让人去面试。那么被猎头&#x2F;人事叫去面试之前，先问了解一些具体情况，有如下一些意识：<ul><li>从岗位角度问： 这个岗位是常年招聘的，还是最近刚招聘的。<ul><li>（如果是常年招聘的，那么最好不要过去了，人家公司上层可能都没有提供新员工名额，让你过去对你的要求是极高，你达到了或许有点希望，而且后面谈工资的时候对自己没有多少优势；如果是最近刚招聘的、岗位急着要人的，那么可以试试。）</li></ul></li><li>从部门角度问： 这个岗位所在的部门是什么情况，是由于业务扩展新成立的，还是一些老的部门。<ul><li>（如果是新成立一个部门，那么确实有可能要进新人，公司可能会放出岗位需求名额；如果是不是新成立的部门，是老部门，那么很可能这个岗位招人就不那么迫切。）</li></ul></li><li>从岗位职责要求角度问： 这个岗位的职责是什么，需要有什么技能的人选。<ul><li>（可以先让跟你打电话的猎头&#x2F;人事给你发一个JD邮件，你看看是否和你的技能、兴趣相符，如果相符则可以考虑是否过去；如果不相符，你都不知道他看了你的简历后怎么选的你，那你要么回信问清楚为何觉得我合适、贵岗位具体需要什么人做什么事情，如果没回音，就不要再管了，他们不要人的。不要怕把他们问烦了，他们如果真的缺人，那么不怕你多问，还怕你不来呢，问两句就烦，直接就说明他们本来就不确认，你去不去面试对他们影响不大。）</li></ul></li><li>面试过程中要有警觉： 如果最终还是去了，那么面试过程中也可以看到他们是否缺人。如果面试官上来就问你以前的项目，要你给他详细讲解，那么多半想把你当成免费的”老师“，你可以准备好一些素材给他讲；他问你有没有什么要问他的，你可以问他们要什么样技能的人，如果他们说的空泛不具体，不说需要具体掌握什么技能的，就是他们自己都不能详细表达岗位需求，那多半也不缺人。</li></ul></li><li>为何有些公司要这样“挖坑挖 ”呢？为何要设置那些长期招聘的岗位呢？ 呢<ul><li>第一、未雨绸缪。如果公司认为过段时间有人会离职，尤其是发完年终奖之前，那么就会提前做好准备，去招新人减少风险，而老员工未走新员工的招聘进度可以慢一点来。</li><li>第二、降低人力成本。如果公司当前人力成本太高，那么就想淘汰部分高价的老员工换来廉价新员工，那么会在老员工走之前招人，而新员工的招聘也可以慢一点来，招的到就招，招不到就不招，总之价格要压低。（这样的公司卸磨杀驴，不去也罢）</li><li>第三、换血。如果公司的部门当前好久没有换血了，对部门不是太有利，那么也是常年打着招聘的旗号招人，碰到真正有料的人选，如果成功压低了价格，也可以招进来，但公司不太缺人的情况下，不招也行。</li><li>第四、了解行业动态。这主要是部门某些人心术不正，让面试者赶来面试，当免费老师，以面试为名从面试者口中获取一些其它公司的技术内幕。（搞技术的人都不傻，出来混迟早要还的，心术不正败坏的是自己公司的名声。）</li></ul></li><li>面试官问你的职业规划？该怎么回答？回答这个问题要注意三点：<ul><li>接地气。也就是实实在在的说，不做作。这应该是在跟HR交流各个问题都要注意的，不要去学习面经上那些头头是道的回答，针对性并不强，不能把自己的特质表露出来，这对应聘双方都是无益的。搞清楚自己的想法，流畅的表达就行了（表达上也许需要一些技巧），至于如何搞清楚自己的想法，请看第二点。</li><li>预先做功课。了解自己和了解社会是一生都不应该停止的两个过程。在应聘之前，需要对自己和要应聘的行业、公司、岗位都有一定的了解，知道自己的兴趣点和竞争优势，在这个基础上才能够谈职业规划。</li><li>区分职业和工作。HR问你职业规划，也许只是在探寻你对这个岗位或公司的热衷度，判断你是无关痛痒的仅仅想要一份工作安身，还是对未来的发展有一定的方向，方向和目标自然不可能太具体，所以觉得难回答，但是，面试官想知道的其实是你对自己未来的期许是什么样子的，仅此而已。</li><li>参考：我希望在 我 **公司发展成为 公 “T”字形人才，短期目标，我希望能够接触尽可能多的知识面，努力扩展自己专业技能的 字 “横”，可以独立的完成工作中的每一个任务。长期目标，我希望自己在知识面足够宽的基础上，能够有一到两个方向的深入研究，深入自己工作中的一 长 ”竖“，早日独当一面，成为公司的中流砥柱，</li></ul></li></ul><h4 id="人事问工资该如何回答？"><a href="#人事问工资该如何回答？" class="headerlink" title="人事问工资该如何回答？"></a>人事问工资该如何回答？</h4><ul><li>2年工作经验：<ul><li>薪资、福利、加班情况及有无加班费、年终奖、年假、有无培训等</li><li>工作的内容，公司的发展</li><li>半年的时候去做大数据项目后加过一次薪，9000加到了12000.</li><li>12K——-17K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1000左右</li></ul></li><li>3年工作经验：<ul><li>17K——–23K 具体的工资组成我不清楚，但是我知道，我们没有上公积金。每个月我拿到手的工资是1400左右</li><li>具体的情况，根据面试的好坏做相应的调整，但是工资的税前和税后差额一般在2k—3k</li></ul></li><li>面试的本质不是一问一答，而是亮点展示</li></ul><h1 id="请介绍一下你自己"><a href="#请介绍一下你自己" class="headerlink" title="请介绍一下你自己"></a>请介绍一下你自己</h1><ul><li>这是面试官100%会问的问题，一般人回答这个问题过于平常，只说姓名、年龄、爱好、所学专业等，如果你用一分钟来重复你的简历，那么，你的印象加分没有了！</li><li>不妨坦诚自信地展现自我，重点突出与应聘职位相吻合的优势。你的相关能力和素质是企业最感兴趣的信息。因为，在许多情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。</li><li>回答范例：我叫XX，今年X岁，XXXX年毕业于XX大学。有3年的开发工作经验，我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，精通.Net技术体系，熟悉MVC。平常有时间看看博客，并且自己也喜欢在CSDN上写技术类的文章，与博友一起讨论。谢谢！</li></ul><h1 id="为什么来北京找工作？"><a href="#为什么来北京找工作？" class="headerlink" title="为什么来北京找工作？"></a>为什么来北京找工作？</h1><ul><li>面试官对异地求职者90%都会问的问题，主要考察你是否稳定，个人经验能力之外，排在第一位的就是稳定性，如果不够稳定，那么其余都是空谈。</li><li>回答范例：我来自河南，河南是一个农业大省，IT行业还不是很发达，我是学计算机专业的，也很喜欢这个行业，北京在国内IT行业发展是最快的，所以我想来这里谋求发展，学习更多的新技术，能够带来自我的提升。</li><li>注意：不要说以前公司有多么不好。也不要说哪个哥们混的很不错，羡慕才来北京。因为企业招人想要的都是能够长期工作的人，可能哪个哥们哪天在别的地方又混的更好了，你是不是还要跳槽？所以，只要说来学习更多新技术和管理经验就够了。</li></ul><h1 id="你为什么离开原来的公司？"><a href="#你为什么离开原来的公司？" class="headerlink" title="你为什么离开原来的公司？"></a>你为什么离开原来的公司？</h1><ul><li>最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在</li><li>避免把“离职原因”说得太详细、太具体</li><li>不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等</li><li>但也不能躲闪、回避，如“想换换环境”、“个人原因”等</li><li>不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等</li><li>尽量使解释的理由为应聘者个人形象添彩</li><li>相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</li><li>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职，这个答案一般面试官还能接受。</li></ul><h1 id="你最大的缺点是什么？"><a href="#你最大的缺点是什么？" class="headerlink" title="你最大的缺点是什么？"></a>你最大的缺点是什么？</h1><ul><li>被面试官问的概率很大，也是HR的杀手锏和狠招，这个问题最难回答，通常面试官不希望听到求职直接回答的缺点是什么，如果求职者说自己小心眼、脾气大、工作效率低，企业肯定不会录用你。不要自作聪明地回答“我最大的缺点就是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。面试官喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上，突出优点的部分，面试官喜欢聪明的求职者。</li><li>回答范例：这个问题好难回答啊！我想想……（亲和力表现，也缓解了自己的紧张情绪）我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。</li></ul><h1 id="你未来3-5年的职业规划是怎样的？"><a href="#你未来3-5年的职业规划是怎样的？" class="headerlink" title="你未来3-5年的职业规划是怎样的？"></a>你未来3-5年的职业规划是怎样的？</h1><ul><li>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</li><li>回答范例：我希望从现在开始，1-2年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以从开发做到架构师。同时我也希望自己能够在企业的平台上得到进一步的职业能力提升。</li></ul><h1 id="你对薪资的要求？"><a href="#你对薪资的要求？" class="headerlink" title="你对薪资的要求？"></a>你对薪资的要求？</h1><ul><li>如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求职的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</li><li>回答范例一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。</li><li>如果你必须自己说出具体数目，那就不要说一个宽泛的范围，不要说7000-8000之间，那样你将只会得到最低限底的数字，也就是7000。最好给出一个具体的数字。</li></ul><h1 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h1><ul><li>大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司的规定上班”，如果还未辞去上一个工作，但上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</li></ul><h1 id="介绍一个你认为最熟悉的项目（项目经理）"><a href="#介绍一个你认为最熟悉的项目（项目经理）" class="headerlink" title="介绍一个你认为最熟悉的项目（项目经理）"></a>介绍一个你认为最熟悉的项目（项目经理）</h1><ul><li>这个问题在技术面试时常被问到，问这个问题的意图是想考察你的成长路径和编程习惯，因为，你最熟悉的项目往往是你成长最快的项目，那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹。所以，通过你对熟悉项目的描述，有经验的他会很快锁定你技术成长中的缺陷和闪光点，从而判断是否能够“为我所用”。</li><li>你最好拿出一个自己最擅长技术的那个项目进行介绍，他听完你的介绍后，会接下来进行提问，这样他所有问的问题，你都成竹在胸了。</li><li>切忌拿自己参与很少的项目来介绍，一旦他深入的询问很可能你会答非所问，反而造成更严重的影响。你大强以和他谈谈在那个项目中获得的经验，这样会引起此君的共鸣，有可能的话，说出一些你自己的小技巧，他会很高兴，同时这场面试也会很轻松，拿到Offer基本没问题了。</li></ul><h1 id="如果公司录用你，你将怎样开展工作？"><a href="#如果公司录用你，你将怎样开展工作？" class="headerlink" title="如果公司录用你，你将怎样开展工作？"></a>如果公司录用你，你将怎样开展工作？</h1><ul><li>很多企业在招聘开发人员时很看重是否能够尽快上手，所以回答这个问题时要“实打实”的回答，在回答中最好强调能够“尽快”投入开发工作中，这样领导就放心了，会觉得你不是一个只会盲目工作的人，而是一个按部就班，稳打稳扎的人。</li><li>回答范例：我对咱们公司的大体情况只有一个大概了解，在这个职位的工作性质仅仅是我自己的一个理解。作为这个职位而言，我想我首先要对本公司的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向、我们面向的客户性质等。第二我要了解所属部门在公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。第三，了解我参与项目的开发方式，架构方式，紧密配合领导工作，尽快投入具体的开发工作中。这就是我开展工作的计划。</li></ul><h1 id="你还有什么问题问我吗？"><a href="#你还有什么问题问我吗？" class="headerlink" title="你还有什么问题问我吗？"></a>你还有什么问题问我吗？</h1><ul><li>这个问题看上去可有可无，其实很关键，面试官不喜欢说“没有问题”的人，没有问题就是自寻死路，没有问题传达出你对公司缺乏兴趣，而只是来寻找一笔薪水。其实在面试过程中谦虚礼貌的问面试官怎么称呼，该部门工作中的信息，如项目情况，开发技术再或者说贵公司的晋升机制是什么样的等。表现出一种很积极主动的状态是非常讨巧的。也可以更多的了解到自己来的工作环境。企业很欢迎这样的求职者，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。</li></ul><h1 id="你对加班的看法？"><a href="#你对加班的看法？" class="headerlink" title="你对加班的看法？"></a>你对加班的看法？</h1><ul><li>实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。</li><li>回答范例：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</li></ul><h1 id="你朋友对你的评价？"><a href="#你朋友对你的评价？" class="headerlink" title="你朋友对你的评价？"></a>你朋友对你的评价？</h1><ul><li>回答提示： 想从侧面了解一下你的性格及与人相处的问题。</li><li>回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。</li><li>回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。</li></ul><h1 id="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"><a href="#如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？" class="headerlink" title="如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"></a>如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</h1><ul><li>回答提示：一段时间发现工作不适合我，有两种情况：<ul><li>如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</li><li>你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</li></ul></li></ul><h1 id="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"><a href="#在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？" class="headerlink" title="在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"></a>在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</h1><ul><li>原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。</li><li>如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。</li><li>还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</li></ul><h1 id="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"><a href="#如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？" class="headerlink" title="如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"></a>如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</h1><ul><li>我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。</li><li>分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。</li><li>总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</li></ul><h1 id="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"><a href="#如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？" class="headerlink" title="如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"></a>如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</h1><ul><li>我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：<ul><li>我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。</li><li>他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</li></ul></li></ul><h1 id="谈谈你对跳槽的看法？"><a href="#谈谈你对跳槽的看法？" class="headerlink" title="谈谈你对跳槽的看法？"></a>谈谈你对跳槽的看法？</h1><ul><li>正常的“跳槽”能促进人才合理流动，应该支持。</li><li>频繁的跳槽对单位和个人双方都不利，应该反对。</li></ul><h1 id="工作中你难以和同事、上司相处，你该怎么办？"><a href="#工作中你难以和同事、上司相处，你该怎么办？" class="headerlink" title="工作中你难以和同事、上司相处，你该怎么办？"></a>工作中你难以和同事、上司相处，你该怎么办？</h1><ul><li>我会服从领导的指挥，配合同事的工作。</li><li>我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话 我会努力改正。</li><li>如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。</li><li>作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。</li></ul><h1 id="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"><a href="#假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？" class="headerlink" title="假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"></a>假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</h1><ul><li>成绩比较突出，得到领导的肯定是件好事情，以后更加努力。</li><li>检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。</li><li>工作中，切勿伤害别人的自尊心。</li><li>不再领导前拨弄是非。<br>。</li></ul><h1 id="请说出你选择这份工作的动机？"><a href="#请说出你选择这份工作的动机？" class="headerlink" title="请说出你选择这份工作的动机？"></a>请说出你选择这份工作的动机？</h1><ul><li>这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</li></ul><h1 id="你最擅长的技术方向是什么？"><a href="#你最擅长的技术方向是什么？" class="headerlink" title="你最擅长的技术方向是什么？"></a>你最擅长的技术方向是什么？</h1><ul><li>说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</li></ul><h1 id="你能为我们公司带来什么呢？"><a href="#你能为我们公司带来什么呢？" class="headerlink" title="你能为我们公司带来什么呢？"></a>你能为我们公司带来什么呢？</h1><ul><li>企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。</li></ul><h1 id="最能概括你自己的三个词是什么？"><a href="#最能概括你自己的三个词是什么？" class="headerlink" title="最能概括你自己的三个词是什么？"></a>最能概括你自己的三个词是什么？</h1><ul><li>我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，</li></ul><h1 id="你的业余爱好是什么？"><a href="#你的业余爱好是什么？" class="headerlink" title="你的业余爱好是什么？"></a>你的业余爱好是什么？</h1><ul><li>找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。</li></ul><h1 id="作为被面试者给我打一下分？"><a href="#作为被面试者给我打一下分？" class="headerlink" title="作为被面试者给我打一下分？"></a>作为被面试者给我打一下分？</h1><ul><li>试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</li></ul><h1 id="你怎么理解你应聘的职位？"><a href="#你怎么理解你应聘的职位？" class="headerlink" title="你怎么理解你应聘的职位？"></a>你怎么理解你应聘的职位？</h1><ul><li>把岗位职责和任务及工作态度阐述一下。</li></ul><h1 id="喜欢这份工作的哪一点？"><a href="#喜欢这份工作的哪一点？" class="headerlink" title="喜欢这份工作的哪一点？"></a>喜欢这份工作的哪一点？</h1><ul><li>相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</li></ul><h1 id="说说你对行业、技术发展趋势的看法？"><a href="#说说你对行业、技术发展趋势的看法？" class="headerlink" title="说说你对行业、技术发展趋势的看法？"></a>说说你对行业、技术发展趋势的看法？</h1><ul><li>企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</li></ul><h1 id="对工作的期望与目标何在？"><a href="#对工作的期望与目标何在？" class="headerlink" title="对工作的期望与目标何在？"></a>对工作的期望与目标何在？</h1><ul><li>这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。</li></ul><h1 id="说你的家庭"><a href="#说你的家庭" class="headerlink" title="说你的家庭"></a>说你的家庭</h1><ul><li>企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。</li><li>企业希望听到的重点也在于家庭对求职者的积极影响。</li><li>企业最喜欢听到的是：我很爱我的家庭，我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。</li><li>我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。</li><li>企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</li></ul><h1 id="就你申请的这个职位，你认为你还欠缺什么？"><a href="#就你申请的这个职位，你认为你还欠缺什么？" class="headerlink" title="就你申请的这个职位，你认为你还欠缺什么？"></a>就你申请的这个职位，你认为你还欠缺什么？</h1><ul><li>企业喜欢问求职者弱点，但精明的求职者一般不直接回答。</li><li>他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</li></ul><h1 id="你欣赏哪种性格的人？"><a href="#你欣赏哪种性格的人？" class="headerlink" title="你欣赏哪种性格的人？"></a>你欣赏哪种性格的人？</h1><ul><li>诚实、不死板而且容易相处的人、有“实际行动”的人。</li></ul><h1 id="你通常如何处理別人的批评？"><a href="#你通常如何处理別人的批评？" class="headerlink" title="你通常如何处理別人的批评？"></a>你通常如何处理別人的批评？</h1><ul><li>沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。</li><li>我会等大家冷靜下来再讨论。</li></ul><h1 id="你为什么愿意到我们公司来工作？"><a href="#你为什么愿意到我们公司来工作？" class="headerlink" title="你为什么愿意到我们公司来工作？"></a>你为什么愿意到我们公司来工作？</h1><ul><li>对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</li></ul><h1 id="你和别人发生过争执吗？你是怎样解决的？"><a href="#你和别人发生过争执吗？你是怎样解决的？" class="headerlink" title="你和别人发生过争执吗？你是怎样解决的？"></a>你和别人发生过争执吗？你是怎样解决的？</h1><ul><li>这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。</li><li>你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。</li><li>他们通过这个问题了解你的成熟度和处世能力。</li><li>在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</li></ul><h1 id="问题：你做过的哪件事最令自己感到骄傲？"><a href="#问题：你做过的哪件事最令自己感到骄傲？" class="headerlink" title="问题：你做过的哪件事最令自己感到骄傲？"></a>问题：你做过的哪件事最令自己感到骄傲？</h1><ul><li>这是考官给你的一个机会，让你展示自己把握命运的能力。</li><li>这会体现你潜在的领导能力以及你被提升的可能性。</li><li>假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐</li><li>记住：你的前途取决于你的知识、你的社交能力和综合表现。</li></ul><h1 id="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"><a href="#新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？" class="headerlink" title="新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？"></a>新到一个部门，一天一个客户来找你解决问题，你努力想让他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低，你这个时候怎么作？</h1><ul><li>首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。</li><li>其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。</li><li>再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。</li><li>再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。</li><li>我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。</li></ul><h1 id="对这项工作，你有哪些可预见的困难？"><a href="#对这项工作，你有哪些可预见的困难？" class="headerlink" title="对这项工作，你有哪些可预见的困难？"></a>对这项工作，你有哪些可预见的困难？</h1><ul><li>不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。</li><li>可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。</li><li>分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。</li><li>当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</li></ul><h1 id="怎样对待自己的失敗？"><a href="#怎样对待自己的失敗？" class="headerlink" title="怎样对待自己的失敗？"></a>怎样对待自己的失敗？</h1><ul><li>我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</li></ul><h1 id="什么会让你有成就感？"><a href="#什么会让你有成就感？" class="headerlink" title="什么会让你有成就感？"></a>什么会让你有成就感？</h1><ul><li>为贵公司竭力效劳，尽我所能，完成一个项目。</li></ul><h1 id="眼下你生活中最重要的是什么？"><a href="#眼下你生活中最重要的是什么？" class="headerlink" title="眼下你生活中最重要的是什么？"></a>眼下你生活中最重要的是什么？</h1><ul><li>对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。</li></ul><h1 id="与上级意见不一是，你将怎么办？"><a href="#与上级意见不一是，你将怎么办？" class="headerlink" title="与上级意见不一是，你将怎么办？"></a>与上级意见不一是，你将怎么办？</h1><ul><li><p>一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</p></li><li><p>如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</p></li><li><p>分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p></li><li><p>你工作经验欠缺，如何能胜任这项工作？</p></li><li><p>如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。</p></li><li><p>对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。</p></li><li><p>如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。”</p></li><li><p>点评：这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p></li></ul><h1 id="你希望与什么样的上级共事？"><a href="#你希望与什么样的上级共事？" class="headerlink" title="你希望与什么样的上级共事？"></a>你希望与什么样的上级共事？</h1><ul><li>通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。</li><li>最好回避对上级具体的希望，多谈对自己的要求。</li><li>如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。</li><li>分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</li></ul><h1 id="谈谈如何适应办公室工作的新环境？"><a href="#谈谈如何适应办公室工作的新环境？" class="headerlink" title="谈谈如何适应办公室工作的新环境？"></a>谈谈如何适应办公室工作的新环境？</h1><ul><li>办公室里每个人有各自的岗位与职责，不得擅离岗位。</li><li>根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。</li><li>多请示并及时汇报，遇到不明白的要虚心请教。</li><li>抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</li></ul><h1 id="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"><a href="#为了做好你工作份外之事，你该怎样获得他人的支持和帮助？" class="headerlink" title="为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"></a>为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</h1><ul><li>每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</li></ul><h1 id="如果你在这次面试中没有被录用，你怎么打算？"><a href="#如果你在这次面试中没有被录用，你怎么打算？" class="headerlink" title="如果你在这次面试中没有被录用，你怎么打算？"></a>如果你在这次面试中没有被录用，你怎么打算？</h1><ul><li>现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。</li><li>我会从以下几个方面来正确看待这次失败：<ul><li>要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。</li><li>善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。</li><li>走出阴影，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。</li><li>认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行、行行出状元，争取在本岗位上做出一定的成绩。</li><li>再接再厉，成为国家公务员一直是我的梦想，以后如果有机会我仍然后再次参加竞争。</li></ul></li></ul><h1 id="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"><a href="#假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？" class="headerlink" title="假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？"></a>假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？</h1><ul><li>我觉得工作是第一位的，但朋友间的情谊也是不能偏废的，这个问题我觉得要按照当时具体的情况来决定。</li><li>如果我的朋友晚上9点中的飞机，而我的加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。</li><li>如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。</li><li>如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。<ul><li>如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。</li><li>如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，相信他会理解，毕竟工作做完了就完了，朋友还是可以再见面的。</li></ul></li></ul><h1 id="谈谈你过去做过的成功案例？"><a href="#谈谈你过去做过的成功案例？" class="headerlink" title="谈谈你过去做过的成功案例？"></a>谈谈你过去做过的成功案例？</h1><ul><li>举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。</li><li>切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</li></ul><h1 id="谈谈你过去的工作经验中，最令你挫折的事情？"><a href="#谈谈你过去的工作经验中，最令你挫折的事情？" class="headerlink" title="谈谈你过去的工作经验中，最令你挫折的事情？"></a>谈谈你过去的工作经验中，最令你挫折的事情？</h1><ul><li>曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。</li><li>分析：借此了解你对挫折的容忍度及调解方式。</li></ul><h1 id="如何安排自己的时间？会不会排斥加班？"><a href="#如何安排自己的时间？会不会排斥加班？" class="headerlink" title="如何安排自己的时间？会不会排斥加班？"></a>如何安排自己的时间？会不会排斥加班？</h1><ul><li>基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。</li><li>分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</li></ul><h1 id="为什么我们要在众多的面试者中选择你？"><a href="#为什么我们要在众多的面试者中选择你？" class="headerlink" title="为什么我们要在众多的面试者中选择你？"></a>为什么我们要在众多的面试者中选择你？</h1><ul><li>根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、ＥＱ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。</li><li>分析：别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。</li></ul><h1 id="你并非毕业于名牌院校？"><a href="#你并非毕业于名牌院校？" class="headerlink" title="你并非毕业于名牌院校？"></a>你并非毕业于名牌院校？</h1><ul><li>是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我想我更适合贵公司这个职位。</li></ul><h1 id="怎样看待学历和能力？"><a href="#怎样看待学历和能力？" class="headerlink" title="怎样看待学历和能力？"></a>怎样看待学历和能力？</h1><ul><li>学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？</li></ul><h1 id="工作中学习到了些什么？"><a href="#工作中学习到了些什么？" class="headerlink" title="工作中学习到了些什么？"></a>工作中学习到了些什么？</h1><ul><li>这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</li></ul><h1 id="想过创业吗？"><a href="#想过创业吗？" class="headerlink" title="想过创业吗？"></a>想过创业吗？</h1><ul><li>这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？</li></ul><h1 id="除了本公司外，还应聘了哪些公司？"><a href="#除了本公司外，还应聘了哪些公司？" class="headerlink" title="除了本公司外，还应聘了哪些公司？"></a>除了本公司外，还应聘了哪些公司？</h1><ul><li>很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</li></ul><h1 id="面试注意事项："><a href="#面试注意事项：" class="headerlink" title="面试注意事项："></a>面试注意事项：</h1><ul><li>在面试官面前千万不要抖脚，手脚不要动来动去，不能有小动作。</li><li>在面试过程中，千万不要跟面试官去争论，说话太冲，太能说、抢话说、乱说都不好，遇到难题，先思考一下，切记心浮气燥，表达时口气温和，谦虚。</li><li>如果面试过程中都不错，谈的也很好，之后却没有给Offer，完全是自己意料之外的情况，这个很有可能，或许是因为公司有了其他的人选，不用介意，更不要沮丧。</li><li>在面试过程中，切忌问关于公司计划、行业机密等相关的东西，不要打探公司的内幕，机密敏感性的问题不要问东问西。</li><li>千万要注意仪容仪表，要有礼貌，最好不要有口吃，口头表达，逻辑思维很重要，不要让面试官觉得你很幼稚，太过小孩子气，显的不够稳重踏实。</li><li>在去面试之前，要熟悉自己的简历，特别是工作经历，准备好关于一些离职原因、职业规划方面的问题的回答方式。</li><li>在面试过程中，80%的面试官会让做自我介绍，所以提前要准备一下，说出的内容既要和简历相符，又要有重点有突出的地方，不能像背简历一样。</li><li>面试完后，如果等待的时间较长，没有回应，就可能没有什么希望了，自己可以打电话去了解情况。</li><li>在面试过程中，谈到薪资的时候，如果没有说明是税后工资就是税前，假如是税前6000，这里面就包括了公司给交的公积金，还有其他五险要交的费用，拿到手差不多4000左右。</li></ul><h1 id="投递简历注意事项"><a href="#投递简历注意事项" class="headerlink" title="投递简历注意事项"></a>投递简历注意事项</h1><ul><li>投简历的时间最好在早上8点多钟，因为人事9点多开始收简历，收到的简历又都是按时间来排序的，所以一般早上8点到9点投的都会排在前面，人事当天就能看到。</li><li>写简历：<ul><li>现居住地最好能在企业附近，如果不在，只写北京，人事比较看重现居住地，如果你填写的现居地离公司远，基本上人事就不太愿意打电话了，因为她（他）怕你不会来。</li><li>期望薪资最好不要写在简历上，也不要填写在网上的简历上，具体薪资见面的时候再谈。</li><li>大部分的岗位招聘都有相应的硬性要求，比如：年龄、居住地点、工作年限等。如果自己不符合也没有关系，机会还有很多。</li><li>简历上的工作经历不能太多，否则人事会觉得你不够稳定。</li><li>开发工作，简历上的项目要抓住重点，放重要的技术点，不能千篇一律，简短、抓住中心。</li></ul></li></ul><h1 id="入职后试用期："><a href="#入职后试用期：" class="headerlink" title="入职后试用期："></a>入职后试用期：</h1><ul><li>到了公司之后，工作中不懂的地方要多问，跟同事搞好关系，多看看旁人在干什么～</li><li>有些同学被录用之后都还不知道自己的薪资待遇，也不知道公司有哪些福利，这是因为在面试过程中不敢多问。因此，如果在面试过程中，面试官已经比较明确的表达了想让你去上班后，你就可以在适当的时候问一些关于工作的情况，工资、福利待遇，上班时间，加班情况等等。</li></ul><h1 id="上家公司的组成架构"><a href="#上家公司的组成架构" class="headerlink" title="上家公司的组成架构"></a>上家公司的组成架构</h1><ul><li>根据你的公司来定即可</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/98f0d77a0556.html" class="post-title-link" itemprop="url">数据结构与算法</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:35:25" itemprop="dateCreated datePublished" datetime="2023-12-20T15:35:25+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-26 20:27:05" itemprop="dateModified" datetime="2023-12-26T20:27:05+08:00">2023-12-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说⼀下⼏种常⻅的排序算法和分别的复杂度"><a href="#说⼀下⼏种常⻅的排序算法和分别的复杂度" class="headerlink" title="说⼀下⼏种常⻅的排序算法和分别的复杂度"></a>说⼀下⼏种常⻅的排序算法和分别的复杂度</h1><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li>原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了.<ul><li>选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。</li><li>基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的分在右边。</li><li>可以肯定，如此⼀轮下来，这个枢轴的位置⼀定在最终位置上。</li><li>对两个⼦数组分别重复上述过程，直到每个数组只有⼀个元素。</li><li>排序完成。</li></ul></li><li>复杂度：O(n)</li><li>特点：快速排序是我们平常最常使⽤的⼀种排序算法,因为它速度快,效率⾼,是最优秀的⼀种排序算法.</li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li>原理：冒泡排序其实就是逐⼀⽐较交换,进⾏⾥外两次循环,外层循环为遍历所有数字,逐个确定每个位置,⾥层循环为确定了位置后,遍历所有后⾯没有确定位置的数字,与该位置的数字进⾏⽐较,只要⽐该位置的数字⼩,就和该位置的数字进⾏交换.</li><li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li><li>特点：冒泡排序在我们实际开发中,使⽤的还是⽐较少的.它更加适合数据规模⽐较少的时候,因为它的效率是⽐较低的,但是优点是逻辑简单,容易让我们记得.</li></ul><h4 id="直接插⼊排序"><a href="#直接插⼊排序" class="headerlink" title="直接插⼊排序"></a>直接插⼊排序</h4><ul><li>原理：直接插⼊排序是将从第⼆个数字开始,逐个拿出来,插⼊到之前排好序的数列⾥.</li><li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li></ul><h4 id="直接选择排序："><a href="#直接选择排序：" class="headerlink" title="直接选择排序："></a>直接选择排序：</h4><ul><li>原理：直接选择排序是从第⼀个位置开始遍历位置,找到剩余未排序的数据⾥最⼩的,找到最⼩的后,再做交换</li><li>复杂度：O(n^2)</li><li>特点：和冒泡排序⼀样,逻辑简单,但是效率不⾼,适合少量的数据排序</li></ul><h1 id="描述⼀下链式存储结构"><a href="#描述⼀下链式存储结构" class="headerlink" title="描述⼀下链式存储结构"></a>描述⼀下链式存储结构</h1><ul><li>线性结构的优点是可以实现随机读取，时间复杂度为O(1)，空间利⽤率⾼，缺点是进⾏插⼊和删除操作时⽐较麻烦，时间复杂度为O(n)，同时容量受限制，需要事先确定容量⼤⼩，容量过⼤，浪费空间资源，过⼩不能满⾜使⽤要求，会产⽣溢出问题。</li><li>链式存储结构的优点主要是插⼊和删除⾮常简单，前提条件是知道操作位置，时间复杂度是O(1)，但如果不知道操作位置则要定位元素，时间复杂度为O(n)，没有容量的限制，可以使⽤过程中动态分配的分配内存空间，不⽤担⼼溢出问题，但是它并不能实现随机读取，同时空间利⽤率不⾼。</li></ul><h1 id="如何遍历⼀颗⼆叉树"><a href="#如何遍历⼀颗⼆叉树" class="headerlink" title="如何遍历⼀颗⼆叉树"></a>如何遍历⼀颗⼆叉树</h1><ul><li>先输出节点的值，再递归遍历左右⼦树。中序和后序的递归类似，改变根节点输出位置即可。</li></ul><h1 id="倒排⼀个LinkedList"><a href="#倒排⼀个LinkedList" class="headerlink" title="倒排⼀个LinkedList"></a>倒排⼀个LinkedList</h1><ul><li>Collections.reverse(linkedList);</li></ul><h1 id="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"><a href="#⽤java写⼀个递归遍历⽬录下⾯的所有⽂件" class="headerlink" title="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"></a>⽤java写⼀个递归遍历⽬录下⾯的所有⽂件</h1><ul><li>File.listFiles()</li></ul><h1 id="⼆叉树与红⿊树："><a href="#⼆叉树与红⿊树：" class="headerlink" title="⼆叉树与红⿊树："></a>⼆叉树与红⿊树：</h1><h4 id="⼆叉树"><a href="#⼆叉树" class="headerlink" title="⼆叉树"></a>⼆叉树</h4><ul><li>左⼦树上所有结点的值均⼩于或等于它的根结点的值。</li><li>右⼦树上所有结点的值均⼤于或等于它的根结点的值。</li><li>左、右⼦树也分别为⼆叉排序树。</li><li>查找：⼆分查找（通过⼀层⼀层的⽐较⼤⼩来查找位置）：如查找值为10的节点：9–13–11–10</li><li>缺陷：插⼊容易变成线性形态，查找性能⼤打折扣，这时需要引⼊红⿊树来解决</li></ul><h4 id="红⿊树"><a href="#红⿊树" class="headerlink" title="红⿊树"></a>红⿊树</h4><ul><li>特点：是⼀种⾃平衡的⼆叉查找树，除了符合⼆叉树的特点之外，还符合以下⼏点：<ul><li>节点是红⾊或⿊⾊。</li><li>根节点是⿊⾊。</li><li>每个叶⼦节点都是⿊⾊的空节点（NIL节点）。</li><li>每个红⾊节点的两个⼦节点都是⿊⾊。(从每个叶⼦到根的所有路径上不能有两个连续的红⾊节点)</li><li>从任⼀节点到其每个叶⼦的所有路径都包含相同数⽬的⿊⾊节点。</li></ul></li><li>这些规则保证了红⿊树的⾃平衡。</li><li>红⿊树从根到叶⼦的最长路径不会超过最短路径的2倍。</li><li>提⾼寻址效率。</li><li>添加删除：通过⾃旋来保证平衡</li></ul><h1 id="b-tree、b-tree多叉树："><a href="#b-tree、b-tree多叉树：" class="headerlink" title="b-tree、b+tree多叉树："></a>b-tree、b+tree多叉树：</h1><h4 id="b-tree"><a href="#b-tree" class="headerlink" title="b-tree"></a>b-tree</h4><ul><li>⽂件系统</li><li>B树也称B-树,它是⼀颗多路平衡查找树</li><li>我们描述⼀颗B树时需要指定它的阶数，阶数表示了⼀个结点最多有多少个孩⼦结点，⼀般⽤字⺟m表示阶数</li><li>当m取2时，就是我们常⻅的⼆叉搜索树。</li><li>定义：<ul><li>每个结点最多有m-1个关键字。</li><li>根结点最少可以只有1个关键字。</li><li>⾮根结点⾄少有Math.ceil(m&#x2F;2)-1个关键字。</li><li>每个结点中的关键字都按照从⼩到⼤的顺序排列，每个关键字的左⼦树中的所有关键字都⼩于它，⽽右⼦树中的所有关键字都⼤于它。</li><li>所有叶⼦结点都位于同⼀层，或者说根结点到每个叶⼦结点的⻓度都相同。</li></ul></li><li>插⼊数据，向兄弟节点借，兄弟节点不够则向⽗节点借；</li></ul><h4 id="b-tree-1"><a href="#b-tree-1" class="headerlink" title="b+tree"></a>b+tree</h4><ul><li>mysql索引</li><li>定义：<ul><li>B+树包含2种类型的结点：内部结点（也称索引结点）和叶⼦结点。根结点本身即可以是内部结点，也可以是叶⼦结点。根结点的关键字个数最少可以只有1个。</li><li>B+树与B树最⼤的不同是内部结点不保存数据，只⽤于索引，所有数据（或者说记录）都保存在叶⼦结点中。</li><li>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个⼦树），阶数m同时限制了叶⼦结点最多存储m-1个记录。</li><li>内部结点中的key都按照从⼩到⼤的顺序排列，对于内部结点中的⼀个key，左树中的所有key都⼩于它，右⼦树中的key都⼤于等于它。叶⼦结点中的记录也按照key的⼤⼩排列。</li><li>每个叶⼦结点都存有相邻叶⼦结点的指针，叶⼦结点本身依关键字的⼤⼩⾃⼩⽽⼤顺序链接。</li></ul></li></ul><h1 id="谈谈数据结构，⽐如TreeMap："><a href="#谈谈数据结构，⽐如TreeMap：" class="headerlink" title="谈谈数据结构，⽐如TreeMap："></a>谈谈数据结构，⽐如TreeMap：</h1><ul><li>TreeMap实现了红⿊树的结构。</li></ul><h1 id="图的深度遍历和⼴度遍历"><a href="#图的深度遍历和⼴度遍历" class="headerlink" title="图的深度遍历和⼴度遍历"></a>图的深度遍历和⼴度遍历</h1><ul><li>深度优先遍历：深度优先遍历尽可能优先往深层次进⾏搜索</li><li>⼴度优先遍历：⼴度优先遍历按层次优先搜索最近的结点，⼀层⼀层往外搜索。</li></ul><h1 id="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"><a href="#说说java集合，每个集合下⾯有哪些实现类，及其数据结构" class="headerlink" title="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"></a>说说java集合，每个集合下⾯有哪些实现类，及其数据结构</h1><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li>概念<ul><li>在HashMap内部，采⽤了数组+链表的形式来组织键值对Entry&lt;Key,Value&gt;（利⽤数组的查询快+链表的插⼊删除快）</li><li>HashMap在存储键值对Entry&lt;Key,Value&gt;的时候，会根据Key的hashcode值，以某种映射关系，决定应当将这对键值对Entry&lt;Key,Value&gt;存储在HashMap中的什么位置上</li><li>在JDK1.7进⾏多线程put操作，之后遍历，直接死循环，CPU飙到100%，在JDK 1.8中进⾏多线程操作会出现节点和value值丢失，为什么JDK1.7与JDK1.8多线程操作会出现很⼤不同，是因为JDK 1.8的作者对resize⽅法进⾏了优化不会产⽣链表闭环。</li></ul></li><li>结构</li><li>HashMap扩容<ul><li>很简单的计算：由于默认的加载因⼦是0.75 ，那么，此时map的阀值是 16*0.75 &#x3D; 12，即添加第13 个键值对&lt;Key,Value&gt;的时候，map的容量会扩充⼀倍。</li><li>确实如此，但是为了尽可能第减少桶中的Entry&lt;Key,Value&gt;链表的长度，以提⾼HashMap的存取性能，确定的这个经验值</li></ul></li><li>扩容步骤：<ul><li>申请⼀个新的、⼤⼩为当前容量两倍的数组；</li><li>将旧数组的Entry[] table中的链表重新计算hash值，然后重新均匀地放置到新的扩充数组中；</li><li>释放旧的数组；</li></ul></li><li>为何扩容为原来的两倍（性能）：<ul><li>在HashMap通过键的哈希值进⾏定位桶位置的时候，调⽤了⼀个indexFor(hash, table.length);⽅法。</li><li>通过限制length是⼀个2的幂数，h &amp; (length-1)和h % length结果是⼀致的。</li><li>如果length是⼀个2的幂的数，那么length-1就会变成⼀个mask, 它会将hashcode低位取出来，</li><li>hashcode的低位实际就是余数，和取余操作相⽐，与操作会将性能提升很多。</li></ul></li><li>put流程<ul><li>获取这个Key的hashcode值，根据此值确定应该将这⼀对键值对存放在哪⼀个桶中，即确定要存放桶的索引；</li><li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul><li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,其中的Value值更新为新的Value值；返回旧值；</li><li>若不存在，则根据键值对&lt;Key,Value&gt; 创建⼀个新的Entry&lt;Key,Value&gt;对象，然后添加到这个桶的Entry&lt;Key,Value&gt;</li></ul></li><li>当前的HashMap的⼤⼩(即Entry&lt;key,Value&gt;节点的数⽬)是否超过了阀值，若超过了阀值(threshold)，</li><li>则增⼤HashMap的容量(即Entry[] table 的⼤⼩)，并且重新组织内部各个Entry&lt;Key,Value&gt;排列。</li></ul></li><li>get流程<ul><li>获取这个Key的hashcode值，根据此hashcode值决定应该从哪⼀个桶中查找；</li><li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul><li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,返回value</li><li>若不存在，返回null；</li></ul></li></ul></li></ul><h1 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>红黑树是一种自平衡二叉查找树</li><li>它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用</li><li>它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。</li></ul><h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><ul><li>红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡</li><li>它的每个节点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父节点）。</li><li>红黑树的定义也是它的性质，有以下五条：<ul><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色（叶子是NIL节点）</li><li>如果一个节点是红的，则它的两个儿子都是黑的</li><li>从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。</li></ul></li><li>这五个性质强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</li><li>为什么呢？性质4暗示着任何一个简单路径上不能有两个毗连的红色节点，这样，最短的可能路径全是黑色节点，最长的可能路径有交替的红色和黑色节点。同时根据性质5知道：所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</li></ul><h4 id="红黑树的基本操作"><a href="#红黑树的基本操作" class="headerlink" title="红黑树的基本操作"></a>红黑树的基本操作</h4><ul><li>因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同</li><li>然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质</li><li>恢复红黑树的性质需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)</li><li>虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次。</li></ul><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><ul><li>插入操作可以概括为以下几个步骤：<ul><li>查找要插入的位置，时间复杂度为：O(N)</li><li>将新节点的color赋为红色</li><li>自下而上重新调整该树为红黑树</li></ul></li><li>其中，第(1)步的查找方法跟普通二叉查找树一样</li><li>第(2)步之所以将新插入的节点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的</li><li>但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整，这样简单多了</li><li>下面讨论步骤(3)的一些细节：<ul><li>设要插入的节点为N，其父节点为P，其父亲G的兄弟节点为U（即P和U是同一个节点的两个子节点）。</li><li>如果P是黑色的，则整棵树不必调整便是红黑树。</li><li>如果P是红色的（可知，其父节点G一定是黑色的），则插入z后，违背了性质4，需要进行调整</li><li>调整时分以下3种情况：<ul><li>N的叔叔U是红色的</li><li>N的叔叔U是黑色的，且N是右孩子</li><li>N的叔叔U是黑色的，且N是左孩子</li></ul></li></ul></li></ul><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><ul><li>删除操作可以概括为以下几个步骤：<ul><li>查找要删除位置，时间复杂度为：O(N)</li><li>用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点）</li><li>如果删除节点的替换节点为黑色，则需重新调整该树为红黑树</li></ul></li><li>其中，第(1)步的查找方法跟普通二叉查找树一样</li><li>第(2)步之所以用后继节点替换删除节点，是因为这样可以保证该后继节点之上仍是一个红黑树，而后继节点可能是一个叶节点或者只有右子树的节点，这样只需用有节点替换后继节点即可达到删除的目的</li><li>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题</li><li>在第(3)步中，如果，如果删除节点为红色节点，则他的父亲和孩子全为黑节点，这样直接删除该节点即可，不必进行任何调整</li><li>如果删除节点是黑节点，分四种情况：<ul><li>设要删除的节点为N，其父节点为P，其兄弟节点为S。</li><li>由于N是黑色的，则P可能是黑色的，也可能是红色的，S也可能是黑色的或者红色的</li><li>S是红色的</li><li>S和S的孩子全是黑色的</li><li>S是黑色的，S的左孩子是红色，右孩子是黑色</li><li>S是黑色的，S的右孩子是红色</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/e002a9c6759b.html" class="post-title-link" itemprop="url">Java web</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:32:02" itemprop="dateCreated datePublished" datetime="2023-12-20T15:32:02+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-30 14:04:10" itemprop="dateModified" datetime="2023-12-30T14:04:10+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-web/" itemprop="url" rel="index"><span itemprop="name">Java web</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>22k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>20 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service?"></a>什么是Web Service?</h1><ul><li>Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。</li><li>使用的技术：HTTP、XML、SOAP（简单对象访问协议）、WSDL</li><li>优点：跨平台、跨语言、跨系统</li><li>SOAP协议:<ul><li>SOAP协议（Simple Object Access Protocal,简单对象访问协议）</li><li>Tcp&#x2F;iphttp-&gt;soap，soap 通过xml文件传送信息</li></ul></li><li>缺点：<ul><li>WebService使用了XML对数据封装，会造成大量的数据要在网络中传输。</li><li>WebService规范没有规定任何与实现相关的细节，包括对象模型、编程语言，这一点，它不如CORBA。</li></ul></li></ul><h1 id="什么是Web容器"><a href="#什么是Web容器" class="headerlink" title="什么是Web容器?"></a>什么是Web容器?</h1><ul><li>实现J2EE规范中web协议的应用</li><li>该协议定义了web程序的运行时环境,包括:并发性,安全性,生命周期管理等等.</li><li>就是在tomcat、weblogic下运行jsp、servlet、struts</li></ul><h1 id="应用服务器有那些？"><a href="#应用服务器有那些？" class="headerlink" title="应用服务器有那些？"></a>应用服务器有那些？</h1><ul><li>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat</li></ul><h1 id="如何给weblogic指定大小的内存"><a href="#如何给weblogic指定大小的内存" class="headerlink" title="如何给weblogic指定大小的内存?"></a>如何给weblogic指定大小的内存?</h1><ul><li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li></ul><h1 id="如何设定的weblogic的热启动模式-开发模式-与产品发布模式"><a href="#如何设定的weblogic的热启动模式-开发模式-与产品发布模式" class="headerlink" title="如何设定的weblogic的热启动模式(开发模式)与产品发布模式?"></a>如何设定的weblogic的热启动模式(开发模式)与产品发布模式?</h1><ul><li>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一</li><li>或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE&#x3D;true。</li></ul><h1 id="如何启动时不需输入用户名与密码"><a href="#如何启动时不需输入用户名与密码" class="headerlink" title="如何启动时不需输入用户名与密码?"></a>如何启动时不需输入用户名与密码?</h1><ul><li>修改服务启动文件，增加 WLS_USER和WLS_PW项</li><li>也可以在boot.properties文件中增加加密过的用户名和密码.</li></ul><h1 id="在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中"><a href="#在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中" class="headerlink" title="在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?"></a>在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?</h1><ul><li>保存在此Domain的config.xml文件中，它是服务器的核心配置文件。</li></ul><h1 id="说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办"><a href="#说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办" class="headerlink" title="说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?"></a>说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?</h1><ul><li>Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问</li><li>如果是Web应用，应用目录需要满足Web应用目录要求</li><li>jsp文件可以直接放在应用目录中</li><li>Javabean需要放在应用目录的WEB-INF目录的classes目录中</li><li>设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。</li></ul><h1 id="CORBA是什么-用途是什么"><a href="#CORBA是什么-用途是什么" class="headerlink" title="CORBA是什么?用途是什么?"></a>CORBA是什么?用途是什么?</h1><ul><li>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)</li><li>由对象管理组织 (Object Management Group，缩写为 OMG)标准化</li><li>它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议</li><li>其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。</li></ul><h1 id="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"><a href="#说说在weblogic中开发消息Bean时的persistent与non-persisten的差别" class="headerlink" title="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"></a>说说在weblogic中开发消息Bean时的persistent与non-persisten的差别</h1><ul><li>persistent方式的MDB可以保证消息传递的可靠性</li><li>也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来</li><li>而non－persistent方式的消息将被丢弃。</li></ul><h1 id="WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。"><a href="#WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。" class="headerlink" title="WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。"></a>WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</h1><ul><li>Web Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。</li><li>JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口，这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。</li><li>JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。</li><li>WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。</li><li>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。</li><li>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。</li></ul><h1 id="简单说说tomcat的配置？"><a href="#简单说说tomcat的配置？" class="headerlink" title="简单说说tomcat的配置？"></a>简单说说tomcat的配置？</h1><ul><li>JAVA_HOME&#x3D;JDK的根目录</li><li>CATALINA_HOME&#x3D;tomcat的根目录</li><li>CATALINA-HOME\conf\server.xml:可以配置tomcat的端口，可以配置tomcat中下连接池。</li><li>CATALINA-HOME\common\lib:存放公用的类包</li></ul><h1 id="JSP中动态INCLUDE与静态INCLUDE的区别？"><a href="#JSP中动态INCLUDE与静态INCLUDE的区别？" class="headerlink" title="JSP中动态INCLUDE与静态INCLUDE的区别？"></a>JSP中动态INCLUDE与静态INCLUDE的区别？</h1><ul><li>jsp:include:在运行时调用另一个页面，变量是可以重复的。</li><li>&lt;%@include file&#x3D;””%&gt;:在转译时合在一起，会成为同一个类，变量不可以重复。</li><li>&lt;@include file&gt;:在将jsp生成servlet类前将两个文件和在一起，生成一个java类，一起运行的。所以是一家子，当中的变量名不能重名。</li><li>&lt;jsp:include page&gt;:是两个类，是一个调用关系，在运行时动态的调用，不是一家子，可以重复变量。</li></ul><h1 id="forward和redirect的区别？"><a href="#forward和redirect的区别？" class="headerlink" title="forward和redirect的区别？"></a>forward和redirect的区别？</h1><ul><li>forward: 转发，在下一个页面中，request保留上一个页面中的request的所有值</li><li>redirect: 跳转，不传递request对象。</li></ul><h1 id="Servlet的体系结构是什么"><a href="#Servlet的体系结构是什么" class="headerlink" title="Servlet的体系结构是什么?"></a>Servlet的体系结构是什么?</h1><ul><li>Servlet</li><li>GenericServlet</li><li>HttpServlet</li></ul><h1 id="如何实现一个自定义的servlet"><a href="#如何实现一个自定义的servlet" class="headerlink" title="如何实现一个自定义的servlet?"></a>如何实现一个自定义的servlet?</h1><ul><li>extends HttpServlet 并覆盖doPost或doGet方法</li><li>在web.xml中进行部署</li></ul><h1 id="Servlet的生命周期是什么"><a href="#Servlet的生命周期是什么" class="headerlink" title="Servlet的生命周期是什么?"></a>Servlet的生命周期是什么?</h1><ul><li>Init</li><li>多次执行doGet或doPost</li><li>destroy</li></ul><h1 id="jsp就是一个servlet是否正确"><a href="#jsp就是一个servlet是否正确" class="headerlink" title="jsp就是一个servlet是否正确?"></a>jsp就是一个servlet是否正确?</h1><ul><li>对</li></ul><h1 id="请罗列jsp中的脚本、指令及动作"><a href="#请罗列jsp中的脚本、指令及动作" class="headerlink" title="请罗列jsp中的脚本、指令及动作?"></a>请罗列jsp中的脚本、指令及动作?</h1><ul><li>脚本：&lt;%%&gt; &lt;%&#x3D;%&gt; &lt;%!%&gt; &lt;%—-%&gt;</li><li>指令<ul><li>&lt;%@page contentType&#x3D;”text&#x2F;html;charset&#x3D;utf-8” language&#x3D;”java” import&#x3D;””%&gt;</li><li>&lt;%@include file&#x3D;””%&gt;</li><li>&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</li></ul></li><li>动作:<ul><li>&lt;jsp:useBean class&#x3D;”” id&#x3D;”” scope&#x3D;””&gt; 在scope中如果没有实例化一个对象，如果有直接用以前的。</li><li>&lt;jsp:getProperty name&#x3D;”” property&#x3D;””&gt; 向一个bean中设置属性值</li><li>&lt;jsp:forward &gt; jsp页的转发</li><li>&lt;jsp:include page&#x3D;””&gt; 导入一个jsp页面</li></ul></li></ul><h1 id="JSP的内置对象及方法"><a href="#JSP的内置对象及方法" class="headerlink" title="JSP的内置对象及方法"></a>JSP的内置对象及方法</h1><ul><li>Request request表示HttpServletRequest对象。取客户端表单域信息及cookie, header, 和session</li><li>response response表示HttpServletResponse对象，对客户端的响应返回文本、写cookies。</li><li>out out 向客户端打印html文本.</li><li>pageContext :当前jsp页面的上下文环境，可以得到session、request、application等内置对象，在自定义标签中使用的很多。</li><li>session session表示一个请求的javax.servlet.http.HttpSession对象。Session一个用户多个页面共享同一变量。</li><li>application applicaton 表示一个javax.servle.ServletContext对象。存放容器级的变量。</li><li>config config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。</li><li>page page表示从该页面产生的一个servlet实例</li><li>exception:异常，当iserrorpage&#x3D;true</li></ul><h1 id="说出在JSP页面里是怎么分页的"><a href="#说出在JSP页面里是怎么分页的" class="headerlink" title="说出在JSP页面里是怎么分页的?"></a>说出在JSP页面里是怎么分页的?</h1><ul><li>页面需要保存以下参数：(数据库的分页及比较)<ul><li>总行数：根据sql语句得到总行数</li><li>每页显示行数：设定值</li><li>当前页数：请求参数</li></ul></li><li>页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。</li></ul><h1 id="描述JSP和Servlet的区别、共同点、各自应用的范围"><a href="#描述JSP和Servlet的区别、共同点、各自应用的范围" class="headerlink" title="描述JSP和Servlet的区别、共同点、各自应用的范围"></a>描述JSP和Servlet的区别、共同点、各自应用的范围</h1><ul><li>Jsp主要在于页面的显示动态生成页面，可以与html标记一起使用，其还是要生成为一个servlet。</li><li>Servlet：主要是控制的处理，如调用业务层，跳转不同的jsp页面。</li><li>Mvc:<ul><li>Jsp:v</li><li>Servlet:c</li></ul></li></ul><h1 id="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"><a href="#在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？" class="headerlink" title="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"></a>在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？</h1><ul><li>Request.getparameter(“”)</li><li>&lt;%&#x3D;application.getRealPath(“aa.jsp”) %&gt;</li></ul><h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。</h1><ul><li>Cookie:主要用在保存客户端，其值在客户端与服务端之间传送，不安全，存储的数据量有限。</li><li>Session:保存在服务端，每一个session在服务端有一个sessionID作一个标识。存储的数据量大，安全性高。占用服务端的内存资源。</li></ul><h1 id="说明Jsp中errorPage的作用，应用范围。"><a href="#说明Jsp中errorPage的作用，应用范围。" class="headerlink" title="说明Jsp中errorPage的作用，应用范围。"></a>说明Jsp中errorPage的作用，应用范围。</h1><ul><li>正常页面中：%@page erropage&#x3D;”error.jsp”%</li><li>错误页面：&lt;%@page iserrorpage&#x3D;”true”%&gt;</li><li>有一内置对象:exception</li></ul><h1 id="介绍在Jsp中如何使用JavaBeans"><a href="#介绍在Jsp中如何使用JavaBeans" class="headerlink" title="介绍在Jsp中如何使用JavaBeans"></a>介绍在Jsp中如何使用JavaBeans</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean class=”” id=”” scope=””/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	New 类();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="简单介绍JSP的标记库"><a href="#简单介绍JSP的标记库" class="headerlink" title="简单介绍JSP的标记库"></a>简单介绍JSP的标记库</h1><ul><li><p>做一个标记处理类 extends TagSupport</p></li><li><p>通过tld说明标记处理的类的前缀及后缀</p></li><li><p>在web.xml中说明tld文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;taglib&gt;</span><br><span class="line">		&lt;taglib-uri&gt;</span><br><span class="line">		&lt;taglib-location&gt;</span><br><span class="line">&lt;taglib&gt;</span><br></pre></td></tr></table></figure></li><li><p>在jsp页面是引用tld&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</p></li></ul><h1 id="Servlet中的核心类有那些，各有什么特点"><a href="#Servlet中的核心类有那些，各有什么特点" class="headerlink" title="Servlet中的核心类有那些，各有什么特点?"></a>Servlet中的核心类有那些，各有什么特点?</h1><ul><li>ServletContext：容器，放置全局变量<ul><li>setAtribute()</li><li>getAttribute()</li></ul></li><li>ServletConfig：一个servlet的配置<ul><li>getInitParameter(”名称”)</li></ul></li><li>HttpServletRequest：封装的所有的请求<ul><li>getParameterValue(”名称”)</li><li>getParameterValues(”称”)</li></ul></li><li>getSession();<ul><li>getAttribute(” 名称”);</li><li>getRequestDispatch(”a.jsp”).forward(request,response)</li></ul></li><li>HttpServletResponse：响应<ul><li>getOut();</li><li>sendRedirect(””)</li></ul><p></p></li><li>HttpSession：一个用户多个页面共享同一变量<ul><li>setAttribute(””,””)</li></ul></li></ul><h1 id="Servlet中重要的包有那些，有什么区别"><a href="#Servlet中重要的包有那些，有什么区别" class="headerlink" title="Servlet中重要的包有那些，有什么区别?"></a>Servlet中重要的包有那些，有什么区别?</h1><ul><li>javax.servlet.<em>；javax.servlet.http.</em>;</li></ul><h1 id="说出Servlet的生命周期，并说出Servlet和CGI的区别？"><a href="#说出Servlet的生命周期，并说出Servlet和CGI的区别？" class="headerlink" title="说出Servlet的生命周期，并说出Servlet和CGI的区别？"></a>说出Servlet的生命周期，并说出Servlet和CGI的区别？</h1><ul><li>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</li><li>与cgi的区别在于servlet处理服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li></ul><h1 id="什么情况下调用doGet-和doPost-？"><a href="#什么情况下调用doGet-和doPost-？" class="headerlink" title="什么情况下调用doGet()和doPost()？"></a>什么情况下调用doGet()和doPost()？</h1><ul><li>Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。</li></ul><h1 id="如何现实servlet的单线程模式"><a href="#如何现实servlet的单线程模式" class="headerlink" title="如何现实servlet的单线程模式"></a>如何现实servlet的单线程模式</h1><ul><li>在doGet及doPost方法前加入synchoronized</li><li>JSP：&lt;%@ page isThreadSafe&#x3D;”true”%&gt;</li></ul><h1 id="Request对象的主要方法："><a href="#Request对象的主要方法：" class="headerlink" title="Request对象的主要方法："></a>Request对象的主要方法：</h1><ul><li>setAttribute(String name,Object)：设置名字为name的request的参数值</li><li>getAttribute(String name)：返回由name指定的属性值</li><li>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例</li><li>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组</li><li>getCharacterEncoding()：返回请求中的字符编码方式</li><li>getContentLength()：返回请求的Body的长度</li><li>getInputStream()：返回请求的输入流，用于获得请求中的数据</li><li>getMethod()：获得客户端向服务器端传送数据的方法</li><li>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值</li><li>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li><li>getParameterValues(String name)：获得有name指定的参数的所有值</li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li><li>getQueryString()：获得查询字符串</li><li>getRequestURI()：获取发出请求字符串的客户端地址</li><li>getRemoteAddr()：获取客户端的IP地址</li><li>getRemoteHost()：获取客户端的名字</li><li>getSession([Boolean create])：返回和请求相关Session</li><li>getServerName()：获取服务器的名字</li><li>getServletPath()：获取客户端所请求的脚本文件的路径</li><li>getServerPort()：获取服务器的端口号</li><li>removeAttribute(String name)：删除请求中的一个属性</li></ul><h1 id="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"><a href="#我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"></a>我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Public String translate (String str) &#123;</span><br><span class="line">  String tempStr = &quot;&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">    tempStr = new String(str.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);</span><br><span class="line">    tempStr = tempStr.trim();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Exception e) &#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  return tempStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Servlet执行时一般实现哪几个方法"><a href="#Servlet执行时一般实现哪几个方法" class="headerlink" title="Servlet执行时一般实现哪几个方法?"></a>Servlet执行时一般实现哪几个方法?</h1><ul><li>public void init(ServletConfig config)</li><li>public ServletConfig getServletConfig()</li><li>public String getServletInfo()</li><li>public void service(ServletRequest request,ServletResponse response)</li><li>public void destroy()</li></ul><h1 id="jsp有哪些内置对象-作用分别是什么："><a href="#jsp有哪些内置对象-作用分别是什么：" class="headerlink" title="jsp有哪些内置对象?作用分别是什么："></a>jsp有哪些内置对象?作用分别是什么：</h1><ul><li>JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：<ul><li>request 用户端请求，此请求会包含来自GET&#x2F;POST请求的参数</li><li>response 网页传回用户端的回应</li><li>pageContext 网页的属性是在这里管理</li><li>session 与请求有关的会话期</li><li>application servlet 正在执行的内容</li><li>out 用来传送回应的输出</li><li>config servlet的构架部件</li><li>page JSP网页本身</li><li>exception 针对错误网页，未捕捉的例外。</li></ul></li></ul><h1 id="jsp有哪些动作-作用分别是什么："><a href="#jsp有哪些动作-作用分别是什么：" class="headerlink" title="jsp有哪些动作?作用分别是什么："></a>jsp有哪些动作?作用分别是什么：</h1><ul><li>JSP共有以下6种基本动作<ul><li>jsp:include：在页面被请求的时候引入一个文件。</li><li>jsp:useBean：寻找或者实例化一个JavaBean。</li><li>jsp:setProperty：设置JavaBean的属性。</li><li>jsp:getProperty：输出某个JavaBean的属性。</li><li>jsp:forward：把请求转到一个新的页面。</li><li>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。</li></ul></li></ul><h1 id="说一说Servlet的生命周期："><a href="#说一说Servlet的生命周期：" class="headerlink" title="说一说Servlet的生命周期："></a>说一说Servlet的生命周期：</h1><ul><li>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束</li><li>这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。</li></ul><h1 id="JAVA-SERVLET-API中forward-与redirect-的区别："><a href="#JAVA-SERVLET-API中forward-与redirect-的区别：" class="headerlink" title="JAVA SERVLET API中forward() 与redirect()的区别："></a>JAVA SERVLET API中forward() 与redirect()的区别：</h1><ul><li>前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接，从浏览器的地址栏中可以看到跳转后的链接地址</li><li>前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。</li></ul><h1 id="MVC的各个部分都有那些技术来实现-如何实现："><a href="#MVC的各个部分都有那些技术来实现-如何实现：" class="headerlink" title="MVC的各个部分都有那些技术来实现?如何实现："></a>MVC的各个部分都有那些技术来实现?如何实现：</h1><ul><li>MVC是Model－View－Controller的简写</li><li>“Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）</li><li>“View” 是应用的表示面（由JSP页面产生）</li><li>“Controller” 是提供应用的处理过程控制（一般是一个Servlet）</li><li>通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。</li></ul><h1 id="J2EE是什么："><a href="#J2EE是什么：" class="headerlink" title="J2EE是什么："></a>J2EE是什么：</h1><ul><li>Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model)</li><li>在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中</li><li>所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。</li></ul><h1 id="STRUTS的应用-如STRUTS架构-："><a href="#STRUTS的应用-如STRUTS架构-：" class="headerlink" title="STRUTS的应用(如STRUTS架构) ："></a>STRUTS的应用(如STRUTS架构) ：</h1><ul><li>Struts是采用Java Servlet&#x2F;JavaServer Pages技术，开发Web应用程序的开放源码的framework</li><li>采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架</li><li>Struts有如下的主要功能：<ul><li>包含一个controller servlet，能将用户的请求发送到相应的Action对象。</li><li>JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。</li><li>提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。</li></ul></li></ul><h1 id="开发中都用到了那些设计模式-用在什么场合："><a href="#开发中都用到了那些设计模式-用在什么场合：" class="headerlink" title="开发中都用到了那些设计模式?用在什么场合："></a>开发中都用到了那些设计模式?用在什么场合：</h1><ul><li>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心</li><li>通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作</li><li>主要用到了MVC的设计模式</li><li>用来开发JSP&#x2F;Servlet或者J2EE的相关应用</li><li>简单工厂模式等。</li></ul><h1 id="四种会话跟踪技术："><a href="#四种会话跟踪技术：" class="headerlink" title="四种会话跟踪技术："></a>四种会话跟踪技术：</h1><ul><li>cookie,url重写,session,隐藏域。</li></ul><h1 id="J2EE是技术还是平台还是框架："><a href="#J2EE是技术还是平台还是框架：" class="headerlink" title="J2EE是技术还是平台还是框架："></a>J2EE是技术还是平台还是框架：</h1><ul><li>J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。</li><li>J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。</li></ul><h1 id="EJB的角色和三个对象："><a href="#EJB的角色和三个对象：" class="headerlink" title="EJB的角色和三个对象："></a>EJB的角色和三个对象：</h1><ul><li>一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性</li><li>这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类</li></ul><h1 id="EJB容器提供的服务："><a href="#EJB容器提供的服务：" class="headerlink" title="EJB容器提供的服务："></a>EJB容器提供的服务：</h1><ul><li>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</li></ul><h1 id="EJB规范规定EJB中禁止的操作有哪些："><a href="#EJB规范规定EJB中禁止的操作有哪些：" class="headerlink" title="EJB规范规定EJB中禁止的操作有哪些："></a>EJB规范规定EJB中禁止的操作有哪些：</h1><ul><li>不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，</li><li>不能操作awt，</li><li>不能实现服务器功能，</li><li>不能对静态属生存取，</li><li>不能使用IO操作直接存取文件系统，</li><li>不能加载本地库.，</li><li>不能将this作为变量和返回，</li><li>不能循环调用。</li></ul><h1 id="说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法："><a href="#说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法：" class="headerlink" title="说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法："></a>说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法：</h1><ul><li>Session Facade Pattern：使用SessionBean访问EntityBean；</li><li>Message Facade Pattern：实现异步调用</li><li>EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问；</li><li>Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性；</li><li>Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性；</li><li>Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性；</li><li>ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率</li><li>项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。</li></ul><h1 id="UML方面："><a href="#UML方面：" class="headerlink" title="UML方面："></a>UML方面：</h1><ul><li>标准建模语言UML</li><li>用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。</li></ul><h1 id="说出一些常用的类，包，接口，请各举5个常用的类："><a href="#说出一些常用的类，包，接口，请各举5个常用的类：" class="headerlink" title="说出一些常用的类，包，接口，请各举5个常用的类："></a>说出一些常用的类，包，接口，请各举5个常用的类：</h1><ul><li>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer；</li><li>常用的包：java.lang java.awt java.io java.util java.sql；</li><li>常用的接口：Remote List Map Document NodeList</li></ul><h1 id="应用服务器与WEB-SERVER的区别："><a href="#应用服务器与WEB-SERVER的区别：" class="headerlink" title="应用服务器与WEB SERVER的区别："></a>应用服务器与WEB SERVER的区别：</h1><ul><li>应用服务器：Weblogic、Tomcat、Jboss； WEB SERVER：IIS、 Apache</li></ul><h1 id="BS与CS的联系与区别："><a href="#BS与CS的联系与区别：" class="headerlink" title="BS与CS的联系与区别："></a>BS与CS的联系与区别：</h1><ul><li>C&#x2F;S是Client&#x2F;Server的缩写</li><li>服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server</li><li>客户端需要安装专用的客户端软件</li><li>B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库</li><li>在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。</li><li>浏览器通过Ｗeb Server 同数据库进行数据交互。</li></ul><h4 id="C-S-与-B-S-区别"><a href="#C-S-与-B-S-区别" class="headerlink" title="C&#x2F;S 与 B&#x2F;S 区别"></a>C&#x2F;S 与 B&#x2F;S 区别</h4><ul><li>硬件环境不同: C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C&#x2F;S更强的适应范围, 一般只要有操作系统和浏览器就行</li><li>对安全要求不同 ：C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C&#x2F;S 结构适宜. 可以通过B&#x2F;S发布部分可公开信息.B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。</li><li>对程序架构不同 ：　C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C&#x2F;S有更高的要求 B&#x2F;S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B&#x2F;S更加成熟.</li><li>软件重用不同： C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性好.　B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。</li><li>系统维护不同 ：C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.</li><li>处理问题不同 ：C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C&#x2F;S无法作到的. 与操作系统平台关系最小.</li><li>用户接口不同： C&#x2F;S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.</li><li>信息流不同 ：　C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B&#x2F;S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心</li></ul><h1 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h1><ul><li>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址</li><li>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</li></ul><h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理</h1><ul><li>Session用于保存每个用户的专用信息</li><li>每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID）</li><li>她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右)</li><li>Session中的信息保存在Web服务器内容中,保存的数据量可大可小</li><li>当 Session超时或被关闭时将自动释放保存的数据信息</li><li>由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低</li><li>对于小量的数据,使用Session对象保存还是一个不错的选择</li><li>Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置</li><li>如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止</li><li>如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期</li><li>Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据</li><li>由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性</li><li>session工作原理<ul><li>当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。</li><li>然后，服务器开辟一块内存，对应于该Session ID。</li><li>服务器再将该Session ID写入浏览器的cookie。</li><li>服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。</li><li>当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。</li><li>然后，服务检查该Session ID所对应的内存是否有效。</li><li>如果有效，就读出内存中的值。</li><li>如果无效，就建立新的Session。</li></ul></li></ul><h1 id="Servlet的生命周期分为3个阶段-和CGI的区别？"><a href="#Servlet的生命周期分为3个阶段-和CGI的区别？" class="headerlink" title="Servlet的生命周期分为3个阶段:?  和CGI的区别？"></a>Servlet的生命周期分为3个阶段:? 和CGI的区别？</h1><ul><li>Servlet的生命周期主要由3个过程组成。<ul><li>init()方法：服务器初始化servlet。</li><li>service()方法：初始化完毕，servlet对象调用该方法响应客户的请求。</li><li>destroy()方法：调用该方法消灭servlet对象。</li></ul></li><li>其中，init()方法只在servlet第一次被请求加载的时候被调用一次，当有客户再请求servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。</li><li>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li></ul><h1 id="浏览器页面与T0MCat的交互过程？"><a href="#浏览器页面与T0MCat的交互过程？" class="headerlink" title="浏览器页面与T0MCat的交互过程？"></a>浏览器页面与T0MCat的交互过程？</h1><ul><li>当一个JSP页面第一次被访问的时候，JSP引擎将执行以下步骤：<ul><li>将JSP页面翻译成一个Servlet，这个Servlet是一个java文件，同时也是一个完整的java程序</li><li>JSP引擎调用java编译器对这个Servlet进行编译，得到可执行文件class</li><li>JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户端</li></ul></li><li>以上三个步骤仅仅在JSP页面第一次被访问时才会执行，以后的访问速度会因为class文件已经生成而大大提高<br>当JSP引擎接到一个客户端的访问请求时，首先判断请求的JSP页面是否比对应的Servlet新，如果新，对应的JSP需要重新编译。</li></ul><h1 id="JSP内置对象作用，如何取Cookie的方法"><a href="#JSP内置对象作用，如何取Cookie的方法" class="headerlink" title="JSP内置对象作用，如何取Cookie的方法"></a>JSP内置对象作用，如何取Cookie的方法</h1><ul><li>使用request对象的getCookies()方法取cookies</li></ul><h1 id="JAVA事件有哪些模式？"><a href="#JAVA事件有哪些模式？" class="headerlink" title="JAVA事件有哪些模式？"></a>JAVA事件有哪些模式？</h1><ul><li>事件直接驱动模式。它的第一个要求就是性能的要求，需要直接而且快，是必须经常使用的，主要适合于迅速处理 前台的命令，往往是系统架构的重要部分，也是流程控制的主要模式。</li><li>监控式事件模式是借助第三者来监控和触发事件，特点是： 有一个观察者置身事外在定期独立运行着。</li></ul><h1 id="uml三要素"><a href="#uml三要素" class="headerlink" title="uml三要素."></a>uml三要素.</h1><ul><li>事物、关系、图</li></ul><h1 id="Session的具体用法？"><a href="#Session的具体用法？" class="headerlink" title="Session的具体用法？"></a>Session的具体用法？</h1><ul><li>Session用来保存每一个用户的专有信息，比如像用户登录验证、购物车。</li></ul><h1 id="请裂举session、cookie、viewstated的应用范围"><a href="#请裂举session、cookie、viewstated的应用范围" class="headerlink" title="请裂举session、cookie、viewstated的应用范围"></a>请裂举session、cookie、viewstated的应用范围</h1><ul><li>Session 服务器端维护， 某个用户活动时间 + 延迟时间（默认20分钟），</li><li>Cookie 客户端维护， 程序可指定生命周期，</li><li>ViewState 小量数据，一个web页面的生命期</li></ul><h1 id="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"><a href="#用什么方法使服务器关闭之后，session所保存的信息不会丢失？" class="headerlink" title="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"></a>用什么方法使服务器关闭之后，session所保存的信息不会丢失？</h1><ul><li>将session信息保存到数据库中或文件中</li></ul><h4 id="写客户端Cookie的方式"><a href="#写客户端Cookie的方式" class="headerlink" title="写客户端Cookie的方式"></a>写客户端Cookie的方式</h4><ul><li>当用户登陆成功以后，把网站域名、用户名、密码、token、session有效时间全部采用cookie的形式写入到客户端的cookie里面</li><li>如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务</li><li>当然，如果cookie过期，或者无效，自然就不让用户继续服务了</li><li>当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？</li></ul><h4 id="服务器之间Session数据同步的方式"><a href="#服务器之间Session数据同步的方式" class="headerlink" title="服务器之间Session数据同步的方式"></a>服务器之间Session数据同步的方式</h4><ul><li>假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了</li><li>缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。</li></ul><h4 id="利用NFS共享Session数据的方式"><a href="#利用NFS共享Session数据的方式" class="headerlink" title="利用NFS共享Session数据的方式"></a>利用NFS共享Session数据的方式</h4><ul><li>其实这个方案和下面的Mysql方案类似，只是存储方式不一样</li><li>大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台NFS服务器上的，不论用户访问那太Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了</li><li>缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。</li></ul><h4 id="利用Mysql数据库共享Session数据的方式"><a href="#利用Mysql数据库共享Session数据的方式" class="headerlink" title="利用Mysql数据库共享Session数据的方式"></a>利用Mysql数据库共享Session数据的方式</h4><ul><li>这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上</li><li>所有Web服务器都来这台Mysql服务器来获取Session数据</li><li>缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql数据的方式。</li></ul><h1 id="使用硬件设备"><a href="#使用硬件设备" class="headerlink" title="使用硬件设备"></a>使用硬件设备</h1><ul><li>这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了</li><li>目前很多门户网站采用这种方式</li><li>缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的。</li></ul><h1 id="过滤器有哪些作用和用法？"><a href="#过滤器有哪些作用和用法？" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h1><ul><li>对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤</li><li>当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联</li><li>如果有，那么容器将把请求交给过滤器进行处理</li><li>在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源</li><li>当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常- 见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。</li><li>和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain</li></ul><h1 id="监听器有哪些作用和用法？"><a href="#监听器有哪些作用和用法？" class="headerlink" title="监听器有哪些作用和用法？"></a>监听器有哪些作用和用法？</h1><ul><li>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：<ul><li>ServletContextListener：对Servlet上下文的创建和销毁进行监听。</li><li>ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。</li><li>HttpSessionListener：对Session的创建和销毁进行监听。补充：session的销毁有两种情况：1session超时（可以在web.xml中通过&lt;session-config&gt;&#x2F;&lt;session-timeout&gt;标签配置超时时间）；2通过调用session对象的invalidate()方法使session失效。</li><li>HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。</li><li>ServletRequestListener：对请求对象的初始化和销毁进行监听。</li><li>ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</li></ul></li></ul><h1 id="实现会话跟踪的技术有哪些？"><a href="#实现会话跟踪的技术有哪些？" class="headerlink" title="实现会话跟踪的技术有哪些？"></a>实现会话跟踪的技术有哪些？</h1><ul><li>由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。</li></ul><h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><ul><li>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</li></ul><h4 id="设置表单隐藏域"><a href="#设置表单隐藏域" class="headerlink" title="设置表单隐藏域"></a>设置表单隐藏域</h4><ul><li>将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。</li><li>这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。</li></ul><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul><li>cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间</li><li>当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份</li><li>会话中可以为用户保存信息</li><li>会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的</li><li>如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪</li><li>当然，在使用cookie时要注意几点<ul><li>首先不要在cookie中存放敏感信息</li><li>其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中</li><li>再者浏览器通常只允许一个站点最多存放20个cookie</li><li>当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。</li></ul></li></ul><h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><ul><li>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的</li><li>当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession</li><li>可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象</li><li>与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能</li><li>添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</li></ul><h1 id="JSP-和Servlet-有有什么关系？"><a href="#JSP-和Servlet-有有什么关系？" class="headerlink" title="JSP 和Servlet 有有什么关系？"></a>JSP 和Servlet 有有什么关系？</h1><ul><li>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容</li><li>JSP本质上是Servlet的一种简易形式， JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成</li><li>Servlet和JSP最主要的不同点在于，Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML分离开来</li><li>而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp 的文件（有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然，这个说法还是很片面的）</li><li>JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</li></ul><h1 id="常用的Web容器"><a href="#常用的Web容器" class="headerlink" title="常用的Web容器"></a>常用的Web容器</h1><ul><li>Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器</li><li>选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等</li><li>下面是对常用服务器的简介：<ul><li>IIS：Microsoft的Web服务器产品为Internet Information Services。IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。</li><li>Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。</li><li>WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要，范围从简单到高级直到企业级。</li><li>WebLogic：BEA WebLogic Server是一种多功能、基于标准的Web应用服务器，为企业构建自己的应用提供了坚实的基础。各种应用开发、部署所有关键性的任务，无论是集成各种系统和数据库，还是提交服务、跨Internet协作，Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发，基于Internet的企业都选择它来开发、部署最佳的应用。BEA WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础，它们以 Internet的容量和速度，在连网的企业之间共享信息、提交服务，实现协作自动化。</li><li>Apache：目前Apache仍然是世界上用得最多的Web服务器，市场占有率约为60%左右。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。</li><li>Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。TomcatServer实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。</li><li>Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</li></ul></li></ul><h1 id="MVC原理"><a href="#MVC原理" class="headerlink" title="MVC原理"></a>MVC原理</h1><ul><li>MVC是一种程序开发设计模式,它实现了显示模块与功能模块的分离</li><li>提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、控制器三层。<ul><li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li><li>视图(view) 用户与之交互的界面、在web中视图一般由jsp,html组成</li><li>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用</li></ul></li></ul><h4 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h4><ul><li>降低代码耦合性。在MVC模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。</li><li>有利于分工合作。在MVC模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。</li><li>有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。</li></ul><h4 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h4><ul><li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li><li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li><li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li><li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难。</li></ul><h1 id="JSP的执行过程"><a href="#JSP的执行过程" class="headerlink" title="JSP的执行过程"></a>JSP的执行过程</h1><ul><li>在JSP运行过程中，首先由客户端发出请求，Web服务器接收到请求后，如果是第一次访问某个jsp页面，Web服务器对它进行以下3个操作。<ul><li>翻译：由.jsp变为.java,由JSP引擎实现。</li><li>编译：由.java变为.class,由 Java编译器实现。</li><li>执行：由.class变为.html,用Java虚拟机执行编译文件,然后将执行结果返回给Web服务器，并最终返回给客户端</li></ul></li><li>如果不是第一次访问某个JSP页面，则只执行第三步。所以第一次访问JSP较慢。</li></ul><h1 id="CGI-Servlet-JSP的比较"><a href="#CGI-Servlet-JSP的比较" class="headerlink" title="CGI&#x2F;Servlet&#x2F;JSP的比较"></a>CGI&#x2F;Servlet&#x2F;JSP的比较</h1><ul><li>CGI(Common Gateway Interface)，通用网关接口,是一种根据请求信息动态产生回应内容的技术。通过CGI，Web 服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于每个请求，都要产生一个新的进程进行处理。</li><li>Servlet 是在服务器上运行的小程序。在实际运行的时候Java Servlet与Web服务器会融为一体。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。</li><li>JSP从本质上说就是Servlet。JSP技术产生于Servlet之后，两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。</li><li>与CGI相比，Servlet效率更高。Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet 。</li><li>与CGI相比，Servlet更容易使用，功能更强大，具有更好的可移植性，更节省投资。在未来的技术发展过程中，Servlet有可能彻底取代CGI。</li></ul><h1 id="JSP-ASP-PHP的比较"><a href="#JSP-ASP-PHP的比较" class="headerlink" title="JSP&#x2F;ASP&#x2F;PHP的比较"></a>JSP&#x2F;ASP&#x2F;PHP的比较</h1><ul><li>ASP(Active Server Pages),JSP(JavaServer Pages),PHP(Hypertext Preprocessor)是目前主流的三种动态网页语言。</li><li>ASP是微软（Microsoft）所开发的一种后台脚本语言，它的语法和Visual BASIC类似，可以像SSI（Server Side Include）那样把后台脚本代码内嵌到HTML页面中。虽然ASP简单易用，但是它自身存在着许多缺陷，最重要的就是安全性问题。</li><li>PHP是一种跨平台的服务器端的嵌入式脚本语言。它大量地借用C,Java和Perl语言的语法, 并耦合PHP自己的特性,使WEB开发者能够快速地写出动态产生页面。它支持目前绝大多数数据库。</li><li>JSP是一个简化的Servlet，它是由Sun公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML中插入Java程序段和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。</li><li>ASP优点:无需编译、易于生成、独立于浏览器、面向对象、与任何ActiveX scripting 语言兼容、源程序码不会外漏。</li><li>ASP缺点:<ul><li>Windows本身的所有问题都会一成不变的也累加到了它的身上。安全性、稳定性、跨平台性都会因为与NT的捆绑而显现出来。</li><li>ASP由于使用了COM组件所以它会变的十分强大，但是这样的强大由于Windows NT系统最初的设计问题而会引发大量的安全问题。只要在这样的组件或是操作中一不注意，那么外部攻击就可以取得相当高的权限而导致网站瘫痪或者数据丢失。</li><li>还无法完全实现一些企业级的功能：完全的集群、负载均横。</li></ul></li><li>PHP优点：<ul><li>一种能快速学习、跨平台、有良好数据库交互能力的开发语言。</li><li>简单轻便，易学易用。</li><li>与Apache及其它扩展库结合紧密。</li></ul></li><li>PHP缺点：<ul><li>数据库支持的极大变化。</li><li>不适合应用于大型电子商务站点。</li></ul></li><li>JSP优点：<ul><li>一处编写随处运行。</li><li>系统的多台平支持。</li><li>强大的的可伸缩性。</li><li>多样化和功能强大的开发工具支持。</li></ul></li><li>JSP缺点：<ul><li>与ASP一样，Java的一些优势正是它致命的问题所在。</li><li>开发速度慢</li></ul></li></ul><h1 id="http的响应码"><a href="#http的响应码" class="headerlink" title="http的响应码"></a>http的响应码</h1><ul><li>200 - 确定。客户端请求已成功</li><li>302 - 临时移动转移，请求的内容已临时移动新的位置</li><li>404 - 未找到文件或目录</li><li>500 - 服务器内部错误</li></ul><h1 id="Session域和request域什么区别？"><a href="#Session域和request域什么区别？" class="headerlink" title="Session域和request域什么区别？"></a>Session域和request域什么区别？</h1><ul><li>作用域：存放数据，获取数据（传递数据）</li><li>有效的作用域：生命周期，作用范围</li><li>http<ul><li>生命周期 ：一次请求之间</li><li>作用范围：所有被请求转发过的servlet都能获取到httpSession:</li></ul></li><li>Servelt<ul><li>生命周期：一次会话</li><li>作用范围：所有的servlet都可以获取到servletContex:</li></ul></li><li>Request:<ul><li>生命周期：从项目开始运行到服务器关闭</li><li>作用范围：所有的servlet都可以获取到</li></ul></li><li>作用域如何选用？<ul><li>httpServeltRequest：和当前请求有关的信息</li><li>httpSession：和当前用户有关的信息</li><li>servletContex：访问量比较大，不易更改</li></ul></li></ul><h1 id="如何给weblogic定内存的大小？"><a href="#如何给weblogic定内存的大小？" class="headerlink" title="如何给weblogic定内存的大小？"></a>如何给weblogic定内存的大小？</h1><ul><li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/32257fddc744.html" class="post-title-link" itemprop="url">数据库</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:19:45" itemprop="dateCreated datePublished" datetime="2023-12-20T15:19:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-28 14:04:43" itemprop="dateModified" datetime="2023-12-28T14:04:43+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul><li>区别：<ul><li>InnoDB支持事务，MyISAM不支持</li><li>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</li><li>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ul></li><li>如何选择：<ul><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ul></li></ul><h4 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h4><ul><li>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）</li><li>如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</li></ul><h4 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h4><ul><li>插入缓冲（insert buffer）</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h1 id="⾏锁，表锁，乐观锁，悲观锁？"><a href="#⾏锁，表锁，乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁，乐观锁，悲观锁？"></a>⾏锁，表锁，乐观锁，悲观锁？</h1><ul><li>⾏锁：数据库表中某一⾏被锁住。</li><li>表锁：整个数据库表被锁住。</li><li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不不会修改，具体实现是给表增加⼀个版本号的字段，在执行update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。</li><li>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。读数据的时候会上锁，直到update完成才释放锁，使⽤悲观锁要注意不要锁住整个表。</li></ul><h1 id="数据库隔离级别是什什么？有什么作用？"><a href="#数据库隔离级别是什什么？有什么作用？" class="headerlink" title="数据库隔离级别是什什么？有什么作用？"></a>数据库隔离级别是什什么？有什么作用？</h1><ul><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。 这种隔离级别会产⽣生脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外⼀个事务不能读取该 事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了了保证一个事务不能读取另⼀个事务未提交的数据外，还保证了了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理理为顺序执行。除了防止脏读， 不可重复读外，还避免了幻读。</li></ul><h1 id="MySQL主备同步的基本原理理。"><a href="#MySQL主备同步的基本原理理。" class="headerlink" title="MySQL主备同步的基本原理理。"></a>MySQL主备同步的基本原理理。</h1><ul><li>mysql主备复制实现分成三个步骤：<ul><li>master将改变记录到⼆进制⽇志(binary log) 中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</li><li>slave将master的binary log events拷⻉到它的中继日志(relay log) ；</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ul></li></ul><h1 id="select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？"><a href="#select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</h1><ul><li>sql语句句执⾏行行顺序如下：</li><li>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</li></ul><h1 id="如何优化数据库性能"><a href="#如何优化数据库性能" class="headerlink" title="如何优化数据库性能"></a>如何优化数据库性能</h1><ul><li>索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署</li><li>选择合适的数据库引擎，合理使用索引</li><li>分页获取数据，只获取需要的字段</li><li>优化业务逻辑，减少数据库IO</li><li>分库分表</li><li>部署主从数据库</li><li>升级硬件</li></ul><h1 id="SQL什么情况下不会使用索引"><a href="#SQL什么情况下不会使用索引" class="headerlink" title="SQL什么情况下不会使用索引"></a>SQL什么情况下不会使用索引</h1><ul><li>不包含，不等于，函数</li><li>select * 可能导致不走索引；</li><li>空值会导致不走索引，因为hashset不能存空值；</li><li>索引列有函数运算，不走索引，可以在索引列列建⽴立⼀一个函数的索引。</li><li>隐式转换可能导致不走索引；</li><li>表的数据库小或者需要选择大部分数据，不走索引；</li><li>!&#x3D;或者&lt;&gt;可能导致不走索引；</li><li>字符型的索引列列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式</li><li>like ‘%liu’ 百分号在前不走索引；</li><li>not in, not exist不走索引；</li></ul><h1 id="一般在什什么字段上建索引"><a href="#一般在什什么字段上建索引" class="headerlink" title="一般在什什么字段上建索引"></a>一般在什什么字段上建索引</h1><ul><li>过滤数据最多的字段</li><li>表的主键、外键必须有索引；</li><li>数据量量超过300的表应该有索引；</li><li>经常与其他表进行行连接的表，在连接字段上应该建立索引；</li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>如何从一张表中查出name字段不包含”XYZ”的所有行？</li></ul><h1 id="如何解决高并发减库存问题"><a href="#如何解决高并发减库存问题" class="headerlink" title="如何解决高并发减库存问题"></a>如何解决高并发减库存问题</h1><ul><li>消息队列，异步处理，减库存加锁</li></ul><h1 id="数据库事务的几种粒度；"><a href="#数据库事务的几种粒度；" class="headerlink" title="数据库事务的几种粒度；"></a>数据库事务的几种粒度；</h1><ul><li>表锁定：对整个表的锁定。</li><li>行锁定：只锁定进⾏行更改的行，例如：insert，update，delete，都隐式采用行锁定。</li><li>数据库锁机制可分为多种粒度的： 数据库，表，页面，行</li><li>粒度越大，DBMS管理越容易，但是实现并发处理的能力就越差，表，页面，行</li></ul><h1 id="mysql调优"><a href="#mysql调优" class="headerlink" title="mysql调优"></a>mysql调优</h1><ul><li>explain select语句；</li><li>当只要一条数据时使用limit 1；</li><li>为搜索字段建索引；</li><li>避免select *；</li><li>字段尽量使用not null；</li><li>垂直分割；</li><li>拆分大的delete和insert语句：delete和insert会锁表；</li><li>分表分库分区</li></ul><h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><ul><li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li><li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><ul><li>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页</li><li>然后redo log按照时间或者空间等条件进行落盘</li><li>undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了</li><li>此时，事务还未 COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤用undo log进⾏事务回滚</li><li>事务执行COMMIT操作时，会将本事务相关的所有redo log都进⾏落盘，只有所有redo log落盘成功，才算COMMIT成功</li><li>然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发⽣了崩溃，则只使⽤用redo log恢复数据。</li></ul><h1 id="让你设计一个索引，你会怎么设计？"><a href="#让你设计一个索引，你会怎么设计？" class="headerlink" title="让你设计一个索引，你会怎么设计？"></a>让你设计一个索引，你会怎么设计？</h1><ul><li>mysql默认存储引擎innodb只显式支持B树索引</li><li>对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</li></ul><h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><ul><li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。<ul><li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li><li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li></ul></li><li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放<ul><li>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</li></ul></li><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置<ul><li>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销</li><li>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li></ul></li></ul><h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ul><h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul><li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li><li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li></ul><h4 id="哈希索引的优势"><a href="#哈希索引的优势" class="headerlink" title="哈希索引的优势"></a>哈希索引的优势</h4><ul><li>等值查询，哈希索引具有绝对优势</li><li>前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题</li></ul><h4 id="哈希索引不适用的场景"><a href="#哈希索引不适用的场景" class="headerlink" title="哈希索引不适用的场景"></a>哈希索引不适用的场景</h4><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li><li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<ul><li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主</li><li>没有范围查询、没有排序的时候，特别适合采用哈希索引</li><li>仅等值查询<ul><li>select id, name from table where name&#x3D;’李明’;</li></ul></li></ul></li><li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li><li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li><li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li><li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li><li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read&#x2F;write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li></ul><h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li></ul><h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><h4 id="B-的磁盘读写代价更低。"><a href="#B-的磁盘读写代价更低。" class="headerlink" title="B+的磁盘读写代价更低。"></a>B+的磁盘读写代价更低。</h4><ul><li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li><li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多</li><li>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li></ul><h4 id="B-tree的查询效率更加稳定。"><a href="#B-tree的查询效率更加稳定。" class="headerlink" title="B+-tree的查询效率更加稳定。"></a>B+-tree的查询效率更加稳定。</h4><ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引</li><li>所以任何关键字的查找必须走一条从根结点到叶子结点的路</li><li>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><ul><li>联合索引是两个或更多个列上的索引</li><li>对于联合索引Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li><li>例如索引是key index (a,b,c).<ul><li>可以支持a 、 a,b 、 a,b,c 3种组合进行查找</li><li>但不支持 b,c进行查找</li><li>当最左侧字段是常量引用时，索引就十分有效。</li></ul></li><li>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</li><li>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。</li><li>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</li></ul><h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul><li>表记录太少</li><li>经常插入、删除、修改的表</li><li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul><li>表分区是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分</li><li>从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li></ul><h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul><li>分表：指的是通过一定规则，将一张表分解成多张不同的表</li><li>比如将用户订单记录根据时间成多个表。</li><li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li></ul><h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><h4 id="存储更多数据"><a href="#存储更多数据" class="headerlink" title="存储更多数据"></a>存储更多数据</h4><ul><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li><li>和单个磁盘或者文件系统相比，可以存储更多数据</li></ul><h4 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h4><ul><li>在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率</li><li>涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li></ul><h4 id="分区表更容易维护"><a href="#分区表更容易维护" class="headerlink" title="分区表更容易维护"></a>分区表更容易维护</h4><ul><li>例如：想批量删除大量数据可以清除整个分区。</li></ul><h4 id="避免某些特殊的瓶颈"><a href="#避免某些特殊的瓶颈" class="headerlink" title="避免某些特殊的瓶颈"></a>避免某些特殊的瓶颈</h4><ul><li>例如InnoDB的单个索引的互斥访问，ext3文件系统的inode锁竞争等。</li></ul><h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式</li><li>在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><ul><li>命令：show variables like ‘%partition%’ 运行结果:</li><li>mysql&gt; show variables like ‘%partition%’;</li><li>have_partintioning 的值为YES，表示支持分区。</li></ul><h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><ul><li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><ul><li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control)</li><li>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</li><li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</li><li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制</li><li>MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议</li><li>纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li><li>在MVCC并发控制中，读操作可以分成两类：<ul><li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li><li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li></ul></li></ul><h1 id="行级锁定的优缺点"><a href="#行级锁定的优缺点" class="headerlink" title="行级锁定的优缺点"></a>行级锁定的优缺点</h1><h4 id="行级锁定的优点"><a href="#行级锁定的优点" class="headerlink" title="行级锁定的优点"></a>行级锁定的优点</h4><ul><li>当在许多线程中访问不同的行时只存在少量锁定冲突</li><li>回滚时只有少量的更改</li><li>可以长时间锁定单一的行</li></ul><h4 id="行级锁定的缺点"><a href="#行级锁定的缺点" class="headerlink" title="行级锁定的缺点"></a>行级锁定的缺点</h4><ul><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul><li>key 是数据库的物理结构，它包含两层意义和作用<ul><li>一是约束（偏重于约束和规范数据库的结构完整性）</li><li>二是索引（辅助查询用的），包括primary key, unique key, foreign key 等</li></ul></li><li>index是数据库的物理结构<ul><li>它只是辅助查询的</li><li>它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储</li><li>索引要分类的话，分为前缀索引、全文本索引等；</li></ul></li></ul><h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><h4 id="字段名及字段配制合理性"><a href="#字段名及字段配制合理性" class="headerlink" title="字段名及字段配制合理性"></a>字段名及字段配制合理性</h4><ul><li>剔除关系不密切的字段；</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul><h4 id="系统特殊字段处理及建成后建议"><a href="#系统特殊字段处理及建成后建议" class="headerlink" title="系统特殊字段处理及建成后建议"></a>系统特殊字段处理及建成后建议</h4><ul><li>添加删除标记（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul><h4 id="表结构合理性配置"><a href="#表结构合理性配置" class="headerlink" title="表结构合理性配置"></a>表结构合理性配置</h4><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><h4 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h4><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul><h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><h4 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF"></a>第一范式（1NF</h4><ul><li>字段具有原子性,不可再分</li><li>所有关系型数据库系统都满足第一范式</li><li>数据库表中的字段都是单一属性的，不可再分</li></ul><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><ul><li>是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）</li><li>要求数据库表中的每个实例或行必须可以被惟一地区分</li><li>通常需要为表加上一个列，以存储各个实例的惟一标识</li><li>这个惟一属性列被称为主关键字或主键。</li></ul><h4 id="满足第三范式（3NF）"><a href="#满足第三范式（3NF）" class="headerlink" title="满足第三范式（3NF）"></a>满足第三范式（3NF）</h4><ul><li>必须先满足第二范式（2NF）</li><li>简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</li><li>所以第三范式具有如下特征<ul><li>每一列只有一个值</li><li>每一行都能区分</li><li>每一个表都不包含其他表已经包含的非主关键字信息。</li></ul></li></ul><h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><ul><li>用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</li><li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</li><li>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等</li><li>UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL</li><li>UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同<ul><li>对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录</li><li>对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</li></ul></li></ul><h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><ul><li>普通索引: 即针对数据库表创建索引</li><li>唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值</li><li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li><li>组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li></ul><h1 id="在mysql数据库中索引的工作机制是什么？"><a href="#在mysql数据库中索引的工作机制是什么？" class="headerlink" title="在mysql数据库中索引的工作机制是什么？"></a>在mysql数据库中索引的工作机制是什么？</h1><ul><li>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据</li><li>索引的实现通常使用B树及其变种B+树</li></ul><h1 id="MySQL的基础操作命令"><a href="#MySQL的基础操作命令" class="headerlink" title="MySQL的基础操作命令"></a>MySQL的基础操作命令</h1><ul><li>MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status</li><li>开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务</li><li>Shell 登入 MySQL: 运行命令 mysql -u root -p</li><li>列出所有数据库:运行命令 show databases;</li><li>切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库</li><li>列出某个数据库内所有表: show tables;</li><li>获取表内所有 Field 对象的名称和类型 :describe table_name;</li></ul><h1 id="mysql的复制原理以及流程"><a href="#mysql的复制原理以及流程" class="headerlink" title="mysql的复制原理以及流程"></a>mysql的复制原理以及流程</h1><ul><li>Mysql内建的复制功能是构建大型，高性能应用程序的基础</li><li>将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的</li><li>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器</li><li>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环</li><li>这些日志可以记录发送到从服务器的更新</li><li>当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置</li><li>从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新</li><li>过程如下<ul><li>主服务器把更新记录到二进制日志文件中</li><li>从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中</li><li>从服务器重做中继日志中的时间，把更新应用到自己的数据库上</li></ul></li></ul><h1 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型?"></a>mysql支持的复制类型?</h1><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><ul><li>在主服务器上执行的SQL语句，在从服务器上执行同样的语句</li><li>MySQL默认采用基于语句的复制，效率比较高</li><li>一旦发现没法精确复制时，会自动选着基于行的复制。</li></ul><h4 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h4><ul><li>把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持</li></ul><h4 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h4><ul><li>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</li></ul><h1 id="mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？"><a href="#mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？" class="headerlink" title="mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？"></a>mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</h1><ul><li>varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.</li><li>varchar(50)中50的涵义 : 最多存放50个字节</li><li>int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</li></ul><h1 id="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h1><ul><li>如果字段里面有大字段（text,blob）类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了</li><li>MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多</li><li>此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率</li><li>当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的</li><li>拆分开后，对字段的UPDAE就要UPDATE多个表了</li></ul><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</h1><ul><li>InnoDB行锁是通过给索引上的索引项加锁来实现的</li><li>这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的</li><li>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li></ul><h1 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</h1><ul><li>由于utf8的每个字符最多占用3个字节</li><li>而MySQL定义行的长度不能超过65535</li><li>因此N的最大值计算方法为：(65535-1-2)&#x2F;3</li><li>减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</li></ul><h1 id="SELECT-和SELECT-全部字段的2种写法有何优缺点"><a href="#SELECT-和SELECT-全部字段的2种写法有何优缺点" class="headerlink" title="SELECT * 和SELECT 全部字段的2种写法有何优缺点?"></a>SELECT * 和SELECT 全部字段的2种写法有何优缺点?</h1><ul><li>前者要解析数据字典，后者不需要</li><li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li><li>表字段改名，前者不需要修改，后者需要改</li><li>后者可以建立索引进行优化，前者无法优化</li><li>后者的可读性比前者要高</li></ul><h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><ul><li>语法上：where 用表中列名，having用select结果别名</li><li>影响结果范围：where从表读出数据的行数，having返回客户端的行数</li><li>索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作</li><li>where后面不能使用聚集函数，having是专门使用聚集函数的。</li></ul><h1 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h1><ul><li>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c&#x3D;c+1;</li></ul><h1 id="MySQL的insert和update的select语句语法"><a href="#MySQL的insert和update的select语句语法" class="headerlink" title="MySQL的insert和update的select语句语法"></a>MySQL的insert和update的select语句语法</h1><ul><li>insert into student (stuid,stuname,deptid) select 10,’xzm’,3 from student where stuid &gt; 8;</li><li>update student a inner join student b on b.stuID&#x3D;10 set a.stuname&#x3D;concat(b.stuname, b.stuID) where a.stuID&#x3D;10 ;</li></ul><h1 id="Mysql-中有哪几种锁？"><a href="#Mysql-中有哪几种锁？" class="headerlink" title="Mysql 中有哪几种锁？"></a>Mysql 中有哪几种锁？</h1><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低， 并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和 行锁之间，并发度一般。</li></ul><h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><ul><li>共有 5 种类型的表格：<ul><li>MyISAM</li><li>Heap</li><li>Merge</li><li>INNODB</li><li>ISAM</li></ul></li></ul><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul><li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li><li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li></ul><h1 id="myisamchk-是用来做什么的？"><a href="#myisamchk-是用来做什么的？" class="headerlink" title="myisamchk 是用来做什么的？"></a>myisamchk 是用来做什么的？</h1><ul><li>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。</li></ul><h1 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h1><ul><li>在 MyISAM Static 上的所有字段有固定宽度</li><li>动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。</li><li>MyISAM Static 在受损情况下更容易恢复。</li></ul><h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><ul><li>每当行被更改时，时间戳字段将获取当前时间戳。</li></ul><h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><ul><li>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</li></ul><h1 id="数据库架构原则"><a href="#数据库架构原则" class="headerlink" title="数据库架构原则"></a>数据库架构原则</h1><ul><li>高可用</li><li>高性能</li><li>一致性</li><li>扩展性</li></ul><h1 id="常见的数据库架构方案"><a href="#常见的数据库架构方案" class="headerlink" title="常见的数据库架构方案"></a>常见的数据库架构方案</h1><h4 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h4><ul><li>只有主库提供读写服务，备库冗余作故障转移用</li><li>高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写都操作主库，很容易产生瓶颈</li><li>大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能</li><li>另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 </li><li>一致性分析：读写都操作主库，不存在数据一致性问题。 </li><li>扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案</li><li>第二，扩展性差，这点可以通过分库分表来扩展。</li></ul></li></ul><h4 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h4><ul><li>两个主库同时提供服务，负载均衡</li><li>高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写性能相比于方案一都得到提升，提升一倍。</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）</li><li>如果非得在数据库架构层面扩展的话，扩展为方案四。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。</li></ul></li></ul><h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><ul><li>一主多从，读写分离</li><li>高可用分析：主库单点，从库高可用</li><li>一旦主库挂了，写服务也就无法提供。 </li><li>高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能</li><li>读的性能提高了，整体性能也提高了。</li><li>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引</li><li>线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。</li><li>带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长）</li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主库单点问题，笔者暂时没想到很好的解决方案。</li></ul></li><li>思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？</li></ul><h4 id="双主-主从架构"><a href="#双主-主从架构" class="headerlink" title="双主+主从架构"></a>双主+主从架构</h4><ul><li>看似完美的方案</li><li>高可用分析：高可用。 </li><li>高性能分析：高性能。 </li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案 。</li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） </li><li>可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。</li></ul><h1 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h1><h4 id="主库和从库一致性解决方案"><a href="#主库和从库一致性解决方案" class="headerlink" title="主库和从库一致性解决方案"></a>主库和从库一致性解决方案</h4><ul><li>数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的</li><li>这个同步时间内主库和从库的数据会存在不一致的情况</li><li>如果同步过程中有读请求，那么读到的就是从库中的老数据。</li><li>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<ul><li>直接忽略，如果业务允许延时存在，那么就不去管它。 </li><li>强制读主，采用主备架构方案，读写都走主库</li><li>用缓存来扩展数据库读性能</li><li>有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</li></ul></li><li>选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。</li><li>读请求时，同样的方式生成key先去查Cache，再判断是否命中</li><li>若命中，则读主库，否则读从库</li><li>代价是多了一次缓存读写，基本可以忽略。</li><li>半同步复制，等主从同步完成，写请求才返回</li><li>就是大家常说的“半同步复制”semi-sync</li><li>这可以利用数据库原生功能，实现比较简单</li><li>代价是写请求时延增长，吞吐量降低。 </li><li>数据库中间件，引入开源（mycat等）或自研的数据库中间层</li><li>个人理解，思路同选择读主</li><li>数据库中间件的成本比较高，并且还多引入了一层</li></ul><h4 id="DB和缓存一致性解决方案"><a href="#DB和缓存一致性解决方案" class="headerlink" title="DB和缓存一致性解决方案"></a>DB和缓存一致性解决方案</h4><ul><li>先来看一下常用的缓存使用方式：<ul><li>第一步：淘汰缓存；</li><li>第二步：写入数据库；</li><li>第三步：读取缓存？返回：读取数据库；</li><li>第四步：读取数据库后写入缓存。</li></ul></li><li>注：如果按照这种方式，不会产生DB和缓存不一致问题，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据</li><li>设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！</li><li>加缓存和索引是通用的提升数据库性能的方式； </li><li>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。</li><li>阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。</li></ul><p> </p><h1 id="主从数据库不一致如何解决"><a href="#主从数据库不一致如何解决" class="headerlink" title="主从数据库不一致如何解决"></a>主从数据库不一致如何解决</h1><ul><li>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</li><li>忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</li><li>强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</li><li>选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</li></ul><h1 id="说出数据连接池的工作机制是什么"><a href="#说出数据连接池的工作机制是什么" class="headerlink" title="说出数据连接池的工作机制是什么?"></a>说出数据连接池的工作机制是什么?</h1><ul><li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接</li><li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙</li><li>如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定</li><li>当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</li></ul><h1 id="数据库创建索引的缺点？"><a href="#数据库创建索引的缺点？" class="headerlink" title="数据库创建索引的缺点？"></a>数据库创建索引的缺点？</h1><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h1 id="说一下数据库的存储过程？"><a href="#说一下数据库的存储过程？" class="headerlink" title="说一下数据库的存储过程？"></a>说一下数据库的存储过程？</h1><ul><li>存储过程与函数的区别：<ul><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。</li><li>对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。</li><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。</li></ul></li><li>存储过程的优点：<ul><li>执行速度更快 – 在数据库中保存的存储过程语句都是编译过的</li><li>允许模块化程序设计 – 类似方法的复用</li><li>提高系统安全性 – 防止SQL注入</li><li>减少网络流通量 – 只要传输存储过程的名称</li></ul></li><li>系统存储过程一般以sp开头，用户自定义的存储过程一般以usp开头</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><a class="page-number" href="/default-index/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/4/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.6m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">23:50</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>