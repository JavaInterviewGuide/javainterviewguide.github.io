<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java后端面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/3/index.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/3/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java后端面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">44</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/98f0d77a0556.html" class="post-title-link" itemprop="url">数据结构与算法</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:35:25 / 修改时间：15:39:01" itemprop="dateCreated datePublished" datetime="2023-12-20T15:35:25+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><ol><li>说⼀下⼏种常⻅的排序算法和分别的复杂度<br>a. 快速排序：<br>i. 原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字<br>都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了.</li><li>选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。</li><li>基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的分在右边。</li><li>可以肯定，如此⼀轮下来，这个枢轴的位置⼀定在最终位置上。</li><li>对两个⼦数组分别重复上述过程，直到每个数组只有⼀个元素。</li><li>排序完成。<br>ii. 复杂度：O(n)<br>iii. 特点：快速排序是我们平常最常使⽤的⼀种排序算法,因为它速度快,效率⾼,是最优秀的⼀种排序算法.<br>b. 冒泡排序：<br>i. 原理：冒泡排序其实就是逐⼀⽐较交换,进⾏⾥外两次循环,外层循环为遍历所有数字,逐个确定每个位置,⾥层循环<br>为确定了位置后,遍历所有后⾯没有确定位置的数字,与该位置的数字进⾏⽐较,只要⽐该位置的数字⼩,就和该位置的<br>数字进⾏交换.<br>ii. 复杂度：O(n^2)，最佳时间复杂度为O(n)<br>iii. 特点：冒泡排序在我们实际开发中,使⽤的还是⽐较少的.它更加适合数据规模⽐较少的时候,因为它的效率是⽐较<br>低的,但是优点是逻辑简单,容易让我们记得.<br>c. 直接插⼊排序：<br>i. 原理：直接插⼊排序是将从第⼆个数字开始,逐个拿出来,插⼊到之前排好序的数列⾥.<br>ii. 复杂度：O(n^2)，最佳时间复杂度为O(n)<br>iii. 特点：<br>d. 直接选择排序：<br>i. 原理：直接选择排序是从第⼀个位置开始遍历位置,找到剩余未排序的数据⾥最⼩的,找到最⼩的后,再做交换<br>ii. 复杂度：O(n^2)<br>iii. 特点：和冒泡排序⼀样,逻辑简单,但是效率不⾼,适合少量的数据排序</li><li>⽤java写⼀个冒泡排序算法<br>1 public class Test {<br>2 public static void bubbleSort() {<br>3 int a[] = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 5, 4, 62, 99, 98, 54, 56, 17, 18<br>4 int temp;<br>5 for (int i = 0; i &lt; a.length - 1; i++) {<br>6 for (int j = 0; j &lt; a.length - 1 - i; j++) {<br>7 if (a[j] &gt; a[j + 1]) {<br>8 temp = a[j];<br>9 a[j] = a[j + 1];<br>10 a[j + 1] = temp;<br>11 }<br>12 }<br>13 }<br>14 for (int i = 0; i &lt; a.length; i++)<br>15 System.out.println(a[i]);<br>16 }<br>17<br>18 public static void main(String[] args) {<br>19 bubbleSort();<br>20 }<br>21 }</li><li>描述⼀下链式存储结构<br>a. 线性结构的优点是可以实现随机读取，时间复杂度为O(1)，空间利⽤率⾼，缺点是进⾏插⼊和删除操作时⽐较麻烦，<br>时间复杂度为O(n)，同时容量受限制，需要事先确定容量⼤⼩，容量过⼤，浪费空间资源，过⼩不能满⾜使⽤要求，会<br>产⽣溢出问题。<br>b. 链式存储结构的优点主要是插⼊和删除⾮常简单，前提条件是知道操作位置，时间复杂度是O(1)，但如果不知道操作<br>位置则要定位元素，时间复杂度为O(n)，没有容量的限制，可以使⽤过程中动态分配的分配内存空间，不⽤担⼼溢出问<br>题，但是它并不能实现随机读取，同时空间利⽤率不⾼。</li><li>如何遍历⼀颗⼆叉树<br>a. 树节点：<br>1 class TreeNode {<br>2 int val;<br>3 //左⼦树<br>4 TreeNode left;<br>5 //右⼦树<br>6 TreeNode right;<br>7 //构造⽅法<br>8 TreeNode(int x) {<br>9 val = x;<br>10 }<br>11 }<br>b. 递归先序遍历：先输出节点的值，再递归遍历左右⼦树。中序和后序的递归类似，改变根节点输出位置即可。<br>1 // 递归先序遍历<br>2 public static void recursionPreorderTraversal(TreeNode root) {<br>3 if (root != null) {<br>4 System.out.print(root.val + “ “);<br>5 recursionPreorderTraversal(root.left);<br>6 recursionPreorderTraversal(root.right);<br>7 }<br>8 }<br>9 //1 2 4 6 7 8 3 5<br>c. 递归中序遍历：过程和递归先序遍历类似<br>1 // 递归中序遍历<br>2 public static void recursionMiddleorderTraversal(TreeNode root) {<br>3 if (root != null) {<br>4 recursionMiddleorderTraversal(root.left);<br>5 System.out.print(root.val + “ “);<br>6 recursionMiddleorderTraversal(root.right);<br>7 }<br>8 }<br>9 //4 7 6 8 2 1 3 5<br>d. 递归后序遍历：<br>1 // 递归后序遍历<br>2 public static void recursionPostorderTraversal(TreeNode root) {<br>3 if (root != null) {<br>4 recursionPostorderTraversal(root.left);<br>5 recursionPostorderTraversal(root.right);<br>6 System.out.print(root.val + “ “);<br>7 }<br>8 }</li><li>倒排⼀个LinkedList<br>1 Collections.reverse(linkedList);</li><li>⽤java写⼀个递归遍历⽬录下⾯的所有⽂件（directory.listFiles()）<br>1 void listAll(File directory) {<br>2 if (!(directory.exists() &amp;&amp; directory.isDirectory())) {<br>3 throw new RuntimeException(“⽬录不存在”);<br>4 }<br>5<br>6 File[] files = directory.listFiles();<br>7<br>8 for (File file : files) {<br>9 System.out.println(file.getPath() + file.getName());<br>10 if (file.isDirectory()) {<br>11 listAll(file);<br>12 }<br>13 }<br>14 }</li><li>⼆叉树与红⿊树：</li><li>⼆叉树：<br>a. 特性：<br>i. 左⼦树上所有结点的值均⼩于或等于它的根结点的值。<br>ii. 右⼦树上所有结点的值均⼤于或等于它的根结点的值。<br>iii. 左、右⼦树也分别为⼆叉排序树。<br>b. 图例：<br>c. 查找：⼆分查找（通过⼀层⼀层的⽐较⼤⼩来查找位置）：如查找值为10的节点：9–13–11–10<br>d. 缺陷：插⼊容易变成线性形态，查找性能⼤打折扣，这时需要引⼊红⿊树来解决</li><li>红⿊树：<br>a. 特点：是⼀种⾃平衡的⼆叉查找树，除了符合⼆叉树的特点之外，还符合以下⼏点：<br>i. 节点是红⾊或⿊⾊。<br>ii. 根节点是⿊⾊。<br>iii. 每个叶⼦节点都是⿊⾊的空节点（NIL节点）。<br>iv. 每个红⾊节点的两个⼦节点都是⿊⾊。(从每个叶⼦到根的所有路径上不能有两个连续的红⾊节点)<br>v. 从任⼀节点到其每个叶⼦的所有路径都包含相同数⽬的⿊⾊节点。<br>这些规则保证了红⿊树的⾃平衡。<br>红⿊树从根到叶⼦的最长路径不会超过最短路径的2倍。<br>提⾼寻址效率。<br>b. 添加删除：通过⾃旋来保证平衡</li><li>b-tree、b+tree多叉树：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.html">https://www.cnblogs.com/nullzx/p/8729425.html</a></li><li>b-tree（⽂件系统）：B树也称B-树,它是⼀颗多路平衡查找树。我们描述⼀颗B树时需要指定它的阶数，阶数表示了⼀<br>个结点最多有多少个孩⼦结点，⼀般⽤字⺟m表示阶数。当m取2时，就是我们常⻅的⼆叉搜索树。<br>a. 定义：<br>1）每个结点最多有m-1个关键字。<br>2）根结点最少可以只有1个关键字。<br>3）⾮根结点⾄少有Math.ceil(m/2)-1个关键字。<br>4）每个结点中的关键字都按照从⼩到⼤的顺序排列，每个关键字的左⼦树中的所有关键字都⼩于它，⽽右⼦树<br>中的所有关键字都⼤于它。<br>5）所有叶⼦结点都位于同⼀层，或者说根结点到每个叶⼦结点的⻓度都相同。<br>b. 插⼊数据，向兄弟节点借，兄弟节点不够则向⽗节点借；</li><li>b+tree（mysql索引）：<br>a. 定义：<br>1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶⼦结点。根结点本身即可以是内部结点，也可以<br>是叶⼦结点。根结点的关键字个数最少可以只有1个。<br>2）B+树与B树最⼤的不同是内部结点不保存数据，只⽤于索引，所有数据（或者说记录）都保存在叶⼦结点<br>中。<br>3）m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个⼦树），阶数m同时限制了叶⼦<br>结点最多存储m-1个记录。<br>4）内部结点中的key都按照从⼩到⼤的顺序排列，对于内部结点中的⼀个key，左树中的所有key都⼩于它，右<br>⼦树中的key都⼤于等于它。叶⼦结点中的记录也按照key的⼤⼩排列。<br>5）每个叶⼦结点都存有相邻叶⼦结点的指针，叶⼦结点本身依关键字的⼤⼩⾃⼩⽽⼤顺序链接。</li><li>谈谈数据结构，⽐如TreeMap：<br>TreeMap实现了红⿊树的结构。</li><li>图的深度遍历和⼴度遍历<br>1、深度优先遍历：<br>深度优先遍历结果是： A B E F C D G H I<br>深度优先遍历尽可能优先往深层次进⾏搜索<br>2、⼴度优先遍历：<br>⼴度优先遍历结果是： A B C D E F G H I<br>⼴度优先遍历按层次优先搜索最近的结点，⼀层⼀层往外搜索。</li><li>介绍⼀下红⿊树、⼆叉平衡树</li><li>说说java集合，每个集合下⾯有哪些实现类，及其数据结构。<br>a. HashMap：<br>i. 概念：</li><li>在HashMap内部，采⽤了数组+链表的形式来组织键值对Entry&lt;Key,Value&gt;（利⽤数组的查询快+链表的插⼊<br>删除快）</li><li>HashMap在存储键值对Entry&lt;Key,Value&gt;的时候，会根据Key的hashcode值，以某种映射关系，决定应当将<br>这对键值对Entry&lt;Key,Value&gt;存储在HashMap中的什么位置上</li><li>在JDK1.7进⾏多线程put操作，之后遍历，直接死循环，CPU飙到100%，在JDK 1.8中进⾏多线程操作会出现<br>节点和value值丢失，为什么JDK1.7与JDK1.8多线程操作会出现很⼤不同，是因为JDK 1.8的作者对resize⽅法进<br>⾏了优化不会产⽣链表闭环。<br>ii. 结构：<br>iii. HashMap扩容：<br>1、很简单的计算：由于默认的加载因⼦是0.75 ，那么，此时map的阀值是 16*0.75 = 12，即添加第13 个键值对&lt;Key,Value&gt;的<br>时候，map的容量会扩充⼀倍。<br>2、确实如此，但是为了尽可能第减少桶中的Entry&lt;Key,Value&gt;链表的长度，以提⾼HashMap的存取性能，确定的这个经验<br>值。如果读者你对存取效率要求的不是太⾼，想省点空间的话，你可以new HashMap(int initialCapacity, float loadFactor)构造⽅<br>法将这个因⼦设置得⼤⼀些也⽆妨。</li><li>扩容步骤：<br>1 1.申请⼀个新的、⼤⼩为当前容量两倍的数组；<br>2 2.将旧数组的Entry[] table中的链表重新计算hash值，然后重新均匀地放置到新的扩充数组中；<br>3 3.释放旧的数组；</li><li>为何扩容为原来的两倍（性能）：<br>a. 在HashMap通过键的哈希值进⾏定位桶位置的时候，调⽤了⼀个indexFor(hash, table.length);⽅法。<br>1 /**<br>2 * Returns index for hash code h.<br>3 */<br>4 static int indexFor(int h, int length) {<br>5 return h &amp; (length-1);<br>6 }<br>b. 通过限制length是⼀个2的幂数，h &amp; (length-1)和h % length结果是⼀致的。<br>c. 如果length是⼀个2的幂的数，那么length-1就会变成⼀个mask, 它会将hashcode低位取出来，<br>hashcode的低位实际就是余数，和取余操作相⽐，与操作会将性能提升很多。<br>_.<br>iv. put流程：<br>1 a. 获取这个Key的hashcode值，根据此值确定应该将这⼀对键值对存放在哪⼀个桶中，即确定要存放桶的索引；<br>2 b. 遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<br>3 c1. 若已存在，定位到对应的Entry&lt;Key,Value&gt;,其中的Value值更新为新的Value值；返回旧值；<br>4 c2. 若不存在，则根据键值对&lt;Key,Value&gt; 创建⼀个新的Entry&lt;Key,Value&gt;对象，然后添加到这个桶的Entry&lt;Key,Value&gt;<br>5 d. 当前的HashMap的⼤⼩(即Entry&lt;key,Value&gt;节点的数⽬)是否超过了阀值，若超过了阀值(threshold)，<br>6 则增⼤HashMap的容量(即Entry[] table 的⼤⼩)，并且重新组织内部各个Entry&lt;Key,Value&gt;排列。<br>v. get流程：<br>1 a. 获取这个Key的hashcode值，根据此hashcode值决定应该从哪⼀个桶中查找；<br>2 b. 遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<br>3 c1. 若已存在，定位到对应的Entry&lt;Key,Value&gt;,返回value<br>4 c2. 若不存在，返回null；</li></ol><p>红黑树简介</p><ol><li>简介<br>红黑树是一种自平衡二叉查找树。它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。在C++ STL中，很多部分(目前包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。<br>本文介绍了红黑树的基本性质和基本操作。</li><li>红黑树的性质<br>红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡。它的每个节点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父节点）。<br>红黑树的定义也是它的性质，有以下五条：<br>性质1. 节点是红色或黑色<br>性质2. 根是黑色<br>性质3. 所有叶子都是黑色（叶子是NIL节点）<br>性质4. 如果一个节点是红的，则它的两个儿子都是黑的<br>性质5. 从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p>这五个性质强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。为什么呢？性质4暗示着任何一个简单路径上不能有两个毗连的红色节点，这样，最短的可能路径全是黑色节点，最长的可能路径有交替的红色和黑色节点。同时根据性质5知道：所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br>3. 红黑树的基本操作<br>因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同。然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次。<br>3.1 插入操作<br>插入操作可以概括为以下几个步骤：<br>(1) 查找要插入的位置，时间复杂度为：O(N)<br>(2) 将新节点的color赋为红色<br>(3) 自下而上重新调整该树为红黑树<br>其中，第(1)步的查找方法跟普通二叉查找树一样，第(2)步之所以将新插入的节点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整，这样简单多了。下面讨论步骤(3)的一些细节：<br>设要插入的节点为N，其父节点为P，其父亲G的兄弟节点为U（即P和U是同一个节点的两个子节点）。<br>[1] 如果P是黑色的，则整棵树不必调整便是红黑树。<br>[2] 如果P是红色的（可知，其父节点G一定是黑色的），则插入z后，违背了性质4，需要进行调整。调整时分以下3种情况：<br>（a）N的叔叔U是红色的</p><p>如上图所示，我们将P和U重绘为黑色并重绘节点G为红色(用来保持性质5)。现在新节点N有了一个黑色的父节点P，因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G的父节点也有可能是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归调整颜色。<br>（b）N的叔叔U是黑色的，且N是右孩子</p><p>如上图所示，我们对P进行一次左旋转调换新节点和其父节点的角色; 接着，按情形(c)处理以前的父节点P以解决仍然失效的性质4。<br>（c）N的叔叔U是黑色的，且N是左孩子</p><p>如上图所示，对祖父节点G 的一次右旋转; 在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G 的父节点， 然后交换以前的父节点P和祖父节点G的颜色，结果的树满足性质4，同时性质5[4]也仍然保持满足。<br>3.2 删除操作<br>删除操作可以概括为以下几个步骤：<br>(1) 查找要删除位置，时间复杂度为：O(N)<br>(2) 用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点）<br>(3) 如果删除节点的替换节点为黑色，则需重新调整该树为红黑树<br>其中，第(1)步的查找方法跟普通二叉查找树一样，第(2)步之所以用后继节点替换删除节点，是因为这样可以保证该后继节点之上仍是一个红黑树，而后继节点可能是一个叶节点或者只有右子树的节点，这样只需用有节点替换后继节点即可达到删除的目的。如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。（没看懂？？？可参考：<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a> ）在第(3)步中，如果，如果删除节点为红色节点，则他的父亲和孩子全为黑节点，这样直接删除该节点即可，不必进行任何调整。如果删除节点是黑节点，分四种情况：<br>设要删除的节点为N，其父节点为P，其兄弟节点为S。<br>由于N是黑色的，则P可能是黑色的，也可能是红色的，S也可能是黑色的或者红色的<br>（1）S是红色的<br>此时P肯定是红色的。我们对N的父节点进行左旋转，然后把红色兄弟转换成N的祖父。我们接着对调 N 的父亲和祖父的颜色。尽管所有的路径仍然有相同数目的黑色节点，现在 N 有了一个黑色的兄弟和一个红色的父亲，所以我们可以接下去按 (2)、(3)或(4)情况来处理。</p><p>（2）S和S的孩子全是黑色的<br>在这种情况下，P可能是黑色的或者红色的，我们简单的重绘S 为红色。结果是通过S的所有路径，它们就是以前不通过 N 的那些路径，都少了一个黑色节点。因为删除 N 的初始的父亲使通过 N 的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过 P 的所有路径现在比不通过 P 的路径少了一个黑色节点。接下来，要调整以P作为N递归调整树。</p><p>（3）S是黑色的，S的左孩子是红色，右孩子是黑色<br>这种情况下我们在 S 上做右旋转，这样 S 的左儿子成为 S 的父亲和 N 的新兄弟。我们接着交换 S 和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在 N 有了一个右儿子是红色的黑色兄弟，所以我们进入了情况（4）。N 和它的父亲都不受这个变换的影响。</p><p>（4）S是黑色的，S的右孩子是红色<br>在这种情况下我们在 N 的父亲上做左旋转，这样 S 成为 N 的父亲和 S 的右儿子的父亲。我们接着交换 N 的父亲和 S 的颜色，并使 S 的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以属性 3 没有被违反。但是，N 现在增加了一个黑色祖先: 要么 N 的父亲变成黑色，要么它是黑色而 S 被增加为一个黑色祖父。所以，通过 N 的路径都增加了一个黑色节点。</p><p>部分IT公司笔试算法题<br>个人总结，算法未必最合理，仅供参考: <a href="mailto:&#115;&#x68;&#97;&#121;&#103;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;">&#115;&#x68;&#97;&#121;&#103;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;</a><br>1、将一整数逆序后放入一数组中（要求递归实现）</p><pre><code>void convert(int *result, int n) &#123;
    if(n&gt;=10)
        convert(result+1, n/10);
    *result = n%10;    
&#125;
int main(int argc, char* argv[]) &#123;
    int n = 123456789, result[20]=&#123;&#125;;
    convert(result, n);
    printf(&quot;%d:&quot;, n);
    for(int i=0; i&lt;9; i++)
        printf(&quot;%d&quot;, result[i]);
&#125;
</code></pre><p>2、求高于平均分的学生学号及成绩（学号和成绩人工输入）</p><pre><code>double find(int total, int n) &#123;
    int number, score,  average;
    scanf(&quot;%d&quot;, &amp;number);
    if(number != 0) &#123;
        scanf(&quot;%d&quot;, &amp;score);
        average = find(total+score, n+1);
        if(score &gt;= average)
            printf(&quot;%d:%d\n&quot;, number, score);
        return average;
    &#125; else &#123;
        printf(&quot;Average=%d\n&quot;, total/n);
        return total/n;
    &#125;
&#125;
int main(int argc, char* argv[]) &#123;
    find(0, 0);
&#125;
</code></pre><p>3、递归实现回文判断（如：abcdedbca就是回文，判断一个面试者对递归理解的简单程序）</p><pre><code>int find(char *str, int n) &#123;
    if(n&lt;=1)    return 1;
    else if(str[0]==str[n-1])    return find(str+1, n-2);
    else        return 0;
&#125;

int main(int argc, char* argv[]) &#123;
    char *str = &quot;abcdedcba&quot;;
    printf(&quot;%s: %s\n&quot;, str, find(str, strlen(str)) ? &quot;Yes&quot; : &quot;No&quot;);
&#125;
</code></pre><p>4、组合问题（从M个不同字符中任取N个字符的所有组合）</p><pre><code>void find(char *source, char *result, int n) &#123;
    if(n==1) &#123;
        while(*source)
           printf(&quot;%s%c\n&quot;, result, *source++);
    &#125; else &#123;
        int i, j;
        for(i=0; source[i] != 0; i++);
        for(j=0; result[j] != 0; j++);
        for(; i&gt;=n; i--) &#123;
            result[j] = *source++;
            result[j+1] = &#39;\0&#39;;
            find(source, result, n-1);
        &#125;
    &#125;
&#125;

int main(int argc, char* argv[]) &#123;
    int const n = 3;
    char *source = &quot;ABCDE&quot;, result[n+1] = &#123;0&#125;;
    if(n&gt;0 &amp;&amp; strlen(source)&gt;0 &amp;&amp; n&lt;=strlen(source))
        find(source, result, 3);
&#125;
</code></pre><p>5、分解成质因数(如435234=251<em>17</em>17<em>3</em>2，据说是华为笔试题)</p><pre><code>void prim(int m, int n) &#123;
    if(m&gt;n) &#123;
        while(m%n != 0) n++;
        m /= n;
        prim(m, n);
        printf(&quot;%d*&quot;, n);
    &#125;
&#125;
int main(int argc, char* argv[]) &#123;
    int n = 435234;
    printf(&quot;%d=&quot;, n);
    prim(n, 2);
&#125;
</code></pre><p>6、寻找迷宫的一条出路，o：通路； X：障碍。（大家经常谈到的一个小算法题）</p><pre><code>#define MAX_SIZE  8
int H[4] = &#123;0, 1, 0, -1&#125;; 
int V[4] = &#123;-1, 0, 1, 0&#125;;           
char Maze[MAX_SIZE][MAX_SIZE] = &#123;&#123;'X','X','X','X','X','X','X','X'&#125;,
                                 &#123;'o','o','o','o','o','X','X','X'&#125;,
                                 &#123;'X','o','X','X','o','o','o','X'&#125;,
                           		&#123;'X','o','X','X','o','X','X','o'&#125;,
                      			&#123;'X','o','X','X','X','X','X','X'&#125;,
&#123;'X','o','X','X','o','o','o','X'&#125;,
  							&#123;'X','o','o','o','o','X','o','o'&#125;,
                                 &#123;'X','X','X','X','X','X','X','X'&#125;&#125;;
void FindPath(int X, int Y) &#123;
    if(X == MAX_SIZE || Y == MAX_SIZE) &#123;
          for(int i = 0; i &lt; MAX_SIZE; i++)
for(int j = 0; j &lt; MAX_SIZE; j++)
                  printf(&quot;%c%c&quot;, Maze[i][j], j &lt; MAX_SIZE-1 ? &#39; &#39; : &#39;\n&#39;);
&#125;else for(int k = 0; k &lt; 4; k++) 
if(X &gt;= 0 &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; MAX_SIZE &amp;&amp; X &lt; MAX_SIZE &amp;&amp; &#39;o&#39; == Maze[X][Y]) &#123;
                      Maze[X][Y] = &#39; &#39;;
                      FindPath(X+V[k], Y+H[k]);
                      Maze[X][Y] =&#39;o&#39;; 
&#125;
&#125;
int main(int argc, char* argv[]) &#123;
    FindPath(1,0);
&#125;
</code></pre><p>7、随机分配座位，共50个学生，使学号相邻的同学座位不能相邻(早些时候用C#写的，没有用C改写）。</p><pre><code>static void Main(string[] args)
&#123;
    int Tmp = 0, Count = 50;            
    int[] Seats = new int[Count];            
    bool[] Students = new bool[Count];
    System.Random RandStudent=new System.Random();
    Students[Seats[0]=RandStudent.Next(0,Count)]=true;
    for(int i = 1; i &lt; Count; ) &#123;
        Tmp=(int)RandStudent.Next(0,Count);
        if((!Students[Tmp])&amp;&amp;(Seats[i-1]-Tmp!=1) &amp;&amp; (Seats[i-1] - Tmp) != -1) &#123;
            Seats[i++] = Tmp;
Students[Tmp] = true;
        &#125;
    &#125;
    foreach(int Student in Seats)
        System.Console.Write(Student + &quot; &quot;);
    System.Console.Read();
&#125;
</code></pre><p>8、求网格中的黑点分布。现有6*7的网格，在某些格子中有黑点，已知各行与各列中有黑点的点数之和，请在这张网格中画出黑点的位置。（这是一网友提出的题目，说是他笔试时遇到算法题）</p><pre><code>#define ROWS 6
#define COLS 7
int iPointsR[ROWS] = &#123;2, 0, 4, 3, 4, 0&#125;;           // 各行黑点数和的情况
int iPointsC[COLS] = &#123;4, 1, 2, 2, 1, 2, 1&#125;;        // 各列黑点数和的情况
int iCount, iFound;
int iSumR[ROWS], iSumC[COLS], Grid[ROWS][COLS];

int Set(int iRowNo) &#123;
if(iRowNo == ROWS) &#123; 
        for(int iColNo=0; iColNo &lt; COLS &amp;&amp; iSumC[iColNo]==iPointsC[iColNo]; iColNo++) 
           if(iColNo == COLS-1) &#123;
               printf(&quot;\nNo.%d:\n&quot;, ++iCount); 
               for(int i=0; i &lt; ROWS; i++)
                  for(int j=0; j &lt; COLS; j++)
                      printf(&quot;%d%c&quot;, Grid[i][j], (j+1) % COLS ? &#39; &#39; : &#39;\n&#39;);
               iFound = 1;    // iFound = 1，有解
           &#125;
    &#125; else &#123;
        for(int iColNo=0; iColNo &lt; COLS; iColNo++) &#123;
            if(iPointsR[iRowNo] == 0) &#123; 
                Set(iRowNo + 1);
   &#125; else if(Grid[iRowNo][iColNo]==0) &#123; 
Grid[iRowNo][iColNo] = 1; 
iSumR[iRowNo]++; iSumC[iColNo]++;                                  if(iSumR[iRowNo]&lt;iPointsR[iRowNo] &amp;&amp; iSumC[iColNo]&lt;=iPointsC[iColNo])
                     Set(iRowNo);
else if(iSumR[iRowNo]==iPointsR[iRowNo] &amp;&amp; iRowNo &lt; ROWS)
                     Set(iRowNo + 1);
                Grid[iRowNo][iColNo] = 0;
                iSumR[iRowNo]--; 
iSumC[iColNo]--;
            &#125;
        &#125;
    &#125;
return iFound;           // 用于判断是否有解
&#125;
int main(int argc, char* argv[]) &#123;
    if(!Set(0))
        printf(&quot;Failure!&quot;); 
&#125;
</code></pre><p>9、有4种面值的邮票很多枚，这4种邮票面值分别1, 4, 12, 21，现从多张中最多任取5张进行组合，求取出这些邮票的最大连续组合值。（据说是华为2003年校园招聘笔试题）<br>#define N 5<br>#define M 5<br>int k, Found, Flag[N];<br>int Stamp[M] = {0, 1, 4, 12, 21};</p><p>// 在剩余张数n中组合出面值和Value<br>int Combine(int n, int Value) {<br>if(n &gt;= 0 &amp;&amp; Value == 0) {<br>Found = 1;<br>int Sum = 0;<br>for(int i=0; i&lt;N &amp;&amp; Flag[i] != 0; i++) {<br>Sum += Stamp[Flag[i]];<br>printf(“%d “, Stamp[Flag[i]]);<br>}<br>printf(“\tSum=%d\n\n”, Sum);<br>}else for(int i=1; i&lt;M &amp;&amp; !Found &amp;&amp; n&gt;0; i++)<br>if(Value-Stamp[i] &gt;= 0) {<br>Flag[k++] = i;<br>Combine(n-1, Value-Stamp[i]);<br>Flag[–k] = 0;<br>}<br>return Found;<br>}</p><p>int main(int argc, char* argv[]) {<br>for(int i=1; Combine(N, i); i++, Found=0);<br>}</p><p>10、大整数数相乘的问题。（这是2002年在一考研班上遇到的算法题）<br>void Multiple(char A[], char B[], char C[]) {<br>int TMP, In=0, LenA=-1, LenB=-1;<br>while(A[++LenA] != ‘\0’);<br>while(B[++LenB] != ‘\0’);<br>int Index, Start = LenA + LenB - 1;<br>for(int i=LenB-1; i&gt;=0; i–) {<br>Index = Start–;<br>if(B[i] != ‘0’) {<br>for(int In=0, j=LenA-1; j&gt;=0; j–) {<br>TMP = (C[Index]-‘0’) + (A[j]-‘0’) * (B[i] - ‘0’) + In;<br>C[Index–] = TMP % 10 + ‘0’;<br>In = TMP / 10;<br>}<br>C[Index] = In + ‘0’;<br>}<br>}<br>}</p><p>int main(int argc, char* argv[]) {<br>char A[] = “21839244444444448880088888889”;<br>char B[] = “38888888888899999999999999988”;<br>char C[sizeof(A) + sizeof(B) - 1];</p><pre><code>for(int k=0; k&lt;sizeof(C); k++)
    C[k] = &#39;0&#39;;
C[sizeof(C)-1] = &#39;\0&#39;;

Multiple(A, B, C);
for(int i=0; C[i] != &#39;\0&#39;; i++)
    printf(&quot;%c&quot;, C[i]);
</code></pre><p>}</p><p>11、求最大连续递增数字串（如“ads3sl456789DF3456ld345AA”中的“456789”）<br>int GetSubString(char *strSource, char <em>strResult) {<br>int iTmp=0, iHead=0, iMax=0;<br>for(int Index=0, iLen=0; strSource[Index]; Index++) {<br>if(strSource[Index] &gt;= ‘0’ &amp;&amp; strSource[Index] &lt;= ‘9’ &amp;&amp;<br>strSource[Index-1] &gt; ‘0’ &amp;&amp; strSource[Index] == strSource[Index-1]+1) {<br>iLen++; // 连续数字的长度增1<br>} else { // 出现字符或不连续数字<br>if(iLen &gt; iMax) {<br>iMax = iLen; iHead = iTmp;<br>}<br>// 该字符是数字，但数字不连续<br>if(strSource[Index] &gt;= ‘0’ &amp;&amp; strSource[Index] &lt;= ‘9’) {<br>iTmp = Index;<br>iLen = 1;<br>}<br>}<br>}<br>for(iTmp=0 ; iTmp &lt; iMax; iTmp++) // 将原字符串中最长的连续数字串赋值给结果串<br>strResult[iTmp] = strSource[iHead++];<br>strResult[iTmp]=’\0’;<br>return iMax; // 返回连续数字的最大长度<br>}<br>int main(int argc, char</em> argv[]) {<br>char strSource[]=”ads3sl456789DF3456ld345AA”, char strResult[sizeof(strSource)];<br>printf(“Len=%d, strResult=%s \nstrSource=%s\n”,<br>GetSubString(strSource, strResult), strResult, strSource);<br>}</p><p>12、四个工人，四个任务，每个人做不同的任务需要的时间不同，求任务分配的最优方案。（2005年5月29日全国计算机软件资格水平考试——软件设计师的算法题）。<br>#include “stdafx.h”<br>#define N 4<br>int Cost[N][N] = { {2, 12, 5, 32}, // 行号：任务序号，列号：工人序号<br>{8, 15, 7, 11}, // 每行元素值表示这个任务由不同工人完成所需要的时间<br>{24, 18, 9, 6},<br>{21, 1, 8, 28}};<br>int MinCost=1000;<br>int Task[N], TempTask[N], Worker[N];<br>void Assign(int k, int cost) {<br>if(k == N) {<br>MinCost = cost;<br>for(int i=0; i&lt;N; i++)<br>TempTask[i] = Task[i];<br>} else {<br>for(int i=0; i&lt;N; i++) {<br>if(Worker[i]==0 &amp;&amp; cost+Cost[k][i] &lt; MinCost) { // 为提高效率而进行剪枝<br>Worker[i] = 1; Task[k] = i;<br>Assign(k+1, cost+Cost[k][i]);<br>Worker[i] = 0; Task[k] = 0;<br>}<br>}<br>}<br>}<br>int main(int argc, char* argv[]) {<br>Assign(0, 0);<br>printf(“最佳方案总费用=%d\n”, MinCost);<br>for(int i=0; i&lt;N; i++) /* 输出最佳方案 */<br>printf(“\t任务%d由工人%d来做：%d\n”, i, TempTask[i], Cost[i][TempTask[i]]);<br>}<br>13、八皇后问题，输出了所有情况，不过有些结果只是旋转了90度而已。（回溯算法的典型例题，是数据结构书上算法的具体实现，大家都亲自动手写过这个程序吗？）<br>#define N 8<br>int Board[N][N];<br>int Valid(int i, int j) { // 判断下棋位置是否有效<br>int k = 1;<br>for(k=1; i&gt;=k &amp;&amp; j&gt;=k;k++)<br>if(Board[i-k][j-k]) return 0;<br>for(k=1; i&gt;=k;k++)<br>if(Board[i-k][j]) return 0;<br>for(k=1; i&gt;=k &amp;&amp; j+k&lt;N;k++)<br>if(Board[i-k][j+k]) return 0;<br>return 1;<br>}</p><p>void Trial(int i, int n) { // 寻找合适下棋位置<br>if(i == n) {<br>for(int k=0; k&lt;n; k++) {<br>for(int m=0; m&lt;n; m++)<br>printf(“%d “, Board[k][m]);<br>printf(“\n”);<br>}<br>printf(“\n”);<br>} else {<br>for(int j=0; j&lt;n; j++) {<br>Board[i][j] = 1;<br>if(Valid(i,j))<br>Trial(i+1, n);<br>Board[i][j] = 0;<br>}<br>}<br>}</p><p>int main(int argc, char* argv[]) {<br>Trial(0, N);<br>}</p><p>14、实现strstr功能，即在父串中寻找子串首次出现的位置。（笔试中常让面试者实现标准库中的一些函数）<br>char * strstring(char *ParentString, char *SubString) {<br>char *pSubString, *pPareString;<br>for(char *pTmp=ParentString; *pTmp; pTmp++) {<br>pSubString = SubString;<br>pPareString = pTmp;<br>while(*pSubString == *pPareString &amp;&amp; *pSubString != ‘\0’) {<br>pSubString++;<br>pPareString++;<br>}<br>if(*pSubString == ‘\0’) return pTmp;<br>}<br>return NULL;<br>}</p><p>int main(int argc, char* argv[]) {<br>char *ParentString = “happy birthday to you!”;<br>char *SubString = “birthday”;<br>printf(“%s”,strstring(ParentString, SubString));<br>}</p><p>15、现在小明一家过一座桥，过桥的时候是黑夜，所以必须有灯。现在小明过桥要1分，小明的弟弟要3分，小明的爸爸要6分，小明的妈妈要8分，小明的爷爷要12分。每次此桥最多可过两人，而过桥的速度依过桥最慢者而定，而且灯在点燃后30分就会熄灭。问小明一家如何过桥时间最短？（原本是个小小智力题，据说是外企的面试题，在这里用程序来求解）<br>#include “stdafx.h”<br>#define N 5<br>#define SIZE 64</p><p>// 将人员编号：小明-0，弟弟-1，爸爸-2，妈妈-3，爷爷-4<br>// 每个人的当前位置：0–在桥左边， 1–在桥右边<br>int Position[N];<br>// 过桥临时方案的数组下标； 临时方案； 最小时间方案；<br>int Index, TmpScheme[SIZE], Scheme[SIZE];<br>// 最小过桥时间总和，初始值100；每个人过桥所需要的时间<br>int MinTime=100, Time[N]={1, 3, 6, 8, 12};<br>// 寻找最佳过桥方案。Remnant:未过桥人数; CurTime:当前已用时间;<br>// Direction:过桥方向,1–向右,0–向左<br>void Find(int Remnant, int CurTime, int Direction) {<br>if(Remnant == 0) { // 所有人已经过桥，更新最少时间及方案<br>MinTime=CurTime;<br>for(int i=0; i&lt;SIZE &amp;&amp; TmpScheme[i]&gt;=0; i++)<br>Scheme[i] = TmpScheme[i];<br>} else if(Direction == 1) { // 过桥方向向右，从桥左侧选出两人过桥<br>for(int i=0; i&lt;N; i++)<br>if(Position[i] == 0 &amp;&amp; CurTime + Time[i] &lt; MinTime) {<br>TmpScheme[Index++] = i;<br>Position[i] = 1;<br>for(int j=0; j&lt;N; j++) {<br>int TmpMax = (Time[i] &gt; Time[j] ? Time[i] : Time[j]);<br>if(Position[j] == 0 &amp;&amp; CurTime + TmpMax &lt; MinTime) {<br>TmpScheme[Index++] = j;<br>Position[j] = 1;<br>Find(Remnant - 2, CurTime + TmpMax, !Direction);<br>Position[j] = 0;<br>TmpScheme[–Index] = -1;<br>}<br>}<br>Position[i] = 0;<br>TmpScheme[–Index] = -1;<br>}<br>} else { // 过桥方向向左，从桥右侧选出一个人回来送灯<br>for(int j=0; j&lt;N; j++) {<br>if(Position[j] == 1 &amp;&amp; CurTime+Time[j] &lt; MinTime) {<br>TmpScheme[Index++] = j;<br>Position[j] = 0;<br>Find(Remnant+1, CurTime+Time[j], !Direction);<br>Position[j] = 1;<br>TmpScheme[–Index] = -1;<br>}<br>}<br>}<br>}<br>int main(int argc, char* argv[]) {<br>for(int i=0; i&lt;SIZE; i++) // 初始方案内容为负值，避免和人员标号冲突<br>Scheme[i] = TmpScheme[i] = -1;</p><p>Find(N, 0, 1); // 查找最佳方案</p><pre><code>printf(&quot;MinTime=%d:&quot;, MinTime);    // 输出最佳方案
for(int i=0; i&lt;SIZE &amp;&amp; Scheme[i]&gt;=0; i+=3)
    printf(&quot;  %d-%d  %d&quot;, Scheme[i], Scheme[i+1], Scheme[i+2]);
printf(&quot;\b\b  &quot;);
</code></pre><p>}</p><p>16、2005年11月金山笔试题。编码完成下面的处理函数。函数将字符串中的字符’<em>‘移到串的前部分，前面的非’</em>‘字符后移，但不能改变非’<em>‘字符的先后顺序，函数返回串中字符’</em>‘的数量。如原始串为：ab<strong>cd</strong>e<em>12，处理后为*****abcde12，函数并返回值为5。（要求使用尽量少的时间和辅助空间）<br>int change(char <em>str) { /</em> 这个算法并不高效，从后向前搜索效率要高些 <em>/<br>int count = 0; /</em> 记录串中字符’</em>‘的个数 <em>/<br>for(int i=0, j=0; str[i]; i++) { /</em> 重串首开始遍历 <em>/<br>if(str[i]==’</em>‘) { /* 遇到字符’<em>‘ <em>/<br>for(j=i-1; str[j]!=’</em>‘&amp;&amp;j&gt;=0; j–) /</em> 采用类似插入排序的思想，将<em>前面 <em>/<br>str[j+1]=str[j]; /</em> 的非</em>字符逐个后移，直到遇到<em>字符 <em>/<br>str[j+1] = ‘</em>‘;<br>count++;<br>}<br>}<br>return count;<br>}<br>int main(int argc, char</em> argv[]) {<br>char str[] = “ab<strong>cd</strong>e<em>12”;<br>printf(“str1=%s\n”, str);<br>printf(“str2=%s, count=%d”, str, change(str));<br>}<br>// 终于得到一个比较高效的算法，一个网友提供，估计应该和金山面试官的想法一致。算法如下：<br>int change(char <em>str) {<br>int i,j=strlen(str)-1;<br>for(i=j; j&gt;=0; j–) {<br>if(str[i]!=’</em>‘) {<br>i–;<br>} else if(str[j]!=’</em>‘) {<br>str[i] = str[j];<br>str[j] = ‘*’;<br>i–;<br>}<br>}<br>return i+1;<br>}</p><p>17、2005年11月15日华为软件研发笔试题。实现一单链表的逆转。<br>#include “stdafx.h”<br>typedef char eleType; // 定义链表中的数据类型<br>typedef struct listnode { // 定义单链表结构<br>eleType data;<br>struct listnode *next;<br>}node;</p><p>node *create(int n) { // 创建单链表，n为节点个数<br>node *p = (node *)malloc(sizeof(node));<br>node *head = p; head-&gt;data = ‘A’;<br>for(int i=’B’; i&lt;’A’+n; i++) {<br>p = (p-&gt;next = (node *)malloc(sizeof(node)));<br>p-&gt;data = i;<br>p-&gt;next = NULL;<br>}<br>return head;<br>}</p><p>void print(node *head) { // 按链表顺序输出链表中元素<br>for(; head; head = head-&gt;next)<br>printf(“%c “, head-&gt;data);<br>printf(“\n”);<br>}</p><p>node *reverse(node *head, node *pre) { // 逆转单链表函数。这是笔试时需要写的最主要函数<br>node *p=head-&gt;next;<br>head-&gt;next = pre;<br>if(p) return reverse(p, head);<br>else return head;<br>}</p><p>int main(int argc, char* argv[]) {<br>node *head = create(6);<br>print(head);<br>head = reverse(head, NULL);<br>print(head);<br>}</p><p>18、编码实现字符串转整型的函数（实现函数atoi的功能），据说是神州数码笔试题。如将字符串 ”+123”123, ”-0123”-123, “123CS45”123, “123.45CS”123, “CS123.45”0<br>#include “stdafx.h”<br>int str2int(const char *str) { // 字符串转整型函数<br>int i=0, sign=1, value = 0;<br>if(str==NULL) return NULL; // 空串直接返回 NULL<br>if(str[0]==’-‘ || str[0]==’+’) { // 判断是否存在符号位<br>i = 1;<br>sign = (str[0]==’-‘ ? -1 : 1);<br>}<br>for(; str[i]&gt;=’0’ &amp;&amp; str[i]&lt;=’9’; i++) // 如果是数字，则继续转换<br>value = value * 10 + (str[i] - ‘0’);<br>return sign * value;<br>}</p><p>int main(int argc, char *argv[]) {<br>char *str = “-123.45CS67”;<br>int val = str2int(str);<br>printf(“str=%s\tval=%d\n”, str, val);<br>}</p><p>19、歌德巴赫猜想。任何一个偶数都可以分解为两个素数之和。（其实这是个C二级考试的模拟试题）<br>#include “stdafx.h”<br>#include “math.h”<br>int main(int argc, char* argv[]) {<br>int Even=78, Prime1, Prime2, Tmp1, Tmp2;<br>for(Prime1=3; Prime1&lt;=Even/2; Prime1+=2) {<br>for(Tmp1=2,Tmp2=sqrt(float(Prime1)); Tmp1&lt;=Tmp2 &amp;&amp; Prime1%Tmp1 != 0; Tmp1++);<br>if(Tmp1&lt;=Tmp2) continue;<br>Prime2 = Even-Prime1;<br>for(Tmp1=2,Tmp2=sqrt(float(Prime2)); Tmp1&lt;=Tmp2 &amp;&amp; Prime2%Tmp1 != 0; Tmp1++);<br>if(Tmp1&lt;=Tmp2) continue;<br>printf(“%d=%d+%d\n”, Even, Prime1, Prime2);<br>}<br>}</p><p>20、快速排序（东软喜欢考类似的算法填空题，又如堆排序的算法等）<br>#include “stdafx.h”<br>#define N 10<br>int part(int list[], int low, int high) { // 一趟排序，返回分割点位置<br>int tmp = list[low];<br>while(low&lt;high) {<br>while(low&lt;high &amp;&amp; list[high]&gt;=tmp) –high;<br>list[low] = list[high];<br>while(low&lt;high &amp;&amp; list[low]&lt;=tmp) ++low;<br>list[high] = list[low];<br>}<br>list[low] = tmp;<br>return low;<br>}<br>void QSort(int list[], int low, int high) { // 应用递归进行快速排序<br>if(low&lt;high) {<br>int mid = part(list, low, high);<br>QSort(list, low, mid-1);<br>QSort(list, mid+1, high);<br>}<br>}<br>void show(int list[], int n) { // 输出列表中元素<br>for(int i=0; i&lt;n; i++)<br>printf(“%d “, list[i]);<br>printf(“\n”);<br>}<br>int main(int argc, char* argv[]) {<br>int list[N] = {23, 65, 26, 1, 6, 89, 3, 12, 33, 8};<br>show(list, N); // 输出排序前序列<br>QSort(list, 0, N-1); // 快速排序<br>show(list, N); // 输出排序后序列<br>}</p><p>21、2005年11月23日慧通笔试题：写一函数判断某个整数是否为回文数，如12321为回文数。可以用判断入栈和出栈是否相同来实现（略微复杂些），这里是将整数逆序后形成另一整数，判断两个整数是否相等来实现的。<br>#include “stdafx.h”<br>int IsEchoNum(int num) {<br>int tmp = 0;<br>for(int n = num; n; n/=10)<br>tmp = tmp *10 + n%10;<br>return tmp==num;<br>}</p><p>int main(int argc, char* argv[]) {<br>int num = 12321;<br>printf(“%d %d\n”, num, IsEchoNum(num));<br>}</p><p>22、删除字符串中的数字并压缩字符串（神州数码以前笔试题），如字符串”abc123de4fg56”处理后变为”abcdefg”。注意空间和效率。（下面的算法只需要一次遍历，不需要开辟新空间，时间复杂度为O(N)）<br>#include “stdafx.h”<br>void delNum(char *str) {<br>int i, j=0;<br>// 找到串中第一个数字的位子<br>for(i=j=0; str[i] &amp;&amp; (str[i]&lt;’0’ || str[i]&gt;’9’); j=++i);</p><pre><code>// 从串中第一个数字的位置开始，逐个放入后面的非数字字符
for(; str[i]; i++)            
    if(str[i]&lt;&#39;0&#39; || str[i]&gt;&#39;9&#39;) 
        str[j++] = str[i];
str[j] = &#39;\0&#39;;
</code></pre><p>}</p><p>int main(int argc, char* argv[]) {<br>char str[] = “abc123ef4g4h5”;<br>printf(“%s\n”, str);<br>delNum(str);<br>printf(“%s\n”, str);<br>}</p><p>23、求两个串中的第一个最长子串（神州数码以前试题）。如”abractyeyt”,”dgdsaeactyey”的最大子串为”actyet”。<br>#include “stdafx.h”<br>char *MaxSubString(char *str1, char *str2) {<br>int i, j, k, index, max=0;<br>for(i=0; str1[i]; i++)<br>for(j=0; str2[j]; j++) {<br>for(k=0; str1[i+k]==str2[j+k] &amp;&amp; (str2[i+k] || str1[i+k]); k++);<br>if(k&gt;max) { // 出现大于当前子串长度的子串，则替换子串位置和程度<br>index = j; max = k;<br>}<br>}<br>char *strResult = (char *)calloc(sizeof(char), max+1);<br>for(i=0; i&lt;max; i++)<br>strResult[i] = str2[index++];<br>return strResult;<br>}</p><p>int main(int argc, char* argv[]) {<br>char str1[] = “abractyeyt”, str2[] = “dgdsaeactyey”;<br>char *strResult = MaxSubString(str1, str2);<br>printf(“str1=%s\nstr2=%s\nMaxSubString=%s\n”, str1, str2, strResult);<br>}</p><p>24、不开辟用于交换数据的临时空间，如何完成字符串的逆序(在技术一轮面试中，有些面试官会这样问)<br>#include “stdafx.h”<br>void change(char <em>str) {<br>for(int i=0,j=strlen(str)-1; i&lt;j; i++, j–){<br>str[i] ^= str[j] ^= str[i] ^= str[j];<br>}<br>}<br>int main(int argc, char</em> argv[]) {<br>char str[] = “abcdefg”;<br>printf(“strSource=%s\n”, str);<br>change(str);<br>printf(“strResult=%s\n”, str);<br>return getchar();<br>}</p><p>25、删除串中指定的字符（做此题时，千万不要开辟新空间，否则面试官可能认为你不适合做嵌入式开发）<br>#include “stdafx.h”<br>void delChar(char *str, char c) {<br>int i, j=0;<br>for(i=0; str[i]; i++)<br>if(str[i]!=c) str[j++]=str[i];<br>str[j] = ‘\0’;<br>}</p><p>int main(int argc, char* argv[]) {<br>char str[] = “abcdefgh”; // 注意，此处不能写成char *str = “abcdefgh”;<br>printf(“%s\n”, str);<br>delChar(str, ‘c’);<br>printf(“%s\n”, str);<br>}</p><p>26、判断单链表中是否存在环（网上说的笔试题）<br>#include “stdafx.h”<br>typedef char eleType; // 定义链表中的数据类型<br>typedef struct listnode { // 定义单链表结构<br>eleType data;<br>struct listnode *next;<br>}node;</p><p>node *create(int n) { // 创建单链表，n为节点个数<br>node *p = (node *)malloc(sizeof(node));<br>node *head = p; head-&gt;data = ‘A’;<br>for(int i=’B’; i&lt;’A’+n; i++) {<br>p = (p-&gt;next = (node *)malloc(sizeof(node)));<br>p-&gt;data = i;<br>p-&gt;next = NULL;<br>}<br>return head;<br>}</p><p>void addCircle(node *head, int n) { // 增加环，将链尾指向链中第n个节点<br>node *q, *p = head;<br>for(int i=1; p-&gt;next; i++) {<br>if(i==n) q = p;<br>p = p-&gt;next;<br>}<br>p-&gt;next = q;<br>}</p><p>int isCircle(node *head) { // 这是笔试时需要写的最主要函数，其他函数可以不写<br>node *p=head,*q=head;<br>while( p-&gt;next &amp;&amp; q-&gt;next) {<br>p = p-&gt;next;<br>if (NULL == (q=q-&gt;next-&gt;next)) return 0;<br>if (p == q) return 1;<br>}<br>return 0;<br>}</p><p>int main(int argc, char* argv[]) {<br>node *head = create(12);<br>addCircle(head, 8); // 注释掉此行，连表就没有环了<br>printf(“%d\n”, isCircle(head));<br>}</p><ol start="4"><li>算法与编程</li><li>判断身份证：要么是15位，要么是18位，最后一位可以为字母，并写程序提出其中的年月日。<br>答：我们可以用正则表达式来定义复杂的字符串格式，(\d{17}[0-9a-zA-Z]|\d{14}[0-9a-zA-Z])可以用来判断是否为合法的15位或18位身份证号码。<br>因为15位和18位的身份证号码都是从7位到第12位为身份证为日期类型。这样我们可以设计出更精确的正则模式，使身份证号的日期合法，这样我们的正则模式可以进一步将日期部分的正则修改为[12][0-9]{3}[01][0-9][123][0-9]，当然可以更精确的设置日期。<br>在jdk的java.util.Regex包中有实现正则的类,Pattern和Matcher。以下是实现代码：</li></ol><p>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;</p><p>public class RegexTest {</p><pre><code>/**
 * @param args
 */
public static void main(String[] args) &#123;
    
    // 测试是否为合法的身份证号码
    String[] strs = &#123; &quot;130681198712092019&quot;, &quot;13068119871209201x&quot;,
            &quot;13068119871209201&quot;, &quot;123456789012345&quot;, &quot;12345678901234x&quot;,
            &quot;1234567890123&quot; &#125;;
    Pattern p1 = Pattern.compile(&quot;(\\d&#123;17&#125;[0-9a-zA-Z]|\\d&#123;14&#125;[0-9a-zA-Z])&quot;);
    for (int i = 0; i &lt; strs.length; i++) &#123;
        Matcher matcher = p1.matcher(strs[i]);
        System.out.println(strs[i] + &quot;:&quot; + matcher.matches());
    &#125;

    Pattern p2 = Pattern.compile(&quot;\\d&#123;6&#125;(\\d&#123;8&#125;).*&quot;); // 用于提取出生日字符串
    Pattern p3 = Pattern.compile(&quot;(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)&quot;);// 用于将生日字符串进行分解为年月日
    for (int i = 0; i &lt; strs.length; i++) &#123;
        Matcher matcher = p2.matcher(strs[i]);
        boolean b = matcher.find();
        if (b) &#123;
            String s = matcher.group(1);
            Matcher matcher2 = p3.matcher(s);
            if (matcher2.find()) &#123;
                System.out
                        .println(&quot;生日为&quot; + matcher2.group(1) + &quot;年&quot;
                                + matcher2.group(2) + &quot;月&quot;
                                + matcher2.group(3) + &quot;日&quot;);
            &#125;
        &#125;

    &#125;

&#125;
</code></pre><p>}</p><p>1、编写一个程序，将a.txt文件中的单词与b.txt文件中的单词交替合并到c.txt文件中，a.txt文件中的单词用回车符分隔，b.txt文件中用回车或空格进行分隔。<br>答：<br>package cn.itcast;</p><p>import java.io.File;<br>import java.io.FileReader;<br>import java.io.FileWriter;</p><p>public class MainClass{<br>public static void main(String[] args) throws Exception{<br>FileManager a = new FileManager(“a.txt”,new char[]{‘\n’});<br>FileManager b = new FileManager(“b.txt”,new char[]{‘\n’,’ ‘});<br>FileWriter c = new FileWriter(“c.txt”);<br>String aWord = null;<br>String bWord = null;<br>while((aWord = a.nextWord()) !=null ){<br>c.write(aWord + “\n”);<br>bWord = b.nextWord();<br>if(bWord != null)<br>c.write(bWord + “\n”);<br>}</p><pre><code>    while((bWord = b.nextWord()) != null)&#123;
        c.write(bWord + &quot;\n&quot;);
    &#125;    
    c.close();
&#125;
</code></pre><p>}</p><p>class FileManager{</p><pre><code>String[] words = null;
int pos = 0;
public FileManager(String filename,char[] seperators) throws Exception&#123;
    File f = new File(filename);
    FileReader reader = new FileReader(f);
    char[] buf = new char[(int)f.length()];
    int len = reader.read(buf);
    String results = new String(buf,0,len);
    String regex = null;
    if(seperators.length &gt;1 )&#123;
        regex = &quot;&quot; + seperators[0] + &quot;|&quot; + seperators[1];
    &#125;else&#123;
        regex = &quot;&quot; + seperators[0];
    &#125;
    words = results.split(regex);
&#125;

public String nextWord()&#123;
    if(pos == words.length)
        return null;
    return words[pos++];
&#125;
</code></pre><p>}</p><p>1、编写一个程序，将d:\java目录下的所有.java文件复制到d:\jad目录下，并将原来文件的扩展名从.java改为.jad。<br>（大家正在做上面这道题，网上迟到的朋友也请做做这道题，找工作必须能编写这些简单问题的代码！）<br>答：listFiles方法接受一个FileFilter对象，这个FileFilter对象就是过虑的策略对象，不同的人提供不同的FileFilter实现，即提供了不同的过滤策略。<br>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.FilenameFilter;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;</p><p>public class Jad2Java {</p><pre><code>public static void main(String[] args) throws Exception &#123;
    File srcDir = new File(&quot;java&quot;);
    if(!(srcDir.exists() &amp;&amp; srcDir.isDirectory()))
            throw new Exception(&quot;目录不存在&quot;);
    File[] files = srcDir.listFiles(
        new FilenameFilter()&#123;

                public boolean accept(File dir, String name) &#123;
                    return name.endsWith(&quot;.java&quot;);
                &#125;
                
            &#125;
    );
    
    System.out.println(files.length);
    File destDir = new File(&quot;jad&quot;);
    if(!destDir.exists()) destDir.mkdir();
    for(File f :files)&#123;
        FileInputStream  fis = new FileInputStream(f);
        String destFileName = f.getName().replaceAll(&quot;\\.java$&quot;, &quot;.jad&quot;);
        FileOutputStream fos = new FileOutputStream(new File(destDir,destFileName));
        copy(fis,fos);
        fis.close();
        fos.close();
    &#125;
&#125;

private static void copy(InputStream ips,OutputStream ops) throws Exception&#123;
    int len = 0;
    byte[] buf = new byte[1024];
    while((len = ips.read(buf)) != -1)&#123;
        ops.write(buf,0,len);
    &#125;

&#125;
</code></pre><p>}</p><p>由本题总结的思想及策略模式的解析：<br>1.<br>class jad2java{<br>1. 得到某个目录下的所有的java文件集合<br>1.1 得到目录 File srcDir = new File(“d:\java”);<br>1.2 得到目录下的所有java文件：File[] files = srcDir.listFiles(new MyFileFilter());<br>1.3 只想得到.java的文件： class MyFileFilter implememyts FileFilter{<br>public boolean accept(File pathname){<br>return pathname.getName().endsWith(“.java”)<br>}<br>}</p><pre><code>2.将每个文件复制到另外一个目录，并改扩展名
    2.1 得到目标目录，如果目标目录不存在，则创建之
    2.2 根据源文件名得到目标文件名，注意要用正则表达式，注意.的转义。
    2.3 根据表示目录的File和目标文件名的字符串，得到表示目标文件的File。
        //要在硬盘中准确地创建出一个文件，需要知道文件名和文件的目录。 
    2.4 将源文件的流拷贝成目标文件流，拷贝方法独立成为一个方法，方法的参数采用抽象流的形式。
        //方法接受的参数类型尽量面向父类，越抽象越好，这样适应面更宽广。    
</code></pre><p>}</p><p>分析listFiles方法内部的策略模式实现原理<br>File[] listFiles(FileFilter filter){<br>File[] files = listFiles();<br>//Arraylist acceptedFilesList = new ArrayList();<br>File[] acceptedFiles = new File[files.length];<br>int pos = 0;<br>for(File file: files){<br>boolean accepted = filter.accept(file);<br>if(accepted){<br>//acceptedFilesList.add(file);<br>acceptedFiles[pos++] = file;<br>}<br>}</p><pre><code>Arrays.copyOf(acceptedFiles,pos);
//return (File[])accpetedFilesList.toArray();
</code></pre><p>}<br>1、编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。<br>答：<br>首先要了解中文字符有多种编码及各种编码的特征。<br>假设n为要截取的字节数。<br>public static void main(String[] args) throws Exception{<br>String str = “我a爱中华abc我爱传智def’;<br>String str = “我ABC汉”;<br>int num = trimGBK(str.getBytes(“GBK”),5);<br>System.out.println(str.substring(0,num) );<br>}</p><pre><code>public static int  trimGBK(byte[] buf,int n)&#123;
    int num = 0;
    boolean bChineseFirstHalf = false;
    for(int i=0;i&lt;n;i++)
    &#123;
        if(buf[i]&lt;0 &amp;&amp; !bChineseFirstHalf)&#123;
            bChineseFirstHalf = true;
        &#125;else&#123;
            num++;
            bChineseFirstHalf = false;                
        &#125;
    &#125;
    return num;
&#125;
</code></pre><p>1、有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数。<br>答：哈哈，其实包含中文字符、英文字符、数字字符原来是出题者放的烟雾弹。<br>String content = “中国aadf的111萨bbb菲的zz萨菲”;<br>HashMap map = new HashMap();<br>for(int i=0;i&lt;content.length;i++)<br>{<br>char c = content.charAt(i);<br>Integer num = map.get(c);<br>if(num == null)<br>num = 1;<br>else<br>num = num + 1;<br>map.put(c,num);<br>}<br>for(Map.EntrySet entry : map)<br>{<br>system.out.println(entry.getkey() + “:” + entry.getValue());<br>}<br>估计是当初面试的那个学员表述不清楚，问题很可能是：<br>如果一串字符如”aaaabbc中国1512”要分别统计英文字符的数量，中文字符的数量，和数字字符的数量，假设字符中没有中文字符、英文字符、数字字符之外的其他特殊字符。<br>int engishCount;<br>int chineseCount;<br>int digitCount;<br>for(int i=0;i&lt;str.length;i++)<br>{<br>char ch = str.charAt(i);<br>if(ch&gt;=’0’ &amp;&amp; ch&lt;=’9’)<br>{<br>digitCount++<br>}<br>else if((ch&gt;=’a’ &amp;&amp; ch&lt;=’z’) || (ch&gt;=’A’ &amp;&amp; ch&lt;=’Z’))<br>{<br>engishCount++;<br>}<br>else<br>{<br>chineseCount++;<br>}<br>}<br>System.out.println(……………);</p><p>1、说明生活中遇到的二叉树，用java实现二叉树<br>这是组合设计模式。<br>我有很多个(假设10万个)数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据，（我想说出二叉树的好处，该怎么说呢？那就是说别人的缺点），假如存在数组中，那么，碰巧要找的数字位于99999那个地方，那查找的速度将很慢，因为要从第1个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序，中序，后序）效率要比数组低很多，原理如下图：</p><p>代码如下：<br>package com.huawei.interview;</p><p>public class Node {<br>public int value;<br>public Node left;<br>public Node right;</p><pre><code>public void store(int value)
&#123;
    if(value&lt;this.value)
    &#123;
        if(left == null)
        &#123;
            left = new Node();
            left.value=value;
        &#125;
        else
        &#123;
            left.store(value);
        &#125;
    &#125;
    else if(value&gt;this.value)
    &#123;
        if(right == null)
        &#123;
            right = new Node();
            right.value=value;
        &#125;
        else
        &#123;
            right.store(value);
        &#125;            
    &#125;
&#125;

public boolean find(int value)
&#123;    
    System.out.println(&quot;happen &quot; + this.value);
    if(value == this.value)
    &#123;
        return true;
    &#125;
    else if(value&gt;this.value)
    &#123;
        if(right == null) return false;
        return right.find(value);
    &#125;else
    &#123;
        if(left == null) return false;
        return left.find(value);
    &#125;

&#125;

public  void preList()
&#123;
    System.out.print(this.value + &quot;,&quot;);
    if(left!=null) left.preList();
    if(right!=null) right.preList();
&#125;

public void middleList()
&#123;
    if(left!=null) left.preList();
    System.out.print(this.value + &quot;,&quot;);
    if(right!=null) right.preList();        
&#125;
public void afterList()
&#123;
</code></pre><p>if(left!=null) left.preList();<br>if(right!=null) right.preList();<br>System.out.print(this.value + “,”);<br>}<br>public static void main(String [] args)<br>{<br>int [] data = new int[20];<br>for(int i=0;i&lt;data.length;i++)<br>{<br>data[i] = (int)(Math.random()*100) + 1;<br>System.out.print(data[i] + “,”);<br>}<br>System.out.println();</p><pre><code>    Node root = new Node();
    root.value = data[0];
    for(int i=1;i&lt;data.length;i++)
    &#123;
        root.store(data[i]);
    &#125;
    
    root.find(data[19]);
    
    root.preList();
    System.out.println();
    root.middleList();
    System.out.println();        
    root.afterList();
&#125;
</code></pre><p>}<br>—————–又一次临场写的代码—————————<br>import java.util.Arrays;<br>import java.util.Iterator;</p><p>public class Node {<br>private Node left;<br>private Node right;<br>private int value;<br>//private int num;</p><pre><code>public Node(int value)&#123;
    this.value = value;
&#125;
public void add(int value)&#123;
    
    if(value &gt; this.value)
    &#123;
        if(right != null)
            right.add(value);
        else
        &#123;
            Node node = new Node(value);                
            right = node;
        &#125;
    &#125;
    else&#123;
        if(left != null)
            left.add(value);
        else
        &#123;
            Node node = new Node(value);                
            left = node;
        &#125;            
    &#125;
&#125;

public boolean find(int value)&#123;
    if(value == this.value) return true;
    else if(value &gt; this.value)&#123;
        if(right == null) return false;
        else return right.find(value);
    &#125;else&#123;
        if(left == null) return false;
        else return left.find(value);            
    &#125;

&#125;

public void display()&#123;
    System.out.println(value);
    if(left != null) left.display();
    if(right != null) right.display();
    
&#125;

/*public Iterator iterator()&#123;
    
&#125;*/

public static void main(String[] args)&#123;
    int[] values = new int[8];
    for(int i=0;i&lt;8;i++)&#123;
        int num = (int)(Math.random() * 15);
        //System.out.println(num);
        //if(Arrays.binarySearch(values, num)&lt;0)
        if(!contains(values,num))
            values[i] = num;
        else
            i--;
    &#125;
    
    System.out.println(Arrays.toString(values));
    
    Node root  = new Node(values[0]);
    for(int i=1;i&lt;values.length;i++)&#123;
        root.add(values[i]);
    &#125;
    
    System.out.println(root.find(13));
    
    root.display();
    
&#125;

public static boolean contains(int [] arr, int value)&#123;
    int i = 0;
    for(;i&lt;arr.length;i++)&#123;
        if(arr[i] == value) return true;
        
    &#125;
    return false;
&#125;
</code></pre><p>}<br>1、从类似如下的文本文件中读取出所有的姓名，并打印出重复的姓名和重复的次数，并按重复次数排序：<br>1,张三,28<br>2,李四,35<br>3,张三,28<br>4,王五,35<br>5,张三,28<br>6,李四,35<br>7,赵六,28<br>8,田七,35</p><p>程序代码如下（答题要博得用人单位的喜欢，包名用该公司，面试前就提前查好该公司的网址，如果查不到，现场问也是可以的。还要加上实现思路的注释）：<br>package com.huawei.interview;</p><p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.InputStreamReader;<br>import java.util.Comparator;<br>import java.util.HashMap;<br>import java.util.Iterator;<br>import java.util.Map;<br>import java.util.TreeSet;</p><p>public class GetNameTest {</p><pre><code>/**
 * @param args
 */
public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    //InputStream ips = GetNameTest.class.getResourceAsStream(&quot;/com/huawei/interview/info.txt&quot;);
    //用上一行注释的代码和下一行的代码都可以，因为info.txt与GetNameTest类在同一包下面，所以，可以用下面的相对路径形式
    
    Map results = new HashMap();
    InputStream ips = GetNameTest.class.getResourceAsStream(&quot;info.txt&quot;);
    BufferedReader in = new BufferedReader(new InputStreamReader(ips));
    String line = null;
    try &#123;
        while((line=in.readLine())!=null)
        &#123;
            dealLine(line,results);
        &#125;
        sortResults(results);
    &#125; catch (IOException e) &#123;
        // TODO Auto-generated catch block
        e.printStackTrace();
    &#125;
&#125;

static class User
&#123;
    public  String name;
    public Integer value;
    public User(String name,Integer value)
    &#123;
        this.name = name;
        this.value = value;
    &#125;

    @Override
    public boolean equals(Object obj) &#123;
        // TODO Auto-generated method stub
            
        //下面的代码没有执行，说明往treeset中增加数据时，不会使用到equals方法。
        boolean result = super.equals(obj);
        System.out.println(result);
        return result;
    &#125;
&#125;

private static void sortResults(Map results) &#123;
    // TODO Auto-generated method stub
    TreeSet sortedResults = new TreeSet(
            new Comparator()&#123;
                public int compare(Object o1, Object o2) &#123;
                    // TODO Auto-generated method stub
                    User user1 = (User)o1;
                    User user2 = (User)o2;
                    /*如果compareTo返回结果0，则认为两个对象相等，新的对象不会增加到集合中去
                     * 所以，不能直接用下面的代码，否则，那些个数相同的其他姓名就打印不出来。
                     * */
                    
                    //return user1.value-user2.value;
                    //return user1.value&lt;user2.value?-1:user1.value==user2.value?0:1;
                    if(user1.value&lt;user2.value)
                    &#123;
                        return -1;
                    &#125;else if(user1.value&gt;user2.value)
                    &#123;
                        return 1;
                    &#125;else
                    &#123;
                        return user1.name.compareTo(user2.name);
                    &#125;
                &#125;
                
            &#125;
    );
    Iterator iterator = results.keySet().iterator();
    while(iterator.hasNext())
    &#123;
        String name = (String)iterator.next();
        Integer value = (Integer)results.get(name);
        if(value &gt; 1)
        &#123;                
            sortedResults.add(new User(name,value));                
        &#125;
    &#125;
    
    printResults(sortedResults);
&#125;
private static void printResults(TreeSet sortedResults) 
&#123;
    Iterator iterator  = sortedResults.iterator();
    while(iterator.hasNext())
    &#123;
        User user = (User)iterator.next();
        System.out.println(user.name + &quot;:&quot; + user.value);
    &#125;    
&#125;
public static void dealLine(String line,Map map)
&#123;
    if(!&quot;&quot;.equals(line.trim()))
    &#123;
        String [] results = line.split(&quot;,&quot;);
        if(results.length == 3)
        &#123;
            String name = results[1];
            Integer value = (Integer)map.get(name);
            if(value == null) value = 0;
            map.put(name,value + 1);
        &#125;
    &#125;
&#125;
</code></pre><p>}<br>48、写一个Singleton出来。<br>第一种：饱汉模式<br>public class SingleTon {<br>private SingleTon(){<br>}</p><pre><code>//实例化放在静态代码块里可提高程序的执行效率，但也可能更占用空间    
private final static SingleTon instance = new SingleTon();
public static SingleTon getInstance()&#123;
    return instance;
&#125;
</code></pre><p>}</p><p>第二种：饥汉模式<br>public class SingleTon {<br>private SingleTon(){}</p><pre><code>private static instance = null;//new SingleTon();

public static synchronized SingleTon getInstance()&#123;
    if(instance == null)
        instance = new SingleTon();
    return instance;
&#125;
</code></pre><p>}</p><p>第三种：用枚举<br>public enum SingleTon{<br>ONE;</p><pre><code>&#125;
</code></pre><p>第三：更实际的应用（在什么情况用单例）<br>public class SequenceGenerator{<br>//下面是该类自身的业务功能代码<br>private int count = 0;</p><pre><code>public synchronized int getSequence()&#123;
    ++count;
&#125;

//下面是把该类变成单例的代码
private SequenceGenerator()&#123;&#125;
private final static instance = new SequenceGenerator();
public static SingleTon getInstance()&#123;
    return instance;
&#125;    
</code></pre><p>}</p><p>第四：<br>public class MemoryDao<br>{<br>private HashMap map = new HashMap();</p><pre><code>   public void add(Student stu1)&#123; 
        map.put(SequenceGenerator.getInstance().getSequence(),stu1);
&#125;
</code></pre><p>//把MemoryDao变成单例<br>}</p><p>Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。<br>一般Singleton模式通常有几种种形式:<br>第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。<br>public class Singleton {<br>private Singleton(){}<br>　　 //在自己内部定义自己一个实例，是不是很奇怪？<br>　　 //注意这是private 只供内部调用<br>　　 private static Singleton instance = new Singleton();<br>　　 //这里提供了一个供外部访问本class的静态方法，可以直接访问　　<br>　　 public static Singleton getInstance() {<br>　　　　 return instance; 　　<br>　　 }<br>}<br>第二种形式:<br>public class Singleton {<br>　　private static Singleton instance = null;<br>　　public static synchronized Singleton getInstance() {<br>　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　 　<br>　　//使用时生成实例，提高了效率！<br>　　if (instance==null)<br>　　　　instance＝new Singleton();<br>return instance; 　　<br>}<br>}<br>其他形式:<br>定义一个类，它的构造函数为private的，所有方法为static的。<br>一般认为第一种形式要更加安全些<br>7、递归算法题1<br>一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。<br>例：n=1237<br>则输出为：<br>1237，<br>2474，<br>4948，<br>9896，<br>9896，<br>4948，<br>2474，<br>1237，<br>提示：写程序时，先致谢按递增方式的代码，写好递增的以后，再增加考虑递减部分。<br>public static void doubleNum(int n)<br>{<br>System.out.println(n);<br>if(n&lt;=5000)<br>doubleNum(n*2);<br>System.out.println(n);<br>}</p><p>7、递归算法题2<br>第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？<br>package cn.itcast;</p><p>import java.util.Date;</p><p>public class A1 {</p><pre><code>public static void main(String [] args)
&#123;
    System.out.println(computeAge(8));
&#125;

public static int computeAge(int n)
&#123;
    if(n==1) return 10;
    return computeAge(n-1) + 2;
&#125;
</code></pre><p>}</p><pre><code>public static void toBinary(int n,StringBuffer result)
&#123;

    if(n/2 != 0)
        toBinary(n/2,result);
    result.append(n%2);        
&#125;
</code></pre><p>94、排序都有哪几种方法？请列举。用JAVA实现一个快速排序。<br>本人只研究过冒泡排序、选择排序和快速排序，下面是快速排序的代码：<br>public class QuickSort {<br>/**</p><ul><li>快速排序</li><li>@param strDate</li><li>@param left</li><li>@param right</li><li>/<br>public void quickSort(String[] strDate,int left,int right){<br>String middle,tempDate;<br>int i,j;<br>i=left;<br>j=right;<br>middle=strDate[(i+j)/2];<br>do{<br>while(strDate[i].compareTo(middle)&lt;0&amp;&amp; i&lt;right)<br>i++; //找出左边比中间值大的数<br>while(strDate[j].compareTo(middle)&gt;0&amp;&amp; j&gt;left)<br>j–; //找出右边比中间值小的数<br>if(i&lt;=j){ //将左边大的数和右边小的数进行替换<br>tempDate=strDate[i];<br>strDate[i]=strDate[j];<br>strDate[j]=tempDate;<br>i++;<br>j–;<br>}<br>}while(i&lt;=j); //当两者交错时停止</li></ul><p>if(i&lt;right){<br>quickSort(strDate,i,right);//从<br>}<br>if(j&gt;left){<br>quickSort(strDate,left,j);<br>}<br>}<br>/**<br>  * @param args<br>  */<br>public static void main(String[] args){<br>String[] strVoid=new String[]{“11”,”66”,”22”,”0”,”55”,”22”,”0”,”32”};<br>QuickSort sort=new QuickSort();<br>sort.quickSort(strVoid,0,strVoid.length-1);<br>for(int i=0;i&lt;strVoid.length;i++){<br>System.out.println(strVoid[i]+” “);<br>}<br>}</p><p>}<br>7、有数组a[n]，用java代码将数组元素顺序颠倒<br>//用下面的也可以<br>//for(int i=0,int j=a.length-1;i&lt;j;i++,j–) 是否等效于 for(int i=0;i&lt;a.length/2;i++)呢？</p><p>import java.util.Arrays;</p><p>public class SwapDemo{</p><pre><code>public static void main(String[] args)&#123;
    int [] a = new int[]&#123;
                    (int)(Math.random() * 1000),
                    (int)(Math.random() * 1000),
                    (int)(Math.random() * 1000),
                    (int)(Math.random() * 1000),                        
                    (int)(Math.random() * 1000)                                                                        
    &#125;;    
    
    System.out.println(a);
    System.out.println(Arrays.toString(a));
    swap(a);
    System.out.println(Arrays.toString(a));        
&#125;

public static void swap(int a[])&#123;
    int len = a.length;
    for(int i=0;i&lt;len/2;i++)&#123;
        int tmp = a[i];
        a[i] = a[len-1-i];
        a[len-1-i] = tmp;
    &#125;
&#125;
</code></pre><p>}<br>2．金额转换，阿拉伯数字的金额转换成中国传统的形式如：（￥1011）－&gt;（一千零一拾一元整）输出。<br>去零的代码：<br>return sb.reverse().toString().replaceAll(“零[拾佰仟]”,”零”).replaceAll(“零+万”,”万”).replaceAll(“零+元”,”元”).replaceAll(“零+”,”零”);</p><p>public class RenMingBi {</p><pre><code>/**
 * @param args add by zxx ,Nov 29, 2008
 */
private static final char[] data = new char[]&#123;
        &#39;零&#39;,&#39;壹&#39;,&#39;贰&#39;,&#39;叁&#39;,&#39;肆&#39;,&#39;伍&#39;,&#39;陆&#39;,&#39;柒&#39;,&#39;捌&#39;,&#39;玖&#39;
    &#125;; 
private static final char[] units = new char[]&#123;
    &#39;元&#39;,&#39;拾&#39;,&#39;佰&#39;,&#39;仟&#39;,&#39;万&#39;,&#39;拾&#39;,&#39;佰&#39;,&#39;仟&#39;,&#39;亿&#39;
&#125;;
public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    System.out.println(
            convert(135689123));
&#125;

public static String convert(int money)
&#123;
    StringBuffer sbf = new StringBuffer();
    int unit = 0;
    while(money!=0)
    &#123;
        sbf.insert(0,units[unit++]);
        int number = money%10;
        sbf.insert(0, data[number]);
        money /= 10;
    &#125;

    return sbf.toString();
&#125;
</code></pre><p>}<br>5. html&amp;JavaScript&amp;ajax部分</p><ol><li>判断第二个日期比第一个日期大<br>如何用脚本判断用户输入的的字符串是下面的时间格式2004-11-21 必须要保证用户的输入是此格式，并且是时间，比如说月份不大于12等等，另外我需要用户输入两个，并且后一个要比前一个晚，只允许用JAVASCRIPT，请详细帮助作答，,<br>//这里可用正则表达式判断提前判断一下格式，然后按下提取各时间字段内容<script type="text/javascript">function compareDate(e,t){var n=e.split("-"),a=new Date(n[0],n[1],n[2]),r=t.split("-");return!(a>new Date(r[0],r[1],r[2]))}function verifyDate(e){return/^\d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2]\d|3[0-1])$/.test(e)}window.onload=function(){document.getElementById("frm1").onsubmit=function(){var e=this.d1.value,t=this.d2.value;return verifyDate(e)?verifyDate(t)?compareDate(e,t)?void 0:(alert("第二个日期比第一日期小"),!1):(alert("第二个日期格式不对"),!1):(alert("第一个日期格式不对"),!1)}}</script></li></ol><form id="frm1" action="xxx.html"><input type="text" name="d1"> <input type="text" name="d2"> <input type="submit"></form>140、编程：编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取 的字符串。 但是要保证汉字不 被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC 汉 DEF”，6，应该输出为“我 ABC”而不是“我ABC+汉的半 个”。 答：代码如下： package test;<p>class SplitString</p><p>{<br>String SplitStr;<br>int SplitByte;<br>public SplitString(String str,int bytes)<br>{</p><p>SplitStr=str;</p><p>———- 15 ———-</p><p>*** JAVA面试题.txt ***<br>SplitByte=bytes;<br>System.out.println(“The String is:’”+SplitStr+”‘;SplitBytes=”+SplitByte);<br>}<br>public void SplitIt()<br>{<br>int loopCount;</p><p>loopCount=(SplitStr.length()%SplitByte==0)?(SplitStr.length()/SplitByte):(SplitStr.length()/Split</p><p>Byte+1);<br>System.out.println(“Will Split into “+loopCount);<br>for (int i=1;i&lt;=loopCount ;i++ )<br>{</p><p>if (i==loopCount){</p><p>System.out.println(SplitStr.substring((i-1)*SplitByte,SplitStr.length()));<br>} else {</p><p>System.out.println(SplitStr.substring((i-1)<em>SplitByte,(i</em>SplitByte)));<br>}</p><p>}<br>}<br>public static void main(String[] args)<br>{</p><p>SplitString ss = new SplitString(“test中 dd文 dsaf中男大 3443n中国43 中国人</p><p>0ewldfls=103”,4);<br>ss.SplitIt();<br>}<br>}</p><p>143、ORACLE 大数据量下的分页解决方法。一般用截取 ID方法，还有是三层嵌套方法。<br>答:一种分页方法<br>&lt;%</p><p>int i=1;<br>int numPages=14;<br>String pages = request.getParameter(“page”) ;<br>int currentPage = 1;<br>currentPage=(pages==null)?(1):{Integer.parseInt(pages)}<br>sql = “select count(*) from tables”;<br>ResultSet rs = DBLink.executeQuery(sql) ;<br>while(rs.next()) i = rs.getInt(1) ;<br>int intPageCount=1;<br>intPageCount=(i%numPages==0)?(i/numPages):(i/numPages+1);<br>int nextPage ;<br>int upPage;<br>nextPage = currentPage+1; if (nextPage&gt;=intPageCount) nextPage=intPageCount;<br>upPage = currentPage-1;<br>if (upPage&lt;=1) upPage=1;</p><p>———- 17 ———-</p><p>*** JAVA面试题.txt ***<br>rs.close();<br>sql=”select * from tables”;<br>rs=DBLink.executeQuery(sql);<br>i=0;<br>while((i&lt;numPages*(currentPage-1))&amp;&amp;rs.next()){i++;}<br>%&gt;<br>//输出内容<br>//输出翻页连接<br>合计:&lt;%=currentPage%&gt;/&lt;%=intPageCount%&gt;<a href="List.jsp?page=1">第一页</a>&lt;a</p><p>href=”List.jsp?page=&lt;%=upPage%&gt;”&gt;上一页</p><p>&lt;%<br>for(int j=1;j&lt;=intPageCount;j++){<br>if(currentPage!=j){</p><p>%&gt;<br><a href="list.jsp?page=<%=j%>">[&lt;%=j%&gt;]</a></p><p>&lt;%<br>}else{<br>out.println(j);<br>}<br>}</p><p>%&gt;<br><a href="List.jsp?page=<%=nextPage%>">下 一 页 </a><a href="List.jsp?page=<%=intPageCount%>">最后页</a></p><p>144、用 jdom解析xml 文件时如何解决中文问题?如何解析?<br>答:看如下代码,用编码方式加以解决<br>package test;<br>import java.io.*;<br>public class DOMTest<br>{</p><p>private String inFile = “c:\people.xml”;<br>private String outFile = “c:\people.xml”;<br>public static void main(String args[])<br>{</p><p>new DOMTest();</p><p>}<br>public DOMTest()<br>{</p><p>try<br>{<br>javax.xml.parsers.DocumentBuilder builder =</p><p>javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder();<br>org.w3c.dom.Document doc = builder.newDocument();<br>org.w3c.dom.Element root = doc.createElement(“老师”);<br>org.w3c.dom.Element wang = doc.createElement(“王”);</p><p>org.w3c.dom.Element liu = doc.createElement(“刘”);<br>wang.appendChild(doc.createTextNode(“我是王老师”));<br>root.appendChild(wang);<br>doc.appendChild(root);<br>javax.xml.transform.Transformer transformer =</p><p>javax.xml.transform.TransformerFactory.newInstance().newTransformer();<br>transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, “gb2312”);<br>transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, “yes”);</p><p>transformer.transform(new javax.xml.transform.dom.DOMSource(doc),<br>new</p><p>javax.xml.transform.stream.StreamResult(outFile));<br>}<br>catch (Exception e)<br>{<br>System.out.println (e.getMessage());<br>}<br>}<br>}</p><p>下面的程序代码输出的结果是多少？<br>public class smallT<br>{<br>public static void main(String args[])<br>{<br>smallT t = new smallT();<br>int b = t.get();<br>System.out.println(b);<br>}</p><pre><code>public int  get()
&#123;
    try
    &#123;
        return 1 ;
    &#125;
    finally
    &#123;
        return 2 ;
    &#125;
&#125;
</code></pre><p>}</p><p>返回的结果是2。<br>我可以通过下面一个例子程序来帮助我解释这个答案，从下面例子的运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。<br>在讲解答案时可以用下面的程序来帮助分析：<br>public class Test {</p><pre><code>/**
 * @param args add by zxx ,Dec 9, 2008
 */
public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    System.out.println(new Test().test());;
&#125;

int test()
&#123;
    try
    &#123;
        return func1();
    &#125;
    finally
    &#123;
        return func2();
    &#125;
&#125;

int func1()
&#123;
    System.out.println(&quot;func1&quot;);
    return 1;
&#125;
int func2()
&#123;
    System.out.println(&quot;func2&quot;);
    return 2;
&#125;    
</code></pre><p>}<br>———–执行结果—————–</p><p>func1<br>func2<br>2</p><p>结论：finally中的代码比return 和break语句后执行</p><p>1.写一段把本地文件formfile拷贝到本地文件tofile的程序<br>public class ChangeJtdToJava {<br>public static void main(String[] args) {<br>File dir = new File(“f:/jtd”);<br>// 得到d:/jtd 下的所有文件对象<br>File[] files = dir.listFiles();<br>for (File file : files) {<br>String fileName = file.getName(); // 得到文件名<br>int index = fileName.indexOf(“.”);// .的索引位置<br>String fileName2 = fileName.substring(0, index); // 不带后缀名的文件名<br>String houZui = fileName.substrinxg(index);<br>if (houZui.equals(“.jtd”)) {<br>// “f:/java/“ + fileName2 + “.java”<br>// 要移到的地方<br>file.renameTo(new File(“f:/java/“ + fileName2 + “.java”));<br>}<br>}<br>}<br>}</p><p>2.写出删除表中重复记录的语句 oracle<br>delete from people<br>where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) and rowid not in (select min(rowid) from people group by</p><p>3.JAVA实现向数据库添加一列<br>Connection con = null;<br>ResultSet rs = null;<br>Class.forName(“com.microsoft.jdbc.sqlserver.SQLServerDriver”);<br>String url=”jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=db_name”;<br>Connection con = DriverManager.getConnection(url,””,””);<br>StateManager sm =con.createStateMent();<br>String sql = “ alter table student add age int; “;<br>rs = sm.excute(sql);</p><p>4.写出删除表中重复记录的语句 oracle<br>delete from people<br>where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) and rowid not in (select min(rowid) from people group</p><p>5.用4 个0，用你所知道的数学方法计算出24<br>0的阶乘等于1 即 0！＝１那么４个0就是４了<br>又4的阶乘为２４ ４！＝２４</p><p>6.手写个程序在本页面中心弹出一个窗体，里面有学生的成绩，可以修改学生的成绩，并且可以关闭窗口，把每个要用的jsp页面显示出来。（用 JavaScript）<br>到显示页面的ShowStudentServlet<br>public void doGet(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>request.setCharacterEncoding(“gbk”);<br>response.setCharacterEncoding(“gbk”);<br>response.setContentType(“text/html”);<br>StudentDao dao=new StudentDao();<br>List<student>sts=dao.stlist();<br>request.setAttribute(“sts”, sts);<br>request.getRequestDispatcher(“/showStu.jsp”).forward(request, response);<br>}<br>学生成绩的显示页面：showStu.jsp</student></p><table><tr><th>学号</th><th>姓名</th><th>成绩</th><th>修改</th></tr><c:foreach items="${sts}" var="st"><tr><td>${st.sid}</td><td>${st.name}</td><td>${st.score}</td><td><button onclick='window.showModalDialog("UpdateStudentServlet?sid=${st.sid }&rand="+Math.random()),location.reload()'>修改</button></td></tr></c:foreach></table>请求修改的UpdateStudentServlet public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding("gbk"); response.setCharacterEncoding("gbk"); response.setContentType("text/html"); String s=request.getParameter("sid"); if(s!=null&&!s.equals("")){ StudentDao dao=new StudentDao(); Integer sid=Integer.parseInt(s); Student st=dao.findById(sid); request.setAttribute("st", st); request.getRequestDispatcher("/updateStu.jsp").forward(request, response); }else{ throw new ServletException("需要传递一个名为sid的int类型参数"); } } 可以修改成绩的页面:updateStu.jsp<base href="<%=basePath%>" target="_self"><form action="UpdateScoreServlet" method="post"><table><tr><th>编号</th><td><input type="text" name="sid" value="${st.sid }" readonly></td></tr><tr><th>姓名</th><td><input type="text" name="name" value="${st.name }" readonly></td></tr><tr><th>分数</th><td><input type="text" name="score" value="${st.score }"></td></tr><tr><td colspan="2"><input type="submit" value="修改"></td></tr></table></form>负责修改成绩的UpdateScoreServlet public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<pre><code>    request.setCharacterEncoding(&quot;gbk&quot;);
    response.setCharacterEncoding(&quot;gbk&quot;);
    response.setContentType(&quot;text/html&quot;);
    String sid=request.getParameter(&quot;sid&quot;);
    String score=request.getParameter(&quot;score&quot;);
    if(sid!=null&amp;&amp;!sid.equals(&quot;&quot;)&amp;&amp;score!=null&amp;&amp;!&quot;&quot;.equals(score))&#123;
        StudentDao dao=new StudentDao();
        Student st=new Student();
        st.setSid(Integer.parseInt(sid));
        st.setScore(Double.parseDouble(score));
        dao.update(st);
        response.getWriter().println(&quot;&lt;script type=&#39;text/javascript&#39;&gt;alert(&#39;修改成功&#39;);window.close();&lt;/script&gt;&quot;);
    &#125;
&#125;
</code></pre><p>7.用main涵数输出一到一百的和。<br>#include &lt;stdio.h&gt;<br>int main() {<br>printf(“sum:%d\n”, sum());<br>return 0;<br>}</p><p>int sum() {<br>int i;<br>int sum = 0;<br>for (i = 1; i &lt;= 100; i++)<br>sum += i;<br>return sum;<br>}<br>8.在main方法中将字符串中的。数字排序并输出 STRING A=”56.89.5.3.75.98.98.26.15.44”</p><p>String s=” 56.89.5.3.75.98.98.26.15.44”;<br>String s1[]=s. split (“.”);<br>Integer ii[]=new Integer[s1.length];<br>For(int i=0;i&lt;s1.length;i++){<br>ii[i]=Integer.parseInt(s1[i]);<br>}<br>Arrays.sort(ii);<br>for(Integer o: ii){<br>System.out.println(o+” s”);<br>}</p><p>9.用一个方法查出宜个数值类型数组的最大值，用递归方式实现<br>方法1<br>public class Test1 {<br>public static int a(int[] i,int j){<br>if(i.length-1&gt;j){<br>if(i[j]&gt;i[j+1]){<br>i[j+1]=i[j];<br>}<br>return a(i,j+1);<br>}else{<br>return i[i.length-1];<br>}<br>}</p><p>}<br>方法2 – 非递归<br>public static int test(int []num) { int x=0; int log = num.Length;for(intt=0;t&lt;log;t++){ if(num[t]&gt;x){ x=num[t]; } }return x;}</p><p>方法3 — 递归 不改变原数组中的元素<br>public static int getMax(int[]a, int index,int max){<br>int len = a.length;<br>if(len==1){<br>return a[len-1];<br>}<br>if(index==0){<br>max = a[index];<br>}<br>if(index==len){<br>return max;<br>}<br>if(max&lt;a[index]){<br>max = a[index];<br>}<br>index++;<br>return getMax(a,index,max);<br>}<br>// 测试<br>int max = getMax(new int[]{2,5,18,3,38,10,2},0,0);<br>System.out.println(max);</p><p>10.设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。<br>public class ThreadTest1{   <br>private int j;   <br>public static void main(String args[]){   <br>ThreadTest1 tt=new ThreadTest1(); <br>Inc inc=tt.new Inc();   Dec dec=tt.new Dec();   <br>for(int i=0;i &lt;2;i++){   <br>Thread t=new Thread(inc);   <br>t.start();   <br>t=new Thread(dec);  //???这个前面不要加Thread吗<br>t.start();   <br>}   <br>}   <br>private synchronized void inc(){  //???为什么要加锁呢 不加可以吗 <br>j++;   <br>System.out.println(Thread.currentThread().getName()+”-inc:”+j);   <br>}                      //???currentThread()有什么作用呢是什么方法<br>                            //???getname呢<br>private synchronized void dec(){   <br>j–;   <br>System.out.println(Thread.currentThread().getName()+”-dec:”+j);   <br>}   <br>class Inc implements Runnable{   <br>public void run(){   <br>for(int i=0;i &lt;100;i++){   <br>inc();   <br>}   <br>}   <br>}   <br>class Dec implements Runnable{   <br>public void run(){   <br>for(int i=0;i &lt;100;i++){   <br>dec();    }    }    }    }</p><p>11.定义两个变量a和b，不使用第三个变量，使两个值交换<br>public class testMain {<br>public void test(int a,int b){<br>System.out.println(“交换前a = “+a);<br>System.out.println(“交换前b = “+b);</p><pre><code>    a=a+b;
    b=a-b;
    a=a-b;
    
   System.out.println(&quot;交换后a = &quot; +a);
   System.out.print(&quot;交换后b = &quot;+b);
&#125;
public static void main(String args[])&#123;        
    new testMain().test(10,13);
&#125;
</code></pre><p>}<br>12.题目：JS树形菜单<br>&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;<br>&lt;%<br>String path = request.getContextPath();<br>String basePath = request.getScheme()+”://“+request.getServerName()+”:”+request.getServerPort()+path+”/“;<br>%&gt;</p><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><base href="<%=basePath%>"><pre><code>&lt;title&gt;My JSP &#39;scriptTree.jsp&#39; starting page&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
   function fun1()&#123;
     window.showModalDialog(&quot;$&#123;pageContext.request.contextPath&#125;/user.do?method=login&quot;,&quot;700&quot;);
     window.dialogHeight=800;
   &#125;
   function fun(isd)&#123;
   
      var tabIds=document.getElementById(isd); 
      
      if(tabIds.style.display==&#39;none&#39;)&#123;
         tabIds.style.display=&#39;inline&#39;;
      &#125;else&#123;
         tabIds.style.display=&#39;none&#39;;
      &#125;
   &#125;
&lt;/script&gt;
</code></pre></head><body><table border="2" bordercolor="green" width="75%"><tr><td onclick='fun("tableId1")'>树型菜单</td><td>菜单名称</td></tr><tr><td colspan="2"><table id="tableId1" border="2" bordercolor="red"><tr style="display:inline"><td>kongjian</td></tr><tr style="display:inline"><td><a href="">xiaoxin</a></td></tr></table></td></tr></table></body></html><p>13.将字符串str（例：”abcrepefd”）中的”rep”部分替换成”with”字符串(不能用jdk自带的replace方法)<br>答案如下:<br>public void replace(String str,String rep,String with){<br>try{<br>int i = str.indexOf(rep);<br>String s1 = str.substring(0, i);<br>String s2 = str.substring(i, rep.length()+i);<br>String s3 = str.substring(rep.length()+i, str.length());<br>s2 = with;<br>String mes = s1+s2+s3;<br>System.out.println(“替换前：”+str);<br>System.out.println(“替换后：”+mes);<br>}catch(Exception e){<br>System.out.println(“字符串”+str+”中不含有”+rep+”字符串！”);<br>}<br>}</p><p>14.Java Reflection是什么？<br>答：<br>1.JAVA反射，Reflection是Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说”自审”，并能直接操作程序的内部属性。例如，使用它能获得 Java 类中各成员的名称并显示出来;<br>2.一个简单的例子<br>import java.lang.reflect.*;<br>public class DumpMethods {<br>   public static void main(String args[]) {<br>try {<br>Class c = Class.forName(args[0]);<br>Method m[] = c.getDeclaredMethods();<br>for (int i = 0; i &lt; m.length; i++)<br>System.out.println(m.toString());<br>}<br>catch (Throwable e) {<br>System.err.println(e);<br>}<br>}}</p><p>15.1到11相加是奇数还是偶数?<br>偶数</p><p>16.一个圆上有6个点，可以连多少条直线？<br>15条线段</p><p>17.Stack堆栈，实现进栈，出栈<br>package t1;<br>public class mystack {<br>private Object[] data;<br>private int top=-1;<br>private int size;<br>public mystack()<br>{<br>data=new Object[5];<br>size=5;<br>}<br>public mystack(int size)<br>{<br>data=new Object[size];<br>this.size=size;<br>}<br>public void push(Object obj)<br>{<br>if(this.isfull())<br>{<br>return ;<br>}<br>top++;<br>data[top]=obj;<br>}<br>public Object pop() {<br>if(this.isempty())<br>{<br>return null;<br>}<br>Object obj=data[top];<br>top–;<br>return obj ;<br>}</p><pre><code>public boolean isfull()
&#123;
    if(top==data.length)
    &#123;
        return true;
    &#125;
    else
    &#123;
        return false;
    &#125;
&#125;
public boolean isempty()
&#123;
    if(top==-1)
    &#123;
        return true;
    &#125;
    else
    &#123;
        return false;
    &#125;
&#125;
</code></pre><p>}</p><p>18.每周的工作效率要提高24％，每周工作6天，那么每天工作效率要提高多少？（6％，4%,24%）<br>答：24%</p><p>19..前一天是星期一，又是第二个工作日，那么今天是星期几？<br>答：星期三</p><p>20.一个字符串中可能存在A-Z的全角字符，写一个方法把里面的全角字符转变成半角字符？<br>答：采用建立字典表进行查找转换<br>public  static String translate(String s){<br>        String qj = “ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ”;<br>        String bj = “ABCDEFGHIJKLMNOPQRSTUVWXYZ”;<br>        StringBuffer sb = new StringBuffer();<br>        for(int i=0;i&lt;s.length();i++){<br>            char c = s.charAt(i);<br>            int pos = qj.indexOf(c);<br>            if(pos&gt;=0){<br>                System.out.println(c + “,” + pos);<br>                sb.append(bj.charAt(pos));<br>            }else{<br>                sb.append(c);<br>            }<br>        }<br>        return sb.toString();<br>    }</p><p>21.写一个方法，传入一个int 型的数字，把它的四个字节码取出来，并且把它按大小顺序通过控制台输出？<br>public static void main(String[] args) {<br>        int num = -800000000;<br>        String str = Integer.toBinaryString(num); //获得num 的二进制 <br>        if(num&gt;=0) {    //如果输入的数为正数,位数可能不足32位，要补0；负数肯定是32位<br>            if(str.length()&lt;32) { //二进制不足32位，就在前面补0<br>                int n0 = 32-str.length(); //看差几个0<br>                String temp = “”;<br>                for(int i=0;i&lt;n0;i++) {<br>                    temp = temp + “0”; //拼0<br>                }<br>                str = temp + str;<br>            }<br>        }<br>        String s1 = str.substring(0, 8);<br>        String s2 = str.substring(8, 16);<br>        String s3 = str.substring(16, 24);<br>        String s4 = str.substring(24, 32);<br>        <br>        System.out.println(str);<br>        System.out.println(s1);<br>        System.out.println(s2);<br>        System.out.println(s3);<br>        System.out.println(s4);<br>        <br>        <br>        int n1=Integer.parseInt(s1,2);//以二进制把字符串解析为 10进制的数<br>        int n2=Integer.parseInt(s2,2);<br>        int n3=Integer.parseInt(s3,2);<br>        int n4=Integer.parseInt(s4,2);<br>        System.out.println(n1);<br>        System.out.println(n2);<br>        System.out.println(n3);<br>        System.out.println(n4);        //整数大小自己比较吧</p><p>    }</p><p>22.编程题:有一个数据文件:123 34 17 651234 345….这些数据都是随机产生的,编写程序读出该文件.并将其以从大到小的顺序输出到另一个文件中.<br>public void readtext(){<br>File file = new File(“D:\test.txt”);<br>List list= new ArrayList();<br>try {<br>BufferedReader br=new BufferedReader(new FileReader(file));<br>String data = “”;<br>String line = null;<br>while ( (line = br.readLine()) != null) {<br>data = data.concat(line);<br>}<br>StringTokenizer stoken = new StringTokenizer(data, “ “);<br>while (stoken.hasMoreTokens()) {<br>int i = Integer.parseInt(stoken.nextToken());<br>list.add(i);<br>}<br>} catch(Exception ex) {}<br>String[] str = new String[list.size()];<br>for(int i=0;i&lt;list.size();i++){<br>str[i]=list.get(i);<br>}<br>Object iTemp= null;<br>for(int i=1;i&lt;list.size();i++) {<br>　　 for(int j=list.size()-1;j&gt;=i;j–) {<br>　　 if(str[j]&gt;str[j-1]) {<br>　　 iTemp = str[j-1];<br>　　 str[j-1] = str[j];<br>　　 str[j] = iTemp;<br>　　 }<br>}<br>String result = “”;<br>for(int i=0;i&lt;str.length;i++){<br>result +=str[i]+” “;<br>}<br>//将result写入另外一个文件即可。<br>}</p><p>23.从一到十九共十九个数,打印出利用这十九个整数任意多个相加等于20所以可能性,每个数字在同一个算式中只出现一次.<br>public void test(){<br>Integer[] a = new Integer[19];<br>for(int i=1;i&lt;20;i++){<br>a[i-1]=i;<br>}<br>for(int i=0;i&lt;18;i++){<br>for(int j=18-i;j&lt;18;j++)<br>if(a[i]+a[j]==20)<br>System.out.println(a[i]+”+”+a[i+1]+”=”+20);<br>}<br>}<br>24.哪几个方法可以实现一个线程？<br>一种是声明 Thread 的子类,重载 Thread 类的方法 run。 另一种途径是声明一个类，该类实现 Runnable 接口。然后再实现方法 run。</p><p>25.//编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。<br>//但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6应该输出为“我ABC”而不是“我ABC+汉的半个”。</p><pre><code>
public static void main(String[] args) throws Exception&#123;
        String str = &quot;我a爱中华abc def&#39;;
        String str = &quot;我ABC汉&quot;;
        int num = trimGBK(str.getBytes(&quot;GBK&quot;),5);
        System.out.println(str.substring(0,num) );
    &#125;
    
    public static int  trimGBK(byte[] buf,int n)&#123;
        int num = 0;
        boolean bChineseFirstHalf = false;
        for(int i=0;i&lt;n;i++)
        &#123;
            if(buf[i]&lt;0 &amp;&amp; !bChineseFirstHalf)&#123;
                bChineseFirstHalf = true;
            &#125;else&#123;
                num++;
                bChineseFirstHalf = false;                
            &#125;
        &#125;
        return num;
    &#125;
</code></pre><p>26.java程序每天12点打印”hello”<br>public static void main(String[] args) {<br>Date date = new Date();<br>System.out.println(date.getHours());<br>while (true) {<br>while (date.getHours() == 12) {<br>if (date.getMinutes() == 0) {<br>if (date.getSeconds() == 0) {<br>System.out.println(“hello world!”);<br>}<br>}<br>}<br>}<br>}</p><p>27.编程题：读取一个文件在控制台打印出来<br>File file = new File(“E:\课件\二期课件\Java\T09 src\JRadioButtonDemo.java”);<br>long file_length= file.length();<br>try {<br>//输入流<br>FileInputStream input = new FileInputStream(file);<br>byte b_data [] = new byte[(int)file_length];<br>input.read(b_data);<br>System.out.println(new String(b_data));<br>input.close();<br>} catch (FileNotFoundException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (IOException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>}</p><p>28.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?<br>　也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果：<br>public class Test {<br>public static void main(String[] args) {<br>// TODO Auto-generated method stub<br>System.out.println(new Test().test());;<br>}<br>static int test()<br>{<br>int x = 1;<br>try<br>{<br>return x;<br>}<br>finally<br>{<br>++x;<br>}<br>}</p><p>}</p><p>———执行结果 ———<br>1</p><p>运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。<br>29.有一些奇数和偶数，无序的，要求写一个方法，实现将所有的奇数放在全部的偶数前面<br>主要代码如下：主要采用快速排序的算法。<br>int[] n = {1,2,5,6,4,7,10,9,3,8};<br>int m = n[0];<br>int j = n.length -1;<br>int i= 0;<br>while(i&lt;j){<br>while(i&lt;j &amp;&amp; n[j]%2==0){j–;}<br>if(j&gt;=i){<br>n[i++] = n[j];<br>}</p><pre><code>       while(i&lt;j &amp;&amp; n[i]%2!=0)&#123;i++;&#125;
       if(i&lt;=j)&#123;
           n[j--] = n[i];
       &#125;           
   &#125;
   n[i] = m;

   for(int k=0;k&lt;n.length;k++)&#123;
     System.out.print(n[k] + &quot;  &quot;);   
   &#125;
</code></pre></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/ff5236f93fe2.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/ff5236f93fe2.html" class="post-title-link" itemprop="url">项目设计</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:33:24 / 修改时间：16:15:51" itemprop="dateCreated datePublished" datetime="2023-12-20T15:33:24+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">项目设计</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="积分系统设计"><a href="#积分系统设计" class="headerlink" title="积分系统设计"></a>积分系统设计</h1><p>本文就其中一个问题：设计一个电商平台的积分兑换系统，来详细阐述一下。文中会详细指出在系统设计的时候要考虑哪些要点，给大家展示出来这类问题思考的一个过程。</p><p>2、业务需求的描述<br>假设面试官现在给出来对于这个电商平台的积分兑换系统的相关需求如下：<br>用户在电商平台里平时通过购买商品、晒单评论可以有不断的积累积分积累到足够的积分后，就可以在电商平台的积分兑换页面中，选择使用自己的积分来兑换一些礼品</p><p>需求其实就这么简单，那么面试官说了，针对这个业务场景给出你对这个机制实现的思考过程以及这里要注意的一些地方。</p><p>3、对业务流程的思考<br>如何思考？首先，用户不停的购买商品以及晒单评论，会不断的获取积分，那么是不是需要一张积分表，专门用来存储每个用户的积分呢？没错，这个表是一定需要的，可以现场给出下述的表结构。</p><p>积分表：</p><p>id（自增id主键）<br>user_id（用户id）<br>credit（积分）<br>继续来看，假设在积分兑换页面，用户选择用自己的20000积分兑换一瓶洗发水，后台的逻辑应该如何设计呢？</p><p>这个也是必须得现场给出一个思考过程的，这个其实看起来简单，但是很多年纪较轻，经验不足的朋友，可能没法快速思考出来。</p><p>首先你要用20000积分去进行兑换，那么一定是必须要在积分表里扣减掉这20000积分的吧？所以在流程设计中，首先就得有一个20000积分扣减的过程。</p><p>其次，你用这20000积分兑换了什么东西呢？</p><p>所以你是不是还需要一张单独的表，叫做积分兑换记录表，记录下来你这个用户本次用多少积分兑换了一件什么商品？</p><p>这个积分兑换记录表的结构如下所示，你是不是需要在下面的那个表里插入一条记录，说这个用户本次用多少积分兑换了哪个商品？</p><p>积分兑换表：<br>id（自增id主键）<br>user_id（用户id）<br>exchanged_credit（用于兑换的积分）<br>product_id（兑换的商品id）<br>最后，光是插入上述那条积分兑换记录是不够的，你必须得调用仓储业务模块的接口，通知仓储业务模块新增一条发货申请，而且应该是积分兑换对应的发货申请，这样保证仓库可以准备对应的商品进行发货。</p><p>这个发货申请大致对应如下的表结构：</p><p>发货申请表：<br>id（自增id主键）<br>type（发货类型，1：购买，2：积分兑换）<br>credit_exchange_id（积分兑换表的id）<br>product_id（要发货的商品id）<br>其实这里的发货申请表简化了很多，按理说还得有发货商品的数量等等字段，但是这里可以简化处理也没事，毕竟是面试现场。</p><p>简单画出来这个流程大致如下所示。</p><p>4、物流配送进度查询，考虑到了吗？</p><p>如果把上面那整个业务流程给面试官说了，就完事了吗？<br>当然不是！<br>你可以站在用户的角度考虑一下，你是不是肯定还需要查看积分兑换的记录？这个在积分兑换表里可以查看到你用多少积分兑换了什么商品。<br>但是你兑换商品的物流配送进度，能查看到吗？不能。所以你应该在业务流程里再考虑进去对应的物流配送的逻辑。</p><p>通常来说一个基本的逻辑，就是在生产发货申请单的时候，需要调用第三方物流公司的接口申请一个物流单，这样仓库管理员打包准备好商品，坐等物流公司商品收快递就可以了。</p><p>物流公司会根据物流单去进行配送，这个配送地址当然是用户自己在电商平台选择的自己的某个地址。</p><p>此时发货申请单的表结构是不是如下所示？</p><p>发货申请表：<br>id（自增id主键）<br>type（发货类型，1：购买，2：积分兑换）<br>credit_exchange_id（积分兑换表的id）<br>product_id（要发货的商品id）<br>express_no（物流单号）</p><p>所以在生产发货申请单时，先得调用第三方物流公司的接口申请一个物流单，这样发货申请单中是有一个物流单号的，而且每个积分兑换记录都通过id跟发货申请单关联起来。</p><p>这样在页面上对每个兑换记录，是不是可以找到发货申请单中的物流单号，然后根据物流单号调用第三方物流公司的接口，去获取配送的进度？</p><p>这就是一个非常典型的业务系统的技术实现的逻辑思考，一个经验丰富合格的工程师，往往都具备了一定的业务思维，可以很好的根据业务系统中的用户逻辑来考虑，反推自己的系统技术实现逻辑。</p><p>上述整个过程，如下图所示：</p><p>5、事务的保证<br>业务流程整个捋顺之后，接下来就涉及到技术的考虑了。你得考虑一下，这种业务系统里怎么能没有事务呢？</p><p>扣减积分、新增积分兑换记录、新增发货申请单，这三个步骤必须是要么一起完成，要么一起失败的。也就是说，这三个步骤必须是在一个事务里的。</p><p>现在有一个问题，对一个电商平台自身的业务系统来说，仅仅包含积分服务。但是仓储服务一般是独立部署的一套系统，或者是一个独立的服务。</p><p>也就是说，扣减积分和新增积分兑换记录可以在一个服务里是一个事务，但是新增发货申请单，他是在另外一个服务里的，这个事务如何保证呢？</p><p>有朋友可能马上回答：用分布式事务啊！先别急，咱们可以先用最简单的模式来实现一下。</p><p>比如积分服务在一个事务代码块中，先执行扣减积分、新增积分兑换记录两个步骤。</p><p>然后记住，在事务代码块中，最后一步调用仓储服务的接口，如果接口调用成功，那么就可以提交事务了。如果接口调用失败，那么就抛异常让事务回滚，这样可以不可以？</p><p>这个流程如下所示：</p><p>        积分服务 事务 {<br>               -&gt; 扣减积分<br>               -&gt; 新增积分兑换记录<br>            -&gt; 调用仓储服务<br>        }</p><p>6、消息中间件的引入<br>上述设计其实理论上是没问题的，但是这里你忽略了一个问题，在这个业务场景中，积分服务是没有必要同步调用仓储服务的。</p><p>因为积分兑换是一个用户执行的操作，假设你的仓储服务在生成发货申请单的时候调用第三方物流公司的接口，被卡住了，或者失败了，怎么办？</p><p>此时可能导致用户在页面上看到积分兑换按钮点击之后，卡在那儿可能几十秒都无法执行成功，所以这个系统如此设计是错误的。</p><p>那应该怎么做呢？你必须得在这里引入消息中间件进行异步化的解耦，保证用户点击积分兑换按钮之后，尽快返回。如下图所示：</p><p>7、重试机制的引入<br>到这里就OK了吗？还没呢！</p><p>一旦引入消息中间件之后，好处是用户点击积分兑换按钮，直接就是在积分服务里扣减积分以及新增积分兑换记录，然后发送一条消息到消息中间件里就结束了，速度很快，保证了用户体验。</p><p>但是坏处就是，万一仓储服务执行新增发货申请失败了怎么办？</p><p>这个时候就需要引入可靠消息服务了，他需要去保证仓储服务一定会完成新增发货申请这个事。</p><p>具体的流程如下：</p><p>积分服务发送消息给可靠消息服务，可靠消息服务在消息表中新增记录，然后发送消息到MQ（消息中间件）</p><p>然后仓储服务消费消息新增发货申请单，如果成功就回调可靠消息服务的一个接口说自己成功了，可靠消息服务就可以更新本地消息表中的记录状态为成功</p><p>如果仓储服务长时间没通知可靠消息服务自己成功了，可靠消息服务不停的重试再次发送消息</p><p>通过这样的设计，就可以保证可靠消息服务一定会无限次重试保证让仓储服务成功执行。再加上重试机制后，整个流程图如下所示：</p><p>8、引入幂等性机制<br>最后一个问题，如果仓储服务卡在第三方物流系统申请物流单的环节，长时间阻塞，所以没回调通知可靠消息服务。</p><p>但是可靠消息服务过了一段时间，感觉没收到回调通知，就自己重试发送了消息，这样岂不是会让仓储服务新增两条发货申请单？</p><p>因此我们还要保证仓储服务新增发货申请单的幂等性，其实也非常简单，回顾一下发货申请单表的结构：</p><p>发货申请表：<br>id（自增id主键）<br>type（发货类型，1：购买，2：积分兑换）<br>credit_exchange_id（积分兑换表的id）<br>product_id（要发货的商品id）<br>express_no（物流单号）</p><p>只要在“credit_exchange_id”字段上建立一个唯一索引就可以了，保证每个积分兑换记录只能创建一条发货申请单，如果重复创建就会被唯一索引被阻止，这样就可以保证这个行为的幂等性了。</p><p>至此，对这道系统设计题目的回答，全部结束。</p><h1 id="秒杀业务的流量削峰场景如何解决？"><a href="#秒杀业务的流量削峰场景如何解决？" class="headerlink" title="秒杀业务的流量削峰场景如何解决？"></a>秒杀业务的流量削峰场景如何解决？</h1><p>流量削峰的由来<br>主要是还是来自于互联网的业务场景，例如，马上即将开始的春节火车票抢购，大量的用户需要同一时间去抢购；以及大家熟知的阿里双11秒杀，<br>短时间上亿的用户涌入，瞬间流量巨大（高并发），比如：200万人准备在凌晨12:00准备抢购一件商品，但是商品的数量缺是有限的100-500件左右。<br>这样真实能购买到该件商品的用户也只有几百人左右， 但是从业务上来说，秒杀活动是希望更多的人来参与，也就是抢购之前希望有越来越多的人来看购买商品。<br>但是，在抢购时间达到后，用户开始真正下单时，秒杀的服务器后端缺不希望同时有几百万人同时发起抢购请求。<br>我们都知道服务器的处理资源是有限的，所以出现峰值的时候，很容易导致服务器宕机，用户无法访问的情况出现。<br>这就好比出行的时候存在早高峰和晚高峰的问题，为了解决这个问题，出行就有了错峰限行的解决方案。<br>同理，在线上的秒杀等业务场景，也需要类似的解决方案，需要平安度过同时抢购带来的流量峰值的问题，这就是流量削峰的由来。<br>怎样来实现流量削峰方案<br>削峰从本质上来说就是更多地延缓用户请求，以及层层过滤用户的访问需求，遵从“最后落地到数据库的请求数要尽量少”的原则。<br>1.消息队列解决削峰<br>要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。</p><p>消息队列中间件主要解决应用耦合，异步消息， 流量削锋等问题。常用消息队列系统：目前在生产环境，使用较多的消息队列有 ActiveMQ、RabbitMQ、 ZeroMQ、Kafka、MetaMQ、RocketMQ 等。<br>在这里，消息队列就像“水库”一样，拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。<br>具体的消息队列MQ选型和应用场景可以参考(点击查看)：高并发架构系列：分布式之消息队列的特点、选型、及应用场景详解<br>2.流量削峰漏斗：层层削峰<br>针对秒杀场景还有一种方法，就是对请求进行分层过滤，从而过滤掉一些无效的请求。<br>分层过滤其实就是采用“漏斗”式设计来处理请求的，如下图所示：</p><p>这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。<br>1、分层过滤的核心思想<br>通过在不同的层次尽可能地过滤掉无效请求。<br>通过CDN过滤掉大量的图片，静态资源的请求。<br>再通过类似Redis这样的分布式缓存，过滤请求等就是典型的在上游拦截读请求。<br>2、分层过滤的基本原则<br>对写数据进行基于时间的合理分片，过滤掉过期的失效请求。<br>对写请求做限流保护，将超出系统承载能力的请求过滤掉。<br>涉及到的读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题。<br>对写数据进行强一致性校验，只保留最后有效的数据。<br>最终，让“漏斗”最末端(数据库)的才是有效请求。例如：当用户真实达到订单和支付的流程，这个是需要数据强一致性的。<br>流量削峰总结<br>1.对于秒杀这样的高并发场景业务，最基本的原则就是将请求拦截在系统上游，降低下游压力。如果不在前端拦截很可能造成数据库(mysql、oracle等)读写锁冲突，甚至导致死锁，最终还有可能出现雪崩等场景。<br>2.划分好动静资源，静态资源使用CDN进行服务分发。<br>3.充分利用缓存(redis等)：增加QPS，从而加大整个集群的吞吐量。<br>4.高峰值流量是压垮系统很重要的原因，所以需要Kafka等消息队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。</p><h1 id="如何设计一个百万级用户的抽奖系统？"><a href="#如何设计一个百万级用户的抽奖系统？" class="headerlink" title="如何设计一个百万级用户的抽奖系统？"></a>如何设计一个百万级用户的抽奖系统？</h1><p>目录 <br>1.抽奖系统的背景引入    <br>2.结合具体业务需求分析抽奖系统    <br>3.一个未经过优化的系统架构    <br>4.负载均衡层的限流    <br>5.Tomcat线程数量的优化    <br>6.基于Redis实现抽奖业务逻辑    <br>7.发放礼品环节进行限流削峰    <br>8.系统架构设计总结    </p><p>1、抽奖系统的背景引入<br>本文给大家分享一个之前经历过的抽奖系统的流量削峰架构的设计方案。</p><p>抽奖、抢红包、秒杀，这类系统其实都有一些共同的特点，那就是在某个时间点会瞬间涌入大量的人来点击系统，给系统造成瞬间高于平时百倍、千倍甚至几十万倍的流量压力。</p><p>比如抽奖，有一种场景：某个网站或者APP规定好了在某个时间点，所有人都可以参与抽奖，那么可能百万级的用户会蹲守在那个时间点，到时间大家一起参与这个抽奖。</p><p>抢红包，可能是某个电视节目上，突然说扫码可以抢红包，那么电视机前可能千万级的用户会瞬间一起打开手机扫码抢红包。</p><p>秒杀更是如此，所谓秒杀，意思是让大家都在电脑前等着，在某个时间突然就可以抢购某个限量的商品</p><p>比如某个手机平时卖5999，现在限量100台价格才2999，50%的折扣，可能百万级的用户就会蹲守在电脑前在比如凌晨12点一起点击按钮抢购这款手机。</p><p>类似的场景其实现在是很多的，那么本文就用一个抽奖系统举例，说说应对这种瞬时超高并发的流量，应该如何设计流量削峰的架构来应对，才能保证系统不会突然跨掉？</p><p>2、结合具体业务需求分析抽奖系统<br>假设现在有一个抽奖的业务场景，用户在某个时间可以参与抽奖，比如一共有1万个奖，奖品就是某个礼物。</p><p>然后参与抽奖的用户可能有几十万，一瞬间可能几十万请求涌入过来，接着瞬间其中1万人中奖了，剩余的人都是没中奖的。然后中奖的1万人的请求会联动调用礼品服务，完成这1万中奖人的礼品发放。</p><p>简单来说，需求场景就是如此，然而这里就有很多的地方值得优化了。</p><p>3、一个未经过优化的系统架构<br>先来看一个未经过任何优化的系统架构，简单来说就是有一个负载均衡的设备会把瞬间涌入的超高并发的流量转发到后台的抽奖服务上。</p><p>这个抽奖服务就是用普通的Tomcat来部署的，里面实现了具体的抽奖逻辑，假设刚开始最常规的抽奖逻辑是基于MySQL来实现的，接着就是基于Tomcat部署的礼品服务，抽奖服务如果发现中奖了需要调用礼品服务去发放礼品。</p><p>如下图所示：</p><p>4、负载均衡层的限流</p><p>4.1 防止用户重复抽奖<br>首先第一次在负载均衡层可以做的事情，就是防止重复抽奖。</p><p>我们可以在负载均衡设备中做一些配置，判断如果同一个用户在1分钟之内多次发送请求来进行抽奖，就认为是恶意重复抽奖，或者是他们自己写的脚本在刷奖，这种流量一律认为是无效流量，在负载均衡设备那个层次就给直接屏蔽掉。</p><p>举个例子，比如有几十万用户瞬间同时抽奖，最多其实也就几十万请求而已，但是如果有人重复抽奖或者是写脚本刷奖，那可能瞬间涌入的是几百万的请求，就不是几十万的请求了，所以这里就可以把无效流量给拦截掉。</p><p>如下图所示：</p><p>4.2 全部开奖后暴力拦截流量<br>其实秒杀、抢红包、抽奖，这类系统有一个共同的特点，那就是假设有50万请求涌入进来，可能前5万请求就直接把事儿干完了，甚至是前500请求就把事儿干完了，后续的几十万流量是无效的，不需要让他们进入后台系统执行业务逻辑了。</p><p>什么意思呢？</p><p>举个例子，秒杀商品，假设有50万人抢一个特价手机，人家就准备了100台手机，那么50万请求瞬间涌入，其实前500个请求就把手机抢完了，后续的几十万请求没必要让他转发到Tomcat服务中去执行秒杀业务逻辑了，不是吗？</p><p>抽奖、红包都是一样的 ，可能50万请求涌入，但是前1万个请求就把奖品都抽完了，或者把红包都抢完了，后续的流量其实已经不需要放到Tomcat抽奖服务上去了，直接暴力拦截返回抽奖结束就可以了。</p><p>这样的话，其实在负载均衡这一层（可以考虑用Nginx之类的来实现）就可以拦截掉99%的无效流量。</p><p>所以必须让抽奖服务跟负载均衡之间有一个状态共享的机制。</p><p>就是说抽奖服务一旦全部开奖完毕，直接更新一个共享状态。然后负载均衡感知到了之后，后续请求全部拦截掉返回一个抽奖结束的标识就可以了。</p><p>这么做可能就会做到50万人一起请求，结果就可能2万请求到了后台的Tomcat抽奖服务中，48万请求直接拦截掉了。</p><p>我们可以基于Redis来实现这种共享抽奖状态，它非常轻量级，很适合两个层次的系统的共享访问。</p><p>当然其实用ZooKeeper也是可以的，在负载均衡层可以基于zk客户端监听某个znode节点状态。一旦抽奖结束，抽奖服务更新zk状态，负载均衡层会感知到。</p><p>下图展示了上述所说的过程：</p><p>5、Tomcat线程数量的优化<br>其次就是对于线上生产环境的Tomcat，有一个至关重要的参数是需要根据自己的情况调节好的，那就是他的工作线程数量。</p><p>众所周知，对于进入Tomcat的每个请求，其实都会交给一个独立的工作线程来进行处理，那么Tomcat有多少线程，就决定了并发请求处理的能力。</p><p>但是这个线程数量是需要经过压测来进行判断的，因为每个线程都会处理一个请求，这个请求又需要访问数据库之类的外部系统，所以不是每个系统的参数都可以一样的，需要自己对系统进行压测。</p><p>但是给一个经验值的话，Tomcat的线程数量不宜过多。因为线程过多，普通虚拟机的CPU是扛不住的，反而会导致机器CPU负载过高，最终崩溃。</p><p>同时，Tomcat的线程数量也不宜太少，因为如果就100个线程，那么会导致无法充分利用Tomcat的线程资源和机器的CPU资源。</p><p>所以一般来说，Tomcat线程数量在200~500之间都是可以的，但是具体多少需要自己压测一下，不断的调节参数，看具体的CPU负载以及线程执行请求的一个效率。</p><p>在CPU负载尚可，以及请求执行性能正常的情况下，尽可能提高一些线程数量。</p><p>但是如果到一个临界值，发现机器负载过高，而且线程处理请求的速度开始下降，说明这台机扛不住这么多线程并发执行处理请求了，此时就不能继续上调线程数量了。</p><p>6、基于Redis实现抽奖业务逻辑<br>现在问题又来了，虽然在负载均衡那个层面，已经把比如50万流量中的48万都拦截掉了，但是可能还是会有2万流量进入抽奖服务</p><p>此时抽奖服务自然是可以多机器来部署的，比如假设一台Tomcat可以抗500请求，那么2万并发就是40台机器。</p><p>如果你是基于云平台来部署系统的，搞活动临时租用一批机器就可以了，活动结束了机器立马可以释放掉，现在云平台都很方便。</p><p>但是有个问题，你的数据库MySQL能抗住2万的并发请求吗？</p><p>如果你基于MySQL来实现核心的抽奖业务逻辑，40个Tomcat部署的抽奖服务频繁对MySQL进行增删改查，这一个MySQL实例也是很难抗住的。</p><p>所以此时还得把MySQL给替换成Redis，通常这种场景下，建议是基于Redis来实现核心的业务逻辑。</p><p>Redis单机抗2万并发那是很轻松的一件事情，所以在这里又需要做进一步的优化。如下图：</p><p>7、发放礼品环节进行限流削峰<br>接着问题又来了，假设抽奖服务在2万请求中有1万请求抽中了奖品，那么势必会造成抽奖服务对礼品服务调用1万次。</p><p>礼品服务假设也是优化后的Tomcat，可以抗500并发，难道礼品服务也要去部署20台机器吗？</p><p>其实这是没必要的，因为抽奖之后完全可以让礼品服务在后台慢慢的把中奖的礼品给发放出去，不需要一下子就立马对1万个请求完成礼品的发放逻辑。</p><p>所以这里可以在抽奖服务和礼品服务之间，引入消息中间件，进行限流削峰。</p><p>也就是说，抽奖服务把中奖信息发送到MQ，然后礼品服务假设就部署两个Tomcat，慢慢的从MQ中消费中奖消息，然后慢慢完成1完礼品的发放就可以了。</p><p>假设两个礼品服务实例每秒可以完成100个礼品的发放，那么1万个礼品也就是延迟100秒发放完毕罢了。</p><p>也就是你抽奖之后，可能过了一两分钟，会看到自己的礼品发放的一些物流配送的进度之类的。</p><p>而且礼品服务可能需要在MySQL数据库中做很多增删改查的操作，比如插入中奖纪录，然后进行礼品发货等等。</p><p>此时因为礼品服务就2个Tomcat实例，所以对MySQL的并发读写不会太高，那么数据库层面也是可以抗住的。</p><p>整个过程，如下图所示：</p><p>8、系统架构设计总结<br>其实对于商品秒杀、抽奖活动、抢红包类的系统而言，架构设计的思路很多都是类似的，核心思路都是对于这种瞬时超高流量的系统，尽可能在负载均衡层就把99%的无效流量拦截掉</p><p>然后在1%的流量进入核心业务服务后，此时每秒并发还是可能会上万，那么可以基于Redis实现核心业务逻辑 ，抗住上万并发。</p><p>最后对于类似秒杀商品发货、抽奖商品发货、红包资金转账之类的非常耗时的操作，完全可以基于MQ来限流削峰，后台有一个服务慢慢执行即可。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/e002a9c6759b.html" class="post-title-link" itemprop="url">Java web</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:32:02 / 修改时间：15:32:30" itemprop="dateCreated datePublished" datetime="2023-12-20T15:32:02+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-web/" itemprop="url" rel="index"><span itemprop="name">Java web</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>WebService技术<br>1、什么是Web Service?<br>Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。<br>使用的技术:<br>HTTP、XML、SOAP（简单对象访问协议）、WSDL<br>优点:<br>跨平台、跨语言、跨系统<br>SOAP协议:<br>SOAP协议（Simple Object Access Protocal,简单对象访问协议）<br>Tcp/iphttp-&gt;soap，soap 通过xml文件传送信息<br>缺点：<br>(1).WebService使用了XML对数据封装，会造成大量的数据要在网络中传输。<br>(2).WebService规范没有规定任何与实现相关的细节，包括对象模型、编程语言，这一点，它不如CORBA。<br>2、什么是Web容器?<br>实现J2EE规范中web协议的应用.该协议定义了web程序的运行时环境,包括:并发性,安全性,生命周期管理等等.<br>就是在tomcat、weblogic下运行jsp、servlet、struts<br>3、应用服务器有那些？<br>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat<br>5、如何给weblogic指定大小的内存?<br>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS=-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M<br>6、如何设定的weblogic的热启动模式(开发模式)与产品发布模式?<br>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE=true。<br>7、如何启动时不需输入用户名与密码?<br>修改服务启动文件，增加 WLS_USER和WLS_PW项。也可以在boot.properties文件中增加加密过的用户名和密码.<br>8、在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?<br>保存在此Domain的config.xml文件中，它是服务器的核心配置文件。<br>9、说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http://主机:端口号//helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?<br>Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问，如果是Web应用，应用目录需要满足Web应用目录要求，jsp文件可以直接放在应用目录中，Javabean需要放在应用目录的WEB-INF目录的classes目录中，设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。<br>12、CORBA是什么?用途是什么?<br>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。<br>13、说说在weblogic中开发消息Bean时的persistent与non-persisten的差别<br>persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来，而non－persistent方式的消息将被丢弃。<br>14、WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。<br>Web ServiceWeb Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。<br>JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口。这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。<br>JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。<br>WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。<br>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。<br>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。</p><p>Web编程Jsp&amp;Servlet技术<br>1、简单说说tomcat的配置？<br>JAVA_HOME=JDK的根目录<br>CATALINA_HOME=tomcat的根目录</p><p>CATALINA-HOME\conf\server.xml:可以配置tomcat的端口，可以配置tomcat中下连接池。<br>CATALINA-HOME\common\lib:存放公用的类包</p><p>在My eclipse中如何配置tomcat<br>在eclipse中,选择windows-&gt;preference-&gt;MyEclipse-&gt;ApplicationServer-&gt;Tomcat<br>选择Tomcat 的安装目录，并选择TomCat所需的jdk，选择enable,确定即可。<br>2、JSP中动态INCLUDE与静态INCLUDE的区别？<br>jsp:include:在运行时调用另一个页面，变量是可以重复的。<br>&lt;%@include file=””%&gt;:在转译时合在一起，会成为同一个类，变量不可以重复。<br>3、forward和redirect的区别？<br>forward: 转发，在下一个页面中,request保留上一个页面中的request的所有值</p><p>redirect: 跳转，不传递request对象。<br>4、Servlet的体系结构是什么?<br>Servlet<br>GenericServlet<br>HttpServlet<br>自定义<br>5、如何实现一个自定义的servlet?<br>extends HttpServlet 并覆盖doPost或doGet方法</p><p>在web.xml中进行部署<br>6、Servlet的生命周期是什么?<br>Init<br>多次执行doGet或doPost<br>destroy<br>7、jsp就是一个servlet是否正确?<br>对<br>8、请罗列jsp中的脚本、指令及动作?<br>脚本<br>&lt;%%&gt; &lt;%=%&gt; &lt;%!%&gt; &lt;%—-%&gt;<br>指令<br>&lt;%@page contentType=”text/html;charset=utf-8” language=”java” import=””%&gt;<br>&lt;%@include file=””%&gt;<br>&lt;%@taglib uri=”” prefix=””%&gt;<br>动作:<br>&lt;jsp:useBean class=”” id=”” scope=””&gt; 在scope中如果没有实例化一个对象，如果有直接用以前的。<br>&lt;jsp:getProperty name=”” property=””&gt; 向一个bean中设置属性值<br>&lt;jsp:forward &gt; jsp页的转发<br>&lt;jsp:include page=””&gt; 导入一个jsp页面<br>9、JSP的内置对象及方法<br>Request request表示HttpServletRequest对象。取客户端表单域信息及cookie, header, 和session<br>response response表示HttpServletResponse对象，对客户端的响应返回文本、写cookies。<br>out out 向客户端打印html文本.<br>pageContext :当前jsp页面的上下文环境，可以得到session、request、application等内置对象，在自定义标签中使用的很多。<br>session session表示一个请求的javax.servlet.http.HttpSession对象。Session一个用户多个页面共享同一变量。<br>application applicaton 表示一个javax.servle.ServletContext对象。存放容器级的变量。<br>config config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。<br>page page表示从该页面产生的一个servlet实例<br>exception:异常，当iserrorpage=true<br>10、说出在JSP页面里是怎么分页的?<br>页面需要保存以下参数：(数据库的分页及比较)<br>总行数：根据sql语句得到总行数<br>每页显示行数：设定值<br>当前页数：请求参数<br>页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。</p><p>数据库:<br>Sqlserver:<br>SELECT TOP 页大小 *<br>FROM TestTable</p><p>WHERE (ID NOT IN<br>(SELECT TOP 页大小*(页数-1) id<br>FROM 表<br>ORDER BY id))<br>ORDER BY ID</p><p>–pageSize=5 页大小<br>–pageIndex=2 所要的页<br>–如果有主键可以，没以及键不行<br>select top 5 *<br>from aa where a1 not in<br>(select top 5 a1 from aa order by a1)<br>order by a1;</p><p>oracle:<br>select * from ‘||v_sql||’ where rownum&lt;’||<br>pageLastRow||’minus select * from ‘||v_sql<br>||’ where rownum&lt;’||pageFirstRow;</p><p>Session<br>先取出数据中的所有信息封装到对象并保存在session中，转发到jsp页面做如下处理。<br><table border="1"><br><tr><br><td>a1</td><br><td>a2</td><br></tr><br>&lt;%<br>List l=(List)session.getAttribute(“as”);<br>//一页显示多少行<br>int pageSize=3;<br>//总页数<br>int pageCount=0;<br>int currentPage=1;<br>if(l!=null &amp;&amp; l.size()&gt;0)<br>{<br>pageCount=(l.size()/pageSize)+(l.size()%pageSize==0?0:1);<br>if(request.getParameter(“page”)!=null)<br>{<br>currentPage=Integer.parseInt(request.getParameter(“page”));<br>}<br>if(currentPage&lt;1)<br>{<br>currentPage=1;<br>}<br>if(currentPage&gt;pageCount)<br>{<br>currentPage=pageCount;<br>}<br>for (int i = (currentPage-1)*pageSize; i &lt;(currentPage-1)*pageSize+pageSize; i++)<br>{<br>if(i&gt;=l.size())<br>{<br>break;<br>}<br>Aa aa=(Aa)l.get(i);<br>%&gt;<br><tr><br><td>&lt;%=aa.getA1()%&gt;</td><br><td>&lt;%=aa.getA2()%&gt;</td><br></tr><br>&lt;%<br>}<br>}<br>%&gt;</table></p><tr><td colspan="2"> <%
    if(currentPage!=1)
    {
    %> <a href="page.jsp?page=1">首页</a>&nbsp;&nbsp; <a href="page.jsp?page=<%=currentPage-1%>">上一页</a>&nbsp;&nbsp; <%
    }
    if(currentPage!=pageCount)
    {
    %> <a href="page.jsp?page=<%=currentPage+1%>">下一页</a>&nbsp;&nbsp; <a href="page.jsp?page=<%=pageCount%>">最后一页</a>&nbsp;&nbsp; <%
    }
    %> </td></tr><p>11、include的两种实现方式的区别?<br>&lt;@include file&gt;:在将jsp生成servlet类前将两个文件和在一起，生成一个java类，一起运行的。所以是一家子，当中的变量名不能重名。<br>&lt;jsp:include page&gt;:是两个类，是一个调用关系，在运行时动态的调用，不是一家子，可以重复变量。<br>12、jsp页面中两种跳转方式分别是什么?有什么区别?<br>转发: 保留上次的request<br><a href="jsp:forward">jsp:forward</a><br>actionMapping.findForWard(“”);<br>pageContext.forward();<br>request.getRequestDispacher(“a.jsp”).forward(request,response)<br>跳转:不保留上次的request<br>Response.setRedirect(“”)<br>13、描述JSP和Servlet的区别、共同点、各自应用的范围<br>Jsp主要在于页面的显示动态生成页面，可以与html标记一起使用，其还是要生成为一个servlet。<br>Servlet：主要是控制的处理，如调用业务层，跳转不同的jsp页面。<br>Mvc:<br>Jsp:v<br>Servlet:c<br>14、在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？<br>Request.getparameter(“”)<br>&lt;%=application.getRealPath(“aa.jsp”) %&gt;<br>15、描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。<br>Cookie:主要用在保存客户端，其值在客户端与服务端之间传送，不安全，存储的数据量有限。<br>Session:保存在服务端，每一个session在服务端有一个sessionID作一个标识。存储的数据量大，安全性高。占用服务端的内存资源。<br>16、说明Jsp中errorPage的作用，应用范围。<br>正常页面中<br>%@page erropage=”error.jsp”%<br>错误页面<br>&lt;%@page iserrorpage=”true”%&gt;<br>有一内置对象:exception<br>17、介绍在Jsp中如何使用JavaBeans<br>&lt;jsp:useBean class=”” id=”” scope=””/&gt;<br>&lt;%<br>New 类();<br>%&gt;<br>19、简单介绍JSP的标记库<br>做一个标记处理类 extends TagSupport<br>通过tld说明标记处理的类的前缀及后缀<br>在web.xml中说明tld文件<br><taglib><br><taglib-uri><br><taglib-location><br><taglib><br>在jsp页面是引用tld&lt;%@taglib uri=”” prefix=””%&gt;<br>20、Servlet中的核心类有那些，各有什么特点?<br>ServletContext：容器，放置全局变量<br>setAtribute()<br>getAttribute()<br>ServletConfig：一个servlet的配置<br>getInitParameter(”名称”)<br>HttpServletRequest：封装的所有的请求<br>getParameterValue(”名称”)<br>getParameterValues(”称”)<br>getSession();<br>getAttribute(” 名称”);<br>getRequestDispatch(”a.jsp”).forward(request,response)<br>HttpServletResponse：响应<br>getOut();<br>sendRedirect(””)<br>HttpSession：一个用户多个页面共享同一变量<br>setAttribute(””,””)<br>21、Servlet中重要的包有那些，有什么区别?<br>javax.servlet.<em>；javax.servlet.http.</em>;<br>22、说出Servlet的生命周期，并说出Servlet和CGI的区别？<br>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</taglib></taglib-location></taglib-uri></taglib></p><p>与cgi的区别在于servlet处理服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。<br>23、什么情况下调用doGet()和doPost()？<br>Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。<br>25、如何现实servlet的单线程模式<br>在doGet及doPost方法前加入synchoronized<br>JSP:<br>&lt;%@ page isThreadSafe=”true”%&gt;<br>27、Request对象的主要方法：<br>setAttribute(String name,Object)：设置名字为name的request的参数值<br>getAttribute(String name)：返回由name指定的属性值<br>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的Body的长度<br>实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例<br>getParameterValues(String name)：获得有name指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的IP地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性<br>28、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？<br>Public String translate (String str) {<br>String tempStr = “”;<br>try {<br>tempStr = new String(str.getBytes(“ISO-8859-1”), “GBK”);<br>tempStr = tempStr.trim();<br>}<br>catch (Exception e) {<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}</p><p>30、Servlet执行时一般实现哪几个方法?<br>public void init(ServletConfig config)<br>public ServletConfig getServletConfig()<br>public String getServletInfo()<br>public void service(ServletRequest request,ServletResponse response)<br>public void destroy()</p><p>31<br>1.jsp有哪些内置对象?作用分别是什么：<br>答:JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：<br>request 用户端请求，此请求会包含来自GET/POST请求的参数<br>response 网页传回用户端的回应<br>pageContext 网页的属性是在这里管理<br>session 与请求有关的会话期<br>application servlet 正在执行的内容<br>out 用来传送回应的输出<br>config servlet的构架部件<br>page JSP网页本身<br>exception 针对错误网页，未捕捉的例外。<br>2.jsp有哪些动作?作用分别是什么：<br>答:JSP共有以下6种基本动作<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个JavaBean。<br>jsp:setProperty：设置JavaBean的属性。<br>jsp:getProperty：输出某个JavaBean的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。<br>3.JSP中动态INCLUDE与静态INCLUDE的区别：<br>答：动态INCLUDE用jsp:include动作实现<br>&lt;jsp:include page=”included.jsp” flush=”true” /&gt;它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数<br>静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面<br>&lt;%@ include file=”included.htm” %&gt;。<br>4.两种跳转方式分别是什么?有什么区别：<br>答：有两种，分别为：<br>&lt;jsp:include page=”included.jsp” flush=”true”&gt;<br>&lt;jsp:forward page= “nextpage.jsp”/&gt;<br>前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。<br>5.说一说Servlet的生命周期：<br>答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。<br>6.JAVA SERVLET API中forward() 与redirect()的区别：<br>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。</p><p>16.MVC的各个部分都有那些技术来实现?如何实现：<br>答:MVC是Model－View－Controller的简写。”Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， “View” 是应用的表示面（由JSP页面产生），”Controller” 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。<br>17.J2EE是什么：<br>答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。<br>18.WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释：<br>答：Web Service描述语言WSDL<br>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。<br>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。<br>19.STRUTS的应用(如STRUTS架构) ：<br>答：Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能：<br>一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。<br>二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。<br>三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。<br>20.开发中都用到了那些设计模式?用在什么场合：<br>答：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。<br>30.JSP的内置对象及方法:<br>request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法,response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等）.<br>out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。<br>session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息 applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息 config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 page表示从该页面产生的一个servlet实例。<br>31.JSP的常用指令：<br>&lt;%@page language=”java” contenType=”text/html;charset=gb2312” session=”true” buffer=”64kb” autoFlush=”true” isThreadSafe=”true” info=”text” errorPage=”error.jsp” isErrorPage=”true” isELIgnored=”true” pageEncoding=”gb2312” import=”java.sql.*”%&gt;<br>isErrorPage(是否能使用Exception对象)，isELIgnored(是否忽略表达式) &lt;%@include file=”filename”%&gt;&lt;%@taglib prefix=”c”uri=”http://……”%&gt;<br>32.四种会话跟踪技术：<br>cookie,url重写,session,隐藏域。<br>33.Request对象的主要方法：<br>setAttribute(String name,Object)：设置名字为name的request的参数值<br>getAttribute(String name)：返回由name指定的属性值<br>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的Body的长度<br>getHeader(String name)：获得HTTP协议定义的文件头信息<br>getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例<br>getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例<br>getParameterValues(String name)：获得有name指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的IP地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性<br>34.J2EE是技术还是平台还是框架：<br>J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br>J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。<br>35.EJB的角色和三个对象：<br>一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性。这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类<br>36.EJB容器提供的服务：<br>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。<br>37.EJB规范规定EJB中禁止的操作有哪些：<br>1.不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，<br>2.不能操作awt，<br>3.不能实现服务器功能，<br>4.不能对静态属生存取，<br>5.不能使用IO操作直接存取文件系统，<br>6.不能加载本地库.，<br>7.不能将this作为变量和返回，<br>8.不能循环调用。<br>51.说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法：<br>Session Facade Pattern：使用SessionBean访问EntityBean；Message Facade Pattern：实现异步调用；EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问；Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性；Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性；Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性；ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率。项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。<br>52.说说在weblogic中开发消息Bean时的persistent与non-persisten的差别：<br>persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来，而non－persistent方式的消息将被丢弃。<br>53.常用的设计模式？说明工厂模式：<br>Java中的23种设计模式：Factory（工厂模式），Builder（建造模式）， Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）。<br>工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。<br>54.MVC的各个部分都有那些技术来实现?如何实现：<br>MVC是Model－View－Controller的简写。”Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， “View” 是应用的表示面（由JSP页面产生），”Controller” 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。<br>55.UML方面：<br>标准建模语言UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。<br>56.说出一些常用的类，包，接口，请各举5个常用的类：<br>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer；<br>常用的包：java.lang java.awt java.io java.util java.sql；<br>常用的接口：Remote List Map Document NodeList<br>57.开发中都用到了那些设计模式?用在什么场合:<br>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。<br>58.jsp有哪些动作?作用分别是什么：<br>JSP共有以下6种基本动作：<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个JavaBean。<br>jsp:setProperty：设置JavaBean的属性。<br>jsp:getProperty：输出某个JavaBean的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。<br>59.应用服务器与WEB SERVER的区别：<br>应用服务器：Weblogic、Tomcat、Jboss； WEB SERVER：IIS、 Apache<br>60.BS与CS的联系与区别：<br>C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C/S 与 B/S 区别：<br>１．硬件环境不同: C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行<br>２．对安全要求不同 ：C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息.B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同 ：　C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟.<br>４．软件重用不同： C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好.　B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。<br>５．系统维护不同 ：C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.<br>６．处理问题不同 ：C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小.<br>７．用户接口不同： C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.<br>８．信息流不同 ：　C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心</p><p>19、forward 和redirect的区别forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。<br>3、JAVA SERVLET API中forward() 与redirect()的区别？<br>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。<br>1..描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理<br>Session用于保存每个用户的专用信息. 每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID) . 她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右).Session中的信息保存在Web服务器内容中,保存的数据量可大可小.当 Session超时或被关闭时将自动释放保存的数据信息.由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低.对于小量的数据,使用Session对象保存还是一个不错的选择<br>Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置.如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止.如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期.Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据.由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性<br>session工作原理<br>(1)当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。<br>(2)然后，服务器开辟一块内存，对应于该Session ID。<br>(3)服务器再将该Session ID写入浏览器的cookie。<br>(4)服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。<br>(5)当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。<br>(6)然后，服务检查该Session ID所对应的内存是否有效。<br>(7)如果有效，就读出内存中的值。<br>(8)如果无效，就建立新的Session。<br>2.Servlet的生命周期分为3个阶段:? 和CGI的区别？<br>Servlet的生命周期主要由3个过程组成。<br>(1)init()方法：服务器初始化servlet。<br>(2)service()方法：初始化完毕，servlet对象调用该方法响应客户的请求。<br>(3)destroy()方法：调用该方法消灭servlet对象。<br>其中，init()方法只在servlet第一次被请求加载的时候被调用一次，当有客户再请求servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。<br>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</p><p>3.forward与redirect 的区别?有哪些方式实现<br>1）.<a href="jsp:forward">jsp:forward</a>重定向后url地址栏地址不变还是原来的地址；而response.sendRedirect()重定向后url地址栏地址显示的请求后的新地址。<br>2）.<a href="jsp:forward">jsp:forward</a>重定向的时候可以保存回话信息，因此可以使用request来进行参数传递，在新页面可以使用request.getAttribute ()来得到参数。而response.sendRedirect()不支持此通过request进行参数传递。它唯一的传值方式为response.sendRedirect(“example.jsp?aa=123”)，在新的页面通过request.getParameter(“aa”)来得到参数值<br>3）.Tomcat的class加载的优先顺序一览<br>1.最先是$JAVA_HOME/jre/lib/ext/下的jar文件。<br>2.环境变量CLASSPATH中的jar和class文<br>3.$CATALINA_HOME/common/classes下的class<br>4.$CATALINA_HOME/commons/endorsed下的jar文件。<br>5.$CATALINA_HOME/commons/i18n下的jar文件。<br>6.$CATALINA_HOME/common/lib 下的jar文件。<br>（JDBC驱动之类的jar文件可以放在这里，这样就可以避免在server.xml配置好数据源却出现找不到JDBC Driver的情况。）<br>7.$CATALINA_HOME/server/classes下的class文件。<br>8.$CATALINA_HOME/server/lib/下的jar文件。<br>9.$CATALINA_BASE/shared/classes 下的class文件。<br>10.$CATALINA_BASE/shared/lib下的jar文件。<br>11.各自具体的webapp /WEB-INF/classes下的class文件。<br>12.各自具体的webapp /WEB-INF/lib下的jar文件。</p><p>4）.CS与BS联系区别<br>1）java适合开发bs结构，cs不是它的强项 C/S 服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。B/S 客户机上只要安装一个浏览器（Browser），如Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Web Server 同数据库进行数据交互 1．硬件环境不同: C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务. B/S 建立在广域网之上的<br>2）对安全要求不同 C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息. B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户<br>3）对程序架构不同 C/S 程序可以更加注重流程, 可以对权限多层次校验 B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上</p><p>4.解释一下mvc以及熟悉的mvc框架<br>答:m代表模型层，v 代表视图层，c代表控制层，也就是把一个整体分割成不同的模块，各负责自己的功能，分工明确，提高代码的重用性和方便维护。<br>在jsp设计模式二中，jsp用来做视图层，servlet是控制器，dao则处理相关业务成为模型层。<br>在struts2.0,其中m是action,c是拦截器，v是jsp.</p><p>5.浏览器页面与T0MCat的交互过程？<br>当一个JSP页面第一次被访问的时候，JSP引擎将执行以下步骤：<br>（1）将JSP页面翻译成一个Servlet，这个Servlet是一个java文件，同时也是一个完整的java程序<br>（2）JSP引擎调用java编译器对这个Servlet进行编译，得到可执行文件class<br>（3）JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户端<br>以上三个步骤仅仅在JSP页面第一次被访问时才会执行，以后的访问速度会因为class文件已经生成而大大提高。当JSP引擎街道一个客户端的访问请求时，首先判断请求的JSP页面是否比对应的Servlet新，如果新，对应的JSP需要重新编译。</p><p>6.JSP内置对象作用，如何取Cookie的方法<br>使用request对象的getCookies()方法取cookies<br>(1) HttpServletRequest类的Request对象<br>作用：代表请求对象，主要用于接受客户端通过HTTP协议连接传输到服务器端的数据。<br>(2) HttpServletResponse类的Respone对象<br>作用：代表响应对象，主要用于向客户端发送数据<br>(3) JspWriter类的out对象<br>作用：主要用于向客户端输出数据;<br>        Out的基类是JspWriter<br>(4) HttpSession类的session对象<br>作用：主要用于来分别保存每个用户信息，与请求关联的会话；<br>    会话状态维持是Web应用开发者必须面对的问题。<br>(5) ServletContext类的application对象<br>作用：主要用于保存用户信息，代码片段的运行环境；<br>    它是一个共享的内置对象，即一个容器中的多个用户共享一个application对象，故其保存的信息被所有用户所共享.<br>(6) PageContext类的PageContext对象<br>作用：管理网页属性,为JSP页面包装页面的上下文，管理对属于JSP中特殊可见部分中已命名对象的访问，它的创建和初始化都是由容器来完成的。<br>(7) ServletConfig类的Config对象<br>作用：代码片段配置对象，表示Servlet的配置。<br>(8) Object类的Page（相当于this）对象<br>作用：处理JSP网页，是Object类的一个实例，指的是JSP实现类的实例，即它也是JSP本身，只有在JSP页面范围之内才是合法的。<br>(9)Exception<br>作用：处理JSP文件执行时发生的错误和异常<br>7.JAVA事件有哪些模式？<br>1.事件直接驱动模式。它的第一个要求就是性能的要求，需要直接而且快，是必须经常使用的，主要适合于迅速处理 前台的命令，往往是系统架构的重要部分，也是流程控制的主要模式。2.监控式事件模式是借助第三者来监控和触发事件，特点是： 有一个观察者置身事外在定期独立运行着。<br>2.uml三要素.<br>事物、关系、图</p><p>8.jsp与servlet中请求转发的区别<br>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址，但此转发是连续的转发，在转发过程中请求参数也连续转发到目标地址中。<br>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求。前者对请求是连续的，后者是重新发送一个新的请求，所以只能重新发送新的请求参数，原有的请求参数将不再连续到目标页面。<br>9.Session的具体用法？<br>Session用来保存每一个用户的专有信息，比如像用户登录验证、购物车。<br>1.ibatis 中的#与$的区别<br>1.#是把传入的数据当作字符串，如#field#传入的是id,则sql语句生成是这样，order by “id”,这当然会报错．．<br>2.$传入的数据直接生成在sql里，如#field#传入的是id,则sql语句生成是这样，order by id, 这就对了．<br>3.#方式能够很大程度防止sql注入．<br>4.$方式无法方式sql注入．<br>5.$方式一般用于传入数据库对象．例如传入表名.<br>6.一般能用#的就别用$.</p><p>10.请裂举session、cookie、viewstated的应用范围<br>Session 服务器端维护， 某个用户活动时间 + 延迟时间（默认20分钟），<br>Cookie 客户端维护， 程序可指定生命周期，<br>ViewState 小量数据，一个web页面的生命期</p><ol start="11"><li>用什么方法使服务器关闭之后，session所保存的信息不会丢失？<br>将session信息保存到数据库中或文件中</li></ol><p>　1. 写客户端Cookie的方式<br>　　当用户登陆成功以后，把网站域名、用户名、密码、token、session有效时间全部采用cookie的形式写入到客户端的cookie里面，如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务，当然，如果cookie过期，或者无效，自然就不让用户继续服务了。当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？<br>　　2. 服务器之间Session数据同步的方式<br>　　假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了。缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。<br>　　3. 利用NFS共享Session数据的方式<br>　　其实这个方案和下面的Mysql方案类似，只是存储方式不一样。大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台NFS服务器上的，不论用户访问那太Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了。缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。</p><p>　　4. 利用Mysql数据库共享Session数据的方式<br>　　这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上，所有Web服务器都来这台Mysql服务器来获取Session数据。缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql数据的方式。<br>　　5. 使用硬件设备<br>　　这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了。目前很多门户网站采用这种方式。缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/32257fddc744.html" class="post-title-link" itemprop="url">数据库</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:19:45 / 修改时间：15:20:18" itemprop="dateCreated datePublished" datetime="2023-12-20T15:19:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="MyISAM与InnoDB-的区别（9个不同点）"><a href="#MyISAM与InnoDB-的区别（9个不同点）" class="headerlink" title="MyISAM与InnoDB 的区别（9个不同点）"></a>MyISAM与InnoDB 的区别（9个不同点）</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>1、InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>2、InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>3、InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。<br>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。<br>也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</li><li>4、InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；<br>那么为什么InnoDB没有了这个变量呢？<br>因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。<br>如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS</li><li>5、Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了</li><li>6、MyISAM表格可以被压缩后进行查询操作</li><li>7、InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁<br>InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。<br>例如：</li></ul><pre><code>    t_user(uid, uname, age, sex) innodb;
 
    uid PK
    无其他索引
    update t_user set age=10 where uid=1;             命中索引，行锁。
 
    update t_user set age=10 where uid != 1;           未命中索引，表锁。
 
    update t_user set age=10 where name=&#39;chackca&#39;;    无索引，表锁。
</code></pre><ul><li>8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</li><li>9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI<ul><li>Innodb：frm是表定义文件，ibd是数据文件</li><li>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</li></ul></li></ul><h2 id="如何选择："><a href="#如何选择：" class="headerlink" title="如何选择："></a>如何选择：</h2><p>*<br>1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；<br>*<br>1. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。<br>*<br>1. 系统奔溃后，MyISAM恢复起来更困难，能否接受；<br>*<br>1. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</p><h2 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h2><ul><li>答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</li></ul><h2 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h2><ul><li>插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</li></ul><h1 id="⾏锁，表锁，乐观锁，悲观锁？"><a href="#⾏锁，表锁，乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁，乐观锁，悲观锁？"></a>⾏锁，表锁，乐观锁，悲观锁？</h1><ul><li>a. ⾏锁：数据库表中某一⾏被锁住。</li><li>b. 表锁：整个数据库表被锁住。</li><li>c. 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不不会修改，具体实现是给表增加⼀个版本号的字段，在执行update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。</li><li>d. 悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。读数据的时候会上锁，直到update完成才释放锁，使⽤悲观锁要注意不要锁住整个表。</li></ul><h1 id="数据库隔离级别是什什么？有什么作用？"><a href="#数据库隔离级别是什什么？有什么作用？" class="headerlink" title="数据库隔离级别是什什么？有什么作用？"></a>数据库隔离级别是什什么？有什么作用？</h1><p>*<br>1. ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。 这种隔离级别会产⽣生脏读，不可重复读和幻读。<br>*<br>1. ISOLATIONREADCOMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外⼀个事务不能读取该 事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。<br>*<br>1. ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了了保证一个事务不能读取另⼀个事务未提交的数据外，还保证了了避免不可重复读。<br>*<br>1. ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理理为顺序执行。除了防止脏读， 不可重复读外，还避免了幻读。</p><h1 id="MySQL主备同步的基本原理理。"><a href="#MySQL主备同步的基本原理理。" class="headerlink" title="MySQL主备同步的基本原理理。"></a>MySQL主备同步的基本原理理。</h1><ul><li>mysql主备复制实现分成三个步骤：<ul><li>1、master将改变记录到⼆二进制⽇日志(binary log) 中（这些记录叫做⼆二进制⽇日志事件，binary log events，可以通过show binlog events进⾏行行查看）；</li><li>2、slave将master的binary log events拷⻉贝到它的中继⽇日志(relay log) ；</li><li>3、slave重做中继⽇日志中的事件，将改变反映它⾃自⼰己的数据。</li></ul></li></ul><h1 id="select-from-table-t-where-size-gt-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？"><a href="#select-from-table-t-where-size-gt-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</h1><ul><li>sql语句句执⾏行行顺序如下：</li><li>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</li></ul><h1 id="如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）"><a href="#如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）" class="headerlink" title="如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）"></a>如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）</h1><ul><li>1、选择合适的数据库引擎，合理理使⽤用索引</li><li>2、分⻚页获取数据，只获取需要的字段</li><li>3、优化业务逻辑，减少数据库IO</li><li>4、分库分表</li><li>5、部署主从数据库</li><li>6、升级硬件</li><li><ol><li>SQL什什么情况下不不会使⽤用索引（不不包含，不不等于，函数）</li></ol><ul><li>a. select * 可能导致不不⾛走索引；</li><li>b. 空值会导致不不⾛走索引，因为hashset不不能存空值；</li><li>c. 索引列列有函数运算，不不⾛走索引，可以在索引列列建⽴立⼀一个函数的索引。</li><li>d. 隐式转换可能导致不不⾛走索引；</li><li>e. 表的数据库⼩小或者需要选择⼤大部分数据，不不⾛走索引；</li><li>f. !=或者&lt;&gt;可能导致不不⾛走索引；</li><li>g. 字符型的索引列列会导致优化器器认为需要扫描索引⼤大部分数据且聚簇因⼦子很⼤大，最终导致弃⽤用索引扫描⽽而改⽤用全表扫描方式</li><li>h. like ‘%liu’ 百分号在前不不⾛走索引；</li><li>i. not in, not exist不不⾛走索引；</li></ul></li></ul><h1 id="—般在什什么字段上建索引（过滤数据最多的字段）"><a href="#—般在什什么字段上建索引（过滤数据最多的字段）" class="headerlink" title="—般在什什么字段上建索引（过滤数据最多的字段）"></a>—般在什什么字段上建索引（过滤数据最多的字段）</h1><ul><li>1、表的主键、外键必须有索引；</li><li>2、数据量量超过300的表应该有索引；</li><li>3、经常与其他表进⾏行行连接的表，在连接字段上应该建⽴立索引；</li><li>4、经常出现在Where⼦子句句中的字段，特别是⼤大表的字段，应该建⽴立索引；</li><li>5、索引应该建在选择性⾼高的字段上；</li><li>6、索引应该建在⼩小字段上，对于⼤大的⽂文本字段甚⾄至超⻓长字段，不不要建索引；</li><li><ol><li>如何从⼀一张表中查出name字段不不包含”XYZ”的所有⾏行行？</li></ol></li></ul><h1 id="HRedis-RDB和A0Ff如何做⾼高可⽤用、集群"><a href="#HRedis-RDB和A0Ff如何做⾼高可⽤用、集群" class="headerlink" title="HRedis, RDB和A0Ff如何做⾼高可⽤用、集群"></a>HRedis, RDB和A0Ff如何做⾼高可⽤用、集群</h1><h1 id="如何解决⾼高并发减库存问题"><a href="#如何解决⾼高并发减库存问题" class="headerlink" title="如何解决⾼高并发减库存问题"></a>如何解决⾼高并发减库存问题</h1><ul><li>消息队列列，异步处理理，减库存加锁</li></ul><h1 id="mysql存储引擎中索引的实现机制；"><a href="#mysql存储引擎中索引的实现机制；" class="headerlink" title="mysql存储引擎中索引的实现机制；"></a>mysql存储引擎中索引的实现机制；</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/debug_zhang/article/details/52168552">https://blog.csdn.net/debug_zhang/article/details/52168552</a></p><h1 id="数据库事务的⼏几种粒度；"><a href="#数据库事务的⼏几种粒度；" class="headerlink" title="数据库事务的⼏几种粒度；"></a>数据库事务的⼏几种粒度；</h1><ul><li>a. 表锁定：对整个表的锁定。</li><li>b. ⾏行行锁定：只锁定进⾏行行更更改的⾏行行，例例如：insert，update，delete，都隐式采⽤用⾏行行锁定。</li><li>c. 数据库锁机制可分为多种粒度的： 数据库，表，⻚页⾯面，⾏行行</li><li>d. 粒度越⼤大，DBMS管理理越容易易，但是实现并发处理理的能⼒力力就越差，表，⻚页⾯面，⾏行行</li></ul><h1 id="mysql调优："><a href="#mysql调优：" class="headerlink" title="mysql调优："></a>mysql调优：</h1><ul><li>a. explain select语句句；</li><li>b. 当只要⼀一条数据时使⽤用limit 1；</li><li>c. 为搜索字段建索引；</li><li>d. 避免select *；</li><li>e. 字段尽量量使⽤用not null；</li><li>f. 垂直分割；</li><li>g. 拆分⼤大的delete和insert语句句：delete和insert会锁表；</li><li>h. 分表分库分区。</li></ul><h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><ul><li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li><li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><p>事务进⾏行行过程中，每次sql语句句执⾏行行，都会记录undo log和redo log，然后更更新数据形成脏⻚页，然后redo log按照时间或 者空间等条件进⾏行行落盘，undo log和脏⻚页按照checkpoint进⾏行行落盘，落盘后相应的redo log就可以删除了了。此时，事务还未 COMMIT，如果发⽣生崩溃，则⾸首先检查checkpoint记录，使⽤用相应的redo log进⾏行行数据和undo log的恢复，然后查看undo log的状 态发现事务尚未提交，然后就使⽤用undo log进⾏行行事务回滚。事务执⾏行行COMMIT操作时，会将本事务相关的所有redo log都进⾏行行落 盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏⻚页继续按照checkpoint进⾏行行落盘。如果此时发⽣生了了崩 溃，则只使⽤用redo log恢复数据。</p><h1 id="让你设计⼀一个索引，你会怎么设计？"><a href="#让你设计⼀一个索引，你会怎么设计？" class="headerlink" title="让你设计⼀一个索引，你会怎么设计？"></a>让你设计⼀一个索引，你会怎么设计？</h1><p>mysql默认存储引擎innodb只显式⽀支持B树索引，对于频繁访问的表，innodb会透明建⽴立⾃自适应hash索引，即在B树索引 基础上建⽴立hash索引，可以显著提⾼高查找效率，对于客户端是透明的，不不可控制的，隐式的。</p><h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><ul><li>1、如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。</li><li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li><li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li><li>2、数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放</li><li>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</li><li>3、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>4、如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置</li><li>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销</li><li>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li></ul><h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ul><h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul><li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li><li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li></ul><h1 id="哈希索引的优势："><a href="#哈希索引的优势：" class="headerlink" title="哈希索引的优势："></a>哈希索引的优势：</h1><ul><li>等值查询，哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</li></ul><h1 id="哈希索引不适用的场景："><a href="#哈希索引不适用的场景：" class="headerlink" title="哈希索引不适用的场景："></a>哈希索引不适用的场景：</h1><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li><li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：</li><li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：</li><li>仅等值查询</li><li>select id, name from table where name=’李明’;</li><li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li><li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li><li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li><li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li><li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li></ul><h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul><li>1、B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li><li>2、B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li></ul><h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><ul><li>1、B+的磁盘读写代价更低。</li><li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li><li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li><li>2、B+-tree的查询效率更加稳定。</li><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><ul><li>1、联合索引是两个或更多个列上的索引。</li><li>对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li><li>例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</li><li>2、利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</li><li>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。</li><li>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</li></ul><h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul><li>1、表记录太少</li><li>2、经常插入、删除、修改的表</li><li>3、数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>4、经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul><li>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li></ul><h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul><li>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。</li><li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li></ul><h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><ul><li>1、存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据</li><li>2、优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li><li>3、分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</li><li>4、避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</li></ul><h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><ul><li>命令：show variables like ‘%partition%’ 运行结果:</li><li>mysql&gt; show variables like ‘%partition%’;</li><li>+——————-+——-+| Variable_name | Value |+——————-+——-+| have_partitioning | YES |+——————-+——-+1 row in set (0.00 sec)</li><li>have_partintioning 的值为YES，表示支持分区。</li></ul><h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><ul><li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h1 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h1><ul><li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ul><h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><ul><li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control)</li><li>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</li><li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</li><li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制</li><li>MVCC：Multi-Version Concurrency Control</li><li>基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li><li>十八、在MVCC并发控制中，读操作可以分成两类：</li><li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li><li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li></ul><h1 id="行级锁定的优点："><a href="#行级锁定的优点：" class="headerlink" title="行级锁定的优点："></a>行级锁定的优点：</h1><ul><li>1、当在许多线程中访问不同的行时只存在少量锁定冲突。</li><li>2、回滚时只有少量的更改</li><li>3、可以长时间锁定单一的行。</li></ul><h1 id="行级锁定的缺点："><a href="#行级锁定的缺点：" class="headerlink" title="行级锁定的缺点："></a>行级锁定的缺点：</h1><ul><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h1 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h1><ul><li>开启查询缓存，优化查询</li><li>explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的</li><li>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</li><li>为搜索字段建索引</li><li>使用 ENUM 而不是 VARCHAR。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR</li><li>Prepared StatementsPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</li><li>Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击</li><li>垂直分表</li><li>选择正确的存储引擎</li></ul><h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul><li>key 是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等</li><li>index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；</li></ul><h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul><li>区别：<ul><li>InnoDB支持事务，MyISAM不支持</li><li>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</li><li>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ul></li><li>如何选择：<ul><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ul></li></ul><h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><ul><li>1、字段名及字段配制合理性<ul><li>剔除关系不密切的字段；</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul></li><li>2、系统特殊字段处理及建成后建议<ul><li>添加删除标记（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul></li><li>3、表结构合理性配置<ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul></li><li>4、其它建议<ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul></li></ul><h1 id="数据库优化的方案"><a href="#数据库优化的方案" class="headerlink" title="数据库优化的方案"></a>数据库优化的方案</h1><p>建立主键，为数据库创建索引，建立存储过程，触发器，可提高查询速度</p><h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><p>*<br>1. 第一范式（1NF）：字段具有原子性,不可再分。(所有关系型数据库系统都满足第一范式数据库表中的字段都是单一属性的，不可再分)<br>*<br>1. 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。<br>*<br>1. 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 &gt;所以第三范式具有如下特征： &gt;&gt;1. 每一列只有一个值 &gt;&gt;2. 每一行都能区分。 &gt;&gt;3. 每一个表都不包含其他表已经包含的非主关键字信息。</p><h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><p>*<br>1. 用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。<br>*<br>1. 有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。<br>*<br>1. 表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等<br>*<br>1. UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL。 &gt;&gt;UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。 &gt;1. 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。 &gt;2. 对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</p><h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><p>*<br>1. 普通索引: 即针对数据库表创建索引<br>*<br>1. 唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值<br>*<br>1. 主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引<br>*<br>1. 组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</p><h1 id="以及在mysql数据库中索引的工作机制是什么？"><a href="#以及在mysql数据库中索引的工作机制是什么？" class="headerlink" title="以及在mysql数据库中索引的工作机制是什么？"></a>以及在mysql数据库中索引的工作机制是什么？</h1><ul><li>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树</li></ul><h1 id="MySQL的基础操作命令"><a href="#MySQL的基础操作命令" class="headerlink" title="MySQL的基础操作命令:"></a>MySQL的基础操作命令:</h1><p>*<br>1. MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status<br>*<br>1. 开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务<br>*<br>1. Shell 登入 MySQL: 运行命令 mysql -u root -p<br>*<br>1. 列出所有数据库:运行命令 show databases;<br>*<br>1. 切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库<br>*<br>1. 列出某个数据库内所有表: show tables;<br>*<br>1. 获取表内所有 Field 对象的名称和类型 :describe table_name;</p><h1 id="mysql的复制原理以及流程。"><a href="#mysql的复制原理以及流程。" class="headerlink" title="mysql的复制原理以及流程。"></a>mysql的复制原理以及流程。</h1><ul><li>Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的。 * 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。 当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。 过程如下 1. 主服务器把更新记录到二进制日志文件中。 2. 从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中。 3. 从服务器重做中继日志中的时间，把更新应用到自己的数据库上。</li></ul><h1 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型?"></a>mysql支持的复制类型?</h1><p>*<br>1. 基于语句的复制： 在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。 一旦发现没法精确复制时，会自动选着基于行的复制。<br>*<br>1. 基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持<br>*<br>1. 混合类型的复制: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p><h1 id="mysql中myisam与innodb的区别？"><a href="#mysql中myisam与innodb的区别？" class="headerlink" title="mysql中myisam与innodb的区别？"></a>mysql中myisam与innodb的区别？</h1><p>*<br>1. 事务支持 &gt; MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 &gt; InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。<br>*<br>1. InnoDB支持行级锁，而MyISAM支持表级锁. &gt;&gt; 用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>*<br>1. InnoDB支持MVCC, 而MyISAM不支持<br>*<br>1. InnoDB支持外键，而MyISAM不支持<br>*<br>1. 表主键 &gt; MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 &gt; InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。<br>*<br>1. InnoDB不支持全文索引，而MyISAM支持。<br>*<br>1. 可移植性、备份及恢复 &gt; MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 &gt; InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了<br>*<br>1. 存储结构 &gt; MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。 &gt; InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h1 id="mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？"><a href="#mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？" class="headerlink" title="mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？"></a>mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</h1><p>*<br>1. varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.<br>*<br>1. varchar(50)中50的涵义 : 最多存放50个字节<br>*<br>1. int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</p><h1 id="MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h1><p>*<br>1. Read Uncommitted（读取未提交内容） &gt;&gt; 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>*<br>1. Read Committed（读取提交内容） &gt;&gt; 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>*<br>1. Repeatable Read（可重读） &gt;&gt; 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。<br>*<br>1. Serializable（可串行化） &gt;&gt; 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<table><thead><tr><th align="left">隔离级别</th><th align="left">脏读（Dirty Read）</th><th align="left">不可重复读（NonRepeatable Read）</th><th align="left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td align="left">未提交读（Read uncommitted）</td><td align="left">可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">已提交读（Read committed）</td><td align="left">不可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">可重复读（Repeatable read）</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">可能</td></tr><tr><td align="left">可串行化（SERIALIZABLE）</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">不可能</td></tr></tbody></table></p><h1 id="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h1><ul><li>如果字段里面有大字段（text,blob)类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了。 MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多。此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后，对字段的UPDAE就要UPDATE多个表了</li></ul><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</h1><ul><li>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li></ul><h1 id="MySQL中控制内存分配的全局参数，有哪些？"><a href="#MySQL中控制内存分配的全局参数，有哪些？" class="headerlink" title="MySQL中控制内存分配的全局参数，有哪些？"></a>MySQL中控制内存分配的全局参数，有哪些？</h1><p>*<br>1. Keybuffersize： &gt; * keybuffersize指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Keyreadrequests和Keyreads，可以知道keybuffersize设置是否合理。比例keyreads /keyreadrequests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘keyread%’获得）。 &gt; * keybuffersize只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值createdtmpdisktables得知详情。对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M） &gt; * keybuffersize设置注意事项 &gt;&gt;&gt;1. 单个keybuffer的大小不能超过4G，如果设置超过4G，就有可能遇到下面3个bug: &gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=29446">http://bugs.mysql.com/bug.php?id=29446</a><br>&gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=29419">http://bugs.mysql.com/bug.php?id=29419</a><br>&gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=5731">http://bugs.mysql.com/bug.php?id=5731</a><br>&gt;&gt;&gt;2. 建议keybuffer设置为物理内存的1/4(针对MyISAM引擎)，甚至是物理内存的30%~40%，如果keybuffersize设置太大，系统就会频繁的换页，降低系统性能。因为MySQL使用操作系统的缓存来缓存数据，所以我们得为系统留够足够的内存；在很多情况下数据要比索引大得多。 &gt;&gt;&gt;3. 如果机器性能优越，可以设置多个keybuffer,分别让不同的keybuffer来缓存专门的索引<br>*<br>1. innodbbufferpool_size &gt; 表示缓冲池字节大小，InnoDB缓存表和索引数据的内存区域。mysql默认的值是128M。最大值与你的CPU体系结构有关，在32位操作系统，最大值是 4294967295 (2^32-1) ，在64 位操作系统，最大值为18446744073709551615 (2^64-1)。 &gt; 在32位操作系统中，CPU和操作系统实用的最大大小低于设置的最大值。如果设定的缓冲池的大小大于1G，设置innodbbufferpoolinstances的值大于1. &gt; * 数据读写在内存中非常快, innodbbufferpoolsize 减少了对磁盘的读写。 当数据提交或满足检查点条件后才一次性将内存数据刷新到磁盘中。然而内存还有操作系统或数据库其他进程使用, 一般设置 buffer pool 大小为总内存的 3/4 至 4/5。 若设置不当, 内存使用可能浪费或者使用过多。 对于繁忙的服务器, buffer pool 将划分为多个实例以提高系统并发性, 减少线程间读写缓存的争用。buffer pool 的大小首先受 innodbbufferpool_instances 影响, 当然影响较小。<br>*<br>1. querycachesize &gt; 当mysql接收到一条select类型的query时，mysql会对这条query进行hash计算而得到一个hash值，然后通过该hash值到query cache中去匹配，如果没有匹配中，则将这个hash值存放在一个hash链表中，同时将query的结果集存放进cache中，存放hash值的链表的每一个hash节点存放了相应query结果集在cache中的地址，以及该query所涉及到的一些table的相关信息；如果通过hash值匹配到了一样的query，则直接将cache中相应的query结果集返回给客户端。如果mysql任何一个表中的任何一条数据发生了变化，便会通知query cache需要与该table相关的query的cache全部失效，并释放占用的内存地址。 &gt; query cache优缺点 &gt;&gt; 1. query语句的hash计算和hash查找带来的资源消耗。mysql会对每条接收到的select类型的query进行hash计算然后查找该query的cache是否存在，虽然hash计算和查找的效率已经足够高了，一条query所带来的消耗可以忽略，但一旦涉及到高并发，有成千上万条query时，hash计算和查找所带来的开销就的重视了； &gt;&gt; 2. query cache的失效问题。如果表变更比较频繁，则会造成query cache的失效率非常高。表变更不仅仅指表中的数据发生变化，还包括结构或者索引的任何变化； &gt;&gt; 3. 对于不同sql但同一结果集的query都会被缓存，这样便会造成内存资源的过渡消耗。sql的字符大小写、空格或者注释的不同，缓存都是认为是不同的sql（因为他们的hash值会不同）； &gt;&gt; 4. 相关参数设置不合理会造成大量内存碎片，相关的参数设置会稍后介绍。<br>*<br>1. readbuffersize &gt;是MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。readbuffersize变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。</p><h1 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</h1><ul><li>由于utf8的每个字符最多占用3个字节。而MySQL定义行的长度不能超过65535，因此N的最大值计算方法为：(65535-1-2)/3。减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</li></ul><h1 id="SELECT-和-SELECT-全部字段-的2种写法有何优缺点"><a href="#SELECT-和-SELECT-全部字段-的2种写法有何优缺点" class="headerlink" title="[SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?"></a>[SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?</h1><p>*<br>1. 前者要解析数据字典，后者不需要<br>*<br>1. 结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。<br>*<br>1. 表字段改名，前者不需要修改，后者需要改<br>*<br>1. 后者可以建立索引进行优化，前者无法优化<br>*<br>1. 后者的可读性比前者要高</p><h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><p>*<br>1. 语法上：where 用表中列名，having用select结果别名<br>*<br>1. 影响结果范围：where从表读出数据的行数，having返回客户端的行数<br>*<br>1. 索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作<br>*<br>1. where后面不能使用聚集函数，having是专门使用聚集函数的。</p><h1 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h1><ul><li>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;</li></ul><h1 id="MySQL的insert和update的select语句语法"><a href="#MySQL的insert和update的select语句语法" class="headerlink" title="MySQL的insert和update的select语句语法"></a>MySQL的insert和update的select语句语法</h1><pre><code>SQL insert into student (stuid,stuname,deptid) select 10,&#39;xzm&#39;,3 from student where stuid &gt; 8;
update student a inner join student b on b.stuID=10 set a.stuname=concat(b.stuname, b.stuID) where a.stuID=10 ; 
</code></pre><h1 id="谈谈MySQL支持的事务隔离级别？"><a href="#谈谈MySQL支持的事务隔离级别？" class="headerlink" title="谈谈MySQL支持的事务隔离级别？"></a>谈谈MySQL支持的事务隔离级别？</h1><ul><li>典型回答: MySQL数据库事务隔离级别分为四个不同层次:</li><li>读未提交: 一个事务能够读取其他事务未提交的修改的数据,这是最低的隔离水平,允许 脏读出现。</li><li>脏读的场景：</li></ul><table><thead><tr><th>时间顺序</th><th>转账事务</th><th>取款事务</th></tr></thead><tbody><tr><td>1</td><td></td><td>开始事务</td></tr><tr><td>2</td><td>开始事务</td><td></td></tr><tr><td>3</td><td></td><td>查询账户余额为2000元</td></tr><tr><td>4</td><td></td><td>取款1000元，余额被更改为1000元</td></tr><tr><td>5</td><td>查询账户余额为1000元（产生脏读）</td><td></td></tr><tr><td>6</td><td></td><td>取款操作发生未知错误，事务回滚，余额变更为2000元</td></tr><tr><td>7</td><td>转入2000元，余额被更改为3000元（脏读的1000+2000）</td><td></td></tr><tr><td>8</td><td>提交事务</td><td></td></tr><tr><td>备注</td><td>按照正确逻辑，此时账户余额应该为4000元</td><td></td></tr></tbody></table><ul><li>读已提交: 一个事务能够读取其他事务已经提交的修改的数据,脏读不会出现。但是隔离 级别比较低,允许出现不可重复读和幻象读。</li><li>不可重读的场景:</li></ul><table><thead><tr><th>时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td>第一次查询，小明的年龄为20岁</td><td></td></tr><tr><td>3</td><td></td><td>开始事务</td></tr><tr><td>4</td><td>其他操作</td><td></td></tr><tr><td>5</td><td></td><td>更改小明的年龄为30岁</td></tr><tr><td>6</td><td></td><td>提交事务</td></tr><tr><td>7</td><td>第二次查询，小明的年龄为30岁</td><td></td></tr><tr><td>备注</td><td>按照正确逻辑，事务A前后两次读取到的数据应该一致</td><td></td></tr></tbody></table><ul><li>可重复读： 一个事务读取到另一个事务已经提交的数据,隔离级别比较高,允许出现幻读。</li><li>幻读的场景：</li></ul><table><thead><tr><th>时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td>第一次查询，数据总量为100条</td><td></td></tr><tr><td>3</td><td></td><td>开始事务</td></tr><tr><td>4</td><td>其他操作</td><td></td></tr><tr><td>5</td><td></td><td>新增100条数据</td></tr><tr><td>6</td><td></td><td>提交事务</td></tr><tr><td>7</td><td>第二次查询，数据总量为200条</td><td></td></tr><tr><td>备注</td><td>按照正确逻辑，事务A前后两次读取到的数据总量应该一致</td><td></td></tr></tbody></table><ul><li>这也是MySQL InnoDB引擎的默认隔离级别,但是和一些其他的数据库不同,可以简单的认为 MySQL在可重复读级别不会出现幻读。</li><li>串行化: 并发事务之间是串行化的,通常意味着读取需要共享读锁,更新需要获取排他写 锁。这是最高的隔离级别。</li><li>不可重复读和幻读到底有什么区别呢？<ul><li>（1）不可重复读是读取了其他事务更改的数据，针对update操作 解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许 其他事务更改刚才的数据。</li><li>（2）幻读是读取了其他事务新增的数据，针对insert操作 解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才 允许其他事务新增数据。</li></ul></li></ul><h1 id="Mysql-中有哪几种锁？"><a href="#Mysql-中有哪几种锁？" class="headerlink" title="Mysql 中有哪几种锁？"></a>Mysql 中有哪几种锁？</h1><p>*<br>1. 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>*<br>1. 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低， 并发度也最高。<br>*<br>1. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和 行锁之间，并发度一般。</p><h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><p>共有 5 种类型的表格：</p><ul><li>MyISAM</li><li>Heap</li><li>Merge</li><li>INNODB</li><li>ISAM</li></ul><h1 id="简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别"><a href="#简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别" class="headerlink" title="简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别"></a>简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别</h1><ul><li>MyISAM：<ul><li>不支持事务，但是每次查询都是原子的； 支持表级锁，即每次操作是对整个表加锁； 存储表的总行数；</li><li>一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；</li><li>采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本 一致，但是辅索引不用保证唯一性。</li></ul></li><li>InnoDb：<ul><li>支持 ACID 的事务，支持事务的四种隔离级别； 支持行级锁及外键约束：因此可以支持写并发； 不存储总行数；</li><li>一个 InnoDb 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一 个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系 统文件大小限制，一般为 2G），受操作系统文件大小的限制；</li><li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最 好使用自增主键，防止插入数据时，为维持 B+树结构，文件的大调整。</li></ul></li></ul><h1 id="Mysql-中-InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#Mysql-中-InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</h1><ul><li>SQL 标准定义的四个隔离级别为：<ul><li>read uncommited ：读到未提交数据</li><li>read committed：脏读，不可重复读</li><li>repeatable read：可重读</li><li>serializable ：串行事物</li></ul></li></ul><h1 id="CHAR-和-VARCHAR-的区别？"><a href="#CHAR-和-VARCHAR-的区别？" class="headerlink" title="CHAR 和 VARCHAR 的区别？"></a>CHAR 和 VARCHAR 的区别？</h1><ul><li>1.CHAR 和 VARCHAR 类型在存储和检索方面有所不同</li><li>2.CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255</li><li>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除 尾随空格。</li></ul><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul><li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li><li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li></ul><h1 id="myisamchk-是用来做什么的？"><a href="#myisamchk-是用来做什么的？" class="headerlink" title="myisamchk 是用来做什么的？"></a>myisamchk 是用来做什么的？</h1><ul><li>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。</li></ul><h1 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h1><ul><li>在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。</li><li>MyISAM Static 在受损情况下更容易恢复。</li></ul><h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><p>每当行被更改时，时间戳字段将获取当前时间戳。</p><h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p><h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h1><ul><li>（1）Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。</li><li>（2）用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。</li><li>（3） 避免在索引列上使用计算</li><li>（4）避免在索引列上使用 IS NULL 和 IS NOT NULL</li><li>（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃 使用索引而进行全表扫描</li></ul><p>一、数据库架构原则<br>1.<br>高可用<br>2.<br>3.<br>高性能<br>4.<br>5.<br>一致性<br>6.<br>7.<br>扩展性<br>8.<br>二、常见的数据库架构方案<br>方案一：主备架构，只有主库提供读写服务，备库冗余作故障转移用</p><p>jdbc:mysql://vip:3306/xxdb<br>1、高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库。这个过程对业务层是透明的，无需修改代码或配置。 <br>2、高性能分析：读写都操作主库，很容易产生瓶颈。大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能。另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 <br>3、一致性分析：读写都操作主库，不存在数据一致性问题。 <br>4、扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 <br>5、可落地分析：两点影响落地使用。第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案。第二，扩展性差，这点可以通过分库分表来扩展。<br>方案二：双主架构，两个主库同时提供服务，负载均衡</p><p>jdbc:mysql://vip:3306/xxdb<br>1、高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务。这个过程对业务层是透明的，无需修改代码或配置。 <br>2、高性能分析：读写性能相比于方案一都得到提升，提升一倍。<br>3、一致性分析：存在数据一致性问题。请看，一致性解决方案。 <br>4、扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）。如果非得在数据库架构层面扩展的话，扩展为方案四。 <br>5、可落地分析：两点影响落地使用。第一，数据一致性问题，一致性解决方案可解决问题。第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。<br>方案三：主从架构，一主多从，读写分离</p><p>jdbc:mysql://master-ip:3306/xxdb</p><p> jdbc:mysql://slave1-ip:3306/xxdb</p><p> jdbc:mysql://slave2-ip:3306/xxdb<br>1、高可用分析：主库单点，从库高可用。一旦主库挂了，写服务也就无法提供。 <br>2、高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能。读的性能提高了，整体性能也提高了。<br>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引<br>（线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引）<br>3、一致性分析：存在数据一致性问题。请看，一致性解决方案。 <br>4、扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。<br>（带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长） <br>5、可落地分析：两点影响落地使用。第一，数据一致性问题，一致性解决方案可解决问题。第二，主库单点问题，笔者暂时没想到很好的解决方案。<br>注：思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？<br>方案四：双主+主从架构，看似完美的方案</p><p>dbc:mysql://vip:3306/xxdb</p><p> jdbc:mysql://slave1-ip:3306/xxdb</p><p> jdbc:mysql://slave2-ip:3306/xxdb<br>1、高可用分析：高可用。 <br>2、高性能分析：高性能。 <br>3、一致性分析：存在数据一致性问题。请看，一致性解决方案 。<br>4、扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） <br>5、可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。<br>三、一致性解决方案<br>第一类：主库和从库一致性解决方案</p><p>注：图中圈出的是数据同步的地方，数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的，这个同步时间内主库和从库的数据会存在不一致的情况。如果同步过程中有读请求，那么读到的就是从库中的老数据。<br>如下图</p><p>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<br>1、直接忽略，如果业务允许延时存在，那么就不去管它。 <br>2、强制读主，采用主备架构方案，读写都走主库。用缓存来扩展数据库读性能 。有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</p><p>3、选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。<br>读请求时，同样的方式生成key先去查Cache，再判断是否命中。若命中，则读主库，否则读从库。代价是多了一次缓存读写，基本可以忽略。</p><p>4、半同步复制，等主从同步完成，写请求才返回。就是大家常说的“半同步复制”semi-sync。这可以利用数据库原生功能，实现比较简单。代价是写请求时延增长，吞吐量降低。 <br>5、数据库中间件，引入开源（mycat等）或自研的数据库中间层。个人理解，思路同选择读主。数据库中间件的成本比较高，并且还多引入了一层。**</p><p>第二类：DB和缓存一致性解决方案</p><p>先来看一下常用的缓存使用方式：<br>第一步：淘汰缓存；<br>第二步：写入数据库；<br>第三步：读取缓存？返回：读取数据库；<br>第四步：读取数据库后写入缓存。<br>注：如果按照这种方式，图一，不会产生DB和缓存不一致问题；图二，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据。解决方式如下：</p><p>注：设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！<br>四、个人的一些见解<br>1、架构演变<br>1、架构演变一：方案一 -&gt; 方案一+分库分表 -&gt; 方案二+分库分表 -&gt; 方案四+分库分表； <br>2、架构演变二：方案一 -&gt; 方案一+分库分表 -&gt; 方案三+分库分表 -&gt; 方案四+分库分表； <br>3、架构演变三：方案一 -&gt; 方案二 -&gt; 方案四 -&gt; 方案四+分库分表； <br>4、架构演变四：方案一 -&gt; 方案三 -&gt; 方案四 -&gt; 方案四+分库分表；<br>2、个人见解<br>1、加缓存和索引是通用的提升数据库性能的方式； <br>2、分库分表带来的好处是巨大的，但同样也会带来一些问题，详见前日推文。<br>3、不管是主备+分库分表还是主从+读写分离+分库分表，都要考虑具体的业务场景。<br>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。<br>另外，阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。 </p><p>两台MySQL数据库数据同步实现<br>做开发的时候要做Mysql的数据库同步，两台安装一样的系统，都是FreeBSD5.4，安装了Apache 2.0.55和PHP 4.4.0，Mysql的版本是4.1.15，都是目前最新的版本。</p><ol><li><p>安装配置<br>两台服务器，分别安装好Mysql，都安装在 /usr/local/mysql 目录下（安装步骤省略，请参考相关文档），两台服务器的IP分别是192.168.0.1和192.168.0.2，我们把192.168.0.1作为master数据库，把192.168.0.2作为slave服务器，我们采用单向同步的方式，就是master的数据是主的数据，然后slave主动去master哪儿同步数据回来。<br>两台服务器的配置一样，我们把关键的配置文件拷贝一下，默认的配置文件是在 /usr/local/mysql/share/mysql目录下，分别有 my-large.cnf, my-medium.cnf, my-small.cnf等几个文家，我们只是测试，使用my-medium.cnf就行了。mysql安装完后，默认的配置文件是指定在数据库存放目录下的，我们用的是4.1.X的，所以配置文件就应该在 /usr/local/mysql/var 目录下，于是把配置文件拷贝过去：<br>cp /usr/local/mysql/share/mysql/my-medium.cnf  /usr/local/mysql/var/my.cnf<br>两台服务器做相同的拷贝配置文件操作。</p></li><li><p>配置Master服务器</p></li></ol><p>我们要把192.168.0.1配置为主mysql服务器（master），那么我们就要考虑我们需要同步那个数据库，使用那个用户同步，我们这里为了简单起见，就使用root用户进行同步，并且只需要同步数据库abc。<br>打开配置文件：<br>vi /usr/local/mysql/var/my.cnf<br>找到一下信息：</p><h1 id="required-unique-id-between-1-and-2-32-1"><a href="#required-unique-id-between-1-and-2-32-1" class="headerlink" title="required unique id between 1 and 2^32 - 1"></a>required unique id between 1 and 2^32 - 1</h1><h1 id="defaults-to-1-if-master-host-is-not-set"><a href="#defaults-to-1-if-master-host-is-not-set" class="headerlink" title="defaults to 1 if master-host is not set"></a>defaults to 1 if master-host is not set</h1><h1 id="but-will-not-function-as-a-master-if-omitted"><a href="#but-will-not-function-as-a-master-if-omitted" class="headerlink" title="but will not function as a master if omitted"></a>but will not function as a master if omitted</h1><p>server-id        = 1    //1为master，2为salve<br>添加两行：<br>sql-bin-update-same     //同步形式<br>binlog-do-db     = abc  //要同步的数据库<br>重启192.168.0.1的mysql服务器：<br>/usr/local/mysql/bin/mysqladmin shutdown<br>/usr/local/mysql/bin/mysqld_safe –user=mysql &amp;</p><ol start="3"><li><p>配置Slave服务器<br>我们的slave服务器主要是主动去master服务器同步数据回来，我们编辑配置文件：<br>vi /usr/local/mysql/var/my.cnf<br>找到下面类似的信息：</p><h1 id="required-unique-id-between-1-and-2-32-1-1"><a href="#required-unique-id-between-1-and-2-32-1-1" class="headerlink" title="required unique id between 1 and 2^32 - 1"></a>required unique id between 1 and 2^32 - 1</h1><h1 id="defaults-to-1-if-master-host-is-not-set-1"><a href="#defaults-to-1-if-master-host-is-not-set-1" class="headerlink" title="defaults to 1 if master-host is not set"></a>defaults to 1 if master-host is not set</h1><h1 id="but-will-not-function-as-a-master-if-omitted-1"><a href="#but-will-not-function-as-a-master-if-omitted-1" class="headerlink" title="but will not function as a master if omitted"></a>but will not function as a master if omitted</h1><p>server-id        = 1<br>把上面的server-id修改为2，同时添加一些信息：<br>server-id                   = 2                        //本Mysql是slave服务器<br>master-host             = 192.168.0.1    //master服务器的IP<br>master-user             = root                  //连接master服务器的用户<br>master-password   = ‘’                        //连接master服务器的密码<br>master-port              = 3306                //连接端口<br>master-connect-retry    = 10              //重试次数<br>replicate-do-db        = abc                  //要同步的数据库<br>log-slave-updates                              //同步的形式<br>重启192.168.0.2的mysql服务器：<br>/usr/local/mysql/bin/mysqladmin shutdown<br>/usr/local/mysql/bin/mysqld_safe –user=mysql &amp;</p></li><li><p>测试安装</p></li></ol><p>首先查看一下slave的主机日志：<br>cat /usr/local/mysql/var/xxxxx_err （xxx是主机名）<br>检查是否连接正常, 看到类似这样的信息就成功了<br>051031 11:42:40  mysqld started<br>051031 11:42:41  InnoDB: Started; log sequence number 0 43634<br>/usr/local/mysql/libexec/mysqld: ready for connections.<br>Version: ‘4.1.15-log’  socket: ‘/tmp/mysql.sock’  port: 3306  Source distribution<br>051031 11:42:41 [Note] Slave SQL thread initialized, starting replication in log ‘FIRST’ at position 0, relay log ‘./new4-relay-bin.000001’ position: 4<br>051031 11:43:21 [Note] Slave I/O thread: connected to master ‘<a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#x31;&#x39;&#x32;&#46;&#x31;&#x36;&#56;&#x2e;&#x30;&#46;&#49;">&#x72;&#111;&#111;&#116;&#x40;&#x31;&#x39;&#x32;&#46;&#x31;&#x36;&#56;&#x2e;&#x30;&#46;&#49;</a>:3306’,  replication started in log ‘FIRST’ at position 4<br>在Master查看信息<br>/usr/local/mysql/bin/mysql -u root<br>查看master状态：<br>mysql&gt; show master status;<br>查看Master下mysql进程信息：<br>mysql&gt; show processlist;</p><p>在slave上查看信息：<br>/usr/local/mysql/bin/mysql -u root<br>查看slave状态：<br>mysql&gt; show slave status;<br>查看slave下mysql进程信息：<br>mysql&gt; show processlist;<br>你再在master的abc库里建立表结构并且插入数据，然后检查slave有没有同步这些数据，就能够检查出是否设置成功。</p><p>最后，如果有兴趣的话，可以研究一下双击热备份，或者一台master，多台slave的同步实现。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/4a23c7da79c0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/4a23c7da79c0.html" class="post-title-link" itemprop="url">Spring cloud</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:16:45 / 修改时间：16:23:51" itemprop="dateCreated datePublished" datetime="2023-12-20T15:16:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring-cloud/" itemprop="url" rel="index"><span itemprop="name">Spring cloud</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h1><ul><li>Spring Cloud 是一个基于 Spring Boot 的开发工具集</li><li>专为构建微服务架构而设计</li><li>它提供了一系列的工具和框架，使开发、部署和维护微服务变得更加简单和高效</li></ul><h1 id="Spring-Cloud-的一些核心概念"><a href="#Spring-Cloud-的一些核心概念" class="headerlink" title="Spring Cloud 的一些核心概念"></a>Spring Cloud 的一些核心概念</h1><ul><li>配置管理: Spring Cloud 提供工具来统一管理和维护在多个环境中的微服务配置，如开发、测试和生产环境。</li><li>服务发现: 它集成了服务发现服务器，如 Eureka，使得微服务可以自动注册自己并发现其他服务。</li><li>负载均衡: 通过集成 Ribbon 和其他工具，Spring Cloud 提供客户端侧的负载均衡，帮助分发请求到不同的实例。</li><li>断路器: 通过 Hystrix，Spring Cloud 提供了断路器模式，以确保在某个服务出现问题时，不会导致整个系统的崩溃。</li><li>API 网关: 通过 Zuul，Spring Cloud 提供了API网关解决方案，用于请求路由、过滤和负载均衡。</li><li>分布式跟踪: Spring Cloud 集成了 Zipkin 和 Sleuth，为微服务架构提供分布式日志追踪。</li><li>分布式数据管理: 提供了工具来处理在微服务架构中的数据一致性和分布式事务问题。</li><li>集成和适配: Spring Cloud 与许多常见的云平台和服务深度集成，例如 AWS、GCP 和 Azure，使得部署和管理微服务更加简单。</li></ul><h1 id="使用Spring-Cloud有什么优势"><a href="#使用Spring-Cloud有什么优势" class="headerlink" title="使用Spring Cloud有什么优势"></a>使用Spring Cloud有什么优势</h1><ul><li>耦合度比较低。不会影响其他模块的开发</li><li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</li><li>配置比较简单，基本用注解就能实现，不用使用过多的配置文件</li><li>微服务跨平台的，可以用任何一种语言开发</li><li>每个微服务可以有自己的独立的数据库也有用公共的数据库</li><li>直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</li></ul><h1 id="服务注册和发现是什么意思？Spring-Cloud如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud如何实现？"></a>服务注册和发现是什么意思？Spring Cloud如何实现？</h1><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><ul><li>服务注册：将服务实例的信息注册到服务注册中心</li><li>在微服务架构中，每个服务都是独立运行的，需要通过服务注册中心来管理和调用</li><li>服务注册中心是一个集中的服务实例的注册和发现的地方</li><li>当一个服务实例启动时，它会向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号等</li><li>其他服务可以通过服务注册中心查询到需要调用的服务的信息，从而实现服务之间的通信</li><li>Spring Cloud提供了多个服务注册中心的实现，如Eureka、Consul和Zookeeper，其中，Eureka是Spring Cloud的默认选择</li><li>每个服务实例在启动时，会向Eureka服务器注册自己的信息</li><li>Eureka服务器会维护一个服务注册表，用于保存所有已注册的服务实例信息</li><li>其他服务可以通过查询服务注册表来获取需要调用的服务的相关信息</li><li>服务注册的优势在于解耦了服务之间的直接依赖关系，使得服务之间可以动态地发现和调用</li><li>通过服务注册，可以实现服务的高可用性和负载均衡，当某个服务实例不可用时，可以自动剔除或替换，从而保证整个系统的稳定性和可靠性</li><li>同时，服务注册还能提供服务的版本管理、动态扩缩容等功能，为微服务架构带来更大的灵活性和可扩展性</li></ul><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul><li>服务发现是指在微服务架构中，通过服务注册中心来查询和发现可用的服务实例</li><li>在传统的单体应用中，服务的调用通常是通过硬编码的方式实现的，而在微服务架构中，由于服务实例的数量和位置可能会动态变化，因此需要一种机制来动态地发现和调用服务</li><li>Spring Cloud提供了多个服务发现的实现，例如Eureka、Consul和Zookeeper</li><li>服务发现的基本流程如下<ul><li>服务注册：当一个服务实例启动时，它会向服务注册中心注册自己的信息，包括服务名称、IP地址、端口号等。注册后，服务注册中心会维护一个服务注册表，记录所有已注册的服务实例</li><li>服务查询：当需要调用某个服务时，服务消费者可以通过服务注册中心查询到该服务的可用实例信息。服务消费者可以根据需要的负载均衡策略，选择一个合适的服务实例进行调用。</li><li>服务调用：服务消费者通过获取到的服务实例信息，可以直接向服务提供者发送请求，进行服务调用。服务消费者可以通过负载均衡、容错机制等手段，提高系统的可用性和稳定性。</li></ul></li></ul><h1 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h1><ul><li>负载平衡的作用<ul><li>提高系统性能：通过将请求分发到多个服务器上，负载平衡可以避免单一服务器的过载情况，从而提高系统的整体吞吐量和响应速度。</li><li>增加系统可靠性：当某个服务器发生故障或不可用时，负载平衡可以将请求转发到其他正常工作的服务器上，确保系统的可用性和稳定性。</li><li>实现扩展性：负载平衡可以根据实际需求，添加或移除服务器，以适应流量的增加或减少，从而实现系统的弹性扩展。</li><li>实现会话保持：负载平衡可以确保同一个用户的连续请求都被转发到同一个服务器上，以保持用户会话的状态。</li></ul></li><li>常见的负载平衡算法有轮询、随机、最少连接等<ul><li>轮询算法是将请求按照顺序依次分发到每个服务器上</li><li>随机算法是随机选择一个服务器来处理请求</li><li>最少连接算法是将请求分发到当前连接数最少的服务器上</li></ul></li><li>负载平衡可以通过硬件设备（如负载均衡器）或软件方式实现，常用的软件负载均衡工具有Nginx、HAProxy、SpringCloud的Ribbon等。这些工具可以根据实际需求和场景选择，以提供高效的负载平衡服务。</li></ul><h1 id="什么是Hystrix？它如何实现容错？"><a href="#什么是Hystrix？它如何实现容错？" class="headerlink" title="什么是Hystrix？它如何实现容错？"></a>什么是Hystrix？它如何实现容错？</h1><ul><li>hystrix是Netlifx开源的一款容错框架，防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控(Hystrix Dashboard)等功能</li></ul><h4 id="hystrix被设计的目标"><a href="#hystrix被设计的目标" class="headerlink" title="hystrix被设计的目标"></a>hystrix被设计的目标</h4><ul><li>对通过第三方客户端库访问的依赖项（通常是通过网络）的延迟和故障进行保护和控制。</li><li>在复杂的分布式系统汇中阻止级联故障。</li><li>快速失败，快速恢复。</li><li>回退，尽可能优雅的降级。</li><li>启用近实时监控、警报和操作控制。</li></ul><h4 id="Hystrix使用场景"><a href="#Hystrix使用场景" class="headerlink" title="Hystrix使用场景"></a>Hystrix使用场景</h4><ul><li>调用超时时间比你自己定义的阈值要长。</li><li>线程池满了，该以来应该立即拒绝请求，而不是排队</li><li>在一段时间内，如果服务的错误百分比超过了一个阈值，就会触发一个断路器来停止对特定服务的所有请求，无论是手动还是自动的</li></ul><h4 id="Hystrix如何解决依赖隔离"><a href="#Hystrix如何解决依赖隔离" class="headerlink" title="Hystrix如何解决依赖隔离"></a>Hystrix如何解决依赖隔离</h4><ul><li>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行。</li><li>可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</li><li>为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</li><li>依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</li><li>提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</li><li>提供近实时依赖的统计和监控</li></ul><h1 id="什么是Netflix-Feign？它的优点是什么？"><a href="#什么是Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是Netflix Feign？它的优点是什么？"></a>什么是Netflix Feign？它的优点是什么？</h1><h4 id="Feign是什么"><a href="#Feign是什么" class="headerlink" title="Feign是什么"></a>Feign是什么</h4><ul><li>Feign 是 Spring Cloud Netflix 组件中的一个轻量级 RESTful 的 HTTP 服务客户端</li><li>实现了负载均衡和 Rest 调用的开源框架</li><li>封装了 Ribbon 和 RestTemplate</li><li>实现了 WebService的面向接口编程，进一步降低了项目的耦合度</li><li>Feign 内置了 Ribbon，用来做客户端负载均衡调用服务注册中心的服务</li><li>Feign 本身并不支持 Spring MVC 的注解，它有一套自己的注解，为了更方便的使用，Spring Cloud 孵化了 OpenFeign</li><li>Feign 是一种声明式、模板化的 HTTP 客户端（仅在 Consumer 中使用）</li><li>Feign 的使用方式是：使用 Feign 的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。</li></ul><h4 id="Feign解决了什么问题"><a href="#Feign解决了什么问题" class="headerlink" title="Feign解决了什么问题"></a>Feign解决了什么问题</h4><ul><li>Feign 旨在使编写 JAVA HTTP 客户端变得更加容易</li><li>Feign 简化了 RestTemplate 代码，实现了 Ribbon负载均衡，使代码变得更加简洁，也少了客户端调用的代码，使用 Feign 实现负载均衡是首选方案</li><li>只需要你创建一个接口，然后在上面添加注解即可</li><li>Feign 是声明式服务调用组件，其核心就是：像调用本地方法一样调用远程方法，无感知远程 HTTP 请求</li><li>它解决了让开发者调用远程接口就跟调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP请求</li><li>无需关注与远程的交互细节，更无需关注分布式环境开发</li><li>它像 Dubbo 一样，Consumer 直接调用 Provider 接口方法，而不需要通过常规的 Http Client 构造请求再解析返回数据</li></ul><h1 id="什么是Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是Spring Cloud Bus？我们需要它吗？"></a>什么是Spring Cloud Bus？我们需要它吗？</h1><h4 id="什么是Spring-Cloud-Bus"><a href="#什么是Spring-Cloud-Bus" class="headerlink" title="什么是Spring Cloud Bus"></a>什么是Spring Cloud Bus</h4><ul><li>Spring Cloud Bus是Spring Cloud提供的一种用于实现分布式系统中消息传递和事件驱动的组件</li><li>Spring Cloud Bus是基于消息代理的分布式系统消息总线</li><li>它利用轻量级消息代理来连接各个分布式节点，实现节点之间的消息传递和事件驱动</li><li>Spring Cloud Bus的核心思想是通过消息广播机制，使得一次配置更新可以触发所有相关节点的配置刷新，从而实现分布式系统的配置管理和动态更新</li><li>通过消息广播机制和消息代理，它可以实现配置的动态刷新、事件的传递和驱动，以及系统的监控与管理</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li><p>引入依赖：在项目的pom.xml文件中添加Spring Cloud Bus相关的依赖</p><pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre></li><li><p>配置消息代理：在Spring Cloud配置文件中配置消息代理的地址和相关参数</p><pre><code>spring:
rabbitmq:
  host: localhost
  port: 5672
  username: guest
  password: guest
</code></pre></li><li><p>注册消息总线端点：在Spring Boot应用程序中注册消息总线的端点</p><pre><code>@SpringBootApplication
@EnableDiscoveryClient
@RestController
public class MyApp &#123;

  @Autowired
  private RefreshEndpoint refreshEndpoint;

  @PostMapping(&quot;/refresh&quot;)
  public void refresh() &#123;
      refreshEndpoint.refresh();
  &#125;

  public static void main(String[] args) &#123;
      SpringApplication.run(MyApp.class, args);
  &#125;
&#125;
</code></pre></li><li><p>刷新配置：通过发送POST请求到消息总线端点来触发配置的刷新</p><pre><code>RestTemplate restTemplate = new RestTemplate();
restTemplate.postForObject(&quot;http://localhost:8080/refresh&quot;, null, Void.class);
</code></pre></li></ul><h4 id="Spring-Cloud-Bus的核心组件"><a href="#Spring-Cloud-Bus的核心组件" class="headerlink" title="Spring Cloud Bus的核心组件"></a>Spring Cloud Bus的核心组件</h4><ul><li>消息代理：用于转发消息和事件的中间件，如RabbitMQ、Kafka等。</li><li>消息总线：通过消息代理将消息广播给所有相关节点。</li><li>消息生成器：用于生成和发送消息的组件。</li><li>消息接收器：用于接收和处理消息的组件。</li></ul><h4 id="Spring-Cloud-Bus的作用"><a href="#Spring-Cloud-Bus的作用" class="headerlink" title="Spring Cloud Bus的作用"></a>Spring Cloud Bus的作用</h4><ul><li>配置刷新：通过消息广播机制，实现配置的动态刷新，避免了每个节点都需要手动刷新配置的问题</li><li>事件驱动：通过消息代理的发布-订阅模式，实现事件的传递和驱动，使得各个节点能够响应和处理特定的事件</li><li>监控与管理：可以通过消息总线来收集系统的监控数据和指标，实现分布式系统的集中管理和监控</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/8270315bab4b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/8270315bab4b.html" class="post-title-link" itemprop="url">Java虚拟机（JVM）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:08:40 / 修改时间：15:09:12" itemprop="dateCreated datePublished" datetime="2023-12-20T15:08:40+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="gc概述"><a href="#gc概述" class="headerlink" title="gc概述"></a>gc概述</h1><ul><li>垃圾收集机制是指jvm用于释放那些不再使用的对象所占用的内存</li><li>java语言并不要求jvm有gc，也没有规定gc如何工作</li><li>不过常用的jvm都有gc，而且大多数gc都使用类似的算法管理内存和执行收集操作</li><li>垃圾收集的目的在于清除不再使用的对象</li><li>gc通过确定对象是否被活动对象引用来确定是否收集该对象</li><li>gc首先要判断该对象是否是时候可以收集，两种常用的方法是引用计数和对象引用遍历<ul><li>引用计数<ul><li>引用计数存储对特定对象的所有引用数</li><li>当应用程序创建引用以及引用超出范围时，jvm必须适当增减引用数</li><li>当某对象的引用数为0时，便可以进行垃圾收集</li></ul></li><li>对象引用遍历<ul><li>早期的jvm使用引用计数，现在大多数jvm采用对象引用遍历</li><li>对象引用遍历从一组对象（GC ROOT）开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象</li><li>如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集</li><li>在对象遍历阶段，gc必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象</li><li>下一步，gc要删除不可到达的对象</li><li>删除时，有些gc只是简单的扫描堆栈，删除未标记的对象，并释放它们的内存以生成新的对象，这叫做清除（sweeping）</li><li>这种方法的问题在于内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大</li><li>因此，许多gc可以重新组织内存中的对象，并进行压缩（compact），形成可利用的空间</li><li>为此，gc需要停止其他的活动活动，这种方法意味着所有与应用程序相关的工作停止，只有gc运行，结果，在响应期间增减了许多混杂请求</li><li>另外，更复杂的gc不断增加或同时运行以减少或者清除应用程序的中断，有的gc使用单线程完成这项工作，有的则采用多线程以增加效率。</li><li>java中可作为GC Root的对象有<ul><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native对象）</li></ul></li></ul></li></ul></li><li>有3个内存区域是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。</li></ul><h1 id="几种垃圾回收机制"><a href="#几种垃圾回收机制" class="headerlink" title="几种垃圾回收机制"></a>几种垃圾回收机制</h1><h4 id="标记-清除收集器"><a href="#标记-清除收集器" class="headerlink" title="标记-清除收集器"></a>标记-清除收集器</h4><ul><li>这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存</li><li>这种收集器一般使用单线程工作并停止其他操作</li><li>标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片</li></ul><h4 id="标记-压缩收集器"><a href="#标记-压缩收集器" class="headerlink" title="标记-压缩收集器"></a>标记-压缩收集器</h4><ul><li>有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段</li><li>在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈</li><li>这种收集器也停止其他操作</li><li>由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。（该算法适用于旧生代）</li></ul><h4 id="复制收集器"><a href="#复制收集器" class="headerlink" title="复制收集器"></a>复制收集器</h4><ul><li>这种收集器将堆栈分为两个域，常称为半空间</li><li>每次仅使用一半的空间，jvm生成的新对象则放在另一半空间中</li><li>gc运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈</li><li>这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低</li><li>复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域</li><li>当存活的对象较少时，复制算法会比较高效（新生代的Eden区就是采用这种算法），其带来的成本是需要一块额外的空闲空间和对象的移动</li></ul><h4 id="增量收集器"><a href="#增量收集器" class="headerlink" title="增量收集器"></a>增量收集器</h4><ul><li>增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾</li><li>这会造成较小的应用程序中断</li></ul><h4 id="分代收集器"><a href="#分代收集器" class="headerlink" title="分代收集器"></a>分代收集器</h4><ul><li>这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象</li><li>jvm生成的新对象一般放在其中的某个域中，过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中</li><li>分代收集器对不同的域使用不同的算法以优化性能</li></ul><h4 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h4><ul><li>并发收集器与应用程序同时运行</li><li>这些收集器在某点上（比如压缩时）一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低</li></ul><h4 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h4><ul><li>并行收集器使用某种传统的算法并使用多线程并行的执行它们的工作</li><li>在多cpu机器上使用多线程技术可以显著的提高java应用程序的可扩展性</li></ul><h1 id="Sun-HotSpot"><a href="#Sun-HotSpot" class="headerlink" title="Sun HotSpot"></a>Sun HotSpot</h1><ul><li>Sun HotSpot 使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域</li><li>Jvm生成的所有新对象放在新域中</li><li>一旦对象经历了一定数量的垃圾收集循环后，便获得使用期并进入旧域</li><li>在永久域中jvm则存储class和method对象</li><li>就配置而言，永久域是一个独立域并且不认为是堆的一部分</li><li>可使用-Xms和-Xmx 控制整个堆的原始大小或最大值</li><li>默认状态下，HotSpot在新域中使用复制收集器，该域一般分为三个部分<ul><li>第一部分为Eden，用于生成新的对象</li><li>另两部分称为救助空间，当Eden充满时，收集器停止应用程序，把所有可到达对象复制到当前的from救助空间，一旦当前的from救助空间充满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们获得使用期并转入旧域</li></ul></li><li>默认状态下HotSpot对新域使用复制收集器，对旧域使用标记－清除－压缩收集器</li><li>在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。如果能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价</li></ul><h1 id="如何从JVM中获取信息来进行调整"><a href="#如何从JVM中获取信息来进行调整" class="headerlink" title="如何从JVM中获取信息来进行调整"></a>如何从JVM中获取信息来进行调整</h1><ul><li>-verbose.gc开关可显示gc的操作内容。打开它，可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等。</li><li>打开-xx：+ printgcdetails开关，可以详细了解gc中的变化</li><li>打开-XX： + PrintGCTimeStamps开关，可以了解这些垃圾收集发生的时间，自jvm启动以后以秒计量</li><li>通过-xx： + PrintHeapAtGC开关了解堆的更详细的信息</li><li>为了了解新域的情况，可以通过-XX：=PrintTenuringDistribution开关了解获得使用期的对象权。</li></ul><h1 id="查看配置JVM内存信息"><a href="#查看配置JVM内存信息" class="headerlink" title="查看配置JVM内存信息"></a>查看配置JVM内存信息</h1><ul><li>Runtime.getRuntime().maxMemory();//最大可用内存，对应-Xmx</li><li>Runtime.getRuntime().freeMemory();//当前JVM空闲内存</li><li>Runtime.getRuntime().totalMemory();//当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和<h4 id="关于maxMemory-，freeMemory-和totalMemory-："><a href="#关于maxMemory-，freeMemory-和totalMemory-：" class="headerlink" title="关于maxMemory()，freeMemory()和totalMemory()："></a>关于maxMemory()，freeMemory()和totalMemory()：</h4></li><li>maxMemory()为JVM的最大可用内存，可通过-Xmx设置，默认值为物理内存的1/4，设值不能高于计算机物理内存；</li><li>totalMemory()为当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和，会随着JVM使用内存的增加而增加；</li><li>freeMemory()为当前JVM空闲内存，因为JVM只有在需要内存时才占用物理内存使用，所以freeMemory()的值一般情况下都很小，而JVM实际可用内存并不等于freeMemory()，而应该等于maxMemory()-totalMemory()+freeMemory()。及其配置JVM内存分配。</li></ul><h1 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h1><ul><li>JVM的新生代、老年代、MinorGC、MajorGC</li><li>JVM中的堆，一般分为三大部分：新生代、老年代、永久代</li></ul><h4 id="新生代（Youn-Generation）"><a href="#新生代（Youn-Generation）" class="headerlink" title="新生代（Youn Generation）"></a>新生代（Youn Generation）</h4><ul><li>主要是用来存放新生的对象</li><li>一般占据堆的1/3空间</li><li>由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收</li><li>新生代又分为 Eden区、ServivorFrom、ServivorTo三个区<ul><li>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收</li><li>ServivorTo：保留了一次MinorGC过程中的幸存者</li><li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者</li></ul></li><li>当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。</li><li>MinorGC的过程：采用复制算法<ul><li>首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则赋值到老年代区）</li><li>同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）</li><li>然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</li></ul></li><li>新建的对象都是从新生代分配内存，Eden区不足的时候，会把存活的对象转移到Survivor区</li></ul><h4 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h4><ul><li>老年代的对象比较稳定，所以MajorGC不会频繁执行</li><li>在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发</li><li>当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间</li><li>MajorGC采用标记—清除算法：<ul><li>首先扫描一次所有老年代，标记出存活的对象</li><li>然后回收没有标记的对象</li></ul></li><li>MajorGC的耗时比较长，因为要扫描再回收</li><li>MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配</li><li>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常</li><li>旧生代用于存放新生代多次回收依然存活的对象，如缓存对象。当旧生代满了的时候就需要对旧生代进行回收，旧生代的垃圾回收称作Major GC</li></ul><h4 id="永久代（Permanent-Generation）"><a href="#永久代（Permanent-Generation）" class="headerlink" title="永久代（Permanent Generation）"></a>永久代（Permanent Generation）</h4><ul><li>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息</li><li>Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常</li><li>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现</li><li>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</li><li>类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中</li><li>这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制</li><li>在Sun 的JVM中就是方法区的意思，尽管大多数JVM没有这一代</li></ul><h4 id="Major-GC和Full-GC区别"><a href="#Major-GC和Full-GC区别" class="headerlink" title="Major GC和Full GC区别"></a>Major GC和Full GC区别</h4><ul><li>Full GC：收集young gen、old gen、perm gen</li><li>Major GC：有时又叫old gc，只收集old gen</li></ul><h1 id="常⽤的GC策略和触发时机"><a href="#常⽤的GC策略和触发时机" class="headerlink" title="常⽤的GC策略和触发时机"></a>常⽤的GC策略和触发时机</h1><h4 id="YGC-Young-GC"><a href="#YGC-Young-GC" class="headerlink" title="YGC(Young GC)"></a>YGC(Young GC)</h4><ul><li>概念：对新⽣代堆进⾏GC。频率⽐较⾼，因为⼤部分对象的存活寿命较短，在新⽣代⾥被回收。性能耗费较⼩。</li><li>触发时机：Eden区空间不⾜</li></ul><h4 id="FGC-Full-GC"><a href="#FGC-Full-GC" class="headerlink" title="FGC(Full GC)"></a>FGC(Full GC)</h4><ul><li>概念：全堆范围的GC。默认堆空间使⽤到达80%(可调整)的时候会触发FGC。以我们⽣产环境为例，⼀般⽐较少会触发FGC，有时10天或⼀周左右会有⼀次。</li><li>触发时机：<ul><li>Old空间不⾜</li><li>Perm空间不⾜</li></ul></li></ul><h4 id="显示调⽤System-gc-，包括RMI等的定时触发"><a href="#显示调⽤System-gc-，包括RMI等的定时触发" class="headerlink" title="显示调⽤System.gc() ，包括RMI等的定时触发"></a>显示调⽤System.gc() ，包括RMI等的定时触发</h4><h4 id="YGC时的悲观策略"><a href="#YGC时的悲观策略" class="headerlink" title="YGC时的悲观策略"></a>YGC时的悲观策略</h4><h4 id="dump-live的内存信息时-jmap-–dump-live-。"><a href="#dump-live的内存信息时-jmap-–dump-live-。" class="headerlink" title="dump live的内存信息时(jmap –dump:live)。"></a>dump live的内存信息时(jmap –dump:live)。</h4><h1 id="深入理解JVM–JVM垃圾回收机制"><a href="#深入理解JVM–JVM垃圾回收机制" class="headerlink" title="深入理解JVM–JVM垃圾回收机制"></a>深入理解JVM–JVM垃圾回收机制</h1><h4 id="GC为我们做了什么操作呢？"><a href="#GC为我们做了什么操作呢？" class="headerlink" title="GC为我们做了什么操作呢？"></a>GC为我们做了什么操作呢？</h4><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><h4 id="学习GC作用"><a href="#学习GC作用" class="headerlink" title="学习GC作用"></a>学习GC作用</h4><ul><li>排查内存溢出</li><li>排查内存泄漏</li><li>性能调优，排查并发瓶颈</li></ul><h4 id="什么时候会触发一个对象的回收"><a href="#什么时候会触发一个对象的回收" class="headerlink" title="什么时候会触发一个对象的回收"></a>什么时候会触发一个对象的回收</h4><ul><li>对象没有引用</li><li>作用域发生未捕获异常</li><li>程序在作用域正常执行完毕</li><li>程序执行了System.exit()</li><li>程序发生意外终止（被杀进程等）</li></ul><h1 id="Java中存在四种引用"><a href="#Java中存在四种引用" class="headerlink" title="Java中存在四种引用"></a>Java中存在四种引用</h1><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>只要引用存在，垃圾回收器永远不会回收</li><li>Object obj = new Object();</li><li>new出来的对象都是强引用，GC无论如何都不会回收，即使抛出OOM异常</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul><li>非必须引用，内存溢出之前进行回收，可以通过以下代码实现</li><li>只有当JVM内存不足时才会被回收<br>Object obj = new Object();<br>SoftReference<object>sf = new SoftReference<object>(obj);<br>obj = null;<br>sf.get();//有时候会返回null<br>这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；<br>软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</object></object></li></ul><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul><li>第二次垃圾回收时回收，可以通过如下代码实现<br>Object obj = new Object();<br>WeakReference<object>wf = new WeakReference<object>(obj);<br>obj = null;<br>wf.get();//有时候会返回null<br>wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾<br>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。<br>弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器</object></object></li><li>只要GC,就会立马回收，不管内存是否充足</li></ul><h4 id="虚引用（幽灵-幻影引用）"><a href="#虚引用（幽灵-幻影引用）" class="headerlink" title="虚引用（幽灵/幻影引用）"></a>虚引用（幽灵/幻影引用）</h4><ul><li>垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现<br>Object obj = new Object();<br>PhantomReference<object>pf = new PhantomReference<object>(obj);<br>obj=null;<br>pf.get();//永远返回null<br>pf.isEnQueued();//返回从内存中已经删除<br>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。<br>虚引用主要用于检测对象是否已经从内存中删除。</object></object></li><li>它唯一的作用就是做一些跟踪记录，辅助finalize函数的使用</li></ul><h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><p>JVM把内存划分成了如下几个区域：<br>1.方法区（Method Area）<br>2.堆区（Heap）<br>3.虚拟机栈（VM Stack）<br>4.本地方法栈（Native Method Stack）<br>5.程序计数器（Program Counter Register）<br>其中，方法区和堆所有线程共享。</p><ul><li>线程不共享区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的</li><li>线程共享区域 线程共享区域包含：堆和方法区</li></ul><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><ul><li>主要存放类与类之间关系的数据，而这部分数据被加载到内存之后，基本上是不会发生变更的</li><li>方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息</li><li>方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常</li><li>在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation）</li><li>一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载</li><li>在方法区上进行GC，条件相当苛刻而且困难。</li><li>方法区的数据因为回收率非常小，而成本又比较高，一般认为是“性价比”非常差的，所以Sun自己的虚拟机HotSpot中是不回收的！但是在现在高性能分布式J2EE的系统中，我们大量用到了反射、动态代理、CGLIB、JSP和OSGI等，这些类频繁的调用自定义类加载器，都需要动态的加载和卸载了，以保证永久带不会溢出，他们通过自定义的类加载器进行了各项操作，因此在实际的应用开发中，类也是被经常加载和卸载的，方法区也是会被回收的！但是方法区的回收条件非常苛刻，只有同时满足以下三个条件才会被回收！<ul><li>该类的所有实例都已经被回收</li><li>加载该类的ClassLoad已经被回收</li><li>Class对象无法通过任何途径访问(包括反射)，该类对应的反射类java.lang.Class对象没有被任何地方引用</li></ul></li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用</li><li>一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</li><li>保存装载的类的元信息：类型的常量池，字段、⽅法信息，⽅法字节码</li><li>jdk6时，String等常量信息置于⽅法区，jdk7移到了堆中</li><li>通常和永久区（Perm）关联在⼀起</li></ul><h4 id="堆区（Heap）"><a href="#堆区（Heap）" class="headerlink" title="堆区（Heap）"></a>堆区（Heap）</h4><ul><li>Java堆中的数据基本上是朝生夕死的，我们用完之后要马上回收的，而Java栈和本地方法栈中的数据，因为有后进先出的原则，当我取下面的数据之前，必须要把栈顶的元素出栈，因此回收率可认为是100%</li><li>堆区是GC最频繁的，也是理解GC机制最重要的区域</li><li>堆区由所有线程共享，在虚拟机启动时创建</li><li>堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。</li><li>应⽤系统对象都保存在java堆中</li><li>所有线程共享java堆</li><li>对分代GC来说，堆也是分代的</li></ul><h4 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h4><ul><li>虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈</li><li>局部变量表中存储着方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：内存空间可以在编译期间就确定，运行时不再改变</li><li>虚拟机栈定义了两种异常类型：StackOverFlowError(栈溢出)和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError；不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</li><li>线程私有</li><li>栈由⼀系列帧组成（因此java栈也叫做帧栈）</li><li>帧保存⼀个⽅法的局部变量（局部变量表）、操作数栈、常量池指针</li><li>每⼀次⽅法调⽤创建⼀个帧，并压栈</li></ul><h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><ul><li>本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态</li><li>本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法</li><li>在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</li></ul><h4 id="程序计数器（Program-Counter-Register）-PC寄存器"><a href="#程序计数器（Program-Counter-Register）-PC寄存器" class="headerlink" title="程序计数器（Program Counter Register）(PC寄存器)"></a>程序计数器（Program Counter Register）(PC寄存器)</h4><ul><li>主要用于记录线程执行的行号等一些信息，这块区域也是被认为是唯一一块不会内存溢出的区域。在SunHostSpot的虚拟机中，对于程序计数器是不回收的</li><li>每个线程拥有⼀个pc寄存器，指向下⼀条指令的地址</li><li>程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它</li><li>它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的</li><li>每个程序计数器只能记录一个线程的行号，因此它是线程私有的</li><li>如果程序当前正在执行的是一个java方法，则程序计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则计数器的值为空</li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ul><li>属于串行收集器</li><li>Serial收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下ServerVM 4核4GB以下机器的默认垃圾回收器</li><li>比较适合于只有一个处理器的系统</li><li>串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World”的垃圾回收器</li><li>串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。</li><li>Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</li><li>在串行处理器中minor和major GC过程都是用一个线程进行回收的</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul><li>ParNew收集器其实就是多线程版本的Serial收集器</li><li>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器</li><li>它可以与CMS GC配合，所以，更加有理由将他用于server端</li></ul><h4 id="ParallelScavenge"><a href="#ParallelScavenge" class="headerlink" title="ParallelScavenge"></a>ParallelScavenge</h4><ul><li>ParallelScavenge又被称为是吞吐量优先的收集器</li><li>ParallelScavenge所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%，在交互不多的云端，比较适合使用该回收器。</li><li>在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式</li></ul><h1 id="ParallelOld"><a href="#ParallelOld" class="headerlink" title="ParallelOld"></a>ParallelOld</h1><ul><li>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器</li><li>这个收集器是JDK1.6之后刚引入的一款收集器，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先</li><li>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法</li></ul><h4 id="SerialOld"><a href="#SerialOld" class="headerlink" title="SerialOld"></a>SerialOld</h4><ul><li>SerialOld是旧生代Client模式下的默认收集器，单线程执行</li><li>在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器</li><li>Serial Old是Serial收集器的老年代版本</li><li>它同样使用一个单线程执行收集，使用“标记-整理”算法</li><li>主要使用在Client模式下的虚拟机</li></ul><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><ul><li>CMS又称响应时间优先(最短回收停顿)的回收器</li><li>使用并发模式回收垃圾</li><li>使用标记-清除算法</li><li>CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%</li><li>CMS模式主要分为4个过程</li><li>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程</li><li>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</li><li>CMS为了确保能够扫描到所有的对象，避免在Initial Marking中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack中，如依赖的对象地址在其之后，则仅标记该对象。在进行Concurrent Marking时minor GC也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS为了应对这样的并发现象，提供了一个Mod Union Table来进行记录，在这个Mod Union Table中记录每次minor GC后修改了的Card的信息。这也是ParallelScavenge不能和CMS一起使用的原因。</li><li>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收</li><li>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收</li><li>该收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间</li><li>常见的B/S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清楚算法实现的</li><li>CMS收集器的优点：并发收集、低停顿，但远没有达到完美</li><li>CMS收集器的缺点：<ul><li>CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。</li><li>CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。</li><li>CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。</li></ul></li></ul><h4 id="GarbageFirst-G1"><a href="#GarbageFirst-G1" class="headerlink" title="GarbageFirst(G1)"></a>GarbageFirst(G1)</h4><ul><li>SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器</li><li>他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间</li><li>相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿</li></ul><h4 id="RTSJ垃圾收集器"><a href="#RTSJ垃圾收集器" class="headerlink" title="RTSJ垃圾收集器"></a>RTSJ垃圾收集器</h4><ul><li>RTSJ垃圾收集器，用于Java实时编程</li></ul><h1 id="JVM的内存分配与回收策略"><a href="#JVM的内存分配与回收策略" class="headerlink" title="JVM的内存分配与回收策略"></a>JVM的内存分配与回收策略</h1><ul><li>优先在Edon上分配对象</li><li>大对象直接进入老生代</li><li>年长者(长期存活对象)进入老生代</li><li>群体效应(大批中年对象进入老生代)</li><li>担保GC(担保minorGC)<ul><li>担保GC就是担保minorGC能够满足当前的存储空间，而无需触发老生代的回收，由于大部分对象都是朝生夕死的，因此，在实际开发中这种很起效，但是也有可能会发生担保失败的情况，当担保失败的时候会触发FullGC，但是失败毕竟是少数，因此这种一般是很划算的。</li><li>默认情况是是开启担保的，无需设置参数</li></ul></li></ul><h1 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h1><ul><li>每⼀个线程有⼀个⼯作内存，和主存独⽴</li><li>⼯作内存存放主存中变量的值的拷⻉</li><li>对于普通变量，⼀个线程中更新的值，不能⻢上反应在其他变量中；如果需要在其他线程中⽴即可⻅，需要使⽤volatile关键字</li><li>volatile不能代替锁，⼀般认为volatile⽐锁性能好(不绝对)，使⽤volatile的条件是语义是否满⾜应⽤</li><li>可⻅性：⼀个线程修改了变量，其他线程可以⽴即知道。<ul><li>volatile；</li><li>synchronized（unlock之前，写变量值回主存）</li><li>final（⼀旦初始化完成，其他线程可⻅）</li></ul></li></ul><h1 id="Java-中堆和栈有什么不同"><a href="#Java-中堆和栈有什么不同" class="headerlink" title="Java 中堆和栈有什么不同"></a>Java 中堆和栈有什么不同</h1><ul><li>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的</li><li>而堆是所有线程共享的一片公用内存区域</li><li>对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</li></ul><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>虚拟机把描述类的数据⽂件（字节码）加载到内存，并对数据进⾏验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使⽤的java类型（java.lang.Class对象）</li><li>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</li></ul><h4 id="类⽣命周期"><a href="#类⽣命周期" class="headerlink" title="类⽣命周期"></a>类⽣命周期</h4><ul><li>类加载过程：读取⼆进制字节流到jvm—&gt;验证格式语义等—&gt;为静态变量分配内存空间—&gt;常量池引⽤解析—&gt;执⾏static标识的代码<ul><li>a. 加载过程：通过⼀个类的全限定名来获取定义此类的⼆进制字节流，将这个字节流所代表的静态存储结构转化为⽅法区的运⾏时数据结构。在内存中(⽅法区)⽣成⼀个代表这个类的java.lang.Class对象，作为⽅法区这个类的各种数据的访问⼊⼝；</li><li>b. 验证过程：为了确保Class⽂件的字节流中包含的信息符合当前虚拟机的要求，⽂件格式验证、元数据验证、字节码验证、符号引⽤验证；</li><li>c. 准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在⽅法区中进⾏分配；准备阶段，static对象会被设置默认值，static ﬁnal对象会被赋上给予的值。</li><li>d. 解析阶段：虚拟机将常量池内的符号引⽤替换为直接引⽤的过程。<ul><li>i. 符号引⽤：字符串，引⽤对象不⼀定被加载；</li><li>ii. 直接引⽤：指针或者地址偏移量，引⽤对象⼀定在内存中。</li></ul></li><li>e. 初始化阶段：类初始化阶段是类加载过程的最后⼀步。初始化阶段就是执⾏类构造器<clint>()⽅法的过程。</clint></li><li>f. 使⽤阶段</li><li>g. 卸载阶段：</li></ul></li></ul><h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><ul><li>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</li><li>主要有一下四种类加载器:<ul><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ul></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li>java默认提供三个类加载器：<ul><li>a. 启动类加载器（BootStrap ClassLoader） 启动ClassLoader（sun.boot.class.path）：最顶层的加载类，主要加载jdk中的核⼼库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。Bootstrap ClassLoader不继承⾃ClassLoader，因为它不是⼀个普通的Java类，底层由C++编写，已嵌⼊到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核⼼类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</li><li>b. 扩展类加载器（Extension ClassLoader）扩展ClassLoader（java.ext.dirs）：扩展的类加载器，加载⽬录%JRE_HOME%\lib\ext⽬录下的jar包和class⽂件。还可以加载-D java.ext.dirs选项指定的⽬录。</li><li>c. App ClassLoader应⽤ClassLoader/系统ClassLoader（java.class.path）：也称为SystemAppClass 加载当前应⽤的classpath的所有类。除了BootStrap ClassLoader，每个ClassLoader都有⼀个Parent作为⽗亲。</li></ul></li><li>双亲委派机制：<ul><li>定义：当⼀个ClassLoader实例需要加载某个类时，它会试图亲⾃搜索某个类之前，先把这个任务委托给它的⽗类加载器，这个过程是由上⾄下依次检查的，⾸先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader进⾏加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的⽂件系统或⽹络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类⽣成⼀个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</li><li>作⽤：<ul><li>避免重复加载；</li><li>考虑到安全因素，避免⾃定义的类去替代系统类，如String。</li><li>jvm如何判定两个class是否相同？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，⽽且要判断是否由同⼀个类加载器实例加载的。只有两者同时满⾜的情况下，JVM才认为这两个class是相同的。<ul><li>⾃底向上检查类是否已经加载；</li><li>⾃顶向下尝试加载类。</li></ul></li></ul></li></ul></li><li>custom classloader：⾃定义classloader<ul><li>Java中提供的默认ClassLoader，只加载指定⽬录下的jar和class，如果我们想加载其它位置的类或jar时，就需要定义⾃⼰的ClassLoader。</li><li>步骤：<ul><li>继承java.lang.ClassLoader</li><li>重写⽗类的findClass⽅法</li></ul></li></ul></li></ul><h4 id="引起类加载的五个⾏为"><a href="#引起类加载的五个⾏为" class="headerlink" title="引起类加载的五个⾏为"></a>引起类加载的五个⾏为</h4><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li><li>反射调⽤的时候，如果类没有进⾏过初始化，则需要先触发其初始化</li><li>⼦类初始化的时候，如果其⽗类还没初始化，则需先触发其⽗类的初始化</li><li>虚拟机执⾏主类的时候(有 main(string[] args))</li><li>JDK1.7 动态语⾔⽀持</li></ul><h4 id="java对象创建时机"><a href="#java对象创建时机" class="headerlink" title="java对象创建时机"></a>java对象创建时机</h4><ul><li>使⽤new关键字创建对象</li><li>使⽤Class类的newInstance⽅法(反射机制)</li><li>使⽤Constructor类的newInstance⽅法(反射机制)</li><li>使⽤Clone⽅法创建对象</li><li>使⽤(反)序列化机制创建对象</li></ul><h1 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h1><h4 id="调优时机"><a href="#调优时机" class="headerlink" title="调优时机"></a>调优时机</h4><ul><li>heap 内存（⽼年代）持续上涨达到设置的最⼤内存值；</li><li>Full GC 次数频繁；</li><li>GC 停顿时间过⻓（超过1秒）；</li><li>应⽤出现OutOfMemory 等内存异常；</li><li>应⽤中有使⽤本地缓存且占⽤⼤量内存空间；</li><li>系统吞吐量与响应性能不⾼或下降。</li></ul><h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><ul><li>多数的Java应⽤不需要在服务器上进⾏JVM优化；</li><li>多数导致GC问题的Java应⽤，都不是因为我们参数设置错误，⽽是代码问题；</li><li>在应⽤上线之前，先考虑将机器的JVM参数设置到最优（最适合）；</li><li>减少创建对象的数量；</li><li>减少使⽤全局变量和⼤对象；</li><li>JVM优化是到最后不得已才采⽤的⼿段；</li><li>在实际使⽤中，分析GC情况优化代码⽐优化JVM参数更好；</li></ul><h4 id="调优⽬标"><a href="#调优⽬标" class="headerlink" title="调优⽬标"></a>调优⽬标</h4><ul><li>GC低停顿；</li><li>GC低频率；</li><li>低内存占⽤；</li><li>⾼吞吐量；</li></ul><h4 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a>调优步骤</h4><ul><li>分析GC⽇志及dump⽂件，判断是否需要优化，确定瓶颈问题点；</li><li>确定jvm调优量化⽬标；</li><li>确定jvm调优参数（根据历史jvm参数来调整）；</li><li>调优⼀台服务器，对⽐观察调优前后的差异；</li><li>不断的分析和调整，知道找到合适的jvm参数配置；</li><li>找到最合适的参数，将这些参数应⽤到所有服务器，并进⾏后续跟踪。</li></ul><h1 id="jvm调优参数"><a href="#jvm调优参数" class="headerlink" title="jvm调优参数"></a>jvm调优参数</h1><ul><li>设定堆内存⼤⼩，这是最基本的。</li><li>-Xms：启动JVM时的堆内存空间。</li><li>-Xmx：堆内存最⼤限制。</li><li>设定新⽣代⼤⼩。</li><li>新⽣代不宜太⼩，否则会有⼤量对象涌⼊⽼年代。</li><li>-XX:NewRatio：新⽣代和⽼年代的占⽐。</li><li>-XX:NewSize：新⽣代空间。</li><li>-XX:SurvivorRatio：伊甸园空间和幸存者空间的占⽐。</li><li>-XX:MaxTenuringThreshold：对象进⼊⽼年代的年龄阈值。</li><li>设定垃圾回收器<ul><li>年轻代：-XX:+UseParNewGC。</li><li>⽼年代：-XX:+UseConcMarkSweepGC。</li><li>CMS可以将STW时间降到最低，但是不对内存进⾏压缩，有可能出现“并⾏模式失败”。⽐如⽼年代空间还有300MB空间，但是⼀些10MB的对象⽆法被顺序的存储。这时候会触发压缩处理，但是CMS GC模式下的压缩处理时间要⽐Parallel GC⻓很多。</li><li>G1采⽤”标记-整理“算法，解决了内存碎⽚问题，建⽴了可预测的停顿时间类型，能让使⽤者指定在⼀个⻓度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。</li></ul></li></ul><h1 id="触发full-gc的场景及应对策略"><a href="#触发full-gc的场景及应对策略" class="headerlink" title="触发full gc的场景及应对策略"></a>触发full gc的场景及应对策略</h1><ul><li>System.gc()⽅法的调⽤，应对策略：通过-XX:+DisableExpl icitGC来禁⽌调⽤System.gc ;</li><li>⽼年代代空间不⾜，应对策略：让对象在Minor GC阶段被回收，让对象在新⽣代多存活⼀段时间，不要创建过⼤的对象及数组;</li><li>永⽣区空间不⾜，应对策略：增⼤PermGen空间；</li><li>GC时出现promotionfailed和concurrent mode failure，应对策略：增⼤survivor space；</li><li>Minor GC后晋升到旧⽣代的对象⼤⼩⼤于⽼年代的剩余空间，应对策略：增⼤Tenured space 或下调CMSInitiatingOccupancyFraction=60；</li><li>内存持续增涨达到上限导致Full GC，应对策略：通过dumpheap 分析是否存在内存泄漏。</li></ul><h1 id="简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述java内存分配与回收策率以及Minor GC和Major GC"></a>简述java内存分配与回收策率以及Minor GC和Major GC</h1><ul><li>对象优先在堆的Eden区分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将直接进入老年代</li><li>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度</li></ul><h1 id="如何查看jvm内存使⽤情况"><a href="#如何查看jvm内存使⽤情况" class="headerlink" title="如何查看jvm内存使⽤情况"></a>如何查看jvm内存使⽤情况</h1><ul><li>可以使⽤JDK⾃带的JConsole、JVisualVM、JMap、JHat等⼯具，或者使⽤第三⽅⼯具，⽐如 Eclipse Memory Analyzer</li></ul><h1 id="内存溢出的可能原因和解决⽅法"><a href="#内存溢出的可能原因和解决⽅法" class="headerlink" title="内存溢出的可能原因和解决⽅法"></a>内存溢出的可能原因和解决⽅法</h1><h4 id="内存溢出原因"><a href="#内存溢出原因" class="headerlink" title="内存溢出原因"></a>内存溢出原因</h4><ul><li>数据加载过多，如1次从数据库中取出过多数据</li><li>集合类中有对对象的引⽤，⽤完后没有清空或者集合对象未置空导致引⽤存在等，是的JVM⽆法回收</li><li>死循环，过多重复对象</li><li>第三⽅软件的bug</li><li>启动参数内存值设定的过⼩</li></ul><h4 id="解决⽅法"><a href="#解决⽅法" class="headerlink" title="解决⽅法"></a>解决⽅法</h4><ul><li>修改JVM启动参数，加内存(-Xms，-Xmx)</li><li>错误⽇志，是否还有其他错误</li><li>代码⾛查</li></ul><h1 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h1><ul><li>未对作废数据内存单元置为null，尽早释放⽆⽤对象的引⽤，使⽤临时变量时，让引⽤变量在推出活动域后⾃动设置为null，暗示垃圾收集器收集；</li><li>程序避免⽤String拼接，⽤StringBuffer，因为每个String会占⽤内存⼀块区域；</li><li>尽量少⽤静态变量（全局不会回收）；</li><li>不要集中创建对象尤其⼤对象，可以使⽤流操作；</li><li>尽量使⽤对象池，不再循环中创建对象，优化配置；</li><li>创建对象到单例getInstance中，对象⽆法回收被单例引⽤；</li><li>服务器session时间设置过⻓也会引起内存泄漏。</li></ul><h1 id="⽅法区oom"><a href="#⽅法区oom" class="headerlink" title="⽅法区oom"></a>⽅法区oom</h1><ul><li>⽅法区⽤于存放Class的相关信息，如：类名，访问修饰符，常量池，字符描述，⽅法描述等。</li><li>原因：运⾏时产⽣⼤量的类去填满⽅法区，直到溢出。</li></ul><h1 id="哪些情况下对象会进⼊⽼年代"><a href="#哪些情况下对象会进⼊⽼年代" class="headerlink" title="哪些情况下对象会进⼊⽼年代"></a>哪些情况下对象会进⼊⽼年代</h1><ul><li>新⽣代对象每次经历⼀次minor gc，年龄会加1，当达到年龄阈值（默认为15岁）会直接进⼊⽼年代</li><li>⼤对象直接进⼊⽼年代</li><li>新⽣代复制算法需要⼀个survivor区进⾏轮换备份，如果出现⼤量对象在minor gc后仍然存活的情况时，就需要⽼年代进⾏分配担保，让survivor⽆法容纳的对象直接进⼊⽼年代</li><li>如果在Survivor空间中相同年龄所有对象⼤⼩的总和⼤于Survivor空间的⼀半，年龄⼤于或等于该年龄的对象就可以直接进⼊年⽼代</li></ul><h1 id="当对象A创建之后，对象A在各个区之间的流转过程"><a href="#当对象A创建之后，对象A在各个区之间的流转过程" class="headerlink" title="当对象A创建之后，对象A在各个区之间的流转过程"></a>当对象A创建之后，对象A在各个区之间的流转过程</h1><ul><li>对象A被new出来之后，是被存放在Eden（伊甸园）区的</li><li>当发⽣⼀次GC后，Eden区存活下来的对象A会被复制到s1区，s0中存活的对象也会被复制到s1中。如果对象年龄超过阈值年龄（默认15岁），会被复制到⽼年区。部分对象也需要⽼年代分担。<br>c. GC会清空Eden和s0中存储的所有对象；<br>d. 交换s0和s1的⻆⾊；<br>e. 重复上⾯的步骤。</li></ul><h1 id="jvm体系总体分四大块"><a href="#jvm体系总体分四大块" class="headerlink" title="jvm体系总体分四大块"></a>jvm体系总体分四大块</h1><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul><h1 id="调优命令"><a href="#调优命令" class="headerlink" title="调优命令"></a>调优命令</h1><ul><li>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</li><li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>jstack，用于生成java虚拟机当前时刻的线程快照</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数</li><li>jstack可以看当前栈的情况，jmap查看内存，jhat 进行dump堆的信息</li></ul><h1 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h1><ul><li>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto</li><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等</li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>GChisto，一款专业分析gc日志的工具</li></ul><h1 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h1><ul><li>比如GC的时候必须要等到Java线程都进入到safepoint的时候VMThread才能开始执行GC，</li><li>循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)</li><li>方法返回前</li><li>调用方法的call之后</li><li>抛出异常的位置</li></ul><h1 id="简述java垃圾回收机制"><a href="#简述java垃圾回收机制" class="headerlink" title="简述java垃圾回收机制"></a>简述java垃圾回收机制</h1><ul><li>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行</li><li>在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</li></ul><h1 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h1><ul><li>－server 启用服务器模式（如果CPU多，服务器机建议使用此项）</li><li>－Xms，－Xmx一般设为同样大小。 800m</li><li>－Xmn 是将NewSize与MaxNewSize设为一致。320m</li><li>－XX：PerSize 64m</li><li>－XX：NewSize 320m 此值设大可调大新对象区，减少Full GC次数</li><li>－XX：MaxNewSize 320m</li><li>－XX：NewRato NewSize设了可不设。4</li><li>－XX： SurvivorRatio 4</li><li>－XX：userParNewGC 可用来设置并行收集</li><li>－XX：ParallelGCThreads 可用来增加并行度 4</li><li>－XXUseParallelGC 设置后可以使用并行清除收集器</li><li>－XX：UseAdaptiveSizePolicy 与上面一个联合使用效果更好，利用它可以自动优化新域大小以及救助空间比值</li><li>-XmxJavaHeap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；</li><li>-XmsJavaHeap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/c0d8e27e97f4.html" class="post-title-link" itemprop="url">多线程</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:06:48 / 修改时间：15:07:41" itemprop="dateCreated datePublished" datetime="2023-12-20T15:06:48+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="用什么关键字修饰同步方法"><a href="#用什么关键字修饰同步方法" class="headerlink" title="用什么关键字修饰同步方法"></a>用什么关键字修饰同步方法</h1><ul><li>用synchronized关键字修饰同步方法</li></ul><h1 id="stop-和suspend-方法为何不推荐使用"><a href="#stop-和suspend-方法为何不推荐使用" class="headerlink" title="stop()和suspend()方法为何不推荐使用"></a>stop()和suspend()方法为何不推荐使用</h1><ul><li>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</li><li>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</li></ul><h1 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h1><ul><li>最大的不同是在等待时wait会释放锁，而sleep一直持有锁</li><li>Wait通常被用于线程间交互，sleep通常被用于暂停执行</li><li>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li><li>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li><li>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。</li><li>wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。</li><li>sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器</li></ul><h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul><li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取</li><li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率</li></ul><h1 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h1><ul><li>启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态</li><li>一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码</li></ul><h1 id="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h1><ul><li>分几种情况：<ul><li>其他方法前是否加了synchronized关键字，如果没加，则能。</li><li>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</li><li>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</li><li>如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</li></ul></li></ul><h1 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h1><ul><li>一个程序中可以有多条执行线索同时执行</li><li>一个线程就是程序中的一条执行线索</li><li>每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行</li><li>每个程序至少都有一个线程，即main方法执行的那个线程</li><li>如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行。</li><li>线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身</li><li>Java中的线程有四种状态分别是：运行、就绪、挂起、结束</li><li>线程是操作系统能够进⾏运算调度的最⼩单位，它被包含在进程之中，是进程中的实际运作单位，可以使⽤多线程对进⾏运算提速</li></ul><h1 id="简述synchronized和java-util-concurrent-locks-Lock的异同"><a href="#简述synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="简述synchronized和java.util.concurrent.locks.Lock的异同"></a>简述synchronized和java.util.concurrent.locks.Lock的异同</h1><ul><li>主要相同点：Lock能完成synchronized所实现的所有功能</li><li>主要不同点<ul><li>Lock有比synchronized更精确的线程语义和更好的性能</li><li>ynchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放</li><li>Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁</li></ul></li></ul><h1 id="Synchronized和ReentrantLock有什么区别"><a href="#Synchronized和ReentrantLock有什么区别" class="headerlink" title="Synchronized和ReentrantLock有什么区别?"></a>Synchronized和ReentrantLock有什么区别?</h1><ul><li>synchronized是Java内建的同步机制,所以也有人称其为Intrinsic Locking（固有锁），它提供了互斥的语义和可见性,当一个线程已经获取当前锁时,其他试图获取的线程只能等待或者阻塞在那里。在Java 5以前,synchronized是仅有的同步手段,在代码中,synchronized可以用来修饰方法,也可以使用在特定的代码块上,本质上 synchronized方法等同于把方法全部语句用synchronized块包起来。</li><li>ReentrantLock,通常翻译为再入锁,是Java 5提供的锁实现,它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取,代码书写更加灵活。与此同时,ReentrantLock提供了很多实用的方法,能够实现很多synchronized无法做到的细节控制,但是在编码中也需要注意,必须要明确调用unlock()方法释放,不然就会一直持有该锁。synchronzied和ReentrantLock的性能不能一概而论,早期版本synchronized在很多场景下性能相差较大,在后续版本进行了较多改进,在低竞争场景中表现可能优于ReentrantLock。</li></ul><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>可重⼊锁。可重⼊锁是指同⼀个线程可以多次获取同⼀把锁。ReentrantLock和synchronized都是可重⼊锁。</li><li>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，⽽ReentrantLock则提供了中断功能。</li><li>公平锁是指多个线程同时尝试获取同⼀把锁时，获取锁的顺序按照线程达到的顺序</li><li>⾮公平锁则允许线程“插队”</li><li>synchronized是⾮公平锁，⽽ReentrantLock的默认实现是⾮公平锁，但是也可以设置为公平锁。</li></ul><h4 id="CAS操作-CompareAndSwap"><a href="#CAS操作-CompareAndSwap" class="headerlink" title="CAS操作(CompareAndSwap)"></a>CAS操作(CompareAndSwap)</h4><ul><li>CAS操作简单的说就是⽐较并交换</li><li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)</li><li>如果内存位置的值与预期原值相匹配，那么处理器会⾃动将该位置值更新为新值。否则，处理器不做任何操作</li><li>⽆论哪种情况，它都会在 CAS 指令之前返回该位置的值</li><li>CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</li></ul><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ul><li>synchronized是java内置的关键字，它提供了⼀种独占的加锁⽅式</li><li>synchronized的获取和释放锁由JVM实现，⽤户不需要显示的释放锁，⾮常⽅便</li><li>然⽽synchronized也有⼀定的局限性：<ul><li>当线程尝试获取锁的时候，如果获取不到锁会⼀直阻塞。</li><li>如果获取锁的线程进⼊休眠或者阻塞，除⾮当前线程异常，否则其他线程尝试获取锁必须⼀直等待。</li></ul></li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul><li>ReentrantLock它是JDK 1.5之后提供的API层⾯的互斥锁，需要lock()和unlock()⽅法配合try/finally语句块来完成。</li><li>等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）</li><li>公平锁与⾮公平锁多个线程等待同⼀个锁时，必须按照申请锁的时间顺序获得锁</li><li>Synchronized锁⾮公平锁，ReentrantLock默认的构造函数是创建的⾮公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li></ul><h1 id="请说出你所知道的线程同步的方法"><a href="#请说出你所知道的线程同步的方法" class="headerlink" title="请说出你所知道的线程同步的方法"></a>请说出你所知道的线程同步的方法</h1><ul><li>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</li><li>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</li><li>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级</li><li>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li></ul><h1 id="同步有几种实现方法-都是什么"><a href="#同步有几种实现方法-都是什么" class="headerlink" title="同步有几种实现方法,都是什么?"></a>同步有几种实现方法,都是什么?</h1><ul><li>同步的实现方面有两种，分别是synchronized,wait与notify</li></ul><h1 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信</li><li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信</li><li>这种方式，本质上就是“共享内存”式的通信</li><li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行</li></ul><h4 id="while轮询的方式"><a href="#while轮询的方式" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul><li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信</li><li>但是这种方式会浪费CPU资源</li><li>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试某个条件是否成立</li><li>这种方式还存在另外一个问题：轮询的条件的可见性问题</li><li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li></ul><h4 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait/notify机制"></a>wait/notify机制</h4><ul><li>线程A要等待某个条件满足时(list.size()==5)，才执行操作，线程B则向list中添加元素，改变list 的size</li><li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢</li><li>这里用到了Object类的 wait() 和 notify() 方法</li><li>当条件未满足时(list.size() !=5)，线程A调用wait()放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</li><li>当条件满足时，线程B调用 notify()通知线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态</li><li>这种方式的一个好处就是CPU的利用率提高了，但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ul><li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li><li>分布式系统中说的两种通信机制：共享内存机制和消息通信机制</li><li>synchronized关键字和while轮询“属于”共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流</li><li>而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。</li></ul><h1 id="线程死锁及解决办法"><a href="#线程死锁及解决办法" class="headerlink" title="线程死锁及解决办法"></a>线程死锁及解决办法</h1><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><ul><li>所谓死锁： 是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁线程。</li><li>由于资源占用是互斥的，当某个线程提出申请资源后，使得有关线程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁</li><li>关键点：<ul><li>两个以上的线程</li><li>争夺共享的资源</li><li>它们各自不释放手中资源，除非有外力协助</li></ul></li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y的拥有者分别等待对方的资源的问题。</li><li>将多个锁组成一组并放到同一个锁下</li><li>将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得容器对象的锁时，就可以通过检查变量来判断是否整个容器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试</li></ul><h1 id="锁分类的了解"><a href="#锁分类的了解" class="headerlink" title="锁分类的了解"></a>锁分类的了解</h1><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h4><ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁</li><li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象</li><li>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大</li><li>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁</li></ul><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul><li>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。</li><li>对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。<br>```<br>synchronized void setA() throws Exception{<br>Thread.sleep(1000);<br>setB();<br>}</li></ul><p>synchronized void setB() throws Exception{<br>Thread.sleep(1000);<br>}</p><pre><code>
- 上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁

#### 独享锁/共享锁
- 独享锁是指该锁一次只能被一个线程所持有。
- 共享锁是指该锁可被多个线程所持有。
- 对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
- 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
- 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
- 对于Synchronized而言，当然是独享锁。

#### 互斥锁/读写锁
- 上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
- 互斥锁在Java中的具体实现就是ReentrantLock
- 读写锁在Java中的具体实现就是ReadWriteLock

#### 乐观锁/悲观锁
- 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
- 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
- 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
- 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
- 悲观锁在Java中的使用，就是利用各种锁。
- 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
- 乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑
- 悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接上了锁操作资源。

#### 分段锁
- 分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
- 我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
- 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
- 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计
- 分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作

#### 偏向锁/轻量级锁/重量级锁
- 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
- 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

#### 自旋锁
- 自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区
- 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU
- ⾃旋锁是SMP架构中的⼀种low-level的同步机制
- 当线程A想要获取⼀把⾃旋锁⽽该锁⼜被其它线程锁持有时，线程A会在⼀个循环中⾃旋以检测锁是不是已经可⽤了。
- ⾃选锁需要注意：
    - 由于⾃旋时不释放CPU，因⽽持有⾃旋锁的线程应该尽快释放⾃旋锁，否则等待该⾃旋锁的线程会⼀直在那⾥⾃旋，这就会浪费CPU时间
    - 持有⾃旋锁的线程在sleep之前应该释放⾃旋锁以便其它线程可以获得⾃旋锁
- ⽬前的JVM实现⾃旋会消耗CPU，如果⻓时间不调⽤doNotify⽅法，doWait⽅法会⼀直⾃旋，CPU会消耗太⼤
- ⾃旋锁⽐较适⽤于锁使⽤者保持锁时间⽐较短的情况，这种情况⾃旋锁的效率⽐较⾼
- ⾃旋锁是⼀种对多处理器相当有效的机制，⽽在单处理器⾮抢占式的系统中基本上没有作⽤

# 重入锁：ReentrantLock 详解
- 在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的。除此之外，重入锁又自带一系列高逼格UBFF：可中断响应、锁申请等待限时、公平锁。另外可以结合Condition来使用，使其更是逼格满满。
- 使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对逻辑控制的灵活性远远大于synchronized关键字
- 需要注意，有加锁就必须有释放锁，而且加锁与释放锁的分数要相同，这里就引出了“重”字的概念

#### 中断响应
- 对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。
- t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了死锁。但是，给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，正常执行完成。t2也会退出，但只是释放了资源并没有完成工作

#### 锁申请等待限时
- 可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。
- 前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。
- 后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false

#### 公平锁
- 所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：
</code></pre><p>public ReentrantLock(boolean fair) {<br>sync = fair ? new FairSync() : new NonfairSync();<br>}</p><pre><code>
#### ReentrantLock 配合 Conditond 使用
- 配合关键字synchronized使用的方法如：await()、notify()、notifyAll()
- ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象

# 深入理解Callable
- Callable和Runnbale一样代表着任务，区别在于Callable有返回值并且可以抛出异常
- Callable接⼝使⽤泛型去定义它的返回类型
- Executors类提供了⼀些有⽤的⽅法去在线程池中执⾏Callable内的任务
- 由于Callable任务是并⾏的，必须等待它返回的结果，java.util.concurrent.Future对象解决了这个问题
- 在线程池提交Callable任务后返回了⼀个Future对象，使⽤它可以知道Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()⽅法，等待Callable结束并获取它的执⾏结果

#### Future接口
- Future是一个接口，代表了一个异步计算的结果
- 接口中的方法用来检查计算是否完成、等待完成和得到计算的结果
- 当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了
- 如果想取消，那么调用cancel()方法
- 其他方法用于确定任务是正常完成还是取消了
- 一旦计算完成了，那么这个计算就不能被取消

#### FutureTask 是什么？
- FutureTask 表示一个异步运算的任务，FutureTask 里面可以传入一个 Callable的具体实现类
- 可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、 取消任务等操作
- FutureTask可⽤于异步获取执⾏结果或取消执⾏任务的场景
- 通过传⼊Runnable或者Callable的任务给FutureTask，直接调⽤其run⽅法或者放⼊线程池执⾏，之后可以在外部通过FutureTask的get⽅法异步获取执⾏结果
- FutureTask⾮常适合⽤于耗时的计算，主线程可以在完成⾃⼰的任务后，再去获取结果
- FutureTask还可以确保即使调⽤了多次run⽅法，它都只会执⾏⼀次Runnable或者Callable任务，或者通过cancel取消FutureTask的执⾏等
- futuretask可⽤于执⾏多任务、以及避免⾼并发情况下多次创建数据机锁的出现。

#### run方法
- 当将FutureTask提交给Executor后，Executor执行FutureTask时会执行其run方法
- 任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程
- 从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法
- set方法：当Callable成功执行后，会调用set方法将结果传出
- setException方法：该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程
- get方法：当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。
- 在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待
- awaitDone方法是如何将调用线程阻塞的,awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制
- awaitDone方法中进入死循环后，主要有几步
    - 如果线程被中断了，移除节点，抛出异常
    - 如果状态大于COMPLETING，那么直接返回
    - 如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下
    - 如果状态是NEW且节点为null，那么创建一个节点
    - 如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程
    - 如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点
    - 如果没有限制时间，那么将线程无限挂起
- 上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。
- 当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果
- report会根据任务的状态不同返回不同的结果。
    - 如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果
    - 如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException
    - 如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException
- finishCompletion方法：在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程
- finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环，释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。
- cancel方法：用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了，如果是需要中断正在执行的任务，那么状态转换将会是NEW-&gt;INTERRPUTING-&gt;INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW-&gt;CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。

- isDone方法：表明任务是否已经完成了，如果完成了，那么返回true，否则false，只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。

#### 总结
- Callable是一种可以返回结果的任务，这是它与Runnable的区别，但是通过适配器模式可以使Runnable与Callable类似
- Future代表了一个异步的计算，可以从中得到计算结果、查看计算状态，其实现FutureTask可以被提交给Executor执行，多个线程可以从中得到计算结果
- Callable和Future是配合使用的，当从Future中get结果时，如果结果还没被计算出来，那么线程将会被挂起，FutureTak内部使用一个单链表维持等待的线程；当计算结果出来后，将会对等待线程解除挂起，等待线程就都可以得到计算结果了。
- Callable⽤于产⽣结果，Future⽤于获取结果

# 多线程
#### 多线程优点
- 发挥多核CPU 的优势，并发执⾏让系统运⾏的更快、更流畅，⽤户体验更好
- 防止阻塞：从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因 为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但 是单核 CPU 我们还是要应用多线程，就是为了防止阻塞
- 便于建模：这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么 就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成 几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运 行这几个任务，那就简单很多了。
- 使⽤多线程可以把程序中占据时间⻓的任务放到后台去处理，如图⽚、视屏的下载

#### 多线程的缺点
- ⼤量的线程降低代码的可读性；
- 更多的线程需要更多的内存空间
- 当多个线程对同⼀个资源出现争夺时候要注意线程安全的问题。

#### 多线程的上下⽂切换
- CPU通过时间⽚分配算法来循环执⾏任务，当前任务执⾏⼀个时间⽚后会切换到下⼀个任务
- 在切换前会保存上⼀个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态

# 线程和进程的区别是什么
- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式
- 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径
- 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些
- 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程

# Java 实现线程有哪几种方式
- 继承 Thread 类实现多线程
- 实现 Runnable 接口方式实现多线程
- 使用 ExecutorService、Callable、Future 实现有返回结果的多线程

# 启动线程方法 start()和 run()有什么区别
- 只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代 码交替执行
- 如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码

# 一个线程的生命周期有哪几种状态？它们之间如何流转的？
- NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。
- RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中 状态。
- BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。
- WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如 通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方 法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线 程就进入了 RUNNABLE 状态继续运行。
- TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒 后线程重新进行 RUNNABLE 状态继续运行。
- TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程 通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态

# violatile 关键字的作用
- volatile 关键字的作用主要有两个
    - 多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据
    - 使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重要作用就是和CAS结合，保证了原子性

# 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行
- 用 join 方法。

# 为什么要使用线程池
- 什么是线程池？ 很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线 程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用
- 每个线程都要通过 new Thread(xxRunnable).start()的方 式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈
- 线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存

# 线程池⽤法与优势？
#### ThreadPool 优点
- 减少了创建和销毁线程的次数，每个⼯作线程都可以被重复利⽤，可执⾏多个任务
- 可以根据系统的承受能⼒，调整线程池中⼯作线线程的数⽬，防⽌因为因为消耗过多的内存，⽽把服务器累趴下
- 减少在创建和销毁线程上所花的时间以及系统资源的开销
- 如不使⽤线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存

#### ⽐较重要的⼏个类
- Java⾥⾯线程池的顶级接⼜是Executor，但是严格意义上讲Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具
- 真正的线程池接口是ExecutorService。

#### 任务执⾏顺序：
- ExecutorService 真正的线程池接⼝。
- ScheduledExecutorService 能和Timer/TimerTask类似，解决那些需要任务重复执⾏的问题。
- ThreadPoolExecutor ExecutorService的默认实现。
- ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接⼝实现，周期性任务调度的类实现。
    - 当线程数⼩于corePoolSize时，创建线程执⾏任务。
    - 当线程数⼤于等于corePoolSize并且workQueue没有满时，放⼊workQueue中
    - 线程数⼤于等于corePoolSize并且当workQueue满时，新任务新建线程运⾏，线程总数要⼩于maximumPoolSize
    - 当线程总数等于maximumPoolSize并且workQueue满了的时候执⾏handler的rejectedExecution。也就是拒绝策略

# 常用的几种线程池并讲讲其中的工作原理
- 线程池核心类：在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是我们线程池核心类
- 如何提交线程：如可以先随便定义一个固定大小的线程池 ExecutorService es = Executors.newFixedThreadPool(3);提交一个线程es.submit(xxRunnble); es.execute(xxRunnble);
- submit 和 execute 分别有什么区别呢
    - execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多
    - submit 返回一个 Future 对象，如果想知道线程结果就使用 submit提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常
- 如何关闭线程池
    - es.shutdown(); 不再接受新的任务，之前提交的任务等执行结束再关闭线程池
    - es.shutdownNow();不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程 list 列表

# CyclicBarrier 和 CountDownLatch 的区别
- 都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上
- CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值-1 而已，该线程继续运行
- CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务
- CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为0该CountDownLatch就不可再用了

# 什么是活锁、饥饿、无锁、死锁
- 死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现了这三种情况，即线程不再活跃，不能再正常地执行下去了
- 死锁：死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁
- 活锁：活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。 
- 饥饿：我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源
- 无锁：无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功，可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合 下是非常高效的。

# 什么是原子性、可见性、有序性
- 原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个 变量进行操作
- 可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值
- 有序性我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序， 只是重排序会影响多线程执行的结果。

# 什么是守护线程？有什么用？
- 与守护线程相对应的就是用户线程，守护线程就是守护用户线程
- 当用户线程全部执行完结束之后，守护线程才会跟着结束
- 也就是守护线程必须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线 程自然会退出

# 一个线程运行时发生异常会怎样
- 如果异常没有被捕获该线程将会停止执行
- Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口
- 当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理

# 线程 yield()方法有什么用
- Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行
- 它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行

# 什么是重入锁
- 所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的

# Synchronized 有哪几种用法
- 锁类、锁方法、锁代码块

# Fork/Join 框架
#### Fork/Join 框架是干什么的
- 大任务自动分散小任务，并发执行，合并小任务结果

#### Fork/Join 框架使用有哪些要注意的地方？
- 如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降； 
- 如果函数的调用栈很深，会导致栈内存溢出；

# 线程数过多会造成什么异常
- 线程过多会造成栈溢出，也有可能会造成堆异常

# 说说线程安全的和不安全的集合
- Java 中平时用的最多的 Map 集合就是 HashMap 了，它是线程不安全的。 看下面两个场景：
    - 当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线程安全不安全的问题了
    - 当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个 HashMap了，对同个 HashMap 操作这时候就存在线程安全的问题了

# 什么是 CAS 算法？在多线程中有哪些应用
- CAS，全称为 Compare and Swap，即比较-替换
- 假设有三个操作数：内存值 V、 旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false
- 当然 CAS 一定要 volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功。
- java.util.concurrent.atomic 包下面的 Atom*类都有 CAS 算法的应用。

# 怎么检测一个线程是否拥有锁
- java.lang.Thread#holdsLock 方法

# Jdk 中排查多线程问题用什么命令
- jstack

# 线程同步需要注意什么
- 尽量缩小同步的范围，增加系统吞吐量
- 分布式同步锁无意义，要使用分布式锁
- 防止死锁，注意加锁顺序

# 线程 wait()方法使用有什么前提？
- 要在同步块中使用

# 线程之间如何传递数据？
- 通过在线程之间共享对象就可以了，
- 然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列 BlockingQueue就是为线程之间共享数据而设计的

# 保证&quot;可见性&quot;有哪几种方式？
- synchronized 和 viotatile

# 说几个常用的 Lock 接口实现锁。
- ReentrantLock、ReadWriteLock

# ThreadLocal 是什么？有什么应用场景？
- ThreadLocal 的作用是提供线程内的局部变量
- 这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。用来解决数据库连接、Session 管理等。

# ReadWriteLock 有什么用？
- ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现
- 实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能

# 怎么唤醒一个阻塞的线程？
- 如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它
- 如果线程遇到了 IO 阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统

# 不可变对象对多线程有什么帮助？
- 不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率

# 多线程上下文切换是什么意思？
- 多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。

# Java 中用到了什么线程调度算法？
- 抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

# Thread.sleep(0)的作用是什么？
- 由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制 权的一种操作

# Hashtable 的 size()方法为什么要做同步？
- 同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B则可以正常调用 size()方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对size++，线程 B 就已经读取 size了，那么对于线程 B 来说读取到的size 一定是不准 确的。而给 size()方法加了同步之后，意味着线程 B 调用size()方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性。

# 同步方法和同步块，哪种更好？
- 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率
- 请知道一条原则：同步的范围越小越好。

# Runnable 和 Thread 用哪个好？
- Java 不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也为了减少类之间的耦合性，Runnable 会更好

# Java 中 notify 和 notifyAll 有什么区别？
- notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行

# 为什么 wait/notify/notifyAll 这些方法不在 thread 类里面？
- 原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果 wait()方法定 义在 Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait， notify 和 notifyAll都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象

# 为什么 wait 和 notify 方法要在同步块中调用？
- 为了避免 wait 和 notify 之间产生竞态条件
- 为Java API强制要求，否则会抛出IllegalMonitorStateException 异常

# 为什么你应该在循环中检查等待条件？
- 处于等待状态的线程可能会收到错误警报和伪唤醒
- 如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出
- 因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因

# 你如何在 Java 中获取线程堆栈？
- jstack 这个工具来获取，它对进程 id 进行操作，用 jps 这个工具找到 id。

# 如何创建线程安全的单例模式？
- 单例模式即一个 JVM 内存中只存在一个类的对象实例分类
    - 懒汉式 类加载的时候就创建实例
    - 饿汉式 使用的时候才创建实例

# 什么是阻塞式方法？
- 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接
- 这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

# 提交任务时线程池队列已满会时发会生什么？
- 当线程数小于最大线程池数 maximumPoolSize 时就会创建新线程来处理
- 线程数大于等于最大线程池数 maximumPoolSize 时就会执行拒绝策略
- 如果你使⽤的LinkedBlockingQueue，也就是⽆界队列的话，没关系，继续添加任务到阻塞队列中等待执⾏，因为LinkedBlockingQueue可以近乎认为是⼀个⽆穷⼤的队列，可以⽆限存放任务；
- 如果你使⽤的是有界队列⽐⽅说ArrayBlockingQueue的话，任务⾸先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使⽤拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。

# 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
- 可以用join方法实现

# 在Java中Lock接口比synchronized块的优势是什么？
- lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁

# 你将如何使用threaddump？你将如何分析Thread dump？
- 在UNIX中你可以使用kill -3，然后thread dump将会打印日志
- 在windows中你可以使用”CTRL+Break”

# 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
- 当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码
- 但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码

# Java中你怎样唤醒一个阻塞的线程？
- 如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程
- 如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它

# Java并发类库提供的线程池有哪几种？ 分别有什么特点？
- 通常利用Executors提供的通用线程池创建方法，去创建不同配置的线程池,主要区别在于不同的ExecutorService类型或者不同的初始参数
- Executors目前提供了5种不同的线程池创建配置
    - newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点:
        - 它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程
        - 如果线程闲置的时间超过60S，则被终止并移出缓存
        - 长时间闲置时，这种线程池不会消耗资源
    - newFixedThreadPool(int  nThreads)：重用指定数目的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现，如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads
    - newSingleThreadExecutor()：它的特点在于工作线程数目被限制为1,操作一个无界的工作队列,所以它保证了所有任务的都是被顺序执行,最多会有一个任务处于活动状态,并且不允许使用者改造线程实例,因此可以避免其改变线程数目。
    - newSingleThreadScheduledExecutor()和newSecheduledThreadPool(int  corePoolSize),创建的是个ScheduledExecutorService,可以进行定时或周期性的工作调度,区别在于单一工作线程还是多个工作线程。

# ⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？
- ⾼并发、任务执⾏时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下⽂的切换
- 并发不⾼、任务执⾏时间⻓的业务要区分开看：
    - 假如是业务时间⻓集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占⽤CPU，所以不要让所有的CPU闲下来，可以加⼤线程池中的线程数⽬，让CPU处理更多的业务
    - 假如是业务时间⻓集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）⼀样吧，线程池中的线程数设置得少⼀些，减少线程上下⽂的切换
- 并发⾼、业务执⾏时间⻓，解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，看看这些业务⾥⾯某些数据是否能做缓存是第⼀步，增加服务器是第⼆步，⾄于线程池的设置，设置参考（2）。最后，业务执⾏时间⻓的问题，也可能需要分析⼀下，看看能不能使⽤中间件对任务进⾏拆分和解耦。

# 线程安全和线程不安全
#### 线程安全
- 线程安全就是多线程访问时，采⽤了加锁机制，当⼀个线程访问该类的某个数据时，进⾏保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使⽤。不会出现数据不⼀致或者数据污染。
- 线程安全是一个多线程环境下正确性的概念,也就是保证多线程环境下共享的可修改的状态的正确性,这里的状态反映在程序中其实可以看做是数据。
- 换个角度来看,如果状态不是共享的,或者不是可修改的,也就不存在线程安全问题,进而可以推理出保证线程安全的两个办法
    - 第一个是封装,我们可以将对象内部状态隐藏保护起来
    - 第二个是不可变。
- 线程安全需要保证几个基本特性
    - 原子性：简单来说就是相关操作不会中途被其他线程干扰,一般通过同步机制实现
    - 可见性：是一个线程修改了某个共享变量,其状态能够立即被其他线程知晓,通常被解释为将线程本地状态反映到主内存中,volatile关键字就是负责保证可见性的
    - 有序性：是保证线程内串行语义, 避免指令重排等

#### 线程不安全
- 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据
- 线程安全问题都是由全局变量及静态变量引起的
- 若每个线程中对全局变量、静态变量只有读操作，⽽⽆写操作，⼀般来说，这个全局变量是线程安全的
- 若有多个线程同时执⾏写操作，⼀般都需要考虑线程同步，否则的话就可能影响线程安全


# 如何保证集合是线程安全的?    ConcurrentHashMap 如何实现高效的线程安全?
- 在传统集合框架内部,除了Hashtable  Vector等同步容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个 同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等
- Vector 是⽤同步⽅法来实现线程安全的, ⽽和它相似的ArrayList不是线程安全的

# 为什么需要ConcurrentHashMap?
- Hashtable本身比较低效,因为它的实现基本就是put  get  size等各种方法加上&quot;synchronized&quot;
- 这就导致了所有并发操作都要竞争同一把锁,一个线程在进行同步操作时,其他线程只能等待,大大降低了并发操作的效率
- HashMap不是线程安全的,那么能不能利用Collections提供的同步包装器来解决问题
- 实际上同步器只是利用 输入Map构造了另一个同步版本,所有操作不再声明为synchronized方法,但是还是利用
- Hashtable或者同步包装版本,都只是适合在非高度并发的场景下

# ConcurrentHashMap工作机制
- 在早期的ConcurrentHashMap,其实现是基于分离锁,也就是将内部进行分段,里面则是HashEntry的数据
- 和HashMap类似,哈希相同的条目也是以链表形式存放。(简单点来说,就是在ConcurrentHashMap中,把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中)在构造的时候,Segment的数量由所谓的concurrentcyLevel来决定,默认是16,也可以在相应构造函数直接指定。注意,Java需要它是2的幂数值,如果输入是类似15这种非幂值,会自动调整到16之类2的幂数值。
- ConcurrentHashMap的工作机制就是通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。

# 什么是CAS
- CAS（compare and swap）的缩写，中⽂翻译成⽐较并交换。
- CAS 不通过JVM,直接利⽤java本地⽅ JNI（Java Native Interface为JAVA本地调⽤）,直接调⽤CPU 的cmpxchg（是汇编指令）指令
- 利⽤CPU的CAS指令，同时借助JNI来完成Java的⾮阻塞算法,实现原⼦操作。其它原⼦操作都是利⽤类似的特性完成的。
- 整个java.util.concurrent都是建⽴在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很⼤的提升。
- CAS是项乐观锁技术，当多个线程尝试使⽤CAS同时更新同⼀个变量时，只有其中⼀个线程能更新变量的值，⽽其它线程都失败，失败的线程并不会被挂起，⽽是被告知这次竞争中失败，并可以再次尝试
- 使⽤CAS在线程冲突严重时，会⼤幅降低程序性能；CAS只适合于线程冲突较少的情况使⽤。
- synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是⾃旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了⾼吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；⽽线程冲突严重的情况下，性能远⾼于CAS

# 什么是AQS
- AbstractQueuedSynchronizer简称AQS，是⼀个⽤于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等
- AQS解决了在实现同步容器时设计的⼤量细节问题。
- AQS使⽤⼀个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护⼀个等待状态waitStatus。

# 什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？
- 原⼦操作是指⼀个不受其他操作影响的操作任务单元
- 原⼦操作是在多线程环境下避免数据不⼀致必须的⼿段。
- int++并不是⼀个原⼦操作，所以当⼀个线程读取它的值并加1时，另外⼀个线程有可能会读到之前的值，这就会引发错误。
- 为了解决这个问题，必须保证增加操作是原⼦的，在JDK1.5之前我们可以使⽤同步技术来做到这⼀点到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以⾃动的保证对于他们的操作是原⼦的并且不需要使⽤同步

# 什么是阻塞队列
- 阻塞队列是⼀个在队列基础上⼜⽀持了两个附加操作的队列。
    - ⽀持阻塞的插⼊⽅法：队列满时，队列会阻塞插⼊元素的线程，直到队列不满。
    - ⽀持阻塞的移除⽅法：队列空时，获取元素的线程会等待队列变为⾮空。
- JDK7提供了7个阻塞队列
    - ArrayBlockingQueue ：⼀个由数组结构组成的有界阻塞队列。
    - LinkedBlockingQueue ：⼀个由链表结构组成的有界阻塞队列。
    - PriorityBlockingQueue ：⼀个⽀持优先级排序的⽆界阻塞队列。
    - DelayQueue：⼀个使⽤优先级队列实现的⽆界阻塞队列。
    - SynchronousQueue：⼀个不存储元素的阻塞队列。
    - LinkedTransferQueue：⼀个由链表结构组成的⽆界阻塞队列。
    - LinkedBlockingDeque：⼀个由链表结构组成的双向阻塞队列。

# 什么是同步容器和并发容器的实现？
#### 同步容器
- 主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。
- 锁的粒度为当前对象整体。
- 迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。

#### 并发容器
- 主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。
- 锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。
- 迭代器具有弱⼀致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。
- ConcurrentHashMap采⽤分段锁技术，同步容器中，是⼀个容器⼀个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若⼲段，每段维护⼀个锁，以达到⾼效的并发访问；

# ThreadLocal
#### ThreadLocal的设计理念与作⽤？
- Java中的ThreadLocal类允许我们创建只能被同⼀个线程读写的变量
- 如果⼀段代码含有⼀个ThreadLocal变量的引⽤，即使两个线程同时执⾏这段代码，它们也⽆法访问到对⽅的ThreadLocal变量

#### 概念
- 线程局部变量
- 变量是同⼀个，但是每个线程都使⽤同⼀个初始值，也就是使⽤同⼀个变量的⼀个新的副本。这种情况之下ThreadLocal就⾮常适⽤，⽐如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是⼀个线程安全的变量。⽽我们每个线程都需要使⽤他，并且各⾃使⽤各⾃的。这种情况，ThreadLocal就⽐较好的解决了这个问题。

#### 原理
- 从本质来讲，就是每个线程都维护了⼀个map，⽽这个map的key就是threadLocal，⽽值就是我们set的那个值
- 每次线程在get的时候，都从⾃⼰的变量中取值，既然从⾃⼰的变量中取值，那肯定就不存在线程安全问题
- ThreadLocal这个变量的状态根本没有发⽣变化，他仅仅是充当⼀个key的⻆⾊，另外提供给每⼀个线程⼀个初始值。

#### 实现机制
- 每个Thread对象内部都维护了⼀个ThreadLocalMap这样⼀个ThreadLocal的Map，可以存放若⼲个ThreadLocal。

#### 应⽤场景
- 当很多线程需要多次使⽤同⼀个对象，并且需要该对象具有相同初始化值的时候最适合使⽤ThreadLocal。

# Semaphore有什么作⽤？
- Semaphore就是⼀个信号量
- 作⽤是限制某段代码块的并发数

# Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？
- 同⼀时间只能有⼀条线程执⾏固定类的同步⽅法，但是对于类的⾮同步⽅法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执⾏Hashtable的put⽅法添加数据，线程B则可以正常调⽤size()⽅法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size⼀定是不准确的。
- ⽽给size()⽅法加了同步之后，意味着线程B调⽤size()⽅法只有在线程A调⽤put⽅法完毕之后才可以调⽤，这样就保证了线程安全性。

# ConcurrentHashMap的并发度是什么？
- ⼯作机制（分⽚思想）：它引⼊了⼀个“分段锁”的概念，具体可以理解为把⼀个⼤的Map拆分成N个⼩的segment，根据key.hashCode()来决定把key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。
- 应⽤：当读&gt;写时使⽤，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；
- hash冲突：
    - 简介：HashMap中调⽤hashCode()⽅法来计算hashCode。由于在Java中两个不同的对象可能有⼀样的hashCode,所以不同的键可能有⼀样hashCode，从⽽导致冲突的产⽣。
    - hash冲突解决：使⽤平衡树来代替链表，当同⼀hash中的元素数量超过特定的值便会由链表切换到平衡树
- ⽆锁读：ConcurrentHashMap之所以有较好的并发性是因为ConcurrentHashMap是⽆锁读和加锁写，并且利⽤了分段锁（不是在所有的entry上加锁，⽽是在⼀部分entry上加锁）；读之前会先判断count(jdk1.6)，其中的count是被volatile修饰的(当变量被volatile修饰后，每次更改该变量的时候会将更改结果写到系统主内存中，利⽤多处理器的缓存⼀致性，其他处理器会发现⾃⼰的缓存⾏对应的内存地址被修改，就会将⾃⼰处理器的缓存⾏设置为失效，并强制从系统主内存获取最新的数据。)，故可以实现⽆锁读。
- ConcurrentHashMap的并发度就是segment的⼤⼩，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最⼤优势。

# ReentrantReadWriteLock读写锁的使⽤
- 读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm⾃⼰控制的，你只要上好相应的锁即可
- 如果你的代码只读数据，可以很多⼈同时读，但不能同时写，那就上读锁
- 如果你的代码修改数据，只能有⼀个⼈在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁

# 锁的等级：⽅法锁、对象锁、类锁?
#### ⽅法锁（synchronized修饰⽅法时）
    - 通过在⽅法声明中加⼊ synchronized关键字来声明 synchronized ⽅法。
    - synchronized ⽅法控制对类成员变量的访问：
    - 每个类实例对应⼀把锁，每个 synchronized ⽅法都必须获得调⽤该⽅法的类实例的锁⽅能执⾏，否则所属线程阻塞，⽅法⼀旦执⾏，就独占该锁，直到从该⽅法返回时才将锁释放，此后被阻塞的线程⽅能获得该锁，重新进⼊可执⾏状态
    - 这种机制确保了同⼀时刻对于每⼀个类实例，其所有声明为 synchronized 的成员函数中⾄多只有⼀个处于可执⾏状态，从⽽有效避免了类成员变量的访问冲突。

#### 对象锁（synchronized修饰⽅法或代码块）
- 当⼀个对象中有synchronized method或synchronized block的时候调⽤此对象的同步⽅法或进⼊其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调⽤者占⽤，则需要等待此锁被释放。（⽅法锁也是对象锁）
- java的所有对象都含有1个互斥锁，这个锁由JVM⾃动获取和释放
- 线程进⼊synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待
- synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁
- 这⾥也体现了⽤synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来⾃动释放。　

#### 类锁(synchronized 修饰静态的⽅法或代码块)
- 由于⼀个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有⼀份。所以，⼀旦⼀个静态的⽅法被申明为synchronized。此类所有的实例化对象在调⽤此⽅法，共⽤同⼀把锁，我们称之为类锁。
- 对象锁是⽤来控制实例⽅法之间的同步，类锁是⽤来控制静态⽅法（或静态变量互斥体）之间的同步

# 如果同步块内的线程抛出异常会发⽣什么？
- synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁

# 并发编程（concurrency）并⾏编程（parallellism）有什么区别？
- 并⾏是指两个或者多个事件在同⼀时刻发⽣；⽽并发是指两个或多个事件在同⼀时间间隔发⽣。
- 并⾏是在不同实体上的多个事件，并发是在同⼀实体上的多个事件。
- 在⼀台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群所以并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能。

# 如何保证多线程下 i++ 结果正确？
- volatile只能保证你数据的可⻅性，获取到的是最新的数据，不能保证原⼦性；
- ⽤AtomicInteger保证原⼦性。
- synchronized既能保证共享变量可⻅性，也可以保证锁内操作的原⼦性。

# ⼀个线程如果出现了运⾏时异常会怎么样?
- 如果这个异常没有被捕获的话，这个线程就停⽌执⾏了。
- 另外重要的⼀点是：如果这个线程持有某个对象的监视器，那么这个对象监视器会被⽴即释放.

# 如何在两个线程之间共享数据?
- 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进⾏唤起和等待
- ⽐⽅说阻塞队列BlockingQueue就是为线程之间共享数据⽽设计的。

# 










# ⽣产者消费者模型的作⽤是什么?
- 通过平衡⽣产者的⽣产能⼒和消费者的消费能⼒来提升整个系统的运⾏效率，这是⽣产者消费者模型最重要的作⽤
- 解耦，这是⽣产者消费者模型附带的作⽤，解耦意味着⽣产者和消费者之间的联系少，联系越少越可以独⾃发展⽽不需要受到相互的制约。

# 怎么唤醒⼀个阻塞的线程?
- 如果线程是因为调⽤了wait()、sleep()或者join()⽅法⽽导致的阻塞
- suspend与resume，Java废弃suspend() 去挂起线程的原因，是因为suspend() 在导致线程暂停的同时，并不会释放任何锁资源。其他线程都⽆法访问被它占⽤的锁。直到对应的线程执⾏resume() ⽅法后，被挂起的线程才能继从⽽其它被阻塞在这个锁的线程才可以继续执⾏。但是，如果resume()操作出现在 suspend(之前执⾏，那么线程将⼀直处于挂起状态，同时⼀直占⽤锁，这就产⽣了死锁。⽽且，对于被挂起的线程，它的线程状态居然还是 Runnable。
- wait与notify，wait与notify必须配合synchronized使⽤，因为调⽤之前必须持有锁，wait会⽴即释放锁，notify则是同步块执⾏完了才释放
- await与singal，Condition类提供，⽽Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使⽤Lock锁后⽆法使⽤wait⽅法
- park与unpark
    LockSupport是⼀个⾮常⽅便实⽤的线程阻塞⼯具，它可以在线程任意位置让线程阻塞。和Thread.suspenf()相
    ⽐，它弥补了由于resume()在前发⽣，导致线程⽆法继续执⾏的情况。和Object.wait()相⽐，它不需要先获得某个对
    象的锁，也不会抛出IException异常。可以唤醒指定线程。

89. 如果线程遇到了IO阻塞，⽆能为⼒，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
90. Java中⽤到的线程调度算法是什么
91. 抢占式。⼀个线程⽤完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出⼀个总的优先级并分配下⼀
    个时间⽚给某个线程执⾏。
92. 单例模式的线程安全性?
    ⾸先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建⼀次出来。单
    例模式有很多种的写法，我总结⼀下：
    （1）饿汉式单例模式的写法：线程安全
    （2）懒汉式单例模式的写法：⾮线程安全
    （3）双检锁单例模式的写法：线程安全
93. 线程类的构造⽅法、静态块是被哪个线程调⽤的?
    线程类的构造⽅法、静态块是被new这个线程类所在的线程所调⽤的，⽽run⽅法⾥⾯的代码才是被线程⾃身所调⽤的。
94. 同步⽅法和同步块，哪个是更好的选择?
95. 同步块是更好的选择，因为它不会锁住整个对象（当然也可以让它锁住整个对象）。同步⽅法会锁住整个对象，哪怕
    这个类中有多个不相关联的同步块，这通常会导致他们停⽌执⾏并需要等待获得这个对象上的锁。
    synchronized(this)以及⾮static的synchronized⽅法（⾄于static synchronized⽅法请往下看），只能防⽌多个线程同时
    执⾏同⼀个对象的同步代码段。
    如果要锁住多个对象⽅法，可以锁住⼀个固定的对象，或者锁住这个类的Class对象。
    synchronized锁住的是括号⾥的对象，⽽不是代码。对于⾮static的synchronized⽅法，锁的就是对象本身也就是this。

97. 如何检测死锁？怎么预防死锁？
98. 概念：
    是指两个或两个以上的进程在执⾏过程中，因争夺资源⽽造成的⼀种互相等待的现象，若⽆外⼒作⽤，它们都将⽆
    法推进下去。此时称系统处于死锁；
99. 死锁的四个必要条件：
    i. 互斥条件：进程对所分配到的资源不允许其他进程进⾏访问，若其他进程访问该资源，只能等待，直⾄占有该资源
    的进程使⽤完成后释放该资源
    ii. 请求和保持条件：进程获得⼀定的资源之后，⼜对其他资源发出请求，但是该资源可能被其他进程占有，此时请
    求阻塞，但⼜对⾃⼰获得的资源保持不放
    iii. 不可剥夺条件：是指进程已获得的资源，在未完成使⽤之前，不可被剥夺，只能在使⽤完后⾃⼰释放
    iv. 环路等待条件：是指进程发⽣死锁后，若⼲进程之间形成⼀种头尾相接的循环等待资源关系
100.    死锁产⽣的原因：
        1.因竞争资源发⽣死锁 现象：系统中供多个进程共享的资源的数⽬不⾜以满⾜全部进程的需要时，就会引起对诸资
        源的竞争⽽发⽣死锁现象
        2.进程推进顺序不当发⽣死锁
101.    检查死锁
        i. 有两个容器，⼀个⽤于保存线程正在请求的锁，⼀个⽤于保存线程已经持有的锁。每次加锁之前都会做如下检测:
        ii. 检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来
        iii. 遍历第⼀步中返回的线程，检查⾃⼰持有的锁是否正被其中任何⼀个线程请求，如果第⼆步返回真,表示出现了死
        锁
102.    死锁的解除与预防：控制不要让四个必要条件成⽴。
103.    HashMap在多线程环境下使⽤需要注意什么？
        要注意死循环的问题，HashMap的put操作引发扩容，这个动作在多线程并发下会发⽣线程死循环的问题。
        2、多个线程同时扩容，造成数据丢失；
        3、多线程扩容时导致Node链表形成环形结构造成.next()死循环，导致CPU利⽤率接近100%；
104.    什么是守护线程？有什么⽤？
        守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程，这是它的作⽤——⽽其他的线程只有
        ⼀种，那就是⽤户线程。所以java⾥线程分2种，
        1、守护线程，⽐如垃圾回收线程，就是最典型的守护线程。
        2、⽤户线程，就是应⽤程序⾥的⾃定义线程。
105.    如何实现线程串⾏执⾏？
        a. 为了控制线程执⾏的顺序，如ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执⾏三个线程，我们需要确定唤醒、等待
        的顺序。这时我们可以同时使⽤ Obj.wait()、Obj.notify()与synchronized(Obj)来实现这个⽬标。
        线程中持有上⼀个线程类的对象锁以及⾃⼰的锁，由于这种依赖关系，该线程执⾏需要等待上个对象释放锁，从⽽
        保证类线程执⾏的顺序。
        b. 通常情况下，wait是线程在获取对象锁后，主动释放对象锁，同时本线程休眠，直到有其它线程调⽤对象的notify()唤
        醒该线程，才能继续获取对象锁，并继续执⾏。⽽notify()则是对等待对象锁的线程的唤醒操作。但值得注意的是notify()
        调⽤后，并不是⻢上就释放对象锁，⽽是在相应的synchronized()&#123;&#125;语句块执⾏结束。释放对象锁后，JVM会在执⾏
        wait()等待对象锁的线程中随机选取⼀线程，赋予其对象锁，唤醒线程，继续执⾏。

106.    可以运⾏时kill掉⼀个线程吗？
        a. 不可以
        b. 只有当线程run⽅法或者主线程main⽅法结束，⼜或者抛出异常时，线程才会结束⽣命周期。
107.    关于synchronized：
108.    在某个对象的所有synchronized⽅法中,在某个时刻只能有⼀个唯⼀的⼀个线程去访问这些synchronized⽅法
109.    如果⼀个⽅法是synchronized⽅法,那么该synchronized关键字表示给当前对象上锁(即this)相当于
        synchronized(this)&#123;&#125;
110.    如果⼀个synchronized⽅法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管⽣成
        多少对象,其对应的class对象只有⼀个)
111.    分步式锁,程序数据库中死锁机制及解决⽅案
        基本原理：⽤⼀个状态值表示锁，对锁的占⽤和释放通过状态值来标识。
        1、三种分布式锁：
        1、Zookeeper：基于zookeeper瞬时有序节点实现的分布式锁，其主要逻辑如下。⼤致思想即为：每个客户端对某个
        功能加锁时，在zookeeper上的与该功能对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点。判断是否获取锁的⽅式很简
        单，只需要判断有序节点中序号最⼩的⼀个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁
        ⽆法释放，⽽产⽣的死锁问题。

2、优点
锁安全性⾼，zk可持久化，且能实时监听获取锁的客户端状态。⼀旦客户端宕机，则瞬时节点随之消失，zk因
⽽能第⼀时间释放锁。这也省去了⽤分布式缓存实现锁的过程中需要加⼊超时时间判断的这⼀逻辑。
3、缺点
性能开销⽐较⾼。因为其需要动态产⽣、销毁瞬时节点来实现锁功能。所以不太适合直接提供给⾼并发的场景
使⽤。
4、实现
可以直接采⽤zookeeper第三⽅库curator即可⽅便地实现分布式锁。
5、适⽤场景
对可靠性要求⾮常⾼，且并发程度不⾼的场景下使⽤。如核⼼数据的定时全量/增量同步等。
2、memcached：memcached带有add函数，利⽤add函数的特性即可实现分布式锁。add和set的区别在于：如果多
线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。⽽add的话则相反，add会添加第⼀个到达的值，并
返回true，后续的添加则都会返回false。利⽤该点即可很轻松地实现分布式锁。
2、优点
并发⾼效
3、缺点
memcached采⽤列⼊LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。
memcached⽆法持久化，⼀旦重启，将导致信息丢失。
4、使⽤场景
⾼并发场景。需要 1)加上超时时间避免死锁; 2)提供⾜够⽀撑锁服务的内存空间; 3)稳定的集群化管理。
3、redis：redis分布式锁即可以结合zk分布式锁锁⾼度安全和memcached并发场景下效率很好的优点，其实现⽅式和
memcached类似，采⽤setnx即可实现。需要注意的是，这⾥的redis也需要设置超时时间，以避免死锁。
2、数据库死锁机制和解决⽅案：
1、死锁：死锁是指两个或者两个以上的事务在执⾏过程中，因争夺锁资源⽽造成的⼀种互相等待的现象。
2、处理机制：解决死锁最有⽤最简单的⽅法是不要有等待，将任何等待都转化为回滚，并且事务重新开始。但是有可能
影响并发性能。
1、超时回滚，innodb\_lock\_wait\_time设置超时时间；
2、wait-for-graph⽅法：跟超时回滚⽐起来，这是⼀种更加主动的死锁检测⽅式。InnoDB引擎也采⽤这种⽅
式。

1.  spring单例为什么没有安全问题(ThreadLocal)
    1、ThreadLocal：spring使⽤ThreadLocal解决线程安全问题；ThreadLocal会为每⼀个线程提供⼀个独⽴的变量副本，从⽽
    隔离了多个线程对数据的访问冲突。
    2、单例：⽆状态的Bean(⽆状态就是⼀次操作，不能保存数据。⽆状态对象(Stateless Bean)，就是没有实例变量的对象，不
    能保存数据，是不变类，是线程安全的。)适合⽤不变模式，技术就是单例模式，这样可以共享实例，提⾼性能。
2.  线程池原理：
    1、使⽤场景：使⽤线程池，以提⾼服务器性能；
    2、组成：
    1、线程池管理器（ThreadPool）：⽤于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
    2、⼯作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执⾏任务；
    3、任务接⼝（Task）：每个任务必须实现的接⼝，以供⼯作线程调度任务的执⾏，它主要规定了任务的⼊⼝，任务执⾏完后
    的收尾⼯作，任务的执⾏状态等；
    4、任务队列（taskQueue）：⽤于存放没有处理的任务。提供⼀种缓冲机制。
    2、原理：线程池技术正是关注如何缩短或调整T1,T3时间的技术，从⽽提⾼服务器程序性能的。它把T1，T3分别安排在服务器程
    序的启动和结束的时间段或者⼀些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。
    3、⼯作流程：
    1、线程池刚创建时，⾥⾯没有⼀个线程(也可以设置参数prestartAllCoreThreads启动预期数量主线程)。任务队列是作
    为参数传进来的。不过，就算队列⾥⾯有任务，线程池也不会⻢上执⾏它们。
    2、当调⽤ execute() ⽅法添加⼀个任务时，线程池会做如下判断：
3.  如果正在运⾏的线程数量⼩于 corePoolSize，那么⻢上创建线程运⾏这个任务；
4.  如果正在运⾏的线程数量⼤于或等于 corePoolSize，那么将这个任务放⼊队列；
5.  如果这时候队列满了，⽽且正在运⾏的线程数量⼩于 maximumPoolSize，那么还是要创建⾮核⼼线程⽴刻运⾏这个
    任务；
6.  如果队列满了，⽽且正在运⾏的线程数量⼤于或等于 maximumPoolSize，那么线程池会抛出异常
    RejectExecutionException。
    3、当⼀个线程完成任务时，它会从队列中取下⼀个任务来执⾏。
    4、当⼀个线程⽆事可做，超过⼀定的时间（keepAliveTime）时，线程池会判断，如果当前运⾏的线程数⼤于
    corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的⼤⼩。
7.  java锁多个对象：
    例如： 在银⾏系统转账时，需要锁定两个账户，这个时候，顺序使⽤两个synchronized可能存在死锁的情况，在⽹上搜索到下⾯的例
    ⼦：
    1 public class Bank &#123;
    2 final static Object obj\_lock = new Object();
    3
    4 // Deadlock crisis 死锁
    5 public void transferMoney(Account from, Account to, int number) &#123;
    6 synchronized (from) &#123;
    7 synchronized (to) &#123;
    8 from.debit();
    9 to.credit();
    10 &#125;
    11 &#125;
    12 &#125;
    13
    14 // Thread safe
    15 public void transferMoney2(final Account from, final Account to, int number) &#123;
    16 class Help &#123;
    17 void transferMoney2() &#123;
    18 from.debit();
    19 to.credit();
    20 &#125;
    21 &#125;
    22
    23 //通过hashCode⼤⼩调整加锁顺序
    24 int fromHash = from.hashCode();
    25 int toHash = to.hashCode();
    26
    27 if (fromHash &lt; toHash) &#123;
    28 synchronized (from) &#123;
    29 synchronized (to) &#123;
    30 new Help().transferMoney2();
    31 &#125;
    32 &#125;
    33 &#125; else if (toHash &lt; fromHash) &#123;
    34 synchronized (to) &#123;
    35 synchronized (from) &#123;
    36 new Help().transferMoney2();
    37 &#125;
    38 &#125;
    39 &#125; else &#123;
    40 synchronized (obj\_lock) &#123;
    41 synchronized (to) &#123;
    42 synchronized (from) &#123;
    43 new Help().transferMoney2();
    44 &#125;
    45 &#125;
    46 &#125;
    47 &#125;
    48 &#125;
    49 &#125;
    若操作账户A，B：
8.  A的hashCode⼩于B， 先锁A再锁B
9.  B的hashCode⼩于A， 先锁B再锁A
10. 产⽣的hashCode相等，先锁住⼀个全局静态变量，在锁A，B
    这样就避免了两个线程分别操作账户A,B和B,A⽽产⽣死锁的情况。
    需要为Account对象写⼀个好的hashCode算法，使得不同账户间产⽣的hashCode尽量不同。
11. java线程如何启动：
    1、继承Thread类；
    2、实现Runnable接⼝；
    3、直接在函数体内：
    4、⽐较：
    1、实现Runnable接⼝优势：
    1）适合多个相同的程序代码的线程去处理同⼀个资源
    2）可以避免java中的单继承的限制
    3）增加程序的健壮性，代码可以被多个线程共享，代码和数据独⽴。
    2、继承Thread类优势：
    1）可以将线程类抽象出来，当需要使⽤抽象⼯⼚模式设计时。
    2）多线程同步
    3、在函数体使⽤优势
    1）⽆需继承thread或者实现Runnable，缩⼩作⽤域。
12. java中加锁的⽅式有哪些,如何实现怎么个写法.
    1、java中有两种锁：⼀种是⽅法锁或者对象锁(在⾮静态⽅法或者代码块上加锁)，第⼆种是类锁(在静态⽅法或者class上加锁)；
    2、注意：其他线程可以访问未加锁的⽅法和代码；synchronized同时修饰静态⽅法和实例⽅法，但是运⾏结果是交替进⾏的，这证明
    了类锁和对象锁是两个不⼀样的锁，控制着不同的区域，它们是互不⼲扰的。
    3、示例代码：
    1、⽅法锁和同步代码块：
    1 public class TestSynchronized
    2 &#123;
    3 public void test1()
    4 &#123;
    5 synchronized(this)
    6 &#123;
    7 int i = 5;
    8 while( i-- &gt; 0)
    9 &#123;
    10 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
    11 try
    12 &#123;
    13 Thread.sleep(500);
    14 &#125;
    15 catch (InterruptedException ie)
    16 &#123;
    17 &#125;
    18 &#125;
    19 &#125;
    20 &#125;
    21
    22 public synchronized void test2()
    23 &#123;
    24 int i = 5;
    25 while( i-- &gt; 0)
    26 &#123;
    27 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
    28 try
    29 &#123;
    30 Thread.sleep(500);
    31 &#125;
    32 catch (InterruptedException ie)
    33 &#123;
    34 &#125;
    35 &#125;
    36 &#125;
    37
    38 public static void main(String\[] args)
    39 &#123;
    40 final TestSynchronized myt2 = new TestSynchronized();
    41 Thread test1 = new Thread( new Runnable() &#123; public void run() &#123; myt2.test1(); &#125; &#125;,
    42 Thread test2 = new Thread( new Runnable() &#123; public void run() &#123; myt2.test2(); &#125; &#125;,
    43 test1.start();;
    44 test2.start();
    45 // TestRunnable tr=new TestRunnable();
    46 // Thread test3=new Thread(tr);
    47 // test3.start();
    48 &#125;
    49 &#125;
    2、类锁：
    1 public class TestSynchronized
    2 &#123;
    3 public void test1()
    4 &#123;
    5 synchronized(TestSynchronized.class)
    6 &#123;
    7 int i = 5;
    8 while( i-- &gt; 0)
    9 &#123;
    10 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
    11 try
    12 &#123;
    13 Thread.sleep(500);
    14 &#125;
    15 catch (InterruptedException ie)
    16 &#123;
    17 &#125;
    18 &#125;
    19 &#125;
    20 &#125;
    21
    22 public static synchronized void test2()
    23 &#123;
    24 int i = 5;
    25 while( i-- &gt; 0)
    26 &#123;
    27 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
    28 try
    29 &#123;
    30 Thread.sleep(500);
    31 &#125;
    32 catch (InterruptedException ie)
    33 &#123;
    34 &#125;
    35 &#125;
    36 &#125;
    37
    38 public static void main(String\[] args)
    39 &#123;
    40 final TestSynchronized myt2 = new TestSynchronized();
    41 Thread test1 = new Thread( new Runnable() &#123; public void run() &#123; myt2.test1(); &#125; &#125;,
    42 Thread test2 = new Thread( new Runnable() &#123; public void run() &#123; TestSynchronized.test2
    43 test1.start();
    44 test2.start();
    45 // TestRunnable tr=new TestRunnable();
    46 // Thread test3=new Thread(tr);
    47 // test3.start();
    48 &#125;
    49
    50 &#125;
    62、如何保证数据不丢失：
    1、使⽤消息队列，消息持久化；
    2、添加标志位：未处理 0，处理中 1，已处理 2。定时处理。
    63、ThreadLocal为什么会发⽣内存泄漏？
    1、threadlocal原理图：
    2、OOM实现：
    1、ThreadLocal的实现是这样的：每个Thread 维护⼀个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实
    例本身，value 是真正需要存储的 Object。
    2、也就是说 ThreadLocal 本身并不存储值，它只是作为⼀个 key 来让线程从 ThreadLocalMap 获取 value。值得注意的
    是图中的虚线，表示 ThreadLocalMap 是使⽤ ThreadLocal 的弱引⽤作为 Key 的，弱引⽤的对象在 GC 时会被回收。
    3、ThreadLocalMap使⽤ThreadLocal的弱引⽤作为key，如果⼀个ThreadLocal没有外部强引⽤来引⽤它，那么系统 GC
    的时候，这个ThreadLocal势必会被回收，这样⼀来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这
    些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会⼀直存在⼀条强引⽤
    链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远⽆法回收，造成内存泄漏。
    3、预防办法：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap⾥所有key为null的value。
    但是这些被动的预防措施并不能保证不会内存泄漏：
    （1）使⽤static的ThreadLocal，延⻓了ThreadLocal的⽣命周期，可能导致内存泄漏。
    （2）分配使⽤了ThreadLocal⼜不再调⽤get(),set(),remove()⽅法，那么就会导致内存泄漏，因为这块内存⼀直存在。
    64、jdk8中对ConcurrentHashmap的改进
13. Java 7为实现并⾏访问，引⼊了Segment这⼀结构，实现了分段锁，理论上最⼤并发度与Segment个数相等。
14. Java 8为进⼀步提⾼并发性，摒弃了分段锁的⽅案，⽽是直接使⽤⼀个⼤的数组。同时为了提⾼哈希碰撞下的寻址性能，
    Java 8在链表⻓度超过⼀定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红⿊树（寻址时间复杂度为O(long(N))）。
    其数据结构如下图所示
    3、源码：
    1 public V put(K key, V value) &#123;
    2 return putVal(key, value, false);
    3 &#125;
    4
    5 /\*\* Implementation for put and putIfAbsent \*/
    6 final V putVal(K key, V value, boolean onlyIfAbsent) &#123;
    7 //ConcurrentHashMap 不允许插⼊null键，HashMap允许插⼊⼀个null键
    8 if (key == null || value == null) throw new NullPointerException();
    9 //计算key的hash值
    10 int hash = spread(key.hashCode());
    11 int binCount = 0;
    12 //for循环的作⽤：因为更新元素是使⽤CAS机制更新，需要不断的失败重试，直到成功为⽌。
    13 for (Node\&lt;K,V&gt;\[] tab = table;;) &#123;
    14 // f：链表或红⿊⼆叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。
    15 Node\&lt;K,V&gt; f; int n, i, fh;
    16 //判断Node\[]数组是否初始化，没有则进⾏初始化操作
    17 if (tab == null || (n = tab.length) == 0)
    18 tab = initTable();
    19 //通过hash定位Node\[]数组的索引坐标，是否有Node节点，如果没有则使⽤CAS进⾏添加（链表的头结点），添加失败则进⼊下次循环。
    20 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;
    21 if (casTabAt(tab, i, null,
    22 new Node\&lt;K,V&gt;(hash, key, value, null)))
    23 break; // no lock when adding to empty bin
    24 &#125;
    25 //检查到内部正在移动元素（Node\[] 数组扩容）
    26 else if ((fh = f.hash) == MOVED)
    27 //帮助它扩容
    28 tab = helpTransfer(tab, f);
    29 else &#123;
    30 V oldVal = null;
    31 //锁住链表或红⿊⼆叉树的头结点
    32 synchronized (f) &#123;
    33 //判断f是否是链表的头结点
    34 if (tabAt(tab, i) == f) &#123;
    35 //如果fh&gt;=0 是链表节点
    36 if (fh &gt;= 0) &#123;
    37 binCount = 1;
    38 //遍历链表所有节点
    39 for (Node\&lt;K,V&gt; e = f;; ++binCount) &#123;
    40 K ek;
    41 //如果节点存在，则更新value
    42 if (e.hash == hash &amp;&amp;
    43 ((ek = e.key) == key ||
    44 (ek != null &amp;&amp; key.equals(ek)))) &#123;
    45 oldVal = e.val;
    46 if (!onlyIfAbsent)
    47 e.val = value;
    48 break;
    49 &#125;
    50 //不存在则在链表尾部添加新节点。
    51 Node\&lt;K,V&gt; pred = e;
    52 if ((e = e.next) == null) &#123;
    53 pred.next = new Node\&lt;K,V&gt;(hash, key,
    54 value, null);
    55 break;
    56 &#125;
    57 &#125;
    58 &#125;
    59 //TreeBin是红⿊⼆叉树节点
    60 else if (f instanceof TreeBin) &#123;
    61 Node\&lt;K,V&gt; p;
    62 binCount = 2;
    63 //添加树节点
    64 if ((p = ((TreeBin\&lt;K,V&gt;)f).putTreeVal(hash, key,
    65 value)) != null) &#123;
    66 oldVal = p.val;
    67 if (!onlyIfAbsent)
    68 p.val = value;
    69 &#125;
    70 &#125;
    71 &#125;
    72 &#125;
    73
    74 if (binCount != 0) &#123;
    75 //如果链表⻓度已经达到临界值8 就需要把链表转换为树结构
    76 if (binCount &gt;= TREEIFY\_THRESHOLD)
    77 treeifyBin(tab, i);
    78 if (oldVal != null)
    79 return oldVal;
    80 break;
    81 &#125;
    82 &#125;
    83 &#125;
    84 //将当前ConcurrentHashMap的size数量+1
    85 addCount(1L, binCount);
    86 return null;
    87 &#125;
    65、concurrent包下有哪些类？
    ConcurrentHashMap、Future、FutureTask、AtomicInteger...
    66、线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?
    1、CountDownLatch类
    ⼀个同步辅助类，常⽤于某个条件发⽣后才能执⾏后续进程。给定计数初始化CountDownLatch，调⽤countDown(）⽅
    法，在计数到达零之前，await⽅法⼀直受阻塞。
    重要⽅法为countdown()与await()；
    2、join⽅法
    将线程B加⼊到线程A的尾部，当A执⾏完后B才执⾏。
    1 public static void main(String\[] args) throws Exception &#123;
    2 Th t = new Th(&quot;t1&quot;);
    3 Th t2 = new Th(&quot;t2&quot;);
    4 t.start();
    5 t.join();
    6 t2.start();
    7 &#125;
    3、notify、wait⽅法，Java中的唤醒与等待⽅法，关键为synchronized代码块，参数线程间应相同，也常⽤Object作为参
    数。
    67、⾼并发系统如何做性能优化？如何防⽌库存超卖？
    1、⾼并发系统性能优化：
    优化程序，优化服务配置，优化系统配置
    1.尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。
    2.⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。
    3.优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。
    4.优化数据库结构，多做索引，提⾼查询效率。
    5.统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。
    6.能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。
    7.解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。
    2、防⽌库存超卖：
    1、悲观锁：在更新库存期间加锁，不允许其它线程修改；
    1、数据库锁：select xxx for update；
    2、分布式锁；
    2、乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失
    败。
    1、redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。
    3、消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。
    4、总结：总的来说，不能把压⼒放在数据库上，所以使⽤ &quot;select xxx for update&quot; 的⽅式在⾼并发的场景下是不可⾏
    的。FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤。所以相对来说，我会倾向于
    选择：乐观锁 / 缓存锁 / 分布式锁的⽅式。
    68、线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？
    1、线程池简介：
    2、核⼼参数：
    3、⼯⼚⽅法作⽤：ThreadPoolExecutor类就是Executor的实现类，但ThreadPoolExecutor在使⽤上并不是那么⽅便，在实
    例化时需要传⼊很多歌参数，还要考虑线程的并发数等与线程池运⾏效率有关的参数，所以官⽅建议使⽤Executors⼯程类来
    创建线程池对象。
    69、说说java同步机制，java有哪些锁，每个锁的特性？
    70、说说volatile如何保证可⻅性，从cpu层⾯分析？

JAVA多线程之线程间的通信方式
一，介绍
本总结我对于JAVA多线程中线程之间的通信方式的理解，主要以代码结合文字的方式来讨论线程间的通信，故摘抄了书中的一些示例代码。
 
二，线程间的通信方式
①同步
这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。
参考示例：

public class MyObject &#123;

    synchronized public void methodA() &#123;
        //do something....
    &#125;

    synchronized public void methodB() &#123;
        //do some other thing
    &#125;

&#125;

public class ThreadA extends Thread &#123;

    private MyObject object;

//省略构造方法
@Override
public void run() &#123;
super.run();
object.methodA();
&#125;
&#125;

public class ThreadB extends Thread &#123;

    private MyObject object;

//省略构造方法
@Override
public void run() &#123;
super.run();
object.methodB();
&#125;
&#125;

public class Run &#123;
public static void main(String\[] args) &#123;
MyObject object = new MyObject();

        //线程A与线程B 持有的是同一个对象:object
        ThreadA a = new ThreadA(object);
        ThreadB b = new ThreadB(object);
        a.start();
        b.start();
    &#125;

&#125;

由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。
这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。
 
②while轮询的方式
代码如下：
import java.util.ArrayList;
import java.util.List;

public class MyList &#123;

    private List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    public void add() &#123;
        list.add(&quot;elements&quot;);
    &#125;
    public int size() &#123;
        return list.size();
    &#125;

&#125;

import mylist.MyList;

public class ThreadA extends Thread &#123;

    private MyList list;

    public ThreadA(MyList list) &#123;
        super();
        this.list = list;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                list.add();
                System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素&quot;);
                Thread.sleep(1000);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

import mylist.MyList;

public class ThreadB extends Thread &#123;

    private MyList list;

    public ThreadB(MyList list) &#123;
        super();
        this.list = list;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            while (true) &#123;
                if (list.size() == 5) &#123;
                    System.out.println(&quot;==5, 线程b准备退出了&quot;);
                    throw new InterruptedException();
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

import mylist.MyList;
import extthread.ThreadA;
import extthread.ThreadB;

public class Test &#123;

    public static void main(String[] args) &#123;
        MyList service = new MyList();

        ThreadA a = new ThreadA(service);
        a.setName(&quot;A&quot;);
        a.start();

        ThreadB b = new ThreadB(service);
        b.setName(&quot;B&quot;);
        b.start();
    &#125;

&#125;
在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信。但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是： 在干别的事情，当有电话来时，响铃通知TA电话来了。关于线程的轮询的影响，可参考：JAVA多线程之当一个线程在执行死循环时会影响另外一个线程吗？
这种方式还存在另外一个问题：
轮询的条件的可见性问题，关于内存可见性问题，可参考：JAVA多线程之volatile 与 synchronized 的比较中的第一点“一，volatile关键字的可见性”
线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的 条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。
 
③wait/notify机制
代码如下：
import java.util.ArrayList;
import java.util.List;

public class MyList &#123;

    private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();

    public static void add() &#123;
        list.add(&quot;anyString&quot;);
    &#125;

    public static int size() &#123;
        return list.size();
    &#125;

&#125;

public class ThreadA extends Thread &#123;

    private Object lock;

    public ThreadA(Object lock) &#123;
        super();
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            synchronized (lock) &#123;
                if (MyList.size() != 5) &#123;
                    System.out.println(&quot;wait begin &quot;
                            + System.currentTimeMillis());
                    lock.wait();
                    System.out.println(&quot;wait end  &quot;
                            + System.currentTimeMillis());
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

public class ThreadB extends Thread &#123;
private Object lock;

    public ThreadB(Object lock) &#123;
        super();
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            synchronized (lock) &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    MyList.add();
                    if (MyList.size() == 5) &#123;
                        lock.notify();
                        System.out.println(&quot;已经发出了通知&quot;);
                    &#125;
                    System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;);
                    Thread.sleep(1000);
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

public class Run &#123;

    public static void main(String[] args) &#123;

        try &#123;
            Object lock = new Object();

            ThreadA a = new ThreadA(lock);
            a.start();

            Thread.sleep(50);

            ThreadB b = new ThreadB(lock);
            b.start();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;
线程A要等待某个条件满足时(list.size()==5)，才执行操作。线程B则向list中添加元素，改变list 的size。
A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？
这里用到了Object类的 wait() 和 notify() 方法。
当条件未满足时(list.size() !=5)，线程A调用wait() 放弃CPU，并进入阻塞状态。---不像②while轮询那样占用CPU
当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。
这种方式的一个好处就是CPU的利用率提高了。
但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。
 
④管道通信就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信
具体就不介绍了。分布式系统中说的两种通信机制：共享内存机制和消息通信机制。感觉前面的①中的synchronized关键字和②中的while轮询 “属于” 共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流。
而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。

线程池详解（ThreadPoolExecutor）
前言
在实现异步时，基本都是使用线程池来实现，线程池在工作应用的还是比较频繁的，本文将就线程池的使用、相关原理和主要方法源码进行深入讲解学习。
线程池的基本使用
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
public class ThreadPoolExecutorTest &#123;
/\*\*
\* 创建一个线程池(完整入参):
\* 核心线程数为5 (corePoolSize),
\* 最大线程数为10 (maximumPoolSize),
\* 存活时间为60分钟(keepAliveTime),
\* 工作队列为LinkedBlockingQueue (workQueue),
\* 线程工厂为默认的DefaultThreadFactory (threadFactory),
\* 饱和策略(拒绝策略)为AbortPolicy: 抛出异常(handler).
*/
private static ExecutorService THREAD\_POOL = new ThreadPoolExecutor(5, 10, 60, TimeUnit.MINUTES,
new LinkedBlockingQueue\&lt;Runnable&gt;(), Executors.defaultThreadFactory(),
new ThreadPoolExecutor.AbortPolicy());
/*\*
\* 只有一个线程的线程池 没有超时时间, 工作队列使用无界的LinkedBlockingQueue
*/
private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
// private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());
/*\*
\* 有固定线程的线程池(即corePoolSize = maximumPoolSize) 没有超时时间,
\* 工作队列使用无界的LinkedBlockingQueue
*/
private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
// private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5, Executors.defaultThreadFactory());
/*\*
\* 大小不限的线程池 核心线程数为0, 最大线程数为Integer.MAX\_VALUE, 存活时间为60秒 该线程池可以无限扩展,
\* 并且当需求降低时会自动收缩, 工作队列使用同步移交SynchronousQueue.
*/
private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
// private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool(Executors.defaultThreadFactory());
/*\*
\* 给定的延迟之后运行任务, 或者定期执行任务的线程池
\*/
private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
// private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5, Executors.defaultThreadFactory());

    public static void main(String args[]) throws Exception &#123;
       /**
         * 例子1: 没有返回结果的异步任务
         */
        THREAD_POOL.submit(new Runnable() &#123;
            @Override
            public void run() &#123;
                // do something
                System.out.println(&quot;没有返回结果的异步任务&quot;);
            &#125;
        &#125;);
         /**
         * 例子2: 有返回结果的异步任务
         */
        Future&lt;List&lt;String&gt;&gt; future = THREAD_POOL.submit(new Callable&lt;List&lt;String&gt;&gt;() &#123;
            @Override
            public List&lt;String&gt; call() &#123;
                List&lt;String&gt; result = new ArrayList&lt;&gt;();
                result.add(&quot;JoonWhee&quot;);
                return result;
            &#125;
        &#125;);
        List&lt;String&gt; result = future.get(); // 获取返回结果
        System.out.println(&quot;有返回结果的异步任务: &quot; + result);
         /**
         * 例子3: 
         * 有延迟的, 周期性执行异步任务
         * 本例子为: 延迟1秒, 每2秒执行1次
         */
        scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;this is &quot; + Thread.currentThread().getName());
            &#125;
         &#125;, 1, 2, TimeUnit.SECONDS);
        /**
         * 例子4: FutureTask的使用
         */
        Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;
            public String call() &#123;
                return &quot;JoonWhee&quot;;
            &#125;
        &#125;;      
        FutureTask&lt;String&gt; futureTo = new FutureTask&lt;String&gt;(task);
        THREAD_POOL.submit(futureTo);
        System.out.println(futureTo.get()); // 获取返回结果

//        System.out.println(futureTo.get(3, TimeUnit.SECONDS));  // 超时时间为3秒
&#125;
&#125;
线程池的定义和优点
线程池，从字面含义来看，是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
“在线程池中执行任务“”比“为每个线程分配一个任务”优势更多。通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。
线程池的工作流程
1.默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） 
2.当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  
3.当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  
4.当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。
5.当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 
6.如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。

工作队列
如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源。常见的工作队列有以下几种，前三种用的最多。
1.ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。
2.LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界/无界队列，先进先出。
3.SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue才有实际价值.
4.PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。

5.DelayedWorkQueue：延迟的工作队列，无界队列。

饱和策略（拒绝策略）
当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。（如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略）。饱和策略有以下四种，一般使用默认的AbortPolicy。
1.AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。

2.DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。

3.DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。

4.CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。

线程工厂
每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法。Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。
1.DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。
2.PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。
3.自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。

ThreadPoolExecutor源码解析
几个点
了解这几个点，有助于你阅读下面的源码解释。
1.下面的源码解读中提到的运行状态就是runState，有效的线程数就是workerCount，内容比较多，所以可能两种写法都用到。
2.运行状态的一些定义：RUNNING：接受新任务并处理排队任务； SHUTDOWN：不接受新任务，但处理排队任务； STOP：不接受新任务，不处理排队任务，并中断正在进行的任务；TIDYING：所有任务已经终止，workerCount为零，线程转换到状态TIDYING将运行terminate()钩子方法；TERMINATED：terminated()已经完成，该方法执行完毕代表线程池已经完全终止。
3.运行状态之间并不是随意转换的，大多数状态都只能由固定的状态转换而来，转换关系见第4点\~第8点。
4.RUNNING - &gt; SHUTDOWN：在调用shutdown()时，可能隐含在finalize()。
5.(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()。
6.SHUTDOWN - &gt; TIDYING：当队列和线程池都是空的时。

7.STOP - &gt; TIDYING：当线程池为空时。

8.TIDYING - &gt; TERMINATED：当terminate()方法完成时。

基础属性（很重要）
/\*\*

*   主池控制状态ctl是包含两个概念字段的原子整数: workerCount：指有效的线程数量；
*   runState：指运行状态，运行，关闭等。为了将workerCount和runState用1个int来表示，
*   我们限制workerCount范围为(2 ^ 29) - 1，即用int的低29位用来表示workerCount，
*   用int的高3位用来表示runState，这样workerCount和runState刚好用int可以完整表示。
    \*/
    // 初始化时有效的线程数为0, 此时ctl为: 1010 0000 0000 0000 0000 0000 0000 0000
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // 高3位用来表示运行状态，此值用于运行状态向左移动的位数，即29位
    private static final int COUNT\_BITS = Integer.SIZE - 3;\
    // 线程数容量，低29位表示有效的线程数, 0001 1111 1111 1111 1111 1111 1111 1111
    private static final int CAPACITY   = (1 &lt;&lt; COUNT\_BITS) - 1;

/\*\*

*   大小关系：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED，
*   源码中频繁使用大小关系来作为条件判断。
*   1010 0000 0000 0000 0000 0000 0000 0000 运行
*   0110 0000 0000 0000 0000 0000 0000 0000 关闭
*   0110 0000 0000 0000 0000 0000 0000 0000 停止
*   0110 0000 0000 0000 0000 0000 0000 0000 整理
*   0110 0000 0000 0000 0000 0000 0000 0000 终止
    \*/
    private static final int RUNNING    = -1 &lt;&lt; COUNT\_BITS; // 运行
    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT\_BITS; // 关闭
    private static final int STOP       =  1 &lt;&lt; COUNT\_BITS; // 停止
    private static final int TIDYING    =  2 &lt;&lt; COUNT\_BITS; // 整理
    private static final int TERMINATED =  3 &lt;&lt; COUNT\_BITS; // 终止

/\*\*

*   得到运行状态:入参c为ctl的值，\~CAPACITY高3位为1低29位全为0,
*   因此运算结果为ctl的高3位, 也就是运行状态
    */
    private static int runStateOf(int c)     &#123; return c &amp; \~CAPACITY; &#125;\
    /*\*
*   得到有效的线程数:入参c为ctl的值, CAPACITY高3为为0,
*   低29位全为1, 因此运算结果为ctl的低29位, 也就是有效的线程数
    */
    private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;\
    /*\*
*   得到ctl的值：高3位的运行状态和低29位的有效线程数进行或运算,
*   组合成一个完成的32位数
    \*/
    private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;

// 状态c是否小于s
private static boolean runStateLessThan(int c, int s) &#123;
return c &lt; s;
&#125;
// 状态c是否大于等于s
private static boolean runStateAtLeast(int c, int s) &#123;
return c &gt;= s;
&#125;
// 状态c是否为RUNNING（小于SHUTDOWN的状态只有RUNNING）
private static boolean isRunning(int c) &#123;
return c &lt; SHUTDOWN;
&#125;

// 使用CAS增加一个有效的线程
private boolean compareAndIncrementWorkerCount(int expect) &#123;\
return ctl.compareAndSet(expect, expect + 1);
&#125;

// 使用CAS减少一个有效的线程
private boolean compareAndDecrementWorkerCount(int expect) &#123;\
return ctl.compareAndSet(expect, expect - 1);
&#125;

// 减少一个有效的线程
private void decrementWorkerCount() &#123;
do &#123;&#125; while (! compareAndDecrementWorkerCount(ctl.get()));
&#125;

// 工作队列
private final BlockingQueue\&lt;Runnable&gt; workQueue;

// 锁
private final ReentrantLock mainLock = new ReentrantLock();

// 包含线程池中的所有工作线程,只有在mainLock的情况下才能访问,Worker集合
private final HashSet\&lt;Worker&gt; workers = new HashSet\&lt;Worker&gt;();

private final Condition termination = mainLock.newCondition();

// 跟踪线程池的最大到达大小，仅在mainLock下访问
private int largestPoolSize;

// 总的完成的任务数
private long completedTaskCount;

// 线程工厂，用于创建线程
private volatile ThreadFactory threadFactory;

// 拒绝策略
private volatile RejectedExecutionHandler handler;

/\*\*

*   线程超时时间，当线程数超过corePoolSize时生效,
*   如果有线程空闲时间超过keepAliveTime, 则会被终止
    \*/
    private volatile long keepAliveTime;

// 是否允许核心线程超时，默认false，false情况下核心线程会一直存活。
private volatile boolean allowCoreThreadTimeOut;

// 核心线程数
private volatile int corePoolSize;

// 最大线程数
private volatile int maximumPoolSize;

// 默认饱和策略（拒绝策略）, 抛异常
private static final RejectedExecutionHandler defaultHandler =
new AbortPolicy();

private static final RuntimePermission shutdownPerm =
new RuntimePermission(&quot;modifyThread&quot;);

/\*\*

*   Worker类，每个Worker包含一个线程、一个初始任务、一个任务计算器
    \*/
    private final class Worker\
    extends AbstractQueuedSynchronizer
    implements Runnable
    &#123;
    private static final long serialVersionUID = 6138294804551838833L;

    final Thread thread;    // Worker对应的线程
    Runnable firstTask; // 运行的初始任务。
    volatile long completedTasks;   // 每个线程的任务计数器

    Worker(Runnable firstTask) &#123;
    setState(-1); // 禁止中断，直到runWorker
    this.firstTask = firstTask; // 设置为初始任务
    // 使用当前线程池的线程工厂创建一个线程
    this.thread = getThreadFactory().newThread(this);\
    &#125;

    // 将主运行循环委托给外部runWorker
    public void run() &#123;
    runWorker(this);
    &#125;

    // Lock methods
    //
    // The value 0 represents the unlocked state.
    // The value 1 represents the locked state.
    /\*\*

    *   通过AQS的同步状态来实现锁机制。state为0时代表锁未被获取（解锁状态），
    *   state为1时代表锁已经被获取（加锁状态）。
        \*/
        protected boolean isHeldExclusively() &#123; //
        return getState() != 0;
        &#125;
        protected boolean tryAcquire(int unused) &#123;  // 尝试获取锁
        if (compareAndSetState(0, 1)) &#123; // 使用CAS尝试将state设置为1，即尝试获取锁
        // 成功将state设置为1，则当前线程拥有独占访问权
        setExclusiveOwnerThread(Thread.currentThread());\
        return true;
        &#125;
        return false;
        &#125;
        protected boolean tryRelease(int unused) &#123;  // 尝试释放锁
        setExclusiveOwnerThread(null);  // 释放独占访问权：即将独占访问线程设为null
        setState(0);    // 解锁：将state设置为0
        return true;
        &#125;
        public void lock()        &#123; acquire(1); &#125;   // 加锁
        public boolean tryLock()  &#123; return tryAcquire(1); &#125; // 尝试加锁
        public void unlock()      &#123; release(1); &#125;   // 解锁
        public boolean isLocked() &#123; return isHeldExclusively(); &#125;  // 是否为加锁状态
        void interruptIfStarted() &#123; // 如果线程启动了，则进行中断
        Thread t;
        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;
        try &#123;
        t.interrupt();
        &#125; catch (SecurityException ignore) &#123;
        &#125;
        &#125;
        &#125;
        &#125;
        1.execute方法
        使用线程池的submit方法提交任务时，会走到该方法，该方法也是线程池最重要的方法。
        public void execute(Runnable command) &#123;
        if (command == null)    // 为空校验
        throw new NullPointerException();

    int c = ctl.get();  // 拿到当前的ctl值
    if (workerCountOf(c) &lt; corePoolSize) &#123;  // 如果有效的线程数小于核心线程数
    if (addWorker(command, true))   // 则新建一个线程来处理任务（核心线程）
    return;
    c = ctl.get();  // 拿到当前的ctl值
    &#125;
    // 走到这里说明有效的线程数已经 &gt;= 核心线程数
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;// 如果当前状态是运行, 尝试将任务放入工作队列
    int recheck = ctl.get();    // 再次拿到当前的ctl值
    // 如果再次检查状态不是运行, 则将刚才添加到工作队列的任务移除
    if (! isRunning(recheck) &amp;&amp; remove(command))
    reject(command);    // 并调用拒绝策略
    else if (workerCountOf(recheck) == 0) // 如果再次检查时,有效的线程数为0,
    addWorker(null, false); // 则新建一个线程(非核心线程)
    &#125;
    // 走到这里说明工作队列已满
    else if (!addWorker(command, false))//尝试新建一个线程来处理任务(非核心)
    reject(command);    // 如果失败则调用拒绝策略
    &#125;

该方法就是对应上文的线程池的工作流程。主要调用到的方法为addWorker（见下文addWorker方法解读）。

addWorker方法
方法主要目的就是使用入参中的firstTask和当前线程添加一个Worker，前面的for循环主要是对当前线程池的运行状态和有效的线程数进行一些校验，校验逻辑比较绕，可以参考注释进行理解。该方法涉及到的其他方法有addWorkerFailed（见下文addWorkerFailed源码解读）；还有就是Worker的线程启动时，会调用Worker里的run方法，执行runWorker(this)方法（见下文runWorker源码解读）。

addWorkerFailed方法
/\*\*

*   Rolls back the worker thread creation.
*
    *   removes worker from workers, if present
*
    *   decrements worker count
*
    *   rechecks for termination, in case the existence of this
*   worker was holding up termination
    \*/
    private void addWorkerFailed(Worker w) &#123;    // 回滚Worker的添加，就是将Worker移除
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try &#123;
    if (w != null)
    workers.remove(w);  // 移除Worker
    decrementWorkerCount(); // 有效线程数-1
    tryTerminate(); // 有worker线程移除，可能是最后一个线程退出需要尝试终止线程池
    &#125; finally &#123;
    mainLock.unlock();
    &#125;
    &#125;
    该方法很简单，就是移除入参中的Worker并将workerCount-1，最后调用tryTerminate尝试终止线程池，tryTerminate见下文对应方法源码解读。

runWorker方法
上文addWork方法里说道，当Worker里的线程启动时，就会调用该方法。
/\*\*

*   Worker的线程开始执行任务
    \*/
    final void runWorker(Worker w) &#123;
    Thread wt = Thread.currentThread(); // 获取当前线程
    Runnable task = w\.firstTask;    // 拿到Worker的初始任务
    w\.firstTask = null;
    w\.unlock(); // allow interrupts
    boolean completedAbruptly = true;   // Worker是不是因异常而死亡
    try &#123;
    while (task != null || (task = getTask()) != null) &#123;// Worker取任务执行
    w\.lock();   // 加锁
    /\*\*如果线程池停止，确保线程中断; 如果不是，确保线程不被中断。
    \* 在第二种情况下进行重新检查，以便在清除中断的同时处理shutdownNow竞争
    \* 线程池停止指运行状态为STOP/TIDYING/TERMINATED中的一种
    \*/
    if ((runStateAtLeast(ctl.get(), STOP) ||    // 判断线程池运行状态
    (Thread.interrupted() &amp;&amp;   // 重新检查
    runStateAtLeast(ctl.get(), STOP))) &amp;&amp; // 再次判断线程池运行状态
    !wt.isInterrupted())// 走到这里代表线程池运行状态为停止,检查wt是否中断
    wt.interrupt(); // 线程池的状态为停止并且wt不为中断, 则将wt中断
    try &#123;
    beforeExecute(wt, task);// 执行beforeExecute（默认空，需要自己重写）
    Throwable thrown = null;
    try &#123;
    task.run(); // 执行任务
    &#125; catch (RuntimeException x) &#123;
    thrown = x; throw x; //如果抛异常,则completedAbruptly为true
    &#125; catch (Error x) &#123;
    thrown = x; throw x;
    &#125; catch (Throwable x) &#123;
    thrown = x; throw new Error(x);
    &#125; finally &#123;
    afterExecute(task, thrown);// 执行afterExecute（需要自己重写）
    &#125;
    &#125; finally &#123;
    task = null;    // 将执行完的任务清空
    w\.completedTasks++; // Worker完成任务数+1
    w\.unlock();
    &#125;
    &#125;
    completedAbruptly = false;  // 如果执行到这里，则worker是正常退出
    &#125; finally &#123;
    processWorkerExit(w, completedAbruptly);// 调用processWorkerExit方法
    &#125;
    &#125;
    该方法为Worker线程开始执行任务，首先执行当初创建Worker时的初始任务，接着从工作队列中获取任务执行。主要涉及两个方法：获取任务的方法getTask（见下文getTask源码解读）和执行Worker退出的方法processWorkerExit（见下文processWorkerExit源码解读）。注：processWorkerExit在处理正常Worker退出时，没有对workerCount-1，而是在getTask方法中进行workerCount-1。

getTask方法
private Runnable getTask() &#123;    // Worker从工作队列获取任务
boolean timedOut = false; // poll方法取任务是否超时

    for (;;) &#123;  // 无线循环
        int c = ctl.get();  // ctl
        int rs = runStateOf(c); // 当前运行状态

        // 如果线程池运行状态为停止，或者可以停止（状态为SHUTDOWN并且队列为空）
        // 则返回null，代表当前Worker需要移除
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;    
            decrementWorkerCount(); // 将workerCount - 1
            // 返回null前将workerCount - 1,
            // 因此processWorkerExit中completedAbruptly＝false时无需再减
            return null;
        &#125;

        int wc = workerCountOf(c);  // 当前的workerCount

        // 判断当前Worker是否可以被移除, 即当前Worker是否可以一直等待任务。
        // 如果allowCoreThreadTimeOut为true，或者workerCount大于核心线程数，
        // 则当前线程是有超时时间的（keepAliveTime），无法一直等待任务。
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;    

        // 如果wc超过最大线程数 或者 当前线程会超时并且已经超时，
        // 并且wc &gt; 1 或者 工作队列为空，则返回null，代表当前Worker需要移除
        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;   // 确保有Worker可以移除 
            if (compareAndDecrementWorkerCount(c))
                // 返回null前将workerCount - 1，
                // 因此processWorkerExit中completedAbruptly＝false时无需再减
                return null;    
            continue;
        &#125;

        try &#123;
            // 根据线程是否会超时调用相应的方法，poll为带超时的获取任务方法
            // take()为不带超时的获取任务方法，会一直阻塞直到获取到任务
            Runnable r = timed ? 
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;    // 走到这代表当前线程获取任务超时
        &#125; catch (InterruptedException retry) &#123;
            timedOut = false;   // 被中断
        &#125;
    &#125;

&#125;
Worker从工作队列获取任务，如果allowCoreThreadTimeOut为false并且  workerCount&lt;=corePoolSize，则这些核心线程永远存活，并且一直在尝试获取工作队列的任务；否则，线程会有超时时间（keepAliveTime），当在keepAliveTime时间内获取不到任务，该线程的Worker会被移除。 
Worker移除的过程：getTask方法返回null，导致runWorker方法中跳出while循环，调用processWorkerExit方法将Worker移除。注意：在返回null的之前，已经将workerCount-1，因此在processWorkerExit中，completedAbruptly=false的情况（即正常超时退出）不需要再将workerCount-1。

processWorkerExit方法
private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;   // Worker的退出
// 如果Worker是异常死亡（completedAbruptly=true），则workerCount-1；
// 如果completedAbruptly为false的时候（正常超时退出），则代表task=getTask()等于null，
// getTask()方法中返回null的地方，都已经将workerCount - 1，所以此处无需再-1
if (completedAbruptly)
decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();    // 加锁
    try &#123;
        completedTaskCount += w.completedTasks; // 该Worker完成的任务数加到总完成的任务数
        workers.remove(w);  // 移除该Worker
    &#125; finally &#123;
        mainLock.unlock();
    &#125;

    tryTerminate(); // 有Worker线程移除，可能是最后一个线程退出，需要尝试终止线程池

    int c = ctl.get();  // 获取当前的ctl
    if (runStateLessThan(c, STOP)) &#123;  // 如果线程池的运行状态还没停止（RUNNING或SHUTDOWN）
        if (!completedAbruptly) &#123;   // 如果Worker不是异常死亡
            // min为线程池的理论最小线程数:如果允许核心线程超时则min为0,否则min为核心线程数
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;    
            // 如果min为0,工作队列不为空,将min设置为1,确保至少有1个Worker来处理队列里的任务 
            if (min == 0 &amp;&amp; ! workQueue.isEmpty())
                min = 1;
            // 当前有效的线程数&gt;=min，直接返回;
            if (workerCountOf(c) &gt;= min)
                return; // replacement not needed 
            // 如果代码走到这边，代表workerCountOf(c) &lt; min，此时会走到下面的addWorker方法。
            // 通过getTask方法我们知道，当allowCoreThreadTimeOut为false
            // 并且workerCount&lt;=corePoolSize时，是不会走到processWorkerExit方法的。
            // 因此走到这边只可能是当前移除的Worker是最后一个Worker，但是此时工作
            // 队列还不为空，因此min被设置成了1，所以需要在添加一个Worker来处理工作队列。
        &#125;
        addWorker(null, false); // 添加一个Worker
    &#125;

&#125;
该方法就是执行Worker的退出：统计完成的任务数，将Worker移除，并尝试终止线程池，最后根据情况决定是否创建一个新的Worker。两种情况下会创建一个新的Worker：1）被移除的Worker是由于异常而死亡；2）被移除的Worker是最后一个Worker，但是工作队列还有任务。completedAbruptly=false时，没有将workerCount-1是因为已经在getTask方法中将workerCount-1。

tryTerminate方法
final void tryTerminate() &#123; // 尝试终止线程池
for (;;) &#123;
int c = ctl.get();
// 只有当前状态为STOP 或者 SHUTDOWN并且队列为空，才会尝试整理并终止
// 1: 当前状态为RUNNING，则不尝试终止，直接返回
// 2: 当前状态为TIDYING或TERMINATED，代表有其他线程正在执行终止，直接返回
// 3: 当前状态为SHUTDOWN 并且 workQueue不为空，则不尝试终止，直接返回
if (isRunning(c) || // 1
runStateAtLeast(c, TIDYING) ||  // 2
(runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))   // 3
return;
// 走到这代表线程池可以终止（通过上面的校验）
// 如果此时有效线程数不为0， 将中断一个空闲的Worker，以确保关闭信号传播
if (workerCountOf(c) != 0) &#123; // Eligible to terminate
interruptIdleWorkers(ONLY\_ONE);
return;
&#125;

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();    // 加锁，终止线程池
        try &#123;
            // 使用CAS将ctl的运行状态设置为TIDYING，有效线程数设置为0
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;  
                try &#123;
                    terminated();   // 供用户重写的terminated方法，默认为空
                &#125; finally &#123;
                    // 将ctl的运行状态设置为TERMINATED，有效线程数设置为0
                    ctl.set(ctlOf(TERMINATED, 0));  
                    termination.signalAll();
                &#125;
                return;
            &#125;
        &#125; finally &#123;
            mainLock.unlock();
        &#125;
        // else retry on failed CAS
    &#125;

&#125;
该方法用来尝试终止线程池，主要在移除Worker后会调用此方法。首先进行一些状态的校验，如果通过校验，则在加锁的条件下，使用CAS将运行状态设为TERMINATED，有效线程数设为0。

1\)现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？

这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。

2\)在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？

lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。

3\)在java中wait和sleep方法的不同？

通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。

4）用Java实现阻塞队列。

这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。

5）用Java写代码来解决生产者——消费者问题。

与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。

6）用Java编程一个会导致死锁的程序，你将怎么解决？

这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。

7\) 什么是原子操作，Java中的原子操作是什么？

非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。

8\) Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？

自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性。

9\) 什么是竞争条件？你怎样发现和解决竞争？

这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or anyother race condition。关于这方面最好的书是《Concurrency practices in Java》。

10\) 你将如何使用threaddump？你将如何分析Thread dump？

在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。

11\) 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。

12\) Java中你怎样唤醒一个阻塞的线程？

这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。

13\)在Java中CycliBarriar和CountdownLatch有什么区别？

这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。

14\) 什么是不可变对象，它对写并发应用有什么帮助？

另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。

15\) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？

多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。

笔记本： Java面试题
创建时间： 2018-10-30 11:14 更新时间： 2018-10-30 12:09
作者： 这个名字其实还是很长很长的
第八题 Java并发类库提供的线程池有哪几种？ 分别有什么特点？
Java并发类库提供的线程池有哪几种？ 分别有什么特点？
经典回答:
通常开发者都是利用Executors提供的通用线程池创建方法,去创建不同配置的线程池,主要
区别在于不同的ExecutorService类型或者不同的初识参数。
Executors目前提供了5种不同的线程池创建配置:
newCachedThreadPool(),它是一种用来处理大量短时间工作任务的线程池,具有几个鲜明特
点:它会试图缓存线程并重用,当无缓存线程可用时,就会创建新的工作线程;如果线程闲置
的时间超过60S,则被终止并移出缓存;长时间闲置时,这种线程池,不会消耗资源。
newFixedThreadPool(int nThreads),重用指定数目的线程,其背后使用的是无界的工作队
列,任何时候最多有nThreads个工作线程是活动的。这意味着,如果任务数量超过了活动队
列数目,将在工作队列中等待空闲线程出现;如果有工作线程退出,将会有新的工作线程被创
建,以补足指定的数目nThreads。
newSingleThreadExecutor(),它的特点在于工作线程数目被限制为1,操作一个无界的工作
队列,所以它保证了所有任务的都是被顺序执行,最多会有一个任务处于活动状态,并且不允
许使用者改造线程实例,因此可以避免其改变线程数目。
newSingleThreadScheduledExecutor()和newSecheduledThreadPool(int corePoolSize),
创建的是个ScheduledExecutorService,可以进行定时或周期性的工作调度,区别在于单一
工作线程还是多个工作线程。

笔记本： Java面试题
创建时间： 2018-10-29 11:12 更新时间： 2018-10-29 15:44
作者： 这个名字其实还是很长很长的
第六题 synchronized和ReentrantLock有什么区别
Synchronized和ReentrantLock有什么区别?
典型回答:
synchronized是Java内建的同步机制,所以也有人称其为Intrinsic Locking（固有
锁）,它提供了互斥的语义和可见性,当一个线程已经获取当前锁时,其他试图获取的线程
只能等待或者阻塞在那里。在Java 5以前,synchronized是仅有的同步手段,在代码
中,synchronized可以用来修饰方法,也可以使用在特定的代码块上,本质上
synchronized方法等同于把方法全部语句用synchronized块包起来。
ReentrantLock,通常翻译为再入锁,是Java 5提供的锁实现,它的语义和
synchronized基本相同。再入锁通过代码直接调用lock()方法获取,代码书写更加灵
活。与此同时,ReentrantLock提供了很多实用的方法,能够实现很多synchronized无法
做到的细节控制,但是在编码中也需要注意,必须要明确调用unlock()方法释放,不然就
会一直持有该锁。synchronzied和ReentrantLock的性能不能一概而论,早期版本
synchronized在很多场景下性能相差较大,在后续版本进行了较多改进,在低竞争场景中
表现可能优于ReentrantLock。
知识扩展:
什么是线程安全? 线程安全是一个多线程环境下正确性的概念,也就是保证多线程环
境下共享的可修改的状态的正确性,这里的状态反映在程序中其实可以看做是数据。
换个角度来看,如果状态不是共享的,或者不是可修改的,也就不存在线程安全问题,
进而可以推理出保证线程安全的两个办法:第一个是封装,我们可以将对象内部状态隐藏
保护起来。第二个是不可变。
线程安全需要保证几个基本特性:第一个是原子性,简单来说就是相关操作不会中途
被其他线程干扰,一般通过同步机制实现。第二是可见性,是一个线程修改了某个共享变
量,其状态能够立即被其他线程知晓,通常被解释为将线程本地状态反映到主内存
中,volatile关键字就是负责保证可见性的。第三个是有序性,是保证线程内串行语义,
避免指令重排等。
可能有点晦涩,那么我们看看下面的代码段,分析一下原子性需求体现在哪里。这个
例子通过取两个次数值然后进行对比,来模拟两次对共享状态的操作。你可以编译并执
行,可以看到,仅仅是两个线程的低度并发,就非常容易碰到former和latter不相等的情
况。这是因为,在两次取值的过程中,其他线程已经修改了sharedState的值。
下面是电脑上的运行结果:
因为线程安全的问题,导致以上的运行结果。我们可以将两次赋值过程用synchronized保护
起来,使用this作为互斥单元,就可以避免别的线程并发的去修改sharedState。
我们在来看看ReentrantLock。
你可能好奇什么是再入?它是表示当一个线程试图获取一个它已经获取的琐时,这个获
取动作就自动成功,这是对锁获取粒度的一个概念,也就是一个锁的持有是以线程为单位而
不是基于调用次数。
首先看下面的例子:
从上可以看出，使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对
逻辑控制的灵活性远远大于synchronized关键字。同时，需要注意，有加锁就必须有释放
锁，而且加锁与释放锁的份数要相同，这里就引出了“重”字的概念，如上边代码演示，
放开①、②处的注释，与原来效果一致。
ReentrantLock实现中断操作,先了解几个方法的作用
lockInterruptibly():当两个线程同时通过lock.lockInterruptibly()想获取某个锁
时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用
threadB.interrupt()方法能够中断线程B的等待过程。
isHeldByCurrentThread():查询当前线程是否保持锁。
t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了
死锁。但是，在③处给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中
断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，
正常执行完成。t2也会退出，但只是释放了资源并没有完成工作。
ReentrantLock实现锁申请等待限时
可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁
等待。前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线
程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。后者带有
参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返
回false。
公平锁
所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产
生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非
公平锁）创建公平锁：

ReentrantLock与Condition一起使用
配合关键字synchronized使用的方法如：await()、notify()、notifyAll()，同样配合
ReentrantLock 使用的Conditon提供了以下方法：
ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建
Condition对象

11
1.多线程有什么用？
1）发挥多核CPU 的优势
随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的
，4 核、8 核甚至 16 核的也都不少见，如果是单线程的程序，那么在双核 CPU 上
就浪费了 50%， 在 4 核 CPU 上就浪费了 75%。单核 CPU 上所谓的&quot;多线程&quot;那是
假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，
看着像多个线程&quot;同时&quot;运行罢了。多核 CPU 上的多线程才是真正的多线程，它能
让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU 的优势来，达到充
分利用CPU 的目的。
2）防止阻塞
从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因
为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但
是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使
用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返
回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多
线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻
塞，也不会影响其它任务的执行。
3）便于建模
这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么
就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成
几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运
行这几个任务，那就简单很多了。
2.线程和进程的区别是什么？
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地
址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一
个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的
地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程
序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进
行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
3.Java 实现线程有哪几种方式？
1）继承 Thread 类实现多线程
2）实现 Runnable 接口方式实现多线程
3）使用 ExecutorService、Callable、Future 实现有返回结果的多线程
4.启动线程方法 start()和 run()有什么区别？
只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代
码交替执行。如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个
线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run()
方法里面的代码。
5.怎么终止一个线程？如何优雅地终止线程？
stop 终止，不推荐。
6.一个线程的生命周期有哪几种状态？它们之间如何流转的？
NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。
RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中
状态。
BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock 等关键字等
12
占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。
WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如
通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方
法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线
程就进入了 RUNNABLE 状态继续运行。
TIMED\_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒
后线程重新进行 RUNNABLE 状态继续运行。
TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程
通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到
RUNNABLE 状态
7.线程中的 wait()和 sleep()方法有什么区别？
这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在
于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait
方法会放弃这个对象的监视器
8.多线程同步有哪几种方法？
Synchronized 关键字，Lock 锁实现，分布式锁等。
9.什么是死锁？如何避免死锁？
死锁就是两个线程相互等待对方释放对象锁。
10.多线程之间如何进行通信？
wait/notify
11、线程怎样拿到返回结果？
实现Callable 接口。
12、violatile 关键字的作用？
一个非常重要的问题，是每个学习、应用多线程的 Java 程序员都必须掌握的。理
解 volatile关键字的作用的前提是要理解 Java 内存模型，这里就不讲 Java 内存模型
了，可以参见第31 点，volatile 关键字的作用主要有两个：
1）多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变
量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的
数据
2）代码底层执行不像我们看到的高级语言----Java 程序这么简单，它的执行是 Java
代码--&gt;字节码--&gt;根据字节码执行对应的 C/C++代码--&gt;C/C++代码被编译成汇编语
言--&gt;和硬件电路交互，现实中，为了获取更好的性能 JVM 可能会对指令进行重排
序，多线程下可能会出现一些意想不到的问题。使用 volatile 则会对禁止语义重排
序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重
要 作 用 就 是 和 CAS 结 合 ， 保 证 了 原 子 性 ， 详 细 的 可 以 参 见
java.util.concurrent.atomic 包下的类，比如 AtomicInteger。
13、新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？
用 join 方法。
14、怎么控制同一时间只有 3 个线程运行？
用 Semaphore。
15、为什么要使用线程池？
我们知道不用线程池的话，每个线程都要通过 new Thread(xxRunnable).start()的方
式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个
13
线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和
内存资源，也会造成 GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消
耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，
线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也
会自动销毁，而不会长驻内存。
16、常用的几种线程池并讲讲其中的工作原理。
什么是线程池？
很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线
程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的
复用。
线程池的好处
我们知道不用线程池的话，每个线程都要通过 new Thread(xxRunnable).start()的方
式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个
线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和
内存资源，也会造成 GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消
耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，
线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也
会自动销毁，而不会长驻内存。
线程池核心类
在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是
我们线程池核心类，首先看看线程池类的主要参数有哪些。
如何提交线程
如 可 以 先 随 便 定 义 一 个 固 定 大 小 的 线 程 池 ExecutorService es = Executors.newFixedThreadPool(3);提交一个线程es.submit(xxRunnble);
es.execute(xxRunnble);
submit 和 execute 分别有什么区别呢？
execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很
多。
submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能
在主线程中通过 Future 的 get 方法捕获线程中的异常。
如何关闭线程池es.shutdown();
不再接受新的任务，之前提交的任务等执行结束再关闭线程池。
es.shutdownNow();
不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程
list 列表。
17、线程池启动线程 submit()和 execute()方法有什么不同？
execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很
多。
submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能
在主线程中通过 Future 的 get 方法捕获线程中的异常。
18、CyclicBarrier 和 CountDownLatch 的区别？
两个看上去有点像的类，都在 java.util.concurrent 下，都可以用来表示代码运行到
某个点上，二者的区别在于：
1.CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的
线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运
行到某个点上之后，只是给某个数值-1 而已，该线程继续运行
14
2.CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务
3.CyclicBarrier 可 重 用 ， CountDownLatch 不 可 重 用 ， 计 数 值 为 0 该
CountDownLatch就不可再用了
19、什么是活锁、饥饿、无锁、死锁？
死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现
了这三种情况，即线程不再活跃，不能再正常地执行下去了。
死锁
死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等
对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。
举个例子，A 同学抢了 B 同学的钢笔，B 同学抢了 A 同学的书，两个人都相互占
用对方的东西，都在让对方先还给自己自己再还，这样一直争执下去等待对方还而
又得不到解决，老师知道此事后就让他们相互还给对方，这样在外力的干预下他们
才解决，当然这只是个例子没有老师他们也能很好解决，计算机不像人如果发现这
种情况没有外力干预还是会一直阻塞下去的。
活锁
活锁这个概念大家应该很少有人听说或理解它的概念，而在多线程中这确实存在。
活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿
到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别
的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。
饥饿
我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执
行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无
法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源
不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够
得到执行的，如那个占用资源的线程结束了并释放了资源。
无锁
无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时
只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，
线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下
一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，
而其他修改失败的线程会不断重试直到修改成功。之前的文章我介绍过 JDK 的
CAS 原理及应用即是无锁的实现。
可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使
用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合
下是非常高效的。
20、什么是原子性、可见性、有序性？
原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复
杂，如何让每个线程能看到正确的结果，这是非常重要的。
原子性
原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个
变量进行操作。在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如
说多个线程同时对同一个共享成员变量 n++100 次，如果 n 初始值为 0，n 最后的
值应该是 100，所以说它们是互不干扰的，这就是传说的中的原子性。但 n++并不
是原子性的操作，要使用 AtomicInteger 保证原子性。
可见性
可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享
变量修改后的值。在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的
15
值，而在多线程编程中就不一定了。每个线程都有自己的工作内存，线程先把共享
变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主
内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对
其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值。像
CPU 的缓存优化、硬件优化、指令重排及对 JVM 编译器的优化，都会出现可见性
的问题。
有序性
我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情
况下就不是如此了。为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统
都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即
后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所
以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的
执行结果。虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，
只是重排序会影响多线程执行的结果。
21、什么是守护线程？有什么用？
什么是守护线程？与守护线程相对应的就是用户线程，守护线程就是守护用户线
程，当用户线程全部执行完结束之后，守护线程才会跟着结束。也就是守护线程必
须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线
程自然会退出。
22、一个线程运行时发生异常会怎样？
如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用
于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造
成线程中断的时 候 JVM 会 使 用 Thread.getUncaughtExceptionHandler() 来 查 询 线
程 的UncaughtExceptionHandler 并 将 线 程 和 异 常 作 为 参 数 传 递 给 handler 的
uncaughtException()方法进行处理。
23、线程 yield()方法有什么用？
Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。
它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定
能占用 CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。
24、什么是重入锁？
所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再
次获取本对象上的锁，而其他的线程是不可以的。
25、Synchronized 有哪几种用法？
锁类、锁方法、锁代码块。
26、Fork/Join 框架是干什么的？
大任务自动分散小任务，并发执行，合并小任务结果。
27、线程数过多会造成什么异常？
线程过多会造成栈溢出，也有可能会造成堆异常。
28、说说线程安全的和不安全的集合。
Java 中平时用的最多的 Map 集合就是 HashMap 了，它是线程不安全的。
看下面两个场景：
1、当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访
问不了，所以这时也不存在线程安全不安全的问题了。
16
2、当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个
HashMap 了，对同个 HashMap 操作这时候就存在线程安全的问题了。
29、什么是 CAS 算法？在多线程中有哪些应用。
CAS，全称为 Compare and Swap，即比较-替换。假设有三个操作数：内存值 V、
旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内
存值修改为 B 并返回 true，否则什么都不做并返回 false。当然 CAS 一定要 volatile
变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期
值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远
都不可能成功。
java.util.concurrent.atomic 包下面的 Atom\*\*\*\*类都有 CAS 算法的应用。
30、怎么检测一个线程是否拥有锁？
java.lang.Thread#holdsLock 方法
31、Jdk 中排查多线程问题用什么命令？
jstack
32、线程同步需要注意什么？
1、尽量缩小同步的范围，增加系统吞吐量。
2、分布式同步锁无意义，要使用分布式锁。
3、防止死锁，注意加锁顺序。
33、线程 wait()方法使用有什么前提？
要在同步块中使用。
34、Fork/Join 框架使用有哪些要注意的地方？
如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；
如果函数的调用栈很深，会导致栈内存溢出；
35、线程之间如何传递数据？
通 过 在 线 程 之 间 共 享 对 象 就 可 以 了 ， 然 后 通 过 wait/notify/notifyAll 、
await/signal/signalAll 进行唤起和等待，比方说阻塞队列 BlockingQueue 就是为线程
之间共享数据而设计的
36、保证&quot;可见性&quot;有哪几种方式？
synchronized 和 viotatile
37、说几个常用的 Lock 接口实现锁。
ReentrantLock、ReadWriteLock
38、ThreadLocal 是什么？有什么应用场景？
ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作
用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。用来
解决数据库连接、Session 管理等。
39、ReadWriteLock 有什么用？
ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接
口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之
间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。
40、FutureTask 是什么？
FutureTask 表示一个异步运算的任务，FutureTask 里面可以传入一个 Callable 的具
17
体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、
取消任务等操作。
41、怎么唤醒一个阻塞的线程？
如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，
并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，
因为 IO是操作系统实现的，Java 代码并没有办法直接接触到操作系统。
42、不可变对象对多线程有什么帮助？
不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步
手段，提升了代码执行效率。
43、多线程上下文切换是什么意思？
多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个
就绪并等待获取 CPU 执行权的线程的过程。
44、Java 中用到了什么线程调度算法？
抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等
数据算出一个总的优先级并分配下一个时间片给某个线程执行。
45、Thread.sleep(0)的作用是什么？
由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU
控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使
用 Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制
权的一种操作。
46、Java 内存模型是什么，哪些区域是线程共享的，哪些是不共享
的？
我们知道的 JVM 内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的
一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。
线程不共享区域每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它
们都是在新线程创建时才创建的。
程序计数器（Program Counter Rerister）
程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程
都有自己的程序计数器，此区域不会有内存溢出的情况。
虚拟机栈（VM Stack）
虚拟机栈描述的是 Java 方法执行的内存模型，每个方法被执行的时候都会同时创
建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口
等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从
入栈到出栈的过程。
本地方法栈（Native Method Stack）
本地方法栈用于支持本地方法（native 标识的方法，即非 Java 语言实现的方法）。
虚拟机栈和本地方法栈，当线程请求分配的栈容量超过 JVM 允许的最大容量时抛
出StackOverflowError 异常。
线程共享区域
线程共享区域包含：堆和方法区。
堆（Heap）
堆是最常处理的区域，它存储在 JVM 启动时创建的数组和对象，JVM 垃圾收集也
主要是在堆上面工作。
如 果 实 际 所 需 的 堆 超 过 了 自 动 内 存 管 理 系 统 能 提 供 的 最 大 容 量 时 抛 出
18
OutOfMemoryError 异常。
方法区（Method Area）
方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如
运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法
的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。当创建类
和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内
存空间后就会抛出 OutOfMemoryError
运行时常量池（Runtime Constant Pool）
运行时常量池是方法区的一部分，每一个运行时常量池都分配在 JVM 的方法区中，
在类和接口被加载到 JVM 后，对应的运行时常量池就被创建。运行时常量池是每
一个类或接口的常量池（Constant\_Pool）的运行时表现形式，它包括了若干种常量：
编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。如果
方法区的内存空间不能满足内存分配请求，那 Java 虚 拟 机 将 抛 出 一 个
OutOfMemoryError 异常。栈包含 Frames，当调用方法时，Frame 被推送到堆栈。
一个 Frame 包含局部变量数组、操作数栈、常量池引用。
47、什么是乐观锁和悲观锁？
乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐
观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为
一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有
相应的重试逻辑。
悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，
悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的
锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。
48、Hashtable 的 size()方法为什么要做同步？
同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以
多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put
方法添加数据，线程 B 则可以正常调用 size()方法读取 Hashtable 中当前元素的个
数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对
size++，线程 B 就已经读取 size了，那么对于线程 B 来说读取到的 size 一定是不准
确的。而给 size()方法加了同步之后，意味着线程 B 调用 size()方法只有在线程 A
调用 put 方法完毕之后才可以调用，这样就保证了线程安全性CPU 执行代码，执行
的不是 Java 代码，这点很关键，一定得记住。Java 代码最终是被翻译成机器码执
行的，机器码才是真正可以和硬件电路交互的代码。即使你看到 Java 代码只有一
行，甚至你看到 Java 代码编译之后生成的字节码也只有一行，也不意味着对于底
层来说这句语句的操作只有一个。一句&quot;return count&quot;假设被翻译成了三句汇编语句
执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。
49、同步方法和同步块，哪种更好？
同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码
的效率。
请知道一条原则：同步的范围越小越好。
50、什么是自旋锁？
自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线
程改变时才能进入临界区。
51、Runnable 和 Thread 用哪个好？
Java 不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也
19
为了减少类之间的耦合性，Runnable 会更好。
52、Java 中 notify 和 notifyAll 有什么区别？
notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用
武之地。
而 notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。
53、为什么 wait/notify/notifyAll 这些方法不在 thread 类里面？
这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不
合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object
类里是有意义的，还有不把它放在 Thread 类里的原因。一个很明显的原因是
JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如
果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果 wait()方法定
义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，
notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对
象。
54、为什么 wait 和 notify 方法要在同步块中调用？
主 要 是 因 为 Java API 强 制 要 求 这 样 做 ， 如 果 你 不 这 么 做 ， 你 的 代 码
会 抛 出IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify
之间产生竞态条件。
55、为什么你应该在循环中检查等待条件？
处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，
程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能
认为它原来的等待状态仍然是有效的，在 notify()方法调用之后和等待线程醒来之
前这段时间它可能会改变。这就是在循环中使用 wait()方法效果更好的原因，你可
以在 Eclipse 中创建模板调用 wait和 notify 试一试。
56、Java 中堆和栈有什么不同？
每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中
存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对
象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线
程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程
从主存中读取变量的值。
57、你如何在 Java 中获取线程堆栈？
对于不同的操作系统，有多种方法来获得 Java 进程的线程堆栈。当你获取线程堆
栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在 Windows 你
可以使用 Ctrl + Break 组合键来获取线程堆栈，Linux 下用 kill -3 命令。你也可以
用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。
58、如何创建线程安全的单例模式？
单例模式即一个 JVM 内存中只存在一个类的对象实例分类
1、懒汉式
类加载的时候就创建实例
2、饿汉式
使用的时候才创建实例
59、什么是阻塞式方法？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的
110
accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前
线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任
务完成前就返回。
60、提交任务时线程池队列已满会时发会生什么？
当线程数小于最大线程池数 maximumPoolSize 时就会创建新线程来处理，而线程
数大于等于最大线程池数 maximumPoolSize 时就会执行拒绝策略。

关于线程和线程池的学习，我们可以从以下几个方面入手：
第一，什么是线程，线程和进程的区别是什么
第二，线程中的基本概念，线程的生命周期
第三，单线程和多线程
第四，线程池的原理解析
第五，常见的几种线程池的特点以及各自的应用场景
一、
线程，程序执行流的最小执行单位，是行程中的实际运作单位，经常容易和进程这个概念混淆。那么，线程和进程究竟有什么区别呢？首先，进程是一个动态的过程，是一个活动的实体。简单来说，一个应用程序的运行就可以被看做是一个进程，而线程，是运行中的实际的任务执行者。可以说，进程中包含了多个可以同时运行的线程。
二、
线程的生命周期，线程的生命周期可以利用以下的图解来更好的理解：
第一步，是用new Thread()的方法新建一个线程，在线程创建完成之后，线程就进入了就绪（Runnable）状态，此时创建出来的线程进入抢占CPU资源的状态，当线程抢到了CPU的执行权之后，线程就进入了运行状态（Running），当该线程的任务执行完成之后或者是非常态的调用的stop（）方法之后，线程就进入了死亡状态。而我们在图解中可以看出，线程还具有一个则色的过程，这是怎么回事呢？当面对以下几种情况的时候，容易造成线程阻塞，第一种，当线程主动调用了sleep（）方法时，线程会进入则阻塞状态，除此之外，当线程中主动调用了阻塞时的IO方法时，这个方法有一个返回参数，当参数返回之前，线程也会进入阻塞状态，还有一种情况，当线程进入正在等待某个通知时，会进入阻塞状态。那么，为什么会有阻塞状态出现呢？我们都知道,CPU的资源是十分宝贵的，所以，当线程正在进行某种不确定时长的任务时，Java就会收回CPU的执行权，从而合理应用CPU的资源。我们根据图可以看出，线程在阻塞过程结束之后，会重新进入就绪状态，重新抢夺CPU资源。这时候，我们可能会产生一个疑问，如何跳出阻塞过程呢?又以上几种可能造成线程阻塞的情况来看，都是存在一个时间限制的，当sleep()方法的睡眠时长过去后，线程就自动跳出了阻塞状态，第二种则是在返回了一个参数之后，在获取到了等待的通知时，就自动跳出了线程的阻塞过程
三、
什么是单线程和多线程？
单线程，顾名思义即是只有一条线程在执行任务，这种情况在我们日常的工作学习中很少遇到，所以我们只是简单做一下了解
多线程，创建多条线程同时执行任务，这种方式在我们的日常生活中比较常见。但是，在多线程的使用过程中，还有许多需要我们了解的概念。比如，在理解上并行和并发的区别，以及在实际应用的过程中多线程的安全问题，对此，我们需要进行详细的了解。
并行和并发：在我们看来，都是可以同时执行多种任务，那么，到底他们二者有什么区别呢？
并发，从宏观方面来说，并发就是同时进行多种时间，实际上，这几种时间，并不是同时进行的，而是交替进行的，而由于CPU的运算速度非常的快，会造成我们的一种错觉，就是在同一时间内进行了多种事情
而并发，则是真正意义上的同时进行多种事情。这种只可以在多核CPU的基础下完成。
还有就是多线程的安全问题？为什么会造成多线程的安全问题呢？我们可以想象一下，如果多个线程同时执行一个任务，name意味着他们共享同一种资源，由于线程CPU的资源不一定可以被谁抢占到，这是，第一条线程先抢占到CPU资源，他刚刚进行了第一次操作，而此时第二条线程抢占到了CPU的资源，name，共享资源还来不及发生变化，就同时有两条数据使用了同一条资源，具体请参考多线程买票问题。这个问题我们应该如何解决那？
有造成问题的原因我们可以看出，这个问题主要的矛盾在于，CPU的使用权抢占和资源的共享发生了冲突，解决时，我们只需要让一条线程战歌了CPU的资源时，阻止第二条线程同时抢占CPU的执行权，在代码中，我们只需要在方法中使用同步代码块即可。在这里，同步代码块不多进行赘述，可以自行了解。
四，线程池
又以上介绍我们可以看出，在一个应用程序中，我们需要多次使用线程，也就意味着，我们需要多次创建并销毁线程。而创建并销毁线程的过程势必会消耗内存。而在Java中，内存资源是及其宝贵的，所以，我们就提出了线程池的概念。
线程池：Java中开辟出了一种管理线程的概念，这个概念叫做线程池，从概念以及应用场景中，我们可以看出，线程池的好处，就是可以方便的管理线程，也可以减少内存的消耗。
那么，我们应该如何创建一个线程池那?Java中已经提供了创建线程池的一个类：Executor
而我们创建时，一般使用它的子类：ThreadPoolExecutor.
public ThreadPoolExecutor(
int corePoolSize,//核心线程数（线程池中线程的数量）
int maximumPoolSize,（最大线程数，包括核心线程数，剩下的任务放在放在阻塞队列中）
long keepAliveTime,//非核心线程空闲存活时间
TimeUnit unit,// 空闲线程存活时间的单位
BlockingQueue workQueue, //阻塞队列，存放最大线程数-核心线程数的剩余任务数
ThreadFactory threadFactory,//线程生产工厂类对象
RejectedExecutionHandler handler//任务数异常时解决方案
)
这是其中最重要的一个构造方法，这个方法决定了创建出来的线程池的各种属性，下面依靠一张图来更好的理解线程池和这几个参数：

又图中，我们可以看出，线程池中的corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收，maximumPoolSize就是线程池中可以容纳的最大线程的数量，而keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，而util，就是计算这个时间的一个单位，workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。threadFactory，就是创建线程的线程工厂，最后一个handler,是一种拒绝策略，我们可以在任务满了知乎，拒绝执行某些任务。
线程池的执行流程又是怎样的呢？

有图我们可以看出，任务进来时，首先执行判断，判断核心线程是否处于空闲状态，如果不是，核心线程就先就执行任务，如果核心线程已满，则判断任务队列是否有地方存放该任务，若果有，就将任务保存在任务队列中，等待执行，如果满了，在判断最大可容纳的线程数，如果没有超出这个数量，就开创非核心线程执行任务，如果超出了，就调用handler实现拒绝策略。
handler的拒绝策略：
有四种：第一种AbortPolicy:不执行新任务，直接抛出异常，提示线程池已满
第二种DisCardPolicy:不执行新任务，也不抛出异常
第三种DisCardOldSetPolicy:将消息队列中的第一个任务替换为当前新进来的任务执行
第四种CallerRunsPolicy:直接调用execute来执行当前任务
五，四种常见的线程池：
CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max\_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。
SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。
SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。
FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程

线程池能有效的处理多个线程的并发问题，避免大量的线程因为互相强占系统资源导致阻塞现象，能够有效的降低频繁创建和销毁线程对性能所带来的开销。真正线程池的实现是通过ThreadPoolExecutor，ThreadPoolExecutor通过配置不同的参数配置来创建线程池。下面简单的介绍一下各个线程池的区别和用处。
（1）fixThreadPool  正规线程
          我的理解这是一个有指定的线程数的线程池，有核心的线程，里面有固定的线程数量，响应的速度快。正规的并发线程，多用于服务器。固定的线程数由系统资源设置。
public static ExecutorService newFixedThreadPool(int threads)
&#123;
return newFixedThreadPool(threads,threads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue\&lt;Runnable&gt;());
&#125;
核心线程是没有超时机制的，队列大小没有限制，除非线程池关闭了核心线程才会被回收。
（2）caCheThreadPool  缓存线程池

         只有非核心线程，最大线程数很大（Int.Max(values)），它会为每一个任务添加一个新的线程，这边有一个超时机制，当空闲的线程超过60s内没有用到的话，就会被回收。缺点就是没有考虑到系统的实际内存大小。
public static ExecutorService newCachedThreadPool(int threads)
&#123;
return newFixedThreadPool(threads,Integer.MAX\_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue\&lt;Runnable&gt;());
&#125;
（3）singleThreadPoll   单线程线程池
  看这个名字就知道这个家伙是只有一个核心线程，就是一个孤家寡人，通过指定的顺序将任务一个个丢到线程，都乖乖的排队等待执行，不处理并发的操作，不会被回收。确定就是一个人干活效率慢。
（4）ScheduledThreadPoll   

         这个线程池就厉害了，是唯一一个有延迟执行和周期重复执行的线程池。它的核心线程池固定，非核心线程的数量没有限制，但是闲置时会立即会被回收。
线程池的基本使用
1.package com.joonwhee.concurrent;

1.

3.import java.util.ArrayList;
4.import java.util.List;
5.import java.util.concurrent.Callable;
6.import java.util.concurrent.ExecutorService;
7.import java.util.concurrent.Executors;
8.import java.util.concurrent.Future;
9.import java.util.concurrent.FutureTask;
10.import java.util.concurrent.LinkedBlockingQueue;
11.import java.util.concurrent.ScheduledExecutorService;
12.import java.util.concurrent.ThreadPoolExecutor;
13.import java.util.concurrent.TimeUnit;

1.

15./\*\*
16\. \* 线程池的基本使用

1.
    *   @author JoonWhee
2.
    *   @Date 2018年1月21日
3.  \*/
    20.public class ThreadPoolExecutorTest &#123;
4.
5.  /\*\*
6.
         * 创建一个线程池(完整入参): 
7.
         * 核心线程数为5 (corePoolSize), 
8.
         * 最大线程数为10 (maximumPoolSize), 
9.
         * 存活时间为60分钟(keepAliveTime), 
10.
        * 工作队列为LinkedBlockingQueue (workQueue),
11.
        * 线程工厂为默认的DefaultThreadFactory (threadFactory), 
12.
        * 饱和策略(拒绝策略)为AbortPolicy: 抛出异常(handler).
13.
        */
14. private static ExecutorService THREAD\_POOL = new ThreadPoolExecutor(5, 10, 60, TimeUnit.MINUTES,
15.
               new LinkedBlockingQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(),
16.
               new ThreadPoolExecutor.AbortPolicy());
17.
18. /\*\*
19.
        * 只有一个线程的线程池 没有超时时间, 工作队列使用无界的LinkedBlockingQueue
20.
        */
21. private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
22. // private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());
23.
24. /\*\*
25.
        * 有固定线程的线程池(即corePoolSize = maximumPoolSize) 没有超时时间,
26.
        * 工作队列使用无界的LinkedBlockingQueue
27.
        */
28. private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
29. // private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5, Executors.defaultThreadFactory());
30.
31. /\*\*
32.
        * 大小不限的线程池 核心线程数为0, 最大线程数为Integer.MAX_VALUE, 存活时间为60秒 该线程池可以无限扩展,
33.
        * 并且当需求降低时会自动收缩, 工作队列使用同步移交SynchronousQueue.
34.
        */
35. private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
36. // private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool(Executors.defaultThreadFactory());
37.
38. /\*\*
39.
        * 给定的延迟之后运行任务, 或者定期执行任务的线程池
40.
        */
41. private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
42. // private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5, Executors.defaultThreadFactory());
43.
44. public static void main(String args\[]) throws Exception &#123;
45.
46.
           /**
47.
            * 例子1: 没有返回结果的异步任务
48.
            */
49.
           THREAD_POOL.submit(new Runnable() &#123;
50.
               @Override
51.
               public void run() &#123;
52.
                   // do something
53.
                   System.out.println(&quot;没有返回结果的异步任务&quot;);
54.
               &#125;
55.
           &#125;);
56.
57.
           /**
58.
            * 例子2: 有返回结果的异步任务
59.
            */
60.
           Future&lt;List&lt;String&gt;&gt; future = THREAD_POOL.submit(new Callable&lt;List&lt;String&gt;&gt;() &#123;
61.
               @Override
62.
               public List&lt;String&gt; call() &#123;
63.
                   List&lt;String&gt; result = new ArrayList&lt;&gt;();
64.
                   result.add(&quot;JoonWhee&quot;);
65.
                   return result;
66.
               &#125;
67.
           &#125;);
68.
           List&lt;String&gt; result = future.get(); // 获取返回结果
69.
           System.out.println(&quot;有返回结果的异步任务: &quot; + result);
70.
71.
           /**
72.
            * 例子3: 
73.
            * 有延迟的, 周期性执行异步任务
74.
            * 本例子为: 延迟1秒, 每2秒执行1次
75.
            */
76.
           scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123;
77.
               @Override
78.
               public void run() &#123;
79.
                   System.out.println(&quot;this is &quot; + Thread.currentThread().getName());
80.
               &#125;
81.
82.
           &#125;, 1, 2, TimeUnit.SECONDS);
83.
84.
           /**
85.
            * 例子4: FutureTask的使用
86.
            */
87.
           Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;
88.
               public String call() &#123;
89.
                   return &quot;JoonWhee&quot;;
90.
               &#125;
91.
           &#125;;      
92.
           FutureTask&lt;String&gt; futureTo = new FutureTask&lt;String&gt;(task);
93.
           THREAD_POOL.submit(futureTo);
94.
           System.out.println(futureTo.get()); // 获取返回结果

112.//        System.out.println(futureTo.get(3, TimeUnit.SECONDS));  // 超时时间为3秒
113\.    &#125;
114.&#125;

线程池的定义和优点
线程池，从字面含义来看，是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
“在线程池中执行任务“”比“为每个线程分配一个任务”优势更多。通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。

线程池的工作流程
1.默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） 
2.当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  
3.当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  
4.当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。
5.当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 
6.如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。

工作队列
如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源。常见的工作队列有以下几种，前三种用的最多。
1.ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。
2.LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界/无界队列，先进先出。
3.SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue才有实际价值.
4.PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。

5.DelayedWorkQueue：延迟的工作队列，无界队列。

饱和策略（拒绝策略）
当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。（如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略）。饱和策略有以下四种，一般使用默认的AbortPolicy。
1.AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。

2.DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。

3.DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。

4.CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。

线程工厂
每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法。Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。
1.DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。
2.PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。
3.自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。

ThreadPoolExecutor源码解析
几个点
了解这几个点，有助于你阅读下面的源码解释。
1.下面的源码解读中提到的运行状态就是runState，有效的线程数就是workerCount，内容比较多，所以可能两种写法都用到。
2.运行状态的一些定义：RUNNING：接受新任务并处理排队任务； SHUTDOWN：不接受新任务，但处理排队任务； STOP：不接受新任务，不处理排队任务，并中断正在进行的任务；TIDYING：所有任务已经终止，workerCount为零，线程转换到状态TIDYING将运行terminate()钩子方法；TERMINATED：terminated()已经完成，该方法执行完毕代表线程池已经完全终止。
3.运行状态之间并不是随意转换的，大多数状态都只能由固定的状态转换而来，转换关系见第4点\~第8点。
4.RUNNING - &gt; SHUTDOWN：在调用shutdown()时，可能隐含在finalize()。
5.(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()。
6.SHUTDOWN - &gt; TIDYING：当队列和线程池都是空的时。

7.STOP - &gt; TIDYING：当线程池为空时。

8.TIDYING - &gt; TERMINATED：当terminate()方法完成时。

基础属性（很重要）
1./\*\*

1.
    *   主池控制状态ctl是包含两个概念字段的原子整数: workerCount：指有效的线程数量；
2.
    *   runState：指运行状态，运行，关闭等。为了将workerCount和runState用1个int来表示，
3.
    *   我们限制workerCount范围为(2 ^ 29) - 1，即用int的低29位用来表示workerCount，
4.
    *   用int的高3位用来表示runState，这样workerCount和runState刚好用int可以完整表示。
5.  \*/
    7.// 初始化时有效的线程数为0, 此时ctl为: 1010 0000 0000 0000 0000 0000 0000 0000
    8.private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    9.// 高3位用来表示运行状态，此值用于运行状态向左移动的位数，即29位
    10.private static final int COUNT\_BITS = Integer.SIZE - 3;\
    11.// 线程数容量，低29位表示有效的线程数, 0001 1111 1111 1111 1111 1111 1111 1111
    12.private static final int CAPACITY   = (1 &lt;&lt; COUNT\_BITS) - 1;
6.

14./\*\*
15\. \* 大小关系：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED，

1.
    *   源码中频繁使用大小关系来作为条件判断。
2.
    *   1010 0000 0000 0000 0000 0000 0000 0000 运行
3.
    *   0110 0000 0000 0000 0000 0000 0000 0000 关闭
4.
    *   0110 0000 0000 0000 0000 0000 0000 0000 停止
5.
    *   0110 0000 0000 0000 0000 0000 0000 0000 整理
6.
    *   0110 0000 0000 0000 0000 0000 0000 0000 终止
7.  \*/
    23.private static final int RUNNING    = -1 &lt;&lt; COUNT\_BITS; // 运行
    24.private static final int SHUTDOWN   =  0 &lt;&lt; COUNT\_BITS; // 关闭
    25.private static final int STOP       =  1 &lt;&lt; COUNT\_BITS; // 停止
    26.private static final int TIDYING    =  2 &lt;&lt; COUNT\_BITS; // 整理
    27.private static final int TERMINATED =  3 &lt;&lt; COUNT\_BITS; // 终止
8.

29./\*\*
30\. \* 得到运行状态:入参c为ctl的值，\~CAPACITY高3位为1低29位全为0,

1.
    *   因此运算结果为ctl的高3位, 也就是运行状态
2.  */
    33.private static int runStateOf(int c)     &#123; return c &amp; \~CAPACITY; &#125;\
    34./*\*
3.
    *   得到有效的线程数:入参c为ctl的值, CAPACITY高3为为0,
4.
    *   低29位全为1, 因此运算结果为ctl的低29位, 也就是有效的线程数
5.  */
    38.private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;\
    39./*\*
6.
    *   得到ctl的值：高3位的运行状态和低29位的有效线程数进行或运算,
7.
    *   组合成一个完成的32位数
8.  \*/
    43.private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;
9.

45.// 状态c是否小于s
46.private static boolean runStateLessThan(int c, int s) &#123;

1.  return c &lt; s;
    48.&#125;
    49.// 状态c是否大于等于s
    50.private static boolean runStateAtLeast(int c, int s) &#123;
2.  return c &gt;= s;
    52.&#125;
    53.// 状态c是否为RUNNING（小于SHUTDOWN的状态只有RUNNING）
    54.private static boolean isRunning(int c) &#123;
3.  return c &lt; SHUTDOWN;
    56.&#125;
4.

58.// 使用CAS增加一个有效的线程
59.private boolean compareAndIncrementWorkerCount(int expect) &#123;

1.  return ctl.compareAndSet(expect, expect + 1);
    61.&#125;
2.

63.// 使用CAS减少一个有效的线程
64.private boolean compareAndDecrementWorkerCount(int expect) &#123;

1.  return ctl.compareAndSet(expect, expect - 1);
    66.&#125;
2.

68.// 减少一个有效的线程
69.private void decrementWorkerCount() &#123;

1.  do &#123;&#125; while (! compareAndDecrementWorkerCount(ctl.get()));
    71.&#125;
2.

73.// 工作队列
74.private final BlockingQueue\&lt;Runnable&gt; workQueue;

1.

76.// 锁
77.private final ReentrantLock mainLock = new ReentrantLock();

1.

79.// 包含线程池中的所有工作线程,只有在mainLock的情况下才能访问,Worker集合
80.private final HashSet\&lt;Worker&gt; workers = new HashSet\&lt;Worker&gt;();

1.

82.private final Condition termination = mainLock.newCondition();
83\.
84.// 跟踪线程池的最大到达大小，仅在mainLock下访问
85.private int largestPoolSize;

1.

87.// 总的完成的任务数
88.private long completedTaskCount;

1.

90.// 线程工厂，用于创建线程
91.private volatile ThreadFactory threadFactory;

1.

93.// 拒绝策略
94.private volatile RejectedExecutionHandler handler;

1.
2.

97./\*\*
98\. \* 线程超时时间，当线程数超过corePoolSize时生效,

1.
    *   如果有线程空闲时间超过keepAliveTime, 则会被终止
2.  \*/
    101.private volatile long keepAliveTime;
3.

103.// 是否允许核心线程超时，默认false，false情况下核心线程会一直存活。
104.private volatile boolean allowCoreThreadTimeOut;

1.

106.// 核心线程数
107.private volatile int corePoolSize;

1.

109.// 最大线程数
110.private volatile int maximumPoolSize;

1.

112.// 默认饱和策略（拒绝策略）, 抛异常
113.private static final RejectedExecutionHandler defaultHandler =

1.  new AbortPolicy();
2.

116.private static final RuntimePermission shutdownPerm =
117\.    new RuntimePermission(&quot;modifyThread&quot;);

1.

119./\*\*
120\. \* Worker类，每个Worker包含一个线程、一个初始任务、一个任务计算器

1.  \*/
    122.private final class Worker
2.  extends AbstractQueuedSynchronizer
3.  implements Runnable
    125.&#123;
4.  private static final long serialVersionUID = 6138294804551838833L;
5.
6.  final Thread thread;    // Worker对应的线程
7.  Runnable firstTask; // 运行的初始任务。
8.  volatile long completedTasks;   // 每个线程的任务计数器
9.
10. Worker(Runnable firstTask) &#123;
11.
           setState(-1); // 禁止中断，直到runWorker
12.
           this.firstTask = firstTask; // 设置为初始任务
13.
           // 使用当前线程池的线程工厂创建一个线程
14.
           this.thread = getThreadFactory().newThread(this);  
15. &#125;
16.
17. // 将主运行循环委托给外部runWorker
18. public void run() &#123;
19.
           runWorker(this);
20. &#125;
21.
22. // Lock methods
23. //
24. // The value 0 represents the unlocked state.
25. // The value 1 represents the locked state.
26. /\*\*
27.
        * 通过AQS的同步状态来实现锁机制。state为0时代表锁未被获取（解锁状态），
28.
        * state为1时代表锁已经被获取（加锁状态）。
29.
        */
30. protected boolean isHeldExclusively() &#123; //
31.
           return getState() != 0; 
32. &#125;
33. protected boolean tryAcquire(int unused) &#123;  // 尝试获取锁
34.
           if (compareAndSetState(0, 1)) &#123; // 使用CAS尝试将state设置为1，即尝试获取锁
35.
               // 成功将state设置为1，则当前线程拥有独占访问权
36.
               setExclusiveOwnerThread(Thread.currentThread());    
37.
               return true;
38.
           &#125;
39.
           return false;
40. &#125;
41. protected boolean tryRelease(int unused) &#123;  // 尝试释放锁
42.
           setExclusiveOwnerThread(null);  // 释放独占访问权：即将独占访问线程设为null
43.
           setState(0);    // 解锁：将state设置为0
44.
           return true;
45. &#125;
46. public void lock()        &#123; acquire(1); &#125;   // 加锁
47. public boolean tryLock()  &#123; return tryAcquire(1); &#125; // 尝试加锁
48. public void unlock()      &#123; release(1); &#125;   // 解锁
49. public boolean isLocked() &#123; return isHeldExclusively(); &#125;  // 是否为加锁状态
50. void interruptIfStarted() &#123; // 如果线程启动了，则进行中断
51.
           Thread t;
52.
           if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;
53.
               try &#123;
54.
                   t.interrupt();
55.
               &#125; catch (SecurityException ignore) &#123;
56.
               &#125;
57.
           &#125;
58. &#125;
    181.&#125;

execute方法
使用线程池的submit方法提交任务时，会走到该方法，该方法也是线程池最重要的方法。

1.public void execute(Runnable command) &#123;
2\.    if (command == null)    // 为空校验

1.
            throw new NullPointerException();
2.
3.  int c = ctl.get();  // 拿到当前的ctl值
4.  if (workerCountOf(c) &lt; corePoolSize) &#123;  // 如果有效的线程数小于核心线程数
5.
            if (addWorker(command, true))   // 则新建一个线程来处理任务（核心线程）
6.
                return;
7.
            c = ctl.get();  // 拿到当前的ctl值
8.  &#125;
9.  // 走到这里说明有效的线程数已经 &gt;= 核心线程数
10. if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;// 如果当前状态是运行, 尝试将任务放入工作队列
11.
           int recheck = ctl.get();    // 再次拿到当前的ctl值
12.
           // 如果再次检查状态不是运行, 则将刚才添加到工作队列的任务移除
13.
           if (! isRunning(recheck) &amp;&amp; remove(command)) 
14.
               reject(command);    // 并调用拒绝策略
15.
           else if (workerCountOf(recheck) == 0) // 如果再次检查时,有效的线程数为0, 
16.
               addWorker(null, false); // 则新建一个线程(非核心线程)
17. &#125;
18. // 走到这里说明工作队列已满
19. else if (!addWorker(command, false))//尝试新建一个线程来处理任务(非核心)
20.
           reject(command);    // 如果失败则调用拒绝策略

23.&#125;
该方法就是对应上文的线程池的工作流程。主要调用到的方法为addWorker（见下文addWorker方法解读）。

addWorker方法
1./\*\*

1.
    *   添加一个Worker，Worker包含一个线程和一个任务，由这个线程来执行该任务。
2.  \*/
    4.private boolean addWorker(Runnable firstTask, boolean core) &#123;
3.  retry:
4.  for (;;) &#123;
5.
            int c = ctl.get();  // c赋值为ctl
6.
            int rs = runStateOf(c); // rs赋值为运行状态
7.
            /**
8.
             * 1.如果池停止或有资格关闭，则此方法返回false；
9.
             * 如果线程工厂在被询问时未能创建线程，它也返回false。 
10.
            * 包括以下5种情况：
11.
            * 1).rs为RUNNING，通过校验。
12.
            * 2).rs为STOP或TIDYING或TERMINATED，返回false。
13.
            * （STOP、TIDYING、TERMINATED：已经停止进入最后清理终止，不接受任务不处理队列任务）
14.
            * 3).rs为SHUTDOWN，提交的任务不为空，返回false。
15.
            * （SHUTDOWN：不接受任务但是处理队列任务，因此任务不为空返回false）
16.
            * 4).rs为SHUTDOWN，提交的任务为空，并且工作队列为空，返回false。
17.
            * （状态为SHUTDOWN、提交的任务为空、工作队列为空，则线程池有资格关闭，直接返回false）
18.
            * 5).rs为SHUTDOWN，提交的任务为空，并且工作队列不为空，通过校验。
19.
            * （因为SHUTDOWN状态下刚好可以处理队列任务）
20.
            */
21.
           if (rs &gt;= SHUTDOWN &amp;&amp;
22.
               ! (rs == SHUTDOWN &amp;&amp;
23.
                  firstTask == null &amp;&amp;
24.
                  ! workQueue.isEmpty()))
25.
               return false;
26.
27.
           for (;;) &#123;
28.
               int wc = workerCountOf(c);  // 拿到有效的线程数
29.
               // 校验有效的线程数是否超过阈值
30.
               if (wc &gt;= CAPACITY ||
31.
                   wc &gt;= (core ? corePoolSize : maximumPoolSize))
32.
                   return false;
33.
               // 使用CAS将workerCount+1, 修改成功则跳出循环，否则进入下面的状态判断
34.
               if (compareAndIncrementWorkerCount(c))
35.
                   break retry;
36.
               c = ctl.get();  // 重新读取ctl
37.
               // 判断当前运行状态，如果不等于上面获取的运行状态rs，
38.
               // 说明rs被其他线程修改了，跳到retry重新校验线程池状态
39.
               if (runStateOf(c) != rs)
40.
                   continue retry;
41.
               // 走到这里说明compareAndIncrementWorkerCount失败; 
42.
               // 重试内部循环（状态没变，则继续内部循环，尝试使用CAS修改workerCount）
43.
           &#125;
44. &#125;
45.
46. boolean workerStarted = false;  // Worker的线程是否启动
47. boolean workerAdded = false;    // Worker是否成功增加
48. Worker w = null;
49. try &#123;
50.
           w = new Worker(firstTask);  // 用firstTask和当前线程创建一个Worker
51.
           final Thread t = w.thread;  // 拿到Worker对应的线程
52.
           if (t != null) &#123;
53.
               final ReentrantLock mainLock = this.mainLock;
54.
               mainLock.lock();    // 加锁
55.
               try &#123;
56.
                   // Recheck while holding lock.
57.
                   // Back out on ThreadFactory failure or if
58.
                   // shut down before lock acquired.
59.
                   int rs = runStateOf(ctl.get()); // 加锁的情况下重新获取当前的运行状态
60.
61.
                   // 如果当前的运行状态为RUNNING，
62.
                   // 或者当前的运行状态为SHUTDOWN并且firstTask为空，则通过校验
63.
                   if (rs &lt; SHUTDOWN ||
64.
                       (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;
65.
                       if (t.isAlive())    // 预先校验线程是可以启动的
66.
                           throw new IllegalThreadStateException();
67.
                       workers.add(w); // 将刚创建的worker添加到工作者列表
68.
                       int s = workers.size();
69.
                       if (s &gt; largestPoolSize)
70.
                           largestPoolSize = s;
71.
                       workerAdded = true;
72.
                   &#125;
73.
               &#125; finally &#123;
74.
                   mainLock.unlock();
75.
               &#125;
76.
               if (workerAdded) &#123;  // 如果Worker添加成功，则启动线程执行
77.
                   t.start();
78.
                   workerStarted = true;
79.
               &#125;
80.
           &#125;
81. &#125; finally &#123;
82.
           if (! workerStarted)    // 如果Worker的线程没有成功启动
83.
               addWorkerFailed(w); // 则进行回滚, 移除之前添加的Worker
84. &#125;
85. return workerStarted;
    88.&#125;
    该方法主要目的就是使用入参中的firstTask和当前线程添加一个Worker，前面的for循环主要是对当前线程池的运行状态和有效的线程数进行一些校验，校验逻辑比较绕，可以参考注释进行理解。该方法涉及到的其他方法有addWorkerFailed（见下文addWorkerFailed源码解读）；还有就是Worker的线程启动时，会调用Worker里的run方法，执行runWorker(this)方法（见下文runWorker源码解读）。

addWorkerFailed方法
1./\*\*

1.
    *   Rolls back the worker thread creation.
2.
    *
        *   removes worker from workers, if present
3.
    *
        *   decrements worker count
4.
    *
        *   rechecks for termination, in case the existence of this
5.
    *   worker was holding up termination
6.  \*/
    8.private void addWorkerFailed(Worker w) &#123;    // 回滚Worker的添加，就是将Worker移除
7.  final ReentrantLock mainLock = this.mainLock;
8.  mainLock.lock();
9.  try &#123;
10.
           if (w != null)
11.
               workers.remove(w);  // 移除Worker
12.
           decrementWorkerCount(); // 有效线程数-1
13.
           tryTerminate(); // 有worker线程移除，可能是最后一个线程退出需要尝试终止线程池
14. &#125; finally &#123;
15.
           mainLock.unlock();
16. &#125;
    19.&#125;
    该方法很简单，就是移除入参中的Worker并将workerCount-1，最后调用tryTerminate尝试终止线程池，tryTerminate见下文对应方法源码解读。

runWorker方法
上文addWork方法里说道，当Worker里的线程启动时，就会调用该方法。
1./\*\*

1.
    *   Worker的线程开始执行任务
2.  \*/
    4.final void runWorker(Worker w) &#123;
3.  Thread wt = Thread.currentThread(); // 获取当前线程
4.  Runnable task = w\.firstTask;    // 拿到Worker的初始任务
5.  w\.firstTask = null;
6.  w\.unlock(); // allow interrupts
7.  boolean completedAbruptly = true;   // Worker是不是因异常而死亡
8.  try &#123;
9.
            while (task != null || (task = getTask()) != null) &#123;// Worker取任务执行
10.
               w.lock();   // 加锁
11.
               /**如果线程池停止，确保线程中断; 如果不是，确保线程不被中断。
12.
                * 在第二种情况下进行重新检查，以便在清除中断的同时处理shutdownNow竞争
13.
                * 线程池停止指运行状态为STOP/TIDYING/TERMINATED中的一种
14.
                */
15.
               if ((runStateAtLeast(ctl.get(), STOP) ||    // 判断线程池运行状态
16.
                    (Thread.interrupted() &amp;&amp;   // 重新检查
17.
                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp; // 再次判断线程池运行状态
18.
                   !wt.isInterrupted())// 走到这里代表线程池运行状态为停止,检查wt是否中断
19.
                   wt.interrupt(); // 线程池的状态为停止并且wt不为中断, 则将wt中断
20.
               try &#123;
21.
                   beforeExecute(wt, task);// 执行beforeExecute（默认空，需要自己重写）
22.
                   Throwable thrown = null;
23.
                   try &#123;
24.
                       task.run(); // 执行任务
25.
                   &#125; catch (RuntimeException x) &#123;
26.
                       thrown = x; throw x; //如果抛异常,则completedAbruptly为true
27.
                   &#125; catch (Error x) &#123;
28.
                       thrown = x; throw x;
29.
                   &#125; catch (Throwable x) &#123;
30.
                       thrown = x; throw new Error(x);
31.
                   &#125; finally &#123;
32.
                       afterExecute(task, thrown);// 执行afterExecute（需要自己重写）
33.
                   &#125;
34.
               &#125; finally &#123;
35.
                   task = null;    // 将执行完的任务清空
36.
                   w.completedTasks++; // Worker完成任务数+1
37.
                   w.unlock();
38.
               &#125;
39.
           &#125;
40.
           completedAbruptly = false;  // 如果执行到这里，则worker是正常退出
41. &#125; finally &#123;
42.
           processWorkerExit(w, completedAbruptly);// 调用processWorkerExit方法
43. &#125;
    46.&#125;
    该方法为Worker线程开始执行任务，首先执行当初创建Worker时的初始任务，接着从工作队列中获取任务执行。主要涉及两个方法：获取任务的方法getTask（见下文getTask源码解读）和执行Worker退出的方法processWorkerExit（见下文processWorkerExit源码解读）。注：processWorkerExit在处理正常Worker退出时，没有对workerCount-1，而是在getTask方法中进行workerCount-1。

getTask方法
1.private Runnable getTask() &#123;    // Worker从工作队列获取任务

1.  boolean timedOut = false; // poll方法取任务是否超时
2.
3.  for (;;) &#123;  // 无线循环
4.
            int c = ctl.get();  // ctl
5.
            int rs = runStateOf(c); // 当前运行状态
6.
7.
            // 如果线程池运行状态为停止，或者可以停止（状态为SHUTDOWN并且队列为空）
8.
            // 则返回null，代表当前Worker需要移除
9.
            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;    
10.
               decrementWorkerCount(); // 将workerCount - 1
11.
               // 返回null前将workerCount - 1,
12.
               // 因此processWorkerExit中completedAbruptly＝false时无需再减
13.
               return null;
14.
           &#125;
15.
16.
           int wc = workerCountOf(c);  // 当前的workerCount
17.
18.
           // 判断当前Worker是否可以被移除, 即当前Worker是否可以一直等待任务。
19.
           // 如果allowCoreThreadTimeOut为true，或者workerCount大于核心线程数，
20.
           // 则当前线程是有超时时间的（keepAliveTime），无法一直等待任务。
21.
           boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;    
22.
23.
           // 如果wc超过最大线程数 或者 当前线程会超时并且已经超时，
24.
           // 并且wc &gt; 1 或者 工作队列为空，则返回null，代表当前Worker需要移除
25.
           if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
26.
               &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;   // 确保有Worker可以移除 
27.
               if (compareAndDecrementWorkerCount(c))
28.
                   // 返回null前将workerCount - 1，
29.
                   // 因此processWorkerExit中completedAbruptly＝false时无需再减
30.
                   return null;    
31.
               continue;
32.
           &#125;
33.
34.
           try &#123;
35.
               // 根据线程是否会超时调用相应的方法，poll为带超时的获取任务方法
36.
               // take()为不带超时的获取任务方法，会一直阻塞直到获取到任务
37.
               Runnable r = timed ? 
38.
                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
39.
                   workQueue.take();
40.
               if (r != null)
41.
                   return r;
42.
               timedOut = true;    // 走到这代表当前线程获取任务超时
43.
           &#125; catch (InterruptedException retry) &#123;
44.
               timedOut = false;   // 被中断
45.
           &#125;
46. &#125;
    48.&#125;
    Worker从工作队列获取任务，如果allowCoreThreadTimeOut为false并且  workerCount&lt;=corePoolSize，则这些核心线程永远存活，并且一直在尝试获取工作队列的任务；否则，线程会有超时时间（keepAliveTime），当在keepAliveTime时间内获取不到任务，该线程的Worker会被移除。 
    Worker移除的过程：getTask方法返回null，导致runWorker方法中跳出while循环，调用processWorkerExit方法将Worker移除。注意：在返回null的之前，已经将workerCount-1，因此在processWorkerExit中，completedAbruptly=false的情况（即正常超时退出）不需要再将workerCount-1。

processWorkerExit方法
1.private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;   // Worker的退出

1.  // 如果Worker是异常死亡（completedAbruptly=true），则workerCount-1；
2.  // 如果completedAbruptly为false的时候（正常超时退出），则代表task=getTask()等于null，
3.  // getTask()方法中返回null的地方，都已经将workerCount - 1，所以此处无需再-1
4.  if (completedAbruptly)
5.
            decrementWorkerCount();
6.
7.  final ReentrantLock mainLock = this.mainLock;
8.  mainLock.lock();    // 加锁
9.  try &#123;
10.
           completedTaskCount += w.completedTasks; // 该Worker完成的任务数加到总完成的任务数
11.
           workers.remove(w);  // 移除该Worker
12. &#125; finally &#123;
13.
           mainLock.unlock();
14. &#125;
15.
16. tryTerminate(); // 有Worker线程移除，可能是最后一个线程退出，需要尝试终止线程池
17.
18. int c = ctl.get();  // 获取当前的ctl
19. if (runStateLessThan(c, STOP)) &#123;  // 如果线程池的运行状态还没停止（RUNNING或SHUTDOWN）
20.
           if (!completedAbruptly) &#123;   // 如果Worker不是异常死亡
21.
               // min为线程池的理论最小线程数:如果允许核心线程超时则min为0,否则min为核心线程数
22.
               int min = allowCoreThreadTimeOut ? 0 : corePoolSize;    
23.
               // 如果min为0,工作队列不为空,将min设置为1,确保至少有1个Worker来处理队列里的任务 
24.
               if (min == 0 &amp;&amp; ! workQueue.isEmpty())
25.
                   min = 1;
26.
               // 当前有效的线程数&gt;=min，直接返回;
27.
               if (workerCountOf(c) &gt;= min)
28.
                   return; // replacement not needed 
29.
               // 如果代码走到这边，代表workerCountOf(c) &lt; min，此时会走到下面的addWorker方法。
30.
               // 通过getTask方法我们知道，当allowCoreThreadTimeOut为false
31.
               // 并且workerCount&lt;=corePoolSize时，是不会走到processWorkerExit方法的。
32.
               // 因此走到这边只可能是当前移除的Worker是最后一个Worker，但是此时工作
33.
               // 队列还不为空，因此min被设置成了1，所以需要在添加一个Worker来处理工作队列。
34.
           &#125;
35.
           addWorker(null, false); // 添加一个Worker
36. &#125;
    38.&#125;
    该方法就是执行Worker的退出：统计完成的任务数，将Worker移除，并尝试终止线程池，最后根据情况决定是否创建一个新的Worker。两种情况下会创建一个新的Worker：1）被移除的Worker是由于异常而死亡；2）被移除的Worker是最后一个Worker，但是工作队列还有任务。completedAbruptly=false时，没有将workerCount-1是因为已经在getTask方法中将workerCount-1。

tryTerminate方法
1.final void tryTerminate() &#123; // 尝试终止线程池

1.  for (;;) &#123;
2.
            int c = ctl.get();
3.
            // 只有当前状态为STOP 或者 SHUTDOWN并且队列为空，才会尝试整理并终止
4.
            // 1: 当前状态为RUNNING，则不尝试终止，直接返回
5.
            // 2: 当前状态为TIDYING或TERMINATED，代表有其他线程正在执行终止，直接返回
6.
            // 3: 当前状态为SHUTDOWN 并且 workQueue不为空，则不尝试终止，直接返回
7.
            if (isRunning(c) || // 1
8.
                runStateAtLeast(c, TIDYING) ||  // 2
9.
                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))   // 3
10.
               return;
11.
           // 走到这代表线程池可以终止（通过上面的校验）
12.
           // 如果此时有效线程数不为0， 将中断一个空闲的Worker，以确保关闭信号传播
13.
           if (workerCountOf(c) != 0) &#123; // Eligible to terminate 
14.
               interruptIdleWorkers(ONLY_ONE);
15.
               return;
16.
           &#125;
17.
18.
           final ReentrantLock mainLock = this.mainLock;
19.
           mainLock.lock();    // 加锁，终止线程池
20.
           try &#123;
21.
               // 使用CAS将ctl的运行状态设置为TIDYING，有效线程数设置为0
22.
               if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;  
23.
                   try &#123;
24.
                       terminated();   // 供用户重写的terminated方法，默认为空
25.
                   &#125; finally &#123;
26.
                       // 将ctl的运行状态设置为TERMINATED，有效线程数设置为0
27.
                       ctl.set(ctlOf(TERMINATED, 0));  
28.
                       termination.signalAll();
29.
                   &#125;
30.
                   return;
31.
               &#125;
32.
           &#125; finally &#123;
33.
               mainLock.unlock();
34.
           &#125;
35.
           // else retry on failed CAS
36. &#125;
    38.&#125;
    该方法用来尝试终止线程池，主要在移除Worker后会调用此方法。首先进行一些状态的校验，如果通过校验，则在加锁的条件下，使用CAS将运行状态设为TERMINATED，有效线程数设为0。

深入理解Callable
概述
Callable和Runnbale一样代表着任务，区别在于Callable有返回值并且可以抛出异常。其使用如下：
public class CallableDemo &#123;
static class SumTask implements Callable\&lt;Long&gt; &#123;
@Override
public Long call() throws Exception &#123;
long sum = 0;
for (int i = 0; i &lt; 9000; i++) &#123;
sum += i;
&#125;
return sum;
&#125;
&#125;
public static void main(String\[] args) throws ExecutionException, InterruptedException &#123;
System.out.println(&quot;Start:&quot; + System.nanoTime());
FutureTask\&lt;Long&gt; futureTask = new FutureTask\&lt;Long&gt;(new SumTask());
Executor executor=Executors.newSingleThreadExecutor();
executor.execute(futureTask);
System.out.println(futureTask.get());
System.out.println(&quot;End:&quot; + System.nanoTime());
&#125;
&#125;
从上面的代码可以看到，使用到了一个FutureTask的变量并且还可以得到Callable执行的结果，那么这个FutureTask是什么呢?
分析
Future接口
Future是一个接口，代表了一个异步计算的结果。接口中的方法用来检查计算是否完成、等待完成和得到计算的结果。当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了。如果想取消，那么调用cancel()方法。其他方法用于确定任务是正常完成还是取消了。一旦计算完成了，那么这个计算就不能被取消。
FutureTask类
FutureTask类实现了RunnableFuture接口，而RunnnableFuture接口继承了Runnable和Future接口，所以说FutureTask是一个提供异步计算的结果的任务。 
FutureTask可以用来包装Callable或者Runnbale对象。因为FutureTask实现了Runnable接口，所以FutureTask也可以被提交给Executor（如上面例子那样）。
FutureTask的状态
FutureTask中有一个表示任务状态的int值，初始为NEW。定义如下：
private volatile int state;
private static final int NEW          = 0;
private static final int COMPLETING   = 1;
private static final int NORMAL       = 2;
private static final int EXCEPTIONAL  = 3;
private static final int CANCELLED    = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED  = 6;
可能的状态转换包括： 

*   NEW -&gt; COMPLETING -&gt; NORMAL 
*   NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 
*   NEW -&gt; CANCELLED 
*   NEW -&gt; INTERRUPTING -&gt; INTERRUPTED
    构造方法
    FutureTask一共有两个构造方法，如下:
    public FutureTask(Callable\&lt;V&gt; callable) &#123;
    if (callable == null)
    throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
    &#125;

    public FutureTask(Runnable runnable, V result) &#123;
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
    &#125;
    第一个构造方法好理解；第二个方法是将Runnbale和结果组合成一个Callable，这个可以通过Excutors.callable()方法得出结论：
    public static \&lt;T&gt; Callable\&lt;T&gt; callable(Runnable task, T result) &#123;
    if (task == null)
    throw new NullPointerException();
    return new RunnableAdapter\&lt;T&gt;(task, result);
    &#125;

static final class RunnableAdapter\&lt;T&gt; implements Callable\&lt;T&gt; &#123;
final Runnable task;
final T result;
RunnableAdapter(Runnable task, T result) &#123;
this.task = task;
this.result = result;
&#125;
public T call() &#123;
task.run();
return result;
&#125;
&#125;
从上面可以看到RunnableAdapter实现了Callable并且在call方法中调用了Runnable的run方法，然后将结果返回，这其实就是一个适配器模式啊。 
所以说两个构造方法最终都是得到了一个Callable以及设置了初始状态为NEW。
run方法
当将FutureTask提交给Executor后，Executor执行FutureTask时会执行其run方法，下面看一下run方法中做了哪些事情。
public void run() &#123;
//如果状态不为NEW或者CAS当前执行线程失败，直接返回
if (state != NEW ||
!UNSAFE.compareAndSwapObject(this, runnerOffset,
null, Thread.currentThread()))
return;
//尝试调用Callable.call
try &#123;
Callable\&lt;V&gt; c = callable;
if (c != null &amp;&amp; state == NEW) &#123;
V result;
boolean ran;
try &#123;
result = c.call();
ran = true;
&#125; catch (Throwable ex) &#123;
//出现异常了，调用setException方法
result = null;
ran = false;
setException(ex);
&#125;
//如果成功了，调用set方法
if (ran)
set(result);
&#125;
&#125; finally &#123;
// runner must be non-null until state is settled to
// prevent concurrent calls to run()
runner = null;
// state must be re-read after nulling runner to prevent
// leaked interrupts
//如果在执行过程，任务被取消了
int s = state;
if (s &gt;= INTERRUPTING)
handlePossibleCancellationInterrupt(s);
&#125;
&#125;
从上面可以看到，任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程。从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法，下面我们分别来看这几种情况。
set方法
当Callable成功执行后，会调用set方法将结果传出。源码如下：
protected void set(V v) &#123;
//完成NEW-&gt;COMPLETING-&gt;NORMAL状态转换
if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;
outcome = v;
UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
finishCompletion();
&#125;
&#125;
从上面可以看到，将outcome变量赋值为结果，并将state状态更新，最后调用finishCompletion()方法。finishCompletion()方法将移除和通知所有等待线程，这个方法后面再说。下面先看setException方法。
setException方法
setException方法如下：
//完成NEW-&gt;COMPLETING-&gt;EXCEPTIONAL状态转换
protected void setException(Throwable t) &#123;
if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;
outcome = t;
UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state
finishCompletion();
&#125;
&#125;
从上面看到，该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程。
get方法
当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况。
public static void main(String\[] args) throws ExecutionException, InterruptedException &#123;
System.out.println(&quot;Start:&quot; + System.nanoTime());
FutureTask\&lt;Long&gt; futureTask = new FutureTask\&lt;Long&gt;(new SumTask());
Executor executor=Executors.newSingleThreadExecutor();
executor.execute(futureTask);
for(int i=0;i&lt;5;i++)&#123;
executor.execute(new Runnable() &#123;
@Override
public void run() &#123;
try &#123;
System.out.println(&quot;get result &quot;+futureTask.get());
&#125; catch (InterruptedException e) &#123;
e.printStackTrace();
&#125; catch (ExecutionException e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;);
&#125;
System.out.println(futureTask.get());
System.out.println(&quot;End:&quot; + System.nanoTime());
&#125;
该例子展示了一共有5个线程想得到FutureTask的结果，一旦调用get，那么该线程就会阻塞。 
FutureTask的get方法实现如下：
public V get() throws InterruptedException, ExecutionException &#123;
int s = state;
if (s &lt;= COMPLETING)
s = awaitDone(false, 0L);
return report(s);
&#125;
从上面的代码可以看到，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。 
在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待。下面先看下awaitDone方法是如何将调用线程阻塞的。awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制。awaitDone方法如下：
private int awaitDone(boolean timed, long nanos)
throws InterruptedException &#123;
final long deadline = timed ? System.nanoTime() + nanos : 0L;
WaitNode q = null;
boolean queued = false;
for (;;) &#123;
//如果当前线程被中断了，移除并抛出异常
if (Thread.interrupted()) &#123;
removeWaiter(q);
throw new InterruptedException();
&#125;

            int s = state;
            //如果状态大于COMPLETING，说明已经计算已经完成了
            if (s &gt; COMPLETING) &#123;
                if (q != null)
                    q.thread = null;
                return s;
            &#125;
            //状态是COMPLETING，在set和setException方法中可以看到处于该状态马上就会进入下一个状态
            else if (s == COMPLETING) // cannot time out yet
                Thread.yield();
            //新建一个等待节点
            else if (q == null)
                q = new WaitNode();
            //还没有入队，尝试入队
            else if (!queued)
                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                     q.next = waiters, q);
            //如果限制了时间
            else if (timed) &#123;
                nanos = deadline - System.nanoTime();
                if (nanos &lt;= 0L) &#123;
                    removeWaiter(q);
                    return state;
                &#125;
                //挂起指定时间
                LockSupport.parkNanos(this, nanos);
            &#125;
            //无限挂起
            else
                LockSupport.park(this);
        &#125;
    &#125;

1
上面的代码中有一个WaitNode类，该类表示等待节点，保存等待的线程以及下一个节点，是一个单链表结构，其定义如下:
static final class WaitNode &#123;
volatile Thread thread;
volatile WaitNode next;
WaitNode() &#123; thread = Thread.currentThread(); &#125;
&#125;
awaitDone方法中进入死循环后，主要有几步： 

1.  如果线程被中断了，移除节点，抛出异常 
2.  如果状态大于COMPLETING，那么直接返回 
3.  如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下 
4.  如果状态是NEW且节点为null，那么创建一个节点 
5.  如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程 
6.  如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点。 
7.  如果没有限制时间，那么将线程无限挂起
    上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。 
    当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果，其实现如下：
    private V report(int s) throws ExecutionException &#123;
    Object x = outcome;
    //如果计算正常结束
    if (s == NORMAL)
    return (V)x;
    //如果计算被取消了
    if (s &gt;= CANCELLED)
    throw new CancellationException();
    //如果计算以异常计算
    throw new ExecutionException((Throwable)x);
    &#125;
    从上面可以看到report会根据任务的状态不同返回不同的结果。 

*   如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果 
*   如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException 
*   如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException
    finishCompletion方法
    在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程。finishCompletion的实现如下：
    private void finishCompletion() &#123;
    //如果有等待线程，从头开始解除挂起
    for (WaitNode q; (q = waiters) != null;) &#123;
    if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;
    for (;;) &#123;
    //得到等待节点的线程，解除挂起
    Thread t = q.thread;
    if (t != null) &#123;
    q.thread = null;
    LockSupport.unpark(t);
    &#125;
    WaitNode next = q.next;
    if (next == null)
    break;
    q.next = null; // unlink to help gc
    q = next;
    &#125;
    break;
    &#125;
    &#125;
    done();
    callable = null;        // to reduce footprint
    &#125;
    finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环。 
    释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。 
    上面的方法分析完了FutureTask的主要流程，包括调用get线程的阻塞、run方法执行、计算结果的返回。下面再来看一些取消、查看状态的方法。
    cancel方法
    cancel方法用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了。其源码如下：
    public boolean cancel(boolean mayInterruptIfRunning) &#123;
    if (!(state == NEW &amp;&amp;
    UNSAFE.compareAndSwapInt(this, stateOffset, NEW,
    mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
    return false;
    try &#123;
    //如果需要中断
    if (mayInterruptIfRunning) &#123;
    try &#123;
    Thread t = runner;
    if (t != null)
    t.interrupt();
    &#125; finally &#123;
    //最终状态INTERRUPTED
    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);
    &#125;
    &#125;
    &#125; finally &#123;
    //释放等待线程
    finishCompletion();
    &#125;
    return true;
    &#125;
    从上面可以看到如果是需要中断正在执行的任务，那么状态转换将会是NEW-&gt;INTERRPUTING-&gt;INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW-&gt;CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。 
    当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。
    isDone方法
    Future接口中isDone方法表明任务是否已经完成了，如果完成了，那么返回true，否则false。下面是FutureTask的实现：
    public boolean isDone() &#123;
    return state != NEW;
    &#125;
    可以看到只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。
    总结
    Callable是一种可以返回结果的任务，这是它与Runnable的区别，但是通过适配器模式可以使Runnable与Callable类似。Future代表了一个异步的计算，可以从中得到计算结果、查看计算状态，其实现FutureTask可以被提交给Executor执行，多个线程可以从中得到计算结果。Callable和Future是配合使用的，当从Future中get结果时，如果结果还没被计算出来，那么线程将会被挂起，FutureTak内部使用一个单链表维持等待的线程；当计算结果出来后，将会对等待线程解除挂起，等待线程就都可以得到计算结果了。

公平锁/非公平锁
可重入锁
独享锁/共享锁
互斥锁/读写锁
乐观锁/悲观锁(实现秒杀的一种解决方案)
（select \* from product p where  p.type=’xxxxx’  for update）

分段锁
偏向锁/轻量级锁/重量级锁
自旋锁
上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。
公平锁/非公平锁
公平锁是指多个线程按照申请锁的顺序来获取锁。
非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。
对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。
可重入锁
可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。
对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。
对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。
synchronized void setA() throws Exception&#123;
Thread.sleep(1000);
setB();
&#125;

synchronized void setB() throws Exception&#123;
Thread.sleep(1000);
&#125;
上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。
独享锁/共享锁
独享锁是指该锁一次只能被一个线程所持有。
共享锁是指该锁可被多个线程所持有。
对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
对于Synchronized而言，当然是独享锁。
互斥锁/读写锁
上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
互斥锁在Java中的具体实现就是ReentrantLock
读写锁在Java中的具体实现就是ReadWriteLock
乐观锁/悲观锁
乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
悲观锁在Java中的使用，就是利用各种锁。
乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
分段锁
分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。
偏向锁/轻量级锁/重量级锁
这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。
自旋锁
在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

99、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？

java5以前，有如下两种：
第一种：
new Thread()&#123;&#125;.start();这表示调用Thread子类对象的run方法，new Thread()&#123;&#125;表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：
new Thread()&#123;
public void run()&#123;
&#125;
&#125;.start();

第二种：
new Thread(new Runnable()&#123;&#125;).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable()&#123;&#125;表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：
new Thread(new Runnable()&#123;
public void run()&#123;
&#125;
&#125;
).start();

从java5开始，还有如下一些线程池创建多线程的方式：
ExecutorService pool = Executors.newFixedThreadPool(3)
for(int i=0;i&lt;10;i++)
&#123;
pool.execute(new Runable()&#123;public void run()&#123;&#125;&#125;);
&#125;
Executors.newCachedThreadPool().execute(new Runable()&#123;public void run()&#123;&#125;&#125;);
Executors.newSingleThreadExecutor().execute(new Runable()&#123;public void run()&#123;&#125;&#125;);

有两种实现方法，分别使用new Thread()和new Thread(runnable)形式，第一种直接调用thread的run方法，所以，我们往往使用Thread子类，即new SubThread()。第二种调用runnable的run方法。

有两种实现方法，分别是继承Thread类与实现Runnable接口
用synchronized关键字修饰同步方法
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被&quot;挂起&quot;的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。
13、sleep() 和 wait() 有什么区别?
（网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。）

sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。
package com.huawei.interview;

public class MultiThread &#123;

    /**
     * @param args
     */
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        new Thread(new Thread1()).start();
        try &#123;
            Thread.sleep(10);
        &#125; catch (InterruptedException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        new Thread(new Thread2()).start();        
    &#125;


    private static class Thread1 implements Runnable
    &#123;

        @Override
        public void run() &#123;
            // TODO Auto-generated method stub

//由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。
synchronized (MultiThread.class) &#123;

                System.out.println(&quot;enter thread1...&quot;);
                
                System.out.println(&quot;thread1 is waiting&quot;);
                try &#123;
            //释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。
                    MultiThread.class.wait();
                &#125; catch (InterruptedException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;
                
                System.out.println(&quot;thread1 is going on...&quot;);
                System.out.println(&quot;thread1 is being over!&quot;);            
            &#125;
        &#125;
        
    &#125;

    private static class Thread2 implements Runnable
    &#123;

        @Override
        public void run() &#123;
            // TODO Auto-generated method stub
            synchronized (MultiThread.class) &#123;
            
                System.out.println(&quot;enter thread2...&quot;);
                
                System.out.println(&quot;thread2 notify other thread can release wait status..&quot;);

//由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。

                MultiThread.class.notify();
                
                System.out.println(&quot;thread2 is sleeping ten millisecond...&quot;);
                try &#123;
                    Thread.sleep(10);
                &#125; catch (InterruptedException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;
                
                System.out.println(&quot;thread2 is going on...&quot;);
                System.out.println(&quot;thread2 is being over!&quot;);
                
            &#125;
        &#125;
        
    &#125;    

&#125;

16、同步和异步有何异同，在什么情况下分别使用他们？举例说明。
如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

1.  下面两个方法同步吗？（自己发明）
    class Test
    &#123;
    synchronized static void sayHello3()
    &#123;

        &#125;    

        synchronized void getX()&#123;&#125;

&#125;
56、多线程有几种实现方法?同步有几种实现方法?
多线程有两种实现方法，分别是继承Thread类与实现Runnable接口
同步的实现方面有两种，分别是synchronized,wait与notify
wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

30、启动一个线程是用run()还是start()? .
启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。

47、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
分几种情况：
1.其他方法前是否加了synchronized关键字，如果没加，则能。
2.如果这个方法内部调用了wait，则可以进入其他synchronized方法。
3.如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。
4.如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。

58、线程的基本概念、线程的基本状态以及状态之间的关系

一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。

状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。
调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。

71、简述synchronized和java.util.concurrent.locks.Lock的异同 ？
主要相同点：Lock能完成synchronized所实现的所有功能
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。
举例说明（对下面的题用lock进行了改写）：
package com.huawei.interview;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadTest &#123;

    /**
     * @param args
     */

    private int j;
    private Lock lock = new ReentrantLock();
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        ThreadTest tt = new ThreadTest();
        for(int i=0;i&lt;2;i++)
        &#123;
            new Thread(tt.new Adder()).start();
            new Thread(tt.new Subtractor()).start();
        &#125;
    &#125;

    private class Subtractor implements Runnable
    &#123;

        @Override
        public void run() &#123;
            // TODO Auto-generated method stub
            while(true)
            &#123;
                /*synchronized (ThreadTest.this) &#123;            
                    System.out.println(&quot;j--=&quot; + j--);
                    //这里抛异常了，锁能释放吗？
                &#125;*/
                lock.lock();
                try
                &#123;
                    System.out.println(&quot;j--=&quot; + j--);
                &#125;finally
                &#123;
                    lock.unlock();
                &#125;
            &#125;
        &#125;
        
    &#125;

    private class Adder implements Runnable
    &#123;

        @Override
        public void run() &#123;
            // TODO Auto-generated method stub
            while(true)
            &#123;
                /*synchronized (ThreadTest.this) &#123;
                System.out.println(&quot;j++=&quot; + j++);    
                &#125;*/
                lock.lock();
                try
                &#123;
                    System.out.println(&quot;j++=&quot; + j++);
                &#125;finally
                &#123;
                    lock.unlock();
                &#125;                
            &#125;            
        &#125;
        
    &#125;

&#125;
28、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。
以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。
public class ThreadTest1
&#123;
private int j;
public static void main(String args\[])&#123;
ThreadTest1 tt=new ThreadTest1();
Inc inc=tt.new Inc();
Dec dec=tt.new Dec();
for(int i=0;i&lt;2;i++)&#123;
Thread t=new Thread(inc);
t.start();
t=new Thread(dec);
t.start();
&#125;
&#125;
private synchronized void inc()&#123;
j++;
System.out.println(Thread.currentThread().getName()+&quot;-inc:&quot;+j);
&#125;
private synchronized void dec()&#123;
j--;
System.out.println(Thread.currentThread().getName()+&quot;-dec:&quot;+j);
&#125;
class Inc implements Runnable&#123;
public void run()&#123;
for(int i=0;i&lt;100;i++)&#123;
inc();
&#125;
&#125;
&#125;
class Dec implements Runnable&#123;
public void run()&#123;
for(int i=0;i&lt;100;i++)&#123;
dec();
&#125;
&#125;
&#125;
&#125;

\----------随手再写的一个-------------
class A
&#123;
JManger j =new JManager();
main()
&#123;
new A().call();
&#125;

void call
&#123;
for(int i=0;i&lt;2;i++)
&#123;
new Thread(
new Runnable()&#123; public void run()&#123;while(true)&#123;j.accumulate()&#125;&#125;&#125;
).start();
new Thread(new Runnable()&#123; public void run()&#123;while(true)&#123;j.sub()&#125;&#125;&#125;).start();
&#125;
&#125;
&#125;

class JManager
&#123;
private j = 0;

    public synchronized void subtract()
    &#123;
        j--
    &#125;

    public synchronized void accumulate()
    &#123;
        j++;
    &#125;

&#125;

28、子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。

最终的程序代码如下：
public class ThreadTest &#123;

    /**
     * @param args
     */
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        new ThreadTest().init();

    &#125;

    public void init()
    &#123;
        final Business business = new Business();
        new Thread(
                new Runnable()
                &#123;

                    public void run() &#123;
                        for(int i=0;i&lt;50;i++)
                        &#123;
                            business.SubThread(i);
                        &#125;                        
                    &#125;
                    
                &#125;
        
        ).start();
        
        for(int i=0;i&lt;50;i++)
        &#123;
            business.MainThread(i);
        &#125;        
    &#125;

    private class Business
    &#123;
        boolean bShouldSub = true;//这里相当于定义了控制该谁执行的一个信号灯
        public synchronized void MainThread(int i)
        &#123;
            if(bShouldSub)
                try &#123;
                    this.wait();
                &#125; catch (InterruptedException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;        
                
            for(int j=0;j&lt;5;j++)
            &#123;
                System.out.println(Thread.currentThread().getName() + &quot;:i=&quot; + i +&quot;,j=&quot; + j);
            &#125;
            bShouldSub = true;
            this.notify();
        
        &#125;
        
        
        public synchronized void SubThread(int i)
        &#123;
            if(!bShouldSub)
                try &#123;
                    this.wait();
                &#125; catch (InterruptedException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;    
                
            for(int j=0;j&lt;10;j++)
            &#123;
                System.out.println(Thread.currentThread().getName() + &quot;:i=&quot; + i +&quot;,j=&quot; + j);
            &#125;
            bShouldSub = false;                
            this.notify();            
        &#125;
    &#125;

&#125;

备注：不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去：

package com.huawei.interview\.lym;

public class ThreadTest &#123;

    private static boolean bShouldMain = false;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        /*new Thread()&#123;
        public void run()
        &#123;
            for(int i=0;i&lt;50;i++)
            &#123;
                for(int j=0;j&lt;10;j++)
                &#123;
                    System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);
                &#125;
            &#125;                
        &#125;
        
    &#125;.start();*/        
        
        
        //final String str = new String(&quot;&quot;);

        new Thread(
                new Runnable()
                &#123;
                    public void run()
                    &#123;
                        for(int i=0;i&lt;50;i++)
                        &#123;
                            synchronized (ThreadTest.class) &#123;
                                if(bShouldMain)
                                &#123;
                                    try &#123;
                                        ThreadTest.class.wait();&#125; 
                                    catch (InterruptedException e) &#123;
                                        e.printStackTrace();
                                    &#125;
                                &#125;
                                for(int j=0;j&lt;10;j++)
                                &#123;
                                    System.out.println(
                                            Thread.currentThread().getName() + 
                                            &quot;i=&quot; + i + &quot;,j=&quot; + j);
                                &#125;
                                bShouldMain = true;
                                ThreadTest.class.notify();
                            &#125;                            
                        &#125;                        
                    &#125;
                &#125;
        ).start();
        
        for(int i=0;i&lt;50;i++)
        &#123;
            synchronized (ThreadTest.class) &#123;
                if(!bShouldMain)
                &#123;
                    try &#123;
                        ThreadTest.class.wait();&#125; 
                    catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;                
                for(int j=0;j&lt;5;j++)
                &#123;
                    System.out.println(
                            Thread.currentThread().getName() +                         
                            &quot;i=&quot; + i + &quot;,j=&quot; + j);
                &#125;
                bShouldMain = false;
                ThreadTest.class.notify();                
            &#125;            
        &#125;
    &#125;

&#125;
下面使用jdk5中的并发库来实现的：
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;

public class ThreadTest
&#123;
private static Lock lock = new ReentrantLock();
private static Condition subThreadCondition = lock.newCondition();
private static boolean bBhouldSubThread = false;
public static void main(String \[] args)
&#123;
ExecutorService threadPool = Executors.newFixedThreadPool(3);
threadPool.execute(new Runnable()&#123;
public void run()
&#123;
for(int i=0;i&lt;50;i++)
&#123;
lock.lock();
try
&#123;
if(!bBhouldSubThread)
subThreadCondition.await();
for(int j=0;j&lt;10;j++)
&#123;
System.out.println(Thread.currentThread().getName() + &quot;,j=&quot; + j);
&#125;
bBhouldSubThread = false;
subThreadCondition.signal();
&#125;catch(Exception e)
&#123;
&#125;
finally
&#123;
lock.unlock();
&#125;
&#125;
&#125;

        &#125;);
        threadPool.shutdown();
        for(int i=0;i&lt;50;i++)
        &#123;
                lock.lock();                    
                try
                &#123;    
                    if(bBhouldSubThread)
                            subThreadCondition.await();                                
                    for(int j=0;j&lt;10;j++)
                    &#123;
                        System.out.println(Thread.currentThread().getName() + &quot;,j=&quot; + j);
                    &#125;
                    bBhouldSubThread = true;
                    subThreadCondition.signal();                    
                &#125;catch(Exception e)
                &#123;                        
                &#125;
                finally
                &#123;
                    lock.unlock();
                &#125;                    
        &#125;
    &#125;

&#125;

线程编程方面   
60、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
答：有两种实现方法，分别是继承Thread类与实现Runnable接口
用synchronized关键字修饰同步方法
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被&quot;挂起&quot;的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。
61、sleep() 和 wait() 有什么区别? 
答：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
62、同步和异步有何异同，在什么情况下分别使用他们？举例说明。
答：如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。
63、启动一个线程是用run()还是start()?
答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 
64、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
答：不能，一个对象的一个synchronized方法只能由一个线程访问。
65、请说出你所知道的线程同步的方法。
答：wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。
66、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 
答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 
同步的实现方面有两种，分别是synchronized,wait与notify
67、线程的基本概念、线程的基本状态以及状态之间的关系
答：线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。
Java中的线程有四种状态分别是：运行、就绪、挂起、结束
68、简述synchronized和java.util.concurrent.locks.Lock的异同 ？
答：主要相同点：Lock能完成synchronized所实现的所有功能
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。
Jsp方面
69、forward 和redirect的区别
答：forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。
    redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。
70、jsp有哪些内置对象?作用分别是什么?
答：JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：
　request 用户端请求，此请求会包含来自GET/POST请求的参数
   response 网页传回用户端的回应
   pageContext 网页的属性是在这里管理
   session 与请求有关的会话期
   application servlet 正在执行的内容
   out 用来传送回应的输出
   config servlet的构架部件
   page JSP网页本身
   exception 针对错误网页，未捕捉的例外
71、jsp有哪些动作?作用分别是什么?
答\:JSP共有以下6种基本动作
   jsp\:include：在页面被请求的时候引入一个文件。
   jsp\:useBean：寻找或者实例化一个JavaBean。
   jsp\:setProperty：设置JavaBean的属性。
   jsp\:getProperty：输出某个JavaBean的属性。
   jsp\:forward：把请求转到一个新的页面。
   jsp\:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记
72、JSP中动态INCLUDE与静态INCLUDE的区别？
答：动态INCLUDE用jsp\:include动作实现
   \&lt;jsp\:include page=&quot;included.jsp&quot; flush=&quot;true&quot; /&gt;它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数
   静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面
   &lt;%@ include file=&quot;included.htm&quot; %&gt;
73、两种跳转方式分别是什么?有什么区别?
答：有两种，分别为：
  \&lt;jsp\:include page=&quot;included.jsp&quot; flush=&quot;true&quot;&gt;
  \&lt;jsp\:forward page= &quot;nextpage.jsp&quot;/&gt;
前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。
74、JSP的内置对象及方法。
答：request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。 
    response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等） 
    out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 
    pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。 
    session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息 
    applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息 
    config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 
    page表示从该页面产生的一个servlet实例
Servlet方面
75、说一说Servlet的生命周期?
答\:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。 Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。
76、JAVA SERVLET API中forward() 与redirect()的区别？
答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。
77、Servlet的基本架构
答：
public class ServletName extends HttpServlet &#123;
  public void doPost(HttpServletRequest request, HttpServletResponse response) throws
      ServletException, IOException  &#123;
      &#125;
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws
      ServletException, IOException  &#123;
      &#125;
&#125;
78、什么情况下调用doGet()和doPost()？
答：Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。
79、servlet的生命周期
答：web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现，根据请求的不同调用不同的do\*\*\*()方法。结束服务，web容器调用servlet的destroy()方法。
80、如何现实servlet的单线程模式
答：&lt;%@ page isThreadSafe=&quot;false&quot;%&gt;
81、页面间对象传递的方法
答：request，session，application，cookie等
82、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？ 
答：JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是&quot;类servlet&quot;。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。
83、四种会话跟踪技术
答：会话作用域ServletsJSP 页面描述
page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面
request是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系）
session是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求
application是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域
84、Request对象的主要方法
答：
setAttribute(String name,Object)：设置名字为name的request的参数值
getAttribute(String name)：返回由name指定的属性值
getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例
getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组
getCharacterEncoding()：返回请求中的字符编码方式
getContentLength()：返回请求的Body的长度
getHeader(String name)：获得HTTP协议定义的文件头信息
getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例
getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例
getInputStream()：返回请求的输入流，用于获得请求中的数据
getMethod()：获得客户端向服务器端传送数据的方法
getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值
getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例
getParameterValues(String name)：获得有name指定的参数的所有值
getProtocol()：获取客户端向服务器端传送数据所依据的协议名称
getQueryString()：获得查询字符串
getRequestURI()：获取发出请求字符串的客户端地址
getRemoteAddr()：获取客户端的IP地址
getRemoteHost()：获取客户端的名字
getSession(\[Boolean create])：返回和请求相关Session
getServerName()：获取服务器的名字
getServletPath()：获取客户端所请求的脚本文件的路径
getServerPort()：获取服务器的端口号
removeAttribute(String name)：删除请求中的一个属性
85、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？
答：
  Public String translate (String str) &#123;
    String tempStr = &quot;&quot;;
    try &#123;
      tempStr = new String(str.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);
      tempStr = tempStr.trim();
    &#125;
    catch (Exception e) &#123;
      System.err.println(e.getMessage());
    &#125;
    return tempStr;
  &#125;
86、Servlet执行时一般实现哪几个方法？
答：
public void init(ServletConfig config)
public ServletConfig getServletConfig()
public String getServletInfo()
public void service(ServletRequest request,ServletResponse response)
public void destroy()
Jdbc、Jdo方面
87、Class.forName的作用?为什么要用?
答：调用该访问返回一个以字符串指定类名的类的对象。
88、Jdo是什么?
答：JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。
89、说出数据连接池的工作机制是什么?
答：J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。
90、Jdo是什么? 
答：JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。
Xml方面
91、xml有哪些解析技术?区别是什么?
答：有DOM,SAX,STAX等
DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问
STAX\:Streaming API for XML (StAX)
92、你在项目中用到了xml技术的哪些方面?如何实现的?
答：用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。
93、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ 
答：a: 两种形式 dtd  schema，b: 本质区别\:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)，c:有DOM,SAX,STAX等 
    DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问
SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 
STAX\:Streaming API for XML (StAX)

线程间的通信
线程间的通信方式
1、同步
这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。
这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。
例如
public class MyObject &#123;

    synchronized public void methodA() &#123;
        //do something....
    &#125;

    synchronized public void methodB() &#123;
        //do some other thing
    &#125;

&#125;

public class ThreadA extends Thread &#123;

    private MyObject object;

//省略构造方法
@Override
public void run() &#123;
super.run();
object.methodA();
&#125;
&#125;

public class ThreadB extends Thread &#123;

    private MyObject object;

//省略构造方法
@Override
public void run() &#123;
super.run();
object.methodB();
&#125;
&#125;

public class Run &#123;
public static void main(String\[] args) &#123;
MyObject object = new MyObject();

        //线程A与线程B 持有的是同一个对象:object
        ThreadA a = new ThreadA(object);
        ThreadB b = new ThreadB(object);
        a.start();
        b.start();
    &#125;

&#125;
2、while轮询的方式
在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信。但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是： 在干别的事情，当有电话来时，响铃通知TA电话来了。关于线程的轮询的影响，可参考：JAVA多线程之当一个线程在执行死循环时会影响另外一个线程吗？
这种方式还存在另外一个问题：轮询的条件的可见性问题。
线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的 条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。
例如：
import java.util.ArrayList;
import java.util.List;

public class MyList &#123;

    private List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    public void add() &#123;
        list.add(&quot;elements&quot;);
    &#125;
    public int size() &#123;
        return list.size();
    &#125;

&#125;

import mylist.MyList;

public class ThreadA extends Thread &#123;

    private MyList list;

    public ThreadA(MyList list) &#123;
        super();
        this.list = list;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                list.add();
                System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素&quot;);
                Thread.sleep(1000);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

import mylist.MyList;

public class ThreadB extends Thread &#123;

    private MyList list;

    public ThreadB(MyList list) &#123;
        super();
        this.list = list;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            while (true) &#123;
                if (list.size() == 5) &#123;
                    System.out.println(&quot;==5, 线程b准备退出了&quot;);
                    throw new InterruptedException();
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

import mylist.MyList;
import extthread.ThreadA;
import extthread.ThreadB;

public class Test &#123;

    public static void main(String[] args) &#123;
        MyList service = new MyList();

        ThreadA a = new ThreadA(service);
        a.setName(&quot;A&quot;);
        a.start();

        ThreadB b = new ThreadB(service);
        b.setName(&quot;B&quot;);
        b.start();
    &#125;

&#125;
3、wait/notify机制
线程A要等待某个条件满足时(list.size()==5)，才执行操作。线程B则向list中添加元素，改变list 的size。
A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？
这里用到了Object类的 wait() 和 notify() 方法。
当条件未满足时(list.size() !=5)，线程A调用wait() 放弃CPU，并进入阻塞状态。---不像②while轮询那样占用CPU
当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。
这种方式的一个好处就是CPU的利用率提高了。
但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。

import java.util.ArrayList;
import java.util.List;

public class MyList &#123;

    private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();

    public static void add() &#123;
        list.add(&quot;anyString&quot;);
    &#125;

    public static int size() &#123;
        return list.size();
    &#125;

&#125;

public class ThreadA extends Thread &#123;

    private Object lock;

    public ThreadA(Object lock) &#123;
        super();
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            synchronized (lock) &#123;
                if (MyList.size() != 5) &#123;
                    System.out.println(&quot;wait begin &quot;
                            + System.currentTimeMillis());
                    lock.wait();
                    System.out.println(&quot;wait end  &quot;
                            + System.currentTimeMillis());
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

public class ThreadB extends Thread &#123;
private Object lock;

    public ThreadB(Object lock) &#123;
        super();
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            synchronized (lock) &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    MyList.add();
                    if (MyList.size() == 5) &#123;
                        lock.notify();
                        System.out.println(&quot;已经发出了通知&quot;);
                    &#125;
                    System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;);
                    Thread.sleep(1000);
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

public class Run &#123;

    public static void main(String[] args) &#123;

        try &#123;
            Object lock = new Object();

            ThreadA a = new ThreadA(lock);
            a.start();

            Thread.sleep(50);

            ThreadB b = new ThreadB(lock);
            b.start();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

4、管道通信就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信
具体就不介绍了。分布式系统中说的两种通信机制：共享内存机制和消息通信机制。感觉前面的①中的synchronized关键字和②中的while轮询 “属于” 共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流。
而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。

线程死锁及解决办法
线程死锁及解决办法
一、什么是死锁？
所谓死锁： 是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁线程。 由于资源占用是互斥的，当某个线程提出申请资源后，使得有关线程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁.
关键点：
1\)两个以上的线程
2\)争夺共享的资源
3\)它们各自不释放手中资源，除非有外力协助
二、死锁例子：
public class TestDealLock implements Runnable&#123;

    /**
     * @param args
     */
    public static void main(String[] args) &#123;
        TestDealLock lock1=new TestDealLock();
        TestDealLock lock2=new TestDealLock();
        Thread thread1=new Thread(lock1);
        Thread thread2=new Thread(lock2);
        lock1.setFlag(0);
        lock2.setFlag(1);
        thread1.start();
        thread2.start();
    &#125;

    private static Object obj1=new Object();//一把A筷子的锁
    private static Object obj2=new Object();//一把B筷子的锁
    private int flag=0;

    public int getFlag() &#123;
        return flag;
    &#125;
    public void setFlag(int flag) &#123;
        this.flag = flag;
    &#125;
    public void eatMeat()&#123;
             synchronized (obj1) &#123;
                 System.out.println(Thread.currentThread().getName()+&quot;:拿到A筷子！&quot;);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (obj2) &#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:拿到B筷子！开始吃饭&quot;);
                &#125;
                &#125;
    &#125;
    public void eatVegetable()&#123;
             synchronized (obj2) &#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:拿到B筷子！&quot;);
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    
                    synchronized (obj1) &#123;
                        System.out.println(Thread.currentThread().getName()+&quot;:拿到A筷子！开始吃饭&quot;);
                    &#125;
                &#125;
    &#125;

    @Override
    public void run() &#123;
        if(flag==0)&#123;
            eatMeat();
        &#125;else&#123;
            eatVegetable();
        &#125;
    &#125;

&#125;

三、解决办法：
　　1)、让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y 的拥有者分别等待对方的资源的问题。

　　2)、将多个锁组成一组并放到同一个锁下。前面Java线程死锁的例子中，可以创建一个银器对象的锁。于是在获得刀或叉之前都必须获得这个银器的锁。

　　3)、将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得银器对象的锁时，就可以通过检查变量来判断是否整个银器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试。（没有实现）
实现1：
@Override
public void run() &#123;
/\*        if(flag==0)&#123;
eatMeat();
&#125;else&#123;
eatVegetable();
&#125;\*/
eatMeat();
&#125;
实现2、

/\*\*

*   然要探测或推敲各种情况是非常困难的，但只要按照下面几条规则去设计系统，就能够避免Java线程死锁问题：

　　一、让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y 的拥有者分别等待对方的资源的问题。

　　二、将多个锁组成一组并放到同一个锁下。前面Java线程死锁的例子中，可以创建一个银器对象的锁。于是在获得刀或叉之前都必须获得这个银器的锁。

　　三、将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得银器对象的锁时，就可以通过检查变量来判断是否整个银器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试。（没有实现）

*   @author abc
*

\*/
public class TestDealLock implements Runnable&#123;

    /**
     * @param args
     */
    public static void main(String[] args) &#123;
        TestDealLock lock1=new TestDealLock();
        TestDealLock lock2=new TestDealLock();
        Thread thread1=new Thread(lock1);
        Thread thread2=new Thread(lock2);
        lock1.setFlag(0);
        lock2.setFlag(1);
        thread1.start();
        thread2.start();
    &#125;

    private static Object obj1=new Object();//一把A筷子的锁
    private static Object obj2=new Object();//一把B筷子的锁
    private static Object obj3=new Object();//加一把锁，保证A锁和B锁锁上同一组，只有拿到此锁才能拿到A锁或者B锁
    private int flag=0;

    public int getFlag() &#123;
        return flag;
    &#125;
    public void setFlag(int flag) &#123;
        this.flag = flag;
    &#125;
    public void eatMeat()&#123;
        synchronized (obj3) &#123;
             synchronized (obj1) &#123;
                 System.out.println(Thread.currentThread().getName()+&quot;:拿到A筷子！&quot;);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (obj2) &#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:拿到B筷子！开始吃饭&quot;);
                &#125;
                &#125;
        &#125;
    &#125;
    public void eatVegetable()&#123;
        synchronized (obj3) &#123;
             synchronized (obj2) &#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:拿到B筷子！&quot;);
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    
                    synchronized (obj1) &#123;
                        System.out.println(Thread.currentThread().getName()+&quot;:拿到A筷子！开始吃饭&quot;);
                    &#125;
                &#125;
    //    &#125;
        &#125;
    &#125;

    @Override
    public void run() &#123;
        if(flag==0)&#123;
            eatMeat();
        &#125;else&#123;
            eatVegetable();
        &#125;
    &#125;

&#125;

线程锁之重入锁

重入锁：ReentrantLock 详解
在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的。除此之外，重入锁又自带一系列高逼格UBFF：可中断响应、锁申请等待限时、公平锁。另外可以结合Condition来使用，使其更是逼格满满。
先来盘花生米：
package somhu;

import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockTest implements Runnable&#123;
public static ReentrantLock lock = new ReentrantLock();
public static int i = 0;

    @Override
    public void run() &#123;
        for (int j = 0; j &lt; 10000; j++) &#123;
            lock.lock();  // 看这里就可以
            //lock.lock(); ①
            try &#123;
                i++;
            &#125; finally &#123;
                lock.unlock(); // 看这里就可以
                //lock.unlock();②
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        ReentrantLockTest test = new ReentrantLockTest();
        Thread t1 = new Thread(test);
        Thread t2 = new Thread(test);
        t1.start();t2.start();
        t1.join(); t2.join(); // main线程会等待t1和t2都运行完再执行以后的流程
        System.err.println(i);
    &#125;

&#125;
从上可以看出，使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对逻辑控制的灵活性远远大于synchronized关键字。同时，需要注意，有加锁就必须有释放锁，而且加锁与释放锁的分数要相同，这里就引出了“重”字的概念，如上边代码演示，放开①、②处的注释，与原来效果一致。
硬菜来了：
1、中断响应
对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。直接上代码，来演示使用重入锁如何解决死锁：
1
package somhu;

import java.util.concurrent.locks.ReentrantLock;

public class KillDeadlock implements Runnable&#123;
public static ReentrantLock lock1 = new ReentrantLock();
public static ReentrantLock lock2 = new ReentrantLock();
int lock;

    public KillDeadlock(int lock) &#123;
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            if (lock == 1) &#123;
                lock1.lockInterruptibly();  // 以可以响应中断的方式加锁
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;&#125;
                lock2.lockInterruptibly();
            &#125; else &#123;
                lock2.lockInterruptibly();  // 以可以响应中断的方式加锁
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;&#125;
                lock1.lockInterruptibly();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (lock1.isHeldByCurrentThread()) lock1.unlock();  // 注意判断方式
            if (lock2.isHeldByCurrentThread()) lock2.unlock();
            System.err.println(Thread.currentThread().getId() + &quot;退出！&quot;);
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        KillDeadlock deadLock1 = new KillDeadlock(1);
        KillDeadlock deadLock2 = new KillDeadlock(2);
        Thread t1 = new Thread(deadLock1);
        Thread t2 = new Thread(deadLock2);
        t1.start();t2.start();
        Thread.sleep(1000);
        t2.interrupt(); // ③
    &#125;

&#125;
t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了死锁。但是，在③处给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，正常执行完成。t2也会退出，但只是释放了资源并没有完成工作。
2、锁申请等待限时
可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。
前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。 
后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false。
上代码：
package somhu;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class TryLockTest implements Runnable&#123;
public static ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() &#123;
        try &#123;
            if (lock.tryLock(1, TimeUnit.SECONDS)) &#123; // 等待1秒
                Thread.sleep(2000);  //休眠2秒
            &#125; else &#123;
                System.err.println(Thread.currentThread().getName() + &quot;获取锁失败！&quot;);
            &#125;
        &#125; catch (Exception e) &#123;
            if (lock.isHeldByCurrentThread()) lock.unlock();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        TryLockTest test = new TryLockTest();
        Thread t1 = new Thread(test); t1.setName(&quot;线程1&quot;);
        Thread t2 = new Thread(test); t1.setName(&quot;线程2&quot;);
        t1.start();t2.start();
    &#125;

&#125;
/\*\*

*   运行结果:
*   线程2获取锁失败！
    \*/
    上述示例中，t1先获取到锁，并休眠2秒，这时t2开始等待，等待1秒后依然没有获取到锁，就不再继续等待，符合预期结果。
    3、公平锁
    所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：
    public ReentrantLock(boolean fair) &#123;
    sync = fair ? new FairSync() : new NonfairSync();
    &#125;
    上代码：
    package somhu;

import java.util.concurrent.locks.ReentrantLock;

public class FairLockTest implements Runnable&#123;
public static ReentrantLock lock = new ReentrantLock(true);

    @Override
    public void run() &#123;
        while (true) &#123;
            try &#123;
                lock.lock();
                System.err.println(Thread.currentThread().getName() + &quot;获取到了锁！&quot;);
            &#125; finally &#123;
                lock.unlock();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        FairLockTest test = new FairLockTest();
        Thread t1 = new Thread(test, &quot;线程1&quot;);
        Thread t2 = new Thread(test, &quot;线程2&quot;);
        t1.start();t2.start();
    &#125;

&#125;
/\*\*

*   运行结果:
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   ......（上边是截取的一段）
    \*/
    可以发现，t1和t2交替获取到锁。如果是非公平锁，会发生t1运行了许多遍后t2才开始运行的情况。
    ReentrantLock 配合 Conditond 使用
    配合关键字synchronized使用的方法如：await()、notify()、notifyAll()，同样配合ReentrantLock 使用的Conditon提供了以下方法：
    public interface Condition &#123;
    void await() throws InterruptedException; // 类似于Object.wait()
    void awaitUninterruptibly(); // 与await()相同，但不会再等待过程中响应中断
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    boolean awaitUntil(Date deadline) throws InterruptedException;
    void signal(); // 类似于Obejct.notify()
    void signalAll();
    &#125;
    ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象：
    public interface Lock &#123;
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
    &#125;
    上代码：
    package somhu;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockWithConditon implements Runnable&#123;
public static ReentrantLock lock = new ReentrantLock(true);
public static Condition condition = lock.newCondition();

    @Override
    public void run() &#123;
        lock.newCondition();
        try &#123;
            lock.lock();
            System.err.println(Thread.currentThread().getName() + &quot;-线程开始等待...&quot;);
            condition.await();
            System.err.println(Thread.currentThread().getName() + &quot;-线程继续进行了&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        ReentrantLockWithConditon test = new ReentrantLockWithConditon();
        Thread t = new Thread(test, &quot;线程ABC&quot;);
        t.start();
        Thread.sleep(1000);
        System.err.println(&quot;过了1秒后...&quot;);
        lock.lock();
        condition.signal(); // 调用该方法前需要获取到创建该对象的锁否则会产生
                            // java.lang.IllegalMonitorStateException异常
        lock.unlock();
    &#125;

&#125;
好了，到这里重入锁ReentrantLock的基本使用方法就介绍完成了！
</code></pre></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/1e7ca447b43e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/1e7ca447b43e.html" class="post-title-link" itemprop="url">分布式</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:04:09" itemprop="dateCreated datePublished" datetime="2023-12-20T15:04:09+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 11:47:26" itemprop="dateModified" datetime="2023-12-24T11:47:26+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="⾼并发原则"><a href="#⾼并发原则" class="headerlink" title="⾼并发原则"></a>⾼并发原则</h1><h4 id="⽆状态"><a href="#⽆状态" class="headerlink" title="⽆状态"></a>⽆状态</h4><ul><li>⽆状态应⽤，便于⽔平扩展</li><li>有状态配置可通过配置中⼼实现⽆状态</li><li>实践: Disconf、Yaconf、Zookpeer、Consul、Confd、Diamond、Xdiamond等</li></ul><h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><ul><li>系统维度：按照系统功能、业务拆分，如购物⻋，结算，订单等</li><li>功能维度：对系统功能在做细粒度拆分</li><li>读写维度：根据读写⽐例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表</li><li>AOP维度： 根据访问特征，按照AOP进⾏拆分，⽐如商品⻚可分为CDN、⻚⾯渲染系统，CDN就是⼀个AOP系统</li><li>模块维度：对整体代码结构划分Web、Service、DAO</li></ul><h4 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h4><ul><li>服务化演进: 进程内服务-单机远程服务-集群⼿动注册服务-⾃动注册和发现服务-服务的分组、隔离、路由-服务治理</li><li>考虑服务分组、隔离、限流、⿊⽩名单、超时、重试机制、路由、故障补偿等</li><li>实践：利⽤Nginx、HaProxy、LVS等实现负载均衡，ZooKeeper、Consul等实现⾃动注册和发现服</li></ul><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul><li>⽬的: 服务解耦(⼀对多消费)、异步处理、流量削峰缓冲等</li><li>⼤流量缓冲： 牺牲强⼀致性，保证最终⼀致性(案例：库存扣减，现在Redis中做扣减，记录扣减⽇志，通过后台进程将扣减⽇志应⽤到DB)</li><li>数据校对: 解决异步消息机制下消息丢失问题</li></ul><h4 id="数据异构"><a href="#数据异构" class="headerlink" title="数据异构"></a>数据异构</h4><ul><li>数据异构: 通过消息队列机制接收数据变更，原⼦化存储</li><li>数据闭环: 屏蔽多从数据来源，将数据异构存储，形成闭环</li></ul><h4 id="缓存银弹"><a href="#缓存银弹" class="headerlink" title="缓存银弹"></a>缓存银弹</h4><ul><li>⽤户层:<ul><li>DNS缓存</li><li>浏览器DNS缓存</li><li>操作系统DNS缓存</li><li>本地DNS服务商缓存</li><li>DNS服务器缓存</li><li>客户端缓存<ul><li>浏览器缓存(Expires、Cache-Control、Last-Modified、Etag)* App</li><li>客户缓存(js/css/image…)</li></ul></li></ul></li><li>代理层：<ul><li>CDN缓存(⼀般基于ATS、Varnish、Nginx、Squid等构建,边缘节点-⼆级节点-中⼼节点-源站)</li></ul></li><li>接⼊层：<ul><li>Nginx为例：<ul><li>Proxy_cache： 代理缓存,可以存储到/dev/shm或者SSD</li><li>FastCGI Cache</li><li>Nginx+Lua+Redis: 业务数据缓存</li></ul></li><li>PHP为例：<ul><li>Opcache： 缓存PHP的Opcodes</li></ul></li></ul></li><li>应⽤层：<ul><li>⻚⾯静态化</li><li>业务数据缓存(Redis/Memcached/本地⽂件等)</li><li>消息队列</li></ul></li><li>数据层：<ul><li>NoSQL： Redis、Memcache、SSDB等</li><li>MySQL： Innodb/MyISAM等Query Cache、Key Cache、Innodb</li><li>Buffer Size等</li></ul></li><li>系统层：<ul><li>CPU : L1/L2/L3 Cache/NUMA</li><li>内存</li><li>磁盘：磁盘本身缓存、dirty_ratio/dirty_background_ratio、阵列卡本身缓存</li><li>并发化</li></ul></li></ul><h1 id="⾼可⽤原则"><a href="#⾼可⽤原则" class="headerlink" title="⾼可⽤原则"></a>⾼可⽤原则</h1><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><ul><li>降级开关集中化管理：将开关配置信息推送到各个应⽤</li><li>可降级的多级读服务：如服务调⽤降级为只读本地缓存</li><li>开关前置化：如Nginx+lua(OpenResty)配置降级策略，引流流量；可基于此做灰度策略</li><li>业务降级：⾼并发下，保证核⼼功能，次要功能可由同步改为异步策略或屏蔽功能</li></ul><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul><li>⽬的: 防⽌恶意请求攻击或超出系统峰值</li><li>实践：<ul><li>恶意请求流量只访问到Cache</li><li>穿透后端应⽤的流量使⽤Nginx的limit处理</li><li>恶意IP使⽤Nginx Deny策略或者iptables拒绝</li></ul></li></ul><h4 id="切流量"><a href="#切流量" class="headerlink" title="切流量"></a>切流量</h4><ul><li>⽬的：屏蔽故障机器</li><li>实践:<ul><li>DNS: 更改域名解析⼊⼝，如DNSPOD可以添加备⽤IP，正常IP故障时，会⾃主切换到备⽤地址;⽣效实践较慢</li><li>HttpDNS: 为了绕过运营商LocalDNS实现的精准流量调度</li><li>LVS/HaProxy/Nginx: 摘除故障节点</li></ul></li></ul><h4 id="可回滚"><a href="#可回滚" class="headerlink" title="可回滚"></a>可回滚</h4><ul><li>发布版本失败时可随时快速回退到上⼀个稳定版本</li></ul><h1 id="业务设计原则"><a href="#业务设计原则" class="headerlink" title="业务设计原则"></a>业务设计原则</h1><ul><li>防重设计</li><li>幂等设计</li><li>流程定义</li><li>状态与状态机</li><li>后台系统操作可反馈</li><li>后台系统审批化</li><li>⽂档注释</li><li>备份</li></ul><h1 id="分布式与集群的区别"><a href="#分布式与集群的区别" class="headerlink" title="分布式与集群的区别"></a>分布式与集群的区别</h1><ul><li>分布式是指将不同的业务分布在不同的地⽅</li><li>⽽集群指的是将⼏台服务器集中在⼀起，实现同⼀业务</li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h4 id="⼆阶段提交"><a href="#⼆阶段提交" class="headerlink" title="⼆阶段提交"></a>⼆阶段提交</h4><ul><li>概念：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中⽌操作。</li><li>作⽤：主要保证了分布式事务的原⼦性；第⼀阶段为准备阶段，第⼆阶段为提交阶段；</li><li>缺点：不仅要锁住参与者的所有资源，⽽且要锁住协调者资源，开销⼤。⼀句话总结就是：2PC效率很低，对⾼并发很不友好。</li></ul><h4 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h4><ul><li>概念：三阶段提交协议在协调者和参与者中都引⼊超时机制，并且把两阶段提交协议的第⼀个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</li><li>缺点：如果进⼊PreCommit后，Coordinator发出的是abort请求，假设只有⼀个Cohort收到并进⾏了abort操作，⽽其他对于系统状态未知的Cohort会根据3PC选择继续Commit，此时系统状态发⽣不⼀致性。</li></ul><h4 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h4><ul><li>概念：所谓柔性事务是相对强制锁表的刚性事务⽽⾔。流程⼊下：服务器A的事务如果执⾏顺利，那么事务A就先⾏提交，如果事务B也执⾏顺利，则事务B也提交，整个事务就算完成。但是如果事务B执⾏失败，事务B本身回滚，这时事务A已经被提交，所以需要执⾏⼀个补偿操作，将已经提交的事务A执⾏的操作作反操作，恢复到未执⾏前事务A的状态。</li><li>缺点：业务侵⼊性太强，还要补偿操作，缺乏普遍性，没法⼤规模推⼴。</li></ul><h1 id="消息最终⼀致性解决⽅案之RabbitMQ实现："><a href="#消息最终⼀致性解决⽅案之RabbitMQ实现：" class="headerlink" title="消息最终⼀致性解决⽅案之RabbitMQ实现："></a>消息最终⼀致性解决⽅案之RabbitMQ实现：</h1><ul><li>实现：发送⽅确认+消息持久化+消费者确认。</li></ul><h1 id="什么时候⽤到分布式开发："><a href="#什么时候⽤到分布式开发：" class="headerlink" title="什么时候⽤到分布式开发："></a>什么时候⽤到分布式开发：</h1><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>模块解耦：把模块拆分,使⽤接⼝通信,降低模块之间的耦合度.</li><li>项⽬拆分，不同团队负责不同的⼦项⽬：把项⽬拆分成若⼲个⼦项⽬,不同的团队负责不同的⼦项⽬.</li><li>提⾼项⽬扩展性：增加功能时只需要再增加⼀个⼦项⽬,调⽤其他系统的接⼝就可以。</li><li>分布式部署：可以灵活的进⾏分布式部署.</li><li>提⾼代码的复⽤性：⽐如service层,如果不采⽤分布式rest服务⽅式架构就会在⼿机wap商城,信商城,pc,android，ios每个端都要写⼀个service层逻辑,开发量⼤,难以维护⼀起升级,这时候可以采⽤分布式rest服务⽅式,公⽤⼀个service层。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>系统之间的交互要使⽤远程通信,接⼝开发增⼤⼯作量；</li><li>⽹络请求有延时；</li><li>事务处理⽐较麻烦，需要使⽤分布式事务。</li></ul><h1 id="cdn（异地多活）"><a href="#cdn（异地多活）" class="headerlink" title="cdn（异地多活）"></a>cdn（异地多活）</h1><h4 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h4><ul><li>异地多活指分布在异地的多个站点同时对外提供服务的业务场景。异地多活是⾼可⽤架构设计的⼀种，与传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。</li><li>两地容灾切换⽅案：容灾是异地多活中最核⼼的⼀环， 以两个城市异地多活部署架构图为例，在两个城市（城市1位于华南1地域、城市2位于华东1地域）均部署⼀套完整的业务系统。下单业务按照“user_id”％ 100 进⾏分⽚，在正常情况下：<ul><li>[00~49]分⽚所有的读写都在城市1的数据库实例主库。</li><li>[50～99]分⽚所有的读写都在城市2的数据库实例主库。</li><li>“城市1的数据库实例主库”和 “城市2的数据库实例主库”建⽴DTS双向复制。</li><li>当出现异常时，需要进⾏容灾切换。可能出现的场景有以下4种：<ul><li>将第2种、第3种异常情况，全部采⽤第2种⽅案进⾏处理，那么不管是所有的APP Server异常、所有的数据库异常、整个城市异常，就直接按照城市级容灾⽅案处理，直接将APP Server、数据库切换到到另⼀个城市。</li></ul></li></ul></li></ul><h4 id="多城异地多活"><a href="#多城异地多活" class="headerlink" title="多城异地多活"></a>多城异地多活</h4><ul><li>多城市异地多活模式指的是3个或者3个以上城市间部署异地多活</li><li>该模式下存在中⼼节点和单元节点：<ul><li>中⼼节点：指单元节点的增量数据都需要实时的同步到中⼼节点，同时中⼼节点将所有分⽚的增量数据同步到其他单元节点。</li><li>单元节点：即对应分⽚读写的节点，该节点需要将该分⽚的增量同步到中⼼节点，并且接收来⾃于中⼼节点的其他分⽚的增量数据。</li></ul></li></ul><h1 id="分布式环境下宕机的处理⽅案"><a href="#分布式环境下宕机的处理⽅案" class="headerlink" title="分布式环境下宕机的处理⽅案"></a>分布式环境下宕机的处理⽅案</h1><ul><li>dubbo：服务器宕机，zk临时被删除；</li><li>springcloud：每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。</li><li>apm监控</li></ul><h1 id="分布式、高并发、多线程，到底有什么区别？"><a href="#分布式、高并发、多线程，到底有什么区别？" class="headerlink" title="分布式、高并发、多线程，到底有什么区别？"></a>分布式、高并发、多线程，到底有什么区别？</h1><ul><li>当提起这三个词的时候，是不是很多人都认为分布式=高并发=多线程？</li><li>在一开始接触的时候，不少人都会将三者混淆，误以为所谓的分布式高并发的系统就是能同时供海量用户访问，而采用多线程手段不就是可以提供系统的并发能力吗</li><li>实际上，他们三个总是相伴而生，但侧重点又有不同</li></ul><h4 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h4><ul><li>分布式更多的一个概念，是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段</li><li>该领域需要解决的问题极多，在不同的技术层面上，又包括：分布式文件系统、分布式缓存、分布式数据库、分布式计算等，一些名词如Hadoop、zookeeper、MQ等都跟分布式有关</li><li>从理念上讲，分布式的实现有两种形式：<ul><li>水平扩展：当一台机器扛不住流量时，就通过添加机器的方式，将流量平分到所有服务器上，所有机器都可以提供相当的服务；</li><li>垂直拆分：前端有多种查询需求时，一台机器扛不住，可以将不同的需求分发到不同的机器上，比如A机器处理余票查询的请求，B机器处理支付的请求。</li></ul></li></ul><h4 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h4><ul><li>相对于分布式来讲，高并发在解决的问题上会集中一些，其反应的是同时有多少量：比如在线直播服务，同时有上万人观看</li><li>高并发可以通过分布式技术去解决，将并发流量分不到不同的物理服务器上</li><li>但除此之外，还可以有很多其他优化手段：比如使用缓存系统，将所有的，静态内容放到CDN等；还可以使用多线程技术将一台服务器的服务能力最大化。</li></ul><h4 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h4><ul><li>多线程是指从软件或者硬件上实现多个线程并发执行的技术</li><li>它更多的是解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行（实际是交替运行的）</li><li>多线程解决的问题是最明确的，手段也是比较单一的，基本上遇到的最大问题就是线程安全</li><li>在JAVA语言中，需要对JVM内存模型、指令重排等深入了解，才能写出一份高质量的多线程代码。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>分布式是从物理资源的角度去将不同的机器组成一个整体对外服务，技术范围非常广且难度非常大，有了这个基础，高并发、高吞吐等系统很容易构建；</li><li>高并发是从业务角度去描述系统的能力，实现高并发的手段可以采用分布式，也可以采用诸如缓存、CDN等，当然也包括多线程；</li><li>多线程则聚焦于如何使用编程语言将CPU调度能力最大化</li></ul><h1 id="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"><a href="#分布式服务接口的幂等性如何设计（比如不能重复扣款）？" class="headerlink" title="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"></a>分布式服务接口的幂等性如何设计（比如不能重复扣款）？</h1><ul><li>这个不是技术问题，这个没有通用的一个方法，这个应该结合业务来保证幂等性。</li><li>所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</li><li>其实保证幂等性主要是三点：<ul><li>对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单id，一个订单 id 最多支付一次。</li><li>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql中记录个状态，比如支付之前记录一条这个订单的支付流水。</li><li>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。</li></ul></li><li>实际运作过程中，你要结合自己的业务来，比如说利用 redis，用 orderId作为唯一键</li><li>只有成功插入这个支付流水，才可以执行实际的支付扣款。</li><li>要求是支付一个订单，必须插入一条支付流水，<code>order_id</code> 建一个唯一键unique key。你在支付一个订单之前，先插入一条支付流水，<code>order_id</code>就已经进去了。你就可以写一个标识到 redis 里面去，<code>set order_id payed</code>，下一次重复请求过来了，先查 redis 的 order_id 对应的 value，如果是payed就说明已经支付过了，你就别重复支付了。</li></ul><h1 id="分布式事务了解吗？你们是如何解决分布式事务问题的？"><a href="#分布式事务了解吗？你们是如何解决分布式事务问题的？" class="headerlink" title="分布式事务了解吗？你们是如何解决分布式事务问题的？"></a>分布式事务了解吗？你们是如何解决分布式事务问题的？</h1><ul><li>分布式事务的实现主要有以下 5 种方案：</li><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h4 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案/XA方案"></a>两阶段提交方案/XA方案</h4><ul><li>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</li><li>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。</li><li>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</li><li>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</li><li>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</li><li>distributed-transacion-XA</li></ul><h4 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h4><ul><li>TCC 的全称是：Try、Confirm、Cancel。<ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。</li><li>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul></li><li>这种方案说实话几乎很少人使用，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大。</li><li>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</li><li>而且最好是你的各个业务执行的时间都比较短。</li><li>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</li><li>distributed-transacion-TCC</li></ul><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><ul><li>本地消息表其实是国外的 ebay 搞出来的这么一套思想。这个大概意思是这样的：<ul><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B那边成功为止。</li></ul></li><li>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</li><li>distributed-transaction-local-message-table</li></ul><h4 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h4><ul><li>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ就支持消息事务。大概的意思就是：<ul><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li></ul></li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用RocketMQ支持的，要不你就自己基于类似ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li><li>distributed-transaction-reliable-message</li></ul><h4 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h4><ul><li>这个方案的大致意思就是：<ul><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ul></li></ul><h4 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h4><ul><li>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性</li><li>然后其他的一些场景基于阿里的 RocketMQ 来实现了分布式事务。</li><li>找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案</li><li>如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/52555cb3db5d.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/52555cb3db5d.html" class="post-title-link" itemprop="url">Docker</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 14:12:50 / 修改时间：15:02:23" itemprop="dateCreated datePublished" datetime="2023-12-20T14:12:50+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">容器</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AE%B9%E5%99%A8/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h1><ul><li>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</li><li>容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</li><li>容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li><li>容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</li></ul><h1 id="物理机、虚拟机与容器"><a href="#物理机、虚拟机与容器" class="headerlink" title="物理机、虚拟机与容器"></a>物理机、虚拟机与容器</h1><ul><li>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的</li><li>虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统</li><li>因此容器的隔离级别会稍低一些。</li></ul><h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><ul><li>Docker是世界领先的软件容器平台。</li><li>Docker使用Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li><li>由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器</li><li>Docke最初实现是基于LXC。</li><li>Docker能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</li><li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li></ul><h1 id="Docker思想"><a href="#Docker思想" class="headerlink" title="Docker思想"></a>Docker思想</h1><ul><li>集装箱</li><li>标准化： ①运输方式、②存储方式、 ③API接口</li><li>隔离</li></ul><h1 id="Docker容器的特点"><a href="#Docker容器的特点" class="headerlink" title="Docker容器的特点"></a>Docker容器的特点</h1><ul><li>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li><li>标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</li><li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li></ul><h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><ul><li>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境</li><li>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</li><li>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</li><li>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</li><li>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</li><li>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</li></ul><h1 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h1><ul><li>简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</li><li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</li><li>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。</li><li>虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。</li></ul><h1 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h1><ul><li>Docker包括三个基本概念：<ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul></li></ul><h4 id="镜像（Image）——一个特殊的文件系统"><a href="#镜像（Image）——一个特殊的文件系统" class="headerlink" title="镜像（Image）——一个特殊的文件系统"></a>镜像（Image）——一个特殊的文件系统</h4><ul><li>操作系统分为内核和用户空间</li><li>对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持</li><li>而Docker镜像（Image），就相当于是一个root文件系统。</li><li>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</li><li>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li><li>Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。</li><li>镜像实际是由多层文件系统联合组成。</li><li>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</li><li>分层存储的特征还使得镜像的复用、定制变的更为容易</li><li>甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</li></ul><h4 id="容器（Container）——镜像运行时的实体"><a href="#容器（Container）——镜像运行时的实体" class="headerlink" title="容器（Container）——镜像运行时的实体"></a>容器（Container）——镜像运行时的实体</h4><ul><li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</li><li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</li><li>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</li><li>按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li></ul><h4 id="仓库（Repository）——集中存放镜像文件的地方"><a href="#仓库（Repository）——集中存放镜像文件的地方" class="headerlink" title="仓库（Repository）——集中存放镜像文件的地方"></a>仓库（Repository）——集中存放镜像文件的地方</h4><ul><li>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</li><li>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</li><li>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。</li><li>这里补充一下Docker Registry公开服务和私有Docker Registry的概念：<ul><li>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub，这也是默认的Registry，并拥有大量的高质量的官方镜像。</li><li>除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</li></ul></li></ul><h1 id="Build，Ship，and-Run"><a href="#Build，Ship，and-Run" class="headerlink" title="Build，Ship，and Run"></a>Build，Ship，and Run</h1><ul><li>Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。</li><li>Ship（运输镜像）：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li>Run （运行镜像）：运行的镜像就是一个容器，容器就是运行程序的地方。</li><li>Docker运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/5352a96111d6.html" class="post-title-link" itemprop="url">Java基础</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-23 22:23:43" itemprop="dateModified" datetime="2023-12-23T22:23:43+08:00">2023-12-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="获得Class对象的⽅式"><a href="#获得Class对象的⽅式" class="headerlink" title="获得Class对象的⽅式"></a>获得Class对象的⽅式</h1><ul><li>静态类的.class语法：GuideUtil.class</li><li>普通类对象的getClass()⽅法：new Test().getClass()</li><li>通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”);</li><li>对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><a class="page-number" href="/default-index/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/4/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>