<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"defalut"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/5/index.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/5/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/5/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/52555cb3db5d.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/52555cb3db5d.html" class="post-title-link" itemprop="url">Docker</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 14:12:50" itemprop="dateCreated datePublished" datetime="2023-12-20T14:12:50+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 00:47:34" itemprop="dateModified" datetime="2024-01-04T00:47:34+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">容器</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AE%B9%E5%99%A8/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h1><ul><li>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</li><li>容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</li><li>容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li><li>容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</li></ul><h1 id="物理机、虚拟机与容器"><a href="#物理机、虚拟机与容器" class="headerlink" title="物理机、虚拟机与容器"></a>物理机、虚拟机与容器</h1><ul><li>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的</li><li>虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统</li><li>因此容器的隔离级别会稍低一些。</li></ul><h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><ul><li>Docker是世界领先的软件容器平台。</li><li>Docker使用Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li><li>由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器</li><li>Docke最初实现是基于LXC。</li><li>Docker能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</li><li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li></ul><h1 id="Docker思想"><a href="#Docker思想" class="headerlink" title="Docker思想"></a>Docker思想</h1><ul><li>集装箱</li><li>标准化： ①运输方式、②存储方式、 ③API接口</li><li>隔离</li></ul><h1 id="Docker容器的特点"><a href="#Docker容器的特点" class="headerlink" title="Docker容器的特点"></a>Docker容器的特点</h1><ul><li>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li><li>标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</li><li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li></ul><h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><ul><li>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境</li><li>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</li><li>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</li><li>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</li><li>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</li><li>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</li></ul><h1 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h1><ul><li>简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</li><li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</li><li>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。</li><li>虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。</li></ul><h1 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h1><ul><li>Docker包括三个基本概念：<ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul></li></ul><h4 id="镜像（Image）——一个特殊的文件系统"><a href="#镜像（Image）——一个特殊的文件系统" class="headerlink" title="镜像（Image）——一个特殊的文件系统"></a>镜像（Image）——一个特殊的文件系统</h4><ul><li>操作系统分为内核和用户空间</li><li>对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持</li><li>而Docker镜像（Image），就相当于是一个root文件系统。</li><li>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</li><li>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li><li>Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。</li><li>镜像实际是由多层文件系统联合组成。</li><li>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</li><li>分层存储的特征还使得镜像的复用、定制变的更为容易</li><li>甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</li></ul><h4 id="容器（Container）——镜像运行时的实体"><a href="#容器（Container）——镜像运行时的实体" class="headerlink" title="容器（Container）——镜像运行时的实体"></a>容器（Container）——镜像运行时的实体</h4><ul><li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</li><li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</li><li>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</li><li>按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</li></ul><h4 id="仓库（Repository）——集中存放镜像文件的地方"><a href="#仓库（Repository）——集中存放镜像文件的地方" class="headerlink" title="仓库（Repository）——集中存放镜像文件的地方"></a>仓库（Repository）——集中存放镜像文件的地方</h4><ul><li>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</li><li>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</li><li>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。</li><li>这里补充一下Docker Registry公开服务和私有Docker Registry的概念：<ul><li>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。最常使用的Registry公开服务是官方的Docker Hub，这也是默认的Registry，并拥有大量的高质量的官方镜像。</li><li>除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</li></ul></li></ul><h1 id="Build，Ship，and-Run"><a href="#Build，Ship，and-Run" class="headerlink" title="Build，Ship，and Run"></a>Build，Ship，and Run</h1><ul><li>Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。</li><li>Ship（运输镜像）：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li>Run （运行镜像）：运行的镜像就是一个容器，容器就是运行程序的地方。</li><li>Docker运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。</li></ul><h1 id="Docker-的目的是什么？"><a href="#Docker-的目的是什么？" class="headerlink" title="Docker 的目的是什么？"></a>Docker 的目的是什么？</h1><ul><li>Docker 提供了一个可用于托管任何应用程序的容器环境。在此，软件应用程序和支持它的依赖项紧密打包在一起。</li><li>因此，这个打包的产品被称为 Container，因为它是由 Docker 完成的，所以它被称为 Docker 容器！</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/22829df8f04f.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/22829df8f04f.html" class="post-title-link" itemprop="url">Java基础</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-08 18:44:17" itemprop="dateModified" datetime="2024-01-08T18:44:17+08:00">2024-01-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>47k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>43 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="获得Class对象的⽅式"><a href="#获得Class对象的⽅式" class="headerlink" title="获得Class对象的⽅式"></a>获得Class对象的⽅式</h1><ul><li>静态类的.class语法：GuideUtil.class</li><li>普通类对象的getClass()⽅法：new Test().getClass()</li><li>通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”);</li><li>对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE</li></ul><h1 id="在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>在 Java 中，为什么不允许从静态方法中访问非静态变量？</h1><ul><li>因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联</li></ul><h1 id="在-Java-中，什么时候用重载，什么时候用重写？"><a href="#在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="在 Java 中，什么时候用重载，什么时候用重写？"></a>在 Java 中，什么时候用重载，什么时候用重写？</h1><ul><li>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding）</li><li>而重载（overloading）是用不同的输入做同一件事</li><li>在 Java 中，重载的方法签名不同，而重写并不是。</li></ul><h1 id="举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>举例说明什么情况下会更倾向于使用抽象类而不是接口？</h1><ul><li>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求</li><li>在 Java 中，你只能继承一个类，但可以实现多个接口</li><li>所以一旦你继承了一个类，你就失去了继承其他类的机会了。</li><li>接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable(注：这里的意思是指如果把 Runnable 等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</li><li>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</li><li>如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择</li><li>有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</li></ul><h1 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h1><ul><li>调用该访问返回一个以字符串指定类名的类的对象。</li></ul><h1 id="Jdo是什么"><a href="#Jdo是什么" class="headerlink" title="Jdo是什么?"></a>Jdo是什么?</h1><ul><li>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API</li><li>JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）</li><li>这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上</li><li>另外，JDO很灵活，因为它可以在任何数据底层上运行</li><li>JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。</li></ul><h1 id="HashMap-，HashTable-区别"><a href="#HashMap-，HashTable-区别" class="headerlink" title="HashMap ，HashTable 区别"></a>HashMap ，HashTable 区别</h1><ul><li>默认容量不同。扩容不同</li><li>线程安全性，HashTable 安全</li><li>效率不同 HashTable 要慢因为加锁</li></ul><h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul><li>数组 + 链表方式存储</li><li>默认容量：11(质数 为宜)</li><li>put:<ul><li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li><li>若在链表中找到了，则替换旧值，若未找到则继续</li><li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li><li>将新元素加到链表头部</li><li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。</li></ul></li></ul><h1 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h1><ul><li>默认的负载因子大小为0.75</li><li>也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组来重新调整map的大小，并将原来的对象放入新的bucket数组中。</li><li>这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</li></ul><h1 id="EJB与JavaBean的区别？"><a href="#EJB与JavaBean的区别？" class="headerlink" title="EJB与JavaBean的区别？"></a>EJB与JavaBean的区别？</h1><ul><li>Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于JavaBean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器。另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。</li><li>Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。</li></ul><h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</li><li>下面列出了使用封装的一些好处：<ul><li>通过隐藏对象的属性来保护对象内部的状态。</li><li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li><li>禁止对象之间的不良交互提高模块化</li></ul></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</li></ul><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul><li>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</li></ul><h1 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h1><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul><li>修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>在异常处理时提供 finally 块来执行任何清除操作</li><li>如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ul><li>方法名</li><li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</li><li>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h4 id="override（重写）"><a href="#override（重写）" class="headerlink" title="override（重写）"></a>override（重写）</h4><ul><li>方法名、参数、返回值相同。</li><li>子类方法不能缩小父类方法的访问权限。</li><li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li><li>存在于父类和子类之间。</li><li>方法被定义为final不能被重写。</li></ul><h4 id="overload（重载）"><a href="#overload（重载）" class="headerlink" title="overload（重载）"></a>overload（重载）</h4><ul><li>参数类型、个数、顺序至少有一个不相同。</li><li>不能重载只有返回值不同的方法名。</li><li>存在于父类和子类、同类中。</li></ul><h1 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h1><ul><li>接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。</li><li>还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。</li></ul><h1 id="Java1-7与1-8-1-9-10-新特性"><a href="#Java1-7与1-8-1-9-10-新特性" class="headerlink" title="Java1.7与1.8,1.9,10 新特性"></a>Java1.7与1.8,1.9,10 新特性</h1><h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4><ul><li>switch中可以使用字串了</li><li>运用List tempList &#x3D; new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断</li><li>语法上支持集合，而不一定是数组</li><li>新增一些取环境信息的工具方法</li><li>Boolean类型反转，空指针安全,参与位运算</li><li>两个char间的equals</li><li>安全的加减乘除</li><li>map集合支持并发请求，且可以写成 Map map &#x3D; {name:”xxx”,age:18};</li></ul><h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><ul><li>允许在接口中有默认方法实现</li><li>Lambda表达式</li><li>函数式接口</li><li>方法和构造函数引用</li><li>Lambda的范围</li><li>内置函数式接口</li><li>Streams</li><li>Parallel Streams</li><li>Map</li><li>时间日期API</li><li>Annotations</li></ul><h4 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h4><ul><li>Jigsaw 项目;模块化源码</li><li>简化进程API</li><li>轻量级 JSON API</li><li>钱和货币的API</li><li>改善锁争用机制</li><li>代码分段缓存</li><li>智能Java编译, 第二阶段</li><li>HTTP 2.0客户端</li><li>Kulla计划: Java的REPL实现</li></ul><h1 id="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"><a href="#解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI" class="headerlink" title="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"></a>解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI</h1><ul><li>web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。</li><li>EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。</li><li>JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</li><li>JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</li><li>JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</li><li>JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</li><li>RMI&#x2F;IIOP:（Remote Method Invocation &#x2F;internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。</li></ul><h1 id="Class类的作用？生成Class对象的方法有哪些？"><a href="#Class类的作用？生成Class对象的方法有哪些？" class="headerlink" title="Class类的作用？生成Class对象的方法有哪些？"></a>Class类的作用？生成Class对象的方法有哪些？</h1><ul><li>Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类</li><li>Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口</li><li>方法示例<ul><li>getClass()</li><li>getSuperClass()</li><li>.class</li><li>.TYPE</li></ul></li></ul><h1 id="序列化的定义、实现和注意事项"><a href="#序列化的定义、实现和注意事项" class="headerlink" title="序列化的定义、实现和注意事项"></a>序列化的定义、实现和注意事项</h1><ul><li>想把一个对象写在硬盘上或者网络上，对其进行序列化，把他序列化成为一个字节流。</li><li>实现和注意事项：<ul><li>实现接口Serializable Serializable接口中没有任何的方法，实现该接口的类不需要实现额外的方法。</li><li>如果对象中的某个属性是对象类型，必须也实现Serializable接口才可以，序列化对静态变量无效</li><li>如果不希望某个属性参与序列化，不是将其static，而是transient</li></ul></li><li>串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存</li><li>序列化版本不兼容</li></ul><h1 id="java-sql-Date和java-util-Date的联系和区别"><a href="#java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="java.sql.Date和java.util.Date的联系和区别"></a>java.sql.Date和java.util.Date的联系和区别</h1><ul><li>java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</li><li>JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002&#x2F;05&#x2F;22 5:00:57 PM的字段，读取日期时得到的是2002&#x2F;05&#x2F;22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.sql.Timestamp类比java.util.Date类精确度要高。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用…</li><li>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。</li></ul><h1 id="String-s-new-String-“xyz”-创建几个String-Object"><a href="#String-s-new-String-“xyz”-创建几个String-Object" class="headerlink" title="String s &#x3D; new String(“xyz”);创建几个String Object?"></a>String s &#x3D; new String(“xyz”);创建几个String Object?</h1><ul><li>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个</li><li>New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象</li><li>如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</li></ul><h1 id="String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？"><a href="#String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？" class="headerlink" title="String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？"></a>String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？</h1><ul><li>没有改变。</li><li>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</li></ul><h1 id="基本数据类型有哪些"><a href="#基本数据类型有哪些" class="headerlink" title="基本数据类型有哪些"></a>基本数据类型有哪些</h1><ul><li>byte、short、char、int、long、float、double、boolean</li></ul><h1 id="String、StringBuffer、StringBuilder区别与联系"><a href="#String、StringBuffer、StringBuilder区别与联系" class="headerlink" title="String、StringBuffer、StringBuilder区别与联系"></a>String、StringBuffer、StringBuilder区别与联系</h1><ul><li>String类是字符序列不可变的类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。</li><li>StringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setChartAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String</li><li>JDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder</li></ul><h1 id="String类为什么是final的"><a href="#String类为什么是final的" class="headerlink" title="String类为什么是final的"></a>String类为什么是final的</h1><ul><li>为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。</li><li>为了安全。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的， 和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的， 这不就成了核心病毒了么？</li><li>不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性， 如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点；</li></ul><h1 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h1><ul><li>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</li><li>int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</li><li>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</li><li>Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</li></ul><h1 id="异常处理中throws和throw的区别"><a href="#异常处理中throws和throw的区别" class="headerlink" title="异常处理中throws和throw的区别"></a>异常处理中throws和throw的区别</h1><ul><li>作用不同：<ul><li>throw用于程序员自行产生并抛出异常；</li><li>throws用于声明在该方法内抛出了异常</li></ul></li><li>使用的位置不同：<ul><li>throw位于方法体内部，可以作为单独语句使用；</li><li>throws必须跟在方法参数列表的后面，不能单独使用。</li></ul></li><li>内容不同：<ul><li>throw抛出一个异常对象，且只能是一个；</li><li>throws后面跟异常类，而且可以有多个。</li></ul></li></ul><h1 id="Java异常处理try-catch-finally的执行过程"><a href="#Java异常处理try-catch-finally的执行过程" class="headerlink" title="Java异常处理try-catch-finally的执行过程"></a>Java异常处理try-catch-finally的执行过程</h1><ul><li>try-catch-finally程序块的执行流程以及执行结果比较复杂。</li><li>基本执行过程如下：<ul><li>程序首先执行可能发生异常的try语句块。</li><li>如果try语句没有出现异常则执行完后跳至finally语句块执行；</li><li>如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。</li><li>catch语句块可以有多个，分别捕获不同类型的异常。</li><li>catch语句块执行完后程序会继续执行finally语句块。</li></ul></li><li>finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。需要注意的是即使try和catch块中存在return语句，finally语句也会执行，是在执行完finally语句后再通过return退出。</li></ul><h1 id="运行时异常与受检异常有何异同"><a href="#运行时异常与受检异常有何异同" class="headerlink" title="运行时异常与受检异常有何异同"></a>运行时异常与受检异常有何异同</h1><ul><li>运行时异常：包括RuntimeaException及其所有子类。不要求程序必须对它们作出处理，比如InputMismatchException、ArithmeticException、NullPointerException等。即使没有显示使用try-catch或throws进行处理，仍旧可以进行编译和运行(其实是JVM隐式的使用try-catch或throws进行处理)。如果运行时发生异常，会输出异常的堆栈信息并中止程序执行。</li><li>Checked异常（非运行时异常）：除了运行时异常外的其他异常类都是Checked异常，程序必须捕获或者声明抛出这种异常，否则出现编译错误，无法通过编译。处理方式包括两种：通过try-catch捕获异常，通过throws声明抛出异常从而交给上一级调用方法处理。</li></ul><h1 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h1><ul><li>Error类，表示仅靠程序本身无法恢复的严重错误，比如说内存溢出、动态链接异常、虚拟机错误。应用程序不应该抛出这种类型的对象。假如出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。所以在进行程序设计时，应该更关注Exception类。</li><li>Exception类，由Java应用程序抛出和处理的非严重错误，比如所需文件没有找到、零作除数，数组下标越界等。它的各种不同子类分别对应不同类型异常。可分为两类：Checked异常和Runtime异常</li></ul><h1 id="和equals的区别和联系"><a href="#和equals的区别和联系" class="headerlink" title="&#x3D;&#x3D;和equals的区别和联系"></a>&#x3D;&#x3D;和equals的区别和联系</h1><ul><li>“&#x3D;&#x3D;”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</li><li>“&#x3D;&#x3D;”使用情况如下：<ul><li>基本类型，比较的是值</li><li>引用类型，比较的是地址</li><li>不能比较没有父子关系的两个对象</li></ul></li><li>equals()方法使用如下：<ul><li>系统类一般已经覆盖了equals()，比较的是内容。</li><li>用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this &#x3D;&#x3D; obj);）</li><li>用户自定义类需要覆盖父类的equals()</li></ul></li><li>注意：Object的&#x3D;&#x3D;和equals比较的都是地址，作用相同</li></ul><h1 id="继承条件下构造方法的执行过程"><a href="#继承条件下构造方法的执行过程" class="headerlink" title="继承条件下构造方法的执行过程"></a>继承条件下构造方法的执行过程</h1><ul><li>继承条件下构造方法的调用规则如下：<ul><li>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</li><li>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li><li>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</li></ul></li><li>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li></ul><h1 id="权限修饰符的区别"><a href="#权限修饰符的区别" class="headerlink" title="权限修饰符的区别"></a>权限修饰符的区别</h1><ul><li>类的访问权限只有两种<ul><li>public 公共的 可被同一项目中所有的类访问。 (必须与文件名同名)</li><li>default 默认的 可被同一个包中的类访问。</li></ul></li><li>成员（成员变量或成员方法）访问权限共有四种：<ul><li>public 公共的 可以被项目中所有的类访问。(项目可见性)</li><li>protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）</li><li>default 默认的被这个类本身访问；被同一个包中的类访问。（包可见性）</li><li>private 私有的只能被这个类本身访问。（类可见性）</li></ul></li></ul><h1 id="final和abstract关键字的作用"><a href="#final和abstract关键字的作用" class="headerlink" title="final和abstract关键字的作用"></a>final和abstract关键字的作用</h1><ul><li>final和abstract是功能相反的两个关键字，可以对比记忆</li><li>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</li><li>final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</li><li>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li></ul><h1 id="static关键字的作用（修饰变量、方法、代码块）"><a href="#static关键字的作用（修饰变量、方法、代码块）" class="headerlink" title="static关键字的作用（修饰变量、方法、代码块）"></a>static关键字的作用（修饰变量、方法、代码块）</h1><ul><li>static可以修饰变量、方法、代码块和内部类</li><li>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</li><li>static变量和非static变量的区别(都是成员变量，不是局部变量)<ul><li>在内存中份数不同<ul><li>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</li><li>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</li></ul></li><li>在内存中存放的位置不同<ul><li>静态变量存在方法区中，实例变量存在堆内存中</li></ul></li><li>访问的方式不同<ul><li>实例变量： 对象名.变量名 stu1.name&#x3D;”小明明”;</li><li>静态变量：对象名.变量名 stu1.schoolName&#x3D;”西二旗小学”; 不推荐如此使用</li><li>类名.变量名 Student.schoolName&#x3D;”东三旗小学”; 推荐使用</li></ul></li><li>在内存中分配空间的时间不同<ul><li>实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候</li><li>Student.schoolName&#x3D;”东三旗小学”;或者Student stu1 &#x3D; new Student(“小明”,”男”,20,98);</li><li>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</li><li>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</li><li>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员</li></ul></li></ul></li></ul><h1 id="this和super关键字的作用"><a href="#this和super关键字的作用" class="headerlink" title="this和super关键字的作用"></a>this和super关键字的作用</h1><ul><li>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题</li><li>this可以调用成员变量，不能调用局部变量</li><li>this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句，而且在静态方法当中不允许出现this关键字。</li><li>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</li><li>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</li></ul><h1 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h1><ul><li>面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li><li>封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</li><li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</li></ul><h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><ul><li>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</li><li>类和对象好比图纸和实物的关系，模具和铸件的关系。</li></ul><h1 id="可变参数的作用和特点"><a href="#可变参数的作用和特点" class="headerlink" title="可变参数的作用和特点"></a>可变参数的作用和特点</h1><ul><li>可变参数<ul><li>可变参数的形式 …</li><li>可变参数只能是方法的形参</li><li>可变参数对应的实参可以0,1,2…..个，也可以是一个数组</li><li>在可变参数的方法中，将可变参数当做数组来处理</li><li>可变参数最多有一个，只能是最后一个</li><li>可变参数好处：方便 简单 减少重载方法的数量</li><li>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</li></ul></li><li>数组做形参和可变参数做形参联系和区别</li><li>联系：<br>-实参都可以是数组；2.方法体中，可变参数当做数组来处理</li><li>区别：<ul><li>个数不同	可变参数只能有一个数组参数可以多个</li><li>位置不同	可变参数只能是最后一个	数组参数位置任意</li><li>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</li></ul></li></ul><h1 id="递归的定义和优缺点"><a href="#递归的定义和优缺点" class="headerlink" title="递归的定义和优缺点"></a>递归的定义和优缺点</h1><ul><li>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</li><li>递归算法解决问题的特点：<ul><li>递归就是在过程或函数里调用自身。</li><li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li><li>递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</li><li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</li></ul></li></ul><h1 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h1><ul><li>break: 结束当前循环并退出当前循环体。</li><li>break还可以退出switch语句</li><li>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。</li></ul><h1 id="while和do-while循环的区别"><a href="#while和do-while循环的区别" class="headerlink" title="while和do-while循环的区别"></a>while和do-while循环的区别</h1><ul><li>while先判断后执行，第一次判断为false,循环体一次都不执行</li><li>do while先执行 后判断，最少执行1次。</li><li>如果while循环第一次判断为true, 则两种循环没有区别。</li></ul><h1 id="用最有效率的方法算出2乘以8等于多少"><a href="#用最有效率的方法算出2乘以8等于多少" class="headerlink" title="用最有效率的方法算出2乘以8等于多少"></a>用最有效率的方法算出2乘以8等于多少</h1><ul><li>使用位运算来实现效率最高</li><li>位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数</li><li>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高</li><li>所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</li></ul><h1 id="和-的区别和联系，-和-的区别和联系"><a href="#和-的区别和联系，-和-的区别和联系" class="headerlink" title="&amp;和&amp;&amp;的区别和联系，|和||的区别和联系"></a>&amp;和&amp;&amp;的区别和联系，|和||的区别和联系</h1><ul><li>&amp;和&amp;&amp;的联系(共同点)：<ul><li>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</li><li>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</li><li>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</li><li>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li><li>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li><li>表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</li></ul></li><li>&amp;和&amp;&amp;的区别(不同点)<ul><li>&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。</li><li>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</li><li>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</li><li>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</li><li>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</li></ul></li><li>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</li></ul><h1 id="i-和-i的异同之处"><a href="#i-和-i的异同之处" class="headerlink" title="i++和++i的异同之处"></a>i++和++i的异同之处</h1><ul><li>共同点：<ul><li>i++和++i都是变量自增1，都等价于i&#x3D;i+1</li><li>如果i++,++i是一条单独的语句，两者没有任何区别</li><li>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</li></ul></li><li>不同点：<ul><li>如果i++,++i不是一条单独的语句，他们就有区别</li><li>i++ ：先运算后增1。如：int x&#x3D;5;</li><li>int y&#x3D;x++;</li><li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li><li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;5++i ： 先增1后运算。如：</li><li>int x&#x3D;5;</li><li>int y&#x3D;++x;</li><li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li><li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;6334.</li></ul></li></ul><h1 id="JDK-JRE-JVM三者关系概括如下："><a href="#JDK-JRE-JVM三者关系概括如下：" class="headerlink" title="JDK,JRE,JVM三者关系概括如下："></a>JDK,JRE,JVM三者关系概括如下：</h1><ul><li>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE</li><li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了</li><li>JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li></ul><h1 id="Java跨平台原理"><a href="#Java跨平台原理" class="headerlink" title="Java跨平台原理"></a>Java跨平台原理</h1><ul><li>C&#x2F;C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</li><li>Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</li><li>字节码文件不面向任何具体平台，只面向虚拟机。</li><li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li><li>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C&#x2F;C++要低。</li><li>Java的跨平台原理决定了其性能没有C&#x2F;C++高</li></ul><h1 id="Java的安全性"><a href="#Java的安全性" class="headerlink" title="Java的安全性"></a>Java的安全性</h1><ul><li>语言层次的安全性主要体现在：<ul><li>Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</li><li>垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。</li><li>异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</li><li>强制类型转换：只有在满足强制转换规则的情况下才能强转成功。</li></ul></li><li>底层的安全性可以从以下方面来说明<ul><li>Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。</li></ul></li><li>在运行环境提供了四级安全性保障机制：<ul><li>字节码校验器 -类装载器 -运行时内存布局 -文件访问限制</li></ul></li></ul><h1 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h1><ul><li>对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术</li><li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（可以用XML或者是注解），将Java程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</li></ul><h1 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h1><ul><li>DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作</li><li>为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中</li><li>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法</li><li>在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储</li><li>DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</li></ul><h1 id="UML是什么？UML中有哪些图？"><a href="#UML是什么？UML中有哪些图？" class="headerlink" title="UML是什么？UML中有哪些图？"></a>UML是什么？UML中有哪些图？</h1><ul><li>UML是统一建模语言（Unified Modeling Language）的缩写，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为</li><li>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等</li><li>在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</li></ul><h1 id="Java-中有几种类型的流？"><a href="#Java-中有几种类型的流？" class="headerlink" title="Java 中有几种类型的流？"></a>Java 中有几种类型的流？</h1><ul><li>两种流分别是字节流，字符流。</li><li>字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer</li><li>在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</li><li>关于Java的IO需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</li></ul><h1 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h1><ul><li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间</li><li>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</li><li>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</li></ul><h1 id="什么时候用assert？"><a href="#什么时候用assert？" class="headerlink" title="什么时候用assert？"></a>什么时候用assert？</h1><ul><li>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制</li><li>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。</li></ul><h1 id="比较一下Java-和JavaSciprt"><a href="#比较一下Java-和JavaSciprt" class="headerlink" title="比较一下Java 和JavaSciprt"></a>比较一下Java 和JavaSciprt</h1><ul><li>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。</li><li>下面对两种语言间的异同作如下比较：<ul><li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</li><li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</li><li>代码格式不一样。</li></ul></li><li>上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</li></ul><p> </p><h1 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h1><ul><li><p>代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;你好&quot;;</span><br><span class="line">String s2 = newString(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); </span><br></pre></td></tr></table></figure></li><li><p>在String类的构造方法当中，存在一个字符集设置的方法</p></li></ul><h1 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h1><ul><li>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</li><li>如果要访问外部类的局部变量，此时局部变量必须使用final修饰，否则无法访问。</li></ul><h1 id="匿名内部类是否可以继承其它类？是否可以实现接口？"><a href="#匿名内部类是否可以继承其它类？是否可以实现接口？" class="headerlink" title="匿名内部类是否可以继承其它类？是否可以实现接口？"></a>匿名内部类是否可以继承其它类？是否可以实现接口？</h1><ul><li>可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。</li></ul><h1 id="一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h1><ul><li>可以，但一个源文件中最多只能有一个公开类（public class）</li><li>而且文件名必须和公开类的类名完全保持一致。</li></ul><p> </p><h1 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h1><ul><li>接口可以继承接口</li><li>抽象类可以实现(implements)接口，抽象类可以继承具体类</li><li>抽象类中可以有静态的main方法。</li></ul><h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><ul><li>有两种方式：<ul><li>实现Cloneable接口并重写Object类中的clone()方法；</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</li></ul></li><li>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</li></ul><h1 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h1><ul><li>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</li></ul><p> </p><h1 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h1><ul><li>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝</li><li>实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存</li><li>两者的相同点：都有默认值而且在类的任何地方都可以调用</li></ul><h1 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h1><ul><li>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的</li><li>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li><li>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li></ul><h1 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h1><ul><li>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）</li><li>然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露</li><li>一个例子就是hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象</li></ul><h1 id="静态内部类和内部类有什么区别"><a href="#静态内部类和内部类有什么区别" class="headerlink" title="静态内部类和内部类有什么区别"></a>静态内部类和内部类有什么区别</h1><ul><li>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</li><li>内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</li><li>在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类</li><li>Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class</li><li>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</li><li>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化</li></ul><h1 id="char-型变量中能不能存贮一个中文汉字-为什么"><a href="#char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char 型变量中能不能存贮一个中文汉字?为什么?"></a>char 型变量中能不能存贮一个中文汉字?为什么?</h1><ul><li>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦</li></ul><h1 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h1><ul><li>是值传递</li><li>Java 编程语言只有值传递参数</li><li>当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用</li><li>对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。</li></ul><h1 id="是否可以继承String-类"><a href="#是否可以继承String-类" class="headerlink" title="是否可以继承String 类?"></a>是否可以继承String 类?</h1><ul><li>String 类是final类，不可以被继承。</li></ul><h1 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</h1><ul><li>不对</li><li>如果两个对象x和y满足x.equals(y) &#x3D;&#x3D;++++ true，它们的哈希码（hash code）应当相同</li><li>Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同</li></ul><h1 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）?"></a>构造器（constructor）是否可被重写（override）?</h1><ul><li>构造器不能被继承，因此不能被重写，但可以被重载。</li></ul><h1 id="在Java-中，如何跳出当前的多重嵌套循环？"><a href="#在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java 中，如何跳出当前的多重嵌套循环？"></a>在Java 中，如何跳出当前的多重嵌套循环？</h1><ul><li>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</li><li>Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好</li></ul><h1 id="数组有没有length-方法-String-有没有length-方法？"><a href="#数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="数组有没有length()方法?String 有没有length()方法？"></a>数组有没有length()方法?String 有没有length()方法？</h1><ul><li>数组没有length()方法，有length 的属性</li><li>String 有length()方法</li><li>JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</li></ul><h1 id="swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h1><ul><li>早期的JDK中，switch（expr）中，expr可以是byte、short、char、int</li><li>从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举</li><li>从JDK 1.7版开始，还可以是字符串（String）</li><li>长整型（long）是不可以的。</li></ul><h1 id="Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?"></a>Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h1><ul><li>Math.round(11.5)的返回值是12</li><li>Math.round(-11.5)的返回值是-11</li><li>四舍五入的原理是在参数上加0.5然后进行下取整。</li></ul><p> </p><h1 id="解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h1><ul><li><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间</p></li><li><p>而通过new关键字和构造器创建的对象放在堆空间</p></li><li><p>程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中</p></li><li><p>栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“hello”);</span><br></pre></td></tr></table></figure></li><li><p>上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。</p></li><li><p>较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p></li></ul><h1 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h1><ul><li>&amp;运算符有两种用法<ul><li>按位与</li><li>逻辑与</li></ul></li><li>&amp;&amp;运算符是短路与运算</li><li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true</li><li>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</li><li>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常</li><li>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</li></ul><h1 id="Java-有没有goto"><a href="#Java-有没有goto" class="headerlink" title="Java 有没有goto?"></a>Java 有没有goto?</h1><ul><li>goto 是Java中的保留字，在目前版本的Java中没有使用</li><li>其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字</li></ul><h1 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?</h1><ul><li>对于short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型</li><li>而short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为s1+&#x3D; 1;相当于s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。</li></ul><h1 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确?"></a>float f&#x3D;3.4;是否正确?</h1><ul><li>不正确</li><li>3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成float f &#x3D;3.4F;。</li></ul><h1 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h1><ul><li>不是</li><li>Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</li></ul><h1 id="访问修饰符的区别？"><a href="#访问修饰符的区别？" class="headerlink" title="访问修饰符的区别？"></a>访问修饰符的区别？</h1><table><thead><tr><th>作用域</th><th>当前类</th><th>同包</th><th>子类</th><th>其他</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</li></ul><p> </p><h1 id="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><a href="#如果变量用final修饰，则怎样？如果方法final修饰，则怎样？" class="headerlink" title="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"></a>如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</h1><ul><li>用final修饰的类不能被扩展，也就是说不可能有子类；</li><li>用final修饰的方法不能被替换或隐藏：<ul><li>使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</li><li>使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏	（hidden）；</li></ul></li><li>用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：<ul><li>静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量， 赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，	赋值只能在其声明中通过初始化表达式完成；</li><li>实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通	过初始化表达式完成，也可以在实例初始化块或构造器中进行；</li><li>方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体	（body）结束，在此期间其值不能改变；</li><li>构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，	同时被初始化为对应实参值，终止于构造器体结束，在此期间其值不能改变；</li><li>异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化	为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</li><li>局部变量在其值被访问之前必须被明确赋值；</li></ul></li></ul><h1 id="成员变量用static修饰和不用static修饰有什么区别？"><a href="#成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="成员变量用static修饰和不用static修饰有什么区别？"></a>成员变量用static修饰和不用static修饰有什么区别？</h1><ul><li>两个变量的生命周期不同。<ul><li>成员变量随着对象的创建而存在，随着对象的被回收而释放。</li><li>静态变量随着类的加载而存在，随着类的消失而消失。</li></ul></li><li>调用方式不同。<ul><li>成员变量只能被对象调用。</li><li>静态变量可以被对象调用，还可以被类名调用。</li><li>对象调用：p.country</li><li>类名调用 ：Person.country</li></ul></li><li>别名不同。<ul><li>成员变量也称为实例变量。</li><li>静态变量称为类变量。</li></ul><p> </p></li><li>数据存储位置不同。<ul><li>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.</li><li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.</li></ul></li></ul><h1 id="System-out-println-‘a’-1-的结果是"><a href="#System-out-println-‘a’-1-的结果是" class="headerlink" title="System.out.println(‘a’+1);的结果是"></a>System.out.println(‘a’+1);的结果是</h1><ul><li>‘a’是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98</li></ul><h1 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h1><ul><li>NullPointerException：一般都是在null对象上调用方法了。</li><li>NumberFormatException：继承IllegalArgumentException，字符串转换为数字时。</li><li>StringIndexOutOfBoundsException：字符串越界</li><li>ClassCastException:类型转换错误</li></ul><h1 id="200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><a href="#200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？" class="headerlink" title="200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"></a>200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</h1><ul><li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li><li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序</li><li>Collections 工具类的sort方法有两种重载的形式<ul><li>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul></li></ul><h1 id="199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><a href="#199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？" class="headerlink" title="199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"></a>199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</h1><ul><li>构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法</li></ul><h1 id="char型变量中能不能存储一个中文汉字？"><a href="#char型变量中能不能存储一个中文汉字？" class="headerlink" title="char型变量中能不能存储一个中文汉字？"></a>char型变量中能不能存储一个中文汉字？</h1><ul><li>java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。</li><li>char 在java中是2个字节，所以可以存储中文</li></ul><h1 id="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"><a href="#创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。" class="headerlink" title="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"></a>创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</h1><ul><li>用一个for循环创建线程对象并调用start方法启动线程。</li></ul><h1 id="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><a href="#Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？" class="headerlink" title="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"></a>Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</h1><ul><li>Map的实现类有HashMap,LinkedHashMap,TreeMap</li><li>HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序；TreeMap默认是自然升序）</li><li>LinkedHashMap底层存储结构是哈希表+链表，链表记录了添加数据的顺序</li><li>TreeMap底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性</li><li>LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表</li></ul><h1 id="try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？"><a href="#try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？" class="headerlink" title="try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？"></a>try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？</h1><ul><li>在异常处理时提供 finally 块来执行任何清除操作。</li><li>如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。</li><li>finally中语句不执行的唯一情况中执行了System.exit(0)语句。</li></ul><h1 id="什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>什么是编译型语言，什么是解释型语言？java可以归类到那种？</h1><ul><li>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。</li><li>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。</li><li>解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。</li><li>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C&#x2F;C++、Pascal&#x2F;Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。</li><li>JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</li></ul><h1 id="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h1><ul><li>final修饰基本类型变量，其值不能改变。</li><li>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li></ul><h1 id="Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="Class类的getDeclaredFields()方法与getFields()的区别？"></a>Class类的getDeclaredFields()方法与getFields()的区别？</h1><ul><li>getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法</li><li>getFields(): 只能获取所有public声43明的方法, 包括继承的方法</li></ul><h1 id="103-可序列化对象为什么要定义serialversionUID值"><a href="#103-可序列化对象为什么要定义serialversionUID值" class="headerlink" title="103.可序列化对象为什么要定义serialversionUID值?"></a>103.可序列化对象为什么要定义serialversionUID值?</h1><ul><li>SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容</li><li>如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常</li><li>如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</li></ul><h1 id="GC线程是否为守护线程？"><a href="#GC线程是否为守护线程？" class="headerlink" title="GC线程是否为守护线程？"></a>GC线程是否为守护线程？</h1><ul><li>GC线程是守护线程</li><li>线程分为守护线程和非守护线程（即用户线程）。只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。</li></ul><h1 id="不通过构造函数也能创建对象么"><a href="#不通过构造函数也能创建对象么" class="headerlink" title="不通过构造函数也能创建对象么"></a>不通过构造函数也能创建对象么</h1><ul><li>是</li><li>Java创建对象的几种方式：<ul><li>用new语句创建对象，这是最常见的创建对象的方法。</li><li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li><li>调用对象的clone()方法。</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li></ul></li><li>(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。</li></ul><h1 id="同步代码块和同步方法有什么区别"><a href="#同步代码块和同步方法有什么区别" class="headerlink" title="同步代码块和同步方法有什么区别"></a>同步代码块和同步方法有什么区别</h1><ul><li>相同点：同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为this，那么同步方法和同步代码块没有太大的区别。</li><li>区别：同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</li></ul><h1 id="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><a href="#Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？" class="headerlink" title="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"></a>Java中，如果Manager是Employee的子类，那么Pair<manager>是Pair<employee>的子类吗？</employee></manager></h1><ul><li>不是，两者没有任何关联。</li></ul><h1 id="简述Java中如何实现多态"><a href="#简述Java中如何实现多态" class="headerlink" title="简述Java中如何实现多态"></a>简述Java中如何实现多态</h1><ul><li>实现多态有三个前提条件：<ul><li>继承的存在；（继承是多态的基础，没有继承就没有多态）。</li><li>子类重写父类的方法。（多态下会调用子类重写后的方法）。</li><li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</li></ul></li><li>最后使用父类的引用变量调用子类重写的方法即可实现多态。</li></ul><h1 id="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h1><ul><li>在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt;K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt;K, V&gt;可以理解为HashMap&lt;Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型</li><li>引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。</li></ul><h1 id="对象在虚拟机的大小中可不可以用size-of取出。"><a href="#对象在虚拟机的大小中可不可以用size-of取出。" class="headerlink" title="对象在虚拟机的大小中可不可以用size of取出。"></a>对象在虚拟机的大小中可不可以用size of取出。</h1><ul><li>可以</li></ul><h1 id="什么是-JMS？"><a href="#什么是-JMS？" class="headerlink" title="什么是 JMS？"></a>什么是 JMS？</h1><ul><li>JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。</li></ul><h1 id="JMS-有哪些模型？"><a href="#JMS-有哪些模型？" class="headerlink" title="JMS 有哪些模型？"></a>JMS 有哪些模型？</h1><ul><li>JMS 消息机制主要分为两种模型：PTP 模型和 Pub&#x2F;Sub 模型。</li></ul><h4 id="PTP-模型"><a href="#PTP-模型" class="headerlink" title="PTP 模型"></a>PTP 模型</h4><ul><li>（Point to Point 对点模型) 每一个消息传递给一个消息消费者，保证消息传递给消息消费者，且消息不会同时被多个消费者接收。如果消息消费者暂时不在连接范围内，JMS 会自动保证消息不会丢失，直到消息消费者进入连接，消息将自动送达。因此，JMS 需要将消息保存到永久性介质上，例如数据库或者文件。</li></ul><h4 id="Pub-Sub-模型"><a href="#Pub-Sub-模型" class="headerlink" title="Pub-Sub 模型"></a>Pub-Sub 模型</h4><ul><li>(publish-subscription 发布者订阅者模型)每个主题可以拥有多个订阅者。JMS 系统负责将消息的副本传给该主题的每个订阅者。如果希望每一条消息都能够被处理，那么应该使用 PTP 消息模型。如果并不要求消息都必须被消息消费者接收到的情况下，可使用 pub-sub 消息模型。Pub-Sub 模型可以在一对多的消息广播时使用。</li></ul><h1 id="为什么不能根据返回类型来区分重载，为什么？"><a href="#为什么不能根据返回类型来区分重载，为什么？" class="headerlink" title="为什么不能根据返回类型来区分重载，为什么？"></a>为什么不能根据返回类型来区分重载，为什么？</h1><ul><li>方法的重载，即使返回值类型不同，也不能改变实现功能相同或类似这一既定事实</li><li>同时方法的重载只是要求两同三不同，即在同一个类中，相同的方法名称，参数列表当中的参数类型、个数、顺序不同；跟权限修饰符和返回值类无关</li></ul><h1 id="Java-中-byte-表示的数值范围是什么？"><a href="#Java-中-byte-表示的数值范围是什么？" class="headerlink" title="Java 中 byte 表示的数值范围是什么？"></a>Java 中 byte 表示的数值范围是什么？</h1><ul><li>范围是-128 至 127</li></ul><h1 id="在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？"><a href="#在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？" class="headerlink" title="在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？"></a>在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？</h1><ul><li>不正确。</li><li>通常情况下，进行比较判断的处理，switch 和 if-else 可以互相转换来写；</li><li>if-else 作用的范围比 switch-case 作用范围要大，但是当 switch-case 和 if-else 都可以用的情况下，通常推荐使用 switch-case。</li></ul><h1 id="Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？"><a href="#Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？" class="headerlink" title="Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？"></a>Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？</h1><ul><li>Java 程序中创建新的类对象，使用关键字 new 是正确的</li><li>回收无用的类对象使用关键字 free 是错误的.</li></ul><h1 id="存在使-i-1"><a href="#存在使-i-1" class="headerlink" title="存在使 i+1&lt;i 的数么?"></a>存在使 i+1&lt;i 的数么?</h1><ul><li>存在, int 的最大值, 加 1 后变为负数.</li></ul><h1 id="Java-中-Math-random（）-Math-random（）值为？"><a href="#Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="Java 中 Math.random（）&#x2F; Math.random（）值为？"></a>Java 中 Math.random（）&#x2F; Math.random（）值为？</h1><ul><li>如果除数与被除数均不为 0.0 的话，则取值范围为[0, +∞]。+∞在 Java 中显示的结果为 Infinity。</li><li>如果除数与被除数均为 0.0 的话，则运行结果为 NaN（Not a Number 的简写），计算错误。</li></ul><h1 id="匿名内部类可不可以继承或实现接口。为什么？"><a href="#匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="匿名内部类可不可以继承或实现接口。为什么？"></a>匿名内部类可不可以继承或实现接口。为什么？</h1><ul><li>匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现.</li><li>由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把<br>创建对象的任务交给了父类去完成。</li><li>在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。</li><li>因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。</li></ul><h1 id="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？"><a href="#说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？" class="headerlink" title="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？"></a>说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？</h1><ul><li>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；比如申请了一个 integer,但给它存了long 才能存下的数，那就是内存溢出。</li><li>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li><li>memory leak 会最终会导致 out of memory！</li></ul><h1 id="为什么为基本类型引入包装类"><a href="#为什么为基本类型引入包装类" class="headerlink" title="为什么为基本类型引入包装类"></a>为什么为基本类型引入包装类</h1><ul><li>基本数据类型有方便之处，简单、高效。</li><li>但是 Java 中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是 Object）。</li><li>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</li><li>包装类和基本数据类型之间的转换<ul><li>包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</li><li>包装类——-new WrapperClass(primitive) new WrapperClass(string)——基本数据类型</li></ul></li><li>自动装箱和自动拆箱<ul><li>JDK1.5 提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换</li></ul></li><li>包装类还可以实现基本类型变量和字符串之间的转换<ul><li>基本类型变量&lt;————String.valueof()————&gt;字符串</li><li>基本类型变量&lt;————WrapperClass.parseXxx(string)————字符串</li></ul></li></ul><h1 id="谈谈-Java-的多态"><a href="#谈谈-Java-的多态" class="headerlink" title="谈谈 Java 的多态"></a>谈谈 Java 的多态</h1><ul><li>实现多态的三个条件（前提条件，向上转型、向下转型）<ul><li>继承的存在；（继承是多态的基础，没有继承就没有多态）</li><li>子类重写父类的方法。（多态下会调用子类重写后的方法）</li><li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）</li></ul></li><li>向上转型 Student person &#x3D; new Student()</li><li>将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。</li><li>此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法此时通过父类引用变量无法调用子类特有的方法。</li><li>向下转型 Student stu &#x3D; (Student)person;</li><li>将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类型，否则将出现 ClassCastException，不是任意的强制转换向下转型时可以结合使用 instanceof 运算符进行强制类型转换，比如出现转换异常—ClassCastException</li></ul><h1 id="if-多分支语句和-switch-多分支语句的异同之处"><a href="#if-多分支语句和-switch-多分支语句的异同之处" class="headerlink" title="if 多分支语句和 switch 多分支语句的异同之处"></a>if 多分支语句和 switch 多分支语句的异同之处</h1><ul><li>相同之处：都是分支语句，多超过一种的情况进行判断处理。</li><li>不同之处：<ul><li>switch 更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有 break 跳出），不加判断地执行下去;而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。</li><li>switch 为等值判断（不允许比如&gt;&#x3D; &lt;&#x3D;），而 if 为等值和区间都可以，if 的使用范围大。</li></ul></li></ul><h1 id="基本数据类型的类型转换规则"><a href="#基本数据类型的类型转换规则" class="headerlink" title="基本数据类型的类型转换规则"></a>基本数据类型的类型转换规则</h1><ul><li>基本类型转换分为自动转换和强制转换。</li><li>自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的<br>范围。</li><li>强制转换规则：高级变为低级需要强制转换。</li><li>如何转换：<ul><li>赋值运算符“&#x3D;”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</li><li>赋值运算符“&#x3D;”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 &#x3D;&#x3D; 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li><li>可以将整型常量直接赋值给 byte, short, char 等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li></ul></li></ul><h1 id="Java-三种注释类型"><a href="#Java-三种注释类型" class="headerlink" title="Java 三种注释类型"></a>Java 三种注释类型</h1><ul><li>共有单行注释、多行注释、文档注释 3 种注释类型</li></ul><h1 id="谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么"><a href="#谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么" class="headerlink" title="谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?"></a>谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?</h1><ul><li>Java本身是一种面向对象的语言,最显著的特点有两个方面,一个是所谓的”书写一次,到处运行”;能够非常容易地获得跨平台能力;另外就是垃圾收集器(GC)，Java通过垃圾收集器回收分配内存,大部分情况下,程序员不需要自己操心内存的分配和回收。我们日常接触到JRE或者JDK。JRE也就是Java运行环境,包含了JVM和Java类库,以及一些模块等。而JDK可以看作是JRE的一个超集,提供了更多的工具,比如编译器 各种诊断工具。</li><li>“对于Java是解释执行”这句话,这个说法不准确。我们开发的Java的源代码,首先通过Javac编译成为字节码,然后在运行时通过Java虚拟机内嵌的解释器将字节码转换为最终的机器码。但是常见的JVM,比如我们大数据情况使用的Oracle JDK提供的HostpotJVM,提供了JIT编译器,就是通常所说的动态编译器,JIT能够在运行时将热点代码(高频调用的方法和代码块)编译成机器码,这种情况下部分热点就属于编译执行,而不是解释执行。这样类似于缓存技术,运行时在遇到热点代码可以直接执行,而不是先解释在执行。</li></ul><h1 id="NoClassDeFoundError和ClassNotFoundException的区别"><a href="#NoClassDeFoundError和ClassNotFoundException的区别" class="headerlink" title="NoClassDeFoundError和ClassNotFoundException的区别?"></a>NoClassDeFoundError和ClassNotFoundException的区别?</h1><ul><li>首先NoClassDeFoundError是一个错误,ClassNotFoundException是一个异常。ClassNotFoundException的产生原因,Java支持使用Class.froName方法来动态地加载类,任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中,如果这个类在类路径中没有被找到,那么此时就会在运行时抛出ClassNotFoundException异常。另外还有一个导致ClassNotFoundException的原因就是,当一个类已经被某个类加载器加载到内存中,此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li><li>NoClassDeFoundError产生的原因在于:如果JVM或者ClassLoader实例尝试加载类的时候找不到类的定义。例如要查找的类在编译的时候是存在的,运行的时候找不到了。这个时候就会导致NoClassDefFoundError。造成该问题的原因可能是打包过程中漏掉了部分类,或者jar包出现损坏或者篡改。解决这个问题的办法就是查找那些在开发期间存在与类路径下,但在运行期间却不在类路径下的类。</li></ul><h1 id="一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数"><a href="#一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数" class="headerlink" title="一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?"></a>一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?</h1><ul><li>用 super 关键字,子类去调用父类的方法，如：super.myMethod();子类去调用父类的构造函数，如：super()</li></ul><h1 id="Bit-和-Byte-是什么意思-它们之间有什么关系"><a href="#Bit-和-Byte-是什么意思-它们之间有什么关系" class="headerlink" title="Bit 和 Byte 是什么意思?它们之间有什么关系?"></a>Bit 和 Byte 是什么意思?它们之间有什么关系?</h1><ul><li>bit 中文名称是位，是用以描述电脑数据量的最小单位。</li><li>byte（字节）是计算机信息技术用于计量存储容量和传输容量的一种计量单位 1byte&#x3D;8bit</li></ul><h1 id="什么是-java-序列化，如何实现-java-序列化？"><a href="#什么是-java-序列化，如何实现-java-序列化？" class="headerlink" title="什么是 java 序列化，如何实现 java 序列化？"></a>什么是 java 序列化，如何实现 java 序列化？</h1><ul><li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；</li><li>序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream) 来 构 造 一 个 ObjectOutputStream( 对 象 流 ) 对 象 ， 接 着 ， 使 用ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。</li></ul><h1 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h1><ul><li>Lambda表达式的本质只是一个”语法糖”,由编译器推断并帮我们转换包装为常规的代码,因此我们可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘。</li><li>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许我们通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。</li><li>Lambda表达式还增强了集合库。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。</li></ul><h1 id="获取用键盘输入常用的的两种方法"><a href="#获取用键盘输入常用的的两种方法" class="headerlink" title="获取用键盘输入常用的的两种方法"></a>获取用键盘输入常用的的两种方法</h1><ul><li>通过 Scanner</li><li>通过 BufferedReader</li></ul><h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul><h1 id="JAVA-复制"><a href="#JAVA-复制" class="headerlink" title="JAVA 复制"></a>JAVA 复制</h1><ul><li>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</li></ul><h4 id="直接赋值复制"><a href="#直接赋值复制" class="headerlink" title="直接赋值复制"></a>直接赋值复制</h4><ul><li>直接赋值。在 Java 中，A a1 &#x3D; a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。</li></ul><h4 id="浅复制（复制引用但不复制引用的对象）"><a href="#浅复制（复制引用但不复制引用的对象）" class="headerlink" title="浅复制（复制引用但不复制引用的对象）"></a>浅复制（复制引用但不复制引用的对象）</h4><ul><li>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。</li><li>因此，原始对象及其副本引用同一个对象。</li></ul><h4 id="深复制（复制对象和其应用对象）"><a href="#深复制（复制对象和其应用对象）" class="headerlink" title="深复制（复制对象和其应用对象）"></a>深复制（复制对象和其应用对象）</h4><ul><li>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</li></ul><h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><ul><li>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List&lt;Object&gt;和 List&lt;String&gt;等类型，在编译之后</li><li>都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</li><li>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</li></ul><h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h1><ul><li>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数</li><li>例 如 List&lt;?&gt; 在逻辑上是 List&lt;String&gt;,List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt;的父类。</li></ul><h1 id="创建对象的两种方法"><a href="#创建对象的两种方法" class="headerlink" title="创建对象的两种方法"></a>创建对象的两种方法</h1><ul><li>Class 对象的 newInstance()<ul><li>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</li></ul></li><li>调用 Constructor 对象的 newInstance()<ul><li>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</li></ul></li></ul><h1 id="Java-中，Serializable-与-Externalizable-的区别？"><a href="#Java-中，Serializable-与-Externalizable-的区别？" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别？"></a>Java 中，Serializable 与 Externalizable 的区别？</h1><ul><li>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</li></ul><h1 id="OOP-中的-组合、聚合和关联有什么区别？"><a href="#OOP-中的-组合、聚合和关联有什么区别？" class="headerlink" title="OOP 中的 组合、聚合和关联有什么区别？"></a>OOP 中的 组合、聚合和关联有什么区别？</h1><ul><li>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B组合的，则 A 不存在的话，B 一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</li></ul><h1 id="Java-中，嵌套公共静态类与顶级类有什么不同？"><a href="#Java-中，嵌套公共静态类与顶级类有什么不同？" class="headerlink" title="Java 中，嵌套公共静态类与顶级类有什么不同？"></a>Java 中，嵌套公共静态类与顶级类有什么不同？</h1><ul><li>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</li></ul><h1 id="继承和组合之间有什么不同？"><a href="#继承和组合之间有什么不同？" class="headerlink" title="继承和组合之间有什么不同？"></a>继承和组合之间有什么不同？</h1><ul><li>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</li></ul><h1 id="我们能自己写一个容器类，然后使用-for-each-循环码？"><a href="#我们能自己写一个容器类，然后使用-for-each-循环码？" class="headerlink" title="我们能自己写一个容器类，然后使用 for-each 循环码？"></a>我们能自己写一个容器类，然后使用 for-each 循环码？</h1><ul><li>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</li></ul><h1 id="写一段代码在遍历-ArrayList-时移除一个元素？"><a href="#写一段代码在遍历-ArrayList-时移除一个元素？" class="headerlink" title="写一段代码在遍历 ArrayList 时移除一个元素？"></a>写一段代码在遍历 ArrayList 时移除一个元素？</h1><ul><li>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</li></ul><h1 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a>Java 中的 HashSet，内部是如何工作的？</h1><ul><li>HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。</li></ul><h1 id="Java-中的-TreeMap-是采用什么树实现的？"><a href="#Java-中的-TreeMap-是采用什么树实现的？" class="headerlink" title="Java 中的 TreeMap 是采用什么树实现的？"></a>Java 中的 TreeMap 是采用什么树实现的？</h1><ul><li>Java 中的 TreeMap 是使用红黑树实现的。</li></ul><h1 id="Java-中的-LinkedList-是单向链表还是双向链表？"><a href="#Java-中的-LinkedList-是单向链表还是双向链表？" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表？"></a>Java 中的 LinkedList 是单向链表还是双向链表？</h1><ul><li>是双向链表，你可以检查 JDK 的源码</li></ul><h1 id="Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？</h1><ul><li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li></ul><h1 id="poll-方法和-remove-方法的区别？"><a href="#poll-方法和-remove-方法的区别？" class="headerlink" title="poll() 方法和 remove() 方法的区别？"></a>poll() 方法和 remove() 方法的区别？</h1><ul><li>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</li></ul><h1 id="Java-中的编译期常量是什么？使用它又什么风险？"><a href="#Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="Java 中的编译期常量是什么？使用它又什么风险？"></a>Java 中的编译期常量是什么？使用它又什么风险？</h1><ul><li>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</li></ul><h1 id="我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？"><a href="#我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？" class="headerlink" title="我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？"></a>我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？</h1><ul><li>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</li></ul><h1 id="3-0-1-0-3-将会返回什么？true-还是-false？"><a href="#3-0-1-0-3-将会返回什么？true-还是-false？" class="headerlink" title="3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？"></a>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？</h1><ul><li>false，因为有些浮点数不能完全精确的表示出来。</li></ul><h1 id="int-和-Integer-哪个会占用更多的内存？"><a href="#int-和-Integer-哪个会占用更多的内存？" class="headerlink" title="int 和 Integer 哪个会占用更多的内存？"></a>int 和 Integer 哪个会占用更多的内存？</h1><ul><li>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。</li><li>但是 int 是一个原始类型的数据，所以占用的空间更少。</li></ul><h1 id="为什么-Java-中的-String-是不可变的（Immutable）？"><a href="#为什么-Java-中的-String-是不可变的（Immutable）？" class="headerlink" title="为什么 Java 中的 String 是不可变的（Immutable）？"></a>为什么 Java 中的 String 是不可变的（Immutable）？</h1><ul><li>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。</li></ul><h1 id="我们能在-Switch-中使用-String-吗？"><a href="#我们能在-Switch-中使用-String-吗？" class="headerlink" title="我们能在 Switch 中使用 String 吗？"></a>我们能在 Switch 中使用 String 吗？</h1><ul><li>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</li></ul><h1 id="Java-中的构造器链是什么？"><a href="#Java-中的构造器链是什么？" class="headerlink" title="Java 中的构造器链是什么？"></a>Java 中的构造器链是什么？</h1><ul><li>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</li></ul><h1 id="什么是-Busy-spin？我们为什么要使用它？"><a href="#什么是-Busy-spin？我们为什么要使用它？" class="headerlink" title="什么是 Busy spin？我们为什么要使用它？"></a>什么是 Busy spin？我们为什么要使用它？</h1><ul><li>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。</li><li>所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</li></ul><h1 id="Swing-是线程安全的？"><a href="#Swing-是线程安全的？" class="headerlink" title="Swing 是线程安全的？"></a>Swing 是线程安全的？</h1><ul><li>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。</li><li>这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</li></ul><h1 id="什么是线程局部变量？"><a href="#什么是线程局部变量？" class="headerlink" title="什么是线程局部变量？"></a>什么是线程局部变量？</h1><ul><li>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</li></ul><h1 id="Java-中应该使用什么数据类型来代表价格？"><a href="#Java-中应该使用什么数据类型来代表价格？" class="headerlink" title="Java 中应该使用什么数据类型来代表价格？"></a>Java 中应该使用什么数据类型来代表价格？</h1><ul><li>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的double 类型。</li></ul><h1 id="怎么将-byte-转换为-String？"><a href="#怎么将-byte-转换为-String？" class="headerlink" title="怎么将 byte 转换为 String？"></a>怎么将 byte 转换为 String？</h1><ul><li>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</li></ul><h1 id="我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h1><ul><li>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。</li></ul><h1 id="哪个类包含-clone-方法？是-Cloneable-还是-Object？"><a href="#哪个类包含-clone-方法？是-Cloneable-还是-Object？" class="headerlink" title="哪个类包含 clone 方法？是 Cloneable 还是 Object？"></a>哪个类包含 clone 方法？是 Cloneable 还是 Object？</h1><ul><li>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由c 或 c++ 或 其他本地语言实现的。</li></ul><h1 id="Java-中-操作符是线程安全的吗？"><a href="#Java-中-操作符是线程安全的吗？" class="headerlink" title="Java 中 ++ 操作符是线程安全的吗？"></a>Java 中 ++ 操作符是线程安全的吗？</h1><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p><h1 id="a-a-b-与-a-b-的区别"><a href="#a-a-b-与-a-b-的区别" class="headerlink" title="a &#x3D; a + b 与 a +&#x3D; b 的区别"></a>a &#x3D; a + b 与 a +&#x3D; b 的区别</h1><ul><li>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是a +&#x3D; b 没问题，如下：<ul><li>byte a &#x3D; 127;</li><li>byte b &#x3D; 127;</li><li>b &#x3D; a + b; &#x2F;&#x2F; error : cannot convert from int to byte</li><li>b +&#x3D; a; &#x2F;&#x2F; ok</li></ul></li></ul><h1 id="什么是多线程环境下的伪共享（false-sharing）？"><a href="#什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="什么是多线程环境下的伪共享（false sharing）？"></a>什么是多线程环境下的伪共享（false sharing）？</h1><ul><li>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行</li></ul><h1 id="89、简述一下面向对象的”六原则一法则”。"><a href="#89、简述一下面向对象的”六原则一法则”。" class="headerlink" title="89、简述一下面向对象的”六原则一法则”。"></a>89、简述一下面向对象的”六原则一法则”。</h1><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</li><li>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</li><li>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</li><li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</li></ul><h1 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h1><ul><li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li></ul><h1 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h1><ul><li>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</li></ul><h1 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h1><ul><li>动态代理是运行时动态生成代理类。</li><li>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</li></ul><h1 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h1><ul><li>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</li></ul><h1 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h1><ul><li>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</li></ul><h1 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h1><ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul><h1 id="Java-中的异常处理机制的简单原理和应用。"><a href="#Java-中的异常处理机制的简单原理和应用。" class="headerlink" title="Java 中的异常处理机制的简单原理和应用。"></a>Java 中的异常处理机制的简单原理和应用。</h1><ul><li>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。</li><li>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。</li></ul><h1 id="Java-中的-LongAdder-和-AtomicLong-的区别"><a href="#Java-中的-LongAdder-和-AtomicLong-的区别" class="headerlink" title="Java 中的 LongAdder 和 AtomicLong 的区别"></a>Java 中的 LongAdder 和 AtomicLong 的区别</h1><ul><li>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进行了有效的分离，提高了并行度。</li></ul><h1 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h1><ul><li>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</li><li>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。</li></ul><h1 id="Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h1><ul><li>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。</li><li>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</li><li>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数。</li></ul><h1 id="请问-Query-接口的-list-方法和-iterate-方法有什么区别？"><a href="#请问-Query-接口的-list-方法和-iterate-方法有什么区别？" class="headerlink" title="请问 Query 接口的 list 方法和 iterate 方法有什么区别？"></a>请问 Query 接口的 list 方法和 iterate 方法有什么区别？</h1><ul><li>list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用 iterate()方法可以减少性能开销。</li><li>list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题</li></ul><h1 id="Java-的接口和-C-的虚类的相同和不同处。"><a href="#Java-的接口和-C-的虚类的相同和不同处。" class="headerlink" title="Java 的接口和 C++的虚类的相同和不同处。"></a>Java 的接口和 C++的虚类的相同和不同处。</h1><ul><li>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。</li><li>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。</li></ul><h1 id="Java-支持多继承么？"><a href="#Java-支持多继承么？" class="headerlink" title="Java 支持多继承么？"></a>Java 支持多继承么？</h1><ul><li>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</li></ul><h1 id="解释-extends-和-super-泛型限定符-上界不存下界不取"><a href="#解释-extends-和-super-泛型限定符-上界不存下界不取" class="headerlink" title="解释 extends 和 super 泛型限定符-上界不存下界不取"></a>解释 extends 和 super 泛型限定符-上界不存下界不取</h1><ul><li>泛型中上界和下界的定义<ul><li>上界 &lt;? extend Fruit&gt;</li><li>下界 &lt;? super Apple&gt;</li></ul></li><li>上界和下界的特点<ul><li>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）</li><li>下界的 list 只能 add，不能 get</li></ul></li><li>上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把所有的子类向上转型为 Fruit。</li><li>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接着呢，除了 Object，其他的都接不住。</li><li>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。</li><li>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引用就必须得用 cast。</li></ul><h1 id="”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？"><a href="#”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？" class="headerlink" title="”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？"></a>”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？</h1><ul><li>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</li><li>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。</li></ul><h1 id="你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？</h1><ul><li>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</li><li>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一个很好的说明。</li><li>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。</li><li>其函数表示是：<ul><li>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));</li><li>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。</li><li>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好的说明。</li></ul></li></ul><h1 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h1><ul><li>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</li><li>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递.</li></ul><h1 id="为啥有时会出现-4-0-3-6-0-40000001-这种现象？"><a href="#为啥有时会出现-4-0-3-6-0-40000001-这种现象？" class="headerlink" title="为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？"></a>为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？</h1><ul><li>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。</li></ul><h1 id="说说-Lamda-表达式的优缺点。"><a href="#说说-Lamda-表达式的优缺点。" class="headerlink" title="说说 Lamda 表达式的优缺点。"></a>说说 Lamda 表达式的优缺点。</h1><ul><li>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。</li><li>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</li></ul><h1 id="若对一个类不重写，它的-equals-方法是如何比较的？"><a href="#若对一个类不重写，它的-equals-方法是如何比较的？" class="headerlink" title="若对一个类不重写，它的 equals()方法是如何比较的？"></a>若对一个类不重写，它的 equals()方法是如何比较的？</h1><ul><li>比较是对象的地址。</li></ul><h1 id="比较的是什么？"><a href="#比较的是什么？" class="headerlink" title="&#x3D;&#x3D;比较的是什么？"></a>&#x3D;&#x3D;比较的是什么？</h1><ul><li>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。</li></ul><h1 id="Object-若不重写-hashCode-的话，hashCode-如何计算出来的？"><a href="#Object-若不重写-hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="Object 若不重写 hashCode()的话，hashCode()如何计算出来的？"></a>Object 若不重写 hashCode()的话，hashCode()如何计算出来的？</h1><ul><li>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。</li></ul><h1 id="Hash表的hash函数，冲突解决方法有哪些。"><a href="#Hash表的hash函数，冲突解决方法有哪些。" class="headerlink" title="Hash表的hash函数，冲突解决方法有哪些。"></a>Hash表的hash函数，冲突解决方法有哪些。</h1><ul><li>开放定址法或者叫再散列法；<ul><li>线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    - 二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    - 伪随机探测再散列：di&#x3D;伪随机序列；</li></ul></li><li>再哈希法；</li><li>拉链法。</li></ul><h1 id="分派：静态分派与动态分派。"><a href="#分派：静态分派与动态分派。" class="headerlink" title="分派：静态分派与动态分派。"></a>分派：静态分派与动态分派。</h1><ul><li>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的</li><li>动态分派：（重写）</li></ul><h1 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样?"></a>一个线程如果出现了运行时异常会怎么样?</h1><ul><li>如果该异常被捕获或抛出，则程序继续运行。 </li><li>如果异常没有被捕获该线程将会停止执行。 </li><li>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理</li></ul><h1 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h1><ul><li>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。</li></ul><h1 id="并发编程（concurrency）并行编程（parallellism）有什么区别？"><a href="#并发编程（concurrency）并行编程（parallellism）有什么区别？" class="headerlink" title="并发编程（concurrency）并行编程（parallellism）有什么区别？*"></a>并发编程（concurrency）并行编程（parallellism）有什么区别？*</h1><ul><li>并发（concurrency）和并行（parallellism）是：<ul><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群</li></ul></li></ul><h1 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h1><ul><li>只要退出了synchronized块，无论是正常还是异常，都会释放锁。</li></ul><h1 id="foreach与正常for循环效率对比"><a href="#foreach与正常for循环效率对比" class="headerlink" title="foreach与正常for循环效率对比"></a>foreach与正常for循环效率对比</h1><ul><li>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。</li></ul><h1 id="Static-class-与non-static-class的区别"><a href="#Static-class-与non-static-class的区别" class="headerlink" title="Static?class?与non?static?class的区别"></a>Static?class?与non?static?class的区别</h1><ul><li>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。</li><li>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。</li></ul><h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul><li>加载JDBC驱动程序</li><li>提供JDBC连接的URL</li><li>创建数据库的连接</li><li>创建一个Statement</li><li>执行SQL语句</li><li>处理结果</li><li>关闭JDBC对象</li></ul><h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul><li>方法名称相同，参数的类型或个数不同</li><li>方法名称、参数类型、返回值类型全部相同</li><li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li><li>范围 发生在一个类中 发生在继承类中</li><li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li><li>反射的应用很多，很多框架都有用到<ul><li>spring 的 ioc&#x2F;di 也是反射…</li><li>javaBean和jsp之间调用也是反射…</li><li>struts的 FormBean 和页面之间…也是通过反射调用…</li><li>JDBC 的 classForName()也是反射…</li><li>hibernate的 find(Class clazz) 也是反射…</li><li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li></ul></li></ul><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>虚拟机把描述类的数据⽂件（字节码）加载到内存，并对数据进⾏验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使⽤的java类型（java.lang.Class对象）</li><li>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</li></ul><h4 id="类⽣命周期"><a href="#类⽣命周期" class="headerlink" title="类⽣命周期"></a>类⽣命周期</h4><ul><li>类加载过程：读取⼆进制字节流到JVM—&gt;验证格式语义等—&gt;为静态变量分配内存空间—&gt;常量池引⽤解析—&gt;执⾏static标识的代码<ul><li>a. 加载过程：通过⼀个类的全限定名来获取定义此类的⼆进制字节流，将这个字节流所代表的静态存储结构转化为⽅法区的运⾏时数据结构。在内存中(⽅法区)⽣成⼀个代表这个类的java.lang.Class对象，作为⽅法区这个类的各种数据的访问⼊⼝；</li><li>b. 验证过程：为了确保Class⽂件的字节流中包含的信息符合当前虚拟机的要求，⽂件格式验证、元数据验证、字节码验证、符号引⽤验证；</li><li>c. 准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在⽅法区中进⾏分配；准备阶段，static对象会被设置默认值，static ﬁnal对象会被赋上给予的值。</li><li>d. 解析阶段：虚拟机将常量池内的符号引⽤替换为直接引⽤的过程。<ul><li>i. 符号引⽤：字符串，引⽤对象不⼀定被加载；</li><li>ii. 直接引⽤：指针或者地址偏移量，引⽤对象⼀定在内存中。</li></ul></li><li>e. 初始化阶段：类初始化阶段是类加载过程的最后⼀步。初始化阶段就是执⾏类构造器<clint>()⽅法的过程。</clint></li><li>f. 使⽤阶段</li><li>g. 卸载阶段：</li></ul></li></ul><h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><ul><li>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</li><li>主要有一下四种类加载器:<ul><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ul></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li>java默认提供三个类加载器：<ul><li>a. 启动类加载器（BootStrap ClassLoader） 启动ClassLoader（sun.boot.class.path）：最顶层的加载类，主要加载jdk中的核⼼库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。Bootstrap ClassLoader不继承⾃ClassLoader，因为它不是⼀个普通的Java类，底层由C++编写，已嵌⼊到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核⼼类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</li><li>b. 扩展类加载器（Extension ClassLoader）扩展ClassLoader（java.ext.dirs）：扩展的类加载器，加载⽬录%JRE_HOME%\lib\ext⽬录下的jar包和class⽂件。还可以加载-D java.ext.dirs选项指定的⽬录。</li><li>c. App ClassLoader应⽤ClassLoader&#x2F;系统ClassLoader（java.class.path）：也称为SystemAppClass 加载当前应⽤的classpath的所有类。除了BootStrap ClassLoader，每个ClassLoader都有⼀个Parent作为⽗亲。</li></ul></li><li>双亲委派机制：<ul><li>定义：当⼀个ClassLoader实例需要加载某个类时，它会试图亲⾃搜索某个类之前，先把这个任务委托给它的⽗类加载器，这个过程是由上⾄下依次检查的，⾸先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader进⾏加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的⽂件系统或⽹络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类⽣成⼀个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</li><li>作⽤：<ul><li>避免重复加载；</li><li>考虑到安全因素，避免⾃定义的类去替代系统类，如String。</li><li>JVM如何判定两个class是否相同？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，⽽且要判断是否由同⼀个类加载器实例加载的。只有两者同时满⾜的情况下，JVM才认为这两个class是相同的。<ul><li>⾃底向上检查类是否已经加载；</li><li>⾃顶向下尝试加载类。</li></ul></li></ul></li></ul></li><li>custom classloader：⾃定义classloader<ul><li>Java中提供的默认ClassLoader，只加载指定⽬录下的jar和class，如果我们想加载其它位置的类或jar时，就需要定义⾃⼰的ClassLoader。</li><li>步骤：<ul><li>继承java.lang.ClassLoader</li><li>重写⽗类的findClass⽅法</li></ul></li></ul></li></ul><h4 id="引起类加载的五个⾏为"><a href="#引起类加载的五个⾏为" class="headerlink" title="引起类加载的五个⾏为"></a>引起类加载的五个⾏为</h4><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li><li>反射调⽤的时候，如果类没有进⾏过初始化，则需要先触发其初始化</li><li>⼦类初始化的时候，如果其⽗类还没初始化，则需先触发其⽗类的初始化</li><li>虚拟机执⾏主类的时候(有 main(string[] args))</li><li>JDK1.7 动态语⾔⽀持</li></ul><h4 id="java对象创建时机"><a href="#java对象创建时机" class="headerlink" title="java对象创建时机"></a>java对象创建时机</h4><ul><li>使⽤new关键字创建对象</li><li>使⽤Class类的newInstance⽅法(反射机制)</li><li>使⽤Constructor类的newInstance⽅法(反射机制)</li><li>使⽤Clone⽅法创建对象</li><li>使⽤(反)序列化机制创建对象</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/7e68be57c290.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/7e68be57c290.html" class="post-title-link" itemprop="url">消息队列（MQ）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:22:16" itemprop="dateCreated datePublished" datetime="2023-12-20T09:22:16+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-05 17:08:37" itemprop="dateModified" datetime="2024-01-05T17:08:37+08:00">2024-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>10 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是消息队列中间件"><a href="#什么是消息队列中间件" class="headerlink" title="什么是消息队列中间件"></a>什么是消息队列中间件</h1><ul><li>消息队列中间件（简称消息中间件）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成</li><li>通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能</li><li>ActiveMQ<ul><li>Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信</li></ul></li><li>RabbitMQ<ul><li>采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息</li><li>RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的</li></ul></li><li>Kafka<ul><li>起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，现已捐献给 Apache 基金会</li><li>它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用</li><li>目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成</li></ul></li><li>RocketMQ<ul><li>是阿里开源的消息中间件，目前已经捐献给 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双 11 的洗礼，实力不容小觑</li></ul></li><li>ZeroMQ<ul><li>号称史上最快的消息队列，基于 C 语言开发</li><li>ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩。</li><li>虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</li></ul></li><li>目前市面上的消息中间件还有很多，比如腾讯系的 PhxQueue、CMQ、CKafka，又比如基于 Go 语言的 NSQ，有时人们也把类似 Redis 的产品也看做消息中间件的一种</li></ul><h1 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h1><ul><li>场景有很多，但是比较核心的有 3 个：解耦、异步、削峰。</li><li>解耦<ul><li>假如A系统需要发送数据到BCD三个系统，通过接口调用发送。如果新系统E也要这个数据，C系统现在不需要这个数据了，A系统就需要通过新接口发给E系统，并且把C系统的调用去掉</li><li>在这个场景中，A系统跟其它系统严重耦合，A系统要时刻考虑BCDE四个系统是否正确收到数据，要不要重发</li><li>如果使用MQ，A系统产生一条数据，发送到MQ里面去，哪个系统需要数据自己去MQ里面消费。如果新系统需要数据，直接从MQ里消费即可；如果某个系统不需要这条数据了，就取消对MQ消息的消费即可。这样下来，A系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</li><li>通过一个MQ，发布订阅这么一个模型，A系统就跟其它系统彻底解耦了。</li><li>面试技巧：考虑一下你负责的系统中是否有类似的场景，有的话在简历中体现出来这块东西，用MQ作解耦。</li></ul></li><li>异步<ul><li>A系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近1s。</li><li>如果使用MQ，那么 A系统连续发送 3 条消息到MQ队列中，假如耗时 5ms，A系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms</li></ul></li><li>削峰<ul><li>每天 0:00 到 12:00，A系统每秒并发请求数量50个。12:00 ~ 13:00，每秒并发请求数量会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，可能导致系统崩溃，用户也就没法再使用系统了。但是高峰期一过，到了下午的时候，又成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</li><li>如果使用MQ，每秒 5k 个请求写入MQ，A系统每秒钟最多处理 2k 个请求。A系统从MQ中慢慢拉取请求，每秒钟就拉取 2k 个请求，这样下来，哪怕是高峰期的时候，A系统也绝对不会挂掉。而MQ每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在MQ中。这个短暂的高峰期积压是可以的，因为高峰期过了之后，每秒钟就 50 个请求进MQ，但是 A系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A系统就会快速将积压的消息给解决掉。</li></ul></li></ul><h1 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h1><ul><li>优点<ul><li>解耦、异步、削峰。</li></ul></li><li>缺点<ul><li>系统可用性降低：系统引入的外部依赖越多，越容易挂掉</li><li>系统复杂度提高：加个MQ进来，要解决重复消费、消息丢失、消息传递的顺序性等问题</li><li>一致性问题：如果消费数据的多个系统，有个别系统处理失败了，就会导致数据不一致了</li></ul></li></ul><h1 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点</h1><ul><li>对比</li></ul><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td>-</td><td>-</td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><ul><li>建议<ul><li>ActiveMQ，现在用的不多了，没经过大规模吞吐量场景的验证，社区不是很活跃，不推荐用这个；</li><li>RabbitMQ，erlang语言阻止了大量的Java工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是是开源的，有比较稳定的支持，活跃度也高；</li><li>RocketMQ，阿里出品，社区不是很活跃，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li><li>中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择</li><li>大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择</li><li>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li></ul></li></ul><h1 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h1><h2 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h2><ul><li>RabbitMQ 是基于主从（非分布式）做高可用性的</li><li>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式</li></ul><h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><ul><li>单机模式，是 Demo 级别的，一般生产环境不用单机模式。</li></ul><h3 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h3><ul><li>在多台机器上启动多个 RabbitMQ 实例</li><li>创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据</li><li>元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例</li><li>消费的时候，如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来</li><li>没做到所谓的分布式，就是个普通集群</li><li>要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈</li><li>如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据</li><li>所以这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作</li></ul><h3 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h3><ul><li>这种模式才是所谓的 RabbitMQ 的高可用模式</li><li>在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，即每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据</li><li>写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上</li><li>任何一个机器宕机了，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据</li><li>坏处在于<ul><li>性能开销大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重</li><li>这不是分布式的，没有扩展性可言，如果某个 queue 负载很重，加机器的话，新增的机器也包含了这个 queue 的所有数据，没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li></ul></li></ul><h2 id="Kafka-的高可用性"><a href="#Kafka-的高可用性" class="headerlink" title="Kafka 的高可用性"></a>Kafka 的高可用性</h2><ul><li>Kafka是分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据</li><li>Kafka 一个最基本的架构认识<ul><li>由多个 broker 组成，每个 broker 是一个节点</li><li>你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</li><li>每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本</li><li>所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower</li><li>写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可</li></ul></li><li>如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本</li><li>如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可，这就有所谓的高可用性了</li><li>写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者（当然，这只是其中一种模式，还可以适当调整这个行为）</li><li>消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到</li></ul><h1 id="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</h1><ul><li>RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题</li><li>因为这问题通常不是MQ自己保证的，是由我们开发来保证的</li><li>挑一个 Kafka 来举个例子，说说怎么重复消费吧</li><li>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示已经消费过了，下次就从上次消费到的 offset 来继续消费</li><li>但是系统出故障了，导致 consumer 有些消息处理了，但是没来得及提交 offset，重启之后，少数消息会再次消费一次，那么就会导致重复消费</li><li>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致数据在数据库里插入了 2 次，那么数据就错啦</li><li>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</li><li>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</li><li>保证消息队列消费的幂等性还是得结合业务来思考<ul><li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li><li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li><li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul></li></ul><h1 id="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"><a href="#如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？" class="headerlink" title="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"></a>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</h1><ul><li>数据的丢失问题，可能出现在生产者、MQ、消费者中</li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul><li>生产者弄丢了数据<ul><li>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，如网络问题等。</li><li>选择用 RabbitMQ 提供的事务功能<ul><li>生产者发送数据之前开启 RabbitMQ 事务channel.txSelect</li><li>然后发送消息</li><li>如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息</li><li>如果收到了消息，那么可以提交事务channel.txCommit。</li><li>事务的缺点是吞吐量会下来，因为太耗性能</li></ul></li><li>开启confirm模式<ul><li>在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，告诉你说这个消息 ok 了</li><li>如果 RabbitMQ 没能处理这个消息，会回调你的一个nack接口，告诉你这个消息接收失败，你可以重试</li><li>而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发</li></ul></li><li>事务机制和confirm机制最大的不同在于<ul><li>事务机制是同步的，你提交一个事务之后会阻塞在那儿</li><li>confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了</li></ul></li><li>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</li></ul></li><li>RabbitMQ 弄丢了数据<ul><li>就是 RabbitMQ 自己弄丢了数据</li><li>这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢</li><li>除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</li><li>设置持久化有两个步骤：<ul><li>创建 queue 的时候将其设置为持久化，这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的</li><li>发送消息的时候将消息的deliveryMode设置为 2，就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去</li></ul></li><li>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据</li><li>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失</li><li>所以，持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到ack，你也是可以自己重发的</li></ul></li><li>消费端弄丢了数据<ul><li>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，RabbitMQ 认为你都消费了，这数据就丢了。</li><li>这个时候得用 RabbitMQ 提供的ack机制<ul><li>就是关闭 RabbitMQ 的自动ack</li><li>可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把</li><li>这样的话，如果你还没处理完，不就没有ack了，RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的</li></ul></li></ul></li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li>消费端弄丢了数据<ul><li>唯一可能导致消费者弄丢数据的情况，就是消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实消息还没处理，系统挂了，此时这条消息就丢了</li><li>需要关闭自动提交offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢</li></ul></li><li>Kafka弄丢了数据<ul><li>如果Kafka某个broker宕机，然后重新选举 partition 的 leader，此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，这就丢了一些数据</li><li>所以此时一般是要求起码设置如下 4 个参数<ul><li>给 topic 设置replication.factor参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本</li><li>在 Kafka 服务端设置min.insync.replicas参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower</li><li>在 producer 端设置acks&#x3D;all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了</li><li>在 producer 端设置retries&#x3D;MAX（很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试</li></ul></li><li>按照上述要求配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失</li></ul></li><li>生产者会不会弄丢数据<ul><li>如果按照上述的思路设置了acks&#x3D;all，一定不会丢</li><li>因为leader接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了，如果没满足这个条件，生产者会自动不断的重试，重试无限次</li></ul></li></ul><h1 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h1><ul><li>消息顺序错乱场景<ul><li>RabbitMQ：一个 queue，多个 consumer<ul><li>比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列</li><li>有三个消费者分别从MQ中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3，顺序就乱了。</li></ul></li><li>Kafka：一个 topic，一个 partition，一个consumer，consumer是多线程的<ul><li>生产者在写的时候，其实可以指定一个 key，比如订单 id 作为 key，那么这个数据一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的</li><li>消费者从 partition 中取出来数据的时候，也一定是有顺序的</li><li>如果消费用多个线程来并发处理消息，顺序可能就乱掉了</li></ul></li></ul></li><li>解决方案<ul><li>RabbitMQ<ul><li>拆分多个 queue，每个 queue 一个 consumer</li><li>或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理</li></ul></li><li>Kafka<ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue，然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性</li></ul></li></ul></li></ul><h1 id="有几百万消息持续积压几小时，说说怎么解决？"><a href="#有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="有几百万消息持续积压几小时，说说怎么解决？"></a>有几百万消息持续积压几小时，说说怎么解决？</h1><ul><li>先假设一个场景，我们现在消费端出故障了，然后大量消息在MQ里积压，大量消息在MQ里积压了几个小时了还没解决。这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕，一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来</li><li>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：<ul><li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据</li><li>这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据</li><li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息</li></ul></li></ul><h1 id="如何解决消息队列的延时以及过期失效问题？"><a href="#如何解决消息队列的延时以及过期失效问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？"></a>如何解决消息队列的延时以及过期失效问题？</h1><ul><li>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL，如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了</li><li>这个情况下，我们可以采取一个方案，就是批量重导，就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入MQ里面去，把白天丢的数据给他补回来</li><li>假设 1 万个订单积压在MQ里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到MQ里去再补一次</li></ul><h1 id="消息队列满了以后该怎么处理？"><a href="#消息队列满了以后该怎么处理？" class="headerlink" title="消息队列满了以后该怎么处理？"></a>消息队列满了以后该怎么处理？</h1><ul><li>如果消息积压在MQ里，你很长时间都没有处理掉，此时导致MQ都快写满了<ul><li>临时写程序，接入数据来消费，消费一个丢弃一个</li><li>都不要了，快速消费掉所有的消息。然后走批量重导的方案，到了晚上再补数据</li></ul></li></ul><h1 id="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"><a href="#如果让你写一个消息队列，该如何进行架构设计？说一下你的思路" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"></a>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</h1><ul><li>其实回答这类问题，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好</li><li>比如说这个消息队列系统，我们从以下几个角度来考虑一下<ul><li>可伸缩性<ul><li>就是需要的时候快速扩容，就可以增加吞吐量和容量，设计个分布式的系统，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据，如果现在资源不够了，给 topic 增加 partition，然后做数据迁移，增加机器，就可以存放更多数据，提供更高的吞吐量了</li></ul></li><li>数据要落地磁盘<ul><li>落磁盘才能保证别进程挂了数据就丢了，那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路</li></ul></li><li>高可用性<ul><li>具体参考kafka的高可用保障机制，多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务</li></ul></li><li>能不能支持数据 0 丢失<ul><li>可以的，参考 kafka 数据零丢失方案</li></ul></li></ul></li></ul><h1 id="四款消息队列的对比"><a href="#四款消息队列的对比" class="headerlink" title="四款消息队列的对比"></a>四款消息队列的对比</h1><h2 id="MSMQ"><a href="#MSMQ" class="headerlink" title="MSMQ"></a>MSMQ</h2><ul><li>这是微软的产品里唯一被认为有价值的东西</li><li>这个东西并不复杂，除了接收和发送，没有别的</li><li>它有一些硬性限制，比如最大消息体积是4MB，然而，通过和一些像MassTransit 或 NServiceBus这样的软件的连接，它完全可以解决这些问题</li><li>优点：<ul><li>由于是异步通信，无论是发送方还是接收方都不用等待对方返回成功消息，就可以执行余下的代码，因而大大地提高了事物处理的能力</li><li>当信息传送过程中，信息发送机制具有一定功能的故障恢复能力</li><li>MSMQ的消息传递机制使得消息通信的双方具有不同的物理平台成为可能</li></ul></li></ul><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><ul><li>多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li><li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务）</li><li>对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性</li><li>通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic）的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上</li><li>支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>支持通过JDBC和journal提供高速的消息持久化</li><li>从设计上保证了高性能的集群，客户端-服务器，点对点</li><li>支持Ajax</li><li>支持与Axis的整合</li><li>可以很容易得调用内嵌JMS provider，进行测试</li></ul><h2 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul><li>它支持开放的高级消息队列协议 (AMQP，Advanced Message Queuing Protocol)</li><li>从根本上避免了生产厂商的封闭，使用任何语言的各种客户都可以从中受益</li><li>这种协议提供了相当复杂的消息传输模式，所以基本上不需要 MassTransit 或 NServiceBus 的配合</li></ul><h2 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h2><ul><li>ZeroMQ 是一个轻量级消息内核</li><li>它可用于C、C++、Python、.NET &#x2F;Mono、Fortran和Java语言</li><li>它运行在AIX ， FreeBSD的，基于HP - UX ， Linux和MacOS下， OpenBSD系统， OpenVMS ， QNX Neutrino， Solaris和Windows操作系统。</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>ActiveMQ需要在目标机器上安装Java，RabbitMQ需要Erlang环境</li><li>ActiveMQ,RabbitMQ 和 MSMQ 都需要启动服务进程，这些都可以监控和配置，另外一个就有问题了</li><li>ZeroMQ，它没有中间件架构，不需要任何服务进程和运行时，事实上，你的应用程序端点扮演了这个服务角色，这让部署起来非常简单，但担心的是，你没有地方可以观察它是否有问题出现。就目前我知道的，ZeroMQ仅提供非持久性的队列，你可以在需要的地方实现自己的审计和数据恢复功能</li><li>如果你希望一个应用程序发送消息越快越好，你选择ZeroMQ，当你不太在意偶然会丢失某些消息的情况下更有价值</li><li>虽然说ZeroMQ的速度很惊人，但是对于数据就是生命的年代，我们宁可降低一些需求也不愿意丢失任何一条宝贵的数据，所以综合对比下来，我觉得RabbitMQ更适合</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/4/">4</a><span class="page-number current">5</span></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">449k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:48</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>