<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/5/index.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/5/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/5/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">58</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/22829df8f04f.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/22829df8f04f.html" class="post-title-link" itemprop="url">Java基础</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 17:16:47" itemprop="dateModified" datetime="2024-01-04T17:16:47+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>45k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>41 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="获得Class对象的⽅式"><a href="#获得Class对象的⽅式" class="headerlink" title="获得Class对象的⽅式"></a>获得Class对象的⽅式</h1><ul><li>静态类的.class语法：GuideUtil.class</li><li>普通类对象的getClass()⽅法：new Test().getClass()</li><li>通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”);</li><li>对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE</li></ul><h1 id="在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>在 Java 中，为什么不允许从静态方法中访问非静态变量？</h1><ul><li>因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联</li></ul><h1 id="在-Java-中，什么时候用重载，什么时候用重写？"><a href="#在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="在 Java 中，什么时候用重载，什么时候用重写？"></a>在 Java 中，什么时候用重载，什么时候用重写？</h1><ul><li>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding）</li><li>而重载（overloading）是用不同的输入做同一件事</li><li>在 Java 中，重载的方法签名不同，而重写并不是。</li></ul><h1 id="举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>举例说明什么情况下会更倾向于使用抽象类而不是接口？</h1><ul><li>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求</li><li>在 Java 中，你只能继承一个类，但可以实现多个接口</li><li>所以一旦你继承了一个类，你就失去了继承其他类的机会了。</li><li>接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable(注：这里的意思是指如果把 Runnable 等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</li><li>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</li><li>如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择</li><li>有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</li></ul><h1 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h1><ul><li>调用该访问返回一个以字符串指定类名的类的对象。</li></ul><h1 id="Jdo是什么"><a href="#Jdo是什么" class="headerlink" title="Jdo是什么?"></a>Jdo是什么?</h1><ul><li>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API</li><li>JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）</li><li>这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上</li><li>另外，JDO很灵活，因为它可以在任何数据底层上运行</li><li>JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。</li></ul><h1 id="HashMap-，HashTable-区别"><a href="#HashMap-，HashTable-区别" class="headerlink" title="HashMap ，HashTable 区别"></a>HashMap ，HashTable 区别</h1><ul><li>默认容量不同。扩容不同</li><li>线程安全性，HashTable 安全</li><li>效率不同 HashTable 要慢因为加锁</li></ul><h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul><li>数组 + 链表方式存储</li><li>默认容量：11(质数 为宜)</li><li>put:<ul><li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li><li>若在链表中找到了，则替换旧值，若未找到则继续</li><li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li><li>将新元素加到链表头部</li><li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。</li></ul></li></ul><h1 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h1><ul><li>默认的负载因子大小为0.75</li><li>也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组来重新调整map的大小，并将原来的对象放入新的bucket数组中。</li><li>这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</li></ul><h1 id="EJB与JavaBean的区别？"><a href="#EJB与JavaBean的区别？" class="headerlink" title="EJB与JavaBean的区别？"></a>EJB与JavaBean的区别？</h1><ul><li>Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于JavaBean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器。另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。</li><li>Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。</li></ul><h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</li><li>下面列出了使用封装的一些好处：<ul><li>通过隐藏对象的属性来保护对象内部的状态。</li><li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li><li>禁止对象之间的不良交互提高模块化</li></ul></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</li></ul><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul><li>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</li></ul><h1 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h1><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul><li>修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>在异常处理时提供 finally 块来执行任何清除操作</li><li>如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ul><li>方法名</li><li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</li><li>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h4 id="override（重写）"><a href="#override（重写）" class="headerlink" title="override（重写）"></a>override（重写）</h4><ul><li>方法名、参数、返回值相同。</li><li>子类方法不能缩小父类方法的访问权限。</li><li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li><li>存在于父类和子类之间。</li><li>方法被定义为final不能被重写。</li></ul><h4 id="overload（重载）"><a href="#overload（重载）" class="headerlink" title="overload（重载）"></a>overload（重载）</h4><ul><li>参数类型、个数、顺序至少有一个不相同。</li><li>不能重载只有返回值不同的方法名。</li><li>存在于父类和子类、同类中。</li></ul><h1 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h1><ul><li>接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。</li><li>还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。</li></ul><h1 id="Java1-7与1-8-1-9-10-新特性"><a href="#Java1-7与1-8-1-9-10-新特性" class="headerlink" title="Java1.7与1.8,1.9,10 新特性"></a>Java1.7与1.8,1.9,10 新特性</h1><h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4><ul><li>switch中可以使用字串了</li><li>运用List tempList &#x3D; new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断</li><li>语法上支持集合，而不一定是数组</li><li>新增一些取环境信息的工具方法</li><li>Boolean类型反转，空指针安全,参与位运算</li><li>两个char间的equals</li><li>安全的加减乘除</li><li>map集合支持并发请求，且可以写成 Map map &#x3D; {name:”xxx”,age:18};</li></ul><h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><ul><li>允许在接口中有默认方法实现</li><li>Lambda表达式</li><li>函数式接口</li><li>方法和构造函数引用</li><li>Lambda的范围</li><li>内置函数式接口</li><li>Streams</li><li>Parallel Streams</li><li>Map</li><li>时间日期API</li><li>Annotations</li></ul><h4 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h4><ul><li>Jigsaw 项目;模块化源码</li><li>简化进程API</li><li>轻量级 JSON API</li><li>钱和货币的API</li><li>改善锁争用机制</li><li>代码分段缓存</li><li>智能Java编译, 第二阶段</li><li>HTTP 2.0客户端</li><li>Kulla计划: Java的REPL实现</li></ul><h1 id="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"><a href="#解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI" class="headerlink" title="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"></a>解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI</h1><ul><li>web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。</li><li>EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。</li><li>JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</li><li>JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</li><li>JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</li><li>JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</li><li>RMI&#x2F;IIOP:（Remote Method Invocation &#x2F;internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。</li></ul><h1 id="Class类的作用？生成Class对象的方法有哪些？"><a href="#Class类的作用？生成Class对象的方法有哪些？" class="headerlink" title="Class类的作用？生成Class对象的方法有哪些？"></a>Class类的作用？生成Class对象的方法有哪些？</h1><ul><li>Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类</li><li>Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口</li><li>方法示例<ul><li>getClass()</li><li>getSuperClass()</li><li>.class</li><li>.TYPE</li></ul></li></ul><h1 id="序列化的定义、实现和注意事项"><a href="#序列化的定义、实现和注意事项" class="headerlink" title="序列化的定义、实现和注意事项"></a>序列化的定义、实现和注意事项</h1><ul><li>想把一个对象写在硬盘上或者网络上，对其进行序列化，把他序列化成为一个字节流。</li><li>实现和注意事项：<ul><li>实现接口Serializable Serializable接口中没有任何的方法，实现该接口的类不需要实现额外的方法。</li><li>如果对象中的某个属性是对象类型，必须也实现Serializable接口才可以，序列化对静态变量无效</li><li>如果不希望某个属性参与序列化，不是将其static，而是transient</li></ul></li><li>串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存</li><li>序列化版本不兼容</li></ul><h1 id="java-sql-Date和java-util-Date的联系和区别"><a href="#java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="java.sql.Date和java.util.Date的联系和区别"></a>java.sql.Date和java.util.Date的联系和区别</h1><ul><li>java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</li><li>JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002&#x2F;05&#x2F;22 5:00:57 PM的字段，读取日期时得到的是2002&#x2F;05&#x2F;22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.sql.Timestamp类比java.util.Date类精确度要高。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用…</li><li>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。</li></ul><h1 id="String-s-new-String-“xyz”-创建几个String-Object"><a href="#String-s-new-String-“xyz”-创建几个String-Object" class="headerlink" title="String s &#x3D; new String(“xyz”);创建几个String Object?"></a>String s &#x3D; new String(“xyz”);创建几个String Object?</h1><ul><li>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个</li><li>New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象</li><li>如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</li></ul><h1 id="String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？"><a href="#String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？" class="headerlink" title="String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？"></a>String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？</h1><ul><li>没有改变。</li><li>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</li></ul><h1 id="基本数据类型有哪些"><a href="#基本数据类型有哪些" class="headerlink" title="基本数据类型有哪些"></a>基本数据类型有哪些</h1><ul><li>byte、short、char、int、long、float、double、boolean</li></ul><h1 id="String、StringBuffer、StringBuilder区别与联系"><a href="#String、StringBuffer、StringBuilder区别与联系" class="headerlink" title="String、StringBuffer、StringBuilder区别与联系"></a>String、StringBuffer、StringBuilder区别与联系</h1><ul><li>String类是字符序列不可变的类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。</li><li>StringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setChartAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String</li><li>JDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder</li></ul><h1 id="String类为什么是final的"><a href="#String类为什么是final的" class="headerlink" title="String类为什么是final的"></a>String类为什么是final的</h1><ul><li>为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。</li><li>为了安全。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的， 和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的， 这不就成了核心病毒了么？</li><li>不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性， 如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点；</li></ul><h1 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h1><ul><li>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</li><li>int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</li><li>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</li><li>Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</li></ul><h1 id="异常处理中throws和throw的区别"><a href="#异常处理中throws和throw的区别" class="headerlink" title="异常处理中throws和throw的区别"></a>异常处理中throws和throw的区别</h1><ul><li>作用不同：<ul><li>throw用于程序员自行产生并抛出异常；</li><li>throws用于声明在该方法内抛出了异常</li></ul></li><li>使用的位置不同：<ul><li>throw位于方法体内部，可以作为单独语句使用；</li><li>throws必须跟在方法参数列表的后面，不能单独使用。</li></ul></li><li>内容不同：<ul><li>throw抛出一个异常对象，且只能是一个；</li><li>throws后面跟异常类，而且可以有多个。</li></ul></li></ul><h1 id="Java异常处理try-catch-finally的执行过程"><a href="#Java异常处理try-catch-finally的执行过程" class="headerlink" title="Java异常处理try-catch-finally的执行过程"></a>Java异常处理try-catch-finally的执行过程</h1><ul><li>try-catch-finally程序块的执行流程以及执行结果比较复杂。</li><li>基本执行过程如下：<ul><li>程序首先执行可能发生异常的try语句块。</li><li>如果try语句没有出现异常则执行完后跳至finally语句块执行；</li><li>如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。</li><li>catch语句块可以有多个，分别捕获不同类型的异常。</li><li>catch语句块执行完后程序会继续执行finally语句块。</li></ul></li><li>finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。需要注意的是即使try和catch块中存在return语句，finally语句也会执行，是在执行完finally语句后再通过return退出。</li></ul><h1 id="运行时异常与受检异常有何异同"><a href="#运行时异常与受检异常有何异同" class="headerlink" title="运行时异常与受检异常有何异同"></a>运行时异常与受检异常有何异同</h1><ul><li>运行时异常：包括RuntimeaException及其所有子类。不要求程序必须对它们作出处理，比如InputMismatchException、ArithmeticException、NullPointerException等。即使没有显示使用try-catch或throws进行处理，仍旧可以进行编译和运行(其实是JVM隐式的使用try-catch或throws进行处理)。如果运行时发生异常，会输出异常的堆栈信息并中止程序执行。</li><li>Checked异常（非运行时异常）：除了运行时异常外的其他异常类都是Checked异常，程序必须捕获或者声明抛出这种异常，否则出现编译错误，无法通过编译。处理方式包括两种：通过try-catch捕获异常，通过throws声明抛出异常从而交给上一级调用方法处理。</li></ul><h1 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h1><ul><li>Error类，表示仅靠程序本身无法恢复的严重错误，比如说内存溢出、动态链接异常、虚拟机错误。应用程序不应该抛出这种类型的对象。假如出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。所以在进行程序设计时，应该更关注Exception类。</li><li>Exception类，由Java应用程序抛出和处理的非严重错误，比如所需文件没有找到、零作除数，数组下标越界等。它的各种不同子类分别对应不同类型异常。可分为两类：Checked异常和Runtime异常</li></ul><h1 id="和equals的区别和联系"><a href="#和equals的区别和联系" class="headerlink" title="&#x3D;&#x3D;和equals的区别和联系"></a>&#x3D;&#x3D;和equals的区别和联系</h1><ul><li>“&#x3D;&#x3D;”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</li><li>“&#x3D;&#x3D;”使用情况如下：<ul><li>基本类型，比较的是值</li><li>引用类型，比较的是地址</li><li>不能比较没有父子关系的两个对象</li></ul></li><li>equals()方法使用如下：<ul><li>系统类一般已经覆盖了equals()，比较的是内容。</li><li>用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this &#x3D;&#x3D; obj);）</li><li>用户自定义类需要覆盖父类的equals()</li></ul></li><li>注意：Object的&#x3D;&#x3D;和equals比较的都是地址，作用相同</li></ul><h1 id="继承条件下构造方法的执行过程"><a href="#继承条件下构造方法的执行过程" class="headerlink" title="继承条件下构造方法的执行过程"></a>继承条件下构造方法的执行过程</h1><ul><li>继承条件下构造方法的调用规则如下：<ul><li>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</li><li>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li><li>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</li></ul></li><li>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li></ul><h1 id="权限修饰符的区别"><a href="#权限修饰符的区别" class="headerlink" title="权限修饰符的区别"></a>权限修饰符的区别</h1><ul><li>类的访问权限只有两种<ul><li>public 公共的 可被同一项目中所有的类访问。 (必须与文件名同名)</li><li>default 默认的 可被同一个包中的类访问。</li></ul></li><li>成员（成员变量或成员方法）访问权限共有四种：<ul><li>public 公共的 可以被项目中所有的类访问。(项目可见性)</li><li>protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）</li><li>default 默认的被这个类本身访问；被同一个包中的类访问。（包可见性）</li><li>private 私有的只能被这个类本身访问。（类可见性）</li></ul></li></ul><h1 id="final和abstract关键字的作用"><a href="#final和abstract关键字的作用" class="headerlink" title="final和abstract关键字的作用"></a>final和abstract关键字的作用</h1><ul><li>final和abstract是功能相反的两个关键字，可以对比记忆</li><li>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</li><li>final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</li><li>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li></ul><h1 id="static关键字的作用（修饰变量、方法、代码块）"><a href="#static关键字的作用（修饰变量、方法、代码块）" class="headerlink" title="static关键字的作用（修饰变量、方法、代码块）"></a>static关键字的作用（修饰变量、方法、代码块）</h1><ul><li>static可以修饰变量、方法、代码块和内部类</li><li>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</li><li>static变量和非static变量的区别(都是成员变量，不是局部变量)<ul><li>在内存中份数不同<ul><li>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</li><li>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</li></ul></li><li>在内存中存放的位置不同<ul><li>静态变量存在方法区中，实例变量存在堆内存中</li></ul></li><li>访问的方式不同<ul><li>实例变量： 对象名.变量名 stu1.name&#x3D;”小明明”;</li><li>静态变量：对象名.变量名 stu1.schoolName&#x3D;”西二旗小学”; 不推荐如此使用</li><li>类名.变量名 Student.schoolName&#x3D;”东三旗小学”; 推荐使用</li></ul></li><li>在内存中分配空间的时间不同<ul><li>实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候</li><li>Student.schoolName&#x3D;”东三旗小学”;或者Student stu1 &#x3D; new Student(“小明”,”男”,20,98);</li><li>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</li><li>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</li><li>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员</li></ul></li></ul></li></ul><h1 id="this和super关键字的作用"><a href="#this和super关键字的作用" class="headerlink" title="this和super关键字的作用"></a>this和super关键字的作用</h1><ul><li>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题</li><li>this可以调用成员变量，不能调用局部变量</li><li>this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句，而且在静态方法当中不允许出现this关键字。</li><li>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</li><li>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</li></ul><h1 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h1><ul><li>面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li><li>封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</li><li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</li></ul><h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><ul><li>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</li><li>类和对象好比图纸和实物的关系，模具和铸件的关系。</li></ul><h1 id="可变参数的作用和特点"><a href="#可变参数的作用和特点" class="headerlink" title="可变参数的作用和特点"></a>可变参数的作用和特点</h1><ul><li>可变参数<ul><li>可变参数的形式 …</li><li>可变参数只能是方法的形参</li><li>可变参数对应的实参可以0,1,2…..个，也可以是一个数组</li><li>在可变参数的方法中，将可变参数当做数组来处理</li><li>可变参数最多有一个，只能是最后一个</li><li>可变参数好处：方便 简单 减少重载方法的数量</li><li>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</li></ul></li><li>数组做形参和可变参数做形参联系和区别</li><li>联系：<br>-实参都可以是数组；2.方法体中，可变参数当做数组来处理</li><li>区别：<ul><li>个数不同	可变参数只能有一个数组参数可以多个</li><li>位置不同	可变参数只能是最后一个	数组参数位置任意</li><li>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</li></ul></li></ul><h1 id="递归的定义和优缺点"><a href="#递归的定义和优缺点" class="headerlink" title="递归的定义和优缺点"></a>递归的定义和优缺点</h1><ul><li>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</li><li>递归算法解决问题的特点：<ul><li>递归就是在过程或函数里调用自身。</li><li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li><li>递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</li><li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</li></ul></li></ul><h1 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h1><ul><li>break: 结束当前循环并退出当前循环体。</li><li>break还可以退出switch语句</li><li>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。</li></ul><h1 id="while和do-while循环的区别"><a href="#while和do-while循环的区别" class="headerlink" title="while和do-while循环的区别"></a>while和do-while循环的区别</h1><ul><li>while先判断后执行，第一次判断为false,循环体一次都不执行</li><li>do while先执行 后判断，最少执行1次。</li><li>如果while循环第一次判断为true, 则两种循环没有区别。</li></ul><h1 id="用最有效率的方法算出2乘以8等于多少"><a href="#用最有效率的方法算出2乘以8等于多少" class="headerlink" title="用最有效率的方法算出2乘以8等于多少"></a>用最有效率的方法算出2乘以8等于多少</h1><ul><li>使用位运算来实现效率最高</li><li>位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数</li><li>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高</li><li>所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</li></ul><h1 id="和-的区别和联系，-和-的区别和联系"><a href="#和-的区别和联系，-和-的区别和联系" class="headerlink" title="&amp;和&amp;&amp;的区别和联系，|和||的区别和联系"></a>&amp;和&amp;&amp;的区别和联系，|和||的区别和联系</h1><ul><li>&amp;和&amp;&amp;的联系(共同点)：<ul><li>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</li><li>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</li><li>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</li><li>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li><li>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li><li>表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</li></ul></li><li>&amp;和&amp;&amp;的区别(不同点)<ul><li>&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。</li><li>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</li><li>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</li><li>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</li><li>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</li></ul></li><li>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</li></ul><h1 id="i-和-i的异同之处"><a href="#i-和-i的异同之处" class="headerlink" title="i++和++i的异同之处"></a>i++和++i的异同之处</h1><ul><li>共同点：<ul><li>i++和++i都是变量自增1，都等价于i&#x3D;i+1</li><li>如果i++,++i是一条单独的语句，两者没有任何区别</li><li>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</li></ul></li><li>不同点：<ul><li>如果i++,++i不是一条单独的语句，他们就有区别</li><li>i++ ：先运算后增1。如：int x&#x3D;5;</li><li>int y&#x3D;x++;</li><li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li><li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;5++i ： 先增1后运算。如：</li><li>int x&#x3D;5;</li><li>int y&#x3D;++x;</li><li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li><li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;6334.</li></ul></li></ul><h1 id="JDK-JRE-JVM三者关系概括如下："><a href="#JDK-JRE-JVM三者关系概括如下：" class="headerlink" title="JDK,JRE,JVM三者关系概括如下："></a>JDK,JRE,JVM三者关系概括如下：</h1><ul><li>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE</li><li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了</li><li>JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li></ul><h1 id="Java跨平台原理"><a href="#Java跨平台原理" class="headerlink" title="Java跨平台原理"></a>Java跨平台原理</h1><ul><li>C&#x2F;C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</li><li>Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</li><li>字节码文件不面向任何具体平台，只面向虚拟机。</li><li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li><li>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C&#x2F;C++要低。</li><li>Java的跨平台原理决定了其性能没有C&#x2F;C++高</li></ul><h1 id="Java的安全性"><a href="#Java的安全性" class="headerlink" title="Java的安全性"></a>Java的安全性</h1><ul><li>语言层次的安全性主要体现在：<ul><li>Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</li><li>垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。</li><li>异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</li><li>强制类型转换：只有在满足强制转换规则的情况下才能强转成功。</li></ul></li><li>底层的安全性可以从以下方面来说明<ul><li>Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。</li></ul></li><li>在运行环境提供了四级安全性保障机制：<ul><li>字节码校验器 -类装载器 -运行时内存布局 -文件访问限制</li></ul></li></ul><h1 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h1><ul><li>对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术</li><li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（可以用XML或者是注解），将Java程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</li></ul><h1 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h1><ul><li>DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作</li><li>为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中</li><li>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法</li><li>在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储</li><li>DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</li></ul><h1 id="UML是什么？UML中有哪些图？"><a href="#UML是什么？UML中有哪些图？" class="headerlink" title="UML是什么？UML中有哪些图？"></a>UML是什么？UML中有哪些图？</h1><ul><li>UML是统一建模语言（Unified Modeling Language）的缩写，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为</li><li>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等</li><li>在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</li></ul><h1 id="Java-中有几种类型的流？"><a href="#Java-中有几种类型的流？" class="headerlink" title="Java 中有几种类型的流？"></a>Java 中有几种类型的流？</h1><ul><li>两种流分别是字节流，字符流。</li><li>字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer</li><li>在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</li><li>关于Java的IO需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</li></ul><h1 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h1><ul><li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间</li><li>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</li><li>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</li></ul><h1 id="什么时候用assert？"><a href="#什么时候用assert？" class="headerlink" title="什么时候用assert？"></a>什么时候用assert？</h1><ul><li>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制</li><li>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。</li></ul><h1 id="比较一下Java-和JavaSciprt"><a href="#比较一下Java-和JavaSciprt" class="headerlink" title="比较一下Java 和JavaSciprt"></a>比较一下Java 和JavaSciprt</h1><ul><li>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。</li><li>下面对两种语言间的异同作如下比较：<ul><li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</li><li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</li><li>代码格式不一样。</li></ul></li><li>上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</li></ul><p> </p><h1 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h1><ul><li><p>代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;你好&quot;;</span><br><span class="line">String s2 = newString(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); </span><br></pre></td></tr></table></figure></li><li><p>在String类的构造方法当中，存在一个字符集设置的方法</p></li></ul><h1 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h1><ul><li>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</li><li>如果要访问外部类的局部变量，此时局部变量必须使用final修饰，否则无法访问。</li></ul><h1 id="匿名内部类是否可以继承其它类？是否可以实现接口？"><a href="#匿名内部类是否可以继承其它类？是否可以实现接口？" class="headerlink" title="匿名内部类是否可以继承其它类？是否可以实现接口？"></a>匿名内部类是否可以继承其它类？是否可以实现接口？</h1><ul><li>可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。</li></ul><h1 id="一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h1><ul><li>可以，但一个源文件中最多只能有一个公开类（public class）</li><li>而且文件名必须和公开类的类名完全保持一致。</li></ul><p> </p><h1 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h1><ul><li>接口可以继承接口</li><li>抽象类可以实现(implements)接口，抽象类可以继承具体类</li><li>抽象类中可以有静态的main方法。</li></ul><h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><ul><li>有两种方式：<ul><li>实现Cloneable接口并重写Object类中的clone()方法；</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</li></ul></li><li>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</li></ul><h1 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h1><ul><li>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</li></ul><p> </p><h1 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h1><ul><li>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝</li><li>实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存</li><li>两者的相同点：都有默认值而且在类的任何地方都可以调用</li></ul><h1 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h1><ul><li>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的</li><li>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li><li>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li></ul><h1 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h1><ul><li>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）</li><li>然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露</li><li>一个例子就是hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象</li></ul><h1 id="静态内部类和内部类有什么区别"><a href="#静态内部类和内部类有什么区别" class="headerlink" title="静态内部类和内部类有什么区别"></a>静态内部类和内部类有什么区别</h1><ul><li>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</li><li>内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</li><li>在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类</li><li>Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class</li><li>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</li><li>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化</li></ul><h1 id="char-型变量中能不能存贮一个中文汉字-为什么"><a href="#char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char 型变量中能不能存贮一个中文汉字?为什么?"></a>char 型变量中能不能存贮一个中文汉字?为什么?</h1><ul><li>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦</li></ul><h1 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h1><ul><li>是值传递</li><li>Java 编程语言只有值传递参数</li><li>当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用</li><li>对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。</li></ul><h1 id="是否可以继承String-类"><a href="#是否可以继承String-类" class="headerlink" title="是否可以继承String 类?"></a>是否可以继承String 类?</h1><ul><li>String 类是final类，不可以被继承。</li></ul><h1 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</h1><ul><li>不对</li><li>如果两个对象x和y满足x.equals(y) &#x3D;&#x3D;++++ true，它们的哈希码（hash code）应当相同</li><li>Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同</li></ul><h1 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）?"></a>构造器（constructor）是否可被重写（override）?</h1><ul><li>构造器不能被继承，因此不能被重写，但可以被重载。</li></ul><h1 id="在Java-中，如何跳出当前的多重嵌套循环？"><a href="#在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java 中，如何跳出当前的多重嵌套循环？"></a>在Java 中，如何跳出当前的多重嵌套循环？</h1><ul><li>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</li><li>Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好</li></ul><h1 id="数组有没有length-方法-String-有没有length-方法？"><a href="#数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="数组有没有length()方法?String 有没有length()方法？"></a>数组有没有length()方法?String 有没有length()方法？</h1><ul><li>数组没有length()方法，有length 的属性</li><li>String 有length()方法</li><li>JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</li></ul><h1 id="swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h1><ul><li>早期的JDK中，switch（expr）中，expr可以是byte、short、char、int</li><li>从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举</li><li>从JDK 1.7版开始，还可以是字符串（String）</li><li>长整型（long）是不可以的。</li></ul><h1 id="Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?"></a>Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h1><ul><li>Math.round(11.5)的返回值是12</li><li>Math.round(-11.5)的返回值是-11</li><li>四舍五入的原理是在参数上加0.5然后进行下取整。</li></ul><p> </p><h1 id="解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h1><ul><li><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间</p></li><li><p>而通过new关键字和构造器创建的对象放在堆空间</p></li><li><p>程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中</p></li><li><p>栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“hello”);</span><br></pre></td></tr></table></figure></li><li><p>上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。</p></li><li><p>较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p></li></ul><h1 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h1><ul><li>&amp;运算符有两种用法<ul><li>按位与</li><li>逻辑与</li></ul></li><li>&amp;&amp;运算符是短路与运算</li><li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true</li><li>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</li><li>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常</li><li>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</li></ul><h1 id="Java-有没有goto"><a href="#Java-有没有goto" class="headerlink" title="Java 有没有goto?"></a>Java 有没有goto?</h1><ul><li>goto 是Java中的保留字，在目前版本的Java中没有使用</li><li>其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字</li></ul><h1 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?</h1><ul><li>对于short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型</li><li>而short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为s1+&#x3D; 1;相当于s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。</li></ul><h1 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确?"></a>float f&#x3D;3.4;是否正确?</h1><ul><li>不正确</li><li>3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成float f &#x3D;3.4F;。</li></ul><h1 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h1><ul><li>不是</li><li>Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</li></ul><h1 id="访问修饰符的区别？"><a href="#访问修饰符的区别？" class="headerlink" title="访问修饰符的区别？"></a>访问修饰符的区别？</h1><table><thead><tr><th>作用域</th><th>当前类</th><th>同包</th><th>子类</th><th>其他</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</li></ul><p> </p><h1 id="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><a href="#如果变量用final修饰，则怎样？如果方法final修饰，则怎样？" class="headerlink" title="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"></a>如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</h1><ul><li>用final修饰的类不能被扩展，也就是说不可能有子类；</li><li>用final修饰的方法不能被替换或隐藏：<ul><li>使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</li><li>使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏	（hidden）；</li></ul></li><li>用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：<ul><li>静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量， 赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，	赋值只能在其声明中通过初始化表达式完成；</li><li>实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通	过初始化表达式完成，也可以在实例初始化块或构造器中进行；</li><li>方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体	（body）结束，在此期间其值不能改变；</li><li>构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，	同时被初始化为对应实参值，终止于构造器体结束，在此期间其值不能改变；</li><li>异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化	为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</li><li>局部变量在其值被访问之前必须被明确赋值；</li></ul></li></ul><h1 id="成员变量用static修饰和不用static修饰有什么区别？"><a href="#成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="成员变量用static修饰和不用static修饰有什么区别？"></a>成员变量用static修饰和不用static修饰有什么区别？</h1><ul><li>两个变量的生命周期不同。<ul><li>成员变量随着对象的创建而存在，随着对象的被回收而释放。</li><li>静态变量随着类的加载而存在，随着类的消失而消失。</li></ul></li><li>调用方式不同。<ul><li>成员变量只能被对象调用。</li><li>静态变量可以被对象调用，还可以被类名调用。</li><li>对象调用：p.country</li><li>类名调用 ：Person.country</li></ul></li><li>别名不同。<ul><li>成员变量也称为实例变量。</li><li>静态变量称为类变量。</li></ul><p> </p></li><li>数据存储位置不同。<ul><li>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.</li><li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.</li></ul></li></ul><h1 id="System-out-println-‘a’-1-的结果是"><a href="#System-out-println-‘a’-1-的结果是" class="headerlink" title="System.out.println(‘a’+1);的结果是"></a>System.out.println(‘a’+1);的结果是</h1><ul><li>‘a’是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98</li></ul><h1 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h1><ul><li>NullPointerException：一般都是在null对象上调用方法了。</li><li>NumberFormatException：继承IllegalArgumentException，字符串转换为数字时。</li><li>StringIndexOutOfBoundsException：字符串越界</li><li>ClassCastException:类型转换错误</li></ul><h1 id="200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><a href="#200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？" class="headerlink" title="200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"></a>200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</h1><ul><li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li><li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序</li><li>Collections 工具类的sort方法有两种重载的形式<ul><li>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul></li></ul><h1 id="199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><a href="#199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？" class="headerlink" title="199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"></a>199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</h1><ul><li>构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法</li></ul><h1 id="char型变量中能不能存储一个中文汉字？"><a href="#char型变量中能不能存储一个中文汉字？" class="headerlink" title="char型变量中能不能存储一个中文汉字？"></a>char型变量中能不能存储一个中文汉字？</h1><ul><li>java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。</li><li>char 在java中是2个字节，所以可以存储中文</li></ul><h1 id="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"><a href="#创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。" class="headerlink" title="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"></a>创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</h1><ul><li>用一个for循环创建线程对象并调用start方法启动线程。</li></ul><h1 id="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><a href="#Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？" class="headerlink" title="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"></a>Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</h1><ul><li>Map的实现类有HashMap,LinkedHashMap,TreeMap</li><li>HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序；TreeMap默认是自然升序）</li><li>LinkedHashMap底层存储结构是哈希表+链表，链表记录了添加数据的顺序</li><li>TreeMap底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性</li><li>LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表</li></ul><h1 id="try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？"><a href="#try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？" class="headerlink" title="try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？"></a>try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？</h1><ul><li>在异常处理时提供 finally 块来执行任何清除操作。</li><li>如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。</li><li>finally中语句不执行的唯一情况中执行了System.exit(0)语句。</li></ul><h1 id="什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>什么是编译型语言，什么是解释型语言？java可以归类到那种？</h1><ul><li>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。</li><li>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。</li><li>解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。</li><li>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C&#x2F;C++、Pascal&#x2F;Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。</li><li>JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</li></ul><h1 id="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h1><ul><li>final修饰基本类型变量，其值不能改变。</li><li>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li></ul><h1 id="Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="Class类的getDeclaredFields()方法与getFields()的区别？"></a>Class类的getDeclaredFields()方法与getFields()的区别？</h1><ul><li>getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法</li><li>getFields(): 只能获取所有public声43明的方法, 包括继承的方法</li></ul><h1 id="103-可序列化对象为什么要定义serialversionUID值"><a href="#103-可序列化对象为什么要定义serialversionUID值" class="headerlink" title="103.可序列化对象为什么要定义serialversionUID值?"></a>103.可序列化对象为什么要定义serialversionUID值?</h1><ul><li>SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容</li><li>如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常</li><li>如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</li></ul><h1 id="GC线程是否为守护线程？"><a href="#GC线程是否为守护线程？" class="headerlink" title="GC线程是否为守护线程？"></a>GC线程是否为守护线程？</h1><ul><li>GC线程是守护线程</li><li>线程分为守护线程和非守护线程（即用户线程）。只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。</li></ul><h1 id="不通过构造函数也能创建对象么"><a href="#不通过构造函数也能创建对象么" class="headerlink" title="不通过构造函数也能创建对象么"></a>不通过构造函数也能创建对象么</h1><ul><li>是</li><li>Java创建对象的几种方式：<ul><li>用new语句创建对象，这是最常见的创建对象的方法。</li><li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li><li>调用对象的clone()方法。</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li></ul></li><li>(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。</li></ul><h1 id="同步代码块和同步方法有什么区别"><a href="#同步代码块和同步方法有什么区别" class="headerlink" title="同步代码块和同步方法有什么区别"></a>同步代码块和同步方法有什么区别</h1><ul><li>相同点：同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为this，那么同步方法和同步代码块没有太大的区别。</li><li>区别：同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</li></ul><h1 id="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><a href="#Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？" class="headerlink" title="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"></a>Java中，如果Manager是Employee的子类，那么Pair<manager>是Pair<employee>的子类吗？</employee></manager></h1><ul><li>不是，两者没有任何关联。</li></ul><h1 id="简述Java中如何实现多态"><a href="#简述Java中如何实现多态" class="headerlink" title="简述Java中如何实现多态"></a>简述Java中如何实现多态</h1><ul><li>实现多态有三个前提条件：<ul><li>继承的存在；（继承是多态的基础，没有继承就没有多态）。</li><li>子类重写父类的方法。（多态下会调用子类重写后的方法）。</li><li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</li></ul></li><li>最后使用父类的引用变量调用子类重写的方法即可实现多态。</li></ul><h1 id="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h1><ul><li>在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt;K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt;K, V&gt;可以理解为HashMap&lt;Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型</li><li>引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。</li></ul><h1 id="对象在虚拟机的大小中可不可以用size-of取出。"><a href="#对象在虚拟机的大小中可不可以用size-of取出。" class="headerlink" title="对象在虚拟机的大小中可不可以用size of取出。"></a>对象在虚拟机的大小中可不可以用size of取出。</h1><ul><li>可以</li></ul><h1 id="什么是-JMS？"><a href="#什么是-JMS？" class="headerlink" title="什么是 JMS？"></a>什么是 JMS？</h1><ul><li>JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。</li></ul><h1 id="JMS-有哪些模型？"><a href="#JMS-有哪些模型？" class="headerlink" title="JMS 有哪些模型？"></a>JMS 有哪些模型？</h1><ul><li>JMS 消息机制主要分为两种模型：PTP 模型和 Pub&#x2F;Sub 模型。</li></ul><h4 id="PTP-模型"><a href="#PTP-模型" class="headerlink" title="PTP 模型"></a>PTP 模型</h4><ul><li>（Point to Point 对点模型) 每一个消息传递给一个消息消费者，保证消息传递给消息消费者，且消息不会同时被多个消费者接收。如果消息消费者暂时不在连接范围内，JMS 会自动保证消息不会丢失，直到消息消费者进入连接，消息将自动送达。因此，JMS 需要将消息保存到永久性介质上，例如数据库或者文件。</li></ul><h4 id="Pub-Sub-模型"><a href="#Pub-Sub-模型" class="headerlink" title="Pub-Sub 模型"></a>Pub-Sub 模型</h4><ul><li>(publish-subscription 发布者订阅者模型)每个主题可以拥有多个订阅者。JMS 系统负责将消息的副本传给该主题的每个订阅者。如果希望每一条消息都能够被处理，那么应该使用 PTP 消息模型。如果并不要求消息都必须被消息消费者接收到的情况下，可使用 pub-sub 消息模型。Pub-Sub 模型可以在一对多的消息广播时使用。</li></ul><h1 id="为什么不能根据返回类型来区分重载，为什么？"><a href="#为什么不能根据返回类型来区分重载，为什么？" class="headerlink" title="为什么不能根据返回类型来区分重载，为什么？"></a>为什么不能根据返回类型来区分重载，为什么？</h1><ul><li>方法的重载，即使返回值类型不同，也不能改变实现功能相同或类似这一既定事实</li><li>同时方法的重载只是要求两同三不同，即在同一个类中，相同的方法名称，参数列表当中的参数类型、个数、顺序不同；跟权限修饰符和返回值类无关</li></ul><h1 id="Java-中-byte-表示的数值范围是什么？"><a href="#Java-中-byte-表示的数值范围是什么？" class="headerlink" title="Java 中 byte 表示的数值范围是什么？"></a>Java 中 byte 表示的数值范围是什么？</h1><ul><li>范围是-128 至 127</li></ul><h1 id="在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？"><a href="#在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？" class="headerlink" title="在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？"></a>在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？</h1><ul><li>不正确。</li><li>通常情况下，进行比较判断的处理，switch 和 if-else 可以互相转换来写；</li><li>if-else 作用的范围比 switch-case 作用范围要大，但是当 switch-case 和 if-else 都可以用的情况下，通常推荐使用 switch-case。</li></ul><h1 id="Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？"><a href="#Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？" class="headerlink" title="Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？"></a>Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？</h1><ul><li>Java 程序中创建新的类对象，使用关键字 new 是正确的</li><li>回收无用的类对象使用关键字 free 是错误的.</li></ul><h1 id="存在使-i-1"><a href="#存在使-i-1" class="headerlink" title="存在使 i+1&lt;i 的数么?"></a>存在使 i+1&lt;i 的数么?</h1><ul><li>存在, int 的最大值, 加 1 后变为负数.</li></ul><h1 id="Java-中-Math-random（）-Math-random（）值为？"><a href="#Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="Java 中 Math.random（）&#x2F; Math.random（）值为？"></a>Java 中 Math.random（）&#x2F; Math.random（）值为？</h1><ul><li>如果除数与被除数均不为 0.0 的话，则取值范围为[0, +∞]。+∞在 Java 中显示的结果为 Infinity。</li><li>如果除数与被除数均为 0.0 的话，则运行结果为 NaN（Not a Number 的简写），计算错误。</li></ul><h1 id="匿名内部类可不可以继承或实现接口。为什么？"><a href="#匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="匿名内部类可不可以继承或实现接口。为什么？"></a>匿名内部类可不可以继承或实现接口。为什么？</h1><ul><li>匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现.</li><li>由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把<br>创建对象的任务交给了父类去完成。</li><li>在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。</li><li>因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。</li></ul><h1 id="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？"><a href="#说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？" class="headerlink" title="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？"></a>说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？</h1><ul><li>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；比如申请了一个 integer,但给它存了long 才能存下的数，那就是内存溢出。</li><li>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li><li>memory leak 会最终会导致 out of memory！</li></ul><h1 id="为什么为基本类型引入包装类"><a href="#为什么为基本类型引入包装类" class="headerlink" title="为什么为基本类型引入包装类"></a>为什么为基本类型引入包装类</h1><ul><li>基本数据类型有方便之处，简单、高效。</li><li>但是 Java 中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是 Object）。</li><li>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</li><li>包装类和基本数据类型之间的转换<ul><li>包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</li><li>包装类——-new WrapperClass(primitive) new WrapperClass(string)——基本数据类型</li></ul></li><li>自动装箱和自动拆箱<ul><li>JDK1.5 提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换</li></ul></li><li>包装类还可以实现基本类型变量和字符串之间的转换<ul><li>基本类型变量&lt;————String.valueof()————&gt;字符串</li><li>基本类型变量&lt;————WrapperClass.parseXxx(string)————字符串</li></ul></li></ul><h1 id="谈谈-Java-的多态"><a href="#谈谈-Java-的多态" class="headerlink" title="谈谈 Java 的多态"></a>谈谈 Java 的多态</h1><ul><li>实现多态的三个条件（前提条件，向上转型、向下转型）<ul><li>继承的存在；（继承是多态的基础，没有继承就没有多态）</li><li>子类重写父类的方法。（多态下会调用子类重写后的方法）</li><li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）</li></ul></li><li>向上转型 Student person &#x3D; new Student()</li><li>将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。</li><li>此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法此时通过父类引用变量无法调用子类特有的方法。</li><li>向下转型 Student stu &#x3D; (Student)person;</li><li>将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类型，否则将出现 ClassCastException，不是任意的强制转换向下转型时可以结合使用 instanceof 运算符进行强制类型转换，比如出现转换异常—ClassCastException</li></ul><h1 id="if-多分支语句和-switch-多分支语句的异同之处"><a href="#if-多分支语句和-switch-多分支语句的异同之处" class="headerlink" title="if 多分支语句和 switch 多分支语句的异同之处"></a>if 多分支语句和 switch 多分支语句的异同之处</h1><ul><li>相同之处：都是分支语句，多超过一种的情况进行判断处理。</li><li>不同之处：<ul><li>switch 更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有 break 跳出），不加判断地执行下去;而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。</li><li>switch 为等值判断（不允许比如&gt;&#x3D; &lt;&#x3D;），而 if 为等值和区间都可以，if 的使用范围大。</li></ul></li></ul><h1 id="基本数据类型的类型转换规则"><a href="#基本数据类型的类型转换规则" class="headerlink" title="基本数据类型的类型转换规则"></a>基本数据类型的类型转换规则</h1><ul><li>基本类型转换分为自动转换和强制转换。</li><li>自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的<br>范围。</li><li>强制转换规则：高级变为低级需要强制转换。</li><li>如何转换：<ul><li>赋值运算符“&#x3D;”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</li><li>赋值运算符“&#x3D;”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 &#x3D;&#x3D; 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li><li>可以将整型常量直接赋值给 byte, short, char 等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li></ul></li></ul><h1 id="Java-三种注释类型"><a href="#Java-三种注释类型" class="headerlink" title="Java 三种注释类型"></a>Java 三种注释类型</h1><ul><li>共有单行注释、多行注释、文档注释 3 种注释类型</li></ul><h1 id="谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么"><a href="#谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么" class="headerlink" title="谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?"></a>谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?</h1><ul><li>Java本身是一种面向对象的语言,最显著的特点有两个方面,一个是所谓的”书写一次,到处运行”;能够非常容易地获得跨平台能力;另外就是垃圾收集器(GC)，Java通过垃圾收集器回收分配内存,大部分情况下,程序员不需要自己操心内存的分配和回收。我们日常接触到JRE或者JDK。JRE也就是Java运行环境,包含了JVM和Java类库,以及一些模块等。而JDK可以看作是JRE的一个超集,提供了更多的工具,比如编译器 各种诊断工具。</li><li>“对于Java是解释执行”这句话,这个说法不准确。我们开发的Java的源代码,首先通过Javac编译成为字节码,然后在运行时通过Java虚拟机内嵌的解释器将字节码转换为最终的机器码。但是常见的JVM,比如我们大数据情况使用的Oracle JDK提供的HostpotJVM,提供了JIT编译器,就是通常所说的动态编译器,JIT能够在运行时将热点代码(高频调用的方法和代码块)编译成机器码,这种情况下部分热点就属于编译执行,而不是解释执行。这样类似于缓存技术,运行时在遇到热点代码可以直接执行,而不是先解释在执行。</li></ul><h1 id="NoClassDeFoundError和ClassNotFoundException的区别"><a href="#NoClassDeFoundError和ClassNotFoundException的区别" class="headerlink" title="NoClassDeFoundError和ClassNotFoundException的区别?"></a>NoClassDeFoundError和ClassNotFoundException的区别?</h1><ul><li>首先NoClassDeFoundError是一个错误,ClassNotFoundException是一个异常。ClassNotFoundException的产生原因,Java支持使用Class.froName方法来动态地加载类,任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中,如果这个类在类路径中没有被找到,那么此时就会在运行时抛出ClassNotFoundException异常。另外还有一个导致ClassNotFoundException的原因就是,当一个类已经被某个类加载器加载到内存中,此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li><li>NoClassDeFoundError产生的原因在于:如果JVM或者ClassLoader实例尝试加载类的时候找不到类的定义。例如要查找的类在编译的时候是存在的,运行的时候找不到了。这个时候就会导致NoClassDefFoundError。造成该问题的原因可能是打包过程中漏掉了部分类,或者jar包出现损坏或者篡改。解决这个问题的办法就是查找那些在开发期间存在与类路径下,但在运行期间却不在类路径下的类。</li></ul><h1 id="一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数"><a href="#一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数" class="headerlink" title="一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?"></a>一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?</h1><ul><li>用 super 关键字,子类去调用父类的方法，如：super.myMethod();子类去调用父类的构造函数，如：super()</li></ul><h1 id="Bit-和-Byte-是什么意思-它们之间有什么关系"><a href="#Bit-和-Byte-是什么意思-它们之间有什么关系" class="headerlink" title="Bit 和 Byte 是什么意思?它们之间有什么关系?"></a>Bit 和 Byte 是什么意思?它们之间有什么关系?</h1><ul><li>bit 中文名称是位，是用以描述电脑数据量的最小单位。</li><li>byte（字节）是计算机信息技术用于计量存储容量和传输容量的一种计量单位 1byte&#x3D;8bit</li></ul><h1 id="什么是-java-序列化，如何实现-java-序列化？"><a href="#什么是-java-序列化，如何实现-java-序列化？" class="headerlink" title="什么是 java 序列化，如何实现 java 序列化？"></a>什么是 java 序列化，如何实现 java 序列化？</h1><ul><li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；</li><li>序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream) 来 构 造 一 个 ObjectOutputStream( 对 象 流 ) 对 象 ， 接 着 ， 使 用ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。</li></ul><h1 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h1><ul><li>Lambda表达式的本质只是一个”语法糖”,由编译器推断并帮我们转换包装为常规的代码,因此我们可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘。</li><li>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许我们通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。</li><li>Lambda表达式还增强了集合库。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。</li></ul><h1 id="获取用键盘输入常用的的两种方法"><a href="#获取用键盘输入常用的的两种方法" class="headerlink" title="获取用键盘输入常用的的两种方法"></a>获取用键盘输入常用的的两种方法</h1><ul><li>通过 Scanner</li><li>通过 BufferedReader</li></ul><h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul><h1 id="JAVA-复制"><a href="#JAVA-复制" class="headerlink" title="JAVA 复制"></a>JAVA 复制</h1><ul><li>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</li></ul><h4 id="直接赋值复制"><a href="#直接赋值复制" class="headerlink" title="直接赋值复制"></a>直接赋值复制</h4><ul><li>直接赋值。在 Java 中，A a1 &#x3D; a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。</li></ul><h4 id="浅复制（复制引用但不复制引用的对象）"><a href="#浅复制（复制引用但不复制引用的对象）" class="headerlink" title="浅复制（复制引用但不复制引用的对象）"></a>浅复制（复制引用但不复制引用的对象）</h4><ul><li>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。</li><li>因此，原始对象及其副本引用同一个对象。</li></ul><h4 id="深复制（复制对象和其应用对象）"><a href="#深复制（复制对象和其应用对象）" class="headerlink" title="深复制（复制对象和其应用对象）"></a>深复制（复制对象和其应用对象）</h4><ul><li>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</li></ul><h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><ul><li>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List&lt;Object&gt;和 List&lt;String&gt;等类型，在编译之后</li><li>都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</li><li>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</li></ul><h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h1><ul><li>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数</li><li>例 如 List&lt;?&gt; 在逻辑上是 List&lt;String&gt;,List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt;的父类。</li></ul><h1 id="创建对象的两种方法"><a href="#创建对象的两种方法" class="headerlink" title="创建对象的两种方法"></a>创建对象的两种方法</h1><ul><li>Class 对象的 newInstance()<ul><li>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</li></ul></li><li>调用 Constructor 对象的 newInstance()<ul><li>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</li></ul></li></ul><h1 id="Java-中，Serializable-与-Externalizable-的区别？"><a href="#Java-中，Serializable-与-Externalizable-的区别？" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别？"></a>Java 中，Serializable 与 Externalizable 的区别？</h1><ul><li>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</li></ul><h1 id="OOP-中的-组合、聚合和关联有什么区别？"><a href="#OOP-中的-组合、聚合和关联有什么区别？" class="headerlink" title="OOP 中的 组合、聚合和关联有什么区别？"></a>OOP 中的 组合、聚合和关联有什么区别？</h1><ul><li>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B组合的，则 A 不存在的话，B 一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</li></ul><h1 id="Java-中，嵌套公共静态类与顶级类有什么不同？"><a href="#Java-中，嵌套公共静态类与顶级类有什么不同？" class="headerlink" title="Java 中，嵌套公共静态类与顶级类有什么不同？"></a>Java 中，嵌套公共静态类与顶级类有什么不同？</h1><ul><li>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</li></ul><h1 id="继承和组合之间有什么不同？"><a href="#继承和组合之间有什么不同？" class="headerlink" title="继承和组合之间有什么不同？"></a>继承和组合之间有什么不同？</h1><ul><li>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</li></ul><h1 id="我们能自己写一个容器类，然后使用-for-each-循环码？"><a href="#我们能自己写一个容器类，然后使用-for-each-循环码？" class="headerlink" title="我们能自己写一个容器类，然后使用 for-each 循环码？"></a>我们能自己写一个容器类，然后使用 for-each 循环码？</h1><ul><li>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</li></ul><h1 id="写一段代码在遍历-ArrayList-时移除一个元素？"><a href="#写一段代码在遍历-ArrayList-时移除一个元素？" class="headerlink" title="写一段代码在遍历 ArrayList 时移除一个元素？"></a>写一段代码在遍历 ArrayList 时移除一个元素？</h1><ul><li>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</li></ul><h1 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a>Java 中的 HashSet，内部是如何工作的？</h1><ul><li>HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。</li></ul><h1 id="Java-中的-TreeMap-是采用什么树实现的？"><a href="#Java-中的-TreeMap-是采用什么树实现的？" class="headerlink" title="Java 中的 TreeMap 是采用什么树实现的？"></a>Java 中的 TreeMap 是采用什么树实现的？</h1><ul><li>Java 中的 TreeMap 是使用红黑树实现的。</li></ul><h1 id="Java-中的-LinkedList-是单向链表还是双向链表？"><a href="#Java-中的-LinkedList-是单向链表还是双向链表？" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表？"></a>Java 中的 LinkedList 是单向链表还是双向链表？</h1><ul><li>是双向链表，你可以检查 JDK 的源码</li></ul><h1 id="Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？</h1><ul><li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li></ul><h1 id="poll-方法和-remove-方法的区别？"><a href="#poll-方法和-remove-方法的区别？" class="headerlink" title="poll() 方法和 remove() 方法的区别？"></a>poll() 方法和 remove() 方法的区别？</h1><ul><li>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</li></ul><h1 id="Java-中的编译期常量是什么？使用它又什么风险？"><a href="#Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="Java 中的编译期常量是什么？使用它又什么风险？"></a>Java 中的编译期常量是什么？使用它又什么风险？</h1><ul><li>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</li></ul><h1 id="我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？"><a href="#我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？" class="headerlink" title="我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？"></a>我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？</h1><ul><li>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</li></ul><h1 id="3-0-1-0-3-将会返回什么？true-还是-false？"><a href="#3-0-1-0-3-将会返回什么？true-还是-false？" class="headerlink" title="3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？"></a>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？</h1><ul><li>false，因为有些浮点数不能完全精确的表示出来。</li></ul><h1 id="int-和-Integer-哪个会占用更多的内存？"><a href="#int-和-Integer-哪个会占用更多的内存？" class="headerlink" title="int 和 Integer 哪个会占用更多的内存？"></a>int 和 Integer 哪个会占用更多的内存？</h1><ul><li>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。</li><li>但是 int 是一个原始类型的数据，所以占用的空间更少。</li></ul><h1 id="为什么-Java-中的-String-是不可变的（Immutable）？"><a href="#为什么-Java-中的-String-是不可变的（Immutable）？" class="headerlink" title="为什么 Java 中的 String 是不可变的（Immutable）？"></a>为什么 Java 中的 String 是不可变的（Immutable）？</h1><ul><li>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。</li></ul><h1 id="我们能在-Switch-中使用-String-吗？"><a href="#我们能在-Switch-中使用-String-吗？" class="headerlink" title="我们能在 Switch 中使用 String 吗？"></a>我们能在 Switch 中使用 String 吗？</h1><ul><li>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</li></ul><h1 id="Java-中的构造器链是什么？"><a href="#Java-中的构造器链是什么？" class="headerlink" title="Java 中的构造器链是什么？"></a>Java 中的构造器链是什么？</h1><ul><li>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</li></ul><h1 id="什么是-Busy-spin？我们为什么要使用它？"><a href="#什么是-Busy-spin？我们为什么要使用它？" class="headerlink" title="什么是 Busy spin？我们为什么要使用它？"></a>什么是 Busy spin？我们为什么要使用它？</h1><ul><li>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。</li><li>所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</li></ul><h1 id="Swing-是线程安全的？"><a href="#Swing-是线程安全的？" class="headerlink" title="Swing 是线程安全的？"></a>Swing 是线程安全的？</h1><ul><li>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。</li><li>这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</li></ul><h1 id="什么是线程局部变量？"><a href="#什么是线程局部变量？" class="headerlink" title="什么是线程局部变量？"></a>什么是线程局部变量？</h1><ul><li>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</li></ul><h1 id="Java-中应该使用什么数据类型来代表价格？"><a href="#Java-中应该使用什么数据类型来代表价格？" class="headerlink" title="Java 中应该使用什么数据类型来代表价格？"></a>Java 中应该使用什么数据类型来代表价格？</h1><ul><li>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的double 类型。</li></ul><h1 id="怎么将-byte-转换为-String？"><a href="#怎么将-byte-转换为-String？" class="headerlink" title="怎么将 byte 转换为 String？"></a>怎么将 byte 转换为 String？</h1><ul><li>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</li></ul><h1 id="我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h1><ul><li>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。</li></ul><h1 id="哪个类包含-clone-方法？是-Cloneable-还是-Object？"><a href="#哪个类包含-clone-方法？是-Cloneable-还是-Object？" class="headerlink" title="哪个类包含 clone 方法？是 Cloneable 还是 Object？"></a>哪个类包含 clone 方法？是 Cloneable 还是 Object？</h1><ul><li>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由c 或 c++ 或 其他本地语言实现的。</li></ul><h1 id="Java-中-操作符是线程安全的吗？"><a href="#Java-中-操作符是线程安全的吗？" class="headerlink" title="Java 中 ++ 操作符是线程安全的吗？"></a>Java 中 ++ 操作符是线程安全的吗？</h1><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p><h1 id="a-a-b-与-a-b-的区别"><a href="#a-a-b-与-a-b-的区别" class="headerlink" title="a &#x3D; a + b 与 a +&#x3D; b 的区别"></a>a &#x3D; a + b 与 a +&#x3D; b 的区别</h1><ul><li>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是a +&#x3D; b 没问题，如下：<ul><li>byte a &#x3D; 127;</li><li>byte b &#x3D; 127;</li><li>b &#x3D; a + b; &#x2F;&#x2F; error : cannot convert from int to byte</li><li>b +&#x3D; a; &#x2F;&#x2F; ok</li></ul></li></ul><h1 id="什么是多线程环境下的伪共享（false-sharing）？"><a href="#什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="什么是多线程环境下的伪共享（false sharing）？"></a>什么是多线程环境下的伪共享（false sharing）？</h1><ul><li>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行</li></ul><h1 id="89、简述一下面向对象的”六原则一法则”。"><a href="#89、简述一下面向对象的”六原则一法则”。" class="headerlink" title="89、简述一下面向对象的”六原则一法则”。"></a>89、简述一下面向对象的”六原则一法则”。</h1><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</li><li>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</li><li>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</li><li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</li></ul><h1 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h1><ul><li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li></ul><h1 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h1><ul><li>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</li></ul><h1 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h1><ul><li>动态代理是运行时动态生成代理类。</li><li>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</li></ul><h1 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h1><ul><li>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</li></ul><h1 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h1><ul><li>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</li></ul><h1 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h1><ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul><h1 id="Java-中的异常处理机制的简单原理和应用。"><a href="#Java-中的异常处理机制的简单原理和应用。" class="headerlink" title="Java 中的异常处理机制的简单原理和应用。"></a>Java 中的异常处理机制的简单原理和应用。</h1><ul><li>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。</li><li>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。</li></ul><h1 id="Java-中的-LongAdder-和-AtomicLong-的区别"><a href="#Java-中的-LongAdder-和-AtomicLong-的区别" class="headerlink" title="Java 中的 LongAdder 和 AtomicLong 的区别"></a>Java 中的 LongAdder 和 AtomicLong 的区别</h1><ul><li>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进行了有效的分离，提高了并行度。</li></ul><h1 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h1><ul><li>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</li><li>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。</li></ul><h1 id="Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h1><ul><li>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。</li><li>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</li><li>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数。</li></ul><h1 id="请问-Query-接口的-list-方法和-iterate-方法有什么区别？"><a href="#请问-Query-接口的-list-方法和-iterate-方法有什么区别？" class="headerlink" title="请问 Query 接口的 list 方法和 iterate 方法有什么区别？"></a>请问 Query 接口的 list 方法和 iterate 方法有什么区别？</h1><ul><li>list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用 iterate()方法可以减少性能开销。</li><li>list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题</li></ul><h1 id="Java-的接口和-C-的虚类的相同和不同处。"><a href="#Java-的接口和-C-的虚类的相同和不同处。" class="headerlink" title="Java 的接口和 C++的虚类的相同和不同处。"></a>Java 的接口和 C++的虚类的相同和不同处。</h1><ul><li>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。</li><li>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。</li></ul><h1 id="Java-支持多继承么？"><a href="#Java-支持多继承么？" class="headerlink" title="Java 支持多继承么？"></a>Java 支持多继承么？</h1><ul><li>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</li></ul><h1 id="解释-extends-和-super-泛型限定符-上界不存下界不取"><a href="#解释-extends-和-super-泛型限定符-上界不存下界不取" class="headerlink" title="解释 extends 和 super 泛型限定符-上界不存下界不取"></a>解释 extends 和 super 泛型限定符-上界不存下界不取</h1><ul><li>泛型中上界和下界的定义<ul><li>上界 &lt;? extend Fruit&gt;</li><li>下界 &lt;? super Apple&gt;</li></ul></li><li>上界和下界的特点<ul><li>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）</li><li>下界的 list 只能 add，不能 get</li></ul></li><li>上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把所有的子类向上转型为 Fruit。</li><li>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接着呢，除了 Object，其他的都接不住。</li><li>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。</li><li>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引用就必须得用 cast。</li></ul><h1 id="”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？"><a href="#”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？" class="headerlink" title="”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？"></a>”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？</h1><ul><li>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</li><li>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。</li></ul><h1 id="你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？</h1><ul><li>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</li><li>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一个很好的说明。</li><li>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。</li><li>其函数表示是：<ul><li>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));</li><li>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。</li><li>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好的说明。</li></ul></li></ul><h1 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h1><ul><li>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</li><li>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递.</li></ul><h1 id="为啥有时会出现-4-0-3-6-0-40000001-这种现象？"><a href="#为啥有时会出现-4-0-3-6-0-40000001-这种现象？" class="headerlink" title="为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？"></a>为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？</h1><ul><li>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。</li></ul><h1 id="说说-Lamda-表达式的优缺点。"><a href="#说说-Lamda-表达式的优缺点。" class="headerlink" title="说说 Lamda 表达式的优缺点。"></a>说说 Lamda 表达式的优缺点。</h1><ul><li>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。</li><li>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</li></ul><h1 id="若对一个类不重写，它的-equals-方法是如何比较的？"><a href="#若对一个类不重写，它的-equals-方法是如何比较的？" class="headerlink" title="若对一个类不重写，它的 equals()方法是如何比较的？"></a>若对一个类不重写，它的 equals()方法是如何比较的？</h1><ul><li>比较是对象的地址。</li></ul><h1 id="比较的是什么？"><a href="#比较的是什么？" class="headerlink" title="&#x3D;&#x3D;比较的是什么？"></a>&#x3D;&#x3D;比较的是什么？</h1><ul><li>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。</li></ul><h1 id="Object-若不重写-hashCode-的话，hashCode-如何计算出来的？"><a href="#Object-若不重写-hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="Object 若不重写 hashCode()的话，hashCode()如何计算出来的？"></a>Object 若不重写 hashCode()的话，hashCode()如何计算出来的？</h1><ul><li>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。</li></ul><h1 id="Hash表的hash函数，冲突解决方法有哪些。"><a href="#Hash表的hash函数，冲突解决方法有哪些。" class="headerlink" title="Hash表的hash函数，冲突解决方法有哪些。"></a>Hash表的hash函数，冲突解决方法有哪些。</h1><ul><li>开放定址法或者叫再散列法；<ul><li>线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    - 二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    - 伪随机探测再散列：di&#x3D;伪随机序列；</li></ul></li><li>再哈希法；</li><li>拉链法。</li></ul><h1 id="分派：静态分派与动态分派。"><a href="#分派：静态分派与动态分派。" class="headerlink" title="分派：静态分派与动态分派。"></a>分派：静态分派与动态分派。</h1><ul><li>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的</li><li>动态分派：（重写）</li></ul><h1 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样?"></a>一个线程如果出现了运行时异常会怎么样?</h1><ul><li>如果该异常被捕获或抛出，则程序继续运行。 </li><li>如果异常没有被捕获该线程将会停止执行。 </li><li>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理</li></ul><h1 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h1><ul><li>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。</li></ul><h1 id="并发编程（concurrency）并行编程（parallellism）有什么区别？"><a href="#并发编程（concurrency）并行编程（parallellism）有什么区别？" class="headerlink" title="并发编程（concurrency）并行编程（parallellism）有什么区别？*"></a>并发编程（concurrency）并行编程（parallellism）有什么区别？*</h1><ul><li>并发（concurrency）和并行（parallellism）是：<ul><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群</li></ul></li></ul><h1 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h1><ul><li>只要退出了synchronized块，无论是正常还是异常，都会释放锁。</li></ul><h1 id="foreach与正常for循环效率对比"><a href="#foreach与正常for循环效率对比" class="headerlink" title="foreach与正常for循环效率对比"></a>foreach与正常for循环效率对比</h1><ul><li>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。</li></ul><h1 id="Static-class-与non-static-class的区别"><a href="#Static-class-与non-static-class的区别" class="headerlink" title="Static?class?与non?static?class的区别"></a>Static?class?与non?static?class的区别</h1><ul><li>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。</li><li>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。</li></ul><h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul><li>加载JDBC驱动程序</li><li>提供JDBC连接的URL</li><li>创建数据库的连接</li><li>创建一个Statement</li><li>执行SQL语句</li><li>处理结果</li><li>关闭JDBC对象</li></ul><h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul><li>方法名称相同，参数的类型或个数不同</li><li>方法名称、参数类型、返回值类型全部相同</li><li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li><li>范围 发生在一个类中 发生在继承类中</li><li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li><li>反射的应用很多，很多框架都有用到<ul><li>spring 的 ioc&#x2F;di 也是反射…</li><li>javaBean和jsp之间调用也是反射…</li><li>struts的 FormBean 和页面之间…也是通过反射调用…</li><li>JDBC 的 classForName()也是反射…</li><li>hibernate的 find(Class clazz) 也是反射…</li><li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/7e68be57c290.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/7e68be57c290.html" class="post-title-link" itemprop="url">消息队列（MQ）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:22:16" itemprop="dateCreated datePublished" datetime="2023-12-20T09:22:16+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 11:21:45" itemprop="dateModified" datetime="2024-01-04T11:21:45+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>26k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h1><ul><li>场景有很多，但是比较核心的有 3 个：解耦、异步、削峰。</li></ul><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><ul><li>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</li><li>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A系统要时时刻刻考虑BCDE四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？</li><li>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去MQ里面消费。如果新系统需要数据，直接从MQ里消费即可；如果某个系统不需要这条数据了，就取消对MQ消息的消费即可。这样下来，A系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</li><li>总结：通过一个 MQ，Pub&#x2F;Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</li><li>面试技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</li></ul><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近 1s，用户感觉慢。</li><li>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</li><li>如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了</li></ul><h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><ul><li>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</li><li>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</li><li>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</li></ul><h1 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h1><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>解耦、异步、削峰。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="系统可用性降低"><a href="#系统可用性降低" class="headerlink" title="系统可用性降低"></a>系统可用性降低</h5><ul><li>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的。</li></ul><h5 id="系统复杂度提高"><a href="#系统复杂度提高" class="headerlink" title="系统复杂度提高"></a>系统复杂度提高</h5><ul><li>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li></ul><h5 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h5><ul><li>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。<br>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</li></ul><h1 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点</h1><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td>-</td><td>-</td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul><li>最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，不推荐用这个；</li><li>后来大家开始用 RabbitMQ，但是确实erlang语言阻止了大量的Java工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li><li>不过现在确实越来越多的公司会去用RocketMQ，确实很不错，阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给Apache，但GitHub上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li><li>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li></ul><h1 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h1><h4 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h4><ul><li>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</li><li>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</li></ul><h5 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h5><ul><li>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li></ul><h5 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h5><ul><li>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</li><li>这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</li></ul><h5 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h5><ul><li>这种模式，才是所谓的 RabbitMQ 的高可用模式</li><li>跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思</li><li>然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</li><li>那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li><li>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据</li><li>坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li></ul><h4 id="Kafka-的高可用性"><a href="#Kafka-的高可用性" class="headerlink" title="Kafka 的高可用性"></a>Kafka 的高可用性</h4><ul><li>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</li><li>这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</li><li>实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</li><li>Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1&#x2F;3 的数据就丢了，因此这个是做不到高可用的。</li><li>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。</li><li>只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</li><li>这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</li><li>写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</li><li>消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</li></ul><h1 id="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</h1><ul><li>RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题</li><li>因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。</li><li>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</li><li>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</li><li>举个栗子。有这么个场景。数据 1&#x2F;2&#x2F;3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152&#x2F;153&#x2F;154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了offset&#x3D;153的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 152 的 offset 并没有提交，kafka 也就不知道你已经消费了offset&#x3D;153这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 152 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</li><li>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 152 在数据库里插入了 2 次，那么数据就错啦。</li><li>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</li><li>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</li><li>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</li><li>所以第二个问题来了，怎么保证消息队列消费的幂等性？</li><li>其实还是得结合业务来思考，我这里给几个思路：<ul><li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li><li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li><li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul></li></ul><h1 id="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"><a href="#如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？" class="headerlink" title="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"></a>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</h1><ul><li>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</li></ul><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><h5 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h5><ul><li>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</li><li>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</li><li>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上吞吐量会下来，因为太耗性能。</li><li>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</li><li>事务机制和confirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</li><li>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</li></ul><h5 id="RabbitMQ-弄丢了数据"><a href="#RabbitMQ-弄丢了数据" class="headerlink" title="RabbitMQ 弄丢了数据"></a>RabbitMQ 弄丢了数据</h5><ul><li>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</li><li>设置持久化有两个步骤：<ul><li>创建 queue 的时候将其设置为持久化<br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的deliveryMode设置为 2<br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul></li><li>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</li><li>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</li><li>所以，持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</li></ul><h5 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h5><ul><li>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</li><li>这个时候得用 RabbitMQ 提供的ack机制，简单来说，就是你必须关闭 RabbitMQ 的自动ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把。这样的话，如果你还没处理完，不就没有ack了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><h5 id="消费端弄丢了数据-1"><a href="#消费端弄丢了数据-1" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h5><ul><li>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</li><li>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要关闭自动提交offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</li><li>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</li></ul><h5 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h5><ul><li>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</li><li>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</li><li>所以此时一般是要求起码设置如下 4 个参数：<ul><li>给 topic 设置replication.factor参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置min.insync.replicas参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置acks&#x3D;all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。</li><li>在 producer 端设置retries&#x3D;MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。</li></ul></li><li>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</li></ul><h5 id="生产者会不会弄丢数据"><a href="#生产者会不会弄丢数据" class="headerlink" title="生产者会不会弄丢数据"></a>生产者会不会弄丢数据</h5><ul><li>如果按照上述的思路设置了acks&#x3D;all，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了</li><li>如果没满足这个条件，生产者会自动不断的重试，重试无限次。</li></ul><h1 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h1><ul><li>举个例子，我们以前做过一个 mysql binlog 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）</li><li>常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</li><li>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 binlog 日志，接着这三条 binlog 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</li><li>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</li><li>先看看顺序会错乱的俩场景：<ul><li>RabbitMQ：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3。这不明显乱了。</li><li>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞多个线程来并发处理消息。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li></ul></li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul><li>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点</li><li>或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li></ul><p> </p><h5 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h5><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue</li><li>然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><h1 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h1><ul><li>先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。</li><li>大量消息在 mq 里积压了几个小时了还没解决。这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</li><li>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</li><li>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：<ul><li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据</li><li>这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li></ul></li></ul><h4 id="mq-中的消息过期失效了"><a href="#mq-中的消息过期失效了" class="headerlink" title="mq 中的消息过期失效了"></a>mq 中的消息过期失效了</h4><ul><li>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL</li><li>如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了</li><li>那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。</li><li>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息</li><li>我们可以采取一个方案，就是批量重导。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</li><li>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</li></ul><h4 id="mq-都快写满了"><a href="#mq-都快写满了" class="headerlink" title="mq 都快写满了"></a>mq 都快写满了</h4><ul><li>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</li></ul><h1 id="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"><a href="#如果让你写一个消息队列，该如何进行架构设计？说一下你的思路" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"></a>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</h1><ul><li>其实回答这类问题，说白了，不求你看过那技术的源码，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</li><li>比如说这个消息队列系统，我们从以下几个角度来考虑一下：<ul><li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li><li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li><li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li><li>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</li></ul></li><li>mq 肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</li></ul><h1 id="四款消息队列的对比"><a href="#四款消息队列的对比" class="headerlink" title="四款消息队列的对比"></a>四款消息队列的对比</h1><h4 id="MSMQ"><a href="#MSMQ" class="headerlink" title="MSMQ"></a>MSMQ</h4><ul><li>这是微软的产品里唯一被认为有价值的东西</li><li>这个东西并不复杂，除了接收和 发送，没有别的</li><li>它有一些硬性限制，比如最大消息体积是4MB</li><li>然而，通过和一些像MassTransit 或 NServiceBus这样的软件的连接，它完全可以解决这些问题。</li><li>优点：<ul><li>由于是异步通信，无论是发送方还是接收方都不用等待对方返回成功消息，就可以执行余下的代码，因而大大地提高了事物处理的能力</li><li>当信息传送过程中，信息发送机制具有一定功能的故障恢复能力；</li><li>MSMQ的消息传递机制使得消息通信的双方具有不同的物理平台成为可能。</li></ul></li></ul><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><ul><li>特性列表:</li><li>多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li><li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)</li><li>对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性</li><li>通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上</li><li>支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>支持通过JDBC和journal提供高速的消息持久化</li><li>从设计上保证了高性能的集群，客户端-服务器，点对点</li><li>支持Ajax</li><li>支持与Axis的整合</li><li>可以很容易得调用内嵌JMS provider，进行测试</li></ul><h4 id="RabbitMQ-2"><a href="#RabbitMQ-2" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><ul><li>它支持开放的高级消息队列协议 (AMQP，Advanced Message Queuing Protocol)</li><li>从根本上避免了生产厂商的封闭，使用任何语言的各种客户都可以从中受益</li><li>这种协议提供了相当复杂的消息传输模式，所以基本上不需要 MassTransit 或 NServiceBus 的配合</li></ul><h4 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h4><ul><li>ZeroMQ 是一个轻量级消息内核</li><li>它可用于C、C++、Python、.NET &#x2F;Mono、Fortran和Java语言<br>它运行在AIX ， FreeBSD的，基于HP - UX ， Linux和MacOS下， OpenBSD系统， OpenVMS ， QNX Neutrino， Solaris和Windows操作系统。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>ActiveMQ需要 在目标机器上安装Java，RabbitMQ需要Erlang环境。如果这个中 的一个被选中，我需要让系统维护的人去理解和维护他们以前不熟悉的运行库。</li><li>ActiveMQ,RabbitMQ 和 MSMQ 都需要启动服务进程，这些都可以监控和配置，另外一个就有问题了。</li><li>ZeroMQ，它没有中间件架构，不需要任何服务进程和运行时。事实上，你的应用程序端点扮演了这个服务角色。这让部署起来非常简单，但担心的是， 你没有地方可以观察它是否有问题出现。就目前我知道的，ZeroMQ仅提供非持久性的队列。你可以在需要的地方实现自己的审计和数据恢复功能</li><li>如果你希望一个应用程序发送消息越快越好，你选择ZeroMQ。当你不太在意偶然会丢失某些消息的情况下更有价值。</li><li>虽然说ZeroMQ的速度很惊人,但是对于数据就是生命的年代,我们宁可降低一些需求也不愿意丢失任何一条宝贵的数据,所以综合对比下来,我觉得RabbitMQ更适合.</li></ul><h1 id="消息中间件Kafka与RabbitMQ谁更胜一筹"><a href="#消息中间件Kafka与RabbitMQ谁更胜一筹" class="headerlink" title="消息中间件Kafka与RabbitMQ谁更胜一筹"></a>消息中间件Kafka与RabbitMQ谁更胜一筹</h1><ul><li>在 IM 这种讲究高并发、高消息吞吐的互联网场景下，MQ 消息中间件是个很重要的基础设施，它在 IM 系统的服务端架构中担当消息中转、消息削峰、消息交换异步化等角色。</li><li>当然，MQ 消息中间件的作用远不止于此，它的价值不仅仅存在于技术上，更重要的是改变了以往同步处理消息的思路。</li><li>比如进行 IM 消息历史存储时，传统的信息系统作法可能是收到一条消息就马上同步存入数据库，这种作法在小并发量的情况下可以很好的工作，但互联网大并发环境下就是灾难。</li><li>MQ 消息中间件可以理解为一个水池，水池的这头是消息生产者，水池的那头是消息消费者，生产者和消息者无需直接对接，这将带来很多好处：业务解耦、架构分布式化等，生产者和消费者互相完全透明。</li></ul><h1 id="什么是消息队列中间件"><a href="#什么是消息队列中间件" class="headerlink" title="什么是消息队列中间件"></a>什么是消息队列中间件</h1><ul><li>消息队列中间件(简称消息中间件)是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</li><li>通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。</li><li>目前开源的消息中间件可谓是琳琅满目，能让大家耳熟能详的就有很多，比如 ActiveMQ、RabbitMQ、Kafka、RocketMQ、ZeroMQ 等，不管选择其中的哪一款，都会有用的不趁手的地方，毕竟不是为你量身定制的。</li><li>可能有些大厂在长期的使用过程中积累了一定的经验，加上其消息队列的使用场景也相对稳定固化，或者目前市面上的消息中间件无法满足自身需求，同时它也具备足够的精力和人力而选择自研来为自己量身打造一款消息中间件。</li><li>但是绝大多数公司还是不会选择重复造轮子，那么选择一款适合自己的消息中间件显得尤为重要。</li><li>就算是前者，那么在自研出稳定且可靠的相关产品之前也会经历这样一个选型过程。</li><li>在整体架构中引入消息中间件，势必要考虑很多因素，比如成本及收益问题，怎么样才能达到最优的性价比?</li><li>虽然消息中间件种类繁多，但是各自都有各自的侧重点，选择合适自己、扬长避短无疑是最好的方式。如果你对此感到无所适从，本文或许可以参考一二。</li></ul><h4 id="各类消息队列简述"><a href="#各类消息队列简述" class="headerlink" title="各类消息队列简述"></a>各类消息队列简述</h4><h5 id="ActiveMQ-1"><a href="#ActiveMQ-1" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h5><ul><li>Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。</li><li>不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为 Apollo，号称下一代 ActiveMQ，有兴趣的同学可自行了解。</li></ul><h5 id="RabbitMQ-3"><a href="#RabbitMQ-3" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul><li>采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。</li><li>RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。</li></ul><h5 id="Kafka-2"><a href="#Kafka-2" class="headerlink" title="Kafka"></a>Kafka</h5><ul><li>起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。</li><li>它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用</li><li>目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</li></ul><h5 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h5><ul><li>是阿里开源的消息中间件，目前已经捐献给 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双 11 的洗礼，实力不容小觑。</li></ul><h5 id="ZeroMQ-1"><a href="#ZeroMQ-1" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h5><ul><li>号称史上最快的消息队列，基于 C 语言开发。ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩。</li><li>虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</li><li>目前市面上的消息中间件还有很多，比如腾讯系的 PhxQueue、CMQ、CKafka，又比如基于 Go 语言的 NSQ，有时人们也把类似 Redis 的产品也看做消息中间件的一种。</li></ul><h1 id="消息中间件选型要点"><a href="#消息中间件选型要点" class="headerlink" title="消息中间件选型要点"></a>消息中间件选型要点</h1><ul><li>衡量一款消息中间件是否符合需求，需要从多个维度进行考察。</li><li>首要的就是功能维度，这个直接决定了你能否最大程度上地实现开箱即用，进而缩短项目周期、降低成本等。</li><li>如果一款消息中间件的功能达不到想要的功能，那么就需要进行二次开发，这样会增加项目的技术难度、复杂度以及增大项目周期等。</li><li>消息中间件具体选型指标</li></ul><h4 id="功能维度"><a href="#功能维度" class="headerlink" title="功能维度"></a>功能维度</h4><h5 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h5><ul><li>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。</li><li>不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器(一般简单的称之为 Broker)中没有消息堆积。</li><li>那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</li></ul><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><ul><li>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”，这个是延迟队列的一种典型应用场景。</li><li>延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</li><li>延迟队列一般分为两种：<ul><li>基于消息的延迟，是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。</li><li>基于队列的延迟，实际应用中大多采用这种，设置不同延迟级别的队列，比如5s、10s、30s、1min、5mins、10mins等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略(比如定时)即可投递超时的消息。</li></ul></li></ul><h5 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h5><ul><li>由于某些原因消息无法被正确投递，为了确保消息不会被无故丢弃，一般将其置于一个特殊角色的队列，这个队列称为死信队列。</li><li>与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认(Ack), 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。</li><li>为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</li></ul><h5 id="重试队列"><a href="#重试队列" class="headerlink" title="重试队列"></a>重试队列</h5><ul><li>其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。</li><li>与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。</li><li>举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息。</li><li>如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。</li><li>以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。</li><li>重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发;延迟队列作用一次，而重试队列的作用范围会向后传递。</li></ul><h5 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h5><ul><li>消费模式分为推(push)模式和拉(pull)模式：<ul><li>推模式，是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。</li><li>拉模式，是指消费端主动向 Broker 端请求拉取(一般是定时或者定量)消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。</li></ul></li></ul><h5 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h5><ul><li>消息一般有两种传递模式——点对点(P2P，Point-to-Point)模式和发布&#x2F;订阅(Pub&#x2F;Sub)模式：</li><li>对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。</li><li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题(Topic)，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。</li><li>主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布&#x2F;订阅模式在消息的一对多广播时采用。</li><li>RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。</li><li>但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组(Consumer Group)的概念看成是队列的概念。</li><li>不过对比来说，Kafka 中因为有了消息回溯功能的存在，对于广播消费的力度支持比 RabbitMQ 的要强。</li></ul><h5 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h5><ul><li>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息</li><li>消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。</li><li>对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失，一般很难追查。</li><li>如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头所在。</li><li>消息回溯的作用远不止于此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。</li></ul><h5 id="消息堆积-持久化"><a href="#消息堆积-持久化" class="headerlink" title="消息堆积+持久化"></a>消息堆积+持久化</h5><ul><li>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。</li><li>从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。</li><li>消息堆积分内存式堆积和磁盘式堆积：</li><li>RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘(换页动作会影响吞吐)，或者直接使用惰性队列来将消息直接持久化至磁盘中。</li><li>Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。</li><li>一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。</li><li>从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引《纽约时报》的案例，其直接将 Kafka 用作存储系统。</li></ul><h5 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h5><ul><li>对于分布式架构系统中的链路追踪(Trace)，大家一定不陌生</li><li>对于消息中间件，消息的链路追踪(以下简称消息追踪)同样重要，最通俗来理解，就是要知道消息从哪来，存在哪里以及发往哪里去。</li><li>基于此功能，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。</li></ul><h5 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h5><ul><li>消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。</li><li>就以 Kafka 而言，完全可以将不同类别的消息发送至不同的 Topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 Topic 中的消息进行分类。</li><li>不过，更加严格意义上的消息过滤，应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。</li><li>同样以 Kafka 为例，可以通过客户端提供的 Consumer Interceptor 接口或者 Kafka Stream 的 Filter 功能进行消息过滤。</li></ul><h5 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h5><ul><li>也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。</li><li>RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 VHost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。</li><li>VHost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。</li></ul><h5 id="多协议支持"><a href="#多协议支持" class="headerlink" title="多协议支持"></a>多协议支持</h5><ul><li>消息是信息的载体，为了让生产者和消费者都能理解所承载的信息(生产者需要知道如何构造消息，消费者需要知道如何解析消息)，它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。</li><li>有效的消息一定具有某种格式，而没有格式的消息是没有意义的。</li><li>一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等(消息领域中的 JMS 更多的是一个规范而不是一个协议)，支持的协议越多其应用范围就会越广，通用性越强。</li><li>比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。</li></ul><h5 id="跨语言支持"><a href="#跨语言支持" class="headerlink" title="跨语言支持"></a>跨语言支持</h5><ul><li>对很多公司而言，其技术栈体系中会有多种编程语言，如 C&#x2F;C++、Java、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。</li><li>跨语言的支持力度也从侧面反映出一个消息中间件的流行程度。</li></ul><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><ul><li>针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应</li><li>通常的流控方法有 Stop-and-Wait、滑动窗口以及令牌桶等。</li></ul><h5 id="消息顺序性"><a href="#消息顺序性" class="headerlink" title="消息顺序性"></a>消息顺序性</h5><ul><li>顾名思义，是指保证消息有序</li><li>这个功能有个很常见的应用场景就是 CDC(Change Data Chapture)。</li><li>以 MySQL 为例，如果其传输的 Binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1，造成数据不一致。</li></ul><h5 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h5><ul><li>在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制：<ul><li>身份认证，是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制。</li><li>权限控制，是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。</li></ul></li><li>对于 RabbitMQ 而言，其同样提供身份认证(TLS&#x2F;SSL、SASL)和权限控制(读写操作)的安全机制。</li></ul><h5 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h5><ul><li>确保消息在生产者和消费者之间进行传输，一般有三种传输保障(Delivery Guarantee)：<ul><li>At most once，至多一次，消息可能丢失，但绝不会重复传输。</li><li>At least once，至少一次，消息绝不会丢，但是可能会重复。</li><li>Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。</li></ul></li><li>对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</li><li>Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等。</li><li>而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS(Exactly Once Semantic)的能力。</li><li>不过如果要考虑全局的幂等，还需要从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。</li><li>以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法由消息中间件层面来保证的。</li><li>如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。</li></ul><h5 id="事务性消息"><a href="#事务性消息" class="headerlink" title="事务性消息"></a>事务性消息</h5><ul><li>事务本身是一个并不陌生的词汇，事务是由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。</li><li>支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。</li><li>消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。</li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li>功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度，有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得。<br>K- afka 在开启幂等、事务功能的时候会使其性能降低;RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大影响其性能。</li></ul><h5 id="性能指什么"><a href="#性能指什么" class="headerlink" title="性能指什么?"></a>性能指什么?</h5><ul><li>消息中间件的性能一般是指其吞吐量</li><li>虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级。</li><li>一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。</li><li>注明：消息中间件的吞吐量始终会受到硬件层面的限制。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过(1Gb&#x2F;8)&#x2F;100W，即约等于 134B。</li><li>换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。</li></ul><h5 id="性能的指标是什么"><a href="#性能的指标是什么" class="headerlink" title="性能的指标是什么?"></a>性能的指标是什么?</h5><ul><li>时延作为性能维度的一个重要指标，却往往在消息中间件领域被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。</li><li>消息中间件具备消息堆积的能力，消息堆积越大也就意味着端到端的时延也就越长，与此同时延时队列也是某些消息中间件的一大特色。那么为什么还要关注消息中间件的时延问题呢?</li><li>消息中间件能够解耦系统，对于一个时延较低的消息中间件而言，它可以让上游生产者发送消息之后可以迅速的返回，也可以让消费者更加快速的获取到消息，在没有堆积的情况下，可以让整体上下游的应用之间的级联动作更加高效。</li><li>虽然不建议在时效性很高的场景下使用消息中间件，但是如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。</li></ul><h4 id="可靠性-可用性"><a href="#可靠性-可用性" class="headerlink" title="可靠性+可用性"></a>可靠性+可用性</h4><ul><li>消息丢失是使用消息中间件时所不得不面对的一个痛点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素</li><li>尤其是在金融支付领域，消息可靠性尤为重要。</li><li>然而说到可靠性必然要说到可用性，注意这两者之间的区别：<ul><li>可靠性是指对消息不丢失的保障程度。</li><li>可用性是指无故障运行的时间百分比，通常用几个 9 来衡量。</li></ul></li><li>从狭义的角度来说，分布式系统架构是一致性协议理论的应用实现，对于消息可靠性和可用性而言也可以追溯到消息中间件背后的一致性协议：<ul><li>对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，通过 ISR(In-Sync-Replica)来保证多副本之间的同步，并且支持强一致性语义(通过 Acks 实现)。</li><li>对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。</li></ul></li><li>多副本可以保证在 Master 节点宕机异常之后可以提升 Slave 作为新的 Master 而继续提供服务来保障可用性。</li><li>Kafka 设计之初是为日志处理而生，给人们留下了数据可靠性要求不高的不良印象，但是随着版本的升级优化，其可靠性得到极大的增强，详细可以参考 KIP101。</li><li>就目前而言，在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多，随着 RabbitMQ 性能的不断提升和 Kafka 可靠性的进一步增强，相信彼此都能在以前不擅长的领域分得一杯羹。</li><li>同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘。</li><li>但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。</li><li>这里还要提及的一个方面是扩展能力，这里我狭隘地将此归纳到可用性这一维度，消息中间件的扩展能力能够增强其可用能力及范围，比如前面提到的 RabbitMQ 支持多种消息协议，这个就是基于其插件化的扩展实现。</li><li>还有从集群部署上来讲，归功于 Kafka 的水平扩展能力，其基本上可以达到线性容量提升的水平，在 LinkedIn 实践介绍中就提及了有部署超过千台设备的 Kafka 集群。</li></ul><h4 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h4><ul><li>在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复?</li><li>业务线流量有峰值有低谷，尤其是电商领域，那么怎样进行有效的容量评估，尤其是大促期间?脚踢电源、网线被挖等事件层出不穷，如何有效的做好异地多活?</li><li>这些都离不开消息中间件的衍生产品——运维管理。运维管理也可以进行进一步的细分，比如申请、审核、监控、告警、管理、容灾、部署等。</li><li>申请、审核很好理解，在源头对资源进行管控，既可以有效校正应用方的使用规范，配合监控也可以做好流量统计与流量评估工作。</li><li>一般申请、审核与公司内部系统交融性较大，不适合使用开源类的产品。</li><li>监控、告警也比较好理解，对消息中间件的使用进行全方位的监控，既可以为系统提供基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。</li><li>除了一般的监控项(比如硬件、GC 等)之外，消息中间件还需要关注端到端时延、消息审计、消息堆积等方面：</li><li>对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，但是社区内还有 AppDynamics、Collectd、DataDog、Ganglia、Munin、Nagios、New Relic、Prometheus、Zenoss 等多种优秀的产品。</li><li>Kafka 在此方面也毫不逊色，比如：Kafka Manager、Kafka Monitor、Kafka Offset Monitor、Burrow、Chaperone、Confluent Control Center 等产品，尤其是 Cruise 还可以提供自动化运维的功能。</li><li>不管是扩容、降级、版本升级、集群节点部署、还是故障处理都离不开管理工具的应用，一个配套完备的管理工具集可以在遇到变更时做到事半功倍。</li><li>故障可大可小，一般是一些应用异常，也可以是机器掉电、网络异常、磁盘损坏等单机故障，这些故障单机房内的多副本足以应付。</li><li>如果是机房故障就要涉及异地容灾了，关键点在于如何有效的进行数据复制，Kafka 可以参考 MirrorMarker、uReplicator 等产品，而 RabbitMQ 可以参考 Federation 和 Shovel。</li></ul><h4 id="社区力度及生态发展"><a href="#社区力度及生态发展" class="headerlink" title="社区力度及生态发展"></a>社区力度及生态发展</h4><ul><li>对于目前流行的编程语言而言，如 Java、Python，如果你在使用过程中遇到了一些异常，基本上可以通过搜索引擎的帮助来得到解决，因为一个产品用的人越多，踩过的坑也就越多，对应的解决方案也就越多。</li><li>消息中间件也同样适用，如果你选择了一种“生僻”的消息中间件，可能在某些方面运用的得心应手，但是版本更新缓慢、遇到棘手问题也难以得到社区的支持而越陷越深。</li><li>相反如果你选择了一种“流行”的消息中间件，其更新力度大，不仅可以迅速的弥补之前的不足，而且也能顺应技术的快速发展来变更一些新的功能，这样可以让你也“站在巨人的肩膀上”。</li><li>在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。</li></ul><h4 id="消息中间件选型误区总结"><a href="#消息中间件选型误区总结" class="headerlink" title="消息中间件选型误区总结"></a>消息中间件选型误区总结</h4><h5 id="选型误区"><a href="#选型误区" class="headerlink" title="选型误区"></a>选型误区</h5><ul><li>选型之前可以先问自己一个问题：是否真的需要一个消息中间件?</li><li>在搞清楚这个问题之后，还可以继续问自己一个问题：是否需要自己维护一套消息中间件?</li><li>很多初创型公司为了节省成本会选择直接购买消息中间件有关的云服务，自己只需要关注收发消息即可，其余的都可以外包出去。</li><li>很多人面对消息中间件有一种自研的冲动，你完全可以对 Java 中的 ArrayBlockingQueue 做一个简单的封装，你也可以基于文件、数据库、Redis 等底层存储封装而形成一个消息中间件。</li><li>消息中间件做为一个基础组件并没有想象中的那么简单，其背后还需要配套的管理运维整个生态的产品集。</li><li>自研还会有交接问题，如果文档不齐全、运作不规范将会带给新人噩梦般的体验。</li><li>是否真的有自研的必要?如果不是 KPI 的压迫可以先考虑下面这两个问题：<ul><li>目前市面上的消息中间件是否都真的无法满足目前的业务需求?</li><li>团队是否有足够的能力、人力、财力、精力来支持自研?</li></ul></li><li>很多人在做消息中间件选型时会参考网络上的很多对比类的文章，但是其专业性、严谨性、以及其政治立场问题都有待考证，需要带着怀疑的态度去审视这些文章。</li><li>比如有些文章会在没有任何限定条件及场景的情况下直接定义某款消息中间件最好。</li><li>还有些文章没有指明消息中间件版本及测试环境就来做功能和性能对比分析，诸如此类的文章都可以唾弃之。</li><li>消息中间件犹如小马过河，选择合适的才最重要。这需要贴合自身的业务需求，技术服务于业务，大体上可以根据上一节所提及的功能、性能等 6 个维度来一一进行筛选。更深层次的抉择在于你能否掌握其魂。</li><li>笔者鄙见：RabbitMQ 在于 Routing，而 Kafka 在于 Streaming，了解其根本对于自己能够对症下药选择到合适的消息中间件尤为重要。</li><li>消息中间件选型切忌一味的追求性能或者功能，性能可以优化，功能可以二次开发。</li><li>如果要在功能和性能方面做一个抉择的话，那么首选性能，因为总体上来说性能优化的空间没有功能扩展的空间大。然而看长期发展，生态又比性能以及功能都要重要。</li></ul><h5 id="可靠性误区"><a href="#可靠性误区" class="headerlink" title="可靠性误区"></a>可靠性误区</h5><ul><li>很多时候，可靠性方面也容易存在一个误区：想要找到一个产品来保证消息的绝对可靠，很不幸的是这世界上没有绝对的东西，只能说尽量趋于完美。</li><li>想要尽可能的保障消息的可靠性也并非单单只靠消息中间件本身，还要依赖于上下游，需要从生产端、服务端和消费端这 3 个维度去努力保证。</li><li>消息中间件选型还有一个考量标准就是尽量贴合团队自身的技术栈体系，虽然说没有蹩脚的消息中间件，只有蹩脚的程序员，但是让一个 C 栈的团队去深挖 PhxQueue 总比去深挖 Scala 编写的 Kafka 要容易的多。</li><li>消息中间件大道至简：一发一存一消费，没有最好的消息中间件，只有最合适的消息中间件</li></ul><h1 id="消息服务的应用场景有哪些？"><a href="#消息服务的应用场景有哪些？" class="headerlink" title="消息服务的应用场景有哪些？"></a>消息服务的应用场景有哪些？</h1><ul><li>如下 3 个场景都可以使用消息服务<ul><li>异步处理</li><li>应用的解耦</li><li>流量的削峰</li></ul></li></ul><h1 id="Zookeeper-对于-Kafka-的作用是什么？"><a href="#Zookeeper-对于-Kafka-的作用是什么？" class="headerlink" title="Zookeeper 对于 Kafka 的作用是什么？"></a>Zookeeper 对于 Kafka 的作用是什么？</h1><ul><li>Zookeeper 是一个开放源码的、高性能的协调服务，它用于 Kafka 的分布式应用。</li><li>Zookeeper 主要用于在集群中不同节点之间进行通信</li><li>在 Kafka 中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取<br>除此之外，它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等。</li></ul><h1 id="RabbitMQ-有哪些重要的角色？"><a href="#RabbitMQ-有哪些重要的角色？" class="headerlink" title="RabbitMQ 有哪些重要的角色？"></a>RabbitMQ 有哪些重要的角色？</h1><ul><li>RabbitMQ 中重要的角色有：生产者、消费者和代理：</li><li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li><li>消费者：消息的接收方，用于处理数据和确认消息；</li><li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h1 id="RabbitMQ-有哪些重要的组件？"><a href="#RabbitMQ-有哪些重要的组件？" class="headerlink" title="RabbitMQ 有哪些重要的组件？"></a>RabbitMQ 有哪些重要的组件？</h1><ul><li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li><li>Channel（信道）：消息推送使用的通道。</li><li>Exchange（交换器）：用于接受、分配消息。</li><li>Queue（队列）：用于存储生产者的消息。</li><li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li></ul><h1 id="RabbitMQ-中-vhost-的作用是什么？"><a href="#RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="RabbitMQ 中 vhost 的作用是什么？"></a>RabbitMQ 中 vhost 的作用是什么？</h1><ul><li>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</li></ul><h1 id="RabbitMQ-的消息是怎么发送的？"><a href="#RabbitMQ-的消息是怎么发送的？" class="headerlink" title="RabbitMQ 的消息是怎么发送的？"></a>RabbitMQ 的消息是怎么发送的？</h1><ul><li>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</li></ul><h1 id="RabbitMQ-怎么保证消息的稳定性？"><a href="#RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="RabbitMQ 怎么保证消息的稳定性？"></a>RabbitMQ 怎么保证消息的稳定性？</h1><ul><li>提供了事务的功能。</li><li>通过将 channel 设置为 confirm（确认）模式。</li></ul><h1 id="RabbitMQ-怎么避免消息丢失？"><a href="#RabbitMQ-怎么避免消息丢失？" class="headerlink" title="RabbitMQ 怎么避免消息丢失？"></a>RabbitMQ 怎么避免消息丢失？</h1><ul><li>把消息持久化磁盘，保证服务器重启消息不丢失。</li><li>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li></ul><h1 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h1><ul><li>声明队列必须设置持久化 durable 设置为 true.</li><li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li><li>消息已经到达持久化交换器。</li><li>消息已经到达持久化队列。</li><li>以上四个条件都满足才能保证消息持久化成功。</li></ul><h1 id="RabbitMQ-持久化有什么缺点？"><a href="#RabbitMQ-持久化有什么缺点？" class="headerlink" title="RabbitMQ 持久化有什么缺点？"></a>RabbitMQ 持久化有什么缺点？</h1><ul><li>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</li></ul><h1 id="RabbitMQ-有几种广播类型？"><a href="#RabbitMQ-有几种广播类型？" class="headerlink" title="RabbitMQ 有几种广播类型？"></a>RabbitMQ 有几种广播类型？</h1><ul><li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</li><li>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</li><li>fanout：分发模式，把消费分发给所有订阅者。</li><li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</li></ul><h1 id="RabbitMQ-怎么实现延迟消息队列？"><a href="#RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="RabbitMQ 怎么实现延迟消息队列？"></a>RabbitMQ 怎么实现延迟消息队列？</h1><ul><li>延迟队列的实现有两种方式：<ul><li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li><li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li></ul></li></ul><h1 id="RabbitMQ-集群有什么用？"><a href="#RabbitMQ-集群有什么用？" class="headerlink" title="RabbitMQ 集群有什么用？"></a>RabbitMQ 集群有什么用？</h1><ul><li>集群主要有以下两个用途：<ul><li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li><li>高容量：集群可以承载更多的消息量。</li></ul></li></ul><h1 id="RabbitMQ-节点的类型有哪些？"><a href="#RabbitMQ-节点的类型有哪些？" class="headerlink" title="RabbitMQ 节点的类型有哪些？"></a>RabbitMQ 节点的类型有哪些？</h1><ul><li>磁盘节点：消息会存储到磁盘。</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li></ul><h1 id="RabbitMQ-集群搭建需要注意哪些问题？"><a href="#RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="RabbitMQ 集群搭建需要注意哪些问题？"></a>RabbitMQ 集群搭建需要注意哪些问题？</h1><ul><li>各节点之间使用“–link”连接，此属性不能忽略。</li><li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li><li>整个集群中必须包含一个磁盘节点。</li></ul><h1 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h1><ul><li>不是，原因有以下两个：<ul><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li></ul></li></ul><h1 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h1><ul><li>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li><li>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</li></ul></li></ul><h1 id="RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗？"></a>RabbitMQ 对集群节点停止顺序有要求吗？</h1><ul><li>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/4/">4</a><span class="page-number current">5</span></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">458k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:56</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>