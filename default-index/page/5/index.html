<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/page/5/index.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/page/5/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/5/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">32</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">58</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/5352a96111d6.html" class="post-title-link" itemprop="url">Java基础</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-03 23:42:05" itemprop="dateModified" datetime="2024-01-03T23:42:05+08:00">2024-01-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>557k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8:26</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h1><ul><li>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架</li><li>Java反射的主要功能：<ul><li>确定一个对象的类</li><li>取出类的modifiers,数据成员,方法,构造器,和超类.</li><li>找出某个接口里定义的常量和方法说明.</li><li>创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).</li><li>取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.</li><li>在运行时刻调用动态对象的方法.</li></ul></li></ul><h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul><li>方法名称相同，参数的类型或个数不同</li><li>方法名称、参数类型、返回值类型全部相同</li><li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li><li>范围 发生在一个类中 发生在继承类中</li><li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li><li>反射的应用很多，很多框架都有用到<ul><li>spring 的 ioc&#x2F;di 也是反射…</li><li>javaBean和jsp之间调用也是反射…</li><li>struts的 FormBean 和页面之间…也是通过反射调用…</li><li>JDBC 的 classForName()也是反射…</li><li>hibernate的 find(Class clazz) 也是反射…</li><li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li></ul></li></ul><h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul><li>加载JDBC驱动程序</li><li>提供JDBC连接的URL</li><li>创建数据库的连接</li><li>创建一个Statement</li><li>执行SQL语句</li><li>处理结果</li><li>关闭JDBC对象</li></ul><h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><p>1.hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和<br>containsKey（）方法。<br>2.hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。<br>3.hashMap允许空键值，而hashTable不允许。<br>注意：<br>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状<br>态。<br>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p><h1 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h1><p>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是<br>用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过<br>key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象</p><h1 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h1><p>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上<br>都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更<br>好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>HashMap 的工作原理及代码实现<br>参考：<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，<br>当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时<br>间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，<br>16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一<br>个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来<br>决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步<br>机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只<br>是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个<br>Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此<br>HashTable已经被淘汰了。</p><h1 id="Java中创建线程主要有三种方式："><a href="#Java中创建线程主要有三种方式：" class="headerlink" title="Java中创建线程主要有三种方式："></a>Java中创建线程主要有三种方式：</h1><p>一、继承Thread类创建线程类<br>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完<br>成的任务。因此把run()方法称为执行体。<br>（2）创建Thread子类的实例，即创建了线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。getName()方法返<br>回调用该方法的线程的名字。<br>二、通过Runnable接口创建线程类<br>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是<br>该线程的线程执行体。<br>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该<br>Thread对象才是真正的线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>三、通过Callable和Future创建线程<br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且<br>有返回值。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对<br>象封装了该Callable对象的call()方法的返回值。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><h1 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h1><p>1、sleep()方法<br>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度<br>程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如<br>果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常<br>比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一<br>个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级<br>的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。<br>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的<br>线程有执行的机会。<br>2、yield()方法<br>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方<br>法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态<br>后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也<br>和sleep()方法不同。<br>3、join()方法<br>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，<br>B不能工作。<br>保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有<br>存活，则当前线程不需要停止。<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲<br>突。<br>在Java里，线程安全一般体现在两个方面：<br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关<br>键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有<br>synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，<br>问题就出现了。<br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在<br>java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>volatile 实现原理<br>聊聊并发（一）——深入分析Volatile的实现原理<br>悲观锁 乐观锁<br>乐观锁 悲观锁<br>是一种思想。可以用在很多方面。<br>比如数据库方面。<br>悲观锁就是for update（锁定查询的行）<br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读­<br>比较­写的操作。）<br>JDK方面：<br>悲观锁就是sync<br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。<br>乐观锁就认为，基本没人抢。<br>CAS 乐观锁<br>乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出<br>当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重<br>复读­比较­写的操作。<br>CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。<br>CAS顶多算是乐观锁写那一步操作的一种实现方式罢了，不用CAS自己加锁也是可以的。<br>ABA 问题<br>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A，当前线程的CAS<br>操作无法分辨当前V值是否发生过变化。<br>参考：<br>Java CAS 和ABA问题<br>乐观锁的业务场景及实现方式<br>乐观锁（Optimistic Lock）：<br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，<br>但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不<br>进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，<br>期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可<br>能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量<br>的查询操作，降低了系统的吞吐量。<br>核心篇<br>数据存储<br>MySQL 索引使用的注意事项<br>参考：<br>mysql索引使用技巧及注意事项<br>说说反模式设计<br>参考：<br>每个程序员要注意的 9 种反模式<br>说说分库与分表设计<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策<br>说说 SQL 优化之道<br>sql优化的几种方法<br>微服务哪些框架<br>Spring Cloud、Dubbo、Hsf等<br>你怎么理解 RPC 框架<br>RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这<br>个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。<br>说说 RPC 的实现原理<br>参考：<br>你应该知道的 RPC 原理<br>从零开始实现RPC框架 ­ RPC原理及实现</p><p>分布式<br>谈谈业务中使用分布式的场景<br>一、解决java集群的session共享的解决方案：<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>二、分布式事务的解决方案:<br>1.TCC解决方案：try confirm cancel。<br>参考：<br>为什么说传统分布式事务不再适用于微服务架构？<br>Session 分布式方案<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库<br>更多Java技术资料视频分享+QQ2118797017<br>来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>分布式锁的场景<br>比如交易系统的金额修改，同一时间只能又一个人操作，比如秒杀场景，同一时间只能一个<br>用户抢到，比如火车站抢票等等<br>分布式锁的实现方案<br>26. 基于数据库实现分布式锁<br>27. 基于缓存实现分布式锁<br>28. 基于Zookeeper实现分布式锁<br>参考：<br>分布式锁的多种实现方式<br>分布式事务<br>参考：<br>深入理解分布式事务,高并发下分布式事务的解决方案<br>集群与负载均衡的算法与实现<br>参考：<br>负载均衡算法及手段<br>说说分库与分表设计<br>参考：<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>安全&amp;性能<br>安全问题<br>安全要素与 STRIDE 威胁<br>防范常见的 Web 攻击<br>XSS攻击<br>跨站脚本攻击;<br>是什么：攻击者向有XSS漏洞的网站中输入恶意的HTML代码，当其浏览器浏览该网站<br>时，这段HTML代码会自­ ­ 动执行。（理论上所有可以输入的地方没有对输入的数据进<br>行处理，都会存在XSS攻击）;<br>危害： 盗取用户cookie，破坏页面结构，重定向到其他网站;<br>防御：对用户输入的信息进行处理，只允许合法的值;<br>CSRF攻击<br>跨站请求伪造<br>是什么：攻击者盗用了你的身份，以你的名义发送恶意请求;<br>危害：以你的名义发送邮件，盗取帐号，购买东西等;<br>原理： 首先个登录某网站，并在本地生成cookie;然后在不登出的情况下，访问危害网<br>站。<br>防御： 可以从服务端和客户端两方面进行考虑。但是在服务端的效果好。<br>a. 随机的cookie<br>b. 添加验证码<br>c. 不同的表单包含一个不同的伪随机值<br>注意：如果用户在一个站点上同时打开了两个不同的表单。CSRF保护措施不应该影响<br>到他对任何表单的提交<br>SQL注入<br>是什么：通过sql命令伪装成正常的http请求参数，传递到服务端，服务器执行sql命令<br>造成对数据库进行攻击<br>原理：sql语句伪造参数，然后在对参数机型拼接后形成破坏性的sql语句，最后导致数<br>据库收到攻击<br>防御：<br>a. 对参数进行转义<br>b. 数据库中的密码不应明文存储，可以对密码使用md5进行加密。<br>DDOS攻击（分布式拒绝服务攻击）<br>是什么：简单来说就是ifasong大量的请求使服务器瘫痪。<br>被攻击的原因：服务器带宽不足，不能挡住攻击者的攻击流量。<br>防御：<br>a. 最直接的方法就是增加带宽;<br>b. 使用硬件防火墙;<br>c. 优化资源使用提高 web server 的负载能力<br>服务端通信安全攻防<br>HTTPS 原理剖析<br>HTTPS 降级攻击<br>授权与认证<br>基于角色的访问控制<br>基于数据的访问控制<br>基于角色的访问控制，只验证访问数据的角色，但是没有对角色内的用户做细分。举个例<br>子，用户甲与用户乙都具有用一个角色，但是如果只建立基于角色的访问控制，那么用户甲<br>可以对用户乙的数据进行任意操作，从而发生了越权访问。因此，在业务场景中仅仅使用基<br>于角色的访问控制是不够的，还需要引入基于数据的访问控制。如果将基于角色的访问控制<br>视为一种垂直权限控制，那么，基于数据的访问控制就是一种水平权限控制。在业务场景<br>中，往往对基于数据的访问控制不够重视，举个例子，评论功能是一个非常常见的功能，用<br>户可以在客户端发起评论，回复评论，查看评论，删除评论等操作。一般情况下，只有本人<br>才可以删除自己的评论，如果此时，业务层面没有建立数据的访问控制，那么用户甲可以试<br>图绕过客户端，通过调用服务端RESTful API 接口，猜测评论 ID 并修改评论 ID 就可以删除<br>别人的评论。事实上，这是非常严重的越权操作。除此之外，用户之间往往也存在一些私有<br>的数据，而这些私有的数据在正常情况下，只有用户自己才能访问。<br>基于数据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引<br>起重视。这里，再次使用删除评论的案例，通过 Java 语言进行介绍。在这个案例中，核心<br>的代码片段在于，判断当前用户是否是评论的创建者，如果是则通过，不是则报出没有权限<br>的错误码。那么，这样就可以很好地防止数据的越权操作。<br>总结下，基于角色的访问控制是一种垂直权限控制，通过建立用户与角色的对应关系，使得<br>不同角色之间具有高低之分。用户根据拥有的角色进行操作与资源访问。基于数据的访问控<br>制是一种水平权限控制，它对角色内的用户做细分，确保用户的数据不能越权操作。基于数<br>据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引起重<br>视。<br>性能优化<br>性能指标有哪些<br>如何发现性能瓶颈<br>性能调优的常见手段<br>说说你在项目中如何进行性能调优</p><p>1.八种基本数据类型的大小，以及他们的封装类<br>double—Double 8位0.0d<br>float —Float 4位0.0f<br>long —Long8位0L<br>int —Integer 4位0<br>short —Short 2位(short)0<br>byte —byte1位(byte)0<br>char —Character 2位null\u0000<br>boolean —Boolean – false<br>2.引用数据类型<br>数组，类，接口<br>3.Switch能否用string做参数<br>以前只能支持byte、short、char、int，可以强转<br>Jdk7.0以后可以，整型、枚举类型、boolean、字符串都可以<br>4.equals与&#x3D;&#x3D;的区别*<br>&#x3D;&#x3D;比较的是2个对象的地址，而equals比较的是2个对象的内容<br>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。<br>Equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。<br>5.自动装箱，常量池<br>自动装箱：基本数据类型对象类型<br>自动拆箱：对象类型基本数据类型<br>常量池：Byte,Short,Integer,Long,Character在自动装箱时对于值从–128到127之间的值（共享），会存在内存中被重用<br>字符串常量池<br>常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s &#x3D; “java”这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。<br>6.Object有哪些公用方法<br>clone(),hashCode(),equals(),notify(),notifyAll(),wait(),getClass(),toString,finalize()<br>8.Hashcode的作用*<br>利用哈希算法，配合基于散列的集合一起正常运行，Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值，降低equals的调用，实现存放的值不会重复。<br>Note:重写equals必须重写hashcode方法，equals相等，hashcode也必须相等。<br>一般对于存放到Set集合或者Map中键值对的元素，需要按需要重写hashCode与equals方法，以保证唯一性！<br>例如hashset存放多个对象，重写equals和hashcode<br>两个对象相等，其HashCode一定相同;<br>两个对象不相等，其HashCode有可能相同;<br>HashCode相同的两个对象，不一定相等;<br>HashCode不相同的两个对象，一定不相等;<br>9.HashMap的hashcode的作用*<br>Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 equals方法可用于保证元素不重复，但是，如果每增加一个元素就检查一次，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次equals方法。这显然会大大降低效率。<br>HashMap的数据结构是 数组+链表形式存储数据，继承AbstractMap，实现Map接口，主要用于查找的快捷性。<br>10.为什么重载hashCode方法？*<br>一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是object对象，必须重载hashCode和equal方法。<br>11.ArrayList、LinkedList、Vector的区别*<br>ArrayList： 线程不安全，数组，适合查找，可自动扩容50%<br>三个构造器，无参，容量，Collection接口，transient Object[] elementData;不被序列化。<br>LinkedList：线程不安全，链表，审核插入，删除<br>Vector： 线程安全，数组，适合查找，可自动扩容100%<br>12.String、StringBuffer与StringBuilder的区别*<br>String 是final修饰的，字符串常量，String对象一旦创建之后该对象是不可更改的<br>StringBuffer 字符串变量，对象可变，线程安全，适合多线程下字符缓冲区大量操作<br>StringBuider 字符串变量，对象可变，线程不安全，适用单线程下载字符缓冲区进行大量操作的情况，都是继承AbstractStringBuilder super.容量为16<br>13.Map、Set、List、Queue、Stack的特点与用法。<br>Map map集合，k-v键值对存储<br>HashTable 和 HashMap 是 Map 的实现类   <br>HashTable 是线程安全的，不能存储 null 值   <br>HashMap 不是线程安全的，可以存储 null 值  <br>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。<br>Set 集合，无序，不重复<br>List 数组集合，ArrayList ， Vector ， LinkedList 是 List 的实现类<br>ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的<br>LinkedList 是线程不安全的，底层是由链表实现的   <br>Queue 队列，提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。<br>Stack 栈，继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。<br>HashMap和HashTable的区别<br>14.JDK7与JDK8中HashMap的实现*<br>JDK8在JDK7的基础上引入了红黑树-b，因为链表过长，会导致效率很低，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率<br>15.HashMap和ConcurrentHashMap的区别，HashMap的底层源码*<br>HashMap是线程不安全的，ConcurrentHashMap是线程安全的，适用于高并发，ConcurrentHashMap就是一个分段的hashtable，根据自定的hashcode算法生成的对象来获取对应hashcode的分段块进行加锁，不用整体加锁，提高了效率。<br>HashMap的get（key）方法是获取key的hash值，计算hash&amp;（n-1）得到在链表数组中的位置first&#x3D;tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可。<br>HashMap的put（key）方法是判断键值对数组tab[]是否为空或位null，否则以默认大小resize()；根据键值key计算hash值得到插入的数组索引i，如果tab[i]&#x3D;&#x3D;null,直接新建节点添加，否则判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可)，分别处理。<br>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比<em>Node.length）重新调整HashMap大小 变为原来2倍大小,扩容很耗时<br>16.ConcurrentHashMap能完全替代HashTable吗？<br>Hash table虽然性能上不如ConcurrentHashMap，但并不能完全被取代，两者的迭代器的一致性不同的，ConcurrentHashMap由于分段锁，弱一致性主要是为了提升效率。<br>强一致性就如hashtable一样，锁整个map。<br>17.为什么HashMap是线程不安全的</em><br>在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，如图中a1、a2，这个时候需要解决碰撞冲突，而解决冲突的办法上面已经说过，对于链表的结构在这里不再赘述，暂且不讨论是从链表头部插入还是从尾部初入，这个时候两个线程如果恰好都取到了对应位置的头结点e1，而最终的结果可想而知，a1、a2两个数据中势必会有一个会丢失<br>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。<br>18.多并发情况下HashMap是否还会产生死循环*<br>不会，jdk1.8版本以后已经没有这个问题了，没有transfer这个函数了do while可能造成的死循环，对原有造成死锁的关键原因点（新table复制在头端添加元素）改进为依次在末端添加新的元素<br>19.TreeMap、HashMap、LindedHashMap的区别*<br>LinkedHashMap可以保证HashMap集合有序。存入的顺序和取出的顺序一致。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。<br>HashMap不保证顺序，即为无序的，具有很快的访问速度。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步。<br>20.Collection包结构，与Collections的区别<br>Collection是个java.util下的接口，它是各种集合结构的父接口。<br>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<br>21.try?catch?finally，try里有return，finally还执行么<br>如果finally没有return 相同返回值变量，则返回try里面的return，否则finally 的return 值会影响 try里面return结果。<br>finally还是会执行的，除非中途遇到jvm退出。<br>22.Excption与Error包结构，OOM你遇到过哪些情况，SOF你遇到过哪些情况<br>都是Throwable的子类，Exception指出了合理的应用程序想要捕获的条件。Error 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件<br>Java Heap 溢出，虚拟机栈和本地方法栈溢出，运行时常量池溢出，方法区溢出<br>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br>23.Java(OOP)面向对象的三个特征与含义<br>封装：可见性封装，setget读写，将类的某些特征隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。<br>继承：子类继承父类，可以得到父类的全部属性和方法（除了父类中的构造方法），java中的多继承可以通过接口来实现。<br>多态：一种是编译时多态，另外一种是运行时多态，编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。<br>26.Static?class?与non?static?class的区别<br>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。<br>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。<br>27.foreach与正常for循环效率对比<br>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。<br>28.Java?IO与NIO*<br>NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I&#x2F;O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征<br>IO是面向流的，NIO是面向块（缓冲区）的。<br>IO是阻塞的，NIO是非阻塞的。<br>多连接，少数据可以用NIO<br>少连接，大数据可以用IO</p><h1 id="java反射的作用与原理"><a href="#java反射的作用与原理" class="headerlink" title="java反射的作用与原理"></a>java反射的作用与原理</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>在JAVA中，只有给定类的名字，就可以通过反射机制来获取类的所有信息，可以动态的创建对象和编译。<br>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。</p><h1 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h1><p>泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。<br>使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。<br>通过类型擦除来实现</p><h1 id="解析XML的几种方式的原理与特点：DOM、SAX"><a href="#解析XML的几种方式的原理与特点：DOM、SAX" class="headerlink" title="解析XML的几种方式的原理与特点：DOM、SAX"></a>解析XML的几种方式的原理与特点：DOM、SAX</h1><p>DOM分析器是把整个XML文档转化为DOM树放在内存中<br>SAX解析采用事件驱动，通过事件处理函数实现对xml文档的访问。</p><p>21.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？<br>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>22.Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？<br>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。<br>而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性<br>Put和读取多线程导致的问题。<br>23.ConcurrentHashMap的并发度是什么？*<br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势<br>24.ReentrantReadWriteLock读写锁的使用？<br>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 <br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；<br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！<br>36.高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？*<br>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看： 　　<br>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 　　<br>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换<br>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。<br>39.如果同步块内的线程抛出异常会发生什么？<br>只要退出了synchronized块，无论是正常还是异常，都会释放锁。<br>40.并发编程（concurrency）并行编程（parallellism）有什么区别？*<br>并发（concurrency）和并行（parallellism）是：<br>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>解释三：并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群<br>41.如何保证多线程下 i++ 结果正确？<br>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。<br>42.一个线程如果出现了运行时异常会怎么样?<br>如果该异常被捕获或抛出，则程序继续运行。 <br>如果异常没有被捕获该线程将会停止执行。 <br>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理<br>46.Java中用到的线程调度算法是什么*<br>操作系统的核心，它实际就是一个常驻内存的程序，不断地对线程队列进行扫描，利用特定的算法（时间片轮转法、优先级调度法、多级反馈队列调度法等）找出比当前占有CPU的线程更有CPU使用权的线程，并从之前的线程中收回处理器，再使待运行的线程占用处理器。<br>10.分派：静态分派与动态分派。<br>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的<br>动态分派：（重写）<br>数据结构与算法<br>1.链表与数组。<br>数组：ArrayList—静态分配内存，内存连续。数组元素在栈区。<br>链表：LinkedList—手持下一个人的地址，动态内存分配，内存不连续。数组元素在堆区<br>2.队列和栈，出栈与入栈。<br>queue队列是先进先出<br>入栈，s.push(x)<br>出栈，s.pop()<br>访问栈顶，s.top()<br>判断栈空，s.empty()<br>访问栈中的元素个数，s.size()<br>stack栈是先入后出<br>入队，q.push(x)<br>出队，q.pop()<br>访问队首元素，q.front()、访问队尾元素，q.back()<br>判断队列空，q.empty()<br>访问队列中的元素个数，q.size()<br>3.链表的删除、插入、反向。*<br>数据域，指针域，当前节点<br>删除需要找到上一个节点，然后指向下下节点，size减去1<br>插入，找上一个节点，设置next到新节点，新节点初始化上一节点的current.next<br>反向：head.getnext获取末尾节点，然后以此重新指向反转（递归反转法）<br>遍历反转法，按顺序依次反转。<br>4.字符串操作。<br>(1)字符串的连接<br>public String concat(String str) <br>该方法的参数为一个String类对象,作用是将参数中的字符串str连接到原来字符串的后面. <br>(2)求字符串的长度<br>public int length()<br>返回字串的长度,这里的长度指的是字符串中Unicode字符的数目.<br>(3)求字符串中某一位置的字符<br>public char charAt(int index)<br>该方法在一个特定的位置索引一个字符串,以得到字符串中指定位置的字符.值得注意的是,在字符串中第一个字符的索引是0,第二个字符的索引是1,依次类推,最后一个字符的索引是length()-1. <br>(4)字符串的比较<br>比较字符串可以利用String类提供的下列方法:<br>1)public int compareTo(String anotherString)<br>该方法比较两个字符串,和Character类提供的compareTo方法相似,Character类提供的compareTo方法比较的是两个字符类数据,而这里比较的是字符串数据.<br>其比较过程实际上是两个字符串中相同位置上的字符按Unicode中排列顺序逐个比较的结果.如果在整个比较过程中,没有发现任何不同的地方,则表明两个字符串是完全相等的,compareTo方法返回0;如果在比较过程中,发现了不同的地方,则比较过程会停下来,这时一定是两个字符串在某个位置上不相同,如果当前字符串在这个位置上的字符大于参数中的这个位置上的字符,compareTo方法返回一个大于0的整数,否则返回一个小于0的整数. <br>2)public boolean equals(Object anObject)<br>该方法比较两个字符串,和Character类提供的equals方法相似,因为它们都是重载Object类的方法.该方法比较当前字符串和参数字符串,在两个字符串相等的时候返回true,否则返回false.<br>3)public boolean equalsIgnoreCase(String anotherString)<br>该方法和equals方法相似,不同的地方在于,equalsIgnoreCase方法将忽略字母大小写的区别.<br>(5)从字符串中提取子串<br>利用String类提供的substring方法可以从一个大的字符串中提取一个子串,该方法有两种常用的形式:<br>1)public String substring(int beginIndex)<br>该方法从beginIndex位置起,从当前字符串中取出剩余的字符作为一个新的字符串返回.<br>2)public String substring(int beginIndex, int endIndex)<br>该方法从当前字符串中取出一个子串,该子串从beginIndex位置起至endIndex-1为结束.子串返的长度为endIndex-beginIndex. <br>(6)判断字符串的前缀和后缀<br>判断字符串的前缀是否为指定的字符串利用String类提供的下列方法:<br>1)public boolean startsWith(String prefix)<br>该方法用于判断当前字符串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>2)public boolean startsWith(String prefix, int toffset)<br>该方法用于判断当前字符串从toffset位置开始的子串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>判断字符串的后缀是否为指定的字符串利用String类提供的方法:<br>public boolean endsWith(String suffix)<br>该方法用于判断当前字符串的后缀是否和参数中指定的字符串suffix一致,如果是,返回true,否则返回false.<br>(7)字符串中单个字符的查找<br>字符串中单个字符的查找可以利用String类提供的下列方法:<br>1)public int indexOf(int ch)<br>该方法用于查找当前字符串中某一个特定字符ch出现的位置.该方法从头向后查找,如果在字符串中找到字符ch,则返回字符ch在字符串中第一次出现的位置;如果在整个字符串中没有找到字符ch,则返回-1. <br>2)public int indexOf(int ch, int fromIndex)<br>该方法和第一种方法类似,不同的地方在于,该方法从fromIndex位置向后查找,返回的仍然是字符ch在字符串第一次出现的位置. <br>3)public int lastIndexOf(int ch)<br>该方法和第一种方法类似,不同的地方在于,该方法从字符串的末尾位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>4)public int lastIndexOf(int ch, int fromIndex)<br>该方法和第二种方法类似,不同的地方在于,该方法从fromIndex位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>(8)字符串中子串的查找<br>字符串中子串的查找与字符串中单个字符的查找十分相似,可以利用String类提供的下列方法:<br>1)public int indexOf(String str)<br>2)public int indexOf(String str, int fromIndex)<br>3)public int lastIndexOf(String str)<br>4)public int lastIndexOf(String str, int fromIndex) <br>(9)字符串中字符大小写的转换<br>字符串中字符大小写的转换,可以利用String类提供的下列方法:<br>1)public String toLowerCase()<br>该方法将字符串中所有字符转换成小写,并返回转换后的新串.<br>2)public String toUpperCase()<br>该方法将字符串中所有字符转换成大写,并返回转换后的新串. <br>(10)字符串中多余空格的去除<br>public String trim()<br>该方法只是去掉开头和结尾的空格,并返回得到的新字符串.值得注意的是,在原来字符串中间的空格并不去掉. <br>(11)字符串中字符的替换<br>1)public String replace(char oldChar,char newChar)<br>该方法用字符newChar替换当前字符串中所有的字符oldChar,并返回一个新的字符串.<br>2)public String replaceFirst(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的第一个和字符串regex相一致的子串,并将产生的新字符串返回. <br>3)public String replaceAll(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的所有和字符串regex相一致的子串,并将产生的新字符串返回. <br>字符串变量与StringBuffer类 <br>1.创建StringBuffer类对象<br>StringBuffer类对象表示的是字符串变量,每一个StringBuffer类对象都是可以扩充和修改的字符串变量.以下是常用的StringBuffer类构造函数:<br>(1)public StringBuffer()<br>(2)public StringBuffer(int length) <br>(3)public StringBuffer(String str)  <br>5.Hash表的hash函数，冲突解决方法有哪些。<br>开放定址法或者叫再散列法；<br>1&gt;线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    2&gt;二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    3&gt;伪随机探测再散列：di&#x3D;伪随机序列；<br>再哈希法；<br>拉链法。<br>6.各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。<br>相连元素两两比较，大的往后放，第一次完毕后，最大值就出现在了最大索引处。同理，，继续，即可得到一个排好序的数组。<br>选择排序原理：<br>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i&#x3D;1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>插入排序原理：<br>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>归并排序的原理:<br>从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。<br>快速排序的原理:<br>从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。<br>堆排序的原理:<br>堆排序从小到大排序：首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，再将除了最后一个数的n-1个元素建立成大顶堆，再将最大元素和数组倒数第二个元素进行交换，重复直至堆大小减为1。<br>希尔排序的原理:<br>希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。<br>桶排序的原理:<br>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。<br>7.快排的partition函数与归并的Merge函数。<br>partition函数：双向扫描<br>Merge函数:最后再看每一组（一对）子表的归并，其原理是相同的，只是子表表长不同，换句话说，是子表的首记录号与尾记录号不同，把这个归并操作作为核心算法写成函数 merge <br>8.对冒泡与快排的改进。*<br>8.1 对冒泡的改进<br>    改进1：设置一个标志位，标志位代表在某一个冒泡遍历时候是否发生位置数据的交换，如果没有交换，则表明序列已经排序完成，否则继续排序。减少不必要的遍历。 <br>    改进2：再设置一个标志位，标志位是序列的某个下标，下标之后的代表已经排序完成，下标之前未排序，则遍历大于标志位时，不再遍历。减少一次遍历中已排完序的序列的遍历 <br>    改进3：在一次遍历时，同时找出最大值和最小值，从而提高效率。 <br>参考：排序算法（一）——冒泡排序及改进<br>8.2对快排的改进<br>基准的选取影响快排的效率，一般基准的选取有三种： <br>    1）固定位置。选序列第一位或者最后一位，算法的导论中提到的就是固定选择最后一位。 <br>    2）随机选取。对于序列中部分有序的情况，如果选择固定位置作为基准，会导致全序列都需要交换位置，这会使得效率低下。因此会采用随机选取数据作为基准。 <br>    3）三数取中。最佳划分是将序列划分成等长的两个子序列，因此提出三数取中的思想。取序列中，下标第一位，下标中间一位，下标最后一位的三个数进行排序，取排序结果中排中间的数据作为基准。（此外，也可以取5个数作为数据的基准。） <br>参考：三种快速排序以及快速排序的优化 <br>    针对以上三种情况中，三数取中效果最优，但是依然无法解决序列中出现重复情况，对此进行再次优化： <br>    优化1：当待排序序列的长度分割到一定大小后，使用插入排序。对于很小和部分有序的数组，快排不如插排好。 <br>    优化2：与基准值相同的不加入分割。在每一次分割结束后，可以把与基准相等的元素聚在一起，继续下次分割时，不用再对与基准相等元素分割。减少重复序列的反复分割 <br>    优化3：优化递归操作，快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。 <br>    这里提一下尾递归，如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归。需要说明的是递归调用必须整个函数体中最后执行的语句且它的返回值不属于表达式的一部分。 <br>尾递归的优点： <br>    1）尾递归通过迭代的方式，不存在子问题被多次计算的情况 <br>    2）尾递归的调用发生在方法的末尾，在计算过程中，完全可以把上一次留在堆栈的状态擦掉，保证程序以O(1)的空间复杂度运行。 <br>    可惜的是，在jvm中第二点并没有被优化。 <br>9.二分查找，与变种二分查找。<br>二分查找的中间下标：mid&#x3D;low+0.5∗(high−low)mid&#x3D;low+0.5∗(high−low) <br>    二分+插值： <br>    如果序列长度为1000，查找的关键字在10位置上，则还是需要从500中间开始二分查找，这样会产生多次无效查询，因此优化的方式就是更改分割的比例，采用三分，四分，分割位置：mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key)mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key) <br>    插值查找是根据要查找的关键字的key与查找表中最大最小记录的关键字比较之后的查找算法。 <br>    黄金分割比：用黄金分割比来作为mid值<br>10.二叉树、B+树、AVL树、红黑树、哈夫曼树。<br>二叉树：<br>二叉树的数据结构就不多说了，这里列举一些常见题目 <br>1）求解二叉树的节点 <br>    递归求解： <br>        a) 树为空，节点数为0 <br>        b) 二叉树节点个数 &#x3D; 左子树节点个数 + 右子树节点个数 + 1 <br>2）求二叉树的深度 <br>    递归解法： <br>        a）如果二叉树为空，二叉树的深度为0 <br>        b）如果二叉树不为空，二叉树的深度 &#x3D; max(左子树深度， 右子树深度) + 1 1. 先根遍历，中序遍历，后序遍历 <br>    依然递归求解 <br>4）广度优先 <br>    借助队列。 <br>5）将二叉查找树变为有序的双向链表 <br>    要求不能创建新节点，只调整指针。 <br>    递归解法： <br>        a）如果二叉树查找树为空，对应双向链表的第一个节点和最后一个节点是NULL <br>        b）如果二叉查找树不为空： <br>        设置参数flag，代表父节点与子节点的关系。如果修正的是左子树与父节点的关系，则递归返回的是序列最后的节点。 <br>6)求二叉树第K层的节点个数 <br>    递归解法： <br>        a）如果二叉树为空或者k&lt;1返回0 <br>        b）如果二叉树不为空并且k&#x3D;&#x3D;1，返回1 <br>        c）如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 <br>7)求二叉树中叶子节点的个数 <br>    递归解法： <br>        a）如果二叉树为空，返回0 <br>        b）如果二叉树不为空且左右子树为空，返回1 <br>        c）如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 <br>8)判断二叉树是不是平衡二叉树(AVL树) <br>    递归解法： <br>        a）如果二叉树为空，返回真 <br>        b）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假 <br>9)由前序遍历序列和中序遍历序列重建二叉树 <br>    二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。 <br>    递归解法： <br>        a）如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL; <br>        b）创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树 <br>10)判断是不是完全二叉树<br>11.二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。<br>12.图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。<br>13.KMP算法。<br>14.排列组合问题。<br>15.动态规划、贪心算法、分治算法。（一般不会问到）<br>16.大数据处理：类似10亿条数据找出最大的1000个数………等等<br>17.算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看数据库<br>1.事务四大特性（ACID）原子性、一致性、隔离性、持久性*<br>原子性：是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性: 是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。<br>隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。<br>事务之间的相互影响：脏读，不可重复读，幻读，丢失更新。<br>脏读 意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的<br>不可重复读 意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。<br>  幻读 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.<br>丢失更新 两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。<br>持久性：<br>意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><p>7.索引有B+索引和hash索引，各自的区别<br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。<br>在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。<br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。<br>8.B+索引数据结构，和B树的区别<br>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。<br>根节点至少有两个子节点<br>每个节点有M-1个key，并且以升序排列<br>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>其它节点至少有M&#x2F;2个子节点<br>B+树是对B树的一种变形树，它与B树的差异在于：<br>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</p><p>12.关系型数据库和非关系型数据库区别<br>1.关系型数据库通过外键关联来建立表与表之间的关系，<br>2.非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定</p><p>15.使用explain优化sql和索引<br>表的读取顺序<br>数据读取操作的操作类型<br>哪些索引可以使用<br>哪些索引被实际使用<br>表之间的引用<br>每张表有多少行被优化器查询<br>说了这么多使用explain的好处,那么实际上到底该怎么玩? 答案： explain + 待执行的sql<br>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化<br>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL<br>all: full table scan ;MySQL将遍历全表以找到匹配的行；<br>index ： index scan; index 和 all的区别在于index类型只遍历索引；<br>range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，&lt; ,&gt;等查询；<br>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；<br>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；<br>const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。<br>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句<br>key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：MySQL认为必须检查的用来返回请求数据的行数<br>Extra：关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。<br>16.long_query怎么解决*<br>慢查询日志：默认情况下，MySQL数据库是不开启慢查询日志的，long_query_time的默认值为10（即10秒，通常设置为1秒），即运行10秒以上的语句是慢查询语句。<br>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。<br>slow_query_log 慢查询开启状态。<br>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。<br>long_query_time 查询超过多少秒才记录。<br>17.内连接、外连接、交叉连接、笛卡儿积等<br>内连接(INNER JOIN)：  <br>    分为三种：等值连接、自然连接、不等连接<br>  <br>外连接(OUTER JOIN)：  <br>    分为三种：  <br>    左外连接(LEFT OUTER JOIN或LEFT JOIN)  <br>    右外连接(RIGHT OUTER JOIN或RIGHT JOIN)  <br>    全外连接(FULL OUTER JOIN或FULL JOIN)  交叉连接(CROSS JOIN)：  <br>    没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积<br>笛卡尔积是两个表每一个字段相互匹配，去掉where 或者inner join的等值 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。内连接: 只连接匹配的行。<br>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。<br>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。<br>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。<br>交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>20.mysql并发情况下怎么解决（通过事务、隔离级别、锁）<br>MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。。。。。<br>需求分析：互联网单位 每天大量数据读取，写入，并发性高。<br>现有解决方式：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。<br>集群方案：解决DB宕机带来的单点DB不能访问问题。<br>读写分离策略：极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。<br>21.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）<br>Undo Log<br>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了UndoLog来实现多版本并发控制(简称：MVCC)。<br>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>之所以能同时保证原子性和持久化，是因为以下特点：<br>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。<br>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。<br>Redo Log<br>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。<br>22.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序<br>Join where limit group by having12.Spring如何解决循环依赖？<br>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。<br>Spring的单例对象的初始化主要分为三步：<br>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>（3）initializeBean：调用spring xml中的init 方法。<br>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。<br>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。<br>13.Spring 如何保证 Controller 并发的安全？*<br>在Controller中使用ThreadLocal变量<br>在spring配置文件Controller中声明 scope&#x3D;”prototype”，每次都创建新的controller<br>在控制器中不使用实例变量7.Netty的高性能表现在哪些方面*<br>异步非阻塞通信<br> Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都 是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。另外，由于Netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。<br>零拷贝<br>  1) Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>       2) Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>       3) Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>内存池<br>   随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty提供了基于内存池的缓冲区重用机制（PooledByteBuf）。<br>高效的Reactor线程模型1. Reactor单线程模型；<br>       2) Reactor多线程模型；<br>       3) 主从Reactor多线程模型<br>无锁化的串行设计理念<br> 在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。<br>       为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。<br>       Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程 操作导致的锁的竞争，从性能角度看是最优的。<br>高效的并发编程<br>Netty的高效并发编程主要体现在如下几点：<br>       1) volatile的大量、正确使用;<br>       2) CAS和原子类的广泛使用；<br>       3) 线程安全容器的使用；<br>       4) 通过读写锁提升并发性能。<br>高性能的序列化框架<br>影响序列化性能的关键因素总结如下：<br>       1) 序列化后的码流大小（网络带宽的占用）；<br>       2) 序列化&amp;反序列化的性能（CPU资源占用）；<br>       3) 是否支持跨语言（异构系统的对接和开发语言切换）。<br>Netty默认提供了对Google Protobuf的支持，通过扩展Netty的编解码接口，用户可以实现其它的高性能序列化框架，例如Thrift的压缩二进制编解码框架。<br>灵活的TCP参数配置能力<br> 合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和SO_SNDBUF。如果设置不当，对性能的影响是非常大的。下面总结下对性能影响比较大的几个配置项：<br>       1) SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；<br>       2) SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；<br>       3) 软中断：如果Linux内核版本支持RPS（2.6.35以上版本），开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个 hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。<br>Netty在启动辅助类中可以灵活的配置TCP参数，满足不同的用户场景。<br>缓存<br>4.Redis的并发竞争问题如何解决<br>1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。  <br>2.服务器角度，利用setnx实现锁。<br>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。<br>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。<br>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p><p>3.Netty是如何使用线程池的，为什么这么使用*<br>EventExecutorGroup 自己实现了Future和submit<br>AbstractEventExecutorGroup，最上层实现的还是Executor接口<br>只不过通过 配置数量，配置线程模型</p><p>3.HTTP协议<br>http：+地址+端口+url<br>基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），B&#x2F;C架构<br>HTTP request请求：<br>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>GET说明请求类型为GET,[&#x2F;562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息<br>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<br>第三部分：空行，请求头部后面的空行是必须的<br>即使第四部分的请求数据为空，也必须有空行。<br>第四部分：请求数据也叫主体，可以添加任意的其他数据。<br>这个例子的请求数据为空。<br>HTTP之响应消息Response<br>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文<br>4.TCP协议：面向连接的、可靠的、基于字节流的传输层通信协议<br>IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。<br>简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包<br>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。5.一致性Hash算法*<br>一致性hash作为一个负载均衡算法，可以用在分布式缓存、数据库的分库分表等场景中，还可以应用在负载均衡器中作为作为负载均衡算法。在有多台服务器时，对于某个请求资源通过hash算法，映射到某一个台服务器，当增加或减少一台服务器时，可能会改变这些资源对应的hash值，这样可能导致一部分缓存或数据失效了。一致性hash就是尽可能在将同一个资源请求路由到同一台服务器中。<br>一致性哈希采用的做法如下：引入一个环的概念，如上面的第一个图。先将机器映射到这个环上，再将数据也通过相同的哈希函数映射到这个环上，数据存储在它顺时针走向的那台机器上。以环为中介，实现了数据与机器数目之间的解耦。这样，当机器的数目变化时，只会影响到增加或删除的那台机器所在的环的邻接机器的数据存储，而其他机器上的数据不受影响。</p><p>10.HTTP连接池实现原理<br>1、降低延迟：如果不采用连接池，每次连接发起Http请求的时候都会重新建立TCP连接(经历3次握手)，用完就会关闭连接(4次挥手)，如果采用连接池则减少了这部分时间损耗，别小看这几次握手，本人经过测试发现，基本上3倍的时间延迟<br>2、支持更大的并发：如果不采用连接池，每次连接都会打开一个端口，在大并发的情况下系统的端口资源很快就会被用完，导致无法建立新的连接<br>PoolingHttpClientConnectionManager<br>配置请求超时设置—RequestConfig<br>CloseableHttpClient 获取httpClient对象，post，get封装<br>12.数据库的实现原理分布式<br>1.什么是CAP定理<br>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本），换句话就是说，任何时刻，所用的应用程序都能访问得到相同的数据。<br>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性），换句话就是说，任何时候，任何应用程序都可以读写数据。<br>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，换句话说，系统可以跨网络分区线性的伸缩和扩展。<br>2.CAP 理论和 BASE 理论<br>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。<br>基本可用（Basically Available）<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。<br>软状态（ Soft State）<br>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。<br>最终一致性（ Eventual Consistency）<br>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。<br>3.CAP 理论1. CAP理论<br>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。<br>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。<br>1.1 一致性（Consistency）<br>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。<br>1.2 可用性（Availability）<br>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。<br>1.3 分区容错性（Partition tolerance）<br>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。<br>4.CAP 理论和最终一致性<br>一言以蔽之：过程松，结果紧，最终结果必须保持一致性<br>最终一致性是弱一致性的一种特例。假如A首先write了一个值到存储系统，存储系统保证如果在A,B,C后续读取之前没有其它写操作更新同样的值的话，最终所有的读取操作都会读取到最A写入的最新值。此种情况下，如果没有失败发生的话，“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制技术中replica的个数（这个可以理解为master&#x2F;salve模式中，salve的个数），最终一致性方面最出名的系统可以说是DNS系统，当更新一个域名的IP以后，根据配置策略以及缓存控制策略的不同，最终所有的客户都会看到最新的值<br>5.最终一致性实现方式<br>6.一致性 Hash<br>7.分布式事务，两阶段提交。<br>两阶段提交涉及到多个节点的网络通信,通信时间如果过长,事务的相对时间也就会过长,那么锁定资源的时间也就长了.在高并发的服务中,就会存在严重的性能瓶颈</p><p>9.如何实现分布式Session*<br>2. 基于数据库的Session共享<br>3. 基于NFS共享文件系统<br>4. 基于memcached 的session，如何保证 memcached 本身的高可用性？<br>5. 基于resin&#x2F;tomcat web容器本身的session复制机制<br>6. 基于TT&#x2F;Redis 或 jbosscache 进行 session 共享。<br>7. 基于cookie 进行session共享<br>10.如何保证消息的一致性*11.负载均衡<br>负载均衡是高可用网络基础架构的的一个关键组成部分，有了负载均衡，我们通常可以将我们的应用服务器部署多台，然后通过负载均衡将用户的请求分发到不同的服务器用来提高网站、应用、数据库或其他服务的性能以及可靠性<br>12.正向代理（客户端代理）和反向代理（服务器端代理）*<br>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>（1）访问原来无法访问的资源，如google<br>    （2）可以做缓存，加速访问资源<br>　　（3）对客户端访问授权，上网进行认证<br>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息<br>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击<br>（2）负载均衡，通过反向代理服务器来优化网站的负载<br>nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。<br>13.CDN实现原理<br>（1）CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br>（2）大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。<br>CDN即内容分发网络，加速的意思，那么网站CND服务是网站加速服务。<br>CDN加速将网站的内容缓存在网络边缘（离用户接入网络最近的地方），然后在用户访问网站内容的时候，通过调度系统将用户的请求路由或者引导到离用户接入网络最近或者访问效果的缓存服务器上，有该缓存服务器为用户提供内容服务；相对于直接访问源站，这种方式缩短了用户和内容之间的网络距离，从而达到加速的效果<br>14.怎么提升系统的QPS和吞吐量*<br>QPS（TPS）：每秒钟request&#x2F;事务 数量<br>并发数：系统同时处理的request&#x2F;事务数<br>响应时间：一般取平均响应时间<br>简单而言通过增加集群来提升qps和吞吐量<br>实际上要比这个要复杂<br>首先我们需要知道系统的瓶颈<br>我们所知道的系统拓扑架构<br>对于rest接口而言<br>系统设施依次是：<br>dns<br>　　nginx<br>　　　　tomcat<br>　　　　　　db&#x2F;soa<br>首先我们可以通过增加集群来增加qps和吞吐量<br>其次考虑到负载均衡的问题，我们可以通过其他设施来保证集群节点的负载均衡，进一步提高系统qps<br>于是就有nginx集群+负载均衡<br>tomcat集群+负载均衡<br>到db&#x2F;soa这一层的时候，同样也可以通过增加集群+负载均衡的方式来解决<br>我们还可以在每一层增加缓存来应对热点数据<br>然而另外一个方面，可以系统拆分，服务拆分，分别针对瓶颈的系统单独增加集群和负载均衡来解决<br>同样db也可以分库分表，<br>因为单表超过1000万条数据时就很慢了，所以这个时候就需要库拆分，于是就有垂直拆分，水平拆分。　　　<br>异步化，可以不同调用的异步化，使用mq，比如发送短信，发送邮件等<br> <br>综上所述：<br>集群+负载均衡<br>增加缓存<br>系统拆分<br>分库分表<br>垂直拆分+水平拆分<br>异步化+MQ</p><p>16.描述一个服务从发布到被消费的详细过程*<br>创建接口服务<br>配置文件配置服务注册中心，配置接口服务<br>启动后，服务提供者启动时，向注册中心注册自己提供的服务，服务消费者在启动时，向注册中心订阅自己所需的服务<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br>17.分布式系统怎么做服务治理服务自动注册<br>客户端自动发现<br>变更下发<br>18.接口的幂等性的概念<br>在数学里，幂等有两种主要的定义：<br>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 即 s <em>s &#x3D; s<br>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) &#x3D; f(x)。<br>HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。如通过PUT接口将数据的Status置为1，无论是第一次执行还是多次执行，获取到的结果应该是相同的，即执行完成之后Status &#x3D;1。<br>orderStatus由0-&gt;1 是需要幂等性的<br>19.消息中间件如何解决消息丢失问题</em><br>消息持久化<br>ACK确认机制<br>设置集群镜像模式<br>1）单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。<br>2）普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。<br>3）镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案<br>消息补偿机制：息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。<br>20.Dubbo的服务请求失败怎么处理<br>因此，将应用拆分，并抽取出核心服务来解决上述问题，还要考虑负载均衡、服务监控、高可用性、服务隔离与降级、路由策略、完善的容错机制、序列化方案的选择、通信框架的选择、开发人员对底层细节无感知、服务升级兼容性等问题。Dubbo满足了以上所有需求。<br>21.重连机制会不会造成错误<br>dubbo在调用服务不成功时，默认会重试2次。<br>Dubbo的路由机制，会把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机制也能一定程度的保证服务的质量。<br>但是如果不合理的配置重试次数，当失败时会进行重试多次，这样在某个时间点出现性能问题，调用方再连续重复调用。<br>系统请求变为正常值的retries倍，系统压力会大增，容易引起服务雪崩，需要根据业务情况规划好如何进行异常处理，何时进行重试。<br>22.对分布式事务的理解<br>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。<br>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交，包括上面提到的消息事务+最终一致性、TCC模式，而完全控制就是完全实现两阶段提交。部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。<br>下单—涉及扣库存和更新订单状态。<br>23.如何实现负载均衡，有哪些算法可以实现？<br>既然要解决后端系统的承载能力：nginx的配置<br>均衡算法主要解决将请求如何发送给后端服务<br>随机（random）、轮训（round-robin）、一致哈希（consistent-hash）和主备（master-slave）。<br>24.Zookeeper的用途，选举的原理是什么？<br>分布式系统基本上都是主从结构，所以需要zookeeper进行协调服务，他做很多事情的，比如命名服务，配置管理，集群管理，分布式协调通知等等<br>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。1.服务器初始化时Leader选举<br>zookeeper由于其自身的性质，一般建议选取奇数个节点进行搭建分布式服务器集群。以3个节点组成的服务器集群为例，说明服务器初始化时的选举过程。启动第一台安装zookeeper的节点时，无法单独进行选举，启动第二台时，两节点之间进行通信，开始选举Leader。1）每个Server投出一票。他们两都选自己为Leader，投票的内容为（SID，ZXID）。SID即Server的id，安装zookeeper时配置文件中所配置的myid；ZXID，事务id，为节点的更新程度，ZXID越大，代表Server对Znode的操作越新。由于服务器初始化，每个Sever上的Znode为0，所以Server1投的票为（1,0），Server2为（2,0）。两Server将各自投票发给集群中其他机器。2）每个Server接收来自其他Server的投票。集群中的每个Server先判断投票有效性，如检查是不是本轮的投票，是不是来Looking状态的服务器投的票。3）对投票结果进行处理。先了解下处理规则</p><ul><li>首先对比ZXID。ZXID大的服务器优先作为Leader</li><li>若ZXID相同，比如初始化的时候，每个Server的ZXID都为0，就会比较myid，myid大的选出来做Leader。对于Server而言，他接受到的投票为（2,0），因为自身的票为（1,0），所以此时它会选举Server2为Leader，将自己的更新为（2,0）。而Server2收到的投票为Server1的（1,0）由于比他自己小，Server2的投票不变。Server1和Server2再次将票投出，投出的票都为（2,0）。4） 统计投票。每次投票之后，服务器都会统计投票信息，如果判定某个Server有过半的票数投它，那么该Server将会作为Leader。对于Server1和Server2而言,统计出已经有两台机器接收了（2,0）的投票信息，此时认为选出了Leader。5）改变服务器状态。当确定了Leader之后，每个Server更新自己的状态，Leader将状态更新为Leading，Follower将状态更新为Following。2.服务器运行期间的Leader选举<br>zookeeper运行期间，如果有新的Server加入，或者非Leader的Server宕机，那么Leader将会同步数据到新Server或者寻找其他备用Server替代宕机的Server。若Leader宕机，此时集群暂停对外服务，开始在内部选举新的Leader。假设当前集群中有Server1、Server2、Server3三台服务器，Server2为当前集群的Leader，由于意外情况，Server2宕机了，便开始进入选举状态。过程如下<br>1） 变更状态。其他的非Observer服务器将自己的状态改变为Looking，开始进入Leader选举。<br>2） 每个Server发出一个投票（myid，ZXID），由于此集群已经运行过，所以每个Server上的ZXID可能不同。假设Server1的ZXID为145，Server3的为122，第一轮投票中，Server1和Server3都投自己，票分别为（1，145）、（3,122）,将自己的票发送给集群中所有机器。<br>3） 每个Server接收接收来自其他Server的投票，降下来的步骤与启动时步骤相同。25.数据的垂直拆分水平拆分。<br>垂直拆分，对于表来说，可以按业务模型进行拆分<br>水平拆分，对于表来说，是分多个票取模存放到不同数据库<br>26.zookeeper原理和适用场景*<br>Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储， Zookeeper 作用主要是用来维护和监控存储的数据的状态变化，通过监控这些数据状态的变化，从而达到基于数据的集群管理<br>简单的说，zookeeper&#x3D;文件系统+通知机制。<br>ZooKeeper以Fast Paxos（帕克索斯）算法为基础，让集群中的每个zk实例数据保持一致。一般部署集群，机器数设置为奇数个，更容易满足&gt;N&#x2F;2的投票条件。<br>Zookeeper应用场景<br>统一命名服务<br>       分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别不同服务。类似于域名与ip之间对应关系，域名容易记住。通过名称来获取资源或服务的地址，提供者等信息按照层次结构组织服务&#x2F;应用名称可将服务名称以及地址信息写到Zookeeper上，客户端通过Zookeeper获取可用服务列表类。<br>配置管理<br>       分布式环境下，配置文件管理和同步是一个常见问题。一个集群中，所有节点的配置信息是一致的，比如Hadoop。对配置文件修改后，希望能够快速同步到各个节点上配置管理可交由Zookeeper实现。可将配置信息写入Zookeeper的一个znode上。各个节点监听这个znode。一旦znode中的数据被修改，zookeeper将通知各个节点。<br>集群管理<br>       分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态作出一些调整。Zookeeper可将节点信息写入Zookeeper的一个znode上。监听这个znode可获取它的实时状态变化。典型应用比如Hbase中Master状态监控与选举。<br>分布式通知&#x2F;协调<br>       分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。例如，NameNode须知道各DataNode的状态，JobTracker须知道各TaskTracker的状态。心跳检测机制和信息推送也是可通过Zookeeper实现。<br>分布式锁<br>       Zookeeper是强一致的。多个客户端同时在Zookeeper上创建相同znode，只有一个创建成功。Zookeeper实现锁的独占性。多个客户端同时在Zookeeper上创建相同znode ，创建成功的那个客户端得到锁，其他客户端等待。Zookeeper 控制锁的时序。各个客户端在某个znode下创建临时znode （类型为CreateMode. EPHEMERAL _SEQUENTIAL），这样，该znode可掌握全局访问时序。<br>分布式队列<br>       两种队列。当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。（可通过分布式锁实现）<br>       同步队列。一个job由多个task组成，只有所有任务完成后，job才运行完成。可为job创建一个&#x2F;job目录，然后在该目录下，为每个完成的task创建一个临时znode，一旦临时节点数目达到task总数，则job运行完成。<br>27.zookeeper watch机制<br>监视是一种简单的机制，使客户端收到关于ZooKeeper集合中的更改的通知。客户端可以在读取特定znode时设置Watches。Watches会向注册的客户端发送任何znode（客户端注册表）更改的通知。<br>Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。<br>28.redis&#x2F;zk节点宕机如何处理*<br>解决方法是连接从服务器，做save操作。将会在从服务器的data目录保存一份从服务器最新的dump.rdb文件。将这份dump.rdb文件拷贝到主服务器的data目录下。再重启主服务器。<br>29.分布式集群下如何做到唯一序列号*<br><a target="_blank" rel="noopener" href="http://stor.51cto.com/art/201711/558600.htm">http://stor.51cto.com/art/201711/558600.htm</a><br>1、利用数据库递增，全数据库唯一。<br>优点：明显，可控。<br>缺点：单库单表，数据库压力大。<br>2、UUID， 生成的是length&#x3D;32的16进制格式的字符串，如果回退为byte数组共16个byte元素，即UUID是一个128bit长的数字，一般用16进制表示。<br>优点：对数据库压力减轻了。<br>缺点：但是排序怎么办？<br>此外还有UUID的变种，增加一个时间拼接，但是会造成id非常长。<br>3、twitter在把存储系统从MySQL迁移到Cassandra的过程中由于Cassandra没有顺序ID生成机制，于是自己开发了一套全局唯一ID生成服务：Snowflake。<br>41位的时间序列（精确到毫秒，41位的长度可以使用69年）<br>10位的机器标识（10位的长度最多支持部署1024个节点）<br>12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 最高位是符号位，始终为0。<br>优点：高性能，低延迟；独立的应用；按时间有序。<br>缺点：需要独立的开发和部署。<br>4、Redis生成ID<br>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作INCR和INCRBY来实现。<br>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。<br>30.用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗*<br>可靠消费<br>Redis：没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理<br>RabbitMQ：具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费<br>可靠发布<br>Reids：不提供，需自行实现<br>RabbitMQ：具有发布确认功能，保证消息被发布到服务器<br>高可用<br>Redis：采用主从模式，读写分离，但是故障转移还没有非常完善的官方解决方案<br>RabbitMQ：集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作<br>持久化<br>Redis：将整个Redis实例持久化到磁盘<br>RabbitMQ：队列，消息，都可以选择是否持久化<br>消费者负载均衡<br>Redis：不提供，需自行实现<br>RabbitMQ：根据消费者情况，进行消息的均衡分发<br>队列监控<br>Redis：不提供，需自行实现<br>RabbitMQ：后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）<br>流量控制<br>Redis：不提供，需自行实现<br>RabbitMQ：服务器过载的情况，对生产者速率会进行限制，保证服务可靠性<br>kafka，<br>activemq，<br>RocketMQ<br>31.MQ系统的数据如何保证不丢失<br>32.列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询<br>１、中间变量　＝ user_id%（库数量*每个库的表数量）;<br>２、库序号　＝　取整（中间变量／每个库的表数量）;<br>３、表序号　＝　中间变量％每个库的表数量;<br>Join连表查询，或者多sql查询系统架构<br>1.如何搭建一个高可用系统<br>容灾<br>集群<br>主备<br>熔断<br>限流<br>监控<br>降级<br>日志<br>分库分表<br>读写分离<br>Nginx反向代理<br>CDN加速<br>SSD硬盘持久化<br>自动备份<br>2.哪些设计模式可以增加系统的可扩展性<br>工厂模式<br>抽象工厂模式<br>观察者模式：很方便增加观察者，方便系统扩展<br>模板方法模式：很方便的实现不稳定的扩展点，完成功能的重用<br>适配器模式：可以很方便地对适配其他接口<br>代理模式：可以很方便在原来功能的基础上增加功能或者逻辑<br>责任链模式：可以很方便得增加拦截器&#x2F;过滤器实现对数据的处理，比如struts2的责任链<br>策略模式：通过新增策略从而改变原来的执行策略<br>3.介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。5.什么是高内聚低耦合，请举例子如何实现*<br>同一类功能放一块，如utils包，但是各个模块功能不依赖关联，这就是低耦合<br>接口、继承、多态也是低耦合的实现<br>6.什么情况用接口，什么情况用消息<br>接口的特点是同步调用，接口实时响应，阻塞等待<br>消息的特点是异步处理，非实时响应，消息发送后则返回，消息队列可以削峰<br>一般对实时性要求比较高的功能采用接口<br>对实时性要求不高的功能可以采用消息，削峰时可以采用消息<br>7.如果AB两个系统互相依赖，如何解除依赖*<br>A—&gt;B，同时B—&gt;A<br>解除这种双向依赖的话，需要在AB之外增加一个C，用C封装A依赖的B的那部分功能，让A改为依赖C，C依赖B<br>然后就是这样<br>A—&gt;C，C—-&gt;B，B—&gt;A<br>不过这样依然存在环路依赖<br>8.如何写一篇设计文档，目录是什么<br>基于此我认为主要会分为8个部分。分别为 项目背景，项目目标，需求分析，方案对比，概要设计，详细设计（存储模型设计，接口设计），开发以及上线计划，方案排期。<br>9.什么场景应该拆分系统，什么场景应该合并系统<br>拆分系统：<br>当系统通过集群的方式已经无法解决性能问题的时候，或者业务扩展到很大的时候，需要把拆分系统<br>按照业务的方式垂直拆分：将业务功能结合比较紧密的部分拆分成独立的系统，独立维护<br>按照性能瓶颈点拆分：将系统性能瓶颈点拆分出一个独立的系统，可以针对这个独立的系统集群部署，增加可伸缩性，提高系统整体的性能<br>合并系统：<br>或者系统间通过跨进程访问的性能损耗过高，可以将系统合并成一个系统，减少跨进程访问的消耗<br>10.系统和模块的区别，分别在什么场景下使用<br>系统和模块<br>系统是一个完整功能的系统，拥有独立的访问方式，和部署方式，拥有完整的生命周期，系统由模块组成<br>模块是系统的组成部分，不能单独工作，需要依附于系统才能发挥作用，通常是解决一定场景下的问题<br>系统用于系统性解决问题的方案<br>模块是针对单个问题方面的解决方案<br>11.实战能力<br>12.有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。<br>13.开发中有没有遇到什么技术问题？如何解决的<br>14.如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。<br>15.新浪微博是如何实现把微博推给订阅者<br>16.Google是如何在一秒内把搜索结果返回给用户的。<br>17.12306网站的订票系统如何实现，如何保证不会票不被超卖。<br>18.如何实现一个秒杀系统，保证只有几位用户能买到某件商品。<br>设计这个系统是一个考虑全面的问题，可以发散出很多问题，考察很多方面，不是仅仅回答通过redis的自减操作完成<br>比如简单的方案：<br>1，页面开启倒计时，要保证不能把下单接口暴露过早暴露出来，防止机器刷下单接口<br>2，前端限流，比如nginx对下单接口限流，命中限流则返回302到秒杀页<br>3，后端单独部署，独立域名和nginx，与线上正常运行的系统隔离开来，避免影响到线上环境<br>4，由于生成订单操作比较耗时，采用队列的方式来解耦下单成功和生成订单，针对进入后端的请求，采用redis自减，针对自减结果&gt;0的请求则认为下单成功，触发一个生成订单的消息，然后立即返回给用户结果<br>5，用户方面，针对秒杀成功有两种处理方式<br>　　a，用户端收到秒杀成功的结果，则开启提示页面，并进入倒计时，倒计时时间为订单生成的预估时间<br>　　b，秒杀成功后，给当前用户在redis中生成一个订单生成状态的标识，用户端开启提示页面，loading，并轮询后端订单生成状态，生成成功之后让前端跳转到订单页面<br>6，订单服务订阅下单系统发送的消息，并开始生成订单，生成订单成功之后更新redis中用户秒杀订单的状态为已生成订单</li></ul><p> <br>系统应该有页面和接口<br>页面用于展示用户界面，接口用于获取数据<br>界面：秒杀页面，秒杀成功页面，秒杀失败页面，命中限流页面（查看订单页面不算秒杀系统的功能）<br>接口：秒杀下单接口，秒杀成功获取订单生成状态接口TCP&#x2F;IP<br>1.OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议。*<br>OSI模型—应用层，表示层，回话层，传输层，网络层，数据链路层，物理层<br>1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 <br>2.数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 <br>3.网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 <br>4.传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 <br>5.会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） <br>6.表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 <br>7.应用层： 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。2.TCP与UDP的区别。*<br>TCP(Transmission Control Protocol)：传输控制协议<br>UDP(User Datagram Protocol)：用户数据报协议<br>TCP是面向连接的、可靠的、有序的、速度慢的协议；<br>UDP是无连接的、不可靠的、无序的、速度快的协议。<br>TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。<br>TCP无界有拥塞控制，UDP有界无拥塞控制。3.TCP报文结构。<br>1、端口号：用来标识同一台计算机的不同的应用进程。<br>1）源端口：源端口和IP地址的作用是标识报文的返回地址。<br>2）目的端口：端口指明接收方计算机上的应用程序接口。<br>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。<br>2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。<br>3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32&#x2F;8 &#x3D; 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。<br>4、保留：为将来定义新的用途保留，现在一般置0。<br>5、控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。<br>1）URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。<br>2）ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。<br>3）PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。<br>4）RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。<br>5）SYN：同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。<br>6）FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。<br>6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。<br>7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。<br>8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。<br>9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。<br>10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。<br>4.TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。<br>5.TCP拥塞控制。<br>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或者链路不会导致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制<br>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。<br>（1）在通信子网出现过多数据包的情况，使得网络的性能下降，甚至不能正常工作，这种现象就称为拥塞。<br>（2）网络拥塞的成因主要有三：1、处理器的速度太慢。2、线路容量的限制。3、节点输出包的能力小于输入包的能力。<br>（3）拥塞控制与流量控制是相关的，流量控制在数据链路层对一条通信路径上的流量进行控制，其的是保证发送者的发送速度不超过接收者的接收速度，它只涉及一全发送者和一个接收者，是局部控制。拥塞控制是对整个通信子网的流量进行控制，其目的是保证通信子网中的流量与其资源相匹配，使子网不会出现性能下降和恶化、甚至崩溃，是全局控制。<br>（4）拥塞控制的最终目标是：1、防止由于过载而使吞吐量下降，损失效率；2、合理分配网络资源；3、避免死锁；4、匹配传输速度。<br>（5）对拥塞控制，可用的方法有两类：开环控制和闭环控制。<br>1、开环控制的思想是通过良好的设计避免拥塞问题的出现，确保拥塞问题在开始时就不可能发生。开环控制方法包括何时接受新的通信何时丢弃包、丢弃哪些包。其特点是在作出决定时不考虑网络当前的状态。<br>2、闭环控制的思想是反馈控制。即通过将网络工作的动态信息反馈给网络中节点的有关进程，节点根据网络当前的动态信息，调整转发数据包的策略。闭环控制过程包括三部分： ①监视系统  检测网络发生或将要发生拥塞的时间和地点。②报告  将监视中检测到的信息传送到可以进行拥塞控制的节点。③决策  调整系统的操作行为，以解决问题。<br>（6）对应于开环控制的方法有：（基于拥塞预防）<br>1、预定缓冲区 2、合理分配缓冲区 3、通信量整形法（A、许可证算法，B、漏桶算法，C、令牌漏桶算法。）<br>对应于闭环控制的方法有：（基于拥塞抑制，即拥塞出现或即将出现时采取适当的措施进行控制，直到消除拥塞）<br>1、阻塞包法。 2、负载丢弃法<br>6.TCP滑动窗口与回退N针协议。<br>7.Http的报文结构。<br>（1）HTTP请求报文<br>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。（2）HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。<br>8.Http的状态码含义。<br>1xx: 信息<br>消息：	描述：<br>100 Continue	服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。<br>101 Switching Protocols	服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。<br>103 Checkpoint	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>2xx: 成功<br>消息：	描述：<br>200 OK	请求成功（这是对HTTP请求成功的标准应答。）<br>201 Created	请求被创建完成，同时新的资源被创建。<br>202 Accepted	供处理的请求已被接受，但是处理未完成。<br>203 Non-Authoritative Information	请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。<br>204 No Content	请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br>205 Reset Content	请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。<br>206 Partial Content	客户发送了一个带有Range头的GET请求，服务器完成了它。<br>3xx: 重定向<br>消息：	描述：<br>300 Multiple Choices	多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。<br>301 Moved Permanently	所请求的页面已经转移至新的 URL 。<br>302 Found	所请求的页面已经临时转移至新的 URL 。<br>303 See Other	所请求的页面可在别的 URL 下被找到。<br>304 Not Modified	未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br>305 Use Proxy	客户请求的文档应该通过Location头所指明的代理服务器提取。<br>306 Switch Proxy	目前已不再使用，但是代码依然被保留。<br>307 Temporary Redirect	被请求的页面已经临时移至新的 URL 。<br>308 Resume Incomplete	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>4xx: 客户端错误<br>消息：	描述：<br>400 Bad Request	因为语法错误，服务器未能理解请求。<br>401 Unauthorized	合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。<br>402 Payment Required	此代码尚无法使用。<br>403 Forbidden	合法请求，但对被请求页面的访问被禁止。<br>404 Not Found	服务器无法找到被请求的页面。<br>405 Method Not Allowed	请求中指定的方法不被允许。<br>406 Not Acceptable	服务器生成的响应无法被客户端所接受。<br>407 Proxy Authentication Required	用户必须首先使用代理服务器进行验证，这样请求才会被处理。<br>408 Request Timeout	请求超出了服务器的等待时间。<br>409 Conflict	由于冲突，请求无法被完成。<br>410 Gone	被请求的页面不可用。<br>411 Length Required	“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。<br>412 Precondition Failed	请求中的前提条件被服务器评估为失败。<br>413 Request Entity Too Large	由于所请求的实体太大，服务器不会接受请求。<br>414 Request-URI Too Long	由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。<br>415 Unsupported Media Type	由于媒介类型不被支持，服务器不会接受请求。<br>416 Requested Range Not Satisfiable	客户端请求部分文档，但是服务器不能提供被请求的部分。<br>417 Expectation Failed	服务器不能满足客户在请求中指定的请求头。<br>5xx: 服务器错误<br>消息：	描述：<br>500 Internal Server Error	请求未完成。服务器遇到不可预知的情况。<br>501 Not Implemented	请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。<br>502 Bad Gateway	请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。<br>503 Service Unavailable	服务器当前不可用（过载或者当机）。<br>504 Gateway Timeout	网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。<br>505 HTTP Version Not Supported	服务器不支持请求中指明的HTTP协议版本。<br>511 Network Authentication Required	用户需要提供身份验证来获取网络访问入口。9.Http?request的几种类型。*<br>1.  OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’<em>‘的请求来测试服务器的功能性。<br>2.  HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>3.  GET：向特定的资源发出请求。<br>4.  POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>5.  PUT：向指定资源位置上传其最新内容。<br>6.  DELETE：请求服务器删除Request-URI所标识的资源。<br>7.  TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>8.  CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>10.Http1.1和Http1.0的区别</em><br>长连接<br>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。<br>HTTP是基于TCP&#x2F;IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。<br>节约带宽<br>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。<br>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。<br>HOST域<br>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。<br>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。<br>11.Http怎么处理长连接。*<br>在HTTP1.0和HTTP1.1协议中都有对长连接的支持。其中HTTP1.0需要在request中增加Connection： keep-alive header才能够支持，而HTTP1.1默认支持。<br>http1.0请求与服务端的交互过程:<br>（1）客户端发出带有包含一个header：”Connection： keep-alive“的请求<br>（2）服务端接收到这个请求后,根据http1.0和”Connection： keep-alive“判断出这是一个长连接,就会在response的header中也增加”Connection： keep-alive“，同时不会关闭已建立的tcp连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>http1.1请求与服务端的交互过程:<br>（1）客户端发出http1.1的请求<br>（2）服务端收到http1.1后就认为这是一个长连接,会在返回的response设置Connection： keep-alive,同时不会关闭已建立的连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>基于http协议的长连接减少了请求,减少了建立连接的时间,但是每次交互都是由客户端发起的,客户端发送消息,服务端才能返回客户端消息。<br>12.Cookie与Session的作用于原理。<br>1.1 Cookie机制<br>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。<br>而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。<br>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。<br>1.2 Session机制<br>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。<br>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。<br>Java Web规范支持通过配置的方式禁用Cookie。下面举例说一下怎样通过配置禁止使用Cookie，可以使用重定向url。 <br>cookie数据保存在客户端，session数据保存在服务器端 <br>第一次请求服务器，生成session和sessionID，sessionID用cookie保存 <br>第二次请求服务器，携带seesionID，服务器从请求中取出sessionID<br>13.电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。<br>应用层：<br>连接：当我们输入一个url请求时，首先要建立socket连接，因为socket是通过ip和端口建立的，所有有一个DNS解析的过程，首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。现在已经拥有了目标ip和端口号，这样我们就可以打开socket连接了。<br>请求：连接成功建立后，开始向web服务器发送请求，这个请求一般是GET或POST命令（POST用于FORM参数的传递）。GET命令的格式为：　　GET 路径&#x2F;文件名 HTTP&#x2F;1.0<br>文件名指出所访问的文件，HTTP&#x2F;1.0指出Web浏览器使用的HTTP版本。现在可以发送GET命令：<br>GET &#x2F;mytest&#x2F;index.html HTTP&#x2F;1.0，<br>应用层：<br>1. DNS（53）：<br>我们输入的是一个URL需要转化成IP地址。首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。1. HTTP（80）<br>HTTP协议的主要职责是生成针对目标web服务器的http请求报文（请求行、请求头部）<br>传输层<br>2. TCP<br>将http请求报文分割成报文段，按序号分为多个报文段。（三次握手）<br>网络层<br>3. IP<br>搜索目标的地址，一边中转一边传送。（路由）<br>4. ARP<br>因为最终都要在数据链路层上进行传输，而数据链路层并不认识IP地址，所以ARP的职责就是把IP地址转换成数据链路层认识的MAC地址。<br>通过数据链路层到达目标机器之后<br>网络层<br>5. RARP<br>这其实是ARP的逆过程，将MAC地址转换成Ip地址<br>传输层<br>6. TCP<br>将接收到的报文段按序号进行重组。<br>应用层<br>7. HTTP<br>14.Ping的整个过程。ICMP报文是什么。<br>ICMP（网际控制报文协议）：用来测试网络层是不是有故障，若有故障，该协议还能报告故障。Ping命令来使用这个协议<br>15.C&#x2F;S模式下使用socket通信，几个关键函数。*<br>client ： socket（ip，端口）<br>socket.close();<br>server：serversocket（端口）<br>socket &#x3D; server.accept()<br>16.IP地址分类。<br>IP地址分类（A类 B类 C类 D类 E类）<br>     IP地址由四段组成，每个字段是一个字节，8位，最大值是255，,<br>     IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。<br>  IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。<br>     IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。    全0和全1的都保留不用。<br>     A类：（1.0.0.0-126.0.0.0）（默认子网掩码：255.0.0.0或 0xFF000000）<br>     第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1<del>126之间。<br>     一般用于大型网络。<br>     B类：（128.1.0.0-191.255.0.0）（默认子网掩码：255.255.0.0或0xFFFF0000）<br>     前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128</del>191之间。<br>     一般用于中等规模网络。<br>     C类：（192.0.1.0-223.255.255.0）（子网掩码：255.255.255.0或 0xFFFFFF00）<br>     前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192<del>223之间。<br>     一般用于小型网络。<br>    D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224</del>239之间。一般用于多路广播用户[1]  。<br>    E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。<br>  回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。 <br>       一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP&#x2F;IP是否正常。<br>17.路由器与交换机区别。<br>一、工作所在的OSI层次不一样（根本区别，导致接下来的区别） <br>交换机工作在 OSI模型的数据链路层，所以工作原理比较简单； <br>路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。<br>二、数据转发所依据的对象也不一样。 <br>交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。 <br>路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。<br>三、是否可以分割广播域 <br>由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵； <br>连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。<br>18.网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。<br>19.推荐书籍：《TCP&#x2F;IP协议族》1．JDK,JRE,JVM(掌握)<br>(1)JVM<br>保证Java语言跨平台。针对不同的操心系统提供不同的JVM。<br>问题：java语言是跨平台的吗?JVM是跨平台的吗?<br>(2)JRE<br>java程序的运行环境。包括JVM和核心类库<br>(3)JDK<br>java开发环境。包括JRE和开发工具(javac,java)<br>(4)一个Java程序的开发流程<br>A:编写Java源程序<br>B:通过javac命令编译java程序，生成字节码文件<br>C:通过java命令运行字节码文件<br>2．主从数据库切换<br>一般使用多个dataSource，然后创建多个SessionFactory，入侵明显，修改多，session处理比较麻烦。<br>合适的方案使用AbstractRoutingDataSource实现类通过AOP或者手动处理实现动态使用我们的数据源，入侵低。determineTargetDataSource –<br>determineCurrentLookupKey<br>Why：如果主库故障，可以切换从库<br>Why：针对与mysql，怎么保证主从同步，怎么通知代码切换1. Bean获取它所在的Spring容器，可以让该Bean实现ApplicationContextAware接口，Bean获取它所在的Spring容器，可以通过这个上下文环境对象得到Spring容器中的Bean。<br>Why：针对于非web项目的spring2. ehcache:<br>String：字符串常量 每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉，<br>　　　StringBuffer：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>　　　StringBuilder：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>String 字符串常量 线程安全 操作少量数据<br>StringBuffer 字符串变量 线程安全 操作大量数据 速度慢 多线程适合用<br>StringBuilder 字符串变量 线程不安全 操作大量数据 速度快 单线程适合用<br>String str &#x3D; new String(“xyz”);创建了几个对象。<br>如果String常量池中，已经创建了”xyz”,则不会继续创建，此时只创建了一个对象new String(“xyz”);<br>如果String常量池中没有创建”xyz”,则会创建两个对象，一个对象的值是”xyz”,一个对象是new String(“xyz”);<br>6．关系型数据库和非关系型数据库种类和关系<br>数据库<br>类型	特性	优点	缺点<br>关系型数据库<br>SQLite、Oracle、mysql	1、关系型数据库，是指采用了关系模型来组织<br>数据的数据库；<br>2、关系型数据库的最大特点就是事务的一致性；<br>3、简单来说，关系模型指的就是二维表格模型，<br>而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。	1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。	1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、高并发读写需求；<br>4、海量数据的高效率读写；<br>非关系型数据库<br>MongoDb、redis、HBase	1、使用键值对存储数据；<br>2、分布式；<br>3、一般不支持ACID特性；<br>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。	1、无需经过sql层的解析，读写性能很高；<br>2、基于键值对，数据没有耦合性，容易扩展；<br>3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。	1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理，附加功能bi和报表等支持也不好；4. Vector ,ArrayList 和LinkedList的区别？<br> 1、Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。<br> 2、Vector线程同步，ArrayList、LinkedList线程不同步。<br> 3、LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。<br> 4、ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省。8.注解<br>登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。9.反射<br>反射就是把java类中的各种成分映射成一个个的Java对象<br>可以获取类的相关信息，可以进行设置，可以代理<br>spring 的 ioc&#x2F;di 也是反射….<br>javaBean和jsp之间调用也是反射….<br>struts的 FormBean 和页面之间…也是通过反射调用….<br>JDBC 的 classForName()也是反射…..<br>hibernate的 find(Class clazz) 也是反射….<br>10.加载器11.ajax<br>运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换；2. statement<br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>3. 数据库基础查询<br>1、 加载JDBC驱动程序： <br>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机）， <br>这通过java.lang.Class类的静态方法forName(String className)实现。 <br>例如：<br>try{<br>&#x2F;&#x2F;加载MySql的驱动类<br>Class.forName(“com.mysql.jdbc.Driver”) ;<br>}catch(ClassNotFoundException e){<br>System.out.println(“找不到驱动程序类 ，加载驱动失败！”);<br>e.printStackTrace() ;<br>}<br>成功加载后，会将Driver类的实例注册到DriverManager类中。<br>2、 提供JDBC连接的URL * 连接URL定义了连接数据库时的协议、子协议、数据源标识。 </p><ul><li>书写形式：协议：子协议：数据源标识<br>协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。 <br>数据源标识：标记找到数据库来源的地址与连接端口。 <br>例如： <br>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;gbk;useUnicode&#x3D;true;（MySql的连接URL） <br>表示使用Unicode字符集。如果characterEncoding设置为 gb2312或GBK，本参数必须设置为true 。characterEncoding&#x3D;gbk：字符编码方式。<br>3、创建数据库的连接 </li><li>要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。 </li><li>使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。<br>例如： &#x2F;&#x2F;连接MySql数据库，用户名和密码都是root<br>String url &#x3D; “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test” ;<br>String username &#x3D; “root” ;<br>String password &#x3D; “root” ;<br>try{<br>Connection con &#x3D; DriverManager.getConnection(url , username , password ) ;<br>}catch(SQLException se){<br>System.out.println(“数据库连接失败！”);<br>se.printStackTrace() ;<br>}<br>4、 创建一个Statement <br>•要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型： <br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>具体的实现方式： <br>Statement stmt &#x3D; con.createStatement() ; PreparedStatement pstmt &#x3D; con.prepareStatement(sql) ; CallableStatement cstmt &#x3D; con.prepareCall(“{CALL demoSp(? , ?)}”) ; <br>5、执行SQL语句 <br>Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute <br>1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。 <br>2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等 <br>3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码： <br>ResultSet rs &#x3D; stmt.executeQuery(“SELECT * FROM …”) ; int rows &#x3D; stmt.executeUpdate(“INSERT INTO …”) ; boolean flag &#x3D; stmt.execute(String sql) ; <br>6、处理结果 <br>两种情况： <br>1、执行更新返回的是本次操作影响到的记录数。 <br>2、执行查询返回的结果是一个ResultSet对象。 <br>• ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些 行中数据的访问。 <br>• 使用结果集（ResultSet）对象的访问方法获取数据： <br>while(rs.next()){ <br>String name &#x3D; rs.getString(“name”) ; <br>String pass &#x3D; rs.getString(1) ; &#x2F;&#x2F; 此方法比较高效 <br>} <br>（列是从左到右编号的，并且从列1开始）<br>7、关闭JDBC对象 <br>操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反： <br>1、关闭记录集 <br>2、关闭声明 <br>3、关闭连接对象</li></ul><p>17.使用Spring框架的好处是什么？<br>  轻量：Spring 是轻量的，基本的版本大约2MB。<br>  控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>  容器：Spring 包含并管理应用中对象的生命周期和配置。<br>  MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br>  事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br>  异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。1. ~8等于多少？8&gt;&gt;&gt;2等于多少？<br>第一个答案是-9，第二个答案是2，无符号右移高位补0	。2. 子类能否重写父类的静态方法<br>不能，类对象，从属于对应的类。3. 什么是线程？<br>  线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。4. 线程和进程有什么区别？<br>  线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。5. 如何在Java中实现线程？<br>  两种方式：java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。6. Java 关键字volatile 与 synchronized 作用与区别？<br>1，volatile<br>    它所修饰的变量不保留拷贝，直接访问主内存中的。<br>2，synchronized<br>    当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。24.不同的线程生命周期？<br>  当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。<br>        1. 程优先级的理解是什么？<br>  每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。26.是死锁(Deadlock)？如何分析和避免死锁？<br>  死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。<br>  分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。<br>  避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。27.么是线程安全？Vector是一个线程安全类吗？ <br>所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。28.Java中如何停止一个线程？<br>  Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程29.什么是ThreadLocal?<br>  ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。<br>  每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。30.Sleep()、suspend()和wait()之间有什么区别？<br>  Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。<br>  注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。<br>  object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()&#x2F;notify()与sleep()&#x2F;interrupt()类似，只是前者需要获取对象锁。31.什么是线程饿死，什么是活锁？<br>  当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI中线程活锁可能发生在以下情形：<br>  1，当所有线程在程序中执行Object.wait(0)，参数为0的wait方法。程序将发生活锁直到在相应的对象上有线程调用Object.notify()或者Object.notifyAll()。<br>  2，当所有线程卡在无限循环中。32.什么是Java Timer类？如何创建一个有特定时间间隔的任务？<br>  java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br>  java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。<br>33.Java中的同步集合与并发集合有什么区别？<br>  同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。<br>  在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。<br>  Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。34.同步方法和同步块，哪个是更好的选择？<br>  同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。35.么是线程池？ 为什么要使用它？<br>  创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。<br>  为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。<br>  从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。36．java中invokeAndWait 和 invokeLater有什么区别？<br>  这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。1. 多线程中的忙循环是什么?<br>  忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存。<br>  在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。2. Array不可以用泛型？<br>是的，list的可以，推荐用list，List可以提供编译期的类型安全保证，而Array却不能。<br>int num&#x3D;Integer.valueOf(“12”);<br>int num2&#x3D;Integer.parseInt(“12”);<br>double num3&#x3D;Double.valueOf(“12.2”);<br>double num4&#x3D;Double.parseDouble(“12.2”);<br>&#x2F;&#x2F;其他的类似。通过基本数据类型的包装来的valueOf和parseXX来实现String转为XX<br>String a&#x3D;String.valueOf(“1234”);&#x2F;&#x2F;这里括号中几乎可以是任何类型<br>String b&#x3D;String.valueOf(true);<br>String c&#x3D;new Integer(12).toString();&#x2F;&#x2F;通过包装类的toString()也可以<br>String d&#x3D;new Double(2.3).toString();3. AJAX有哪些有点和缺点？<br>优点：<br>  1、最大的一点是页面无刷新，用户的体验非常好。<br>  2、使用异步方式与服务器通信，具有更加迅速的响应能力。<br>  3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。<br>   4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。<br>缺点：<br>   1、ajax不支持浏览器back按钮。<br>   2、安全问题 AJAX暴露了与服务器交互的细节。<br>   3、对搜索引擎的支持比较弱。<br>   4、破坏了程序的异常机制。<br>   5、不容易调试。40.集合解析<br>List 和 Set 区别<br>List,Set都是继承自Collection接口<br>List特点：元素有放入顺序，元素可重复<br>Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉<br>（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）<br>Set和List对比：<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。<br>ArrayList 与 Vector 区别<br>public ArrayList(int initialCapacity)&#x2F;&#x2F;构造一个具有指定初始容量的空列表。<br>public ArrayList()&#x2F;&#x2F;构造一个初始容量为10的空列表。<br>public ArrayList(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 的元素的列表<br>Vector有四个构造方法：<br>public Vector()&#x2F;&#x2F;使用指定的初始容量和等于零的容量增量构造一个空向量。<br>public Vector(int initialCapacity)&#x2F;&#x2F;构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。<br>public Vector(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 中的元素的向量<br>public Vector(int initialCapacity,int capacityIncrement)&#x2F;&#x2F;使用指定的初始容量和容量增量构造一个空的向量<br>ArrayList和Vector都是用数组实现的，主要有这么三个区别：<br>Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；<br>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。<br>Vector可以设置增长因子，而ArrayList不可以。<br>Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。<br>适用场景分析：<br>Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。<br>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。<br>HashSet 和 HashMap 区别<br>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象<br>HashMap 和 ConcurrentHashMap 的区别<br>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。41.线程解析</p><ol><li>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore<br>CountDownLatch用法<br>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。<br>CyclicBarrier用法<br>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。<br>Semaphore用法<br>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。下面对上面说的三个辅助类进行一个总结：<br>　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。<br>　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。<br>说说 CountDownLatch 与 CyclicBarrier 区别<br>CountDownLatch	CyclicBarrier<br>减计数方式	加计数方式<br>计算为0时释放所有等待的线程	计数达到指定值时释放所有等待线程<br>计数为0时，无法重置	计数达到指定值时，计数置为0重新开始<br>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响	调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞<br>不可重复利用	可重复利用java.util.concurrent.Exchanger应用范例与原理浅析<br>此类提供对外的操作是同步的；<br>用于成对出现的线程之间交换数据；<br>可以视作双向的同步队列；<br>可应用于基因算法、流水线设计等场景。<br>ThreadLocal 原理分析<br>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。<br>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。<br>讲讲线程池的实现原理<br>线程池的几种方式<br>newFixedThreadPool(int nThreads) <br>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程<br>newCachedThreadPool() <br>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制<br>newSingleThreadExecutor() <br>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行<br>newScheduledThreadPool(int corePoolSize) <br>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br>线程的生命周期<br>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态<br>(1)生命周期的五种状态<br>新建（new Thread） <br>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 <br>例如：Thread t1&#x3D;new Thread();<br>就绪（runnable） <br>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();<br>运行（running） <br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。<br>死亡（dead） <br>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。<br>自然终止：正常运行run()方法后终止<br>异常终止：调用stop()方法让一个线程终止运行<br>堵塞（blocked） <br>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。<br>正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）1. 锁机制<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。 <br>在Java里，线程安全一般体现在两个方面： <br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。 <br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>Volatile<br>在多线程并发编程中synchronized和Volatile都扮演着重要的角色，Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。悲观锁 乐观锁<br>乐观锁 悲观锁 <br>是一种思想。可以用在很多方面。<br>比如数据库方面。 <br>悲观锁就是for update（锁定查询的行） <br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）<br>JDK方面： <br>悲观锁就是sync <br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。 <br>乐观锁就认为，基本没人抢。<br>乐观锁（Optimistic Lock）： <br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。数据存储分析<br>mysql索引使用技巧及注意事项<br> INSERT 与 UPDATE 语句在拥有索引的表中执行会花费更多的时间，而SELECT 语句却会执行得更快。这是因为，在进行插入或更新时，数据库也需要插入或更新索引值。<br>索引的类型：<br>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值<br>INDEX(普通索引)：允许出现相同的索引内容<br>PROMARY KEY(主键索引)：不允许出现相同的值<br>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维<br>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一<br>(1)使用ALTER TABLE语句创建索性<br>ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）<br>(2)使用CREATE INDEX语句对表增加索引<br>CREATE INDEX index_name ON table_name(username(length));<br>&#x2F;&#x2F;create只能添加这两种索引;<br>CREATE INDEX index_name ON table_name (column_list)<br>CREATE UNIQUE INDEX index_name ON table_name (column_list)<br>(3)删除索引<br>删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下：<br>drop index index_name on table_name ;alter table table_name drop index index_name ;alter table table_name drop primary key ;<br>(4) 组合索引与前缀索引<br>create table USER_DEMO<br>(<br>ID int not null auto_increment comment ‘主键’,<br>LOGIN_NAME varchar(100) not null comment ‘登录名’,<br>PASSWORD varchar(100) not null comment ‘密码’,<br>CITY varchar(30) not null comment ‘城市’,<br>AGE int not null comment ‘年龄’,<br>SEX int not null comment ‘性别(0:女 1：男)’,<br>primary key (ID)<br>);<br>ALTER TABLE USER_DEMO ADD INDEX name_city_age (LOGIN_NAME(16),CITY,AGE);索引的使用及注意事项<br>Explain select * from user where id&#x3D;1;<br>    1.索引不会包含有NULL的列<br>       只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。<br>    2.使用短索引<br>       对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。<br>    3.索引列排序<br>       mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。<br>    4.like语句操作<br>      一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。<br>    5.不要在列上进行运算<br>    6.不使用NOT IN 、&lt;&gt;、！&#x3D;操作，但&lt;,&lt;&#x3D;，&#x3D;，&gt;,&gt;&#x3D;,BETWEEN,IN是可以用到索引的<br>    7.索引要建立在经常进行select操作的字段上。<br>       这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。<br>    8.索引要建立在值比较唯一的字段上。<br>    9.对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。<br>    10.在where和join中出现的列需要建立索引。<br>    11.where的查询条件里有不等号(where column !&#x3D; …),mysql将无法使用索引。<br>    12.如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…),mysql将无法使用索引。<br>    13.在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。<br>分表与分库使用场景以及设计方式<br>对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表！场景：分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master<br>服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。<br>因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!<br>MySQL有三种锁的级别：页级、表级、行级。<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br>存储引擎的 InnoDB 与 MyISAM<br>1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。<br>2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用<br>3）InnoDB支持外键，MyISAM不支持<br>4）从MySQL5.5.5以后，InnoDB是默认引擎<br>5）InnoDB不支持FULLTEXT类型的索引<br>6）InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表<br>7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引<br>8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表<br>9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’<br>索引数据结构设相关的计算机原理<br>上文说过，二叉树、红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-&#x2F;+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-&#x2F;+Tree作为索引的理论基础。<br>当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，你需增加order by，并且order by字段需要建立索引。<br>   如果使用子查询去优化LIMIT的话，则子查询必须是连续的，某种意义来讲，子查询不应该有where条件，where会过滤数据，使数据失去连续性。<br>   如果你查询的记录比较大，并且数据传输量比较大，比如包含了text类型的field，则可以通过建立子查询。<br>分布式系统唯一ID生成方案汇总<br>关系型数据库 MySQL<br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。<br>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>文档数据库 MongoDB<br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。<br>列族数据库 HBase<br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。<br>全文搜索引擎 ElasticSearch<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。<br>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。<br>MongoDB 特性	优势<br>事务支持	MongoDB 目前只支持单文档事务，需要复杂事务支持的场景暂时不适合<br>灵活的文档模型	JSON 格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代<br>高可用复制集	满足数据高可靠、服务高可用的需求，运维简单，故障自动切换<br>可扩展分片集群	海量数据存储，服务能力水平扩展<br>高性能	mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足各种场景需求<br>强大的索引支持	地理位置索引可用于构建 各种 O2O 应用、文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求<br>Gridfs	解决文件存储的需求<br>aggregation &amp; mapreduce	解决数据分析场景需求，用户可以自己写查询语句或脚本，将请求都分发到 MongoDB 上完成<br>从目前阿里云 MongoDB 云数据库上的用户看，MongoDB 的应用已经渗透到各个领域，比如游戏、物流、电商、内容管理、社交、物联网、视频直播等，以下是几个实际的应用案例。<br>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新<br>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。<br>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能<br>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析<br>视频直播，使用 MongoDB 存储用户信息、礼物信息等redis内部数据结构深入浅出<br>redis 是 key-value 存储系统，其中 key 类型一般为字符串，而 value 类型则为 redis 对象（redis object），可以绑定各种类型的数据，譬如 string、list 和set，redis.h 中定义了 struct redisObject，它是一个简单优秀的数据结构Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>Redis 如何实现持久化1. snapshotting(快照)<br>也是默认方式.(把数据做一个备份，将数据存储到文件)<br>快照是默认的持久化方式，这种方式是将内存中数据以快照的方式写到二进制文件中，默认的文件名称为dump.rdb.可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key键修改就自动做快照.<br> 2. Append-onlyfile(缩写aof)的方式        <br>aof方式:由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。aof比快照方式有更好的持久化性，是由于在使用aof时，redis会将每一个收到的写命令都通过write函数追加到文件中，当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。      <br>当然由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。可以通过配置文件告诉redis我们想要通过fsync函数强制os写入到磁盘的时机。<br>Redis 为什么是单线程的<br>要知道Redis的数据结构并不全是简单的Key-Value，还有列表，hash，map等等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，等等。这些操作还可以合成MULTI&#x2F;EXEC的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。这还带来一个恶果就是吞吐量虽然增大，但是响应延迟可能会增加。 <br>Redis在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用Lua脚本这样的功能。对于多线程来说这需要高得多的代价。44.使用传统的 Socket 开发挺简单的，我为什么要切换到 NIO 进行编程呢？<br>1.线程模型存在致命缺陷：一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>2.性能差：频繁的线程上下文切换导致 CPU 利用效率不高；<br>3.可靠性差：由于所有的 IO 操作都是同步的，所以业务线程只要进行 IO 操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br>4.采用非阻塞 IO（NIO）之后，同步阻塞 IO 的三个缺陷都将迎刃而解：<br>5.Nio 采用 Reactor 模式，一个 Reactor 线程聚合一个多路复用器 Selector，它可以同时注册、监听和轮询成百上千个 Channel，一个 IO 线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为 CPU 核数 + 1， N &lt; 进程可用的最大句柄数)；<br>6.由于 IO 线程总数有限，不会存在频繁的 IO 线程之间上下文切换和竞争，CPU 利用率高；<br>7.所有的 IO 操作都是异步的，即使业务线程直接进行 IO 操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。由于切换到 NIO 编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用 NIO 进行通信已经逐渐成为主流。# 什么是WebSockets？WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信信道。WebSocket是双向的 -使用WebSocket客户端或服务器可以发起消息发送。<br>WebSocket是全双工的 -客户端和服务器通信是相互独立的。<br>单个TCP连接 -初始连接使用HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信<br>Light -与http相比，WebSocket消息数据交换要轻得多。# 什么是CSRF攻击CSRF代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web应用程序上执行不需要的操作。CSRF攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。NOWCODER.COM<br>Java 面试题库<br>牛客网出品<br>NOWCODER.COM<br>Java 工程师校招面试题库导读<br>一、学习说明<br>本题库均来自海量真实校招面试题目大数据进行的整理，后续也会不断更新，可免费在线观<br>看，如需下载，也可在页面<br>载需要用牛币兑换，一次兑换可享受永久下载权限，因为后续会更新）<br>需要严肃说明的是：面试题库作为帮助同学准备面试的辅助资料，但是绝对不能作为备考唯<br>一途径，因为面试是一个考察真实水平的，不是背会了答案就可以的，需要你透彻理解的，<br>否则追问问题答不出来反而减分，毕竟技术面试中面试官最痛恨的就是背答案这个事情了。<br>学完这个题库，把此题库都理解透彻应对各家企业面试完全没有问题。（当然，要加上好的<br>项目以及透彻掌握）<br>另外，此面试题库中不包括面试中问到的项目，hr 面以及个人技术发展类。<br> 项目是比较个性化的，没办法作为一个题库来给大家参考，但是如果你有一个非常有含<br>金量的项目的话，是非常加分的，而且你的项目可能也会被问的多一些；<br> hr 面的话一般来说技术面通过的话个人没有太大的和公司不符合的问题都能通过；<br> 技术发展类的话这个就完全看自己啦，主要考察的会是你对技术的热爱和学习能力，比<br>如会问一些你是如何学习 xxx 技术的，或者能表达出你对技术的热爱的地方等等。此处<br>不做赘述。<br>那么抛开这些，Java 工程师中技术面中考察的占比如下：<br>需要注意的是：此图不绝对，因为实际面试中面试官会根据你的简历去问，比如你的项目多<br>NOWCODER.COM<br>可能就问的项目多一些，或者你说哪里精通可能面试官就多去问你这些。而且此图是根据题<br>库数据整理出来，并不是根据实际单场面试整理，比如基础部分不会考那么多，会从中抽着<br>考<br>但是面试中必考的点且占比非常大的有 Java 基础和算法。<br>决定你是否能拿 sp offer（高薪 offer）以及是否进名企的是项目和算法。<br>可以看出，算法除了是面试必过门槛以外，更是决定你是否能进名企或高薪 offer 的决定性<br>因素。<br>另外关于算法部分，想要系统的学习算法思想，实现高频面试题最优解等详细讲解的话可以<br>报名算法名企校招冲刺班或算法高薪校招冲刺班，你将能学到更先进的算法思想以及又一套<br>系统的校招高频题目的解题套路和方法论。<br>多出来的服务如下：<br>NOWCODER.COM<br>如果有什么问题，也可以加 qq 咨询 1440073724，如果是早鸟的话，还可以领取早鸟优惠哦<br>二、面试技巧<br>面试一般分为技术面和 hr 面，形式的话很少有群面，少部分企业可能会有一个交叉面，不<br>过总的来说，技术面基本就是考察你的专业技术水平的，hr 面的话主要是看这个人的综合<br>素质以及家庭情况符不符合公司要求，一般来讲，技术的话只要通过了技术面 hr 面基本上<br>是没有问题（也有少数企业 hr 面会刷很多人）<br>那我们主要来说技术面，技术面的话主要是考察专业技术知识和水平，我们是可以有一定的<br>技巧的，但是一定是基于有一定的能力水平的。<br>所以也慎重的告诉大家，技巧不是投机取巧，是起到辅助效果的，技术面最主要的还是要有<br>实力，这里是基于实力水平之上的技巧。<br>这里告诉大家面试中的几个技巧：<br>1、简历上做一个引导：<br>在词汇上做好区分，比如熟悉 Java，了解 python，精通 c 语言<br>这样的话对自己的掌握程度有个区分，也好让面试官有个着重去问，python 本来写的也只<br>是了解，自然就不会多问你深入的一些东西了。<br>2、在面试过程中做一个引导：<br>面试过程中尽量引导到自己熟知的一个领域，比如问到你说一下 DNS 寻址，然后你简单回<br>答（甚至这步也可以省略）之后，可以说一句，自己对这块可能不是特别熟悉，对计算机网<br>络中的运输层比较熟悉，如果有具体的，甚至可以再加一句，比如 TCP 和 UDP<br>这样的话你可以把整个面试过程往你熟知的地方引导，也能更倾向于体现出你的优势而不是<br>劣势，但是此方法仅限于掌握合适的度，比如有的知识点是必会的而你想往别处引就有点说<br>不过去了，比如让你说几个 Java 的关键字，你一个也说不上来，那可能就真的没辙了。<br>3、在自我介绍中做一个引导：<br>一般面试的开头都会有一个自我介绍，在这个位置你也可以尽情的为自己的优势方面去引导。<br>4、面试过程中展示出自信：<br>面试过程中的态度也要掌握好，不要自卑，也不要傲娇，自信的回答出每个问题，尤其遇到<br>不会的问题，要么做一些引导，实在不能引导也可以先打打擦边球，和面试官交流一下问题，<br>看起来像是没听懂题意，这个过程也可以再自己思考一下，如果觉得这个过程可以免了的话<br>也直接表明一下这个地方不太熟悉或者还没有掌握好，千万不要强行回答。<br>面试前的准备：<br>NOWCODER.COM<br>最重要的肯定是系统的学习了，有一个知识的框架，基础知识的牢靠程度等。<br>其中算法尤其重要，越来越多公司还会让你现场或者视频面试中手写代码；<br>另一大重要的和加分项就是项目，在面试前，一定要练习回答自己项目的三个问题：<br> 这是一个怎样的项目<br> 用到了什么技术，为什么用这项技术（以及每项技术很细的点以及扩展）<br> 过程中遇到了什么问题，怎么解决的。<br>那么话说回来，这个的前提是你要有一个好的项目，牛客网 CEO 叶向宇有带大家做项目，<br>感兴趣的可以去了解一下<br> 竞争力超过 70%求职者的项目：<br>（专属优惠码：DjPgy3x，每期限量前 100 个）<br> 竞争力超过 80%求职者的项目：<br>（专属优惠码：DMVSexJ，每期限量前 100 个）<br>知识都掌握好后，剩下的就是一个心态和模拟练习啦，因为你面试的少的话现场难免紧张，<br>而且没在那个环境下可能永远不知道自己回答的怎么样。<br>因为哪怕当你都会了的情况下，你的表达和心态就显得更重要了，会了但是没有表达的很清<br>晰就很吃亏了，牛客网这边有 AI 模拟面试，完全模拟了真实面试环境，正好大家可以真正<br>的去练习一下，还能收获一份面试报告：<br>面试后需要做的：<br>面试完了的话就不用太在意结果了，有限的时间就应该做事半功倍的事情，当然，要保持电<br>话邮箱畅通，不然别给你发 offer 你都不知道。<br>抛开这些，我们需要做的是及时将面试中的问题记录下来，尤其是自己回答的不够好的问题，<br>一定要花时间去研究，并解决这些问题，下次面试再遇到相同的问题就能很好的解决，当然，<br>即使不遇到，你这个习惯坚持住，后面也可以作为一个经历去跟面试官说，能表现出你对技<br>术的喜爱和钻研的一个态度，同时，每次面试后你会发现自己的不足，查缺补漏的好机会，<br>及时调整，在不断的调整和查缺补漏的过程中，你会越来越好。 三、面试考点导图<br>NOWCODER.COM<br>NOWCODER.COM<br>四、一对一答疑讲解戳这里<br>如果你对校招求职或者职业发展很困惑，欢迎与牛客网专业老师沟通，老师会帮你一对一讲<br>解答疑哦（可以扫下方二维码或者添加微信号：niukewang985）<br>NOWCODER.COM<br>目录<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>②关键字<br>③面向对象<br>④集合部分<br>2、Java 高级知识<br>①线程<br>②锁<br>③JDK<br>④反射<br>⑤JVM<br>⑥GC<br>⑦ IO 和 NIO，AIO<br>二、JavaEE 部分<br>1、Spring<br>①IoC 与 Bean 配置、管理<br>②AOP 与事务、权限控制<br>③S2SH 整合开发<br>④Spring，JPA 整合<br>2、Hibernate<br>①ORM 与持久化映射<br>②延迟加载、性能优化<br>③HQL 查询、条件查询、SQL 查询<br>④二级缓存与查询缓存<br>3、Struts<br>①MVC 模式与 Struts 体系<br>4、mybatis<br>5、MVC 框架<br>6、各框架对比与项目优化<br>7、JPA<br>①EJB<br>三、Java web 开发核心内容<br>1、web 编程基础<br>①Tomcat 服务器<br>NOWCODER.COM<br>②JSP 语法，EL，内置对象<br>③Listener 和 filter<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>②redis<br>③MVC 和 DAO<br>④JSTL、DisplayTag 等常见标签库的用法<br>3、Web 编程原理<br>① HTTP 协议<br>②请求&#x2F;相应架构原理<br>③web 容器<br>四、JDBC 编程<br>1、SQL 基础<br>2、JDBC 基础<br>①数据库<br>②数据库连接池<br>③事物管理，批处理<br>3、JDBC 进阶<br>五、XML 编程<br>1、XML 基础<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>六、计算机网络<br>1、网络概述<br>①关于分层<br>2、运输层<br>①TCP 与 UDP<br>②协议<br>3、网络层<br>①网际协议 IP<br>②网际控制报文协议 ICMP<br>③因特网的路由器选择协议<br>4、应用层<br>①域名系统 DNS<br>②电子邮件<br>NOWCODER.COM<br>七、操作系统<br>1、操作系统概论<br>2、进程的描述与控制<br>3、输入输出系统<br>4、存储器管理<br>5、处理机调度与死锁<br>八、算法与数据结构<br>1、哈希<br>2、树<br>3、遍历<br>4、链表<br>5、数组<br>6、排序<br>7、堆与栈<br>8、队列<br>9、高级算法<br>九、设计模式<br>1、结构型模式<br>①代理模式<br>②装饰模式<br>③适配器模式<br>2、创建型模式<br>①单例模式<br>3、行为型模式<br>①策略模式<br>②观察者模式<br>4、所有模式汇总<br>十、场景题<br>十一、UML<br>更多名企历年笔试真题可点击直接进行练习：<br>NOWCODER.COM<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>1、为什么重写 equals 还要重写 hashcode？<br>考点：java 基础<br>参考回答：<br>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()<br>方法继承于 Object 类，其 hashcode 码为默认的内存地址，这样即便有相同含义的两个对象，比<br>较也是不相等的。HashMap 中的比较 key 是这样的，先求出 key 的 hashcode(),比较其值是否相<br>等，若相等再比较 equals(),若相等则认为他们是相等的。若 equals()不相等则认为他们不相等。<br>如果只重写 hashcode()不重写 equals()方法，当比较 equals()时只是看他们是否为同一对象（即<br>进行内存地址的比较）,所以必定要两个方法一起重写。HashMap 用来判断 key 是否相等的方法，<br>其实是调用了 HashSet 判断加入元素 是否相等。重载 hashCode()是为了对同一个 key，能得到<br>相同的 Hash Code，这样 HashMap 就可以定位到我们指定的 key 上。重载 equals()是为了向<br>HashMap 表明当前对象和 key 上所保存的对象是相等的，这样我们才真正地获得了这个 key 所对<br>应的这个键值对。<br>2、说一下 map 的分类和常见的情况<br>考点：java 基础<br>参考回答：<br>java 为数据结构中的映射定义了一个接口 java.util.Map;它有四个实现类,分别是 HashMap<br>Hashtable LinkedHashMap 和 TreeMap.<br>Map 主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重<br>复。<br>Hashmap 是一个最常用的 Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的<br>值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap 最多只允许一条<br>记录的键为 Null;允许多条记录的值为 Null;HashMap 不支持线程的同步，即任一时刻可以有多<br>个线程同时写 HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections 的<br>synchronizedMap 方法使 HashMap 具有同步的能力，或者使用 ConcurrentHashMap。<br>Hashtable 与 HashMap 类似,它继承自 Dictionary 类，不同的是:它不允许记录的键或者值<br>为空;它支持线程的同步，即任一时刻只有一个线程能写 Hashtable,因此也导致了 Hashtable<br>在写入时会比较慢。<br>NOWCODER.COM<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排<br>序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，<br>遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和<br>容量无关，而 HashMap 的遍历速度和他的容量有关。<br>TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>一般情况下，我们用的最多的是 HashMap,在 Map 中插入、删除和定位元素，HashMap 是最<br>好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。如果需要输出的<br>顺序和输入的相同,那么用 LinkedHashMap 可以实现,它还可以按读取顺序来排列.<br>HashMap 是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的<br>值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。<br>HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的<br>不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的<br>能力。<br>Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，<br>即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。<br>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的<br>记录肯定是先插入的。<br>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，<br>也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？<br>考点：基础<br>参考回答：<br>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回<br>对象的 内存地址。<br>4、&#x3D;&#x3D;比较的是什么？<br>考点：基础<br>参考回答：<br>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，<br>“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。<br>NOWCODER.COM<br>5、若对一个类不重写，它的 equals()方法是如何比较的？<br>考点：基础<br>参考回答：<br>比较是对象的地址。<br>6、java8 新特性<br>考察点：java8<br>参考回答：<br>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。<br>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）<br>的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。<br>新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。<br>Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到<br>Java 中。<br>Date Time API − 加强对日期与时间的处理。<br>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许<br>我们在 JVM 上运行特定的 javascript 应用。<br>7、说说 Lamda 表达式的优缺点。<br>考察点：Java 基础<br>参考回答：<br>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。<br>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时<br>需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码<br>不容易让其他语言的程序员看懂。<br>8、一个十进制的数在内存中是怎么存的？<br>考察点：计算机基础<br>NOWCODER.COM<br>参考回答：<br>补码的形式。<br>9、为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？<br>考察点：计算机基础<br>参考回答：<br>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小<br>数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。<br>10、Java 支持的数据类型有哪些？什么是自动拆装箱？<br>考察点：JAVA 数据类型<br>参考回答：<br>Java 语言支持的 8 种基本数据类型是：<br>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：<br>把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。<br>11、什么是值传递和引用传递？<br>考察点：JAVA 引用传递<br>参考回答：<br>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。<br>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递. 12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不<br>是 ArrayList？<br>考察点：Array<br>NOWCODER.COM<br>参考回答：<br>Array 和 ArrayList 的不同点：<br>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。<br>Array 大小是固定的，ArrayList 的大小是动态变化的。<br>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类<br>型的时候，这种方式相对比较慢。<br>13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？<br>考察点：JAVA notation<br>参考回答：<br>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下<br>有多么好。<br>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般<br>使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一<br>个很好的说明。<br>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。<br>其函数表示是：<br>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));<br>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。<br>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使<br>用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好<br>的说明。<br>14、String 是最基本的数据类型吗?<br>考察点：数据类型<br>参考回答：<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效<br>率节省空间，我们应该用 StringBuffer 类。<br>15、int 和 Integer 有什么区别<br>考察点：数据类型<br>NOWCODER.COM<br>参考回答：<br>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据<br>类型，Integer 是 java 为 int 提供的封装类。<br>Java 为每个原始类型提供了封装类。<br>原始类型封装类<br>booleanBoolean<br>charCharacter<br>byteByte<br>shortShort<br>intInteger<br>longLong<br>floatFloat<br>doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同<br>的特征和用法，它们包括：大小和速<br>度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时<br>所指定的缺省值。对象引用实例变量<br>的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。<br>16、String 和 StringBuffer 的区别<br>考察点：数据类型<br>参考回答：<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多<br>个字符的字符数据。这个 String 类提供了<br>数值不可改变的字符串。而这个 StringBuffer 类提供的字符串进行修改。当你知道字符数据要<br>改变的时候你就可以使用 StringBuffer 。典型地，你可以使用 StringBuffers 来动态构造字符数据。<br>17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1<br>等，如何输出一个某种编码的字符串？<br>考察点：数据类型<br>参考回答：<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1″), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>NOWCODER.COM<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>18、int 和 Integer 有什么区别？<br>考察点：数据类型<br>参考回答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，<br>但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的<br>包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱<br>机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：* 原始类型: boolean，char，byte，short，int，long，float，double</li></ol><ul><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<br>如：<br>class AutoUnboxingTest {<br>public static void main(String[] args) {<br>Integer a &#x3D; new Integer(3);<br>Integer b &#x3D; 3; &#x2F;&#x2F; 将 3 自动装箱成 Integer 类型<br>int c &#x3D; 3;<br>System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false 两个引用没有引用同一对象<br>System.out.println(a &#x3D;&#x3D; c); &#x2F;&#x2F; true a 自动拆箱成 int 类型再和 c 比较<br>}<br>}<br>19、&amp;和&amp;&amp;的区别？<br>考察点：运算符<br>参考回答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的<br>差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是<br>NOWCODER.COM<br>true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直<br>接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定<br>用户名不是 null 而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，<br>二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的<br>equals 比较，否则会产生 NullPointerException 异常。<br>20、在 Java 中，如何跳出当前的多重嵌套循环？<br>考察点：循环<br>参考回答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标<br>签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时<br>候甚至有相反的作用，所以这种语法其实不知道更好）<br>21、你能比较一下 Java 和 JavaSciprt 吗？<br>考察：Java&amp;JavaScript<br>参考回答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司<br>推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape<br>公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对<br>象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：</li><li>基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设<br>计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软<br>件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身<br>提供了非常丰富的内部对象供设计人员使用。</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，<br>其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技<br>术来提升 JavaScript 的运行效率）</li><li>强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；<br>JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行<br>时检查推断其数据类型。</li><li>代码格式不一样。<br>22、简述正则表达式及其用途。<br>考察点：正则表达式<br>参考回答：<br>NOWCODER.COM<br>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式<br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的<br>信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大<br>的工具，绝大多数语言都提供了对正则表达式的支持。<br>23、Java 中是如何支持正则表达式操作的？<br>考察点：正则表达式<br>参考回答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、<br>replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰<br>富的 API 进行各种正则表达式操作，如：<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;<br>class RegExpTest {<br>public static void main(String[] args) {<br>String str &#x3D; “成都市(成华区)(武侯区)(高新区)”;<br>Pattern p &#x3D; Pattern.compile(“.*?(?&#x3D;\()”);<br>Matcher m &#x3D; p.matcher(str);<br>if(m.find()) {<br>System.out.println(m.group());<br>}<br>}<br>}<br>24、请你说说 Java 和 PHP 的区别？<br>考察点：Java 特性<br>参考回答：<br>PHP 暂时还不支持像 Java 那样 JIT 运行时编译热点代码,但是 PHP 具有 opcache 机制,能够<br>把脚本对应的 opcode 缓存在内存,PHP7 中还支持配置 opcache.file_cache 导出 opcode 到文件. 第三方的 Facebook HHVM 也支持 JIT.另外 PHP 官方基于 LLVM 围绕 opcache 机制构建的 Zend JIT<br>分支也正在开发测试中.在 php-src&#x2F;Zend&#x2F;bench.php 测试显示,PHP JIT 分支速度是 PHP 5.4 的<br>10 倍.<br>PHP 的库函数用 C 实现,而 Java 核心运行时类库(jdk&#x2F;jre&#x2F;lib&#x2F;rt.jar,大于 60MB)用 Java 编写<br>(jdk&#x2F;src.zip), 所以 Java 应用运行的时候,用户编写的代码以及引用的类库和框架都要在 JVM<br>上解释执行. Java 的 HotSpot 机制,直到有方法被执行 10000 次才会触发 JIT 编译, 在此之前运<br>行在解释模式下,以避免出现 JIT 编译花费的时间比方法解释执行消耗的时间还要多的情况.<br>PHP 内置模板引擎,自身就是模板语言.而 Java Web 需要使用 JSP 容器如 Tomcat 或第三方模<br>板引擎.<br>NOWCODER.COM<br>PHP 也可以运行在多线程模式下,比如 Apache 的 event MPM 和 Facebook 的 HHVM 都是多线程<br>架构.不管是多进程还是多线程的 PHP Web 运行模式,都不需要 PHP 开发者关心和控制,也就是说<br>PHP 开发者不需要写代码参与进程和线程的管理,这些都由 PHP-FPM&#x2F;HHVM&#x2F;Apache 实现.PHP-FPM<br>进程管理和并发实现并不需要 PHP 开发者关心,而 Java 多线程编程需要 Java 开发者编码参<br>与.PHP 一个 worker 进程崩溃,master 进程会自动新建一个新的 worker 进程,并不会导致 PHP 服<br>务崩溃.而 Java 多线程编程稍有不慎(比如没有捕获异常)就会导致 JVM 崩溃退出.对于 PHP-FPM<br>和 Apache MOD_PHP 来说,服务进程常驻内存,但一次请求释放一次资源,这种内存释放非常彻底.<br>PHP 基于引用计数的 GC 甚至都还没发挥作用程序就已经结束了。 ②关键字<br>1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什<br>么？如果修饰成员方法，锁住了什么？<br>考点：java 关键字<br>参考回答：<br>synchronized 修饰静态方法以及同步代码块的 synchronized (类.class)用法锁的是类，线<br>程想要执行对应同步代码，需要获得类锁。<br>synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。<br>2、介绍一下 volatile？<br>考察点：java 关键字<br>参考回答：<br>volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。比如我们所写的<br>代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，<br>这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高 CPU 的执行效<br>率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有<br>happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面<br>对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先 Java 内存模<br>型分为，主内存，工作内存。比如线程 A 从主内存把变量从主内存读到了自己的工作内存中，做<br>了加 1 的操作，但是此时没有将 i 的最新值刷新会主内存中，线程 B 此时读到的还是 i 的旧值。<br>加了 volatile 关键字的代码生成的汇编代码发现，会多出一个 lock 前缀指令。Lock 指令对 Intel<br>平台的 CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多<br>核之间数据不一致性问题。<br>3、锁有了解嘛，说一下 Synchronized 和 lock<br>考察点：java 关键字<br>NOWCODER.COM<br>参考回答：<br>synchronized 是 Java 的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证<br>在同一时刻最多只有一个线程执行该段代码。JDK1.5 以后引入了自旋锁、锁粗化、轻量级锁，<br>偏向锁来有优化关键字的性能。<br>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；<br>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock<br>在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock<br>时需要在 finally 块中释放锁；Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，<br>使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没<br>有成功获取锁，而 synchronized 却无法办到。<br>4、讲一讲 Java 里面的 final 关键字怎么用的？<br>考察点：关键字<br>参考回答：<br>当用 final 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他<br>被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注<br>意 final 类中的所有成员方法都会被隐式地指定为 final 方法。<br>“使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；<br>第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法<br>过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final<br>方法进行这些优化了。“<br>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；<br>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 ③面向对象<br>1、wait 方法底层原理<br>考察点：基础<br>参考回答：<br>ObjectSynchronizer::wait 方法通过 object 的对象中找到 ObjectMonitor 对象调用方法<br>void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)<br>通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队<br>列的末尾中然后在 ObjectMonitor::exit 释放锁，接着 thread_ParkEvent-&gt;park 也就是 wait。<br>NOWCODER.COM<br>2、Java 有哪些特性，举个多态的例子。<br>考察点：语言特性<br>参考回答：<br>封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据<br>发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）<br>3、String 为啥不可变？<br>考察点：面向对象<br>参考回答：<br>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不<br>能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对<br>象，引用类型指向的对象的状态也不能改变。<br>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字<br>节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以<br>在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串<br>是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得<br>数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不<br>可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安<br>全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，<br>这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的<br>所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计<br>算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是<br>HashMap 中的键往往都使用字符串的原因。<br>4、类和对象的区别<br>考察点：面向对象<br>参考回答：<br>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。<br>比如：“人”是一个类，而“教师”则是“人”的一个实例。<br>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性<br>的对象集合体。<br>5、请列举你所知道的 Object 类的方法。<br>考察点：面向对象<br>NOWCODER.COM<br>参考回答：<br>Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指<br>示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引<br>用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回<br>该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此<br>对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等<br>待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导<br>致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超<br>过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此<br>对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某<br>个实际时间量。<br>6、重载和重写的区别？相同参数不同返回值能重载吗？<br>考察点：重载<br>参考回答：<br>重载(Overloading)<br>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，<br>具有不同的参数个数&#x2F;类型。<br>重载 Overloading 是一个类中多态性的一种表现。<br>（2） Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同<br>的参数和不同的定义。<br>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是<br>多态性。<br>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可<br>以不相同。无法以返回型别作为重载函数的区分标准。<br>重写（Overriding）<br>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与<br>其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类<br>中的方法，而不需要重新编写相同的方法。<br>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的<br>重写。<br>方法重写又称方法覆盖。<br>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法<br>将覆盖原有的方法。<br>如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。<br>NOWCODER.COM<br>（3）子类函数的访问修饰权限不能少于父类的。<br>7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private<br>或者是 static 的方法？<br>考察点：static 变量<br>参考回答：<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情<br>况下被访问。<br>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编<br>译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。<br>8、String 能继承吗？<br>考察点：String<br>参考回答：<br>不能，char 数组用 final 修饰的。<br>9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？<br>考察点：类<br>参考回答：<br>StringBuffer 线程安全，StringBuilder 线程不安全，底层实现上的话，StringBuffer 其<br>实就是比 StringBuilder 多了 Synchronized 修饰符。<br>10、类加载机制，双亲委派模型，好处是什么？<br>考察点：类<br>参考回答：<br>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，<br>如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才<br>自己去加载。<br>使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次<br>关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最<br>终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各<br>种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的<br>话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现<br>NOWCODER.COM<br>多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的<br>Java 类，可以正常编译，但是永远无法被加载运行。<br>11、静态变量存在哪?<br>考察点：类<br>参考回答：<br>方法区<br>12、讲讲什么是泛型？<br>考察点：JAVA 泛型<br>参考回答：<br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法<br>时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，<br>类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;<br>调用时传入具体的类型（类型实参）。</li></ul><p>采用泛型写法后，在&#x2F;&#x2F;1 处想加入一个 Integer 类型的对象时会出现编译错误，通过<br>List&lt;String&gt;，直接限定了 list 集合中只能含有 String 类型的元素，从而在&#x2F;&#x2F;2 处无须进行强<br>制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是 String 类型<br>了。<br>13、解释 extends 和 super 泛型限定符-上界不存下界不取<br>考察点：JAVA 泛型<br>参考回答：<br>（1）泛型中上界和下界的定义<br>上界 &lt;? extend Fruit&gt;<br>下界 &lt;? super Apple&gt;<br>（2）上界和下界的特点<br>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）<br>下界的 list 只能 add，不能 get<br>（3）示例代码</p><p>（4）上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确<br>定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，<br>不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把<br>所有的子类向上转型为 Fruit。<br>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。<br>那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父<br>类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple<br>及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接<br>着呢，除了 Object，其他的都接不住。<br>NOWCODER.COM<br>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。<br>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引<br>用就必须得用 cast。<br>14、是否可以在 static 环境中访问非 static 变量？<br>考察点：static 变量<br>参考回答：<br>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机<br>载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，<br>编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。<br>15、谈谈如何通过反射创建对象？<br>考察点：类<br>参考回答：</p><ul><li>方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()</li><li>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器<br>（Constructor）对象并调用其 newInstance()方法创建对象，例如：<br>String.class.getConstructor(String.class).newInstance(“Hello”);<br>16、Java 支持多继承么？<br>考察点：JAVA 多继承<br>参考回答：<br>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口<br>支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子<br>接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</li></ul><p>18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。<br>考察点：comparable 接口<br>参考回答：<br>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象<br>排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两<br>个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()<br>方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也<br>是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回<br>true。</p><p>23、Static Nested Class 和 Inner Class 的不同<br>考察点：声明<br>参考回答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被<br>实例化。而通常的内部类需要在外部类实<br>例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义<br>为动态的(instance).Nested Class 的静态成员(Method)只能对 Outer Class 的静态成员(static<br>memebr)进行操作(ACCESS), 而不能 Access Outer Class 的动态成员(instance member).而<br>Nested Class 的动态成员(instance method) 却可以 Access Outer Class 的所有成员, 这个概<br>念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而 动<br>态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)<br>永远不可以 Access 跟 object 相关的动态成员(instance member),反过来就可以, 一个 CLASS<br>的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，<br>并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>考察点：对象<br>参考回答：<br>是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中<br>时，参数的值就是对该对象的引用。对象<br>的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。<br>25、Java 的接口和 C++的虚类的相同和不同处。<br>考察点：接口<br>参考回答：<br>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或<br>属性，现有的单继承机制就不能满足要求。<br>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，<br>该类要实现接口里面所有的方法和属<br>NOWCODER.COM<br>性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。<br>26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally<br>分别代表什么意义？在 try 块中可以抛出异常吗？<br>考察点：异常<br>参考回答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接<br>口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个<br>异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个<br>异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br>用 try 来指定一块预防所有”异常”的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指<br>定你想要捕捉的”异常”的类型。throw 语句用来明确地抛出一个”异常”。throws 用来标明一<br>个成员函数可能抛出的各种”异常”。Finally 为确保一段代码不管发生什么”异常”都被执行<br>一段代码。可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try<br>语句保护其他代码。每当遇到一个 try 语句，”异常“的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有<br>处理这种”异常”的 try 语句。<br>27、内部类可以引用他包含类的成员吗？有没有什么限制？<br>考察点：类<br>参考回答：<br>一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是 static 的，那么它<br>可以访问创建它的外部类对象的所有属性内部类如果是 sattic 的，即为 nested class，那么它<br>只可以访问创建它的外部类对象的所有 static 属性一般普通类只有 public 或 package 的访问修<br>饰，而内部类可以实现 static，protected，private 等访问修饰。当从外部类继承的时候，内<br>部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明<br>确地继承，就可以覆盖原来内部类的方法。<br>28、两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code 说法<br>是否正确？<br>考察点：对象<br>参考回答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当<br>相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals<br>方法返回 true），那么它们的 hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它<br>NOWCODER.COM<br>们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容<br>器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存<br>储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>30、如何通过反射获取和设置对象私有字段的值？<br>考察点：类<br>参考回答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段对象的<br>setAccessible(true)将其设置为可以访问，接下来就可以通过 get&#x2F;set 方法来获取&#x2F;设置字段的<br>值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段<br>的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如<br>ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得 dog 对象的主人的汽车的引擎的<br>ID 号。31、谈一下面向对象的”六原则一法则”。<br>考察点：Java 对象<br>参考回答：<br>NOWCODER.COM</p><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写<br>代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功<br>能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内<br>聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到<br>变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶<br>皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到<br>其他系统中使用的，这样才能实现软件复用的目标。）- 开闭原则：软件实体应当对扩展开放，<br>对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系<br>统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是<br>关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可<br>变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不<br>清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- 依赖倒<br>转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类<br>型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一<br>个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换<br>掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简<br>单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，<br>如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。<br>例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容<br>易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的<br>能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示<br>能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分<br>别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方<br>法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会<br>几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、<br>代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- 合成聚合复用<br>原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用<br>得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之<br>间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其<br>中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A<br>关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可<br>以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例<br>子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错<br>误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置<br>为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。<br>记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- 迪<br>米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂<br>的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter<br>不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的<br>请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内<br>存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到<br>一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设<br>备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。<br>NOWCODER.COM<br>32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？<br>考察点：接口<br>参考回答：<br>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的<br>前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使<br>用 iterate()方法可以减少性能开销。<br>② list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题<br>33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？<br>考察点：方法<br>参考回答：<br>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的<br>情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参<br>数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。<br>34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？<br>考察点：JAVA 构造函数<br>参考回答：<br>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提<br>供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。<br>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必<br>须有它自己唯一的参数列表。<br>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，<br>Java 不会创建默认的复制构造函数。<br>35、hashCode()和 equals()方法有什么联系？<br>考点：基础<br>参考回答：<br>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<br>➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>➁ 如果两个对象的 hashCode 相同，它们并不一定相同。<br>NOWCODER.COM<br>④集合部分<br>1、Map 和 ConcurrentHashMap 的区别？<br>考点：集合<br>参考回答：<br>hashmap 是线程不安全的，put 时在多线程情况下，会形成环从而导致死循环。<br>CoucurrentHashMap 是线程安全的，采用分段锁机制，减少锁的粒度。<br>2、hashMap 内部具体如何实现的？<br>考点：集合<br>参考回答：<br>Hashmap 基于数组实现的，通过对 key 的 hashcode &amp; 数组的长度得到在数组中位置，如当<br>前数组有元素，则数组当前元素 next 指向要插入的元素，这样来解决 hash 冲突的，形成了拉链<br>式的结构。put 时在多线程情况下，会形成环从而导致死循环。数组长度一般是 2n，从 0 开始编<br>号，所以 hashcode &amp; （2n-1），（2n-1）每一位都是 1，这样会让散列均匀。需要注意的是，<br>HashMap 在 JDK1.8 的版本中引入了红黑树结构做优化，当链表元素个数大于等于 8 时，链表转<br>换成树结构；若桶中链表元素个数小于等于 6 时，树结构还原成链表。因为红黑树的平均查找长<br>度是 log(n)，长度为 8 的时候，平均查找长度为 3，如果继续使用链表，平均查找长度为 8&#x2F;2&#x3D;4，<br>这才有转换为树的必要。链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，虽然速度也很快的，但是转化为<br>树结构和生成树的时间并不会太短。还有选择 6 和 8，中间有个差值 7 可以有效防止链表和树频<br>繁转换。假设一下，如果设计成链表个数超过 8 则链表转换成树结构，链表个数小于 8 则树结构<br>转换成链表，如果一个 HashMap 不停的插入、删除元素，链表个数在 8 左右徘徊，就会频繁的发<br>生树转链表、链表转树，效率会很低。<br>3、如果 hashMap 的 key 是一个自定义的类，怎么办？<br>考点：集合<br>参考回答：<br>使用 HashMap，如果 key 是自定义的类，就必须重写 hashcode()和 equals()。<br>4、ArrayList 和 LinkedList 的区别，如果一直在 list 的尾部添加元素，用哪<br>个效率高？<br>考点：集合<br>参考回答：<br>NOWCODER.COM<br>ArrayList 采用数组数组实现的，查找效率比 LinkedList 高。LinkedList 采用双向链表实<br>现的，插入和删除的效率比 ArrayList 要高。一直在 list 的尾部添加元素，LinkedList 效率要<br>高。<br>5、HashMap 底层，负载因子，为啥是 2^n？<br>考点：集合<br>参考回答：<br>负载因子默认是 0.75， 2^n 是为了让散列更加均匀，例如出现极端情况都散列在数组中的<br>一个下标，那么 hashmap 会由 O（1）复杂退化为 O（n）的。<br>6、ConcurrentHashMap 锁加在了哪些地方？<br>考点：集合<br>参考回答：<br>加在每个 Segment 上面。<br>7、TreeMap 底层，红黑树原理？<br>考点：集合<br>参考回答：<br>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证<br>当需要快速检索指定节点。<br>红黑树的插入、删除、遍历时间复杂度都为 O(lgN)，所以性能上低于哈希表。但是哈希表<br>无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑<br>树性质：<br>性质 1：每个节点要么是红色，要么是黑色。<br>性质 2：根节点永远是黑色的。<br>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。<br>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续<br>的红色节点）<br>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。<br>8、concurrenthashmap 有啥优势，1.7，1.8 区别？<br>NOWCODER.COM<br>考点：集合<br>参考回答：<br>Concurrenthashmap 线程安全的，1.7 是在 jdk1.7 中采用 Segment + HashEntry 的方式进<br>行实现的，lock 加在 Segment 上面。1.7size 计算是先采用不加锁的方式，连续计算元素的个数，<br>最多计算 3 次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果<br>前后两次计算结果都不同，则给每个 Segment 进行加锁，再计算一次元素的个数；<br>1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node + CAS + Synchronized 来<br>保证并发安全进行实现，1.8 中使用一个 volatile 类型的变量 baseCount 记录元素的个数，当<br>插入新数据或则删除数据时，会通过 addCount()方法更新 baseCount，通过累加 baseCount 和<br>CounterCell 数组中的数量，即可得到元素的总个数；<br>9、ArrayList 是否会越界？<br>考点：集合<br>参考回答：<br>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构 2. 对<br>于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList<br>并发 add()可能出现数组下标越界异常<br>10、什么是 TreeMap?<br>考察点：key-value 集合<br>参考回答：<br>TreeMap 是一个有序的 key-value 集合，基于红黑树（Red-Black tree）的 NavigableMap<br>实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，<br>具体取决于使用的构造方法。<br>TreeMap 的特性：<br>根节点是黑色<br>每个节点都只能是红色或者黑色<br>每个叶节点（NIL 节点，空节点）是黑色的。<br>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个<br>红色的节点。<br>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>NOWCODER.COM<br>11、ConcurrentHashMap 的原理是什么？<br>考察点：JAVA 内存模型<br>参考回答：<br>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封<br>装映射表的键 &#x2F; 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的<br>若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例<br>中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在<br>HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。<br>static final class HashEntry&lt;K,V&gt; {<br>final K key; &#x2F;&#x2F; 声明<br>key 为 final 型<br>final int hash; &#x2F;&#x2F; 声明 hash<br>值为 final 型<br>volatile V value; &#x2F;&#x2F; 声明 value 为<br>volatile 型<br>final HashEntry&lt;K,V&gt; next; &#x2F;&#x2F; 声明 next 为 final 型<br>HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) {<br>this.key &#x3D; key;<br>this.hash &#x3D; hash;<br>this.next &#x3D; next;<br>this.value &#x3D; value;<br>}<br>}<br>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰<br>撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，<br>所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry<br>对象后的结构图：<br>图 1. 插入三个节点后桶的结构示意图：<br>NOWCODER.COM<br>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。<br>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个<br>Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。<br>12、Java 集合类框架的基本接口有哪些？<br>考察点：JAVA 集合<br>参考回答：<br>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它<br>自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基<br>本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的 Collection。<br>List：有顺序的 collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。<br>13、为什么集合类没有实现 Cloneable 和 Serializable 接口？<br>考察点：JAVA 集合<br>参考回答：<br>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，<br>应该由集合类的具体实现来决定如何被克隆或者是序列化。<br>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创<br>建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果<br>你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应<br>用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化<br>14、什么是迭代器？<br>考察点：JAVA 迭代器<br>参考回答：<br>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接<br>口,<br>NOWCODER.COM<br>每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合<br>的元素进行迭代操作. 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出<br>ConcurrentModificationException<br>异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除. 15、Iterator 和 ListIterator 的区别是什么？<br>考察点：迭代器<br>参考回答：<br>Iterator 和 ListIterator 的区别是：<br>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。<br>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前<br>一个和后一个元素的索引，等等。<br>16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？<br>考察点：集合<br>参考回答：<br>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。<br>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的<br>类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全<br>失败的迭代器永远不会抛出这样的异常。<br>18、ArrayList 和 LinkedList 有什么区别？<br>考察点：ArrayList<br>参考回答：<br>NOWCODER.COM<br>ArrayList 和 LinkedList 都实现了 List 接口，他们有以下的不同点：<br>ArrayList 是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行随机<br>访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个<br>和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。<br>相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任<br>意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向<br>前一个元素，一个指向下一个元素。<br>19、ArrayList,Vector,LinkedList 的存储性能和特性是什么？<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索<br>引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector<br>由于使用了 synchronized 方法（线程<br>安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据<br>需要进行前向或后向遍历，但是插入数<br>据时只需要记录本项的前后项即可，所以插入速度较快。<br>20、Collection 和 Collections 的区别。<br>考察点：集合<br>参考回答：<br>Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.<br>Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、<br>线程安全化等操作。<br>21、你所知道的集合类都有哪些？主要方法？<br>考察点：集合<br>参考回答：<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可<br>变大小的列表，比较适合构建、存储和操<br>作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其<br>中每个键映射到一个值。</li></ul><p>23、阐述 ArrayList、Vector、LinkedList 的存储性能和特性<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操<br>作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector<br>是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使<br>用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号<br>索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号<br>索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速<br>度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、<br>BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和<br>LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具<br>类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢<br>模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。<br>24、List、Map、Set 三个接口存取元素时，各有什么特点？<br>考察点：List<br>参考回答：<br>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals()<br>方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一<br>或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理<br>论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的<br>键（key）构成排序树从而达到排序和去重的效果。<br>NOWCODER.COM<br>2、Java 高级知识<br>①线程<br>1、多线程中的 i++线程安全吗？为什么？<br>考察点：多线程<br>参考回答：<br>不安全。i++不是原子性操作。i++分为读取 i 值，对 i 值加一，再赋值给 i++，执行期中任<br>何一步都是有可能被其他线程抢占的。<br>2、如何线程安全的实现一个计数器？<br>考察点：多线程<br>参考回答：<br>可以使用加锁，比如 synchronized 或者 lock。也可以使用 Concurrent 包下的原子类。<br>3、多线程同步的方法<br>考察点：多线程<br>参考回答：<br>可以使用 synchronized、lock、volatile 和 ThreadLocal 来实现同步。<br>4、介绍一下生产者消费者模式？<br>考察点：线程<br>参考回答：<br>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储<br>空间，生产者向空间里生产数据，而消费者取走数据。<br>优点：支持并发、解耦。<br>5、线程，进程，然后线程创建有很大开销，怎么优化？<br>NOWCODER.COM<br>考察点：多线程<br>参考回答：<br>可以使用线程池。<br>6、线程池运行流程，参数，策略<br>考察点：线程池<br>参考回答：<br>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线<br>程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列<br>满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝<br>策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。<br>7、讲一下 AQS 吧。<br>考察点：多线程<br>参考回答：<br>AQS 其实就是一个可以给我们实现锁的框架<br>内部实现的关键是：先进先出的队列、state 状态<br>定义了内部类 ConditionObject<br>拥有两种线程模式独占模式和共享模式。<br>在 LOCK 包中的相关锁(常用的有 ReentrantLock、 ReadWriteLock)都是基于 AQS 来构建，<br>一般我们叫 AQS 为同步器。<br>10、Java 中有几种线程池？<br>考察点：线程池<br>参考回答：<br>1、newFixedThreadPool 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一<br>个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>2、newCachedThreadPool 创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1<br>分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个<br>工作线程。<br>3、newSingleThreadExecutor 创建一个单线程化的 Executor，即只创建唯一的工作者线程<br>来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特<br>色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个<br>线程是活动的 。<br>4、newScheduleThreadPool 创建一个定长的线程池，而且支持定时的以及周期性的任务执<br>行，类似于 Timer。(这种线程池原理暂还没完全了解透彻)<br>11、线程池有什么好处？<br>考察点：线程池<br>参考回答：<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。<br>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。<br>参考回答：<br>所谓回调，就是客户程序 C 调用服务程序 S 中的某个方法 A，然后 S 又在某个时候反过来调<br>用 C 中的某个方法 B，对于 C 来说，这个 B 便叫做回调方法。<br>17、同步方法和同步代码块的区别是什么？<br>考察点：JAVA 代码块同步<br>参考回答：<br>区别：<br>同步方法默认用 this 或者当前类 class 对象作为锁；<br>NOWCODER.COM<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步<br>问题的部分代码而不是整个方法；<br>18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同<br>步？<br>考察点：JAVA 线程同步<br>参考回答：<br>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一<br>个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行<br>同步代码。<br>26、线程的 sleep()方法和 yield()方法有什么区别？<br>考察点：线程<br>参考回答：<br>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行<br>的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）<br>状态；<br>③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。<br>27、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进<br>入此对象的 synchronized 方法 B？<br>考察点：线程<br>参考回答：<br>NOWCODER.COM<br>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的<br>synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被<br>取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。<br>28、请说出与线程同步以及线程调度相关的方法。<br>考察点：线程同步<br>参考回答：* wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p><ul><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理<br>InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一<br>个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让<br>它们竞争，只有获得锁的线程才能进入就绪状态；<br>通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。<br>Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()<br>方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），<br>信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须<br>得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必<br>须向信号量归还许可（调用 Semaphore 对象的 release()方法）。<br>29、举例说明同步和异步<br>考察点：线程<br>参考回答：<br>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据<br>以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就<br>必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个<br>需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，<br>在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是<br>非阻塞式操作。<br>31、说说线程的基本状态以及状态之间的关系？<br>考察点：线程<br>参考回答：<br>其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表<br>示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait()方法进入等待池，也可能是执行<br>同步方法或同步代码块进入等锁池，或者是调用了 sleep()方法或 join()方法等待休眠或其他线<br>程结束，或是因为发生了 I&#x2F;O 中断。<br>1、Java 中的 LongAdder 和 AtomicLong 的区别<br>考点：JDK<br>参考回答：<br>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到<br>修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在<br>大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合<br>ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。<br>虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger<br>NOWCODER.COM<br>的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字<br>进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元<br>cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进<br>行了有效的分离，提高了并行度。<br>2、JDK 和 JRE 的区别是什么？<br>考察点：JDK<br>参考回答：<br>Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet<br>需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其<br>他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应用程序。 ④反射<br>1、反射的实现与作用<br>考察点：反射<br>参考回答；<br>JAVA 语言编译之后会生成一个.class 文件，反射就是通过字节码文件找到某一个类、类中<br>的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构<br>造方法，Field：类中的属性对象，Method：类中的方法对象。<br>作用：反射机制指的是程序在运行时能够获取自身的信息。在 JAVA 中，只要给定类的名字，<br>那么就可以通过反射机制来获取类的所有信息。 ⑤JVM</li></ul><p>5、JAVA 虚拟机的作用?<br>考察点：java 虚拟机<br>参考回答：<br>解释运行字节码程序 消除平台相关性。<br>NOWCODER.COM<br>jvm 将 java 字节码解释为具体平台的具体指令。一般的高级语言如要在不同的平台上运行，<br>至少需要编译成不同的目标代码。而引入 JVM 后，Java 语言在不同平台上运行时不需要重新编<br>译。Java 语言使用模式 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言编译程序只<br>需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java<br>虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<br>假设一个场景，要求 stop the world 时间非常短，你会怎么设计垃圾回收机制？<br>绝大多数新创建的对象分配在 Eden 区。<br>在 Eden 区发生一次 GC 后，存活的对象移到其中一个 Survivor 区。<br>在 Eden 区发生一次 GC 后，对象是存放到 Survivor 区，这个 Survivor 区已经存在其他存活<br>的对象。<br>一旦一个 Survivor 区已满，存活的对象移动到另外一个 Survivor 区。然后之前那个空间已<br>满 Survivor 区将置为空，没有任何数据。<br>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。<br>9、jvm 是如何实现线程？<br>考察点：JVM<br>参考回答：<br>NOWCODER.COM<br>线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开。<br>一个进程里可以启动多条线程，各个线程可共享该进程的资源(内存地址，文件 IO 等)，又可以<br>独立调度。线程是 CPU 调度的基本单位。<br>主流 OS 都提供线程实现。Java 语言提供对线程操作的同一 API，每个已经执行 start()，<br>且还未结束的 java.lang.Thread 类的实例，代表了一个线程。<br>Thread 类的关键方法，都声明为 Native。这意味着这个方法无法或没有使用平台无关的手<br>段来实现，也可能是为了执行效率。<br>实现线程的方式<br>A.使用内核线程实现内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核支持<br>的线程。<br>内核来完成线程切换<br>内核通过调度器 Scheduler 调度线程，并将线程的任务映射到各个 CPU 上<br>程序使用内核线程的高级接口，轻量级进程(Light Weight Process,LWP)<br>用户态和内核态切换消耗内核资源<br>使用用户线程实现<br>系统内核不能感知线程存在的实现<br>用户线程的建立、同步、销毁和调度完全在用户态中完成<br>所有线程操作需要用户程序自己处理，复杂度高<br>用户线程加轻量级进程混合实现<br>轻量级进程作为用户线程和内核线程之间的桥梁<br>10、jvm 最大内存限制多少<br>考察点：JVM<br>参考回答：<br>(1)堆内存分配<br>JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1&#x2F;64；JVM 最大分配的内存由-Xmx 指<br>定，默认是物理内存的 1&#x2F;4。默认空余堆内存小 于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；<br>空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。因此服务器一般设置-Xms、 -Xmx 相等以避免在每次 GC 后调整堆的大小。<br>(2)非堆内存分配<br>JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1&#x2F;64；由 XX:MaxPermSize<br>设置最大非堆内存的大小，默认是物理内存的 1&#x2F;4。<br>NOWCODER.COM<br>(3)VM 最大内存<br>首先 JVM 内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM 内存的最大值跟<br>操作系统有很大的关系。简单的说就 32 位处理器虽 然可控内存空间有 4GB,但是具体的操作系<br>统会给一个限制，这个限制一般是 2GB-3GB（一般来说 Windows 系统下为 1.5G-2G，Linux 系 统<br>下为 2G-3G），而 64bit 以上的处理器就不会有限制了。<br>(3)下面是当前比较流行的几个不同公司不同版本 JVM 最大堆内存:<br>11、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？<br>考察点：JVM<br>参考回答：<br>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚<br>拟机执行的字节码文件。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或<br>者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。<br>12、描述一下 JVM 加载 class 文件的原理机制?<br>考察点：JVM<br>参考回答：<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的<br>Java 运行时系统组件。它负责在运行时查找和装入类文件的类。<br>Java 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，<br>而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的<br>加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要<br>的类。<br>NOWCODER.COM<br>类装载方式，有两种<br>（1）隐式装载， 程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载<br>对应的类到 jvm 中，<br>（2）显式装载， 通过 class.forname()等方法，显式加载需要的类 , 隐式加载与显式加载的<br>区别：两者本质是一样的。<br>Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行<br>的基础类(像是基类)完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了<br>节省内存开销。 ⑥GC<br>1、java 中内存泄露是啥，什么时候出现内存泄露？<br>考察点：内存泄漏<br>参考回答：<br>Java 中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就<br>是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。<br>2、minor gc 如果运行的很频繁，可能是什么原因引起的，minor gc 如果运行的<br>很慢，可能是什么原因引起的?<br>考察点：GC<br>参考回答：<br>可能是堆内存太小。<br>3、阐述 GC 算法<br>考察点：JVM<br>参考回答：<br>①GC（GarbageCollection 垃圾收集），GC 的对象是堆空间和永久区<br>②GC 算法包含：引用计数法，标记清除，标记压缩，复制算法。<br>③引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用<br>计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A<br>就不可能再被使用。<br>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：<br>标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开<br>始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有<br>未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对<br>象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正<br>NOWCODER.COM<br>在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对<br>象，交换两个内存的角色，完成垃圾回收。<br>4、GC 是什么? 为什么要有 GC?<br>考察点：回收<br>参考回答：<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，<br>忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监<br>测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显<br>示操作方法。<br>5、垃圾回收的优点和原理。并考虑 2 种回收机制<br>考察点：垃圾回收<br>参考回答：<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的<br>问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回<br>收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以<br>有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的<br>线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，<br>程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃<br>圾回收和标记垃圾回收，增量垃圾回收。<br>6、java 中会存在内存泄漏吗，请简单描述。<br>考察点：内存<br>参考回答：<br>Java 中的确存在 Java 的内存泄漏, 并且事态可以变得相当严重<br>Java garbage collector 自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的<br>其他程序上下文的内存泄漏. 但是 Java 应用程序依旧会有相当的内存泄漏. 查找原因会十分困<br>难. 有两类主要的 Java 内存泄漏:* 不再需要的对象引用</p><ul><li>未释放的系统资源<br>2.2 非必要的对象引用<br>Java 代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java 对<br>象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如<br>下问题:</li><li>在向数组添加对象以后遗漏了对于他们的处理</li><li>直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并<br>且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.</li><li>在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面<br>保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当<br>中.<br>NOWCODER.COM</li><li>允许一个长久执行的线程所引用的对象. 设置引用为 NULL 也无济于事, 在线程退出和空闲之<br>前, 对象不会被收集释放<br>2.3 未释放的系统资源<br>Java 方法可以定位 Java 实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java 常常通过<br>JNI(Java Native Interface)调用 C&#x2F;C++子程序定位这些资源. 7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办<br>法主动通知虚拟机进行垃圾回收？（垃圾回收）<br>考察点：垃圾回收<br>参考回答：<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆<br>(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当<br>GC 确定一些对象为”不可达”时，GC 就有责<br>任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。 ⑦ IO 和 NIO，AIO<br>1、怎么打印日志？<br>考察点：异常<br>参考回答：<br>cat &#x2F;var&#x2F;log&#x2F;*.log<br>如果日志在更新，如何实时查看 tail -f &#x2F;var&#x2F;log&#x2F;messages<br>还可以使用 watch -d -n 1 cat &#x2F;var&#x2F;log&#x2F;messages<br>-d 表示高亮不同的地方，-n 表示多少秒刷新一次。<br>2、运行时异常与一般异常有何异同？<br>考察点：异常<br>参考回答：<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异<br>常，但是并不要求必须声明抛出未被捕获的运行时异常。<br>3、error 和 exception 有什么区别?<br>考察点：异常<br>NOWCODER.COM<br>参考回答：<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。<br>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。<br>4、给我一个你最常见到的 runtime exception<br>考察点：异常<br>参考回答：<br>ArithmeticException,<br>ArrayStoreException,<br>BufferOverflowException,<br>BufferUnderflowException,<br>CannotRedoException,<br>CannotUndoException,<br>ClassCastException,<br>CMMException,<br>ConcurrentModificationException,<br>DOMException,<br>EmptyStackException,<br>IllegalArgumentException,<br>IllegalMonitorStateException,<br>IllegalPathStateException,<br>IllegalStateException,<br>ImagingOpException,<br>IndexOutOfBoundsException,<br>MissingResourceException,<br>NegativeArraySizeException,<br>NoSuchElementException,<br>NullPointerException,<br>ProfileDataException,<br>NOWCODER.COM<br>ProviderException,<br>RasterFormatException, SecurityException, SystemException,<br>UndeclaredThrowableException, UnmodifiableSetException,<br>UnsupportedOperationException<br>5、Java 中的异常处理机制的简单原理和应用。<br>考察点：异常<br>参考回答：<br>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。<br>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发<br>IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就<br>是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。<br>6、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，<br>请说出他们分别是哪些类？<br>考察点：stream<br>参考回答：<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于<br>InputStreamReader OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高<br>性能和使用方便。</li></ul><p>8、运行时异常与受检异常有什么区别？<br>考察点：异常<br>参考回答：<br>NOWCODER.COM<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序<br>运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求<br>方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异<br>常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用<br>给出了以下指导原则：* 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流<br>而使用异常）</p><ul><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在 catch 中忽略掉捕获到的异常<br>二、JavaEE 部分<br>3、Spring 里面注解用过没有？autowired 和 resource 区别？<br>考察点：Spring<br>参考回答：<br>1、共同点<br>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter<br>方法。<br>2、不同点<br>（1）@Autowired<br>@Autowired 为 Spring 提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired;只按照 byType 注入。<br>NOWCODER.COM<br>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存<br>在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）<br>来装配，可以结合@Qualifier 注解一起使用。<br>（2）@Resource<br>@Resource 默认按照 ByName 自动注入，由 J2EE 提供，需要导入包<br>javax.annotation.Resource。@Resource 有两个重要的属性：name 和 type，而 Spring 将<br>@Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以，如<br>果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入<br>策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。<br>4、@Controller 和@RestController 的区别？<br>考察点：spring<br>参考回答：<br>@RestController 注解相当于@ResponseBody ＋ @Controller 合在一起的作用<br>2、Struts 拦截器和 Spring AOP 区别？<br>考察点：框架<br>参考回答：<br>拦截器是 AOP 的一种实现，struts2 拦截器采用 xwork2 的 interceptor！而 spring 的 AOP<br>基于 IoC 基础,其底层采用动态代理与 CGLIB 代理两种方式结合的实现方式。<br>4、选择使用 Spring 框架的原因（Spring 框架为企业级开发带来的好处有哪些）？<br>考察点：框架<br>参考回答：<br>NOWCODER.COM</li><li>非侵入式：支持基于 POJO 的编程模式，不强制性的要求实现 Spring 框架中的接口或继承<br>Spring 框架中的类。</li><li>IoC 容器：IoC 容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如<br>果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建<br>和完整的回归测试。有了 IoC 容器，程序员再也不需要自己编写工厂、单例，这一点特别符合<br>Spring 的精神”不要重复的发明轮子”。</li><li>AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将<br>横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，<br>有了 AOP 程序员可以省去很多自己写代理类的工作。</li><li>MVC：Spring 的 MVC 框架为 Web 表示层提供了更好的解决方案。</li><li>事务管理：Spring 以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，<br>在不需要任何一行代码的情况下就能够完成事务管理。</li><li>其他：选择 Spring 框架的原因还远不止于此，Spring 为 Java 企业级开发提供了一站式选择，<br>你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到 Spring 存在的情<br>况下，在你的项目中使用 Spring 提供的各种优秀的功能。 ④Spring，JPA 整合<br>1、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？<br>考察点：框架<br>参考回答：<br>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中<br>的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统<br>中专注于实现数据持久化的相对独立的层面。<br>持久层设计的目标包括：</li><li>数据存储逻辑的分离，提供抽象化的数据访问接口。</li><li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。</li><li>资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。</li><li>数据抽象，提供更面向对象的数据操作。<br>持久层框架有：</li><li>Hibernate</li><li>MyBatis</li><li>TopLink</li><li>Guzz</li><li>jOOQ</li><li>Spring Data</li><li>ActiveJDBC<br>NOWCODER.COM<br>2、Hibernate<br>①ORM 与持久化映射<br>1、阐述实体对象的三种状态以及转换关系。<br>考察点：JAVA 实体<br>参考回答：<br>最新的 Hibernate 文档中为 Hibernate 对象定义了四种状态（原来是三种状态，面试的时候<br>基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or<br>persistent）、游状态（detached）和移除态（removed，以前 Hibernate 文档中定义的三种状<br>态中没有移除态），如下图所示，就以前的 Hibernate 文档中移除态被视为是瞬时态。<br>瞬时态：当 new 一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数<br>据的内存区域，如果没有变量引用这个对象，则会被 JVM 的垃圾回收机制回收。这个对象所保存<br>的数据与数据库没有任何关系，除非通过 Session 的 save()、saveOrUpdate()、persist()、merge()<br>方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对<br>象。<br>持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态<br>对象进行 delete 操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存<br>在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上<br>同步到数据库，直到数据库事务提交。<br>游离态：当 Session 进行了 close()、clear()、evict()或 flush()后，实体对象从持久态变成<br>游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除<br>掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象<br>是十分相似的，只是它还含有持久化标识。 ②延迟加载、性能优化<br>1、Hibernate 中 SessionFactory 是线程安全的吗？Session 是线程安全的吗（两<br>个线程能够共享同一个 Session 吗）？<br>考察点：session<br>参考回答：<br>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线<br>程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将<br>SessionFactory 通过单例模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象<br>（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。Session 是由<br>SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接<br>口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的<br>session，可以使用 ThreadLocal 将 session 和当前线程绑定在一起，这样可以让同一个线程获<br>得的总是同一个 session。Hibernate 3 中 SessionFactory 的 getCurrentSession()方法就可以<br>做到。<br>NOWCODER.COM<br>2、Hibernate 中 Session 的 load 和 get 方法的区别是什么？<br>考察点：请求方式<br>参考回答：<br>主要有以下三项区别：<br>① 如果没有找到符合条件的记录，get 方法返回 null，load 方法抛出异常。<br>② get 方法直接返回实体类对象，load 方法返回实体类对象的代理。<br>③ 在 Hibernate 3 之前，get 方法只在一级缓存中进行数据查找，如果没有找到对应的数据则<br>越过二级缓存，直接发出 SQL 语句完成数据读取；load 方法则可以从二级缓存中获取数据；从<br>Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。<br>对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加<br>载，如果没有数据就抛出异常，而通过 get()方法获取的数据可以不存在。<br>3、如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session<br>关闭的矛盾是如何处理的？<br>考察点：hibernate 框架<br>参考回答：<br>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate<br>使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load()方法加载数据或者一对多关联<br>映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给<br>用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据<br>库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。<br>延迟加载与 session 关闭的矛盾一般可以这样处理：<br>① 关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通<br>过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or<br>session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询<br>的开销都会变得很大。<br>② 在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized()<br>判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize()方法加载对象。<br>③ 使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提<br>供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。<br>4、简述 Hibernate 常见优化策略。<br>考察点：Hibernate<br>参考回答：<br>①制定合理的缓存策略（二级缓存、查询缓存）。<br>② 采用合理的 Session 管理机制。<br>③ 尽量使用延迟加载特性。<br>④ 设定合理的批处理参数。<br>⑤ 如果可以，选用 UUID 作为主键生成器。<br>⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。<br>⑦ 在开发过程中, 开启 hibernate.show_sql 选项查看生成的 SQL，从而了解底层的状况；开发<br>完成后关闭此选项。<br>NOWCODER.COM<br>⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观<br>的提升，但这些需要专业的 DBA（数据库管理员）提供支持。<br>5、锁机制有什么用？简述 Hibernate 的悲观锁和乐观锁机制。<br>考察点：锁<br>参考回答：<br>有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此<br>过程中数据被锁住不会被外界修改，这就是所谓的锁机制。<br>Hibernate 支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极<br>有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理<br>的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，<br>乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过<br>更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐<br>观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加 1，<br>然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的<br>当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate 中通过 Session 的 get()和<br>load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加<br>整型的版本字段再通过 XML 或@Version 注解进行配置。<br>使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了<br>空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间<br>换时间的策略。 ③HQL 查询、条件查询、SQL 查询<br>1、Hibernate 如何实现分页查询？<br>考察点：框架<br>参考回答：<br>通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()<br>方法）或查询条件（调用 Session 的 createCriteria()方法）、设置查询起始行数（调用 Query<br>或 Criteria 接口的 setFirstResult()方法）和最大查询行数（调用 Query 或 Criteria 接口的<br>setMaxResults()方法），并调用 Query 或 Criteria 接口的 list()方法，Hibernate 会自动生成<br>分页查询的 SQL 语句。 ④二级缓存与查询缓存<br>1、谈一谈 Hibernate 的一级缓存、二级缓存和查询缓存。<br>考察点：缓存<br>参考回答：<br>NOWCODER.COM<br>Hibernate 的 Session 提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实<br>体、修改持久化实体时，Session 并不会立即把这种改变提交到数据库，而是缓存在当前的<br>Session 中，除非显示调用了 Session 的 flush()方法或通过 close()方法关闭 Session。通过一<br>级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。<br>SessionFactory 级别的二级缓存是全局性的，所有的 Session 可以共享这个二级缓存。不过二<br>级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供<br>的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory 就会缓<br>存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。<br>一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓<br>存，可以使用查询缓存。查询缓存是将 HQL 或 SQL 语句以及它们的查询结果作为键值对进行缓存，<br>对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。<br>3、Struts<br>①MVC 模式与 Struts 体系<br>1、说说 STRUTS 的应用<br>考察点：STRUTS 架构<br>参考回答：<br>Struts 是采用 Java Servlet&#x2F;JavaServer Pages 技术，开发 Web 应用程序的开放源码的<br>framework。采用 Struts 能开发出基于 MVC(Model-View-Controller)设计模式的应用构架。<br>Struts 有如下的主要功能：<br>包含一个 controller servlet，能将用户的请求发送到相应的 Action 对象。二.JSP 自由<br>tag 库，并且在 controller servlet 中提供关联支持，帮助开发员创建交互式表单应用。<br>提供了一系列实用对象：XML 处理、通过 Java reflection APIs 自动处理 JavaBeans 属性、<br>国际化的提示和消息。<br>4、Mybatis<br>1、解释一下 MyBatis 中命名空间（namespace）的作用。<br>考察点：Mybatis<br>参考回答：<br>在大型项目中，可能存在大量的 SQL 语句，这时候为每个 SQL 语句起一个唯一的标识（ID）<br>就变得并不容易了。为了解决这个问题，在 MyBatis 中，可以为每个映射文件起一个唯一的命名<br>空间，这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只<br>要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不<br>会再产生冲突了。<br>NOWCODER.COM<br>2、MyBatis 中的动态 SQL 是什么意思？<br>考察点：SQL<br>参考回答：<br>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，<br>需要根据用户指定的条件动态生成 SQL 语句。如果不使用持久层框架我们可能需要自己拼装 SQL<br>语句，还好 MyBatis 提供了动态 SQL 的功能来解决这个问题。MyBatis 中用于实现动态 SQL 的元<br>素主要有：</li><li>if</li><li>choose &#x2F; when &#x2F; otherwise</li><li>trim</li><li>where</li><li>set</li><li>foreach<br>5、MVC<br>1、Spring MVC 注解的优点<br>考察点：spring mvc<br>参考回答：<br>1、XML 配置起来有时候冗长，此时注解可能是更好的选择，如 jpa 的实体映射；注解在处<br>理一些不变的元数据时有时候比 XML 方便的多，比如 springmvc 的数据绑定，如果用 xml 写的代<br>码会多的多；<br>2、注解最大的好处就是简化了 XML 配置；其实大部分注解一定确定后很少会改变，所以在<br>一些中小项目中使用注解反而提供了开发效率，所以没必要一头走到黑；<br>3、注解相对于 XML 的另一个好处是类型安全的，XML 只能在运行期才能发现问题。<br>2、springmvc 和 spring-boot 区别？<br>考察点：spring<br>参考回答：<br>总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA 等等。但<br>他们的基础都是 Spring 的 IOC 和 AOP，IOC 提供了依赖注入的容器，而 AOP 解决了面向切面的<br>编程，然后在此两者的基础上实现了其他衍生产品的高级功能；因为 Spring 的配置非常复杂，<br>各种 xml，properties 处理起来比较繁琐。于是为了简化开发者的使用，Spring 社区创造性地<br>推出了 Spring Boot，它遵循约定优于配置，极大降低了 Spring 使用门槛，<br>但又不失 Spring 原本灵活强大的功能。<br>3、SpringMVC 的运行机制，运行机制的每一部分的相关知识？<br>考察点：spring<br>NOWCODER.COM<br>参考回答：<br>1、用户发送请求时会先从 DispathcherServler 的 doService 方法开始，在该方法中会将<br>ApplicationContext、localeResolver、themeResolver 等对象添加到 request 中，紧接着就是<br>调用 doDispatch 方法。<br>2、进入该方法后首先会检查该请求是否是文件上传的请求(校验的规则是是否是 post 并且<br>contenttType 是否为 multipart&#x2F;为前缀)即调用的是 checkMultipart 方法；如果是的将 request<br>包装成 MultipartHttpServletRequest。<br>3、然后调用 getHandler 方法来匹配每个 HandlerMapping 对象，如果匹配成功会返回这个<br>Handle 的处理链 HandlerExecutionChain 对象，在获取该对象的内部其实也获取我们自定定义<br>的拦截器，并执行了其中的方法。<br>4、执行拦截器的 preHandle 方法，如果返回 false 执行 afterCompletion 方法并理解返回<br>5、通过上述获取到了 HandlerExecutionChain 对象，通过该对象的 getHandler()方法获得<br>一个 object 通过 HandlerAdapter 进行封装得到 HandlerAdapter 对象。<br>6、该对象调用 handle 方法来执行 Controller 中的方法，该对象如果返回一个 ModelAndView 给 DispatcherServlet。<br>7、DispatcherServlet借助ViewResolver完成逻辑试图名到真实视图对象的解析，得到View 后 DispatcherServlet 使用这个 View 对 ModelAndView 中的模型数据进行视图渲染。</li></ul><p>6、各框架对比与项目优化<br>1、Mybatis 和 Hibernate 区别？<br>NOWCODER.COM<br>考察点：Spring 框架<br>参考回答：1. 简介<br>Hibernate：Hibernate 是当前最流行的 ORM 框架之一，对 JDBC 提供了较为完整的封装。<br>Hibernate 的 O&#x2F;R Mapping 实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。<br>Mybatis：Mybatis 同样也是非常流行的 ORM 框架，主要着力点在于 POJO 与 SQL 之间的映<br>射关系。然后通过映射配置文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO 。<br>相对 Hibernate“O&#x2F;R”而言，Mybatis 是一种“Sql Mapping”的 ORM 实现。<br>2、缓存机制对比<br>相同点<br>Hibernate 和 Mybatis 的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己<br>的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。<br>不同点<br>Hibernate 的二级缓存配置在 SessionFactory 生成的配置文件中进行详细配置，然后再在<br>具体的表-对象映射中配置是那种缓存。<br>MyBatis 的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的<br>表可以自定义不同的缓存机制。并且 Mybatis 可以在命名空间中共享相同的缓存配置和实例，通<br>过 Cache-ref 来实现。<br>两者比较<br>因为 Hibernate 对查询对象有着良好的管理机制，用户无需关心 SQL。所以在使用二级缓存<br>时如果出现脏数据，系统会报出错误并提示。而 MyBatis 在这一方面，使用二级缓存时需要特别<br>小心。如果不能完全确定数据更新操作的波及范围，避免 Cache 的盲目使用。否则，脏数据的出<br>现会给系统的正常运行带来很大的隐患。<br>Mybatis：小巧、方便、高效、简单、直接、半自动化<br>Hibernate：强大、方便、高效、复杂、间接、全自动化<br>2、介绍一下你了解的 Java 领域的 Web Service 框架。<br>考察点：框架<br>参考回答：<br>Java 领域的 Web Service 框架很多，包括 Axis2（Axis 的升级版本）、Jersey（RESTful<br>的 Web Service 框架）、CXF（XFire 的延续版本）、Hessian、Turmeric、JBoss SOA 等，其中<br>绝大多数都是开源框架。<br>NOWCODER.COM<br>7、JPA<br>①EJB<br>1、EJB 是基于哪些技术实现的？并说出 SessionBean 和 EntityBean 的区别，<br>StatefulBean 和 StatelessBean 的区别。<br>考察点：JAVA EJB<br>参考回答：<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技<br>术实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用<br>其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象<br>视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种<br>的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的<br>实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是<br>说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会<br>消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者<br>的状态。<br>2、EJB 与 JAVA BEAN 的区别？<br>考察点：EJB<br>参考回答：<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java<br>类都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所以<br>Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于<br>实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，它是不<br>能被跨进程访问的。EnterpriseJava Bean 相当于 DCOM，即分布式组件。它是基于 Java 的远程<br>方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。但 EJB 必须被布署<br>在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正的 EJB 组件，而是通过<br>其容器访问。EJB 容器是 EJB 组件的代理， EJB 组件由容器所创建和管理。客户通过容器来访问<br>真正的 EJB 组件。<br>3、EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事<br>务的？<br>考察点：JAVA EJB<br>NOWCODER.COM<br>参考回答：<br>SessionBean： Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求<br>要建立一个 Bean 的实例时，EJB 容器不一定<br>要创建一个新的 Bean 的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户<br>机第一次调用一个 Stateful Session<br>Bean 时，容器必须立即在服务器中创建一个新的 Bean 实例，并关联到客户机上，以后此客户机<br>调用 Stateful Session Bean 的方法<br>时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不<br>是按照应用程序或者服务进程来说的。即使 EJB 容器崩溃了，Entity beans 也是存活的。Entity<br>Beans 生命周期能够被容器或者<br>Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、<br>Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。<br>4、EJB 的角色和三个对象是什么？<br>考察点：EJB<br>参考回答：<br>一个完整的基于 EJB 的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提<br>供，每个角色所作的工作必须遵循 Sun 公司<br>提供的 EJB 规范，以保证彼此之间的兼容性。这六个角色分别是 EJB 组件开发者（Enterprise Bean<br>Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供<br>者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System<br>Administrator）<br>三个对象是 Remote（Local）接口、Home（LocalHome）接口，Bean 类<br>5、说说 EJB 规范规定 EJB 中禁止的操作有哪些？<br>考察点：EJB<br>参考回答：<br>1.不能操作线程和线程 API(线程 API 指非线程对象的方法如 notify,wait 等)，<br>2.不能操作 awt，<br>3.不能实现服务器功能，<br>4.不能对静态属生存取，<br>5.不能使用 IO 操作直接存取文件系统，<br>6.不能加载本地库.，<br>7.不能将 this 作为变量和返回，<br>NOWCODER.COM<br>8.不能循环调用。<br>6、EJB 的激活机制是什么？<br>考察点：EJB<br>参考回答：<br>以 Stateful Session Bean 为例：其 Cache 大小决定了内存中可以同时存在的 Bean 实例的<br>数量，根据 MRU 或 NRU 算法，实例在激活和去<br>激活状态之间迁移，激活机制是当客户端调用某个 EJB 实例业务方法时，如果对应 EJB Object<br>发现自己没有绑定对应的 Bean 实例则从<br>其去激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。<br>7、EJB 的几种类型分别是什么<br>考察点：EJB<br>参考回答：<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean，会话<br>Bean 又可分为有状态（Stateful）和无状态（Stateless）两种，<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种。<br>8、EJB 需直接实现它的业务接口或 Home 接口吗，请简述理由。<br>考察点：EJB<br>参考回答：<br>在 EJB 中则至少要包括 10 个 class:<br>Bean 类，特定 App Server 的 Bean 实现类 Bean 的 remote 接口，特定 App Server 的 remote 接<br>口实现类，特定 App Server 的 remote 接口的实现类的 stub 类和 skeleton 类。<br>Bean 的 home 接口，特定 App Server 的 home 接口实现类，特定 App Server 的 home 接口的实现<br>类的 stub 类和 skeleton 类。<br>和 RMI 不同的是，EJB 中这 10 个 class 真正需要用户写的只有 3 个，Bean 类，remote 接口，home<br>接口，其它的 7 个究竟怎么生成，被打包在哪里，是否需要更多的类文件，否根据不同的 App<br>Server 表现出较大的差异。<br>Weblogic：<br>home 接口和 remote 接口的 weblogic 的实现类的 stub 类和 skeleton 类是在 EJB 被部署到<br>weblogic 的时候，由 weblogic 动态生成 stub 类和 skeleton 类的字节码，所以看不到这 4 个类<br>文件。<br>对于一次客户端远程调用 EJB，要经过两个远程对象的多次 RMI 循环。首先是通过 JNDI 查找 Home<br>接口，获得 Home 接口的实现类，这个过程其实相当复杂，首先是找到 Home 接口的 Weblogic 实<br>现类，然后创建一个 Home 接口的 Weblogic 实现类的 stub 类的对象实例，将它序列化传送给客<br>户端（注意 stub 类的实例是在第 1 次 RMI 循环中，由服务器动态发送给客户端的，因此不需要<br>客户端保存 Home 接口的 Weblogic 实现类的 stub 类），最后客户端获得该 stub 类的对象实例<br>（普通的 RMI 需要在客户端保存 stub 类，而 EJB 不需要，因为服务器会把 stub 类的对象实例发<br>送给客户端）。<br>客户端拿到服务器给它的 Home 接口的 Weblogic 实现类的 stub 类对象实例以后，调用 stub 类的<br>NOWCODER.COM<br>create 方法， (在代码上就是 home.create()，但是后台要做很多事情),于是经过第 2 次 RMI<br>循环，在服务器端，Home 接口的 Weblogic 实现类的 skeleton 类收到 stub 类的调用信息后，由<br>它再去调用 Home 接口的 Weblogic 实现类的 create 方法。<br>在服务端， Home 接口的 Weblogic 实现类的 create 方法再去调用 Bean 类的 Weblogic 实现类的<br>ejbCreate 方法，在服务端创建或者分配一个 EJB 实例，然后将这个 EJB 实例的远程接口的<br>Weblogic 实现类的 stub 类对象实例序列化发送给客户端。 三、Java web 编程<br>1、web 编程基础<br>①Tomcat 服务器<br>1、启动项目时如何实现不在链接里输入项目名就能启动?<br>考察点：tomcat<br>参考回答：<br>可在 taomcat 配置虚拟目录。<br>2、1 分钟之内只能处理 1000 个请求，你怎么实现，手撕代码?<br>考察点：tomcat<br>参考回答：<br>限流的几种方法：计数器，滑动窗口、漏桶法、令牌桶<br>3、什么时候用 assert<br>考察点：JAVA 调试<br>参考回答：<br>assertion (断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。<br>在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的<br>状态下，系统将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正确性。<br>assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常<br>是关闭的。<br>4、JAVA 应用服务器有那些？<br>考察点：服务器<br>参考回答：<br>NOWCODER.COM<br>BEA WebLogic Server，<br>IBM WebSphere Application Server，<br>Oracle9i Application Server<br>jBoss，<br>Tomcat<br>5、说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的<br>helloWorld.jsp 放入何目录下,然后在浏览器上就可打入主机？<br>考察点：目录结构<br>参考回答：<br>端口号&#x2F;&#x2F;helloword.jsp 就可以看到运行结果了? 又比如这其中用到了一个自己写的<br>javaBean 该如何办?<br>NOWCODER.COM<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果是<br>Web 应用，应用目录需要满足 Web 应用<br>目录要求，jsp 文件可以直接放在应用目录中，Javabean 需要放在应用目录的 WEB-INF 目录的<br>classes 目录中，设置服务器的缺省应用<br>将可以实现在浏览器上无需输入应用名。<br>6、jsp 有哪些动作?作用分别是什么?<br>考察点：JSP<br>参考回答：<br>JSP 共有以下 6 种基本动作 jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>jsp:setProperty：设置 JavaBean 的属性。 jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。<br>8、说一下表达式语言（EL）的隐式对象及其作用<br>考察点：EL<br>NOWCODER.COM<br>参考回答：<br>EL 的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、<br>paramValues、header（访问请求头）、headerValues、cookie（访问 cookie）、applicationScope<br>（访问 application 作用域）、sessionScope（访问 session 作用域）、requestScope（访问 request<br>作用域）、pageScope（访问 page 作用域）。<br>9、JSP 中的静态包含和动态包含有什么区别？<br>考察点：JSP<br>参考回答：<br>静态包含是通过 JSP 的 include指令包含页面，动态包含是通过 JSP 标准动作<a href="jsp:forward">jsp:forward</a><br>包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的<br>“contentType”属性应保持一致，因为两个页面会合二为一，只产生一个 class 文件，因此被包<br>含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含<br>的页面传递参数，包含页面和被包含页面是独立的，会编译出两个 class 文件，如果被包含的页<br>面不存在，不会产生编译错误，也不影响页面其他部分的执行。<br>例如：&lt;%– 静态包含 –%&gt;<br>&lt;%@ include file&#x3D;”…” %&gt;<br>&lt;%– 动态包含 –%&gt;<br>&lt;jsp:include page&#x3D;”…”&gt;<br>&lt;jsp:param name&#x3D;”…” value&#x3D;”…” &#x2F;&gt;<br>&lt;&#x2F;jsp:include&gt;<br>③Listener 和 Filter<br>1、过滤器有哪些作用和用法？<br>考察点：过滤器<br>参考回答：<br>Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在 Servlet<br>2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web 组件，它可以截取<br>客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当 Web 容器接受到一个对资源<br>的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进<br>行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发<br>送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器<br>中你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、<br>对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求<br>或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT 等。<br>和过滤器相关的接口主要有：Filter、FilterConfig 和 FilterChain。<br>3、说说 web.xml 文件中可以配置哪些内容？<br>考察点：xml 文件<br>参考回答：<br>web.xml 用于配置 Web 应用的相关信息，如：监听器（listener）、过滤器（filter）、Servlet、<br>相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：<br>①配置 Spring 上下文加载监听器加载 Spring 配置文件并创建 IoC 容器：<br>&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; &lt;listener&gt; &lt;listener-class&gt;<br>org.springframework.web.context.ContextLoaderListener &lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt;<br>②配置 Spring 的 OpenSessionInView 过滤器来解决延迟加载和 Hibernate 会话关闭的矛盾： &lt;filter&gt; &lt;filter-name&gt;openSessionInView&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;<br>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter &lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;<br>NOWCODER.COM<br>③配置会话超时时间为 10 分钟： &lt;session-config&gt; &lt;session-timeout&gt;10&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt;<br>④配置 404 和 Exception 的错误页面： &lt;error-page&gt; &lt;error-code&gt;404&lt;&#x2F;error-code&gt; &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;&#x2F;exception-type&gt; &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt;<br>⑤配置安全认证方式： &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;ProtectedArea&lt;&#x2F;web-resource-name&gt; &lt;url-pattern&gt;&#x2F;admin&#x2F;<em>&lt;&#x2F;url-pattern&gt; &lt;http-method&gt;GET&lt;&#x2F;http-method&gt; &lt;http-method&gt;POST&lt;&#x2F;http-method&gt; &lt;&#x2F;web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;&#x2F;role-name&gt; &lt;&#x2F;auth-constraint&gt; &lt;&#x2F;security-constraint&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;&#x2F;auth-method&gt; &lt;&#x2F;login-config&gt; &lt;security-role&gt; &lt;role-name&gt;admin&lt;&#x2F;role-name&gt; &lt;&#x2F;security-role&gt;<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>1、forward 与 redirect 区别，说一下你知道的状态码，redirect 的状态码是多<br>少？<br>考察点：Servlet<br>参考回答：<br>1.从地址栏显示来说<br>NOWCODER.COM<br>forward 是服务器请求资源,服务器直接访问目标地址的 URL,把那个 URL 的响应内容读取过<br>来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地<br>址栏还是原来的地址.<br>redirect 是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址<br>栏显示的是新的 URL.<br>2.从数据共享来说<br>forward:转发页面和转发到的页面可以共享 request 里面的数据.<br>redirect:不能共享数据.<br>3.从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.<br>4.从效率来说<br>forward:高.<br>redirect:低.<br>redirect 的状态码是 302<br>2、servlet 生命周期，是否单例，为什么是单例。<br>考察点：servlet<br>参考回答：<br>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：<br>Servlet 通过调用 init () 方法进行初始化。<br>Servlet 调用 service() 方法来处理客户端的请求。<br>Servlet 通过调用 destroy() 方法终止（结束）。<br>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。<br>Servlet 单实例，减少了产生 servlet 的开销；<br>3、说出 Servlet 的生命周期，并说出 Servlet 和 CGI 的区别。<br>考察点：servlet<br>参考回答：<br>NOWCODER.COM<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，<br>service 方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实<br>例销毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个实<br>例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，服务完<br>成后就销毁，所以效率上低于 servlet。<br>4、Servlet 执行时一般实现哪几个方法？<br>考察点：servlet<br>参考回答：<br>public void init(ServletConfig config)<br>public ServletConfig getServletConfig()<br>public String getServletInfo()<br>public void service(ServletRequest request,ServletResponse response)<br>public void destroy()<br>init ()方法在 servlet 的生命周期中仅执行一次，在服务器装载 servlet 时执行。缺省的 init()<br>方法通常是符合要求的，不过也可以根据需要进行 override，比如管理服务器端资源，一次性<br>装入 GIF 图像，初始化数据库连接等，缺省的 inti()方法设置了 servlet 的初始化参数，并用<br>它的 ServeltConfig 对象参数来启动配置，所以覆盖 init()方法时，应调用 super.init()以确<br>保仍然执行这些任务。service ()方法是 servlet 的核心，在调用 service()方法之前，应确保<br>已完成 init()方法。对于 HttpServlet，每当客户请求一个 HttpServlet 对象，该对象的 service()<br>方法就要被调用，HttpServlet 缺省的 service()方法的服务功能就是调用与 HTTP 请求的方法<br>相应的 do 功能，doPost()和 doGet()，所以对于 HttpServlet，一般都是重写 doPost()和 doGet()<br>方法。destroy()方法在 servlet 的生命周期中也仅执行一次，即在服务器停止卸载 servlet 时<br>执行，把 servlet 作为服务器进程的一部分关闭。缺省的 destroy()方法通常是符合要求的，但<br>也可以 override，比如在卸载 servlet 时将统计数字保存在文件中，或是关闭数据库连接<br>getServletConfig()方法返回一个 servletConfig 对象，该对象用来返回初始化参<br>servletContext。servletContext 接口提供有关 servlet 的环境信息。getServletInfo()方法<br>提供有关 servlet 的信息，如作者，版本，版权。<br>5、阐述一下阐述 Servlet 和 CGI 的区别?<br>考察点：servlet<br>参考回答：<br>Servlet与 CGI 的区别在于 Servlet 处于服务器进程中，它通过多线程方式运行其 service()<br>方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的<br>进程，服务完成后就销毁，所以效率上低于 Servlet。<br>6、说说 Servlet 接口中有哪些方法？<br>考察点：Servlet 接口<br>参考回答：<br>NOWCODER.COM<br>Servlet 接口定义了 5 个方法，其中前三个方法与 Servlet 生命周期相关：</em> void init(ServletConfig config) throws ServletException</p><ul><li>void service(ServletRequest req, ServletResponse resp) throws ServletException,<br>java.io.IOException</li><li>void destory()</li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()<br>Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init()方法进行<br>Servlet 的初始化；请求到达时调用 Servlet 的 service()方法，service()方法会根据需要调用<br>与请求对应的 doGet 或 doPost 等方法；当服务器关闭或项目被卸载时服务<br>器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy()方法。<br>7、Servlet 3 中的异步处理指的是什么？<br>考察点：servlet<br>参考回答：<br>在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然<br>都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那<br>么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将<br>会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝<br>服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行<br>时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交<br>给 Executor 并立即返回即可。</li></ul><p>8、如何在基于 Java 的 Web 项目中实现文件上传和下载？<br>考察点：文件传输<br>参考回答：<br>在 Sevlet 3 以前，Servlet API 中没有支持上传功能的 API，因此要实现上传功能需要引<br>入第三方工具从 POST 请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们<br>推荐使用 Apache 的 commons-fileupload。<br>从 Servlet 3 开始，文件上传变得简单许多。</p><p>9、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()<br>方法？<br>考察点：servlet<br>参考回答：<br>HTML 的&lt;form&gt;元素有一个 method 属性，用来指定提交表单的方式，其值可以是 get 或 post。<br>我们自定义的 Servlet 一般情况下会重写 doGet()或 doPost()两个方法之一或全部，如果是 GET<br>请求就调用 doGet()方法，如果是 POST 请求就调用 doPost()方法，那为什么为什么这样呢？我<br>们自定义的 Servlet 通常继承自 HttpServlet，HttpServlet 继承自 GenericServlet 并重写了其<br>中的 service()方法，这个方法是 Servlet 接口中定义的。HttpServlet 重写的 service()方法<br>会先获取用户请求的方法，然后根据请求方法调用 doGet()、doPost()、doPut()、doDelete()<br>等方法，如果在自定义 Servlet 中重写了这些方法，那么显然会调用重写过的（自定义的）方法，<br>这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java 与模式》一书的第 37<br>章）。当然，自定义 Servlet 中也可以直接重写 service()方法，那么不管是哪种方式的请求，<br>都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。<br>10、Servlet 中如何获取用户提交的查询参数或表单数据？<br>考察点：servlet<br>参考回答：<br>可以通过请求对象（HttpServletRequest）的 getParameter()方法通过参数名获得参数值。<br>如果有包含多个值的参数（例如复选框），可以通过请求对象的 getParameterValues()方法获<br>得。当然也可以通过请求对象的 getParameterMap()获得一个参数名和参数值的映射（Map）。<br>11、Servlet 中如何获取用户配置的初始化参数以及服务器上下文参数？<br>考察点：初始化<br>参考回答：<br>可以通过重写 Servlet 接口的 init(ServletConfig)方法并通过 ServletConfig 对象的<br>getInitParameter()方法来获取 Servlet 的初始化参数。可以通过 ServletConfig 对象的<br>getServletContext()方法获取 ServletContext 对象，并通过该对象的 getInitParameter()方<br>法来获取服务器上下文参数。当然，ServletContext 对象也在处理用户请求的方法（如 doGet()<br>方法）中通过请求对象的 getServletContext()方法来获得。<br>NOWCODER.COM</p><p>3、请问 Java Web 开发的 Model 1 和 Model 2 分别指的是什么？<br>考察点：Model<br>参考回答：<br>Model 1 是以页面为中心的 Java Web 开发，使用 JSP+JavaBean 技术将页面显示逻辑和业务<br>逻辑处理分开，JSP 实现页面显示，JavaBean 对象用来保存数据和实现业务逻辑。Model 2 是基<br>于 MVC（模型-视图-控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视<br>图的彻底分离，利于团队开发和代码复用。 ④JSTL、DisplayTag 等常见标签库的用法<br>1、你的项目中使用过哪些 JSTL 标签？<br>考察点：JSTL<br>参考回答：<br>项目中主要使用了 JSTL 的核心标签库，包括&lt;c:if&gt;、&lt;c:choose&gt;、&lt;c: when&gt;、&lt;c: otherwise&gt;、<br>&lt;c:forEach&gt;等，主要用于构造循环和分支结构以控制显示逻辑。<br>虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库，但是实际开发中建议只使用核心<br>标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到<br>数据显示和业务逻辑的分离，这才是最佳实践。<br>2、使用标签库有什么好处？如何自定义 JSP 标签？（JSP 标签）<br>考察点：JSP 标签<br>参考回答：<br>使用标签库的好处包括以下几个方面：</p><ul><li>分离 JSP 页面的内容和逻辑，简化了 Web 开发；</li><li>开发者可以创建自定义标签来封装业务逻辑和显示逻辑；</li><li>标签具有很好的可移植性、可维护性和可重用性；</li><li>避免了对 Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在 JSP 中书写小脚本）<br>编写一个 Java 类实现实现 Tag&#x2F;BodyTag&#x2F;IterationTag 接口（开发中通常不直接实现这些<br>接口而是继承 TagSupport&#x2F;BodyTagSupport&#x2F;SimpleTagSupport 类，这是对缺省适配模式的应用），<br>重写 doStartTag()、doEndTag()等方法，定义标签要完成的功能：<br>NOWCODER.COM</li><li>编写扩展名为 tld 的标签描述文件对自定义标签进行部署，tld 文件通常放在 WEB-INF 文件夹<br>下或其子目录中</li><li>在 JSP 页面中使用 taglib 指令引用该标签库<br>3、Web 编程原理<br>①HTTP 协议<br>1、get 和 post 区别？<br>考察点：HTTP 请求<br>参考回答：<br>（1）在客户端， Get 方式在通过 URL 提交数据，数据 在 URL 中可以看到；POST 方式，数据<br>放置在 HTML HEADER 内提交。<br>（2）GET 方式提交的数据最多只能有 1024 字节，而 POST 则没有此限制。<br>（3）安全性问题。正如在（ 1 ）中提到，使用 Get 的时候，参数会显示在地址栏上，<br>而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get ；如果<br>用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post 为好。<br>安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同<br>一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，<br>GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从<br>自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的<br>一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。<br>POST 请求就不那么轻松了。 POST 表示可能改变服务器上的资源的请求。仍然以新闻站点<br>为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比<br>方说文章下面出现一条注解）。</li></ul><p>3、BS 与 CS 的联系与区别。<br>考察点：客户端&#x2F;服务器模式<br>NOWCODER.COM<br>参考回答：<br>C&#x2F;S 是 Client&#x2F;Server 的缩写。服务器通常采用高性能的 PC、工作站或小型机，并采用大型<br>数据库系统，如 Oracle、Sybase、Informix 或 SQL Server。客户端需要安装专用的客户端软件。<br>B&#x2F;Ｓ是 Brower&#x2F;Server 的缩写，客户机上只要安装一个浏览器（Browser），如 Netscape Navigator<br>或 Internet Explorer，服务器安<br>装 Oracle、Sybase、Informix 或 SQL Server 等数据库。在这种结构下，用户界面完全通过 WWW<br>浏览器实现，一部分事务逻辑在前端实<br>现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C&#x2F;S 与 B&#x2F;S 区别：<br>硬件环境不同:<br>C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供<br>连接和数据交换服务.<br>B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自<br>己管理. 有比 C&#x2F;S 更强的适应范围, 一<br>般只要有操作系统和浏览器就行<br>２．对安全要求不同<br>C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统<br>采用 C&#x2F;S 结构适宜. 可以通过 B&#x2F;S 发布<br>部分可公开信息.<br>B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同<br>C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.<br>B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比 C&#x2F;S 有更高<br>的要求 B&#x2F;S 结构的程序架构是发展的趋<br>势, 从 MS 的.Net 系列的 BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN<br>和 IBM 推的 JavaBean 构件技术等,使<br>B&#x2F;S 更加成熟. ４．软件重用不同<br>C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在 B&#x2F;S 要求下的构件的重用性好.<br>B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以<br>再利用,而不是做在墙上的石头桌子<br>５．系统维护不同<br>C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再<br>做一个全新的系统<br>B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从<br>网上自己下载安装就可以实现升级. ６．处理问题不同<br>C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应<br>该都是相同的系统<br>B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是 C&#x2F;S 无法作到的. 与操作系统<br>平台关系最小. ７．用户接口不同<br>C&#x2F;S 多是建立的 Window 平台上,表现方法有限,对程序员普遍要求较高<br>B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减<br>低开发成本. ８．信息流不同<br>C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低<br>B&#x2F;S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。<br>NOWCODER.COM<br>4、如何设置请求的编码以及响应内容的类型？<br>考察点：请求类型<br>参考回答：<br>通过请求对象（ServletRequest）的 setCharacterEncoding(String)方法可以设置请求的<br>编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java 程序都使用统一的<br>编码，最好的选择当然是 UTF-8；通过响应对象（ServletResponse）的 setContentType(String)<br>方法可以设置响应内容的类型，当然也可以通过 HttpServletResponsed 对象的<br>setHeader(String, String)方法来设置。<br>5、什么是 Web Service（Web 服务）？<br>考察点：web service<br>参考回答：<br>从表面上看，Web Service 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用<br>的 API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，<br>跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的 Web Service，那么无论你<br>用哪种编程语言开发的应用都可以通过调用它的 API 并传入城市信息来获得该城市的天气预报。<br>之所以称之为 Web Service，是因为它基于 HTTP 协议传输数据，这使得运行在不同机器上的不<br>同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。<br>SOA（Service-Oriented Architecture，面向服务的架构），SOA 是一种思想，它将应用程<br>序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种<br>形式的功能单元能够更好的集成。显然，Web Service 是 SOA 的一种较好的解决方案，它更多的<br>是一种标准，而不是一种具体的技术。<br>6、谈谈 Session 的 save()、update()、merge()、lock()、saveOrUpdate()和<br>persist()方法分别是做什么的？有什么区别？<br>考察点：session<br>参考回答：<br>Hibernate 的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态<br>（detached），如第 135 题中的图所示。瞬时态的实例可以通过调用 save()、persist()或者<br>saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()<br>或者 replicate()变成持久态。save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()<br>或 merge()会引发 UPDATE 语句。save()和 update()的区别在于一个是将瞬时态对象变成持久态，<br>一个是将游离态对象变为持久态。merge()方法可以完成 save()和 update()方法的功能，它的意<br>图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于 persist()方法，按照<br>官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填<br>入到持久化实例中，标识符的填入可能被推迟到 flush 的时间；② persist()方法保证当它在一<br>个事务外部被调用的时候并不触发一个 INSERT 语句，当需要封装一个长会话流程的时候，<br>persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执<br>行 INSERT 语句，不管是在事务内部还是外部。至于 lock()方法和 update()方法的区别，update()<br>方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱<br>管状态的对象变成持久状态。<br>NOWCODER.COM<br>7、大型网站在架构上应当考虑哪些问题？<br>考察点：Java 架构<br>参考回答：</p><ul><li>分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个<br>层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形<br>成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI&#x2F;RM）和 Internet 的 TCP&#x2F;IP<br>模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储<br>和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。<br>需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备<br>上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之<br>间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</li><li>分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚<br>低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模<br>块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另<br>一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</li><li>分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独<br>立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的<br>加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式<br>部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，<br>例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce<br>分布式计算框架来处理。</li><li>集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</li><li>缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓<br>存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。</li><li>异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，<br>二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影<br>响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用<br>Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能<br>推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</li><li>冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可<br>以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。 ③Web 容器<br>1、请对以下在 J2EE 中常用的名词进行解释(或简单描述)<br>考察点：J2EE<br>参考回答：<br>web 容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP,SERVLET<br>直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有 WEB 服务器来实现。例如：<br>TOMCAT,WEBLOGIC,WEBSPHERE 等。该容器提供的接口严格遵守 J2EE 规范中的 WEBAPPLICATION 标<br>准。我们把遵守以上标准的 WEB 服务器就叫做 J2EE 中的 WEB 容器。<br>Web container：实现 J2EE 体系结构中 Web 组件协议的容器。这个协议规定了一个 Web 组件运行<br>时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和 JSP 和<br>J2EE 平台 APIs 界面相同服务的容器。一个 Web container 由 Web 服务器或者 J2EE 服务器提供。<br>EJB 容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件 EJB<br>NOWCODER.COM<br>各种管理功能。只要满足 J2EE 规范的 EJB 放入该容器，马上就会被容器进行高效率的管理。并<br>且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了 J2EE 体<br>系结构中 EJB 组件规范的容器。这个规范指定了一个 Enterprise bean 的运行时环境，包括安全，<br>一致性，生命周期，事务，配置，和其他的服务。<br>JNDI：（Java Naming &amp; Directory Interface）JAVA 命名目录服务。主要提供的功能是：提供<br>一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布<br>式应用程序的功能。<br>JMS：（Java Message Service）JAVA 消息服务。主要实现各个应用程序之间的通讯。包括点对<br>点和广播。<br>JTA：（Java Transaction API）JAVA 事务服务。提供各种分布式事务服务。应用程序只需调用<br>其提供的接口即可。<br>JAF：（Java Action FrameWork）JAVA 安全认证框架。提供一些安全控制方面的框架。让开发<br>者通过各种部署和自定义实现自己的个性安全控制策略。<br>RMI&#x2F;IIOP: （Remote Method Invocation &#x2F;internet 对象请求中介协议）他们主要用于通过远<br>程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地<br>计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI<br>是 JAVA 特有的。RMI-IIOP 出现以前，只有 RMI 和 CORBA 两种选择来进行分布式程序设计。<br>RMI-IIOP 综合了 RMI 和 CORBA 的优点，克服了他们的缺点，使得程序员能更方便的编写分布式<br>程序设计，实现分布式计算。首先，RMI-IIOP 综合了 RMI 的简单性和 CORBA 的多语言性（兼容<br>性），其次 RMI-IIOP 克服了 RMI 只能用于 Java 的缺点和 CORBA 的复杂性。 四、JDBC 编程</li></ul><p>2、JDBC 基础<br>①数据库<br>1、数据库水平切分，垂直切分<br>考察点：数据库<br>参考回答：<br>NOWCODER.COM<br>垂直拆分就是要把表按模块划分到不同数据库表中（当然原则还是不破坏第三范式），这种<br>拆分在大型网站的演变过程中是很常见的。当一个网站还在很小的时候，只有小量的人来开发和<br>维护，各模块和表都在一起，当网站不断丰富和壮大的时候，也会变成多个子系统来支撑，这时<br>就有按模块和功能把表划分出来的需求。其实，相对于垂直切分更进一步的是服务化改造，说得<br>简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，<br>因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，淘宝在架构不断演<br>变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成独立<br>的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。<br>垂直拆分：单表大数据量依然存在性能瓶颈<br>水平拆分，上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量<br>的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。例如像计费<br>系统，通过按时间来划分表就比较合适，因为系统都是处理某一时间段的数据。而像 SaaS 应用，<br>通过按用户维度来划分数据比较合适，因为用户与用户之间的隔离的，一般不存在处理多个用户<br>数据的情况，简单的按 user_id 范围来水平切分。<br>通俗理解：水平拆分行，行数据拆分到不同表中， 垂直拆分列，表数据拆分到不同表中。</p><p>10、leftjoin 和 rightjoin 的区别？<br>考察点：表结构<br>参考回答：<br>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录<br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>比如：<br>表 A 记录如下：<br>aID aNum<br>1 a20050111<br>2 a20050112<br>3 a20050113<br>4 a20050114<br>5 a20050115<br>表 B 记录如下:<br>bID bName<br>1 2006032401<br>2 2006032402<br>3 2006032403<br>4 2006032404<br>8 2006032408<br>left join 是以 A 表的记录为基础的,A 可以看成左表,B 可以看成右表,left join 是以左表<br>为准的. 换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为:<br>A.aID &#x3D; B.bID).<br>B 表记录不足的地方均为 NULL. 11、数据库优化方法<br>考察点：数据库<br>参考回答：<br>（1）选取最适用的字段属性<br>MySQL 可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行<br>的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度<br>设得尽可能小。<br>例如，在定义邮政编码这个字段时，如果将其设置为 CHAR(255),显然给数据库增加了不必<br>要的空间，甚至使用 VARCHAR 这种类型也是多余的，因为 CHAR(6)就可以很好的完成任务了。同<br>样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段。<br>NOWCODER.COM<br>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为 NOTNULL，这样在将来<br>执行查询的时候，数据库不用去比较 NULL 值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL<br>中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。<br>这样，我们又可以提高数据库的性能。<br>（2）使用连接（JOIN）来代替子查询(Sub-Queries)<br>MySQL 从 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查<br>询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没<br>有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户 ID 取出<br>来，然后将结果传递给主查询<br>（3）使用联合(UNION)来代替手动创建的临时表<br>MySQL 从 4.0 的版本开始支持 union 查询，它可以把需要使用临时表的两条或更多的 select<br>查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据<br>库整齐、高效。使用 union 来创建查询的时候，我们只需要用 UNION 作为关键字把多个 select<br>语句连接起来就可以了，要注意的是所有 select 语句中的字段数目要想同。下面的例子就演示<br>了一个使用 UNION 的查询。<br>（4）事务<br>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样<br>的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时<br>候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句<br>运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两<br>个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，<br>造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。<br>要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失<br>败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以 BEGIN 关键字开始，COMMIT<br>关键字结束。在这之间的一条 SQL 操作失败，那么，ROLLBACK 命令就可以把数据库恢复到 BEGIN<br>开始之前的状态。<br>12、谈一下你对继承映射的理解。<br>考察点：映射<br>参考回答：<br>继承关系的映射策略有三种：<br>① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。<br>② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。<br>③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。<br>第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态<br>查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是<br>需要进行连接查询，不适合多态查询。<br>NOWCODER.COM<br>②数据库连接池<br>1、说出数据连接池的工作机制是什么?<br>考察点：连接池<br>参考回答：<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连<br>接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用<br>完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 ③事物管理，批处理<br>1、事务的 ACID 是指什么？<br>考察点：数据库<br>参考回答：</p><ul><li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导<br>致整个事务的失败； - 一致性(Consistent)：事务结束后系统状态是一致的； - 隔离性<br>(Isolated)：并发执行的事务彼此无法看到对方的中间状态； - 持久性(Durable)：事务完成后<br>所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建<br>数据。<br>关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，<br>只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括<br>3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类<br>丢失更新）。<br>2、JDBC 中如何进行事务处理？<br>考察点：数据库<br>参考回答：<br>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置手动提交事<br>务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中发生异常则通过 rollback()<br>进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代<br>码设置保存点并让事务回滚到指定的保存点。<br>NOWCODER.COM<br>3、JDBC 进阶<br>1、JDBC 的反射，反射都是什么？<br>考察点：jdbc<br>参考回答：<br>通过反射 com.mysql.jdbc.Driver 类，实例化该类的时候会执行该类内部的静态代码块，该<br>代码块会在 Java 实现的 DriverManager 类中注册自己,DriverManager 管理所有已经注册的驱动<br>类，当调用 DriverManager.geConnection 方法时会遍历这些驱动类，并尝试去连接数据库，只<br>要有一个能连接成功，就返回 Connection 对象，否则则报异常。</li></ul><p>4、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性<br>能？<br>考察点：JDBC 优化<br>NOWCODER.COM<br>参考回答：<br>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()方法指<br>定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用<br>PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。 五、XML 编程<br>1、XML 基础<br>1、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种<br>方式？<br>考察点：XML<br>参考回答：<br>a: 两种形式 dtd schema<br>b: 本质区别:schema 本身是 xml 的，可以被 XML 解析器解析(这也是从 DTD 上发展 schema 的根<br>本目的)<br>c:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这种结构占<br>用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML 的随机访问<br>SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文件，不需要一次全部装载<br>整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用<br>户通过在其回调事件中写入处理代码来处理 XML 文件，适合对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)<br>xml 文档有两种定义方法：<br>dtd：数据类型定义（data type definition），用以描述 XML 文档的文档结构，是早期的 XML<br>文档定义形式。<br>schema：其本身是基于 XML 语言编写的，在类型和语法上的限定能力比 dtd 强，处理也比较方便，<br>因为此正逐渐代替 dtd 成为新的模式定义语言。<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>1、WEB SERVICE 名词解释，JSWDL 开发包的介绍，JAXP、JAXM 的解释。SOAP、<br>UDDI,WSDL 解释。<br>考察点：web service<br>NOWCODER.COM<br>参考回答：<br>Web ServiceWeb Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 WebService 能与其他兼容的组件进行互操作。JAXP(Java API for<br>XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。这样在你的程序中你只要<br>使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。JAXM(Java API for XML<br>Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。WSDL 是一种 XML 格式，用于将网<br>络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格<br>式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。<br>相关的具体端点即组合成为抽象端点（服务）。SOAP 即简单对象访问协议(Simple Object Access<br>Protocol)，它是用于交换 XML 编码信息的轻量级协议。UDDI 的目的是为电子商务建立标准；UDDI<br>是一套基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范，同时也<br>包含一组使企业能将自身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标<br>准。soap 是 web service 最关键的技术，是 web service 中数据和方法调传输的介质。WSDL（web<br>service definition language）描述了 web service 的接口和功能。<br>2、请你谈谈对 SOAP、WSDL、UDDI 的了解？<br>考察点：协议&amp;语言<br>参考回答：</p><ul><li>SOAP：简单对象访问协议（Simple Object Access Protocol），是 Web Service 中交换<br>数据的一种协议规范。</li><li>WSDL：Web 服务描述语言（Web Service Description Language），它描述了 Web 服务的公共<br>接口。这是一个基于 XML 的关于如何与 Web 服务通讯和使用的服务描述；也就是描述与目录中列<br>出的 Web 服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作<br>和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。</li><li>UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它<br>是一个基于 XML 的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服<br>务。简单的说，UDDI 是访问各种 WSDL 的一个门面（可以参考设计模式中的门面模式）。<br>3、谈谈 Java 规范中和 Web Service 相关的规范有哪些？<br>考察点：规范<br>参考回答：<br>Java 规范中和 Web Service 相关的有三个：</li><li>JAX-WS(JSR 224)：这个规范是早期的基于 SOAP 的 Web Service 规范 JAX-RPC 的替代版本，它<br>并不提供向下兼容性，因为 RPC 样式的 WSDL 以及相关的 API 已经在 Java EE5 中被移除了。<br>WS-MetaData 是 JAX-WS 的依赖规范，提供了基于注解配置 Web Service 和 SOAP 消息的相关 API。</li><li>JAXM(JSR 67)：定义了发送和接收消息所需的 API,相当于 Web Service 的服务器端。</li><li>JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是 Java 针对 REST（Representation State Transfer）<br>架构风格制定的一套 Web Service 规范。REST 是一种软件架构模式，是一种风格，它不像 SOAP<br>那样本身承载着一种消息协议，(两种风格的 Web Service 均采用了 HTTP 做传输协议，因为 HTTP<br>协议能穿越防火墙，Java 的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因<br>此可以将 REST 视为基于 HTTP 协议的软件架构。REST 中最重要的两个概念是资源定位和资源操<br>作，而 HTTP 协议恰好完整的提供了这两个点。HTTP 协议中的 URI 可以完成资源定位，而 GET、<br>POST、OPTION、DELETE 方法可以完成资源操作。因此 REST 完全依赖 HTTP 协议就可以完成 Web<br>NOWCODER.COM<br>Service，而不像 SOAP 协议那样只利用了 HTTP 的传输特性，定位和操作都是由 SOAP 协议自身完<br>成的，也正是由于 SOAP 消息的存在使得基于 SOAP 的 Web Service 显得笨重而逐渐被淘汰。 六、计算机网络<br>1、网络概述<br>①关于分层<br>1、TCP 协议在哪一层？IP 协议在那一层？HTTP 在哪一层？<br>考察点：网络七层模型<br>参考回答：<br>运输层，网络层，应用层。<br>2、运输层<br>①TCP 与 UDP<br>1、讲一下 TCP 的连接和释放连接。<br>考察点：网络基础<br>参考回答：<br>三次握手的过程<br>1）主机 A 向主机 B 发送 TCP 连接请求数据包，其中包含主机 A 的初始序列号 seq(A)&#x3D;x。（其<br>中报文中同步标志位 SYN&#x3D;1，ACK&#x3D;0，表示这是一个 TCP 连接请求数据报文；序号 seq&#x3D;x，表明传<br>输数据时的第一个数据字节的序号是 x）；<br>2）主机 B 收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位 SYN&#x3D;1，ACK&#x3D;1，<br>表示这是一个 TCP 连接响应数据报文，并含主机 B 的初始序列号 seq(B)&#x3D;y，以及主机 B 对主机 A<br>初始序列号的确认号 ack(B)&#x3D;seq(A)+1&#x3D;x+1）<br>3）第三次，主机 A 收到主机 B 的确认报文后，还需作出确认，即发送一个序列号 seq(A)&#x3D;x+1；<br>确认号为 ack(A)&#x3D;y+1 的报文；<br>四次挥手过程<br>NOWCODER.COM<br>假设主机 A 为客户端，主机 B 为服务器，其释放 TCP 连接的过程如下：<br>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数<br>据传送，然后等待服务器的确认。其中终止标志位 FIN&#x3D;1，序列号 seq&#x3D;u。<br>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。<br>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。<br>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加<br>1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>三次握手<br>四次挥手<br>2、TCP 有哪些应用场景<br>考察点：TCP 协议<br>参考回答：<br>NOWCODER.COM<br>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一<br>些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议<br>3、tcp 为什么可靠<br>考察点：TCP<br>参考回答：<br>三次握手，超时重传，滑动窗口，拥塞控制。<br>4、tcp 为什么要建立连接<br>考察点：TCP<br>参考回答：<br>保证可靠传输。<br>5、阐述 TCP 的 4 次挥手<br>考察点：TCP 协议<br>参考回答：<br>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的<br>数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上<br>没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动<br>关闭，而另一方执行被动关闭。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服<br>务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。<br>（1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送。<br>（2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，<br>一个 FIN 将占用一个序号。<br>（3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A。<br>（4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。<br>NOWCODER.COM<br>②协议<br>1、讲一下浏览器从接收到一个 URL 到最后展示出页面，经历了哪些过程。tag<br>考察点：http 协议<br>参考回答：<br>1.DNS 解析 2.TCP 连接 3.发送 HTTP 请求 4.服务器处理请求并返回 HTTP 报文<br>5.浏览器解析渲染页面<br>2、http 和 https 的区别<br>考察点：http 协议<br>参考回答；<br>https 协议要申请证书到 ca，需要一定经济成本；2） http 是明文传输，https 是加密的安<br>全传输；3） 连接的端口不一样，http 是 80，https 是 443；4）http 连接很简单，没有状态；<br>https 是 ssl 加密的传输，身份认证的网络协议，相对 http 传输比较安全。<br>3、http 的请求有哪些，应答码 502 和 504 有什么区别<br>考察点：http 协议<br>参考回答：<br>OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送<br>‘*‘的请求来测试服务器的功能性。<br>HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以<br>在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>NOWCODER.COM<br>GET：向特定的资源发出请求。<br>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请<br>求体中。POST 请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>PUT：向指定资源位置上传其最新内容。<br>DELETE：请求服务器删除 Request-URI 所标识的资源。<br>TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求<br>方式也都可以通过这两种方式间接的来实现。<br>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识<br>出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。<br>4、http1.1 和 1.0 的区别<br>考察点：http<br>参考回答：<br>主要区别主要体现在：<br>缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判<br>断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since,<br>If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。<br>带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要<br>某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在<br>请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），<br>这样就方便了开发者自由的选择以便于充分利用带宽和连接。<br>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请<br>求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。<br>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中<br>的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以<br>存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求<br>消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad<br>Request）。<br>长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）<br>处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，<br>在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创<br>建连接的缺点。<br>NOWCODER.COM<br>5、说说 ssl 四次握手的过程<br>考察：HTTP 加密协议<br>参考回答：<br>1、 客户端发出请求<br>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello<br>请求。<br>2、服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。<br>3、客户端回应<br>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书<br>中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还<br>要继续通信。<br>4、服务器的最后回应<br>服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的”会话密<br>钥”。然后，向客户端最后发送下面信息。<br>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所<br>有内容的 hash 值，用来供客户端校验。<br>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通<br>的 HTTP 协议，只不过用”会话密钥”加密内容。<br>6、304 状态码有什么含义？<br>考察点：http<br>参考回答：<br>304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页<br>内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为<br>If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，<br>进而节省带宽和开销。<br>3、网络层<br>①网际协议 IP<br>1、arp 协议，arp 攻击<br>NOWCODER.COM<br>考察点：ARP 协议<br>参考回答：<br>地址解析协议。ARP 攻击的第一步就是 ARP 欺骗。由上述“ARP 协议的工作过程”我们知道，<br>ARP 协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正<br>确和快速的完成——ARP 协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在<br>向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现 ARP 应答中的 IP 地址和 MAC<br>地址中的信息是可以伪造的，并不一定是自己的真实 IP 地址和 MAC 地址，由此，ARP 欺骗就产<br>生了。 ②网际控制报文协议 ICMP<br>1、icmp 协议<br>考察点：ICMP 协议<br>参考回答：<br>它是 TCP&#x2F;IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息。控制消息是<br>指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用<br>户数据，但是对于用户数据的传递起着重要的作用。 ③因特网的路由器选择协议<br>1、讲一下路由器和交换机的区别？<br>考察点：路由器<br>参考回答：<br>交换机用于同一网络内部数据的快速传输转发决策通过查看二层头部完成转发不需要修改<br>数据帧工作在 TCP&#x2F;IP 协议的二层 —— 数据链路层工作简单，直接使用硬件处理路由器用于不<br>同网络间数据的跨网络传输转发决策通过查看三层头部完成转发需要修改 TTL ，IP 头部校验和<br>需要重新计算，数据帧需要重新封装工作在 TCP&#x2F;IP 协议的三层 —— 网络层工作复杂，使用软<br>件处理。<br>4、应用层<br>①域名系统 DNS<br>1、DNS 寻址过程<br>考察点：DNS<br>NOWCODER.COM<br>参考回答：<br>1、在浏览器中输入 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个<br>网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。<br>2、如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射<br>关系，如果有，直接返回，完成域名解析。<br>3、如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP&#x2F;ip 参数中<br>设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域<br>名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。<br>4、如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关<br>系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。<br>5、如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是<br>否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服<br>务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的<br>一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com<br>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS 服务器地<br>址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，<br>重复上面的动作，进行查询，直至找到 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 主机。<br>6、如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服<br>务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不<br>管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此<br>DNS 服务器再返回给客户机。<br>从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查<br>询。②电子邮件<br>1、负载均衡反向代理模式优点及缺点<br>考察点：反向代理<br>参考回答：<br>（1）反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然<br>后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接<br>的客户端，此时代理服务器对外就表现为一个服务器。<br>（2）反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转<br>发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。<br>（3）反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，<br>也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡<br>策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由<br>于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有<br>此优点）。<br>NOWCODER.COM<br>（4）其缺点主要表现在以下两个方面<br>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反<br>向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器<br>的负载均衡。<br>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接<br>请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的<br>瓶颈。<br>一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点<br>进行负载均衡，如 search 等。 七、操作系统<br>1、操作系统概论<br>1、CentOS 和 Linux 的关系？<br>考察点：操作系统<br>参考回答：<br>CentOS是Linux众多得发行版本之一，linux有三大发行版本（：Slackware、debian、redhat）, 而 Redhat 有收费的商业版和免费的开源版,商业版的业内称之为 RHEL 系列，CentOS 是来自于依<br>照开放源代码规定而公布的源代码重新编译而成。可以用 CentOS 替代商业版的 RHEL 使用。两者<br>的不同，CentOS 不包含封闭源代码软件，是免费的。<br>2、64 位和 32 位的区别？<br>考察点：<br>操作系统<br>参考回答：<br>操作系统只是硬件和应用软件中间的一个平台。32 位操作系统针对的 32 位的 CPU 设计。64<br>位操作系统针对的 64 位的 CPU 设计。<br>2、进程的描述与控制<br>1、怎么杀死进程？<br>考察点：进程<br>参考回答：<br>NOWCODER.COM<br>Kill pid<br>2、线程，进程区别<br>考察点：进程，线程<br>参考回答：<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，<br>一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路<br>径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个<br>进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要<br>差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。1. 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li></ul><ol start="2"><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高<br>了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序<br>执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多<br>个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这<br>就是进程和线程的重要区别。<br>3、系统线程数量上限是多少？<br>考察点：线程<br>参考回答：<br>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。<br>这个限制可以在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;local_lim.h 中查看 ，对 linuxthreads 这个值一般<br>是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。<br>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程<br>栈大小，一般情况下，这个值是 8M&#x3D;8192KB。<br>4、进程和线程的区别是什么？<br>考察点：JAVA 进程<br>参考回答：<br>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。<br>线程又叫做轻量级进程。<br>NOWCODER.COM<br>5、解释一下 LINUX 下线程，GDI 类。<br>考察点：线程<br>参考回答：<br>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心<br>轻量级进程，而线程之间的管理在核外函数库中实现。<br>GDI 类为图像设备编程接口类库。<br>3、输入输出系统<br>1、socket 编程，BIO，NIO，epoll？<br>考察点：I&#x2F;O 多路复用<br>参考回答：<br>阻塞，非阻塞，io 多路复用，epoll 支持文件符数目没有限制，fd 集合只会从用户进程拷<br>贝到内核一次，自己维护一个事件队列，不用每次遍历 fd 集合发现是否有就绪状态。<br>4、存储器管理<br>1、什么是页式存储？<br>考察点：页式存储<br>参考回答：<br>主存被等分成大小相等的片，称为主存块，又称为实页。<br>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为 2n ,通常为 1KB、2KB、<br>2n KB 等<br>2、操作系统里的内存碎片你怎么理解，有什么解决办法？<br>考察点：内存碎片<br>参考回答：<br>内存碎片分为：内部碎片和外部碎片。<br>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；<br>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存<br>储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才<br>有可能利用这个存储块。<br>NOWCODER.COM<br>单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。<br>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存<br>空间的新进程的内存空闲区域。<br>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前<br>申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br>使用伙伴系统算法。<br>5、处理机调度与死锁<br>1、什么情况下会发生死锁，解决策略有哪些？<br>考察点：死锁<br>参考回答：<br>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个<br>进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如 CD-ROM 驱动器，打印机等<br>等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属<br>性所决定的。<br>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至<br>少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但<br>是，它在等待新资源之时，仍继续占用已占有的资源。<br>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源<br>的占有者进程自行释放。<br>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。<br>解决方法：银行家算法<br>2、系统 CPU 比较高是什么原因？<br>考察点：处理机<br>参考回答：<br>1、首先查看是哪些进程的 CPU 占用率最高（如下可以看到详细的路径）<br>ps -aux –sort -pcpu | more# 定位有问题的线程可以用如下命令ps -mp pid -o THREAD,tid,time | more<br>2、查看 JAVA 进程的每个线程的 CPU 占用率<br>ps -Lp 5798 cu | more # 5798 是查出来进程 PID<br>NOWCODER.COM<br>3、追踪线程，查看负载过高的原因，使用 JDK 下的一个工具<br>jstack 5798 # 5798 是 PID<br>jstack -J-d64 -m 5798 # -j-d64 指定 64 为系统<br>jstack 查出来的线程 ID 是 16 进制，可以把输出追加到文件，导出用记事本打开，再根据<br>系统中的线程 ID 去搜索查看该 ID 的线程运行内容，可以和开发一起排查。<br>3、系统如何提高并发性？<br>考察：操作系统综合性<br>参考回答：<br>1、提高 CPU 并发计算能力<br>（1）多进程&amp;多线程<br>（2）减少进程切换，使用线程，考虑进程绑定 CPU<br>（3）减少使用不必要的锁，考虑无锁编程<br>（4）考虑进程优先级<br>（5）关注系统负载<br>2、改进 I&#x2F;O 模型<br>(1)DMA 技术<br>(2)异步 I&#x2F;O<br>(3)改进多路 I&#x2F;O 就绪通知策略，epoll<br>(4)Sendfile<br>(5)内存映射<br>(6)直接 I&#x2F;O<br>八、算法与数据结构<br>1、哈希<br>1、hashset 存的数是有序的吗？<br>考察点：哈希<br>NOWCODER.COM<br>参考回答：<br>Hashset 是无序的。<br>2、Object 作为 HashMap 的 key 的话，对 Object 有什么要求吗？<br>考察点：哈希表<br>参考回答：<br>要求 Object 中 hashcode 不能变。<br>3、一致性哈希算法<br>考察点：哈希算法<br>参考回答：<br>先构造一个长度为 232 的整数环（这个环被称为一致性 Hash 环），根据节点名称的 Hash<br>值（其分布为[0, 232-1]）将服务器节点放置在这个 Hash 环上，然后根据数据的 Key 值计算得<br>到其 Hash 值（其分布也为[0, 232-1]），接着在 Hash 环上顺时针查找距离这个 Key 值的 Hash<br>值最近的服务器节点，完成 Key 到服务器的映射查找。<br>这种算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况<br>下尽量有多的请求命中原来路由到的服务器。<br>4、什么是 hashmap?<br>考察点：哈希表<br>参考回答：<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于 AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null。此<br>外，HashMap 中的映射不是有序的。<br>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表<br>中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前<br>可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该<br>哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少<br>了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操<br>作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便<br>最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生<br>rehash 操作。<br>hashmap 共有 4 个构造函数：<br>&#x2F;&#x2F; 默认构造函数。HashMap()<br>&#x2F;&#x2F; 指定“容量大小”的构造函数<br>NOWCODER.COM<br>HashMap(int capacity)<br>&#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数<br>HashMap(int capacity, float loadFactor)<br>&#x2F;&#x2F; 包含“子 Map”的构造函数<br>HashMap(Map&lt;? extends K, ? extends V&gt; map)<br>5、Java 中的 HashMap 的工作原理是什么？<br>考察点：JAVA 哈希表<br>参考回答：<br>HashMap 类有一个叫做 Entry 的内部类。这个 Entry 类包含了 key-value 作为实例变量。每<br>当往 hashmap 里面存放 key-value 对的时候，都会为它们实例化一个 Entry 对象，这个 Entry<br>对象就会存储在前面提到的 Entry 数组 table 中。Entry 具体存在 table 的那个位置是 根据 key<br>的 hashcode()方法计算出来的 hash 值（来决定）。<br>6、hashCode()和 equals()方法的重要性体现在什么地方？<br>考察点：JAVA 哈希表<br>参考回答：<br>Java 中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值<br>的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的<br>hash 值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这<br>两个方法的实现对 HashMap 的精确性和正确性是至关重要的。<br>2、树<br>1、说一下 B+树和 B-树？<br>考察点：树<br>参考回答：<br>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；<br>b+树查询必须查找到叶子节点，b 树只要匹配到即可不用管元素位置，因此 b+树查找更稳定<br>（并不慢）；<br>对于范围查找来说，b+树只需遍历叶子节点链表即可，b 树却需要重复地中序遍历。<br>2、怎么求一个二叉树的深度?手撕代码?<br>考察点：二叉树<br>NOWCODER.COM<br>参考回答：<br>public int maxDepth(TreeNode root) {<br>if (root &#x3D;&#x3D; null) {<br>return 0;<br>}<br>int left &#x3D; maxDepth(root.left);<br>int right &#x3D; maxDepth(root.right);<br>int bigger &#x3D; Math.max(left, right);<br>return bigger + 1;<br>}<br>3、算法题：二叉树层序遍历，进一步提问：要求每层打印出一个换行符<br>考察点：二叉树<br>参考回答：<br>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {<br>List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();<br>LinkedList&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;TreeNode&gt;();<br>if (root &#x3D;&#x3D; null) {<br>return res;<br>}<br>queue.offer(root);<br>while (queue.size() !&#x3D; 0) {<br>List&lt;Integer&gt; l &#x3D; new ArrayList&lt;Integer&gt;();<br>int size &#x3D; queue.size();<br>for (int i &#x3D; 0; i &lt; size; i++) {<br>TreeNode temp &#x3D; queue.poll();<br>l.add(temp.val);<br>if (temp.left !&#x3D; null) {<br>NOWCODER.COM<br>queue.offer(temp.left);<br>}<br>if (temp.right !&#x3D; null) {<br>queue.offer(temp.right);<br>}<br>}<br>res.add(l);<br>}<br>return res;<br>}<br>4、二叉树任意两个节点之间路径的最大长度<br>考察点：树<br>参考回答：<br>int maxDist(Tree root) {<br>&#x2F;&#x2F;如果树是空的，则返回 0<br>if(root &#x3D;&#x3D; NULL)<br>return 0;<br>if(root-&gt;left !&#x3D; NULL) {<br>root-&gt;lm &#x3D; maxDist(root-&gt;left) + 1;<br>}<br>if(root-&gt;right !&#x3D; NULL)<br>root-&gt;rm &#x3D; maxDist(root-&gt;right) + 1;<br>&#x2F;&#x2F;如果以该节点为根的子树中有最大的距离，那就更新最大距离<br>int sum &#x3D; root-&gt;rm + root-&gt;lm;<br>if(sum &gt; max) {<br>max &#x3D; sum;<br>NOWCODER.COM<br>}<br>return root-&gt;rm &gt; root-&gt;lm ? root-&gt;rm : root-&gt;lm;<br>}<br>5、如何实现二叉树的深度？<br>考察点：二叉树<br>参考回答：<br>实现二叉树的深度方式有两种，递归以及非递归。<br>①递归实现：<br>为了求树的深度，可以先求其左子树的深度和右子树的深度，可以用递归实现，递归的出口<br>就是节点为空。返回值为 0；<br>②非递归实现：<br>利用层次遍历的算法，设置变量 level 记录当前节点所在的层数，设置变量 last 指向当前<br>层的最后一个节点，当处理完当前层的最后一个节点，让 level 指向+1 操作。设置变量 cur 记<br>录当前层已经访问的节点的个数，当 cur 等于 last 时，表示该层访问结束。<br>层次遍历在求树的宽度、输出某一层节点，某一层节点个数，每一层节点个数都可以采取类<br>似的算法。<br>树的宽度：在树的深度算法基础上，加一个记录访问过的层节点个数最多的变量 max,在访<br>问每层前 max 与 last 比较，如果 max 比较大，max 不变，如果 max 小于 last，把 last 赋值给<br>max;<br>6、如何打印二叉树每层的节点？<br>考察点：二叉树<br>参考回答：</li></ol><p>4、bucket 如果用链表存储，它的缺点是什么？<br>考察点：链表<br>参考回答：<br>①查找速度慢，因为查找时，需要循环链表访问<br>②如果进行频繁插入和删除操作，会导致速度很慢。<br>5、如何判断链表检测环<br>考察点：链表<br>参考回答：<br>单链表有环，是指单链表中某个节点的 next 指针域指向的是链表中在它之前的某一个节点，<br>这样在链表的尾部形成一个环形结构。<br>&#x2F;&#x2F; 链表的节点结构如下 typedef struct node { int data; struct node *next; } NODE;<br>最常用方法：定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针<br>一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指<br>针走到了链表的末尾（next 指向 NULL）都没有追上第一个指针，那么链表就不是环形链表。<br>通过使用 STL 库中的 map 表进行映射。首先定义 map&lt;NODE , int&gt; m; 将一个 NODE * 指<br>针映射成数组的下标，并赋值为一个 int 类型的数值。然后从链表的头指针开始往后遍历，每<br>次遇到一个指针 p，就判断 m[p] 是否为 0。如果为 0，则将 m[p]赋值为 1，表示该节点第一次<br>访问；而如果 m[p]的值为 1，则说明这个节点已经被访问过一次了，于是就形成了环。</p><p>6、排序<br>1、排序算法知道哪些，时间复杂度是多少，解释一下快排？<br>考察点：快排<br>参考回答：<br>快排：快速排序有两个方向，左边的 i 下标一直往右走（当条件 a[i] &lt;&#x3D; a[center_index]<br>时），其中 center_index 是中枢元素的数组下标，一般取为数组第 0 个元素。<br>而右边的 j 下标一直往左走（当 a[j] &gt; a[center_index]时）。<br>如果 i 和 j 都走不动了，i &lt;&#x3D; j, 交换 a[i]和 a[j],重复上面的过程，直到 i&gt;j。交换 a[j]<br>和 a[center_index]，完成一趟快速排序。<br>2、如何得到一个数据流中的中位数？<br>考察点：排序<br>参考回答：<br>数据是从一个数据流中读出来的，数据的数目随着时间的变化而增加。如果用一个数据容器<br>来保存从流中读出来的数据，当有新的数据流中读出来时，这些数据就插入到数据容器中。<br>数组是最简单的容器。如果数组没有排序，可以用 Partition 函数找出数组中的中位数。<br>在没有排序的数组中插入一个数字和找出中位数的时间复杂度是 O(1)和 O(n)。<br>我们还可以往数组里插入新数据时让数组保持排序，这是由于可能要移动 O(n)个数，因此<br>需要 O(n)时间才能完成插入操作。在已经排好序的数组中找出中位数是一个简单的操作，只需<br>要 O(1)时间即可完成。<br>排序的链表时另外一个选择。我们需要 O(n)时间才能在链表中找到合适的位置插入新的数<br>据。如果定义两个指针指向链表的中间结点（如果链表的结点数目是奇数，那么这两个指针指向<br>同一个结点），那么可以在 O（1）时间得出中位数。此时时间效率与及基于排序的数组的时间<br>效率一样。<br>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有<br>排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大<br>NOWCODER.COM<br>数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆<br>中找出最小数。<br>因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右<br>边的数据容器。往堆中插入一个数据的时间效率是 O(logn)。由于只需 O(1)时间就可以得到位<br>于堆顶的数据，因此得到中位数的时间效率是 O(1)。<br>3、堆排序的原理是什么？<br>考察点：堆排序<br>参考回答：<br>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大<br>数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：<br>（1）最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。<br>（2）创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆。<br>（3）堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算<br>4、归并排序的原理是什么？<br>考察点：归并排序<br>参考回答：<br>（1）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and<br>Conquer）的一个非常典型的应用。<br>（2）首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个<br>数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那<br>直接将另一个数列的数据依次取出即可。<br>（3）解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组<br>A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让<br>这二组组内数据有序了？<br>NOWCODER.COM<br>可以将 A，B 组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这<br>个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，<br>再合并数列就完成了归并排序。<br>5、排序都有哪几种方法？请列举出来。<br>考察点：排序<br>参考回答：<br>排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），<br>选择排序（直接选择排序、堆排序），<br>归并排序，分配排序（箱排序、基数排序）<br>快速排序的伪代码。<br>&#x2F; &#x2F;使用快速排序方法对 a[ 0 :n- 1 ]排序<br>从 a[ 0 :n- 1 ]中选择一个元素作为 m i d d l e，该元素为支点<br>把余下的元素分割为两段 left 和 r i g h t，使得 l e f t 中的元素都小于等于支点，而 right<br>中的元素都大于等于支点<br>递归地使用快速排序方法对 left 进行排序<br>递归地使用快速排序方法对 right 进行排序<br>所得结果为 l e f t + m i d d l e + r i g h t<br>7、堆与栈<br>1、堆与栈的不同是什么？<br>考察点：堆，栈<br>参考回答：<br>（1）Java 的堆是一个运行时数据区，类的对象从中分配空间。通过比如：new 等指令建立，<br>不需要代码显式的释放，由垃圾回收来负责。<br>优点：可以动态地分配内存大小，垃圾收集器会自动回收垃圾数据。<br>缺点：由于其优点，所以存取速度较慢。<br>（2）栈：<br>其数据项的插入和删除都只能在称为栈顶的一端完成，后进先出。栈中存放一些基本类型的<br>变量 和 对象句柄。<br>优点：读取数度比堆要快，仅次于寄存器，栈数据可以共享。<br>NOWCODER.COM<br>缺点：比堆缺乏灵活性，存在栈中的数据大小与生存期必须是确定的。<br>举例：<br>String 是一个特殊的包装类数据。可以用：<br>String str &#x3D; new String(“csdn”);<br>String str &#x3D; “csdn”;<br>两种的形式来创建，第一种是用 new()来新建对象的，它会在存放于堆中。每调用一次就会<br>创建一个新的对象。而第二种是先在栈中创建一个对 String 类的对象引用变量 str，然后查找<br>栈中有没有存放”csdn”，如果没有，则将”csdn”存放进栈，并令 str 指向”abc”，如果已经<br>有”csdn” 则直接令 str 指向“csdn”。<br>2、heap 和 stack 有什么区别。<br>考察点：堆与栈<br>参考回答：<br>栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。<br>堆是栈的一个组成元素。<br>3、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。<br>考察点：堆栈<br>参考回答：<br>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都<br>使用内存中的栈空间；而通过 new 关键字和构造器创建的对象放在堆空间；程序中的字面量<br>（literal）如直接书写的 100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈<br>很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上<br>的虚拟内存都可以被当成堆空间来使用。<br>String str &#x3D; new String(“hello”);<br>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面<br>量放在静态区。<br>8、队列<br>1、什么是 Java 优先级队列(Priority Queue)？<br>考察点：队列<br>参考回答：<br>PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)<br>排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue 不允<br>NOWCODER.COM<br>许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，<br>PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。<br>2、id 全局唯一且自增，如何实现？<br>考察点：SnowFlake 雪花算法<br>参考回答；<br>SnowFlake 雪花算法<br>雪花 ID 生成的是一个 64 位的二进制正整数，然后转换成 10 进制的数。64 位二进制数由如<br>下部分组成：<br>snowflake id 生成规则<br>1 位标识符：始终是 0，由于 long 基本类型在 Java 中是带符号的，最高位是符号位，正数<br>是 0，负数是 1，所以 id 一般是正数，最高位是 0。<br>41 位时间戳：41 位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间<br>截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的 id 生成器开始使用的时间，<br>由我们程序来指定的。<br>10 位机器标识码：可以部署在 1024 个节点，如果机器分机房（IDC）部署，这 10 位可以由<br>5 位机房 ID + 5 位机器 ID 组成。<br>NOWCODER.COM<br>12 位序列：毫秒内的计数，12 位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)<br>产生 4096 个 ID 序号<br>优点<br>简单高效，生成速度快。<br>时间戳在高位，自增序列在低位，整个 ID 是趋势递增的，按照时间有序递增。<br>灵活度高，可以根据业务需求，调整 bit 位的划分，满足不同的需求。<br>缺点<br>依赖机器的时钟，如果服务器时钟回拨，会导致重复 ID 生成。<br>在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况。<br>3、如何设计算法压缩一段 URL？<br>考察点：MD5 加密算法<br>参考回答：<br>该算法主要使用 MD5 算法对原始链接进行加密（这里使用的 MD5 加密后的字符串长度为 32<br>位），然后对加密后的字符串进行处理以得到短链接的地址。<br>4、为什么要设计后缀表达式，有什么好处？<br>考察点：逆波兰表达式<br>参考回答：<br>后缀表达式又叫逆波兰表达式，逆波兰记法不需要括号来标识操作符的优先级。<br>5、LRU 算法的实现原理？<br>考察点：LRU 算法<br>参考回答：<br>①LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数<br>据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也很高”，反过来说“如果<br>数据最近这段时间一直都没有访问,那么将来被访问的概率也会很低”，两种理解是一样的；常<br>用于页面置换算法，为虚拟页式存储管理服务。<br>②达到这样一种情形的算法是最理想的：每次调换出的页面是所有内存页面中最迟将被使用<br>的；这可以最大限度的推迟页面调换，这种算法，被称为理想页面置换算法。可惜的是，这种算<br>法是无法实现的。<br>为了尽量减少与理想算法的差距，产生了各种精妙的算法，最近最少使用页面置换算法便是其中<br>一个。LRU 算法的提出，是基于这样一个事实：在前面几条指令中使用频繁的页面很可能在后面<br>的几条指令中频繁使用。反过来说，已经很久没有使用的页面很可能在未来较长的一段时间内不<br>NOWCODER.COM<br>会被用到 。这个，就是著名的局部性原理——比内存速度还要快的 cache，也是基于同样的原<br>理运行的。因此，我们只需要在每次调换时，找到最近最少使用的那个页面调出内存。<br>算法实现的关键<br>命中率：<br>当存在热点数据时，LRU 的效率很好，但偶发性的、周期性的批量操作会导致 LRU 命中率急剧<br>下降，缓存污染情况比较严重。<br>复杂度：<br>实现起来较为简单。<br>存储成本：<br>几乎没有空间上浪费。<br>代价：<br>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。 九、设计模式<br>1、结构型模式<br>①代理模式<br>1、java 中有哪些代理模式？<br>考察点：代理模式<br>参考回答：<br>静态代理，动态代理，Cglib 代理。<br>2、如何实现动态代理<br>考察点：动态代理流程<br>参考回答：<br>Java 实现动态代理的大致步骤如下：<br>1.定义一个委托类和公共接口。<br>2.自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是<br>指定运行时将生成的代理类需要完成的具体任务（包括 Preprocess 和 Postprocess），即代理<br>类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。<br>3.生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口<br>(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器<br>实例。<br>4.Java 实现动态代理主要涉及以下几个类：<br>NOWCODER.COM<br>①java.lang.reflect.Proxy: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承<br>了 Proxy 类，即 DynamicProxyClass extends Proxy。<br>②java.lang.reflect.InvocationHandler: 这里称他为”调用处理器”，他是一个接口，我<br>们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现<br>InvocationHandler 接口。<br>示例代码：<br>public final class <code>$Proxy1 extends Proxy implements Subject&#123; private InvocationHandler h; private $</code>Proxy1(){}<br>public $Proxy1(InvocationHandler h){<br>this.h &#x3D; h; }<br>public int request(int i){<br>Method method &#x3D; Subject.class.getMethod(“request”, new Class[]{int.class}); &#x2F;&#x2F;<br>创建 method 对象<br>return (Integer)h.invoke(this, method, new Object[]{new Integer(i)}); &#x2F;&#x2F;调用了<br>invoke 方法 } }<br>②适配器模式<br>1、IO 流熟悉吗，用的什么设计模式？<br>考察点：装饰模式，适配器模式<br>参考回答：<br>装饰模式和适配器模式<br>2、创建型模式<br>①单例模式<br>1、介绍一下单例模式？懒汉式的单例模式如何实现单例？<br>考察点：单例模式<br>参考回答：<br>NOWCODER.COM<br>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。优点：单例类只有一个<br>实例、共享资源，全局使用节省创建时间，提高性能。可以用静态内部实现，保证是懒加载就行<br>了，就是使用才会创建实例对象。<br>3、行为型模式<br>①策略模式<br>1、介绍一下策略模式？<br>考察点：策略模式<br>参考回答：<br>策略模式也叫政策模式，是一种行为型设计模式，是一种比较简单的设计模式。策略模式<br>采用了面向对象的继承和多态机制。略模式适合使用在：1.多个类只有在算法或行为上稍有不同<br>的场景。2.算法需要自由切换的场景。3.需要屏蔽算法规则的场景。 使用策略模式当然也有需<br>要注意的地方，那么就是策略类不要太多，如果一个策略家族的具体策略数量超过 4 个，则需要<br>考虑混合模式，解决策略类膨胀和对外暴露问题。在实际项目中，我们一般通过工厂方法模式来<br>实现策略类的声明。<br>优点：算法可以自由切换。2.避免使用多重条件判断。3.扩展性良好。 ②观察者模式<br>1、设计模式了解哪些，手写一下观察者模式？<br>考察点：观察者模式<br>参考回答：<br>NOWCODER.COM<br>观察者模式优点：<br>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个<br>具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个<br>具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，<br>因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然<br>跨越抽象化和具体化层次。<br>观察者模式缺点：<br>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费<br>很多时间。<br>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩<br>溃。在使用观察者模式是要特别注意这一点。<br>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方<br>式进行的。<br>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应<br>的机制使观察者知道所观察的对象是怎么发生变化的。<br>4、模式汇总<br>1、说说你所熟悉或听说过的 j2ee 中的几种常用模式?及对设计模式的一些看法<br>考察点：J2EE 设计模式<br>参考回答：<br>Session Facade Pattern：使用 SessionBean 访问 EntityBean Message Facade Pattern：<br>实现异步调用 EJB Command Pattern：使用 Command JavaBeans 取代 SessionBean，实现轻量级<br>访问 Data Transfer Object Factory：通过 DTO Factory 简化 EntityBean 数据提供特性 Generic<br>Attribute Access：通过 AttibuteAccess 接口简化 EntityBean 数据提供特性 Business<br>NOWCODER.COM<br>Interface：通过远程（本地）接口和 Bean 类实现相同接口规范业务逻辑一致性ＥＪＢ架构的设<br>计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率。项目越复杂，<br>项目队伍越庞大则越能体现良好设计的重要性。<br>2、j2ee 常用的设计模式？说明工厂模式。<br>考察点：j2ee 设计模式<br>参考回答：<br>Java 中的 23 种设计模式：<br>Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），Prototype<br>（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式），<br>Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元<br>模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor<br>（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），<br>Observer（观察者模式）， State（状态模式）， Strategy（策略模式），Template Method<br>（模板方法模式）， Chain Of Responsibleity（责任链模式）工厂模式：工厂模式是一种经常<br>被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通<br>常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了<br>不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需<br>要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员<br>可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。<br>3、开发中都用到了那些设计模式?用在什么场合?<br>考察点：设计模式<br>参考回答：<br>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核<br>心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用<br>到了 MVC 的设计模式。用来开发 JSP&#x2F;Servlet 或者 J2EE 的相关应用。简单工厂模式等。<br>4、简述一下你了解的 Java 设计模式<br>考察点：设计模式<br>参考回答：<br>所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一<br>个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。<br>设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模<br>式也会使新系统开发者更加容易理解其设计思路。<br>在 GoF 的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三<br>类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的<br>结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：<br>Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模<br>式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter<br>（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight<br>（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor<br>（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），<br>NOWCODER.COM<br>Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模<br>板方法模式）， Chain Of Responsibility（责任链模式）。 十、场景题<br>1、情景题：如果一个外卖配送单子要发布，现在有 200 个骑手都想要接这一单，如何保证只有<br>一个骑手接到单子？<br>2、场景题：美团首页每天会从 10000 个商家里面推荐 50 个商家置顶，每个商家有一个权值，你<br>如何来推荐？第二天怎么更新推荐的商家？<br>可以借鉴下 stackoverflow，视频网站等等的推荐算法。<br>3、场景题：微信抢红包问题<br>悲观锁，乐观锁，存储过程放在 mysql 数据库中。<br>4、场景题：1000 个任务，分给 10 个人做，你怎么分配，先在纸上写个最简单的版本，然后优<br>化。<br>全局队列，把 1000 任务放在一个队列里面，然后每个人都是取，完成任务。<br>分为 10 个队列，每个人分别到自己对应的队列中去取务。<br>5、场景题：保证发送消息的有序性，消息处理的有序性。<br>6、如何把一个文件快速下发到 100w 个服务器<br>7、给每个组分配不同的 IP 段，怎么设计一种结构使的快速得知 IP 是哪个组的?<br>8、10 亿个数，找出最大的 10 个。<br>建议一个大小为 10 的小根堆。<br>9、有几台机器存储着几亿淘宝搜索日志，你只有一台 2g 的电脑，怎么选出搜索热度最高的十个<br>搜索关键词？<br>10、分布式集群中如何保证线程安全？<br>11、给个淘宝场景，怎么设计一消息队列？<br>12、10 万个数，输出从小到大？<br>先划分成多个小文件，送进内存排序，然后再采用多路归并排序。<br>13、有十万个单词，找出重复次数最高十个？<br>十一、UML<br>1、请你谈一下 UML 中有哪些常用的图？<br>考察点：用例图<br>参考回答：<br>UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用<br>例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图<br>（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、<br>构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有<br>三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解<br>系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、<br>NOWCODER.COM<br>时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收<br>的消息也就是说对象能够向外界提供的服务）。 十二、惊喜福利<br>此面试题库将根据当下面试形式大数据随时更新，如果你已获得下载权限，那么你可以终身<br>在牛币兑换中心里去兑换此面试题库的电子版，如果电子版有更新，会通过牛客站内信进行<br>通知（前提是你已获得下载权限）。<br>b.14. ⽹络相关：<br>a. tcp三次握⼿、四次挥⼿<br>b. http机制<br>c. https机制15. 项⽬亮点：16. 画架构图：17. 平时看过什么书？18. 接⼝与抽象类区别<br>1、⼀个类声明可否既是abstract的,⼜是final的? 不能,这两个修式符⽭盾（abstract就是要被继承）<br>2、抽象类不⼀定包含抽象⽅法<br>3、有抽象⽅法,则⼀定是抽象类<br>4、抽象类不能被实例化，⼀般⽤作基类使⽤；<br>a. 类可以实现多个接⼝但只能继承⼀个抽象类<br>b. 接⼝⾥⾯所有的⽅法都是Public的，抽象类允许Private、Protected⽅法<br>c. JDK8前接⼝⾥⾯所有的⽅法都是抽象的且不允许有静态⽅法，抽象类可以有普通、静态⽅法，JDK8 接⼝可以实现默认⽅法<br>和静态⽅法，前⾯加default、static关键字。19. java中的异常有哪⼏类，分别怎么使⽤？<br>分为错误和异常，异常⼜包括运⾏时异常、⾮运⾏时异常<br>a. 错误，如StackOverflowError、OutOfMemoryError<br>b. 异常：<br>i. 运⾏时异常，如NullPointerException、IndexOutOfBoundsException，都是RuntimeException及其⼦类<br>ii. ⾮运⾏时异常，如IOException、SQLException,都是Exception及其⼦类，这些异常是⼀定需要try catch捕获的20. 常⽤的集合类有哪些？⽐如list如何排序？<br>主要分为三类，Map、Set、List<br>a. Map: HashMap、LinkedHashMap、TreeMap<br>b. Set：HashSet、LinkedHashSet、TreeSet<br>c. List: ArrayList、LinkedList<br>1 Collections.sort(list);21. ArrayList和LinkedList内部实现⼤致是怎样的？他们之间的区别和优缺点？<br>a. ArrayList：内部使⽤数组的形式实现了存储，利⽤数组的下标进⾏元素的访问，因此对元素的随机访问速度⾮常快。因为是<br>数组，所以ArrayList在初始化的时候，有初始⼤⼩10，插⼊新元素的时候，会判断是否需要扩容，扩容的步⻓是0.5倍原容量，<br>扩容⽅式是利⽤数组的复制，因此有⼀定的开销。<br>b. LinkedList：内部使⽤双向链表的结构实现存储，LinkedList有⼀个内部类作为存放元素的单元，⾥⾯有三个属性，⽤来存放<br>元素本身以及前后2个单元的引⽤，另外LinkedList内部还有⼀个header属性，⽤来标识起始位置，LinkedList的第⼀个单元和<br>最后⼀个单元都会指向header，因此形成了⼀个双向的链表结构。<br>c. ArrayList查找较快，插⼊、删除较慢，LinkedList查找较慢，插⼊、删除较快。22. 内存溢出是怎么回事？举个例⼦。<br>a. 内存溢出 out of memory，是指程序在申请内存时，没有⾜够的内存空间供其使⽤，出现out of memory。<br>1 List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();<br>2 while (true) {<br>3 list.add(new Object());<br>4 }<br>b. 内存溢出可能的原因：<br>i. 程序中存在死循环<br>ii. 静态变量和静态⽅法太多了<br>iii. 内存泄漏：⽐如说⼀个静态的list，⼀直往⾥放值，⼜因为静态变量不会被释放，所以迟早是要内存溢出的<br>iv. ⼤对象过多：java中的⼤对象是直接进⼊⽼年代的，然后当多个⼤对象同时⼯作时造成程序的可⽤内存⾮常⼩，⽐如我<br>list中原本最多可以放1000个对象，因为可⽤内存太⼩，放了500个就放不下了。<br>v. 程序分配内存过⼩：还有⼀种很常⻅的情况，在把⼀个很⼤的程序直接导⼊，直接就内存溢出了，原因就是内存相对这<br>个程序就是太⼩了，需要⼿动增加内存。<br>c. 内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄漏堆<br>积后果很严重，⽆论多少内存,迟早会被占光。23. &#x3D;&#x3D;和equals的区别<br>&#x3D;&#x3D;是运算符，⽽equals是Object的基本⽅法，&#x3D;&#x3D;⽤于基本类型的数据的⽐较，或者是⽐较两个对象的引⽤是否相同，equals⽤<br>于⽐较两个对象的值是否相等，例如字符串的⽐较。24. hashCode⽅法的作⽤<br>1、hashCode的存在主要是⽤于查找的快捷性，为了配合基于散列的集合正常运⾏，如Hashtable，HashMap等，hashCode是<br>⽤来在散列存储结构中确定对象的存储地址的；<br>2、如果两个对象相同，就是适⽤于equals(java.lang.Object) ⽅法，那么这两个对象的hashCode⼀定要相同；<br>3、如果对象的equals⽅法被重写，那么对象的hashCode也尽量重写，并且产⽣hashCode使⽤的对象，⼀定要和equals⽅法中<br>使⽤的⼀致，否则就会违反上⾯提到的第2点；<br>4、两个对象的hashCode相同，并不⼀定表示两个对象就相同，也就是不⼀定适⽤于equals(java.lang.Object) ⽅法，只能够说<br>明这两个对象在散列存储结构中，它们存放在同⼀个桶⾥⾯。25. NIO是什么？适⽤于何种场景？<br>a. NIO是为了弥补IO操作的不⾜⽽诞⽣的，NIO的⼀些新特性有：⾮阻塞I&#x2F;O，选择器，缓冲以及管道。<br>b. 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候⽤NIO处理数据可<br>能是个很好的选择。(适⽤于⼩数据多连接)<br>c. ⽽如果只有少量的连接，⽽这些连接每次要发送⼤量的数据，这时候传统的IO更合适。使⽤哪种处理数据，需要在数据的响<br>应等待时间和检查缓冲区数据的时间上作⽐较来权衡选择。<br>d. NIO：<br>i. 概念：NIO(new IO)，是⼀种⾮阻塞式I&#x2F;O；java NIO采⽤了双向通道进⾏数据传输，在通道上我们可以注册我们感兴趣的<br>事件：连接事件、读写事件；NIO主要有三⼤核⼼部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)。传统IO基于字<br>节流和字符流进⾏操作，⽽NIO基于Channel和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区<br>写⼊到通道中。Selector(选择区)⽤于监听多个通道的事件（⽐如：连接打开，数据到达）。因此，单个线程可以监听多个<br>数据通道。<br>ii. 原理：26. 由⼀个专⻔的线程来处理所有的 IO 事件，并负责分发。27. 事件驱动机制：事件到的时候触发，⽽不是同步的去监视事件。28. 线程通讯：线程之间通过 wait,notify 等⽅式通讯。保证每次上下⽂切换都是有意义的。减少⽆谓的线程切换。29. Hashmap实现原理？如何保证HashMap线程安全？<br>a. HashMap简单说就是它根据键的hashCode值存储数据，⼤多数情况下可以直接定位到它的值，因⽽具有很快的访问速度，<br>但遍历顺序却是不确定的。<br>b. HashMap基于哈希表，底层结构由数组来实现，添加到集合中的元素以“key–value”形式保存到数组中，在数组中key–<br>value被包装成⼀个实体来处理—也就是上⾯Map接⼝中的Entry。<br>c. 在HashMap中，Entry[]保存了集合中所有的键值对，当我们需要快速存储、获取、删除集合中的元素时，HashMap会根据<br>hash算法来获得“键值对”在数组中存在的位置，以来实现对应的操作⽅法。<br>d. HashMap底层是采⽤数组来维护的.Entry静态内部类的数组<br>1 &#x2F;**<br>2 * The table, resized as necessary. Length MUST Always be a power of two.<br>3 *&#x2F;<br>4 transient Entry[] table;<br>5<br>6 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>7 final K key;<br>8 V value;<br>9 Entry&lt;K,V&gt; next;<br>10 final int hash;<br>11 ……<br>12 }<br>c. HashMap添加元素：将准备增加到map中的对象与该位置上的对象进⾏⽐较(equals⽅法),如果相同,那么就将该位置上的那<br>个对象(Entry类型)的value值替换掉,否则沿着该Entry的链继续重复上述过程,如果到链的最后任然没有找到与此对象相同的对象,那么这个<br>时候就会被增加到数组中,将数组中该位置上的那个Entry对象链到该对象的后⾯(先hashcode计算位置，如果找到相同位置便替换值，找<br>不到则重复hashcode计算，直到最后在添加到hashmap最后⾯；)<br>d. HashMap是基于哈希表的Map接⼝的⾮同步实现，允许null键值，但不保证映射的顺序；底层使⽤数组实现，数组中的每项<br>是⼀个链表；存储时根据key的hash算法来决定其存储位置；数组扩容需要重新计算扩容后每个元素在数组中的位置很耗性能；<br>e. ConcurrentHashMap是HashMap的线程安全实现，允许多个修改操作同时进⾏(使⽤了锁分离技术)，它使⽤了多个锁来控制<br>对hash表的不同段进⾏的修改，每个段其实就是⼀个⼩的hashtable，它们有⾃⼰的锁。使⽤了多个⼦hash表(段Segment)，允<br>许多个读操作并发进⾏，读操作并不需要锁，因为它的HashEntry⼏乎是不可变的：30. jvm内存结构？为什么需要GC？<br>a. 内存结构：<br>b. 垃圾回收：垃圾回收可以有效的防⽌内存泄漏，有效的使⽤可以使⽤的内存。垃圾回收器通常是作为⼀个单独的低优先级的<br>线程运⾏，不可预知的情况下对内存堆中已经死亡的或者⻓时间没有使⽤的对象进⾏清除和回收，程序员不能实时的调⽤垃圾<br>回收器对某个对象或所有对象进⾏垃圾回收。回收机制有分代复制垃圾回收、标记垃圾回收、增量垃圾回收等⽅式。31. NIO模型，select&#x2F;epoll的区别，多路复⽤的原理？<br>1、io多路复⽤：<br>1、概念：IO多路复⽤是指内核⼀旦发现进程指定的⼀个或者多个IO条件准备读取，它就通知该进程。<br>2、优势：与多进程和多线程技术相⽐，I&#x2F;O多路复⽤技术的最⼤优势是系统开销⼩，系统不必创建进程&#x2F;线程，也不必维护<br>这些进程&#x2F;线程，从⽽⼤⼤减⼩了系统的开销。<br>3、系统：⽬前⽀持I&#x2F;O多路复⽤的系统调⽤有 select，pselect，poll，epoll。<br>2、select：select⽬前⼏乎在所有的平台上⽀持，其良好跨平台⽀持也是它的⼀个优点。select的⼀个缺点在于单个进程能够<br>监视的⽂件描述符的数量存在最⼤限制，在Linux上⼀般为1024，可以通过修改宏定义甚⾄重新编译内核的⽅式提升这⼀限制，<br>但是这样也会造成效率的降低。<br>3、poll：它没有最⼤连接数的限制，原因是它是基于链表来存储的，但是同样有⼀个缺点：<br>a. ⼤量的fd的数组被整体复制于⽤户态和内核地址空间之间，⽽不管这样的复制是不是有意义。<br>b. poll还有⼀个特点是“⽔平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<br>epoll跟select都能提供多路I&#x2F;O复⽤的解决⽅案。在现在的Linux内核⾥有都能够⽀持，其中epoll是Linux所特有，⽽select则应该是<br>POSIX所规定，⼀般操作系统均有实现。32. java中⼀个字符占多少个字节？int，long，double占多少个字节？<br>a. 1字节： byte , boolean<br>b. 2字节： short , char<br>c. 4字节： int , float<br>d. 8字节： long , double33. 创建⼀个类的实例都有哪些⽅法？<br>1 Object o &#x3D; new Object();<br>2 Object o &#x3D; oo.clone();<br>3 Object o &#x3D; Class.forName(“xxx”).newInstance();34. final&#x2F;finaly&#x2F;finalize区别？<br>a. final是定义类、⽅法、字段的修饰符，表示类不可被继承，⽅法不能被重写，字段值不能被修改<br>b. finally是异常处理机制的关键字，表示最后执⾏<br>c. finalize是Object的⼀个⽅法，在对象被虚拟机回收时会判断是否执⾏该⽅法，当对象没有覆盖finalize⽅法，或者finalize⽅法<br>已经被虚拟机调⽤过，虚拟机将这两种情况都视为“没有必要执⾏”35. Session&#x2F;Cookie区别？<br>Session存储在服务器端，类型可以是任意的Java对象，Cookie存储在客户端，类型只能为字符串36. String&#x2F;StringBuffer&#x2F;StringBuilder的区别以及实现？<br>a. String、StringBuffer是线程安全的，StringBuilder不是<br>b. String不继承任何类，StringBuffer、StringBuilder继承⾃AbstractStringBuilder<br>StringBuffer线程安全但效率低，应该使⽤在多线程情况下；<br>StringBuilder线程不安全，在单线程情况下效率⾼；37. Servlet⽣命周期<br>a. Servlet⽣命周期分为三个阶段：<br>1、初始化阶段 调⽤init()⽅法<br>　　2、响应客户请求阶段　　调⽤service()⽅法<br>　　3、终⽌阶段　　调⽤destroy()⽅法38. 如何⽤java分配⼀段连续的1G的内存空间?需要注意些什么？<br>1 ByteBuffer.allocateDirect(1024<em>1024</em>1024);<br>要注意内存溢出问题。39. Java有⾃⼰的内存回收机制，但为什么还存在内存泄漏的问题呢？<br>a. ⾸先内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄<br>漏堆积后果很严重，⽆论多少内存,迟早会被占光。<br>b. ⽐如下⾯这段代码，list持有o的引⽤，o暂时是⽆法被JVM垃圾回收的，只有当list被垃圾回收或者o从对象list删除掉后，o才<br>能被JVM垃圾回收。<br>1 List list &#x3D; new ArrayList();<br>2 Object o &#x3D; new Object();<br>3 list.add(o);<br>4 o &#x3D; null;<br>41. String s &#x3D; new String(“abc”)创建了⼏个String Object？<br>1、2个，会创建String对象在常量池和堆中。<br>2、String中的intern(),⾸先检查String pool是否有对应的字符串对象,如果有则返回，如果没有则在String pool中⽣成字符串，<br>并返回地址；<br>3.String中字⾯值”ab”之间拼接是在String pool中产⽣,⽽字⾯值与变量拼接字符串或者new String(“”)则是在堆中产⽣对象;42. 静态对象：<br>1.在main⽅法开始运⾏时需要注意static的先后顺序：静态变量和静态代码块(按代码先后顺序)—-匿名块和成员变量(按代码先<br>后顺序)—-构造函数—静态⽅法(调⽤时加载)<br>2.先执⾏⽗类的静态块,再执⾏⼦类的静态块,再执⾏⽗类的构造⽅法,再执⾏⼦类的构造⽅法<br>1、静态块&gt;构造⽅法；<br>2、⽗&gt;⼦43. final关键字：<br>1、⽤在类上不能被继承，abstract(需要被继承)和final不能共存；<br>2、⽤在⽅法上不能被重写<br>3、⽤在变量上表示⽅变量不能被改变<br>--对于final类的成员变量的初使化⽅式(基本数据类型)<br>1.申明变量时直接赋值<br>2.在构造⽅法中完成赋值,如果有多个构造⽅法,则每个都要完成final类变量的赋值<br>3.如果⼀个变量为static final则只能在申明时赋值<br>--对于final类型的引⽤变量来说,所谓的不能改变指的是该引⽤不能改变,值是可以改变的（如StringBuffer）<br>--为什么⼀般在public类final终态成员变量申明时要加static?<br>static对象存放在静态空间，不会在运⾏时被释放，可以节省内存，类的多个对象同时引⽤只有⼀份,没有多份拷⻉44. HashMap与HashTable的区别：<br>1.线程安全上,hashtable是同步的线程安全；hashmap是⾮同步的线程不安全，可接受null的值和value（hashtable不允许）；<br>2.对单线程来说,hashTable效率低<br>3、线程安全的类：vector(⽐arrayList多了同步机制，效率低不建议使⽤)、stack(堆栈类，先进后出)、hashtable(⽐hashmap<br>多了同步机制)、enumeration(枚举类)45. 多态：<br>1、多态条件：1.有继承 2. 有重写 3. 要有⽗类引⽤指向⼦类对象；如Animal a &#x3D; new Tiger();46. ⽗类或者接⼝引⽤指向⼦类或者实现该接⼝的类的对象；47. 多态是运⾏时⾏为,不是编绎时⾏为；48. 多态要有动态绑定，通过⽅法重写与⽅法重载来实现多态?? 这种说法是错误，因为⽅法重载是编译期决定好的,没有后期也就<br>是运⾏期的动态绑定；49. 集合删除：<br>注意: List底层为数组,删除时数组元素下标会被改变50. 跌代器调⽤.next()⽅法时,会检测是否有被修改过51. 如果要删除集合中的元素⼀定要⽤跌代器的remove()⽅法.52. 参数传递与引⽤传递：<br>1.基本数据类型传参,是数据值的拷⻉互不影响.<br>2.引⽤对象传参,是传地址,两个引⽤指向同⼀个对象,则对象改变两个引⽤也都改变(java编程只有值传递参数)53. hash冲突：<br>1、描述：当关键字值域远⼤于哈希表的⻓度，⽽且事先并不知道关键字的具体取值时，冲突就难免会发⽣。（两个或两个以上<br>的值hash计算的结果有相同的，造成冲突）<br>2、解决⽅法：<br>1、开放地址法：插⼊元素时，如果发⽣冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下⼀个空<br>槽，并将该元素放⼊该槽中（会导致相同hash值的元素挨在⼀起和其他hash值对应的槽被占⽤）。查找元素时，⾸先散列值所<br>指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到⼀个空槽，指示查找的元<br>素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）<br>2、链地址法：现⾏探测法的基本思想是将所有哈希地址为i的元素构成⼀个称为同义词链的单链表，并将单链表的头指针<br>存在哈希表的第i个单元中，因⽽查找、插⼊和删除主要在同义词链中进⾏。链地址法适⽤于经常进⾏插⼊和删除的情况。<br>3、在散列(双&#x2F;多重散列)：当发⽣冲突时，使⽤第⼆个、第三个、哈希函数计算地址，直到⽆冲突时。缺点：计算时间增<br>加。<br>4、建⽴⼀个公共溢出区：假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设⽴存储空间向量<br>OverTable[0..v]⽤以存储发⽣冲突的记录。54. 在java中⼀个字符能否表示⼀个汉字：<br>在java中,⼀个字符表示16位,相当于2个字节,⼀个汉字正好是2个字节55. ⼀致性hash：<br>1、⼀致性hash算法：我们的memcached客户端（这⾥我看的spymemcache的源码），使⽤了⼀致性hash算法ketama进⾏数据存储节点<br>的选择。与常规的hash算法思路不同，只是对我们要存储数据的key进⾏hash计算，分配到不同节点存储。⼀致性hash算法是对我们要存储数<br>据的服务器进⾏hash计算，进⽽确认每个key的存储位置。这⾥提到的⼀致性hash算法ketama的做法是：选择具体的机器节点不在只依赖需要<br>缓存数据的key的hash本身了，⽽是机器节点本身也进⾏了hash运算。<br>1、⼀致性hash算法是分布式系统中常⽤算法，设计⽬的是为了解决因特⽹中的热点(hot spot)问题。解决了P2P环境最为关键问<br>题—如何在动态⽹络拓扑中分布存储和路由；<br>2、⼀致性hash算法引⼊虚拟节点机制，解决服务节点少时数据倾斜问题(即对每⼀个服务节点计算多个哈希，每个计算结果位置都<br>放置⼀个此服务节点，称为虚拟节点。)；<br>2、具体做法：如果有⼀个写⼊缓存的请求，其中Key值为K，计算器hash值Hash(K)， Hash(K) 对应于图 – 1环中的某⼀个点，如果<br>该点对应没有映射到具体的某⼀个机器节点，那么顺时针查找，直到第⼀次找到有映射机器的节点，该节点就是确定的⽬标节点，如果超过了<br>2^32仍然找不到节点，则命中第⼀个机器节点。⽐如 Hash(K) 的值介于A~B之间，那么命中的机器节点应该是B节点（如上图 ）。<br>3、数据保存流程：<br>1、⾸先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。<br>2、然后采⽤同样的⽅法求出存储数据的键的哈希值，并映射到相同的圆上。<br>3、然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第⼀个服务器上。如果超过232仍然找不到服务器，就会保存到第<br>⼀台memcached服务器上。56. java反射机制<br>可以在运⾏时判断⼀个对象所属的类，构造⼀个类的对象，判断类具有的成员变量和⽅法，调⽤1个对象的⽅法。<br>4个关键的类：Class，Constructor，Field，Method。 getConstructor获得构造函数&#x2F;getDeclardConstructor；<br>getField&#x2F;getFields&#x2F;getDeclardFields获得类所⽣命的所有字段；getMethod&#x2F;getMethods&#x2F;getDeclardMethod获得类声明的所有⽅法，正<br>常⽅法是⼀个类创建对象，⽽反射是1个对象找到1个类。57. 幂等的处理⽅式：<br>接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。<br>⼀、查询操作是天然幂等<br>⼆、唯⼀索引，防⽌新增脏数据<br>三、token机制，防⽌⻚⾯重复提交<br>四、悲观锁 for update<br>五、乐观锁（通过版本号&#x2F;时间戳实现， 通过条件限制where avai_amount-#subAmount# &gt;&#x3D; 0）<br>六、分布式锁<br>七、状态机幂等（如果状态机已经处于下⼀个状态，这时候来了⼀个上⼀个状态的变更，理论上是不能够变更的，这样的话，保证<br>了有限状态机的幂等。）58. hashmap在jdk1.8中的改动?59. Jdk1.8以前是进⾏四次扰动计算，可能从速度功效各⽅⾯考虑，jdk1.8变成扰动⼀次，低16位和⾼16位进⾏异或计算。取模的时<br>候考虑取模运算的速度⽐较慢，改⽤与操作优化效率，很巧妙，hash table就没设计的这么好。60. JDK1.8⾥对hashmap最⼤的改变是引⼊了红⿊树，这⼀点在hash不均匀并且元素个数很多的情况时，对hashmap的性能提升⾮<br>常⼤。Hashmap的底层实现是使⽤⼀个entry数组存储，默认初始⼤⼩16，不过jdk8换了名字叫node，可能是因为引⼊了树，叫<br>node更合适吧，另外我也不喜欢entry这个名字，不能望⽂⽣义，我在刚学的时候还以为是什么神秘的东⻄呢，其实就是个键值对对<br>象⽽已。Node⾥有next引⽤指向下⼀个节点，因为hashmap解决冲突的思路是拉链法。61. 另外变化⽐较⼤的还有扩容机制，也就是resize⽅法。62. java 8 流式使⽤：<br>1 List&lt;Integer&gt; evens &#x3D; nums.stream().filter(num -&gt; num % 2 &#x3D;&#x3D; 0).collect(Collectors.toList());<br>2 &#x2F;&#x2F;1、stream()操作将集合转换成⼀个流，<br>3 &#x2F;&#x2F;2、filter()执⾏我们⾃定义的筛选处理，这⾥是通过lambda表达式筛选出所有偶数，<br>4 &#x2F;&#x2F;3、最后我们通过collect()对结果进⾏封装处理，并通过Collectors.toList()指定其封装成为⼀个List集合返回。63. java域的概念：<br>field，域是⼀种属性，可以是⼀个类变量，⼀个对象变量，⼀个对象⽅法变量或者是⼀个函数的参数。64. jdk1.8中ConcurrentHashMap size⼤于8时会转化成红⿊树，请问有什么作⽤，如果通过remove操作，size⼩于8了，会发⽣什<br>么？<br>put时如果链表size&gt;&#x3D;8并且table.length&gt;&#x3D;64，这时链表会转变成⼀个红⿊树（红⿊树是⼀个⾃平衡的⼆叉查找树，查找效率会从<br>链表的o(n)降低为o(logn)，效率是⾮常⼤的提⾼），但是remove不会逆转。65. 描述⼀下Hibernate的三个状态？<br>a. transient(瞬时状态)：new出来⼀个对象，还没被保存到数据库中<br>b. persistent(持久化状态)：对象已经保存到数据库中并且在hibernate session也存在该对象<br>c. detached(离线状态)：对象在数据库中存在，hibernate session不存在66. struts⼯作流程<br>1、客户端浏览器发出HTTP请求。<br>2、根据web.xml配置，该请求被FilterDispatcher接收。<br>3、根据struts.xml配置，找到需要调⽤的Action类和⽅法， 并通过IoC⽅式，将值注⼊给Aciton。<br>4、Action调⽤业务逻辑组件处理业务逻辑，这⼀步包含表单验证。<br>5、Action执⾏完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应⻚⾯。<br>6、返回HTTP响应到客户端浏览器。67. Hibernate对⼀⼆级缓存的使⽤， Lazy-Load的理解;<br>a. ⼀级缓存：hibernate的⼀级缓存是由session提供的，因此它只存在session的⽣命周期中。也就是说session关闭的时<br>候该session所管理的⼀级缓存也随之被清除。hibernate的⼀级缓存是session所内置的，默认开启，不能被卸载，也不<br>能进⾏任何配置。在缓存中的对象,具有持久性,session对象负责管理.⼀级缓存的优点是使⽤同⼀个session对象多次查询<br>同⼀个数据对象,仅对数据库查询⼀次。⼀级缓存采⽤的是Key-Value的MAP⽅式来实现的。在缓存实体对象时，对象的<br>主关键字ID是MAP的Key，实体对象就是对象的值。所以说⼀级缓存是以实体对象为单位进⾏存储的。访问的时候使⽤的<br>是主键关键字ID。⼀级缓存使⽤的是⾃动维护的功能。但可以通过session提供的⼿动⽅法对⼀级缓存的管理进⾏⼿动⼲<br>预。evict()⽅法⽤于将某个对象从session的⼀级缓存中清除。clear()⽅法⽤于将session缓存中的⽅法全部清除。<br>b. ⼆级缓存：⼆级缓存的实现原理与⼀级缓存是⼀样的。也是通过Key-Value的Map来实现对对象的缓存。⼆级缓存是作<br>⽤在SessionFactory范围内的。因此它可被所有的Session对象所共享。需要注意的是放⼊缓存中的数据不能有第三⽅的<br>应⽤对数据进⾏修改。⼆级缓存默认关闭，需要程序员⼿动开启，默认为ehcache实现.<br>c. 懒加载：当⽤到数据的时候才向数据库查询，这就是hibernate的懒加载特性。延迟加载策略能避免加载应⽤程序不需<br>要访问的关联对象，以提⾼应⽤程序的性能。68. mybatis如何实现批量提交？<br>a. 通过标签：</p><p>b. 通过ExecutorType.BATCH：<br>69. session机制？70. session是服务器的⽣成,并传⾄客户端浏览器,后续请求,都会通过URL重写传⾄服务器进⾏session⽐较.71. session是基于cookie72. session可以保存⽤户信息,但cookie如果浏览器被禁⽤,则⽆法保存⽤户信息73. 如果浏览器禁⽤会话cookie，则每次请求都⽆法将第⼀次请求获得的sessionId传⾄后台服务器.所以每次请求刷新⻚⾯服务<br>器都会⽣成新的sessionid给到浏览器74. 因HTTP协议为⽆状态的协议（⼀旦数据交互完毕，客户端和服务端的连接就会关闭，再次交换数据时需要建⽴新的连接）,需要<br>通过session或者cookie保存和跟踪⽤户信息<br>6、sessionID放在浏览器客户端cookie,其它信息放在服务器内存中，也可以做持久化管理memcached、redis中；75. Struts2表单重复提交问题（token拦截器）<br>1.访问⻚⾯前保存token(服务器后台⽣成的⼀串序列时间串放到session中)，并传⾄前台jsp⻚⾯中的隐藏域<br>2.提交时验证token,将前台的隐藏的token传⾄后台进⾏验证是否⼀致，提交随机⽣成新的token，可以防⽌重复提交；76. shiro：<br>1、定义：apache shiro是java的⼀个安全框架，简单易⽤，基本功能有：认证、授权、加密、会话管理、与Web集成、缓存<br>等。Shiro不会去维护⽤户、维护权限；这些需要我们⾃⼰去设计&#x2F;提供；然后通过相应的接⼝注⼊给Shiro即可(五张表)。<br>2、功能点：Authentication：身份认证&#x2F;登录，验证⽤户是不是拥有相应的身份；<br>Authorization：授权，即权限验证，验证某个已认证的⽤户是否拥有某个权限；即判断⽤户是否能做事情，常⻅的如：验<br>证某个⽤户是否拥有某个⻆⾊。或者细粒度的验证某个⽤户对某个资源是否具有某个权限；<br>Session Manager：会话管理，即⽤户登录后就是⼀次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通<br>JavaSE环境的，也可以是如Web环境的；<br>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，⽽不是明⽂存储；<br>Web Support：Web⽀持，可以⾮常容易的集成到Web环境；<br>Caching：缓存，⽐如⽤户登录后，其⽤户信息、拥有的⻆⾊&#x2F;权限不必每次去查，这样可以提⾼效率；<br>Concurrency：shiro⽀持多线程应⽤的并发验证，即如在⼀个线程中开启另⼀个线程，能把权限⾃动传播过去；<br>Testing：提供测试⽀持；<br>Run As：允许⼀个⽤户假装为另⼀个⽤户（如果他们允许）的身份进⾏访问；<br>Remember Me：记住我，这个是⾮常常⻅的功能，即⼀次登录后，下次再来的话不⽤登录了。<br>3、⼯作流程：<br>1、应⽤代码通过Subject(主体，代表当前”⽤户”)来进⾏认证和授权，⽽Subject⼜委托给SecurityManager(安全管理<br>器，shiro核⼼)；<br>2、我们需要给Shiro的SecurityManager注⼊Realm(域，Shiro从Realm获取安全数据（如⽤户、⻆⾊、权限）)，从⽽<br>让SecurityManager能得到合法的⽤户及其权限进⾏判断。1. Tomcat Filter过滤器责任链模式,过滤器拦截器区别?<br>1、责任链模式：将⼀个事件处理流程分派到⼀组执⾏对象上去，这⼀组执⾏对象形成⼀个链式结构，事件处理请求在这⼀组执⾏对<br>象上进⾏传递。<br>2、过滤器和拦截器：<br>1、过滤器filter：是在java web中，你传⼊的request,response提前过滤掉⼀些信息，或者提前设置⼀些参数，然后<br>再传⼊servlet或者struts的 action进⾏业务逻辑，⽐如过滤掉⾮法url（不是login.do的地址请求，如果⽤户没有登陆都过滤<br>掉）,或者在传⼊servlet或者 struts的action前统⼀设置字符集，或者去除掉⼀些⾮法字符；<br>2、拦截器interceptor：是在⾯向切⾯编程的就是在你的service或者⼀个⽅法，前调⽤⼀个⽅法，或者在⽅法后调⽤⼀个<br>⽅法⽐如动态代理就是拦截器的简单实现，在你调⽤⽅法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调⽤⽅法后打印出<br>字符串，甚⾄在你抛出异常的时候做业务逻辑的操作。拦截是AOP的⼀种实现策略；<br>3、区别：<br>a. 拦截器是基于java的反射机制的，⽽过滤器是基于函数回调。<br>b. 拦截器不依赖于servlet容器，过滤器依赖与servlet容器。<br>c. 拦截器只能对action请求起作⽤，⽽过滤器则可以对⼏乎所有的请求起作⽤。<br>d. 拦截器可以访问action上下⽂、值栈⾥的对象，⽽过滤器不能访问。<br>e. 在action的⽣命周期中，拦截器可以多次被调⽤，⽽过滤器只能在容器初始化时被调⽤⼀次<br>2. Git与Svn的区别：<br>1、Git是分布式的，⽽Svn不是；<br>2、GIT把内容按元数据⽅式存储，⽽SVN是按⽂件<br>3、分⽀不同：git分⽀切换很⽅便；svn分⽀就是版本库的另外⼀个⽬录；<br>4、GIT没有⼀个全局的版本号，⽽svn有，SVN的版本号实际是任何⼀个相应时间的源代码快照。<br>5、GIT的内容完整性要优于SVN(GIT的内容存储使⽤的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和⽹<br>络问题时降低对版本库的破坏。)<br>3. Git命令底层原理：<br>4. git init：使⽤git init初始化⼀个新的⽬录时，会⽣成⼀个.git的⽬录，该⽬录即为本地仓库。⼀个新初始化的本地仓库<br>是这样的：<br>1 !”” HEAD<br>2 !”” branches<br>3 !”” config<br>4 !”” description<br>5 !”” hooks<br>6 !”” objects<br>7 # !”” info<br>8 # <code>$&quot;&quot; pack 9 $</code>“” refs<br>10 !”” heads<br>11 $“” tags<br>description⽤于GitWeb程序<br>config配置特定于该仓库的设置（还记得git config的三个配置级别么）<br>hooks放置客户端或服务端的hook脚本<br>HEAD传说中的HEAD指针，指明当前处于哪个分⽀<br>objectsGit对象存储⽬录<br>refsGit引⽤存储⽬录<br>branches放置分⽀引⽤的⽬录<br>其中description、config和hooks这些不在讨论中，后⽂会直接忽略。<br>5. git add：Git commit之前先要通过git add添加⽂件：<br>可以看到，多了⼀个index⽂件。并且在objects⽬录下多了⼀个9f的⽬录，其中多了⼀个<br>4d96d5b00d98959ea9960f069585ce42b1349a⽂件。<br>其实9f4d96d5b00d98959ea9960f069585ce42b1349a就是⼀个Git对象，称为blob对象。<br>6. git commit：<br>7. JSP的执⾏过程：<br>1）客户端发出请求。<br>2）Web容器将JSP转译成Servlet源代码。<br>3）Web容器将产⽣的源代码进⾏编译。<br>4）Web容器加载编译后的代码并执⾏。<br>5）把执⾏结果响应⾄客户端。<br>8. ZK⾼可⽤：<br>9. ZooKeeper 运⾏期间，集群中⾄少有过半的机器保存了最新数据。集群超过半数的机器能够正常⼯作，集群就能够对<br>外提供服务。<br>10. zookeeper有什么功能，选举算法如何进⾏：<br>1、选举算法：<br>1、Fast Leader(领导者选举)选举算法：<br>1.server启动时默认选举⾃⼰，并向整个集群⼴播<br>2.收到消息时，通过3层判断：选举轮数，zxid，server id⼤⼩判断是否同意对⽅，如果同意，则修改⾃⼰的选<br>票，并向集群⼴播<br>3.QuorumCnxManager负责IO处理，每2个server建⽴⼀个连接，只允许id⼤的server连id⼩的server，每个<br>server启动单独的读写线程处理，使⽤阻塞IO<br>4.默认超过半数机器同意时，则选举成功，修改⾃身状态为LEADING或FOLLOWING<br>5.Obserer机器不参与选举<br>2、原理：选举结果的影响权重关系是:⾸先看数据id,数据id⼤者胜出;其次再判断leader id,leader id⼤者胜出。<br>3、举例：<br>假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数<br>据量这⼀点上,都是⼀样的.假设这些服务器依序启动,来看看会发⽣什么.1. 服务器1启动,此时只有它⼀台服务器启动了,它发出去的报没有任何响应,所以它的选举状态⼀直是LOOKING<br>状态；<br>2. 服务器2启动,它与最开始启动的服务器1进⾏通信,互相交换⾃⼰的选举结果,由于两者都没有历史数据,所以id<br>值较⼤的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例⼦中的半数以上是3),所以服务器1,2<br>还是继续保持LOOKING状态.<br>3. 服务器3启动,根据前⾯的理论分析,服务器3成为服务器1,2,3中的⽼⼤,⽽与上⾯不同的是,此时有三台服务器<br>选举了它,所以它成为了这次选举的leader.<br>4. 服务器4启动,根据前⾯的分析,理论上服务器4应该是服务器1,2,3,4中最⼤的,但是由于前⾯已经有半数以上的<br>服务器选举了服务器3,所以它只能接收当⼩弟的命了.<br>5. 服务器5启动,同4⼀样,当⼩弟.<br>4、zookeeper管理员指南：<br>1、集群中过半存活即可⽤，故集群选择奇数台机器；1. RPC、RMI、MQ、SOAP：<br>1、RPC:远程过程调⽤协议，采⽤C&#x2F;S模式，分布式跨语⾔平台，更多⽤于同步调⽤，⽐如Web Service(SOAP)；<br>2、RMI:远程⽅法调⽤，依赖于java远程消息交换协议，要求服务端与客户端都为java编写；每个⽅法都具有⽅法签名，只有签名<br>匹配才可以调⽤，返回值是基本类型和对象；<br>3、MQ:队列，更多⽤于异步传输；<br>4、SOAP最主要的⼯作是使⽤标准的XML描述了RPC的请求信息(URI&#x2F;类&#x2F;⽅法&#x2F;参数&#x2F;返回值)。理论上，SOAP就是⼀段xml，你可<br>以通过http,smtp等发送它(复制到软盘上，叫快递公司送去也⾏?)。同样SOAP也是跨语⾔的。<br>2. Netty⾼性能：<br>1、NIO异步⾮阻塞通信<br>2、“零拷⻉”<br>3、内存池ByteBuf<br>4、Netty提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。<br>5、⾼效的Reactor线程模型：Reactor单线程(多线程、主从)模型，指的是所有的IO操作都在同⼀个NIO线程上⾯完成<br>6、为了尽可能提升性能，Netty采⽤了串⾏⽆锁化设计，在IO线程内部进⾏串⾏操作，避免多线程竞争导致的性能下降。表⾯上<br>看，串⾏化设计似乎CPU利⽤率不⾼，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串⾏化的线程并⾏运<br>⾏，这种局部⽆锁化的串⾏线程设计相⽐⼀个队列-多个⼯作线程模型性能更优。<br>7、⾼效的并发编程：Netty的⾼效并发编程主要体现在如下⼏点：1. volatile的⼤量、正确使⽤;<br>2. CAS和原⼦类的⼴泛使⽤；<br>3. 线程安全容器的使⽤；<br>4. 通过读写锁提升并发性能。<br>8、⾼效的序列化框架：<br>9、灵活的TCP参数配置能⼒：合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和<br>SO_SNDBUF。如果设置不当，对性能的影响是⾮常⼤的。1. 如何保证服务的幂等性？<br>1、概念：接⼝的幂等性实际上就是接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。有些<br>接⼝可以天然的实现幂等性，⽐如查询接⼝，对于查询来说，你查询⼀次和两次，对于系统来说，没有任何影响，查出<br>的结果也是⼀样。<br>2、GET幂等：值得注意，幂等性指的是作⽤于结果⽽⾮资源本身。怎么理解呢？例如，这个HTTP GET⽅法可能会每次<br>得到不同的返回内容，但并不影响资源。<br>3、POST⾮幂等：因为它会对资源本身产⽣影响，每次调⽤都会有新的资源产⽣，因此不满⾜幂等性。<br>4、如何保证幂等性：<br>1、全局唯⼀id：如果使⽤全局唯⼀ID，就是根据业务的操作和内容⽣成⼀个全局ID，在执⾏操作前先根据这个全局唯<br>⼀ID是否存在，来判断这个操作是否已经执⾏。如果不存在则把全局ID，存储到存储系统中，⽐如数据库、redis等。如<br>果存在则表示该⽅法已经执⾏。<br>从⼯程的⻆度来说，使⽤全局ID做幂等可以作为⼀个业务的基础的微服务存在，在很多的微服务中都会⽤到这样的<br>服务，在每个微服务中都完成这样的功能，会存在⼯作量重复。另外打造⼀个⾼可靠的幂等服务还需要考虑很多问题，<br>⽐如⼀台机器虽然把全局ID先写⼊了存储，但是在写⼊之后挂了，这就需要引⼊全局ID的超时机制。<br>使⽤全局唯⼀ID是⼀个通⽤⽅案，可以⽀持插⼊、更新、删除业务操作。但是这个⽅案看起来很美但是实现起来⽐<br>较麻烦，下⾯的⽅案适⽤于特定的场景，但是实现起来⽐较简单。<br>2、去重表：这种⽅法适⽤于在业务中有唯⼀标的插⼊场景中，⽐如在以上的⽀付场景中，如果⼀个订单只会⽀付⼀<br>次，所以订单ID可以作为唯⼀标识。这时，我们就可以建⼀张去重表，并且把唯⼀标识作为唯⼀索引，在我们实现时，<br>把创建⽀付单据和写⼊去去重表，放在⼀个事务中，如果重复创建，数据库会抛出唯⼀约束异常，操作就会回滚。<br>3、插⼊或更新：这种⽅法插⼊并且有唯⼀索引的情况，⽐如我们要关联商品品类，其中商品的ID和品类的ID可以构成<br>唯⼀索引，并且在数据表中也增加了唯⼀索引。这时就可以使⽤InsertOrUpdate操作。在mysql数据库中如下：<br>1 insert into goods_category (goods_id,category_id,create_time,update_time)<br>2 values(#{goodsId},#{categoryId},now(),now())<br>3 on DUPLICATE KEY UPDATE<br>4 update_time&#x3D;now()<br>4、多版本控制：这种⽅法适合在更新的场景中，⽐如我们要更新商品的名字，这时我们就可以在更新的接⼝中增加⼀<br>个版本号，来做幂等<br>1 boolean updateGoodsName(int id,String newName,int version);<br>在实现时可以如下<br>1 update goods set name&#x3D;#{newName},version&#x3D;#{version} where id&#x3D;#{id} and version&lt;${version}<br>5、状态机控制：这种⽅法适合在有状态机流转的情况下，⽐如就会订单的创建和付款，订单的付款肯定是在之前，这<br>时我们可以通过在设计状态字段时，使⽤int类型，并且通过值类型的⼤⼩来做幂等，⽐如订单的创建为0，付款成功为<br>100。付款失败为99<br>在做状态机更新时，我们就这可以这样控制<br>1 update <code>order</code> set status&#x3D;#{status} where id&#x3D;#{id} and status&lt;#{status}<br>2. zookeeper⼯作原理？<br>1、定义：zookeeper是⼀种为分布式应⽤所设计的⾼可⽤、⾼性能且⼀致的开源协调服务，它提供了⼀项基本服务：分<br>布式锁服务。后来摸索出了其他使⽤⽅法：配置维护、组服务、分布式消息队列、分布式通知&#x2F;协调等。<br>2、特点：<br>1、能够⽤在⼤型分布式系统中；<br>2、具有⼀致性、可⽤性、容错性，不会因为⼀个节点的错误⽽崩溃；<br>3、⽤途：⽤户⼤型分布式系统，作协调服务⻆⾊；<br>1、分布式锁应⽤：通过对集群进⾏master选举，来解决分布式系统中的单点故障（⼀主n从，主挂全挂）。<br>2、协调服务；<br>3、注册中⼼；<br>4、原理：<br>术语：<br>数据结构Znode：zookeeper数据采⽤树形层次结构，和标准⽂件系统⾮常相似，树中每个节点被称为Znode；<br>通知机制Watcher：zookeeper可以为所有的读操作（exists()、getChilden()及getData()）设置watch，<br>watch事件是⼀次性出发器，当watch的对象状态发⽣改变时，将会触发次对象上watch所对应的事件。watch事件将被异步的发送<br>给客户端，并且zookeeper为watch机制提供了有序的⼀致性保证。<br>基本流程：分布式锁应⽤场景<br>1、传统的⼀主n从分布式系统，容易发⽣单点故障，传统解决⽅式是增加⼀个备⽤节点，定期给主节点发送Ping包，主<br>节点回复ack，但是如果⽹络原因ack丢失，那么会出现两个主节点，造成数据混乱。<br>2、zookeeper的引⼊可以管理两个主节点，其中挂了⼀个，会将另外⼀个作为新的主节点，挂的节点回来时担任备⽤节<br>点；<br>3. cap理论：<br>1、概念：⼀个分布式系统最多只能同时满⾜⼀致性（Consistency）、可⽤性（Availability）和分区容错性（Partition<br>tolerance）这三项中的两项。<br>2、⼀致性：更新操作成功并返回客户端完成后，所有节点在同⼀时间的数据完全⼀致，所以，⼀致性，说的就是数据⼀<br>致性。<br>3、可⽤性：服务⼀直可⽤，⽽且是正常响应时间。<br>4、分区容错性：分布式系统在遇到某节点或⽹络分区故障的时候，仍然能够对外提供满⾜⼀致性和可⽤性的服务。Java 基础<br>1.JDK 和 JRE 有什么区别？<br>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。<br>2.&#x3D;&#x3D; 和 equals 的区别是什么？<br>&#x3D;&#x3D; 解读<br>对于基本类型和引用类型 &#x3D;&#x3D; 的作用效果是不同的，如下所示：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：<br>String x &#x3D; “string”;<br>String y &#x3D; “string”;<br>String z &#x3D; new String(“string”);<br>System.out.println(xy); &#x2F;&#x2F; true<br>System.out.println(xz); &#x2F;&#x2F; false<br>System.out.println(x.equals(y)); &#x2F;&#x2F; true<br>System.out.println(x.equals(z)); &#x2F;&#x2F; true<br>代码解读：因为 x 和 y 指向的是同一个引用，所以 &#x3D;&#x3D; 也是 true，而 new String()方法则重写开辟了内存空间，所以 &#x3D;&#x3D; 结果为 false，而 equals 比较的一直是值，所以结果都为 true。<br>equals 解读<br>equals 本质上就是 &#x3D;&#x3D;，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。<br>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：<br>class Cat {<br>public Cat(String name) {<br>this.name &#x3D; name;<br>}<br>private String name;public String getName() {<br>return name;<br>}public void setName(String name) {<br>this.name &#x3D; name;<br>}<br>}<br>Cat c1 &#x3D; new Cat(“王磊”);<br>Cat c2 &#x3D; new Cat(“王磊”);<br>System.out.println(c1.equals(c2)); &#x2F;&#x2F; false<br>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：<br>public boolean equals(Object obj) {<br>return (this &#x3D;&#x3D; obj);<br>}<br>原来 equals 本质上就是 &#x3D;&#x3D;。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：<br>String s1 &#x3D; new String(“老王”);<br>String s2 &#x3D; new String(“老王”);<br>System.out.println(s1.equals(s2)); &#x2F;&#x2F; true<br>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：<br>public boolean equals(Object anObject) {<br>if (this &#x3D;&#x3D; anObject) {<br>return true;<br>}<br>if (anObject instanceof String) {<br>String anotherString &#x3D; (String)anObject;<br>int n &#x3D; value.length;<br>if (n &#x3D;&#x3D; anotherString.value.length) {<br>char v1[] &#x3D; value;<br>char v2[] &#x3D; anotherString.value;<br>int i &#x3D; 0;<br>while (n– !&#x3D; 0) {<br>if (v1[i] !&#x3D; v2[i])<br>return false;<br>i++;<br>}<br>return true;<br>}<br>}<br>return false;<br>}<br>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br>总结 ：&#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。<br>3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？<br>不对，两个对象的 hashCode() 相同，equals() 不一定 true。<br>代码示例：<br>String str1 &#x3D; “通话”;<br>String str2 &#x3D; “重地”;<br>System. out. println(String. format(“str1：%d | str2：%d”, str1. hashCode(),str2. hashCode()));<br>System. out. println(str1. equals(str2));<br>执行的结果：<br>str1：1179395 | str2：1179395<br>false<br>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。<br>4.final 在 Java 中有什么作用？<br>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。<br>5.Java 中的 Math. round(-1. 5) 等于多少？<br>等于 -1，Math. round 四舍五入大于 0. 5 向上取整的。<br>6.String 属于基础的数据类型吗？<br>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。<br>7.Java 中操作字符串都有哪些类？它们之间有什么区别？<br>操作字符串的类有：String、StringBuffer、StringBuilder。<br>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br>8.String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？<br>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。<br>9.如何将字符串反转？<br>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br>示例代码：<br>&#x2F;&#x2F; StringBuffer reverse<br>StringBuffer stringBuffer &#x3D; new StringBuffer();<br>stringBuffer. append(“abcdefg”);<br>System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba<br>&#x2F;&#x2F; StringBuilder reverse<br>StringBuilder stringBuilder &#x3D; new StringBuilder();<br>stringBuilder. append(“abcdefg”);<br>System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba1. String 类的常用方法都有那些？<br>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。<br>2. 抽象类必须要有抽象方法吗？<br>不需要，抽象类不一定非要有抽象方法。<br>示例代码：<br>abstract class Cat {<br>public static void sayHi() {<br>System. out. println(“hi~”);<br>}<br>}<br>上面代码，抽象类并没有抽象方法但完全可以正常运行。<br>12.普通类和抽象类有哪些区别？<br>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。<br>13.抽象类能使用 final 修饰吗？<br>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：<br>编译器保存图</p><p>15.Java 中 IO 流分为几种？<br>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。<br>16.BIO、NIO、AIO 有什么区别？<br>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。<br>17.Files的常用方法都有哪些？<br>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。<br>容器<br>18.Java 容器都有哪些？<br>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：<br>Collection<br>List<br>ArrayList<br>LinkedList<br>Vector<br>Stack<br>Set<br>HashSet<br>LinkedHashSet<br>TreeSet<br>Map<br>HashMap<br>LinkedHashMap<br>TreeMap<br>ConcurrentHashMap<br>Hashtable<br>3. Collection 和 Collections 有什么区别？<br>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。<br>4. List、Set、Map 之间的区别是什么？<br>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：<br>区别图<br>22.如何决定使用 HashMap 还是 TreeMap？<br>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。<br>23.说一下 HashMap 的实现原理？<br>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。<br>24.说一下 HashSet 的实现原理？<br>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。<br>25.ArrayList 和 LinkedList 的区别是什么？<br>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。<br>26.如何实现数组和 List 之间的转换？<br>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：<br>&#x2F;&#x2F; list to array<br>List list &#x3D; new ArrayList();<br>list. add(“王磊”);<br>list. add(“的博客”);<br>list. toArray();<br>&#x2F;&#x2F; array to list<br>String[] array &#x3D; new String[]{“王磊”,“的博客”};<br>Arrays. asList(array);<br>5. ArrayList 和 Vector 的区别是什么？<br>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。<br>6. Array 和 ArrayList 有何区别？<br>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。<br>7. 在 Queue 中 poll()和 remove()有什么区别？<br>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。<br>代码示例：<br>Queue queue &#x3D; new LinkedList();<br>queue. offer(“string”); &#x2F;&#x2F; add<br>System. out. println(queue. poll());<br>System. out. println(queue. remove());<br>System. out. println(queue. size());<br>8. 哪些集合类是线程安全的？<br>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。<br>31.迭代器 Iterator 是什么？<br>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。<br>32.Iterator 怎么使用？有什么特点？<br>Iterator 使用代码如下：<br>List list &#x3D; new ArrayList&lt;&gt;();<br>Iterator it &#x3D; list. iterator();<br>while(it. hasNext()){<br>String obj &#x3D; it. next();<br>System. out. println(obj);<br>}<br>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。<br>33.Iterator 和 ListIterator 有什么区别？<br>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。<br>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。<br>34.怎么确保一个集合不能被修改？<br>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下：<br>List list &#x3D; new ArrayList&lt;&gt;();<br>list. add(“x”);<br>Collection clist &#x3D; Collections. unmodifiableCollection(list);<br>clist. add(“y”); &#x2F;&#x2F; 运行时此行报错<br>System. out. println(list. size());<br>多线程<br>9. 并行和并发有什么区别？<br>并行：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>并发：多个处理器或多核处理器同时处理多个任务。<br>如下图：<br>并发和并行<br>并发 &#x3D; 两个队列和一台咖啡机。<br>并行 &#x3D; 两个队列和两台咖啡机。<br>36.线程和进程的区别？<br>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。<br>37.守护线程是什么？<br>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。<br>47.在 Java 程序中怎么保证多线程的运行安全？<br>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：<br>Lock lock &#x3D; new ReentrantLock();<br>lock. lock();<br>try {<br>System. out. println(“获得锁”);<br>} catch (Exception e) {<br>&#x2F;&#x2F; TODO: handle exception<br>} finally {<br>System. out. println(“释放锁”);<br>lock. unlock();<br>}<br>13. 多线程中 synchronized 锁升级的原理是什么？<br>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。<br>52.说一下 synchronized 底层实现原理？<br>synchronized 是由一对 monitorenter&#x2F;monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。<br>53.synchronized 和 volatile 的区别是什么？<br>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。<br>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>14. 说一下 atomic 的原理？<br>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>反射<br>15. 什么是反射？<br>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><ol start="16"><li>动态代理是什么？有哪些应用？<br>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。<br>60.怎么实现动态代理？<br>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。<br>对象拷贝</li><li>为什么要使用克隆？<br>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。<br>62.如何实现对象克隆？<br>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。<br>63.深拷贝和浅拷贝区别是什么？<br>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。<br>Java Web<br>64.JSP 和 servlet 有什么区别？<br>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。<br>71.如何避免 SQL 注入？<br>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。<br>72.什么是 XSS 攻击，如何避免？<br>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br>预防 XSS 的核心是必须对输入的数据做过滤处理。<br>73.什么是 CSRF 攻击，如何避免？<br>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br>防御手段：<br>验证请求来源地址；<br>关键操作添加验证码；<br>在请求地址添加 token 并验证。<br>异常</li><li>throw 和 throws 的区别？<br>throw：是真实抛出一个异常。<br>throws：是声明可能会抛出一个异常。</li><li>try-catch-finally 中哪个部分可以省略？<br>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。<br>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？<br>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。<br>78.常见的异常类有哪些？<br>NullPointerException 空指针异常<br>ClassNotFoundException 指定类不存在<br>NumberFormatException 字符串转换为数字异常<br>IndexOutOfBoundsException 数组下标越界异常<br>ClassCastException 数据类型转换异常<br>FileNotFoundException 文件未找到异常<br>NoSuchMethodException 方法不存在异常<br>IOException IO 异常<br>SocketException Socket 异常<br>网络<br>79.http 响应码 301 和 302 代表的是什么？有什么区别？<br>301：永久重定向。<br>302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。<br>80.forward 和 redirect 的区别？<br>forward 是转发 和 redirect 是重定向：<br>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；<br>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；<br>效率：forward 比 redirect 效率高。</li><li>简述 tcp 和 udp的区别？<br>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：<br>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；<br>tcp 提供可靠的服务（数据传输），udp 无法保证；<br>tcp 面向字节流，udp 面向报文；<br>tcp 数据传输慢，udp 数据传输快；<br>83.说一下 tcp 粘包是怎么产生的？<br>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<br>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li><li>OSI 的七层模型都有哪些？<br>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>数据链路层：负责建立和管理节点间的链路。<br>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。<br>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>会话层：向两个实体的表示层提供建立和使用连接的方法。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。<br>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li><li>get 和 post 请求有哪些区别？<br>get 请求会被浏览器主动缓存，而 post 不会。<br>get 传递参数有大小限制，而 post 没有。<br>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li><li>如何实现跨域？<br>实现跨域有以下几种方案：<br>服务器端运行跨域 设置 CORS 等于 *；<br>在单个接口使用注解 @CrossOrigin 运行跨域；<br>使用 jsonp 跨域；</li><li>说一下 JSONP 实现原理？<br>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。<br>设计模式</li><li>为什么要使用 spring？<br>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。<br>spring 提供了事务支持，使得事务操作变的更加方便。<br>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。<br>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。<br>106.spring boot 核心配置文件是什么？<br>spring boot 核心的两个配置文件：<br>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li><li>spring boot 配置文件有哪几种类型？它们有什么区别？<br>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。<br>. properties 配置如下：<br>spring. RabbitMQ. port&#x3D;5672<br>. yml 配置如下：<br>spring:<br>RabbitMQ:<br>port: 5672<br>. yml 格式不支持 @PropertySource 注解导入。<br>108.spring boot 有哪些方式可以实现热部署？<br>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，沟上自动编译或手动重新编译。<br>109.jpa 和 hibernate 有什么区别？<br>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。<br>110.什么是 spring cloud？<br>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。<br>111.spring cloud 断路器的作用是什么？<br>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。<br>112.spring cloud 的核心组件有哪些？<br>Eureka：服务注册于发现。<br>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。<br>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。<br>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。<br>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。<br>Hibernate<br>113.为什么要使用 hibernate？<br>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。<br>可以很方便的进行数据库的移植工作。<br>提供了缓存机制，是程序执行更改的高效。<br>114.什么是 ORM 框架？<br>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。<br>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。<br>115.hibernate 中如何在控制台查看打印的 SQL 语句？<br>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。<br>116.hibernate 有几种查询方式？<br>三种：hql、原生 SQL、条件查询 Criteria。<br>117.hibernate 实体类可以被定义为 final 吗？<br>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。<br>118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？<br>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。<br>119.hibernate 是如何工作的？<br>读取并解析配置文件。<br>读取并解析映射文件，创建 SessionFactory。<br>打开 Session。<br>创建事务。<br>进行持久化操作。<br>提交事务。<br>关闭 Session。<br>关闭 SessionFactory。<br>120.get()和 load()的区别？<br>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。<br>load()支持延迟加载；get() 不支持延迟加载。<br>121.说一下 hibernate 的缓存机制？<br>hibernate 常用的缓存有一级缓存和二级缓存：<br>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；<br>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。<br>122.hibernate 对象有哪些状态？<br>临时&#x2F;瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>持久化状态：当调用 Session 的 save&#x2F;saveOrupdate&#x2F;get&#x2F;load&#x2F;list 等方法的时候，对象就是持久化状态。<br>游离状态：Session 关闭之后对象就是游离状态。<br>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？<br>getCurrentSession 会绑定当前线程，而 openSession 则不会。<br>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。<br>124.hibernate 实体类必须要有无参构造函数吗？为什么？<br>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。<br>MyBatis</li><li>MyBatis 中 #{}和 的区别是什么？#是预编译处理，{}的区别是什么？#{}是预编译处理，的区别是什么？#是预编译处理，{}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。<br>126.MyBatis 有几种分页方式？<br>分页方式：逻辑分页和物理分页。<br>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。<br>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。<br>127.RowBounds 是一次性查询全部结果吗？为什么？<br>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更的数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。<br>Fetch Size 官方相关文档：<a target="_blank" rel="noopener" href="http://t/">http://t</a>. cn&#x2F;EfSE2g3<br>128.MyBatis 逻辑分页和物理分页的区别是什么？<br>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。<br>129.MyBatis 是否支持延迟加载？延迟加载的原理是什么？<br>MyBatis 支持延迟加载，设置 lazyLoadingEnabled&#x3D;true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。<br>130.说一下 MyBatis 的一级缓存和二级缓存？<br>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session&#x2F;二级缓存 Mapper)进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ol><p>132.MyBatis 有哪些执行器（Executor）？<br>MyBatis 有三种基本的Executor执行器：<br>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；<br>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；<br>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。<br>38. MyBatis 分页插件的实现原理是什么？<br>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。<br>134.MyBatis 如何编写一个自定义插件？<br>自定义插件实现原理<br>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：<br>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；<br>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；<br>ParameterHandler：拦截参数的处理；<br>ResultSetHandler：拦截结果集的处理。<br>自定义插件实现关键<br>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：<br>public interface Interceptor {<br>Object intercept(Invocation invocation) throws Throwable;<br>Object plugin(Object target);<br>void setProperties(Properties properties);<br>}<br>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；<br>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；<br>intercept 方法就是要进行拦截的时候要执行的方法。<br>自定义插件实现示例<br>官方插件实现：<br>@Intercepts({@Signature(type &#x3D; Executor. class, method &#x3D; “query”,<br>args &#x3D; {MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class})})<br>public class TestInterceptor implements Interceptor {<br>public Object intercept(Invocation invocation) throws Throwable {<br>Object target &#x3D; invocation. getTarget(); &#x2F;&#x2F;被代理对象<br>Method method &#x3D; invocation. getMethod(); &#x2F;&#x2F;代理方法<br>Object[] args &#x3D; invocation. getArgs(); &#x2F;&#x2F;方法参数<br>&#x2F;&#x2F; do something . . . . . . 方法拦截前执行代码块<br>Object result &#x3D; invocation. proceed();<br>&#x2F;&#x2F; do something . . . . . . . 方法拦截后执行代码块<br>return result;<br>}<br>public Object plugin(Object target) {<br>return Plugin. wrap(target, this);<br>}<br>}<br>RabbitMQ<br>39. RabbitMQ 的使用场景有哪些？<br>抢购活动，削峰填谷，防止系统崩塌。<br>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。<br>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。<br>40. RabbitMQ 有哪些重要的角色？<br>RabbitMQ 中重要的角色有：生产者、消费者和代理：<br>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。<br>41. RabbitMQ 有哪些重要的组件？<br>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。<br>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。<br>42. RabbitMQ 中 vhost 的作用是什么？<br>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。<br>139.RabbitMQ 的消息是怎么发送的？<br>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。<br>140.RabbitMQ 怎么保证消息的稳定性？<br>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。<br>141.RabbitMQ 怎么避免消息丢失？<br>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。<br>142.要保证消息持久化成功的条件有哪些？<br>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。<br>143.RabbitMQ 持久化有什么缺点？<br>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。<br>144.RabbitMQ 有几种广播类型？<br>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。<br>145.RabbitMQ 怎么实现延迟消息队列？<br>延迟队列的实现有两种方式：<br>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。<br>43. RabbitMQ 集群有什么用？<br>集群主要有以下两个用途：<br>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。<br>44. RabbitMQ 节点的类型有哪些？<br>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。<br>45. RabbitMQ 集群搭建需要注意哪些问题？<br>各节点之间使用“–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。<br>46. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？<br>不是，原因有以下两个：<br>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。<br>47. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？<br>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<br>不能创建队列<br>不能创建交换器<br>不能创建绑定<br>不能添加用户<br>不能更改权限<br>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。<br>151.RabbitMQ 对集群节点停止顺序有要求吗？<br>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。<br>Kafka<br>48. kafka 可以脱离 zookeeper 单独使用吗？为什么？<br>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。<br>153.kafka 有几种数据保留的策略？<br>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。<br>154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？<br>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。<br>155.什么情况会导致 kafka 运行变慢？<br>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈<br>156.使用 kafka 集群需要注意什么？<br>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。<br>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。<br>Zookeeper<br>157.zookeeper 是什么？<br>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>158.zookeeper 都有哪些功能？<br>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。<br>159.zookeeper 有几种部署模式？<br>zookeeper 有三种部署模式：<br>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。<br>49. zookeeper 怎么保证主从节点的状态同步？<br>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。<br>161.集群中为什么要有主节点？<br>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。<br>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？<br>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。<br>163.说一下 zookeeper 的通知机制？<br>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。<br>MySQL<br>50. 数据库的三范式是什么？<br>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。<br>51. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？<br>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。<br>166.如何获取当前数据库版本？<br>使用 select version() 获取当前 MySQL 数据库版本。<br>167.说一下 ACID 是什么？<br>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>168.char 和 varchar 的区别是什么？<br>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。<br>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。<br>169.float 和 double 的区别是什么？<br>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。<br>170.MySQL 的内连接、左连接、右连接有什么区别？<br>内连接关键字：inner join；左连接：left join；右连接：right join。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。<br>171.MySQL 索引是怎么实现的？<br>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。<br>172.怎么验证 MySQL 的索引是否满足需求？<br>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br>explain 语法：explain select * from table where type&#x3D;1。<br>173.说一下数据库的事务隔离？<br>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：<br>transaction-isolation &#x3D; REPEATABLE-READ<br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。<br>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。<br>177.MySQL 问题排查都有哪些手段？<br>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。<br>185.Redis 支持的 Java 客户端都有哪些？<br>支持的 Java 客户端有 Redisson、jedis、lettuce 等。<br>186.jedis 和 Redisson 有哪些区别？<br>jedis：提供了比较全面的 Redis 命令的支持。<br>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p><p>191.Redis 如何做内存优化？<br>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。<br>192.Redis 淘汰策略有哪些？<br>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。<br>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。<br>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。<br>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。<br>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。<br>193.Redis 常见的性能问题有哪些？该如何解决？<br>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。<br>JVM<br>194.说一下 JVM 的主要组成部分？及其作用？<br>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）<br>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。<br>195.说一下 JVM 运行时数据区？<br>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：<br>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；<br>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<br>196.说一下堆栈的区别？<br>功能方面：堆是用来存放对象的，栈是用来执行程序的。<br>共享性：堆是线程共享的，栈是线程私有的。<br>空间大小：堆大小远远大于栈。<br>197.队列和栈是什么？有什么区别？<br>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。<br>198.什么是双亲委派模型？<br>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br>类加载器分类：<br>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。<br>199.说一下类加载的执行过程？<br>类加载分为以下 5 个步骤：<br>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。<br>57. 怎么判断对象是否可以被回收？<br>一般有两种方法来判断：<br>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。<br>58. Java 中都有哪些引用类型？<br>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。<br>207.说一下 JVM 调优的工具？<br>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。<br>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。<br>62. 常用的 JVM 调优的参数都有哪些？<br>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。<br>一、Java 基础部分</p><ol><li>JAVA 的基本数据类型有哪些 ? String 是不是基本数据类型 ?<br>Java 有 8 种基本数据类型: byte int short long double float Boolean char<br>byte int short long 都属于整数类型. Double float 属于浮点类型. Boolean 为布尔类型<br>Char 为字符型<br>String 不是基本数据类型.它定义的为对象</li><li>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>可以有多个类，但只能有一个 public 的类，并且 public 的类名必须与文件名相一致。</li><li>Java 有没有 goto?<br>java 中的保留字，现在没有在 java 中使用。</li><li>说说&amp;和&amp;&amp;的区别. &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都<br>为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。<br>&amp;&amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，例如，对<br>于 if(str !&#x3D; null &amp;&amp; !str.equals(“”))表达式，当 str 为 null 时，后面的表达式不会执行，所以不<br>会出现 NullPointerException 如果将&amp;&amp;改为&amp;，则会抛出 NullPointerException 异常。If(x&#x3D;&#x3D;33<br>&amp; ++y&gt;0) y 会增长，If(x&#x3D;&#x3D;33 &amp;&amp; ++y&gt;0)不会增长<br>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是 boolean 类型时，&amp;表示按位与操作，<br>我们通常使用 0x0f 来与一个整数进行&amp;运算，来获取该整数的最低 4 个 bit 位，例如，0x31<br>&amp; 0x0f 的结果为 0x01。<br>备注：这道题先说两者的共同点，再说出&amp;&amp;和&amp;的特殊之处，并列举一些经典的例子来表<br>明自己理解透彻深入、实际经验丰富。</li><li>在 JAVA 中如何跳出当前的多重嵌套循环？<br>在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环<br>体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如，<br>另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里<br>层循环体代码的控制，例如，要在二维数组中查找到某个数字。</li><li>switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上?<br>在 switch（expr1）中，expr1 只能是一个整数表达式或者枚举常量（更大字体），整数表达<br>式可以是 int 基本类型或 Integer 包装类型，由于，byte,short,char 都可以隐含转换为 int，所<br>以，这些类型以及这些类型的包装类型也是可以的。显然，long 和 String 类型都不符合 switch<br>的语法规定，并且不能被隐式转换成 int 类型，所以，它们不能作用于 swtich 语句中。</li><li>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 由于 s1+1 运算时会自动提升表达式的类型，所以结果是 int 型，<br>再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误。<br>对于 short s1 &#x3D; 1; s1 +&#x3D; 1;由于 +&#x3D; 是 java 语言规定的运算符，java 编译器会对它进行特殊处<br>理，因此可以正确编译。</li><li>char 型变量中能不能存贮一个中文汉字?为什么?<br>char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，<br>char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码<br>字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占<br>用两个字节，所以，char 类型的变量也是占用两个字节。</li><li>用最有效率的方法算出 2 乘以 8 等於几?<br>2 &lt;&lt; 3，<br>因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3<br>位即可，而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2 &lt;&lt;<br>3。</li><li>请设计一个一百亿的计算器<br>首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要<br>知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的<br>面向对象的设计思想。<br>首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一<br>定的范围的，为了便于讲解和理解，我们先以 byte 类型的整数为例，它用 1 个字节进行存<br>储，表示的最大数值范围为-128 到+127。-1 在内存中对应的二进制数据为 11111111，如果<br>两个-1 相加，不考虑 Java 运算时的类型提升，运算后会产生进位，二进制结果为 1,11111110，<br>由于进位后超过了 byte 类型的存储空间，所以进位部分被舍弃，即最终的结果为 11111110，<br>也就是-2，这正好利用溢位的方式实现了负数的运算。-128 在内存中对应的二进制数据为<br>10000000，如果两个-128 相加，不考虑 Java 运算时的类型提升，运算后会产生进位，二进<br>制结果为 1,00000000，由于进位后超过了 byte 类型的存储空间，所以进位部分被舍弃，即<br>最终的结果为 00000000，也就是 0，这样的结果显然不是我们期望的，这说明计算机中的算<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。<br>由于 Java 中涉及表达式运算时的类型自动提升，我们无法用 byte 类型来做演示这种问题和<br>现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下：<br>int a &#x3D; Integer.MAX_VALUE;<br>int b &#x3D; Integer.MAX_VALUE;<br>int sum &#x3D; a + b;<br>System.out.println(“a&#x3D;”+a+”,b&#x3D;”+b+”,sum&#x3D;”+sum);<br>先不考虑 long 类型，由于 int 的正数范围为 2 的 31 次方，表示的最大数值约等于<br>2<em>1000</em>1000*1000，也就是 20 亿的大小，所以，要实现一个一百亿的计算器，我们得自己<br>设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大<br>概功能如下：<br>（1）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数<br>（2）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中<br>（3）提供加减乘除的功能<br>public class BigInteger{<br>int sign;<br>byte[] val;<br>public Biginteger(String val){<br>sign &#x3D; ;<br>val &#x3D; ;<br>}<br>public BigInteger add(BigInteger other){<br>}<br>public BigInteger subtract(BigInteger other){<br>}<br>public BigInteger multiply(BigInteger other){<br>}<br>public BigInteger divide(BigInteger other){<br>}<br>}<br>备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看 jdk 中自带<br>的 java.math.BigInteger 类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整<br>代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你<br>不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证<br>明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什<br>么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，<br>拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，<br>体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这<br>也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能<br>力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一<br>千元。</li><li>使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？<br>使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>还是可以改变的。例如，对于如下语句：<br>final StringBuffer a&#x3D;new StringBuffer(“immutable”);<br>执行如下语句将报告编译期错误：<br>a&#x3D;new StringBuffer(“”);<br>但是，执行如下语句则可以通过编译：<br>a.append(“ broken!”);<br>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：<br>public void method(final StringBuffer param){<br>}<br>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：<br>param.append(“a”);</li><li>“&#x3D;&#x3D;”和 equals 方法究竟有什么区别？<br>&#x3D;&#x3D;操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存<br>储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用&#x3D;&#x3D;操作<br>符。<br>如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块<br>内存（堆内存），变量也占用一块内存，例如 Objet obj &#x3D; new Object();变量 obj 是一个内存，<br>new Object()是另一个内存，此时，变量 obj 所对应的内存中存储的数值就是对象占用的那块<br>内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要<br>看这两个变量所对应的内存中的数值是否相等，这时候就需要用&#x3D;&#x3D;操作符进行比较。<br>equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相<br>同，它比较的两个对象是独立的。例如，对于下面的代码：<br>String a&#x3D;new String(“foo”);<br>String b&#x3D;new String(“foo”);<br>两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向了其中一个对象，这是两个<br>不同的对象，它们的首地址是不同的，即 a 和 b 中存储的数值是不相同的，所以，表达式<br>a&#x3D;&#x3D;b 将返回 false，而这两个对象中的内容是相同的，所以，表达式 a.equals(b)将返回 true。<br>在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input &#x3D; …;input.equals(“quit”)，许多人稍不注意就使用&#x3D;&#x3D;进行比较了，这是错误的，随便从网上<br>找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都<br>是使用 equals 方法。<br>如果一个类没有自己定义 equals 方法，那么它将继承 Object 类的 equals 方法，Object 类的<br>equals 方法的实现代码如下：<br>boolean equals(Object o){<br>return this&#x3D;&#x3D;o;<br>}<br>这说明，如果一个类没有自己定义 equals 方法，它默认的 equals 方法（从 Object 类继承的）<br>就是使用&#x3D;&#x3D;操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals<br>和使用&#x3D;&#x3D;会得到同样的结果，如果比较的是两个独立的对象则总返回 false。如果你编写的<br>类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖 equals 方法，由<br>你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。</li><li>静态变量和实例变量的区别？<br>语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量<br>才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所<br>以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分<br>配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来<br>使用，静态变量则可以直接使用类名来引用。<br>例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并<br>且每创建一个实例对象，这个 staticVar 就会加 1；但是，每创建一个实例对象，就会分配一<br>个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。<br>public class VariantTest{<br>public static int staticVar &#x3D; 0;<br>public int instanceVar &#x3D; 0;<br>public VariantTest(){<br>staticVar++;<br>instanceVar++;<br>System.out.println(“staticVar&#x3D;” + staticVar + ”,instanceVar&#x3D;” + instanceVar);<br>}<br>}<br>备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，<br>体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！</li><li>是否可从一个 static 方法内发出对非 static 方法的调用？<br>不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对<br>象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一<br>个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非<br>static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，<br>一个 static 方法内部发出对非 static 方法的调用。</li><li>Integer 与 int 的区别<br>int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 java<br>为 int 提供的封装类。int 的默认值为 0，而 Integer 的默认值为 null，即 Integer 可以区分出<br>未赋值和值为 0 的区别，int 则无法表达出未赋值的情况，例如，要想表达出没有参加考试<br>和考试成绩为 0 的区别，则只能使用 Integer。在 JSP 开发中，Integer 的默认为 null，所以用<br>el 表达式在文本框中显示时，值为空白字符串，而 int 默认的默认值为 0，所以用 el 表达式<br>在文本框中显示时，结果为 0，所以，int 不适合作为 web 层的表单数据的类型。<br>在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可以根据其值是否为 null<br>而判断一个对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中<br>设置其 unsaved-value 属性为 0。<br>另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer<br>中还定义了表示整数的最大值和最小值的常量。</li><li>Math.round(11.5)等於多少? Math.round(-11.5)等於多少?<br>Math 类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英<br>文名称的含义相对应，例如，ceil 的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)<br>的结果为 12,Math.ceil(-11.3)的结果是-11；floor 的英文意义是地板，该方法就表示向下取整，<br>Math.ceil(11.6)的结果为 11,Math.ceil(-11.6)的结果是-12；最难掌握的是 round 方法，它表示<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>“四舍五入”，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，<br>Math.round(11.5)的结果为 12，Math.round(-11.5)的结果为-11。</li><li>下面的代码有什么不妥之处?</li><li>if(username.equals(“zxx”){}<br>2.int x &#x3D; 1;<br>return x&#x3D;&#x3D;1?true:false;</li><li>请说出作用域 public，private，protected，以及不写时的区别<br>说明：如果在修饰的元素上面没有写任何访问修饰符，则表示 friendly。<br>作用域 当前类 同一 package 子孙类 其他 package<br>public √ √ √ √<br>protected √ √ √ ×<br>friendly √ √ × ×<br>private √ × × ×<br>备注：只要记住了有 4 种访问权限，4 个访问范围，然后将全选和范围在水平和垂直方向上<br>分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。</li><li>Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型?<br>Overload 是重载的意思，Override 是覆盖的意思，也就是重写。<br>重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相<br>同（即参数个数或类型不同）。<br>重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类<br>创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个<br>完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法<br>时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决<br>父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能<br>更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增<br>加了一个全新的方法。<br>至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这<br>个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也<br>可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它<br>们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因<br>为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，<br>我们调用 map.remove(key)方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接<br>收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回<br>类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型<br>来判断。<br>override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达<br>到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法<br>进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，<br>我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：<br>1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；<br>2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；<br>3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>4、被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行<br>覆盖。<br>overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的<br>方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数<br>样式，来选择合适的方法执行。在使用重载要注意以下的几点：<br>1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不<br>同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，<br>但是不能为 fun(int,int)）；<br>2、不能通过访问权限、返回类型、抛出的异常进行重载；<br>3、方法的异常类型和数目不会对重载造成影响；<br>4、对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进<br>行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</li><li>同学贡献的一些题?<br>1.搞了多个重载方法，参数分别是 int ,char,和 double，然后将 double x &#x3D; 2，传递进去，会选<br>择哪个方法？<br>2.说说对 javaee 中的 session 的理解，你是怎么用 session 的？cvs&#x2F;svn 下载<br>3.jdk 中哪些类是不能继承的：System,String,StringBuffer 等。<br>4.在 eclipse 中调试时，怎样查看一个变量的值。<br>5.判断身份证：要么是 15 位，要么是 18 位，最后一位可以为字母，并写程序提出其中的年<br>月日。<br>6.一个房子里有椅子，椅子有腿和背，房子与椅子是什么关系，椅子与腿和背是什么关系？<br>7.如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关<br>联。椅子与腿和背时组合关系。<br>8.说说 has a 与 is a 的区别。<br>9.工厂模式的类图</li><li>线程如何同步和通讯？<br>同学回答说 synchronized 方法或代码块！面试官似乎不太满意！<br>只有多个 synchronized 代码块使用的是同一个监视器对象，这些 synchronized 代码块之间才<br>具有线程互斥的效果，假如 a 代码块用 obj1 作为监视器对象，假如 b 代码块用 obj2 作为监<br>视器对象，那么，两个并发的线程可以同时分别进入这两个代码块中。 …这里还可以分析<br>一下同步的原理。<br>对于同步方法的分析，所用的同步监视器对象是 this<br>接着对于静态同步方法的分析，所用的同步监视器对象是该类的 Class 对象<br>接着对如何实现代码块与方法的同步进行分析。</li><li>ClassLoader 如何加载 class ？<br>jvm 里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap 类加载负责<br>加载 jre&#x2F;lib&#x2F;rt.jar 中的类， 我们平时用的 jdk 中的类都位于 rt.jar 中。extclassloader 负责加载<br>jar&#x2F;lib&#x2F;ext&#x2F;*.jar 中的类，appclassloader 负责 classpath 指定的目录或 jar 中的类。除了 bootstrap<br>之外，其他的类加载器本身也都是 java 类，它们的父类是 ClassLoader。</li><li>Servlet 的生命周期？<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销<br>毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个<br>实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，<br>服务完成后就销毁，所以效率上低于 servlet</li><li>抽象类的作用？</li><li>ArrayList 如何实现插入的数据按自定义的方式有序存放？<br>class MyBean implements Comparable{<br>public int compareTo(Object obj){<br>if(! obj instanceof MyBean)<br>throw new ClassCastException() &#x2F;&#x2F;具体异常的名称，我要查 jdk 文档。<br>MyBean other &#x3D; (MyBean) obj;<br>return age &gt; other.age?1:age&#x3D;&#x3D; other.age?0:-1;<br>}<br>}<br>class MyTreeSet {<br>private ArrayList datas &#x3D; new ArrayList();<br>public void add(Object obj){<br>for(int i&#x3D;0;i&lt;datas.size();i++){<br>if(obj.compareTo(datas.get(i) !&#x3D; 1){<br>datas.add(i,obj);<br>}<br>}<br>}<br>}</li><li>分层设计的好处？<br>把各个功能按调用流程进行了模块化，模块化带来的好处就是可以随意组合，举例说明：如<br>果要注册一个用户，流程为显示界面并通过界面接收用户的输入，接着进行业务逻辑处理，<br>在处理业务逻辑又访问数据库，如果我们将这些步骤全部按流水帐的方式放在一个方法中编<br>写，这也是可以的，但这其中的坏处就是，当界面要修改时，由于代码全在一个方法内，可<br>能会碰坏业务逻辑和数据库访问的码，同样，当修改业务逻辑或数据库访问的代码时，也会<br>碰坏其他部分的代码。分层就是要把界面部分、业务逻辑部分、数据库访问部分的代码放在<br>各自独立的方法或类中编写，这样就不会出现牵一发而动全身的问题了。这样分层后，还可<br>以方便切换各层，譬如原来的界面是 Swing，现在要改成 BS 界面，如果最初是按分层设计<br>的，这时候不需要涉及业务和数据访问的代码，只需编写一条 web 界面就可以了。<br>下面的仅供参考，不建议照搬照套，一定要改成自己的语言，发现内心的感受：<br>分层的好处：1.实现了软件之间的解耦；2.便于进行分工；3.便于维护；4.提高软件组件的重<br>用；5.便于替换某种产品，比如持久层用的是 hibernate,需要更换产品用 toplink，就不用其他<br>业务代码，直接把配置一改；6.便于产品功能的扩展；7.便于适用用户需求的不断变化</li><li>序列化接口的 id 有什么用？<br>对象经常要通过 IO 进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某<br>种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”Person，既然大家都要这么干，并且没<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有个统一的干法，于是，sun 公司就提出一种统一的解决方案，它会把对象变成某个格式进<br>行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想<br>能被 sun 的这种方案处理，必须实现 Serializable 接口。<br>ObjectOutputStream.writeObject(obj);<br>Object obj &#x3D; ObjectInputStream.readObject();<br>假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了<br>另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun 的 jdk 就<br>会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本<br>号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，<br>则直接报版本号不同的错!</li><li>StringBuffer 与 StringBuilder 的区别？<br>因为 StringBuilder sbuilder &#x3D; ;是线程不安全的，运行效率高，如果一个字符串变量是在方法<br>里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用 StringBuilder。<br>如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用<br>StringBuffer。</li><li>hashCode 方法的作用？<br>首先，想要明白 hashCode 的作用，你必须要先知道 Java 中的集合。<br>总的来说，Java 中的集合（Collection）有两类，一类是 List，再有一类是 Set。你知道<br>它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重<br>复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该<br>依据什么来判断呢？这就是 Object.equals 方法了。但是，如果每增加一个元素就检查一次，<br>那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中<br>现在已经有 1000 个元素，那么第 1001 个元素加入集合时，它就要调用 1000 次 equals 方法。<br>这显然会大大降低效率。于是，Java 采用了哈希表的原理。可以简单理解，hashCode 方法<br>实际上返回的就是对象存储的物理地址（实际可能并不是）。这样一来，当集合要添加新的<br>元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。<br>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果<br>这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，<br>不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用 equals<br>方法的次数就大大降低了，几乎只需要一两次。<br>所以，Java 对于 eqauls 方法和 hashCode 方法是这样规定的：<br>1、如果两个对象相同，那么它们的 hashCode 值一定要相同；<br>2、如果两个对象的 hashCode 相同，它们并不一定相同<br>上面说的对象相同指的是用 eqauls 方法比较。<br>你当然可以不按要求去做了，但你会发现，相同的对象可以出现在 Set 集合中。同时，增<br>加新元素的效率会大大下降。</li><li>webservice 问得很多</li><li>设计出计算任意正整数的阶层？</li><li>在 oracle 数据库中需要查询出前 8 条记录的 sql 语句怎么写？</li><li>什么是 SOA，谈谈你的 SOA 的理解。service orientied architecture？<br>SOA 是指为了解决在 Internet 环境下业务集成的需要，通过连接能完成特定任务的独立功能<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实体实现的一种软件系统架构。1. 软件系统架构：SOA 不是一种语言，也不是一种具体的技术而是一种软件系统架构，<br>它尝试给出在特定环境下推荐采用的一种架构，从这个角度上来说，它更像一种模式<br>(Pattern)。因此它与很多已有的软件技术比如面向对象技术，是互补的而非互斥的。它们分<br>别面向不同的应用场景，用来满足不同的特定需求。</li><li>SOA 的使用范围：需求决定同时也限制功能。SOA 并不是包治百病的万灵丹，它最<br>主要的应用场合在于解决在 Internet 环境下的不同商业应用之间的业务集成问题。1. 如何实现线程间的通讯？<br>在 Java 语言中，提供了各种各样的输入输出流（stream）,使我们能够很方便的对数据进行<br>操作，其中，管道（pipe）流是一种特殊的流，用于在不同线程（threads）间直接传送数据。<br>一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同<br>线程间的通讯。无需求助于类似临时文件之类的东西。本文在简要介绍管道的基本概念后，<br>将以一个具体的实例 pipeapp 加以详细说明。<br>1．管道的创建与使用<br>Java 提供了两个特殊的专门的类专门用于处理管道，它们就是 pipedinputstream 类和<br>pipeoutputstream 类。<br>Pipedinputstream 代表了数据在管道中的输出端，也就是线程向管道读数据的一端；<br>pipeoutputstream 代表了数据在管道中的输入端，也就是线程向管道写数据的一端，这两个<br>类一起使用可以提供数据的管道流。<br>为了创建一个管道流，我们必须首先创建一个 pipeoutstream 对象，然后，创建<br>pipeinputstream 对象，实例如下：<br>pipeout&#x3D; new pipedyoutstream();<br>pipein&#x3D; new pipedputsteam(pipepout); 一旦创建了一个管道后，就可以象操作文件一样对管道进行数据的读写。<br>2．演示程序： pipeapp<br>应用程序由三个程序组成：主线程（pipeapp.Java）及由主线程启动的两个二级线程<br>（ythread.Java 和 zthread.Java）,它们使用管道来处理数据。程序从一个内容为一行一行”x” 字母的”input.txt”文件中读取数据，使用管道传输数据，第一次是利用线程 ythread 将数据”x” 转换为”y”，最后利用线程 zthread 将”y”转换为”z”,之后，程序在屏幕上显示修改后的数据。<br>主线程 （pipeapp.Java）<br>在 main()方法中，程序首先创建一个应用对象：pipeapp pipeapp&#x3D;new pipeapp();<br>由于程序中流操作都需要使用 IOException 异常处理，所以设置了一个 try 块。在 try 中，为<br>了从源文件中读取数据，程序为”input.txt”文件创建了一个输入流 Xfileln,:<br>fileinputstream xfileln&#x3D; new fileinputstream(“input.txt”);<br>新的输入流传递给 changetoy()方法，让线程 ythread 能读取该文件：<br>inputstream ylnpipe &#x3D;pipeapp.changetoy(xfileln);<br>changetoy()方法创建将输入数据”x”改变到”y”的线程 ythread,并返回该线程的输入管道：<br>inputstream zlnpipe &#x3D; pipeapp.changetoz(ylnpipe);<br>changetoz()方法启动将数据从”y”改变到”z”的线程 zehread,主程序将使用从 changetoz()<br>返回的输入管道。得到以修改的数据。<br>然后，程序将管道输入流定位到 datainputstream 对象，使程序能够使用 readline()方法读<br>取数据：<br>datainputstream inputstream &#x3D; new datainputstream(zlnpiepe);<br>创建了输入流以后，程序就可以以行一行的读取数据病显示在屏幕上。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>String str&#x3D; inputstream.readline();<br>While(str!&#x3D;null){<br>system.out.println(str);<br>str&#x3D;inputstream.readline();<br>}<br>显示完成之后，程序关闭输入流：<br>inputstream.close();<br>changetoy()方法<br>changetoy()方法首先通过传递一个参数 inputstream 给 datainputstream 对象来定位资源的<br>输入流，使程序能使用 readline()方法从流中读取数据：<br>datainputstream xfileln &#x3D;new datainutstream(inputstream)；<br>然后，changetoy()创建输出管道和输入管道：<br>pipeoutstream pipeout &#x3D; new pipeoutputstream();<br>pipeinputstream pipeln &#x3D; new pipedinputsteam(pipeout);<br>为了能够使用 println()方法输出修改的后的文本行到管道，程序将输出管道定位到<br>printstream 对象：<br>printstream printstream &#x3D; new printstream(pipeout);<br>现在，程序可以创建将数据从 x 改变到 y 的线程，该线程是 ythread 类的一个对象，他<br>传递两个参数：输入文件（xfileln）和输出管道（调用 printstream）<br>ythread ythread &#x3D;new thread(xfileln,printstream);<br>之后，程序启动线程：<br>changetoz（）方法<br>changetoz()方法与 changetoy()方法很相似，他从 changetoy()返回的输入流开始：<br>datainputstream yfileln&#x3D; new datainputstream(inputstream);<br>程序创建一个新的管道：<br>pipedoutstream pipeout2 &#x3D; new pipedoutputstream();<br>pipedinputstream pipeln2 &#x3D; new pipedinputsream(pipeout2);<br>该线程通过这个新的管道发出修改后的数据（输入流 pipeln2）给主程序。</li></ol><p>Ythread 类和 Zthread 类<br>由于 ythread 类与 zthread 类基本一样，在此仅以 ythread 为例加以说明。<br>Ythread 的构造器接收两个参数：输入的文件和第一个管道的输出端，构造器存储这两<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>个参数作为类的数据成员：<br>Ythread(datainputstream xfileln,pringstream printstream){<br>this.xfileln &#x3D; xfileln;<br>this.printstream &#x3D; printstream;<br>}<br>线程通过 run()方法来处理数据。首先读取一行数据，确保 xstring 不为空的情况下循环<br>执行：<br>string xstring &#x3D; xfileln.readline();<br>每读一行数据，完成一次转换<br>string ystring &#x3D; xstring.replace(‘x’,’y’);<br>然后将修改后的数据输出到管道的输出端：<br>prinstream.prinrln(ystring);<br>为了确保所有缓冲区的数据完全进入管道的输出端：<br>pringstram.flush();<br>循环完成后，线程关闭管道输出流：<br>pringstram.close();<br>ythread 类的源程序如下：<br>6. 构造器 Constructor 是否可被 override?<br>构造器 Constructor 不能被继承，因此不能重写 Override，但可以被重载 Overload。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>7. 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具<br>体类(concrete class)? 抽象类中是否可以有静态的 main 方法？<br>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类<br>中可以有静态的 main 方法。<br>备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是 java<br>语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道<br>理不提供，那答案就是肯定的了。<br>只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有 abstract 方法。<br>8. 写 clone()方法时，通常都有一行代码，是什么？<br>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己<br>的成员。<br>9. 谈谈你对面向对象的理解<br>面向对象是一种程序的设计方法，或者说它是一种程序设计范型，其基本思想是使用对象，<br>类，继承，封装，消息等基本概念来进行程序设计。<br>它是从现实世界中客观存在的事物（即对象）出发来构造软件系统，并在系统构造中尽可能<br>运用人类的自然思维方式，强调直接以问题域（现实世界）中的事物为中心来思考问题，认<br>识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的对象，作为系统的基本<br>构成单位（而不是用一些与现实世界中的事物相关比较远，并且没有对应关系的其它概念来<br>构造系统）。这可以使系统直接地映射问题域，保持问题域中事物及其相互关系的本来面貌。<br>它可以有不同层次的理解：<br>从世界观的角度可以认为：面向对象的基本哲学是认为世界是由各种各样具有自己的运动规<br>律和内部状态的对象所组成的；不同对象之间的相互作用和通讯构成了完整的现实世界。因<br>此，人们应当按照现实世界这个本来面貌来理解世界，直接通过对象及其相互关系来反映世<br>界。这样建立起来的系统才能符合现实世界的本来面目。<br>从方法学的角度可以认为：面向对象的方法是面向对象的世界观在开发方法中的直接运用。<br>它强调系统的结构应该直接与现实世界的结构相对应，应该围绕现实世界中的对象来构造系<br>统，而不是围绕功能来构造系统。<br>从程序设计的角度来看，面向对象的程序设计语言必须有描述对象及其相互之间关系的语言<br>成分。这些程序设计语言可以归纳为以下几类：系统中一切皆为对象；对象是属性及其操作<br>的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间<br>的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息<br>的序列。<br>10. 面向对象的特征有哪些方面？<br>面向对象的编程语言有封装、继承 、抽象、多态等 4 个主要的特征。<br>1．封装：<br>封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、<br>低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装<br>的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就<br>是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变<br>量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要<br>记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只<br>有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同<br>一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类<br>中。<br>例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个<br>对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中<br>定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两<br>个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配<br>在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个<br>体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例<br>子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配<br>给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能<br>完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动<br>作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。<br>2．抽象：<br>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些<br>事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与<br>当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是<br>抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个 Person 类，如下：<br>class Person{<br>String name;<br>int age;<br>}<br>人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上<br>面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些<br>与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及<br>的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。<br>3．继承：<br>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在<br>的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适<br>合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一<br>种关系，提高了软件的可重用性和可扩展性。<br>4．多态：<br>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编<br>程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，<br>该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<br>因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到<br>各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以<br>改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性<br>增强了软件的灵活性和扩展性。例如，下面代码中的 UserDao 是一个接口，它定义引用变量<br>userDao 指向的实例对象由 daofactory.getDao()在执行的时候返回，有时候指向的是<br>UserJdbcDao 这个实现，有时候指向的是 UserHibernateDao 这个实现，这样，不用修改源代<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>码，就可以改变 userDao 指向的具体类实现，从而导致 userDao.insertUser()方法调用的具体<br>代码也随之改变，即有时候调用的是 UserJdbcDao 的 insertUser 方法，有时候调用的是<br>UserHibernateDao 的 insertUser 方法：<br>UserDao userDao &#x3D; daofactory.getDao();<br>userDao.insertUser(user);<br>比喻：人吃饭，你看到的是左手，还是右手？<br>11. java 中实现多态的机制是什么？<br>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方<br>法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运<br>行的那个对象的方法，而不是引用变量的类型中定义的方法。<br>12. abstract class 和 interface 有什么区别?<br>含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方<br>法的类必须定义为 abstract class，abstract class 类中的方法不必是抽象的。abstract class 类中<br>定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方<br>法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。<br>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口<br>中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final。<br>下面比较一下两者的语法区别：<br>1.抽象类可以有构造方法，接口中不能有构造方法。<br>2.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象<br>的普通方法。<br>4.抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型,虽然 eclipse 下不报<br>错，但应该也不行），但接口抽象方法只能是 public 类型的，并且默认即为 public abstract<br>类型。<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任<br>意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。<br>7.一个类可以实现多个接口，但只能继承一个抽象类。<br>下面接着再说说两者在应用上的区别：<br>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类<br>在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个<br>典型应用，假设某个项目的所有 Servlet 类都要用相同的方式进行权限判断、记录访问日志<br>和处理异常，那么就可以定义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在<br>抽象基类的 service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中<br>只是完成各自的业务逻辑代码，伪代码如下：<br>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。<br>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，<br>最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普<br>通成员变量和方法（包括抽象方法），静态变量和方法，继承性等 6 个方面逐一去比较回答，<br>接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功<br>底。<br>13. abstract 的 method 是 否可 同 时是 static,是 否可 同 时是 native， 是否 可 同时 是<br>synchronized?<br>abstract 的 method 不可以是 static 的，因为抽象的方法是要被子类实现的，而 static 与子类<br>扯不上关系！<br>native 方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问<br>题，所以，它也不能是抽象的，不能与 abstract 混用。例如，FileOutputSteam 类要和硬件打<br>交道，底层的实现用的是操作系统相关的 api 实现，例如，在 windows 用 c 语言实现的，所<br>以，查看 jdk 的源代码，可以发现 FileOutputStream 的 open 方法的定义如下：<br>private native void open(String name) throws FileNotFoundException;<br>如果我们要用 java 调用别人写的 c 语言函数，我们是无法直接调用的，我们需要按照 java<br>的要求写一个 c 语言的函数，又我们的这个 c 语言函数去调用别人的 c 语言函数。由于我们<br>的 c 语言函数是按 java 的要求来写的，我们这个 c 语言函数就可以与 java 对接上，java 那<br>边的对接方式就是定义出与我们这个 c 函数相对应的方法，java 中对应的方法不需要写具体<br>的代码，但需要在前面声明 native。<br>关于 synchronized 与 abstract 合用的问题，我觉得也不行，因为在我几年的学习和开发中，<br>从来没见到过这种情况，并且我觉得 synchronized 应该是作用在一个具体的方法上才有意<br>义。而且，方法上的 synchronized 同步所使用的同步锁对象是 this，而抽象方法上无法确定<br>this 是什么。<br>14. 什么是内部类？Static Nested Class 和 Inner Class 的不同？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>使用 static 声明的内部类就是外部类，可以通过外部类.内部类直接访问。<br>普通内部类是不能够直接被外部所访问的，需要通过外部类实例在找到内部类实例。<br>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特<br>性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放<br>到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。<br>我想可能是既然静态成员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，<br>所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该<br>被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，<br>也可以定义在外部类的方法体中，如下所示：<br>在方法体外面定义的内部类的访问类型可以是 public,protecte,默认的，private 等 4 种类型，<br>这就好像类中定义的成员变量有 4 种访问类型一样，它们决定这个内部类的定义对其他类是<br>否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象<br>时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对<br>象，代码如下：<br>Outer outer &#x3D; new Outer();<br>Outer.Inner1 inner1 &#x3D; outer.new Innner1();<br>在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，<br>但这种内部类的前面可以使用 final 或 abstract 修饰符。这种内部类对其他类是不可见的其他<br>类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部<br>类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局<br>部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但<br>是，该局部变量前必须加 final 修饰符。<br>对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误信息就可以马上<br>了解到。<br>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同<br>时，还创建了该子类的实例对象，无需为该子类定义名称：<br>public class Outer {<br>public void start() {<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>new Thread(new Runnable() {<br>public void run() {<br>};<br>}).start();<br>}<br>}<br>最后，在方法外部定义的内部类前面可以加上 static 关键字，从而成为 Static Nested Class，<br>它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class 与普通类<br>在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定<br>义成 public、protected、默认的、private 等多种类型，而普通类只能定义成 public 和默认的<br>这两种类型。在外面引用 Static Nested Class 类的名称为“外部类名.内部类名”。在外面不<br>需要创建外部类的实例对象，就可以直接创建 Static Nested Class，例如，假设 Inner 是定义<br>在 Outer 类中的 Static Nested Class，那么可以使用如下语句创建 Inner 类：<br>Outer.Inner inner &#x3D; new Outer.Inner();<br>由于 static Nested Class 不依赖于外部类的实例对象，所以，static Nested Class 能访问外部类<br>的非 static 成员变量。当在外部访问 Static Nested Class 时，可以直接使用 Static Nested Class<br>的名字，而不需要加上外部类的名字了，在 Static Nested Class 中也可以直接引用外部类的<br>static 的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是 Static Nested Class，这时候不能在类前面加 static 关键字，<br>静态方法中的 Static Nested Class 与普通方法中的内部类的应用方式很相似，它除了可以直<br>接访问外部类中的 static 的成员变量，还可以访问静态方法中的局部变量，但是，该局部变<br>量前必须加 final 修饰符。<br>备注：首先根据你印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可<br>以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知<br>识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。<br>15. 内部类可以引用它的包含类的成员吗？有没有什么限制？<br>完全可以。如果不是静态内部类，那没有什么限制！<br>如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员<br>变量，而只能访问外部类中的静态成员，例如，下面的代码：</p><p>答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问<br>外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情<br>况，让人家吃惊。<br>16. Anonymous Inner Class (匿名内部类) 是否可继承其它类，是否可以 implements 接<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>口?<br>可以继承其他类或实现其他接口。不仅是可以，而是必须!因为匿名内部类就是在抽象类和<br>接口的基础上发展起来的。<br>17. class.forName 的作用？<br>调用该访问 返回一个以字符串指定类名的类的对象。<br>返回字节码，返回字节码的方式有几种:<br>①：这份字节码曾经被加载过已经存在 java 虚拟机中了直接返回。<br>②：java 虚拟机中还没有这份字节码 用类加载器去加载 把加载进来的字节码缓存在虚拟机<br>中，以后再得到这个字节码就不用再加载。<br>得到字节码对应的实例对象: 类名.class ; 对象.getClass(),例如 new Date; 类名.class，<br>例如，System.class<br>对 象 .getClass() ， 例 如 ， new Date().getClass() Class.forName( “ 类 名 ” ) ， 例 如 ，<br>Class.forName(“java.util.Date”);<br>③：静态方法去查询或者加载这个字符串所对应哪个类的字节码<br>因为在写源程序的时候还不知道类的名字，在我运行的时候人家传递我一个字符串，这个字<br>符串里面包含了一个类的名字，再写程序的时候把 java.util.Date 换成一个字符串变量， 等<br>程序运行起来的时候这个变量的值从一个配置文件里面装再进来，这个类的名字在写原程序<br>的时候不用知道而是等运行的时候给我临时送进来。<br>》》》》》》》》》》》》》》》》》》》》》》》》》》》《《《《《《《《《《《《《《《《《《《《《《《《《《《《《<br>按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，<br>则返回代表该字节码的 Class 实例对象，否则，按类加载器的委托机制去搜索和加载该类，<br>如果所有的类加载器都无法加载到该类，则抛出 ClassNotFoundException。加载完这个 Class<br>字节码后，接着就可以使用 Class 字节码的 newInstance 方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时<br>才能确定，这时候就需要使用 Class.forName 去动态加载该类，这个类名通常是在配置文件<br>中配置的，例如，spring 的 ioc 中每次依赖注入的具体类就是这样配置的，jdbc 的驱动类名<br>通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类<br>名<br>18. super.getClass()方法调用？<br>下面程序的输出结果是多少？<br>import java.util.Date;<br>public class Test extends Date{<br>public static void main(String[] args) {<br>new Test().test();<br>}<br>public void test(){<br>System.out.println(super.getClass().getName());<br>}<br>}<br>很奇怪，结果是 Test<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>这属于脑筋急转弯的题目，在一个 qq 群有个网友正好问过这个问题，我觉得挺有趣，就研<br>究了一下，没想到今天还被你面到了，哈哈。<br>在 test 方法中，直接调用 getClass().getName()方法，返回的是 Test 类名<br>由于 getClass()在 Object 类中定义成了 final，子类不能覆盖该方法，所以，在 test 方法中调<br>用 getClass().getName()方法，其实就是在调用从父类继承的 getClass()方法，等效于调用<br>super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是 Test。<br>如果想得到父类的名称，应该用如下代码：<br>getClass().getSuperClass().getName();<br>19. String 是最基本的数据类型吗?<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型，因此不可继承这个类、不能修改这个类。为提高效率节省空<br>间，我们应用 StringBuffer 类。<br>20. String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的 String 对象中的内容<br>到底变了没有？<br>没有。因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。这段<br>代码中，s 原先指向一个 String 对象，内容是 “Hello”，然后我们对 s 进行了+操作，那么 s<br>所指向那个对象是否发生了改变呢？答案是没有。这时，s 不指向原来那个对象，而指向了<br>另一个 String 对象，内容为”Hello world!”，原来那个对象还存在于内存中，只是 s 这个引用<br>变量不再指向它了。<br>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，<br>或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。因为<br>String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来<br>表示。这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生<br>成一个新的对象。并且，这两种类的对象转换十分容易。<br>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如<br>我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这<br>样做：<br>public class Demo {<br>private String s;<br>public Demo() {<br>s &#x3D; “Initial Value”;<br>}<br>}<br>而非 s &#x3D; new String(“Initial Value”);<br>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String<br>对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，<br>多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。<br>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表<br>同一个 String 对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是<br>否相同。<br>至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多<br>Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变<br>类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不<br>同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一<br>个可变版本，即 StringBuffer。<br>21. 是否可以继承 String 类?<br>String 类是 final 类故不可以继承. 55. String s &#x3D; new String(“xyz”);创建了几个 String Object? 二者之间有什么区别？<br>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多<br>少遍，都是缓冲区中的那一个。New String 每写一遍，就创建一个新的对象，它一句那个常<br>量”xyz”对象的内容来创建出一个新 String 对象。如果以前就用过’xyz’，这句代表就不会创<br>建”xyz”自己了，直接从缓冲区拿。<br>22. String 和 StringBuffer 的区别？<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多个<br>字符的字符数据。这个 String 类提供了数值不可改变的字符串。而这个 StringBuffer 类提供<br>的字符串进行修改。当你知道字符数据要改变的时候你就可以使用 StringBuffer。典型地，<br>你可以使用 StringBuffers 来动态构造字符数据。另外，String 实现了 equals 方法，new<br>String(“abc”).equals(new String(“abc”)的结果为 true,而 StringBuffer 没有实现 equals 方法，所<br>以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为 false。接着要举一个具<br>体的例子来说明，我们要把 1 到 100 的所有数字拼起来，组成一个串。<br>StringBuffer sbf &#x3D; new StringBuffer();<br>for(int i&#x3D;0;i&lt;100;i++){<br>sbf.append(i);<br>}<br>上面的代码效率很高，因为只创建了一个 StringBuffer 对象，而下面的代码效率很低，因为<br>创建了 101 个对象。<br>String str &#x3D; new String();<br>for(int i&#x3D;0;i&lt;100;i++){<br>str &#x3D; str + i;<br>}<br>在讲两者区别时，应把循环的次数搞成 10000，然后用 endTime-beginTime 来比较两者执行<br>的时间差异，最后还要讲讲 StringBuilder 与 StringBuffer 的区别。<br>String 覆盖了 equals 方法和 hashCode 方法，而 StringBuffer 没有覆盖 equals 方法和 hashCode<br>方法，所以，将 StringBuffer 对象存储进 Java 集合类中时会出现问题。<br>23. 如何把一段逗号分割的字符串转换成一个数组?<br>如果不查 jdk api，我很难写出来！我可以说说我的思路：用正则表达式，代码大概为：<br>String [] result &#x3D; orgStr.split(“,”);<br>用 StingTokenizer ,代码为：StringTokenizer tokener &#x3D; StringTokenizer(orgStr,”,”);<br>String [] result &#x3D; new String[tokener .countTokens()];<br>Int i&#x3D;0;<br>while(tokener.hasNext(){result[i++]&#x3D;toker.nextToken();}<br>24. 数组有没有 length()这个方法? String 有没有 length()这个方法？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>数组没有 length()这个方法，有 length 的属性。String 有有 length()这个方法。<br>25. 下面这条语句一共创建了多少个对象：String s&#x3D;”a”+”b”+”c”+”d”？<br>答：对于如下代码：<br>String s1 &#x3D; “a”;<br>String s2 &#x3D; s1 + “b”;<br>String s3 &#x3D; “a” + “b”;<br>System.out.println(s2 &#x3D;&#x3D; “ab”);<br>System.out.println(s3 &#x3D;&#x3D; “ab”);<br>第一条语句打印的结果为 false，第二条语句打印的结果为 true，这说明 javac 编译可以对字<br>符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译<br>时去掉其中的加号，直接将其编译成一个这些常量相连的结果。<br>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所<br>以，上面的代码应该只创建了一个 String 对象。写如下两行代码，<br>String s &#x3D; “a” + “b” + “c” + “d”;<br>System.out.println(s &#x3D;&#x3D; “abcd”);<br>最终打印的结果应该为 true。<br>26. try {}里有一 return 语句，那紧跟在这个 try 后的 finally {}里的 code 是否被执行，什<br>么时候被执行，在 return 前还是后?<br>也许你的答案是在 return 之前，但往更细地说，我的答案是在 return 中间执行，请看下面程<br>序代码的运行结果：<br>public class Test {<br>public static void main(String[] args) {<br>System.out.println(new Test().test());<br>}<br>static int test(){<br>int x &#x3D; 1;<br>try{<br>return x;<br>}<br>finally{<br>++x;<br>}<br>}<br>}<br>运行结果是 1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐<br>子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓<br>返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说<br>这话之前放进罐子里的。<br>29. error 和 exception 有什么区别?<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程<br>序运行正常，从不会发生的情况。<br>Error 表示有 JVM 进行处理的,是 JVM 出错. Exctption 是可以用程序进行处理的,使用 try…catch 进行处理. 65. Java 中的异常处理机制的简单原理和应用。<br>异常是指 java 程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很<br>相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个<br>对象来表示，Java 使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封<br>装到一个对象来表示的，该对象中包含有异常的信息。<br>Java 对异常进行了分类，不同类型的异常分别用不同的 Java 类表示，所有异常的根类为<br>java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception，Error 表示应<br>用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程<br>死锁等系统问题。Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普<br>通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问<br>题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者<br>让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常<br>（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化<br>或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样<br>的异常后，程序不应该死掉。<br>java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处<br>理或用 throws 声明继续抛给上层调用方法处理，所以普通异常也称为 checked 异常，而系统<br>异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用 throws 声明，所以<br>系统异常也称为 unchecked 异常。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉<br>的错误，程序不应该死掉的错误；<br>30. 请写出你最常见到的 5 个 runtime exception。<br>这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面<br>的异常，你不一定真要回答出 5 个具体的系统异常，但你要能够说出什么是系统异常，以及<br>几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，<br>那就用中文吧，有总比没有强！<br>所 谓 系 统 异 常 ， 就 是 ….. ， 它 们 都 是 RuntimeException 的 子 类 ， 在 jdk doc 中 查<br>RuntimeException 类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比<br>较 有 印 象 的 系 统 异 常 有 ： NullPointerException 、 ArrayIndexOutOfBoundsException 、<br>ClassCastException。<br>31. java 如何进行异常处理，throws,throw,try,catch,finally 代表什么意义？在 try 块中可<br>以抛出异常吗？<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。<br>在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到<br>这个异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一<br>个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来<br>处理；<br>try 用来指定一块预防所有“异常”的程序；<br>catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的类型；<br>throw 语句用来明确地抛出一个“异常”；<br>throws 用来标明一个成员函数可能抛出的各种“异常”；<br>finally 为确保一段代码不管发生什么“异常”都被执行一段代码；<br>可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try 语<br>句保护其他代码。每当遇到一个 try 语句，“异常”的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇<br>到有处理这种“异常”的 try 语句。<br>32. 在 java 中如何进行 socket 编程。<br>答：Sockets 有两种主要的操作方式:面向连接的和无连接的。<br>无连接的操作使用数据报协议.这个模式下的 socket 不需要连接一个目的的 socket,它只是简<br>单地投出数据报.无连接的操作是快速的和高效的,但是数据安全性不佳.面向连接的操作使<br>用 TCP 协议.一个这个模式下的 socket 必须在发送数据之前与目的地的 socket 取得一个连接. 一旦连接建立了,sockets 就可以使用一个流接口:打开-读-写-关闭.所有的发送的信息都会在<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>另一端以同样的顺序被接收.面向连接的操作比无连接的操作效率更低,但是数据的安全性更<br>高. 在服务器，使用 ServerSocket 监听指定的端口，端口可以随意指定（由于 1024 以下的端口<br>通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于 1024 的端口），<br>等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。在客户端，使用<br>Socket 对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话<br>完成后，关闭 Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个 1024<br>以上的端口。<br>40. 线程的基本概念、线程的基本状态以及状态之间的关系<br>一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程<br>上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，<br>即 main 方法执行的那个线程。如果只是一个 cpu，它怎么能够同时执行多段程序呢？这是<br>从宏观上来看的，cpu 一会执行 a 线索，一会执行 b 线索，切换时间很快，给人的感觉是 a,b<br>在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一<br>会为 a 传数据，一会为 b 传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。<br>状态：就绪，运行，synchronize 阻塞，wait 和 sleep 挂起，结束。wait 必须在 synchronized<br>内部调用。<br>调用线程的 start 方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状<br>态，遇到 synchronized 语句时，由运行状态转为阻塞，当 synchronized 获得锁后，由阻塞转<br>为运行，在这种情况可以调用 wait 方法转为挂起状态，当线程关联的代码执行完后，线程<br>变为结束状态。<br>44. 介绍 Collection 框架的结构<br>答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。<br>Collection<br>├List<br>│├LinkedList<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>│├ArrayList<br>│└Vector<br>│ └Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap<br>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素<br>（Elements）<br>Map 提供 key 到 value 的映射<br>45. Collection 框架中实现比较要实现什么接口<br>comparable&#x2F;comparator<br>46. ArrayList 和 Vector 的区别<br>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存<br>储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位<br>置索引号取出某个元素，并且其中的数据是允许重复的，这是 HashSet 之类的集合的最大不<br>同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本<br>来题目问的与 hashset 没有任何关系，但为了说清楚 ArrayList 与 Vector 的功能，我们使用对<br>比方式，更有利于说明问题）。<br>接着才说 ArrayList 与 Vector 的区别，这主要包括两个方面：. （1）同步性：<br>Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安<br>全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用<br>ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是<br>使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。<br>(备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全问题，记住 Vector 与<br>Hashtable 是旧的，是 java 一诞生就提供的，它们是线程安全的，ArrayList 与 HashMap 是 java2<br>时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。)<br>（2）数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量<br>时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加一个<br>存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率<br>之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没<br>有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始<br>的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方<br>法。<br>总结：即 Vector 增长原来的一倍，ArrayList 增加原来的 0.5 倍。<br>49. List, Set, Map 是否继承自 Collection 接口?<br>List，Set 是，Map 不是<br>50. List、Map、Set 三个接口，存取元素时，各有什么特点？<br>这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内<br>容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不<br>明白。<br>首先，List 与 Set 具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接<br>口，叫 Collection。Set 里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不<br>是仅仅是相同）的对象 ，即假设 Set 集合中有了一个 A 对象，现在我要向 Set 集合再存入<br>一个 B 对象，但 B 对象与 A 对象 equals 相等，则 B 对象存储不进去，所以，Set 集合的 add<br>方法有一个 boolean 的返回值，当集合中没有某个元素，此时 add 方法可成功加入该元素时，<br>则返回 true，当集合含有与某个元素 equals 相等的元素时，此时 add 方法无法加入该元素，<br>返回结果为 false。Set 取元素时，没法说取第几个，只能以 Iterator 接口取得所有的元素，<br>再逐一遍历各个元素。<br>List 表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我<br>们多次调用 add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>到的顺序排序。有时候，也可以插队，即调用 add(int index,Obj e)方法，就可以指定当前对<br>象在集合中的存放位置。一个对象可以被反复存储进 List 中，每调用一次 add 方法，这个对<br>象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用<br>一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指向了<br>这个对象，如图 x 所示。List 除了可以以 Iterator 接口取得所有的元素，再逐一遍历各个元<br>素之外，还可以调用 get(index i)来明确说明取第几个。<br>Map 与 List 和 Set 不同，它是双列的集合，其中有 put 方法，定义如下：put(obj key,obj value)，<br>每次存储时，要存储一对 key&#x2F;value，不能存储重复的 key，这个重复的规则也是按 equals<br>比较相等。取则可以根据 key 获得相应的 value，即 get(Object key)返回值为 key 所对应的<br>value。另外，也可以获得所有的 key 的结合，还可以获得所有的 value 的结合，还可以获得<br>key 和 value 组合成的 Map.Entry 对象的集合。<br>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存<br>key-value 值，value 可多值。<br>HashSet 按照 hashcode 值的某种运算方式进行存储，而不是直接按 hashCode 值的大小进行<br>存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65 在 hashSet 中的存储顺序不是 62,65,78，<br>LinkedHashSet 按插入的顺序存储，那被存储对象的 hashcode 方法还有什么作用呢？我们想<br>想!hashset 集合比较两个对象是否相等，首先看 hashcode 方法是否相等，然后看 equals 方法<br>是否相等。new 两个 Student 插入到 HashSet 中，看 HashSet 的 size，实现 hashcode 和 equals<br>方法后再看 size。<br>同一个对象可以在 Vector 中加入多次。往集合里面加元素，相当于集合里用一根绳子连接<br>到了目标对象。往 HashSet 中却加不了多次的。<br>51. 说出 ArrayList,Vector, LinkedList 的存储性能和特性<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增<br>加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存<br>操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），<br>通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进<br>行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。<br>LinkedList 也是线程不安全的，LinkedList 提供了一些方法，使得 LinkedList 可以被当作堆<br>栈和队列来使用。<br>52. 去掉一个 Vector 集合中重复的元素<br>Vector newVector &#x3D; new Vector();<br>For (int i&#x3D;0;i&lt;vector.size();i++){<br>Object obj &#x3D; vector.get(i);<br>53. if(!newVector.contains(obj);<br>newVector.add(obj);<br>}<br>还有一种简单的方式，HashSet set &#x3D; new HashSet(vector);<br>54. Collection 和 Collections 的区别。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>Collection： 是集合类的上级接口，继承与他的接口主要有 Set 和 List. Collections：是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、<br>排序、线程安全化等操作。<br>55. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是<br>equals()? 它们有何区别?<br>Set 里的元素是不能重复的，元素重复与否是使用 equals()方法进行判断的。<br>equals()和&#x3D;&#x3D;方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个分<br>离的对象的内容和类型相配的话，返回真值。<br>56. 链表和数组的区别？<br>创建数组时，必须明确说明数组的长度,(即数组中元素的个数),以便在内存中留出一块空间<br>存放所有的数组元素,数组中各数据元素在内存中是顺序存放的。<br>创建链表时，不需要给出链表中元素(称为节点)的个数,可以先只创建一个链表头,其他元素<br>在需要时动态地创建并加入到链表,链表的数据无素在内存中不是连续存放的。<br>57. 你所知道的集合类都有哪些？主要方法？<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变<br>大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索<br>引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），<br>其中每个键映射到一个值。<br>ArrayList&#x2F;VectorList<br>Collection<br>HashSet&#x2F;TreeSetSet<br>PropetiesHashTable<br>Map<br>Treemap&#x2F;HashMap<br>我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，<br>我记得不是很清楚，对于 set，大概的方法是 add,remove, contains；对于 map，大概的方法<br>就是 put,remove，contains 等，因为，我只要在 eclispe 下按点操作符，很自然的这些方法就<br>出来了。我记住的一些思想就是 List 类会有 get(int index)这样的方法，因为它可以按顺序取<br>元素，而 set 类中没有 get(int index)这样的方法。List 和 set 都可以迭代出所有元素，迭代时<br>先要得到一个 iterator 对象，所以，set 和 list 类都有一个 iterator 方法，用于返回那个 iterator<br>对象。map 可以返回三个集合，一个是返回所有的 key 的集合，另外一个返回的是所有 value<br>的集合，再一个返回的 key 和 value 组合成的 EntrySet 对象的集合，map 也有 get 方法，参<br>数是 key，返回值是 key 对应的 value。<br>58. 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code，这句话对不对?<br>对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode<br>值就必须相等。<br>如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode<br>不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没有理由不实<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>现，通常都会去实现的。<br>59. TreeSet 里面放对象，如同时放入父类和子类实例对象，比较时使用的是父类的<br>compareTo 方法，还是子类的 compareTo 方法，还是抛异常！<br>（应该是没有针对问题的确切的答案，当前的 add 方法放入的是哪个对象，就调用哪个对象<br>的 compareTo 方法，至于这个 compareTo 方法怎么做，就看当前这个对象的类中是如何编写<br>这个方法的）</p><ol start="60"><li><p>说出一些常用的类，包，接口，请各举 5 个<br>要让人家感觉你对 java ee 开发很熟，所以，不能仅仅只列 core java 中的那些东西，要多列<br>你在做 ssh 项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。<br>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer<br>java.util.Date，System，Class，List,HashMap<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>常 用 的 包 ： java.lang java.io java.util<br>java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate<br>常 用 的 接 口 ： Remote List Map Document<br>NodeList ,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate) 、<br>Session(Hibernate),HttpSession</p></li><li><p>java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出<br>他们分别是哪些类？<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于 InputStreamReader<br>OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</p></li><li><p>字节流与字符流的区别<br>要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数<br>据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进<br>行描述，这个抽象描述方式起名为 IO 流，对应的抽象类为 OutputStream 和 InputStream ，<br>不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。<br>在实际应用中，经常需要把完全是字符的一段文本输出去或读进来，用字节流可以吗？计算<br>机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的<br>字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，<br>我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。<br>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进<br>行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写<br>入底层设备，这为我们向 IO 设别写入或读取字符串提供了一点点方便。<br>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某<br>种编码的字节形式，读取也是反之的道理。<br>讲解字节流与字符流关系的代码案例：</p></li><li><p>描述一下 JVM 加载 class 文件的原理机制?<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的 Java<br>运行时系统组件。它负责在运行时查找和装入类文件的类。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p></li><li><p>heap 和 stack 有什么区别。<br>java 的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会<br>为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结<br>束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。<br>堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new<br>创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final<br>修饰后，放在堆中，而不是栈中。</p></li><li><p>GC 是什么? 为什么要有 GC?<br>GC：垃圾回收，使用 GC 可以进行垃圾空间释放操作。<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘<br>记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动<br>监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存<br>的显示操作方法。</p></li><li><p>垃圾回收的优点和原理。并考虑 2 种回收机制。<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的问<br>题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾<br>回收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收<br>可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的<br>低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进<br>行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回<br>收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。<br>简单答法:将无用的空间对象进行释放. 俩中回收机制:自动回收和手工调用 System.gc()方法,实际上调用 System.gc 就相当于调用了<br>Runtime.getRuntime().gc()方法. 104. 垃圾回收器的基本原理是？垃圾回收器可以马上回收内存吗？如何主动通知虚拟机<br>进行垃圾回收？<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对<br>象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回<br>收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。</p></li><li><p>什么时候用 assert。<br>JDK1.4 之后增加的新关键字——assert，表示断言，即程序执行到某个地方之后值肯定是预<br>计好的；一般开发中很少使用 assert；要想使用断言，就必须使用-ea 参数。<br>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在<br>实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确<br>的状态下，assert 将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正<br>确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检<br>查通常是关闭的。</p></li><li><p>java 中会存在内存泄漏吗，请简单描述。<br>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java 中有垃圾<br>回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被<br>垃圾回收器从内存中清除掉。由于 Java 使用有向图的方式进行垃圾回收管理，可以消除引<br>用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可<br>以回收它们的，例如下面的代码可以看到这种情况的内存回收：</p></li></ol><p>java 中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存<br>泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不<br>能被回收，这就是 java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对<br>象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃<br>圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了<br>一个对象放在缓存中(例如放在一个全局 map 对象中)，然后一直不再使用它，这个对象一直<br>被缓存引用，但却不再被使用。<br>检查 java 中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某<br>个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。<br>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引<br>用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外<br>部类对象将不会被垃圾回收，这也会造成内存泄露。<br>下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，<br>而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中<br>消失，将那个元素所在的位置的值设置为 null 即可）：<br>我实在想不到比那个堆栈更经典的例子了,以致于我还要引用别人的例子，下面的例子不是<br>我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可<br>是那时我说是我自己想到的也没有人相信的。</p><p>上面的原理应该很简单，假如堆栈加了 10 个元素，然后全部弹出来，虽然堆栈是空的，没<br>有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，<br>无法回收。<br>但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪<br>费了几个 K 内存而已，反正我们的内存都上 G 了，哪里会有什么影响，再说这个东西很快<br>就会被回收的，有什么关系。下面看两个例子。<br>例子 1</p><p>因为是 static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果<br>你的 Stack 最多有 100 个对象，那么最多也就只有 100 个对象无法被回收其实这个应该很容<br>易理解，Stack 内部持有 100 个引用，最坏的情况就是他们都是无用的，因为我们一旦放新<br>的进取，以前的引用自然消失！<br>内存泄露的另外一种情况：当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合<br>中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的<br>参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet<br>集合中单独删除当前对象，造成内存泄露。<br>70. 能不能自己写个类，也叫 java.lang.String？<br>可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去<br>加载 jre.jar 包中的那个 java.lang.String。由于在 tomcat 的 web 应用程序中，都是由 webapp<br>自己的类加载器先自己加载 WEB-INF&#x2F;classess 目录中的类，然后才委托上级的类加载器加<br>载，如果我们在 tomcat 的 web 应用程序中写一个 java.lang.String，这时候 Servlet 程序加载<br>的就是我们自己写的 java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了<br>java.lang.String 类的都将出现问题。<br>虽然 java 提供了 endorsed 技术，可以覆盖 jdk 中的某些类，具体做法是….。但是，能够被<br>覆盖的类是有限制范围，反正不包括 java.lang 这样的包中的类。<br>（下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题<br>目泄露了）例如，运行下面的程序：<br>package java.lang;<br>public class String {<br>public static void main(String[] args) {<br>System.out.println(“string”);<br>}<br>}<br>报告的错误如下：<br>java.lang.NoSuchMethodError: main<br>Exception in thread “main” 这是因为加载了 jre 自带的 java.lang.String，而该类中没有 main 方法。 二、Java 代码查错<br>abstract class Name {<br>private String name;<br>public abstract boolean isStupidName(String name) {}<br>}<br>大侠们，这有何错误?<br>答案: 错。abstract method 必须以分号结尾，且不带花括号。<br>2.public class Something {<br>void doSomething () {<br>private String s &#x3D; “”;<br>int l &#x3D; s.length();<br>}<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有错吗?<br>答案: 错。局部变量前不能放置任何访问修饰符 (private，public，和 protected)。final 可以<br>用来修饰局部变量<br>(final 如同 abstract 和 strictfp，都是非访问修饰符，strictfp 只能修饰 class 和 method 而非<br>variable)。<br>3.abstract class Something {<br>private abstract String doSomething ();<br>}<br>这好像没什么错吧?<br>答案: 错。abstract 的methods不能以private修饰。abstract的 methods就是让子类 implement(实<br>现)具体细节的，怎么可以用 private 把 abstract<br>method 封锁起来呢? (同理，abstract method 前不能加 final)。<br>4.public class Something {<br>public int addOne(final int x) {<br>return ++x;<br>}<br>}<br>这个比较明显。<br>答案: 错。int x 被修饰成 final，意味着 x 不能在 addOne method 中被修改。<br>5.public class Something {<br>public static void main(String[] args) {<br>Other o &#x3D; new Other();<br>new Something().addOne(o);<br>}<br>public void addOne(final Other o) {<br>o.i++;<br>}<br>}<br>class Other {<br>public int i;<br>}<br>和上面的很相似，都是关于 final 的问题，这有错吗?<br>答案: 正确。在 addOne method 中，参数 o 被修饰成 final。如果在 addOne method 里我们修<br>改了 o 的 reference<br>(比如: o &#x3D; new Other();)，那么如同上例这题也是错的。但这里修改的是 o 的 member vairable<br>(成员变量)，而 o 的 reference 并没有改变。<br>6.class Something {<br>int i;<br>public void doSomething() {<br>System.out.println(“i &#x3D; “ + i);<br>}<br>}<br>有什么错呢? 看不出来啊。<br>答案: 正确。输出的是”i &#x3D; 0”。int i 属於 instant variable (实例变量，或叫成员变量)。instant<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>variable 有 default value。int 的 default value 是 0。<br>7.class Something {<br>final int i;<br>public void doSomething() {<br>System.out.println(“i &#x3D; “ + i);<br>}<br>}<br>和上面一题只有一个地方不同，就是多了一个 final。这难道就错了吗?<br>答案: 错。final int i 是个 final 的 instant variable (实例变量，或叫成员变量)。final 的 instant<br>variable 没有 default value，必须在 constructor (构造器)结束之前被赋予一个明确的值。可以<br>修改为”final int i &#x3D; 0;”。<br>8.public class Something {<br>public static void main(String[] args) {<br>Something s &#x3D; new Something();<br>System.out.println(“s.doSomething() returns “ + doSomething());<br>}<br>public String doSomething() {<br>return “Do something …”;<br>}<br>}<br>看上去很完美。<br>答案: 错。看上去在 main 里 call doSomething 没有什么问题，毕竟两个 methods 都在同一个<br>class 里。但仔细看，main 是 static 的。static method 不能直接 call non-static methods。可改<br>成”System.out.println(“s.doSomething() returns “ + s.doSomething());”。同理，static method 不<br>能访问 non-static instant variable。<br>9.此处，Something 类的文件名叫 OtherThing.java<br>class Something {<br>private static void main(String[] something_to_do) {<br>System.out.println(“Do something …”);<br>}<br>}<br>这个好像很明显。<br>答案: 正确。从来没有人说过 Java 的 Class 名字必须和其文件名相同。但 public class 的名字<br>必须和文件名相同。<br>10．interface A{<br>int x &#x3D; 0;<br>}<br>class B{<br>int x &#x3D;1;<br>}<br>class C extends B implements A {<br>public void pX(){<br>System.out.println(x);<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public static void main(String[] args) {<br>new C().pX();<br>}<br>}<br>答案：错误。在编译时会发生错误(错误描述不同的 JVM 有不同的信息，意思就是未明确的<br>x 调用，两个 x 都匹配（就象在同时 import java.util 和 java.sql 两个包时直接声明 Date 一样）。<br>对于父类的变量,可以用 super.x 来明确，而接口的属性默认隐含为 public static final.所以可<br>以通过 A.x 来明确。<br>11.interface Playable {<br>void play();<br>}<br>interface Bounceable {<br>void play();<br>}<br>interface Rollable extends Playable, Bounceable {<br>Ball ball &#x3D; new Ball(“PingPang”);<br>}<br>class Ball implements Rollable {<br>private String name;<br>public String getName() {<br>return name;<br>}<br>public Ball(String name) {<br>this.name &#x3D; name;<br>}<br>public void play() {<br>ball &#x3D; new Ball(“Football”);<br>System.out.println(ball.getName());<br>}<br>}<br>这个错误不容易发现。<br>答案: 错。”interface Rollable extends Playable, Bounceable”没有问题。interface 可继承多个<br>interfaces，所以这里没错。问题出在 interface Rollable 里的”Ball ball &#x3D; new Ball(“PingPang”);”。<br>任何在 interface 里声明的 interface variable (接口变量，也可称成员变量)，默认为 public static<br>final。也就是说”Ball ball &#x3D; new Ball(“PingPang”);”实际上是”public static final Ball ball &#x3D; new<br>Ball(“PingPang”);”。在 Ball 类的 Play()方法中，”ball &#x3D; new Ball(“Football”);”改变了 ball 的<br>reference，而这里的 ball 来自 Rollable interface，Rollable interface 里的 ball 是 public static final<br>的，final 的 object 是不能被改变 reference 的。因此编译器将在”ball &#x3D; new Ball(“Football”);” 这里显示有错。 三、算法与编程<br>71. 用 java 实现一种排序；java 类实现序列化的方法(二种)？ 如在 collection 框架中，<br>实现比较要实现什么样的接口？</p><p>JAVA 类实现序例化的方法是实现 java.io.Serializable 接口<br>Collection 框架中实现比较要实现 Comparable 接口和 Comparator 接口<br>127. 说说你用过那些 ajax 技术和框架，说说它们的区别<br>答:去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存<br>五、Java web 部分<br>128. Tomcat 的优化经验<br>答:去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。<br>有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存<br>129. HTTP 的请求过程？<br>当点击一个链接时,浏览器首先找到站点的 IP 地址,这是通过 DNS 来实现的,在找到 IP 地址后<br>就可以建立 TCP 连接了,连接建立后我们就可以发送请求了.但这个请求是什么样子的呢 ?<br>我们现在假设点击了一个从 <a target="_blank" rel="noopener" href="http://www.webmonkey.com/HTML/96/47/Index2A">www.webmonkey.com/HTML/96/47/Index2A</a> , HTML 点击了<br><a href="WWW.GRIPY.ORG/MATTARG/">WWW.GRIPY.ORG/MATTARG/</a> 这时浏览器会发出下面的请求:<br>Get&#x2F;MATTARG&#x2F;HTML&#x2F;1.0<br>User-Agent: Mozilla&#x2F;2.0(macitosh;1;PPC)<br>Accept: text&#x2F;html: <em>&#x2F;</em> Cookie: name &#x3D; value<br>Refetet: <a target="_blank" rel="noopener" href="http://www.webmonkey.com/html/96/47/index2a.html">http://www.webmonkey.com/html/96/47/index2a.html</a><br>Host: <a target="_blank" rel="noopener" href="http://www.gtippy.org/">www.gtippy.org</a><br>第一行称为请求,它告诉服务器从 MATTMARG 取得文件,这是的目录一般是要加 &#x2F; 的,下面<br>几行通知服务器你所使用的浏览器是什么类型,你所接收的数据是什么类型,如果你以前访问<br>过这个站点,站点可能向你发送了 Cookie ,如果你已经有了一个这样的 Cookie ,浏览器会将<br>这个 Cookie 返回给服务器, referer 行通知服务器用户从哪一页到达此页的. 下面服务器就要返回文件了,每次服务器返回文件时,都要返回一个 Http&#x2F;1.0 响应,同进带有<br>状态码,在此之后是述内部的头信息,下面就是一个响应:<br>HTTP&#x2F;1.0 200 Pound<br>Data: Mon 10 Feb 1997 23:48:22 GMT<br>Server: Apache&#x2F;1.1 1 Hot&amp;ired&#x2F;1.0<br>Content-type: text&#x2F;html<br>Last-Moditied: Tues,11 Feb 1997 22:45:55 GMT<br>不同的数据可能返回不同的 Content-type ，因此不同的内容需要不同的 Content-type ，因<br>此有时候这个过程是很慢的。<br>130. HTTP 请求的 GET 与 POST 方式的区别<br>答：Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST<br>方法。二者主要区别如下：<br>1）Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据；<br>2）Get 将表单中数据按照 variable&#x3D;value 的形式，添加到 action 所指向的 URL 后面，<br>并且两者使用“?”连接，而各个变量之间使用“&amp;”连接；Post 是将表单中的数据放在 form<br>的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL；<br>3）Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中；Post 的所有操作对<br>用户来说都是不可见的；<br>4）Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，<br>所以在上传文件只能使用 Post；<br>5）Get 限制 Form 表单的数据集必须为 ASCII 字符，而 Post 支持整个 ISO10646 字符集；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>6）Get 是 Form 的默认方法。<br>131. 解释一下什么是 servlet？<br>Servlet 是一种独立于平台和协议的服务器端的 Java 技术，可以用来生成动态的 Web 页面。<br>与传统的 CGI（计算机图形接口）和许多其他类似 CGI 技术相比，Servlet 具有更好的可移<br>植性、更强大的功能，更少的投资，更高的效率，更好的安全性等特点。<br>Servlet 是使用 Java Servlet 应用程序接口（API）及相关类和方法的 Java 程序。Java 语言<br>能够实现的功能，Servlet 基本上都能实现（除了图形界面之外）。Servlet 主要用于处理客<br>户端传来的 Http 请求，并返回一个响应。通常所说的 Servlet 就是指 HttpServlet，用于处理<br>Http 请求，其能够处理的请求有 doGet()、doPost()、service()等方法。在开发 Servlet 时，可<br>以直接继承 javax.servlet.http.HttpServlet。<br>Servlet 需要在 web.xml 中进行描述，例如：映射执行 Servlet 的名字，配置 Servlet 类、初<br>始化参数，进行安全配置、URL 映射和设置启动的优先权等。Servlet 不仅可以生成 HTML<br>脚本输出，也可以生成二进制表单输出。<br>Servlet 应用范围很广泛，我们现在用的很多流行的框架技术，其最基本的代码离不开<br>Servelt 的支持。比如我所熟悉的 SSH 框架，Spring 容器启动时，要在 web.xml 中装载 Spring<br>容器的 ActionContext 类来初始化 Spring 的一些参数，如进行依赖注入、数据库表的映射、<br>初始化系统的安全配置设置 read 等属性等一些相关操作。<br>132. 说一说 Servlet 的生命周期?<br>答:servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。<br>这个生存期由 javax.servlet.Servlet 接口的 init,service 和 destroy 方法表达。<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service<br>方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销<br>毁的时候调用其 destroy 方法。<br>web 容器加载 servlet，生命周期开始。通过调用 servlet 的 init()方法进行 servlet 的初始化。<br>通过调用 service()方法实现，根据请求的不同调用不同的 do***()方法。结束服务，web 容<br>器调用 servlet 的 destroy()方法。<br>133. Servlet 的基本架构<br>package test;<br>import java.io.IOException;<br>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>public class ServletName extends HttpServlet {<br>public void doPost(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public void doGet(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>}<br>}<br>134. SERVLET API 中 forward()与 redirect()的区别？<br>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后<br>者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的<br>地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量<br>使用 forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳<br>转到一个其它服务器上的资源，则必须使用 sendRedirect()方法。<br>135. 什么情况下调用 doGet()和 doPost()？<br>Jsp 页面中的 FORM 标签里的 method 属性为 get 时调用 doGet()，为 post 时调用 doPost()。<br>136. Request 对象的主要方法：<br>setAttribute(String name,Object)：设置名字为 name 的 request 的参数值<br>getAttribute(String name)：返回由 name 指定的属性值<br>getAttributeNames()：返回 request 对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有 Cookie 对象，结果是一个 Cookie 数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的 Body 的长度<br>getHeader(String name)：获得 HTTP 协议定义的文件头信息<br>getHeaders(String name)：返回指定名字的 request Header 的所有值，结果是一个枚举的实例<br>getHeaderNames()：返回所以 request Header 的名字，结果是一个枚举的实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有 name 指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实<br>例<br>getParametervalues(String name)：获得有 name 指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的 IP 地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关 Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性<br>137. 简述 HttpSession 的作用、使用方法，可用代码说明。<br>HttpSession 中 可 以 跟 踪 并 储 存 用 户 信 息 ， 把 值 设 置 到 属 性 中 ， 有 2 个 方 法 ：<br>setAttribute(),getAttrribute()；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>例如：在一个方法中用 session.setAttribute(“student”,student);在 session 中设置一个属性名为<br>student,值为一个名为 student 的对象。而后可在同一 session 范围内用 getAttribute(“student”)<br>取出该属性，得到 student 对象。<br>138. 请画出 Servlet 2.2 以上 Web Application 的基本目录结构<br>答：目录结构如下图所示：<br>webapps<br>|<br>Applocation<br>| __________________<br>| |<br>JSP 页面 WEB-INF<br>| ___________________<br>| | |<br>classes lib web.xml<br>139. cookie 和 session 的区别？<br>注意 cookie 有时候禁不掉<br>Cookie session<br>存储在客户端 存储在服务器端<br>两种类型<br>有声明周期<br>无声明周期<br>两种实现方式<br>依赖于 cookie<br>url 重写<br>父路径不能访问子路径的 cookie 同一个 session 的窗口共享一个 session<br>典型应用：<br>3 个月不用再登陆<br>购物车（<a target="_blank" rel="noopener" href="http://www.china-pub.com/%EF%BC%89">http://www.china-pub.com/）</a><br>典型应用：<br>用户登陆<br>购物车也可以用 session 实现。·<br>不可靠 可靠<br>140. forward 和 redirect 的区别<br>forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读<br>取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，<br>所以它的地址栏中还是原来的地址。<br>redirect 就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏<br>览器会用刚才请求的所有参数重新请求，所以 session,request 参数都可以获取。<br>141. request.getAttribute() 和 request.getParameter() 有何区别?<br>当你要传递普通的数据类型给下一个页面时，你在下一个页面中就可以用 getParameter()方<br>法来获得上一个页面传递过来的数据了！（普通的数据类型是指 int,float,double,string 等在<br>Java 中常用的基本类型，但是在下一个页面中你用 getParameter()方法获得的值永远只能时<br>String 类型的，你可以把 String 类型转换为你所需要的类型！）<br>当你要传递一个对象给下一个页面时，你就要使用 getAttribut()方法了！如：你要把一个 List<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>或 Map 传递到下一个页面，这时你就必须要用 setAttribut()和 getAttribut()方法传递数据了！<br>从更深层次的考虑，getParameter()方法传递数据，只会从 WEB 客户端传递到 WEB 服务器，<br>代表 HTTP 请求数据，getParameter()方法返回 String 类型的数据！setAttribut()和 getAttribut()<br>方法传递的数据只会在 WEB 服务器内部，在具有转发关系的 WEB 组件之间传递，这两个<br>方法能设置 Object 类型的共享数据！<br>142. jsp 有哪些内置对象?作用分别是什么? 分别有什么方法？<br>答:JSP 共有以下 9 个内置的对象：<br>request 用户端请求，此请求会包含来自 GET&#x2F;POST 请求的参数<br>response 网页传回用户端的回应<br>pageContext 网页的属性是在这里管理<br>session 与请求有关的会话期<br>application servlet 正在执行的内容<br>out 用来传送回应的输出<br>config servlet 的构架部件<br>page JSP 网页本身<br>exception 针对错误网页，未捕捉的例外<br>request：表示 HttpServletRequest 对象。它包含了有关浏览器请求的信息，并且提供了几个<br>用于获取 cookie, header, 和 session 数据的有用的方法。<br>response：表示 HttpServletResponse 对象，并提供了几个用于设置送回 浏览器的响应的方法<br>（如 cookies,头信息等）<br>out：对象是 javax.jsp.JspWriter 的一个实例，并提供了几个方法使你能用于向浏览器回送输<br>出结果。<br>pageContext：表示一个 javax.servlet.jsp.PageContext 对象。它是用于方便存取各种范围的名<br>字空间、servlet 相关的对象的 API，并且包装了通用的 servlet 相关功能的方法。<br>session：表示一个请求的 javax.servlet.http.HttpSession 对象。Session 可以存贮用户的状态信<br>息<br>applicaton ：表示一个 javax.servle.ServletContext 对象。这有助于查找有关 servlet 引擎和<br>servlet 环境的信息<br>config：表示一个 javax.servlet.ServletConfig 对象。该对象用于存取 servlet 实例的初始化参<br>数。<br>page：表示从该页面产生的一个 servlet 实例<br>143. 介绍在 JSP 中如何使用 JavaBeans？<br>答：在 JSP 中使用 JavaBean 常用的动作有：<br>1）&lt;jsp:useBean &#x2F;&gt;：用来创建和查找 bean 对象；<br>2）&lt;jsp:setProperty &#x2F;&gt;：用来设置 bean 的属性，即调用其 setXxx()方法；<br>3）&lt;jsp:getProperty &#x2F;&gt;：用来获得 bean 的属性，即调用其 getXxx()方法。<br>144. jsp 有哪些动作?作用分别是什么?<br>（这个问题似乎不重要，不明白为何有此题）<br>答:JSP 共有以下 6 种基本动作<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>jsp:setProperty：设置 JavaBean 的属性。<br>jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记<br>145. JSP 的常用指令<br>isErrorPage(是否能使用 Exception 对象)，isELIgnored(是否忽略表达式)<br>146. jsp 的四种范围？<br>答：a.page 是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类<br>（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括<br>被编译成 servlet 的 JSP 页面<br>b.request 是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越<br>多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系）<br>c.session 是代表与用于某个 Web 客户机的一个用户体验相关对象和属性。一个 Web<br>会话可以也经常会跨越多个客户机请求<br>d.application 是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个<br>Web 应用程序，包括多个页面、请求和会话的一个全局作用域。<br>147. JSP 中动态 INCLUDE 与静态 INCLUDE 的区别？<br>答：动态 INCLUDE 用 jsp:include 动作实现<br>&lt;jsp:include page&#x3D;included.jsp flush&#x3D;true &#x2F;&gt;它总是会检查所含文件中的变化，适合用于包含动<br>态页面，并且可以带参数 静态 INCLUDE 用 include 伪码实现,定不会检查所含文件的变化，<br>适用于包含静态页面 &lt;%@ include file&#x3D;included.htm %&gt;<br>148. 两种跳转方式分别是什么?有什么区别?<br>（下面的回答严重错误，应该是想问 forward 和 sendRedirect 的区别，毕竟出题的人不是专<br>业搞文字艺术的人，可能表达能力并不见得很强，用词不一定精准，加之其自身的技术面也<br>可能存在一些问题，不一定真正将他的意思表达清楚了，严格意思上来讲，一些题目可能根<br>本就无人能答，所以，答题时要掌握主动，只要把自己知道的表达清楚就够了，而不要去推<br>敲原始题目的具体含义是什么，不要一味想着是在答题）<br>答：有两种，分别为：<br>&lt;jsp:include page&#x3D;included.jsp flush&#x3D;true&gt;<br>&lt;jsp:forward page&#x3D; nextpage.jsp&#x2F;&gt;<br>前者页面不会转向 include 所指的页面，只是显示该页的结果，主页面还是原来的页面。执<br>行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。<br>相当于 go to 语句. 149. 页面间对象传递的方法<br>request，session，application，cookie 等<br>150. 过滤器有哪些作用？<br>答：可以验证客户是否来自可信的网络，可以对客户提交的数据进行重新编码，可以从系统<br>里获得配置的信息，可以过滤掉客户的某些不应该出现的词汇，可以验证用户是否登录，可<br>以验证客户的浏览器是否支持当前的应用，可以记录系统的日志等等。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>151. 过滤器的用法？（对客户端的请求统一编码和对客户端进行认证）<br>答：首先要实现（implements）Filter 接口，同时覆盖 Filter 接口的三个方法：<br>init(FilterConfig config) &#x2F;&#x2F;用于获得 FilterConfig 对象；<br>doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &#x2F;&#x2F;进行过滤处<br>理一些业务；<br>destroy() &#x2F;&#x2F;销毁 Filter。<br>152. JSP 和 Servlet 中的请求转发分别如何实现？<br>答：JSP 中的请求转发可利用 forward 动作实现：&lt;jsp:forward &#x2F;&gt;；<br>Serlvet 中实现请求转发的方式为：<br>getServletContext().getRequestDispatcher(path).forward(req,res)。<br>153. JSP 和 Servlet 有哪些相同点和不同点，他们之间的联系是什么？<br>JSP 是 Servlet 技术的扩展，本质上是 Servlet 的简易方式，更强调应用的外表表达。JSP 编<br>译后是”类 servlet”。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件<br>中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成<br>一个扩展名为.jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。<br>154. 详细描述 MVC。<br>答：基于 Java 的 Web 应用系统采用 MVC 架构模式，即 model（模型）、view（视图）、control<br>（控制）分离设计；这是目前 WEB 应用服务系统的主流设计方向。<br>Model：即处理业务逻辑的模块，每一种处理一个模块；<br>View：负责页面显示，显示 MODEL 处理结果给用户，主要实现数据到页面转换过程；<br>Control：负责每个请求的分发，把 FORM 数据传递给 MODEL 处理，把处理结果的数<br>据传递给 VIEW 显示。<br>155. MVC 的各个部分都有那些技术来实现?如何实现?<br>答:MVC 是 Model－View－Controller 的简写。Model 代表的是应用的业务逻辑（通过<br>JavaBean，EJB 组件实现）， View 是应用的表示面（由 JSP 页面产生），Controller 是提<br>供应用的处理过程控制（一般是一个 Servlet），通过这种设计模型把应用逻辑，处理过程<br>和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。<br>156. 在 web 应用开发过程中经常遇到输出某种编码字符，如 iso8859-1 等，如何输出一个<br>某种编码字符串？<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1”), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>157. 现在输入 n 个数字，以逗号，分开；然后可选择升或者降序排序；按提交键就在另一<br>页面显示按什么排序，结果为，提供 reset.(答案有点疑惑,问题有点不清不楚)<br>答案（1） public static String[] splitStringByComma(String source){<br>if(source&#x3D;&#x3D;null||source.trim().equals(“”))<br>return null;<br>StringTokenizer commaToker &#x3D; new StringTokenizer(source,”,”);<br>String[] result &#x3D; new String[commaToker.countTokens()];<br>int i&#x3D;0;<br>while(commaToker.hasMoreTokens()){<br>result[i] &#x3D; commaToker.nextToken();<br>i++;<br>}<br>return result;<br>}<br>循环遍历 String 数组<br>Integer.parseInt(String s)变成 int 类型<br>组成 int 数组<br>Arrays.sort(int[] a), a 数组升序<br>降序可以从尾部开始输出<br>158. 说出数据连接池的工作机制是什么?<br>答：J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客<br>户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没<br>有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用<br>的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>159. javascript 的优缺点和内置对象。<br>答：1）优点：简单易用，与 Java 有类似的语法，可以使用任何文本编辑工具编写，只需要<br>浏览器就可执行程序，并且事先不用编译，逐行执行，无需进行严格的变量声明，而且内置<br>大量现成对象，编写少量程序可以完成目标；<br>2）缺点：不适合开发大型应用程序；<br>3）Javascript 有 11 种内置对象： Array、String、Date、Math、Boolean、Number、<br>Function、Global、Error、RegExp、Object。 六、数据库部分<br>160. 存储过程和函数的区别<br>存储过程是用户定义的一系列 sql 语句的集合，涉及特定表或其它对象的任务，用户可以调<br>用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉<br>及特定用户表。</p><ol start="162"><li>游标的作用？如何知道游标已经到了最后？<br>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS 可以判断是否到了最后，<br>通常此变量不等于 0 表示出错或到了最后。</li><li>触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何<br>区别？<br>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触<br>发器可以获取事件之前和新的字段值。 语句级触发器可以在语句执行前或后执行，而行级<br>触发在触发器所影响的每一行触发一次。</li><li>存储过程，触发器，范式，事务的概念及作用？<br>存储过程：是数据库管理系统里的一个很重要的对象。用它可以封装一些功能。把多个 SQL<br>语句封装到存储过程里面。起到封装功能的作用。类似面向对象里，封装对象的一个功能一<br>样。几乎任何可写成批处理的 Transact-SQL 代码都可用于创建存储过程。<br>触发器：触发器是在用户进行某项操作的时候，会触发触发器的执行。它类似于 JAVA 中图<br>形截面编程里的事件操作一样，是触发执行。和存储过程的主要区别在于：存储过程类似<br>JAVA 里面的对象一样，进行功能的封装（方法）。在调用的时候才会执行。而触发器只能<br>在别的操作执行的时候才会触发触发器的执行。<br>事务：类似于 JAVA 里面线程的同步一样，作为一个单元执行。它有四大特性：原子性，隔<br>离性，一致性，持久性。在 SQL SERVER 2000 里面还支持存储点的用法。大家都知道，事<br>务是做为一个单元运行，要么全部执行，要么全部不执行。但是有时候我们可以保证事务的<br>一部分可能正确执行，并且这些执行可以直接刷新到数据库里面。那么我们就可以在这个事<br>务的中间部分设置一个或者多个存储点。这样在这个事务大单元里就分成了几个小部分。如<br>果上面的部分执行正确，下面的部分执行错误，那么就没必要回滚整个事务，只需要回滚到<br>存储点的地方就可以了<br>范式：目地：规范化目的是使结构更合理，消除存储异常，使数据冗余尽量小，便于插入、<br>删除和更新<br>原则：遵从概念单一化 “一事一地”原则，即一个关系模式描述一个实体或实体间的一种联<br>系。规范的实质就是概念的单一化。<br>方法：将关系模式投影分解成两个或两个以上的关系模式。<br>要求：分解后的关系模式集合应当与原关系模式”等价”，即经过自然联接可以恢复原关系而<br>不丢失信息，并保持属性间合理联系。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</li><li>写一个 SQL Server 中的存储过程:<br>以下为一个带有一个输入参数 Vdeptno ,返回部门为 Vdeptnor 的所有职员的信息. create procedure Emp_dept<br>@Vdeptno number(2) AS<br>begin<br>select * from emp where deptno&#x3D;@Vdeptno<br>end</li><li>写一个 Oracle 中的存储过程:<br>带 IN 参数的过程<br>create or replace procedure addnew(dno IN number, name IN varchar2, location IN varchar2)IS<br>begin<br>insert into dept values(dno,name,location);<br>dbms_output.put_line(‘1 record inserted’);<br>end;<br>带 OUT 参数的过程<br>create or replace procedure getsal(name IN varchar2, salary OUT number)AS<br>begin<br>select sal into salary from emp where ename&#x3D;name;<br>end;</li><li>数据库 SQL 语句题<br>106、有 3 个表（15 分钟）：【基础】<br>Student 学生表 (学号，姓名，性别，年龄，组织部门)<br>Course 课程表 (编号，课程名称)<br>Sc 选课表 (学号，课程编号，成绩)<br>表结构如下：<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>1）写一个 SQL 语句，查询选修了’计算机原理’的学生学号和姓名（3 分钟）<br>2）写一个 SQL 语句，查询’周星驰’同学选修了的课程名字（3 分钟）<br>3）写一个 SQL 语句，查询选修了 5 门课程的学生学号和姓名（9 分钟）<br>答：1）SQL 语句如下：<br>select stu.sno, stu.sname from Student stu<br>where (select count(<em>) from sc where sno&#x3D;stu.sno and cno &#x3D;<br>(select cno from Course where cname&#x3D;’计算机原理’)) !&#x3D; 0;<br>2）SQL 语句如下：<br>select cname from Course<br>where cno in ( select cno from sc where sno &#x3D;<br>(select sno from Student where sname&#x3D;’周星驰’));<br>3）SQL 语句如下：<br>select stu.sno, stu.sname from student stu<br>where (select count(</em>) from sc where sno&#x3D;stu.sno) &#x3D; 5;<br>107、有三张表,学生表 S,课程 C,学生课程表 SC,学生可以选修多门课程,一门课程可以被多个<br>学生选修,通过 SC 表关联。【基础】<br>1）写出建表语句；<br>2）写出 SQL 语句,查询选修了所有选修课程的学生；<br>3）写出 SQL 语句,查询选修了至少 5 门以上的课程的学生。<br>答：1）建表语句如下（mysql 数据库）：<br>create table s(id integer primary key, name varchar(20));<br>create table c(id integer primary key, name varchar(20));<br>create table sc(<br>sid integer references s(id), cid integer references c(id), primary key(sid,cid)<br>);<br>2）SQL 语句如下：<br>select stu.id, stu.name from s stu<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>where (select count(<em>) from sc where sid&#x3D;stu.id) &#x3D; (select count(</em>) from c);<br>3）SQL 语句如下：<br>select stu.id, stu.name from s stu<br>where (select count(*) from sc where sid&#x3D;stu.id)&gt;&#x3D;5;<br>108、数据库表(Test)结构如下：【基础】<br>ID NAME AGE MANAGER(所属主管人 ID)<br>106 A 30 104<br>109 B 19 104<br>104 C 20 111<br>107 D 35 109<br>112 E 25 120<br>119 F 45 NULL<br>要求:列出所有年龄比所属主管年龄大的人的 ID 和名字?<br>答：SQL 语句如下：<br>select employee.name from test employee<br>where employee.age &gt; (select manager.age from test manager<br>where manager.id&#x3D;employee.manager);<br>109、有如下两张表：【中等难度】<br>表 city： 表 state：<br>欲得到如下结果：<br>City No City Name State No State Name<br>BJ 北京 （Null） （Null）<br>DL 大连 LN 辽宁<br>GZ 广州 GD 广东<br>SH 上海 （Null） （Null）<br>写相应的 SQL 语句。<br>答：SQL 语句为：<br>SELECT C.CITYNO, C.CITYNAME, C.STATENO, S.STATENAME<br>FROM CITY C, STATE S<br>WHERE C.STATENO&#x3D;S.STATENO(+)<br>ORDER BY(C.CITYNO);</li><li>用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。<br>employee:<br>eid,ename,salary,deptid;<br>select * from employee order by deptid desc,salary</li><li>列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序<br>CityNo CityName StateNo<br>BJ 北京 （Null）<br>SH 上海 （Null）<br>GZ 广州 GD<br>DL 大连 LN<br>State No State Name<br>GD 广东<br>LN 辽宁<br>SD 山东<br>NMG 内蒙古<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>创建表：<br>mysql&gt; create table employee921(id int primary key auto_increment,name varchar(5<br>0),salary bigint,deptid int);<br>插入实验数据：<br>mysql&gt; insert into employee921 values(null,’zs’,1000,1),(null,’ls’,1100,1),(null<br>,’ww’,1100,1),(null,’zl’,900,1) ,(null,’zl’,1000,2), (null,’zl’,900,2) ,(null,’z<br>l’,1000,2) , (null,’zl’,1100,2);<br>编写 sql 语句：<br>（）select avg(salary) from employee921 group by deptid;<br>（）mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 where deptid &#x3D;<br>tid);<br>效率低的一个语句，仅供学习参考使用（在 group by 之后不能使用 where，只能使用<br>having，在 group by 之前可以使用 where，即表示对过滤后的结果分组）：<br>mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 group by deptid<br>having deptid &#x3D; tid);<br>（）select count(*) ,tid<br>from (<br>select employee921.id,employee921.name,employee921.salary,employee921.deptid tid<br>from employee921<br>where salary &gt;<br>(select avg(salary) from employee921 where deptid &#x3D; tid)<br>) as t<br>group by tid ;<br>另外一种方式：关联查询<br>select a.ename,a.salary,a.deptid<br>from emp a, (select deptd,avg(salary) avgsal from emp group by deptid ) b<br>where a.deptid&#x3D;b.deptid and a.salary&gt;b.avgsal;</li><li>存储过程与触发器必须讲，经常被面试到?<br>create procedure insert_Student (_name varchar(50),_age int ,out _id int)<br>begin<br>insert into student value(null,_name,_age);<br>select max(stuId) into _id from student;<br>end;<br>call insert_Student(‘wfz’,23,@id);<br>select @id;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>mysql&gt; create trigger update_Student BEFORE update on student FOR EACH ROW<br>-&gt; select * from student;<br>触发器不允许返回结果<br>create trigger update_Student BEFORE update on student FOR EACH ROW<br>insert into student value(null,’zxx’,28);<br>mysql 的触发器目前不能对当前表进行操作<br>create trigger update_Student BEFORE update on student FOR EACH ROW<br>delete from articles where id&#x3D;8;<br>这个例子不是很好，最好是用删除一个用户时，顺带删除该用户的所有帖子<br>这里要注意使用 OLD.id<br>触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，<br>其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而 UCH<br>没有用触发器，效率和数据处理能力都很低。<br>存储过程的实验步骤：<br>mysql&gt; delimiter |<br>mysql&gt; create procedure insertArticle_Procedure (pTitle varchar(50),pBid int,out<br>pId int)<br>-&gt; begin<br>-&gt; insert into article1 value(null,pTitle,pBid); -&gt; select max(id) into pId from article1; -&gt; end; -&gt; |<br>Query OK, 0 rows affected (0.05 sec)<br>mysql&gt; call insertArticle_Procedure(‘中国北京’,1,@pid); -&gt; |<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; delimiter ;<br>mysql&gt; select @pid;<br>+——+<br>| @pid |<br>+——+<br>| 3 |<br>+——+<br>1 row in set (0.00 sec)<br>mysql&gt; select * from article1;<br>+—-+————–+——+<br>| id | title | bid |<br>+—-+————–+——+<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>| 1 | test | 1 |<br>| 2 | chuanzhiboke | 1 |<br>| 3 | 中国北京 | 1 |<br>+—-+————–+——+<br>3 rows in set (0.00 sec)<br>触发器的实验步骤：<br>create table board1(id int primary key auto_increment,name varchar(50),ar<br>ticleCount int);<br>create table article1(id int primary key auto_increment,title varchar(50)<br>,bid int references board1(id));<br>delimiter |<br>create trigger insertArticle_Trigger after insert on article1 for each ro<br>w begin<br>-&gt; update board1 set articleCount&#x3D;articleCount+1 where id&#x3D; NEW.bid; -&gt; end; -&gt; |<br>delimiter ;<br>insert into board1 value (null,’test’,0);<br>insert into article1 value(null,’test’,1);<br>还有，每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，<br>用触发器做效率就很高。下次课设计这样一个案例，写触发器时，对于最后发帖时间可能需<br>要用 declare 方式声明一个变量，或者是用 NEW.posttime 来生成。</li><li>数据库三范式是什么?<br>第一范式（1NF）：字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式）<br>数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一<br>个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的<br>字段。<br>第二范式（2NF）：第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足<br>第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以<br>被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被<br>称为主关键字或主键。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依<br>赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一<br>部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通<br>常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非<br>部分依赖于主关键字。<br>第三范式的要求如下： 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。所以<br>第三范式具有如下特征：<br>1，每一列只有一个值 。2，每一行都能区分。3，每一个表都不包含其他表已经包含<br>的非主关键字信息。<br>例如，帖子表中只能出现发帖人的 id，而不能出现发帖人的 id，还同时出现发帖人姓名，<br>否则，只要出现同一发帖人 id 的所有记录，它们中的姓名部分都必须严格保持一致，这就<br>是数据冗余。</li><li>说出一些数据库优化方面的经验?<br>用 PreparedStatement 一般来说比 Statement 性能高：一个 sql 发给服务器执行，步骤：语法<br>检查、语义分析， 编译，缓存<br>“inert into user values(1,1,1)”-二进制<br>“inert into user values(2,2,2)”-二进制<br>“inert into user values(?,?,?)”-二进制<br>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就<br>去掉外键。（比喻：就好比免检产品，就是为了提高效率，充分相信产品的制造商）<br>（对于 hibernate 来说，就应该有一个变化：empleyee-&gt;Deptment 对象，现在设计时就成了<br>employeedeptid）<br>看 mysql 帮助文档子查询章节的最后部分，例如，根据扫描的原理，下面的子查询语句要比<br>第二条关联查询的效率高：</li><li>select e.name,e.salary where e.managerid&#x3D;(select id from employee where name&#x3D;’zxx’);</li><li>select e.name,e.salary,m.name,m.salary from employees e,employees m where<br>e.managerid &#x3D; m.id and m.name&#x3D;’zxx’;<br>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等<br>将姓名和密码单独从用户表中独立出来。这可以是非常好的一对一的案例哟！<br>sql 语句全部大写，特别是列名和表名都大写。特别是 sql 命令的缓存功能，更加需要统一<br>大小写，sql 语句发给 oracle 服务器语法检查和编译成为内部指令缓存和执行指令。<br>根据缓存的特点，不要拼凑条件，而是用?和 PreparedStatment<br>还有索引对查询性能的改进也是值得关注的。<br>备注：下面是关于性能的讨论举例<br>4 航班 3 个城市<br>m*n<br>select * from flight,city where flight.startcityid&#x3D;city.cityid and city.name&#x3D;’beijing’;<br>m + n<br>select * from flight where startcityid &#x3D; (select cityid from city where cityname&#x3D;’beijing’);<br>select flight.id,’beijing’,flight.flightTime from flight where startcityid &#x3D; (select cityid from city<br>where cityname&#x3D;’beijing’)</li><li>union 和 union all 有什么不同?<br>假设我们有一个表 Student，包括以下字段与数据：<br>drop table student;<br>create table student<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(<br>id int primary key, name nvarchar2(50) not null, score number not null<br>);<br>insert into student values(1,’Aaron’,78);<br>insert into student values(2,’Bill’,76);<br>insert into student values(3,’Cindy’,89);<br>insert into student values(4,’Damon’,90);<br>insert into student values(5,’Ella’,73);<br>insert into student values(6,’Frado’,61);<br>insert into student values(7,’Gill’,99);<br>insert into student values(8,’Hellen’,56);<br>insert into student values(9,’Ivan’,93);<br>insert into student values(10,’Jay’,90);<br>commit;<br>Union 和 Union All 的区别。<br>select *from studentwhere id &lt; 4union<br>select *from studentwhere id &gt; 2 and id &lt; 6<br>结果将是<br>1 Aaron 78<br>2 Bill 76<br>3 Cindy 89<br>4 Damon 90<br>5 Ella 73<br>如果换成 Union All 连接两个结果集，则返回结果是：<br>1 Aaron 78<br>2 Bill 76<br>3 Cindy 89<br>3 Cindy 89<br>4 Damon 90<br>5 Ella 73<br>可以看到，Union 和 Union All 的区别之一在于对重复结果的处理。<br>UNION 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进<br>行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常<br>见的是过程表与历史表 UNION。如：<br>select * from gc_dfys<br>union<br>select * from ls_jg_dfys<br>这个 SQL 在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后<br>返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。<br>而 UNION ALL 只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有<br>重复的数据，那么返回的结果集就会包含重复的数据了。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>从效率上说，UNION ALL 要比 UNION 快很多，所以，如果可以确认合并的两个结果集<br>中不包含重复的数据的话，那么就使用 UNION ALL，</li><li>分页语句<br>取出 sql 表中第 31 到 40 的记录（以自动增长 ID 为主键）<br>sql server 方案 1：<br>select top 10 * from t where id not in (select top 30 id from t order by id ) orde by id<br>sql server 方案 2：<br>select top 10 * from t where id in (select top 40 id from t order by id) order by id desc<br>mysql 方案：select * from t order by id limit 30,10<br>oracle 方案：select * from (select rownum r,* from t where r&lt;&#x3D;40) where r&gt;30<br>——————–待整理进去的内容————————————- pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>1.分页技术 1（直接利用 sql 语句进行分页，效率最高和最推荐的）<br>mysql:sql &#x3D; “select * from articles limit “ + (pageNo-1)<em>pageSize + “,” + pageSize;<br>oracle: sql &#x3D; “select * from “ +”(select rownum r,</em> from “ +”(select * from articles order by<br>postime desc)” +”where rownum&lt;&#x3D; “ + pageNo*pageSize +”) tmp “ +”where r&gt;” +<br>(pageNo-1)*pageSize;<br>注释：第 7 行保证 rownum 的顺序是确定的，因为 oracle 的索引会造成 rownum 返回不同的<br>值<br>简洋提示：没有 order by 时，rownum 按顺序输出，一旦有了 order by，rownum 不按顺序输<br>出了，这说明 rownum 是排序前的编号。如果对 order by 从句中的字段建立了索引，那么，<br>rownum 也是按顺序输出的，因为这时候生成原始的查询结果集时会参照索引表的顺序来构<br>建。<br>sqlserver:sql &#x3D; “select top 10 * from id not id(select top “ + (pageNo-1)*pageSize + “id from<br>articles)” DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D; cn.prepareSatement(sql);<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>while(rs.next()){<br>out.println(rs.getString(1));<br>}<br>2.不可滚动的游标<br>pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>cn &#x3D; null<br>stmt &#x3D; null;<br>rs &#x3D; null;<br>try{<br>sqlserver:sql &#x3D; “select * from articles”;<br>DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D; cn.prepareSatement(sql);<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>for(int j&#x3D;0;j&lt;(pageNo-1)*pageSize;j++){<br>rs.next();<br>}<br>int i&#x3D;0;<br>while(rs.next() &amp;&amp; i&lt;10){<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly{<br>if(rs!&#x3D;null)try{rs.close();}catch(Exception e){}<br>if(stm……… if(cn………… }<br>3.可滚动的游标<br>pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>cn &#x3D; null<br>stmt &#x3D; null;<br>rs &#x3D; null;<br>try{<br>sqlserver:sql &#x3D; “select * from articles”;<br>DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D;<br>cn.prepareSatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,…);<br>&#x2F;&#x2F;根据上面这行代码的异常 SQLFeatureNotSupportedException，就可判断驱动是否支持可滚<br>动游标<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>rs.absolute((pageNo-1)*pageSize)<br>int i&#x3D;0;<br>while(rs.next() &amp;&amp; i&lt;10){<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly{<br>if(rs!&#x3D;null)try{rs.close();}catch(Exception e){}<br>if(stm……… if(cn………… }</li><li>用一条 SQL 语句 查询出每门课都大于 80 分的学生姓名<br>name kecheng fenshu<br>张三 语文 81<br>张三 数学 75<br>李四 语文 76<br>李四 数学 90<br>王五 语文 81<br>王五 数学 100<br>王五 英语 90<br>准备数据的 sql 代码：<br>create table score(id int primary key auto_increment,name varchar(20),subject varchar(20),score<br>int);<br>insert into score values<br>(null,’张三’,’语文’,81), (null,’张三’,’数学’,75), (null,’李四’,’语文’,76), (null,’李四’,’数学’,90), (null,’王五’,’语文’,81), (null,’王五’,’数学’,100), (null,’王五 ‘,’英语’,90);<br>提示：当百思不得其解时，请理想思维，把小变成大做，把大变成小做，<br>答案：<br>A: select distinct name from score where name not in (select distinct name from score where<br>score&lt;&#x3D;80)<br>B:select distince name t1 from score where 80&lt; all (select score from score where name&#x3D;t1);</li><li>所有部门之间的比赛组合<br>一个叫 department 的表，里面只有一个字段 name,一共有 4 条纪录，分别是 a,b,c,d,对应四个<br>球对，现在四个球对进行比赛，用一条 sql 语句显示所有可能的比赛组合.<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>答：select a.name, b.name from team a, team b where a.name &lt; b.name</li><li>每个月份的发生额都比 101 科目多的科目<br>请用 SQL 语句实现：从 TestDB 数据表中查询出所有月份的发生额都比 101 科目相应月份的<br>发生额高的科目。请注意：TestDB 中有很多科目，都有 1－12 月份的发生额。<br>AccID：科目代码，Occmonth：发生额月份，DebitOccur：发生额。<br>数据库名：JcyAudit，数据集：Select * from TestDB<br>准备数据的 sql 代码：<br>drop table if exists TestDB;<br>create table TestDB(id int primary key auto_increment,AccID varchar(20), Occmonth date, DebitOccur bigint);<br>insert into TestDB values<br>(null,’101’,’1988-1-1’,100), (null,’101’,’1988-2-1’,110), (null,’101’,’1988-3-1’,120), (null,’101’,’1988-4-1’,100), (null,’101’,’1988-5-1’,100), (null,’101’,’1988-6-1’,100), (null,’101’,’1988-7-1’,100), (null,’101’,’1988-8-1’,100); –复制上面的数据，故意把第一个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’102’,’1988-1-1’,90), (null,’102’,’1988-2-1’,110), (null,’102’,’1988-3-1’,120), (null,’102’,’1988-4-1’,100), (null,’102’,’1988-5-1’,100), (null,’102’,’1988-6-1’,100), (null,’102’,’1988-7-1’,100), (null,’102’,’1988-8-1’,100); –复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’103’,’1988-1-1’,150), (null,’103’,’1988-2-1’,160), (null,’103’,’1988-3-1’,180), (null,’103’,’1988-4-1’,120), (null,’103’,’1988-5-1’,120), (null,’103’,’1988-6-1’,120), (null,’103’,’1988-7-1’,120), (null,’103’,’1988-8-1’,120); –复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’104’,’1988-1-1’,130), (null,’104’,’1988-2-1’,130), (null,’104’,’1988-3-1’,140),<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(null,’104’,’1988-4-1’,150), (null,’104’,’1988-5-1’,160), (null,’104’,’1988-6-1’,170), (null,’104’,’1988-7-1’,180), (null,’104’,’1988-8-1’,140); –复制最上面的数据，故意把第二个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’105’,’1988-1-1’,100), (null,’105’,’1988-2-1’,80), (null,’105’,’1988-3-1’,120), (null,’105’,’1988-4-1’,100), (null,’105’,’1988-5-1’,100), (null,’105’,’1988-6-1’,100), (null,’105’,’1988-7-1’,100), (null,’105’,’1988-8-1’,100);<br>答案：<br>select distinct AccID from TestDB<br>where AccID not in<br>(select TestDB.AccIDfrom TestDB, (select * from TestDB where AccID&#x3D;’101’) as db101<br>where TestDB.Occmonth&#x3D;db101.Occmonth and TestDB.DebitOccur&lt;&#x3D;db101.DebitOccur<br>);</li><li>统计每年每月的信息<br>year month amount<br>1991 1 1.1<br>1991 2 1.2<br>1991 3 1.3<br>1991 4 1.4<br>1992 1 2.1<br>1992 2 2.2<br>1992 3 2.3<br>1992 4 2.4<br>查成这样一个结果<br>year m1 m2 m3 m4<br>1991 1.1 1.2 1.3 1.4<br>1992 2.1 2.2 2.3 2.4<br>提示：这个与工资条非常类似，与学生的科目成绩也很相似。<br>准备 sql 语句：<br>drop table if exists sales;<br>create table sales(id int auto_increment primary key,year varchar(10), month varchar(10), amount<br>float(2,1));<br>insert into sales values<br>(null,’1991’,’1’,1.1),<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(null,’1991’,’2’,1.2), (null,’1991’,’3’,1.3), (null,’1991’,’4’,1.4), (null,’1992’,’1’,2.1), (null,’1992’,’2’,2.2), (null,’1992’,’3’,2.3), (null,’1992’,’4’,2.4);<br>答案一、select sales.year , (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘1’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘2’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘3’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) as ‘4’ from sales group by year;</li><li>显示文章标题，发帖人、最后回复时间<br>表：id,title,postuser,postdate,parentid<br>准备 sql 语句：<br>drop table if exists articles;<br>create table articles(id int auto_increment primary key,title varchar(50), postuser varchar(10), postdate datetime,parentid int references articles(id));<br>insert into articles values<br>(null,’第一条’,’张三’,’1998-10-10 12:32:32’,null), (null,’第二条’,’张三’,’1998-10-10 12:34:32’,null), (null,’第一条回复 1’,’李四’,’1998-10-10 12:35:32’,1), (null,’第二条回复 1’,’李四’,’1998-10-10 12:36:32’,2), (null,’第一条回复 2’,’王五’,’1998-10-10 12:37:32’,1), (null,’第一条回复 3’,’李四’,’1998-10-10 12:38:32’,1), (null,’第二条回复 2’,’李四’,’1998-10-10 12:39:32’,2), (null,’第一条回复 4’,’王五’,’1998-10-10 12:39:40’,1);<br>答案：<br>select a.title,a.postuser, (select max(postdate) from articles where parentid&#x3D;a.id) reply<br>from articles a where a.parentid is null;<br>注释：子查询可以用在选择列中，也可用于 where 的比较条件中，还可以用于 from 从句中。</li><li>删除除了 id 号不同,其他都相同的学生冗余信息<br>2.学生表 如下:<br>id 号 学号 姓名 课程编号 课程名称 分数<br>1 2005001 张三 0001 数学 69<br>2 2005002 李四 0001 数学 89<br>3 2005001 张三 0001 数学 69<br>A: delete from tablename where id 号 not in(select min(id 号) from tablename group by 学号,姓<br>名,课程编号,课程名称,分数)<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实验：<br>create table student2(id int auto_increment primary key,code varchar(20),name varchar(20));<br>insert into student2 values(null,’2005001’,’张三’),(null,’2005002’,’李四’),(null,’2005001’,’张三’);<br>&#x2F;&#x2F;如下语句，mysql 报告错误，可能删除依赖后面统计语句，而删除又导致统计语句结果不<br>一致。<br>delete from student2 where id not in(select min(id) from student2 group by name);<br>&#x2F;&#x2F;但是，如下语句没有问题：<br>select * from student2 where id not in(select min(id) from student2 group by name);<br>&#x2F;&#x2F;于是，我想先把分组的结果做成虚表，然后从虚表中选出结果，最后再将结果作为删除的<br>条件数据。<br>delete from student2 where id not in(select mid from (select min(id) mid<br>from student2 group by name) as t);<br>或者：<br>delete from student2 where id not in(select min(id) from (select * from s<br>tudent2) as t group by t.name);</li><li>航空网的几个航班查询题：<br>表结构如下：<br>flight{flightID,StartCityID ,endCityID,StartTime}<br>city{cityID, CityName)<br>实验环境：<br>create table city(cityID int auto_increment primary key,cityName varchar(20));<br>create table flight (flightID int auto_increment primary key, StartCityID int references city(cityID), endCityID int references city(cityID), StartTime timestamp);<br>&#x2F;&#x2F;航班本来应该没有日期部分才好，但是下面的题目当中涉及到了日期<br>insert into city values(null,’北京’),(null,’上海’),(null,’广州’);<br>insert into flight values<br>(null,1,2,’9:37:23’),(null,1,3,’9:37:23’),(null,1,2,’10:37:23’),(null,2,3,’10:37:23’);<br>1、查询起飞城市是北京的所有航班，按到达城市的名字排序<br>参与运算的列是我起码能够显示出来的那些列，但最终我不一定把它们显示出来。各个表组<br>合出来的中间结果字段中必须包含所有运算的字段。<br>select * from flight f,city c<br>where f.endcityid &#x3D; c.cityid and startcityid &#x3D;<br>(select c1.cityid from city c1 where c1.cityname &#x3D; “北京”)<br>order by c.cityname asc;<br>mysql&gt; select flight.flightid,’北京’ startcity, e.cityname from flight,city e wh<br>ere flight.endcityid&#x3D;e.cityid and flight.startcityid&#x3D;(select cityid from city wh<br>ere cityname&#x3D;’北京’);<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>mysql&gt; select flight.flightid,s.cityname,e.cityname from flight,city s,city e wh<br>ere flight.startcityid&#x3D;s.cityid and s.cityname&#x3D;’北京’ and flight.endCityId&#x3D;e.cit<br>yID order by e.cityName desc;<br>2、查询北京到上海的所有航班纪录（起飞城市，到达城市，起飞时间，航班号）<br>select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID&#x3D;c1.cityID<br>and f.endCityID&#x3D;c2.cityID<br>and c1.cityName&#x3D;’北京’ and c2.cityName&#x3D;’上海’ 3、查询具体某一天（2005-5-8）的北京到上海的的航班次数<br>select count(<em>) from<br>(select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID&#x3D;c1.cityID<br>and f.endCityID&#x3D;c2.cityID<br>and c1.cityName&#x3D;’北京’ and c2.cityName&#x3D;’上海’ and 查帮助获得的某个日期处理函数(startTime) like ‘2005-5-8%’ mysql 中提取日期部分进行比较的示例代码如下：<br>select * from flight where date_format(starttime,’%Y-%m-%d’)&#x3D;’1998-01-02’ 182. 查出比经理薪水还高的员工信息：<br>Drop table if not exists employees;<br>create table employees(id int primary key auto_increment,name varchar(50)<br>,salary int,managerid int references employees(id));<br>insert into employees values (null,’ lhm’,10000,null), (null,’ zxx’,15000,1<br>),(null,’flx’,9000,1),(null,’tg’,10000,2),(null,’wzg’,10000,3);<br>Wzg 大于 flx,lhm 大于 zxx<br>解题思路：<br>根据 sql 语句的查询特点，是逐行进行运算，不可能两行同时参与运算。<br>涉及了员工薪水和经理薪水，所有，一行记录要同时包含两个薪水，所有想到要把这个表自<br>关联组合一下。<br>首先要组合出一个包含有各个员工及该员工的经理信息的长记录，譬如，左半部分是员工，<br>右半部分是经理。而迪卡尔积会组合出很多垃圾信息，先去除这些垃圾信息。<br>select e.</em> from employees e,employees m where e.managerid&#x3D;m.id and e.sala<br>ry&gt;m.salary;</li><li>求出小于 45 岁的各个老师所带的大于 12 岁的学生人数<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>数据库中有 3 个表 teacher 表，student 表，tea_stu 关系表。<br>teacher 表 teaID name age<br>student 表 stuID name age<br>teacher_student 表 teaID stuID<br>要求用一条 sql 查询出这样的结果<br>1.显示的字段要有老师 name, age 每个老师所带的学生人数<br>2.只列出老师 age 为 40 以下，学生 age 为 12 以上的记录<br>预 备 知 识 : 1.sql 语 句 是 对 每 一 条 记 录 依 次 处 理 ， 条 件 为 真 则 执 行 动 作<br>（select,insert,delete,update）<br>2.只要是迪卡尔积，就会产生“垃圾”信息，所以，只要迪卡尔积了，我们首先<br>就要想到清除“垃圾”信息<br>实验准备： drop table if exists tea_stu;<br>drop table if exists teacher;<br>drop table if exists student;<br>create table teacher(teaID int primary key,name varchar(50),age int);<br>create table student(stuID int primary key,name varchar(50),age int);<br>create table tea_stu(teaID int references teacher(teaID),stuID int references<br>student(stuID));<br>insert into teacher values(1,’zxx’,45), (2,’lhm’,25) , (3,’wzg’,26) , (4,’tg’,27);<br>insert into student values(1,’wy’,11), (2,’dh’,25) , (3,’ysq’,26) , (4,’mxc’,27);<br>insert into tea_stu values(1,1), (1,2), (1,3);<br>insert into tea_stu values(2,2), (2,3), (2,4);<br>insert into tea_stu values(3,3), (3,4), (3,1);<br>insert into tea_stu values(4,4), (4,1), (4,2) , (4,3);<br>结果：23,32,43<br>解题思路：（真实面试答题时，也要写出每个分析步骤，如果纸张不够，就找别人要）<br>1.要会统计分组信息，统计信息放在中间表中：<br>select teaid,count(<em>) from tea_stu group by teaid;<br>2.接着其实应该是筛除掉小于 12 岁的学生，然后再进行统计，中间表必须与 student 关联才<br>能得到 12 岁以下学生和把该学生记录从中间表中剔除，代码是：<br>select tea_stu.teaid,count(</em>) total from student,tea_stu<br>where student.stuid&#x3D;tea_stu.stuid and student.age&gt;12 group by tea_stu.teaid<br>3.接着把上面的结果做成虚表与 teacher 进行关联，并筛除大于 45 的老师<br>select teacher.teaid,teacher.name,total from teacher ,(select tea_stu.tea<br>id,count(*) total from student,tea_stu where student.stuid&#x3D;tea_stu.stuid and stu<br>dent.age&gt;12 group by tea_stu.teaid) as tea_stu2 where teacher.teaid&#x3D;tea_stu2.tea<br>id and teacher.age&lt;45;</li><li>求出发帖最多的人：<br>select authorid,count(<em>) total from articles<br>group by authorid<br>having total&#x3D;(select max(total2) from (select count(</em>) total2 from articles group by authorid) as t);<br>select t.authorid,max(t.total) from（select authorid,count(<em>) total from articles ）as t<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>这条语句不行，因为 max 只有一列，不能与其他列混淆。<br>select authorid,count(</em>) total from articles<br>group by authorid having total&#x3D;max(total)也不行。</li><li>一个用户表中有一个积分字段，假如数据库中有 100 多万个用户，若要在每年第一天<br>凌晨将积分清零，你将考虑什么，你将想什么办法解决?<br>alter table drop column score;<br>alter table add colunm score int;<br>可能会很快，但是需要试验，试验不能拿真实的环境来操刀，并且要注意，<br>这样的操作时无法回滚的，在我的印象中，只有 inert update delete 等 DML 语句才能回滚，<br>对于 create table,drop table ,alter table 等 DDL 语句是不能回滚。<br>解决方案一，update user set score&#x3D;0;<br>解决方案二，假设上面的代码要执行好长时间，超出我们的容忍范围，那我就 alter table user<br>drop column score;alter table user add column score int。<br>下面代码实现每年的那个凌晨时刻进行清零。<br>Runnable runnable &#x3D;<br>new Runnable(){<br>public void run(){<br>clearDb();<br>schedule(this,new Date(new Date().getYear()+1,0,0));<br>}<br>};<br>schedule(runnable, new Date(new Date().getYear()+1,0,1));</li><li>一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。<br>select count(*) as num,tb.id from tb, (select role from tb where id&#x3D;xxx) as t1<br>where tb.role &#x3D; t1.role and tb.id !&#x3D; t1.id<br>group by tb.id<br>having num &#x3D; select count(role) from tb where id&#x3D;xxx;</li><li>xxx 公司的 sql 面试<br>Table EMPLOYEES Structure:<br>EMPLOYEE_ID NUMBER Primary Key, FIRST_NAME VARCHAR2(25), LAST_NAME VARCHAR2(25), Salary number(8,2), HiredDate DATE, Departmentid number(2)<br>Table Departments Structure:<br>Departmentid number(2) Primary Key, DepartmentName VARCHAR2(25).<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(2）基于上述 EMPLOYEES 表写出查询：写出雇用日期在今年的，或者工资在[1000,2000]<br>之间的，或者员工姓名（last_name）以’Obama’打头的所有员工，列出这些员工的全部个人<br>信息。（4 分）<br>select * from employees<br>where Year(hiredDate) &#x3D; Year(date())<br>or (salary between 1000 and 200)<br>or left(last_name,3)&#x3D;’abc’;<br>(3) 基于上述 EMPLOYEES 表写出查询：查出部门平均工资大于 1800 元的部门的所有员工，<br>列出这些员工的全部个人信息。<br>mysql&gt; select id,name,salary,deptid did from employee1 where (select avg(salary)<br>from employee1 where deptid &#x3D; did) &gt; 1800;<br>(4) 基于上述 EMPLOYEES 表写出查询：查出个人工资高于其所在部门平均工资的员工，<br>列出这些员工的全部个人信息及该员工工资高出部门平均工资百分比。（5 分）<br>select employee1.*,(employee1.salary-t.avgSalary)*100&#x2F;employee1.salary<br>from employee1, (select deptid,avg(salary) avgSalary from employee1 group by deptid) as t<br>where employee1.deptid &#x3D; t.deptid and employee1.salary&gt;t.avgSalary;</li><li>注册 Jdbc 驱动程序的三种方式?<br>如下:</li><li>Class.forName(“com.mysql.jdbc.Driver”);</li><li>System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”);</li><li>DriverManager.registerDriver(new com.mysql.jdbc.Driver());<br>1 中，不需要.newInstance()<br>2 中，通过系统的属性设置即可<br>3 中，是看起来比较直观的一种方式，注册相应的 db 的 jdbc 驱动，<br>总结：推荐 1，和 2 两种方式。<br>原因：3 在编译时需要导入对应的 lib。1，2 不需要。<br>补充：2 的方式的话，可以同时导入多个 jdbc 驱动，中间用冒号“：”分开</li><li>用 JDBC 如何调用存储过程<br>代码如下：<br>package com.huawei.interview.lym;<br>import java.sql.CallableStatement;<br>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;<br>import java.sql.Types;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public class JdbcTest {<br>public static void main(String[] args) {<br>Connection cn &#x3D; null;<br>CallableStatement cstmt &#x3D; null;<br>try {<br>&#x2F;&#x2F;这里最好不要这么干，因为驱动名写死在程序中了<br>Class.forName(“com.mysql.jdbc.Driver”);<br>&#x2F;&#x2F;实际项目中，这里应用 DataSource 数据，如果用框架，<br>&#x2F;&#x2F;这个数据源不需要我们编码创建，我们只需 Datasource ds &#x3D; context.lookup()<br>&#x2F;&#x2F;cn &#x3D; ds.getConnection();<br>cn &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;&#x2F;test”,”root”,”root”);<br>cstmt &#x3D; cn.prepareCall(“{call insert_Student(?,?,?)}”);<br>cstmt.registerOutParameter(3,Types.INTEGER);<br>cstmt.setString(1, “wangwu”);<br>cstmt.setInt(2, 25);<br>cstmt.execute();<br>&#x2F;&#x2F;get 第几个，不同的数据库不一样，建议不写<br>System.out.println(cstmt.getString(3));<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>finally{<br>&#x2F;<em>try{cstmt.close();}catch(Exception e){}<br>try{cn.close();}catch(Exception e){}</em>&#x2F;<br>try {<br>if(cstmt !&#x3D; null)<br>cstmt.close();<br>if(cn !&#x3D; null)<br>cn.close();<br>} catch (SQLException e) {<br>e.printStackTrace();<br>}<br>}<br>}</li><li>JDBC 中的 PreparedStatement 相比 Statement 的好处<br>答：一个 sql 命令发给服务器去执行的步骤为：语法检查，语义分析，编译成内部指令，缓<br>存指令，执行指令等过程。<br>select * from student where id &#x3D;3—-缓存–xxxxx 二进制命令<br>select * from student where id &#x3D;3—-直接取-xxxxx 二进制命令<br>select * from student where id &#x3D;4— -会怎么干？<br>如果当初是 select * from student where id &#x3D;?— -又会怎么干？<br>上面说的是性能提高<br>可以防止 sql 注入。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</li><li>写一个用 jdbc 连接并访问 oracle 数据的程序代码, 能够完成修改和查询工作。<br>public void testJdbc(){<br>Connection con &#x3D; null;<br>PreparedStatement ps &#x3D; null;<br>ResultSet rs &#x3D; null;<br>try{<br>&#x2F;&#x2F;step1：注册驱动；<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>&#x2F;&#x2F;step 2：获取数据库连接；<br>con&#x3D;DriverManager.getConnection( “jdbc:oracle:thin:@192.168.0.39:1521:TARENADB”, “sd0605”,”sd0605”);<br>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>查 询</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>&#x2F;<br>&#x2F;&#x2F;step 3：创建 Statement；<br>String sql &#x3D; “SELECT id, fname, lname, age, FROM Person_Tbl”;<br>ps &#x3D; con.prepareStatement(sql);<br>&#x2F;&#x2F;step 4 ：执行查询语句，获取结果集；<br>rs &#x3D; ps.executeQuery();<br>&#x2F;&#x2F;step 5：处理结果集—输出结果集中保存的查询结果；<br>while (rs.next()){<br>System.out.print(“id &#x3D; “ + rs.getLong(“id”));<br>System.out.print(“ , fname &#x3D; “ + rs.getString(“fname”));<br>System.out.print(“ , lname &#x3D; “ + rs.getString(“lname”));<br>System.out.print(“ , age &#x3D; “ + rs.getInt(“age”));<br>}<br>&#x2F;***<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>JDBC 修 改</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F;<br>sql &#x3D; “UPDATE Person_Tbl SET age&#x3D;23 WHERE id &#x3D; ?”;<br>ps &#x3D; con.prepareStatement(sql);<br>ps.setLong(1, 88);<br>int rows &#x3D; ps.executeUpdate();<br>System.out.println(rows + “ rows affected.”);<br>} catch (Exception e){<br>e.printStackTrace();<br>} finally{<br>try{<br>con.close(); &#x2F;&#x2F;关闭数据库连接，以释放资源。<br>} catch (Exception e1) {<br>}<br>}<br>}</li><li>Class.forName 的作用?为什么要用?<br>答：按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载<br>过，则返回代表该字节码的 Class 实例对象，否则，按类加载器的委托机制去搜索和加载该<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>类，如果所有的类加载器都无法加载到该类，则抛出 ClassNotFoundException。加载完这个<br>Class 字节码后，接着就可以使用 Class 字节码的 newInstance 方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时<br>才能确定，这时候就需要使用 Class.forName 去动态加载该类，这个类名通常是在配置文件<br>中配置的，例如，spring 的 ioc 中每次依赖注入的具体类就是这样配置的，jdbc 的驱动类名<br>通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类<br>名。</li><li>大数据量下的分页解决方法。<br>答：最好的办法是利用 sql 语句进行分页，这样每次查询出的结果集中就只包含某页的数据<br>内容。再 sql 语句无法实现分页的情况下，可以考虑对大的结果集通过游标定位方式来获取<br>某页的数据。<br>sql 语句分页，不同的数据库下的分页方案各不一样，下面是主流的三种数据库的分页 sql：<br>sql server:<br>String sql &#x3D; “select top “ + pageSize + “ * from students where id not in” +<br>“(select top “ + pageSize * (pageNumber-1) + “ id from students order by id)” +<br>“order by id”;<br>mysql:String sql &#x3D; “select * from students order by id limit “ + pageSize*(pageNumber-1) + “,” +<br>pageSize;<br>oracle:String sql &#x3D; “select * from “ + (select <em>,rownum rid from (select * from students order<br>by postime desc) where rid&lt;&#x3D;” + pagesize</em>pagenumber + “) as t” + “where t&gt;” +<br>pageSize*(pageNumber-1);</li><li>用 JDBC 查询学生成绩单, 把主要代码写出来（考试概率极大）. Connection cn &#x3D; null;<br>PreparedStatement pstmt &#x3D;null;<br>Resultset rs &#x3D; null;<br>try{<br>Class.forname(driveClassName);<br>cn &#x3D; DriverManager.getConnection(url,username,password);<br>pstmt &#x3D; cn.prepareStatement(“select score.* from score ,student “ +<br>“where score.stuId &#x3D; student.id and student.name &#x3D; ?”);<br>pstmt.setString(1,studentName);<br>Resultset rs &#x3D; pstmt.executeQuery();<br>while(rs.next()){<br>system.out.println(rs.getInt(“subject”) + “ ” + rs.getFloat(“score”) );<br>}<br>}catch(Exception e){e.printStackTrace();}<br>finally{<br>if(rs !&#x3D; null) try{ rs.close() }catch(exception e){}<br>if(pstmt !&#x3D; null) try{pstmt.close()}catch(exception e){}<br>if(cn !&#x3D; null) try{ cn.close() }catch(exception e){}<br>}</li><li>这段代码有什么不足之处?<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>try {<br>Connection conn &#x3D; …;<br>Statement stmt &#x3D; …;<br>ResultSet rs &#x3D; stmt.executeQuery(“select * from table1”);<br>while(rs.next()) {<br>}<br>} catch(Exception ex) {<br>}<br>答：没有 finally 语句来关闭各个对象，另外，使用 finally 之后，要把变量的定义放在 try 语<br>句块的外面，以便在 try 语句块之外的 finally 块中仍可以访问这些变量。</li><li>说出数据连接池的工作机制是什么?<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空<br>闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池<br>连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>实现方式，返回的 Connection 是原始 Connection 的代理，代理 Connection 的 close 方法不是<br>真正关连接，而是把它代理的 Connection 对象还回到连接池中。</li><li>为什么要用 ORM? 和 JDBC 有何不一样?<br>orm 是一种思想，就是把 object 转变成数据库中的记录，或者把数据库中的记录转变成<br>objecdt，我们可以用 jdbc 来实现这种思想，其实，如果我们的项目是严格按照 oop 方式编<br>写的话，我们的 jdbc 程序不管是有意还是无意，就已经在实现 orm 的工作了。<br>现在有许多 orm 工具，它们底层调用 jdbc 来实现了 orm 工作，我们直接使用这些工具，就<br>省去了直接使用 jdbc 的繁琐细节，提高了开发效率，现在用的较多的 orm 工具是 hibernate。<br>也听说一些其他 orm 工具，如 toplink,ojb 等。</li><li>121、在 ORACLE 大数据量下的分页解决方法。一般用截取 ID 方法，还有是三层嵌<br>套方法。<br>答:一种分页方法<br>&lt;%<br>int i&#x3D;1;<br>int numPages&#x3D;14;<br>String pages &#x3D; request.getParameter(“page”) ;<br>int currentPage &#x3D; 1;<br>currentPage &#x3D; (pages&#x3D;&#x3D;null)?(1):{Integer.parseInt(pages)}<br>sql &#x3D; “select count(<em>) from tables”;<br>ResultSet rs &#x3D; DBLink.executeQuery(sql) ;<br>while(rs.next()) i &#x3D; rs.getInt(1) ;<br>int intPageCount&#x3D;1;<br>intPageCount&#x3D;(i%numPages&#x3D;&#x3D;0)?(i&#x2F;numPages):(i&#x2F;numPages+1);<br>int nextPage ;<br>int upPage;<br>nextPage &#x3D; currentPage+1;<br>if (nextPage&gt;&#x3D;intPageCount) nextPage&#x3D;intPageCount;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>upPage &#x3D; currentPage-1;<br>if (upPage&lt;&#x3D;1) upPage&#x3D;1;<br>rs.close();<br>sql&#x3D;”select * from tables”;<br>rs&#x3D;DBLink.executeQuery(sql);<br>i&#x3D;0;<br>while((i&lt;numPages</em>(currentPage-1))&amp;&amp;rs.next()){i++;}<br>%&gt;<br>&#x2F;&#x2F;输出内容<br>&#x2F;&#x2F;输出翻页连接<br>合计:&lt;%&#x3D;currentPage%&gt;&#x2F;&lt;%&#x3D;intPageCount%&gt;页<br><a href>第一页</a><br><a href>上一页</a><br>&lt;%<br>for(int j&#x3D;1;j&lt;&#x3D;intPageCount;j++){<br>if(currentPage!&#x3D;j){<br>%&gt;<br><a href>[&lt;%&#x3D;j%&gt;]</a><br>&lt;%<br>}else{<br>out.println(j);<br>}<br>}<br>%&gt;<br><a href>下一页</a><br><a href>最后页</a></li><li>JDBC，Hibernate 分页怎样实现？<br>答：方法分别为：</li></ol><ol><li>Hibernate 的分页：<br>Query query &#x3D; session.createQuery(“from Student”);<br>query.setFirstResult(firstResult);&#x2F;&#x2F;设置每页开始的记录号<br>query.setMaxResults(resultNumber);&#x2F;&#x2F;设置每页显示的记录数<br>Collection students &#x3D; query.list();</li><li>JDBC 的分页：根据不同的数据库采用不同的 sql 分页语句<br>例 如 : Oracle 中 的 sql 语 句 为 : “SELECT * FROM (SELECT a.*, rownum r FROM<br>TB_STUDENT) WHERE r between 2 and 10” 查询从记录号 2 到记录号 10 之间的所有记录<br>七、 XML 部分</li></ol><ol start="200"><li><p>xml 有哪些解析技术?区别是什么?<br>答:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>种结构占用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML<br>的随机访问 SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文<br>件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结<br>束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理 XML 文件，适合<br>对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)</p></li><li><p>你在项目中用到了 xml 技术的哪些方面?如何实现的?<br>答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成<br>XML 文件，然后将 XML 文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩<br>后再同 XML 文件中还原相关信息进行处理。在做软件配置时，利用 XML 可以很方便的进<br>行，软件的各种配置参数都存贮在 XML 文件中。</p></li><li><p>谈谈你对 SSH 的理解<br>典型的 JavaEE 三层结构，分为表现层、中间层（业务逻辑层）和数据服务层。三层体系将<br>业务规则、数据访问及合法性校验等工作放在中间层处理。客户端不直接与数据库交互，而<br>是通过组件与中间层建立连接，再由中间层与数据库交互。<br>表现层是传统的 JSP 技术，自 1999 年问世以来，经过多年的发展，其广泛的应用和稳定的<br>表现，为其作为表现层技术打下了坚实的基础。<br>中间层采用的是流行的 Spring+Hibernate，为了将控制层与业务逻辑层分离，又细分为以下<br>几种。<br>Web 层，就是 MVC 模式里面的“C”（controller），负责控制业务逻辑层与表现层的交互，<br>调用业务逻辑层，并将业务数据返回给表现层作组织表现，该系统的 MVC 框架采用 Struts。<br>Service 层（就是业务逻辑层），负责实现业务逻辑。业务逻辑层以 DAO 层为基础，通过对<br>DAO 组件的正面模式包装，完成系统所要求的业务逻辑。<br>DAO 层，负责与持久化对象交互。该层封装了数据的增、删、查、改的操作。<br>PO，持久化对象。通过实体关系映射工具将关系型数据库的数据映射成对象，很方便地实<br>现以面向对象方式操作数据库，该系统采用 Hibernate 作为 ORM 框架。<br>Spring 的作用贯穿了整个中间层，将 Web 层、Service 层、DAO 层及 PO 无缝整合，其数据<br>服务层用来存放数据。</p></li><li><p>谈谈你对 Hibernate 的理解。</p></li><li><p>面向对象设计的软件内部运行过程可以理解成就是在不断创建各种新对象、建立对象之<br>间的关系，调用对象的方法来改变各个对象的状态和对象消亡的过程，不管程序运行的过程<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>和操作怎么样，本质上都是要得到一个结果，程序上一个时刻和下一个时刻的运行结果的差<br>异就表现在内存中的对象状态发生了变化。<br>2.为了在关机和内存空间不够的状况下，保持程序的运行状态，需要将内存中的对象状态保<br>存到持久化设备和从持久化设备中恢复出对象的状态，通常都是保存到关系数据库来保存大<br>量对象信息。从 Java 程序的运行功能上来讲，保存对象状态的功能相比系统运行的其他功<br>能来说，应该是一个很不起眼的附属功能，java 采用 jdbc 来实现这个功能，这个不起眼的<br>功能却要编写大量的代码，而做的事情仅仅是保存对象和恢复对象，并且那些大量的 jdbc<br>代码并没有什么技术含量，基本上是采用一套例行公事的标准代码模板来编写，是一种苦活<br>和重复性的工作。<br>3.通过数据库保存 java 程序运行时产生的对象和恢复对象，其实就是实现了 java 对象与关<br>系数据库记录的映射关系，称为 ORM（即 Object Relation Mapping），人们可以通过封装<br>JDBC 代码来实现了这种功能，封装出来的产品称之为 ORM 框架，Hibernate 就是其中的一<br>种流行 ORM 框架。使用 Hibernate 框架，不用写 JDBC 代码，仅仅是调用一个 save 方法，<br>就可以将对象保存到关系数据库中，仅仅是调用一个 get 方法，就可以从数据库中加载出一<br>个对象。<br>4.使用 Hibernate 的基本流程是：配置 Configuration 对象、产生 SessionFactory、创建 session<br>对象，启动事务，完成 CRUD 操作，提交事务，关闭 session。<br>5.使用 Hibernate 时，先要配置 hibernate.cfg.xml 文件，其中配置数据库连接信息和方言等，<br>还要为每个实体配置相应的 hbm.xml 文件，hibernate.cfg.xml 文件中需要登记每个 hbm.xml<br>文件。<br>6.在应用 Hibernate 时，重点要了解 Session 的缓存原理，级联，延迟加载和 hql 查询。</p></li><li><p>hibernate 中的 update()和 saveOrUpdate()的区别，session 的 load()和 get()的区别。</p></li><li><p>简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件. 216. Hibernate 的应用（Hibernate 的结构）？<br>答：&#x2F;&#x2F;首先获得 SessionFactory 的对象<br>SessionFactory sessionFactory &#x3D; new Configuration().configure().buildSessionFactory();<br>&#x2F;&#x2F;然后获得 session 的对象<br>Session session &#x3D; sessionFactory.openSession();<br>&#x2F;&#x2F;其次获得 Transaction 的对象<br>Transaction tx &#x3D; session.beginTransaction();<br>&#x2F;&#x2F;执行相关的数据库操作:增,删,改,查<br>session.save(user); &#x2F;&#x2F;增加, user 是 User 类的对象<br>session.delete(user); &#x2F;&#x2F;删除<br>session.update(user); &#x2F;&#x2F;更新<br>Query query &#x3D; session.createQuery(“from User”); &#x2F;&#x2F;查询<br>List list &#x3D; query.list();<br>&#x2F;&#x2F;提交事务<br>tx.commit();<br>&#x2F;&#x2F;如果有异常,我们还要作事务的回滚,恢复到操作之前<br>tx.rollback();<br>&#x2F;&#x2F;最后还要关闭 session,释放资源<br>session.close()</p></li><li><p>112、Hibernate 有哪 5 个核心接口？<br>答：Configuration 接口：配置 Hibernate，根据其启动 hibernate，创建 SessionFactory 对象；<br>SessionFactory 接口：初始化 Hibernate，充当数据存储源的代理，创建 session 对象，<br>sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量<br>级、二级缓存；<br>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个<br>线程共享同一个 session，是轻量级、一级缓存；<br>Transaction 接口：管理事务；<br>Query 和 Criteria 接口：执行数据库的查询。</p></li><li><p>iBatis 与 Hibernate 有什么不同?<br>相同点：屏蔽 jdbc api 的底层访问细节，使用我们不用与 jdbc api 打交道，就可以访问数据。<br>jdbc api 编程流程固定，还将 sql 语句与 java 代码混杂在了一起，经常需要拼凑 sql 语句，细<br>节很繁琐。<br>ibatis 的好处：屏蔽 jdbc api 的底层访问细节；将 sql 语句与 java 代码进行分离;提供了将结<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>果集自动封装称为实体对象和对象的集合的功能，queryForList 返回对象集合，用<br>queryForObject 返回单个对象；提供了自动将实体对象的属性传递给 sql 语句的参数。<br>Hibernate 是一个全自动的 orm 映射工具，它可以自动生成 sql 语句,ibatis 需要我们自己在 xml<br>配置文件中写 sql 语句，hibernate 要比 ibatis 功能负责和强大很多。因为 hibernate 自动生成<br>sql 语句，我们无法控制该语句，我们就无法去写特定的高效率的 sql。对于一些不太复杂的<br>sql 查询，hibernate 可以很好帮我们完成，但是，对于特别复杂的查询，hibernate 就很难适<br>应了，这时候用 ibatis 就是不错的选择，因为 ibatis 还是由我们自己写 sql 语句。</p></li><li><p>写 Hibernate 的一对多和多对一双向关联的 orm 配置?</p></li><li><p>什么是 ORM？<br>答：对象关系映射（Object—Relational Mapping，简称 ORM）是一种为了解决面向对象与<br>面向关系数据库存在的互不匹配的现象的技术；简单的说，ORM 是通过使用描述对象和数<br>据库之间映射的元数据，将 java 程序中的对象自动持久化到关系数据库中；本质上就是将<br>数据从一种形式转换到另外一种形式。</p></li><li><p>hibernate 的 inverse 属性的作用?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>在 DAO 中如何体现 DAO 设计模式?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>spring+Hibernate 中委托方案怎么配置?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>spring+Hibernate 中委托方案怎么配置?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>hibernate 进行多表查询每表中各取几个字段，就是说查询出的结果集没有一个实体<br>类与之对应如何解决<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p></li><li><p>介绍一下 Hibernate 的二级缓存<br>按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了 hibernate 的 Session 就<br>是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置 Hibernate<br>的二级缓存。<br>（1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），<br>这个数据结构通常是类似于 Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个<br>对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在<br>缓存中，以便下次使用。下面是缓存的伪代码：<br>引出 hibernate 的第二级缓存，用下面的伪代码分析了 Cache 的实现原理<br>（2）Hibernate 的 Session 就是一种缓存，我们通常将之称为 Hibernate 的一级缓存，当想使<br>用 session 从数据库中查询出一个对象时，Session 也是先从自己内部查看是否存在这个对象，<br>存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于 Session<br>代表一次会话过程，一个 Session 与一个数据库连接相关连，所以 Session 最好不要长时间<br>保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且 Session 是线程不安全<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，<br>才有较大的缓存价值，因此，Hibernate 的 Session 这一级缓存的缓存作用并不明显，应用价<br>值不大。Hibernate 的二级缓存就是要为 Hibernate 配置一种全局缓存，让多个线程和多个事<br>务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session 没有这<br>种效果。<br>（3）二级缓存是独立于 Hibernate 的软件部件，属于第三方的产品，多个厂商和组织都提供<br>有缓存产品，例如，EHCache 和 OSCache 等等。在 Hibernate 中使用二级缓存，首先就要在<br>hibernate.cfg.xml 配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己<br>的配置文件，最后要配置 Hibernate 中的哪些实体对象要纳入到二级缓存的管理中。明白了<br>二级缓存原理和有了这个思路后，很容易配置起 Hibernate 的二级缓存。扩展知识：一个<br>SessionFactory 可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数<br>据，当使用 Hibernate 的二级缓存后，注意不要有其他的应用或 SessionFactory 来更改当前<br>数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。</p></li><li><p>解释 Spring 的依赖注入? 给一个 Bean 的 message 属性, 字符串类型, 注入值为<br>“Hello”的 XML 配置文件该怎么写?</p></li><li><p>spring 与 EJB 的区别！<br>九、软件工程与设计模式</p></li><li><p>UML 方面<br>标准建模语言 UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作<br>图),实现图。</p></li><li><p>BS 与 CS 的联系与区别。<br>C&#x2F;S 是 Client&#x2F;Server 的缩写。服务器通常采用高性能的 PC、工作站或小型机，并采用大型<br>数据库系统，如 Oracle、Sybase、InFORMix 或 SQL Server。客户端需要安装专用的客户端<br>软件。<br>B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator<br>或 Internet Explorer，服务器安装 Oracle、Sybase、InFORMix 或 SQL Server 等数据库。在这<br>种结构下，用户界面完全通过 WWW 浏览器实现，一部分事务逻辑在前端实现，但是主要<br>事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C&#x2F;S 与 B&#x2F;S 区别：<br>１．硬件环境不同:<br>C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提<br>供连接和数据交换服务. B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息<br>自己管理. 有比 C&#x2F;S 更强的适应范围, 一般只要有操作系统和浏览器就行<br>２．对安全要求不同<br>C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系<br>统采用 C&#x2F;S 结构适宜. 可以通过 B&#x2F;S 发布部分可公开信息. B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同<br>C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑. B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比 C&#x2F;S 有更<br>高的要求 B&#x2F;S 结构的程序架构是发展的趋势, 从 MS 的.Net 系列的 BizTalk 2000 Exchange<br>2000 等, 全面支持网络的构件搭建的系统. SUN 和 IBM 推的 JavaBean 构件技术等,使 B&#x2F;S<br>更加成熟. ４．软件重用不同<br>C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性<br>好. B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可<br>以再利用,而不是做在墙上的石头桌子<br>５．系统维护不同<br>C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是<br>再做一个全新的系统<br>B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户<br>从网上自己下载安装就可以实现升级. ６．处理问题不同<br>C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统<br>B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是 C&#x2F;S 无法作到的. 与操作系<br>统平台关系最小.<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>７．用户接口不同<br>C&#x2F;S 多是建立的 Window 平台上,表现方法有限,对程序员普遍要求较高<br>B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低, 减低开发成本. ８．信息流不同<br>C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低<br>B&#x2F;S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。</p></li><li><p>应用服务器与 WEB SERVER 的区别？</p></li><li><p>应用服务器有那些？<br>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，<br>Tomcat</p></li><li><p>J2EE 是什么？<br>答:Je22 是 Sun 公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的<br>企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为<br>不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客<br>户层(clietn tier)组件,web 层和组件,Business 层和组件,企业信息系统(EIS)层。<br>一个另类的回答：j2ee 就是增删改查。</p></li><li><p>J2EE 是技术还是平台还是框架？ 什么是 J2EE?<br>J2EE 本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br>J2EE 也是一个框架，包括 JDBC、JNDI、RMI、JMS、EJB、JTA 等技术。</p></li><li><p>请对以下在 J2EE 中常用的名词进行解释(或简单描述)<br>web 容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP,SERVLET<br>直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有 WEB 服务器来实现。<br>例如：TOMCAT,WEBLOGIC,WEBSPHERE 等。该容器提供的接口严格遵守 J2EE 规范中的<br>WEB APPLICATION 标准。我们把遵守以上标准的 WEB 服务器就叫做 J2EE 中的 WEB 容<br>器。<br>EJB 容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件 EJB<br>各种管理功能。只要满足 J2EE 规范的 EJB 放入该容器，马上就会被容器进行高效率的管理。<br>并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。<br>JNDI：（Java Naming &amp; Directory Interface）JAVA 命名目录服务。主要提供的功能是：提供<br>一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位<br>分布式应用程序的功能。<br>JMS：（Java Message Service）JAVA 消息服务。主要实现各个应用程序之间的通讯。包括<br>点对点和广播。<br>JTA：（Java Transaction API）JAVA 事务服务。提供各种分布式事务服务。应用程序只需调<br>用其提供的接口即可。<br>JAF：（Java Action FrameWork）JAVA 安全认证框架。提供一些安全控制方面的框架。让开<br>发者通过各种部署和自定义实现自己的个性安全控制策略。<br>RMI&#x2F;IIOP:（Remote Method Invocation &#x2F;internet 对象请求中介协议）他们主要用于通过远程<br>调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本<br>地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>信。RMI 是 JAVA 特有的。</p></li><li><p>如何给 weblogic 指定大小的内存?<br>（这个问题不作具体回答，列出来只是告诉读者可能会遇到什么问题，你不需要面面俱到，<br>什么都精通。）<br>在启动 Weblogic 的脚本中（位于所在 Domian 对应服务器目录下的 startServerName），增加<br>set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为 32M，最大 200M</p></li><li><p>如何设定的 weblogic 的热启动模式(开发模式)与产品发布模式?<br>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启<br>动文件或者 commenv 文件，增加 set PRODUCTION_MODE&#x3D;true。</p></li><li><p>如何启动时不需输入用户名与密码?<br>修改服务启动文件，增加 WLS_USER 和 WLS_PW 项。也可以在 boot.properties 文件中增加<br>加密过的用户名和密码. 243. 在 weblogic 管理制台中对一个应用域(或者说是一个网站,Domain)进行 jms 及 ejb 或<br>连接池等相关信息进行配置后,实际保存在什么文件中?<br>保存在此 Domain 的 config.xml 文件中，它是服务器的核心配置文件。</p></li><li><p>说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的 helloWorld.jsp<br>放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp 就可以看<br>到运行结果了? 又比如这其中用到了一个自己写的 javaBean 该如何办?<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果<br>是 Web 应用，应用目录需要满足 Web 应用目录要求，jsp 文件可以直接放在应用目录中，<br>Javabean 需要放在应用目录的 WEB-INF 目录的 classes 目录中，设置服务器的缺省应用将可<br>以实现在浏览器上无需输入应用名。</p></li><li><p>在 weblogic 中发布 ejb 需涉及到哪些配置文件<br>不 同 类 型 的 EJB 涉 及 的 配 置 文 件 不 同 ， 都 涉 及 到 的 配 置 文 件 包 括<br>ejb-jar.xml,weblogic-ejb-jar.xmlCMP 实体 Bean 一般还需要 weblogic-cmp-rdbms-jar.xml</p></li><li><p>如何在 weblogic 中进行 ssl 配置与客户端的认证配置或说说 j2ee(标准)进行 ssl 的配<br>置?<br>缺省安装中使用 DemoIdentity.jks 和 DemoTrust.jks KeyStore 实现 SSL，需要配置服务器使<br>用 Enable SSL，配置其端口，在产品模式下需要从 CA 获取私有密钥和数字证书，创建 identity<br>和 trust keystore，装载获得的密钥和数字证书。可以配置此 SSL 连接是单向还是双向的。</p></li><li><p>如何查看在 weblogic 中已经发布的 EJB?<br>可以使用管理控制台，在它的 Deployment 中可以查看所有已发布的 EJB<br>十一、 ejb 部分</p></li><li><p>EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和<br>StatelessBean 区别。<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技术<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调<br>用其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对<br>象视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的<br>Session Bean 都可以将系统逻辑放在 method 之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean<br>的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就<br>是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗<br>J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状<br>态。</p></li><li><p>简要讲一下 EJB 的 7 个 Transaction Level?</p></li><li><p>EJB 与 JAVA BEAN 的区别？<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类<br>都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所<br>以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用<br>于实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，<br>它是不能被跨进程访问的。Enterprise Java Bean 相当于 DCOM，即分布式组件。它是基于<br>Java 的远程方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。<br>但 EJB 必须被布署在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正<br>的 EJB 组件，而是通过其容器访问。EJB 容器是 EJB 组件的代理，EJB 组件由容器所创建<br>和管理。客户通过容器来访问真正的 EJB 组件。</p></li><li><p>EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？<br>SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立<br>一个 Bean 的实例时，EJB 容器不一定要创建一个新的 Bean 的实例供客户机调用，而是随便<br>找一个现有的实例提供给客户机。当客户机第一次调用一个 Stateful Session Bean 时，容器<br>必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful<br>Session Bean 的方法时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不是按照应用程序或者服务进程来说的。即使 EJB 容器<br>崩溃了，Entity beans 也是存活的。Entity Beans 生命周期能够被容器或者 Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。</p></li><li><p>EJB 容器提供的服务<br>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</p></li><li><p>EJB 的激活机制<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>以Stateful Session Bean 为例：其 Cache大小决定了内存中可以同时存在的Bean实例的数量，<br>根据 MRU 或 NRU 算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某<br>个 EJB 实例业务方法时，如果对应 EJB Object 发现自己没有绑定对应的 Bean 实例则从其去<br>激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。</p></li><li><p>EJB 的几种类型<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean<br>会话 Bean 又可分为有状态（Stateful）和无状态（Stateless）两种<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种</p></li><li><p>客服端调用 EJB 对象的几个基本步骤<br>设置 JNDI 服务工厂以及 JNDI 服务地址系统属性，查找 Home 接口，从 Home 接口调用 Create<br>方法创建 Remote 接口，通过 Remote 接口调用其业务方法。 十二、 webservice 部分</p></li><li><p>名词解释：①WEB SERVICE ②JAXP ③JAXM ④SOAP ⑤UDDI ⑥WSDL。<br>JSWDL 开发包的介绍。<br>Web Service：Web Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 Web Service 能与其他兼容的组件进行互操作。<br>JAXP：(Java API for XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。<br>这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改<br>代码。<br>JAXM：(Java API for XML Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。<br>SOAP：即简单对象访问协议(Simple Object Access Protocol)，它是用于交换 XML 编码信息<br>的轻量级协议。<br>UDDI：的目的是为电子商务建立标准；UDDI 是一套基于 Web 的、分布式的、为 Web Service<br>提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的 Web Service<br>注册，以使别的企业能够发现的访问协议的实现标准。<br>WSDL：是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信<br>息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑<br>定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服<br>务）。</p></li><li><p>CORBA 是什么?用途是什么?<br>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象<br>管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为：用不同的程序<br>设计语言书写在不同的进程中运行，为不同的操作系统开发。 十三、 Linux</p></li><li><p>LINUX 下线程，GDI 类的解释。<br>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>轻量级进程，而线程之间的管理在核外函数库中实现。<br>GDI 类为图像设备编程接口类库。 十四、 问得稀里糊涂的题</p></li><li><p>简述逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别。<br>区别主要答两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以<br>操作数值型<br>b.逻辑操作不会产生短路<br>1，堆和栈的区别，有一个 64k 的字符串，是放到堆上，还是放到栈上，为什么？<br>2，什么时候用到接口，什么时候用到抽象类，二者区别<br>3，有一个 100 万的数组，里边有两个市重复的，如何设计算法找到。<br>4，设计数据库时，n 维，如何设计。<br>例如[省份][城市][网吧]，这是三维关系，它的表也应该有三个，网吧有外键引用城市，城市<br>有外键应用省份，这个规律就是下层的要有一外键去引用上层。</p></li><li><p>Java1.5 的新特性<br>一：Java 基础部分新特性：<br>自动拆箱<br>可变参数与 for each 循环<br>静态导入<br>二：IO 流部分：<br>printf 格式输出<br>Scanner<br>三：其他<br>泛型<br>枚举<br>Annotation<br>MyBatis 面试题<br>1、什么是 Mybatis？<br>1、Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时<br>只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建<br>statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性<br>能，灵活度高。<br>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数<br>据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过<br>java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最<br>后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返<br>回 result 的过程）。<br>2、Mybaits 的优点：<br>1、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任<br>何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML<br>标签，支持编写动态 SQL 语句，并可重用。<br>2、与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不<br>需要手动开关连接；<br>3、很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要<br>JDBC 支持的数据库 MyBatis 都支持）。<br>4、能够与 Spring 很好的集成；<br>5、提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射<br>标签，支持对象关系组件维护。<br>3、MyBatis 框架的缺点：<br>1、SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写<br>SQL 语句的功底有一定要求。<br>2、SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。<br>4、MyBatis 框架适用场合：<br>1、MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。<br>2、对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是<br>不错的选择。<br>5、MyBatis 与 Hibernate 有哪些不同？<br>1、Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要<br>程序员自己编写 Sql 语句。<br>2、Mybatis 直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高，非常<br>适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需<br>求变化要求迅速输出成果。但是灵活的前提是 mybatis 无法做到数据库无关性，<br>如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映射文件，工作量大。<br>3、Hibernate 对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的<br>软件，如果用 hibernate 开发可以节省很多代码，提高效率。<br>6、#{}和<code>$&#123;&#125;的区别是什么？ #&#123;&#125;是预编译处理，$</code>{}是字符串替换。<br>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的<br>set 方法来赋值；<br>Mybatis 在处理<code>$&#123;&#125;时，就是把$</code>{}替换成变量的值。<br>使用#{}可以有效的防止 SQL 注入，提高系统安全性。<br>7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？<br>第 1 种： 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类<br>的属性名一致。<br>&lt;select id&#x3D;”selectorder” parametertype&#x3D;”int” resultetype&#x3D;”<br>me.gacl.domain.order”&gt;<br>select order_id id, order_no orderno ,order_price price form<br>orders where order_id&#x3D;#{id};<br>&lt;&#x2F;select&gt;第 2 种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。 &lt;select id&#x3D;”getOrder” parameterType&#x3D;”int”<br>resultMap&#x3D;”orderresultmap”&gt;<br>select * from orders where order_id&#x3D;#{id} &lt;&#x2F;select&gt; &lt;resultMap type&#x3D;”me.gacl.domain.order” id&#x3D;”orderresultmap”&gt;<br>&lt;!–用 id 属性来映射主键字段–&gt; &lt;id property&#x3D;”id” column&#x3D;”order_id”&gt;<br>&lt;!–用 result 属性来映射非主键字段，property 为实体类属性名，column<br>为数据表中的属性–&gt; &lt;result property &#x3D; “orderno” column &#x3D;”order_no”&#x2F;&gt; &lt;result property&#x3D;”price” column&#x3D;”order_price” &#x2F;&gt; &lt;&#x2F;reslutMap&gt;<br>8、 模糊查询 like 语句该怎么写?<br>第 1 种：在 Java 代码中添加 sql 通配符。<br>string wildcardname &#x3D; “%smi%”;<br>list&lt;name&gt; names &#x3D; mapper.selectlike(wildcardname);<br>&lt;select id&#x3D;”selectlike”&gt;<br>select * from foo where bar like #{value} &lt;&#x2F;select&gt;<br>第 2 种：在 sql 语句中拼接通配符，会引起 sql 注入<br>string wildcardname &#x3D; “smi”;<br>list&lt;name&gt; names &#x3D; mapper.selectlike(wildcardname); &lt;select id&#x3D;”selectlike”&gt;<br>select * from foo where bar like “%”#{value}”%” &lt;&#x2F;select&gt;<br>9、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，<br>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，<br>参数不同时，方法能重载吗？<br>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；<br>接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的<br>参数，就是传递给 sql 的参数。<br>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符<br>串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个 &lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个<br>MapperStatement 对象。<br>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯<br>一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为<br>findStudentById 的 MapperStatement。<br>Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻<br>找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK<br>动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而<br>执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。<br>10、Mybatis 是如何进行分页的？分页插件的原理是什么？<br>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内<br>存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分<br>页功能，也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件<br>的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物<br>理分页语句和物理分页参数。<br>11、Mybatis是如何将sql执行结果封装为目标对象并返回的？<br>都有哪些映射形式？<br>第一种是使用&lt;resultMap&gt;标签，逐一定义数据库列名和对象属性名之间的映<br>射关系。<br>第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名。<br>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给<br>对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。<br>12、如何执行批量插入?<br>首先,创建一个简单的 insert 语句: &lt;insert id&#x3D;”insertname”&gt;<br>insert into names (name) values (#{value}) &lt;&#x2F;insert&gt;<br>然后在 java 代码中像下面这样执行批处理插入:<br>list &lt; string &gt; names &#x3D; new arraylist();<br>names.add(“fred”);<br>names.add(“barney”);<br>names.add(“betty”);<br>names.add(“wilma”);<br>&#x2F;&#x2F; 注意这里 executortype.batch<br>sqlsession sqlsession &#x3D;<br>sqlsessionfactory.opensession(executortype.batch);<br>try {<br>namemapper mapper &#x3D; sqlsession.getmapper(namemapper.class);<br>for (string name: names) {<br>mapper.insertname(name);<br>}<br>sqlsession.commit();<br>} catch (Exception e) {<br>e.printStackTrace();<br>sqlSession.rollback();<br>throw e;<br>}<br>finally {<br>sqlsession.close();<br>}<br>13、如何获取自动生成的(主)键值?<br>insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。<br>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入<br>的参数对象中。<br>示例：<br>&lt;insert id&#x3D;”insertname” usegeneratedkeys&#x3D;”true” keyproperty&#x3D;”<br>id”&gt;<br>insert into names (name) values (#{name}) &lt;&#x2F;insert&gt;<br>name name &#x3D; new name();<br>name.setname(“fred”);<br>int rows &#x3D; mapper.insertname(name);<br>&#x2F;&#x2F; 完成后,id 已经被设置到对象中<br>system.out.println(“rows inserted &#x3D; ” + rows);<br>system.out.println(“generated key value &#x3D; ” + name.getid());<br>14、在 mapper 中如何传递多个参数?<br>1、第一种：<br>DAO 层的函数<br>public UserselectUser(String name,String area);<br>对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第二<br>参数，更多参数一致往后加即可。<br>&lt;select id&#x3D;”selectUser”resultMap&#x3D;”BaseResultMap”&gt;<br>select * fromuser_user_t whereuser_name &#x3D; #{0}<br>anduser_area&#x3D;#{1} &lt;&#x2F;select&gt;<br>2、第二种： 使用 @param 注解:<br>public interface usermapper {<br>user selectuser(@param(“username”) string<br>username,@param(“hashedpassword”) string hashedpassword);<br>}<br>然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给<br>mapper): &lt;select id&#x3D;”selectuser” resulttype&#x3D;”user”&gt;<br>select id, username, hashedpassword<br>from some_table<br>where username &#x3D; #{username}<br>and hashedpassword &#x3D; #{hashedpassword} &lt;&#x2F;select&gt;<br>3、第三种：多个参数封装成 map<br>try {<br>&#x2F;&#x2F;映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的<br>SQL<br>&#x2F;&#x2F;由于我们的参数超过了两个，而方法中只有一个 Object 参数收集，因此<br>我们使用 Map 集合来装载我们的参数<br>Map &lt; String, Object &gt; map &#x3D; new HashMap();<br>map.put(“start”, start);<br>map.put(“end”, end);<br>return sqlSession.selectList(“StudentID.pagination”, map);<br>} catch (Exception e) {<br>e.printStackTrace();<br>sqlSession.rollback();<br>throw e;<br>} finally {<br>MybatisUtil.closeSqlSession();<br>}<br>15、Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？<br>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理<br>是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。<br>Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose<br>| when | otherwise | bind。<br>16、Xml 映射文件中，除了常见的 select|insert|updae|delete<br>标签之外，还有哪些标签？<br>答：&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、 &lt;selectKey&gt;，加上动态 sql 的 9 个标签，其中&lt;sql&gt;为 sql 片段标签，通过 &lt;include&gt;标签引入 sql 片段，&lt;selectKey&gt;为不支持自增的主键生成策略标<br>签。<br>17、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？<br>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配<br>置 namespace，那么 id 不能重复；<br>原因就是 namespace+id 是作为 Map&lt;String, MapperStatement&gt;的 key<br>使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。<br>有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然<br>也就不同。<br>18、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动<br>的区别在哪里？<br>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联<br>集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis<br>在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自<br>动 ORM 映射工具。<br>&lt;select id&#x3D;”getClass” parameterType&#x3D;”int”<br>resultMap&#x3D;”ClassesResultMap”&gt;<br>select * from class c,teacher t where c.teacher_id&#x3D;t.t_id and<br>c.c_id&#x3D;#{id} &lt;&#x2F;select&gt; &lt;resultMap type&#x3D;”com.lcb.user.Classes” id&#x3D;”ClassesResultMap”&gt;&lt;id property&#x3D;”id” column&#x3D;”c_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”c_name”&#x2F;&gt;<br>&lt;association property&#x3D;”teacher”<br>javaType&#x3D;”com.lcb.user.Teacher”&gt;<br>&lt;id property&#x3D;”id” column&#x3D;”t_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”t_name”&#x2F;&gt;<br>&lt;&#x2F;association&gt;<br>&lt;&#x2F;resultMap&gt;&lt;select id&#x3D;”getClass2” parameterType&#x3D;”int”<br>resultMap&#x3D;”ClassesResultMap2”&gt;<br>select * from class c,teacher t,student s where c.teacher_id&#x3D;t.t_id<br>and c.c_id&#x3D;s.class_id and c.c_id&#x3D;#{id}<br>&lt;&#x2F;select&gt;<br>&lt;resultMap type&#x3D;”com.lcb.user.Classes” id&#x3D;”ClassesResultMap2”&gt;<br>&lt;id property&#x3D;”id” column&#x3D;”c_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”c_name”&#x2F;&gt;<br>&lt;association property&#x3D;”teacher”<br>javaType&#x3D;”com.lcb.user.Teacher”&gt;<br>&lt;id property&#x3D;”id” column&#x3D;”t_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”t_name”&#x2F;&gt;<br>&lt;&#x2F;association&gt;<br>&lt;collection property&#x3D;”student”<br>ofType&#x3D;”com.lcb.user.Student”&gt;<br>&lt;id property&#x3D;”id” column&#x3D;”s_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”s_name”&#x2F;&gt;<br>&lt;&#x2F;collection&gt;<br>&lt;&#x2F;resultMap&gt;<br>&lt;&#x2F;mapper&gt;<br>20、MyBatis 实现一对一有几种方式?具体怎么操作的？<br>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在<br>resultMap 里面配置 association 节点配置一对一的类就可以完成；<br>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面<br>查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。<br>21、MyBatis 实现一对多有几种方式,怎么操作的？<br>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在<br>resultMap 里面的 collection 节点配置一对多的类就可以完成；嵌套查询是先查<br>一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过<br>配置 collection,但另外一个表的查询通过 select 节点配置。<br>22、Mybatis 是否支持延迟加载？如果支持，它的实现原理是<br>什么？<br>答：Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加<br>载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis<br>配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。<br>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦<br>截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是<br>null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，<br>然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()<br>方法的调用。这就是延迟加载的基本原理。<br>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都<br>是一样的。<br>23、Mybatis 的一级、二级缓存:<br>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为<br>Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就<br>将清空，默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap<br>存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，<br>如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要<br>实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br>&lt;cache&#x2F;&gt; ；<br>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存<br>Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将<br>被 clear。<br>24、什么是 MyBatis 的接口绑定？有哪些实现方式？<br>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑<br>定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可<br>以有更加灵活的选择和设置。<br>接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上<br>@Select、@Update 等注解，里面包含 Sql 语句来绑定；另外一种就是通过 xml<br>里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须<br>为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂<br>时候,用 xml 绑定,一般用 xml 绑定的比较多。<br>25、使用 MyBatis 的 mapper 接口调用时有哪些要求？<br>1、Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；<br>2、Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的<br>parameterType 的类型相同；<br>3、Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的<br>resultType 的类型相同；<br>4、Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。<br>26、Mapper 编写有哪几种方式？<br>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写<br>mapper 接口，mapper 接口实现类、mapper.xml 文件。<br>1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置<br>&lt;mappers&gt;<br>&lt;mapper resource&#x3D;”mapper.xml 文件的地址” &#x2F;&gt;<br>&lt;mapper resource&#x3D;”mapper.xml 文件的地址” &#x2F;&gt;<br>&lt;&#x2F;mappers&gt;<br>1、定义 mapper 接口<br>3、实现类集成 SqlSessionDaoSupport<br>mapper 方法中可以 this.getSqlSession()进行数据增删改查。<br>4、spring 配置<br>&lt;bean id&#x3D;” “ class&#x3D;”mapper 接口的实现”&gt;<br>&lt;property name&#x3D;”sqlSessionFactory”<br>ref&#x3D;”sqlSessionFactory”&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：<br>1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和<br>mappre 接口的名称相同且在同一个目录，这里可以不用配置<br>&lt;mappers&gt;<br>&lt;mapper resource&#x3D;”mapper.xml 文件的地址” &#x2F;&gt;<br>&lt;mapper resource&#x3D;”mapper.xml 文件的地址” &#x2F;&gt;<br>&lt;&#x2F;mappers&gt;<br>2、定义 mapper 接口：<br>1、mapper.xml 中的 namespace 为 mapper 接口的地址<br>2、mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一<br>致<br>3、Spring 中定义<br>&lt;bean id&#x3D;”” class&#x3D;”org.mybatis.spring.mapper.MapperFactoryBean”&gt;<br>&lt;property name&#x3D;”mapperInterface” value&#x3D;”mapper 接口地址” &#x2F;&gt;<br>&lt;property name&#x3D;”sqlSessionFactory” ref&#x3D;”sqlSessionFactory” &#x2F;&gt;<br>&lt;&#x2F;bean&gt;<br>第三种：使用 mapper 扫描器：<br>1、mapper.xml 文件编写：<br>mapper.xml 中的 namespace 为 mapper 接口的地址；<br>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；<br>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml<br>中进行配置。<br>2、定义 mapper 接口：<br>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录<br>3、配置 mapper 扫描器：<br>&lt;bean class&#x3D;”org.mybatis.spring.mapper.MapperScannerConfigurer”&gt;<br>&lt;property name&#x3D;”basePackage” value&#x3D;”mapper 接口包地址<br>“&gt;&lt;&#x2F;property&gt;<br>&lt;property name&#x3D;”sqlSessionFactoryBeanName”<br>value&#x3D;”sqlSessionFactory”&#x2F;&gt;<br>&lt;&#x2F;bean&gt;<br>4、使用扫描器后从 spring 容器中获取 mapper 的实现对象。<br>27、简述 Mybatis 的插件运行原理，以及如何编写一个插件。<br>答：Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、<br>StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代<br>理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种<br>接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()<br>方法，当然，只会拦截那些你指定需要拦截的方法。<br>编写插件：实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给<br>插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文<br>件中配置你编写的插件。<br>ZooKeeper 面试题1. ZooKeeper 面试题？<br>ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群<br>中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用<br>的接口和性能高效、功能稳定的系统提供给用户。<br>分布式应用程序可以基于 Zookeeper 实现诸如数据发布&#x2F;订阅、负载均衡、命名<br>服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。<br>Zookeeper 保证了如下分布式一致性特性：<br>1、顺序一致性<br>2、原子性<br>3、单一视图<br>4、可靠性<br>5、实时性（最终一致性）<br>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了<br>监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些<br>请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，<br>随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。<br>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个<br>更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。<br>而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个<br>zookeeper 最新的 zxid。</p></li><li><p>ZooKeeper 提供了什么？<br>1、文件系统<br>2、通知机制</p></li><li><p>Zookeeper 文件系统<br>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不<br>同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放<br>数据而目录节点不行。<br>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这<br>种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为<br>1M。</p></li><li><p>ZAB 协议？<br>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广<br>播协议。<br>ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。<br>当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导<br>致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进<br>入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务<br>器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader<br>服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始<br>接收客户端的事务请求生成事物提案来进行事务请求处理。</p></li><li><p>四种类型的数据节点 Znode<br>1、PERSISTENT-持久节点<br>除非手动删除，否则节点一直存在于 Zookeeper 上<br>2、EPHEMERAL-临时节点<br>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与<br>zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都<br>会被移除。<br>3、PERSISTENT_SEQUENTIAL-持久顺序节点<br>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维<br>护的自增整型数字。<br>4、EPHEMERAL_SEQUENTIAL-临时顺序节点<br>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的<br>自增整型数字。</p></li><li><p>Zookeeper Watcher 机制 – 数据变更通知<br>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务<br>端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通<br>知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出<br>业务上的改变。<br>工作机制：<br>1、客户端注册 watcher<br>2、服务端处理 watcher<br>3、客户端回调 watcher<br>Watcher 特性总结：<br>1、一次性<br>无论是服务端还是客户端，一旦一个 Watcher 被触发，Zookeeper 都会将其从相<br>应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频<br>繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的<br>压力都非常大。<br>2、客户端串行执行<br>客户端 Watcher 回调的过程是一个串行同步的过程。<br>3、轻量<br>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具<br>体内容。<br>3.2、客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对<br>象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。<br>4、watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步<br>的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于<br>网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身<br>提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode<br>发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。<br>Zookeeper 只能保证最终的一致性，而无法保证强一致性。<br>5、注册 watcher getData、exists、getChildren<br>6、触发 watcher create、delete、setData<br>7、当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。<br>当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接<br>时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全<br>透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode<br>的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上<br>之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</p></li><li><p>客户端注册 Watcher 实现<br>1、调用 getData()&#x2F;getChildren()&#x2F;exist()三个 API，传入 Watcher 对象<br>2、标记请求 request，封装 Watcher 到 WatchRegistration<br>3、封装成 Packet 对象，发服务端发送 request<br>4、收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理<br>5、请求返回，完成注册。</p></li><li><p>服务端处理 Watcher 实现<br>1、服务端接收 Watcher 并存储<br>接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点<br>的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现<br>了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在<br>WatcherManager 的 WatchTable 和 watch2Paths 中去。<br>2、Watcher 触发<br>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：<br>2.1 封装 WatchedEvent<br>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路<br>径封装成一个 WatchedEvent 对象<br>2.2 查询 Watcher<br>从 WatchTable 中根据节点路径查找 Watcher<br>2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher<br>2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里<br>可以看出 Watcher 在服务端是一次性的，触发一次就失效了）<br>3、调用 process 方法来触发 Watcher<br>这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。</p></li><li><p>客户端回调 Watcher<br>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。<br>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。</p></li><li><p>ACL 权限控制机制<br>UGO（User&#x2F;Group&#x2F;Others）<br>目前在 Linux&#x2F;Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗<br>粒度的文件系统权限控制模式。<br>ACL（Access Control List）访问控制列表<br>包括三个方面：<br>权限模式（Scheme）<br>1、IP：从 IP 地址粒度进行权限控制<br>2、Digest：最常用，用类似于 username:password 的权限标识来进行权限配<br>置，便于区分不同应用来进行权限控制<br>3、World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标<br>识“world:anyone”<br>4、Super：超级用户<br>授权对象<br>授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。<br>权限 Permission<br>1、CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点<br>2、DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点<br>3、READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内<br>容或子节点列表等<br>4、WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作<br>5、ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置<br>操作</p></li><li><p>Chroot 特性<br>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名<br>空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将<br>会被限制在其自己的命名空间下。<br>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对<br>应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相<br>互隔离非常有帮助。</p></li><li><p>会话管理<br>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进<br>行不同区块的隔离处理以及同一区块的统一处理。<br>分配原则：每个会话的“下次超时时间点”（ExpirationTime）<br>计算公式：<br>ExpirationTime_ &#x3D; currentTime + sessionTimeout<br>ExpirationTime &#x3D; (ExpirationTime_ &#x2F; ExpirationInrerval + 1) *<br>ExpirationInterval , ExpirationInterval 是指 Zookeeper 会话超时检查时间<br>间隔，默认 tickTime</p></li><li><p>服务器角色<br>Leader<br>1、事务请求的唯一调度和处理者，保证集群事务处理的顺序性<br>2、集群内部各服务的调度者<br>Follower<br>1、处理客户端的非事务请求，转发事务请求给 Leader 服务器<br>2、参与事务请求 Proposal 的投票<br>3、参与 Leader 选举投票<br>Observer<br>1、3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提<br>升集群的非事务处理能力<br>2、处理客户端的非事务请求，转发事务请求给 Leader 服务器<br>3、不参与任何形式的投票</p></li><li><p>Zookeeper 下 Server 工作状态<br>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。<br>1、LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中<br>没有 Leader，因此需要进入 Leader 选举状态。<br>2、FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。<br>3、LEADING：领导者状态。表明当前服务器角色是 Leader。<br>4、OBSERVING：观察者状态。表明当前服务器角色是 Observer。</p></li><li><p>数据同步<br>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）回向<br>Leader 服务器进行注册。当 Learner 服务器想 Leader 服务器完成注册后，进入<br>数据同步环节。<br>数据同步流程：（均以消息传递的方式进行）<br>Learner 向 Learder 注册<br>数据同步<br>同步确认<br>Zookeeper 的数据同步通常分为四类：<br>1、直接差异化同步（DIFF 同步）<br>2、先回滚再差异化同步（TRUNC+DIFF 同步）<br>3、仅回滚同步（TRUNC 同步）<br>4、全量同步（SNAP 同步）<br>在进行数据同步前，Leader 服务器会完成数据同步初始化：<br>peerLastZxid：<br> 从 learner 服务器注册时发送的 ACKEPOCH 消息中提取 lastZxid（该<br>Learner 服务器最后处理的 ZXID）<br>minCommittedLog：<br> Leader 服务器 Proposal 缓存队列 committedLog 中最小 ZXID<br>maxCommittedLog：<br> Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID<br>直接差异化同步（DIFF 同步）<br> 场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog<br>之间<br>先回滚再差异化同步（TRUNC+DIFF 同步）<br> 场景：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没<br>有的事务记录，那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader<br>服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID<br>仅回滚同步（TRUNC 同步）<br> 场景：peerLastZxid 大于 maxCommittedLog<br>全量同步（SNAP 同步）<br> 场景一：peerLastZxid 小于 minCommittedLog<br> 场景二：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等<br>于 lastProcessZxid</p></li><li><p>zookeeper 是如何保证事务的顺序一致性的？<br>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被<br>提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时<br>期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch<br>会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两<br>阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能<br>执行并且能够成功，那么就会开始执行。</p></li><li><p>分布式集群中为什么会有 Master？<br>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机<br>器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行<br>leader 选举。</p></li><li><p>zk 节点宕机如何处理？<br>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保<br>证当一个节点宕机时，其他节点会继续提供服务。<br>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数<br>据是有多个副本的，数据并不会丢失；<br>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。<br>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK<br>节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。<br>所以<br>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)<br>2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;&#x3D;1)</p></li><li><p>zookeeper 负载均衡和 nginx 负载均衡区别<br>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写<br>插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。</p></li><li><p>Zookeeper 有哪几种几种部署模式？<br>部署模式：单机模式、伪集群模式、集群模式。</p></li><li><p>集群最少要几台机器，集群规则是怎样的?<br>集群规则为 2N+1 台，N&gt;0，即 3 台。</p></li><li><p>集群支持动态添加机器吗？<br>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：<br>全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的<br>会话。<br>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供<br>服务。这是比较常用的方式。<br>3.5 版本开始支持动态扩容。</p></li><li><p>Zookeeper 对节点的 watch监听通知是永久的吗？为什么<br>不是永久的?<br>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch<br>的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，<br>以便通知它们。<br>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况<br>下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。<br>一般是客户端执行 getData(“&#x2F;节点 A”,true)，如果节点 A 发生了变更或删除，<br>客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没<br>有设置 watch 事件，就不再给客户端发送。<br>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我<br>只要最新的数据即可。</p></li><li><p>Zookeeper 的 java 客户端都有哪些？<br>java 客户端：zk 自带的 zkclient 及 Apache 开源的 Curator。</p></li><li><p>chubby 是什么，和 zookeeper 比你怎么看？<br>chubby 是 google 的，完全实现 paxos 算法，不开源。zookeeper 是 chubby<br>的开源实现，使用 zab 协议，paxos 算法的变种。</p></li><li><p>说几个 zookeeper 常用的命令。<br>常用命令：ls get set create delete 等。</p></li><li><p>ZAB 和 Paxos 算法的联系与区别？<br>相同点：<br>1、两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程<br>的运行<br>2、Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提<br>案进行提交<br>3、ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader<br>周期，Paxos 中名字为 Ballot<br>不同点：<br>ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建<br>分布式一致性状态机系统。</p></li><li><p>Zookeeper 的典型应用场景<br>Zookeeper 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员<br>可以使用它来进行分布式数据的发布和订阅。<br>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机<br>制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：<br>1、数据发布&#x2F;订阅<br>2、负载均衡<br>3、命名服务<br>4、分布式协调&#x2F;通知<br>5、集群管理<br>6、Master 选举<br>7、分布式锁<br>8、分布式队列</p></li><li><p>数据发布&#x2F;订阅<br>介绍<br>数据发布&#x2F;订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者<br>进行数据订阅。<br>目的<br>动态获取数据（配置信息）<br>实现数据（配置信息）的集中式管理和数据的动态更新<br>设计模式<br>Push 模式<br>Pull 模式<br>数据（配置信息）特性<br>1、数据量通常比较小<br>2、数据内容在运行时会发生动态更新<br>3、集群中各机器共享，配置一致<br>如：机器列表信息、运行时开关配置、数据库配置信息等<br>基于 Zookeeper 的实现方式<br> 数据存储：将数据（配置信息）存储到 Zookeeper 上的一个数据节点<br> 数据获取：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并<br>在该节点上注册一个数据变更 Watcher<br> 数据变更：当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper<br>会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即<br>可。</p></li><li><p>负载均衡<br>zk 的命名服务<br>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局<br>的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，<br>或者一个远程的对象等等。<br>分布式通知和协调<br>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，<br>然后 zk 将这些变化发送给注册了这个节点的 watcher 的所有客户端。<br>对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工<br>作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时<br>的全局情况。<br>zk 的命名服务（文件系统）<br>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局<br>的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，<br>提供的服务的地址，或者一个远程的对象等等。<br>zk 的配置管理（文件系统、通知机制）<br>程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有<br>配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的<br>内容，利用 watcher 通知给各个客户端，从而更改配置。<br>Zookeeper 集群管理（文件系统、通知机制）<br>所谓集群管理无在乎两点：是否有机器退出和加入、选举 master。<br>对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点<br>的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper 的连接断开，其所创<br>建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于<br>是，所有人都知道：它上船了。<br>新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount 又有了，<br>对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选<br>取编号最小的机器作为 master 就好。<br>Zookeeper 分布式锁（文件系统、通知机制）<br>有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，<br>一个是保持独占，另一个是控制时序。<br>对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode<br>的方式来实现。所有客户端都去创建 &#x2F;distribute_lock 节点，最终成功创建的那<br>个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放<br>出锁。<br>对于第二类， &#x2F;distribute_lock 已经预先存在，所有客户端在它下面创建临时顺<br>序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便。<br>Zookeeper 队列管理（文件系统、通知机制）<br>两种类型的队列：<br>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有<br>成员到达。<br>2、队列按照 FIFO 方式进行入队和出队操作。<br>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。<br>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按<br>编号。在特定的目录下创建 PERSISTENT_SEQUENTIAL 节点，创建成功时<br>Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下<br>Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内<br>容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持<br>久化的，所以不必担心队列消息的丢失问题。</p></li></ol><p>7、服务提供者能实现失效踢出是什么原理？<br>服务失效踢出基于 zookeeper 的临时节点原理。<br>8、服务上线怎么不影响旧版本？<br>采用多版本开发，不影响旧版本。<br>9、如何解决服务调用链过长的问题？<br>可以结合 zipkin 实现分布式服务追踪。</p><p>12、同一个服务多个注册的情况下可以直连某一个服务吗？<br>可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。<br>13、画一画服务注册与发现的流程图？<br>14、Dubbo 集群容错有几种方案？<br>集群容错方案 说明<br>Failover Cluster 失败自动切换，自动重试其它服务器（默认）<br>Failfast Cluster 快速失败，立即报错，只发起一次调用<br>Failsafe Cluster 失败安全，出现异常时，直接忽略<br>Failback Cluster 失败自动恢复，记录失败请求，定时重发<br>Forking Cluster 并行调用多个服务器，只要一个成功即返回<br>Broadcast Cluster 广播逐个调用所有提供者，任意一个报错则报错<br>15、Dubbo 服务降级，失败重试怎么做？<br>可以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修<br>改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口<br>名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑<br>16、Dubbo 使用过程中都遇到了些什么问题？<br>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解<br>无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确<br>17、Dubbo Monitor 实现原理？<br>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是<br>先走 filter 链，然后才进行真正的业务逻辑处理。<br>默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。<br>1、MonitorFilter 向 DubboMonitor 发送数据<br>2、DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到<br>ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个<br>含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，<br>调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕<br>一个，就重置当前的 Statistics 的 AtomicReference<br>3、SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队<br>列大写为 100000）<br>4、SimpleMonitorService 使用一个后台线程（线程名为：<br>DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以<br>死循环的形式来写）<br>5、SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：<br>DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</p><p>19、Dubbo 配置文件是如何加载到 Spring 中的？<br>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自<br>定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，<br>NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为<br>需要加载的 bean 对象！<br>20、Dubbo SPI 和 Java SPI 区别？<br>JDK SPI<br>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展吃实话很耗时，但<br>也没用上，很浪费资源。<br>所以只希望加载某个的实现，就不现实了<br>DUBBO SPI<br>1，对 Dubbo 进行扩展，不需要改动 Dubbo 的源码<br>2，延迟加载，可以一次只加载自己想要加载的扩展实现。<br>3，增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其<br>它扩展点。<br>3，Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。<br>21、Dubbo 支持分布式事务吗？<br>目前暂时不支持，可与通过 tcc-transaction 框架实现<br>介绍：tcc-transaction 是开源的 TCC 补偿性分布式事务框架<br>Git 地址：<br>TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。<br>22、Dubbo 可以对结果进行缓存吗？<br>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作<br>量<br>&lt;dubbo:reference cache&#x3D;”true” &#x2F;&gt;<br>其实比普通的配置文件就多了一个标签 cache&#x3D;”true”<br>23、服务上线怎么兼容旧版本？<br>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不<br>同的服务相互间不引用。这个和服务分组的概念有一点类似。<br>24、Dubbo 必须依赖的包有哪些？<br>Dubbo 必须依赖 JDK，其他为可选。<br>25、Dubbo telnet 命令能做什么？<br>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。<br>Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令<br>连接服务<br>telnet localhost 20880 &#x2F;&#x2F;键入回车进入 Dubbo 命令模式。<br>查看服务列表<br>dubbo&gt;ls<br>com.test.TestService<br>dubbo&gt;ls com.test.TestService<br>create<br>delete<br>query<br> ls (list services and methods)<br> ls : 显示服务列表。<br> ls -l : 显示服务详细信息列表。<br> ls XxxService：显示服务的方法列表。<br> ls -l XxxService：显示服务的方法详细信息列表。<br>26、Dubbo 支持服务降级吗？<br>以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修改<br>为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名<br>称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑<br>27、Dubbo 如何优雅停机？<br>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用<br>kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才<br>会执行。<br>28、Dubbo 和 Dubbox 之间的区别？<br>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如<br>加了服务可 Restful 调用，更新了开源组件等。</p><p>30、你还了解别的分布式框架吗？<br>别的还有 spring 的 spring cloud，facebook 的 thrift，twitter 的 finagle 等</p><p>仅索引层面调优手段：<br>1.1、设计阶段调优<br>1、根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索<br>引；<br>2、使用别名进行索引管理；<br>3、每天凌晨定时对索引做 force_merge 操作，以释放空间；<br>4、采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink<br>操作，以缩减存储；<br>5、采取 curator 进行索引的生命周期管理；<br>6、仅针对需要分词的字段，合理的设置分词器；<br>7、Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。……..<br>1.2、写入调优<br>1、写入前副本数设置为 0；<br>2、写入前关闭 refresh_interval 设置为-1，禁用刷新机制；<br>3、写入过程中：采取 bulk 批量写入；<br>4、写入后恢复副本数和刷新间隔；<br>5、尽量使用自动生成的 id。<br>1.3、查询调优<br>1、禁用 wildcard；<br>2、禁用批量 terms（成百上千的场景）；<br>3、充分利用倒排索引机制，能 keyword 类型尽量 keyword；<br>4、数据量大时候，可以先基于时间敲定索引再检索；<br>5、设置合理的路由机制。<br>1.4、其他调优<br>部署调优，业务调优等。<br>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。<br>2、elasticsearch 的倒排索引是什么<br>面试官：想了解你对基础概念的认知。<br>解答：通俗解释一下就可以。<br>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。<br>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表<br>即为倒排索引。<br>有了倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了<br>检索效率。<br>学术的解答方式：<br>倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文<br>档中出现过，由两部分组成——词典和倒排表。<br>加分项：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结<br>构。<br>lucene 从 4+版本后开始大量使用的数据结构是 FST。FST 有两个优点：<br>1、空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；<br>2、查询速度快。O(len(str))的查询时间复杂度。<br>3、elasticsearch 索引数据多了怎么办，如何调优，部署<br>面试官：想了解大数据量的运维能力。<br>解答：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，<br>这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户<br>检索或者其他业务受到影响。<br>如何调优，正如问题 1 所说，这里细化一下：<br>3.1 动态索引层面<br>基于模板+时间+rollover api 滚动创建索引，举例：设计阶段定义：blog 索<br>引的模板格式为：blog_index_时间戳的形式，每天递增数据。<br>这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线 2 的<br>32 次幂-1，索引存储达到了 TB+甚至更大。<br>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。<br>3.2 存储层面<br>冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。<br>对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，<br>节省存储空间和检索效率。<br>3.3 部署层面<br>一旦之前没有规划，这里就属于应急策略。<br>结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注<br>意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。<br>4、elasticsearch 是如何实现 master 选举的<br>面试官：想了解 ES 集群的底层原理，不再只关注业务层面了。<br>解答：<br>前置前提：<br>1、只有候选主节点（master：true）的节点才能成为主节点。<br>2、最小主节点数（min_master_nodes）的目的是防止脑裂。<br>这个我看了各种网上分析的版本和源码分析的书籍，云里雾里。<br>核对了一下代码，核心入口为 findMaster，选择主节点成功返回对应 Master，否<br>则返回 null。选举流程大致描述如下：<br>第一步：确认候选主节点数达标，elasticsearch.yml 设置的值<br>discovery.zen.minimum_master_nodes；<br>第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；<br>若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。<br>题外话：获取节点 id 的方法。<br>1GET &#x2F;_cat&#x2F;nodes?v&amp;h&#x3D;ip,port,heapPercent,heapMax,id,name<br>2ip port heapPercent heapMax id name<br>5、详细描述一下 Elasticsearch 索引文档的过程<br>面试官：想了解 ES 的底层原理，不再只关注业务层面了。<br>解答：<br>这里的索引文档应该理解为文档写入 ES，创建索引的过程。<br>文档写入包含：单文档写入和批量 bulk 写入，这里只解释一下：单文档写入流程。<br>记住官方文档中的这个图。<br>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由&#x2F;协调节点，<br>请求的节点扮演路由节点的角色。）<br>第二步：节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转<br>到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。<br>第三步：节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1<br>和节点 2 的副本分片上，等待结果返回。所有的副本分片都报告成功，节点 3 将<br>向协调节点（节点 1）报告成功，节点 1 向请求客户端报告写入成功。<br>如果面试官再问：第二步中的文档获取分片的过程？<br>回答：借助路由算法获取，路由算法就是根据路由和文档 id 计算目标的分片 id 的<br>过程。<br>1shard &#x3D; hash(*routing) % (num_of_primary_shards)<br>6、详细描述一下 Elasticsearch 搜索的过程？<br>面试官：想了解 ES 搜索的底层原理，不再只关注业务层面了。<br>解答：<br>搜索拆解为“query then fetch” 两个阶段。<br>query 阶段的目的：定位到位置，但不取。<br>步骤拆解如下：<br>1、假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本<br>分片中）的一个。<br>2、每个分片在本地进行查询，结果返回到本地有序的优先队列中。<br>3、第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。<br>fetch 阶段的目的：取数据。<br>路由节点获取所有文档，返回给客户端。<br>7、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法<br>面试官：想了解对 ES 集群的运维能力。<br>解答：<br>1、关闭缓存 swap;<br>2、堆内存设置为：Min（节点内存&#x2F;2, 32GB）;<br>3、设置最大文件句柄数；<br>4、线程池+队列大小根据业务需要做调整；<br>5、磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单<br>节点存储故障。</p><p>9、Elasticsearch 是如何实现 Master 选举的？<br>1、Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之<br>间通过这个 RPC 来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪<br>些节点需要 ping 通）这两部分；<br>2、对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排<br>序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第 0 位）<br>节点，暂且认为它是 master 节点。<br>3、如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n&#x2F;2+1）并<br>且该节点自己也选举自己，那这个节点就是 master。否则重新选举一直到满足上<br>述条件。<br>4、补充：master 节点的职责主要包括集群、节点和索引的管理，不负责文档级<br>别的管理；data 节点可以关闭 http 功能*。<br>10、Elasticsearch 中的节点（比如共 20 个），其中的 10 个<br>选了一个 master，另外 10 个选了另一个 master，怎么办？<br>1、当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量<br>（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解<br>决脑裂问题；<br>2、当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data<br>节点，避免脑裂问题。<br>11、客户端在和集群连接时，如何选择特定的节点执行请求的？<br>1、TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并<br>不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮<br>询 的方式与这些地址进行通信。<br>12、详细描述一下 Elasticsearch 索引文档的过程。<br>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合<br>适的分片。<br>shard &#x3D; hash(document_id) % (num_of_primary_shards)<br>1、当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory<br>Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Momery<br>Buffer 到 Filesystem Cache 的过程就叫做 refresh；<br>2、当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会<br>丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请<br>求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中<br>时，才会清除掉，这个过程叫做 flush；<br>3、在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync<br>将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一<br>个新的 translog。<br>4、flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认<br>为 512M）时；<br>补充：关于 Lucene 的 Segement：<br>1、Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。<br>2、段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重<br>建索引。<br>3、对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗<br>CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。<br>4、为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并<br>段到磁盘，并删除那些旧的小段。<br>13、详细描述一下 Elasticsearch 更新和删除文档的过程。<br>1、删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不<br>能被删除或者改动以展示其变更；<br>2、磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真<br>的被删除，而是在.del 文件中被标记为删除。该文档依然能匹配查询，但是会在<br>结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入<br>新段。<br>3、在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新<br>时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。<br>旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。<br>14、详细描述一下 Elasticsearch 搜索的过程。<br>1、搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；<br>2、在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分<br>片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的<br>优先队列。<br>PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory<br>Buffer，所以搜索是近实时的。<br>3、每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并<br>这些值到自己的优先队列中来产生一个全局排序后的结果列表。<br>4、接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片<br>提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回<br>文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。<br>5、补充：Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分<br>片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增<br>加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，<br>但是性能会变差。*<br>15、在 Elasticsearch 中，是怎么根据一个词找到对应的倒排索<br>引的？<br>SEE：<br> Lucene 的索引文件格式(1)<br> Lucene 的索引文件格式(2)<br>16、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方<br>法？<br>1、64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。<br>少于 8 GB 会适得其反。<br>2、如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多<br>个内核提供的额外并发远胜过稍微快一点点的时钟频率。<br>3、如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查<br>询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。<br>4、即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群<br>跨越大的地理距离。<br>5、请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在<br>Elasticsearch 的几个地方，使用 Java 的本地序列化。<br>6、通过设置 gateway.recover_after_nodes、gateway.expected_nodes、<br>gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可<br>能会让数据恢复从数个小时缩短为几秒钟。<br>7、Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只<br>有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。<br>8、不要随意修改垃圾回收器（CMS）和各个线程池的大小。<br>9、把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过<br>ES_HEAP_SIZE 环境变量设置。<br>10、内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个<br>100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起<br>来。 不难看出 swapping 对于性能是多么可怕。<br>11、Lucene 使用了大量 的文件。同时，Elasticsearch 在节点和 HTTP 客户端<br>之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你<br>应该增加你的文件描述符，设置一个很大的值，如 64,000。<br>补充：索引阶段性能提升方法<br>1、使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。<br>2、存储：使用 SSD<br>3、段和合并：Elasticsearch 默认值是 20 MB&#x2F;s，对机械磁盘应该是个不错的设<br>置。如果你用的是 SSD，可以考虑提高到 100–200 MB&#x2F;s。如果你在做批量导入，<br>完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加<br>index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的<br>值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。<br>4、如果你的搜索结果不需要近实时的准确度，考虑把每个索引的<br>index.refresh_interval 改到 30s。<br>5、如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副<br>本。<br>17、对于 GC 方面，在使用 Elasticsearch 时要注意什么？<br>1、SEE：<br>2、倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment<br>memory 增长趋势。<br>3、各类缓存，field cache, filter cache, indexing cache, bulk queue 等等，要<br>设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓<br>存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache<br>等“自欺欺人”的方式来释放内存。<br>4、避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用<br>scan &amp; scroll api 来实现。<br>5、cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集<br>群通过 tribe node 连接。<br>6、想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做<br>持续的监控。<br>18、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？<br>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，<br>即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对<br>我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到<br>基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；<br>小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内<br>存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。<br>19、在并发情况下，Elasticsearch 如果保证读写一致？<br>1、可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用<br>层来处理具体的冲突；<br>2、另外对于写操作，一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum，即只<br>有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络<br>等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点<br>上重建。<br>3、对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副<br>本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜<br>索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。<br>20、如何监控 Elasticsearch 集群状态？<br>Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你<br>的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。<br>21、介绍下你们电商搜索的整体技术架构。<br>22、介绍一下你们的个性化搜索方案？<br>SEE 基于 word2vec 和 Elasticsearch 实现个性化搜索<br>23、是否了解字典树？<br>常用字典数据结构如下所示：<br>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以<br>达到提高效率的目的。它有 3 个基本性质：<br>1、根节点不包含字符，除根节点外每一个节点都只包含一个字符。<br>2、从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>3、每个节点的所有子节点包含的字符都不相同。<br>1、可以看到，trie 树每一层的节点数是 26^i 级别的。所以为了节省空间，我们<br>还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数×单<br>词长度。<br>2、实现：对每个结点开一个字母集大小的数组，每个结点挂一个链表，使用左儿<br>子右兄弟表示法记录这棵树；<br>3、对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太<br>大的空间，而且查询速度上可以保留哈希的复杂度 O(1)。<br>24、拼写纠错是如何实现的？<br>1、拼写纠错是基于编辑距离来实现；编辑距离是一种标准的方法，它用来表示经<br>过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数；<br>2、编辑距离的计算过程：比如要计算 batyu 和 beauty 的编辑距离，先创建一个<br>7×8 的表（batyu 长度为 5，coffee 长度为 6，各加 2），接着，在如下位置填入<br>黑色数字。其他格的计算过程是取以下三个值的最小值：<br>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字<br>+1。（对于 3,3 来说为 0）<br>左方数字+1（对于 3,3 格来说为 2）<br>上方数字+1（对于 3,3 格来说为 2）<br>最终取右下角的值即为编辑距离的值 3。<br>对于拼写纠错，我们考虑构造一个度量空间（Metric Space），该空间内任何关<br>系满足以下三条基本条件：<br>d(x,y) &#x3D; 0 – 假如 x 与 y 的距离为 0，则 x&#x3D;y<br>d(x,y) &#x3D; d(y,x) – x 到 y 的距离等同于 y 到 x 的距离<br>d(x,y) + d(y,z) &gt;&#x3D; d(x,z) – 三角不等式<br>1、根据三角不等式，则满足与 query 距离在 n 范围内的另一个字符转 B，其与 A<br>的距离最大为 d+n，最小为 d-n。<br>2、BK 树的构造就过程如下：每个节点有任意个子节点，每条边有个值表示编辑<br>距离。所有子节点到父节点的边上标注 n 表示编辑距离恰好为 n。比如，我们有棵<br>树父节点是”book”和两个子节点”cake”和”books”，”book”到”books”<br>的边标号 1，”book”到”cake”的边上标号 4。从字典里构造好树后，无论何<br>时你想插入新单词时，计算该单词与根节点的编辑距离，并且查找数值为<br>d(neweord, root)的边。递归得与各子节点进行比较，直到没有子节点，你就可<br>以创建新的子节点并将新单词保存在那。比如，插入”boo”到刚才上述例子的树<br>中，我们先检查根节点，查找 d(“book”, “boo”) &#x3D; 1 的边，然后检查标号为<br>1 的边的子节点，得到单词”books”。我们再计算距离 d(“books”, “boo”)&#x3D;2，<br>则将新单词插在”books”之后，边标号为 2。<br>3、查询相似词如下：计算单词与根节点的编辑距离 d，然后递归查找每个子节点<br>标号为 d-n 到 d+n（包含）的边。假如被检查的节点与搜索单词的距离 d 小于 n，<br>则返回该节点并继续查询。比如输入 cape 且最大容忍距离为 1，则先计算和根的<br>编辑距离 d(“book”, “cape”)&#x3D;4，然后接着找和根节点之间编辑距离为 3 到<br>5 的，这个就找到了 cake 这个节点，计算 d(“cake”, “cape”)&#x3D;1，满足条件<br>所以返回 cake，然后再找和 cake 节点编辑距离是 0 到 2 的，分别找到 cape 和<br>cart 节点，这样就得到 cape 这个满足条件的结果。</p><p>2、Memcached 服务分布式集群如何实现？<br>特殊说明：Memcached 集群和 web 服务集群是不一样的，所有 Memcached 的<br>数据总和才是数据库的数据。每台 Memcached 都是部分数据。<br>（一台 memcached 的数据，就是一部分 mysql 数据库的数据）<br>a、程序端实现<br>程序加载所有 mc 的 ip 列表，通过对 key 做 hash (一致性哈希算法)<br>例如：web1 (key)&#x3D;&#x3D;&#x3D;&gt;对应 A,B,C,D,E,F,G…..若干台服务器。（通过哈希算法实<br>现）<br>b、负载均衡器<br>通过对 key 做 hash (一致性哈希算法)<br>一致哈希算法的目的是不但保证每个对象只请求一个对应的服务器，而且当节点<br>宕机，缓存服务器的更新重新分配比例降到最低。<br>3、Memcached 服务特点及工作原理是什么？<br>a、完全基于内存缓存的<br>b、节点之间相互独立<br>c、C&#x2F;S 模式架构，C 语言编写，总共 2000 行代码。<br>d、异步Ｉ&#x2F;O 模型，使用 libevent 作为事件通知机制。<br>e、被缓存的数据以 key&#x2F;value 键值对形式存在的。<br>f、全部数据存放于内存中，无持久性存储的设计，重启服务器，内存里的数据会<br>丢失。<br>g、当内存中缓存的数据容量达到启动时设定的内存值时，就自动使用 LRU 算法<br>删除过期的缓存数据。<br>h、可以对存储的数据设置过期时间，这样过期后的数据自动被清除，服务本身不<br>会监控过期，而是在访问的时候查看 key 的时间戳,判断是否过期。<br>j、memcache 会对设定的内存进行分块，再把块分组，然后再提供服务。<br>4、简述 Memcached 内存管理机制原理？<br>早期的 Memcached 内存管理方式是通过 malloc 的分配的内存，使用完后通过<br>free 来回收内存，这种方式容易产生内存碎片，并降低操作系统对内存的管理效<br>率。加重操作系统内存管理器的负担，最坏的情况下，会导致操作系统比<br>memcached 进程本身还慢，为了解决这个问题，Slab Allocation 内存分配机制<br>就延生了。<br>现在 Memcached 利用 Slab Allocation 机制来分配和管理内存。<br>Slab<br>Allocation 机制原理是按照预先规定的大小，将分配给 memcached 的内存分割<br>成特定长度的内存块（chunk)，再把尺寸相同的内存块，分成组<br>（chunks slab class),这些内存块不会释放，可以重复利用。<br>而且，slab allocator 还有重复使用已分配的内存的目的。 也就是说，分配到的<br>内存不会释放，而是重复利用。<br>Slab Allocation 的主要术语<br>Page<br>分配给 Slab 的内存空间，默认是 1MB。分配给 Slab 之后根据 slab 的大小切分成<br>chunk。<br>Chunk<br>用于缓存记录的内存空间。<br>SlabClass<br>特定大小的 chunk 的组。<br>集群架构方面的问题</p><p>7、memcached 和 MySQL 的 query<br>cache 相比，有什么优缺点？<br>把 memcached 引入应用中，还是需要不少工作量的。MySQL 有个使用方便的<br>query cache，可以自动地缓存 SQL 查询的结果，被缓存的 SQL 查询可以被反复<br>地快速执行。Memcached 与之相比，怎么样呢？MySQL 的 query cache 是集中<br>式的，连接到该 query cache 的 MySQL 服务器都会受益。<br> 当您修改表时，MySQL 的 query cache 会立刻被刷新（flush）。存储<br>一个 memcached item 只需要很少的时间，但是当写操作很频繁时，MySQL<br>的 query cache 会经常让所有缓存数据都失效。<br> 在多核 CPU 上，MySQL 的 query cache 会遇到扩展问题（scalability<br>issues）。在多核 CPU 上，query cache 会增加一个全局锁（global lock）, 由<br>于需要刷新更多的缓存数据，速度会变得更慢。<br> 在 MySQL 的 query cache 中，我们是不能存储任意的数据的（只能是<br>SQL 查询结果）。而利用 memcached，我们可以搭建出各种高效的缓存。比<br>如，可以执行多个独立的查询，构建出一个用户对象（user object），然后将<br>用户对象缓存到 memcached 中。而 query cache 是 SQL 语句级别的，不可能<br>做到这一点。在小的网站中，query cache 会有所帮助，但随着网站规模的增加，<br>query cache 的弊将大于利。<br> query cache能够利用的内存容量受到MySQL服务器空闲内存空间的限<br>制。给数据库服务器增加更多的内存来缓存数据，固然是很好的。但是，有了<br>memcached，只要您有空闲的内存，都可以用来增加 memcached 集群的规<br>模，然后您就可以缓存更多的数据。<br>8、memcached 和服务器的 local cache（比如 PHP 的 APC、<br>mmap 文件等）相比，有什么优缺点？<br>首先，local cache 有许多与上面(query cache)相同的问题。local cache 能够利<br>用的内存容量受到（单台）服务器空闲内存空间的限制。不过，local<br>cache 有一点比 memcached 和 query cache 都要好，那就是它不但可以存储任<br>意的数据，而且没有网络存取的延迟。<br> local cache 的数据查询更快。考虑把 highly common 的数据放在 local<br>cache 中吧。如果每个页面都需要加载一些数量较少的数据，考虑把它们放在<br>local<br>cached 吧。<br> local cache 缺少集体失效（group<br>invalidation）的特性。在 memcached 集群中，删除或更新一个 key 会让所有<br>的观察者觉察到。但是在local cache中, 我们只能通知所有的服务器刷新cache<br>（很慢，不具扩展性），或者仅仅依赖缓存超时失效机制。<br> local cache 面临着严重的内存限制，这一点上面已经提到。<br>9、memcached 的 cache 机制是怎样的？<br>Memcached 主要的 cache 机制是 LRU（最近最少用）算法+超时失效。当您存<br>数据到 memcached 中，可以指定该数据在缓存中可以呆多久 Which is forever,<br>or some time in the future。如果 memcached 的内存不够用了，过期的 slabs<br>会优先被替换，接着就轮到最老的未被使用的 slabs。<br>10、memcached 如何实现冗余机制？<br>不实现！我们对这个问题感到很惊讶。Memcached 应该是应用的缓存层。它的设<br>计本身就不带有任何冗余机制。如果一个 memcached 节点失去了所有数据，您<br>应该可以从数据源（比如数据库）再次获取到数据。您应该特别注意，您的应用<br>应该可以容忍节点的失效。不要写一些糟糕的查询代码，寄希望于 memcached<br>来保证一切！如果您担心节点失效会大大加重数据库的负担，那么您可以采取一<br>些办法。比如您可以增加更多的节点（来减少丢失一个节点的影响），热备节点<br>（在其他节点 down 了的时候接管 IP），等等。<br>11、memcached 如何处理容错的？<br>不处理！ 在 memcached 节点失效的情况下，集群没有必要做任何容错处理。如<br>果发生了节点失效，应对的措施完全取决于用户。节点失效时，下面列出几种方<br>案供您选择：<br> 忽略它！ 在失效节点被恢复或替换之前，还有很多其他节点可以应对节<br>点失效带来的影响。<br> 把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下<br>（余数式哈希算法），客户端添加或移除节点，会导致所有的缓存数据不可用！<br>因为哈希参照的节点列表变化了，大部分 key 会因为哈希值的改变而被映射到<br>（与原来）不同的节点上。<br> 启动热备节点，接管失效节点所占用的 IP。这样可以防止哈希紊乱<br>（hashing chaos）。<br> 如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈<br>希算法（consistent hashing）。您可以百度一下一致性哈希算法。支持一致性<br>哈希的客户端已经很成熟，而且被广泛使用。去尝试一下吧！<br> 两次哈希（reshing）。当客户端存取数据时，如果发现一个节点 down<br>了，就再做一次哈希（哈希算法与前一次不同），重新选择另一个节点（需要注<br>意的时，客户端并没有把 down 的节点从节点列表中移除，下次还是有可能先<br>哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和<br>坏的节点上都可能存在脏数据（stale data）。<br>12、如何将 memcached 中 item 批量导入导出？<br>您不应该这样做！Memcached 是一个非阻塞的服务器。任何可能导致<br>memcached 暂停或瞬时拒绝服务的操作都应该值得深思熟虑。向 memcached<br>中批量导入数据往往不是您真正想要的！想象看，如果缓存数据在导出导入之间<br>发生了变化，您就需要处理脏数据了；<br>13、如果缓存数据在导出导入之间过期了，您又怎么处理这些<br>数据呢？<br>因此，批量导出导入数据并不像您想象中的那么有用。不过在一个场景倒是很有<br>用。如果您有大量的从不变化的数据，并且希望缓存很快热（warm）起来，批量<br>导入缓存数据是很有帮助的。虽然这个场景并不典型，但却经常发生，因此我们<br>会考虑在将来实现批量导出导入的功能。<br>如果一个 memcached 节点 down 了让您很痛苦，那么您还会陷入其他很多麻烦。<br>您的系统太脆弱了。您需要做一些优化工作。比如处理”惊群”问题（比如<br>memcached 节点都失效了，反复的查询让您的数据库不堪重负…这个问题在 FAQ<br>的其他提到过），或者优化不好的查询。记住，Memcached 并不是您逃避优化<br>查询的借口。<br>14、memcached 是如何做身份验证的？<br>没有身份认证机制！memcached 是运行在应用下层的软件（身份验证应该是应用<br>上层的职责）。memcached 的客户端和服务器端之所以是轻量级的，部分原因就<br>是完全没有实现身份验证机制。这样，memcached 可以很快地创建新连接，服务<br>器端也无需任何配置。<br>如果您希望限制访问，您可以使用防火墙，或者让 memcached 监听 unix domain<br>socket。<br>15、memcached 的多线程是什么？如何使用它们？<br>线程就是定律（threads rule）！在 Steven Grimm 和 Facebook 的努力下，<br>memcached 1.2 及更高版本拥有了多线程模式。多线程模式允许 memcached 能<br>够充分利用多个 CPU，并在 CPU 之间共享所有的缓存数据。memcached 使用一<br>种简单的锁机制来保证数据更新操作的互斥。相比在同一个物理机器上运行多个<br>memcached 实例，这种方式能够更有效地处理 multi gets。<br>如果您的系统负载并不重，也许您不需要启用多线程工作模式。如果您在运行一<br>个拥有大规模硬件的、庞大的网站，您将会看到多线程的好处。<br>简单地总结一下：命令解析（memcached 在这里花了大部分时间）可以运行在多<br>线程模式下。memcached 内部对数据的操作是基于很多全局锁的（因此这部分工<br>作不是多线程的）。未来对多线程模式的改进，将移除大量的全局锁，提高<br>memcached 在负载极高的场景下的性能。<br>16、memcached 能接受的 key 的最大长度是多少？<br>key 的最大长度是 250 个字符。需要注意的是，250 是 memcached 服务器端内<br>部的限制，如果您使用的客户端支持”key 的前缀”或类似特性，那么 key（前缀<br>+原始 key）的最大长度是可以超过 250 个字符的。我们推荐使用使用较短的 key，<br>因为可以节省内存和带宽。<br>memcached 对 item 的过期时间有什么限制？<br>过期时间最大可以达到 30 天。memcached 把传入的过期时间（时间段）解释成<br>时间点后，一旦到了这个时间点，memcached 就把 item 置为失效状态。这是一<br>个简单但 obscure 的机制。<br>17、memcached 最大能存储多大的单个 item？<br>1MB。如果你的数据大于 1MB，可以考虑在客户端压缩或拆分到多个 key 中。<br>为什么单个 item 的大小被限制在 1M byte 之内？<br>啊…这是一个大家经常问的问题！<br>简单的回答：因为内存分配器的算法就是这样的。<br>详细的回答：Memcached 的内存存储引擎（引擎将来可插拔…），使用 slabs 来<br>管理内存。内存被分成大小不等的 slabs chunks（先分成大小相等的 slabs，然后<br>每个 slab 被分成大小相等 chunks，不同 slab 的 chunk 大小是不相等的）。chunk<br>的大小依次从一个最小数开始，按某个因子增长，直到达到最大的可能值。<br>18、memcached 能够更有效地使用内存吗？<br>Memcache 客户端仅根据哈希算法来决定将某个 key 存储在哪个节点上，而不考<br>虑节点的内存大小。因此，您可以在不同的节点上使用大小不等的缓存。但是一<br>般都是这样做的：拥有较多内存的节点上可以运行多个 memcached 实例，每个<br>实例使用的内存跟其他节点上的实例相同。<br>19、什么是二进制协议，我该关注吗？<br>关于二进制最好的信息当然是二进制协议规范：<br>二进制协议尝试为端提供一个更有效的、可靠的协议，减少客户端&#x2F;服务器端因处<br>理协议而产生的 CPU 时间。<br>根据 Facebook 的测试，解析 ASCII 协议是 memcached 中消耗 CPU 时间最多的<br>环节。所以，我们为什么不改进 ASCII 协议呢？<br>20、memcached 的内存分配器是如何工作的？为什么不适用<br>malloc&#x2F;free！？为何要使用 slabs？<br>实际上，这是一个编译时选项。默认会使用内部的 slab 分配器。您确实确实应该<br>使用内建的 slab 分配器。最早的时候，memcached 只使用 malloc&#x2F;free 来管理<br>内存。然而，这种方式不能与 OS 的内存管理以前很好地工作。反复地 malloc&#x2F;free<br>造成了内存碎片，OS 最终花费大量的时间去查找连续的内存块来满足 malloc 的<br>请求，而不是运行 memcached 进程。如果您不同意，当然可以使用 malloc！只<br>是不要在邮件列表中抱怨啊<br>slab 分配器就是为了解决这个问题而生的。内存被分配并划分成 chunks，一直被<br>重复使用。因为内存被划分成大小不等的 slabs，如果 item 的大小与被选择存放<br>它的 slab 不是很合适的话，就会浪费一些内存。Steven Grimm 正在这方面已经<br>做出了有效的改进。<br>21、memcached 是原子的吗？<br>所有的被发送到 memcached 的单个命令是完全原子的。如果您针对同一份数据<br>同时发送了一个 set 命令和一个 get 命令，它们不会影响对方。它们将被串行化、<br>先后执行。即使在多线程模式，所有的命令都是原子的，除非程序有 bug:)<br>命令序列不是原子的。如果您通过 get 命令获取了一个 item，修改了它，然后想<br>把它 set 回 memcached，我们不保证这个 item 没有被其他进程（process，未<br>必是操作系统中的进程）操作过。在并发的情况下，您也可能覆写了一个被其他<br>进程 set 的 item。<br>memcached 1.2.5 以及更高版本，提供了 gets 和 cas 命令，它们可以解决上面<br>的问题。如果您使用 gets 命令查询某个 key 的 item，memcached 会给您返回<br>该 item 当前值的唯一标识。如果您覆写了这个 item 并想把它写回到 memcached<br>中，您可以通过 cas 命令把那个唯一标识一起发送给 memcached。如果该 item<br>存放在 memcached 中的唯一标识与您提供的一致，您的写操作将会成功。如果<br>另一个进程在这期间也修改了这个 item，那么该 item 存放在 memcached 中的<br>唯一标识将会改变，您的写操作就会失败<br>22、如何实现集群中的 session 共享存储？<br>Session 是运行在一台服务器上的，所有的访问都会到达我们的唯一服务器上，这<br>样我们可以根据客户端传来的 sessionID，来获取 session，或在对应 Session 不<br>存在的情况下（session 生命周期到了&#x2F;用户第一次登录），创建一个新的 Session；<br>但是，如果我们在集群环境下，假设我们有两台服务器 A，B，用户的请求会由<br>Nginx 服务器进行转发（别的方案也是同理），用户登录时，Nginx 将请求转发<br>至服务器 A 上，A 创建了新的 session，并将 SessionID 返回给客户端，用户在浏<br>览其他页面时，客户端验证登录状态，Nginx 将请求转发至服务器 B，由于 B 上<br>并没有对应客户端发来 sessionId 的 session，所以会重新创建一个新的 session，<br>并且再将这个新的 sessionID 返回给客户端，这样，我们可以想象一下，用户每<br>一次操作都有 1&#x2F;2 的概率进行再次的登录，这样不仅对用户体验特别差，还会让<br>服务器上的 session 激增，加大服务器的运行压力。<br>为了解决集群环境下的 seesion 共享问题，共有 4 种解决方案：<br>1.粘性 session<br>粘性 session 是指 Ngnix 每次都将同一用户的所有请求转发至同一台服务器上，<br>即将用户与服务器绑定。<br>2.服务器 session 复制<br>即每次 session 发生变化时，创建或者修改，就广播给所有集群中的服务器，使<br>所有的服务器上的 session 相同。<br>3.session 共享<br>缓存 session，使用 redis， memcached。<br>4.session 持久化<br>将 session 存储至数据库中，像操作数据一样才做 session。<br>23、memcached 与 redis 的区别？<br>1、Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash<br>等数据结构的存储。而 memcache 只支持简单数据类型，需要客户端自己处理复<br>杂对象<br>2、Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可<br>以再次加载进行使用（PS：持久化在 rdb、aof）。<br>3、由于 Memcache 没有持久化机制，因此宕机所有缓存数据失效。Redis 配置<br>为持久化，宕机重启后，将自动加载宕机时刻的数据到缓存系统中。具有更好的<br>灾备机制。<br>4、Memcache 可以使用 Magent 在客户端进行一致性 hash 做分布式。Redis 支<br>持在服务器端做分布式（PS:Twemproxy&#x2F;Codis&#x2F;Redis-cluster 多种分布式实现方<br>式）<br>5、Memcached 的简单限制就是键（key）和 Value 的限制。最大键长为 250 个<br>字符。可以接受的储存数据不能超过 1MB（可修改配置文件变大），因为这是典<br>型 slab 的最大值，不适合虚拟机使用。而 Redis 的 Key 长度支持到 512k。<br>6、Redis 使用的是单线程模型，保证了数据按顺序提交。Memcache 需要使用<br>cas 保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属<br>于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操<br>作，不一致就放弃任何操作<br>cpu 利用。由于 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每<br>一个核上 Redis 在存储小数据时比 Memcached 性能更 高。而在 100k 以上的数<br>据中，Memcached 性能要高于 Redis 。<br>7、memcache 内存管理：使用 Slab Allocation。原理相当简单，预先分配一系<br>列大小固定的组，然后根据数据大小选择最合适的块存储。避免了内存碎片。（缺<br>点：不能变长，浪费了一定空间）memcached 默认情况下下一个 slab 的最大值<br>为前一个的 1.25 倍。<br>8、redis 内存管理： Redis 通过定义一个数组来记录所有的内存分配情况， Redis<br>采用的是包装的 malloc&#x2F;free，相较于 Memcached 的内存 管理方法来说，要简<br>单很多。由于 malloc 首先以链表的方式搜索已管理的内存中可用的空间分配，导<br>致内存碎片比较多<br>7、redis一个字符串类型的值能存储最大容量是多少？<br>答：512M<br>9、Redis 常见性能问题和解决方案：<br>1、Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave<br>函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性<br>暂停服务<br>2、如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一<br>3、为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网<br>4、尽量避免在压力很大的主库上增加从<br>5、主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1<br>&lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现 Slave 对 Master<br>的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。</p><p>12、为什么 edis 需要把所有数据放到内存中？<br>答：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数<br>据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，<br>磁盘 I&#x2F;O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越<br>来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不<br>能继续插入新值。<br>14、Pipeline 有什么好处，为什么要用 pipeline？<br>答：可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有<br>因果相关性。使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS<br>峰值的一个重要因素是 pipeline 批次指令的数目。<br>19、Redis 如何设置密码及验证密码？<br>设置密码：config set requirepass 123456<br>授权密码：auth 123456<br>20、说说 Redis 哈希槽的概念？<br>答：Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有<br>16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，<br>集群的每个节点负责一部分 hash 槽。<br>21、Redis 集群的主从复制模型是怎样的？<br>答：为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所<br>以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.<br>22、Redis 集群会有写操作丢失吗？为什么？<br>答：Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可<br>能会丢失写操作。<br>23、Redis 集群之间是如何复制的？<br>答：异步复制<br>24、Redis 集群最大节点个数是多少？<br>答：16384 个。<br>25、Redis 集群如何选择数据库？<br>答：Redis 集群目前无法做数据库选择，默认在 0 数据库。<br>26、怎么测试 Redis 的连通性？<br>答：使用 ping 命令。<br>27、怎么理解 Redis 事务？<br>答：<br>1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。<br>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<br>28、Redis 事务相关的命令有哪几个？<br>答：MULTI、EXEC、DISCARD、WATCH<br>29、Redis key 的过期时间和永久有效分别怎么设置？<br>答：EXPIRE 和 PERSIST 命令。<br>30、Redis 如何做内存优化？<br>答：尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用<br>的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比<br>如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码<br>设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面.<br>31、Redis 回收进程如何工作的？<br>答：一个客户端运行了新的命令，添加了新的数据。Redi 检查内存使用情况，如<br>果大于 maxmemory 的限制, 则根据设定好的策略进行回收。一个新的命令被执<br>行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地<br>回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合<br>的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。<br>32、都有哪些办法可以降低 Redis 的内存使用情况呢？<br>答：如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set<br>等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放<br>到一起。<br>33、Redis 的内存用完了会发生什么？<br>答：如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正<br>常返回。）或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存<br>上限时会冲刷掉旧的内容。<br>34、一个 Redis 实例最多能存放多少的 keys？List、Set、<br>Sorted Set 他们最多能存放多少元素？<br>答：理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实<br>例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list、set、<br>和 sorted set 都可以放 232 个元素。换句话说，Redis 的存储极限是系统中的可<br>用内存值。<br>35、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如<br>何保证 redis 中的数据都是热点数据？<br>答：Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。<br>36、Redis 最适合的场景？<br>1、会话缓存（Session Cache）<br>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会<br>话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不<br>是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不<br>高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容<br>易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台<br>Magento 也提供 Redis 的插件。<br>2、全页缓存（FPC）<br>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，<br>即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的<br>下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento<br>提供一个插件来使用 Redis 作为全页缓存后端。 此外，对 WordPress 的用户来<br>说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加<br>载你曾浏览过的页面。<br>3、队列<br>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis<br>能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本<br>地程序语言（如 Python）对 list 的 push&#x2F;pop 操作。 如果你快速的在 Google<br>中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就<br>是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一<br>个后台就是使用 Redis 作为 broker，你可以从这里去查看。<br>4，排行榜&#x2F;计数器<br>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序<br>集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是<br>正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10<br>个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，<br>这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，<br>你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就<br>是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，<br>你可以在这里看到。<br>5、发布&#x2F;订阅<br>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景<br>确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚<br>本触发器，甚至用 Redis 的发布&#x2F;订阅功能来建立聊天系统！<br>37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以<br>某个固定的已知的前缀开头的，如果将它们全部找出来？<br>答：使用 keys 指令可以扫出指定模式的 key 列表。<br>对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会<br>有什么问题？<br>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线<br>程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时<br>候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但<br>是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间<br>会比直接用 keys 指令长。<br>38、如果有大量的 key 需要设置同一时间过期，一般需要注意<br>什么？<br>答：如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能<br>会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一<br>些。<br>39、使用过 Redis 做异步队列么，你是怎么用的？<br>答：一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有<br>消息的时候，要适当 sleep 一会再重试。<br>如果对方追问可不可以不用 sleep 呢？<br>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对<br>方追问能不能生产一次消费多次呢？使用 pub&#x2F;sub 主题订阅者模式，可以实现<br>1:N 的消息队列。<br>如果对方追问 pub&#x2F;sub 有什么缺点？<br>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ<br>等。<br>如果对方追问 redis 如何实现延时队列？<br>我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这<br>么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为<br>score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令<br>获取 N 秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇<br>指。但是他不知道的是此刻你却竖起了中指，在椅子背后。<br>40、使用过 Redis 分布式锁么，它是什么回事？<br>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了<br>释放。<br>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire<br>之前进程意外 crash 或者要重启维护了，那会怎么样？<br>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你<br>需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，<br>然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和<br>expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子<br>还不错。<br>11、列对比运算符是什么？<br>在 SELECT 语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，<br>OR 或 LIKE 运算符。</p><p>17、可以使用多少列创建索引？<br>任何标准表最多可以创建 16 个索引列。<br>18、NOW（）和 CURRENT_DATE（）有什么区别？<br>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。<br>CURRENT_DATE（）仅显示当前年份，月份和日期。<br>20、什么是通用 SQL 函数？<br>1、CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个<br>或多个字段合并为一个字段。<br>2、FORMAT(X, D)- 格式化数字 X 到 D 有效数字。<br>3、CURRDATE(), CURRTIME()- 返回当前日期或时间。<br>4、NOW（） – 将当前日期和时间作为一个值返回。<br>5、MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期<br>值中提取给定数据。<br>6、HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。<br>7、DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄<br>8、SUBTIMES（A，B） – 确定两次之间的差异。<br>9、FROMDAYS（INT） – 将整数天数转换为日期值。</p><p>23、MySQL 有关权限的表都有哪几个？<br>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 MySQL 数<br>据库里，由 MySQL_install_db 脚本初始化。这些权限表分别 user，db，table_priv，<br>columns_priv 和 host。<br>24、列的字符串类型可以是什么？<br>字符串类型是：<br>1、SET<br>2、BLOB<br>3、ENUM<br>4、CHAR<br>5、TEXT<br>25、MySQL 数据库作发布系统的存储，一天五万条以上的增量，<br>预计运维三年,怎么优化？<br>1、设计良好的数据库结构，允许部分数据冗余，尽量避免 join 查询，提高效率。<br>2、选择合适的表字段数据类型和存储引擎，适当的添加索引。<br>3、MySQL 库主从读写分离。<br>4、找规律分表，减少单表中的数据量提高查询速度。<br>5、添加缓存机制，比如 memcached，apc 等。<br>6、不经常改动的页面，生成静态页面。<br>7、书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1,<br>field_2, field_3 FROM TABLE.<br>26、锁的优化策略<br>1、读写分离<br>2、分段加锁<br>3、减少锁持有的时间<br>4.多个线程尽量以相同的顺序去获取资源<br>不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效<br>率不如一次加一把大锁。<br>27、索引的底层实现原理和优化<br>B+树，经过优化的 B+树<br>主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此 InnoDB 建<br>议为大部分表使用默认自增的主键作为主索引。<br>28、什么情况下设置了索引但无法使用<br>1、以“%”开头的 LIKE 语句，模糊匹配<br>2、OR 语句前后没有同时使用索引<br>3、数据类型出现隐式转化（如 varchar 不加单引号的话可能会自动转换为 int 型）<br>29、实践中如何优化 MySQL<br>最好是按照以下顺序优化：<br>1、SQL 语句及索引的优化<br>2、数据库表结构的优化<br>3、系统配置的优化<br>4、硬件的优化<br>详细可以查看 阿里 P8 架构师谈：MySQL 慢查询优化、索引优化、以及表等优化<br>总结<br>30、优化数据库的方法<br>1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL，<br>例如’省份’、’性别’最好适用 ENUM<br>2、使用连接(JOIN)来代替子查询<br>3、适用联合(UNION)来代替手动创建的临时表<br>4、事务处理<br>5、锁定表、优化事务处理<br>6、适用外键，优化锁定表<br>7、建立索引<br>8、优化查询语句<br>31、简单描述 MySQL 中，索引，主键，唯一索引，联合索引<br>的区别，对数据库的性能有什么影响（从读写两方面）<br>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们<br>包含着对数据表里所有记录的引用指针。<br>普通索引(由关键字 KEY 或 INDEX 定义的索引)的唯一任务是加快对数据的访问速<br>度。<br>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼<br>此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它<br>定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。<br>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯<br>一标识一条记录，使用关键字 PRIMARY KEY 来创建。<br>索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引，这就是联合索<br>引。<br>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，<br>因为在执行这些写操作时，还要操作索引文件。</p><p>33、SQL 注入漏洞产生的原因？如何防止？<br>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进<br>行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。<br>防止 SQL 注入的方式：<br>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置<br>执行 sql 语句时使用 addslashes 进行 sql 语句转换<br>Sql 语句书写尽量不要省略双引号和单引号。<br>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。<br>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不<br>易被猜到的。<br>34、为表中得字段选择合适得数据类型<br>字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text<br>优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得<br>数据类型，应该优先选择占用空间小的数据类型<br>35、存储时期<br>Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，<br>占用 8 个字节得存储空间，datatime 类型与时区无关<br>Timestamp:以时间戳格式存储，占用 4 个字节，范围小 1970-1-1 到 2038-1-19，<br>显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改<br>timestamp 列得值<br>Date:（生日）占用得字节数比使用字符串.datatime.int 储存要少，使用 date 只<br>需要 3 个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算<br>Time:存储时间部分得数据<br>注意:不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小，<br>在进行查找过滤可以利用日期得函数）<br>使用 int 存储日期时间不如使用 timestamp 类型<br>36、对于关系型数据库而言，索引是相当重要的概念，请回答<br>有关索引的几个问题：<br>1、索引的目的是什么？<br>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间<br>2、索引对数据库系统的负面影响是什么？<br>负面影响：<br>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需<br>要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；<br>当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速<br>度。<br>3、为数据表建立索引的原则有哪些？<br>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引<br>4、什么情况下不宜建立索引？<br>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等<br>37、解释 MySQL 外连接、内连接与自连接的区别<br>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一<br>个表的所有记录和另一个表中的所有记录一一匹配。<br>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合<br>条件的记录不会出现在结果集中，即内连接只连接匹配的行。<br>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个<br>表中<br>的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。<br>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，<br>对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以<br>NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现<br>在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。<br>38、Myql 中的事务回滚机制概述<br>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个<br>不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤<br>销。<br>要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修<br>改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依<br>旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个<br>事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和<br>第二个表都要回到未修改的状态，这就是所谓的事务回滚<br>39、SQL 语言包括哪几部分？每部分都有哪些操作关键字？<br>SQL 语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）<br>四个部分。<br>数据定义：Create Table,Alter Table,Drop Table, Craete&#x2F;Drop Index 等<br>数据操纵：Select ,insert,update,delete,<br>数据控制：grant,revoke<br>数据查询：select<br>40、完整性约束包括哪些？<br>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。<br>分为以下四类：<br>1、实体完整性：规定表的每一行在表中是惟一的实体。<br>2、域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括<br>取值范围、精度等规定。<br>3、参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间<br>的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。<br>4、用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需<br>要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束<br>条件，它反映某一具体应用必须满足的语义要求。<br>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、<br>foreign key、check、UNIQUE) 。<br>41、什么是锁？<br>答：数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数<br>据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可<br>能会读取和存储不正确的数据，破坏数据库的一致性。<br>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进<br>行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定<br>的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。<br>基本锁类型：锁包括行级锁和表级锁<br>42、什么叫视图？游标是什么？<br>答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，<br>查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影<br>响基本表。它使得我们获取数据更容易，相比多表查询。<br>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元<br>中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。<br>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。<br>43、什么是存储过程？用什么来调用？<br>答：存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需<br>创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，<br>使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。<br>44、如何通俗地理解三个范式？<br>答：第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>第二范式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，<br>它要求字段没有冗余。。<br>范式化设计优缺点:<br>优点:<br>可以尽量得减少数据冗余，使得更新快，体积小<br>缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引<br>优化<br>反范式化:<br>优点:可以减少表得关联，可以更好得进行索引优化<br>缺点:数据冗余以及数据异常，数据得修改需要更多的成本<br>45、什么是基本表？什么是视图？<br>答：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从<br>一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表<br>46、试述视图的优点？<br>答：(1) 视图能够简化用户的操作 (2) 视图使用户能以多种角度看待同一数据；<br>(3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供<br>安全保护。<br>47、 NULL 是什么意思<br>答：NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这<br>个值的任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比<br>较，并在逻辑上希望获得一个答案。<br>使用 IS NULL 来进行 NULL 判断<br>48、主键、外键和索引的区别？<br>主键、外键和索引的区别<br>定义：<br>主键–唯一标识一条记录，不能有重复的，不允许为空<br>外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值<br>索引–该字段没有重复值，但可以有一个空值<br>作用：<br>主键–用来保证数据完整性<br>外键–用来和其他表建立联系用的<br>索引–是提高查询排序的速度<br>个数：<br>主键–主键只能有一个<br>外键–一个表可以有多个外键<br>索引–一个表可以有多个唯一索引<br>49、你可以用什么来确保表格里的字段只接受特定范围里的值?<br>答：Check 限制，它在数据库表格里被定义，用来限制输入该列的值。<br>触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求<br>触发器在表格里被定义，这可能会在某些情况下影响到性能。<br>50、说说对 SQL 语句优化有哪些方法？（选择几条）<br>1、Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可<br>以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。<br>2、用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。<br>3、 避免在索引列上使用计算<br>4、避免在索引列上使用 IS NULL 和 IS NOT NULL<br>5、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉<br>及的列上建立索引。<br>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃<br>使用索引而进行全表扫描<br>7、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用<br>索引而进行全表扫描<br>Java 并发编程（一）<br>1、在 java 中守护线程和本地线程区别？<br>java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。<br>任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(bool<br>on)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()<br>必须在 Thread.start()之前调用，否则运行时会抛出异常。<br>两者的区别：<br>唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果<br>全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可<br>以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的<br>线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产<br>生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线<br>程时，Java 虚拟机会自动离开。<br>扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护<br>进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break<br>的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。<br>2、线程与进程的区别？<br>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。<br>一个程序至少有一个进程,一个进程至少有一个线程。<br>3、什么是多线程中的上下文切换？<br>多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，<br>为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU<br>发生的切换数据等就是上下文切换。<br>4、死锁与活锁的区别，死锁与饥饿的区别？<br>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成<br>的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br>产生死锁的必要条件：<br>1、互斥条件：所谓互斥就是进程在某一时间内独占资源。<br>2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3、不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。<br>4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，<br>失败，尝试，失败。<br>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而<br>处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。<br>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执<br>行的状态。<br>Java 中导致饥饿的原因：<br>1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。<br>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前<br>持续地对该同步块进行访问。<br>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方<br>法)，因为其他线程总是被持续地获得唤醒。<br>5、Java 中用到的线程调度算法是什么？<br>采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优<br>先级上，如非特别需要，尽量不要用，防止线程饥饿。<br>6、什么是线程组，为什么在 Java 中不推荐使用？<br>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，<br>也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。<br>为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使<br>用，推荐使用线程池。<br>8、在 Java 中 Executor 和 Executors 的区别？<br>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务<br>的需求。<br>Executor 接口对象能执行我们的线程任务。<br>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我<br>们能获得任务执行的状态并且可以获取任务的返回值。<br>使用 ThreadPoolExecutor 可以创建自定义线程池。<br>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的<br>完成，并可以使用 get()方法获取计算的结果。<br>9、如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时<br>间最长？<br>参考：<br><a target="_blank" rel="noopener" href="http://daiguahub.com/2016/07/31/%E4%BD%BF%E7%94%A8">http://daiguahub.com/2016/07/31/使用</a> jstack 找出消耗 CPU 最多的线程代码<br>&#x2F;<br>10、什么是原子操作？在 Java Concurrency API 中有哪些原<br>子类(atomic classes)？<br>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。<br>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。<br>在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——<br>Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持 CAS<br>的原子操作。<br>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境<br>下避免数据不一致必须的手段。<br>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程<br>有可能会读到之前的值，这就会引发错误。<br>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同<br>步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和<br>long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需<br>要使用同步。<br>java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程<br>环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当<br>某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像<br>自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个<br>线程进入，这只是一种逻辑上的理解。<br>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference<br>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray<br>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，<br>AtomicReferenceFieldUpdater<br>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean<br>来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累<br>加来反映中间有没有变过）<br>11、Java Concurrency API 中的 Lock 接口(Lock interface)<br>是什么？对比同步它有什么优势？<br>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。<br>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的<br>条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的<br>(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多<br>条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平<br>锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非<br>公平锁是高效的选择。<br>12、什么是 Executors 框架？<br>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框<br>架。<br>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的<br>解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用<br>Executors 框架可以非常方便的创建一个线程池。<br>13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用<br>阻塞队列来实现生产者-消费者模型？<br>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<br>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当<br>队列满时，存储元素的线程会等待队列可用。<br>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消<br>费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者<br>也只从容器里拿元素。<br>JDK7 提供了 7 个阻塞队列。分别是：<br>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。<br>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作<br>和线程同步可以实现生产者，消费者模式，主要的技术就是用好，<br>wait ,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻<br>塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面<br>也有保障。<br>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是<br>作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向<br>BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图<br>从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这<br>个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，<br>它可以很好的控制线程之间的通信。<br>阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线<br>程不断将数据放入队列，然后解析线程不断从队列取数据解析。<br>14、什么是 Callable 和 Future?<br>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返<br>回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执<br>行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到<br>异步执行任务的返回值。<br>可以认为是带有回调的 Runnable。<br>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable<br>用于产生结果，Future 用于获取结果。<br>15、什么是 FutureTask?使用 ExecutorService 启动任务。<br>在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消<br>运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才<br>能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用<br>了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable<br>接口所以它可以提交给 Executor 来执行。<br>16、什么是并发容器的实现？<br>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有<br>多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，<br>以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。<br>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容<br>器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上<br>关键字 synchronized。<br>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，<br>例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段<br>锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作<br>的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程<br>并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。<br>17、多线程同步和互斥有几种实现方法，都是什么？<br>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程<br>的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。<br>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若<br>干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它<br>要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成<br>是一种特殊的线程同步。<br>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式<br>就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，<br>而用户模式就是不需要切换到内核态，只在用户态完成操作。<br>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模<br>式下的方法有：事件，信号量，互斥量。<br>18、什么是竞争条件？你怎样发现和解决竞争？<br>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的<br>顺序时，则我们认为这发生了竞争条件（race condition）。<br>19、你将如何使用 thread dump？你将如何分析 Thread<br>dump？<br>新建状态（New）<br>用 new 语句创建的线程处于新建状态，此时它和其他 Java 对象一样，仅仅在堆区<br>中被分配了内存。<br>就绪状态（Runnable）<br>当一个线程对象创建后，其他线程调用它的 start()方法，该线程就进入就绪状态，<br>Java 虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运<br>行池中，等待获得 CPU 的使用权。<br>运行状态（Running）<br>处于这个状态的线程占用 CPU，执行程序代码。只有处于就绪状态的线程才有机<br>会转到运行状态。<br>阻塞状态（Blocked）<br>阻塞状态是指线程因为某些原因放弃 CPU，暂时停止运行。当线程处于阻塞状态<br>时，Java 虚拟机不会给线程分配 CPU。直到线程重新进入就绪状态，它才有机会<br>转到运行状态。<br>阻塞状态可分为以下 3 种：<br>位于对象等待池中的阻塞状态（Blocked in object’s wait pool）：<br>当线程处于运行状态时，如果执行了某个对象的 wait()方法，Java 虚拟机就会把<br>线程放到这个对象的等待池中，这涉及到“线程通信”的内容。<br>位于对象锁池中的阻塞状态（Blocked in object’s lock pool）：<br>当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已<br>经被其他线程占用，Java 虚拟机就会把这个线程放到这个对象的锁池中，这涉及<br>到“线程同步”的内容。<br>其他阻塞状态（Otherwise Blocked）：<br>当前线程执行了 sleep()方法，或者调用了其他线程的 join()方法，或者发出了 I&#x2F;O<br>请求时，就会进入这个状态。<br>死亡状态（Dead）<br>当线程退出 run()方法时，就进入死亡状态，该线程结束生命周期。<br>我们运行之前的那个死锁代码 SimpleDeadLock.java，然后尝试输出信息(<br>&#x2F;* 时间，jvm 信息 <em>&#x2F;<br>2017-11-01 17:36:28<br>Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed<br>mode):<br>&#x2F;</em> 线程名称：DestroyJavaVM<br>编号：#13<br>优先级：5<br>系统优先级：0<br>jvm 内部线程 id：0x0000000001c88800<br>对应系统线程 id（NativeThread ID）：0x1c18<br>线程状态： waiting on condition [0x0000000000000000] （等待某个条件）<br>线程详细状态：java.lang.Thread.State: RUNNABLE 及之后所有*&#x2F;<br>“DestroyJavaVM” #13 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x0000000001c88800<br>nid&#x3D;0x1c18 waiting on condition [0x0000000000000000]<br>java.lang.Thread.State: RUNNABLE<br>“Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x0000000018d49000<br>nid&#x3D;0x17b8 waiting for monitor entry [0x0000000019d7f000]<br>&#x2F;* 线程状态：阻塞（在对象同步上）<br>代码位置：at<br>com.leo.interview.SimpleDeadLock&#96;$B.run(SimpleDeadLock.java:56)<br>等待锁：0x00000000d629b4d8<br>已经获得锁：0x00000000d629b4e8*&#x2F;</p><p>25、Java 中用到的线程调度算法是什么？<br>计算机通常只有一个 CPU,在任意时刻只能执行一条机器指令,每个线程只有获得<br>CPU 的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线<br>程轮流获得 CPU 的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状<br>态的线程在等待 CPU,JAVA 虚拟机的一项任务就是负责线程的调度,线程调度是指<br>按照特定机制为多个线程分配 CPU 的使用权.<br>有两种调度模型：分时调度模型和抢占式调度模型。<br>分时调度模型是指让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占<br>用的 CPU 的时间片这个也比较好理解。<br>java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用<br>CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用<br>CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。<br>26、什么是线程组，为什么在 Java 中不推荐使用？<br>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程<br>的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。<br>27、为什么使用 Executor 框架比使用应用创建和管理线程好？<br>为什么要使用 Executor 线程池框架<br>1、每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗<br>时、耗资源的。<br>2、调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的<br>创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程<br>之间的频繁交替也会消耗很多系统资源。<br>3、直接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、<br>定时定期执行、线程中断等都不便实现。<br>使用 Executor 线程池框架的优点<br>1、能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开<br>销。<br>2、可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。<br>3、框架中已经有定时、定期、单线程、并发数控制等功能。<br>综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。<br>29、如何停止一个正在运行的线程？<br>使用共享变量的方式<br>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的<br>线程用来作为是否中断的信号，通知中断线程的执行。<br>使用 interrupt 方法终止线程<br>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种<br>情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用<br>Thread.join()方法，或者 Thread.sleep()方法，在网络中调用<br>ServerSocket.accept()方法，或者调用了 DatagramSocket.receive()方法时，都<br>有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程<br>的共享变量设置为 true，但该线程此时根本无法检查循环标志，当然也就无法立<br>即中断。这里我们给出的建议是，不要使用 stop()方法，而是使用 Thread 提供的<br>interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一<br>个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代<br>码。</p><p>36、SynchronizedMap 和 ConcurrentHashMap 有什么区<br>别？<br>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来<br>访为 map。<br>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。<br>ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将<br>hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。<br>这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提<br>升是显而易见的。<br>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当<br>iterator 被创建后集合再发生改变就不再是抛出<br>ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而<br>不影响原有的数据 ，iterator 完成后再将头指针替换为新的数据 ，这样 iterator<br>线程可以使用原来老的数据，而写线程也可以并发的完成改变。<br>37、CopyOnWriteArrayList 可以用于什么应用场景？<br>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这<br>个列表时，不会抛出 ConcurrentModificationException。在<br>CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保<br>留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。<br>1、由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的<br>情况下，可能导致 young gc 或者 full gc；<br>2、不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set<br>操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致<br>性,但是还是没法满足实时性要求；<br>CopyOnWriteArrayList 透露的思想<br>1、读写分离，读和写分开<br>2、最终一致性<br>3、使用另外开辟空间的思路，来解决并发冲突<br>38、什么叫线程安全？servlet 是线程安全吗?<br>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够<br>正确地处理多个线程之间的共享变量，使程序功能正确完成。<br>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个<br>方法，是不能保证共享变量的线程安全性的。<br>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一<br>个新的 action 分配给这个请求，请求完成后销毁。<br>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。<br>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安<br>全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多<br>线程的问题。<br>39、volatile 有什么用？能否用一句话说明下 volatile 的应用<br>场景？<br>volatile 保证内存可见性和禁止指令重排。<br>volatile 用于多线程环境下的单次操作(单次读或者单次写)。<br>40、为什么代码会重排序？<br>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是<br>不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：<br>在单线程环境下不能改变程序运行的结果；<br>存在数据依赖关系的不允许重排序<br>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执<br>行语义。</p><p>48、Java 中 interrupted 和 isInterrupted 方法的区别？<br>interrupt<br>interrupt 方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监<br>视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出<br>interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状<br>态被置为“中断状态”，就会抛出中断异常。<br>interrupted<br>查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调<br>用 interrupted 则返回 true，第二次和后面的就返回 false 了。<br>isInterrupted<br>仅仅是查询当前线程的中断状态<br>49、为什么 wait 和 notify 方法要在同步块中调用？<br>Java API 强制要求这样做，如果你不这么做，你的代码会抛出<br>IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify<br>之间产生竞态条件。<br>50、为什么你应该在循环中检查等待条件?<br>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条<br>件，程序就会在没有满足结束条件的情况下退出。<br>51、Java 中的同步集合与并发集合有什么区别？<br>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发<br>集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发<br>的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像<br>ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高<br>了可扩展性。</p><p>57、Java 中 ConcurrentHashMap 的并发度是什么？<br>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安<br>全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一<br>个可选参数，默认值为 16，这样在多线程情况下就能避免争用。<br>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实<br>现,利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看<br>源码吧。</p><p>61、Java 中的 ReadWriteLock 是什么？<br>读写锁是用来提升并发程序性能的锁分离技术的成果。<br>62、volatile 变量和 atomic 变量有什么不同？<br>Volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不<br>能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子<br>性的。<br>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如<br>getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型<br>和引用变量也可以进行相似操作。</p><p>64、如何让正在运行的线程暂停一段时间？<br>我们可以使用 Thread 类的 Sleep()方法让线程暂停一段时间。需要注意的是，这<br>并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，<br>并且根据线程调度，它将得到执行。<br>65、你对线程优先级的理解是什么？<br>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，<br>但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我<br>们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线<br>程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最<br>高优先级。<br>java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级<br>有关，如非特别需要，一般无需设置线程优先级。<br>66、什么是线程调度器(Thread Scheduler)和时间分片(Time<br>Slicing )？<br>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。<br>一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。<br>同上一个问题，线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是<br>更好的选择（也就是说不要让你的程序依赖于线程的优先级）。<br>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU<br>时间可以基于线程优先级或者线程等待的时间。<br>67、你如何确保 main()方法所在的线程是 Java 程序最后结束<br>的线程？<br>我们可以使用 Thread 类的 join()方法来确保所有程序创建的线程在 main()方法退<br>出前结束。<br>71、为什么 Thread 类的 sleep()和 yield ()方法是静态的？<br>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他<br>处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静<br>态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在<br>其他非运行线程调用这些方法。<br>72、如何确保线程安全？<br>在 Java 中可以有很多方法来保证线程安全——同步，使用原子类(atomic<br>concurrent classes)，实现并发锁，使用 volatile 关键字，使用不变类和线程安<br>全类。<br>73、同步方法和同步块，哪个是更好的选择？<br>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对<br>象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通<br>常会导致他们停止执行并需要等待获得这个对象上的锁。<br>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样<br>从侧面来说也可以避免死锁。<br>74、如何创建守护线程？<br>使用 Thread 类的 setDaemon(true)方法可以将线程设置为守护线程，需要注意<br>的是，需要在调用 start()方法前调用这个方法，否则会抛出<br>IllegalThreadStateException 异常。<br>75、什么是 Java Timer 类？如何创建一个有特定时间间隔的<br>任务？<br>java.util.Timer 是一个工具类，可以用于安排一个线程在未来的某个特定时间执<br>行。Timer 类可以用安排一次性任务或者周期任务。<br>java.util.TimerTask 是一个实现了 Runnable 接口的抽象类，我们需要去继承这<br>个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。<br>Java 并发编程（二）<br>1、并发编程三要素？<br>1、原子性<br>原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操<br>作打断，要么就全部都不执行。<br>2、可见性<br>可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他<br>线程可以立即看到修改的结果。<br>3、有序性<br>有序性，即程序的执行顺序按照代码的先后顺序来执行。<br>2、实现可见性的方法有哪些？<br>synchronized 或者 Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放<br>之前把最新的值刷新到主内存，实现可见性。<br>17、什么是 Future？<br>在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不<br>管是继承 thread 类还是实现 runnable 接口，都无法保证获取到之前的执行结果。<br>通过实现 Callback 接口，并用 Future 可以来接收多线程的执行结果。<br>Future 表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加<br>Callback 以便在任务执行成功或失败后作出相应的操作。<br>18、什么是 AQS<br>AQS 是 AbustactQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步<br>工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管<br>理这个同步状态。<br>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广<br>泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如<br>ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于<br>AQS 的。<br>19、AQS 支持两种同步方式：<br>1、独占式<br>2、共享式<br>这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如<br>Semaphore，CountDownLatch，组合式的如 ReentrantReadWriteLock。总之，<br>AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。<br>20、ReadWriteLock 是什么<br>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局<br>限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在<br>读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，<br>读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。<br>因为这个，才诞生了读写锁 ReadWriteLock。ReadWriteLock 是一个读写锁接口，<br>ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写<br>的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、<br>写和写之间才会互斥，提升了读写的性能。<br>21、FutureTask 是什么<br>这个其实前面有提到过，FutureTask 表示一个异步运算的任务。FutureTask 里面<br>可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等<br>待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是<br>Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p><p>24、线程 B 怎么知道线程 A 修改了变量<br>1、volatile 修饰变量<br>2、synchronized 修饰修改变量的方法<br>3、wait&#x2F;notify<br>4、while 轮询<br>25、synchronized、volatile、CAS 比较<br>1、synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。<br>2、volatile 提供多线程共享变量可见性和禁止指令重排序优化。<br>3、CAS 是基于冲突检测的乐观锁（非阻塞）</p><p>29、多线程同步有哪几种方法？<br>Synchronized 关键字，Lock 锁实现，分布式锁等。<br>30、线程的调度策略<br>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线<br>程的运行：<br>1、线程体中调用了 yield 方法让出了对 cpu 的占用权利<br>2、线程体中调用了 sleep 方法使线程进入睡眠状态<br>3、线程由于 IO 操作受到阻塞<br>4、另外一个更高优先级线程出现<br>5）在支持时间片的系统中，该线程的时间片用完<br>31、ConcurrentHashMap 的并发度是什么<br>ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最<br>多同时可以有 16 条线程操作 ConcurrentHashMap，这也是<br>ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同<br>时有两条线程获取 Hashtable 中的数据吗？<br>32、Linux 环境下如何查找哪个线程使用 CPU 最长<br>1、获取项目的 pid，jps 或者 ps -ef | grep java，这个前面有讲过<br>2、top -H -p pid，顺序不能改变<br>33、Java 死锁以及如何避免？<br>Java 中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java 死锁情况<br>出现至少两个线程和两个或更多资源。<br>Java 发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。<br>34、死锁的原因<br>1、是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖<br>的闭环。<br>例如：线程在获得了锁 A 并且没有释放的情况下去申请锁 B，这时，另一个线程<br>已经获得了锁 B，在释放锁 B 之前又要先获得锁 A，因此闭环发生，陷入死锁循环。<br>2、默认的锁申请操作是阻塞的。<br>所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对<br>象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免<br>在一个同步方法中调用其它对象的延时方法和同步方法。</p><p>40、什么是线程调度器(Thread Scheduler)和时间分片(Time<br>Slicing)？<br>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。<br>一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分<br>片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可<br>以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所<br>以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优<br>先级）。<br>41、什么是自旋<br>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等<br>待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核<br>态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线<br>程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多<br>次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。<br>42、Java Concurrency API 中的 Lock 接口(Lock interface)<br>是什么？对比同步它有什么优势？<br>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结<br>构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>1、可以使锁更公平<br>2、可以使线程在等待锁的时候响应中断<br>3、可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>4、可以在不同的范围，以不同的顺序获取和释放锁</p><p>46、线程类的构造方法、静态块是被哪个线程调用的<br>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new<br>这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用<br>的。<br>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了<br>Thread1，main 函数中 new 了 Thread2，那么：<br>1、Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是<br>Thread2 自己调用的<br>2、Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是<br>Thread1 自己调用的<br>47、同步方法和同步块，哪个是更好的选择?<br>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代<br>码的效率。请知道一条原则：同步的范围越小越好。<br>48、Java 线程数过多会造成什么异常？<br>1、线程的生命周期开销非常高<br>2、消耗过多的 CPU 资源<br>如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空<br>闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU<br>资源时还将产生其他性能的开销。<br>3、降低稳定性<br>JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，<br>并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的<br>大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出<br>OutOfMemoryError 异常。<br>Java 面试题（一）<br>1、面向对象的特征有哪些方面？<br>答：<br>面向对象的特征主要有以下几个方面：<br> 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽<br>象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的<br>细节是什么。<br> 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类<br>被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让<br>变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要<br>手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中<br>关于桥梁模式的部分）。<br> 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问<br>只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自<br>治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写<br>一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，<br>只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，<br>明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是<br>封装得足够好的，因为几个按键就搞定了所有的事情）。<br> 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。<br>简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分<br>为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的<br>服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B<br>系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须<br>刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，<br>甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道<br>供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载<br>（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）<br>实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的<br>东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已<br>有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样<br>的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。<br>2、访问修饰符 public,private,protected,以及不写（默认）<br>时的区别？<br>答：<br>修饰符 当前类 同 包 子 类 其他包<br>public √ √ √ √<br>protecte<br>d<br>√ √ √ ×<br>default √ √ × ×<br>private √ × × ×<br>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公<br>开（public），对于不是同一个包中的其他类相当于私有（private）。受保护<br>（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私<br>有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的<br>修饰符可以是以上四种。<br>3、String 是最基本的数据类型吗？<br>答：<br>不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、<br>char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference<br>type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。<br>4、float f&#x3D;3.4;是否正确？<br>答:不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于<br>下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换<br>float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。<br>5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;<br>有错吗？<br>答：<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int<br>型，需要强制转换类型才能赋值给 short 型。而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确<br>编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。<br>6、Java 有没有 goto？<br>答：<br>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 James Gosling<br>（Java 之父）编写的《The Java Programming Language》一书的附录中给出<br>了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的<br>关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意<br>义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词<br>或单词的组合都被视为保留字）<br>7、int 和 Integer 有什么区别？<br>答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本<br>数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本<br>数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，<br>从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：<br> 原始类型: boolean，char，byte，short，int，long，float，double<br> 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，<br>Double<br>class AutoUnboxingTest {<br>public static void main(String[] args) {<br>Integer a &#x3D; new Integer(3);<br>Integer b &#x3D; 3; &#x2F;&#x2F; 将 3 自动装箱成 Integer 类型<br>int c &#x3D; 3;<br>System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false 两个引用没有引用同一对<br>象<br>System.out.println(a &#x3D;&#x3D; c); &#x2F;&#x2F; true a 自动拆箱成 int 类型再和 c<br>比较<br>}<br>}<br>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：<br>public class Test03 {<br>public static void main(String[] args) {<br>Integer f1 &#x3D; 100, f2 &#x3D; 100, f3 &#x3D; 150, f4 &#x3D; 150;<br>System.out.println(f1 &#x3D;&#x3D; f2);<br>System.out.println(f3 &#x3D;&#x3D; f4);<br>}<br>}<br>如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的<br>是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，所以下面的&#x3D;&#x3D;运算比较的不<br>是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的<br>时候，会调用 Integer 类的静态方法 valueOf，如果看看 valueOf 的源代码就知<br>道发生了什么。<br>简单的说，如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer<br>对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1f4 的结果<br>是 false。<br>提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。<br>8、&amp;和&amp;&amp;的区别？<br>答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与<br>跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是<br>true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的<br>表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我<br>们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是 null 而且不<br>是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者<br>的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行<br>字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或<br>运算符（|）和短路或运算符（||）的差别也是如此。<br>补充：如果你熟悉 JavaScript，那你可能更能感受到短路运算的强大，想成为<br>JavaScript 的高手就先从玩转短路运算开始吧。<br>9、解释内存中的栈(stack)、堆(heap)和方法区(method area)<br>的用法。<br>答：<br>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的<br>现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在<br>堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收<br>集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、<br>Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都<br>是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变<br>量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”<br>hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来<br>最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM<br>的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量<br>池空间不足则会引发 OutOfMemoryError。<br>String str &#x3D; new String(“hello”);<br>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”<br>hello”这个字面量是放在方法区的。<br>补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发<br>展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一<br>定分配在堆上这件事情已经变得不那么绝对了。<br>补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求<br>常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String<br>类的 intern()方法就是这样的。<br>看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否<br>一致。<br>String s1 &#x3D; new StringBuilder(“go”)<br>.append(“od”).toString();<br>System.out.println(s1.intern() &#x3D;&#x3D; s1);<br>String s2 &#x3D; new StringBuilder(“ja”)<br>.append(“va”).toString();<br>System.out.println(s2.intern() &#x3D;&#x3D; s2);<br>10、Math.round(11.5) 等于多少？Math.round(-11.5)等于<br>多少？<br>答：<br>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五<br>入的原理是在参数上加 0.5 然后进行下取整。<br>11、switch 是否能作用在 byte 上，是否能作用在 long 上，<br>是否能作用在 String 上？<br>答：<br>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java<br>5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，<br>expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是<br>不可以的。<br>12、用最有效率的方法计算 2 乘以 8？<br>答：<br>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。<br>补充：我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代码，其<br>实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为<br>什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答案你可以自己<br>百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，从而得到更好的性<br>能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移 5<br>位相当于乘以 2 的 5 次方再减去自身就相当于乘以 31，现在的 VM 都能自动完成<br>这个优化。</p><p>13、数组有没有 length()方法？String 有没有 length()方法？<br>答：<br>数组没有 length()方法，有 length 的属性。String 有 length()方法。JavaScript<br>中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。<br>14、在 Java 中，如何跳出当前的多重嵌套循环？<br>答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中<br>支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语<br>句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，<br>因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法<br>其实不知道更好）<br>15、构造器（constructor）是否可被重写（override）？<br>答：<br>构造器不能被继承，因此不能被重写，但可以被重载。<br>16、两个对象值相同(x.equals(y) ++++&#x3D;&#x3D; true)，但却可有不同的<br>hash code，这句话对不对？<br>答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) &#x3D;&#x3D;++++ true，它们的哈希码（hash code）<br>应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个<br>对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；(2)<br>如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求<br>去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现<br>在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，<br>如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>补充：关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人也就是<br>仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，<br>《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java<br>程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍<br>equals 方法的：首先 equals 方法必须满足自反性（x.equals(x)必须返回 true）、<br>对称性（x.equals(y)返回 true 时，y.equals(x)也必须返回 true）、传递性<br>（x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true）和一<br>致性（当 x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同<br>样的返回值），而且对于任何非 null 值的引用 x，x.equals(null)必须返回 false。<br>实现高质量的 equals 方法的诀窍包括：1. 使用&#x3D;&#x3D;操作符检查”参数是否为这个<br>对象的引用”；2. 使用 instanceof 操作符检查”参数是否为正确的类型”；3. 对<br>于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完 equals<br>方法后，问自己它是否满足对称性、传递性、一致性；5. 重写 equals 时总是要<br>重写 hashCode；6. 不要将 equals 方法参数中的 Object 对象替换为其他的类型，<br>在重写时不要忘掉@Override 注解。<br>17、是否可以继承 String 类？<br>答：<br>String 类是 final 类，不可以被继承。<br>补充：继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关<br>联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。<br>18、当一个对象被当作参数传递到一个方法后，此方法可改变<br>这个对象的属性，并可返回变化后的结果，那么这里到底是值传<br>递还是引用传递？<br>答：<br>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个<br>参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调<br>用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和 C#中可以<br>通过传引用或传输出参数来改变传入的参数的值。在 C#中可以编写如下所示的代<br>码，但是在 Java 中却做不到。<br>using System;<br>namespace CS01 {<br>class Program {<br>public static void swap(ref int x, ref int y) {<br>int temp &#x3D; x;<br>x &#x3D; y;<br>y &#x3D; temp;<br>}<br>public static void Main (string[] args) {<br>int a &#x3D; 5, b &#x3D; 10;<br>swap (ref a, ref b);<br>&#x2F;&#x2F; a &#x3D; 10, b &#x3D; 5;<br>Console.WriteLine (“a &#x3D; {0}, b &#x3D; {1}”, a, b);<br>}<br>}<br>}<br>说明：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到<br>改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过<br>方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），<br>这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++转型为 Java 程序员的开<br>发者无法容忍。<br>19、String 和 StringBuilder、StringBuffer 的区别？<br>答：<br>Java 平台提供了两种类型的字符串：String 和 StringBuffer&#x2F;StringBuilder，它<br>们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的<br>字符串内容是不能被改变的。而 StringBuffer&#x2F;StringBuilder 类表示的字符串对象<br>可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方<br>法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被<br>synchronized 修饰，因此它的效率也比 StringBuffer 要高。<br>面试题 1 - 什么情况下用+运算符进行字符串连接比调用<br>StringBuffer&#x2F;StringBuilder 对象的 append 方法连接字符串性能更好？<br>面试题 2 - 请说出下面程序的输出。<br>class StringEqualTest {<br>public static void main(String[] args) {<br>String s1 &#x3D; “Programming”;<br>String s2 &#x3D; new String(“Programming”);<br>String s3 &#x3D; “Program”;<br>String s4 &#x3D; “ming”;<br>String s5 &#x3D; “Program” + “ming”;<br>String s6 &#x3D; s3 + s4;<br>System.out.println(s1 &#x3D;&#x3D; s2);<br>System.out.println(s1 &#x3D;&#x3D; s5);<br>System.out.println(s1 &#x3D;&#x3D; s6);<br>System.out.println(s1 &#x3D;&#x3D; s6.intern());<br>System.out.println(s2 &#x3D;&#x3D; s2.intern());<br>}<br>}<br>补充：解答上面的面试题需要清除两点：1. String 对象的 intern 方法会得到字符<br>串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象<br>的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加<br>到常量池中，然后返回常量池中字符串的引用；2. 字符串的+操作其本质是创建<br>了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用<br>toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class<br>命令获得 class 文件对应的 JVM 字节码指令就可以看出来。<br>20、重载（Overload）和重写（Override）的区别。重载的<br>方法能否根据返回类型进行区分？<br>答：<br>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，<br>而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同<br>的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写<br>发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返<br>回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里<br>氏代换原则）。重载对返回类型没有特殊的要求。<br>面试题：华为的面试题中曾经问过这样一个问题 - “为什么不能根据返回类型来<br>区分重载”，快说出你的答案吧！<br>21、描述一下 JVM 加载 class 文件的原理机制？<br>答：<br>JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的<br>类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件<br>中的类。<br>由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一<br>个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、<br>连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读<br>入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应<br>的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类<br>被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设<br>置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对<br>类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么<br>就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。<br>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加<br>载器（Extension）、系统加载器（System）和用户自定义类加载器<br>（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采<br>取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制<br>中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载<br>器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载<br>器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类<br>加载器的说明：<br> Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；<br> Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父<br>加载器是 Bootstrap；<br> System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的<br>类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目<br>录中记载类，是用户自定义加载器的默认父加载器。<br>22、char 型变量中能不能存贮一个中文汉字，为什么？<br>答：<br>char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择<br>任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一<br>个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。<br>补充：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM<br>内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统<br>中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节<br>流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，<br>这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程<br>序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体&#x2F;共用体）共享内<br>存的特征来实现了。<br>23、抽象类（abstract class）和接口（interface）有什么异<br>同？<br>答：<br>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如<br>果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实<br>现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中<br>可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其<br>中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、<br>public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接<br>口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而<br>抽象类未必要有抽象方法。<br>24、静态嵌套类(Static Nested Class)和内部类（Inner Class）<br>的不同？<br>答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类<br>实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起<br>来挺诡异的，如下所示。<br>面试题 - 下面的代码哪些地方会产生编译错误？<br>class Outer {<br>class Inner {}<br>public static void foo() { new Inner(); }<br>public void bar() { new Inner(); }<br>public static void main(String[] args) {<br>new Inner();<br>}<br>}<br>注意：Java 中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中 foo<br>和 main 方法都是静态方法，静态方法中没有 this，也就是说没有所谓的外部类对<br>象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样<br>做：<br>new Outer().new Inner();<br>25、Java 中会存在内存泄漏吗，请简单描述。<br>答：<br>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被<br>广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无<br>用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。例如<br>Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收<br>这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）<br>或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存<br>泄露。<br>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明<br>显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在<br>内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾<br>回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过<br>期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，<br>这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起<br>来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，<br>即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，<br>从而对性能造成重大影响，极端情况下会引发 Disk Paging（物理内存与硬盘的虚<br>拟内存交换数据），甚至造成 OutOfMemoryError。<br>26、抽象的（abstract）方法是否可同时是静态的（static）,<br>是否可同时是本地方法（native），是否可同时被 synchronized<br>修饰？<br>答：<br>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛<br>盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现<br>的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细<br>节，因此也是相互矛盾的。<br>27、阐述静态变量和实例变量的区别。<br>答：<br>静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的<br>任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷<br>贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。<br>静态变量可以实现让多个对象共享内存。<br>补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。<br>28、是否可以从一个静态（static）方法内部发出对非静态<br>（non-static）方法的调用？<br>答：<br>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在<br>调用静态方法时可能对象并没有被初始化。<br>29、如何实现对象克隆？<br>答：<br>有两种方式：<br>1). 实现 Cloneable 接口并重写 Object 类中的 clone()方法；<br>2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真<br>正的深度克隆，代码如下。<br>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛<br>型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，<br>不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对<br>象。让问题在编译的时候暴露出来总是好过把问题留到运行时。<br>31、String s &#x3D; new String(“xyz”);创建了几个字符串对象？<br>答：<br>两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。<br>32、接口是否可继承（extends）接口？抽象类是否可实现<br>（implements）接口？抽象类是否可继承具体类（concrete<br>class）？<br>答：<br>接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽<br>象类可继承具体类也可以继承抽象类。<br>33、一个”.java”源文件中是否可以包含多个类（不是内部类）？<br>有什么限制？<br>答：<br>可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和<br>公开类的类名完全保持一致。<br>34、Anonymous Inner Class(匿名内部类)是否可以继承其它<br>类？是否可以实现接口？<br>答：<br>可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来<br>实现事件监听和回调。<br>35、内部类可以引用它的包含类（外部类）的成员吗？有没有<br>什么限制？<br>答：<br>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。<br>36、Java 中的 final 关键字有哪些用法？<br>答：<br>(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变<br>量：表示变量只能一次赋值以后值不能被修改（常量）。<br>38、数据类型之间的转换：<br> 如何将字符串转换为基本数据类型？<br> 如何将基本数据类型转换为字符串？<br>答：<br> 调用基本数据类型对应的包装类中的方法 parseXXX(String)或<br>valueOf(String)即可返回相应基本类型；<br> 一种方法是将基本数据类型与空字符串（”“）连接（+）即可获得其所<br>对应的字符串；另一种方法是调用 String 类中的 valueOf()方法返回相应字符<br>串<br>39、如何实现字符串的反转及替换？<br>答：<br>方法很多，可以自己写实现也可以使用 String 或 StringBuffer&#x2F;StringBuilder 中<br>的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：<br>public static String reverse(String originStr) {<br>if(originStr &#x3D;&#x3D; null || originStr.length() &lt;&#x3D; 1)<br>return originStr;<br>return reverse(originStr.substring(1)) + originStr.charAt(0);<br>}<br>40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的<br>字符串？<br>答：<br>代码如下所示：<br>String s1 &#x3D; “你好”;<br>String s2 &#x3D; new String(s1.getBytes(“GB2312”), “ISO-8859-1”);<br>41、日期和时间：<br> 如何取得年月日、小时分钟秒？<br> 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？<br> 如何取得某月的最后一天？<br> 如何格式化日期？<br>答：<br>问题 1：创建 java.util.Calendar 实例，调用其 get()方法传入不同的参数即可获<br>得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTimel 来获取，代码<br>如下所示。<br>问题 2：以下方法均可获得该毫秒数。<br>Calendar.getInstance().getTimeInMillis();<br>System.currentTimeMillis();<br>Clock.systemDefaultZone().millis(); &#x2F;&#x2F; Java 8<br>问题 3：代码如下所示。<br>Calendar time &#x3D; Calendar.getInstance();<br>time.getActualMaximum(Calendar.DAY_OF_MONTH);<br>问题 4：利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的<br>format(Date)方法可将日期格式化。Java 8 中可以用<br>java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。<br>补充：Java 的时间日期 API 一直以来都是被诟病的东西，为了解决这一问题，Java<br>8 中引入了新的时间日期 API，其中包括 LocalDate、LocalTime、LocalDateTime、<br>Clock、Instant 等类，这些的类的设计都使用了不变模式，因此是线程安全的设<br>计。如果不理解这些内容，可以参考我的另一篇文章《关于 Java 并发编程的总结<br>和思考》。<br>43、比较一下 Java 和 JavaSciprt。<br>答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun<br>Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序<br>开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功<br>能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。<br>JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：<br> 基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发<br>简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络<br>无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和<br>事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对<br>象供设计人员使用。<br> 解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是<br>一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏<br>览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率）<br> 强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编<br>译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作<br>声明，JavaScript 的解释器在运行时检查推断其数据类型。<br> 代码格式不一样。<br>补充：上面列出的四点是网上流传的所谓的标准答案。其实 Java 和 JavaScript<br>最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势<br>是函数式语言和动态语言。在 Java 中类（class）是一等公民，而 JavaScript 中<br>函数（function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda<br>函数和闭包（closure），当然 Java 8 也开始支持函数式编程，提供了对 Lambda<br>表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的<br>语言回答会更加靠谱，不要背网上所谓的标准答案。<br>44、什么时候用断言（assert）？<br>答：<br>断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一<br>般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试<br>时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言<br>是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表<br>达式的值为 false，那么系统会报告一个 AssertionError。断言的使用如下面的代<br>码所示：<br>assert(a &gt; 0); &#x2F;&#x2F; throws an AssertionError if a &lt;&#x3D; 0<br>断言可以有两种形式：<br>assert Expression1;<br>assert Expression1 : Expression2 ;<br>Expression1 应该总是产生一个布尔值。<br>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信<br>息的字符串消息。<br>要在运行时启用断言，可以在启动 JVM 时使用-enableassertions 或者-ea 标记。<br>要在运行时选择禁用断言，可以在启动 JVM 时使用-da 或者-disableassertions<br>标记。要在系统类中启用或禁用断言，可使用-esa 或-dsa 标记。还可以在包的基<br>础上启用或者禁用断言。<br>注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某<br>些条件时阻止代码的执行，就可以考虑用断言来阻止它。<br>45、Error 和 Exception 有什么区别？<br>答：<br>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情<br>况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；<br>Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；<br>也就是说，它表示如果程序运行正常，从不会发生的情况。<br>面试题：2005 年摩托罗拉的面试中曾经问过这么一个问题“If a process reports<br>a stack overflow run-time error, what’s the most possible cause?”，给了<br>四个选项 a. lack of memory; b. write on an invalid memory space; c.<br>recursive function calling; d. array index out of boundary. Java 程序在运行<br>时也可能会遭遇 StackOverflowError，这是一个无法恢复的错误，只能重新修改<br>代码了，这个面试题的答案是 c。如果写了不能迅速收敛的递归，则很有可能引发<br>栈溢出的错误，如下所示：<br>class StackOverflowErrorTest {<br>public static void main(String[] args) {<br>main(null);<br>}<br>}<br>提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候<br>就不再继续递归）。</p><p>47、Java 语言如何进行异常处理，关键字：throws、throw、<br>try、catch、finally 分别如何使用？<br>答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了<br>良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类<br>的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，<br>调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理<br>是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况<br>下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过<br>它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用<br>来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要<br>捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个<br>方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段<br>代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语<br>句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的<br>try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这<br>种异常的 try 语句或者最终将异常抛给 JVM。<br>48、运行时异常与受检异常有何异同？<br>答：<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常<br>操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就<br>不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可<br>能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常，<br>但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对<br>象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用给出了以下指<br>导原则：<br> 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调<br>用者为了正常的控制流而使用异常）<br> 对可以恢复的情况使用受检异常，对编程错误使用运行时异常<br> 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发<br>生）<br> 优先使用标准的异常<br> 每个方法抛出的异常都要有文档<br> 保持异常的原子性<br> 不要在 catch 中忽略掉捕获到的异常<br>49、列出一些你常见的运行时异常？<br>答：<br> ArithmeticException（算术异常）<br> ClassCastException （类转换异常）<br> IllegalArgumentException （非法参数异常）<br> IndexOutOfBoundsException （下标越界异常）<br> NullPointerException （空指针异常）<br> SecurityException （安全异常）<br>51、类 ExampleA 继承 Exception，类 ExampleB 继承<br>ExampleA。<br>有如下代码片断：<br>try {<br>throw new ExampleB(“b”)<br>} catch（ExampleA e）{<br>System.out.println(“ExampleA”);<br>} catch（Exception e）{<br>System.out.println(“Exception”);<br>}<br>**请问执行此段代码的输出是什么？<br>答：<br>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，<br>抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的<br>异常）</p><p>53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。<br>答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的<br>数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉<br>及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由<br>于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较<br>ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存<br>储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索<br>引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更<br>高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本<br>项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中<br>提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties<br>都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非<br>线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类<br>Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这<br>是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强<br>实现）。<br>补充：遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，Properties<br>是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个<br>Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中的<br>Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代码的<br>方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继承工具<br>类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或<br>Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun 公司的工<br>程师们也会犯这种低级错误，让人唏嘘不已。<br>54、Collection 和 Collections 的区别？<br>答：<br>Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个<br>工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、<br>排序、线程安全化等等。<br>55、List、Map、Set 三个接口存取元素时，各有什么特点？<br>答：<br>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的<br>equals()方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，<br>映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的<br>两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树<br>版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达<br>到排序和去重的效果。</p><p>76、Statement 和 PreparedStatement 有什么区别？哪个性<br>能更好？<br>答：<br>与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优<br>势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可<br>能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串<br>连接拼接 SQL 语句的麻烦和不安全；③当批量处理 SQL 或频繁执行相同的查询时，<br>PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的<br>SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成<br>执行计划）。<br>补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接<br>口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语<br>句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数<br>（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全<br>性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，<br>因为每种数据库的存储过程在书写上存在不少的差别。<br>77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如<br>何提升更新数据的性能？<br>答：<br>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()<br>方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能<br>可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处<br>理中执行。<br>78、在进行数据库编程时，连接池有什么作用？<br>答：<br>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每<br>次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成<br>的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连<br>接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭<br>连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间<br>的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在<br>Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的<br>开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。<br>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性<br>能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓<br>存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数<br>据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快<br>过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对<br>于这个问题的讨论已经超出了这里要阐述的范围。</p><p>80、事务的 ACID 是指什么？<br>答：<br> 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作<br>的失败都会导致整个事务的失败；<br> 一致性(Consistent)：事务结束后系统状态是一致的；<br> 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；<br> 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难<br>性的失败。通过日志和同步备份可以在故障发生后重建数据。<br>补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。<br>首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一<br>数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻<br>读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类丢失更新）。<br>脏读（Dirty Read）：A 事务读取 B 事务尚未提交的数据并在此基础上操作，而 B<br>事务执行回滚，那么 A 读取到的数据就是脏数据。<br>时间 转账事务 A 取款事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 查询账户余额为 1000 元<br>T4 取出 500 元余额修改为 500<br>元<br>T5 查询账户余额为 500 元（脏读）<br>T6 撤销事务余额恢复为 1000 元<br>T7 汇入 100 元把余额修改为 600<br>元<br>T8 提交事务<br>不可重复读（Unrepeatable Read）：事务 A 重新读取前面读取过的数据，发现<br>该数据已经被另一个已提交的事务 B 修改过了。<br>时间 转账事务 A 取款事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 查询账户余额为 1000 元<br>T4 查询账户余额为 1000 元<br>T5 取出 100 元修改余额为 900<br>元<br>T6 提交事务<br>T7 查询账户余额为 900 元（不可重复读）<br>幻读（Phantom Read）：事务 A 重新执行一个查询，返回一系列符合查询条件<br>的行，发现其中插入了被事务 B 提交的行。<br>时间 统计金额事务 A 转账事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 统计总存款为 10000 元<br>T4 新增一个存款账户存入 100<br>元<br>T5 提交事务<br>T6 再次统计总存款为 10100 元（幻读）<br>第 1 类丢失更新：事务 A 撤销时，把已经提交的事务 B 的更新数据覆盖了。<br>时间 取款事务 A 转账事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 查询账户余额为 1000 元<br>T4 查询账户余额为 1000 元<br>T5 汇入 100 元修改余额为 1100<br>元<br>T6 提交事务<br>T7 取出 100 元将余额修改为 900 元<br>T8 撤销事务<br>T9 余额恢复为 1000 元（丢失更新）<br>第 2 类丢失更新：事务 A 覆盖事务 B 已经提交的数据，造成事务 B 所做的操作丢<br>失。<br>时间 转账事务 A 取款事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 查询账户余额为 1000 元<br>T4 查询账户余额为 1000 元<br>T5 取出 100 元将余额修改为 900<br>元<br>T6 提交事务<br>T7 汇入 100 元将余额修改为 1100 元<br>T8 提交事务<br>T9 查询账户余额为 1100 元（丢失更新）<br>数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能<br>就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不<br>同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具<br>体的内容大家可以自行查阅资料进行了解。<br>直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定<br>会话的事务隔离级别，数据库就会通过分析 SQL 语句然后为事务访问的资源加上<br>合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对<br>用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI&#x2F;ISO<br>SQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示：<br>隔离级别 脏读 不可重复读 幻读 第一类丢失更新 第二类丢失更新<br>READ<br>UNCOMMITED<br>允许 允许 允许 不允许 允许<br>READ<br>COMMITTED<br>不允许 允许 允许 不允许 允许<br>REPEATABLE<br>READ<br>不允许 不允许 允许 不允许 不允许<br>SERIALIZABLE 不允许 不允许 不允许 不允许 不允许<br>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高<br>并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没<br>有万能的原则。<br>**81、JDBC 中如何进行事务处理？<br>答：<br>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置<br>手动提交事务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中<br>发生异常则通过 rollback()进行事务回滚。除此之外，从 JDBC 3.0 中还引入了<br>Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保<br>存点。<br>82、JDBC 能否处理 Blob 和 Clob？<br>答：<br>Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象<br>（Character Large Objec），因此其中 Blob 是为存储大的二进制数据而设计的，<br>而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和<br>ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。下面的代码展示了如<br>何使用 JDBC 操作 LOB：<br>下面以 MySQL 数据库为例，创建一个张有三个字段的用户表，包括编号（id）、<br>姓名（name）和照片（photo），建表语句如下：<br>create table tb_user<br>(<br>id int primary key auto_increment,<br>name varchar(20) unique not null,<br>photo longblob<br>);<br>下面的 Java 代码向数据库中插入一条记录：</p><p>83、简述正则表达式及其用途。<br>答：<br>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。<br>正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本<br>规则的代码。<br>说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用<br>计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符<br>串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支<br>持。<br>84、Java 中是如何支持正则表达式操作的？<br>答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、<br>replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则<br>表达式对象，它提供了丰富的 API 进行各种正则表达式操作，请参考下面面试题<br>的代码。<br>面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京<br>市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;<br>class RegExpTest {<br>public static void main(String[] args) {<br>String str &#x3D; “北京市(朝阳区)(西城区)(海淀区)”;<br>Pattern p &#x3D; Pattern.compile(“.*?(?&#x3D;\()”);<br>Matcher m &#x3D; p.matcher(str);<br>if(m.find()) {<br>System.out.println(m.group());<br>}<br>}<br>}<br>说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐<br>读一下网上很有名的《正则表达式 30 分钟入门教程》。<br>85、获得一个类的类对象有哪些方式？<br>答：<br> 方法 1：类型.class，例如：String.class<br> 方法 2：对象.getClass()，例如：”hello”.getClass()<br> 方法 3：Class.forName()，例如：Class.forName(“java.lang.String”)<br>**86、如何通过反射创建对象？<br>答：<br> 方法 1：通过类对象调用 newInstance()方法，例如：<br>String.class.newInstance()<br> 方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()<br>方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象，<br>例如：String.class.getConstructor(String.class).newInstance(“Hello”);<br>**87、如何通过反射获取和设置对象私有字段的值？<br>答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段<br>对象的 setAccessible(true)将其设置为可以访问，接下来就可以通过 get&#x2F;set 方<br>法来获取&#x2F;设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静<br>态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类<br>型且支持多级对象操作，例如 ReflectionUtil.get(dog, “owner.car.engine.id”);<br>可以获得 dog 对象的主人的汽车的引擎的 ID 号。</p><p>88、如何通过反射调用对象的方法？<br>答：<br>请看下面的代码：<br>import java.lang.reflect.Method;<br>class MethodInvokeTest {<br>public static void main(String[] args) throws Exception {<br>String str &#x3D; “hello”;<br>Method m &#x3D; str.getClass().getMethod(“toUpperCase”);<br>System.out.println(m.invoke(str)); &#x2F;&#x2F; HELLO<br>}<br>}<br>**89、简述一下面向对象的”六原则一法则”。<br>答：<br> 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”<br>高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝<br>典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一<br>个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，<br>而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我<br>们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那<br>么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单<br>一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基<br>本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速<br>器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定<br>是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模<br>块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）<br> 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，<br>当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类<br>就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关<br>键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系<br>统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系<br>统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》<br>一书中对桥梁模式的讲解的章节。）<br> 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方<br>法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不<br>用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里<br>氏替换原则。）<br>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的<br>描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父<br>类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如<br>果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对<br>代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都<br>是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：<br>子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更<br>多，把能力多的对象当成能力少的对象来用当然没有任何问题。）<br> 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的<br>污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高<br>度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口<br>中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，<br>毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现<br>几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能<br>力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）<br> 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复<br>用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例<br>外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，<br>Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关<br>联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是<br>Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关<br>系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在<br>Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable<br>类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在<br>Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符<br>串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来<br>存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，<br>而不是拿来继承的。）<br> 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有<br>尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和<br>调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你<br>去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对<br>这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要<br>做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。<br>再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控<br>制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所<br>知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可<br>以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡<br>各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，<br>计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它<br>将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统<br>的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人<br>打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）<br>92、什么是 UML？<br>答：<br>UML 是统一建模语言（Unified Modeling Language）的缩写，它发表于 1997<br>年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型<br>化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支<br>持。使用 UML 可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系<br>统的结构和行为。<br>93、UML 中有哪些常用的图？<br>答：<br>UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结<br>构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence<br>diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、<br>活动图（activity diagram）、构件图（component diagram）、部署图（deployment<br>diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来<br>捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、<br>类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描<br>述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能<br>接收的消息也就是说对象能够向外界提供的服务）。<br>用例图：<br>类图：<br>时序图：<br>1、Java 中能创建 volatile 数组吗？<br>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不<br>是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，<br>但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护<br>作用了。<br>2、volatile 能使得一个非原子操作变成原子操作吗？<br>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量<br>会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？<br>因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正<br>在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。<br>但是对一个 volatile 型的 long 或 double 变量的读写是原子。<br>3、volatile 修饰符的有过什么实践？<br>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。<br>double 和 long 都是 64 位宽，因此对这两种类型的读是分为两部分的，第一次<br>读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中<br>volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个<br>作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的<br>说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write<br>barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意<br>思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，<br>在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其<br>他所有写的值更新到缓存。<br>4、volatile 类型变量提供什么保证？<br>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT 为了获得更好的性能<br>会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会<br>与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的<br>修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位<br>数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和<br>long 就是原子的。<br>5、10 个线程和 2 个线程的同步代码，哪个更容易写？<br>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互<br>独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的<br>竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。<br>6、你是如何调用 wait（）方法的？使用 if 块还是循环？为什<br>么？<br>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条<br>件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段<br>标准的使用 wait 和 notify 方法的代码：<br>&#x2F;&#x2F; The standard idiom for using the wait method<br>synchronized (obj) {<br>while (condition does not hold)<br>obj.wait(); &#x2F;&#x2F; (Releases lock, and reacquires on wakeup)<br>… &#x2F;&#x2F; Perform action appropriate to condition<br>}<br>参见 [Effective Java]第 69 条，获取更多关于为什么应该在循环中来调用 wait<br>方法的内容。<br>###7、什么是多线程环境下的伪共享（false sharing）？<br>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问<br>题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如<br>下图所示：<br>有经验程序员的 Java 面试题<br>伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧<br>在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审<br>查代码，根据缓存行来调整你的数据结构。<br>8、什么是 Busy spin？我们为什么要使用它？<br>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢<br>失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。<br>所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可<br>以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的<br>好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个<br>高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概<br>念实现的，使用 busy spin 循环 EventProcessors 等待屏障。<br>9、Java 中怎么获取一份线程 dump 文件？<br>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java<br>应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这<br>样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在<br>控制台或者日志文件中，具体位置依赖应用的配置。如果你使用 Tomcat。<br>10、Swing 是线程安全的？<br>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如<br>JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。<br>这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其<br>他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以<br>一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学<br>习到更详细的内容。<br>11、什么是线程局部变量？<br>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共<br>享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方<br>式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，<br>在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线<br>程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。<br>12、用 wait-notify 写一段代码来解决生产者-消费者问题？<br>答案<br>请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如<br>果阻塞，通过循环来测试等待条件。<br>15、什么是不可变对象（immutable object）？Java 中怎么<br>创建一个不可变对象？<br>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的<br>对象，如 String、Integer 及其它包装类。详情参见答案，一步一步指导你在 Java<br>中创建一个不可变的类。<br>16、我们能创建一个包含可变对象的不可变对象吗？<br>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，<br>不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。<br>最常见的例子就是对象中包含一个日期对象的引用。<br>数据类型和 Java 基础面试问题<br>17、Java 中应该使用什么数据类型来代表价格？<br>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的<br>double 类型。<br>18、怎么将 byte 转换为 String？<br>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用<br>的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也<br>可能不同。<br>19、Java 中怎样将 bytes 转换为 long 类型？<br>这个问题你来回答 :-)<br>20、我们能将 int 强制转换为 byte 类型的变量吗？如果该值<br>大于 byte 类型的范围，将会出现什么现象？<br>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位<br>的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围<br>是从 -128 到 128。<br>21、存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为<br>C 么？如 C &#x3D; (C) B；<br>答案<br>ss-interface-example.html<br>22、哪个类包含 clone 方法？是 Cloneable 还是 Object？<br>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在<br>object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由<br>c 或 c++ 或 其他本地语言实现的。<br>23、Java 中 ++ 操作符是线程安全的吗？<br>答案：不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存<br>储回内存，这个过程可能会出现多个线程交差。<br>23、不是线程安全的操作。它涉及到多个指令，如读取变量值，<br>增加，然后存储回内存，这个过程可能会出现多个线程交差。<br>24、a &#x3D; a + b 与 a +&#x3D; b 的区别<br>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相<br>加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法<br>操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是<br>a +&#x3D; b 没问题，如下：<br>byte a &#x3D; 127;<br>byte b &#x3D; 127;<br>b &#x3D; a + b; &#x2F;&#x2F; error : cannot convert from int to byte<br>b +&#x3D; a; &#x2F;&#x2F; ok<br>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会<br>报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte<br>就会编译出错）<br>25、我能在不进行强制转换的情况下将一个 double 值赋值给<br>long 类型的变量吗？<br>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型<br>的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。<br>26、3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？<br>false，因为有些浮点数不能完全精确的表示出来。<br>27、int 和 Integer 哪个会占用更多的内存？<br>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。<br>但是 int 是一个原始类型的数据，所以占用的空间更少。<br>28、为什么 Java 中的 String 是不可变的（Immutable）？<br>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字<br>符串设置为不可变可以允许多个客户端之间共享相同的字符串。<br>29、我们能在 Switch 中使用 String 吗？<br>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法<br>糖。内部实现在 switch 中使用字符串的 hash code。<br>30、Java 中的构造器链是什么？<br>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在<br>重载了类的构造器的时候才会出现。<br>JVM 底层 与 GC（Garbage Collection） 的面试问题<br>31、64 位 JVM 中，int 的长度是多数？<br>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就<br>是说，在 32 位 和 64 位 的 Java 虚拟机中，int 类型的长度是相同的。<br>32、Serial 与 Parallel GC 之间的不同之处？<br>Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要<br>不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而<br>parallel 收集器使用多个 GC 线程来执行。<br>33、32 位和 64 位的 JVM，int 类型变量的长度是多数？<br>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4<br>个字节。<br>34、Java 中 WeakReference 与 SoftReference 的区别？<br>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，<br>但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用<br>虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。<br>35、WeakHashMap 是怎么工作的？<br>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，<br>意思就是当 key 对象没有任何引用时，key&#x2F;value 将会被回收。<br>36、JVM 选项 -XX:+UseCompressedOops 有什么作用？<br>为什么要使用？<br>当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从<br>32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU<br>缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM<br>主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过<br>-XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位<br>的 OOP。<br>37、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64<br>位？<br>你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。<br>38、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？<br>理论上说上 32 位的 JVM 堆内存可以到达 2&#x3D;&#x3D;&#x3D;&#x3D;^32，即 4GB，但实际上会比这个<br>小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约<br>3GB。64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^&#x3D;&#x3D;&#x3D;&#x3D;64，这是一个非<br>常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，<br>堆内存到 1000G 都是可能的。<br>39、JRE、JDK、JVM 及 JIT 之间有什么不同？<br>JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代<br>表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java<br>编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它<br>的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当<br>代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主<br>要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。<br>3 年工作经验的 Java 面试题<br>40、解释 Java 堆空间及 GC？<br>当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于<br>创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内<br>部的一个进程，回收无效对象的内存用于将来的分配。<br>JVM 底层面试题及答案<br>41、你能保证 GC 执行吗？<br>不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC<br>的执行。<br>42、怎么获取 Java 程序使用的内存？堆使用的百分比？<br>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及<br>最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。<br>Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory()<br>方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。<br>43、Java 中堆和栈有什么区别？<br>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局<br>部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，<br>而堆被整个 JVM 的所有线程共享。<br>关于内存的的面试问题和答案<br>Java 基本概念面试题<br>44、“a&#x3D;&#x3D;b”和”a.equals(b)”有什么区别？<br>如果 a 和 b 都是对象，则 a&#x3D;&#x3D;b 是比较两个对象的引用，只有当 a 和 b 指<br>向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以<br>通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方<br>法，所以可以用于两个不同对象，但是包含的字母相同的比较。<br>45、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？<br>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，<br>如 Hashtable、HashMap、LinkedHashMap 等等。它与 equals() 方法关系特<br>别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有<br>相同的 hash code。<br>46、final、finalize 和 finally 的不同之处？<br>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该<br>变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，<br>给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally<br>是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，<br>无论在 try 块中是否有发生异常。<br>47、Java 中的编译期常量是什么？使用它又什么风险？<br>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里<br>的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些<br>变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你<br>使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改<br>变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了<br>避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。<br>Java 集合框架的面试题<br>这部分也包含数据结构、算法及数组的面试问题<br>48、List、Set、Map 和 Queue 之间的区别(答案)<br>List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量<br>访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。<br>49、poll() 方法和 remove() 方法的区别？<br>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败<br>的时候会返回空，但是 remove() 失败的时候会抛出异常。<br>50、Java 中 LinkedHashMap 和 PriorityQueue 的区别是<br>什么？<br>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是<br>LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue<br>时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺<br>序。<br>51、ArrayList 与 LinkedList 的不区别？<br>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而<br>LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，<br>ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见<br>答案。<br>52、用哪两种方式来实现集合的排序？<br>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，<br>如 list，然后通过 Collections.sort() 来排序。<br>53、Java 中怎么打印数组？<br>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由<br>于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println()<br>方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。<br>54、Java 中的 LinkedList 是单向链表还是双向链表？<br>是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，<br>直接在编辑器中打开该类。<br>55、Java 中的 TreeMap 是采用什么树实现的？(答案)<br>Java 中的 TreeMap 是使用红黑树实现的。<br>56、Hashtable 与 HashMap 有什么不同之处？<br>这两个类有许多不同的地方，下面列出了一部分：<br>a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。<br>b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。<br>c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。<br>更多的不同之处参见答案。<br>57、Java 中的 HashSet，内部是如何工作的？<br>HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以<br>所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的<br>key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。<br>58、写一段代码在遍历 ArrayList 时移除一个元素？<br>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的<br>remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移<br>除元素，而不会出现 ConcurrentModificationException 异常的示例代码。<br>59、我们能自己写一个容器类，然后使用 for-each 循环码？<br>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，<br>你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。<br>60、ArrayList 和 HashMap 的默认大小是多数？<br>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是<br>16 个元素（必须是 2 的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的<br>代码片段：<br>&#x2F;&#x2F; from ArrayList.java JDK 1.7<br>private static final int DEFAULT_CAPACITY &#x3D; 10;<br>&#x2F;&#x2F;from HashMap.java JDK 7<br>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16<br>61、有没有可能两个不相等的对象有有相同的 hashcode？<br>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在<br>hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必<br>须有相同的 hashcode 值，但是没有关于不相等对象的任何规定。<br>62、两个相同的对象会有不同的的 hash code 吗？<br>不能，根据 hash code 的规定，这是不可能的。<br>63、我们可以在 hashcode() 中使用随机数字吗？<br>答案<br>ple.html<br>不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中<br>重写 hashCode() 方法的知识。<br>64、Java 中，Comparator 与 Comparable 有什么不同？<br>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户<br>定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义<br>对象的顺序。<br>65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？(答案)<br>因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，<br>如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。<br>Java IO 和 NIO 的面试题<br>IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以<br>及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。<br>66、在我 Java 程序中，我有三个 socket，我需要多少个线<br>程来处理？<br>67、Java 中怎么创建 ByteBuffer？<br>byte[] bytes &#x3D; new byte[10];<br>ByteBuffer buf &#x3D; ByteBuffer.wrap(bytes);<br>68、Java 中，怎么读写 ByteBuffer ？<br>69、Java 采用的是大端还是小端？<br>70、ByteBuffer 中的字节序是什么？<br>71、Java 中，直接缓冲区与非直接缓冲器有什么区别？<br>答案<br>72、Java 中的内存映射缓存区是什么？<br>答案<br>ava.html<br>73、socket 选项 TCP NO DELAY 是指什么？<br>74、TCP 协议与 UDP 协议有什么区别？<br>答案<br>-udp-protocol.html<br>75、Java 中，ByteBuffer 与 StringBuffer 有什么区别？(答<br>案)<br>Java 最佳实践的面试问题<br>包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常<br>处理，设计模式等等。<br>76、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？<br>这是我在写 Java 并发程序的时候遵循的一些最佳实践：<br>a）给线程命名，这样可以帮助调试。<br>b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。<br>c）如果可以，更偏向于使用 volatile 而不是 synchronized。<br>d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通<br>信，如 BlockingQueue，CountDownLatch 及 Semeaphore。<br>e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。<br>77、说出几点 Java 中使用 Collections 的最佳实践<br>这是我在使用 Java 中 Collectionc 类的一些最佳实践：<br>a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是<br>Vector。<br>b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。<br>c）使用接口代表和访问集合，如使用 List 存储 ArrayList，使用 Map 存储<br>HashMap 等等。<br>d）使用迭代器来循环集合。<br>e）使用集合的时候使用泛型。<br>78、说出至少 5 点在 Java 中使用线程的最佳实践。<br>答案<br>gthread-in-java.html<br>这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：<br>a）对线程命名<br>b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。<br>c）使用线程池<br>79、说出 5 条 IO 的最佳实践(答案)<br>IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上<br>避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：<br>a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。<br>b）使用 NIO 和 NIO2<br>c）在 finally 块中关闭流，或者使用 try-with-resource 语句。<br>d）使用内存映射文件获取更快的 IO。<br>80、列出 5 个应该遵循的 JDBC 最佳实践<br>答案<br>ava.html))<br>有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：<br>a）使用批量的操作来插入和更新数据<br>b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。<br>c）使用数据库连接池<br>d）通过列名来获取结果集，不要使用列的下标来获取。<br>81、说出几条 Java 中方法重载的最佳实践？<br>下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。<br>a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参<br>数。<br>b）不要重载参数数量一致，而只是参数顺序不同的方法。<br>c）如果重载的方法参数个数多于 5 个，采用可变参数。<br>Date、Time 及 Calendar 的面试题<br>82、在多线程环境下，SimpleDateFormat 是线程安全的吗？<br>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是<br>线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中<br>使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，<br>在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、<br>时间处理的所有实践来说，我强力推荐 joda-time 库。<br>83、Java 中如何格式化一个日期？如格式化为 ddMMyyyy<br>的形式？<br>答案<br>dateformat.html<br>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。<br>DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代<br>码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。<br>84、Java 中，怎么在格式化的日期中显示时区？<br>答案<br>85、Java 中 java.util.Date 与 java.sql.Date 有什么区别？<br>答案<br>86、Java 中，如何计算两个日期之间的差距？<br>程序<br>87、Java 中，如何将字符串 YYYYMMDD 转换为日期？<br>答案<br>hreading.html<br>单元测试 JUnit 面试题<br>89、如何测试静态方法？(答案)<br>可以使用 PowerMock 库来测试静态方法。<br>90、怎么利用 JUnit 来测试一个方法的异常？<br>答案<br>91、你使用过哪个单元测试库来测试你的 Java 程序？<br>92、@Before 和 @BeforeClass 有什么区别？<br>答案<br>编程和代码相关的面试题<br>93、怎么检查一个字符串只包含数字？解决方案<br>mbers-in-String.html<br>94、Java 中如何利用泛型写一个 LRU 缓存？<br>95、写一段 Java 程序将 byte 转换为 long？<br>95、在不使用 StringBuffer 的前提下，怎么反转一个字符串？<br>解决方案<br>buffer-stringbuilder.htm<br>97、Java 中，怎么获取一个文件中单词出现的最高频率？<br>解决方案<br>ds-and-count.html<br>98、如何检查出两个给定的字符串是反序的？<br>解决方案<br>tring-are-anagrams-example-tutorial.html<br>99、Java 中，怎么打印出一个字符串的所有排列？<br>解决方案<br>100、Java 中，怎样才能打印出数组中的重复元素？<br>解决方案<br>ents-in-array-java.html<br>101、Java 中如何将字符串转换为整数？<br>String s&#x3D;”123”;<br>int i;<br>第一种方法：i&#x3D;Integer.parseInt(s);<br>第二种方法：i&#x3D;Integer.valueOf(s).intValue();<br>102、在没有使用临时变量的情况如何交换两个整数变量的值？<br>解决方案<br>关于 OOP 和设计模式的面试题<br>这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，<br>接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。<br>也包含了 GOF 设计模式的问题。<br>103、接口是什么？为什么要使用接口而不是直接使用具体类？<br>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，<br>因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机<br>访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写<br>代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这<br>种方法是具体的。<br>104、Java 中，抽象类与接口之间有什么不同？<br>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个<br>类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类<br>的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。<br>105、除了单例模式，你在生产环境中还用过什么设计模式？<br>这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰<br>模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的<br>基于你选择的模式的问题。<br>106、你能解释一下里氏替换原则吗?<br>答案<br>迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。<br>108、适配器模式是什么？什么时候使用？<br>适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一<br>些接口，你就可以写一个适配去来连接这些接口。<br>109、什么是“依赖注入”和“控制反转”？为什么有人使用？<br>控制反转（IOC）是 Spring 框架的核心思想，用我自己的话说，就是你要做一件<br>事，别自己可劲 new 了，你就说你要干啥，然后外包出去就好~<br>依赖注入（DI） 在我浅薄的想法中，就是通过接口的引用和构造方法的表达，将<br>一些事情整好了反过来传给需要用到的地方~<br>110、抽象类是什么？它与接口有什么区别？你为什么要使用过<br>抽象类？<br>接口用于规范，抽象类用于共性.<br>声明方法的存在而不去实现它的类被叫做抽象类<br>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。<br>111、构造器注入和 setter 依赖注入，那种方式更好？<br>每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是<br>setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，<br>Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使<br>用 setter 注入。<br>112、依赖注入和工程模式之间有什么不同？<br>虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式<br>更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获<br>取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用<br>工厂模式更容易测试。<br>113、适配器模式和装饰器模式有什么区别？<br>虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配<br>器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加<br>新的功能。<br>114、适配器模式和代理模式之前有什么不同？<br>这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由<br>于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是<br>适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便<br>支持分配、控制或智能访问。<br>115、什么是模板方法模式？<br>模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序<br>算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用<br>Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方<br>法就是众所周知的模板方法。<br>116、什么时候使用访问者模式？<br>访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模<br>式采用双派发的形式来增加中间层。<br>117、什么时候使用组合模式？<br>组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式<br>来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采<br>用组合模式。<br>118、继承和组合之间有什么不同？<br>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行<br>时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。<br>119、描述 Java 中的重载和重写？<br>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，<br>而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方<br>法。重写必须要有继承。<br>120、Java 中，嵌套公共静态类与顶级类有什么不同？<br>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公<br>共类，并且顶级公共类的名称与源文件名称必须一致。<br>121、 OOP 中的 组合、聚合和关联有什么区别？<br>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中<br>的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一<br>个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B<br>组合的，则 A 不存在的话，B 一定不存在，但是如果 A 对象聚合了一个对象 B，<br>则即使 A 不存在了，B 也可以单独存在。<br>122、给我一个符合开闭原则的设计模式的例子？<br>开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增<br>加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代<br>码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策<br>略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是<br>Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的<br>对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。<br>123、抽象工厂模式和原型模式之间的区别？<br>抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方<br>法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产<br>品。当要切换为另一个系列的产品，换一个工厂类即可。<br>原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同<br>样复杂的工厂类的继承体系。我们可以把工厂类中的工厂方法放到产品类自身之<br>中吗？如果这样的话，就可以将两个继承体系为一个。这也就是原型模式的思想，<br>原型模式中的工厂方法为 clone，它会返回一个拷贝（可以是浅拷贝，也可以是深<br>拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用 clone 来动<br>态绑定地生成所需的具体的类。这些原型对象必须事先构造好。<br>原型模式想对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。<br>124、什么时候使用享元模式？<br>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保<br>你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池<br>以及 Long 池都是很好的使用了享元模式的例子。<br>Java 面试中其他各式各样的问题<br>这部分包含 Java 中关于 XML 的面试题，正则表达式面试题，Java 错误和异常<br>及序列化面试题<br>125、嵌套静态类与顶级类有什么区别？<br>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个<br>嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如<br>HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry 是一个嵌<br>套静态类。<br>126、你能写出一个正则表达式来判断一个字符串是否是一个数<br>字吗？<br>一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，<br>你可以下一个如下的正则表达式来判断给定的字符串是不是数字。<br>首先要 import java.util.regex.Pattern 和 java.util.regex.Matcher<br>public boolean isNumeric(String str){<br>Pattern pattern &#x3D; Pattern.compile(“[0-9]*“);<br>Matcher isNum &#x3D; pattern.matcher(str);<br>if( !isNum.matches() ){<br>return false;<br>}<br>return true;<br>}<br>127、Java 中，受检查异常 和 不受检查异常的区别？<br>受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过<br>throws 子句声明。其中一种情况是 Exception 的子类但不是<br>RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶<br>段不受编译器的检查。<br>128、Java 中，throw 和 throws 有什么区别<br>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通<br>过关键字 throw 抛出一个 Error 或者 一个 Exception，如：<br>throw new IllegalArgumentException(“size must be multiple of 2″ )<br>而 throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便<br>调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。<br>129、Java 中，Serializable 与 Externalizable 的区别？<br>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输<br>或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、<br>脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进<br>制格式，增加安全机制。<br>130、Java 中，DOM 和 SAX 解析器有什么不同？<br>DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以<br>更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，<br>不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要<br>求更多的内存，不适合于解析大 XML 文件。<br>131、说出 JDK 1.7 中的三个新特性？<br>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，<br>如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关<br>闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。<br>允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需<br>要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一<br>个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。<br>132、说出 5 个 JDK 1.8 引入的新特性？<br>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。<br>133、Java 中，Maven 和 ANT 有什么区别？<br>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，<br>在基于“约定优于配置”的概念下，提供标准的 Java 项目结构，同时能为应用自<br>动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之<br>处请参见答案。<br>这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的<br>所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，<br>这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也<br>没有包含主流的框架如 Spring MVC，Struts 2.0，Hibernate，也没有包含 SOAP<br>和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web<br>开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基<br>础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了<br>的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建<br>一份最新的、最优的 Java 面试问题列表。<br>3.1、什么是 spring bean？<br> 它们是构成用户应用程序主干的对象。<br> Bean 由 Spring IoC 容器管理。<br> 它们由 Spring IoC 容器实例化，配置，装配和管理。<br> Bean 是基于用户提供给容器的配置元数据创建。</p><p>5、数据访问<br>5.1、spring DAO 有什么用？<br>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一<br>种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写<br>代码时，无需考虑捕获每种技术不同的异常。<br>5.2、列举 Spring DAO 抛出的异常。<br>5.3、spring JDBC API 中存在哪些类？<br> JdbcTemplate<br> SimpleJdbcTemplate<br> NamedParameterJdbcTemplate<br> SimpleJdbcInsert<br> SimpleJdbcCall<br>5.4、使用 Spring 访问 Hibernate 的方法有哪些？<br>我们可以通过两种方式使用 Spring 访问 Hibernate：<br>1、 使用 Hibernate 模板和回调进行控制反转<br>2、 扩展 HibernateDAOSupport 并应用 AOP 拦截器节点<br>5.5、列举 spring 支持的事务管理类型<br>Spring 支持两种类型的事务管理：<br>1、 程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大<br>的灵活性，但维护起来非常困难。<br>2、 声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML<br>的配置来管理事务。</p><p>4、核心容器（应用上下文) 模块。<br>这是基本的 Spring 模块，提供 spring 框架的基础功能，BeanFactory 是 任何<br>以 spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使 Spring 成<br>为一个容器。<br>5、BeanFactory – BeanFactory 实现举例。<br>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依<br>赖从正真的应用代码中分离。<br>最常用的 BeanFactory 实现是 XmlBeanFactory 类。<br>6、XMLBeanFactory<br>最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory ，它<br>根据 XML 文件中的定义加载 beans。该容器从 XML 文件读取配置元数据并用它<br>去创建一个完全配置的系统或应用。</p><p>8、解释 JDBC 抽象和 DAO 模块。<br>通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源<br>错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一<br>的异常访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务<br>管理服务。<br>9、解释对象&#x2F;关系映射集成模块。<br>Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象&#x2F;关系映射<br>映射(ORM)工具，Spring 支持集成主流的 ORM 框架，如 Hiberate,JDO 和 iBATIS<br>SQL Maps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。<br>10、解释 WEB 模块。<br>Spring 的 WEB 模块是构建在 application context 模块基础之上，提供一个适<br>合 web 应用的上下文。这个模块也包括支持多种面向 web 的任务，如透明地处理<br>多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对 Jakarta<br>Struts 的支持。</p><p>15、ApplicationContext 通常的实现是什么?<br> FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加<br>载 beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。<br> ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加<br>载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath<br>里找 bean 配置。<br> WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定<br>义了一个 WEB 应用的所有 bean。<br>23、如何给 Spring 容器提供配置元数据?<br>这里有三种重要的方法给 Spring 容器提供配置元数据。<br>XML 配置文件。<br>基于注解的配置。<br>基于 java 的配置。<br>24、你怎样定义类的作用域?<br>当定义一个 在 Spring 里，我们还能给这个 bean 声明一个作用域。它可以通过<br>bean 定义中的 scope 属性来定义。如，当 Spring 要在需要的时候每次生产一个<br>新的 bean 实例，bean 的 scope 属性被指定为 prototype。另一方面，一个 bean<br>每次使用的时候必须返回同一个实例，这个 bean 的 scope 属性 必须设为<br>singleton。<br>28、哪些是重要的 bean 生命周期方法？你能重载它们吗？<br>有两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean<br>的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。<br>The bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们<br>你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和<br>@PreDestroy）。<br>30、在 Spring 中如何注入一个 java 集合？<br>Spring 提供以下几种集合的配置元素：<br> 类型用于注入一列值，允许有相同的值。<br> 类型用于注入一组值，不允许有相同的值。<br> 类型用于注入一组键值对，键和值都可以为任意类型。<br> 类型用于注入一组键值对，键和值都只能为 String 类型。</p><p>35、你可以在 Spring 中注入一个 null 和一个空字符串吗？<br>可以。<br>Spring 注解<br>36、什么是基于 Java 的 Spring 注解配置? 给一些注解的例子.<br>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring<br>配置而非通过 XML 文件。<br>以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被<br>Spring IOC 容器使用。另一个例子是@Bean 注解，它表示此方法将要返回一个<br>对象，作为一个 bean 注册进 Spring 应用上下文。<br>37、什么是基于注解的容器配置?<br>相对于 XML 文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号<br>的声明。<br>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，<br>而不是使用 xml 表述 bean 的装配关系。</p><p>42.在 Spring 框架中如何更有效地使用 JDBC?<br>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只<br>需写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供<br>的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate （例子见这里<br>here）<br>43、JdbcTemplate<br>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据<br>类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处<br>理。<br>44、Spring 对 DAO 的支持<br>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，<br>Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心<br>会捕获每种技术特有的异常。<br>45、使用 Spring 通过什么方式访问 Hibernate?<br>在 Spring 中有两种方式访问 Hibernate：<br> 控制反转 Hibernate Template 和 Callback。<br> 继承 HibernateDAOSupport 提供一个 AOP 拦截器。<br>46、Spring 支持的 ORM<br>Spring 支持以下 ORM：<br> Hibernate<br> iBatis<br> JPA (Java Persistence API)<br> TopLink<br> JDO (Java Data Objects)<br> OJB<br>47.如何通过HibernateDaoSupport将Spring和Hibernate<br>结合起来？<br>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<br> 配置 the Hibernate SessionFactory。<br> 继承 HibernateDaoSupport 实现一个 DAO。<br> 在 AOP 支持的事务中装配。</p><p>49、Spring 框架的事务管理有哪些优点？<br> 它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供<br>一个不变的编程模式。<br> 它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API<br>如<br> 它支持声明式事务管理。<br> 它和 Spring 各种数据访问抽象层很好得集成。<br>50、你更倾向用那种事务管理类型？<br>大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，<br>因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务<br>管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵<br>活性。</p><p>微服务 面试题<br>1、您对微服务有何了解？<br>微服务，又称微服务 架构，是一种架构风格，它将应用程序构建为以业务领域为<br>模型的小型自治服务集合 。<br>通俗地说，你必须看到蜜蜂如何通过对齐六角形蜡细胞来构建它们的蜂窝状物。<br>他们最初从使用各种材料的小部分开始，并继续从中构建一个大型蜂箱。这些细<br>胞形成图案，产生坚固的结构，将蜂窝的特定部分固定在一起。这里，每个细胞<br>独立于另一个细胞，但它也与其他细胞相关。这意味着对一个细胞的损害不会损<br>害其他细胞，因此，蜜蜂可以在不影响完整蜂箱的情况下重建这些细胞。<br>图 1：微服务的蜂窝表示 – 微服务访谈问题<br>请参考上图。这里，每个六边形形状代表单独的服务组件。与蜜蜂的工作类似，<br>每个敏捷团队都使用可用的框架和所选的技术堆栈构建单独的服务组件。就像在<br>蜂箱中一样，每个服务组件形成一个强大的微服务架构，以提供更好的可扩展性。<br>此外，敏捷团队可以单独处理每个服务组件的问题，而对整个应用程序没有影响<br>或影响最小。<br>2、微服务架构有哪些优势？<br>图 2：微服务的 优点 – 微服务访谈问题<br> 独立开发 – 所有微服务都可以根据各自的功能轻松开发<br> 独立部署 – 基于其服务，可以在任何应用程序中单独部署它们<br> 故障隔离 – 即使应用程序的一项服务不起作用，系统仍可继续运行<br> 混合技术堆栈 – 可以使用不同的语言和技术来构建同一应用程序的不同<br>服务<br> 粒度缩放 – 单个组件可根据需要进行缩放，无需将所有组件缩放在一起<br>3。微服务有哪些特点？<br>图 3：微服务的 特点 – 微服务访谈问题<br> 解耦 – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻<br>松构建，更改和扩展<br> 组件化 – 微服务被视为可以轻松更换和升级的独立组件<br> 业务能力 – 微服务非常简单，专注于单一功能<br> 自治 – 开发人员和团队可以彼此独立工作，从而提高速度<br> 持续交付 – 通过软件创建，测试和批准的系统自动化，允许频繁发布软<br>件<br> 责任 – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他<br>们负责的产品<br> 分散治理 – 重点是使用正确的工具来做正确的工作。这意味着没有标准<br>化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题<br> 敏捷 – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃<br>4、设计微服务的最佳实践是什么？<br>以下是设计微服务的最佳实践：<br>图 4：设计微服务的最佳实践 – 微服务访谈问题<br>5、微服务架构如何运作？<br>微服务架构具有以下组件：<br>图 5：微服务 架构 – 微服务面试问题<br> 客户端 – 来自不同设备的不同用户发送请求。<br> 身份提供商 – 验证用户或客户身份并颁发安全令牌。<br> API 网关 – 处理客户端请求。<br> 静态内容 – 容纳系统的所有内容。<br> 管理 – 在节点上平衡服务并识别故障。<br> 服务发现 – 查找微服务之间通信路径的指南。<br> 内容交付网络 – 代理服务器及其数据中心的分布式网络。<br> 远程服务 – 启用驻留在 IT 设备网络上的远程访问信息。<br>6、微服务架构的优缺点是什么？<br>7、单片，SOA 和微服务架构有什么区别？<br>图 6： 单片 SOA 和微服务之间的比较 – 微服务访谈问题<br> 单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密<br>封装。<br> 一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数<br>据传递，也可以涉及两个或多个协调某些活动的服务。<br> 微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型<br>自治服务集合。<br>8、在使用微服务架构时，您面临哪些挑战？<br>开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。<br> 自动化组件：难以自动化，因为有许多较小的组件。因此，对于每个组件，<br>我们必须遵循 Build，Deploy 和 Monitor 的各个阶段。<br> 易感性：将大量组件维护在一起变得难以部署，维护，监控和识别问题。<br>它需要在所有组件周围具有很好的感知能力。<br> 配置管理：有时在各种环境中维护组件的配置变得困难。<br> 调试：很难找到错误的每一项服务。维护集中式日志记录和仪表板以调试<br>问题至关重要。<br>9、SOA 和微服务架构之间的主要区别是什么？<br>SOA 和微服务之间的主要区别如下：<br>10、微服务有什么特点？<br>您可以列出微服务的特征，如下所示：<br>图 7：微服务的特征 – 微服务访谈问题<br>11、什么是领域驱动设计？<br>图 8： DDD 原理 – 微服务面试问题<br>12、为什么需要域驱动设计（DDD）？<br>图 9：我们需要 DDD 的因素 – 微服务面试问题<br>13、什么是无所不在的语言？<br>如果您必须定义泛在语言（UL），那么它是特定域的开发人员和用户使用的通用<br>语言，通过该语言可以轻松解释域。<br>无处不在的语言必须非常清晰，以便它将所有团队成员放在同一页面上，并以机<br>器可以理解的方式进行翻译。<br>14、什么是凝聚力？<br>模块内部元素所属的程度被认为是凝聚力。<br>15、什么是耦合？<br>组件之间依赖关系强度的度量被认为是耦合。一个好的设计总是被认为具有高内<br>聚力和低耦合性。<br>16、什么是 REST &#x2F; RESTful 以及它的用途是什么？<br>Representational State Transfer（REST）&#x2F; RESTful Web 服务是一种帮助计<br>算机系统通过 Internet 进行通信的架构风格。这使得微服务更容易理解和实现。<br>微服务可以使用或不使用 RESTful API 实现，但使用 RESTful API 构建松散耦合<br>的微服务总是更容易。<br>17、你对 Spring Boot 有什么了解？<br>事实上，随着新功能的增加，弹簧变得越来越复杂。如果必须启动新的 spring 项<br>目，则必须添加构建路径或添加 maven 依赖项，配置应用程序服务器，添加 spring<br>配置。所以一切都必须从头开始。<br>Spring Boot 是解决这个问题的方法。使用 spring boot 可以避免所有样板代码<br>和配置。因此，基本上认为自己就好像你正在烘烤蛋糕一样，春天就像制作蛋糕<br>所需的成分一样，弹簧靴就是你手中的完整蛋糕。<br>图 10： Spring Boot 的因素 – 微服务面试问题<br>18、什么是 Spring 引导的执行器？<br>Spring Boot 执行程序提供了 restful Web 服务，以访问生产环境中运行应用程序<br>的当前状态。在执行器的帮助下，您可以检查各种指标并监控您的应用程序。<br>19、什么是 Spring Cloud？<br>根据 Spring Cloud 的官方网站，Spring Cloud 为开发人员提供了快速构建分布<br>式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，<br>领导选举，分布式会话，集群状态）。<br>20、Spring Cloud 解决了哪些问题？<br>在使用 Spring Boot 开发分布式微服务时，我们面临的问题很少由 Spring Cloud<br>解决。<br> 与分布式系统相关的复杂性 – 包括网络问题，延迟开销，带宽问题，安<br>全问题。<br> 处理服务发现的能力 – 服务发现允许集群中的进程和服务找到彼此并进<br>行通信。<br> 解决冗余问题 – 冗余问题经常发生在分布式系统中。<br> 负载平衡 – 改进跨多个计算资源（例如计算机集群，网络链接，中央处<br>理单元）的工作负载分布。<br> 减少性能问题 – 减少因各种操作开销导致的性能问题。<br>21、在 Spring MVC 应用程序中使用 WebMvcTest 注释有什<br>么用处？<br>在测试目标只关注 Spring MVC 组件的情况下，WebMvcTest 注释用于单元测试<br>Spring MVC 应用程序。在上面显示的快照中，我们只想启动 ToTestController。<br>执行此单元测试时，不会启动所有其他控制器和映射。<br>22。你能否给出关于休息和微服务的要点？<br>虽然您可以通过多种方式实现微服务，但 REST over HTTP 是实现微服务的一种<br>方式。REST 还可用于其他应用程序，如 Web 应用程序，API 设计和 MVC 应用程<br>序，以提供业务数据。<br>微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件<br>可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用<br>程序。<br>简而言之，您可以说 REST 是构建微服务的媒介。<br>23、什么是不同类型的微服务测试？<br>在使用微服务时，由于有多个微服务协同工作，测试变得非常复杂。因此，测试<br>分为不同的级别。<br> 在底层，我们有面向技术的测试，如单元测试和性能测试。这些是完全自<br>动化的。<br> 在中间层面，我们进行了诸如压力测试和可用性测试之类的探索性测试。<br> 在顶层， 我们的 验收测试数量很少。这些验收测试有助于利益相关者理<br>解和验证软件功能。<br>24、您对 Distributed Transaction 有何了解？<br>分布式事务是指单个事件导致两个或多个不能以原子方式提交的单独数据源的突<br>变的任何情况。在微服务的世界中，它变得更加复杂，因为每个服务都是一个工<br>作单元，并且大多数时候多个服务必须协同工作才能使业务成功。<br>25、什么是 Idempotence 以及它在哪里使用？<br>幂等性是能够以这样的方式做两次事情的特性，即最终结果将保持不变，即好像<br>它只做了一次。<br>用法：在远程服务或数据源中使用 Idempotence，这样当它多次接收指令时，它<br>只处理指令一次。<br>26、什么是有界上下文？<br>有界上下文是域驱动设计的核心模式。DDD 战略设计部门的重点是处理大型模型<br>和团队。DDD 通过将大型模型划分为不同的有界上下文并明确其相互关系来处理<br>大型模型。<br>27、什么是双因素身份验证？<br>双因素身份验证为帐户登录过程启用第二级身份验证。<br>图 11： 双因素认证的表示 – 微服务访谈问题<br>因此，假设用户必须只输入用户名和密码，那么这被认为是单因素身份验证。<br>28、双因素身份验证的凭据类型有哪些？<br>这三种凭证是：<br>图 12： 双因素认证的证书类型 – 微服务面试问题<br>29、什么是客户证书？<br>客户端系统用于向远程服务器发出经过身份验证的请求的一种数字证书称为客户<br>端证书。客户端证书在许多相互认证设计中起着非常重要的作用，为请求者的身<br>份提供了强有力的保证。<br>30、PACT 在微服务架构中的用途是什么？<br>PACT 是一个开源工具，允许测试服务提供者和消费者之间的交互，与合同隔离，<br>从而提高微服务集成的可靠性。<br>微服务中的用法<br> 用于在微服务中实现消费者驱动的合同。<br> 测试微服务的消费者和提供者之间的消费者驱动的合同。<br>查看即将到来的批次<br>31、什么是 OAuth？<br>OAuth 代表开放授权协议。这允许通过在 HTTP 服务上启用客户端应用程序（例<br>如第三方提供商 Facebook，GitHub 等）来访问资源所有者的资源。因此，您可<br>以在不使用其凭据的情况下与另一个站点共享存储在一个站点上的资源。<br>32、康威定律是什么？<br>“任何 设计 系统 的组 织（ 广泛 定义 ）都 将产 生一 种设 计， 其结 构是 组织 通信 结构<br>的副 本。” – Mel Conway<br>图 13： Conway 定律的表示 – 微服务访谈问题<br>该法律基本上试图传达这样一个事实：为了使软件模块起作用，整个团队应该进<br>行良好的沟通。因此，系统的结构反映了产生它的组织的社会边界。<br>33、合同测试你懂什么？<br>根据 Martin Flower 的说法，合同测试是在外部服务边界进行的测试，用于验证<br>其是否符合消费服务预期的合同。<br>此外，合同测试不会深入测试服务的行为。更确切地说，它测试该服务调用的输<br>入＆输出包含所需的属性和所述响应延迟，吞吐量是允许的限度内。<br>34、什么是端到端微服务测试？<br>端到端测试验证了工作流中的每个流程都正常运行。这可确保系统作为一个整体<br>协同工作并满足所有要求。<br>通俗地说，你可以说端到端测试是一种测试，在特定时期后测试所有东西。<br>图 14：测试层次 – 微服务面试问题<br>35、Container 在微服务中的用途是什么？<br>容器是管理基于微服务的应用程序以便单独开发和部署它们的好方法。您可以将<br>微服务封装在容器映像及其依赖项中，然后可以使用它来滚动按需实例的微服务，<br>而无需任何额外的工作。<br>图 15： 容器的表示及其在微服务中的使用方式 – 微服务访谈问题<br>36、什么是微服务架构中的 DRY？<br>DRY 代表不要重复自己。它基本上促进了重用代码的概念。这导致开发和共享库，<br>这反过来导致紧密耦合。<br>37、什么是消费者驱动的合同（CDC）？<br>这基本上是用于开发微服务的模式，以便它们可以被外部系统使用。当我们处理<br>微服务时，有一个特定的提供者构建它，并且有一个或多个使用微服务的消费者。<br>通常，提供程序在 XML 文档中指定接口。但在消费者驱动的合同中，每个服务消<br>费者都传达了提供商期望的接口。<br>38、Web，RESTful API 在微服务中的作用是什么？<br>微服务架构基于一个概念，其中所有服务应该能够彼此交互以构建业务功能。因<br>此，要实现这一点，每个微服务必须具有接口。这使得 Web API 成为微服务的一<br>个非常重要的推动者。RESTful API 基于 Web 的开放网络原则，为构建微服务架<br>构的各个组件之间的接口提供了最合理的模型。<br>39、您对微服务架构中的语义监控有何了解？<br>语义监控，也称为 综合监控， 将自动化测试与监控应用程序相结合，以检测业<br>务失败因素。<br>40、我们如何进行跨功能测试？<br>跨功能测试是对非功能性需求的验证，即那些无法像普通功能那样实现的需求。<br>41、我们如何在测试中消除非决定论？<br>非确定性测试（NDT）基本上是不可靠的测试。所以，有时可能会发生它们通过，<br>显然有时它们也可能会失败。当它们失败时，它们会重新运行通过。<br>从测试中删除非确定性的一些方法如下：<br>1、 隔离<br>2、 异步<br>3、 远程服务<br>4、 隔离<br>5、 时间<br>6、 资源泄漏<br>42、Mock 或 Stub 有什么区别？<br>存根<br> 一个有助于运行测试的虚拟对象。<br> 在某些可以硬编码的条件下提供固定行为。<br> 永远不会测试存根的任何其他行为。<br>例如，对于空堆栈，您可以创建一个只为 empty（）方法返回 true 的存根。因此，<br>这并不关心堆栈中是否存在元素。<br>嘲笑<br> 一个虚拟对象，其中最初设置了某些属性。<br> 此对象的行为取决于 set 属性。<br> 也可以测试对象的行为。<br>例如，对于 Customer 对象，您可以通过设置名称和年龄来模拟它。您可以将 age<br>设置为 12，然后测试 isAdult（）方法，该方法将在年龄大于 18 时返回 true。因<br>此，您的 Mock Customer 对象适用于指定的条件。<br>43、您对 Mike Cohn 的测试金字塔了解多少？<br>Mike Cohn 提供了一个名为 Test Pyramid 的模型。这描述了软件开发所需的自<br>动化测试类型。<br>图 16： Mike Cohn 的测试金字塔 – 微服务面试问题<br>根据金字塔，第一层的测试数量应该最高。在服务层，测试次数应小于单元测试<br>级别，但应大于端到端级别。<br>44、Docker 的目的是什么？<br>Docker 提供了一个可用于托管任何应用程序的容器环境。在此，软件应用程序和<br>支持它的依赖项紧密打包在一起。<br>因此，这个打包的产品被称为 Container，因为它是由 Docker 完成的，所以它<br>被称为 Docker 容器！<br>45、什么是金丝雀释放？<br>Canary Releasing 是一种降低在生产中引入新软件版本的风险的技术。这是通过<br>将变更缓慢地推广到一小部分用户，然后将其发布到整个基础架构，即将其提供<br>给每个人来完成的。<br>46、什么是持续集成（CI）？<br>持续集成（CI）是每次团队成员提交版本控制更改时自动构建和测试代码的过程。<br>这鼓励开发人员通过在每个小任务完成后将更改合并到共享版本控制存储库来共<br>享代码和单元测试。<br>47、什么是持续监测？<br>持续监控深入监控覆盖范围，从浏览器内前端性能指标，到应用程序性能，再到<br>主机虚拟化基础架构指标。<br>48、架构师在微服务架构中的角色是什么？<br>微服务架构中的架构师扮演以下角色：<br> 决定整个软件系统的布局。<br> 帮助确定组件的分区。因此，他们确保组件相互粘合，但不紧密耦合。<br> 与开发人员共同编写代码，了解日常生活中面临的挑战。<br> 为开发微服务的团队提供某些工具和技术的建议。<br> 提供技术治理，以便技术开发团队遵循微服务原则。<br>49、我们可以用微服务创建状态机吗？<br>我们知道拥有自己的数据库的每个微服务都是一个可独立部署的程序单元，这反<br>过来又让我们可以创建一个状态机。因此，我们可以为特定的微服务指定不同的<br>状态和事件。<br>例如，我们可以定义 Order 微服务。订单可以具有不同的状态。Order 状态的转<br>换可以是 Order 微服务中的独立事件。<br>50、什么是微服务中的反应性扩展？<br>Reactive Extensions 也称为 Rx。这是一种设计方法，我们通过调用多个服务来<br>收集结果，然后编译组合响应。这些调用可以是同步或异步，阻塞或非阻塞。Rx<br>是分布式系统中非常流行的工具，与传统流程相反。<br>希望 这些 微服 务面 试问 题可 以帮 助您 进行 微服 务架 构师 访谈 。<br>翻译来源：<br>w-questions&#x2F;<br>Linux 面试题<br>1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？<br>主目录用什么表示? 切换目录用什么命令？<br>答案：<br>绝对路径： 如&#x2F;etc&#x2F;init.d<br>当前目录和上层目录： .&#x2F; ..&#x2F;<br>主目录： ~&#x2F;<br>切换目录： cd<br>2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？<br>答案：<br>查看当前进程： ps<br>执行退出： exit<br>查看当前路径： pwd<br>3、怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当<br>前用户 id？查看指定帮助用什么命令？<br>答案：<br>清屏： clear<br>退出当前命令： ctrl+c 彻底退出<br>执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台<br>查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组<br>及用户名<br>查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser –help 这<br>个告诉你一些常用参数； info adduesr；<br>4、Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？<br>答案：<br>ls 执行的功能： 列出指定目录中的目录，以及文件<br>哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行<br>的权限等<br>5、建立软链接(快捷方式)，以及硬链接的命令。<br>答案：<br>软链接： ln -s slink source<br>硬链接： ln link source<br>6、目录创建用什么命令？创建文件用什么命令？复制文件用什<br>么命令？<br>答案：<br>创建目录： mkdir<br>创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件<br>输出，都会创建文件<br>复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？<br>文件权限修改： chmod<br>格式如下：<br>chmodu+xfile 给 file 的属主增加执行权限 chmod 751 file 给 file 的属主分配<br>读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户<br>分配执行(1)的权限<br>chmodu&#x3D;rwx,g&#x3D;rx,o&#x3D;xfile 上例的另一种形式 chmod &#x3D;r file 为所有用户分配<br>读权限<br>chmod444file 同上例 chmod a-wx,a+r file 同上例<br><code>$chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属 主分配读的权限 7、查看文件内容有哪些命令可以使用？ 答案： vi 文件名 #编辑方式查看，可修改 cat 文件名 #显示全部文件内容 more 文件名 #分页显示文件内容 less 文件名 #与 more 相似，更好的是可以往前翻页 tail 文件名 #仅查看尾部，还可以指定行数 head 文件名 #仅查看头部,还可以指定行数 8、随意写文件命令？怎么向屏幕输出带空格的字符串，比如” hello world”? 答案： 写文件命令：vi 向屏幕输出带空格的字符串:echo hello world 9、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下 的哪个命令？ 答案： 终端 /dev/tty 黑洞文件 /dev/null 10、移动文件用哪个命令？改名用哪个命令？ 答案： mv mv 11、复制文件用哪个命令？如果需要连同文件夹一块复制呢？ 如果需要有提示功能呢？ 答案： cp cp -r ？？？？ 12、删除文件用哪个命令？如果需要连目录及目录下文件一块 删除呢？删除空文件夹用什么命令？ 答案： rm rm -r rmdir 13、Linux 下命令有哪几种可使用的通配符？分别代表什么含 义? 答案： “？”可替代单个字符。 “*”可替代任意多个字符。 方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC] 14、用什么命令对一个文件的内容进行统计？(行号、单词数、 字节数) 答案： wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。 15、Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含 该串的行? 答案： 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印 出来。 grep [stringSTRING] filename grep [^string] filename 16、Linux 中进程有哪几种状态？在 ps 显示出来的信息中， 分别用什么符号表示的？ 答案： 1、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。 2、暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而 进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个 特殊的状态。 正被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。 3、就绪状态：在 run_queue 队列里的状态 4、运行状态：在 run_queue 队列里的状态 5、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起 6、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程 的尸体（task_struct）也释放掉 7、退出状态 D 不可中断 Uninterruptible（usually IO） R 正在运行，或在队列中的进程 S 处于休眠状态 T 停止或被追踪 Z 僵尸进程 W 进入内存交换（从内核 2.6 开始无效） X 死掉的进程 17、怎么使一个命令在后台运行? 答案： 一般都是使用 &amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格) 18、利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进 程的信息？ 答案： ps -ef (system v 输出) ps -aux bsd 格式输出 ps -ef | grep pid 19、哪个命令专门用来查看后台任务? 答案： job -l 20、把后台任务调到前台执行使用什么命令?把停下的后台任务 在后台执行起来用什么命令? 答案： 把后台任务调到前台执行 fg 把停下的后台任务在后台执行起来 bg 21、终止进程用什么命令? 带什么参数? 答案： kill [-s &amp;lt;信息名称或编号&amp;gt;][程序] 或 kill [-l &amp;lt;信息编号&amp;gt;] kill-9 pid 22、怎么查看系统支持的所有信号？ 答案： kill -l 23、搜索文件用什么命令? 格式是怎么样的? 答案： find &amp;lt;指定目录&amp;gt; &amp;lt;指定条件&amp;gt; &amp;lt;指定动作&amp;gt; whereis 加参数与文件名 locate 只加文件名 find 直接搜索磁盘，较慢。 find / -name &quot;string*&quot; 24、查看当前谁在使用该主机用什么命令? 查找自己所在的终 端信息用什么命令? 答案： 查找自己所在的终端信息：who am i 查看当前谁在使用该主机：who 25、使用什么命令查看用过的命令列表? 答案： history 26、使用什么命令查看磁盘使用空间？ 空闲空间呢? 答案： df -hl 文件系统 容量 已用 可用 已用% 挂载点 Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% / /dev/hda1 494M 19M 450M 4% /boot 27、使用什么命令查看网络是否连通? 答案： netstat 28、使用什么命令查看 ip 地址及接口信息？ 答案： ifconfig 29、查看各类环境变量用什么命令? 答案： 查看所有 env 查看某个，如 home： env$</code>HOME<br>30、通过什么命令指定命令提示符?<br>答案：<br> \u：显示当前用户账号<br> \h：显示当前主机名<br> \W：只显示当前路径最后一个目录<br> \w：显示当前绝对路径（当前用户目录会以~代替）<br> <code>$PWD：显示当前全路径  $</code>：显示命令行’<code>$&#39;或者’#&#39;符号  #：下达的第几个命令  \d：代表日期，格式为 week day month date，例如：&quot;MonAug1&quot;  \t：显示时间为 24 小时格式，如：HH：MM：SS  \T：显示时间为 12 小时格式  \A：显示时间为 24 小时格式：HH：MM  \v：BASH 的版本信息 如 export PS1=’[\u@\h\w#]$</code>‘<br>31、查找命令的可执行文件是去哪查找的? 怎么对其进行设置<br>及添加?<br>答案：<br>whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…]<br>补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性<br>应属于原始代码，二进制文件，或是帮助文件。<br> -b 只查找二进制文件。<br> -B &lt;目录&gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的<br>路径名称。<br> -m 只查找说明文件。<br> -M &lt;目录&gt; 只在设置的目录下查找说明文件。-s 只查找原始代码文件。<br> -S &lt;目录&gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定<br>类型的文件。<br>w -h ich 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且<br>返回第一个搜索结果。<br> -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件<br>名。<br> -p 与-n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位<br>的宽度。<br> -V 显示版本信息<br>32、通过什么命令查找执行命令?<br>答案：<br>which 只能查可执行文件<br>whereis 只能查二进制文件、说明文档，源文件等<br>33、怎么对命令进行取别名？<br>答案：<br>alias la&#x3D;’ls -a’<br>34、du 和 df 的定义，以及区别？<br>答案：<br>du 显示目录或文件的大小<br>df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。<br>（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘<br>分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，<br>通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df<br>命令则查看文件系统的磁盘分配图并考虑 Meta Data。<br>df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。<br>35、awk 详解。<br>答案：<br>awk ‘{pattern + action}’ {filenames}<br>#cat &#x2F;etc&#x2F;passwd |awk -F ‘:’ ‘{print 1”\t”7}’ &#x2F;&#x2F;-F 的意思是以’:’分隔 root<br>&#x2F;bin&#x2F;bash<br>daemon &#x2F;bin&#x2F;sh 搜索&#x2F;etc&#x2F;passwd 有 root 关键字的所有行<br>#awk -F: ‘&#x2F;root&#x2F;‘ &#x2F;etc&#x2F;passwd root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<br>36、当你需要给命令绑定一个宏或者按键的时候，应该怎么做<br>呢？<br>答案：<br>可以使用 bind 命令，bind 可以很方便地在 shell 中实现宏或按键的绑定。<br>在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。<br>比如获取 F12 的字符序列获取方法如下：先按下 Ctrl+V,然后按下 F12 .我们就可<br>以得到 F12 的字符序列 ^[[24<del>。<br>接着使用 bind 进行绑定。<br>[root@localhost ~]# bind ‘”\e[24</del>“:”date”‘<br>注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。<br>【附】也可以使用 showkey -a 命令查看按键对应的字符序列。<br>37、如果一个 linux 新手想要知道当前系统支持的所有命令的<br>列表，他需要怎么做？<br>答案：<br>使用命令 compgen -c，可以打印出所有支持的命令列表。<br>[root@localhost ~]$ compgen -c<br>l.<br>ll<br>ls<br>which<br>if<br>then<br>else<br>elif<br>fi<br>case<br>esac<br>for<br>select<br>while<br>until<br>do<br>done<br>…<br>38、如果你的助手想要打印出当前的目录栈，你会建议他怎么<br>做？<br>答案：<br>使用 Linux 命令 dirs 可以将当前的目录栈打印出来。<br>[root@localhost ~]# dirs<br>&#x2F;usr&#x2F;share&#x2F;X11<br>【附】：目录栈通过 pushd popd 来操作。<br>39、你的系统目前有许多正在运行的任务，在不重启机器的条<br>件下，有什么方法可以把所有正在运行的进程移除呢？<br>答案：<br>使用 linux 命令 ’disown -r ’可以将所有正在运行的进程移除。<br>40、bash shell 中的 hash 命令有什么作用？<br>答案：<br>linux 命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径,<br>用该命令可以打印出你所使用过的命令以及执行的次数。<br>[root@localhost ~]# hash<br>hits command<br>2 &#x2F;bin&#x2F;ls<br>2 &#x2F;bin&#x2F;su<br>41、哪一个 bash 内置命令能够进行数学运算。<br>答案：<br>bash shell 的内置命令 let 可以进行整型数的数学运算。<br>#! &#x2F;bin&#x2F;bash<br>…<br>…<br>let c&#x3D;a+b<br>…<br>…<br>42、怎样一页一页地查看一个大文件的内容呢？<br>答案：<br>通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个<br>需要.<br>[root@localhost ~]# cat file_name.txt | more<br>43、数据字典属于哪一个用户的？<br>答案：<br>数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动<br>创建的<br>44、怎样查看一个 linux 命令的概要与用法？假设你在&#x2F;bin 目<br>录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用<br>和用法呢？<br>答案：<br>使用命令 whatis 可以先出显示出这个命令的用法简要，比如，你可以使用 whatis<br>zcat 去查看‘zcat’的介绍以及使用简要。<br>[root@localhost ~]# whatis zcat<br>zcat [gzip] (1) – compress or expand files<br>45、使用哪一个命令可以查看自己文件系统的磁盘空间配额<br>呢？<br>答案：<br>使用命令 repquota 能够显示出一个文件系统的配额信息<br>【附】只有 root 用户才能够查看其它用户的配额。<br>Spring Boot 面试题<br>1、什么是 Spring Boot？<br>多年来，随着新功能的增加，spring 变得越来越复杂。只需访问<br>所有 Spring 项目的不同功能。如果必须启动一个新的 Spring 项目，我们必须添<br>加构建路径或添加 Maven 依赖关系，配置应用程序服务器，添加 spring 配置。<br>因此，开始一个新的 spring 项目需要很多努力，因为我们现在必须从头开始做所<br>有事情。<br>Spring Boot 是解决这个问题的方法。Spring Boot 已经建立在现有 spring 框架<br>之上。使用 spring 启动，我们避免了之前我们必须做的所有样板代码和配置。因<br>此，Spring Boot 可以帮助我们以最少的工作量，更加健壮地使用现有的 Spring<br>功能。<br>2、Spring Boot 有哪些优点？<br>Spring Boot 的优点有：<br>1、减少开发，测试时间和努力。<br>2、使用 JavaConfig 有助于避免使用 XML。<br>3、避免大量的 Maven 导入和各种版本冲突。<br>4、提供意见发展方法。<br>5、通过提供默认值快速开始开发。<br>6、没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish<br>或其他任何东西。<br>7、需要更少的配置 因为没有 web.xml 文件。只需添加用@ Configuration 注释<br>的类，然后添加用@Bean 注释的方法，Spring 将自动加载对象并像以前一样对其<br>进行管理。您甚至可以将@Autowired 添加到 bean 方法中，以使 Spring 自动装<br>入需要的依赖关系中。<br>8、基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：<br>-Dspring.profiles.active &#x3D; {enviornment}。在加载主应用程序属性文件后，<br>Spring 将在（application{environment} .properties）中加载后续的应用程序属<br>性文件。<br>3、什么是 JavaConfig？<br>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯<br>Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：<br>1、面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分<br>利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方<br>法等。<br>2、减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，<br>许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供<br>了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，<br>只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将<br>JavaConfig 与 XML 混合匹配是理想的。<br>3、类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring<br>容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不<br>需要任何强制转换或基于字符串的查找。<br>4、如何重新加载 Spring Boot 上的更改，而无需重新启动服务<br>器？<br>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式<br>tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于<br>提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部<br>署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，<br>而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布<br>它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完<br>全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制<br>台以更好地测试应用程序。<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;<br>&lt;optional&gt;true&lt;&#x2F;optional&gt;<br>5、Spring Boot 中的监视器是什么？<br>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视<br>器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在<br>生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向<br>相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的<br>REST 端点来检查状态。<br>6、如何在 Spring Boot 中禁用 Actuator 端点安全性？<br>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用<br>户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实<br>施的。 我们可以使用<br>来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。<br>7、如何在自定义端口上运行 Spring Boot 应用程序？<br>为了在自定义端口上运行 Spring Boot 应用程序，您可以在<br>application.properties 中指定端口。<br>server.port &#x3D; 8090<br>8、什么是 YAML？<br>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。<br>与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加<br>结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。<br>9、如何实现 Spring Boot 应用程序的安全性？<br>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖<br>项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展<br>WebSecurityConfigurerAdapter 并覆盖其方法。<br>10、如何集成 Spring Boot 和 ActiveMQ？<br>对于集成 Spring Boot 和 ActiveMQ，我们使用<br>依赖关系。 它只需要很少的配置，并且不需要样板代码。<br>11、如何使用 Spring Boot 实现分页和排序？<br>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页<br>的<br>传递给存储库方法。<br>12、什么是 Swagger？你用 Spring Boot 实现了它吗？<br>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。<br>Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实<br>现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消<br>费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger<br>消除了调用服务时的猜测。<br>13、什么是 Spring Profiles？<br>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因<br>此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION<br>中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环<br>境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用<br>配置文件非常简单。<br>14、什么是 Spring Batch？<br>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包<br>括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。<br>它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量<br>和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式<br>利用框架处理重要大量的信息。<br>15、什么是 FreeMarker 模板？<br>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动<br>态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员<br>可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用<br>freemarker 可以将这些结合起来，给出最终的输出页面。<br>16、如何使用 Spring Boot 实现异常处理？<br>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通<br>过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。<br>17、您使用了哪些 starter maven 依赖项？<br>使用了下面的一些依赖项<br>spring-boot-starter-activemq<br>spring-boot-starter-security<br>这有助于增加更少的依赖关系，并减少版本的冲突。<br>18、什么是 CSRF 攻击？<br>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的<br>Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是<br>数据窃取，因为攻击者无法查看对伪造请求的响应。<br>19、什么是 WebSockets？<br>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。<br>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。<br>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。<br>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。<br>然后这个单一连接用于所有未来的通信<br>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。<br>20、什么是 AOP？<br>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题。这些交叉问题与<br>应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向方<br>面编程（AOP）的地方。<br>21、什么是 Apache Kafka？<br>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的<br>发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶<br>级项目。Kafka 适合离线和在线消息消费。<br>22、我们如何监视所有 Spring Boot 微服务？<br>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应<br>用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运<br>行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应<br>用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，<br>管理员将不得不击中所有 50 个应用程序的执行终端。<br>为了帮助我们处理这种情况，我们将使用位于<br>的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使<br>我们能够可视化多个应用程序的度量。<br>Spring Cloud 面试题<br>1、什么是 Spring Cloud？<br>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，<br>提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，<br>用于快速构建执行有限数据处理的应用程序。<br>2、使用 Spring Cloud 有什么优势？<br>使用 Spring Boot 开发分布式微服务时，我们面临以下问题<br>1、与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，<br>安全问题。<br>2、服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉<br>及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。<br>3、冗余-分布式系统中的冗余问题。<br>4、负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机<br>集群，网络链路，中央处理单元，或磁盘驱动器的分布。<br>5、性能-问题 由于各种运营开销导致的性能问题。<br>6、部署复杂性-Devops 技能的要求。<br>3、服务注册和发现是什么意思？Spring Cloud 如何实现？<br>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多<br>的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，<br>而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册<br>和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通<br>过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。<br>4、负载平衡的意义什么？<br>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元<br>或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最<br>大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负<br>载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉<br>及专用软件或硬件，例如多层交换机或域名系统服务器进程。<br>5、什么是 Hystrix？它如何实现容错？<br>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当<br>出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。<br>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。<br>思考以下微服务<br>假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。但<br>这仍然会导致整个系统崩溃。<br>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.<br>这是 hystrix 出现的地方 我们将使用 Hystrix 在这种情况下的 Fallback 方法功能。<br>我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。<br>简化图如下所示<br>现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这<br>种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服务相<br>同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。<br>6、什么是 Hystrix 断路器？我们需要它吗？<br>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用<br>Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回<br>一些默认值。<br>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工<br>使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第<br>一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发<br>生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。<br>7、什么是 Netflix Feign？它的优点是什么？<br>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。<br>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。<br>在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST<br>模板公开的 REST 服务。<br>但是我们必须编写大量代码才能执行以下步骤<br>1、使用功能区进行负载平衡。<br>2、获取服务实例，然后获取基本 URL。<br>3、利用 REST 模板来使用服务。 前面的代码如下</p><p>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如<br>何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关<br>系也在类路径中，那么 Feign 默认也会负责负载平衡。<br>8、什么是 Spring Cloud Bus？我们需要它吗？<br>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而<br>Spring Cloud Config 从 GIT 读取这些属性。<br>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注<br>册的财产。<br>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什<br>么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。<br>还有另一种使用执行器端点&#x2F;刷新的方式。但是我们将不得不为每个模块单独调用<br>这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：<br>&#x2F;&#x2F; localhost：8080 &#x2F; refresh。同样对于 Employee Producer2 http：&#x2F;&#x2F;<br>localhost：8081 &#x2F; refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥<br>作用的地方。<br>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，<br>如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果<br>我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个<br>消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微<br>服务，并且它们也会刷新。可以通过使用端点&#x2F;总线&#x2F;刷新来实现对任何单个实例的<br>刷新。<br>RabbitMQ 面试题<br>1、什么是 rabbitmq<br>采用 AMQP 高级消息队列协议的一种消息队列技术,最大的特点就是消费并不需<br>要确保提供方存在,实现了服务之间的高度解耦<br>2、为什么要使用 rabbitmq<br>1、在分布式系统下具备异步,削峰,负载均衡等一系列高级功能;<br>2、拥有持久化的机制，进程消息，队列中的信息也可以保存下来。<br>3、实现消费者和生产者之间的解耦。<br>4、对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量<br>的限流，利于数据库的操作。<br>5.可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。<br>3、使用 rabbitmq 的场景<br>1、服务间异步通信<br>2、顺序消费<br>3、定时任务<br>4、请求削峰<br>4、如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接<br>收方消费了消息？<br>发送方确认模式<br>将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都<br>会被指派一个唯一的 ID。<br>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信<br>道会发送一个确认给生产者（包含消息唯一 ID）。<br>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（not<br>acknowledged，未确认）消息。<br>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消<br>息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来<br>处理确认消息。<br>接收方确认机制<br>接收方消息确认机制<br>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操<br>作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。<br>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否<br>需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足<br>够长的时间来处理消息。保证数据的最终一致性；<br>下面罗列几种特殊情况<br>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为<br>消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消<br>费的隐患，需要去重）<br>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消<br>费者繁忙，将不会给该消费者分发更多的消息。<br>5.如何避免消息重复投递或重复消费？<br>在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id，作<br>为去重的依据（消息投递失败并重传），避免重复的消息进入队列；<br>在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支<br>付 ID、订单 ID、帖子 ID 等）作为去重的依据，避免同一条消息被重复消费。<br>6、消息基于什么传输？<br>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶<br>颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的<br>虚拟连接，且每条 TCP 连接上的信道数量没有限制。<br>7、消息如何分发？<br>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消<br>费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息<br>并进行确认）。<br>通过路由可实现多消费的功能<br>8、消息怎么路由？<br>消息提供方-&gt;路由-&gt;一至多个队列<br>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设<br>定。<br>通过队列路由键，可以把队列绑定到交换器上。<br>消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针<br>对不同的交换器有不同的路由规则）；<br>常用的交换器主要分为一下三种<br>fanout：如果交换器收到消息，将会广播到所有绑定的队列上<br>direct：如果路由键完全匹配，消息就被投递到相应的队列<br>topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，<br>可以使用通配符<br>9、如何确保消息不丢失？<br>消息持久化，当然前提是队列必须持久化<br>RabbitMQ 确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上<br>的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit 会在<br>消息提交到日志文件后才发送响应。<br>一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ 会在持久化日志中<br>把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前 RabbitMQ 重启，<br>那么 Rabbit 会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件<br>中的消息到合适的队列。<br>10、使用 RabbitMQ 有什么好处？<br>1、服务间高度解耦<br>2、异步通信性能高<br>3、流量削峰<br>11、RabbitMQ 的集群<br>镜像集群模式<br>你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，然后<br>每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息<br>同步。<br>好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第<br>一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很<br>重！第二，这么玩儿，就没有扩展性可言了，如果某个 queue 负载很重，你加机<br>器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue<br>12、mq 的缺点<br>系统可用性降低<br>系统引入的外部依赖越多，越容易挂掉，本来你就是 A 系统调用 BCD 三个系统的<br>接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一<br>MQ 挂了咋整？MQ 挂了，整套系统崩溃了，你不就完了么。<br>系统复杂性提高<br>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？<br>怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已<br>一致性问题<br>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要<br>是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？<br>你这数据就不一致了。<br>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对<br>它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈<br>呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还<br>是得用的<br>kafka 面试题<br>1、如何获取 topic 主题的列表<br>bin&#x2F;kafka-topics.sh –list –zookeeper localhost:2181<br>2、生产者和消费者的命令行是什么？<br>生产者在主题上发布消息：<br>bin&#x2F;kafka-console-producer.sh –broker-list 192.168.43.49:9092 –topic<br>Hello-Kafka<br>注意这里的 IP 是 server.properties 中的 listeners 的配置。接下来每个新行就是<br>输入一条新消息。<br>消费者接受消息：<br>bin&#x2F;kafka-console-consumer.sh –zookeeper localhost:2181 –topic<br>Hello-Kafka –from-beginning<br>3、consumer 是推还是拉？<br>Kafka 最初考虑的问题是，customer 应该从 brokes 拉取消息还是 brokers 将消<br>息推送到 consumer，也就是 pull 还 push。在这方面，Kafka 遵循了一种大部分<br>消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从<br>broker 拉取消息。<br>一些消息系统比如 Scribe 和 Apache Flume 采用了 push 模式，将消息推送到下<br>游的 consumer。这样做有好处也有坏处：由 broker 决定消息推送的速率，对于<br>不同消费速率的 consumer 就不太好处理了。消息系统都致力于让 consumer 以<br>最大的速率最快速的消费消息，但不幸的是，push 模式下，当 broker 推送的速<br>率远大于 consumer 消费的速率时，consumer 恐怕就要崩溃了。最终 Kafka 还<br>是选取了传统的 pull 模式。<br>Pull 模式的另外一个好处是 consumer 可以自主决定是否批量的从 broker 拉取数<br>据。Push 模式必须在不知道下游 consumer 消费能力和消费策略的情况下决定是<br>立即推送每条消息还是缓存之后批量推送。如果为了避免 consumer 崩溃而采用<br>较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull 模式下，<br>consumer 就可以根据自己的消费能力去决定这些策略。<br>Pull 有个缺点是，如果 broker 没有可供消费的消息，将导致 consumer 不断在循<br>环中轮询，直到新消息到 t 达。为了避免这点，Kafka 有个参数可以让 consumer<br>阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可<br>以批量发送)。<br>4、讲讲 kafka 维护消费状态跟踪的方法<br>大部分消息系统在 broker 端的维护消息被消费的记录：一个消息被分发到<br>consumer 后 broker 就马上进行标记或者等待 customer 的通知后进行标记。这<br>样也可以在消息在消费后立马就删除以减少空间占用。<br>但是这样会不会有什么问题呢？如果一条消息发送出去之后就立即被标记为消费<br>过的，一旦 consumer 处理消息时失败了（比如程序崩溃）消息就丢失了。为了<br>解决这个问题，很多消息系统提供了另外一个个功能：当消息被发送出去之后仅<br>仅被标记为已发送状态，当接到 consumer 已经消费成功的通知后才标记为已被<br>消费的状态。这虽然解决了消息丢失的问题，但产生了新问题，首先如果 consumer<br>处理消息成功了但是向 broker 发送响应时失败了，这条消息将被消费两次。第二<br>个问题时，broker 必须维护每条消息的状态，并且每次都要先锁住消息然后更改<br>状态然后释放锁。这样麻烦又来了，且不说要维护大量的状态数据，比如如果消<br>息发送出去但没有收到消费成功的通知，这条消息将一直处于被锁定的状态，<br>Kafka 采用了不同的策略。Topic 被分成了若干分区，每个分区在同一时间只被一<br>个 consumer 消费。这意味着每个分区被消费的消息在日志中的位置仅仅是一个<br>简单的整数：offset。这样就很容易标记每个分区消费状态就很容易了，仅仅需要<br>一个整数而已。这样消费状态的跟踪就很简单了。<br>这带来了另外一个好处：consumer 可以把 offset 调成一个较老的值，去重新消<br>费老的消息。这对传统的消息系统来说看起来有些不可思议，但确实是非常有用<br>的，谁规定了一条消息只能被消费一次呢？<br>5、讲一下主从同步**<br>6、为什么需要消息系统，mysql 不能满足需求吗？<br>1.解耦：<br>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。<br>2.冗余：<br>消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据<br>丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队<br>列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保<br>你的数据被安全的保存直到你使用完毕。<br>3.扩展性：<br>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，<br>只要另外增加处理过程即可。<br>4.灵活性 &amp; 峰值处理能力：<br>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不<br>常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪<br>费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负<br>荷的请求而完全崩溃。<br>5.可恢复性：<br>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合<br>度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复<br>后被处理。<br>6.顺序保证：<br>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，<br>并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消<br>息的有序性）<br>7.缓冲：<br>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度<br>不一致的情况。<br>8.异步通信：<br>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允<br>许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放<br>多少，然后在需要的时候再去处理它们。<br>7、Zookeeper 对于 Kafka 的作用是什么？<br>Zookeeper 是一个开放源码的、高性能的协调服务，它用于 Kafka 的分布式应用。<br>Zookeeper 主要用于在集群中不同节点之间进行通信<br>在 Kafka 中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都<br>可以从之前提交的偏移量中获取<br>除此之外，它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新<br>节点何时离开或连接、集群、节点实时状态等等。<br>8、数据传输的事务定义有哪三种？<br>和 MQTT 的事务定义一样都是 3 种。<br>（1）最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输<br>（2）最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.<br>（3）精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输<br>被一次而且仅仅被传输一次，这是大家所期望的<br>9、Kafka 判断一个节点是否还活着有那两个条件？<br>（1）节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每<br>个节点的连接<br>（2）如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太<br>久<br>10、Kafka 与传统 MQ 消息系统之间有三个关键区别<br>(1).Kafka 持久化日志，这些日志可以被重复读取和无限期保留<br>(2).Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过<br>复制数据提升容错能力和高可用性<br>(3).Kafka 支持实时的流式处理<br>11、讲一讲 kafka 的 ack 的三种机制<br>request.required.acks 有三个值 0 1 -1(all)<br>0:生产者不会等待 broker 的 ack，这个延迟最低但是存储的保证最弱当 server 挂<br>掉的时候就会丢数据。<br>1：服务端会等待 ack 值 leader 副本确认接收到消息后发送 ack 但是如果 leader<br>挂掉后他不确保是否复制完成新 leader 也会导致数据丢失。<br>-1(all)：服务端会等所有的 follower 的副本受到数据后才会受到 leader 发出的<br>ack，这样数据不会丢失<br>12、消费者如何不自动提交偏移量，由应用提交？<br>将 auto.commit.offset 设为 false，然后在处理一批消息后 commitSync() 或者<br>异步提交 commitAsync()<br>即：<br>ConsumerRecords&lt;&gt; records &#x3D; consumer.poll();<br>for (ConsumerRecord&lt;&gt; record : records){<br>。。。<br>tyr{<br>consumer.commitSync()<br>}<br>。。。<br>}<br>13、消费者故障，出现活锁问题如何解决？<br>出现“活锁”的情况，是它持续的发送心跳，但是没有处理。为了预防消费者在<br>这种情况下一直持有分区，我们使用 max.poll.interval.ms 活跃检测机制。 在此<br>基础上，如果你调用的 poll 的频率大于最大间隔，则客户端将主动地离开组，以<br>便其他消费者接管该分区。 发生这种情况时，你会看到 offset 提交失败（调用<br>commitSync（）引发的 CommitFailedException）。这是一种安全机制，保障<br>只有活动成员能够提交 offset。所以要留在组中，你必须持续调用 poll。<br>消费者提供两个配置设置来控制 poll 循环：<br>max.poll.interval.ms：增大 poll 的间隔，可以为消费者提供更多的时间去处理返<br>回的消息（调用 poll(long)返回的消息，通常返回的消息都是一批）。缺点是此值<br>越大将会延迟组重新平衡。<br>max.poll.records：此设置限制每次调用 poll 返回的消息数，这样可以更容易的<br>预测每次 poll 间隔要处理的最大值。通过调整此值，可以减少 poll 间隔，减少重<br>新平衡分组的<br>对于消息处理时间不可预测地的情况，这些选项是不够的。 处理这种情况的推荐<br>方法是将消息处理移到另一个线程中，让消费者继续调用 poll。 但是必须注意确<br>保已提交的 offset 不超过实际位置。另外，你必须禁用自动提交，并只有在线程<br>完成处理后才为记录手动提交偏移量（取决于你）。 还要注意，你需要 pause 暂<br>停分区，不会从 poll 接收到新消息，让线程处理完之前返回的消息（如果你的处<br>理能力比拉取消息的慢，那创建新线程将导致你机器内存溢出）。<br>14、如何控制消费的位置<br>kafka 使用 seek(TopicPartition, long)指定新的消费位置。用于查找服务器保留<br>的最早和最新的 offset 的特殊的方法也可用（seekToBeginning(Collection) 和<br>seekToEnd(Collection)）<br>15、kafka 分布式（不是单机）的情况下，如何保证消息的顺<br>序消费?<br>Kafka 分布式的单位是 partition，同一个 partition 用一个 write ahead log 组织，<br>所以可以保证 FIFO 的顺序。不同 partition 之间不能保证顺序。但是绝大多数用<br>户都可以通过 message key 来定义，因为同一个 key 的 message 可以保证只发<br>送到同一个 partition。<br>Kafka 中发送 1 条消息的时候，可以指定(topic, partition, key) 3 个参数。<br>partiton 和 key 是可选的。如果你指定了 partition，那就是所有消息发往同 1<br>个 partition，就是有序的。并且在消费端，Kafka 保证，1 个 partition 只能被<br>1 个 consumer 消费。或者你指定 key（比如 order id），具有同 1 个 key 的<br>所有消息，会发往同 1 个 partition。<br>16、kafka 的高可用机制是什么？<br>这个问题比较系统，回答出 kafka 的系统特点，leader 和 follower 的关系，消息<br>读写的顺序即可。</p><p>17、kafka 如何减少数据丢失<br>18、kafka 如何不消费重复数据？比如扣款，我们不能重复的<br>扣。<br>其实还是得结合业务来思考，我这里给几个思路：<br>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入<br>了，update 一下好吧。<br>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。<br>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据<br>的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费<br>到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消<br>费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保<br>证别重复处理相同的消息即可。<br>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束<br>了，重复数据插入只会报错，不会导致数据库中出现脏数据。<br>互联网 Java 工程师面试题<br>内容涵盖：Java、MyBatis、ZooKeeper、Dubbo、Elasticsearch、Memcached、<br>Redis、MySQL、Spring、Spring Boot、Spring Cloud、RabbitMQ、Kafka、<br>Linux 等技术栈<br>6、虚拟机jVM编译class类的原理？<br>JVM可以称为软件模拟的计算机，它可以在任何处理器安全地兼容并且执行.class字节码。其实 JVM兼容的二进制字节码和操作系统的本地机器码有一定的区别，只是针对 JVM上层的调用程序而言，执行过程效果一样，所以我们一般理解就是说直接用JVM来执行二进制码，实际上二者本质 有一定的差异，但是这一点可以理解JVM具有跨平台性。一般情况下，编程人员都是直接编写.java的 源文件，然后用Java编译器（javac命 令）对源文件进行编译，生成.class文件，生成的.class文件就是我们平时所说的包含了“机 器码”的文件，实际上JVM在编译和运行过程做了两件事，先是直接将源文件编译成二进制字节码.class文件，然后进行第二次处理：解释 器负责将这些二进制字节码根据本地操作系统宿主环境生成相应的本地机器码解释执行。所以可以理解的一点是为什么Java语言具有跨平台性， 因为JVM提供了Java运行的一个中间层，使得操作系统和上层应用相互之间是依靠JVM中间层进行通信的，也就是说Java编写的程序是运行在JVM上 的；再者尽管Java确实可以做到“一次编译，多处运行”，但是在不同结构的操作系统平台生成的.class文件真正在执行的时候是存在一定差异的，只是 JVM本身会根据安装的不同版本进行不同的操作系统平台下本地机器码的生成及运行，所以虽然我们在Sun公司官方网站可以下载到很多不同操作系统版本的 JDK，但是执行效果一样。而且还有一点，这一步操作针对开发人员是透明的，所以真正在开发过程可以放心的是不需要去担心这种问题，只要下载的版本是和符 合我们运行的操作系统的，只管进行普通编程的编译、解释运行操作就可以了。　　Java语言既是编译型语言，也是解释型语言，在.class文件生成之前，JVM通过javac命令对源代码进行编译操作， 然后用JVM根据包含了二进制码的.class生成机器码并且解释执行。所以Java程序的跨平台特性主要是指字节码文件可以在任何具有Java虚拟机的计算机或者电 子设备上运行，Java虚拟机中的Java解释器负责将字节码文件解释成为特定的机器码进行运行。Java虚拟机的建立需要针对不同的软硬件平台来实现， 既要考虑处理器的型号，也要考虑操作系统的种类。由此在SPARC结构、X86结构、MIPS和PPC等嵌入式处理芯片上，在UNIX、Linux、 Windows和部分实时操作系统上都可实现Java虚拟机，这也是为了在运行过程生成本地机器码而考虑的，使得JVM可以兼容不同的软硬件平台。7、Servlet怎么实现单一线程？原理？<br>&lt;%@ page isThreadSafe&#x3D;”true|false” %&gt;<br>默认值为trueisThreadSafe&#x3D;false模式表示它是以Singleton模式运行。<br>该模式implements了接口SingleThreadMode,<br>该模式同一时刻只有一个实例，不会出现信息同步与否的概念。<br>若多个用户同时访问一个这种模式的页面，<br>那么先访问者完全执行完该页面后，后访问者才开始执行。<br>10、怎么用SqlServer数据库实现无限量数据的存储，原理是什么?<br>将SQL数据库设为文件自动增长是为了简化系统管理，当磁盘上有剩余空间，数据库总能装下新输入的数据。数据库文件自动增长只发生在当现有剩余空间不足以装新输入数据时才增长，对数据库的只读访问无论多少次都不使数据库增长，新增&#x2F;修改数据时也只有在剩余空间不足时才增大文件；而删除数据时，释放的空间满足一定条件时这部分空间可以被重新使用。由于增长文件大小需要消耗大量系统资源，数据库管理系统总是尽可能减少增长文件的操作。其增长方式通常有按百分比增长，假如文件初始大小是100MB，百分比是10%，那么下次自动增长时，文件大小将变为110MB，即增加原大小的10%，再发生增长时，文件大小变为121MB；另一种常用的方式是固定大小增长，假如文件初始大小是100MB，每次增加10MB，则下次自动增长时，文件大小将变为110MB，再发生增长时，文件大小变为120MB.<br>3.类型转换Java语言是一种强类型的语言。强类型的语言有以下几个要求：<br>l 变量或常量必须有类型<br>要求声明变量或常量时必须声明类型，而且只能在声明以后才能使用。<br>l 赋值时类型必须一致<br>值的类型必须和变量或常量的类型完全一致。<br>l 运算时类型必须一致<br>参与运算的数据类型必须一致才能运算。<br>但是在实际的使用中，经常需要在不同类型的值之间进行操作，这就需要一种新的语法来适应这种需要，这个语法就是数据类型转换。<br>在数值处理这部分，计算机和现实的逻辑不太一样，对于现实来说，1和1.0没有什么区别，但是对于计算机来说，1是整数类型，而1.0是小数类型，其在内存中的存储方式以及占用的空间都不一样，所以类型转换在计算机内部是必须的。Java语言中的数据类型转换有两种：<br>l 自动类型转换<br>编译器自动完成类型转换，不需要在程序中编写代码。<br>l 强制类型转换<br>强制编译器进行类型转换，必须在程序中编写代码。<br>由于基本数据类型中boolean类型不是数字型，所以基本数据类型的转换是出了boolean类型以外的其它7种类型之间的转换。下面来具体介绍两种类型转换的规则、适用场合以及使用时需要注意的问题。<br>3.7.1 自动类型转换<br>自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以Java语言在设计时，没有为该操作设计语法，而是由JVM自动完成。<br>l 转换规则<br>从存储范围小的类型到存储范围大的类型。<br>具体规则为：<br>byte→short(char)→int→long→float→double<br>也就是说byte类型的变量可以自动转换为short类型，示例代码：<br>byte b &#x3D; 10;<br>short sh &#x3D; b;<br>这里在赋值时，JVM首先将b的值转换为short类型，然后再赋值给sh。<br>在类型转换时可以跳跃。示例代码：<br>byte b1 &#x3D; 100;<br>int n &#x3D; b1;<br>l 注意问题<br>在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。<br>3.7.2 强制类型转换<br>强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。<br>l 转换规则<br>从存储范围大的类型到存储范围小的类型。<br>具体规则为：<br>double→float→long→int→short(char)→byte<br>语法格式为：<br>(转换到的类型)需要转换的值<br>示例代码：<br>double d &#x3D; 3.10;<br>int n &#x3D; (int)d;<br>这里将double类型的变量d强制转换成int类型，然后赋值给变量n。需要说明的是小数强制转换为整数，采用的是“去1法”，也就是无条件的舍弃小数点的所有数字，则以上转换出的结果是3。整数强制转换为整数时取数字的低位，例如int类型的变量转换为byte类型时，则只去int类型的低8位(也就是最后一个字节)的值。<br>示例代码：<br>int n &#x3D; 123;<br>byte b &#x3D; (byte)n;<br>int m &#x3D; 1234;<br>byte b1 &#x3D; (byte)m;<br>则b的值还是123，而b1的值为-46。b1的计算方法如下：m的值转换为二进制是10011010010，取该数字低8位的值作为b1的值，则b1的二进制值是11010010，按照机器数的规定，最高位是符号位，1代表负数，在计算机中负数存储的是补码，则该负数的原码是10101110，该值就是十进制的-46。4.修饰符的作用域<br>1、类的修饰符分为：可访问控制符和非访问控制符两种。可访问控制符是：公共类修饰符 public非访问控制符有：抽象类修饰符 abstract ；最终类修饰符 final1 ）公共类修饰符 public ： Java 语言中类的可访问控制符只有一个： public 即公共的。每个 Java 程序的主类都必须是 public 类作为公共工具供其它类和程序使用的应定义为 public 类。2 ）抽象类修饰符 abstract ：凡是用 abstract 修饰符修饰的类，被称为抽象类。所谓抽象类是指这种类没有具体对象的一种概念类。这样的类就是 Java 语言的 abstract 类。3 ） 最终类修饰符 final ：当一个类不可能有子类时可用修饰符 final 把它说明为最终类。被定义为 final 的类通常是一些有固定作用、用来完成某种标准功能的类。4 ）类缺省访问控制符：如果一个类没有访问控制符，说明它具有缺省的访问控制符特性。此时，这个类只能被同一个包中的类访问或引用。这一访问特性又称为包访问性。2 ．域的控制修饰符也分为：可访问控制符和非访问控制符两类。可访问控制符有 4 种：公共访问控制符： public ；私有访问控制符： private ；保护访问控制符： protected ；私有保护访问控制符： private protected非访问控制符有 4 种：静态域修饰符： static ；最终域修饰符： final ；易失 ( 共享 ) 域修饰符： volatile ；暂时性域修饰符： transient1 ）公共访问控制符 public ：用 public 修饰的域称为公共域。如果公共域属于一个公共类，则可以被所有其它类所引用。由于 public 修饰符会降低运行的安全性和数据的封装性，所以一般应减少 public 域的使用。2 ）私有访问控制符 private ： 用 private 修饰的成员变量 ( 域 ) 只能被该类自身所访问，而不能被任何其它类 ( 包括子类 ) 所引用。3 ）保护访问控制符 protected ：用 protected 修饰的成员变量可以被三种类所引用：①该类自身；②与它在同一个包中的其它类；③在其它包中的该类的子类。使用修饰符 protected 的主要作用是允许其它包中它的子类来访问父类的特定属性。4 ）私有保护访问控制符 private protected ：用修饰符 private protected 修饰的成员变量可以被该类本身或该类的子类两种类访问和引用。5 ）静态域修饰符 static ：用 static 修饰的成员变量仅属于类的变量，而不属于任何一个具体的对象，静态成员变量的值是保存在类的内存区域的公共存储单元，而不是保存在某一个对象的内存区间。任何一个类的对象访问它时取到的都是相同的数据；任何一个类的对象修改它时 , 也都是对同一个内存单元进行操作。6 ）最终域修饰符 final ：最终域修饰符 final 是用来定义符号常量的。一个类的域 ( 成员变量 ) 如果被修饰符 final 说明，则它的取值在程序的整个执行过程中都是不变的。7 ）易失 ( 共享 ) 域修饰符 volatile ：易失 ( 共享 ) 域修饰符 volatile 是用来说明这个成员变量可能被几个线程所控制和修改。也就是说在程序运行过程中，这个成员变量有可能被其它的程序影响或改变它的取值。因此，在使用中要注意这种成员变量取值的变化。通常 volatile 用来修饰接受外部输入的域。8 ）暂时性域修饰符 transient ：暂时性域修饰符 transient 用来定义一个暂时性变量。其特点是：用修饰符 transient 限定的暂时性变量，将指定 Java 虚拟机认定该暂时性变量不属于永久状态，以实现不同对象的存档功能。否则，类中所有变量都是对象的永久状态的一部分，存储对象时必须同时保存这些变量。3 ．方法的控制修饰符也分为：可访问控制符和非访问控制符两类。可访问控制符有 4 种：公共访问控制符： public ；私有访问控制符： private ；保护访问控制符： protected ；私有保护访问控制符： private protected非访问控制符有 5 种：抽象方法控制符： abstract ；静态方法控制符： static ；最终方法控制符： final ；本地方法控制符： native ；同步方法控制符： synchronized1 ）抽象方法控制符 abstract ：用修饰符 abstract 修饰的方法称为抽象方法。抽象方法是一种仅有方法头，没有方法体和操作实现的一种方法。2 ）静态方法控制符 static ：用修饰符 static 修饰的方法称为静态方法。静态方法是属于整个类的类方法；而不使用 static 修饰、限定的方法是属于某个具体类对象的方法。 由于 static 方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量，即 static 方法只能处理 static 的域。3 ）最终方法控制符 final ：用修饰符 final 修饰的方法称为最终方法。最终方法是功能和内部语句不能更改的方法，即最终方法不能重载。这样，就固定了这个方法所具有的功能和操作，防止当前类的子类对父类关键方法的错误定义，保证了程序的安全性和正确性。所有被 private 修饰符限定为私有的方法，以及所有包含在 final 类 ( 最终类 ) 中的方法，都被认为是最终方法。4 ）本地方法控制符 native ：用修饰符 native 修饰的方法称为本地方法。为了提高程序的运行速度，需要用其它的高级语言书写程序的方法体，那么该方法可定义为本地方法用修饰符 native 来修饰；5 ）同步方法控制符 synchronized ：该修饰符主要用于多线程共存的程序中的协调和同步。5.STATIC修饰符<br>希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static(静态的)就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static 成员的最常见的例子是main( ) 。因为在程序开始执行时必须调用main() ，所以它被声明为static。声明为static的变量实质上就是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。声明为static的方法有以下几条限制：<br>·<br>它们仅能调用其他的static 方法。<br>·<br>它们只能访问static数据。<br>·<br>它们不能以任何方式引用this 或super（关键字super 与继承有关，在下一章中描述）。<br>如果你需要通过计算来初始化你的static变量，你可以声明一个static块，Static 块仅在该类被加载时执行一次6.字符串的大小写转换<br>1.把一个ASP网站改成JSP网站要怎么做<br>1.在IIS环境配置并测试成功后，打开站点属性——主目录——配置——映射选项卡——添加<br>可执行文件找到c:\windows\system32\inetsrv\asp.dll<br>扩展名输入.jsp<br>确定（若此时确定为灰色，请单击可执行文件中的路径）<br>2.将所有.asp文件扩展名改为.jsp（内页中的包含文件路径等也要替换.jsp，避免找不到文件）<br>3.运行网站2.STRUTS1与STUSTS2的区别是什么Struts 1和Struts 2对比2.1. 在Action实现类方面的对比：<br>Struts 1要求Action类继承一个抽象基类；Struts 1的一个具体问题是使用抽象类编程而不是接口。<br>Struts 2 Action类可以实现一个Action接口，也可以实现其他接口，使可选和定制的服务成为可能。Struts 2提供一个ActionSupport基类去实现常用的接口。即使Action接口不是必须实现的，只有一个包含execute方法的POJO类都可以用作Struts 2的Action。<br>2.2. 线程模式方面的对比：<br>Struts 1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts 1 Action能做的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的；<br>Struts 2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。<br>2.3. Servlet依赖方面的对比：<br>Struts 1 Action依赖于Servlet API，因为Struts 1 Action的execute方法中有HttpServletRequest和HttpServletResponse方法。<br>Struts 2 Action不再依赖于Servlet API，从而允许Action脱离Web容器运行，从而降低了测试Action的难度。当然，如果Action需要直接访问HttpServletRequest和HttpServletResponse参数，Struts 2 Action仍然可以访问它们。但是，大部分时候，Action都无需直接访问HttpServetRequest和 HttpServletResponse，从而给开发者更多灵活的选择。<br>2.4. 可测性方面的对比：<br>测试Struts 1 Action的一个主要问题是execute方法依赖于Servlet API，这使得Action的测试要依赖于Web容器。为了脱离Web容器测试Struts 1的Action，必须借助于第三方扩展：Struts TestCase，该扩展下包含了系列的Mock对象（模拟了HttpServetRequest和HttpServletResponse对象），从而可以脱离Web容器测试Struts 1的Action类。<br>Struts 2 Action可以通过初始化、设置属性、调用方法来测试。<br>2.5. 封装请求参数的对比：<br>Struts 1使用ActionForm对象封装用户的请求参数，所有的ActionForm必须继承一个基类：ActionForm。普通的JavaBean不能用作ActionForm，因此，开发者必须创建大量的ActionForm类封装用户请求参数。虽然Struts 1提供了动态ActionForm来简化ActionForm的开发，但依然需要在配置文件中定义ActionForm；<br>Struts 2直接使用Action属性来封装用户请求属性，避免了开发者需要大量开发ActionForm类的烦琐，实际上，这些属性还可以是包含子属性的Rich 对象类型。如果开发者依然怀念Struts 1 ActionForm的模式，Struts 2提供了ModelDriven模式，可以让开发者使用单独的Model对象来封装用户请求参数，但该Model对象无需继承任何Struts 2基类，是一个POJO，从而降低了代码污染。<br>2.6. 表达式语言方面的对比：<br>Struts 1整合了JSTL，因此可以使用JSTL表达式语言。这种表达式语言有基本对象图遍历，但在对集合和索引属性的支持上则功能不强；<br>Struts 2可以使用JSTL，但它整合了一种更强大和灵活的表达式语言：OGNL（Object Graph Notation Language），因此，Struts 2下的表达式语言功能更加强大。<br>2.7. 绑定值到视图的对比：<br>Struts 1使用标准JSP机制把对象绑定到视图页面；<br>Struts 2使用“ValueStack”技术，使标签库能够访问值，而不需要把对象和视图页面绑定在一起。<br>2.8. 类型转换的对比：<br>Struts 1 ActionForm 属性通常都是String类型。Struts 1使用Commons-Beanutils进行类型转换，每个类一个转换器，转换器是不可配置的；<br>Struts 2使用OGNL进行类型转换，支持基本数据类型和常用对象之间的转换。<br>2.9. 数据校验的对比：<br>Struts 1支持在ActionForm重写validate方法中手动校验，或者通过整合Commons alidator框架来完成数据校验。<br>Struts 2支持通过重写validate方法进行校验，也支持整合XWork校验框架进行校验。<br>2.10. Action执行控制的对比：<br>Struts 1支持每一个模块对应一个请求处理（即生命周期的概念），但是模块中的所有Action必须共享相同的生命周期。<br>Struts 2支持通过拦截器堆栈（Interceptor Stacks）为每一个Action创建不同的生命周期。开发者可以根据需要创建相应堆栈，从而和不同的Action一起使用1.简述MVC模式<br>MVC架构是”Model-View-Controller”的缩写，中文翻译为”模型-视图-控制器”。MVC应用程序总是由这三个部分组成。Event(事件)导致Controller改变Model或View，或者同时改变两者。只要Controller改变了Models的数据或者属性，所有依赖的View都会自动更新。类似的，只要Controller改变了View，View会从潜在的Model中获取数据来刷新自己。MVC架构最早是smalltalk语言研究团提出的，应用于用户交互应用程序中。smalltalk语言和java语言有很多相似性,都是面向对象语言，很自然的SUN在petstore(宠物店)事例应用程序中就推荐MVC架构作为开发Web应用的架构模式。MVC架构是一种架构，其实需要其他模式协作完成。在J2EE模式目录中，通常采用service to worker模式实现，而service to worker模式可由集中控制器模式，派遣器模式和Page Helper模式组成。而Struts只实现了MVC的View和Controller两个部分，Model部分需要开发者自己来实现，Struts提供了抽象类Action使开发者能将Model应用于Struts框架中。2.述说STRING的作用<br>要理解 java中String的运作方式，必须明确一点：String是一个非可变类（immutable）。什么是非可变类呢？简单说来，非可变类的实例是不能被修改的，每个实例中包含的信息都必须在该实例创建的时候就提供出来，并且在对象的整个生<br>要理解 java中String的运作方式，必须明确一点：String是一个非可变类（immutable）。什么是非可变类呢？简单说来，非可变类的实例是不能被修改的，每个实例中包含的信息都必须在该实例创建的时候就提供出来，并且在对象的整个生存周期内固定不变。但是非可变类确实有着自身的优势，如状态单一，对象简单，便于维护。其次，该类对象对象本质上是线程安全的，不要求同步。此外用户可以共享非可变对象，甚至可以共享它们的内部信息。。String类在java中被大量运用，甚至在class文件中都有其身影，因此将其设计为简单轻便的非可变类是比较合适的。<br>一、创建。<br>好了，知道String是非可变类以后，我们可以进一步了解String的构造方式了。创建一个Stirng对象，主要就有以下两种方式：java 代码<br>String str1 &#x3D; new String( “abc” );<br>Stirng str2 &#x3D; “abc” ;<br>虽然两个语句都是返回一个String对象的引用，但是jvm对两者的处理方式是不一样的。对于第一种，jvm会马上在heap中创建一个String对象，然后将该对象的引用返回给用户。对于第二种，jvm首先会在内部维护的strings pool中通过String的 equels 方法查找是对象池中是否存放有该String对象，如果有，则返回已有的String对象给用户，而不会在heap中重新创建一个新的String对象；如果对象池中没有该String对象，jvm则在heap中创建新的String对象，将其引用返回给用户，同时将该引用添加至strings pool中。注意：使用第一种方法创建对象时，jvm是不会主动把该对象放到strings pool里面的，除非程序调用 String的intern方法。看下面的例子：java 代码<br>String str1 &#x3D; new String( “abc” ); &#x2F;&#x2F;jvm 在堆上创建一个String对象&#x2F;&#x2F;jvm 在strings pool中找不到值为“abc”的字符串，因此<br>&#x2F;&#x2F;在堆上创建一个String对象，并将该对象的引用加入至strings pool中<br>&#x2F;&#x2F;此时堆上有两个String对象<br>Stirng str2 &#x3D; “abc” ;if (str1 &#x3D;&#x3D; str2){<br>System.out.println( “str1 &#x3D;&#x3D; str2” );<br>} else {<br>System.out.println( “str1 !&#x3D; str2” );<br>}<br>&#x2F;&#x2F;打印结果是 str1 !&#x3D; str2,因为它们是堆上两个不同的对象String str3 &#x3D; “abc” ;<br>&#x2F;&#x2F;此时，jvm发现strings pool中已有“abc”对象了，因为“abc”equels “abc”<br>&#x2F;&#x2F;因此直接返回str2指向的对象给str3，也就是说str2和str3是指向同一个对象的引用<br>if (str2 &#x3D;&#x3D; str3){<br>System.out.println( “str2 &#x3D;&#x3D; str3” );<br>} else {<br>System.out.println( “str2 !&#x3D; str3” );<br>}<br>&#x2F;&#x2F;打印结果为 str2 &#x3D;&#x3D; str3<br>再看下面的例子：java 代码<br>String str1 &#x3D; new String( “abc” ); &#x2F;&#x2F;jvm 在堆上创建一个String对象str1 &#x3D; str1.intern();<br>&#x2F;&#x2F;程序显式将str1放到strings pool中，intern运行过程是这样的：首先查看strings pool<br>&#x2F;&#x2F;有没“abc”对象的引用，没有，则在堆中新建一个对象，然后将新对象的引用加入至<br>&#x2F;&#x2F;strings pool中。执行完该语句后，str1原来指向的String对象已经成为垃圾对象了，随时会<br>&#x2F;&#x2F;被GC收集。&#x2F;&#x2F;此时，jvm发现strings pool中已有“abc”对象了，因为“abc”equels “abc”<br>&#x2F;&#x2F;因此直接返回str1指向的对象给str2，也就是说str2和str1引用着同一个对象，<br>&#x2F;&#x2F;此时，堆上的有效对象只有一个。<br>Stirng str2 &#x3D; “abc” ;if (str1 &#x3D;&#x3D; str2){<br>System.out.println( “str1 &#x3D;&#x3D; str2” );<br>} else {<br>System.out.println( “str1 !&#x3D; str2” );<br>}<br>&#x2F;&#x2F;打印结果是 str1 &#x3D;&#x3D; str2为什么jvm可以这样处理String对象呢？就是因为String的非可变性。既然所引用的对象一旦创建就永不更改，那么多个引用共用一个对象时互不影响。二、串接（Concatenation）。<br>java程序员应该都知道滥用String的串接操作符是会影响程序的性能的。性能问题从何而来呢？归根结底就是String类的非可变性。既然 String对象都是非可变的，也就是对象一旦创建了就不能够改变其内在状态了，但是串接操作明显是要增长字符串的，也就是要改变String的内部状态，两者出现了矛盾。怎么办呢？要维护String的非可变性，只好在串接完成后新建一个String 对象来表示新产生的字符串了。也就是说，每一次执行串接操作都会导致新对象的产生，如果串接操作执行很频繁，就会导致大量对象的创建，性能问题也就随之而来了。<br>为了解决这个问题，jdk为String类提供了一个可变的配套类，StringBuffer。使用StringBuffer对象，由于该类是可变的，串接时仅仅时改变了内部数据结构，而不会创建新的对象，因此性能上有很大的提高。针对单线程，jdk 5.0还提供了StringBuilder类，在单线程环境下，由于不用考虑同步问题，使用该类使性能得到进一步的提高。三、String的长度<br>我们可以使用串接操作符得到一个长度更长的字符串，那么，String对象最多能容纳多少字符呢？查看String的源代码我们可以得知类String中是使用域 count 来记录对象字符的数量，而count 的类型为 int，因此，我们可以推测最长的长度为 2^32，也就是4G。<br>不过，我们在编写源代码的时候，如果使用 Sting str &#x3D; “aaaa”;的形式定义一个字符串，那么双引号里面的ASCII字符最多只能有 65534 个。为什么呢？因为在class文件的规范中， CONSTANT_Utf8_info表中使用一个16位的无符号整数来记录字符串的长度的，最多能表示 65536个字节，而java class 文件是使用一种变体UTF-8格式来存放字符的，null值使用两个字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。也正是变体UTF-8的原因，如果字符串中含有中文等非ASCII字符，那么双引号中字符的数量会更少（一个中文字符占用三个字节）。如果超出这个数量，在编译的时候编译器会报错。3.简述一下EJB与SPRING的区别与联系<br>Spring+hibernate提供了大部分原来只有ejb才有的服务，而且spring提供的有些服务比ejb做的更细致，更周到。<br>那么是不是有了spring，ejb3就没有作用吗？<br>否定。因为ejb设计的初衷是用于分布式场合，而spring一开始就没有打算提供分布式功能。所以两者的偏重点是不一样的，像ejb比较适合用于大型企业，因为大型企业一般都　会存在多个信息系统，而这些信息系统又相互关联。为了避免业务功能重复开发，实现最大程度的重用，有必要把业务层独立出来，让多个信息系统共享一个业务中心，这样应用就需要具备分布式能力。它的主要优点就是：分离出业务层，软件功能改变，只需修改业务层，为后期软件维护提供了方便。实现业务功能共享。软件实现了最大程度的组件方面的重用。4.述说一下STRUSTS1和STRUSTS2的区别1，strust2.0的配置文件:struts.xml(取代了struts1里面的strut-config.xml<br>2.strust2.0提供了，拦截器（interceptot），而struts1没有此技术<br>3，Struts2的核心框架是当作一个filter来实现其功能的,而Struts1是ActionServlet.<br>4，Struts 1要求Action类继承一个抽象基类；Struts 1的一个具体问题是使用抽象类编程而不是接口。Struts 2 Action类可以实现一个Action接口，也可以实现其他接口，使可选和定制的服务成为可能。Struts 2提供一个ActionSupport基类去实现常用的接口。即使Action接口不是必须实现的，只有一个包含execute方法的POJO类都可以用作Struts 2的Action。<br>5，数据校验的对比：Struts 1支持在ActionForm重写validate方法中手动校验，或者通过整合Commons alidator框架来完成数据校验。Struts 2支持通过重写validate方法进行校验，也支持整合XWork校验框架进行校验。5.说一下MYSQL数据库的配置文件<br>可以使用的MySQL配置文件共有５个。最后４个位于&#x2F;usr&#x2F;share&#x2F;doc&#x2F;mysql-server-*&#x2F;目录中。<br>·&#x2F;etc&#x2F;my.cnf是默认的MySQL配置文件。应该对这个文件配置修改。它是为学习目的而设计的。<br>·my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。<br>·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。<br>·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。<br>·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。6.MYSQL数据库的备份与还原<br>1.将数据库mydb导出到e:\mysql\mydb.sql文件中：<br>打开开始-&gt;运行-&gt;输入cmd进入命令行模式<br>c:&gt;mysqldump -h localhost -u root -p mydb &gt;e:\mysql\mydb.sql<br>然后输入密码，等待一会导出就成功了，可以到目标文件中检查是否成功。<br>2.将数据库mydb中的mytable导出到e:\mysql\mytable.sql文件中：<br>c:&gt;mysqldump -h localhost -u root -p mydb mytable&gt;e:\mysql\mytable.sql<br>3.将数据库mydb的结构导出到e:\mysql\mydb_stru.sql文件中：<br>c:&gt;mysqldump -h localhost -u root -p mydb –add-drop-table &gt;e:\mysql\mydb_stru.sql<br>四.从外部文件导入数据到数据库中：<br>从e:\mysql\mydb2.sql中将文件中的SQL语句导入数据库中：<br>1.从命令行进入mysql，然后用命令CREATE DATABASE mydb2;创建数据库mydb2。<br>2.退出mysql 可以输入命令exit；或者quit；<br>3.在CMD中输入下列命令：<br>c:&gt;mysql -h localhost -u root -p mydb2 &lt; e:\mysql\mydb2.sql<br>然后输入密码，就OK了。3、spring的JDBC与传统JDBC的区别及其核心类是什么？<br>对于JDBC来说，Spring提供了3个模板类：<br>nJdbcTemplate：Spring里最基本的JDBC模板，利用JDBC和简单的索引参数查询提供对数据库的简单访问。<br>nNamedParameterJdbcTemplate：能够在执行查询时把值绑定到SQL里的命名参数，而不是使用索引参数。<br>nSimpleJdbcTemplate：利用Java 5的特性，比如自动装箱、通用（generic）和可变参数列表来简化JDBC模板的使用。<br>JDBC是在关系型数据库里访问数据的最基本方式，Spring的JDBC模板让我们不必编写处理连接资源和异常的重复代码，把精力集中于查询和更新数据的工作。<br>虽然Spring处理了使用JDBC时必需的很多工作，但随着程序规模增加、复杂程度提高，使用JDBC仍然会变得繁琐。为了帮助管理大型程序的存留工作，我们可以使用像Hibernate这样的存留框架。4、web service 是什么 及其运行机制。<br>W3C组织对其的定义如下，它是一个软件系统，为了支持跨网络的机器间相互操作交互而设计。Web Service服务通常被定义为一组模块化的API，它们可以通过网络进行调用，来执行远程系统的请求服务。这里我们从一个程序员的视角来观察web service。在传统的程序编码中，存在这各种的函数方法调用。通常，我们知道一个程序模块M中的方法A，向其发出调用请求，并传入A方法需要的参数P，方法A执行完毕后，返回处理结果R。这种函数或方法调用通常发生在同一台机器上的同一程序语言环境下。现在的我们需要一种能够在不同计算机间的不同语言编写的应用程序系统中，通过网络通讯实现函数和方法调用的能力，而Web service正是应这种需求而诞生的。web service的构成组件web service的工作原理分为两步，第一步是在服务器上创造服务并将其在一台“目录服务器”上注册；第二步是客户端查找并调用该服务。要在网络使用服务，必须先有人提供服务；如何提供服务，首先必须有一个服务的发布场所；如何发布服务，就是要向“发布场所”声明你有一个服务可以对外提供，这就是服务的注册。就如在淘宝上发布了一件商品，把价格等必要信息写上去，让要的人来买。这个发布的场所是人所周知的，就如淘宝，卖东西的人知道，买东西的人也知道，所以web service的服务端和客户端都必须知道这台注册服务用的服务器。有了市场，就可以开始做生意了，厂商开始生产自己的东西，并拿到市场上去卖，而客户则通过商品目录来查找自己所需要的产品。这其中会涉及到一些买卖术语，厂商要把商品属性通知市场，而市场又要为厂商打广告，把商品目录告知客户，最后厂商和客户交易还需要传递数量、颜色、等级等信息，并且最终交付产品。在网络上，这些交流需要专门的术语，否则就会变成“鸡同鸭讲”了。6、JNDI JMS JTA 是什么意思？<br>JNDI(Java Naming and Directory Interface)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI SPI的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。集群JNDI实现了高可靠性JNDI[8]，通过服务器的集群，保证了JNDI的负载平衡和错误恢复。在全局共享的方式下，集群中的一个应用服务器保证本地JNDI树的独立性，并拥有全局的JNDI树。每个应用服务器在把部署的服务对象绑定到自己本地的JNDI树的同时，还绑定到一个共享的全局JNDI树，实现全局JNDI和自身JNDI的联系。JNDI(Java Naming and Directory Interface)是一个应用程序设计的API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。<br>JNDI可访问的现有的目录及服务有：<br>DNS、XNam 、Novell目录服务、LDAP(Lightweight Directory Access Protocol 轻型目录访问协议)、 CORBA对象服务、文件系统、Windows XP&#x2F;2000&#x2F;NT&#x2F;Me&#x2F;9x的注册表、RMI、DSML v1&amp;v2、NIS。<br>JNDI优点：<br>包含了大量的命名和目录服务，使用通用接口来访问不同种类的服务；<br>可以同时连接到多个命名或目录服务上；<br>建立起逻辑关联，允许把名称同Java对象或资源关联起来，而不必指导对象或资源的物理ID。JTA :<br>JTA(Java Transaction API) 为 J2EE 平台提供了分布式事务服务。<br>要用 JTA 进行事务界定，应用程序要调用 javax.transaction.UserTransaction 接口中的方法<br>“用 JTA 界定事务，那么就需要有一个实现 javax.sql.XADataSource 、 javax.sql.XAConnection 和 javax.sql.XAResource 接口的 JDBC 驱动程序。一个实现了这些接口的驱动程序将可以参与 JTA 事务。一个 XADataSource 对象就是一个 XAConnection 对象的工厂。 XAConnection s 是参与 JTA 事务的 JDBC 连接。”<br>要使用JTA事务，必须使用XADataSource来产生数据库连接，产生的连接为一个XA连接。<br>JMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，翻译为Java消息服务。JMS支持点对点和发布&#x2F;订阅两种消息模型。JMS基本概念<br>1.JMS(Java Message Service)是访问企业消息系统的标准API,它便于消息系<br>统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。1. JMS基本功能<br>JMS是用于和面向消息的中间件相互通信的应用程序接口。它既支持点对点(point-to-point)的域，又支持发布&#x2F;订阅(publish&#x2F;subscribe)类型的域，并且提供对下列类型的支持：经认可的消息传递,事务型消息的传递，一致性消息和具有持久性的订阅者支持。JMS还提供了另一种方式来对您的应用与旧的后台系统相集成。<br>2. WebLogic JMS Server介绍<br>WebLogic Server8.1符合JAVA规范,并通过Sun Microsystems J2EE 1.3认<br>证.作为WebLogic的一部分,当然WebLogic JMS Server也完全遵从JMS规范,还支持集群,并可以应用于实际企业系统.下图是WebLogic JMS Server体系结构.图中可以看到WebLogic JMS Server主要组件有: WebLogic JMS servers(用于消息通信),Java客户端,JNDI(用于域名查找), 后备存储(用于持久消息存储,基于文件或者JDBC数据库).7、spring 在SSH 框架中的作用。<br>在SSH框假中spring充当了管理容器的角色。我们都知道Hibernate用来做持久层，因为它将JDBC做了一个良好的封装，程序员在与数据库进行交互时可以不用书写大量的SQL语句。Struts是用来做应用层的，他它负责调用业务逻辑serivce层。所以SSH框架的流程大致控制Service（业务逻辑处理类），从而控制了Service的生命周期，这样层与层之间的依赖和强，属于耦合。这时，使用spring框架就起到了控制Action对象（Strus中的）和Service类的作用，两者之间的关系就松散了，Spring的Ioc机制（控制反转和依赖注入）正是用在此处。<br>Spring的Ioc（控制反转和依赖注入）<br>控制反转：就是由容器控制程序之间的（依赖）关系，而非传统实现中，由程序代码直接操控。<br>依赖注入：组件之间的依赖关系由容器在运行期决定 ，由容器动态的将某种依赖关系注入到组件之中。从上面我们不难看出：从头到尾Action仅仅是充当了Service的控制工具，这些具体的业务方法是怎样实现的，他根本就不会管，也不会问，他只要知道这些业务实现类所提供的方法接口就可以了。而在以往单独使用Struts框架的时候，所有的业务方法类的生命周期，甚至是一些业务流程都是由Action来控制的。层与层之间耦合性太紧密了，既降低了数据访问的效率又使业务逻辑看起来很复杂，代码量也很多。，Spring容器控制所有Action对象和业务逻辑类的生命周期，由与上层不再控制下层的生命周期，层与层之间实现了完全脱耦，使程序运行起来效率更高，维护起来也方便。 使用Spring的第二个好处（AOP应用）：事务的处理：在以往的JDBCTemplate中事务提交成功，异常处理都是通过Try&#x2F;Catch 来完成，而在Spring中。Spring容器集成了TransactionTemplate，她封装了所有对事务处理的功能，<br>包括异常时事务回滚，操作成功时数据提交等复杂业务功能。这都是由Spring容器来管理，大大减少了程序员的代码量，也对事务有了很好的管理控制。Hibernate中也有对事务的管理，hibernate中事务管理是通过SessionFactory创建和维护Session来完成。而Spring对SessionFactory配置也进行了整合，不需要在通过hibernate.cfg.xml来对SessionaFactory进行设定。这样的话就可以很好的利用Sping对事务管理强大功能。避免了每次对数据操作都要现获得Session实例来启动事务&#x2F;提交&#x2F;回滚事务还有繁琐的<br>Try&#x2F;Catch操作。这些也就是Spring中的AOP（面向切面编程）机制很好的应用。一方面使开发业务逻辑更清晰、专业分工更加容易进行。另一方面就是应用Spirng AOP隔离降低了程序的耦合性使我们可以在不同的应用中将各个切面结合起来使用大大提高了代码重用度。9、J2EE 是什么？<br>J2EE Java2平台企业版（Java 2 Platform,Enterprise Edition）<br>　　J2EE是一套全然不同于传统应用开发的技术架构，包含许多组件，主要可简化且规范应用系统的开发与部署，进而提高可移植性、安全与再用价值。<br>　　J2EE核心是一组技术规范与指南，其中所包含的各类组件、服务架构及技术层次，均有共通的标准及规格，让各种依循J2EE架构的不同平台之间，存在良好的兼容性，解决过去企业后端使用的信息产品彼此之间无法兼容,，企业内部或外部难以互通的窘境。1.string类修饰的值是否可以改变？为什么？它在内存中是怎么样运作的？<br>String类的值在初始后不能改变，如果要改变，可转换为StringBuffer类，这个类的值是可以动态改变的<br>Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！全面解析 Java 中的 String 数据类型<br>April 6th, 2008 | Categories: Java | Tags: Java1. 首先String不属于8种基本数据类型，String是一个对象。<br>因为对象的默认值是null，所以String的默认值也是null；但它又是一种特殊的对象，有其它对象没有的一些特性。2. new String()和new String(””)都是申明一个新的空字符串，是空串不是null；3. String str&#x3D;”kvill”；String str&#x3D;new String (”kvill”);的区别：在这里，我们不谈堆，也不谈栈，只先简单引入常量池这个简单的概念。<br>常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。看例1：String s0&#x3D;”kvill”;<br>String s1&#x3D;”kvill”;<br>String s2&#x3D;”kv” + “ill”;<br>System.out.println( s0&#x3D;&#x3D;s1 );<br>System.out.println( s0&#x3D;&#x3D;s2 );<br>结果为：<br>true<br>true首先，我们要知结果为道Java会确保一个字符串常量只有一个拷贝。<br>因为例子中的s0和s1中的”kvill”都是字符串常量，它们在编译期就被确定了，所以s0&#x3D;&#x3D;s1为true；而”kv”和”ill”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中” kvill”的一个引用。<br>所以我们得出s0&#x3D;&#x3D;s1&#x3D;&#x3D;s2；用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。　　看例2：<br>String s0&#x3D;”kvill”;<br>String s1&#x3D;new String(“kvill”);<br>String s2&#x3D;”kv” + new String(“ill”);<br>System.out.println( s0&#x3D;&#x3D;s1 );<br>System.out.println( s0&#x3D;&#x3D;s2 );<br>System.out.println( s1&#x3D;&#x3D;s2 );<br>结果为：<br>false<br>false<br>false例2中s0还是常量池中”kvill”的应用，s1因为无法在编译期确定，所以是运行时创建的新对象”kvill”的引用，s2因为有后半部分 new String(”ill”)所以也无法在编译期确定，所以也是一个新创建对象”kvill”的应用;明白了这些也就知道为何得出此结果了。1. String.intern()：<br>再补充介绍一点：存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；看例3就清楚了　　例3：<br>String s0&#x3D; “kvill”;<br>String s1&#x3D;new String(“kvill”);<br>String s2&#x3D;new String(“kvill”);<br>System.out.println( s0&#x3D;&#x3D;s1 );<br>System.out.println( “**********“ );<br>s1.intern();<br>s2&#x3D;s2.intern(); &#x2F;&#x2F;把常量池中”kvill”的引用赋给s2<br>System.out.println( s0&#x3D;&#x3D;s1);<br>System.out.println( s0&#x3D;&#x3D;s1.intern() );<br>System.out.println( s0&#x3D;&#x3D;s2 );<br>结果为：<br>false<em>*<em>false &#x2F;&#x2F;虽然执行了s1.intern(),但它的返回值没有赋给s1<br>true &#x2F;&#x2F;说明s1.intern()返回的是常量池中”kvill”的引用<br>true最后我再破除一个错误的理解：有人说，“使用 String.intern() 方法则可以将一个 String 类的保存到一个全局 String 表中，如果具有相同值的 Unicode 字符串已经在这个表中，那么该方法返回表中已有字符串的地址，如果在表中没有相同值的字符串，则将自己的地址注册到表中”如果我把他说的这个全局的 String 表理解为常量池的话，他的最后一句话，”如果在表中没有相同值的字符串，则将自己的地址注册到表中”是错的：　　看例4：<br>String s1&#x3D;new String(“kvill”);<br>String s2&#x3D;s1.intern();<br>System.out.println( s1&#x3D;&#x3D;s1.intern() );<br>System.out.println( s1+” “+s2 );<br>System.out.println( s2&#x3D;&#x3D;s1.intern() );<br>结果：<br>false<br>kvill kvill<br>true在这个类中我们没有声名一个”kvill”常量，所以常量池中一开始是没有”kvill”的，当我们调用s1.intern()后就在常量池中新添加了一个”kvill”常量，原来的不在常量池中的”kvill”仍然存在，也就不是“将自己的地址注册到常量池中”了。<br>s1&#x3D;&#x3D;s1.intern()为false说明原来的”kvill”仍然存在；s2现在为常量池中”kvill”的地址，所以有s2&#x3D;&#x3D;s1.intern()为true。1. 关于equals()和&#x3D;&#x3D;:<br>这个对于String简单来说就是比较两字符串的Unicode序列是否相当，如果相等返回true;而&#x3D;&#x3D;是比较两字符串的地址是否相同，也就是是否是同一个字符串的引用。1. 关于String是不可变的<br>这一说又要说很多，大家只要知道String的实例一旦生成就不会再改变了，比如说：String str&#x3D;”kv”+”ill”+” “+”ans”;<br>就是有4个字符串常量，首先”kv”和”ill”生成了”kvill”存在内存中，然后”kvill”又和” ” 生成 “kvill “存在内存中，最后又和生成了”kvill ans”;并把这个字符串的地址赋给了str,就是因为String的”不可变”产生了很多临时变量，这也就是为什么建议用StringBuffer的原因了，因为StringBuffer是可改变的。1. mxj said:<br>April 11th, 2008 at 11:44 pm单独的这样一条语句String str&#x3D;”kv”+”ill”+” “+”ans”;应该不会产生临时变量吧，等号后面的一长串东西应该在编译期就直接变成一个常量字符串，放在常量池里了。。<br>做了个测试：<br>源代码<br>public class Test{<br>public static void main(String[] s){<br>String b&#x3D;”xxx”;<br>String a&#x3D;”bbb”+”ccc”+”ddd”;<br>System.out.println(a+b);<br>}<br>}<br>javac 编译后，用javap看他的机器码。<br>可以看到只有一个已经编译成”bbbcccddd”的常量字符串。<br>可以看到编译器自动调用StringBuilder来处理字符串拼接，编译器还是很AI的。（StringBuilder是1.5的新类，1.4应该是StringBuffer，两者区别后面说。） 到底coding的时候要不要用StringBuffer呢？貌似编译器会自动把字符串拼接，用StringBuffer来处理。。<br>好比c里面，到底要不要把c&#x2F;2改成c&gt;&gt;1提高效率，编译器有时候做的比我们想象的好的多。。 到了JDK1.5多了一个StringBuilder类，这个类比StringBuffer应该更快 一点，毕竟StringBuffer是线程安全的。<br>但是不知道怎么做个测试案例，来测试这两个类的性能差异。2.struts是用什么设计模式实现的？<br>MVC模式(Model-View-Controller 模型-视图-控制器)<br>Struts主要担当了控制器的作用3.struts的工作流程是什么？<br>通常我们在配置Struts框架的时候，所使用的Controller都是默认的org\apache\struts\action\ActionServlet类,它继承自javax.servlet.http.HttpServlet,因此具有一般servlet的所有特征,必须在web.xml中对其进行注册。当我们的container第一次启动的时候(这个说法不是很准确，或者是ActionServlet第一次被请求调用得时候)，会自动加载ActionServlet，同时调用其中的init()方法。在init()方法中将发生如下动作：1.initInternal():初始化框架的内部消息绑定，这些消息用来输出提示，警告，和错误信息到日志文件中，主要操作是internal &#x3D; MessageResources.getMessageResources(internalName);其中internal是MessageResources的一个实例。2.initOther():加载web.xml中定义的不同参数，如config，用以控制ActionServlet的不同行为，主要是读取&lt;init-param&gt;&lt;&#x2F;init-param&gt;中所定义的参数。3.initServlet():加载并初始化web.xml文件所定义的servlet名称和servlet映射信息4.initModuleConfigFactory()和ModuleConfig moduleConfig &#x3D; initModuleConfig(“”, config):加载并初始化struts-config.xml配置文件,默认配置文件被解析，产生一个ModuleConfig对象于ServletContext5.initModuleMessageResources(moduleConfig):struts-config.xml配置文件中指定的每一个消息资源都被加载，初始化6.initModuleDataSources(moduleConfig):struts-config.xml配置文件中声明的每一个数据源被加载并且初始化，如果没有配置数据源，这一步跳过。7.initModulePlugIns(moduleConfig):加载并初始化struts-config.xml配置文件中指定的插件。每一个插件的init()方法被调用。8.当默认应用加载完成，init()方法判断是否有应用模块需要加载，如果有，重复步骤4—7完成应用模块的加载。 然后，在应用程序的运行过程中，当有用户发出请求的时候(当然这个请求必须得映射到ActionServlet上面去)，ActionServlet就会收到这个请求，此时它的doPost或者doGet方法就会自动的被调用，这是servlet的内部机制。至于究竟是哪个方法会被调用取决于所请求的方法的类型，即html表单中的method属性。但是,不管是哪个方法会被调用ActionServlet中的process(HttpServletRequest request, HttpServletResponse response)方法都会被调用。ActionServlet中的process方法的主要作用就是得到一个相应的RequestProcessor类或者其子类的对象，然后调用这个它的process(HttpServletRequest request, HttpServletResponse response)方法来处理用户的需求。现在ActionServlet就已经完成了它的使命,剩下的任务就由RequestProcessor来完成了,在RequestProcessor中将主要执行如下操作:1.processMultipart(request):对用户的请求进行预处理，如果HttpServletRequest是POST方式，且请求为multipart&#x2F;form-data ，Struts框架将请求对象包装成处理multipart请求专用的请求对象，否则，只是简单地返回原有的请求对象。一般来说，除非需要处理文件上传，否则不用关心multipart 功能的具体细节。进行包装处理的类是MultipartRequestWrapper类，它以用户的请求为包装对象。2.processPath(request, response):该方法用来从请求URL中获应用取路径部分，获取到的信息在稍后的步骤中用于选择合适的Struts Action调用，与action标签的path属性相对应。3.processLocale(request, response):处理一些国际化的事务。4.processContent(request, response):设置响应体的编码方式，response.setContentType(contentType)。5.processNoCache(request, response):根据noCache属性的设置调用processNoCache( ) 方法，如果noCache设置为true.则添加合适的响应头到响应对象中，使得页面保留在浏览器的Cache中。这些响应头包含Pragma, Cache-Control, 和Expires6.processPreprocess(request, response):该方法只是简单的返回一个true值,它是以如下方式调用的:if(!processPreprocess(request, response)) return;因此我们可以在processPreprocess方法中进行一点的预处理，如果用户的请求不符合要求的话，我们就让它返回一个false值，这样的话action就不会调用。7.processMapping(request, response, path):利用前面所获取的path值，在struts-config.xml中寻找对应的action。即根据path在action－mappings标签中寻找其对应的action，如果找不到则返回一个error。8.processRoles(request, response, mapping):可忽略，一般没啥用处。9.processActionForm(request, response, mapping):第一步,查看是否存在着为这个ActionMapping配置得ActionForm,具体的查看流程如下:1.该action元素的attribute是否为null，如果为null，则返回null;2.如果attribute属性不为null则取得它的 name属性,然后根据name的值在<form-beans></form-beans>中寻找相应的ActionForm，也是通过name属性来配对的,如果找不到的话，则会产生错误日志,并且返回null。第二步,如果存在这样的ActionForm，我们就根据上面的attribute的值，在作用域查看是否存在着这样的ActionForm的实例，如果存 在则复用之，并把它作为返回值,否则的话，就重新创建这个ActionForm的一个实例，并且返回它，最后这个实例将会保存在相应的作用域中10.processPopulate(request, response, form, mapping):如果存在为ActionMapping配置的ActionForm，则封装请求对象中的数据到ActionForm 中，在进行封装之前，先调用ActionForm 的reset( )方法进行属性值的默认化。11.processValidate(request, response, form, mapping):如果ActionForm被配置好，并且Action元素的属性validate被设置为true ，则进一步调用validate( )方法进行规则校 验。如果validate()方法校验失败，就会保存一个ActionErrors 对象到请求区域中，请求将会自动重定向到action映射的input属性所指定的页面中。如果校验通过或在action映射中没有配置ActionForm，则继续处理请求。12.processForward(request, response, mapping)&amp;processInclude(request, response, mapping):根据action 映射是否配置了forward属性或include属性来决定下一步操作。如果配置了任意一个，则相应地调用RequestDispatcher对象的forward( )方法或include( )方法，调用后，对客户请求的处理结束。否则，继续处理请求。13.processActionCreate(request, response, mapping):创建或获取一个Action对象实例处理请求。processActionCreate( )方法会在缓存中查找是否存在已经创 建好的Action实例，如果存在，则复用，否则，则重新创建并将其存于缓存中。如果该方法返回null，则请求处理结束(注：根据action映射得type属性来寻找对应得Action类)。14.processActionPerform(request, response, action, form, mapping):调用action 实例的execute( )方法。15.processForwardConfig(request, response, forward):传入action的execute( )方法所返回的ActionForward对象实例，方法通过检查ActionForward对象实例，决定用 redirect或forword方式进行重定向。究竟采用redirect还是forword取决于forward元素的redirect属性值。在oracle数据库中 表的内连接与外连接的区别是什么？分别用在什么场合？<br>两个表的连接，是通过将一个表中的一列或者多列同另一个表中的列链接而建立起来的。用来连接两张表的表达式组成了连接条件。当连接成功后，第二张表中的数据就同第一张表连接起来了，并形成了复合结果集–包括两张表中数据行的计划。简单地说，就是两张表有了子集，虽然只是暂时的有两者基本类型的的连接，inner和outer连接。两种类型的主要区别在于，即使是在连接条件不满足的情况下，外部连接也会在结果集内返回行，而内部连接不会在结果集类返回行<br>当外部连接不满足连接条件时，通常返回一个表中的列，但是第二个表中没有返回值–为null（一）内连接<br>　　内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的<br>列值。内连接分三种：<br>　　1、等值连接：在连接条件中使用等于号(&#x3D;)运算符比较被连接列的列值，其查询结<br>果中列出被连接表中的所有列，包括其中的重复列。<br>　　<br>　　2、不等连接： 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的<br>列的列值。这些运算符包括&gt;、&gt;&#x3D;、&lt;&#x3D;、&lt;、!&gt;、!&lt;和&lt;&gt;。　　3、自然连接：在连接条件中使用等于(&#x3D;)运算符比较被连接列的列值，但它使用选<br>择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。(二) 外连接　　<br>　　外连接，返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左<br>外连接或左连接))、右表(右外连接或右连接)或两个边接表(全外连接)中的所有数据行。<br>　　left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录；<br>　　right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录；<br>例如1：SELECT a.</em>,b.* FROM luntan LEFT JOIN usertable as b<br>　　 ON a.username&#x3D;b.username<br>例如2：SELECT a.</em>,b.*<br>　　 FROM city as a FULL OUTER JOIN user as b<br>　　 ON a.username&#x3D;b.username<br>(三) 交叉连接 　　<br>　　交叉连接不带WHERE 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到<br>结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查<br>询条件的数据行数。例，titles表中有6类图书，而publishers表中有8家出版社，则下<br>列交叉连接检索到的记录数将等于6*8&#x3D;48行。 　　<br>　　例如：SELECT type,pub_name<br>　　 FROM titles CROSS JOIN publishers<br>　　 ORDER BY type1.AJAX的工作原理<br>Ajax的工作原理Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。在创建Web站点时，在客户端执行屏幕更新为用户提供了很大的灵活性。下面是使用Ajax可以完成的功能：动态更新购物车的物品总数，无需用户单击Update并等待服务器重新发送整个页面。<br>提升站点的性能，这是通过减少从服务器下载的数据量而实现的。例如，在Amazon的购物车页面，当更新篮子中的一项物品的数量时，会重新载入整个页面，这必须下载32K的数据。如果使用Ajax计算新的总量，服务器只会返回新的总量值，因此所需的带宽仅为原来的百分之一。<br>消除了每次用户输入时的页面刷新。例如，在Ajax中，如果用户在分页列表上单击Next，则服务器数据只刷新列表而不是整个页面。<br>直接编辑表格数据，而不是要求用户导航到新的页面来编辑数据。对于Ajax，当用户单击Edit时，可以将静态表格刷新为内容可编辑的表格。用户单击Done之后，就可以发出一个Ajax请求来更新服务器，并刷新表格，使其包含静态、只读的数据。2.三大框架的特点及应用<br>Struts的原理和优点.Struts工作原理MVC即Model-View-Controller的缩写，是一种常用的设计模式。MVC 减弱了业务逻辑接口和数据接口之间的耦合，以及让视图层更富于变化。MVC的工作原理,如下图1所示：<br>Struts 是MVC的一种实现，它将 Servlet和 JSP 标记（属于 J2EE 规范）用作实现的一部分。Struts继承了MVC的各项特性，并根据J2EE的特点，做了相应的变化与扩展。Struts的工作原理，<br>视图：主要由JSP生成页面完成视图，Struts提供丰富的JSP 标签库： Html，Bean，Logic，Template等，这有利于分开表现逻辑和程序逻辑。<br>控制：在Struts中，承担MVC中Controller角色的是一个Servlet，叫ActionServlet。ActionServlet是一个通用的控制组件。这个控制组件提供了处理所有发送到Struts的HTTP请求的入口点。它截取和分发这些请求到相应的动作类（这些动作类都是Action类的子类）。另外控制组件也负责用相应的请求参数填充 Action From（通常称之为FromBean）,并传给动作类（通常称之为ActionBean）。动作类实现核心商业逻辑，它可以访问java bean 或调用EJB。最后动作类把控制权传给后续的JSP 文件，后者生成视图。所有这些控制逻辑利用Struts-config.xml文件来配置。<br>模型：模型以一个或多个java bean的形式存在。这些bean分为三类：Action Form、Action、JavaBean or EJB。Action Form通常称之为FormBean，封装了来自于Client的用户请求信息，如表单信息。Action通常称之为ActionBean，获取从ActionSevlet传来的FormBean，取出FormBean中的相关信息，并做出相关的处理，一般是调用Java Bean或EJB等。<br>流程：在Struts中，用户的请求一般以*.do作为请求服务名，所有的*.do请求均被指向ActionSevlet，ActionSevlet根据Struts-config.xml中的配置信息，将用户请求封装成一个指定名称的FormBean，并将此FormBean传至指定名称的ActionBean，由ActionBean完成相应的业务操作，如文件操作，数据库操作等。每一个*.do均有对应的FormBean名称和ActionBean名称，这些在Struts-config.xml中配置。<br>核心：Struts的核心是ActionSevlet，ActionSevlet的核心是Struts-config.xml。<br>Struts优缺点<br>优点：<br>1.开源软件，能更深入的了解其内部实现机制。<br>2.Taglib标记库，灵活动用，能大大提高开发效率。<br>3.页面导航使系统的脉络更加清晰。通过一个配置文件，即可把握整个系统各部分之间的联系，这对于后期的维护有着莫大的好处。尤其是当另一批开发者接手这个项目时，这种优势体现得更加明显。1. 提供Exception处理机制 .<br>2. 数据库链接池管理<br>3. Struts 的Action必需是thread－safe方式，它仅仅允许一个实例去处理所有的请求。所以action用到的所有的资源都必需统一同步，这个就引起了线程安全的问题。<br>缺点：<br>Taglib是Struts的一大优势，但对于初学者而言，却需要一个持续学习的过程，甚至还会打乱你网页编写的习惯，但是，当你习惯了它时，你会觉得它真的很棒。<br>Struts将MVC的Controller一分为三，在获得结构更加清晰的同时，也增加了系统的复杂度。<br>ActionForms使用不便、无法进行单元测试（StrutsTestCase只能用于集成）<br>Spring的原理和优点<br>Spring真正的精华是它的Ioc模式实现的BeanFactory和AOP，它自己在这个基础上延伸的功能有些画蛇添足。<br>Ioc模式是什么<br>可伸缩性和重&#x2F;轻量，谁是实用系统的架构主选？<br>Spring<br>它是一个开源的项目，而且目前非常活跃；它基于IoC（Inversion of Control，反向控制）和AOP的构架多层j2ee系统的框架，但它不强迫你必须在每一层 中必须使用Spring，因为它模块化的很好，允许你根据自己的需要选择使用它的某一个模块；它实现了很优雅的MVC，对不同的数据访问技术提供了统一的 接口，采用IoC使得可以很容易的实现bean的装配，提供了简洁的AOP并据此实现Transcation Managment，等等<br>优点<br>a. Spring能有效地组织你的中间层对象，不管你是否选择使用了EJB。如果你仅仅使用了Struts或其他为J2EE的 API特制的framework，Spring致力于解决剩下的问题。<br>b. Spring能消除在许多工程中常见的对Singleton的过多使用。根据我的经验，这是一个很大的问题，它降低了系统的可测试性和面向对象的程度。<br>c. 通过一种在不同应用程序和项目间一致的方法来处理配置文件，Spring能消除各种各样自定义格式的属性文件的需要。曾经对某个类要寻找的是哪个魔法般的属性项或系统属性感到不解，为此不得不去读Javadoc甚至源编码？有了Spring，你仅仅需要看看类的JavaBean属性。Inversion of Control的使用（在下面讨论）帮助完成了这种简化。<br>d.? 通过把对接口编程而不是对类编程的代价几乎减少到没有，Spring能够促进养成好的编程习惯。<br>e. Spring被设计为让使用它创建的应用尽可能少的依赖于他的APIs。在Spring应用中的大多数业务对象没有依赖于Spring。<br>f. 使用Spring构建的应用程序易于单元测试。<br>g. Spring能使EJB的使用成为一个实现选择,而不是应用架构的必然选择。你能选择用POJOs或local EJBs来实现业务接口，却不会影响调用代码。<br>h. Spring帮助你解决许多问题而无需使用EJB。Spring能提供一种EJB的替换物，它们适用于许多web应用。例如，Spring能使用AOP提供声明性事务管理而不通过EJB容器，如果你仅仅需要与单个数据库打交道，甚至不需要一个JTA实现。<br>i. Spring为数据存取提供了一个一致的框架,不论是使用的是JDBC还是O&#x2F;R mapping产品（如Hibernate）。<br>Spring确实使你能通过最简单可行的解决办法来解决你的问题。而这是有有很大价值的。缺点：使用人数不多、jsp中要写很多代码、控制器过于灵活，缺少一个公用控制器Hibernate的原理和优点。<br>Hibernate使用了J2EE架构中的如下技术：JDBC、JTA、JNDI。其中JDBC是一个支持关系数据库操作的一个基础层；它与JNDI和JTA一起结合，使得Hibernate可以方便地集成到J2EE应用服务器中去。 　　在这里，我们不会详细地去讨论Hibernate API接口中的所有方法，我们只简要讲一下每个主要接口的功能，如果你想了解得更多的话，你可以在Hibernate的源码包中的net.sf.hibernate子包中去查看这些接口的源代码。下面我们依次讲一下所有的主要接口： 　　核心接口 　　以下5个核心接口几乎在任何实际开发中都会用到。通过这些接口，你不仅可以存储和获得持久对象，并且能够进行事务控制。 　　<br>Session接口 　　Session接口对于Hibernate 开发人员来说是一个最重要的接口。然而在Hibernate中，实例化的Session是一个轻量级的类，创建和销毁它都不会占用很多资源。这在实际项目中确实很重要，因为在客户程序中，可能会不断地创建以及销毁Session对象，如果Session的开销太大，会给系统带来不良影响。　　<br>SessionFactory 接口 　这里用到了一个设计模式――工厂模式，用户程序从工厂类SessionFactory中取得Session的实例。 　　令你感到奇怪的是SessionFactory并不是轻量级的！实际上它的设计者的意图是让它能在整个应用中共享。典型地来说，一个项目通常只需要一个SessionFactory就够了，但是当你的项目要操作多个数据库时，那你必须为每个数据库指定一个SessionFactory。 SessionFactory在Hibernate中实际起到了一个缓冲区的作用，它缓冲了Hibernate自动生成的SQL语句和一些其它的映射数据，还缓冲了一些将来有可能重复利用的数据。 　　<br>Configuration 接口 　Configuration接口的作用是对Hibernate进行配置，以及对它进行启动。在Hibernate的启动过程中，Configuration类的实例首先定位映射文档的位置，读取这些配置，然后创建一个SessionFactory对象。 　　　　<br>Query和Criteria接口 Query接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。Query经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。 　　Criteria接口与Query接口非常类似，它允许你创建并执行面向对象的标准化查询。 值得注意的是Query接口也是轻量级的，它不能在Session之外使用。 　　<br>Callback 接口 当一些有用的事件发生时――例如持久对象的载入、存储、删除时，Callback接口会通知Hibernate去接收一个通知消息。一般而言，Callback接口在用户程序中并不是必须的，但你要在你的项目中创建审计日志时，你可能会用到它。以下是它的策略接口：<br>· 主键的生成 (IdentifierGenerator 接口) 　　<br>· 本地SQL语言支持 (Dialect 抽象类) 　　<br>· 缓冲机制 (Cache 和CacheProvider 接口) 　　<br>· JDBC 连接管理 (ConnectionProvider接口) 　　<br>.事务管理 (TransactionFactory, Transaction, 和 TransactionManagerLookup 接口) 　　<br>· ORM 策略 (ClassPersister 接口) 　　<br>· 属性访问策略 (PropertyAccessor 接口) 　　<br>· 代理对象的创建 (ProxyFactory接口) 　　<br>Hibernate为以上所列的机制分别创建了一个缺省的实现，因此如果你只是要增强它的某个策略的功能的话，只需简单地继承这个类就可以了，没有必要从头开始写代码。<br>Hibernate运行在两种环境下：可管理环境和不可管理环境 　　<br>· 可管理环境――这种环境可管理如下资源：池资源管理，诸如数据库连接池和，还有事务管理、安全定义。一些典型的J2EE服务器（JBoss、Weblogic、WebSphere）已经实现了这些。 　　<br>· 不可管理环境――只是提供了一些基本的功能，诸如像Jetty或Tomcat这样的servlet容器环境。<br>优点：<br>Hibernate是JDBC的轻量级的对象封装，它是一个独立的对象持久层框架。Hibernate可以用在任何JDBC可以使用的场合，例如Java应用程序的数据库访问代码，DAO接口的实现类，甚至可以是BMP里面的访问数据库的代码。<br>Hibernate是一个和JDBC密切关联的框架，所以Hibernate的兼容性和JDBC驱动，和数据库都有一定的关系，但是和使用它的Java程序，和App Server没有任何关系，也不存在兼容性问题。<br>Hibernate不能用来直接和Entity Bean做对比，只有放在整个J2EE项目的框架中才能比较。并且即使是放在软件整体框架中来看，Hibernate也是做为JDBC的替代者出现的，而不是Entity Bean的替代者出现的，<br>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。<br>Hibernate可以应用在任何使用JDBC的场合。<br>Hibernate 使用 Java 反射机制 而不是字节码增强程序来实现透明性。<br>Hibernate 的性能非常好，因为它是个轻量级框架。 映射的灵活性很出色。<br>它支持各种关系数据库，从一对一到多对多的各种复杂关系。<br>缺点：它限制您所使用的对象模型。(例如，一个持久性类不能映射到多个表)。<br>让我再列一次我已经列n次的框架结构：<br>传统的架构：1. Session Bean &lt;-&gt; Entity Bean &lt;-&gt; DB<br>为了解决性能障碍的替代架构：<br>2. Session Bean &lt;-&gt; DAO &lt;-&gt; JDBC &lt;-&gt; DB<br>使用Hibernate来提高上面架构的开发效率的架构：<br>3. Session Bean &lt;-&gt; DAO &lt;-&gt; Hibernate &lt;-&gt; DB<br>就上面3个架构来分析：<br>1、内存消耗：采用JDBC的架构2无疑是最省内存的，Hibernate的架构次之，EB的架构1最差。<br>2、运行效率：如果JDBC的代码写的非常优化，那么JDBC架构运行效率最高，但是实际项目中，这一点几乎做不到，这需要程序员非常精通JDBC，运用Batch语句，调整PreapredStatement的Batch Size和Fetch Size等参数，以及在必要的情况下采用结果集cache等等。而一般情况下程序员是做不到这一点的。因此Hibernate架构表现出最快的运行效率。EB的架构效率会差的很远。<br>3、开发效率：在有JBuilder的支持下以及简单的项目，EB架构开发效率最高，JDBC次之，Hibernate最差。但是在大的项目，特别是持久层关系映射很复杂的情况下，Hibernate效率高的惊人，JDBC次之，而EB架构很可能会失败。3.介绍FREEMARK技术 URLWRITE技术<br>FreeMarker允许Java servlet保持图形设计同应用程序逻辑的分离，这是通过在模板中密封HTML完成的。模板用servlet提供的数据动态地生成 HTML。模板语言是强大的直观的，编译器速度快，输出接近静态HTML页面的速度。<br>　　FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯Java编写<br>　　FreeMarker被设计用来生成HTML Web页面，特别是基于MVC模式的应用程序<br>　　虽然FreeMarker具有一些编程的能力，但通常由Java程序准备要显示的数据，由FreeMarker生成页面，通过模板显示准备的数据<br>　　FreeMarker不是一个Web应用框架，而适合作为Web应用框架一个组件<br>　　FreeMarker与容器无关，因为它并不知道HTTP或Servlet；FreeMarker同样可以应用于非Web应用程序环境<br>　　FreeMarker更适合作为Model2框架（如Struts）的视图组件，你也可以在模板中使用JSP标记库<br>　　FreeMarker是免费的把动态的地址转换成静态的地址，增大搜索引擎化，我解释的不是很明白，大致就是这样的吧， 下面给大家一个小例子，大家需要帮助多的看看。。indexx.jsp:&lt;%@ page language&#x3D;”java” import&#x3D;”java.util.*“ pageEncoding&#x3D;”UTF-8”%&gt;<br>urlrewrite.xml :(和web.xml同级)&lt;?xml version&#x3D;”1.0” encoding&#x3D;”utf-8”?&gt;&lt;!DOCTYPE urlrewrite PUBLIC “-&#x2F;&#x2F;tuckey.org&#x2F;&#x2F;DTD UrlRewrite 3.0&#x2F;&#x2F;EN”<br>“<a target="_blank" rel="noopener" href="http://tuckey.org/res/dtds/urlrewrite3.0.dtd&quot;">http://tuckey.org/res/dtds/urlrewrite3.0.dtd&quot;</a>&gt;&lt;urlrewrite&gt;<rule><br><from>&#x2F;world&#x2F;(\w+)&#x2F;(\w+)</from><br><to>&#x2F;indexx.jsp?country&#x3D;$1&amp;city&#x3D;$2</to><br></rule>&lt;&#x2F;urlrewrite&gt;web.xml: &lt;display-name&gt;url rewrite filter build&lt;&#x2F;display-name&gt; &lt;description&gt;build context&lt;&#x2F;description&gt;<filter><br><filter-name>UrlRewriteFilter</filter-name><br><filter-class>org.tuckey.web.filters.urlrewrite.UrlRewriteFilter</filter-class><br><init-param><br><param-name>confReloadCheckInterval</param-name><br><param-value>30</param-value><br></init-param><br><init-param><br><param-name>logLevel</param-name><br><param-value>DEBUG</param-value><br></init-param><br><init-param><br><param-name>statusEnabled</param-name><br><param-value>true</param-value><br></init-param><br><init-param><br><param-name>statusPath</param-name><br><param-value>&#x2F;status</param-value><br></init-param><br></filter><br><filter-mapping><br><filter-name>UrlRewriteFilter</filter-name><br><url-pattern>&#x2F;*</url-pattern><br></filter-mapping>4.C&#x2F;S与B&#x2F;S的区别<br>C&#x2F;S是Client&#x2F;Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。C&#x2F;S 与 B&#x2F;S 区别：<br>１．硬件环境不同: C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C&#x2F;S更强的适应范围, 一般只要有操作系统和浏览器就行<br>２．对安全要求不同 ：C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C&#x2F;S 结构适宜. 可以通过B&#x2F;S发布部分可公开信息.B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同 ：　C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上.<br>４．软件重用不同： C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性好.　B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。<br>５．系统维护不同 ：C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.<br>６．处理问题不同 ：C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C&#x2F;S无法作到的. 与操作系统平台关系最小.<br>７．用户接口不同： C&#x2F;S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.<br>８．信息流不同 ：　C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B&#x2F;S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心。5.怎么布署项目（不在MYECLIPSE下部署）到外网<br>在Tomcat中部署Java Web应用程序在Tomcat中部署Java Web应用程序有两种方式：静态部署和动态部署。在下文中<code>$CATALINA_HOME指的是Tomcat根目录。 一、静态部署 静态部署指的是我们在服务器启动之前部署我们的程序，只有当服务器启动之后，我们的Web应用程序才能访问。以下3中方式都可以部署： 1、将PetWeb目录拷贝到$</code>CATALINA_HOME\webapps下，然后启动服务器就可以了。这种方式比较简单，但是web应用程序必须在webapps目录下。访问地址如下：<br><a target="_blank" rel="noopener" href="http://localhost:8080/PetWeb/">http://localhost:8080/PetWeb/</a><br>2、这种方式可以不必将PetWeb目录拷贝到webapps下，直接在F:\部署。方法如下，更改<code>$CATALINA_HOME\conf\server.xml文件，在&lt;host&gt;标签内添加&lt;Context&gt;标签，内容如下： &lt;Context docBase=&quot;F:/PetWeb&quot; reloadable=&quot;false&quot; path=&quot;/Pet&quot;/&gt; 其中reloadable=&quot;false&quot;表示当应用程序中的内容发生更改之后服务器不会自动加载，这个属性在开发阶段通常都设为true，方便开发，在发布阶段应该设置为false，提高应用程序的访问速度。docBase为路径，可以使用绝对路径，也可以使用相对路径，相对路径相对于webapps。path属性的值是访问时的根地址。访问地址如下：http://localhost:8080/Pet/ 3、这种方式和第二种方式差不多，但是不是在Server.xml文件中添加Context标签，而是在$</code>CATALINA_HOME\conf\Catalina\localhost中添加一个xml文件，如Pet.xml，内容如下： &lt;Context docBase&#x3D;”F:&#x2F;PetWeb” reloadable&#x3D;”false” &#x2F;&gt;大家可能发现和第二种方式差不多，但是缺少了path属性，这种方式服务器会使用.xml的名字作为path属性的值。访问地址如下：<a target="_blank" rel="noopener" href="http://localhost:8080/Pet/">http://localhost:8080/Pet/</a> 我们刚才是将PetWeb文件夹部署在了服务器中，我们知道可以将Web应用程序的内容打成.war包，然后在部署在服务器上。打包请参考如下步骤：<br>1、打开命令提示符（Start–&gt;Run–&gt;cmd）<br>2、设置jdk环境变量（如果我教过的学生不会配置，以后别说孙老师教过你）<br>3、在命令提示符中进入F:\PetWeb文件后，键入如下命令：jar ..\Pet.war <em>.</em> 这样在F:\下应该有Pet.war文件。其中..表示当前目录的父目录。<br>部署Pet.war文件非常简单，将刚才有docBase&#x3D;”F:\PetWeb”更改为docBase&#x3D;”F:\Pet.war”或者直接将其拷贝到 webapps下也可以。重新启动服务器就可以将Pet.war部署为一个Web应用程序了。如果你够细心的话你会发现，服务器将Pet.war文件解开，并且在webapps下面又生成了一个Pet文件夹，然后把Pet.war的内容拷贝到里面去了。我们可以通过以下方式取消自动解压缩，配置方式如下： &lt;Context docBase&#x3D;”F:&#x2F;PetWeb” reloadable&#x3D;”false” unpackWAR&#x3D;”false”&#x2F;&gt;<br>二、动态部署<br>动态部署是指可以在服务器启动之后部署web应用程序，而不用重新启动服务器。动态部署要用到服务器提供的manager.war文件，如果在<code>$CATALINA_HOME\webapps\下没有该文件，你必须去重新下载tomcat，否则不能完成以下的功能。要想使用该管理程序必须首先编辑$</code>CATALINA_HOME\conf\tomcat-users.xml文件，内容如下：关于这个文件的更多内容，请参考Java Web应用程序的安全模型二 &lt;tomcat-users&gt; &lt;role rolename&#x3D;”tomcat”&#x2F;&gt; &lt;role rolename&#x3D;”role1”&#x2F;&gt; &lt;role rolename&#x3D;”manager”&#x2F;&gt; &lt;user username&#x3D;”coresun” password&#x3D;”coresun” roles&#x3D;”manager”&#x2F;&gt; &lt;user username&#x3D;”tomcat” password&#x3D;”tomcat” roles&#x3D;”tomcat”&#x2F;&gt; &lt;user username&#x3D;”both” password&#x3D;”tomcat” roles&#x3D;”tomcat,role1”&#x2F;&gt; &lt;user username&#x3D;”role1” password&#x3D;”tomcat” roles&#x3D;”role1”&#x2F;&gt; &lt;&#x2F;tomcat-users&gt;<br>然后在浏览器中键入如下地址：<br><a target="_blank" rel="noopener" href="http://localhost:8080/%E5%BA%94%E8%AF%A5%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%8A%A0%E8%8F%B2%E7%8C%AB%E4%BA%86%E5%90%A7%E3%80%82%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%E7%9A%84Tomcat">http://localhost:8080/应该看到一个漂亮的加菲猫了吧。点击左边的Tomcat</a> Manager链接，提示输入用户名和密码，本文都是coresun，然后可以看到以下页面：<br>在Context Path(option):中输入&#x2F;Pet<br>XML Configration file URL中要指定一个.xml文件，比如我们在F:\下建立一个Pet.xml文件，内容如下： &lt;Context reloadable&#x3D;”false” &#x2F;&gt;docBase不用写了，因为在下一个文本框中填入。或者更简单点，这个文本框什么都不填。<br>在WAR or Directory URL:中键入F:\PetWet或者F:\Pet.war都可以，然后点击Deploy按钮，看看上面是不是已经看到了你web应用程序，名字就是你Context Path(option):中的名字。如果你部署.war文件还有更加简单的方式，下面还有个Select WAR file uploae点击浏览选择.war文件，然后点击Deploy也可以6.为什么要使用HIBERMATE框架，描述HIBERMATE的映射（如一对的 多对的）SSH中的H指的就是Hibernate ，这个已经被炒烂了的o&#x2F;r mapping的开源项目，那为什么我们在项目中的和数据库交互的那块操作（说的书面点就是持久化部分）要用它了，它比我们以前用的JDBC的硬编码或是 使用了DTO（POJO），DAO这样的模式的模块又好在哪里了？（当然JDBC硬编码的做法确实比较ugly,现在这样做的也比较少了吧）<br>要想说清这个，当然有很多种说法，观点也不尽一致，所以我们先来看看HIbernate具体都有些什么，我们怎么来使用它，然后再对比和分析。<br>Hibernate既然是持久化的框架，干得自然是和数据库打交道的事，所以其概念和使用上应该不难，但是其文档（中文）也有200多页，可以看出其内容 还是不少（在这里向翻译文档的团队表示感谢，呵呵）。从整体上看要使用它需要两种配置文件，一个是hibernate.cfg.xml，它是与数据库连接 的配置文件（事务类型也是在其中配置的），支持普通的JDBC连接，也支持使用JNDI的数据源连接，它是放在class-path下；另一个配置文件是 xxx.hbm.xml，它是某个POJO和一个或多个数据库表的对应关系的配置文件，也即是o&#x2F;r映射的配置文件，也是放在class-path下，而 且在hibernate.cfg.xml中要引入这些xxx.hbm.xml。<br>我们在代码阶段要先new一个Configuration，它需要载入hibernate.cfg.xml；然后根据这个Configuration build出一个SessionFactory，注意当sessionFactory建立后，如果在改动configuration, sessionFactory不会受影响，而且sessionFactory的建立是很耗资源的，所以我们对一个数据库的应用应该只创建一个 SessionFactory。如果我们的操作要涉及多个库，我们可以配置多个hibernate.cfg.xml，从而生成多个 Configuration，进而创建多个SessionFactory。<br>当得到SessionFactory后我们就可以建立Session对象了，我个人感觉Session有点像JDBC中的Connection和 Statement的混合，因为它确实是和数据库连接的一个具体实例，同时它下面有save,update等方法，可以操作数据库，所以又不单单是个 Connection，也有Statement的意思。得到了Session后，我们通过它下面的各种方法，就可以完成对对象的CRUD，那在 hibernate中对象和数据库表之间是有对应关系的，所以通过对对象的操作，hibernate自动完成对数据库表的操作，它底层也是通过JDBC的 PreparedStatement来完成的。<br>但在hibernate3.x以后情况又有些不同了，在3.x中，HQL的功能加强了很多，具有了update,delete的功能，再加上 Session的find方法的取消，所以对于Query的使用越来越多，于是Session就越来越像Connection了。HQL很像传统的SQL 语言，但它们两者还是有很明显的不同，SQL面向的是二维的结构化的数据，而HQL则是面向的数据对象。<br>HQL中包括简单的实体查询，对象属性的查询（相当于SQL 中的select某几个字段），分组和排序，where条件查询（注意在这里，我们为了避免sql injection问题，对于条件变量要采用现在HQL语句中用占位符的方法，再set进去，相当于PrepareStatement），联合查询 （SQL中的join) ，子查询，删除和修改。对于HQL，我们还可以在配置文件中写，然后通过代码找到，不用再代码中直接写HQL字符串。另外有一点要说明的是我们如果要调用 存储过程，则相对麻烦而且只能调用带返回结果集的存储过程，简单的做法是不用hibernate的API来做，我们可以通过Session得到 Connection对象，从而按照JDBC的方式来调用，本身hibernate并不提倡用存储过程 ，它认为存储过程和具体的DBMS有很强的耦合性。。hibernate3中还提供了一个Criteria的对象来进行查询工作，它本身只是一个查询容 器，具体的查询条件要通过Criteria.add方法来添加到对象中。不过其功能现在没有HQL强。而且在hibernate3中还提供了一个 Criteria的实现–DetachedCriteria，它可以脱离Session实例独立存在，具体的就不多说了，用到的时候看看文档吧。<br>由以上的知识点我们不能看出hibernate是比较简单和容易使用的，但事实并不完全是这样，我们知道o&#x2F;r mapping中，数据库表是二维的关系型数据库表，而我们的POJO是面向对象的结构（面向对象的特点有封装，继承，多态），这两者之间的映射并不是那 么简单，下面我们来看一下hibernate中比较难的那个方面。<br>一个是复杂的实体映射，另一个是数据关联int 和 Integer 有什么区别<br>1.Integer 是对象类型 int是原始类型<br>适用场合有很大的不同 之所以要把int封装成Integer 型 是因为<br>很多方法参数就只接收对象类型(Object)<br>还比如 范型 就只支持 对象类型<br>2.如果在数据库操作中某数值列允许为null的话，那接受该列数据的类型就只能为<br>Integer，而不能为int，所以在一般性的持久化对象中尽量少地使用基本类型，<br>除非确定它不会为空。<br>3.类可以是null 但是基本数据类型不能为空<br>Ingeter i&#x3D;null; int j&#x3D;i;<br>对象的比较不能用＝＝号了 呵呵<br>Integer i＝0; Integer j&#x3D;0;<br>但是 i!&#x3D;j<br>虽然你说你执行了以下这个程序：<br>public static void main(String[] args) {<br>Integer b &#x3D; 0;<br>int c &#x3D; 0;<br>if (b &#x3D;&#x3D; c) {<br>System.out.println(true);<br>} else {<br>System.out.println(false);<br>}<br>输出的结果为true，但并不意味这他们两个不同类型的值就相等，是因为其过程中系统自动拆箱造成的，b&#x3D;&#x3D;c的时候java自动拆箱了,最后比较的是两个int下列说法错误的有（c ）<br>A． 能被java.exe成功运行的java class文件必须有main()方法<br>B． J2SDK就是Java API<br>C． Appletviewer.exe可利用jar选项运行.jar文件判断题<br>Java程序中的起始类名称必须与存放该类的文件名相同。　　<br>Unicode是用16位来表示一个字的吗。√×　　<br>原生类中的数据类型均可任意转换吗。　机试题：<br>1.新闻查询Web程序要求：<br>使用 MVC设计模式，运用jsp、Bean及Servlet，结合jdbc制作一个简单的新闻查询Web程序。<br>需要进行查询的新闻如下所示：新闻标题	发布时间	新闻内容<br>微软向非洲支援二手电脑	2005-06-09 15:49:00	微软在最近宣布它正计划向非洲国家提供技术帮助，以加速该地区的数字化进程。据悉，微软已经与纳米比亚政府达成了协议，将在两年内向该国13所学校提供从发达国家淘汰的二手电脑，这些电脑将运行Windows系统，可以登录Google、雅虎等热门网站，不过微软并没有透露出售Windows系统给这些学校的价格。<br>韩国失窃手机大量流入中国	2005-06-09 10:49:44	据韩国信息部提供的消息称，目前已经发现中国商人在韩国以每部400—500元(人民币)的价格收购被盗或丢失的市价1—2万元(人民币)的手机，然后成批走私到中国，以每部3000元以下的价格出售。<br>明基宣布收购西门子手机	2005-06-07 16:50:33	明基7日下午正式对外宣布收购德国西门子手机事业，这起并购将使BenQ成为全球第四大手机品牌、大中华区第一大手机科技公司，合并后公司年营收将超过100亿美元。<br>Google股价飙升	2005-06-03 11:30:20	现今的Google已经成为华尔街的宠儿。上市后的前三个季度里，Google的业绩均超过了分析师的预期。主要竞争对手雅虎和微软都在广告战中大把烧钱，而Google却毫不费力的依靠人们的口口相传继续保持着搜索市场的领先位置。与此同时，Google的股价也一路飙升，目前已较发行价上涨226%，达到227美元。使用jsp制作查询页面，在输入框中输入查询关键字内容，然后将查询关键字提交到servlet进行处理，在bean中制作针对关键字执行查询的部分，并将查询结果返回，最后将查询结果的标题按照时间顺序在结果页面中输出成为规则的列表。点击标题，在弹出的新窗口中显示本条新闻的全部详细内容，包括标题，发布时间，以及新闻内容。注意：本题目的重点在于提交查询关键字时，要求可以同时提交多项关键字，每项关键字之间用空格间隔，查询结果范围为全部满足多项关键字的条目，也就是说，假如同时提出了三个关键字，那么只有在标题或内容中都能够找到这三个查询关键字的条目才会进入查询结果。提交的关键字越多，查询出来的结果就越少，如果由于提交的关键字太多，造成没有条目符合查询请求，就需要在页面中显示“查询无结果”字样，不能造成异常。<br>create table t_news<br>(<br>id int primary key,<br>title char(20),<br>pubTime Date,<br>cont char(50)<br>)其他1. 什么是幂等？什么情况下需要考虑幂等？你怎么解决幂等的问题？<br>Java<br>2. 多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决<br>并发的问题？你会选择加什么样的锁？<br>3. JAVA的AQS是否了解，它是⼲嘛的？<br>4. 除了synchronized关键字之外，你是怎么来保障线程安全的？<br>5. 什么时候需要加volatile关键字？它能保证线程安全吗？<br>6. 线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部<br>塞满了之后，还是忙，再提交会发⽣什么？<br>7. Tomcat本身的参数你⼀般会怎么调整？<br>8. synchronized关键字锁住的是什么东⻄？在字节码中是怎么表示的？在内<br>存中的对象上表现为什么？<br>9. wait&#x2F;notify&#x2F;notifyAll⽅法需不需要被包含在synchronized块中？这是为什<br>么？<br>10. ExecutorService你⼀般是怎么⽤的？是每个service放⼀个还是⼀个项⽬<br>⾥⾯放⼀个？有什么好处？<br>Spring<br>11. 你有没有⽤过Spring的AOP? 是⽤来⼲嘛的? ⼤概会怎么使⽤？<br>12. 如果⼀个接⼝有2个不同的实现, 那么怎么来Autowire⼀个指定的实现？<br>13. Spring的声明式事务 @Transaction注解⼀般写在什么位置? 抛出了异常<br>会⾃动回滚吗？有没有办法控制不触发回滚?<br>14. 如果想在某个Bean⽣成并装配完毕后执⾏⾃⼰的逻辑，可以什么⽅式实<br>现？<br>15. SpringBoot没有放到web容器⾥为什么能跑HTTP服务？<br>16. SpringBoot中如果你想使⽤⾃定义的配置⽂件⽽不仅仅是<br>application.properties，应该怎么弄？<br>17. SpringMVC中RequestMapping可以指定GET, POST⽅法么？怎么指定？<br>18. SpringMVC如果希望把输出的Object(例如XXResult或者XXResponse)这<br>种包装为JSON输出, 应该怎么处理?<br>19. 怎样拦截SpringMVC的异常，然后做⾃定义的处理，⽐如打⽇志或者包装<br>成JSON<br>MySQL<br>20. 如果有很多数据插⼊MYSQL 你会选择什么⽅式?<br>21. 如果查询很慢，你会想到的第⼀个⽅式是什么？索引是⼲嘛的?<br>22. 如果建了⼀个单列索引，查询的时候查出2列，会⽤到这个单列索引吗？<br>23. 如果建了⼀个包含多个列的索引，查询的时候只⽤了第⼀列，能不能⽤上<br>这个索引？查三列呢？<br>24. 接上题，如果where条件后⾯带有⼀个 i + 5 &lt; 100 会使⽤到这个索引吗？<br>25. 怎么看是否⽤到了某个索引？<br>26. like %aaa%会使⽤索引吗? like aaa%呢?<br>27. drop、truncate、delete的区别？<br>28. 平时你们是怎么监控数据库的? 慢SQL是怎么排查的？<br>29. 你们数据库是否⽀持emoji表情，如果不⽀持，如何操作?<br>30. 你们的数据库单表数据量是多少？⼀般多⼤的时候开始出现查询性能急<br>剧下降？<br>31. 查询死掉了，想要找出执⾏的查询进程⽤什么命令？找出来之后⼀般你<br>会⼲嘛？<br>32. 读写分离是怎么做的？你认为中间件会怎么来操作？这样操作跟事务有<br>什么关系？<br>33. 分库分表有没有做过？线上的迁移过程是怎么样的？如何确定数据是正<br>确的？<br>JVM<br>34. 你知道哪些或者你们线上使⽤什么GC策略? 它有什么优势，适⽤于什么<br>场景？<br>35. JAVA类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？双亲委派机<br>制是什么意思？有什么好处？<br>36. 如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃<br>定义的类加载器吗？<br>37. 堆内存设置的参数是什么？<br>38. Perm Space中保存什么数据? 会引起OutOfMemory吗？<br>39. 做gc时，⼀个对象在内存各个Space中被移动的顺序是什么？<br>40. 你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理<br>过程中有哪些收获？<br>41. 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是<br>你们会通过什么⽅式来指定⼤⼩?<br>42. Jstack是⼲什么的? Jstat呢? 如果线上程序周期性地出现卡顿，你怀疑可<br>能是gc导致的，你会怎么来排查这个问题？线程⽇志⼀般你会看其中的什么<br>部分？<br>43. StackOverFlow异常有没有遇到过？⼀般你猜测会在什么情况下被触<br>发？如何指定⼀个线程的堆栈⼤⼩？⼀般你们写多少？<br>Linux命令<br>44. ⽇志特别⼤只想看最后100⾏怎么弄? 如果想⼀直看⽇志的持续输出，⽤<br>什么命令?<br>45. 如果⽇志⼀边输出，⼀边想实时看到有没有某个关键字应该怎么弄？<br>46. grep如果忽略⼤⼩写应该怎么弄? 正则表达式呢？<br>47. vim往下⼀⾏是什么键？往下30⾏呢? 跳到⽂件末尾⼀⾏是什么? 跳回来<br>是什么? 向后搜索是什么?<br>48. 如果有个⽂本⽂件，按空格作为列的分隔符，如果想统计第三列⾥⾯的每<br>个单词的出现次数应该怎么弄？<br>49. 如果把上⾯的出现次数排个序应该怎么弄? 想按照数字本身的顺序⽽不是<br>字符串的顺序排列怎么弄？<br>50. Linux环境变量是以什么作为分隔符的？环境变量通过什么命令设置？<br>51. 给某个⽂件权设置限⽐如设置为644 是⽤什么命令？这个6是什么意思？<br>52. Linux下⾯如果想看某个进程的资源占⽤情况是怎么看的？系统load⼤概<br>指的什么意思？你们线上系统load⼀般多少？如果⼀个4核机器，你认为多<br>少load是⽐较正常的？top命令⾥⾯按⼀下1会发⽣什么?<br>53. top命令⾥⾯，有时候所有进程的CPU使⽤率加起来超过100%是怎么回<br>事？<br>54. 还有哪些查看系统性能或者供你发现问题的命令？你⼀般是看哪个参<br>数？<br>55. 想看某个进程打开了哪些⽹络连接是什么命令？⾥⾯连接的状态你⽐较<br>关⼼哪⼏种？<br>-- 偏题<br>56. 有没有做过Linux系统参数⽅⾯的优化，⼤概优化过什么？<br>57. 系统参数⾥⾯有个叫做backlog的可以⽤来⼲什么？<br>58. 查看⽹络连接发现好多TIME_WAIT 可能是什么原因？对你的应⽤会有什<br>么影响？你会选择什么样的⽅式来减少这些TIME_WAIT<br>59. 可否介绍⼀下TCP三次握⼿的过程，如果现在有个⽹络程序，你⽤第三⽅<br>的library来发送数据，你怀疑这个library发送的数据有问题，那么怎么来验<br>证？tcpdump导出的⽂件你⼀般是怎么分析的？<br>60. KeepAlive是⽤来⼲什么的？这样的好处是什么？<br>Redis<br>-- 开发<br>61. 缓存穿透可以介绍⼀下么？你认为应该如何解决这个问题<br>62. 你是怎么触发缓存更新的？(⽐如设置超时时间(被动⽅式), ⽐如更新的时<br>候主动update)？如果是被动的⽅式如何控制多个⼊⼝同时触发某个缓存更<br>新？<br>63. 你们⽤Redis来做什么？为什么不⽤其他的KV存储例如Memcached,<br>Cassandra等?<br>64. 你们⽤什么Redis客户端? Redis⾼性能的原因⼤概可以讲⼀些?<br>65. 你熟悉哪些Redis的数据结构? zset是⼲什么的? 和set有什么区别?<br>66. Redis的hash, 存储和获取的具体命令叫什么名字?<br>67. LPOP和BLPOP的区别?<br>68. Redis的有⼀些包含SCAN关键字的命令是⼲嘛的? SCAN返回的数据量是<br>固定的吗?<br>69. Redis中的Lua有没有使⽤过? 可以⽤来做什么? 为什么可以这么⽤?<br>70. Redis的Pipeline是⽤来⼲什么的?<br>-- 运维<br>71. Redis持久化⼤概有⼏种⽅式? aof和rdb的区别是什么? AOF有什么优缺<br>点吗?<br>72. Redis Replication的⼤致流程是什么? bgsave这个命令的执⾏过程?<br>-- 偏题<br>73. 如果有很多 KV数据要存储到Redis, 但是内存不⾜, 通过什么⽅式可以缩<br>减内存? 为什么这样可以缩⼩内存?<br>74. Redis中List, HashTable都⽤到了ZipList, 为什么会选择它?<br>监控、稳定性<br>75. 业务⽇志是通过什么⽅式来收集的？<br>76. 线上机器如何监控？采⽤什么开源产品或者⾃研的产品？它是分钟级的还<br>是秒级的？<br>77. 如果让你来想办法收集⼀个JAVA后端应⽤的性能数据，你会在意哪些⽅<br>⾯? 你会选择什么样的⼯具、思路来收集?<br>78. ⼀般你调⽤第三⽅的时候会不会监控调⽤情况？java 基于TCP协议的Socket编程和通信<br>在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)程序，简称客户端，而在第一次通讯中等待连接的程序被称作服务器端(Server)程序，简称服务器。一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。<br>“请求-响应”模式：1. Socket类：发送TCP消息。<br>2. ServerSocket类：创建服务器。<br>套接字是一种进程间的数据交换机制。这些进程既可以在同一机器上，也可以在通过网络连接的不同机器上。换句话说，套接字起到通信端点的作用。单个套接字是一个端点，而一对套接字则构成一个双向通信信道，使非关联进程可以在本地或通过网络进行数据交换。一旦建立套接字连接，数据即可在相同或不同的系统中双向或单向发送，直到其中一个端点关闭连接。套接字与主机地址和端口地址相关联。主机地址就是客户端或服务器程序所在的主机的IP地址。端口地址是指客户端或服务器程序使用的主机的通信端口。<br>在客户端和服务器中，分别创建独立的Socket，并通过Socket的属性，将两个Socket进行连接，这样，客户端和服务器通过套接字所建立的连接使用输入输出流进行通信。<br>TCP&#x2F;IP套接字是最可靠的双向流协议，使用TCP&#x2F;IP可以发送任意数量的数据。<br>实际上，套接字只是计算机上已编号的端口。如果发送方和接收方计算机确定好端口，他们就可以通信了。<br>如图所示为客户端与服务器端的通信关系图：TCP&#x2F;IP通信连接的简单过程：<br>位于A计算机上的TCP&#x2F;IP软件向B计算机发送包含端口号的消息，B计算机的TCP&#x2F;IP软件接收该消息，并进行检查，查看是否有它知道的程序正在该端口上接收消息。如果有，他就将该消息交给这个程序。<br>要使程序有效地运行，就必须有一个客户端和一个服务器。<br>通过Socket的编程顺序：1. 创建服务器ServerSocket，在创建时，定义ServerSocket的监听端口(在这个端口接收客户端发来的消息)。<br>2. ServerSocket调用accept()方法，使之处于阻塞状态。<br>3. 创建客户端Socket，并设置服务器的IP及端口。<br>4. 客户端发出连接请求，建立连接。<br>5. 分别取得服务器和客户端Socket的InputStream和OutputStream。<br>6. 利用Socket和ServerSocket进行数据传输。<br>7. 关闭流及Socket。<br>【示例12-7】TCP：单向通信Socket之服务器端</p><p>【示例12-8】TCP：单向通信Socket之客户端</p><p>【示例12-9】TCP：双向通信Socket之服务器端</p><p>【示例12-10】TCP：双向通信Socket之客户端</p><p>执行结果如图所示菜鸟雷区<br>运行时，要先启动服务器端，再启动客户端，才能得到正常的运行效果。<br>但是，上面这个程序，必须按照安排好的顺序，服务器和客户端一问一答!不够灵活!!可以使用多线程实现更加灵活的双向通讯!!<br>服务器端：一个线程专门发送消息，一个线程专门接收消息。<br>客户端：一个线程专门发送消息，一个线程专门接收消息。<br>【示例12-11】TCP：聊天室之服务器端<br>【示例12-12】TCP：聊天室之客户端<br>执行结果如图所示：<br>44. JVM<br>(1) 基本概念：<br>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、<br>一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接<br>的交互。<br>(2) 运行过程：<br>13&#x2F;04&#x2F;2018 Page 20 of 283<br>我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，<br>而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。<br>也就是如下：<br>① Java 源文件—-&gt;编译器—-&gt;字节码文件<br>② 字节码文件—-&gt;JVM—-&gt;机器码<br>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够<br>跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会<br>存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不<br>能共享。<br>2.1.线程<br>这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。<br>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓<br>冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。<br>Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可<br>用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，<br>13&#x2F;04&#x2F;2018 Page 21 of 283<br>会释放原生线程和 Java 线程的所有资源。<br>Hotspot JVM 后台运行的系统线程主要有下面几个：<br>虚拟机线程<br>（VM thread）<br>这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当<br>堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-the￾world 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。<br>周期性任务线程 这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。<br>GC 线程 这些线程支持 JVM 中不同的垃圾回收活动。<br>编译器线程 这些线程在运行时将字节码动态编译成本地平台相关的机器码。<br>信号分发线程 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</p><p>2.8. JAVA IO&#x2F;NIO<br>2.8.1. 阻塞 IO 模型<br>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内<br>核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用<br>户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用<br>13&#x2F;04&#x2F;2018 Page 35 of 283<br>户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data &#x3D; socket.read();如果数据没有就<br>绪，就会一直阻塞在 read 方法。<br>2.8.2. 非阻塞 IO 模型<br>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个<br>error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备<br>好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO<br>不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：<br>while(true){<br>data &#x3D; socket.read();<br>if(data!&#x3D; error){<br>处理数据<br>break;<br>}<br>}<br>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就<br>绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。<br>2.8.3. 多路复用 IO 模型<br>多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO<br>模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真<br>正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个<br>socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有<br>socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通<br>过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这<br>种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当<br>socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连<br>接数比较多的情况。<br>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态<br>时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效<br>率要比用户线程要高的多。<br>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件<br>逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件<br>迟迟得不到处理，并且会影响新的事件轮询。<br>13&#x2F;04&#x2F;2018 Page 36 of 283<br>2.8.4. 信号驱动 IO 模型<br>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函<br>数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到<br>信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。<br>2.8.5. 异步 IO 模型<br>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就<br>可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，<br>它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内<br>核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程<br>发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何<br>进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接<br>去使用数据了。<br>也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完<br>成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的<br>读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据<br>已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号<br>表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。<br>注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。<br>更多参考： <a target="_blank" rel="noopener" href="http://www.importnew.com/19816.html">http://www.importnew.com/19816.html</a><br>2.8.1. JAVA IO 包<br>13&#x2F;04&#x2F;2018 Page 37 of 283<br>2.8.2. JAVA NIO<br>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统 IO 基于字节流和字<br>符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区<br>中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，<br>数据到达）。因此，单个线程可以监听多个数据通道。<br>13&#x2F;04&#x2F;2018 Page 38 of 283<br>NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。<br>2.8.2.1. NIO 的缓冲区<br>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何<br>地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓<br>存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在<br>缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所<br>有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的<br>数据。<br>2.8.2.2. NIO 的非阻塞<br>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有<br>一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，<br>使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可<br>用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以<br>继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它<br>完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上<br>执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。<br>13&#x2F;04&#x2F;2018 Page 39 of 283<br>13&#x2F;04&#x2F;2018 Page 40 of 283<br>2.8.3. Channel<br>首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个<br>等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向<br>的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有：<br>55. FileChannel<br>56. DatagramChannel<br>57. SocketChannel<br>58. ServerSocketChannel<br>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。<br>下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。<br>2.8.4. Buffer<br>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、<br>网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。<br>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送<br>数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必<br>须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。<br>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：<br>ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、<br>ShortBuffer<br>2.8.5. Selector<br>Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事<br>件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可<br>以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用<br>函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护<br>多个线程，并且避免了多线程之间的上下文切换导致的开销。<br>71. JAVA 集合<br>3.1.接口继承关系和实现<br>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。<br>72. Collection：Collection 是集合 List、Set、Queue 的最基本的接口。<br>73. Iterator：迭代器，可以通过迭代器遍历集合中的数据<br>74. Map：是映射表的基础接口<br>13&#x2F;04&#x2F;2018 Page 46 of 283<br>13&#x2F;04&#x2F;2018 Page 47 of 283<br>3.2.List<br>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类：<br>分别是 ArrayList、Vector 和 LinkedList。<br>3.2.1. ArrayList（数组）<br>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数<br>组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数<br>组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进<br>行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br>3.2.2. Vector（数组实现、线程同步）<br>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一<br>个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，<br>访问它比访问 ArrayList 慢。<br>3.2.3. LinkList（链表）<br>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较<br>慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆<br>栈、队列和双向队列使用。<br>13&#x2F;04&#x2F;2018 Page 48 of 283<br>3.3.Set<br>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重<br>复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断<br>的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方<br>法。<br>3.3.1.1. HashSet（Hash 表）<br>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不<br>同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的<br>hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较<br>equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是<br>同一个元素。<br>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相<br>同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情<br>况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。<br>13&#x2F;04&#x2F;2018 Page 49 of 283<br>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元<br>素。<br>3.3.1.2. TreeSet（二叉树）<br>75. TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增<br>加一个对象都会进行排序，将对象插入的二叉树指定的位置。<br>76. Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自<br>己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使<br>用。<br>77. 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序<br>78. 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整<br>数、零或正整数。<br>3.3.1.3. LinkHashSet（HashSet+LinkedHashMap）<br>对 于 LinkedHashSet 而 言 ， 它 继 承与 HashSet、 又 基于 LinkedHashMap 来 实 现的 。<br>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法<br>操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并<br>通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操<br>作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。<br>13&#x2F;04&#x2F;2018 Page 50 of 283<br>3.4.Map<br>3.4.1. HashMap（数组+链表+红黑树）<br>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快<br>的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记<br>录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导<br>致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使<br>HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍<br>HashMap 的结构。<br>3.4.1.1. JAVA7 实现<br>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色<br>的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。<br>79. capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。<br>80. loadFactor：负载因子，默认为 0.75。<br>13&#x2F;04&#x2F;2018 Page 51 of 283<br>81. threshold：扩容的阈值，等于 capacity * loadFactor<br>3.4.1.2. JAVA8 实现<br>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑<br>树 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的<br>具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决<br>于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，<br>会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br>3.4.2. ConcurrentHashMap<br>3.4.2.1. Segment 段<br>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的<br>意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个<br>segment。<br>3.4.2.2. 线程安全（Segment 继承 ReentrantLock 加锁）<br>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每<br>个 Segment 是线程安全的，也就实现了全局的线程安全。<br>13&#x2F;04&#x2F;2018 Page 52 of 283<br>3.4.2.3. 并行度（默认 16）<br>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，<br>也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支<br>持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时<br>候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实<br>每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。<br>3.4.2.4. Java8 实现 （引入了红黑树）<br>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。<br>13&#x2F;04&#x2F;2018 Page 53 of 283<br>3.4.3. HashTable（线程安全）<br>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，<br>并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，<br>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全<br>的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。<br>3.4.4. TreeMap（可排序）<br>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。<br>参考：<br>3.4.5. LinkHashMap（记录插入顺序）<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。<br>参考 1：<a target="_blank" rel="noopener" href="http://www.importnew.com/28263.html">http://www.importnew.com/28263.html</a><br>参考 2：<a target="_blank" rel="noopener" href="http://www.importnew.com/20386.html#comment-648123">http://www.importnew.com/20386.html#comment-648123</a><br>13&#x2F;04&#x2F;2018 Page 54 of 283<br>4.1.11. 线程上下文切换<br>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存<br>下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做<br>上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。<br>4.1.11.1. 进程<br>（有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且<br>与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量<br>级的进程。<br>4.1.11.2. 上下文<br>是指某一时间点 CPU 寄存器和程序计数器的内容。<br>4.1.11.3. 寄存器<br>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内<br>存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速<br>度。<br>4.1.11.4. 程序计数器<br>是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令<br>的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。<br>4.1.11.5. PCB-“切换桢”<br>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下<br>文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称<br>作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。<br>13&#x2F;04&#x2F;2018 Page 76 of 283<br>4.1.11.6. 上下文切换的活动：<br>58. 挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。<br>59. 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。<br>60. 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序<br>中。<br>4.1.11.7. 引起线程上下文切换的原因<br>61. 当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；<br>62. 当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；<br>63. 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；<br>64. 用户代码挂起当前任务，让出 CPU 时间；<br>65. 硬件中断；</p><p>4.1.14. JAVA 阻塞队列原理<br>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：<br>85. 当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放<br>入队列。<br>86. 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有<br>空的位置，线程被自动唤醒。<br>13&#x2F;04&#x2F;2018 Page 80 of 283<br>4.1.14.1. 阻塞队列的主要方法<br> 抛出异常：抛出一个异常；<br> 特殊值：返回一个特殊值（null 或 false,视情况而定）<br> 则塞：在成功操作之前，一直阻塞线程<br> 超时：放弃前只在最大的时间内阻塞<br>插入操作：<br>1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行<br>且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛<br>出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。<br>2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行<br>且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。<br>3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插<br>入此队列中，将等待可用的空间（如果有必要）<br>public void put(E paramE) throws InterruptedException {<br>checkNotNull(paramE);<br>ReentrantLock localReentrantLock &#x3D; this.lock;<br>localReentrantLock.lockInterruptibly();<br>try {<br>while (this.count &#x3D;&#x3D; this.items.length)<br>this.notFull.await();&#x2F;&#x2F;如果队列满了，则线程阻塞等待<br>enqueue(paramE);<br>13&#x2F;04&#x2F;2018 Page 81 of 283<br>localReentrantLock.unlock();<br>} finally {<br>localReentrantLock.unlock();<br>}<br>}<br>4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间<br>内，还不能往队列中加入 BlockingQueue，则返回失败。<br>获取数据操作：<br>1：poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数<br>规定的时间,取不到时返回 null;<br>2：poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在<br>指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数<br>据可取，返回失败。<br>3：take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状<br>态直到 BlockingQueue 有新的数据被加入。<br>4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个<br>数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。<br>4.1.14.2. Java 中的阻塞队列<br>87. ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。<br>88. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。<br>89. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。<br>90. DelayQueue：使用优先级队列实现的无界阻塞队列。<br>91. SynchronousQueue：不存储元素的阻塞队列。<br>92. LinkedTransferQueue：由链表结构组成的无界阻塞队列。<br>93. LinkedBlockingDeque：由链表结构组成的双向阻塞队列<br>13&#x2F;04&#x2F;2018 Page 82 of 283<br>4.1.14.3. ArrayBlockingQueue（公平、非公平）<br>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下<br>不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当<br>队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入<br>元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐<br>量。我们可以使用以下代码创建一个公平的阻塞队列：<br>ArrayBlockingQueue fairQueue &#x3D; new ArrayBlockingQueue(1000,true);<br>4.1.14.4. LinkedBlockingQueue（两个独立锁提高并发）<br>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对<br>元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者<br>端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费<br>者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。<br>4.1.14.5. PriorityBlockingQueue（compareTo 排序实现优先）<br>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现<br>compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造<br>参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。<br>4.1.14.6. DelayQueue（缓存失效、定时任务 ）<br>是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实<br>现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才<br>能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景：<br>94. 缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询<br>DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。<br>13&#x2F;04&#x2F;2018 Page 83 of 283<br>95. 定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从<br>DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。<br>4.1.14.7. SynchronousQueue（不存储数据、可用于传递数据）<br>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。<br>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线<br>程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给<br>另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和<br>ArrayBlockingQueue。<br>4.1.14.8. LinkedTransferQueue<br>是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，<br>LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。<br>96. transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的<br>poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如<br>果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素<br>被消费者消费了才返回。<br>97. tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费<br>者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否<br>接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。<br>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传<br>入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时<br>还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。<br>4.1.14.9. LinkedBlockingDeque<br>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。<br>双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其<br>他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，<br>peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队<br>列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另<br>外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同<br>于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。<br>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在<br>“工作窃取”模式中。<br>13&#x2F;04&#x2F;2018 Page 84 of 283</p><p>4.1.20. ConcurrentHashMap 并发<br>4.1.20.1. 减小锁粒度<br>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减<br>小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高<br>性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我<br>们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被<br>称为 ConcurrentHashMap 的并发度。<br>4.1.20.2. ConcurrentHashMap 分段锁<br>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下<br>一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。<br>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首<br>先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程<br>环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以<br>做到真正的并行。<br>13&#x2F;04&#x2F;2018 Page 93 of 283<br>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成<br>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可<br>重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值<br>对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap<br>类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是<br>一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的<br>数据进行修改时，必须首先获得它对应的 Segment 锁。</p><p>5.1.1. JAVA 异常分类及处理<br>5.1.1.1. 概念<br>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下<br>会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用<br>这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。<br>5.1.1.2. 异常分类<br>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception<br>Error<br>138.Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果<br>出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。<br>Exception（RuntimeException、CheckedException）<br>139.Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是<br>CheckedException。<br>RuntimeException 如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常<br>CheckedException，如 I&#x2F;O 错误导致的 IOException、SQLException。 RuntimeException 是<br>那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一<br>定是程序员的错误.<br>13&#x2F;04&#x2F;2018 Page 102 of 283<br>检查异常 CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强<br>制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一<br>般包括几个方面：<br>140.试图在文件尾部读取数据<br>141.试图打开一个错误格式的 URL<br>142.试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在<br>5.1.1.3. 异常的处理方式<br>遇到问题不进行具体处理，而是继续抛给调用者 （throw,throws）<br>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。<br>public static void main(String[] args) {<br>String s &#x3D; “abc”;<br>if(s.equals(“abc”)) {<br>throw new NumberFormatException();<br>} else {<br>System.out.println(s);<br>}<br>}<br>int div(int a,int b) throws Exception{<br>return a&#x2F;b;}<br>try catch 捕获异常针对性处理方式<br>5.1.1.4. Throw 和 throws 的区别：<br>位置不同<br>143.throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的<br>是异常对象。<br>功能不同：<br>144.throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方<br>式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并<br>将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语<br>句，因为执行不到。<br>145.throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，<br>执行 throw 则一定抛出了某种异常对象。<br>13&#x2F;04&#x2F;2018 Page 103 of 283<br>146.两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异<br>常，真正的处理异常由函数的上层调用处理。<br>5.1.2. JAVA 反射<br>5.1.2.1. 动态语言<br>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结<br>构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，<br>而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。<br>5.1.2.2. 反射机制概念 （运行状态中知道类所有的属性和方法）<br>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；<br>并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方<br>法的功能成为 Java 语言的反射机制。<br>5.1.2.3. 反射的应用场合<br>编译时类型和运行时类型<br>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由<br>声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：<br>Person p&#x3D;new Student();<br>其中编译时类型为 Person，运行时类型为 Student。<br>13&#x2F;04&#x2F;2018 Page 104 of 283<br>的编译时类型无法获取具体方法<br>程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用<br>该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。<br>然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象<br>和类的真实信息，此时就必须使用到反射了。<br>5.1.2.4. Java 反射 API<br>反射 API 用来生成 JVM 中的类、接口或则对象的信息。<br>147.Class 类：反射的核心类，可以获取类的属性，方法等信息。<br>148.Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性<br>值。<br>149.Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或<br>者执行方法。<br>150.Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。<br>5.1.2.5. 反射使用步骤（获取 Class 对象、调用对象方法）<br>151.获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方<br>法。<br>152.调用 Class 类中的方法，既就是反射的使用阶段。<br>153.使用反射 API 来操作这些信息。<br>5.1.2.6. 获取 Class 对象的 3 种方法<br>调用某个对象的 getClass()方法<br>Person p&#x3D;new Person();<br>Class clazz&#x3D;p.getClass();<br>调用某个类的 class 属性来获取该类对应的 Class 对象<br>Class clazz&#x3D;Person.class;<br>使用 Class 类中的 forName()静态方法(最安全&#x2F;性能最好)<br>Class clazz&#x3D;Class.forName(“类的全路径”); (最常用)<br>当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法<br>和属性。<br>&#x2F;&#x2F;获取 Person 类的 Class 对象<br>Class clazz&#x3D;Class.forName(“reflection.Person”);<br>13&#x2F;04&#x2F;2018 Page 105 of 283<br>&#x2F;&#x2F;获取 Person 类的所有方法信息<br>Method[] method&#x3D;clazz.getDeclaredMethods();<br>for(Method m:method){<br>System.out.println(m.toString());<br>}<br>&#x2F;&#x2F;获取 Person 类的所有成员属性信息<br>Field[] field&#x3D;clazz.getDeclaredFields();<br>for(Field f:field){<br>System.out.println(f.toString());<br>}<br>&#x2F;&#x2F;获取 Person 类的所有构造方法信息<br>Constructor[] constructor&#x3D;clazz.getDeclaredConstructors();<br>for(Constructor c:constructor){<br>System.out.println(c.toString());<br>}<br>5.1.2.7. 创建对象的两种方法<br>Class 对象的 newInstance()<br>154.使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求<br>该 Class 对象对应的类有默认的空构造器。<br>调用 Constructor 对象的 newInstance()<br>155.先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()<br>方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。<br>&#x2F;&#x2F;获取 Person 类的 Class 对象<br>Class clazz&#x3D;Class.forName(“reflection.Person”);<br>&#x2F;&#x2F;使用.newInstane 方法创建对象<br>Person p&#x3D;(Person) clazz.newInstance();<br>&#x2F;&#x2F;获取构造方法并创建对象<br>Constructor c&#x3D;clazz.getDeclaredConstructor(String.class,String.class,int.class);<br>&#x2F;&#x2F;创建对象并设置属性<br>13&#x2F;04&#x2F;2018 Page 106 of 283<br>Person p1&#x3D;(Person) c.newInstance(“李四”,”男”,20);<br>5.1.3. JAVA 注解<br>5.1.3.1. 概念<br>Annotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径<br>和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation<br>对象，然后通过该 Annotation 对象来获取注解中的元数据信息。<br>5.1.3.2. 4 种标准元注解<br>元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被<br>用来提供对其它 annotation 类型作说明。<br>@Target 修饰的对象范围<br>@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、<br>接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数<br>和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰<br>其修饰的目标<br>@Retention 定义 被保留的时间长短<br>Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描<br>述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：<br> SOURCE:在源文件中有效（即源文件保留）<br> CLASS:在 class 文件中有效（即 class 保留）<br> RUNTIME:在运行时有效（即运行时保留）<br>@Documented 描述-javadoc<br>@ Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因<br>此可以被例如 javadoc 此类的工具文档化。<br>@Inherited 阐述了某个被标注的类型是被继承的<br>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一<br>个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该<br>class 的子类。<br>13&#x2F;04&#x2F;2018 Page 107 of 283<br>5.1.3.3. 注解处理器<br>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，<br>很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API，以帮助程序员快速<br>的构造自定义注解处理器。下面实现一个注解处理器。<br>&#x2F;1：*** 定义注解*&#x2F;<br>@Target(ElementType.FIELD)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface FruitProvider {<br>&#x2F;<em>供应商编号</em>&#x2F;<br>public int id() default -1;<br>&#x2F;** 供应商名称*&#x2F;<br>public String name() default “”；<br>13&#x2F;04&#x2F;2018 Page 108 of 283<br>&#x2F;** * 供应商地址*&#x2F;<br>public String address() default “”;<br>}<br>&#x2F;&#x2F;2：注解使用<br>public class Apple {<br>@FruitProvider(id &#x3D; 1, name &#x3D; “陕西红富士集团”, address &#x3D; “陕西省西安市延安路”)<br>private String appleProvider;<br>public void setAppleProvider(String appleProvider) {<br>this.appleProvider &#x3D; appleProvider;<br>}<br>public String getAppleProvider() {<br>return appleProvider;<br>}<br>}<br>&#x2F;3：*********** 注解处理器 ***************&#x2F;<br>public class FruitInfoUtil {<br>public static void getFruitInfo(Class&lt;?&gt; clazz) {<br>String strFruitProvicer &#x3D; “供应商信息：”;<br>Field[] fields &#x3D; clazz.getDeclaredFields();&#x2F;&#x2F;通过反射获取处理注解<br>for (Field field : fields) {<br>if (field.isAnnotationPresent(FruitProvider.class)) {<br>FruitProvider fruitProvider &#x3D; (FruitProvider) field.getAnnotation(FruitProvider.class);<br>&#x2F;&#x2F;注解信息的处理地方<br>strFruitProvicer &#x3D; “ 供应商编号：” + fruitProvider.id() + “ 供应商名称：”* fruitProvider.name() + “ 供应商地址：”+ fruitProvider.address();<br>System.out.println(strFruitProvicer);<br>}<br>}<br>}<br>}<br>13&#x2F;04&#x2F;2018 Page 109 of 283<br>public class FruitRun {<br>public static void main(String[] args) {<br>FruitInfoUtil.getFruitInfo(Apple.class);<br>&#x2F;<em><strong>输出结果</strong></em>****&#x2F;<br>&#x2F;&#x2F; 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延<br>}<br>}<br>5.1.4. JAVA 内部类<br>Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根<br>据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。<br>5.1.4.1. 静态内部类<br>定义在类内部的静态类，就是静态内部类。<br>public class Out {<br>private static int a;<br>private int b;<br>public static class Inner {<br>public void print() {<br>System.out.println(a);<br>}<br>}<br>}1. 静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。2. 静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。3. 其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：Out.Inner inner &#x3D;<br>new Out.Inner();inner.print();4. Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，<br>HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部<br>类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。<br>13&#x2F;04&#x2F;2018 Page 110 of 283<br>5.1.4.2. 成员内部类<br>定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final 修饰的<br>除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内<br>部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。<br>public class Out {<br>private static int a;<br>private int b;<br>public class Inner {<br>public void print() {<br>System.out.println(a);<br>System.out.println(b);<br>}<br>}<br>}<br>5.1.4.3. 局部内部类（定义在方法中的类）<br>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。<br>public class Out {<br>private static int a;<br>private int b;<br>public void test(final int c) {<br>final int d &#x3D; 1;<br>class Inner {<br>public void print() {<br>System.out.println(c);<br>}<br>}<br>}<br>}<br>13&#x2F;04&#x2F;2018 Page 111 of 283<br>5.1.4.4. 匿名内部类（要继承一个父类或者实现一个接口、直接使用<br>new 来生成一个对象的引用）<br>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一<br>个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引<br>用。<br>public abstract class Bird {<br>private String name;<br>public String getName() {<br>return name;<br>}<br>public void setName(String name) {<br>this.name &#x3D; name;<br>}<br>public abstract int fly();<br>}<br>public class Test {<br>public void test(Bird bird){<br>System.out.println(bird.getName() + “能够飞 “ + bird.fly() + “米”);<br>}<br>public static void main(String[] args) {<br>Test test &#x3D; new Test();<br>test.test(new Bird() {<br>public int fly() {<br>return 10000;<br>}<br>public String getName() {<br>return “大雁”;<br>}<br>});<br>}<br>}<br>13&#x2F;04&#x2F;2018 Page 112 of 283<br>5.1.5. JAVA 泛型<br>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本<br>质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，<br>能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。<br>5.1.5.1. 泛型方法（&lt;E&gt;）<br>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数<br>类型，编译器适当地处理每一个方法调用。<br>&#x2F;&#x2F; 泛型方法 printArray<br>public static &lt; E &gt; void printArray( E[] inputArray )<br>{<br>for ( E element : inputArray ){<br>System.out.printf( “%s “, element );<br>}<br>}5. &lt;? extends T&gt;表示该通配符所代表的类型是 T 类型的子类。6. &lt;? super T&gt;表示该通配符所代表的类型是 T 类型的父类。5.1.5.2. 泛型类&lt;T&gt;<br>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一<br>样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，<br>也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，<br>这些类被称为参数化的类或参数化的类型。<br>public class Box&lt;T&gt; {<br>private T t;<br>public void add(T t) {<br>this.t &#x3D; t;<br>}<br>public T get() {<br>return t;<br>}<br>13&#x2F;04&#x2F;2018 Page 113 of 283<br>5.1.5.3. 类型通配符?<br>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List&lt;?&gt; 在逻辑上是<br>List&lt;String&gt;,List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt;的父类。<br>5.1.5.4. 类型擦除<br>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛<br>型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个<br>过程就称为类型擦除。如在代码中定义的 List&lt;Object&gt;和 List&lt;String&gt;等类型，在编译之后<br>都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。<br>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般<br>是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换<br>成具体的类。<br>5.1.6. JAVA 序列化(创建可复用的 Java 对象)<br>保存(持久化)对象及其状态到内存或者磁盘<br>Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，<br>这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，<br>就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。<br>Java 对象序列化就能够帮助我们实现该功能。<br>序列化对象以字节数组保持-静态成员不保存<br>使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装<br>成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对<br>象序列化不会关注类中的静态变量。<br>序列化用户远程对象传输<br>除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，<br>都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。<br>Serializable 实现序列化<br>在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。<br>ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化<br>通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。<br>writeObject 和 readObject 自定义序列化策略<br>在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。<br>序列化 ID<br>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个<br>类的序列化 ID 是否一致（就是 private static final long serialVersionUID）<br>13&#x2F;04&#x2F;2018 Page 114 of 283<br>序列化并不保存静态变量<br>序列化子父类说明<br>要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。<br>Transient 关键字阻止该变量被序列化到文件中1. 在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列<br>化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。<br>2. 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串<br>等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在<br>客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的<br>数据安全。<br>5.1.7. JAVA 复制<br>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式<br>是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。<br>5.1.7.1. 直接赋值复制<br>直接赋值。在 Java 中，A a1 &#x3D; a2，我们需要理解的是这实际上复制的是引用，也就是<br>说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟<br>着变化。<br>5.1.7.2. 浅复制（复制引用但不复制引用的对象）<br>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，<br>那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。<br>因此，原始对象及其副本引用同一个对象。<br>class Resume implements Cloneable{<br>public Object clone() {<br>try {<br>return (Resume)super.clone();<br>} catch (Exception e) {<br>e.printStackTrace();<br>return null;<br>}<br>}<br>}<br>13&#x2F;04&#x2F;2018 Page 115 of 283<br>5.1.7.3. 深复制（复制对象和其应用对象）<br>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。<br>class Student implements Cloneable {<br>String name;<br>int age;<br>Professor p;<br>Student(String name, int age, Professor p) {<br>this.name &#x3D; name;<br>this.age &#x3D; age;<br>this.p &#x3D; p;<br>}<br>public Object clone() {<br>Student o &#x3D; null;<br>try {<br>o &#x3D; (Student) super.clone();<br>} catch (CloneNotSupportedException e) {<br>System.out.println(e.toString());<br>}<br>o.p &#x3D; (Professor) p.clone();<br>return o;<br>}<br>}<br>5.1.7.4. 序列化（深 clone 一中实现）<br>在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对<br>象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。<br>13&#x2F;04&#x2F;2018 Page 116 of 283<br>6.1.10. Spring Boot 原理<br>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭<br>建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的<br>配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application<br>development)成为领导者。其特点如下：<br>1. 创建独立的 Spring 应用程序<br>2. 嵌入的 Tomcat，无需部署 WAR 文件<br>3. 简化 Maven 配置<br>4. 自动配置 Spring<br>5. 提供生产就绪型功能，如指标，健康检查和外部配置<br>6. 绝对没有代码生成和对 XML 没有要求配置 [1]<br>6.1.11. JPA 原理<br>6.1.11.1. 事务<br>事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性 ( Atomicity )、一致性<br>( Consistency )、隔离性 ( Isolation ) 和持久性 ( Durabilily )。<br>6.1.11.2. 本地事务<br>紧密依赖于底层资源管理器（例如数据库连接 )，事务处理局限在当前事务资源内。此种事务处理<br>方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。在数据库连<br>接中使用本地事务示例如下：<br>public void transferAccount() {<br>Connection conn &#x3D; null;<br>Statement stmt &#x3D; null;<br>try{<br>conn &#x3D; getDataSource().getConnection();<br>&#x2F;&#x2F; 将自动提交设置为 false，若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交<br>conn.setAutoCommit(false);<br>stmt &#x3D; conn.createStatement();<br>&#x2F;&#x2F; 将 A 账户中的金额减少 500<br>stmt.execute(“update t_account set amount &#x3D; amount - 500 where account_id &#x3D; ‘A’”);<br>13&#x2F;04&#x2F;2018 Page 135 of 283<br>&#x2F;&#x2F; 将 B 账户中的金额增加 500<br>stmt.execute(“update t_account set amount &#x3D; amount + 500 where account_id &#x3D; ‘B’”);<br>&#x2F;&#x2F; 提交事务<br>conn.commit();<br>&#x2F;&#x2F; 事务提交：转账的两步操作同时成功<br>} catch(SQLException sqle){<br>&#x2F;&#x2F; 发生异常，回滚在本事务中的操做<br>conn.rollback();<br>&#x2F;&#x2F; 事务回滚：转账的两步操作完全撤销<br>stmt.close();<br>conn.close();<br>}<br>}<br>6.1.11.1. 分布式事务<br>Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction<br>Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务<br>管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource<br>Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务<br>参与单元的协调与控制。<br>public void transferAccount() {<br>UserTransaction userTx &#x3D; null;<br>Connection connA &#x3D; null; Statement stmtA &#x3D; null;<br>Connection connB &#x3D; null; Statement stmtB &#x3D; null;<br>try{<br>&#x2F;&#x2F; 获得 Transaction 管理对象<br>userTx &#x3D; (UserTransaction)getContext().lookup(“java:comp&#x2F;UserTransaction”);<br>connA &#x3D; getDataSourceA().getConnection();&#x2F;&#x2F; 从数据库 A 中取得数据库连接<br>connB &#x3D; getDataSourceB().getConnection();&#x2F;&#x2F; 从数据库 B 中取得数据库连接<br>userTx.begin(); &#x2F;&#x2F; 启动事务<br>stmtA &#x3D; connA.createStatement();&#x2F;&#x2F; 将 A 账户中的金额减少 500<br>stmtA.execute(“update t_account set amount &#x3D; amount - 500 where account_id &#x3D; ‘A’”);<br>&#x2F;&#x2F; 将 B 账户中的金额增加 500<br>stmtB &#x3D; connB.createStatement();<br>13&#x2F;04&#x2F;2018 Page 136 of 283<br>stmtB.execute(“update t_account set amount &#x3D; amount + 500 where account_id &#x3D; ‘B’”);<br>userTx.commit();&#x2F;&#x2F; 提交事务<br>&#x2F;&#x2F; 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新）<br>} catch(SQLException sqle){<br>&#x2F;&#x2F; 发生异常，回滚在本事务中的操纵<br>userTx.rollback();&#x2F;&#x2F; 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销<br>} catch(Exception ne){ }<br>}<br>6.1.11.1. 两阶段提交<br>两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段<br>是指：第一阶段：准备阶段；第二阶段：提交阶段。<br>1 准备阶段<br>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回<br>失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一<br>种“万事俱备，只欠东风”的状态。<br>2 提交阶段：<br>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，<br>发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过<br>程中使用的锁资源。(注意:必须在最后阶段释放锁资源)<br>13&#x2F;04&#x2F;2018 Page 137 of 283<br>将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成<br>所有能完成的工作。<br>6.1.12. Mybatis 缓存<br>Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存<br>是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以<br>后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存<br>是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的<br>sqlsession 是可以共享的。<br>13&#x2F;04&#x2F;2018 Page 138 of 283<br>6.1.12.1. Mybatis 的一级缓存原理（sqlsession 级别）<br>第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一<br>个 map。<br>key：MapperID+offset+limit+Sql+所有的入参<br>value：用户信息<br>同一个 sqlsession 再次发出相同的 sql，就从缓存中取出数据。如果两次中间出现 commit 操作<br>（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所<br>以要从数据库查询，从数据库查询到再写入缓存。<br>6.1.12.2. 二级缓存原理（mapper 基本）<br>二级缓存的范围是 mapper 级别（mapper 同一个命名空间），mapper 以命名空间为单位创建缓<br>存数据结构，结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor<br>13&#x2F;04&#x2F;2018 Page 139 of 283<br>其实是 Executor 的代理对象。所有的查询操作，在 CacheExecutor 中都会先匹配缓存中是否存<br>在，不存在则查询数据库。<br>key：MapperID+offset+limit+Sql+所有的入参<br>具体使用需要配置：<br>1. Mybatis 全局配置中启用二级缓存配置<br>2. 在对应的 Mapper.xml 中配置 cache 节点<br>3. 在对应的 select 查询节点中添加 useCache&#x3D;true<br>6.1.13. Tomcat 架构<br><a target="_blank" rel="noopener" href="http://www.importnew.com/21112.html">http://www.importnew.com/21112.html</a><br>13&#x2F;04&#x2F;2018 Page 140 of 283<br>7. 微服务<br>7.1.1. 服务注册发现<br>服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记<br>簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服<br>务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种<br>形式：客户端注册和第三方注册。<br>7.1.1.1. 客户端注册（zookeeper）<br>客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下<br>线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心<br>负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一<br>套注册逻辑。<br>7.1.1.2. 第三方注册（独立的服务 Registrar）<br>第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，<br>然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不<br>可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统，否则注册<br>工作没法进展。<br>13&#x2F;04&#x2F;2018 Page 141 of 283<br>7.1.1.3. 客户端发现<br>客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而<br>且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多<br>语言时的重复工作，每个语言实现相同的逻辑。<br>13&#x2F;04&#x2F;2018 Page 142 of 283<br>7.1.1.4. 服务端发现<br>服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。<br>这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。<br>7.1.1.5. Consul<br>7.1.1.6. Eureka<br>7.1.1.7. SmartStack<br>7.1.1.8. Etcd<br>7.1.2. API 网关<br>API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的<br>Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有<br>其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一<br>个适应当前架构的 API Gateway。<br>13&#x2F;04&#x2F;2018 Page 143 of 283<br>API Gateway 负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过 API Gateway，<br>然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以<br>及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如<br>HTTP 协议、WebSocket 协议。<br>7.1.2.1. 请求转发<br>服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上<br>7.1.2.2. 响应合并<br>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。<br>7.1.2.3. 协议转换<br>重点是支持 SOAP，JMS，Rest 间的协议转换。<br>7.1.2.4. 数据转换<br>重点是支持 XML 和 Json 之间的报文格式转换能力（可选）<br>13&#x2F;04&#x2F;2018 Page 144 of 283<br>7.1.2.5. 安全认证<br>1. 基于 Token 的客户端访问控制和安全策略<br>2. 传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包<br>3. 基于 Https 的传输加密，客户端和服务端数字证书支持<br>4. 基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）<br>7.1.3. 配置中心<br>配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访<br>问。<br>7.1.3.1. zookeeper 配置中心<br>实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点<br>监听机制来实现实时感知。<br>7.1.3.2. 配置中心数据分类<br>7.1.4. 事件调度（kafka）<br>消息服务和事件的统一调度，常用用 kafka ，activemq 等。<br>7.1.5. 服务跟踪（starter-sleuth）<br>随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， Spring<br>Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这<br>样你就能跟踪某个请求是如何从一个微服务传递到下一个。<br>13&#x2F;04&#x2F;2018 Page 145 of 283<br>1. 为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求<br>创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标<br>识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。通过 Trace ID 的记<br>录，我们就能将所有请求过程日志关联起来。<br>2. 为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态<br>时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到<br>的 Span ID，对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结<br>束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一<br>些其他元数据，比如：事件名称、请求信息等。<br>3. 在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloud￾starter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloud￾starter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：<br> 通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息<br>中间件）传递的请求。<br> 通过 Zuul 代理传递的请求。<br> 通过 RestTemplate 发起的请求。<br>7.1.6. 服务熔断（Hystrix）<br>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个<br>系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不<br>可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。<br>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到<br>许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序<br>不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU<br>时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经<br>修正，应用程序会再次尝试调用操作。<br>13&#x2F;04&#x2F;2018 Page 146 of 283<br>7.1.6.1. Hystrix 断路器机制<br>断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会<br>切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态<br>一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况,<br>如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器<br>就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效<br>请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。<br>7.1.7. API 管理<br>SwaggerAPI 管理工具。<br>13&#x2F;04&#x2F;2018 Page 147 of 283<br>8. Netty 与 RPC<br>8.1.1. Netty 原理<br>Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对<br>TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞<br>的，通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。<br>8.1.2. Netty 高性能<br>在 IO 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者 IO 多路复用技术<br>进行处理。IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞上，从而使得系统在<br>单线程的情况下可以同时处理多个客户端请求。与传统的多线程&#x2F;多进程模型比，I&#x2F;O 多路复用的<br>最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程<br>的运行，降低了系统的维护工作量，节省了系统资源。<br>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel<br>两种不同的套接字通道实现。<br>8.1.2.1. 多路复用通讯方式<br>Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下：<br>客户端通信序列图如下：<br>13&#x2F;04&#x2F;2018 Page 148 of 283<br>Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个<br>客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于<br>频繁 IO 阻塞导致的线程挂起。<br>8.1.2.1. 异步通讯 NIO<br>由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作，这从根<br>本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极<br>大的提升。<br>13&#x2F;04&#x2F;2018 Page 149 of 283<br>8.1.2.2. 零拷贝（DIRECT BUFFERS 使用堆外直接内存）<br>1. Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，<br>不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，<br>JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，<br>消息在发送过程中多了一次缓冲区的内存拷贝。<br>2. Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样<br>方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的<br>Buffer。<br>3. Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，<br>避免了传统通过循环 write 方式导致的内存拷贝问题<br>8.1.2.3. 内存池（基于内存池的缓冲区重用机制）<br>随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓<br>冲区 Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽<br>量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。<br>8.1.2.4. 高效的 Reactor 线程模型<br>常用的 Reactor 线程模型有三种，Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模<br>型。<br>Reactor 单线程模型<br>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：<br>1) 作为 NIO 服务端，接收客户端的 TCP 连接；<br>2) 作为 NIO 客户端，向服务端发起 TCP 连接；<br>3) 读取通信对端的请求或者应答消息；<br>4) 向通信对端发送消息请求或者应答消息。<br>13&#x2F;04&#x2F;2018 Page 150 of 283<br>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独<br>立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过<br>Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer<br>派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。<br>Reactor 多线程模型<br>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。 有专门一个<br>NIO 线程-Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求； 网络 IO 操作-读、写<br>等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N<br>个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；<br>主从 Reactor 多线程模型<br>服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。<br>Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的<br>SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责<br>SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅只用于客户端的登陆、握手和安全<br>认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负<br>责后续的 IO 操作。<br>13&#x2F;04&#x2F;2018 Page 151 of 283<br>8.1.2.5. 无锁设计、线程绑定<br>Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。<br>表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程<br>参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-<br>多个工作线程模型性能更优。<br>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的<br>fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用<br>到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁<br>的竞争，从性能角度看是最优的。<br>8.1.2.6. 高性能的序列化框架<br>Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的<br>高性能序列化框架，例如 Thrift 的压缩二进制编解码框架。<br>1. SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K。<br>13&#x2F;04&#x2F;2018 Page 152 of 283<br>小包封大包，防止网络阻塞<br>2. SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量<br>小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算<br>法。<br>软中断 Hash 值和 CPU 绑定<br>3. 软中断：开启 RPS 后可以实现软中断，提升网络吞吐量。RPS 根据数据包的源地址，目的地址以<br>及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu，从上层<br>来看，也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上，提升<br>网络并行处理性能。<br>8.1.3. Netty RPC 实现<br>8.1.3.1. 概念<br>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一<br>样。RPC 可以很好的解耦系统，如 WebService 就是一种基于 Http 协议的 RPC。这个 RPC 整体框架<br>如下：<br>8.1.3.2. 关键技术<br>1. 服务发布与订阅：服务端使用 Zookeeper 注册服务地址，客户端从 Zookeeper 获取可用的服务<br>地址。<br>2. 通信：使用 Netty 作为通信框架。<br>3. Spring：使用 Spring 配置服务，加载 Bean，扫描注解。<br>4. 动态代理：客户端使用代理模式透明化服务调用。<br>5. 消息编解码：使用 Protostuff 序列化和反序列化消息。<br>8.1.3.3. 核心流程<br>1. 服务消费方（client）调用以本地调用方式调用服务；<br>13&#x2F;04&#x2F;2018 Page 153 of 283<br>2. client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3. client stub 找到服务地址，并将消息发送到服务端；<br>4. server stub 收到消息后进行解码；<br>5. server stub 根据解码结果调用本地的服务；<br>6. 本地服务执行并将结果返回给 server stub；<br>7. server stub 将返回结果打包成消息并发送至消费方；<br>8. client stub 接收到消息，并进行解码；<br>9. 服务消费方得到最终结果。<br>RPC 的目标就是要 2~8 这些步骤都封装起来，让用户对这些细节透明。JAVA 一般使用动态代<br>理方式实现远程调用。<br>8.1.3.1. 消息编解码<br>息数据结构（接口名称+方法名+参数类型和参数值+超时时间+ requestID）<br>客户端的请求消息结构一般需要包括以下内容：<br>1. 接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪<br>个接口了；<br>2. 方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；<br>3. 参数类型和参数值：参数类型有很多，比如有 bool、int、long、double、string、map、list，<br>甚至如 struct（class）；以及相应的参数值；<br>4. 超时时间：<br>5. requestID，标识唯一请求 id，在下面一节会详细描述 requestID 的用处。<br>6. 服务端返回的消息 ： 一般包括以下内容。返回值+状态 code+requestID<br>13&#x2F;04&#x2F;2018 Page 154 of 283<br>序列化<br>目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案来搭建 RPC 框架，这<br>些都是久经考验的解决方案。<br>8.1.3.1. 通讯过程<br>核心问题(线程暂停、消息乱序)<br>如果使用 netty 的话，一般会用 channel.writeAndFlush()方法来发送消息二进制串，这个方<br>法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的，即对于当前线程来说，<br>将请求发送出来后，线程就可以往后执行了，至于服务端的结果，是服务端处理完成后，再以消息<br>的形式发送给客户端的。于是这里出现以下两个问题：<br>1. 怎么让当前线程“暂停”，等结果回来后，再向后执行？<br>2. 如果有多个线程同时进行远程方法调用，这时建立在 client server 之间的 socket 连接上<br>会有很多双方发送的消息传递，前后顺序也可能是随机的，server 处理完结果后，将结<br>果消息发送给 client，client 收到很多消息，怎么知道哪个消息结果是原先哪个线程调用<br>的？如下图所示，线程 A 和线程 B 同时向 client socket 发送请求 requestA 和 requestB，<br>socket 先后将 requestB 和 requestA 发送至 server，而 server 可能将 responseB 先返<br>回，尽管 requestB 请求到达时间更晚。我们需要一种机制保证 responseA 丢给<br>ThreadA，responseB 丢给 ThreadB。<br>通讯流程<br>requestID 生成-AtomicLong<br>1. client 线程每次通过 socket 调用一次远程接口前，生成一个唯一的 ID，即 requestID<br>（requestID 必需保证在一个 Socket 连接里面是唯一的），一般常常使用 AtomicLong<br>从 0 开始累计数字生成唯一 ID；<br>存放回调对象 callback 到全局 ConcurrentHashMap<br>2. 将 处 理 结 果 的 回 调 对 象 callback ， 存 放 到 全 局 ConcurrentHashMap 里 面<br>put(requestID, callback)；<br>synchronized 获取回调对象 callback 的锁并自旋 wait<br>3. 当线程调用 channel.writeAndFlush()发送消息后，紧接着执行 callback 的 get()方法试<br>图获取远程返回的结果。在 get()内部，则使用 synchronized 获取回调对象 callback 的<br>锁，再先检测是否已经获取到结果，如果没有，然后调用 callback 的 wait()方法，释放<br>callback 上的锁，让当前线程处于等待状态。<br>13&#x2F;04&#x2F;2018 Page 155 of 283<br>监听消息的线程收到消息，找到 callback 上的锁并唤醒<br>4. 服务端接收到请求并处理后，将 response 结果（此结果中包含了前面的 requestID）发<br>送给客户端，客户端 socket 连接上专门监听消息的线程收到消息，分析结果，取到<br>requestID ， 再 从 前 面 的 ConcurrentHashMap 里 面 get(requestID) ， 从 而 找 到<br>callback 对象，再用 synchronized 获取 callback 上的锁，将方法调用结果设置到<br>callback 对象里，再调用 callback.notifyAll()唤醒前面处于等待状态的线程。<br>public Object get() {<br>synchronized (this) { &#x2F;&#x2F; 旋锁<br>while (true) { &#x2F;&#x2F; 是否有结果了<br>If （!isDone）{<br>wait(); &#x2F;&#x2F;没结果释放锁，让当前线程处于等待状态<br>}else{&#x2F;&#x2F;获取数据并处理<br>}<br>}<br>}<br>}<br>private void setDone(Response res) {<br>this.res &#x3D; res;<br>isDone &#x3D; true;<br>synchronized (this) { &#x2F;&#x2F;获取锁，因为前面 wait()已经释放了 callback 的锁了<br>notifyAll(); &#x2F;&#x2F; 唤醒处于等待的线程<br>}<br>}<br>8.1.4. RMI 实现方式<br>Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用<br>于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远<br>程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接<br>口对象的使用。8.1.4.1. 实现步骤1. 编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出<br>java.rmi.RemoteException 异常；<br>2. 编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；<br>3. 运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类;<br>4. 启动一个 RMI 注册表，以便驻留这些服务;<br>13&#x2F;04&#x2F;2018 Page 156 of 283<br>5. 在 RMI 注册表中注册服务；<br>6. 客户端查找远程对象，并调用远程方法；<br>1：创建远程接口，继承 java.rmi.Remote 接口<br>public interface GreetService extends java.rmi.Remote {<br>String sayHello(String name) throws RemoteException;<br>}<br>2：实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类<br>public class GreetServiceImpl extends java.rmi.server.UnicastRemoteObject<br>implements GreetService {<br>private static final long serialVersionUID &#x3D; 3434060152387200042L;<br>public GreetServiceImpl() throws RemoteException {<br>super();<br>}<br>@Override<br>public String sayHello(String name) throws RemoteException {<br>return “Hello “ + name;<br>}<br>}<br>3：生成 Stub 和 Skeleton;<br>4：执行 rmiregistry 命令注册服务<br>5：启动服务<br>LocateRegistry.createRegistry(1098);<br>Naming.bind(“rmi:&#x2F;&#x2F;10.108.1.138:1098&#x2F;GreetService”, new GreetServiceImpl());<br>6.客户端调用<br>GreetService greetService &#x3D; (GreetService)<br>Naming.lookup(“rmi:&#x2F;&#x2F;10.108.1.138:1098&#x2F;GreetService”);<br>System.out.println(greetService.sayHello(“Jobs”));<br>8.1.5. Protoclol Buffer<br>protocol buffer 是 google 的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，<br>例如 XML，不过它比 xml 更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器<br>生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。<br>13&#x2F;04&#x2F;2018 Page 157 of 283<br>8.1.5.1. 特点<br>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：<br>7. 编码 &#x2F; 解码 方式简单（只需要简单的数学运算 &#x3D; 位移等等）<br>8. 采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成<br>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：<br>9. a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等<br>10. b. 采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑<br>8.1.6. Thrift<br>Apache Thrift 是 Facebook 实现的一种高效的、支持多种编程语言的远程服务调用的框架。本文将从<br>Java 开发人员角度详细介绍 Apache Thrift 的架构、开发和部署，并且针对不同的传输协议和服务类<br>型给出相应的 Java 实例，同时详细介绍 Thrift 异步客户端的实现，最后提出使用 Thrift 需要注意的事<br>项。<br>目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式<br>的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输<br>效率低，JSON 体积较小，新颖，但还不够完善。本文将介绍由 Facebook 开发的远程服务调用框架<br>Apache Thrift，它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码<br>生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa,<br>Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，<br>对于高并发、大数据量和多语言的环境更有优势。本文将详细介绍 Thrift 的使用，并且提供丰富的实例<br>代码加以解释说明，帮助使用者快速构建服务。<br>为什么要 Thrift：<br>1、多语言开发的需要 2、性能问题<br>13&#x2F;04&#x2F;2018 Page 158 of 283<br>13&#x2F;04&#x2F;2018 Page 159 of 283<br>11. 网络<br>9.1.1. 网络 7 层架构<br>7 层模型主要包括：<br>12. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率<br>等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为<br>1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。<br>13. 数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这<br>一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。<br>14. 网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工<br>作的设备是路由器，常把这一层的数据叫做数据包。<br>15. 传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，<br>传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，<br>与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这<br>种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。<br>常常把这一层数据叫做段。<br>16. 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间<br>发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）<br>17. 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够<br>识别的东西转换成人能够能识别的东西（如图片、声音等））<br>18. 应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你<br>就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。<br>13&#x2F;04&#x2F;2018 Page 160 of 283<br>9.1.2. TCP&#x2F;IP 原理<br>TCP&#x2F;IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP&#x2F;IP 协议族。从协议分层<br>模型方面来讲，TCP&#x2F;IP 由四个层次组成：网络接口层、网络层、传输层、应用层。<br>9.1.2.1. 网络访问层(Network Access Layer)<br>19. 网络访问层(Network Access Layer)在 TCP&#x2F;IP 参考模型中并没有详细描述，只是指出主机<br>必须使用某种协议与网络相连。<br>9.1.2.2. 网络层(Internet Layer)<br>20. 网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网<br>络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也<br>可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。互联网层使用因特<br>网协议(IP，Internet Protocol)。<br>9.1.2.3. 传输层(Tramsport Layer-TCP&#x2F;UDP)<br>21. 传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。在这一层定义了<br>两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协<br>议(UDP，User Datagram Protocol)。TCP 是面向连接的协议，它提供可靠的报文传输和对<br>上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路<br>复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需<br>要 TCP 的排序和流量控制等功能的应用程序。<br>9.1.2.4. 应用层(Application Layer)<br>22. 应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，<br>TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件<br>传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name<br>13&#x2F;04&#x2F;2018 Page 161 of 283<br>Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议<br>(HTTP，HyperText Transfer Protocol)等。<br>9.1.3. TCP 三次握手&#x2F;四次挥手<br>TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般<br>称为“四次挥手”。<br>9.1.3.1. 数据包说明<br>23. 源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。<br>24. 目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值<br>加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接。<br>25. 顺序号 seq（ 32 位）：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个<br>报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则<br>TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2 的 32 次方 － 1 后<br>又从 0 开始。当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该<br>连接的初始顺序号 ISN （ Initial Sequence Number ）。<br>26. 确认号 ack（ 32 位）：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当<br>是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效。 TCP 为<br>应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必<br>须保持每个方向上的传输数据顺序号。<br>27. TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，它实际上指明数据从哪里开始。需要这<br>个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然<br>而，没有任选字段，正常的长度是 20 字节。<br>28. 保留位（ 6 位）：保留给将来使用，目前必须置为 0 。<br>29. 控制位（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设<br>置为 1 。依次为：<br> URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。<br> ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。<br> PSH ：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层<br>而不用等待缓冲区装满。<br> RST ：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报<br>文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些<br>问题。<br> SYN ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。<br> FIN ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。<br>30. 窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源<br>方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。<br>31. 校验和（ 16 位）：此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字<br>进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。<br>32. 紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。TCP 的紧急方式是发送端向另<br>一端发送紧急数据的一种方式。<br>13&#x2F;04&#x2F;2018 Page 162 of 283<br>33. 选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连<br>接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，<br>它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充<br>位，使得报头长度成为整字数。<br>34. 数据： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报<br>文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数<br>据。在处理超时的许多情况中，也会发送不带任何数据的报文段。<br>9.1.3.2. 三次握手<br>第一次握手：主机 A 发送位码为 syn＝1,随机产生 seq number&#x3D;1234567 的数据包到服务器，主机 B<br>由 SYN&#x3D;1 知道，A 要求建立联机；<br>第二次握手：主机 B 收到请求后要确认联机信息，向 A 发 送 ack number&#x3D;( 主 机 A 的<br>seq+1),syn&#x3D;1,ack&#x3D;1,随机产生 seq&#x3D;7654321 的包<br>第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码<br>ack 是否为 1，若正确，主机 A 会再发送 ack number&#x3D;(主机 B 的 seq+1),ack&#x3D;1，主机 B 收到后确认<br>13&#x2F;04&#x2F;2018 Page 163 of 283<br>seq 值与 ack&#x3D;1 则连接建立成功。<br>9.1.3.3. 四次挥手<br>TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连<br>接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单<br>方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个<br>方向的连接。<br>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，<br>然后等待服务器的确认。其中终止标志位 FIN&#x3D;1，序列号 seq&#x3D;u<br>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。<br>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。<br>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。<br>首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>13&#x2F;04&#x2F;2018 Page 164 of 283<br>主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即<br>给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高<br>层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给<br>B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释<br>放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注<br>意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到<br>close 状态。<br>9.1.4. HTTP 原理<br>HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，<br>这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服<br>务器端不保留连接的有关信息.HTTP 遵循请求(Request)&#x2F;应答(Response)模型。客户机（浏览器）向<br>服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。<br>9.1.4.1. 传输流程<br>1：地址解析<br>如用客户端浏览器请求这个页面：<a target="_blank" rel="noopener" href="http://localhost.com:8080/index.htm">http://localhost.com:8080/index.htm</a> 从中分解出协议名、主机名、<br>端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：<br>协议名：http<br>主机名：localhost.com<br>端口：8080<br>对象路径：&#x2F;index.htm<br>13&#x2F;04&#x2F;2018 Page 165 of 283<br>在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。<br>2：封装 HTTP 请求数据包<br>把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包<br>3：封装成 TCP 包并建立连接<br>封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）<br>4：客户机发送请求命<br>4）客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资<br>源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。<br>5：服务器响应<br>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或<br>错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。<br>6：服务器关闭 TCP 连接<br>服务器关闭 TCP 连接：一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连<br>接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送<br>后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求<br>建立新连接所需的时间，还节约了网络带宽。<br>9.1.4.2. HTTP 状态<br>状态码 原因短语<br>消息响应<br>100 Continue(继续)<br>101 Switching Protocol(切换协议)<br>13&#x2F;04&#x2F;2018 Page 166 of 283<br>成功响应<br>200 OK(成功)<br>201 Created(已创建)<br>202 Accepted(已创建)<br>203 Non-Authoritative Information(未授权信息)<br>204 No Content(无内容)<br>205 Reset Content(重置内容)<br>206 Partial Content(部分内容)<br>重定向<br>300 Multiple Choice(多种选择)<br>301 Moved Permanently(永久移动)<br>302 Found(临时移动)<br>303 See Other(查看其他位置)<br>304 Not Modified(未修改)<br>305 Use Proxy(使用代理)<br>306 unused(未使用)<br>307 Temporary Redirect(临时重定向)<br>308 Permanent Redirect(永久重定向)<br>客户端错误<br>400 Bad Request(错误请求)<br>401 Unauthorized(未授权)<br>402 Payment Required(需要付款)<br>403 Forbidden(禁止访问)<br>404 Not Found(未找到)<br>405 Method Not Allowed(不允许使用该方法)<br>406 Not Acceptable(无法接受)<br>407 Proxy Authentication Required(要求代理身份验证)<br>408 Request Timeout(请求超时)<br>409 Conflict(冲突)<br>410 Gone(已失效)<br>411 Length Required(需要内容长度头)<br>412 Precondition Failed(预处理失败)<br>413 Request Entity Too Large(请求实体过长)<br>414 Request-URI Too Long(请求网址过长)<br>415 Unsupported Media Type(媒体类型不支持)<br>416 Requested Range Not Satisfiable(请求范围不合要求)<br>417 Expectation Failed(预期结果失败)<br>服务器端错误<br>500 Internal Server Error(内部服务器错误)<br>501 Implemented(未实现)<br>502 Bad Gateway(网关错误)<br>503 Service Unavailable(服务不可用)<br>504 Gateway Timeout (网关超时)<br>505 HTTP Version Not Supported(HTTP 版本不受支持)<br>9.1.4.3. HTTPS<br>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的<br>HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用<br>的端口号是 443。 过程大致如下：<br>13&#x2F;04&#x2F;2018 Page 167 of 283<br>建立连接获取证书<br>1） SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握<br>手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算<br>法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所<br>需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书<br>的公司，公共秘钥）。<br>证书验证<br>2） Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公<br>共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。<br>数据加密和传输<br>3） 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务<br>器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。<br>9.1.5. CDN 原理<br>CND 一般包含分发服务系统、负载均衡系统和管理系统<br>9.1.5.1. 分发服务系统<br>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还<br>负责内容更新，保证和源站内容的同步。<br>13&#x2F;04&#x2F;2018 Page 168 of 283<br>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速<br>服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部<br>署的 Cache 集群组成。<br>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个<br>Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由<br>哪个 Cache 设备来响应用户的请求。<br>9.1.5.2. 负载均衡系统：<br>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问<br>地址。<br>使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。<br>GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS<br>解析或者应用层重定向（Http 3XX 重定向）的方式实现。<br>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个<br>Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调<br>度（Nginx）和链路负载调度等。<br>9.1.5.3. 管理系统：<br>分为运营管理和网络管理子系统。<br>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资<br>源的可视化的集中管理，通常用 web 方式实现。<br>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、<br>交付工作。包括用户管理、产品管理、计费管理、统计分析等。<br>13&#x2F;04&#x2F;2018 Page 169 of 283</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/7e68be57c290.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/7e68be57c290.html" class="post-title-link" itemprop="url">消息队列（MQ）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:22:16" itemprop="dateCreated datePublished" datetime="2023-12-20T09:22:16+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-03 14:43:47" itemprop="dateModified" datetime="2024-01-03T14:43:47+08:00">2024-01-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>24k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>22 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h1><ul><li>场景有很多，但是比较核心的有 3 个：解耦、异步、削峰。</li></ul><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><ul><li>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</li><li>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A系统要时时刻刻考虑BCDE四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？</li><li>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去MQ里面消费。如果新系统需要数据，直接从MQ里消费即可；如果某个系统不需要这条数据了，就取消对MQ消息的消费即可。这样下来，A系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</li><li>总结：通过一个 MQ，Pub&#x2F;Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</li><li>面试技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</li></ul><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近 1s，用户感觉慢。</li><li>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</li><li>如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了</li></ul><h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><ul><li>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</li><li>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</li><li>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</li></ul><h1 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h1><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>解耦、异步、削峰。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="系统可用性降低"><a href="#系统可用性降低" class="headerlink" title="系统可用性降低"></a>系统可用性降低</h5><ul><li>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的。</li></ul><h5 id="系统复杂度提高"><a href="#系统复杂度提高" class="headerlink" title="系统复杂度提高"></a>系统复杂度提高</h5><ul><li>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li></ul><h5 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h5><ul><li>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。<br>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</li></ul><h1 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点</h1><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td>-</td><td>-</td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul><li>最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，不推荐用这个；</li><li>后来大家开始用 RabbitMQ，但是确实erlang语言阻止了大量的Java工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li><li>不过现在确实越来越多的公司会去用RocketMQ，确实很不错，阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给Apache，但GitHub上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li><li>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li></ul><h1 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h1><h4 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h4><ul><li>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</li><li>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</li></ul><h5 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h5><ul><li>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li></ul><h5 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h5><ul><li>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</li><li>这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</li></ul><h5 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h5><ul><li>这种模式，才是所谓的 RabbitMQ 的高可用模式</li><li>跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思</li><li>然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。</li><li>那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li><li>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据</li><li>坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</li></ul><h4 id="Kafka-的高可用性"><a href="#Kafka-的高可用性" class="headerlink" title="Kafka 的高可用性"></a>Kafka 的高可用性</h4><ul><li>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</li><li>这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</li><li>实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</li><li>Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1&#x2F;3 的数据就丢了，因此这个是做不到高可用的。</li><li>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。</li><li>只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</li><li>这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</li><li>写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</li><li>消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</li></ul><h1 id="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</h1><ul><li>RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题</li><li>因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。</li><li>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</li><li>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</li><li>举个栗子。有这么个场景。数据 1&#x2F;2&#x2F;3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152&#x2F;153&#x2F;154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了offset&#x3D;153的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 152 的 offset 并没有提交，kafka 也就不知道你已经消费了offset&#x3D;153这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 152 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</li><li>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 152 在数据库里插入了 2 次，那么数据就错啦。</li><li>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</li><li>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</li><li>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</li><li>所以第二个问题来了，怎么保证消息队列消费的幂等性？</li><li>其实还是得结合业务来思考，我这里给几个思路：<ul><li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li><li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li><li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul></li></ul><h1 id="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"><a href="#如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？" class="headerlink" title="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"></a>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</h1><ul><li>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</li></ul><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><h5 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h5><ul><li>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</li><li>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</li><li>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上吞吐量会下来，因为太耗性能。</li><li>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</li><li>事务机制和confirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</li><li>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</li></ul><h5 id="RabbitMQ-弄丢了数据"><a href="#RabbitMQ-弄丢了数据" class="headerlink" title="RabbitMQ 弄丢了数据"></a>RabbitMQ 弄丢了数据</h5><ul><li>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</li><li>设置持久化有两个步骤：<ul><li>创建 queue 的时候将其设置为持久化<br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的deliveryMode设置为 2<br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul></li><li>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</li><li>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</li><li>所以，持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</li></ul><h5 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h5><ul><li>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</li><li>这个时候得用 RabbitMQ 提供的ack机制，简单来说，就是你必须关闭 RabbitMQ 的自动ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把。这样的话，如果你还没处理完，不就没有ack了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><h5 id="消费端弄丢了数据-1"><a href="#消费端弄丢了数据-1" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h5><ul><li>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</li><li>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要关闭自动提交offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</li><li>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</li></ul><h5 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h5><ul><li>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</li><li>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</li><li>所以此时一般是要求起码设置如下 4 个参数：<ul><li>给 topic 设置replication.factor参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置min.insync.replicas参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置acks&#x3D;all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。</li><li>在 producer 端设置retries&#x3D;MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。</li></ul></li><li>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</li></ul><h5 id="生产者会不会弄丢数据"><a href="#生产者会不会弄丢数据" class="headerlink" title="生产者会不会弄丢数据"></a>生产者会不会弄丢数据</h5><ul><li>如果按照上述的思路设置了acks&#x3D;all，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了</li><li>如果没满足这个条件，生产者会自动不断的重试，重试无限次。</li></ul><h1 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h1><ul><li>举个例子，我们以前做过一个 mysql binlog 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）</li><li>常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</li><li>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 binlog 日志，接着这三条 binlog 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</li><li>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</li><li>先看看顺序会错乱的俩场景：<ul><li>RabbitMQ：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3。这不明显乱了。</li><li>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞多个线程来并发处理消息。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li></ul></li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul><li>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点</li><li>或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li></ul><p> </p><h5 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h5><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue</li><li>然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><h1 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h1><ul><li>先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。</li><li>大量消息在 mq 里积压了几个小时了还没解决。这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</li><li>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</li><li>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：<ul><li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据</li><li>这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li></ul></li></ul><h4 id="mq-中的消息过期失效了"><a href="#mq-中的消息过期失效了" class="headerlink" title="mq 中的消息过期失效了"></a>mq 中的消息过期失效了</h4><ul><li>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL</li><li>如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了</li><li>那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。</li><li>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息</li><li>我们可以采取一个方案，就是批量重导。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</li><li>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</li></ul><h4 id="mq-都快写满了"><a href="#mq-都快写满了" class="headerlink" title="mq 都快写满了"></a>mq 都快写满了</h4><ul><li>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</li></ul><h1 id="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"><a href="#如果让你写一个消息队列，该如何进行架构设计？说一下你的思路" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计？说一下你的思路"></a>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</h1><ul><li>其实回答这类问题，说白了，不求你看过那技术的源码，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</li><li>比如说这个消息队列系统，我们从以下几个角度来考虑一下：<ul><li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li><li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li><li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li><li>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</li></ul></li><li>mq 肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</li></ul><h1 id="四款消息队列的对比"><a href="#四款消息队列的对比" class="headerlink" title="四款消息队列的对比"></a>四款消息队列的对比</h1><h4 id="MSMQ"><a href="#MSMQ" class="headerlink" title="MSMQ"></a>MSMQ</h4><ul><li>这是微软的产品里唯一被认为有价值的东西</li><li>这个东西并不复杂，除了接收和 发送，没有别的</li><li>它有一些硬性限制，比如最大消息体积是4MB</li><li>然而，通过和一些像MassTransit 或 NServiceBus这样的软件的连接，它完全可以解决这些问题。</li><li>优点：<ul><li>由于是异步通信，无论是发送方还是接收方都不用等待对方返回成功消息，就可以执行余下的代码，因而大大地提高了事物处理的能力</li><li>当信息传送过程中，信息发送机制具有一定功能的故障恢复能力；</li><li>MSMQ的消息传递机制使得消息通信的双方具有不同的物理平台成为可能。</li></ul></li></ul><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><ul><li>特性列表:</li><li>多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li><li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)</li><li>对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性</li><li>通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上</li><li>支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>支持通过JDBC和journal提供高速的消息持久化</li><li>从设计上保证了高性能的集群，客户端-服务器，点对点</li><li>支持Ajax</li><li>支持与Axis的整合</li><li>可以很容易得调用内嵌JMS provider，进行测试</li></ul><h4 id="RabbitMQ-2"><a href="#RabbitMQ-2" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><ul><li>它支持开放的高级消息队列协议 (AMQP，Advanced Message Queuing Protocol)</li><li>从根本上避免了生产厂商的封闭，使用任何语言的各种客户都可以从中受益</li><li>这种协议提供了相当复杂的消息传输模式，所以基本上不需要 MassTransit 或 NServiceBus 的配合</li></ul><h4 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h4><ul><li>ZeroMQ 是一个轻量级消息内核</li><li>它可用于C、C++、Python、.NET &#x2F;Mono、Fortran和Java语言<br>它运行在AIX ， FreeBSD的，基于HP - UX ， Linux和MacOS下， OpenBSD系统， OpenVMS ， QNX Neutrino， Solaris和Windows操作系统。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>ActiveMQ需要 在目标机器上安装Java，RabbitMQ需要Erlang环境。如果这个中 的一个被选中，我需要让系统维护的人去理解和维护他们以前不熟悉的运行库。</li><li>ActiveMQ,RabbitMQ 和 MSMQ 都需要启动服务进程，这些都可以监控和配置，另外一个就有问题了。</li><li>ZeroMQ，它没有中间件架构，不需要任何服务进程和运行时。事实上，你的应用程序端点扮演了这个服务角色。这让部署起来非常简单，但担心的是， 你没有地方可以观察它是否有问题出现。就目前我知道的，ZeroMQ仅提供非持久性的队列。你可以在需要的地方实现自己的审计和数据恢复功能</li><li>如果你希望一个应用程序发送消息越快越好，你选择ZeroMQ。当你不太在意偶然会丢失某些消息的情况下更有价值。</li><li>虽然说ZeroMQ的速度很惊人,但是对于数据就是生命的年代,我们宁可降低一些需求也不愿意丢失任何一条宝贵的数据,所以综合对比下来,我觉得RabbitMQ更适合.</li></ul><h1 id="消息中间件Kafka与RabbitMQ谁更胜一筹"><a href="#消息中间件Kafka与RabbitMQ谁更胜一筹" class="headerlink" title="消息中间件Kafka与RabbitMQ谁更胜一筹"></a>消息中间件Kafka与RabbitMQ谁更胜一筹</h1><ul><li>在 IM 这种讲究高并发、高消息吞吐的互联网场景下，MQ 消息中间件是个很重要的基础设施，它在 IM 系统的服务端架构中担当消息中转、消息削峰、消息交换异步化等角色。</li><li>当然，MQ 消息中间件的作用远不止于此，它的价值不仅仅存在于技术上，更重要的是改变了以往同步处理消息的思路。</li><li>比如进行 IM 消息历史存储时，传统的信息系统作法可能是收到一条消息就马上同步存入数据库，这种作法在小并发量的情况下可以很好的工作，但互联网大并发环境下就是灾难。</li><li>MQ 消息中间件可以理解为一个水池，水池的这头是消息生产者，水池的那头是消息消费者，生产者和消息者无需直接对接，这将带来很多好处：业务解耦、架构分布式化等，生产者和消费者互相完全透明。</li></ul><h1 id="什么是消息队列中间件"><a href="#什么是消息队列中间件" class="headerlink" title="什么是消息队列中间件"></a>什么是消息队列中间件</h1><ul><li>消息队列中间件(简称消息中间件)是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</li><li>通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。</li><li>目前开源的消息中间件可谓是琳琅满目，能让大家耳熟能详的就有很多，比如 ActiveMQ、RabbitMQ、Kafka、RocketMQ、ZeroMQ 等，不管选择其中的哪一款，都会有用的不趁手的地方，毕竟不是为你量身定制的。</li><li>可能有些大厂在长期的使用过程中积累了一定的经验，加上其消息队列的使用场景也相对稳定固化，或者目前市面上的消息中间件无法满足自身需求，同时它也具备足够的精力和人力而选择自研来为自己量身打造一款消息中间件。</li><li>但是绝大多数公司还是不会选择重复造轮子，那么选择一款适合自己的消息中间件显得尤为重要。</li><li>就算是前者，那么在自研出稳定且可靠的相关产品之前也会经历这样一个选型过程。</li><li>在整体架构中引入消息中间件，势必要考虑很多因素，比如成本及收益问题，怎么样才能达到最优的性价比?</li><li>虽然消息中间件种类繁多，但是各自都有各自的侧重点，选择合适自己、扬长避短无疑是最好的方式。如果你对此感到无所适从，本文或许可以参考一二。</li></ul><h4 id="各类消息队列简述"><a href="#各类消息队列简述" class="headerlink" title="各类消息队列简述"></a>各类消息队列简述</h4><h5 id="ActiveMQ-1"><a href="#ActiveMQ-1" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h5><ul><li>Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。</li><li>不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为 Apollo，号称下一代 ActiveMQ，有兴趣的同学可自行了解。</li></ul><h5 id="RabbitMQ-3"><a href="#RabbitMQ-3" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul><li>采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。</li><li>RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。</li></ul><h5 id="Kafka-2"><a href="#Kafka-2" class="headerlink" title="Kafka"></a>Kafka</h5><ul><li>起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 ZooKeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。</li><li>它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用</li><li>目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</li></ul><h5 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h5><ul><li>是阿里开源的消息中间件，目前已经捐献给 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双 11 的洗礼，实力不容小觑。</li></ul><h5 id="ZeroMQ-1"><a href="#ZeroMQ-1" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h5><ul><li>号称史上最快的消息队列，基于 C 语言开发。ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩。</li><li>虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</li><li>目前市面上的消息中间件还有很多，比如腾讯系的 PhxQueue、CMQ、CKafka，又比如基于 Go 语言的 NSQ，有时人们也把类似 Redis 的产品也看做消息中间件的一种。</li></ul><h1 id="消息中间件选型要点"><a href="#消息中间件选型要点" class="headerlink" title="消息中间件选型要点"></a>消息中间件选型要点</h1><ul><li>衡量一款消息中间件是否符合需求，需要从多个维度进行考察。</li><li>首要的就是功能维度，这个直接决定了你能否最大程度上地实现开箱即用，进而缩短项目周期、降低成本等。</li><li>如果一款消息中间件的功能达不到想要的功能，那么就需要进行二次开发，这样会增加项目的技术难度、复杂度以及增大项目周期等。</li><li>消息中间件具体选型指标</li></ul><h4 id="功能维度"><a href="#功能维度" class="headerlink" title="功能维度"></a>功能维度</h4><h5 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h5><ul><li>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。</li><li>不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器(一般简单的称之为 Broker)中没有消息堆积。</li><li>那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</li></ul><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><ul><li>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”，这个是延迟队列的一种典型应用场景。</li><li>延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</li><li>延迟队列一般分为两种：<ul><li>基于消息的延迟，是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。</li><li>基于队列的延迟，实际应用中大多采用这种，设置不同延迟级别的队列，比如5s、10s、30s、1min、5mins、10mins等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略(比如定时)即可投递超时的消息。</li></ul></li></ul><h5 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h5><ul><li>由于某些原因消息无法被正确投递，为了确保消息不会被无故丢弃，一般将其置于一个特殊角色的队列，这个队列称为死信队列。</li><li>与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认(Ack), 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。</li><li>为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</li></ul><h5 id="重试队列"><a href="#重试队列" class="headerlink" title="重试队列"></a>重试队列</h5><ul><li>其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。</li><li>与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。</li><li>举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息。</li><li>如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。</li><li>以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。</li><li>重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发;延迟队列作用一次，而重试队列的作用范围会向后传递。</li></ul><h5 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h5><ul><li>消费模式分为推(push)模式和拉(pull)模式：<ul><li>推模式，是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。</li><li>拉模式，是指消费端主动向 Broker 端请求拉取(一般是定时或者定量)消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。</li></ul></li></ul><h5 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h5><ul><li>消息一般有两种传递模式——点对点(P2P，Point-to-Point)模式和发布&#x2F;订阅(Pub&#x2F;Sub)模式：</li><li>对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。</li><li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题(Topic)，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。</li><li>主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布&#x2F;订阅模式在消息的一对多广播时采用。</li><li>RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。</li><li>但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组(Consumer Group)的概念看成是队列的概念。</li><li>不过对比来说，Kafka 中因为有了消息回溯功能的存在，对于广播消费的力度支持比 RabbitMQ 的要强。</li></ul><h5 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h5><ul><li>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息</li><li>消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。</li><li>对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失，一般很难追查。</li><li>如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头所在。</li><li>消息回溯的作用远不止于此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。</li></ul><h5 id="消息堆积-持久化"><a href="#消息堆积-持久化" class="headerlink" title="消息堆积+持久化"></a>消息堆积+持久化</h5><ul><li>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。</li><li>从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。</li><li>消息堆积分内存式堆积和磁盘式堆积：</li><li>RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘(换页动作会影响吞吐)，或者直接使用惰性队列来将消息直接持久化至磁盘中。</li><li>Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。</li><li>一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。</li><li>从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引《纽约时报》的案例，其直接将 Kafka 用作存储系统。</li></ul><h5 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h5><ul><li>对于分布式架构系统中的链路追踪(Trace)，大家一定不陌生</li><li>对于消息中间件，消息的链路追踪(以下简称消息追踪)同样重要，最通俗来理解，就是要知道消息从哪来，存在哪里以及发往哪里去。</li><li>基于此功能，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。</li></ul><h5 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h5><ul><li>消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。</li><li>就以 Kafka 而言，完全可以将不同类别的消息发送至不同的 Topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 Topic 中的消息进行分类。</li><li>不过，更加严格意义上的消息过滤，应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。</li><li>同样以 Kafka 为例，可以通过客户端提供的 Consumer Interceptor 接口或者 Kafka Stream 的 Filter 功能进行消息过滤。</li></ul><h5 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h5><ul><li>也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。</li><li>RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 VHost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。</li><li>VHost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。</li></ul><h5 id="多协议支持"><a href="#多协议支持" class="headerlink" title="多协议支持"></a>多协议支持</h5><ul><li>消息是信息的载体，为了让生产者和消费者都能理解所承载的信息(生产者需要知道如何构造消息，消费者需要知道如何解析消息)，它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。</li><li>有效的消息一定具有某种格式，而没有格式的消息是没有意义的。</li><li>一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等(消息领域中的 JMS 更多的是一个规范而不是一个协议)，支持的协议越多其应用范围就会越广，通用性越强。</li><li>比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。</li></ul><h5 id="跨语言支持"><a href="#跨语言支持" class="headerlink" title="跨语言支持"></a>跨语言支持</h5><ul><li>对很多公司而言，其技术栈体系中会有多种编程语言，如 C&#x2F;C++、Java、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。</li><li>跨语言的支持力度也从侧面反映出一个消息中间件的流行程度。</li></ul><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><ul><li>针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应</li><li>通常的流控方法有 Stop-and-Wait、滑动窗口以及令牌桶等。</li></ul><h5 id="消息顺序性"><a href="#消息顺序性" class="headerlink" title="消息顺序性"></a>消息顺序性</h5><ul><li>顾名思义，是指保证消息有序</li><li>这个功能有个很常见的应用场景就是 CDC(Change Data Chapture)。</li><li>以 MySQL 为例，如果其传输的 Binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1，造成数据不一致。</li></ul><h5 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h5><ul><li>在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制：<ul><li>身份认证，是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制。</li><li>权限控制，是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。</li></ul></li><li>对于 RabbitMQ 而言，其同样提供身份认证(TLS&#x2F;SSL、SASL)和权限控制(读写操作)的安全机制。</li></ul><h5 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h5><ul><li>确保消息在生产者和消费者之间进行传输，一般有三种传输保障(Delivery Guarantee)：<ul><li>At most once，至多一次，消息可能丢失，但绝不会重复传输。</li><li>At least once，至少一次，消息绝不会丢，但是可能会重复。</li><li>Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。</li></ul></li><li>对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</li><li>Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等。</li><li>而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS(Exactly Once Semantic)的能力。</li><li>不过如果要考虑全局的幂等，还需要从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。</li><li>以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法由消息中间件层面来保证的。</li><li>如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。</li></ul><h5 id="事务性消息"><a href="#事务性消息" class="headerlink" title="事务性消息"></a>事务性消息</h5><ul><li>事务本身是一个并不陌生的词汇，事务是由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。</li><li>支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。</li><li>消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。</li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li>功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度，有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得。<br>K- afka 在开启幂等、事务功能的时候会使其性能降低;RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大影响其性能。</li></ul><h5 id="性能指什么"><a href="#性能指什么" class="headerlink" title="性能指什么?"></a>性能指什么?</h5><ul><li>消息中间件的性能一般是指其吞吐量</li><li>虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级。</li><li>一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。</li><li>注明：消息中间件的吞吐量始终会受到硬件层面的限制。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过(1Gb&#x2F;8)&#x2F;100W，即约等于 134B。</li><li>换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。</li></ul><h5 id="性能的指标是什么"><a href="#性能的指标是什么" class="headerlink" title="性能的指标是什么?"></a>性能的指标是什么?</h5><ul><li>时延作为性能维度的一个重要指标，却往往在消息中间件领域被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。</li><li>消息中间件具备消息堆积的能力，消息堆积越大也就意味着端到端的时延也就越长，与此同时延时队列也是某些消息中间件的一大特色。那么为什么还要关注消息中间件的时延问题呢?</li><li>消息中间件能够解耦系统，对于一个时延较低的消息中间件而言，它可以让上游生产者发送消息之后可以迅速的返回，也可以让消费者更加快速的获取到消息，在没有堆积的情况下，可以让整体上下游的应用之间的级联动作更加高效。</li><li>虽然不建议在时效性很高的场景下使用消息中间件，但是如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。</li></ul><h4 id="可靠性-可用性"><a href="#可靠性-可用性" class="headerlink" title="可靠性+可用性"></a>可靠性+可用性</h4><ul><li>消息丢失是使用消息中间件时所不得不面对的一个痛点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素</li><li>尤其是在金融支付领域，消息可靠性尤为重要。</li><li>然而说到可靠性必然要说到可用性，注意这两者之间的区别：<ul><li>可靠性是指对消息不丢失的保障程度。</li><li>可用性是指无故障运行的时间百分比，通常用几个 9 来衡量。</li></ul></li><li>从狭义的角度来说，分布式系统架构是一致性协议理论的应用实现，对于消息可靠性和可用性而言也可以追溯到消息中间件背后的一致性协议：<ul><li>对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，通过 ISR(In-Sync-Replica)来保证多副本之间的同步，并且支持强一致性语义(通过 Acks 实现)。</li><li>对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。</li></ul></li><li>多副本可以保证在 Master 节点宕机异常之后可以提升 Slave 作为新的 Master 而继续提供服务来保障可用性。</li><li>Kafka 设计之初是为日志处理而生，给人们留下了数据可靠性要求不高的不良印象，但是随着版本的升级优化，其可靠性得到极大的增强，详细可以参考 KIP101。</li><li>就目前而言，在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多，随着 RabbitMQ 性能的不断提升和 Kafka 可靠性的进一步增强，相信彼此都能在以前不擅长的领域分得一杯羹。</li><li>同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘。</li><li>但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。</li><li>这里还要提及的一个方面是扩展能力，这里我狭隘地将此归纳到可用性这一维度，消息中间件的扩展能力能够增强其可用能力及范围，比如前面提到的 RabbitMQ 支持多种消息协议，这个就是基于其插件化的扩展实现。</li><li>还有从集群部署上来讲，归功于 Kafka 的水平扩展能力，其基本上可以达到线性容量提升的水平，在 LinkedIn 实践介绍中就提及了有部署超过千台设备的 Kafka 集群。</li></ul><h4 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h4><ul><li>在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复?</li><li>业务线流量有峰值有低谷，尤其是电商领域，那么怎样进行有效的容量评估，尤其是大促期间?脚踢电源、网线被挖等事件层出不穷，如何有效的做好异地多活?</li><li>这些都离不开消息中间件的衍生产品——运维管理。运维管理也可以进行进一步的细分，比如申请、审核、监控、告警、管理、容灾、部署等。</li><li>申请、审核很好理解，在源头对资源进行管控，既可以有效校正应用方的使用规范，配合监控也可以做好流量统计与流量评估工作。</li><li>一般申请、审核与公司内部系统交融性较大，不适合使用开源类的产品。</li><li>监控、告警也比较好理解，对消息中间件的使用进行全方位的监控，既可以为系统提供基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。</li><li>除了一般的监控项(比如硬件、GC 等)之外，消息中间件还需要关注端到端时延、消息审计、消息堆积等方面：</li><li>对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，但是社区内还有 AppDynamics、Collectd、DataDog、Ganglia、Munin、Nagios、New Relic、Prometheus、Zenoss 等多种优秀的产品。</li><li>Kafka 在此方面也毫不逊色，比如：Kafka Manager、Kafka Monitor、Kafka Offset Monitor、Burrow、Chaperone、Confluent Control Center 等产品，尤其是 Cruise 还可以提供自动化运维的功能。</li><li>不管是扩容、降级、版本升级、集群节点部署、还是故障处理都离不开管理工具的应用，一个配套完备的管理工具集可以在遇到变更时做到事半功倍。</li><li>故障可大可小，一般是一些应用异常，也可以是机器掉电、网络异常、磁盘损坏等单机故障，这些故障单机房内的多副本足以应付。</li><li>如果是机房故障就要涉及异地容灾了，关键点在于如何有效的进行数据复制，Kafka 可以参考 MirrorMarker、uReplicator 等产品，而 RabbitMQ 可以参考 Federation 和 Shovel。</li></ul><h4 id="社区力度及生态发展"><a href="#社区力度及生态发展" class="headerlink" title="社区力度及生态发展"></a>社区力度及生态发展</h4><ul><li>对于目前流行的编程语言而言，如 Java、Python，如果你在使用过程中遇到了一些异常，基本上可以通过搜索引擎的帮助来得到解决，因为一个产品用的人越多，踩过的坑也就越多，对应的解决方案也就越多。</li><li>消息中间件也同样适用，如果你选择了一种“生僻”的消息中间件，可能在某些方面运用的得心应手，但是版本更新缓慢、遇到棘手问题也难以得到社区的支持而越陷越深。</li><li>相反如果你选择了一种“流行”的消息中间件，其更新力度大，不仅可以迅速的弥补之前的不足，而且也能顺应技术的快速发展来变更一些新的功能，这样可以让你也“站在巨人的肩膀上”。</li><li>在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。</li></ul><h4 id="消息中间件选型误区总结"><a href="#消息中间件选型误区总结" class="headerlink" title="消息中间件选型误区总结"></a>消息中间件选型误区总结</h4><h5 id="选型误区"><a href="#选型误区" class="headerlink" title="选型误区"></a>选型误区</h5><ul><li>选型之前可以先问自己一个问题：是否真的需要一个消息中间件?</li><li>在搞清楚这个问题之后，还可以继续问自己一个问题：是否需要自己维护一套消息中间件?</li><li>很多初创型公司为了节省成本会选择直接购买消息中间件有关的云服务，自己只需要关注收发消息即可，其余的都可以外包出去。</li><li>很多人面对消息中间件有一种自研的冲动，你完全可以对 Java 中的 ArrayBlockingQueue 做一个简单的封装，你也可以基于文件、数据库、Redis 等底层存储封装而形成一个消息中间件。</li><li>消息中间件做为一个基础组件并没有想象中的那么简单，其背后还需要配套的管理运维整个生态的产品集。</li><li>自研还会有交接问题，如果文档不齐全、运作不规范将会带给新人噩梦般的体验。</li><li>是否真的有自研的必要?如果不是 KPI 的压迫可以先考虑下面这两个问题：<ul><li>目前市面上的消息中间件是否都真的无法满足目前的业务需求?</li><li>团队是否有足够的能力、人力、财力、精力来支持自研?</li></ul></li><li>很多人在做消息中间件选型时会参考网络上的很多对比类的文章，但是其专业性、严谨性、以及其政治立场问题都有待考证，需要带着怀疑的态度去审视这些文章。</li><li>比如有些文章会在没有任何限定条件及场景的情况下直接定义某款消息中间件最好。</li><li>还有些文章没有指明消息中间件版本及测试环境就来做功能和性能对比分析，诸如此类的文章都可以唾弃之。</li><li>消息中间件犹如小马过河，选择合适的才最重要。这需要贴合自身的业务需求，技术服务于业务，大体上可以根据上一节所提及的功能、性能等 6 个维度来一一进行筛选。更深层次的抉择在于你能否掌握其魂。</li><li>笔者鄙见：RabbitMQ 在于 Routing，而 Kafka 在于 Streaming，了解其根本对于自己能够对症下药选择到合适的消息中间件尤为重要。</li><li>消息中间件选型切忌一味的追求性能或者功能，性能可以优化，功能可以二次开发。</li><li>如果要在功能和性能方面做一个抉择的话，那么首选性能，因为总体上来说性能优化的空间没有功能扩展的空间大。然而看长期发展，生态又比性能以及功能都要重要。</li></ul><h5 id="可靠性误区"><a href="#可靠性误区" class="headerlink" title="可靠性误区"></a>可靠性误区</h5><ul><li>很多时候，可靠性方面也容易存在一个误区：想要找到一个产品来保证消息的绝对可靠，很不幸的是这世界上没有绝对的东西，只能说尽量趋于完美。</li><li>想要尽可能的保障消息的可靠性也并非单单只靠消息中间件本身，还要依赖于上下游，需要从生产端、服务端和消费端这 3 个维度去努力保证。</li><li>消息中间件选型还有一个考量标准就是尽量贴合团队自身的技术栈体系，虽然说没有蹩脚的消息中间件，只有蹩脚的程序员，但是让一个 C 栈的团队去深挖 PhxQueue 总比去深挖 Scala 编写的 Kafka 要容易的多。</li><li>消息中间件大道至简：一发一存一消费，没有最好的消息中间件，只有最合适的消息中间件</li></ul><h1 id="消息服务的应用场景有哪些？"><a href="#消息服务的应用场景有哪些？" class="headerlink" title="消息服务的应用场景有哪些？"></a>消息服务的应用场景有哪些？</h1><ul><li>如下 3 个场景都可以使用消息服务<ul><li>异步处理</li><li>应用的解耦</li><li>流量的削峰</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/4/">4</a><span class="page-number current">5</span></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">944k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">14:18</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>