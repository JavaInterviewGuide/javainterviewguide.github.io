<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"defalut"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/index.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/6a0bdde6e107.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/6a0bdde6e107.html" class="post-title-link" itemprop="url">RabbitMQ</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-05 17:05:19 / 修改时间：18:24:56" itemprop="dateCreated datePublished" datetime="2024-01-05T17:05:19+08:00">2024-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="RabbitMQ-有哪些重要的角色？"><a href="#RabbitMQ-有哪些重要的角色？" class="headerlink" title="RabbitMQ 有哪些重要的角色？"></a>RabbitMQ 有哪些重要的角色？</h1><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器</li><li>消费者：消息的接收方，用于处理数据和确认消息</li><li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色</li></ul><h1 id="RabbitMQ-有哪些重要的组件？"><a href="#RabbitMQ-有哪些重要的组件？" class="headerlink" title="RabbitMQ 有哪些重要的组件？"></a>RabbitMQ 有哪些重要的组件？</h1><ul><li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用</li><li>Channel（信道）：消息推送使用的通道</li><li>Exchange（交换器）：用于接受、分配消息</li><li>Queue（队列）：用于存储生产者的消息</li><li>RoutingKey（路由键）：用于把生产者的数据分配到交换器上</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上</li></ul><h1 id="RabbitMQ-中-vhost-的作用是什么？"><a href="#RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="RabbitMQ 中 vhost 的作用是什么？"></a>RabbitMQ 中 vhost 的作用是什么？</h1><ul><li>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机</li><li>每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制</li></ul><h1 id="RabbitMQ的消息是怎么发送的？"><a href="#RabbitMQ的消息是怎么发送的？" class="headerlink" title="RabbitMQ的消息是怎么发送的？"></a>RabbitMQ的消息是怎么发送的？</h1><ul><li>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息</li><li>客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证，你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel）</li><li>认证就是你发送给 rabbit 服务器的用户名和密码</li><li>信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的</li></ul><h1 id="RabbitMQ-怎么保证消息的稳定性？"><a href="#RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="RabbitMQ 怎么保证消息的稳定性？"></a>RabbitMQ 怎么保证消息的稳定性？</h1><ul><li>提供了事务的功能</li><li>通过将 channel 设置为 confirm（确认）模式</li></ul><h1 id="RabbitMQ-怎么避免消息丢失？"><a href="#RabbitMQ-怎么避免消息丢失？" class="headerlink" title="RabbitMQ 怎么避免消息丢失？"></a>RabbitMQ 怎么避免消息丢失？</h1><ul><li>把消息持久化磁盘，保证服务器重启消息不丢失</li><li>每个集群中至少有一个物理磁盘，保证消息落入磁盘</li></ul><h1 id="RabbitMQ-持久化有什么缺点？"><a href="#RabbitMQ-持久化有什么缺点？" class="headerlink" title="RabbitMQ 持久化有什么缺点？"></a>RabbitMQ 持久化有什么缺点？</h1><ul><li>降低了服务器的吞吐量</li><li>因为使用的是磁盘而非内存存储，从而降低了吞吐量</li><li>可尽量使用 ssd 硬盘来缓解吞吐量的问题</li></ul><h1 id="RabbitMQ有几种广播类型？"><a href="#RabbitMQ有几种广播类型？" class="headerlink" title="RabbitMQ有几种广播类型？"></a>RabbitMQ有几种广播类型？</h1><ul><li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发。</li><li>headers：与 direct 类似，只是性能很差，此类型几乎用不到</li><li>fanout：分发模式，把消费分发给所有订阅者</li><li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到</li></ul><h1 id="RabbitMQ-怎么实现延迟消息队列？"><a href="#RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="RabbitMQ 怎么实现延迟消息队列？"></a>RabbitMQ 怎么实现延迟消息队列？</h1><ul><li>延迟队列的实现有两种方式：<ul><li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能</li><li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能</li></ul></li></ul><h1 id="RabbitMQ-集群有什么用？"><a href="#RabbitMQ-集群有什么用？" class="headerlink" title="RabbitMQ 集群有什么用？"></a>RabbitMQ 集群有什么用？</h1><ul><li>集群主要有以下两个用途：<ul><li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用</li><li>高容量：集群可以承载更多的消息量</li></ul></li></ul><h1 id="RabbitMQ-节点的类型有哪些？"><a href="#RabbitMQ-节点的类型有哪些？" class="headerlink" title="RabbitMQ 节点的类型有哪些？"></a>RabbitMQ 节点的类型有哪些？</h1><ul><li>磁盘节点：消息会存储到磁盘</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型</li></ul><h1 id="RabbitMQ-集群搭建需要注意哪些问题？"><a href="#RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="RabbitMQ 集群搭建需要注意哪些问题？"></a>RabbitMQ 集群搭建需要注意哪些问题？</h1><ul><li>各节点之间使用“–link”连接，此属性不能忽略</li><li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证</li><li>整个集群中必须包含一个磁盘节点</li></ul><h1 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h1><ul><li>不是</li><li>原因有以下两个<ul><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟</li></ul></li></ul><h1 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h1><ul><li>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li><li>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西</li></ul></li></ul><h1 id="RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗？"></a>RabbitMQ 对集群节点停止顺序有要求吗？</h1><ul><li>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点</li><li>如果顺序恰好相反的话，可能会造成消息的丢失</li></ul><h1 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h1><ul><li>以下四个条件都满足才能保证消息持久化成功<ul><li>声明队列必须设置持久化 durable 设置为 true</li><li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）</li><li>消息已经到达持久化交换器</li><li>消息已经到达持久化队列</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/39a9c27510d2.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/39a9c27510d2.html" class="post-title-link" itemprop="url">微服务</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-04 00:50:49 / 修改时间：01:00:46" itemprop="dateCreated datePublished" datetime="2024-01-04T00:50:49+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="您对微服务有何了解？"><a href="#您对微服务有何了解？" class="headerlink" title="您对微服务有何了解？"></a>您对微服务有何了解？</h1><ul><li>微服务，又称微服务 架构，是一种架构风格，它将应用程序构建为以业务领域为模型的小型自治服务集合 。</li><li>通俗地说，你必须看到蜜蜂如何通过对齐六角形蜡细胞来构建它们的蜂窝状物。</li><li>他们最初从使用各种材料的小部分开始，并继续从中构建一个大型蜂箱。这些细胞形成图案，产生坚固的结构，将蜂窝的特定部分固定在一起。这里，每个细胞独立于另一个细胞，但它也与其他细胞相关。这意味着对一个细胞的损害不会损害其他细胞，因此，蜜蜂可以在不影响完整蜂箱的情况下重建这些细胞。这里，每个六边形形状代表单独的服务组件。与蜜蜂的工作类似，每个敏捷团队都使用可用的框架和所选的技术堆栈构建单独的服务组件。就像在蜂箱中一样，每个服务组件形成一个强大的微服务架构，以提供更好的可扩展性。此外，敏捷团队可以单独处理每个服务组件的问题，而对整个应用程序没有影响或影响最小。</li></ul><h1 id="微服务架构有哪些优势？"><a href="#微服务架构有哪些优势？" class="headerlink" title="微服务架构有哪些优势？"></a>微服务架构有哪些优势？</h1><ul><li>独立开发 – 所有微服务都可以根据各自的功能轻松开发</li><li>独立部署 – 基于其服务，可以在任何应用程序中单独部署它们</li><li>故障隔离 – 即使应用程序的一项服务不起作用，系统仍可继续运行</li><li>混合技术堆栈 – 可以使用不同的语言和技术来构建同一应用程序的不同服务</li><li>粒度缩放 – 单个组件可根据需要进行缩放，无需将所有组件缩放在一起</li></ul><h1 id="微服务有哪些特点？"><a href="#微服务有哪些特点？" class="headerlink" title="微服务有哪些特点？"></a>微服务有哪些特点？</h1><ul><li>解耦 – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展</li><li>组件化 – 微服务被视为可以轻松更换和升级的独立组件</li><li>业务能力 – 微服务非常简单，专注于单一功能</li><li>自治 – 开发人员和团队可以彼此独立工作，从而提高速度</li><li>持续交付 – 通过软件创建，测试和批准的系统自动化，允许频繁发布软件</li><li>责任 – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品</li><li>分散治理 – 重点是使用正确的工具来做正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</li><li>敏捷 – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃</li></ul><h1 id="微服务架构如何运作？"><a href="#微服务架构如何运作？" class="headerlink" title="微服务架构如何运作？"></a>微服务架构如何运作？</h1><ul><li>微服务架构具有以下组件：<ul><li>客户端 – 来自不同设备的不同用户发送请求。</li><li>身份提供商 – 验证用户或客户身份并颁发安全令牌。</li><li>API 网关 – 处理客户端请求。</li><li>静态内容 – 容纳系统的所有内容。</li><li>管理 – 在节点上平衡服务并识别故障。</li><li>服务发现 – 查找微服务之间通信路径的指南。</li><li>内容交付网络 – 代理服务器及其数据中心的分布式网络。</li><li>远程服务 – 启用驻留在 IT 设备网络上的远程访问信息。</li></ul></li></ul><h1 id="单片，SOA-和微服务架构有什么区别？"><a href="#单片，SOA-和微服务架构有什么区别？" class="headerlink" title="单片，SOA 和微服务架构有什么区别？"></a>单片，SOA 和微服务架构有什么区别？</h1><ul><li>单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密封装。</li><li>一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数据传递，也可以涉及两个或多个协调某些活动的服务。</li><li>微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。</li></ul><h1 id="在使用微服务架构时，您面临哪些挑战？"><a href="#在使用微服务架构时，您面临哪些挑战？" class="headerlink" title="在使用微服务架构时，您面临哪些挑战？"></a>在使用微服务架构时，您面临哪些挑战？</h1><ul><li>开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。</li><li>自动化组件：难以自动化，因为有许多较小的组件。因此，对于每个组件，我们必须遵循 Build，Deploy 和 Monitor 的各个阶段。</li><li>易感性：将大量组件维护在一起变得难以部署，维护，监控和识别问题。它需要在所有组件周围具有很好的感知能力。</li><li>配置管理：有时在各种环境中维护组件的配置变得困难。</li><li>调试：很难找到错误的每一项服务。维护集中式日志记录和仪表板以调试问题至关重要。</li></ul><h1 id="什么是无所不在的语言？"><a href="#什么是无所不在的语言？" class="headerlink" title="什么是无所不在的语言？"></a>什么是无所不在的语言？</h1><ul><li>如果您必须定义泛在语言（UL），那么它是特定域的开发人员和用户使用的通用语言，通过该语言可以轻松解释域。</li><li>无处不在的语言必须非常清晰，以便它将所有团队成员放在同一页面上，并以机器可以理解的方式进行翻译。</li></ul><h1 id="什么是凝聚力？"><a href="#什么是凝聚力？" class="headerlink" title="什么是凝聚力？"></a>什么是凝聚力？</h1><ul><li>模块内部元素所属的程度被认为是凝聚力。</li></ul><h1 id="什么是耦合？"><a href="#什么是耦合？" class="headerlink" title="什么是耦合？"></a>什么是耦合？</h1><ul><li>组件之间依赖关系强度的度量被认为是耦合。一个好的设计总是被认为具有高内聚力和低耦合性。</li></ul><h1 id="什么是-REST-RESTful-以及它的用途是什么？"><a href="#什么是-REST-RESTful-以及它的用途是什么？" class="headerlink" title="什么是 REST &#x2F; RESTful 以及它的用途是什么？"></a>什么是 REST &#x2F; RESTful 以及它的用途是什么？</h1><ul><li>Representational State Transfer（REST）&#x2F; RESTful Web 服务是一种帮助计算机系统通过 Internet 进行通信的架构风格。这使得微服务更容易理解和实现。</li><li>微服务可以使用或不使用 RESTful API 实现，但使用 RESTful API 构建松散耦合的微服务总是更容易。</li></ul><h1 id="什么是-Spring-引导的执行器？"><a href="#什么是-Spring-引导的执行器？" class="headerlink" title="什么是 Spring 引导的执行器？"></a>什么是 Spring 引导的执行器？</h1><ul><li>Spring Boot 执行程序提供了 restful Web 服务，以访问生产环境中运行应用程序的当前状态。在执行器的帮助下，您可以检查各种指标并监控您的应用程序。</li></ul><h1 id="什么是-Spring-Cloud？"><a href="#什么是-Spring-Cloud？" class="headerlink" title="什么是 Spring Cloud？"></a>什么是 Spring Cloud？</h1><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，领导选举，分布式会话，集群状态）。</p><h1 id="Spring-Cloud-解决了哪些问题？"><a href="#Spring-Cloud-解决了哪些问题？" class="headerlink" title="Spring Cloud 解决了哪些问题？"></a>Spring Cloud 解决了哪些问题？</h1><ul><li>在使用 Spring Boot 开发分布式微服务时，我们面临的问题很少由 Spring Cloud解决。</li><li>与分布式系统相关的复杂性 – 包括网络问题，延迟开销，带宽问题，安全问题。</li><li>处理服务发现的能力 – 服务发现允许集群中的进程和服务找到彼此并进行通信。</li><li>解决冗余问题 – 冗余问题经常发生在分布式系统中。</li><li>负载平衡 – 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布。</li><li>减少性能问题 – 减少因各种操作开销导致的性能问题。</li></ul><h1 id="在-Spring-MVC-应用程序中使用-WebMvcTest-注释有什么用处？"><a href="#在-Spring-MVC-应用程序中使用-WebMvcTest-注释有什么用处？" class="headerlink" title="在 Spring MVC 应用程序中使用 WebMvcTest 注释有什么用处？"></a>在 Spring MVC 应用程序中使用 WebMvcTest 注释有什么用处？</h1><ul><li>在测试目标只关注 Spring MVC 组件的情况下，WebMvcTest 注释用于单元测试Spring MVC 应用程序。在上面显示的快照中，我们只想启动 ToTestController。</li><li>执行此单元测试时，不会启动所有其他控制器和映射。</li></ul><h1 id="你能否给出关于休息和微服务的要点？"><a href="#你能否给出关于休息和微服务的要点？" class="headerlink" title="你能否给出关于休息和微服务的要点？"></a>你能否给出关于休息和微服务的要点？</h1><ul><li>虽然您可以通过多种方式实现微服务，但 REST over HTTP 是实现微服务的一种方式。REST 还可用于其他应用程序，如 Web 应用程序，API 设计和 MVC 应用程序，以提供业务数据。</li><li>微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用程序。</li><li>简而言之，您可以说 REST 是构建微服务的媒介。</li></ul><h1 id="什么是不同类型的微服务测试？"><a href="#什么是不同类型的微服务测试？" class="headerlink" title="什么是不同类型的微服务测试？"></a>什么是不同类型的微服务测试？</h1><ul><li>在使用微服务时，由于有多个微服务协同工作，测试变得非常复杂。因此，测试分为不同的级别。</li><li>在底层，我们有面向技术的测试，如单元测试和性能测试。这些是完全自动化的。</li><li>在中间层面，我们进行了诸如压力测试和可用性测试之类的探索性测试。</li><li>在顶层， 我们的 验收测试数量很少。这些验收测试有助于利益相关者理解和验证软件功能。</li></ul><h1 id="您对-Distributed-Transaction-有何了解？"><a href="#您对-Distributed-Transaction-有何了解？" class="headerlink" title="您对 Distributed Transaction 有何了解？"></a>您对 Distributed Transaction 有何了解？</h1><ul><li>分布式事务是指单个事件导致两个或多个不能以原子方式提交的单独数据源的突变的任何情况。在微服务的世界中，它变得更加复杂，因为每个服务都是一个工作单元，并且大多数时候多个服务必须协同工作才能使业务成功。</li></ul><h1 id="什么是-Idempotence-以及它在哪里使用？"><a href="#什么是-Idempotence-以及它在哪里使用？" class="headerlink" title="什么是 Idempotence 以及它在哪里使用？"></a>什么是 Idempotence 以及它在哪里使用？</h1><ul><li>幂等性是能够以这样的方式做两次事情的特性，即最终结果将保持不变，即好像它只做了一次。</li><li>用法：在远程服务或数据源中使用 Idempotence，这样当它多次接收指令时，它只处理指令一次。</li></ul><h1 id="什么是有界上下文？"><a href="#什么是有界上下文？" class="headerlink" title="什么是有界上下文？"></a>什么是有界上下文？</h1><ul><li>有界上下文是域驱动设计的核心模式。DDD 战略设计部门的重点是处理大型模型和团队。DDD 通过将大型模型划分为不同的有界上下文并明确其相互关系来处理大型模型。</li></ul><h1 id="什么是双因素身份验证？"><a href="#什么是双因素身份验证？" class="headerlink" title="什么是双因素身份验证？"></a>什么是双因素身份验证？</h1><ul><li>双因素身份验证为帐户登录过程启用第二级身份验证。</li><li>因此，假设用户必须只输入用户名和密码，那么这被认为是单因素身份验证。</li></ul><h1 id="什么是客户证书？"><a href="#什么是客户证书？" class="headerlink" title="什么是客户证书？"></a>什么是客户证书？</h1><ul><li>客户端系统用于向远程服务器发出经过身份验证的请求的一种数字证书称为客户端证书。客户端证书在许多相互认证设计中起着非常重要的作用，为请求者的身份提供了强有力的保证。</li></ul><h1 id="PACT-在微服务架构中的用途是什么？"><a href="#PACT-在微服务架构中的用途是什么？" class="headerlink" title="PACT 在微服务架构中的用途是什么？"></a>PACT 在微服务架构中的用途是什么？</h1><ul><li>PACT 是一个开源工具，允许测试服务提供者和消费者之间的交互，与合同隔离，从而提高微服务集成的可靠性。</li><li>微服务中的用法</li><li>用于在微服务中实现消费者驱动的合同。</li><li>测试微服务的消费者和提供者之间的消费者驱动的合同。</li><li>查看即将到来的批次</li></ul><h1 id="什么是-OAuth？"><a href="#什么是-OAuth？" class="headerlink" title="什么是 OAuth？"></a>什么是 OAuth？</h1><ul><li>OAuth 代表开放授权协议。这允许通过在 HTTP 服务上启用客户端应用程序（例如第三方提供商 Facebook，GitHub 等）来访问资源所有者的资源。因此，您可以在不使用其凭据的情况下与另一个站点共享存储在一个站点上的资源。</li></ul><h1 id="康威定律是什么？"><a href="#康威定律是什么？" class="headerlink" title="康威定律是什么？"></a>康威定律是什么？</h1><ul><li>“任何 设计 系统 的组 织（ 广泛 定义 ）都 将产 生一 种设 计， 其结 构是 组织 通信 结构的副 本。” – Mel Conway</li><li>该法律基本上试图传达这样一个事实：为了使软件模块起作用，整个团队应该进行良好的沟通。因此，系统的结构反映了产生它的组织的社会边界。</li></ul><h1 id="合同测试你懂什么？"><a href="#合同测试你懂什么？" class="headerlink" title="合同测试你懂什么？"></a>合同测试你懂什么？</h1><ul><li>根据 Martin Flower 的说法，合同测试是在外部服务边界进行的测试，用于验证其是否符合消费服务预期的合同。</li><li>此外，合同测试不会深入测试服务的行为。更确切地说，它测试该服务调用的输入＆输出包含所需的属性和所述响应延迟，吞吐量是允许的限度内。</li></ul><h1 id="什么是端到端微服务测试？"><a href="#什么是端到端微服务测试？" class="headerlink" title="什么是端到端微服务测试？"></a>什么是端到端微服务测试？</h1><ul><li>端到端测试验证了工作流中的每个流程都正常运行。这可确保系统作为一个整体协同工作并满足所有要求。</li><li>通俗地说，你可以说端到端测试是一种测试，在特定时期后测试所有东西。</li></ul><h1 id="Container-在微服务中的用途是什么？"><a href="#Container-在微服务中的用途是什么？" class="headerlink" title="Container 在微服务中的用途是什么？"></a>Container 在微服务中的用途是什么？</h1><ul><li>容器是管理基于微服务的应用程序以便单独开发和部署它们的好方法。您可以将微服务封装在容器映像及其依赖项中，然后可以使用它来滚动按需实例的微服务，而无需任何额外的工作。</li></ul><h1 id="什么是微服务架构中的-DRY？"><a href="#什么是微服务架构中的-DRY？" class="headerlink" title="什么是微服务架构中的 DRY？"></a>什么是微服务架构中的 DRY？</h1><ul><li>DRY 代表不要重复自己。它基本上促进了重用代码的概念。这导致开发和共享库，这反过来导致紧密耦合。</li></ul><h1 id="什么是消费者驱动的合同（CDC）？"><a href="#什么是消费者驱动的合同（CDC）？" class="headerlink" title="什么是消费者驱动的合同（CDC）？"></a>什么是消费者驱动的合同（CDC）？</h1><ul><li>这基本上是用于开发微服务的模式，以便它们可以被外部系统使用。当我们处理微服务时，有一个特定的提供者构建它，并且有一个或多个使用微服务的消费者。</li><li>通常，提供程序在 XML 文档中指定接口。但在消费者驱动的合同中，每个服务消费者都传达了提供商期望的接口。</li></ul><h1 id="Web，RESTful-API-在微服务中的作用是什么？"><a href="#Web，RESTful-API-在微服务中的作用是什么？" class="headerlink" title="Web，RESTful API 在微服务中的作用是什么？"></a>Web，RESTful API 在微服务中的作用是什么？</h1><ul><li>微服务架构基于一个概念，其中所有服务应该能够彼此交互以构建业务功能。因此，要实现这一点，每个微服务必须具有接口。这使得 Web API 成为微服务的一个非常重要的推动者。RESTful API 基于 Web 的开放网络原则，为构建微服务架构的各个组件之间的接口提供了最合理的模型。</li></ul><h1 id="您对微服务架构中的语义监控有何了解？"><a href="#您对微服务架构中的语义监控有何了解？" class="headerlink" title="您对微服务架构中的语义监控有何了解？"></a>您对微服务架构中的语义监控有何了解？</h1><ul><li>语义监控，也称为 综合监控， 将自动化测试与监控应用程序相结合，以检测业务失败因素。</li></ul><h1 id="我们如何进行跨功能测试？"><a href="#我们如何进行跨功能测试？" class="headerlink" title="我们如何进行跨功能测试？"></a>我们如何进行跨功能测试？</h1><ul><li>跨功能测试是对非功能性需求的验证，即那些无法像普通功能那样实现的需求。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/193c3be66867.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/193c3be66867.html" class="post-title-link" itemprop="url">日志</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-03 23:25:51 / 修改时间：23:45:01" itemprop="dateCreated datePublished" datetime="2024-01-03T23:25:51+08:00">2024-01-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%97%A5%E5%BF%97/" itemprop="url" rel="index"><span itemprop="name">日志</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h4 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h4><ul><li>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带的 java.util.logging.Logger 等。</li></ul><h4 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h4><ul><li>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。Log4j 由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。<ul><li>Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制</li><li>Appenders : 指定了日志将打印到控制台还是文件中</li><li>Layout : 控制日志信息的显示格式</li></ul></li><li>Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为 DEBUG、INFO、WARN、ERROR 和 FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码。</li></ul><h4 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h4><ul><li>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。</li><li>Logback 主要由三个模块组成：logback-core，logback-classic。logback-access logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的 通用机制。</li><li>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J；</li><li>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与HTTP 访问相关的功能。</li></ul><h4 id="Logback-优点"><a href="#Logback-优点" class="headerlink" title="Logback 优点"></a>Logback 优点</h4><ul><li>同样的代码路径，Logback 执行更快</li><li>更充分的测试</li><li>原生实现了 SLF4J API（Log4J 还需要有一个中间转换层）</li><li>内容更丰富的文档</li><li>支持 XML 或者 Groovy 方式配置</li><li>配置文件自动热加载</li><li>从 IO 错误中优雅恢复</li><li>自动删除日志归档</li><li>自动压缩日志成为归档文件</li><li>支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件</li><li>支持配置文件中加入条件判断来适应不同的环境</li><li>更强大的过滤器</li><li>支持 SiftingAppender（可筛选 Appender）</li><li>异常栈信息带有包信息</li></ul><h4 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h4><ul><li>ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打造大规模日志实时处理系统。<ul><li>Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将日志索引并存储起来，方便业务方检索查询。</li><li>Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理。</li><li>Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方，比如各类饼图、直方图、区域图等。</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c96491b71c82.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/c96491b71c82.html" class="post-title-link" itemprop="url">Maven</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-03 16:22:49 / 修改时间：16:28:26" itemprop="dateCreated datePublished" datetime="2024-01-03T16:22:49+08:00">2024-01-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">代码管理</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是-Maven？"><a href="#什么是-Maven？" class="headerlink" title="什么是 Maven？"></a>什么是 Maven？</h1><ul><li>Maven 使用项目对象模型(POM)的概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</li><li>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具</li><li>由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目</li><li>由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发布时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</li><li>Maven 的出现，解决了开发过程中的 jar 包升级及依赖的难题</li><li>它可以对项目依赖的 jar包进行管理，可以让你的项目保持基本的依赖，排除冗余 jar 包，并且可以让你非常轻松的对依赖的 jar 包进行版本升级</li><li>而这些仅仅是 Maven 最基本的功能，它可以在这基础上对项目进行清理、编译、测试、打包、发布等等构建项目的工作。</li><li>可以说，Maven 是现在 Java 社区中最强大的项目管理和项目构建工具，而更加值得庆幸的是，这样一个强大的工具，它的使用也是非常简单的。</li><li>现在，JavaEE 项目使用的开源软件都可以通过 Maven 来获取，并且，越来越多的公司也开始使用 Maven 来管理构建项目了。</li></ul><h1 id="Maven-和-ANT-的区别"><a href="#Maven-和-ANT-的区别" class="headerlink" title="Maven 和 ANT 的区别"></a>Maven 和 ANT 的区别</h1><ul><li>maven&amp;ant 同属 apach 是流行的构建工具。</li><li>都是为了简化软件开发而存在的。但是 maven 因为自身管理一个项目对象模型（project object model），这个模型其实就是抽象了一个项目的开发流程，它包含了一个项目的生命周期的各个阶段，并将这个周期固定下来，这也就是约定大于配置。约定大于配置的意思就是，我 maven 将项目开发的各个阶段固定起来了，每个文件的存放位置，每个阶段要生成什么文件、保存为什么格式并且要把它放在什么位置，我都固定好了。我知道一个软件是怎么开发出来，如果一个项目要使用 maven，可以，但你要遵循我的规则，文件目录不要乱建乱放，只有这样 maven 才会将源码用起来。这就是约定大于配置，因为 maven 已经将流程固定下来了，只要遵守约定，就不需要自己手动去配置了，这将大大地提高开发效率。- 就像是开车一样，只要知道点火、油门、方向、刹车，就可以将车子开东起来（当然出于安全和法律考虑，还是要考驾照的。），关于车子内部的传动原理，电气原理，工程原理，普通人并不需要了解多少，日常够用就好了。这也是约定大于配置的一个例子。配置就是自己造一辆车去开，有必要，有能力，有时间吗？</li><li>maven 的中央仓库和 pom.xml 文件。中央仓库统一存放了开发用到的各种 jar 包，要用时只需要添加依赖到 pom 文件中，maven 就会自动下载，当然为了方便一般会在本地建一个仓库，减少下载时间。pom 文件是 maven 的配置文件，maven 就是通过管理 pom 文件和一些核心插件来管理项目。当然我前面将 maven 拟人化了，其实 maven 是没有智力的，一切都是封装好的流程，只是 maven 将很多操作隐藏起来了。</li><li>ant 的 build.xml 文件。build 文件是 ant 的配置文件，ant 依靠它来执行操作，与 maven不同的是 ant 没有固定一条程序链。你想要执行什么操作以及操作之间的顺序和依赖关系，都需要手动添加到 build 文件中，一点一滴都要写清楚，否则 ant 就不会执行。</li><li>maven 和 ant 区别<ul><li>Maven 拥有约定，只要遵守约定，它就知道你的源代码在哪里。Maven 是声明式的。你需要做的只是创建一个 pom.xml 文件然后将源代码放到默认的目录。Maven 会帮你处理其它的事情。Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。缺点是运行许多默认目标。而 ant 没有约定，项目生命周期，它是命令式的。所有操作都要手动去创建、布置。甚至连build.xml 文件都需要手动创建。</li></ul></li></ul><h1 id="Maven-仓库是什么"><a href="#Maven-仓库是什么" class="headerlink" title="Maven 仓库是什么"></a>Maven 仓库是什么</h1><ul><li>Maven 仓库是基于简单文件系统存储的，集中化管理 Java API 资源（构件）的一个服务</li><li>仓库中的任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径</li><li>得益于 Maven 的坐标机制，任何 Maven 项目使用任何一个构件的方式都是完全相同的，Maven 可以在某个位置统一存储所有的 Maven 项目共享的构件，这个统一的位置就是仓库，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其它项目使用。</li><li>对于 Maven 来说，仓库分为两类：本地仓库和远程仓库。</li></ul><h1 id="Maven-的工程类型有哪些？"><a href="#Maven-的工程类型有哪些？" class="headerlink" title="Maven 的工程类型有哪些？"></a>Maven 的工程类型有哪些？</h1><h4 id="POM-工程"><a href="#POM-工程" class="headerlink" title="POM 工程"></a>POM 工程</h4><ul><li>POM 工程是逻辑工程。用在父级工程或聚合工程中。用来做 jar 包的版本控制。</li></ul><h4 id="JAR-工程"><a href="#JAR-工程" class="headerlink" title="JAR 工程"></a>JAR 工程</h4><ul><li>将会打包成 jar 用作 jar 包使用。即常见的本地工程 - Java Project。</li></ul><h4 id="WAR-工程"><a href="#WAR-工程" class="headerlink" title="WAR 工程"></a>WAR 工程</h4><ul><li>将会打包成 war，发布在服务器上的工程。如网站或服务。即常见的网络工程 -Dynamic Web Project。war 工程默认没有 WEB-INF 目录及 web.xml 配置文件，IDE通常会显示工程错误，提供完整工程结构可以解决。</li></ul><h1 id="Maven-常用命令有哪些？"><a href="#Maven-常用命令有哪些？" class="headerlink" title="Maven 常用命令有哪些？"></a>Maven 常用命令有哪些？</h1><ul><li>install 本地安装， 包含编译，打包，安装到本地仓库<ul><li>编译 - javac</li><li>打包 - jar， 将 java 代码打包为 jar 文件</li><li>安装到本地仓库 - 将打包的 jar 文件，保存到本地仓库目录中。</li></ul></li><li>clean<ul><li>清除已编译信息。</li><li>删除工程中的 target 目录。</li></ul></li><li>compile<ul><li>只编译。 javac 命令</li></ul></li><li>deploy<ul><li>部署。 常见于结合私服使用的命令。</li><li>相当于是 install+上传 jar 到私服。</li><li>包含编译，打包，安装到本地仓库，上传到私服仓库。</li></ul></li><li>package<ul><li>打包。 包含编译，打包两个功能。</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/b1378143ed59.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/b1378143ed59.html" class="post-title-link" itemprop="url">Hibernate</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-02 14:48:16" itemprop="dateCreated datePublished" datetime="2024-01-02T14:48:16+08:00">2024-01-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 16:00:26" itemprop="dateModified" datetime="2024-01-04T16:00:26+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="介绍一下-Hibernate-的缓存"><a href="#介绍一下-Hibernate-的缓存" class="headerlink" title="介绍一下 Hibernate 的缓存"></a>介绍一下 Hibernate 的缓存</h1><h4 id="为什么要用-Hibernate-缓存？"><a href="#为什么要用-Hibernate-缓存？" class="headerlink" title="为什么要用 Hibernate 缓存？"></a>为什么要用 Hibernate 缓存？</h4><ul><li>Hibernate 是一种持久化层框架，经常访问物理数据库。</li><li>为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。</li><li>为了提高访问速度，把磁盘或者数据库访问变成内存访问</li></ul><h4 id="Hibernate-缓存原理是怎样的？"><a href="#Hibernate-缓存原理是怎样的？" class="headerlink" title="Hibernate 缓存原理是怎样的？"></a>Hibernate 缓存原理是怎样的？</h4><ul><li>Hibernate 缓存包括两大类：Hibernate一级缓存和 Hibernate 二级缓存</li></ul><h1 id="Hibernate-一级缓存又称为”session-的缓存”。"><a href="#Hibernate-一级缓存又称为”session-的缓存”。" class="headerlink" title="Hibernate 一级缓存又称为”session 的缓存”。"></a>Hibernate 一级缓存又称为”session 的缓存”。</h1><ul><li>session 缓存内置不能被卸载，session 的缓存是事务范围的缓存(session 对象的生命周期通常对应一个数据库事务或者一个应用事务)。</li><li>一级缓存中，持久化类的每个实例都具有唯一的 OID</li></ul><h1 id="Hibernate-的二级缓存又称为”sessionFactory-的缓存”。"><a href="#Hibernate-的二级缓存又称为”sessionFactory-的缓存”。" class="headerlink" title="Hibernate 的二级缓存又称为”sessionFactory 的缓存”。"></a>Hibernate 的二级缓存又称为”sessionFactory 的缓存”。</h1><ul><li>由于 sessionFactory 对象的生命周期和应用程序的整个过程对应，因此 Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。</li><li>第二级缓存是可选的，是一个可配置的插件，默认下 sessionFactory 不会启用这个插件。</li><li>什么样的数据适合存放到二级缓存中？<ul><li>很少被修改的数据 (帖子的最后回复时间)</li><li>经常被查询的数据 (电商的地点)</li><li>不是很重要的数据，允许出现偶尔并发的数据</li><li>不会被并发访问的数据</li><li>常量数据</li></ul></li><li>Hibernate 的二级缓存默认是不支持分布式缓存的，使用 memcache，redis等中央缓存来代替二级缓存</li></ul><h1 id="Hibernate-对象的状态"><a href="#Hibernate-对象的状态" class="headerlink" title="Hibernate 对象的状态"></a>Hibernate 对象的状态</h1><ul><li>临时状态&#x2F;瞬时状态(transient)：刚刚用 new 语句创建，没有被持久化，无 id，不处于 session 中(没有使用 session 的方法去操作临时对象)，该对象成为临时对象持久化状态，</li><li>托管状态(persistent)：已经被持久化，加入 session 的缓存中，session是没有关闭该状态的对象为持久化对象。</li><li>游离状态，脱管状态(detached)：已经被持久化，但不处于 session 中，该状态的对象为游离对象。</li><li>删除状态(removed)：对象有关联的 id，并且在 session 管理下，但是已经被计划(事务提交的时候，commit)删除，如果没有事务就不能删除相互转换</li></ul><h1 id="Session-的-save-、update-、merge-、lock-、saveOrUpdate-和-persist-方法有什么区别？"><a href="#Session-的-save-、update-、merge-、lock-、saveOrUpdate-和-persist-方法有什么区别？" class="headerlink" title="Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？"></a>Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？</h1><ul><li>Hibernate 的对象有三种状态：瞬态、持久态和游离态</li><li>游离状态的实例可以通过调用 save()、persist()或者 saveOrUpdate()方法进行持久化；脱管状态的实例可以通过调用 update()、0saveOrUpdate()、lock()或者 replicate()进行持久化</li><li>save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()或 merge()会引发 UPDATE 语句</li><li>save()和 update()的区别在于一个是将瞬态对象变成持久态，一个是将游离态对象变为持久态。</li><li>merge 方法可以完成 save()和 update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象</li><li>按照官方文档的说明<ul><li>persist()方法把一个瞬态的实例持久化，但是并”不保证”标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到 flush 的时间</li><li>persist”保证”，当它在一个事务外部被调用的时候并不触发一个 Insert 语句，当需要封装一个长会话流程的时候，一个 persist 这样的函数是需要的</li><li>save”不保证”第 2 条,它要返回标识符，所以它会立即执行 Insert 语句，不管是不是在事务内部还是外部</li><li>update()方法是把一个已经更改过的脱管状态的对象变成持久状态</li><li>lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。</li></ul></li></ul><h1 id="Session-的-load-和-get-方法的区别是什么？"><a href="#Session-的-load-和-get-方法的区别是什么？" class="headerlink" title="Session 的 load 和 get 方法的区别是什么？"></a>Session 的 load 和 get 方法的区别是什么？</h1><ul><li>主要有以下三项区别：<ul><li>如果没有找到符合条件的记录, get 方法返回 null,load 方法抛出异常</li><li>get 方法直接返回实体类对象, load 方法返回实体类对象的代理</li><li>在 Hibernate 3 之前，get 方法只在一级缓存(内部缓存)中进行数据查找, 如果没有找到对应的数据则越过二级缓存, 直接发出 SQL 语句完成数据读取; load 方法则可以充分利用二级缓存中的现有数据；当然从 Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的</li></ul></li><li>简单的说，对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过 get()方法去取的数据可以不存在。</li></ul><h1 id="SessionFactory-是线程安全的吗？Session-是线程安全的吗，两个线程能够共享同一个-Session-吗？"><a href="#SessionFactory-是线程安全的吗？Session-是线程安全的吗，两个线程能够共享同一个-Session-吗？" class="headerlink" title="SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？"></a>SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？</h1><ul><li>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将 SessionFactory 通过单例的模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。</li><li>Session 是由 SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的 session，可以使用 ThreadLocal 来取得当前的 session，无论你调用多少次 getCurrentSession()方法，返回的都是同一个 session。</li></ul><h1 id="Hibernate与JDBC的区别"><a href="#Hibernate与JDBC的区别" class="headerlink" title="Hibernate与JDBC的区别"></a>Hibernate与JDBC的区别</h1><ul><li>hibernate和jdbc主要区别就是，hibernate先检索缓存中的映射对象( 即hibernate操作的是对象)，而jdbc则是直接操作数据库.</li><li>Hibernate是JDBC的轻量级的对象封装，它是一个独立的对象持久层框架。Hibernate可以用在任何JDBC可以使用的场合</li><li>Hibernate是一个和JDBC密切关联的框架，所以Hibernate的兼容性和JDBC驱动，和数据库都有一定的关系，但是和使用它的Java程序，和App Server没有任何关系，也不存在兼容性问题。</li><li>如果正确的使用JDBC技术,它的执行效率一定比hibernate要好,因为hibernate是基于jdbc的技术.</li><li>JDBC使用的是SQL语句，Hibernate使用的是HQL语句，但是HQL语句最终还会隐式转换成SQL语句执行。</li></ul><h1 id="Hibernate中的两大配置文件"><a href="#Hibernate中的两大配置文件" class="headerlink" title="Hibernate中的两大配置文件"></a>Hibernate中的两大配置文件</h1><ul><li>*.hbm.xml：主键生成策略，映射关系，一对多，一对一的关系。</li><li>Hibernate.cfg.xml：方言(用哪个数据库)，数据库连接信息，包含*.hbm.xml内容，映射文件，也可以配事务。</li></ul><h1 id="Hibernate事务处理"><a href="#Hibernate事务处理" class="headerlink" title="Hibernate事务处理"></a>Hibernate事务处理</h1><ul><li>开启事务 session.beginTransaction();</li><li>执行相关的操作，如果成功则session.getTransaction().commit();</li><li>执行操作失败则 session.getTransaction.rollback();</li></ul><h1 id="Hibernate五大核心（类-接口）简述"><a href="#Hibernate五大核心（类-接口）简述" class="headerlink" title="Hibernate五大核心（类&#x2F;接口）简述"></a>Hibernate五大核心（类&#x2F;接口）简述</h1><ul><li>Configuration接口的作用是对Hibernate进行配置，以及对它进行启动。（加载 hibernate.cfg.xml）并创建一个SessionFactory对象。</li><li>SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建 Session对象。SessionFactory是线程安全的。</li><li>Session接口<ul><li>Session（会话）接口是Hibernate应用使用的主要接口。Session接口负责执行被持久化对象的CRUD操作(增删改查)。Session对象是非线程安全的。Session 相当于jdbc的connection</li></ul></li><li>Query与Criteria接口<ul><li>总之Query和Criteria接口负责执行各种数据库查询。</li></ul></li><li>Transaction接口<ul><li>Transaction（事务）负责操作相关的事务。</li></ul></li></ul><h1 id="Hibernate的运行原理"><a href="#Hibernate的运行原理" class="headerlink" title="Hibernate的运行原理"></a>Hibernate的运行原理</h1><ul><li>首先通过configuration去加载hibernate.cfg.xml这个配置文件，根据配置文件的信息去创建sessionFactory,sessionFactory是线程安全的，是一个session工厂，用来创建session,session是线程不安全的，相当于jdbc的connection，最后通过session去进行数据库的各种操作，在进行操作的时候通过transaction进行事务的控制。</li></ul><h1 id="Hibernate、Ibatis、Jdbc三者的区别"><a href="#Hibernate、Ibatis、Jdbc三者的区别" class="headerlink" title="Hibernate、Ibatis、Jdbc三者的区别"></a>Hibernate、Ibatis、Jdbc三者的区别</h1><ul><li>Hibernate属于全自动， Ibatis属于半自动，Jdbc属于手动，从开发效率上讲hibernate较高，ibatis居中，jdbc较低，从执行效率上讲hibernate较低，ibatis居中，jdbc较高，因为jdbc是手工写sql语句，程序员对sql的控制能力更大，可以根据业务需要进行优化，而ibatis虽然也可以对sql进行优化，但是他里面将resultset封装为实体的过程中采用了反射机制所以一定程度上影响了性能，而hibernate因为高度封装所以开发效率相对较高，但正因为这个原因，所以程序员在对sql语句的控制和优化方面相对比较弱，而且在将resultset封装成实体的过程中也采用了反射机制，所以在性能方面较低</li></ul><h1 id="Hibernate-中get-和-load的区别"><a href="#Hibernate-中get-和-load的区别" class="headerlink" title="Hibernate 中get 和 load的区别"></a>Hibernate 中get 和 load的区别</h1><ul><li>加载方式：<ul><li>load为延迟加载(返回的是一个只有id属性的代理,只有使用该对象属性时,才发出sql语句)；</li><li>get为立即加载(执行时,会立即向数据库发出sql语句)</li></ul></li><li>返回结果：<ul><li>load检索不到记录时,会抛ObjectNotFoundException异常</li><li>get检索不到记录时,会返回null</li></ul></li></ul><h1 id="Hibernate-的应用（Hibernate-的结构）？"><a href="#Hibernate-的应用（Hibernate-的结构）？" class="headerlink" title="Hibernate 的应用（Hibernate 的结构）？"></a>Hibernate 的应用（Hibernate 的结构）？</h1><ul><li>首先获得 SessionFactory 的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure().buildSessionFactory();</span><br><span class="line"><span class="comment">//然后获得 session 的对象</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="comment">//其次获得 Transaction 的对象</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"><span class="comment">//执行相关的数据库操作:增,删,改,查</span></span><br><span class="line">session.save(user); <span class="comment">//增加, user 是 User 类的对象</span></span><br><span class="line">session.delete(user); <span class="comment">//删除</span></span><br><span class="line">session.update(user); <span class="comment">//更新</span></span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(“from User”); <span class="comment">//查询</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">tx.commit();</span><br><span class="line"><span class="comment">//如果有异常,我们还要作事务的回滚,恢复到操作之前</span></span><br><span class="line">tx.rollback();</span><br><span class="line"><span class="comment">//最后还要关闭 session,释放资源</span></span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h1 id="Hibernate-有哪-5-个核心接口？"><a href="#Hibernate-有哪-5-个核心接口？" class="headerlink" title="Hibernate 有哪 5 个核心接口？"></a>Hibernate 有哪 5 个核心接口？</h1><ul><li>Configuration 接口：配置 Hibernate，根据其启动 hibernate，创建 SessionFactory 对象；</li><li>SessionFactory 接口：初始化 Hibernate，充当数据存储源的代理，创建 session 对象，sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级、二级缓存；</li><li>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个线程共享同一个 session，是轻量级、一级缓存；</li><li>Transaction 接口：管理事务；</li><li>Query 和 Criteria 接口：执行数据库的查询。</li></ul><h1 id="在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h1><ul><li>getCurrentSession 会绑定当前线程，而 openSession 则不会。</li><li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</li></ul><h1 id="hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="hibernate 实体类必须要有无参构造函数吗？为什么？"></a>hibernate 实体类必须要有无参构造函数吗？为什么？</h1><ul><li>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</li></ul><h1 id="hibernate-对象有哪些状态？"><a href="#hibernate-对象有哪些状态？" class="headerlink" title="hibernate 对象有哪些状态？"></a>hibernate 对象有哪些状态？</h1><ul><li>临时&#x2F;瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</li><li>持久化状态：当调用 Session 的 save&#x2F;saveOrupdate&#x2F;get&#x2F;load&#x2F;list 等方法的时候，对象就是持久化状态。</li><li>游离状态：Session 关闭之后对象就是游离状态。</li></ul><h1 id="说一下-hibernate-的缓存机制？"><a href="#说一下-hibernate-的缓存机制？" class="headerlink" title="说一下 hibernate 的缓存机制？"></a>说一下 hibernate 的缓存机制？</h1><ul><li>hibernate 常用的缓存有一级缓存和二级缓存：<ul><li>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</li><li>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</li></ul></li></ul><h1 id="hibernate-是如何工作的？"><a href="#hibernate-是如何工作的？" class="headerlink" title="hibernate 是如何工作的？"></a>hibernate 是如何工作的？</h1><ul><li>读取并解析配置文件。</li><li>读取并解析映射文件，创建 SessionFactory。</li><li>打开 Session。</li><li>创建事务。</li><li>进行持久化操作。</li><li>提交事务。</li><li>关闭 Session。</li><li>关闭 SessionFactory。</li></ul><h1 id="hibernate-有几种查询方式？"><a href="#hibernate-有几种查询方式？" class="headerlink" title="hibernate 有几种查询方式？"></a>hibernate 有几种查询方式？</h1><ul><li>三种：hql、原生 SQL、条件查询 Criteria。</li></ul><h1 id="hibernate-实体类可以被定义为-final-吗？"><a href="#hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="hibernate 实体类可以被定义为 final 吗？"></a>hibernate 实体类可以被定义为 final 吗？</h1><ul><li>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</li></ul><h1 id="在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h1><ul><li>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</li></ul><h1 id="jpa-和-hibernate-有什么区别？"><a href="#jpa-和-hibernate-有什么区别？" class="headerlink" title="jpa 和 hibernate 有什么区别？"></a>jpa 和 hibernate 有什么区别？</h1><ul><li>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</li></ul><h1 id="如何理解-Hibernate-的延迟加载机制？在实际应用中，延迟加载与-Session关闭的矛盾是如何处理的？"><a href="#如何理解-Hibernate-的延迟加载机制？在实际应用中，延迟加载与-Session关闭的矛盾是如何处理的？" class="headerlink" title="如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session关闭的矛盾是如何处理的？"></a>如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session关闭的矛盾是如何处理的？</h1><ul><li>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。</li><li>延迟加载与 session 关闭的矛盾一般可以这样处理：<ul><li>关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session orsession was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。</li><li>在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize()方法加载对象。</li><li>使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/fec4be92fa21.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/fec4be92fa21.html" class="post-title-link" itemprop="url">架构</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-31 12:24:09" itemprop="dateCreated datePublished" datetime="2023-12-31T12:24:09+08:00">2023-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-05 17:01:46" itemprop="dateModified" datetime="2024-01-05T17:01:46+08:00">2024-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>16k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>15 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是-ELK（ElasticSearch-Logstash-Kibana）"><a href="#什么是-ELK（ElasticSearch-Logstash-Kibana）" class="headerlink" title="什么是 ELK（ElasticSearch, Logstash, Kibana）"></a>什么是 ELK（ElasticSearch, Logstash, Kibana）</h1><ul><li>ELK 是三个工具的集合，Elasticsearch + Logstash + Kibana，这三个工具组合形成了<br>一套实用、易用的监控架构，很多公司利用它来搭建可视化的海量日志分析平台。</li></ul><h4 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h4><ul><li>ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口</li><li>Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li></ul><h4 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h4><ul><li>Logstash 是一个用于管理日志和事件的工具，你可以用它去收集日志、转换日志、解析日志并将他们作为数据提供给其它模块调用，例如搜索、存储等。</li></ul><h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><ul><li>Kibana 是一个优秀的前端日志展示框架，它可以非常详细的将日志转化为各种图表，为用户提供强大的数据可视化支持。</li></ul><h1 id="什么是网关服务？"><a href="#什么是网关服务？" class="headerlink" title="什么是网关服务？"></a>什么是网关服务？</h1><ul><li>网关服务，通常是外部访问服务的唯一接口，访问内部的所有服务都必须先经过网关服务。网关服务的主要功能是消息解析过滤，路由，转发等。</li></ul><h1 id="网关服务中，路由器的-4-种路由规则方法是什么？"><a href="#网关服务中，路由器的-4-种路由规则方法是什么？" class="headerlink" title="网关服务中，路由器的 4 种路由规则方法是什么？"></a>网关服务中，路由器的 4 种路由规则方法是什么？</h1><ul><li>采用 URL 指定路由方式</li><li>采用服务名称指定路由方式</li><li>路由的排除方法</li><li>路由的添加前缀方法</li></ul><h1 id="什么是服务的灾难性的雪崩效应？"><a href="#什么是服务的灾难性的雪崩效应？" class="headerlink" title="什么是服务的灾难性的雪崩效应？"></a>什么是服务的灾难性的雪崩效应？</h1><ul><li>在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问 A 服务，而 A 服务需要调用 B 服务，B 服务需要调用 C 服务，由于网络原因或者自身的原因，如果 B 服务或者 C 服务不能及时响应，A 服务将处于阻塞状态，直到 B 服务 C 服务响应。</li><li>此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应</li></ul><h1 id="如何解决灾难性雪崩效应？"><a href="#如何解决灾难性雪崩效应？" class="headerlink" title="如何解决灾难性雪崩效应？"></a>如何解决灾难性雪崩效应？</h1><ul><li>降级：超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值.</li><li>隔离（线程池隔离和信号量隔离）：限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。</li><li>熔断：当失败率(如因网络故障&#x2F;超时造成的失败率高)达到阀值自动触发降级，熔断器触发的快速失败会进行快速恢复。</li><li>缓存：提供了请求缓存。</li><li>请求合并：提供请求合并。</li></ul><h1 id="什么是声明式，有什么作用，解决什么问题？"><a href="#什么是声明式，有什么作用，解决什么问题？" class="headerlink" title="什么是声明式，有什么作用，解决什么问题？"></a>什么是声明式，有什么作用，解决什么问题？</h1><ul><li>声明式调用就像调用本地方法一样调用远程方法;无感知远程 http 请求。</li><li>Spring Cloud 的声明式调用, 可以做到使用 HTTP 请求远程服务时能就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。</li><li>它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规的 Http Client 构造请求再解析返回数据。</li><li>它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</li></ul><h1 id="什么是-AKF-拆分原则？"><a href="#什么是-AKF-拆分原则？" class="headerlink" title="什么是 AKF 拆分原则？"></a>什么是 AKF 拆分原则？</h1><ul><li>业界对于可扩展的系统架构设计有一个朴素的理念,就是：通过加机器就可以解决容量和可用性问题。(如果一台不行那就两台)。</li></ul><h1 id="简单讲一下-webservice-使用的场景"><a href="#简单讲一下-webservice-使用的场景" class="headerlink" title="简单讲一下 webservice 使用的场景"></a>简单讲一下 webservice 使用的场景</h1><ul><li>webservice 是一个 SOA(面向服务的编程)的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过 Internet 进行基于 http 协议的网络应用间的交互。</li><li>异构系统(不同的开发语言)的整合</li><li>不同客户端的整合 (浏览器、手机端(android\ios)、微信)</li><li>实实在在的例子：天气预报：可以通过实现 webservice 客户端调用远程天气服务实现的</li><li>单点登录：一个服务实现所有系统的登录</li></ul><h1 id="什么是-VSFTPD？"><a href="#什么是-VSFTPD？" class="headerlink" title="什么是 VSFTPD？"></a>什么是 VSFTPD？</h1><ul><li>vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。</li><li>vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX 等系统上面，是一个完全免费的、开放源代码的 ftp 服务器软件，支持很多其他的 FTP 服务器所不支持的特征。</li></ul><h1 id="项目的生命周期"><a href="#项目的生命周期" class="headerlink" title="项目的生命周期"></a>项目的生命周期</h1><ul><li>需求分析</li><li>概要设计</li><li>详细设计(用例图，流程图，类图)</li><li>数据库设计(powerdesigner)</li><li>代码开发（编写）</li><li>单元测试（junit 白盒测试）(开发人员) svn版本管理工具(提交，更新代码，文档)</li><li>集成测试 （黑盒测试，loadrunner（编写测试脚本）(高级测试)）</li><li>上线试运行 （用户自己体验）</li><li>压力测试（loadrunner）</li><li>正式上线</li><li>维护</li></ul><h1 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h1><ul><li>CND 一般包含分发服务系统、负载均衡系统和管理系统</li></ul><h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><ul><li>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。</li><li>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。</li><li>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。</li></ul><h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><ul><li>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</li><li>使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。</li><li>GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。</li><li>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个 Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。</li></ul><h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><ul><li>分为运营管理和网络管理子系统。</li><li>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。</li><li>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。包括用户管理、产品管理、计费管理、统计分析等。</li></ul><h1 id="RMI-实现方式"><a href="#RMI-实现方式" class="headerlink" title="RMI 实现方式"></a>RMI 实现方式</h1><ul><li>Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用</li><li>实现步骤<ul><li>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</li><li>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</li><li>运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类;</li><li>启动一个 RMI 注册表，以便驻留这些服务;</li><li>在 RMI 注册表中注册服务；</li><li>客户端查找远程对象，并调用远程方法；<ul><li>创建远程接口，继承 java.rmi.Remote 接口</li><li>实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类</li><li>生成 Stub 和 Skeleton;</li><li>执行 rmiregistry 命令注册服务</li><li>启动服务</li><li>客户端调用</li></ul></li></ul></li></ul><h1 id="什么是微服务中的反应性扩展？"><a href="#什么是微服务中的反应性扩展？" class="headerlink" title="什么是微服务中的反应性扩展？"></a>什么是微服务中的反应性扩展？</h1><ul><li>Reactive Extensions 也称为 Rx</li><li>这是一种设计方法，我们通过调用多个服务来收集结果，然后编译组合响应</li><li>这些调用可以是同步或异步，阻塞或非阻塞。Rx是分布式系统中非常流行的工具，与传统流程相反。</li></ul><h1 id="我们可以用微服务创建状态机吗？"><a href="#我们可以用微服务创建状态机吗？" class="headerlink" title="我们可以用微服务创建状态机吗？"></a>我们可以用微服务创建状态机吗？</h1><ul><li>我们知道拥有自己的数据库的每个微服务都是一个可独立部署的程序单元，这反过来又让我们可以创建一个状态机。因此，我们可以为特定的微服务指定不同的状态和事件。</li><li>例如，我们可以定义 Order 微服务。订单可以具有不同的状态。Order 状态的转换可以是 Order 微服务中的独立事件。</li></ul><h1 id="架构师在微服务架构中的角色是什么？"><a href="#架构师在微服务架构中的角色是什么？" class="headerlink" title="架构师在微服务架构中的角色是什么？"></a>架构师在微服务架构中的角色是什么？</h1><ul><li>微服务架构中的架构师扮演以下角色：<ul><li>决定整个软件系统的布局。</li><li>帮助确定组件的分区。因此，他们确保组件相互粘合，但不紧密耦合。</li><li>与开发人员共同编写代码，了解日常生活中面临的挑战。</li><li>为开发微服务的团队提供某些工具和技术的建议。</li><li>提供技术治理，以便技术开发团队遵循微服务原则。</li></ul></li></ul><h1 id="什么是持续监测？"><a href="#什么是持续监测？" class="headerlink" title="什么是持续监测？"></a>什么是持续监测？</h1><ul><li>持续监控深入监控覆盖范围，从浏览器内前端性能指标，到应用程序性能，再到主机虚拟化基础架构指标。</li></ul><h1 id="什么是金丝雀释放？"><a href="#什么是金丝雀释放？" class="headerlink" title="什么是金丝雀释放？"></a>什么是金丝雀释放？</h1><ul><li>Canary Releasing 是一种降低在生产中引入新软件版本的风险的技术。这是通过将变更缓慢地推广到一小部分用户，然后将其发布到整个基础架构，即将其提供给每个人来完成的。</li></ul><h1 id="什么是持续集成（CI）？"><a href="#什么是持续集成（CI）？" class="headerlink" title="什么是持续集成（CI）？"></a>什么是持续集成（CI）？</h1><ul><li>持续集成（CI）是每次团队成员提交版本控制更改时自动构建和测试代码的过程。</li><li>这鼓励开发人员通过在每个小任务完成后将更改合并到共享版本控制存储库来共享代码和单元测试。</li></ul><h1 id="您对-Mike-Cohn-的测试金字塔了解多少？"><a href="#您对-Mike-Cohn-的测试金字塔了解多少？" class="headerlink" title="您对 Mike Cohn 的测试金字塔了解多少？"></a>您对 Mike Cohn 的测试金字塔了解多少？</h1><ul><li>Mike Cohn 提供了一个名为 Test Pyramid 的模型。这描述了软件开发所需的自动化测试类型。</li><li>根据金字塔，第一层的测试数量应该最高。在服务层，测试次数应小于单元测试级别，但应大于端到端级别。</li></ul><h1 id="Mock-或-Stub-有什么区别？"><a href="#Mock-或-Stub-有什么区别？" class="headerlink" title="Mock 或 Stub 有什么区别？"></a>Mock 或 Stub 有什么区别？</h1><ul><li>存根<ul><li>一个有助于运行测试的虚拟对象。</li><li>在某些可以硬编码的条件下提供固定行为。</li><li>永远不会测试存根的任何其他行为。</li></ul></li><li>例如，对于空堆栈，您可以创建一个只为 empty（）方法返回 true 的存根。因此，这并不关心堆栈中是否存在元素。</li><li>嘲笑<ul><li>一个虚拟对象，其中最初设置了某些属性。</li><li>此对象的行为取决于 set 属性。</li><li>也可以测试对象的行为。</li></ul></li><li>例如，对于 Customer 对象，您可以通过设置名称和年龄来模拟它。您可以将 age设置为 12，然后测试 isAdult（）方法，该方法将在年龄大于 18 时返回 true。因此，您的 Mock Customer 对象适用于指定的条件。</li></ul><h1 id="我们如何在测试中消除非决定论？"><a href="#我们如何在测试中消除非决定论？" class="headerlink" title="我们如何在测试中消除非决定论？"></a>我们如何在测试中消除非决定论？</h1><ul><li>非确定性测试（NDT）基本上是不可靠的测试。所以，有时可能会发生它们通过，显然有时它们也可能会失败。当它们失败时，它们会重新运行通过。</li><li>从测试中删除非确定性的一些方法如下：<ul><li>隔离</li><li>异步</li><li>远程服务</li><li>隔离</li><li>时间</li><li>资源泄漏</li></ul></li></ul><h1 id="负载均衡反向代理模式优点及缺点"><a href="#负载均衡反向代理模式优点及缺点" class="headerlink" title="负载均衡反向代理模式优点及缺点"></a>负载均衡反向代理模式优点及缺点</h1><ul><li>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</li><li>反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。</li><li>反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有此优点）。</li><li>其缺点主要表现在以下两个方面<ul><li>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器的负载均衡。</li><li>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。</li></ul></li><li>般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点进行负载均衡，如 search 等。</li></ul><h1 id="大型网站在架构上应当考虑哪些问题？"><a href="#大型网站在架构上应当考虑哪些问题？" class="headerlink" title="大型网站在架构上应当考虑哪些问题？"></a>大型网站在架构上应当考虑哪些问题？</h1><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><ul><li>分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI&#x2F;RM）和 Internet 的 TCP&#x2F;IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</li></ul><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><ul><li>分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</li></ul><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><ul><li>除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce分布式计算框架来处理。</li></ul><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><ul><li>集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。</li></ul><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</li></ul><h4 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h4><ul><li>各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</li></ul><h1 id="正向代理（客户端代理）和反向代理（服务器端代理）"><a href="#正向代理（客户端代理）和反向代理（服务器端代理）" class="headerlink" title="正向代理（客户端代理）和反向代理（服务器端代理）*"></a>正向代理（客户端代理）和反向代理（服务器端代理）*</h1><ul><li>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<ul><li>访问原来无法访问的资源，如google</li><li>可以做缓存，加速访问资源</li><li>对客户端访问授权，上网进行认证</li><li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li></ul></li><li>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<ul><li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li><li>负载均衡，通过反向代理服务器来优化网站的负载</li></ul></li><li>nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。</li></ul><h1 id="如何实现分布式Session"><a href="#如何实现分布式Session" class="headerlink" title="如何实现分布式Session"></a>如何实现分布式Session</h1><ul><li>基于数据库的Session共享</li><li>基于NFS共享文件系统</li><li>基于memcached 的session，如何保证 memcached 本身的高可用性？</li><li>基于resin&#x2F;tomcat web容器本身的session复制机制</li><li>基于TT&#x2F;Redis 或 jbosscache 进行 session 共享。</li><li>基于cookie 进行session共享</li></ul><h1 id="CAP-理论和-BASE-理论"><a href="#CAP-理论和-BASE-理论" class="headerlink" title="CAP 理论和 BASE 理论"></a>CAP 理论和 BASE 理论</h1><ul><li>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</li><li>基本可用（Basically Available）</li><li>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</li><li>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</li><li>软状态（ Soft State）</li><li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</li><li>最终一致性（ Eventual Consistency）</li><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul><h1 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h1><ul><li>c是指client，而10k则是一万的意思。c10k就是单机同时并发一万个请求。同理c100k则是同时并发十万个请求，如今百万请求也十分常见了。</li></ul><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><ul><li>一致性哈希算法在1997年由麻省理工学院提出,是一种特殊的哈希算法,目的是解决分布式缓存的问题。 [1] 在移除或者添加一个服务器时,能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table,DHT) 中存在的动态伸缩等问题</li></ul><h1 id="DDD设计模式"><a href="#DDD设计模式" class="headerlink" title="DDD设计模式"></a>DDD设计模式</h1><ul><li>领域驱动设计原则:DDD倡导将领域模型作为核心设计元素,通过使用领域模型中的领域对象、值对象和领域服务来解决问题</li></ul><h1 id="消息中间件选型要点"><a href="#消息中间件选型要点" class="headerlink" title="消息中间件选型要点"></a>消息中间件选型要点</h1><h2 id="功能维度"><a href="#功能维度" class="headerlink" title="功能维度"></a>功能维度</h2><ul><li>优先级队列<ul><li>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证</li><li>优先级也是需要有一个前提的，生产者的速度大于消费者的速度，否则，生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的</li></ul></li><li>延迟队列<ul><li>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”，这个是延迟队列的一种典型应用场景。</li><li>延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</li><li>延迟队列一般分为两种：<ul><li>基于消息的延迟，是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。</li><li>基于队列的延迟，实际应用中大多采用这种，设置不同延迟级别的队列，比如5s、10s、30s、1min、5mins、10mins等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略(比如定时)即可投递超时的消息。</li></ul></li></ul></li><li>死信队列<ul><li>由于某些原因消息无法被正确投递，为了确保消息不会被无故丢弃，一般将其置于一个特殊角色的队列，这个队列称为死信队列。</li><li>与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认(Ack), 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。</li><li>为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</li></ul></li><li>重试队列<ul><li>其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。</li><li>与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。</li><li>举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息。</li><li>如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。</li><li>以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。</li><li>重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发;延迟队列作用一次，而重试队列的作用范围会向后传递。</li></ul></li><li>消费模式<ul><li>消费模式分为推(push)模式和拉(pull)模式：<ul><li>推模式，是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。</li><li>拉模式，是指消费端主动向 Broker 端请求拉取(一般是定时或者定量)消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。</li></ul></li></ul></li><li>广播消费<ul><li>消息一般有两种传递模式——点对点(P2P，Point-to-Point)模式和发布&#x2F;订阅(Pub&#x2F;Sub)模式：</li><li>对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。</li><li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题(Topic)，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。</li><li>主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布&#x2F;订阅模式在消息的一对多广播时采用。</li><li>RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。</li><li>但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组(Consumer Group)的概念看成是队列的概念。</li><li>不过对比来说，Kafka 中因为有了消息回溯功能的存在，对于广播消费的力度支持比 RabbitMQ 的要强。</li></ul></li><li>消息回溯<ul><li>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息</li><li>消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。</li><li>对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失，一般很难追查。</li><li>如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头所在。</li><li>消息回溯的作用远不止于此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。</li></ul></li><li>消息堆积+持久化<ul><li>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。</li><li>从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。</li><li>消息堆积分内存式堆积和磁盘式堆积：</li><li>RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘(换页动作会影响吞吐)，或者直接使用惰性队列来将消息直接持久化至磁盘中。</li><li>Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。</li><li>一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。</li><li>从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引《纽约时报》的案例，其直接将 Kafka 用作存储系统。</li></ul></li><li>消息追踪<ul><li>对于分布式架构系统中的链路追踪(Trace)，大家一定不陌生</li><li>对于消息中间件，消息的链路追踪(以下简称消息追踪)同样重要，最通俗来理解，就是要知道消息从哪来，存在哪里以及发往哪里去。</li><li>基于此功能，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。</li></ul></li><li>消息过滤<ul><li>消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。</li><li>就以 Kafka 而言，完全可以将不同类别的消息发送至不同的 Topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 Topic 中的消息进行分类。</li><li>不过，更加严格意义上的消息过滤，应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。</li><li>同样以 Kafka 为例，可以通过客户端提供的 Consumer Interceptor 接口或者 Kafka Stream 的 Filter 功能进行消息过滤。</li></ul></li><li>多租户<ul><li>也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。</li><li>RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 VHost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。</li><li>VHost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。</li></ul></li><li>多协议支持<ul><li>消息是信息的载体，为了让生产者和消费者都能理解所承载的信息(生产者需要知道如何构造消息，消费者需要知道如何解析消息)，它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。</li><li>有效的消息一定具有某种格式，而没有格式的消息是没有意义的。</li><li>一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等(消息领域中的 JMS 更多的是一个规范而不是一个协议)，支持的协议越多其应用范围就会越广，通用性越强。</li><li>比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。</li></ul></li><li>跨语言支持<ul><li>对很多公司而言，其技术栈体系中会有多种编程语言，如 C&#x2F;C++、Java、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。</li><li>跨语言的支持力度也从侧面反映出一个消息中间件的流行程度。</li></ul></li><li>流量控制<ul><li>针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应</li><li>通常的流控方法有 Stop-and-Wait、滑动窗口以及令牌桶等。</li></ul></li><li>消息顺序性<ul><li>顾名思义，是指保证消息有序</li><li>这个功能有个很常见的应用场景就是 CDC(Change Data Chapture)。</li><li>以 MySQL 为例，如果其传输的 Binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1，造成数据不一致。</li></ul></li><li>安全机制<ul><li>在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制：<ul><li>身份认证，是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制。</li><li>权限控制，是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。</li></ul></li><li>对于 RabbitMQ 而言，其同样提供身份认证(TLS&#x2F;SSL、SASL)和权限控制(读写操作)的安全机制。</li></ul></li><li>消息幂等性<ul><li>确保消息在生产者和消费者之间进行传输，一般有三种传输保障(Delivery Guarantee)：<ul><li>At most once，至多一次，消息可能丢失，但绝不会重复传输。</li><li>At least once，至少一次，消息绝不会丢，但是可能会重复。</li><li>Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。</li></ul></li><li>对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</li><li>Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等。</li><li>而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS(Exactly Once Semantic)的能力。</li><li>不过如果要考虑全局的幂等，还需要从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。</li><li>以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法由消息中间件层面来保证的。</li><li>如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。</li></ul></li><li>事务性消息<ul><li>事务本身是一个并不陌生的词汇，事务是由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。</li><li>支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。</li><li>消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。</li></ul></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li>功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度，有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得。<br>K- afka 在开启幂等、事务功能的时候会使其性能降低;RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大影响其性能。</li><li>性能指什么?<ul><li>消息中间件的性能一般是指其吞吐量</li><li>虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级。</li><li>一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。</li><li>注明：消息中间件的吞吐量始终会受到硬件层面的限制。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过(1Gb&#x2F;8)&#x2F;100W，即约等于 134B。</li><li>换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。</li></ul></li><li>性能的指标是什么?<ul><li>时延作为性能维度的一个重要指标，却往往在消息中间件领域被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。</li><li>消息中间件具备消息堆积的能力，消息堆积越大也就意味着端到端的时延也就越长，与此同时延时队列也是某些消息中间件的一大特色。那么为什么还要关注消息中间件的时延问题呢?</li><li>消息中间件能够解耦系统，对于一个时延较低的消息中间件而言，它可以让上游生产者发送消息之后可以迅速的返回，也可以让消费者更加快速的获取到消息，在没有堆积的情况下，可以让整体上下游的应用之间的级联动作更加高效。</li><li>虽然不建议在时效性很高的场景下使用消息中间件，但是如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。</li></ul></li></ul><h2 id="可靠性-可用性"><a href="#可靠性-可用性" class="headerlink" title="可靠性+可用性"></a>可靠性+可用性</h2><ul><li>消息丢失是使用消息中间件时所不得不面对的一个痛点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素</li><li>尤其是在金融支付领域，消息可靠性尤为重要。</li><li>然而说到可靠性必然要说到可用性，注意这两者之间的区别：<ul><li>可靠性是指对消息不丢失的保障程度。</li><li>可用性是指无故障运行的时间百分比，通常用几个 9 来衡量。</li></ul></li><li>从狭义的角度来说，分布式系统架构是一致性协议理论的应用实现，对于消息可靠性和可用性而言也可以追溯到消息中间件背后的一致性协议：<ul><li>对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，通过 ISR(In-Sync-Replica)来保证多副本之间的同步，并且支持强一致性语义(通过 Acks 实现)。</li><li>对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。</li></ul></li><li>多副本可以保证在 Master 节点宕机异常之后可以提升 Slave 作为新的 Master 而继续提供服务来保障可用性。</li><li>Kafka 设计之初是为日志处理而生，给人们留下了数据可靠性要求不高的不良印象，但是随着版本的升级优化，其可靠性得到极大的增强，详细可以参考 KIP101。</li><li>就目前而言，在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多，随着 RabbitMQ 性能的不断提升和 Kafka 可靠性的进一步增强，相信彼此都能在以前不擅长的领域分得一杯羹。</li><li>同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘。</li><li>但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。</li><li>这里还要提及的一个方面是扩展能力，这里我狭隘地将此归纳到可用性这一维度，消息中间件的扩展能力能够增强其可用能力及范围，比如前面提到的 RabbitMQ 支持多种消息协议，这个就是基于其插件化的扩展实现。</li><li>还有从集群部署上来讲，归功于 Kafka 的水平扩展能力，其基本上可以达到线性容量提升的水平，在 LinkedIn 实践介绍中就提及了有部署超过千台设备的 Kafka 集群。</li></ul><h2 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h2><ul><li>在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复?</li><li>业务线流量有峰值有低谷，尤其是电商领域，那么怎样进行有效的容量评估，尤其是大促期间?脚踢电源、网线被挖等事件层出不穷，如何有效的做好异地多活?</li><li>这些都离不开消息中间件的衍生产品——运维管理。运维管理也可以进行进一步的细分，比如申请、审核、监控、告警、管理、容灾、部署等。</li><li>申请、审核很好理解，在源头对资源进行管控，既可以有效校正应用方的使用规范，配合监控也可以做好流量统计与流量评估工作。</li><li>一般申请、审核与公司内部系统交融性较大，不适合使用开源类的产品。</li><li>监控、告警也比较好理解，对消息中间件的使用进行全方位的监控，既可以为系统提供基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。</li><li>除了一般的监控项(比如硬件、GC 等)之外，消息中间件还需要关注端到端时延、消息审计、消息堆积等方面：</li><li>对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，但是社区内还有 AppDynamics、Collectd、DataDog、Ganglia、Munin、Nagios、New Relic、Prometheus、Zenoss 等多种优秀的产品。</li><li>Kafka 在此方面也毫不逊色，比如：Kafka Manager、Kafka Monitor、Kafka Offset Monitor、Burrow、Chaperone、Confluent Control Center 等产品，尤其是 Cruise 还可以提供自动化运维的功能。</li><li>不管是扩容、降级、版本升级、集群节点部署、还是故障处理都离不开管理工具的应用，一个配套完备的管理工具集可以在遇到变更时做到事半功倍。</li><li>故障可大可小，一般是一些应用异常，也可以是机器掉电、网络异常、磁盘损坏等单机故障，这些故障单机房内的多副本足以应付。</li><li>如果是机房故障就要涉及异地容灾了，关键点在于如何有效的进行数据复制，Kafka 可以参考 MirrorMarker、uReplicator 等产品，而 RabbitMQ 可以参考 Federation 和 Shovel。</li></ul><h2 id="社区力度及生态发展"><a href="#社区力度及生态发展" class="headerlink" title="社区力度及生态发展"></a>社区力度及生态发展</h2><ul><li>对于目前流行的编程语言而言，如 Java、Python，如果你在使用过程中遇到了一些异常，基本上可以通过搜索引擎的帮助来得到解决，因为一个产品用的人越多，踩过的坑也就越多，对应的解决方案也就越多。</li><li>消息中间件也同样适用，如果你选择了一种“生僻”的消息中间件，可能在某些方面运用的得心应手，但是版本更新缓慢、遇到棘手问题也难以得到社区的支持而越陷越深。</li><li>相反如果你选择了一种“流行”的消息中间件，其更新力度大，不仅可以迅速的弥补之前的不足，而且也能顺应技术的快速发展来变更一些新的功能，这样可以让你也“站在巨人的肩膀上”。</li><li>在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。</li></ul><h2 id="消息中间件选型误区总结"><a href="#消息中间件选型误区总结" class="headerlink" title="消息中间件选型误区总结"></a>消息中间件选型误区总结</h2><ul><li>选型误区<ul><li>选型之前可以先问自己一个问题：是否真的需要一个消息中间件?</li><li>在搞清楚这个问题之后，还可以继续问自己一个问题：是否需要自己维护一套消息中间件?</li><li>很多初创型公司为了节省成本会选择直接购买消息中间件有关的云服务，自己只需要关注收发消息即可，其余的都可以外包出去。</li><li>很多人面对消息中间件有一种自研的冲动，你完全可以对 Java 中的 ArrayBlockingQueue 做一个简单的封装，你也可以基于文件、数据库、Redis 等底层存储封装而形成一个消息中间件。</li><li>消息中间件做为一个基础组件并没有想象中的那么简单，其背后还需要配套的管理运维整个生态的产品集。</li><li>自研还会有交接问题，如果文档不齐全、运作不规范将会带给新人噩梦般的体验。</li><li>是否真的有自研的必要?如果不是 KPI 的压迫可以先考虑下面这两个问题：<ul><li>目前市面上的消息中间件是否都真的无法满足目前的业务需求?</li><li>团队是否有足够的能力、人力、财力、精力来支持自研?</li></ul></li><li>很多人在做消息中间件选型时会参考网络上的很多对比类的文章，但是其专业性、严谨性、以及其政治立场问题都有待考证，需要带着怀疑的态度去审视这些文章。</li><li>比如有些文章会在没有任何限定条件及场景的情况下直接定义某款消息中间件最好。</li><li>还有些文章没有指明消息中间件版本及测试环境就来做功能和性能对比分析，诸如此类的文章都可以唾弃之。</li><li>消息中间件犹如小马过河，选择合适的才最重要。这需要贴合自身的业务需求，技术服务于业务，大体上可以根据上一节所提及的功能、性能等 6 个维度来一一进行筛选。更深层次的抉择在于你能否掌握其魂。</li><li>笔者鄙见：RabbitMQ 在于 Routing，而 Kafka 在于 Streaming，了解其根本对于自己能够对症下药选择到合适的消息中间件尤为重要。</li><li>消息中间件选型切忌一味的追求性能或者功能，性能可以优化，功能可以二次开发。</li><li>如果要在功能和性能方面做一个抉择的话，那么首选性能，因为总体上来说性能优化的空间没有功能扩展的空间大。然而看长期发展，生态又比性能以及功能都要重要。</li></ul></li><li>可靠性误区<ul><li>很多时候，可靠性方面也容易存在一个误区：想要找到一个产品来保证消息的绝对可靠，很不幸的是这世界上没有绝对的东西，只能说尽量趋于完美。</li><li>想要尽可能的保障消息的可靠性也并非单单只靠消息中间件本身，还要依赖于上下游，需要从生产端、服务端和消费端这 3 个维度去努力保证。</li><li>消息中间件选型还有一个考量标准就是尽量贴合团队自身的技术栈体系，虽然说没有蹩脚的消息中间件，只有蹩脚的程序员，但是让一个 C 栈的团队去深挖 PhxQueue 总比去深挖 Scala 编写的 Kafka 要容易的多。</li><li>消息中间件大道至简：一发一存一消费，没有最好的消息中间件，只有最合适的消息中间件</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/73098ee3eeb0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/73098ee3eeb0.html" class="post-title-link" itemprop="url">集合</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:39:17" itemprop="dateCreated datePublished" datetime="2023-12-30T14:39:17+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 17:09:38" itemprop="dateModified" datetime="2024-01-04T17:09:38+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h1><ul><li>Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。</li><li>Java中还有一个Collections类，专门用来操作集合类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li></ul><h1 id="集合和数组的比较（为什么引入集合）"><a href="#集合和数组的比较（为什么引入集合）" class="headerlink" title="集合和数组的比较（为什么引入集合）"></a>集合和数组的比较（为什么引入集合）</h1><ul><li>数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框架类可适用于不同场合</li><li>具体如下：<ul><li>数组的效率高于集合类.</li><li>数组能存放基本数据类型和对象，而集合类中只能放对象。</li><li>数组容量固定且无法动态改变，集合类容量动态改变。</li><li>数组无法判断其中实际存有多少元素，length只告诉了array的容量。</li><li>集合有多种实现方式和不同的适用场合，而不像数组仅采用顺序表方式。</li><li>集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。</li></ul></li></ul><h1 id="TreeSet的原理和使用"><a href="#TreeSet的原理和使用" class="headerlink" title="TreeSet的原理和使用"></a>TreeSet的原理和使用</h1><ul><li>TreeSet集合，元素不允许重复且有序(自然顺序)</li><li>TreeSet采用树结构存储数据，存入元素时需要和树中元素进行对比，需要指定比较策略。</li><li>可以通过Comparable(外部比较器)和Comparator(内部比较器)来指定比较策略，实现了Comparable的系统类可以顺利存入TreeSet。自定义类可以实现Comparable接口来指定比较策略。</li><li>可创建Comparator接口实现类来指定比较策略，并通过TreeSet构造方法参数传入。这种方式尤其对系统类非常适用。</li></ul><h1 id="HashSet的使用和原理"><a href="#HashSet的使用和原理" class="headerlink" title="HashSet的使用和原理"></a>HashSet的使用和原理</h1><ul><li>哈希表的查询速度特别快，时间复杂度为O（1）。</li><li>HashMap、Hashtable、HashSet这些集合采用的是哈希表结构，需要用到hashCode哈希码，hashCode是一个整数值。</li><li>系统类已经覆盖了hashCode方法 自定义类如果要放入hash类集合，必须重写hashcode。如果不重写，调用的是Object的hashcode，而Object的hashCode实际上是地址。</li><li>向哈希表中添加数据的原理：当向集合Set中增加对象时，首先集合计算要增加对象的hashCode码，根据该值来得到一个位置用来存放当前对象，如在该位置没有一个对象存在的话，那么集合Set认为该对象在集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接着将准备增加到集合中的对象与该位置上的对象进行equals方法比较，如果该equals方法返回false,那么集合认为集合中不存在该对象，在进行一次散列，将该对象放到散列后计算出的新地址里。如果equals方法返回true，那么集合认为集合中已经存在该对象了，不会再将该对象增加到集合中了。</li><li>在哈希表中判断两个元素是否重复要使用到hashCode()和equals()。hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。</li><li>Y&#x3D;K(X) ：K是函数，X是哈希码，Y是地址</li></ul><h1 id="ArrayList和LinkedList的区别和联系"><a href="#ArrayList和LinkedList的区别和联系" class="headerlink" title="ArrayList和LinkedList的区别和联系"></a>ArrayList和LinkedList的区别和联系</h1><ul><li>相同点：两者都实现了List接口，都具有List中元素有序、不唯一的特点。</li><li>不同点：ArrayList实现了长度可变的数组，在内存中分配连续空间。遍历元素和随机访问元素的效率比较高；LinkedList采用链表存储方式。插入、删除元素时效率比较高</li></ul><h1 id="HashMap和Hashtable的区别和联系"><a href="#HashMap和Hashtable的区别和联系" class="headerlink" title="HashMap和Hashtable的区别和联系"></a>HashMap和Hashtable的区别和联系</h1><ul><li>相同点：实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</li><li>不同点：<ul><li>Hashtable是早期提供的接口，HashMap是新版JDK提供的接口</li><li>Hashtable继承Dictionary类，HashMap实现Map接口</li><li>Hashtable线程安全，HashMap线程非安全</li><li>Hashtable不允许null值，HashMap允许null值</li></ul></li></ul><h1 id="Vector和ArrayList的区别和联系"><a href="#Vector和ArrayList的区别和联系" class="headerlink" title="Vector和ArrayList的区别和联系"></a>Vector和ArrayList的区别和联系</h1><ul><li>相同点：<ul><li>实现原理相同—底层都使用数组</li><li>功能相同—实现增删改查等操作的方法相似</li><li>都是长度可变的数组结构，很多情况下可以互用</li></ul></li><li>不同点：<ul><li>Vector是早期JDK接口，ArrayList是替代Vector的新接口</li><li>Vector线程安全，ArrayList重速度轻安全，线程非安全</li><li>长度需增长时，Vector默认增长一倍，ArrayList增长50%</li></ul></li></ul><h1 id="Java集合体系结构"><a href="#Java集合体系结构" class="headerlink" title="Java集合体系结构"></a>Java集合体系结构</h1><ul><li>Collection 接口存储一组不唯一，无序的对象</li><li>List 接口存储一组不唯一，有序（插入顺序）的对象</li><li>Set 接口存储一组唯一，无序的对象</li><li>Map接口存储一组键值对象，提供key到value的映射。Key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</li></ul><h1 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h1><ul><li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li><li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</li><li>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul><h1 id="List、Map、Set-三个接口，存取元素时，各有什么特点？"><a href="#List、Map、Set-三个接口，存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set 三个接口，存取元素时，各有什么特点？"></a>List、Map、Set 三个接口，存取元素时，各有什么特点？</h1><ul><li>List以特定索引来存取元素，可有重复元素。</li><li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）</li><li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一</li><li>Set和Map容器都有基于哈希存储和排序树（红黑树）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</li></ul><p> </p><h1 id="说出ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#说出ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="说出ArrayList、Vector、LinkedList 的存储性能和特性？"></a>说出ArrayList、Vector、LinkedList 的存储性能和特性？</h1><ul><li>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。</li><li>遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖）。同理，Stack类继承Vector也是不正确的。</li></ul><p> </p><h1 id="List、Set、Map-是否继承自-Collection-接口？"><a href="#List、Set、Map-是否继承自-Collection-接口？" class="headerlink" title="List、Set、Map 是否继承自 Collection 接口？"></a>List、Set、Map 是否继承自 Collection 接口？</h1><ul><li>List、Set 的父接口是 Collection，Map 不是其子接口，而是与Collection 接口是平行关系，互不包含。</li><li>Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</li></ul><h1 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的-sort（）方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的-sort（）方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？</h1><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li><li>TreeMap 要求存放的键值对映射的键必须实现 Comparable接口从而根据键对元素进行排序</li><li>Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul><h1 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?</h1><ul><li>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。</li><li>equals()和&#x3D;&#x3D;方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值</li></ul><h1 id="List-和-Map-区别"><a href="#List-和-Map-区别" class="headerlink" title="List 和 Map 区别?"></a>List 和 Map 区别?</h1><ul><li>一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复</li><li>Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</li></ul><h1 id="你是怎么理解-java-的泛型的？"><a href="#你是怎么理解-java-的泛型的？" class="headerlink" title="你是怎么理解 java 的泛型的？"></a>你是怎么理解 java 的泛型的？</h1><ul><li>在 Java SE 1.5 之前，没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</li><li>泛型是 Java SE 1.5 的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</li></ul><h1 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h1><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h1 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h1><ul><li>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接口,每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合的元素进行迭代操作. 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除.</li></ul><h1 id="为什么集合类没有实现-Cloneable-和-Serializable-接口？"><a href="#为什么集合类没有实现-Cloneable-和-Serializable-接口？" class="headerlink" title="为什么集合类没有实现 Cloneable 和 Serializable 接口？"></a>为什么集合类没有实现 Cloneable 和 Serializable 接口？</h1><ul><li>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</li><li>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。</li><li>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化</li></ul><h1 id="Java-集合类框架的基本接口有哪些？"><a href="#Java-集合类框架的基本接口有哪些？" class="headerlink" title="Java 集合类框架的基本接口有哪些？"></a>Java 集合类框架的基本接口有哪些？</h1><ul><li>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</li><li>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基本的接口有：<ul><li>Collection：代表一组对象，每一个对象都是它的子元素。</li><li>Set：不包含重复元素的 Collection。</li><li>List：有顺序的 collection，并且可以包含重复元素。</li><li>Map：可以把键(key)映射到值(value)的对象，键不能重复。</li></ul></li></ul><h1 id="ArrayList-是否会越界？"><a href="#ArrayList-是否会越界？" class="headerlink" title="ArrayList 是否会越界？"></a>ArrayList 是否会越界？</h1><ul><li>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构</li><li>对于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList并发 add()可能出现数组下标越界异常</li></ul><h1 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？"><a href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？"></a>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</h1><ul><li>Array 和 ArrayList 的不同点：<ul><li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li><li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li><li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li><li>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li></ul></li></ul><h1 id="Map、Set、List、Queue、Stack的特点与用法。"><a href="#Map、Set、List、Queue、Stack的特点与用法。" class="headerlink" title="Map、Set、List、Queue、Stack的特点与用法。"></a>Map、Set、List、Queue、Stack的特点与用法。</h1><ul><li>Map map集合，k-v键值对存储</li><li>HashTable 和 HashMap 是 Map 的实现类   </li><li>HashTable 是线程安全的，不能存储 null 值   </li><li>HashMap 不是线程安全的，可以存储 null 值  </li><li>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。</li><li>Set 集合，无序，不重复</li><li>List 数组集合，ArrayList ， Vector ， LinkedList 是 List 的实现类</li><li>ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的</li><li>LinkedList 是线程不安全的，底层是由链表实现的   </li><li>Queue 队列，提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。</li><li>Stack 栈，继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/3aaab7406978.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/3aaab7406978.html" class="post-title-link" itemprop="url">IO</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:28:05" itemprop="dateCreated datePublished" datetime="2023-12-30T14:28:05+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-03 20:39:24" itemprop="dateModified" datetime="2024-01-03T20:39:24+08:00">2024-01-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说明缓冲流的优点和原理"><a href="#说明缓冲流的优点和原理" class="headerlink" title="说明缓冲流的优点和原理"></a>说明缓冲流的优点和原理</h1><ul><li>不带缓冲的流的工作原理：它读取到一个字节&#x2F;字符，就向用户指定的路径写出去，读一个写一个，所以就慢了。</li><li>带缓冲的流的工作原理：读取到一个字节&#x2F;字符，先不输出，等凑足了缓冲的最大容量后一次性写出去，从而提高了工作效率</li><li>优点：减少对硬盘的读取次数，降低对硬盘的损耗。</li></ul><h1 id="列举常用字节输入流和输出流并说明其特点，至少5对。"><a href="#列举常用字节输入流和输出流并说明其特点，至少5对。" class="headerlink" title="列举常用字节输入流和输出流并说明其特点，至少5对。"></a>列举常用字节输入流和输出流并说明其特点，至少5对。</h1><ul><li>FileInputStream 从文件系统中的某个文件中获得输入字节。</li><li>FileOutputStream 从程序当中的数据，写入到指定文件。</li><li>ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。</li><li>ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪 read 方法要提供的下一个字节。</li><li>FilterInputStream 包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。FilterInputStream 类本身只是简单地重写那些将所有请求传递给所包含输入流的 InputStream 的所有方法。FilterInputStream 的子类可进一步重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</li><li>StringBufferInputStream此类允许应用程序创建输入流，在该流中读取的字节由字符串内容提供。应用程序还可以使用ByteArrayInputStream 从 byte 数组中读取字节。 只有字符串中每个字符的低八位可以由此类使用。ByteArrayOutputStream此类实现了一个输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</li><li>FileOutputStream文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。文件是否可用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。</li><li>FilterOutputStream类是过滤输出流的所有类的超类。这些流位于已存在的输出流（基础 输出流）之上，它们将已存在的输出流作为其基本数据接收器，但可能直接传输数据或提供一些额外的功能。 FilterOutputStream 类本身只是简单地重写那些将所有请求传递给所包含输出流的 OutputStream 的所有方法。FilterOutputStream 的子类可进一步地重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</li><li>ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。</li><li>PipedOutputStream可以将管道输出流连接到管道输入流来创建通信管道。管道输出流是管道的发送端。通常，数据由某个线程写入 PipedOutputStream 对象，并由其他线程从连接的 PipedInputStream 读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于毁坏状态。</li></ul><h1 id="字符流字节流联系区别；什么时候使用字节流和字符流"><a href="#字符流字节流联系区别；什么时候使用字节流和字符流" class="headerlink" title="字符流字节流联系区别；什么时候使用字节流和字符流?"></a>字符流字节流联系区别；什么时候使用字节流和字符流?</h1><ul><li>字符流和字节流是流的一种划分，按处理照流的数据单位进行的划分</li><li>两类都分为输入和输出操作</li><li>在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。这四个都是抽象类。</li><li>字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组</li><li>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的编码来处理，也就是要进行字符集的转化 这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联的。</li></ul><h1 id="输入流和输出流联系和区别，节点流和处理流联系和区别"><a href="#输入流和输出流联系和区别，节点流和处理流联系和区别" class="headerlink" title="输入流和输出流联系和区别，节点流和处理流联系和区别"></a>输入流和输出流联系和区别，节点流和处理流联系和区别</h1><ul><li>流就像管道一样，在程序和文件之间，输入输出的方向是针对程序而言，向程序中读入东西，就是输入流，从程序中向外读东西，就是输出流。</li><li>输入流是得到数据，输出流是输出数据，而节点流，处理流是流的另一种划分，按照功能不同进行的划分</li><li>节点流，可以从或向一个特定的地方(节点)读写数据</li><li>处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader</li><li>处理流的构造方法总是要带一个其他的流对象做参数</li><li>一个流对象经过其他流的多次包装，称为流的链接。</li></ul><h1 id="I-O-流两种流（字符、字节）、四个接口："><a href="#I-O-流两种流（字符、字节）、四个接口：" class="headerlink" title="I&#x2F;O 流两种流（字符、字节）、四个接口："></a>I&#x2F;O 流两种流（字符、字节）、四个接口：</h1><ul><li>Read&#x2F;Write，Input&#x2F;Output</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/4181b8cf024e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/4181b8cf024e.html" class="post-title-link" itemprop="url">Socket</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:16:07" itemprop="dateCreated datePublished" datetime="2023-12-30T14:16:07+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 00:40:41" itemprop="dateModified" datetime="2024-01-04T00:40:41+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Socket编程"><a href="#什么是Socket编程" class="headerlink" title="什么是Socket编程"></a>什么是Socket编程</h1><ul><li>所谓socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄</li><li>应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</li><li>我们开发的网络应用程序位于应用层，TCP和UDP属于传输层协议，在应用层如何使用传输层的服务呢？在应用层和传输层之间，则是使用套接字来进行分离。</li><li>套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者接收远程发来的数据；而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次的工作。</li><li>Socket实际是传输层供给应用层的编程接口。传输层则在网络层的基础上提供进程到进程问的逻辑通道，而应用层的进程则利用传输层向另一台主机的某一进程通信。Socket就是应用层与传输层之间的桥梁</li><li>使用Socket编程可以开发客户机和服务器应用程序，可以在本地网络上进行通信，也可通过Internet在全球范围内通信</li></ul><h1 id="简述基于TCP和UDP的Socket编程的主要步骤"><a href="#简述基于TCP和UDP的Socket编程的主要步骤" class="headerlink" title="简述基于TCP和UDP的Socket编程的主要步骤"></a>简述基于TCP和UDP的Socket编程的主要步骤</h1><ul><li>Java分别为TCP和UDP 两种通信协议提供了相应的Socket编程类，这些类存放在java.net包中</li><li>与TCP对应的是服务器的ServerSocket和客户端的Socket，与UDP对应的是DatagramSocket。</li><li>基于TCP创建的套接字可以叫做流套接字，服务器端相当于一个监听器，用来监听端口</li><li>服务器与客服端之间的通讯都是输入输出流来实现的</li><li>基于UDP的套接字就是数据报套接字，两个都要先构造好相应的数据包。</li></ul><h4 id="基于TCP协议的Socket编程的主要步骤"><a href="#基于TCP协议的Socket编程的主要步骤" class="headerlink" title="基于TCP协议的Socket编程的主要步骤"></a>基于TCP协议的Socket编程的主要步骤</h4><h5 id="服务器端（server）"><a href="#服务器端（server）" class="headerlink" title="服务器端（server）"></a>服务器端（server）</h5><ul><li>构建一个ServerSocket实例，指定本地的端口。这个socket就是用来监听指定端口的连接请求的。</li><li>重复如下几个步骤：<ul><li>调用socket的accept()方法来获得下面客户端的连接请求。通过accept()方法返回的socket实例，建立了一个和客户端的新连接。</li><li>通过这个返回的socket实例获取InputStream和OutputStream,可以通过这两个stream来分别读和写数据。</li><li>结束的时候调用socket实例的close()方法关闭socket连接。</li></ul></li></ul><h5 id="客户端（client）"><a href="#客户端（client）" class="headerlink" title="客户端（client）"></a>客户端（client）</h5><ul><li>构建Socket实例，通过指定的远程服务器地址和端口来建立连接。</li><li>通过Socket实例包含的InputStream和OutputStream来进行数据的读写。</li><li>操作结束后调用socket实例的close方法，关闭</li></ul><h4 id="基于UDP协议的Socket编程的主要步骤"><a href="#基于UDP协议的Socket编程的主要步骤" class="headerlink" title="基于UDP协议的Socket编程的主要步骤"></a>基于UDP协议的Socket编程的主要步骤</h4><h5 id="服务器端（server）-1"><a href="#服务器端（server）-1" class="headerlink" title="服务器端（server）"></a>服务器端（server）</h5><ul><li>构造DatagramSocket实例，指定本地端口。</li><li>通过DatagramSocket实例的receive方法接收DatagramPacket.DatagramPacket中间就包含了通信的内容。</li><li>通过DatagramSocket的send和receive方法来收和发DatagramPacket.</li></ul><h5 id="客户端（client）-1"><a href="#客户端（client）-1" class="headerlink" title="客户端（client）"></a>客户端（client）</h5><ul><li>构造DatagramSocket实例。</li><li>通过DatagramSocket实例的send和receive方法发送DatagramPacket报文。</li><li>结束后，调用DatagramSocket的close方法关闭。</li></ul><h1 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h1><ul><li>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</li><li>WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</li><li>WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</li><li>单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</li><li>Light -与 http 相比，WebSocket 消息数据交换要轻得多。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/a36cfa964151.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/a36cfa964151.html" class="post-title-link" itemprop="url">反射</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:09:59" itemprop="dateCreated datePublished" datetime="2023-12-30T14:09:59+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 17:17:04" itemprop="dateModified" datetime="2024-01-04T17:17:04+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Java反射技术主要实现类有哪些，作用分别是什么？"><a href="#Java反射技术主要实现类有哪些，作用分别是什么？" class="headerlink" title="Java反射技术主要实现类有哪些，作用分别是什么？"></a>Java反射技术主要实现类有哪些，作用分别是什么？</h1><ul><li>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中</li><li>Class类：代表一个类</li><li>Field 类：代表类的成员变量(属性)</li><li>Method类：代表类的成员方法</li><li>Constructor 类：代表类的构造方法</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li></ul><h1 id="反射的使用场合和作用、及其优缺点"><a href="#反射的使用场合和作用、及其优缺点" class="headerlink" title="反射的使用场合和作用、及其优缺点"></a>反射的使用场合和作用、及其优缺点</h1><ul><li>使用场合：在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息。</li><li>主要作用：通过反射可以使程序代码访问装载到JVM 中的类的内部信息，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息</li><li>反射的优点：反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类；反射是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的。Java反射技术应用领域很广，如软件测试、 EJB、JavaBean等；许多流行的开源框架例如Struts、Hibernate、Spring在实现过程中都采用了该技术</li><li>反射的缺点<ul><li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。</li><li>使用反射会模糊程序内部逻辑：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。</li></ul></li></ul><h1 id="Java-反射机制的作用？"><a href="#Java-反射机制的作用？" class="headerlink" title="Java 反射机制的作用？"></a>Java 反射机制的作用？</h1><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li></ul><h1 id="JAVA-反射"><a href="#JAVA-反射" class="headerlink" title="JAVA 反射"></a>JAVA 反射</h1><h4 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h4><ul><li>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。</li></ul><h4 id="反射机制概念-（运行状态中知道类所有的属性和方法）"><a href="#反射机制概念-（运行状态中知道类所有的属性和方法）" class="headerlink" title="反射机制概念 （运行状态中知道类所有的属性和方法）"></a>反射机制概念 （运行状态中知道类所有的属性和方法）</h4><ul><li>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；</li><li>并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</li></ul><h4 id="反射的应用场合"><a href="#反射的应用场合" class="headerlink" title="反射的应用场合"></a>反射的应用场合</h4><ul><li>编译时类型和运行时类型</li><li>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：Person p&#x3D;new Student();其中编译时类型为 Person，运行时类型为 Student。的编译时类型无法获取具体方法程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。</li><li>然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</li></ul><h1 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h1><ul><li>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架</li><li>Java反射的主要功能：<ul><li>确定一个对象的类</li><li>取出类的modifiers,数据成员,方法,构造器,和超类.</li><li>找出某个接口里定义的常量和方法说明.</li><li>创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).</li><li>取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.</li><li>在运行时刻调用动态对象的方法.</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">447k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:46</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>