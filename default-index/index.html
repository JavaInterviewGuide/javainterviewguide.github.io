<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:type" content="website"><meta property="og:title" content="Java面试指南"><meta property="og:url" content="https://javainterviewguide.github.io/default-index/index.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="路漫漫其修远兮，吾将上下而求索"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="褚岩"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/default-index/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Java面试指南</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">40</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">30</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/b1378143ed59.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/b1378143ed59.html" class="post-title-link" itemprop="url">Hibernate</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-02 14:48:16 / 修改时间：14:55:25" itemprop="dateCreated datePublished" datetime="2024-01-02T14:48:16+08:00">2024-01-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="介绍一下-Hibernate-的缓存"><a href="#介绍一下-Hibernate-的缓存" class="headerlink" title="介绍一下 Hibernate 的缓存"></a>介绍一下 Hibernate 的缓存</h1><h4 id="为什么要用-Hibernate-缓存？"><a href="#为什么要用-Hibernate-缓存？" class="headerlink" title="为什么要用 Hibernate 缓存？"></a>为什么要用 Hibernate 缓存？</h4><ul><li>Hibernate 是一种持久化层框架，经常访问物理数据库。</li><li>为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。</li><li>为了提高访问速度，把磁盘或者数据库访问变成内存访问</li></ul><h4 id="Hibernate-缓存原理是怎样的？"><a href="#Hibernate-缓存原理是怎样的？" class="headerlink" title="Hibernate 缓存原理是怎样的？"></a>Hibernate 缓存原理是怎样的？</h4><ul><li>Hibernate 缓存包括两大类：Hibernate一级缓存和 Hibernate 二级缓存</li></ul><h1 id="Hibernate-一级缓存又称为”session-的缓存”。"><a href="#Hibernate-一级缓存又称为”session-的缓存”。" class="headerlink" title="Hibernate 一级缓存又称为”session 的缓存”。"></a>Hibernate 一级缓存又称为”session 的缓存”。</h1><ul><li>session 缓存内置不能被卸载，session 的缓存是事务范围的缓存(session 对象的生命周期通常对应一个数据库事务或者一个应用事务)。</li><li>一级缓存中，持久化类的每个实例都具有唯一的 OID</li></ul><h1 id="Hibernate-的二级缓存又称为”sessionFactory-的缓存”。"><a href="#Hibernate-的二级缓存又称为”sessionFactory-的缓存”。" class="headerlink" title="Hibernate 的二级缓存又称为”sessionFactory 的缓存”。"></a>Hibernate 的二级缓存又称为”sessionFactory 的缓存”。</h1><ul><li>由于 sessionFactory 对象的生命周期和应用程序的整个过程对应，因此 Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。</li><li>第二级缓存是可选的，是一个可配置的插件，默认下 sessionFactory 不会启用这个插件。</li><li>什么样的数据适合存放到二级缓存中？<ul><li>很少被修改的数据 (帖子的最后回复时间)</li><li>经常被查询的数据 (电商的地点)</li><li>不是很重要的数据，允许出现偶尔并发的数据</li><li>不会被并发访问的数据</li><li>常量数据</li></ul></li><li>Hibernate 的二级缓存默认是不支持分布式缓存的，使用 memcache，redis等中央缓存来代替二级缓存</li></ul><h1 id="Hibernate-对象的状态"><a href="#Hibernate-对象的状态" class="headerlink" title="Hibernate 对象的状态"></a>Hibernate 对象的状态</h1><ul><li>临时状态&#x2F;瞬时状态(transient)：刚刚用 new 语句创建，没有被持久化，无 id，不处于 session 中(没有使用 session 的方法去操作临时对象)，该对象成为临时对象持久化状态，</li><li>托管状态(persistent)：已经被持久化，加入 session 的缓存中，session是没有关闭该状态的对象为持久化对象。</li><li>游离状态，脱管状态(detached)：已经被持久化，但不处于 session 中，该状态的对象为游离对象。</li><li>删除状态(removed)：对象有关联的 id，并且在 session 管理下，但是已经被计划(事务提交的时候，commit)删除，如果没有事务就不能删除相互转换</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/fec4be92fa21.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/fec4be92fa21.html" class="post-title-link" itemprop="url">架构</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-31 12:24:09" itemprop="dateCreated datePublished" datetime="2023-12-31T12:24:09+08:00">2023-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-02 14:51:54" itemprop="dateModified" datetime="2024-01-02T14:51:54+08:00">2024-01-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是-ELK（ElasticSearch-Logstash-Kibana）"><a href="#什么是-ELK（ElasticSearch-Logstash-Kibana）" class="headerlink" title="什么是 ELK（ElasticSearch, Logstash, Kibana）"></a>什么是 ELK（ElasticSearch, Logstash, Kibana）</h1><ul><li>ELK 是三个工具的集合，Elasticsearch + Logstash + Kibana，这三个工具组合形成了<br>一套实用、易用的监控架构，很多公司利用它来搭建可视化的海量日志分析平台。</li></ul><h4 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h4><ul><li>ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口</li><li>Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li></ul><h4 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h4><ul><li>Logstash 是一个用于管理日志和事件的工具，你可以用它去收集日志、转换日志、解析日志并将他们作为数据提供给其它模块调用，例如搜索、存储等。</li></ul><h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><ul><li>Kibana 是一个优秀的前端日志展示框架，它可以非常详细的将日志转化为各种图表，为用户提供强大的数据可视化支持。</li></ul><h1 id="什么是网关服务？"><a href="#什么是网关服务？" class="headerlink" title="什么是网关服务？"></a>什么是网关服务？</h1><ul><li>网关服务，通常是外部访问服务的唯一接口，访问内部的所有服务都必须先经过网关服务。网关服务的主要功能是消息解析过滤，路由，转发等。</li></ul><h1 id="网关服务中，路由器的-4-种路由规则方法是什么？"><a href="#网关服务中，路由器的-4-种路由规则方法是什么？" class="headerlink" title="网关服务中，路由器的 4 种路由规则方法是什么？"></a>网关服务中，路由器的 4 种路由规则方法是什么？</h1><ul><li>采用 URL 指定路由方式</li><li>采用服务名称指定路由方式</li><li>路由的排除方法</li><li>路由的添加前缀方法</li></ul><h1 id="什么是服务的灾难性的雪崩效应？"><a href="#什么是服务的灾难性的雪崩效应？" class="headerlink" title="什么是服务的灾难性的雪崩效应？"></a>什么是服务的灾难性的雪崩效应？</h1><ul><li>在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问 A 服务，而 A 服务需要调用 B 服务，B 服务需要调用 C 服务，由于网络原因或者自身的原因，如果 B 服务或者 C 服务不能及时响应，A 服务将处于阻塞状态，直到 B 服务 C 服务响应。</li><li>此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应</li></ul><h1 id="如何解决灾难性雪崩效应？"><a href="#如何解决灾难性雪崩效应？" class="headerlink" title="如何解决灾难性雪崩效应？"></a>如何解决灾难性雪崩效应？</h1><ul><li>降级：超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值.</li><li>隔离（线程池隔离和信号量隔离）：限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。</li><li>熔断：当失败率(如因网络故障&#x2F;超时造成的失败率高)达到阀值自动触发降级，熔断器触发的快速失败会进行快速恢复。</li><li>缓存：提供了请求缓存。</li><li>请求合并：提供请求合并。</li></ul><h1 id="什么是声明式，有什么作用，解决什么问题？"><a href="#什么是声明式，有什么作用，解决什么问题？" class="headerlink" title="什么是声明式，有什么作用，解决什么问题？"></a>什么是声明式，有什么作用，解决什么问题？</h1><ul><li>声明式调用就像调用本地方法一样调用远程方法;无感知远程 http 请求。</li><li>Spring Cloud 的声明式调用, 可以做到使用 HTTP 请求远程服务时能就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。</li><li>它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规的 Http Client 构造请求再解析返回数据。</li><li>它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</li></ul><h1 id="什么是-AKF-拆分原则？"><a href="#什么是-AKF-拆分原则？" class="headerlink" title="什么是 AKF 拆分原则？"></a>什么是 AKF 拆分原则？</h1><ul><li>业界对于可扩展的系统架构设计有一个朴素的理念,就是：通过加机器就可以解决容量和可用性问题。(如果一台不行那就两台)。</li></ul><h1 id="简单讲一下-webservice-使用的场景"><a href="#简单讲一下-webservice-使用的场景" class="headerlink" title="简单讲一下 webservice 使用的场景"></a>简单讲一下 webservice 使用的场景</h1><ul><li>webservice 是一个 SOA(面向服务的编程)的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过 Internet 进行基于 http 协议的网络应用间的交互。</li><li>异构系统(不同的开发语言)的整合</li><li>不同客户端的整合 (浏览器、手机端(android\ios)、微信)</li><li>实实在在的例子：天气预报：可以通过实现 webservice 客户端调用远程天气服务实现的</li><li>单点登录：一个服务实现所有系统的登录</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/73098ee3eeb0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/73098ee3eeb0.html" class="post-title-link" itemprop="url">集合</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:39:17 / 修改时间：16:16:14" itemprop="dateCreated datePublished" datetime="2023-12-30T14:39:17+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h1><ul><li>Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。</li><li>Java中还有一个Collections类，专门用来操作集合类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li></ul><h1 id="集合和数组的比较（为什么引入集合）"><a href="#集合和数组的比较（为什么引入集合）" class="headerlink" title="集合和数组的比较（为什么引入集合）"></a>集合和数组的比较（为什么引入集合）</h1><ul><li>数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框架类可适用于不同场合</li><li>具体如下：<ul><li>数组的效率高于集合类.</li><li>数组能存放基本数据类型和对象，而集合类中只能放对象。</li><li>数组容量固定且无法动态改变，集合类容量动态改变。</li><li>数组无法判断其中实际存有多少元素，length只告诉了array的容量。</li><li>集合有多种实现方式和不同的适用场合，而不像数组仅采用顺序表方式。</li><li>集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。</li></ul></li></ul><h1 id="TreeSet的原理和使用"><a href="#TreeSet的原理和使用" class="headerlink" title="TreeSet的原理和使用"></a>TreeSet的原理和使用</h1><ul><li>TreeSet集合，元素不允许重复且有序(自然顺序)</li><li>TreeSet采用树结构存储数据，存入元素时需要和树中元素进行对比，需要指定比较策略。</li><li>可以通过Comparable(外部比较器)和Comparator(内部比较器)来指定比较策略，实现了Comparable的系统类可以顺利存入TreeSet。自定义类可以实现Comparable接口来指定比较策略。</li><li>可创建Comparator接口实现类来指定比较策略，并通过TreeSet构造方法参数传入。这种方式尤其对系统类非常适用。</li></ul><h1 id="HashSet的使用和原理"><a href="#HashSet的使用和原理" class="headerlink" title="HashSet的使用和原理"></a>HashSet的使用和原理</h1><ul><li>哈希表的查询速度特别快，时间复杂度为O（1）。</li><li>HashMap、Hashtable、HashSet这些集合采用的是哈希表结构，需要用到hashCode哈希码，hashCode是一个整数值。</li><li>系统类已经覆盖了hashCode方法 自定义类如果要放入hash类集合，必须重写hashcode。如果不重写，调用的是Object的hashcode，而Object的hashCode实际上是地址。</li><li>向哈希表中添加数据的原理：当向集合Set中增加对象时，首先集合计算要增加对象的hashCode码，根据该值来得到一个位置用来存放当前对象，如在该位置没有一个对象存在的话，那么集合Set认为该对象在集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接着将准备增加到集合中的对象与该位置上的对象进行equals方法比较，如果该equals方法返回false,那么集合认为集合中不存在该对象，在进行一次散列，将该对象放到散列后计算出的新地址里。如果equals方法返回true，那么集合认为集合中已经存在该对象了，不会再将该对象增加到集合中了。</li><li>在哈希表中判断两个元素是否重复要使用到hashCode()和equals()。hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。</li><li>Y&#x3D;K(X) ：K是函数，X是哈希码，Y是地址</li></ul><h1 id="ArrayList和LinkedList的区别和联系"><a href="#ArrayList和LinkedList的区别和联系" class="headerlink" title="ArrayList和LinkedList的区别和联系"></a>ArrayList和LinkedList的区别和联系</h1><ul><li>相同点：两者都实现了List接口，都具有List中元素有序、不唯一的特点。</li><li>不同点：ArrayList实现了长度可变的数组，在内存中分配连续空间。遍历元素和随机访问元素的效率比较高；LinkedList采用链表存储方式。插入、删除元素时效率比较高</li></ul><h1 id="HashMap和Hashtable的区别和联系"><a href="#HashMap和Hashtable的区别和联系" class="headerlink" title="HashMap和Hashtable的区别和联系"></a>HashMap和Hashtable的区别和联系</h1><ul><li>相同点：实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</li><li>不同点：<ul><li>Hashtable是早期提供的接口，HashMap是新版JDK提供的接口</li><li>Hashtable继承Dictionary类，HashMap实现Map接口</li><li>Hashtable线程安全，HashMap线程非安全</li><li>Hashtable不允许null值，HashMap允许null值</li></ul></li></ul><h1 id="Vector和ArrayList的区别和联系"><a href="#Vector和ArrayList的区别和联系" class="headerlink" title="Vector和ArrayList的区别和联系"></a>Vector和ArrayList的区别和联系</h1><ul><li>相同点：<ul><li>实现原理相同—底层都使用数组</li><li>功能相同—实现增删改查等操作的方法相似</li><li>都是长度可变的数组结构，很多情况下可以互用</li></ul></li><li>不同点：<ul><li>Vector是早期JDK接口，ArrayList是替代Vector的新接口</li><li>Vector线程安全，ArrayList重速度轻安全，线程非安全</li><li>长度需增长时，Vector默认增长一倍，ArrayList增长50%</li></ul></li></ul><h1 id="Java集合体系结构"><a href="#Java集合体系结构" class="headerlink" title="Java集合体系结构"></a>Java集合体系结构</h1><ul><li>Collection 接口存储一组不唯一，无序的对象</li><li>List 接口存储一组不唯一，有序（插入顺序）的对象</li><li>Set 接口存储一组唯一，无序的对象</li><li>Map接口存储一组键值对象，提供key到value的映射。Key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</li></ul><h1 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h1><ul><li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li><li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</li><li>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul><h1 id="List、Map、Set-三个接口，存取元素时，各有什么特点？"><a href="#List、Map、Set-三个接口，存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set 三个接口，存取元素时，各有什么特点？"></a>List、Map、Set 三个接口，存取元素时，各有什么特点？</h1><ul><li>List以特定索引来存取元素，可有重复元素。</li><li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）</li><li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一</li><li>Set和Map容器都有基于哈希存储和排序树（红黑树）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</li></ul><p> </p><h1 id="说出ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#说出ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="说出ArrayList、Vector、LinkedList 的存储性能和特性？"></a>说出ArrayList、Vector、LinkedList 的存储性能和特性？</h1><ul><li>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。</li><li>遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖）。同理，Stack类继承Vector也是不正确的。</li></ul><p> </p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/3aaab7406978.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/3aaab7406978.html" class="post-title-link" itemprop="url">IO</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:28:05 / 修改时间：14:34:05" itemprop="dateCreated datePublished" datetime="2023-12-30T14:28:05+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说明缓冲流的优点和原理"><a href="#说明缓冲流的优点和原理" class="headerlink" title="说明缓冲流的优点和原理"></a>说明缓冲流的优点和原理</h1><ul><li>不带缓冲的流的工作原理：它读取到一个字节&#x2F;字符，就向用户指定的路径写出去，读一个写一个，所以就慢了。</li><li>带缓冲的流的工作原理：读取到一个字节&#x2F;字符，先不输出，等凑足了缓冲的最大容量后一次性写出去，从而提高了工作效率</li><li>优点：减少对硬盘的读取次数，降低对硬盘的损耗。</li></ul><h1 id="列举常用字节输入流和输出流并说明其特点，至少5对。"><a href="#列举常用字节输入流和输出流并说明其特点，至少5对。" class="headerlink" title="列举常用字节输入流和输出流并说明其特点，至少5对。"></a>列举常用字节输入流和输出流并说明其特点，至少5对。</h1><ul><li>FileInputStream 从文件系统中的某个文件中获得输入字节。</li><li>FileOutputStream 从程序当中的数据，写入到指定文件。</li><li>ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。</li><li>ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪 read 方法要提供的下一个字节。</li><li>FilterInputStream 包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。FilterInputStream 类本身只是简单地重写那些将所有请求传递给所包含输入流的 InputStream 的所有方法。FilterInputStream 的子类可进一步重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</li><li>StringBufferInputStream此类允许应用程序创建输入流，在该流中读取的字节由字符串内容提供。应用程序还可以使用ByteArrayInputStream 从 byte 数组中读取字节。 只有字符串中每个字符的低八位可以由此类使用。ByteArrayOutputStream此类实现了一个输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</li><li>FileOutputStream文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。文件是否可用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。</li><li>FilterOutputStream类是过滤输出流的所有类的超类。这些流位于已存在的输出流（基础 输出流）之上，它们将已存在的输出流作为其基本数据接收器，但可能直接传输数据或提供一些额外的功能。 FilterOutputStream 类本身只是简单地重写那些将所有请求传递给所包含输出流的 OutputStream 的所有方法。FilterOutputStream 的子类可进一步地重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</li><li>ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。</li><li>PipedOutputStream可以将管道输出流连接到管道输入流来创建通信管道。管道输出流是管道的发送端。通常，数据由某个线程写入 PipedOutputStream 对象，并由其他线程从连接的 PipedInputStream 读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于毁坏状态。</li></ul><h1 id="字符流字节流联系区别；什么时候使用字节流和字符流"><a href="#字符流字节流联系区别；什么时候使用字节流和字符流" class="headerlink" title="字符流字节流联系区别；什么时候使用字节流和字符流?"></a>字符流字节流联系区别；什么时候使用字节流和字符流?</h1><ul><li>字符流和字节流是流的一种划分，按处理照流的数据单位进行的划分</li><li>两类都分为输入和输出操作</li><li>在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。这四个都是抽象类。</li><li>字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组</li><li>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的编码来处理，也就是要进行字符集的转化 这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联的。</li></ul><h1 id="输入流和输出流联系和区别，节点流和处理流联系和区别"><a href="#输入流和输出流联系和区别，节点流和处理流联系和区别" class="headerlink" title="输入流和输出流联系和区别，节点流和处理流联系和区别"></a>输入流和输出流联系和区别，节点流和处理流联系和区别</h1><ul><li>流就像管道一样，在程序和文件之间，输入输出的方向是针对程序而言，向程序中读入东西，就是输入流，从程序中向外读东西，就是输出流。</li><li>输入流是得到数据，输出流是输出数据，而节点流，处理流是流的另一种划分，按照功能不同进行的划分</li><li>节点流，可以从或向一个特定的地方(节点)读写数据</li><li>处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader</li><li>处理流的构造方法总是要带一个其他的流对象做参数</li><li>一个流对象经过其他流的多次包装，称为流的链接。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/4181b8cf024e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/4181b8cf024e.html" class="post-title-link" itemprop="url">Socket</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:16:07 / 修改时间：14:21:56" itemprop="dateCreated datePublished" datetime="2023-12-30T14:16:07+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Socket编程"><a href="#什么是Socket编程" class="headerlink" title="什么是Socket编程"></a>什么是Socket编程</h1><ul><li>所谓socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄</li><li>应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</li><li>我们开发的网络应用程序位于应用层，TCP和UDP属于传输层协议，在应用层如何使用传输层的服务呢？在应用层和传输层之间，则是使用套接字来进行分离。</li><li>套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者接收远程发来的数据；而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次的工作。</li><li>Socket实际是传输层供给应用层的编程接口。传输层则在网络层的基础上提供进程到进程问的逻辑通道，而应用层的进程则利用传输层向另一台主机的某一进程通信。Socket就是应用层与传输层之间的桥梁</li><li>使用Socket编程可以开发客户机和服务器应用程序，可以在本地网络上进行通信，也可通过Internet在全球范围内通信</li></ul><h1 id="简述基于TCP和UDP的Socket编程的主要步骤"><a href="#简述基于TCP和UDP的Socket编程的主要步骤" class="headerlink" title="简述基于TCP和UDP的Socket编程的主要步骤"></a>简述基于TCP和UDP的Socket编程的主要步骤</h1><ul><li>Java分别为TCP和UDP 两种通信协议提供了相应的Socket编程类，这些类存放在java.net包中</li><li>与TCP对应的是服务器的ServerSocket和客户端的Socket，与UDP对应的是DatagramSocket。</li><li>基于TCP创建的套接字可以叫做流套接字，服务器端相当于一个监听器，用来监听端口</li><li>服务器与客服端之间的通讯都是输入输出流来实现的</li><li>基于UDP的套接字就是数据报套接字，两个都要先构造好相应的数据包。</li></ul><h4 id="基于TCP协议的Socket编程的主要步骤"><a href="#基于TCP协议的Socket编程的主要步骤" class="headerlink" title="基于TCP协议的Socket编程的主要步骤"></a>基于TCP协议的Socket编程的主要步骤</h4><h5 id="服务器端（server）"><a href="#服务器端（server）" class="headerlink" title="服务器端（server）"></a>服务器端（server）</h5><ul><li>构建一个ServerSocket实例，指定本地的端口。这个socket就是用来监听指定端口的连接请求的。</li><li>重复如下几个步骤：<ul><li>调用socket的accept()方法来获得下面客户端的连接请求。通过accept()方法返回的socket实例，建立了一个和客户端的新连接。</li><li>通过这个返回的socket实例获取InputStream和OutputStream,可以通过这两个stream来分别读和写数据。</li><li>结束的时候调用socket实例的close()方法关闭socket连接。</li></ul></li></ul><h5 id="客户端（client）"><a href="#客户端（client）" class="headerlink" title="客户端（client）"></a>客户端（client）</h5><ul><li>构建Socket实例，通过指定的远程服务器地址和端口来建立连接。</li><li>通过Socket实例包含的InputStream和OutputStream来进行数据的读写。</li><li>操作结束后调用socket实例的close方法，关闭</li></ul><h4 id="基于UDP协议的Socket编程的主要步骤"><a href="#基于UDP协议的Socket编程的主要步骤" class="headerlink" title="基于UDP协议的Socket编程的主要步骤"></a>基于UDP协议的Socket编程的主要步骤</h4><h5 id="服务器端（server）-1"><a href="#服务器端（server）-1" class="headerlink" title="服务器端（server）"></a>服务器端（server）</h5><ul><li>构造DatagramSocket实例，指定本地端口。</li><li>通过DatagramSocket实例的receive方法接收DatagramPacket.DatagramPacket中间就包含了通信的内容。</li><li>通过DatagramSocket的send和receive方法来收和发DatagramPacket.</li></ul><h5 id="客户端（client）-1"><a href="#客户端（client）-1" class="headerlink" title="客户端（client）"></a>客户端（client）</h5><ul><li>构造DatagramSocket实例。</li><li>通过DatagramSocket实例的send和receive方法发送DatagramPacket报文。</li><li>结束后，调用DatagramSocket的close方法关闭。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/a36cfa964151.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/a36cfa964151.html" class="post-title-link" itemprop="url">反射</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:09:59 / 修改时间：14:15:12" itemprop="dateCreated datePublished" datetime="2023-12-30T14:09:59+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>660</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Java反射技术主要实现类有哪些，作用分别是什么？"><a href="#Java反射技术主要实现类有哪些，作用分别是什么？" class="headerlink" title="Java反射技术主要实现类有哪些，作用分别是什么？"></a>Java反射技术主要实现类有哪些，作用分别是什么？</h1><ul><li>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflect包中</li><li>Class类：代表一个类</li><li>Field 类：代表类的成员变量(属性)</li><li>Method类：代表类的成员方法</li><li>Constructor 类：代表类的构造方法</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li></ul><h1 id="反射的使用场合和作用、及其优缺点"><a href="#反射的使用场合和作用、及其优缺点" class="headerlink" title="反射的使用场合和作用、及其优缺点"></a>反射的使用场合和作用、及其优缺点</h1><ul><li>使用场合：在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息。</li><li>主要作用：通过反射可以使程序代码访问装载到JVM 中的类的内部信息，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息</li><li>反射的优点：反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类；反射是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的。Java反射技术应用领域很广，如软件测试、 EJB、JavaBean等；许多流行的开源框架例如Struts、Hibernate、Spring在实现过程中都采用了该技术</li><li>反射的缺点<ul><li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。</li><li>使用反射会模糊程序内部逻辑：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。</li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/7fec0b877c88.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/7fec0b877c88.html" class="post-title-link" itemprop="url">JSON</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-28 15:58:23 / 修改时间：15:59:49" itemprop="dateCreated datePublished" datetime="2023-12-28T15:58:23+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">序列化</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>593</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="JSON及其作用"><a href="#JSON及其作用" class="headerlink" title="JSON及其作用"></a>JSON及其作用</h1><ul><li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式</li><li>同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据不须要任何特殊的 API 或工具包。</li><li>在JSON中，有两种结构：对象和数组。<ul><li>一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称&#x2F;值’ 对”之间运用 “,”（逗号）分隔。 名称用引号括起来；值如果是字符串则必须用括号，数值型则不须要。例如：<ul><li>var o&#x3D;{“xlid”:”cxh”,”xldigitid”:123456,”topscore”:2000,”topplaytime”:”2009-08-20”}；</li></ul></li><li>数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间运用 “,”（逗号）分隔。例如：<ul><li>var jsonranklist&#x3D;[{“xlid”:”cxh”,”xldigitid”:123456,”topscore”:2000,”topplaytime”:”2009-08-20”},{“xlid”:”zd”,”xldigitid”:123456,”topscore”:1500,”topplaytime”:”2009-11-20”}];</li></ul></li></ul></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/3842b15435d5.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/3842b15435d5.html" class="post-title-link" itemprop="url">高可用性（HA）系统</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-28 12:52:22 / 修改时间：13:38:38" itemprop="dateCreated datePublished" datetime="2023-12-28T12:52:22+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%AB%98%E5%8F%AF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">高可用</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="SOA-面向服务的架构"><a href="#SOA-面向服务的架构" class="headerlink" title="SOA(面向服务的架构)"></a>SOA(面向服务的架构)</h1><ul><li>面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来</li><li>接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言</li><li>这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。</li><li>对于一个SOA解决方案来说就需要能够满足这些场景的业务需求，能够解决其中的各种技术问题</li><li>需要解决的基本问题包括：<ul><li>服务的描述问题，描述服务提供哪些功能，适用服务有哪些要求</li><li>服务的注册和查找问题，定义好的服务信息在哪发布，如何发布，到哪查找，如何查找</li><li>服务通讯方式，包括具体如何向服务发送请求，并获取应答，支持什么样的交互方式。</li><li>服务流程问题，对服务流程的灵活定制，执行监控等提供管理</li><li>服务的管理问题，服务的提供，撤销，改变这些情况如何进行管理</li><li>服务质量问题，如何保障安全性，通讯的可靠性，以及事务完整性如何保证</li><li>整个系统的效率问题，包括查找效率，通讯效率，服务运行处理效率等</li><li>系统能够提供什么样的开发工具，支持什么样的开发模式，系统运行情况是否可以及时了解，是否可以及时获取故障信息，是否可以提供运行状态信息，以利于系统的优化。</li></ul></li></ul><h1 id="ESB（企业服务总线）"><a href="#ESB（企业服务总线）" class="headerlink" title="ESB（企业服务总线）"></a>ESB（企业服务总线）</h1><ul><li>ESB全称为Enterprise Service Bus，即企业服务总线</li><li>它是传统中间件技术与XML、Web服务等技术结合的产物</li><li>ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素。</li><li>大规模分布式的企业应用需要相对简单而实用的中间件技术来简化和统一越来越复杂、繁琐的企业级信息系统平台</li><li>面向服务体系架构（SOA）是能够将应用程序的不同功能单元通过服务之间定义良好的接口和契约联系起来</li><li>SOA使用户可以不受限制地重复使用软件、把各种资源互连起来，只要IT人员选用标准接口包装旧的应用程序、把新的应用程序构建成服务，那么其他应用系统就可以很方便的使用这些功能服务。</li></ul><h1 id="SOA-与-ESB的区别"><a href="#SOA-与-ESB的区别" class="headerlink" title="SOA 与 ESB的区别"></a>SOA 与 ESB的区别</h1><ul><li>SOA是一种方式或架构，用于具有自服务功能的应用程序，应用程序随后通过用户接口（UI）或经过工作流将其聚合成用户需要的功能</li><li>服务不仅是可复用代码的组件，更是运行程序的一部分，客户端可以不必合并它自己的代码直接调用该程序</li><li>服务是与业务相关的一个定义。</li><li>ESB是用于调节 SOA 中的调用者及服务提供者的机制</li><li>它使得调用者在不知道提供者或提供者使用的地址的情况下调用该服务</li><li>ESB 可在多个提供者、提供者的负载平衡及停止使用提供者（当失效时）之间进行选择，并且基于调用者的需求在提供者之间进行选择，这些提供者提供了各种质量级别的服务</li><li>ESB 能够调节同步或异步服务，事实上对于同一服务可以提供同步及异步的访问。</li><li>因此 SOA 和 ESB 是相对应的。具备 SOA 的应用程序应当使用 ESB 来调用它的服务。SOA 和 ESB 不必用 Web 服务实现。然而，经常需要 ESB 来调用服务，该服务提供自我描述及发现的能力，这由 Web 服务帮助完成。在 SOA 中经常需要由一种技术实现的调用者，它们用于调用由其它技术实现的服务，这也由 Web 服务帮助完成</li><li>所以 SOA、ESB 和 Web 服务都集中于创建这样的领域：一个应用程序中的功能在其它应用程序中也是可用的，本质是复用性。</li></ul><h1 id="SAAS-软件即服务"><a href="#SAAS-软件即服务" class="headerlink" title="SAAS (软件即服务)"></a>SAAS (软件即服务)</h1><ul><li>SaaS是Software-as-a-Service（软件即服务）的简称,它与“on-demand software”（按需软件），the application service provider(ASP，应用服务提供商)，hosted software(托管软件)所具有相似的含义</li><li>它是一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。</li><li>对企业来说，SaaS的优点：<ul><li>从技术方面来看：SaaS是简单的部署，不需要购买任何硬件，刚开始只需要简单注册即可。企业无需再配备IT方面的专业技术人员，同时又能得到最新的技术应用，满足企业对信息管理的需求。</li><li>从投资方面来看：企业只以相对低廉的“月费”方式投资，不用一次性投资到位，不占用过多的营运资金，从而缓解企业资金不足的压力；不用考虑成本折旧问题，并能及时获得最新硬件平台及最佳解决方案。</li><li>从维护和管理方面来看：由于企业采取租用的方式来进行物流业务管理，不需要专门的维护和管理人员，也不需要为维护和管理人员支付额外费用。很大程度上缓解企业在人力、财力上的压力，使其能够集中资金对核心业务进行有效的运营；SaaS能使用户在世界上都是一个完全独立的系统。如果您连接到网络，就可以访问系统。</li></ul></li><li>对企业来说，SaaS的缺点<ul><li>安全性：企业，尤其是大型企业，很不情愿使用SaaS正是因为安全问题，他们要保护他们的核心数据，不希望这些核心数据由第三方来负责。</li><li>标准化：SaaS解决方案缺乏标准化。这个行业刚刚起步，没有明确的解决办法，一家公司可以设计建立一个解决方案。鉴于复杂和高度可定制的ERP产品，这是一个冒险的建议。</li></ul></li></ul><h1 id="SOA和SaaS的区别"><a href="#SOA和SaaS的区别" class="headerlink" title="SOA和SaaS的区别"></a>SOA和SaaS的区别</h1><ul><li>SOA包括了关于软件是如何被架构起来的东西，而SaaS是关于软件是如何被应用的。</li><li>在SaaS当中，应用程序可以像任何服务一样被传递，就像你家中电话的语音一样，看起来似乎就是为你的需求量体裁衣得到的。而SOA的定义和这个无丝毫的联系。SOA支持的服务，都是些离散的可以再使用的事务处理，这些事务处理合起来就组成了一个业务流程，是从基本的系统中提取出来的抽象代码。</li><li>SOA是一个框架的方法，而SaaS是一种传递模型。</li><li>通过SaaS传递Web服务并不需要SOA。</li><li>SaaS主要是指一个软件企业向其它企业提供软件服务。而SOA一般是企业内部搭建系统的基础。SaaS注重的是提供服务的思维。而SOA注重的是实现服务的思维。</li></ul><h1 id="微服务架构模式（Microservice-Architect-Pattern）"><a href="#微服务架构模式（Microservice-Architect-Pattern）" class="headerlink" title="微服务架构模式（Microservice Architect Pattern）"></a>微服务架构模式（Microservice Architect Pattern）</h1><ul><li>近两年在服务的疯狂增长与云计算技术的进步，让微服务架构受到重点关注微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值</li><li>每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。</li><li>每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建</li></ul><h4 id="微服务架构优势"><a href="#微服务架构优势" class="headerlink" title="微服务架构优势"></a>微服务架构优势</h4><ul><li>微服务架构的本质，是用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题</li><li>微服务架构将服务拆分，分别采用相对独立的服务对各方面进行管理，彼此之间使用统一的接口来进行交流，架构变得复杂，优势也很明显：<ul><li>复杂度可控：在将应用分解的同时，规避了原本复杂度无止境的积累</li><li>每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界</li><li>由于体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。</li><li>独立部署：由于微服务具备独立的运行进程，所以每个微服务也可以独立部署</li><li>当某个微服务发生变更时无需编译、部署整个应用</li><li>由微服务组成的应用相当于具备一系列可并行的发布流程，使得发布更加高效，同时降低对生产环境所造成的风险，最终缩短应用交付周期。</li><li>技术选型灵活：微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。由于每个微服务相对简单，当需要对技术栈进行升级时所面临的风险较低，甚至完全重构一个微服务也是可行的。</li><li>容错：当某一组建发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用</li><li>在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。</li><li>扩展：单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</li></ul></li></ul><h1 id="SOA和微服务架构的区别"><a href="#SOA和微服务架构的区别" class="headerlink" title="SOA和微服务架构的区别"></a>SOA和微服务架构的区别</h1><ul><li>微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化。</li><li>微服务架构强调的第一个重点就是业务系统需要彻底的组件化和服务化，原有的单个业务系统会拆分为多个可以独立开发，设计，运行和运维的小应用。这些小应用之间通过服务完成交互和集成。每个小应用从前端web ui，到控制层，逻辑层，数据库访问，数据库都完全是独立的一套。在这里我们不用组件而用小应用这个词更加合适，每个小应用除了完成自身本身的业务功能外，重点就是还需要消费外部其它应用暴露的服务，同时自身也将自身的能力朝外部发布为服务。</li><li>首先对于应用本身暴露出来的服务，是和应用一起部署的，即服务本身并不单独部署，服务本身就是业务组件已有的接口能力发布和暴露出来的</li><li>其次微服务架构本身来源于互联网的思路，因此组件对外发布的服务强调了采用HTTP Rest API的方式来进行。</li><li>微服务的基本思想在于考虑围绕着业务领域组件来创建应用，这些就应用可独立地进行开发、管理和加速。在分散的组件中使用微服务云架构和平台使部署、管理和服务功能交付变得更加简单。</li></ul><h1 id="什么是高可用性"><a href="#什么是高可用性" class="headerlink" title="什么是高可用性"></a>什么是高可用性</h1><ul><li>高可用性（HA）系统是目前企业防止核心计算机系统因故障停机的最有效手段。</li></ul><h1 id="高可用性（HA）的功能"><a href="#高可用性（HA）的功能" class="headerlink" title="高可用性（HA）的功能"></a>高可用性（HA）的功能</h1><ul><li>软件故障监测与排除</li><li>备份和数据保护</li><li>管理站能够监视各站点的运行情况，能随时或定时报告系统运行状况，故障能及时报告和告警，并有必要的控制手段</li><li>实现错误隔离以及主、备份服务器间的服务切换</li></ul><h1 id="HA的工作方式"><a href="#HA的工作方式" class="headerlink" title="HA的工作方式"></a>HA的工作方式</h1><ul><li>HA有主从方式和双工方式两种工作模式</li><li>高可用性方案则利用更少的冗余部件同时由软件检测故障，一旦故障发生立即隔离损坏部件，通过提供故障恢复实现最大化系统和应用的可用性。</li><li>容错技术随着处理器速度的加快和价格的下跌而越来越多地转移到软件中</li><li>未来容错技术将完全在软件环境下完成，那时它和高可用性技术之间的差别也就随之消失了。</li></ul><h1 id="高可用性（HA）系统-需要解决的问题"><a href="#高可用性（HA）系统-需要解决的问题" class="headerlink" title="高可用性（HA）系统-需要解决的问题"></a>高可用性（HA）系统-需要解决的问题</h1><ul><li>负载均衡与反向代理</li><li>隔离</li><li>限流</li><li>降级</li><li>超时与重试</li><li>回滚</li><li>压力测试与应急预案</li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性</li><li>软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，如DNS Load Balance，CheckPoint Firewall-1 ConnectControl等，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。</li><li>软件解决方案缺点也较多，因为每台服务器上安装额外的软件运行会消耗系统不定量的资源，越是功能强大的模块，消耗得越多，所以当连接请求特别大的时候，软件本身会成为服务器工作成败的一个关键；软件可扩展性并不是很好，受到操作系统的限制；由于操作系统本身的Bug，往往会引起安全问题。 硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。</li></ul><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul><li>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li><li>代理服务器有三种：<ul><li>标准的代理缓冲服务器：一个标准的代理缓冲服务被用于缓存静态的网页（例如：html文件和图片文件等）到本地网络上的一台主机上（即代理服务器）。</li><li>透明代理缓冲服务器：透明代理缓冲服务和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。</li><li>反向代理缓冲服务器：反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。</li></ul></li><li>安全反向代理用途：<ul><li>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。</li><li>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息。</li><li>安全反向代理会造成各安全连接加密数据所涉及的系统开销而变慢。 SSL 提供了高速缓存机制，连接双方重复使用先前协商的安全参数，大大降低后续连接的系统开销。</li></ul></li></ul><h4 id="隔离术"><a href="#隔离术" class="headerlink" title="隔离术"></a>隔离术</h4><ul><li>线程隔离:<ul><li>线程隔离主要是指线程池隔离，在实际使用时，我们会把请求分类，然后交给不同的线程池处理。当一种业务的请求处理发生问题时，不会将故障扩散到其他线程池，从而保证其他服务可用。</li></ul></li><li>进程隔离<ul><li>由于传统的系统所有功能都集中在一个系统中，为了避免系统其中一个模块功能出现问题导致整个系统无法使用的情况发生，将其该系统拆分成多子系统实现物理隔离，故通过进程隔离使得某一个子系统出现问题时不影响到其他子系统。</li></ul></li><li>集群隔离<ul><li>随着调用方的增多，当秒杀（并发量特别大功能）类似的服务被刷新会影响到其他服务的稳定性时，应该考虑为秒杀（并发量特别大功能）类似的服务提供单独的服务集群，即分服务分组，这样当某一个分组出现问题时，不会影响到其他分组，从而实现了故障隔离愿景。</li></ul></li><li>机房隔离<ul><li>随着对系统可用性的要求，会进行多机房部署，每一个机房的服务都有自己的服务分组，本机房的服务应该只调用本机房的服务，不进行跨机房调用。其中，一个机房服务发生问题时，可以通过DNS&#x2F;负载均衡将请求全部切到另一个机房，或者考虑服务能自动重试其他机房的服务，从而提升系统可用性。</li></ul></li><li>读写隔离<ul><li>为了提高数据访问，一般采用redis主从模式将读和写进群分离，在正常情况下，当主redis集群出现问题时，从redis集群还是可以用的，从而不影响用户的访问。</li></ul></li><li>动静隔离<ul><li>例如当用户访问如结算页时，如果JS&#x2F;CSS等静态资源也在结算页系统中时，很可能因为访问量太大导致带宽被打满导致出现不可用。为了不影响结算等用户操作的功能，将其JS&#x2F;CSS等静态资源静态化与用户操作功能分开部署。</li></ul></li><li>资源隔离<ul><li>最常见的资源如磁盘、CPU、网络；对于宝贵的资源都会存在竞争问题。我们可以使用JIMDB数据同步时要dump数据，SSD盘容量用了50%以上，dump到同一块磁盘时遇到了容量不足的问题，我们通过单独挂一块SAS盘来专门同步数据。还有如使用Docker容器时，有的容器写磁盘非常频繁，因此要考虑为不同的容器挂载不同的磁盘。</li></ul></li></ul><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul><li>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流</li><li>缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发&#x2F;请求量，即限流。</li><li>限流的目的是通过对并发访问&#x2F;请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</li><li>一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</li></ul><h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><ul><li>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</li><li>降级预案<ul><li>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</li><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ul></li><li>降级按照是否自动化可分为：自动开关降级和人工开关降级。</li><li>降级按照功能可分为：读服务降级、写服务降级。</li><li>降级按照处于的系统层次可分为：多级降级。</li><li>降级的功能点主要从服务端链路考虑，即根据用户访问的服务调用链路来梳理哪里需要降级：页面降级、页面片段降级、页面异步请求降级、服务功能降级、读降级、写降级</li><li>自动开关降级：超时降级、统计失败次数降级、故障降级、限流降级</li><li>人工开关降级：读服务降级、写服务降级</li></ul><h4 id="超时与重试"><a href="#超时与重试" class="headerlink" title="超时与重试"></a>超时与重试</h4><ul><li>在实际开发过程中，我们见过太多故障时因为没有设置超时或者设置得不对而造成的，而这些故障都是因为没有意识到超时设置的重要性而造成的。如果应用不设置超时，则可能会导致请求响应慢，慢请求积累导致连锁反应，甚至造成应用雪塌。而有些中间件或者框架在超时后进行重试（例如dubbo默认重试两次），读服务天然适合重试，但写服务大多不能重试（如写订单、支付等），重试次数太多会导致多倍请求流量。</li><li>例如模拟了Ddos攻击（分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户&#x2F;服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS，通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户&#x2F;服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。），后果可能是灾难，因此，务必设置合理的重试机制，并且应该和熔断、快速失败机制配合。所以在进行代码Review时，一定记得Review超时与重试机制。</li></ul><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><ul><li>事务回滚<ul><li>在执行数据库SQL时，如果我们检测到哦事务提交冲突，那么事务中所有执行的SQL要进行回滚，目的是防止数据库出现数据不一致。</li></ul></li><li>代码库回滚<ul><li>在开发项目时一定要将代码维护到代码仓库，从而进行版本管理。有了版本控制系统后可记录代码的历史版本，在出现问题时候可以方便回滚。</li></ul></li><li>部署版本回滚<ul><li>代码测试完成后，接下来要进行系统部署，在部署时要考虑当代码逻辑出现错误后如何快速恢复</li></ul></li><li>数据版本回滚<ul><li>在设计消息队列时，重要业务会对消息队列进行副本处理，以便万一业务逻辑出现问题能进行历史数据回滚，从而修复问题。</li></ul></li><li>静态资源版本回滚<ul><li>静态化页面资源后，每次内容变更时我们都会生成一个全量新版本放到项目的文件目录中，从而保证版本可追溯，出现问题时能及时回滚。</li></ul></li></ul><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><ul><li>线下压力测试<ul><li>通过如Jmeter，Apac，he ab 压力测试系统的某一个接口等（如登录、查询订单）或者某一个组件（例如数据库连接池），然后进行调优（如调优JVM参数，优化代码等），实现单个接口或者组件的性能最优。</li></ul></li><li>线上压力测试<ul><li>线上压力测试份方式非常多，按读分为读压、写压测和混合压测，按照数据仿真度分为仿真压力测试和引流压力测试，按照给用户提供服务分为隔离集群压力测试和线上集群压力测试。</li></ul></li><li>系统优化和容灾<ul><li>拿到全面的压力测试报告后，接下来就是分析报告，然后进行一些有这对性的优化，如硬件升级、系统扩容、参数调优、代码优化（代码同步改异步）、架构优化（如加缓存、读写分离、历史数据归档）等。在扩容时也需要考虑容灾，比如分组部署、跨机房部署。容灾是通过部署多组（单机房或多机房）相同系统，当其中一组出现问题时，可以切换到另一个分组，保证系统可用</li></ul></li></ul><h4 id="应急预案"><a href="#应急预案" class="headerlink" title="应急预案"></a>应急预案</h4><ul><li>在系统压力测试之后发现一些系统瓶颈，在系统优化之后会提升系统吐吞量并降低响应时间，容灾之后的系统可用性得以保障，但还是会存在一些风险，如网络抖动、某台机器负载过高、某个服务变慢、数据库Load值过高，为了防止因为这些问题而出现系统雪崩，需要针对这些情况制定应急预案，从而在出现突发情况时，有响应的措施来解决掉这些问题。</li><li>应急预案可按照如下几步进行：首先进行系统分级，然后进行全链路分析、配置监控，最后制定应急预案。</li></ul><h1 id="高并发系统需要解决的问题"><a href="#高并发系统需要解决的问题" class="headerlink" title="高并发系统需要解决的问题"></a>高并发系统需要解决的问题</h1><ul><li>应用缓存</li><li>HTTP缓存</li><li>多级缓存</li><li>池化</li><li>异步并发</li><li>扩容</li><li>队列</li></ul><h4 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h4><ul><li>堆缓存<ul><li>使用Java堆内存来存储缓存对象。使用堆缓存的好处是没有序列化&#x2F;反序列化，是最快的缓存。缺点也很明显，当缓存的数据量很大时，GC（垃圾回收）暂停时间会变长，存储容量受限于堆空间大小。一般通过软引用&#x2F;弱引用来存储缓存对象，即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。有Guava Cache、Ehcache 3.x、MapDB实现</li></ul></li><li>堆外缓存<ul><li>即缓存数据存储在堆外内存，可以减少GC暂停时间（堆对象转移到堆外，GC扫描和移动的对象变少），但是，读取数据时需要序列化&#x2F;反序列化，因此会比堆缓存要慢很多。有Ehcache 3.x、MapDB实现</li></ul></li><li>磁盘缓存<ul><li>即缓存数据存储在磁道上，在JVM重启时数据还存在的，而堆缓存&#x2F;堆外缓存数据会丢失，需要重新加载。有Ehcache 3.x、MapDB实现</li></ul></li><li>分布式缓存<ul><li>之前缓存提到是进程内缓存和磁盘缓存，在多JVM实例的情况下，会存在两个问题：<ul><li>单机容量问题；</li><li>数据一致性问题（多台JVM实例的缓存数据不一致怎么办？），这个问题不用纠结，既然数据允许缓存，则表示允许一定时间内的不一致，因此可以设置缓存数据的过期时间来定期更新数据；</li><li>缓存不命中时，需要回源到DB&#x2F;服务请求多变问题：每个实例在缓存不命中的情况下都会回源到DB加载数据，因此多实例后DB整体的访问量变多了解决办法是可以使用如一致性哈希分片算法。因此，这些情况可以考虑使用分布式缓存来解决。可以使用ehcache –clustered(配合 Terracotta server) 实现JAVA进程间分布式缓存。最好的办法是使用redis实现分布式缓存。</li></ul></li></ul></li></ul><h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><ul><li>浏览器缓存是指当我们使用浏览器访问一些网站页面或者http服务时，根据服务端返回的缓存设置响应头将响应内容缓存到浏览器，下次可以直接使用缓存内容或者仅需要去服务端验证内容是否过期即可。这样的好处可以减少浏览器和服务端之间来回传输的数据量，节省带宽提升性能。解决办法：内容不需要动态（计算、渲染等）速度更快，内容越接近于用户速度越快。像apache traffic server、squid、varnish、nginx等技术都可以来进行内容缓存。还有CDN就是用来加速用户访问的：即用户首先访问到全国各地的CDN节点（使用如ATS、Squid实现），如果CDN没命中，会回源到中央nginx集群，该集群如果没有命中缓存（该集群的缓存不是必须的，要根据实际命中情况等决定），最后回源到后端应用集群。</li></ul><h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><ul><li>分布式缓存</li></ul><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><ul><li>在应用系统开发过程中，我们经常会用到池化技术，如对象池、连接池、线程池等，通过池化来减少一些消耗，以提升性能</li><li>对象池通过复用对象从而减少创建对象、垃圾回收 的开销。但是，池化不能太大，太大会影响GC时的扫描时间</li><li>连接池如数据库连接池、Redis连接池、Http连接池，通过复用TCP连接减少创建和释放连接的时间来提升性能</li><li>线程池也是类似的，通过复用线程提升性能。也就是说池化的目的就是通过复用技术提升性能。</li></ul><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul><li>读写分离：当数据库访问量还不是很大的时候，我们可以适当增加服务器，数据库主从复制的方式将读写分离</li><li>垂直分区：当写入操作一旦增加的时候，那么主从数据库将花更多的时间的放在数据同步上，这个时候服务器也是不堪重负的；那么就有了数据的垂直分区，数据的垂直分区思路是将写入操作比较频繁的数据表，如用户表_user,或者订单表_orders,那么我们就可以把这个两个表分离出来，放在不同的服务器，如果这两个表和其他表存在联表查询，那么就只能把原来的sql语句给拆分了，先查询一个表，在查询另一个，虽然说这个会消耗更过性能，但比起那种大量数据同步，负担还是减轻了不少；</li><li>水平分区：但是往往事情不尽人意，可能采取垂直分区能撑一段时间，由于网站太火了，访问量又每日100w,一下子蹦到了1000w,这个时候可以采取数据的进行分离，我们可以根据user的Id不同进行分配，如采取%2的形式，或者%10的形式，当然这种形式对以后的扩展有了很大的限制，当我由10个分区增加到20个的时候，所有的数据都得重新分区，那么将是一个的很庞大的计算量；以下提供几种常见的算法：<ul><li>哈希算法：就是采用user_id%的方式;</li><li>范围：可以根据user_id字符值范围分区，如1-1000为一区，1001-2000则是另一个区等；</li><li>映射关系：就是将user_id存在的所对应的分区放在数据库中保存，当用户操作时先去查询所在分区，再进行操作；</li></ul></li></ul><h4 id="扩容分布式数据库"><a href="#扩容分布式数据库" class="headerlink" title="扩容分布式数据库"></a>扩容分布式数据库</h4><ul><li>分布式数据库（终极方案）：TDSQL架构采用自动扩容机制、分表逻辑、扩容流程、容灾机制、强同步方案解决分布式数据库扩容方案</li><li>系统由三个模块组成：Scheduler、Agent、网关，三个模块的交互都是通过ZooKeeper完成，极大简化了各个节点之间的通信机制，相对于第二代HOLD的开发简单了很多。</li><li>Scheduler作为集群的管理调度中心，主要功能包括：<ul><li>管理set，提供创建、删除set、set内节点替换等工作</li><li>所有的DDL操作统一下发和调度</li><li>监控set内各个节点的存活状态，当set内主节点故障，发起高一致性主备切换流程</li><li>监控各个set的CPU、磁盘容量、各个表的资源消耗情况，必要的时候自动发起扩容流程</li><li>Scheduler自身的容灾通过ZooKeqzer的选举机制完成，保证中心控制节点无单点。</li></ul></li><li>Agent模块负责监控本机MySQL实例的运行情况，主要功能包括：<ul><li>用短连接的方式周期性访问本机的MySQL实例，检测是否可读、可写，若发生异常，会将异常信息上报到ZooKeeper，最终会由上面描述的Scheduler模块检测到这个异常情况，从而发起容灾切换；</li><li>检测主备复制的执行情况，会定期上报主备复制的延时和延迟的事务数，若发生了主备切换，自动向新主机重建主备，因此MySQL的主备不需要DBA干预，对于新增的实例会自动采用xtrabackup通过主机自动重建数据；</li><li>检测MySQL实例的CPU利用率和各个表的请求量、数据量、CPU利用率，上报到ZooKeeper，ZooKeeper通过全局的资源情况抉择如何扩容、缩容；监控是否有下发到自身的扩容任务，如有则会执行扩容流程（下面会有描述）；监控是否要发生容灾切换，并按计划执行主备切换流程。</li></ul></li><li>网关基于MySQL Proxy开发，在网络层、连接管理、SQL解析、路由等方面做了大量优化，主要特点和功能如下：<ul><li>解析SQL，将识别出的DDL语句直接存到ZooKeeper，让Keeper来统一调度；</li><li>Watch ZooKeeper的路由信息，拉取最新的路由表保存到本地文件和内存；</li><li>将SQL请求路由到对应的set，支持读写分离；</li><li>对接入的IP、用户名、密码进行鉴权；</li><li>记录完整的SQL执行信息，与秒级监控平台对接完成实时的SQL请求的时耗，成功率等指标监控分析；</li><li>对count、distinct、sum、avg、max、min、order by、group by等聚合类SQL一般需要访问后端的多个set，网关会分析结果并做合并再返回，暂不支持跨set join和分布式事务；</li></ul></li><li>网关无状态，既支持与业务部署到一起，也可以独立部署（可通过TGW或者LVS做容灾）。</li></ul><h4 id="扩容（-Canal分布式数据库同步系统）"><a href="#扩容（-Canal分布式数据库同步系统）" class="headerlink" title="扩容（ Canal分布式数据库同步系统）"></a>扩容（ Canal分布式数据库同步系统）</h4><ul><li>基于Canal开源产品，获取数据库增量日志数据。</li><li>典型管理系统架构，manager(web管理)+node(工作节点)<ul><li>manager运行时推送同步配置到node节点</li><li>node节点将同步状态反馈到manager上</li></ul></li><li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作. 互联网技术高并发-队列应用场景<ul><li>异步处理：使用队列的一个主要原因是进行异步处理，比如用户注册完成后，需要发送注册成功邮件&#x2F;新用户积分&#x2F;优惠卷等；缓存过期时，先返回过期数据，然后异步更新缓存、异步写日志等。</li><li>系统解耦：比如用户支付完成订单后，需要通知生产配货系统、发票系统、库存系统、推荐系统、搜索系统等进行业务处理。</li><li>数据同步：比如想把mysql变更的数据同步到Redis，或者将mysql数据同步到mongodb,或者让机房之间的数据同步，或者主从数据同步等，有相关软件：databus、canal、otter等。使用数据总线队列进行数据同步的好处是可以保证数据修改的有序。</li><li>流量削峰：系统的瓶颈一般在数据库上，比如扣减库存、下单等，此时可以考虑使用队列将变更请求暂时放入队列，通过缓存+队列暂存的方式将数据库流量削峰。同样，对于秒杀系统，下单服务会是该系统的瓶颈，此时可以使用队列进行排队和限流，从而保护下单服务，通过队列暂存或者队列限流进行流量削峰</li></ul></li></ul><h4 id="队列（-Canal-）"><a href="#队列（-Canal-）" class="headerlink" title="队列（ Canal ）"></a>队列（ Canal ）</h4><ul><li>Canal 同步缓存</li><li>Canal 下发任务给消息队列</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/54eea449909d.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/54eea449909d.html" class="post-title-link" itemprop="url">XML</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-28 12:09:54 / 修改时间：12:13:33" itemprop="dateCreated datePublished" datetime="2023-12-28T12:09:54+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">序列化</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>549</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="xml有哪些解析技术-区别是什么"><a href="#xml有哪些解析技术-区别是什么" class="headerlink" title="xml有哪些解析技术?区别是什么?"></a>xml有哪些解析技术?区别是什么?</h1><ul><li>有DOM,SAX,STAX等</li></ul><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><ul><li>处理大型文件时其性能下降的非常厉害</li><li>这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式</li><li>它顺序读取XML文件，不需要一次全部装载整个文件</li><li>当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问</li></ul><h4 id="STAX"><a href="#STAX" class="headerlink" title="STAX"></a>STAX</h4><ul><li>Streaming API for XML (StAX)</li></ul><h1 id="你在项目中用到了xml技术的哪些方面-如何实现的"><a href="#你在项目中用到了xml技术的哪些方面-如何实现的" class="headerlink" title="你在项目中用到了xml技术的哪些方面?如何实现的?"></a>你在项目中用到了xml技术的哪些方面?如何实现的?</h1><ul><li>用到了数据存贮，信息配置两方面</li><li>在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理</li><li>在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。</li></ul><h1 id="XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"><a href="#XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？" class="headerlink" title="XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"></a>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</h1><ul><li>两种形式 dtd  schema</li><li>本质区别<ul><li>schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)</li></ul></li><li>有DOM,SAX,STAX等</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/b3085e36f5dd.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/publishes/b3085e36f5dd.html" class="post-title-link" itemprop="url">Kafka</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:27:32" itemprop="dateCreated datePublished" datetime="2023-12-20T16:27:32+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-24 18:18:31" itemprop="dateModified" datetime="2023-12-24T18:18:31+08:00">2023-12-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>116</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Apache-Kafka"><a href="#什么是Apache-Kafka" class="headerlink" title="什么是Apache Kafka"></a>什么是Apache Kafka</h1><p>Apache Kafka是一个分布式发布&#x2F;订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个Apache顶级项目。Kafka适合离线和在线消息消费。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/default-index/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">21:06</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>