<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="zookeeper 都有哪些使用场景？ 大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了： 分布式协调 分布式锁 元数据&#x2F;配置信息管理 HA高可用性    分布式协调 这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zook"><meta property="og:type" content="article"><meta property="og:title" content="Zookeeper"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/554d7a59d68c.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="zookeeper 都有哪些使用场景？ 大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了： 分布式协调 分布式锁 元数据&#x2F;配置信息管理 HA高可用性    分布式协调 这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zook"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T08:19:03.000Z"><meta property="article:modified_time" content="2024-01-04T03:35:39.069Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="zookeeper"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/554d7a59d68c.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/554d7a59d68c.html","path":"publishes/554d7a59d68c.html","title":"Zookeeper"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Zookeeper | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#zookeeper-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">zookeeper 都有哪些使用场景？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">分布式协调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">元数据&#x2F;配置信息管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">HA高可用性</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ZooKeeper"><span class="nav-number">2.</span> <span class="nav-text">什么是 ZooKeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZooKeeper-%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">ZooKeeper 的由来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZooKeeper-%E6%A6%82%E8%A7%88"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">ZooKeeper 概览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E5%90%88%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E7%9A%84%E8%AE%B2%E4%B8%80%E4%B8%8B-ZooKeeper"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">结合个人使用情况的讲一下 ZooKeeper</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%A5%BD%E4%BD%BF%E7%94%A8%E5%A5%87%E6%95%B0%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E6%88%90-ZooKeeper-%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">为什么最好使用奇数台服务器构成 ZooKeeper 集群？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-ZooKeeper-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-number">4.</span> <span class="nav-text">关于 ZooKeeper 的一些重要概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="nav-number">4.0.0.1.</span> <span class="nav-text">重要概念总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%EF%BC%88Session%EF%BC%89"><span class="nav-number">4.0.0.2.</span> <span class="nav-text">会话（Session）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Znode"><span class="nav-number">4.0.0.3.</span> <span class="nav-text">Znode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%88%E6%9C%AC"><span class="nav-number">4.0.0.4.</span> <span class="nav-text">版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watcher"><span class="nav-number">4.0.0.5.</span> <span class="nav-text">Watcher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ACL"><span class="nav-number">4.0.0.6.</span> <span class="nav-text">ACL</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZooKeeper-%E7%89%B9%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">ZooKeeper 特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZooKeeper-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="nav-number">6.</span> <span class="nav-text">ZooKeeper 设计目标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">简单的数据模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E6%9E%84%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">可构建集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE"><span class="nav-number">6.0.0.3.</span> <span class="nav-text">顺序访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD"><span class="nav-number">6.0.0.4.</span> <span class="nav-text">高性能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZooKeeper-%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2%E4%BB%8B%E7%BB%8D"><span class="nav-number">7.</span> <span class="nav-text">ZooKeeper 集群角色介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZooKeeper-ZAB-%E5%8D%8F%E8%AE%AE-Paxos%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">ZooKeeper &amp;ZAB 协议&amp;Paxos算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZAB-%E5%8D%8F%E8%AE%AE-Paxos%E7%AE%97%E6%B3%95"><span class="nav-number">8.0.0.1.</span> <span class="nav-text">ZAB 协议&amp;Paxos算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZAB-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="nav-number">8.0.0.2.</span> <span class="nav-text">ZAB 协议介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZAB-%E5%8D%8F%E8%AE%AE%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E5%92%8C%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD"><span class="nav-number">8.0.0.3.</span> <span class="nav-text">ZAB 协议两种基本的模式：崩溃恢复和消息广播</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Znode-%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">Znode 节点类型有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Znode%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">什么是 Znode？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper-%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">11.</span> <span class="nav-text">Zookeeper 的典型应用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chubby-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%92%8C-zookeeper-%E6%AF%94%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">chubby 是什么，和 zookeeper 比你怎么看？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper-%E7%9A%84-java-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">Zookeeper 的 java 客户端都有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper-%E5%AF%B9%E8%8A%82%E7%82%B9%E7%9A%84-watch%E7%9B%91%E5%90%AC%E9%80%9A%E7%9F%A5%E6%98%AF%E6%B0%B8%E4%B9%85%E7%9A%84%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E6%B0%B8%E4%B9%85%E7%9A%84"><span class="nav-number">14.</span> <span class="nav-text">Zookeeper 对节点的 watch监听通知是永久的吗？为什么不是永久的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8%E5%90%97%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">集群支持动态添加机器吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%9C%80%E5%B0%91%E8%A6%81%E5%87%A0%E5%8F%B0%E6%9C%BA%E5%99%A8%EF%BC%8C%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">16.</span> <span class="nav-text">集群最少要几台机器，集群规则是怎样的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%87%A0%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">Zookeeper 有哪几种几种部署模式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zookeeper-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C-nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">zookeeper 负载均衡和 nginx 负载均衡区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk-%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">zk 节点宕机如何处理？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zookeeper-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">zookeeper 是如何保证事务的顺序一致性的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-Master%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">分布式集群中为什么会有 Master？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="nav-number">22.</span> <span class="nav-text">数据同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper-%E4%B8%8B-Server-%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81"><span class="nav-number">23.</span> <span class="nav-text">Zookeeper 下 Server 工作状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%92%E8%89%B2"><span class="nav-number">24.</span> <span class="nav-text">服务器角色</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leader"><span class="nav-number">24.0.0.1.</span> <span class="nav-text">Leader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Follower"><span class="nav-number">24.0.0.2.</span> <span class="nav-text">Follower</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observer"><span class="nav-number">24.0.0.3.</span> <span class="nav-text">Observer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZooKeeper-%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">ZooKeeper 提供了什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">26.</span> <span class="nav-text">Zookeeper 文件系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9-Znode"><span class="nav-number">27.</span> <span class="nav-text">四种类型的数据节点 Znode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B3%A8%E5%86%8C-Watcher-%E5%AE%9E%E7%8E%B0"><span class="nav-number">28.</span> <span class="nav-text">客户端注册 Watcher 实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86-Watcher-%E5%AE%9E%E7%8E%B0"><span class="nav-number">29.</span> <span class="nav-text">服务端处理 Watcher 实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9B%9E%E8%B0%83-Watcher"><span class="nav-number">30.</span> <span class="nav-text">客户端回调 Watcher</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ACL-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">31.</span> <span class="nav-text">ACL 权限控制机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%A8%A1%E5%BC%8F%EF%BC%88Scheme%EF%BC%89"><span class="nav-number">31.0.0.1.</span> <span class="nav-text">权限模式（Scheme）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E5%AF%B9%E8%B1%A1"><span class="nav-number">31.0.0.2.</span> <span class="nav-text">授权对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90-Permission"><span class="nav-number">31.0.0.3.</span> <span class="nav-text">权限 Permission</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chroot-%E7%89%B9%E6%80%A7"><span class="nav-number">32.</span> <span class="nav-text">Chroot 特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86"><span class="nav-number">33.</span> <span class="nav-text">会话管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zookeeper-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">zookeeper 怎么保证主从节点的状态同步？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%89-3-%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99-zookeeper-%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-zookeeper-%E7%9A%84%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">说一下 zookeeper 的通知机制？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cap%E7%90%86%E8%AE%BA%EF%BC%9A"><span class="nav-number">37.</span> <span class="nav-text">cap理论：</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/554d7a59d68c.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Zookeeper | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Zookeeper</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:19:03" itemprop="dateCreated datePublished" datetime="2023-12-20T16:19:03+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 11:35:39" itemprop="dateModified" datetime="2024-01-04T11:35:39+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>12 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="zookeeper-都有哪些使用场景？"><a href="#zookeeper-都有哪些使用场景？" class="headerlink" title="zookeeper 都有哪些使用场景？"></a>zookeeper 都有哪些使用场景？</h1><ul><li>大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：<ul><li>分布式协调</li><li>分布式锁</li><li>元数据&#x2F;配置信息管理</li><li>HA高可用性</li></ul></li></ul><h4 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h4><ul><li>这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li>对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</li></ul><h4 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据&#x2F;配置信息管理"></a>元数据&#x2F;配置信息管理</h4><ul><li>ookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？</li></ul><h4 id="HA高可用性"><a href="#HA高可用性" class="headerlink" title="HA高可用性"></a>HA高可用性</h4><ul><li>这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个重要进程一般会做主备两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。</li></ul><h1 id="什么是-ZooKeeper"><a href="#什么是-ZooKeeper" class="headerlink" title="什么是 ZooKeeper"></a>什么是 ZooKeeper</h1><h4 id="ZooKeeper-的由来"><a href="#ZooKeeper-的由来" class="headerlink" title="ZooKeeper 的由来"></a>ZooKeeper 的由来</h4><ul><li>Zookeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。</li></ul><h4 id="ZooKeeper-概览"><a href="#ZooKeeper-概览" class="headerlink" title="ZooKeeper 概览"></a>ZooKeeper 概览</h4><ul><li>ZooKeeper 是一个开源的分布式协调服务，ZooKeeper框架最初是在“Yahoo!”上构建的，用于以简单而稳健的方式访问他们的应用程序。 后来，Apache ZooKeeper成为Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 例如，Apache HBase使用ZooKeeper跟踪分布式数据的状态</li><li>ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</li><li>原语： 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</li><li>ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</li><li>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。</li></ul><h4 id="结合个人使用情况的讲一下-ZooKeeper"><a href="#结合个人使用情况的讲一下-ZooKeeper" class="headerlink" title="结合个人使用情况的讲一下 ZooKeeper"></a>结合个人使用情况的讲一下 ZooKeeper</h4><ul><li>在我自己做过的项目中，主要使用到了 ZooKeeper 作为 Dubbo 的注册中心(Dubbo 官方推荐使用 ZooKeeper注册中心)。</li><li>另外在搭建 solr 集群的时候，我使用 ZooKeeper 作为 solr 集群的管理工具。这时，ZooKeeper 主要提供下面几个功能：<ul><li>集群管理：容错、负载均衡</li><li>配置文件的集中管理</li><li>集群的入口</li></ul></li><li>我个人觉得在使用 ZooKeeper 的时候，最好是使用 集群版的 ZooKeeper 而不是单机版的。官网给出的架构图就描述的是一个集群版的 ZooKeeper 。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。</li></ul><h1 id="为什么最好使用奇数台服务器构成-ZooKeeper-集群？"><a href="#为什么最好使用奇数台服务器构成-ZooKeeper-集群？" class="headerlink" title="为什么最好使用奇数台服务器构成 ZooKeeper 集群？"></a>为什么最好使用奇数台服务器构成 ZooKeeper 集群？</h1><ul><li>我们知道在Zookeeper中 Leader 选举算法采用了Zab协议</li><li>Zab核心思想是当多数 Server 写成功，则任务数据写成功<ul><li>如果有3个Server，则最多允许1个Server 挂掉。</li><li>如果有4个Server，则同样最多允许1个Server挂掉。</li><li>既然3个或者4个Server，同样最多允许1个Server挂掉，那么它们的可靠性是一样的，所以选择奇数个ZooKeeper Server即可，这里选择3个Server。</li></ul></li></ul><h1 id="关于-ZooKeeper-的一些重要概念"><a href="#关于-ZooKeeper-的一些重要概念" class="headerlink" title="关于 ZooKeeper 的一些重要概念"></a>关于 ZooKeeper 的一些重要概念</h1><h4 id="重要概念总结"><a href="#重要概念总结" class="headerlink" title="重要概念总结"></a>重要概念总结</h4><ul><li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li><li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li><li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。</li><li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li><li>ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。</li><li>ZooKeeper 底层其实只提供了两个功能：<ul><li>管理（存储、读取）用户程序提交的数据；</li><li>为用户程序提交数据节点监听服务。</li></ul></li></ul><h4 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h4><ul><li>Session 指的是 ZooKeeper 服务器与客户端会话</li><li>在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接</li><li>客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</li><li>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</li></ul><h4 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h4><ul><li>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然而，在Zookeeper中，“节点”分为两类<ul><li>第一类同样是指构成集群的机器，我们称之为机器节点</li><li>第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</li></ul></li><li>Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree），由斜杠（&#x2F;）的进行分割的路径，就是一个Znode，例如&#x2F;foo&#x2F;path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</li><li>在Zookeeper中，node可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</li></ul><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><ul><li>在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 cversion（当前ZNode的ACL版本）。</li></ul><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><ul><li>Watcher（事件监听器），是Zookeeper中的一个很重要的特性</li><li>Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。</li></ul><h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><ul><li>Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</li><li>Zookeeper 定义了5种权限。</li><li>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</li></ul><h1 id="ZooKeeper-特点"><a href="#ZooKeeper-特点" class="headerlink" title="ZooKeeper 特点"></a>ZooKeeper 特点</h1><ul><li>顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li><li>原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li><li>单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li><li>可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li></ul><h1 id="ZooKeeper-设计目标"><a href="#ZooKeeper-设计目标" class="headerlink" title="ZooKeeper 设计目标"></a>ZooKeeper 设计目标</h1><h4 id="简单的数据模型"><a href="#简单的数据模型" class="headerlink" title="简单的数据模型"></a>简单的数据模型</h4><ul><li>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似</li><li>名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录</li><li>与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。</li></ul><h4 id="可构建集群"><a href="#可构建集群" class="headerlink" title="可构建集群"></a>可构建集群</h4><ul><li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的</li><li>客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。</li><li>组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信</li><li>集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。</li></ul><h4 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h4><ul><li>对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。这个编号也叫做时间戳——zxid（Zookeeper Transaction Id）</li></ul><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><ul><li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li></ul><h1 id="ZooKeeper-集群角色介绍"><a href="#ZooKeeper-集群角色介绍" class="headerlink" title="ZooKeeper 集群角色介绍"></a>ZooKeeper 集群角色介绍</h1><ul><li>最典型集群模式： Master&#x2F;Slave 模式（主备模式）。在这种模式中，通常 Master服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</li><li>在 ZooKeeper 中没有选择传统的 Master&#x2F;Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色。</li><li>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器</li><li>Leader 既可以为客户端提供写服务又能提供读服务</li><li>除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</li></ul><h1 id="ZooKeeper-ZAB-协议-Paxos算法"><a href="#ZooKeeper-ZAB-协议-Paxos算法" class="headerlink" title="ZooKeeper &amp;ZAB 协议&amp;Paxos算法"></a>ZooKeeper &amp;ZAB 协议&amp;Paxos算法</h1><h4 id="ZAB-协议-Paxos算法"><a href="#ZAB-协议-Paxos算法" class="headerlink" title="ZAB 协议&amp;Paxos算法"></a>ZAB 协议&amp;Paxos算法</h4><ul><li>Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</li></ul><h4 id="ZAB-协议介绍"><a href="#ZAB-协议介绍" class="headerlink" title="ZAB 协议介绍"></a>ZAB 协议介绍</h4><ul><li>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议</li><li>在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</li></ul><h4 id="ZAB-协议两种基本的模式：崩溃恢复和消息广播"><a href="#ZAB-协议两种基本的模式：崩溃恢复和消息广播" class="headerlink" title="ZAB 协议两种基本的模式：崩溃恢复和消息广播"></a>ZAB 协议两种基本的模式：崩溃恢复和消息广播</h4><ul><li>ZAB协议包括两种基本的模式，分别是 崩溃恢复和消息广播</li><li>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器</li><li>当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式</li><li>其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</li><li>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了</li><li>当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去</li><li>正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理</li><li>Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</li></ul><h1 id="Znode-节点类型有哪些？"><a href="#Znode-节点类型有哪些？" class="headerlink" title="Znode 节点类型有哪些？"></a>Znode 节点类型有哪些？</h1><ul><li>PERSISTENT 持久化节点: 所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点。否则不会因为创建该节点的客户端会话失效而消失。</li><li>PERSISTENT_SEQUENTIAL 持久顺序节点：这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在 ZK 中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK 会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 在创建节点的时候只需要传入节点 “&#x2F;test_”，这样之后，zookeeper 自动会给”test_”后面补充数字。</li><li>EPHEMERAL 临时节点：和持久节点不同的是，临时节点的生命周期和客户端会 话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。这里还要注意一件事，就是当你客户端会话失效后，所产生的节点也不是一下子就消失了，也要过一段时间，大概是 10 秒以内，可以试一下，本机操作生成节点，在服务器端用命令来查看当前的节点数目，你会发现客户端已经 stop，但是产生的节点还在。</li><li>EPHEMERAL_SEQUENTIAL 临时自动编号节点：此节点是属于临时节点，不过带有顺序，客户端会话结束节点就消失。</li></ul><h1 id="什么是-Znode？"><a href="#什么是-Znode？" class="headerlink" title="什么是 Znode？"></a>什么是 Znode？</h1><ul><li>在 Zookeeper 中，znode 是一个跟 Unix 文件系统路径相似的节点，可以往这个节点存储或获取数据。</li><li>Zookeeper 底层是一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为“znode”</li><li>zookeeper 中的数据是按照“树”结构进行存储的。而且 znode 节点还分为 4 中不同的类型。</li><li>每一个 znode 默认能够存储 1MB 的数据（对于记录状态性质的数据来说，够了）</li><li>可以使用 zkCli 命令，登录到 zookeeper 上，并通过 ls、create、delete、get、set等命令操作这些 znode 节点</li></ul><h1 id="Zookeeper-的典型应用场景"><a href="#Zookeeper-的典型应用场景" class="headerlink" title="Zookeeper 的典型应用场景"></a>Zookeeper 的典型应用场景</h1><ul><li>Zookeeper 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。<br>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：<ul><li>数据发布&#x2F;订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调&#x2F;通知</li><li>集群管理</li><li>Master 选举</li><li>分布式锁</li><li>分布式队列</li></ul></li></ul><h1 id="chubby-是什么，和-zookeeper-比你怎么看？"><a href="#chubby-是什么，和-zookeeper-比你怎么看？" class="headerlink" title="chubby 是什么，和 zookeeper 比你怎么看？"></a>chubby 是什么，和 zookeeper 比你怎么看？</h1><ul><li>chubby 是 google 的，完全实现 paxos 算法，不开源。zookeeper 是 chubby的开源实现，使用 zab 协议，paxos 算法的变种。</li></ul><h1 id="Zookeeper-的-java-客户端都有哪些？"><a href="#Zookeeper-的-java-客户端都有哪些？" class="headerlink" title="Zookeeper 的 java 客户端都有哪些？"></a>Zookeeper 的 java 客户端都有哪些？</h1><ul><li>java 客户端：zk 自带的 zkclient 及 Apache 开源的 Curator。</li></ul><h1 id="Zookeeper-对节点的-watch监听通知是永久的吗？为什么不是永久的"><a href="#Zookeeper-对节点的-watch监听通知是永久的吗？为什么不是永久的" class="headerlink" title="Zookeeper 对节点的 watch监听通知是永久的吗？为什么不是永久的?"></a>Zookeeper 对节点的 watch监听通知是永久的吗？为什么不是永久的?</h1><ul><li>不是</li><li>官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</li><li>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。</li><li>一般是客户端执行 getData(“&#x2F;节点 A”,true)，如果节点 A 发生了变更或删除，客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没有设置 watch 事件，就不再给客户端发送。</li><li>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</li></ul><h1 id="集群支持动态添加机器吗？"><a href="#集群支持动态添加机器吗？" class="headerlink" title="集群支持动态添加机器吗？"></a>集群支持动态添加机器吗？</h1><ul><li>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的<br>会话。</li><li>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。</li><li>3.5 版本开始支持动态扩容。</li></ul><h1 id="集群最少要几台机器，集群规则是怎样的"><a href="#集群最少要几台机器，集群规则是怎样的" class="headerlink" title="集群最少要几台机器，集群规则是怎样的?"></a>集群最少要几台机器，集群规则是怎样的?</h1><ul><li>集群规则为 2N+1 台，N&gt;0，即 3 台。</li></ul><h1 id="Zookeeper-有哪几种几种部署模式？"><a href="#Zookeeper-有哪几种几种部署模式？" class="headerlink" title="Zookeeper 有哪几种几种部署模式？"></a>Zookeeper 有哪几种几种部署模式？</h1><ul><li>部署模式：单机模式、伪集群模式、集群模式。</li></ul><h1 id="zookeeper-负载均衡和-nginx-负载均衡区别"><a href="#zookeeper-负载均衡和-nginx-负载均衡区别" class="headerlink" title="zookeeper 负载均衡和 nginx 负载均衡区别"></a>zookeeper 负载均衡和 nginx 负载均衡区别</h1><ul><li>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。</li></ul><h1 id="zk-节点宕机如何处理？"><a href="#zk-节点宕机如何处理？" class="headerlink" title="zk 节点宕机如何处理？"></a>zk 节点宕机如何处理？</h1><ul><li>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</li><li>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</li><li>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</li><li>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5) 2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;&#x3D;1)</li></ul><h1 id="zookeeper-是如何保证事务的顺序一致性的？"><a href="#zookeeper-是如何保证事务的顺序一致性的？" class="headerlink" title="zookeeper 是如何保证事务的顺序一致性的？"></a>zookeeper 是如何保证事务的顺序一致性的？</h1><ul><li>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</li></ul><h1 id="分布式集群中为什么会有-Master？"><a href="#分布式集群中为什么会有-Master？" class="headerlink" title="分布式集群中为什么会有 Master？"></a>分布式集群中为什么会有 Master？</h1><ul><li>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行leader 选举。</li></ul><h1 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h1><ul><li>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）回向Leader 服务器进行注册。当 Learner 服务器想 Leader 服务器完成注册后，进入数据同步环节。</li><li>数据同步流程：（均以消息传递的方式进行）</li><li>Learner 向 Learder 注册</li><li>数据同步</li><li>同步确认</li><li>Zookeeper 的数据同步通常分为四类：<ul><li>直接差异化同步（DIFF 同步）</li><li>先回滚再差异化同步（TRUNC+DIFF 同步）</li><li>仅回滚同步（TRUNC 同步）</li><li>全量同步（SNAP 同步）</li></ul></li><li>在进行数据同步前，Leader 服务器会完成数据同步初始化：</li><li>peerLastZxid：<ul><li>从 learner 服务器注册时发送的 ACKEPOCH 消息中提取 lastZxid（该Learner 服务器最后处理的 ZXID）<br>minCommittedLog：</li></ul></li><li>Leader 服务器 Proposal 缓存队列 committedLog 中最小 ZXID maxCommittedLog：</li><li>Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID直接差异化同步（DIFF 同步）</li><li>场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog之间</li><li>先回滚再差异化同步（TRUNC+DIFF 同步）</li><li>场景：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没有的事务记录，那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader</li><li>服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID仅回滚同步（TRUNC 同步）</li><li>场景：peerLastZxid 大于 maxCommittedLog</li><li>全量同步（SNAP 同步）</li><li>场景一：peerLastZxid 小于 minCommittedLog</li><li>场景二：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等于 lastProcessZxid</li></ul><h1 id="Zookeeper-下-Server-工作状态"><a href="#Zookeeper-下-Server-工作状态" class="headerlink" title="Zookeeper 下 Server 工作状态"></a>Zookeeper 下 Server 工作状态</h1><ul><li>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。<ul><li>LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</li><li>FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</li><li>LEADING：领导者状态。表明当前服务器角色是 Leader。</li><li>OBSERVING：观察者状态。表明当前服务器角色是 Observer。</li></ul></li></ul><h1 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h1><h4 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h4><ul><li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li><li>集群内部各服务的调度者</li></ul><h4 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h4><ul><li>处理客户端的非事务请求，转发事务请求给 Leader 服务器</li><li>参与事务请求 Proposal 的投票</li><li>参与 Leader 选举投票</li></ul><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><ul><li>3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</li><li>处理客户端的非事务请求，转发事务请求给 Leader 服务器</li><li>不参与任何形式的投票</li></ul><h1 id="ZooKeeper-提供了什么？"><a href="#ZooKeeper-提供了什么？" class="headerlink" title="ZooKeeper 提供了什么？"></a>ZooKeeper 提供了什么？</h1><ul><li>文件系统</li><li>通知机制</li></ul><h1 id="Zookeeper-文件系统"><a href="#Zookeeper-文件系统" class="headerlink" title="Zookeeper 文件系统"></a>Zookeeper 文件系统</h1><ul><li>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</li><li>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。</li></ul><h1 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h1><ul><li>PERSISTENT-持久节点<ul><li>除非手动删除，否则节点一直存在于 Zookeeper 上</li></ul></li><li>EPHEMERAL-临时节点<ul><li>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</li></ul></li><li>PERSISTENT_SEQUENTIAL-持久顺序节点<ul><li>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li></ul></li><li>EPHEMERAL_SEQUENTIAL-临时顺序节点<ul><li>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li></ul></li></ul><h1 id="客户端注册-Watcher-实现"><a href="#客户端注册-Watcher-实现" class="headerlink" title="客户端注册 Watcher 实现"></a>客户端注册 Watcher 实现</h1><ul><li>调用 getData()&#x2F;getChildren()&#x2F;exist()三个 API，传入 Watcher 对象</li><li>标记请求 request，封装 Watcher 到 WatchRegistration</li><li>封装成 Packet 对象，发服务端发送 request</li><li>收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理</li><li>请求返回，完成注册。</li></ul><h1 id="服务端处理-Watcher-实现"><a href="#服务端处理-Watcher-实现" class="headerlink" title="服务端处理 Watcher 实现"></a>服务端处理 Watcher 实现</h1><ul><li>服务端接收 Watcher 并存储接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在WatcherManager 的 WatchTable 和 watch2Paths 中去。</li><li>Watcher 触发</li><li>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：<ul><li>封装 WatchedEvent<ul><li>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个 WatchedEvent 对象</li></ul></li><li>查询 Watcher<ul><li>从 WatchTable 中根据节点路径查找 Watcher</li></ul></li><li>没找到；说明没有客户端在该数据节点上注册过 Watcher</li><li>找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里可以看出 Watcher 在服务端是一次性的，触发一次就失效了）</li><li>调用 process 方法来触发 Watcher 这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。</li></ul></li></ul><h1 id="客户端回调-Watcher"><a href="#客户端回调-Watcher" class="headerlink" title="客户端回调 Watcher"></a>客户端回调 Watcher</h1><ul><li>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。</li><li>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。</li></ul><h1 id="ACL-权限控制机制"><a href="#ACL-权限控制机制" class="headerlink" title="ACL 权限控制机制"></a>ACL 权限控制机制</h1><ul><li>UGO（User&#x2F;Group&#x2F;Others）目前在 Linux&#x2F;Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗粒度的文件系统权限控制模式。</li><li>ACL（Access Control List）访问控制列表包括三个方面：</li></ul><h4 id="权限模式（Scheme）"><a href="#权限模式（Scheme）" class="headerlink" title="权限模式（Scheme）"></a>权限模式（Scheme）</h4><ul><li>IP：从 IP 地址粒度进行权限控制</li><li>Digest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制</li><li>World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标识“world:anyone”</li><li>Super：超级用户</li></ul><h4 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h4><ul><li>授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。</li></ul><h4 id="权限-Permission"><a href="#权限-Permission" class="headerlink" title="权限 Permission"></a>权限 Permission</h4><ul><li>CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点</li><li>DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点</li><li>READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等</li><li>WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作</li><li>ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置操作</li></ul><h1 id="Chroot-特性"><a href="#Chroot-特性" class="headerlink" title="Chroot 特性"></a>Chroot 特性</h1><ul><li>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。</li><li>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相互隔离非常有帮助。</li></ul><h1 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h1><ul><li>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。</li><li>分配原则：每个会话的“下次超时时间点”（ExpirationTime）</li><li>计算公式：</li><li>ExpirationTime_ &#x3D; currentTime + sessionTimeout</li><li>ExpirationTime &#x3D; (ExpirationTime_ &#x2F; ExpirationInrerval + 1) * ExpirationInterval</li><li>ExpirationInterval 是指 Zookeeper 会话超时检查时间间隔，默认 tickTime</li></ul><h1 id="zookeeper-怎么保证主从节点的状态同步？"><a href="#zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="zookeeper 怎么保证主从节点的状态同步？"></a>zookeeper 怎么保证主从节点的状态同步？</h1><ul><li>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</li></ul><h1 id="集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h1><ul><li>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</li></ul><h1 id="说一下-zookeeper-的通知机制？"><a href="#说一下-zookeeper-的通知机制？" class="headerlink" title="说一下 zookeeper 的通知机制？"></a>说一下 zookeeper 的通知机制？</h1><ul><li>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</li></ul><h1 id="cap理论："><a href="#cap理论：" class="headerlink" title="cap理论："></a>cap理论：</h1><ul><li>概念：⼀个分布式系统最多只能同时满⾜⼀致性（Consistency）、可⽤性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</li><li>⼀致性：更新操作成功并返回客户端完成后，所有节点在同⼀时间的数据完全⼀致，所以，⼀致性，说的就是数据⼀致性。</li><li>可⽤性：服务⼀直可⽤，⽽且是正常响应时间。</li><li>分区容错性：分布式系统在遇到某节点或⽹络分区故障的时候，仍然能够对外提供满⾜⼀致性和可⽤性的服务。</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/zookeeper/" rel="tag"><i class="fa fa-tag"></i> zookeeper</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/4f75e46c0d1c.html" rel="prev" title="设计模式"><i class="fa fa-angle-left"></i> 设计模式</a></div><div class="post-nav-item"><a href="/publishes/dffc02696193.html" rel="next" title="MySQL">MySQL <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">453k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:52</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>