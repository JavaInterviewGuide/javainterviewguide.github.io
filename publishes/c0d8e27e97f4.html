<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="用什么关键字修饰同步方法 用synchronized关键字修饰同步方法  stop()和suspend()方法为何不推荐使用 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。 suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这"><meta property="og:type" content="article"><meta property="og:title" content="多线程"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="用什么关键字修饰同步方法 用synchronized关键字修饰同步方法  stop()和suspend()方法为何不推荐使用 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。 suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:06:48.000Z"><meta property="article:modified_time" content="2023-12-27T07:03:00.938Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="线程"><meta property="article:tag" content="多线程"><meta property="article:tag" content="并发"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html","path":"publishes/c0d8e27e97f4.html","title":"多线程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>多线程 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E4%BB%80%E4%B9%88%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">用什么关键字修饰同步方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stop-%E5%92%8Csuspend-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">stop()和suspend()方法为何不推荐使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">sleep() 和 wait() 有什么区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E4%BB%96%E4%BB%AC%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="nav-number">4.</span> <span class="nav-text">同步和异步有何异同，在什么情况下分别使用他们？举例说明。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%94%A8run-%E8%BF%98%E6%98%AFstart"><span class="nav-number">5.</span> <span class="nav-text">启动一个线程是用run()还是start()?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AAsynchronized%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">7.</span> <span class="nav-text">线程的基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0synchronized%E5%92%8Cjava-util-concurrent-locks-Lock%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">8.</span> <span class="nav-text">简述synchronized和java.util.concurrent.locks.Lock的异同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Synchronized%E5%92%8CReentrantLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">Synchronized和ReentrantLock有什么区别?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">9.0.0.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%93%8D%E4%BD%9C-CompareAndSwap"><span class="nav-number">9.0.0.2.</span> <span class="nav-text">CAS操作(CompareAndSwap)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized"><span class="nav-number">9.0.0.3.</span> <span class="nav-text">Synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">9.0.0.4.</span> <span class="nav-text">ReentrantLock</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">10.</span> <span class="nav-text">请说出你所知道的线程同步的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">11.</span> <span class="nav-text">同步有几种实现方法,都是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">12.</span> <span class="nav-text">线程间的通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">12.0.0.1.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">12.0.0.2.</span> <span class="nav-text">while轮询的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-notify%E6%9C%BA%E5%88%B6"><span class="nav-number">12.0.0.3.</span> <span class="nav-text">wait&#x2F;notify机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="nav-number">12.0.0.4.</span> <span class="nav-text">管道通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">线程死锁及解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="nav-number">13.0.0.1.</span> <span class="nav-text">什么是死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">13.0.0.2.</span> <span class="nav-text">解决办法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81%E5%88%86%E7%B1%BB%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">14.</span> <span class="nav-text">锁分类的了解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">14.0.0.1.</span> <span class="nav-text">公平锁&#x2F;非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">14.0.0.2.</span> <span class="nav-text">可重入锁</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">26</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="多线程 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">多线程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:06:48" itemprop="dateCreated datePublished" datetime="2023-12-20T15:06:48+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-27 15:03:00" itemprop="dateModified" datetime="2023-12-27T15:03:00+08:00">2023-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="用什么关键字修饰同步方法"><a href="#用什么关键字修饰同步方法" class="headerlink" title="用什么关键字修饰同步方法"></a>用什么关键字修饰同步方法</h1><ul><li>用synchronized关键字修饰同步方法</li></ul><h1 id="stop-和suspend-方法为何不推荐使用"><a href="#stop-和suspend-方法为何不推荐使用" class="headerlink" title="stop()和suspend()方法为何不推荐使用"></a>stop()和suspend()方法为何不推荐使用</h1><ul><li>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</li><li>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</li></ul><h1 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h1><ul><li>最大的不同是在等待时wait会释放锁，而sleep一直持有锁</li><li>Wait通常被用于线程间交互，sleep通常被用于暂停执行</li><li>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li><li>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li><li>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。</li><li>wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。</li><li>sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器</li></ul><h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul><li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取</li><li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率</li></ul><h1 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h1><ul><li>启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态</li><li>一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码</li></ul><h1 id="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h1><ul><li>分几种情况：<ul><li>其他方法前是否加了synchronized关键字，如果没加，则能。</li><li>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</li><li>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</li><li>如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</li></ul></li></ul><h1 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h1><ul><li>一个程序中可以有多条执行线索同时执行</li><li>一个线程就是程序中的一条执行线索</li><li>每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行</li><li>每个程序至少都有一个线程，即main方法执行的那个线程</li><li>如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行。</li><li>线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身</li><li>Java中的线程有四种状态分别是：运行、就绪、挂起、结束</li><li>线程是操作系统能够进⾏运算调度的最⼩单位，它被包含在进程之中，是进程中的实际运作单位，可以使⽤多线程对进⾏运算提速</li></ul><h1 id="简述synchronized和java-util-concurrent-locks-Lock的异同"><a href="#简述synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="简述synchronized和java.util.concurrent.locks.Lock的异同"></a>简述synchronized和java.util.concurrent.locks.Lock的异同</h1><ul><li>主要相同点：Lock能完成synchronized所实现的所有功能</li><li>主要不同点<ul><li>Lock有比synchronized更精确的线程语义和更好的性能</li><li>ynchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放</li><li>Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁</li></ul></li></ul><h1 id="Synchronized和ReentrantLock有什么区别"><a href="#Synchronized和ReentrantLock有什么区别" class="headerlink" title="Synchronized和ReentrantLock有什么区别?"></a>Synchronized和ReentrantLock有什么区别?</h1><ul><li>synchronized是Java内建的同步机制,所以也有人称其为Intrinsic Locking（固有锁），它提供了互斥的语义和可见性,当一个线程已经获取当前锁时,其他试图获取的线程只能等待或者阻塞在那里。在Java 5以前,synchronized是仅有的同步手段,在代码中,synchronized可以用来修饰方法,也可以使用在特定的代码块上,本质上 synchronized方法等同于把方法全部语句用synchronized块包起来。</li><li>ReentrantLock,通常翻译为再入锁,是Java 5提供的锁实现,它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取,代码书写更加灵活。与此同时,ReentrantLock提供了很多实用的方法,能够实现很多synchronized无法做到的细节控制,但是在编码中也需要注意,必须要明确调用unlock()方法释放,不然就会一直持有该锁。synchronzied和ReentrantLock的性能不能一概而论,早期版本synchronized在很多场景下性能相差较大,在后续版本进行了较多改进,在低竞争场景中表现可能优于ReentrantLock。</li></ul><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>可重⼊锁。可重⼊锁是指同⼀个线程可以多次获取同⼀把锁。ReentrantLock和synchronized都是可重⼊锁。</li><li>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，⽽ReentrantLock则提供了中断功能。</li><li>公平锁是指多个线程同时尝试获取同⼀把锁时，获取锁的顺序按照线程达到的顺序</li><li>⾮公平锁则允许线程“插队”</li><li>synchronized是⾮公平锁，⽽ReentrantLock的默认实现是⾮公平锁，但是也可以设置为公平锁。</li></ul><h4 id="CAS操作-CompareAndSwap"><a href="#CAS操作-CompareAndSwap" class="headerlink" title="CAS操作(CompareAndSwap)"></a>CAS操作(CompareAndSwap)</h4><ul><li>CAS操作简单的说就是⽐较并交换</li><li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)</li><li>如果内存位置的值与预期原值相匹配，那么处理器会⾃动将该位置值更新为新值。否则，处理器不做任何操作</li><li>⽆论哪种情况，它都会在 CAS 指令之前返回该位置的值</li><li>CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</li></ul><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ul><li>synchronized是java内置的关键字，它提供了⼀种独占的加锁⽅式</li><li>synchronized的获取和释放锁由JVM实现，⽤户不需要显示的释放锁，⾮常⽅便</li><li>然⽽synchronized也有⼀定的局限性：<ul><li>当线程尝试获取锁的时候，如果获取不到锁会⼀直阻塞。</li><li>如果获取锁的线程进⼊休眠或者阻塞，除⾮当前线程异常，否则其他线程尝试获取锁必须⼀直等待。</li></ul></li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul><li>ReentrantLock它是JDK 1.5之后提供的API层⾯的互斥锁，需要lock()和unlock()⽅法配合try/finally语句块来完成。</li><li>等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）</li><li>公平锁与⾮公平锁多个线程等待同⼀个锁时，必须按照申请锁的时间顺序获得锁</li><li>Synchronized锁⾮公平锁，ReentrantLock默认的构造函数是创建的⾮公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li></ul><h1 id="请说出你所知道的线程同步的方法"><a href="#请说出你所知道的线程同步的方法" class="headerlink" title="请说出你所知道的线程同步的方法"></a>请说出你所知道的线程同步的方法</h1><ul><li>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</li><li>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</li><li>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级</li><li>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li></ul><h1 id="同步有几种实现方法-都是什么"><a href="#同步有几种实现方法-都是什么" class="headerlink" title="同步有几种实现方法,都是什么?"></a>同步有几种实现方法,都是什么?</h1><ul><li>同步的实现方面有两种，分别是synchronized,wait与notify</li></ul><h1 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信</li><li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信</li><li>这种方式，本质上就是“共享内存”式的通信</li><li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行</li></ul><h4 id="while轮询的方式"><a href="#while轮询的方式" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul><li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信</li><li>但是这种方式会浪费CPU资源</li><li>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试某个条件是否成立</li><li>这种方式还存在另外一个问题：轮询的条件的可见性问题</li><li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li></ul><h4 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait/notify机制"></a>wait/notify机制</h4><ul><li>线程A要等待某个条件满足时(list.size()==5)，才执行操作，线程B则向list中添加元素，改变list 的size</li><li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢</li><li>这里用到了Object类的 wait() 和 notify() 方法</li><li>当条件未满足时(list.size() !=5)，线程A调用wait()放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</li><li>当条件满足时，线程B调用 notify()通知线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态</li><li>这种方式的一个好处就是CPU的利用率提高了，但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ul><li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li><li>分布式系统中说的两种通信机制：共享内存机制和消息通信机制</li><li>synchronized关键字和while轮询“属于”共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流</li><li>而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。</li></ul><h1 id="线程死锁及解决办法"><a href="#线程死锁及解决办法" class="headerlink" title="线程死锁及解决办法"></a>线程死锁及解决办法</h1><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><ul><li>所谓死锁： 是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁线程。</li><li>由于资源占用是互斥的，当某个线程提出申请资源后，使得有关线程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁</li><li>关键点：<ul><li>两个以上的线程</li><li>争夺共享的资源</li><li>它们各自不释放手中资源，除非有外力协助</li></ul></li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y的拥有者分别等待对方的资源的问题。</li><li>将多个锁组成一组并放到同一个锁下</li><li>将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得容器对象的锁时，就可以通过检查变量来判断是否整个容器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试</li></ul><h1 id="锁分类的了解"><a href="#锁分类的了解" class="headerlink" title="锁分类的了解"></a>锁分类的了解</h1><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h4><ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁</li><li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象</li><li>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大</li><li>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁</li></ul><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul><li>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。</li><li>对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。<br>```<br>synchronized void setA() throws Exception{<br>Thread.sleep(1000);<br>setB();<br>}</li></ul><p>synchronized void setB() throws Exception{<br>Thread.sleep(1000);<br>}</p><pre><code>
- 上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁

#### 独享锁/共享锁
- 独享锁是指该锁一次只能被一个线程所持有。
- 共享锁是指该锁可被多个线程所持有。
- 对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
- 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
- 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
- 对于Synchronized而言，当然是独享锁。

#### 互斥锁/读写锁
- 上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
- 互斥锁在Java中的具体实现就是ReentrantLock
- 读写锁在Java中的具体实现就是ReadWriteLock

#### 乐观锁/悲观锁
- 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
- 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
- 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
- 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
- 悲观锁在Java中的使用，就是利用各种锁。
- 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
- 乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑
- 悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接上了锁操作资源。

#### 分段锁
- 分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
- 我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
- 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
- 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计
- 分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作

#### 偏向锁/轻量级锁/重量级锁
- 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
- 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

#### 自旋锁
- 自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区
- 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU
- ⾃旋锁是SMP架构中的⼀种low-level的同步机制
- 当线程A想要获取⼀把⾃旋锁⽽该锁⼜被其它线程锁持有时，线程A会在⼀个循环中⾃旋以检测锁是不是已经可⽤了。
- ⾃选锁需要注意：
    - 由于⾃旋时不释放CPU，因⽽持有⾃旋锁的线程应该尽快释放⾃旋锁，否则等待该⾃旋锁的线程会⼀直在那⾥⾃旋，这就会浪费CPU时间
    - 持有⾃旋锁的线程在sleep之前应该释放⾃旋锁以便其它线程可以获得⾃旋锁
- ⽬前的JVM实现⾃旋会消耗CPU，如果⻓时间不调⽤doNotify⽅法，doWait⽅法会⼀直⾃旋，CPU会消耗太⼤
- ⾃旋锁⽐较适⽤于锁使⽤者保持锁时间⽐较短的情况，这种情况⾃旋锁的效率⽐较⾼
- ⾃旋锁是⼀种对多处理器相当有效的机制，⽽在单处理器⾮抢占式的系统中基本上没有作⽤

# 重入锁：ReentrantLock 详解
- 在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的。除此之外，重入锁又自带一系列高逼格UBFF：可中断响应、锁申请等待限时、公平锁。另外可以结合Condition来使用，使其更是逼格满满。
- 使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对逻辑控制的灵活性远远大于synchronized关键字
- 需要注意，有加锁就必须有释放锁，而且加锁与释放锁的分数要相同，这里就引出了“重”字的概念

#### 中断响应
- 对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。
- t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了死锁。但是，给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，正常执行完成。t2也会退出，但只是释放了资源并没有完成工作

#### 锁申请等待限时
- 可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。
- 前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。
- 后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false

#### 公平锁
- 所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：
</code></pre><p>public ReentrantLock(boolean fair) {<br>sync = fair ? new FairSync() : new NonfairSync();<br>}</p><pre><code>
#### ReentrantLock 配合 Conditond 使用
- 配合关键字synchronized使用的方法如：await()、notify()、notifyAll()
- ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象

# 深入理解Callable
- Callable和Runnbale一样代表着任务，区别在于Callable有返回值并且可以抛出异常
- Callable接⼝使⽤泛型去定义它的返回类型
- Executors类提供了⼀些有⽤的⽅法去在线程池中执⾏Callable内的任务
- 由于Callable任务是并⾏的，必须等待它返回的结果，java.util.concurrent.Future对象解决了这个问题
- 在线程池提交Callable任务后返回了⼀个Future对象，使⽤它可以知道Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()⽅法，等待Callable结束并获取它的执⾏结果

#### Future接口
- Future是一个接口，代表了一个异步计算的结果
- 接口中的方法用来检查计算是否完成、等待完成和得到计算的结果
- 当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了
- 如果想取消，那么调用cancel()方法
- 其他方法用于确定任务是正常完成还是取消了
- 一旦计算完成了，那么这个计算就不能被取消

#### FutureTask 是什么？
- FutureTask 表示一个异步运算的任务，FutureTask 里面可以传入一个 Callable的具体实现类
- 可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、 取消任务等操作
- FutureTask可⽤于异步获取执⾏结果或取消执⾏任务的场景
- 通过传⼊Runnable或者Callable的任务给FutureTask，直接调⽤其run⽅法或者放⼊线程池执⾏，之后可以在外部通过FutureTask的get⽅法异步获取执⾏结果
- FutureTask⾮常适合⽤于耗时的计算，主线程可以在完成⾃⼰的任务后，再去获取结果
- FutureTask还可以确保即使调⽤了多次run⽅法，它都只会执⾏⼀次Runnable或者Callable任务，或者通过cancel取消FutureTask的执⾏等
- futuretask可⽤于执⾏多任务、以及避免⾼并发情况下多次创建数据机锁的出现。

#### run方法
- 当将FutureTask提交给Executor后，Executor执行FutureTask时会执行其run方法
- 任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程
- 从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法
- set方法：当Callable成功执行后，会调用set方法将结果传出
- setException方法：该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程
- get方法：当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。
- 在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待
- awaitDone方法是如何将调用线程阻塞的,awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制
- awaitDone方法中进入死循环后，主要有几步
    - 如果线程被中断了，移除节点，抛出异常
    - 如果状态大于COMPLETING，那么直接返回
    - 如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下
    - 如果状态是NEW且节点为null，那么创建一个节点
    - 如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程
    - 如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点
    - 如果没有限制时间，那么将线程无限挂起
- 上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。
- 当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果
- report会根据任务的状态不同返回不同的结果。
    - 如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果
    - 如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException
    - 如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException
- finishCompletion方法：在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程
- finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环，释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。
- cancel方法：用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了，如果是需要中断正在执行的任务，那么状态转换将会是NEW-&gt;INTERRPUTING-&gt;INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW-&gt;CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。

- isDone方法：表明任务是否已经完成了，如果完成了，那么返回true，否则false，只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。

#### 总结
- Callable是一种可以返回结果的任务，这是它与Runnable的区别，但是通过适配器模式可以使Runnable与Callable类似
- Future代表了一个异步的计算，可以从中得到计算结果、查看计算状态，其实现FutureTask可以被提交给Executor执行，多个线程可以从中得到计算结果
- Callable和Future是配合使用的，当从Future中get结果时，如果结果还没被计算出来，那么线程将会被挂起，FutureTak内部使用一个单链表维持等待的线程；当计算结果出来后，将会对等待线程解除挂起，等待线程就都可以得到计算结果了。
- Callable⽤于产⽣结果，Future⽤于获取结果

# 多线程
#### 多线程优点
- 发挥多核CPU 的优势，并发执⾏让系统运⾏的更快、更流畅，⽤户体验更好
- 防止阻塞：从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因 为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但 是单核 CPU 我们还是要应用多线程，就是为了防止阻塞
- 便于建模：这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么 就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成 几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运 行这几个任务，那就简单很多了。
- 使⽤多线程可以把程序中占据时间⻓的任务放到后台去处理，如图⽚、视屏的下载

#### 多线程的缺点
- ⼤量的线程降低代码的可读性；
- 更多的线程需要更多的内存空间
- 当多个线程对同⼀个资源出现争夺时候要注意线程安全的问题。

#### 多线程的上下⽂切换
- CPU通过时间⽚分配算法来循环执⾏任务，当前任务执⾏⼀个时间⽚后会切换到下⼀个任务
- 在切换前会保存上⼀个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态

# 线程和进程的区别是什么
- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式
- 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径
- 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些
- 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程

# Java 实现线程有哪几种方式
- 继承 Thread 类实现多线程
- 实现 Runnable 接口方式实现多线程
- 使用 ExecutorService、Callable、Future 实现有返回结果的多线程

# 启动线程方法 start()和 run()有什么区别
- 只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代 码交替执行
- 如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码

# 一个线程的生命周期有哪几种状态？它们之间如何流转的？
- NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。
- RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中 状态。
- BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。
- WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如 通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方 法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线 程就进入了 RUNNABLE 状态继续运行。
- TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒 后线程重新进行 RUNNABLE 状态继续运行。
- TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程 通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态

# violatile 关键字的作用
- volatile 关键字的作用主要有两个
    - 多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据
    - 使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重要作用就是和CAS结合，保证了原子性

# 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行
- 用 join 方法。

# 为什么要使用线程池
- 什么是线程池？ 很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线 程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用
- 每个线程都要通过 new Thread(xxRunnable).start()的方 式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈
- 线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存

# 线程池⽤法与优势？
#### ThreadPool 优点
- 减少了创建和销毁线程的次数，每个⼯作线程都可以被重复利⽤，可执⾏多个任务
- 可以根据系统的承受能⼒，调整线程池中⼯作线线程的数⽬，防⽌因为因为消耗过多的内存，⽽把服务器累趴下
- 减少在创建和销毁线程上所花的时间以及系统资源的开销
- 如不使⽤线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存

#### ⽐较重要的⼏个类
- Java⾥⾯线程池的顶级接⼜是Executor，但是严格意义上讲Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具
- 真正的线程池接口是ExecutorService。

#### 任务执⾏顺序：
- ExecutorService 真正的线程池接⼝。
- ScheduledExecutorService 能和Timer/TimerTask类似，解决那些需要任务重复执⾏的问题。
- ThreadPoolExecutor ExecutorService的默认实现。
- ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接⼝实现，周期性任务调度的类实现。
    - 当线程数⼩于corePoolSize时，创建线程执⾏任务。
    - 当线程数⼤于等于corePoolSize并且workQueue没有满时，放⼊workQueue中
    - 线程数⼤于等于corePoolSize并且当workQueue满时，新任务新建线程运⾏，线程总数要⼩于maximumPoolSize
    - 当线程总数等于maximumPoolSize并且workQueue满了的时候执⾏handler的rejectedExecution。也就是拒绝策略

# 常用的几种线程池并讲讲其中的工作原理
- 线程池核心类：在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是我们线程池核心类
- 如何提交线程：如可以先随便定义一个固定大小的线程池 ExecutorService es = Executors.newFixedThreadPool(3);提交一个线程es.submit(xxRunnble); es.execute(xxRunnble);
- submit 和 execute 分别有什么区别呢
    - execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多
    - submit 返回一个 Future 对象，如果想知道线程结果就使用 submit提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常
- 如何关闭线程池
    - es.shutdown(); 不再接受新的任务，之前提交的任务等执行结束再关闭线程池
    - es.shutdownNow();不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程 list 列表

# CyclicBarrier 和 CountDownLatch 的区别
- 都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上
- CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值-1 而已，该线程继续运行
- CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务
- CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为0该CountDownLatch就不可再用了

# 什么是活锁、饥饿、无锁、死锁
- 死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现了这三种情况，即线程不再活跃，不能再正常地执行下去了
- 死锁：死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁
- 活锁：活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。 
- 饥饿：我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源
- 无锁：无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功，可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合 下是非常高效的。

# 什么是原子性、可见性、有序性
- 原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个 变量进行操作
- 可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值
- 有序性我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序， 只是重排序会影响多线程执行的结果。

# 什么是守护线程？有什么用？
- 与守护线程相对应的就是用户线程，守护线程就是守护用户线程
- 当用户线程全部执行完结束之后，守护线程才会跟着结束
- 也就是守护线程必须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线 程自然会退出

# 一个线程运行时发生异常会怎样
- 如果异常没有被捕获该线程将会停止执行
- Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口
- 当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理

# 线程 yield()方法有什么用
- Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行
- 它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行

# 什么是重入锁
- 所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的

# Synchronized 有哪几种用法
- 锁类、锁方法、锁代码块

# Fork/Join 框架
#### Fork/Join 框架是干什么的
- 大任务自动分散小任务，并发执行，合并小任务结果

#### Fork/Join 框架使用有哪些要注意的地方？
- 如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降； 
- 如果函数的调用栈很深，会导致栈内存溢出；

# 线程数过多会造成什么异常
- 线程过多会造成栈溢出，也有可能会造成堆异常

# 说说线程安全的和不安全的集合
- Java 中平时用的最多的 Map 集合就是 HashMap 了，它是线程不安全的。 看下面两个场景：
    - 当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线程安全不安全的问题了
    - 当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个 HashMap了，对同个 HashMap 操作这时候就存在线程安全的问题了

# 什么是 CAS 算法？在多线程中有哪些应用
- CAS，全称为 Compare and Swap，即比较-替换
- 假设有三个操作数：内存值 V、 旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false
- 当然 CAS 一定要 volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功。
- java.util.concurrent.atomic 包下面的 Atom*类都有 CAS 算法的应用。

# 怎么检测一个线程是否拥有锁
- java.lang.Thread#holdsLock 方法

# Jdk 中排查多线程问题用什么命令
- jstack

# 线程同步需要注意什么
- 尽量缩小同步的范围，增加系统吞吐量
- 分布式同步锁无意义，要使用分布式锁
- 防止死锁，注意加锁顺序

# 线程 wait()方法使用有什么前提？
- 要在同步块中使用

# 线程之间如何传递数据？
- 通过在线程之间共享对象就可以了，
- 然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列 BlockingQueue就是为线程之间共享数据而设计的

# 保证&quot;可见性&quot;有哪几种方式？
- synchronized 和 viotatile

# 说几个常用的 Lock 接口实现锁。
- ReentrantLock、ReadWriteLock

# ThreadLocal 是什么？有什么应用场景？
- ThreadLocal 的作用是提供线程内的局部变量
- 这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。用来解决数据库连接、Session 管理等。

# ReadWriteLock 有什么用？
- ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现
- 实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能

# 怎么唤醒一个阻塞的线程？
- 如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它
- 如果线程遇到了 IO 阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统

# 不可变对象对多线程有什么帮助？
- 不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率

# 多线程上下文切换是什么意思？
- 多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。

# Java 中用到了什么线程调度算法？
- 抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

# Thread.sleep(0)的作用是什么？
- 由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制 权的一种操作

# Hashtable 的 size()方法为什么要做同步？
- 同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B则可以正常调用 size()方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对size++，线程 B 就已经读取 size了，那么对于线程 B 来说读取到的size 一定是不准 确的。而给 size()方法加了同步之后，意味着线程 B 调用size()方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性。

# 同步方法和同步块，哪种更好？
- 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率
- 请知道一条原则：同步的范围越小越好。

# Runnable 和 Thread 用哪个好？
- Java 不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也为了减少类之间的耦合性，Runnable 会更好

# Java 中 notify 和 notifyAll 有什么区别？
- notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行

# 为什么 wait/notify/notifyAll 这些方法不在 thread 类里面？
- 原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果 wait()方法定 义在 Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait， notify 和 notifyAll都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象

# 为什么 wait 和 notify 方法要在同步块中调用？
- 为了避免 wait 和 notify 之间产生竞态条件
- 为Java API强制要求，否则会抛出IllegalMonitorStateException 异常

# 为什么你应该在循环中检查等待条件？
- 处于等待状态的线程可能会收到错误警报和伪唤醒
- 如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出
- 因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因

# 你如何在 Java 中获取线程堆栈？
- jstack 这个工具来获取，它对进程 id 进行操作，用 jps 这个工具找到 id。

# 如何创建线程安全的单例模式？
- 单例模式即一个 JVM 内存中只存在一个类的对象实例分类
    - 懒汉式 类加载的时候就创建实例
    - 饿汉式 使用的时候才创建实例

# 什么是阻塞式方法？
- 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接
- 这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

# 提交任务时线程池队列已满会时发会生什么？
- 当线程数小于最大线程池数 maximumPoolSize 时就会创建新线程来处理
- 线程数大于等于最大线程池数 maximumPoolSize 时就会执行拒绝策略
- 如果你使⽤的LinkedBlockingQueue，也就是⽆界队列的话，没关系，继续添加任务到阻塞队列中等待执⾏，因为LinkedBlockingQueue可以近乎认为是⼀个⽆穷⼤的队列，可以⽆限存放任务；
- 如果你使⽤的是有界队列⽐⽅说ArrayBlockingQueue的话，任务⾸先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使⽤拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。

# 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
- 可以用join方法实现

# 在Java中Lock接口比synchronized块的优势是什么？
- lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁

# 你将如何使用threaddump？你将如何分析Thread dump？
- 在UNIX中你可以使用kill -3，然后thread dump将会打印日志
- 在windows中你可以使用”CTRL+Break”

# 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
- 当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码
- 但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码

# Java中你怎样唤醒一个阻塞的线程？
- 如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程
- 如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它

# Java并发类库提供的线程池有哪几种？ 分别有什么特点？
- 通常利用Executors提供的通用线程池创建方法，去创建不同配置的线程池,主要区别在于不同的ExecutorService类型或者不同的初始参数
- Executors目前提供了5种不同的线程池创建配置
    - newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点:
        - 它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程
        - 如果线程闲置的时间超过60S，则被终止并移出缓存
        - 长时间闲置时，这种线程池不会消耗资源
    - newFixedThreadPool(int  nThreads)：重用指定数目的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现，如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads
    - newSingleThreadExecutor()：它的特点在于工作线程数目被限制为1,操作一个无界的工作队列,所以它保证了所有任务的都是被顺序执行,最多会有一个任务处于活动状态,并且不允许使用者改造线程实例,因此可以避免其改变线程数目。
    - newSingleThreadScheduledExecutor()和newSecheduledThreadPool(int  corePoolSize),创建的是个ScheduledExecutorService,可以进行定时或周期性的工作调度,区别在于单一工作线程还是多个工作线程。

# ⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？
- ⾼并发、任务执⾏时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下⽂的切换
- 并发不⾼、任务执⾏时间⻓的业务要区分开看：
    - 假如是业务时间⻓集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占⽤CPU，所以不要让所有的CPU闲下来，可以加⼤线程池中的线程数⽬，让CPU处理更多的业务
    - 假如是业务时间⻓集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）⼀样吧，线程池中的线程数设置得少⼀些，减少线程上下⽂的切换
- 并发⾼、业务执⾏时间⻓，解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，看看这些业务⾥⾯某些数据是否能做缓存是第⼀步，增加服务器是第⼆步，⾄于线程池的设置，设置参考（2）。最后，业务执⾏时间⻓的问题，也可能需要分析⼀下，看看能不能使⽤中间件对任务进⾏拆分和解耦。

# 线程安全和线程不安全
#### 线程安全
- 线程安全就是多线程访问时，采⽤了加锁机制，当⼀个线程访问该类的某个数据时，进⾏保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使⽤。不会出现数据不⼀致或者数据污染。
- 线程安全是一个多线程环境下正确性的概念,也就是保证多线程环境下共享的可修改的状态的正确性,这里的状态反映在程序中其实可以看做是数据。
- 换个角度来看,如果状态不是共享的,或者不是可修改的,也就不存在线程安全问题,进而可以推理出保证线程安全的两个办法
    - 第一个是封装,我们可以将对象内部状态隐藏保护起来
    - 第二个是不可变。
- 线程安全需要保证几个基本特性
    - 原子性：简单来说就是相关操作不会中途被其他线程干扰,一般通过同步机制实现
    - 可见性：是一个线程修改了某个共享变量,其状态能够立即被其他线程知晓,通常被解释为将线程本地状态反映到主内存中,volatile关键字就是负责保证可见性的
    - 有序性：是保证线程内串行语义, 避免指令重排等

#### 线程不安全
- 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据
- 线程安全问题都是由全局变量及静态变量引起的
- 若每个线程中对全局变量、静态变量只有读操作，⽽⽆写操作，⼀般来说，这个全局变量是线程安全的
- 若有多个线程同时执⾏写操作，⼀般都需要考虑线程同步，否则的话就可能影响线程安全


# 如何保证集合是线程安全的?    ConcurrentHashMap 如何实现高效的线程安全?
- 在传统集合框架内部,除了Hashtable  Vector等同步容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个 同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等
- Vector 是⽤同步⽅法来实现线程安全的, ⽽和它相似的ArrayList不是线程安全的

# 为什么需要ConcurrentHashMap?
- Hashtable本身比较低效,因为它的实现基本就是put  get  size等各种方法加上&quot;synchronized&quot;
- 这就导致了所有并发操作都要竞争同一把锁,一个线程在进行同步操作时,其他线程只能等待,大大降低了并发操作的效率
- HashMap不是线程安全的,那么能不能利用Collections提供的同步包装器来解决问题
- 实际上同步器只是利用 输入Map构造了另一个同步版本,所有操作不再声明为synchronized方法,但是还是利用
- Hashtable或者同步包装版本,都只是适合在非高度并发的场景下

# ConcurrentHashMap工作机制
- 在早期的ConcurrentHashMap,其实现是基于分离锁,也就是将内部进行分段,里面则是HashEntry的数据
- 和HashMap类似,哈希相同的条目也是以链表形式存放。(简单点来说,就是在ConcurrentHashMap中,把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中)在构造的时候,Segment的数量由所谓的concurrentcyLevel来决定,默认是16,也可以在相应构造函数直接指定。注意,Java需要它是2的幂数值,如果输入是类似15这种非幂值,会自动调整到16之类2的幂数值。
- ConcurrentHashMap的工作机制就是通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。

# 什么是CAS
- CAS（compare and swap）的缩写，中⽂翻译成⽐较并交换。
- CAS 不通过JVM,直接利⽤java本地⽅ JNI（Java Native Interface为JAVA本地调⽤）,直接调⽤CPU 的cmpxchg（是汇编指令）指令
- 利⽤CPU的CAS指令，同时借助JNI来完成Java的⾮阻塞算法,实现原⼦操作。其它原⼦操作都是利⽤类似的特性完成的。
- 整个java.util.concurrent都是建⽴在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很⼤的提升。
- CAS是项乐观锁技术，当多个线程尝试使⽤CAS同时更新同⼀个变量时，只有其中⼀个线程能更新变量的值，⽽其它线程都失败，失败的线程并不会被挂起，⽽是被告知这次竞争中失败，并可以再次尝试
- 使⽤CAS在线程冲突严重时，会⼤幅降低程序性能；CAS只适合于线程冲突较少的情况使⽤。
- synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是⾃旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了⾼吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；⽽线程冲突严重的情况下，性能远⾼于CAS

# 什么是AQS
- AbstractQueuedSynchronizer简称AQS，是⼀个⽤于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等
- AQS解决了在实现同步容器时设计的⼤量细节问题。
- AQS使⽤⼀个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护⼀个等待状态waitStatus。

# 什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？
- 原⼦操作是指⼀个不受其他操作影响的操作任务单元
- 原⼦操作是在多线程环境下避免数据不⼀致必须的⼿段。
- int++并不是⼀个原⼦操作，所以当⼀个线程读取它的值并加1时，另外⼀个线程有可能会读到之前的值，这就会引发错误。
- 为了解决这个问题，必须保证增加操作是原⼦的，在JDK1.5之前我们可以使⽤同步技术来做到这⼀点到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以⾃动的保证对于他们的操作是原⼦的并且不需要使⽤同步

# 什么是阻塞队列
- 阻塞队列是⼀个在队列基础上⼜⽀持了两个附加操作的队列。
    - ⽀持阻塞的插⼊⽅法：队列满时，队列会阻塞插⼊元素的线程，直到队列不满。
    - ⽀持阻塞的移除⽅法：队列空时，获取元素的线程会等待队列变为⾮空。
- JDK7提供了7个阻塞队列
    - ArrayBlockingQueue ：⼀个由数组结构组成的有界阻塞队列。
    - LinkedBlockingQueue ：⼀个由链表结构组成的有界阻塞队列。
    - PriorityBlockingQueue ：⼀个⽀持优先级排序的⽆界阻塞队列。
    - DelayQueue：⼀个使⽤优先级队列实现的⽆界阻塞队列。
    - SynchronousQueue：⼀个不存储元素的阻塞队列。
    - LinkedTransferQueue：⼀个由链表结构组成的⽆界阻塞队列。
    - LinkedBlockingDeque：⼀个由链表结构组成的双向阻塞队列。

# 什么是同步容器和并发容器的实现？
#### 同步容器
- 主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。
- 锁的粒度为当前对象整体。
- 迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。

#### 并发容器
- 主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。
- 锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。
- 迭代器具有弱⼀致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。
- ConcurrentHashMap采⽤分段锁技术，同步容器中，是⼀个容器⼀个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若⼲段，每段维护⼀个锁，以达到⾼效的并发访问；

# ThreadLocal
#### ThreadLocal的设计理念与作⽤？
- Java中的ThreadLocal类允许我们创建只能被同⼀个线程读写的变量
- 如果⼀段代码含有⼀个ThreadLocal变量的引⽤，即使两个线程同时执⾏这段代码，它们也⽆法访问到对⽅的ThreadLocal变量

#### 概念
- 线程局部变量
- 变量是同⼀个，但是每个线程都使⽤同⼀个初始值，也就是使⽤同⼀个变量的⼀个新的副本。这种情况之下ThreadLocal就⾮常适⽤，⽐如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是⼀个线程安全的变量。⽽我们每个线程都需要使⽤他，并且各⾃使⽤各⾃的。这种情况，ThreadLocal就⽐较好的解决了这个问题。

#### 原理
- 从本质来讲，就是每个线程都维护了⼀个map，⽽这个map的key就是threadLocal，⽽值就是我们set的那个值
- 每次线程在get的时候，都从⾃⼰的变量中取值，既然从⾃⼰的变量中取值，那肯定就不存在线程安全问题
- ThreadLocal这个变量的状态根本没有发⽣变化，他仅仅是充当⼀个key的⻆⾊，另外提供给每⼀个线程⼀个初始值。

#### 实现机制
- 每个Thread对象内部都维护了⼀个ThreadLocalMap这样⼀个ThreadLocal的Map，可以存放若⼲个ThreadLocal。

#### 应⽤场景
- 当很多线程需要多次使⽤同⼀个对象，并且需要该对象具有相同初始化值的时候最适合使⽤ThreadLocal。

# Semaphore有什么作⽤？
- Semaphore就是⼀个信号量
- 作⽤是限制某段代码块的并发数

# Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？
- 同⼀时间只能有⼀条线程执⾏固定类的同步⽅法，但是对于类的⾮同步⽅法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执⾏Hashtable的put⽅法添加数据，线程B则可以正常调⽤size()⽅法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size⼀定是不准确的。
- ⽽给size()⽅法加了同步之后，意味着线程B调⽤size()⽅法只有在线程A调⽤put⽅法完毕之后才可以调⽤，这样就保证了线程安全性。

# ConcurrentHashMap的并发度是什么？
- ⼯作机制（分⽚思想）：它引⼊了⼀个“分段锁”的概念，具体可以理解为把⼀个⼤的Map拆分成N个⼩的segment，根据key.hashCode()来决定把key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。
- 应⽤：当读&gt;写时使⽤，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；
- hash冲突：
    - 简介：HashMap中调⽤hashCode()⽅法来计算hashCode。由于在Java中两个不同的对象可能有⼀样的hashCode,所以不同的键可能有⼀样hashCode，从⽽导致冲突的产⽣。
    - hash冲突解决：使⽤平衡树来代替链表，当同⼀hash中的元素数量超过特定的值便会由链表切换到平衡树
- ⽆锁读：ConcurrentHashMap之所以有较好的并发性是因为ConcurrentHashMap是⽆锁读和加锁写，并且利⽤了分段锁（不是在所有的entry上加锁，⽽是在⼀部分entry上加锁）；读之前会先判断count(jdk1.6)，其中的count是被volatile修饰的(当变量被volatile修饰后，每次更改该变量的时候会将更改结果写到系统主内存中，利⽤多处理器的缓存⼀致性，其他处理器会发现⾃⼰的缓存⾏对应的内存地址被修改，就会将⾃⼰处理器的缓存⾏设置为失效，并强制从系统主内存获取最新的数据。)，故可以实现⽆锁读。
- ConcurrentHashMap的并发度就是segment的⼤⼩，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最⼤优势。

# ReentrantReadWriteLock读写锁的使⽤
- 读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm⾃⼰控制的，你只要上好相应的锁即可
- 如果你的代码只读数据，可以很多⼈同时读，但不能同时写，那就上读锁
- 如果你的代码修改数据，只能有⼀个⼈在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁

# 锁的等级：⽅法锁、对象锁、类锁?
#### ⽅法锁（synchronized修饰⽅法时）
    - 通过在⽅法声明中加⼊ synchronized关键字来声明 synchronized ⽅法。
    - synchronized ⽅法控制对类成员变量的访问：
    - 每个类实例对应⼀把锁，每个 synchronized ⽅法都必须获得调⽤该⽅法的类实例的锁⽅能执⾏，否则所属线程阻塞，⽅法⼀旦执⾏，就独占该锁，直到从该⽅法返回时才将锁释放，此后被阻塞的线程⽅能获得该锁，重新进⼊可执⾏状态
    - 这种机制确保了同⼀时刻对于每⼀个类实例，其所有声明为 synchronized 的成员函数中⾄多只有⼀个处于可执⾏状态，从⽽有效避免了类成员变量的访问冲突。

#### 对象锁（synchronized修饰⽅法或代码块）
- 当⼀个对象中有synchronized method或synchronized block的时候调⽤此对象的同步⽅法或进⼊其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调⽤者占⽤，则需要等待此锁被释放。（⽅法锁也是对象锁）
- java的所有对象都含有1个互斥锁，这个锁由JVM⾃动获取和释放
- 线程进⼊synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待
- synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁
- 这⾥也体现了⽤synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来⾃动释放。　

#### 类锁(synchronized 修饰静态的⽅法或代码块)
- 由于⼀个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有⼀份。所以，⼀旦⼀个静态的⽅法被申明为synchronized。此类所有的实例化对象在调⽤此⽅法，共⽤同⼀把锁，我们称之为类锁。
- 对象锁是⽤来控制实例⽅法之间的同步，类锁是⽤来控制静态⽅法（或静态变量互斥体）之间的同步

# 如果同步块内的线程抛出异常会发⽣什么？
- synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁

# 并发编程（concurrency）并⾏编程（parallellism）有什么区别？
- 并⾏是指两个或者多个事件在同⼀时刻发⽣；⽽并发是指两个或多个事件在同⼀时间间隔发⽣。
- 并⾏是在不同实体上的多个事件，并发是在同⼀实体上的多个事件。
- 在⼀台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群所以并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能。

# 如何保证多线程下 i++ 结果正确？
- volatile只能保证你数据的可⻅性，获取到的是最新的数据，不能保证原⼦性；
- ⽤AtomicInteger保证原⼦性。
- synchronized既能保证共享变量可⻅性，也可以保证锁内操作的原⼦性。

# ⼀个线程如果出现了运⾏时异常会怎么样?
- 如果这个异常没有被捕获的话，这个线程就停⽌执⾏了。
- 另外重要的⼀点是：如果这个线程持有某个对象的监视器，那么这个对象监视器会被⽴即释放.

# 如何在两个线程之间共享数据?
- 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进⾏唤起和等待
- ⽐⽅说阻塞队列BlockingQueue就是为线程之间共享数据⽽设计的。

# ⽣产者消费者模型的作⽤是什么?
- 通过平衡⽣产者的⽣产能⼒和消费者的消费能⼒来提升整个系统的运⾏效率，这是⽣产者消费者模型最重要的作⽤
- 解耦，这是⽣产者消费者模型附带的作⽤，解耦意味着⽣产者和消费者之间的联系少，联系越少越可以独⾃发展⽽不需要受到相互的制约。

# 怎么唤醒⼀个阻塞的线程?
- 如果线程是因为调⽤了wait()、sleep()或者join()⽅法⽽导致的阻塞
- suspend与resume，Java废弃suspend() 去挂起线程的原因，是因为suspend() 在导致线程暂停的同时，并不会释放任何锁资源。其他线程都⽆法访问被它占⽤的锁。直到对应的线程执⾏resume() ⽅法后，被挂起的线程才能继从⽽其它被阻塞在这个锁的线程才可以继续执⾏。但是，如果resume()操作出现在 suspend(之前执⾏，那么线程将⼀直处于挂起状态，同时⼀直占⽤锁，这就产⽣了死锁。⽽且，对于被挂起的线程，它的线程状态居然还是 Runnable。
- wait与notify，wait与notify必须配合synchronized使⽤，因为调⽤之前必须持有锁，wait会⽴即释放锁，notify则是同步块执⾏完了才释放
- await与singal，Condition类提供，⽽Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使⽤Lock锁后⽆法使⽤wait⽅法
- park与unpark，LockSupport是⼀个⾮常⽅便实⽤的线程阻塞⼯具，它可以在线程任意位置让线程阻塞。和Thread.suspenf()相⽐，它弥补了由于resume()在前发⽣，导致线程⽆法继续执⾏的情况。和Object.wait()相⽐，它不需要先获得某个对象的锁，也不会抛出IException异常。可以唤醒指定线程。
- 如果线程遇到了IO阻塞，⽆能为⼒，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。

# 单例模式的线程安全性?
- ⾸先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建⼀次出来
- 单例模式有很多种的写法，我总结⼀下：
    - 饿汉式单例模式的写法：线程安全
    - 懒汉式单例模式的写法：⾮线程安全
    - 双检锁单例模式的写法：线程安全

# 线程类的构造⽅法、静态块是被哪个线程调⽤的?
- 线程类的构造⽅法、静态块是被new这个线程类所在的线程所调⽤的，⽽run⽅法⾥⾯的代码才是被线程⾃身所调⽤的。

# 同步⽅法和同步块，哪个是更好的选择?
- 同步块是更好的选择，因为它不会锁住整个对象（当然也可以让它锁住整个对象）
- 同步⽅法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停⽌执⾏并需要等待获得这个对象上的锁。
- synchronized(this)以及⾮static的synchronized⽅法（⾄于static synchronized⽅法请往下看），只能防⽌多个线程同时执⾏同⼀个对象的同步代码段。
- 如果要锁住多个对象⽅法，可以锁住⼀个固定的对象，或者锁住这个类的Class对象。
- synchronized锁住的是括号⾥的对象，⽽不是代码
- 对于⾮static的synchronized⽅法，锁的就是对象本身也就是this。

# 如何检测死锁？怎么预防死锁？
- 死锁是指两个或两个以上的进程在执⾏过程中，因争夺资源⽽造成的⼀种互相等待的现象，若⽆外⼒作⽤，它们都将⽆法推进下去。此时称系统处于死锁；

#### 死锁的四个必要条件
- 互斥条件：进程对所分配到的资源不允许其他进程进⾏访问，若其他进程访问该资源，只能等待，直⾄占有该资源的进程使⽤完成后释放该资源
- 请求和保持条件：进程获得⼀定的资源之后，⼜对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但⼜对⾃⼰获得的资源保持不放
- 不可剥夺条件：是指进程已获得的资源，在未完成使⽤之前，不可被剥夺，只能在使⽤完后⾃⼰释放
- 环路等待条件：是指进程发⽣死锁后，若⼲进程之间形成⼀种头尾相接的循环等待资源关系

#### 死锁产⽣的原因
- 因竞争资源发⽣死锁 现象：系统中供多个进程共享的资源的数⽬不⾜以满⾜全部进程的需要时，就会引起对诸资源的竞争⽽发⽣死锁现象
- 进程推进顺序不当发⽣死锁

#### 检查死锁
- 有两个容器，⼀个⽤于保存线程正在请求的锁，⼀个⽤于保存线程已经持有的锁
- 每次加锁之前都会做如下检测:
    - 检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来
    - 遍历第⼀步中返回的线程，检查⾃⼰持有的锁是否正被其中任何⼀个线程请求，如果第⼆步返回真,表示出现了死锁

#### 死锁的解除与预防
- 控制不要让四个必要条件成⽴。

# HashMap在多线程环境下使⽤需要注意什么？
- 要注意死循环的问题，HashMap的put操作引发扩容，这个动作在多线程并发下会发⽣线程死循环的问题
- 多个线程同时扩容，造成数据丢失；
- 多线程扩容时导致Node链表形成环形结构造成.next()死循环，导致CPU利⽤率接近100%；

# 如何实现线程串⾏执⾏？
- 为了控制线程执⾏的顺序，如ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执⾏三个线程，我们需要确定唤醒、等待的顺序
- 这时我们可以同时使⽤ Obj.wait()、Obj.notify()与synchronized(Obj)来实现这个⽬标。
- 线程中持有上⼀个线程类的对象锁以及⾃⼰的锁，由于这种依赖关系，该线程执⾏需要等待上个对象释放锁，从⽽保证类线程执⾏的顺序。
- 通常情况下，wait是线程在获取对象锁后，主动释放对象锁，同时本线程休眠，直到有其它线程调⽤对象的notify()唤醒该线程，才能继续获取对象锁，并继续执⾏
- ⽽notify()则是对等待对象锁的线程的唤醒操作
- 但值得注意的是notify()调⽤后，并不是⻢上就释放对象锁，⽽是在相应的synchronized()&#123;&#125;语句块执⾏结束
- 释放对象锁后，JVM会在执⾏wait()等待对象锁的线程中随机选取⼀线程，赋予其对象锁，唤醒线程，继续执⾏。

# 可以运⾏时kill掉⼀个线程吗？
- 不可以
- 只有当线程run⽅法或者主线程main⽅法结束，⼜或者抛出异常时，线程才会结束⽣命周期。

# 关于synchronized
- 在某个对象的所有synchronized⽅法中,在某个时刻只能有⼀个唯⼀的⼀个线程去访问这些synchronized⽅法
- 如果⼀个⽅法是synchronized⽅法,那么该synchronized关键字表示给当前对象上锁(即this)相当于synchronized(this)&#123;&#125;
- 如果⼀个synchronized⽅法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管⽣成多少对象,其对应的class对象只有⼀个)

# 数据库死锁机制和解决⽅案
- 死锁：死锁是指两个或者两个以上的事务在执⾏过程中，因争夺锁资源⽽造成的⼀种互相等待的现象。
- 处理机制：解决死锁最有⽤最简单的⽅法是不要有等待，将任何等待都转化为回滚，并且事务重新开始，但是有可能影响并发性能。
    - 超时回滚，innodb_lock_wait_time设置超时时间；
    - wait-for-graph⽅法：跟超时回滚⽐起来，这是⼀种更加主动的死锁检测⽅式。InnoDB引擎也采⽤这种⽅式。

# spring单例为什么没有安全问题(ThreadLocal)
- ThreadLocal：spring使⽤ThreadLocal解决线程安全问题
- ThreadLocal会为每⼀个线程提供⼀个独⽴的变量副本，从⽽隔离了多个线程对数据的访问冲突
- 单例：⽆状态的Bean(⽆状态就是⼀次操作，不能保存数据。⽆状态对象(Stateless Bean)，就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。)适合⽤不变模式，技术就是单例模式，这样可以共享实例，提⾼性能。

# 线程池原理
- 使⽤场景：使⽤线程池，以提⾼服务器性能；
- 组成：
    - 线程池管理器（ThreadPool）：⽤于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
    - ⼯作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执⾏任务；
    - 任务接⼝（Task）：每个任务必须实现的接⼝，以供⼯作线程调度任务的执⾏，它主要规定了任务的⼊⼝，任务执⾏完后的收尾⼯作，任务的执⾏状态等；
    - 任务队列（taskQueue）：⽤于存放没有处理的任务。提供⼀种缓冲机制。
- 原理：线程池技术正是关注如何缩短或调整T1,T3时间的技术，从⽽提⾼服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者⼀些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。
- ⼯作流程：
    - 线程池刚创建时，⾥⾯没有⼀个线程(也可以设置参数prestartAllCoreThreads启动预期数量主线程)
    - 任务队列是作为参数传进来的
    - 不过，就算队列⾥⾯有任务，线程池也不会⻢上执⾏它们。
    - 当调⽤ execute() ⽅法添加⼀个任务时，线程池会做如下判断：
        - 如果正在运⾏的线程数量⼩于 corePoolSize，那么⻢上创建线程运⾏这个任务；
        - 如果正在运⾏的线程数量⼤于或等于 corePoolSize，那么将这个任务放⼊队列；
        - 如果这时候队列满了，⽽且正在运⾏的线程数量⼩于 maximumPoolSize，那么还是要创建⾮核⼼线程⽴刻运⾏这个任务；
        - 如果队列满了，⽽且正在运⾏的线程数量⼤于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。
    - 当⼀个线程完成任务时，它会从队列中取下⼀个任务来执⾏。
    - 当⼀个线程⽆事可做，超过⼀定的时间（keepAliveTime）时，线程池会判断，如果当前运⾏的线程数⼤于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的⼤⼩。

# java线程如何启动
- 继承Thread类；
- 实现Runnable接⼝
- 在函数体使⽤
- ⽐较：
    - 实现Runnable接⼝优势：
        - 适合多个相同的程序代码的线程去处理同⼀个资源
        - 可以避免java中的单继承的限制
        - 增加程序的健壮性，代码可以被多个线程共享，代码和数据独⽴。
    - 继承Thread类优势：
        - 可以将线程类抽象出来，当需要使⽤抽象⼯⼚模式设计时。
        - 多线程同步
    - 在函数体使⽤优势
        - ⽆需继承thread或者实现Runnable，缩⼩作⽤域。

# java中加锁的⽅式有哪些,如何实现怎么个写法
- java中有两种锁
    - ⼀种是⽅法锁或者对象锁(在⾮静态⽅法或者代码块上加锁)
    - 第⼆种是类锁(在静态⽅法或者class上加锁)；
- 注意
    - 其他线程可以访问未加锁的⽅法和代码
    - synchronized同时修饰静态⽅法和实例⽅法，但是运⾏结果是交替进⾏的，这证明了类锁和对象锁是两个不⼀样的锁，控制着不同的区域，它们是互不⼲扰的。

# 如何保证数据不丢失：
- 使⽤消息队列，消息持久化；
- 添加标志位：未处理 0，处理中 1，已处理 2。定时处理。

# ThreadLocal为什么会发⽣内存泄漏？
- ThreadLocal的实现是这样的：每个Thread 维护⼀个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。
- 也就是说 ThreadLocal 本身并不存储值，它只是作为⼀个 key 来让线程从 ThreadLocalMap 获取 value
- ThreadLocalMap使⽤ThreadLocal的弱引⽤作为key，如果⼀个ThreadLocal没有外部强引⽤来引⽤它，那么系统 GC的时候，这个ThreadLocal势必会被回收，这样⼀来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会⼀直存在⼀条强引⽤链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远⽆法回收，造成内存泄漏。
- 预防办法：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap⾥所有key为null的value。
- 但是这些被动的预防措施并不能保证不会内存泄漏：
    - 使⽤static的ThreadLocal，延⻓了ThreadLocal的⽣命周期，可能导致内存泄漏。
    - 分配使⽤了ThreadLocal⼜不再调⽤get(),set(),remove()⽅法，那么就会导致内存泄漏，因为这块内存⼀直存在。

# jdk8中对ConcurrentHashmap的改进
- Java 7为实现并⾏访问，引⼊了Segment这⼀结构，实现了分段锁，理论上最⼤并发度与Segment个数相等。
- Java 8为进⼀步提⾼并发性，摒弃了分段锁的⽅案，⽽是直接使⽤⼀个⼤的数组。同时为了提⾼哈希碰撞下的寻址性能
- Java 8在链表⻓度超过⼀定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红⿊树（寻址时间复杂度为O(long(N))）。
 
# concurrent包下有哪些类？
- ConcurrentHashMap、Future、FutureTask、AtomicInteger...

# 线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?
- CountDownLatch类
    - ⼀个同步辅助类，常⽤于某个条件发⽣后才能执⾏后续进程。给定计数初始化CountDownLatch，调⽤countDown(）⽅法，在计数到达零之前，await⽅法⼀直受阻塞。
    - 重要⽅法为countdown()与await()；
- join⽅法
    - 将线程B加⼊到线程A的尾部，当A执⾏完后B才执⾏。
    ```
    public static void main(String[] args) throws Exception &#123;
        Thread t = new Thread(&quot;t1&quot;);
        Thread t2 = new Thread(&quot;t2&quot;);
        t.start();
        t.join();
        t2.start();
    &#125;
    ```
- notify、wait⽅法，Java中的唤醒与等待⽅法
    - 关键为synchronized代码块，参数线程间应相同，也常⽤Object作为参数。

# ⾼并发系统如何做性能优化？如何防⽌库存超卖？
#### ⾼并发系统性能优化
- 优化程序，优化服务配置，优化系统配置
- 尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。
- ⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。
- 优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。
- 优化数据库结构，多做索引，提⾼查询效率。
- 统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。
- 能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。
- 解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。

#### 防⽌库存超卖
- 悲观锁：在更新库存期间加锁，不允许其它线程修改；
    - 数据库锁：select xxx for update；
    - 分布式锁；
- 乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。
- redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。
- 消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。
- 总结：总的来说，不能把压⼒放在数据库上，所以使⽤ &quot;select xxx for update&quot; 的⽅式在⾼并发的场景下是不可⾏的
- FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤
- 所以相对来说，我会倾向于选择：乐观锁 / 缓存锁 / 分布式锁的⽅式。

# 线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？
- ⼯⼚⽅法作⽤：ThreadPoolExecutor类就是Executor的实现类，但ThreadPoolExecutor在使⽤上并不是那么⽅便，在实例化时需要传⼊很多歌参数，还要考虑线程的并发数等与线程池运⾏效率有关的参数，所以官⽅建议使⽤Executors工厂类来创建线程池对象。

# 线程间的通信方式
- 共享内存机制和消息通信机制

#### 同步
- 这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。
- 由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。
- 这种方式，本质上就是“共享内存”式的通信
- 多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。
 
#### while轮询的方式
- 在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信
- 但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立
- 这种方式还存在另外一个问题：轮询的条件的可见性问题，关于内存可见性问题
- 线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。
 
#### wait/notify机制
- 线程A要等待某个条件满足时(list.size()==5)，才执行操作
- 线程B则向list中添加元素，改变list 的size。
- A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？
- 这里用到了Object类的 wait() 和 notify() 方法。
- 当条件未满足时(list.size() !=5)，线程A调用wait() 放弃CPU，并进入阻塞状态。不像②while轮询那样占用CPU
- 当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。
- 这种方式的一个好处就是CPU的利用率提高了。
- 但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。
 
#### 管道通信
- 就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信

#  线程池的定义和优点
- 线程池，从字面含义来看，是指管理一组同构工作线程的资源池
- 线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务
- 工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
- “在线程池中执行任务“”比“为每个线程分配一个任务”优势更多
- 通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销
- 另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性
- 通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。

#### 线程池的工作流程
- 默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） 
- 当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  
- 当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  
- 当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。
- 当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 
- 如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。

#### 工作队列
- 如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来
- 在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待
- 常见的工作队列有以下几种，前三种用的最多。
    - ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。
    - LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界/无界队列，先进先出。
    - SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue才有实际价值.
    - PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。
    - DelayedWorkQueue：延迟的工作队列，无界队列。

#### 饱和策略（拒绝策略）
- 当有界队列被填满后，饱和策略开始发挥作用
- ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改
- 如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略
- 饱和策略有以下四种，一般使用默认的AbortPolicy。
    - AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。
    - DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。
    - DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。
    - CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。

#### 线程工厂
- 每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的
- 在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法
- Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。
    - DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。
    - PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。
- 自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。

# 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
- 可以用join方法实现。

# 在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？
- lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁
- 它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞

# 你将如何使用threaddump？你将如何分析Thread dump？
- 在UNIX中你可以使用kill -3，然后thread dump将会打印日志
- 在windows中你可以使用”CTRL+Break”

# violatile 关键字的作用？
- 多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据
- 使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言
- volatile 的一个重要作用就是和CAS结合，保证了原子性

# 怎么控制同一时间只有 3 个线程运行？
用 Semaphore。

# 线程池启动线程 submit()和 execute()方法有什么不同？
- execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多。
- submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常。

# 什么是原子性、可见性、有序性？
#### 原子性
- 原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作
- 在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量 n++100 次，如果 n 初始值为 0，n 最后的值应该是 100，所以说它们是互不干扰的，这就是传说的中的原子性。但 n++并不是原子性的操作，要使用 AtomicInteger 保证原子性。

#### 可见性
- 可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值
- 在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的值，而在多线程编程中就不一定了
- 每个线程都有自己的工作内存，线程先把共享变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值
- 像CPU 的缓存优化、硬件优化、指令重排及对 JVM 编译器的优化，都会出现可见性的问题。

#### 有序性
- 我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了
- 为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即
后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果
- 所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果
- 虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，只是重排序会影响多线程执行的结果。

# 多线程上下文切换是什么意思？
多- 线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。

# Java 中堆和栈有什么不同？
- 每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的
- 而堆是所有线程共享的一片公用内存区域
- 对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。

# 你如何在 Java 中获取线程堆栈？
- 对于不同的操作系统，有多种方法来获得 Java 进程的线程堆栈
- 当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台
- 在 Windows 你可以使用 Ctrl + Break 组合键来获取线程堆栈，Linux 下用 kill -3 命令
- 你也可以用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。

# 什么是阻塞式方法？
- 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接
- 这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回
- 此外，还有异步和非阻塞式方法在任务完成前就返回。

# 同步和异步有何异同，在什么情况下分别使用他们？举例说明。
- 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
- 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。
</code></pre></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/1e7ca447b43e.html" rel="prev" title="分布式"><i class="fa fa-angle-left"></i> 分布式</a></div><div class="post-nav-item"><a href="/publishes/8270315bab4b.html" rel="next" title="Java虚拟机（JVM）">Java虚拟机（JVM） <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>