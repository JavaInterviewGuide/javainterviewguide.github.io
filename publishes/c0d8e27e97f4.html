<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="用什么关键字修饰同步方法 用synchronized关键字修饰同步方法  stop()和suspend()方法为何不推荐使用 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。 suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这"><meta property="og:type" content="article"><meta property="og:title" content="多线程"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="用什么关键字修饰同步方法 用synchronized关键字修饰同步方法  stop()和suspend()方法为何不推荐使用 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。 suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:06:48.000Z"><meta property="article:modified_time" content="2023-12-20T07:07:41.149Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="线程"><meta property="article:tag" content="多线程"><meta property="article:tag" content="并发"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html","path":"publishes/c0d8e27e97f4.html","title":"多线程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>多线程 | Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java后端面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E4%BB%80%E4%B9%88%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">用什么关键字修饰同步方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stop-%E5%92%8Csuspend-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">stop()和suspend()方法为何不推荐使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">sleep() 和 wait() 有什么区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E4%BB%96%E4%BB%AC%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="nav-number">4.</span> <span class="nav-text">同步和异步有何异同，在什么情况下分别使用他们？举例说明。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%94%A8run-%E8%BF%98%E6%98%AFstart"><span class="nav-number">5.</span> <span class="nav-text">启动一个线程是用run()还是start()?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AAsynchronized%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">7.</span> <span class="nav-text">线程的基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0synchronized%E5%92%8Cjava-util-concurrent-locks-Lock%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">8.</span> <span class="nav-text">简述synchronized和java.util.concurrent.locks.Lock的异同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Synchronized%E5%92%8CReentrantLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">Synchronized和ReentrantLock有什么区别?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">9.0.0.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%93%8D%E4%BD%9C-CompareAndSwap"><span class="nav-number">9.0.0.2.</span> <span class="nav-text">CAS操作(CompareAndSwap)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized"><span class="nav-number">9.0.0.3.</span> <span class="nav-text">Synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">9.0.0.4.</span> <span class="nav-text">ReentrantLock</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">10.</span> <span class="nav-text">请说出你所知道的线程同步的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">11.</span> <span class="nav-text">同步有几种实现方法,都是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">12.</span> <span class="nav-text">线程间的通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">12.0.0.1.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">12.0.0.2.</span> <span class="nav-text">while轮询的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-notify%E6%9C%BA%E5%88%B6"><span class="nav-number">12.0.0.3.</span> <span class="nav-text">wait&#x2F;notify机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="nav-number">12.0.0.4.</span> <span class="nav-text">管道通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">线程死锁及解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="nav-number">13.0.0.1.</span> <span class="nav-text">什么是死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">13.0.0.2.</span> <span class="nav-text">解决办法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81%E5%88%86%E7%B1%BB%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">14.</span> <span class="nav-text">锁分类的了解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">14.0.0.1.</span> <span class="nav-text">公平锁&#x2F;非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">14.0.0.2.</span> <span class="nav-text">可重入锁</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c0d8e27e97f4.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="多线程 | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">多线程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:06:48 / 修改时间：15:07:41" itemprop="dateCreated datePublished" datetime="2023-12-20T15:06:48+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="用什么关键字修饰同步方法"><a href="#用什么关键字修饰同步方法" class="headerlink" title="用什么关键字修饰同步方法"></a>用什么关键字修饰同步方法</h1><ul><li>用synchronized关键字修饰同步方法</li></ul><h1 id="stop-和suspend-方法为何不推荐使用"><a href="#stop-和suspend-方法为何不推荐使用" class="headerlink" title="stop()和suspend()方法为何不推荐使用"></a>stop()和suspend()方法为何不推荐使用</h1><ul><li>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</li><li>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</li></ul><h1 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h1><ul><li>最大的不同是在等待时wait会释放锁，而sleep一直持有锁</li><li>Wait通常被用于线程间交互，sleep通常被用于暂停执行</li><li>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li><li>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li><li>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。</li><li>wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。</li><li>sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器</li></ul><h1 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h1><ul><li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取</li><li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率</li></ul><h1 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h1><ul><li>启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态</li><li>一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码</li></ul><h1 id="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h1><ul><li>分几种情况：<ul><li>其他方法前是否加了synchronized关键字，如果没加，则能。</li><li>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</li><li>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</li><li>如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</li></ul></li></ul><h1 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h1><ul><li>一个程序中可以有多条执行线索同时执行</li><li>一个线程就是程序中的一条执行线索</li><li>每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行</li><li>每个程序至少都有一个线程，即main方法执行的那个线程</li><li>如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行。</li><li>线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身</li><li>Java中的线程有四种状态分别是：运行、就绪、挂起、结束</li><li>线程是操作系统能够进⾏运算调度的最⼩单位，它被包含在进程之中，是进程中的实际运作单位，可以使⽤多线程对进⾏运算提速</li></ul><h1 id="简述synchronized和java-util-concurrent-locks-Lock的异同"><a href="#简述synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="简述synchronized和java.util.concurrent.locks.Lock的异同"></a>简述synchronized和java.util.concurrent.locks.Lock的异同</h1><ul><li>主要相同点：Lock能完成synchronized所实现的所有功能</li><li>主要不同点<ul><li>Lock有比synchronized更精确的线程语义和更好的性能</li><li>ynchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放</li><li>Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁</li></ul></li></ul><h1 id="Synchronized和ReentrantLock有什么区别"><a href="#Synchronized和ReentrantLock有什么区别" class="headerlink" title="Synchronized和ReentrantLock有什么区别?"></a>Synchronized和ReentrantLock有什么区别?</h1><ul><li>synchronized是Java内建的同步机制,所以也有人称其为Intrinsic Locking（固有锁），它提供了互斥的语义和可见性,当一个线程已经获取当前锁时,其他试图获取的线程只能等待或者阻塞在那里。在Java 5以前,synchronized是仅有的同步手段,在代码中,synchronized可以用来修饰方法,也可以使用在特定的代码块上,本质上 synchronized方法等同于把方法全部语句用synchronized块包起来。</li><li>ReentrantLock,通常翻译为再入锁,是Java 5提供的锁实现,它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取,代码书写更加灵活。与此同时,ReentrantLock提供了很多实用的方法,能够实现很多synchronized无法做到的细节控制,但是在编码中也需要注意,必须要明确调用unlock()方法释放,不然就会一直持有该锁。synchronzied和ReentrantLock的性能不能一概而论,早期版本synchronized在很多场景下性能相差较大,在后续版本进行了较多改进,在低竞争场景中表现可能优于ReentrantLock。</li></ul><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>可重⼊锁。可重⼊锁是指同⼀个线程可以多次获取同⼀把锁。ReentrantLock和synchronized都是可重⼊锁。</li><li>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，⽽ReentrantLock则提供了中断功能。</li><li>公平锁是指多个线程同时尝试获取同⼀把锁时，获取锁的顺序按照线程达到的顺序</li><li>⾮公平锁则允许线程“插队”</li><li>synchronized是⾮公平锁，⽽ReentrantLock的默认实现是⾮公平锁，但是也可以设置为公平锁。</li></ul><h4 id="CAS操作-CompareAndSwap"><a href="#CAS操作-CompareAndSwap" class="headerlink" title="CAS操作(CompareAndSwap)"></a>CAS操作(CompareAndSwap)</h4><ul><li>CAS操作简单的说就是⽐较并交换</li><li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)</li><li>如果内存位置的值与预期原值相匹配，那么处理器会⾃动将该位置值更新为新值。否则，处理器不做任何操作</li><li>⽆论哪种情况，它都会在 CAS 指令之前返回该位置的值</li><li>CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</li></ul><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ul><li>synchronized是java内置的关键字，它提供了⼀种独占的加锁⽅式</li><li>synchronized的获取和释放锁由JVM实现，⽤户不需要显示的释放锁，⾮常⽅便</li><li>然⽽synchronized也有⼀定的局限性：<ul><li>当线程尝试获取锁的时候，如果获取不到锁会⼀直阻塞。</li><li>如果获取锁的线程进⼊休眠或者阻塞，除⾮当前线程异常，否则其他线程尝试获取锁必须⼀直等待。</li></ul></li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul><li>ReentrantLock它是JDK 1.5之后提供的API层⾯的互斥锁，需要lock()和unlock()⽅法配合try/finally语句块来完成。</li><li>等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）</li><li>公平锁与⾮公平锁多个线程等待同⼀个锁时，必须按照申请锁的时间顺序获得锁</li><li>Synchronized锁⾮公平锁，ReentrantLock默认的构造函数是创建的⾮公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li></ul><h1 id="请说出你所知道的线程同步的方法"><a href="#请说出你所知道的线程同步的方法" class="headerlink" title="请说出你所知道的线程同步的方法"></a>请说出你所知道的线程同步的方法</h1><ul><li>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</li><li>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</li><li>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级</li><li>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li></ul><h1 id="同步有几种实现方法-都是什么"><a href="#同步有几种实现方法-都是什么" class="headerlink" title="同步有几种实现方法,都是什么?"></a>同步有几种实现方法,都是什么?</h1><ul><li>同步的实现方面有两种，分别是synchronized,wait与notify</li></ul><h1 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h1><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信</li><li>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信</li><li>这种方式，本质上就是“共享内存”式的通信</li><li>多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行</li></ul><h4 id="while轮询的方式"><a href="#while轮询的方式" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h4><ul><li>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信</li><li>但是这种方式会浪费CPU资源</li><li>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试某个条件是否成立</li><li>这种方式还存在另外一个问题：轮询的条件的可见性问题</li><li>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</li></ul><h4 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait/notify机制"></a>wait/notify机制</h4><ul><li>线程A要等待某个条件满足时(list.size()==5)，才执行操作，线程B则向list中添加元素，改变list 的size</li><li>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢</li><li>这里用到了Object类的 wait() 和 notify() 方法</li><li>当条件未满足时(list.size() !=5)，线程A调用wait()放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</li><li>当条件满足时，线程B调用 notify()通知线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态</li><li>这种方式的一个好处就是CPU的利用率提高了，但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。</li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ul><li>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</li><li>分布式系统中说的两种通信机制：共享内存机制和消息通信机制</li><li>synchronized关键字和while轮询“属于”共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流</li><li>而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。</li></ul><h1 id="线程死锁及解决办法"><a href="#线程死锁及解决办法" class="headerlink" title="线程死锁及解决办法"></a>线程死锁及解决办法</h1><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><ul><li>所谓死锁： 是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁线程。</li><li>由于资源占用是互斥的，当某个线程提出申请资源后，使得有关线程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁</li><li>关键点：<ul><li>两个以上的线程</li><li>争夺共享的资源</li><li>它们各自不释放手中资源，除非有外力协助</li></ul></li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y的拥有者分别等待对方的资源的问题。</li><li>将多个锁组成一组并放到同一个锁下</li><li>将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得容器对象的锁时，就可以通过检查变量来判断是否整个容器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试</li></ul><h1 id="锁分类的了解"><a href="#锁分类的了解" class="headerlink" title="锁分类的了解"></a>锁分类的了解</h1><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h4><ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁</li><li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象</li><li>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大</li><li>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁</li></ul><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul><li>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。</li><li>对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。<br>```<br>synchronized void setA() throws Exception{<br>Thread.sleep(1000);<br>setB();<br>}</li></ul><p>synchronized void setB() throws Exception{<br>Thread.sleep(1000);<br>}</p><pre><code>
- 上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁

#### 独享锁/共享锁
- 独享锁是指该锁一次只能被一个线程所持有。
- 共享锁是指该锁可被多个线程所持有。
- 对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
- 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
- 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
- 对于Synchronized而言，当然是独享锁。

#### 互斥锁/读写锁
- 上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
- 互斥锁在Java中的具体实现就是ReentrantLock
- 读写锁在Java中的具体实现就是ReadWriteLock

#### 乐观锁/悲观锁
- 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
- 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
- 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
- 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
- 悲观锁在Java中的使用，就是利用各种锁。
- 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
- 乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑
- 悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接上了锁操作资源。

#### 分段锁
- 分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
- 我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
- 当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
- 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计
- 分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作

#### 偏向锁/轻量级锁/重量级锁
- 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
- 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

#### 自旋锁
- 自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区
- 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU
- ⾃旋锁是SMP架构中的⼀种low-level的同步机制
- 当线程A想要获取⼀把⾃旋锁⽽该锁⼜被其它线程锁持有时，线程A会在⼀个循环中⾃旋以检测锁是不是已经可⽤了。
- ⾃选锁需要注意：
    - 由于⾃旋时不释放CPU，因⽽持有⾃旋锁的线程应该尽快释放⾃旋锁，否则等待该⾃旋锁的线程会⼀直在那⾥⾃旋，这就会浪费CPU时间
    - 持有⾃旋锁的线程在sleep之前应该释放⾃旋锁以便其它线程可以获得⾃旋锁
- ⽬前的JVM实现⾃旋会消耗CPU，如果⻓时间不调⽤doNotify⽅法，doWait⽅法会⼀直⾃旋，CPU会消耗太⼤
- ⾃旋锁⽐较适⽤于锁使⽤者保持锁时间⽐较短的情况，这种情况⾃旋锁的效率⽐较⾼
- ⾃旋锁是⼀种对多处理器相当有效的机制，⽽在单处理器⾮抢占式的系统中基本上没有作⽤

# 重入锁：ReentrantLock 详解
- 在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的。除此之外，重入锁又自带一系列高逼格UBFF：可中断响应、锁申请等待限时、公平锁。另外可以结合Condition来使用，使其更是逼格满满。
- 使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对逻辑控制的灵活性远远大于synchronized关键字
- 需要注意，有加锁就必须有释放锁，而且加锁与释放锁的分数要相同，这里就引出了“重”字的概念

#### 中断响应
- 对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。
- t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了死锁。但是，给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，正常执行完成。t2也会退出，但只是释放了资源并没有完成工作

#### 锁申请等待限时
- 可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。
- 前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。
- 后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false

#### 公平锁
- 所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：
</code></pre><p>public ReentrantLock(boolean fair) {<br>sync = fair ? new FairSync() : new NonfairSync();<br>}</p><pre><code>
#### ReentrantLock 配合 Conditond 使用
- 配合关键字synchronized使用的方法如：await()、notify()、notifyAll()
- ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象

# 深入理解Callable
- Callable和Runnbale一样代表着任务，区别在于Callable有返回值并且可以抛出异常
- Callable接⼝使⽤泛型去定义它的返回类型
- Executors类提供了⼀些有⽤的⽅法去在线程池中执⾏Callable内的任务
- 由于Callable任务是并⾏的，必须等待它返回的结果，java.util.concurrent.Future对象解决了这个问题
- 在线程池提交Callable任务后返回了⼀个Future对象，使⽤它可以知道Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()⽅法，等待Callable结束并获取它的执⾏结果

#### Future接口
- Future是一个接口，代表了一个异步计算的结果
- 接口中的方法用来检查计算是否完成、等待完成和得到计算的结果
- 当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了
- 如果想取消，那么调用cancel()方法
- 其他方法用于确定任务是正常完成还是取消了
- 一旦计算完成了，那么这个计算就不能被取消

#### FutureTask 是什么？
- FutureTask 表示一个异步运算的任务，FutureTask 里面可以传入一个 Callable的具体实现类
- 可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、 取消任务等操作
- FutureTask可⽤于异步获取执⾏结果或取消执⾏任务的场景
- 通过传⼊Runnable或者Callable的任务给FutureTask，直接调⽤其run⽅法或者放⼊线程池执⾏，之后可以在外部通过FutureTask的get⽅法异步获取执⾏结果
- FutureTask⾮常适合⽤于耗时的计算，主线程可以在完成⾃⼰的任务后，再去获取结果
- FutureTask还可以确保即使调⽤了多次run⽅法，它都只会执⾏⼀次Runnable或者Callable任务，或者通过cancel取消FutureTask的执⾏等
- futuretask可⽤于执⾏多任务、以及避免⾼并发情况下多次创建数据机锁的出现。

#### run方法
- 当将FutureTask提交给Executor后，Executor执行FutureTask时会执行其run方法
- 任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程
- 从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法
- set方法：当Callable成功执行后，会调用set方法将结果传出
- setException方法：该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程
- get方法：当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。
- 在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待
- awaitDone方法是如何将调用线程阻塞的,awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制
- awaitDone方法中进入死循环后，主要有几步
    - 如果线程被中断了，移除节点，抛出异常
    - 如果状态大于COMPLETING，那么直接返回
    - 如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下
    - 如果状态是NEW且节点为null，那么创建一个节点
    - 如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程
    - 如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点
    - 如果没有限制时间，那么将线程无限挂起
- 上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。
- 当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果
- report会根据任务的状态不同返回不同的结果。
    - 如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果
    - 如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException
    - 如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException
- finishCompletion方法：在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程
- finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环，释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。
- cancel方法：用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了，如果是需要中断正在执行的任务，那么状态转换将会是NEW-&gt;INTERRPUTING-&gt;INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW-&gt;CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。

- isDone方法：表明任务是否已经完成了，如果完成了，那么返回true，否则false，只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。

#### 总结
- Callable是一种可以返回结果的任务，这是它与Runnable的区别，但是通过适配器模式可以使Runnable与Callable类似
- Future代表了一个异步的计算，可以从中得到计算结果、查看计算状态，其实现FutureTask可以被提交给Executor执行，多个线程可以从中得到计算结果
- Callable和Future是配合使用的，当从Future中get结果时，如果结果还没被计算出来，那么线程将会被挂起，FutureTak内部使用一个单链表维持等待的线程；当计算结果出来后，将会对等待线程解除挂起，等待线程就都可以得到计算结果了。
- Callable⽤于产⽣结果，Future⽤于获取结果

# 多线程
#### 多线程优点
- 发挥多核CPU 的优势，并发执⾏让系统运⾏的更快、更流畅，⽤户体验更好
- 防止阻塞：从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因 为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但 是单核 CPU 我们还是要应用多线程，就是为了防止阻塞
- 便于建模：这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么 就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成 几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运 行这几个任务，那就简单很多了。
- 使⽤多线程可以把程序中占据时间⻓的任务放到后台去处理，如图⽚、视屏的下载

#### 多线程的缺点
- ⼤量的线程降低代码的可读性；
- 更多的线程需要更多的内存空间
- 当多个线程对同⼀个资源出现争夺时候要注意线程安全的问题。

#### 多线程的上下⽂切换
- CPU通过时间⽚分配算法来循环执⾏任务，当前任务执⾏⼀个时间⽚后会切换到下⼀个任务
- 在切换前会保存上⼀个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态

# 线程和进程的区别是什么
- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式
- 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径
- 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些
- 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程

# Java 实现线程有哪几种方式
- 继承 Thread 类实现多线程
- 实现 Runnable 接口方式实现多线程
- 使用 ExecutorService、Callable、Future 实现有返回结果的多线程

# 启动线程方法 start()和 run()有什么区别
- 只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代 码交替执行
- 如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码

# 一个线程的生命周期有哪几种状态？它们之间如何流转的？
- NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。
- RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中 状态。
- BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock等关键字等占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。
- WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如 通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方 法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线 程就进入了 RUNNABLE 状态继续运行。
- TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒 后线程重新进行 RUNNABLE 状态继续运行。
- TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程 通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到 RUNNABLE 状态

# violatile 关键字的作用
- volatile 关键字的作用主要有两个
    - 多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据
    - 使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重要作用就是和CAS结合，保证了原子性

# 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行
- 用 join 方法。

# 为什么要使用线程池
- 什么是线程池？ 很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线 程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用
- 每个线程都要通过 new Thread(xxRunnable).start()的方 式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈
- 线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存

# 线程池⽤法与优势？
#### ThreadPool 优点
- 减少了创建和销毁线程的次数，每个⼯作线程都可以被重复利⽤，可执⾏多个任务
- 可以根据系统的承受能⼒，调整线程池中⼯作线线程的数⽬，防⽌因为因为消耗过多的内存，⽽把服务器累趴下
- 减少在创建和销毁线程上所花的时间以及系统资源的开销
- 如不使⽤线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存

#### ⽐较重要的⼏个类
- Java⾥⾯线程池的顶级接⼜是Executor，但是严格意义上讲Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具
- 真正的线程池接口是ExecutorService。

#### 任务执⾏顺序：
- ExecutorService 真正的线程池接⼝。
- ScheduledExecutorService 能和Timer/TimerTask类似，解决那些需要任务重复执⾏的问题。
- ThreadPoolExecutor ExecutorService的默认实现。
- ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接⼝实现，周期性任务调度的类实现。
    - 当线程数⼩于corePoolSize时，创建线程执⾏任务。
    - 当线程数⼤于等于corePoolSize并且workQueue没有满时，放⼊workQueue中
    - 线程数⼤于等于corePoolSize并且当workQueue满时，新任务新建线程运⾏，线程总数要⼩于maximumPoolSize
    - 当线程总数等于maximumPoolSize并且workQueue满了的时候执⾏handler的rejectedExecution。也就是拒绝策略

# 常用的几种线程池并讲讲其中的工作原理
- 线程池核心类：在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是我们线程池核心类
- 如何提交线程：如可以先随便定义一个固定大小的线程池 ExecutorService es = Executors.newFixedThreadPool(3);提交一个线程es.submit(xxRunnble); es.execute(xxRunnble);
- submit 和 execute 分别有什么区别呢
    - execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很多
    - submit 返回一个 Future 对象，如果想知道线程结果就使用 submit提交，而且它能在主线程中通过 Future 的 get 方法捕获线程中的异常
- 如何关闭线程池
    - es.shutdown(); 不再接受新的任务，之前提交的任务等执行结束再关闭线程池
    - es.shutdownNow();不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程 list 列表

# CyclicBarrier 和 CountDownLatch 的区别
- 都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上
- CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值-1 而已，该线程继续运行
- CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务
- CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为0该CountDownLatch就不可再用了

# 什么是活锁、饥饿、无锁、死锁
- 死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现了这三种情况，即线程不再活跃，不能再正常地执行下去了
- 死锁：死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁
- 活锁：活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。 
- 饥饿：我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源
- 无锁：无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功，可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合 下是非常高效的。

# 什么是原子性、可见性、有序性
- 原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个 变量进行操作
- 可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值
- 有序性我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情况下就不是如此了。为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的执行结果。虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序， 只是重排序会影响多线程执行的结果。

# 什么是守护线程？有什么用？
- 与守护线程相对应的就是用户线程，守护线程就是守护用户线程
- 当用户线程全部执行完结束之后，守护线程才会跟着结束
- 也就是守护线程必须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线 程自然会退出

# 一个线程运行时发生异常会怎样
- 如果异常没有被捕获该线程将会停止执行
- Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口
- 当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理

# 线程 yield()方法有什么用
- Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行
- 它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行

# 什么是重入锁
- 所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的

# Synchronized 有哪几种用法
- 锁类、锁方法、锁代码块

# Fork/Join 框架
#### Fork/Join 框架是干什么的
- 大任务自动分散小任务，并发执行，合并小任务结果

#### Fork/Join 框架使用有哪些要注意的地方？
- 如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降； 
- 如果函数的调用栈很深，会导致栈内存溢出；

# 线程数过多会造成什么异常
- 线程过多会造成栈溢出，也有可能会造成堆异常

# 说说线程安全的和不安全的集合
- Java 中平时用的最多的 Map 集合就是 HashMap 了，它是线程不安全的。 看下面两个场景：
    - 当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线程安全不安全的问题了
    - 当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个 HashMap了，对同个 HashMap 操作这时候就存在线程安全的问题了

# 什么是 CAS 算法？在多线程中有哪些应用
- CAS，全称为 Compare and Swap，即比较-替换
- 假设有三个操作数：内存值 V、 旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false
- 当然 CAS 一定要 volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功。
- java.util.concurrent.atomic 包下面的 Atom*类都有 CAS 算法的应用。

# 怎么检测一个线程是否拥有锁
- java.lang.Thread#holdsLock 方法

# Jdk 中排查多线程问题用什么命令
- jstack

# 线程同步需要注意什么
- 尽量缩小同步的范围，增加系统吞吐量
- 分布式同步锁无意义，要使用分布式锁
- 防止死锁，注意加锁顺序

# 线程 wait()方法使用有什么前提？
- 要在同步块中使用

# 线程之间如何传递数据？
- 通过在线程之间共享对象就可以了，
- 然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列 BlockingQueue就是为线程之间共享数据而设计的

# 保证&quot;可见性&quot;有哪几种方式？
- synchronized 和 viotatile

# 说几个常用的 Lock 接口实现锁。
- ReentrantLock、ReadWriteLock

# ThreadLocal 是什么？有什么应用场景？
- ThreadLocal 的作用是提供线程内的局部变量
- 这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。用来解决数据库连接、Session 管理等。

# ReadWriteLock 有什么用？
- ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现
- 实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能

# 怎么唤醒一个阻塞的线程？
- 如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它
- 如果线程遇到了 IO 阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统

# 不可变对象对多线程有什么帮助？
- 不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率

# 多线程上下文切换是什么意思？
- 多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。

# Java 中用到了什么线程调度算法？
- 抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

# Thread.sleep(0)的作用是什么？
- 由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制 权的一种操作

# Hashtable 的 size()方法为什么要做同步？
- 同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B则可以正常调用 size()方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对size++，线程 B 就已经读取 size了，那么对于线程 B 来说读取到的size 一定是不准 确的。而给 size()方法加了同步之后，意味着线程 B 调用size()方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性。

# 同步方法和同步块，哪种更好？
- 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率
- 请知道一条原则：同步的范围越小越好。

# Runnable 和 Thread 用哪个好？
- Java 不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也为了减少类之间的耦合性，Runnable 会更好

# Java 中 notify 和 notifyAll 有什么区别？
- notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行

# 为什么 wait/notify/notifyAll 这些方法不在 thread 类里面？
- 原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果 wait()方法定 义在 Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait， notify 和 notifyAll都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象

# 为什么 wait 和 notify 方法要在同步块中调用？
- 为了避免 wait 和 notify 之间产生竞态条件
- 为Java API强制要求，否则会抛出IllegalMonitorStateException 异常

# 为什么你应该在循环中检查等待条件？
- 处于等待状态的线程可能会收到错误警报和伪唤醒
- 如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出
- 因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因

# 你如何在 Java 中获取线程堆栈？
- jstack 这个工具来获取，它对进程 id 进行操作，用 jps 这个工具找到 id。

# 如何创建线程安全的单例模式？
- 单例模式即一个 JVM 内存中只存在一个类的对象实例分类
    - 懒汉式 类加载的时候就创建实例
    - 饿汉式 使用的时候才创建实例

# 什么是阻塞式方法？
- 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接
- 这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

# 提交任务时线程池队列已满会时发会生什么？
- 当线程数小于最大线程池数 maximumPoolSize 时就会创建新线程来处理
- 线程数大于等于最大线程池数 maximumPoolSize 时就会执行拒绝策略
- 如果你使⽤的LinkedBlockingQueue，也就是⽆界队列的话，没关系，继续添加任务到阻塞队列中等待执⾏，因为LinkedBlockingQueue可以近乎认为是⼀个⽆穷⼤的队列，可以⽆限存放任务；
- 如果你使⽤的是有界队列⽐⽅说ArrayBlockingQueue的话，任务⾸先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使⽤拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。

# 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
- 可以用join方法实现

# 在Java中Lock接口比synchronized块的优势是什么？
- lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁

# 你将如何使用threaddump？你将如何分析Thread dump？
- 在UNIX中你可以使用kill -3，然后thread dump将会打印日志
- 在windows中你可以使用”CTRL+Break”

# 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
- 当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码
- 但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码

# Java中你怎样唤醒一个阻塞的线程？
- 如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程
- 如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它

# Java并发类库提供的线程池有哪几种？ 分别有什么特点？
- 通常利用Executors提供的通用线程池创建方法，去创建不同配置的线程池,主要区别在于不同的ExecutorService类型或者不同的初始参数
- Executors目前提供了5种不同的线程池创建配置
    - newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点:
        - 它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程
        - 如果线程闲置的时间超过60S，则被终止并移出缓存
        - 长时间闲置时，这种线程池不会消耗资源
    - newFixedThreadPool(int  nThreads)：重用指定数目的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现，如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads
    - newSingleThreadExecutor()：它的特点在于工作线程数目被限制为1,操作一个无界的工作队列,所以它保证了所有任务的都是被顺序执行,最多会有一个任务处于活动状态,并且不允许使用者改造线程实例,因此可以避免其改变线程数目。
    - newSingleThreadScheduledExecutor()和newSecheduledThreadPool(int  corePoolSize),创建的是个ScheduledExecutorService,可以进行定时或周期性的工作调度,区别在于单一工作线程还是多个工作线程。

# ⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？
- ⾼并发、任务执⾏时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下⽂的切换
- 并发不⾼、任务执⾏时间⻓的业务要区分开看：
    - 假如是业务时间⻓集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占⽤CPU，所以不要让所有的CPU闲下来，可以加⼤线程池中的线程数⽬，让CPU处理更多的业务
    - 假如是业务时间⻓集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）⼀样吧，线程池中的线程数设置得少⼀些，减少线程上下⽂的切换
- 并发⾼、业务执⾏时间⻓，解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，看看这些业务⾥⾯某些数据是否能做缓存是第⼀步，增加服务器是第⼆步，⾄于线程池的设置，设置参考（2）。最后，业务执⾏时间⻓的问题，也可能需要分析⼀下，看看能不能使⽤中间件对任务进⾏拆分和解耦。

# 线程安全和线程不安全
#### 线程安全
- 线程安全就是多线程访问时，采⽤了加锁机制，当⼀个线程访问该类的某个数据时，进⾏保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使⽤。不会出现数据不⼀致或者数据污染。
- 线程安全是一个多线程环境下正确性的概念,也就是保证多线程环境下共享的可修改的状态的正确性,这里的状态反映在程序中其实可以看做是数据。
- 换个角度来看,如果状态不是共享的,或者不是可修改的,也就不存在线程安全问题,进而可以推理出保证线程安全的两个办法
    - 第一个是封装,我们可以将对象内部状态隐藏保护起来
    - 第二个是不可变。
- 线程安全需要保证几个基本特性
    - 原子性：简单来说就是相关操作不会中途被其他线程干扰,一般通过同步机制实现
    - 可见性：是一个线程修改了某个共享变量,其状态能够立即被其他线程知晓,通常被解释为将线程本地状态反映到主内存中,volatile关键字就是负责保证可见性的
    - 有序性：是保证线程内串行语义, 避免指令重排等

#### 线程不安全
- 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据
- 线程安全问题都是由全局变量及静态变量引起的
- 若每个线程中对全局变量、静态变量只有读操作，⽽⽆写操作，⼀般来说，这个全局变量是线程安全的
- 若有多个线程同时执⾏写操作，⼀般都需要考虑线程同步，否则的话就可能影响线程安全


# 如何保证集合是线程安全的?    ConcurrentHashMap 如何实现高效的线程安全?
- 在传统集合框架内部,除了Hashtable  Vector等同步容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个 同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等
- Vector 是⽤同步⽅法来实现线程安全的, ⽽和它相似的ArrayList不是线程安全的

# 为什么需要ConcurrentHashMap?
- Hashtable本身比较低效,因为它的实现基本就是put  get  size等各种方法加上&quot;synchronized&quot;
- 这就导致了所有并发操作都要竞争同一把锁,一个线程在进行同步操作时,其他线程只能等待,大大降低了并发操作的效率
- HashMap不是线程安全的,那么能不能利用Collections提供的同步包装器来解决问题
- 实际上同步器只是利用 输入Map构造了另一个同步版本,所有操作不再声明为synchronized方法,但是还是利用
- Hashtable或者同步包装版本,都只是适合在非高度并发的场景下

# ConcurrentHashMap工作机制
- 在早期的ConcurrentHashMap,其实现是基于分离锁,也就是将内部进行分段,里面则是HashEntry的数据
- 和HashMap类似,哈希相同的条目也是以链表形式存放。(简单点来说,就是在ConcurrentHashMap中,把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中)在构造的时候,Segment的数量由所谓的concurrentcyLevel来决定,默认是16,也可以在相应构造函数直接指定。注意,Java需要它是2的幂数值,如果输入是类似15这种非幂值,会自动调整到16之类2的幂数值。
- ConcurrentHashMap的工作机制就是通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。

# 什么是CAS
- CAS（compare and swap）的缩写，中⽂翻译成⽐较并交换。
- CAS 不通过JVM,直接利⽤java本地⽅ JNI（Java Native Interface为JAVA本地调⽤）,直接调⽤CPU 的cmpxchg（是汇编指令）指令
- 利⽤CPU的CAS指令，同时借助JNI来完成Java的⾮阻塞算法,实现原⼦操作。其它原⼦操作都是利⽤类似的特性完成的。
- 整个java.util.concurrent都是建⽴在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很⼤的提升。
- CAS是项乐观锁技术，当多个线程尝试使⽤CAS同时更新同⼀个变量时，只有其中⼀个线程能更新变量的值，⽽其它线程都失败，失败的线程并不会被挂起，⽽是被告知这次竞争中失败，并可以再次尝试
- 使⽤CAS在线程冲突严重时，会⼤幅降低程序性能；CAS只适合于线程冲突较少的情况使⽤。
- synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是⾃旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了⾼吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；⽽线程冲突严重的情况下，性能远⾼于CAS

# 什么是AQS
- AbstractQueuedSynchronizer简称AQS，是⼀个⽤于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等
- AQS解决了在实现同步容器时设计的⼤量细节问题。
- AQS使⽤⼀个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护⼀个等待状态waitStatus。

# 什么是原⼦操作？在Java Concurrency API中有哪些原⼦类(atomic classes)？
- 原⼦操作是指⼀个不受其他操作影响的操作任务单元
- 原⼦操作是在多线程环境下避免数据不⼀致必须的⼿段。
- int++并不是⼀个原⼦操作，所以当⼀个线程读取它的值并加1时，另外⼀个线程有可能会读到之前的值，这就会引发错误。
- 为了解决这个问题，必须保证增加操作是原⼦的，在JDK1.5之前我们可以使⽤同步技术来做到这⼀点到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以⾃动的保证对于他们的操作是原⼦的并且不需要使⽤同步

# 什么是阻塞队列
- 阻塞队列是⼀个在队列基础上⼜⽀持了两个附加操作的队列。
    - ⽀持阻塞的插⼊⽅法：队列满时，队列会阻塞插⼊元素的线程，直到队列不满。
    - ⽀持阻塞的移除⽅法：队列空时，获取元素的线程会等待队列变为⾮空。
- JDK7提供了7个阻塞队列
    - ArrayBlockingQueue ：⼀个由数组结构组成的有界阻塞队列。
    - LinkedBlockingQueue ：⼀个由链表结构组成的有界阻塞队列。
    - PriorityBlockingQueue ：⼀个⽀持优先级排序的⽆界阻塞队列。
    - DelayQueue：⼀个使⽤优先级队列实现的⽆界阻塞队列。
    - SynchronousQueue：⼀个不存储元素的阻塞队列。
    - LinkedTransferQueue：⼀个由链表结构组成的⽆界阻塞队列。
    - LinkedBlockingDeque：⼀个由链表结构组成的双向阻塞队列。

# 什么是同步容器和并发容器的实现？
#### 同步容器
- 主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。
- 锁的粒度为当前对象整体。
- 迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。

#### 并发容器
- 主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。
- 锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。
- 迭代器具有弱⼀致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。
- ConcurrentHashMap采⽤分段锁技术，同步容器中，是⼀个容器⼀个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若⼲段，每段维护⼀个锁，以达到⾼效的并发访问；

# ThreadLocal
#### ThreadLocal的设计理念与作⽤？
- Java中的ThreadLocal类允许我们创建只能被同⼀个线程读写的变量
- 如果⼀段代码含有⼀个ThreadLocal变量的引⽤，即使两个线程同时执⾏这段代码，它们也⽆法访问到对⽅的ThreadLocal变量

#### 概念
- 线程局部变量
- 变量是同⼀个，但是每个线程都使⽤同⼀个初始值，也就是使⽤同⼀个变量的⼀个新的副本。这种情况之下ThreadLocal就⾮常适⽤，⽐如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是⼀个线程安全的变量。⽽我们每个线程都需要使⽤他，并且各⾃使⽤各⾃的。这种情况，ThreadLocal就⽐较好的解决了这个问题。

#### 原理
- 从本质来讲，就是每个线程都维护了⼀个map，⽽这个map的key就是threadLocal，⽽值就是我们set的那个值
- 每次线程在get的时候，都从⾃⼰的变量中取值，既然从⾃⼰的变量中取值，那肯定就不存在线程安全问题
- ThreadLocal这个变量的状态根本没有发⽣变化，他仅仅是充当⼀个key的⻆⾊，另外提供给每⼀个线程⼀个初始值。

#### 实现机制
- 每个Thread对象内部都维护了⼀个ThreadLocalMap这样⼀个ThreadLocal的Map，可以存放若⼲个ThreadLocal。

#### 应⽤场景
- 当很多线程需要多次使⽤同⼀个对象，并且需要该对象具有相同初始化值的时候最适合使⽤ThreadLocal。

# Semaphore有什么作⽤？
- Semaphore就是⼀个信号量
- 作⽤是限制某段代码块的并发数

# Hashtable的size()⽅法中明明只有⼀条语句”return count”，为什么还要做同步？
- 同⼀时间只能有⼀条线程执⾏固定类的同步⽅法，但是对于类的⾮同步⽅法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执⾏Hashtable的put⽅法添加数据，线程B则可以正常调⽤size()⽅法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size⼀定是不准确的。
- ⽽给size()⽅法加了同步之后，意味着线程B调⽤size()⽅法只有在线程A调⽤put⽅法完毕之后才可以调⽤，这样就保证了线程安全性。

# ConcurrentHashMap的并发度是什么？
- ⼯作机制（分⽚思想）：它引⼊了⼀个“分段锁”的概念，具体可以理解为把⼀个⼤的Map拆分成N个⼩的segment，根据key.hashCode()来决定把key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。
- 应⽤：当读&gt;写时使⽤，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；
- hash冲突：
    - 简介：HashMap中调⽤hashCode()⽅法来计算hashCode。由于在Java中两个不同的对象可能有⼀样的hashCode,所以不同的键可能有⼀样hashCode，从⽽导致冲突的产⽣。
    - hash冲突解决：使⽤平衡树来代替链表，当同⼀hash中的元素数量超过特定的值便会由链表切换到平衡树
- ⽆锁读：ConcurrentHashMap之所以有较好的并发性是因为ConcurrentHashMap是⽆锁读和加锁写，并且利⽤了分段锁（不是在所有的entry上加锁，⽽是在⼀部分entry上加锁）；读之前会先判断count(jdk1.6)，其中的count是被volatile修饰的(当变量被volatile修饰后，每次更改该变量的时候会将更改结果写到系统主内存中，利⽤多处理器的缓存⼀致性，其他处理器会发现⾃⼰的缓存⾏对应的内存地址被修改，就会将⾃⼰处理器的缓存⾏设置为失效，并强制从系统主内存获取最新的数据。)，故可以实现⽆锁读。
- ConcurrentHashMap的并发度就是segment的⼤⼩，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最⼤优势。

# ReentrantReadWriteLock读写锁的使⽤
- 读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm⾃⼰控制的，你只要上好相应的锁即可
- 如果你的代码只读数据，可以很多⼈同时读，但不能同时写，那就上读锁
- 如果你的代码修改数据，只能有⼀个⼈在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁

# 锁的等级：⽅法锁、对象锁、类锁?
#### ⽅法锁（synchronized修饰⽅法时）
    - 通过在⽅法声明中加⼊ synchronized关键字来声明 synchronized ⽅法。
    - synchronized ⽅法控制对类成员变量的访问：
    - 每个类实例对应⼀把锁，每个 synchronized ⽅法都必须获得调⽤该⽅法的类实例的锁⽅能执⾏，否则所属线程阻塞，⽅法⼀旦执⾏，就独占该锁，直到从该⽅法返回时才将锁释放，此后被阻塞的线程⽅能获得该锁，重新进⼊可执⾏状态
    - 这种机制确保了同⼀时刻对于每⼀个类实例，其所有声明为 synchronized 的成员函数中⾄多只有⼀个处于可执⾏状态，从⽽有效避免了类成员变量的访问冲突。

#### 对象锁（synchronized修饰⽅法或代码块）
- 当⼀个对象中有synchronized method或synchronized block的时候调⽤此对象的同步⽅法或进⼊其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调⽤者占⽤，则需要等待此锁被释放。（⽅法锁也是对象锁）
- java的所有对象都含有1个互斥锁，这个锁由JVM⾃动获取和释放
- 线程进⼊synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待
- synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁
- 这⾥也体现了⽤synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来⾃动释放。　

#### 类锁(synchronized 修饰静态的⽅法或代码块)
- 由于⼀个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有⼀份。所以，⼀旦⼀个静态的⽅法被申明为synchronized。此类所有的实例化对象在调⽤此⽅法，共⽤同⼀把锁，我们称之为类锁。
- 对象锁是⽤来控制实例⽅法之间的同步，类锁是⽤来控制静态⽅法（或静态变量互斥体）之间的同步

# 如果同步块内的线程抛出异常会发⽣什么？
- synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁

# 并发编程（concurrency）并⾏编程（parallellism）有什么区别？
- 并⾏是指两个或者多个事件在同⼀时刻发⽣；⽽并发是指两个或多个事件在同⼀时间间隔发⽣。
- 并⾏是在不同实体上的多个事件，并发是在同⼀实体上的多个事件。
- 在⼀台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群所以并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能。

# 如何保证多线程下 i++ 结果正确？
- volatile只能保证你数据的可⻅性，获取到的是最新的数据，不能保证原⼦性；
- ⽤AtomicInteger保证原⼦性。
- synchronized既能保证共享变量可⻅性，也可以保证锁内操作的原⼦性。

# ⼀个线程如果出现了运⾏时异常会怎么样?
- 如果这个异常没有被捕获的话，这个线程就停⽌执⾏了。
- 另外重要的⼀点是：如果这个线程持有某个对象的监视器，那么这个对象监视器会被⽴即释放.

# 如何在两个线程之间共享数据?
- 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进⾏唤起和等待
- ⽐⽅说阻塞队列BlockingQueue就是为线程之间共享数据⽽设计的。

# 










# ⽣产者消费者模型的作⽤是什么?
- 通过平衡⽣产者的⽣产能⼒和消费者的消费能⼒来提升整个系统的运⾏效率，这是⽣产者消费者模型最重要的作⽤
- 解耦，这是⽣产者消费者模型附带的作⽤，解耦意味着⽣产者和消费者之间的联系少，联系越少越可以独⾃发展⽽不需要受到相互的制约。

# 怎么唤醒⼀个阻塞的线程?
- 如果线程是因为调⽤了wait()、sleep()或者join()⽅法⽽导致的阻塞
- suspend与resume，Java废弃suspend() 去挂起线程的原因，是因为suspend() 在导致线程暂停的同时，并不会释放任何锁资源。其他线程都⽆法访问被它占⽤的锁。直到对应的线程执⾏resume() ⽅法后，被挂起的线程才能继从⽽其它被阻塞在这个锁的线程才可以继续执⾏。但是，如果resume()操作出现在 suspend(之前执⾏，那么线程将⼀直处于挂起状态，同时⼀直占⽤锁，这就产⽣了死锁。⽽且，对于被挂起的线程，它的线程状态居然还是 Runnable。
- wait与notify，wait与notify必须配合synchronized使⽤，因为调⽤之前必须持有锁，wait会⽴即释放锁，notify则是同步块执⾏完了才释放
- await与singal，Condition类提供，⽽Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使⽤Lock锁后⽆法使⽤wait⽅法
- park与unpark
    LockSupport是⼀个⾮常⽅便实⽤的线程阻塞⼯具，它可以在线程任意位置让线程阻塞。和Thread.suspenf()相
    ⽐，它弥补了由于resume()在前发⽣，导致线程⽆法继续执⾏的情况。和Object.wait()相⽐，它不需要先获得某个对
    象的锁，也不会抛出IException异常。可以唤醒指定线程。

89. 如果线程遇到了IO阻塞，⽆能为⼒，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
90. Java中⽤到的线程调度算法是什么
91. 抢占式。⼀个线程⽤完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出⼀个总的优先级并分配下⼀
    个时间⽚给某个线程执⾏。
92. 单例模式的线程安全性?
    ⾸先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建⼀次出来。单
    例模式有很多种的写法，我总结⼀下：
    （1）饿汉式单例模式的写法：线程安全
    （2）懒汉式单例模式的写法：⾮线程安全
    （3）双检锁单例模式的写法：线程安全
93. 线程类的构造⽅法、静态块是被哪个线程调⽤的?
    线程类的构造⽅法、静态块是被new这个线程类所在的线程所调⽤的，⽽run⽅法⾥⾯的代码才是被线程⾃身所调⽤的。
94. 同步⽅法和同步块，哪个是更好的选择?
95. 同步块是更好的选择，因为它不会锁住整个对象（当然也可以让它锁住整个对象）。同步⽅法会锁住整个对象，哪怕
    这个类中有多个不相关联的同步块，这通常会导致他们停⽌执⾏并需要等待获得这个对象上的锁。
    synchronized(this)以及⾮static的synchronized⽅法（⾄于static synchronized⽅法请往下看），只能防⽌多个线程同时
    执⾏同⼀个对象的同步代码段。
    如果要锁住多个对象⽅法，可以锁住⼀个固定的对象，或者锁住这个类的Class对象。
    synchronized锁住的是括号⾥的对象，⽽不是代码。对于⾮static的synchronized⽅法，锁的就是对象本身也就是this。

97. 如何检测死锁？怎么预防死锁？
98. 概念：
    是指两个或两个以上的进程在执⾏过程中，因争夺资源⽽造成的⼀种互相等待的现象，若⽆外⼒作⽤，它们都将⽆
    法推进下去。此时称系统处于死锁；
99. 死锁的四个必要条件：
    i. 互斥条件：进程对所分配到的资源不允许其他进程进⾏访问，若其他进程访问该资源，只能等待，直⾄占有该资源
    的进程使⽤完成后释放该资源
    ii. 请求和保持条件：进程获得⼀定的资源之后，⼜对其他资源发出请求，但是该资源可能被其他进程占有，此时请
    求阻塞，但⼜对⾃⼰获得的资源保持不放
    iii. 不可剥夺条件：是指进程已获得的资源，在未完成使⽤之前，不可被剥夺，只能在使⽤完后⾃⼰释放
    iv. 环路等待条件：是指进程发⽣死锁后，若⼲进程之间形成⼀种头尾相接的循环等待资源关系
100.    死锁产⽣的原因：
        1.因竞争资源发⽣死锁 现象：系统中供多个进程共享的资源的数⽬不⾜以满⾜全部进程的需要时，就会引起对诸资
        源的竞争⽽发⽣死锁现象
        2.进程推进顺序不当发⽣死锁
101.    检查死锁
        i. 有两个容器，⼀个⽤于保存线程正在请求的锁，⼀个⽤于保存线程已经持有的锁。每次加锁之前都会做如下检测:
        ii. 检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来
        iii. 遍历第⼀步中返回的线程，检查⾃⼰持有的锁是否正被其中任何⼀个线程请求，如果第⼆步返回真,表示出现了死
        锁
102.    死锁的解除与预防：控制不要让四个必要条件成⽴。
103.    HashMap在多线程环境下使⽤需要注意什么？
        要注意死循环的问题，HashMap的put操作引发扩容，这个动作在多线程并发下会发⽣线程死循环的问题。
        2、多个线程同时扩容，造成数据丢失；
        3、多线程扩容时导致Node链表形成环形结构造成.next()死循环，导致CPU利⽤率接近100%；
104.    什么是守护线程？有什么⽤？
        守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程，这是它的作⽤——⽽其他的线程只有
        ⼀种，那就是⽤户线程。所以java⾥线程分2种，
        1、守护线程，⽐如垃圾回收线程，就是最典型的守护线程。
        2、⽤户线程，就是应⽤程序⾥的⾃定义线程。
105.    如何实现线程串⾏执⾏？
        a. 为了控制线程执⾏的顺序，如ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执⾏三个线程，我们需要确定唤醒、等待
        的顺序。这时我们可以同时使⽤ Obj.wait()、Obj.notify()与synchronized(Obj)来实现这个⽬标。
        线程中持有上⼀个线程类的对象锁以及⾃⼰的锁，由于这种依赖关系，该线程执⾏需要等待上个对象释放锁，从⽽
        保证类线程执⾏的顺序。
        b. 通常情况下，wait是线程在获取对象锁后，主动释放对象锁，同时本线程休眠，直到有其它线程调⽤对象的notify()唤
        醒该线程，才能继续获取对象锁，并继续执⾏。⽽notify()则是对等待对象锁的线程的唤醒操作。但值得注意的是notify()
        调⽤后，并不是⻢上就释放对象锁，⽽是在相应的synchronized()&#123;&#125;语句块执⾏结束。释放对象锁后，JVM会在执⾏
        wait()等待对象锁的线程中随机选取⼀线程，赋予其对象锁，唤醒线程，继续执⾏。

106.    可以运⾏时kill掉⼀个线程吗？
        a. 不可以
        b. 只有当线程run⽅法或者主线程main⽅法结束，⼜或者抛出异常时，线程才会结束⽣命周期。
107.    关于synchronized：
108.    在某个对象的所有synchronized⽅法中,在某个时刻只能有⼀个唯⼀的⼀个线程去访问这些synchronized⽅法
109.    如果⼀个⽅法是synchronized⽅法,那么该synchronized关键字表示给当前对象上锁(即this)相当于
        synchronized(this)&#123;&#125;
110.    如果⼀个synchronized⽅法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管⽣成
        多少对象,其对应的class对象只有⼀个)
111.    分步式锁,程序数据库中死锁机制及解决⽅案
        基本原理：⽤⼀个状态值表示锁，对锁的占⽤和释放通过状态值来标识。
        1、三种分布式锁：
        1、Zookeeper：基于zookeeper瞬时有序节点实现的分布式锁，其主要逻辑如下。⼤致思想即为：每个客户端对某个
        功能加锁时，在zookeeper上的与该功能对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点。判断是否获取锁的⽅式很简
        单，只需要判断有序节点中序号最⼩的⼀个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁
        ⽆法释放，⽽产⽣的死锁问题。

2、优点
锁安全性⾼，zk可持久化，且能实时监听获取锁的客户端状态。⼀旦客户端宕机，则瞬时节点随之消失，zk因
⽽能第⼀时间释放锁。这也省去了⽤分布式缓存实现锁的过程中需要加⼊超时时间判断的这⼀逻辑。
3、缺点
性能开销⽐较⾼。因为其需要动态产⽣、销毁瞬时节点来实现锁功能。所以不太适合直接提供给⾼并发的场景
使⽤。
4、实现
可以直接采⽤zookeeper第三⽅库curator即可⽅便地实现分布式锁。
5、适⽤场景
对可靠性要求⾮常⾼，且并发程度不⾼的场景下使⽤。如核⼼数据的定时全量/增量同步等。
2、memcached：memcached带有add函数，利⽤add函数的特性即可实现分布式锁。add和set的区别在于：如果多
线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。⽽add的话则相反，add会添加第⼀个到达的值，并
返回true，后续的添加则都会返回false。利⽤该点即可很轻松地实现分布式锁。
2、优点
并发⾼效
3、缺点
memcached采⽤列⼊LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。
memcached⽆法持久化，⼀旦重启，将导致信息丢失。
4、使⽤场景
⾼并发场景。需要 1)加上超时时间避免死锁; 2)提供⾜够⽀撑锁服务的内存空间; 3)稳定的集群化管理。
3、redis：redis分布式锁即可以结合zk分布式锁锁⾼度安全和memcached并发场景下效率很好的优点，其实现⽅式和
memcached类似，采⽤setnx即可实现。需要注意的是，这⾥的redis也需要设置超时时间，以避免死锁。
2、数据库死锁机制和解决⽅案：
1、死锁：死锁是指两个或者两个以上的事务在执⾏过程中，因争夺锁资源⽽造成的⼀种互相等待的现象。
2、处理机制：解决死锁最有⽤最简单的⽅法是不要有等待，将任何等待都转化为回滚，并且事务重新开始。但是有可能
影响并发性能。
1、超时回滚，innodb\_lock\_wait\_time设置超时时间；
2、wait-for-graph⽅法：跟超时回滚⽐起来，这是⼀种更加主动的死锁检测⽅式。InnoDB引擎也采⽤这种⽅
式。

1.  spring单例为什么没有安全问题(ThreadLocal)
    1、ThreadLocal：spring使⽤ThreadLocal解决线程安全问题；ThreadLocal会为每⼀个线程提供⼀个独⽴的变量副本，从⽽
    隔离了多个线程对数据的访问冲突。
    2、单例：⽆状态的Bean(⽆状态就是⼀次操作，不能保存数据。⽆状态对象(Stateless Bean)，就是没有实例变量的对象，不
    能保存数据，是不变类，是线程安全的。)适合⽤不变模式，技术就是单例模式，这样可以共享实例，提⾼性能。
2.  线程池原理：
    1、使⽤场景：使⽤线程池，以提⾼服务器性能；
    2、组成：
    1、线程池管理器（ThreadPool）：⽤于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
    2、⼯作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执⾏任务；
    3、任务接⼝（Task）：每个任务必须实现的接⼝，以供⼯作线程调度任务的执⾏，它主要规定了任务的⼊⼝，任务执⾏完后
    的收尾⼯作，任务的执⾏状态等；
    4、任务队列（taskQueue）：⽤于存放没有处理的任务。提供⼀种缓冲机制。
    2、原理：线程池技术正是关注如何缩短或调整T1,T3时间的技术，从⽽提⾼服务器程序性能的。它把T1，T3分别安排在服务器程
    序的启动和结束的时间段或者⼀些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。
    3、⼯作流程：
    1、线程池刚创建时，⾥⾯没有⼀个线程(也可以设置参数prestartAllCoreThreads启动预期数量主线程)。任务队列是作
    为参数传进来的。不过，就算队列⾥⾯有任务，线程池也不会⻢上执⾏它们。
    2、当调⽤ execute() ⽅法添加⼀个任务时，线程池会做如下判断：
3.  如果正在运⾏的线程数量⼩于 corePoolSize，那么⻢上创建线程运⾏这个任务；
4.  如果正在运⾏的线程数量⼤于或等于 corePoolSize，那么将这个任务放⼊队列；
5.  如果这时候队列满了，⽽且正在运⾏的线程数量⼩于 maximumPoolSize，那么还是要创建⾮核⼼线程⽴刻运⾏这个
    任务；
6.  如果队列满了，⽽且正在运⾏的线程数量⼤于或等于 maximumPoolSize，那么线程池会抛出异常
    RejectExecutionException。
    3、当⼀个线程完成任务时，它会从队列中取下⼀个任务来执⾏。
    4、当⼀个线程⽆事可做，超过⼀定的时间（keepAliveTime）时，线程池会判断，如果当前运⾏的线程数⼤于
    corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的⼤⼩。
7.  java锁多个对象：
    例如： 在银⾏系统转账时，需要锁定两个账户，这个时候，顺序使⽤两个synchronized可能存在死锁的情况，在⽹上搜索到下⾯的例
    ⼦：
    1 public class Bank &#123;
    2 final static Object obj\_lock = new Object();
    3
    4 // Deadlock crisis 死锁
    5 public void transferMoney(Account from, Account to, int number) &#123;
    6 synchronized (from) &#123;
    7 synchronized (to) &#123;
    8 from.debit();
    9 to.credit();
    10 &#125;
    11 &#125;
    12 &#125;
    13
    14 // Thread safe
    15 public void transferMoney2(final Account from, final Account to, int number) &#123;
    16 class Help &#123;
    17 void transferMoney2() &#123;
    18 from.debit();
    19 to.credit();
    20 &#125;
    21 &#125;
    22
    23 //通过hashCode⼤⼩调整加锁顺序
    24 int fromHash = from.hashCode();
    25 int toHash = to.hashCode();
    26
    27 if (fromHash &lt; toHash) &#123;
    28 synchronized (from) &#123;
    29 synchronized (to) &#123;
    30 new Help().transferMoney2();
    31 &#125;
    32 &#125;
    33 &#125; else if (toHash &lt; fromHash) &#123;
    34 synchronized (to) &#123;
    35 synchronized (from) &#123;
    36 new Help().transferMoney2();
    37 &#125;
    38 &#125;
    39 &#125; else &#123;
    40 synchronized (obj\_lock) &#123;
    41 synchronized (to) &#123;
    42 synchronized (from) &#123;
    43 new Help().transferMoney2();
    44 &#125;
    45 &#125;
    46 &#125;
    47 &#125;
    48 &#125;
    49 &#125;
    若操作账户A，B：
8.  A的hashCode⼩于B， 先锁A再锁B
9.  B的hashCode⼩于A， 先锁B再锁A
10. 产⽣的hashCode相等，先锁住⼀个全局静态变量，在锁A，B
    这样就避免了两个线程分别操作账户A,B和B,A⽽产⽣死锁的情况。
    需要为Account对象写⼀个好的hashCode算法，使得不同账户间产⽣的hashCode尽量不同。
11. java线程如何启动：
    1、继承Thread类；
    2、实现Runnable接⼝；
    3、直接在函数体内：
    4、⽐较：
    1、实现Runnable接⼝优势：
    1）适合多个相同的程序代码的线程去处理同⼀个资源
    2）可以避免java中的单继承的限制
    3）增加程序的健壮性，代码可以被多个线程共享，代码和数据独⽴。
    2、继承Thread类优势：
    1）可以将线程类抽象出来，当需要使⽤抽象⼯⼚模式设计时。
    2）多线程同步
    3、在函数体使⽤优势
    1）⽆需继承thread或者实现Runnable，缩⼩作⽤域。
12. java中加锁的⽅式有哪些,如何实现怎么个写法.
    1、java中有两种锁：⼀种是⽅法锁或者对象锁(在⾮静态⽅法或者代码块上加锁)，第⼆种是类锁(在静态⽅法或者class上加锁)；
    2、注意：其他线程可以访问未加锁的⽅法和代码；synchronized同时修饰静态⽅法和实例⽅法，但是运⾏结果是交替进⾏的，这证明
    了类锁和对象锁是两个不⼀样的锁，控制着不同的区域，它们是互不⼲扰的。
    3、示例代码：
    1、⽅法锁和同步代码块：
    1 public class TestSynchronized
    2 &#123;
    3 public void test1()
    4 &#123;
    5 synchronized(this)
    6 &#123;
    7 int i = 5;
    8 while( i-- &gt; 0)
    9 &#123;
    10 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
    11 try
    12 &#123;
    13 Thread.sleep(500);
    14 &#125;
    15 catch (InterruptedException ie)
    16 &#123;
    17 &#125;
    18 &#125;
    19 &#125;
    20 &#125;
    21
    22 public synchronized void test2()
    23 &#123;
    24 int i = 5;
    25 while( i-- &gt; 0)
    26 &#123;
    27 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
    28 try
    29 &#123;
    30 Thread.sleep(500);
    31 &#125;
    32 catch (InterruptedException ie)
    33 &#123;
    34 &#125;
    35 &#125;
    36 &#125;
    37
    38 public static void main(String\[] args)
    39 &#123;
    40 final TestSynchronized myt2 = new TestSynchronized();
    41 Thread test1 = new Thread( new Runnable() &#123; public void run() &#123; myt2.test1(); &#125; &#125;,
    42 Thread test2 = new Thread( new Runnable() &#123; public void run() &#123; myt2.test2(); &#125; &#125;,
    43 test1.start();;
    44 test2.start();
    45 // TestRunnable tr=new TestRunnable();
    46 // Thread test3=new Thread(tr);
    47 // test3.start();
    48 &#125;
    49 &#125;
    2、类锁：
    1 public class TestSynchronized
    2 &#123;
    3 public void test1()
    4 &#123;
    5 synchronized(TestSynchronized.class)
    6 &#123;
    7 int i = 5;
    8 while( i-- &gt; 0)
    9 &#123;
    10 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
    11 try
    12 &#123;
    13 Thread.sleep(500);
    14 &#125;
    15 catch (InterruptedException ie)
    16 &#123;
    17 &#125;
    18 &#125;
    19 &#125;
    20 &#125;
    21
    22 public static synchronized void test2()
    23 &#123;
    24 int i = 5;
    25 while( i-- &gt; 0)
    26 &#123;
    27 System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
    28 try
    29 &#123;
    30 Thread.sleep(500);
    31 &#125;
    32 catch (InterruptedException ie)
    33 &#123;
    34 &#125;
    35 &#125;
    36 &#125;
    37
    38 public static void main(String\[] args)
    39 &#123;
    40 final TestSynchronized myt2 = new TestSynchronized();
    41 Thread test1 = new Thread( new Runnable() &#123; public void run() &#123; myt2.test1(); &#125; &#125;,
    42 Thread test2 = new Thread( new Runnable() &#123; public void run() &#123; TestSynchronized.test2
    43 test1.start();
    44 test2.start();
    45 // TestRunnable tr=new TestRunnable();
    46 // Thread test3=new Thread(tr);
    47 // test3.start();
    48 &#125;
    49
    50 &#125;
    62、如何保证数据不丢失：
    1、使⽤消息队列，消息持久化；
    2、添加标志位：未处理 0，处理中 1，已处理 2。定时处理。
    63、ThreadLocal为什么会发⽣内存泄漏？
    1、threadlocal原理图：
    2、OOM实现：
    1、ThreadLocal的实现是这样的：每个Thread 维护⼀个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实
    例本身，value 是真正需要存储的 Object。
    2、也就是说 ThreadLocal 本身并不存储值，它只是作为⼀个 key 来让线程从 ThreadLocalMap 获取 value。值得注意的
    是图中的虚线，表示 ThreadLocalMap 是使⽤ ThreadLocal 的弱引⽤作为 Key 的，弱引⽤的对象在 GC 时会被回收。
    3、ThreadLocalMap使⽤ThreadLocal的弱引⽤作为key，如果⼀个ThreadLocal没有外部强引⽤来引⽤它，那么系统 GC
    的时候，这个ThreadLocal势必会被回收，这样⼀来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这
    些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会⼀直存在⼀条强引⽤
    链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远⽆法回收，造成内存泄漏。
    3、预防办法：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap⾥所有key为null的value。
    但是这些被动的预防措施并不能保证不会内存泄漏：
    （1）使⽤static的ThreadLocal，延⻓了ThreadLocal的⽣命周期，可能导致内存泄漏。
    （2）分配使⽤了ThreadLocal⼜不再调⽤get(),set(),remove()⽅法，那么就会导致内存泄漏，因为这块内存⼀直存在。
    64、jdk8中对ConcurrentHashmap的改进
13. Java 7为实现并⾏访问，引⼊了Segment这⼀结构，实现了分段锁，理论上最⼤并发度与Segment个数相等。
14. Java 8为进⼀步提⾼并发性，摒弃了分段锁的⽅案，⽽是直接使⽤⼀个⼤的数组。同时为了提⾼哈希碰撞下的寻址性能，
    Java 8在链表⻓度超过⼀定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红⿊树（寻址时间复杂度为O(long(N))）。
    其数据结构如下图所示
    3、源码：
    1 public V put(K key, V value) &#123;
    2 return putVal(key, value, false);
    3 &#125;
    4
    5 /\*\* Implementation for put and putIfAbsent \*/
    6 final V putVal(K key, V value, boolean onlyIfAbsent) &#123;
    7 //ConcurrentHashMap 不允许插⼊null键，HashMap允许插⼊⼀个null键
    8 if (key == null || value == null) throw new NullPointerException();
    9 //计算key的hash值
    10 int hash = spread(key.hashCode());
    11 int binCount = 0;
    12 //for循环的作⽤：因为更新元素是使⽤CAS机制更新，需要不断的失败重试，直到成功为⽌。
    13 for (Node\&lt;K,V&gt;\[] tab = table;;) &#123;
    14 // f：链表或红⿊⼆叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。
    15 Node\&lt;K,V&gt; f; int n, i, fh;
    16 //判断Node\[]数组是否初始化，没有则进⾏初始化操作
    17 if (tab == null || (n = tab.length) == 0)
    18 tab = initTable();
    19 //通过hash定位Node\[]数组的索引坐标，是否有Node节点，如果没有则使⽤CAS进⾏添加（链表的头结点），添加失败则进⼊下次循环。
    20 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;
    21 if (casTabAt(tab, i, null,
    22 new Node\&lt;K,V&gt;(hash, key, value, null)))
    23 break; // no lock when adding to empty bin
    24 &#125;
    25 //检查到内部正在移动元素（Node\[] 数组扩容）
    26 else if ((fh = f.hash) == MOVED)
    27 //帮助它扩容
    28 tab = helpTransfer(tab, f);
    29 else &#123;
    30 V oldVal = null;
    31 //锁住链表或红⿊⼆叉树的头结点
    32 synchronized (f) &#123;
    33 //判断f是否是链表的头结点
    34 if (tabAt(tab, i) == f) &#123;
    35 //如果fh&gt;=0 是链表节点
    36 if (fh &gt;= 0) &#123;
    37 binCount = 1;
    38 //遍历链表所有节点
    39 for (Node\&lt;K,V&gt; e = f;; ++binCount) &#123;
    40 K ek;
    41 //如果节点存在，则更新value
    42 if (e.hash == hash &amp;&amp;
    43 ((ek = e.key) == key ||
    44 (ek != null &amp;&amp; key.equals(ek)))) &#123;
    45 oldVal = e.val;
    46 if (!onlyIfAbsent)
    47 e.val = value;
    48 break;
    49 &#125;
    50 //不存在则在链表尾部添加新节点。
    51 Node\&lt;K,V&gt; pred = e;
    52 if ((e = e.next) == null) &#123;
    53 pred.next = new Node\&lt;K,V&gt;(hash, key,
    54 value, null);
    55 break;
    56 &#125;
    57 &#125;
    58 &#125;
    59 //TreeBin是红⿊⼆叉树节点
    60 else if (f instanceof TreeBin) &#123;
    61 Node\&lt;K,V&gt; p;
    62 binCount = 2;
    63 //添加树节点
    64 if ((p = ((TreeBin\&lt;K,V&gt;)f).putTreeVal(hash, key,
    65 value)) != null) &#123;
    66 oldVal = p.val;
    67 if (!onlyIfAbsent)
    68 p.val = value;
    69 &#125;
    70 &#125;
    71 &#125;
    72 &#125;
    73
    74 if (binCount != 0) &#123;
    75 //如果链表⻓度已经达到临界值8 就需要把链表转换为树结构
    76 if (binCount &gt;= TREEIFY\_THRESHOLD)
    77 treeifyBin(tab, i);
    78 if (oldVal != null)
    79 return oldVal;
    80 break;
    81 &#125;
    82 &#125;
    83 &#125;
    84 //将当前ConcurrentHashMap的size数量+1
    85 addCount(1L, binCount);
    86 return null;
    87 &#125;
    65、concurrent包下有哪些类？
    ConcurrentHashMap、Future、FutureTask、AtomicInteger...
    66、线程a,b,c,d运⾏任务，怎么保证当a,b,c线程执⾏完再执⾏d线程?
    1、CountDownLatch类
    ⼀个同步辅助类，常⽤于某个条件发⽣后才能执⾏后续进程。给定计数初始化CountDownLatch，调⽤countDown(）⽅
    法，在计数到达零之前，await⽅法⼀直受阻塞。
    重要⽅法为countdown()与await()；
    2、join⽅法
    将线程B加⼊到线程A的尾部，当A执⾏完后B才执⾏。
    1 public static void main(String\[] args) throws Exception &#123;
    2 Th t = new Th(&quot;t1&quot;);
    3 Th t2 = new Th(&quot;t2&quot;);
    4 t.start();
    5 t.join();
    6 t2.start();
    7 &#125;
    3、notify、wait⽅法，Java中的唤醒与等待⽅法，关键为synchronized代码块，参数线程间应相同，也常⽤Object作为参
    数。
    67、⾼并发系统如何做性能优化？如何防⽌库存超卖？
    1、⾼并发系统性能优化：
    优化程序，优化服务配置，优化系统配置
    1.尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。
    2.⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。
    3.优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。
    4.优化数据库结构，多做索引，提⾼查询效率。
    5.统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。
    6.能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。
    7.解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。
    2、防⽌库存超卖：
    1、悲观锁：在更新库存期间加锁，不允许其它线程修改；
    1、数据库锁：select xxx for update；
    2、分布式锁；
    2、乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失
    败。
    1、redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。
    3、消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。
    4、总结：总的来说，不能把压⼒放在数据库上，所以使⽤ &quot;select xxx for update&quot; 的⽅式在⾼并发的场景下是不可⾏
    的。FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤。所以相对来说，我会倾向于
    选择：乐观锁 / 缓存锁 / 分布式锁的⽅式。
    68、线程池的参数配置，为什么java官⽅提供⼯⼚⽅法给线程池？
    1、线程池简介：
    2、核⼼参数：
    3、⼯⼚⽅法作⽤：ThreadPoolExecutor类就是Executor的实现类，但ThreadPoolExecutor在使⽤上并不是那么⽅便，在实
    例化时需要传⼊很多歌参数，还要考虑线程的并发数等与线程池运⾏效率有关的参数，所以官⽅建议使⽤Executors⼯程类来
    创建线程池对象。
    69、说说java同步机制，java有哪些锁，每个锁的特性？
    70、说说volatile如何保证可⻅性，从cpu层⾯分析？

JAVA多线程之线程间的通信方式
一，介绍
本总结我对于JAVA多线程中线程之间的通信方式的理解，主要以代码结合文字的方式来讨论线程间的通信，故摘抄了书中的一些示例代码。
 
二，线程间的通信方式
①同步
这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。
参考示例：

public class MyObject &#123;

    synchronized public void methodA() &#123;
        //do something....
    &#125;

    synchronized public void methodB() &#123;
        //do some other thing
    &#125;

&#125;

public class ThreadA extends Thread &#123;

    private MyObject object;

//省略构造方法
@Override
public void run() &#123;
super.run();
object.methodA();
&#125;
&#125;

public class ThreadB extends Thread &#123;

    private MyObject object;

//省略构造方法
@Override
public void run() &#123;
super.run();
object.methodB();
&#125;
&#125;

public class Run &#123;
public static void main(String\[] args) &#123;
MyObject object = new MyObject();

        //线程A与线程B 持有的是同一个对象:object
        ThreadA a = new ThreadA(object);
        ThreadB b = new ThreadB(object);
        a.start();
        b.start();
    &#125;

&#125;

由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。
这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。
 
②while轮询的方式
代码如下：
import java.util.ArrayList;
import java.util.List;

public class MyList &#123;

    private List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    public void add() &#123;
        list.add(&quot;elements&quot;);
    &#125;
    public int size() &#123;
        return list.size();
    &#125;

&#125;

import mylist.MyList;

public class ThreadA extends Thread &#123;

    private MyList list;

    public ThreadA(MyList list) &#123;
        super();
        this.list = list;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                list.add();
                System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素&quot;);
                Thread.sleep(1000);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

import mylist.MyList;

public class ThreadB extends Thread &#123;

    private MyList list;

    public ThreadB(MyList list) &#123;
        super();
        this.list = list;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            while (true) &#123;
                if (list.size() == 5) &#123;
                    System.out.println(&quot;==5, 线程b准备退出了&quot;);
                    throw new InterruptedException();
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

import mylist.MyList;
import extthread.ThreadA;
import extthread.ThreadB;

public class Test &#123;

    public static void main(String[] args) &#123;
        MyList service = new MyList();

        ThreadA a = new ThreadA(service);
        a.setName(&quot;A&quot;);
        a.start();

        ThreadB b = new ThreadB(service);
        b.setName(&quot;B&quot;);
        b.start();
    &#125;

&#125;
在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信。但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是： 在干别的事情，当有电话来时，响铃通知TA电话来了。关于线程的轮询的影响，可参考：JAVA多线程之当一个线程在执行死循环时会影响另外一个线程吗？
这种方式还存在另外一个问题：
轮询的条件的可见性问题，关于内存可见性问题，可参考：JAVA多线程之volatile 与 synchronized 的比较中的第一点“一，volatile关键字的可见性”
线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的 条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。
 
③wait/notify机制
代码如下：
import java.util.ArrayList;
import java.util.List;

public class MyList &#123;

    private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();

    public static void add() &#123;
        list.add(&quot;anyString&quot;);
    &#125;

    public static int size() &#123;
        return list.size();
    &#125;

&#125;

public class ThreadA extends Thread &#123;

    private Object lock;

    public ThreadA(Object lock) &#123;
        super();
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            synchronized (lock) &#123;
                if (MyList.size() != 5) &#123;
                    System.out.println(&quot;wait begin &quot;
                            + System.currentTimeMillis());
                    lock.wait();
                    System.out.println(&quot;wait end  &quot;
                            + System.currentTimeMillis());
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

public class ThreadB extends Thread &#123;
private Object lock;

    public ThreadB(Object lock) &#123;
        super();
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            synchronized (lock) &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    MyList.add();
                    if (MyList.size() == 5) &#123;
                        lock.notify();
                        System.out.println(&quot;已经发出了通知&quot;);
                    &#125;
                    System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;);
                    Thread.sleep(1000);
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

public class Run &#123;

    public static void main(String[] args) &#123;

        try &#123;
            Object lock = new Object();

            ThreadA a = new ThreadA(lock);
            a.start();

            Thread.sleep(50);

            ThreadB b = new ThreadB(lock);
            b.start();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;
线程A要等待某个条件满足时(list.size()==5)，才执行操作。线程B则向list中添加元素，改变list 的size。
A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？
这里用到了Object类的 wait() 和 notify() 方法。
当条件未满足时(list.size() !=5)，线程A调用wait() 放弃CPU，并进入阻塞状态。---不像②while轮询那样占用CPU
当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。
这种方式的一个好处就是CPU的利用率提高了。
但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。
 
④管道通信就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信
具体就不介绍了。分布式系统中说的两种通信机制：共享内存机制和消息通信机制。感觉前面的①中的synchronized关键字和②中的while轮询 “属于” 共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流。
而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。

线程池详解（ThreadPoolExecutor）
前言
在实现异步时，基本都是使用线程池来实现，线程池在工作应用的还是比较频繁的，本文将就线程池的使用、相关原理和主要方法源码进行深入讲解学习。
线程池的基本使用
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
public class ThreadPoolExecutorTest &#123;
/\*\*
\* 创建一个线程池(完整入参):
\* 核心线程数为5 (corePoolSize),
\* 最大线程数为10 (maximumPoolSize),
\* 存活时间为60分钟(keepAliveTime),
\* 工作队列为LinkedBlockingQueue (workQueue),
\* 线程工厂为默认的DefaultThreadFactory (threadFactory),
\* 饱和策略(拒绝策略)为AbortPolicy: 抛出异常(handler).
*/
private static ExecutorService THREAD\_POOL = new ThreadPoolExecutor(5, 10, 60, TimeUnit.MINUTES,
new LinkedBlockingQueue\&lt;Runnable&gt;(), Executors.defaultThreadFactory(),
new ThreadPoolExecutor.AbortPolicy());
/*\*
\* 只有一个线程的线程池 没有超时时间, 工作队列使用无界的LinkedBlockingQueue
*/
private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
// private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());
/*\*
\* 有固定线程的线程池(即corePoolSize = maximumPoolSize) 没有超时时间,
\* 工作队列使用无界的LinkedBlockingQueue
*/
private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
// private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5, Executors.defaultThreadFactory());
/*\*
\* 大小不限的线程池 核心线程数为0, 最大线程数为Integer.MAX\_VALUE, 存活时间为60秒 该线程池可以无限扩展,
\* 并且当需求降低时会自动收缩, 工作队列使用同步移交SynchronousQueue.
*/
private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
// private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool(Executors.defaultThreadFactory());
/*\*
\* 给定的延迟之后运行任务, 或者定期执行任务的线程池
\*/
private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
// private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5, Executors.defaultThreadFactory());

    public static void main(String args[]) throws Exception &#123;
       /**
         * 例子1: 没有返回结果的异步任务
         */
        THREAD_POOL.submit(new Runnable() &#123;
            @Override
            public void run() &#123;
                // do something
                System.out.println(&quot;没有返回结果的异步任务&quot;);
            &#125;
        &#125;);
         /**
         * 例子2: 有返回结果的异步任务
         */
        Future&lt;List&lt;String&gt;&gt; future = THREAD_POOL.submit(new Callable&lt;List&lt;String&gt;&gt;() &#123;
            @Override
            public List&lt;String&gt; call() &#123;
                List&lt;String&gt; result = new ArrayList&lt;&gt;();
                result.add(&quot;JoonWhee&quot;);
                return result;
            &#125;
        &#125;);
        List&lt;String&gt; result = future.get(); // 获取返回结果
        System.out.println(&quot;有返回结果的异步任务: &quot; + result);
         /**
         * 例子3: 
         * 有延迟的, 周期性执行异步任务
         * 本例子为: 延迟1秒, 每2秒执行1次
         */
        scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;this is &quot; + Thread.currentThread().getName());
            &#125;
         &#125;, 1, 2, TimeUnit.SECONDS);
        /**
         * 例子4: FutureTask的使用
         */
        Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;
            public String call() &#123;
                return &quot;JoonWhee&quot;;
            &#125;
        &#125;;      
        FutureTask&lt;String&gt; futureTo = new FutureTask&lt;String&gt;(task);
        THREAD_POOL.submit(futureTo);
        System.out.println(futureTo.get()); // 获取返回结果

//        System.out.println(futureTo.get(3, TimeUnit.SECONDS));  // 超时时间为3秒
&#125;
&#125;
线程池的定义和优点
线程池，从字面含义来看，是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
“在线程池中执行任务“”比“为每个线程分配一个任务”优势更多。通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。
线程池的工作流程
1.默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） 
2.当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  
3.当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  
4.当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。
5.当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 
6.如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。

工作队列
如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源。常见的工作队列有以下几种，前三种用的最多。
1.ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。
2.LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界/无界队列，先进先出。
3.SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue才有实际价值.
4.PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。

5.DelayedWorkQueue：延迟的工作队列，无界队列。

饱和策略（拒绝策略）
当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。（如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略）。饱和策略有以下四种，一般使用默认的AbortPolicy。
1.AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。

2.DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。

3.DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。

4.CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。

线程工厂
每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法。Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。
1.DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。
2.PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。
3.自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。

ThreadPoolExecutor源码解析
几个点
了解这几个点，有助于你阅读下面的源码解释。
1.下面的源码解读中提到的运行状态就是runState，有效的线程数就是workerCount，内容比较多，所以可能两种写法都用到。
2.运行状态的一些定义：RUNNING：接受新任务并处理排队任务； SHUTDOWN：不接受新任务，但处理排队任务； STOP：不接受新任务，不处理排队任务，并中断正在进行的任务；TIDYING：所有任务已经终止，workerCount为零，线程转换到状态TIDYING将运行terminate()钩子方法；TERMINATED：terminated()已经完成，该方法执行完毕代表线程池已经完全终止。
3.运行状态之间并不是随意转换的，大多数状态都只能由固定的状态转换而来，转换关系见第4点\~第8点。
4.RUNNING - &gt; SHUTDOWN：在调用shutdown()时，可能隐含在finalize()。
5.(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()。
6.SHUTDOWN - &gt; TIDYING：当队列和线程池都是空的时。

7.STOP - &gt; TIDYING：当线程池为空时。

8.TIDYING - &gt; TERMINATED：当terminate()方法完成时。

基础属性（很重要）
/\*\*

*   主池控制状态ctl是包含两个概念字段的原子整数: workerCount：指有效的线程数量；
*   runState：指运行状态，运行，关闭等。为了将workerCount和runState用1个int来表示，
*   我们限制workerCount范围为(2 ^ 29) - 1，即用int的低29位用来表示workerCount，
*   用int的高3位用来表示runState，这样workerCount和runState刚好用int可以完整表示。
    \*/
    // 初始化时有效的线程数为0, 此时ctl为: 1010 0000 0000 0000 0000 0000 0000 0000
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // 高3位用来表示运行状态，此值用于运行状态向左移动的位数，即29位
    private static final int COUNT\_BITS = Integer.SIZE - 3;\
    // 线程数容量，低29位表示有效的线程数, 0001 1111 1111 1111 1111 1111 1111 1111
    private static final int CAPACITY   = (1 &lt;&lt; COUNT\_BITS) - 1;

/\*\*

*   大小关系：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED，
*   源码中频繁使用大小关系来作为条件判断。
*   1010 0000 0000 0000 0000 0000 0000 0000 运行
*   0110 0000 0000 0000 0000 0000 0000 0000 关闭
*   0110 0000 0000 0000 0000 0000 0000 0000 停止
*   0110 0000 0000 0000 0000 0000 0000 0000 整理
*   0110 0000 0000 0000 0000 0000 0000 0000 终止
    \*/
    private static final int RUNNING    = -1 &lt;&lt; COUNT\_BITS; // 运行
    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT\_BITS; // 关闭
    private static final int STOP       =  1 &lt;&lt; COUNT\_BITS; // 停止
    private static final int TIDYING    =  2 &lt;&lt; COUNT\_BITS; // 整理
    private static final int TERMINATED =  3 &lt;&lt; COUNT\_BITS; // 终止

/\*\*

*   得到运行状态:入参c为ctl的值，\~CAPACITY高3位为1低29位全为0,
*   因此运算结果为ctl的高3位, 也就是运行状态
    */
    private static int runStateOf(int c)     &#123; return c &amp; \~CAPACITY; &#125;\
    /*\*
*   得到有效的线程数:入参c为ctl的值, CAPACITY高3为为0,
*   低29位全为1, 因此运算结果为ctl的低29位, 也就是有效的线程数
    */
    private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;\
    /*\*
*   得到ctl的值：高3位的运行状态和低29位的有效线程数进行或运算,
*   组合成一个完成的32位数
    \*/
    private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;

// 状态c是否小于s
private static boolean runStateLessThan(int c, int s) &#123;
return c &lt; s;
&#125;
// 状态c是否大于等于s
private static boolean runStateAtLeast(int c, int s) &#123;
return c &gt;= s;
&#125;
// 状态c是否为RUNNING（小于SHUTDOWN的状态只有RUNNING）
private static boolean isRunning(int c) &#123;
return c &lt; SHUTDOWN;
&#125;

// 使用CAS增加一个有效的线程
private boolean compareAndIncrementWorkerCount(int expect) &#123;\
return ctl.compareAndSet(expect, expect + 1);
&#125;

// 使用CAS减少一个有效的线程
private boolean compareAndDecrementWorkerCount(int expect) &#123;\
return ctl.compareAndSet(expect, expect - 1);
&#125;

// 减少一个有效的线程
private void decrementWorkerCount() &#123;
do &#123;&#125; while (! compareAndDecrementWorkerCount(ctl.get()));
&#125;

// 工作队列
private final BlockingQueue\&lt;Runnable&gt; workQueue;

// 锁
private final ReentrantLock mainLock = new ReentrantLock();

// 包含线程池中的所有工作线程,只有在mainLock的情况下才能访问,Worker集合
private final HashSet\&lt;Worker&gt; workers = new HashSet\&lt;Worker&gt;();

private final Condition termination = mainLock.newCondition();

// 跟踪线程池的最大到达大小，仅在mainLock下访问
private int largestPoolSize;

// 总的完成的任务数
private long completedTaskCount;

// 线程工厂，用于创建线程
private volatile ThreadFactory threadFactory;

// 拒绝策略
private volatile RejectedExecutionHandler handler;

/\*\*

*   线程超时时间，当线程数超过corePoolSize时生效,
*   如果有线程空闲时间超过keepAliveTime, 则会被终止
    \*/
    private volatile long keepAliveTime;

// 是否允许核心线程超时，默认false，false情况下核心线程会一直存活。
private volatile boolean allowCoreThreadTimeOut;

// 核心线程数
private volatile int corePoolSize;

// 最大线程数
private volatile int maximumPoolSize;

// 默认饱和策略（拒绝策略）, 抛异常
private static final RejectedExecutionHandler defaultHandler =
new AbortPolicy();

private static final RuntimePermission shutdownPerm =
new RuntimePermission(&quot;modifyThread&quot;);

/\*\*

*   Worker类，每个Worker包含一个线程、一个初始任务、一个任务计算器
    \*/
    private final class Worker\
    extends AbstractQueuedSynchronizer
    implements Runnable
    &#123;
    private static final long serialVersionUID = 6138294804551838833L;

    final Thread thread;    // Worker对应的线程
    Runnable firstTask; // 运行的初始任务。
    volatile long completedTasks;   // 每个线程的任务计数器

    Worker(Runnable firstTask) &#123;
    setState(-1); // 禁止中断，直到runWorker
    this.firstTask = firstTask; // 设置为初始任务
    // 使用当前线程池的线程工厂创建一个线程
    this.thread = getThreadFactory().newThread(this);\
    &#125;

    // 将主运行循环委托给外部runWorker
    public void run() &#123;
    runWorker(this);
    &#125;

    // Lock methods
    //
    // The value 0 represents the unlocked state.
    // The value 1 represents the locked state.
    /\*\*

    *   通过AQS的同步状态来实现锁机制。state为0时代表锁未被获取（解锁状态），
    *   state为1时代表锁已经被获取（加锁状态）。
        \*/
        protected boolean isHeldExclusively() &#123; //
        return getState() != 0;
        &#125;
        protected boolean tryAcquire(int unused) &#123;  // 尝试获取锁
        if (compareAndSetState(0, 1)) &#123; // 使用CAS尝试将state设置为1，即尝试获取锁
        // 成功将state设置为1，则当前线程拥有独占访问权
        setExclusiveOwnerThread(Thread.currentThread());\
        return true;
        &#125;
        return false;
        &#125;
        protected boolean tryRelease(int unused) &#123;  // 尝试释放锁
        setExclusiveOwnerThread(null);  // 释放独占访问权：即将独占访问线程设为null
        setState(0);    // 解锁：将state设置为0
        return true;
        &#125;
        public void lock()        &#123; acquire(1); &#125;   // 加锁
        public boolean tryLock()  &#123; return tryAcquire(1); &#125; // 尝试加锁
        public void unlock()      &#123; release(1); &#125;   // 解锁
        public boolean isLocked() &#123; return isHeldExclusively(); &#125;  // 是否为加锁状态
        void interruptIfStarted() &#123; // 如果线程启动了，则进行中断
        Thread t;
        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;
        try &#123;
        t.interrupt();
        &#125; catch (SecurityException ignore) &#123;
        &#125;
        &#125;
        &#125;
        &#125;
        1.execute方法
        使用线程池的submit方法提交任务时，会走到该方法，该方法也是线程池最重要的方法。
        public void execute(Runnable command) &#123;
        if (command == null)    // 为空校验
        throw new NullPointerException();

    int c = ctl.get();  // 拿到当前的ctl值
    if (workerCountOf(c) &lt; corePoolSize) &#123;  // 如果有效的线程数小于核心线程数
    if (addWorker(command, true))   // 则新建一个线程来处理任务（核心线程）
    return;
    c = ctl.get();  // 拿到当前的ctl值
    &#125;
    // 走到这里说明有效的线程数已经 &gt;= 核心线程数
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;// 如果当前状态是运行, 尝试将任务放入工作队列
    int recheck = ctl.get();    // 再次拿到当前的ctl值
    // 如果再次检查状态不是运行, 则将刚才添加到工作队列的任务移除
    if (! isRunning(recheck) &amp;&amp; remove(command))
    reject(command);    // 并调用拒绝策略
    else if (workerCountOf(recheck) == 0) // 如果再次检查时,有效的线程数为0,
    addWorker(null, false); // 则新建一个线程(非核心线程)
    &#125;
    // 走到这里说明工作队列已满
    else if (!addWorker(command, false))//尝试新建一个线程来处理任务(非核心)
    reject(command);    // 如果失败则调用拒绝策略
    &#125;

该方法就是对应上文的线程池的工作流程。主要调用到的方法为addWorker（见下文addWorker方法解读）。

addWorker方法
方法主要目的就是使用入参中的firstTask和当前线程添加一个Worker，前面的for循环主要是对当前线程池的运行状态和有效的线程数进行一些校验，校验逻辑比较绕，可以参考注释进行理解。该方法涉及到的其他方法有addWorkerFailed（见下文addWorkerFailed源码解读）；还有就是Worker的线程启动时，会调用Worker里的run方法，执行runWorker(this)方法（见下文runWorker源码解读）。

addWorkerFailed方法
/\*\*

*   Rolls back the worker thread creation.
*
    *   removes worker from workers, if present
*
    *   decrements worker count
*
    *   rechecks for termination, in case the existence of this
*   worker was holding up termination
    \*/
    private void addWorkerFailed(Worker w) &#123;    // 回滚Worker的添加，就是将Worker移除
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try &#123;
    if (w != null)
    workers.remove(w);  // 移除Worker
    decrementWorkerCount(); // 有效线程数-1
    tryTerminate(); // 有worker线程移除，可能是最后一个线程退出需要尝试终止线程池
    &#125; finally &#123;
    mainLock.unlock();
    &#125;
    &#125;
    该方法很简单，就是移除入参中的Worker并将workerCount-1，最后调用tryTerminate尝试终止线程池，tryTerminate见下文对应方法源码解读。

runWorker方法
上文addWork方法里说道，当Worker里的线程启动时，就会调用该方法。
/\*\*

*   Worker的线程开始执行任务
    \*/
    final void runWorker(Worker w) &#123;
    Thread wt = Thread.currentThread(); // 获取当前线程
    Runnable task = w\.firstTask;    // 拿到Worker的初始任务
    w\.firstTask = null;
    w\.unlock(); // allow interrupts
    boolean completedAbruptly = true;   // Worker是不是因异常而死亡
    try &#123;
    while (task != null || (task = getTask()) != null) &#123;// Worker取任务执行
    w\.lock();   // 加锁
    /\*\*如果线程池停止，确保线程中断; 如果不是，确保线程不被中断。
    \* 在第二种情况下进行重新检查，以便在清除中断的同时处理shutdownNow竞争
    \* 线程池停止指运行状态为STOP/TIDYING/TERMINATED中的一种
    \*/
    if ((runStateAtLeast(ctl.get(), STOP) ||    // 判断线程池运行状态
    (Thread.interrupted() &amp;&amp;   // 重新检查
    runStateAtLeast(ctl.get(), STOP))) &amp;&amp; // 再次判断线程池运行状态
    !wt.isInterrupted())// 走到这里代表线程池运行状态为停止,检查wt是否中断
    wt.interrupt(); // 线程池的状态为停止并且wt不为中断, 则将wt中断
    try &#123;
    beforeExecute(wt, task);// 执行beforeExecute（默认空，需要自己重写）
    Throwable thrown = null;
    try &#123;
    task.run(); // 执行任务
    &#125; catch (RuntimeException x) &#123;
    thrown = x; throw x; //如果抛异常,则completedAbruptly为true
    &#125; catch (Error x) &#123;
    thrown = x; throw x;
    &#125; catch (Throwable x) &#123;
    thrown = x; throw new Error(x);
    &#125; finally &#123;
    afterExecute(task, thrown);// 执行afterExecute（需要自己重写）
    &#125;
    &#125; finally &#123;
    task = null;    // 将执行完的任务清空
    w\.completedTasks++; // Worker完成任务数+1
    w\.unlock();
    &#125;
    &#125;
    completedAbruptly = false;  // 如果执行到这里，则worker是正常退出
    &#125; finally &#123;
    processWorkerExit(w, completedAbruptly);// 调用processWorkerExit方法
    &#125;
    &#125;
    该方法为Worker线程开始执行任务，首先执行当初创建Worker时的初始任务，接着从工作队列中获取任务执行。主要涉及两个方法：获取任务的方法getTask（见下文getTask源码解读）和执行Worker退出的方法processWorkerExit（见下文processWorkerExit源码解读）。注：processWorkerExit在处理正常Worker退出时，没有对workerCount-1，而是在getTask方法中进行workerCount-1。

getTask方法
private Runnable getTask() &#123;    // Worker从工作队列获取任务
boolean timedOut = false; // poll方法取任务是否超时

    for (;;) &#123;  // 无线循环
        int c = ctl.get();  // ctl
        int rs = runStateOf(c); // 当前运行状态

        // 如果线程池运行状态为停止，或者可以停止（状态为SHUTDOWN并且队列为空）
        // 则返回null，代表当前Worker需要移除
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;    
            decrementWorkerCount(); // 将workerCount - 1
            // 返回null前将workerCount - 1,
            // 因此processWorkerExit中completedAbruptly＝false时无需再减
            return null;
        &#125;

        int wc = workerCountOf(c);  // 当前的workerCount

        // 判断当前Worker是否可以被移除, 即当前Worker是否可以一直等待任务。
        // 如果allowCoreThreadTimeOut为true，或者workerCount大于核心线程数，
        // 则当前线程是有超时时间的（keepAliveTime），无法一直等待任务。
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;    

        // 如果wc超过最大线程数 或者 当前线程会超时并且已经超时，
        // 并且wc &gt; 1 或者 工作队列为空，则返回null，代表当前Worker需要移除
        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;   // 确保有Worker可以移除 
            if (compareAndDecrementWorkerCount(c))
                // 返回null前将workerCount - 1，
                // 因此processWorkerExit中completedAbruptly＝false时无需再减
                return null;    
            continue;
        &#125;

        try &#123;
            // 根据线程是否会超时调用相应的方法，poll为带超时的获取任务方法
            // take()为不带超时的获取任务方法，会一直阻塞直到获取到任务
            Runnable r = timed ? 
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;    // 走到这代表当前线程获取任务超时
        &#125; catch (InterruptedException retry) &#123;
            timedOut = false;   // 被中断
        &#125;
    &#125;

&#125;
Worker从工作队列获取任务，如果allowCoreThreadTimeOut为false并且  workerCount&lt;=corePoolSize，则这些核心线程永远存活，并且一直在尝试获取工作队列的任务；否则，线程会有超时时间（keepAliveTime），当在keepAliveTime时间内获取不到任务，该线程的Worker会被移除。 
Worker移除的过程：getTask方法返回null，导致runWorker方法中跳出while循环，调用processWorkerExit方法将Worker移除。注意：在返回null的之前，已经将workerCount-1，因此在processWorkerExit中，completedAbruptly=false的情况（即正常超时退出）不需要再将workerCount-1。

processWorkerExit方法
private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;   // Worker的退出
// 如果Worker是异常死亡（completedAbruptly=true），则workerCount-1；
// 如果completedAbruptly为false的时候（正常超时退出），则代表task=getTask()等于null，
// getTask()方法中返回null的地方，都已经将workerCount - 1，所以此处无需再-1
if (completedAbruptly)
decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();    // 加锁
    try &#123;
        completedTaskCount += w.completedTasks; // 该Worker完成的任务数加到总完成的任务数
        workers.remove(w);  // 移除该Worker
    &#125; finally &#123;
        mainLock.unlock();
    &#125;

    tryTerminate(); // 有Worker线程移除，可能是最后一个线程退出，需要尝试终止线程池

    int c = ctl.get();  // 获取当前的ctl
    if (runStateLessThan(c, STOP)) &#123;  // 如果线程池的运行状态还没停止（RUNNING或SHUTDOWN）
        if (!completedAbruptly) &#123;   // 如果Worker不是异常死亡
            // min为线程池的理论最小线程数:如果允许核心线程超时则min为0,否则min为核心线程数
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;    
            // 如果min为0,工作队列不为空,将min设置为1,确保至少有1个Worker来处理队列里的任务 
            if (min == 0 &amp;&amp; ! workQueue.isEmpty())
                min = 1;
            // 当前有效的线程数&gt;=min，直接返回;
            if (workerCountOf(c) &gt;= min)
                return; // replacement not needed 
            // 如果代码走到这边，代表workerCountOf(c) &lt; min，此时会走到下面的addWorker方法。
            // 通过getTask方法我们知道，当allowCoreThreadTimeOut为false
            // 并且workerCount&lt;=corePoolSize时，是不会走到processWorkerExit方法的。
            // 因此走到这边只可能是当前移除的Worker是最后一个Worker，但是此时工作
            // 队列还不为空，因此min被设置成了1，所以需要在添加一个Worker来处理工作队列。
        &#125;
        addWorker(null, false); // 添加一个Worker
    &#125;

&#125;
该方法就是执行Worker的退出：统计完成的任务数，将Worker移除，并尝试终止线程池，最后根据情况决定是否创建一个新的Worker。两种情况下会创建一个新的Worker：1）被移除的Worker是由于异常而死亡；2）被移除的Worker是最后一个Worker，但是工作队列还有任务。completedAbruptly=false时，没有将workerCount-1是因为已经在getTask方法中将workerCount-1。

tryTerminate方法
final void tryTerminate() &#123; // 尝试终止线程池
for (;;) &#123;
int c = ctl.get();
// 只有当前状态为STOP 或者 SHUTDOWN并且队列为空，才会尝试整理并终止
// 1: 当前状态为RUNNING，则不尝试终止，直接返回
// 2: 当前状态为TIDYING或TERMINATED，代表有其他线程正在执行终止，直接返回
// 3: 当前状态为SHUTDOWN 并且 workQueue不为空，则不尝试终止，直接返回
if (isRunning(c) || // 1
runStateAtLeast(c, TIDYING) ||  // 2
(runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))   // 3
return;
// 走到这代表线程池可以终止（通过上面的校验）
// 如果此时有效线程数不为0， 将中断一个空闲的Worker，以确保关闭信号传播
if (workerCountOf(c) != 0) &#123; // Eligible to terminate
interruptIdleWorkers(ONLY\_ONE);
return;
&#125;

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();    // 加锁，终止线程池
        try &#123;
            // 使用CAS将ctl的运行状态设置为TIDYING，有效线程数设置为0
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;  
                try &#123;
                    terminated();   // 供用户重写的terminated方法，默认为空
                &#125; finally &#123;
                    // 将ctl的运行状态设置为TERMINATED，有效线程数设置为0
                    ctl.set(ctlOf(TERMINATED, 0));  
                    termination.signalAll();
                &#125;
                return;
            &#125;
        &#125; finally &#123;
            mainLock.unlock();
        &#125;
        // else retry on failed CAS
    &#125;

&#125;
该方法用来尝试终止线程池，主要在移除Worker后会调用此方法。首先进行一些状态的校验，如果通过校验，则在加锁的条件下，使用CAS将运行状态设为TERMINATED，有效线程数设为0。

1\)现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？

这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。

2\)在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？

lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。

3\)在java中wait和sleep方法的不同？

通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。

4）用Java实现阻塞队列。

这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。

5）用Java写代码来解决生产者——消费者问题。

与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。

6）用Java编程一个会导致死锁的程序，你将怎么解决？

这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。

7\) 什么是原子操作，Java中的原子操作是什么？

非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。

8\) Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？

自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性。

9\) 什么是竞争条件？你怎样发现和解决竞争？

这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or anyother race condition。关于这方面最好的书是《Concurrency practices in Java》。

10\) 你将如何使用threaddump？你将如何分析Thread dump？

在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。

11\) 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。

12\) Java中你怎样唤醒一个阻塞的线程？

这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。

13\)在Java中CycliBarriar和CountdownLatch有什么区别？

这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。

14\) 什么是不可变对象，它对写并发应用有什么帮助？

另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。

15\) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？

多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。

笔记本： Java面试题
创建时间： 2018-10-30 11:14 更新时间： 2018-10-30 12:09
作者： 这个名字其实还是很长很长的
第八题 Java并发类库提供的线程池有哪几种？ 分别有什么特点？
Java并发类库提供的线程池有哪几种？ 分别有什么特点？
经典回答:
通常开发者都是利用Executors提供的通用线程池创建方法,去创建不同配置的线程池,主要
区别在于不同的ExecutorService类型或者不同的初识参数。
Executors目前提供了5种不同的线程池创建配置:
newCachedThreadPool(),它是一种用来处理大量短时间工作任务的线程池,具有几个鲜明特
点:它会试图缓存线程并重用,当无缓存线程可用时,就会创建新的工作线程;如果线程闲置
的时间超过60S,则被终止并移出缓存;长时间闲置时,这种线程池,不会消耗资源。
newFixedThreadPool(int nThreads),重用指定数目的线程,其背后使用的是无界的工作队
列,任何时候最多有nThreads个工作线程是活动的。这意味着,如果任务数量超过了活动队
列数目,将在工作队列中等待空闲线程出现;如果有工作线程退出,将会有新的工作线程被创
建,以补足指定的数目nThreads。
newSingleThreadExecutor(),它的特点在于工作线程数目被限制为1,操作一个无界的工作
队列,所以它保证了所有任务的都是被顺序执行,最多会有一个任务处于活动状态,并且不允
许使用者改造线程实例,因此可以避免其改变线程数目。
newSingleThreadScheduledExecutor()和newSecheduledThreadPool(int corePoolSize),
创建的是个ScheduledExecutorService,可以进行定时或周期性的工作调度,区别在于单一
工作线程还是多个工作线程。

笔记本： Java面试题
创建时间： 2018-10-29 11:12 更新时间： 2018-10-29 15:44
作者： 这个名字其实还是很长很长的
第六题 synchronized和ReentrantLock有什么区别
Synchronized和ReentrantLock有什么区别?
典型回答:
synchronized是Java内建的同步机制,所以也有人称其为Intrinsic Locking（固有
锁）,它提供了互斥的语义和可见性,当一个线程已经获取当前锁时,其他试图获取的线程
只能等待或者阻塞在那里。在Java 5以前,synchronized是仅有的同步手段,在代码
中,synchronized可以用来修饰方法,也可以使用在特定的代码块上,本质上
synchronized方法等同于把方法全部语句用synchronized块包起来。
ReentrantLock,通常翻译为再入锁,是Java 5提供的锁实现,它的语义和
synchronized基本相同。再入锁通过代码直接调用lock()方法获取,代码书写更加灵
活。与此同时,ReentrantLock提供了很多实用的方法,能够实现很多synchronized无法
做到的细节控制,但是在编码中也需要注意,必须要明确调用unlock()方法释放,不然就
会一直持有该锁。synchronzied和ReentrantLock的性能不能一概而论,早期版本
synchronized在很多场景下性能相差较大,在后续版本进行了较多改进,在低竞争场景中
表现可能优于ReentrantLock。
知识扩展:
什么是线程安全? 线程安全是一个多线程环境下正确性的概念,也就是保证多线程环
境下共享的可修改的状态的正确性,这里的状态反映在程序中其实可以看做是数据。
换个角度来看,如果状态不是共享的,或者不是可修改的,也就不存在线程安全问题,
进而可以推理出保证线程安全的两个办法:第一个是封装,我们可以将对象内部状态隐藏
保护起来。第二个是不可变。
线程安全需要保证几个基本特性:第一个是原子性,简单来说就是相关操作不会中途
被其他线程干扰,一般通过同步机制实现。第二是可见性,是一个线程修改了某个共享变
量,其状态能够立即被其他线程知晓,通常被解释为将线程本地状态反映到主内存
中,volatile关键字就是负责保证可见性的。第三个是有序性,是保证线程内串行语义,
避免指令重排等。
可能有点晦涩,那么我们看看下面的代码段,分析一下原子性需求体现在哪里。这个
例子通过取两个次数值然后进行对比,来模拟两次对共享状态的操作。你可以编译并执
行,可以看到,仅仅是两个线程的低度并发,就非常容易碰到former和latter不相等的情
况。这是因为,在两次取值的过程中,其他线程已经修改了sharedState的值。
下面是电脑上的运行结果:
因为线程安全的问题,导致以上的运行结果。我们可以将两次赋值过程用synchronized保护
起来,使用this作为互斥单元,就可以避免别的线程并发的去修改sharedState。
我们在来看看ReentrantLock。
你可能好奇什么是再入?它是表示当一个线程试图获取一个它已经获取的琐时,这个获
取动作就自动成功,这是对锁获取粒度的一个概念,也就是一个锁的持有是以线程为单位而
不是基于调用次数。
首先看下面的例子:
从上可以看出，使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对
逻辑控制的灵活性远远大于synchronized关键字。同时，需要注意，有加锁就必须有释放
锁，而且加锁与释放锁的份数要相同，这里就引出了“重”字的概念，如上边代码演示，
放开①、②处的注释，与原来效果一致。
ReentrantLock实现中断操作,先了解几个方法的作用
lockInterruptibly():当两个线程同时通过lock.lockInterruptibly()想获取某个锁
时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用
threadB.interrupt()方法能够中断线程B的等待过程。
isHeldByCurrentThread():查询当前线程是否保持锁。
t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了
死锁。但是，在③处给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中
断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，
正常执行完成。t2也会退出，但只是释放了资源并没有完成工作。
ReentrantLock实现锁申请等待限时
可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁
等待。前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线
程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。后者带有
参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返
回false。
公平锁
所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产
生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非
公平锁）创建公平锁：

ReentrantLock与Condition一起使用
配合关键字synchronized使用的方法如：await()、notify()、notifyAll()，同样配合
ReentrantLock 使用的Conditon提供了以下方法：
ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建
Condition对象

11
1.多线程有什么用？
1）发挥多核CPU 的优势
随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的
，4 核、8 核甚至 16 核的也都不少见，如果是单线程的程序，那么在双核 CPU 上
就浪费了 50%， 在 4 核 CPU 上就浪费了 75%。单核 CPU 上所谓的&quot;多线程&quot;那是
假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，
看着像多个线程&quot;同时&quot;运行罢了。多核 CPU 上的多线程才是真正的多线程，它能
让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU 的优势来，达到充
分利用CPU 的目的。
2）防止阻塞
从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因
为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但
是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使
用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返
回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多
线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻
塞，也不会影响其它任务的执行。
3）便于建模
这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么
就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成
几个小任务，任务B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运
行这几个任务，那就简单很多了。
2.线程和进程的区别是什么？
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地
址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一
个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的
地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程
序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进
行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
3.Java 实现线程有哪几种方式？
1）继承 Thread 类实现多线程
2）实现 Runnable 接口方式实现多线程
3）使用 ExecutorService、Callable、Future 实现有返回结果的多线程
4.启动线程方法 start()和 run()有什么区别？
只有调用了 start()方法，才会表现出多线程的特性，不同线程的 run()方法里面的代
码交替执行。如果只是调用 run()方法，那么代码还是同步执行的，必须等待一个
线程的 run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run()
方法里面的代码。
5.怎么终止一个线程？如何优雅地终止线程？
stop 终止，不推荐。
6.一个线程的生命周期有哪几种状态？它们之间如何流转的？
NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。
RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中
状态。
BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock 等关键字等
12
占用临界区的情况，一旦获取到锁就进行 RUNNABLE 状态继续运行。
WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如
通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方
法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线
程就进入了 RUNNABLE 状态继续运行。
TIMED\_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒
后线程重新进行 RUNNABLE 状态继续运行。
TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程
通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到
RUNNABLE 状态
7.线程中的 wait()和 sleep()方法有什么区别？
这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在
于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait
方法会放弃这个对象的监视器
8.多线程同步有哪几种方法？
Synchronized 关键字，Lock 锁实现，分布式锁等。
9.什么是死锁？如何避免死锁？
死锁就是两个线程相互等待对方释放对象锁。
10.多线程之间如何进行通信？
wait/notify
11、线程怎样拿到返回结果？
实现Callable 接口。
12、violatile 关键字的作用？
一个非常重要的问题，是每个学习、应用多线程的 Java 程序员都必须掌握的。理
解 volatile关键字的作用的前提是要理解 Java 内存模型，这里就不讲 Java 内存模型
了，可以参见第31 点，volatile 关键字的作用主要有两个：
1）多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变
量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的
数据
2）代码底层执行不像我们看到的高级语言----Java 程序这么简单，它的执行是 Java
代码--&gt;字节码--&gt;根据字节码执行对应的 C/C++代码--&gt;C/C++代码被编译成汇编语
言--&gt;和硬件电路交互，现实中，为了获取更好的性能 JVM 可能会对指令进行重排
序，多线程下可能会出现一些意想不到的问题。使用 volatile 则会对禁止语义重排
序，当然这也一定程度上降低了代码执行效率从实践角度而言，volatile 的一个重
要 作 用 就 是 和 CAS 结 合 ， 保 证 了 原 子 性 ， 详 细 的 可 以 参 见
java.util.concurrent.atomic 包下的类，比如 AtomicInteger。
13、新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？
用 join 方法。
14、怎么控制同一时间只有 3 个线程运行？
用 Semaphore。
15、为什么要使用线程池？
我们知道不用线程池的话，每个线程都要通过 new Thread(xxRunnable).start()的方
式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个
13
线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和
内存资源，也会造成 GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消
耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，
线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也
会自动销毁，而不会长驻内存。
16、常用的几种线程池并讲讲其中的工作原理。
什么是线程池？
很简单，简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线
程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的
复用。
线程池的好处
我们知道不用线程池的话，每个线程都要通过 new Thread(xxRunnable).start()的方
式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个
线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的 CPU 和
内存资源，也会造成 GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消
耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，
线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也
会自动销毁，而不会长驻内存。
线程池核心类
在 java.util.concurrent 包中我们能找到线程池的定义，其中 ThreadPoolExecutor 是
我们线程池核心类，首先看看线程池类的主要参数有哪些。
如何提交线程
如 可 以 先 随 便 定 义 一 个 固 定 大 小 的 线 程 池 ExecutorService es = Executors.newFixedThreadPool(3);提交一个线程es.submit(xxRunnble);
es.execute(xxRunnble);
submit 和 execute 分别有什么区别呢？
execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很
多。
submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能
在主线程中通过 Future 的 get 方法捕获线程中的异常。
如何关闭线程池es.shutdown();
不再接受新的任务，之前提交的任务等执行结束再关闭线程池。
es.shutdownNow();
不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程
list 列表。
17、线程池启动线程 submit()和 execute()方法有什么不同？
execute 没有返回值，如果不需要知道线程的结果就使用 execute 方法，性能会好很
多。
submit 返回一个 Future 对象，如果想知道线程结果就使用 submit 提交，而且它能
在主线程中通过 Future 的 get 方法捕获线程中的异常。
18、CyclicBarrier 和 CountDownLatch 的区别？
两个看上去有点像的类，都在 java.util.concurrent 下，都可以用来表示代码运行到
某个点上，二者的区别在于：
1.CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的
线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运
行到某个点上之后，只是给某个数值-1 而已，该线程继续运行
14
2.CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务
3.CyclicBarrier 可 重 用 ， CountDownLatch 不 可 重 用 ， 计 数 值 为 0 该
CountDownLatch就不可再用了
19、什么是活锁、饥饿、无锁、死锁？
死锁、活锁、饥饿是关于多线程是否活跃出现的运行阻塞障碍问题，如果线程出现
了这三种情况，即线程不再活跃，不能再正常地执行下去了。
死锁
死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等
对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。
举个例子，A 同学抢了 B 同学的钢笔，B 同学抢了 A 同学的书，两个人都相互占
用对方的东西，都在让对方先还给自己自己再还，这样一直争执下去等待对方还而
又得不到解决，老师知道此事后就让他们相互还给对方，这样在外力的干预下他们
才解决，当然这只是个例子没有老师他们也能很好解决，计算机不像人如果发现这
种情况没有外力干预还是会一直阻塞下去的。
活锁
活锁这个概念大家应该很少有人听说或理解它的概念，而在多线程中这确实存在。
活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿
到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别
的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。
饥饿
我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执
行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无
法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源
不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够
得到执行的，如那个占用资源的线程结束了并释放了资源。
无锁
无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时
只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，
线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下
一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，
而其他修改失败的线程会不断重试直到修改成功。之前的文章我介绍过 JDK 的
CAS 原理及应用即是无锁的实现。
可以看出，无锁是一种非常良好的设计，它不会出现线程出现的跳跃性问题，锁使
用不当肯定会出现系统性能问题，虽然无锁无法全面代替有锁，但无锁在某些场合
下是非常高效的。
20、什么是原子性、可见性、有序性？
原子性、可见性、有序性是多线程编程中最重要的几个知识点，由于多线程情况复
杂，如何让每个线程能看到正确的结果，这是非常重要的。
原子性
原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个
变量进行操作。在多线程情况下，每个线程的执行结果不受其他线程的干扰，比如
说多个线程同时对同一个共享成员变量 n++100 次，如果 n 初始值为 0，n 最后的
值应该是 100，所以说它们是互不干扰的，这就是传说的中的原子性。但 n++并不
是原子性的操作，要使用 AtomicInteger 保证原子性。
可见性
可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享
变量修改后的值。在单线程中肯定不会有这种问题，单线程读到的肯定都是最新的
15
值，而在多线程编程中就不一定了。每个线程都有自己的工作内存，线程先把共享
变量的值从主内存读到工作内存，形成一个副本，当计算完后再把副本的值刷回主
内存，从读取到最后刷回主内存这是一个过程，当还没刷回主内存的时候这时候对
其他线程是不可见的，所以其他线程从主内存读到的值是修改之前的旧值。像
CPU 的缓存优化、硬件优化、指令重排及对 JVM 编译器的优化，都会出现可见性
的问题。
有序性
我们都知道程序是按代码顺序执行的，对于单线程来说确实是如此，但在多线程情
况下就不是如此了。为了优化程序执行和提高 CPU 的处理性能，JVM 和操作系统
都会对指令进行重排，也就说前面的代码并不一定都会在后面的代码前面执行，即
后面的代码可能会插到前面的代码之前执行，只要不影响当前线程的执行结果。所
以，指令重排只会保证当前线程执行结果一致，但指令重排后势必会影响多线程的
执行结果。虽然重排序优化了性能，但也是会遵守一些规则的，并不能随便乱排序，
只是重排序会影响多线程执行的结果。
21、什么是守护线程？有什么用？
什么是守护线程？与守护线程相对应的就是用户线程，守护线程就是守护用户线
程，当用户线程全部执行完结束之后，守护线程才会跟着结束。也就是守护线程必
须伴随着用户线程，如果一个应用内只存在一个守护线程，没有用户线程，守护线
程自然会退出。
22、一个线程运行时发生异常会怎样？
如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用
于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造
成线程中断的时 候 JVM 会 使 用 Thread.getUncaughtExceptionHandler() 来 查 询 线
程 的UncaughtExceptionHandler 并 将 线 程 和 异 常 作 为 参 数 传 递 给 handler 的
uncaughtException()方法进行处理。
23、线程 yield()方法有什么用？
Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。
它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定
能占用 CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。
24、什么是重入锁？
所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再
次获取本对象上的锁，而其他的线程是不可以的。
25、Synchronized 有哪几种用法？
锁类、锁方法、锁代码块。
26、Fork/Join 框架是干什么的？
大任务自动分散小任务，并发执行，合并小任务结果。
27、线程数过多会造成什么异常？
线程过多会造成栈溢出，也有可能会造成堆异常。
28、说说线程安全的和不安全的集合。
Java 中平时用的最多的 Map 集合就是 HashMap 了，它是线程不安全的。
看下面两个场景：
1、当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访
问不了，所以这时也不存在线程安全不安全的问题了。
16
2、当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个
HashMap 了，对同个 HashMap 操作这时候就存在线程安全的问题了。
29、什么是 CAS 算法？在多线程中有哪些应用。
CAS，全称为 Compare and Swap，即比较-替换。假设有三个操作数：内存值 V、
旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内
存值修改为 B 并返回 true，否则什么都不做并返回 false。当然 CAS 一定要 volatile
变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期
值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远
都不可能成功。
java.util.concurrent.atomic 包下面的 Atom\*\*\*\*类都有 CAS 算法的应用。
30、怎么检测一个线程是否拥有锁？
java.lang.Thread#holdsLock 方法
31、Jdk 中排查多线程问题用什么命令？
jstack
32、线程同步需要注意什么？
1、尽量缩小同步的范围，增加系统吞吐量。
2、分布式同步锁无意义，要使用分布式锁。
3、防止死锁，注意加锁顺序。
33、线程 wait()方法使用有什么前提？
要在同步块中使用。
34、Fork/Join 框架使用有哪些要注意的地方？
如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；
如果函数的调用栈很深，会导致栈内存溢出；
35、线程之间如何传递数据？
通 过 在 线 程 之 间 共 享 对 象 就 可 以 了 ， 然 后 通 过 wait/notify/notifyAll 、
await/signal/signalAll 进行唤起和等待，比方说阻塞队列 BlockingQueue 就是为线程
之间共享数据而设计的
36、保证&quot;可见性&quot;有哪几种方式？
synchronized 和 viotatile
37、说几个常用的 Lock 接口实现锁。
ReentrantLock、ReadWriteLock
38、ThreadLocal 是什么？有什么应用场景？
ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作
用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。用来
解决数据库连接、Session 管理等。
39、ReadWriteLock 有什么用？
ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接
口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之
间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。
40、FutureTask 是什么？
FutureTask 表示一个异步运算的任务，FutureTask 里面可以传入一个 Callable 的具
17
体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、
取消任务等操作。
41、怎么唤醒一个阻塞的线程？
如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，
并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，
因为 IO是操作系统实现的，Java 代码并没有办法直接接触到操作系统。
42、不可变对象对多线程有什么帮助？
不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步
手段，提升了代码执行效率。
43、多线程上下文切换是什么意思？
多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个
就绪并等待获取 CPU 执行权的线程的过程。
44、Java 中用到了什么线程调度算法？
抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等
数据算出一个总的优先级并分配下一个时间片给某个线程执行。
45、Thread.sleep(0)的作用是什么？
由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU
控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使
用 Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制
权的一种操作。
46、Java 内存模型是什么，哪些区域是线程共享的，哪些是不共享
的？
我们知道的 JVM 内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的
一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。
线程不共享区域每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它
们都是在新线程创建时才创建的。
程序计数器（Program Counter Rerister）
程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程
都有自己的程序计数器，此区域不会有内存溢出的情况。
虚拟机栈（VM Stack）
虚拟机栈描述的是 Java 方法执行的内存模型，每个方法被执行的时候都会同时创
建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口
等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从
入栈到出栈的过程。
本地方法栈（Native Method Stack）
本地方法栈用于支持本地方法（native 标识的方法，即非 Java 语言实现的方法）。
虚拟机栈和本地方法栈，当线程请求分配的栈容量超过 JVM 允许的最大容量时抛
出StackOverflowError 异常。
线程共享区域
线程共享区域包含：堆和方法区。
堆（Heap）
堆是最常处理的区域，它存储在 JVM 启动时创建的数组和对象，JVM 垃圾收集也
主要是在堆上面工作。
如 果 实 际 所 需 的 堆 超 过 了 自 动 内 存 管 理 系 统 能 提 供 的 最 大 容 量 时 抛 出
18
OutOfMemoryError 异常。
方法区（Method Area）
方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如
运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法
的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。当创建类
和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内
存空间后就会抛出 OutOfMemoryError
运行时常量池（Runtime Constant Pool）
运行时常量池是方法区的一部分，每一个运行时常量池都分配在 JVM 的方法区中，
在类和接口被加载到 JVM 后，对应的运行时常量池就被创建。运行时常量池是每
一个类或接口的常量池（Constant\_Pool）的运行时表现形式，它包括了若干种常量：
编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。如果
方法区的内存空间不能满足内存分配请求，那 Java 虚 拟 机 将 抛 出 一 个
OutOfMemoryError 异常。栈包含 Frames，当调用方法时，Frame 被推送到堆栈。
一个 Frame 包含局部变量数组、操作数栈、常量池引用。
47、什么是乐观锁和悲观锁？
乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐
观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为
一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有
相应的重试逻辑。
悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，
悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的
锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。
48、Hashtable 的 size()方法为什么要做同步？
同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以
多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put
方法添加数据，线程 B 则可以正常调用 size()方法读取 Hashtable 中当前元素的个
数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对
size++，线程 B 就已经读取 size了，那么对于线程 B 来说读取到的 size 一定是不准
确的。而给 size()方法加了同步之后，意味着线程 B 调用 size()方法只有在线程 A
调用 put 方法完毕之后才可以调用，这样就保证了线程安全性CPU 执行代码，执行
的不是 Java 代码，这点很关键，一定得记住。Java 代码最终是被翻译成机器码执
行的，机器码才是真正可以和硬件电路交互的代码。即使你看到 Java 代码只有一
行，甚至你看到 Java 代码编译之后生成的字节码也只有一行，也不意味着对于底
层来说这句语句的操作只有一个。一句&quot;return count&quot;假设被翻译成了三句汇编语句
执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。
49、同步方法和同步块，哪种更好？
同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码
的效率。
请知道一条原则：同步的范围越小越好。
50、什么是自旋锁？
自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线
程改变时才能进入临界区。
51、Runnable 和 Thread 用哪个好？
Java 不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也
19
为了减少类之间的耦合性，Runnable 会更好。
52、Java 中 notify 和 notifyAll 有什么区别？
notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用
武之地。
而 notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。
53、为什么 wait/notify/notifyAll 这些方法不在 thread 类里面？
这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不
合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object
类里是有意义的，还有不把它放在 Thread 类里的原因。一个很明显的原因是
JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如
果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果 wait()方法定
义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，
notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对
象。
54、为什么 wait 和 notify 方法要在同步块中调用？
主 要 是 因 为 Java API 强 制 要 求 这 样 做 ， 如 果 你 不 这 么 做 ， 你 的 代 码
会 抛 出IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify
之间产生竞态条件。
55、为什么你应该在循环中检查等待条件？
处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，
程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能
认为它原来的等待状态仍然是有效的，在 notify()方法调用之后和等待线程醒来之
前这段时间它可能会改变。这就是在循环中使用 wait()方法效果更好的原因，你可
以在 Eclipse 中创建模板调用 wait和 notify 试一试。
56、Java 中堆和栈有什么不同？
每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中
存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对
象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线
程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程
从主存中读取变量的值。
57、你如何在 Java 中获取线程堆栈？
对于不同的操作系统，有多种方法来获得 Java 进程的线程堆栈。当你获取线程堆
栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在 Windows 你
可以使用 Ctrl + Break 组合键来获取线程堆栈，Linux 下用 kill -3 命令。你也可以
用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。
58、如何创建线程安全的单例模式？
单例模式即一个 JVM 内存中只存在一个类的对象实例分类
1、懒汉式
类加载的时候就创建实例
2、饿汉式
使用的时候才创建实例
59、什么是阻塞式方法？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的
110
accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前
线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任
务完成前就返回。
60、提交任务时线程池队列已满会时发会生什么？
当线程数小于最大线程池数 maximumPoolSize 时就会创建新线程来处理，而线程
数大于等于最大线程池数 maximumPoolSize 时就会执行拒绝策略。

关于线程和线程池的学习，我们可以从以下几个方面入手：
第一，什么是线程，线程和进程的区别是什么
第二，线程中的基本概念，线程的生命周期
第三，单线程和多线程
第四，线程池的原理解析
第五，常见的几种线程池的特点以及各自的应用场景
一、
线程，程序执行流的最小执行单位，是行程中的实际运作单位，经常容易和进程这个概念混淆。那么，线程和进程究竟有什么区别呢？首先，进程是一个动态的过程，是一个活动的实体。简单来说，一个应用程序的运行就可以被看做是一个进程，而线程，是运行中的实际的任务执行者。可以说，进程中包含了多个可以同时运行的线程。
二、
线程的生命周期，线程的生命周期可以利用以下的图解来更好的理解：
第一步，是用new Thread()的方法新建一个线程，在线程创建完成之后，线程就进入了就绪（Runnable）状态，此时创建出来的线程进入抢占CPU资源的状态，当线程抢到了CPU的执行权之后，线程就进入了运行状态（Running），当该线程的任务执行完成之后或者是非常态的调用的stop（）方法之后，线程就进入了死亡状态。而我们在图解中可以看出，线程还具有一个则色的过程，这是怎么回事呢？当面对以下几种情况的时候，容易造成线程阻塞，第一种，当线程主动调用了sleep（）方法时，线程会进入则阻塞状态，除此之外，当线程中主动调用了阻塞时的IO方法时，这个方法有一个返回参数，当参数返回之前，线程也会进入阻塞状态，还有一种情况，当线程进入正在等待某个通知时，会进入阻塞状态。那么，为什么会有阻塞状态出现呢？我们都知道,CPU的资源是十分宝贵的，所以，当线程正在进行某种不确定时长的任务时，Java就会收回CPU的执行权，从而合理应用CPU的资源。我们根据图可以看出，线程在阻塞过程结束之后，会重新进入就绪状态，重新抢夺CPU资源。这时候，我们可能会产生一个疑问，如何跳出阻塞过程呢?又以上几种可能造成线程阻塞的情况来看，都是存在一个时间限制的，当sleep()方法的睡眠时长过去后，线程就自动跳出了阻塞状态，第二种则是在返回了一个参数之后，在获取到了等待的通知时，就自动跳出了线程的阻塞过程
三、
什么是单线程和多线程？
单线程，顾名思义即是只有一条线程在执行任务，这种情况在我们日常的工作学习中很少遇到，所以我们只是简单做一下了解
多线程，创建多条线程同时执行任务，这种方式在我们的日常生活中比较常见。但是，在多线程的使用过程中，还有许多需要我们了解的概念。比如，在理解上并行和并发的区别，以及在实际应用的过程中多线程的安全问题，对此，我们需要进行详细的了解。
并行和并发：在我们看来，都是可以同时执行多种任务，那么，到底他们二者有什么区别呢？
并发，从宏观方面来说，并发就是同时进行多种时间，实际上，这几种时间，并不是同时进行的，而是交替进行的，而由于CPU的运算速度非常的快，会造成我们的一种错觉，就是在同一时间内进行了多种事情
而并发，则是真正意义上的同时进行多种事情。这种只可以在多核CPU的基础下完成。
还有就是多线程的安全问题？为什么会造成多线程的安全问题呢？我们可以想象一下，如果多个线程同时执行一个任务，name意味着他们共享同一种资源，由于线程CPU的资源不一定可以被谁抢占到，这是，第一条线程先抢占到CPU资源，他刚刚进行了第一次操作，而此时第二条线程抢占到了CPU的资源，name，共享资源还来不及发生变化，就同时有两条数据使用了同一条资源，具体请参考多线程买票问题。这个问题我们应该如何解决那？
有造成问题的原因我们可以看出，这个问题主要的矛盾在于，CPU的使用权抢占和资源的共享发生了冲突，解决时，我们只需要让一条线程战歌了CPU的资源时，阻止第二条线程同时抢占CPU的执行权，在代码中，我们只需要在方法中使用同步代码块即可。在这里，同步代码块不多进行赘述，可以自行了解。
四，线程池
又以上介绍我们可以看出，在一个应用程序中，我们需要多次使用线程，也就意味着，我们需要多次创建并销毁线程。而创建并销毁线程的过程势必会消耗内存。而在Java中，内存资源是及其宝贵的，所以，我们就提出了线程池的概念。
线程池：Java中开辟出了一种管理线程的概念，这个概念叫做线程池，从概念以及应用场景中，我们可以看出，线程池的好处，就是可以方便的管理线程，也可以减少内存的消耗。
那么，我们应该如何创建一个线程池那?Java中已经提供了创建线程池的一个类：Executor
而我们创建时，一般使用它的子类：ThreadPoolExecutor.
public ThreadPoolExecutor(
int corePoolSize,//核心线程数（线程池中线程的数量）
int maximumPoolSize,（最大线程数，包括核心线程数，剩下的任务放在放在阻塞队列中）
long keepAliveTime,//非核心线程空闲存活时间
TimeUnit unit,// 空闲线程存活时间的单位
BlockingQueue workQueue, //阻塞队列，存放最大线程数-核心线程数的剩余任务数
ThreadFactory threadFactory,//线程生产工厂类对象
RejectedExecutionHandler handler//任务数异常时解决方案
)
这是其中最重要的一个构造方法，这个方法决定了创建出来的线程池的各种属性，下面依靠一张图来更好的理解线程池和这几个参数：

又图中，我们可以看出，线程池中的corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收，maximumPoolSize就是线程池中可以容纳的最大线程的数量，而keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，而util，就是计算这个时间的一个单位，workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。threadFactory，就是创建线程的线程工厂，最后一个handler,是一种拒绝策略，我们可以在任务满了知乎，拒绝执行某些任务。
线程池的执行流程又是怎样的呢？

有图我们可以看出，任务进来时，首先执行判断，判断核心线程是否处于空闲状态，如果不是，核心线程就先就执行任务，如果核心线程已满，则判断任务队列是否有地方存放该任务，若果有，就将任务保存在任务队列中，等待执行，如果满了，在判断最大可容纳的线程数，如果没有超出这个数量，就开创非核心线程执行任务，如果超出了，就调用handler实现拒绝策略。
handler的拒绝策略：
有四种：第一种AbortPolicy:不执行新任务，直接抛出异常，提示线程池已满
第二种DisCardPolicy:不执行新任务，也不抛出异常
第三种DisCardOldSetPolicy:将消息队列中的第一个任务替换为当前新进来的任务执行
第四种CallerRunsPolicy:直接调用execute来执行当前任务
五，四种常见的线程池：
CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max\_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。
SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。
SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。
FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程

线程池能有效的处理多个线程的并发问题，避免大量的线程因为互相强占系统资源导致阻塞现象，能够有效的降低频繁创建和销毁线程对性能所带来的开销。真正线程池的实现是通过ThreadPoolExecutor，ThreadPoolExecutor通过配置不同的参数配置来创建线程池。下面简单的介绍一下各个线程池的区别和用处。
（1）fixThreadPool  正规线程
          我的理解这是一个有指定的线程数的线程池，有核心的线程，里面有固定的线程数量，响应的速度快。正规的并发线程，多用于服务器。固定的线程数由系统资源设置。
public static ExecutorService newFixedThreadPool(int threads)
&#123;
return newFixedThreadPool(threads,threads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue\&lt;Runnable&gt;());
&#125;
核心线程是没有超时机制的，队列大小没有限制，除非线程池关闭了核心线程才会被回收。
（2）caCheThreadPool  缓存线程池

         只有非核心线程，最大线程数很大（Int.Max(values)），它会为每一个任务添加一个新的线程，这边有一个超时机制，当空闲的线程超过60s内没有用到的话，就会被回收。缺点就是没有考虑到系统的实际内存大小。
public static ExecutorService newCachedThreadPool(int threads)
&#123;
return newFixedThreadPool(threads,Integer.MAX\_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue\&lt;Runnable&gt;());
&#125;
（3）singleThreadPoll   单线程线程池
  看这个名字就知道这个家伙是只有一个核心线程，就是一个孤家寡人，通过指定的顺序将任务一个个丢到线程，都乖乖的排队等待执行，不处理并发的操作，不会被回收。确定就是一个人干活效率慢。
（4）ScheduledThreadPoll   

         这个线程池就厉害了，是唯一一个有延迟执行和周期重复执行的线程池。它的核心线程池固定，非核心线程的数量没有限制，但是闲置时会立即会被回收。
线程池的基本使用
1.package com.joonwhee.concurrent;

1.

3.import java.util.ArrayList;
4.import java.util.List;
5.import java.util.concurrent.Callable;
6.import java.util.concurrent.ExecutorService;
7.import java.util.concurrent.Executors;
8.import java.util.concurrent.Future;
9.import java.util.concurrent.FutureTask;
10.import java.util.concurrent.LinkedBlockingQueue;
11.import java.util.concurrent.ScheduledExecutorService;
12.import java.util.concurrent.ThreadPoolExecutor;
13.import java.util.concurrent.TimeUnit;

1.

15./\*\*
16\. \* 线程池的基本使用

1.
    *   @author JoonWhee
2.
    *   @Date 2018年1月21日
3.  \*/
    20.public class ThreadPoolExecutorTest &#123;
4.
5.  /\*\*
6.
         * 创建一个线程池(完整入参): 
7.
         * 核心线程数为5 (corePoolSize), 
8.
         * 最大线程数为10 (maximumPoolSize), 
9.
         * 存活时间为60分钟(keepAliveTime), 
10.
        * 工作队列为LinkedBlockingQueue (workQueue),
11.
        * 线程工厂为默认的DefaultThreadFactory (threadFactory), 
12.
        * 饱和策略(拒绝策略)为AbortPolicy: 抛出异常(handler).
13.
        */
14. private static ExecutorService THREAD\_POOL = new ThreadPoolExecutor(5, 10, 60, TimeUnit.MINUTES,
15.
               new LinkedBlockingQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(),
16.
               new ThreadPoolExecutor.AbortPolicy());
17.
18. /\*\*
19.
        * 只有一个线程的线程池 没有超时时间, 工作队列使用无界的LinkedBlockingQueue
20.
        */
21. private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
22. // private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());
23.
24. /\*\*
25.
        * 有固定线程的线程池(即corePoolSize = maximumPoolSize) 没有超时时间,
26.
        * 工作队列使用无界的LinkedBlockingQueue
27.
        */
28. private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
29. // private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5, Executors.defaultThreadFactory());
30.
31. /\*\*
32.
        * 大小不限的线程池 核心线程数为0, 最大线程数为Integer.MAX_VALUE, 存活时间为60秒 该线程池可以无限扩展,
33.
        * 并且当需求降低时会自动收缩, 工作队列使用同步移交SynchronousQueue.
34.
        */
35. private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
36. // private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool(Executors.defaultThreadFactory());
37.
38. /\*\*
39.
        * 给定的延迟之后运行任务, 或者定期执行任务的线程池
40.
        */
41. private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
42. // private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5, Executors.defaultThreadFactory());
43.
44. public static void main(String args\[]) throws Exception &#123;
45.
46.
           /**
47.
            * 例子1: 没有返回结果的异步任务
48.
            */
49.
           THREAD_POOL.submit(new Runnable() &#123;
50.
               @Override
51.
               public void run() &#123;
52.
                   // do something
53.
                   System.out.println(&quot;没有返回结果的异步任务&quot;);
54.
               &#125;
55.
           &#125;);
56.
57.
           /**
58.
            * 例子2: 有返回结果的异步任务
59.
            */
60.
           Future&lt;List&lt;String&gt;&gt; future = THREAD_POOL.submit(new Callable&lt;List&lt;String&gt;&gt;() &#123;
61.
               @Override
62.
               public List&lt;String&gt; call() &#123;
63.
                   List&lt;String&gt; result = new ArrayList&lt;&gt;();
64.
                   result.add(&quot;JoonWhee&quot;);
65.
                   return result;
66.
               &#125;
67.
           &#125;);
68.
           List&lt;String&gt; result = future.get(); // 获取返回结果
69.
           System.out.println(&quot;有返回结果的异步任务: &quot; + result);
70.
71.
           /**
72.
            * 例子3: 
73.
            * 有延迟的, 周期性执行异步任务
74.
            * 本例子为: 延迟1秒, 每2秒执行1次
75.
            */
76.
           scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123;
77.
               @Override
78.
               public void run() &#123;
79.
                   System.out.println(&quot;this is &quot; + Thread.currentThread().getName());
80.
               &#125;
81.
82.
           &#125;, 1, 2, TimeUnit.SECONDS);
83.
84.
           /**
85.
            * 例子4: FutureTask的使用
86.
            */
87.
           Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123;
88.
               public String call() &#123;
89.
                   return &quot;JoonWhee&quot;;
90.
               &#125;
91.
           &#125;;      
92.
           FutureTask&lt;String&gt; futureTo = new FutureTask&lt;String&gt;(task);
93.
           THREAD_POOL.submit(futureTo);
94.
           System.out.println(futureTo.get()); // 获取返回结果

112.//        System.out.println(futureTo.get(3, TimeUnit.SECONDS));  // 超时时间为3秒
113\.    &#125;
114.&#125;

线程池的定义和优点
线程池，从字面含义来看，是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
“在线程池中执行任务“”比“为每个线程分配一个任务”优势更多。通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。

线程池的工作流程
1.默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） 
2.当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  
3.当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  
4.当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。
5.当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 
6.如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。

工作队列
如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源。常见的工作队列有以下几种，前三种用的最多。
1.ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。
2.LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界/无界队列，先进先出。
3.SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue才有实际价值.
4.PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。

5.DelayedWorkQueue：延迟的工作队列，无界队列。

饱和策略（拒绝策略）
当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。（如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略）。饱和策略有以下四种，一般使用默认的AbortPolicy。
1.AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。

2.DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。

3.DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。

4.CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。

线程工厂
每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法。Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。
1.DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。
2.PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。
3.自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。

ThreadPoolExecutor源码解析
几个点
了解这几个点，有助于你阅读下面的源码解释。
1.下面的源码解读中提到的运行状态就是runState，有效的线程数就是workerCount，内容比较多，所以可能两种写法都用到。
2.运行状态的一些定义：RUNNING：接受新任务并处理排队任务； SHUTDOWN：不接受新任务，但处理排队任务； STOP：不接受新任务，不处理排队任务，并中断正在进行的任务；TIDYING：所有任务已经终止，workerCount为零，线程转换到状态TIDYING将运行terminate()钩子方法；TERMINATED：terminated()已经完成，该方法执行完毕代表线程池已经完全终止。
3.运行状态之间并不是随意转换的，大多数状态都只能由固定的状态转换而来，转换关系见第4点\~第8点。
4.RUNNING - &gt; SHUTDOWN：在调用shutdown()时，可能隐含在finalize()。
5.(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()。
6.SHUTDOWN - &gt; TIDYING：当队列和线程池都是空的时。

7.STOP - &gt; TIDYING：当线程池为空时。

8.TIDYING - &gt; TERMINATED：当terminate()方法完成时。

基础属性（很重要）
1./\*\*

1.
    *   主池控制状态ctl是包含两个概念字段的原子整数: workerCount：指有效的线程数量；
2.
    *   runState：指运行状态，运行，关闭等。为了将workerCount和runState用1个int来表示，
3.
    *   我们限制workerCount范围为(2 ^ 29) - 1，即用int的低29位用来表示workerCount，
4.
    *   用int的高3位用来表示runState，这样workerCount和runState刚好用int可以完整表示。
5.  \*/
    7.// 初始化时有效的线程数为0, 此时ctl为: 1010 0000 0000 0000 0000 0000 0000 0000
    8.private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    9.// 高3位用来表示运行状态，此值用于运行状态向左移动的位数，即29位
    10.private static final int COUNT\_BITS = Integer.SIZE - 3;\
    11.// 线程数容量，低29位表示有效的线程数, 0001 1111 1111 1111 1111 1111 1111 1111
    12.private static final int CAPACITY   = (1 &lt;&lt; COUNT\_BITS) - 1;
6.

14./\*\*
15\. \* 大小关系：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED，

1.
    *   源码中频繁使用大小关系来作为条件判断。
2.
    *   1010 0000 0000 0000 0000 0000 0000 0000 运行
3.
    *   0110 0000 0000 0000 0000 0000 0000 0000 关闭
4.
    *   0110 0000 0000 0000 0000 0000 0000 0000 停止
5.
    *   0110 0000 0000 0000 0000 0000 0000 0000 整理
6.
    *   0110 0000 0000 0000 0000 0000 0000 0000 终止
7.  \*/
    23.private static final int RUNNING    = -1 &lt;&lt; COUNT\_BITS; // 运行
    24.private static final int SHUTDOWN   =  0 &lt;&lt; COUNT\_BITS; // 关闭
    25.private static final int STOP       =  1 &lt;&lt; COUNT\_BITS; // 停止
    26.private static final int TIDYING    =  2 &lt;&lt; COUNT\_BITS; // 整理
    27.private static final int TERMINATED =  3 &lt;&lt; COUNT\_BITS; // 终止
8.

29./\*\*
30\. \* 得到运行状态:入参c为ctl的值，\~CAPACITY高3位为1低29位全为0,

1.
    *   因此运算结果为ctl的高3位, 也就是运行状态
2.  */
    33.private static int runStateOf(int c)     &#123; return c &amp; \~CAPACITY; &#125;\
    34./*\*
3.
    *   得到有效的线程数:入参c为ctl的值, CAPACITY高3为为0,
4.
    *   低29位全为1, 因此运算结果为ctl的低29位, 也就是有效的线程数
5.  */
    38.private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;\
    39./*\*
6.
    *   得到ctl的值：高3位的运行状态和低29位的有效线程数进行或运算,
7.
    *   组合成一个完成的32位数
8.  \*/
    43.private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;
9.

45.// 状态c是否小于s
46.private static boolean runStateLessThan(int c, int s) &#123;

1.  return c &lt; s;
    48.&#125;
    49.// 状态c是否大于等于s
    50.private static boolean runStateAtLeast(int c, int s) &#123;
2.  return c &gt;= s;
    52.&#125;
    53.// 状态c是否为RUNNING（小于SHUTDOWN的状态只有RUNNING）
    54.private static boolean isRunning(int c) &#123;
3.  return c &lt; SHUTDOWN;
    56.&#125;
4.

58.// 使用CAS增加一个有效的线程
59.private boolean compareAndIncrementWorkerCount(int expect) &#123;

1.  return ctl.compareAndSet(expect, expect + 1);
    61.&#125;
2.

63.// 使用CAS减少一个有效的线程
64.private boolean compareAndDecrementWorkerCount(int expect) &#123;

1.  return ctl.compareAndSet(expect, expect - 1);
    66.&#125;
2.

68.// 减少一个有效的线程
69.private void decrementWorkerCount() &#123;

1.  do &#123;&#125; while (! compareAndDecrementWorkerCount(ctl.get()));
    71.&#125;
2.

73.// 工作队列
74.private final BlockingQueue\&lt;Runnable&gt; workQueue;

1.

76.// 锁
77.private final ReentrantLock mainLock = new ReentrantLock();

1.

79.// 包含线程池中的所有工作线程,只有在mainLock的情况下才能访问,Worker集合
80.private final HashSet\&lt;Worker&gt; workers = new HashSet\&lt;Worker&gt;();

1.

82.private final Condition termination = mainLock.newCondition();
83\.
84.// 跟踪线程池的最大到达大小，仅在mainLock下访问
85.private int largestPoolSize;

1.

87.// 总的完成的任务数
88.private long completedTaskCount;

1.

90.// 线程工厂，用于创建线程
91.private volatile ThreadFactory threadFactory;

1.

93.// 拒绝策略
94.private volatile RejectedExecutionHandler handler;

1.
2.

97./\*\*
98\. \* 线程超时时间，当线程数超过corePoolSize时生效,

1.
    *   如果有线程空闲时间超过keepAliveTime, 则会被终止
2.  \*/
    101.private volatile long keepAliveTime;
3.

103.// 是否允许核心线程超时，默认false，false情况下核心线程会一直存活。
104.private volatile boolean allowCoreThreadTimeOut;

1.

106.// 核心线程数
107.private volatile int corePoolSize;

1.

109.// 最大线程数
110.private volatile int maximumPoolSize;

1.

112.// 默认饱和策略（拒绝策略）, 抛异常
113.private static final RejectedExecutionHandler defaultHandler =

1.  new AbortPolicy();
2.

116.private static final RuntimePermission shutdownPerm =
117\.    new RuntimePermission(&quot;modifyThread&quot;);

1.

119./\*\*
120\. \* Worker类，每个Worker包含一个线程、一个初始任务、一个任务计算器

1.  \*/
    122.private final class Worker
2.  extends AbstractQueuedSynchronizer
3.  implements Runnable
    125.&#123;
4.  private static final long serialVersionUID = 6138294804551838833L;
5.
6.  final Thread thread;    // Worker对应的线程
7.  Runnable firstTask; // 运行的初始任务。
8.  volatile long completedTasks;   // 每个线程的任务计数器
9.
10. Worker(Runnable firstTask) &#123;
11.
           setState(-1); // 禁止中断，直到runWorker
12.
           this.firstTask = firstTask; // 设置为初始任务
13.
           // 使用当前线程池的线程工厂创建一个线程
14.
           this.thread = getThreadFactory().newThread(this);  
15. &#125;
16.
17. // 将主运行循环委托给外部runWorker
18. public void run() &#123;
19.
           runWorker(this);
20. &#125;
21.
22. // Lock methods
23. //
24. // The value 0 represents the unlocked state.
25. // The value 1 represents the locked state.
26. /\*\*
27.
        * 通过AQS的同步状态来实现锁机制。state为0时代表锁未被获取（解锁状态），
28.
        * state为1时代表锁已经被获取（加锁状态）。
29.
        */
30. protected boolean isHeldExclusively() &#123; //
31.
           return getState() != 0; 
32. &#125;
33. protected boolean tryAcquire(int unused) &#123;  // 尝试获取锁
34.
           if (compareAndSetState(0, 1)) &#123; // 使用CAS尝试将state设置为1，即尝试获取锁
35.
               // 成功将state设置为1，则当前线程拥有独占访问权
36.
               setExclusiveOwnerThread(Thread.currentThread());    
37.
               return true;
38.
           &#125;
39.
           return false;
40. &#125;
41. protected boolean tryRelease(int unused) &#123;  // 尝试释放锁
42.
           setExclusiveOwnerThread(null);  // 释放独占访问权：即将独占访问线程设为null
43.
           setState(0);    // 解锁：将state设置为0
44.
           return true;
45. &#125;
46. public void lock()        &#123; acquire(1); &#125;   // 加锁
47. public boolean tryLock()  &#123; return tryAcquire(1); &#125; // 尝试加锁
48. public void unlock()      &#123; release(1); &#125;   // 解锁
49. public boolean isLocked() &#123; return isHeldExclusively(); &#125;  // 是否为加锁状态
50. void interruptIfStarted() &#123; // 如果线程启动了，则进行中断
51.
           Thread t;
52.
           if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;
53.
               try &#123;
54.
                   t.interrupt();
55.
               &#125; catch (SecurityException ignore) &#123;
56.
               &#125;
57.
           &#125;
58. &#125;
    181.&#125;

execute方法
使用线程池的submit方法提交任务时，会走到该方法，该方法也是线程池最重要的方法。

1.public void execute(Runnable command) &#123;
2\.    if (command == null)    // 为空校验

1.
            throw new NullPointerException();
2.
3.  int c = ctl.get();  // 拿到当前的ctl值
4.  if (workerCountOf(c) &lt; corePoolSize) &#123;  // 如果有效的线程数小于核心线程数
5.
            if (addWorker(command, true))   // 则新建一个线程来处理任务（核心线程）
6.
                return;
7.
            c = ctl.get();  // 拿到当前的ctl值
8.  &#125;
9.  // 走到这里说明有效的线程数已经 &gt;= 核心线程数
10. if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;// 如果当前状态是运行, 尝试将任务放入工作队列
11.
           int recheck = ctl.get();    // 再次拿到当前的ctl值
12.
           // 如果再次检查状态不是运行, 则将刚才添加到工作队列的任务移除
13.
           if (! isRunning(recheck) &amp;&amp; remove(command)) 
14.
               reject(command);    // 并调用拒绝策略
15.
           else if (workerCountOf(recheck) == 0) // 如果再次检查时,有效的线程数为0, 
16.
               addWorker(null, false); // 则新建一个线程(非核心线程)
17. &#125;
18. // 走到这里说明工作队列已满
19. else if (!addWorker(command, false))//尝试新建一个线程来处理任务(非核心)
20.
           reject(command);    // 如果失败则调用拒绝策略

23.&#125;
该方法就是对应上文的线程池的工作流程。主要调用到的方法为addWorker（见下文addWorker方法解读）。

addWorker方法
1./\*\*

1.
    *   添加一个Worker，Worker包含一个线程和一个任务，由这个线程来执行该任务。
2.  \*/
    4.private boolean addWorker(Runnable firstTask, boolean core) &#123;
3.  retry:
4.  for (;;) &#123;
5.
            int c = ctl.get();  // c赋值为ctl
6.
            int rs = runStateOf(c); // rs赋值为运行状态
7.
            /**
8.
             * 1.如果池停止或有资格关闭，则此方法返回false；
9.
             * 如果线程工厂在被询问时未能创建线程，它也返回false。 
10.
            * 包括以下5种情况：
11.
            * 1).rs为RUNNING，通过校验。
12.
            * 2).rs为STOP或TIDYING或TERMINATED，返回false。
13.
            * （STOP、TIDYING、TERMINATED：已经停止进入最后清理终止，不接受任务不处理队列任务）
14.
            * 3).rs为SHUTDOWN，提交的任务不为空，返回false。
15.
            * （SHUTDOWN：不接受任务但是处理队列任务，因此任务不为空返回false）
16.
            * 4).rs为SHUTDOWN，提交的任务为空，并且工作队列为空，返回false。
17.
            * （状态为SHUTDOWN、提交的任务为空、工作队列为空，则线程池有资格关闭，直接返回false）
18.
            * 5).rs为SHUTDOWN，提交的任务为空，并且工作队列不为空，通过校验。
19.
            * （因为SHUTDOWN状态下刚好可以处理队列任务）
20.
            */
21.
           if (rs &gt;= SHUTDOWN &amp;&amp;
22.
               ! (rs == SHUTDOWN &amp;&amp;
23.
                  firstTask == null &amp;&amp;
24.
                  ! workQueue.isEmpty()))
25.
               return false;
26.
27.
           for (;;) &#123;
28.
               int wc = workerCountOf(c);  // 拿到有效的线程数
29.
               // 校验有效的线程数是否超过阈值
30.
               if (wc &gt;= CAPACITY ||
31.
                   wc &gt;= (core ? corePoolSize : maximumPoolSize))
32.
                   return false;
33.
               // 使用CAS将workerCount+1, 修改成功则跳出循环，否则进入下面的状态判断
34.
               if (compareAndIncrementWorkerCount(c))
35.
                   break retry;
36.
               c = ctl.get();  // 重新读取ctl
37.
               // 判断当前运行状态，如果不等于上面获取的运行状态rs，
38.
               // 说明rs被其他线程修改了，跳到retry重新校验线程池状态
39.
               if (runStateOf(c) != rs)
40.
                   continue retry;
41.
               // 走到这里说明compareAndIncrementWorkerCount失败; 
42.
               // 重试内部循环（状态没变，则继续内部循环，尝试使用CAS修改workerCount）
43.
           &#125;
44. &#125;
45.
46. boolean workerStarted = false;  // Worker的线程是否启动
47. boolean workerAdded = false;    // Worker是否成功增加
48. Worker w = null;
49. try &#123;
50.
           w = new Worker(firstTask);  // 用firstTask和当前线程创建一个Worker
51.
           final Thread t = w.thread;  // 拿到Worker对应的线程
52.
           if (t != null) &#123;
53.
               final ReentrantLock mainLock = this.mainLock;
54.
               mainLock.lock();    // 加锁
55.
               try &#123;
56.
                   // Recheck while holding lock.
57.
                   // Back out on ThreadFactory failure or if
58.
                   // shut down before lock acquired.
59.
                   int rs = runStateOf(ctl.get()); // 加锁的情况下重新获取当前的运行状态
60.
61.
                   // 如果当前的运行状态为RUNNING，
62.
                   // 或者当前的运行状态为SHUTDOWN并且firstTask为空，则通过校验
63.
                   if (rs &lt; SHUTDOWN ||
64.
                       (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;
65.
                       if (t.isAlive())    // 预先校验线程是可以启动的
66.
                           throw new IllegalThreadStateException();
67.
                       workers.add(w); // 将刚创建的worker添加到工作者列表
68.
                       int s = workers.size();
69.
                       if (s &gt; largestPoolSize)
70.
                           largestPoolSize = s;
71.
                       workerAdded = true;
72.
                   &#125;
73.
               &#125; finally &#123;
74.
                   mainLock.unlock();
75.
               &#125;
76.
               if (workerAdded) &#123;  // 如果Worker添加成功，则启动线程执行
77.
                   t.start();
78.
                   workerStarted = true;
79.
               &#125;
80.
           &#125;
81. &#125; finally &#123;
82.
           if (! workerStarted)    // 如果Worker的线程没有成功启动
83.
               addWorkerFailed(w); // 则进行回滚, 移除之前添加的Worker
84. &#125;
85. return workerStarted;
    88.&#125;
    该方法主要目的就是使用入参中的firstTask和当前线程添加一个Worker，前面的for循环主要是对当前线程池的运行状态和有效的线程数进行一些校验，校验逻辑比较绕，可以参考注释进行理解。该方法涉及到的其他方法有addWorkerFailed（见下文addWorkerFailed源码解读）；还有就是Worker的线程启动时，会调用Worker里的run方法，执行runWorker(this)方法（见下文runWorker源码解读）。

addWorkerFailed方法
1./\*\*

1.
    *   Rolls back the worker thread creation.
2.
    *
        *   removes worker from workers, if present
3.
    *
        *   decrements worker count
4.
    *
        *   rechecks for termination, in case the existence of this
5.
    *   worker was holding up termination
6.  \*/
    8.private void addWorkerFailed(Worker w) &#123;    // 回滚Worker的添加，就是将Worker移除
7.  final ReentrantLock mainLock = this.mainLock;
8.  mainLock.lock();
9.  try &#123;
10.
           if (w != null)
11.
               workers.remove(w);  // 移除Worker
12.
           decrementWorkerCount(); // 有效线程数-1
13.
           tryTerminate(); // 有worker线程移除，可能是最后一个线程退出需要尝试终止线程池
14. &#125; finally &#123;
15.
           mainLock.unlock();
16. &#125;
    19.&#125;
    该方法很简单，就是移除入参中的Worker并将workerCount-1，最后调用tryTerminate尝试终止线程池，tryTerminate见下文对应方法源码解读。

runWorker方法
上文addWork方法里说道，当Worker里的线程启动时，就会调用该方法。
1./\*\*

1.
    *   Worker的线程开始执行任务
2.  \*/
    4.final void runWorker(Worker w) &#123;
3.  Thread wt = Thread.currentThread(); // 获取当前线程
4.  Runnable task = w\.firstTask;    // 拿到Worker的初始任务
5.  w\.firstTask = null;
6.  w\.unlock(); // allow interrupts
7.  boolean completedAbruptly = true;   // Worker是不是因异常而死亡
8.  try &#123;
9.
            while (task != null || (task = getTask()) != null) &#123;// Worker取任务执行
10.
               w.lock();   // 加锁
11.
               /**如果线程池停止，确保线程中断; 如果不是，确保线程不被中断。
12.
                * 在第二种情况下进行重新检查，以便在清除中断的同时处理shutdownNow竞争
13.
                * 线程池停止指运行状态为STOP/TIDYING/TERMINATED中的一种
14.
                */
15.
               if ((runStateAtLeast(ctl.get(), STOP) ||    // 判断线程池运行状态
16.
                    (Thread.interrupted() &amp;&amp;   // 重新检查
17.
                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp; // 再次判断线程池运行状态
18.
                   !wt.isInterrupted())// 走到这里代表线程池运行状态为停止,检查wt是否中断
19.
                   wt.interrupt(); // 线程池的状态为停止并且wt不为中断, 则将wt中断
20.
               try &#123;
21.
                   beforeExecute(wt, task);// 执行beforeExecute（默认空，需要自己重写）
22.
                   Throwable thrown = null;
23.
                   try &#123;
24.
                       task.run(); // 执行任务
25.
                   &#125; catch (RuntimeException x) &#123;
26.
                       thrown = x; throw x; //如果抛异常,则completedAbruptly为true
27.
                   &#125; catch (Error x) &#123;
28.
                       thrown = x; throw x;
29.
                   &#125; catch (Throwable x) &#123;
30.
                       thrown = x; throw new Error(x);
31.
                   &#125; finally &#123;
32.
                       afterExecute(task, thrown);// 执行afterExecute（需要自己重写）
33.
                   &#125;
34.
               &#125; finally &#123;
35.
                   task = null;    // 将执行完的任务清空
36.
                   w.completedTasks++; // Worker完成任务数+1
37.
                   w.unlock();
38.
               &#125;
39.
           &#125;
40.
           completedAbruptly = false;  // 如果执行到这里，则worker是正常退出
41. &#125; finally &#123;
42.
           processWorkerExit(w, completedAbruptly);// 调用processWorkerExit方法
43. &#125;
    46.&#125;
    该方法为Worker线程开始执行任务，首先执行当初创建Worker时的初始任务，接着从工作队列中获取任务执行。主要涉及两个方法：获取任务的方法getTask（见下文getTask源码解读）和执行Worker退出的方法processWorkerExit（见下文processWorkerExit源码解读）。注：processWorkerExit在处理正常Worker退出时，没有对workerCount-1，而是在getTask方法中进行workerCount-1。

getTask方法
1.private Runnable getTask() &#123;    // Worker从工作队列获取任务

1.  boolean timedOut = false; // poll方法取任务是否超时
2.
3.  for (;;) &#123;  // 无线循环
4.
            int c = ctl.get();  // ctl
5.
            int rs = runStateOf(c); // 当前运行状态
6.
7.
            // 如果线程池运行状态为停止，或者可以停止（状态为SHUTDOWN并且队列为空）
8.
            // 则返回null，代表当前Worker需要移除
9.
            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;    
10.
               decrementWorkerCount(); // 将workerCount - 1
11.
               // 返回null前将workerCount - 1,
12.
               // 因此processWorkerExit中completedAbruptly＝false时无需再减
13.
               return null;
14.
           &#125;
15.
16.
           int wc = workerCountOf(c);  // 当前的workerCount
17.
18.
           // 判断当前Worker是否可以被移除, 即当前Worker是否可以一直等待任务。
19.
           // 如果allowCoreThreadTimeOut为true，或者workerCount大于核心线程数，
20.
           // 则当前线程是有超时时间的（keepAliveTime），无法一直等待任务。
21.
           boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;    
22.
23.
           // 如果wc超过最大线程数 或者 当前线程会超时并且已经超时，
24.
           // 并且wc &gt; 1 或者 工作队列为空，则返回null，代表当前Worker需要移除
25.
           if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
26.
               &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;   // 确保有Worker可以移除 
27.
               if (compareAndDecrementWorkerCount(c))
28.
                   // 返回null前将workerCount - 1，
29.
                   // 因此processWorkerExit中completedAbruptly＝false时无需再减
30.
                   return null;    
31.
               continue;
32.
           &#125;
33.
34.
           try &#123;
35.
               // 根据线程是否会超时调用相应的方法，poll为带超时的获取任务方法
36.
               // take()为不带超时的获取任务方法，会一直阻塞直到获取到任务
37.
               Runnable r = timed ? 
38.
                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
39.
                   workQueue.take();
40.
               if (r != null)
41.
                   return r;
42.
               timedOut = true;    // 走到这代表当前线程获取任务超时
43.
           &#125; catch (InterruptedException retry) &#123;
44.
               timedOut = false;   // 被中断
45.
           &#125;
46. &#125;
    48.&#125;
    Worker从工作队列获取任务，如果allowCoreThreadTimeOut为false并且  workerCount&lt;=corePoolSize，则这些核心线程永远存活，并且一直在尝试获取工作队列的任务；否则，线程会有超时时间（keepAliveTime），当在keepAliveTime时间内获取不到任务，该线程的Worker会被移除。 
    Worker移除的过程：getTask方法返回null，导致runWorker方法中跳出while循环，调用processWorkerExit方法将Worker移除。注意：在返回null的之前，已经将workerCount-1，因此在processWorkerExit中，completedAbruptly=false的情况（即正常超时退出）不需要再将workerCount-1。

processWorkerExit方法
1.private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;   // Worker的退出

1.  // 如果Worker是异常死亡（completedAbruptly=true），则workerCount-1；
2.  // 如果completedAbruptly为false的时候（正常超时退出），则代表task=getTask()等于null，
3.  // getTask()方法中返回null的地方，都已经将workerCount - 1，所以此处无需再-1
4.  if (completedAbruptly)
5.
            decrementWorkerCount();
6.
7.  final ReentrantLock mainLock = this.mainLock;
8.  mainLock.lock();    // 加锁
9.  try &#123;
10.
           completedTaskCount += w.completedTasks; // 该Worker完成的任务数加到总完成的任务数
11.
           workers.remove(w);  // 移除该Worker
12. &#125; finally &#123;
13.
           mainLock.unlock();
14. &#125;
15.
16. tryTerminate(); // 有Worker线程移除，可能是最后一个线程退出，需要尝试终止线程池
17.
18. int c = ctl.get();  // 获取当前的ctl
19. if (runStateLessThan(c, STOP)) &#123;  // 如果线程池的运行状态还没停止（RUNNING或SHUTDOWN）
20.
           if (!completedAbruptly) &#123;   // 如果Worker不是异常死亡
21.
               // min为线程池的理论最小线程数:如果允许核心线程超时则min为0,否则min为核心线程数
22.
               int min = allowCoreThreadTimeOut ? 0 : corePoolSize;    
23.
               // 如果min为0,工作队列不为空,将min设置为1,确保至少有1个Worker来处理队列里的任务 
24.
               if (min == 0 &amp;&amp; ! workQueue.isEmpty())
25.
                   min = 1;
26.
               // 当前有效的线程数&gt;=min，直接返回;
27.
               if (workerCountOf(c) &gt;= min)
28.
                   return; // replacement not needed 
29.
               // 如果代码走到这边，代表workerCountOf(c) &lt; min，此时会走到下面的addWorker方法。
30.
               // 通过getTask方法我们知道，当allowCoreThreadTimeOut为false
31.
               // 并且workerCount&lt;=corePoolSize时，是不会走到processWorkerExit方法的。
32.
               // 因此走到这边只可能是当前移除的Worker是最后一个Worker，但是此时工作
33.
               // 队列还不为空，因此min被设置成了1，所以需要在添加一个Worker来处理工作队列。
34.
           &#125;
35.
           addWorker(null, false); // 添加一个Worker
36. &#125;
    38.&#125;
    该方法就是执行Worker的退出：统计完成的任务数，将Worker移除，并尝试终止线程池，最后根据情况决定是否创建一个新的Worker。两种情况下会创建一个新的Worker：1）被移除的Worker是由于异常而死亡；2）被移除的Worker是最后一个Worker，但是工作队列还有任务。completedAbruptly=false时，没有将workerCount-1是因为已经在getTask方法中将workerCount-1。

tryTerminate方法
1.final void tryTerminate() &#123; // 尝试终止线程池

1.  for (;;) &#123;
2.
            int c = ctl.get();
3.
            // 只有当前状态为STOP 或者 SHUTDOWN并且队列为空，才会尝试整理并终止
4.
            // 1: 当前状态为RUNNING，则不尝试终止，直接返回
5.
            // 2: 当前状态为TIDYING或TERMINATED，代表有其他线程正在执行终止，直接返回
6.
            // 3: 当前状态为SHUTDOWN 并且 workQueue不为空，则不尝试终止，直接返回
7.
            if (isRunning(c) || // 1
8.
                runStateAtLeast(c, TIDYING) ||  // 2
9.
                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))   // 3
10.
               return;
11.
           // 走到这代表线程池可以终止（通过上面的校验）
12.
           // 如果此时有效线程数不为0， 将中断一个空闲的Worker，以确保关闭信号传播
13.
           if (workerCountOf(c) != 0) &#123; // Eligible to terminate 
14.
               interruptIdleWorkers(ONLY_ONE);
15.
               return;
16.
           &#125;
17.
18.
           final ReentrantLock mainLock = this.mainLock;
19.
           mainLock.lock();    // 加锁，终止线程池
20.
           try &#123;
21.
               // 使用CAS将ctl的运行状态设置为TIDYING，有效线程数设置为0
22.
               if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;  
23.
                   try &#123;
24.
                       terminated();   // 供用户重写的terminated方法，默认为空
25.
                   &#125; finally &#123;
26.
                       // 将ctl的运行状态设置为TERMINATED，有效线程数设置为0
27.
                       ctl.set(ctlOf(TERMINATED, 0));  
28.
                       termination.signalAll();
29.
                   &#125;
30.
                   return;
31.
               &#125;
32.
           &#125; finally &#123;
33.
               mainLock.unlock();
34.
           &#125;
35.
           // else retry on failed CAS
36. &#125;
    38.&#125;
    该方法用来尝试终止线程池，主要在移除Worker后会调用此方法。首先进行一些状态的校验，如果通过校验，则在加锁的条件下，使用CAS将运行状态设为TERMINATED，有效线程数设为0。

深入理解Callable
概述
Callable和Runnbale一样代表着任务，区别在于Callable有返回值并且可以抛出异常。其使用如下：
public class CallableDemo &#123;
static class SumTask implements Callable\&lt;Long&gt; &#123;
@Override
public Long call() throws Exception &#123;
long sum = 0;
for (int i = 0; i &lt; 9000; i++) &#123;
sum += i;
&#125;
return sum;
&#125;
&#125;
public static void main(String\[] args) throws ExecutionException, InterruptedException &#123;
System.out.println(&quot;Start:&quot; + System.nanoTime());
FutureTask\&lt;Long&gt; futureTask = new FutureTask\&lt;Long&gt;(new SumTask());
Executor executor=Executors.newSingleThreadExecutor();
executor.execute(futureTask);
System.out.println(futureTask.get());
System.out.println(&quot;End:&quot; + System.nanoTime());
&#125;
&#125;
从上面的代码可以看到，使用到了一个FutureTask的变量并且还可以得到Callable执行的结果，那么这个FutureTask是什么呢?
分析
Future接口
Future是一个接口，代表了一个异步计算的结果。接口中的方法用来检查计算是否完成、等待完成和得到计算的结果。当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了。如果想取消，那么调用cancel()方法。其他方法用于确定任务是正常完成还是取消了。一旦计算完成了，那么这个计算就不能被取消。
FutureTask类
FutureTask类实现了RunnableFuture接口，而RunnnableFuture接口继承了Runnable和Future接口，所以说FutureTask是一个提供异步计算的结果的任务。 
FutureTask可以用来包装Callable或者Runnbale对象。因为FutureTask实现了Runnable接口，所以FutureTask也可以被提交给Executor（如上面例子那样）。
FutureTask的状态
FutureTask中有一个表示任务状态的int值，初始为NEW。定义如下：
private volatile int state;
private static final int NEW          = 0;
private static final int COMPLETING   = 1;
private static final int NORMAL       = 2;
private static final int EXCEPTIONAL  = 3;
private static final int CANCELLED    = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED  = 6;
可能的状态转换包括： 

*   NEW -&gt; COMPLETING -&gt; NORMAL 
*   NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 
*   NEW -&gt; CANCELLED 
*   NEW -&gt; INTERRUPTING -&gt; INTERRUPTED
    构造方法
    FutureTask一共有两个构造方法，如下:
    public FutureTask(Callable\&lt;V&gt; callable) &#123;
    if (callable == null)
    throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
    &#125;

    public FutureTask(Runnable runnable, V result) &#123;
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
    &#125;
    第一个构造方法好理解；第二个方法是将Runnbale和结果组合成一个Callable，这个可以通过Excutors.callable()方法得出结论：
    public static \&lt;T&gt; Callable\&lt;T&gt; callable(Runnable task, T result) &#123;
    if (task == null)
    throw new NullPointerException();
    return new RunnableAdapter\&lt;T&gt;(task, result);
    &#125;

static final class RunnableAdapter\&lt;T&gt; implements Callable\&lt;T&gt; &#123;
final Runnable task;
final T result;
RunnableAdapter(Runnable task, T result) &#123;
this.task = task;
this.result = result;
&#125;
public T call() &#123;
task.run();
return result;
&#125;
&#125;
从上面可以看到RunnableAdapter实现了Callable并且在call方法中调用了Runnable的run方法，然后将结果返回，这其实就是一个适配器模式啊。 
所以说两个构造方法最终都是得到了一个Callable以及设置了初始状态为NEW。
run方法
当将FutureTask提交给Executor后，Executor执行FutureTask时会执行其run方法，下面看一下run方法中做了哪些事情。
public void run() &#123;
//如果状态不为NEW或者CAS当前执行线程失败，直接返回
if (state != NEW ||
!UNSAFE.compareAndSwapObject(this, runnerOffset,
null, Thread.currentThread()))
return;
//尝试调用Callable.call
try &#123;
Callable\&lt;V&gt; c = callable;
if (c != null &amp;&amp; state == NEW) &#123;
V result;
boolean ran;
try &#123;
result = c.call();
ran = true;
&#125; catch (Throwable ex) &#123;
//出现异常了，调用setException方法
result = null;
ran = false;
setException(ex);
&#125;
//如果成功了，调用set方法
if (ran)
set(result);
&#125;
&#125; finally &#123;
// runner must be non-null until state is settled to
// prevent concurrent calls to run()
runner = null;
// state must be re-read after nulling runner to prevent
// leaked interrupts
//如果在执行过程，任务被取消了
int s = state;
if (s &gt;= INTERRUPTING)
handlePossibleCancellationInterrupt(s);
&#125;
&#125;
从上面可以看到，任务可以被执行的前提是当前状态为NEW以及CAS当前执行线程成功，也就是runner值，代表执行Callable的线程。从这个看到run方法就是调用Callable的call方法，然后如果出现异常了就调用setException方法，如果成功执行了，那么调用set方法，下面我们分别来看这几种情况。
set方法
当Callable成功执行后，会调用set方法将结果传出。源码如下：
protected void set(V v) &#123;
//完成NEW-&gt;COMPLETING-&gt;NORMAL状态转换
if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;
outcome = v;
UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
finishCompletion();
&#125;
&#125;
从上面可以看到，将outcome变量赋值为结果，并将state状态更新，最后调用finishCompletion()方法。finishCompletion()方法将移除和通知所有等待线程，这个方法后面再说。下面先看setException方法。
setException方法
setException方法如下：
//完成NEW-&gt;COMPLETING-&gt;EXCEPTIONAL状态转换
protected void setException(Throwable t) &#123;
if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;
outcome = t;
UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state
finishCompletion();
&#125;
&#125;
从上面看到，该方法和set方法类似，完成状态转换，将结果设置为Throwable并调用finishCompletion通知和移除等待线程。
get方法
当想得到FutureTask的结算结果时，调用get方法，get方法可以允许多个线程调用，下面的例子展示了多个线程调用get的情况。
public static void main(String\[] args) throws ExecutionException, InterruptedException &#123;
System.out.println(&quot;Start:&quot; + System.nanoTime());
FutureTask\&lt;Long&gt; futureTask = new FutureTask\&lt;Long&gt;(new SumTask());
Executor executor=Executors.newSingleThreadExecutor();
executor.execute(futureTask);
for(int i=0;i&lt;5;i++)&#123;
executor.execute(new Runnable() &#123;
@Override
public void run() &#123;
try &#123;
System.out.println(&quot;get result &quot;+futureTask.get());
&#125; catch (InterruptedException e) &#123;
e.printStackTrace();
&#125; catch (ExecutionException e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;);
&#125;
System.out.println(futureTask.get());
System.out.println(&quot;End:&quot; + System.nanoTime());
&#125;
该例子展示了一共有5个线程想得到FutureTask的结果，一旦调用get，那么该线程就会阻塞。 
FutureTask的get方法实现如下：
public V get() throws InterruptedException, ExecutionException &#123;
int s = state;
if (s &lt;= COMPLETING)
s = awaitDone(false, 0L);
return report(s);
&#125;
从上面的代码可以看到，如果当前任务的状态不大于COMPLETING，那么会调用awaitDone方法，这个方法会将调用的线程挂起；否则直接调用report方法返回结果。 
在前面set和setException方法中可以得出结论：当状态从NEW变为COMPLETING后，才会将outcome赋值，也就是状态是NEW或者COMPLETING时，outcome都还未赋值，也就意味着计算仍在进行，那么此时想要get到结果，就必须等待。下面先看下awaitDone方法是如何将调用线程阻塞的。awaitDone的两个参数分别表示是否定时，以及定时的时间多少。get的另一个重载方法就提供了超时限制。awaitDone方法如下：
private int awaitDone(boolean timed, long nanos)
throws InterruptedException &#123;
final long deadline = timed ? System.nanoTime() + nanos : 0L;
WaitNode q = null;
boolean queued = false;
for (;;) &#123;
//如果当前线程被中断了，移除并抛出异常
if (Thread.interrupted()) &#123;
removeWaiter(q);
throw new InterruptedException();
&#125;

            int s = state;
            //如果状态大于COMPLETING，说明已经计算已经完成了
            if (s &gt; COMPLETING) &#123;
                if (q != null)
                    q.thread = null;
                return s;
            &#125;
            //状态是COMPLETING，在set和setException方法中可以看到处于该状态马上就会进入下一个状态
            else if (s == COMPLETING) // cannot time out yet
                Thread.yield();
            //新建一个等待节点
            else if (q == null)
                q = new WaitNode();
            //还没有入队，尝试入队
            else if (!queued)
                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                     q.next = waiters, q);
            //如果限制了时间
            else if (timed) &#123;
                nanos = deadline - System.nanoTime();
                if (nanos &lt;= 0L) &#123;
                    removeWaiter(q);
                    return state;
                &#125;
                //挂起指定时间
                LockSupport.parkNanos(this, nanos);
            &#125;
            //无限挂起
            else
                LockSupport.park(this);
        &#125;
    &#125;

1
上面的代码中有一个WaitNode类，该类表示等待节点，保存等待的线程以及下一个节点，是一个单链表结构，其定义如下:
static final class WaitNode &#123;
volatile Thread thread;
volatile WaitNode next;
WaitNode() &#123; thread = Thread.currentThread(); &#125;
&#125;
awaitDone方法中进入死循环后，主要有几步： 

1.  如果线程被中断了，移除节点，抛出异常 
2.  如果状态大于COMPLETING，那么直接返回 
3.  如果状态是COMPLETING，在set和setException可以看到，处于COMPLETING是一个暂时状态，很快就会进入下一个状态，所以这儿就调用了Thread.yield()方法让步一下 
4.  如果状态是NEW且节点为null，那么创建一个节点 
5.  如果还没有将当前线程加入队列，那么将当前线程加入到等待队列中。由于WaitNode是一个单链表结构，FutureTask中保存了waiters的变量，就可以沿着该变量得到所有等待的线程 
6.  如果限制了时间，那么计算出生出超出时间，挂起指定时间。当解除挂起时，如果计算还未完成，那么将会由于没有时间了，调用removeWaiter方法移除节点。 
7.  如果没有限制时间，那么将线程无限挂起
    上面几种情况下，都涉及了移除节点，removeWaiter方法就是删除单链表中一个节点的实现。 
    当线程被解除挂起，或计算已经完成后，将会get方法中将会调用report返回结果，其实现如下：
    private V report(int s) throws ExecutionException &#123;
    Object x = outcome;
    //如果计算正常结束
    if (s == NORMAL)
    return (V)x;
    //如果计算被取消了
    if (s &gt;= CANCELLED)
    throw new CancellationException();
    //如果计算以异常计算
    throw new ExecutionException((Throwable)x);
    &#125;
    从上面可以看到report会根据任务的状态不同返回不同的结果。 

*   如果计算正常结束，即状态是NORMAL，那么返回正确的计算结果 
*   如果计算被取消了，即状态大于等于CANCELLED，那么抛出CancellationException 
*   如果计算以异常结束，即状态是EXCEPTIONAL，那么抛出ExecutionException
    finishCompletion方法
    在set方法和setException方法中，当将结果赋值后，都调用了finishCompletion方法来移除和通知等待线程。由于get方法中可以挂起了一群等待节点，那么当结果被计算出来了，自然应该通知那些等待线程。finishCompletion的实现如下：
    private void finishCompletion() &#123;
    //如果有等待线程，从头开始解除挂起
    for (WaitNode q; (q = waiters) != null;) &#123;
    if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;
    for (;;) &#123;
    //得到等待节点的线程，解除挂起
    Thread t = q.thread;
    if (t != null) &#123;
    q.thread = null;
    LockSupport.unpark(t);
    &#125;
    WaitNode next = q.next;
    if (next == null)
    break;
    q.next = null; // unlink to help gc
    q = next;
    &#125;
    break;
    &#125;
    &#125;
    done();
    callable = null;        // to reduce footprint
    &#125;
    finishCompletion的实现比较简单，就是遍历等待线程的单链表，释放那些等待线程。当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了NORMAL或者EXCEPTIONAL，将会直接跳出循环。 
    释放了所有线程后，将会调用done()方法，FutureTask的done()方法默认没有任何实现，子类可以在该方法中调用完成回调以及记录操作等等。 
    上面的方法分析完了FutureTask的主要流程，包括调用get线程的阻塞、run方法执行、计算结果的返回。下面再来看一些取消、查看状态的方法。
    cancel方法
    cancel方法用于取消Callable的计算。参数mayInterruptIfRunning指明是否应该中断正在运行的任务，返回值表示取消是否成功了。其源码如下：
    public boolean cancel(boolean mayInterruptIfRunning) &#123;
    if (!(state == NEW &amp;&amp;
    UNSAFE.compareAndSwapInt(this, stateOffset, NEW,
    mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
    return false;
    try &#123;
    //如果需要中断
    if (mayInterruptIfRunning) &#123;
    try &#123;
    Thread t = runner;
    if (t != null)
    t.interrupt();
    &#125; finally &#123;
    //最终状态INTERRUPTED
    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);
    &#125;
    &#125;
    &#125; finally &#123;
    //释放等待线程
    finishCompletion();
    &#125;
    return true;
    &#125;
    从上面可以看到如果是需要中断正在执行的任务，那么状态转换将会是NEW-&gt;INTERRPUTING-&gt;INTERRUPTED；如果不需要中断正在执行的任务，那么状态转换将会是NEW-&gt;CANCELD。不管是否中断，最终都会调用finishCompletion()完成对等待线程的释放。 
    当这些线程释放后，再进入到awaitDone中的循环时，返回的状态将会是大于等于CANCELD，在report方法中将会得到CancellationException异常。
    isDone方法
    Future接口中isDone方法表明任务是否已经完成了，如果完成了，那么返回true，否则false。下面是FutureTask的实现：
    public boolean isDone() &#123;
    return state != NEW;
    &#125;
    可以看到只要状态从初始状态NEW完成了一次转换，那么就说明任务已经被完成了。
    总结
    Callable是一种可以返回结果的任务，这是它与Runnable的区别，但是通过适配器模式可以使Runnable与Callable类似。Future代表了一个异步的计算，可以从中得到计算结果、查看计算状态，其实现FutureTask可以被提交给Executor执行，多个线程可以从中得到计算结果。Callable和Future是配合使用的，当从Future中get结果时，如果结果还没被计算出来，那么线程将会被挂起，FutureTak内部使用一个单链表维持等待的线程；当计算结果出来后，将会对等待线程解除挂起，等待线程就都可以得到计算结果了。

公平锁/非公平锁
可重入锁
独享锁/共享锁
互斥锁/读写锁
乐观锁/悲观锁(实现秒杀的一种解决方案)
（select \* from product p where  p.type=’xxxxx’  for update）

分段锁
偏向锁/轻量级锁/重量级锁
自旋锁
上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。
公平锁/非公平锁
公平锁是指多个线程按照申请锁的顺序来获取锁。
非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。
对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。
可重入锁
可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。
对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。
对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。
synchronized void setA() throws Exception&#123;
Thread.sleep(1000);
setB();
&#125;

synchronized void setB() throws Exception&#123;
Thread.sleep(1000);
&#125;
上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。
独享锁/共享锁
独享锁是指该锁一次只能被一个线程所持有。
共享锁是指该锁可被多个线程所持有。
对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
对于Synchronized而言，当然是独享锁。
互斥锁/读写锁
上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
互斥锁在Java中的具体实现就是ReentrantLock
读写锁在Java中的具体实现就是ReadWriteLock
乐观锁/悲观锁
乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
悲观锁在Java中的使用，就是利用各种锁。
乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
分段锁
分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。
偏向锁/轻量级锁/重量级锁
这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。
自旋锁
在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

99、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？

java5以前，有如下两种：
第一种：
new Thread()&#123;&#125;.start();这表示调用Thread子类对象的run方法，new Thread()&#123;&#125;表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：
new Thread()&#123;
public void run()&#123;
&#125;
&#125;.start();

第二种：
new Thread(new Runnable()&#123;&#125;).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable()&#123;&#125;表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：
new Thread(new Runnable()&#123;
public void run()&#123;
&#125;
&#125;
).start();

从java5开始，还有如下一些线程池创建多线程的方式：
ExecutorService pool = Executors.newFixedThreadPool(3)
for(int i=0;i&lt;10;i++)
&#123;
pool.execute(new Runable()&#123;public void run()&#123;&#125;&#125;);
&#125;
Executors.newCachedThreadPool().execute(new Runable()&#123;public void run()&#123;&#125;&#125;);
Executors.newSingleThreadExecutor().execute(new Runable()&#123;public void run()&#123;&#125;&#125;);

有两种实现方法，分别使用new Thread()和new Thread(runnable)形式，第一种直接调用thread的run方法，所以，我们往往使用Thread子类，即new SubThread()。第二种调用runnable的run方法。

有两种实现方法，分别是继承Thread类与实现Runnable接口
用synchronized关键字修饰同步方法
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被&quot;挂起&quot;的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。
13、sleep() 和 wait() 有什么区别?
（网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。）

sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。
package com.huawei.interview;

public class MultiThread &#123;

    /**
     * @param args
     */
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        new Thread(new Thread1()).start();
        try &#123;
            Thread.sleep(10);
        &#125; catch (InterruptedException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        new Thread(new Thread2()).start();        
    &#125;


    private static class Thread1 implements Runnable
    &#123;

        @Override
        public void run() &#123;
            // TODO Auto-generated method stub

//由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。
synchronized (MultiThread.class) &#123;

                System.out.println(&quot;enter thread1...&quot;);
                
                System.out.println(&quot;thread1 is waiting&quot;);
                try &#123;
            //释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。
                    MultiThread.class.wait();
                &#125; catch (InterruptedException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;
                
                System.out.println(&quot;thread1 is going on...&quot;);
                System.out.println(&quot;thread1 is being over!&quot;);            
            &#125;
        &#125;
        
    &#125;

    private static class Thread2 implements Runnable
    &#123;

        @Override
        public void run() &#123;
            // TODO Auto-generated method stub
            synchronized (MultiThread.class) &#123;
            
                System.out.println(&quot;enter thread2...&quot;);
                
                System.out.println(&quot;thread2 notify other thread can release wait status..&quot;);

//由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。

                MultiThread.class.notify();
                
                System.out.println(&quot;thread2 is sleeping ten millisecond...&quot;);
                try &#123;
                    Thread.sleep(10);
                &#125; catch (InterruptedException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;
                
                System.out.println(&quot;thread2 is going on...&quot;);
                System.out.println(&quot;thread2 is being over!&quot;);
                
            &#125;
        &#125;
        
    &#125;    

&#125;

16、同步和异步有何异同，在什么情况下分别使用他们？举例说明。
如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

1.  下面两个方法同步吗？（自己发明）
    class Test
    &#123;
    synchronized static void sayHello3()
    &#123;

        &#125;    

        synchronized void getX()&#123;&#125;

&#125;
56、多线程有几种实现方法?同步有几种实现方法?
多线程有两种实现方法，分别是继承Thread类与实现Runnable接口
同步的实现方面有两种，分别是synchronized,wait与notify
wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

30、启动一个线程是用run()还是start()? .
启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。

47、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
分几种情况：
1.其他方法前是否加了synchronized关键字，如果没加，则能。
2.如果这个方法内部调用了wait，则可以进入其他synchronized方法。
3.如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。
4.如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。

58、线程的基本概念、线程的基本状态以及状态之间的关系

一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。

状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。
调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。

71、简述synchronized和java.util.concurrent.locks.Lock的异同 ？
主要相同点：Lock能完成synchronized所实现的所有功能
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。
举例说明（对下面的题用lock进行了改写）：
package com.huawei.interview;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadTest &#123;

    /**
     * @param args
     */

    private int j;
    private Lock lock = new ReentrantLock();
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        ThreadTest tt = new ThreadTest();
        for(int i=0;i&lt;2;i++)
        &#123;
            new Thread(tt.new Adder()).start();
            new Thread(tt.new Subtractor()).start();
        &#125;
    &#125;

    private class Subtractor implements Runnable
    &#123;

        @Override
        public void run() &#123;
            // TODO Auto-generated method stub
            while(true)
            &#123;
                /*synchronized (ThreadTest.this) &#123;            
                    System.out.println(&quot;j--=&quot; + j--);
                    //这里抛异常了，锁能释放吗？
                &#125;*/
                lock.lock();
                try
                &#123;
                    System.out.println(&quot;j--=&quot; + j--);
                &#125;finally
                &#123;
                    lock.unlock();
                &#125;
            &#125;
        &#125;
        
    &#125;

    private class Adder implements Runnable
    &#123;

        @Override
        public void run() &#123;
            // TODO Auto-generated method stub
            while(true)
            &#123;
                /*synchronized (ThreadTest.this) &#123;
                System.out.println(&quot;j++=&quot; + j++);    
                &#125;*/
                lock.lock();
                try
                &#123;
                    System.out.println(&quot;j++=&quot; + j++);
                &#125;finally
                &#123;
                    lock.unlock();
                &#125;                
            &#125;            
        &#125;
        
    &#125;

&#125;
28、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。
以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。
public class ThreadTest1
&#123;
private int j;
public static void main(String args\[])&#123;
ThreadTest1 tt=new ThreadTest1();
Inc inc=tt.new Inc();
Dec dec=tt.new Dec();
for(int i=0;i&lt;2;i++)&#123;
Thread t=new Thread(inc);
t.start();
t=new Thread(dec);
t.start();
&#125;
&#125;
private synchronized void inc()&#123;
j++;
System.out.println(Thread.currentThread().getName()+&quot;-inc:&quot;+j);
&#125;
private synchronized void dec()&#123;
j--;
System.out.println(Thread.currentThread().getName()+&quot;-dec:&quot;+j);
&#125;
class Inc implements Runnable&#123;
public void run()&#123;
for(int i=0;i&lt;100;i++)&#123;
inc();
&#125;
&#125;
&#125;
class Dec implements Runnable&#123;
public void run()&#123;
for(int i=0;i&lt;100;i++)&#123;
dec();
&#125;
&#125;
&#125;
&#125;

\----------随手再写的一个-------------
class A
&#123;
JManger j =new JManager();
main()
&#123;
new A().call();
&#125;

void call
&#123;
for(int i=0;i&lt;2;i++)
&#123;
new Thread(
new Runnable()&#123; public void run()&#123;while(true)&#123;j.accumulate()&#125;&#125;&#125;
).start();
new Thread(new Runnable()&#123; public void run()&#123;while(true)&#123;j.sub()&#125;&#125;&#125;).start();
&#125;
&#125;
&#125;

class JManager
&#123;
private j = 0;

    public synchronized void subtract()
    &#123;
        j--
    &#125;

    public synchronized void accumulate()
    &#123;
        j++;
    &#125;

&#125;

28、子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。

最终的程序代码如下：
public class ThreadTest &#123;

    /**
     * @param args
     */
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        new ThreadTest().init();

    &#125;

    public void init()
    &#123;
        final Business business = new Business();
        new Thread(
                new Runnable()
                &#123;

                    public void run() &#123;
                        for(int i=0;i&lt;50;i++)
                        &#123;
                            business.SubThread(i);
                        &#125;                        
                    &#125;
                    
                &#125;
        
        ).start();
        
        for(int i=0;i&lt;50;i++)
        &#123;
            business.MainThread(i);
        &#125;        
    &#125;

    private class Business
    &#123;
        boolean bShouldSub = true;//这里相当于定义了控制该谁执行的一个信号灯
        public synchronized void MainThread(int i)
        &#123;
            if(bShouldSub)
                try &#123;
                    this.wait();
                &#125; catch (InterruptedException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;        
                
            for(int j=0;j&lt;5;j++)
            &#123;
                System.out.println(Thread.currentThread().getName() + &quot;:i=&quot; + i +&quot;,j=&quot; + j);
            &#125;
            bShouldSub = true;
            this.notify();
        
        &#125;
        
        
        public synchronized void SubThread(int i)
        &#123;
            if(!bShouldSub)
                try &#123;
                    this.wait();
                &#125; catch (InterruptedException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;    
                
            for(int j=0;j&lt;10;j++)
            &#123;
                System.out.println(Thread.currentThread().getName() + &quot;:i=&quot; + i +&quot;,j=&quot; + j);
            &#125;
            bShouldSub = false;                
            this.notify();            
        &#125;
    &#125;

&#125;

备注：不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去：

package com.huawei.interview\.lym;

public class ThreadTest &#123;

    private static boolean bShouldMain = false;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        /*new Thread()&#123;
        public void run()
        &#123;
            for(int i=0;i&lt;50;i++)
            &#123;
                for(int j=0;j&lt;10;j++)
                &#123;
                    System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);
                &#125;
            &#125;                
        &#125;
        
    &#125;.start();*/        
        
        
        //final String str = new String(&quot;&quot;);

        new Thread(
                new Runnable()
                &#123;
                    public void run()
                    &#123;
                        for(int i=0;i&lt;50;i++)
                        &#123;
                            synchronized (ThreadTest.class) &#123;
                                if(bShouldMain)
                                &#123;
                                    try &#123;
                                        ThreadTest.class.wait();&#125; 
                                    catch (InterruptedException e) &#123;
                                        e.printStackTrace();
                                    &#125;
                                &#125;
                                for(int j=0;j&lt;10;j++)
                                &#123;
                                    System.out.println(
                                            Thread.currentThread().getName() + 
                                            &quot;i=&quot; + i + &quot;,j=&quot; + j);
                                &#125;
                                bShouldMain = true;
                                ThreadTest.class.notify();
                            &#125;                            
                        &#125;                        
                    &#125;
                &#125;
        ).start();
        
        for(int i=0;i&lt;50;i++)
        &#123;
            synchronized (ThreadTest.class) &#123;
                if(!bShouldMain)
                &#123;
                    try &#123;
                        ThreadTest.class.wait();&#125; 
                    catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;                
                for(int j=0;j&lt;5;j++)
                &#123;
                    System.out.println(
                            Thread.currentThread().getName() +                         
                            &quot;i=&quot; + i + &quot;,j=&quot; + j);
                &#125;
                bShouldMain = false;
                ThreadTest.class.notify();                
            &#125;            
        &#125;
    &#125;

&#125;
下面使用jdk5中的并发库来实现的：
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;

public class ThreadTest
&#123;
private static Lock lock = new ReentrantLock();
private static Condition subThreadCondition = lock.newCondition();
private static boolean bBhouldSubThread = false;
public static void main(String \[] args)
&#123;
ExecutorService threadPool = Executors.newFixedThreadPool(3);
threadPool.execute(new Runnable()&#123;
public void run()
&#123;
for(int i=0;i&lt;50;i++)
&#123;
lock.lock();
try
&#123;
if(!bBhouldSubThread)
subThreadCondition.await();
for(int j=0;j&lt;10;j++)
&#123;
System.out.println(Thread.currentThread().getName() + &quot;,j=&quot; + j);
&#125;
bBhouldSubThread = false;
subThreadCondition.signal();
&#125;catch(Exception e)
&#123;
&#125;
finally
&#123;
lock.unlock();
&#125;
&#125;
&#125;

        &#125;);
        threadPool.shutdown();
        for(int i=0;i&lt;50;i++)
        &#123;
                lock.lock();                    
                try
                &#123;    
                    if(bBhouldSubThread)
                            subThreadCondition.await();                                
                    for(int j=0;j&lt;10;j++)
                    &#123;
                        System.out.println(Thread.currentThread().getName() + &quot;,j=&quot; + j);
                    &#125;
                    bBhouldSubThread = true;
                    subThreadCondition.signal();                    
                &#125;catch(Exception e)
                &#123;                        
                &#125;
                finally
                &#123;
                    lock.unlock();
                &#125;                    
        &#125;
    &#125;

&#125;

线程编程方面   
60、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
答：有两种实现方法，分别是继承Thread类与实现Runnable接口
用synchronized关键字修饰同步方法
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被&quot;挂起&quot;的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。
61、sleep() 和 wait() 有什么区别? 
答：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
62、同步和异步有何异同，在什么情况下分别使用他们？举例说明。
答：如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。
63、启动一个线程是用run()还是start()?
答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 
64、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
答：不能，一个对象的一个synchronized方法只能由一个线程访问。
65、请说出你所知道的线程同步的方法。
答：wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。
66、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 
答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 
同步的实现方面有两种，分别是synchronized,wait与notify
67、线程的基本概念、线程的基本状态以及状态之间的关系
答：线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。
Java中的线程有四种状态分别是：运行、就绪、挂起、结束
68、简述synchronized和java.util.concurrent.locks.Lock的异同 ？
答：主要相同点：Lock能完成synchronized所实现的所有功能
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。
Jsp方面
69、forward 和redirect的区别
答：forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。
    redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。
70、jsp有哪些内置对象?作用分别是什么?
答：JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：
　request 用户端请求，此请求会包含来自GET/POST请求的参数
   response 网页传回用户端的回应
   pageContext 网页的属性是在这里管理
   session 与请求有关的会话期
   application servlet 正在执行的内容
   out 用来传送回应的输出
   config servlet的构架部件
   page JSP网页本身
   exception 针对错误网页，未捕捉的例外
71、jsp有哪些动作?作用分别是什么?
答\:JSP共有以下6种基本动作
   jsp\:include：在页面被请求的时候引入一个文件。
   jsp\:useBean：寻找或者实例化一个JavaBean。
   jsp\:setProperty：设置JavaBean的属性。
   jsp\:getProperty：输出某个JavaBean的属性。
   jsp\:forward：把请求转到一个新的页面。
   jsp\:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记
72、JSP中动态INCLUDE与静态INCLUDE的区别？
答：动态INCLUDE用jsp\:include动作实现
   \&lt;jsp\:include page=&quot;included.jsp&quot; flush=&quot;true&quot; /&gt;它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数
   静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面
   &lt;%@ include file=&quot;included.htm&quot; %&gt;
73、两种跳转方式分别是什么?有什么区别?
答：有两种，分别为：
  \&lt;jsp\:include page=&quot;included.jsp&quot; flush=&quot;true&quot;&gt;
  \&lt;jsp\:forward page= &quot;nextpage.jsp&quot;/&gt;
前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。
74、JSP的内置对象及方法。
答：request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。 
    response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等） 
    out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 
    pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。 
    session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息 
    applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息 
    config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 
    page表示从该页面产生的一个servlet实例
Servlet方面
75、说一说Servlet的生命周期?
答\:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。 Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。
76、JAVA SERVLET API中forward() 与redirect()的区别？
答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。
77、Servlet的基本架构
答：
public class ServletName extends HttpServlet &#123;
  public void doPost(HttpServletRequest request, HttpServletResponse response) throws
      ServletException, IOException  &#123;
      &#125;
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws
      ServletException, IOException  &#123;
      &#125;
&#125;
78、什么情况下调用doGet()和doPost()？
答：Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。
79、servlet的生命周期
答：web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现，根据请求的不同调用不同的do\*\*\*()方法。结束服务，web容器调用servlet的destroy()方法。
80、如何现实servlet的单线程模式
答：&lt;%@ page isThreadSafe=&quot;false&quot;%&gt;
81、页面间对象传递的方法
答：request，session，application，cookie等
82、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？ 
答：JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是&quot;类servlet&quot;。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。
83、四种会话跟踪技术
答：会话作用域ServletsJSP 页面描述
page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面
request是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系）
session是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求
application是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域
84、Request对象的主要方法
答：
setAttribute(String name,Object)：设置名字为name的request的参数值
getAttribute(String name)：返回由name指定的属性值
getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例
getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组
getCharacterEncoding()：返回请求中的字符编码方式
getContentLength()：返回请求的Body的长度
getHeader(String name)：获得HTTP协议定义的文件头信息
getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例
getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例
getInputStream()：返回请求的输入流，用于获得请求中的数据
getMethod()：获得客户端向服务器端传送数据的方法
getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值
getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例
getParameterValues(String name)：获得有name指定的参数的所有值
getProtocol()：获取客户端向服务器端传送数据所依据的协议名称
getQueryString()：获得查询字符串
getRequestURI()：获取发出请求字符串的客户端地址
getRemoteAddr()：获取客户端的IP地址
getRemoteHost()：获取客户端的名字
getSession(\[Boolean create])：返回和请求相关Session
getServerName()：获取服务器的名字
getServletPath()：获取客户端所请求的脚本文件的路径
getServerPort()：获取服务器的端口号
removeAttribute(String name)：删除请求中的一个属性
85、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？
答：
  Public String translate (String str) &#123;
    String tempStr = &quot;&quot;;
    try &#123;
      tempStr = new String(str.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);
      tempStr = tempStr.trim();
    &#125;
    catch (Exception e) &#123;
      System.err.println(e.getMessage());
    &#125;
    return tempStr;
  &#125;
86、Servlet执行时一般实现哪几个方法？
答：
public void init(ServletConfig config)
public ServletConfig getServletConfig()
public String getServletInfo()
public void service(ServletRequest request,ServletResponse response)
public void destroy()
Jdbc、Jdo方面
87、Class.forName的作用?为什么要用?
答：调用该访问返回一个以字符串指定类名的类的对象。
88、Jdo是什么?
答：JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。
89、说出数据连接池的工作机制是什么?
答：J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。
90、Jdo是什么? 
答：JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。
Xml方面
91、xml有哪些解析技术?区别是什么?
答：有DOM,SAX,STAX等
DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问
STAX\:Streaming API for XML (StAX)
92、你在项目中用到了xml技术的哪些方面?如何实现的?
答：用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。
93、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ 
答：a: 两种形式 dtd  schema，b: 本质区别\:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)，c:有DOM,SAX,STAX等 
    DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问
SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 
STAX\:Streaming API for XML (StAX)

线程间的通信
线程间的通信方式
1、同步
这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。
这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。
例如
public class MyObject &#123;

    synchronized public void methodA() &#123;
        //do something....
    &#125;

    synchronized public void methodB() &#123;
        //do some other thing
    &#125;

&#125;

public class ThreadA extends Thread &#123;

    private MyObject object;

//省略构造方法
@Override
public void run() &#123;
super.run();
object.methodA();
&#125;
&#125;

public class ThreadB extends Thread &#123;

    private MyObject object;

//省略构造方法
@Override
public void run() &#123;
super.run();
object.methodB();
&#125;
&#125;

public class Run &#123;
public static void main(String\[] args) &#123;
MyObject object = new MyObject();

        //线程A与线程B 持有的是同一个对象:object
        ThreadA a = new ThreadA(object);
        ThreadB b = new ThreadB(object);
        a.start();
        b.start();
    &#125;

&#125;
2、while轮询的方式
在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信。但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是： 在干别的事情，当有电话来时，响铃通知TA电话来了。关于线程的轮询的影响，可参考：JAVA多线程之当一个线程在执行死循环时会影响另外一个线程吗？
这种方式还存在另外一个问题：轮询的条件的可见性问题。
线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的 条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。
例如：
import java.util.ArrayList;
import java.util.List;

public class MyList &#123;

    private List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    public void add() &#123;
        list.add(&quot;elements&quot;);
    &#125;
    public int size() &#123;
        return list.size();
    &#125;

&#125;

import mylist.MyList;

public class ThreadA extends Thread &#123;

    private MyList list;

    public ThreadA(MyList list) &#123;
        super();
        this.list = list;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                list.add();
                System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素&quot;);
                Thread.sleep(1000);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

import mylist.MyList;

public class ThreadB extends Thread &#123;

    private MyList list;

    public ThreadB(MyList list) &#123;
        super();
        this.list = list;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            while (true) &#123;
                if (list.size() == 5) &#123;
                    System.out.println(&quot;==5, 线程b准备退出了&quot;);
                    throw new InterruptedException();
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

import mylist.MyList;
import extthread.ThreadA;
import extthread.ThreadB;

public class Test &#123;

    public static void main(String[] args) &#123;
        MyList service = new MyList();

        ThreadA a = new ThreadA(service);
        a.setName(&quot;A&quot;);
        a.start();

        ThreadB b = new ThreadB(service);
        b.setName(&quot;B&quot;);
        b.start();
    &#125;

&#125;
3、wait/notify机制
线程A要等待某个条件满足时(list.size()==5)，才执行操作。线程B则向list中添加元素，改变list 的size。
A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？
这里用到了Object类的 wait() 和 notify() 方法。
当条件未满足时(list.size() !=5)，线程A调用wait() 放弃CPU，并进入阻塞状态。---不像②while轮询那样占用CPU
当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。
这种方式的一个好处就是CPU的利用率提高了。
但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。

import java.util.ArrayList;
import java.util.List;

public class MyList &#123;

    private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();

    public static void add() &#123;
        list.add(&quot;anyString&quot;);
    &#125;

    public static int size() &#123;
        return list.size();
    &#125;

&#125;

public class ThreadA extends Thread &#123;

    private Object lock;

    public ThreadA(Object lock) &#123;
        super();
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            synchronized (lock) &#123;
                if (MyList.size() != 5) &#123;
                    System.out.println(&quot;wait begin &quot;
                            + System.currentTimeMillis());
                    lock.wait();
                    System.out.println(&quot;wait end  &quot;
                            + System.currentTimeMillis());
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

public class ThreadB extends Thread &#123;
private Object lock;

    public ThreadB(Object lock) &#123;
        super();
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            synchronized (lock) &#123;
                for (int i = 0; i &lt; 10; i++) &#123;
                    MyList.add();
                    if (MyList.size() == 5) &#123;
                        lock.notify();
                        System.out.println(&quot;已经发出了通知&quot;);
                    &#125;
                    System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;);
                    Thread.sleep(1000);
                &#125;
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

public class Run &#123;

    public static void main(String[] args) &#123;

        try &#123;
            Object lock = new Object();

            ThreadA a = new ThreadA(lock);
            a.start();

            Thread.sleep(50);

            ThreadB b = new ThreadB(lock);
            b.start();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;

4、管道通信就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信
具体就不介绍了。分布式系统中说的两种通信机制：共享内存机制和消息通信机制。感觉前面的①中的synchronized关键字和②中的while轮询 “属于” 共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流。
而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。

线程死锁及解决办法
线程死锁及解决办法
一、什么是死锁？
所谓死锁： 是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的线程称为死锁线程。 由于资源占用是互斥的，当某个线程提出申请资源后，使得有关线程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁.
关键点：
1\)两个以上的线程
2\)争夺共享的资源
3\)它们各自不释放手中资源，除非有外力协助
二、死锁例子：
public class TestDealLock implements Runnable&#123;

    /**
     * @param args
     */
    public static void main(String[] args) &#123;
        TestDealLock lock1=new TestDealLock();
        TestDealLock lock2=new TestDealLock();
        Thread thread1=new Thread(lock1);
        Thread thread2=new Thread(lock2);
        lock1.setFlag(0);
        lock2.setFlag(1);
        thread1.start();
        thread2.start();
    &#125;

    private static Object obj1=new Object();//一把A筷子的锁
    private static Object obj2=new Object();//一把B筷子的锁
    private int flag=0;

    public int getFlag() &#123;
        return flag;
    &#125;
    public void setFlag(int flag) &#123;
        this.flag = flag;
    &#125;
    public void eatMeat()&#123;
             synchronized (obj1) &#123;
                 System.out.println(Thread.currentThread().getName()+&quot;:拿到A筷子！&quot;);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (obj2) &#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:拿到B筷子！开始吃饭&quot;);
                &#125;
                &#125;
    &#125;
    public void eatVegetable()&#123;
             synchronized (obj2) &#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:拿到B筷子！&quot;);
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    
                    synchronized (obj1) &#123;
                        System.out.println(Thread.currentThread().getName()+&quot;:拿到A筷子！开始吃饭&quot;);
                    &#125;
                &#125;
    &#125;

    @Override
    public void run() &#123;
        if(flag==0)&#123;
            eatMeat();
        &#125;else&#123;
            eatVegetable();
        &#125;
    &#125;

&#125;

三、解决办法：
　　1)、让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y 的拥有者分别等待对方的资源的问题。

　　2)、将多个锁组成一组并放到同一个锁下。前面Java线程死锁的例子中，可以创建一个银器对象的锁。于是在获得刀或叉之前都必须获得这个银器的锁。

　　3)、将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得银器对象的锁时，就可以通过检查变量来判断是否整个银器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试。（没有实现）
实现1：
@Override
public void run() &#123;
/\*        if(flag==0)&#123;
eatMeat();
&#125;else&#123;
eatVegetable();
&#125;\*/
eatMeat();
&#125;
实现2、

/\*\*

*   然要探测或推敲各种情况是非常困难的，但只要按照下面几条规则去设计系统，就能够避免Java线程死锁问题：

　　一、让所有的线程按照同样的顺序获得一组锁。这种方法消除了 X 和 Y 的拥有者分别等待对方的资源的问题。

　　二、将多个锁组成一组并放到同一个锁下。前面Java线程死锁的例子中，可以创建一个银器对象的锁。于是在获得刀或叉之前都必须获得这个银器的锁。

　　三、将那些不会阻塞的可获得资源用变量标志出来。当某个线程获得银器对象的锁时，就可以通过检查变量来判断是否整个银器集合中的对象锁都可获得。如果是，它就可以获得相关的锁，否则，就要释放掉银器这个锁并稍后再尝试。（没有实现）

*   @author abc
*

\*/
public class TestDealLock implements Runnable&#123;

    /**
     * @param args
     */
    public static void main(String[] args) &#123;
        TestDealLock lock1=new TestDealLock();
        TestDealLock lock2=new TestDealLock();
        Thread thread1=new Thread(lock1);
        Thread thread2=new Thread(lock2);
        lock1.setFlag(0);
        lock2.setFlag(1);
        thread1.start();
        thread2.start();
    &#125;

    private static Object obj1=new Object();//一把A筷子的锁
    private static Object obj2=new Object();//一把B筷子的锁
    private static Object obj3=new Object();//加一把锁，保证A锁和B锁锁上同一组，只有拿到此锁才能拿到A锁或者B锁
    private int flag=0;

    public int getFlag() &#123;
        return flag;
    &#125;
    public void setFlag(int flag) &#123;
        this.flag = flag;
    &#125;
    public void eatMeat()&#123;
        synchronized (obj3) &#123;
             synchronized (obj1) &#123;
                 System.out.println(Thread.currentThread().getName()+&quot;:拿到A筷子！&quot;);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (obj2) &#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:拿到B筷子！开始吃饭&quot;);
                &#125;
                &#125;
        &#125;
    &#125;
    public void eatVegetable()&#123;
        synchronized (obj3) &#123;
             synchronized (obj2) &#123;
                    System.out.println(Thread.currentThread().getName()+&quot;:拿到B筷子！&quot;);
                    try &#123;
                        Thread.sleep(1000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    
                    synchronized (obj1) &#123;
                        System.out.println(Thread.currentThread().getName()+&quot;:拿到A筷子！开始吃饭&quot;);
                    &#125;
                &#125;
    //    &#125;
        &#125;
    &#125;

    @Override
    public void run() &#123;
        if(flag==0)&#123;
            eatMeat();
        &#125;else&#123;
            eatVegetable();
        &#125;
    &#125;

&#125;

线程锁之重入锁

重入锁：ReentrantLock 详解
在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的。除此之外，重入锁又自带一系列高逼格UBFF：可中断响应、锁申请等待限时、公平锁。另外可以结合Condition来使用，使其更是逼格满满。
先来盘花生米：
package somhu;

import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockTest implements Runnable&#123;
public static ReentrantLock lock = new ReentrantLock();
public static int i = 0;

    @Override
    public void run() &#123;
        for (int j = 0; j &lt; 10000; j++) &#123;
            lock.lock();  // 看这里就可以
            //lock.lock(); ①
            try &#123;
                i++;
            &#125; finally &#123;
                lock.unlock(); // 看这里就可以
                //lock.unlock();②
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        ReentrantLockTest test = new ReentrantLockTest();
        Thread t1 = new Thread(test);
        Thread t2 = new Thread(test);
        t1.start();t2.start();
        t1.join(); t2.join(); // main线程会等待t1和t2都运行完再执行以后的流程
        System.err.println(i);
    &#125;

&#125;
从上可以看出，使用重入锁进行加锁是一种显式操作，通过何时加锁与释放锁使重入锁对逻辑控制的灵活性远远大于synchronized关键字。同时，需要注意，有加锁就必须有释放锁，而且加锁与释放锁的分数要相同，这里就引出了“重”字的概念，如上边代码演示，放开①、②处的注释，与原来效果一致。
硬菜来了：
1、中断响应
对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。直接上代码，来演示使用重入锁如何解决死锁：
1
package somhu;

import java.util.concurrent.locks.ReentrantLock;

public class KillDeadlock implements Runnable&#123;
public static ReentrantLock lock1 = new ReentrantLock();
public static ReentrantLock lock2 = new ReentrantLock();
int lock;

    public KillDeadlock(int lock) &#123;
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            if (lock == 1) &#123;
                lock1.lockInterruptibly();  // 以可以响应中断的方式加锁
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;&#125;
                lock2.lockInterruptibly();
            &#125; else &#123;
                lock2.lockInterruptibly();  // 以可以响应中断的方式加锁
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;&#125;
                lock1.lockInterruptibly();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (lock1.isHeldByCurrentThread()) lock1.unlock();  // 注意判断方式
            if (lock2.isHeldByCurrentThread()) lock2.unlock();
            System.err.println(Thread.currentThread().getId() + &quot;退出！&quot;);
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        KillDeadlock deadLock1 = new KillDeadlock(1);
        KillDeadlock deadLock2 = new KillDeadlock(2);
        Thread t1 = new Thread(deadLock1);
        Thread t2 = new Thread(deadLock2);
        t1.start();t2.start();
        Thread.sleep(1000);
        t2.interrupt(); // ③
    &#125;

&#125;
t1、t2线程开始运行时，会分别持有lock1和lock2而请求lock2和lock1，这样就发生了死锁。但是，在③处给t2线程状态标记为中断后，持有重入锁lock2的线程t2会响应中断，并不再继续等待lock1，同时释放了其原本持有的lock2，这样t1获取到了lock2，正常执行完成。t2也会退出，但只是释放了资源并没有完成工作。
2、锁申请等待限时
可以使用 tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。
前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。 
后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false。
上代码：
package somhu;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class TryLockTest implements Runnable&#123;
public static ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() &#123;
        try &#123;
            if (lock.tryLock(1, TimeUnit.SECONDS)) &#123; // 等待1秒
                Thread.sleep(2000);  //休眠2秒
            &#125; else &#123;
                System.err.println(Thread.currentThread().getName() + &quot;获取锁失败！&quot;);
            &#125;
        &#125; catch (Exception e) &#123;
            if (lock.isHeldByCurrentThread()) lock.unlock();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        TryLockTest test = new TryLockTest();
        Thread t1 = new Thread(test); t1.setName(&quot;线程1&quot;);
        Thread t2 = new Thread(test); t1.setName(&quot;线程2&quot;);
        t1.start();t2.start();
    &#125;

&#125;
/\*\*

*   运行结果:
*   线程2获取锁失败！
    \*/
    上述示例中，t1先获取到锁，并休眠2秒，这时t2开始等待，等待1秒后依然没有获取到锁，就不再继续等待，符合预期结果。
    3、公平锁
    所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：
    public ReentrantLock(boolean fair) &#123;
    sync = fair ? new FairSync() : new NonfairSync();
    &#125;
    上代码：
    package somhu;

import java.util.concurrent.locks.ReentrantLock;

public class FairLockTest implements Runnable&#123;
public static ReentrantLock lock = new ReentrantLock(true);

    @Override
    public void run() &#123;
        while (true) &#123;
            try &#123;
                lock.lock();
                System.err.println(Thread.currentThread().getName() + &quot;获取到了锁！&quot;);
            &#125; finally &#123;
                lock.unlock();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        FairLockTest test = new FairLockTest();
        Thread t1 = new Thread(test, &quot;线程1&quot;);
        Thread t2 = new Thread(test, &quot;线程2&quot;);
        t1.start();t2.start();
    &#125;

&#125;
/\*\*

*   运行结果:
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   线程1获取到了锁！
*   线程2获取到了锁！
*   ......（上边是截取的一段）
    \*/
    可以发现，t1和t2交替获取到锁。如果是非公平锁，会发生t1运行了许多遍后t2才开始运行的情况。
    ReentrantLock 配合 Conditond 使用
    配合关键字synchronized使用的方法如：await()、notify()、notifyAll()，同样配合ReentrantLock 使用的Conditon提供了以下方法：
    public interface Condition &#123;
    void await() throws InterruptedException; // 类似于Object.wait()
    void awaitUninterruptibly(); // 与await()相同，但不会再等待过程中响应中断
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    boolean awaitUntil(Date deadline) throws InterruptedException;
    void signal(); // 类似于Obejct.notify()
    void signalAll();
    &#125;
    ReentrantLock 实现了Lock接口，可以通过该接口提供的newCondition()方法创建Condition对象：
    public interface Lock &#123;
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
    &#125;
    上代码：
    package somhu;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockWithConditon implements Runnable&#123;
public static ReentrantLock lock = new ReentrantLock(true);
public static Condition condition = lock.newCondition();

    @Override
    public void run() &#123;
        lock.newCondition();
        try &#123;
            lock.lock();
            System.err.println(Thread.currentThread().getName() + &quot;-线程开始等待...&quot;);
            condition.await();
            System.err.println(Thread.currentThread().getName() + &quot;-线程继续进行了&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        ReentrantLockWithConditon test = new ReentrantLockWithConditon();
        Thread t = new Thread(test, &quot;线程ABC&quot;);
        t.start();
        Thread.sleep(1000);
        System.err.println(&quot;过了1秒后...&quot;);
        lock.lock();
        condition.signal(); // 调用该方法前需要获取到创建该对象的锁否则会产生
                            // java.lang.IllegalMonitorStateException异常
        lock.unlock();
    &#125;

&#125;
好了，到这里重入锁ReentrantLock的基本使用方法就介绍完成了！
</code></pre></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/1e7ca447b43e.html" rel="prev" title="分布式"><i class="fa fa-angle-left"></i> 分布式</a></div><div class="post-nav-item"><a href="/publishes/8270315bab4b.html" rel="next" title="Java虚拟机（JVM）">Java虚拟机（JVM） <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>