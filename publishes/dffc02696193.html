<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="谈谈MySQL支持的事务隔离级别？MySQL数据库事务隔离级别分为四个不同层次:读未提交: 一个事务能够读取其他事务未提交的修改的数据,这是最低的隔离水平,允许脏读出现。读已提交: 一个事务能够读取其他事务已经提交的修改的数据,脏读不会出现。但是隔离级别比较低,允许出现不可重复读和幻象读。可重复读： 一个事务读取到另一个事务已经提交的数据,隔离级别比较高,允许出现幻读。这也是MySQL InnoD"><meta property="og:type" content="article"><meta property="og:title" content="MySQL"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/dffc02696193.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="谈谈MySQL支持的事务隔离级别？MySQL数据库事务隔离级别分为四个不同层次:读未提交: 一个事务能够读取其他事务未提交的修改的数据,这是最低的隔离水平,允许脏读出现。读已提交: 一个事务能够读取其他事务已经提交的修改的数据,脏读不会出现。但是隔离级别比较低,允许出现不可重复读和幻象读。可重复读： 一个事务读取到另一个事务已经提交的数据,隔离级别比较高,允许出现幻读。这也是MySQL InnoD"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T08:21:32.000Z"><meta property="article:modified_time" content="2023-12-20T08:22:19.722Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="数据库"><meta property="article:tag" content="mysql"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/dffc02696193.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/dffc02696193.html","path":"publishes/dffc02696193.html","title":"MySQL"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>MySQL | Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java后端面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">谈谈MySQL支持的事务隔离级别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">不可重复读和幻读到底有什么区别呢？</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">为什么用自增列作为主键？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">为什么使用数据索引能提高效率？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">B+树索引和哈希索引的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">哈希索引的优势：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">哈希索引不适用的场景：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%85%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="nav-number">7.</span> <span class="nav-text">仅等值查询</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">B 树和 B+ 树的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4B-%E6%AF%94B%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">10.</span> <span class="nav-text">关于 MySQL 联合索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E4%B8%8D%E5%BB%BA%E6%88%96%E5%B0%91%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">什么情况下应不建或少建索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A8%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">什么是表分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E4%B8%8E%E5%88%86%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">表分区与分表的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">表分区有什么好处？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E9%99%90%E5%88%B6%E5%9B%A0%E7%B4%A0"><span class="nav-number">15.</span> <span class="nav-text">分区表的限制因素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8DMySQL%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">如何判断当前MySQL是否支持分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%86%E5%8C%BA%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">MySQL支持的分区类型有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">四种隔离级别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EMVVC"><span class="nav-number">19.</span> <span class="nav-text">关于MVVC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8MVCC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%AD%EF%BC%8C%E8%AF%BB%E6%93%8D%E4%BD%9C%E5%8F%AF%E4%BB%A5%E5%88%86%E6%88%90%E4%B8%A4%E7%B1%BB%EF%BC%9A"><span class="nav-number">20.</span> <span class="nav-text">在MVCC并发控制中，读操作可以分成两类：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">21.</span> <span class="nav-text">行级锁定的优点：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">22.</span> <span class="nav-text">行级锁定的缺点：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%BC%98%E5%8C%96"><span class="nav-number">23.</span> <span class="nav-text">MySQL优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#key%E5%92%8Cindex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">24.</span> <span class="nav-text">key和index的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD-MyISAM-%E5%92%8C-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">26.</span> <span class="nav-text">数据库表创建注意事项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E5%8D%83%E4%B8%87%E7%BA%A7%E7%9A%84%E5%A4%A7%E8%A1%A8%E8%A6%81%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%88%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E3%80%81%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E3%80%81%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%EF%BC%89"><span class="nav-number">27.</span> <span class="nav-text">MySQL千万级的大表要怎么优化（读写分离、水平拆分、垂直拆分）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-InnoDB%E3%80%81Mysaim%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">MySQL InnoDB、Mysaim的特点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BE%8F%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81%EF%BC%9B%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">⾏锁，表锁；乐观锁，悲观锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">数据库隔离级别是什么？有什么作⽤？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%BB%E5%A4%87%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%82"><span class="nav-number">31.</span> <span class="nav-text">MySQL主备同步的基本原理。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#select-from-table-t-where-size-gt-10-group-by-size-order-by-size%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E2%BE%8F%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">select * from table t where size &gt; 10 group by size order by size的sql语句执⾏顺序？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%EF%BC%88%E7%B4%A2%E5%BC%95%E3%80%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E3%80%81%E6%89%B9%E7%BD%AE%E6%93%8D%E4%BD%9C%E3%80%81%E5%88%86%E2%BB%9A%E7%AE%97%E6%B3%95%E3%80%81%E5%8D%87%E7%BA%A7%E7%A1%AC%E7%9B%98SSD%E3%80%81%E4%B8%9A%E5%8A%A1%E4%BC%98%E5%8C%96%E3%80%81%E4%B8%BB%E4%BB%8E%E9%83%A8%E7%BD%B2%EF%BC%89"><span class="nav-number">33.</span> <span class="nav-text">如何优化数据库性能（索引、分库分表、批置操作、分⻚算法、升级硬盘SSD、业务优化、主从部署）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E4%BC%9A%E4%BD%BF%E2%BD%A4%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8D%E5%8C%85%E5%90%AB%EF%BC%8C%E4%B8%8D%E7%AD%89%E4%BA%8E%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-number">34.</span> <span class="nav-text">SQL什么情况下不会使⽤索引（不包含，不等于，函数）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%80%94%E8%88%AC%E5%9C%A8%E4%BB%80%E4%B9%88%E5%AD%97%E6%AE%B5%E4%B8%8A%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%89"><span class="nav-number">35.</span> <span class="nav-text">—般在什么字段上建索引（过滤数据最多的字段）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E2%BC%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E6%9F%A5%E5%87%BAname%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%8C%85%E5%90%AB%E2%80%9DXYZ%E2%80%9D%E7%9A%84%E6%89%80%E6%9C%89%E2%BE%8F%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">如何从⼀张表中查出name字段不包含”XYZ”的所有⾏？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HRedis-RDB%E5%92%8CA0Ff%E5%A6%82%E4%BD%95%E5%81%9A%E2%BE%BC%E5%8F%AF%E2%BD%A4%E3%80%81%E9%9B%86%E7%BE%A4"><span class="nav-number">37.</span> <span class="nav-text">HRedis, RDB和A0Ff如何做⾼可⽤、集群</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%BE%BC%E5%B9%B6%E5%8F%91%E5%87%8F%E5%BA%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">38.</span> <span class="nav-text">如何解决⾼并发减库存问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9B"><span class="nav-number">39.</span> <span class="nav-text">mysql存储引擎中索引的实现机制；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E2%BC%8F%E7%A7%8D%E7%B2%92%E5%BA%A6%EF%BC%9B"><span class="nav-number">40.</span> <span class="nav-text">数据库事务的⼏种粒度；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E8%B0%83%E4%BC%98%EF%BC%9A"><span class="nav-number">41.</span> <span class="nav-text">mysql调优：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%EF%BC%9F"><span class="nav-number">42.</span> <span class="nav-text">说说事务的四种特性（ACID）？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7-Atomicity"><span class="nav-number">42.0.0.1.</span> <span class="nav-text">原子性 (Atomicity)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-Consistency"><span class="nav-number">42.0.0.2.</span> <span class="nav-text">一致性 (Consistency)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7-Isolation"><span class="nav-number">42.0.0.3.</span> <span class="nav-text">隔离性 (Isolation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7-Durability"><span class="nav-number">42.0.0.4.</span> <span class="nav-text">持久性(Durability)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#innodb%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">innodb如何实现mysql的事务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E2%BC%80%E4%B8%AA%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-number">44.</span> <span class="nav-text">让你设计⼀个索引，你会怎么设计？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%A0%B9%E6%8D%AE%E9%83%A8%E9%97%A8%E5%8F%B7%E4%BB%8E%E9%AB%98%E5%88%B0%E4%BD%8E%EF%BC%8C%E5%B7%A5%E8%B5%84%E4%BB%8E%E4%BD%8E%E5%88%B0%E9%AB%98%E5%88%97%E5%87%BA%E6%AF%8F%E4%B8%AA%E5%91%98%E5%B7%A5%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82"><span class="nav-number">45.</span> <span class="nav-text">用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E5%90%84%E4%B8%AA%E9%83%A8%E9%97%A8%E4%B8%AD%E5%B7%A5%E8%B5%84%E9%AB%98%E4%BA%8E%E6%9C%AC%E9%83%A8%E9%97%A8%E7%9A%84%E5%B9%B3%E5%9D%87%E5%B7%A5%E8%B5%84%E7%9A%84%E5%91%98%E5%B7%A5%E6%95%B0%E5%92%8C%E9%83%A8%E9%97%A8%E5%8F%B7%EF%BC%8C%E5%B9%B6%E6%8C%89%E9%83%A8%E9%97%A8%E5%8F%B7%E6%8E%92%E5%BA%8F"><span class="nav-number">46.</span> <span class="nav-text">列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E5%BF%85%E9%A1%BB%E8%AE%B2%EF%BC%8C%E7%BB%8F%E5%B8%B8%E8%A2%AB%E9%9D%A2%E8%AF%95%E5%88%B0"><span class="nav-number">47.</span> <span class="nav-text">存储过程与触发器必须讲，经常被面试到?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">48.</span> <span class="nav-text">数据库三范式是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="nav-number">49.</span> <span class="nav-text">说出一些数据库优化方面的经验?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#union%E5%92%8Cunion-all%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">50.</span> <span class="nav-text">union和union all有什么不同?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E8%AF%AD%E5%8F%A5"><span class="nav-number">51.</span> <span class="nav-text">分页语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5-%E6%9F%A5%E8%AF%A2%E5%87%BA%E6%AF%8F%E9%97%A8%E8%AF%BE%E9%83%BD%E5%A4%A7%E4%BA%8E80%E5%88%86%E7%9A%84%E5%AD%A6%E7%94%9F%E5%A7%93%E5%90%8D"><span class="nav-number">52.</span> <span class="nav-text">用一条SQL语句 查询出每门课都大于80分的学生姓名</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E9%83%A8%E9%97%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%B5%9B%E7%BB%84%E5%90%88"><span class="nav-number">53.</span> <span class="nav-text">所有部门之间的比赛组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E6%9C%88%E4%BB%BD%E7%9A%84%E5%8F%91%E7%94%9F%E9%A2%9D%E9%83%BD%E6%AF%94101%E7%A7%91%E7%9B%AE%E5%A4%9A%E7%9A%84%E7%A7%91%E7%9B%AE"><span class="nav-number">54.</span> <span class="nav-text">每个月份的发生额都比101科目多的科目</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E6%AF%8F%E5%B9%B4%E6%AF%8F%E6%9C%88%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">55.</span> <span class="nav-text">统计每年每月的信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%EF%BC%8C%E5%8F%91%E5%B8%96%E4%BA%BA%E3%80%81%E6%9C%80%E5%90%8E%E5%9B%9E%E5%A4%8D%E6%97%B6%E9%97%B4"><span class="nav-number">56.</span> <span class="nav-text">显示文章标题，发帖人、最后回复时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%99%A4%E4%BA%86id%E5%8F%B7%E4%B8%8D%E5%90%8C-%E5%85%B6%E4%BB%96%E9%83%BD%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%A6%E7%94%9F%E5%86%97%E4%BD%99%E4%BF%A1%E6%81%AF"><span class="nav-number">57.</span> <span class="nav-text">删除除了id号不同,其他都相同的学生冗余信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%88%AA%E7%A9%BA%E7%BD%91%E7%9A%84%E5%87%A0%E4%B8%AA%E8%88%AA%E7%8F%AD%E6%9F%A5%E8%AF%A2%E9%A2%98%EF%BC%9A"><span class="nav-number">58.</span> <span class="nav-text">航空网的几个航班查询题：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E5%87%BA%E6%AF%94%E7%BB%8F%E7%90%86%E8%96%AA%E6%B0%B4%E8%BF%98%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%EF%BC%9A"><span class="nav-number">59.</span> <span class="nav-text">查出比经理薪水还高的员工信息：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%82%E5%87%BA%E5%B0%8F%E4%BA%8E45%E5%B2%81%E7%9A%84%E5%90%84%E4%B8%AA%E8%80%81%E5%B8%88%E6%89%80%E5%B8%A6%E7%9A%84%E5%A4%A7%E4%BA%8E12%E5%B2%81%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0"><span class="nav-number">60.</span> <span class="nav-text">求出小于45岁的各个老师所带的大于12岁的学生人数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%82%E5%87%BA%E5%8F%91%E5%B8%96%E6%9C%80%E5%A4%9A%E7%9A%84%E4%BA%BA%EF%BC%9A"><span class="nav-number">61.</span> <span class="nav-text">求出发帖最多的人：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%A1%A8%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A7%AF%E5%88%86%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%81%87%E5%A6%82%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9C%89100%E5%A4%9A%E4%B8%87%E4%B8%AA%E7%94%A8%E6%88%B7%EF%BC%8C%E8%8B%A5%E8%A6%81%E5%9C%A8%E6%AF%8F%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%A4%A9%E5%87%8C%E6%99%A8%E5%B0%86%E7%A7%AF%E5%88%86%E6%B8%85%E9%9B%B6%EF%BC%8C%E4%BD%A0%E5%B0%86%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%A0%E5%B0%86%E6%83%B3%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E8%A7%A3%E5%86%B3"><span class="nav-number">62.</span> <span class="nav-text">一个用户表中有一个积分字段，假如数据库中有100多万个用户，若要在每年第一天凌晨将积分清零，你将考虑什么，你将想什么办法解决?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%85%B7%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%A7%92%E8%89%B2%EF%BC%8C%E8%AF%B7%E6%9F%A5%E8%AF%A2%E5%87%BA%E8%AF%A5%E8%A1%A8%E4%B8%AD%E5%85%B7%E6%9C%89%E8%AF%A5%E7%94%A8%E6%88%B7%E7%9A%84%E6%89%80%E6%9C%89%E8%A7%92%E8%89%B2%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E3%80%82"><span class="nav-number">63.</span> <span class="nav-text">一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#xxx%E5%85%AC%E5%8F%B8%E7%9A%84sql%E9%9D%A2%E8%AF%95"><span class="nav-number">64.</span> <span class="nav-text">xxx公司的sql面试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#oracle%E4%B8%AD%E9%99%A4%E4%BA%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%A4%87%E4%BB%BD%EF%BC%9F"><span class="nav-number">65.</span> <span class="nav-text">oracle中除了数据库备份，还有什么方法备份？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#truncate%E4%B8%8Edelete%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88delete-from-table%E5%92%8Ctruncate-table-tablea%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81%EF%BC%89"><span class="nav-number">66.</span> <span class="nav-text">truncate与delete的区别？（delete from table和truncate table tablea的区别！）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Oracle%E5%86%B7%E5%A4%87%E4%BB%BD%E7%9A%84%E9%80%9A%E5%B8%B8%E6%AD%A5%E9%AA%A4"><span class="nav-number">67.</span> <span class="nav-text">Oracle冷备份的通常步骤</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BF%E9%97%AE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">68.</span> <span class="nav-text">对数据库的访问是怎么实现的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">69.</span> <span class="nav-text">接口与抽象类的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">70.</span> <span class="nav-text">数据库优化的方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql-dir-bin-mysql-h-hostname-u-p"><span class="nav-number">71.</span> <span class="nav-text">[mysql dir]&#x2F;bin&#x2F;mysql -h hostname -u -p</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/dffc02696193.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="MySQL | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">MySQL</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:21:32 / 修改时间：16:22:19" itemprop="dateCreated datePublished" datetime="2023-12-20T16:21:32+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="谈谈MySQL支持的事务隔离级别？"><a href="#谈谈MySQL支持的事务隔离级别？" class="headerlink" title="谈谈MySQL支持的事务隔离级别？"></a>谈谈MySQL支持的事务隔离级别？</h1><p>MySQL数据库事务隔离级别分为四个不同层次:<br>读未提交: 一个事务能够读取其他事务未提交的修改的数据,这是最低的隔离水平,允许<br>脏读出现。<br>读已提交: 一个事务能够读取其他事务已经提交的修改的数据,脏读不会出现。但是隔离<br>级别比较低,允许出现不可重复读和幻象读。<br>可重复读： 一个事务读取到另一个事务已经提交的数据,隔离级别比较高,允许出现幻读。<br>这也是MySQL InnoDB引擎的默认隔离级别,但是和一些其他的数据库不同,可以简单的认为<br>MySQL在可重复读级别不会出现幻读。<br>串行化: 并发事务之间是串行化的,通常意味着读取需要共享读锁,更新需要获取排他写<br>锁。这是最高的隔离级别。</p><h4 id="不可重复读和幻读到底有什么区别呢？"><a href="#不可重复读和幻读到底有什么区别呢？" class="headerlink" title="不可重复读和幻读到底有什么区别呢？"></a>不可重复读和幻读到底有什么区别呢？</h4><p>（1）不可重复读是读取了其他事务更改的数据，针对update操作<br>解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许<br>其他事务更改刚才的数据。<br>（2）幻读是读取了其他事务新增的数据，针对insert操作<br>解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才<br>允许其他事务新增数据。</p><h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><p>1、如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。<br>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。<br>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。<br>2、数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放<br>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）<br>3、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页<br>4、如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置<br>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销<br>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><p>数据索引的存储是有序的</p><p>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</p><p>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</p><h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的，如下图：</p><p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的<br>如下图所示：</p><h1 id="哈希索引的优势："><a href="#哈希索引的优势：" class="headerlink" title="哈希索引的优势："></a>哈希索引的优势：</h1><p>等值查询，哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p><h1 id="哈希索引不适用的场景："><a href="#哈希索引不适用的场景：" class="headerlink" title="哈希索引不适用的场景："></a>哈希索引不适用的场景：</h1><p>不支持范围查询</p><p>不支持索引完成排序</p><p>不支持联合索引的最左前缀匹配规则</p><p>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<br>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：</p><h1 id="仅等值查询"><a href="#仅等值查询" class="headerlink" title="仅等值查询"></a>仅等值查询</h1><p>select id, name from table where name=’李明’; <br>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。<br>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。<br>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。<br>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。<br>但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</p><h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><p>1、B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</p><p>2、B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接<br>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</p><h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><p>1、B+的磁盘读写代价更低。<br>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。<br>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。<br>2、B+-tree的查询效率更加稳定。<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><p>1、联合索引是两个或更多个列上的索引。<br>对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。<br>例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。<br>2、利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。<br>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。<br>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</p><h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><p>1、表记录太少<br>2、经常插入、删除、修改的表<br>3、数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。<br>4、经常和主字段一块查询但主字段索引值比较多的表字段</p><h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p><h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><p>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。<br>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p><h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><p>1、存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据<br>2、优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。<br>3、分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。<br>4、避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</p><h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><p>一个表最多只能有1024个分区<br>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。<br>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。<br>分区表中无法使用外键约束<br>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</p><h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><p>命令：show variables like ‘%partition%’ 运行结果:<br>mysql&gt; show variables like ‘%partition%’;<br>+——————-+——-+| Variable_name | Value |+——————-+——-+| have_partitioning | YES |+——————-+——-+1 row in set (0.00 sec)<br>have_partintioning 的值为YES，表示支持分区。</p><h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><p>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区<br>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。<br>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。<br>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</p><h1 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h1><p>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。<br>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。<br>Read committed (读已提交)：可避免脏读的发生。<br>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p><h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) <br>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control<br>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。<br>LBCC：Lock-Based Concurrency Control，基于锁的并发控制<br>MVCC：Multi-Version Concurrency Control<br>基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</p><h1 id="在MVCC并发控制中，读操作可以分成两类："><a href="#在MVCC并发控制中，读操作可以分成两类：" class="headerlink" title="在MVCC并发控制中，读操作可以分成两类："></a>在MVCC并发控制中，读操作可以分成两类：</h1><p>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）<br>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</p><h1 id="行级锁定的优点："><a href="#行级锁定的优点：" class="headerlink" title="行级锁定的优点："></a>行级锁定的优点：</h1><p>1、当在许多线程中访问不同的行时只存在少量锁定冲突。<br>2、回滚时只有少量的更改<br>3、可以长时间锁定单一的行。</p><h1 id="行级锁定的缺点："><a href="#行级锁定的缺点：" class="headerlink" title="行级锁定的缺点："></a>行级锁定的缺点：</h1><p>比页级或表级锁定占用更多的内存。<br>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。<br>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。<br>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</p><h1 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h1><p>开启查询缓存，优化查询<br>explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的<br>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据<br>为搜索字段建索引<br>使用 ENUM 而不是 VARCHAR。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR<br>Prepared StatementsPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。<br>Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击<br>垂直分表<br>选择正确的存储引擎</p><h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><p>key 是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等<br>index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；</p><h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><p>区别：<br>InnoDB支持事务，MyISAM不支持<br>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；<br>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；<br>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。<br>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。<br>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。<br>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；<br>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；<br>如何选择：<br>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；<br>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB<br>系统奔溃后，MyISAM恢复起来更困难，能否接受；<br>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</p><h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><p>1、字段名及字段配制合理性<br>剔除关系不密切的字段；<br>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；<br>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；<br>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；<br>字段名不要使用保留字或者关键字；<br>保持字段名和类型的一致性；<br>慎重选择数字类型；<br>给文本字段留足余量；<br>2、系统特殊字段处理及建成后建议<br>添加删除标记（例如操作人、删除时间）；<br>建立版本机制；<br>3、表结构合理性配置<br>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；<br>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！<br>4、其它建议<br>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；<br>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；<br>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；<br>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；<br>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</p><h1 id="MySQL千万级的大表要怎么优化（读写分离、水平拆分、垂直拆分）"><a href="#MySQL千万级的大表要怎么优化（读写分离、水平拆分、垂直拆分）" class="headerlink" title="MySQL千万级的大表要怎么优化（读写分离、水平拆分、垂直拆分）"></a>MySQL千万级的大表要怎么优化（读写分离、水平拆分、垂直拆分）</h1><p>思考<br>如何设计或优化千万级别的大表？此外无其他信息，个人觉得这个话题有点范，就只好简单说下该如何做，对于一个存储设计，必须考虑业务特点，收集的信息如下：<br>1.数据的容量：1-3年内会大概多少条数据，每条数据大概多少字节；<br>2.数据项：是否有大字段，那些字段的值是否经常被更新；<br>3.数据查询SQL条件：哪些数据项的列名称经常出现在WHERE、GROUP BY、ORDER BY子句中等；<br>4.数据更新类SQL条件：有多少列经常出现UPDATE或DELETE 的WHERE子句中；<br>5.SQL量的统计比，如：SELECT：UPDATE+DELETE：INSERT=多少？<br>6.预计大表及相关联的SQL，每天总的执行量在何数量级？<br>7.表中的数据：更新为主的业务 还是 查询为主的业务 ？<br>8.打算采用什么数据库物理服务器，以及数据库服务器架构？<br>9.并发如何？<br>10.存储引擎选择InnoDB还是MyISAM？<br>大致明白以上10个问题，至于如何设计此类的大表，应该什么都清楚了！<br>至于优化若是指创建好的表，不能变动表结构的话，那建议InnoDB引擎，多利用点内存，减轻磁盘IO负载，因为IO往往是数据库服务器的瓶颈<br>另外对优化索引结构去解决性能问题的话，建议优先考虑修改类SQL语句，使他们更快些，不得已只靠索引组织结构的方式，当然此话前提是， 索引已经创建的非常好，若是读为主，可以考虑打开query_cache，以及调整一些参数值：sort_buffer_size,read_buffer_size,read_rnd_buffer_size,join_buffer_size<br>以及调整一些参数值：sort_buffer_size,read_buffer_size,read_rnd_buffer_size,join_buffer_size<br>案列一<br>我现在的公司有三张表，是5亿的数据，每天张表每天的增量是100w<br>每张表大概在10个columns左右<br>下面是我做的测试和对比<br>1.首先看engine,在大数据量情况下，在没有做分区的情况下<br>mysiam比innodb在只读的情况下，效率要高13％左右<br>2.在做了partition之后，你可以去读一下mysql的官方文档，其实对于partition，专门是对myisam做的优化，对于innodb，所有的数据是存在ibdata里面的，所以即使你可以看到schema变了，其实没有本质的变化<br>在分区出于同一个physical disk下面的情况下，提升大概只有1％<br>在分区在不同的physical disk下，我分到了三个不同的disks下，提升大概在3％，其实所谓的吞吐量，由很多因素决定的，比如你的explain parition时候可以看到，record在那一个分区，如果每个分区都有，其实本质上没有解决读的问题，这样只会提升写的效率。<br>另外一个问题在于，分区，你怎么分，如果一张表，有三个column都是经常被用于做查询条件的，其实是一件很悲惨的事情，因为你没有办法对所有的sql做针对性的分区，如果你只是如mysql官方文档上说的，只对时间做一个分区，而且你也只用时间查询的话，恭喜你<br>3.表主要用来读还是写，其实这个问题是不充分的，应该这样问，你在写入的时候，同时并发的查询多么？我的问题还比较简单，因为mongodb的shredding支持不能，在crush之后，还是回到mysql，所以在通常情况下，9am－9pm，写入的情况很多，这个时候我会做一个view，view是基于最近被插入或者经常被查询的，通过做view来分离读取，就是说写是在table上的，读在进行逻辑判断前是在view上操作的<br>4.做一些archive table，比如先对这些大表做很多已有的统计分析，然后通过已有的分析＋增量来解决<br>5.如果你用mysiam，还有一个问题你要注意，如果你的.configure的时候，加了一个max index length参数的时候，当你的record数大于制定长度的时候，这个index会被disable<br>案列二<br>任何偏离业务场景的优化都是耍流氓，如果是订单表，主要 通过订单id来查询 订单信息，则可以对这样的表 进行垂直分库，每个库表容量500万条，按订单号维度 给拆分到多个库，而在查询的时候，使用订单号查询，通过某个业务规则，直接定位到要查询的目标库。或者通过用户ID 、日期维度 进行分库，但是千万要注意，查询时携带 分库的条件。 如果是CRM系统 ，不直接使用订单号直接查询，而是一个范围查询，返回一个列表集合，而你还继续执着于分库分表就能解决你的性能问题，这样你要对各个库的查询结果集进行union，数据库的性能非但不能提高反而会适得其反！<br>解决方案<br>首先，任何优化，都需要你了解你的业务，了解你的数据。<br>QPS要到多少？- 带宽及存储够的情况下，单机几千QPS妥妥的。<br>读写比例如何？- 读多写少和写多读少，优化方法是有很大差别的。设置于只读场景，果断压缩。<br>数据是否快速增长？- 基本就是QPS的要求。<br>数据及服务的SLA要到多少？- 数据需不需要强一致？HA做到什么程度？<br>诸如此类。<br>不同的场景有不同的侧重，解决方案是不同的。而对于一些典型的场景可能会有成熟的解决方案。<br>题主已注明“千万级”，因此以下假设题主为最常见的场景： 大量数据，QPS要求高，读多写少，数据快速增长，SLA要求高 。<br>其次，说优化的方法。<br>主要从三个维度说：Why, How, When。<br>0. sql vs nosql<br>有些跑题，但也是很重要的一方面。<br>Why: nosql天生分布，而且大多针对某种类型的数据、某种使用场景做过优化。<br>比如大批量的监控数据，用mysql存费时费力，可以选择mongo，甚至时间序列数据库，存取会有量级提升。<br>How: 找对应解决方案。<br>When: 有足够诱惑 - 针对使用场景，有成熟解决方案，效率获得大量提升。</p><ol><li>优化shema、sql语句+索引<br>Why: 再好的MySQL架构也扛不住一个频繁的垃圾查询。不合理的schema设计也会导致数据存取慢。索引的作用不必多说，但如innodb下，错的索引带来的可能不只是查询变慢而已。<br>How: 设计阶段就需要预计QPS及数据规模，参考业务场景对数据的要求，合理设计表结构（参考mysql在线DDL问题），甚至违反设计范式做到适当冗余。生产环境分析慢日志，优化语句。索引的设计需要知道索引是怎么用的，比如innodb的加锁机制。<br>When: 这个不仅仅是第一个要考虑的，而应该是需要持续去优化的。特别是要参考业务。但实际环境中如果是这个的问题，那一般比较幸运了，因为一般已经优化过很多了。实际中遇到的一般是更深的问题。</li><li>缓存<br>缓存没有那么简单。<br>缓存对于应用不是完全透明的，除非你用Django这种成熟框架，而且缓存粒度很大，但实际。。。像python，最少也得加几个装饰器。<br>如何保证缓存里面的数据是始终正确的？写数据前失效缓存还是写数据后？<br>缓存挂了或者过冷，流量压到后端mysql了怎么办？<br>缓存也不是万能的。写多读少，命中率会很低。<br>How: memcache用做缓存，redis用于需要持久化的场景。（redis能不能完全取代memcache？呵呵。。）<br>还可以使用mysql自带的query cache，对应用基本完全透明。但会受限于本机。而且只缓存查询结果，mc和redis可以缓存一些加工后的数据。<br>而且数据量大、QPS大的情况下，也需要考虑分片及HA的问题。如果有一个数据过热，把一个节点压垮了怎么办？<br>When: 基本上大多数读多写少的场景都能用，写多的情况下可能需要考虑考虑。</li><li>复制及读写分离（做主从复制或主主复制，读写分离，可以在应用层做，效率高，也可以用三方工具，第三方工具推荐360的atlas,其它的要么效率不高，要么没人维护）<br>Why: 这个其实是大多数场景下都必须的。因为复制可以实现备份、高可用、负载均衡。就算嫌麻烦不做负载均衡，那备份下总是要的吧？既然已经备份了，何不加个LVS+HAProxy做下HA？顺便稍微修改下应用，读写分离也就成了。<br>How: 节点少的情况下，主备。前面加Keepalived+HAProxy等组件，失效自动切换。读写分离可能需要修改下应用。<br>节点多的情况下，一是考虑多级备份，减轻主的压力。其次可以引入第三方组件，接管主节点的备份工作。<br>主主不是很推荐。一是需要考虑数据冲突的情况，比如错开id，同时操作数据后冲突解决。其次如果强一致会导致延迟增加，如果有节点挂了，需要等到超时才返回。<br>When: 主备几乎大多数场景。甚至不论数据大小。高可用对应用透明，为啥不用?主主麻烦，建议先用切分。</li><li>切分<br>包括垂直切分和水平切分，实现方式上又包括分库、分表。<br>虽然有些难度，但还是推荐常用的。<br>Why: 垂直切分保证业务的独立性，防止不同业务争抢资源，毕竟业务是有优先级的。<br>水平切分主要用于突破单机瓶颈。除了主主外，只有切分能真正做到将负载分配下去。<br>切分后也可对不同片数据进行不同优化。如按时间切分，超过一定时间数据不允许修改，就可以引入压缩了，数据传输及读取减少很多。<br>How: 根据业务垂直切分。业务内部分库、分表。一般都需要修改应用。除分表外，其余实现不是很复杂。有第三方组件可用，但通用高效又灵活的方式，还是自己写client。<br>When: 垂直切分一般都要做，只不过业务粒度大小而已。<br>分库有是经常用的，就算当前压力小，也尽量分出几个逻辑库出来。等规模上去了，很方便就迁移扩展。<br>水平拆分有一定难度，但如果将来一定会到这个规模，又可能用到，建议越早做越好。因为对应用的改动较大，而且迁移成本高。<br>综上，数据库设计要面向现代化，面向世界，面向未来。。。<br>在一般运维的角度来看，我们什么情况下需要考虑分库分表？<br>首先说明，这里所说的分库分表是指把数据库数据的物理拆分到多个实例或者多台机器上去，而不是类似分区表的原地切分。<br>原则零：能不分就不分。<br>是的，MySQL 是关系数据库，数据库表之间的关系从一定的角度上映射了业务逻辑。任何分库分表的行为都会在某种程度上提升业务逻辑的复杂度，数据库除了承载数据的存储和访问外，协助业务更好的实现需求和逻辑也是其重要工作之一。分库分表会带来数据的合并，查询或者更新条件的分离，事务的分离等等多种后果，业务实现的复杂程度往往会翻倍或者指数级上升。所以，在分库分表之前，不要为分而分，去做其他力所能及的事情吧，例如升级硬件，升级，升级网络，升级数据库版本，读写分离，负载均衡等等。所有分库分表的前提是，这些你已经尽力了。<br>原则一：数据量太大，正常的运维影响正常业务访问。<br>这里说的运维，例如：<br>（1）对数据库的备份。如果单表或者单个实例太大，在做备份的时候需要大量的磁盘IO或者网络IO资源。例如1T的数据，网络传输占用50MB的时候，需要20000秒才能传输完毕，在此整个过程中的维护风险都是高于平时的。我们在Qunar的做法是给所有的数据库机器添加第二块网卡，用来做备份，或者SST，Group Communication等等各种内部的数据传输。1T的数据的备份，也会占用大量的磁盘IO，如果是SSD还好，当然这里忽略某些厂商的产品在集中IO的时候会出一些BUG的问题。如果是普通的物理磁盘，则在不限流的情况下去执行xtrabackup，该实例基本不可用。<br>（2）对数据表的修改。如果某个表过大，对此表做DDL的时候，MySQL会锁住全表，这个时间可能很长，在这段时间业务不能访问此表，影响甚大。解决的办法有类似腾讯游戏DBA自己改造的可以在线秒改表，不过他们目前也只是能添加字段而已，对别的DDL还是无效；或者使用pt-online-schema-change，当然在使用过程中，它需要建立触发器和影子表，同时也需要很长很长的时间，在此操作过程中的所有时间，都可以看做是风险时间。把数据表切分，总量减小，有助于改善这种风险。<br>（3）整个表热点，数据访问和更新频繁，经常有锁等待，你又没有能力去修改源码，降低锁的粒度，那么只会把其中的数据物理拆开，用空间换时间，变相降低访问压力。<br>原则二：表设计不合理，需要对某些字段垂直拆分<br>这里举一个例子，如果你有一个用户表，在最初设计的时候可能是这样：<br>table :users<br>id bigint 用户的ID<br>name varchar 用户的名字<br>last_login_time datetime 最近登录时间<br>personal_info text 私人信息<br>xxxxx 其他信息字段。<br>一般的users表会有很多字段，我就不列举了。如上所示，在一个简单的应用中，这种设计是很常见的。但是：<br>设想情况一：你的业务中彩了，用户数从100w飙升到10个亿。你为了统计活跃用户，在每个人登录的时候都会记录一下他的最近登录时间。并且的用户活跃得很，不断的去更新这个login_time，搞的你的这个表不断的被update，压力非常大。那么，在这个时候，只要考虑对它进行拆分，站在业务的角度，最好的办法是先把last_login_time拆分出去，我们叫它 user_time。这样做，业务的代码只有在用到这个字段的时候修改一下就行了。如果你不这么做，直接把users表水平切分了，那么，所有访问users表的地方，都要修改。或许你会说，我有proxy，能够动态merge数据。到目前为止我还从没看到谁家的proxy不影响性能的。<br>设想情况二：personal_info这个字段本来没啥用，你就是让用户注册的时候填一些个人爱好而已，基本不查询。一开始的时候有它没它无所谓。但是到后来发现两个问题，一，这个字段占用了大量的空间，因为是text嘛，有很多人喜欢长篇大论地介绍自己。更糟糕的是二，不知道哪天哪个产品经理心血来潮，说允许个人信息公开吧，以方便让大家更好的相互了解。那么在所有人猎奇窥私心理的影响下，对此字段的访问大幅度增加。数据库压力瞬间抗不住了，这个时候，只好考虑对这个表的垂直拆分了。<br>原则三：某些数据表出现了无穷增长<br>例子很好举，各种的评论，消息，日志记录。这个增长不是跟人口成比例的，而是不可控的，例如微博的feed的广播，我发一条消息，会扩散给很多很多人。虽然主体可能只存一份，但不排除一些索引或者路由有这种存储需求。这个时候，增加存储，提升机器配置已经苍白无力了，水平切分是最佳实践。拆分的标准很多，按用户的，按时间的，按用途的，不在一一举例。<br>原则四：安全性和可用性的考虑<br>这个很容易理解，鸡蛋不要放在一个篮子里，我不希望我的数据库出问题，但我希望在出问题的时候不要影响到100%的用户，这个影响的比例越少越好，那么，水平切分可以解决这个问题，把用户，库存，订单等等本来同统一的资源切分掉，每个小的数据库实例承担一小部分业务，这样整体的可用性就会提升。这对Qunar这样的业务还是比较合适的，人与人之间，某些库存与库存之间，关联不太大，可以做一些这样的切分。<br>原则五：业务耦合性考虑<br>这个跟上面有点类似，主要是站在业务的层面上，我们的火车票业务和烤羊腿业务是完全无关的业务，虽然每个业务的数据量可能不太大，放在一个MySQL实例中完全没问题，但是很可能烤羊腿业务的DBA 或者开发人员水平很差，动不动给你出一些幺蛾子，直接把数据库搞挂。这个时候，火车票业务的人员虽然技术很优秀，工作也很努力，照样被老板打屁股。解决的办法很简单:惹不起，躲得起。<br>20条规则摘要如下：<br>规则1：一般情况可以选择MyISAM存储引擎，如果需要事务支持必须使用InnoDB存储引擎。<br>规则2：命名规则。<br>规则3：数据库字段类型定义</li><li>经常需要计算和排序等消耗CPU的字段,应该尽量选择更为迅速的字段，如用TIMESTAMP(4个字节，最小值1970-01-01 00:00:00)代替Datetime（8个字节，最小值1001-01-01 00:00:00）,通过整型替代浮点型和字符型</li><li>变长字段使用varchar，不要使用char</li><li>对于二进制多媒体数据，流水队列数据(如日志)，超大文本数据不要放在数据库字段中<br>规则4：业务逻辑执行过程必须读到的表中必须要有初始的值。避免业务读出为负或无穷大的值导致程序失败<br>规则5：并不需要一定遵守范式理论，适度的冗余，让Query尽量减少Join<br>规则6：访问频率较低的大字段拆分出数据表。有些大字段占用空间多，访问频率较其他字段明显要少很多，这种情况进行拆分，频繁的查询中就不需要读取大字段，造成IO资源的浪费。<br>规则7： 水平分表，这个我还是建议 三思，搞不好非但不能提升性能反而多了很多的join和磁盘IO，开发起来也麻烦，有很多的业务就是要求一次查询大部分的字段 看你业务场景了。大表可以考虑水平拆分。大表影响查询效率，根据业务特性有很多拆分方式，像根据时间递增的数据，可以根据时间来分。以id划分的数据，可根据id%数据库个数的方式来拆分。<br>规则8：业务需要的相关索引是根据实际的设计所构造sql语句的where条件来确定的，业务不需要的不要建索引，不允许在联合索引（或主键）中存在多于的字段。特别是该字段根本不会在条件语句中出现。<br>规则9：唯一确定一条记录的一个字段或多个字段要建立主键或者唯一索引，不能唯一确定一条记录，为了提高查询效率建普通索引。<br>规则10：业务使用的表，有些记录数很少，甚至只有一条记录，为了约束的需要，也要建立索引或者设置主键。<br>规则11：对于取值不能重复，经常作为查询条件的字段，应该建唯一索引(主键默认唯一索引)，并且将查询条件中该字段的条件置于第一个位置。没有必要再建立与该字段有关的联合索引。<br>规则12：对于经常查询的字段，其值不唯一，也应该考虑建立普通索引，查询语句中该字段条件置于第一个位置，对联合索引处理的方法同样。<br>规则13：业务通过不唯一索引访问数据时，需要考虑通过该索引值返回的记录稠密度，原则上可能的稠密度最大不能高于0.2，如果稠密度太大，则不合适建立索引了。<br>规则14：需要联合索引(或联合主键)的数据库要注意索引的顺序。SQL语句中的匹配条件也要跟索引的顺序保持一致。<br>注意：索引的顺势不正确也可能导致严重的后果。<br>规则15：表中的多个字段查询作为查询条件，不含有其他索引，并且字段联合值不重复，可以在这多个字段上建唯一的联合索引，假设索引字段为 (a1,a2,…an),则查询条件(a1 op val1,a2 op val2,…am op valm)m&lt;=n,可以用到索引，查询条件中字段的位置与索引中的字段位置是一致的。<br>规则16：联合索引的建立原则(以下均假设在数据库表的字段a,b,c上建立联合索引(a,b,c))。<br>规则17：重要业务访问数据表时。但不能通过索引访问数据时，应该确保顺序访问的记录数目是有限的，原则上不得多于10。<br>规则18：合理构造Query语句，慢SQL监控，检查是否有大量的的子查询和关联查询 嵌套查询等，尽量避免使用这些查询， 使用连接（JOIN）来代替子查询(Sub-Queries)，使用联合(UNION)来代替手动创建的临时表。<br>规则19：应用系统的优化。<br>规则20：可以结合redis，memcache等缓存服务，把这些复杂的sql进行拆分， 充分利用二级缓存 ，减少数据库IO操作。对数据库连接池，mybatis，hiberante二级缓存充分利用上。尽量使用顺序IO代替随机IO。合理使用索引，尽量避免全表扫描。</li></ol><h1 id="MySQL-InnoDB、Mysaim的特点？"><a href="#MySQL-InnoDB、Mysaim的特点？" class="headerlink" title="MySQL InnoDB、Mysaim的特点？"></a>MySQL InnoDB、Mysaim的特点？</h1><p>a. InnoDB：</p><ol><li>⽀持事务处理</li><li>⽀持外键</li><li>⽀持⾏锁</li><li>不⽀持FULLTEXT类型的索引（在Mysql5.6已引⼊）</li><li>不保存表的具体⾏数，扫描表来计算有多少⾏</li><li>对于AUTO_INCREMENT类型的字段，必须包含只有该字段的索引</li><li>DELETE 表时，是⼀⾏⼀⾏的删除</li><li>InnoDB 把数据和索引存放在表空间⾥⾯</li><li>跨平台可直接拷⻉使⽤</li><li>表格很难被压缩<br>b. MyISAM：</li><li>不⽀持事务，回滚将造成不完全回滚，不具有原⼦性</li><li>不⽀持外键</li><li>⽀持全⽂搜索</li><li>保存表的具体⾏数,不带where时，直接返回保存的⾏数</li><li>DELETE 表时，先drop表，然后重建表</li><li>MyISAM 表被存放在三个⽂件 。frm ⽂件存放表格定义。 数据⽂件是MYD (MYData) 。 索引⽂件是MYI<br>(MYIndex)引伸</li><li>跨平台很难直接拷⻉</li><li>AUTO_INCREMENT类型字段可以和其他字段⼀起建⽴联合索引</li><li>表格可以被压缩<br>c. 选择：因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原⼦性要求低。那么MyISAM最好<br>的选择。且MyISAM恢复速度快。可直接⽤备份覆盖恢复。如果系统读少，写多的时候，尤其是并发写⼊⾼的时候。<br>InnoDB就是⾸选了。两种类型都有⾃⼰优缺点，选择那个完全要看⾃⼰的实际类弄。</li></ol><h1 id="⾏锁，表锁；乐观锁，悲观锁？"><a href="#⾏锁，表锁；乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁；乐观锁，悲观锁？"></a>⾏锁，表锁；乐观锁，悲观锁？</h1><p>a. ⾏锁：数据库表中某⼀⾏被锁住。<br>b. 表锁：整个数据库表被锁住。<br>c. 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别⼈不会修改，具体实现是给表增加⼀个版本号的字<br>段，在执⾏update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。<br>d. 悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别⼈会修改。读数据的时候会上锁，直到update完成才<br>释放锁，使⽤悲观锁要注意不要锁住整个表。</p><h1 id="数据库隔离级别是什么？有什么作⽤？"><a href="#数据库隔离级别是什么？有什么作⽤？" class="headerlink" title="数据库隔离级别是什么？有什么作⽤？"></a>数据库隔离级别是什么？有什么作⽤？</h1><ol><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。<br>这种隔离级别会产⽣脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该<br>事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个<br>事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，<br>不可重复读外，还避免了幻读。</li></ol><h1 id="MySQL主备同步的基本原理。"><a href="#MySQL主备同步的基本原理。" class="headerlink" title="MySQL主备同步的基本原理。"></a>MySQL主备同步的基本原理。</h1><p>mysql主备复制实现分成三个步骤：<br>1、master将改变记录到⼆进制⽇志(binary log)中（这些记录叫做⼆进制⽇志事件，binary log events，可以通过show<br>binlog events进⾏查看）；<br>2、slave将master的binary log events拷⻉到它的中继⽇志(relay log)；<br>3、slave重做中继⽇志中的事件，将改变反映它⾃⼰的数据。</p><h1 id="select-from-table-t-where-size-gt-10-group-by-size-order-by-size的sql语句执⾏顺序？"><a href="#select-from-table-t-where-size-gt-10-group-by-size-order-by-size的sql语句执⾏顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句执⾏顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句执⾏顺序？</h1><p>sql语句执⾏顺序如下：<br>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</p><h1 id="如何优化数据库性能（索引、分库分表、批置操作、分⻚算法、升级硬盘SSD、业务优化、主从部署）"><a href="#如何优化数据库性能（索引、分库分表、批置操作、分⻚算法、升级硬盘SSD、业务优化、主从部署）" class="headerlink" title="如何优化数据库性能（索引、分库分表、批置操作、分⻚算法、升级硬盘SSD、业务优化、主从部署）"></a>如何优化数据库性能（索引、分库分表、批置操作、分⻚算法、升级硬盘SSD、业务优化、主从部署）</h1><p>1、选择合适的数据库引擎，合理使⽤索引<br>2、分⻚获取数据，只获取需要的字段<br>3、优化业务逻辑，减少数据库IO<br>4、分库分表<br>5、部署主从数据库<br>6、升级硬件</p><h1 id="SQL什么情况下不会使⽤索引（不包含，不等于，函数）"><a href="#SQL什么情况下不会使⽤索引（不包含，不等于，函数）" class="headerlink" title="SQL什么情况下不会使⽤索引（不包含，不等于，函数）"></a>SQL什么情况下不会使⽤索引（不包含，不等于，函数）</h1><p>a. select * 可能导致不⾛索引；<br>b. 空值会导致不⾛索引，因为hashset不能存空值；<br>c. 索引列有函数运算，不⾛索引，可以在索引列建⽴⼀个函数的索引。<br>d. 隐式转换可能导致不⾛索引；<br>e. 表的数据库⼩或者需要选择⼤部分数据，不⾛索引；<br>f. !=或者&lt;&gt;可能导致不⾛索引；<br>g. 字符型的索引列会导致优化器认为需要扫描索引⼤部分数据且聚簇因⼦很⼤，最终导致弃⽤索引扫描⽽改⽤全表扫描<br>⽅式<br>h. like ‘%liu’ 百分号在前不⾛索引；<br>i. not in, not exist不⾛索引；</p><h1 id="—般在什么字段上建索引（过滤数据最多的字段）"><a href="#—般在什么字段上建索引（过滤数据最多的字段）" class="headerlink" title="—般在什么字段上建索引（过滤数据最多的字段）"></a>—般在什么字段上建索引（过滤数据最多的字段）</h1><p>1、表的主键、外键必须有索引；<br>2、数据量超过300的表应该有索引；<br>3、经常与其他表进⾏连接的表，在连接字段上应该建⽴索引；<br>4、经常出现在Where⼦句中的字段，特别是⼤表的字段，应该建⽴索引；<br>5、索引应该建在选择性⾼的字段上；<br>6、索引应该建在⼩字段上，对于⼤的⽂本字段甚⾄超⻓字段，不要建索引；</p><h1 id="如何从⼀张表中查出name字段不包含”XYZ”的所有⾏？"><a href="#如何从⼀张表中查出name字段不包含”XYZ”的所有⾏？" class="headerlink" title="如何从⼀张表中查出name字段不包含”XYZ”的所有⾏？"></a>如何从⼀张表中查出name字段不包含”XYZ”的所有⾏？</h1><p>1 select * from table where name not like ‘%XYZ%’;</p><h1 id="HRedis-RDB和A0Ff如何做⾼可⽤、集群"><a href="#HRedis-RDB和A0Ff如何做⾼可⽤、集群" class="headerlink" title="HRedis, RDB和A0Ff如何做⾼可⽤、集群"></a>HRedis, RDB和A0Ff如何做⾼可⽤、集群</h1><h1 id="如何解决⾼并发减库存问题"><a href="#如何解决⾼并发减库存问题" class="headerlink" title="如何解决⾼并发减库存问题"></a>如何解决⾼并发减库存问题</h1><p>消息队列，异步处理，减库存加锁</p><h1 id="mysql存储引擎中索引的实现机制；"><a href="#mysql存储引擎中索引的实现机制；" class="headerlink" title="mysql存储引擎中索引的实现机制；"></a>mysql存储引擎中索引的实现机制；</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/debug_zhang/article/details/52168552">https://blog.csdn.net/debug_zhang/article/details/52168552</a></p><h1 id="数据库事务的⼏种粒度；"><a href="#数据库事务的⼏种粒度；" class="headerlink" title="数据库事务的⼏种粒度；"></a>数据库事务的⼏种粒度；</h1><p>a. 表锁定：对整个表的锁定。<br>b. ⾏锁定：只锁定进⾏更改的⾏，例如：insert，update，delete，都隐式采⽤⾏锁定。<br>c. 数据库锁机制可分为多种粒度的： 数据库，表，⻚⾯，⾏<br>d. 粒度越⼤，DBMS管理越容易，但是实现并发处理的能⼒就越差，表，⻚⾯，⾏</p><h1 id="mysql调优："><a href="#mysql调优：" class="headerlink" title="mysql调优："></a>mysql调优：</h1><p>a. explain select语句；<br>b. 当只要⼀条数据时使⽤limit 1；<br>c. 为搜索字段建索引；<br>d. 避免select *；<br>e. 字段尽量使⽤not null；<br>f. 垂直分割；<br>g. 拆分⼤的delete和insert语句：delete和insert会锁表；<br>h. 分表分库分区。</p><h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性 (Atomicity)"></a>原子性 (Atomicity)</h4><p>原子性是指事冬是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 (Consistency)"></a>一致性 (Consistency)</h4><p>事务前后数据的完整性必须保持一致。(比如转账)</p><h4 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性 (Isolation)"></a>隔离性 (Isolation)</h4><p>事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔。</p><h4 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h4><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p><h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><p>事务进⾏过程中，每次sql语句执⾏，都会记录undo log和redo log，然后更新数据形成脏⻚，然后redo log按照时间或<br>者空间等条件进⾏落盘，undo log和脏⻚按照checkpoint进⾏落盘，落盘后相应的redo log就可以删除了。此时，事务还未<br>COMMIT，如果发⽣崩溃，则⾸先检查checkpoint记录，使⽤相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状<br>态发现事务尚未提交，然后就使⽤undo log进⾏事务回滚。事务执⾏COMMIT操作时，会将本事务相关的所有redo log都进⾏落<br>盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏⻚继续按照checkpoint进⾏落盘。如果此时发⽣了崩<br>溃，则只使⽤redo log恢复数据。</p><h1 id="让你设计⼀个索引，你会怎么设计？"><a href="#让你设计⼀个索引，你会怎么设计？" class="headerlink" title="让你设计⼀个索引，你会怎么设计？"></a>让你设计⼀个索引，你会怎么设计？</h1><p>mysql默认存储引擎innodb只显式⽀持B树索引，对于频繁访问的表，innodb会透明建⽴⾃适应hash索引，即在B树索引<br>基础上建⽴hash索引，可以显著提⾼查找效率，对于客户端是透明的，不可控制的，隐式的。</p><h1 id="用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。"><a href="#用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。" class="headerlink" title="用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。"></a>用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。</h1><p>employee:<br>eid,ename,salary,deptid;<br>select * from employee order by deptid desc,salary</p><h1 id="列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序"><a href="#列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序" class="headerlink" title="列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序"></a>列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序</h1><p>创建表：<br>mysql&gt; create table employee921(id int primary key auto_increment,name varchar(5<br>0),salary bigint,deptid int);</p><p>插入实验数据：<br>mysql&gt; insert into employee921 values(null,’zs’,1000,1),(null,’ls’,1100,1),(null<br>,’ww’,1100,1),(null,’zl’,900,1) ,(null,’zl’,1000,2), (null,’zl’,900,2) ,(null,’z<br>l’,1000,2) , (null,’zl’,1100,2);</p><p>编写sql语句：</p><p>（）select avg(salary) from employee921 group by deptid;<br>（）mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 where deptid = tid);<br>效率低的一个语句，仅供学习参考使用（在group by之后不能使用where，只能使用having，在group by之前可以使用where，即表示对过滤后的结果分组）：<br>mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 group by deptid having deptid = tid);<br>（）select count(*) ,tid<br>from (<br>select employee921.id,employee921.name,employee921.salary,employee921.deptid tid<br>from employee921<br>where salary &gt;<br>(select avg(salary) from employee921 where deptid = tid)<br>) as t<br>group by tid ;</p><p>另外一种方式：关联查询<br>select a.ename,a.salary,a.deptid<br>from emp a,<br>(select deptd,avg(salary) avgsal from emp group by deptid ) b<br>where a.deptid=b.deptid and a.salary&gt;b.avgsal;</p><h1 id="存储过程与触发器必须讲，经常被面试到"><a href="#存储过程与触发器必须讲，经常被面试到" class="headerlink" title="存储过程与触发器必须讲，经常被面试到?"></a>存储过程与触发器必须讲，经常被面试到?</h1><p>create procedure insert_Student (_name varchar(50),_age int ,out _id int)<br>begin<br>insert into student value(null,_name,_age);<br>select max(stuId) into _id from student;<br>end;</p><p>call insert_Student(‘wfz’,23,@id);<br>select @id;</p><p>mysql&gt; create trigger update_Student BEFORE update on student FOR EACH ROW<br>-&gt; select * from student;<br>触发器不允许返回结果</p><p>create trigger update_Student BEFORE update on student FOR EACH ROW<br>insert into student value(null,’zxx’,28);<br>mysql的触发器目前不能对当前表进行操作</p><p>create trigger update_Student BEFORE update on student FOR EACH ROW<br>delete from articles where id=8;<br>这个例子不是很好，最好是用删除一个用户时，顺带删除该用户的所有帖子<br>这里要注意使用OLD.id</p><p>触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而UCH没有用触发器，效率和数据处理能力都很低。<br>存储过程的实验步骤：<br>mysql&gt; delimiter |<br>mysql&gt; create procedure insertArticle_Procedure (pTitle varchar(50),pBid int,out<br>pId int)<br>-&gt; begin<br>-&gt; insert into article1 value(null,pTitle,pBid);<br>-&gt; select max(id) into pId from article1;<br>-&gt; end;<br>-&gt; |<br>Query OK, 0 rows affected (0.05 sec)</p><p>mysql&gt; call insertArticle_Procedure(‘传智播客’,1,@pid);<br>-&gt; |<br>Query OK, 0 rows affected (0.00 sec)</p><p>mysql&gt; delimiter ;<br>mysql&gt; select @pid;<br>+——+<br>| @pid |<br>+——+<br>| 3 |<br>+——+<br>1 row in set (0.00 sec)</p><p>mysql&gt; select * from article1;<br>+—-+————–+——+<br>| id | title | bid |<br>+—-+————–+——+<br>| 1 | test | 1 |<br>| 2 | chuanzhiboke | 1 |<br>| 3 | 传智播客 | 1 |<br>+—-+————–+——+<br>3 rows in set (0.00 sec)</p><p>触发器的实验步骤：<br>create table board1(id int primary key auto_increment,name varchar(50),ar<br>ticleCount int);</p><p>create table article1(id int primary key auto_increment,title varchar(50)<br>,bid int references board1(id));</p><p>delimiter |</p><p>create trigger insertArticle_Trigger after insert on article1 for each ro<br>w begin<br>-&gt; update board1 set articleCount=articleCount+1 where id= NEW.bid;<br>-&gt; end;<br>-&gt; |</p><p>delimiter ;</p><p>insert into board1 value (null,’test’,0);</p><p>insert into article1 value(null,’test’,1);<br>还有，每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，用触发器做效率就很高。下次课设计这样一个案例，写触发器时，对于最后发帖时间可能需要用declare方式声明一个变量，或者是用NEW.posttime来生成。</p><h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><p>第一范式（1NF）：字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式）<br>数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。</p><p>  第二范式（2NF）：<br>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。<br>要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。</p><p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>  <br>第三范式的要求如下：<br>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。<br>所以第三范式具有如下特征：<br>         1，每一列只有一个值<br>         2，每一行都能区分。<br>         3，每一个表都不包含其他表已经包含的非主关键字信息。<br>例如，帖子表中只能出现发帖人的id，而不能出现发帖人的id，还同时出现发帖人姓名，否则，只要出现同一发帖人id的所有记录，它们中的姓名部分都必须严格保持一致，这就是数据冗余。</p><h1 id="说出一些数据库优化方面的经验"><a href="#说出一些数据库优化方面的经验" class="headerlink" title="说出一些数据库优化方面的经验?"></a>说出一些数据库优化方面的经验?</h1><p>用PreparedStatement 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存<br>“inert into user values(1,1,1)”-二进制<br>“inert into user values(2,2,2)”-二进制<br>“inert into user values(?,?,?)”-二进制</p><p>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。（比喻：就好比免检产品，就是为了提高效率，充分相信产品的制造商）<br>（对于hibernate来说，就应该有一个变化：empleyee-&gt;Deptment对象，现在设计时就成了employeedeptid）</p><p>看mysql帮助文档子查询章节的最后部分，例如，根据扫描的原理，下面的子查询语句要比第二条关联查询的效率高：</p><ol><li><p>select e.name,e.salary where e.managerid=(select id from employee where name=’zxx’);</p></li><li><p>select e.name,e.salary,m.name,m.salary from employees e,employees m where<br>e.managerid = m.id and m.name=’zxx’;</p></li></ol><p>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等<br>将姓名和密码单独从用户表中独立出来。这可以是非常好的一对一的案例哟！</p><p>sql语句全部大写，特别是列名和表名都大写。特别是sql命令的缓存功能，更加需要统一大小写，sql语句发给oracle服务器语法检查和编译成为内部指令缓存和执行指令。根据缓存的特点，不要拼凑条件，而是用?和PreparedStatment</p><p>还有索引对查询性能的改进也是值得关注的。</p><p>备注：下面是关于性能的讨论举例</p><p>4航班 3个城市</p><p>m*n</p><p>select * from flight,city where flight.startcityid=city.cityid and city.name=’beijing’;</p><p>m + n</p><p>select * from flight where startcityid = (select cityid from city where cityname=’beijing’);</p><p>select flight.id,’beijing’,flight.flightTime from flight where startcityid = (select cityid from city where cityname=’beijing’)</p><h1 id="union和union-all有什么不同"><a href="#union和union-all有什么不同" class="headerlink" title="union和union all有什么不同?"></a>union和union all有什么不同?</h1><p>假设我们有一个表Student，包括以下字段与数据：<br>drop table student;<br>create table student<br>(<br>id int primary key,<br>name nvarchar2(50) not null,<br>score number not null<br>);<br>insert into student values(1,’Aaron’,78);<br>insert into student values(2,’Bill’,76);<br>insert into student values(3,’Cindy’,89);<br>insert into student values(4,’Damon’,90);<br>insert into student values(5,’Ella’,73);<br>insert into student values(6,’Frado’,61);<br>insert into student values(7,’Gill’,99);<br>insert into student values(8,’Hellen’,56);<br>insert into student values(9,’Ivan’,93);<br>insert into student values(10,’Jay’,90);<br>commit;<br>Union和Union All的区别。<br>select *<br>from student<br>where id &lt; 4<br>union<br>select *<br>from student<br>where id &gt; 2 and id &lt; 6<br>结果将是<br>1    Aaron    78<br>2    Bill    76<br>3    Cindy    89<br>4    Damon    90<br>5    Ella    73<br>如果换成Union All连接两个结果集，则返回结果是：<br>1    Aaron    78<br>2    Bill    76<br>3    Cindy    89<br>3    Cindy    89<br>4    Damon    90<br>5    Ella    73<br>可以看到，Union和Union All的区别之一在于对重复结果的处理。</p><p>　　UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。如：<br>select * from gc_dfys<br>union<br>select * from ls_jg_dfys<br>　　这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。<br>　而UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。<br>　从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL，</p><h1 id="分页语句"><a href="#分页语句" class="headerlink" title="分页语句"></a>分页语句</h1><p>取出sql表中第31到40的记录（以自动增长ID为主键）<br>sql server方案1：<br>select top 10 * from t where id not in (select top 30 id from t order by id ) orde by id<br>sql server方案2：<br>select top 10 * from t where id in (select top 40 id from t order by id) order by id desc</p><p>mysql方案：select * from t order by id limit 30,10</p><p>oracle方案：select * from (select rownum r,* from t where r&lt;=40) where r&gt;30</p><p>——————–待整理进去的内容————————————-<br>pageSize=20;<br>pageNo = 5;</p><p>1.分页技术1（直接利用sql语句进行分页，效率最高和最推荐的）</p><p>mysql:sql = “select * from articles limit “ + (pageNo-1)<em>pageSize + “,” + pageSize;<br>oracle: sql = “select * from “ +<br>“(select rownum r,</em> from “ +<br>“(select * from articles order by postime desc)” +<br>“where rownum&lt;= “ + pageNo*pageSize +”) tmp “ +<br>“where r&gt;” + (pageNo-1)*pageSize;<br>注释：第7行保证rownum的顺序是确定的，因为oracle的索引会造成rownum返回不同的值<br>简洋提示：没有order by时，rownum按顺序输出，一旦有了order by，rownum不按顺序输出了，这说明rownum是排序前的编号。如果对order by从句中的字段建立了索引，那么，rownum也是按顺序输出的，因为这时候生成原始的查询结果集时会参照索引表的顺序来构建。</p><p>sqlserver:sql = “select top 10 * from id not id(select top “ + (pageNo-1)*pageSize + “id from articles)”</p><p>DataSource ds = new InitialContext().lookup(jndiurl);<br>Connection cn = ds.getConnection();<br>//“select * from user where id=?” —&gt;binary directive<br>PreparedStatement pstmt = cn.prepareSatement(sql);<br>ResultSet rs = pstmt.executeQuery()<br>while(rs.next())<br>{<br>out.println(rs.getString(1));<br>}</p><p>2.不可滚动的游标<br>pageSize=20;<br>pageNo = 5;<br>cn = null<br>stmt = null;<br>rs = null;<br>try<br>{<br>sqlserver:sql = “select * from articles”;</p><p>DataSource ds = new InitialContext().lookup(jndiurl);<br>Connection cn = ds.getConnection();<br>//“select * from user where id=?” —&gt;binary directive<br>PreparedStatement pstmt = cn.prepareSatement(sql);<br>ResultSet rs = pstmt.executeQuery()<br>for(int j=0;j&lt;(pageNo-1)*pageSize;j++)<br>{<br>rs.next();<br>}</p><p>int i=0;</p><p>while(rs.next() &amp;&amp; i&lt;10)<br>{<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly<br>{<br>if(rs!=null)try{rs.close();}catch(Exception e){}<br>if(stm………<br>if(cn…………<br>}</p><p>3.可滚动的游标<br>pageSize=20;<br>pageNo = 5;<br>cn = null<br>stmt = null;<br>rs = null;<br>try<br>{<br>sqlserver:sql = “select * from articles”;</p><p>DataSource ds = new InitialContext().lookup(jndiurl);<br>Connection cn = ds.getConnection();<br>//“select * from user where id=?” —&gt;binary directive<br>PreparedStatement pstmt = cn.prepareSatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,…);<br>//根据上面这行代码的异常SQLFeatureNotSupportedException，就可判断驱动是否支持可滚动游标</p><p>ResultSet rs = pstmt.executeQuery()<br>rs.absolute((pageNo-1)*pageSize)<br>int i=0;<br>while(rs.next() &amp;&amp; i&lt;10)<br>{<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly<br>{<br>if(rs!=null)try{rs.close();}catch(Exception e){}<br>if(stm………<br>if(cn…………<br>}</p><h1 id="用一条SQL语句-查询出每门课都大于80分的学生姓名"><a href="#用一条SQL语句-查询出每门课都大于80分的学生姓名" class="headerlink" title="用一条SQL语句 查询出每门课都大于80分的学生姓名"></a>用一条SQL语句 查询出每门课都大于80分的学生姓名</h1><p>name   kecheng   fenshu<br>张三     语文       81<br>张三     数学       75<br>李四     语文       76<br>李四     数学       90<br>王五     语文       81<br>王五     数学       100<br>王五     英语       90</p><p>准备数据的sql代码：<br>create table score(id int primary key auto_increment,name varchar(20),subject varchar(20),score int);<br>insert into score values<br>(null,’张三’,’语文’,81),<br>(null,’张三’,’数学’,75),<br>(null,’李四’,’语文’,76),<br>(null,’李四’,’数学’,90),<br>(null,’王五’,’语文’,81),<br>(null,’王五’,’数学’,100),<br>(null,’王五 ‘,’英语’,90);</p><p>提示：当百思不得其解时，请理想思维，把小变成大做，把大变成小做，</p><p>答案：<br>A: select distinct name from score  where  name not in (select distinct name from score where score&lt;=80)</p><p>B:select distince name t1 from score where 80&lt; all (select score from score where name=t1);</p><h1 id="所有部门之间的比赛组合"><a href="#所有部门之间的比赛组合" class="headerlink" title="所有部门之间的比赛组合"></a>所有部门之间的比赛组合</h1><p>一个叫department的表，里面只有一个字段name,一共有4条纪录，分别是a,b,c,d,对应四个球对，现在四个球对进行比赛，用一条sql语句显示所有可能的比赛组合.</p><p>答：select a.name, b.name<br>from team a, team b<br>where a.name &lt; b.name</p><h1 id="每个月份的发生额都比101科目多的科目"><a href="#每个月份的发生额都比101科目多的科目" class="headerlink" title="每个月份的发生额都比101科目多的科目"></a>每个月份的发生额都比101科目多的科目</h1><p>请用SQL语句实现：从TestDB数据表中查询出所有月份的发生额都比101科目相应月份的发生额高的科目。请注意：TestDB中有很多科目，都有1－12月份的发生额。<br>AccID：科目代码，Occmonth：发生额月份，DebitOccur：发生额。<br>数据库名：JcyAudit，数据集：Select * from TestDB<br>准备数据的sql代码：<br>drop table if exists TestDB;<br>create table TestDB(id int primary key auto_increment,AccID varchar(20), Occmonth date, DebitOccur bigint);<br>insert into TestDB values<br>(null,’101’,’1988-1-1’,100),<br>(null,’101’,’1988-2-1’,110),<br>(null,’101’,’1988-3-1’,120),<br>(null,’101’,’1988-4-1’,100),<br>(null,’101’,’1988-5-1’,100),<br>(null,’101’,’1988-6-1’,100),<br>(null,’101’,’1988-7-1’,100),<br>(null,’101’,’1988-8-1’,100);<br>–复制上面的数据，故意把第一个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’102’,’1988-1-1’,90),<br>(null,’102’,’1988-2-1’,110),<br>(null,’102’,’1988-3-1’,120),<br>(null,’102’,’1988-4-1’,100),<br>(null,’102’,’1988-5-1’,100),<br>(null,’102’,’1988-6-1’,100),<br>(null,’102’,’1988-7-1’,100),<br>(null,’102’,’1988-8-1’,100);<br>–复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’103’,’1988-1-1’,150),<br>(null,’103’,’1988-2-1’,160),<br>(null,’103’,’1988-3-1’,180),<br>(null,’103’,’1988-4-1’,120),<br>(null,’103’,’1988-5-1’,120),<br>(null,’103’,’1988-6-1’,120),<br>(null,’103’,’1988-7-1’,120),<br>(null,’103’,’1988-8-1’,120);<br>–复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’104’,’1988-1-1’,130),<br>(null,’104’,’1988-2-1’,130),<br>(null,’104’,’1988-3-1’,140),<br>(null,’104’,’1988-4-1’,150),<br>(null,’104’,’1988-5-1’,160),<br>(null,’104’,’1988-6-1’,170),<br>(null,’104’,’1988-7-1’,180),<br>(null,’104’,’1988-8-1’,140);<br>–复制最上面的数据，故意把第二个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’105’,’1988-1-1’,100),<br>(null,’105’,’1988-2-1’,80),<br>(null,’105’,’1988-3-1’,120),<br>(null,’105’,’1988-4-1’,100),<br>(null,’105’,’1988-5-1’,100),<br>(null,’105’,’1988-6-1’,100),<br>(null,’105’,’1988-7-1’,100),<br>(null,’105’,’1988-8-1’,100);<br>答案：<br>select distinct AccID from TestDB<br>where AccID not in<br>(select TestDB.AccIDfrom TestDB,<br>(select * from TestDB where AccID=’101’) as db101<br>where TestDB.Occmonth=db101.Occmonth and TestDB.DebitOccur&lt;=db101.DebitOccur<br>);</p><h1 id="统计每年每月的信息"><a href="#统计每年每月的信息" class="headerlink" title="统计每年每月的信息"></a>统计每年每月的信息</h1><p>year  month amount<br>1991   1     1.1<br>1991   2     1.2<br>1991   3     1.3<br>1991   4     1.4<br>1992   1     2.1<br>1992   2     2.2<br>1992   3     2.3<br>1992   4     2.4<br>查成这样一个结果<br>year m1  m2  m3  m4<br>1991 1.1 1.2 1.3 1.4<br>1992 2.1 2.2 2.3 2.4</p><p>提示：这个与工资条非常类似，与学生的科目成绩也很相似。</p><p>准备sql语句：<br>drop table if exists sales;<br>create table sales(id int auto_increment primary key,year varchar(10), month varchar(10), amount float(2,1));<br>insert into sales values<br>(null,’1991’,’1’,1.1),<br>(null,’1991’,’2’,1.2),<br>(null,’1991’,’3’,1.3),<br>(null,’1991’,’4’,1.4),<br>(null,’1992’,’1’,2.1),<br>(null,’1992’,’2’,2.2),<br>(null,’1992’,’3’,2.3),<br>(null,’1992’,’4’,2.4);</p><p>答案一、<br>select sales.year ,<br>(select t.amount from sales t where t.month=’1’ and t.year= sales.year) ‘1’,<br>(select t.amount from sales t where t.month=’1’ and t.year= sales.year) ‘2’,<br>(select t.amount from sales t where t.month=’1’ and t.year= sales.year) ‘3’,<br>(select t.amount from sales t where t.month=’1’ and t.year= sales.year) as ‘4’<br>from sales group by year;</p><h1 id="显示文章标题，发帖人、最后回复时间"><a href="#显示文章标题，发帖人、最后回复时间" class="headerlink" title="显示文章标题，发帖人、最后回复时间"></a>显示文章标题，发帖人、最后回复时间</h1><p>表：id,title,postuser,postdate,parentid<br>准备sql语句：<br>drop table if exists articles;<br>create table articles(id int auto_increment primary key,title varchar(50), postuser varchar(10), postdate datetime,parentid int references articles(id));<br>insert into articles values<br>(null,’第一条’,’张三’,’1998-10-10 12:32:32’,null),<br>(null,’第二条’,’张三’,’1998-10-10 12:34:32’,null),<br>(null,’第一条回复1’,’李四’,’1998-10-10 12:35:32’,1),<br>(null,’第二条回复1’,’李四’,’1998-10-10 12:36:32’,2),<br>(null,’第一条回复2’,’王五’,’1998-10-10 12:37:32’,1),<br>(null,’第一条回复3’,’李四’,’1998-10-10 12:38:32’,1),<br>(null,’第二条回复2’,’李四’,’1998-10-10 12:39:32’,2),<br>(null,’第一条回复4’,’王五’,’1998-10-10 12:39:40’,1);</p><p>答案：<br>select a.title,a.postuser,<br>(select max(postdate) from articles where parentid=a.id) reply<br>from articles a where a.parentid is null;</p><p>注释：子查询可以用在选择列中，也可用于where的比较条件中，还可以用于from从句中。</p><h1 id="删除除了id号不同-其他都相同的学生冗余信息"><a href="#删除除了id号不同-其他都相同的学生冗余信息" class="headerlink" title="删除除了id号不同,其他都相同的学生冗余信息"></a>删除除了id号不同,其他都相同的学生冗余信息</h1><p>2.学生表 如下:<br>id号   学号   姓名 课程编号 课程名称 分数<br>1        2005001  张三  0001      数学    69<br>2        2005002  李四  0001      数学    89<br>3        2005001  张三  0001      数学    69<br>A: delete from tablename where id号 not in(select min(id号) from tablename group by 学号,姓名,课程编号,课程名称,分数)<br>实验：<br>create table student2(id int auto_increment primary key,code varchar(20),name varchar(20));<br>insert into student2 values(null,’2005001’,’张三’),(null,’2005002’,’李四’),(null,’2005001’,’张三’);</p><p>//如下语句，mysql报告错误，可能删除依赖后面统计语句，而删除又导致统计语句结果不一致。</p><p>delete from student2 where id not in(select min(id) from student2 group by name);<br>//但是，如下语句没有问题：<br>select * from student2 where id not in(select min(id) from student2 group by name);<br>//于是，我想先把分组的结果做成虚表，然后从虚表中选出结果，最后再将结果作为删除的条件数据。<br>delete from student2 where id not in(select mid from (select min(id) mid<br>from student2 group by name) as t);<br>或者：<br>delete from student2 where id not in(select min(id) from (select * from s<br>tudent2) as t group by t.name);</p><h1 id="航空网的几个航班查询题："><a href="#航空网的几个航班查询题：" class="headerlink" title="航空网的几个航班查询题："></a>航空网的几个航班查询题：</h1><p>表结构如下：<br>flight{flightID,StartCityID ,endCityID,StartTime}<br>city{cityID, CityName)<br>实验环境：<br>create table city(cityID int auto_increment primary key,cityName varchar(20));<br>create table flight (flightID int auto_increment primary key,<br>StartCityID int references city(cityID),<br>endCityID int references city(cityID),<br>StartTime timestamp);<br>//航班本来应该没有日期部分才好，但是下面的题目当中涉及到了日期<br>insert into city values(null,’北京’),(null,’上海’),(null,’广州’);<br>insert into flight values<br>(null,1,2,’9:37:23’),(null,1,3,’9:37:23’),(null,1,2,’10:37:23’),(null,2,3,’10:37:23’);</p><p>1、查询起飞城市是北京的所有航班，按到达城市的名字排序</p><p>参与运算的列是我起码能够显示出来的那些列，但最终我不一定把它们显示出来。各个表组合出来的中间结果字段中必须包含所有运算的字段。</p><p>select * from flight f,city c<br>where f.endcityid = c.cityid and startcityid =<br>(select c1.cityid from city c1 where c1.cityname = “北京”)<br>order by c.cityname asc;</p><p>mysql&gt; select flight.flightid,’北京’ startcity, e.cityname from flight,city e wh<br>ere flight.endcityid=e.cityid and flight.startcityid=(select cityid from city wh<br>ere cityname=’北京’);</p><p>mysql&gt; select flight.flightid,s.cityname,e.cityname from flight,city s,city e wh<br>ere flight.startcityid=s.cityid and s.cityname=’北京’ and flight.endCityId=e.cit<br>yID order by e.cityName desc;</p><p>2、查询北京到上海的所有航班纪录（起飞城市，到达城市，起飞时间，航班号）<br>select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID=c1.cityID<br>and f.endCityID=c2.cityID<br>and c1.cityName=’北京’<br>and c2.cityName=’上海’<br>3、查询具体某一天（2005-5-8）的北京到上海的的航班次数<br>select count(*) from<br>(select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID=c1.cityID<br>and f.endCityID=c2.cityID<br>and c1.cityName=’北京’<br>and c2.cityName=’上海’<br>and 查帮助获得的某个日期处理函数(startTime) like ‘2005-5-8%’</p><p>mysql中提取日期部分进行比较的示例代码如下：<br>select * from flight where date_format(starttime,’%Y-%m-%d’)=’1998-01-02’</p><h1 id="查出比经理薪水还高的员工信息："><a href="#查出比经理薪水还高的员工信息：" class="headerlink" title="查出比经理薪水还高的员工信息："></a>查出比经理薪水还高的员工信息：</h1><p>Drop table if not exists employees;<br>create table employees(id int primary key auto_increment,name varchar(50)<br>,salary int,managerid int references employees(id));<br>insert into employees values (null,’ lhm’,10000,null), (null,’ zxx’,15000,1<br>),(null,’flx’,9000,1),(null,’tg’,10000,2),(null,’wzg’,10000,3);</p><p>Wzg大于flx,lhm大于zxx</p><p>解题思路：<br>根据sql语句的查询特点，是逐行进行运算，不可能两行同时参与运算。<br>涉及了员工薪水和经理薪水，所有，一行记录要同时包含两个薪水，所有想到要把这个表自关联组合一下。<br>首先要组合出一个包含有各个员工及该员工的经理信息的长记录，譬如，左半部分是员工，右半部分是经理。而迪卡尔积会组合出很多垃圾信息，先去除这些垃圾信息。</p><p>select e.* from employees e,employees m where e.managerid=m.id and e.sala<br>ry&gt;m.salary;</p><h1 id="求出小于45岁的各个老师所带的大于12岁的学生人数"><a href="#求出小于45岁的各个老师所带的大于12岁的学生人数" class="headerlink" title="求出小于45岁的各个老师所带的大于12岁的学生人数"></a>求出小于45岁的各个老师所带的大于12岁的学生人数</h1><p>数据库中有3个表 teacher 表，student表，tea_stu关系表。<br>teacher 表 teaID name age<br>student 表 stuID name age<br>teacher_student表 teaID stuID<br>要求用一条sql查询出这样的结果<br>1.显示的字段要有老师name, age 每个老师所带的学生人数<br>2 只列出老师age为40以下，学生age为12以上的记录<br>预备知识：<br>1.sql语句是对每一条记录依次处理，条件为真则执行动作（select,insert,delete,update）<br>2.只要是迪卡尔积，就会产生“垃圾”信息，所以，只要迪卡尔积了，我们首先就要想到清除“垃圾”信息<br>实验准备：<br>drop table if exists tea_stu;<br>drop table if exists teacher;<br>drop table if exists student;<br>create table teacher(teaID int primary key,name varchar(50),age int);<br>create table student(stuID int primary key,name varchar(50),age int);<br>create table tea_stu(teaID int references teacher(teaID),stuID int references student(stuID));<br>insert into teacher values(1,’zxx’,45), (2,’lhm’,25) , (3,’wzg’,26) , (4,’tg’,27);<br>insert into student values(1,’wy’,11), (2,’dh’,25) , (3,’ysq’,26) , (4,’mxc’,27);<br>insert into tea_stu values(1,1), (1,2), (1,3);<br>insert into tea_stu values(2,2), (2,3), (2,4);<br>insert into tea_stu values(3,3), (3,4), (3,1);<br>insert into tea_stu values(4,4), (4,1), (4,2) , (4,3);</p><p>结果：23,32,43</p><p>解题思路：（真实面试答题时，也要写出每个分析步骤，如果纸张不够，就找别人要）<br>1要会统计分组信息，统计信息放在中间表中：<br>select teaid,count(*) from tea_stu group by teaid;</p><p>2接着其实应该是筛除掉小于12岁的学生，然后再进行统计，中间表必须与student关联才能得到12岁以下学生和把该学生记录从中间表中剔除，代码是：<br>select tea_stu.teaid,count(*) total from student,tea_stu<br>where student.stuid=tea_stu.stuid and student.age&gt;12 group by tea_stu.teaid</p><p>3.接着把上面的结果做成虚表与teacher进行关联，并筛除大于45的老师<br>select teacher.teaid,teacher.name,total from teacher ,(select tea_stu.tea<br>id,count(*) total from student,tea_stu where student.stuid=tea_stu.stuid and stu<br>dent.age&gt;12 group by tea_stu.teaid) as tea_stu2 where teacher.teaid=tea_stu2.tea<br>id and teacher.age&lt;45;</p><h1 id="求出发帖最多的人："><a href="#求出发帖最多的人：" class="headerlink" title="求出发帖最多的人："></a>求出发帖最多的人：</h1><p>select authorid,count(<em>) total from articles<br>group by authorid<br>having total=<br>(select max(total2) from (select count(</em>) total2 from articles group by authorid) as t);</p><p>select t.authorid,max(t.total) from<br>（select authorid,count(*) total from articles ）as t<br>这条语句不行，因为max只有一列，不能与其他列混淆。</p><p>select authorid,count(*) total from articles<br>group by authorid having total=max(total)也不行。</p><h1 id="一个用户表中有一个积分字段，假如数据库中有100多万个用户，若要在每年第一天凌晨将积分清零，你将考虑什么，你将想什么办法解决"><a href="#一个用户表中有一个积分字段，假如数据库中有100多万个用户，若要在每年第一天凌晨将积分清零，你将考虑什么，你将想什么办法解决" class="headerlink" title="一个用户表中有一个积分字段，假如数据库中有100多万个用户，若要在每年第一天凌晨将积分清零，你将考虑什么，你将想什么办法解决?"></a>一个用户表中有一个积分字段，假如数据库中有100多万个用户，若要在每年第一天凌晨将积分清零，你将考虑什么，你将想什么办法解决?</h1><p>alter table drop column score;<br>alter table add colunm score int;<br>可能会很快，但是需要试验，试验不能拿真实的环境来操刀，并且要注意，<br>这样的操作时无法回滚的，在我的印象中，只有inert update delete等DML语句才能回滚，<br>对于create table,drop table ,alter table等DDL语句是不能回滚。</p><p>解决方案一，update user set score=0;<br>解决方案二，假设上面的代码要执行好长时间，超出我们的容忍范围，那我就alter table user drop column score;alter table user add column score int。</p><p>下面代码实现每年的那个凌晨时刻进行清零。<br>Runnable runnable =<br>new Runnable(){<br>public void run(){<br>clearDb();<br>schedule(this,new Date(new Date().getYear()+1,0,0));<br>}<br>};</p><p>schedule(runnable,<br>new Date(new Date().getYear()+1,0,1));</p><h1 id="一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。"><a href="#一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。" class="headerlink" title="一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。"></a>一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。</h1><p>select count(*) as num,tb.id<br>from<br>tb,<br>(select role from tb where id=xxx) as t1<br>where<br>tb.role = t1.role and tb.id != t1.id<br>group by tb.id<br>having<br>num = select count(role) from tb where id=xxx;</p><h1 id="xxx公司的sql面试"><a href="#xxx公司的sql面试" class="headerlink" title="xxx公司的sql面试"></a>xxx公司的sql面试</h1><p>Table EMPLOYEES Structure:<br>EMPLOYEE_ID NUMBER Primary Key,<br>FIRST_NAME VARCHAR2(25),<br>LAST_NAME VARCHAR2(25),<br>Salary number(8,2),<br>HiredDate DATE,<br>Departmentid number(2)<br>Table Departments Structure:<br>Departmentid number(2) Primary Key,<br>DepartmentName VARCHAR2(25).</p><p>(2）基于上述EMPLOYEES表写出查询：写出雇用日期在今年的，或者工资在[1000,2000]之间的，或者员工姓名（last_name）以’Obama’打头的所有员工，列出这些员工的全部个人信息。（4分）<br>select * from employees<br>where Year(hiredDate) = Year(date())<br>or (salary between 1000 and 200)<br>or left(last_name,3)=’abc’;</p><p>(3) 基于上述EMPLOYEES表写出查询：查出部门平均工资大于1800元的部门的所有员工，列出这些员工的全部个人信息。（4分）<br>mysql&gt; select id,name,salary,deptid did from employee1 where (select avg(salary)<br>from employee1 where deptid = did) &gt; 1800;</p><p>(4) 基于上述EMPLOYEES表写出查询：查出个人工资高于其所在部门平均工资的员工，列出这些员工的全部个人信息及该员工工资高出部门平均工资百分比。（5分）<br>select employee1.*,(employee1.salary-t.avgSalary)*100/employee1.salary<br>from employee1,<br>(select deptid,avg(salary) avgSalary from employee1 group by deptid) as t<br>where employee1.deptid = t.deptid and employee1.salary&gt;t.avgSalary;</p><h1 id="oracle中除了数据库备份，还有什么方法备份？"><a href="#oracle中除了数据库备份，还有什么方法备份？" class="headerlink" title="oracle中除了数据库备份，还有什么方法备份？"></a>oracle中除了数据库备份，还有什么方法备份？</h1><p>Oracle数据库有三种标准的备份方法，它们分别是导出/导入(EXP/IMP)、热备份和冷备份。导出备份是一种逻辑备份，冷备份和热备份是物理备份。</p><h1 id="truncate与delete的区别？（delete-from-table和truncate-table-tablea的区别！）"><a href="#truncate与delete的区别？（delete-from-table和truncate-table-tablea的区别！）" class="headerlink" title="truncate与delete的区别？（delete from table和truncate table tablea的区别！）"></a>truncate与delete的区别？（delete from table和truncate table tablea的区别！）</h1><p>truncate是DDL語言.delete是DML語言 DDL語言是自動提交的.命令完成就不可回滾.truncate的速度也比delete要快得多.<br>详细说明：<br>相同点:truncate和不带where子句的delete, 以及drop都会删除表内的数据<br>不同点:</p><ol><li>truncate和 delete只删除数据不删除表的结构(定义)<br>drop语句将删除表的结构被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程/函数将保留,但是变为invalid状态.</li><li>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.<br>truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</li><li>delete语句不影响表所占用的extent, 高水线(high watermark)保持原位置不动<br>显然drop语句将表所占用的空间全部释放<br>truncate 语句缺省情况下见空间释放到 minextents个 extent,除非使用reuse storage; truncate会将高水线复位(回到最开始).</li><li>速度,一般来说: drop&gt; truncate &gt; delete</li><li>安全性:小心使用drop 和truncate,尤其没有备份的时候.否则哭都来不及<br>使用上,想删除部分数据行用delete,注意带上where子句. 回滚段要足够大.<br>想删除表,当然用drop<br>想保留表而将所有数据删除. 如果和事务无关,用truncate即可. 如果和事务有关,或者想触发trigger,还是用delete.</li></ol><h1 id="Oracle冷备份的通常步骤"><a href="#Oracle冷备份的通常步骤" class="headerlink" title="Oracle冷备份的通常步骤"></a>Oracle冷备份的通常步骤</h1><p>1 正常关闭数据库 2 备份所有重要的文件到备份目录（数据文件、控制文件、重做日志文件等）<br>3 完成备份后启动数据库用冷备份进行恢复时，只需要将所有文件恢复到原有位置，就可以启动数据库了<br>4关闭数据库 SQL&gt;shutdown 5 备份文件到备份的目录 6 然后启动数据库 ＃sqlplus “/as sysdba”SQL&gt;startup 冷备份完毕！！</p><h1 id="对数据库的访问是怎么实现的"><a href="#对数据库的访问是怎么实现的" class="headerlink" title="对数据库的访问是怎么实现的"></a>对数据库的访问是怎么实现的</h1><p>将对持久层数据库的基本添加，修改，查找等操作提取到BaseDAO中,采用JavaBean对数据进行封装，以便对持久层的数据能够很好的处理，实现BaseDAO设计对数据库访问的便捷。业务组件通过DAO 的委托接口调用DAO对象，使得上层组件不 直接依赖于DAO的实现类.</p><h1 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h1><p>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。<br>接 口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有 程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。 然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到 接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p><h1 id="数据库优化的方案"><a href="#数据库优化的方案" class="headerlink" title="数据库优化的方案"></a>数据库优化的方案</h1><pre><code>建立主键，为数据库创建索引，建立存储过程，触发器，可提高查询速度。
</code></pre><p>1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，<br>再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？<br>(1)如果表的类型是 MyISAM，那么是 18<br>因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大<br>ID 也不会丢失<br>（2）如果表的类型是 InnoDB，那么是 15<br>InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进行<br>OPTIMIZE 操作，都会导致最大 ID 丢失<br>2、Mysql 的技术特点是什么？<br>Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多<br>线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。<br>3、Heap 表是什么？<br>HEAP 表存在于内存中，用于临时高速存储。<br>BLOB 或 TEXT 字段是不允许的<br>只能使用比较运算符=，&lt;，&gt;，=&gt;，= &lt;<br>HEAP 表不支持 AUTO_INCREMENT<br>索引不可为 NULL<br>4、Mysql 服务器默认端口是什么？<br>Mysql 服务器的默认端口是 3306。<br>5、与 Oracle 相比，Mysql 有什么优势？<br>Mysql 是开源软件，随时可用，无需付费。<br>Mysql 是便携式的<br>带有命令提示符的 GUI。<br>使用 Mysql 查询浏览器支持管理<br>6、如何区分 FLOAT 和 DOUBLE？<br>以下是 FLOAT 和 DOUBLE 的区别：<br>浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。<br>浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。<br>7、区分 CHAR_LENGTH 和 LENGTH？<br>CHAR_LENGTH 是字符数，而 LENGTH 是字节数。Latin 字符的这两个数据是相同的，但是对<br>于 Unicode 和其他编码，它们是不同的。<br>8、请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？<br>SQL 标准定义的四个隔离级别为：<br>read uncommited ：读到未提交数据<br>read committed：脏读，不可重复读<br>repeatable read：可重读<br>serializable ：串行事物<br>9、在 Mysql 中 ENUM 的用法是什么？<br>ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。<br>Create table size(name ENUM(‘Smail,’Medium’,’Large’);<br>10、如何定义 REGEXP？<br>REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置。<br>11、CHAR 和 VARCHAR 的区别？<br>以下是 CHAR 和 VARCHAR 的区别：<br>CHAR 和 VARCHAR 类型在存储和检索方面有所不同<br>CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255<br>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。<br>12、列的字符串类型可以是什么？<br>字符串类型是：<br>SET<br>BLOB<br>ENUM<br>CHAR<br>TEXT<br>VARCHAR<br>13、如何获取当前的 Mysql 版本？<br>SELECT VERSION();用于获取当前 Mysql 的版本。<br>14、Mysql 中使用什么存储引擎？<br>存储引擎称为表类型，数据使用各种技术存储在文件中。<br>技术涉及：<br>Storage mechanism<br>Locking levels<br>Indexing<br>Capabilities and functions.<br>15、Mysql 驱动程序是什么？<br>以下是 Mysql 中可用的驱动程序：<br>PHP 驱动程序<br>JDBC 驱动程序<br>ODBC 驱动程序<br>CWRAPPER PYTHON<br>驱动程序 PERL 驱动<br>程序 RUBY 驱动程<br>序 CAP11PHP 驱动<br>程序<br>Ado.net5.mxj<br>16、TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？<br>创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE<br>CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。<br>17、主键和候选键有什么区别？<br>表格的每一行都由主键唯一标识,一个表只有一个主键。<br>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。<br>18、如何使用 Unix shell 登录 Mysql？<br>我们可以通过以下命令登录：<br>[mysql dir]/bin/mysql -h hostname -u<br>19、 myisamchk 是用来做什么的？<br>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。<br>20、MYSQL 数据库服务器性能分析的方法命令有哪些?<br>21、如何控制 HEAP 表的最大尺寸？<br>Heal 表的大小可通过称为 max_heap_table_size 的 Mysql 配置变量来控制。<br>22、MyISAM Static 和 MyISAM Dynamic 有什么区别？<br>在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB 等字<br>段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。<br>MyISAM Static 在受损情况下更容易恢复。<br>23、federated 表是什么？<br>federated 表，允许访问位于其他服务器数据库上的表。<br>24、如果一个表有一列定义为 TIMESTAMP，将发生什么？<br>每当行被更改时，时间戳字段将获取当前时间戳。<br>25、列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？<br>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。<br>26、怎样才能找出最后一次插入时分配了哪个自动增量？<br>LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。<br>27、你怎么看到为表格定义的所有索引？<br>索引是通过以下方式为表格定义的：<br>SHOW INDEX FROM<br>28.、LIKE 声明中的％和_是什么意思？<br>％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。<br>29、如何在 Unix 和 Mysql 时间戳之间进行转换？<br>UNIX_TIMESTAMP 是从 Mysql 时间戳转换为 Unix 时间戳的命令<br>FROM_UNIXTIME 是从 Unix 时间戳转换为 Mysql 时间戳的命令<br>30、列对比运算符是什么？<br>在 SELECT 语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR 或 LIKE 运<br>算符。<br>31、我们如何得到受查询影响的行数？<br>行数可以通过以下代码获得：<br>SELECT COUNT(user_id)FROM users;<br>32、Mysql 查询是否区分大小写？<br>不区分<br>SELECT VERSION(), CURRENT_DATE;<br>SeLect version(), current_date;<br>seleCt vErSiOn(), current_DATE;<br>所有这些例子都是一样的，Mysql 不区分大小写。<br>33.、LIKE 和 REGEXP 操作有什么区别？<br>LIKE 和 REGEXP 运算符用于表示^和％。<br>SELECT * FROM employee WHERE emp_name REGEXP “^b”;<br>SELECT * FROM employee WHERE emp_name LIKE “%b”;<br>34.、BLOB 和 TEXT 有什么区别？<br>BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB -<br>TINYBLOB<br>BLOB<br>MEDIUMBLOB 和 LONGBLOB 它们只能在所能容纳<br>价值的最大长度上有所不同。<br>TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型<br>TINYTEXT<br>TEXT<br>MEDIUMTEXT 和<br>LONGTEXT<br>它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。<br>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT<br>值不区分大小写。<br>35、mysql_fetch_array 和 mysql_fetch_object 的区别是什么？<br>以下是 mysql_fetch_array 和 mysql_fetch_object 的区别：<br>mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。<br>mysql_fetch_object - 从数据库返回结果行作为对象。<br>36、我们如何在 mysql 中运行批处理模式？<br>以下命令用于在批处理模式下运行：<br>mysql;<br>mysql mysql.out<br>37、MyISAM 表格将在哪里存储，并且还提供其存储格式？<br>每个 MyISAM 表格以三种格式存储在磁盘上：<br>·“.frm”文件存储表定义<br>·数据文件具有“.MYD”（MYData）扩展名<br>索引文件具有“.MYI”（MYIndex）扩展名<br>38.、Mysql 中有哪些不同的表格？<br>共有 5 种类型的表格：<br>MyISAM<br>Heap<br>Merge<br>INNODB<br>ISAM<br>MyISAM 是 Mysql 的默认存储引擎。<br>39、ISAM 是什么？<br>ISAM 简称为索引顺序访问方法。它是由 IBM 开发的，用于在磁带等辅助存储系统上存储和<br>检索数据。<br>40、InnoDB 是什么？<br>lnnoDB 是一个由 Oracle 公司开发的 Innobase Oy 事务安全存储引擎。<br>41、Mysql 如何优化 DISTINCT？<br>DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。<br>1<br>SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;<br>42、如何输入字符为十六进制数字？<br>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者<br>只用（Ox）前缀输入十六进制数字。<br>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。<br>43、如何显示前 50 行？<br>在 Mysql 中，使用以下代码查询显示前 50 行：<br>SELECT*FROM<br>LIMIT 0,50;<br>44、可以使用多少列创建索引？<br>任何标准表最多可以创建 16 个索引列。<br>45、NOW（）和 CURRENT_DATE（）有什么区别？<br>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。<br>CURRENT_DATE（）仅显示当前年份，月份和日期。<br>46、什么样的对象可以使用 CREATE 语句创建？<br>以下对象是使用 CREATE 语句创建的：<br>DATABASE<br>EVENT<br>FUNCTION<br>INDEX<br>PROCEDURE<br>TABLE<br>TRIGGER<br>USER<br>VIEW<br>47、Mysql 表中允许有多少个 TRIGGERS？<br>在 Mysql 表中允许有六个触发器，如下：<br>BEFORE INSERT<br>AFTER INSERT<br>BEFORE UPDATE<br>AFTER UPDATE<br>BEFORE DELETE<br>AFTER DELETE<br>48、什么是非标准字符串类型？<br>以下是非标准字符串类型：<br>TINYTEXT<br>TEXT<br>MEDIUMTEXT<br>LONGTEXT<br>49、什么是通用 SQL 函数？<br>CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合<br>并为一个字段。<br>FORMAT(X, D)- 格式化数字 X 到 D 有效数字。<br>CURRDATE(), CURRTIME()- 返回当前日期或时间。<br>NOW（） - 将当前日期和时间作为一个值返回。<br>MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。<br>HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。<br>DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄<br>SUBTIMES（A，B） - 确定两次之间的差异。<br>FROMDAYS（INT） - 将整数天数转换为日期值。<br>50、解释访问控制列表<br>ACL（访问控制列表）是与对象关联的权限列表。这个列表是 Mysql 服务器安全模型的基<br>础，它有助于排除用户无法连接的问题。<br>Mysql 将 ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql 会按<br>照预定的顺序检查 ACL 的认证信息和权限。<br>51、MYSQL 支持事务吗？<br>在缺省模式下，MYSQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，所<br>以在缺省情况下，mysql 是不支持事务的。<br>但是如果你的 MYSQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的 MYSQL 就可以<br>使用事务处理,使用 SET AUTOCOMMIT=0 就可以使 MYSQL 允许在非 autocommit 模式，在非<br>autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK 来回滚你的<br>更改。<br>示例如下：<br>一<br>START TRANSACTION;<br>SELECT @A:=SUM(salary) FROM table1 WHERE type=1;<br>UPDATE table2 SET summmary=@A WHERE type=1;<br>COMMIT;<br>52、mysql 里记录货币用什么字段类型好<br>NUMERIC 和 DECIMAL 类型被 Mysql 实现为同样的类型，这在 SQL92 标准允许。他们被用于<br>保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些<br>类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总<br>结。<br>例如：<br>salary DECIMAL(9,2)<br>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于<br>存储小数点后的位数。<br>因此，在这种情况下，能被存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。<br>在 ANSI/ISO SQL92 中，句法 DECIMAL(p)等价于 DECIMAL(p,0)。<br>同样，句法 DECIMAL 等价于 DECIMAL(p,0)，这里实现被允许决定值 p。Mysql 当前不支持<br>DECIMAL/NUMERIC 数据类型的这些变种形式的任一种。<br>这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模<br>的能力。<br>DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小<br>数精度。<br>一个字符用于值的每一位、小数点(如果 scale&gt;0)和“-”符号(对于负值)。如果 scale 是 0，<br>DECIMAL 和 NUMERIC 值不包含小数点或小数部分。<br>DECIMAL 和 NUMERIC 值得最大的范围与 DOUBLE 一样，但是对于一个给定的 DECIMAL 或<br>NUMERIC 列，实际的范围可由制由给定列的 precision 或 scale 限制。<br>当这样的列赋给了小数点后面的位超过指定 scale 所允许的位的值，该值根据 scale 四舍五<br>入。<br>当一个 DECIMAL 或 NUMERIC 列被赋给了其大小超过指定(或缺省的）precision 和 scale 隐含<br>的范围的值，Mysql 存储表示那个范围的相应的端点值。<br>我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担<br>心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点<br>也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困<br>境的第一步。<br>53、MYSQL 数据表在什么情况下容易损坏？<br>服务器突然断电导致数据文件损坏。<br>强制关机，没有先关闭 mysql 服务等。<br>54、mysql 有关权限的表都有哪几个？<br>Mysql 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由<br>mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和<br>host。<br>55、Mysql 中有哪几种锁？<br>MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁<br>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量<br>最低<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高<br>最后，欢迎做 Java 的工程师朋友们加入 Java 高级架构进阶 Qqun：963944895<br>群内有技术大咖指点难题，还提供免费的 Java 架构学习资料（里面有高可用、高并发、高性能及分布式、<br>Jvm 性能调优、Spring 源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx 等多个<br>知识点的架构资料）<br>比你优秀的对手在学习，你的仇人在磨刀，你的闺蜜在减肥，隔壁老王在练腰， 我们必须不断学习，否则我<br>们将被学习者超越！<br>趁年轻，使劲拼，给未来的自己一个交代！</p><p>1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，<br>删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记<br>录，这条记录的 ID 是 18 还是 15 ？<br>答<br>(1)如果表的类型是MylSAM，那么是18因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失(2)如果表的类型是InnoDB，那么是15InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。<br>2、Mysql 的技术特点是什么？<br>Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多<br>线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。<br>3、Heap 表是什么？<br>HEAP 表存在于内存中，用于临时高速存储。<br> BLOB 或 TEXT 字段是不允许的<br> 只能使用比较运算符=，&lt;，&gt;，=&gt;，= &lt;<br> HEAP 表不支持 AUTO_INCREMENT<br> 索引不可为 NULL<br>4、Mysql 服务器默认端口是什么？<br>Mysql 服务器的默认端口是 3306。<br>5、与 Oracle 相比，Mysql 有什么优势？<br> Mysql 是开源软件，随时可用，无需付费。<br> Mysql 是便携式的<br> 带有命令提示符的 GUI。<br> 使用 Mysql 查询浏览器支持管理<br>6、如何区分 FLOAT 和 DOUBLE？<br>以下是 FLOAT 和 DOUBLE 的区别：<br>浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。<br>浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。<br>7、区分 CHAR_LENGTH 和 LENGTH？<br>CHAR_LENGTH 是字符数，而 LENGTH 是字节数。Latin 字符的这两个数据是相同的，<br>但是对于 Unicode 和其他编码，它们是不同的。<br>8、请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名<br>称，以及逐级之间的区别？<br>SQL 标准定义的四个隔离级别为：<br>read uncommited ：读到未提交数据<br>read committed：脏读，不可重复读<br>repeatable read：可重读<br>serializable ：串行事物<br>9、在 Mysql 中 ENUM 的用法是什么？<br>ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。<br>Create table size(name ENUM(‘Smail,’Medium’,’Large’);<br>10、如何定义 REGEXP？<br>REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置。<br>11、CHAR 和 VARCHAR 的区别？<br>以下是 CHAR 和 VARCHAR 的区别：<br> CHAR 和 VARCHAR 类型在存储和检索方面有所不同<br> CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255<br>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。<br>12、列的字符串类型可以是什么？<br>字符串类型是：<br> SET<br> BLOB<br> ENUM<br> CHAR<br> TEXT<br> VARCHAR<br>13、如何获取当前的 Mysql 版本？<br>SELECT VERSION();用于获取当前 Mysql 的版本。<br>14、Mysql 中使用什么存储引擎？<br>存储引擎称为表类型，数据使用各种技术存储在文件中。<br>技术涉及：<br> Storage mechanism<br> Locking levels<br> Indexing<br> Capabilities and functions. 15、Mysql 驱动程序是什么？<br>以下是 Mysql 中可用的驱动程序：<br> PHP 驱动程序<br> JDBC 驱动程序<br> ODBC 驱动程序<br> CWRAPPER<br> PYTHON 驱动程序<br> PERL 驱动程序<br> RUBY 驱动程序<br> CAP11PHP 驱动程序<br> Ado.net5.mxj<br>16、TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据<br>类型上做什么？<br>创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE<br>CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。<br>17、主键和候选键有什么区别？<br>表格的每一行都由主键唯一标识,一个表只有一个主键。<br>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。<br>18、如何使用 Unix shell 登录 Mysql？<br>我们可以通过以下命令登录：</p><h1 id="mysql-dir-bin-mysql-h-hostname-u-p"><a href="#mysql-dir-bin-mysql-h-hostname-u-p" class="headerlink" title="[mysql dir]/bin/mysql -h hostname -u  -p "></a>[mysql dir]/bin/mysql -h hostname -u<username>-p<password></password></username></h1><p>19、 myisamchk 是用来做什么的？<br>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。<br>20、MYSQL 数据库服务器性能分析的方法命令有哪些?<br>Show status<br>·一些值得监控的变量值:<br>Bytes_received和Bytes sent·和服务器之间来往的流量。·Com_服务器正在执行的命令<br>·Created*在查询执行期限间创建的临时表和文件。<br>·Handler_*存储引擎操作。<br>·Select_*不同类型的联接执行计划。<br>·Sort_<em>几种排序信息。<br>Show session status like ‘Select;<br>Show profilesSET profiling=1;Show profileslGShow profile;<br>21、如何控制 HEAP 表的最大尺寸？<br>Heal 表的大小可通过称为 max_heap_table_size 的 Mysql 配置变量来控制。<br>22、MyISAM Static 和 MyISAM Dynamic 有什么区别？<br>在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB<br>等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。<br>MyISAM Static 在受损情况下更容易恢复。<br>23、federated 表是什么？<br>federated 表，允许访问位于其他服务器数据库上的表。<br>24、如果一个表有一列定义为 TIMESTAMP，将发生什么？<br>每当行被更改时，时间戳字段将获取当前时间戳。<br>25、列设置为 AUTO INCREMENT 时，如果在表中达到最大<br>值，会发生什么情况？<br>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。<br>26、怎样才能找出最后一次插入时分配了哪个自动增量？<br>LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名<br>称。<br>27、你怎么看到为表格定义的所有索引？<br>索引是通过以下方式为表格定义的：<br>SHOW INDEX FROM<tablename>;<br>28.、LIKE 声明中的％和_是什么意思？<br>％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。<br>29、如何在 Unix 和 Mysql 时间戳之间进行转换？<br>UNIX_TIMESTAMP 是从 Mysql 时间戳转换为 Unix 时间戳的命令<br>FROM_UNIXTIME 是从 Unix 时间戳转换为 Mysql 时间戳的命令<br>30、列对比运算符是什么？<br>在 SELECT 语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR 或<br>LIKE 运算符。<br>31、我们如何得到受查询影响的行数？<br>行数可以通过以下代码获得：<br>SELECT COUNT(user_id)FROM users;<br>32、Mysql 查询是否区分大小写？<br>不区分<br>SELECT VERSION(), CURRENT_DATE;<br>SeLect version(), current_date;<br>seleCt vErSiOn(), current_DATE;<br>所有这些例子都是一样的，Mysql 不区分大小写。<br>33.、LIKE 和 REGEXP 操作有什么区别？<br>LIKE 和 REGEXP 运算符用于表示^和％。<br>SELECT * FROM employee WHERE emp_name REGEXP “^b”;<br>SELECT * FROM employee WHERE emp_name LIKE “%b”;<br>34.、BLOB 和 TEXT 有什么区别？<br>BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB -  TINYBLOB<br> BLOB<br> MEDIUMBLOB<br> LONGBLOB<br>它们只能在所能容纳价值的最大长度上有所不同。<br>TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型<br> TINYTEXT<br> TEXT<br> MEDIUMTEXT<br> LONGTEXT<br>它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。<br>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对<br>TEXT 值不区分大小写。<br>35、mysql_fetch_array 和 mysql_fetch_object 的区别是什么？<br>以下是 mysql_fetch_array 和 mysql_fetch_object 的区别：<br>mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。<br>mysql_fetch_object - 从数据库返回结果行作为对象。<br>36、我们如何在 mysql 中运行批处理模式？<br>以下命令用于在批处理模式下运行：<br>mysql;<br>mysql mysql.out<br>37、MyISAM 表格将在哪里存储，并且还提供其存储格式？<br>每个 MyISAM 表格以三种格式存储在磁盘上：<br>·“.frm”文件存储表定义<br>·数据文件具有“.MYD”（MYData）扩展名<br>索引文件具有“.MYI”（MYIndex）扩展名<br>38.、Mysql 中有哪些不同的表格？<br>共有 5 种类型的表格：<br> MyISAM<br> Heap<br> Merge<br> INNODB<br> ISAM<br>MyISAM 是 Mysql 的默认存储引擎。<br>39、ISAM 是什么？<br>ISAM 简称为索引顺序访问方法。它是由 IBM 开发的，用于在磁带等辅助存储系统上存储<br>和检索数据。<br>40、InnoDB 是什么？<br>lnnoDB 是一个由 Oracle 公司开发的 Innobase Oy 事务安全存储引擎。<br>41、Mysql 如何优化 DISTINCT？<br>DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。<br>SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;<br>42、如何输入字符为十六进制数字？<br>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者<br>只用（Ox）前缀输入十六进制数字。<br>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。<br>43、如何显示前 50 行？<br>在 Mysql 中，使用以下代码查询显示前 50 行：<br>SELECT</tablename></em>FROM<br>LIMIT 0,50;<br>44、可以使用多少列创建索引？<br>任何标准表最多可以创建 16 个索引列。<br>45、NOW（）和 CURRENT_DATE（）有什么区别？<br>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。<br>CURRENT_DATE（）仅显示当前年份，月份和日期。<br>46、什么样的对象可以使用 CREATE 语句创建？<br>以下对象是使用 CREATE 语句创建的：<br> DATABASE<br> EVENT<br> FUNCTION<br> INDEX<br> PROCEDURE<br> TABLE<br> TRIGGER<br> USER<br> VIEW<br>47、Mysql 表中允许有多少个 TRIGGERS？<br>在 Mysql 表中允许有六个触发器，如下：<br> BEFORE INSERT<br> AFTER INSERT<br> BEFORE UPDATE<br> AFTER UPDATE<br> BEFORE DELETE<br> AFTER DELETE<br>48、什么是非标准字符串类型？<br>以下是非标准字符串类型：<br> TINYTEXT<br> TEXT<br> MEDIUMTEXT<br> LONGTEXT<br>49、什么是通用 SQL 函数？<br> CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个<br>字段合并为一个字段。<br> FORMAT(X, D)- 格式化数字 X 到 D 有效数字。<br> CURRDATE(), CURRTIME()- 返回当前日期或时间。<br> NOW（） - 将当前日期和时间作为一个值返回。<br> MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中<br>提取给定数据。<br> HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。<br> DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄<br> SUBTIMES（A，B） - 确定两次之间的差异。<br> FROMDAYS（INT） - 将整数天数转换为日期值。<br>50、解释访问控制列表<br>ACL（访问控制列表）是与对象关联的权限列表。这个列表是 Mysql 服务器安全模型的基<br>础，它有助于排除用户无法连接的问题。<br>Mysql 将 ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql 会<br>按照预定的顺序检查 ACL 的认证信息和权限。<br>51、MYSQL 支持事务吗？<br>在缺省模式下，MYSQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，<br>所以在缺省情况下，mysql 是不支持事务的。<br>但是如果你的 MYSQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的 MYSQL<br>就 可 以 使 用 事 务 处 理 , 使 用 SET AUTOCOMMIT=0 就 可 以 使 MYSQL 允 许 在 非<br>autocommit 模式，在非 autocommit 模式下，你必须使用 COMMIT 来提交你的更改，<br>或者用 ROLLBACK 来回滚你的更改。<br>示例如下：<br>START TRANSACTION;<br>SELECT @A:=SUM(salary) FROM table1 WHERE type=1;<br>UPDATE table2 SET summmary=@A WHERE type=1;<br>COMMIT;<br>52、 mysql 里记录货币用什么字段类型好<br>NUMERIC 和 DECIMAL 类型被 Mysql 实现为同样的类型，这在 SQL92 标准允许。他们<br>被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是<br>这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总<br>结。<br>例如：<br>salary DECIMAL(9,2)<br>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用<br>于存储小数点后的位数。<br>因 此 ， 在 这 种 情 况 下 ， 能 被 存 储 在 salary 列 中 的 值 的 范 围 是 从 -9999999.99 到<br>9999999.99。在 ANSI/ISO SQL92 中，句法 DECIMAL(p)等价于 DECIMAL(p,0)。<br>同样，句法 DECIMAL 等价于 DECIMAL(p,0)，这里实现被允许决定值 p。Mysql 当前不<br>支持 DECIMAL/NUMERIC 数据类型的这些变种形式的任一种。<br>这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的<br>能力。<br>DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值<br>的小数精度。<br>一个字符用于值的每一位、小数点(如果 scale&gt;0)和“-”符号(对于负值)。如果 scale 是 0，<br>DECIMAL 和 NUMERIC 值不包含小数点或小数部分。<br>DECIMAL 和 NUMERIC 值得最大的范围与 DOUBLE 一样，但是对于一个给定的<br>DECIMAL 或 NUMERIC 列，实际的范围可由制由给定列的 precision 或 scale 限制。<br>当这样的列赋给了小数点后面的位超过指定 scale 所允许的位的值，该值根据 scale 四舍五<br>入。<br>当一个 DECIMAL 或 NUMERIC 列被赋给了其大小超过指定(或缺省的）precision 和 scale<br>隐含的范围的值，Mysql 存储表示那个范围的相应的端点值。<br>53、MYSQL 数据表在什么情况下容易损坏？<br>服务器突然断电导致数据文件损坏。<br>强制关机，没有先关闭 mysql 服务等。<br>54、mysql 有关权限的表都有哪几个？<br>Mysql 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由<br>mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv<br>和 host。<br>55、Mysql 中有哪几种锁？<br>MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁<br>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最<br>低<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p><p>1.数据库三范式是什么?<br>1.第一范式（1NF）：字段具有原子性,不可再分。(所有关系型数据库系统都满足第一范式数据库表中的字段都是单一属性的，不可再分)<br>2.第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。<br>3.满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 &gt;所以第三范式具有如下特征： &gt;&gt;1. 每一列只有一个值 &gt;&gt;2. 每一行都能区分。 &gt;&gt;3. 每一个表都不包含其他表已经包含的非主关键字信息。<br>2.有哪些数据库优化方面的经验?<br>1.用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。<br>2.有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。<br>3.表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等<br>4.UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL。 &gt;&gt;UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。 &gt;1. 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。 &gt;2. 对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。<br>3.请简述常用的索引有哪些种类?<br>1.普通索引: 即针对数据库表创建索引<br>2.唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值<br>3.主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引<br>4.组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。<br>4.以及在mysql数据库中索引的工作机制是什么？<br>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树<br>5.MySQL的基础操作命令:<br>1.MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status<br>2.开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务<br>3.Shell 登入 MySQL: 运行命令 mysql -u root -p<br>4.列出所有数据库:运行命令 show databases;<br>5.切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库<br>6.列出某个数据库内所有表: show tables;<br>7.获取表内所有 Field 对象的名称和类型 :describe table_name;<br>6.mysql的复制原理以及流程。<br>Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的。 * 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。 当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。 过程如下 1. 主服务器把更新记录到二进制日志文件中。 2. 从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中。 3. 从服务器重做中继日志中的时间，把更新应用到自己的数据库上。<br>7.mysql支持的复制类型?<br>1.基于语句的复制： 在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。 一旦发现没法精确复制时，会自动选着基于行的复制。<br>2.基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持<br>3.混合类型的复制: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。<br>8.mysql中myisam与innodb的区别？<br>1.事务支持 &gt; MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 &gt; InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。<br>2.InnoDB支持行级锁，而MyISAM支持表级锁. &gt;&gt; 用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>3.InnoDB支持MVCC, 而MyISAM不支持<br>4.InnoDB支持外键，而MyISAM不支持<br>5.表主键 &gt; MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 &gt; InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。<br>6.InnoDB不支持全文索引，而MyISAM支持。<br>7.可移植性、备份及恢复 &gt; MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 &gt; InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了<br>8.存储结构 &gt; MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。 &gt; InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。<br>9.mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？<br>1.varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.<br>2.varchar(50)中50的涵义 : 最多存放50个字节<br>3.int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.<br>10.MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？<br>1.Read Uncommitted（读取未提交内容） &gt;&gt; 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>2.Read Committed（读取提交内容） &gt;&gt; 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>3.Repeatable Read（可重读） &gt;&gt; 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。<br>4.Serializable（可串行化） &gt;&gt; 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<table><thead><tr><th align="left">隔离级别</th><th align="left">脏读（Dirty Read）</th><th align="left">不可重复读（NonRepeatable Read）</th><th align="left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td align="left">未提交读（Read uncommitted）</td><td align="left">可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">已提交读（Read committed）</td><td align="left">不可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">可重复读（Repeatable read）</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">可能</td></tr><tr><td align="left">可串行化（SERIALIZABLE）</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">不可能</td></tr></tbody></table><br>11.表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？<br>如果字段里面有大字段（text,blob)类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了。 MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多。此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后，对字段的UPDAE就要UPDATE多个表了<br>12.MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？<br>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！<br>13.MySQL中控制内存分配的全局参数，有哪些？<br>1.Keybuffersize： &gt; * keybuffersize指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Keyreadrequests和Keyreads，可以知道keybuffersize设置是否合理。比例keyreads /keyreadrequests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘keyread%’获得）。 &gt; * keybuffersize只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值createdtmpdisktables得知详情。对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M） &gt; * keybuffersize设置注意事项 &gt;&gt;&gt;1. 单个keybuffer的大小不能超过4G，如果设置超过4G，就有可能遇到下面3个bug: &gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=29446">http://bugs.mysql.com/bug.php?id=29446</a><br>&gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=29419">http://bugs.mysql.com/bug.php?id=29419</a><br>&gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=5731">http://bugs.mysql.com/bug.php?id=5731</a><br>&gt;&gt;&gt;2. 建议keybuffer设置为物理内存的1/4(针对MyISAM引擎)，甚至是物理内存的30%~40%，如果keybuffersize设置太大，系统就会频繁的换页，降低系统性能。因为MySQL使用操作系统的缓存来缓存数据，所以我们得为系统留够足够的内存；在很多情况下数据要比索引大得多。 &gt;&gt;&gt;3. 如果机器性能优越，可以设置多个keybuffer,分别让不同的keybuffer来缓存专门的索引<br>2.innodbbufferpool_size &gt; 表示缓冲池字节大小，InnoDB缓存表和索引数据的内存区域。mysql默认的值是128M。最大值与你的CPU体系结构有关，在32位操作系统，最大值是 4294967295 (2^32-1) ，在64 位操作系统，最大值为18446744073709551615 (2^64-1)。 &gt; 在32位操作系统中，CPU和操作系统实用的最大大小低于设置的最大值。如果设定的缓冲池的大小大于1G，设置innodbbufferpoolinstances的值大于1. &gt; * 数据读写在内存中非常快, innodbbufferpoolsize 减少了对磁盘的读写。 当数据提交或满足检查点条件后才一次性将内存数据刷新到磁盘中。然而内存还有操作系统或数据库其他进程使用, 一般设置 buffer pool 大小为总内存的 3/4 至 4/5。 若设置不当, 内存使用可能浪费或者使用过多。 对于繁忙的服务器, buffer pool 将划分为多个实例以提高系统并发性, 减少线程间读写缓存的争用。buffer pool 的大小首先受 innodbbufferpool_instances 影响, 当然影响较小。<br>3.querycachesize &gt; 当mysql接收到一条select类型的query时，mysql会对这条query进行hash计算而得到一个hash值，然后通过该hash值到query cache中去匹配，如果没有匹配中，则将这个hash值存放在一个hash链表中，同时将query的结果集存放进cache中，存放hash值的链表的每一个hash节点存放了相应query结果集在cache中的地址，以及该query所涉及到的一些table的相关信息；如果通过hash值匹配到了一样的query，则直接将cache中相应的query结果集返回给客户端。如果mysql任何一个表中的任何一条数据发生了变化，便会通知query cache需要与该table相关的query的cache全部失效，并释放占用的内存地址。 &gt; query cache优缺点 &gt;&gt; 1. query语句的hash计算和hash查找带来的资源消耗。mysql会对每条接收到的select类型的query进行hash计算然后查找该query的cache是否存在，虽然hash计算和查找的效率已经足够高了，一条query所带来的消耗可以忽略，但一旦涉及到高并发，有成千上万条query时，hash计算和查找所带来的开销就的重视了； &gt;&gt; 2. query cache的失效问题。如果表变更比较频繁，则会造成query cache的失效率非常高。表变更不仅仅指表中的数据发生变化，还包括结构或者索引的任何变化； &gt;&gt; 3. 对于不同sql但同一结果集的query都会被缓存，这样便会造成内存资源的过渡消耗。sql的字符大小写、空格或者注释的不同，缓存都是认为是不同的sql（因为他们的hash值会不同）； &gt;&gt; 4. 相关参数设置不合理会造成大量内存碎片，相关的参数设置会稍后介绍。<br>4.readbuffersize &gt;是MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。readbuffersize变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。<br>14.若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?<br>由于utf8的每个字符最多占用3个字节。而MySQL定义行的长度不能超过65535，因此N的最大值计算方法为：(65535-1-2)/3。减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。<br>15. [SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?<br>1.前者要解析数据字典，后者不需要<br>2.结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。<br>3.表字段改名，前者不需要修改，后者需要改<br>4.后者可以建立索引进行优化，前者无法优化<br>5.后者的可读性比前者要高<br>16.HAVNG 子句 和 WHERE的异同点?<br>1.语法上：where 用表中列名，having用select结果别名<br>2.影响结果范围：where从表读出数据的行数，having返回客户端的行数<br>3.索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作<br>4.where后面不能使用聚集函数，having是专门使用聚集函数的。<br>17.MySQL当记录不存在时insert,当记录存在时update，语句怎么写？<br>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;<br>18.MySQL的insert和update的select语句语法<br><code>SQL insert into student (stuid,stuname,deptid) select 10,&#39;xzm&#39;,3 from student where stuid &gt; 8; update student a inner join student b on b.stuID=10 set a.stuname=concat(b.stuname, b.stuID) where a.stuID=10 ; </code></p><p>1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，<br>再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？<br>(1)如果表的类型是 MyISAM，那么是 18<br>因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大<br>ID 也不会丢失<br>（2）如果表的类型是 InnoDB，那么是 15<br>InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进行<br>OPTIMIZE 操作，都会导致最大 ID 丢失<br>2、Mysql 的技术特点是什么？<br>Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多<br>线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。<br>3、Heap 表是什么？<br>HEAP 表存在于内存中，用于临时高速存储。<br>BLOB 或 TEXT 字段是不允许的<br>只能使用比较运算符=，&lt;，&gt;，=&gt;，= &lt;<br>HEAP 表不支持 AUTO_INCREMENT<br>索引不可为 NULL<br>4、Mysql 服务器默认端口是什么？<br>Mysql 服务器的默认端口是 3306。<br>5、与 Oracle 相比，Mysql 有什么优势？<br>Mysql 是开源软件，随时可用，无需付费。<br>Mysql 是便携式的<br>带有命令提示符的 GUI。<br>使用 Mysql 查询浏览器支持管理<br>6、如何区分 FLOAT 和 DOUBLE？<br>以下是 FLOAT 和 DOUBLE 的区别：<br>浮点数以 8 位精度存储在 FLOAT 中，并且有四个字节。<br>浮点数存储在 DOUBLE 中，精度为 18 位，有八个字节。<br>7、区分 CHAR_LENGTH 和 LENGTH？<br>CHAR_LENGTH 是字符数，而 LENGTH 是字节数。Latin 字符的这两个数据是相同的，但是对<br>于 Unicode 和其他编码，它们是不同的。<br>8、请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？<br>SQL 标准定义的四个隔离级别为：<br>read uncommited ：读到未提交数据<br>read committed：脏读，不可重复读<br>repeatable read：可重读<br>serializable ：串行事物<br>9、在 Mysql 中 ENUM 的用法是什么？<br>ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。<br>Create table size(name ENUM(‘Smail,’Medium’,’Large’);<br>10、如何定义 REGEXP？<br>REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置。<br>11、CHAR 和 VARCHAR 的区别？<br>以下是 CHAR 和 VARCHAR 的区别：<br>CHAR 和 VARCHAR 类型在存储和检索方面有所不同<br>CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255<br>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。<br>12、列的字符串类型可以是什么？<br>字符串类型是：<br>SET<br>BLOB<br>ENUM<br>CHAR<br>TEXT<br>VARCHAR<br>13、如何获取当前的 Mysql 版本？<br>SELECT VERSION();用于获取当前 Mysql 的版本。<br>14、Mysql 中使用什么存储引擎？<br>存储引擎称为表类型，数据使用各种技术存储在文件中。<br>技术涉及：<br>Storage mechanism<br>Locking levels<br>Indexing<br>Capabilities and functions.<br>15、Mysql 驱动程序是什么？<br>以下是 Mysql 中可用的驱动程序：<br>PHP 驱动程序<br>JDBC 驱动程序<br>ODBC 驱动程序<br>CWRAPPER PYTHON<br>驱动程序 PERL 驱动<br>程序 RUBY 驱动程<br>序 CAP11PHP 驱动<br>程序<br>Ado.net5.mxj<br>16、TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？<br>创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE<br>CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。<br>17、主键和候选键有什么区别？<br>表格的每一行都由主键唯一标识,一个表只有一个主键。<br>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。<br>18、如何使用 Unix shell 登录 Mysql？<br>我们可以通过以下命令登录：<br>[mysql dir]/bin/mysql -h hostname -u<br>19、 myisamchk 是用来做什么的？<br>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。<br>20、MYSQL 数据库服务器性能分析的方法命令有哪些?<br>21、如何控制 HEAP 表的最大尺寸？<br>Heal 表的大小可通过称为 max_heap_table_size 的 Mysql 配置变量来控制。<br>22、MyISAM Static 和 MyISAM Dynamic 有什么区别？<br>在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB 等字<br>段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。<br>MyISAM Static 在受损情况下更容易恢复。<br>23、federated 表是什么？<br>federated 表，允许访问位于其他服务器数据库上的表。<br>24、如果一个表有一列定义为 TIMESTAMP，将发生什么？<br>每当行被更改时，时间戳字段将获取当前时间戳。<br>25、列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？<br>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。<br>26、怎样才能找出最后一次插入时分配了哪个自动增量？<br>LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。<br>27、你怎么看到为表格定义的所有索引？<br>索引是通过以下方式为表格定义的：<br>SHOW INDEX FROM<br>28.、LIKE 声明中的％和_是什么意思？<br>％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。<br>29、如何在 Unix 和 Mysql 时间戳之间进行转换？<br>UNIX_TIMESTAMP 是从 Mysql 时间戳转换为 Unix 时间戳的命令<br>FROM_UNIXTIME 是从 Unix 时间戳转换为 Mysql 时间戳的命令<br>30、列对比运算符是什么？<br>在 SELECT 语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR 或 LIKE 运<br>算符。<br>31、我们如何得到受查询影响的行数？<br>行数可以通过以下代码获得：<br>SELECT COUNT(user_id)FROM users;<br>32、Mysql 查询是否区分大小写？<br>不区分<br>SELECT VERSION(), CURRENT_DATE;<br>SeLect version(), current_date;<br>seleCt vErSiOn(), current_DATE;<br>所有这些例子都是一样的，Mysql 不区分大小写。<br>33.、LIKE 和 REGEXP 操作有什么区别？<br>LIKE 和 REGEXP 运算符用于表示^和％。<br>SELECT * FROM employee WHERE emp_name REGEXP “^b”;<br>SELECT * FROM employee WHERE emp_name LIKE “%b”;<br>34.、BLOB 和 TEXT 有什么区别？<br>BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB -<br>TINYBLOB<br>BLOB<br>MEDIUMBLOB 和 LONGBLOB 它们只能在所能容纳<br>价值的最大长度上有所不同。<br>TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型<br>TINYTEXT<br>TEXT<br>MEDIUMTEXT 和<br>LONGTEXT<br>它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。<br>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT<br>值不区分大小写。<br>35、mysql_fetch_array 和 mysql_fetch_object 的区别是什么？<br>以下是 mysql_fetch_array 和 mysql_fetch_object 的区别：<br>mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。<br>mysql_fetch_object - 从数据库返回结果行作为对象。<br>36、我们如何在 mysql 中运行批处理模式？<br>以下命令用于在批处理模式下运行：<br>mysql;<br>mysql mysql.out<br>37、MyISAM 表格将在哪里存储，并且还提供其存储格式？<br>每个 MyISAM 表格以三种格式存储在磁盘上：<br>·“.frm”文件存储表定义<br>·数据文件具有“.MYD”（MYData）扩展名<br>索引文件具有“.MYI”（MYIndex）扩展名<br>38.、Mysql 中有哪些不同的表格？<br>共有 5 种类型的表格：<br>MyISAM<br>Heap<br>Merge<br>INNODB<br>ISAM<br>MyISAM 是 Mysql 的默认存储引擎。<br>39、ISAM 是什么？<br>ISAM 简称为索引顺序访问方法。它是由 IBM 开发的，用于在磁带等辅助存储系统上存储和<br>检索数据。<br>40、InnoDB 是什么？<br>lnnoDB 是一个由 Oracle 公司开发的 Innobase Oy 事务安全存储引擎。<br>41、Mysql 如何优化 DISTINCT？<br>DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。<br>1<br>SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;<br>42、如何输入字符为十六进制数字？<br>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者<br>只用（Ox）前缀输入十六进制数字。<br>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。<br>43、如何显示前 50 行？<br>在 Mysql 中，使用以下代码查询显示前 50 行：<br>SELECT*FROM<br>LIMIT 0,50;<br>44、可以使用多少列创建索引？<br>任何标准表最多可以创建 16 个索引列。<br>45、NOW（）和 CURRENT_DATE（）有什么区别？<br>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。<br>CURRENT_DATE（）仅显示当前年份，月份和日期。<br>46、什么样的对象可以使用 CREATE 语句创建？<br>以下对象是使用 CREATE 语句创建的：<br>DATABASE<br>EVENT<br>FUNCTION<br>INDEX<br>PROCEDURE<br>TABLE<br>TRIGGER<br>USER<br>VIEW<br>47、Mysql 表中允许有多少个 TRIGGERS？<br>在 Mysql 表中允许有六个触发器，如下：<br>BEFORE INSERT<br>AFTER INSERT<br>BEFORE UPDATE<br>AFTER UPDATE<br>BEFORE DELETE<br>AFTER DELETE<br>48、什么是非标准字符串类型？<br>以下是非标准字符串类型：<br>TINYTEXT<br>TEXT<br>MEDIUMTEXT<br>LONGTEXT<br>49、什么是通用 SQL 函数？<br>CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合<br>并为一个字段。<br>FORMAT(X, D)- 格式化数字 X 到 D 有效数字。<br>CURRDATE(), CURRTIME()- 返回当前日期或时间。<br>NOW（） - 将当前日期和时间作为一个值返回。<br>MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。<br>HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。<br>DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄<br>SUBTIMES（A，B） - 确定两次之间的差异。<br>FROMDAYS（INT） - 将整数天数转换为日期值。<br>50、解释访问控制列表<br>ACL（访问控制列表）是与对象关联的权限列表。这个列表是 Mysql 服务器安全模型的基<br>础，它有助于排除用户无法连接的问题。<br>Mysql 将 ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql 会按<br>照预定的顺序检查 ACL 的认证信息和权限。<br>51、MYSQL 支持事务吗？<br>在缺省模式下，MYSQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，所<br>以在缺省情况下，mysql 是不支持事务的。<br>但是如果你的 MYSQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的 MYSQL 就可以<br>使用事务处理,使用 SET AUTOCOMMIT=0 就可以使 MYSQL 允许在非 autocommit 模式，在非<br>autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK 来回滚你的<br>更改。<br>示例如下：<br>一<br>START TRANSACTION;<br>SELECT @A:=SUM(salary) FROM table1 WHERE type=1;<br>UPDATE table2 SET summmary=@A WHERE type=1;<br>COMMIT;<br>52、mysql 里记录货币用什么字段类型好<br>NUMERIC 和 DECIMAL 类型被 Mysql 实现为同样的类型，这在 SQL92 标准允许。他们被用于<br>保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些<br>类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总<br>结。<br>例如：<br>salary DECIMAL(9,2)<br>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于<br>存储小数点后的位数。<br>因此，在这种情况下，能被存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。<br>在 ANSI/ISO SQL92 中，句法 DECIMAL(p)等价于 DECIMAL(p,0)。<br>同样，句法 DECIMAL 等价于 DECIMAL(p,0)，这里实现被允许决定值 p。Mysql 当前不支持<br>DECIMAL/NUMERIC 数据类型的这些变种形式的任一种。<br>这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模<br>的能力。<br>DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小<br>数精度。<br>一个字符用于值的每一位、小数点(如果 scale&gt;0)和“-”符号(对于负值)。如果 scale 是 0，<br>DECIMAL 和 NUMERIC 值不包含小数点或小数部分。<br>DECIMAL 和 NUMERIC 值得最大的范围与 DOUBLE 一样，但是对于一个给定的 DECIMAL 或<br>NUMERIC 列，实际的范围可由制由给定列的 precision 或 scale 限制。<br>当这样的列赋给了小数点后面的位超过指定 scale 所允许的位的值，该值根据 scale 四舍五<br>入。<br>当一个 DECIMAL 或 NUMERIC 列被赋给了其大小超过指定(或缺省的）precision 和 scale 隐含<br>的范围的值，Mysql 存储表示那个范围的相应的端点值。<br>我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担<br>心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点<br>也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困<br>境的第一步。<br>53、MYSQL 数据表在什么情况下容易损坏？<br>服务器突然断电导致数据文件损坏。<br>强制关机，没有先关闭 mysql 服务等。<br>54、mysql 有关权限的表都有哪几个？<br>Mysql 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库里，由<br>mysql_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和<br>host。<br>55、Mysql 中有哪几种锁？<br>MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁<br>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量<br>最低<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高<br>最后，欢迎做 Java 的工程师朋友们加入 Java 高级架构进阶 Qqun：963944895<br>群内有技术大咖指点难题，还提供免费的 Java 架构学习资料（里面有高可用、高并发、高性能及分布式、<br>Jvm 性能调优、Spring 源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx 等多个<br>知识点的架构资料）<br>比你优秀的对手在学习，你的仇人在磨刀，你的闺蜜在减肥，隔壁老王在练腰， 我们必须不断学习，否则我<br>们将被学习者超越！<br>趁年轻，使劲拼，给未来的自己一个交代！</p><p>&lt;最全 MySQL 面试 50 题和答案&gt;<br>Mysql 中有哪几种锁？<br>1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率<br>最高，并发度最低。<br>2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，<br>并发度也最高。<br>3. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和<br>行锁之间，并发度一般。<br>Mysql 中有哪些不同的表格？<br>共有 5 种类型的表格：<br>. MyISAM<br>. Heap<br>. Merge<br>. INNODB<br>. ISAM<br>简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别<br>MyISAM：<br>不支持事务，但是每次查询都是原子的；<br>支持表级锁，即每次操作是对整个表加锁；<br>存储表的总行数；<br>一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；<br>采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本<br>一致，但是辅索引不用保证唯一性。<br>InnoDb：<br>支持 ACID 的事务，支持事务的四种隔离级别；<br>支持行级锁及外键约束：因此可以支持写并发；<br>不存储总行数；<br>一个 InnoDb 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一<br>个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系<br>统文件大小限制，一般为 2G），受操作系统文件大小的限制；<br>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主<br>键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最<br>好使用自增主键，防止插入数据时，为维持 B+树结构，文件的大调整。<br>Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？<br>SQL 标准定义的四个隔离级别为：<br>. read uncommited ：读到未提交数据<br>. read committed：脏读，不可重复读<br>. repeatable read：可重读<br>. serializable ：串行事物<br>CHAR 和 VARCHAR 的区别？<br>1.CHAR 和 VARCHAR 类型在存储和检索方面有所不同<br>2.CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255<br>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除<br>尾随空格。<br>主键和候选键有什么区别？<br>表格的每一行都由主键唯一标识,一个表只有一个主键。<br>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外<br>键引用。<br>myisamchk 是用来做什么的？<br>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。<br>MyISAM Static 和 MyISAM Dynamic 有什么区别？<br>在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像<br>TEXT，BLOB 等字段，以适应不同长度的数据类型。<br>MyISAM Static 在受损情况下更容易恢复。<br>如果一个表有一列定义为 TIMESTAMP，将发生什么？<br>每当行被更改时，时间戳字段将获取当前时间戳。<br>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？<br>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。<br>怎样才能找出最后一次插入时分配了哪个自动增量？<br>（1）Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那<br>些可以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。<br>（2）用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。<br>（3） 避免在索引列上使用计算<br>（4）避免在索引列上使用 IS NULL 和 IS NOT NULL<br>（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order<br>by 涉及的列上建立索引。<br>（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放<br>弃使用索引而进行全表扫描<br>（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃<br>使用索引而进行全表扫描</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a> <a href="/tags/mysql/" rel="tag"># mysql</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/554d7a59d68c.html" rel="prev" title="Zookeeper"><i class="fa fa-angle-left"></i> Zookeeper</a></div><div class="post-nav-item"><a href="/publishes/b9efb3c36627.html" rel="next" title="Dubbo">Dubbo <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>