<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="获得Class对象的⽅式 静态类的.class语法：GuideUtil.class 普通类对象的getClass()⽅法：new Test().getClass() 通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”); 对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE  在"><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/22829df8f04f.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="获得Class对象的⽅式 静态类的.class语法：GuideUtil.class 普通类对象的getClass()⽅法：new Test().getClass() 通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”); 对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE  在"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T01:28:17.000Z"><meta property="article:modified_time" content="2024-01-04T09:16:47.092Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="java"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/22829df8f04f.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/22829df8f04f.html","path":"publishes/22829df8f04f.html","title":"Java基础"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java基础 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%BD%85%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">获得Class对象的⽅式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">在 Java 中，为什么不允许从静态方法中访问非静态变量？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">在 Java 中，什么时候用重载，什么时候用重写？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%9B%B4%E5%80%BE%E5%90%91%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">举例说明什么情况下会更倾向于使用抽象类而不是接口？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class-forName%E7%9A%84%E4%BD%9C%E7%94%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">Class.forName的作用?为什么要用?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jdo%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.</span> <span class="nav-text">Jdo是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%EF%BC%8CHashTable-%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">HashMap ，HashTable 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashTable"><span class="nav-number">8.</span> <span class="nav-text">HashTable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9CHashMap%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%87%E4%BA%86%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90-load-factor-%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%B9%E9%87%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB%E4%B8%8EJavaBean%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">EJB与JavaBean的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81"><span class="nav-number">11.</span> <span class="nav-text">面向对象特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">11.0.0.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">11.0.0.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">11.0.0.3.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1"><span class="nav-number">11.0.0.4.</span> <span class="nav-text">抽象</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#final-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">final, finally, finalize 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final"><span class="nav-number">12.0.0.1.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally"><span class="nav-number">12.0.0.2.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finalize"><span class="nav-number">12.0.0.3.</span> <span class="nav-text">finalize</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">重载和重写的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#override%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89"><span class="nav-number">13.0.0.1.</span> <span class="nav-text">override（重写）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#overload%EF%BC%88%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="nav-number">13.0.0.2.</span> <span class="nav-text">overload（重载）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">抽象类和接口有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java1-7%E4%B8%8E1-8-1-9-10-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">15.</span> <span class="nav-text">Java1.7与1.8,1.9,10 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7"><span class="nav-number">15.0.0.1.</span> <span class="nav-text">1.7</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8"><span class="nav-number">15.0.0.2.</span> <span class="nav-text">1.8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9"><span class="nav-number">15.0.0.3.</span> <span class="nav-text">1.9</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E9%9D%A2%E5%85%B3%E4%BA%8EJ2EE%E7%9A%84%E5%90%8D%E8%AF%8D%EF%BC%9AJNDI%E3%80%81JDBC%E3%80%81JMS%E3%80%81JTA%E3%80%81EJB%E3%80%81RMI"><span class="nav-number">16.</span> <span class="nav-text">解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E7%94%9F%E6%88%90Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">Class类的作用？生成Class对象的方法有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">18.</span> <span class="nav-text">序列化的定义、实现和注意事项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java-sql-Date%E5%92%8Cjava-util-Date%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">java.sql.Date和java.util.Date的联系和区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AAString-Object"><span class="nav-number">20.</span> <span class="nav-text">String s &#x3D; new String(“xyz”);创建几个String Object?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-s-%E2%80%9DHello%E2%80%9D-s-s-%E2%80%9Dworld-%E2%80%9D-%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8Cs%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E6%94%B9%E5%8F%98%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">22.</span> <span class="nav-text">基本数据类型有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">23.</span> <span class="nav-text">String、StringBuffer、StringBuilder区别与联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFfinal%E7%9A%84"><span class="nav-number">24.</span> <span class="nav-text">String类为什么是final的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Integer%E4%B8%8Eint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">25.</span> <span class="nav-text">Integer与int的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%ADthrows%E5%92%8Cthrow%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.</span> <span class="nav-text">异常处理中throws和throw的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86try-catch-finally%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">27.</span> <span class="nav-text">Java异常处理try-catch-finally的执行过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C"><span class="nav-number">28.</span> <span class="nav-text">运行时异常与受检异常有何异同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">Error和Exception的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">30.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别和联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">31.</span> <span class="nav-text">继承条件下构造方法的执行过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">32.</span> <span class="nav-text">权限修饰符的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final%E5%92%8Cabstract%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">33.</span> <span class="nav-text">final和abstract关键字的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="nav-number">34.</span> <span class="nav-text">static关键字的作用（修饰变量、方法、代码块）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">35.</span> <span class="nav-text">this和super关键字的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">面向过程和面向对象的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">37.</span> <span class="nav-text">类和对象的关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">38.</span> <span class="nav-text">可变参数的作用和特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">39.</span> <span class="nav-text">递归的定义和优缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#break%E5%92%8Ccontinue%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">40.</span> <span class="nav-text">break和continue的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#while%E5%92%8Cdo-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">41.</span> <span class="nav-text">while和do-while循环的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="nav-number">42.</span> <span class="nav-text">用最有效率的方法算出2乘以8等于多少</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%8C-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">43.</span> <span class="nav-text">&amp;和&amp;&amp;的区别和联系，|和||的区别和联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#i-%E5%92%8C-i%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="nav-number">44.</span> <span class="nav-text">i++和++i的异同之处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-JRE-JVM%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%E6%A6%82%E6%8B%AC%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">45.</span> <span class="nav-text">JDK,JRE,JVM三者关系概括如下：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="nav-number">46.</span> <span class="nav-text">Java跨平台原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">47.</span> <span class="nav-text">Java的安全性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFORM%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">什么是ORM？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDAO%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">什么是DAO模式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UML%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FUML%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9B%BE%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">UML是什么？UML中有哪些图？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">Java 中有几种类型的流？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">Java中如何实现序列化，有什么意义？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8assert%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">什么时候用assert？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E4%B8%80%E4%B8%8BJava-%E5%92%8CJavaSciprt"><span class="nav-number">54.</span> <span class="nav-text">比较一下Java 和JavaSciprt</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E5%B0%86GB2312%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BAISO-8859-1%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="nav-number">55.</span> <span class="nav-text">怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E5%AE%83%E7%9A%84%E5%8C%85%E5%90%AB%E7%B1%BB%EF%BC%88%E5%A4%96%E9%83%A8%E7%B1%BB%EF%BC%89%E7%9A%84%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E5%AE%83%E7%B1%BB%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">57.</span> <span class="nav-text">匿名内部类是否可以继承其它类？是否可以实现接口？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E2%80%9C-java%E2%80%9D%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%B1%BB%EF%BC%88%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="nav-number">58.</span> <span class="nav-text">一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%EF%BC%88extends%EF%BC%89%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%EF%BC%88implements%EF%BC%89%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%85%B7%E4%BD%93%E7%B1%BB%EF%BC%88concrete-class%EF%BC%89"><span class="nav-number">59.</span> <span class="nav-text">接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="nav-number">60.</span> <span class="nav-text">如何实现对象克隆？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%EF%BC%88static%EF%BC%89%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9E%E9%9D%99%E6%80%81%EF%BC%88non-static%EF%BC%89%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">61.</span> <span class="nav-text">是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">62.</span> <span class="nav-text">静态变量和实例变量的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%EF%BC%88abstract%EF%BC%89%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%88static%EF%BC%89-%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%EF%BC%88native%EF%BC%89%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E8%A2%ABsynchronized%E4%BF%AE%E9%A5%B0"><span class="nav-number">63.</span> <span class="nav-text">抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="nav-number">64.</span> <span class="nav-text">Java 中会存在内存泄漏吗，请简单描述。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">65.</span> <span class="nav-text">静态内部类和内部类有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#char-%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">66.</span> <span class="nav-text">char 型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%BD%93%E4%BD%9C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E6%AD%A4%E6%96%B9%E6%B3%95%E5%8F%AF%E6%94%B9%E5%8F%98%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%B9%B6%E5%8F%AF%E8%BF%94%E5%9B%9E%E5%8F%98%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E9%87%8C%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">67.</span> <span class="nav-text">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BFString-%E7%B1%BB"><span class="nav-number">68.</span> <span class="nav-text">是否可以继承String 类?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%80%BC%E7%9B%B8%E5%90%8C-x-equals-y-true-%EF%BC%8C%E4%BD%86%E5%8D%B4%E5%8F%AF%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84hash-code%EF%BC%8C%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%AF%B9%E4%B8%8D%E5%AF%B9%EF%BC%9F"><span class="nav-number">69.</span> <span class="nav-text">两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88constructor%EF%BC%89%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89"><span class="nav-number">70.</span> <span class="nav-text">构造器（constructor）是否可被重写（override）?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8Java-%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="nav-number">71.</span> <span class="nav-text">在Java 中，如何跳出当前的多重嵌套循环？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95-String-%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">72.</span> <span class="nav-text">数组有没有length()方法?String 有没有length()方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#swtich-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8byte-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8long-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8String%E4%B8%8A"><span class="nav-number">73.</span> <span class="nav-text">swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Math-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91-Math-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="nav-number">74.</span> <span class="nav-text">Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88%EF%BC%88stack%EF%BC%89%E3%80%81%E5%A0%86-heap-%E5%92%8C%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%82"><span class="nav-number">75.</span> <span class="nav-text">解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">76.</span> <span class="nav-text">&amp;和&amp;&amp;的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E6%9C%89%E6%B2%A1%E6%9C%89goto"><span class="nav-number">77.</span> <span class="nav-text">Java 有没有goto?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#short-s1-1-s1-s1-1-%E6%9C%89%E9%94%99%E5%90%97-short-s1-1-s1-1-%E6%9C%89%E9%94%99%E5%90%97"><span class="nav-number">78.</span> <span class="nav-text">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#float-f-3-4-%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="nav-number">79.</span> <span class="nav-text">float f&#x3D;3.4;是否正确?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97"><span class="nav-number">80.</span> <span class="nav-text">String 是最基本的数据类型吗?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">81.</span> <span class="nav-text">访问修饰符的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%8F%98%E9%87%8F%E7%94%A8final%E4%BF%AE%E9%A5%B0%EF%BC%8C%E5%88%99%E6%80%8E%E6%A0%B7%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%96%B9%E6%B3%95final%E4%BF%AE%E9%A5%B0%EF%BC%8C%E5%88%99%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="nav-number">82.</span> <span class="nav-text">如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%94%A8static%E4%BF%AE%E9%A5%B0%E5%92%8C%E4%B8%8D%E7%94%A8static%E4%BF%AE%E9%A5%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">83.</span> <span class="nav-text">成员变量用static修饰和不用static修饰有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#System-out-println-%E2%80%98a%E2%80%99-1-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF"><span class="nav-number">84.</span> <span class="nav-text">System.out.println(‘a’+1);的结果是</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84RuntimeException"><span class="nav-number">85.</span> <span class="nav-text">常见的RuntimeException</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-TreeMap%E5%92%8CTreeSet%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%97%B6%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9FCollections%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E7%9A%84sort%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">86.</span> <span class="nav-text">200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#199-%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD%EF%BC%88overloading%EF%BC%89%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%EF%BC%88overrding%EF%BC%89%EF%BC%9F"><span class="nav-number">87.</span> <span class="nav-text">199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E5%82%A8%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%EF%BC%9F"><span class="nav-number">88.</span> <span class="nav-text">char型变量中能不能存储一个中文汉字？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAn%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%BF%99%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E5%90%AF%E5%8A%A8%EF%BC%9F%E7%9C%8B%E6%B8%85%EF%BC%8C%E6%98%AF%E2%80%9C%E5%90%8C%E6%97%B6%E2%80%9D%E3%80%82"><span class="nav-number">89.</span> <span class="nav-text">创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%8C%E6%9C%89%E5%BA%8F%E7%9A%84%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%85%B6%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E5%93%AA%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%80%A7%E6%80%A7%E8%83%BD%E6%9B%B4%E9%AB%98%EF%BC%8C%E4%BD%A0%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9B%B4%E5%A5%BD%E6%88%96%E8%80%85%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">90.</span> <span class="nav-text">Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#try-%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AAreturn%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B4%A7%E8%B7%9F%E5%9C%A8%E8%BF%99%E4%B8%AAtry%E5%90%8E%E7%9A%84finally-%E9%87%8C%E9%9D%A2%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%9C%A8%E5%BC%82%E5%B8%B8%E5%87%BA%E7%8E%B0%E5%90%8E%EF%BC%8C%E9%83%BD%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">91.</span> <span class="nav-text">try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9Fjava%E5%8F%AF%E4%BB%A5%E5%BD%92%E7%B1%BB%E5%88%B0%E9%82%A3%E7%A7%8D%EF%BC%9F"><span class="nav-number">92.</span> <span class="nav-text">什么是编译型语言，什么是解释型语言？java可以归类到那种？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="nav-number">93.</span> <span class="nav-text">使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class%E7%B1%BB%E7%9A%84getDeclaredFields-%E6%96%B9%E6%B3%95%E4%B8%8EgetFields-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">94.</span> <span class="nav-text">Class类的getDeclaredFields()方法与getFields()的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89serialversionUID%E5%80%BC"><span class="nav-number">95.</span> <span class="nav-text">103.可序列化对象为什么要定义serialversionUID值?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">96.</span> <span class="nav-text">GC线程是否为守护线程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8D%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%9F%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B9%88"><span class="nav-number">97.</span> <span class="nav-text">不通过构造函数也能创建对象么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">98.</span> <span class="nav-text">同步代码块和同步方法有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9CManager%E6%98%AFEmployee%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%8C%E9%82%A3%E4%B9%88Pair%E6%98%AFPair%E7%9A%84%E5%AD%90%E7%B1%BB%E5%90%97%EF%BC%9F"><span class="nav-number">99.</span> <span class="nav-text">Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="nav-number">100.</span> <span class="nav-text">简述Java中如何实现多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E5%81%9A%E4%B8%BAHashMap%E7%9A%84%E9%94%AE%E5%80%BC%EF%BC%8C%E8%80%8C%E5%8F%AA%E8%83%BD%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8A%8A%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%81%9A%E4%B8%BAHashMap%E7%9A%84%E5%81%A5%E5%80%BC%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E3%80%82"><span class="nav-number">101.</span> <span class="nav-text">在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B8%AD%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%94%A8size-of%E5%8F%96%E5%87%BA%E3%80%82"><span class="nav-number">102.</span> <span class="nav-text">对象在虚拟机的大小中可不可以用size of取出。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JMS%EF%BC%9F"><span class="nav-number">103.</span> <span class="nav-text">什么是 JMS？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMS-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">104.</span> <span class="nav-text">JMS 有哪些模型？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PTP-%E6%A8%A1%E5%9E%8B"><span class="nav-number">104.0.0.1.</span> <span class="nav-text">PTP 模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pub-Sub-%E6%A8%A1%E5%9E%8B"><span class="nav-number">104.0.0.2.</span> <span class="nav-text">Pub-Sub 模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%A0%B9%E6%8D%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%8C%BA%E5%88%86%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">105.</span> <span class="nav-text">为什么不能根据返回类型来区分重载，为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD-byte-%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">106.</span> <span class="nav-text">Java 中 byte 表示的数值范围是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-switch-%E5%92%8C-if-else-%E8%AF%AD%E5%8F%A5%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E9%80%89%E5%8F%96%EF%BC%8C%E5%BD%93%E6%8E%A7%E5%88%B6%E9%80%89%E6%8B%A9%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E4%BE%9D%E8%B5%96%E4%BA%8E%E4%B8%80%E4%B8%AA-x-%E6%97%B6%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-switch-%E7%BB%93%E6%9E%84%EF%BC%9B%E6%AD%A3%E7%A1%AE%E4%B9%88%EF%BC%9F"><span class="nav-number">107.</span> <span class="nav-text">在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97-new%EF%BC%8C%E5%9B%9E%E6%94%B6%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97-free-%E6%AD%A3%E7%A1%AE%E4%B9%88%EF%BC%9F"><span class="nav-number">108.</span> <span class="nav-text">Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E4%BD%BF-i-1"><span class="nav-number">109.</span> <span class="nav-text">存在使 i+1&lt;i 的数么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD-Math-random%EF%BC%88%EF%BC%89-Math-random%EF%BC%88%EF%BC%89%E5%80%BC%E4%B8%BA%EF%BC%9F"><span class="nav-number">110.</span> <span class="nav-text">Java 中 Math.random（）&#x2F; Math.random（）值为？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%88%96%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E3%80%82%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">111.</span> <span class="nav-text">匿名内部类可不可以继承或实现接口。为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%8C%E7%BB%93%E5%90%88%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%8F%8F%E8%BF%B0Java-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">112.</span> <span class="nav-text">说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%BC%95%E5%85%A5%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">113.</span> <span class="nav-text">为什么为基本类型引入包装类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88-Java-%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-number">114.</span> <span class="nav-text">谈谈 Java 的多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#if-%E5%A4%9A%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C-switch-%E5%A4%9A%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="nav-number">115.</span> <span class="nav-text">if 多分支语句和 switch 多分支语句的异同之处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="nav-number">116.</span> <span class="nav-text">基本数据类型的类型转换规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%89%E7%A7%8D%E6%B3%A8%E9%87%8A%E7%B1%BB%E5%9E%8B"><span class="nav-number">117.</span> <span class="nav-text">Java 三种注释类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Java%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3-%E2%80%9CJava-%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E2%80%9D-%E8%BF%99%E5%8F%A5%E8%AF%9D%E6%AD%A3%E7%A1%AE%E4%B9%88"><span class="nav-number">118.</span> <span class="nav-text">谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NoClassDeFoundError%E5%92%8CClassNotFoundException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">119.</span> <span class="nav-text">NoClassDeFoundError和ClassNotFoundException的区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA-subclass-%E6%80%8E%E6%A0%B7%E8%B0%83%E7%94%A8-superclass-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88myMethod%EF%BC%89%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">120.</span> <span class="nav-text">一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bit-%E5%92%8C-Byte-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-number">121.</span> <span class="nav-text">Bit 和 Byte 是什么意思?它们之间有什么关系?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-java-%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-java-%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-number">122.</span> <span class="nav-text">什么是 java 序列化，如何实现 java 序列化？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">123.</span> <span class="nav-text">Lambda表达式概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">124.</span> <span class="nav-text">获取用键盘输入常用的的两种方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="nav-number">125.</span> <span class="nav-text">自动装箱与拆箱</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA-%E5%A4%8D%E5%88%B6"><span class="nav-number">126.</span> <span class="nav-text">JAVA 复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E5%A4%8D%E5%88%B6"><span class="nav-number">126.0.0.1.</span> <span class="nav-text">直接赋值复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E5%A4%8D%E5%88%B6%EF%BC%88%E5%A4%8D%E5%88%B6%E5%BC%95%E7%94%A8%E4%BD%86%E4%B8%8D%E5%A4%8D%E5%88%B6%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="nav-number">126.0.0.2.</span> <span class="nav-text">浅复制（复制引用但不复制引用的对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%A4%8D%E5%88%B6%EF%BC%88%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%B6%E5%BA%94%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="nav-number">126.0.0.3.</span> <span class="nav-text">深复制（复制对象和其应用对象）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">127.</span> <span class="nav-text">类型擦除</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">128.</span> <span class="nav-text">类型通配符?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">129.</span> <span class="nav-text">创建对象的两种方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%EF%BC%8CSerializable-%E4%B8%8E-Externalizable-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">130.</span> <span class="nav-text">Java 中，Serializable 与 Externalizable 的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OOP-%E4%B8%AD%E7%9A%84-%E7%BB%84%E5%90%88%E3%80%81%E8%81%9A%E5%90%88%E5%92%8C%E5%85%B3%E8%81%94%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">131.</span> <span class="nav-text">OOP 中的 组合、聚合和关联有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%EF%BC%8C%E5%B5%8C%E5%A5%97%E5%85%AC%E5%85%B1%E9%9D%99%E6%80%81%E7%B1%BB%E4%B8%8E%E9%A1%B6%E7%BA%A7%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">132.</span> <span class="nav-text">Java 中，嵌套公共静态类与顶级类有什么不同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">133.</span> <span class="nav-text">继承和组合之间有什么不同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E8%83%BD%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%B1%BB%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8-for-each-%E5%BE%AA%E7%8E%AF%E7%A0%81%EF%BC%9F"><span class="nav-number">134.</span> <span class="nav-text">我们能自己写一个容器类，然后使用 for-each 循环码？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%9C%A8%E9%81%8D%E5%8E%86-ArrayList-%E6%97%B6%E7%A7%BB%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">135.</span> <span class="nav-text">写一段代码在遍历 ArrayList 时移除一个元素？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84-HashSet%EF%BC%8C%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">136.</span> <span class="nav-text">Java 中的 HashSet，内部是如何工作的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84-TreeMap-%E6%98%AF%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">137.</span> <span class="nav-text">Java 中的 TreeMap 是采用什么树实现的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84-LinkedList-%E6%98%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E8%BF%98%E6%98%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="nav-number">138.</span> <span class="nav-text">Java 中的 LinkedList 是单向链表还是双向链表？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD-LinkedHashMap-%E5%92%8C-PriorityQueue-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">139.</span> <span class="nav-text">Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#poll-%E6%96%B9%E6%B3%95%E5%92%8C-remove-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">140.</span> <span class="nav-text">poll() 方法和 remove() 方法的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8F%88%E4%BB%80%E4%B9%88%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="nav-number">141.</span> <span class="nav-text">Java 中的编译期常量是什么？使用它又什么风险？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91%E8%83%BD%E5%9C%A8%E4%B8%8D%E8%BF%9B%E8%A1%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%B0%86%E4%B8%80%E4%B8%AA-double-%E5%80%BC%E8%B5%8B%E5%80%BC%E7%BB%99long-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F"><span class="nav-number">142.</span> <span class="nav-text">我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-0-1-0-3-%E5%B0%86%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88%EF%BC%9Ftrue-%E8%BF%98%E6%98%AF-false%EF%BC%9F"><span class="nav-number">143.</span> <span class="nav-text">3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#int-%E5%92%8C-Integer-%E5%93%AA%E4%B8%AA%E4%BC%9A%E5%8D%A0%E7%94%A8%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">144.</span> <span class="nav-text">int 和 Integer 哪个会占用更多的内存？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E4%B8%AD%E7%9A%84-String-%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%88Immutable%EF%BC%89%EF%BC%9F"><span class="nav-number">145.</span> <span class="nav-text">为什么 Java 中的 String 是不可变的（Immutable）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E8%83%BD%E5%9C%A8-Switch-%E4%B8%AD%E4%BD%BF%E7%94%A8-String-%E5%90%97%EF%BC%9F"><span class="nav-number">146.</span> <span class="nav-text">我们能在 Switch 中使用 String 吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">147.</span> <span class="nav-text">Java 中的构造器链是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Busy-spin%EF%BC%9F%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="nav-number">148.</span> <span class="nav-text">什么是 Busy spin？我们为什么要使用它？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Swing-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">149.</span> <span class="nav-text">Swing 是线程安全的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="nav-number">150.</span> <span class="nav-text">什么是线程局部变量？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E4%BB%A3%E8%A1%A8%E4%BB%B7%E6%A0%BC%EF%BC%9F"><span class="nav-number">151.</span> <span class="nav-text">Java 中应该使用什么数据类型来代表价格？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%B0%86-byte-%E8%BD%AC%E6%8D%A2%E4%B8%BA-String%EF%BC%9F"><span class="nav-number">152.</span> <span class="nav-text">怎么将 byte 转换为 String？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E8%83%BD%E5%B0%86-int-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%AF%A5%E5%80%BC%E5%A4%A7%E4%BA%8E-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="nav-number">153.</span> <span class="nav-text">我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%AA%E4%B8%AA%E7%B1%BB%E5%8C%85%E5%90%AB-clone-%E6%96%B9%E6%B3%95%EF%BC%9F%E6%98%AF-Cloneable-%E8%BF%98%E6%98%AF-Object%EF%BC%9F"><span class="nav-number">154.</span> <span class="nav-text">哪个类包含 clone 方法？是 Cloneable 还是 Object？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD-%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">155.</span> <span class="nav-text">Java 中 ++ 操作符是线程安全的吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#a-a-b-%E4%B8%8E-a-b-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">156.</span> <span class="nav-text">a &#x3D; a + b 与 a +&#x3D; b 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%88false-sharing%EF%BC%89%EF%BC%9F"><span class="nav-number">157.</span> <span class="nav-text">什么是多线程环境下的伪共享（false sharing）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#89%E3%80%81%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9D%E5%85%AD%E5%8E%9F%E5%88%99%E4%B8%80%E6%B3%95%E5%88%99%E2%80%9D%E3%80%82"><span class="nav-number">158.</span> <span class="nav-text">89、简述一下面向对象的”六原则一法则”。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#try-catch-finally-%E4%B8%AD%E5%93%AA%E4%B8%AA%E9%83%A8%E5%88%86%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%EF%BC%9F"><span class="nav-number">159.</span> <span class="nav-text">try-catch-finally 中哪个部分可以省略？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="nav-number">160.</span> <span class="nav-text">为什么要使用克隆？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="nav-number">161.</span> <span class="nav-text">动态代理是什么？有哪些应用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="nav-number">162.</span> <span class="nav-text">怎么实现动态代理？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-atomic-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">163.</span> <span class="nav-text">说一下 atomic 的原理？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">164.</span> <span class="nav-text">Files的常用方法都有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E3%80%82"><span class="nav-number">165.</span> <span class="nav-text">Java 中的异常处理机制的简单原理和应用。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84-LongAdder-%E5%92%8C-AtomicLong-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">166.</span> <span class="nav-text">Java 中的 LongAdder 和 AtomicLong 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5-fail-fast-%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5-fail-safe-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">167.</span> <span class="nav-text">快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">168.</span> <span class="nav-text">Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E9%97%AE-Query-%E6%8E%A5%E5%8F%A3%E7%9A%84-list-%E6%96%B9%E6%B3%95%E5%92%8C-iterate-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">169.</span> <span class="nav-text">请问 Query 接口的 list 方法和 iterate 方法有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C-C-%E7%9A%84%E8%99%9A%E7%B1%BB%E7%9A%84%E7%9B%B8%E5%90%8C%E5%92%8C%E4%B8%8D%E5%90%8C%E5%A4%84%E3%80%82"><span class="nav-number">170.</span> <span class="nav-text">Java 的接口和 C++的虚类的相同和不同处。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B9%88%EF%BC%9F"><span class="nav-number">171.</span> <span class="nav-text">Java 支持多继承么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-extends-%E5%92%8C-super-%E6%B3%9B%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6-%E4%B8%8A%E7%95%8C%E4%B8%8D%E5%AD%98%E4%B8%8B%E7%95%8C%E4%B8%8D%E5%8F%96"><span class="nav-number">172.</span> <span class="nav-text">解释 extends 和 super 泛型限定符-上界不存下界不取</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%80%9Dstatic%E2%80%9D%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9FJava-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A6%86%E7%9B%96-override-%E4%B8%80%E4%B8%AA-private%E6%88%96%E8%80%85%E6%98%AF-static-%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">173.</span> <span class="nav-text">”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%A7-O-%E7%AC%A6%E5%8F%B7-big-O-notation-%E4%B9%88%EF%BC%9F%E4%BD%A0%E8%83%BD%E7%BB%99%E5%87%BA%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BE%8B%E5%AD%90%E4%B9%88%EF%BC%9F"><span class="nav-number">174.</span> <span class="nav-text">你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="nav-number">175.</span> <span class="nav-text">什么是值传递和引用传递？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5%E6%9C%89%E6%97%B6%E4%BC%9A%E5%87%BA%E7%8E%B0-4-0-3-6-0-40000001-%E8%BF%99%E7%A7%8D%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="nav-number">176.</span> <span class="nav-text">为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-Lamda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E3%80%82"><span class="nav-number">177.</span> <span class="nav-text">说说 Lamda 表达式的优缺点。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8B%A5%E5%AF%B9%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E9%87%8D%E5%86%99%EF%BC%8C%E5%AE%83%E7%9A%84-equals-%E6%96%B9%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%9A%84%EF%BC%9F"><span class="nav-number">178.</span> <span class="nav-text">若对一个类不重写，它的 equals()方法是如何比较的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">179.</span> <span class="nav-text">&#x3D;&#x3D;比较的是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-%E8%8B%A5%E4%B8%8D%E9%87%8D%E5%86%99-hashCode-%E7%9A%84%E8%AF%9D%EF%BC%8ChashCode-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F"><span class="nav-number">180.</span> <span class="nav-text">Object 若不重写 hashCode()的话，hashCode()如何计算出来的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hash%E8%A1%A8%E7%9A%84hash%E5%87%BD%E6%95%B0%EF%BC%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E3%80%82"><span class="nav-number">181.</span> <span class="nav-text">Hash表的hash函数，冲突解决方法有哪些。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%B4%BE%EF%BC%9A%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E3%80%82"><span class="nav-number">182.</span> <span class="nav-text">分派：静态分派与动态分派。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E4%BA%86%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">183.</span> <span class="nav-text">一个线程如果出现了运行时异常会怎么样?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B-i-%E7%BB%93%E6%9E%9C%E6%AD%A3%E7%A1%AE%EF%BC%9F"><span class="nav-number">184.</span> <span class="nav-text">如何保证多线程下 i++ 结果正确？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88concurrency%EF%BC%89%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%EF%BC%88parallellism%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">185.</span> <span class="nav-text">并发编程（concurrency）并行编程（parallellism）有什么区别？*</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E6%AD%A5%E5%9D%97%E5%86%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">186.</span> <span class="nav-text">如果同步块内的线程抛出异常会发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#foreach%E4%B8%8E%E6%AD%A3%E5%B8%B8for%E5%BE%AA%E7%8E%AF%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="nav-number">187.</span> <span class="nav-text">foreach与正常for循环效率对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Static-class-%E4%B8%8Enon-static-class%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">188.</span> <span class="nav-text">Static?class?与non?static?class的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC-%E6%B5%81%E7%A8%8B"><span class="nav-number">189.</span> <span class="nav-text">JDBC 流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E5%86%99%EF%BC%89"><span class="nav-number">190.</span> <span class="nav-text">重载 重写（覆写）</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/22829df8f04f.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java基础 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java基础</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 17:16:47" itemprop="dateModified" datetime="2024-01-04T17:16:47+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>45k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>41 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="获得Class对象的⽅式"><a href="#获得Class对象的⽅式" class="headerlink" title="获得Class对象的⽅式"></a>获得Class对象的⽅式</h1><ul><li>静态类的.class语法：GuideUtil.class</li><li>普通类对象的getClass()⽅法：new Test().getClass()</li><li>通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”);</li><li>对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE</li></ul><h1 id="在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>在 Java 中，为什么不允许从静态方法中访问非静态变量？</h1><ul><li>因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联</li></ul><h1 id="在-Java-中，什么时候用重载，什么时候用重写？"><a href="#在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="在 Java 中，什么时候用重载，什么时候用重写？"></a>在 Java 中，什么时候用重载，什么时候用重写？</h1><ul><li>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding）</li><li>而重载（overloading）是用不同的输入做同一件事</li><li>在 Java 中，重载的方法签名不同，而重写并不是。</li></ul><h1 id="举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>举例说明什么情况下会更倾向于使用抽象类而不是接口？</h1><ul><li>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求</li><li>在 Java 中，你只能继承一个类，但可以实现多个接口</li><li>所以一旦你继承了一个类，你就失去了继承其他类的机会了。</li><li>接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable(注：这里的意思是指如果把 Runnable 等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</li><li>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</li><li>如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择</li><li>有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</li></ul><h1 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h1><ul><li>调用该访问返回一个以字符串指定类名的类的对象。</li></ul><h1 id="Jdo是什么"><a href="#Jdo是什么" class="headerlink" title="Jdo是什么?"></a>Jdo是什么?</h1><ul><li>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API</li><li>JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）</li><li>这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上</li><li>另外，JDO很灵活，因为它可以在任何数据底层上运行</li><li>JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。</li></ul><h1 id="HashMap-，HashTable-区别"><a href="#HashMap-，HashTable-区别" class="headerlink" title="HashMap ，HashTable 区别"></a>HashMap ，HashTable 区别</h1><ul><li>默认容量不同。扩容不同</li><li>线程安全性，HashTable 安全</li><li>效率不同 HashTable 要慢因为加锁</li></ul><h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul><li>数组 + 链表方式存储</li><li>默认容量：11(质数 为宜)</li><li>put:<ul><li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li><li>若在链表中找到了，则替换旧值，若未找到则继续</li><li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li><li>将新元素加到链表头部</li><li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。</li></ul></li></ul><h1 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h1><ul><li>默认的负载因子大小为0.75</li><li>也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组来重新调整map的大小，并将原来的对象放入新的bucket数组中。</li><li>这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</li></ul><h1 id="EJB与JavaBean的区别？"><a href="#EJB与JavaBean的区别？" class="headerlink" title="EJB与JavaBean的区别？"></a>EJB与JavaBean的区别？</h1><ul><li>Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于JavaBean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器。另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。</li><li>Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。</li></ul><h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</li><li>下面列出了使用封装的一些好处：<ul><li>通过隐藏对象的属性来保护对象内部的状态。</li><li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li><li>禁止对象之间的不良交互提高模块化</li></ul></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</li></ul><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul><li>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</li></ul><h1 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h1><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul><li>修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>在异常处理时提供 finally 块来执行任何清除操作</li><li>如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ul><li>方法名</li><li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</li><li>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h4 id="override（重写）"><a href="#override（重写）" class="headerlink" title="override（重写）"></a>override（重写）</h4><ul><li>方法名、参数、返回值相同。</li><li>子类方法不能缩小父类方法的访问权限。</li><li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li><li>存在于父类和子类之间。</li><li>方法被定义为final不能被重写。</li></ul><h4 id="overload（重载）"><a href="#overload（重载）" class="headerlink" title="overload（重载）"></a>overload（重载）</h4><ul><li>参数类型、个数、顺序至少有一个不相同。</li><li>不能重载只有返回值不同的方法名。</li><li>存在于父类和子类、同类中。</li></ul><h1 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h1><ul><li>接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。</li><li>还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。</li></ul><h1 id="Java1-7与1-8-1-9-10-新特性"><a href="#Java1-7与1-8-1-9-10-新特性" class="headerlink" title="Java1.7与1.8,1.9,10 新特性"></a>Java1.7与1.8,1.9,10 新特性</h1><h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4><ul><li>switch中可以使用字串了</li><li>运用List tempList &#x3D; new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断</li><li>语法上支持集合，而不一定是数组</li><li>新增一些取环境信息的工具方法</li><li>Boolean类型反转，空指针安全,参与位运算</li><li>两个char间的equals</li><li>安全的加减乘除</li><li>map集合支持并发请求，且可以写成 Map map &#x3D; {name:”xxx”,age:18};</li></ul><h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><ul><li>允许在接口中有默认方法实现</li><li>Lambda表达式</li><li>函数式接口</li><li>方法和构造函数引用</li><li>Lambda的范围</li><li>内置函数式接口</li><li>Streams</li><li>Parallel Streams</li><li>Map</li><li>时间日期API</li><li>Annotations</li></ul><h4 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h4><ul><li>Jigsaw 项目;模块化源码</li><li>简化进程API</li><li>轻量级 JSON API</li><li>钱和货币的API</li><li>改善锁争用机制</li><li>代码分段缓存</li><li>智能Java编译, 第二阶段</li><li>HTTP 2.0客户端</li><li>Kulla计划: Java的REPL实现</li></ul><h1 id="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"><a href="#解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI" class="headerlink" title="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"></a>解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI</h1><ul><li>web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。</li><li>EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。</li><li>JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</li><li>JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</li><li>JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</li><li>JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</li><li>RMI&#x2F;IIOP:（Remote Method Invocation &#x2F;internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。</li></ul><h1 id="Class类的作用？生成Class对象的方法有哪些？"><a href="#Class类的作用？生成Class对象的方法有哪些？" class="headerlink" title="Class类的作用？生成Class对象的方法有哪些？"></a>Class类的作用？生成Class对象的方法有哪些？</h1><ul><li>Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类</li><li>Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口</li><li>方法示例<ul><li>getClass()</li><li>getSuperClass()</li><li>.class</li><li>.TYPE</li></ul></li></ul><h1 id="序列化的定义、实现和注意事项"><a href="#序列化的定义、实现和注意事项" class="headerlink" title="序列化的定义、实现和注意事项"></a>序列化的定义、实现和注意事项</h1><ul><li>想把一个对象写在硬盘上或者网络上，对其进行序列化，把他序列化成为一个字节流。</li><li>实现和注意事项：<ul><li>实现接口Serializable Serializable接口中没有任何的方法，实现该接口的类不需要实现额外的方法。</li><li>如果对象中的某个属性是对象类型，必须也实现Serializable接口才可以，序列化对静态变量无效</li><li>如果不希望某个属性参与序列化，不是将其static，而是transient</li></ul></li><li>串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存</li><li>序列化版本不兼容</li></ul><h1 id="java-sql-Date和java-util-Date的联系和区别"><a href="#java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="java.sql.Date和java.util.Date的联系和区别"></a>java.sql.Date和java.util.Date的联系和区别</h1><ul><li>java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</li><li>JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002&#x2F;05&#x2F;22 5:00:57 PM的字段，读取日期时得到的是2002&#x2F;05&#x2F;22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.sql.Timestamp类比java.util.Date类精确度要高。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用…</li><li>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。</li></ul><h1 id="String-s-new-String-“xyz”-创建几个String-Object"><a href="#String-s-new-String-“xyz”-创建几个String-Object" class="headerlink" title="String s &#x3D; new String(“xyz”);创建几个String Object?"></a>String s &#x3D; new String(“xyz”);创建几个String Object?</h1><ul><li>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个</li><li>New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象</li><li>如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</li></ul><h1 id="String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？"><a href="#String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？" class="headerlink" title="String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？"></a>String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？</h1><ul><li>没有改变。</li><li>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</li></ul><h1 id="基本数据类型有哪些"><a href="#基本数据类型有哪些" class="headerlink" title="基本数据类型有哪些"></a>基本数据类型有哪些</h1><ul><li>byte、short、char、int、long、float、double、boolean</li></ul><h1 id="String、StringBuffer、StringBuilder区别与联系"><a href="#String、StringBuffer、StringBuilder区别与联系" class="headerlink" title="String、StringBuffer、StringBuilder区别与联系"></a>String、StringBuffer、StringBuilder区别与联系</h1><ul><li>String类是字符序列不可变的类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。</li><li>StringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setChartAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String</li><li>JDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder</li></ul><h1 id="String类为什么是final的"><a href="#String类为什么是final的" class="headerlink" title="String类为什么是final的"></a>String类为什么是final的</h1><ul><li>为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。</li><li>为了安全。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的， 和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的， 这不就成了核心病毒了么？</li><li>不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性， 如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点；</li></ul><h1 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h1><ul><li>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</li><li>int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</li><li>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</li><li>Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</li></ul><h1 id="异常处理中throws和throw的区别"><a href="#异常处理中throws和throw的区别" class="headerlink" title="异常处理中throws和throw的区别"></a>异常处理中throws和throw的区别</h1><ul><li>作用不同：<ul><li>throw用于程序员自行产生并抛出异常；</li><li>throws用于声明在该方法内抛出了异常</li></ul></li><li>使用的位置不同：<ul><li>throw位于方法体内部，可以作为单独语句使用；</li><li>throws必须跟在方法参数列表的后面，不能单独使用。</li></ul></li><li>内容不同：<ul><li>throw抛出一个异常对象，且只能是一个；</li><li>throws后面跟异常类，而且可以有多个。</li></ul></li></ul><h1 id="Java异常处理try-catch-finally的执行过程"><a href="#Java异常处理try-catch-finally的执行过程" class="headerlink" title="Java异常处理try-catch-finally的执行过程"></a>Java异常处理try-catch-finally的执行过程</h1><ul><li>try-catch-finally程序块的执行流程以及执行结果比较复杂。</li><li>基本执行过程如下：<ul><li>程序首先执行可能发生异常的try语句块。</li><li>如果try语句没有出现异常则执行完后跳至finally语句块执行；</li><li>如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。</li><li>catch语句块可以有多个，分别捕获不同类型的异常。</li><li>catch语句块执行完后程序会继续执行finally语句块。</li></ul></li><li>finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。需要注意的是即使try和catch块中存在return语句，finally语句也会执行，是在执行完finally语句后再通过return退出。</li></ul><h1 id="运行时异常与受检异常有何异同"><a href="#运行时异常与受检异常有何异同" class="headerlink" title="运行时异常与受检异常有何异同"></a>运行时异常与受检异常有何异同</h1><ul><li>运行时异常：包括RuntimeaException及其所有子类。不要求程序必须对它们作出处理，比如InputMismatchException、ArithmeticException、NullPointerException等。即使没有显示使用try-catch或throws进行处理，仍旧可以进行编译和运行(其实是JVM隐式的使用try-catch或throws进行处理)。如果运行时发生异常，会输出异常的堆栈信息并中止程序执行。</li><li>Checked异常（非运行时异常）：除了运行时异常外的其他异常类都是Checked异常，程序必须捕获或者声明抛出这种异常，否则出现编译错误，无法通过编译。处理方式包括两种：通过try-catch捕获异常，通过throws声明抛出异常从而交给上一级调用方法处理。</li></ul><h1 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h1><ul><li>Error类，表示仅靠程序本身无法恢复的严重错误，比如说内存溢出、动态链接异常、虚拟机错误。应用程序不应该抛出这种类型的对象。假如出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。所以在进行程序设计时，应该更关注Exception类。</li><li>Exception类，由Java应用程序抛出和处理的非严重错误，比如所需文件没有找到、零作除数，数组下标越界等。它的各种不同子类分别对应不同类型异常。可分为两类：Checked异常和Runtime异常</li></ul><h1 id="和equals的区别和联系"><a href="#和equals的区别和联系" class="headerlink" title="&#x3D;&#x3D;和equals的区别和联系"></a>&#x3D;&#x3D;和equals的区别和联系</h1><ul><li>“&#x3D;&#x3D;”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</li><li>“&#x3D;&#x3D;”使用情况如下：<ul><li>基本类型，比较的是值</li><li>引用类型，比较的是地址</li><li>不能比较没有父子关系的两个对象</li></ul></li><li>equals()方法使用如下：<ul><li>系统类一般已经覆盖了equals()，比较的是内容。</li><li>用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this &#x3D;&#x3D; obj);）</li><li>用户自定义类需要覆盖父类的equals()</li></ul></li><li>注意：Object的&#x3D;&#x3D;和equals比较的都是地址，作用相同</li></ul><h1 id="继承条件下构造方法的执行过程"><a href="#继承条件下构造方法的执行过程" class="headerlink" title="继承条件下构造方法的执行过程"></a>继承条件下构造方法的执行过程</h1><ul><li>继承条件下构造方法的调用规则如下：<ul><li>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</li><li>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li><li>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</li></ul></li><li>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li></ul><h1 id="权限修饰符的区别"><a href="#权限修饰符的区别" class="headerlink" title="权限修饰符的区别"></a>权限修饰符的区别</h1><ul><li>类的访问权限只有两种<ul><li>public 公共的 可被同一项目中所有的类访问。 (必须与文件名同名)</li><li>default 默认的 可被同一个包中的类访问。</li></ul></li><li>成员（成员变量或成员方法）访问权限共有四种：<ul><li>public 公共的 可以被项目中所有的类访问。(项目可见性)</li><li>protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）</li><li>default 默认的被这个类本身访问；被同一个包中的类访问。（包可见性）</li><li>private 私有的只能被这个类本身访问。（类可见性）</li></ul></li></ul><h1 id="final和abstract关键字的作用"><a href="#final和abstract关键字的作用" class="headerlink" title="final和abstract关键字的作用"></a>final和abstract关键字的作用</h1><ul><li>final和abstract是功能相反的两个关键字，可以对比记忆</li><li>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</li><li>final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</li><li>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li></ul><h1 id="static关键字的作用（修饰变量、方法、代码块）"><a href="#static关键字的作用（修饰变量、方法、代码块）" class="headerlink" title="static关键字的作用（修饰变量、方法、代码块）"></a>static关键字的作用（修饰变量、方法、代码块）</h1><ul><li>static可以修饰变量、方法、代码块和内部类</li><li>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</li><li>static变量和非static变量的区别(都是成员变量，不是局部变量)<ul><li>在内存中份数不同<ul><li>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</li><li>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</li></ul></li><li>在内存中存放的位置不同<ul><li>静态变量存在方法区中，实例变量存在堆内存中</li></ul></li><li>访问的方式不同<ul><li>实例变量： 对象名.变量名 stu1.name&#x3D;”小明明”;</li><li>静态变量：对象名.变量名 stu1.schoolName&#x3D;”西二旗小学”; 不推荐如此使用</li><li>类名.变量名 Student.schoolName&#x3D;”东三旗小学”; 推荐使用</li></ul></li><li>在内存中分配空间的时间不同<ul><li>实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候</li><li>Student.schoolName&#x3D;”东三旗小学”;或者Student stu1 &#x3D; new Student(“小明”,”男”,20,98);</li><li>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</li><li>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</li><li>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员</li></ul></li></ul></li></ul><h1 id="this和super关键字的作用"><a href="#this和super关键字的作用" class="headerlink" title="this和super关键字的作用"></a>this和super关键字的作用</h1><ul><li>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题</li><li>this可以调用成员变量，不能调用局部变量</li><li>this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句，而且在静态方法当中不允许出现this关键字。</li><li>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</li><li>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</li></ul><h1 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h1><ul><li>面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li><li>封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</li><li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</li></ul><h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><ul><li>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</li><li>类和对象好比图纸和实物的关系，模具和铸件的关系。</li></ul><h1 id="可变参数的作用和特点"><a href="#可变参数的作用和特点" class="headerlink" title="可变参数的作用和特点"></a>可变参数的作用和特点</h1><ul><li>可变参数<ul><li>可变参数的形式 …</li><li>可变参数只能是方法的形参</li><li>可变参数对应的实参可以0,1,2…..个，也可以是一个数组</li><li>在可变参数的方法中，将可变参数当做数组来处理</li><li>可变参数最多有一个，只能是最后一个</li><li>可变参数好处：方便 简单 减少重载方法的数量</li><li>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</li></ul></li><li>数组做形参和可变参数做形参联系和区别</li><li>联系：<br>-实参都可以是数组；2.方法体中，可变参数当做数组来处理</li><li>区别：<ul><li>个数不同	可变参数只能有一个数组参数可以多个</li><li>位置不同	可变参数只能是最后一个	数组参数位置任意</li><li>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</li></ul></li></ul><h1 id="递归的定义和优缺点"><a href="#递归的定义和优缺点" class="headerlink" title="递归的定义和优缺点"></a>递归的定义和优缺点</h1><ul><li>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</li><li>递归算法解决问题的特点：<ul><li>递归就是在过程或函数里调用自身。</li><li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li><li>递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</li><li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</li></ul></li></ul><h1 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h1><ul><li>break: 结束当前循环并退出当前循环体。</li><li>break还可以退出switch语句</li><li>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。</li></ul><h1 id="while和do-while循环的区别"><a href="#while和do-while循环的区别" class="headerlink" title="while和do-while循环的区别"></a>while和do-while循环的区别</h1><ul><li>while先判断后执行，第一次判断为false,循环体一次都不执行</li><li>do while先执行 后判断，最少执行1次。</li><li>如果while循环第一次判断为true, 则两种循环没有区别。</li></ul><h1 id="用最有效率的方法算出2乘以8等于多少"><a href="#用最有效率的方法算出2乘以8等于多少" class="headerlink" title="用最有效率的方法算出2乘以8等于多少"></a>用最有效率的方法算出2乘以8等于多少</h1><ul><li>使用位运算来实现效率最高</li><li>位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数</li><li>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高</li><li>所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</li></ul><h1 id="和-的区别和联系，-和-的区别和联系"><a href="#和-的区别和联系，-和-的区别和联系" class="headerlink" title="&amp;和&amp;&amp;的区别和联系，|和||的区别和联系"></a>&amp;和&amp;&amp;的区别和联系，|和||的区别和联系</h1><ul><li>&amp;和&amp;&amp;的联系(共同点)：<ul><li>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</li><li>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</li><li>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</li><li>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li><li>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li><li>表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</li></ul></li><li>&amp;和&amp;&amp;的区别(不同点)<ul><li>&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。</li><li>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</li><li>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</li><li>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</li><li>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</li></ul></li><li>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</li></ul><h1 id="i-和-i的异同之处"><a href="#i-和-i的异同之处" class="headerlink" title="i++和++i的异同之处"></a>i++和++i的异同之处</h1><ul><li>共同点：<ul><li>i++和++i都是变量自增1，都等价于i&#x3D;i+1</li><li>如果i++,++i是一条单独的语句，两者没有任何区别</li><li>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</li></ul></li><li>不同点：<ul><li>如果i++,++i不是一条单独的语句，他们就有区别</li><li>i++ ：先运算后增1。如：int x&#x3D;5;</li><li>int y&#x3D;x++;</li><li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li><li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;5++i ： 先增1后运算。如：</li><li>int x&#x3D;5;</li><li>int y&#x3D;++x;</li><li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li><li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;6334.</li></ul></li></ul><h1 id="JDK-JRE-JVM三者关系概括如下："><a href="#JDK-JRE-JVM三者关系概括如下：" class="headerlink" title="JDK,JRE,JVM三者关系概括如下："></a>JDK,JRE,JVM三者关系概括如下：</h1><ul><li>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE</li><li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了</li><li>JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li></ul><h1 id="Java跨平台原理"><a href="#Java跨平台原理" class="headerlink" title="Java跨平台原理"></a>Java跨平台原理</h1><ul><li>C&#x2F;C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</li><li>Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</li><li>字节码文件不面向任何具体平台，只面向虚拟机。</li><li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li><li>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C&#x2F;C++要低。</li><li>Java的跨平台原理决定了其性能没有C&#x2F;C++高</li></ul><h1 id="Java的安全性"><a href="#Java的安全性" class="headerlink" title="Java的安全性"></a>Java的安全性</h1><ul><li>语言层次的安全性主要体现在：<ul><li>Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</li><li>垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。</li><li>异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</li><li>强制类型转换：只有在满足强制转换规则的情况下才能强转成功。</li></ul></li><li>底层的安全性可以从以下方面来说明<ul><li>Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。</li></ul></li><li>在运行环境提供了四级安全性保障机制：<ul><li>字节码校验器 -类装载器 -运行时内存布局 -文件访问限制</li></ul></li></ul><h1 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h1><ul><li>对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术</li><li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（可以用XML或者是注解），将Java程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</li></ul><h1 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h1><ul><li>DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作</li><li>为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中</li><li>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法</li><li>在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储</li><li>DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</li></ul><h1 id="UML是什么？UML中有哪些图？"><a href="#UML是什么？UML中有哪些图？" class="headerlink" title="UML是什么？UML中有哪些图？"></a>UML是什么？UML中有哪些图？</h1><ul><li>UML是统一建模语言（Unified Modeling Language）的缩写，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为</li><li>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等</li><li>在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</li></ul><h1 id="Java-中有几种类型的流？"><a href="#Java-中有几种类型的流？" class="headerlink" title="Java 中有几种类型的流？"></a>Java 中有几种类型的流？</h1><ul><li>两种流分别是字节流，字符流。</li><li>字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer</li><li>在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</li><li>关于Java的IO需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</li></ul><h1 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h1><ul><li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间</li><li>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</li><li>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</li></ul><h1 id="什么时候用assert？"><a href="#什么时候用assert？" class="headerlink" title="什么时候用assert？"></a>什么时候用assert？</h1><ul><li>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制</li><li>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。</li></ul><h1 id="比较一下Java-和JavaSciprt"><a href="#比较一下Java-和JavaSciprt" class="headerlink" title="比较一下Java 和JavaSciprt"></a>比较一下Java 和JavaSciprt</h1><ul><li>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。</li><li>下面对两种语言间的异同作如下比较：<ul><li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</li><li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</li><li>代码格式不一样。</li></ul></li><li>上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</li></ul><p> </p><h1 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h1><ul><li><p>代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;你好&quot;;</span><br><span class="line">String s2 = newString(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); </span><br></pre></td></tr></table></figure></li><li><p>在String类的构造方法当中，存在一个字符集设置的方法</p></li></ul><h1 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h1><ul><li>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</li><li>如果要访问外部类的局部变量，此时局部变量必须使用final修饰，否则无法访问。</li></ul><h1 id="匿名内部类是否可以继承其它类？是否可以实现接口？"><a href="#匿名内部类是否可以继承其它类？是否可以实现接口？" class="headerlink" title="匿名内部类是否可以继承其它类？是否可以实现接口？"></a>匿名内部类是否可以继承其它类？是否可以实现接口？</h1><ul><li>可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。</li></ul><h1 id="一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h1><ul><li>可以，但一个源文件中最多只能有一个公开类（public class）</li><li>而且文件名必须和公开类的类名完全保持一致。</li></ul><p> </p><h1 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h1><ul><li>接口可以继承接口</li><li>抽象类可以实现(implements)接口，抽象类可以继承具体类</li><li>抽象类中可以有静态的main方法。</li></ul><h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><ul><li>有两种方式：<ul><li>实现Cloneable接口并重写Object类中的clone()方法；</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</li></ul></li><li>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</li></ul><h1 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h1><ul><li>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</li></ul><p> </p><h1 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h1><ul><li>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝</li><li>实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存</li><li>两者的相同点：都有默认值而且在类的任何地方都可以调用</li></ul><h1 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h1><ul><li>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的</li><li>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li><li>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li></ul><h1 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h1><ul><li>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）</li><li>然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露</li><li>一个例子就是hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象</li></ul><h1 id="静态内部类和内部类有什么区别"><a href="#静态内部类和内部类有什么区别" class="headerlink" title="静态内部类和内部类有什么区别"></a>静态内部类和内部类有什么区别</h1><ul><li>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</li><li>内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</li><li>在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类</li><li>Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class</li><li>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</li><li>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化</li></ul><h1 id="char-型变量中能不能存贮一个中文汉字-为什么"><a href="#char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char 型变量中能不能存贮一个中文汉字?为什么?"></a>char 型变量中能不能存贮一个中文汉字?为什么?</h1><ul><li>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦</li></ul><h1 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h1><ul><li>是值传递</li><li>Java 编程语言只有值传递参数</li><li>当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用</li><li>对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。</li></ul><h1 id="是否可以继承String-类"><a href="#是否可以继承String-类" class="headerlink" title="是否可以继承String 类?"></a>是否可以继承String 类?</h1><ul><li>String 类是final类，不可以被继承。</li></ul><h1 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</h1><ul><li>不对</li><li>如果两个对象x和y满足x.equals(y) &#x3D;&#x3D;++++ true，它们的哈希码（hash code）应当相同</li><li>Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同</li></ul><h1 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）?"></a>构造器（constructor）是否可被重写（override）?</h1><ul><li>构造器不能被继承，因此不能被重写，但可以被重载。</li></ul><h1 id="在Java-中，如何跳出当前的多重嵌套循环？"><a href="#在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java 中，如何跳出当前的多重嵌套循环？"></a>在Java 中，如何跳出当前的多重嵌套循环？</h1><ul><li>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</li><li>Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好</li></ul><h1 id="数组有没有length-方法-String-有没有length-方法？"><a href="#数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="数组有没有length()方法?String 有没有length()方法？"></a>数组有没有length()方法?String 有没有length()方法？</h1><ul><li>数组没有length()方法，有length 的属性</li><li>String 有length()方法</li><li>JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</li></ul><h1 id="swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h1><ul><li>早期的JDK中，switch（expr）中，expr可以是byte、short、char、int</li><li>从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举</li><li>从JDK 1.7版开始，还可以是字符串（String）</li><li>长整型（long）是不可以的。</li></ul><h1 id="Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?"></a>Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h1><ul><li>Math.round(11.5)的返回值是12</li><li>Math.round(-11.5)的返回值是-11</li><li>四舍五入的原理是在参数上加0.5然后进行下取整。</li></ul><p> </p><h1 id="解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h1><ul><li><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间</p></li><li><p>而通过new关键字和构造器创建的对象放在堆空间</p></li><li><p>程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中</p></li><li><p>栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“hello”);</span><br></pre></td></tr></table></figure></li><li><p>上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。</p></li><li><p>较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p></li></ul><h1 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h1><ul><li>&amp;运算符有两种用法<ul><li>按位与</li><li>逻辑与</li></ul></li><li>&amp;&amp;运算符是短路与运算</li><li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true</li><li>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</li><li>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常</li><li>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</li></ul><h1 id="Java-有没有goto"><a href="#Java-有没有goto" class="headerlink" title="Java 有没有goto?"></a>Java 有没有goto?</h1><ul><li>goto 是Java中的保留字，在目前版本的Java中没有使用</li><li>其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字</li></ul><h1 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?</h1><ul><li>对于short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型</li><li>而short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为s1+&#x3D; 1;相当于s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。</li></ul><h1 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确?"></a>float f&#x3D;3.4;是否正确?</h1><ul><li>不正确</li><li>3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成float f &#x3D;3.4F;。</li></ul><h1 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h1><ul><li>不是</li><li>Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</li></ul><h1 id="访问修饰符的区别？"><a href="#访问修饰符的区别？" class="headerlink" title="访问修饰符的区别？"></a>访问修饰符的区别？</h1><table><thead><tr><th>作用域</th><th>当前类</th><th>同包</th><th>子类</th><th>其他</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</li></ul><p> </p><h1 id="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><a href="#如果变量用final修饰，则怎样？如果方法final修饰，则怎样？" class="headerlink" title="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"></a>如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</h1><ul><li>用final修饰的类不能被扩展，也就是说不可能有子类；</li><li>用final修饰的方法不能被替换或隐藏：<ul><li>使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</li><li>使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏	（hidden）；</li></ul></li><li>用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：<ul><li>静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量， 赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，	赋值只能在其声明中通过初始化表达式完成；</li><li>实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通	过初始化表达式完成，也可以在实例初始化块或构造器中进行；</li><li>方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体	（body）结束，在此期间其值不能改变；</li><li>构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，	同时被初始化为对应实参值，终止于构造器体结束，在此期间其值不能改变；</li><li>异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化	为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</li><li>局部变量在其值被访问之前必须被明确赋值；</li></ul></li></ul><h1 id="成员变量用static修饰和不用static修饰有什么区别？"><a href="#成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="成员变量用static修饰和不用static修饰有什么区别？"></a>成员变量用static修饰和不用static修饰有什么区别？</h1><ul><li>两个变量的生命周期不同。<ul><li>成员变量随着对象的创建而存在，随着对象的被回收而释放。</li><li>静态变量随着类的加载而存在，随着类的消失而消失。</li></ul></li><li>调用方式不同。<ul><li>成员变量只能被对象调用。</li><li>静态变量可以被对象调用，还可以被类名调用。</li><li>对象调用：p.country</li><li>类名调用 ：Person.country</li></ul></li><li>别名不同。<ul><li>成员变量也称为实例变量。</li><li>静态变量称为类变量。</li></ul><p> </p></li><li>数据存储位置不同。<ul><li>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.</li><li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.</li></ul></li></ul><h1 id="System-out-println-‘a’-1-的结果是"><a href="#System-out-println-‘a’-1-的结果是" class="headerlink" title="System.out.println(‘a’+1);的结果是"></a>System.out.println(‘a’+1);的结果是</h1><ul><li>‘a’是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98</li></ul><h1 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h1><ul><li>NullPointerException：一般都是在null对象上调用方法了。</li><li>NumberFormatException：继承IllegalArgumentException，字符串转换为数字时。</li><li>StringIndexOutOfBoundsException：字符串越界</li><li>ClassCastException:类型转换错误</li></ul><h1 id="200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><a href="#200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？" class="headerlink" title="200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"></a>200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</h1><ul><li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li><li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序</li><li>Collections 工具类的sort方法有两种重载的形式<ul><li>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul></li></ul><h1 id="199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><a href="#199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？" class="headerlink" title="199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"></a>199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</h1><ul><li>构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法</li></ul><h1 id="char型变量中能不能存储一个中文汉字？"><a href="#char型变量中能不能存储一个中文汉字？" class="headerlink" title="char型变量中能不能存储一个中文汉字？"></a>char型变量中能不能存储一个中文汉字？</h1><ul><li>java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。</li><li>char 在java中是2个字节，所以可以存储中文</li></ul><h1 id="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"><a href="#创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。" class="headerlink" title="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"></a>创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</h1><ul><li>用一个for循环创建线程对象并调用start方法启动线程。</li></ul><h1 id="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><a href="#Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？" class="headerlink" title="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"></a>Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</h1><ul><li>Map的实现类有HashMap,LinkedHashMap,TreeMap</li><li>HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序；TreeMap默认是自然升序）</li><li>LinkedHashMap底层存储结构是哈希表+链表，链表记录了添加数据的顺序</li><li>TreeMap底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性</li><li>LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表</li></ul><h1 id="try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？"><a href="#try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？" class="headerlink" title="try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？"></a>try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？</h1><ul><li>在异常处理时提供 finally 块来执行任何清除操作。</li><li>如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。</li><li>finally中语句不执行的唯一情况中执行了System.exit(0)语句。</li></ul><h1 id="什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>什么是编译型语言，什么是解释型语言？java可以归类到那种？</h1><ul><li>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。</li><li>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。</li><li>解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。</li><li>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C&#x2F;C++、Pascal&#x2F;Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。</li><li>JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</li></ul><h1 id="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h1><ul><li>final修饰基本类型变量，其值不能改变。</li><li>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li></ul><h1 id="Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="Class类的getDeclaredFields()方法与getFields()的区别？"></a>Class类的getDeclaredFields()方法与getFields()的区别？</h1><ul><li>getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法</li><li>getFields(): 只能获取所有public声43明的方法, 包括继承的方法</li></ul><h1 id="103-可序列化对象为什么要定义serialversionUID值"><a href="#103-可序列化对象为什么要定义serialversionUID值" class="headerlink" title="103.可序列化对象为什么要定义serialversionUID值?"></a>103.可序列化对象为什么要定义serialversionUID值?</h1><ul><li>SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容</li><li>如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常</li><li>如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</li></ul><h1 id="GC线程是否为守护线程？"><a href="#GC线程是否为守护线程？" class="headerlink" title="GC线程是否为守护线程？"></a>GC线程是否为守护线程？</h1><ul><li>GC线程是守护线程</li><li>线程分为守护线程和非守护线程（即用户线程）。只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。</li></ul><h1 id="不通过构造函数也能创建对象么"><a href="#不通过构造函数也能创建对象么" class="headerlink" title="不通过构造函数也能创建对象么"></a>不通过构造函数也能创建对象么</h1><ul><li>是</li><li>Java创建对象的几种方式：<ul><li>用new语句创建对象，这是最常见的创建对象的方法。</li><li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li><li>调用对象的clone()方法。</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li></ul></li><li>(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。</li></ul><h1 id="同步代码块和同步方法有什么区别"><a href="#同步代码块和同步方法有什么区别" class="headerlink" title="同步代码块和同步方法有什么区别"></a>同步代码块和同步方法有什么区别</h1><ul><li>相同点：同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为this，那么同步方法和同步代码块没有太大的区别。</li><li>区别：同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</li></ul><h1 id="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><a href="#Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？" class="headerlink" title="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"></a>Java中，如果Manager是Employee的子类，那么Pair<manager>是Pair<employee>的子类吗？</employee></manager></h1><ul><li>不是，两者没有任何关联。</li></ul><h1 id="简述Java中如何实现多态"><a href="#简述Java中如何实现多态" class="headerlink" title="简述Java中如何实现多态"></a>简述Java中如何实现多态</h1><ul><li>实现多态有三个前提条件：<ul><li>继承的存在；（继承是多态的基础，没有继承就没有多态）。</li><li>子类重写父类的方法。（多态下会调用子类重写后的方法）。</li><li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</li></ul></li><li>最后使用父类的引用变量调用子类重写的方法即可实现多态。</li></ul><h1 id="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h1><ul><li>在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt;K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt;K, V&gt;可以理解为HashMap&lt;Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型</li><li>引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。</li></ul><h1 id="对象在虚拟机的大小中可不可以用size-of取出。"><a href="#对象在虚拟机的大小中可不可以用size-of取出。" class="headerlink" title="对象在虚拟机的大小中可不可以用size of取出。"></a>对象在虚拟机的大小中可不可以用size of取出。</h1><ul><li>可以</li></ul><h1 id="什么是-JMS？"><a href="#什么是-JMS？" class="headerlink" title="什么是 JMS？"></a>什么是 JMS？</h1><ul><li>JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。</li></ul><h1 id="JMS-有哪些模型？"><a href="#JMS-有哪些模型？" class="headerlink" title="JMS 有哪些模型？"></a>JMS 有哪些模型？</h1><ul><li>JMS 消息机制主要分为两种模型：PTP 模型和 Pub&#x2F;Sub 模型。</li></ul><h4 id="PTP-模型"><a href="#PTP-模型" class="headerlink" title="PTP 模型"></a>PTP 模型</h4><ul><li>（Point to Point 对点模型) 每一个消息传递给一个消息消费者，保证消息传递给消息消费者，且消息不会同时被多个消费者接收。如果消息消费者暂时不在连接范围内，JMS 会自动保证消息不会丢失，直到消息消费者进入连接，消息将自动送达。因此，JMS 需要将消息保存到永久性介质上，例如数据库或者文件。</li></ul><h4 id="Pub-Sub-模型"><a href="#Pub-Sub-模型" class="headerlink" title="Pub-Sub 模型"></a>Pub-Sub 模型</h4><ul><li>(publish-subscription 发布者订阅者模型)每个主题可以拥有多个订阅者。JMS 系统负责将消息的副本传给该主题的每个订阅者。如果希望每一条消息都能够被处理，那么应该使用 PTP 消息模型。如果并不要求消息都必须被消息消费者接收到的情况下，可使用 pub-sub 消息模型。Pub-Sub 模型可以在一对多的消息广播时使用。</li></ul><h1 id="为什么不能根据返回类型来区分重载，为什么？"><a href="#为什么不能根据返回类型来区分重载，为什么？" class="headerlink" title="为什么不能根据返回类型来区分重载，为什么？"></a>为什么不能根据返回类型来区分重载，为什么？</h1><ul><li>方法的重载，即使返回值类型不同，也不能改变实现功能相同或类似这一既定事实</li><li>同时方法的重载只是要求两同三不同，即在同一个类中，相同的方法名称，参数列表当中的参数类型、个数、顺序不同；跟权限修饰符和返回值类无关</li></ul><h1 id="Java-中-byte-表示的数值范围是什么？"><a href="#Java-中-byte-表示的数值范围是什么？" class="headerlink" title="Java 中 byte 表示的数值范围是什么？"></a>Java 中 byte 表示的数值范围是什么？</h1><ul><li>范围是-128 至 127</li></ul><h1 id="在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？"><a href="#在-switch-和-if-else-语句之间进行选取，当控制选择的条件，不仅仅依赖于一个-x-时，应该使用-switch-结构；正确么？" class="headerlink" title="在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？"></a>在 switch 和 if-else 语句之间进行选取，当控制选择的条件，不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？</h1><ul><li>不正确。</li><li>通常情况下，进行比较判断的处理，switch 和 if-else 可以互相转换来写；</li><li>if-else 作用的范围比 switch-case 作用范围要大，但是当 switch-case 和 if-else 都可以用的情况下，通常推荐使用 switch-case。</li></ul><h1 id="Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？"><a href="#Java-程序中创建新的类对象，使用关键字-new，回收无用的类对象使用关键字-free-正确么？" class="headerlink" title="Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？"></a>Java 程序中创建新的类对象，使用关键字 new，回收无用的类对象使用关键字 free 正确么？</h1><ul><li>Java 程序中创建新的类对象，使用关键字 new 是正确的</li><li>回收无用的类对象使用关键字 free 是错误的.</li></ul><h1 id="存在使-i-1"><a href="#存在使-i-1" class="headerlink" title="存在使 i+1&lt;i 的数么?"></a>存在使 i+1&lt;i 的数么?</h1><ul><li>存在, int 的最大值, 加 1 后变为负数.</li></ul><h1 id="Java-中-Math-random（）-Math-random（）值为？"><a href="#Java-中-Math-random（）-Math-random（）值为？" class="headerlink" title="Java 中 Math.random（）&#x2F; Math.random（）值为？"></a>Java 中 Math.random（）&#x2F; Math.random（）值为？</h1><ul><li>如果除数与被除数均不为 0.0 的话，则取值范围为[0, +∞]。+∞在 Java 中显示的结果为 Infinity。</li><li>如果除数与被除数均为 0.0 的话，则运行结果为 NaN（Not a Number 的简写），计算错误。</li></ul><h1 id="匿名内部类可不可以继承或实现接口。为什么？"><a href="#匿名内部类可不可以继承或实现接口。为什么？" class="headerlink" title="匿名内部类可不可以继承或实现接口。为什么？"></a>匿名内部类可不可以继承或实现接口。为什么？</h1><ul><li>匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现.</li><li>由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把<br>创建对象的任务交给了父类去完成。</li><li>在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。</li><li>因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。</li></ul><h1 id="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？"><a href="#说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java-程序中如何检测？如何解决？" class="headerlink" title="说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？"></a>说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java 程序中如何检测？如何解决？</h1><ul><li>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；比如申请了一个 integer,但给它存了long 才能存下的数，那就是内存溢出。</li><li>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li><li>memory leak 会最终会导致 out of memory！</li></ul><h1 id="为什么为基本类型引入包装类"><a href="#为什么为基本类型引入包装类" class="headerlink" title="为什么为基本类型引入包装类"></a>为什么为基本类型引入包装类</h1><ul><li>基本数据类型有方便之处，简单、高效。</li><li>但是 Java 中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多的不便（比如集合的元素只能是 Object）。</li><li>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</li><li>包装类和基本数据类型之间的转换<ul><li>包装类—— wrapperInstance.xxxValue() ——&gt;基本数据类型</li><li>包装类——-new WrapperClass(primitive) new WrapperClass(string)——基本数据类型</li></ul></li><li>自动装箱和自动拆箱<ul><li>JDK1.5 提供了自动装箱（autoboxing）和自动拆箱（autounboxing）功能, 从而实现了包装类和基本数据类型之间的自动转换</li></ul></li><li>包装类还可以实现基本类型变量和字符串之间的转换<ul><li>基本类型变量&lt;————String.valueof()————&gt;字符串</li><li>基本类型变量&lt;————WrapperClass.parseXxx(string)————字符串</li></ul></li></ul><h1 id="谈谈-Java-的多态"><a href="#谈谈-Java-的多态" class="headerlink" title="谈谈 Java 的多态"></a>谈谈 Java 的多态</h1><ul><li>实现多态的三个条件（前提条件，向上转型、向下转型）<ul><li>继承的存在；（继承是多态的基础，没有继承就没有多态）</li><li>子类重写父类的方法。（多态下会调用子类重写后的方法）</li><li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）</li></ul></li><li>向上转型 Student person &#x3D; new Student()</li><li>将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。</li><li>此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法此时通过父类引用变量无法调用子类特有的方法。</li><li>向下转型 Student stu &#x3D; (Student)person;</li><li>将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类型，否则将出现 ClassCastException，不是任意的强制转换向下转型时可以结合使用 instanceof 运算符进行强制类型转换，比如出现转换异常—ClassCastException</li></ul><h1 id="if-多分支语句和-switch-多分支语句的异同之处"><a href="#if-多分支语句和-switch-多分支语句的异同之处" class="headerlink" title="if 多分支语句和 switch 多分支语句的异同之处"></a>if 多分支语句和 switch 多分支语句的异同之处</h1><ul><li>相同之处：都是分支语句，多超过一种的情况进行判断处理。</li><li>不同之处：<ul><li>switch 更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有 break 跳出），不加判断地执行下去;而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。</li><li>switch 为等值判断（不允许比如&gt;&#x3D; &lt;&#x3D;），而 if 为等值和区间都可以，if 的使用范围大。</li></ul></li></ul><h1 id="基本数据类型的类型转换规则"><a href="#基本数据类型的类型转换规则" class="headerlink" title="基本数据类型的类型转换规则"></a>基本数据类型的类型转换规则</h1><ul><li>基本类型转换分为自动转换和强制转换。</li><li>自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的<br>范围。</li><li>强制转换规则：高级变为低级需要强制转换。</li><li>如何转换：<ul><li>赋值运算符“&#x3D;”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</li><li>赋值运算符“&#x3D;”两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 &#x3D;&#x3D; 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li><li>可以将整型常量直接赋值给 byte, short, char 等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li></ul></li></ul><h1 id="Java-三种注释类型"><a href="#Java-三种注释类型" class="headerlink" title="Java 三种注释类型"></a>Java 三种注释类型</h1><ul><li>共有单行注释、多行注释、文档注释 3 种注释类型</li></ul><h1 id="谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么"><a href="#谈谈你对Java平台的理解-“Java-是解释执行”-这句话正确么" class="headerlink" title="谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?"></a>谈谈你对Java平台的理解? “Java 是解释执行”,这句话正确么?</h1><ul><li>Java本身是一种面向对象的语言,最显著的特点有两个方面,一个是所谓的”书写一次,到处运行”;能够非常容易地获得跨平台能力;另外就是垃圾收集器(GC)，Java通过垃圾收集器回收分配内存,大部分情况下,程序员不需要自己操心内存的分配和回收。我们日常接触到JRE或者JDK。JRE也就是Java运行环境,包含了JVM和Java类库,以及一些模块等。而JDK可以看作是JRE的一个超集,提供了更多的工具,比如编译器 各种诊断工具。</li><li>“对于Java是解释执行”这句话,这个说法不准确。我们开发的Java的源代码,首先通过Javac编译成为字节码,然后在运行时通过Java虚拟机内嵌的解释器将字节码转换为最终的机器码。但是常见的JVM,比如我们大数据情况使用的Oracle JDK提供的HostpotJVM,提供了JIT编译器,就是通常所说的动态编译器,JIT能够在运行时将热点代码(高频调用的方法和代码块)编译成机器码,这种情况下部分热点就属于编译执行,而不是解释执行。这样类似于缓存技术,运行时在遇到热点代码可以直接执行,而不是先解释在执行。</li></ul><h1 id="NoClassDeFoundError和ClassNotFoundException的区别"><a href="#NoClassDeFoundError和ClassNotFoundException的区别" class="headerlink" title="NoClassDeFoundError和ClassNotFoundException的区别?"></a>NoClassDeFoundError和ClassNotFoundException的区别?</h1><ul><li>首先NoClassDeFoundError是一个错误,ClassNotFoundException是一个异常。ClassNotFoundException的产生原因,Java支持使用Class.froName方法来动态地加载类,任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中,如果这个类在类路径中没有被找到,那么此时就会在运行时抛出ClassNotFoundException异常。另外还有一个导致ClassNotFoundException的原因就是,当一个类已经被某个类加载器加载到内存中,此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</li><li>NoClassDeFoundError产生的原因在于:如果JVM或者ClassLoader实例尝试加载类的时候找不到类的定义。例如要查找的类在编译的时候是存在的,运行的时候找不到了。这个时候就会导致NoClassDefFoundError。造成该问题的原因可能是打包过程中漏掉了部分类,或者jar包出现损坏或者篡改。解决这个问题的办法就是查找那些在开发期间存在与类路径下,但在运行期间却不在类路径下的类。</li></ul><h1 id="一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数"><a href="#一个-subclass-怎样调用-superclass-中的方法（myMethod）和构造函数" class="headerlink" title="一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?"></a>一个 subclass 怎样调用 superclass 中的方法（myMethod）和构造函数?</h1><ul><li>用 super 关键字,子类去调用父类的方法，如：super.myMethod();子类去调用父类的构造函数，如：super()</li></ul><h1 id="Bit-和-Byte-是什么意思-它们之间有什么关系"><a href="#Bit-和-Byte-是什么意思-它们之间有什么关系" class="headerlink" title="Bit 和 Byte 是什么意思?它们之间有什么关系?"></a>Bit 和 Byte 是什么意思?它们之间有什么关系?</h1><ul><li>bit 中文名称是位，是用以描述电脑数据量的最小单位。</li><li>byte（字节）是计算机信息技术用于计量存储容量和传输容量的一种计量单位 1byte&#x3D;8bit</li></ul><h1 id="什么是-java-序列化，如何实现-java-序列化？"><a href="#什么是-java-序列化，如何实现-java-序列化？" class="headerlink" title="什么是 java 序列化，如何实现 java 序列化？"></a>什么是 java 序列化，如何实现 java 序列化？</h1><ul><li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；</li><li>序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream) 来 构 造 一 个 ObjectOutputStream( 对 象 流 ) 对 象 ， 接 着 ， 使 用ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。</li></ul><h1 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h1><ul><li>Lambda表达式的本质只是一个”语法糖”,由编译器推断并帮我们转换包装为常规的代码,因此我们可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘。</li><li>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许我们通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。</li><li>Lambda表达式还增强了集合库。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。</li></ul><h1 id="获取用键盘输入常用的的两种方法"><a href="#获取用键盘输入常用的的两种方法" class="headerlink" title="获取用键盘输入常用的的两种方法"></a>获取用键盘输入常用的的两种方法</h1><ul><li>通过 Scanner</li><li>通过 BufferedReader</li></ul><h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul><h1 id="JAVA-复制"><a href="#JAVA-复制" class="headerlink" title="JAVA 复制"></a>JAVA 复制</h1><ul><li>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</li></ul><h4 id="直接赋值复制"><a href="#直接赋值复制" class="headerlink" title="直接赋值复制"></a>直接赋值复制</h4><ul><li>直接赋值。在 Java 中，A a1 &#x3D; a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。</li></ul><h4 id="浅复制（复制引用但不复制引用的对象）"><a href="#浅复制（复制引用但不复制引用的对象）" class="headerlink" title="浅复制（复制引用但不复制引用的对象）"></a>浅复制（复制引用但不复制引用的对象）</h4><ul><li>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。</li><li>因此，原始对象及其副本引用同一个对象。</li></ul><h4 id="深复制（复制对象和其应用对象）"><a href="#深复制（复制对象和其应用对象）" class="headerlink" title="深复制（复制对象和其应用对象）"></a>深复制（复制对象和其应用对象）</h4><ul><li>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</li></ul><h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><ul><li>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List&lt;Object&gt;和 List&lt;String&gt;等类型，在编译之后</li><li>都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</li><li>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</li></ul><h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符?</h1><ul><li>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数</li><li>例 如 List&lt;?&gt; 在逻辑上是 List&lt;String&gt;,List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt;的父类。</li></ul><h1 id="创建对象的两种方法"><a href="#创建对象的两种方法" class="headerlink" title="创建对象的两种方法"></a>创建对象的两种方法</h1><ul><li>Class 对象的 newInstance()<ul><li>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</li></ul></li><li>调用 Constructor 对象的 newInstance()<ul><li>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</li></ul></li></ul><h1 id="Java-中，Serializable-与-Externalizable-的区别？"><a href="#Java-中，Serializable-与-Externalizable-的区别？" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别？"></a>Java 中，Serializable 与 Externalizable 的区别？</h1><ul><li>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</li></ul><h1 id="OOP-中的-组合、聚合和关联有什么区别？"><a href="#OOP-中的-组合、聚合和关联有什么区别？" class="headerlink" title="OOP 中的 组合、聚合和关联有什么区别？"></a>OOP 中的 组合、聚合和关联有什么区别？</h1><ul><li>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B组合的，则 A 不存在的话，B 一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</li></ul><h1 id="Java-中，嵌套公共静态类与顶级类有什么不同？"><a href="#Java-中，嵌套公共静态类与顶级类有什么不同？" class="headerlink" title="Java 中，嵌套公共静态类与顶级类有什么不同？"></a>Java 中，嵌套公共静态类与顶级类有什么不同？</h1><ul><li>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</li></ul><h1 id="继承和组合之间有什么不同？"><a href="#继承和组合之间有什么不同？" class="headerlink" title="继承和组合之间有什么不同？"></a>继承和组合之间有什么不同？</h1><ul><li>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</li></ul><h1 id="我们能自己写一个容器类，然后使用-for-each-循环码？"><a href="#我们能自己写一个容器类，然后使用-for-each-循环码？" class="headerlink" title="我们能自己写一个容器类，然后使用 for-each 循环码？"></a>我们能自己写一个容器类，然后使用 for-each 循环码？</h1><ul><li>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</li></ul><h1 id="写一段代码在遍历-ArrayList-时移除一个元素？"><a href="#写一段代码在遍历-ArrayList-时移除一个元素？" class="headerlink" title="写一段代码在遍历 ArrayList 时移除一个元素？"></a>写一段代码在遍历 ArrayList 时移除一个元素？</h1><ul><li>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</li></ul><h1 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a>Java 中的 HashSet，内部是如何工作的？</h1><ul><li>HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。</li></ul><h1 id="Java-中的-TreeMap-是采用什么树实现的？"><a href="#Java-中的-TreeMap-是采用什么树实现的？" class="headerlink" title="Java 中的 TreeMap 是采用什么树实现的？"></a>Java 中的 TreeMap 是采用什么树实现的？</h1><ul><li>Java 中的 TreeMap 是使用红黑树实现的。</li></ul><h1 id="Java-中的-LinkedList-是单向链表还是双向链表？"><a href="#Java-中的-LinkedList-是单向链表还是双向链表？" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表？"></a>Java 中的 LinkedList 是单向链表还是双向链表？</h1><ul><li>是双向链表，你可以检查 JDK 的源码</li></ul><h1 id="Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？</h1><ul><li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li></ul><h1 id="poll-方法和-remove-方法的区别？"><a href="#poll-方法和-remove-方法的区别？" class="headerlink" title="poll() 方法和 remove() 方法的区别？"></a>poll() 方法和 remove() 方法的区别？</h1><ul><li>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</li></ul><h1 id="Java-中的编译期常量是什么？使用它又什么风险？"><a href="#Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="Java 中的编译期常量是什么？使用它又什么风险？"></a>Java 中的编译期常量是什么？使用它又什么风险？</h1><ul><li>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</li></ul><h1 id="我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？"><a href="#我能在不进行强制转换的情况下将一个-double-值赋值给long-类型的变量吗？" class="headerlink" title="我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？"></a>我能在不进行强制转换的情况下将一个 double 值赋值给long 类型的变量吗？</h1><ul><li>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</li></ul><h1 id="3-0-1-0-3-将会返回什么？true-还是-false？"><a href="#3-0-1-0-3-将会返回什么？true-还是-false？" class="headerlink" title="3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？"></a>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？</h1><ul><li>false，因为有些浮点数不能完全精确的表示出来。</li></ul><h1 id="int-和-Integer-哪个会占用更多的内存？"><a href="#int-和-Integer-哪个会占用更多的内存？" class="headerlink" title="int 和 Integer 哪个会占用更多的内存？"></a>int 和 Integer 哪个会占用更多的内存？</h1><ul><li>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。</li><li>但是 int 是一个原始类型的数据，所以占用的空间更少。</li></ul><h1 id="为什么-Java-中的-String-是不可变的（Immutable）？"><a href="#为什么-Java-中的-String-是不可变的（Immutable）？" class="headerlink" title="为什么 Java 中的 String 是不可变的（Immutable）？"></a>为什么 Java 中的 String 是不可变的（Immutable）？</h1><ul><li>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。</li></ul><h1 id="我们能在-Switch-中使用-String-吗？"><a href="#我们能在-Switch-中使用-String-吗？" class="headerlink" title="我们能在 Switch 中使用 String 吗？"></a>我们能在 Switch 中使用 String 吗？</h1><ul><li>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</li></ul><h1 id="Java-中的构造器链是什么？"><a href="#Java-中的构造器链是什么？" class="headerlink" title="Java 中的构造器链是什么？"></a>Java 中的构造器链是什么？</h1><ul><li>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</li></ul><h1 id="什么是-Busy-spin？我们为什么要使用它？"><a href="#什么是-Busy-spin？我们为什么要使用它？" class="headerlink" title="什么是 Busy spin？我们为什么要使用它？"></a>什么是 Busy spin？我们为什么要使用它？</h1><ul><li>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。</li><li>所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</li></ul><h1 id="Swing-是线程安全的？"><a href="#Swing-是线程安全的？" class="headerlink" title="Swing 是线程安全的？"></a>Swing 是线程安全的？</h1><ul><li>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。</li><li>这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</li></ul><h1 id="什么是线程局部变量？"><a href="#什么是线程局部变量？" class="headerlink" title="什么是线程局部变量？"></a>什么是线程局部变量？</h1><ul><li>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</li></ul><h1 id="Java-中应该使用什么数据类型来代表价格？"><a href="#Java-中应该使用什么数据类型来代表价格？" class="headerlink" title="Java 中应该使用什么数据类型来代表价格？"></a>Java 中应该使用什么数据类型来代表价格？</h1><ul><li>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的double 类型。</li></ul><h1 id="怎么将-byte-转换为-String？"><a href="#怎么将-byte-转换为-String？" class="headerlink" title="怎么将 byte 转换为 String？"></a>怎么将 byte 转换为 String？</h1><ul><li>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</li></ul><h1 id="我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h1><ul><li>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。</li></ul><h1 id="哪个类包含-clone-方法？是-Cloneable-还是-Object？"><a href="#哪个类包含-clone-方法？是-Cloneable-还是-Object？" class="headerlink" title="哪个类包含 clone 方法？是 Cloneable 还是 Object？"></a>哪个类包含 clone 方法？是 Cloneable 还是 Object？</h1><ul><li>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由c 或 c++ 或 其他本地语言实现的。</li></ul><h1 id="Java-中-操作符是线程安全的吗？"><a href="#Java-中-操作符是线程安全的吗？" class="headerlink" title="Java 中 ++ 操作符是线程安全的吗？"></a>Java 中 ++ 操作符是线程安全的吗？</h1><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p><h1 id="a-a-b-与-a-b-的区别"><a href="#a-a-b-与-a-b-的区别" class="headerlink" title="a &#x3D; a + b 与 a +&#x3D; b 的区别"></a>a &#x3D; a + b 与 a +&#x3D; b 的区别</h1><ul><li>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是a +&#x3D; b 没问题，如下：<ul><li>byte a &#x3D; 127;</li><li>byte b &#x3D; 127;</li><li>b &#x3D; a + b; &#x2F;&#x2F; error : cannot convert from int to byte</li><li>b +&#x3D; a; &#x2F;&#x2F; ok</li></ul></li></ul><h1 id="什么是多线程环境下的伪共享（false-sharing）？"><a href="#什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="什么是多线程环境下的伪共享（false sharing）？"></a>什么是多线程环境下的伪共享（false sharing）？</h1><ul><li>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行</li></ul><h1 id="89、简述一下面向对象的”六原则一法则”。"><a href="#89、简述一下面向对象的”六原则一法则”。" class="headerlink" title="89、简述一下面向对象的”六原则一法则”。"></a>89、简述一下面向对象的”六原则一法则”。</h1><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</li><li>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</li><li>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</li><li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</li></ul><h1 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h1><ul><li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li></ul><h1 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h1><ul><li>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</li></ul><h1 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h1><ul><li>动态代理是运行时动态生成代理类。</li><li>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</li></ul><h1 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h1><ul><li>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</li></ul><h1 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h1><ul><li>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</li></ul><h1 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h1><ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul><h1 id="Java-中的异常处理机制的简单原理和应用。"><a href="#Java-中的异常处理机制的简单原理和应用。" class="headerlink" title="Java 中的异常处理机制的简单原理和应用。"></a>Java 中的异常处理机制的简单原理和应用。</h1><ul><li>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。</li><li>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。</li></ul><h1 id="Java-中的-LongAdder-和-AtomicLong-的区别"><a href="#Java-中的-LongAdder-和-AtomicLong-的区别" class="headerlink" title="Java 中的 LongAdder 和 AtomicLong 的区别"></a>Java 中的 LongAdder 和 AtomicLong 的区别</h1><ul><li>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进行了有效的分离，提高了并行度。</li></ul><h1 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h1><ul><li>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</li><li>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。</li></ul><h1 id="Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h1><ul><li>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。</li><li>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</li><li>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数。</li></ul><h1 id="请问-Query-接口的-list-方法和-iterate-方法有什么区别？"><a href="#请问-Query-接口的-list-方法和-iterate-方法有什么区别？" class="headerlink" title="请问 Query 接口的 list 方法和 iterate 方法有什么区别？"></a>请问 Query 接口的 list 方法和 iterate 方法有什么区别？</h1><ul><li>list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用 iterate()方法可以减少性能开销。</li><li>list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题</li></ul><h1 id="Java-的接口和-C-的虚类的相同和不同处。"><a href="#Java-的接口和-C-的虚类的相同和不同处。" class="headerlink" title="Java 的接口和 C++的虚类的相同和不同处。"></a>Java 的接口和 C++的虚类的相同和不同处。</h1><ul><li>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。</li><li>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。</li></ul><h1 id="Java-支持多继承么？"><a href="#Java-支持多继承么？" class="headerlink" title="Java 支持多继承么？"></a>Java 支持多继承么？</h1><ul><li>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</li></ul><h1 id="解释-extends-和-super-泛型限定符-上界不存下界不取"><a href="#解释-extends-和-super-泛型限定符-上界不存下界不取" class="headerlink" title="解释 extends 和 super 泛型限定符-上界不存下界不取"></a>解释 extends 和 super 泛型限定符-上界不存下界不取</h1><ul><li>泛型中上界和下界的定义<ul><li>上界 &lt;? extend Fruit&gt;</li><li>下界 &lt;? super Apple&gt;</li></ul></li><li>上界和下界的特点<ul><li>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）</li><li>下界的 list 只能 add，不能 get</li></ul></li><li>上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把所有的子类向上转型为 Fruit。</li><li>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接着呢，除了 Object，其他的都接不住。</li><li>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。</li><li>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引用就必须得用 cast。</li></ul><h1 id="”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？"><a href="#”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？" class="headerlink" title="”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？"></a>”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？</h1><ul><li>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</li><li>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。</li></ul><h1 id="你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？</h1><ul><li>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</li><li>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一个很好的说明。</li><li>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。</li><li>其函数表示是：<ul><li>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));</li><li>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。</li><li>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好的说明。</li></ul></li></ul><h1 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h1><ul><li>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</li><li>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递.</li></ul><h1 id="为啥有时会出现-4-0-3-6-0-40000001-这种现象？"><a href="#为啥有时会出现-4-0-3-6-0-40000001-这种现象？" class="headerlink" title="为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？"></a>为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？</h1><ul><li>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。</li></ul><h1 id="说说-Lamda-表达式的优缺点。"><a href="#说说-Lamda-表达式的优缺点。" class="headerlink" title="说说 Lamda 表达式的优缺点。"></a>说说 Lamda 表达式的优缺点。</h1><ul><li>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。</li><li>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</li></ul><h1 id="若对一个类不重写，它的-equals-方法是如何比较的？"><a href="#若对一个类不重写，它的-equals-方法是如何比较的？" class="headerlink" title="若对一个类不重写，它的 equals()方法是如何比较的？"></a>若对一个类不重写，它的 equals()方法是如何比较的？</h1><ul><li>比较是对象的地址。</li></ul><h1 id="比较的是什么？"><a href="#比较的是什么？" class="headerlink" title="&#x3D;&#x3D;比较的是什么？"></a>&#x3D;&#x3D;比较的是什么？</h1><ul><li>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。</li></ul><h1 id="Object-若不重写-hashCode-的话，hashCode-如何计算出来的？"><a href="#Object-若不重写-hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="Object 若不重写 hashCode()的话，hashCode()如何计算出来的？"></a>Object 若不重写 hashCode()的话，hashCode()如何计算出来的？</h1><ul><li>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。</li></ul><h1 id="Hash表的hash函数，冲突解决方法有哪些。"><a href="#Hash表的hash函数，冲突解决方法有哪些。" class="headerlink" title="Hash表的hash函数，冲突解决方法有哪些。"></a>Hash表的hash函数，冲突解决方法有哪些。</h1><ul><li>开放定址法或者叫再散列法；<ul><li>线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    - 二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    - 伪随机探测再散列：di&#x3D;伪随机序列；</li></ul></li><li>再哈希法；</li><li>拉链法。</li></ul><h1 id="分派：静态分派与动态分派。"><a href="#分派：静态分派与动态分派。" class="headerlink" title="分派：静态分派与动态分派。"></a>分派：静态分派与动态分派。</h1><ul><li>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的</li><li>动态分派：（重写）</li></ul><h1 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样?"></a>一个线程如果出现了运行时异常会怎么样?</h1><ul><li>如果该异常被捕获或抛出，则程序继续运行。 </li><li>如果异常没有被捕获该线程将会停止执行。 </li><li>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理</li></ul><h1 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h1><ul><li>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。</li></ul><h1 id="并发编程（concurrency）并行编程（parallellism）有什么区别？"><a href="#并发编程（concurrency）并行编程（parallellism）有什么区别？" class="headerlink" title="并发编程（concurrency）并行编程（parallellism）有什么区别？*"></a>并发编程（concurrency）并行编程（parallellism）有什么区别？*</h1><ul><li>并发（concurrency）和并行（parallellism）是：<ul><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群</li></ul></li></ul><h1 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h1><ul><li>只要退出了synchronized块，无论是正常还是异常，都会释放锁。</li></ul><h1 id="foreach与正常for循环效率对比"><a href="#foreach与正常for循环效率对比" class="headerlink" title="foreach与正常for循环效率对比"></a>foreach与正常for循环效率对比</h1><ul><li>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。</li></ul><h1 id="Static-class-与non-static-class的区别"><a href="#Static-class-与non-static-class的区别" class="headerlink" title="Static?class?与non?static?class的区别"></a>Static?class?与non?static?class的区别</h1><ul><li>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。</li><li>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。</li></ul><h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul><li>加载JDBC驱动程序</li><li>提供JDBC连接的URL</li><li>创建数据库的连接</li><li>创建一个Statement</li><li>执行SQL语句</li><li>处理结果</li><li>关闭JDBC对象</li></ul><h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul><li>方法名称相同，参数的类型或个数不同</li><li>方法名称、参数类型、返回值类型全部相同</li><li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li><li>范围 发生在一个类中 发生在继承类中</li><li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li><li>反射的应用很多，很多框架都有用到<ul><li>spring 的 ioc&#x2F;di 也是反射…</li><li>javaBean和jsp之间调用也是反射…</li><li>struts的 FormBean 和页面之间…也是通过反射调用…</li><li>JDBC 的 classForName()也是反射…</li><li>hibernate的 find(Class clazz) 也是反射…</li><li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/7e68be57c290.html" rel="prev" title="消息队列（MQ）"><i class="fa fa-angle-left"></i> 消息队列（MQ）</a></div><div class="post-nav-item"><a href="/publishes/52555cb3db5d.html" rel="next" title="Docker">Docker <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">453k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:52</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>