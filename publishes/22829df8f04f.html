<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="获得Class对象的⽅式 静态类的.class语法：GuideUtil.class 普通类对象的getClass()⽅法：new Test().getClass() 通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”); 对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE  在"><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/22829df8f04f.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="获得Class对象的⽅式 静态类的.class语法：GuideUtil.class 普通类对象的getClass()⽅法：new Test().getClass() 通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”); 对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE  在"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T01:28:17.000Z"><meta property="article:modified_time" content="2024-01-02T07:00:36.959Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="java"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/22829df8f04f.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/22829df8f04f.html","path":"publishes/22829df8f04f.html","title":"Java基础"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java基础 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%BD%85%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">获得Class对象的⽅式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">在 Java 中，为什么不允许从静态方法中访问非静态变量？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">在 Java 中，什么时候用重载，什么时候用重写？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%9B%B4%E5%80%BE%E5%90%91%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">举例说明什么情况下会更倾向于使用抽象类而不是接口？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class-forName%E7%9A%84%E4%BD%9C%E7%94%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">Class.forName的作用?为什么要用?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jdo%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.</span> <span class="nav-text">Jdo是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%EF%BC%8CHashTable-%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">HashMap ，HashTable 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashTable"><span class="nav-number">8.</span> <span class="nav-text">HashTable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9CHashMap%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%87%E4%BA%86%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90-load-factor-%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%B9%E9%87%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB%E4%B8%8EJavaBean%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">EJB与JavaBean的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81"><span class="nav-number">11.</span> <span class="nav-text">面向对象特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">11.0.0.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">11.0.0.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">11.0.0.3.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1"><span class="nav-number">11.0.0.4.</span> <span class="nav-text">抽象</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#final-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">final, finally, finalize 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final"><span class="nav-number">12.0.0.1.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally"><span class="nav-number">12.0.0.2.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finalize"><span class="nav-number">12.0.0.3.</span> <span class="nav-text">finalize</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">重载和重写的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#override%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89"><span class="nav-number">13.0.0.1.</span> <span class="nav-text">override（重写）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#overload%EF%BC%88%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="nav-number">13.0.0.2.</span> <span class="nav-text">overload（重载）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">抽象类和接口有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java1-7%E4%B8%8E1-8-1-9-10-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">15.</span> <span class="nav-text">Java1.7与1.8,1.9,10 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7"><span class="nav-number">15.0.0.1.</span> <span class="nav-text">1.7</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8"><span class="nav-number">15.0.0.2.</span> <span class="nav-text">1.8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9"><span class="nav-number">15.0.0.3.</span> <span class="nav-text">1.9</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E9%9D%A2%E5%85%B3%E4%BA%8EJ2EE%E7%9A%84%E5%90%8D%E8%AF%8D%EF%BC%9AJNDI%E3%80%81JDBC%E3%80%81JMS%E3%80%81JTA%E3%80%81EJB%E3%80%81RMI"><span class="nav-number">16.</span> <span class="nav-text">解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E7%94%9F%E6%88%90Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">Class类的作用？生成Class对象的方法有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">18.</span> <span class="nav-text">序列化的定义、实现和注意事项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java-sql-Date%E5%92%8Cjava-util-Date%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">java.sql.Date和java.util.Date的联系和区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AAString-Object"><span class="nav-number">20.</span> <span class="nav-text">String s &#x3D; new String(“xyz”);创建几个String Object?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-s-%E2%80%9DHello%E2%80%9D-s-s-%E2%80%9Dworld-%E2%80%9D-%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8Cs%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E6%94%B9%E5%8F%98%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">22.</span> <span class="nav-text">基本数据类型有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">23.</span> <span class="nav-text">String、StringBuffer、StringBuilder区别与联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFfinal%E7%9A%84"><span class="nav-number">24.</span> <span class="nav-text">String类为什么是final的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Integer%E4%B8%8Eint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">25.</span> <span class="nav-text">Integer与int的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%ADthrows%E5%92%8Cthrow%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.</span> <span class="nav-text">异常处理中throws和throw的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86try-catch-finally%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">27.</span> <span class="nav-text">Java异常处理try-catch-finally的执行过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C"><span class="nav-number">28.</span> <span class="nav-text">运行时异常与受检异常有何异同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">Error和Exception的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">30.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别和联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">31.</span> <span class="nav-text">继承条件下构造方法的执行过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">32.</span> <span class="nav-text">权限修饰符的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final%E5%92%8Cabstract%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">33.</span> <span class="nav-text">final和abstract关键字的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="nav-number">34.</span> <span class="nav-text">static关键字的作用（修饰变量、方法、代码块）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">35.</span> <span class="nav-text">this和super关键字的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">面向过程和面向对象的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">37.</span> <span class="nav-text">类和对象的关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">38.</span> <span class="nav-text">可变参数的作用和特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">39.</span> <span class="nav-text">递归的定义和优缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#break%E5%92%8Ccontinue%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">40.</span> <span class="nav-text">break和continue的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#while%E5%92%8Cdo-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">41.</span> <span class="nav-text">while和do-while循环的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="nav-number">42.</span> <span class="nav-text">用最有效率的方法算出2乘以8等于多少</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%8C-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">43.</span> <span class="nav-text">&amp;和&amp;&amp;的区别和联系，|和||的区别和联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#i-%E5%92%8C-i%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="nav-number">44.</span> <span class="nav-text">i++和++i的异同之处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-JRE-JVM%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%E6%A6%82%E6%8B%AC%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">45.</span> <span class="nav-text">JDK,JRE,JVM三者关系概括如下：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="nav-number">46.</span> <span class="nav-text">Java跨平台原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">47.</span> <span class="nav-text">Java的安全性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFORM%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">什么是ORM？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDAO%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">什么是DAO模式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UML%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FUML%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9B%BE%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">UML是什么？UML中有哪些图？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">Java 中有几种类型的流？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">Java中如何实现序列化，有什么意义？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#try-%E9%87%8C%E6%9C%89%E4%B8%80%E4%B8%AAreturn%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B4%A7%E8%B7%9F%E5%9C%A8%E8%BF%99%E4%B8%AAtry%E5%90%8E%E7%9A%84finally-%E9%87%8C%E7%9A%84code%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%9C%A8return%E5%89%8D%E8%BF%98%E6%98%AF%E5%90%8E"><span class="nav-number">53.</span> <span class="nav-text">try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8assert%EF%BC%9F"><span class="nav-number">54.</span> <span class="nav-text">什么时候用assert？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E4%B8%80%E4%B8%8BJava-%E5%92%8CJavaSciprt"><span class="nav-number">55.</span> <span class="nav-text">比较一下Java 和JavaSciprt</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E5%B0%86GB2312%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BAISO-8859-1%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E5%AE%83%E7%9A%84%E5%8C%85%E5%90%AB%E7%B1%BB%EF%BC%88%E5%A4%96%E9%83%A8%E7%B1%BB%EF%BC%89%E7%9A%84%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="nav-number">57.</span> <span class="nav-text">内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E5%AE%83%E7%B1%BB%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">58.</span> <span class="nav-text">匿名内部类是否可以继承其它类？是否可以实现接口？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E2%80%9C-java%E2%80%9D%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%B1%BB%EF%BC%88%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="nav-number">59.</span> <span class="nav-text">一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%EF%BC%88extends%EF%BC%89%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%EF%BC%88implements%EF%BC%89%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%85%B7%E4%BD%93%E7%B1%BB%EF%BC%88concrete-class%EF%BC%89"><span class="nav-number">60.</span> <span class="nav-text">接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="nav-number">61.</span> <span class="nav-text">如何实现对象克隆？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%EF%BC%88static%EF%BC%89%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9E%E9%9D%99%E6%80%81%EF%BC%88non-static%EF%BC%89%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">62.</span> <span class="nav-text">是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">63.</span> <span class="nav-text">静态变量和实例变量的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%9A%84%EF%BC%88abstract%EF%BC%89%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%88static%EF%BC%89-%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%EF%BC%88native%EF%BC%89%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E8%A2%ABsynchronized%E4%BF%AE%E9%A5%B0"><span class="nav-number">64.</span> <span class="nav-text">抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="nav-number">65.</span> <span class="nav-text">Java 中会存在内存泄漏吗，请简单描述。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">66.</span> <span class="nav-text">静态内部类和内部类有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#char-%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">67.</span> <span class="nav-text">char 型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%BD%93%E4%BD%9C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E6%AD%A4%E6%96%B9%E6%B3%95%E5%8F%AF%E6%94%B9%E5%8F%98%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%B9%B6%E5%8F%AF%E8%BF%94%E5%9B%9E%E5%8F%98%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E9%87%8C%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">68.</span> <span class="nav-text">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BFString-%E7%B1%BB"><span class="nav-number">69.</span> <span class="nav-text">是否可以继承String 类?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%80%BC%E7%9B%B8%E5%90%8C-x-equals-y-true-%EF%BC%8C%E4%BD%86%E5%8D%B4%E5%8F%AF%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84hash-code%EF%BC%8C%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%AF%B9%E4%B8%8D%E5%AF%B9%EF%BC%9F"><span class="nav-number">70.</span> <span class="nav-text">两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88constructor%EF%BC%89%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89"><span class="nav-number">71.</span> <span class="nav-text">构造器（constructor）是否可被重写（override）?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8Java-%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="nav-number">72.</span> <span class="nav-text">在Java 中，如何跳出当前的多重嵌套循环？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95-String-%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">73.</span> <span class="nav-text">数组有没有length()方法?String 有没有length()方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#swtich-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8byte-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8long-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8String%E4%B8%8A"><span class="nav-number">74.</span> <span class="nav-text">swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Math-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91-Math-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="nav-number">75.</span> <span class="nav-text">Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88%EF%BC%88stack%EF%BC%89%E3%80%81%E5%A0%86-heap-%E5%92%8C%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%82"><span class="nav-number">76.</span> <span class="nav-text">解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">77.</span> <span class="nav-text">&amp;和&amp;&amp;的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E6%9C%89%E6%B2%A1%E6%9C%89goto"><span class="nav-number">78.</span> <span class="nav-text">Java 有没有goto?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#short-s1-1-s1-s1-1-%E6%9C%89%E9%94%99%E5%90%97-short-s1-1-s1-1-%E6%9C%89%E9%94%99%E5%90%97"><span class="nav-number">79.</span> <span class="nav-text">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#float-f-3-4-%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="nav-number">80.</span> <span class="nav-text">float f&#x3D;3.4;是否正确?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97"><span class="nav-number">81.</span> <span class="nav-text">String 是最基本的数据类型吗?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">82.</span> <span class="nav-text">访问修饰符的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%8F%98%E9%87%8F%E7%94%A8final%E4%BF%AE%E9%A5%B0%EF%BC%8C%E5%88%99%E6%80%8E%E6%A0%B7%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%96%B9%E6%B3%95final%E4%BF%AE%E9%A5%B0%EF%BC%8C%E5%88%99%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="nav-number">83.</span> <span class="nav-text">如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%94%A8static%E4%BF%AE%E9%A5%B0%E5%92%8C%E4%B8%8D%E7%94%A8static%E4%BF%AE%E9%A5%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">84.</span> <span class="nav-text">成员变量用static修饰和不用static修饰有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#System-out-println-%E2%80%98a%E2%80%99-1-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF"><span class="nav-number">85.</span> <span class="nav-text">System.out.println(‘a’+1);的结果是</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84RuntimeException"><span class="nav-number">86.</span> <span class="nav-text">常见的RuntimeException</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-TreeMap%E5%92%8CTreeSet%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%97%B6%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9FCollections%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E7%9A%84sort%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">87.</span> <span class="nav-text">200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#199-%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD%EF%BC%88overloading%EF%BC%89%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%EF%BC%88overrding%EF%BC%89%EF%BC%9F"><span class="nav-number">88.</span> <span class="nav-text">199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E5%82%A8%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%EF%BC%9F"><span class="nav-number">89.</span> <span class="nav-text">char型变量中能不能存储一个中文汉字？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAn%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%BF%99%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E5%90%AF%E5%8A%A8%EF%BC%9F%E7%9C%8B%E6%B8%85%EF%BC%8C%E6%98%AF%E2%80%9C%E5%90%8C%E6%97%B6%E2%80%9D%E3%80%82"><span class="nav-number">90.</span> <span class="nav-text">创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%8C%E6%9C%89%E5%BA%8F%E7%9A%84%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%85%B6%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E5%93%AA%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%80%A7%E6%80%A7%E8%83%BD%E6%9B%B4%E9%AB%98%EF%BC%8C%E4%BD%A0%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9B%B4%E5%A5%BD%E6%88%96%E8%80%85%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">91.</span> <span class="nav-text">Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#try-%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AAreturn%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B4%A7%E8%B7%9F%E5%9C%A8%E8%BF%99%E4%B8%AAtry%E5%90%8E%E7%9A%84finally-%E9%87%8C%E9%9D%A2%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%9C%A8%E5%BC%82%E5%B8%B8%E5%87%BA%E7%8E%B0%E5%90%8E%EF%BC%8C%E9%83%BD%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">92.</span> <span class="nav-text">try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9Fjava%E5%8F%AF%E4%BB%A5%E5%BD%92%E7%B1%BB%E5%88%B0%E9%82%A3%E7%A7%8D%EF%BC%9F"><span class="nav-number">93.</span> <span class="nav-text">什么是编译型语言，什么是解释型语言？java可以归类到那种？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="nav-number">94.</span> <span class="nav-text">使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class%E7%B1%BB%E7%9A%84getDeclaredFields-%E6%96%B9%E6%B3%95%E4%B8%8EgetFields-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">95.</span> <span class="nav-text">Class类的getDeclaredFields()方法与getFields()的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89serialversionUID%E5%80%BC"><span class="nav-number">96.</span> <span class="nav-text">103.可序列化对象为什么要定义serialversionUID值?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">97.</span> <span class="nav-text">GC线程是否为守护线程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8D%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%9F%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B9%88"><span class="nav-number">98.</span> <span class="nav-text">不通过构造函数也能创建对象么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">99.</span> <span class="nav-text">同步代码块和同步方法有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9CManager%E6%98%AFEmployee%E7%9A%84%E5%AD%90%E7%B1%BB%EF%BC%8C%E9%82%A3%E4%B9%88Pair%E6%98%AFPair%E7%9A%84%E5%AD%90%E7%B1%BB%E5%90%97%EF%BC%9F"><span class="nav-number">100.</span> <span class="nav-text">Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="nav-number">101.</span> <span class="nav-text">简述Java中如何实现多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E5%81%9A%E4%B8%BAHashMap%E7%9A%84%E9%94%AE%E5%80%BC%EF%BC%8C%E8%80%8C%E5%8F%AA%E8%83%BD%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8A%8A%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%81%9A%E4%B8%BAHashMap%E7%9A%84%E5%81%A5%E5%80%BC%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E3%80%82"><span class="nav-number">102.</span> <span class="nav-text">在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B8%AD%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%94%A8size-of%E5%8F%96%E5%87%BA%E3%80%82"><span class="nav-number">103.</span> <span class="nav-text">对象在虚拟机的大小中可不可以用size of取出。</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">40</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">30</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">54</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/22829df8f04f.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java基础 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java基础</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-02 15:00:36" itemprop="dateModified" datetime="2024-01-02T15:00:36+08:00">2024-01-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>27k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>25 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="获得Class对象的⽅式"><a href="#获得Class对象的⽅式" class="headerlink" title="获得Class对象的⽅式"></a>获得Class对象的⽅式</h1><ul><li>静态类的.class语法：GuideUtil.class</li><li>普通类对象的getClass()⽅法：new Test().getClass()</li><li>通过Class对象的forName()⽅法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil”);</li><li>对于包装类,可以通过.TYPE语法⽅式：Integer.TYPE</li></ul><h1 id="在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>在 Java 中，为什么不允许从静态方法中访问非静态变量？</h1><ul><li>因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联</li></ul><h1 id="在-Java-中，什么时候用重载，什么时候用重写？"><a href="#在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="在 Java 中，什么时候用重载，什么时候用重写？"></a>在 Java 中，什么时候用重载，什么时候用重写？</h1><ul><li>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding）</li><li>而重载（overloading）是用不同的输入做同一件事</li><li>在 Java 中，重载的方法签名不同，而重写并不是。</li></ul><h1 id="举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>举例说明什么情况下会更倾向于使用抽象类而不是接口？</h1><ul><li>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求</li><li>在 Java 中，你只能继承一个类，但可以实现多个接口</li><li>所以一旦你继承了一个类，你就失去了继承其他类的机会了。</li><li>接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable(注：这里的意思是指如果把 Runnable 等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</li><li>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</li><li>如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择</li><li>有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</li></ul><h1 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h1><ul><li>调用该访问返回一个以字符串指定类名的类的对象。</li></ul><h1 id="Jdo是什么"><a href="#Jdo是什么" class="headerlink" title="Jdo是什么?"></a>Jdo是什么?</h1><ul><li>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API</li><li>JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）</li><li>这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上</li><li>另外，JDO很灵活，因为它可以在任何数据底层上运行</li><li>JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。</li></ul><h1 id="HashMap-，HashTable-区别"><a href="#HashMap-，HashTable-区别" class="headerlink" title="HashMap ，HashTable 区别"></a>HashMap ，HashTable 区别</h1><ul><li>默认容量不同。扩容不同</li><li>线程安全性，HashTable 安全</li><li>效率不同 HashTable 要慢因为加锁</li></ul><h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><ul><li>数组 + 链表方式存储</li><li>默认容量：11(质数 为宜)</li><li>put:<ul><li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li><li>若在链表中找到了，则替换旧值，若未找到则继续</li><li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li><li>将新元素加到链表头部</li><li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。</li></ul></li></ul><h1 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h1><ul><li>默认的负载因子大小为0.75</li><li>也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组来重新调整map的大小，并将原来的对象放入新的bucket数组中。</li><li>这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</li></ul><h1 id="EJB与JavaBean的区别？"><a href="#EJB与JavaBean的区别？" class="headerlink" title="EJB与JavaBean的区别？"></a>EJB与JavaBean的区别？</h1><ul><li>Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于JavaBean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器。另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。</li><li>Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。</li></ul><h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 3 种修饰符： public， private 和 protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</li><li>下面列出了使用封装的一些好处：<ul><li>通过隐藏对象的属性来保护对象内部的状态。</li><li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li><li>禁止对象之间的不良交互提高模块化</li></ul></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</li></ul><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul><li>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。 Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</li></ul><h1 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h1><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul><li>修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。</li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><ul><li>在异常处理时提供 finally 块来执行任何清除操作</li><li>如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ul><li>方法名</li><li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</li><li>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h4 id="override（重写）"><a href="#override（重写）" class="headerlink" title="override（重写）"></a>override（重写）</h4><ul><li>方法名、参数、返回值相同。</li><li>子类方法不能缩小父类方法的访问权限。</li><li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li><li>存在于父类和子类之间。</li><li>方法被定义为final不能被重写。</li></ul><h4 id="overload（重载）"><a href="#overload（重载）" class="headerlink" title="overload（重载）"></a>overload（重载）</h4><ul><li>参数类型、个数、顺序至少有一个不相同。</li><li>不能重载只有返回值不同的方法名。</li><li>存在于父类和子类、同类中。</li></ul><h1 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h1><ul><li>接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。</li><li>还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。</li></ul><h1 id="Java1-7与1-8-1-9-10-新特性"><a href="#Java1-7与1-8-1-9-10-新特性" class="headerlink" title="Java1.7与1.8,1.9,10 新特性"></a>Java1.7与1.8,1.9,10 新特性</h1><h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4><ul><li>switch中可以使用字串了</li><li>运用List tempList &#x3D; new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断</li><li>语法上支持集合，而不一定是数组</li><li>新增一些取环境信息的工具方法</li><li>Boolean类型反转，空指针安全,参与位运算</li><li>两个char间的equals</li><li>安全的加减乘除</li><li>map集合支持并发请求，且可以写成 Map map &#x3D; {name:”xxx”,age:18};</li></ul><h4 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h4><ul><li>允许在接口中有默认方法实现</li><li>Lambda表达式</li><li>函数式接口</li><li>方法和构造函数引用</li><li>Lambda的范围</li><li>内置函数式接口</li><li>Streams</li><li>Parallel Streams</li><li>Map</li><li>时间日期API</li><li>Annotations</li></ul><h4 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h4><ul><li>Jigsaw 项目;模块化源码</li><li>简化进程API</li><li>轻量级 JSON API</li><li>钱和货币的API</li><li>改善锁争用机制</li><li>代码分段缓存</li><li>智能Java编译, 第二阶段</li><li>HTTP 2.0客户端</li><li>Kulla计划: Java的REPL实现</li></ul><h1 id="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"><a href="#解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI" class="headerlink" title="解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI"></a>解释下面关于J2EE的名词：JNDI、JDBC、JMS、JTA、EJB、RMI</h1><ul><li>web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。</li><li>EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。</li><li>JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</li><li>JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</li><li>JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</li><li>JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</li><li>RMI&#x2F;IIOP:（Remote Method Invocation &#x2F;internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。</li></ul><h1 id="Class类的作用？生成Class对象的方法有哪些？"><a href="#Class类的作用？生成Class对象的方法有哪些？" class="headerlink" title="Class类的作用？生成Class对象的方法有哪些？"></a>Class类的作用？生成Class对象的方法有哪些？</h1><ul><li>Class类是Java 反射机制的起源和入口，用于获取与类相关的各种信息，提供了获取类信息的相关方法。Class类继承自Object类</li><li>Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的结构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方法、父类和接口</li><li>方法示例<ul><li>getClass()</li><li>getSuperClass()</li><li>.class</li><li>.TYPE</li></ul></li></ul><h1 id="序列化的定义、实现和注意事项"><a href="#序列化的定义、实现和注意事项" class="headerlink" title="序列化的定义、实现和注意事项"></a>序列化的定义、实现和注意事项</h1><ul><li>想把一个对象写在硬盘上或者网络上，对其进行序列化，把他序列化成为一个字节流。</li><li>实现和注意事项：<ul><li>实现接口Serializable Serializable接口中没有任何的方法，实现该接口的类不需要实现额外的方法。</li><li>如果对象中的某个属性是对象类型，必须也实现Serializable接口才可以，序列化对静态变量无效</li><li>如果不希望某个属性参与序列化，不是将其static，而是transient</li></ul></li><li>串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存</li><li>序列化版本不兼容</li></ul><h1 id="java-sql-Date和java-util-Date的联系和区别"><a href="#java-sql-Date和java-util-Date的联系和区别" class="headerlink" title="java.sql.Date和java.util.Date的联系和区别"></a>java.sql.Date和java.util.Date的联系和区别</h1><ul><li>java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。</li><li>JAVA里提供的日期和时间类，java.sql.Date和java.sql.Time,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002&#x2F;05&#x2F;22 5:00:57 PM的字段，读取日期时得到的是2002&#x2F;05&#x2F;22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用Equals方法可能返回false。.sql.Timestamp类比java.util.Date类精确度要高。这个类包了一个getTime()方法，但是它不会返回额外精度部分的数据，因此必须使用…</li><li>总之，java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。</li></ul><h1 id="String-s-new-String-“xyz”-创建几个String-Object"><a href="#String-s-new-String-“xyz”-创建几个String-Object" class="headerlink" title="String s &#x3D; new String(“xyz”);创建几个String Object?"></a>String s &#x3D; new String(“xyz”);创建几个String Object?</h1><ul><li>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个</li><li>New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象</li><li>如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</li></ul><h1 id="String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？"><a href="#String-s-”Hello”-s-s-”world-”-执行后，s内容是否改变？" class="headerlink" title="String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？"></a>String s&#x3D;”Hello”;s&#x3D;s+”world!”;执行后，s内容是否改变？</h1><ul><li>没有改变。</li><li>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</li></ul><h1 id="基本数据类型有哪些"><a href="#基本数据类型有哪些" class="headerlink" title="基本数据类型有哪些"></a>基本数据类型有哪些</h1><ul><li>byte、short、char、int、long、float、double、boolean</li></ul><h1 id="String、StringBuffer、StringBuilder区别与联系"><a href="#String、StringBuffer、StringBuilder区别与联系" class="headerlink" title="String、StringBuffer、StringBuilder区别与联系"></a>String、StringBuffer、StringBuilder区别与联系</h1><ul><li>String类是字符序列不可变的类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。</li><li>StringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setChartAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String</li><li>JDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder</li></ul><h1 id="String类为什么是final的"><a href="#String类为什么是final的" class="headerlink" title="String类为什么是final的"></a>String类为什么是final的</h1><ul><li>为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。</li><li>为了安全。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的， 和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的， 这不就成了核心病毒了么？</li><li>不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性， 如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点；</li></ul><h1 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h1><ul><li>int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</li><li>int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</li><li>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</li><li>Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</li></ul><h1 id="异常处理中throws和throw的区别"><a href="#异常处理中throws和throw的区别" class="headerlink" title="异常处理中throws和throw的区别"></a>异常处理中throws和throw的区别</h1><ul><li>作用不同：<ul><li>throw用于程序员自行产生并抛出异常；</li><li>throws用于声明在该方法内抛出了异常</li></ul></li><li>使用的位置不同：<ul><li>throw位于方法体内部，可以作为单独语句使用；</li><li>throws必须跟在方法参数列表的后面，不能单独使用。</li></ul></li><li>内容不同：<ul><li>throw抛出一个异常对象，且只能是一个；</li><li>throws后面跟异常类，而且可以有多个。</li></ul></li></ul><h1 id="Java异常处理try-catch-finally的执行过程"><a href="#Java异常处理try-catch-finally的执行过程" class="headerlink" title="Java异常处理try-catch-finally的执行过程"></a>Java异常处理try-catch-finally的执行过程</h1><ul><li>try-catch-finally程序块的执行流程以及执行结果比较复杂。</li><li>基本执行过程如下：<ul><li>程序首先执行可能发生异常的try语句块。</li><li>如果try语句没有出现异常则执行完后跳至finally语句块执行；</li><li>如果try语句出现异常，则中断执行并根据发生的异常类型跳至相应的catch语句块执行处理。</li><li>catch语句块可以有多个，分别捕获不同类型的异常。</li><li>catch语句块执行完后程序会继续执行finally语句块。</li></ul></li><li>finally语句是可选的，如果有的话，则不管是否发生异常，finally语句都会被执行。需要注意的是即使try和catch块中存在return语句，finally语句也会执行，是在执行完finally语句后再通过return退出。</li></ul><h1 id="运行时异常与受检异常有何异同"><a href="#运行时异常与受检异常有何异同" class="headerlink" title="运行时异常与受检异常有何异同"></a>运行时异常与受检异常有何异同</h1><ul><li>运行时异常：包括RuntimeaException及其所有子类。不要求程序必须对它们作出处理，比如InputMismatchException、ArithmeticException、NullPointerException等。即使没有显示使用try-catch或throws进行处理，仍旧可以进行编译和运行(其实是JVM隐式的使用try-catch或throws进行处理)。如果运行时发生异常，会输出异常的堆栈信息并中止程序执行。</li><li>Checked异常（非运行时异常）：除了运行时异常外的其他异常类都是Checked异常，程序必须捕获或者声明抛出这种异常，否则出现编译错误，无法通过编译。处理方式包括两种：通过try-catch捕获异常，通过throws声明抛出异常从而交给上一级调用方法处理。</li></ul><h1 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h1><ul><li>Error类，表示仅靠程序本身无法恢复的严重错误，比如说内存溢出、动态链接异常、虚拟机错误。应用程序不应该抛出这种类型的对象。假如出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。所以在进行程序设计时，应该更关注Exception类。</li><li>Exception类，由Java应用程序抛出和处理的非严重错误，比如所需文件没有找到、零作除数，数组下标越界等。它的各种不同子类分别对应不同类型异常。可分为两类：Checked异常和Runtime异常</li></ul><h1 id="和equals的区别和联系"><a href="#和equals的区别和联系" class="headerlink" title="&#x3D;&#x3D;和equals的区别和联系"></a>&#x3D;&#x3D;和equals的区别和联系</h1><ul><li>“&#x3D;&#x3D;”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；</li><li>“&#x3D;&#x3D;”使用情况如下：<ul><li>基本类型，比较的是值</li><li>引用类型，比较的是地址</li><li>不能比较没有父子关系的两个对象</li></ul></li><li>equals()方法使用如下：<ul><li>系统类一般已经覆盖了equals()，比较的是内容。</li><li>用户自定义类如果没有覆盖equals()，将调用父类的equals（比如是Object），而Object的equals的比较是地址（return (this &#x3D;&#x3D; obj);）</li><li>用户自定义类需要覆盖父类的equals()</li></ul></li><li>注意：Object的&#x3D;&#x3D;和equals比较的都是地址，作用相同</li></ul><h1 id="继承条件下构造方法的执行过程"><a href="#继承条件下构造方法的执行过程" class="headerlink" title="继承条件下构造方法的执行过程"></a>继承条件下构造方法的执行过程</h1><ul><li>继承条件下构造方法的调用规则如下：<ul><li>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</li><li>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li><li>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</li></ul></li><li>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li></ul><h1 id="权限修饰符的区别"><a href="#权限修饰符的区别" class="headerlink" title="权限修饰符的区别"></a>权限修饰符的区别</h1><ul><li>类的访问权限只有两种<ul><li>public 公共的 可被同一项目中所有的类访问。 (必须与文件名同名)</li><li>default 默认的 可被同一个包中的类访问。</li></ul></li><li>成员（成员变量或成员方法）访问权限共有四种：<ul><li>public 公共的 可以被项目中所有的类访问。(项目可见性)</li><li>protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）</li><li>default 默认的被这个类本身访问；被同一个包中的类访问。（包可见性）</li><li>private 私有的只能被这个类本身访问。（类可见性）</li></ul></li></ul><h1 id="final和abstract关键字的作用"><a href="#final和abstract关键字的作用" class="headerlink" title="final和abstract关键字的作用"></a>final和abstract关键字的作用</h1><ul><li>final和abstract是功能相反的两个关键字，可以对比记忆</li><li>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</li><li>final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</li><li>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li></ul><h1 id="static关键字的作用（修饰变量、方法、代码块）"><a href="#static关键字的作用（修饰变量、方法、代码块）" class="headerlink" title="static关键字的作用（修饰变量、方法、代码块）"></a>static关键字的作用（修饰变量、方法、代码块）</h1><ul><li>static可以修饰变量、方法、代码块和内部类</li><li>static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</li><li>static变量和非static变量的区别(都是成员变量，不是局部变量)<ul><li>在内存中份数不同<ul><li>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</li><li>static变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</li></ul></li><li>在内存中存放的位置不同<ul><li>静态变量存在方法区中，实例变量存在堆内存中</li></ul></li><li>访问的方式不同<ul><li>实例变量： 对象名.变量名 stu1.name&#x3D;”小明明”;</li><li>静态变量：对象名.变量名 stu1.schoolName&#x3D;”西二旗小学”; 不推荐如此使用</li><li>类名.变量名 Student.schoolName&#x3D;”东三旗小学”; 推荐使用</li></ul></li><li>在内存中分配空间的时间不同<ul><li>实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候</li><li>Student.schoolName&#x3D;”东三旗小学”;或者Student stu1 &#x3D; new Student(“小明”,”男”,20,98);</li><li>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</li><li>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</li><li>static内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员</li></ul></li></ul></li></ul><h1 id="this和super关键字的作用"><a href="#this和super关键字的作用" class="headerlink" title="this和super关键字的作用"></a>this和super关键字的作用</h1><ul><li>this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题</li><li>this可以调用成员变量，不能调用局部变量</li><li>this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句，而且在静态方法当中不允许出现this关键字。</li><li>super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问private成员）</li><li>super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</li></ul><h1 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h1><ul><li>面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li><li>封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</li><li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</li></ul><h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><ul><li>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</li><li>类和对象好比图纸和实物的关系，模具和铸件的关系。</li></ul><h1 id="可变参数的作用和特点"><a href="#可变参数的作用和特点" class="headerlink" title="可变参数的作用和特点"></a>可变参数的作用和特点</h1><ul><li>可变参数<ul><li>可变参数的形式 …</li><li>可变参数只能是方法的形参</li><li>可变参数对应的实参可以0,1,2…..个，也可以是一个数组</li><li>在可变参数的方法中，将可变参数当做数组来处理</li><li>可变参数最多有一个，只能是最后一个</li><li>可变参数好处：方便 简单 减少重载方法的数量</li><li>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</li></ul></li><li>数组做形参和可变参数做形参联系和区别</li><li>联系：<br>-实参都可以是数组；2.方法体中，可变参数当做数组来处理</li><li>区别：<ul><li>个数不同	可变参数只能有一个数组参数可以多个</li><li>位置不同	可变参数只能是最后一个	数组参数位置任意</li><li>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</li></ul></li></ul><h1 id="递归的定义和优缺点"><a href="#递归的定义和优缺点" class="headerlink" title="递归的定义和优缺点"></a>递归的定义和优缺点</h1><ul><li>递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</li><li>递归算法解决问题的特点：<ul><li>递归就是在过程或函数里调用自身。</li><li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li><li>递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</li><li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</li></ul></li></ul><h1 id="break和continue的作用"><a href="#break和continue的作用" class="headerlink" title="break和continue的作用"></a>break和continue的作用</h1><ul><li>break: 结束当前循环并退出当前循环体。</li><li>break还可以退出switch语句</li><li>continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。</li></ul><h1 id="while和do-while循环的区别"><a href="#while和do-while循环的区别" class="headerlink" title="while和do-while循环的区别"></a>while和do-while循环的区别</h1><ul><li>while先判断后执行，第一次判断为false,循环体一次都不执行</li><li>do while先执行 后判断，最少执行1次。</li><li>如果while循环第一次判断为true, 则两种循环没有区别。</li></ul><h1 id="用最有效率的方法算出2乘以8等于多少"><a href="#用最有效率的方法算出2乘以8等于多少" class="headerlink" title="用最有效率的方法算出2乘以8等于多少"></a>用最有效率的方法算出2乘以8等于多少</h1><ul><li>使用位运算来实现效率最高</li><li>位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数</li><li>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高</li><li>所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</li></ul><h1 id="和-的区别和联系，-和-的区别和联系"><a href="#和-的区别和联系，-和-的区别和联系" class="headerlink" title="&amp;和&amp;&amp;的区别和联系，|和||的区别和联系"></a>&amp;和&amp;&amp;的区别和联系，|和||的区别和联系</h1><ul><li>&amp;和&amp;&amp;的联系(共同点)：<ul><li>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</li><li>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</li><li>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</li><li>情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li><li>情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</li><li>表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</li></ul></li><li>&amp;和&amp;&amp;的区别(不同点)<ul><li>&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。</li><li>对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</li><li>对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</li><li>综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</li><li>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</li></ul></li><li>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</li></ul><h1 id="i-和-i的异同之处"><a href="#i-和-i的异同之处" class="headerlink" title="i++和++i的异同之处"></a>i++和++i的异同之处</h1><ul><li>共同点：<ul><li>i++和++i都是变量自增1，都等价于i&#x3D;i+1</li><li>如果i++,++i是一条单独的语句，两者没有任何区别</li><li>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</li></ul></li><li>不同点：<ul><li>如果i++,++i不是一条单独的语句，他们就有区别</li><li>i++ ：先运算后增1。如：int x&#x3D;5;</li><li>int y&#x3D;x++;</li><li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li><li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;5++i ： 先增1后运算。如：</li><li>int x&#x3D;5;</li><li>int y&#x3D;++x;</li><li>System.out.println(“x&#x3D;”+x+”, y&#x3D;”+y);</li><li>&#x2F;&#x2F;以上代码运行后输出结果为：x&#x3D;6, y&#x3D;6334.</li></ul></li></ul><h1 id="JDK-JRE-JVM三者关系概括如下："><a href="#JDK-JRE-JVM三者关系概括如下：" class="headerlink" title="JDK,JRE,JVM三者关系概括如下："></a>JDK,JRE,JVM三者关系概括如下：</h1><ul><li>jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE</li><li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了</li><li>JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li></ul><h1 id="Java跨平台原理"><a href="#Java跨平台原理" class="headerlink" title="Java跨平台原理"></a>Java跨平台原理</h1><ul><li>C&#x2F;C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</li><li>Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</li><li>字节码文件不面向任何具体平台，只面向虚拟机。</li><li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li><li>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C&#x2F;C++要低。</li><li>Java的跨平台原理决定了其性能没有C&#x2F;C++高</li></ul><h1 id="Java的安全性"><a href="#Java的安全性" class="headerlink" title="Java的安全性"></a>Java的安全性</h1><ul><li>语言层次的安全性主要体现在：<ul><li>Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。</li><li>垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。</li><li>异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</li><li>强制类型转换：只有在满足强制转换规则的情况下才能强转成功。</li></ul></li><li>底层的安全性可以从以下方面来说明<ul><li>Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。</li></ul></li><li>在运行环境提供了四级安全性保障机制：<ul><li>字节码校验器 -类装载器 -运行时内存布局 -文件访问限制</li></ul></li></ul><h1 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h1><ul><li>对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术</li><li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（可以用XML或者是注解），将Java程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</li></ul><h1 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h1><ul><li>DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作</li><li>为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中</li><li>用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法</li><li>在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储</li><li>DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</li></ul><h1 id="UML是什么？UML中有哪些图？"><a href="#UML是什么？UML中有哪些图？" class="headerlink" title="UML是什么？UML中有哪些图？"></a>UML是什么？UML中有哪些图？</h1><ul><li>UML是统一建模语言（Unified Modeling Language）的缩写，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为</li><li>UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等</li><li>在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。</li></ul><h1 id="Java-中有几种类型的流？"><a href="#Java-中有几种类型的流？" class="headerlink" title="Java 中有几种类型的流？"></a>Java 中有几种类型的流？</h1><ul><li>两种流分别是字节流，字符流。</li><li>字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer</li><li>在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</li><li>关于Java的IO需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</li></ul><h1 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h1><ul><li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间</li><li>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</li><li>要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</li></ul><h1 id="try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?</h1><ul><li>会执行，在方法返回调用者前执行</li><li>Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。</li></ul><p> </p><h1 id="什么时候用assert？"><a href="#什么时候用assert？" class="headerlink" title="什么时候用assert？"></a>什么时候用assert？</h1><ul><li>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制</li><li>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。</li></ul><h1 id="比较一下Java-和JavaSciprt"><a href="#比较一下Java-和JavaSciprt" class="headerlink" title="比较一下Java 和JavaSciprt"></a>比较一下Java 和JavaSciprt</h1><ul><li>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。</li><li>下面对两种语言间的异同作如下比较：<ul><li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</li><li>强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</li><li>代码格式不一样。</li></ul></li><li>上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</li></ul><p> </p><h1 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h1><ul><li><p>代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;你好&quot;;</span><br><span class="line">String s2 = newString(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); </span><br></pre></td></tr></table></figure></li><li><p>在String类的构造方法当中，存在一个字符集设置的方法</p></li></ul><h1 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h1><ul><li>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</li><li>如果要访问外部类的局部变量，此时局部变量必须使用final修饰，否则无法访问。</li></ul><h1 id="匿名内部类是否可以继承其它类？是否可以实现接口？"><a href="#匿名内部类是否可以继承其它类？是否可以实现接口？" class="headerlink" title="匿名内部类是否可以继承其它类？是否可以实现接口？"></a>匿名内部类是否可以继承其它类？是否可以实现接口？</h1><ul><li>可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。</li></ul><h1 id="一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个“-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h1><ul><li>可以，但一个源文件中最多只能有一个公开类（public class）</li><li>而且文件名必须和公开类的类名完全保持一致。</li></ul><p> </p><h1 id="接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）"><a href="#接口是否可继承（extends）接口-抽象类是否可实现（implements）接口-抽象类是否可继承具体类（concrete-class）" class="headerlink" title="接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?"></a>接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?</h1><ul><li>接口可以继承接口</li><li>抽象类可以实现(implements)接口，抽象类可以继承具体类</li><li>抽象类中可以有静态的main方法。</li></ul><h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><ul><li>有两种方式：<ul><li>实现Cloneable接口并重写Object类中的clone()方法；</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。</li></ul></li><li>基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。</li></ul><h1 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h1><ul><li>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。</li></ul><p> </p><h1 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h1><ul><li>静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝</li><li>实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存</li><li>两者的相同点：都有默认值而且在类的任何地方都可以调用</li></ul><h1 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?</h1><ul><li>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的</li><li>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li><li>synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li></ul><h1 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h1><ul><li>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）</li><li>然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露</li><li>一个例子就是hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象</li></ul><h1 id="静态内部类和内部类有什么区别"><a href="#静态内部类和内部类有什么区别" class="headerlink" title="静态内部类和内部类有什么区别"></a>静态内部类和内部类有什么区别</h1><ul><li>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</li><li>内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</li><li>在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类</li><li>Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class</li><li>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</li><li>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化</li></ul><h1 id="char-型变量中能不能存贮一个中文汉字-为什么"><a href="#char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char 型变量中能不能存贮一个中文汉字?为什么?"></a>char 型变量中能不能存贮一个中文汉字?为什么?</h1><ul><li>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦</li></ul><h1 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h1><ul><li>是值传递</li><li>Java 编程语言只有值传递参数</li><li>当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用</li><li>对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。</li></ul><h1 id="是否可以继承String-类"><a href="#是否可以继承String-类" class="headerlink" title="是否可以继承String 类?"></a>是否可以继承String 类?</h1><ul><li>String 类是final类，不可以被继承。</li></ul><h1 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对？</h1><ul><li>不对</li><li>如果两个对象x和y满足x.equals(y) &#x3D;&#x3D;++++ true，它们的哈希码（hash code）应当相同</li><li>Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同</li></ul><h1 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）?"></a>构造器（constructor）是否可被重写（override）?</h1><ul><li>构造器不能被继承，因此不能被重写，但可以被重载。</li></ul><h1 id="在Java-中，如何跳出当前的多重嵌套循环？"><a href="#在Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java 中，如何跳出当前的多重嵌套循环？"></a>在Java 中，如何跳出当前的多重嵌套循环？</h1><ul><li>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环</li><li>Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好</li></ul><h1 id="数组有没有length-方法-String-有没有length-方法？"><a href="#数组有没有length-方法-String-有没有length-方法？" class="headerlink" title="数组有没有length()方法?String 有没有length()方法？"></a>数组有没有length()方法?String 有没有length()方法？</h1><ul><li>数组没有length()方法，有length 的属性</li><li>String 有length()方法</li><li>JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</li></ul><h1 id="swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?"></a>swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?</h1><ul><li>早期的JDK中，switch（expr）中，expr可以是byte、short、char、int</li><li>从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举</li><li>从JDK 1.7版开始，还可以是字符串（String）</li><li>长整型（long）是不可以的。</li></ul><h1 id="Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?"></a>Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h1><ul><li>Math.round(11.5)的返回值是12</li><li>Math.round(-11.5)的返回值是-11</li><li>四舍五入的原理是在参数上加0.5然后进行下取整。</li></ul><p> </p><h1 id="解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h1><ul><li><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间</p></li><li><p>而通过new关键字和构造器创建的对象放在堆空间</p></li><li><p>程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中</p></li><li><p>栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“hello”);</span><br></pre></td></tr></table></figure></li><li><p>上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。</p></li><li><p>较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</p></li></ul><h1 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h1><ul><li>&amp;运算符有两种用法<ul><li>按位与</li><li>逻辑与</li></ul></li><li>&amp;&amp;运算符是短路与运算</li><li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true</li><li>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</li><li>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常</li><li>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</li></ul><h1 id="Java-有没有goto"><a href="#Java-有没有goto" class="headerlink" title="Java 有没有goto?"></a>Java 有没有goto?</h1><ul><li>goto 是Java中的保留字，在目前版本的Java中没有使用</li><li>其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字</li></ul><h1 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗?</h1><ul><li>对于short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型</li><li>而short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为s1+&#x3D; 1;相当于s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。</li></ul><h1 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确?"></a>float f&#x3D;3.4;是否正确?</h1><ul><li>不正确</li><li>3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成float f &#x3D;3.4F;。</li></ul><h1 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h1><ul><li>不是</li><li>Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</li></ul><h1 id="访问修饰符的区别？"><a href="#访问修饰符的区别？" class="headerlink" title="访问修饰符的区别？"></a>访问修饰符的区别？</h1><table><thead><tr><th>作用域</th><th>当前类</th><th>同包</th><th>子类</th><th>其他</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</li></ul><p> </p><h1 id="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"><a href="#如果变量用final修饰，则怎样？如果方法final修饰，则怎样？" class="headerlink" title="如果变量用final修饰，则怎样？如果方法final修饰，则怎样？"></a>如果变量用final修饰，则怎样？如果方法final修饰，则怎样？</h1><ul><li>用final修饰的类不能被扩展，也就是说不可能有子类；</li><li>用final修饰的方法不能被替换或隐藏：<ul><li>使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</li><li>使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏	（hidden）；</li></ul></li><li>用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：<ul><li>静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量， 赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，	赋值只能在其声明中通过初始化表达式完成；</li><li>实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通	过初始化表达式完成，也可以在实例初始化块或构造器中进行；</li><li>方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体	（body）结束，在此期间其值不能改变；</li><li>构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，	同时被初始化为对应实参值，终止于构造器体结束，在此期间其值不能改变；</li><li>异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化	为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</li><li>局部变量在其值被访问之前必须被明确赋值；</li></ul></li></ul><h1 id="成员变量用static修饰和不用static修饰有什么区别？"><a href="#成员变量用static修饰和不用static修饰有什么区别？" class="headerlink" title="成员变量用static修饰和不用static修饰有什么区别？"></a>成员变量用static修饰和不用static修饰有什么区别？</h1><ul><li>两个变量的生命周期不同。<ul><li>成员变量随着对象的创建而存在，随着对象的被回收而释放。</li><li>静态变量随着类的加载而存在，随着类的消失而消失。</li></ul></li><li>调用方式不同。<ul><li>成员变量只能被对象调用。</li><li>静态变量可以被对象调用，还可以被类名调用。</li><li>对象调用：p.country</li><li>类名调用 ：Person.country</li></ul></li><li>别名不同。<ul><li>成员变量也称为实例变量。</li><li>静态变量称为类变量。</li></ul><p> </p></li><li>数据存储位置不同。<ul><li>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.</li><li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.</li></ul></li></ul><h1 id="System-out-println-‘a’-1-的结果是"><a href="#System-out-println-‘a’-1-的结果是" class="headerlink" title="System.out.println(‘a’+1);的结果是"></a>System.out.println(‘a’+1);的结果是</h1><ul><li>‘a’是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98</li></ul><h1 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h1><ul><li>NullPointerException：一般都是在null对象上调用方法了。</li><li>NumberFormatException：继承IllegalArgumentException，字符串转换为数字时。</li><li>StringIndexOutOfBoundsException：字符串越界</li><li>ClassCastException:类型转换错误</li></ul><h1 id="200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"><a href="#200-TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？" class="headerlink" title="200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？"></a>200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？</h1><ul><li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li><li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序</li><li>Collections 工具类的sort方法有两种重载的形式<ul><li>第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul></li></ul><h1 id="199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"><a href="#199-一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？" class="headerlink" title="199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？"></a>199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？</h1><ul><li>构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法</li></ul><h1 id="char型变量中能不能存储一个中文汉字？"><a href="#char型变量中能不能存储一个中文汉字？" class="headerlink" title="char型变量中能不能存储一个中文汉字？"></a>char型变量中能不能存储一个中文汉字？</h1><ul><li>java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。</li><li>char 在java中是2个字节，所以可以存储中文</li></ul><h1 id="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"><a href="#创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。" class="headerlink" title="创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。"></a>创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。</h1><ul><li>用一个for循环创建线程对象并调用start方法启动线程。</li></ul><h1 id="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"><a href="#Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？" class="headerlink" title="Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？"></a>Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？</h1><ul><li>Map的实现类有HashMap,LinkedHashMap,TreeMap</li><li>HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序；TreeMap默认是自然升序）</li><li>LinkedHashMap底层存储结构是哈希表+链表，链表记录了添加数据的顺序</li><li>TreeMap底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性</li><li>LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表</li></ul><h1 id="try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？"><a href="#try-里面有一个return语句，那么紧跟在这个try后的finally-里面的语句在异常出现后，都会执行么？为什么？" class="headerlink" title="try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？"></a>try{}里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？</h1><ul><li>在异常处理时提供 finally 块来执行任何清除操作。</li><li>如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。</li><li>finally中语句不执行的唯一情况中执行了System.exit(0)语句。</li></ul><h1 id="什么是编译型语言，什么是解释型语言？java可以归类到那种？"><a href="#什么是编译型语言，什么是解释型语言？java可以归类到那种？" class="headerlink" title="什么是编译型语言，什么是解释型语言？java可以归类到那种？"></a>什么是编译型语言，什么是解释型语言？java可以归类到那种？</h1><ul><li>计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。</li><li>用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。</li><li>解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。</li><li>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C&#x2F;C++、Pascal&#x2F;Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。</li><li>JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。</li></ul><h1 id="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？</h1><ul><li>final修饰基本类型变量，其值不能改变。</li><li>但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变</li></ul><h1 id="Class类的getDeclaredFields-方法与getFields-的区别？"><a href="#Class类的getDeclaredFields-方法与getFields-的区别？" class="headerlink" title="Class类的getDeclaredFields()方法与getFields()的区别？"></a>Class类的getDeclaredFields()方法与getFields()的区别？</h1><ul><li>getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法</li><li>getFields(): 只能获取所有public声43明的方法, 包括继承的方法</li></ul><h1 id="103-可序列化对象为什么要定义serialversionUID值"><a href="#103-可序列化对象为什么要定义serialversionUID值" class="headerlink" title="103.可序列化对象为什么要定义serialversionUID值?"></a>103.可序列化对象为什么要定义serialversionUID值?</h1><ul><li>SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容</li><li>如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常</li><li>如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</li></ul><h1 id="GC线程是否为守护线程？"><a href="#GC线程是否为守护线程？" class="headerlink" title="GC线程是否为守护线程？"></a>GC线程是否为守护线程？</h1><ul><li>GC线程是守护线程</li><li>线程分为守护线程和非守护线程（即用户线程）。只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。</li></ul><h1 id="不通过构造函数也能创建对象么"><a href="#不通过构造函数也能创建对象么" class="headerlink" title="不通过构造函数也能创建对象么"></a>不通过构造函数也能创建对象么</h1><ul><li>是</li><li>Java创建对象的几种方式：<ul><li>用new语句创建对象，这是最常见的创建对象的方法。</li><li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li><li>调用对象的clone()方法。</li><li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li></ul></li><li>(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。</li></ul><h1 id="同步代码块和同步方法有什么区别"><a href="#同步代码块和同步方法有什么区别" class="headerlink" title="同步代码块和同步方法有什么区别"></a>同步代码块和同步方法有什么区别</h1><ul><li>相同点：同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为this，那么同步方法和同步代码块没有太大的区别。</li><li>区别：同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。</li></ul><h1 id="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"><a href="#Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？" class="headerlink" title="Java中，如果Manager是Employee的子类，那么Pair是Pair的子类吗？"></a>Java中，如果Manager是Employee的子类，那么Pair<manager>是Pair<employee>的子类吗？</employee></manager></h1><ul><li>不是，两者没有任何关联。</li></ul><h1 id="简述Java中如何实现多态"><a href="#简述Java中如何实现多态" class="headerlink" title="简述Java中如何实现多态"></a>简述Java中如何实现多态</h1><ul><li>实现多态有三个前提条件：<ul><li>继承的存在；（继承是多态的基础，没有继承就没有多态）。</li><li>子类重写父类的方法。（多态下会调用子类重写后的方法）。</li><li>父类引用变量指向子类对象。（涉及子类到父类的类型转换）。</li></ul></li><li>最后使用父类的引用变量调用子类重写的方法即可实现多态。</li></ul><h1 id="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"><a href="#在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。" class="headerlink" title="在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。"></a>在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。</h1><ul><li>在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&lt;K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap&lt;K, V&gt;可以理解为HashMap&lt;Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型</li><li>引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。</li></ul><h1 id="对象在虚拟机的大小中可不可以用size-of取出。"><a href="#对象在虚拟机的大小中可不可以用size-of取出。" class="headerlink" title="对象在虚拟机的大小中可不可以用size of取出。"></a>对象在虚拟机的大小中可不可以用size of取出。</h1><ul><li>可以</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/5352a96111d6.html" rel="prev" title="Java基础"><i class="fa fa-angle-left"></i> Java基础</a></div><div class="post-nav-item"><a href="/publishes/52555cb3db5d.html" rel="next" title="Docker">Docker <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">21:06</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>