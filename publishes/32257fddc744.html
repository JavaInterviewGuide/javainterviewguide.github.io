<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？ 区别： InnoDB支持事务，MyISAM不支持 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； InnoDB是聚集索引，数据文件是和"><meta property="og:type" content="article"><meta property="og:title" content="数据库"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/32257fddc744.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？ 区别： InnoDB支持事务，MyISAM不支持 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； InnoDB是聚集索引，数据文件是和"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:19:45.000Z"><meta property="article:modified_time" content="2023-12-28T06:04:43.824Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="数据库"><meta property="article:tag" content="MySQL"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/32257fddc744.html","path":"publishes/32257fddc744.html","title":"数据库"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>数据库 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD-MyISAM-%E5%92%8C-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9EID%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">InnoDB为什么推荐使用自增ID作为主键？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innodb%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">innodb引擎的4大特性</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BE%8F%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">⾏锁，表锁，乐观锁，悲观锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%EF%A7%BD%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">数据库隔离级别是什什么？有什么作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%BB%E5%A4%87%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%A7%A4%E3%80%82"><span class="nav-number">4.</span> <span class="nav-text">MySQL主备同步的基本原理理。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#select-from-table-t-where-size-10-group-by-size-order-by-size%E7%9A%84sql%E8%AF%AD%E5%8F%A5%EF%A4%86%E6%89%A7%E2%BE%8F%E8%A1%8C%EF%A8%88%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD"><span class="nav-number">6.</span> <span class="nav-text">如何优化数据库性能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%A5%A7%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">7.</span> <span class="nav-text">SQL什么情况下不会使用索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%9C%A8%E4%BB%80%EF%A7%BD%E4%B9%88%E5%AD%97%E6%AE%B5%E4%B8%8A%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">8.</span> <span class="nav-text">一般在什什么字段上建索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E5%87%8F%E5%BA%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">如何解决高并发减库存问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B2%92%E5%BA%A6%EF%BC%9B"><span class="nav-number">10.</span> <span class="nav-text">数据库事务的几种粒度；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E8%B0%83%E4%BC%98"><span class="nav-number">11.</span> <span class="nav-text">mysql调优</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">说说事务的四种特性（ACID）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#innodb%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">innodb如何实现mysql的事务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">让你设计一个索引，你会怎么设计？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">为什么用自增列作为主键？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">为什么使用数据索引能提高效率？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">B+树索引和哈希索引的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">17.0.0.1.</span> <span class="nav-text">哈希索引的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">17.0.0.2.</span> <span class="nav-text">哈希索引不适用的场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">B 树和 B+ 树的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4B-%E6%AF%94B%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E7%9A%84%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%BB%A3%E4%BB%B7%E6%9B%B4%E4%BD%8E%E3%80%82"><span class="nav-number">19.0.0.1.</span> <span class="nav-text">B+的磁盘读写代价更低。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-tree%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9B%B4%E5%8A%A0%E7%A8%B3%E5%AE%9A%E3%80%82"><span class="nav-number">19.0.0.2.</span> <span class="nav-text">B+-tree的查询效率更加稳定。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">20.</span> <span class="nav-text">关于 MySQL 联合索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E4%B8%8D%E5%BB%BA%E6%88%96%E5%B0%91%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">什么情况下应不建或少建索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A8%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">什么是表分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E4%B8%8E%E5%88%86%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">表分区与分表的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">表分区有什么好处？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A4%9A%E6%95%B0%E6%8D%AE"><span class="nav-number">24.0.0.1.</span> <span class="nav-text">存储更多数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">24.0.0.2.</span> <span class="nav-text">优化查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E6%9B%B4%E5%AE%B9%E6%98%93%E7%BB%B4%E6%8A%A4"><span class="nav-number">24.0.0.3.</span> <span class="nav-text">分区表更容易维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%9F%90%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E7%93%B6%E9%A2%88"><span class="nav-number">24.0.0.4.</span> <span class="nav-text">避免某些特殊的瓶颈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E9%99%90%E5%88%B6%E5%9B%A0%E7%B4%A0"><span class="nav-number">25.</span> <span class="nav-text">分区表的限制因素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8DMySQL%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">如何判断当前MySQL是否支持分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%86%E5%8C%BA%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">MySQL支持的分区类型有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EMVVC"><span class="nav-number">28.</span> <span class="nav-text">关于MVVC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">29.</span> <span class="nav-text">行级锁定的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">29.0.0.1.</span> <span class="nav-text">行级锁定的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">29.0.0.2.</span> <span class="nav-text">行级锁定的缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#key%E5%92%8Cindex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">30.</span> <span class="nav-text">key和index的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">31.</span> <span class="nav-text">数据库表创建注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E5%90%8D%E5%8F%8A%E5%AD%97%E6%AE%B5%E9%85%8D%E5%88%B6%E5%90%88%E7%90%86%E6%80%A7"><span class="nav-number">31.0.0.1.</span> <span class="nav-text">字段名及字段配制合理性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%AE%8A%E5%AD%97%E6%AE%B5%E5%A4%84%E7%90%86%E5%8F%8A%E5%BB%BA%E6%88%90%E5%90%8E%E5%BB%BA%E8%AE%AE"><span class="nav-number">31.0.0.2.</span> <span class="nav-text">系统特殊字段处理及建成后建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E5%90%88%E7%90%86%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">31.0.0.3.</span> <span class="nav-text">表结构合理性配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%BB%BA%E8%AE%AE"><span class="nav-number">31.0.0.4.</span> <span class="nav-text">其它建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">32.</span> <span class="nav-text">数据库三范式是什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF"><span class="nav-number">32.0.0.1.</span> <span class="nav-text">第一范式（1NF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89"><span class="nav-number">32.0.0.2.</span> <span class="nav-text">第二范式（2NF）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A1%E8%B6%B3%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89"><span class="nav-number">32.0.0.3.</span> <span class="nav-text">满足第三范式（3NF）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="nav-number">33.</span> <span class="nav-text">有哪些数据库优化方面的经验?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%A7%8D%E7%B1%BB"><span class="nav-number">34.</span> <span class="nav-text">请简述常用的索引有哪些种类?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">在mysql数据库中索引的工作机制是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-number">36.</span> <span class="nav-text">MySQL的基础操作命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E7%9A%84%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B"><span class="nav-number">37.</span> <span class="nav-text">mysql的复制原理以及流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E6%94%AF%E6%8C%81%E7%9A%84%E5%A4%8D%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">38.</span> <span class="nav-text">mysql支持的复制类型?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">38.0.0.1.</span> <span class="nav-text">基于语句的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">38.0.0.2.</span> <span class="nav-text">基于行的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">38.0.0.3.</span> <span class="nav-text">混合类型的复制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E4%B8%ADvarchar%E4%B8%8Echar%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8Avarchar-50-%E4%B8%AD%E7%9A%8450%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%B6%B5%E4%B9%89%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E4%B8%AD%E6%9C%89%E5%A4%A7%E5%AD%97%E6%AE%B5X%EF%BC%88%E4%BE%8B%E5%A6%82%EF%BC%9Atext%E7%B1%BB%E5%9E%8B%EF%BC%89%EF%BC%8C%E4%B8%94%E5%AD%97%E6%AE%B5X%E4%B8%8D%E4%BC%9A%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BB%A5%E8%AF%BB%E4%B8%BA%E4%B8%BA%E4%B8%BB%EF%BC%8C%E5%B0%86%E8%AF%A5%E5%AD%97%E6%AE%B5%E6%8B%86%E6%88%90%E5%AD%90%E8%A1%A8%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%ADInnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E9%80%9A%E8%BF%87%E5%8A%A0%E5%9C%A8%E4%BB%80%E4%B9%88%E4%B8%8A%E5%AE%8C%E6%88%90%EF%BC%88%E6%88%96%E7%A7%B0%E5%AE%9E%E7%8E%B0%EF%BC%89%E7%9A%84%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8B%A5%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5VARCHAR-N-%E7%B1%BB%E5%9E%8B%EF%BC%8Cutf8%E7%BC%96%E7%A0%81%EF%BC%8C%E5%88%99N%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91-%E7%B2%BE%E7%A1%AE%E5%88%B0%E6%95%B0%E9%87%8F%E7%BA%A7%E5%8D%B3%E5%8F%AF"><span class="nav-number">42.</span> <span class="nav-text">若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SELECT-%E5%92%8CSELECT-%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%E7%9A%842%E7%A7%8D%E5%86%99%E6%B3%95%E6%9C%89%E4%BD%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">43.</span> <span class="nav-text">SELECT * 和SELECT 全部字段的2种写法有何优缺点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HAVNG-%E5%AD%90%E5%8F%A5-%E5%92%8C-WHERE%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">44.</span> <span class="nav-text">HAVNG 子句 和 WHERE的异同点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E5%BD%93%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6insert-%E5%BD%93%E8%AE%B0%E5%BD%95%E5%AD%98%E5%9C%A8%E6%97%B6update%EF%BC%8C%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="nav-number">45.</span> <span class="nav-text">MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%9A%84insert%E5%92%8Cupdate%E7%9A%84select%E8%AF%AD%E5%8F%A5%E8%AF%AD%E6%B3%95"><span class="nav-number">46.</span> <span class="nav-text">MySQL的insert和update的select语句语法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="nav-number">47.</span> <span class="nav-text">Mysql 中有哪几种锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">Mysql 中有哪些不同的表格？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E5%92%8C%E5%80%99%E9%80%89%E9%94%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">主键和候选键有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#myisamchk-%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">myisamchk 是用来做什么的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MyISAM-Static-%E5%92%8C-MyISAM-Dynamic-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">MyISAM Static 和 MyISAM Dynamic 有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%9C%89%E4%B8%80%E5%88%97%E5%AE%9A%E4%B9%89%E4%B8%BA-TIMESTAMP%EF%BC%8C%E5%B0%86%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">如果一个表有一列定义为 TIMESTAMP，将发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E8%AE%BE%E7%BD%AE%E4%B8%BA-AUTO-INCREMENT-%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E8%A1%A8%E4%B8%AD%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99"><span class="nav-number">54.</span> <span class="nav-text">数据库架构原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88"><span class="nav-number">55.</span> <span class="nav-text">常见的数据库架构方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%A4%87%E6%9E%B6%E6%9E%84"><span class="nav-number">55.0.0.1.</span> <span class="nav-text">主备架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%B8%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">55.0.0.2.</span> <span class="nav-text">双主架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">55.0.0.3.</span> <span class="nav-text">主从架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%B8%BB-%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">55.0.0.4.</span> <span class="nav-text">双主+主从架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">56.</span> <span class="nav-text">一致性解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%BA%93%E5%92%8C%E4%BB%8E%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">56.0.0.1.</span> <span class="nav-text">主库和从库一致性解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DB%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">56.0.0.2.</span> <span class="nav-text">DB和缓存一致性解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">57.</span> <span class="nav-text">主从数据库不一致如何解决</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">58.</span> <span class="nav-text">说出数据连接池的工作机制是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">59.</span> <span class="nav-text">数据库创建索引的缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">60.</span> <span class="nav-text">说一下数据库的存储过程？</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">28</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">47</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="数据库 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据库</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:19:45" itemprop="dateCreated datePublished" datetime="2023-12-20T15:19:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-28 14:04:43" itemprop="dateModified" datetime="2023-12-28T14:04:43+08:00">2023-12-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul><li>区别：<ul><li>InnoDB支持事务，MyISAM不支持</li><li>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</li><li>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ul></li><li>如何选择：<ul><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ul></li></ul><h4 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h4><ul><li>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）</li><li>如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</li></ul><h4 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h4><ul><li>插入缓冲（insert buffer）</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h1 id="⾏锁，表锁，乐观锁，悲观锁？"><a href="#⾏锁，表锁，乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁，乐观锁，悲观锁？"></a>⾏锁，表锁，乐观锁，悲观锁？</h1><ul><li>⾏锁：数据库表中某一⾏被锁住。</li><li>表锁：整个数据库表被锁住。</li><li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不不会修改，具体实现是给表增加⼀个版本号的字段，在执行update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。</li><li>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。读数据的时候会上锁，直到update完成才释放锁，使⽤悲观锁要注意不要锁住整个表。</li></ul><h1 id="数据库隔离级别是什什么？有什么作用？"><a href="#数据库隔离级别是什什么？有什么作用？" class="headerlink" title="数据库隔离级别是什什么？有什么作用？"></a>数据库隔离级别是什什么？有什么作用？</h1><ul><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。 这种隔离级别会产⽣生脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外⼀个事务不能读取该 事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了了保证一个事务不能读取另⼀个事务未提交的数据外，还保证了了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理理为顺序执行。除了防止脏读， 不可重复读外，还避免了幻读。</li></ul><h1 id="MySQL主备同步的基本原理理。"><a href="#MySQL主备同步的基本原理理。" class="headerlink" title="MySQL主备同步的基本原理理。"></a>MySQL主备同步的基本原理理。</h1><ul><li>mysql主备复制实现分成三个步骤：<ul><li>master将改变记录到⼆进制⽇志(binary log) 中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</li><li>slave将master的binary log events拷⻉到它的中继日志(relay log) ；</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ul></li></ul><h1 id="select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？"><a href="#select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</h1><ul><li>sql语句句执⾏行行顺序如下：</li><li>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</li></ul><h1 id="如何优化数据库性能"><a href="#如何优化数据库性能" class="headerlink" title="如何优化数据库性能"></a>如何优化数据库性能</h1><ul><li>索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署</li><li>选择合适的数据库引擎，合理使用索引</li><li>分页获取数据，只获取需要的字段</li><li>优化业务逻辑，减少数据库IO</li><li>分库分表</li><li>部署主从数据库</li><li>升级硬件</li></ul><h1 id="SQL什么情况下不会使用索引"><a href="#SQL什么情况下不会使用索引" class="headerlink" title="SQL什么情况下不会使用索引"></a>SQL什么情况下不会使用索引</h1><ul><li>不包含，不等于，函数</li><li>select * 可能导致不走索引；</li><li>空值会导致不走索引，因为hashset不能存空值；</li><li>索引列有函数运算，不走索引，可以在索引列列建⽴立⼀一个函数的索引。</li><li>隐式转换可能导致不走索引；</li><li>表的数据库小或者需要选择大部分数据，不走索引；</li><li>!&#x3D;或者&lt;&gt;可能导致不走索引；</li><li>字符型的索引列列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式</li><li>like ‘%liu’ 百分号在前不走索引；</li><li>not in, not exist不走索引；</li></ul><h1 id="一般在什什么字段上建索引"><a href="#一般在什什么字段上建索引" class="headerlink" title="一般在什什么字段上建索引"></a>一般在什什么字段上建索引</h1><ul><li>过滤数据最多的字段</li><li>表的主键、外键必须有索引；</li><li>数据量量超过300的表应该有索引；</li><li>经常与其他表进行行连接的表，在连接字段上应该建立索引；</li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>如何从一张表中查出name字段不包含”XYZ”的所有行？</li></ul><h1 id="如何解决高并发减库存问题"><a href="#如何解决高并发减库存问题" class="headerlink" title="如何解决高并发减库存问题"></a>如何解决高并发减库存问题</h1><ul><li>消息队列，异步处理，减库存加锁</li></ul><h1 id="数据库事务的几种粒度；"><a href="#数据库事务的几种粒度；" class="headerlink" title="数据库事务的几种粒度；"></a>数据库事务的几种粒度；</h1><ul><li>表锁定：对整个表的锁定。</li><li>行锁定：只锁定进⾏行更改的行，例如：insert，update，delete，都隐式采用行锁定。</li><li>数据库锁机制可分为多种粒度的： 数据库，表，页面，行</li><li>粒度越大，DBMS管理越容易，但是实现并发处理的能力就越差，表，页面，行</li></ul><h1 id="mysql调优"><a href="#mysql调优" class="headerlink" title="mysql调优"></a>mysql调优</h1><ul><li>explain select语句；</li><li>当只要一条数据时使用limit 1；</li><li>为搜索字段建索引；</li><li>避免select *；</li><li>字段尽量使用not null；</li><li>垂直分割；</li><li>拆分大的delete和insert语句：delete和insert会锁表；</li><li>分表分库分区</li></ul><h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><ul><li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li><li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><ul><li>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页</li><li>然后redo log按照时间或者空间等条件进行落盘</li><li>undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了</li><li>此时，事务还未 COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤用undo log进⾏事务回滚</li><li>事务执行COMMIT操作时，会将本事务相关的所有redo log都进⾏落盘，只有所有redo log落盘成功，才算COMMIT成功</li><li>然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发⽣了崩溃，则只使⽤用redo log恢复数据。</li></ul><h1 id="让你设计一个索引，你会怎么设计？"><a href="#让你设计一个索引，你会怎么设计？" class="headerlink" title="让你设计一个索引，你会怎么设计？"></a>让你设计一个索引，你会怎么设计？</h1><ul><li>mysql默认存储引擎innodb只显式支持B树索引</li><li>对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</li></ul><h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><ul><li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。<ul><li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li><li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li></ul></li><li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放<ul><li>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</li></ul></li><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置<ul><li>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销</li><li>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li></ul></li></ul><h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ul><h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul><li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li><li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li></ul><h4 id="哈希索引的优势"><a href="#哈希索引的优势" class="headerlink" title="哈希索引的优势"></a>哈希索引的优势</h4><ul><li>等值查询，哈希索引具有绝对优势</li><li>前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题</li></ul><h4 id="哈希索引不适用的场景"><a href="#哈希索引不适用的场景" class="headerlink" title="哈希索引不适用的场景"></a>哈希索引不适用的场景</h4><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li><li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<ul><li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主</li><li>没有范围查询、没有排序的时候，特别适合采用哈希索引</li><li>仅等值查询<ul><li>select id, name from table where name&#x3D;’李明’;</li></ul></li></ul></li><li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li><li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li><li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li><li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li><li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read&#x2F;write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li></ul><h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li></ul><h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><h4 id="B-的磁盘读写代价更低。"><a href="#B-的磁盘读写代价更低。" class="headerlink" title="B+的磁盘读写代价更低。"></a>B+的磁盘读写代价更低。</h4><ul><li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li><li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多</li><li>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li></ul><h4 id="B-tree的查询效率更加稳定。"><a href="#B-tree的查询效率更加稳定。" class="headerlink" title="B+-tree的查询效率更加稳定。"></a>B+-tree的查询效率更加稳定。</h4><ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引</li><li>所以任何关键字的查找必须走一条从根结点到叶子结点的路</li><li>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><ul><li>联合索引是两个或更多个列上的索引</li><li>对于联合索引Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li><li>例如索引是key index (a,b,c).<ul><li>可以支持a 、 a,b 、 a,b,c 3种组合进行查找</li><li>但不支持 b,c进行查找</li><li>当最左侧字段是常量引用时，索引就十分有效。</li></ul></li><li>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</li><li>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。</li><li>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</li></ul><h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul><li>表记录太少</li><li>经常插入、删除、修改的表</li><li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul><li>表分区是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分</li><li>从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li></ul><h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul><li>分表：指的是通过一定规则，将一张表分解成多张不同的表</li><li>比如将用户订单记录根据时间成多个表。</li><li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li></ul><h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><h4 id="存储更多数据"><a href="#存储更多数据" class="headerlink" title="存储更多数据"></a>存储更多数据</h4><ul><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li><li>和单个磁盘或者文件系统相比，可以存储更多数据</li></ul><h4 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h4><ul><li>在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率</li><li>涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li></ul><h4 id="分区表更容易维护"><a href="#分区表更容易维护" class="headerlink" title="分区表更容易维护"></a>分区表更容易维护</h4><ul><li>例如：想批量删除大量数据可以清除整个分区。</li></ul><h4 id="避免某些特殊的瓶颈"><a href="#避免某些特殊的瓶颈" class="headerlink" title="避免某些特殊的瓶颈"></a>避免某些特殊的瓶颈</h4><ul><li>例如InnoDB的单个索引的互斥访问，ext3文件系统的inode锁竞争等。</li></ul><h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式</li><li>在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><ul><li>命令：show variables like ‘%partition%’ 运行结果:</li><li>mysql&gt; show variables like ‘%partition%’;</li><li>have_partintioning 的值为YES，表示支持分区。</li></ul><h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><ul><li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><ul><li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control)</li><li>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</li><li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</li><li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制</li><li>MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议</li><li>纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li><li>在MVCC并发控制中，读操作可以分成两类：<ul><li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li><li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li></ul></li></ul><h1 id="行级锁定的优缺点"><a href="#行级锁定的优缺点" class="headerlink" title="行级锁定的优缺点"></a>行级锁定的优缺点</h1><h4 id="行级锁定的优点"><a href="#行级锁定的优点" class="headerlink" title="行级锁定的优点"></a>行级锁定的优点</h4><ul><li>当在许多线程中访问不同的行时只存在少量锁定冲突</li><li>回滚时只有少量的更改</li><li>可以长时间锁定单一的行</li></ul><h4 id="行级锁定的缺点"><a href="#行级锁定的缺点" class="headerlink" title="行级锁定的缺点"></a>行级锁定的缺点</h4><ul><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul><li>key 是数据库的物理结构，它包含两层意义和作用<ul><li>一是约束（偏重于约束和规范数据库的结构完整性）</li><li>二是索引（辅助查询用的），包括primary key, unique key, foreign key 等</li></ul></li><li>index是数据库的物理结构<ul><li>它只是辅助查询的</li><li>它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储</li><li>索引要分类的话，分为前缀索引、全文本索引等；</li></ul></li></ul><h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><h4 id="字段名及字段配制合理性"><a href="#字段名及字段配制合理性" class="headerlink" title="字段名及字段配制合理性"></a>字段名及字段配制合理性</h4><ul><li>剔除关系不密切的字段；</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul><h4 id="系统特殊字段处理及建成后建议"><a href="#系统特殊字段处理及建成后建议" class="headerlink" title="系统特殊字段处理及建成后建议"></a>系统特殊字段处理及建成后建议</h4><ul><li>添加删除标记（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul><h4 id="表结构合理性配置"><a href="#表结构合理性配置" class="headerlink" title="表结构合理性配置"></a>表结构合理性配置</h4><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><h4 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h4><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul><h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><h4 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF"></a>第一范式（1NF</h4><ul><li>字段具有原子性,不可再分</li><li>所有关系型数据库系统都满足第一范式</li><li>数据库表中的字段都是单一属性的，不可再分</li></ul><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><ul><li>是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）</li><li>要求数据库表中的每个实例或行必须可以被惟一地区分</li><li>通常需要为表加上一个列，以存储各个实例的惟一标识</li><li>这个惟一属性列被称为主关键字或主键。</li></ul><h4 id="满足第三范式（3NF）"><a href="#满足第三范式（3NF）" class="headerlink" title="满足第三范式（3NF）"></a>满足第三范式（3NF）</h4><ul><li>必须先满足第二范式（2NF）</li><li>简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</li><li>所以第三范式具有如下特征<ul><li>每一列只有一个值</li><li>每一行都能区分</li><li>每一个表都不包含其他表已经包含的非主关键字信息。</li></ul></li></ul><h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><ul><li>用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</li><li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</li><li>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等</li><li>UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL</li><li>UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同<ul><li>对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录</li><li>对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</li></ul></li></ul><h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><ul><li>普通索引: 即针对数据库表创建索引</li><li>唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值</li><li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li><li>组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li></ul><h1 id="在mysql数据库中索引的工作机制是什么？"><a href="#在mysql数据库中索引的工作机制是什么？" class="headerlink" title="在mysql数据库中索引的工作机制是什么？"></a>在mysql数据库中索引的工作机制是什么？</h1><ul><li>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据</li><li>索引的实现通常使用B树及其变种B+树</li></ul><h1 id="MySQL的基础操作命令"><a href="#MySQL的基础操作命令" class="headerlink" title="MySQL的基础操作命令"></a>MySQL的基础操作命令</h1><ul><li>MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status</li><li>开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务</li><li>Shell 登入 MySQL: 运行命令 mysql -u root -p</li><li>列出所有数据库:运行命令 show databases;</li><li>切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库</li><li>列出某个数据库内所有表: show tables;</li><li>获取表内所有 Field 对象的名称和类型 :describe table_name;</li></ul><h1 id="mysql的复制原理以及流程"><a href="#mysql的复制原理以及流程" class="headerlink" title="mysql的复制原理以及流程"></a>mysql的复制原理以及流程</h1><ul><li>Mysql内建的复制功能是构建大型，高性能应用程序的基础</li><li>将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的</li><li>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器</li><li>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环</li><li>这些日志可以记录发送到从服务器的更新</li><li>当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置</li><li>从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新</li><li>过程如下<ul><li>主服务器把更新记录到二进制日志文件中</li><li>从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中</li><li>从服务器重做中继日志中的时间，把更新应用到自己的数据库上</li></ul></li></ul><h1 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型?"></a>mysql支持的复制类型?</h1><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><ul><li>在主服务器上执行的SQL语句，在从服务器上执行同样的语句</li><li>MySQL默认采用基于语句的复制，效率比较高</li><li>一旦发现没法精确复制时，会自动选着基于行的复制。</li></ul><h4 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h4><ul><li>把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持</li></ul><h4 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h4><ul><li>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</li></ul><h1 id="mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？"><a href="#mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？" class="headerlink" title="mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？"></a>mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</h1><ul><li>varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.</li><li>varchar(50)中50的涵义 : 最多存放50个字节</li><li>int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</li></ul><h1 id="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h1><ul><li>如果字段里面有大字段（text,blob）类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了</li><li>MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多</li><li>此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率</li><li>当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的</li><li>拆分开后，对字段的UPDAE就要UPDATE多个表了</li></ul><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</h1><ul><li>InnoDB行锁是通过给索引上的索引项加锁来实现的</li><li>这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的</li><li>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li></ul><h1 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</h1><ul><li>由于utf8的每个字符最多占用3个字节</li><li>而MySQL定义行的长度不能超过65535</li><li>因此N的最大值计算方法为：(65535-1-2)&#x2F;3</li><li>减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</li></ul><h1 id="SELECT-和SELECT-全部字段的2种写法有何优缺点"><a href="#SELECT-和SELECT-全部字段的2种写法有何优缺点" class="headerlink" title="SELECT * 和SELECT 全部字段的2种写法有何优缺点?"></a>SELECT * 和SELECT 全部字段的2种写法有何优缺点?</h1><ul><li>前者要解析数据字典，后者不需要</li><li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li><li>表字段改名，前者不需要修改，后者需要改</li><li>后者可以建立索引进行优化，前者无法优化</li><li>后者的可读性比前者要高</li></ul><h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><ul><li>语法上：where 用表中列名，having用select结果别名</li><li>影响结果范围：where从表读出数据的行数，having返回客户端的行数</li><li>索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作</li><li>where后面不能使用聚集函数，having是专门使用聚集函数的。</li></ul><h1 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h1><ul><li>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c&#x3D;c+1;</li></ul><h1 id="MySQL的insert和update的select语句语法"><a href="#MySQL的insert和update的select语句语法" class="headerlink" title="MySQL的insert和update的select语句语法"></a>MySQL的insert和update的select语句语法</h1><ul><li>insert into student (stuid,stuname,deptid) select 10,’xzm’,3 from student where stuid &gt; 8;</li><li>update student a inner join student b on b.stuID&#x3D;10 set a.stuname&#x3D;concat(b.stuname, b.stuID) where a.stuID&#x3D;10 ;</li></ul><h1 id="Mysql-中有哪几种锁？"><a href="#Mysql-中有哪几种锁？" class="headerlink" title="Mysql 中有哪几种锁？"></a>Mysql 中有哪几种锁？</h1><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低， 并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和 行锁之间，并发度一般。</li></ul><h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><ul><li>共有 5 种类型的表格：<ul><li>MyISAM</li><li>Heap</li><li>Merge</li><li>INNODB</li><li>ISAM</li></ul></li></ul><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul><li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li><li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li></ul><h1 id="myisamchk-是用来做什么的？"><a href="#myisamchk-是用来做什么的？" class="headerlink" title="myisamchk 是用来做什么的？"></a>myisamchk 是用来做什么的？</h1><ul><li>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。</li></ul><h1 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h1><ul><li>在 MyISAM Static 上的所有字段有固定宽度</li><li>动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。</li><li>MyISAM Static 在受损情况下更容易恢复。</li></ul><h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><ul><li>每当行被更改时，时间戳字段将获取当前时间戳。</li></ul><h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><ul><li>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</li></ul><h1 id="数据库架构原则"><a href="#数据库架构原则" class="headerlink" title="数据库架构原则"></a>数据库架构原则</h1><ul><li>高可用</li><li>高性能</li><li>一致性</li><li>扩展性</li></ul><h1 id="常见的数据库架构方案"><a href="#常见的数据库架构方案" class="headerlink" title="常见的数据库架构方案"></a>常见的数据库架构方案</h1><h4 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h4><ul><li>只有主库提供读写服务，备库冗余作故障转移用</li><li>高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写都操作主库，很容易产生瓶颈</li><li>大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能</li><li>另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 </li><li>一致性分析：读写都操作主库，不存在数据一致性问题。 </li><li>扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案</li><li>第二，扩展性差，这点可以通过分库分表来扩展。</li></ul></li></ul><h4 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h4><ul><li>两个主库同时提供服务，负载均衡</li><li>高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写性能相比于方案一都得到提升，提升一倍。</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）</li><li>如果非得在数据库架构层面扩展的话，扩展为方案四。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。</li></ul></li></ul><h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><ul><li>一主多从，读写分离</li><li>高可用分析：主库单点，从库高可用</li><li>一旦主库挂了，写服务也就无法提供。 </li><li>高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能</li><li>读的性能提高了，整体性能也提高了。</li><li>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引</li><li>线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。</li><li>带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长）</li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主库单点问题，笔者暂时没想到很好的解决方案。</li></ul></li><li>思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？</li></ul><h4 id="双主-主从架构"><a href="#双主-主从架构" class="headerlink" title="双主+主从架构"></a>双主+主从架构</h4><ul><li>看似完美的方案</li><li>高可用分析：高可用。 </li><li>高性能分析：高性能。 </li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案 。</li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） </li><li>可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。</li></ul><h1 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h1><h4 id="主库和从库一致性解决方案"><a href="#主库和从库一致性解决方案" class="headerlink" title="主库和从库一致性解决方案"></a>主库和从库一致性解决方案</h4><ul><li>数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的</li><li>这个同步时间内主库和从库的数据会存在不一致的情况</li><li>如果同步过程中有读请求，那么读到的就是从库中的老数据。</li><li>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<ul><li>直接忽略，如果业务允许延时存在，那么就不去管它。 </li><li>强制读主，采用主备架构方案，读写都走主库</li><li>用缓存来扩展数据库读性能</li><li>有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</li></ul></li><li>选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。</li><li>读请求时，同样的方式生成key先去查Cache，再判断是否命中</li><li>若命中，则读主库，否则读从库</li><li>代价是多了一次缓存读写，基本可以忽略。</li><li>半同步复制，等主从同步完成，写请求才返回</li><li>就是大家常说的“半同步复制”semi-sync</li><li>这可以利用数据库原生功能，实现比较简单</li><li>代价是写请求时延增长，吞吐量降低。 </li><li>数据库中间件，引入开源（mycat等）或自研的数据库中间层</li><li>个人理解，思路同选择读主</li><li>数据库中间件的成本比较高，并且还多引入了一层</li></ul><h4 id="DB和缓存一致性解决方案"><a href="#DB和缓存一致性解决方案" class="headerlink" title="DB和缓存一致性解决方案"></a>DB和缓存一致性解决方案</h4><ul><li>先来看一下常用的缓存使用方式：<ul><li>第一步：淘汰缓存；</li><li>第二步：写入数据库；</li><li>第三步：读取缓存？返回：读取数据库；</li><li>第四步：读取数据库后写入缓存。</li></ul></li><li>注：如果按照这种方式，不会产生DB和缓存不一致问题，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据</li><li>设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！</li><li>加缓存和索引是通用的提升数据库性能的方式； </li><li>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。</li><li>阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。</li></ul><p> </p><h1 id="主从数据库不一致如何解决"><a href="#主从数据库不一致如何解决" class="headerlink" title="主从数据库不一致如何解决"></a>主从数据库不一致如何解决</h1><ul><li>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</li><li>忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</li><li>强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</li><li>选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</li></ul><h1 id="说出数据连接池的工作机制是什么"><a href="#说出数据连接池的工作机制是什么" class="headerlink" title="说出数据连接池的工作机制是什么?"></a>说出数据连接池的工作机制是什么?</h1><ul><li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接</li><li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙</li><li>如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定</li><li>当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</li></ul><h1 id="数据库创建索引的缺点？"><a href="#数据库创建索引的缺点？" class="headerlink" title="数据库创建索引的缺点？"></a>数据库创建索引的缺点？</h1><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h1 id="说一下数据库的存储过程？"><a href="#说一下数据库的存储过程？" class="headerlink" title="说一下数据库的存储过程？"></a>说一下数据库的存储过程？</h1><ul><li>存储过程与函数的区别：<ul><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。</li><li>对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。</li><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。</li></ul></li><li>存储过程的优点：<ul><li>执行速度更快 – 在数据库中保存的存储过程语句都是编译过的</li><li>允许模块化程序设计 – 类似方法的复用</li><li>提高系统安全性 – 防止SQL注入</li><li>减少网络流通量 – 只要传输存储过程的名称</li></ul></li><li>系统存储过程一般以sp开头，用户自定义的存储过程一般以usp开头</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a> <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/4a23c7da79c0.html" rel="prev" title="Spring cloud"><i class="fa fa-angle-left"></i> Spring cloud</a></div><div class="post-nav-item"><a href="/publishes/e002a9c6759b.html" rel="next" title="Java web">Java web <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">2.6m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">39:05</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>