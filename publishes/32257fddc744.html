<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><meta name="description" content="MyISAM与InnoDB 的区别（9个不同点）区别   1、InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；   2、InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 3、InnoDB是聚集索引，使用B+T"><meta property="og:type" content="article"><meta property="og:title" content="数据库"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/32257fddc744.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="MyISAM与InnoDB 的区别（9个不同点）区别   1、InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；   2、InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 3、InnoDB是聚集索引，使用B+T"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:19:45.000Z"><meta property="article:modified_time" content="2023-12-20T07:20:18.893Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="数据库"><meta property="article:tag" content="MySQL"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/32257fddc744.html","path":"publishes/32257fddc744.html","title":"数据库"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>数据库 | Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java后端面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MyISAM%E4%B8%8EInnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%889%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">MyISAM与InnoDB 的区别（9个不同点）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">如何选择：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9EID%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">InnoDB为什么推荐使用自增ID作为主键？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#innodb%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.</span> <span class="nav-text">innodb引擎的4大特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BE%8F%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">⾏锁，表锁，乐观锁，悲观锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%EF%A7%BD%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">数据库隔离级别是什什么？有什么作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%BB%E5%A4%87%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%A7%A4%E3%80%82"><span class="nav-number">4.</span> <span class="nav-text">MySQL主备同步的基本原理理。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#select-from-table-t-where-size-gt-10-group-by-size-order-by-size%E7%9A%84sql%E8%AF%AD%E5%8F%A5%EF%A4%86%E6%89%A7%E2%BE%8F%E8%A1%8C%EF%A8%88%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%EF%BC%88%E7%B4%A2%E5%BC%95%E3%80%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E3%80%81%E6%89%B9%E7%BD%AE%E6%93%8D%E4%BD%9C%E3%80%81%E5%88%86%E2%BB%9A%E9%A1%B5%E7%AE%97%E6%B3%95%E3%80%81%E5%8D%87%E7%BA%A7%E7%A1%AC%E7%9B%98SSD%E3%80%81%E4%B8%9A%E5%8A%A1%E4%BC%98%E5%8C%96%E3%80%81%E4%B8%BB%E4%BB%8E%E9%83%A8%E7%BD%B2%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%80%94%E8%88%AC%E5%9C%A8%E4%BB%80%EF%A7%BD%E4%B9%88%E5%AD%97%E6%AE%B5%E4%B8%8A%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">—般在什什么字段上建索引（过滤数据最多的字段）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HRedis-RDB%E5%92%8CA0Ff%E5%A6%82%E4%BD%95%E5%81%9A%E2%BE%BC%E9%AB%98%E5%8F%AF%E2%BD%A4%E7%94%A8%E3%80%81%E9%9B%86%E7%BE%A4"><span class="nav-number">8.</span> <span class="nav-text">HRedis, RDB和A0Ff如何做⾼高可⽤用、集群</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%BE%BC%E9%AB%98%E5%B9%B6%E5%8F%91%E5%87%8F%E5%BA%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">如何解决⾼高并发减库存问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9B"><span class="nav-number">10.</span> <span class="nav-text">mysql存储引擎中索引的实现机制；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E2%BC%8F%E5%87%A0%E7%A7%8D%E7%B2%92%E5%BA%A6%EF%BC%9B"><span class="nav-number">11.</span> <span class="nav-text">数据库事务的⼏几种粒度；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E8%B0%83%E4%BC%98%EF%BC%9A"><span class="nav-number">12.</span> <span class="nav-text">mysql调优：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">说说事务的四种特性（ACID）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#innodb%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">innodb如何实现mysql的事务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E2%BC%80%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">让你设计⼀一个索引，你会怎么设计？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">为什么用自增列作为主键？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">为什么使用数据索引能提高效率？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">B+树索引和哈希索引的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="nav-number">19.</span> <span class="nav-text">哈希索引的优势：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">20.</span> <span class="nav-text">哈希索引不适用的场景：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">B 树和 B+ 树的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4B-%E6%AF%94B%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">23.</span> <span class="nav-text">关于 MySQL 联合索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E4%B8%8D%E5%BB%BA%E6%88%96%E5%B0%91%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">什么情况下应不建或少建索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A8%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">什么是表分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E4%B8%8E%E5%88%86%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">表分区与分表的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">表分区有什么好处？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E9%99%90%E5%88%B6%E5%9B%A0%E7%B4%A0"><span class="nav-number">28.</span> <span class="nav-text">分区表的限制因素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8DMySQL%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">如何判断当前MySQL是否支持分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%86%E5%8C%BA%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">MySQL支持的分区类型有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">31.</span> <span class="nav-text">四种隔离级别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EMVVC"><span class="nav-number">32.</span> <span class="nav-text">关于MVVC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">33.</span> <span class="nav-text">行级锁定的优点：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">34.</span> <span class="nav-text">行级锁定的缺点：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%BC%98%E5%8C%96"><span class="nav-number">35.</span> <span class="nav-text">MySQL优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#key%E5%92%8Cindex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">key和index的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD-MyISAM-%E5%92%8C-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">38.</span> <span class="nav-text">数据库表创建注意事项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">39.</span> <span class="nav-text">数据库优化的方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">40.</span> <span class="nav-text">数据库三范式是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="nav-number">41.</span> <span class="nav-text">有哪些数据库优化方面的经验?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%A7%8D%E7%B1%BB"><span class="nav-number">42.</span> <span class="nav-text">请简述常用的索引有哪些种类?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A5%E5%8F%8A%E5%9C%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">以及在mysql数据库中索引的工作机制是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-number">44.</span> <span class="nav-text">MySQL的基础操作命令:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E7%9A%84%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E3%80%82"><span class="nav-number">45.</span> <span class="nav-text">mysql的复制原理以及流程。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E6%94%AF%E6%8C%81%E7%9A%84%E5%A4%8D%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">46.</span> <span class="nav-text">mysql支持的复制类型?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E4%B8%ADmyisam%E4%B8%8Einnodb%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">47.</span> <span class="nav-text">mysql中myisam与innodb的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E4%B8%ADvarchar%E4%B8%8Echar%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8Avarchar-50-%E4%B8%AD%E7%9A%8450%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%B6%B5%E4%B9%89%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%ADInnoDB%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%90%8D%E7%A7%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%80%90%E7%BA%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E4%B8%AD%E6%9C%89%E5%A4%A7%E5%AD%97%E6%AE%B5X%EF%BC%88%E4%BE%8B%E5%A6%82%EF%BC%9Atext%E7%B1%BB%E5%9E%8B%EF%BC%89%EF%BC%8C%E4%B8%94%E5%AD%97%E6%AE%B5X%E4%B8%8D%E4%BC%9A%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BB%A5%E8%AF%BB%E4%B8%BA%E4%B8%BA%E4%B8%BB%EF%BC%8C%E5%B0%86%E8%AF%A5%E5%AD%97%E6%AE%B5%E6%8B%86%E6%88%90%E5%AD%90%E8%A1%A8%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%ADInnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E9%80%9A%E8%BF%87%E5%8A%A0%E5%9C%A8%E4%BB%80%E4%B9%88%E4%B8%8A%E5%AE%8C%E6%88%90%EF%BC%88%E6%88%96%E7%A7%B0%E5%AE%9E%E7%8E%B0%EF%BC%89%E7%9A%84%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">MySQL中控制内存分配的全局参数，有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8B%A5%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5VARCHAR-N-%E7%B1%BB%E5%9E%8B%EF%BC%8Cutf8%E7%BC%96%E7%A0%81%EF%BC%8C%E5%88%99N%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91-%E7%B2%BE%E7%A1%AE%E5%88%B0%E6%95%B0%E9%87%8F%E7%BA%A7%E5%8D%B3%E5%8F%AF"><span class="nav-number">53.</span> <span class="nav-text">若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SELECT-%E5%92%8C-SELECT-%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5-%E7%9A%842%E7%A7%8D%E5%86%99%E6%B3%95%E6%9C%89%E4%BD%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">54.</span> <span class="nav-text">[SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HAVNG-%E5%AD%90%E5%8F%A5-%E5%92%8C-WHERE%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">55.</span> <span class="nav-text">HAVNG 子句 和 WHERE的异同点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E5%BD%93%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6insert-%E5%BD%93%E8%AE%B0%E5%BD%95%E5%AD%98%E5%9C%A8%E6%97%B6update%EF%BC%8C%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%9A%84insert%E5%92%8Cupdate%E7%9A%84select%E8%AF%AD%E5%8F%A5%E8%AF%AD%E6%B3%95"><span class="nav-number">57.</span> <span class="nav-text">MySQL的insert和update的select语句语法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="nav-number">58.</span> <span class="nav-text">谈谈MySQL支持的事务隔离级别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="nav-number">59.</span> <span class="nav-text">Mysql 中有哪几种锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%9F"><span class="nav-number">60.</span> <span class="nav-text">Mysql 中有哪些不同的表格？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E5%9C%A8-MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD-MyISAM-%E5%92%8C-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">61.</span> <span class="nav-text">简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD-InnoDB-%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%90%8D%E7%A7%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%80%90%E7%BA%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">62.</span> <span class="nav-text">Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAR-%E5%92%8C-VARCHAR-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">63.</span> <span class="nav-text">CHAR 和 VARCHAR 的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E5%92%8C%E5%80%99%E9%80%89%E9%94%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">64.</span> <span class="nav-text">主键和候选键有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#myisamchk-%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-number">65.</span> <span class="nav-text">myisamchk 是用来做什么的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MyISAM-Static-%E5%92%8C-MyISAM-Dynamic-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">66.</span> <span class="nav-text">MyISAM Static 和 MyISAM Dynamic 有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%9C%89%E4%B8%80%E5%88%97%E5%AE%9A%E4%B9%89%E4%B8%BA-TIMESTAMP%EF%BC%8C%E5%B0%86%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">67.</span> <span class="nav-text">如果一个表有一列定义为 TIMESTAMP，将发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E8%AE%BE%E7%BD%AE%E4%B8%BA-AUTO-INCREMENT-%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E8%A1%A8%E4%B8%AD%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">68.</span> <span class="nav-text">列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E6%89%BE%E5%87%BA%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5%E6%97%B6%E5%88%86%E9%85%8D%E4%BA%86%E5%93%AA%E4%B8%AA%E8%87%AA%E5%8A%A8%E5%A2%9E%E9%87%8F%EF%BC%9F"><span class="nav-number">69.</span> <span class="nav-text">怎样才能找出最后一次插入时分配了哪个自动增量？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#required-unique-id-between-1-and-2-32-1"><span class="nav-number">70.</span> <span class="nav-text">required unique id between 1 and 2^32 - 1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defaults-to-1-if-master-host-is-not-set"><span class="nav-number">71.</span> <span class="nav-text">defaults to 1 if master-host is not set</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#but-will-not-function-as-a-master-if-omitted"><span class="nav-number">72.</span> <span class="nav-text">but will not function as a master if omitted</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#required-unique-id-between-1-and-2-32-1-1"><span class="nav-number">73.</span> <span class="nav-text">required unique id between 1 and 2^32 - 1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defaults-to-1-if-master-host-is-not-set-1"><span class="nav-number">74.</span> <span class="nav-text">defaults to 1 if master-host is not set</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#but-will-not-function-as-a-master-if-omitted-1"><span class="nav-number">75.</span> <span class="nav-text">but will not function as a master if omitted</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="数据库 | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据库</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:19:45 / 修改时间：15:20:18" itemprop="dateCreated datePublished" datetime="2023-12-20T15:19:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="MyISAM与InnoDB-的区别（9个不同点）"><a href="#MyISAM与InnoDB-的区别（9个不同点）" class="headerlink" title="MyISAM与InnoDB 的区别（9个不同点）"></a>MyISAM与InnoDB 的区别（9个不同点）</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>1、InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>2、InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>3、InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。<br>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。<br>也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</li><li>4、InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；<br>那么为什么InnoDB没有了这个变量呢？<br>因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。<br>如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS</li><li>5、Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了</li><li>6、MyISAM表格可以被压缩后进行查询操作</li><li>7、InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁<br>InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。<br>例如：</li></ul><pre><code>    t_user(uid, uname, age, sex) innodb;
 
    uid PK
    无其他索引
    update t_user set age=10 where uid=1;             命中索引，行锁。
 
    update t_user set age=10 where uid != 1;           未命中索引，表锁。
 
    update t_user set age=10 where name=&#39;chackca&#39;;    无索引，表锁。
</code></pre><ul><li>8、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</li><li>9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI<ul><li>Innodb：frm是表定义文件，ibd是数据文件</li><li>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</li></ul></li></ul><h2 id="如何选择："><a href="#如何选择：" class="headerlink" title="如何选择："></a>如何选择：</h2><p>*<br>1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；<br>*<br>1. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。<br>*<br>1. 系统奔溃后，MyISAM恢复起来更困难，能否接受；<br>*<br>1. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</p><h2 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h2><ul><li>答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</li></ul><h2 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h2><ul><li>插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</li></ul><h1 id="⾏锁，表锁，乐观锁，悲观锁？"><a href="#⾏锁，表锁，乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁，乐观锁，悲观锁？"></a>⾏锁，表锁，乐观锁，悲观锁？</h1><ul><li>a. ⾏锁：数据库表中某一⾏被锁住。</li><li>b. 表锁：整个数据库表被锁住。</li><li>c. 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不不会修改，具体实现是给表增加⼀个版本号的字段，在执行update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。</li><li>d. 悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。读数据的时候会上锁，直到update完成才释放锁，使⽤悲观锁要注意不要锁住整个表。</li></ul><h1 id="数据库隔离级别是什什么？有什么作用？"><a href="#数据库隔离级别是什什么？有什么作用？" class="headerlink" title="数据库隔离级别是什什么？有什么作用？"></a>数据库隔离级别是什什么？有什么作用？</h1><p>*<br>1. ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。 这种隔离级别会产⽣生脏读，不可重复读和幻读。<br>*<br>1. ISOLATIONREADCOMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外⼀个事务不能读取该 事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。<br>*<br>1. ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了了保证一个事务不能读取另⼀个事务未提交的数据外，还保证了了避免不可重复读。<br>*<br>1. ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理理为顺序执行。除了防止脏读， 不可重复读外，还避免了幻读。</p><h1 id="MySQL主备同步的基本原理理。"><a href="#MySQL主备同步的基本原理理。" class="headerlink" title="MySQL主备同步的基本原理理。"></a>MySQL主备同步的基本原理理。</h1><ul><li>mysql主备复制实现分成三个步骤：<ul><li>1、master将改变记录到⼆二进制⽇日志(binary log) 中（这些记录叫做⼆二进制⽇日志事件，binary log events，可以通过show binlog events进⾏行行查看）；</li><li>2、slave将master的binary log events拷⻉贝到它的中继⽇日志(relay log) ；</li><li>3、slave重做中继⽇日志中的事件，将改变反映它⾃自⼰己的数据。</li></ul></li></ul><h1 id="select-from-table-t-where-size-gt-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？"><a href="#select-from-table-t-where-size-gt-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</h1><ul><li>sql语句句执⾏行行顺序如下：</li><li>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</li></ul><h1 id="如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）"><a href="#如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）" class="headerlink" title="如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）"></a>如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署）</h1><ul><li>1、选择合适的数据库引擎，合理理使⽤用索引</li><li>2、分⻚页获取数据，只获取需要的字段</li><li>3、优化业务逻辑，减少数据库IO</li><li>4、分库分表</li><li>5、部署主从数据库</li><li>6、升级硬件</li><li><ol><li>SQL什什么情况下不不会使⽤用索引（不不包含，不不等于，函数）</li></ol><ul><li>a. select * 可能导致不不⾛走索引；</li><li>b. 空值会导致不不⾛走索引，因为hashset不不能存空值；</li><li>c. 索引列列有函数运算，不不⾛走索引，可以在索引列列建⽴立⼀一个函数的索引。</li><li>d. 隐式转换可能导致不不⾛走索引；</li><li>e. 表的数据库⼩小或者需要选择⼤大部分数据，不不⾛走索引；</li><li>f. !=或者&lt;&gt;可能导致不不⾛走索引；</li><li>g. 字符型的索引列列会导致优化器器认为需要扫描索引⼤大部分数据且聚簇因⼦子很⼤大，最终导致弃⽤用索引扫描⽽而改⽤用全表扫描方式</li><li>h. like ‘%liu’ 百分号在前不不⾛走索引；</li><li>i. not in, not exist不不⾛走索引；</li></ul></li></ul><h1 id="—般在什什么字段上建索引（过滤数据最多的字段）"><a href="#—般在什什么字段上建索引（过滤数据最多的字段）" class="headerlink" title="—般在什什么字段上建索引（过滤数据最多的字段）"></a>—般在什什么字段上建索引（过滤数据最多的字段）</h1><ul><li>1、表的主键、外键必须有索引；</li><li>2、数据量量超过300的表应该有索引；</li><li>3、经常与其他表进⾏行行连接的表，在连接字段上应该建⽴立索引；</li><li>4、经常出现在Where⼦子句句中的字段，特别是⼤大表的字段，应该建⽴立索引；</li><li>5、索引应该建在选择性⾼高的字段上；</li><li>6、索引应该建在⼩小字段上，对于⼤大的⽂文本字段甚⾄至超⻓长字段，不不要建索引；</li><li><ol><li>如何从⼀一张表中查出name字段不不包含”XYZ”的所有⾏行行？</li></ol></li></ul><h1 id="HRedis-RDB和A0Ff如何做⾼高可⽤用、集群"><a href="#HRedis-RDB和A0Ff如何做⾼高可⽤用、集群" class="headerlink" title="HRedis, RDB和A0Ff如何做⾼高可⽤用、集群"></a>HRedis, RDB和A0Ff如何做⾼高可⽤用、集群</h1><h1 id="如何解决⾼高并发减库存问题"><a href="#如何解决⾼高并发减库存问题" class="headerlink" title="如何解决⾼高并发减库存问题"></a>如何解决⾼高并发减库存问题</h1><ul><li>消息队列列，异步处理理，减库存加锁</li></ul><h1 id="mysql存储引擎中索引的实现机制；"><a href="#mysql存储引擎中索引的实现机制；" class="headerlink" title="mysql存储引擎中索引的实现机制；"></a>mysql存储引擎中索引的实现机制；</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/debug_zhang/article/details/52168552">https://blog.csdn.net/debug_zhang/article/details/52168552</a></p><h1 id="数据库事务的⼏几种粒度；"><a href="#数据库事务的⼏几种粒度；" class="headerlink" title="数据库事务的⼏几种粒度；"></a>数据库事务的⼏几种粒度；</h1><ul><li>a. 表锁定：对整个表的锁定。</li><li>b. ⾏行行锁定：只锁定进⾏行行更更改的⾏行行，例例如：insert，update，delete，都隐式采⽤用⾏行行锁定。</li><li>c. 数据库锁机制可分为多种粒度的： 数据库，表，⻚页⾯面，⾏行行</li><li>d. 粒度越⼤大，DBMS管理理越容易易，但是实现并发处理理的能⼒力力就越差，表，⻚页⾯面，⾏行行</li></ul><h1 id="mysql调优："><a href="#mysql调优：" class="headerlink" title="mysql调优："></a>mysql调优：</h1><ul><li>a. explain select语句句；</li><li>b. 当只要⼀一条数据时使⽤用limit 1；</li><li>c. 为搜索字段建索引；</li><li>d. 避免select *；</li><li>e. 字段尽量量使⽤用not null；</li><li>f. 垂直分割；</li><li>g. 拆分⼤大的delete和insert语句句：delete和insert会锁表；</li><li>h. 分表分库分区。</li></ul><h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><ul><li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li><li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><p>事务进⾏行行过程中，每次sql语句句执⾏行行，都会记录undo log和redo log，然后更更新数据形成脏⻚页，然后redo log按照时间或 者空间等条件进⾏行行落盘，undo log和脏⻚页按照checkpoint进⾏行行落盘，落盘后相应的redo log就可以删除了了。此时，事务还未 COMMIT，如果发⽣生崩溃，则⾸首先检查checkpoint记录，使⽤用相应的redo log进⾏行行数据和undo log的恢复，然后查看undo log的状 态发现事务尚未提交，然后就使⽤用undo log进⾏行行事务回滚。事务执⾏行行COMMIT操作时，会将本事务相关的所有redo log都进⾏行行落 盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏⻚页继续按照checkpoint进⾏行行落盘。如果此时发⽣生了了崩 溃，则只使⽤用redo log恢复数据。</p><h1 id="让你设计⼀一个索引，你会怎么设计？"><a href="#让你设计⼀一个索引，你会怎么设计？" class="headerlink" title="让你设计⼀一个索引，你会怎么设计？"></a>让你设计⼀一个索引，你会怎么设计？</h1><p>mysql默认存储引擎innodb只显式⽀支持B树索引，对于频繁访问的表，innodb会透明建⽴立⾃自适应hash索引，即在B树索引 基础上建⽴立hash索引，可以显著提⾼高查找效率，对于客户端是透明的，不不可控制的，隐式的。</p><h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><ul><li>1、如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。</li><li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li><li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li><li>2、数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放</li><li>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</li><li>3、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>4、如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置</li><li>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销</li><li>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li></ul><h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ul><h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul><li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li><li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li></ul><h1 id="哈希索引的优势："><a href="#哈希索引的优势：" class="headerlink" title="哈希索引的优势："></a>哈希索引的优势：</h1><ul><li>等值查询，哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</li></ul><h1 id="哈希索引不适用的场景："><a href="#哈希索引不适用的场景：" class="headerlink" title="哈希索引不适用的场景："></a>哈希索引不适用的场景：</h1><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li><li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：</li><li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：</li><li>仅等值查询</li><li>select id, name from table where name=’李明’;</li><li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li><li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li><li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li><li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li><li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li></ul><h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul><li>1、B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li><li>2、B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li></ul><h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><ul><li>1、B+的磁盘读写代价更低。</li><li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li><li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li><li>2、B+-tree的查询效率更加稳定。</li><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><ul><li>1、联合索引是两个或更多个列上的索引。</li><li>对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li><li>例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</li><li>2、利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</li><li>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。</li><li>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</li></ul><h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul><li>1、表记录太少</li><li>2、经常插入、删除、修改的表</li><li>3、数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>4、经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul><li>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li></ul><h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul><li>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。</li><li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li></ul><h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><ul><li>1、存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据</li><li>2、优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li><li>3、分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</li><li>4、避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</li></ul><h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><ul><li>命令：show variables like ‘%partition%’ 运行结果:</li><li>mysql&gt; show variables like ‘%partition%’;</li><li>+——————-+——-+| Variable_name | Value |+——————-+——-+| have_partitioning | YES |+——————-+——-+1 row in set (0.00 sec)</li><li>have_partintioning 的值为YES，表示支持分区。</li></ul><h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><ul><li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h1 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h1><ul><li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ul><h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><ul><li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control)</li><li>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</li><li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</li><li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制</li><li>MVCC：Multi-Version Concurrency Control</li><li>基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li><li>十八、在MVCC并发控制中，读操作可以分成两类：</li><li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li><li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li></ul><h1 id="行级锁定的优点："><a href="#行级锁定的优点：" class="headerlink" title="行级锁定的优点："></a>行级锁定的优点：</h1><ul><li>1、当在许多线程中访问不同的行时只存在少量锁定冲突。</li><li>2、回滚时只有少量的更改</li><li>3、可以长时间锁定单一的行。</li></ul><h1 id="行级锁定的缺点："><a href="#行级锁定的缺点：" class="headerlink" title="行级锁定的缺点："></a>行级锁定的缺点：</h1><ul><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h1 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h1><ul><li>开启查询缓存，优化查询</li><li>explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的</li><li>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</li><li>为搜索字段建索引</li><li>使用 ENUM 而不是 VARCHAR。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR</li><li>Prepared StatementsPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</li><li>Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击</li><li>垂直分表</li><li>选择正确的存储引擎</li></ul><h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul><li>key 是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等</li><li>index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；</li></ul><h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul><li>区别：<ul><li>InnoDB支持事务，MyISAM不支持</li><li>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</li><li>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ul></li><li>如何选择：<ul><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ul></li></ul><h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><ul><li>1、字段名及字段配制合理性<ul><li>剔除关系不密切的字段；</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul></li><li>2、系统特殊字段处理及建成后建议<ul><li>添加删除标记（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul></li><li>3、表结构合理性配置<ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul></li><li>4、其它建议<ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul></li></ul><h1 id="数据库优化的方案"><a href="#数据库优化的方案" class="headerlink" title="数据库优化的方案"></a>数据库优化的方案</h1><p>建立主键，为数据库创建索引，建立存储过程，触发器，可提高查询速度</p><h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><p>*<br>1. 第一范式（1NF）：字段具有原子性,不可再分。(所有关系型数据库系统都满足第一范式数据库表中的字段都是单一属性的，不可再分)<br>*<br>1. 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。<br>*<br>1. 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 &gt;所以第三范式具有如下特征： &gt;&gt;1. 每一列只有一个值 &gt;&gt;2. 每一行都能区分。 &gt;&gt;3. 每一个表都不包含其他表已经包含的非主关键字信息。</p><h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><p>*<br>1. 用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。<br>*<br>1. 有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。<br>*<br>1. 表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等<br>*<br>1. UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL。 &gt;&gt;UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。 &gt;1. 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。 &gt;2. 对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</p><h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><p>*<br>1. 普通索引: 即针对数据库表创建索引<br>*<br>1. 唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值<br>*<br>1. 主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引<br>*<br>1. 组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</p><h1 id="以及在mysql数据库中索引的工作机制是什么？"><a href="#以及在mysql数据库中索引的工作机制是什么？" class="headerlink" title="以及在mysql数据库中索引的工作机制是什么？"></a>以及在mysql数据库中索引的工作机制是什么？</h1><ul><li>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树</li></ul><h1 id="MySQL的基础操作命令"><a href="#MySQL的基础操作命令" class="headerlink" title="MySQL的基础操作命令:"></a>MySQL的基础操作命令:</h1><p>*<br>1. MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status<br>*<br>1. 开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务<br>*<br>1. Shell 登入 MySQL: 运行命令 mysql -u root -p<br>*<br>1. 列出所有数据库:运行命令 show databases;<br>*<br>1. 切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库<br>*<br>1. 列出某个数据库内所有表: show tables;<br>*<br>1. 获取表内所有 Field 对象的名称和类型 :describe table_name;</p><h1 id="mysql的复制原理以及流程。"><a href="#mysql的复制原理以及流程。" class="headerlink" title="mysql的复制原理以及流程。"></a>mysql的复制原理以及流程。</h1><ul><li>Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的。 * 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。 当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。 过程如下 1. 主服务器把更新记录到二进制日志文件中。 2. 从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中。 3. 从服务器重做中继日志中的时间，把更新应用到自己的数据库上。</li></ul><h1 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型?"></a>mysql支持的复制类型?</h1><p>*<br>1. 基于语句的复制： 在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。 一旦发现没法精确复制时，会自动选着基于行的复制。<br>*<br>1. 基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持<br>*<br>1. 混合类型的复制: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p><h1 id="mysql中myisam与innodb的区别？"><a href="#mysql中myisam与innodb的区别？" class="headerlink" title="mysql中myisam与innodb的区别？"></a>mysql中myisam与innodb的区别？</h1><p>*<br>1. 事务支持 &gt; MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 &gt; InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。<br>*<br>1. InnoDB支持行级锁，而MyISAM支持表级锁. &gt;&gt; 用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>*<br>1. InnoDB支持MVCC, 而MyISAM不支持<br>*<br>1. InnoDB支持外键，而MyISAM不支持<br>*<br>1. 表主键 &gt; MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 &gt; InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。<br>*<br>1. InnoDB不支持全文索引，而MyISAM支持。<br>*<br>1. 可移植性、备份及恢复 &gt; MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 &gt; InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了<br>*<br>1. 存储结构 &gt; MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。 &gt; InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h1 id="mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？"><a href="#mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？" class="headerlink" title="mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？"></a>mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</h1><p>*<br>1. varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.<br>*<br>1. varchar(50)中50的涵义 : 最多存放50个字节<br>*<br>1. int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</p><h1 id="MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h1><p>*<br>1. Read Uncommitted（读取未提交内容） &gt;&gt; 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>*<br>1. Read Committed（读取提交内容） &gt;&gt; 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>*<br>1. Repeatable Read（可重读） &gt;&gt; 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。<br>*<br>1. Serializable（可串行化） &gt;&gt; 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<table><thead><tr><th align="left">隔离级别</th><th align="left">脏读（Dirty Read）</th><th align="left">不可重复读（NonRepeatable Read）</th><th align="left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td align="left">未提交读（Read uncommitted）</td><td align="left">可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">已提交读（Read committed）</td><td align="left">不可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">可重复读（Repeatable read）</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">可能</td></tr><tr><td align="left">可串行化（SERIALIZABLE）</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">不可能</td></tr></tbody></table></p><h1 id="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h1><ul><li>如果字段里面有大字段（text,blob)类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了。 MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多。此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后，对字段的UPDAE就要UPDATE多个表了</li></ul><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</h1><ul><li>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li></ul><h1 id="MySQL中控制内存分配的全局参数，有哪些？"><a href="#MySQL中控制内存分配的全局参数，有哪些？" class="headerlink" title="MySQL中控制内存分配的全局参数，有哪些？"></a>MySQL中控制内存分配的全局参数，有哪些？</h1><p>*<br>1. Keybuffersize： &gt; * keybuffersize指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Keyreadrequests和Keyreads，可以知道keybuffersize设置是否合理。比例keyreads /keyreadrequests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘keyread%’获得）。 &gt; * keybuffersize只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值createdtmpdisktables得知详情。对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M） &gt; * keybuffersize设置注意事项 &gt;&gt;&gt;1. 单个keybuffer的大小不能超过4G，如果设置超过4G，就有可能遇到下面3个bug: &gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=29446">http://bugs.mysql.com/bug.php?id=29446</a><br>&gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=29419">http://bugs.mysql.com/bug.php?id=29419</a><br>&gt;&gt;&gt;&gt;&gt; <a target="_blank" rel="noopener" href="http://bugs.mysql.com/bug.php?id=5731">http://bugs.mysql.com/bug.php?id=5731</a><br>&gt;&gt;&gt;2. 建议keybuffer设置为物理内存的1/4(针对MyISAM引擎)，甚至是物理内存的30%~40%，如果keybuffersize设置太大，系统就会频繁的换页，降低系统性能。因为MySQL使用操作系统的缓存来缓存数据，所以我们得为系统留够足够的内存；在很多情况下数据要比索引大得多。 &gt;&gt;&gt;3. 如果机器性能优越，可以设置多个keybuffer,分别让不同的keybuffer来缓存专门的索引<br>*<br>1. innodbbufferpool_size &gt; 表示缓冲池字节大小，InnoDB缓存表和索引数据的内存区域。mysql默认的值是128M。最大值与你的CPU体系结构有关，在32位操作系统，最大值是 4294967295 (2^32-1) ，在64 位操作系统，最大值为18446744073709551615 (2^64-1)。 &gt; 在32位操作系统中，CPU和操作系统实用的最大大小低于设置的最大值。如果设定的缓冲池的大小大于1G，设置innodbbufferpoolinstances的值大于1. &gt; * 数据读写在内存中非常快, innodbbufferpoolsize 减少了对磁盘的读写。 当数据提交或满足检查点条件后才一次性将内存数据刷新到磁盘中。然而内存还有操作系统或数据库其他进程使用, 一般设置 buffer pool 大小为总内存的 3/4 至 4/5。 若设置不当, 内存使用可能浪费或者使用过多。 对于繁忙的服务器, buffer pool 将划分为多个实例以提高系统并发性, 减少线程间读写缓存的争用。buffer pool 的大小首先受 innodbbufferpool_instances 影响, 当然影响较小。<br>*<br>1. querycachesize &gt; 当mysql接收到一条select类型的query时，mysql会对这条query进行hash计算而得到一个hash值，然后通过该hash值到query cache中去匹配，如果没有匹配中，则将这个hash值存放在一个hash链表中，同时将query的结果集存放进cache中，存放hash值的链表的每一个hash节点存放了相应query结果集在cache中的地址，以及该query所涉及到的一些table的相关信息；如果通过hash值匹配到了一样的query，则直接将cache中相应的query结果集返回给客户端。如果mysql任何一个表中的任何一条数据发生了变化，便会通知query cache需要与该table相关的query的cache全部失效，并释放占用的内存地址。 &gt; query cache优缺点 &gt;&gt; 1. query语句的hash计算和hash查找带来的资源消耗。mysql会对每条接收到的select类型的query进行hash计算然后查找该query的cache是否存在，虽然hash计算和查找的效率已经足够高了，一条query所带来的消耗可以忽略，但一旦涉及到高并发，有成千上万条query时，hash计算和查找所带来的开销就的重视了； &gt;&gt; 2. query cache的失效问题。如果表变更比较频繁，则会造成query cache的失效率非常高。表变更不仅仅指表中的数据发生变化，还包括结构或者索引的任何变化； &gt;&gt; 3. 对于不同sql但同一结果集的query都会被缓存，这样便会造成内存资源的过渡消耗。sql的字符大小写、空格或者注释的不同，缓存都是认为是不同的sql（因为他们的hash值会不同）； &gt;&gt; 4. 相关参数设置不合理会造成大量内存碎片，相关的参数设置会稍后介绍。<br>*<br>1. readbuffersize &gt;是MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。readbuffersize变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。</p><h1 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</h1><ul><li>由于utf8的每个字符最多占用3个字节。而MySQL定义行的长度不能超过65535，因此N的最大值计算方法为：(65535-1-2)/3。减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</li></ul><h1 id="SELECT-和-SELECT-全部字段-的2种写法有何优缺点"><a href="#SELECT-和-SELECT-全部字段-的2种写法有何优缺点" class="headerlink" title="[SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?"></a>[SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?</h1><p>*<br>1. 前者要解析数据字典，后者不需要<br>*<br>1. 结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。<br>*<br>1. 表字段改名，前者不需要修改，后者需要改<br>*<br>1. 后者可以建立索引进行优化，前者无法优化<br>*<br>1. 后者的可读性比前者要高</p><h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><p>*<br>1. 语法上：where 用表中列名，having用select结果别名<br>*<br>1. 影响结果范围：where从表读出数据的行数，having返回客户端的行数<br>*<br>1. 索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作<br>*<br>1. where后面不能使用聚集函数，having是专门使用聚集函数的。</p><h1 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h1><ul><li>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;</li></ul><h1 id="MySQL的insert和update的select语句语法"><a href="#MySQL的insert和update的select语句语法" class="headerlink" title="MySQL的insert和update的select语句语法"></a>MySQL的insert和update的select语句语法</h1><pre><code>SQL insert into student (stuid,stuname,deptid) select 10,&#39;xzm&#39;,3 from student where stuid &gt; 8;
update student a inner join student b on b.stuID=10 set a.stuname=concat(b.stuname, b.stuID) where a.stuID=10 ; 
</code></pre><h1 id="谈谈MySQL支持的事务隔离级别？"><a href="#谈谈MySQL支持的事务隔离级别？" class="headerlink" title="谈谈MySQL支持的事务隔离级别？"></a>谈谈MySQL支持的事务隔离级别？</h1><ul><li>典型回答: MySQL数据库事务隔离级别分为四个不同层次:</li><li>读未提交: 一个事务能够读取其他事务未提交的修改的数据,这是最低的隔离水平,允许 脏读出现。</li><li>脏读的场景：</li></ul><table><thead><tr><th>时间顺序</th><th>转账事务</th><th>取款事务</th></tr></thead><tbody><tr><td>1</td><td></td><td>开始事务</td></tr><tr><td>2</td><td>开始事务</td><td></td></tr><tr><td>3</td><td></td><td>查询账户余额为2000元</td></tr><tr><td>4</td><td></td><td>取款1000元，余额被更改为1000元</td></tr><tr><td>5</td><td>查询账户余额为1000元（产生脏读）</td><td></td></tr><tr><td>6</td><td></td><td>取款操作发生未知错误，事务回滚，余额变更为2000元</td></tr><tr><td>7</td><td>转入2000元，余额被更改为3000元（脏读的1000+2000）</td><td></td></tr><tr><td>8</td><td>提交事务</td><td></td></tr><tr><td>备注</td><td>按照正确逻辑，此时账户余额应该为4000元</td><td></td></tr></tbody></table><ul><li>读已提交: 一个事务能够读取其他事务已经提交的修改的数据,脏读不会出现。但是隔离 级别比较低,允许出现不可重复读和幻象读。</li><li>不可重读的场景:</li></ul><table><thead><tr><th>时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td>第一次查询，小明的年龄为20岁</td><td></td></tr><tr><td>3</td><td></td><td>开始事务</td></tr><tr><td>4</td><td>其他操作</td><td></td></tr><tr><td>5</td><td></td><td>更改小明的年龄为30岁</td></tr><tr><td>6</td><td></td><td>提交事务</td></tr><tr><td>7</td><td>第二次查询，小明的年龄为30岁</td><td></td></tr><tr><td>备注</td><td>按照正确逻辑，事务A前后两次读取到的数据应该一致</td><td></td></tr></tbody></table><ul><li>可重复读： 一个事务读取到另一个事务已经提交的数据,隔离级别比较高,允许出现幻读。</li><li>幻读的场景：</li></ul><table><thead><tr><th>时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td>第一次查询，数据总量为100条</td><td></td></tr><tr><td>3</td><td></td><td>开始事务</td></tr><tr><td>4</td><td>其他操作</td><td></td></tr><tr><td>5</td><td></td><td>新增100条数据</td></tr><tr><td>6</td><td></td><td>提交事务</td></tr><tr><td>7</td><td>第二次查询，数据总量为200条</td><td></td></tr><tr><td>备注</td><td>按照正确逻辑，事务A前后两次读取到的数据总量应该一致</td><td></td></tr></tbody></table><ul><li>这也是MySQL InnoDB引擎的默认隔离级别,但是和一些其他的数据库不同,可以简单的认为 MySQL在可重复读级别不会出现幻读。</li><li>串行化: 并发事务之间是串行化的,通常意味着读取需要共享读锁,更新需要获取排他写 锁。这是最高的隔离级别。</li><li>不可重复读和幻读到底有什么区别呢？<ul><li>（1）不可重复读是读取了其他事务更改的数据，针对update操作 解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许 其他事务更改刚才的数据。</li><li>（2）幻读是读取了其他事务新增的数据，针对insert操作 解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才 允许其他事务新增数据。</li></ul></li></ul><h1 id="Mysql-中有哪几种锁？"><a href="#Mysql-中有哪几种锁？" class="headerlink" title="Mysql 中有哪几种锁？"></a>Mysql 中有哪几种锁？</h1><p>*<br>1. 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>*<br>1. 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低， 并发度也最高。<br>*<br>1. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和 行锁之间，并发度一般。</p><h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><p>共有 5 种类型的表格：</p><ul><li>MyISAM</li><li>Heap</li><li>Merge</li><li>INNODB</li><li>ISAM</li></ul><h1 id="简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别"><a href="#简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别" class="headerlink" title="简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别"></a>简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别</h1><ul><li>MyISAM：<ul><li>不支持事务，但是每次查询都是原子的； 支持表级锁，即每次操作是对整个表加锁； 存储表的总行数；</li><li>一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；</li><li>采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本 一致，但是辅索引不用保证唯一性。</li></ul></li><li>InnoDb：<ul><li>支持 ACID 的事务，支持事务的四种隔离级别； 支持行级锁及外键约束：因此可以支持写并发； 不存储总行数；</li><li>一个 InnoDb 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一 个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系 统文件大小限制，一般为 2G），受操作系统文件大小的限制；</li><li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最 好使用自增主键，防止插入数据时，为维持 B+树结构，文件的大调整。</li></ul></li></ul><h1 id="Mysql-中-InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#Mysql-中-InnoDB-支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</h1><ul><li>SQL 标准定义的四个隔离级别为：<ul><li>read uncommited ：读到未提交数据</li><li>read committed：脏读，不可重复读</li><li>repeatable read：可重读</li><li>serializable ：串行事物</li></ul></li></ul><h1 id="CHAR-和-VARCHAR-的区别？"><a href="#CHAR-和-VARCHAR-的区别？" class="headerlink" title="CHAR 和 VARCHAR 的区别？"></a>CHAR 和 VARCHAR 的区别？</h1><ul><li>1.CHAR 和 VARCHAR 类型在存储和检索方面有所不同</li><li>2.CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255</li><li>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除 尾随空格。</li></ul><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul><li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li><li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li></ul><h1 id="myisamchk-是用来做什么的？"><a href="#myisamchk-是用来做什么的？" class="headerlink" title="myisamchk 是用来做什么的？"></a>myisamchk 是用来做什么的？</h1><ul><li>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。</li></ul><h1 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h1><ul><li>在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。</li><li>MyISAM Static 在受损情况下更容易恢复。</li></ul><h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><p>每当行被更改时，时间戳字段将获取当前时间戳。</p><h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p><h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="怎样才能找出最后一次插入时分配了哪个自动增量？"></a>怎样才能找出最后一次插入时分配了哪个自动增量？</h1><ul><li>（1）Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。</li><li>（2）用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。</li><li>（3） 避免在索引列上使用计算</li><li>（4）避免在索引列上使用 IS NULL 和 IS NOT NULL</li><li>（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃 使用索引而进行全表扫描</li></ul><p>一、数据库架构原则<br>1.<br>高可用<br>2.<br>3.<br>高性能<br>4.<br>5.<br>一致性<br>6.<br>7.<br>扩展性<br>8.<br>二、常见的数据库架构方案<br>方案一：主备架构，只有主库提供读写服务，备库冗余作故障转移用</p><p>jdbc:mysql://vip:3306/xxdb<br>1、高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库。这个过程对业务层是透明的，无需修改代码或配置。 <br>2、高性能分析：读写都操作主库，很容易产生瓶颈。大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能。另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 <br>3、一致性分析：读写都操作主库，不存在数据一致性问题。 <br>4、扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 <br>5、可落地分析：两点影响落地使用。第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案。第二，扩展性差，这点可以通过分库分表来扩展。<br>方案二：双主架构，两个主库同时提供服务，负载均衡</p><p>jdbc:mysql://vip:3306/xxdb<br>1、高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务。这个过程对业务层是透明的，无需修改代码或配置。 <br>2、高性能分析：读写性能相比于方案一都得到提升，提升一倍。<br>3、一致性分析：存在数据一致性问题。请看，一致性解决方案。 <br>4、扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）。如果非得在数据库架构层面扩展的话，扩展为方案四。 <br>5、可落地分析：两点影响落地使用。第一，数据一致性问题，一致性解决方案可解决问题。第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。<br>方案三：主从架构，一主多从，读写分离</p><p>jdbc:mysql://master-ip:3306/xxdb</p><p> jdbc:mysql://slave1-ip:3306/xxdb</p><p> jdbc:mysql://slave2-ip:3306/xxdb<br>1、高可用分析：主库单点，从库高可用。一旦主库挂了，写服务也就无法提供。 <br>2、高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能。读的性能提高了，整体性能也提高了。<br>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引<br>（线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引）<br>3、一致性分析：存在数据一致性问题。请看，一致性解决方案。 <br>4、扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。<br>（带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长） <br>5、可落地分析：两点影响落地使用。第一，数据一致性问题，一致性解决方案可解决问题。第二，主库单点问题，笔者暂时没想到很好的解决方案。<br>注：思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？<br>方案四：双主+主从架构，看似完美的方案</p><p>dbc:mysql://vip:3306/xxdb</p><p> jdbc:mysql://slave1-ip:3306/xxdb</p><p> jdbc:mysql://slave2-ip:3306/xxdb<br>1、高可用分析：高可用。 <br>2、高性能分析：高性能。 <br>3、一致性分析：存在数据一致性问题。请看，一致性解决方案 。<br>4、扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） <br>5、可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。<br>三、一致性解决方案<br>第一类：主库和从库一致性解决方案</p><p>注：图中圈出的是数据同步的地方，数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的，这个同步时间内主库和从库的数据会存在不一致的情况。如果同步过程中有读请求，那么读到的就是从库中的老数据。<br>如下图</p><p>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<br>1、直接忽略，如果业务允许延时存在，那么就不去管它。 <br>2、强制读主，采用主备架构方案，读写都走主库。用缓存来扩展数据库读性能 。有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</p><p>3、选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。<br>读请求时，同样的方式生成key先去查Cache，再判断是否命中。若命中，则读主库，否则读从库。代价是多了一次缓存读写，基本可以忽略。</p><p>4、半同步复制，等主从同步完成，写请求才返回。就是大家常说的“半同步复制”semi-sync。这可以利用数据库原生功能，实现比较简单。代价是写请求时延增长，吞吐量降低。 <br>5、数据库中间件，引入开源（mycat等）或自研的数据库中间层。个人理解，思路同选择读主。数据库中间件的成本比较高，并且还多引入了一层。**</p><p>第二类：DB和缓存一致性解决方案</p><p>先来看一下常用的缓存使用方式：<br>第一步：淘汰缓存；<br>第二步：写入数据库；<br>第三步：读取缓存？返回：读取数据库；<br>第四步：读取数据库后写入缓存。<br>注：如果按照这种方式，图一，不会产生DB和缓存不一致问题；图二，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据。解决方式如下：</p><p>注：设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！<br>四、个人的一些见解<br>1、架构演变<br>1、架构演变一：方案一 -&gt; 方案一+分库分表 -&gt; 方案二+分库分表 -&gt; 方案四+分库分表； <br>2、架构演变二：方案一 -&gt; 方案一+分库分表 -&gt; 方案三+分库分表 -&gt; 方案四+分库分表； <br>3、架构演变三：方案一 -&gt; 方案二 -&gt; 方案四 -&gt; 方案四+分库分表； <br>4、架构演变四：方案一 -&gt; 方案三 -&gt; 方案四 -&gt; 方案四+分库分表；<br>2、个人见解<br>1、加缓存和索引是通用的提升数据库性能的方式； <br>2、分库分表带来的好处是巨大的，但同样也会带来一些问题，详见前日推文。<br>3、不管是主备+分库分表还是主从+读写分离+分库分表，都要考虑具体的业务场景。<br>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。<br>另外，阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。 </p><p>两台MySQL数据库数据同步实现<br>做开发的时候要做Mysql的数据库同步，两台安装一样的系统，都是FreeBSD5.4，安装了Apache 2.0.55和PHP 4.4.0，Mysql的版本是4.1.15，都是目前最新的版本。</p><ol><li><p>安装配置<br>两台服务器，分别安装好Mysql，都安装在 /usr/local/mysql 目录下（安装步骤省略，请参考相关文档），两台服务器的IP分别是192.168.0.1和192.168.0.2，我们把192.168.0.1作为master数据库，把192.168.0.2作为slave服务器，我们采用单向同步的方式，就是master的数据是主的数据，然后slave主动去master哪儿同步数据回来。<br>两台服务器的配置一样，我们把关键的配置文件拷贝一下，默认的配置文件是在 /usr/local/mysql/share/mysql目录下，分别有 my-large.cnf, my-medium.cnf, my-small.cnf等几个文家，我们只是测试，使用my-medium.cnf就行了。mysql安装完后，默认的配置文件是指定在数据库存放目录下的，我们用的是4.1.X的，所以配置文件就应该在 /usr/local/mysql/var 目录下，于是把配置文件拷贝过去：<br>cp /usr/local/mysql/share/mysql/my-medium.cnf  /usr/local/mysql/var/my.cnf<br>两台服务器做相同的拷贝配置文件操作。</p></li><li><p>配置Master服务器</p></li></ol><p>我们要把192.168.0.1配置为主mysql服务器（master），那么我们就要考虑我们需要同步那个数据库，使用那个用户同步，我们这里为了简单起见，就使用root用户进行同步，并且只需要同步数据库abc。<br>打开配置文件：<br>vi /usr/local/mysql/var/my.cnf<br>找到一下信息：</p><h1 id="required-unique-id-between-1-and-2-32-1"><a href="#required-unique-id-between-1-and-2-32-1" class="headerlink" title="required unique id between 1 and 2^32 - 1"></a>required unique id between 1 and 2^32 - 1</h1><h1 id="defaults-to-1-if-master-host-is-not-set"><a href="#defaults-to-1-if-master-host-is-not-set" class="headerlink" title="defaults to 1 if master-host is not set"></a>defaults to 1 if master-host is not set</h1><h1 id="but-will-not-function-as-a-master-if-omitted"><a href="#but-will-not-function-as-a-master-if-omitted" class="headerlink" title="but will not function as a master if omitted"></a>but will not function as a master if omitted</h1><p>server-id        = 1    //1为master，2为salve<br>添加两行：<br>sql-bin-update-same     //同步形式<br>binlog-do-db     = abc  //要同步的数据库<br>重启192.168.0.1的mysql服务器：<br>/usr/local/mysql/bin/mysqladmin shutdown<br>/usr/local/mysql/bin/mysqld_safe –user=mysql &amp;</p><ol start="3"><li><p>配置Slave服务器<br>我们的slave服务器主要是主动去master服务器同步数据回来，我们编辑配置文件：<br>vi /usr/local/mysql/var/my.cnf<br>找到下面类似的信息：</p><h1 id="required-unique-id-between-1-and-2-32-1-1"><a href="#required-unique-id-between-1-and-2-32-1-1" class="headerlink" title="required unique id between 1 and 2^32 - 1"></a>required unique id between 1 and 2^32 - 1</h1><h1 id="defaults-to-1-if-master-host-is-not-set-1"><a href="#defaults-to-1-if-master-host-is-not-set-1" class="headerlink" title="defaults to 1 if master-host is not set"></a>defaults to 1 if master-host is not set</h1><h1 id="but-will-not-function-as-a-master-if-omitted-1"><a href="#but-will-not-function-as-a-master-if-omitted-1" class="headerlink" title="but will not function as a master if omitted"></a>but will not function as a master if omitted</h1><p>server-id        = 1<br>把上面的server-id修改为2，同时添加一些信息：<br>server-id                   = 2                        //本Mysql是slave服务器<br>master-host             = 192.168.0.1    //master服务器的IP<br>master-user             = root                  //连接master服务器的用户<br>master-password   = ‘’                        //连接master服务器的密码<br>master-port              = 3306                //连接端口<br>master-connect-retry    = 10              //重试次数<br>replicate-do-db        = abc                  //要同步的数据库<br>log-slave-updates                              //同步的形式<br>重启192.168.0.2的mysql服务器：<br>/usr/local/mysql/bin/mysqladmin shutdown<br>/usr/local/mysql/bin/mysqld_safe –user=mysql &amp;</p></li><li><p>测试安装</p></li></ol><p>首先查看一下slave的主机日志：<br>cat /usr/local/mysql/var/xxxxx_err （xxx是主机名）<br>检查是否连接正常, 看到类似这样的信息就成功了<br>051031 11:42:40  mysqld started<br>051031 11:42:41  InnoDB: Started; log sequence number 0 43634<br>/usr/local/mysql/libexec/mysqld: ready for connections.<br>Version: ‘4.1.15-log’  socket: ‘/tmp/mysql.sock’  port: 3306  Source distribution<br>051031 11:42:41 [Note] Slave SQL thread initialized, starting replication in log ‘FIRST’ at position 0, relay log ‘./new4-relay-bin.000001’ position: 4<br>051031 11:43:21 [Note] Slave I/O thread: connected to master ‘<a href="mailto:&#114;&#111;&#x6f;&#x74;&#x40;&#x31;&#x39;&#50;&#46;&#49;&#54;&#x38;&#46;&#x30;&#46;&#49;">&#114;&#111;&#x6f;&#x74;&#x40;&#x31;&#x39;&#50;&#46;&#49;&#54;&#x38;&#46;&#x30;&#46;&#49;</a>:3306’,  replication started in log ‘FIRST’ at position 4<br>在Master查看信息<br>/usr/local/mysql/bin/mysql -u root<br>查看master状态：<br>mysql&gt; show master status;<br>查看Master下mysql进程信息：<br>mysql&gt; show processlist;</p><p>在slave上查看信息：<br>/usr/local/mysql/bin/mysql -u root<br>查看slave状态：<br>mysql&gt; show slave status;<br>查看slave下mysql进程信息：<br>mysql&gt; show processlist;<br>你再在master的abc库里建立表结构并且插入数据，然后检查slave有没有同步这些数据，就能够检查出是否设置成功。</p><p>最后，如果有兴趣的话，可以研究一下双击热备份，或者一台master，多台slave的同步实现。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a> <a href="/tags/MySQL/" rel="tag"># MySQL</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/4a23c7da79c0.html" rel="prev" title="Spring cloud"><i class="fa fa-angle-left"></i> Spring cloud</a></div><div class="post-nav-item"><a href="/publishes/e002a9c6759b.html" rel="next" title="Java web">Java web <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>