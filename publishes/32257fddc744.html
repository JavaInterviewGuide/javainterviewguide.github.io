<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"defalut"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="数据库锁机制 ⾏锁：对某一⾏加锁 表锁：对整张表加锁 乐观锁：每次去拿数据的时候都认为别人不会修改，具体实现是给表增加⼀个版本号的字段，在执行更新操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝 悲观锁：每次去拿数据的时候都认为别人会修改，读数据的时候会上锁，直到更新完成才释放锁  数据库隔离级别是什么 读未提交：⼀个事务可以读取另一个事务未提交的数据，会产生脏读，不可重"><meta property="og:type" content="article"><meta property="og:title" content="数据库"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/32257fddc744.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="数据库锁机制 ⾏锁：对某一⾏加锁 表锁：对整张表加锁 乐观锁：每次去拿数据的时候都认为别人不会修改，具体实现是给表增加⼀个版本号的字段，在执行更新操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝 悲观锁：每次去拿数据的时候都认为别人会修改，读数据的时候会上锁，直到更新完成才释放锁  数据库隔离级别是什么 读未提交：⼀个事务可以读取另一个事务未提交的数据，会产生脏读，不可重"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:19:45.000Z"><meta property="article:modified_time" content="2024-04-05T11:18:11.074Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="数据库"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/32257fddc744.html","path":"publishes/32257fddc744.html","title":"数据库"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>数据库 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">数据库锁机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">数据库隔离级别是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%EF%A8%88%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">SQL语句执行顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD"><span class="nav-number">4.</span> <span class="nav-text">如何优化数据库性能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%A5%A7%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">5.</span> <span class="nav-text">SQL什么情况下不会使用索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%9C%A8%E4%BB%80%E4%B9%88%E5%AD%97%E6%AE%B5%E4%B8%8A%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">6.</span> <span class="nav-text">一般在什么字段上建索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E5%87%8F%E5%BA%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">如何解决高并发减库存问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B2%92%E5%BA%A6%EF%BC%9B"><span class="nav-number">8.</span> <span class="nav-text">数据库事务的几种粒度；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98"><span class="nav-number">9.</span> <span class="nav-text">数据库调优</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">事务的四种特性（ACID）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">为什么使用数据索引能提高效率？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">B+树索引和哈希索引的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">12.0.0.1.</span> <span class="nav-text">哈希索引的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">12.0.0.2.</span> <span class="nav-text">哈希索引不适用的场景</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">B 树和 B+ 树的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4B-%E6%AF%94B%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E7%9A%84%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%BB%A3%E4%BB%B7%E6%9B%B4%E4%BD%8E%E3%80%82"><span class="nav-number">14.0.0.1.</span> <span class="nav-text">B+的磁盘读写代价更低。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-tree%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9B%B4%E5%8A%A0%E7%A8%B3%E5%AE%9A%E3%80%82"><span class="nav-number">14.0.0.2.</span> <span class="nav-text">B+-tree的查询效率更加稳定。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E4%B8%8D%E5%BB%BA%E6%88%96%E5%B0%91%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">什么情况下应不建或少建索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A8%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">什么是表分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E4%B8%8E%E5%88%86%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">表分区与分表的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">表分区有什么好处？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A4%9A%E6%95%B0%E6%8D%AE"><span class="nav-number">18.0.0.1.</span> <span class="nav-text">存储更多数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">18.0.0.2.</span> <span class="nav-text">优化查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E6%9B%B4%E5%AE%B9%E6%98%93%E7%BB%B4%E6%8A%A4"><span class="nav-number">18.0.0.3.</span> <span class="nav-text">分区表更容易维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%9F%90%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E7%93%B6%E9%A2%88"><span class="nav-number">18.0.0.4.</span> <span class="nav-text">避免某些特殊的瓶颈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">19.</span> <span class="nav-text">行级锁定的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">19.0.0.1.</span> <span class="nav-text">行级锁定的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">19.0.0.2.</span> <span class="nav-text">行级锁定的缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#key%E5%92%8Cindex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">20.</span> <span class="nav-text">key和index的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">21.</span> <span class="nav-text">数据库表创建注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E5%90%8D%E5%8F%8A%E5%AD%97%E6%AE%B5%E9%85%8D%E5%88%B6%E5%90%88%E7%90%86%E6%80%A7"><span class="nav-number">21.0.0.1.</span> <span class="nav-text">字段名及字段配制合理性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%AE%8A%E5%AD%97%E6%AE%B5%E5%A4%84%E7%90%86%E5%8F%8A%E5%BB%BA%E6%88%90%E5%90%8E%E5%BB%BA%E8%AE%AE"><span class="nav-number">21.0.0.2.</span> <span class="nav-text">系统特殊字段处理及建成后建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E5%90%88%E7%90%86%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">21.0.0.3.</span> <span class="nav-text">表结构合理性配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%BB%BA%E8%AE%AE"><span class="nav-number">21.0.0.4.</span> <span class="nav-text">其它建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">22.</span> <span class="nav-text">数据库三范式是什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF"><span class="nav-number">22.0.0.1.</span> <span class="nav-text">第一范式（1NF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89"><span class="nav-number">22.0.0.2.</span> <span class="nav-text">第二范式（2NF）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A1%E8%B6%B3%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89"><span class="nav-number">22.0.0.3.</span> <span class="nav-text">满足第三范式（3NF）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="nav-number">23.</span> <span class="nav-text">有哪些数据库优化方面的经验?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%A7%8D%E7%B1%BB"><span class="nav-number">24.</span> <span class="nav-text">请简述常用的索引有哪些种类?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SELECT-%E5%92%8CSELECT-%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%E7%9A%842%E7%A7%8D%E5%86%99%E6%B3%95%E6%9C%89%E4%BD%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">25.</span> <span class="nav-text">SELECT * 和SELECT 全部字段的2种写法有何优缺点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HAVNG-%E5%AD%90%E5%8F%A5-%E5%92%8C-WHERE%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">26.</span> <span class="nav-text">HAVNG 子句 和 WHERE的异同点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E5%92%8C%E5%80%99%E9%80%89%E9%94%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">主键和候选键有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%9C%89%E4%B8%80%E5%88%97%E5%AE%9A%E4%B9%89%E4%B8%BA-TIMESTAMP%EF%BC%8C%E5%B0%86%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">如果一个表有一列定义为 TIMESTAMP，将发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E8%AE%BE%E7%BD%AE%E4%B8%BA-AUTO-INCREMENT-%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E8%A1%A8%E4%B8%AD%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99"><span class="nav-number">30.</span> <span class="nav-text">数据库架构原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88"><span class="nav-number">31.</span> <span class="nav-text">常见的数据库架构方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%A4%87%E6%9E%B6%E6%9E%84"><span class="nav-number">31.0.0.1.</span> <span class="nav-text">主备架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%B8%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">31.0.0.2.</span> <span class="nav-text">双主架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">31.0.0.3.</span> <span class="nav-text">主从架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%B8%BB-%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">31.0.0.4.</span> <span class="nav-text">双主+主从架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">32.</span> <span class="nav-text">一致性解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%BA%93%E5%92%8C%E4%BB%8E%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">32.0.0.1.</span> <span class="nav-text">主库和从库一致性解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DB%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">32.0.0.2.</span> <span class="nav-text">DB和缓存一致性解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">33.</span> <span class="nav-text">主从数据库不一致如何解决</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">34.</span> <span class="nav-text">说出数据连接池的工作机制是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">数据库创建索引的缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">说一下数据库的存储过程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E6%9C%AC%E8%A1%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%8C%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">什么是基本表，什么是视图，两者的区别和联系是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ORM"><span class="nav-number">38.</span> <span class="nav-text">什么是 ORM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">39.</span> <span class="nav-text">数据库连接池的原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%B5%E5%90%91%E5%88%87%E5%88%86-%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">什么是纵向切分&#x2F;垂直切分？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%AA%E5%90%91%E5%88%87%E5%88%86-%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86"><span class="nav-number">40.0.0.1.</span> <span class="nav-text">横向切分&#x2F;水平切分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MyCat%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">什么是 MyCat？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%A4%E7%A7%8D%E4%BB%A5%E4%B8%8A%E6%89%A9%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">42.</span> <span class="nav-text">请说出两种以上扩大数据库的方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%B9%B6%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E%E8%BF%99%E4%BA%9B%E5%B1%9E%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">43.</span> <span class="nav-text">事务是什么？有哪些属性，并简要说明这些属性的含义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Statement-PreparedStatement-CallableStatment-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">44.</span> <span class="nav-text">Statement,PreparedStatement,CallableStatment 的区别。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-PreparedStatement-%E8%80%8C%E4%B8%8D%E6%98%AF-Statement"><span class="nav-number">45.</span> <span class="nav-text">JDBC 为什么要使用 PreparedStatement 而不是 Statement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%86%E4%B8%BA%E4%BA%8B%E5%89%8D%E8%A7%A6%E5%8F%91%E5%92%8C%E4%BA%8B%E5%90%8E%E8%A7%A6%E5%8F%91%EF%BC%8C%E8%BF%99%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%9C%89%E5%92%8C%E5%8C%BA%E5%88%AB%E3%80%82%E8%AF%AD%E5%8F%A5%E7%BA%A7%E8%A7%A6%E5%8F%91%E5%92%8C%E8%A1%8C%E7%BA%A7%E8%A7%A6%E5%8F%91%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">46.</span> <span class="nav-text">触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%B8%B8%E6%A0%87%E5%B7%B2%E7%BB%8F%E5%88%B0%E4%BA%86%E6%9C%80%E5%90%8E%EF%BC%9A"><span class="nav-number">47.</span> <span class="nav-text">游标的作用？如何知道游标已经到了最后：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD%EF%BC%9A"><span class="nav-number">48.</span> <span class="nav-text">数据库中常用术语：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NULL-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">49.</span> <span class="nav-text">NULL 是什么意思</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E6%9C%AC%E8%A1%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">什么是基本表？什么是视图？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%95%E8%BF%B0%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">试述视图的优点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%9D%A5%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">什么是存储过程？用什么来调用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">完整性约束包括哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-MySQL-%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%87%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">54.</span> <span class="nav-text">解释 MySQL 外连接、内连接与自连接的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%EF%BC%9F"><span class="nav-number">55.</span> <span class="nav-text">SQL 注入漏洞产生的原因？如何防止？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">56.</span> <span class="nav-text">存储过程和函数的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A7%8D%E7%B1%BB%E5%92%8C%E5%85%B3%E7%B3%BB"><span class="nav-number">57.</span> <span class="nav-text">关系型数据库和非关系型数据库种类和关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">57.0.0.1.</span> <span class="nav-text">关系型数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">57.0.0.2.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E3%80%81%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF%E7%AD%89"><span class="nav-number">58.</span> <span class="nav-text">内连接、外连接、交叉连接、笛卡儿积等</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="数据库 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据库</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:19:45" itemprop="dateCreated datePublished" datetime="2023-12-20T15:19:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-04-05 19:18:11" itemprop="dateModified" datetime="2024-04-05T19:18:11+08:00">2024-04-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="数据库锁机制"><a href="#数据库锁机制" class="headerlink" title="数据库锁机制"></a>数据库锁机制</h1><ul><li>⾏锁：对某一⾏加锁</li><li>表锁：对整张表加锁</li><li>乐观锁：每次去拿数据的时候都认为别人不会修改，具体实现是给表增加⼀个版本号的字段，在执行更新操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，读数据的时候会上锁，直到更新完成才释放锁</li></ul><h1 id="数据库隔离级别是什么"><a href="#数据库隔离级别是什么" class="headerlink" title="数据库隔离级别是什么"></a>数据库隔离级别是什么</h1><ul><li>读未提交：⼀个事务可以读取另一个事务未提交的数据，会产生脏读，不可重复读、幻读。</li><li>读已提交：⼀个事务不可以读取另一个事务未提交的数据。可以避免脏读，但会出现不可重复读、幻读。</li><li>可重复读：可以防⽌脏读、不可重复读。但会出现幻读。</li><li>串行化：事务被处理为顺序执行，花费最⾼代价但是最可靠。可以避免脏读、不可重复读、幻读。</li></ul><h1 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h1><p>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</p><h1 id="如何优化数据库性能"><a href="#如何优化数据库性能" class="headerlink" title="如何优化数据库性能"></a>如何优化数据库性能</h1><ul><li>选择合适的数据库引擎</li><li>使用索引</li><li>查询时只获取需要的字段</li><li>查询时分页</li><li>优化业务逻辑，减少数据库IO</li><li>部署主从数据库</li><li>分库分表</li><li>升级硬件</li></ul><h1 id="SQL什么情况下不会使用索引"><a href="#SQL什么情况下不会使用索引" class="headerlink" title="SQL什么情况下不会使用索引"></a>SQL什么情况下不会使用索引</h1><ul><li>不包含、不等于、函数</li><li>select * 可能不走索引</li><li>空值</li><li>索引列有函数运算，不走索引，可以在索引列建⽴一个函数的索引</li><li>隐式转换可能不走索引</li><li>表的数据库小或者需要选择大部分数据，不走索引</li><li>字符型的索引列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式</li><li>like ‘%aaa’ 百分号在前不走索引</li><li>not exist不走索引</li></ul><h1 id="一般在什么字段上建索引"><a href="#一般在什么字段上建索引" class="headerlink" title="一般在什么字段上建索引"></a>一般在什么字段上建索引</h1><ul><li>过滤数据最多的字段</li><li>表的主键、外键必须有索引；</li><li>数据量量超过300的表应该有索引；</li><li>经常与其他表进行行连接的表，在连接字段上应该建立索引；</li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>如何从一张表中查出name字段不包含”XYZ”的所有行？</li></ul><h1 id="如何解决高并发减库存问题"><a href="#如何解决高并发减库存问题" class="headerlink" title="如何解决高并发减库存问题"></a>如何解决高并发减库存问题</h1><ul><li>消息队列，异步处理，减库存加锁</li></ul><h1 id="数据库事务的几种粒度；"><a href="#数据库事务的几种粒度；" class="headerlink" title="数据库事务的几种粒度；"></a>数据库事务的几种粒度；</h1><ul><li>表锁定：对整个表的锁定。</li><li>行锁定：只锁定进⾏行更改的行，例如：insert，update，delete，都隐式采用行锁定。</li><li>数据库锁机制可分为多种粒度的： 数据库，表，页面，行</li><li>粒度越大，DBMS管理越容易，但是实现并发处理的能力就越差，表，页面，行</li></ul><h1 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h1><ul><li>explain select语句；</li><li>当只要一条数据时使用limit 1；</li><li>为搜索字段建索引；</li><li>避免select *；</li><li>字段尽量使用not null；</li><li>垂直分割；</li><li>拆分大的delete和insert语句：delete和insert会锁表；</li><li>分表分库分区</li></ul><h1 id="事务的四种特性（ACID）？"><a href="#事务的四种特性（ACID）？" class="headerlink" title="事务的四种特性（ACID）？"></a>事务的四种特性（ACID）？</h1><ul><li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li><li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ul><h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul><li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li><li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li></ul><h4 id="哈希索引的优势"><a href="#哈希索引的优势" class="headerlink" title="哈希索引的优势"></a>哈希索引的优势</h4><ul><li>等值查询，哈希索引具有绝对优势</li><li>前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题</li></ul><h4 id="哈希索引不适用的场景"><a href="#哈希索引不适用的场景" class="headerlink" title="哈希索引不适用的场景"></a>哈希索引不适用的场景</h4><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li><li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<ul><li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主</li><li>没有范围查询、没有排序的时候，特别适合采用哈希索引</li><li>仅等值查询<ul><li>select id, name from table where name&#x3D;’李明’;</li></ul></li></ul></li><li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li><li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li><li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li><li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li><li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read&#x2F;write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li></ul><h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li></ul><h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><h4 id="B-的磁盘读写代价更低。"><a href="#B-的磁盘读写代价更低。" class="headerlink" title="B+的磁盘读写代价更低。"></a>B+的磁盘读写代价更低。</h4><ul><li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li><li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多</li><li>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li></ul><h4 id="B-tree的查询效率更加稳定。"><a href="#B-tree的查询效率更加稳定。" class="headerlink" title="B+-tree的查询效率更加稳定。"></a>B+-tree的查询效率更加稳定。</h4><ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引</li><li>所以任何关键字的查找必须走一条从根结点到叶子结点的路</li><li>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul><li>表记录太少</li><li>经常插入、删除、修改的表</li><li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul><li>表分区是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分</li><li>从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li></ul><h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul><li>分表：指的是通过一定规则，将一张表分解成多张不同的表</li><li>比如将用户订单记录根据时间成多个表。</li><li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li></ul><h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><h4 id="存储更多数据"><a href="#存储更多数据" class="headerlink" title="存储更多数据"></a>存储更多数据</h4><ul><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li><li>和单个磁盘或者文件系统相比，可以存储更多数据</li></ul><h4 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h4><ul><li>在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率</li><li>涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li></ul><h4 id="分区表更容易维护"><a href="#分区表更容易维护" class="headerlink" title="分区表更容易维护"></a>分区表更容易维护</h4><ul><li>例如：想批量删除大量数据可以清除整个分区。</li></ul><h4 id="避免某些特殊的瓶颈"><a href="#避免某些特殊的瓶颈" class="headerlink" title="避免某些特殊的瓶颈"></a>避免某些特殊的瓶颈</h4><ul><li>例如InnoDB的单个索引的互斥访问，ext3文件系统的inode锁竞争等。</li></ul><h1 id="行级锁定的优缺点"><a href="#行级锁定的优缺点" class="headerlink" title="行级锁定的优缺点"></a>行级锁定的优缺点</h1><h4 id="行级锁定的优点"><a href="#行级锁定的优点" class="headerlink" title="行级锁定的优点"></a>行级锁定的优点</h4><ul><li>当在许多线程中访问不同的行时只存在少量锁定冲突</li><li>回滚时只有少量的更改</li><li>可以长时间锁定单一的行</li></ul><h4 id="行级锁定的缺点"><a href="#行级锁定的缺点" class="headerlink" title="行级锁定的缺点"></a>行级锁定的缺点</h4><ul><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul><li>key 是数据库的物理结构，它包含两层意义和作用<ul><li>一是约束（偏重于约束和规范数据库的结构完整性）</li><li>二是索引（辅助查询用的），包括primary key, unique key, foreign key 等</li></ul></li><li>index是数据库的物理结构<ul><li>它只是辅助查询的</li><li>它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储</li><li>索引要分类的话，分为前缀索引、全文本索引等；</li></ul></li></ul><h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><h4 id="字段名及字段配制合理性"><a href="#字段名及字段配制合理性" class="headerlink" title="字段名及字段配制合理性"></a>字段名及字段配制合理性</h4><ul><li>剔除关系不密切的字段；</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul><h4 id="系统特殊字段处理及建成后建议"><a href="#系统特殊字段处理及建成后建议" class="headerlink" title="系统特殊字段处理及建成后建议"></a>系统特殊字段处理及建成后建议</h4><ul><li>添加删除标记（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul><h4 id="表结构合理性配置"><a href="#表结构合理性配置" class="headerlink" title="表结构合理性配置"></a>表结构合理性配置</h4><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><h4 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h4><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul><h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><h4 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF"></a>第一范式（1NF</h4><ul><li>字段具有原子性,不可再分</li><li>所有关系型数据库系统都满足第一范式</li><li>数据库表中的字段都是单一属性的，不可再分</li></ul><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><ul><li>是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）</li><li>要求数据库表中的每个实例或行必须可以被惟一地区分</li><li>通常需要为表加上一个列，以存储各个实例的惟一标识</li><li>这个惟一属性列被称为主关键字或主键。</li></ul><h4 id="满足第三范式（3NF）"><a href="#满足第三范式（3NF）" class="headerlink" title="满足第三范式（3NF）"></a>满足第三范式（3NF）</h4><ul><li>必须先满足第二范式（2NF）</li><li>简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</li><li>所以第三范式具有如下特征<ul><li>每一列只有一个值</li><li>每一行都能区分</li><li>每一个表都不包含其他表已经包含的非主关键字信息。</li></ul></li></ul><h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><ul><li>用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</li><li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</li><li>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等</li><li>UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL</li><li>UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同<ul><li>对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录</li><li>对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</li></ul></li></ul><h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><ul><li>普通索引: 即针对数据库表创建索引</li><li>唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值</li><li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li><li>组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li></ul><h1 id="SELECT-和SELECT-全部字段的2种写法有何优缺点"><a href="#SELECT-和SELECT-全部字段的2种写法有何优缺点" class="headerlink" title="SELECT * 和SELECT 全部字段的2种写法有何优缺点?"></a>SELECT * 和SELECT 全部字段的2种写法有何优缺点?</h1><ul><li>前者要解析数据字典，后者不需要</li><li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li><li>表字段改名，前者不需要修改，后者需要改</li><li>后者可以建立索引进行优化，前者无法优化</li><li>后者的可读性比前者要高</li></ul><h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><ul><li>语法上：where 用表中列名，having用select结果别名</li><li>影响结果范围：where从表读出数据的行数，having返回客户端的行数</li><li>索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作</li><li>where后面不能使用聚集函数，having是专门使用聚集函数的。</li></ul><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul><li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li><li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li></ul><h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><ul><li>每当行被更改时，时间戳字段将获取当前时间戳。</li></ul><h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><ul><li>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</li></ul><h1 id="数据库架构原则"><a href="#数据库架构原则" class="headerlink" title="数据库架构原则"></a>数据库架构原则</h1><ul><li>高可用</li><li>高性能</li><li>一致性</li><li>扩展性</li></ul><h1 id="常见的数据库架构方案"><a href="#常见的数据库架构方案" class="headerlink" title="常见的数据库架构方案"></a>常见的数据库架构方案</h1><h4 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h4><ul><li>只有主库提供读写服务，备库冗余作故障转移用</li><li>高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写都操作主库，很容易产生瓶颈</li><li>大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能</li><li>另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 </li><li>一致性分析：读写都操作主库，不存在数据一致性问题。 </li><li>扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案</li><li>第二，扩展性差，这点可以通过分库分表来扩展。</li></ul></li></ul><h4 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h4><ul><li>两个主库同时提供服务，负载均衡</li><li>高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写性能相比于方案一都得到提升，提升一倍。</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）</li><li>如果非得在数据库架构层面扩展的话，扩展为方案四。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。</li></ul></li></ul><h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><ul><li>一主多从，读写分离</li><li>高可用分析：主库单点，从库高可用</li><li>一旦主库挂了，写服务也就无法提供。 </li><li>高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能</li><li>读的性能提高了，整体性能也提高了。</li><li>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引</li><li>线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。</li><li>带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长）</li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主库单点问题，笔者暂时没想到很好的解决方案。</li></ul></li><li>思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？</li></ul><h4 id="双主-主从架构"><a href="#双主-主从架构" class="headerlink" title="双主+主从架构"></a>双主+主从架构</h4><ul><li>看似完美的方案</li><li>高可用分析：高可用。 </li><li>高性能分析：高性能。 </li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案 。</li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） </li><li>可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。</li></ul><h1 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h1><h4 id="主库和从库一致性解决方案"><a href="#主库和从库一致性解决方案" class="headerlink" title="主库和从库一致性解决方案"></a>主库和从库一致性解决方案</h4><ul><li>数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的</li><li>这个同步时间内主库和从库的数据会存在不一致的情况</li><li>如果同步过程中有读请求，那么读到的就是从库中的老数据。</li><li>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<ul><li>直接忽略，如果业务允许延时存在，那么就不去管它。 </li><li>强制读主，采用主备架构方案，读写都走主库</li><li>用缓存来扩展数据库读性能</li><li>有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</li></ul></li><li>选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。</li><li>读请求时，同样的方式生成key先去查Cache，再判断是否命中</li><li>若命中，则读主库，否则读从库</li><li>代价是多了一次缓存读写，基本可以忽略。</li><li>半同步复制，等主从同步完成，写请求才返回</li><li>就是大家常说的“半同步复制”semi-sync</li><li>这可以利用数据库原生功能，实现比较简单</li><li>代价是写请求时延增长，吞吐量降低。 </li><li>数据库中间件，引入开源（mycat等）或自研的数据库中间层</li><li>个人理解，思路同选择读主</li><li>数据库中间件的成本比较高，并且还多引入了一层</li></ul><h4 id="DB和缓存一致性解决方案"><a href="#DB和缓存一致性解决方案" class="headerlink" title="DB和缓存一致性解决方案"></a>DB和缓存一致性解决方案</h4><ul><li>先来看一下常用的缓存使用方式：<ul><li>第一步：淘汰缓存；</li><li>第二步：写入数据库；</li><li>第三步：读取缓存？返回：读取数据库；</li><li>第四步：读取数据库后写入缓存。</li></ul></li><li>注：如果按照这种方式，不会产生DB和缓存不一致问题，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据</li><li>设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！</li><li>加缓存和索引是通用的提升数据库性能的方式； </li><li>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。</li><li>阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。</li></ul><p> </p><h1 id="主从数据库不一致如何解决"><a href="#主从数据库不一致如何解决" class="headerlink" title="主从数据库不一致如何解决"></a>主从数据库不一致如何解决</h1><ul><li>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</li><li>忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</li><li>强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</li><li>选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</li></ul><h1 id="说出数据连接池的工作机制是什么"><a href="#说出数据连接池的工作机制是什么" class="headerlink" title="说出数据连接池的工作机制是什么?"></a>说出数据连接池的工作机制是什么?</h1><ul><li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接</li><li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙</li><li>如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定</li><li>当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</li></ul><h1 id="数据库创建索引的缺点？"><a href="#数据库创建索引的缺点？" class="headerlink" title="数据库创建索引的缺点？"></a>数据库创建索引的缺点？</h1><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h1 id="说一下数据库的存储过程？"><a href="#说一下数据库的存储过程？" class="headerlink" title="说一下数据库的存储过程？"></a>说一下数据库的存储过程？</h1><ul><li>存储过程与函数的区别：<ul><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。</li><li>对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。</li><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。</li></ul></li><li>存储过程的优点：<ul><li>执行速度更快 – 在数据库中保存的存储过程语句都是编译过的</li><li>允许模块化程序设计 – 类似方法的复用</li><li>提高系统安全性 – 防止SQL注入</li><li>减少网络流通量 – 只要传输存储过程的名称</li></ul></li><li>系统存储过程一般以sp开头，用户自定义的存储过程一般以usp开头</li></ul><h1 id="什么是基本表，什么是视图，两者的区别和联系是什么？"><a href="#什么是基本表，什么是视图，两者的区别和联系是什么？" class="headerlink" title="什么是基本表，什么是视图，两者的区别和联系是什么？"></a>什么是基本表，什么是视图，两者的区别和联系是什么？</h1><ul><li>它是从一个或几个基本表中导出的 表，是从现有基本表中抽取若干子集组成用户的“专用表”。</li><li>基本表：基本表的定义指建立基本关系模式,</li><li>而变更则是指对数据库中已存在的基本表进行删除与修改。</li><li>区别：<ul><li>视图是已经编译好的 sql 语句。而表不是</li><li>视图没有实际的物理记录。而表有。</li><li>表是内容，视图是窗口</li><li>表只用物理空间而视图不占用物理空间，</li></ul></li><li>视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改</li><li>表是内模式，试图是外模式</li><li>视图是查看数据表的一种方法，</li><li>可以查询数据表中某些字段构成的数据，</li><li>只是一些 SQL 语句的集合。从安全的角度说，</li><li>视图可以不给用户接触数据表，从而不知道表结构。</li><li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li><li>联系<ul><li>视图（view）是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。</li><li>视图是基本表的抽象和在逻辑意义上建立的新关系</li></ul></li></ul><h1 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM"></a>什么是 ORM</h1><ul><li>对象关系映射(Object Relation Mapping，简称 ORM)模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术</li><li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中</li><li>那么到底如何实现持久化呢？一种简单的方案时采用硬编码方式(jdbc 操作 sql 方式)，为每一种可能的数据库访问操作提供单独的方法。</li><li>这种方案存在以下不足：<ul><li>持久化层缺乏弹性，一旦出现业务需求变更，就必须修改持久化层的接口</li><li>持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层的相关程序代码，增加软件的维护难度。</li></ul></li><li>ORM 提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得 ORM 中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁，Java 典型的 ORM 框架有：Hibernate，ibatis(mybtis)，speedframework。</li><li>ORM 框架的方法论基于三个核心原则：<ul><li>简单：以最基本的形式建模数据</li><li>传达性：数据库结构被任何人都能理解的语言文档化</li><li>精确性：基于数据模型创建正确标准化了结构</li></ul></li></ul><h1 id="数据库连接池的原理"><a href="#数据库连接池的原理" class="headerlink" title="数据库连接池的原理"></a>数据库连接池的原理</h1><ul><li>传统连接方式:<ul><li>首先调用 Class.forName()方法加载数据库驱动，</li><li>然后调用 DriverManager.getConnection()方法建立连接.</li></ul></li><li>连接池技术:<ul><li>连接池解决方案是在应用程序启动时就预先建立多个数据库连接对象,然后将连接对象保存到连接池中。</li><li>当客户请求到来时,从池中取出一个连接对象为客户服务。</li><li>当请求完成时,客户程序调用 close()方法,将连接对象放回池中.</li><li>对于多于连接池中连接数的请求，排队等待。</li><li>应用程序还可根据连接池中连接的使用率，动态增加或减少池中的连接数。</li></ul></li></ul><h1 id="什么是纵向切分-垂直切分？"><a href="#什么是纵向切分-垂直切分？" class="headerlink" title="什么是纵向切分&#x2F;垂直切分？"></a>什么是纵向切分&#x2F;垂直切分？</h1><ul><li>就是把原本存储于一个库的数据存储到多个库上。</li><li>由于对数据库的读写都是对同一个库进行操作，所以单库并不能解决大规模并发写入的问题。</li><li>例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</li><li>优点<ul><li>减少增量数据写入时的锁对查询的影响。</li><li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘 IO，时延变短。</li></ul></li><li>缺点：无法解决单表数据量太大的问题。</li></ul><h4 id="横向切分-水平切分"><a href="#横向切分-水平切分" class="headerlink" title="横向切分&#x2F;水平切分"></a>横向切分&#x2F;水平切分</h4><ul><li>把原本存储于一个表的数据分块存储到多个表上。当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，进行划分，然后存储到多个结构相同的表，和不同的库上。</li><li>例如，我们 userDB 中的 userTable 中数据量很大，那么可以把 userDB 切分为结构相同的多个 userDB：part0DB、part1DB 等，再将 userDB 上的 userTable，切分为很多userTable：userTable0、userTable1 等，然后将这些表按照一定的规则存储到多个 userDB上。</li><li>优点：<ul><li>单表的并发能力提高了，磁盘 I&#x2F;O 性能也提高了。</li><li>如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。</li></ul></li><li>缺点：无法实现表连接查询</li></ul><h1 id="什么是-MyCat？"><a href="#什么是-MyCat？" class="headerlink" title="什么是 MyCat？"></a>什么是 MyCat？</h1><ul><li>MyCat 是目前最流行的基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分离。</li><li>MyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。</li><li>MyCat 发展到目前的版本，已经不是一个单纯的 MySQL 代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL 等主流数据库，也支持 MongoDB 这种新型 NoSQL 方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那种存储方式，在 MyCat 里，都是一个传统的数据库表，支持标准的 SQL 语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度。</li></ul><h1 id="请说出两种以上扩大数据库的方式"><a href="#请说出两种以上扩大数据库的方式" class="headerlink" title="请说出两种以上扩大数据库的方式"></a>请说出两种以上扩大数据库的方式</h1><ul><li>修改现有表空间的大小；</li><li>向表空间插入一个新的数据文件</li></ul><h1 id="事务是什么？有哪些属性，并简要说明这些属性的含义"><a href="#事务是什么？有哪些属性，并简要说明这些属性的含义" class="headerlink" title="事务是什么？有哪些属性，并简要说明这些属性的含义"></a>事务是什么？有哪些属性，并简要说明这些属性的含义</h1><ul><li>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如 SQL，C++或 Java）书写的用户程序的执行所引起，并用形如 begin transaction 和 end transaction 语句（或函数调用）来界定。</li><li>事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。</li><li>事务应该具有 4 个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为 ACID特性。原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li></ul><h1 id="Statement-PreparedStatement-CallableStatment-的区别。"><a href="#Statement-PreparedStatement-CallableStatment-的区别。" class="headerlink" title="Statement,PreparedStatement,CallableStatment 的区别。"></a>Statement,PreparedStatement,CallableStatment 的区别。</h1><ul><li>区别有以下几点：</li><li>Statement 是 PreparedStatement 和 CallableStatement 的父类；</li><li>Statement 是直接发送 Sql 语句到数据库，事先没有进行预编译。 PreparedStatement会将 sql 进行预编译，当 sql 语句要重复执行时，数据库会调用以前预编译好的 sql 语句，所以 PreparedStatement 在性能方面会更好；</li><li>PreparedStatement 在执行 sql 时，对传入的参数可以进行强制的类型转换。以保证数据格式与底层的数据库格式一致。</li><li>CallableStatement 适用与存储过程的查询表达语句</li></ul><h1 id="JDBC-为什么要使用-PreparedStatement-而不是-Statement"><a href="#JDBC-为什么要使用-PreparedStatement-而不是-Statement" class="headerlink" title="JDBC 为什么要使用 PreparedStatement 而不是 Statement"></a>JDBC 为什么要使用 PreparedStatement 而不是 Statement</h1><ul><li>PreparedStatement 是 用 来 执 行 SQL 查 询 语 句 的 API 之 一 ， Java 提 供 了 Statement 、PreparedStatement 和 CallableStatement 三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement 则是用于存储过程。</li></ul><h1 id="触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别："><a href="#触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：" class="headerlink" title="触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别："></a>触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：</h1><ul><li>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。</li><li>语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。</li></ul><h1 id="游标的作用？如何知道游标已经到了最后："><a href="#游标的作用？如何知道游标已经到了最后：" class="headerlink" title="游标的作用？如何知道游标已经到了最后："></a>游标的作用？如何知道游标已经到了最后：</h1><ul><li>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。</li></ul><h1 id="数据库中常用术语："><a href="#数据库中常用术语：" class="headerlink" title="数据库中常用术语："></a>数据库中常用术语：</h1><ul><li>ddl:数据定义语言 Create Drop Alter</li><li>dml:数据操纵语言 insert update delete select</li><li>dcl:数据控制语言 grant revoke</li><li>tcl:事务控制语言 commit rollback</li></ul><h1 id="NULL-是什么意思"><a href="#NULL-是什么意思" class="headerlink" title="NULL 是什么意思"></a>NULL 是什么意思</h1><ul><li>NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这个值的任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比较，并在逻辑上希望获得一个答案。</li><li>使用 IS NULL 来进行 NULL 判断‘</li></ul><h1 id="什么是基本表？什么是视图？"><a href="#什么是基本表？什么是视图？" class="headerlink" title="什么是基本表？什么是视图？"></a>什么是基本表？什么是视图？</h1><ul><li>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表</li></ul><h1 id="试述视图的优点？"><a href="#试述视图的优点？" class="headerlink" title="试述视图的优点？"></a>试述视图的优点？</h1><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据；</li><li>视图为数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护。</li></ul><h1 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h1><ul><li>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。</li></ul><h1 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a>完整性约束包括哪些？</h1><ul><li>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</li><li>分为以下四类：<ul><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ul></li><li>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、<br>foreign key、check、UNIQUE) 。</li></ul><h1 id="解释-MySQL-外连接、内连接与自连接的区别"><a href="#解释-MySQL-外连接、内连接与自连接的区别" class="headerlink" title="解释 MySQL 外连接、内连接与自连接的区别"></a>解释 MySQL 外连接、内连接与自连接的区别</h1><ul><li>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</li><li>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。</li><li>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</li><li>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。</li></ul><h1 id="SQL-注入漏洞产生的原因？如何防止？"><a href="#SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL 注入漏洞产生的原因？如何防止？"></a>SQL 注入漏洞产生的原因？如何防止？</h1><ul><li>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。</li><li>防止 SQL 注入的方式：<ul><li>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置</li><li>执行 sql 语句时使用 addslashes 进行 sql 语句转换Sql 语句书写尽量不要省略双引号和单引号。</li><li>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。</li><li>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</li></ul></li></ul><h1 id="存储过程和函数的区别"><a href="#存储过程和函数的区别" class="headerlink" title="存储过程和函数的区别"></a>存储过程和函数的区别</h1><ul><li>存储过程是用户定义的一系列 sql 语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。</li></ul><h1 id="关系型数据库和非关系型数据库种类和关系"><a href="#关系型数据库和非关系型数据库种类和关系" class="headerlink" title="关系型数据库和非关系型数据库种类和关系"></a>关系型数据库和非关系型数据库种类和关系</h1><ul><li>数据库</li><li>类型	特性	优点	缺点</li></ul><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><ul><li>SQLite、Oracle、mysql	1、关系型数据库，是指采用了关系模型来组织数据的数据库；</li><li>关系型数据库的最大特点就是事务的一致性；</li><li>简单来说，关系模型指的就是二维表格模型，</li><li>而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。<ul><li>容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</li><li>使用方便：通用的SQL语言使得操作关系型数据库非常方便；</li><li>易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；</li><li>支持SQL，可用于复杂的查询。</li></ul></li><li>为了维护一致性所付出的巨大代价就是其读写性能比较差；</li><li>固定的表结构；</li><li>高并发读写需求；</li><li>海量数据的高效率读写；</li></ul><h4><a href="#" class="headerlink"></a></h4><ul><li>非关系型数据库</li><li>MongoDb、redis、HBase</li><li>使用键值对存储数据；</li><li>分布式；</li><li>一般不支持ACID特性；</li><li>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。<ul><li>无需经过sql层的解析，读写性能很高；</li><li>基于键值对，数据没有耦合性，容易扩展；</li><li>存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。</li></ul><p></p></li><li>不提供sql支持，学习和使用成本较高；</li><li>无事务处理，附加功能bi和报表等支持也不好；</li></ul><h1 id="内连接、外连接、交叉连接、笛卡儿积等"><a href="#内连接、外连接、交叉连接、笛卡儿积等" class="headerlink" title="内连接、外连接、交叉连接、笛卡儿积等"></a>内连接、外连接、交叉连接、笛卡儿积等</h1><ul><li>内连接(INNER JOIN)：  <ul><li>分为三种：等值连接、自然连接、不等连接</li></ul></li><li>外连接(OUTER JOIN)：  </li><li>分为三种：  <ul><li>左外连接(LEFT OUTER JOIN或LEFT JOIN)  </li><li>右外连接(RIGHT OUTER JOIN或RIGHT JOIN)  </li><li>全外连接(FULL OUTER JOIN或FULL JOIN)  交叉连接(CROSS JOIN)：没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积</li></ul></li><li>笛卡尔积是两个表每一个字段相互匹配，去掉where 或者inner join的等值 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。内连接: 只连接匹配的行。</li><li>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。</li><li>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。</li><li>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</li><li>交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/4a23c7da79c0.html" rel="prev" title="Spring cloud"><i class="fa fa-angle-left"></i> Spring cloud</a></div><div class="post-nav-item"><a href="/publishes/e002a9c6759b.html" rel="next" title="Java web">Java web <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">449k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:48</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>