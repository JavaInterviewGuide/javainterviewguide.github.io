<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？ 区别： InnoDB支持事务，MyISAM不支持 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； InnoDB是聚集索引，数据文件是和"><meta property="og:type" content="article"><meta property="og:title" content="数据库"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/32257fddc744.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？ 区别： InnoDB支持事务，MyISAM不支持 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； InnoDB是聚集索引，数据文件是和"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:19:45.000Z"><meta property="article:modified_time" content="2024-01-04T09:02:26.664Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="数据库"><meta property="article:tag" content="MySQL"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/32257fddc744.html","path":"publishes/32257fddc744.html","title":"数据库"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>数据库 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD-MyISAM-%E5%92%8C-InnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9EID%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">InnoDB为什么推荐使用自增ID作为主键？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innodb%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">innodb引擎的4大特性</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BE%8F%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">⾏锁，表锁，乐观锁，悲观锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%EF%A7%BD%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">数据库隔离级别是什什么？有什么作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%BB%E5%A4%87%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%A7%A4%E3%80%82"><span class="nav-number">4.</span> <span class="nav-text">MySQL主备同步的基本原理理。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#select-from-table-t-where-size-10-group-by-size-order-by-size%E7%9A%84sql%E8%AF%AD%E5%8F%A5%EF%A4%86%E6%89%A7%E2%BE%8F%E8%A1%8C%EF%A8%88%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD"><span class="nav-number">6.</span> <span class="nav-text">如何优化数据库性能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%A5%A7%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">7.</span> <span class="nav-text">SQL什么情况下不会使用索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%9C%A8%E4%BB%80%EF%A7%BD%E4%B9%88%E5%AD%97%E6%AE%B5%E4%B8%8A%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">8.</span> <span class="nav-text">一般在什什么字段上建索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E5%87%8F%E5%BA%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">如何解决高并发减库存问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B2%92%E5%BA%A6%EF%BC%9B"><span class="nav-number">10.</span> <span class="nav-text">数据库事务的几种粒度；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E8%B0%83%E4%BC%98"><span class="nav-number">11.</span> <span class="nav-text">mysql调优</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">说说事务的四种特性（ACID）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#innodb%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">innodb如何实现mysql的事务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">让你设计一个索引，你会怎么设计？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">为什么用自增列作为主键？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%E8%83%BD%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">为什么使用数据索引能提高效率？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">B+树索引和哈希索引的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">17.0.0.1.</span> <span class="nav-text">哈希索引的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">17.0.0.2.</span> <span class="nav-text">哈希索引不适用的场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">B 树和 B+ 树的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4B-%E6%AF%94B%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E7%9A%84%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E4%BB%A3%E4%BB%B7%E6%9B%B4%E4%BD%8E%E3%80%82"><span class="nav-number">19.0.0.1.</span> <span class="nav-text">B+的磁盘读写代价更低。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-tree%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E6%9B%B4%E5%8A%A0%E7%A8%B3%E5%AE%9A%E3%80%82"><span class="nav-number">19.0.0.2.</span> <span class="nav-text">B+-tree的查询效率更加稳定。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">20.</span> <span class="nav-text">关于 MySQL 联合索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BA%94%E4%B8%8D%E5%BB%BA%E6%88%96%E5%B0%91%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">什么情况下应不建或少建索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A8%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">什么是表分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E4%B8%8E%E5%88%86%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">表分区与分表的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%88%86%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">表分区有什么好处？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A4%9A%E6%95%B0%E6%8D%AE"><span class="nav-number">24.0.0.1.</span> <span class="nav-text">存储更多数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">24.0.0.2.</span> <span class="nav-text">优化查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E6%9B%B4%E5%AE%B9%E6%98%93%E7%BB%B4%E6%8A%A4"><span class="nav-number">24.0.0.3.</span> <span class="nav-text">分区表更容易维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%9F%90%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E7%93%B6%E9%A2%88"><span class="nav-number">24.0.0.4.</span> <span class="nav-text">避免某些特殊的瓶颈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E9%99%90%E5%88%B6%E5%9B%A0%E7%B4%A0"><span class="nav-number">25.</span> <span class="nav-text">分区表的限制因素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8DMySQL%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">如何判断当前MySQL是否支持分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%86%E5%8C%BA%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">MySQL支持的分区类型有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EMVVC"><span class="nav-number">28.</span> <span class="nav-text">关于MVVC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">29.</span> <span class="nav-text">行级锁定的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">29.0.0.1.</span> <span class="nav-text">行级锁定的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E5%AE%9A%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">29.0.0.2.</span> <span class="nav-text">行级锁定的缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#key%E5%92%8Cindex%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">30.</span> <span class="nav-text">key和index的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">31.</span> <span class="nav-text">数据库表创建注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E5%90%8D%E5%8F%8A%E5%AD%97%E6%AE%B5%E9%85%8D%E5%88%B6%E5%90%88%E7%90%86%E6%80%A7"><span class="nav-number">31.0.0.1.</span> <span class="nav-text">字段名及字段配制合理性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%AE%8A%E5%AD%97%E6%AE%B5%E5%A4%84%E7%90%86%E5%8F%8A%E5%BB%BA%E6%88%90%E5%90%8E%E5%BB%BA%E8%AE%AE"><span class="nav-number">31.0.0.2.</span> <span class="nav-text">系统特殊字段处理及建成后建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E5%90%88%E7%90%86%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">31.0.0.3.</span> <span class="nav-text">表结构合理性配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%BB%BA%E8%AE%AE"><span class="nav-number">31.0.0.4.</span> <span class="nav-text">其它建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">32.</span> <span class="nav-text">数据库三范式是什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF"><span class="nav-number">32.0.0.1.</span> <span class="nav-text">第一范式（1NF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89"><span class="nav-number">32.0.0.2.</span> <span class="nav-text">第二范式（2NF）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A1%E8%B6%B3%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89"><span class="nav-number">32.0.0.3.</span> <span class="nav-text">满足第三范式（3NF）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="nav-number">33.</span> <span class="nav-text">有哪些数据库优化方面的经验?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%A7%8D%E7%B1%BB"><span class="nav-number">34.</span> <span class="nav-text">请简述常用的索引有哪些种类?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">在mysql数据库中索引的工作机制是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-number">36.</span> <span class="nav-text">MySQL的基础操作命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E7%9A%84%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B"><span class="nav-number">37.</span> <span class="nav-text">mysql的复制原理以及流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E6%94%AF%E6%8C%81%E7%9A%84%E5%A4%8D%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">38.</span> <span class="nav-text">mysql支持的复制类型?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">38.0.0.1.</span> <span class="nav-text">基于语句的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">38.0.0.2.</span> <span class="nav-text">基于行的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">38.0.0.3.</span> <span class="nav-text">混合类型的复制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E4%B8%ADvarchar%E4%B8%8Echar%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8Avarchar-50-%E4%B8%AD%E7%9A%8450%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%B6%B5%E4%B9%89%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E4%B8%AD%E6%9C%89%E5%A4%A7%E5%AD%97%E6%AE%B5X%EF%BC%88%E4%BE%8B%E5%A6%82%EF%BC%9Atext%E7%B1%BB%E5%9E%8B%EF%BC%89%EF%BC%8C%E4%B8%94%E5%AD%97%E6%AE%B5X%E4%B8%8D%E4%BC%9A%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BB%A5%E8%AF%BB%E4%B8%BA%E4%B8%BA%E4%B8%BB%EF%BC%8C%E5%B0%86%E8%AF%A5%E5%AD%97%E6%AE%B5%E6%8B%86%E6%88%90%E5%AD%90%E8%A1%A8%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E4%B8%ADInnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E9%80%9A%E8%BF%87%E5%8A%A0%E5%9C%A8%E4%BB%80%E4%B9%88%E4%B8%8A%E5%AE%8C%E6%88%90%EF%BC%88%E6%88%96%E7%A7%B0%E5%AE%9E%E7%8E%B0%EF%BC%89%E7%9A%84%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8B%A5%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5VARCHAR-N-%E7%B1%BB%E5%9E%8B%EF%BC%8Cutf8%E7%BC%96%E7%A0%81%EF%BC%8C%E5%88%99N%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91-%E7%B2%BE%E7%A1%AE%E5%88%B0%E6%95%B0%E9%87%8F%E7%BA%A7%E5%8D%B3%E5%8F%AF"><span class="nav-number">42.</span> <span class="nav-text">若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SELECT-%E5%92%8CSELECT-%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%E7%9A%842%E7%A7%8D%E5%86%99%E6%B3%95%E6%9C%89%E4%BD%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">43.</span> <span class="nav-text">SELECT * 和SELECT 全部字段的2种写法有何优缺点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HAVNG-%E5%AD%90%E5%8F%A5-%E5%92%8C-WHERE%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">44.</span> <span class="nav-text">HAVNG 子句 和 WHERE的异同点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E5%BD%93%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6insert-%E5%BD%93%E8%AE%B0%E5%BD%95%E5%AD%98%E5%9C%A8%E6%97%B6update%EF%BC%8C%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="nav-number">45.</span> <span class="nav-text">MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%9A%84insert%E5%92%8Cupdate%E7%9A%84select%E8%AF%AD%E5%8F%A5%E8%AF%AD%E6%B3%95"><span class="nav-number">46.</span> <span class="nav-text">MySQL的insert和update的select语句语法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="nav-number">47.</span> <span class="nav-text">Mysql 中有哪几种锁？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">Mysql 中有哪些不同的表格？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E5%92%8C%E5%80%99%E9%80%89%E9%94%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">主键和候选键有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#myisamchk-%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">myisamchk 是用来做什么的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MyISAM-Static-%E5%92%8C-MyISAM-Dynamic-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">MyISAM Static 和 MyISAM Dynamic 有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%9C%89%E4%B8%80%E5%88%97%E5%AE%9A%E4%B9%89%E4%B8%BA-TIMESTAMP%EF%BC%8C%E5%B0%86%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">如果一个表有一列定义为 TIMESTAMP，将发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E8%AE%BE%E7%BD%AE%E4%B8%BA-AUTO-INCREMENT-%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E8%A1%A8%E4%B8%AD%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99"><span class="nav-number">54.</span> <span class="nav-text">数据库架构原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88"><span class="nav-number">55.</span> <span class="nav-text">常见的数据库架构方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%A4%87%E6%9E%B6%E6%9E%84"><span class="nav-number">55.0.0.1.</span> <span class="nav-text">主备架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%B8%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">55.0.0.2.</span> <span class="nav-text">双主架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">55.0.0.3.</span> <span class="nav-text">主从架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%B8%BB-%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">55.0.0.4.</span> <span class="nav-text">双主+主从架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">56.</span> <span class="nav-text">一致性解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%BA%93%E5%92%8C%E4%BB%8E%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">56.0.0.1.</span> <span class="nav-text">主库和从库一致性解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DB%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">56.0.0.2.</span> <span class="nav-text">DB和缓存一致性解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">57.</span> <span class="nav-text">主从数据库不一致如何解决</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">58.</span> <span class="nav-text">说出数据连接池的工作机制是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">59.</span> <span class="nav-text">数据库创建索引的缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">60.</span> <span class="nav-text">说一下数据库的存储过程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E6%9C%AC%E8%A1%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%8C%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">61.</span> <span class="nav-text">什么是基本表，什么是视图，两者的区别和联系是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ORM"><span class="nav-number">62.</span> <span class="nav-text">什么是 ORM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">63.</span> <span class="nav-text">数据库连接池的原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%B5%E5%90%91%E5%88%87%E5%88%86-%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86%EF%BC%9F"><span class="nav-number">64.</span> <span class="nav-text">什么是纵向切分&#x2F;垂直切分？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%AA%E5%90%91%E5%88%87%E5%88%86-%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86"><span class="nav-number">64.0.0.1.</span> <span class="nav-text">横向切分&#x2F;水平切分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MyCat%EF%BC%9F"><span class="nav-number">65.</span> <span class="nav-text">什么是 MyCat？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%A4%E7%A7%8D%E4%BB%A5%E4%B8%8A%E6%89%A9%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">66.</span> <span class="nav-text">请说出两种以上扩大数据库的方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%B9%B6%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E%E8%BF%99%E4%BA%9B%E5%B1%9E%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">67.</span> <span class="nav-text">事务是什么？有哪些属性，并简要说明这些属性的含义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MyBatis-%E5%92%8C-hibernate-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">68.</span> <span class="nav-text">MyBatis 和 hibernate 的区别有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Statement-PreparedStatement-CallableStatment-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">69.</span> <span class="nav-text">Statement,PreparedStatement,CallableStatment 的区别。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-PreparedStatement-%E8%80%8C%E4%B8%8D%E6%98%AF-Statement"><span class="nav-number">70.</span> <span class="nav-text">JDBC 为什么要使用 PreparedStatement 而不是 Statement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%86%E4%B8%BA%E4%BA%8B%E5%89%8D%E8%A7%A6%E5%8F%91%E5%92%8C%E4%BA%8B%E5%90%8E%E8%A7%A6%E5%8F%91%EF%BC%8C%E8%BF%99%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%9C%89%E5%92%8C%E5%8C%BA%E5%88%AB%E3%80%82%E8%AF%AD%E5%8F%A5%E7%BA%A7%E8%A7%A6%E5%8F%91%E5%92%8C%E8%A1%8C%E7%BA%A7%E8%A7%A6%E5%8F%91%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">71.</span> <span class="nav-text">触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%B8%B8%E6%A0%87%E5%B7%B2%E7%BB%8F%E5%88%B0%E4%BA%86%E6%9C%80%E5%90%8E%EF%BC%9A"><span class="nav-number">72.</span> <span class="nav-text">游标的作用？如何知道游标已经到了最后：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD%EF%BC%9A"><span class="nav-number">73.</span> <span class="nav-text">数据库中常用术语：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NULL-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">74.</span> <span class="nav-text">NULL 是什么意思</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E6%9C%AC%E8%A1%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%9F"><span class="nav-number">75.</span> <span class="nav-text">什么是基本表？什么是视图？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%95%E8%BF%B0%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-number">76.</span> <span class="nav-text">试述视图的优点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%9D%A5%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">77.</span> <span class="nav-text">什么是存储过程？用什么来调用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">78.</span> <span class="nav-text">完整性约束包括哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-MySQL-%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%87%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">79.</span> <span class="nav-text">解释 MySQL 外连接、内连接与自连接的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%EF%BC%9F"><span class="nav-number">80.</span> <span class="nav-text">SQL 注入漏洞产生的原因？如何防止？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">81.</span> <span class="nav-text">存储过程和函数的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A7%8D%E7%B1%BB%E5%92%8C%E5%85%B3%E7%B3%BB"><span class="nav-number">82.</span> <span class="nav-text">关系型数据库和非关系型数据库种类和关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">82.0.0.1.</span> <span class="nav-text">关系型数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">82.0.0.2.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E3%80%81%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF%E7%AD%89"><span class="nav-number">83.</span> <span class="nav-text">内连接、外连接、交叉连接、笛卡儿积等</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/32257fddc744.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="数据库 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据库</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:19:45" itemprop="dateCreated datePublished" datetime="2023-12-20T15:19:45+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 17:02:26" itemprop="dateModified" datetime="2024-01-04T17:02:26+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>21k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>19 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Mysql-中-MyISAM-和-InnoDB-的区别有哪些？"><a href="#Mysql-中-MyISAM-和-InnoDB-的区别有哪些？" class="headerlink" title="Mysql 中 MyISAM 和 InnoDB 的区别有哪些？"></a>Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</h1><ul><li>区别：<ul><li>InnoDB支持事务，MyISAM不支持</li><li>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</li><li>但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ul></li><li>如何选择：<ul><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li></ul></li></ul><h4 id="InnoDB为什么推荐使用自增ID作为主键？"><a href="#InnoDB为什么推荐使用自增ID作为主键？" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键？"></a>InnoDB为什么推荐使用自增ID作为主键？</h4><ul><li>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）</li><li>如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</li></ul><h4 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h4><ul><li>插入缓冲（insert buffer）</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h1 id="⾏锁，表锁，乐观锁，悲观锁？"><a href="#⾏锁，表锁，乐观锁，悲观锁？" class="headerlink" title="⾏锁，表锁，乐观锁，悲观锁？"></a>⾏锁，表锁，乐观锁，悲观锁？</h1><ul><li>⾏锁：数据库表中某一⾏被锁住。</li><li>表锁：整个数据库表被锁住。</li><li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不不会修改，具体实现是给表增加⼀个版本号的字段，在执行update操作时⽐较该版本号是否与当前数据库中版本号⼀致，如⼀致，更新数据，反之拒绝。</li><li>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。读数据的时候会上锁，直到update完成才释放锁，使⽤悲观锁要注意不要锁住整个表。</li></ul><h1 id="数据库隔离级别是什什么？有什么作用？"><a href="#数据库隔离级别是什什么？有什么作用？" class="headerlink" title="数据库隔离级别是什什么？有什么作用？"></a>数据库隔离级别是什什么？有什么作用？</h1><ul><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它允许另外⼀个事务可以看到这个事务未提交的数据。 这种隔离级别会产⽣生脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外⼀个事务不能读取该 事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了了保证一个事务不能读取另⼀个事务未提交的数据外，还保证了了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理理为顺序执行。除了防止脏读， 不可重复读外，还避免了幻读。</li></ul><h1 id="MySQL主备同步的基本原理理。"><a href="#MySQL主备同步的基本原理理。" class="headerlink" title="MySQL主备同步的基本原理理。"></a>MySQL主备同步的基本原理理。</h1><ul><li>mysql主备复制实现分成三个步骤：<ul><li>master将改变记录到⼆进制⽇志(binary log) 中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</li><li>slave将master的binary log events拷⻉到它的中继日志(relay log) ；</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ul></li></ul><h1 id="select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？"><a href="#select-from-table-t-where-size-10-group-by-size-order-by-size的sql语句句执⾏行行顺序？" class="headerlink" title="select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？"></a>select * from table t where size &gt; 10 group by size order by size的sql语句句执⾏行行顺序？</h1><ul><li>sql语句句执⾏行行顺序如下：</li><li>where -&gt; group by -&gt; having -&gt; select -&gt; orderby</li></ul><h1 id="如何优化数据库性能"><a href="#如何优化数据库性能" class="headerlink" title="如何优化数据库性能"></a>如何优化数据库性能</h1><ul><li>索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署</li><li>选择合适的数据库引擎，合理使用索引</li><li>分页获取数据，只获取需要的字段</li><li>优化业务逻辑，减少数据库IO</li><li>分库分表</li><li>部署主从数据库</li><li>升级硬件</li></ul><h1 id="SQL什么情况下不会使用索引"><a href="#SQL什么情况下不会使用索引" class="headerlink" title="SQL什么情况下不会使用索引"></a>SQL什么情况下不会使用索引</h1><ul><li>不包含，不等于，函数</li><li>select * 可能导致不走索引；</li><li>空值会导致不走索引，因为hashset不能存空值；</li><li>索引列有函数运算，不走索引，可以在索引列列建⽴立⼀一个函数的索引。</li><li>隐式转换可能导致不走索引；</li><li>表的数据库小或者需要选择大部分数据，不走索引；</li><li>!&#x3D;或者&lt;&gt;可能导致不走索引；</li><li>字符型的索引列列会导致优化器认为需要扫描索引大部分数据且聚簇因子很大，最终导致弃用索引扫描而改用全表扫描方式</li><li>like ‘%liu’ 百分号在前不走索引；</li><li>not in, not exist不走索引；</li></ul><h1 id="一般在什什么字段上建索引"><a href="#一般在什什么字段上建索引" class="headerlink" title="一般在什什么字段上建索引"></a>一般在什什么字段上建索引</h1><ul><li>过滤数据最多的字段</li><li>表的主键、外键必须有索引；</li><li>数据量量超过300的表应该有索引；</li><li>经常与其他表进行行连接的表，在连接字段上应该建立索引；</li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>如何从一张表中查出name字段不包含”XYZ”的所有行？</li></ul><h1 id="如何解决高并发减库存问题"><a href="#如何解决高并发减库存问题" class="headerlink" title="如何解决高并发减库存问题"></a>如何解决高并发减库存问题</h1><ul><li>消息队列，异步处理，减库存加锁</li></ul><h1 id="数据库事务的几种粒度；"><a href="#数据库事务的几种粒度；" class="headerlink" title="数据库事务的几种粒度；"></a>数据库事务的几种粒度；</h1><ul><li>表锁定：对整个表的锁定。</li><li>行锁定：只锁定进⾏行更改的行，例如：insert，update，delete，都隐式采用行锁定。</li><li>数据库锁机制可分为多种粒度的： 数据库，表，页面，行</li><li>粒度越大，DBMS管理越容易，但是实现并发处理的能力就越差，表，页面，行</li></ul><h1 id="mysql调优"><a href="#mysql调优" class="headerlink" title="mysql调优"></a>mysql调优</h1><ul><li>explain select语句；</li><li>当只要一条数据时使用limit 1；</li><li>为搜索字段建索引；</li><li>避免select *；</li><li>字段尽量使用not null；</li><li>垂直分割；</li><li>拆分大的delete和insert语句：delete和insert会锁表；</li><li>分表分库分区</li></ul><h1 id="说说事务的四种特性（ACID）？"><a href="#说说事务的四种特性（ACID）？" class="headerlink" title="说说事务的四种特性（ACID）？"></a>说说事务的四种特性（ACID）？</h1><ul><li>原子性（Atomicty）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。（比如转账）</li><li>隔离性（Isolation）：事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。</li><li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><h1 id="innodb如何实现mysql的事务？"><a href="#innodb如何实现mysql的事务？" class="headerlink" title="innodb如何实现mysql的事务？"></a>innodb如何实现mysql的事务？</h1><ul><li>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页</li><li>然后redo log按照时间或者空间等条件进行落盘</li><li>undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了</li><li>此时，事务还未 COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进⾏数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使⽤用undo log进⾏事务回滚</li><li>事务执行COMMIT操作时，会将本事务相关的所有redo log都进⾏落盘，只有所有redo log落盘成功，才算COMMIT成功</li><li>然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发⽣了崩溃，则只使⽤用redo log恢复数据。</li></ul><h1 id="让你设计一个索引，你会怎么设计？"><a href="#让你设计一个索引，你会怎么设计？" class="headerlink" title="让你设计一个索引，你会怎么设计？"></a>让你设计一个索引，你会怎么设计？</h1><ul><li>mysql默认存储引擎innodb只显式支持B树索引</li><li>对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</li></ul><h1 id="为什么用自增列作为主键？"><a href="#为什么用自增列作为主键？" class="headerlink" title="为什么用自增列作为主键？"></a>为什么用自增列作为主键？</h1><ul><li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。<ul><li>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。</li><li>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li></ul></li><li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放<ul><li>因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</li></ul></li><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置<ul><li>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销</li><li>同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li></ul></li></ul><h1 id="为什么使用数据索引能提高效率？"><a href="#为什么使用数据索引能提高效率？" class="headerlink" title="为什么使用数据索引能提高效率？"></a>为什么使用数据索引能提高效率？</h1><ul><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ul><h1 id="B-树索引和哈希索引的区别？"><a href="#B-树索引和哈希索引的区别？" class="headerlink" title="B+树索引和哈希索引的区别？"></a>B+树索引和哈希索引的区别？</h1><ul><li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的</li><li>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的</li></ul><h4 id="哈希索引的优势"><a href="#哈希索引的优势" class="headerlink" title="哈希索引的优势"></a>哈希索引的优势</h4><ul><li>等值查询，哈希索引具有绝对优势</li><li>前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题</li></ul><h4 id="哈希索引不适用的场景"><a href="#哈希索引不适用的场景" class="headerlink" title="哈希索引不适用的场景"></a>哈希索引不适用的场景</h4><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li><li>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<ul><li>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主</li><li>没有范围查询、没有排序的时候，特别适合采用哈希索引</li><li>仅等值查询<ul><li>select id, name from table where name&#x3D;’李明’;</li></ul></li></ul></li><li>而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。</li><li>如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。</li><li>通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</li><li>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。</li><li>但某些时候，在负载高的情况下，自适应哈希索引中添加的read&#x2F;write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</li></ul><h1 id="B-树和-B-树的区别？"><a href="#B-树和-B-树的区别？" class="headerlink" title="B 树和 B+ 树的区别？"></a>B 树和 B+ 树的区别？</h1><ul><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</li></ul><h1 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h1><h4 id="B-的磁盘读写代价更低。"><a href="#B-的磁盘读写代价更低。" class="headerlink" title="B+的磁盘读写代价更低。"></a>B+的磁盘读写代价更低。</h4><ul><li>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</li><li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多</li><li>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li></ul><h4 id="B-tree的查询效率更加稳定。"><a href="#B-tree的查询效率更加稳定。" class="headerlink" title="B+-tree的查询效率更加稳定。"></a>B+-tree的查询效率更加稳定。</h4><ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引</li><li>所以任何关键字的查找必须走一条从根结点到叶子结点的路</li><li>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h1 id="关于-MySQL-联合索引"><a href="#关于-MySQL-联合索引" class="headerlink" title="关于 MySQL 联合索引"></a>关于 MySQL 联合索引</h1><ul><li>联合索引是两个或更多个列上的索引</li><li>对于联合索引Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</li><li>例如索引是key index (a,b,c).<ul><li>可以支持a 、 a,b 、 a,b,c 3种组合进行查找</li><li>但不支持 b,c进行查找</li><li>当最左侧字段是常量引用时，索引就十分有效。</li></ul></li><li>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。</li><li>复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。</li><li>如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处。</li></ul><h1 id="什么情况下应不建或少建索引？"><a href="#什么情况下应不建或少建索引？" class="headerlink" title="什么情况下应不建或少建索引？"></a>什么情况下应不建或少建索引？</h1><ul><li>表记录太少</li><li>经常插入、删除、修改的表</li><li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><ul><li>表分区是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分</li><li>从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</li></ul><h1 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h1><ul><li>分表：指的是通过一定规则，将一张表分解成多张不同的表</li><li>比如将用户订单记录根据时间成多个表。</li><li>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</li></ul><h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><h4 id="存储更多数据"><a href="#存储更多数据" class="headerlink" title="存储更多数据"></a>存储更多数据</h4><ul><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li><li>和单个磁盘或者文件系统相比，可以存储更多数据</li></ul><h4 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h4><ul><li>在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率</li><li>涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li></ul><h4 id="分区表更容易维护"><a href="#分区表更容易维护" class="headerlink" title="分区表更容易维护"></a>分区表更容易维护</h4><ul><li>例如：想批量删除大量数据可以清除整个分区。</li></ul><h4 id="避免某些特殊的瓶颈"><a href="#避免某些特殊的瓶颈" class="headerlink" title="避免某些特殊的瓶颈"></a>避免某些特殊的瓶颈</h4><ul><li>例如InnoDB的单个索引的互斥访问，ext3文件系统的inode锁竞争等。</li></ul><h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式</li><li>在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><ul><li>命令：show variables like ‘%partition%’ 运行结果:</li><li>mysql&gt; show variables like ‘%partition%’;</li><li>have_partintioning 的值为YES，表示支持分区。</li></ul><h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><ul><li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h1 id="关于MVVC"><a href="#关于MVVC" class="headerlink" title="关于MVVC"></a>关于MVVC</h1><ul><li>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control)</li><li>注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control</li><li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。</li><li>LBCC：Lock-Based Concurrency Control，基于锁的并发控制</li><li>MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议</li><li>纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。</li><li>在MVCC并发控制中，读操作可以分成两类：<ul><li>快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）</li><li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li></ul></li></ul><h1 id="行级锁定的优缺点"><a href="#行级锁定的优缺点" class="headerlink" title="行级锁定的优缺点"></a>行级锁定的优缺点</h1><h4 id="行级锁定的优点"><a href="#行级锁定的优点" class="headerlink" title="行级锁定的优点"></a>行级锁定的优点</h4><ul><li>当在许多线程中访问不同的行时只存在少量锁定冲突</li><li>回滚时只有少量的更改</li><li>可以长时间锁定单一的行</li></ul><h4 id="行级锁定的缺点"><a href="#行级锁定的缺点" class="headerlink" title="行级锁定的缺点"></a>行级锁定的缺点</h4><ul><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h1 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h1><ul><li>key 是数据库的物理结构，它包含两层意义和作用<ul><li>一是约束（偏重于约束和规范数据库的结构完整性）</li><li>二是索引（辅助查询用的），包括primary key, unique key, foreign key 等</li></ul></li><li>index是数据库的物理结构<ul><li>它只是辅助查询的</li><li>它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储</li><li>索引要分类的话，分为前缀索引、全文本索引等；</li></ul></li></ul><h1 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h1><h4 id="字段名及字段配制合理性"><a href="#字段名及字段配制合理性" class="headerlink" title="字段名及字段配制合理性"></a>字段名及字段配制合理性</h4><ul><li>剔除关系不密切的字段；</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）；</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）；</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）；</li><li>字段名不要使用保留字或者关键字；</li><li>保持字段名和类型的一致性；</li><li>慎重选择数字类型；</li><li>给文本字段留足余量；</li></ul><h4 id="系统特殊字段处理及建成后建议"><a href="#系统特殊字段处理及建成后建议" class="headerlink" title="系统特殊字段处理及建成后建议"></a>系统特殊字段处理及建成后建议</h4><ul><li>添加删除标记（例如操作人、删除时间）；</li><li>建立版本机制；</li></ul><h4 id="表结构合理性配置"><a href="#表结构合理性配置" class="headerlink" title="表结构合理性配置"></a>表结构合理性配置</h4><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）；</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><h4 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h4><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）；</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的；</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响；</li><li>避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显；</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）；</li></ul><h1 id="数据库三范式是什么"><a href="#数据库三范式是什么" class="headerlink" title="数据库三范式是什么?"></a>数据库三范式是什么?</h1><h4 id="第一范式（1NF"><a href="#第一范式（1NF" class="headerlink" title="第一范式（1NF"></a>第一范式（1NF</h4><ul><li>字段具有原子性,不可再分</li><li>所有关系型数据库系统都满足第一范式</li><li>数据库表中的字段都是单一属性的，不可再分</li></ul><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><ul><li>是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）</li><li>要求数据库表中的每个实例或行必须可以被惟一地区分</li><li>通常需要为表加上一个列，以存储各个实例的惟一标识</li><li>这个惟一属性列被称为主关键字或主键。</li></ul><h4 id="满足第三范式（3NF）"><a href="#满足第三范式（3NF）" class="headerlink" title="满足第三范式（3NF）"></a>满足第三范式（3NF）</h4><ul><li>必须先满足第二范式（2NF）</li><li>简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</li><li>所以第三范式具有如下特征<ul><li>每一列只有一个值</li><li>每一行都能区分</li><li>每一个表都不包含其他表已经包含的非主关键字信息。</li></ul></li></ul><h1 id="有哪些数据库优化方面的经验"><a href="#有哪些数据库优化方面的经验" class="headerlink" title="有哪些数据库优化方面的经验?"></a>有哪些数据库优化方面的经验?</h1><ul><li>用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</li><li>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</li><li>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等</li><li>UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL</li><li>UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同<ul><li>对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录</li><li>对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</li></ul></li></ul><h1 id="请简述常用的索引有哪些种类"><a href="#请简述常用的索引有哪些种类" class="headerlink" title="请简述常用的索引有哪些种类?"></a>请简述常用的索引有哪些种类?</h1><ul><li>普通索引: 即针对数据库表创建索引</li><li>唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值</li><li>主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li><li>组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li></ul><h1 id="在mysql数据库中索引的工作机制是什么？"><a href="#在mysql数据库中索引的工作机制是什么？" class="headerlink" title="在mysql数据库中索引的工作机制是什么？"></a>在mysql数据库中索引的工作机制是什么？</h1><ul><li>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据</li><li>索引的实现通常使用B树及其变种B+树</li></ul><h1 id="MySQL的基础操作命令"><a href="#MySQL的基础操作命令" class="headerlink" title="MySQL的基础操作命令"></a>MySQL的基础操作命令</h1><ul><li>MySQL 是否处于运行状态:Debian 上运行命令 service mysql status，在RedHat 上运行命令 service mysqld status</li><li>开启或停止 MySQL 服务 :运行命令 service mysqld start 开启服务；运行命令 service mysqld stop 停止服务</li><li>Shell 登入 MySQL: 运行命令 mysql -u root -p</li><li>列出所有数据库:运行命令 show databases;</li><li>切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库</li><li>列出某个数据库内所有表: show tables;</li><li>获取表内所有 Field 对象的名称和类型 :describe table_name;</li></ul><h1 id="mysql的复制原理以及流程"><a href="#mysql的复制原理以及流程" class="headerlink" title="mysql的复制原理以及流程"></a>mysql的复制原理以及流程</h1><ul><li>Mysql内建的复制功能是构建大型，高性能应用程序的基础</li><li>将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的</li><li>复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器</li><li>主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环</li><li>这些日志可以记录发送到从服务器的更新</li><li>当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置</li><li>从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新</li><li>过程如下<ul><li>主服务器把更新记录到二进制日志文件中</li><li>从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中</li><li>从服务器重做中继日志中的时间，把更新应用到自己的数据库上</li></ul></li></ul><h1 id="mysql支持的复制类型"><a href="#mysql支持的复制类型" class="headerlink" title="mysql支持的复制类型?"></a>mysql支持的复制类型?</h1><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><ul><li>在主服务器上执行的SQL语句，在从服务器上执行同样的语句</li><li>MySQL默认采用基于语句的复制，效率比较高</li><li>一旦发现没法精确复制时，会自动选着基于行的复制。</li></ul><h4 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h4><ul><li>把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持</li></ul><h4 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h4><ul><li>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</li></ul><h1 id="mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？"><a href="#mysql中varchar与char的区别以及varchar-50-中的50代表的涵义？" class="headerlink" title="mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？"></a>mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？</h1><ul><li>varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.</li><li>varchar(50)中50的涵义 : 最多存放50个字节</li><li>int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</li></ul><h1 id="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"><a href="#表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？" class="headerlink" title="表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？"></a>表中有大字段X（例如：text类型），且字段X不会经常更新，以读为为主，将该字段拆成子表好处是什么？</h1><ul><li>如果字段里面有大字段（text,blob）类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了</li><li>MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的（16K），每条记录越小，相同的块存储的记录就越多</li><li>此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率</li><li>当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的</li><li>拆分开后，对字段的UPDAE就要UPDATE多个表了</li></ul><h1 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？</h1><ul><li>InnoDB行锁是通过给索引上的索引项加锁来实现的</li><li>这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的</li><li>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li></ul><h1 id="若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可"><a href="#若一张表中只有一个字段VARCHAR-N-类型，utf8编码，则N最大值为多少-精确到数量级即可" class="headerlink" title="若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?"></a>若一张表中只有一个字段VARCHAR(N)类型，utf8编码，则N最大值为多少(精确到数量级即可)?</h1><ul><li>由于utf8的每个字符最多占用3个字节</li><li>而MySQL定义行的长度不能超过65535</li><li>因此N的最大值计算方法为：(65535-1-2)&#x2F;3</li><li>减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度，除以3是因为utf8限制：每个字符最多占用3个字节。</li></ul><h1 id="SELECT-和SELECT-全部字段的2种写法有何优缺点"><a href="#SELECT-和SELECT-全部字段的2种写法有何优缺点" class="headerlink" title="SELECT * 和SELECT 全部字段的2种写法有何优缺点?"></a>SELECT * 和SELECT 全部字段的2种写法有何优缺点?</h1><ul><li>前者要解析数据字典，后者不需要</li><li>结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</li><li>表字段改名，前者不需要修改，后者需要改</li><li>后者可以建立索引进行优化，前者无法优化</li><li>后者的可读性比前者要高</li></ul><h1 id="HAVNG-子句-和-WHERE的异同点"><a href="#HAVNG-子句-和-WHERE的异同点" class="headerlink" title="HAVNG 子句 和 WHERE的异同点?"></a>HAVNG 子句 和 WHERE的异同点?</h1><ul><li>语法上：where 用表中列名，having用select结果别名</li><li>影响结果范围：where从表读出数据的行数，having返回客户端的行数</li><li>索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作</li><li>where后面不能使用聚集函数，having是专门使用聚集函数的。</li></ul><h1 id="MySQL当记录不存在时insert-当记录存在时update，语句怎么写？"><a href="#MySQL当记录不存在时insert-当记录存在时update，语句怎么写？" class="headerlink" title="MySQL当记录不存在时insert,当记录存在时update，语句怎么写？"></a>MySQL当记录不存在时insert,当记录存在时update，语句怎么写？</h1><ul><li>INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c&#x3D;c+1;</li></ul><h1 id="MySQL的insert和update的select语句语法"><a href="#MySQL的insert和update的select语句语法" class="headerlink" title="MySQL的insert和update的select语句语法"></a>MySQL的insert和update的select语句语法</h1><ul><li>insert into student (stuid,stuname,deptid) select 10,’xzm’,3 from student where stuid &gt; 8;</li><li>update student a inner join student b on b.stuID&#x3D;10 set a.stuname&#x3D;concat(b.stuname, b.stuID) where a.stuID&#x3D;10 ;</li></ul><h1 id="Mysql-中有哪几种锁？"><a href="#Mysql-中有哪几种锁？" class="headerlink" title="Mysql 中有哪几种锁？"></a>Mysql 中有哪几种锁？</h1><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低， 并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和 行锁之间，并发度一般。</li></ul><h1 id="Mysql-中有哪些不同的表格？"><a href="#Mysql-中有哪些不同的表格？" class="headerlink" title="Mysql 中有哪些不同的表格？"></a>Mysql 中有哪些不同的表格？</h1><ul><li>共有 5 种类型的表格：<ul><li>MyISAM</li><li>Heap</li><li>Merge</li><li>INNODB</li><li>ISAM</li></ul></li></ul><h1 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h1><ul><li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li><li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li></ul><h1 id="myisamchk-是用来做什么的？"><a href="#myisamchk-是用来做什么的？" class="headerlink" title="myisamchk 是用来做什么的？"></a>myisamchk 是用来做什么的？</h1><ul><li>它用来压缩 MyISAM 表，这减少了磁盘或内存使用。</li></ul><h1 id="MyISAM-Static-和-MyISAM-Dynamic-有什么区别？"><a href="#MyISAM-Static-和-MyISAM-Dynamic-有什么区别？" class="headerlink" title="MyISAM Static 和 MyISAM Dynamic 有什么区别？"></a>MyISAM Static 和 MyISAM Dynamic 有什么区别？</h1><ul><li>在 MyISAM Static 上的所有字段有固定宽度</li><li>动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。</li><li>MyISAM Static 在受损情况下更容易恢复。</li></ul><h1 id="如果一个表有一列定义为-TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为-TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为 TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为 TIMESTAMP，将发生什么？</h1><ul><li>每当行被更改时，时间戳字段将获取当前时间戳。</li></ul><h1 id="列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为-AUTO-INCREMENT-时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？"></a>列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？</h1><ul><li>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</li></ul><h1 id="数据库架构原则"><a href="#数据库架构原则" class="headerlink" title="数据库架构原则"></a>数据库架构原则</h1><ul><li>高可用</li><li>高性能</li><li>一致性</li><li>扩展性</li></ul><h1 id="常见的数据库架构方案"><a href="#常见的数据库架构方案" class="headerlink" title="常见的数据库架构方案"></a>常见的数据库架构方案</h1><h4 id="主备架构"><a href="#主备架构" class="headerlink" title="主备架构"></a>主备架构</h4><ul><li>只有主库提供读写服务，备库冗余作故障转移用</li><li>高可用分析：高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写都操作主库，很容易产生瓶颈</li><li>大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能</li><li>另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。 </li><li>一致性分析：读写都操作主库，不存在数据一致性问题。 </li><li>扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案</li><li>第二，扩展性差，这点可以通过分库分表来扩展。</li></ul></li></ul><h4 id="双主架构"><a href="#双主架构" class="headerlink" title="双主架构"></a>双主架构</h4><ul><li>两个主库同时提供服务，负载均衡</li><li>高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务</li><li>这个过程对业务层是透明的，无需修改代码或配置。 </li><li>高性能分析：读写性能相比于方案一都得到提升，提升一倍。</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：当然可以扩展成三主循环，但笔者不建议（会多一层数据同步，这样同步的时间会更长）</li><li>如果非得在数据库架构层面扩展的话，扩展为方案四。 </li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。</li></ul></li></ul><h4 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h4><ul><li>一主多从，读写分离</li><li>高可用分析：主库单点，从库高可用</li><li>一旦主库挂了，写服务也就无法提供。 </li><li>高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能</li><li>读的性能提高了，整体性能也提高了。</li><li>另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引</li><li>线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引</li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案。 </li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。</li><li>带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长）</li><li>可落地分析：两点影响落地使用<ul><li>第一，数据一致性问题，一致性解决方案可解决问题</li><li>第二，主库单点问题，笔者暂时没想到很好的解决方案。</li></ul></li><li>思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？</li></ul><h4 id="双主-主从架构"><a href="#双主-主从架构" class="headerlink" title="双主+主从架构"></a>双主+主从架构</h4><ul><li>看似完美的方案</li><li>高可用分析：高可用。 </li><li>高性能分析：高性能。 </li><li>一致性分析：存在数据一致性问题。请看，一致性解决方案 。</li><li>扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） </li><li>可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。</li></ul><h1 id="一致性解决方案"><a href="#一致性解决方案" class="headerlink" title="一致性解决方案"></a>一致性解决方案</h1><h4 id="主库和从库一致性解决方案"><a href="#主库和从库一致性解决方案" class="headerlink" title="主库和从库一致性解决方案"></a>主库和从库一致性解决方案</h4><ul><li>数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的</li><li>这个同步时间内主库和从库的数据会存在不一致的情况</li><li>如果同步过程中有读请求，那么读到的就是从库中的老数据。</li><li>既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：<ul><li>直接忽略，如果业务允许延时存在，那么就不去管它。 </li><li>强制读主，采用主备架构方案，读写都走主库</li><li>用缓存来扩展数据库读性能</li><li>有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。</li></ul></li><li>选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。</li><li>读请求时，同样的方式生成key先去查Cache，再判断是否命中</li><li>若命中，则读主库，否则读从库</li><li>代价是多了一次缓存读写，基本可以忽略。</li><li>半同步复制，等主从同步完成，写请求才返回</li><li>就是大家常说的“半同步复制”semi-sync</li><li>这可以利用数据库原生功能，实现比较简单</li><li>代价是写请求时延增长，吞吐量降低。 </li><li>数据库中间件，引入开源（mycat等）或自研的数据库中间层</li><li>个人理解，思路同选择读主</li><li>数据库中间件的成本比较高，并且还多引入了一层</li></ul><h4 id="DB和缓存一致性解决方案"><a href="#DB和缓存一致性解决方案" class="headerlink" title="DB和缓存一致性解决方案"></a>DB和缓存一致性解决方案</h4><ul><li>先来看一下常用的缓存使用方式：<ul><li>第一步：淘汰缓存；</li><li>第二步：写入数据库；</li><li>第三步：读取缓存？返回：读取数据库；</li><li>第四步：读取数据库后写入缓存。</li></ul></li><li>注：如果按照这种方式，不会产生DB和缓存不一致问题，会产生DB和缓存不一致问题，即4.read先于3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据</li><li>设置缓存时，一定要加上有效时间，以防延时淘汰缓存失败的情况！</li><li>加缓存和索引是通用的提升数据库性能的方式； </li><li>绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。</li><li>阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。</li></ul><p> </p><h1 id="主从数据库不一致如何解决"><a href="#主从数据库不一致如何解决" class="headerlink" title="主从数据库不一致如何解决"></a>主从数据库不一致如何解决</h1><ul><li>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</li><li>忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</li><li>强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</li><li>选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</li></ul><h1 id="说出数据连接池的工作机制是什么"><a href="#说出数据连接池的工作机制是什么" class="headerlink" title="说出数据连接池的工作机制是什么?"></a>说出数据连接池的工作机制是什么?</h1><ul><li>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接</li><li>客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙</li><li>如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定</li><li>当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</li></ul><h1 id="数据库创建索引的缺点？"><a href="#数据库创建索引的缺点？" class="headerlink" title="数据库创建索引的缺点？"></a>数据库创建索引的缺点？</h1><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h1 id="说一下数据库的存储过程？"><a href="#说一下数据库的存储过程？" class="headerlink" title="说一下数据库的存储过程？"></a>说一下数据库的存储过程？</h1><ul><li>存储过程与函数的区别：<ul><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。</li><li>对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。</li><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。</li></ul></li><li>存储过程的优点：<ul><li>执行速度更快 – 在数据库中保存的存储过程语句都是编译过的</li><li>允许模块化程序设计 – 类似方法的复用</li><li>提高系统安全性 – 防止SQL注入</li><li>减少网络流通量 – 只要传输存储过程的名称</li></ul></li><li>系统存储过程一般以sp开头，用户自定义的存储过程一般以usp开头</li></ul><h1 id="什么是基本表，什么是视图，两者的区别和联系是什么？"><a href="#什么是基本表，什么是视图，两者的区别和联系是什么？" class="headerlink" title="什么是基本表，什么是视图，两者的区别和联系是什么？"></a>什么是基本表，什么是视图，两者的区别和联系是什么？</h1><ul><li>它是从一个或几个基本表中导出的 表，是从现有基本表中抽取若干子集组成用户的“专用表”。</li><li>基本表：基本表的定义指建立基本关系模式,</li><li>而变更则是指对数据库中已存在的基本表进行删除与修改。</li><li>区别：<ul><li>视图是已经编译好的 sql 语句。而表不是</li><li>视图没有实际的物理记录。而表有。</li><li>表是内容，视图是窗口</li><li>表只用物理空间而视图不占用物理空间，</li></ul></li><li>视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改</li><li>表是内模式，试图是外模式</li><li>视图是查看数据表的一种方法，</li><li>可以查询数据表中某些字段构成的数据，</li><li>只是一些 SQL 语句的集合。从安全的角度说，</li><li>视图可以不给用户接触数据表，从而不知道表结构。</li><li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li><li>联系<ul><li>视图（view）是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。</li><li>视图是基本表的抽象和在逻辑意义上建立的新关系</li></ul></li></ul><h1 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM"></a>什么是 ORM</h1><ul><li>对象关系映射(Object Relation Mapping，简称 ORM)模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术</li><li>简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中</li><li>那么到底如何实现持久化呢？一种简单的方案时采用硬编码方式(jdbc 操作 sql 方式)，为每一种可能的数据库访问操作提供单独的方法。</li><li>这种方案存在以下不足：<ul><li>持久化层缺乏弹性，一旦出现业务需求变更，就必须修改持久化层的接口</li><li>持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层的相关程序代码，增加软件的维护难度。</li></ul></li><li>ORM 提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得 ORM 中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁，Java 典型的 ORM 框架有：Hibernate，ibatis(mybtis)，speedframework。</li><li>ORM 框架的方法论基于三个核心原则：<ul><li>简单：以最基本的形式建模数据</li><li>传达性：数据库结构被任何人都能理解的语言文档化</li><li>精确性：基于数据模型创建正确标准化了结构</li></ul></li></ul><h1 id="数据库连接池的原理"><a href="#数据库连接池的原理" class="headerlink" title="数据库连接池的原理"></a>数据库连接池的原理</h1><ul><li>传统连接方式:<ul><li>首先调用 Class.forName()方法加载数据库驱动，</li><li>然后调用 DriverManager.getConnection()方法建立连接.</li></ul></li><li>连接池技术:<ul><li>连接池解决方案是在应用程序启动时就预先建立多个数据库连接对象,然后将连接对象保存到连接池中。</li><li>当客户请求到来时,从池中取出一个连接对象为客户服务。</li><li>当请求完成时,客户程序调用 close()方法,将连接对象放回池中.</li><li>对于多于连接池中连接数的请求，排队等待。</li><li>应用程序还可根据连接池中连接的使用率，动态增加或减少池中的连接数。</li></ul></li></ul><h1 id="什么是纵向切分-垂直切分？"><a href="#什么是纵向切分-垂直切分？" class="headerlink" title="什么是纵向切分&#x2F;垂直切分？"></a>什么是纵向切分&#x2F;垂直切分？</h1><ul><li>就是把原本存储于一个库的数据存储到多个库上。</li><li>由于对数据库的读写都是对同一个库进行操作，所以单库并不能解决大规模并发写入的问题。</li><li>例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</li><li>优点<ul><li>减少增量数据写入时的锁对查询的影响。</li><li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘 IO，时延变短。</li></ul></li><li>缺点：无法解决单表数据量太大的问题。</li></ul><h4 id="横向切分-水平切分"><a href="#横向切分-水平切分" class="headerlink" title="横向切分&#x2F;水平切分"></a>横向切分&#x2F;水平切分</h4><ul><li>把原本存储于一个表的数据分块存储到多个表上。当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，进行划分，然后存储到多个结构相同的表，和不同的库上。</li><li>例如，我们 userDB 中的 userTable 中数据量很大，那么可以把 userDB 切分为结构相同的多个 userDB：part0DB、part1DB 等，再将 userDB 上的 userTable，切分为很多userTable：userTable0、userTable1 等，然后将这些表按照一定的规则存储到多个 userDB上。</li><li>优点：<ul><li>单表的并发能力提高了，磁盘 I&#x2F;O 性能也提高了。</li><li>如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。</li></ul></li><li>缺点：无法实现表连接查询</li></ul><h1 id="什么是-MyCat？"><a href="#什么是-MyCat？" class="headerlink" title="什么是 MyCat？"></a>什么是 MyCat？</h1><ul><li>MyCat 是目前最流行的基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分离。</li><li>MyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。</li><li>MyCat 发展到目前的版本，已经不是一个单纯的 MySQL 代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL 等主流数据库，也支持 MongoDB 这种新型 NoSQL 方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那种存储方式，在 MyCat 里，都是一个传统的数据库表，支持标准的 SQL 语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度。</li></ul><h1 id="请说出两种以上扩大数据库的方式"><a href="#请说出两种以上扩大数据库的方式" class="headerlink" title="请说出两种以上扩大数据库的方式"></a>请说出两种以上扩大数据库的方式</h1><ul><li>修改现有表空间的大小；</li><li>向表空间插入一个新的数据文件</li></ul><h1 id="事务是什么？有哪些属性，并简要说明这些属性的含义"><a href="#事务是什么？有哪些属性，并简要说明这些属性的含义" class="headerlink" title="事务是什么？有哪些属性，并简要说明这些属性的含义"></a>事务是什么？有哪些属性，并简要说明这些属性的含义</h1><ul><li>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如 SQL，C++或 Java）书写的用户程序的执行所引起，并用形如 begin transaction 和 end transaction 语句（或函数调用）来界定。</li><li>事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。</li><li>事务应该具有 4 个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为 ACID特性。原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li></ul><h1 id="MyBatis-和-hibernate-的区别有哪些？"><a href="#MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="MyBatis 和 hibernate 的区别有哪些？"></a>MyBatis 和 hibernate 的区别有哪些？</h1><ul><li>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</li><li>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</li><li>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</li><li>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</li></ul><h1 id="Statement-PreparedStatement-CallableStatment-的区别。"><a href="#Statement-PreparedStatement-CallableStatment-的区别。" class="headerlink" title="Statement,PreparedStatement,CallableStatment 的区别。"></a>Statement,PreparedStatement,CallableStatment 的区别。</h1><ul><li>区别有以下几点：</li><li>Statement 是 PreparedStatement 和 CallableStatement 的父类；</li><li>Statement 是直接发送 Sql 语句到数据库，事先没有进行预编译。 PreparedStatement会将 sql 进行预编译，当 sql 语句要重复执行时，数据库会调用以前预编译好的 sql 语句，所以 PreparedStatement 在性能方面会更好；</li><li>PreparedStatement 在执行 sql 时，对传入的参数可以进行强制的类型转换。以保证数据格式与底层的数据库格式一致。</li><li>CallableStatement 适用与存储过程的查询表达语句</li></ul><h1 id="JDBC-为什么要使用-PreparedStatement-而不是-Statement"><a href="#JDBC-为什么要使用-PreparedStatement-而不是-Statement" class="headerlink" title="JDBC 为什么要使用 PreparedStatement 而不是 Statement"></a>JDBC 为什么要使用 PreparedStatement 而不是 Statement</h1><ul><li>PreparedStatement 是 用 来 执 行 SQL 查 询 语 句 的 API 之 一 ， Java 提 供 了 Statement 、PreparedStatement 和 CallableStatement 三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement 则是用于存储过程。</li></ul><h1 id="触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别："><a href="#触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：" class="headerlink" title="触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别："></a>触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：</h1><ul><li>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。</li><li>语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。</li></ul><h1 id="游标的作用？如何知道游标已经到了最后："><a href="#游标的作用？如何知道游标已经到了最后：" class="headerlink" title="游标的作用？如何知道游标已经到了最后："></a>游标的作用？如何知道游标已经到了最后：</h1><ul><li>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。</li></ul><h1 id="数据库中常用术语："><a href="#数据库中常用术语：" class="headerlink" title="数据库中常用术语："></a>数据库中常用术语：</h1><ul><li>ddl:数据定义语言 Create Drop Alter</li><li>dml:数据操纵语言 insert update delete select</li><li>dcl:数据控制语言 grant revoke</li><li>tcl:事务控制语言 commit rollback</li></ul><h1 id="NULL-是什么意思"><a href="#NULL-是什么意思" class="headerlink" title="NULL 是什么意思"></a>NULL 是什么意思</h1><ul><li>NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这个值的任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比较，并在逻辑上希望获得一个答案。</li><li>使用 IS NULL 来进行 NULL 判断‘</li></ul><h1 id="什么是基本表？什么是视图？"><a href="#什么是基本表？什么是视图？" class="headerlink" title="什么是基本表？什么是视图？"></a>什么是基本表？什么是视图？</h1><ul><li>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表</li></ul><h1 id="试述视图的优点？"><a href="#试述视图的优点？" class="headerlink" title="试述视图的优点？"></a>试述视图的优点？</h1><ul><li>视图能够简化用户的操作</li><li>视图使用户能以多种角度看待同一数据；</li><li>视图为数据库提供了一定程度的逻辑独立性</li><li>视图能够对机密数据提供安全保护。</li></ul><h1 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h1><ul><li>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。</li></ul><h1 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a>完整性约束包括哪些？</h1><ul><li>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</li><li>分为以下四类：<ul><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ul></li><li>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、<br>foreign key、check、UNIQUE) 。</li></ul><h1 id="解释-MySQL-外连接、内连接与自连接的区别"><a href="#解释-MySQL-外连接、内连接与自连接的区别" class="headerlink" title="解释 MySQL 外连接、内连接与自连接的区别"></a>解释 MySQL 外连接、内连接与自连接的区别</h1><ul><li>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</li><li>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。</li><li>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</li><li>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。</li></ul><h1 id="SQL-注入漏洞产生的原因？如何防止？"><a href="#SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL 注入漏洞产生的原因？如何防止？"></a>SQL 注入漏洞产生的原因？如何防止？</h1><ul><li>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。</li><li>防止 SQL 注入的方式：<ul><li>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置</li><li>执行 sql 语句时使用 addslashes 进行 sql 语句转换Sql 语句书写尽量不要省略双引号和单引号。</li><li>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。</li><li>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</li></ul></li></ul><h1 id="存储过程和函数的区别"><a href="#存储过程和函数的区别" class="headerlink" title="存储过程和函数的区别"></a>存储过程和函数的区别</h1><ul><li>存储过程是用户定义的一系列 sql 语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。</li></ul><h1 id="关系型数据库和非关系型数据库种类和关系"><a href="#关系型数据库和非关系型数据库种类和关系" class="headerlink" title="关系型数据库和非关系型数据库种类和关系"></a>关系型数据库和非关系型数据库种类和关系</h1><ul><li>数据库</li><li>类型	特性	优点	缺点</li></ul><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><ul><li>SQLite、Oracle、mysql	1、关系型数据库，是指采用了关系模型来组织数据的数据库；</li><li>关系型数据库的最大特点就是事务的一致性；</li><li>简单来说，关系模型指的就是二维表格模型，</li><li>而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。<ul><li>容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</li><li>使用方便：通用的SQL语言使得操作关系型数据库非常方便；</li><li>易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；</li><li>支持SQL，可用于复杂的查询。</li></ul></li><li>为了维护一致性所付出的巨大代价就是其读写性能比较差；</li><li>固定的表结构；</li><li>高并发读写需求；</li><li>海量数据的高效率读写；</li></ul><h4><a href="#" class="headerlink"></a></h4><ul><li>非关系型数据库</li><li>MongoDb、redis、HBase</li><li>使用键值对存储数据；</li><li>分布式；</li><li>一般不支持ACID特性；</li><li>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。<ul><li>无需经过sql层的解析，读写性能很高；</li><li>基于键值对，数据没有耦合性，容易扩展；</li><li>存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。</li></ul><p></p></li><li>不提供sql支持，学习和使用成本较高；</li><li>无事务处理，附加功能bi和报表等支持也不好；</li></ul><h1 id="内连接、外连接、交叉连接、笛卡儿积等"><a href="#内连接、外连接、交叉连接、笛卡儿积等" class="headerlink" title="内连接、外连接、交叉连接、笛卡儿积等"></a>内连接、外连接、交叉连接、笛卡儿积等</h1><ul><li>内连接(INNER JOIN)：  <ul><li>分为三种：等值连接、自然连接、不等连接</li></ul></li><li>外连接(OUTER JOIN)：  </li><li>分为三种：  <ul><li>左外连接(LEFT OUTER JOIN或LEFT JOIN)  </li><li>右外连接(RIGHT OUTER JOIN或RIGHT JOIN)  </li><li>全外连接(FULL OUTER JOIN或FULL JOIN)  交叉连接(CROSS JOIN)：没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积</li></ul></li><li>笛卡尔积是两个表每一个字段相互匹配，去掉where 或者inner join的等值 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。内连接: 只连接匹配的行。</li><li>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。</li><li>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。</li><li>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</li><li>交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"><i class="fa fa-tag"></i> 数据库</a> <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/4a23c7da79c0.html" rel="prev" title="Spring cloud"><i class="fa fa-angle-left"></i> Spring cloud</a></div><div class="post-nav-item"><a href="/publishes/e002a9c6759b.html" rel="next" title="Java web">Java web <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">452k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:51</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>