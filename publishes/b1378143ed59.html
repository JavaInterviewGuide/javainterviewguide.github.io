<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="介绍一下 Hibernate 的缓存为什么要用 Hibernate 缓存？ Hibernate 是一种持久化层框架，经常访问物理数据库。 为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。 为了提高访问速度，把磁盘或者数据库访问变成内存访问  Hibernate"><meta property="og:type" content="article"><meta property="og:title" content="Hibernate"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/b1378143ed59.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="介绍一下 Hibernate 的缓存为什么要用 Hibernate 缓存？ Hibernate 是一种持久化层框架，经常访问物理数据库。 为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。 为了提高访问速度，把磁盘或者数据库访问变成内存访问  Hibernate"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-01-02T06:48:16.000Z"><meta property="article:modified_time" content="2024-01-04T08:00:26.642Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="Hibernate"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/b1378143ed59.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/b1378143ed59.html","path":"publishes/b1378143ed59.html","title":"Hibernate"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Hibernate | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Hibernate-%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">介绍一下 Hibernate 的缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Hibernate-%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">为什么要用 Hibernate 缓存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hibernate-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">Hibernate 缓存原理是怎样的？</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8F%88%E7%A7%B0%E4%B8%BA%E2%80%9Dsession-%E7%9A%84%E7%BC%93%E5%AD%98%E2%80%9D%E3%80%82"><span class="nav-number">2.</span> <span class="nav-text">Hibernate 一级缓存又称为”session 的缓存”。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate-%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8F%88%E7%A7%B0%E4%B8%BA%E2%80%9DsessionFactory-%E7%9A%84%E7%BC%93%E5%AD%98%E2%80%9D%E3%80%82"><span class="nav-number">3.</span> <span class="nav-text">Hibernate 的二级缓存又称为”sessionFactory 的缓存”。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">Hibernate 对象的状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Session-%E7%9A%84-save-%E3%80%81update-%E3%80%81merge-%E3%80%81lock-%E3%80%81saveOrUpdate-%E5%92%8C-persist-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Session-%E7%9A%84-load-%E5%92%8C-get-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">Session 的 load 和 get 方法的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SessionFactory-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9FSession-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%8C%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%83%BD%E5%A4%9F%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E4%B8%AA-Session-%E5%90%97%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate%E4%B8%8EJDBC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">Hibernate与JDBC的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate%E4%B8%AD%E7%9A%84%E4%B8%A4%E5%A4%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">9.</span> <span class="nav-text">Hibernate中的两大配置文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">Hibernate事务处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate%E4%BA%94%E5%A4%A7%E6%A0%B8%E5%BF%83%EF%BC%88%E7%B1%BB-%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%AE%80%E8%BF%B0"><span class="nav-number">11.</span> <span class="nav-text">Hibernate五大核心（类&#x2F;接口）简述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">Hibernate的运行原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate%E3%80%81Ibatis%E3%80%81Jdbc%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">Hibernate、Ibatis、Jdbc三者的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate-%E4%B8%ADget-%E5%92%8C-load%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">Hibernate 中get 和 load的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate-%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88Hibernate-%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%89%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">Hibernate 的应用（Hibernate 的结构）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate-%E6%9C%89%E5%93%AA-5-%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">Hibernate 有哪 5 个核心接口？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-hibernate-%E4%B8%AD-getCurrentSession-%E5%92%8C-openSession-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hibernate-%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">hibernate 实体类必须要有无参构造函数吗？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hibernate-%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">hibernate 对象有哪些状态？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-hibernate-%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">说一下 hibernate 的缓存机制？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hibernate-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">hibernate 是如何工作的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hibernate-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">hibernate 有几种查询方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hibernate-%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9A%E4%B9%89%E4%B8%BA-final-%E5%90%97%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">hibernate 实体类可以被定义为 final 吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-hibernate-%E4%B8%AD%E4%BD%BF%E7%94%A8-Integer-%E5%92%8C-int-%E5%81%9A%E6%98%A0%E5%B0%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">在 hibernate 中使用 Integer 和 int 做映射有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jpa-%E5%92%8C-hibernate-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">jpa 和 hibernate 有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Hibernate-%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%EF%BC%8C%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E4%B8%8E-Session%E5%85%B3%E9%97%AD%E7%9A%84%E7%9F%9B%E7%9B%BE%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session关闭的矛盾是如何处理的？</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">63</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/b1378143ed59.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Hibernate | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Hibernate</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-02 14:48:16" itemprop="dateCreated datePublished" datetime="2024-01-02T14:48:16+08:00">2024-01-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 16:00:26" itemprop="dateModified" datetime="2024-01-04T16:00:26+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="介绍一下-Hibernate-的缓存"><a href="#介绍一下-Hibernate-的缓存" class="headerlink" title="介绍一下 Hibernate 的缓存"></a>介绍一下 Hibernate 的缓存</h1><h4 id="为什么要用-Hibernate-缓存？"><a href="#为什么要用-Hibernate-缓存？" class="headerlink" title="为什么要用 Hibernate 缓存？"></a>为什么要用 Hibernate 缓存？</h4><ul><li>Hibernate 是一种持久化层框架，经常访问物理数据库。</li><li>为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。</li><li>为了提高访问速度，把磁盘或者数据库访问变成内存访问</li></ul><h4 id="Hibernate-缓存原理是怎样的？"><a href="#Hibernate-缓存原理是怎样的？" class="headerlink" title="Hibernate 缓存原理是怎样的？"></a>Hibernate 缓存原理是怎样的？</h4><ul><li>Hibernate 缓存包括两大类：Hibernate一级缓存和 Hibernate 二级缓存</li></ul><h1 id="Hibernate-一级缓存又称为”session-的缓存”。"><a href="#Hibernate-一级缓存又称为”session-的缓存”。" class="headerlink" title="Hibernate 一级缓存又称为”session 的缓存”。"></a>Hibernate 一级缓存又称为”session 的缓存”。</h1><ul><li>session 缓存内置不能被卸载，session 的缓存是事务范围的缓存(session 对象的生命周期通常对应一个数据库事务或者一个应用事务)。</li><li>一级缓存中，持久化类的每个实例都具有唯一的 OID</li></ul><h1 id="Hibernate-的二级缓存又称为”sessionFactory-的缓存”。"><a href="#Hibernate-的二级缓存又称为”sessionFactory-的缓存”。" class="headerlink" title="Hibernate 的二级缓存又称为”sessionFactory 的缓存”。"></a>Hibernate 的二级缓存又称为”sessionFactory 的缓存”。</h1><ul><li>由于 sessionFactory 对象的生命周期和应用程序的整个过程对应，因此 Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。</li><li>第二级缓存是可选的，是一个可配置的插件，默认下 sessionFactory 不会启用这个插件。</li><li>什么样的数据适合存放到二级缓存中？<ul><li>很少被修改的数据 (帖子的最后回复时间)</li><li>经常被查询的数据 (电商的地点)</li><li>不是很重要的数据，允许出现偶尔并发的数据</li><li>不会被并发访问的数据</li><li>常量数据</li></ul></li><li>Hibernate 的二级缓存默认是不支持分布式缓存的，使用 memcache，redis等中央缓存来代替二级缓存</li></ul><h1 id="Hibernate-对象的状态"><a href="#Hibernate-对象的状态" class="headerlink" title="Hibernate 对象的状态"></a>Hibernate 对象的状态</h1><ul><li>临时状态&#x2F;瞬时状态(transient)：刚刚用 new 语句创建，没有被持久化，无 id，不处于 session 中(没有使用 session 的方法去操作临时对象)，该对象成为临时对象持久化状态，</li><li>托管状态(persistent)：已经被持久化，加入 session 的缓存中，session是没有关闭该状态的对象为持久化对象。</li><li>游离状态，脱管状态(detached)：已经被持久化，但不处于 session 中，该状态的对象为游离对象。</li><li>删除状态(removed)：对象有关联的 id，并且在 session 管理下，但是已经被计划(事务提交的时候，commit)删除，如果没有事务就不能删除相互转换</li></ul><h1 id="Session-的-save-、update-、merge-、lock-、saveOrUpdate-和-persist-方法有什么区别？"><a href="#Session-的-save-、update-、merge-、lock-、saveOrUpdate-和-persist-方法有什么区别？" class="headerlink" title="Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？"></a>Session 的 save()、update()、merge()、lock()、saveOrUpdate()和 persist()方法有什么区别？</h1><ul><li>Hibernate 的对象有三种状态：瞬态、持久态和游离态</li><li>游离状态的实例可以通过调用 save()、persist()或者 saveOrUpdate()方法进行持久化；脱管状态的实例可以通过调用 update()、0saveOrUpdate()、lock()或者 replicate()进行持久化</li><li>save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()或 merge()会引发 UPDATE 语句</li><li>save()和 update()的区别在于一个是将瞬态对象变成持久态，一个是将游离态对象变为持久态。</li><li>merge 方法可以完成 save()和 update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象</li><li>按照官方文档的说明<ul><li>persist()方法把一个瞬态的实例持久化，但是并”不保证”标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到 flush 的时间</li><li>persist”保证”，当它在一个事务外部被调用的时候并不触发一个 Insert 语句，当需要封装一个长会话流程的时候，一个 persist 这样的函数是需要的</li><li>save”不保证”第 2 条,它要返回标识符，所以它会立即执行 Insert 语句，不管是不是在事务内部还是外部</li><li>update()方法是把一个已经更改过的脱管状态的对象变成持久状态</li><li>lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。</li></ul></li></ul><h1 id="Session-的-load-和-get-方法的区别是什么？"><a href="#Session-的-load-和-get-方法的区别是什么？" class="headerlink" title="Session 的 load 和 get 方法的区别是什么？"></a>Session 的 load 和 get 方法的区别是什么？</h1><ul><li>主要有以下三项区别：<ul><li>如果没有找到符合条件的记录, get 方法返回 null,load 方法抛出异常</li><li>get 方法直接返回实体类对象, load 方法返回实体类对象的代理</li><li>在 Hibernate 3 之前，get 方法只在一级缓存(内部缓存)中进行数据查找, 如果没有找到对应的数据则越过二级缓存, 直接发出 SQL 语句完成数据读取; load 方法则可以充分利用二级缓存中的现有数据；当然从 Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的</li></ul></li><li>简单的说，对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过 get()方法去取的数据可以不存在。</li></ul><h1 id="SessionFactory-是线程安全的吗？Session-是线程安全的吗，两个线程能够共享同一个-Session-吗？"><a href="#SessionFactory-是线程安全的吗？Session-是线程安全的吗，两个线程能够共享同一个-Session-吗？" class="headerlink" title="SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？"></a>SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程能够共享同一个 Session 吗？</h1><ul><li>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将 SessionFactory 通过单例的模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。</li><li>Session 是由 SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的 session，可以使用 ThreadLocal 来取得当前的 session，无论你调用多少次 getCurrentSession()方法，返回的都是同一个 session。</li></ul><h1 id="Hibernate与JDBC的区别"><a href="#Hibernate与JDBC的区别" class="headerlink" title="Hibernate与JDBC的区别"></a>Hibernate与JDBC的区别</h1><ul><li>hibernate和jdbc主要区别就是，hibernate先检索缓存中的映射对象( 即hibernate操作的是对象)，而jdbc则是直接操作数据库.</li><li>Hibernate是JDBC的轻量级的对象封装，它是一个独立的对象持久层框架。Hibernate可以用在任何JDBC可以使用的场合</li><li>Hibernate是一个和JDBC密切关联的框架，所以Hibernate的兼容性和JDBC驱动，和数据库都有一定的关系，但是和使用它的Java程序，和App Server没有任何关系，也不存在兼容性问题。</li><li>如果正确的使用JDBC技术,它的执行效率一定比hibernate要好,因为hibernate是基于jdbc的技术.</li><li>JDBC使用的是SQL语句，Hibernate使用的是HQL语句，但是HQL语句最终还会隐式转换成SQL语句执行。</li></ul><h1 id="Hibernate中的两大配置文件"><a href="#Hibernate中的两大配置文件" class="headerlink" title="Hibernate中的两大配置文件"></a>Hibernate中的两大配置文件</h1><ul><li>*.hbm.xml：主键生成策略，映射关系，一对多，一对一的关系。</li><li>Hibernate.cfg.xml：方言(用哪个数据库)，数据库连接信息，包含*.hbm.xml内容，映射文件，也可以配事务。</li></ul><h1 id="Hibernate事务处理"><a href="#Hibernate事务处理" class="headerlink" title="Hibernate事务处理"></a>Hibernate事务处理</h1><ul><li>开启事务 session.beginTransaction();</li><li>执行相关的操作，如果成功则session.getTransaction().commit();</li><li>执行操作失败则 session.getTransaction.rollback();</li></ul><h1 id="Hibernate五大核心（类-接口）简述"><a href="#Hibernate五大核心（类-接口）简述" class="headerlink" title="Hibernate五大核心（类&#x2F;接口）简述"></a>Hibernate五大核心（类&#x2F;接口）简述</h1><ul><li>Configuration接口的作用是对Hibernate进行配置，以及对它进行启动。（加载 hibernate.cfg.xml）并创建一个SessionFactory对象。</li><li>SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建 Session对象。SessionFactory是线程安全的。</li><li>Session接口<ul><li>Session（会话）接口是Hibernate应用使用的主要接口。Session接口负责执行被持久化对象的CRUD操作(增删改查)。Session对象是非线程安全的。Session 相当于jdbc的connection</li></ul></li><li>Query与Criteria接口<ul><li>总之Query和Criteria接口负责执行各种数据库查询。</li></ul></li><li>Transaction接口<ul><li>Transaction（事务）负责操作相关的事务。</li></ul></li></ul><h1 id="Hibernate的运行原理"><a href="#Hibernate的运行原理" class="headerlink" title="Hibernate的运行原理"></a>Hibernate的运行原理</h1><ul><li>首先通过configuration去加载hibernate.cfg.xml这个配置文件，根据配置文件的信息去创建sessionFactory,sessionFactory是线程安全的，是一个session工厂，用来创建session,session是线程不安全的，相当于jdbc的connection，最后通过session去进行数据库的各种操作，在进行操作的时候通过transaction进行事务的控制。</li></ul><h1 id="Hibernate、Ibatis、Jdbc三者的区别"><a href="#Hibernate、Ibatis、Jdbc三者的区别" class="headerlink" title="Hibernate、Ibatis、Jdbc三者的区别"></a>Hibernate、Ibatis、Jdbc三者的区别</h1><ul><li>Hibernate属于全自动， Ibatis属于半自动，Jdbc属于手动，从开发效率上讲hibernate较高，ibatis居中，jdbc较低，从执行效率上讲hibernate较低，ibatis居中，jdbc较高，因为jdbc是手工写sql语句，程序员对sql的控制能力更大，可以根据业务需要进行优化，而ibatis虽然也可以对sql进行优化，但是他里面将resultset封装为实体的过程中采用了反射机制所以一定程度上影响了性能，而hibernate因为高度封装所以开发效率相对较高，但正因为这个原因，所以程序员在对sql语句的控制和优化方面相对比较弱，而且在将resultset封装成实体的过程中也采用了反射机制，所以在性能方面较低</li></ul><h1 id="Hibernate-中get-和-load的区别"><a href="#Hibernate-中get-和-load的区别" class="headerlink" title="Hibernate 中get 和 load的区别"></a>Hibernate 中get 和 load的区别</h1><ul><li>加载方式：<ul><li>load为延迟加载(返回的是一个只有id属性的代理,只有使用该对象属性时,才发出sql语句)；</li><li>get为立即加载(执行时,会立即向数据库发出sql语句)</li></ul></li><li>返回结果：<ul><li>load检索不到记录时,会抛ObjectNotFoundException异常</li><li>get检索不到记录时,会返回null</li></ul></li></ul><h1 id="Hibernate-的应用（Hibernate-的结构）？"><a href="#Hibernate-的应用（Hibernate-的结构）？" class="headerlink" title="Hibernate 的应用（Hibernate 的结构）？"></a>Hibernate 的应用（Hibernate 的结构）？</h1><ul><li>首先获得 SessionFactory 的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>().configure().buildSessionFactory();</span><br><span class="line"><span class="comment">//然后获得 session 的对象</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"><span class="comment">//其次获得 Transaction 的对象</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"><span class="comment">//执行相关的数据库操作:增,删,改,查</span></span><br><span class="line">session.save(user); <span class="comment">//增加, user 是 User 类的对象</span></span><br><span class="line">session.delete(user); <span class="comment">//删除</span></span><br><span class="line">session.update(user); <span class="comment">//更新</span></span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(“from User”); <span class="comment">//查询</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">tx.commit();</span><br><span class="line"><span class="comment">//如果有异常,我们还要作事务的回滚,恢复到操作之前</span></span><br><span class="line">tx.rollback();</span><br><span class="line"><span class="comment">//最后还要关闭 session,释放资源</span></span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h1 id="Hibernate-有哪-5-个核心接口？"><a href="#Hibernate-有哪-5-个核心接口？" class="headerlink" title="Hibernate 有哪 5 个核心接口？"></a>Hibernate 有哪 5 个核心接口？</h1><ul><li>Configuration 接口：配置 Hibernate，根据其启动 hibernate，创建 SessionFactory 对象；</li><li>SessionFactory 接口：初始化 Hibernate，充当数据存储源的代理，创建 session 对象，sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级、二级缓存；</li><li>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个线程共享同一个 session，是轻量级、一级缓存；</li><li>Transaction 接口：管理事务；</li><li>Query 和 Criteria 接口：执行数据库的查询。</li></ul><h1 id="在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h1><ul><li>getCurrentSession 会绑定当前线程，而 openSession 则不会。</li><li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</li></ul><h1 id="hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="hibernate 实体类必须要有无参构造函数吗？为什么？"></a>hibernate 实体类必须要有无参构造函数吗？为什么？</h1><ul><li>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</li></ul><h1 id="hibernate-对象有哪些状态？"><a href="#hibernate-对象有哪些状态？" class="headerlink" title="hibernate 对象有哪些状态？"></a>hibernate 对象有哪些状态？</h1><ul><li>临时&#x2F;瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</li><li>持久化状态：当调用 Session 的 save&#x2F;saveOrupdate&#x2F;get&#x2F;load&#x2F;list 等方法的时候，对象就是持久化状态。</li><li>游离状态：Session 关闭之后对象就是游离状态。</li></ul><h1 id="说一下-hibernate-的缓存机制？"><a href="#说一下-hibernate-的缓存机制？" class="headerlink" title="说一下 hibernate 的缓存机制？"></a>说一下 hibernate 的缓存机制？</h1><ul><li>hibernate 常用的缓存有一级缓存和二级缓存：<ul><li>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</li><li>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</li></ul></li></ul><h1 id="hibernate-是如何工作的？"><a href="#hibernate-是如何工作的？" class="headerlink" title="hibernate 是如何工作的？"></a>hibernate 是如何工作的？</h1><ul><li>读取并解析配置文件。</li><li>读取并解析映射文件，创建 SessionFactory。</li><li>打开 Session。</li><li>创建事务。</li><li>进行持久化操作。</li><li>提交事务。</li><li>关闭 Session。</li><li>关闭 SessionFactory。</li></ul><h1 id="hibernate-有几种查询方式？"><a href="#hibernate-有几种查询方式？" class="headerlink" title="hibernate 有几种查询方式？"></a>hibernate 有几种查询方式？</h1><ul><li>三种：hql、原生 SQL、条件查询 Criteria。</li></ul><h1 id="hibernate-实体类可以被定义为-final-吗？"><a href="#hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="hibernate 实体类可以被定义为 final 吗？"></a>hibernate 实体类可以被定义为 final 吗？</h1><ul><li>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</li></ul><h1 id="在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h1><ul><li>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</li></ul><h1 id="jpa-和-hibernate-有什么区别？"><a href="#jpa-和-hibernate-有什么区别？" class="headerlink" title="jpa 和 hibernate 有什么区别？"></a>jpa 和 hibernate 有什么区别？</h1><ul><li>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</li></ul><h1 id="如何理解-Hibernate-的延迟加载机制？在实际应用中，延迟加载与-Session关闭的矛盾是如何处理的？"><a href="#如何理解-Hibernate-的延迟加载机制？在实际应用中，延迟加载与-Session关闭的矛盾是如何处理的？" class="headerlink" title="如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session关闭的矛盾是如何处理的？"></a>如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session关闭的矛盾是如何处理的？</h1><ul><li>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。</li><li>延迟加载与 session 关闭的矛盾一般可以这样处理：<ul><li>关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session orsession was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。</li><li>在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize()方法加载对象。</li><li>使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。</li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Hibernate/" rel="tag"><i class="fa fa-tag"></i> Hibernate</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/fec4be92fa21.html" rel="prev" title="架构"><i class="fa fa-angle-left"></i> 架构</a></div><div class="post-nav-item"><a href="/publishes/c96491b71c82.html" rel="next" title="Maven">Maven <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">453k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:52</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>