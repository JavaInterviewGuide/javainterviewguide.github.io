<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="⼯⼚⽅法模式 利⽤创建同⼀接⼝的不同实例  普通⼯⼚模式 建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；123456789101112public class SendFactory &#123;    public Sender produce(String type) &#123;        if (&quot;mail&quot;.equals(type)) &#123;"><meta property="og:type" content="article"><meta property="og:title" content="设计模式"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/4f75e46c0d1c.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="⼯⼚⽅法模式 利⽤创建同⼀接⼝的不同实例  普通⼯⼚模式 建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；123456789101112public class SendFactory &#123;    public Sender produce(String type) &#123;        if (&quot;mail&quot;.equals(type)) &#123;"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T08:17:58.000Z"><meta property="article:modified_time" content="2023-12-25T05:49:27.551Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="设计模式"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/4f75e46c0d1c.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/4f75e46c0d1c.html","path":"publishes/4f75e46c0d1c.html","title":"设计模式"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>设计模式 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BC%AF%E2%BC%9A%E2%BD%85%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">⼯⼚⽅法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E2%BC%AF%E2%BC%9A%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">普通⼯⼚模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E2%BC%AF%E2%BC%9A%E2%BD%85%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">多个⼯⼚⽅法模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E2%BC%AF%E2%BC%9A%E2%BD%85%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">静态⼯⼚⽅法模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E2%BD%A4%E5%9C%BA%E6%99%AF"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">适⽤场景</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E2%BC%AF%E2%BC%9A%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">抽象⼯⼚模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E2%BD%A4%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">适⽤场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">饿汉式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">懒汉式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81"><span class="nav-number">3.0.0.4.</span> <span class="nav-text">双重检验锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E2%BD%85%E5%BC%8F"><span class="nav-number">3.0.0.5.</span> <span class="nav-text">静态内部类⽅式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">3.0.0.6.</span> <span class="nav-text">枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">原型模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E2%BD%A4%E5%9C%BA%E6%99%AF"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">使⽤场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">装饰模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E2%BD%A4%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">使⽤场景：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">外观模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">组合模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">享元模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">12.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E2%BD%85%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">模板⽅法模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">14.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">迭代器模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">责任链模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">17.</span> <span class="nav-text">命令模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">18.</span> <span class="nav-text">备忘录模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">19.</span> <span class="nav-text">状态模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">20.</span> <span class="nav-text">访问者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">21.</span> <span class="nav-text">中介者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">22.</span> <span class="nav-text">解释器模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">23.</span> <span class="nav-text">建造者模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E2%BC%A4%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">24.</span> <span class="nav-text">设计模式的六⼤原则：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Close-Principle%EF%BC%89"><span class="nav-number">24.0.0.1.</span> <span class="nav-text">开闭原则（Open Close Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%BE%A5%E2%BD%92%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle-LSP%EF%BC%89"><span class="nav-number">24.0.0.2.</span> <span class="nav-text">⾥⽒代换原则（Liskov Substitution Principle LSP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%EF%BC%88Dependence-Inversion-Principle%EF%BC%89"><span class="nav-number">24.0.0.3.</span> <span class="nav-text">依赖倒转原则（Dependence Inversion Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E2%BC%9D%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88Interface-Segregation-Principle%EF%BC%89"><span class="nav-number">24.0.0.4.</span> <span class="nav-text">接⼝隔离原则（Interface Segregation Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AA%E2%BD%B6%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88%E6%9C%80%E5%B0%91%E7%9F%A5%E9%81%93%E5%8E%9F%E5%88%99%EF%BC%89%EF%BC%88Demeter-Principle%EF%BC%89"><span class="nav-number">24.0.0.5.</span> <span class="nav-text">迪⽶特法则（最少知道原则）（Demeter Principle）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E2%BD%A4%E5%8E%9F%E5%88%99%EF%BC%88Composite-Reuse-Principle%EF%BC%89"><span class="nav-number">24.0.0.6.</span> <span class="nav-text">合成复⽤原则（Composite Reuse Principle）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jdk-%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">25.</span> <span class="nav-text">jdk 中的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">25.0.0.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">25.0.0.2.</span> <span class="nav-text">责任链模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">25.0.0.3.</span> <span class="nav-text">观察者模式：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">26.</span> <span class="nav-text">spring 中的设计模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E2%BC%AF%E2%BC%9A"><span class="nav-number">26.0.0.1.</span> <span class="nav-text">简单⼯⼚</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">27.</span> <span class="nav-text">什么是设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">使用工厂模式最主要的好处是什么？在哪里使用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BE%E4%B8%80%E4%B8%AA%E7%94%A8-Java-%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-decorator-design-pattern-%EF%BC%9F%E5%AE%83%E6%98%AF%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%B1%82%E6%AC%A1%E8%BF%98%E6%98%AF%E7%B1%BB%E5%B1%82%E6%AC%A1%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">28</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">47</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/4f75e46c0d1c.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="设计模式 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">设计模式</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:17:58" itemprop="dateCreated datePublished" datetime="2023-12-20T16:17:58+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-25 13:49:27" itemprop="dateModified" datetime="2023-12-25T13:49:27+08:00">2023-12-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="⼯⼚⽅法模式"><a href="#⼯⼚⽅法模式" class="headerlink" title="⼯⼚⽅法模式"></a>⼯⼚⽅法模式</h1><ul><li>利⽤创建同⼀接⼝的不同实例</li></ul><h4 id="普通⼯⼚模式"><a href="#普通⼯⼚模式" class="headerlink" title="普通⼯⼚模式"></a>普通⼯⼚模式</h4><ul><li>建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SendFactory &#123;</span><br><span class="line">    public Sender produce(String type) &#123;</span><br><span class="line">        if (&quot;mail&quot;.equals(type)) &#123;</span><br><span class="line">            return new MailSender();</span><br><span class="line">        &#125; else if (&quot;sms&quot;.equals(type)) &#123;</span><br><span class="line">            return new SmsSender();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;请输⼊正确的类型!&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多个⼯⼚⽅法模式"><a href="#多个⼯⼚⽅法模式" class="headerlink" title="多个⼯⼚⽅法模式"></a>多个⼯⼚⽅法模式</h4><ul><li>提供多个⼯⼚⽅法，分别创建对象；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SendFactory &#123;</span><br><span class="line">    public Sender produceMail()&#123;</span><br><span class="line">        return new MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">    public Sender produceSms()&#123;</span><br><span class="line">        return new SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="静态⼯⼚⽅法模式"><a href="#静态⼯⼚⽅法模式" class="headerlink" title="静态⼯⼚⽅法模式"></a>静态⼯⼚⽅法模式</h4><ul><li>将上⾯的多个⼯⼚⽅法置为静态的，不需要创建⼯⼚实例，直接调⽤即可；</li></ul><h4 id="适⽤场景"><a href="#适⽤场景" class="headerlink" title="适⽤场景"></a>适⽤场景</h4><ul><li>凡是出现了⼤量不同种类的产品需要创建，并且具有共同的接⼝时，可以通过⼯⼚⽅法模式进⾏创建</li><li>在以上的三种模式中，第⼀种如果传⼊的字符串有误，不能正确创建对象，第三种相对于第⼆种，不需要实例化⼯⼚类，所以，⼤多数情况下，我们会选⽤第三种——静态⼯⼚⽅法模式。</li></ul><h1 id="抽象⼯⼚模式"><a href="#抽象⼯⼚模式" class="headerlink" title="抽象⼯⼚模式"></a>抽象⼯⼚模式</h1><ul><li>多个⼯⼚</li><li>创建多个⼯⼚类，提⾼⼯⼚的扩展性，不⽤像上⾯⼀样如果增加产品则要去修改唯⼀的⼯⼚类；</li></ul><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul><li>保证对象只有⼀个实例</li><li>保证在⼀个 JVM 中，该对象只有⼀个实例存在；</li></ul><h4 id="适⽤场景："><a href="#适⽤场景：" class="headerlink" title="适⽤场景："></a>适⽤场景：</h4><ul><li>某些类创建⽐较频繁，对于⼀些⼤型的对象，这是⼀笔很⼤的系统开销。</li><li>省去了 new 操作符，降低了系统内存的使⽤频率，减轻 GC 压⼒。</li><li>有些类如交易所的核⼼交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。所以只有使⽤单例模式，才能保证核⼼交易服务器独⽴控制整个流程。</li></ul><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul><li>类初始化时创建单例，线程安全，适⽤于单例占内存⼩的场景，否则推荐使⽤懒汉式延迟加载；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton newInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul><li>需要创建单例实例的时候再创建，需要考虑线程安全(性能不太好)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static synchronized Singleton newInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h4><ul><li>效率⾼</li><li>解决问题：假如两个线程 A、B，A 执⾏了 if (instance &#x3D;&#x3D; null)语句，它会认为单例对象没有创建，此时线程切到 B 也执⾏了同样的语句，B 也认为单例对象没有创建，然后两个线程依次执⾏同步代码块，并分别创建了⼀个单例对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance = null;//volatile 的⼀个语义是禁⽌指令重排序优化</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;//2</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="静态内部类⽅式"><a href="#静态内部类⽅式" class="headerlink" title="静态内部类⽅式"></a>静态内部类⽅式</h4><ul><li>可以同时保证延迟加载和线程安全<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        public static Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton newInstance()&#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ul><li>使⽤枚举除了线程安全和防⽌反射调⽤构造器之外，还提供了⾃动序列化机制，防⽌反序列化的时候创建新的对象。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    instance;</span><br><span class="line">    public void whateverMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><ul><li>将⼀个对象作为原型，对其进⾏复制、克隆，产⽣⼀个和元对象类似的新对象；</li><li>核⼼：它的核⼼是原型类 Prototype，需要实现 Cloneable 接⼝，和重写 Object 类中的 clone ⽅法；</li><li>作⽤：使⽤原型模式创建对象⽐直接 new ⼀个对象在性能上要好的多，因为 Object 类的 clone ⽅法是⼀个本地⽅法，它直接操作内存<br>中的⼆进制流，特别是复制⼤对象时，性能的差别⾮常明显。</li></ul><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><ul><li>接⼝兼容</li><li>将某个类的接⼝转换成客户端期望的另⼀个接⼝表示，⽬的是消除由于接⼝不匹配所造成的类的兼容性问题。</li><li>类的适配器模式</li><li>对象的适配器模式</li><li>接⼝的适配器模式</li></ul><h4 id="使⽤场景"><a href="#使⽤场景" class="headerlink" title="使⽤场景"></a>使⽤场景</h4><ul><li>类的适配器模式：当希望将⼀个类转换成满⾜另⼀个新接⼝的类时，可以使⽤类的适配器模式，创建⼀个新类，继承原有的类，<br>实现新的接⼝即可。</li><li>对象的适配器模式：当希望将⼀个对象转换成满⾜另⼀个新接⼝的对象时，可以创建⼀个 Wrapper 类，持有原类的⼀个实例，在<br>Wrapper 类的⽅法中，调⽤实例的⽅法就⾏。</li><li>接⼝的适配器模式：当不希望实现⼀个接⼝中所有的⽅法时，可以创建⼀个抽象类 Wrapper，实现所有⽅法，我们写别的类的时<br>候，继承抽象类即可。</li></ul><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><ul><li>装饰模式就是给⼀个对象增加⼀些新的功能，⽽且是动态的，要求装饰对象和被装饰对象实现同⼀个接⼝，装饰对象持有被装饰对象的实例：</li></ul><h4 id="使⽤场景："><a href="#使⽤场景：" class="headerlink" title="使⽤场景："></a>使⽤场景：</h4><ul><li>需要扩展⼀个类的功能</li><li>动态的为⼀个对象增加功能，⽽且还能动态撤销。（继承不能做到这⼀点，继承的功能是静态的，不能动态增删。）</li></ul><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><ul><li>持有被代理类的实例，进⾏操作前后控制</li><li>采⽤⼀个代理类调⽤原有的⽅法，且对产⽣的结果进⾏控制。</li></ul><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><ul><li>集合所有操作到⼀个类</li><li>外观模式是为了解决类与类之间的依赖关系的，像 spring ⼀样，可以将类和类之间的关系配置到配置⽂件中</li><li>⽽外观模式就是将他们的关系放在⼀个 Facade 类中，降低了类类之间的耦合度。</li></ul><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><ul><li>数据库驱动桥接</li><li>桥接模式就是把事物和其具体实现分开，使他们可以各⾃独⽴的变化</li><li>桥接的⽤意是：将抽象化与实现化解耦，使得⼆者可以独⽴变化，像我们常⽤的 JDBC 桥 DriverManager ⼀样，JDBC 进⾏连接数据库的时候，在各个数据库之间进⾏切换，基本不需要动太多的代码，甚⾄丝毫不⽤动，原因就是 JDBC 提供统⼀接⼝，每个数据库提供各⾃的实现，⽤⼀个叫做数据库驱动的程序来桥接就⾏了。</li></ul><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><ul><li>部分整体模式</li><li>组合模式有时⼜叫部分-整体模式在处理类似树形结构的问题时⽐较⽅便。</li></ul><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><ul><li>共享池、数据库连接池</li><li>享元模式的主要⽬的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与⼯⼚模式⼀起使⽤</li><li>当⼀个客户端请求时，⼯⼚需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建⼀个新对象，如数据库连接池；</li></ul><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><ul><li>多种算法封装</li><li>策略模式定义了⼀系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使⽤算法的客户</li><li>需要设计⼀个接⼝，为⼀系列实现类提供统⼀的⽅法，多个实现类实现该接⼝：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ICalculator cal = new Plus(); //ICalculator 是统⼀接⼝，Plus 是实现类(多个)</span><br><span class="line">int result = cal.calculate(exp); //jvm 根据实现类不同⽽调⽤不同实现类的⽅法</span><br></pre></td></tr></table></figure></li></ul><h1 id="模板⽅法模式"><a href="#模板⽅法模式" class="headerlink" title="模板⽅法模式"></a>模板⽅法模式</h1><ul><li>抽象⽅法作为⻣架，具体逻辑让⼦类实现</li><li>定义⼀个操作中算法的框架，⽽将⼀些步骤延迟到⼦类中，使得⼦类可以不改变算法的结构即可重定义该算法中的某些特定步骤</li><li>完成公共动作和特殊动作的分离。</li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><ul><li>发布-订阅模式</li><li>当⼀个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是⼀种⼀对多的关系</li><li>类似于邮件订阅和 RSS 订阅，当你订阅了该⽂章，如果后续有更新，会及时通知你。</li></ul><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><ul><li>遍历集合</li><li>迭代器模式就是顺序访问聚集中的对象</li></ul><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><ul><li>多任务形成⼀条链，请求在链上传递</li><li>有多个对象，每个对象持有对下⼀个对象的引⽤，这样就会形成⼀条链，请求在这条链上传递，直到某⼀对象决定处理该请求</li><li>但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进⾏动态的调整。</li></ul><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><ul><li>实现请求和执⾏的解耦</li><li>命令模式的⽬的就是达到命令的发出者和执⾏者之间解耦，实现请求和执⾏分开，熟悉 Struts 的同学应该知道，Struts 其实就是⼀种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</li></ul><h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><ul><li>保存和恢复对象状态</li><li>主要⽬的是保存⼀个对象的某个状态，以便在适当的时候恢复对象</li></ul><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><ul><li>对象状态改变时改变其⾏为</li><li>当对象的状态改变时，同时改变其⾏为</li><li>状态模式就两点<ul><li>可以通过改变状态来获得不同的⾏为</li><li>你的好友能同时看到你的变化</li></ul></li></ul><h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><ul><li>数据接⼝稳定，但算法易变</li><li>访问者模式把数据结构和作⽤于结构上的操作解耦合，使得操作集合可相对⾃由地演化</li><li>访问者模式适⽤于数据结构相对稳定算法⼜易变化的系统</li><li>因为访问者模式使得算法操作增加变得容易</li><li>访问者模式就是⼀种分离对象数据结构与⾏为的⽅法，通过这种分离，可达到为⼀个被访问者动态添加新的操作⽽⽆需做其它的修改的效果</li></ul><h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><ul><li>中介者模式也是⽤来降低类类之间的耦合的</li><li>如果使⽤中介者模式，只需关⼼和 Mediator 类的关系</li><li>具体类类之间的关系及调度交给 Mediator 就⾏，这有点像 spring 容器的作⽤。</li></ul><h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><ul><li>对于⼀些固定⽂法构建⼀个解释句⼦的解释器，如正则表达式</li><li>解释器模式⽤来做各种各样的解释器，如正则表达式等的解释器。</li></ul><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><ul><li>创建复合对象</li><li>⼯⼚类模式提供的是创建单个类的模式，⽽建造者模式则是将各种产品集中起来进⾏管理，⽤来创建复合对象，所谓复合对象就是指某个类具有不同的属性</li></ul><h1 id="设计模式的六⼤原则："><a href="#设计模式的六⼤原则：" class="headerlink" title="设计模式的六⼤原则："></a>设计模式的六⼤原则：</h1><h4 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h4><ul><li>开闭原则就是说对扩展开放，对修改关闭</li><li>在程序需要进⾏拓展的时候，不能去修改原有的代码，实现⼀个热插拔的效果。</li><li>所以⼀句话概括就是：为了使程序的扩展性好，易于维护和升级</li><li>想要达到这样的效果，我们需要使⽤接⼝和抽象类，后⾯的具体设计中我们会提到这点。</li></ul><h4 id="⾥⽒代换原则（Liskov-Substitution-Principle-LSP）"><a href="#⾥⽒代换原则（Liskov-Substitution-Principle-LSP）" class="headerlink" title="⾥⽒代换原则（Liskov Substitution Principle LSP）"></a>⾥⽒代换原则（Liskov Substitution Principle LSP）</h4><ul><li>⾥⽒代换原则⾯向对象设计的基本原则之⼀</li><li>⾥⽒代换原则中说，任何基类可以出现的地⽅，⼦类⼀定可以出现</li><li>LSP 是继承复⽤的基⽯，只有当衍⽣类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复⽤，⽽衍⽣类也能够在基类的基础上增加新的⾏为</li><li>⾥⽒代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化</li><li>⽽基类与⼦类的继承关系就是抽象化的具体实现，所以⾥⽒代换原则是对实现抽象化的具体步骤的规范</li></ul><h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul><li>这个是开闭原则的基础，具体内容：真对接⼝编程，依赖于抽象⽽不依赖于具体。</li></ul><h4 id="接⼝隔离原则（Interface-Segregation-Principle）"><a href="#接⼝隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接⼝隔离原则（Interface Segregation Principle）"></a>接⼝隔离原则（Interface Segregation Principle）</h4><ul><li>使⽤多个隔离的接⼝，⽐使⽤单个接⼝要好</li><li>还是⼀个降低类之间的耦合度的意思</li><li>从这⼉我们看出，其实设计模式就是⼀个软件的设计思想，从⼤型软件架构出发，为了升级和维护⽅便</li><li>所以上⽂中多次出现：降低依赖，降低耦合。</li></ul><h4 id="迪⽶特法则（最少知道原则）（Demeter-Principle）"><a href="#迪⽶特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪⽶特法则（最少知道原则）（Demeter Principle）"></a>迪⽶特法则（最少知道原则）（Demeter Principle）</h4><ul><li>为什么叫最少知道原则，就是说：⼀个实体应当尽量少的与其他实体之间发⽣相互作⽤，使得系统功能模块相对独⽴。</li></ul><h4 id="合成复⽤原则（Composite-Reuse-Principle）"><a href="#合成复⽤原则（Composite-Reuse-Principle）" class="headerlink" title="合成复⽤原则（Composite Reuse Principle）"></a>合成复⽤原则（Composite Reuse Principle）</h4><ul><li>原则是尽量使⽤合成&#x2F;聚合的⽅式，⽽不是使⽤继承</li></ul><h1 id="jdk-中的设计模式"><a href="#jdk-中的设计模式" class="headerlink" title="jdk 中的设计模式"></a>jdk 中的设计模式</h1><h4 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li>java.lang.Runtime#getRuntime()</li><li>java.awt.Desktop#getDesktop()</li><li>java.lang.System#getSecurityManager()</li></ul><h4 id="责任链模式-1"><a href="#责任链模式-1" class="headerlink" title="责任链模式"></a>责任链模式</h4><ul><li>java.util.logging.Logger#log()</li><li>javax.servlet.Filter#doFilter()</li></ul><h4 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h4><ul><li>java.util.Observer&#x2F; java.util.Observable（很少在现实世界中使⽤）</li><li>所有实现 java.util.EventListener（因此实际上各地的 Swing）</li><li>javax.servlet.http.HttpSessionBindingListener</li><li>javax.servlet.http.HttpSessionAttributeListener</li><li>javax.faces.event.PhaseListener</li></ul><h1 id="spring-中的设计模式："><a href="#spring-中的设计模式：" class="headerlink" title="spring 中的设计模式："></a>spring 中的设计模式：</h1><h4 id="简单⼯⼚"><a href="#简单⼯⼚" class="headerlink" title="简单⼯⼚"></a>简单⼯⼚</h4><ul><li>spring 中的 BeanFactory 就是简单⼯⼚模式的体现，根据传⼊⼀个唯⼀的标识来获得 bean 对象，但是否是在传⼊ 参数后创建还是传⼊参数前创建这个要根据具体情况来定。</li><li>单例模式：Spring 下默认的 bean 均为 singleton。</li><li>代理模式：为其他对象提供⼀种代理以控制对这个对象的访问。 从结构上来看和 Decorator 模式类似，但 Proxy 是控制，更像 是⼀种对功能的限制，⽽ Decorator 是增加职责。 spring 的 Proxy 模式在 aop 中有体现，⽐如 JdkDynamicAopProxy 和 Cglib2AopProxy。</li><li>观察者模式：定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发⽣改变时，所有依赖于它的对象都得到通知并被⾃动更新。spring 中 Observer 模式常⽤的地⽅是 listener 的实现。如 ApplicationListener。</li></ul><h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><ul><li>设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法</li><li>设计模式是代码可用性的延伸</li></ul><h1 id="使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="使用工厂模式最主要的好处是什么？在哪里使用？"></a>使用工厂模式最主要的好处是什么？在哪里使用？</h1><ul><li>工厂模式的最大好处是增加了创建对象时的封装层次</li><li>如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。</li></ul><h1 id="举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？"><a href="#举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？" class="headerlink" title="举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？"></a>举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</h1><ul><li>装饰模式增加强了单个对象的能力</li><li>Java IO 到处都使用了装饰模式，典型例子就是 Buffered 系列类如 BufferedReader 和 BufferedWriter，它们增强了 Reader 和 Writer 对象，以实现提升性能的 Buffer 层次的读取和写入。</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 设计模式</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/372274a5b315.html" rel="prev" title="搜索引擎"><i class="fa fa-angle-left"></i> 搜索引擎</a></div><div class="post-nav-item"><a href="/publishes/554d7a59d68c.html" rel="next" title="Zookeeper">Zookeeper <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">2.6m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">39:05</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>