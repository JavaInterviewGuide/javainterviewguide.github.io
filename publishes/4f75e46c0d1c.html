<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="1、⼯⼚⽅法模式(利⽤创建同⼀接⼝的不同实例)： 1、普通⼯⼚模式：建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；1 public class SendFactory {23 public Sender produce(String type) {4 if (“mail”.equals(type)) {5 return new MailSender();6 } else if (“sms"><meta property="og:type" content="article"><meta property="og:title" content="设计模式"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/4f75e46c0d1c.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="1、⼯⼚⽅法模式(利⽤创建同⼀接⼝的不同实例)： 1、普通⼯⼚模式：建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；1 public class SendFactory {23 public Sender produce(String type) {4 if (“mail”.equals(type)) {5 return new MailSender();6 } else if (“sms"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T08:17:58.000Z"><meta property="article:modified_time" content="2023-12-20T08:18:19.565Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="设计模式"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/4f75e46c0d1c.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/4f75e46c0d1c.html","path":"publishes/4f75e46c0d1c.html","title":"设计模式"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>设计模式 | Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java后端面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">44</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/4f75e46c0d1c.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="设计模式 | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">设计模式</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:17:58 / 修改时间：16:18:19" itemprop="dateCreated datePublished" datetime="2023-12-20T16:17:58+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>1、⼯⼚⽅法模式(利⽤创建同⼀接⼝的不同实例)：<br>1、普通⼯⼚模式：建⽴⼀个⼯⼚类，对实现了同⼀接⼝的⼀些类进⾏实例的创建；<br>1 public class SendFactory {<br>2<br>3 public Sender produce(String type) {<br>4 if (“mail”.equals(type)) {<br>5 return new MailSender();<br>6 } else if (“sms”.equals(type)) {<br>7 return new SmsSender();<br>8 } else {<br>9 System.out.println(“请输⼊正确的类型!”);<br>10 return null;<br>11 }<br>12 }<br>13 }<br>2、多个⼯⼚⽅法模式：提供多个⼯⼚⽅法，分别创建对象；<br>1 public class SendFactory {<br>2<br>3 public Sender produceMail(){<br>4 return new MailSender();<br>5 }<br>6<br>7 public Sender produceSms(){<br>8 return new SmsSender();<br>9 }<br>10 }<br>3、静态⼯⼚⽅法模式：将上⾯的多个⼯⼚⽅法置为静态的，不需要创建⼯⼚实例，直接调⽤即可；<br>4、适⽤场景：凡是出现了⼤量不同种类的产品需要创建，并且具有共同的接⼝时，可以通过⼯⼚⽅法模式进⾏创建。在以上的三种模式<br>中，第⼀种如果传⼊的字符串有误，不能正确创建对象，第三种相对于第⼆种，不需要实例化⼯⼚类，所以，⼤多数情况下，我们会选⽤第三种——静<br>态⼯⼚⽅法模式。<br>2、抽象⼯⼚模式(多个⼯⼚)：创建多个⼯⼚类，提⾼⼯⼚的扩展性，不⽤像上⾯⼀样如果增加产品则要去修改唯⼀的⼯⼚类；<br>3、单例模式(保证对象只有⼀个实例)：保证在⼀个JVM中，该对象只有⼀个实例存在；<br>1、适⽤场景：<br>1、某些类创建⽐较频繁，对于⼀些⼤型的对象，这是⼀笔很⼤的系统开销。<br>2、省去了new操作符，降低了系统内存的使⽤频率，减轻GC压⼒。<br>3、有些类如交易所的核⼼交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（⽐如⼀个军队出现了多个司<br>令员同时指挥，肯定会乱成⼀团），所以只有使⽤单例模式，才能保证核⼼交易服务器独⽴控制整个流程。<br>2、代码：<br>1 public class Singleton {<br>2<br>3 /* 持有私有静态实例，防⽌被引⽤，此处赋值为null，⽬的是实现延迟加载 <em>/<br>4 private static Singleton instance = null;<br>5<br>6 /</em> 私有构造⽅法，防⽌被实例化 <em>/<br>7 private Singleton() {<br>8 }<br>9<br>10 /</em> 静态⼯程⽅法，创建实例 <em>/<br>11 public static Singleton getInstance() {<br>12 if (instance == null) {<br>13 instance = new Singleton();<br>14 }<br>15 return instance;<br>16 }<br>17<br>18 /</em> 如果该对象被⽤于序列化，可以保证对象在序列化前后保持⼀致 */<br>19 public Object readResolve() {<br>20 return instance;<br>21 }<br>22 }<br>3、分类：<br>1、饿汉式：类初始化时创建单例，线程安全，适⽤于单例占内存⼩的场景，否则推荐使⽤懒汉式延迟加载；<br>1 public class Singleton{<br>2 private static Singleton instance = new Singleton();<br>3 private Singleton(){}<br>4 public static Singleton newInstance(){<br>5 return instance;<br>6 }<br>7 }<br>2、懒汉式：需要创建单例实例的时候再创建，需要考虑线程安全(性能不太好)：<br>1 public class Singleton{<br>2 private static Singleton instance = null;<br>3 private Singleton(){}<br>4 public static synchronized Singleton newInstance(){<br>5 if(null == instance){<br>6 instance = new Singleton();<br>7 }<br>8 return instance;<br>9 }<br>10 }<br>3、双重检验锁：效率⾼；(解决问题：假如两个线程A、B，A执⾏了if (instance == null)语句，它会认为单例对象没有创建，此时线程切到B也<br>执⾏了同样的语句，B也认为单例对象没有创建，然后两个线程依次执⾏同步代码块，并分别创建了⼀个单例对象。)<br>1 public class Singleton {<br>2 private static volatile Singleton instance = null;//volatile的⼀个语义是禁⽌指令重排序优化<br>3 private Singleton(){}<br>4 public static Singleton getInstance() {<br>5 if (instance == null) {<br>6 synchronized (Singleton.class) {<br>7 if (instance == null) {//2<br>8 instance = new Singleton();<br>9 }<br>10 }<br>11 }<br>12 return instance;<br>13 }<br>14 }<br>4、静态内部类⽅式：可以同时保证延迟加载和线程安全。<br>1 public class Singleton{<br>2 private static class SingletonHolder{<br>3 public static Singleton instance = new Singleton();<br>4 }<br>5 private Singleton(){}<br>6 public static Singleton newInstance(){<br>7 return SingletonHolder.instance;<br>8 }<br>9 }<br>5、枚举：使⽤枚举除了线程安全和防⽌反射调⽤构造器之外，还提供了⾃动序列化机制，防⽌反序列化的时候创建新的对象。<br>1 public enum Singleton{<br>2 instance;<br>3 public void whateverMethod(){}<br>4 }<br>4、原型模式(对⼀个原型对象进⾏复制、克隆产⽣类似新对象)：将⼀个对象作为原型，对其进⾏复制、克隆，产⽣⼀个和元对象类似的新对<br>象；<br>1、核⼼：它的核⼼是原型类Prototype，需要实现Cloneable接⼝，和重写Object类中的clone⽅法；<br>2、作⽤：使⽤原型模式创建对象⽐直接new⼀个对象在性能上要好的多，因为Object类的clone⽅法是⼀个本地⽅法，它直接操作内存<br>中的⼆进制流，特别是复制⼤对象时，性能的差别⾮常明显。<br>5、适配器模式(接⼝兼容)：将某个类的接⼝转换成客户端期望的另⼀个接⼝表示，⽬的是消除由于接⼝不匹配所造成的类的兼容性问题。<br>1、类的适配器模式：<br>2、对象的适配器模式：</p><p>3、接⼝的适配器模式：</p><p>4、使⽤场景：<br>1、类的适配器模式：当希望将⼀个类转换成满⾜另⼀个新接⼝的类时，可以使⽤类的适配器模式，创建⼀个新类，继承原有的类，<br>实现新的接⼝即可。<br>2、对象的适配器模式：当希望将⼀个对象转换成满⾜另⼀个新接⼝的对象时，可以创建⼀个Wrapper类，持有原类的⼀个实例，在<br>Wrapper类的⽅法中，调⽤实例的⽅法就⾏。<br>3、接⼝的适配器模式：当不希望实现⼀个接⼝中所有的⽅法时，可以创建⼀个抽象类Wrapper，实现所有⽅法，我们写别的类的时<br>候，继承抽象类即可。<br>6、装饰模式(给对象动态增加新功能，需持有对象实例)：装饰模式就是给⼀个对象增加⼀些新的功能，⽽且是动态的，要求装饰对象和被装<br>饰对象实现同⼀个接⼝，装饰对象持有被装饰对象的实例：<br>1、示例：</p><p>2、使⽤场景：<br>1、需要扩展⼀个类的功能。<br>2、动态的为⼀个对象增加功能，⽽且还能动态撤销。（继承不能做到这⼀点，继承的功能是静态的，不能动态增删。）<br>7、代理模式(持有被代理类的实例，进⾏操作前后控制)：采⽤⼀个代理类调⽤原有的⽅法，且对产⽣的结果进⾏控制。<br>8、外观模式(集合所有操作到⼀个类)：外观模式是为了解决类与类之间的依赖关系的，像spring⼀样，可以将类和类之间的关系配置到配置<br>⽂件中，⽽外观模式就是将他们的关系放在⼀个Facade类中，降低了类类之间的耦合度。</p><p>9、桥接模式(数据库驱动桥接)：桥接模式就是把事物和其具体实现分开，使他们可以各⾃独⽴的变化。桥接的⽤意是：将抽象化与实现化解<br>耦，使得⼆者可以独⽴变化，像我们常⽤的JDBC桥DriverManager⼀样，JDBC进⾏连接数据库的时候，在各个数据库之间进⾏切换，基本不需要<br>动太多的代码，甚⾄丝毫不⽤动，原因就是JDBC提供统⼀接⼝，每个数据库提供各⾃的实现，⽤⼀个叫做数据库驱动的程序来桥接就⾏了。<br>10、组合模式(部分整体模式)：组合模式有时⼜叫部分-整体模式在处理类似树形结构的问题时⽐较⽅便。<br>11、享元模式(共享池、数据库连接池)：享元模式的主要⽬的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，<br>通常与⼯⼚模式⼀起使⽤。当⼀个客户端请求时，⼯⼚需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，<br>则创建⼀个新对象，如数据库连接池；<br>12、策略模式(多种算法封装)：策略模式定义了⼀系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使⽤<br>算法的客户。需要设计⼀个接⼝，为⼀系列实现类提供统⼀的⽅法，多个实现类实现该接⼝：<br>1 ICalculator cal = new Plus(); //ICalculator是统⼀接⼝，Plus是实现类(多个)<br>2 int result = cal.calculate(exp); //jvm根据实现类不同⽽调⽤不同实现类的⽅法<br>13、模板⽅法模式(抽象⽅法作为⻣架，具体逻辑让⼦类实现)：定义⼀个操作中算法的框架，⽽将⼀些步骤延迟到⼦类中，使得⼦类可以不改<br>变算法的结构即可重定义该算法中的某些特定步骤。完成公共动作和特殊动作的分离。<br>1 //题⽬：排序并打印：<br>2 abstract class AbstractSort {<br>3 /**<br>4 * 将数组array由⼩到⼤排序<br>5 * @param array<br>6 */<br>7 protected abstract void sort(int[] array);<br>8<br>9 public void showSortResult(int[] array){<br>10 System.out.print(“排序结果：”);//打印<br>11 }<br>12 }<br>13 //排序<br>14 class ConcreteSort extends AbstractSort {<br>15<br>16 @Override<br>17 protected void sort(int[] array){<br>18 for(int i=0; i&lt;array.length-1; i++){<br>19 selectSort(array, i);<br>20 }<br>21 }<br>22<br>23 private void selectSort(int[] array, int index) {<br>24 //排序的实现逻辑<br>25 }<br>26 }<br>27 //测试<br>28 public class Client {<br>29 public static int[] a = { 10, 32, 1, 9, 5, 7, 12, 0, 4, 3 }; // 预设数据数组<br>30 public static void main(String[] args){<br>31 AbstractSort s = new ConcreteSort();<br>32 s.showSortResult(a);<br>33 }<br>34 }<br>14、观察者模式(发布-订阅模式)：当⼀个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是⼀种⼀对多的关<br>系。类似于邮件订阅和RSS订阅，当你订阅了该⽂章，如果后续有更新，会及时通知你。<br>15、迭代器模式(遍历集合)：迭代器模式就是顺序访问聚集中的对象。<br>16、责任链模式(多任务形成⼀条链，请求在链上传递)：有多个对象，每个对象持有对下⼀个对象的引⽤，这样就会形成⼀条链，请求在<br>这条链上传递，直到某⼀对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的<br>情况下，对系统进⾏动态的调整。<br>17、命令模式(实现请求和执⾏的解耦)：命令模式的⽬的就是达到命令的发出者和执⾏者之间解耦，实现请求和执⾏分开，熟悉Struts的<br>同学应该知道，Struts其实就是⼀种将请求和呈现分离的技术，其中必然涉及命令模式的思想！<br>18、备忘录模式(保存和恢复对象状态)：主要⽬的是保存⼀个对象的某个状态，以便在适当的时候恢复对象。<br>19、状态模式(对象状态改变时改变其⾏为)：当对象的状态改变时，同时改变其⾏为。状态模式就两点：1、可以通过改变状态来获得不同<br>的⾏为。2、你的好友能同时看到你的变化。</p><p>20、访问者模式(数据接⼝稳定，但算法易变)：访问者模式把数据结构和作⽤于结构上的操作解耦合，使得操作集合可相对⾃由地演化。<br>访问者模式适⽤于数据结构相对稳定算法⼜易变化的系统。因为访问者模式使得算法操作增加变得容易。访问者模式就是⼀种分离对象数据结构与⾏<br>为的⽅法，通过这种分离，可达到为⼀个被访问者动态添加新的操作⽽⽆需做其它的修改的效果。<br>21、中介者模式：中介者模式也是⽤来降低类类之间的耦合的。如果使⽤中介者模式，只需关⼼和Mediator类的关系，具体类类之间的关系<br>及调度交给Mediator就⾏，这有点像spring容器的作⽤。<br>22、解释器模式(对于⼀些固定⽂法构建⼀个解释句⼦的解释器，如正则表达式)：解释器模式⽤来做各种各样的解释器，如正则表达式等的<br>解释器。<br>23、建造者模式(创建复合对象)：⼯⼚类模式提供的是创建单个类的模式，⽽建造者模式则是将各种产品集中起来进⾏管理，⽤来创建复合对<br>象，所谓复合对象就是指某个类具有不同的属性<br>24、设计模式的六⼤原则：<br>1、开闭原则（Open Close Principle）<br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进⾏拓展的时候，不能去修改原有的代码，实现⼀个热插拔的效果。<br>所以⼀句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使⽤接⼝和抽象类，后⾯的具<br>体设计中我们会提到这点。<br>2、⾥⽒代换原则（Liskov Substitution Principle）<br>⾥⽒代换原则(Liskov Substitution Principle LSP)⾯向对象设计的基本原则之⼀。 ⾥⽒代换原则中说，任何基类<br>可以出现的地⽅，⼦类⼀定可以出现。 LSP是继承复⽤的基⽯，只有当衍⽣类可以替换掉基类，软件单位的功能不受到影响时，<br>基类才能真正被复⽤，⽽衍⽣类也能够在基类的基础上增加新的⾏为。⾥⽒代换原则是对“开-闭”原则的补充。实现“开-闭”原则<br>的关键步骤就是抽象化。⽽基类与⼦类的继承关系就是抽象化的具体实现，所以⾥⽒代换原则是对实现抽象化的具体步骤的规<br>范。—— From Baidu 百科<br>3、依赖倒转原则（Dependence Inversion Principle）<br>这个是开闭原则的基础，具体内容：真对接⼝编程，依赖于抽象⽽不依赖于具体。<br>4、接⼝隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使⽤多个隔离的接⼝，⽐使⽤单个接⼝要好。还是⼀个降低类之间的耦合度的意思，从这⼉我们看出，<br>其实设计模式就是⼀个软件的设计思想，从⼤型软件架构出发，为了升级和维护⽅便。所以上⽂中多次出现：降低依赖，降低耦<br>合。<br>5、迪⽶特法则（最少知道原则）（Demeter Principle）<br>为什么叫最少知道原则，就是说：⼀个实体应当尽量少的与其他实体之间发⽣相互作⽤，使得系统功能模块相对独⽴。<br>6、合成复⽤原则（Composite Reuse Principle）<br>原则是尽量使⽤合成/聚合的⽅式，⽽不是使⽤继承<br>25、jdk中的设计模式：</p><ol><li>单例模式：<br>java.lang.Runtime#getRuntime()<br>java.awt.Desktop#getDesktop()<br>java.lang.System#getSecurityManager()</li><li>责任链模式：<br>java.util.logging.Logger#log()<br>javax.servlet.Filter#doFilter()</li><li>观察者模式：<br>java.util.Observer/ java.util.Observable（很少在现实世界中使⽤）<br>所有实现java.util.EventListener（因此实际上各地的Swing）<br>javax.servlet.http.HttpSessionBindingListener<br>javax.servlet.http.HttpSessionAttributeListener<br>javax.faces.event.PhaseListener<br>26、spring中的设计模式：<br>a. 简单⼯⼚：spring中的BeanFactory就是简单⼯⼚模式的体现，根据传⼊⼀个唯⼀的标识来获得bean对象，但是否是在传⼊<br>参数后创建还是传⼊参数前创建这个要根据具体情况来定。<br>b. 单例模式：Spring下默认的bean均为singleton。<br>c. 代理模式：为其他对象提供⼀种代理以控制对这个对象的访问。 从结构上来看和Decorator模式类似，但Proxy是控制，更像<br>是⼀种对功能的限制，⽽Decorator是增加职责。 spring的Proxy模式在aop中有体现，⽐如JdkDynamicAopProxy和<br>Cglib2AopProxy。<br>d. 观察者模式：定义对象间的⼀种⼀对多的依赖关系，当⼀个对象的状态发⽣改变时，所有依赖于它的对象都得到通知并被⾃<br>动更新。spring中Observer模式常⽤的地⽅是listener的实现。如ApplicationListener。</li></ol><p>1.请列举出在JDK中几个常用的设计模式？</p><p>单例模式（Singleton pattern）用于Runtime，Calendar和其他的一些类中。工厂模式（Factory pattern）被用于各种不可变的类如 Boolean，像Boolean.valueOf，观察者模式（Observer pattern）被用于 Swing 和很多的事件监听中。装饰器设计模式（Decorator design pattern）被用于多个 Java IO 类中。</p><p>2.什么是设计模式？你是否在你的代码里面使用过任何设计模式？</p><p>设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸</p><p>3.Java 中什么叫单例设计模式？请用Java 写出线程安全的单例模式</p><p>单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。Java.lang.Runtime是单例模式的经典例子。从 Java 5 开始你可以使用枚举（enum）来实现线程安全的单例。</p><p>4.在 Java 中，什么叫观察者设计模式（observer design pattern）？</p><p>观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象是一个主体，而不同的视图是观察者。</p><p>5.使用工厂模式最主要的好处是什么？在哪里使用？</p><p>工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。</p><p>6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</p><p>装饰模式增加强了单个对象的能力。Java IO 到处都使用了装饰模式，典型例子就是 Buffered 系列类如BufferedReader和BufferedWriter，它们增强了Reader和Writer对象，以实现提升性能的 Buffer 层次的读取和写入。</p><p>7.在 Java 中，为什么不允许从静态方法中访问非静态变量？</p><p>Java 中不能从静态上下文访问非静态数据只是因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联。</p><p>8.设计一个 ATM 机，请说出你的设计思路？</p><p>比如设计金融系统来说，必须知道它们应该在任何情况下都能够正常工作。不管是断电还是其他情况，ATM 应该保持正确的状态（事务） , 想想 加锁（locking）、事务（transaction）、错误条件（error condition）、边界条件（boundary condition） 等等。尽管你不能想到具体的设计，但如果你可以指出非功能性需求，提出一些问题，想到关于边界条件，这些都会是很好的。</p><p>9.在 Java 中，什么时候用重载，什么时候用重写？</p><p>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding），而重载（overloading）是用不同的输入做同一件事。在 Java 中，重载的方法签名不同，而重写并不是。</p><p>10.举例说明什么情况下会更倾向于使用抽象类而不是接口？</p><p>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：</p><p>在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。<br>接口通常被用来表示附属描述或行为如：Runnable、Clonable、Serializable等等，因此当你使用抽象类来表示行为时，你的类就不能同时是Runnable和Clonable(注：这里的意思是指如果把Runnable等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。<br>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。<br>如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/372274a5b315.html" rel="prev" title="搜索引擎"><i class="fa fa-angle-left"></i> 搜索引擎</a></div><div class="post-nav-item"><a href="/publishes/554d7a59d68c.html" rel="next" title="Zookeeper">Zookeeper <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>