<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="什么是Web Service? Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。 使用的技术：HTTP、XML、SOAP（简单对象访问协议）、WSDL 优点：跨平台、跨语言、跨系统 SOAP协议: SOAP协议（Simple Object Access Protocal,简单对象访问协议） Tcp&#x2F;iphttp-&gt;soap，soap 通"><meta property="og:type" content="article"><meta property="og:title" content="Java web"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="什么是Web Service? Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。 使用的技术：HTTP、XML、SOAP（简单对象访问协议）、WSDL 优点：跨平台、跨语言、跨系统 SOAP协议: SOAP协议（Simple Object Access Protocal,简单对象访问协议） Tcp&#x2F;iphttp-&gt;soap，soap 通"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:32:02.000Z"><meta property="article:modified_time" content="2024-01-04T03:29:56.920Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="Java web"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/e002a9c6759b.html","path":"publishes/e002a9c6759b.html","title":"Java web"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java web | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFWeb-Service"><span class="nav-number">1.</span> <span class="nav-text">什么是Web Service?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFWeb%E5%AE%B9%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">什么是Web容器?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">应用服务器有那些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99weblogic%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">如何给weblogic指定大小的内存?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A%E7%9A%84weblogic%E7%9A%84%E7%83%AD%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F-%E4%B8%8E%E4%BA%A7%E5%93%81%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">如何设定的weblogic的热启动模式(开发模式)与产品发布模式?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%8D%E9%9C%80%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E4%B8%8E%E5%AF%86%E7%A0%81"><span class="nav-number">6.</span> <span class="nav-text">如何启动时不需输入用户名与密码?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8weblogic%E7%AE%A1%E7%90%86%E5%88%B6%E5%8F%B0%E4%B8%AD%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%9F%9F-%E6%88%96%E8%80%85%E8%AF%B4%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99-Domain-%E8%BF%9B%E8%A1%8Cjms%E5%8F%8Aejb%E6%88%96%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%AD%89%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%E5%90%8E-%E5%AE%9E%E9%99%85%E4%BF%9D%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-number">7.</span> <span class="nav-text">在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4weblogic%E4%B8%AD%E4%B8%80%E4%B8%AADomain%E7%9A%84%E7%BC%BA%E7%9C%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-%E6%AF%94%E5%A6%82%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84helloWorld-jsp%E6%94%BE%E5%85%A5%E4%BD%95%E7%9B%AE%E5%BD%95%E4%B8%8B-%E7%84%B6%E7%9A%84%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E5%B0%B1%E5%8F%AF%E6%89%93%E5%85%A5-http-%E4%B8%BB%E6%9C%BA-%E7%AB%AF%E5%8F%A3%E5%8F%B7-helloword-jsp%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%BA%86-%E5%8F%88%E6%AF%94%E5%A6%82%E8%BF%99%E5%85%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84javaBean%E8%AF%A5%E5%A6%82%E4%BD%95%E5%8A%9E"><span class="nav-number">8.</span> <span class="nav-text">说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CORBA%E6%98%AF%E4%BB%80%E4%B9%88-%E7%94%A8%E9%80%94%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">9.</span> <span class="nav-text">CORBA是什么?用途是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%9C%A8weblogic%E4%B8%AD%E5%BC%80%E5%8F%91%E6%B6%88%E6%81%AFBean%E6%97%B6%E7%9A%84persistent%E4%B8%8Enon-persisten%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">说说在weblogic中开发消息Bean时的persistent与non-persisten的差别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WEB-SERVICE%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E3%80%82JSWDL%E5%BC%80%E5%8F%91%E5%8C%85%E7%9A%84%E4%BB%8B%E7%BB%8D%E3%80%82JAXP%E3%80%81JAXM%E7%9A%84%E8%A7%A3%E9%87%8A%E3%80%82SOAP%E3%80%81UDDI-WSDL%E8%A7%A3%E9%87%8A%E3%80%82"><span class="nav-number">11.</span> <span class="nav-text">WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4tomcat%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">简单说说tomcat的配置？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSP%E4%B8%AD%E5%8A%A8%E6%80%81INCLUDE%E4%B8%8E%E9%9D%99%E6%80%81INCLUDE%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">JSP中动态INCLUDE与静态INCLUDE的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#forward%E5%92%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">forward和redirect的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">15.</span> <span class="nav-text">Servlet的体系结构是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84servlet"><span class="nav-number">16.</span> <span class="nav-text">如何实现一个自定义的servlet?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">17.</span> <span class="nav-text">Servlet的生命周期是什么?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jsp%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AAservlet%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="nav-number">18.</span> <span class="nav-text">jsp就是一个servlet是否正确?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E7%BD%97%E5%88%97jsp%E4%B8%AD%E7%9A%84%E8%84%9A%E6%9C%AC%E3%80%81%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%8A%A8%E4%BD%9C"><span class="nav-number">19.</span> <span class="nav-text">请罗列jsp中的脚本、指令及动作?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSP%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="nav-number">20.</span> <span class="nav-text">JSP的内置对象及方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E5%9C%A8JSP%E9%A1%B5%E9%9D%A2%E9%87%8C%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%A1%B5%E7%9A%84"><span class="nav-number">21.</span> <span class="nav-text">说出在JSP页面里是怎么分页的?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0JSP%E5%92%8CServlet%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E5%85%B1%E5%90%8C%E7%82%B9%E3%80%81%E5%90%84%E8%87%AA%E5%BA%94%E7%94%A8%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">22.</span> <span class="nav-text">描述JSP和Servlet的区别、共同点、各自应用的范围</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8JSP%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%9F%90%E4%B8%AAJsp%E6%96%87%E4%BB%B6%E7%9A%84%E7%9C%9F%E5%AE%9E%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0Cookie%E5%92%8CSession%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%8C%BA%E5%88%AB%E5%92%8C%E5%90%84%E8%87%AA%E7%9A%84%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%8CSession%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%82"><span class="nav-number">24.</span> <span class="nav-text">描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E6%98%8EJsp%E4%B8%ADerrorPage%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4%E3%80%82"><span class="nav-number">25.</span> <span class="nav-text">说明Jsp中errorPage的作用，应用范围。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E5%9C%A8Jsp%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JavaBeans"><span class="nav-number">26.</span> <span class="nav-text">介绍在Jsp中如何使用JavaBeans</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8DJSP%E7%9A%84%E6%A0%87%E8%AE%B0%E5%BA%93"><span class="nav-number">27.</span> <span class="nav-text">简单介绍JSP的标记库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">28.</span> <span class="nav-text">Servlet中的核心类有那些，各有什么特点?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E5%8C%85%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">Servlet中重要的包有那些，有什么区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%87%BAServlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%B9%B6%E8%AF%B4%E5%87%BAServlet%E5%92%8CCGI%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">说出Servlet的生命周期，并说出Servlet和CGI的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%B0%83%E7%94%A8doGet-%E5%92%8CdoPost-%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">什么情况下调用doGet()和doPost()？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%8E%B0%E5%AE%9Eservlet%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">32.</span> <span class="nav-text">如何现实servlet的单线程模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Request%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">33.</span> <span class="nav-text">Request对象的主要方法：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E5%9C%A8web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E8%BE%93%E5%87%BA%E6%9F%90%E7%A7%8D%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%A6%82iso8859-1%E7%AD%89%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%9F%90%E7%A7%8D%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet%E6%89%A7%E8%A1%8C%E6%97%B6%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">35.</span> <span class="nav-text">Servlet执行时一般实现哪几个方法?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jsp%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="nav-number">36.</span> <span class="nav-text">jsp有哪些内置对象?作用分别是什么：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jsp%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E4%BD%9C-%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="nav-number">37.</span> <span class="nav-text">jsp有哪些动作?作用分别是什么：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A"><span class="nav-number">38.</span> <span class="nav-text">说一说Servlet的生命周期：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA-SERVLET-API%E4%B8%ADforward-%E4%B8%8Eredirect-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">39.</span> <span class="nav-text">JAVA SERVLET API中forward() 与redirect()的区别：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVC%E7%9A%84%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E6%8A%80%E6%9C%AF%E6%9D%A5%E5%AE%9E%E7%8E%B0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">40.</span> <span class="nav-text">MVC的各个部分都有那些技术来实现?如何实现：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#J2EE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="nav-number">41.</span> <span class="nav-text">J2EE是什么：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STRUTS%E7%9A%84%E5%BA%94%E7%94%A8-%E5%A6%82STRUTS%E6%9E%B6%E6%9E%84-%EF%BC%9A"><span class="nav-number">42.</span> <span class="nav-text">STRUTS的应用(如STRUTS架构) ：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E5%90%88%EF%BC%9A"><span class="nav-number">43.</span> <span class="nav-text">开发中都用到了那些设计模式?用在什么场合：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="nav-number">44.</span> <span class="nav-text">四种会话跟踪技术：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#J2EE%E6%98%AF%E6%8A%80%E6%9C%AF%E8%BF%98%E6%98%AF%E5%B9%B3%E5%8F%B0%E8%BF%98%E6%98%AF%E6%A1%86%E6%9E%B6%EF%BC%9A"><span class="nav-number">45.</span> <span class="nav-text">J2EE是技术还是平台还是框架：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E4%B8%89%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">46.</span> <span class="nav-text">EJB的角色和三个对象：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB%E5%AE%B9%E5%99%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="nav-number">47.</span> <span class="nav-text">EJB容器提供的服务：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB%E8%A7%84%E8%8C%83%E8%A7%84%E5%AE%9AEJB%E4%B8%AD%E7%A6%81%E6%AD%A2%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9A"><span class="nav-number">48.</span> <span class="nav-text">EJB规范规定EJB中禁止的操作有哪些：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E6%89%80%E7%86%9F%E6%82%89%E6%88%96%E5%90%AC%E8%AF%B4%E8%BF%87%E7%9A%84j2ee%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F-%E5%8F%8A%E5%AF%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95%EF%BC%9A"><span class="nav-number">49.</span> <span class="nav-text">说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UML%E6%96%B9%E9%9D%A2%EF%BC%9A"><span class="nav-number">50.</span> <span class="nav-text">UML方面：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%8C%85%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%AF%B7%E5%90%84%E4%B8%BE5%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%9A"><span class="nav-number">51.</span> <span class="nav-text">说出一些常用的类，包，接口，请各举5个常用的类：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EWEB-SERVER%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">52.</span> <span class="nav-text">应用服务器与WEB SERVER的区别：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BS%E4%B8%8ECS%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">53.</span> <span class="nav-text">BS与CS的联系与区别：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-S-%E4%B8%8E-B-S-%E5%8C%BA%E5%88%AB"><span class="nav-number">53.0.0.1.</span> <span class="nav-text">C&#x2F;S 与 B&#x2F;S 区别</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#forward-%E5%92%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">54.</span> <span class="nav-text">forward 和redirect的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0Cookie%E5%92%8CSession%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%8C%BA%E5%88%AB%E5%92%8C%E5%90%84%E8%87%AA%E7%9A%84%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%8CSession%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">55.</span> <span class="nav-text">描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%88%86%E4%B8%BA3%E4%B8%AA%E9%98%B6%E6%AE%B5-%E5%92%8CCGI%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">Servlet的生命周期分为3个阶段:? 和CGI的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E4%B8%8ET0MCat%E7%9A%84%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">57.</span> <span class="nav-text">浏览器页面与T0MCat的交互过程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%8F%96Cookie%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">58.</span> <span class="nav-text">JSP内置对象作用，如何取Cookie的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA%E4%BA%8B%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">59.</span> <span class="nav-text">JAVA事件有哪些模式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uml%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">60.</span> <span class="nav-text">uml三要素.</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Session%E7%9A%84%E5%85%B7%E4%BD%93%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="nav-number">61.</span> <span class="nav-text">Session的具体用法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E8%A3%82%E4%B8%BEsession%E3%80%81cookie%E3%80%81viewstated%E7%9A%84%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">62.</span> <span class="nav-text">请裂举session、cookie、viewstated的应用范围</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E4%BD%BF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E9%97%AD%E4%B9%8B%E5%90%8E%EF%BC%8Csession%E6%89%80%E4%BF%9D%E5%AD%98%E7%9A%84%E4%BF%A1%E6%81%AF%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="nav-number">63.</span> <span class="nav-text">用什么方法使服务器关闭之后，session所保存的信息不会丢失？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AFCookie%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">63.0.0.1.</span> <span class="nav-text">写客户端Cookie的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4Session%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">63.0.0.2.</span> <span class="nav-text">服务器之间Session数据同步的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8NFS%E5%85%B1%E4%BA%ABSession%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">63.0.0.3.</span> <span class="nav-text">利用NFS共享Session数据的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B1%E4%BA%ABSession%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">63.0.0.4.</span> <span class="nav-text">利用Mysql数据库共享Session数据的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="nav-number">64.</span> <span class="nav-text">使用硬件设备</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="nav-number">65.</span> <span class="nav-text">过滤器有哪些作用和用法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="nav-number">66.</span> <span class="nav-text">监听器有哪些作用和用法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">67.</span> <span class="nav-text">实现会话跟踪的技术有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URL-%E9%87%8D%E5%86%99"><span class="nav-number">67.0.0.1.</span> <span class="nav-text">URL 重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%A1%A8%E5%8D%95%E9%9A%90%E8%97%8F%E5%9F%9F"><span class="nav-number">67.0.0.2.</span> <span class="nav-text">设置表单隐藏域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cookie"><span class="nav-number">67.0.0.3.</span> <span class="nav-text">cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HttpSession"><span class="nav-number">67.0.0.4.</span> <span class="nav-text">HttpSession</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSP-%E5%92%8CServlet-%E6%9C%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">68.</span> <span class="nav-text">JSP 和Servlet 有有什么关系？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84Web%E5%AE%B9%E5%99%A8"><span class="nav-number">69.</span> <span class="nav-text">常用的Web容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVC%E5%8E%9F%E7%90%86"><span class="nav-number">70.</span> <span class="nav-text">MVC原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">70.0.0.1.</span> <span class="nav-text">MVC的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">70.0.0.2.</span> <span class="nav-text">MVC的缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSP%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">71.</span> <span class="nav-text">JSP的执行过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CGI-Servlet-JSP%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">72.</span> <span class="nav-text">CGI&#x2F;Servlet&#x2F;JSP的比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSP-ASP-PHP%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">73.</span> <span class="nav-text">JSP&#x2F;ASP&#x2F;PHP的比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http%E7%9A%84%E5%93%8D%E5%BA%94%E7%A0%81"><span class="nav-number">74.</span> <span class="nav-text">http的响应码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Session%E5%9F%9F%E5%92%8Crequest%E5%9F%9F%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">75.</span> <span class="nav-text">Session域和request域什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99weblogic%E5%AE%9A%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="nav-number">76.</span> <span class="nav-text">如何给weblogic定内存的大小？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Web-%E5%BC%80%E5%8F%91%E7%9A%84-Model-1-%E5%92%8C-Model-2-%E5%88%86%E5%88%AB%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">77.</span> <span class="nav-text">Java Web 开发的 Model 1 和 Model 2 分别指的是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B-MVC-%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="nav-number">78.</span> <span class="nav-text">简单说一下 MVC 框架？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%8C%E6%88%90%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">79.</span> <span class="nav-text">模式完成分页功能的基本思路是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVC-%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">80.</span> <span class="nav-text">MVC 模式及其优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC-%E5%8E%9F%E7%90%86"><span class="nav-number">80.0.0.1.</span> <span class="nav-text">MVC 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">80.0.0.2.</span> <span class="nav-text">MVC 的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC-%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="nav-number">80.0.0.3.</span> <span class="nav-text">MVC 的不足之处</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">81.</span> <span class="nav-text">说说你对容器的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-number">82.</span> <span class="nav-text">什么是同源策略？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JsonP%EF%BC%9F"><span class="nav-number">83.</span> <span class="nav-text">什么是 JsonP？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="nav-number">84.</span> <span class="nav-text">什么是跨域？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4"><span class="nav-number">85.</span> <span class="nav-text">怎么防止重复提交</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%90%E8%BF%B0-Session-%E5%8A%A0%E8%BD%BD%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="nav-number">86.</span> <span class="nav-text">阐述 Session 加载实体对象的过程。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet-3-%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">87.</span> <span class="nav-text">Servlet 3 中的异步处理指的是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95%EF%BC%9F-1"><span class="nav-number">88.</span> <span class="nav-text">过滤器有哪些作用和用法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">89.</span> <span class="nav-text">静态网页和动态网页的联系和区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Session-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">90.</span> <span class="nav-text">Session 的基本原理是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9-XML-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E8%AF%B4%E6%98%8E-Web-%E5%BA%94%E7%94%A8%E4%B8%AD-Web-xml-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">91.</span> <span class="nav-text">谈谈对 XML 的理解？说明 Web 应用中 Web.xml 文件的作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-number">92.</span> <span class="nav-text">什么是 CSRF 攻击？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%9C%A8-weblogic-%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%8F%91%E5%B8%83%E7%9A%84-EJB"><span class="nav-number">93.</span> <span class="nav-text">如何查看在 weblogic 中已经发布的 EJB?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB-%E5%9F%BA%E4%BA%8E%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E8%AF%B4%E5%87%BA-SessionBean-%E5%92%8C-EntityBean-%E5%8C%BA%E5%88%AB%EF%BC%8CStatefulBean-%E5%92%8CStatelessBean-%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">94.</span> <span class="nav-text">EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和StatelessBean 区别。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB-%E5%8C%85%E6%8B%AC%EF%BC%88SessionBean-EntityBean%EF%BC%89%E8%AF%B4%E5%87%BA%E4%BB%96%E4%BB%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%8F%8A%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%EF%BC%9F"><span class="nav-number">95.</span> <span class="nav-text">EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB-%E7%9A%84%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="nav-number">96.</span> <span class="nav-text">EJB 的激活机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EJB-%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">97.</span> <span class="nav-text">EJB 的几种类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%A2%E6%9C%8D%E7%AB%AF%E8%B0%83%E7%94%A8-EJB-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">98.</span> <span class="nav-text">客服端调用 EJB 对象的几个基本步骤</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="nav-number">99.</span> <span class="nav-text">如何实现跨域？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-SQL-%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="nav-number">100.</span> <span class="nav-text">如何避免 SQL 注入？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">101.</span> <span class="nav-text">什么是 XSS 攻击，如何避免？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">102.</span> <span class="nav-text">什么是 CSRF 攻击，如何避免？</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">58</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java web | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java web</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:32:02" itemprop="dateCreated datePublished" datetime="2023-12-20T15:32:02+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 11:29:56" itemprop="dateModified" datetime="2024-01-04T11:29:56+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-web/" itemprop="url" rel="index"><span itemprop="name">Java web</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>30k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>27 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service?"></a>什么是Web Service?</h1><ul><li>Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。</li><li>使用的技术：HTTP、XML、SOAP（简单对象访问协议）、WSDL</li><li>优点：跨平台、跨语言、跨系统</li><li>SOAP协议:<ul><li>SOAP协议（Simple Object Access Protocal,简单对象访问协议）</li><li>Tcp&#x2F;iphttp-&gt;soap，soap 通过xml文件传送信息</li></ul></li><li>缺点：<ul><li>WebService使用了XML对数据封装，会造成大量的数据要在网络中传输。</li><li>WebService规范没有规定任何与实现相关的细节，包括对象模型、编程语言，这一点，它不如CORBA。</li></ul></li></ul><h1 id="什么是Web容器"><a href="#什么是Web容器" class="headerlink" title="什么是Web容器?"></a>什么是Web容器?</h1><ul><li>实现J2EE规范中web协议的应用</li><li>该协议定义了web程序的运行时环境,包括:并发性,安全性,生命周期管理等等.</li><li>就是在tomcat、weblogic下运行jsp、servlet、struts</li></ul><h1 id="应用服务器有那些？"><a href="#应用服务器有那些？" class="headerlink" title="应用服务器有那些？"></a>应用服务器有那些？</h1><ul><li>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat</li></ul><h1 id="如何给weblogic指定大小的内存"><a href="#如何给weblogic指定大小的内存" class="headerlink" title="如何给weblogic指定大小的内存?"></a>如何给weblogic指定大小的内存?</h1><ul><li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li></ul><h1 id="如何设定的weblogic的热启动模式-开发模式-与产品发布模式"><a href="#如何设定的weblogic的热启动模式-开发模式-与产品发布模式" class="headerlink" title="如何设定的weblogic的热启动模式(开发模式)与产品发布模式?"></a>如何设定的weblogic的热启动模式(开发模式)与产品发布模式?</h1><ul><li>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一</li><li>或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE&#x3D;true。</li></ul><h1 id="如何启动时不需输入用户名与密码"><a href="#如何启动时不需输入用户名与密码" class="headerlink" title="如何启动时不需输入用户名与密码?"></a>如何启动时不需输入用户名与密码?</h1><ul><li>修改服务启动文件，增加 WLS_USER和WLS_PW项</li><li>也可以在boot.properties文件中增加加密过的用户名和密码.</li></ul><h1 id="在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中"><a href="#在weblogic管理制台中对一个应用域-或者说是一个网站-Domain-进行jms及ejb或连接池等相关信息进行配置后-实际保存在什么文件中" class="headerlink" title="在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?"></a>在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?</h1><ul><li>保存在此Domain的config.xml文件中，它是服务器的核心配置文件。</li></ul><h1 id="说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办"><a href="#说说weblogic中一个Domain的缺省目录结构-比如要将一个简单的helloWorld-jsp放入何目录下-然的在浏览器上就可打入-http-主机-端口号-helloword-jsp就可以看到运行结果了-又比如这其中用到了一个自己写的javaBean该如何办" class="headerlink" title="说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?"></a>说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?</h1><ul><li>Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问</li><li>如果是Web应用，应用目录需要满足Web应用目录要求</li><li>jsp文件可以直接放在应用目录中</li><li>Javabean需要放在应用目录的WEB-INF目录的classes目录中</li><li>设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。</li></ul><h1 id="CORBA是什么-用途是什么"><a href="#CORBA是什么-用途是什么" class="headerlink" title="CORBA是什么?用途是什么?"></a>CORBA是什么?用途是什么?</h1><ul><li>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)</li><li>由对象管理组织 (Object Management Group，缩写为 OMG)标准化</li><li>它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议</li><li>其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。</li></ul><h1 id="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"><a href="#说说在weblogic中开发消息Bean时的persistent与non-persisten的差别" class="headerlink" title="说说在weblogic中开发消息Bean时的persistent与non-persisten的差别"></a>说说在weblogic中开发消息Bean时的persistent与non-persisten的差别</h1><ul><li>persistent方式的MDB可以保证消息传递的可靠性</li><li>也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来</li><li>而non－persistent方式的消息将被丢弃。</li></ul><h1 id="WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。"><a href="#WEB-SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。" class="headerlink" title="WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。"></a>WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</h1><ul><li>Web Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。</li><li>JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口，这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。</li><li>JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。</li><li>WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。</li><li>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。</li><li>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。</li></ul><h1 id="简单说说tomcat的配置？"><a href="#简单说说tomcat的配置？" class="headerlink" title="简单说说tomcat的配置？"></a>简单说说tomcat的配置？</h1><ul><li>JAVA_HOME&#x3D;JDK的根目录</li><li>CATALINA_HOME&#x3D;tomcat的根目录</li><li>CATALINA-HOME\conf\server.xml:可以配置tomcat的端口，可以配置tomcat中下连接池。</li><li>CATALINA-HOME\common\lib:存放公用的类包</li></ul><h1 id="JSP中动态INCLUDE与静态INCLUDE的区别？"><a href="#JSP中动态INCLUDE与静态INCLUDE的区别？" class="headerlink" title="JSP中动态INCLUDE与静态INCLUDE的区别？"></a>JSP中动态INCLUDE与静态INCLUDE的区别？</h1><ul><li>jsp:include:在运行时调用另一个页面，变量是可以重复的。</li><li>&lt;%@include file&#x3D;””%&gt;:在转译时合在一起，会成为同一个类，变量不可以重复。</li><li>&lt;@include file&gt;:在将jsp生成servlet类前将两个文件和在一起，生成一个java类，一起运行的。所以是一家子，当中的变量名不能重名。</li><li>&lt;jsp:include page&gt;:是两个类，是一个调用关系，在运行时动态的调用，不是一家子，可以重复变量。</li></ul><h1 id="forward和redirect的区别？"><a href="#forward和redirect的区别？" class="headerlink" title="forward和redirect的区别？"></a>forward和redirect的区别？</h1><ul><li>forward: 转发，在下一个页面中，request保留上一个页面中的request的所有值</li><li>redirect: 跳转，不传递request对象。</li></ul><h1 id="Servlet的体系结构是什么"><a href="#Servlet的体系结构是什么" class="headerlink" title="Servlet的体系结构是什么?"></a>Servlet的体系结构是什么?</h1><ul><li>Servlet</li><li>GenericServlet</li><li>HttpServlet</li></ul><h1 id="如何实现一个自定义的servlet"><a href="#如何实现一个自定义的servlet" class="headerlink" title="如何实现一个自定义的servlet?"></a>如何实现一个自定义的servlet?</h1><ul><li>extends HttpServlet 并覆盖doPost或doGet方法</li><li>在web.xml中进行部署</li></ul><h1 id="Servlet的生命周期是什么"><a href="#Servlet的生命周期是什么" class="headerlink" title="Servlet的生命周期是什么?"></a>Servlet的生命周期是什么?</h1><ul><li>Init</li><li>多次执行doGet或doPost</li><li>destroy</li></ul><h1 id="jsp就是一个servlet是否正确"><a href="#jsp就是一个servlet是否正确" class="headerlink" title="jsp就是一个servlet是否正确?"></a>jsp就是一个servlet是否正确?</h1><ul><li>对</li></ul><h1 id="请罗列jsp中的脚本、指令及动作"><a href="#请罗列jsp中的脚本、指令及动作" class="headerlink" title="请罗列jsp中的脚本、指令及动作?"></a>请罗列jsp中的脚本、指令及动作?</h1><ul><li>脚本：&lt;%%&gt; &lt;%&#x3D;%&gt; &lt;%!%&gt; &lt;%—-%&gt;</li><li>指令<ul><li>&lt;%@page contentType&#x3D;”text&#x2F;html;charset&#x3D;utf-8” language&#x3D;”java” import&#x3D;””%&gt;</li><li>&lt;%@include file&#x3D;””%&gt;</li><li>&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</li></ul></li><li>动作:<ul><li>&lt;jsp:useBean class&#x3D;”” id&#x3D;”” scope&#x3D;””&gt; 在scope中如果没有实例化一个对象，如果有直接用以前的。</li><li>&lt;jsp:getProperty name&#x3D;”” property&#x3D;””&gt; 向一个bean中设置属性值</li><li>&lt;jsp:forward &gt; jsp页的转发</li><li>&lt;jsp:include page&#x3D;””&gt; 导入一个jsp页面</li></ul></li></ul><h1 id="JSP的内置对象及方法"><a href="#JSP的内置对象及方法" class="headerlink" title="JSP的内置对象及方法"></a>JSP的内置对象及方法</h1><ul><li>Request request表示HttpServletRequest对象。取客户端表单域信息及cookie, header, 和session</li><li>response response表示HttpServletResponse对象，对客户端的响应返回文本、写cookies。</li><li>out out 向客户端打印html文本.</li><li>pageContext :当前jsp页面的上下文环境，可以得到session、request、application等内置对象，在自定义标签中使用的很多。</li><li>session session表示一个请求的javax.servlet.http.HttpSession对象。Session一个用户多个页面共享同一变量。</li><li>application applicaton 表示一个javax.servle.ServletContext对象。存放容器级的变量。</li><li>config config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。</li><li>page page表示从该页面产生的一个servlet实例</li><li>exception:异常，当iserrorpage&#x3D;true</li></ul><h1 id="说出在JSP页面里是怎么分页的"><a href="#说出在JSP页面里是怎么分页的" class="headerlink" title="说出在JSP页面里是怎么分页的?"></a>说出在JSP页面里是怎么分页的?</h1><ul><li>页面需要保存以下参数：(数据库的分页及比较)<ul><li>总行数：根据sql语句得到总行数</li><li>每页显示行数：设定值</li><li>当前页数：请求参数</li></ul></li><li>页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。</li></ul><h1 id="描述JSP和Servlet的区别、共同点、各自应用的范围"><a href="#描述JSP和Servlet的区别、共同点、各自应用的范围" class="headerlink" title="描述JSP和Servlet的区别、共同点、各自应用的范围"></a>描述JSP和Servlet的区别、共同点、各自应用的范围</h1><ul><li>Jsp主要在于页面的显示动态生成页面，可以与html标记一起使用，其还是要生成为一个servlet。</li><li>Servlet：主要是控制的处理，如调用业务层，跳转不同的jsp页面。</li><li>Mvc:<ul><li>Jsp:v</li><li>Servlet:c</li></ul></li></ul><h1 id="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"><a href="#在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？" class="headerlink" title="在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？"></a>在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？</h1><ul><li>Request.getparameter(“”)</li><li>&lt;%&#x3D;application.getRealPath(“aa.jsp”) %&gt;</li></ul><h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。</h1><ul><li>Cookie:主要用在保存客户端，其值在客户端与服务端之间传送，不安全，存储的数据量有限。</li><li>Session:保存在服务端，每一个session在服务端有一个sessionID作一个标识。存储的数据量大，安全性高。占用服务端的内存资源。</li></ul><h1 id="说明Jsp中errorPage的作用，应用范围。"><a href="#说明Jsp中errorPage的作用，应用范围。" class="headerlink" title="说明Jsp中errorPage的作用，应用范围。"></a>说明Jsp中errorPage的作用，应用范围。</h1><ul><li>正常页面中：%@page erropage&#x3D;”error.jsp”%</li><li>错误页面：&lt;%@page iserrorpage&#x3D;”true”%&gt;</li><li>有一内置对象:exception</li></ul><h1 id="介绍在Jsp中如何使用JavaBeans"><a href="#介绍在Jsp中如何使用JavaBeans" class="headerlink" title="介绍在Jsp中如何使用JavaBeans"></a>介绍在Jsp中如何使用JavaBeans</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean class=”” id=”” scope=””/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	New 类();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="简单介绍JSP的标记库"><a href="#简单介绍JSP的标记库" class="headerlink" title="简单介绍JSP的标记库"></a>简单介绍JSP的标记库</h1><ul><li><p>做一个标记处理类 extends TagSupport</p></li><li><p>通过tld说明标记处理的类的前缀及后缀</p></li><li><p>在web.xml中说明tld文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;taglib&gt;</span><br><span class="line">		&lt;taglib-uri&gt;</span><br><span class="line">		&lt;taglib-location&gt;</span><br><span class="line">&lt;taglib&gt;</span><br></pre></td></tr></table></figure></li><li><p>在jsp页面是引用tld&lt;%@taglib uri&#x3D;”” prefix&#x3D;””%&gt;</p></li></ul><h1 id="Servlet中的核心类有那些，各有什么特点"><a href="#Servlet中的核心类有那些，各有什么特点" class="headerlink" title="Servlet中的核心类有那些，各有什么特点?"></a>Servlet中的核心类有那些，各有什么特点?</h1><ul><li>ServletContext：容器，放置全局变量<ul><li>setAtribute()</li><li>getAttribute()</li></ul></li><li>ServletConfig：一个servlet的配置<ul><li>getInitParameter(”名称”)</li></ul></li><li>HttpServletRequest：封装的所有的请求<ul><li>getParameterValue(”名称”)</li><li>getParameterValues(”称”)</li></ul></li><li>getSession();<ul><li>getAttribute(” 名称”);</li><li>getRequestDispatch(”a.jsp”).forward(request,response)</li></ul></li><li>HttpServletResponse：响应<ul><li>getOut();</li><li>sendRedirect(””)</li></ul><p></p></li><li>HttpSession：一个用户多个页面共享同一变量<ul><li>setAttribute(””,””)</li></ul></li></ul><h1 id="Servlet中重要的包有那些，有什么区别"><a href="#Servlet中重要的包有那些，有什么区别" class="headerlink" title="Servlet中重要的包有那些，有什么区别?"></a>Servlet中重要的包有那些，有什么区别?</h1><ul><li>javax.servlet.<em>；javax.servlet.http.</em>;</li></ul><h1 id="说出Servlet的生命周期，并说出Servlet和CGI的区别？"><a href="#说出Servlet的生命周期，并说出Servlet和CGI的区别？" class="headerlink" title="说出Servlet的生命周期，并说出Servlet和CGI的区别？"></a>说出Servlet的生命周期，并说出Servlet和CGI的区别？</h1><ul><li>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</li><li>与cgi的区别在于servlet处理服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li></ul><h1 id="什么情况下调用doGet-和doPost-？"><a href="#什么情况下调用doGet-和doPost-？" class="headerlink" title="什么情况下调用doGet()和doPost()？"></a>什么情况下调用doGet()和doPost()？</h1><ul><li>Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。</li></ul><h1 id="如何现实servlet的单线程模式"><a href="#如何现实servlet的单线程模式" class="headerlink" title="如何现实servlet的单线程模式"></a>如何现实servlet的单线程模式</h1><ul><li>在doGet及doPost方法前加入synchoronized</li><li>JSP：&lt;%@ page isThreadSafe&#x3D;”true”%&gt;</li></ul><h1 id="Request对象的主要方法："><a href="#Request对象的主要方法：" class="headerlink" title="Request对象的主要方法："></a>Request对象的主要方法：</h1><ul><li>setAttribute(String name,Object)：设置名字为name的request的参数值</li><li>getAttribute(String name)：返回由name指定的属性值</li><li>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例</li><li>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组</li><li>getCharacterEncoding()：返回请求中的字符编码方式</li><li>getContentLength()：返回请求的Body的长度</li><li>getInputStream()：返回请求的输入流，用于获得请求中的数据</li><li>getMethod()：获得客户端向服务器端传送数据的方法</li><li>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值</li><li>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li><li>getParameterValues(String name)：获得有name指定的参数的所有值</li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li><li>getQueryString()：获得查询字符串</li><li>getRequestURI()：获取发出请求字符串的客户端地址</li><li>getRemoteAddr()：获取客户端的IP地址</li><li>getRemoteHost()：获取客户端的名字</li><li>getSession([Boolean create])：返回和请求相关Session</li><li>getServerName()：获取服务器的名字</li><li>getServletPath()：获取客户端所请求的脚本文件的路径</li><li>getServerPort()：获取服务器的端口号</li><li>removeAttribute(String name)：删除请求中的一个属性</li></ul><h1 id="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"><a href="#我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？"></a>我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Public String translate (String str) &#123;</span><br><span class="line">  String tempStr = &quot;&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">    tempStr = new String(str.getBytes(&quot;ISO-8859-1&quot;), &quot;GBK&quot;);</span><br><span class="line">    tempStr = tempStr.trim();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Exception e) &#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  return tempStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Servlet执行时一般实现哪几个方法"><a href="#Servlet执行时一般实现哪几个方法" class="headerlink" title="Servlet执行时一般实现哪几个方法?"></a>Servlet执行时一般实现哪几个方法?</h1><ul><li>public void init(ServletConfig config)</li><li>public ServletConfig getServletConfig()</li><li>public String getServletInfo()</li><li>public void service(ServletRequest request,ServletResponse response)</li><li>public void destroy()</li></ul><h1 id="jsp有哪些内置对象-作用分别是什么："><a href="#jsp有哪些内置对象-作用分别是什么：" class="headerlink" title="jsp有哪些内置对象?作用分别是什么："></a>jsp有哪些内置对象?作用分别是什么：</h1><ul><li>JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：<ul><li>request 用户端请求，此请求会包含来自GET&#x2F;POST请求的参数</li><li>response 网页传回用户端的回应</li><li>pageContext 网页的属性是在这里管理</li><li>session 与请求有关的会话期</li><li>application servlet 正在执行的内容</li><li>out 用来传送回应的输出</li><li>config servlet的构架部件</li><li>page JSP网页本身</li><li>exception 针对错误网页，未捕捉的例外。</li></ul></li></ul><h1 id="jsp有哪些动作-作用分别是什么："><a href="#jsp有哪些动作-作用分别是什么：" class="headerlink" title="jsp有哪些动作?作用分别是什么："></a>jsp有哪些动作?作用分别是什么：</h1><ul><li>JSP共有以下6种基本动作<ul><li>jsp:include：在页面被请求的时候引入一个文件。</li><li>jsp:useBean：寻找或者实例化一个JavaBean。</li><li>jsp:setProperty：设置JavaBean的属性。</li><li>jsp:getProperty：输出某个JavaBean的属性。</li><li>jsp:forward：把请求转到一个新的页面。</li><li>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。</li></ul></li></ul><h1 id="说一说Servlet的生命周期："><a href="#说一说Servlet的生命周期：" class="headerlink" title="说一说Servlet的生命周期："></a>说一说Servlet的生命周期：</h1><ul><li>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束</li><li>这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。</li></ul><h1 id="JAVA-SERVLET-API中forward-与redirect-的区别："><a href="#JAVA-SERVLET-API中forward-与redirect-的区别：" class="headerlink" title="JAVA SERVLET API中forward() 与redirect()的区别："></a>JAVA SERVLET API中forward() 与redirect()的区别：</h1><ul><li>前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接，从浏览器的地址栏中可以看到跳转后的链接地址</li><li>前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。</li></ul><h1 id="MVC的各个部分都有那些技术来实现-如何实现："><a href="#MVC的各个部分都有那些技术来实现-如何实现：" class="headerlink" title="MVC的各个部分都有那些技术来实现?如何实现："></a>MVC的各个部分都有那些技术来实现?如何实现：</h1><ul><li>MVC是Model－View－Controller的简写</li><li>“Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）</li><li>“View” 是应用的表示面（由JSP页面产生）</li><li>“Controller” 是提供应用的处理过程控制（一般是一个Servlet）</li><li>通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。</li></ul><h1 id="J2EE是什么："><a href="#J2EE是什么：" class="headerlink" title="J2EE是什么："></a>J2EE是什么：</h1><ul><li>Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model)</li><li>在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中</li><li>所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。</li></ul><h1 id="STRUTS的应用-如STRUTS架构-："><a href="#STRUTS的应用-如STRUTS架构-：" class="headerlink" title="STRUTS的应用(如STRUTS架构) ："></a>STRUTS的应用(如STRUTS架构) ：</h1><ul><li>Struts是采用Java Servlet&#x2F;JavaServer Pages技术，开发Web应用程序的开放源码的framework</li><li>采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架</li><li>Struts有如下的主要功能：<ul><li>包含一个controller servlet，能将用户的请求发送到相应的Action对象。</li><li>JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。</li><li>提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。</li></ul></li></ul><h1 id="开发中都用到了那些设计模式-用在什么场合："><a href="#开发中都用到了那些设计模式-用在什么场合：" class="headerlink" title="开发中都用到了那些设计模式?用在什么场合："></a>开发中都用到了那些设计模式?用在什么场合：</h1><ul><li>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心</li><li>通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作</li><li>主要用到了MVC的设计模式</li><li>用来开发JSP&#x2F;Servlet或者J2EE的相关应用</li><li>简单工厂模式等。</li></ul><h1 id="四种会话跟踪技术："><a href="#四种会话跟踪技术：" class="headerlink" title="四种会话跟踪技术："></a>四种会话跟踪技术：</h1><ul><li>cookie,url重写,session,隐藏域。</li></ul><h1 id="J2EE是技术还是平台还是框架："><a href="#J2EE是技术还是平台还是框架：" class="headerlink" title="J2EE是技术还是平台还是框架："></a>J2EE是技术还是平台还是框架：</h1><ul><li>J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。</li><li>J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。</li></ul><h1 id="EJB的角色和三个对象："><a href="#EJB的角色和三个对象：" class="headerlink" title="EJB的角色和三个对象："></a>EJB的角色和三个对象：</h1><ul><li>一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性</li><li>这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类</li></ul><h1 id="EJB容器提供的服务："><a href="#EJB容器提供的服务：" class="headerlink" title="EJB容器提供的服务："></a>EJB容器提供的服务：</h1><ul><li>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</li></ul><h1 id="EJB规范规定EJB中禁止的操作有哪些："><a href="#EJB规范规定EJB中禁止的操作有哪些：" class="headerlink" title="EJB规范规定EJB中禁止的操作有哪些："></a>EJB规范规定EJB中禁止的操作有哪些：</h1><ul><li>不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，</li><li>不能操作awt，</li><li>不能实现服务器功能，</li><li>不能对静态属生存取，</li><li>不能使用IO操作直接存取文件系统，</li><li>不能加载本地库.，</li><li>不能将this作为变量和返回，</li><li>不能循环调用。</li></ul><h1 id="说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法："><a href="#说说你所熟悉或听说过的j2ee中的几种常用模式-及对设计模式的一些看法：" class="headerlink" title="说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法："></a>说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法：</h1><ul><li>Session Facade Pattern：使用SessionBean访问EntityBean；</li><li>Message Facade Pattern：实现异步调用</li><li>EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问；</li><li>Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性；</li><li>Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性；</li><li>Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性；</li><li>ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率</li><li>项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。</li></ul><h1 id="UML方面："><a href="#UML方面：" class="headerlink" title="UML方面："></a>UML方面：</h1><ul><li>标准建模语言UML</li><li>用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。</li></ul><h1 id="说出一些常用的类，包，接口，请各举5个常用的类："><a href="#说出一些常用的类，包，接口，请各举5个常用的类：" class="headerlink" title="说出一些常用的类，包，接口，请各举5个常用的类："></a>说出一些常用的类，包，接口，请各举5个常用的类：</h1><ul><li>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer；</li><li>常用的包：java.lang java.awt java.io java.util java.sql；</li><li>常用的接口：Remote List Map Document NodeList</li></ul><h1 id="应用服务器与WEB-SERVER的区别："><a href="#应用服务器与WEB-SERVER的区别：" class="headerlink" title="应用服务器与WEB SERVER的区别："></a>应用服务器与WEB SERVER的区别：</h1><ul><li>应用服务器：Weblogic、Tomcat、Jboss； WEB SERVER：IIS、 Apache</li></ul><h1 id="BS与CS的联系与区别："><a href="#BS与CS的联系与区别：" class="headerlink" title="BS与CS的联系与区别："></a>BS与CS的联系与区别：</h1><ul><li>C&#x2F;S是Client&#x2F;Server的缩写</li><li>服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server</li><li>客户端需要安装专用的客户端软件</li><li>B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库</li><li>在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。</li><li>浏览器通过Ｗeb Server 同数据库进行数据交互。</li></ul><h4 id="C-S-与-B-S-区别"><a href="#C-S-与-B-S-区别" class="headerlink" title="C&#x2F;S 与 B&#x2F;S 区别"></a>C&#x2F;S 与 B&#x2F;S 区别</h4><ul><li>硬件环境不同: C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C&#x2F;S更强的适应范围, 一般只要有操作系统和浏览器就行</li><li>对安全要求不同 ：C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C&#x2F;S 结构适宜. 可以通过B&#x2F;S发布部分可公开信息.B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。</li><li>对程序架构不同 ：　C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C&#x2F;S有更高的要求 B&#x2F;S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B&#x2F;S更加成熟.</li><li>软件重用不同： C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性好.　B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。</li><li>系统维护不同 ：C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.</li><li>处理问题不同 ：C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C&#x2F;S无法作到的. 与操作系统平台关系最小.</li><li>用户接口不同： C&#x2F;S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.</li><li>信息流不同 ：　C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B&#x2F;S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心</li></ul><h1 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h1><ul><li>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址</li><li>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</li></ul><h1 id="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"><a href="#描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理" class="headerlink" title="描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理"></a>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理</h1><ul><li>Session用于保存每个用户的专用信息</li><li>每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID）</li><li>她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右)</li><li>Session中的信息保存在Web服务器内容中,保存的数据量可大可小</li><li>当 Session超时或被关闭时将自动释放保存的数据信息</li><li>由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低</li><li>对于小量的数据,使用Session对象保存还是一个不错的选择</li><li>Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置</li><li>如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止</li><li>如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期</li><li>Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据</li><li>由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性</li><li>session工作原理<ul><li>当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。</li><li>然后，服务器开辟一块内存，对应于该Session ID。</li><li>服务器再将该Session ID写入浏览器的cookie。</li><li>服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。</li><li>当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。</li><li>然后，服务检查该Session ID所对应的内存是否有效。</li><li>如果有效，就读出内存中的值。</li><li>如果无效，就建立新的Session。</li></ul></li></ul><h1 id="Servlet的生命周期分为3个阶段-和CGI的区别？"><a href="#Servlet的生命周期分为3个阶段-和CGI的区别？" class="headerlink" title="Servlet的生命周期分为3个阶段:?  和CGI的区别？"></a>Servlet的生命周期分为3个阶段:? 和CGI的区别？</h1><ul><li>Servlet的生命周期主要由3个过程组成。<ul><li>init()方法：服务器初始化servlet。</li><li>service()方法：初始化完毕，servlet对象调用该方法响应客户的请求。</li><li>destroy()方法：调用该方法消灭servlet对象。</li></ul></li><li>其中，init()方法只在servlet第一次被请求加载的时候被调用一次，当有客户再请求servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。</li><li>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</li></ul><h1 id="浏览器页面与T0MCat的交互过程？"><a href="#浏览器页面与T0MCat的交互过程？" class="headerlink" title="浏览器页面与T0MCat的交互过程？"></a>浏览器页面与T0MCat的交互过程？</h1><ul><li>当一个JSP页面第一次被访问的时候，JSP引擎将执行以下步骤：<ul><li>将JSP页面翻译成一个Servlet，这个Servlet是一个java文件，同时也是一个完整的java程序</li><li>JSP引擎调用java编译器对这个Servlet进行编译，得到可执行文件class</li><li>JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户端</li></ul></li><li>以上三个步骤仅仅在JSP页面第一次被访问时才会执行，以后的访问速度会因为class文件已经生成而大大提高<br>当JSP引擎接到一个客户端的访问请求时，首先判断请求的JSP页面是否比对应的Servlet新，如果新，对应的JSP需要重新编译。</li></ul><h1 id="JSP内置对象作用，如何取Cookie的方法"><a href="#JSP内置对象作用，如何取Cookie的方法" class="headerlink" title="JSP内置对象作用，如何取Cookie的方法"></a>JSP内置对象作用，如何取Cookie的方法</h1><ul><li>使用request对象的getCookies()方法取cookies</li></ul><h1 id="JAVA事件有哪些模式？"><a href="#JAVA事件有哪些模式？" class="headerlink" title="JAVA事件有哪些模式？"></a>JAVA事件有哪些模式？</h1><ul><li>事件直接驱动模式。它的第一个要求就是性能的要求，需要直接而且快，是必须经常使用的，主要适合于迅速处理 前台的命令，往往是系统架构的重要部分，也是流程控制的主要模式。</li><li>监控式事件模式是借助第三者来监控和触发事件，特点是： 有一个观察者置身事外在定期独立运行着。</li></ul><h1 id="uml三要素"><a href="#uml三要素" class="headerlink" title="uml三要素."></a>uml三要素.</h1><ul><li>事物、关系、图</li></ul><h1 id="Session的具体用法？"><a href="#Session的具体用法？" class="headerlink" title="Session的具体用法？"></a>Session的具体用法？</h1><ul><li>Session用来保存每一个用户的专有信息，比如像用户登录验证、购物车。</li></ul><h1 id="请裂举session、cookie、viewstated的应用范围"><a href="#请裂举session、cookie、viewstated的应用范围" class="headerlink" title="请裂举session、cookie、viewstated的应用范围"></a>请裂举session、cookie、viewstated的应用范围</h1><ul><li>Session 服务器端维护， 某个用户活动时间 + 延迟时间（默认20分钟），</li><li>Cookie 客户端维护， 程序可指定生命周期，</li><li>ViewState 小量数据，一个web页面的生命期</li></ul><h1 id="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"><a href="#用什么方法使服务器关闭之后，session所保存的信息不会丢失？" class="headerlink" title="用什么方法使服务器关闭之后，session所保存的信息不会丢失？"></a>用什么方法使服务器关闭之后，session所保存的信息不会丢失？</h1><ul><li>将session信息保存到数据库中或文件中</li></ul><h4 id="写客户端Cookie的方式"><a href="#写客户端Cookie的方式" class="headerlink" title="写客户端Cookie的方式"></a>写客户端Cookie的方式</h4><ul><li>当用户登陆成功以后，把网站域名、用户名、密码、token、session有效时间全部采用cookie的形式写入到客户端的cookie里面</li><li>如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务</li><li>当然，如果cookie过期，或者无效，自然就不让用户继续服务了</li><li>当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？</li></ul><h4 id="服务器之间Session数据同步的方式"><a href="#服务器之间Session数据同步的方式" class="headerlink" title="服务器之间Session数据同步的方式"></a>服务器之间Session数据同步的方式</h4><ul><li>假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了</li><li>缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。</li></ul><h4 id="利用NFS共享Session数据的方式"><a href="#利用NFS共享Session数据的方式" class="headerlink" title="利用NFS共享Session数据的方式"></a>利用NFS共享Session数据的方式</h4><ul><li>其实这个方案和下面的Mysql方案类似，只是存储方式不一样</li><li>大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台NFS服务器上的，不论用户访问那太Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了</li><li>缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。</li></ul><h4 id="利用Mysql数据库共享Session数据的方式"><a href="#利用Mysql数据库共享Session数据的方式" class="headerlink" title="利用Mysql数据库共享Session数据的方式"></a>利用Mysql数据库共享Session数据的方式</h4><ul><li>这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上</li><li>所有Web服务器都来这台Mysql服务器来获取Session数据</li><li>缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql数据的方式。</li></ul><h1 id="使用硬件设备"><a href="#使用硬件设备" class="headerlink" title="使用硬件设备"></a>使用硬件设备</h1><ul><li>这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了</li><li>目前很多门户网站采用这种方式</li><li>缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的。</li></ul><h1 id="过滤器有哪些作用和用法？"><a href="#过滤器有哪些作用和用法？" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h1><ul><li>对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤</li><li>当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联</li><li>如果有，那么容器将把请求交给过滤器进行处理</li><li>在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源</li><li>当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常- 见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。</li><li>和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain</li></ul><h1 id="监听器有哪些作用和用法？"><a href="#监听器有哪些作用和用法？" class="headerlink" title="监听器有哪些作用和用法？"></a>监听器有哪些作用和用法？</h1><ul><li>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：<ul><li>ServletContextListener：对Servlet上下文的创建和销毁进行监听。</li><li>ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。</li><li>HttpSessionListener：对Session的创建和销毁进行监听。补充：session的销毁有两种情况：1session超时（可以在web.xml中通过&lt;session-config&gt;&#x2F;&lt;session-timeout&gt;标签配置超时时间）；2通过调用session对象的invalidate()方法使session失效。</li><li>HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。</li><li>ServletRequestListener：对请求对象的初始化和销毁进行监听。</li><li>ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</li></ul></li></ul><h1 id="实现会话跟踪的技术有哪些？"><a href="#实现会话跟踪的技术有哪些？" class="headerlink" title="实现会话跟踪的技术有哪些？"></a>实现会话跟踪的技术有哪些？</h1><ul><li>由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。</li></ul><h4 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h4><ul><li>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</li></ul><h4 id="设置表单隐藏域"><a href="#设置表单隐藏域" class="headerlink" title="设置表单隐藏域"></a>设置表单隐藏域</h4><ul><li>将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。</li><li>这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。</li></ul><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul><li>cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间</li><li>当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份</li><li>会话中可以为用户保存信息</li><li>会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的</li><li>如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪</li><li>当然，在使用cookie时要注意几点<ul><li>首先不要在cookie中存放敏感信息</li><li>其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中</li><li>再者浏览器通常只允许一个站点最多存放20个cookie</li><li>当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。</li></ul></li></ul><h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><ul><li>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的</li><li>当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession</li><li>可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象</li><li>与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能</li><li>添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</li></ul><h1 id="JSP-和Servlet-有有什么关系？"><a href="#JSP-和Servlet-有有什么关系？" class="headerlink" title="JSP 和Servlet 有有什么关系？"></a>JSP 和Servlet 有有什么关系？</h1><ul><li>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容</li><li>JSP本质上是Servlet的一种简易形式， JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成</li><li>Servlet和JSP最主要的不同点在于，Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML分离开来</li><li>而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp 的文件（有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然，这个说法还是很片面的）</li><li>JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</li></ul><h1 id="常用的Web容器"><a href="#常用的Web容器" class="headerlink" title="常用的Web容器"></a>常用的Web容器</h1><ul><li>Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows平台的服务器通常使用IIS作为Web服务器</li><li>选择Web服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等</li><li>下面是对常用服务器的简介：<ul><li>IIS：Microsoft的Web服务器产品为Internet Information Services。IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。IIS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在IIS的平台上。IIS提供了一个图形界面的管理工具，称为Internet服务管理器，可用于监视配置和控制Internet服务。IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。</li><li>Kangle：Kangle Web服务器是一款跨平台、功能强大、安全稳定、易操作的高性能Web服务器和反向代理服务器软件。此外，Kangle也是一款专为做虚拟主机研发的Web服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持PHP、ASP、ASP.NET、Java、Ruby等多种动态开发语言。</li><li>WebSphere：WebSphere Application Server是功能完善、开放的Web应用程序服务器，是IBM电子商务计划的核心部分，它是基于Java的应用环境，用于建立、部署和管理Internet和Intranet Web应用程序，适应各种Web应用程序服务器的需要，范围从简单到高级直到企业级。</li><li>WebLogic：BEA WebLogic Server是一种多功能、基于标准的Web应用服务器，为企业构建自己的应用提供了坚实的基础。各种应用开发、部署所有关键性的任务，无论是集成各种系统和数据库，还是提交服务、跨Internet协作，Weblogic都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发，基于Internet的企业都选择它来开发、部署最佳的应用。BEA WebLogic Server在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础，它们以 Internet的容量和速度，在连网的企业之间共享信息、提交服务，实现协作自动化。</li><li>Apache：目前Apache仍然是世界上用得最多的Web服务器，市场占有率约为60%左右。世界上很多著名的网站都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。</li><li>Tomcat：Tomcat是一个开放源代码、运行Servlet和JSP的容器。TomcatServer实现了Servlet和JSP规范。此外，Tomcat还实现了Apache-Jakarta规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的Web服务器都选择了Tomcat。</li><li>Nginx：读作”engine x”，是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。 Nginx是由Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</li></ul></li></ul><h1 id="MVC原理"><a href="#MVC原理" class="headerlink" title="MVC原理"></a>MVC原理</h1><ul><li>MVC是一种程序开发设计模式,它实现了显示模块与功能模块的分离</li><li>提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、控制器三层。<ul><li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li><li>视图(view) 用户与之交互的界面、在web中视图一般由jsp,html组成</li><li>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用</li></ul></li></ul><h4 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h4><ul><li>降低代码耦合性。在MVC模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。</li><li>有利于分工合作。在MVC模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。</li><li>有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。</li></ul><h4 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h4><ul><li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li><li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li><li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li><li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成MVC使用的困难。</li></ul><h1 id="JSP的执行过程"><a href="#JSP的执行过程" class="headerlink" title="JSP的执行过程"></a>JSP的执行过程</h1><ul><li>在JSP运行过程中，首先由客户端发出请求，Web服务器接收到请求后，如果是第一次访问某个jsp页面，Web服务器对它进行以下3个操作。<ul><li>翻译：由.jsp变为.java,由JSP引擎实现。</li><li>编译：由.java变为.class,由 Java编译器实现。</li><li>执行：由.class变为.html,用Java虚拟机执行编译文件,然后将执行结果返回给Web服务器，并最终返回给客户端</li></ul></li><li>如果不是第一次访问某个JSP页面，则只执行第三步。所以第一次访问JSP较慢。</li></ul><h1 id="CGI-Servlet-JSP的比较"><a href="#CGI-Servlet-JSP的比较" class="headerlink" title="CGI&#x2F;Servlet&#x2F;JSP的比较"></a>CGI&#x2F;Servlet&#x2F;JSP的比较</h1><ul><li>CGI(Common Gateway Interface)，通用网关接口,是一种根据请求信息动态产生回应内容的技术。通过CGI，Web 服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于每个请求，都要产生一个新的进程进行处理。</li><li>Servlet 是在服务器上运行的小程序。在实际运行的时候Java Servlet与Web服务器会融为一体。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。</li><li>JSP从本质上说就是Servlet。JSP技术产生于Servlet之后，两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。</li><li>与CGI相比，Servlet效率更高。Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet 。</li><li>与CGI相比，Servlet更容易使用，功能更强大，具有更好的可移植性，更节省投资。在未来的技术发展过程中，Servlet有可能彻底取代CGI。</li></ul><h1 id="JSP-ASP-PHP的比较"><a href="#JSP-ASP-PHP的比较" class="headerlink" title="JSP&#x2F;ASP&#x2F;PHP的比较"></a>JSP&#x2F;ASP&#x2F;PHP的比较</h1><ul><li>ASP(Active Server Pages),JSP(JavaServer Pages),PHP(Hypertext Preprocessor)是目前主流的三种动态网页语言。</li><li>ASP是微软（Microsoft）所开发的一种后台脚本语言，它的语法和Visual BASIC类似，可以像SSI（Server Side Include）那样把后台脚本代码内嵌到HTML页面中。虽然ASP简单易用，但是它自身存在着许多缺陷，最重要的就是安全性问题。</li><li>PHP是一种跨平台的服务器端的嵌入式脚本语言。它大量地借用C,Java和Perl语言的语法, 并耦合PHP自己的特性,使WEB开发者能够快速地写出动态产生页面。它支持目前绝大多数数据库。</li><li>JSP是一个简化的Servlet，它是由Sun公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML中插入Java程序段和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。</li><li>ASP优点:无需编译、易于生成、独立于浏览器、面向对象、与任何ActiveX scripting 语言兼容、源程序码不会外漏。</li><li>ASP缺点:<ul><li>Windows本身的所有问题都会一成不变的也累加到了它的身上。安全性、稳定性、跨平台性都会因为与NT的捆绑而显现出来。</li><li>ASP由于使用了COM组件所以它会变的十分强大，但是这样的强大由于Windows NT系统最初的设计问题而会引发大量的安全问题。只要在这样的组件或是操作中一不注意，那么外部攻击就可以取得相当高的权限而导致网站瘫痪或者数据丢失。</li><li>还无法完全实现一些企业级的功能：完全的集群、负载均横。</li></ul></li><li>PHP优点：<ul><li>一种能快速学习、跨平台、有良好数据库交互能力的开发语言。</li><li>简单轻便，易学易用。</li><li>与Apache及其它扩展库结合紧密。</li></ul></li><li>PHP缺点：<ul><li>数据库支持的极大变化。</li><li>不适合应用于大型电子商务站点。</li></ul></li><li>JSP优点：<ul><li>一处编写随处运行。</li><li>系统的多台平支持。</li><li>强大的的可伸缩性。</li><li>多样化和功能强大的开发工具支持。</li></ul></li><li>JSP缺点：<ul><li>与ASP一样，Java的一些优势正是它致命的问题所在。</li><li>开发速度慢</li></ul></li></ul><h1 id="http的响应码"><a href="#http的响应码" class="headerlink" title="http的响应码"></a>http的响应码</h1><ul><li>200 - 确定。客户端请求已成功</li><li>302 - 临时移动转移，请求的内容已临时移动新的位置</li><li>404 - 未找到文件或目录</li><li>500 - 服务器内部错误</li></ul><h1 id="Session域和request域什么区别？"><a href="#Session域和request域什么区别？" class="headerlink" title="Session域和request域什么区别？"></a>Session域和request域什么区别？</h1><ul><li>作用域：存放数据，获取数据（传递数据）</li><li>有效的作用域：生命周期，作用范围</li><li>http<ul><li>生命周期 ：一次请求之间</li><li>作用范围：所有被请求转发过的servlet都能获取到httpSession:</li></ul></li><li>Servelt<ul><li>生命周期：一次会话</li><li>作用范围：所有的servlet都可以获取到servletContex:</li></ul></li><li>Request:<ul><li>生命周期：从项目开始运行到服务器关闭</li><li>作用范围：所有的servlet都可以获取到</li></ul></li><li>作用域如何选用？<ul><li>httpServeltRequest：和当前请求有关的信息</li><li>httpSession：和当前用户有关的信息</li><li>servletContex：访问量比较大，不易更改</li></ul></li></ul><h1 id="如何给weblogic定内存的大小？"><a href="#如何给weblogic定内存的大小？" class="headerlink" title="如何给weblogic定内存的大小？"></a>如何给weblogic定内存的大小？</h1><ul><li>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M</li></ul><h1 id="Java-Web-开发的-Model-1-和-Model-2-分别指的是什么？"><a href="#Java-Web-开发的-Model-1-和-Model-2-分别指的是什么？" class="headerlink" title="Java Web 开发的 Model 1 和 Model 2 分别指的是什么？"></a>Java Web 开发的 Model 1 和 Model 2 分别指的是什么？</h1><ul><li>Model 1 是以页面为中心的 Java Web 开发，只适合非常小型的应用程序，Model 2是基于 MVC 架构模式的应用，这一点在前文的面试题中已经详细讲解过了</li><li>说说什么是框架：框架(framework)是一个框子–》指约束性，也是一个架子–》指支撑性 IT 语境中的框架，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，在此结构上可以根据具体问题扩展、按插更多的组成部分，从而更迅速和方便地架构完整的解决问题的方案。<ul><li>框架本身一般不完整到可以解决特定问题，但是可以帮助您快速解决特定问题：没有框架所有的工作都从零开始做，有了框架，为我们提供了一定的功能。我们就可以在框架的基础上开发，极大的解决了生产力。不同的框架，是为了解决不同领域的问题，一定要为了解决问题才去学习框架。</li><li>框架天生就是为了扩展而设计的</li><li>框架里面可以为后续的组件提供很多辅助性、支撑性的方便易用的实用工具(utilities)，也就是框架时常配套一些帮组解决某类问题的库(libraries）或工具（tools）</li></ul></li></ul><h1 id="简单说一下-MVC-框架？"><a href="#简单说一下-MVC-框架？" class="headerlink" title="简单说一下 MVC 框架？"></a>简单说一下 MVC 框架？</h1><ul><li>是为了解决传统 MVC 模式(jsp+servlet+javabean)一些问题而出现的框架</li><li>传统 MVC 模式模式问题：<ul><li>所有的 Servlet 和 Servlet 映射都要配置在 web.xml 中，如果项目太大，web.xml就太庞大并且不能实现模块化管理。</li><li>Servlet 的主要功能就是接受参数、调用逻辑、跳转页面，比如像其他字符编码、文件上传等功能也要写在 Servlet 中，不能让 Servlet 主要功能而需要做处理一些特例。</li><li>接受参数比较麻烦，(String name &#x3D; request.getParameter(“name”))，不能通过 model 接受，只能单个接收，接收完成后转换封装 model。</li><li>跳转页面方式比较单一(forward,redirect)，并且当我们的页面名称发生改变时需要改变 Servlet 源代码。</li></ul></li><li>现在比较常用的 MVC 框架：<ul><li>webwork</li><li>Struts</li><li>Struts2</li><li>SpringMVC</li></ul></li></ul><h1 id="模式完成分页功能的基本思路是什么？"><a href="#模式完成分页功能的基本思路是什么？" class="headerlink" title="模式完成分页功能的基本思路是什么？"></a>模式完成分页功能的基本思路是什么？</h1><ul><li>页面提交页码(第几页)到 Servlet 中</li><li>Servlet 接收到页码后，将页码传递给分页工具类(PageBean)</li><li>Servlet 中调用 Service 层传入 PageBean 对象</li><li>Service 层调用 DAO 层传入 PageBean 对象</li><li>Servlet 中得到查询出来的数据，并 setAttrivute 保存</li><li>在页面中得到(getAttribute)数据，遍历输出</li></ul><h1 id="MVC-模式及其优缺点"><a href="#MVC-模式及其优缺点" class="headerlink" title="MVC 模式及其优缺点"></a>MVC 模式及其优缺点</h1><h4 id="MVC-原理"><a href="#MVC-原理" class="headerlink" title="MVC 原理"></a>MVC 原理</h4><ul><li>MVC 是一种程序开发设计模式,它实现了显示模块与功能模块的分离</li><li>提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度</li><li>它主要分模型、视图、控制器三层。<ul><li>模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性</li><li>视图(view) 用户与之交互的界面、在 web 中视图一般由 jsp,html 组成</li><li>控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用</li></ul></li></ul><h4 id="MVC-的优点"><a href="#MVC-的优点" class="headerlink" title="MVC 的优点"></a>MVC 的优点</h4><ul><li>降低代码耦合性。在 MVC 模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。</li><li>有利于分工合作。在 MVC 模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的 JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。</li><li>有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。</li></ul><h4 id="MVC-的不足之处"><a href="#MVC-的不足之处" class="headerlink" title="MVC 的不足之处"></a>MVC 的不足之处</h4><ul><li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循 MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li><li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li><li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li><li>目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应 MVC 需要和建立分离的部件的代价是很高的，从而造成 MVC 使用的困难。</li></ul><h1 id="说说你对容器的理解"><a href="#说说你对容器的理解" class="headerlink" title="说说你对容器的理解"></a>说说你对容器的理解</h1><ul><li>容器也是 java 程序，它的主要作用是为应用程序提供运行环境</li><li>容器用来接管安全性、并发性、事务处理、交换到辅助存储器和其它服务的责任</li><li>以 tomcat 为例：Tomcat 是一个后台服务进程，其它的 servlet（相当于 DLL）是在 Tomcat容器内运行,Broswer 只与 Tomcat 通迅; Tomcat 接受 browser 的请求，经过一系列动作（如果是静态网页，那么装载，按 http 协议形成响应流;如果是动态的如 JSP，那就要调用 JDK 中的 servlet.jsp 接口，解释形成静态网页，按 http 协议生成响应流发送回browser）后，形成静态网页，返回响应。</li></ul><h1 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h1><ul><li>同源策略&#x2F;SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略</li><li>如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源</li></ul><h1 id="什么是-JsonP？"><a href="#什么是-JsonP？" class="headerlink" title="什么是 JsonP？"></a>什么是 JsonP？</h1><ul><li>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</li></ul><h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><ul><li>跨域是指一个域（网站）下的文档或脚本试图去请求另一个域（网站）下的资源。</li></ul><h1 id="怎么防止重复提交"><a href="#怎么防止重复提交" class="headerlink" title="怎么防止重复提交"></a>怎么防止重复提交</h1><ul><li>禁掉提交按钮。表单提交后使用 Javascript 使提交按钮 disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把 Javascript 给禁止掉，这种方法就无效了。</li><li>Post&#x2F;Redirect&#x2F;Get 模式。在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按 F5 导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</li><li>在 session 中存放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从 session 中删除它，然后正常处理数据。如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。</li><li>在数据库里添加约束。在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。</li></ul><h1 id="阐述-Session-加载实体对象的过程。"><a href="#阐述-Session-加载实体对象的过程。" class="headerlink" title="阐述 Session 加载实体对象的过程。"></a>阐述 Session 加载实体对象的过程。</h1><ul><li>Session 加载实体对象的步骤是：<ul><li>Session 在调用数据库查询功能之前, 首先会在缓存中进行查询, 在一级缓存中, 通过实体类型和主键进行查找, 如果一级缓存查找命中且数据状态合法, 则直接返回</li><li>如果一级缓存没有命中, 接下来 Session 会在当前 NonExists 记录(相当于一个查询黑名单, 如果出现重复的无效查询可以迅速判断, 从而提升性能)中进行查找, 如果NonExists 中存在同样的查询条件,则返回 null</li><li>对于 load 方法, 如果一级缓存查询失败则查询二级缓存, 如果二级缓存命中则直接返回</li><li>如果之前的查询都未命中, 则发出 SQL 语句, 如果查询未发现对应记录则将此次查询添加到 Session 的 NonExists 中加以记录, 并返回 null</li><li>根据映射配置和 SQL 语句得到 ResultSet,并创建对应的实体对象</li><li>将对象纳入 Session(一级缓存)管理</li><li>执行拦截器的 onLoad 方法(如果有对应的拦截器)</li><li>将数据对象纳入二级缓存</li><li>返回数据对象</li></ul></li></ul><h1 id="Servlet-3-中的异步处理指的是什么？"><a href="#Servlet-3-中的异步处理指的是什么？" class="headerlink" title="Servlet 3 中的异步处理指的是什么？"></a>Servlet 3 中的异步处理指的是什么？</h1><ul><li>在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交给 Executor（如果不清楚请查看前文关于多线程和线程池的部分）并立即返回即可。</li></ul><h1 id="过滤器有哪些作用和用法？-1"><a href="#过滤器有哪些作用和用法？-1" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h1><ul><li>Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在Servlet 2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web 容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果<br>有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转换，然后再将响应发送到客户端。</li><li>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT等。</li><li>和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain</li></ul><h1 id="静态网页和动态网页的联系和区别"><a href="#静态网页和动态网页的联系和区别" class="headerlink" title="静态网页和动态网页的联系和区别"></a>静态网页和动态网页的联系和区别</h1><ul><li>联系：<ul><li>静态网页是网站建设的基础，静态网页和动态网页都要使用到 HTMl 语言。</li><li>静态网页是相对于动态网页而言，指没有后台数据库、不含程序和不可交互的网页、是标准的 HTML 文件，它的文件扩展名是.htm 或.html。你编的是什么它显示的就是什么、不会有任何改变。</li><li>静态网页和动态网页之间并不矛盾，为了网站适应搜索引擎检索的需要，动态网站可以采用静动结合的原则，适合采用动态网页的地方用动态网页，如果必要使用静态网页，则可以考虑用静态网页的方法来实现，在同一个网站上，动态网页内容和静态网页内容同时存在也是很常见的事情。</li></ul></li><li>区别：<ul><li>程序是否在服务器端运行，是重要标志。在服务器端运行的程序、网页、组件，属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如 ASP、PHP、JSP、ASP.net、CGI 等。运行于客户端的程序、网页、插件、组件，属于静态网页，例如 html页、Flash、javascript、VBscript 等等，它们是永远不变的。</li><li>编程技术不同。静态网页和动态网页主要根据网页制作的语言来区分。静态网页使用语言：HTML。 动态网页使用语言：HTML＋ASP 或 HTML＋PHP 或 HTML＋JSP 等其它网站动态语言。</li><li>被搜索引擎收录情况不同。由于编程技术不容，静态网页是纯粹 HTML 格式的网页，页面内容稳定，不论是网页是否被访问，页面都被保存在网站服务器上，很容易被搜索引擎收录。而动态网页的内容是当用户点击请求时才从数据库中调出返回给用户一个网页的内容，并不是存放在服务器上的独立文件，相比较于静态网页而言，动态网页很难被搜索引擎收录。</li><li>用户访问速度不同。用户访问动态网页时，网页在获得搜索指令后经过数据库的调查匹配，再将与指令相符的内容传递给服务器，通过服务器的编译将网页编译成标准的 HTML 代码，从而传递给用户浏览器，多个读取过程大大降低了用户的访问速度。而静态网页不同，由于网页内容直接存取在服务器上，省去了服务器的编译过程，用户访问网页速度很快。</li><li>制作和后期维护工作量不同。动态网页的设计以数据库技术为基础，可以实现多种功能，降低了网站维护的工作量。而静态网页由于没有数据库的支持，网页内容更改时需要直接修改代码，在网站内容制作和维护中，所需的工作量更大。动态网页与静态网页各有特点，网站设计师在网页设计时，主要根据网站的功能需求和网站内容多少选择不同网页。如，网站包含信息量太大时，就需要选择动态网页，反之，则选择静态网页。</li></ul></li></ul><h1 id="Session-的基本原理是什么？"><a href="#Session-的基本原理是什么？" class="headerlink" title="Session 的基本原理是什么？"></a>Session 的基本原理是什么？</h1><ul><li>Session 对象的原理在于，服务器可以为客户端创建并维护一个所谓的 Session 对象，用于存放数据。在创建 Session 对象的同时，服务器将会为该 Session 对象产生一个唯一编号，这个编号称之为 SessionID，服务器以 Cookie 的方式将 SessionID 存放在客户端。当浏览器再次访问该服务器时，会将 SessionID 作为 Cookie 信息带到服务器，服务器可以通过该SessionID 检索到以前的 Session 对象，并对其进行访问。需要注意的是，此时的 Cookie 中仅仅保存了一个 SessionID，而相对较多的会话数据保存在服务器端对应的 Session 对象中，由服务器来统一维护，这样一定程度保证了会话数据安全性，但增加了服务器端的内存开销。</li><li>存放在客户端的用于保存 SessionID 的 Cookie 会在浏览器关闭时清除。我们把用户打开一个浏览器访问某个应用开始，到关闭浏览器为止交互过程称为一个 “会话”。在一个“会话”过程中，可能会向同一个应用发出了多次请求，这些请求将共享一个 Session 对象，因为这些请求携带了相同的 SessionID 信息。Session 对象的正常使用要依赖于 Cookie。如果考虑到客户端浏览器可能出于安全的考虑禁用了 Cookie，应该使用 URL 重写的方式使 Session 在客户端禁用 Cookie 的情况下继续生效。</li></ul><h1 id="谈谈对-XML-的理解？说明-Web-应用中-Web-xml-文件的作用？"><a href="#谈谈对-XML-的理解？说明-Web-应用中-Web-xml-文件的作用？" class="headerlink" title="谈谈对 XML 的理解？说明 Web 应用中 Web.xml 文件的作用？"></a>谈谈对 XML 的理解？说明 Web 应用中 Web.xml 文件的作用？</h1><ul><li>XML（Extensible Markup Language）即可扩展标记语言，它与 HTML 一样，都是SGML(Standard Generalized Markup Language,标准通用标记语言)。Xml 是 Internet 环境中跨平台的，依赖于内容的技术，是当前处理结构化文档信息的有力工具。扩展标记语言 XML 是一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式建立，虽然 XML 占用的空间比二进制数据要占用更多的空间，但 XML 极其简单易于掌握和使用。</li><li>web.xml 的作用是配置欢迎页，servlet，filter，listener 等的。</li></ul><h1 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h1><ul><li>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</li></ul><h1 id="如何查看在-weblogic-中已经发布的-EJB"><a href="#如何查看在-weblogic-中已经发布的-EJB" class="headerlink" title="如何查看在 weblogic 中已经发布的 EJB?"></a>如何查看在 weblogic 中已经发布的 EJB?</h1><ul><li>可以使用管理控制台，在它的 Deployment 中可以查看所有已发布的 EJB</li></ul><h1 id="EJB-基于哪些技术实现的？说出-SessionBean-和-EntityBean-区别，StatefulBean-和StatelessBean-区别。"><a href="#EJB-基于哪些技术实现的？说出-SessionBean-和-EntityBean-区别，StatefulBean-和StatelessBean-区别。" class="headerlink" title="EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和StatelessBean 区别。"></a>EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和StatelessBean 区别。</h1><ul><li>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技术实现。</li><li>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。</li><li>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。</li><li>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。</li><li>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的Session Bean 都可以将系统逻辑放在 method 之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。</li></ul><h1 id="EJB-包括（SessionBean-EntityBean）说出他们的生命周期，及如何管理事务的？"><a href="#EJB-包括（SessionBean-EntityBean）说出他们的生命周期，及如何管理事务的？" class="headerlink" title="EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？"></a>EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？</h1><ul><li>SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立一个 Bean 的实例时，EJB 容器不一定要创建一个新的 Bean 的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个 Stateful Session Bean 时，容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用StatefulSession Bean 的方法时容器会把调用分派到与此客户机相关联的 Bean 实例。</li><li>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，Entity beans 就一直存活。而不是按照应用程序或者服务进程来说的。即使 EJB 容器崩溃了，Entity beans 也是存活的。Entity Beans 生命周期能够被容器或者 Beans 自己管理。</li><li>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems的 Transaction Service（JTS）、Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。</li></ul><h1 id="EJB-的激活机制"><a href="#EJB-的激活机制" class="headerlink" title="EJB 的激活机制"></a>EJB 的激活机制</h1><ul><li>以Stateful Session Bean 为例：其 Cache大小决定了内存中可以同时存在的Bean实例的数量，根据 MRU 或 NRU 算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某个 EJB 实例业务方法时，如果对应 EJB Object 发现自己没有绑定对应的 Bean 实例则从其去激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对应的 ejbActive 和 ejbPassivate 方法。</li></ul><h1 id="EJB-的几种类型"><a href="#EJB-的几种类型" class="headerlink" title="EJB 的几种类型"></a>EJB 的几种类型</h1><ul><li>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean</li><li>会话 Bean 又可分为有状态（Stateful）和无状态（Stateless）两种</li><li>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种</li></ul><h1 id="客服端调用-EJB-对象的几个基本步骤"><a href="#客服端调用-EJB-对象的几个基本步骤" class="headerlink" title="客服端调用 EJB 对象的几个基本步骤"></a>客服端调用 EJB 对象的几个基本步骤</h1><ul><li>设置 JNDI 服务工厂以及 JNDI 服务地址系统属性，查找 Home 接口，从 Home 接口调用 Create方法创建 Remote 接口，通过 Remote 接口调用其业务方法</li></ul><h1 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h1><ul><li>实现跨域有以下几种方案：<ul><li>服务器端运行跨域 设置 CORS 等于 *；</li><li>在单个接口使用注解 @CrossOrigin 运行跨域；</li><li>使用 jsonp 跨域；</li></ul></li></ul><h1 id="如何避免-SQL-注入？"><a href="#如何避免-SQL-注入？" class="headerlink" title="如何避免 SQL 注入？"></a>如何避免 SQL 注入？</h1><ul><li>使用预处理 PreparedStatement。</li><li>使用正则表达式过滤掉字符中的特殊字符。</li></ul><h1 id="什么是-XSS-攻击，如何避免？"><a href="#什么是-XSS-攻击，如何避免？" class="headerlink" title="什么是 XSS 攻击，如何避免？"></a>什么是 XSS 攻击，如何避免？</h1><ul><li>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</li><li>预防 XSS 的核心是必须对输入的数据做过滤处理。</li></ul><h1 id="什么是-CSRF-攻击，如何避免？"><a href="#什么是-CSRF-攻击，如何避免？" class="headerlink" title="什么是 CSRF 攻击，如何避免？"></a>什么是 CSRF 攻击，如何避免？</h1><ul><li>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</li><li>防御手段：<ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加 token 并验证。</li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java-web/" rel="tag"><i class="fa fa-tag"></i> Java web</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/32257fddc744.html" rel="prev" title="数据库"><i class="fa fa-angle-left"></i> 数据库</a></div><div class="post-nav-item"><a href="/publishes/98f0d77a0556.html" rel="next" title="数据结构与算法">数据结构与算法 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">593k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">8:59</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>