<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><meta name="description" content="WebService技术1、什么是Web Service?Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。使用的技术:HTTP、XML、SOAP（简单对象访问协议）、WSDL优点:    跨平台、跨语言、跨系统SOAP协议:    SOAP协议（Simple Object Access Protocal,简单对象访问协议）    Tcp&#x2F;iphttp-"><meta property="og:type" content="article"><meta property="og:title" content="Java web"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="WebService技术1、什么是Web Service?Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。使用的技术:HTTP、XML、SOAP（简单对象访问协议）、WSDL优点:    跨平台、跨语言、跨系统SOAP协议:    SOAP协议（Simple Object Access Protocal,简单对象访问协议）    Tcp&#x2F;iphttp-"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:32:02.000Z"><meta property="article:modified_time" content="2023-12-20T07:32:30.332Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="Java web"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/e002a9c6759b.html","path":"publishes/e002a9c6759b.html","title":"Java web"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java web | Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java后端面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/e002a9c6759b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java web | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java web</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:32:02 / 修改时间：15:32:30" itemprop="dateCreated datePublished" datetime="2023-12-20T15:32:02+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-web/" itemprop="url" rel="index"><span itemprop="name">Java web</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>WebService技术<br>1、什么是Web Service?<br>Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。<br>使用的技术:<br>HTTP、XML、SOAP（简单对象访问协议）、WSDL<br>优点:<br>跨平台、跨语言、跨系统<br>SOAP协议:<br>SOAP协议（Simple Object Access Protocal,简单对象访问协议）<br>Tcp/iphttp-&gt;soap，soap 通过xml文件传送信息<br>缺点：<br>(1).WebService使用了XML对数据封装，会造成大量的数据要在网络中传输。<br>(2).WebService规范没有规定任何与实现相关的细节，包括对象模型、编程语言，这一点，它不如CORBA。<br>2、什么是Web容器?<br>实现J2EE规范中web协议的应用.该协议定义了web程序的运行时环境,包括:并发性,安全性,生命周期管理等等.<br>就是在tomcat、weblogic下运行jsp、servlet、struts<br>3、应用服务器有那些？<br>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat<br>5、如何给weblogic指定大小的内存?<br>在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS=-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M<br>6、如何设定的weblogic的热启动模式(开发模式)与产品发布模式?<br>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE=true。<br>7、如何启动时不需输入用户名与密码?<br>修改服务启动文件，增加 WLS_USER和WLS_PW项。也可以在boot.properties文件中增加加密过的用户名和密码.<br>8、在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?<br>保存在此Domain的config.xml文件中，它是服务器的核心配置文件。<br>9、说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http://主机:端口号//helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?<br>Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问，如果是Web应用，应用目录需要满足Web应用目录要求，jsp文件可以直接放在应用目录中，Javabean需要放在应用目录的WEB-INF目录的classes目录中，设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。<br>12、CORBA是什么?用途是什么?<br>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。<br>13、说说在weblogic中开发消息Bean时的persistent与non-persisten的差别<br>persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来，而non－persistent方式的消息将被丢弃。<br>14、WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。<br>Web ServiceWeb Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。<br>JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口。这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。<br>JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。<br>WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。<br>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。<br>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。</p><p>Web编程Jsp&amp;Servlet技术<br>1、简单说说tomcat的配置？<br>JAVA_HOME=JDK的根目录<br>CATALINA_HOME=tomcat的根目录</p><p>CATALINA-HOME\conf\server.xml:可以配置tomcat的端口，可以配置tomcat中下连接池。<br>CATALINA-HOME\common\lib:存放公用的类包</p><p>在My eclipse中如何配置tomcat<br>在eclipse中,选择windows-&gt;preference-&gt;MyEclipse-&gt;ApplicationServer-&gt;Tomcat<br>选择Tomcat 的安装目录，并选择TomCat所需的jdk，选择enable,确定即可。<br>2、JSP中动态INCLUDE与静态INCLUDE的区别？<br>jsp:include:在运行时调用另一个页面，变量是可以重复的。<br>&lt;%@include file=””%&gt;:在转译时合在一起，会成为同一个类，变量不可以重复。<br>3、forward和redirect的区别？<br>forward: 转发，在下一个页面中,request保留上一个页面中的request的所有值</p><p>redirect: 跳转，不传递request对象。<br>4、Servlet的体系结构是什么?<br>Servlet<br>GenericServlet<br>HttpServlet<br>自定义<br>5、如何实现一个自定义的servlet?<br>extends HttpServlet 并覆盖doPost或doGet方法</p><p>在web.xml中进行部署<br>6、Servlet的生命周期是什么?<br>Init<br>多次执行doGet或doPost<br>destroy<br>7、jsp就是一个servlet是否正确?<br>对<br>8、请罗列jsp中的脚本、指令及动作?<br>脚本<br>&lt;%%&gt; &lt;%=%&gt; &lt;%!%&gt; &lt;%—-%&gt;<br>指令<br>&lt;%@page contentType=”text/html;charset=utf-8” language=”java” import=””%&gt;<br>&lt;%@include file=””%&gt;<br>&lt;%@taglib uri=”” prefix=””%&gt;<br>动作:<br>&lt;jsp:useBean class=”” id=”” scope=””&gt; 在scope中如果没有实例化一个对象，如果有直接用以前的。<br>&lt;jsp:getProperty name=”” property=””&gt; 向一个bean中设置属性值<br>&lt;jsp:forward &gt; jsp页的转发<br>&lt;jsp:include page=””&gt; 导入一个jsp页面<br>9、JSP的内置对象及方法<br>Request request表示HttpServletRequest对象。取客户端表单域信息及cookie, header, 和session<br>response response表示HttpServletResponse对象，对客户端的响应返回文本、写cookies。<br>out out 向客户端打印html文本.<br>pageContext :当前jsp页面的上下文环境，可以得到session、request、application等内置对象，在自定义标签中使用的很多。<br>session session表示一个请求的javax.servlet.http.HttpSession对象。Session一个用户多个页面共享同一变量。<br>application applicaton 表示一个javax.servle.ServletContext对象。存放容器级的变量。<br>config config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。<br>page page表示从该页面产生的一个servlet实例<br>exception:异常，当iserrorpage=true<br>10、说出在JSP页面里是怎么分页的?<br>页面需要保存以下参数：(数据库的分页及比较)<br>总行数：根据sql语句得到总行数<br>每页显示行数：设定值<br>当前页数：请求参数<br>页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。</p><p>数据库:<br>Sqlserver:<br>SELECT TOP 页大小 *<br>FROM TestTable</p><p>WHERE (ID NOT IN<br>(SELECT TOP 页大小*(页数-1) id<br>FROM 表<br>ORDER BY id))<br>ORDER BY ID</p><p>–pageSize=5 页大小<br>–pageIndex=2 所要的页<br>–如果有主键可以，没以及键不行<br>select top 5 *<br>from aa where a1 not in<br>(select top 5 a1 from aa order by a1)<br>order by a1;</p><p>oracle:<br>select * from ‘||v_sql||’ where rownum&lt;’||<br>pageLastRow||’minus select * from ‘||v_sql<br>||’ where rownum&lt;’||pageFirstRow;</p><p>Session<br>先取出数据中的所有信息封装到对象并保存在session中，转发到jsp页面做如下处理。<br><table border="1"><br><tr><br><td>a1</td><br><td>a2</td><br></tr><br>&lt;%<br>List l=(List)session.getAttribute(“as”);<br>//一页显示多少行<br>int pageSize=3;<br>//总页数<br>int pageCount=0;<br>int currentPage=1;<br>if(l!=null &amp;&amp; l.size()&gt;0)<br>{<br>pageCount=(l.size()/pageSize)+(l.size()%pageSize==0?0:1);<br>if(request.getParameter(“page”)!=null)<br>{<br>currentPage=Integer.parseInt(request.getParameter(“page”));<br>}<br>if(currentPage&lt;1)<br>{<br>currentPage=1;<br>}<br>if(currentPage&gt;pageCount)<br>{<br>currentPage=pageCount;<br>}<br>for (int i = (currentPage-1)*pageSize; i &lt;(currentPage-1)*pageSize+pageSize; i++)<br>{<br>if(i&gt;=l.size())<br>{<br>break;<br>}<br>Aa aa=(Aa)l.get(i);<br>%&gt;<br><tr><br><td>&lt;%=aa.getA1()%&gt;</td><br><td>&lt;%=aa.getA2()%&gt;</td><br></tr><br>&lt;%<br>}<br>}<br>%&gt;</table></p><tr><td colspan="2"> <%
    if(currentPage!=1)
    {
    %> <a href="page.jsp?page=1">首页</a>&nbsp;&nbsp; <a href="page.jsp?page=<%=currentPage-1%>">上一页</a>&nbsp;&nbsp; <%
    }
    if(currentPage!=pageCount)
    {
    %> <a href="page.jsp?page=<%=currentPage+1%>">下一页</a>&nbsp;&nbsp; <a href="page.jsp?page=<%=pageCount%>">最后一页</a>&nbsp;&nbsp; <%
    }
    %> </td></tr><p>11、include的两种实现方式的区别?<br>&lt;@include file&gt;:在将jsp生成servlet类前将两个文件和在一起，生成一个java类，一起运行的。所以是一家子，当中的变量名不能重名。<br>&lt;jsp:include page&gt;:是两个类，是一个调用关系，在运行时动态的调用，不是一家子，可以重复变量。<br>12、jsp页面中两种跳转方式分别是什么?有什么区别?<br>转发: 保留上次的request<br><a href="jsp:forward">jsp:forward</a><br>actionMapping.findForWard(“”);<br>pageContext.forward();<br>request.getRequestDispacher(“a.jsp”).forward(request,response)<br>跳转:不保留上次的request<br>Response.setRedirect(“”)<br>13、描述JSP和Servlet的区别、共同点、各自应用的范围<br>Jsp主要在于页面的显示动态生成页面，可以与html标记一起使用，其还是要生成为一个servlet。<br>Servlet：主要是控制的处理，如调用业务层，跳转不同的jsp页面。<br>Mvc:<br>Jsp:v<br>Servlet:c<br>14、在JSP中如何读取客户端的请求，如何确定某个Jsp文件的真实路径？<br>Request.getparameter(“”)<br>&lt;%=application.getRealPath(“aa.jsp”) %&gt;<br>15、描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。<br>Cookie:主要用在保存客户端，其值在客户端与服务端之间传送，不安全，存储的数据量有限。<br>Session:保存在服务端，每一个session在服务端有一个sessionID作一个标识。存储的数据量大，安全性高。占用服务端的内存资源。<br>16、说明Jsp中errorPage的作用，应用范围。<br>正常页面中<br>%@page erropage=”error.jsp”%<br>错误页面<br>&lt;%@page iserrorpage=”true”%&gt;<br>有一内置对象:exception<br>17、介绍在Jsp中如何使用JavaBeans<br>&lt;jsp:useBean class=”” id=”” scope=””/&gt;<br>&lt;%<br>New 类();<br>%&gt;<br>19、简单介绍JSP的标记库<br>做一个标记处理类 extends TagSupport<br>通过tld说明标记处理的类的前缀及后缀<br>在web.xml中说明tld文件<br><taglib><br><taglib-uri><br><taglib-location><br><taglib><br>在jsp页面是引用tld&lt;%@taglib uri=”” prefix=””%&gt;<br>20、Servlet中的核心类有那些，各有什么特点?<br>ServletContext：容器，放置全局变量<br>setAtribute()<br>getAttribute()<br>ServletConfig：一个servlet的配置<br>getInitParameter(”名称”)<br>HttpServletRequest：封装的所有的请求<br>getParameterValue(”名称”)<br>getParameterValues(”称”)<br>getSession();<br>getAttribute(” 名称”);<br>getRequestDispatch(”a.jsp”).forward(request,response)<br>HttpServletResponse：响应<br>getOut();<br>sendRedirect(””)<br>HttpSession：一个用户多个页面共享同一变量<br>setAttribute(””,””)<br>21、Servlet中重要的包有那些，有什么区别?<br>javax.servlet.<em>；javax.servlet.http.</em>;<br>22、说出Servlet的生命周期，并说出Servlet和CGI的区别？<br>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</taglib></taglib-location></taglib-uri></taglib></p><p>与cgi的区别在于servlet处理服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。<br>23、什么情况下调用doGet()和doPost()？<br>Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。<br>25、如何现实servlet的单线程模式<br>在doGet及doPost方法前加入synchoronized<br>JSP:<br>&lt;%@ page isThreadSafe=”true”%&gt;<br>27、Request对象的主要方法：<br>setAttribute(String name,Object)：设置名字为name的request的参数值<br>getAttribute(String name)：返回由name指定的属性值<br>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的Body的长度<br>实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例<br>getParameterValues(String name)：获得有name指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的IP地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性<br>28、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？<br>Public String translate (String str) {<br>String tempStr = “”;<br>try {<br>tempStr = new String(str.getBytes(“ISO-8859-1”), “GBK”);<br>tempStr = tempStr.trim();<br>}<br>catch (Exception e) {<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}</p><p>30、Servlet执行时一般实现哪几个方法?<br>public void init(ServletConfig config)<br>public ServletConfig getServletConfig()<br>public String getServletInfo()<br>public void service(ServletRequest request,ServletResponse response)<br>public void destroy()</p><p>31<br>1.jsp有哪些内置对象?作用分别是什么：<br>答:JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：<br>request 用户端请求，此请求会包含来自GET/POST请求的参数<br>response 网页传回用户端的回应<br>pageContext 网页的属性是在这里管理<br>session 与请求有关的会话期<br>application servlet 正在执行的内容<br>out 用来传送回应的输出<br>config servlet的构架部件<br>page JSP网页本身<br>exception 针对错误网页，未捕捉的例外。<br>2.jsp有哪些动作?作用分别是什么：<br>答:JSP共有以下6种基本动作<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个JavaBean。<br>jsp:setProperty：设置JavaBean的属性。<br>jsp:getProperty：输出某个JavaBean的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。<br>3.JSP中动态INCLUDE与静态INCLUDE的区别：<br>答：动态INCLUDE用jsp:include动作实现<br>&lt;jsp:include page=”included.jsp” flush=”true” /&gt;它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数<br>静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面<br>&lt;%@ include file=”included.htm” %&gt;。<br>4.两种跳转方式分别是什么?有什么区别：<br>答：有两种，分别为：<br>&lt;jsp:include page=”included.jsp” flush=”true”&gt;<br>&lt;jsp:forward page= “nextpage.jsp”/&gt;<br>前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。<br>5.说一说Servlet的生命周期：<br>答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。<br>6.JAVA SERVLET API中forward() 与redirect()的区别：<br>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。</p><p>16.MVC的各个部分都有那些技术来实现?如何实现：<br>答:MVC是Model－View－Controller的简写。”Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， “View” 是应用的表示面（由JSP页面产生），”Controller” 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。<br>17.J2EE是什么：<br>答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。<br>18.WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释：<br>答：Web Service描述语言WSDL<br>SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。<br>UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。<br>19.STRUTS的应用(如STRUTS架构) ：<br>答：Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能：<br>一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。<br>二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。<br>三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。<br>20.开发中都用到了那些设计模式?用在什么场合：<br>答：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。<br>30.JSP的内置对象及方法:<br>request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法,response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等）.<br>out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。<br>session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息 applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息 config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 page表示从该页面产生的一个servlet实例。<br>31.JSP的常用指令：<br>&lt;%@page language=”java” contenType=”text/html;charset=gb2312” session=”true” buffer=”64kb” autoFlush=”true” isThreadSafe=”true” info=”text” errorPage=”error.jsp” isErrorPage=”true” isELIgnored=”true” pageEncoding=”gb2312” import=”java.sql.*”%&gt;<br>isErrorPage(是否能使用Exception对象)，isELIgnored(是否忽略表达式) &lt;%@include file=”filename”%&gt;&lt;%@taglib prefix=”c”uri=”http://……”%&gt;<br>32.四种会话跟踪技术：<br>cookie,url重写,session,隐藏域。<br>33.Request对象的主要方法：<br>setAttribute(String name,Object)：设置名字为name的request的参数值<br>getAttribute(String name)：返回由name指定的属性值<br>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的Body的长度<br>getHeader(String name)：获得HTTP协议定义的文件头信息<br>getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例<br>getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例<br>getParameterValues(String name)：获得有name指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的IP地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性<br>34.J2EE是技术还是平台还是框架：<br>J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br>J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。<br>35.EJB的角色和三个对象：<br>一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性。这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类<br>36.EJB容器提供的服务：<br>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。<br>37.EJB规范规定EJB中禁止的操作有哪些：<br>1.不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，<br>2.不能操作awt，<br>3.不能实现服务器功能，<br>4.不能对静态属生存取，<br>5.不能使用IO操作直接存取文件系统，<br>6.不能加载本地库.，<br>7.不能将this作为变量和返回，<br>8.不能循环调用。<br>51.说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法：<br>Session Facade Pattern：使用SessionBean访问EntityBean；Message Facade Pattern：实现异步调用；EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问；Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性；Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性；Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性；ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率。项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。<br>52.说说在weblogic中开发消息Bean时的persistent与non-persisten的差别：<br>persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来，而non－persistent方式的消息将被丢弃。<br>53.常用的设计模式？说明工厂模式：<br>Java中的23种设计模式：Factory（工厂模式），Builder（建造模式）， Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）。<br>工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。<br>54.MVC的各个部分都有那些技术来实现?如何实现：<br>MVC是Model－View－Controller的简写。”Model” 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， “View” 是应用的表示面（由JSP页面产生），”Controller” 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。<br>55.UML方面：<br>标准建模语言UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。<br>56.说出一些常用的类，包，接口，请各举5个常用的类：<br>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer；<br>常用的包：java.lang java.awt java.io java.util java.sql；<br>常用的接口：Remote List Map Document NodeList<br>57.开发中都用到了那些设计模式?用在什么场合:<br>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。<br>58.jsp有哪些动作?作用分别是什么：<br>JSP共有以下6种基本动作：<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个JavaBean。<br>jsp:setProperty：设置JavaBean的属性。<br>jsp:getProperty：输出某个JavaBean的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。<br>59.应用服务器与WEB SERVER的区别：<br>应用服务器：Weblogic、Tomcat、Jboss； WEB SERVER：IIS、 Apache<br>60.BS与CS的联系与区别：<br>C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C/S 与 B/S 区别：<br>１．硬件环境不同: C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行<br>２．对安全要求不同 ：C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息.B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同 ：　C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟.<br>４．软件重用不同： C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好.　B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。<br>５．系统维护不同 ：C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.<br>６．处理问题不同 ：C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小.<br>７．用户接口不同： C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.<br>８．信息流不同 ：　C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心</p><p>19、forward 和redirect的区别forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。<br>3、JAVA SERVLET API中forward() 与redirect()的区别？<br>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。<br>1..描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理<br>Session用于保存每个用户的专用信息. 每个客户端用户访问时，服务器都为每个用户分配一个唯一的会话ID（Session ID) . 她的生存期是用户持续请求时间再加上一段时间(一般是20分钟左右).Session中的信息保存在Web服务器内容中,保存的数据量可大可小.当 Session超时或被关闭时将自动释放保存的数据信息.由于用户停止使用应用程序后它仍然在内存中保持一段时间,因此使用Session对象使保存用户数据的方法效率很低.对于小量的数据,使用Session对象保存还是一个不错的选择<br>Cookie 用于保存客户浏览器请求服务器页面的请求信息,程序员也可以用它存放非敏感性的用户信息，信息保存的时间可以根据需要设置.如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止.如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期.Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据.由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性<br>session工作原理<br>(1)当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。<br>(2)然后，服务器开辟一块内存，对应于该Session ID。<br>(3)服务器再将该Session ID写入浏览器的cookie。<br>(4)服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。<br>(5)当浏览器连入IIS时并请求的ASP内用到Session时，IIS就读浏览器Cookie中的Session ID。<br>(6)然后，服务检查该Session ID所对应的内存是否有效。<br>(7)如果有效，就读出内存中的值。<br>(8)如果无效，就建立新的Session。<br>2.Servlet的生命周期分为3个阶段:? 和CGI的区别？<br>Servlet的生命周期主要由3个过程组成。<br>(1)init()方法：服务器初始化servlet。<br>(2)service()方法：初始化完毕，servlet对象调用该方法响应客户的请求。<br>(3)destroy()方法：调用该方法消灭servlet对象。<br>其中，init()方法只在servlet第一次被请求加载的时候被调用一次，当有客户再请求servlet服务时，web服务器将启动一个新的线程，在该线程中，调用service方法响应客户的请求。<br>与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</p><p>3.forward与redirect 的区别?有哪些方式实现<br>1）.<a href="jsp:forward">jsp:forward</a>重定向后url地址栏地址不变还是原来的地址；而response.sendRedirect()重定向后url地址栏地址显示的请求后的新地址。<br>2）.<a href="jsp:forward">jsp:forward</a>重定向的时候可以保存回话信息，因此可以使用request来进行参数传递，在新页面可以使用request.getAttribute ()来得到参数。而response.sendRedirect()不支持此通过request进行参数传递。它唯一的传值方式为response.sendRedirect(“example.jsp?aa=123”)，在新的页面通过request.getParameter(“aa”)来得到参数值<br>3）.Tomcat的class加载的优先顺序一览<br>1.最先是$JAVA_HOME/jre/lib/ext/下的jar文件。<br>2.环境变量CLASSPATH中的jar和class文<br>3.$CATALINA_HOME/common/classes下的class<br>4.$CATALINA_HOME/commons/endorsed下的jar文件。<br>5.$CATALINA_HOME/commons/i18n下的jar文件。<br>6.$CATALINA_HOME/common/lib 下的jar文件。<br>（JDBC驱动之类的jar文件可以放在这里，这样就可以避免在server.xml配置好数据源却出现找不到JDBC Driver的情况。）<br>7.$CATALINA_HOME/server/classes下的class文件。<br>8.$CATALINA_HOME/server/lib/下的jar文件。<br>9.$CATALINA_BASE/shared/classes 下的class文件。<br>10.$CATALINA_BASE/shared/lib下的jar文件。<br>11.各自具体的webapp /WEB-INF/classes下的class文件。<br>12.各自具体的webapp /WEB-INF/lib下的jar文件。</p><p>4）.CS与BS联系区别<br>1）java适合开发bs结构，cs不是它的强项 C/S 服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。B/S 客户机上只要安装一个浏览器（Browser），如Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Web Server 同数据库进行数据交互 1．硬件环境不同: C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务. B/S 建立在广域网之上的<br>2）对安全要求不同 C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息. B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户<br>3）对程序架构不同 C/S 程序可以更加注重流程, 可以对权限多层次校验 B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上</p><p>4.解释一下mvc以及熟悉的mvc框架<br>答:m代表模型层，v 代表视图层，c代表控制层，也就是把一个整体分割成不同的模块，各负责自己的功能，分工明确，提高代码的重用性和方便维护。<br>在jsp设计模式二中，jsp用来做视图层，servlet是控制器，dao则处理相关业务成为模型层。<br>在struts2.0,其中m是action,c是拦截器，v是jsp.</p><p>5.浏览器页面与T0MCat的交互过程？<br>当一个JSP页面第一次被访问的时候，JSP引擎将执行以下步骤：<br>（1）将JSP页面翻译成一个Servlet，这个Servlet是一个java文件，同时也是一个完整的java程序<br>（2）JSP引擎调用java编译器对这个Servlet进行编译，得到可执行文件class<br>（3）JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户端<br>以上三个步骤仅仅在JSP页面第一次被访问时才会执行，以后的访问速度会因为class文件已经生成而大大提高。当JSP引擎街道一个客户端的访问请求时，首先判断请求的JSP页面是否比对应的Servlet新，如果新，对应的JSP需要重新编译。</p><p>6.JSP内置对象作用，如何取Cookie的方法<br>使用request对象的getCookies()方法取cookies<br>(1) HttpServletRequest类的Request对象<br>作用：代表请求对象，主要用于接受客户端通过HTTP协议连接传输到服务器端的数据。<br>(2) HttpServletResponse类的Respone对象<br>作用：代表响应对象，主要用于向客户端发送数据<br>(3) JspWriter类的out对象<br>作用：主要用于向客户端输出数据;<br>        Out的基类是JspWriter<br>(4) HttpSession类的session对象<br>作用：主要用于来分别保存每个用户信息，与请求关联的会话；<br>    会话状态维持是Web应用开发者必须面对的问题。<br>(5) ServletContext类的application对象<br>作用：主要用于保存用户信息，代码片段的运行环境；<br>    它是一个共享的内置对象，即一个容器中的多个用户共享一个application对象，故其保存的信息被所有用户所共享.<br>(6) PageContext类的PageContext对象<br>作用：管理网页属性,为JSP页面包装页面的上下文，管理对属于JSP中特殊可见部分中已命名对象的访问，它的创建和初始化都是由容器来完成的。<br>(7) ServletConfig类的Config对象<br>作用：代码片段配置对象，表示Servlet的配置。<br>(8) Object类的Page（相当于this）对象<br>作用：处理JSP网页，是Object类的一个实例，指的是JSP实现类的实例，即它也是JSP本身，只有在JSP页面范围之内才是合法的。<br>(9)Exception<br>作用：处理JSP文件执行时发生的错误和异常<br>7.JAVA事件有哪些模式？<br>1.事件直接驱动模式。它的第一个要求就是性能的要求，需要直接而且快，是必须经常使用的，主要适合于迅速处理 前台的命令，往往是系统架构的重要部分，也是流程控制的主要模式。2.监控式事件模式是借助第三者来监控和触发事件，特点是： 有一个观察者置身事外在定期独立运行着。<br>2.uml三要素.<br>事物、关系、图</p><p>8.jsp与servlet中请求转发的区别<br>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址，但此转发是连续的转发，在转发过程中请求参数也连续转发到目标地址中。<br>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求。前者对请求是连续的，后者是重新发送一个新的请求，所以只能重新发送新的请求参数，原有的请求参数将不再连续到目标页面。<br>9.Session的具体用法？<br>Session用来保存每一个用户的专有信息，比如像用户登录验证、购物车。<br>1.ibatis 中的#与$的区别<br>1.#是把传入的数据当作字符串，如#field#传入的是id,则sql语句生成是这样，order by “id”,这当然会报错．．<br>2.$传入的数据直接生成在sql里，如#field#传入的是id,则sql语句生成是这样，order by id, 这就对了．<br>3.#方式能够很大程度防止sql注入．<br>4.$方式无法方式sql注入．<br>5.$方式一般用于传入数据库对象．例如传入表名.<br>6.一般能用#的就别用$.</p><p>10.请裂举session、cookie、viewstated的应用范围<br>Session 服务器端维护， 某个用户活动时间 + 延迟时间（默认20分钟），<br>Cookie 客户端维护， 程序可指定生命周期，<br>ViewState 小量数据，一个web页面的生命期</p><ol start="11"><li>用什么方法使服务器关闭之后，session所保存的信息不会丢失？<br>将session信息保存到数据库中或文件中</li></ol><p>　1. 写客户端Cookie的方式<br>　　当用户登陆成功以后，把网站域名、用户名、密码、token、session有效时间全部采用cookie的形式写入到客户端的cookie里面，如果用户从一台Web服务器跨越到另一台服务器的时候，我们的程序主动去检测客户端的cookie信息，进行判断，然后提供对应的服务，当然，如果cookie过期，或者无效，自然就不让用户继续服务了。当然，这种方法的弊端就不言而喻了，比如客户端禁用了cookie或者cookie被黑客窃取了呢？<br>　　2. 服务器之间Session数据同步的方式<br>　　假设Web服务器A是所有用户登陆的服务器，那么当用户验证登陆一下，session数据就会写到A服务器里，那么就可以自己写脚本或者守护进程来自动把session数据同步到其他Web服务器，那么当用户跳转到其他服务器的时候，那么session数据是一致的，自然就能够直接进行服务无须再次登陆了。缺点是，可能会速度慢，不稳定，如果是单向同步的话，登陆服务器出现问题，那么其他服务器也无法服务，当然也可以考虑双向同步的问题。<br>　　3. 利用NFS共享Session数据的方式<br>　　其实这个方案和下面的Mysql方案类似，只是存储方式不一样。大致就是有一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台NFS服务器上的，不论用户访问那太Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了。缺点是依赖性太强，如果NFS服务器down掉了，那么大家都无法工作了，当然，可以考虑多台NFS服务器同步的形式。</p><p>　　4. 利用Mysql数据库共享Session数据的方式<br>　　这个方式与NFS的方式类似，也是采用一台Mysql服务器做共享服务器，把所有的session的数据保存到Mysql服务器上，所有Web服务器都来这台Mysql服务器来获取Session数据。缺点也是依赖性太强，Mysql无法工作了影响所有的Web服务器，当然，可以考虑多太Mysql数据库来共享session，使用同步Mysql数据的方式。<br>　　5. 使用硬件设备<br>　　这个算是比较成熟的解决方案了，使用类似BIG-IP的负载设备来实现资源共享，那么就能够又稳定又合理的的共享Session了。目前很多门户网站采用这种方式。缺点很明显了，就是要收费了，硬件设备肯定需要购买成本的，不过对于专业或者大型应用来讲，是比较合理并且值得的。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java-web/" rel="tag"># Java web</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/32257fddc744.html" rel="prev" title="数据库"><i class="fa fa-angle-left"></i> 数据库</a></div><div class="post-nav-item"><a href="/publishes/ff5236f93fe2.html" rel="next" title="项目设计">项目设计 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>