<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="什么是AOP AOP(Aspect-Oriented Programming), 即 面向切面编程 在软件开发过程中，跨越应用程序多个点的功能称为交叉问题 这些交叉问题与应用程序的主要业务逻辑不同 因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。  Spring中Bean的⽣命周期。 Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅"><meta property="og:type" content="article"><meta property="og:title" content="Spring"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="什么是AOP AOP(Aspect-Oriented Programming), 即 面向切面编程 在软件开发过程中，跨越应用程序多个点的功能称为交叉问题 这些交叉问题与应用程序的主要业务逻辑不同 因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。  Spring中Bean的⽣命周期。 Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T08:03:58.000Z"><meta property="article:modified_time" content="2023-12-27T09:13:50.944Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="spring"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html","path":"publishes/c9fa4a3e43dd.html","title":"Spring"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Spring | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOP"><span class="nav-number">1.</span> <span class="nav-text">什么是AOP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%B8%ADBean%E7%9A%84%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%82"><span class="nav-number">2.</span> <span class="nav-text">Spring中Bean的⽣命周期。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-AOP%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">Spring AOP解决了什么问题？怎么实现的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F%E5%AE%83%E4%BC%9A%E5%BD%B1%E5%93%8D%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">Spring事务的传播属性是怎么回事？它会影响什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%B8%ADBeanFactory%E5%92%8CFactoryBean%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">Spring中BeanFactory和FactoryBean有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanFactory"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">BeanFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FactoryBean"><span class="nav-number">5.0.0.2.</span> <span class="nav-text">FactoryBean</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%ADIOC%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">Spring框架中IOC的原理是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E2%BC%8A%E6%9C%89%E5%93%AA%E2%BC%8F%E7%A7%8D%E2%BD%85%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">spring的依赖注⼊有哪⼏种⽅式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BD%A4Spring%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E2%BC%80%E4%B8%AA%E5%88%87%E2%BE%AF%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">⽤Spring如何实现⼀个切⾯？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">Spring如何实现数据库事务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%8A%A0%E8%BD%BD%E6%AC%A1%E5%BA%8FClassloader"><span class="nav-number">10.</span> <span class="nav-text">Spring加载次序Classloader</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8EDI%E4%BE%9D%E8%B5%96%E6%B3%A8%E2%BC%8A"><span class="nav-number">11.</span> <span class="nav-text">IOC控制反转与DI依赖注⼊</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E5%86%99%E5%87%BA%E5%B8%B8%E2%BD%A4%E7%9A%84%E2%BC%8F%E4%B8%AA%E4%BA%8B%E4%BB%B6%E3%80%82"><span class="nav-number">12.</span> <span class="nav-text">spring事件的实现原理，写出常⽤的⼏个事件。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Framework%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">什么是 Spring Framework？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E4%B8%BE-Spring-Framework-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">14.</span> <span class="nav-text">列举 Spring Framework 的优点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Framework-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">Spring Framework 有哪些不同的功能？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Framework-%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">Spring Framework 中有多少个模块，它们分别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">什么是 Spring 配置文件？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">Spring 应用程序有哪些不同组件？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Spring-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">使用 Spring 有哪些方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-IOC-%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">什么是 Spring IOC 容器？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">什么是依赖注入？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D-IOC-%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">spring 中有多少种 IOC 容器？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E4%B8%BE-IoC-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%BD%E5%A4%84%E3%80%82"><span class="nav-number">23.</span> <span class="nav-text">列举 IoC 的一些好处。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-IoC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E3%80%82"><span class="nav-number">24.</span> <span class="nav-text">Spring IoC 的实现机制。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-bean%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">什么是 spring bean？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">spring 提供了哪些配置方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-%E6%94%AF%E6%8C%81%E9%9B%86%E4%B8%AD-bean-scope%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">spring 支持集中 bean scope？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-bean-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">spring bean 容器的生命周期是什么样的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-%E7%9A%84%E5%86%85%E9%83%A8-bean%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">什么是 spring 的内部 bean？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-%E8%A3%85%E9%85%8D"><span class="nav-number">30.</span> <span class="nav-text">什么是 spring 装配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">自动装配有哪些方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%B1%80%E9%99%90%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">自动装配有什么局限？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">33.</span> <span class="nav-text">什么是基于注解的容器配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-spring-%E4%B8%AD%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">如何在 spring 中启动注解装配？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Component-Controller-Repository-Service-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">@Component, @Controller, @Repository, @Service 有何区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Required-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">@Required 注解有什么用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Autowired-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">@Autowired 注解有什么用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Qualifier-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">38.</span> <span class="nav-text">@Qualifier 注解有什么用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RequestMapping-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">@RequestMapping 注解有什么用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-DAO-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">spring DAO 有什么用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-JDBC-API-%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">spring JDBC API 中存在哪些类？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Spring-%E8%AE%BF%E9%97%AE-Hibernate-%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">42.</span> <span class="nav-text">使用 Spring 访问 Hibernate 的方法有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E4%B8%BE-spring-%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="nav-number">43.</span> <span class="nav-text">列举 spring 支持的事务管理类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B-ORM-%E6%A1%86%E6%9E%B6"><span class="nav-number">44.</span> <span class="nav-text">spring 支持哪些 ORM 框架</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E5%87%BA%E5%9C%A8-spring-aop-%E4%B8%AD-concern-%E5%92%8C-cross-cutting-concern-%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E3%80%82"><span class="nav-number">45.</span> <span class="nav-text">指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOP-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">46.</span> <span class="nav-text">AOP 有哪些实现方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-AOP-and-AspectJ-AOP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">47.</span> <span class="nav-text">Spring AOP and AspectJ AOP 有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">如何理解 Spring 中的代理？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E7%BB%87%EF%BC%88Weaving%EF%BC%89%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">什么是编织（Weaving）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-WebApplicationContext"><span class="nav-number">50.</span> <span class="nav-text">介绍一下 WebApplicationContext</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IoC-%E5%92%8C-DI%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">IoC 和 DI的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BeanFactory-%E6%8E%A5%E5%8F%A3%E5%92%8C-ApplicationContext-%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">BeanFactory 接口和 ApplicationContext 接口有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E9%85%8D%E7%BD%AEbean%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">spring配置bean实例化有哪些方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%B4%E4%B8%80%E4%B8%8Bspring%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="nav-number">54.</span> <span class="nav-text">简单的说一下spring的生命周期？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSpring%E6%A1%86%E6%9E%B6%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">55.</span> <span class="nav-text">请介绍一下Spring框架中Bean的生命周期和作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">Spring的核心类有哪些，各有什么作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E9%87%8C%E9%9D%A2applicationContext-xml%E6%96%87%E4%BB%B6%E8%83%BD%E4%B8%8D%E8%83%BD%E6%94%B9%E6%88%90%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%9F"><span class="nav-number">57.</span> <span class="nav-text">Spring里面applicationContext.xml文件能不能改成其他文件名？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">58.</span> <span class="nav-text">Spring如何处理线程并发问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSpring%E7%9A%84%E4%BA%8B%E7%89%A9%E7%AE%A1%E7%90%86"><span class="nav-number">59.</span> <span class="nav-text">介绍一下Spring的事物管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOP-%E9%80%9A%E7%9F%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">60.</span> <span class="nav-text">AOP 通知有哪些类型？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring"><span class="nav-number">61.</span> <span class="nav-text">什么是 spring?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">62.</span> <span class="nav-text">使用 Spring 框架的好处是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ApplicationContext-%E9%80%9A%E5%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">63.</span> <span class="nav-text">ApplicationContext 通常的实现是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA-Spring-%E7%9A%84%E5%BA%94%E7%94%A8%E7%9C%8B%E8%B5%B7%E6%9D%A5%E8%B1%A1%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">64.</span> <span class="nav-text">一个 Spring 的应用看起来象什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%AA%E7%A7%8D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E4%BD%A0%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%EF%BC%8C%E8%BF%98%E6%98%AF-Setter-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="nav-number">65.</span> <span class="nav-text">哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-beans%EF%BC%9F"><span class="nav-number">66.</span> <span class="nav-text">什么是 Spring beans？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA-Spring-Bean-%E5%AE%9A%E4%B9%89-%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">67.</span> <span class="nav-text">一个 Spring Bean 定义 包含什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99-Spring-%E5%AE%B9%E5%99%A8%E6%8F%90%E4%BE%9B%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">68.</span> <span class="nav-text">如何给 Spring 容器提供配置元数据？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E6%80%8E%E6%A0%B7%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="nav-number">69.</span> <span class="nav-text">你怎样定义类的作用域？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">70.</span> <span class="nav-text">Spring 框架中的单例 bean 是线程安全的吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%98%AF%E9%87%8D%E8%A6%81%E7%9A%84-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%EF%BC%9F-%E4%BD%A0%E8%83%BD%E9%87%8D%E8%BD%BD%E5%AE%83%E4%BB%AC%E5%90%97%EF%BC%9F"><span class="nav-number">71.</span> <span class="nav-text">哪些是重要的 bean 生命周期方法？ 你能重载它们吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-Spring-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AA-java-%E9%9B%86%E5%90%88%EF%BC%9F"><span class="nav-number">72.</span> <span class="nav-text">在 Spring 中如何注入一个 java 集合？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%9F"><span class="nav-number">73.</span> <span class="nav-text">自动装配有哪些局限性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%9C%A8-Spring-%E4%B8%AD%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AA-null-%E5%92%8C%E4%B8%80%E4%B8%AA%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%97%EF%BC%9F"><span class="nav-number">74.</span> <span class="nav-text">你可以在 Spring 中注入一个 null 和一个空字符串吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9B%B4%E6%9C%89%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8-JDBC%EF%BC%9F"><span class="nav-number">75.</span> <span class="nav-text">在 Spring 框架中如何更有效地使用 JDBC？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-%E5%AF%B9-DAO-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">76.</span> <span class="nav-text">Spring 对 DAO 的支持</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-HibernateDaoSupport-%E5%B0%86-Spring-%E5%92%8C-Hibernate-%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5%EF%BC%9F"><span class="nav-number">77.</span> <span class="nav-text">如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8spring%E7%9A%84applicationContext-xml%E4%BD%BF%E7%94%A8JNDI%E8%80%8C%E4%B8%8D%E6%98%AFDataSource"><span class="nav-number">78.</span> <span class="nav-text">如何在spring的applicationContext.xml使用JNDI而不是DataSource</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8spring%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E7%9A%84"><span class="nav-number">79.</span> <span class="nav-text">在spring中是如何配置数据库驱动的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8web%E4%B8%AD%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEspring"><span class="nav-number">80.</span> <span class="nav-text">在web中如何配置spring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8spring%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89hibernate-Mapping%EF%BC%9F"><span class="nav-number">81.</span> <span class="nav-text">在spring中如何定义hibernate Mapping？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEspring-struts%EF%BC%9F"><span class="nav-number">82.</span> <span class="nav-text">如何配置spring + struts？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8spring%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">83.</span> <span class="nav-text">如何在spring中实现国际化?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8spring%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">84.</span> <span class="nav-text">在spring中如何实现事件处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86spring%E5%8A%A0%E5%85%A5web%E5%AE%B9%E5%99%A8%E4%B8%AD"><span class="nav-number">85.</span> <span class="nav-text">如何将spring加入web容器中</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">86.</span> <span class="nav-text">Spring如何实现资源管理?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E7%9A%84ApplicationContext%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">87.</span> <span class="nav-text">Spring的ApplicationContext的作用?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hibernate%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%EF%BC%9F"><span class="nav-number">88.</span> <span class="nav-text">Hibernate工作原理及为什么要用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96bean"><span class="nav-number">89.</span> <span class="nav-text">Spring中如何获取bean</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8BBeans%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="nav-number">90.</span> <span class="nav-text">Spring框架中的单例Beans是线程安全的么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%91Spring-Bean%E4%B8%AD%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AAJava-util-Properties%EF%BC%9F"><span class="nav-number">91.</span> <span class="nav-text">如何向Spring Bean中注入一个Java.util.Properties？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="nav-number">92.</span> <span class="nav-text">Spring框架中有哪些不同类型的事件？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FileSystemResource%E5%92%8CClassPathResource%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">93.</span> <span class="nav-text">FileSystemResource和ClassPathResource有何区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">94.</span> <span class="nav-text">Spring 框架中都用到了哪些设计模式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8-Spring-%E7%9A%84%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF"><span class="nav-number">95.</span> <span class="nav-text">开发中主要使用 Spring 的什么技术 ?</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">28</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">47</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Spring | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Spring</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:03:58" itemprop="dateCreated datePublished" datetime="2023-12-20T16:03:58+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-27 17:13:50" itemprop="dateModified" datetime="2023-12-27T17:13:50+08:00">2023-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>25k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>22 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><ul><li>AOP(Aspect-Oriented Programming), 即 面向切面编程</li><li>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题</li><li>这些交叉问题与应用程序的主要业务逻辑不同</li><li>因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。</li></ul><h1 id="Spring中Bean的⽣命周期。"><a href="#Spring中Bean的⽣命周期。" class="headerlink" title="Spring中Bean的⽣命周期。"></a>Spring中Bean的⽣命周期。</h1><ul><li>Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅法-》调⽤InitializationBean的afterPropertiesSet()的⽅法-》调⽤定制的初始化⽅法callCustom的init-method-》调⽤BeanPostProsessor的后初始化⽅法-》Bean可以使⽤了 -》 容器关闭-》 调⽤DisposableBean的destroy⽅法-》调⽤定制的销毁⽅法CallCustom的destroy-method。</li><li>Spring对Bean进⾏实例化（相当于程序中的new Xx()）</li><li>Spring将值和Bean的引⽤注⼊进Bean对应的属性中</li><li>如果Bean实现了BeanNameAware接⼝，Spring将Bean的ID传递给setBeanName()⽅法（实现BeanNameAware清主要是为了通过Bean的引⽤来获得Bean的ID，⼀般业务中是很少有⽤到Bean的ID的）</li><li>如果Bean实现了BeanFactoryAware接⼝，Spring将调⽤setBeanDactory(BeanFactory bf)⽅法并把BeanFactory容器实例作为参数传⼊。（实现BeanFactoryAware 主要⽬的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</li><li>如果Bean实现了ApplicationContextAwaer接⼝，Spring容器将调⽤setApplicationContext(ApplicationContext ctx)⽅法，把y应⽤上下⽂作为参数传⼊.(作⽤与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调⽤setApplicationContext⽅法时会把它⾃⼰作为setApplicationContext 的参数传⼊，⽽Spring容器在调⽤setBeanDactory前需要程序员⾃⼰指定（注⼊）setBeanDactory⾥的参数BeanFactory )</li><li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessBeforeInitialization（预初始化）⽅法（作⽤是在Bean实例创建成功后对进⾏增强处理，如对Bean进⾏修改，增加某个功能）7.如果Bean实现了InitializingBean接⼝，Spring将调⽤它们的afterPropertiesSet⽅法，作⽤与在配置⽂件中对Bean使⽤init-method声明初始化的作⽤⼀样，都是在Bean的全部属性设置成功后执⾏的初始化⽅法。</li><li>如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessAfterInitialization（后初始化）⽅法（作⽤与7的⼀样，只不过7是在Bean初始化前执⾏的，⽽这个是在Bean初始化后执⾏的，时机不同 ）</li><li>经过以上的⼯作后，Bean将⼀直驻留在应⽤上下⽂中给应⽤使⽤，直到应⽤上下⽂被销毁</li><li>如果Bean实现了DispostbleBean接⼝，Spring将调⽤它的destory⽅法，作⽤与在配置⽂件中对Bean使⽤destory￾method属性的作⽤⼀样，都是在Bean实例销毁前执⾏的⽅法。</li></ul><h1 id="Spring-AOP解决了什么问题？怎么实现的？"><a href="#Spring-AOP解决了什么问题？怎么实现的？" class="headerlink" title="Spring AOP解决了什么问题？怎么实现的？"></a>Spring AOP解决了什么问题？怎么实现的？</h1><ul><li>作⽤<ul><li>AOP技术，利⽤⼀种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共⾏为封装到⼀个可重⽤模块，并将其名为“Aspect”，即⽅⾯</li><li>所谓“⽅⾯”，简单地说，就是将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li></ul></li><li>实现：<ul><li>⼀是采⽤动态代理技术，利⽤截取消息的⽅式，对该消息进⾏装饰，以取代原有对象⾏为的执⾏；</li><li>⼆是采⽤静态织⼊的⽅式，引⼊特定的语法创建“⽅⾯”，从⽽使得编译器可以在编译期间织⼊有关“⽅⾯”的代码。</li></ul></li><li>使⽤场景：<ul><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading　懒加载</li><li>Debugging　　调试</li><li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li><li>Performance optimization　性能优化</li><li>Persistence　　持久化</li><li>Resource pooling　资源池</li><li>Synchronization　同步</li><li>Transactions 事务</li></ul></li><li>⼏个概念：<ul><li>切⾯（Aspect）：对象操作过程中的截⾯，这可能是AOP中最为关键的术语。切⾯所要做的事就是专注于各⾃领域的逻辑实现，这样可以使得开发逻辑更加清晰，更加适合专业的分⼯合作。由于切⾯的隔离性，降低了耦合，这样就可以在不同的应⽤中将各个切⾯组合使⽤，从⽽是代码重⽤性⼤⼤增加。</li><li>连接点：程序运⾏过程中的某个阶段点，如某个⽅法的调⽤，或者异常的抛出。</li><li>处理逻辑（Advice）：在某⼀个连接点所采⽤的处理逻辑，处理逻辑的调⽤模式通常有三种：<ul><li>Around 在连接点前后插⼊预处理过程和后处理过程。</li><li>Before 仅在连接点钱出⼊处理过程。</li><li>Throw 在连接点抛出异常时进⾏异常处理。</li></ul></li><li>切点（PointCut）：⼀系列连接点的集合，它指明处理逻辑将在合适触发。</li></ul></li></ul><h1 id="Spring事务的传播属性是怎么回事？它会影响什么？"><a href="#Spring事务的传播属性是怎么回事？它会影响什么？" class="headerlink" title="Spring事务的传播属性是怎么回事？它会影响什么？"></a>Spring事务的传播属性是怎么回事？它会影响什么？</h1><ul><li>七个事务传播属性：<ul><li>PROPAGATION_REQUIRED – ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。</li><li>PROPAGATION_SUPPORTS – ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</li><li>PROPAGATION_MANDATORY – ⽀持当前事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATIONREQUIRESNEW – 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATIONNOTSUPPORTED – 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER – 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</li><li>PROPAGATIONNESTED – 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与PROPAGATIONREQUIRED类似的操作。</li></ul></li><li>五个隔离级别：<ul><li>ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.</li><li>另外四个与JDBC的隔离级别相对应：<ul><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数据。这种隔离级别会产⽣脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏读，不可重复读外，还避免了幻读。</li></ul></li></ul></li><li>关键词：<ul><li>幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；</li><li>不可重复读：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；</li><li>脏读：事务1更新了记录，但没有提交，事务2读取了更新后的⾏，然后事务T1回滚，现在T2读取⽆效。</li></ul></li></ul><h1 id="Spring中BeanFactory和FactoryBean有什么区别？"><a href="#Spring中BeanFactory和FactoryBean有什么区别？" class="headerlink" title="Spring中BeanFactory和FactoryBean有什么区别？"></a>Spring中BeanFactory和FactoryBean有什么区别？</h1><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul><li>以Factory结尾，表示它是⼀个⼯⼚类(接⼝)，⽤于管理Bean的⼀个⼯⼚</li><li>在Spring中，BeanFactory是IOC容器的核⼼接⼝，它的职责包括：实例化、定位、配置应⽤程序中的对象及建⽴这些对象间的依赖。</li></ul><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><ul><li>以Bean结尾，表示它是⼀个Bean，不同于普通Bean的是：它是实现了FactoryBean接⼝的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽不是FactoryBean本身</li><li>如果要获取FactoryBean对象，请在id前⾯加⼀个&amp;符号来获取。</li></ul><h1 id="Spring框架中IOC的原理是什么？"><a href="#Spring框架中IOC的原理是什么？" class="headerlink" title="Spring框架中IOC的原理是什么？"></a>Spring框架中IOC的原理是什么？</h1><ul><li>IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。</li><li>在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</li><li>在系统运⾏中，动态的向某个对象提供它所需要的其他对象。</li><li>依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li></ul><h1 id="spring的依赖注⼊有哪⼏种⽅式"><a href="#spring的依赖注⼊有哪⼏种⽅式" class="headerlink" title="spring的依赖注⼊有哪⼏种⽅式"></a>spring的依赖注⼊有哪⼏种⽅式</h1><ul><li>在Spring容器中为⼀个bean配置依赖注⼊有四种⽅式：<ul><li>使⽤属性的setter⽅法注⼊ 这是最常⽤的⽅式；</li><li>使⽤构造器注⼊；</li><li>使⽤Filed注⼊（⽤于注解⽅式）.</li><li>静态、实例⼯⼚的⽅法注⼊</li></ul></li></ul><h1 id="⽤Spring如何实现⼀个切⾯？"><a href="#⽤Spring如何实现⼀个切⾯？" class="headerlink" title="⽤Spring如何实现⼀个切⾯？"></a>⽤Spring如何实现⼀个切⾯？</h1><ul><li>@Aspect</li></ul><h1 id="Spring如何实现数据库事务？"><a href="#Spring如何实现数据库事务？" class="headerlink" title="Spring如何实现数据库事务？"></a>Spring如何实现数据库事务？</h1><ul><li>使⽤@Transactional注解或在配置⽂件⾥⾯配置</li></ul><h1 id="Spring加载次序Classloader"><a href="#Spring加载次序Classloader" class="headerlink" title="Spring加载次序Classloader"></a>Spring加载次序Classloader</h1><ul><li>先构造函数——&gt;然后是bean的set⽅法注⼊——&gt;InitializingBean的afterPropertiesSet⽅法——&gt;init-method⽅法；</li><li>InitializingBean接⼝为bean提供了初始化⽅法的⽅式，它只包括afterPropertiesSet⽅法，凡是继承该接⼝的类，在初始化bean的时候会执⾏该⽅法。系统则是先调⽤afterPropertiesSet⽅法，然后在调⽤init-method中指定的⽅法。</li><li>Spring装配Bean的过程：<ul><li>实例化;</li><li>设置属性值;</li><li>如果实现了BeanNameAware接⼝,调⽤setBeanName设置Bean的ID或者Name;</li><li>如果实现BeanFactoryAware接⼝,调⽤setBeanFactory 设置BeanFactory;</li><li>如果实现ApplicationContextAware,调⽤setApplicationContext设置ApplicationContext</li><li>调⽤BeanPostProcessor的预先初始化⽅法;</li><li>调⽤InitializingBean的afterPropertiesSet()⽅法;</li><li>调⽤定制init-method⽅法；</li><li>调⽤BeanPostProcessor的后初始化⽅法;</li></ul></li><li>Spring容器关闭过程：<ul><li>调⽤DisposableBean的destroy();</li><li>调⽤定制的destroy-method⽅法;</li></ul></li></ul><h1 id="IOC控制反转与DI依赖注⼊"><a href="#IOC控制反转与DI依赖注⼊" class="headerlink" title="IOC控制反转与DI依赖注⼊"></a>IOC控制反转与DI依赖注⼊</h1><ul><li>IOC控制反转：是⼀种将对象交给容器去控制的设计思想，松耦合，⽅便单元测试，增加功能重⽤性；</li><li>DI依赖注⼊：组件之间依赖关系由容器在运⾏期决定，形象的说，即由容器动态的将某个依赖关系注⼊到组件之中。依赖注⼊的⽬的并⾮为软件系统带来更多功能，⽽是为了提升组件重⽤的频率，并为系统搭建⼀个灵活、可扩展的平台。通过依赖注⼊机制，我们只需要通过简单的配置，⽽⽆需任何代码就可指定⽬标需要的资源，完成⾃身的业务逻辑，⽽不需要关⼼具体的资源来⾃何处，由谁实现。</li><li>AOP⾯向切⾯编程：⾯向切⾯编程（AOP）完善spring的依赖注⼊（DI）。</li></ul><h1 id="spring事件的实现原理，写出常⽤的⼏个事件。"><a href="#spring事件的实现原理，写出常⽤的⼏个事件。" class="headerlink" title="spring事件的实现原理，写出常⽤的⼏个事件。"></a>spring事件的实现原理，写出常⽤的⼏个事件。</h1><ul><li>事件机制：Spring中的事件机制是⼀个观察者模式的实现，观察者模式就是⼀个⽬标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。</li><li>spring默认存在的事件：<ul><li>ContextStartedEvent：ApplicationContext启动后触发的事件</li><li>ContextStoppedEvent：ApplicationContext停⽌后触发的事件</li><li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件</li><li>ContextClosedEvent：ApplicationContext关闭后触发的事件</li></ul></li></ul><h1 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h1><ul><li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li><li>它是轻量级、松散耦合的。</li><li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li><li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li></ul><h1 id="列举-Spring-Framework-的优点"><a href="#列举-Spring-Framework-的优点" class="headerlink" title="列举 Spring Framework 的优点"></a>列举 Spring Framework 的优点</h1><ul><li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li><li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li><li>由于依赖注入和控制反转，JDBC 得以简化。</li><li>它是开源免费的。</li></ul><h1 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h1><ul><li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li><li>IOC - 控制反转</li><li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li><li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li><li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li><li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li><li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li></ul><h1 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h1><ul><li>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：<ul><li>Spring Core</li><li>Spring Bean</li><li>SpEL (Spring Expression Language)</li><li>Spring Context</li></ul></li><li>数据访问&#x2F;集成 – 该层提供与数据库交互的支持。它包含以下模块：<ul><li>JDBC (Java DataBase Connectivity)</li><li>ORM (Object Relational Mapping)</li><li>OXM (Object XML Mappers)</li><li>JMS (Java Messaging Service)</li><li>Transaction</li></ul></li><li>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<ul><li>Web</li><li>Web – Servlet</li><li>Web – Socket</li><li>Web – Portlet</li></ul></li><li>AOP – 该层支持面向切面编程<ul><li>Instrumentation – 该层为类检测和类加载器实现提供支持。</li><li>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</li></ul></li><li>几个杂项模块:<ul><li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li><li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li></ul></li></ul><h1 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h1><ul><li>Spring 配置文件是 XML 文件</li><li>该文件主要包含类信息</li><li>它描述了这些类是如何配置以及相互引入的</li><li>但是，XML 配置文件冗长且更加干净</li><li>如果没有正确规划和编写，那么在大项目中管理变得非常困难。</li></ul><h1 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h1><ul><li>接口 - 定义功能。</li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li><li>用户程序 - 它使用接口。</li></ul><h1 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h1><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>用于远程使用。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li></ul><h1 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h1><ul><li>Spring 框架的核心是 Spring 容器</li><li>容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期</li><li>Spring 容器使用依赖注入来管理组成应用程序的组件</li><li>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令</li><li>该元数据可以通过 XML，Java 注解或 Java 代码提供。</li></ul><h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><ul><li>在依赖注入中，您不必创建对象，但必须描述如何创建它们</li><li>您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务</li><li>由 IoC 容器将它们装配在一起。</li></ul><h1 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h1><ul><li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li><li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h1 id="列举-IoC-的一些好处。"><a href="#列举-IoC-的一些好处。" class="headerlink" title="列举 IoC 的一些好处。"></a>列举 IoC 的一些好处。</h1><ul><li>它将最小化应用程序中的代码量。</li><li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li><li>它以最小的影响和最少的侵入机制促进松耦合。</li><li>它支持即时的实例化和延迟加载服务。</li></ul><h1 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h1><ul><li>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</li></ul><h1 id="什么是-spring-bean？"><a href="#什么是-spring-bean？" class="headerlink" title="什么是 spring bean？"></a>什么是 spring bean？</h1><ul><li>它们是构成用户应用程序主干的对象。</li><li>Bean 由 Spring IoC 容器管理。</li><li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li><li>Bean 是基于用户提供给容器的配置元数据创建。</li></ul><h1 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h1><ul><li>基于 xml 配置<ul><li>bean 所需的依赖项和服务在 XML 格式的配置文件中指定</li><li>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项</li><li>它们通常以 bean 标签开头</li></ul></li><li>基于注解配置<ul><li>可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配</li><li>默认情况下，Spring 容器中未打开注解装配</li><li>因此，您需要在使用它之前在 Spring 配置文件中启用它：<a href="context:annotation-config/">context:annotation-config/</a></li></ul></li><li>基于 Java API 配置<ul><li>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul><li>@Bean 注解扮演与<bean>元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul></li></ul></li></ul><h1 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h1><ul><li>Spring bean 支持 5 种 scope：<ul><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li></ul></li><li>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</li></ul><h1 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h1><ul><li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li><li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li><li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li><li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li><li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li><li>如果为 bean 指定了 init 方法（<bean>的 init-method 属性），那么将调用它。</bean></li><li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li><li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li><li>如果为 bean 指定了 destroy 方法（<bean>的 destroy-method 属性），那么将调用它。</bean></li></ul><h1 id="什么是-spring-的内部-bean？"><a href="#什么是-spring-的内部-bean？" class="headerlink" title="什么是 spring 的内部 bean？"></a>什么是 spring 的内部 bean？</h1><ul><li>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean</li><li>为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg>中提供了<bean>元素的使用</bean></constructor-arg></property></li><li>内部 bean 总是匿名的，它们总是作为原型。</li></ul><h1 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h1><ul><li>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配</li><li>Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</li></ul><h1 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h1><ul><li>Spring 容器能够自动装配 bean</li><li>也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</li><li>自动装配的不同模式：<ul><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ul></li></ul><h1 id="自动装配有什么局限？"><a href="#自动装配有什么局限？" class="headerlink" title="自动装配有什么局限？"></a>自动装配有什么局限？</h1><ul><li>覆盖的可能性 - 您始终可以使用<constructor-arg>和<property>设置指定依赖项，这将覆盖自动装配。</property></constructor-arg></li><li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li><li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li></ul><h1 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h1><ul><li>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身</li><li>它可以作为 XML 设置的替代方案。例如：Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<ul><li>@Bean 注解扮演与元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul></li></ul><h1 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h1><ul><li>默认情况下，Spring 容器中未打开注解装配</li><li>要使用基于注解装配，我们必须通过配置&lt;context：annotation-config &#x2F;&gt; 元素在 Spring 配置文件中启用它</li></ul><h1 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h1><ul><li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li><li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h1 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h1><ul><li>Required 应用于 bean 属性 setter 方法</li><li>此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性</li><li>如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    @Required</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    public string getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h1><ul><li>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配</li><li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean</li><li>默认情况下，它是类型驱动的注入。</li></ul><h1 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h1><ul><li>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</li><li>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</li></ul><h1 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h1><ul><li>RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法</li><li>此注释可应用于两个级别：<ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul></li></ul><h1 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h1><ul><li>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作</li><li>这使得用户容易在持久性技术之间切换</li><li>它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</li></ul><h1 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h1><pre><code>- JdbcTemplate
- SimpleJdbcTemplate
- NamedParameterJdbcTemplate
- SimpleJdbcInsert
- SimpleJdbcCall
</code></pre><h1 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h1><ul><li>我们可以通过两种方式使用 Spring 访问 Hibernate：<ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul></li></ul><h1 id="列举-spring-支持的事务管理类型"><a href="#列举-spring-支持的事务管理类型" class="headerlink" title="列举 spring 支持的事务管理类型"></a>列举 spring 支持的事务管理类型</h1><ul><li>Spring 支持两种类型的事务管理：<ul><li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li><li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li></ul></li></ul><h1 id="spring-支持哪些-ORM-框架"><a href="#spring-支持哪些-ORM-框架" class="headerlink" title="spring 支持哪些 ORM 框架"></a>spring 支持哪些 ORM 框架</h1><ul><li>Hibernate</li><li>iBatis</li><li>JPA</li><li>JDO</li><li>OJB</li></ul><h1 id="指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h1><ul><li>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</li><li>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</li></ul><h1 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h1><ul><li>实现 AOP 的技术，主要分为两大类：<ul><li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul></li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul><li>JDK 动态代理</li><li>CGLIB</li></ul></li></ul></li></ul><h1 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h1><ul><li>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</li><li>Spring AOP 仅支持方法级别的 PointCut；AspectJ 提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</li></ul><h1 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h1><ul><li>将 Advice 应用于目标对象后创建的对象称为代理</li><li>在客户端对象的情况下，目标对象和代理对象是相同的。</li><li>Advice + Target Object &#x3D; Proxy</li></ul><h1 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h1><ul><li>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）</li><li>在 Spring AOP 中，编织在运行时执行</li></ul><h1 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h1><ul><li>WebApplicationContext 是 ApplicationContext 的扩展</li><li>它具有 Web 应用程序所需的一些额外功能</li><li>它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</li></ul><h1 id="IoC-和-DI的区别？"><a href="#IoC-和-DI的区别？" class="headerlink" title="IoC 和 DI的区别？"></a>IoC 和 DI的区别？</h1><ul><li>IoC 控制反转，指将对象的创建权，反转到Spring容器</li><li>DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</li></ul><p> </p><h1 id="BeanFactory-接口和-ApplicationContext-接口有什么区别？"><a href="#BeanFactory-接口和-ApplicationContext-接口有什么区别？" class="headerlink" title="BeanFactory 接口和 ApplicationContext 接口有什么区别？"></a>BeanFactory 接口和 ApplicationContext 接口有什么区别？</h1><ul><li>ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。</li><li>ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));</span><br><span class="line">IHelloService helloService = (IHelloService) beanFactory.getBean(&quot;helloService&quot;);</span><br><span class="line">helloService.sayHello();</span><br></pre></td></tr></table></figure></li></ul><h1 id="spring配置bean实例化有哪些方式？"><a href="#spring配置bean实例化有哪些方式？" class="headerlink" title="spring配置bean实例化有哪些方式？"></a>spring配置bean实例化有哪些方式？</h1><ul><li>使用类构造器实例化(默认无参数)</li><li>使用静态工厂方法实例化(简单工厂模式)</li><li>使用实例工厂方法实例化(工厂方法模式)</li></ul><h1 id="简单的说一下spring的生命周期？"><a href="#简单的说一下spring的生命周期？" class="headerlink" title="简单的说一下spring的生命周期？"></a>简单的说一下spring的生命周期？</h1><ul><li>instantiate bean对象实例化</li><li>populate properties 封装属性</li><li>如果Bean实现BeanNameAware 执行 setBeanName</li><li>如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext</li><li>如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)</li><li>如果Bean实现InitializingBean 执行 afterPropertiesSet </li><li>调用<bean init-method="init"> 指定初始化方法 init</bean></li><li>如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization</li><li>执行业务处理</li><li>如果Bean实现 DisposableBean 执行 destroy</li><li>调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy</bean></li></ul><h1 id="请介绍一下Spring框架中Bean的生命周期和作用域"><a href="#请介绍一下Spring框架中Bean的生命周期和作用域" class="headerlink" title="请介绍一下Spring框架中Bean的生命周期和作用域"></a>请介绍一下Spring框架中Bean的生命周期和作用域</h1><ul><li>bean定义：在配置文件里面用<bean></bean>来进行定义。</li><li>bean初始化，有两种方式初始化:<ul><li>在配置文件中通过指定init-method属性来完成</li><li>实现org.springframwork.beans.factory.InitializingBean接口</li></ul></li><li>bean调用：有三种方式可以得到bean实例，并进行调用</li><li>bean销毁，销毁有两种方式<ul><li>使用配置文件指定的destroy-method属性</li><li>实现org.springframwork.bean.factory.DisposeableBean接口</li></ul></li><li>作用域<ul><li>singleton：当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</li><li>prototype：Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域</li><li>request：在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>global session：在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</li></ul></li></ul><h1 id="Spring的核心类有哪些，各有什么作用？"><a href="#Spring的核心类有哪些，各有什么作用？" class="headerlink" title="Spring的核心类有哪些，各有什么作用？"></a>Spring的核心类有哪些，各有什么作用？</h1><ul><li>BeanFactory：产生一个新的实例，可以实现单例模式</li><li>BeanWrapper：提供统一的get及set方法</li><li>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li></ul><h1 id="Spring里面applicationContext-xml文件能不能改成其他文件名？"><a href="#Spring里面applicationContext-xml文件能不能改成其他文件名？" class="headerlink" title="Spring里面applicationContext.xml文件能不能改成其他文件名？"></a>Spring里面applicationContext.xml文件能不能改成其他文件名？</h1><ul><li>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化</li><li>缺省情况下， 它会在WEB-INF&#x2F;applicationContext.xml文件找Spring的配置</li><li>你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的位置</context-param></li></ul><p>11.Spring里面如何定义hibernate mapping？ </p><ul><li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li></ul><h1 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h1><ul><li>Spring使用ThreadLocal解决线程安全问题</li><li>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域</li><li>就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</li><li>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</li><li>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量</li><li>这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</li><li>而ThreadLocal则从另一个角度来解决多线程的并发访问</li><li>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突</li><li>因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li><li>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</li><li>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换</li><li>但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。</li><li>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li><li>前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li></ul><h1 id="介绍一下Spring的事物管理"><a href="#介绍一下Spring的事物管理" class="headerlink" title="介绍一下Spring的事物管理"></a>介绍一下Spring的事物管理</h1><ul><li>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</li><li>开发中为了避免这种情况一般都会进行事务管理</li><li>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能</li><li>spring提供了几个关于事务处理的类：<ul><li>TransactionDefinition &#x2F;&#x2F;事务属性定义</li><li>TranscationStatus &#x2F;&#x2F;代表了当前的事务，可以提交，回滚。</li><li>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。</li></ul></li><li>spring提供的事务管理可以分为两类：编程式的和声明式的<ul><li>编程式的，比较灵活，但是代码量大，存在重复的代码比较多</li><li>声明式的比编程式的更灵活。</li></ul></li><li>编程式主要使用transactionTemplate</li><li>省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.</li></ul><h1 id="AOP-通知有哪些类型？"><a href="#AOP-通知有哪些类型？" class="headerlink" title="AOP 通知有哪些类型？"></a>AOP 通知有哪些类型？</h1><ul><li>前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li><li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li><li>后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li><li>环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</li></ul><h1 id="什么是-spring"><a href="#什么是-spring" class="headerlink" title="什么是 spring?"></a>什么是 spring?</h1><ul><li>Spring 是个 java 企业级应用的开源开发框架</li><li>Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用</li><li>Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</li></ul><h1 id="使用-Spring-框架的好处是什么？"><a href="#使用-Spring-框架的好处是什么？" class="headerlink" title="使用 Spring 框架的好处是什么？"></a>使用 Spring 框架的好处是什么？</h1><ul><li>轻量：Spring 是轻量的，基本的版本大约 2MB</li><li>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li><li>容器：Spring 包含并管理应用中对象的生命周期和配置</li><li>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品</li><li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li><li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</li></ul><h1 id="ApplicationContext-通常的实现是什么？"><a href="#ApplicationContext-通常的实现是什么？" class="headerlink" title="ApplicationContext 通常的实现是什么？"></a>ApplicationContext 通常的实现是什么？</h1><ul><li>FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li>ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找bean 配置。</li><li>WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个WEB 应用的所有 bean。</li></ul><h1 id="一个-Spring-的应用看起来象什么？"><a href="#一个-Spring-的应用看起来象什么？" class="headerlink" title="一个 Spring 的应用看起来象什么？"></a>一个 Spring 的应用看起来象什么？</h1><ul><li>一个定义了一些功能的接口</li><li>这实现包括属性，它的 Setter ， getter 方法和函数等</li><li>Spring AOP</li><li>Spring 的 XML 配置文件</li><li>使用以上功能的客户端程序</li></ul><h1 id="哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？"><a href="#哪种依赖注入方式你建议使用，构造器注入，还是-Setter-方法注入？" class="headerlink" title="哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？"></a>哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？</h1><ul><li>你两种依赖方式都可以使用，构造器注入和 Setter 方法注入</li><li>最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。</li></ul><h1 id="什么是-Spring-beans？"><a href="#什么是-Spring-beans？" class="headerlink" title="什么是 Spring beans？"></a>什么是 Spring beans？</h1><ul><li>Spring beans 是那些形成 Spring 应用的主干的 java 对象</li><li>它们被 Spring IOC 容器初始化，装配，和管理</li><li>这些 beans 通过容器中配置的元数据创建</li><li>比如，以 XML文件中<bean>的形式定义。</li><li>Spring 框架定义的 beans 都是单件 beans</li><li>在 bean tag 中有个属性”singleton”，如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean</li><li>默认是TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件</li></ul><h1 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h1><ul><li>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</li></ul><h1 id="如何给-Spring-容器提供配置元数据？"><a href="#如何给-Spring-容器提供配置元数据？" class="headerlink" title="如何给 Spring 容器提供配置元数据？"></a>如何给 Spring 容器提供配置元数据？</h1><ul><li>这里有三种重要的方法给 Spring 容器提供配置元数据。<ul><li>XML 配置文件。</li><li>基于注解的配置。</li><li>基于 java 的配置。</li></ul></li></ul><h1 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h1><ul><li>当定义一个<bean>在 Spring 里，我们还能给这个 bean 声明一个作用域</bean></li><li>它可以通过bean定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope属性必须设为singleton。</li></ul><h1 id="Spring-框架中的单例-bean-是线程安全的吗？"><a href="#Spring-框架中的单例-bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例 bean 是线程安全的吗？"></a>Spring 框架中的单例 bean 是线程安全的吗？</h1><ul><li>不，Spring 框架中的单例 bean 不是线程安全的。</li></ul><h1 id="哪些是重要的-bean-生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的-bean-生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的 bean 生命周期方法？ 你能重载它们吗？"></a>哪些是重要的 bean 生命周期方法？ 你能重载它们吗？</h1><p>有- 两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时候被调用</p><ul><li>第二个方法是 teardown 它是在容器卸载类的时候被调用。</li><li>The bean 标签有两个重要的属性（init-method 和 destroy-method）</li><li>用它们你可 以 自 己 定 制 初 始 化 和 注 销 方 法</li><li>它 们 也 有 相 应 的 注 解 （ @PostConstruct 和@PreDestroy）。</li></ul><h1 id="在-Spring-中如何注入一个-java-集合？"><a href="#在-Spring-中如何注入一个-java-集合？" class="headerlink" title="在 Spring 中如何注入一个 java 集合？"></a>在 Spring 中如何注入一个 java 集合？</h1><ul><li>Spring 提供以下几种集合的配置元素：<ul><li><list>类型用于注入一列值，允许有相同的值。</list></li><li><set>类型用于注入一组值，不允许有相同的值。</set></li><li><map>类型用于注入一组键值对，键和值都可以为任意类型。</map></li><li><props>类型用于注入一组键值对，键和值都只能为 String 类型。</props></li></ul></li></ul><h1 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h1><ul><li>自动装配的局限性是：<ul><li>重写：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></li><li>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。</li><li>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li></ul></li></ul><h1 id="你可以在-Spring-中注入一个-null-和一个空字符串吗？"><a href="#你可以在-Spring-中注入一个-null-和一个空字符串吗？" class="headerlink" title="你可以在 Spring 中注入一个 null 和一个空字符串吗？"></a>你可以在 Spring 中注入一个 null 和一个空字符串吗？</h1><ul><li>可以。 Spring 注解</li></ul><h1 id="在-Spring-框架中如何更有效地使用-JDBC？"><a href="#在-Spring-框架中如何更有效地使用-JDBC？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC？"></a>在 Spring 框架中如何更有效地使用 JDBC？</h1><ul><li>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻</li><li>所以开发者只需写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</li><li>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li></ul><h1 id="Spring-对-DAO-的支持"><a href="#Spring-对-DAO-的支持" class="headerlink" title="Spring 对 DAO 的支持"></a>Spring 对 DAO 的支持</h1><ul><li>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，Hibernate or JDO 结合使用</li><li>这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</li></ul><h1 id="如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？"><a href="#如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？" class="headerlink" title="如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？"></a>如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</h1><ul><li>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul><li>配置 the Hibernate SessionFactory</li><li>继承 HibernateDaoSupport 实现一个 DAO</li><li>在 AOP 支持的事务中装配</li></ul></li></ul><h1 id="如何在spring的applicationContext-xml使用JNDI而不是DataSource"><a href="#如何在spring的applicationContext-xml使用JNDI而不是DataSource" class="headerlink" title="如何在spring的applicationContext.xml使用JNDI而不是DataSource"></a>如何在spring的applicationContext.xml使用JNDI而不是DataSource</h1><ul><li>可以使用”org.springframework.jndi.JndiObjectFactoryBean”来实现</li></ul><h1 id="在spring中是如何配置数据库驱动的"><a href="#在spring中是如何配置数据库驱动的" class="headerlink" title="在spring中是如何配置数据库驱动的"></a>在spring中是如何配置数据库驱动的</h1><ul><li>org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动</li></ul><h1 id="在web中如何配置spring"><a href="#在web中如何配置spring" class="headerlink" title="在web中如何配置spring"></a>在web中如何配置spring</h1><ul><li>在J2EE的web应用里面配置spring非常简单，最简单的只需要把spring得ContextLoaderListener添加到你的web.xml文件里面就可以了</li></ul><h1 id="在spring中如何定义hibernate-Mapping？"><a href="#在spring中如何定义hibernate-Mapping？" class="headerlink" title="在spring中如何定义hibernate Mapping？"></a>在spring中如何定义hibernate Mapping？</h1><ul><li>添加hibernate mapping 文件到web&#x2F;WEB-INF目录下的applicationContext.xml文件里面</li></ul><h1 id="如何配置spring-struts？"><a href="#如何配置spring-struts？" class="headerlink" title="如何配置spring + struts？"></a>如何配置spring + struts？</h1><ul><li>在struts-config.xml加入一个插件，通过它加载applicationContext.xml</li><li>在struts-config.xml修改action-mapping标记，具体action交给了DelegateActionProxy</li><li>通过DelegateActionProxy进入一spring的环境。</li><li>在spring的applicationContext.xml加入<bean name="”/login”" class="”“" singleton="”false”/"></bean></li></ul><h1 id="如何在spring中实现国际化"><a href="#如何在spring中实现国际化" class="headerlink" title="如何在spring中实现国际化?"></a>如何在spring中实现国际化?</h1><ul><li>在applicationContext.xml加载一个bean org.springframework.context.support.ResourceBundleMessageSource</li><li>在src目录下建多个properties文件</li><li>对于非英文的要用native2ascii -encoding gb2312 源目转化文件相关内容</li><li>其命名格式是message_语言_国家。</li><li>页面中的中显示提示信息，键名取键值。</li><li>当给定国家，系统会自动加载对应的国家的properties信息。</li><li>通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。</li></ul><h1 id="在spring中如何实现事件处理"><a href="#在spring中如何实现事件处理" class="headerlink" title="在spring中如何实现事件处理"></a>在spring中如何实现事件处理</h1><ul><li>事件 Extends ApplicationEvent</li><li>监听器 Implements ApplicationListener</li><li>事件源 Implements ApplicationContextAware</li><li>在applicationContext.xml中配置事件源、监听器</li><li>先得到事件源，调用事件源的方法，通知监听器。</li></ul><h1 id="如何将spring加入web容器中"><a href="#如何将spring加入web容器中" class="headerlink" title="如何将spring加入web容器中"></a>如何将spring加入web容器中</h1><ul><li>在web.xml中加入如下同容,在启动web服务器时加载&#x2F;WEB-INF&#x2F;applicationContext.xml中的内容。</li></ul><h1 id="Spring如何实现资源管理"><a href="#Spring如何实现资源管理" class="headerlink" title="Spring如何实现资源管理?"></a>Spring如何实现资源管理?</h1><ul><li>使用<ul><li>applicationContext.getResource(“classpath:文件名”):在src根目录下，在类路径下</li><li>applicationContext.getResource(“classpath:&#x2F;chap01&#x2F;文件名”): 以src根目录下的基准往下走。</li><li>applicationContext.getResource(“file:c:&#x2F;a.properties”)：在系统文件目录下。</li></ul></li></ul><h1 id="Spring的ApplicationContext的作用"><a href="#Spring的ApplicationContext的作用" class="headerlink" title="Spring的ApplicationContext的作用?"></a>Spring的ApplicationContext的作用?</h1><ul><li>beanFactory</li><li>国际化(getMesage)</li><li>资源管理:可以直接读取一个文件的内容(getResource)</li><li>加入web框架中(加入一个servlet或监听器)</li><li>事件处理</li></ul><h1 id="Hibernate工作原理及为什么要用？"><a href="#Hibernate工作原理及为什么要用？" class="headerlink" title="Hibernate工作原理及为什么要用？"></a>Hibernate工作原理及为什么要用？</h1><ul><li>原理：<ul><li>读取并解析配置文件</li><li>读取并解析映射信息，创建SessionFactory</li><li>打开Sesssion</li><li>创建事务Transation</li><li>持久化操作</li><li>提交事务</li><li>关闭Session</li><li>关闭SesstionFactory</li></ul></li><li>为什么要用：<ul><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li></ul></li><li>Hibernate是如何延迟加载?<ul><li>Hibernate2延迟加载实现：a)实体对象  b)集合（Collection）</li><li>Hibernate3 提供了属性的延迟加载功能</li></ul></li><li>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</li><li>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)<ul><li>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、</li></ul></li><li>说下Hibernate的缓存机制<ul><li>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</li><li>二级缓存：<ul><li>应用及缓存</li><li>分布式缓存<ul><li>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据</li></ul></li></ul></li><li>第三方缓存的实现</li></ul></li><li>Hibernate的查询方式<ul><li>Sql、Criteria,object comptosition</li><li>Hql：<ul><li>属性查询</li><li>参数查询、命名参数查询</li><li>关联查询</li><li>分页查询</li><li>统计函数</li></ul></li></ul></li><li>如何优化Hibernate？<ul><li>使用双向一对多关联，不使用单向一对多</li><li>灵活使用单向一对多关联</li><li>不用一对一，用多对一取代</li><li>配置对象缓存，不使用集合缓存</li><li>一对多集合使用Bag,多对多集合使用Set</li><li>继承类使用显式多态</li><li>表字段要少，表关联不要怕多，有二级缓存撑腰</li></ul></li></ul><h1 id="Spring中如何获取bean"><a href="#Spring中如何获取bean" class="headerlink" title="Spring中如何获取bean"></a>Spring中如何获取bean</h1><ul><li>通过xml配置文件</li><li>bean配置在xml里面，spring提供多种方式读取配置文件得到ApplicationContext.<ul><li>第一种方式：FileSystemXmlApplicationContext通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例:<ul><li>ApplicationContext ac &#x3D; new FileSystemXmlApplicationContext(”applicationContext.xml”)</li><li>ac.getBean(”beanName”);</li></ul></li><li>第二种方式：WebApplicationContextUtil在B&#x2F;S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext.例如：<ul><li>ApplicationContext ctx &#x3D; WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);</li><li>ApplicationContext ctx &#x3D;   WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</li><li>其中 servletContext sc 可以具体 换成 servlet.getServletContext()或者 this.getServletContext() 或者 request.getSession().getServletContext();</li><li>另外，由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象：</li><li>WebApplicationContext webApplicationContext &#x3D; (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</li></ul></li></ul></li></ul><h1 id="Spring框架中的单例Beans是线程安全的么？"><a href="#Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="Spring框架中的单例Beans是线程安全的么？"></a>Spring框架中的单例Beans是线程安全的么？</h1><ul><li>Spring框架并没有对单例bean进行任何多线程的封装处理</li><li>关于单例bean的线程安全和并发问题需要开发者自行去搞定</li><li>但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的</li><li>如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。</li><li>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</li></ul><h1 id="如何向Spring-Bean中注入一个Java-util-Properties？"><a href="#如何向Spring-Bean中注入一个Java-util-Properties？" class="headerlink" title="如何向Spring Bean中注入一个Java.util.Properties？"></a>如何向Spring Bean中注入一个Java.util.Properties？</h1><ul><li>第一种方法是使用如下面代码所示的<props> 标签</props></li><li>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。</li></ul><h1 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h1><ul><li>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</li><li>我们可以创建bean用来监听在ApplicationContext 中发布的事件</li><li>ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li><li>Spring 提供了以下5中标准的事件：<ul><li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li></ul></li><li>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。为了监听这个事件，还需要创建一个监听器，之后通过applicationContext接口的publishEvent()方法来发布自定义事件。</li></ul><h1 id="FileSystemResource和ClassPathResource有何区别？"><a href="#FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="FileSystemResource和ClassPathResource有何区别？"></a>FileSystemResource和ClassPathResource有何区别？</h1><ul><li>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径</li><li>在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。</li><li>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</li><li>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</li></ul><h1 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h1><ul><li>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：<ul><li>代理模式—在AOP和remoting中被用的比较多。</li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory &#x2F; ApplicationContext接口的核心理念。</li><li>工厂模式—BeanFactory用来创建对象的实例</li></ul></li></ul><p> </p><h1 id="开发中主要使用-Spring-的什么技术"><a href="#开发中主要使用-Spring-的什么技术" class="headerlink" title="开发中主要使用 Spring 的什么技术 ?"></a>开发中主要使用 Spring 的什么技术 ?</h1><ul><li>IOC 容器管理各层的组件</li><li>使用 AOP 配置声明式事务</li><li>整合其他框架</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/spring/" rel="tag"><i class="fa fa-tag"></i> spring</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/cc5f72fdfb9e.html" rel="prev" title="Tomcat"><i class="fa fa-angle-left"></i> Tomcat</a></div><div class="post-nav-item"><a href="/publishes/235b69f65d9c.html" rel="next" title="Spring MVC">Spring MVC <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">2.6m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">39:05</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>