<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><meta name="description" content="什么是AOP在软件开发过程中，跨越应用程序多个点的功能称为交叉问题。这些交叉问题与应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。  Spring中Bean的⽣命周期。Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅法-》调⽤Initializati"><meta property="og:type" content="article"><meta property="og:title" content="Spring"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="什么是AOP在软件开发过程中，跨越应用程序多个点的功能称为交叉问题。这些交叉问题与应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。  Spring中Bean的⽣命周期。Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅法-》调⽤Initializati"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T08:03:58.000Z"><meta property="article:modified_time" content="2023-12-20T10:26:54.501Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="spring"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html","path":"publishes/c9fa4a3e43dd.html","title":"Spring"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Spring | Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java后端面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOP"><span class="nav-number">1.</span> <span class="nav-text">什么是AOP</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/c9fa4a3e43dd.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Spring | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Spring</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:03:58 / 修改时间：18:26:54" itemprop="dateCreated datePublished" datetime="2023-12-20T16:03:58+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><p>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题。这些交叉问题与应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向方面编程（AOP）的地方。</p><ol><li>Spring中Bean的⽣命周期。<br>Instance实例化-》设置属性值-》调⽤BeanNameAware的setBeanName⽅法-》调⽤BeanPostProsessor的预初始化⽅<br>法-》调⽤InitializationBean的afterPropertiesSet()的⽅法-》调⽤定制的初始化⽅法callCustom的init-method-》调⽤<br>BeanPostProsessor的后初始化⽅法-》Bean可以使⽤了 -》 容器关闭-》 调⽤DisposableBean的destroy⽅法-》调⽤定<br>制的销毁⽅法CallCustom的destroy-method。<br>1、Spring对Bean进⾏实例化（相当于程序中的new Xx()）<br>2、Spring将值和Bean的引⽤注⼊进Bean对应的属性中<br>3、如果Bean实现了BeanNameAware接⼝，Spring将Bean的ID传递给setBeanName()⽅法（实现BeanNameAware清主<br>要是为了通过Bean的引⽤来获得Bean的ID，⼀般业务中是很少有⽤到Bean的ID的）<br>4、如果Bean实现了BeanFactoryAware接⼝，Spring将调⽤setBeanDactory(BeanFactory bf)⽅法并把BeanFactory容器<br>实例作为参数传⼊。（实现BeanFactoryAware 主要⽬的是为了获取Spring容器，如Bean通过Spring容器发布事件等）<br>5、如果Bean实现了ApplicationContextAwaer接⼝，Spring容器将调⽤setApplicationContext(ApplicationContext ctx)<br>⽅法，把y应⽤上下⽂作为参数传⼊.(作⽤与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调⽤<br>setApplicationContext⽅法时会把它⾃⼰作为setApplicationContext 的参数传⼊，⽽Spring容器在调⽤setBeanDactory<br>前需要程序员⾃⼰指定（注⼊）setBeanDactory⾥的参数BeanFactory )<br>7、如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessBeforeInitialization（预初始化）⽅法（作<br>⽤是在Bean实例创建成功后对进⾏增强处理，如对Bean进⾏修改，增加某个功能）7.如果Bean实现了InitializingBean接<br>⼝，Spring将调⽤它们的afterPropertiesSet⽅法，作⽤与在配置⽂件中对Bean使⽤init-method声明初始化的作⽤⼀样，<br>都是在Bean的全部属性设置成功后执⾏的初始化⽅法。<br>8、如果Bean实现了BeanPostProcess接⼝，Spring将调⽤它们的postProcessAfterInitialization（后初始化）⽅法（作<br>⽤与7的⼀样，只不过7是在Bean初始化前执⾏的，⽽这个是在Bean初始化后执⾏的，时机不同 )<br>9、经过以上的⼯作后，Bean将⼀直驻留在应⽤上下⽂中给应⽤使⽤，直到应⽤上下⽂被销毁<br>10、如果Bean实现了DispostbleBean接⼝，Spring将调⽤它的destory⽅法，作⽤与在配置⽂件中对Bean使⽤destory￾method属性的作⽤⼀样，都是在Bean实例销毁前执⾏的⽅法。</li><li>SpringBoot项⽬启动时执⾏特定的⽅法：<br>我们可以通过实现ApplicationRunner和CommandLineRunner，来实现，他们都是在SpringApplication 执⾏之后开始执<br>⾏的。</li><li>SpringMVC处理请求的流程。<br>1、请求解析和匹配DipatcherServlet路径：客户端发出⼀个http请求给web服务器，web服务器对http请求进⾏解析，<br>如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet.<br>2、匹配处理器Handler：DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http⽅法、请求报⽂头<br>和请求参数Cookie等）以及HandlerMapping的配置找到处理请求的处理器（Handler）。<br>3-4、处理器进⾏处理：DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给<br>Handler（Handler将具体的处理进⾏封装），再由具体的HandlerAdapter对Handler进⾏具体的调⽤。<br>5、处理器返回逻辑视图ModelAndView对象给DispatcherServlet：Handler对数据处理完成以后将返回⼀个<br>ModelAndView()对象给DispatcherServlet。<br>6、Dispatcher通过ViewResolver将逻辑视图转化为正式视图view：Handler返回的ModelAndView()只是⼀个逻辑视<br>图并不是⼀个正式的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。<br>7、Dispatcher通过model解析出ModelAndView()中的参数进⾏解析最终展现出完整的view并返回给客户端。</li><li>Spring AOP解决了什么问题？怎么实现的？<br>a. <a target="_blank" rel="noopener" href="https://blog.csdn.net/moreevan/article/details/11977115/">https://blog.csdn.net/moreevan/article/details/11977115/</a><br>b. 作⽤：AOP技术，利⽤⼀种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共⾏为封装到⼀<br>个可重⽤模块，并将其名为“Aspect”，即⽅⾯。所谓“⽅⾯”，简单地说，就是将那些与业务⽆关，却为业务模块所共同<br>调⽤的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。<br>c. 实现：<br>i. ⼀是采⽤动态代理技术，利⽤截取消息的⽅式，对该消息进⾏装饰，以取代原有对象⾏为的执⾏；<br>ii. ⼆是采⽤静态织⼊的⽅式，引⼊特定的语法创建“⽅⾯”，从⽽使得编译器可以在编译期间织⼊有关“⽅⾯”的代<br>码。<br>d. 使⽤场景：</li><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading　懒加载</li><li>Debugging　　调试</li><li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li><li>Performance optimization　性能优化</li><li>Persistence　　持久化</li><li>Resource pooling　资源池</li><li>Synchronization　同步</li><li>Transactions 事务<br>e. ⼏个概念：</li><li>切⾯（Aspect）：对象操作过程中的截⾯，这可能是AOP中最为关键的术语。切⾯所要做的事就是专注于各⾃领域<br>的逻辑实现，这样可以使得开发逻辑更加清晰，更加适合专业的分⼯合作。由于切⾯的隔离性，降低了耦合，这样<br>就可以在不同的应⽤中将各个切⾯组合使⽤，从⽽是代码重⽤性⼤⼤增加。</li><li>连接点：程序运⾏过程中的某个阶段点，如某个⽅法的调⽤，或者异常的抛出。</li><li>处理逻辑（Advice）：在某⼀个连接点所采⽤的处理逻辑，处理逻辑的调⽤模式通常有三种：<br>a.Around 在连接点前后插⼊预处理过程和后处理过程。<br>b.Before 仅在连接点钱出⼊处理过程。<br>b.Throw 在连接点抛出异常时进⾏异常处理。<br>Advice有的译为“通知”，说法不⼀，我侧重于“处理逻辑”出⾃于Spring开发指南⼀⽂。</li><li>切点（PointCut）：⼀系列连接点的集合，它指明处理逻辑将在合适触发。</li><li>Spring事务的传播属性是怎么回事？它会影响什么？<br>a. 七个事传播属性：</li><li>PROPAGATION_REQUIRED – ⽀持当前事务，如果当前没有事务，就新建⼀个事务。这是最常⻅的选择。</li><li>PROPAGATION_SUPPORTS – ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。</li><li>PROPAGATION_MANDATORY – ⽀持当前事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATIONREQUIRESNEW – 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATIONNOTSUPPORTED – 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER – 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。</li><li>PROPAGATIONNESTED – 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则进⾏与<br>PROPAGATIONREQUIRED类似的操作。<br>b. 五个隔离级别：</li><li>ISOLATION_DEFAULT 这是⼀个PlatfromTransactionManager默认的隔离级别，使⽤数据库默认的事务隔离级别.</li><li>另外四个与JDBC的隔离级别相对应：</li><li>ISOLATIONREADUNCOMMITTED 这是事务最低的隔离级别，它充许别外⼀个事务可以看到这个事务未提交的数<br>据。这种隔离级别会产⽣脏读，不可重复读和幻读。</li><li>ISOLATIONREADCOMMITTED 保证⼀个事务修改的数据提交后才能被另外⼀个事务读取。另外⼀个事务不能读取<br>该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li>ISOLATIONREPEATABLEREAD 这种事务隔离级别可以防⽌脏读，不可重复读。但是可能出现幻读。它除了保证<br>⼀个事务不能读取另⼀个事务未提交的数据外，还保证了避免不可重复读。</li><li>ISOLATION_SERIALIZABLE 这是花费最⾼代价但是最可靠的事务隔离级别。事务被处理为顺序执⾏。除了防⽌脏<br>读，不可重复读外，还避免了幻读。<br>c. 关键词：<br>1、幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；<br>2、不可重复读：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；<br>3、脏读：事务1更新了记录，但没有提交，事务2读取了更新后的⾏，然后事务T1回滚，现在T2读取⽆效。</li><li>Spring中BeanFactory和FactoryBean有什么区别？<br>a. BeanFactory，以Factory结尾，表示它是⼀个⼯⼚类(接⼝)，⽤于管理Bean的⼀个⼯⼚。在Spring中，BeanFactory是<br>IOC容器的核⼼接⼝，它的职责包括：实例化、定位、配置应⽤程序中的对象及建⽴这些对象间的依赖。<br>b. FactoryBean以Bean结尾，表示它是⼀个Bean，不同于普通Bean的是：它是实现了FactoryBean接⼝的Bean，根据该<br>Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽不是FactoryBean本身，如果要获<br>取FactoryBean对象，请在id前⾯加⼀个&amp;符号来获取。</li><li>Spring框架中IOC的原理是什么？<br>(1). IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权<br>由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的<br>关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系<br>由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。<br>(2). 在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后<br>spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由<br>spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对<br>象，现在是所有对象都被spring控制，所以这叫控制反转。<br>(3). 在系统运⾏中，动态的向某个对象提供它所需要的其他对象。<br>(4). 依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中<br>的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者<br>的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优<br>点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。</li><li>spring的依赖注⼊有哪⼏种⽅式<br>在Spring容器中为⼀个bean配置依赖注⼊有四种⽅式：</li><li>使⽤属性的setter⽅法注⼊ 这是最常⽤的⽅式；</li><li>使⽤构造器注⼊；</li><li>使⽤Filed注⼊（⽤于注解⽅式）.</li><li>静态、实例⼯⼚的⽅法注⼊</li><li>⽤Spring如何实现⼀个切⾯？<br>1 @Aspect<br>2 @Component<br>3 public class LockAspect {<br>4 @Pointcut(“@annotation(xx.xx)”)<br>5 public void pointcut() {<br>6<br>7 }<br>8<br>9 @Around(“pointcut()”)<br>10 public Object arount(ProceedingJoinPoint point) throws Throwable {<br>11 …<br>12 try {<br>13 return point.proceed();<br>14 } catch (Exception e) {<br>15 throw e;<br>16 } finally {<br>17 …<br>18 }<br>19 }<br>20 }</li><li>Spring如何实现数据库事务？<br>使⽤@Transactional注解或在配置⽂件⾥⾯配置</li><li>Spring加载次序Classloader<br>1、先构造函数——&gt;然后是bean的set⽅法注⼊——&gt;InitializingBean的afterPropertiesSet⽅法——&gt;init-method⽅法；<br>2、InitializingBean接⼝为bean提供了初始化⽅法的⽅式，它只包括afterPropertiesSet⽅法，凡是继承该接⼝的类，在<br>初始化bean的时候会执⾏该⽅法。系统则是先调⽤afterPropertiesSet⽅法，然后在调⽤init-method中指定的⽅法。<br>3、Spring装配Bean的过程：</li><li>实例化;</li><li>设置属性值;</li><li>如果实现了BeanNameAware接⼝,调⽤setBeanName设置Bean的ID或者Name;</li><li>如果实现BeanFactoryAware接⼝,调⽤setBeanFactory 设置BeanFactory;</li><li>如果实现ApplicationContextAware,调⽤setApplicationContext设置ApplicationContext</li><li>调⽤BeanPostProcessor的预先初始化⽅法;</li><li>调⽤InitializingBean的afterPropertiesSet()⽅法;</li><li>调⽤定制init-method⽅法；</li><li>调⽤BeanPostProcessor的后初始化⽅法;<br>4、Spring容器关闭过程：</li><li>调⽤DisposableBean的destroy();</li><li>调⽤定制的destroy-method⽅法;</li><li>框架的优缺点SpringMVC,Struts2等…<br>1、Struts2是类级别拦截，参数为类中所有⽅法共有，⼀个Action对应⼀个request上下⽂，SpringMVC是⽅法级别拦截，参<br>数为对应⽅法所有；<br>2、由于Struts2需要针对每个request进⾏封装，把request，session等servlet⽣命周期的变量封装成⼀个⼀个Map，供给<br>每个Action使⽤，并保证线程安全，所以在原则上，是⽐较耗费内存的。<br>3、拦截器实现机制上，Struts2有以⾃⼰的interceptor机制，SpringMVC⽤的是独⽴的AOP⽅式，这样导致Struts2的配置⽂<br>件量还是⽐SpringMVC⼤。<br>4、SpringMVC的⼊⼝是servlet，⽽Struts2是filter<br>5、SpringMVC集成了Ajax，使⽤⾮常⽅便，只需⼀个注解@ResponseBody就可以实现，然后直接返回响应⽂本即可，⽽<br>Struts2拦截器集成了Ajax，在Action中处理时⼀般必须安装插件或者⾃⼰写代码集成进去，使⽤起来也相对不⽅便。<br>6、SpringMVC开发效率和性能⾼于Struts2。<br>7、SpringMVC配置少，零配置。</li><li>IOC控制反转与DI依赖注⼊：<br>1、IOC控制反转：是⼀种将对象交给容器去控制的设计思想，松耦合，⽅便单元测试，增加功能重⽤性；<br>2、DI依赖注⼊：组件之间依赖关系由容器在运⾏期决定，形象的说，即由容器动态的将某个依赖关系注⼊到组件之中。依赖注⼊的<br>⽬的并⾮为软件系统带来更多功能，⽽是为了提升组件重⽤的频率，并为系统搭建⼀个灵活、可扩展的平台。通过依赖注⼊机制，我们只<br>需要通过简单的配置，⽽⽆需任何代码就可指定⽬标需要的资源，完成⾃身的业务逻辑，⽽不需要关⼼具体的资源来⾃何处，由谁实现。<br>3、AOP⾯向切⾯编程：⾯向切⾯编程（AOP）完善spring的依赖注⼊（DI）。</li><li>AOP开发：</li><li>导⼊aop依赖包：<br>1<dependency><br>2<groupid>org.springframework</groupid><br>3<artifactid>spring-aspects</artifactid><br>4<version>4.3.12.RELEASE</version><br>5</dependency></li><li>创建切⾯类：<br>1 /**<br>2 * ⽇志切⾯类<br>3 *<br>4 * @author xuan<br>5 * @date 2018/11/1<br>6 <em>/<br>7 @Aspect<br>8 public class LogAspects {<br>9 /</em>*<br>10 * 公共的切⼊点表达式<br>11 * 1、本类引⽤<br>12 * 2、其他的切⾯引⽤<br>13 *<br>14 * @author xuan<br>15 * @date 2018/11/1<br>16 <em>/<br>17 @Pointcut(value = “execution(public int com.test.aop.MathCalculator.</em>(..))”)<br>18 public void pointCut(){}<br>19<br>20 /**<br>21 * 前置通知<br>22 *<br>23 * 在⽬标⽅法之前切⼊，切⼊点表达式（指在哪个⽅法切⼊）<br>24 * joinPoint参数⼀定要出现在参数列表第⼀位，放在后⾯会报错<br>25 *<br>26 * @author xuan<br>27 * @date 2018/11/1<br>28 */<br>29 @Before(value = “pointCut()”)<br>30 public void logStart(JoinPoint joinPoint) {<br>31 String methodName = joinPoint.getSignature().getName();<br>32 Object[] args = joinPoint.getArgs();<br>33 System.out.println(methodName + “运⾏。。。参数列表是：” + Arrays.toString(args));<br>34 }<br>35<br>36 @After(value = “pointCut()”)<br>37 public void logEnd() {<br>38 System.out.println(“除法结束。。。”);<br>39 }<br>40<br>41 @AfterReturning(value = “pointCut()”, returning = “result”)<br>42 public void logReturn(JoinPoint joinPoint, Object result) {<br>43 String methodName = joinPoint.getSignature().getName();<br>44 System.out.println(methodName + “正常返回。。。计算结果：” + result);<br>45 }<br>46<br>47 @AfterThrowing(value = “pointCut()”, throwing = “exception”)<br>48 public void logException(JoinPoint joinPoint, Exception exception){<br>49 String methodName = joinPoint.getSignature().getName();<br>50 System.out.println(methodName + “异常，异常信息：” + exception);<br>51 }<br>52<br>53 }<br>通知⽅法类型：<br>前置通知（logStart）：在⽬标⽅法运⾏之前运⾏；<br>后置通知（logEnd）：在⽬标⽅法运⾏结束之后运⾏；<br>返回通知（logReturn）：在⽬标⽅法正常返回之后运⾏；<br>异常通知（logException）：在⽬标⽅法出现异常是运⾏；<br>环绕通知（动态代理）：⼿动推荐⽬标⽅法运⾏（joinPoint.procced()）。</li><li>将切⾯类和⽬标类都加⼊到容器中，并开启基于注解的aop动态代理<br>1 public class MathCalculator {<br>2 public int div(int i, int j) {<br>3 System.out.println(“MathCalculator.div…..”);<br>4 return i/j;<br>5 }<br>6<br>7 }<br>8<br>9<br>10 /**<br>11 * aop<br>12 * 在程序运⾏期间动态的将某段代码切⼊到指定⽅法指定位置进⾏运⾏的编程⽅式<br>13 * ‘@EnableAspectJAutoProxy’：开启基于注解的aop动态代理<br>14 *<br>15 * @author xuan<br>16 * @date 2018/11/1<br>17 <em>/<br>18 @Configuration<br>19 @EnableAspectJAutoProxy<br>20 public class MainConfigOfAOP {<br>21<br>22 /</em>*<br>23 * 业务逻辑类加⼊容器中<br>24 *<br>25 * @author xuan<br>26 * @date 2018/11/1<br>27 <em>/<br>28 @Bean<br>29 public MathCalculator calculator() {<br>30 return new MathCalculator();<br>31 }<br>32<br>33 /</em>*<br>34 * 切⾯类加⼊容器中<br>35 *<br>36 * @author xuan<br>37 * @date 2018/11/1<br>38 */<br>39 @Bean<br>40 public LogAspects logAspects(){<br>41 return new LogAspects();<br>42 }<br>43 }</li><li>测试：<br>1 @Test<br>2 public void test01() {<br>3 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP<br>4 MathCalculator calculator = applicationContext.getBean(MathCalculator.class);<br>5 calculator.div(1, 0);<br>6 }</li><li>事务配置：</li><li>@EnableTransactionManagement开启事务配置功能；</li><li>容器中配置DataSource、JdbcTemplate、PlatformTransactionManager三个Bean实例；</li><li>使⽤@Transactional注解开启事务。<br>1 @EnableTransactionManagement<br>2 @Configuration<br>3 @ComponentScan(“com.test.tx”)<br>4 public class TxConfig {<br>5 @Bean<br>6 public DataSource dataSource() {<br>7 DruidDataSource dataSource = new DruidDataSource();<br>8 dataSource.setUrl(“jdbc:mysql://127.0.0.1:3306/xxx?useSSL=false”);<br>9 dataSource.setUsername(“xxx”);<br>10 dataSource.setPassword(“xxx”);<br>11 dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);<br>12 return dataSource;<br>13 }<br>14<br>15 @Bean<br>16 public JdbcTemplate jdbcTemplate() {<br>17 return new JdbcTemplate(dataSource());<br>18 }<br>19<br>20 /**<br>21 * 注册事务管理器<br>22 *<br>23 * @author xuan<br>24 * @date 2018/11/3<br>25 <em>/<br>26 @Bean<br>27 public PlatformTransactionManager transactionManager() {<br>28 return new DataSourceTransactionManager(dataSource());<br>29 }<br>30 }<br>31<br>32 @Service<br>33 public class UserService {<br>34<br>35 @Autowired<br>36 private UserDao userDao;<br>37<br>38 /</em>*<br>39 * 添加⽤户<br>40 *<br>41 * @author xuan<br>42 * @date 2018/11/3<br>43 */<br>44 @Transactional<br>45 public void insertUser() {<br>46 User user = new User(“zhangsan”, 27);<br>47 userDao.insert(user);<br>48 }<br>49 }</li><li>springboot的启动过程：<br>a. 通过 SpringFactoriesLoader加载 META-INF/spring.factories⽂件，获取并创建 SpringApplicationRunListener对象<br>b. 然后由 SpringApplicationRunListener来发出 starting 消息<br>c. 创建参数，并配置当前 SpringBoot 应⽤将要使⽤的 Environment<br>d. 完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息<br>e. 创建 ApplicationContext<br>f. 初始化 ApplicationContext，并设置 Environment，加载相关配置等<br>g. 由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应⽤使⽤的 ApplicationContext已准<br>备OK<br>h. 将各种 beans 装载⼊ ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知<br>SpringBoot 应⽤使⽤的 ApplicationContext已装填OK<br>i. refresh ApplicationContext，完成IoC容器可⽤的最后⼀步<br>j. 由 SpringApplicationRunListener来发出 started 消息<br>k. 完成最终的程序的启动<br>l. 由 SpringApplicationRunListener来发出 running 消息，告知程序已运⾏起来了</li><li>spring事件的实现原理，写出常⽤的⼏个事件。<br>a. 事件机制：Spring中的事件机制是⼀个观察者模式的实现.观察者模式就是⼀个⽬标对象管理所有相依于它的观察者对<br>象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。<br>b. spring默认存在的事件：</li><li>ContextStartedEvent：ApplicationContext启动后触发的事件</li><li>ContextStoppedEvent：ApplicationContext停⽌后触发的事件</li><li>ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件</li><li>ContextClosedEvent：ApplicationContext关闭后触发的事件</li></ol><p>Spring 面试问题 TOP 50（干货推荐收藏必备）<br>Spring Framework 现在几乎已成为 Java Web 开发的标配框架。那么，作为 Java 程序员，你对 Spring 的主要技术点又掌握了多少呢？不妨用本文的问题来检测一下。<br>1、一般问题<br>1.1. 不同版本的 Spring Framework 有哪些主要功能？</p><p>1.2. 什么是 Spring Framework？<br>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。<br>它是轻量级、松散耦合的。<br>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。<br>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。<br>1.3. 列举 Spring Framework 的优点。<br>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。<br>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。<br>由于依赖注入和控制反转，JDBC 得以简化。<br>它是开源免费的。<br>1.4. Spring Framework 有哪些不同的功能？<br>轻量级 - Spring 在代码量和透明度方面都很轻便。<br>IOC - 控制反转<br>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。<br>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。<br>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。<br>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。<br>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。<br>1.5. Spring Framework 中有多少个模块，它们分别是什么？</p><p>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：<br>Spring Core<br>Spring Bean<br>SpEL (Spring Expression Language)<br>Spring Context<br>数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：<br>JDBC (Java DataBase Connectivity)<br>ORM (Object Relational Mapping)<br>OXM (Object XML Mappers)<br>JMS (Java Messaging Service)<br>Transaction<br>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<br>Web<br>Web – Servlet<br>Web – Socket<br>Web – Portlet<br>AOP – 该层支持面向切面编程<br>Instrumentation – 该层为类检测和类加载器实现提供支持。<br>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。<br>几个杂项模块:<br>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。<br>Aspects – 该模块为与 AspectJ 的集成提供支持。<br>1.6. 什么是 Spring 配置文件？<br>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。<br>1.7. Spring 应用程序有哪些不同组件？<br>Spring 应用一般有以下组件：<br>接口 - 定义功能。<br>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。<br>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。<br>Bean 配置文件 - 包含类的信息以及如何配置它们。<br>用户程序 - 它使用接口。<br>1.8. 使用 Spring 有哪些方式？<br>使用 Spring 有以下方式：<br>作为一个成熟的 Spring Web 应用程序。<br>作为第三方 Web 框架，使用 Spring Frameworks 中间层。<br>用于远程使用。<br>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。<br>2、依赖注入（Ioc）<br>2.1. 什么是 Spring IOC 容器？<br>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p><p>2.2. 什么是依赖注入？<br>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。<br>2.3. 可以通过多少种方式完成依赖注入？<br>通常，依赖注入可以通过三种方式完成，即：<br>构造函数注入<br>setter 注入<br>接口注入<br>在 Spring Framework 中，仅使用构造函数和 setter 注入。<br>2.4. 区分构造函数注入和 setter 注入。<br>构造函数注入setter 注入没有部分注入有部分注入不会覆盖 setter 属性会覆盖 setter 属性任意修改都会创建一个新实例任意修改不会创建一个新实例适用于设置很多属性适用于设置少量属性<br>2.5. spring 中有多少种 IOC 容器？<br>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。<br>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。<br>2.6. 区分 BeanFactory 和 ApplicationContext。<br>BeanFactoryApplicationContext它使用懒加载它使用即时加载它使用语法显式提供资源对象它自己创建和管理资源对象不支持国际化支持国际化不支持基于依赖的注解支持基于依赖的注解<br>2.7. 列举 IoC 的一些好处。<br>IoC 的一些好处是：<br>它将最小化应用程序中的代码量。<br>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。<br>它以最小的影响和最少的侵入机制促进松耦合。<br>它支持即时的实例化和延迟加载服务。<br>2.8. Spring IoC 的实现机制。<br>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：<br>interface Fruit {<br>public abstract void eat();<br>}<br>class Apple implements Fruit {<br>public void eat(){<br>System.out.println(“Apple”);<br>}<br>}<br>class Orange implements Fruit {<br>public void eat(){<br>System.out.println(“Orange”);<br>}<br>}<br>class Factory {<br>public static Fruit getInstance(String ClassName) {<br>Fruit f=null;<br>try {<br>f=(Fruit)Class.forName(ClassName).newInstance();<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>return f;<br>}<br>}<br>class Client {<br>public static void main(String[] a) {<br>Fruit f=Factory.getInstance(“io.github.dunwu.spring.Apple”);<br>if(f!=null){<br>f.eat();<br>}<br>}<br>}<br>3. Beans<br>3.1. 什么是 spring bean？<br>它们是构成用户应用程序主干的对象。<br>Bean 由 Spring IoC 容器管理。<br>它们由 Spring IoC 容器实例化，配置，装配和管理。<br>Bean 是基于用户提供给容器的配置元数据创建。<br>3.2. spring 提供了哪些配置方式？<br>基于 xml 配置<br>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：<br><bean id="studentbean" class="org.edureka.firstSpring.StudentBean"><br><property name="name" value="Edureka"></property><br></bean><br>基于注解配置<br>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：<br><beans><br><a href="context:annotation-config/">context:annotation-config/</a></beans></p>基于 Java API 配置 Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。 1.@Bean 注解扮演与<bean>元素相同的角色。 2.@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。 例如： @Configuration public class StudentConfig { @Bean public StudentBean myStudent() { return new StudentBean(); } } 3.3. spring 支持集中 bean scope？ Spring bean 支持 5 种 scope： Singleton - 每个 Spring IoC 容器仅有一个单实例。 Prototype - 每次请求都会产生一个新的实例。 Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。 Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。 Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。 仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。 3.4. spring bean 容器的生命周期是什么样的？ spring bean 容器的生命周期流程如下： 1.Spring 容器根据配置中的 bean 定义中实例化 bean。 2.Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。 3.如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。 4.如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。 5.如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。 6.如果为 bean 指定了 init 方法（<bean>的 init-method 属性），那么将调用它。 7.最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。 8.如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。 9.如果为 bean 指定了 destroy 方法（<bean>的 destroy-method 属性），那么将调用它。<p>3.5. 什么是 spring 的内部 bean？<br>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg>中提供了<bean>元素的使用。内部 bean 总是匿名的，它们总是作为原型。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</bean></constructor-arg></property></p><pre><code>Student.java
public class Student &#123;
private Person person;
//Setters and Getters
&#125;
public class Person &#123;
private String name;
private String address;
//Setters and Getters
&#125;
bean.xml
&lt;bean id=“StudentBean&quot; class=&quot;com.edureka.Student&quot;&gt;
&lt;property name=&quot;person&quot;&gt;
&lt;!--This is inner bean --&gt;
&lt;bean class=&quot;com.edureka.Person&quot;&gt;
&lt;property name=&quot;name&quot; value=“Scott&quot;&gt;&lt;/property&gt;
&lt;property name=&quot;address&quot; value=“Bangalore&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>3.6. 什么是 spring 装配<br>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。<br>3.7. 自动装配有哪些方式？<br>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。<br>自动装配的不同模式：<br>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。<br>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。<br>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。<br>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。<br>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。<br>3.8. 自动装配有什么局限？<br>覆盖的可能性 - 您始终可以使用<constructor-arg>和<property>设置指定依赖项，这将覆盖自动装配。<br>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。<br>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。<br>4、注解<br>4.1. 什么是基于注解的容器配置<br>不使用 XML 来描述 bean 装配，开发人员通过在相关的类，方法或字段声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：<br>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<br>@Bean 注解扮演与<br>元素相同的角色。<br>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。<br>例如：<br>@Configuration<br>public class StudentConfig {<br>@Bean<br>public StudentBean myStudent() {<br>return new StudentBean();<br>}<br>}<br>4.2. 如何在 spring 中启动注解装配？<br>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。<br>4.3. @Component, @Controller, @Repository, @Service 有何区别？<br>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。<br>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。<br>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。<br>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。<br>4.4. @Required 注解有什么用？<br>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。<br>示例：<br>public class Employee {<br>private String name;<br>@Required<br>public void setName(String name){<br>this.name=name;<br>}<br>public string getName(){<br>return name;<br>}<br>}<br>4.5. @Autowired 注解有什么用？<br>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。<br>public class Employee {<br>private String name;<br>@Autowired<br>public void setName(String name) {<br>this.name=name;<br>}<br>public string getName(){<br>return name;<br>}<br>}<br>4.6. @Qualifier 注解有什么用？<br>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。<br>Employee.java<br>public class Employee {<br>private String name;<br>@Autowired<br>public void setName(String name) {<br>this.name=name;<br>}<br>public string getName() {<br>return name;<br>}<br>}<br>EmpAccount.java<br>public class EmpAccount {<br>private Employee emp;<br>@Autowired<br>@Qualifier(emp1)<br>public void showName() {<br>System.out.println(“Employee name : ”+emp.getName);<br>}<br>}<br>4.7. @RequestMapping 注解有什么用？<br>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：<br>类级别：映射请求的 URL<br>方法级别：映射 URL 以及 HTTP 请求方法<br>5、数据访问<br>5.1. spring DAO 有什么用？<br>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。<br>5.2. 列举 Spring DAO 抛出的异常。</property></constructor-arg></p><p>5.3. spring JDBC API 中存在哪些类？<br>JdbcTemplate<br>SimpleJdbcTemplate<br>NamedParameterJdbcTemplate<br>SimpleJdbcInsert<br>SimpleJdbcCall<br>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？<br>我们可以通过两种方式使用 Spring 访问 Hibernate：<br>1.使用 Hibernate 模板和回调进行控制反转<br>2.扩展 HibernateDAOSupport 并应用 AOP 拦截器节点<br>5.5. 列举 spring 支持的事务管理类型<br>Spring 支持两种类型的事务管理：<br>1.程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。<br>2.声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。<br>5.6. spring 支持哪些 ORM 框架<br>Hibernate<br>iBatis<br>JPA<br>JDO<br>OJB<br>6、AOP<br>6.1. 什么是 AOP？<br>AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)<br>6.2. 什么是 Aspect？<br>aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:<br>1.如何通过 pointcut 和 advice 定位到特定的 joinpoint 上<br>2.如何在 advice 中编写切面代码.<br>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p><p>6.3. 什么是切点（JoinPoint）<br>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<br>在 Spring AOP 中, join point 总是方法的执行点。<br>6.4. 什么是通知（Advice）？<br>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。<br>6.5. 有哪些类型的通知（Advice）？<br>Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。<br>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。<br>After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。<br>After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。<br>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。<br>6.6. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。<br>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。<br>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。<br>6.7. AOP 有哪些实现方式？<br>实现 AOP 的技术，主要分为两大类：<br>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<br>编译时编织（特殊编译器实现）<br>类加载时编织（特殊的类加载器实现）。<br>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<br>JDK 动态代理<br>CGLIB<br>6.8. Spring AOP and AspectJ AOP 有什么区别？<br>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。<br>6.9. 如何理解 Spring 中的代理？<br>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<br>Advice + Target Object = Proxy<br>6.10. 什么是编织（Weaving）？<br>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p><p>7、MVC<br>7.1. Spring MVC 框架有什么用？<br>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。<br>7.2. 描述一下 DispatcherServlet 的工作流程<br>DispatcherServlet 的工作流程可以用一幅图来说明：</p><p>1.向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。<br>2.DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。<br>3.DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。<br>4.提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<br>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。<br>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。<br>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。<br>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。<br>1.Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；<br>2.根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。<br>3.ViewResolver 结合Model和View，来渲染视图。<br>4.视图负责将渲染结果返回给客户端。<br>7.3. 介绍一下 WebApplicationContext<br>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p><p>Spring部分<br>1.谈谈你对spring IOC和DI的理解，它们有什么区别？<br>IoC Inverse of Control 反转控制的概念，就是将原本在程序中手动创建UserService对象的控制权，交由Spring框架管理，简单说，就是创建UserService对象控制权被反转到了Spring框架<br>DI：Dependency Injection 依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件 </p><p>面试题： IoC 和 DI的区别？ <br>IoC 控制反转，指将对象的创建权，反转到Spring容器 ， DI 依赖注入，指Spring创建对象的过程中，将对象依赖属性通过配置进行注入 <br>2.BeanFactory 接口和 ApplicationContext 接口有什么区别 ？<br>    ①ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。<br>    ②ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现 <br>开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory </p><p>BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(“applicationContext.xml”));<br>IHelloService helloService = (IHelloService) beanFactory.getBean(“helloService”);<br>helloService.sayHello();<br>3.spring配置bean实例化有哪些方式？<br>    1）使用类构造器实例化(默认无参数)</p><p><bean id="bean1" class="cn.itcast.spring.b_instance.Bean1"></bean><br>    2）使用静态工厂方法实例化(简单工厂模式)</p><p>//下面这段配置的含义：调用Bean2Factory的getBean2方法得到bean2<br><bean id="bean2" class="cn.itcast.spring.b_instance.Bean2Factory" factory-method="getBean2"></bean><br>    3）使用实例工厂方法实例化(工厂方法模式)</p><p>//先创建工厂实例bean3Facory，再通过工厂实例创建目标bean实例<br><bean id="bean3Factory" class="cn.itcast.spring.b_instance.Bean3Factory"></bean><br><bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"></bean><br>4.简单的说一下spring的生命周期？<br>    1)在配置 <bean> 元素，通过 init-method 指定Bean的初始化方法，通过 destroy-method 指定Bean销毁方法 </bean></p><p><bean id="lifeCycleBean" class="cn.itcast.spring.d_lifecycle.LifeCycleBean" init-method="setup" destroy-method="teardown"></bean><br>需要注意的问题：</p><p>    *  destroy-method 只对 scope=”singleton” 有效  <br>    *  销毁方法，必须关闭ApplicationContext对象(手动调用)，才会被调用</p><p>ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>applicationContext.close();<br>    2)Bean的完整生命周期 （十一步骤）【了解内容，但是对于spring内部操作理解有一定帮助】<br>①instantiate bean对象实例化<br>②populate properties 封装属性<br>③如果Bean实现BeanNameAware 执行 setBeanName<br>④如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext<br>⑤如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)</p><p>public class MyBeanPostProcessor implements BeanPostProcessor {<br>public Object postProcessAfterInitialization(Object bean, String beanName)<br>throws BeansException {<br>System.out.println(“第八步：后处理Bean，after初始化。”);<br>//后处理Bean，在这里加上一个动态代理，就把这个Bean给修改了。<br>return bean;//返回bean，表示没有修改，如果使用动态代理，返回代理对象，那么就修改了。<br>}<br>public Object postProcessBeforeInitialization(Object bean, String beanName)<br>throws BeansException {<br>System.out.println(“第五步：后处理Bean的：before初始化！！”);<br>//后处理Bean，在这里加上一个动态代理，就把这个Bean给修改了。<br>return bean;//返回bean本身，表示没有修改。<br>}<br>}<br>注意：这个前处理Bean和后处理Bean会对所有的Bean进行拦截。<br>⑥如果Bean实现InitializingBean 执行 afterPropertiesSet </p><p>⑦调用<bean init-method="init"> 指定初始化方法 init<br>⑧如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization<br>⑨执行业务处理<br>⑩如果Bean实现 DisposableBean 执行 destroy<br>⑪调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy<br>5.请介绍一下Spring框架中Bean的生命周期和作用域 </bean></bean></p><p>(1)bean定义<br>    在配置文件里面用<bean></bean>来进行定义。<br>(2)bean初始化<br>    有两种方式初始化:<br>A.在配置文件中通过指定init-method属性来完成<br>B.实现org.springframwork.beans.factory.InitializingBean接口<br>(3)bean调用<br>    有三种方式可以得到bean实例，并进行调用<br>(4)bean销毁<br>    销毁有两种方式<br>A.使用配置文件指定的destroy-method属性<br>B.实现org.springframwork.bean.factory.DisposeableBean接口<br>##作用域<br>singleton<br>当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。<br>prototype<br>Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域<br>request<br>在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用 域仅在基于web的Spring ApplicationContext情形下有效。<br>session<br>在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>global session<br>在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于 web的Spring ApplicationContext情形下有效。</p><p>6.Bean注入属性有哪几种方式？</p><p>spring支持构造器注入和setter方法注入<br>    构造器注入，通过 <constructor-arg> 元素完成注入<br>    setter方法注入， 通过<property> 元素完成注入【开发中常用方式】<br>7.什么是AOP，AOP的作用是什么？<br>面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足，除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理 <br>Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP 提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上。允许用户实现自定义切面，用AOP来完善OOP的使用,可以把Spring AOP看作是对Spring的一种增强 </property></constructor-arg></p><p>8.Spring的核心类有哪些，各有什么作用？<br>BeanFactory：产生一个新的实例，可以实现单例模式<br>BeanWrapper：提供统一的get及set方法<br>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能<br>9.Spring里面如何配置数据库驱动？<br>使用”org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动。示例如下： <br>1<bean id="”dataSource”"> <br>2    <property name="”driverClassName”"> <br>3       <value>org.hsqldb.jdbcDriver</value><br>4    </property> <br>5<br>6   <property name="”url”"> <br>7        <value>jdbc:hsqldb:db/appfuse</value> <br>8    </property> <br>9<br>10    <property name="”username”"><value>abc</value></property> <br>11    <property name="”password”"><value>abc</value></property> <br>12</bean> <br>10.Spring里面applicationContext.xml文件能不能改成其他文件名？ <br>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化。缺省情况下， 它会在WEB-INF/applicationContext.xml文件找Spring的配置。 你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的 位置。示例如下： </context-param></p><p>1<listener> <br>2    <listener-class>org.springframework.web.context.ContextLoaderListener<br>3        <context-param> <br>4        <param-name>contextConfigLocation</param-name> <br>5        <param-value>/WEB-INF/xyz.xml</param-value> <br>6        </context-param>    <br>7    </listener-class> <br>8</listener> <br>11.Spring里面如何定义hibernate mapping？ </p><p>添加hibernate mapping 文件到web/WEB-INF目录下的applicationContext.xml文件里面。示例如下： <br>1<property name="”mappingResources”"> <br>2    <list> <br>3        <value>org/appfuse/model/User.hbm.xml</value> <br>4    </list> <br>5</property><br>12.Spring如何处理线程并发问题？<br>Spring使用ThreadLocal解决线程安全问题<br>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。<br>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。<br>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。<br>而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<br>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。<br>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。<br>13.为什么要有事物传播行为？</p><p>14.介绍一下Spring的事物管理<br>    事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。<br>开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管 理，可以通过Spring的注入来完成此功能。spring提供了几个关于事务处理的类：<br>TransactionDefinition //事务属性定义<br>TranscationStatus //代表了当前的事务，可以提交，回滚。<br>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。<br>一般事务定义步骤：</p><p>1TransactionDefinition td = new TransactionDefinition();<br>2TransactionStatus ts = transactionManager.getTransaction(td);<br>3try{ <br>4    //do sth<br>5    transactionManager.commit(ts);<br>6}catch(Exception e){<br>7    transactionManager.rollback(ts);<br>8}<br>    spring提供的事务管理可以分为两类：编程式的和声明式的。编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的更灵活。</p><p>编程式主要使用transactionTemplate。省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.</p><p>1void add(){<br>2    transactionTemplate.execute( new TransactionCallback(){<br>3        pulic Object doInTransaction(TransactionStatus ts){<br>4         //do sth<br>5        }<br>6    }<br>7}<br>声明式：</p><p>使用TransactionProxyFactoryBean:PROPAGATION_REQUIRED PROPAGATION_REQUIRED PROPAGATION_REQUIRED,readOnly<br>围绕Poxy的动态代理 能够自动的提交和回滚事务<br>org.springframework.transaction.interceptor.TransactionProxyFactoryBean<br>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。<br>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。<br>PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与 PROPAGATION_REQUIRED类似的操作。<br>15.解释一下Spring AOP里面的几个名词<br>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@AspectJ风格）来实现。<br>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。 在Spring AOP中，一个连接点 总是 代表一个方法的执行。 通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息。<br>通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。 通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。<br>切入点（Pointcut）：匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。 切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。<br>引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。 Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。<br>目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（advised） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。<br>AOP代理（AOP Proxy）： AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 注意：Spring 2.0最新引入的基于模式（schema-based）风格和@AspectJ注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。<br>织入（Weaving）：把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。 这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。 Spring和其他纯Java AOP框架一样，在运行时完成织入。</p><p>16.通知有哪些类型？<br>前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。<br>返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。<br>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。<br>后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。<br>环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。<br> <br>环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。<br>切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</p><p>Spring 概述</p><ol><li>什么是 spring?<br>Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，<br>但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企<br>业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</li><li>使用 Spring 框架的好处是什么？<br>轻量：Spring 是轻量的，基本的版本大约 2MB<br>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是<br>创建或查找依赖的对象们<br>面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服<br>务分开<br>容器：Spring 包含并管理应用中对象的生命周期和配置<br>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的<br>替代品<br>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全<br>局事务（JTA）<br>异 常 处 理 ： Spring 提 供 方 便 的 API 把 具 体 技 术 相 关 的 异 常 （ 比 如 由 JDBC ，<br>Hibernate or JDO 抛出的）转化为一致的 unchecked 异常</li><li>Spring 由哪些模块组成？<br>以下是 Spring 框架的基本模块：<br>Core module<br>Bean module<br>Context module<br>Expression Language module<br>JDBC module<br>ORM module<br>OXM module<br>Java Messaging Service(JMS) module<br>Transaction module<br>Web module<br>Web-Servlet module<br>Web-Struts module<br>Web-Portlet module</li><li>核心容器（应用上下文) 模块<br>这是基本的 Spring 模块，提供 spring 框架的基础功能，BeanFactory 是 任何以<br>spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使 Spring 成为一<br>个容器。</li><li>BeanFactory – BeanFactory 实现举例<br>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖<br>从正真的应用代码中分离。最常用的 BeanFactory 实现是 XmlBeanFactory 类。</li><li>XMLBeanFactory<br>最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory ，它根<br>据 XML 文件中的定义加载 beans。该容器从 XML 文件读取配置元数据并用它去创<br>建一个完全配置的系统或应用。</li><li>解释 AOP 模块<br>AOP 模块用于发给我们的 Spring 应用做面向切面的开发， 很多支持由 AOP 联盟提<br>供，这样就确保了 Spring 和其他 AOP 框架的共通性。这个模块将元数据编程引入<br>Spring。</li><li>解释 JDBC 抽象和 DAO 模块<br>通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源错<br>误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常<br>访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务管理服务。</li><li>解释对象/关系映射集成模块<br>Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象/关系映射<br>映射(ORM)工具，Spring 支持集成主流的 ORM 框架，如 Hiberate,JDO 和 iBATIS<br>SQL Maps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。</li><li>解释 WEB 模块<br>Spring 的 WEB 模块是构建在 application context 模块基础之上，提供一个适合<br>web 应用的上下文。这个模块也包括支持多种面向 web 的任务，如透明地处理多个<br>文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对 Jakarta Struts<br>的支持。</li><li>Spring 配置文件<br>Spring 配置文件是个 XML 文件，这个文件包含了类信息，描述了如何配置它们，<br>以及如何相互调用。</li><li>什么是 Spring IOC 容器？<br>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，<br>并且管理这些对象的整个生命周期。</li><li>IOC 的优点是什么？<br>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要<br>单例和 JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器<br>支持加载服务时的饿汉式初始化和懒加载。</li><li>ApplicationContext 通常的实现是什么？<br> FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加载 beans<br>的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。<br> ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载 beans<br>的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找<br>bean 配置。<br> WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个<br>WEB 应用的所有 bean。</li><li>Bean 工厂和 Application contexts 有什么区别？<br>Application contexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源<br>（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内<br>的 对 象 上 执 行 的 那 些 不 得 不 由 bean 工 厂 以 程 序 化 方 式 处 理 的 操 作 ， 可 以 在<br>Application contexts 中 以 声 明 的 方 式 处 理 。 Application contexts 实 现 了<br>MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</li><li>一个 Spring 的应用看起来象什么？<br> 一个定义了一些功能的接口<br> 这实现包括属性，它的 Setter ， getter 方法和函数等<br> Spring AOP<br> Spring 的 XML 配置文件<br> 使用以上功能的客户端程序<br>依赖注入</li><li>什么是 Spring 的依赖注入？<br>依赖注入，是 IOC 的一个方面，是个通常的概念，它有多种解释。这概念是说你不<br>用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，<br>但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC 容器）负责把<br>他们组装起来。</li><li>有哪些不同类型的 IOC（依赖注入）方式？<br>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一<br>系列参数，每个参数代表一个对其他类的依赖。<br>Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂 方<br>法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注<br>入。</li><li>哪种依赖注入方式你建议使用，构造器注入，还是 Setter 方法注入？<br>你两种依赖方式都可以使用，构造器注入和 Setter 方法注入。最好的解决方案是用<br>构造器参数实现强制依赖，setter 方法实现可选依赖。<br>Spring Beans</li><li>什么是 Spring beans？<br>Spring beans 是那些形成 Spring 应用的主干的 java 对象。它们被 Spring IOC 容<br>器初始化，装配，和管理。这些 beans 通过容器中配置的元数据创建。比如，以 XML<br>文件中<bean>的形式定义。<br>Spring 框架定义的 beans 都是单件 beans。在 bean tag 中有个属性”singleton”，<br>如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean。默认是<br>TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件。点击这里一图 Spring<br>Bean 的生命周期。</li><li>一个 Spring Bean 定义 包含什么？<br>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个<br>bean，它的生命周期详情及它的依赖。</li><li>如何给 Spring 容器提供配置元数据？<br>这里有三种重要的方法给 Spring 容器提供配置元数据。<br> XML 配置文件。<br> 基于注解的配置。<br> 基于 java 的配置。</li><li>你怎样定义类的作用域？<br>当定义一个<bean>在 Spring 里，我们还能给这个 bean 声明一个作用域。它可以<br>通过 bean 定义中的 scope 属性来定义。如，当 Spring 要在需要的时候每次生产一<br>个新的 bean 实例，bean 的 scope 属性被指定为 prototype。另一方面，一个 bean<br>每 次 使 用 的 时 候 必 须 返 回 同 一 个 实 例 ， 这 个 bean 的 scope 属 性 必 须 设 为<br>singleton。</bean></li><li>解释 Spring 支持的几种 bean 的作用域<br>Spring 框架支持以下五种 bean 的作用域：<br> singleton : bean 在每个 Spring ioc 容器中只有一个实例。<br> prototype：一个 bean 的定义可以有多个实例。<br> request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring<br>ApplicationContext 情形下有效。<br> session：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域<br>仅在基于 web 的 Spring ApplicationContext 情形下有效。<br> global-session：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实<br>例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。<br> 缺省的 Spring bean 的作用域是 Singleton。</li><li>Spring 框架中的单例 bean 是线程安全的吗？<br>不，Spring 框架中的单例 bean 不是线程安全的。</li><li>解释 Spring 框架中 bean 的生命周期<br>Spring 容器 从 XML 文件中读取 bean 的定义，并实例化 bean。<br>Spring 根据 bean 的定义填充所有的属性。<br>如 果 bean 实 现 了 BeanNameAware 接 口 ， Spring 传 递 bean 的 ID 到<br>setBeanName 方法。<br>如 果 Bean 实 现 了 BeanFactoryAware 接 口 ， Spring 传 递 beanfactory 给<br>setBeanFactory 方法。<br>如 果 有 任 何 与 bean 相 关 联 的 BeanPostProcessors ， Spring 会 在<br>postProcesserBeforeInitialization()方法内调用它们。<br>如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，如果 bean<br>声明了初始化方法，调用此初始化方法。<br>如 果 有 BeanPostProcessors 和 bean 关 联 ， 这 些 bean 的<br>postProcessAfterInitialization() 方法将被调用。<br>如果 bean 实现了 DisposableBean，它将调用 destroy()方法。<br>点击这里一图 Spring Bean 的生命周期。</li><li>哪些是重要的 bean 生命周期方法？ 你能重载它们吗？<br>有两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时<br>候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。<br>The bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你<br>可 以 自 己 定 制 初 始 化 和 注 销 方 法 。 它 们 也 有 相 应 的 注 解 （ @PostConstruct 和<br>@PreDestroy）。</li><li>什么是 Spring 的内部 bean？<br>当一个 bean 仅被用作另一个 bean 的属性时，它能被声明为一个内部 bean，为了<br>定义 inner bean，在 Spring 的 基于 XML 的 配置元数据中，可以在<property><br>或<constructor-arg>元素内使用<bean>元素，内部 bean 通常是匿名的，它<br>们的 Scope 一般是 prototype。</li><li>在 Spring 中如何注入一个 java 集合？<br>Spring 提供以下几种集合的配置元素：<br><list>类型用于注入一列值，允许有相同的值。<br><set>类型用于注入一组值，不允许有相同的值。<br><map>类型用于注入一组键值对，键和值都可以为任意类型。<br><props>类型用于注入一组键值对，键和值都只能为 String 类型。</props></map></set></list></li><li>什么是 bean 装配？<br>装配，或 bean 装配是指在 Spring 容器中把 bean 组装到一起，前提是容器需要知<br>道 bean 的依赖关系，如何通过依赖注入来把它们装配到一起。</li><li>什么是 bean 的自动装配？<br>Spring 容 器 能 够 自 动 装 配 相 互 合 作 的 bean ， 这 意 味 着 容 器 不 需 要<br><constructor-arg>和<property>配置，能通过 Bean 工厂自动处理 bean 之间的协<br>作。</property></constructor-arg></li><li>解释不同方式的自动装配<br>有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入<br>no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。<br>byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire<br>属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的<br>bean。<br>byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire<br>属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的<br>bean。如果有多个 bean 符合条件，则抛出错误。<br>constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定<br>的带参数的构造器参数类型，将会抛出异常。<br>autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType<br>方式。</li><li>自动装配有哪些局限性？<br>自动装配的局限性是：<br>重写：你仍需用<constructor-arg>和<property>配置来定义依赖，意味着总要<br>重写自动装配。<br>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String 字符串，和类。<br>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</property></constructor-arg></li><li>你可以在 Spring 中注入一个 null 和一个空字符串吗？<br>可以。 Spring 注解</li><li>什么是基于 Java 的 Spring 注解配置? 给一些注解的例子<br>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring<br>配置而非通过 XML 文件。<br>以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring<br>IOC 容器使用。另一个例子是@Bean 注解，它表示此方法将要返回一个对象，作为<br>一个 bean 注册进 Spring 应用上下文。点击这里学习 JAVA 几大元注解。</li><li>什么是基于注解的容器配置？<br>相对于 XML 文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的<br>声明。<br>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而<br>不是使用 xml 表述 bean 的装配关系。</li><li>怎样开启注解装配？<br>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在 Spring 配置文<br>件中配置 <a href="context:annotation-config/">context:annotation-config/</a>元素。</li><li>@Required 注解<br>这个注解表明 bean 的属性必须在配置的时候设置，通过一个 bean 定义的显式的属<br>性 值 或 通 过 自 动 装 配 ， 若 @Required 注 解 的 bean 属 性 未 被 设 置 ， 容 器 将 抛 出<br>BeanInitializationException。</li><li>@Autowired 注解<br>@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它<br>的用法和@Required 一样，修饰 setter 方法、构造器、属性或者具有任意名称和/<br>或多个参数的 PN 方法。</li><li>@Qualifier 注解<br>当 有 多 个 相同 类 型 的 bean 却 只 有 一 个需 要 自 动 装 配 时 ，将 @Qualifier 注 解 和<br>@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的 bean。点击这<br>里学习更多常用注解。 Spring 数据访问</li><li>在 Spring 框架中如何更有效地使用 JDBC？<br>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需<br>写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供的<br>模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate</li><li>JdbcTemplate<br>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类<br>型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li><li>Spring 对 DAO 的支持<br>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，<br>Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会<br>捕获每种技术特有的异常。</li><li>使用 Spring 通过什么方式访问 Hibernate？<br>在 Spring 中有两种方式访问 Hibernate：<br>控制反转 Hibernate Template 和 Callback<br>继承 HibernateDAOSupport 提供一个 AOP 拦截器</li><li>Spring 支持的 ORM<br>Spring 支持以下 ORM：<br>Hibernate<br>iBatis<br>JPA (Java Persistence API)<br>TopLink<br>JDO (Java Data Objects)<br>OJB</li><li>如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？<br>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<br>配置 the Hibernate SessionFactory<br>继承 HibernateDaoSupport 实现一个 DAO<br>在 AOP 支持的事务中装配</li><li>Spring 支持的事务管理类型<br>Spring 支持两种类型的事务管理：<br>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是<br>难维护。<br>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML<br>配置来管理事务。</li><li>Spring 框架的事务管理有哪些优点？<br>它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供一个不变<br>的编程模式。<br>它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API 如<br>它支持声明式事务管理。<br>它和 Spring 各种数据访问抽象层很好得集成。</li><li>你更倾向用那种事务管理类型？<br>大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因<br>此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，<br>虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。 Spring 面向切面编程（AOP）</li><li>解释 AOP<br>面向切面的编程，或 AOP， 是一种编程技术，允许程序模块化横向切割关注点，或<br>横切典型的责任划分，如日志和事务管理。</li><li>Aspect 切面<br>AOP 核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组<br>API 提供横切功能。比如，一个日志模块可以被称作日志的 AOP 切面。根据需求的<br>不同，一个应用程序可以有若干切面。在 Spring AOP 中，切面通过带有@Aspect<br>注解的类实现。</li><li>在 Spring AOP 中，关注点和横切关注的区别是什么？<br>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个<br>功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，<br>比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横<br>切关注点。</li><li>连接点<br>连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个 AOP 切面，它<br>实际上是个应用程序执行 Spring AOP 的位置。</li><li>通知<br>通 知 是 个 在 方 法 执 行 前 或 执 行 后 要 做 的 动 作 ， 实 际 上 是 程 序 执 行 时 要 通 过<br>SpringAOP 框架触发的代码段。<br>Spring 切面可以应用五种类型的通知：<br>before：前置通知，在一个方法执行前被调用<br>after：在方法执行之后调用的通知，无论方法执行是否成功<br>after-returning：仅当方法成功完成后执行的通知<br>after-throwing：在方法抛出异常退出时执行的通知<br>around：在方法执行之前和之后调用的通知</li><li>切点<br>切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式<br>指明切入点。</li><li>什么是引入？<br>引入允许我们在已存在的类中增加新的方法和属性。</li><li>什么是目标对象？<br>被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）<br>对象。</li><li>什么是代理？<br>代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样<br>的。</li><li>有几种不同类型的自动代理？<br>BeanNameAutoProxyCreator<br>DefaultAdvisorAutoProxyCreator<br>Metadata autoproxying</li><li>什么是织入。什么是织入应用的不同点？<br>织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。<br>织入可以在编译时，加载时，或运行时完成。</li><li>解释基于 XML Schema 方式的切面实现<br>在这种情况下，切面由常规类以及基于 XML 的配置实现。</li><li>解释基于注解的切面实现<br>在这种情况下(基于@AspectJ 的实现)，涉及到的切面声明的风格与带有 java5 标注<br>的普通 java 类一致。 Spring 的 MVC</li><li>什么是 Spring 的 MVC 框架？<br>Spring 配备构建 Web 应用的全功能 MVC 框架。Spring 可以很便捷地和其他 MVC<br>框架集成，如 Struts，Spring 的 MVC 框架用控制反转把业务对象和控制逻辑清晰<br>地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</li><li>DispatcherServlet<br>Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP<br>请求和响应。</li><li>WebApplicationContext<br>WebApplicationContext 继承了 ApplicationContext 并增加了一些 WEB 应用<br>必备的特有功能，它不同于一般的 ApplicationContext ，因为它能处理主题，并找<br>到被关联的 servlet。</li><li>什么是 Spring MVC 框架的控制器？<br>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用<br>户输入并将其转换为一个由视图呈现给用户的模型。Spring 用一个非常抽象的方式<br>实现了一个控制层，允许用户创建多种用途的控制器。</li><li>@Controller 注解<br>该注解表明该类扮演控制器的角色，Spring 不需要你继承任何其他控制器基类或引<br>用 Servlet API。</li><li>@RequestMapping 注解<br>该注解是用来映射一个 URL 到一个类或一个特定的方处理法上。</li></ol><ul><li>Spring的优点有什么?</li></ul><p>1.Spring是分层的架构，你可以选择使用你需要的层而不用管不需要的部分<br>2.Spring是POJO编程，POJO编程使得可持续构建和可测试能力提高<br>3.依赖注入和IoC使得JDBC操作简单化<br>4.Spring是开源的免费的<br>5.Spring使得对象管理集中化合简单化</p><ul><li>描述一下spring中实现DI（dependency injection）的几种方式<br>方式一：接口注入，在实际中得到了普遍应用，即使在IOC的概念尚未确立时，这样的方法也已经频繁出现在我们的代码中。<br>方式二：Type2 IoC: Setter injection对象创建之后，将被依赖对象通过set方法设置进去<br>方式三：Type3 IoC: Constructor injection对象创建时，被依赖对象以构造方法参数的方式注入<br>Spring的方式</li><li>简单描述下IOC(inversion of control)的理解<br>一个类需要用到某个接口的方法，我们需要将类A和接口B的实现关联起来，最简单的方法是类A中创建一个对于接口B的实现C的实例，但这种方法显然两者的依赖（Dependency）太大了。而IoC的方法是只在类A中定义好用于关联接口B的实现的方法，将类A，接口B和接口B的实现C放入IoC的 容器（Container）中，通过一定的配置由容器（Container）来实现类A与接口B的实现C的关联。</li><li>Spring对很多ORM框架提供了很好支持，描述下在spring使用hibernate的方法<br>在context中定义DataSource，创建SessionFactoy，设置参数；DAO类继承HibernateDaoSupport，实现具体接口，从中获得HibernateTemplate进行具体操作。在使用中如果遇到OpenSessionInView的问题，可以添加OpenSessionInViewFilter或OpenSessionInViewInterceptor</li><li>请介绍下spring的事务管理<br>spring提供了几个关于事务处理的类：<br>TransactionDefinition //事务属性定义<br>TranscationStatus //代表了当前的事务，可以提交，回滚。<br>PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类AbstractPlatformTransactionManager,我们使用的事务管理类例如DataSourceTransactionManager等都是这个类的子类。<br>一般事务定义步骤：<br>TransactionDefinition td = new TransactionDefinition();<br>TransactionStatus ts = transactionManager.getTransaction(td);<br>try<br>{ //do sth<br>transactionManager.commit(ts);<br>}<br>catch(Exception e){transactionManager.rollback(ts);}<br>spring提供的事务管理可以分为两类：编程式的和声明式的。编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的更灵活。<br>编程式主要使用transactionTemplate。省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.<br>void add()<br>{<br>transactionTemplate.execute( new TransactionCallback(){<br>pulic Object doInTransaction(TransactionStatus ts)<br>{ //do sth}<br>}<br>}<br>声明式：<br>使用TransactionProxyFactoryBean:</li></ul><p>PROPAGATION_REQUIRED PROPAGATION_REQUIRED PROPAGATION_REQUIRED,readOnly<br>围绕Poxy的动态代理 能够自动的提交和回滚事务<br>org.springframework.transaction.interceptor.TransactionProxyFactoryBean<br>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。<br>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。<br>PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p><ul><li>如何在spring的applicationContext.xml使用JNDI而不是DataSource<br>可以使用”org.springframework.jndi.JndiObjectFactoryBean”来实现。示例如下：<bean id="”dataSource”">   <property name="”jndiName”">       <value>java:comp/env/jdbc/appfuse</value>   </property></bean></li><li>在spring中是如何配置数据库驱动的<br>org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动。示例如下：<bean id="”dataSource”">   <property name="”driverClassName”">       <value>org.hsqldb.jdbcDriver</value>   </property>   <property name="”url”">       <value>jdbc:hsqldb:db/appfuse</value>   </property>   <property name="”username”"><value>sa</value></property>   <property name="”password”"><value></value></property></bean></li><li>spring中的applicationContext.xml能不能改为其他名字<br>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化。缺省情况下， 它会在WEB-INF/applicationContext.xml文件找Spring的配置。 你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的位置。示例如下：<listener>   <listener-class>org.springframework.web.context.ContextLoaderListener      <context-param>       <param-name>contextConfigLocation</param-name>       <param-value>/WEB-INF/xyz.xml</param-value>   </context-param>     </listener-class></listener></context-param></li><li>在web中如何配置spring<br>在J2EE的web应用里面配置spring非常简单，最简单的只需要把spring得ContextLoaderListener添加到你的web.xml文件里面就可以了，示例如下：<listener>   <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class></listener></li><li>在spring中如何定义hibernate Mapping？<br>添加hibernate mapping 文件到web/WEB-INF目录下的applicationContext.xml文件里面。示例如下：<property name="”mappingResources”">   <list>       <value>org/appfuse/model/User.hbm.xml</value>   </list></property></li><li>两种依赖注入的类型是什么?<br>两种依赖注入的类型分别是setter注入和构造方法注入。<br>setter注入： 一般情况下所有的java bean, 我们都会使用setter方法和getter方法去设置和获取属性的值，示例如下：<br>public class namebean {<br>     String      name;  <br>     public void setName(String a) {<br>        name = a; }<br>     public String getName() {<br>        return name; }<br>    }<br>我们会创建一个bean的实例然后设置属性的值，spring的配置文件如下：<br><bean id="”bean1″  "><br>  <property name="”name”"><br>      <value>tom</value><br>  </property></bean>Spring会调用setName方法来只是name熟悉为tom 构造方法注入：构造方法注入中，我们使用带参数的构造方法如下： public class namebean {      String name;      public namebean(String a) {         name = a;      }    } 我们会在创建bean实例的时候以new namebean(”tom”)的方式来设置name属性, Spring配置文件如下：<bean id="”bean1″ ">   <constructor-arg>      <value>My Bean Value</value>  </constructor-arg></bean>使用constructor-arg标签来设置构造方法的参数。</li><li>解释一下Dependency Injection(DI)和IOC（inversion of control）?<br>参考答案：依赖注入DI是一个程序设计模式和架构模型， 一些时候也称作控制反转，尽管在技术上来讲，依赖注入是一个IOC的特殊实现，依赖注入是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个数据库连接已参数的形式传到一个对象的结构方法里面而不是在那个对象内部自行创建一个连接。控制反转和依赖注入的基本思想就是把类的依赖从类内部转化到外部以减少依赖<br>应用控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所以，控制反转是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转</li><li>Spring中BeanFactory和ApplicationContext的作用和区别<br>作用：</li></ul><ol><li>BeanFactory负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。</li><li>ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：<br>a. 国际化支持<br>b. 资源访问：Resource rs = ctx. getResource(”classpath:config.properties”), “file:c:/config.properties”<br>c. 事件传递：通过实现ApplicationContextAware接口</li><li>常用的获取ApplicationContext的方法：<br>FileSystemXmlApplicationContext：从文件系统或者url指定的xml配置文件创建，参数为配置文件名或文件名数组<br>ClassPathXmlApplicationContext：从classpath的xml配置文件创建，可以从jar包中读取配置文件<br>WebApplicationContextUtils：从web应用的根目录读取配置文件，需要先在web.xml中配置，可以配置监听器或者servlet来实现<listener><listener-class>org.springframework.web.context.ContextLoaderListener</listener-class></listener><servlet><servlet-name>context</servlet-name><servlet-class>org.springframework.web.context.ContextLoaderServlet</servlet-class><load-on-startup>1</load-on-startup></servlet>这两种方式都默认配置文件为web-inf/applicationContext.xml，也可使用context-param指定配置文件<context-param><param-name>contextConfigLocation</param-name><param-value>/WEB-INF/myApplicationContext.xml</param-value></context-param></li></ol><ul><li>在web环境下如何配置applicationContext.xml文件<listener>  <listener-class>   org.springframework.web.context.ContextLoaderListener   </listener-class> </listener> 或：  <servlet>  <servlet-name>context</servlet-name>   <servlet-class>    org.springframework.web.context.ContextLoaderServlet    </servlet-class>  <load-on-startup>1</load-on-startup> </servlet> 通过如下方法取出applicationContext实例:  ApplicationContext ac=WebApplicationContextUtils.getWebApplicationContext(this.getServletContext);</li><li>如何配置spring + struts？<br>在struts-config.xml加入一个插件，通过它加载applicationContext.xml<br>在struts-config.xml修改action-mapping标记，具体action交给了DelegateActionProxy<br>通过DelegateActionProxy进入一spring的环境。<br>在spring的applicationContext.xml加入&lt;bean name=”/login” class=”” singleton=”false”/&gt;</li><li>Spring 和 hibernate的配置文件中的主要类型有哪些？如何配置?<br>在myeclipse中先加入spring环境再加入hibernate环境。<br> 如果spring与hibernate结合在一起可以不需要hibernate.cfg.xml文件是否正确?<br> spring+hibernate的配置文件中的主要类有那些?如何配置?<br>  dataSource<br>  sessionFactory:hibernate.cfg.xml<br>  transactionManager<br>  userDao (extends HibernateDaoSupport) <br>   sessionFactory<br>  facade<br>  proxy<br>   sessionFactory<br>   transactionManager<br>   facade</li><li>在spring中如何配置容器的事物管理，相关的类有哪些?<br>Datasouce<br>   transactionManager<br>   userDao要注入<br>    Datasouce<br>   Proxy代理<br>    Target:userDao：代理对象(目标对象)<br>    transactionAttributes(那些方法需要事务处理)<br>    transactionManager(事务处理服务)</li><li>在spring中如何配代码的事务管理器<br>Datasouce<br>   transactionManager<br>   userDao要注入<br>    Datasouce<br>    transactionManager<br>  通过如下类实现<br>    TransactionTemplate<br>    JdbcTemplate</li><li>Spring中有几种事物管理，分别是什么?<br>代码管理的事务处理<br>TransactonTemplate的execute方法中的内部类TransactionCallback中的doInTransaction方法中使用。<br>public void make()<br> { <br>  TransactionTemplate jtm=new TransactionTemplate(this.getTransactionManager());<br>  jtm.execute(new myClass1());<br> }<br> public class myClass1 implements TransactionCallback<br> {<br>  public Object doInTransaction(TransactionStatus trans)<br>  {<br>   JdbcTemplate jdbc=new JdbcTemplate(dataSource);<br>   jdbc.execute(”insert into customer(customerName) values(’b’)”);<br>   jdbc.execute(”insert into customer(customerName) values(’b’)”);<br>   return null;<br>  }  <br> }<br>   容器管理的事务处理</li><li>spring中的jdbc与传统的jdbc有什么区别?<br>Spring的jdbc:节省代码，不管连接(Connection)，不管事务、不管异常、不管关闭(con.close() ps.close )<br>  JdbcTemplate(dataSource):增、删、改、查<br>  TransactionTemplate(transactionManager):进行事务处理</li><li>Spring配置的主要标签有什么?有什么作用?<beans>   <bean id="””" class="””" init="””" destroy="””" singleton="””">    <property name="””">     <value></value>    </property>    <property name="””">     <ref local></ref>    </property>   </bean></beans></li><li>如何在spring中实现国际化?<br>在applicationContext.xml加载一个bean<bean id="”messageSource”" class="”org.springframework.context.support.ResourceBundleMessageSource”">  <property name="”basename”">   <value>message</value>  </property></bean> 在src目录下建多个properties文件  对于非英文的要用native2ascii -encoding gb2312 源  目转化文件相关内容  其命名格式是message_语言_国家。  页面中的中显示提示信息，键名取键值。  当给定国家，系统会自动加载对应的国家的properties信息。  通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。</li><li>在spring中如何实现事件处理<br>事件<br>  Extends ApplicationEvent<br>监听器<br>  Implements ApplicationListener<br>事件源<br>  Implements ApplicationContextAware<br>在applicationContext.xml中配置事件源、监听器<br>先得到事件源，调用事件源的方法，通知监听器。</li><li>如何将spring加入web容器中<br>在web.xml中加入如下同容,在启动web服务器时加载/WEB-INF/applicationContext.xml中的内容。<servlet><servlet-name>context</servlet-name><servlet-class>org.springframework.web.context.ContextLoaderServlet</servlet-class><load-on-startup>1</load-on-startup></servlet>通过如下类得到ApplicationContext实例    WebApplicationContextUtils.getWebApplicationContext</li><li>Spring如何实现资源管理?<br>使用<br>applicationContext.getResource(“classpath:文件名”):在src根目录下，在类路径下<br>applicationContext.getResource(“classpath:/chap01/文件名”): 以src根目录下的基准往下走。<br>applicationContext.getResource(“file:c:/a.properties”)：在系统文件目录下。</li><li>Spring的ApplicationContext的作用?<br>beanFactory<br>国际化(getMesage)<br>资源管理:可以直接读取一个文件的内容(getResource)<br>加入web框架中(加入一个servlet或监听器)<br>事件处理</li><li>spring的核心是什么，各有什么作用？<br>BeanFactory：产生一个新的实例，可以实现单例模式<br>BeanWrapper：提供统一的get及set方法<br>ApplicationContext:提供框架的实现，包括BeanFactory的所有功能</li><li>Spring中aop的关键名词有哪些？各有什么作用?<br>拦截器: 代理<br>装备(advice)<br>目标对象<br>关切点:条件<br>连接点:方法、属性</li><li>Spring与struts的区别？<br>strusts：是一种基于MVC模式的一个web层的处理。<br>Spring:提供了通用的服务，ioc/di aop,关心的不仅仅web层，应当j2ee整体的一个服务，可以很容易融合不同的技术struts hibernate ibatis ejb remote springJDBC springMVC</li><li>spring与struts的面试题</li></ul><p>1.struts<br>Action是不是线程安全的？如果不是，有什么方式可以保证Action的线程安全？如果是，说明原因<br>2.MVC，分析一下struts是如何实现MVC的<br>3.struts中的几个关键对象的作用(说说几个关键对象的作用)<br>4.spring<br>说说AOP和IOC的概念以及在spring中是如何应用的<br>5.Hibernate有哪几种查询数据的方式<br>6.load()和get()的区别<br>回答：<br>1.Struts1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1 Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。<br>Struts2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）<br>2.struts是用一组类,servlet 和jsp规范实现mvc的<br>3.ActionFrom ActionServlet Action struts-config.xml<br>4.spring的核心就是IOC,通过指定对象的创建办法,描述对象与服务之间的关系,而不生成对象<br>5.3种,hql 条件查询() 原生sql<br>6.load()方法认为该数据一定存在,可以放心的使用代理来延时加载 ,如果使用过程中发现了问题,就抛出异常;<br>get()方法一定要获取到真实的数据,否则返回null</p><ul><li>Spring, hibernate ,struts面试题<br>Hibernate工作原理及为什么要用？<br>原理：</li></ul><ol><li>读取并解析配置文件</li><li>读取并解析映射信息，创建SessionFactory</li><li>打开Sesssion</li><li>创建事务Transation</li><li>持久化操作</li><li>提交事务</li><li>关闭Session</li><li>关闭SesstionFactory<br>为什么要用：</li></ol><ul><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。<br>Hibernate是如何延迟加载?</li><li>Hibernate2延迟加载实现：a)实体对象  b)集合（Collection）</li><li>Hibernate3 提供了属性的延迟加载功能<br>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。<br>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)<br>类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、<br>说下Hibernate的缓存机制</li><li>内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存</li><li>二级缓存：<br>a)应用及缓存<br>b)分布式缓存<br>条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非              关键数据<br>c)  第三方缓存的实现<br>Hibernate的查询方式<br>Sql、Criteria,object comptosition<br>Hql：</li><li>属性查询</li><li>参数查询、命名参数查询</li><li>关联查询</li><li>分页查询</li><li>统计函数<br>如何优化Hibernate？</li><li>使用双向一对多关联，不使用单向一对多</li><li>灵活使用单向一对多关联</li><li>不用一对一，用多对一取代</li><li>配置对象缓存，不使用集合缓存</li><li>一对多集合使用Bag,多对多集合使用Set</li><li>继承类使用显式多态</li><li>表字段要少，表关联不要怕多，有二级缓存撑腰<br>Struts工作机制？为什么要使用Struts？<br>工作机制：<br>Struts的工作流程:<br>在web应用启动时就会加载初始化ActionServlet,ActionServlet从struts-config.xml文件中读取配置信息,把它们存放到各种配置对象当ActionServlet接收到一个客户请求时,将执行如下流程.<br>(1)检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息;<br>(2)如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中;<br>(3)根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法;<br>(4)如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActuibErrors对象, 就表示表单验证成功;<br>(5)ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的Action实例不存在,就先创建这个实例,然后调用Action的execute()方法;<br>(6)Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给ActionForward对象指向的JSP组件;<br>(7)ActionForward对象指向JSP组件生成动态网页,返回给客户;<br>为什么要用：<br>JSP、Servlet、JavaBean技术的出现给我们构建强大的企业应用系统提供了可能。但用这些技术构建的系统非常的繁乱，所以在此之上，我们需要一个规则、一个把这些技术组织起来的规则，这就是框架，Struts便应运而生。<br>基于Struts开发的应用由3类组件构成：控制器组件、模型组件、视图组件<br>Struts的validate框架是如何验证的？<br>在struts配置文件中配置具体的错误提示，再在FormBean中的validate()方法具体调用。<br>说下Struts的设计模式<br>MVC模式:  web应用程序启动时就会加载并初始化ActionServler。用户提交表单时，一个配置好的ActionForm对象被创建，并被填入表单相应的数据，ActionServler根据Struts-config.xml 文件配置好的设置决定是否需要表单验证，如果需要就调用ActionForm的Validate（）验证后选择将请求发送到哪个Action，如果 Action不存在，ActionServlet会先创建这个对象，然后调用Action的execute（）方法。Execute（）从 ActionForm对象中获取数据，完成业务逻辑，返回一个ActionForward对象，ActionServlet再把客户请求转发给 ActionForward对象指定的jsp组件，ActionForward对象指定的jsp生成动态的网页，返回给客户。<br>单例模式<br>Factory(工厂模式)：<br>定义一个基类===》实现基类方法（子类通过不同的方法）===》定义一个工厂类（生成子类实例）<br>===》开发人员调用基类方法<br>Proxy(代理模式)<br>spring工作机制及为什么要用?</li></ul><p>1.spring mvc请所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责负责对请求进行真正的处理工作。<br>2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.<br>3.DispatcherServlet请请求提交到目标Controller<br>4.Controller进行业务逻辑处理后，会返回一个ModelAndView<br>5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象<br>6.视图对象负责渲染返回给客户端。<br>为什么用：<br>AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP 后，公共服务   （比 如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。<br>IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC 就像反      过来的 JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight construction），每一个对象都是用     其协作对象构造的。因此是由容器管理协作对象（collaborator）。<br>Spring即使一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 JavaBean 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。</p><ul><li><p>一些spring与hibernate的面试题<br>1、 简述你对IoC（Inversion of Control）的理解，描述一下Spring中实现DI（Dependency Injection）的几种方式。<br>2、 Spring的Bean有多种作用域，包括：<br>singleton、prototype、request、session、global session、application、自定义<br>3、 简单描述Spring framework与Struts的不同之处，整合Spring与Struts有哪些方法，哪种最好，为什么？<br>4、 Hibernate中的update()和saveOrUpdate()的区别<br>5、 Spring对多种ORM框架提供了很好的支持，简单描述在Spring中使用Hibernate的方法，并结合事务管理。<br>答案：<br>1、好莱坞原则€€€€不要打电话找我，我会打给你的。IoC将创建的职责从应用程序代码搬到了框架中。Spring对Setter注入和构造方法注入提供支持。（详见<a target="_blank" rel="noopener" href="http://martinfowler.com/articles/injection.html%EF%BC%8C%E4%BB%A5%E5%8F%8Ahttp">http://martinfowler.com/articles/injection.html，以及http</a>: //<a target="_blank" rel="noopener" href="http://www.redsaga.com/spring_ref/2.0/html/beans.html#beans-factory-">www.redsaga.com/spring_ref/2.0/html/beans.html#beans-factory-</a> collaborators）<br>2、 除application（详见Spring framework 2.0 Reference的3.4节bean的作用域）<br>3、 Spring是完整的一站式框架，而Struts仅是MVC框架，且着重于MVC中的C。Spring有三种方式整合Struts：使用 Spring 的 ActionSupport 类整合 Struts；使用 Spring 的 DelegatingRequestProcessor 覆盖 Struts 的 RequestProcessor；将 Struts Action 管理委托给 Spring 框架，动作委托最好。（详见使用Spring 更好地处理Struts 动作）<br>Spring 2.0新增一种方式：AutowiringRequestProcessor。（详见<a target="_blank" rel="noopener" href="http://www.javaeye.com/topic/24239%EF%BC%89">http://www.javaeye.com/topic/24239）</a><br>4、 saveOrUpdate()方法可以实现update()的功能，但会多些步骤，具体如下：<br>如果对象在该session中已经被持久化，不进行操作；<br>对象的标识符属性(identifier property)在数据库中不存在或者是个暂时的值，调用save()方法保存它；<br>如果session中的另一个对象有相同的标识符抛出一个异常；<br>以上皆不符合则调用update()更新之。<br>5、 在context中定义DataSource，创建SessionFactoy，设置参数；DAO类继承HibernateDaoSupport，实现具体接口，从中获得HibernateTemplate进行具体操作。<br>在使用中如果遇到OpenSessionInView的问题，可以添加OpenSessionInViewFilter或OpenSessionInViewInterceptor。（详见Spring framework 2.0 Reference的12.2节Hibernate）<br>声明式事务需声明事务管理器，在context中设置指定属性，用确定和。</p></li><li><p>在spring中如何更加高效的使用JDBC<br>使用Spring框架提供的模板类JdbcTemplete可以是JDBC更加高效<br>代码如下：JdbcTemplate template = new JdbcTemplate(myDataSource);<br>DAO类的例子：<br>public class StudentDaoJdbc implements StudentDao {<br>private JdbcTemplate jdbcTemplate;<br>public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {<br>this.jdbcTemplate = jdbcTemplate;<br>}<br>more..<br>}<br>配置文件：</p><pre><code>&lt;bean id=”jdbcTemplate” class=”org.springframework.jdbc.core.JdbcTemplate”&gt;
&lt;property name=”dataSource”&gt;
&lt;ref bean=”dataSource”/&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=”studentDao” class=”StudentDaoJdbc”&gt;
&lt;property name=”jdbcTemplate”&gt;
&lt;ref bean=”jdbcTemplate”/&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=”courseDao” class=”CourseDaoJdbc”&gt;
&lt;property name=”jdbcTemplate”&gt;
&lt;ref bean=”jdbcTemplate”/&gt;
&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li><li><p>在spring如何创建一个数据连接池<br>```</p><bean id="”dataSource”" class="”org.apache.commons.dbcp.BasicDataSource”"><property name="”driver”"><value>${db.driver}</value></property><property name="”url”"><value>${db.url}</value></property><property name="”username”"><value>${db.username}</value></property><property name="”password”"><value>${db.password}</value></property></bean></li><li><p>在spring中如何配置一个bean来从JNDI到dataSource</p><bean id="”dataSource”" class="”org.springframework.jndi.JndiObjectFactoryBean”"><property name="”jndiName”"><value>java:comp/env/jdbc/myDatasource</value></property></bean>```</li><li><p>请介绍下spring中bean的作用域<br>在spring2.0之前bean只有2种作用域即：singleton(单例)、non-singleton（也称 prototype），Spring2.0以后，增加了session、request、global session三种专用于Web应用程序上下文的Bean。因此，默认情况下Spring2.0现在有五种类型的Bean。</p><bean id="”role”" class="”spring.chapter2.maryGame.Role”" scope="”singleton”/">这里的scope就是用来配置spring bean的作用域，它标识bean的作用域。 在spring2.0之前bean只有2种作用域即：singleton(单例)、non-singleton（也称 prototype），Spring2.0以后，增加了session、request、global session三种专用于Web应用程序上下文的Bean。因此，默认情况下Spring2.0现在有五种类型的Bean。当然，Spring2.0对 Bean的类型的设计进行了重构，并设计出灵活的Bean类型支持，理论上可以有无数多种类型的Bean，用户可以根据自己的需要，增加新的Bean类型，满足实际应用需求。 1、singleton作用域 当一个bean的作用域设置为singleton，那么Spring IOC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。换言之，当把一个bean定义设置为singleton作用域时，Spring IOC容器只会创建该bean定义的唯一实例。这个单一实例会被存储到单例缓存（singleton cache）中，并且所有针对该bean的后续请求和引用都将返回被缓存的对象实例，这里要注意的是singleton作用域和GOF设计模式中的单例是完全不同的，单例设计模式表示一个ClassLoader中只有一个class存在，而这里的singleton则表示一个容器对应一个bean，也就是说当一个bean被标识为singleton时候，spring的IOC容器中只会存在一个该bean。 配置实例： ```<bean id="”role”" class="”spring.chapter2.maryGame.Role”" scope="”singleton”/">或者<bean id="”role”" class="”spring.chapter2.maryGame.Role”" singleton="”true”/">``` 2、prototype prototype作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）都会产生一个新的bean实例，相当于一个new的操作，对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个 prototype bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。（让Spring容器释放被singleton作用域bean占用资源的一种可行方式是，通过使用 bean的后置处理器，该处理器持有要被清除的bean的引用。） 配置实例：</bean></bean></bean></li></ul><pre><code>&lt;bean id=”role” class=”spring.chapter2.maryGame.Role” scope=”prototype”/&gt;
或者
&lt;beanid=”role” class=”spring.chapter2.maryGame.Role” singleton=”false”/&gt;
</code></pre><p>3、request<br>request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，配置实例：<br>request、session、global session使用的时候，首先要在初始化web的web.xml中做如下配置：<br>如果你使用的是Servlet 2.4及以上的web容器，那么你仅需要在web应用的XML声明文件web.xml中增加下述ContextListener即可：<br><web-app><br>…<br><listener><br><listener-class>org.springframework.web.context.request.RequestContextListener</listener-class><br></listener><br>…<br></web-app><br>如果是Servlet2.4以前的web容器,那么你要使用一个javax.servlet.Filter的实现：<br><web-app><br>..<br><filter><br><filter-name>requestContextFilter</filter-name><br><filter-class>org.springframework.web.filter.RequestContextFilter</filter-class><br></filter><br><filter-mapping><br><filter-name>requestContextFilter</filter-name><br><url-pattern>/*</url-pattern><br></filter-mapping><br>…<br></web-app><br>接着既可以配置bean的作用域了：<br><bean id="”role”" class="”spring.chapter2.maryGame.Role”" scope="”request”/"><br>4、session<br>session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效，配置实例：<br>配置实例：<br>和request配置实例的前提一样，配置好web启动文件就可以如下配置：<br><bean id="”role”" class="”spring.chapter2.maryGame.Role”" scope="”session”/"><br>5、global session<br>global session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个 portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。如果你在web中使用global session作用域来标识bean，那么，web会自动当成session类型来使用。<br>配置实例：<br>和request配置实例的前提一样，配置好web启动文件就可以如下配置：<br>&lt;bean id=”role” class=”spring.chapter2.maryGame.Role” scope=”global session”/&gt;<br>6、自定义bean装配作用域<br>在spring 2.0中作用域是可以任意扩展的，你可以自定义作用域，甚至你也可以重新定义已有的作用域（但是你不能覆盖singleton和 prototype），spring的作用域由接口org.springframework.beans.factory.config.Scope来定义，自定义自己的作用域只要实现该接口即可，下面给个实例：<br>我们建立一个线程的scope，该scope在表示一个线程中有效，代码如下：<br>publicclass MyScope implements Scope …{<br>privatefinal ThreadLocal threadScope = new ThreadLocal() …{<br>protected Object initialValue() …{<br>returnnew HashMap();<br>}<br>};<br>public Object get(String name, ObjectFactory objectFactory) …{<br>Map scope = (Map) threadScope.get();<br>Object object = scope.get(name);<br>if(object==null) …{<br>object = objectFactory.getObject();<br>scope.put(name, object);<br>}<br>return object;<br>}<br>public Object remove(String name) …{<br>Map scope = (Map) threadScope.get();<br>return scope.remove(name);<br>}<br>publicvoid registerDestructionCallback(String name, Runnable callback) …{<br>}<br>public String getConversationId() …{<br>// TODO Auto-generated method stub<br>returnnull;<br>}<br>}</bean></bean></p><ul><li>请介绍 一下spring的bean的生命周期<br>一、Bean的定义<br>Spring通常通过配置文件定义Bean。如：<?xml version=”1.0″ encoding=”UTF-8″?> &lt;beans xmlns=”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/beans%E2%80%9D">http://www.springframework.org/schema/beans”</a><br>xmlns:xsi=”<a target="_blank" rel="noopener" href="http://www.w3.org/2001/XMLSchema-instance%E2%80%9D">http://www.w3.org/2001/XMLSchema-instance”</a><br>xsi:schemaLocation=”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> <a target="_blank" rel="noopener" href="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd%E2%80%9D&gt;">http://www.springframework.org/schema/beans/spring-beans-2.0.xsd”&gt;</a><bean id="”HelloWorld”" class="”com.pqf.beans.HelloWorld”"><property name="”msg”"><value>HelloWorld</value></property></bean>这个配置文件就定义了一个标识为 HelloWorld 的Bean。在一个配置文档中可以定义多个Bean。 二、Bean的初始化 有两种方式初始化Bean。 1、在配置文档中通过指定init-method 属性来完成 在Bean的类中实现一个初始化Bean属性的方法，如init()，如： public class HelloWorld{ public String msg=null; public Date date=null; public void init() { msg=”HelloWorld”; date=new Date(); } …… } 然后，在配置文件中设置init-mothod属性：<bean id="”HelloWorld”" class="”com.pqf.beans.HelloWorld”" init-mothod="”init”"></bean>2、实现 org.springframwork.beans.factory.InitializingBean接口 Bean实现InitializingBean接口，并且增加 afterPropertiesSet() 方法： public class HelloWorld implement InitializingBean { public String msg=null; public Date date=null; public void afterPropertiesSet() { msg=”向全世界问好！”; date=new Date(); } …… } 那么，当这个Bean的所有属性被Spring的BeanFactory设置完后，会自动调用afterPropertiesSet()方法对Bean进行初始化，于是，配置文件就不用指定 init-method属性了。 三、Bean的调用 有三种方式可以得到Bean并进行调用： 1、使用BeanWrapper HelloWorld hw=new HelloWorld(); BeanWrapper bw=new BeanWrapperImpl(hw); bw.setPropertyvalue(”msg”,”HelloWorld”); system.out.println(bw.getPropertyCalue(”msg”)); 2、使用BeanFactory InputStream is=new FileInputStream(”config.xml”); XmlBeanFactory factory=new XmlBeanFactory(is); HelloWorld hw=(HelloWorld) factory.getBean(”HelloWorld”); system.out.println(hw.getMsg()); 3、使用ApplicationConttext ApplicationContext actx=new FleSystemXmlApplicationContext(”config.xml”); HelloWorld hw=(HelloWorld) actx.getBean(”HelloWorld”); System.out.println(hw.getMsg()); 四、Bean的销毁 1、使用配置文件中的 destory-method 属性 与初始化属性 init-methods类似，在Bean的类中实现一个撤销Bean的方法，然后在配置文件中通过 destory-method指定，那么当bean销毁时，Spring将自动调用指定的销毁方法。 2、实现 org.springframwork.bean.factory.DisposebleBean接口 如果实现了DisposebleBean接口，那么Spring将自动调用bean中的Destory方法进行销毁，所以，Bean中必须提供Destory方法。</li><li>Spring中如何获取bean<br>通过xml配置文件<br>bean配置在xml里面，spring提供多种方式读取配置文件得到ApplicationContext.<br>第一种方式：FileSystemXmlApplicationContext<br>通过程序在初始化的时候，导入Bean配置文件，然后得到Bean实例:<br>ApplicationContext ac = new FileSystemXmlApplicationContext(”applicationContext.xml”)<br>ac.getBean(”beanName”);<br>第二种方式：WebApplicationContextUtil<br>在B/S系统中,通常在web.xml初始化bean的配置文件，然后由WebAppliCationContextUtil得到ApplicationContext.例如：<br>ApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);<br>ApplicationContext ctx =   WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);<br>其中 servletContext sc 可以具体 换成 servlet.getServletContext()或者 this.getServletContext() 或者 request.getSession().getServletContext();<br>另外，由于spring是注入的对象放在ServletContext中的，所以可以直接在ServletContext取出WebApplicationContext 对象：<br>WebApplicationContext webApplicationContext = (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</li><li>Spring框架有哪几部分组成?<br>Spring框架有七个模块组成组成，这7个模块(或组件)均可以单独存在，也可以与其它一个或多个模块联合使用，主要功能表现如下：<br>☞ Spring 核心容器（Core）：提供Spring框架的基本功能。核心容器的主要组件是BeanFactory，她是工厂模式的实现。BeanFactory使用控制反转（Ioc）模式将应用程序的配置和依赖性规范与实际的应用代码程序分开。<br>☞ Spring AOP：通过配置管理特性，Spring AOP模块直接面向方面的编程功能集成到了Spring框架中，所以可以很容易的使Spring框架管理的任何对象支持 AOP。Spring AOP模块为基于Spring的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，不用依赖于EJB组件，就可以将声明性事务管理集成到应用程序中。<br>☞ Spring ORM：Spring框架集成了若干ORM框架,从而提供了ORM的对象关系工具,其中包括 JDO、Hibernate、iBatis和TopLink。所有这些都遵从Spring的通用事务和DAO异常层结构。<br>☞ Spring DAO：JDBC DAO抽象层提供了有意义的异常层次的结构，可用该结构来管理异常处理和不同数据供应商抛出的异常错误信息。异常层次结构简化了错误处理，并且大大的降低 了需要编写的异常代码数量（例如，打开和关系连接）。Spring DAO的面向JDBC的异常遵从通用的DAO异常层结构。<br>☞ Spring WEB：Web上下文模块建立在上下文模块（Context）的基础之上，为基于Web服务的应用程序提供了上下文的服务。所以Spring框架支持 Jakarta Struts的集成。Web模块还简化了处理多部分请求及将请求参数绑定到域对象的工作。<br>☞ Spring上下文（Context）：Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化校验和调度功能。<br>☞ Spring MVC：Spring的MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的，MVC容纳的大量视图技术，包括JSP、Velocity、Tiles、iText和Pol</li><li>使用spring有什么好处?<br>◆Spring能有效地组织你的中间层对象,无论你是否选择使用了EJB。如果你仅仅使用了Struts或其他的包含了J2EE特有APIs的framework，你会发现Spring关注了遗留下的问题，。<br>◆Spring能消除在许多工程上对Singleton的过多使用。根据我的经验，这是一个主要的问题，它减少了系统的可测试性和面向对象特性。<br>◆Spring能消除使用各种各样格式的属性定制文件的需要,在整个应用和工程中，可通过一种 一致的方法来进行配置。曾经感到迷惑，一个特定类要查找迷幻般的属性关键字或系统属性,为此不得不读Javadoc乃至源编码吗？有了Spring，你可 很简单地看到类的JavaBean属性。倒置控制的使用(在下面讨论)帮助完成这种简化。<br>◆Spring能通过接口而不是类促进好的编程习惯，减少编程代价到几乎为零。<br>◆Spring被设计为让使用它创建的应用尽可能少的依赖于他的APIs。在Spring应用中的大多数业务对象没有依赖于Spring。<br>◆使用Spring构建的应用程序易于单元测试。<br>◆Spring能使EJB的使用成为一个实现选择,而不是应用架构的必然选择。你能选择用POJOs或local EJBs来实现业务接口，却不会影响调用代码。<br>◆Spring帮助你解决许多问题而无需使用EJB。Spring能提供一种EJB的替换物，它们适于许多web应用。例如,Spring能使用AOP提供声明性事务而不通过使用EJB容器，如果你仅仅需要与单个的数据库打交道，甚至不需要JTA实现。<br>■Spring为数据存取提供了一致的框架,不论是使用JDBC或O/R mapping产品（如Hibernate）。<br>Spring确实使你能通过最简单可行的解决办法解决你的问题。这些特性是有很大价值的。<br>总结起来，Spring有如下优点：<br>◆低侵入式设计，代码污染极低<br>◆ 独立于各种应用服务器，可以真正实现Write Once,Run Anywhere的承诺<br>◆Spring的DI机制降低了业务对象替换的复杂性<br>◆Spring并不完全依赖于Spring，开发者可自由选用Spring框架的部分或全部</li><li>什么是spring，它有什么特点?<br>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。<br>◆轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并 且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。<br>◆控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不 是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。<br>◆面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的 业务逻辑与系统级服务（例如审计（auditing）和事务（）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们 并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。<br>◆容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是 一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生 成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。<br>◆框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li></ul><p>1.简单介绍下java？Spring的AOP，IOC的讲述 对struts2的了解，1，2的比较 xml的了解 J2ee的webserviced的协议？<br>Spring AOP:代理机制 Spring提供的自动代理机制<br>Spring的IoC来实组件之间的依赖关系注入, 使控制层与业务实现分离，即客户通过<br>调用业务委托接口来调用具体的业务组件的实例，避免控制层与业务层的藕合带来的维护<br>或升级困难。由Spring为DAO生成代理对象来为DAO添加事务服务，由IoC容器DAO的代理实例注入到业务组件中,业务组件通过DAO的委托接口调用DAO对象，使得上层组件不直接依赖于DAO的实现类，使得持久层更换或修改不影响上层组件。<br>2.Spring工作原理<br>内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射,反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过配置类达到的<br>Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明 管理的（Spring根据这些配置 内部通过反射去动态的组装对象）要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能</p><p>3.解释一下IOC,以及spring的举例<br>IOC称为控制反转，也叫依赖注入，ioc是Spring的核心组件，它通过配置文件，将需要创建的对象以池的方式管理，将实例注入到需要的对象中区，是对象依赖于注入而不依赖于实现，解决了各个组件的耦合度，使得项目在后期的维护和扩展上非常方便。 如在ssh框架整合中，我们将datasource对象注入给sessionFactory，再将sessionFactory注入给dao组件，再将dao组件注入给struts的Action组件，在将action对象注入给struts的拦截器。<br>4.整合spring 与struts的方法，那种最好，为什么？<br>答：1.第一种方法:<br>Struts的Action继承Spring的ActionSupport类，并在Action中获取Spring的ApplicationContext。这是最简单的一种整合方式，但有三个缺点：第一，Struts与Spring紧密耦合，不能改换到其他IoC容器；第二，难以使用Spring AOP特性；第三，对于需要使用DispatchAction的Struts应用无能为力。<br>2.第二种方法:<br>在Struts的配置文件中，以Spring的DelegatingRequestProcessor类代替Struts的RequestProcessor类，并在Spring的配置文件中定义与Struts配置文件中<action-mappings>对应的bean，从而将Struts的Action与Spring分开，并把Struts的动作置于Spring的控制之下。这种整合方式的优点是将不再依赖Spring这个特定的IoC容器，但必须依赖Struts的RequestProcessor类。<br>3.第三种方法:<br>通过Spring的DelegatingActionProxy类代理Struts的动作，即在Struts配置文件中，定义<action-mappings>的type属性全部改为DelegatingActionProxy，而不是具体的类名，并在Spring配置文件中定义与Struts动作映射对应的bean，从而将Struts的Action与Spring分开，并把Struts的动作置于Spring的控制之下。无疑，这是最灵活的一种整合方式。 </action-mappings></action-mappings></p><p>5.springframework与struts的不同之处<br>答：1. SpringFramework是一个采用了反转控制（InversionofControl,Ioc）策略的基于J2EE 的轻量级应用框架。核心是IoC容器，对于其它应用，如数据库访问，日志等，SpringFramework多使用现有的、成熟的框架。它采用了模块化的方式，各模块可以共同使用，也可以单独使用其中的一个模块。<br>2．struts2利用成熟的struts1和webwork整合使之操作更加方便;</p><p>6.spring使用了哪些设计模式，这样用有什么好处？<br>Dao模式 通过实现DAO,我们达到了解耦合的目的,使的程序更加的健壮,但复杂性增加了；</p><p>7.spring对多种ORM 框架提供了很好的支持，结合事务管理描述spring中使用Hibernate的方法。<br>答：spring中采用aop模式注入hibernate的sessionfactory和事务管理,在dao中调用.Spring集成hibernate有两种方式,一是dao层只与hibernate有关, 不使用任何spring 的api, 然后把dao注入到ioc容器.二是使用spring的hibernateDaoSupport.事务管理也可以只使用hibernate的事务管理.</p><p>8.问spring的AOP，mvc到底是怎么优化程序的结构？<br>SpringAOP主要提供了Pointcut、Aspects等以及它们如何被织入应用程序、代理的方式等等进行优化的控制。而Spring MVC里面前端控制器叫做DispatcherServlet。里面充当Action的组件叫做Controller，返回的视图层对象叫做ModelAndView，提交和返回都可能要经过过滤。从而提高程序可读性和稳定性。</p><p>以下为spring常见面试问题：<br> <br>1、什么是Spring框架？Spring框架有哪些主要模块？<br>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。<br> <br>Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。<br>Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。<br>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p><p> <br>2、使用Spring框架能带来哪些好处？<br> <br>下面列举了一些使用Spring框架带来的主要好处：<br>Dependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。<br>与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。<br>Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。<br>Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。<br>要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。<br>Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。<br>Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。<br>3、什么是控制反转(IOC)？什么是依赖注入？<br>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。<br>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。<br>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？<br>在Java中依然注入有以下三种实现方式：<br>1.构造器注入<br>2.Setter方法注入<br>3.接口注入<br>4、请解释下Spring框架中的IoC？<br>Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。<br>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。<br>org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。<br>IOC:把对象的创建、初始化、销毁交给spring来管理，而不是由开发者控制，实现控制反转。</p><p> <br>5、BeanFactory和ApplicationContext有什么区别？<br> <br>BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。<br>BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含 了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。<br>从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但applicationcontext在此基础上还提供了其他的功能。<br>1.提供了支持国际化的文本消息<br>2.统一的资源文件读取方式<br>3.已在监听器中注册的bean的事件<br>以下是三种较常见的 ApplicationContext 实现方式：<br>1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中<br>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);<br> <br>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。<br> <br>ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);<br> <br> <br>3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。<br> <br>4.AnnotationConfigApplicationContext(基于Java配置启动容器)  </p><p> </p><p> <br>6、Spring有几种配置方式？<br> <br>将Spring配置到应用开发中有以下三种方式：<br>1.基于XML的配置<br>2.基于注解的配置<br>3.基于Java的配置<br>7、如何用基于XML配置的方式配置Spring？<br>在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。<br>SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）<br>Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。<br>如：  </beans></p><beans><bean name="viewResolver" class="org.springframework.web.servlet.view.BeanNameViewResolver"><bean name="jsonTemplate" class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"><bean id="restTemplate" class="org.springframework.web.client.RestTemplate"></beans><p> <br>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。</p><web-app><display-name>Archetype Created Web Application</display-name><servlet><servlet-name>spring</servlet-name><servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class><load-on-startup>1</load-on-startup></servlet><servlet-mapping><servlet-name>spring</servlet-name><url-pattern>/</url-pattern></servlet-mapping></web-app><p> <br> <br> <br>8、如何用基于Java配置的方式配置Spring？<br> <br>Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个 新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与<bean> 元素类似。被 @Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的 内部调用@bean方法来设置嵌入bean的依赖关系。<br>最简单的@Configuration 声明类请参考下面的代码：</p><p>@Configuration<br>public class AppConfig{<br>@Bean<br>public MyService myService() {<br>return new MyServiceImpl();<br>}<br>}</p><p> <br>对于上面的@Beans配置文件相同的XML配置文件如下：<br><beans><br><bean id="myService" class="com.somnus.services.MyServiceImpl"><br></beans><br> <br>上述配置方式的实例化方式如下：利用AnnotationConfigApplicationContext 类进行实例化<br> <br>public static void main(String[] args) {<br>ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);<br>MyService myService = ctx.getBean(MyService.class);<br>myService.doStuff();<br>}<br> <br>要使用组件组建扫描，仅需用@Configuration进行注解即可：<br>@Configuration<br>@ComponentScan(basePackages = “com.somnus”)<br>public class AppConfig {<br>…<br>}<br> <br> <br>在上面的例子中，com.acme包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照Sring bean定义进行注册。<br>如果你要在你的web应用开发中选用上述的配置的方式的话，需要用AnnotationConfigWebApplicationContext 类来读 取配置文件，可以用来配置Spring的Servlet监听器ContextLoaderListener或者Spring MVC的DispatcherServlet。</p><web-app><context-param><param-name>contextClass</param-name><param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value></context-param><pre><code>&lt;!-- Configuration locations must consist of one or more comma- or space-delimited    
    fully-qualified @Configuration classes. Fully-qualified packages may also be    
    specified for component-scanning --&gt;    
&lt;context-param&gt;    
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    
    &lt;param-value&gt;com.howtodoinjava.AppConfig&lt;/param-value&gt;    
&lt;/context-param&gt;    
 
&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;    
&lt;listener&gt;    
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    
&lt;/listener&gt;    
 
&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;    
&lt;servlet&gt;    
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    
    &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext    
        instead of the default XmlWebApplicationContext --&gt;    
    &lt;init-param&gt;    
        &lt;param-name&gt;contextClass&lt;/param-name&gt;    
        &lt;param-value&gt;    
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext    
        &lt;/param-value&gt;    
    &lt;/init-param&gt;    
    &lt;!-- Again, config locations must consist of one or more comma- or space-delimited    
        and fully-qualified @Configuration classes --&gt;    
    &lt;init-param&gt;    
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    
        &lt;param-value&gt;com.howtodoinjava.web.MvcConfig&lt;/param-value&gt;    
    &lt;/init-param&gt;    
&lt;/servlet&gt;    
 
&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;    
&lt;servlet-mapping&gt;    
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    
    &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;    
&lt;/servlet-mapping&gt;    
</code></pre><p>&lt;/web-app</p><p> <br> <br> <br> <br>9、怎样用注解的方式配置Spring？<br>Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的 内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结 果。<br>注解装配在Spring中是默认关闭的。所以需要在Spring文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。<br><beans><br><a href="context:annotation-config/">context:annotation-config/</a><br><br></beans><br> <br> <br>在 <a href="context:annotation-config/">context:annotation-config/</a>标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。<br>下面是几种比较重要的注解类型：<br>1.@Required：该注解应用于设值方法。<br>2.@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。<br>3.@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。<br>4.JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy。<br>10、请解释Spring Bean的生命周期？<br>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。<br>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。<br>1.初始化之后调用的回调方法。<br>2.销毁之前调用的回调方法。<br>Spring框架提供了以下四种方式来管理bean的生命周期事件：<br>InitializingBean和DisposableBean回调接口<br>针对特殊行为的其他Aware接口<br>Bean配置文件中的Custom init()方法和destroy()方法<br>@PostConstruct和@PreDestroy注解方式<br>使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下：<br><beans><br><bean id="demoBean" class="com.somnus.task.DemoBean" init-method="customInit" destroy-method="customDestroy"></bean><br></beans><br> <br> <br> <br>11、Spring Bean的作用域之间有什么区别？<br>Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：<br>1.singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。<br>2.prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。<br>3.request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。<br>4.Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。<br>5.global- session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果 你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。<br>全局作用域与Servlet中的session作用域效果相同。<br> <br>12、什么是Spring inner beans？<br> <br>在Spring框架中，无论何时bean被使用时，当仅被调用了一个属性。一个明智的做法是将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。<br>比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们的要做的是创建一个Person的实例，然后在Customer内部使用。<br>public class Customer{<br>private Person person;<br>//Setters and Getters<br>}   </p><p>public class Person{<br>private String name;<br>private String address;<br>private int age;<br>//Setters and Getters<br>}</p><p> <br> <br> <br> <br>内部bean的声明方式如下：</p><bean id="CustomerBean" class="com.somnus.common.Customer"><property name="person"><bean class="com.howtodoinjava.common.Person"><property name="name" value="lokesh"><property name="address" value="India"><property name="age" value="34"></bean></property></bean><p> <br> <br> <br> <br>13、Spring框架中的单例Beans是线程安全的么？<br>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。<br>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p><p> <br>14、请举例说明如何在Spring中注入一个Java Collection？<br> <br>Spring提供了以下四种集合类的配置元素：<br><list> :   该标签用来装配可重复的list值。<br><set> :    该标签用来装配没有重复的set值。<br><map>:   该标签可用来注入键和值可以为任何类型的键值对。<br><props> : 该标签支持注入键和值都是字符串类型的键值对。<br>下面看一下具体的例子：</props></map></set></list></p><beans><bean id="javaCollection" class="com.howtodoinjava.JavaCollection"><property name="customList"><list><value>INDIA</value><value>Pakistan</value><value>USA</value><value>UK</value></list></property><pre><code> &lt;!-- java.util.Set --&gt;    
 &lt;property name=&quot;customSet&quot;&gt;    
    &lt;set&gt;    
       &lt;value&gt;INDIA&lt;/value&gt;    
       &lt;value&gt;Pakistan&lt;/value&gt;    
       &lt;value&gt;USA&lt;/value&gt;    
       &lt;value&gt;UK&lt;/value&gt;    
    &lt;/set&gt;    
  &lt;/property&gt;    
 
 &lt;!-- java.util.Map --&gt;    
 &lt;property name=&quot;customMap&quot;&gt;    
    &lt;map&gt;    
       &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt;    
       &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt;    
       &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt;    
       &lt;entry key=&quot;4&quot; value=&quot;UK&quot;/&gt;    
    &lt;/map&gt;    
  &lt;/property&gt;    
 
&lt;!-- java.util.Properties --&gt;    
&lt;property name=&quot;customProperies&quot;&gt;    
    &lt;props&gt;    
        &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt;    
        &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt;    
    &lt;/props&gt;    
&lt;/property&gt;    
 
</code></pre></bean></beans><p> <br> <br> <br> <br>15、如何向Spring Bean中注入一个Java.util.Properties？<br>第一种方法是使用如下面代码所示的<props> 标签：</props></p><bean id="adminUser" class="com.somnus.common.Customer"><pre><code>&lt;!-- java.util.Properties --&gt;    
&lt;property name=&quot;emails&quot;&gt;    
    &lt;props&gt;    
        &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt;    
        &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt;    
    &lt;/props&gt;    
&lt;/property&gt;    
 
</code></pre></bean><p> <br> <br>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。<br> <br>16、请解释Spring Bean的自动装配？<br> <br>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring容器还可以自动装配合作关系bean之间的关联关系。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。<br>下面的XML配置文件表明了如何根据名称将一个bean设置为自动装配：<br> <br><bean id="employeeDAO" class="com.howtodoinjava.EmployeeDAOImpl" autowire="byName"><br> <br> <br> <br>除了bean配置文件中提供的自动装配模式，还可以使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在按照如下的配置方式在Spring配置文件进行配置才可以使用。<br>&lt;context:annotation-config /&gt;<br> <br> <br> <br>也可以通过在配置文件中配置AutowiredAnnotationBeanPostProcessor 达到相同的效果。<br> <br><bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"><br> <br> <br> <br>配置好以后就可以使用@Autowired来标注了。<br>@Autowired<br>public EmployeeDAOImpl ( EmployeeManager manager ) {<br>this.manager = manager;<br>}      </p><p> <br>17、请解释自动装配模式的区别？<br> <br>在Spring框架中共有5种自动装配，让我们逐一分析。<br>1.no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。<br>2.byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。<br>3.byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。<br>4.constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。<br>5.autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。<br>18、如何开启基于注解的自动装配？<br>要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：<br>1、引入配置文件中的<bean>下引入 <a href="context:annotation-config">context:annotation-config</a><br><beans><br>&lt;context:annotation-config /&gt;<br></beans><br> <br> <br> <br>2、在bean配置文件中直接引入AutowiredAnnotationBeanPostProcessor<br><beans><br><bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"><br></beans>        </bean></p><p>19、请举例解释@Required注解？<br>在产品级别的应用中，IoC容器可能声明了数十万了bean，bean与bean之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在<bean>中设置“dependency-check”来解决这个问题。<br>在应用程序的生命周期中，你可能不大愿意花时间在验证所有bean的属性是否按照上下文文件正确配置。或者你宁可验证某个bean的特定属性是否被正确的设置。即使是用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。<br>需要用如下的方式使用来标明bean的设值方法。  </bean></p><p>public class EmployeeFactoryBean extends AbstractFactoryBean<object>{<br>private String designation;<br>public String getDesignation() {<br>return designation;<br>}<br>@Required<br>public void setDesignation(String designation) {<br>this.designation = designation;<br>}<br>//more code here<br>}</object></p><p> <br> <br> <br>RequiredAnnotationBeanPostProcessor是Spring中的后置处理用来验证被@Required 注解的bean属性是否被正确的设置了。在使用RequiredAnnotationBeanPostProcesso来验证bean属性之前，首先要在IoC容器中对其进行注册：<br> <br> <br><bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"><br> <br> <br> <br>但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个BeanInitializationException 异常。<br> <br>20、请举例解释@Autowired注解？<br> <br>@Autowired注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired注解可以像@Required注解、构造器一样被用于在bean的设值方法上自动装配bean的属性，一个参数或者带有任意名称或带有多个参数的方法。<br>比如，可以在设值方法上使用@Autowired注解来替代配置文件中的 <property>元素。当Spring容器在setter方法上找到@Autowired注解时，会尝试用byType 自动装配。<br>当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个bean时将会被自动装配，即便在配置文件中使用<constructor-arg> 元素。</constructor-arg></property></p><p>public class TextEditor {<br>private SpellChecker spellChecker;<br>@Autowired<br>public TextEditor(SpellChecker spellChecker){<br>System.out.println(“Inside TextEditor constructor.” );<br>this.spellChecker = spellChecker;<br>}<br>public void spellCheck(){<br>spellChecker.checkSpelling();<br>}<br>}</p><p> <br> <br>下面是没有构造参数的配置方式：  </p><beans><p><a href="context:annotation-config/">context:annotation-config/</a></p><bean id="textEditor" class="com.howtodoinjava.TextEditor"><bean id="spellChecker" class="com.howtodoinjava.SpellChecker"></beans><p>     </p><p> <br>21、请举例说明@Qualifier注解？<br> <br>@Qualifier注解意味着可以在被标注bean的字段上可以自动装配。Qualifier注解可以用来取消Spring不能取消的bean应用。<br>下面的示例将会在Customer的person属性中自动装配person的值。<br>public class Customer{<br>@Autowired<br>private Person person;<br>}<br> <br> <br> <br>下面我们要在配置文件中来配置Person类。  </p><bean id="customer" class="com.somnus.common.Customer"><bean id="personA" class="com.somnus.common.Person"><property name="name" value="lokesh"></bean><bean id="personB" class="com.somnus.common.Person"><property name="name" value="alex"></bean><p> <br> <br>  <br> <br>Spring会知道要自动装配哪个person bean么？不会的，但是运行上面的示例时，会抛出下面的异常：<br> <br>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException:<br>No unique bean of type [com.howtodoinjava.common.Person] is defined:<br>expected single matching bean but found 2: [personA, personB]<br> <br> <br> <br>要解决上面的问题，需要使用 @Quanlifier注解来告诉Spring容器要装配哪个bean：<br> <br>public class Customer{<br>@Autowired<br>@Qualifier(“personA”)<br>private Person person;<br>}      </p><p>22、构造方法注入和设值注入有什么区别？<br>请注意以下明显的区别：<br>1.在设值注入方法支持大部分的依赖注入，如果我们仅需 要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法 注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。<br>2.设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。<br>3.在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。<br>4.在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。<br>23、Spring框架中有哪些不同类型的事件？<br>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。<br>我们可以创建bean用来监听在ApplicationContext 中发布的事件。ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><p>public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt;{<br>@Override<br>public void onApplicationEvent(ApplicationEvent applicationEvent)<br>{<br>//process event<br>}<br>}</p><p>     </p><p>Spring 提供了以下5中标准的事件：<br>1.上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。<br>2.上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。<br>3.上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。<br>4.上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。<br>5.请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。<br>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。<br>public class CustomApplicationEvent extends ApplicationEvent{<br>public CustomApplicationEvent ( Object source, final String msg ){<br>super(source);<br>System.out.println(“Created a Custom event”);<br>}<br>}<br> <br> <br> <br>为了监听这个事件，还需要创建一个监听器：<br>public class CustomEventListener implements ApplicationListener &lt; CustomApplicationEvent &gt;{<br>@Override<br>public void onApplicationEvent(CustomApplicationEvent applicationEvent) {<br>//handle event<br>}<br>}      </p><p>之后通过applicationContext接口的publishEvent()方法来发布自定义事件。<br>CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext, “Test message”);<br>applicationContext.publishEvent(customEvent);      </p><p>24、FileSystemResource和ClassPathResource有何区别？<br>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。<br>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。<br>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。<br>25、Spring 框架中都用到了哪些设计模式？<br>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：<br>o代理模式—在AOP和remoting中被用的比较多。<br>o单例模式—在spring配置文件中定义的bean默认为单例模式。<br>o模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。<br>o前端控制器—Spring提供了DispatcherServlet来对请求进行分发。<br>o视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。<br>o依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。<br>o工厂模式—BeanFactory用来创建对象的实例      </p><ol><li>开发中主要使用 Spring 的什么技术 ?<br>①. IOC 容器管理各层的组件<br>②. 使用 AOP 配置声明式事务<br>③. 整合其他框架.  </li><li>简述 AOP 和 IOC 概念 AOP:<br>Aspect Oriented Program, 面向(方面)切面的编程;Filter(过滤器) 也是一种 AOP. AOP 是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充. AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点.可以举例通过事务说明.</li></ol><p> <br>IOC: Invert Of Control, 控制反转. 也成为 DI(依赖注入)其思想是反转 资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源.作为 回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送 给它所管理的组件,组件所要做的仅是选择一种合适的方式来接受资源. 这种行 为也被称为查找的被动形式<br> <br>3. 在 Spring 中如何配置 Bean ?<br>Bean 的配置方式: 通过全类名（反射）、通过工厂方法（静态工厂方法 &amp; 实 例工厂方法）、FactoryBean<br> <br>4. IOC 容器对 Bean 的生命周期:<br>①. 通过构造器或工厂方法创建 Bean 实例<br>②. 为 Bean 的属性设置值和对其他 Bean 的引用<br>③ . 将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的 postProcessBeforeInitialization 方法<br>④. 调用 Bean 的初始化方法(init-method)<br>⑤ . 将 Bean 实 例 传 递 给 Bean 后 置 处 理 器 的 postProcessAfterInitialization 方法<br>⑦. Bean 可以使用了<br>⑧. 当容器关闭时, 调用 Bean 的销毁方法(destroy-method)</p><p>Spring源码分析之IoC<br>一、 什么是Ioc/DI？<br>二、 Spring IOC体系结构<br>(1) BeanFactory<br>(2) BeanDefinition<br>三、 IoC容器的初始化<br>1、 XmlBeanFactory(屌丝IOC)的整个流程<br>2、 FileSystemXmlApplicationContext 的IOC容器流程<br>1、高富帅IOC解剖<br>2、 设置资源加载器和资源定位<br>3、AbstractApplicationContext的refresh函数载入Bean定义过程：<br>4、AbstractApplicationContext子类的refreshBeanFactory()方法：<br>5、AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法：<br>6、AbstractBeanDefinitionReader读取Bean定义资源：<br>7、资源加载器获取要读入的资源：<br>8、XmlBeanDefinitionReader加载Bean定义资源：<br>9、DocumentLoader将Bean定义资源转换为Document对象：<br>10、XmlBeanDefinitionReader解析载入的Bean定义资源文件：<br>11、DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析：<br>12、BeanDefinitionParserDelegate解析Bean定义资源文件中的<bean>元素：<br>13、BeanDefinitionParserDelegate解析<property>元素：<br>14、解析<property>元素的子元素：<br>15、解析<list>子元素：<br>16、解析过后的BeanDefinition在IoC容器中的注册：<br>17、DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition：<br>总结：<br>四、IOC容器的依赖注入<br>1、依赖注入发生的时间<br>2、AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean：<br>3、AbstractAutowireCapableBeanFactory创建Bean实例对象：<br>4、createBeanInstance方法创建Bean的java实例对象：<br>5、SimpleInstantiationStrategy类使用默认的无参构造方法创建Bean实例化对象：<br>6、populateBean方法对Bean属性的依赖注入：<br>7、BeanDefinitionValueResolver解析属性值：<br>8、BeanWrapperImpl对Bean属性的依赖注入：<br>五、IoC容器的高级特性<br>1、介绍<br>2、Spring IoC容器的lazy-init属性实现预实例化：<br>(1) .refresh()<br>(2).finishBeanFactoryInitialization处理预实例化Bean：<br>(3) .DefaultListableBeanFactory对配置lazy-init属性单态Bean的预实例化：<br>3、FactoryBean的实现：<br>(1).FactoryBean的源码如下：<br>(2). AbstractBeanFactory的getBean方法调用FactoryBean：<br>(3)、AbstractBeanFactory生产Bean实例对象：<br>(4).工厂Bean的实现类getObject方法创建Bean实例对象：<br>4.BeanPostProcessor后置处理器的实现：<br>(1).BeanPostProcessor的源码如下：<br>(2).AbstractAutowireCapableBeanFactory类对容器生成的Bean添加后置处理器：<br>(3).initializeBean方法为容器产生的Bean实例对象添加BeanPostProcessor后置处理器：<br>(4).AdvisorAdapterRegistrationManager在Bean对象初始化后注册通知适配器：<br>5.Spring IoC容器autowiring实现原理：<br>(1). AbstractAutoWireCapableBeanFactory对Bean实例进行属性依赖注入：<br>(2).Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入：<br>(3).DefaultSingletonBeanRegistry的registerDependentBean方法对属性注入：<br> <br>一、什么是Ioc/DI？<br>    IoC 容器：最主要是完成了完成对象的创建和依赖的管理注入等等。<br>先从我们自己设计这样一个视角来考虑：<br>所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。<br>对象和对象关系怎么表示？<br>可以用 xml ， properties 文件等语义化配置文件表示。<br>描述对象关系的文件存放在哪里？<br>可能是 classpath ， filesystem ，或者是 URL 网络资源， servletContext 等。<br>回到正题，有了配置文件，还需要对配置文件解析。<br>不同的配置文件对对象的描述不一样，如标准的，自定义声明式的，如何统一？ 在内部需要有一个统一的关于对象的定义，所有外部的描述都必须转化成统一的描述定义。<br>如何对不同的配置文件进行解析？需要对不同的配置文件语法，采用不同的解析器<br> <br>二、 Spring IOC体系结构？<br>(1) BeanFactory<br>         Spring Bean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，其相互关系如下：</list></property></property></bean></p><p> <br>其中BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范，BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为.<br>最基本的IOC容器接口BeanFactory  </p><p>1 public interface BeanFactory {<br>2<br>3 //对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，<br>4 //如果需要得到工厂本身，需要转义<br>5 String FACTORY_BEAN_PREFIX = “&amp;”;<br>6<br>7 //根据bean的名字，获取在IOC容器中得到bean实例<br>8 Object getBean(String name) throws BeansException;<br>9<br>10 //根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。<br>11 Object getBean(String name, Class requiredType) throws BeansException;<br>12<br>13 //提供对bean的检索，看看是否在IOC容器有这个名字的bean<br>14 boolean containsBean(String name);<br>15<br>16 //根据bean名字得到bean实例，并同时判断这个bean是不是单例<br>17 boolean isSingleton(String name) throws NoSuchBeanDefinitionException;<br>18<br>19 //得到bean实例的Class类型<br>20 Class getType(String name) throws NoSuchBeanDefinitionException;<br>21<br>22 //得到bean的别名，如果根据别名检索，那么其原名也会被检索出来<br>23 String[] getAliases(String name);<br>24<br>}</p><p> <br> <br> <br>在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的bean是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。<br> <br>            而要知道工厂是如何产生对象的，我们需要看具体的IOC容器实现，spring提供了许多IOC容器的实现。比如XmlBeanFactory，ClasspathXmlApplicationContext等。其中XmlBeanFactory就是针对最基本的ioc容器的实现，这个IOC容器可以读取XML文件定义的BeanDefinition（XML文件中对bean的描述）,如果说XmlBeanFactory是容器中的屌丝，ApplicationContext应该算容器中的高帅富.<br> <br>            ApplicationContext是Spring提供的一个高级的IoC容器，它除了能够提供IoC容器的基本功能外，还为用户提供了以下的附加服务。<br> <br>从ApplicationContext接口的实现，我们看出其特点：<br> <br>         1.  支持信息源，可以实现国际化。（实现MessageSource接口）<br> <br>         2.  访问资源。(实现ResourcePatternResolver接口，这个后面要讲)<br> <br>         3.  支持应用事件。(实现ApplicationEventPublisher接口)<br> <br> <br> <br>(2) BeanDefinition<br> <br>         SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的，其继承体系如下：</p><p> <br>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成：</p><p>三、IoC容器的初始化？<br>       IoC容器的初始化包括BeanDefinition的Resource定位、载入和注册这三个基本的过程。我们以ApplicationContext为例讲解，ApplicationContext系列容器也许是我们最熟悉的，因为web项目中使用的XmlWebApplicationContext就属于这个继承体系，还有ClasspathXmlApplicationContext等，其继承体系如下图所示：</p><p> <br>ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的bean定义环境。<br> <br>下面我们分别简单地演示一下两种ioc容器的创建过程<br>1、XmlBeanFactory(屌丝IOC)的整个流程<br> <br>通过XmlBeanFactory的源码，我们可以发现:  </p><p>public class XmlBeanFactory extends DefaultListableBeanFactory{</p><pre><code> private final XmlBeanDefinitionReader reader; 


 public XmlBeanFactory(Resource resource)throws BeansException&#123;
     this(resource, null);
 &#125;
 

 public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory)
      throws BeansException&#123;
     super(parentBeanFactory);
     this.reader = new XmlBeanDefinitionReader(this);
     this.reader.loadBeanDefinitions(resource);
&#125;
</code></pre><p>}</p><p>   </p><p>//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息<br>ClassPathResource resource =new ClassPathResource(“application-context.xml”);<br>//创建DefaultListableBeanFactory<br>DefaultListableBeanFactory factory =new DefaultListableBeanFactory();<br>//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory<br>XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(factory);<br>//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用<br>reader.loadBeanDefinitions(resource);</p><p>通过前面的源码，this.reader = new XmlBeanDefinitionReader(this); 中其中this 传的是factory对象<br> <br> <br>2、FileSystemXmlApplicationContext 的IOC容器流程<br> <br>1、高富帅IOC解剖<br> <br> <br> <br>1   ApplicationContext =new FileSystemXmlApplicationContext(xmlPath);<br> <br>先看其构造函数：<br> <br>   调用构造函数：</p><p>/**</p><ul><li>Create a new FileSystemXmlApplicationContext, loading the definitions</li><li>from the given XML files and automatically refreshing the context.</li><li>@param configLocations array of file paths</li><li>@throws BeansException if context creation failed</li><li>/public FileSystemXmlApplicationContext(String… configLocations) throws BeansException {<pre><code>  this(configLocations, true, null);
</code></pre>}</li></ul><p>实际调用</p><p>public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)<br>throws BeansException {<br>super(parent);<br>setConfigLocations(configLocations);<br>if (refresh) {<br>refresh();<br>}<br>}</p><p> <br> <br>2、设置资源加载器和资源定位<br> <br>通过分析FileSystemXmlApplicationContext的源代码可以知道，在创建FileSystemXmlApplicationContext容器时，构造方法做以下两项重要工作：<br>首先，调用父类容器的构造方法(super(parent)方法)为容器设置好Bean资源加载器。<br>然后，再调用父类AbstractRefreshableConfigApplicationContext的setConfigLocations(configLocations)方法设置Bean定义资源文件的定位路径。<br>通过追踪FileSystemXmlApplicationContext的继承体系，发现其父类的父类AbstractApplicationContext中初始化IoC容器所做的主要源码如下：  </p><p>public abstract class AbstractApplicationContext extends DefaultResourceLoader<br>implements ConfigurableApplicationContext, DisposableBean {<br>//静态初始化块，在整个容器创建过程中只执行一次<br>static {<br>//为了避免应用程序在Weblogic8.1关闭时出现类加载异常加载问题，加载IoC容<br>//器关闭事件(ContextClosedEvent)类<br>ContextClosedEvent.class.getName();<br>}<br>//FileSystemXmlApplicationContext调用父类构造方法调用的就是该方法<br>public AbstractApplicationContext(ApplicationContext parent) {<br>this.parent = parent;<br>this.resourcePatternResolver = getResourcePatternResolver();<br>}<br>//获取一个Spring Source的加载器用于读入Spring Bean定义资源文件<br>protected ResourcePatternResolver getResourcePatternResolver() {<br>// AbstractApplicationContext继承DefaultResourceLoader，也是一个S<br>//Spring资源加载器，其getResource(String location)方法用于载入资源<br>return new PathMatchingResourcePatternResolver(this);<br>}<br>……<br>}</p><p> <br> <br> <br> <br>AbstractApplicationContext构造方法中调用PathMatchingResourcePatternResolver的构造方法创建Spring资源加载器：<br> <br>public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {<br>Assert.notNull(resourceLoader, “ResourceLoader must not be null”);<br>//设置Spring的资源加载器<br>this.resourceLoader = resourceLoader;<br>}<br> <br>在设置容器的资源加载器之后，接下来FileSystemXmlApplicationContet执行setConfigLocations方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean定义资源文件的定位，该方法的源码如下：  </p><pre><code>//处理单个资源文件路径为一个字符串的情况  
public void setConfigLocation(String location) &#123;  
   //String CONFIG_LOCATION_DELIMITERS = &quot;,; /t/n&quot;;  
   //即多个资源文件路径之间用” ,; /t/n”分隔，解析成数组形式  
    setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));  
&#125;  

//解析Bean定义资源文件的路径，处理多个资源文件字符串数组  
 public void setConfigLocations(String[] locations) &#123;  
    if (locations != null) &#123;  
        Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);  
        this.configLocations = new String[locations.length];  
        for (int i = 0; i &lt; locations.length; i++) &#123;  
            // resolvePath为同一个类中将字符串解析为路径的方法  
            this.configLocations[i] = resolvePath(locations[i]).trim();  
        &#125;  
    &#125;  
    else &#123;  
        this.configLocations = null;  
    &#125;  
&#125; 
</code></pre><p> <br> <br>通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个Spring Bean定义资源文件，也可以使用字符串数组，即下面两种方式都是可以的：<br>a.    ClasspathResource res = new ClasspathResource(“a.xml,b.xml,……”);<br>多个资源文件路径之间可以是用” ,; /t/n”等分隔。<br>b.    ClasspathResource res = new ClasspathResource(newString[]{“a.xml”,”b.xml”,……});<br>至此，Spring IoC容器在初始化时将配置的Bean定义资源文件定位为Spring封装的Resource。<br> <br>3、AbstractApplicationContext的refresh函数载入Bean定义过程：<br> <br>Spring IoC容器对Bean定义资源的载入是从refresh()函数开始的，refresh()是一个模板方法，refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入<br>FileSystemXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh()函数启动整个IoC容器对Bean定义的载入过程：  </p><p>1 public void refresh() throws BeansException, IllegalStateException {<br>2 synchronized (this.startupShutdownMonitor) {<br>3 //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识<br>4 prepareRefresh();<br>5 //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从<br>6 //子类的refreshBeanFactory()方法启动<br>7 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>8 //为BeanFactory配置容器特性，例如类加载器、事件处理器等<br>9 prepareBeanFactory(beanFactory);<br>10 try {<br>11 //为容器的某些子类指定特殊的BeanPost事件处理器<br>12 postProcessBeanFactory(beanFactory);<br>13 //调用所有注册的BeanFactoryPostProcessor的Bean<br>14 invokeBeanFactoryPostProcessors(beanFactory);<br>15 //为BeanFactory注册BeanPost事件处理器.<br>16 //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件<br>17 registerBeanPostProcessors(beanFactory);<br>18 //初始化信息源，和国际化相关.<br>19 initMessageSource();<br>20 //初始化容器事件传播器.<br>21 initApplicationEventMulticaster();<br>22 //调用子类的某些特殊Bean初始化方法<br>23 onRefresh();<br>24 //为事件传播器注册事件监听器.<br>25 registerListeners();<br>26 //初始化所有剩余的单态Bean.<br>27 finishBeanFactoryInitialization(beanFactory);<br>28 //初始化容器的生命周期事件处理器，并发布容器的生命周期事件<br>29 finishRefresh();<br>30 }<br>31 catch (BeansException ex) {<br>32 //销毁以创建的单态Bean<br>33 destroyBeans();<br>34 //取消refresh操作，重置容器的同步标识.<br>35 cancelRefresh(ex);<br>36 throw ex;<br>37 }<br>38 }<br>39 }</p><p> <br>refresh()方法主要为IoC容器Bean的生命周期管理提供条件，Spring IoC容器载入Bean定义资源文件从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。<br> <br> refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入<br> <br>AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()方法，启动容器载入Bean定义资源文件的过程，代码如下：</p><pre><code>protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;  
    //这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法
     refreshBeanFactory();  
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();  
    if (logger.isDebugEnabled()) &#123;  
        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);  
    &#125;  
    return beanFactory;  
&#125; 
</code></pre><p> <br>AbstractApplicationContext子类的refreshBeanFactory()方法：<br> <br>   AbstractApplicationContext类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类AbstractRefreshableApplicationContext实现的    refreshBeanFactory()方法，方法的源码如下：  </p><p>1 protected final void refreshBeanFactory() throws BeansException {<br>2 if (hasBeanFactory()) {//如果已经有容器，销毁容器中的bean，关闭容器<br>3 destroyBeans();<br>4 closeBeanFactory();<br>5 }<br>6 try {<br>7 //创建IoC容器<br>8 DefaultListableBeanFactory beanFactory = createBeanFactory();<br>9 beanFactory.setSerializationId(getId());<br>10 //对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等<br>11 customizeBeanFactory(beanFactory);<br>12 //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器<br>13 loadBeanDefinitions(beanFactory);<br>14 synchronized (this.beanFactoryMonitor) {<br>15 this.beanFactory = beanFactory;<br>16 }<br>17 }<br>18 catch (IOException ex) {<br>19 throw new ApplicationContextException(“I/O error parsing bean definition source for “ + getDisplayName(), ex);<br>20 }<br>21 }</p><p> <br> <br> <br> <br> <br> <br>在这个方法中，先判断BeanFactory是否存在，如果存在则先销毁beans并关闭beanFactory，接着创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean<br> <br>定义。<br> <br> <br> <br>5、AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法：<br> <br> <br> <br>AbstractRefreshableApplicationContext中只定义了抽象的loadBeanDefinitions方法，容器真正调用的是其子类AbstractXmlApplicationContext对该方法的实现，AbstractXmlApplicationContext的主要源码如下：<br> <br>loadBeanDefinitions方法同样是抽象方法，是由其子类实现的，也即在AbstractXmlApplicationContext中。  </p><p>1 public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {<br>2 ……<br>3 //实现父类抽象的载入Bean定义方法<br>4 @Override<br>5 protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {<br>6 //创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容 器使用该读取器读取Bean定义资源<br>7 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);<br>8 //为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的<br>9 //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器<br>10 beanDefinitionReader.setResourceLoader(this);<br>11 //为Bean读取器设置SAX xml解析器<br>12 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));<br>13 //当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制<br>14 initBeanDefinitionReader(beanDefinitionReader);<br>15 //Bean读取器真正实现加载的方法<br>16 loadBeanDefinitions(beanDefinitionReader);<br>17 }<br>18 //Xml Bean读取器加载Bean定义资源<br>19 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {<br>20 //获取Bean定义资源的定位<br>21 Resource[] configResources = getConfigResources();<br>22 if (configResources != null) {<br>23 //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位<br>24 //的Bean定义资源<br>25 reader.loadBeanDefinitions(configResources);<br>26 }<br>27 //如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源<br>28 String[] configLocations = getConfigLocations();<br>29 if (configLocations != null) {<br>30 //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位<br>31 //的Bean定义资源<br>32 reader.loadBeanDefinitions(configLocations);<br>33 }<br>34 }<br>35 //这里又使用了一个委托模式，调用子类的获取Bean定义资源定位的方法<br>36 //该方法在ClassPathXmlApplicationContext中进行实现，对于我们<br>37 //举例分析源码的FileSystemXmlApplicationContext没有使用该方法<br>38 protected Resource[] getConfigResources() {<br>39 return null;<br>40 } ……<br>41}</p><p> <br> <br> <br> <br> <br> <br>Xml Bean读取器(XmlBeanDefinitionReader)调用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions方法读取Bean定义资源。<br> <br>由于我们使用FileSystemXmlApplicationContext作为例子分析，因此getConfigResources的返回值为null，因此程序执行reader.loadBeanDefinitions(configLocations)分支。<br> <br> <br> <br>6、AbstractBeanDefinitionReader读取Bean定义资源：<br> <br> <br> <br>AbstractBeanDefinitionReader的loadBeanDefinitions方法源码如下：<br> <br> 可以到org.springframework.beans.factory.support看一下BeanDefinitionReader的结构</p><p> <br> <br>在其抽象父类AbstractBeanDefinitionReader中定义了载入过程  </p><p>1 //重载方法，调用下面的loadBeanDefinitions(String, Set<resource>);方法<br>2 public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {<br>3 return loadBeanDefinitions(location, null);<br>4 }<br>5 public int loadBeanDefinitions(String location, Set<resource>actualResources) throws BeanDefinitionStoreException {<br>6 //获取在IoC容器初始化过程中设置的资源加载器<br>7 ResourceLoader resourceLoader = getResourceLoader();<br>8 if (resourceLoader == null) {<br>9 throw new BeanDefinitionStoreException(<br>10 “Cannot import bean definitions from location [“ + location + “]: no ResourceLoader available”);<br>11 }<br>12 if (resourceLoader instanceof ResourcePatternResolver) {<br>13 try {<br>14 //将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源<br>15 //加载多个指定位置的Bean定义资源文件<br>16 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>17 //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能<br>18 int loadCount = loadBeanDefinitions(resources);<br>19 if (actualResources != null) {<br>20 for (Resource resource : resources) {<br>21 actualResources.add(resource);<br>22 }<br>23 }<br>24 if (logger.isDebugEnabled()) {<br>25 logger.debug(“Loaded “ + loadCount + “ bean definitions from location pattern [“ + location + “]”);<br>26 }<br>27 return loadCount;<br>28 }<br>29 catch (IOException ex) {<br>30 throw new BeanDefinitionStoreException(<br>31 “Could not resolve bean definition resource pattern [“ + location + “]”, ex);<br>32 }<br>33 }<br>34 else {<br>35 //将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源<br>36 //加载单个指定位置的Bean定义资源文件<br>37 Resource resource = resourceLoader.getResource(location);<br>38 //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能<br>39 int loadCount = loadBeanDefinitions(resource);<br>40 if (actualResources != null) {<br>41 actualResources.add(resource);<br>42 }<br>43 if (logger.isDebugEnabled()) {<br>44 logger.debug(“Loaded “ + loadCount + “ bean definitions from location [“ + location + “]”);<br>45 }<br>46 return loadCount;<br>47 }<br>48 }<br>49 //重载方法，调用loadBeanDefinitions(String);<br>50 public int loadBeanDefinitions(String… locations) throws BeanDefinitionStoreException {<br>51 Assert.notNull(locations, “Location array must not be null”);<br>52 int counter = 0;<br>53 for (String location : locations) {<br>54 counter += loadBeanDefinitions(location);<br>55 }<br>56 return counter;<br>}</resource></resource></p><p> <br> <br> <br> <br> <br>loadBeanDefinitions(Resource…resources)方法和上面分析的3个方法类似，同样也是调用XmlBeanDefinitionReader的loadBeanDefinitions方法。<br> <br>从对AbstractBeanDefinitionReader的loadBeanDefinitions方法源码分析可以看出该方法做了以下两件事：<br> <br>首先，调用资源加载器的获取资源方法resourceLoader.getResource(location)，获取到要加载的资源。<br> <br>其次，真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinitions方法。<br> <br> <br>看到第8、16行，结合上面的ResourceLoader与ApplicationContext的继承关系图，可以知道此时调用的是DefaultResourceLoader中的getSource()方法定位Resource，因为FileSystemXmlApplicationContext本身就是DefaultResourceLoader的实现类，所以此时又回到了FileSystemXmlApplicationContext中来。<br> <br>7、资源加载器获取要读入的资源：<br> <br>XmlBeanDefinitionReader通过调用其父类DefaultResourceLoader的getResource方法获取要加载的资源，其源码如下  </p><p>1 //获取Resource的具体实现方法<br>2 public Resource getResource(String location) {<br>3 Assert.notNull(location, “Location must not be null”);<br>4 //如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象<br>5 if (location.startsWith(CLASSPATH_URL_PREFIX)) {<br>6 return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());<br>7 }<br>8 try {<br>9 // 如果是URL 方式，使用UrlResource 作为bean 文件的资源对象<br>10 URL url = new URL(location);<br>11 return new UrlResource(url);<br>12 }<br>13 catch (MalformedURLException ex) {<br>14 }<br>15 //如果既不是classpath标识，又不是URL标识的Resource定位，则调用<br>16 //容器本身的getResourceByPath方法获取Resource<br>17 return getResourceByPath(location);<br>18<br>19 }</p><p> <br>FileSystemXmlApplicationContext容器提供了getResourceByPath方法的实现，就是为了处理既不是classpath标识，又不是URL标识的Resource定位这种情况。  </p><p>protected Resource getResourceByPath(String path) {<br>if (path != null &amp;&amp; path.startsWith(“/“)) {<br>path = path.substring(1);<br>}<br>//这里使用文件系统资源对象来定义bean 文件<br>return new FileSystemResource(path);<br>}</p><p> <br>这样代码就回到了 FileSystemXmlApplicationContext 中来，他提供了FileSystemResource 来完成从文件系统得到配置文件的资源定义。<br>这样，就可以从文件系统路径上对IOC 配置文件进行加载 - 当然我们可以按照这个逻辑从任何地方加载，在Spring 中我们看到它提供 的各种资源抽象，比如ClassPathResource, URLResource,FileSystemResource 等来供我们使用。上面我们看到的是定位Resource 的一个过程，而这只是加载过程的一部分.<br>     <br> <br> <br>8、XmlBeanDefinitionReader加载Bean定义资源：<br>     <br>     Bean定义的Resource得到了<br>     继续回到XmlBeanDefinitionReader的loadBeanDefinitions(Resource …)方法看到代表bean文件的资源定义以后的载入过程。</p><p>1 //XmlBeanDefinitionReader加载资源的入口方法<br>2 public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {<br>3 //将读入的XML资源进行特殊编码处理<br>4 return loadBeanDefinitions(new EncodedResource(resource));<br>5 }<br>//这里是载入XML形式Bean定义资源文件方法<br>6 public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {<br>7 …….<br>8 try {<br>9 //将资源文件转为InputStream的IO流<br>10 InputStream inputStream = encodedResource.getResource().getInputStream();<br>11 try {<br>12 //从InputStream中得到XML的解析源<br>13 InputSource inputSource = new InputSource(inputStream);<br>14 if (encodedResource.getEncoding() != null) {<br>15 inputSource.setEncoding(encodedResource.getEncoding());<br>16 }<br>17 //这里是具体的读取过程<br>18 return doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>19 }<br>20 finally {<br>21 //关闭从Resource中得到的IO流<br>22 inputStream.close();<br>23 }<br>24 }<br>25 ………<br>26}<br>27 //从特定XML文件中实际载入Bean定义资源的方法<br>28 protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)<br>29 throws BeanDefinitionStoreException {<br>30 try {<br>31 int validationMode = getValidationModeForResource(resource);<br>32 //将XML文件转换为DOM对象，解析过程由documentLoader实现<br>33 Document doc = this.documentLoader.loadDocument(<br>34 inputSource, this.entityResolver, this.errorHandler, validationMode, this.namespaceAware);<br>35 //这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则<br>36 return registerBeanDefinitions(doc, resource);<br>37 }<br>38 …….<br>}</p><p> <br> <br> <br> <br> <br>通过源码分析，载入Bean定义资源文件的最后一步是将Bean定义资源转换为Document对象，该过程由documentLoader实现<br> <br>    <br> <br>9、DocumentLoader将Bean定义资源转换为Document对象：<br> <br>      <br> <br>DocumentLoader将Bean定义资源转换成Document对象的源码如下：  </p><p>1 //使用标准的JAXP将载入的Bean定义资源转换成document对象<br>2 public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,<br>3 ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {<br>4 //创建文件解析器工厂<br>5 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);<br>6 if (logger.isDebugEnabled()) {<br>7 logger.debug(“Using JAXP provider [“ + factory.getClass().getName() + “]”);<br>8 }<br>9 //创建文档解析器<br>10 DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);<br>11 //解析Spring的Bean定义资源<br>12 return builder.parse(inputSource);<br>13 }<br>14 protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)<br>15 throws ParserConfigurationException {<br>16 //创建文档解析工厂<br>17 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();<br>18 factory.setNamespaceAware(namespaceAware);<br>19 //设置解析XML的校验<br>20 if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {<br>21 factory.setValidating(true);<br>22 if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {<br>23 factory.setNamespaceAware(true);<br>24 try {<br>25 factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);<br>26 }<br>27 catch (IllegalArgumentException ex) {<br>28 ParserConfigurationException pcex = new ParserConfigurationException(<br>29 “Unable to validate using XSD: Your JAXP provider [“ + factory +<br>30 “] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? “ +<br>31 “Upgrade to Apache Xerces (or Java 1.5) for full XSD support.”);<br>32 pcex.initCause(ex);<br>33 throw pcex;<br>34 }<br>35 }<br>36 }<br>37 return factory;<br>38 }</p><p> <br>该解析过程调用JavaEE标准的JAXP标准进行处理。<br>至此Spring IoC容器根据定位的Bean定义资源文件，将其加载读入并转换成为Document对象过程完成。<br> <br> <br>接下来我们要继续分析Spring IoC容器将载入的Bean定义资源文件转换为Document对象之后，是如何将其解析为Spring IoC管理的Bean对象并将其注册到容器中的。<br> <br>10、XmlBeanDefinitionReader解析载入的Bean定义资源文件：<br> <br> XmlBeanDefinitionReader类中的doLoadBeanDefinitions方法是从特定XML文件中实际载入Bean定义资源的方法，该方法在载入Bean定义资源之后将其转换为Document对象，接下来调用registerBeanDefinitions启动Spring IoC容器对Bean定义的解析过程，registerBeanDefinitions方法源码如下：  </p><p>1 //按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构<br>2 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {<br>3 //得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析<br>4 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<br>5 //获得容器中注册的Bean数量<br>6 int countBefore = getRegistry().getBeanDefinitionCount();<br>7 //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成<br>8 documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>9 //统计解析的Bean数量<br>10 return getRegistry().getBeanDefinitionCount() - countBefore;<br>11 }<br>12 //创建BeanDefinitionDocumentReader对象，解析Document对象<br>13 protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {<br>14 return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));<br>}</p><p> <br>Bean定义资源的载入解析分为以下两个过程：<br>首先，通过调用XML解析器将Bean定义资源文件转换得到Document对象，但是这些Document对象并没有按照Spring的Bean规则进行解析。这一步是载入的过程<br>其次，在完成通用的XML解析之后，按照Spring的Bean规则对Document对象进行解析。<br>按照Spring的Bean规则对Document对象解析的过程是在接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader中实现的。<br> <br>11、DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析：<br> <br>BeanDefinitionDocumentReader接口通过registerBeanDefinitions方法调用其实现类DefaultBeanDefinitionDocumentReader对Document对象进行解析，解析的代码如下：        </p><p>1 //根据Spring DTD对Bean的定义规则解析Bean定义Document对象<br>2 public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {<br>3 //获得XML描述符<br>4 this.readerContext = readerContext;<br>5 logger.debug(“Loading bean definitions”);<br>6 //获得Document的根元素<br>7 Element root = doc.getDocumentElement();<br>8 //具体的解析过程由BeanDefinitionParserDelegate实现，<br>9 //BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素<br>10 BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);<br>11 //在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性<br>12 preProcessXml(root);<br>13 //从Document的根元素开始进行Bean定义的Document对象<br>14 parseBeanDefinitions(root, delegate);<br>15 //在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性<br>16 postProcessXml(root);<br>17 }<br>18 //创建BeanDefinitionParserDelegate，用于完成真正的解析过程<br>19 protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root) {<br>20 BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);<br>21 //BeanDefinitionParserDelegate初始化Document根元素<br>22 delegate.initDefaults(root);<br>23 return delegate;<br>24 }<br>25 //使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象<br>26 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {<br>27 //Bean定义的Document对象使用了Spring默认的XML命名空间<br>28 if (delegate.isDefaultNamespace(root)) {<br>29 //获取Bean定义的Document对象根元素的所有子节点<br>30 NodeList nl = root.getChildNodes();<br>31 for (int i = 0; i &lt; nl.getLength(); i++) {<br>32 Node node = nl.item(i);<br>33 //获得Document节点是XML元素节点<br>34 if (node instanceof Element) {<br>35 Element ele = (Element) node;<br>36 //Bean定义的Document的元素节点使用的是Spring默认的XML命名空间<br>37 if (delegate.isDefaultNamespace(ele)) {<br>38 //使用Spring的Bean规则解析元素节点<br>39 parseDefaultElement(ele, delegate);<br>40 }<br>41 else {<br>42 //没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点<br>43 delegate.parseCustomElement(ele);<br>44 }<br>45 }<br>46 }<br>47 }<br>48 else {<br>49 //Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的<br>50 //解析规则解析Document根节点<br>51 delegate.parseCustomElement(root);<br>52 }<br>53 }<br>54 //使用Spring的Bean规则解析Document元素节点<br>55 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {<br>56 //如果元素节点是<import>导入元素，进行导入解析<br>57 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {<br>58 importBeanDefinitionResource(ele);<br>59 }<br>60 //如果元素节点是<alias>别名元素，进行别名解析<br>61 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {<br>62 processAliasRegistration(ele);<br>63 }<br>64 //元素节点既不是导入元素，也不是别名元素，即普通的<bean>元素，<br>65 //按照Spring的Bean规则解析元素<br>66 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {<br>67 processBeanDefinition(ele, delegate);<br>68 }<br>69 }<br>70 //解析<import>导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中<br>71 protected void importBeanDefinitionResource(Element ele) {<br>72 //获取给定的导入元素的location属性<br>73 String location = ele.getAttribute(RESOURCE_ATTRIBUTE);<br>74 //如果导入元素的location属性值为空，则没有导入任何资源，直接返回<br>75 if (!StringUtils.hasText(location)) {<br>76 getReaderContext().error(“Resource location must not be empty”, ele);<br>77 return;<br>78 }<br>79 //使用系统变量值解析location属性值<br>80 location = SystemPropertyUtils.resolvePlaceholders(location);<br>81 Set<resource>actualResources = new LinkedHashSet<resource>(4);<br>82 //标识给定的导入元素的location是否是绝对路径<br>83 boolean absoluteLocation = false;<br>84 try {<br>85 absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();<br>86 }<br>87 catch (URISyntaxException ex) {<br>88 //给定的导入元素的location不是绝对路径<br>89 }<br>90 //给定的导入元素的location是绝对路径<br>91 if (absoluteLocation) {<br>92 try {<br>93 //使用资源读入器加载给定路径的Bean定义资源<br>94 int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);<br>95 if (logger.isDebugEnabled()) {<br>96 logger.debug(“Imported “ + importCount + “ bean definitions from URL location [“ + location + “]”);<br>97 }<br>98 }<br>99 catch (BeanDefinitionStoreException ex) {<br>100 getReaderContext().error(<br>101 “Failed to import bean definitions from URL location [“ + location + “]”, ele, ex);<br>102 }<br>103 }<br>104 else {<br>105 //给定的导入元素的location是相对路径<br>106 try {<br>107 int importCount;<br>108 //将给定导入元素的location封装为相对路径资源<br>109 Resource relativeResource = getReaderContext().getResource().createRelative(location);<br>110 //封装的相对路径资源存在<br>111 if (relativeResource.exists()) {<br>112 //使用资源读入器加载Bean定义资源<br>113 importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);<br>114 actualResources.add(relativeResource);<br>115 }<br>116 //封装的相对路径资源不存在<br>117 else {<br>118 //获取Spring IoC容器资源读入器的基本路径<br>119 String baseLocation = getReaderContext().getResource().getURL().toString();<br>120 //根据Spring IoC容器资源读入器的基本路径加载给定导入<br>121 //路径的资源<br>122 importCount = getReaderContext().getReader().loadBeanDefinitions(<br>123 StringUtils.applyRelativePath(baseLocation, location), actualResources);<br>124 }<br>125 if (logger.isDebugEnabled()) {<br>126 logger.debug(“Imported “ + importCount + “ bean definitions from relative location [“ + location + “]”);<br>127 }<br>128 }<br>129 catch (IOException ex) {<br>130 getReaderContext().error(“Failed to resolve current resource location”, ele, ex);<br>131 }<br>132 catch (BeanDefinitionStoreException ex) {<br>133 getReaderContext().error(“Failed to import bean definitions from relative location [“ + location + “]”,<br>134 ele, ex);<br>135 }<br>136 }<br>137 Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);<br>138 //在解析完<import>元素之后，发送容器导入其他资源处理完成事件<br>139 getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));<br>140 }<br>141 //解析<alias>别名元素，为Bean向Spring IoC容器注册别名<br>142 protected void processAliasRegistration(Element ele) {<br>143 //获取<alias>别名元素中name的属性值<br>144 String name = ele.getAttribute(NAME_ATTRIBUTE);<br>145 //获取<alias>别名元素中alias的属性值<br>146 String alias = ele.getAttribute(ALIAS_ATTRIBUTE);<br>147 boolean valid = true;<br>148 //<alias>别名元素的name属性值为空<br>149 if (!StringUtils.hasText(name)) {<br>150 getReaderContext().error(“Name must not be empty”, ele);<br>151 valid = false;<br>152 }<br>153 //<alias>别名元素的alias属性值为空<br>154 if (!StringUtils.hasText(alias)) {<br>155 getReaderContext().error(“Alias must not be empty”, ele);<br>156 valid = false;<br>157 }<br>158 if (valid) {<br>159 try {<br>160 //向容器的资源读入器注册别名<br>161 getReaderContext().getRegistry().registerAlias(name, alias);<br>162 }<br>163 catch (Exception ex) {<br>164 getReaderContext().error(“Failed to register alias ‘“ + alias +<br>165 “‘ for bean with name ‘“ + name + “‘“, ele, ex);<br>166 }<br>167 //在解析完<alias>元素之后，发送容器别名处理完成事件<br>168 getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));<br>169 }<br>170 }<br>171 //解析Bean定义资源Document对象的普通元素<br>172 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {<br>173 // BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类<br>174 //对Document对象中<bean>元素的解析由BeanDefinitionParserDelegate实现 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<br>175 if (bdHolder != null) {<br>176 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>177 try {<br>178 //向Spring IoC容器注册解析得到的Bean定义，这是Bean定义向IoC容器注册的入口<br>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>179 }<br>180 catch (BeanDefinitionStoreException ex) {<br>181 getReaderContext().error(“Failed to register bean definition with name ‘“ +<br>182 bdHolder.getBeanName() + “‘“, ele, ex);<br>183 }<br>184 //在完成向Spring IoC容器注册解析得到的Bean定义之后，发送注册事件<br>185 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));<br>186 }<br>187 }</bean></alias></alias></alias></alias></alias></alias></import></resource></resource></import></bean></alias></import></p><p> <br> <br> <br> <br>通过上述Spring IoC容器对载入的Bean定义Document解析可以看出，我们使用Spring时，在Spring配置文件中可以使用<import>元素来导入IoC容器所需要的其他资源，Spring IoC容器在解析时会首先将指定导入的资源加载进容器中。使用<ailas>别名时，Spring IoC容器首先将别名元素所定义的别名注册到容器中。<br> <br>对于既不是<import>元素，又不是<alias>元素的元素，即Spring配置文件中普通的<bean>元素的解析由BeanDefinitionParserDelegate类的parseBeanDefinitionElement方法来实现。<br> <br> <br> <br>12、BeanDefinitionParserDelegate解析Bean定义资源文件中的<bean>元素：<br> <br> <br> <br>Bean定义资源文件中的<import>和<alias>元素解析在DefaultBeanDefinitionDocumentReader中已经完成，对Bean定义资源文件中使用最多的<bean>元素交由BeanDefinitionParserDelegate来解析，其解析实现的源码如下：  </bean></alias></import></bean></bean></alias></import></ailas></import></p><p>1 //解析<bean>元素的入口<br>2 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {<br>3 return parseBeanDefinitionElement(ele, null);<br>4 }<br>5 //解析Bean定义资源文件中的<bean>元素，这个方法中主要处理<bean>元素的id，name<br>6 //和别名属性<br>7 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {<br>8 //获取<bean>元素中的id属性值<br>9 String id = ele.getAttribute(ID_ATTRIBUTE);<br>10 //获取<bean>元素中的name属性值<br>11 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);<br>12 ////获取<bean>元素中的alias属性值<br>13 List<string>aliases = new ArrayList<string>();<br>14 //将<bean>元素中的所有name属性值存放到别名中<br>15 if (StringUtils.hasLength(nameAttr)) {<br>16 String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);<br>17 aliases.addAll(Arrays.asList(nameArr));<br>18 }<br>19 String beanName = id;<br>20 //如果<bean>元素中没有配置id属性时，将别名中的第一个值赋值给beanName<br>21 if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {<br>22 beanName = aliases.remove(0);<br>23 if (logger.isDebugEnabled()) {<br>24 logger.debug(“No XML ‘id’ specified - using ‘“ + beanName +<br>25 “‘ as bean name and “ + aliases + “ as aliases”);<br>26 }<br>27 }<br>28 //检查<bean>元素所配置的id或者name的唯一性，containingBean标识<bean><br>29 //元素中是否包含子<bean>元素<br>30 if (containingBean == null) {<br>31 //检查<bean>元素所配置的id、name或者别名是否重复<br>32 checkNameUniqueness(beanName, aliases, ele);<br>33 }<br>34 //详细对<bean>元素中配置的Bean定义进行解析的地方<br>35 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);<br>36 if (beanDefinition != null) {<br>37 if (!StringUtils.hasText(beanName)) {<br>38 try {<br>39 if (containingBean != null) {<br>40 //如果<bean>元素中没有配置id、别名或者name，且没有包含子//<bean>元素，为解析的Bean生成一个唯一beanName并注册<br>41 beanName = BeanDefinitionReaderUtils.generateBeanName(<br>42 beanDefinition, this.readerContext.getRegistry(), true);<br>43 }<br>44 else {<br>45 //如果<bean>元素中没有配置id、别名或者name，且包含了子//<bean>元素，为解析的Bean使用别名向IoC容器注册<br>46 beanName = this.readerContext.generateBeanName(beanDefinition);<br>47 //为解析的Bean使用别名注册时，为了向后兼容 //Spring1.2/2.0，给别名添加类名后缀<br>48 String beanClassName = beanDefinition.getBeanClassName();<br>49 if (beanClassName != null &amp;&amp;<br>50 beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;<br>51 !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {<br>52 aliases.add(beanClassName);<br>53 }<br>54 }<br>55 if (logger.isDebugEnabled()) {<br>56 logger.debug(“Neither XML ‘id’ nor ‘name’ specified - “ +<br>57 “using generated bean name [“ + beanName + “]”);<br>58 }<br>59 }<br>60 catch (Exception ex) {<br>61 error(ex.getMessage(), ele);<br>62 return null;<br>63 }<br>64 }<br>65 String[] aliasesArray = StringUtils.toStringArray(aliases);<br>66 return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);<br>67 }<br>68 //当解析出错时，返回null<br>69 return null;<br>70 }<br>71 //详细对<bean>元素中配置的Bean定义其他属性进行解析，由于上面的方法中已经对//Bean的id、name和别名等属性进行了处理，该方法中主要处理除这三个以外的其他属性数据<br>72 public AbstractBeanDefinition parseBeanDefinitionElement(<br>73 Element ele, String beanName, BeanDefinition containingBean) {<br>74 //记录解析的<bean><br>75 this.parseState.push(new BeanEntry(beanName));<br>76 //这里只读取<bean>元素中配置的class名字，然后载入到BeanDefinition中去<br>77 //只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成<br>78 String className = null;<br>79 if (ele.hasAttribute(CLASS_ATTRIBUTE)) {<br>80 className = ele.getAttribute(CLASS_ATTRIBUTE).trim();<br>81 }<br>82 try {<br>83 String parent = null;<br>84 //如果<bean>元素中配置了parent属性，则获取parent属性的值<br>85 if (ele.hasAttribute(PARENT_ATTRIBUTE)) {<br>86 parent = ele.getAttribute(PARENT_ATTRIBUTE);<br>87 }<br>88 //根据<bean>元素配置的class名称和parent属性值创建BeanDefinition<br>89 //为载入Bean定义信息做准备<br>90 AbstractBeanDefinition bd = createBeanDefinition(className, parent);<br>91 //对当前的<bean>元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等<br>92 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br>93 //为<bean>元素解析的Bean设置description信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));<br>94 //对<bean>元素的meta(元信息)属性解析<br>95 parseMetaElements(ele, bd);<br>96 //对<bean>元素的lookup-method属性解析<br>97 parseLookupOverrideSubElements(ele, bd.getMethodOverrides());<br>98 //对<bean>元素的replaced-method属性解析<br>99 parseReplacedMethodSubElements(ele, bd.getMethodOverrides());<br>100 //解析<bean>元素的构造方法设置<br>101 parseConstructorArgElements(ele, bd);<br>102 //解析<bean>元素的<property>设置<br>103 parsePropertyElements(ele, bd);<br>104 //解析<bean>元素的qualifier属性<br>105 parseQualifierElements(ele, bd);<br>106 //为当前解析的Bean设置所需的资源和依赖对象<br>107 bd.setResource(this.readerContext.getResource());<br>108 bd.setSource(extractSource(ele));<br>109 return bd;<br>110 }<br>111 catch (ClassNotFoundException ex) {<br>112 error(“Bean class [“ + className + “] not found”, ele, ex);<br>113 }<br>114 catch (NoClassDefFoundError err) {<br>115 error(“Class that bean class [“ + className + “] depends on not found”, ele, err);<br>116 }<br>117 catch (Throwable ex) {<br>118 error(“Unexpected failure during bean definition parsing”, ele, ex);<br>119 }<br>120 finally {<br>121 this.parseState.pop();<br>122 }<br>123 //解析<bean>元素出错时，返回null<br>124 return null;<br>125 }</bean></bean></property></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></bean></string></string></bean></bean></bean></bean></bean></bean></p><p> <br> <br> <br> <br> <br>只要使用过Spring，对Spring配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在Spring配置文件中<bean>元素的中配置的属性就是通过该方法解析和设置到Bean中去的。<br> <br>注意：在解析<bean>元素过程中没有创建和实例化Bean对象，只是创建了Bean对象的定义类BeanDefinition，将<bean>元素中的配置信息设置到BeanDefinition中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的Bean对象。<br> <br>上面方法中一些对一些配置如元信息(meta)、qualifier等的解析，我们在Spring中配置时使用的也不多，我们在使用Spring的<bean>元素时，配置最多的是<property>属性，因此我们下面继续分析源码，了解Bean的属性在解析时是如何设置的。<br> <br> <br> <br>13、BeanDefinitionParserDelegate解析<property>元素：<br> <br> <br> <br>BeanDefinitionParserDelegate在解析<bean>调用parsePropertyElements方法解析<bean>元素中的<property>属性子元素，解析源码如下：  </property></bean></bean></property></property></bean></bean></bean></bean></p><p>1 //解析<bean>元素中的<property>子元素<br>2 public void parsePropertyElements(Element beanEle, BeanDefinition bd) {<br>3 //获取<bean>元素中所有的子元素<br>4 NodeList nl = beanEle.getChildNodes();<br>5 for (int i = 0; i &lt; nl.getLength(); i++) {<br>6 Node node = nl.item(i);<br>7 //如果子元素是<property>子元素，则调用解析<property>子元素方法解析<br>8 if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {<br>9 parsePropertyElement((Element) node, bd);<br>10 }<br>11 }<br>12 }<br>13 //解析<property>元素<br>14 public void parsePropertyElement(Element ele, BeanDefinition bd) {<br>15 //获取<property>元素的名字<br>16 String propertyName = ele.getAttribute(NAME_ATTRIBUTE);<br>17 if (!StringUtils.hasLength(propertyName)) {<br>18 error(“Tag ‘property’ must have a ‘name’ attribute”, ele);<br>19 return;<br>20 }<br>21 this.parseState.push(new PropertyEntry(propertyName));<br>22 try {<br>23 //如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。<br>24 //即如果在同一个Bean中配置同名的property，则只有第一个起作用<br>25 if (bd.getPropertyValues().contains(propertyName)) {<br>26 error(“Multiple ‘property’ definitions for property ‘“ + propertyName + “‘“, ele);<br>27 return;<br>28 }<br>29 //解析获取property的值<br>30 Object val = parsePropertyValue(ele, bd, propertyName);<br>31 //根据property的名字和值创建property实例<br>32 PropertyValue pv = new PropertyValue(propertyName, val);<br>33 //解析<property>元素中的属性<br>34 parseMetaElements(ele, pv);<br>35 pv.setSource(extractSource(ele));<br>36 bd.getPropertyValues().addPropertyValue(pv);<br>37 }<br>38 finally {<br>39 this.parseState.pop();<br>40 }<br>41 }<br>42 //解析获取property值<br>43 public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) {<br>44 String elementName = (propertyName != null) ?<br>45 “<property>element for property ‘“ + propertyName + “‘“ :<br>46 “<constructor-arg>element”;<br>47 //获取<property>的所有子元素，只能是其中一种类型:ref,value,list等<br>48 NodeList nl = ele.getChildNodes();<br>49 Element subElement = null;<br>50 for (int i = 0; i &lt; nl.getLength(); i++) {<br>51 Node node = nl.item(i);<br>52 //子元素不是description和meta属性<br>53 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;<br>54 !nodeNameEquals(node, META_ELEMENT)) {<br>55 if (subElement != null) {<br>56 error(elementName + “ must not contain more than one sub-element”, ele);<br>57 }<br>58 else {//当前<property>元素包含有子元素<br>59 subElement = (Element) node;<br>60 }<br>61 }<br>62 }<br>63 //判断property的属性值是ref还是value，不允许既是ref又是value<br>64 boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);<br>65 boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);<br>66 if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||<br>67 ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) {<br>68 error(elementName +<br>69 “ is only allowed to contain either ‘ref’ attribute OR ‘value’ attribute OR sub-element”, ele);<br>70 }<br>71 //如果属性是ref，创建一个ref的数据对象RuntimeBeanReference，这个对象<br>72 //封装了ref信息<br>73 if (hasRefAttribute) {<br>74 String refName = ele.getAttribute(REF_ATTRIBUTE);<br>75 if (!StringUtils.hasText(refName)) {<br>76 error(elementName + “ contains empty ‘ref’ attribute”, ele);<br>77 }<br>78 //一个指向运行时所依赖对象的引用<br>79 RuntimeBeanReference ref = new RuntimeBeanReference(refName);<br>80 //设置这个ref的数据对象是被当前的property对象所引用<br>81 ref.setSource(extractSource(ele));<br>82 return ref;<br>83 }<br>84 //如果属性是value，创建一个value的数据对象TypedStringValue，这个对象<br>85 //封装了value信息<br>86 else if (hasValueAttribute) {<br>87 //一个持有String类型值的对象<br>88 TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));<br>89 //设置这个value数据对象是被当前的property对象所引用<br>90 valueHolder.setSource(extractSource(ele));<br>91 return valueHolder;<br>92 }<br>93 //如果当前<property>元素还有子元素<br>94 else if (subElement != null) {<br>95 //解析<property>的子元素<br>96 return parsePropertySubElement(subElement, bd);<br>97 }<br>98 else {<br>99 //propery属性中既不是ref，也不是value属性，解析出错返回null error(elementName + “ must specify a ref or value”, ele);<br>100 return null;<br>101 }<br>}</property></property></property></property></constructor-arg></property></property></property></property></property></property></bean></property></bean></p><p> <br> <br> <br> <br> <br>通过对上述源码的分析，我们可以了解在Spring配置文件中，<bean>元素中<property>元素的相关配置是如何处理的：<br> <br>a. ref被封装为指向依赖对象一个引用。<br> <br>b.value配置都会封装成一个字符串类型的对象。<br> <br>c.ref和value都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来。<br> <br>在方法的最后对于<property>元素的子元素通过parsePropertySubElement 方法解析，我们继续分析该方法的源码，了解其解析过程。<br> <br> <br> <br>14、解析<property>元素的子元素：<br> <br> <br> <br>在BeanDefinitionParserDelegate类中的parsePropertySubElement方法对<property>中的子元素解析，源码如下：  </property></property></property></property></bean></p><p>1 //解析<property>元素中ref,value或者集合等子元素<br>2 public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) {<br>3 //如果<property>没有使用Spring默认的命名空间，则使用用户自定义的规则解析//内嵌元素<br>4 if (!isDefaultNamespace(ele)) {<br>5 return parseNestedCustomElement(ele, bd);<br>6 }<br>7 //如果子元素是bean，则使用解析<bean>元素的方法解析<br>8 else if (nodeNameEquals(ele, BEAN_ELEMENT)) {<br>9 BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);<br>10 if (nestedBd != null) {<br>11 nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);<br>12 }<br>13 return nestedBd;<br>14 }<br>15 //如果子元素是ref，ref中只能有以下3个属性：bean、local、parent<br>16 else if (nodeNameEquals(ele, REF_ELEMENT)) {<br>17 //获取<property>元素中的bean属性值，引用其他解析的Bean的名称<br>18 //可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则<br>19 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);<br>20 boolean toParent = false;<br>21 if (!StringUtils.hasLength(refName)) {<br>22 //获取<property>元素中的local属性值，引用同一个Xml文件中配置<br>23 //的Bean的id，local和ref不同，local只能引用同一个配置文件中的Bean<br>24 refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);<br>25 if (!StringUtils.hasLength(refName)) {<br>26 //获取<property>元素中parent属性值，引用父级容器中的Bean<br>27 refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);<br>28 toParent = true;<br>29 if (!StringUtils.hasLength(refName)) {<br>30 error(“‘bean’, ‘local’ or ‘parent’ is required for<ref>element”, ele);<br>31 return null;<br>32 }<br>33 }<br>34 }<br>35 //没有配置ref的目标属性值<br>36 if (!StringUtils.hasText(refName)) {<br>37 error(“<ref>element contains empty target attribute”, ele);<br>38 return null;<br>39 }<br>40 //创建ref类型数据，指向被引用的对象<br>41 RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);<br>42 //设置引用类型值是被当前子元素所引用<br>43 ref.setSource(extractSource(ele));<br>44 return ref;<br>45 }<br>46 //如果子元素是<idref>，使用解析ref元素的方法解析<br>47 else if (nodeNameEquals(ele, IDREF_ELEMENT)) {<br>48 return parseIdRefElement(ele);<br>49 }<br>50 //如果子元素是<value>，使用解析value元素的方法解析<br>51 else if (nodeNameEquals(ele, VALUE_ELEMENT)) {<br>52 return parseValueElement(ele, defaultValueType);<br>53 }<br>54 //如果子元素是null，为<property>设置一个封装null值的字符串数据<br>55 else if (nodeNameEquals(ele, NULL_ELEMENT)) {<br>56 TypedStringValue nullHolder = new TypedStringValue(null);<br>57 nullHolder.setSource(extractSource(ele));<br>58 return nullHolder;<br>59 }<br>60 //如果子元素是<array>，使用解析array集合子元素的方法解析<br>61 else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {<br>62 return parseArrayElement(ele, bd);<br>63 }<br>64 //如果子元素是<list>，使用解析list集合子元素的方法解析<br>65 else if (nodeNameEquals(ele, LIST_ELEMENT)) {<br>66 return parseListElement(ele, bd);<br>67 }<br>68 //如果子元素是<set>，使用解析set集合子元素的方法解析<br>69 else if (nodeNameEquals(ele, SET_ELEMENT)) {<br>70 return parseSetElement(ele, bd);<br>71 }<br>72 //如果子元素是<map>，使用解析map集合子元素的方法解析<br>73 else if (nodeNameEquals(ele, MAP_ELEMENT)) {<br>74 return parseMapElement(ele, bd);<br>75 }<br>76 //如果子元素是<props>，使用解析props集合子元素的方法解析<br>77 else if (nodeNameEquals(ele, PROPS_ELEMENT)) {<br>78 return parsePropsElement(ele);<br>79 }<br>80 //既不是ref，又不是value，也不是集合，则子元素配置错误，返回null<br>81 else {<br>82 error(“Unknown property sub-element: [“ + ele.getNodeName() + “]”, ele);<br>83 return null;<br>84 }<br>}</props></map></set></list></array></property></value></idref></ref></ref></property></property></property></bean></property></property></p><p> <br> <br>通过上述源码分析，我们明白了在Spring配置文件中，对<property>元素中配置的Array、List、Set、Map、Prop等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如ManagedList、ManagedArray、ManagedSet等，这些Managed类是Spring对象BeanDefiniton的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对<list>集合元素的解析方法进行源码分析，了解其实现过程。<br> <br>15、解析<list>子元素：<br> <br>在BeanDefinitionParserDelegate类中的parseListElement方法就是具体实现解析<property>元素中的<list>集合子元素，源码如下：  </list></property></list></list></property></p><p>1 //解析<list>集合子元素<br>2 public List parseListElement(Element collectionEle, BeanDefinition bd) {<br>3 //获取<list>元素中的value-type属性，即获取集合元素的数据类型<br>4 String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);<br>5 //获取<list>集合元素中的所有子节点<br>6 NodeList nl = collectionEle.getChildNodes();<br>7 //Spring中将List封装为ManagedList<br>8 ManagedList<object>target = new ManagedList<object>(nl.getLength());<br>9 target.setSource(extractSource(collectionEle));<br>10 //设置集合目标数据类型<br>11 target.setElementTypeName(defaultElementType);<br>12 target.setMergeEnabled(parseMergeAttribute(collectionEle));<br>13 //具体的<list>元素解析<br>14 parseCollectionElements(nl, target, bd, defaultElementType);<br>15 return target;<br>16 }<br>17 //具体解析<list>集合元素，<array>、<list>和<set>都使用该方法解析<br>18 protected void parseCollectionElements(<br>19 NodeList elementNodes, Collection<object>target, BeanDefinition bd, String defaultElementType) {<br>20 //遍历集合所有节点<br>21 for (int i = 0; i &lt; elementNodes.getLength(); i++) {<br>22 Node node = elementNodes.item(i);<br>23 //节点不是description节点<br>24 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {<br>25 //将解析的元素加入集合中，递归调用下一个子元素<br>26 target.add(parsePropertySubElement((Element) node, bd, defaultElementType));<br>27 }<br>28 }<br>}</object></set></list></array></list></list></object></object></list></list></list></p><p> <br> <br> <br> <br> <br> <br>经过对Spring Bean定义资源文件转换的Document对象中的元素层层解析，Spring IoC现在已经将XML形式定义的Bean定义资源文件转换为Spring IoC所识别的数据结构——BeanDefinition，它是Bean定义资源文件中配置的POJO对象在Spring IoC容器中的映射，我们可以通过AbstractBeanDefinition为入口，荣IoC容器进行索引、查询和操作。<br>通过Spring IoC容器对Bean定义资源的解析后，IoC容器大致完成了管理Bean对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在IoC容器中BeanDefinition存储的只是一些静态信息，接下来需要向容器注册Bean定义信息才能全部完成IoC容器的初始化过程<br> <br>16、解析过后的BeanDefinition在IoC容器中的注册：<br> <br>让我们继续跟踪程序的执行顺序，接下来会到我们第3步中分析DefaultBeanDefinitionDocumentReader对Bean定义转换的Document对象解析的流程中，在其parseDefaultElement方法中完成对Document对象的解析后得到封装BeanDefinition的BeanDefinitionHold对象，然后调用BeanDefinitionReaderUtils的registerBeanDefinition方法向IoC容器注册解析的Bean，BeanDefinitionReaderUtils的注册的源码如下：  </p><p>//将解析的BeanDefinitionHold注册到容器中<br>public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)<br>throws BeanDefinitionStoreException {<br>//获取解析的BeanDefinition的名称<br>String beanName = definitionHolder.getBeanName();<br>//向IoC容器注册BeanDefinition<br>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<br>//如果解析的BeanDefinition有别名，向容器为其注册别名<br>String[] aliases = definitionHolder.getAliases();<br>if (aliases != null) {<br>for (String aliase : aliases) {<br>registry.registerAlias(beanName, aliase);<br>}<br>}<br>}</p><p> <br>当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是DefaultListableBeanFactory。<br> <br>17、DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition：<br> <br>DefaultListableBeanFactory中使用一个HashMap的集合对象存放IoC容器中注册解析的BeanDefinition，向IoC容器注册的主要源码如下：</p><p>1 //存储注册的俄BeanDefinition<br>2 private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();<br>3 //向IoC容器注册解析的BeanDefiniton<br>4 public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)<br>5 throws BeanDefinitionStoreException {<br>6 Assert.hasText(beanName, “Bean name must not be empty”);<br>7 Assert.notNull(beanDefinition, “BeanDefinition must not be null”);<br>8 //校验解析的BeanDefiniton<br>9 if (beanDefinition instanceof AbstractBeanDefinition) {<br>10 try {<br>11 ((AbstractBeanDefinition) beanDefinition).validate();<br>12 }<br>13 catch (BeanDefinitionValidationException ex) {<br>14 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,<br>15 “Validation of bean definition failed”, ex);<br>16 }<br>17 }<br>18 //注册的过程中需要线程同步，以保证数据的一致性<br>19 synchronized (this.beanDefinitionMap) {<br>20 Object oldBeanDefinition = this.beanDefinitionMap.get(beanName);<br>21 //检查是否有同名的BeanDefinition已经在IoC容器中注册，如果已经注册，<br>22 //并且不允许覆盖已注册的Bean，则抛出注册失败异常<br>23 if (oldBeanDefinition != null) {<br>24 if (!this.allowBeanDefinitionOverriding) {<br>25 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,<br>26 “Cannot register bean definition [“ + beanDefinition + “] for bean ‘“ + beanName +<br>27 “‘: There is already [“ + oldBeanDefinition + “] bound.”);<br>28 }<br>29 else {//如果允许覆盖，则同名的Bean，后注册的覆盖先注册的<br>30 if (this.logger.isInfoEnabled()) {<br>31 this.logger.info(“Overriding bean definition for bean ‘“ + beanName +<br>32 “‘: replacing [“ + oldBeanDefinition + “] with [“ + beanDefinition + “]”);<br>33 }<br>34 }<br>35 }<br>36 //IoC容器中没有已经注册同名的Bean，按正常注册流程注册<br>37 else {<br>38 this.beanDefinitionNames.add(beanName);<br>39 this.frozenBeanDefinitionNames = null;<br>40 }<br>41 this.beanDefinitionMap.put(beanName, beanDefinition);<br>42 //重置所有已经注册过的BeanDefinition的缓存<br>43 resetBeanDefinition(beanName);<br>44 }<br>}</p><p> <br>至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现  在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些的注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。<br> <br>总结：<br>     现在通过上面的代码，总结一下IOC容器初始化的基本步骤：<br>u 初始化的入口在容器实现中的 refresh()调用来完成<br>u 对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition,其中的大致过程如下：通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置。如果是 XmlBeanFactory作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader来完成定义信息的解析和 Bean 信息的注册,往往使用的是XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition  这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的， 容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.<br>u 然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。 Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在ServletContext 中的框架实现。具体可以参见以后的文章 <br>在使用 Spring IOC 容器的时候我们还需要区别两个概念:<br>       Beanfactory 和 Factory bean，其中 BeanFactory 指的是 IOC 容器的编程抽象，比如 ApplicationContext， XmlBeanFactory 等，这些都是 IOC 容器的具体表现，需要使用什么样的容器由客户决定,但 Spring 为我们提供了丰富的选择。 FactoryBean 只是一个可以在 IOC而容器中被管理的一个 bean,是对各种处理过程和资源使用的抽象,Factory bean 在需要时产生另一个对象，而不返回 FactoryBean本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean 都实现特殊的org.springframework.beans.factory.FactoryBean 接口，当使用容器中 factory bean 的时候，该容器不会返回 factory bean 本身,而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 Factory bean 的实现，其中包括:对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等，这些我们都可以看成是具体的工厂,看成是SPRING 为我们建立好的工厂。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了<br>     <br> <br>四、IOC容器的依赖注入<br>1、依赖注入发生的时间<br>当Spring IoC容器完成了Bean定义资源的定位、载入和解析注册以后，IoC容器中已经管理类Bean定义的相关数据，但是此时IoC容器还没有对所管理的Bean进行依赖注入，依赖注入在以下两种情况发生：<br>(1).用户第一次通过getBean方法向IoC容索要Bean时，IoC容器触发依赖注入。<br>(2).当用户在Bean定义资源中为<bean>元素配置了lazy-init属性，即让容器在解析注册Bean定义时进行预实例化，触发依赖注入。<br>BeanFactory接口定义了Spring IoC容器的基本功能规范，是Spring IoC容器所应遵守的最底层和最基本的编程规范。BeanFactory接口中定义了几个getBean方法，就是用户向IoC容器索取管理的Bean的方法，我们通过分析其子类的具体实现，理解Spring IoC容器在用户索取Bean时如何完成依赖注入。</bean></p><p> <br>在BeanFactory中我们看到getBean（String…）函数，它的具体实现在AbstractBeanFactory中<br> <br>2、AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean：<br> <br>AbstractBeanFactory的getBean相关方法的源码如下：  </p><p>1 //获取IoC容器中指定名称的Bean<br>2 public Object getBean(String name) throws BeansException {<br>3 //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>4 return doGetBean(name, null, null, false);<br>5 }<br>6 //获取IoC容器中指定名称和类型的Bean<br>7 public<t>T getBean(String name, Class<t>requiredType) throws BeansException {<br>8 //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>9 return doGetBean(name, requiredType, null, false);<br>10 }<br>11 //获取IoC容器中指定名称和参数的Bean<br>12 public Object getBean(String name, Object… args) throws BeansException {<br>13 //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>14 return doGetBean(name, null, args, false);<br>15 }<br>16 //获取IoC容器中指定名称、类型和参数的Bean<br>17 public<t>T getBean(String name, Class<t>requiredType, Object… args) throws BeansException {<br>18 //doGetBean才是真正向IoC容器获取被管理Bean的过程<br>19 return doGetBean(name, requiredType, args, false);<br>20 }<br>21 //真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方<br>22 @SuppressWarnings(“unchecked”)<br>23 protected<t>T doGetBean(<br>24 final String name, final Class<t>requiredType, final Object[] args, boolean typeCheckOnly)<br>25 throws BeansException {<br>26 //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖<br>27 //如果指定的是别名，将别名转换为规范的Bean名称<br>28 final String beanName = transformedBeanName(name);<br>29 Object bean;<br>30 //先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整<br>31 //个IoC容器中只创建一次，不需要重复创建<br>32 Object sharedInstance = getSingleton(beanName);<br>33 //IoC容器创建单态模式Bean实例对象<br>34 if (sharedInstance != null &amp;&amp; args == null) {<br>35 if (logger.isDebugEnabled()) {<br>36 //如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回<br>37 //已经创建的Bean<br>38 if (isSingletonCurrentlyInCreation(beanName)) {<br>39 logger.debug(“Returning eagerly cached instance of singleton bean ‘“ + beanName +<br>40 “‘ that is not fully initialized yet - a consequence of a circular reference”);<br>41 }<br>42 else {<br>43 logger.debug(“Returning cached instance of singleton bean ‘“ + beanName + “‘“);<br>44 }<br>45 }<br>46 //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理<br>47 //注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是<br>48 //创建创建对象的工厂Bean，两者之间有区别<br>49 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);<br>50 }<br>51 else {//缓存没有正在创建的单态模式Bean<br>52 //缓存中已经有已经创建的原型模式Bean，但是由于循环引用的问题导致实<br>53 //例化对象失败<br>54 if (isPrototypeCurrentlyInCreation(beanName)) {<br>55 throw new BeanCurrentlyInCreationException(beanName);<br>56 }<br>57 //对IoC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否<br>58 //能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器<br>59 //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找<br>60 BeanFactory parentBeanFactory = getParentBeanFactory();<br>61 //当前容器的父级容器存在，且当前容器中不存在指定名称的Bean<br>62 if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {<br>63 //解析指定Bean名称的原始名称<br>64 String nameToLookup = originalBeanName(name);<br>65 if (args != null) {<br>66 //委派父级容器根据指定名称和显式的参数查找<br>67 return (T) parentBeanFactory.getBean(nameToLookup, args);<br>68 }<br>69 else {<br>70 //委派父级容器根据指定名称和类型查找<br>71 return parentBeanFactory.getBean(nameToLookup, requiredType);<br>72 }<br>73 }<br>74 //创建的Bean是否需要进行类型验证，一般不需要<br>75 if (!typeCheckOnly) {<br>76 //向容器标记指定的Bean已经被创建<br>77 markBeanAsCreated(beanName);<br>78 }<br>79 //根据指定Bean名称获取其父级的Bean定义，主要解决Bean继承时子类<br>80 //合并父类公共属性问题<br>81 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);<br>82 checkMergedBeanDefinition(mbd, beanName, args);<br>83 //获取当前Bean所有依赖Bean的名称<br>84 String[] dependsOn = mbd.getDependsOn();<br>85 //如果当前Bean有依赖Bean<br>86 if (dependsOn != null) {<br>87 for (String dependsOnBean : dependsOn) {<br>88 //递归调用getBean方法，获取当前Bean的依赖Bean<br>89 getBean(dependsOnBean);<br>90 //把被依赖Bean注册给当前依赖的Bean<br>91 registerDependentBean(dependsOnBean, beanName);<br>92 }<br>93 }<br>94 //创建单态模式Bean的实例对象<br>95 if (mbd.isSingleton()) {<br>96 //这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象<br>97 sharedInstance = getSingleton(beanName, new ObjectFactory() {<br>98 public Object getObject() throws BeansException {<br>99 try {<br>100 //创建一个指定Bean实例对象，如果有父级继承，则合并子//类和父类的定义<br>101 return createBean(beanName, mbd, args);<br>102 }<br>103 catch (BeansException ex) {<br>104 //显式地从容器单态模式Bean缓存中清除实例对象<br>105 destroySingleton(beanName);<br>106 throw ex;<br>107 }<br>108 }<br>109 });<br>110 //获取给定Bean的实例对象<br>111 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>112 }<br>113 //IoC容器创建原型模式Bean实例对象<br>114 else if (mbd.isPrototype()) {<br>115 //原型模式(Prototype)是每次都会创建一个新的对象<br>116 Object prototypeInstance = null;<br>117 try {<br>118 //回调beforePrototypeCreation方法，默认的功能是注册当前创//建的原型对象<br>119 beforePrototypeCreation(beanName);<br>120 //创建指定Bean对象实例<br>121 prototypeInstance = createBean(beanName, mbd, args);<br>122 }<br>123 finally {<br>124 //回调afterPrototypeCreation方法，默认的功能告诉IoC容器指//定Bean的原型对象不再创建了<br>125 afterPrototypeCreation(beanName);<br>126 }<br>127 //获取给定Bean的实例对象<br>128 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>129 }<br>130 //要创建的Bean既不是单态模式，也不是原型模式，则根据Bean定义资源中<br>131 //配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中<br>132 //比较常用，如：request、session、application等生命周期<br>133 else {<br>134 String scopeName = mbd.getScope();<br>135 final Scope scope = this.scopes.get(scopeName);<br>136 //Bean定义资源中没有配置生命周期范围，则Bean定义不合法<br>137 if (scope == null) {<br>138 throw new IllegalStateException(“No Scope registered for scope ‘“ + scopeName + “‘“);<br>139 }<br>140 try {<br>141 //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例<br>142 Object scopedInstance = scope.get(beanName, new ObjectFactory() {<br>143 public Object getObject() throws BeansException {<br>144 beforePrototypeCreation(beanName);<br>145 try {<br>146 return createBean(beanName, mbd, args);<br>147 }<br>148 finally {<br>149 afterPrototypeCreation(beanName);<br>150 }<br>151 }<br>152 });<br>153 //获取给定Bean的实例对象<br>154 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>155 }<br>156 catch (IllegalStateException ex) {<br>157 throw new BeanCreationException(beanName,<br>158 “Scope ‘“ + scopeName + “‘ is not active for the current thread; “ +<br>159 “consider defining a scoped proxy for this bean if you intend to refer to it from a singleton”,<br>160 ex);<br>161 }<br>162 }<br>163 }<br>164 //对创建的Bean实例对象进行类型检查<br>165 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) {<br>166 throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());<br>167 }<br>168 return (T) bean;<br>169 }</t></t></t></t></t></t></p><p> <br> <br> <br> <br> <br> <br>通过上面对向IoC容器获取Bean方法的分析，我们可以看到在Spring中，如果Bean定义的单态模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果Bean定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean定义还可以扩展为指定其生命周期范围。<br>上面的源码只是定义了根据Bean定义的模式，采取的不同创建Bean实例对象的策略，具体的Bean实例对象的创建过程由实现了ObejctFactory接口的匿名内部类的createBean方法完成，ObejctFactory使用委派模式，具体的Bean实例创建过程交由其实现类AbstractAutowireCapableBeanFactory完成，我们继续分析AbstractAutowireCapableBeanFactory的createBean方法的源码，理解其创建Bean实例的具体实现过程。<br> <br>3、AbstractAutowireCapableBeanFactory创建Bean实例对象：<br>AbstractAutowireCapableBeanFactory类实现了ObejctFactory接口，创建容器指定的Bean实例对象，同时还对创建的Bean实例对象进行初始化处理。其创建Bean实例对象的方法源码如下：  </p><p>1 //创建Bean实例对象<br>2 protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)<br>3 throws BeanCreationException {<br>4 if (logger.isDebugEnabled()) {<br>5 logger.debug(“Creating instance of bean ‘“ + beanName + “‘“);<br>6 }<br>7 //判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载<br>8 resolveBeanClass(mbd, beanName);<br>9 //校验和准备Bean中的方法覆盖<br>10 try {<br>11 mbd.prepareMethodOverrides();<br>12 }<br>13 catch (BeanDefinitionValidationException ex) {<br>14 throw new BeanDefinitionStoreException(mbd.getResourceDescription(),<br>15 beanName, “Validation of method overrides failed”, ex);<br>16 }<br>17 try {<br>18 //如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建//Bean的代理对象<br>19 Object bean = resolveBeforeInstantiation(beanName, mbd);<br>20 if (bean != null) {<br>21 return bean;<br>22 }<br>23 }<br>24 catch (Throwable ex) {<br>25 throw new BeanCreationException(mbd.getResourceDescription(), beanName,<br>26 “BeanPostProcessor before instantiation of bean failed”, ex);<br>27 }<br>28 //创建Bean的入口<br>29 Object beanInstance = doCreateBean(beanName, mbd, args);<br>30 if (logger.isDebugEnabled()) {<br>31 logger.debug(“Finished creating instance of bean ‘“ + beanName + “‘“);<br>32 }<br>33 return beanInstance;<br>34 }<br>35 //真正创建Bean的方法<br>36 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {<br>37 //封装被创建的Bean对象<br>38 BeanWrapper instanceWrapper = null;<br>39 if (mbd.isSingleton()){//单态模式的Bean，先从容器中缓存中获取同名Bean<br>40 instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);<br>41 }<br>42 if (instanceWrapper == null) {<br>43 //创建实例对象<br>44 instanceWrapper = createBeanInstance(beanName, mbd, args);<br>45 }<br>46 final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);<br>47 //获取实例化对象的类型<br>48 Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);<br>49 //调用PostProcessor后置处理器<br>50 synchronized (mbd.postProcessingLock) {<br>51 if (!mbd.postProcessed) {<br>52 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>53 mbd.postProcessed = true;<br>54 }<br>55 }<br>56 // Eagerly cache singletons to be able to resolve circular references<br>57 //向容器中缓存单态模式的Bean对象，以防循环引用<br>58 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;<br>59 isSingletonCurrentlyInCreation(beanName));<br>60 if (earlySingletonExposure) {<br>61 if (logger.isDebugEnabled()) {<br>62 logger.debug(“Eagerly caching bean ‘“ + beanName +<br>63 “‘ to allow for resolving potential circular references”);<br>64 }<br>65 //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用<br>66 addSingletonFactory(beanName, new ObjectFactory() {<br>67 public Object getObject() throws BeansException {<br>68 return getEarlyBeanReference(beanName, mbd, bean);<br>69 }<br>70 });<br>71 }<br>72 //Bean对象的初始化，依赖注入在此触发<br>73 //这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean<br>74 Object exposedObject = bean;<br>75 try {<br>76 //将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象<br>77 populateBean(beanName, mbd, instanceWrapper);<br>78 if (exposedObject != null) {<br>79 //初始化Bean对象<br>80 exposedObject = initializeBean(beanName, exposedObject, mbd);<br>81 }<br>82 }<br>83 catch (Throwable ex) {<br>84 if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {<br>85 throw (BeanCreationException) ex;<br>86 }<br>87 else {<br>88 throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Initialization of bean failed”, ex);<br>89 }<br>90 }<br>91 if (earlySingletonExposure) {<br>92 //获取指定名称的已注册的单态模式Bean对象<br>93 Object earlySingletonReference = getSingleton(beanName, false);<br>94 if (earlySingletonReference != null) {<br>95 //根据名称获取的以注册的Bean和正在实例化的Bean是同一个<br>96 if (exposedObject == bean) {<br>97 //当前实例化的Bean初始化完成<br>98 exposedObject = earlySingletonReference;<br>99 }<br>100 //当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象<br>101 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {<br>102 String[] dependentBeans = getDependentBeans(beanName);<br>103 Set<string>actualDependentBeans = new LinkedHashSet<string>(dependentBeans.length);<br>104 //获取当前Bean所依赖的其他Bean<br>105 for (String dependentBean : dependentBeans) {<br>106 //对依赖Bean进行类型检查<br>107 if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {<br>108 actualDependentBeans.add(dependentBean);<br>109 }<br>110 }<br>111 if (!actualDependentBeans.isEmpty()) {<br>112 throw new BeanCurrentlyInCreationException(beanName,<br>113 “Bean with name ‘“ + beanName + “‘ has been injected into other beans [“ +<br>114 StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>115 “] in its raw version as part of a circular reference, but has eventually been “ +<br>116 “wrapped. This means that said other beans do not use the final version of the “ +<br>117 “bean. This is often the result of over-eager type matching - consider using “ +<br>118 “‘getBeanNamesOfType’ with the ‘allowEagerInit’ flag turned off, for example.”);<br>119 }<br>120 }<br>121 }<br>122 }<br>123 //注册完成依赖注入的Bean<br>124 try {<br>125 registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>126 }<br>127 catch (BeanDefinitionValidationException ex) {<br>128 throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Invalid destruction signature”, ex);<br>129 }<br>130 return exposedObject;<br>}</string></string></p><p> <br> <br>通过对方法源码的分析，我们看到具体的依赖注入实现在以下两个方法中：<br>(1).createBeanInstance：生成Bean所包含的java对象实例。<br>(2).populateBean ：对Bean属性的依赖注入进行处理。<br> <br>下面继续分析这两个方法的代码实现。<br>4、createBeanInstance方法创建Bean的java实例对象：<br>在createBeanInstance方法中，根据指定的初始化策略，使用静态工厂、工厂方法或者容器的自动装配特性生成java实例对象，创建对象的源码如下：  </p><p>1 //创建Bean的实例对象<br>2 protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {<br>3 //检查确认Bean是可实例化的<br>4 Class beanClass = resolveBeanClass(mbd, beanName);<br>5 //使用工厂方法对Bean进行实例化<br>6 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {<br>7 throw new BeanCreationException(mbd.getResourceDescription(), beanName,<br>8 “Bean class isn’t public, and non-public access not allowed: “ + beanClass.getName());<br>9 }<br>10 if (mbd.getFactoryMethodName() != null) {<br>11 //调用工厂方法实例化<br>12 return instantiateUsingFactoryMethod(beanName, mbd, args);<br>13 }<br>14 //使用容器的自动装配方法进行实例化<br>15 boolean resolved = false;<br>16 boolean autowireNecessary = false;<br>17 if (args == null) {<br>18 synchronized (mbd.constructorArgumentLock) {<br>19 if (mbd.resolvedConstructorOrFactoryMethod != null) {<br>20 resolved = true;<br>21 autowireNecessary = mbd.constructorArgumentsResolved;<br>22 }<br>23 }<br>24 }<br>25 if (resolved) {<br>26 if (autowireNecessary) {<br>27 //配置了自动装配属性，使用容器的自动装配实例化<br>28 //容器的自动装配是根据参数类型匹配Bean的构造方法<br>29 return autowireConstructor(beanName, mbd, null, null);<br>30 }<br>31 else {<br>32 //使用默认的无参构造方法实例化<br>33 return instantiateBean(beanName, mbd);<br>34 }<br>35 }<br>36 //使用Bean的构造方法进行实例化<br>37 Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<br>38 if (ctors != null ||<br>39 mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||<br>40 mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {<br>41 //使用容器的自动装配特性，调用匹配的构造方法实例化<br>42 return autowireConstructor(beanName, mbd, ctors, args);<br>43 }<br>44 //使用默认的无参构造方法实例化<br>45 return instantiateBean(beanName, mbd);<br>46 }<br>47 //使用默认的无参构造方法实例化Bean对象<br>48 protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {<br>49 try {<br>50 Object beanInstance;<br>51 final BeanFactory parent = this;<br>52 //获取系统的安全管理接口，JDK标准的安全管理API<br>53 if (System.getSecurityManager() != null) {<br>54 //这里是一个匿名内置类，根据实例化策略创建实例对象<br>55 beanInstance = AccessController.doPrivileged(new PrivilegedAction<object>() {<br>56 public Object run() {<br>57 return getInstantiationStrategy().instantiate(mbd, beanName, parent);<br>58 }<br>59 }, getAccessControlContext());<br>60 }<br>61 else {<br>62 //将实例化的对象封装起来<br>63 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);<br>64 }<br>65 BeanWrapper bw = new BeanWrapperImpl(beanInstance);<br>66 initBeanWrapper(bw);<br>67 return bw;<br>68 }<br>69 catch (Throwable ex) {<br>70 throw new BeanCreationException(mbd.getResourceDescription(), beanName, “Instantiation of bean failed”, ex);<br>71 }<br>72 }</object></p><p> <br> <br>经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的Bean的实例化相当比较清楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用的默认无参构造方法就需要使用相应的初始化策略(JDK的反射机制或者CGLIB)来进行初始化了，在方法getInstantiationStrategy().instantiate中就具体实现类使用初始策略实例化对象。<br> <br>5、SimpleInstantiationStrategy类使用默认的无参构造方法创建Bean实例化对象：<br>在使用默认的无参构造方法创建Bean的实例化对象时，方法getInstantiationStrategy().instantiate调用了SimpleInstantiationStrategy类中的实例化Bean的方法，其源码如下：  </p><p>1 //使用初始化策略实例化Bean对象<br>2 public Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner) {<br>3 //如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法<br>4 if (beanDefinition.getMethodOverrides().isEmpty()) {<br>5 Constructor<?> constructorToUse;  
6            synchronized (beanDefinition.constructorArgumentLock) {  
7                //获取对象的构造方法或工厂方法  
8                constructorToUse = (Constructor<?>) beanDefinition.resolvedConstructorOrFactoryMethod;<br>9 //如果没有构造方法且没有工厂方法<br>10 if (constructorToUse == null) {<br>11 //使用JDK的反射机制，判断要实例化的Bean是否是接口<br>12 final Class clazz = beanDefinition.getBeanClass();<br>13 if (clazz.isInterface()) {<br>14 throw new BeanInstantiationException(clazz, “Specified class is an interface”);<br>15 }<br>16 try {<br>17 if (System.getSecurityManager() != null) {<br>18 //这里是一个匿名内置类，使用反射机制获取Bean的构造方法<br>19 constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<constructor>() {<br>20 public Constructor run() throws Exception {<br>21 return clazz.getDeclaredConstructor((Class[]) null);<br>22 }<br>23 });<br>24 }<br>25 else {<br>26 constructorToUse = clazz.getDeclaredConstructor((Class[]) null);<br>27 }<br>28 beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;<br>29 }<br>30 catch (Exception ex) {<br>31 throw new BeanInstantiationException(clazz, “No default constructor found”, ex);<br>32 }<br>33 }<br>34 }<br>35 //使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化<br>36 return BeanUtils.instantiateClass(constructorToUse);<br>37 }<br>38 else {<br>39 //使用CGLIB来实例化对象<br>40 return instantiateWithMethodInjection(beanDefinition, beanName, owner);<br>41 }<br>}</constructor></p><p> <br> <br>通过上面的代码分析，我们看到了如果Bean有方法被覆盖了，则使用JDK的反射机制进行实例化，否则，使用CGLIB进行实例化。<br>instantiateWithMethodInjection方法调用SimpleInstantiationStrategy的子类CglibSubclassingInstantiationStrategy使用CGLIB来进行初始化，其源码如下：  </p><p>1 //使用CGLIB进行Bean对象实例化<br>2 public Object instantiate(Constructor ctor, Object[] args) {<br>3 //CGLIB中的类<br>4 Enhancer enhancer = new Enhancer();<br>5 //将Bean本身作为其基类<br>6 enhancer.setSuperclass(this.beanDefinition.getBeanClass());<br>7 enhancer.setCallbackFilter(new CallbackFilterImpl());<br>8 enhancer.setCallbacks(new Callback[] {<br>9 NoOp.INSTANCE,<br>10 new LookupOverrideMethodInterceptor(),<br>11 new ReplaceOverrideMethodInterceptor()<br>12 });<br>13 //使用CGLIB的create方法生成实例对象<br>14 return (ctor == null) ?<br>15 enhancer.create() :<br>16 enhancer.create(ctor.getParameterTypes(), args);<br>17 }</p><p> <br> <br>CGLIB是一个常用的字节码生成器的类库，它提供了一系列API实现java字节码的生成和转换功能。我们在学习JDK的动态代理时都知道，JDK的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用CGLIB。<br> <br>6、populateBean方法对Bean属性的依赖注入：<br>在第3步的分析中我们已经了解到Bean的依赖注入分为以下两个过程：<br>(1).createBeanInstance：生成Bean所包含的java对象实例。<br>(2).populateBean ：对Bean属性的依赖注入进行处理。<br>第4、5步中我们已经分析了容器初始化生成Bean所包含的Java实例对象的过程，现在我们继续分析生成对象后，Spring IoC容器是如何将Bean的属性依赖关系注入Bean实例对象中并设置好的，属性依赖注入的代码如下：  </p><p>1 //将Bean属性设置到生成的实例对象上<br>2 protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) {<br>3 //获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值<br>4 PropertyValues pvs = mbd.getPropertyValues();<br>5 //实例对象为null<br>6 if (bw == null) {<br>7 //属性值不为空<br>8 if (!pvs.isEmpty()) {<br>9 throw new BeanCreationException(<br>10 mbd.getResourceDescription(), beanName, “Cannot apply property values to null instance”);<br>11 }<br>12 else {<br>13 //实例对象为null，属性值也为空，不需要设置属性值，直接返回<br>14 return;<br>15 }<br>16 }<br>17 //在设置属性之前调用Bean的PostProcessor后置处理器<br>18 boolean continueWithPropertyPopulation = true;<br>19 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {<br>20 for (BeanPostProcessor bp : getBeanPostProcessors()) {<br>21 if (bp instanceof InstantiationAwareBeanPostProcessor) {<br>22 InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<br>23 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {<br>24 continueWithPropertyPopulation = false;<br>25 break;<br>26 }<br>27 }<br>28 }<br>29 }<br>30 if (!continueWithPropertyPopulation) {<br>31 return;<br>32 }<br>33 //依赖注入开始，首先处理autowire自动装配的注入<br>34 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||<br>35 mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {<br>36 MutablePropertyValues newPvs = new MutablePropertyValues(pvs);<br>37 //对autowire自动装配的处理，根据Bean名称自动装配注入<br>38 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {<br>39 autowireByName(beanName, mbd, bw, newPvs);<br>40 }<br>41 //根据Bean类型自动装配注入<br>42 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {<br>43 autowireByType(beanName, mbd, bw, newPvs);<br>44 }<br>45 pvs = newPvs;<br>46 }<br>47 //检查容器是否持有用于处理单态模式Bean关闭时的后置处理器<br>48 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();<br>49 //Bean实例对象没有依赖，即没有继承基类<br>50 boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);<br>51 if (hasInstAwareBpps || needsDepCheck) {<br>52 //从实例对象中提取属性描述符<br>53 PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw);<br>54 if (hasInstAwareBpps) {<br>55 for (BeanPostProcessor bp : getBeanPostProcessors()) {<br>56 if (bp instanceof InstantiationAwareBeanPostProcessor) {<br>57 InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<br>58 //使用BeanPostProcessor处理器处理属性值<br>59 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>60 if (pvs == null) {<br>61 return;<br>62 }<br>63 }<br>64 }<br>65 }<br>66 if (needsDepCheck) {<br>67 //为要设置的属性进行依赖检查<br>68 checkDependencies(beanName, mbd, filteredPds, pvs);<br>69 }<br>70 }<br>71 //对属性进行注入<br>72 applyPropertyValues(beanName, mbd, bw, pvs);<br>73 }<br>74 //解析并注入依赖属性的过程<br>75 protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {<br>76 if (pvs == null || pvs.isEmpty()) {<br>77 return;<br>78 }<br>79 //封装属性值<br>80 MutablePropertyValues mpvs = null;<br>81 List<propertyvalue>original;<br>82 if (System.getSecurityManager()!= null) {<br>83 if (bw instanceof BeanWrapperImpl) {<br>84 //设置安全上下文，JDK安全机制<br>85 ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());<br>86 }<br>87 }<br>88 if (pvs instanceof MutablePropertyValues) {<br>89 mpvs = (MutablePropertyValues) pvs;<br>90 //属性值已经转换<br>91 if (mpvs.isConverted()) {<br>92 try {<br>93 //为实例化对象设置属性值<br>94 bw.setPropertyValues(mpvs);<br>95 return;<br>96 }<br>97 catch (BeansException ex) {<br>98 throw new BeanCreationException(<br>99 mbd.getResourceDescription(), beanName, “Error setting property values”, ex);<br>100 }<br>101 }<br>102 //获取属性值对象的原始类型值<br>103 original = mpvs.getPropertyValueList();<br>104 }<br>105 else {<br>106 original = Arrays.asList(pvs.getPropertyValues());<br>107 }<br>108 //获取用户自定义的类型转换<br>109 TypeConverter converter = getCustomTypeConverter();<br>110 if (converter == null) {<br>111 converter = bw;<br>112 }<br>113 //创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象<br>114 //的实际值<br>115 BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);<br>116 //为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中<br>117 List<propertyvalue>deepCopy = new ArrayList<propertyvalue>(original.size());<br>118 boolean resolveNecessary = false;<br>119 for (PropertyValue pv : original) {<br>120 //属性值不需要转换<br>121 if (pv.isConverted()) {<br>122 deepCopy.add(pv);<br>123 }<br>124 //属性值需要转换<br>125 else {<br>126 String propertyName = pv.getName();<br>127 //原始的属性值，即转换之前的属性值<br>128 Object originalValue = pv.getValue();<br>129 //转换属性值，例如将引用转换为IoC容器中实例化对象引用<br>130 Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);<br>131 //转换之后的属性值<br>132 Object convertedValue = resolvedValue;<br>133 //属性值是否可以转换<br>134 boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;<br>135 !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);<br>136 if (convertible) {<br>137 //使用用户自定义的类型转换器转换属性值<br>138 convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);<br>139 }<br>140 //存储转换后的属性值，避免每次属性注入时的转换工作<br>141 if (resolvedValue == originalValue) {<br>142 if (convertible) {<br>143 //设置属性转换之后的值<br>144 pv.setConvertedValue(convertedValue);<br>145 }<br>146 deepCopy.add(pv);<br>147 }<br>148 //属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是<br>149 //动态生成的字符串，且属性的原始值不是集合或者数组类型<br>150 else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;<br>151 !((TypedStringValue) originalValue).isDynamic() &amp;&amp;<br>152 !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {<br>153 pv.setConvertedValue(convertedValue);<br>154 deepCopy.add(pv);<br>155 }<br>156 else {<br>157 resolveNecessary = true;<br>158 //重新封装属性的值<br>159 deepCopy.add(new PropertyValue(pv, convertedValue));<br>160 }<br>161 }<br>162 }<br>163 if (mpvs != null &amp;&amp; !resolveNecessary) {<br>164 //标记属性值已经转换过<br>165 mpvs.setConverted();<br>166 }<br>167 //进行属性依赖注入<br>168 try {<br>169 bw.setPropertyValues(new MutablePropertyValues(deepCopy));<br>170 }<br>171 catch (BeansException ex) {<br>172 throw new BeanCreationException(<br>173 mbd.getResourceDescription(), beanName, “Error setting property values”, ex);<br>174 }<br>}</propertyvalue></propertyvalue></propertyvalue></p><p> <br>分析上述代码，我们可以看出，对属性的注入过程分以下两种情况：<br>(1).属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入。<br>(2).属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。<br>对属性值的解析是在BeanDefinitionValueResolver类中的resolveValueIfNecessary方法中进行的，对属性值的依赖注入是通过bw.setPropertyValues方法实现的，在分析属性值的依赖注入之前，我们先分析一下对属性值的解析过程。<br> <br>7、BeanDefinitionValueResolver解析属性值：<br> <br>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个Bean实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由resolveValueIfNecessary方法实现，其源码如下：  </p><p>1 //解析属性值，对注入类型进行转换<br>2 public Object resolveValueIfNecessary(Object argName, Object value) {<br>3 //对引用类型的属性进行解析<br>4 if (value instanceof RuntimeBeanReference) {<br>5 RuntimeBeanReference ref = (RuntimeBeanReference) value;<br>6 //调用引用类型属性的解析方法<br>7 return resolveReference(argName, ref);<br>8 }<br>9 //对属性值是引用容器中另一个Bean名称的解析<br>10 else if (value instanceof RuntimeBeanNameReference) {<br>11 String refName = ((RuntimeBeanNameReference) value).getBeanName();<br>12 refName = String.valueOf(evaluate(refName));<br>13 //从容器中获取指定名称的Bean<br>14 if (!this.beanFactory.containsBean(refName)) {<br>15 throw new BeanDefinitionStoreException(<br>16 “Invalid bean name ‘“ + refName + “‘ in bean reference for “ + argName);<br>17 }<br>18 return refName;<br>19 }<br>20 //对Bean类型属性的解析，主要是Bean中的内部类<br>21 else if (value instanceof BeanDefinitionHolder) {<br>22 BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;<br>23 return resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());<br>24 }<br>25 else if (value instanceof BeanDefinition) {<br>26 BeanDefinition bd = (BeanDefinition) value;<br>27 return resolveInnerBean(argName, “(inner bean)”, bd);<br>28 }<br>29 //对集合数组类型的属性解析<br>30 else if (value instanceof ManagedArray) {<br>31 ManagedArray array = (ManagedArray) value;<br>32 //获取数组的类型<br>33 Class elementType = array.resolvedElementType;<br>34 if (elementType == null) {<br>35 //获取数组元素的类型<br>36 String elementTypeName = array.getElementTypeName();<br>37 if (StringUtils.hasText(elementTypeName)) {<br>38 try {<br>39 //使用反射机制创建指定类型的对象<br>40 elementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader());<br>41 array.resolvedElementType = elementType;<br>42 }<br>43 catch (Throwable ex) {<br>44 throw new BeanCreationException(<br>45 this.beanDefinition.getResourceDescription(), this.beanName,<br>46 “Error resolving array type for “ + argName, ex);<br>47 }<br>48 }<br>49 //没有获取到数组的类型，也没有获取到数组元素的类型，则直接设置数<br>50 //组的类型为Object<br>51 else {<br>52 elementType = Object.class;<br>53 }<br>54 }<br>55 //创建指定类型的数组<br>56 return resolveManagedArray(argName, (List<?>) value, elementType);  
57        }  
58        //解析list类型的属性值  
59        else if (value instanceof ManagedList) {  
60            return resolveManagedList(argName, (List<?>) value);<br>61 }<br>62 //解析set类型的属性值<br>63 else if (value instanceof ManagedSet) {<br>64 return resolveManagedSet(argName, (Set<?>) value);  
65        }  
66        //解析map类型的属性值  
67        else if (value instanceof ManagedMap) {  
68            return resolveManagedMap(argName, (Map<?, ?>) value);<br>69 }<br>70 //解析props类型的属性值，props其实就是key和value均为字符串的map<br>71 else if (value instanceof ManagedProperties) {<br>72 Properties original = (Properties) value;<br>73 //创建一个拷贝，用于作为解析后的返回值<br>74 Properties copy = new Properties();<br>75 for (Map.Entry propEntry : original.entrySet()) {<br>76 Object propKey = propEntry.getKey();<br>77 Object propValue = propEntry.getValue();<br>78 if (propKey instanceof TypedStringValue) {<br>79 propKey = evaluate((TypedStringValue) propKey);<br>80 }<br>81 if (propValue instanceof TypedStringValue) {<br>82 propValue = evaluate((TypedStringValue) propValue);<br>83 }<br>84 copy.put(propKey, propValue);<br>85 }<br>86 return copy;<br>87 }<br>88 //解析字符串类型的属性值<br>89 else if (value instanceof TypedStringValue) {<br>90 TypedStringValue typedStringValue = (TypedStringValue) value;<br>91 Object valueObject = evaluate(typedStringValue);<br>92 try {<br>93 //获取属性的目标类型<br>94 Class<?> resolvedTargetType = resolveTargetType(typedStringValue);  
95                if (resolvedTargetType != null) {  
96                    //对目标类型的属性进行解析，递归调用  
97                    return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);  
98                }  
99                //没有获取到属性的目标对象，则按Object类型返回  
100                else {  
101                    return valueObject;  
102                }  
103            }  
104            catch (Throwable ex) {  
105                throw new BeanCreationException(  
106                        this.beanDefinition.getResourceDescription(), this.beanName,  
107                        "Error converting typed String value for " + argName, ex);  
108            }  
109        }  
110        else {  
111            return evaluate(value);  
112        }  
113    }  
114    //解析引用类型的属性值  
115    private Object resolveReference(Object argName, RuntimeBeanReference ref) {  
116        try {  
117            //获取引用的Bean名称  
118            String refName = ref.getBeanName();  
119            refName = String.valueOf(evaluate(refName));  
120            //如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象  
121            if (ref.isToParent()) {  
122                if (this.beanFactory.getParentBeanFactory() == null) {  
123                    throw new BeanCreationException(  
124                            this.beanDefinition.getResourceDescription(), this.beanName,  
125                            "Can't resolve reference to bean '" + refName +  
126                            "' in parent factory: no parent factory available");  
127                }  
128                return this.beanFactory.getParentBeanFactory().getBean(refName);  
129            }  
130            //从当前的容器中获取指定的引用Bean对象，如果指定的Bean没有被实例化  
131            //则会递归触发引用Bean的初始化和依赖注入  
132            else {  
133                Object bean = this.beanFactory.getBean(refName);  
134                //将当前实例化对象的依赖引用对象  
135                this.beanFactory.registerDependentBean(refName, this.beanName);  
136                return bean;  
137            }  
138        }  
139        catch (BeansException ex) {  
140            throw new BeanCreationException(  
141                    this.beanDefinition.getResourceDescription(), this.beanName,  
142                    "Cannot resolve reference to bean '" + ref.getBeanName() + "' while setting " + argName, ex);  
143        }  
144    }   
145    //解析array类型的属性  
146    private Object resolveManagedArray(Object argName, List<?> ml, Class elementType) {<br>147 //创建一个指定类型的数组，用于存放和返回解析后的数组<br>148 Object resolved = Array.newInstance(elementType, ml.size());<br>149 for (int i = 0; i &lt; ml.size(); i++) {<br>150 //递归解析array的每一个元素，并将解析后的值设置到resolved数组中，索引为i<br>151 Array.set(resolved, i,<br>152 resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i)));<br>153 }<br>154 return resolved;<br>155 }<br>156 //解析list类型的属性<br>157 private List resolveManagedList(Object argName, List<?> ml) {  
158        List<Object> resolved = new ArrayList<Object>(ml.size());  
159        for (int i = 0; i < ml.size(); i++) {  
160            //递归解析list的每一个元素  
161            resolved.add(  
162                resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i)));  
163        }  
164        return resolved;  
165    }  
166    //解析set类型的属性  
167    private Set resolveManagedSet(Object argName, Set<?> ms) {<br>168 Set<object>resolved = new LinkedHashSet<object>(ms.size());<br>169 int i = 0;<br>170 //递归解析set的每一个元素<br>171 for (Object m : ms) {<br>172 resolved.add(resolveValueIfNecessary(new KeyedArgName(argName, i), m));<br>173 i++;<br>174 }<br>175 return resolved;<br>176 }<br>177 //解析map类型的属性<br>178 private Map resolveManagedMap(Object argName, Map<?, ?> mm) {<br>179 Map&lt;Object, Object&gt; resolved = new LinkedHashMap&lt;Object, Object&gt;(mm.size());<br>180 //递归解析map中每一个元素的key和value<br>181 for (Map.Entry entry : mm.entrySet()) {<br>182 Object resolvedKey = resolveValueIfNecessary(argName, entry.getKey());<br>183 Object resolvedValue = resolveValueIfNecessary(<br>184 new KeyedArgName(argName, entry.getKey()), entry.getValue());<br>185 resolved.put(resolvedKey, resolvedValue);<br>186 }<br>187 return resolved;<br>188 }</object></object></p><p> <br> <br> <br> <br> <br>通过上面的代码分析，我们明白了Spring是如何将引用类型，内部类以及集合类型等属性进行解析的，属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是Bean对象实例设置到它所依赖的Bean对象属性上去，在第7步中我们已经说过，依赖注入是通过bw.setPropertyValues方法实现的，该方法也使用了委托模式，在BeanWrapper接口中至少定义了方法声明，依赖注入的具体实现交由其实现类BeanWrapperImpl来完成，下面我们就分析依BeanWrapperImpl中赖注入相关的源码。<br> <br>8、BeanWrapperImpl对Bean属性的依赖注入：<br> <br>BeanWrapperImpl类主要是对容器中完成初始化的Bean实例对象进行属性的依赖注入，即把Bean对象设置到它所依赖的另一个Bean的属性中去，依赖注入的相关源码如下：  </p><p>1 //实现属性依赖注入功能<br>2 private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {<br>3 //PropertyTokenHolder主要保存属性的名称、路径，以及集合的size等信息<br>4 String propertyName = tokens.canonicalName;<br>5 String actualName = tokens.actualName;<br>6 //keys是用来保存集合类型属性的size<br>7 if (tokens.keys != null) {<br>8 //将属性信息拷贝<br>9 PropertyTokenHolder getterTokens = new PropertyTokenHolder();<br>10 getterTokens.canonicalName = tokens.canonicalName;<br>11 getterTokens.actualName = tokens.actualName;<br>12 getterTokens.keys = new String[tokens.keys.length - 1];<br>13 System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);<br>14 Object propValue;<br>15 try {<br>16 //获取属性值，该方法内部使用JDK的内省( Introspector)机制，调用属性//的getter(readerMethod)方法，获取属性的值<br>17 propValue = getPropertyValue(getterTokens);<br>18 }<br>19 catch (NotReadablePropertyException ex) {<br>20 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,<br>21 “Cannot access indexed value in property referenced “ +<br>22 “in indexed property path ‘“ + propertyName + “‘“, ex);<br>23 }<br>24 //获取集合类型属性的长度<br>25 String key = tokens.keys[tokens.keys.length - 1];<br>26 if (propValue == null) {<br>27 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,<br>28 “Cannot access indexed value in property referenced “ +<br>29 “in indexed property path ‘“ + propertyName + “‘: returned null”);<br>30 }<br>31 //注入array类型的属性值<br>32 else if (propValue.getClass().isArray()) {<br>33 //获取属性的描述符<br>34 PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);<br>35 //获取数组的类型<br>36 Class requiredType = propValue.getClass().getComponentType();<br>37 //获取数组的长度<br>38 int arrayIndex = Integer.parseInt(key);<br>39 Object oldValue = null;<br>40 try {<br>41 //获取数组以前初始化的值<br>42 if (isExtractOldValueForEditor()) {<br>43 oldValue = Array.get(propValue, arrayIndex);<br>44 }<br>45 //将属性的值赋值给数组中的元素<br>46 Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,<br>47 new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));<br>48 Array.set(propValue, arrayIndex, convertedValue);<br>49 }<br>50 catch (IndexOutOfBoundsException ex) {<br>51 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,<br>52 “Invalid array index in property path ‘“ + propertyName + “‘“, ex);<br>53 }<br>54 }<br>55 //注入list类型的属性值<br>56 else if (propValue instanceof List) {<br>57 PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);<br>58 //获取list集合的类型<br>59 Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(<br>60 pd.getReadMethod(), tokens.keys.length);<br>61 List list = (List) propValue;<br>62 //获取list集合的size<br>63 int index = Integer.parseInt(key);<br>64 Object oldValue = null;<br>65 if (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) {<br>66 oldValue = list.get(index);<br>67 }<br>68 //获取list解析后的属性值<br>69 Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,<br>70 new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));<br>71 if (index &lt; list.size()) {<br>72 //为list属性赋值<br>73 list.set(index, convertedValue);<br>74 }<br>75 //如果list的长度大于属性值的长度，则多余的元素赋值为null<br>76 else if (index &gt;= list.size()) {<br>77 for (int i = list.size(); i &lt; index; i++) {<br>78 try {<br>79 list.add(null);<br>80 }<br>81 catch (NullPointerException ex) {<br>82 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,<br>83 “Cannot set element with index “ + index + “ in List of size “ +<br>84 list.size() + “, accessed using property path ‘“ + propertyName +<br>85 “‘: List does not support filling up gaps with null elements”);<br>86 }<br>87 }<br>88 list.add(convertedValue);<br>89 }<br>90 }<br>91 //注入map类型的属性值<br>92 else if (propValue instanceof Map) {<br>93 PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);<br>94 //获取map集合key的类型<br>95 Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(<br>96 pd.getReadMethod(), tokens.keys.length);<br>97 //获取map集合value的类型<br>98 Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(<br>99 pd.getReadMethod(), tokens.keys.length);<br>100 Map map = (Map) propValue;<br>101 //解析map类型属性key值<br>102 Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType,<br>103 new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));<br>104 Object oldValue = null;<br>105 if (isExtractOldValueForEditor()) {<br>106 oldValue = map.get(convertedMapKey);<br>107 }<br>108 //解析map类型属性value值<br>109 Object convertedMapValue = convertIfNecessary(<br>110 propertyName, oldValue, pv.getValue(), mapValueType,<br>111 new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));<br>112 //将解析后的key和value值赋值给map集合属性<br>113 map.put(convertedMapKey, convertedMapValue);<br>114 }<br>115 else {<br>116 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,<br>117 “Property referenced in indexed property path ‘“ + propertyName +<br>118 “‘ is neither an array nor a List nor a Map; returned value was [“ + pv.getValue() + “]”);<br>119 }<br>120 }<br>121 //对非集合类型的属性注入<br>122 else {<br>123 PropertyDescriptor pd = pv.resolvedDescriptor;<br>124 if (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {<br>125 pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);<br>126 //无法获取到属性名或者属性没有提供setter(写方法)方法<br>127 if (pd == null || pd.getWriteMethod() == null) {<br>128 //如果属性值是可选的，即不是必须的，则忽略该属性值<br>129 if (pv.isOptional()) {<br>130 logger.debug(“Ignoring optional value for property ‘“ + actualName +<br>131 “‘ - property not found on bean class [“ + getRootClass().getName() + “]”);<br>132 return;<br>133 }<br>134 //如果属性值是必须的，则抛出无法给属性赋值，因为每天提供setter方法异常<br>135 else {<br>136 PropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());<br>137 throw new NotWritablePropertyException(<br>138 getRootClass(), this.nestedPath + propertyName,<br>139 matches.buildErrorMessage(), matches.getPossibleMatches());<br>140 }<br>141 }<br>142 pv.getOriginalPropertyValue().resolvedDescriptor = pd;<br>143 }<br>144 Object oldValue = null;<br>145 try {<br>146 Object originalValue = pv.getValue();<br>147 Object valueToApply = originalValue;<br>148 if (!Boolean.FALSE.equals(pv.conversionNecessary)) {<br>149 if (pv.isConverted()) {<br>150 valueToApply = pv.getConvertedValue();<br>151 }<br>152 else {<br>153 if (isExtractOldValueForEditor() &amp;&amp; pd.getReadMethod() != null) {<br>154 //获取属性的getter方法(读方法)，JDK内省机制<br>155 final Method readMethod = pd.getReadMethod();<br>156 //如果属性的getter方法不是public访问控制权限的，即访问控制权限比较严格，<br>157 //则使用JDK的反射机制强行访问非public的方法(暴力读取属性值)<br>158 if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &amp;&amp;<br>159 !readMethod.isAccessible()) {<br>160 if (System.getSecurityManager()!= null) {<br>161 //匿名内部类，根据权限修改属性的读取控制限制<br>162 AccessController.doPrivileged(new PrivilegedAction<object>() {<br>163 public Object run() {<br>164 readMethod.setAccessible(true);<br>165 return null;<br>166 }<br>167 });<br>168 }<br>169 else {<br>170 readMethod.setAccessible(true);<br>171 }<br>172 }<br>173 try {<br>174 //属性没有提供getter方法时，调用潜在的读取属性值//的方法，获取属性值<br>175 if (System.getSecurityManager() != null) {<br>176 oldValue = AccessController.doPrivileged(new PrivilegedExceptionAction<object>() {<br>177 public Object run() throws Exception {<br>178 return readMethod.invoke(object);<br>179 }<br>180 }, acc);<br>181 }<br>182 else {<br>183 oldValue = readMethod.invoke(object);<br>184 }<br>185 }<br>186 catch (Exception ex) {<br>187 if (ex instanceof PrivilegedActionException) {<br>188 ex = ((PrivilegedActionException) ex).getException();<br>189 }<br>190 if (logger.isDebugEnabled()) {<br>191 logger.debug(“Could not read previous value of property ‘“ +<br>192 this.nestedPath + propertyName + “‘“, ex);<br>193 }<br>194 }<br>195 }<br>196 //设置属性的注入值<br>197 valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);<br>198 }<br>199 pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);<br>200 }<br>201 //根据JDK的内省机制，获取属性的setter(写方法)方法<br>202 final Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?<br>203 ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :<br>204 pd.getWriteMethod());<br>205 //如果属性的setter方法是非public，即访问控制权限比较严格，则使用JDK的反射机制，<br>206 //强行设置setter方法可访问(暴力为属性赋值)<br>207 if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) &amp;&amp; !writeMethod.isAccessible()) {<br>208 //如果使用了JDK的安全机制，则需要权限验证<br>209 if (System.getSecurityManager()!= null) {<br>210 AccessController.doPrivileged(new PrivilegedAction<object>() {<br>211 public Object run() {<br>212 writeMethod.setAccessible(true);<br>213 return null;<br>214 }<br>215 });<br>216 }<br>217 else {<br>218 writeMethod.setAccessible(true);<br>219 }<br>220 }<br>221 final Object value = valueToApply;<br>222 if (System.getSecurityManager() != null) {<br>223 try {<br>224 //将属性值设置到属性上去<br>225 AccessController.doPrivileged(new PrivilegedExceptionAction<object>() {<br>226 public Object run() throws Exception {<br>227 writeMethod.invoke(object, value);<br>228 return null;<br>229 }<br>230 }, acc);<br>231 }<br>232 catch (PrivilegedActionException ex) {<br>233 throw ex.getException();<br>234 }<br>235 }<br>236 else {<br>237 writeMethod.invoke(this.object, value);<br>238 }<br>239 }<br>240 catch (TypeMismatchException ex) {<br>241 throw ex;<br>242 }<br>243 catch (InvocationTargetException ex) {<br>244 PropertyChangeEvent propertyChangeEvent =<br>245 new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());<br>246 if (ex.getTargetException() instanceof ClassCastException) {<br>247 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());<br>248 }<br>249 else {<br>250 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());<br>251 }<br>252 }<br>253 catch (Exception ex) {<br>254 PropertyChangeEvent pce =<br>255 new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());<br>256 throw new MethodInvocationException(pce, ex);<br>257 }<br>258 }<br>}</object></object></object></object></p><p> <br> <br> <br>通过对上面注入依赖代码的分析，我们已经明白了Spring IoC容器是如何将属性的值注入到Bean实例对象中去的：<br>(1).对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。<br>(2).对于非集合类型的属性，大量使用了JDK的反射和内省机制，通过属性的getter方法(reader method)获取指定属性注入以前的值，同时调用属性的setter方法(writer method)为属性设置注入后的值。看到这里相信很多人都明白了Spring的setter注入原理。<br>至此Spring IoC容器对Bean定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在Spring IoC容器中管理了一系列靠依赖关系联系起来的Bean，程序不需要应用自己手动创建所需的对象，Spring IoC容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖，这就是Spring核心功能的控制反转和依赖注入的相关功能。<br>五、IoC容器的高级特性<br>1、介绍<br>      通过前面4篇文章对Spring IoC容器的源码分析，我们已经基本上了解了Spring IoC容器对Bean定义资源的定位、读入和解析过程，同时也清楚了当用户通过getBean方法向IoC容器获取被管理的Bean时，IoC容器对Bean进行的初始化和依赖注入过程，这些是Spring IoC容器的基本功能特性。Spring IoC容器还有一些高级特性，如使用lazy-init属性对Bean预初始化、FactoryBean产生或者修饰Bean对象的生成、IoC容器初始化Bean过程中使用BeanPostProcessor后置处理器对Bean声明周期事件管理和IoC容器的autowiring自动装配功能等。<br>2、Spring IoC容器的lazy-init属性实现预实例化：<br>      通过前面我们对IoC容器的实现和工作原理分析，我们知道IoC容器的初始化过程就是对Bean定义资源的定位、载入和注册，此时容器对Bean的依赖注入并没有发生，依赖注入主要是在应用程序第一次向容器索取Bean时，通过getBean方法的调用完成。<br>当Bean定义资源的<bean>元素中配置了lazy-init属性时，容器将会在初始化的时候对所配置的Bean进行预实例化，Bean的依赖注入在容器初始化的时候就已经完成。这样，当应用程序第一次向容器索取被管理的Bean时，就不用再初始化和对Bean进行依赖注入了，直接从容器中获取已经完成依赖注入的现成Bean，可以提高应用第一次向容器获取Bean的性能。<br>下面我们通过代码分析容器预实例化的实现过程：<br>(1).refresh()<br>先从IoC容器的初始会过程开始，通过前面文章分析，我们知道IoC容器读入已经定位的Bean定义资源是从refresh方法开始的，我们首先从AbstractApplicationContext类的refresh方法入手分析，源码如下：</bean></p><p>1 //容器初始化的过程，读入Bean定义资源，并解析注册<br>2 public void refresh() throws BeansException, IllegalStateException {<br>3 synchronized (this.startupShutdownMonitor) {<br>4 //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识<br>5 prepareRefresh();<br>6 //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从<br>7 //子类的refreshBeanFactory()方法启动<br>8 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>9 //为BeanFactory配置容器特性，例如类加载器、事件处理器等<br>10 prepareBeanFactory(beanFactory);<br>11 try {<br>12 //为容器的某些子类指定特殊的BeanPost事件处理器<br>13 postProcessBeanFactory(beanFactory);<br>14 //调用所有注册的BeanFactoryPostProcessor的Bean<br>15 invokeBeanFactoryPostProcessors(beanFactory);<br>16 //为BeanFactory注册BeanPost事件处理器.<br>17 //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件<br>18 registerBeanPostProcessors(beanFactory);<br>19 //初始化信息源，和国际化相关.<br>20 initMessageSource();<br>21 //初始化容器事件传播器.<br>22 initApplicationEventMulticaster();<br>23 //调用子类的某些特殊Bean初始化方法<br>24 onRefresh();<br>25 //为事件传播器注册事件监听器.<br>26 registerListeners();<br>27 //这里是对容器lazy-init属性进行处理的入口方法<br>28 finishBeanFactoryInitialization(beanFactory);<br>29 //初始化容器的生命周期事件处理器，并发布容器的生命周期事件<br>30 finishRefresh();<br>31 }<br>32 catch (BeansException ex) {<br>33 //销毁以创建的单态Bean<br>34 destroyBeans();<br>35 //取消refresh操作，重置容器的同步标识.<br>36 cancelRefresh(ex);<br>37 throw ex;<br>38 }<br>39 }<br>}</p><p> <br> <br> <br> <br> <br> <br> <br> <br>在refresh方法中ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory();启动了Bean定义资源的载入、注册过程，而finishBeanFactoryInitialization方法是对注册后的Bean定义中的预实例化(lazy-init=false，Spring默认就是预实例化，即为true)的Bean进行处理的地方。<br> <br>(2).finishBeanFactoryInitialization处理预实例化Bean：<br> <br>当Bean定义资源被载入IoC容器之后，容器将Bean定义资源解析为容器内部的数据结构BeanDefinition注册到容器中，AbstractApplicationContext类中的finishBeanFactoryInitialization方法对配置了预实例化属性的Bean进行预初始化过程，源码如下：</p><p>1 //对配置了lazy-init属性的Bean进行预实例化处理<br>2 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {<br>3 //这是Spring3以后新加的代码，为容器指定一个转换服务(ConversionService)<br>4 //在对某些Bean属性进行转换时使用<br>5 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;<br>6 beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {<br>7 beanFactory.setConversionService(<br>8 beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));<br>9 }<br>10 //为了类型匹配，停止使用临时的类加载器<br>11 beanFactory.setTempClassLoader(null);<br>12 //缓存容器中所有注册的BeanDefinition元数据，以防被修改<br>13 beanFactory.freezeConfiguration();<br>14 //对配置了lazy-init属性的单态模式Bean进行预实例化处理<br>15 beanFactory.preInstantiateSingletons();<br>}</p><p> <br>ConfigurableListableBeanFactory是一个接口，其preInstantiateSingletons方法由其子类DefaultListableBeanFactory提供。  <br>(3)、DefaultListableBeanFactory对配置lazy-init属性单态Bean的预实例化：  </p><p>1//对配置lazy-init属性单态Bean的预实例化<br>2public void preInstantiateSingletons() throws BeansException {<br>3 if (this.logger.isInfoEnabled()) {<br>4 this.logger.info(“Pre-instantiating singletons in “ + this);<br>5 }<br>6 //在对配置lazy-init属性单态Bean的预实例化过程中，必须多线程同步，以确保数据一致性<br>7 synchronized (this.beanDefinitionMap) {<br>8 for (String beanName : this.beanDefinitionNames) {<br>9 //获取指定名称的Bean定义<br>10 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);<br>11 //Bean不是抽象的，是单态模式的，且lazy-init属性配置为false<br>12 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {<br>13 //如果指定名称的bean是创建容器的Bean<br>14 if (isFactoryBean(beanName)) {<br>15 //FACTORY_BEAN_PREFIX=”&amp;”，当Bean名称前面加”&amp;”符号<br>16 //时，获取的是产生容器对象本身，而不是容器产生的Bean.<br>17 //调用getBean方法，触发容器对Bean实例化和依赖注入过程<br>18 final FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName);<br>19 //标识是否需要预实例化<br>20 boolean isEagerInit;<br>21 if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {<br>22 //一个匿名内部类<br>23 isEagerInit = AccessController.doPrivileged(new PrivilegedAction<boolean>() {<br>24 public Boolean run() {<br>25 return ((SmartFactoryBean) factory).isEagerInit();<br>26 }<br>27 }, getAccessControlContext());<br>28 }<br>29 else {<br>30 isEagerInit = factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean) factory).isEagerInit();<br>31 }<br>32 if (isEagerInit) {<br>33 //调用getBean方法，触发容器对Bean实例化和依赖注入过程<br>34 getBean(beanName);<br>35 }<br>36 }<br>37 else {<br>38 //调用getBean方法，触发容器对Bean实例化和依赖注入过程<br>39 getBean(beanName);<br>40 }<br>41 }<br>42 }<br>43 }<br>}</boolean></p><p> <br> <br>通过对lazy-init处理源码的分析，我们可以看出，如果设置了lazy-init属性，则容器在完成Bean定义的注册之后，会通过getBean方法，触发对指定Bean的初始化和依赖注入过程，这样当应用第一次向容器索取所需的Bean时，容器不再需要对Bean进行初始化和依赖注入，直接从已经完成实例化和依赖注入的Bean中取一个线程的Bean，这样就提高了第一次获取Bean的性能。<br>3、FactoryBean的实现：<br>       在Spring中，有两个很容易混淆的类：BeanFactory和FactoryBean。<br>BeanFactory：Bean工厂，是一个工厂(Factory)，我们Spring IoC容器的最顶层接口就是这个BeanFactory，它的作用是管理Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。<br>FactoryBean：工厂Bean，是一个Bean，作用是产生其他bean实例。通常情况下，这种bean没有什么特别的要求，仅需要提供一个工厂方法，该方法用来返回其他bean实例。通常情况下，bean无须自己实现工厂模式，Spring容器担任工厂角色；但少数情况下，容器中的bean本身就是工厂，其作用是产生其它bean实例。<br>当用户使用容器本身时，可以使用转义字符”&amp;”来得到FactoryBean本身，以区别通过FactoryBean产生的实例对象和FactoryBean对象本身。在BeanFactory中通过如下代码定义了该转义字符：<br>StringFACTORY_BEAN_PREFIX = “&amp;”;<br>如果myJndiObject是一个FactoryBean，则使用&amp;myJndiObject得到的是myJndiObject对象，而不是myJndiObject产生出来的对象。<br>(1).FactoryBean的源码如下：</p><p>//工厂Bean，用于产生其他对象<br>public interface FactoryBean<t>{<br>//获取容器管理的对象实例<br>T getObject() throws Exception;<br>//获取Bean工厂创建的对象的类型<br>Class&lt;?&gt; getObjectType();<br>//Bean工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例<br>//对象，每次请求都返回同一个实例对象<br>boolean isSingleton();<br>}</t></p><p> <br>(2). AbstractBeanFactory的getBean方法调用FactoryBean：<br>在前面我们分析Spring Ioc容器实例化Bean并进行依赖注入过程的源码时，提到在getBean方法触发容器实例化Bean的时候会调用AbstractBeanFactory的doGetBean方法来进行实例化的过程，源码如下：</p><p>1 //真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方<br>2 @SuppressWarnings(“unchecked”)<br>3 protected<t>T doGetBean(<br>4 final String name, final Class<t>requiredType, final Object[] args, boolean typeCheckOnly)<br>5 throws BeansException {<br>6 //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖<br>7 //如果指定的是别名，将别名转换为规范的Bean名称<br>8 final String beanName = transformedBeanName(name);<br>9 Object bean;<br>10 //先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整<br>11 //个IoC容器中只创建一次，不需要重复创建<br>12 Object sharedInstance = getSingleton(beanName);<br>13 //IoC容器创建单态模式Bean实例对象<br>14 if (sharedInstance != null &amp;&amp; args == null) {<br>15 if (logger.isDebugEnabled()) {<br>16 //如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回<br>17 //已经创建的Bean<br>18 if (isSingletonCurrentlyInCreation(beanName)) {<br>19 logger.debug(“Returning eagerly cached instance of singleton bean ‘“ + beanName +<br>20 “‘ that is not fully initialized yet - a consequence of a circular reference”);<br>21 }<br>22 else {<br>23 logger.debug(“Returning cached instance of singleton bean ‘“ + beanName + “‘“);<br>24 }<br>25 }<br>26 //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理<br>27 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);<br>28 }<br>29 ……<br>30 }<br>31 //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理<br>32 protected Object getObjectForBeanInstance(<br>33 Object beanInstance, String name, String beanName, RootBeanDefinition mbd) {<br>34 //容器已经得到了Bean实例对象，这个实例对象可能是一个普通的Bean，也可能是<br>35 //一个工厂Bean，如果是一个工厂Bean，则使用它创建一个Bean实例对象，如果<br>36 //调用本身就想获得一个容器的引用，则指定返回这个工厂Bean实例对象<br>37 //如果指定的名称是容器的解引用(dereference，即是对象本身而非内存地址)，<br>38 //且Bean实例也不是创建Bean实例对象的工厂Bean<br>39 if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) {<br>40 throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());<br>41 }<br>42 //如果Bean实例不是工厂Bean，或者指定名称是容器的解引用，调用者向获取对<br>43 //容器的引用，则直接返回当前的Bean实例<br>44 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {<br>45 return beanInstance;<br>46 }<br>47 //处理指定名称不是容器的解引用，或者根据名称获取的Bean实例对象是一个工厂Bean<br>48 //使用工厂Bean创建一个Bean的实例对象<br>49 Object object = null;<br>50 if (mbd == null) {<br>51 //从Bean工厂缓存中获取给定名称的Bean实例对象<br>52 object = getCachedObjectForFactoryBean(beanName);<br>53 }<br>54 //让Bean工厂生产给定名称的Bean对象实例<br>55 if (object == null) {<br>56 FactoryBean factory = (FactoryBean) beanInstance;<br>57 //如果从Bean工厂生产的Bean是单态模式的，则缓存<br>58 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {<br>59 //从容器中获取指定名称的Bean定义，如果继承基类，则合并基类相关属性<br>60 mbd = getMergedLocalBeanDefinition(beanName);<br>61 }<br>62 //如果从容器得到Bean定义信息，并且Bean定义信息不是虚构的，则让工厂<br>63 //Bean生产Bean实例对象<br>64 boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());<br>65 //调用FactoryBeanRegistrySupport类的getObjectFromFactoryBean<br>66 //方法，实现工厂Bean生产Bean对象实例的过程<br>67 object = getObjectFromFactoryBean(factory, beanName, !synthetic);<br>68 }<br>69 return object;<br>}</t></t></p><p> <br> <br> <br> <br>在上面获取给定Bean的实例对象的getObjectForBeanInstance方法中，会调用FactoryBeanRegistrySupport类的getObjectFromFactoryBean方法，该方法实现了Bean工厂生产Bean实例对象。<br> <br>Dereference(解引用)：一个在C/C++中应用比较多的术语，在C++中，”*”是解引用符号，而”&amp;”是引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。<br> <br>(3)、AbstractBeanFactory生产Bean实例对象：<br> <br>AbstractBeanFactory类中生产Bean实例对象的主要源码如下：</p><p>71 //Bean工厂生产Bean实例对象<br>72 protected Object getObjectFromFactoryBean(FactoryBean factory, String beanName, boolean shouldPostProcess) {<br>73 //Bean工厂是单态模式，并且Bean工厂缓存中存在指定名称的Bean实例对象<br>74 if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {<br>75 //多线程同步，以防止数据不一致<br>76 synchronized (getSingletonMutex()) {<br>77 //直接从Bean工厂缓存中获取指定名称的Bean实例对象<br>78 Object object = this.factoryBeanObjectCache.get(beanName);<br>79 //Bean工厂缓存中没有指定名称的实例对象，则生产该实例对象<br>80 if (object == null) {<br>81 //调用Bean工厂的getObject方法生产指定Bean的实例对象<br>82 object = doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);<br>83 //将生产的实例对象添加到Bean工厂缓存中<br>84 this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));<br>85 }<br>86 return (object != NULL_OBJECT ? object : null);<br>87 }<br>88 }<br>89 //调用Bean工厂的getObject方法生产指定Bean的实例对象<br>90 else {<br>91 return doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);<br>92 }<br>93 }<br>94 //调用Bean工厂的getObject方法生产指定Bean的实例对象<br>95 private Object doGetObjectFromFactoryBean(<br>96 final FactoryBean factory, final String beanName, final boolean shouldPostProcess)<br>97 throws BeanCreationException {<br>98 Object object;<br>99 try {<br>100 if (System.getSecurityManager() != null) {<br>101 AccessControlContext acc = getAccessControlContext();<br>102 try {<br>103 //实现PrivilegedExceptionAction接口的匿名内置类<br>104 //根据JVM检查权限，然后决定BeanFactory创建实例对象<br>105 object = AccessController.doPrivileged(new PrivilegedExceptionAction<object>() {<br>106 public Object run() throws Exception {<br>107 //调用BeanFactory接口实现类的创建对象方法<br>108 return factory.getObject();<br>109 }<br>110 }, acc);<br>111 }<br>112 catch (PrivilegedActionException pae) {<br>113 throw pae.getException();<br>114 }<br>115 }<br>116 else {<br>117 //调用BeanFactory接口实现类的创建对象方法<br>118 object = factory.getObject();<br>119 }<br>120 }<br>121 catch (FactoryBeanNotInitializedException ex) {<br>122 throw new BeanCurrentlyInCreationException(beanName, ex.toString());<br>123 }<br>124 catch (Throwable ex) {<br>125 throw new BeanCreationException(beanName, “FactoryBean threw exception on object creation”, ex);<br>126 }<br>127 //创建出来的实例对象为null，或者因为单态对象正在创建而返回null<br>128 if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {<br>129 throw new BeanCurrentlyInCreationException(<br>130 beanName, “FactoryBean which is currently in creation returned null from getObject”);<br>131 }<br>132 //为创建出来的Bean实例对象添加BeanPostProcessor后置处理器<br>133 if (object != null &amp;&amp; shouldPostProcess) {<br>134 try {<br>135 object = postProcessObjectFromFactoryBean(object, beanName);<br>136 }<br>137 catch (Throwable ex) {<br>138 throw new BeanCreationException(beanName, “Post-processing of the FactoryBean’s object failed”, ex);<br>139 }<br>140 }<br>141 return object;<br>}</object></p><p> <br>从上面的源码分析中，我们可以看出，BeanFactory接口调用其实现类的getObject方法来实现创建Bean实例对象的功能。<br>(4).工厂Bean的实现类getObject方法创建Bean实例对象：<br>FactoryBean的实现类有非常多，比如：Proxy、RMI、JNDI、ServletContextFactoryBean等等，FactoryBean接口为Spring容器提供了一个很好的封装机制，具体的getObject有不同的实现类根据不同的实现策略来具体提供，我们分析一个最简单的AnnotationTestFactoryBean的实现源码：</p><p>143 public class AnnotationTestBeanFactory implements FactoryBean<ijmxtestbean>{<br>144 private final FactoryCreatedAnnotationTestBean instance = new FactoryCreatedAnnotationTestBean();<br>145 public AnnotationTestBeanFactory() {<br>146 this.instance.setName(“FACTORY”);<br>147 }<br>148 //AnnotationTestBeanFactory产生Bean实例对象的实现<br>149 public IJmxTestBean getObject() throws Exception {<br>150 return this.instance;<br>151 }<br>152 public Class&lt;? extends IJmxTestBean&gt; getObjectType() {<br>153 return FactoryCreatedAnnotationTestBean.class;<br>154 }<br>155 public boolean isSingleton() {<br>156 return true;<br>157 }<br>}</ijmxtestbean></p><p>其他的Proxy，RMI，JNDI等等，都是根据相应的策略提供getObject的实现。这里不做一一分析，这已经不是Spring的核心功能，有需要的时候再去深入研究。<br>4.BeanPostProcessor后置处理器的实现：<br>BeanPostProcessor后置处理器是Spring IoC容器经常使用到的一个特性，这个Bean后置处理器是一个监听器，可以监听容器触发的Bean声明周期事件。后置处理器向容器注册以后，容器中管理的Bean就具备了接收IoC容器事件回调的能力。<br>BeanPostProcessor的使用非常简单，只需要提供一个实现接口BeanPostProcessor的实现类，然后在Bean的配置文件中设置即可。<br>(1).BeanPostProcessor的源码如下：</p><p>1 package org.springframework.beans.factory.config;<br>2 import org.springframework.beans.BeansException;<br>3 public interface BeanPostProcessor {<br>4 //为在Bean的初始化前提供回调入口<br>5 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;<br>6 //为在Bean的初始化之后提供回调入口<br>7 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;<br>}</p><p> <br>这两个回调的入口都是和容器管理的Bean的生命周期事件紧密相关，可以为用户提供在Spring IoC容器初始化Bean过程中自定义的处理操作。<br>(2).AbstractAutowireCapableBeanFactory类对容器生成的Bean添加后置处理器：<br>BeanPostProcessor后置处理器的调用发生在Spring IoC容器完成对Bean实例对象的创建和属性的依赖注入完成之后，在对Spring依赖注入的源码分析过程中我们知道，当应用程序第一次调用getBean方法(lazy-init预实例化除外)向Spring IoC容器索取指定Bean时触发Spring IoC容器创建Bean实例对象并进行依赖注入的过程，其中真正实现创建Bean对象并进行依赖注入的方法是AbstractAutowireCapableBeanFactory类的doCreateBean方法，主要源码如下：</p><p>1 //真正创建Bean的方法<br>2 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {<br>3 //创建Bean实例对象<br>4 ……<br>5 try {<br>6 //对Bean属性进行依赖注入<br>7 populateBean(beanName, mbd, instanceWrapper);<br>8 if (exposedObject != null) {<br>9 //在对Bean实例对象生成和依赖注入完成以后，开始对Bean实例对象<br>10 //进行初始化 ，为Bean实例对象应用BeanPostProcessor后置处理器<br>11 exposedObject = initializeBean(beanName, exposedObject, mbd);<br>12 }<br>13 }<br>14 catch (Throwable ex) {<br>15 if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {<br>16 throw (BeanCreationException) ex;<br>17 }<br>18 ……<br>19 //为应用返回所需要的实例对象<br>20 return exposedObject;<br>}</p><p> <br> <br>从上面的代码中我们知道，为Bean实例对象添加BeanPostProcessor后置处理器的入口的是initializeBean方法。<br> <br>(3).initializeBean方法为容器产生的Bean实例对象添加BeanPostProcessor后置处理器：<br> <br>同样在AbstractAutowireCapableBeanFactory类中，initializeBean方法实现为容器创建的Bean实例对象添加BeanPostProcessor后置处理器，源码如下：</p><p>1 //初始容器创建的Bean实例对象，为其添加BeanPostProcessor后置处理器<br>2 protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {<br>3 //JDK的安全机制验证权限<br>4 if (System.getSecurityManager() != null) {<br>5 //实现PrivilegedAction接口的匿名内部类<br>6 AccessController.doPrivileged(new PrivilegedAction<object>() {<br>7 public Object run() {<br>8 invokeAwareMethods(beanName, bean);<br>9 return null;<br>10 }<br>11 }, getAccessControlContext());<br>12 }<br>13 else {<br>14 //为Bean实例对象包装相关属性，如名称，类加载器，所属容器等信息<br>15 invokeAwareMethods(beanName, bean);<br>16 }<br>17 Object wrappedBean = bean;<br>18 //对BeanPostProcessor后置处理器的postProcessBeforeInitialization<br>19 //回调方法的调用，为Bean实例初始化前做一些处理<br>20 if (mbd == null || !mbd.isSynthetic()) {<br>21 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>22 }<br>23 //调用Bean实例对象初始化的方法，这个初始化方法是在Spring Bean定义配置<br>24 //文件中通过init-method属性指定的<br>25 try {<br>26 invokeInitMethods(beanName, wrappedBean, mbd);<br>27 }<br>28 catch (Throwable ex) {<br>29 throw new BeanCreationException(<br>30 (mbd != null ? mbd.getResourceDescription() : null),<br>31 beanName, “Invocation of init method failed”, ex);<br>32 }<br>33 //对BeanPostProcessor后置处理器的postProcessAfterInitialization<br>34 //回调方法的调用，为Bean实例初始化之后做一些处理<br>35 if (mbd == null || !mbd.isSynthetic()) {<br>36 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>37 }<br>38 return wrappedBean;<br>39 }<br>40 //调用BeanPostProcessor后置处理器实例对象初始化之前的处理方法<br>41 public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)<br>42 throws BeansException {<br>43 Object result = existingBean;<br>44 //遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器<br>45 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {<br>46 //调用Bean实例所有的后置处理中的初始化前处理方法，为Bean实例对象在<br>47 //初始化之前做一些自定义的处理操作<br>48 result = beanProcessor.postProcessBeforeInitialization(result, beanName);<br>49 if (result == null) {<br>50 return result;<br>51 }<br>52 }<br>53 return result;<br>54 }<br>55 //调用BeanPostProcessor后置处理器实例对象初始化之后的处理方法<br>56 public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)<br>57 throws BeansException {<br>58 Object result = existingBean;<br>59 //遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器<br>60 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {<br>61 //调用Bean实例所有的后置处理中的初始化后处理方法，为Bean实例对象在<br>62 //初始化之后做一些自定义的处理操作<br>63 result = beanProcessor.postProcessAfterInitialization(result, beanName);<br>64 if (result == null) {<br>65 return result;<br>66 }<br>67 }<br>68 return result;<br>}</object></p><p> <br> <br>BeanPostProcessor是一个接口，其初始化前的操作方法和初始化后的操作方法均委托其实现子类来实现，在Spring中，BeanPostProcessor的实现子类非常的多，分别完成不同的操作，如：AOP面向切面编程的注册通知适配器、Bean对象的数据校验、Bean继承属性/方法的合并等等，我们以最简单的AOP切面织入来简单了解其主要的功能。<br> <br>(4).AdvisorAdapterRegistrationManager在Bean对象初始化后注册通知适配器：<br> <br>AdvisorAdapterRegistrationManager是BeanPostProcessor的一个实现类，其主要的作用为容器中管理的Bean注册一个面向切面编程的通知适配器，以便在Spring容器为所管理的Bean进行面向切面编程时提供方便，其源码如下：</p><p>1 //为容器中管理的Bean注册一个面向切面编程的通知适配器<br>2 public class AdvisorAdapterRegistrationManager implements BeanPostProcessor {<br>3 //容器中负责管理切面通知适配器注册的对象<br>4 private AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();<br>5 public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry) {<br>6 this.advisorAdapterRegistry = advisorAdapterRegistry;<br>7 }<br>8 //BeanPostProcessor在Bean对象初始化前的操作<br>9 public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<br>10 //没有做任何操作，直接返回容器创建的Bean对象<br>11 return bean;<br>12 }<br>13 //BeanPostProcessor在Bean对象初始化后的操作<br>14 public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<br>15 if (bean instanceof AdvisorAdapter){<br>16 //如果容器创建的Bean实例对象是一个切面通知适配器，则向容器的注册<br>this.advisorAdapterRegistry.registerAdvisorAdapter((AdvisorAdapter) bean);<br>17 }<br>18 return bean;<br>19 }<br>}</p><p> <br> <br>其他的BeanPostProcessor接口实现类的也类似，都是对Bean对象使用到的一些特性进行处理，或者向IoC容器中注册，为创建的Bean实例对象做一些自定义的功能增加，这些操作是容器初始化Bean时自动触发的，不需要认为的干预。<br> <br>5.Spring IoC容器autowiring实现原理：<br> <br>Spring IoC容器提供了两种管理Bean依赖关系的方式：<br> <br>a.      显式管理：通过BeanDefinition的属性值和构造方法实现Bean依赖关系管理。<br> <br>b． autowiring：Spring IoC容器的依赖自动装配功能，不需要对Bean属性的依赖关系做显式的声明，只需要在配置好autowiring属性，IoC容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的Bean，从而自动地完成依赖注入。<br> <br>通过对autowiring自动装配特性的理解，我们知道容器对Bean的自动装配发生在容器对Bean依赖注入的过程中。在前面对Spring IoC容器的依赖注入过程源码分析中，我们已经知道了容器对Bean实例对象的属性注入的处理发生在AbstractAutoWireCapableBeanFactory类中的populateBean方法中，我们通过程序流程分析autowiring的实现原理：<br> <br>(1). AbstractAutoWireCapableBeanFactory对Bean实例进行属性依赖注入：<br> <br>应用第一次通过getBean方法(配置了lazy-init预实例化属性的除外)向IoC容器索取Bean时，容器创建Bean实例对象，并且对Bean实例对象进行属性依赖注入，AbstractAutoWireCapableBeanFactory的populateBean方法就是实现Bean属性依赖注入的功能，其主要源码如下：</p><p>1 protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) {<br>2 //获取Bean定义的属性值，并对属性值进行处理<br>3 PropertyValues pvs = mbd.getPropertyValues();<br>4 ……<br>5 //对依赖注入处理，首先处理autowiring自动装配的依赖注入<br>6 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||<br>7 mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {<br>8 MutablePropertyValues newPvs = new MutablePropertyValues(pvs);<br>9 //根据Bean名称进行autowiring自动装配处理<br>10 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {<br>11 autowireByName(beanName, mbd, bw, newPvs);<br>12 }<br>13 //根据Bean类型进行autowiring自动装配处理<br>14 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {<br>15 autowireByType(beanName, mbd, bw, newPvs);<br>16 }<br>17 }<br>18 //对非autowiring的属性进行依赖注入处理<br>19 ……<br>}</p><p> <br> <br>(2).Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入：</p><p>1 //根据名称对属性进行自动依赖注入<br>2 protected void autowireByName(<br>3 String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {<br>4 //对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符串，URL等//都是简单属性)进行处理<br>5 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);<br>6 for (String propertyName : propertyNames) {<br>7 //如果Spring IoC容器中包含指定名称的Bean<br>8 if (containsBean(propertyName)) {<br>9 //调用getBean方法向IoC容器索取指定名称的Bean实例，迭代触发属性的//初始化和依赖注入<br>10 Object bean = getBean(propertyName);<br>11 //为指定名称的属性赋予属性值<br>12 pvs.add(propertyName, bean);<br>13 //指定名称属性注册依赖Bean名称，进行属性依赖注入<br>14 registerDependentBean(propertyName, beanName);<br>15 if (logger.isDebugEnabled()) {<br>16 logger.debug(“Added autowiring by name from bean name ‘“ + beanName +<br>17 “‘ via property ‘“ + propertyName + “‘ to bean named ‘“ + propertyName + “‘“);<br>18 }<br>19 }<br>20 else {<br>21 if (logger.isTraceEnabled()) {<br>22 logger.trace(“Not autowiring property ‘“ + propertyName + “‘ of bean ‘“ + beanName +<br>23 “‘ by name: no matching bean found”);<br>24 }<br>25 }<br>26 }<br>27 }<br>28 //根据类型对属性进行自动依赖注入<br>29 protected void autowireByType(<br>30 String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {<br>31 //获取用户定义的类型转换器<br>32 TypeConverter converter = getCustomTypeConverter();<br>33 if (converter == null) {<br>34 converter = bw;<br>35 }<br>36 //存放解析的要注入的属性<br>37 Set<string>autowiredBeanNames = new LinkedHashSet<string>(4);<br>38 //对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符<br>39 //URL等都是简单属性)进行处理<br>40 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);<br>41 for (String propertyName : propertyNames) {<br>42 try {<br>43 //获取指定属性名称的属性描述器<br>44 PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);<br>45 //不对Object类型的属性进行autowiring自动依赖注入<br>46 if (!Object.class.equals(pd.getPropertyType())) {<br>47 //获取属性的setter方法<br>48 MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);<br>49 //检查指定类型是否可以被转换为目标对象的类型<br>50 boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());<br>51 //创建一个要被注入的依赖描述<br>52 DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);<br>53 //根据容器的Bean定义解析依赖关系，返回所有要被注入的Bean对象<br>54 Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);<br>55 if (autowiredArgument != null) {<br>56 //为属性赋值所引用的对象<br>57 pvs.add(propertyName, autowiredArgument);<br>58 }<br>59 for (String autowiredBeanName : autowiredBeanNames) {<br>60 //指定名称属性注册依赖Bean名称，进行属性依赖注入<br>61 registerDependentBean(autowiredBeanName, beanName);<br>62 if (logger.isDebugEnabled()) {<br>63 logger.debug(“Autowiring by type from bean name ‘“ + beanName + “‘ via property ‘“ +<br>64 propertyName + “‘ to bean named ‘“ + autowiredBeanName + “‘“);<br>65 }<br>66 }<br>67 //释放已自动注入的属性<br>68 autowiredBeanNames.clear();<br>69 }<br>70 }<br>71 catch (BeansException ex) {<br>72 throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);<br>73 }<br>74 }<br>}</string></string></p><p> <br>通过上面的源码分析，我们可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依赖注入要稍微简单一些，但是真正实现属性注入的是DefaultSingletonBeanRegistry类的registerDependentBean方法。<br>(3).DefaultSingletonBeanRegistry的registerDependentBean方法对属性注入：</p><p>1 //为指定的Bean注入依赖的Bean<br>2 public void registerDependentBean(String beanName, String dependentBeanName) {<br>3 //处理Bean名称，将别名转换为规范的Bean名称<br>4 String canonicalName = canonicalName(beanName);<br>5 //多线程同步，保证容器内数据的一致性<br>6 //先从容器中：bean名称–&gt;全部依赖Bean名称集合找查找给定名称Bean的依赖Bean<br>7 synchronized (this.dependentBeanMap) {<br>8 //获取给定名称Bean的所有依赖Bean名称<br>9 Set<string>dependentBeans = this.dependentBeanMap.get(canonicalName);<br>10 if (dependentBeans == null) {<br>11 //为Bean设置依赖Bean信息<br>12 dependentBeans = new LinkedHashSet<string>(8);<br>13 this.dependentBeanMap.put(canonicalName, dependentBeans);<br>14 }<br>15 //向容器中：bean名称–&gt;全部依赖Bean名称集合添加Bean的依赖信息<br>16 //即，将Bean所依赖的Bean添加到容器的集合中<br>17 dependentBeans.add(dependentBeanName);<br>18 }<br>19 //从容器中：bean名称–&gt;指定名称Bean的依赖Bean集合找查找给定名称<br>20 //Bean的依赖Bean<br>21 synchronized (this.dependenciesForBeanMap) {<br>22 Set<string>dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);<br>23 if (dependenciesForBean == null) {<br>24 dependenciesForBean = new LinkedHashSet<string>(8);<br>25 this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);<br>26 }<br>27 //向容器中：bean名称–&gt;指定Bean的依赖Bean名称集合添加Bean的依赖信息<br>28 //即，将Bean所依赖的Bean添加到容器的集合中<br>29 dependenciesForBean.add(canonicalName);<br>30 }<br>}</string></string></string></string></p><p> <br> <br>通过对autowiring的源码分析，我们可以看出，autowiring的实现过程：<br> <br>a.    对Bean的属性迭代调用getBean方法，完成依赖Bean的初始化和依赖注入。<br> <br>b.    将依赖Bean的属性引用设置到被依赖的Bean属性上。<br> <br>c.     将依赖Bean的名称和被依赖Bean的名称存储在IoC容器的集合中。<br> <br>Spring IoC容器的autowiring属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，自动属性依赖注入也有不足，首先，Bean的依赖关系在配置文件中无法很清楚地看出来，对于维护造成一定困难。其次，由于自动依赖注入是Spring容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑。</p></web-app></bean></bean></div><footer class="post-footer"><div class="post-tags"><a href="/tags/spring/" rel="tag"># spring</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/cc5f72fdfb9e.html" rel="prev" title="Tomcat"><i class="fa fa-angle-left"></i> Tomcat</a></div><div class="post-nav-item"><a href="/publishes/235b69f65d9c.html" rel="next" title="Spring MVC">Spring MVC <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>