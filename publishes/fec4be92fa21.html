<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="什么是 ELK（ElasticSearch, Logstash, Kibana） ELK 是三个工具的集合，Elasticsearch + Logstash + Kibana，这三个工具组合形成了一套实用、易用的监控架构，很多公司利用它来搭建可视化的海量日志分析平台。  ElasticSearch ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全"><meta property="og:type" content="article"><meta property="og:title" content="架构"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/fec4be92fa21.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="什么是 ELK（ElasticSearch, Logstash, Kibana） ELK 是三个工具的集合，Elasticsearch + Logstash + Kibana，这三个工具组合形成了一套实用、易用的监控架构，很多公司利用它来搭建可视化的海量日志分析平台。  ElasticSearch ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-31T04:24:09.000Z"><meta property="article:modified_time" content="2024-01-05T09:01:46.347Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="ELK"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/fec4be92fa21.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/fec4be92fa21.html","path":"publishes/fec4be92fa21.html","title":"架构"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>架构 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ELK%EF%BC%88ElasticSearch-Logstash-Kibana%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">什么是 ELK（ElasticSearch, Logstash, Kibana）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ElasticSearch"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">ElasticSearch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Logstash"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">Logstash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kibana"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">Kibana</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">什么是网关服务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E4%B8%AD%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84-4-%E7%A7%8D%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">网关服务中，路由器的 4 种路由规则方法是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%81%BE%E9%9A%BE%E6%80%A7%E7%9A%84%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">什么是服务的灾难性的雪崩效应？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%81%BE%E9%9A%BE%E6%80%A7%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">如何解决灾难性雪崩效应？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E5%BC%8F%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">什么是声明式，有什么作用，解决什么问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-AKF-%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">什么是 AKF 拆分原则？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AE%B2%E4%B8%80%E4%B8%8B-webservice-%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">8.</span> <span class="nav-text">简单讲一下 webservice 使用的场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-VSFTPD%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">什么是 VSFTPD？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">10.</span> <span class="nav-text">项目的生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CDN-%E5%8E%9F%E7%90%86"><span class="nav-number">11.</span> <span class="nav-text">CDN 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F"><span class="nav-number">11.0.0.1.</span> <span class="nav-text">分发服务系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%B3%BB%E7%BB%9F"><span class="nav-number">11.0.0.2.</span> <span class="nav-text">负载均衡系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">11.0.0.3.</span> <span class="nav-text">管理系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RMI-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">12.</span> <span class="nav-text">RMI 实现方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%94%E6%80%A7%E6%89%A9%E5%B1%95%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">什么是微服务中的反应性扩展？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E6%9C%BA%E5%90%97%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">我们可以用微服务创建状态机吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E5%B8%88%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">架构师在微服务架构中的角色是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E7%BB%AD%E7%9B%91%E6%B5%8B%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">什么是持续监测？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%91%E4%B8%9D%E9%9B%80%E9%87%8A%E6%94%BE%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">什么是金丝雀释放？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88CI%EF%BC%89%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">什么是持续集成（CI）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%82%A8%E5%AF%B9-Mike-Cohn-%E7%9A%84%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">您对 Mike Cohn 的测试金字塔了解多少？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mock-%E6%88%96-Stub-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">Mock 或 Stub 有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%B6%88%E9%99%A4%E9%9D%9E%E5%86%B3%E5%AE%9A%E8%AE%BA%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">我们如何在测试中消除非决定论？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9%E5%8F%8A%E7%BC%BA%E7%82%B9"><span class="nav-number">22.</span> <span class="nav-text">负载均衡反向代理模式优点及缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E5%9C%A8%E6%9E%B6%E6%9E%84%E4%B8%8A%E5%BA%94%E5%BD%93%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">大型网站在架构上应当考虑哪些问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%82"><span class="nav-number">23.0.0.1.</span> <span class="nav-text">分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%89%B2"><span class="nav-number">23.0.0.2.</span> <span class="nav-text">分割</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">23.0.0.3.</span> <span class="nav-text">分布式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4"><span class="nav-number">23.0.0.4.</span> <span class="nav-text">集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">23.0.0.5.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5"><span class="nav-number">23.0.0.6.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%97%E4%BD%99"><span class="nav-number">23.0.0.7.</span> <span class="nav-text">冗余</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%90%86%EF%BC%89%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%90%86%EF%BC%89"><span class="nav-number">24.</span> <span class="nav-text">正向代理（客户端代理）和反向代理（服务器端代理）*</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8FSession"><span class="nav-number">25.</span> <span class="nav-text">如何实现分布式Session</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAP-%E7%90%86%E8%AE%BA%E5%92%8C-BASE-%E7%90%86%E8%AE%BA"><span class="nav-number">26.</span> <span class="nav-text">CAP 理论和 BASE 理论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c10k%E9%97%AE%E9%A2%98"><span class="nav-number">27.</span> <span class="nav-text">c10k问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">28.</span> <span class="nav-text">一致性哈希</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DDD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">29.</span> <span class="nav-text">DDD设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B%E8%A6%81%E7%82%B9"><span class="nav-number">30.</span> <span class="nav-text">消息中间件选型要点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E7%BB%B4%E5%BA%A6"><span class="nav-number">30.1.</span> <span class="nav-text">功能维度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">30.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7-%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">30.3.</span> <span class="nav-text">可靠性+可用性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86"><span class="nav-number">30.4.</span> <span class="nav-text">运维管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BE%E5%8C%BA%E5%8A%9B%E5%BA%A6%E5%8F%8A%E7%94%9F%E6%80%81%E5%8F%91%E5%B1%95"><span class="nav-number">30.5.</span> <span class="nav-text">社区力度及生态发展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B%E8%AF%AF%E5%8C%BA%E6%80%BB%E7%BB%93"><span class="nav-number">30.6.</span> <span class="nav-text">消息中间件选型误区总结</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/fec4be92fa21.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="架构 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">架构</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-31 12:24:09" itemprop="dateCreated datePublished" datetime="2023-12-31T12:24:09+08:00">2023-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-05 17:01:46" itemprop="dateModified" datetime="2024-01-05T17:01:46+08:00">2024-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>16k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>15 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是-ELK（ElasticSearch-Logstash-Kibana）"><a href="#什么是-ELK（ElasticSearch-Logstash-Kibana）" class="headerlink" title="什么是 ELK（ElasticSearch, Logstash, Kibana）"></a>什么是 ELK（ElasticSearch, Logstash, Kibana）</h1><ul><li>ELK 是三个工具的集合，Elasticsearch + Logstash + Kibana，这三个工具组合形成了<br>一套实用、易用的监控架构，很多公司利用它来搭建可视化的海量日志分析平台。</li></ul><h4 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h4><ul><li>ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口</li><li>Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</li></ul><h4 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h4><ul><li>Logstash 是一个用于管理日志和事件的工具，你可以用它去收集日志、转换日志、解析日志并将他们作为数据提供给其它模块调用，例如搜索、存储等。</li></ul><h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><ul><li>Kibana 是一个优秀的前端日志展示框架，它可以非常详细的将日志转化为各种图表，为用户提供强大的数据可视化支持。</li></ul><h1 id="什么是网关服务？"><a href="#什么是网关服务？" class="headerlink" title="什么是网关服务？"></a>什么是网关服务？</h1><ul><li>网关服务，通常是外部访问服务的唯一接口，访问内部的所有服务都必须先经过网关服务。网关服务的主要功能是消息解析过滤，路由，转发等。</li></ul><h1 id="网关服务中，路由器的-4-种路由规则方法是什么？"><a href="#网关服务中，路由器的-4-种路由规则方法是什么？" class="headerlink" title="网关服务中，路由器的 4 种路由规则方法是什么？"></a>网关服务中，路由器的 4 种路由规则方法是什么？</h1><ul><li>采用 URL 指定路由方式</li><li>采用服务名称指定路由方式</li><li>路由的排除方法</li><li>路由的添加前缀方法</li></ul><h1 id="什么是服务的灾难性的雪崩效应？"><a href="#什么是服务的灾难性的雪崩效应？" class="headerlink" title="什么是服务的灾难性的雪崩效应？"></a>什么是服务的灾难性的雪崩效应？</h1><ul><li>在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问 A 服务，而 A 服务需要调用 B 服务，B 服务需要调用 C 服务，由于网络原因或者自身的原因，如果 B 服务或者 C 服务不能及时响应，A 服务将处于阻塞状态，直到 B 服务 C 服务响应。</li><li>此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应</li></ul><h1 id="如何解决灾难性雪崩效应？"><a href="#如何解决灾难性雪崩效应？" class="headerlink" title="如何解决灾难性雪崩效应？"></a>如何解决灾难性雪崩效应？</h1><ul><li>降级：超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值.</li><li>隔离（线程池隔离和信号量隔离）：限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。</li><li>熔断：当失败率(如因网络故障&#x2F;超时造成的失败率高)达到阀值自动触发降级，熔断器触发的快速失败会进行快速恢复。</li><li>缓存：提供了请求缓存。</li><li>请求合并：提供请求合并。</li></ul><h1 id="什么是声明式，有什么作用，解决什么问题？"><a href="#什么是声明式，有什么作用，解决什么问题？" class="headerlink" title="什么是声明式，有什么作用，解决什么问题？"></a>什么是声明式，有什么作用，解决什么问题？</h1><ul><li>声明式调用就像调用本地方法一样调用远程方法;无感知远程 http 请求。</li><li>Spring Cloud 的声明式调用, 可以做到使用 HTTP 请求远程服务时能就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。</li><li>它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规的 Http Client 构造请求再解析返回数据。</li><li>它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</li></ul><h1 id="什么是-AKF-拆分原则？"><a href="#什么是-AKF-拆分原则？" class="headerlink" title="什么是 AKF 拆分原则？"></a>什么是 AKF 拆分原则？</h1><ul><li>业界对于可扩展的系统架构设计有一个朴素的理念,就是：通过加机器就可以解决容量和可用性问题。(如果一台不行那就两台)。</li></ul><h1 id="简单讲一下-webservice-使用的场景"><a href="#简单讲一下-webservice-使用的场景" class="headerlink" title="简单讲一下 webservice 使用的场景"></a>简单讲一下 webservice 使用的场景</h1><ul><li>webservice 是一个 SOA(面向服务的编程)的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过 Internet 进行基于 http 协议的网络应用间的交互。</li><li>异构系统(不同的开发语言)的整合</li><li>不同客户端的整合 (浏览器、手机端(android\ios)、微信)</li><li>实实在在的例子：天气预报：可以通过实现 webservice 客户端调用远程天气服务实现的</li><li>单点登录：一个服务实现所有系统的登录</li></ul><h1 id="什么是-VSFTPD？"><a href="#什么是-VSFTPD？" class="headerlink" title="什么是 VSFTPD？"></a>什么是 VSFTPD？</h1><ul><li>vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。</li><li>vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX 等系统上面，是一个完全免费的、开放源代码的 ftp 服务器软件，支持很多其他的 FTP 服务器所不支持的特征。</li></ul><h1 id="项目的生命周期"><a href="#项目的生命周期" class="headerlink" title="项目的生命周期"></a>项目的生命周期</h1><ul><li>需求分析</li><li>概要设计</li><li>详细设计(用例图，流程图，类图)</li><li>数据库设计(powerdesigner)</li><li>代码开发（编写）</li><li>单元测试（junit 白盒测试）(开发人员) svn版本管理工具(提交，更新代码，文档)</li><li>集成测试 （黑盒测试，loadrunner（编写测试脚本）(高级测试)）</li><li>上线试运行 （用户自己体验）</li><li>压力测试（loadrunner）</li><li>正式上线</li><li>维护</li></ul><h1 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h1><ul><li>CND 一般包含分发服务系统、负载均衡系统和管理系统</li></ul><h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><ul><li>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。</li><li>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。</li><li>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。</li></ul><h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><ul><li>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</li><li>使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。</li><li>GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现。</li><li>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个 Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。</li></ul><h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><ul><li>分为运营管理和网络管理子系统。</li><li>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。</li><li>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。包括用户管理、产品管理、计费管理、统计分析等。</li></ul><h1 id="RMI-实现方式"><a href="#RMI-实现方式" class="headerlink" title="RMI 实现方式"></a>RMI 实现方式</h1><ul><li>Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用</li><li>实现步骤<ul><li>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</li><li>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</li><li>运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类;</li><li>启动一个 RMI 注册表，以便驻留这些服务;</li><li>在 RMI 注册表中注册服务；</li><li>客户端查找远程对象，并调用远程方法；<ul><li>创建远程接口，继承 java.rmi.Remote 接口</li><li>实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类</li><li>生成 Stub 和 Skeleton;</li><li>执行 rmiregistry 命令注册服务</li><li>启动服务</li><li>客户端调用</li></ul></li></ul></li></ul><h1 id="什么是微服务中的反应性扩展？"><a href="#什么是微服务中的反应性扩展？" class="headerlink" title="什么是微服务中的反应性扩展？"></a>什么是微服务中的反应性扩展？</h1><ul><li>Reactive Extensions 也称为 Rx</li><li>这是一种设计方法，我们通过调用多个服务来收集结果，然后编译组合响应</li><li>这些调用可以是同步或异步，阻塞或非阻塞。Rx是分布式系统中非常流行的工具，与传统流程相反。</li></ul><h1 id="我们可以用微服务创建状态机吗？"><a href="#我们可以用微服务创建状态机吗？" class="headerlink" title="我们可以用微服务创建状态机吗？"></a>我们可以用微服务创建状态机吗？</h1><ul><li>我们知道拥有自己的数据库的每个微服务都是一个可独立部署的程序单元，这反过来又让我们可以创建一个状态机。因此，我们可以为特定的微服务指定不同的状态和事件。</li><li>例如，我们可以定义 Order 微服务。订单可以具有不同的状态。Order 状态的转换可以是 Order 微服务中的独立事件。</li></ul><h1 id="架构师在微服务架构中的角色是什么？"><a href="#架构师在微服务架构中的角色是什么？" class="headerlink" title="架构师在微服务架构中的角色是什么？"></a>架构师在微服务架构中的角色是什么？</h1><ul><li>微服务架构中的架构师扮演以下角色：<ul><li>决定整个软件系统的布局。</li><li>帮助确定组件的分区。因此，他们确保组件相互粘合，但不紧密耦合。</li><li>与开发人员共同编写代码，了解日常生活中面临的挑战。</li><li>为开发微服务的团队提供某些工具和技术的建议。</li><li>提供技术治理，以便技术开发团队遵循微服务原则。</li></ul></li></ul><h1 id="什么是持续监测？"><a href="#什么是持续监测？" class="headerlink" title="什么是持续监测？"></a>什么是持续监测？</h1><ul><li>持续监控深入监控覆盖范围，从浏览器内前端性能指标，到应用程序性能，再到主机虚拟化基础架构指标。</li></ul><h1 id="什么是金丝雀释放？"><a href="#什么是金丝雀释放？" class="headerlink" title="什么是金丝雀释放？"></a>什么是金丝雀释放？</h1><ul><li>Canary Releasing 是一种降低在生产中引入新软件版本的风险的技术。这是通过将变更缓慢地推广到一小部分用户，然后将其发布到整个基础架构，即将其提供给每个人来完成的。</li></ul><h1 id="什么是持续集成（CI）？"><a href="#什么是持续集成（CI）？" class="headerlink" title="什么是持续集成（CI）？"></a>什么是持续集成（CI）？</h1><ul><li>持续集成（CI）是每次团队成员提交版本控制更改时自动构建和测试代码的过程。</li><li>这鼓励开发人员通过在每个小任务完成后将更改合并到共享版本控制存储库来共享代码和单元测试。</li></ul><h1 id="您对-Mike-Cohn-的测试金字塔了解多少？"><a href="#您对-Mike-Cohn-的测试金字塔了解多少？" class="headerlink" title="您对 Mike Cohn 的测试金字塔了解多少？"></a>您对 Mike Cohn 的测试金字塔了解多少？</h1><ul><li>Mike Cohn 提供了一个名为 Test Pyramid 的模型。这描述了软件开发所需的自动化测试类型。</li><li>根据金字塔，第一层的测试数量应该最高。在服务层，测试次数应小于单元测试级别，但应大于端到端级别。</li></ul><h1 id="Mock-或-Stub-有什么区别？"><a href="#Mock-或-Stub-有什么区别？" class="headerlink" title="Mock 或 Stub 有什么区别？"></a>Mock 或 Stub 有什么区别？</h1><ul><li>存根<ul><li>一个有助于运行测试的虚拟对象。</li><li>在某些可以硬编码的条件下提供固定行为。</li><li>永远不会测试存根的任何其他行为。</li></ul></li><li>例如，对于空堆栈，您可以创建一个只为 empty（）方法返回 true 的存根。因此，这并不关心堆栈中是否存在元素。</li><li>嘲笑<ul><li>一个虚拟对象，其中最初设置了某些属性。</li><li>此对象的行为取决于 set 属性。</li><li>也可以测试对象的行为。</li></ul></li><li>例如，对于 Customer 对象，您可以通过设置名称和年龄来模拟它。您可以将 age设置为 12，然后测试 isAdult（）方法，该方法将在年龄大于 18 时返回 true。因此，您的 Mock Customer 对象适用于指定的条件。</li></ul><h1 id="我们如何在测试中消除非决定论？"><a href="#我们如何在测试中消除非决定论？" class="headerlink" title="我们如何在测试中消除非决定论？"></a>我们如何在测试中消除非决定论？</h1><ul><li>非确定性测试（NDT）基本上是不可靠的测试。所以，有时可能会发生它们通过，显然有时它们也可能会失败。当它们失败时，它们会重新运行通过。</li><li>从测试中删除非确定性的一些方法如下：<ul><li>隔离</li><li>异步</li><li>远程服务</li><li>隔离</li><li>时间</li><li>资源泄漏</li></ul></li></ul><h1 id="负载均衡反向代理模式优点及缺点"><a href="#负载均衡反向代理模式优点及缺点" class="headerlink" title="负载均衡反向代理模式优点及缺点"></a>负载均衡反向代理模式优点及缺点</h1><ul><li>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</li><li>反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。</li><li>反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有此优点）。</li><li>其缺点主要表现在以下两个方面<ul><li>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器的负载均衡。</li><li>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。</li></ul></li><li>般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点进行负载均衡，如 search 等。</li></ul><h1 id="大型网站在架构上应当考虑哪些问题？"><a href="#大型网站在架构上应当考虑哪些问题？" class="headerlink" title="大型网站在架构上应当考虑哪些问题？"></a>大型网站在架构上应当考虑哪些问题？</h1><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><ul><li>分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI&#x2F;RM）和 Internet 的 TCP&#x2F;IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</li></ul><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><ul><li>分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</li></ul><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><ul><li>除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce分布式计算框架来处理。</li></ul><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><ul><li>集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。</li></ul><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</li></ul><h4 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h4><ul><li>各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</li></ul><h1 id="正向代理（客户端代理）和反向代理（服务器端代理）"><a href="#正向代理（客户端代理）和反向代理（服务器端代理）" class="headerlink" title="正向代理（客户端代理）和反向代理（服务器端代理）*"></a>正向代理（客户端代理）和反向代理（服务器端代理）*</h1><ul><li>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<ul><li>访问原来无法访问的资源，如google</li><li>可以做缓存，加速访问资源</li><li>对客户端访问授权，上网进行认证</li><li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li></ul></li><li>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<ul><li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li><li>负载均衡，通过反向代理服务器来优化网站的负载</li></ul></li><li>nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。</li></ul><h1 id="如何实现分布式Session"><a href="#如何实现分布式Session" class="headerlink" title="如何实现分布式Session"></a>如何实现分布式Session</h1><ul><li>基于数据库的Session共享</li><li>基于NFS共享文件系统</li><li>基于memcached 的session，如何保证 memcached 本身的高可用性？</li><li>基于resin&#x2F;tomcat web容器本身的session复制机制</li><li>基于TT&#x2F;Redis 或 jbosscache 进行 session 共享。</li><li>基于cookie 进行session共享</li></ul><h1 id="CAP-理论和-BASE-理论"><a href="#CAP-理论和-BASE-理论" class="headerlink" title="CAP 理论和 BASE 理论"></a>CAP 理论和 BASE 理论</h1><ul><li>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</li><li>基本可用（Basically Available）</li><li>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</li><li>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</li><li>软状态（ Soft State）</li><li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</li><li>最终一致性（ Eventual Consistency）</li><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul><h1 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h1><ul><li>c是指client，而10k则是一万的意思。c10k就是单机同时并发一万个请求。同理c100k则是同时并发十万个请求，如今百万请求也十分常见了。</li></ul><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><ul><li>一致性哈希算法在1997年由麻省理工学院提出,是一种特殊的哈希算法,目的是解决分布式缓存的问题。 [1] 在移除或者添加一个服务器时,能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table,DHT) 中存在的动态伸缩等问题</li></ul><h1 id="DDD设计模式"><a href="#DDD设计模式" class="headerlink" title="DDD设计模式"></a>DDD设计模式</h1><ul><li>领域驱动设计原则:DDD倡导将领域模型作为核心设计元素,通过使用领域模型中的领域对象、值对象和领域服务来解决问题</li></ul><h1 id="消息中间件选型要点"><a href="#消息中间件选型要点" class="headerlink" title="消息中间件选型要点"></a>消息中间件选型要点</h1><h2 id="功能维度"><a href="#功能维度" class="headerlink" title="功能维度"></a>功能维度</h2><ul><li>优先级队列<ul><li>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证</li><li>优先级也是需要有一个前提的，生产者的速度大于消费者的速度，否则，生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的</li></ul></li><li>延迟队列<ul><li>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”，这个是延迟队列的一种典型应用场景。</li><li>延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</li><li>延迟队列一般分为两种：<ul><li>基于消息的延迟，是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。</li><li>基于队列的延迟，实际应用中大多采用这种，设置不同延迟级别的队列，比如5s、10s、30s、1min、5mins、10mins等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略(比如定时)即可投递超时的消息。</li></ul></li></ul></li><li>死信队列<ul><li>由于某些原因消息无法被正确投递，为了确保消息不会被无故丢弃，一般将其置于一个特殊角色的队列，这个队列称为死信队列。</li><li>与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认(Ack), 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。</li><li>为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</li></ul></li><li>重试队列<ul><li>其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。</li><li>与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。</li><li>举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息。</li><li>如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。</li><li>以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。</li><li>重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发;延迟队列作用一次，而重试队列的作用范围会向后传递。</li></ul></li><li>消费模式<ul><li>消费模式分为推(push)模式和拉(pull)模式：<ul><li>推模式，是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。</li><li>拉模式，是指消费端主动向 Broker 端请求拉取(一般是定时或者定量)消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。</li></ul></li></ul></li><li>广播消费<ul><li>消息一般有两种传递模式——点对点(P2P，Point-to-Point)模式和发布&#x2F;订阅(Pub&#x2F;Sub)模式：</li><li>对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。</li><li>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题(Topic)，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。</li><li>主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布&#x2F;订阅模式在消息的一对多广播时采用。</li><li>RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。</li><li>但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组(Consumer Group)的概念看成是队列的概念。</li><li>不过对比来说，Kafka 中因为有了消息回溯功能的存在，对于广播消费的力度支持比 RabbitMQ 的要强。</li></ul></li><li>消息回溯<ul><li>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息</li><li>消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。</li><li>对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失，一般很难追查。</li><li>如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头所在。</li><li>消息回溯的作用远不止于此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。</li></ul></li><li>消息堆积+持久化<ul><li>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。</li><li>从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。</li><li>消息堆积分内存式堆积和磁盘式堆积：</li><li>RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘(换页动作会影响吞吐)，或者直接使用惰性队列来将消息直接持久化至磁盘中。</li><li>Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。</li><li>一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。</li><li>从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引《纽约时报》的案例，其直接将 Kafka 用作存储系统。</li></ul></li><li>消息追踪<ul><li>对于分布式架构系统中的链路追踪(Trace)，大家一定不陌生</li><li>对于消息中间件，消息的链路追踪(以下简称消息追踪)同样重要，最通俗来理解，就是要知道消息从哪来，存在哪里以及发往哪里去。</li><li>基于此功能，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。</li></ul></li><li>消息过滤<ul><li>消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。</li><li>就以 Kafka 而言，完全可以将不同类别的消息发送至不同的 Topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 Topic 中的消息进行分类。</li><li>不过，更加严格意义上的消息过滤，应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。</li><li>同样以 Kafka 为例，可以通过客户端提供的 Consumer Interceptor 接口或者 Kafka Stream 的 Filter 功能进行消息过滤。</li></ul></li><li>多租户<ul><li>也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。</li><li>RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 VHost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。</li><li>VHost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。</li></ul></li><li>多协议支持<ul><li>消息是信息的载体，为了让生产者和消费者都能理解所承载的信息(生产者需要知道如何构造消息，消费者需要知道如何解析消息)，它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。</li><li>有效的消息一定具有某种格式，而没有格式的消息是没有意义的。</li><li>一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等(消息领域中的 JMS 更多的是一个规范而不是一个协议)，支持的协议越多其应用范围就会越广，通用性越强。</li><li>比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。</li></ul></li><li>跨语言支持<ul><li>对很多公司而言，其技术栈体系中会有多种编程语言，如 C&#x2F;C++、Java、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。</li><li>跨语言的支持力度也从侧面反映出一个消息中间件的流行程度。</li></ul></li><li>流量控制<ul><li>针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应</li><li>通常的流控方法有 Stop-and-Wait、滑动窗口以及令牌桶等。</li></ul></li><li>消息顺序性<ul><li>顾名思义，是指保证消息有序</li><li>这个功能有个很常见的应用场景就是 CDC(Change Data Chapture)。</li><li>以 MySQL 为例，如果其传输的 Binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1，造成数据不一致。</li></ul></li><li>安全机制<ul><li>在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制：<ul><li>身份认证，是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制。</li><li>权限控制，是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。</li></ul></li><li>对于 RabbitMQ 而言，其同样提供身份认证(TLS&#x2F;SSL、SASL)和权限控制(读写操作)的安全机制。</li></ul></li><li>消息幂等性<ul><li>确保消息在生产者和消费者之间进行传输，一般有三种传输保障(Delivery Guarantee)：<ul><li>At most once，至多一次，消息可能丢失，但绝不会重复传输。</li><li>At least once，至少一次，消息绝不会丢，但是可能会重复。</li><li>Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。</li></ul></li><li>对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</li><li>Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等。</li><li>而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS(Exactly Once Semantic)的能力。</li><li>不过如果要考虑全局的幂等，还需要从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。</li><li>以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法由消息中间件层面来保证的。</li><li>如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。</li></ul></li><li>事务性消息<ul><li>事务本身是一个并不陌生的词汇，事务是由事务开始(Begin Transaction)和事务结束(End Transaction)之间执行的全体操作组成。</li><li>支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。</li><li>消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。</li></ul></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li>功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度，有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得。<br>K- afka 在开启幂等、事务功能的时候会使其性能降低;RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大影响其性能。</li><li>性能指什么?<ul><li>消息中间件的性能一般是指其吞吐量</li><li>虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级。</li><li>一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。</li><li>注明：消息中间件的吞吐量始终会受到硬件层面的限制。就以网卡带宽为例，如果单机单网卡的带宽为 1Gbps，如果要达到百万级的吞吐，那么消息体大小不得超过(1Gb&#x2F;8)&#x2F;100W，即约等于 134B。</li><li>换句话说如果消息体大小超过 134B，那么就不可能达到百万级别的吞吐。这种计算方式同样可以适用于内存和磁盘。</li></ul></li><li>性能的指标是什么?<ul><li>时延作为性能维度的一个重要指标，却往往在消息中间件领域被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。</li><li>消息中间件具备消息堆积的能力，消息堆积越大也就意味着端到端的时延也就越长，与此同时延时队列也是某些消息中间件的一大特色。那么为什么还要关注消息中间件的时延问题呢?</li><li>消息中间件能够解耦系统，对于一个时延较低的消息中间件而言，它可以让上游生产者发送消息之后可以迅速的返回，也可以让消费者更加快速的获取到消息，在没有堆积的情况下，可以让整体上下游的应用之间的级联动作更加高效。</li><li>虽然不建议在时效性很高的场景下使用消息中间件，但是如果所使用的消息中间件的时延方面比较优秀，那么对于整体系统的性能将会是一个不小的提升。</li></ul></li></ul><h2 id="可靠性-可用性"><a href="#可靠性-可用性" class="headerlink" title="可靠性+可用性"></a>可靠性+可用性</h2><ul><li>消息丢失是使用消息中间件时所不得不面对的一个痛点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素</li><li>尤其是在金融支付领域，消息可靠性尤为重要。</li><li>然而说到可靠性必然要说到可用性，注意这两者之间的区别：<ul><li>可靠性是指对消息不丢失的保障程度。</li><li>可用性是指无故障运行的时间百分比，通常用几个 9 来衡量。</li></ul></li><li>从狭义的角度来说，分布式系统架构是一致性协议理论的应用实现，对于消息可靠性和可用性而言也可以追溯到消息中间件背后的一致性协议：<ul><li>对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，通过 ISR(In-Sync-Replica)来保证多副本之间的同步，并且支持强一致性语义(通过 Acks 实现)。</li><li>对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。</li></ul></li><li>多副本可以保证在 Master 节点宕机异常之后可以提升 Slave 作为新的 Master 而继续提供服务来保障可用性。</li><li>Kafka 设计之初是为日志处理而生，给人们留下了数据可靠性要求不高的不良印象，但是随着版本的升级优化，其可靠性得到极大的增强，详细可以参考 KIP101。</li><li>就目前而言，在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多，随着 RabbitMQ 性能的不断提升和 Kafka 可靠性的进一步增强，相信彼此都能在以前不擅长的领域分得一杯羹。</li><li>同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘。</li><li>但是笔者对同步刷盘有一定的疑问：绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。</li><li>这里还要提及的一个方面是扩展能力，这里我狭隘地将此归纳到可用性这一维度，消息中间件的扩展能力能够增强其可用能力及范围，比如前面提到的 RabbitMQ 支持多种消息协议，这个就是基于其插件化的扩展实现。</li><li>还有从集群部署上来讲，归功于 Kafka 的水平扩展能力，其基本上可以达到线性容量提升的水平，在 LinkedIn 实践介绍中就提及了有部署超过千台设备的 Kafka 集群。</li></ul><h2 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h2><ul><li>在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复?</li><li>业务线流量有峰值有低谷，尤其是电商领域，那么怎样进行有效的容量评估，尤其是大促期间?脚踢电源、网线被挖等事件层出不穷，如何有效的做好异地多活?</li><li>这些都离不开消息中间件的衍生产品——运维管理。运维管理也可以进行进一步的细分，比如申请、审核、监控、告警、管理、容灾、部署等。</li><li>申请、审核很好理解，在源头对资源进行管控，既可以有效校正应用方的使用规范，配合监控也可以做好流量统计与流量评估工作。</li><li>一般申请、审核与公司内部系统交融性较大，不适合使用开源类的产品。</li><li>监控、告警也比较好理解，对消息中间件的使用进行全方位的监控，既可以为系统提供基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。</li><li>除了一般的监控项(比如硬件、GC 等)之外，消息中间件还需要关注端到端时延、消息审计、消息堆积等方面：</li><li>对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，但是社区内还有 AppDynamics、Collectd、DataDog、Ganglia、Munin、Nagios、New Relic、Prometheus、Zenoss 等多种优秀的产品。</li><li>Kafka 在此方面也毫不逊色，比如：Kafka Manager、Kafka Monitor、Kafka Offset Monitor、Burrow、Chaperone、Confluent Control Center 等产品，尤其是 Cruise 还可以提供自动化运维的功能。</li><li>不管是扩容、降级、版本升级、集群节点部署、还是故障处理都离不开管理工具的应用，一个配套完备的管理工具集可以在遇到变更时做到事半功倍。</li><li>故障可大可小，一般是一些应用异常，也可以是机器掉电、网络异常、磁盘损坏等单机故障，这些故障单机房内的多副本足以应付。</li><li>如果是机房故障就要涉及异地容灾了，关键点在于如何有效的进行数据复制，Kafka 可以参考 MirrorMarker、uReplicator 等产品，而 RabbitMQ 可以参考 Federation 和 Shovel。</li></ul><h2 id="社区力度及生态发展"><a href="#社区力度及生态发展" class="headerlink" title="社区力度及生态发展"></a>社区力度及生态发展</h2><ul><li>对于目前流行的编程语言而言，如 Java、Python，如果你在使用过程中遇到了一些异常，基本上可以通过搜索引擎的帮助来得到解决，因为一个产品用的人越多，踩过的坑也就越多，对应的解决方案也就越多。</li><li>消息中间件也同样适用，如果你选择了一种“生僻”的消息中间件，可能在某些方面运用的得心应手，但是版本更新缓慢、遇到棘手问题也难以得到社区的支持而越陷越深。</li><li>相反如果你选择了一种“流行”的消息中间件，其更新力度大，不仅可以迅速的弥补之前的不足，而且也能顺应技术的快速发展来变更一些新的功能，这样可以让你也“站在巨人的肩膀上”。</li><li>在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。</li></ul><h2 id="消息中间件选型误区总结"><a href="#消息中间件选型误区总结" class="headerlink" title="消息中间件选型误区总结"></a>消息中间件选型误区总结</h2><ul><li>选型误区<ul><li>选型之前可以先问自己一个问题：是否真的需要一个消息中间件?</li><li>在搞清楚这个问题之后，还可以继续问自己一个问题：是否需要自己维护一套消息中间件?</li><li>很多初创型公司为了节省成本会选择直接购买消息中间件有关的云服务，自己只需要关注收发消息即可，其余的都可以外包出去。</li><li>很多人面对消息中间件有一种自研的冲动，你完全可以对 Java 中的 ArrayBlockingQueue 做一个简单的封装，你也可以基于文件、数据库、Redis 等底层存储封装而形成一个消息中间件。</li><li>消息中间件做为一个基础组件并没有想象中的那么简单，其背后还需要配套的管理运维整个生态的产品集。</li><li>自研还会有交接问题，如果文档不齐全、运作不规范将会带给新人噩梦般的体验。</li><li>是否真的有自研的必要?如果不是 KPI 的压迫可以先考虑下面这两个问题：<ul><li>目前市面上的消息中间件是否都真的无法满足目前的业务需求?</li><li>团队是否有足够的能力、人力、财力、精力来支持自研?</li></ul></li><li>很多人在做消息中间件选型时会参考网络上的很多对比类的文章，但是其专业性、严谨性、以及其政治立场问题都有待考证，需要带着怀疑的态度去审视这些文章。</li><li>比如有些文章会在没有任何限定条件及场景的情况下直接定义某款消息中间件最好。</li><li>还有些文章没有指明消息中间件版本及测试环境就来做功能和性能对比分析，诸如此类的文章都可以唾弃之。</li><li>消息中间件犹如小马过河，选择合适的才最重要。这需要贴合自身的业务需求，技术服务于业务，大体上可以根据上一节所提及的功能、性能等 6 个维度来一一进行筛选。更深层次的抉择在于你能否掌握其魂。</li><li>笔者鄙见：RabbitMQ 在于 Routing，而 Kafka 在于 Streaming，了解其根本对于自己能够对症下药选择到合适的消息中间件尤为重要。</li><li>消息中间件选型切忌一味的追求性能或者功能，性能可以优化，功能可以二次开发。</li><li>如果要在功能和性能方面做一个抉择的话，那么首选性能，因为总体上来说性能优化的空间没有功能扩展的空间大。然而看长期发展，生态又比性能以及功能都要重要。</li></ul></li><li>可靠性误区<ul><li>很多时候，可靠性方面也容易存在一个误区：想要找到一个产品来保证消息的绝对可靠，很不幸的是这世界上没有绝对的东西，只能说尽量趋于完美。</li><li>想要尽可能的保障消息的可靠性也并非单单只靠消息中间件本身，还要依赖于上下游，需要从生产端、服务端和消费端这 3 个维度去努力保证。</li><li>消息中间件选型还有一个考量标准就是尽量贴合团队自身的技术栈体系，虽然说没有蹩脚的消息中间件，只有蹩脚的程序员，但是让一个 C 栈的团队去深挖 PhxQueue 总比去深挖 Scala 编写的 Kafka 要容易的多。</li><li>消息中间件大道至简：一发一存一消费，没有最好的消息中间件，只有最合适的消息中间件</li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/ELK/" rel="tag"><i class="fa fa-tag"></i> ELK</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/73098ee3eeb0.html" rel="prev" title="集合"><i class="fa fa-angle-left"></i> 集合</a></div><div class="post-nav-item"><a href="/publishes/b1378143ed59.html" rel="next" title="Hibernate">Hibernate <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">450k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:49</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>