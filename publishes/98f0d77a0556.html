<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="说⼀下⼏种常⻅的排序算法和分别的复杂度快速排序 原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了. 选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。 基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="说⼀下⼏种常⻅的排序算法和分别的复杂度快速排序 原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了. 选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。 基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:35:25.000Z"><meta property="article:modified_time" content="2023-12-26T12:27:05.624Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/98f0d77a0556.html","path":"publishes/98f0d77a0556.html","title":"数据结构与算法"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>数据结构与算法 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E2%BC%80%E4%B8%8B%E2%BC%8F%E7%A7%8D%E5%B8%B8%E2%BB%85%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%86%E5%88%AB%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">说⼀下⼏种常⻅的排序算法和分别的复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E2%BC%8A%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">直接插⼊排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">直接选择排序：</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E2%BC%80%E4%B8%8B%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">描述⼀下链式存储结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E2%BC%80%E9%A2%97%E2%BC%86%E5%8F%89%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">如何遍历⼀颗⼆叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%92%E6%8E%92%E2%BC%80%E4%B8%AALinkedList"><span class="nav-number">4.</span> <span class="nav-text">倒排⼀个LinkedList</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BD%A4java%E5%86%99%E2%BC%80%E4%B8%AA%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E2%BD%AC%E5%BD%95%E4%B8%8B%E2%BE%AF%E7%9A%84%E6%89%80%E6%9C%89%E2%BD%82%E4%BB%B6"><span class="nav-number">5.</span> <span class="nav-text">⽤java写⼀个递归遍历⽬录下⾯的所有⽂件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BC%86%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E2%BF%8A%E6%A0%91%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">⼆叉树与红⿊树：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%BC%86%E5%8F%89%E6%A0%91"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">⼆叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E2%BF%8A%E6%A0%91"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">红⿊树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#b-tree%E3%80%81b-tree%E5%A4%9A%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">b-tree、b+tree多叉树：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#b-tree"><span class="nav-number">7.0.0.1.</span> <span class="nav-text">b-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-tree-1"><span class="nav-number">7.0.0.2.</span> <span class="nav-text">b+tree</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E2%BD%90%E5%A6%82TreeMap%EF%BC%9A"><span class="nav-number">8.</span> <span class="nav-text">谈谈数据结构，⽐如TreeMap：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E5%92%8C%E2%BC%B4%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="nav-number">9.</span> <span class="nav-text">图的深度遍历和⼴度遍历</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4java%E9%9B%86%E5%90%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8B%E2%BE%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E5%8F%8A%E5%85%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">10.</span> <span class="nav-text">说说java集合，每个集合下⾯有哪些实现类，及其数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">10.0.0.1.</span> <span class="nav-text">HashMap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AE%80%E4%BB%8B"><span class="nav-number">11.</span> <span class="nav-text">红黑树简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">11.0.0.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">11.0.0.2.</span> <span class="nav-text">红黑树的性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">11.0.0.3.</span> <span class="nav-text">红黑树的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">11.0.0.3.1.</span> <span class="nav-text">插入操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">11.0.0.3.2.</span> <span class="nav-text">删除操作</span></a></li></ol></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">26</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="数据结构与算法 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据结构与算法</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:35:25" itemprop="dateCreated datePublished" datetime="2023-12-20T15:35:25+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-26 20:27:05" itemprop="dateModified" datetime="2023-12-26T20:27:05+08:00">2023-12-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说⼀下⼏种常⻅的排序算法和分别的复杂度"><a href="#说⼀下⼏种常⻅的排序算法和分别的复杂度" class="headerlink" title="说⼀下⼏种常⻅的排序算法和分别的复杂度"></a>说⼀下⼏种常⻅的排序算法和分别的复杂度</h1><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li>原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了.<ul><li>选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。</li><li>基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的分在右边。</li><li>可以肯定，如此⼀轮下来，这个枢轴的位置⼀定在最终位置上。</li><li>对两个⼦数组分别重复上述过程，直到每个数组只有⼀个元素。</li><li>排序完成。</li></ul></li><li>复杂度：O(n)</li><li>特点：快速排序是我们平常最常使⽤的⼀种排序算法,因为它速度快,效率⾼,是最优秀的⼀种排序算法.</li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li>原理：冒泡排序其实就是逐⼀⽐较交换,进⾏⾥外两次循环,外层循环为遍历所有数字,逐个确定每个位置,⾥层循环为确定了位置后,遍历所有后⾯没有确定位置的数字,与该位置的数字进⾏⽐较,只要⽐该位置的数字⼩,就和该位置的数字进⾏交换.</li><li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li><li>特点：冒泡排序在我们实际开发中,使⽤的还是⽐较少的.它更加适合数据规模⽐较少的时候,因为它的效率是⽐较低的,但是优点是逻辑简单,容易让我们记得.</li></ul><h4 id="直接插⼊排序"><a href="#直接插⼊排序" class="headerlink" title="直接插⼊排序"></a>直接插⼊排序</h4><ul><li>原理：直接插⼊排序是将从第⼆个数字开始,逐个拿出来,插⼊到之前排好序的数列⾥.</li><li>复杂度：O(n^2)，最佳时间复杂度为O(n)</li></ul><h4 id="直接选择排序："><a href="#直接选择排序：" class="headerlink" title="直接选择排序："></a>直接选择排序：</h4><ul><li>原理：直接选择排序是从第⼀个位置开始遍历位置,找到剩余未排序的数据⾥最⼩的,找到最⼩的后,再做交换</li><li>复杂度：O(n^2)</li><li>特点：和冒泡排序⼀样,逻辑简单,但是效率不⾼,适合少量的数据排序</li></ul><h1 id="描述⼀下链式存储结构"><a href="#描述⼀下链式存储结构" class="headerlink" title="描述⼀下链式存储结构"></a>描述⼀下链式存储结构</h1><ul><li>线性结构的优点是可以实现随机读取，时间复杂度为O(1)，空间利⽤率⾼，缺点是进⾏插⼊和删除操作时⽐较麻烦，时间复杂度为O(n)，同时容量受限制，需要事先确定容量⼤⼩，容量过⼤，浪费空间资源，过⼩不能满⾜使⽤要求，会产⽣溢出问题。</li><li>链式存储结构的优点主要是插⼊和删除⾮常简单，前提条件是知道操作位置，时间复杂度是O(1)，但如果不知道操作位置则要定位元素，时间复杂度为O(n)，没有容量的限制，可以使⽤过程中动态分配的分配内存空间，不⽤担⼼溢出问题，但是它并不能实现随机读取，同时空间利⽤率不⾼。</li></ul><h1 id="如何遍历⼀颗⼆叉树"><a href="#如何遍历⼀颗⼆叉树" class="headerlink" title="如何遍历⼀颗⼆叉树"></a>如何遍历⼀颗⼆叉树</h1><ul><li>先输出节点的值，再递归遍历左右⼦树。中序和后序的递归类似，改变根节点输出位置即可。</li></ul><h1 id="倒排⼀个LinkedList"><a href="#倒排⼀个LinkedList" class="headerlink" title="倒排⼀个LinkedList"></a>倒排⼀个LinkedList</h1><ul><li>Collections.reverse(linkedList);</li></ul><h1 id="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"><a href="#⽤java写⼀个递归遍历⽬录下⾯的所有⽂件" class="headerlink" title="⽤java写⼀个递归遍历⽬录下⾯的所有⽂件"></a>⽤java写⼀个递归遍历⽬录下⾯的所有⽂件</h1><ul><li>File.listFiles()</li></ul><h1 id="⼆叉树与红⿊树："><a href="#⼆叉树与红⿊树：" class="headerlink" title="⼆叉树与红⿊树："></a>⼆叉树与红⿊树：</h1><h4 id="⼆叉树"><a href="#⼆叉树" class="headerlink" title="⼆叉树"></a>⼆叉树</h4><ul><li>左⼦树上所有结点的值均⼩于或等于它的根结点的值。</li><li>右⼦树上所有结点的值均⼤于或等于它的根结点的值。</li><li>左、右⼦树也分别为⼆叉排序树。</li><li>查找：⼆分查找（通过⼀层⼀层的⽐较⼤⼩来查找位置）：如查找值为10的节点：9–13–11–10</li><li>缺陷：插⼊容易变成线性形态，查找性能⼤打折扣，这时需要引⼊红⿊树来解决</li></ul><h4 id="红⿊树"><a href="#红⿊树" class="headerlink" title="红⿊树"></a>红⿊树</h4><ul><li>特点：是⼀种⾃平衡的⼆叉查找树，除了符合⼆叉树的特点之外，还符合以下⼏点：<ul><li>节点是红⾊或⿊⾊。</li><li>根节点是⿊⾊。</li><li>每个叶⼦节点都是⿊⾊的空节点（NIL节点）。</li><li>每个红⾊节点的两个⼦节点都是⿊⾊。(从每个叶⼦到根的所有路径上不能有两个连续的红⾊节点)</li><li>从任⼀节点到其每个叶⼦的所有路径都包含相同数⽬的⿊⾊节点。</li></ul></li><li>这些规则保证了红⿊树的⾃平衡。</li><li>红⿊树从根到叶⼦的最长路径不会超过最短路径的2倍。</li><li>提⾼寻址效率。</li><li>添加删除：通过⾃旋来保证平衡</li></ul><h1 id="b-tree、b-tree多叉树："><a href="#b-tree、b-tree多叉树：" class="headerlink" title="b-tree、b+tree多叉树："></a>b-tree、b+tree多叉树：</h1><h4 id="b-tree"><a href="#b-tree" class="headerlink" title="b-tree"></a>b-tree</h4><ul><li>⽂件系统</li><li>B树也称B-树,它是⼀颗多路平衡查找树</li><li>我们描述⼀颗B树时需要指定它的阶数，阶数表示了⼀个结点最多有多少个孩⼦结点，⼀般⽤字⺟m表示阶数</li><li>当m取2时，就是我们常⻅的⼆叉搜索树。</li><li>定义：<ul><li>每个结点最多有m-1个关键字。</li><li>根结点最少可以只有1个关键字。</li><li>⾮根结点⾄少有Math.ceil(m/2)-1个关键字。</li><li>每个结点中的关键字都按照从⼩到⼤的顺序排列，每个关键字的左⼦树中的所有关键字都⼩于它，⽽右⼦树中的所有关键字都⼤于它。</li><li>所有叶⼦结点都位于同⼀层，或者说根结点到每个叶⼦结点的⻓度都相同。</li></ul></li><li>插⼊数据，向兄弟节点借，兄弟节点不够则向⽗节点借；</li></ul><h4 id="b-tree-1"><a href="#b-tree-1" class="headerlink" title="b+tree"></a>b+tree</h4><ul><li>mysql索引</li><li>定义：<ul><li>B+树包含2种类型的结点：内部结点（也称索引结点）和叶⼦结点。根结点本身即可以是内部结点，也可以是叶⼦结点。根结点的关键字个数最少可以只有1个。</li><li>B+树与B树最⼤的不同是内部结点不保存数据，只⽤于索引，所有数据（或者说记录）都保存在叶⼦结点中。</li><li>m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个⼦树），阶数m同时限制了叶⼦结点最多存储m-1个记录。</li><li>内部结点中的key都按照从⼩到⼤的顺序排列，对于内部结点中的⼀个key，左树中的所有key都⼩于它，右⼦树中的key都⼤于等于它。叶⼦结点中的记录也按照key的⼤⼩排列。</li><li>每个叶⼦结点都存有相邻叶⼦结点的指针，叶⼦结点本身依关键字的⼤⼩⾃⼩⽽⼤顺序链接。</li></ul></li></ul><h1 id="谈谈数据结构，⽐如TreeMap："><a href="#谈谈数据结构，⽐如TreeMap：" class="headerlink" title="谈谈数据结构，⽐如TreeMap："></a>谈谈数据结构，⽐如TreeMap：</h1><ul><li>TreeMap实现了红⿊树的结构。</li></ul><h1 id="图的深度遍历和⼴度遍历"><a href="#图的深度遍历和⼴度遍历" class="headerlink" title="图的深度遍历和⼴度遍历"></a>图的深度遍历和⼴度遍历</h1><ul><li>深度优先遍历：深度优先遍历尽可能优先往深层次进⾏搜索</li><li>⼴度优先遍历：⼴度优先遍历按层次优先搜索最近的结点，⼀层⼀层往外搜索。</li></ul><h1 id="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"><a href="#说说java集合，每个集合下⾯有哪些实现类，及其数据结构" class="headerlink" title="说说java集合，每个集合下⾯有哪些实现类，及其数据结构"></a>说说java集合，每个集合下⾯有哪些实现类，及其数据结构</h1><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li>概念<ul><li>在HashMap内部，采⽤了数组+链表的形式来组织键值对Entry&lt;Key,Value&gt;（利⽤数组的查询快+链表的插⼊删除快）</li><li>HashMap在存储键值对Entry&lt;Key,Value&gt;的时候，会根据Key的hashcode值，以某种映射关系，决定应当将这对键值对Entry&lt;Key,Value&gt;存储在HashMap中的什么位置上</li><li>在JDK1.7进⾏多线程put操作，之后遍历，直接死循环，CPU飙到100%，在JDK 1.8中进⾏多线程操作会出现节点和value值丢失，为什么JDK1.7与JDK1.8多线程操作会出现很⼤不同，是因为JDK 1.8的作者对resize⽅法进⾏了优化不会产⽣链表闭环。</li></ul></li><li>结构</li><li>HashMap扩容<ul><li>很简单的计算：由于默认的加载因⼦是0.75 ，那么，此时map的阀值是 16*0.75 = 12，即添加第13 个键值对&lt;Key,Value&gt;的时候，map的容量会扩充⼀倍。</li><li>确实如此，但是为了尽可能第减少桶中的Entry&lt;Key,Value&gt;链表的长度，以提⾼HashMap的存取性能，确定的这个经验值</li></ul></li><li>扩容步骤：<ul><li>申请⼀个新的、⼤⼩为当前容量两倍的数组；</li><li>将旧数组的Entry[] table中的链表重新计算hash值，然后重新均匀地放置到新的扩充数组中；</li><li>释放旧的数组；</li></ul></li><li>为何扩容为原来的两倍（性能）：<ul><li>在HashMap通过键的哈希值进⾏定位桶位置的时候，调⽤了⼀个indexFor(hash, table.length);⽅法。</li><li>通过限制length是⼀个2的幂数，h &amp; (length-1)和h % length结果是⼀致的。</li><li>如果length是⼀个2的幂的数，那么length-1就会变成⼀个mask, 它会将hashcode低位取出来，</li><li>hashcode的低位实际就是余数，和取余操作相⽐，与操作会将性能提升很多。</li></ul></li><li>put流程<ul><li>获取这个Key的hashcode值，根据此值确定应该将这⼀对键值对存放在哪⼀个桶中，即确定要存放桶的索引；</li><li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul><li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,其中的Value值更新为新的Value值；返回旧值；</li><li>若不存在，则根据键值对&lt;Key,Value&gt; 创建⼀个新的Entry&lt;Key,Value&gt;对象，然后添加到这个桶的Entry&lt;Key,Value&gt;</li></ul></li><li>当前的HashMap的⼤⼩(即Entry&lt;key,Value&gt;节点的数⽬)是否超过了阀值，若超过了阀值(threshold)，</li><li>则增⼤HashMap的容量(即Entry[] table 的⼤⼩)，并且重新组织内部各个Entry&lt;Key,Value&gt;排列。</li></ul></li><li>get流程<ul><li>获取这个Key的hashcode值，根据此hashcode值决定应该从哪⼀个桶中查找；</li><li>遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<ul><li>若已存在，定位到对应的Entry&lt;Key,Value&gt;,返回value</li><li>若不存在，返回null；</li></ul></li></ul></li></ul><h1 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>红黑树是一种自平衡二叉查找树</li><li>它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用</li><li>它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。</li></ul><h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><ul><li>红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡</li><li>它的每个节点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父节点）。</li><li>红黑树的定义也是它的性质，有以下五条：<ul><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色（叶子是NIL节点）</li><li>如果一个节点是红的，则它的两个儿子都是黑的</li><li>从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。</li></ul></li><li>这五个性质强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</li><li>为什么呢？性质4暗示着任何一个简单路径上不能有两个毗连的红色节点，这样，最短的可能路径全是黑色节点，最长的可能路径有交替的红色和黑色节点。同时根据性质5知道：所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</li></ul><h4 id="红黑树的基本操作"><a href="#红黑树的基本操作" class="headerlink" title="红黑树的基本操作"></a>红黑树的基本操作</h4><ul><li>因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同</li><li>然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质</li><li>恢复红黑树的性质需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)</li><li>虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次。</li></ul><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><ul><li>插入操作可以概括为以下几个步骤：<ul><li>查找要插入的位置，时间复杂度为：O(N)</li><li>将新节点的color赋为红色</li><li>自下而上重新调整该树为红黑树</li></ul></li><li>其中，第(1)步的查找方法跟普通二叉查找树一样</li><li>第(2)步之所以将新插入的节点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的</li><li>但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整，这样简单多了</li><li>下面讨论步骤(3)的一些细节：<ul><li>设要插入的节点为N，其父节点为P，其父亲G的兄弟节点为U（即P和U是同一个节点的两个子节点）。</li><li>如果P是黑色的，则整棵树不必调整便是红黑树。</li><li>如果P是红色的（可知，其父节点G一定是黑色的），则插入z后，违背了性质4，需要进行调整</li><li>调整时分以下3种情况：<ul><li>N的叔叔U是红色的</li><li>N的叔叔U是黑色的，且N是右孩子</li><li>N的叔叔U是黑色的，且N是左孩子</li></ul></li></ul></li></ul><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><ul><li>删除操作可以概括为以下几个步骤：<ul><li>查找要删除位置，时间复杂度为：O(N)</li><li>用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点）</li><li>如果删除节点的替换节点为黑色，则需重新调整该树为红黑树</li></ul></li><li>其中，第(1)步的查找方法跟普通二叉查找树一样</li><li>第(2)步之所以用后继节点替换删除节点，是因为这样可以保证该后继节点之上仍是一个红黑树，而后继节点可能是一个叶节点或者只有右子树的节点，这样只需用有节点替换后继节点即可达到删除的目的</li><li>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题</li><li>在第(3)步中，如果，如果删除节点为红色节点，则他的父亲和孩子全为黑节点，这样直接删除该节点即可，不必进行任何调整</li><li>如果删除节点是黑节点，分四种情况：<ul><li>设要删除的节点为N，其父节点为P，其兄弟节点为S。</li><li>由于N是黑色的，则P可能是黑色的，也可能是红色的，S也可能是黑色的或者红色的</li><li>S是红色的</li><li>S和S的孩子全是黑色的</li><li>S是黑色的，S的左孩子是红色，右孩子是黑色</li><li>S是黑色的，S的右孩子是红色</li></ul></li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/e002a9c6759b.html" rel="prev" title="Java web"><i class="fa fa-angle-left"></i> Java web</a></div><div class="post-nav-item"><a href="/publishes/64b56da2b088.html" rel="next" title="面试技巧">面试技巧 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>