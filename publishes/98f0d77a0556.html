<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><meta name="description" content="说⼀下⼏种常⻅的排序算法和分别的复杂度a. 快速排序：i. 原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了. 选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。 基于这个值，将数组分为两部分，较⼩的分"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="说⼀下⼏种常⻅的排序算法和分别的复杂度a. 快速排序：i. 原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了. 选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。 基于这个值，将数组分为两部分，较⼩的分"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:35:25.000Z"><meta property="article:modified_time" content="2023-12-20T07:39:01.683Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/98f0d77a0556.html","path":"publishes/98f0d77a0556.html","title":"数据结构与算法"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>数据结构与算法 | Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java后端面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/98f0d77a0556.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="数据结构与算法 | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据结构与算法</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:35:25 / 修改时间：15:39:01" itemprop="dateCreated datePublished" datetime="2023-12-20T15:35:25+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><ol><li>说⼀下⼏种常⻅的排序算法和分别的复杂度<br>a. 快速排序：<br>i. 原理：快速排序采⽤的是⼀种分治的思想,它先找⼀个基准数（⼀般选择第⼀个值）,然后将⽐这个基准数⼩的数字<br>都放到它的左边,然后再递归调⽤,分别对左右两边快速排序,直到每⼀边只有⼀个数字.整个排序就完成了.</li><li>选定⼀个合适的值（理想情况中值最好，但实现中⼀般使⽤数组第⼀个值）,称为“枢轴”(pivot)。</li><li>基于这个值，将数组分为两部分，较⼩的分在左边，较⼤的分在右边。</li><li>可以肯定，如此⼀轮下来，这个枢轴的位置⼀定在最终位置上。</li><li>对两个⼦数组分别重复上述过程，直到每个数组只有⼀个元素。</li><li>排序完成。<br>ii. 复杂度：O(n)<br>iii. 特点：快速排序是我们平常最常使⽤的⼀种排序算法,因为它速度快,效率⾼,是最优秀的⼀种排序算法.<br>b. 冒泡排序：<br>i. 原理：冒泡排序其实就是逐⼀⽐较交换,进⾏⾥外两次循环,外层循环为遍历所有数字,逐个确定每个位置,⾥层循环<br>为确定了位置后,遍历所有后⾯没有确定位置的数字,与该位置的数字进⾏⽐较,只要⽐该位置的数字⼩,就和该位置的<br>数字进⾏交换.<br>ii. 复杂度：O(n^2)，最佳时间复杂度为O(n)<br>iii. 特点：冒泡排序在我们实际开发中,使⽤的还是⽐较少的.它更加适合数据规模⽐较少的时候,因为它的效率是⽐较<br>低的,但是优点是逻辑简单,容易让我们记得.<br>c. 直接插⼊排序：<br>i. 原理：直接插⼊排序是将从第⼆个数字开始,逐个拿出来,插⼊到之前排好序的数列⾥.<br>ii. 复杂度：O(n^2)，最佳时间复杂度为O(n)<br>iii. 特点：<br>d. 直接选择排序：<br>i. 原理：直接选择排序是从第⼀个位置开始遍历位置,找到剩余未排序的数据⾥最⼩的,找到最⼩的后,再做交换<br>ii. 复杂度：O(n^2)<br>iii. 特点：和冒泡排序⼀样,逻辑简单,但是效率不⾼,适合少量的数据排序</li><li>⽤java写⼀个冒泡排序算法<br>1 public class Test {<br>2 public static void bubbleSort() {<br>3 int a[] = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 5, 4, 62, 99, 98, 54, 56, 17, 18<br>4 int temp;<br>5 for (int i = 0; i &lt; a.length - 1; i++) {<br>6 for (int j = 0; j &lt; a.length - 1 - i; j++) {<br>7 if (a[j] &gt; a[j + 1]) {<br>8 temp = a[j];<br>9 a[j] = a[j + 1];<br>10 a[j + 1] = temp;<br>11 }<br>12 }<br>13 }<br>14 for (int i = 0; i &lt; a.length; i++)<br>15 System.out.println(a[i]);<br>16 }<br>17<br>18 public static void main(String[] args) {<br>19 bubbleSort();<br>20 }<br>21 }</li><li>描述⼀下链式存储结构<br>a. 线性结构的优点是可以实现随机读取，时间复杂度为O(1)，空间利⽤率⾼，缺点是进⾏插⼊和删除操作时⽐较麻烦，<br>时间复杂度为O(n)，同时容量受限制，需要事先确定容量⼤⼩，容量过⼤，浪费空间资源，过⼩不能满⾜使⽤要求，会<br>产⽣溢出问题。<br>b. 链式存储结构的优点主要是插⼊和删除⾮常简单，前提条件是知道操作位置，时间复杂度是O(1)，但如果不知道操作<br>位置则要定位元素，时间复杂度为O(n)，没有容量的限制，可以使⽤过程中动态分配的分配内存空间，不⽤担⼼溢出问<br>题，但是它并不能实现随机读取，同时空间利⽤率不⾼。</li><li>如何遍历⼀颗⼆叉树<br>a. 树节点：<br>1 class TreeNode {<br>2 int val;<br>3 //左⼦树<br>4 TreeNode left;<br>5 //右⼦树<br>6 TreeNode right;<br>7 //构造⽅法<br>8 TreeNode(int x) {<br>9 val = x;<br>10 }<br>11 }<br>b. 递归先序遍历：先输出节点的值，再递归遍历左右⼦树。中序和后序的递归类似，改变根节点输出位置即可。<br>1 // 递归先序遍历<br>2 public static void recursionPreorderTraversal(TreeNode root) {<br>3 if (root != null) {<br>4 System.out.print(root.val + “ “);<br>5 recursionPreorderTraversal(root.left);<br>6 recursionPreorderTraversal(root.right);<br>7 }<br>8 }<br>9 //1 2 4 6 7 8 3 5<br>c. 递归中序遍历：过程和递归先序遍历类似<br>1 // 递归中序遍历<br>2 public static void recursionMiddleorderTraversal(TreeNode root) {<br>3 if (root != null) {<br>4 recursionMiddleorderTraversal(root.left);<br>5 System.out.print(root.val + “ “);<br>6 recursionMiddleorderTraversal(root.right);<br>7 }<br>8 }<br>9 //4 7 6 8 2 1 3 5<br>d. 递归后序遍历：<br>1 // 递归后序遍历<br>2 public static void recursionPostorderTraversal(TreeNode root) {<br>3 if (root != null) {<br>4 recursionPostorderTraversal(root.left);<br>5 recursionPostorderTraversal(root.right);<br>6 System.out.print(root.val + “ “);<br>7 }<br>8 }</li><li>倒排⼀个LinkedList<br>1 Collections.reverse(linkedList);</li><li>⽤java写⼀个递归遍历⽬录下⾯的所有⽂件（directory.listFiles()）<br>1 void listAll(File directory) {<br>2 if (!(directory.exists() &amp;&amp; directory.isDirectory())) {<br>3 throw new RuntimeException(“⽬录不存在”);<br>4 }<br>5<br>6 File[] files = directory.listFiles();<br>7<br>8 for (File file : files) {<br>9 System.out.println(file.getPath() + file.getName());<br>10 if (file.isDirectory()) {<br>11 listAll(file);<br>12 }<br>13 }<br>14 }</li><li>⼆叉树与红⿊树：</li><li>⼆叉树：<br>a. 特性：<br>i. 左⼦树上所有结点的值均⼩于或等于它的根结点的值。<br>ii. 右⼦树上所有结点的值均⼤于或等于它的根结点的值。<br>iii. 左、右⼦树也分别为⼆叉排序树。<br>b. 图例：<br>c. 查找：⼆分查找（通过⼀层⼀层的⽐较⼤⼩来查找位置）：如查找值为10的节点：9–13–11–10<br>d. 缺陷：插⼊容易变成线性形态，查找性能⼤打折扣，这时需要引⼊红⿊树来解决</li><li>红⿊树：<br>a. 特点：是⼀种⾃平衡的⼆叉查找树，除了符合⼆叉树的特点之外，还符合以下⼏点：<br>i. 节点是红⾊或⿊⾊。<br>ii. 根节点是⿊⾊。<br>iii. 每个叶⼦节点都是⿊⾊的空节点（NIL节点）。<br>iv. 每个红⾊节点的两个⼦节点都是⿊⾊。(从每个叶⼦到根的所有路径上不能有两个连续的红⾊节点)<br>v. 从任⼀节点到其每个叶⼦的所有路径都包含相同数⽬的⿊⾊节点。<br>这些规则保证了红⿊树的⾃平衡。<br>红⿊树从根到叶⼦的最长路径不会超过最短路径的2倍。<br>提⾼寻址效率。<br>b. 添加删除：通过⾃旋来保证平衡</li><li>b-tree、b+tree多叉树：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/8729425.html">https://www.cnblogs.com/nullzx/p/8729425.html</a></li><li>b-tree（⽂件系统）：B树也称B-树,它是⼀颗多路平衡查找树。我们描述⼀颗B树时需要指定它的阶数，阶数表示了⼀<br>个结点最多有多少个孩⼦结点，⼀般⽤字⺟m表示阶数。当m取2时，就是我们常⻅的⼆叉搜索树。<br>a. 定义：<br>1）每个结点最多有m-1个关键字。<br>2）根结点最少可以只有1个关键字。<br>3）⾮根结点⾄少有Math.ceil(m/2)-1个关键字。<br>4）每个结点中的关键字都按照从⼩到⼤的顺序排列，每个关键字的左⼦树中的所有关键字都⼩于它，⽽右⼦树<br>中的所有关键字都⼤于它。<br>5）所有叶⼦结点都位于同⼀层，或者说根结点到每个叶⼦结点的⻓度都相同。<br>b. 插⼊数据，向兄弟节点借，兄弟节点不够则向⽗节点借；</li><li>b+tree（mysql索引）：<br>a. 定义：<br>1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶⼦结点。根结点本身即可以是内部结点，也可以<br>是叶⼦结点。根结点的关键字个数最少可以只有1个。<br>2）B+树与B树最⼤的不同是内部结点不保存数据，只⽤于索引，所有数据（或者说记录）都保存在叶⼦结点<br>中。<br>3）m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个⼦树），阶数m同时限制了叶⼦<br>结点最多存储m-1个记录。<br>4）内部结点中的key都按照从⼩到⼤的顺序排列，对于内部结点中的⼀个key，左树中的所有key都⼩于它，右<br>⼦树中的key都⼤于等于它。叶⼦结点中的记录也按照key的⼤⼩排列。<br>5）每个叶⼦结点都存有相邻叶⼦结点的指针，叶⼦结点本身依关键字的⼤⼩⾃⼩⽽⼤顺序链接。</li><li>谈谈数据结构，⽐如TreeMap：<br>TreeMap实现了红⿊树的结构。</li><li>图的深度遍历和⼴度遍历<br>1、深度优先遍历：<br>深度优先遍历结果是： A B E F C D G H I<br>深度优先遍历尽可能优先往深层次进⾏搜索<br>2、⼴度优先遍历：<br>⼴度优先遍历结果是： A B C D E F G H I<br>⼴度优先遍历按层次优先搜索最近的结点，⼀层⼀层往外搜索。</li><li>介绍⼀下红⿊树、⼆叉平衡树</li><li>说说java集合，每个集合下⾯有哪些实现类，及其数据结构。<br>a. HashMap：<br>i. 概念：</li><li>在HashMap内部，采⽤了数组+链表的形式来组织键值对Entry&lt;Key,Value&gt;（利⽤数组的查询快+链表的插⼊<br>删除快）</li><li>HashMap在存储键值对Entry&lt;Key,Value&gt;的时候，会根据Key的hashcode值，以某种映射关系，决定应当将<br>这对键值对Entry&lt;Key,Value&gt;存储在HashMap中的什么位置上</li><li>在JDK1.7进⾏多线程put操作，之后遍历，直接死循环，CPU飙到100%，在JDK 1.8中进⾏多线程操作会出现<br>节点和value值丢失，为什么JDK1.7与JDK1.8多线程操作会出现很⼤不同，是因为JDK 1.8的作者对resize⽅法进<br>⾏了优化不会产⽣链表闭环。<br>ii. 结构：<br>iii. HashMap扩容：<br>1、很简单的计算：由于默认的加载因⼦是0.75 ，那么，此时map的阀值是 16*0.75 = 12，即添加第13 个键值对&lt;Key,Value&gt;的<br>时候，map的容量会扩充⼀倍。<br>2、确实如此，但是为了尽可能第减少桶中的Entry&lt;Key,Value&gt;链表的长度，以提⾼HashMap的存取性能，确定的这个经验<br>值。如果读者你对存取效率要求的不是太⾼，想省点空间的话，你可以new HashMap(int initialCapacity, float loadFactor)构造⽅<br>法将这个因⼦设置得⼤⼀些也⽆妨。</li><li>扩容步骤：<br>1 1.申请⼀个新的、⼤⼩为当前容量两倍的数组；<br>2 2.将旧数组的Entry[] table中的链表重新计算hash值，然后重新均匀地放置到新的扩充数组中；<br>3 3.释放旧的数组；</li><li>为何扩容为原来的两倍（性能）：<br>a. 在HashMap通过键的哈希值进⾏定位桶位置的时候，调⽤了⼀个indexFor(hash, table.length);⽅法。<br>1 /**<br>2 * Returns index for hash code h.<br>3 */<br>4 static int indexFor(int h, int length) {<br>5 return h &amp; (length-1);<br>6 }<br>b. 通过限制length是⼀个2的幂数，h &amp; (length-1)和h % length结果是⼀致的。<br>c. 如果length是⼀个2的幂的数，那么length-1就会变成⼀个mask, 它会将hashcode低位取出来，<br>hashcode的低位实际就是余数，和取余操作相⽐，与操作会将性能提升很多。<br>_.<br>iv. put流程：<br>1 a. 获取这个Key的hashcode值，根据此值确定应该将这⼀对键值对存放在哪⼀个桶中，即确定要存放桶的索引；<br>2 b. 遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<br>3 c1. 若已存在，定位到对应的Entry&lt;Key,Value&gt;,其中的Value值更新为新的Value值；返回旧值；<br>4 c2. 若不存在，则根据键值对&lt;Key,Value&gt; 创建⼀个新的Entry&lt;Key,Value&gt;对象，然后添加到这个桶的Entry&lt;Key,Value&gt;<br>5 d. 当前的HashMap的⼤⼩(即Entry&lt;key,Value&gt;节点的数⽬)是否超过了阀值，若超过了阀值(threshold)，<br>6 则增⼤HashMap的容量(即Entry[] table 的⼤⼩)，并且重新组织内部各个Entry&lt;Key,Value&gt;排列。<br>v. get流程：<br>1 a. 获取这个Key的hashcode值，根据此hashcode值决定应该从哪⼀个桶中查找；<br>2 b. 遍历所在桶中的Entry&lt;Key,Value&gt;链表，查找其中是否已经有了以Key值为Key存储的Entry&lt;Key,Value&gt;对象，<br>3 c1. 若已存在，定位到对应的Entry&lt;Key,Value&gt;,返回value<br>4 c2. 若不存在，返回null；</li></ol><p>红黑树简介</p><ol><li>简介<br>红黑树是一种自平衡二叉查找树。它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。在C++ STL中，很多部分(目前包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。<br>本文介绍了红黑树的基本性质和基本操作。</li><li>红黑树的性质<br>红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡。它的每个节点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父节点）。<br>红黑树的定义也是它的性质，有以下五条：<br>性质1. 节点是红色或黑色<br>性质2. 根是黑色<br>性质3. 所有叶子都是黑色（叶子是NIL节点）<br>性质4. 如果一个节点是红的，则它的两个儿子都是黑的<br>性质5. 从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p>这五个性质强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。为什么呢？性质4暗示着任何一个简单路径上不能有两个毗连的红色节点，这样，最短的可能路径全是黑色节点，最长的可能路径有交替的红色和黑色节点。同时根据性质5知道：所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br>3. 红黑树的基本操作<br>因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同。然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次。<br>3.1 插入操作<br>插入操作可以概括为以下几个步骤：<br>(1) 查找要插入的位置，时间复杂度为：O(N)<br>(2) 将新节点的color赋为红色<br>(3) 自下而上重新调整该树为红黑树<br>其中，第(1)步的查找方法跟普通二叉查找树一样，第(2)步之所以将新插入的节点的颜色赋为红色，是因为：如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整，这样简单多了。下面讨论步骤(3)的一些细节：<br>设要插入的节点为N，其父节点为P，其父亲G的兄弟节点为U（即P和U是同一个节点的两个子节点）。<br>[1] 如果P是黑色的，则整棵树不必调整便是红黑树。<br>[2] 如果P是红色的（可知，其父节点G一定是黑色的），则插入z后，违背了性质4，需要进行调整。调整时分以下3种情况：<br>（a）N的叔叔U是红色的</p><p>如上图所示，我们将P和U重绘为黑色并重绘节点G为红色(用来保持性质5)。现在新节点N有了一个黑色的父节点P，因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G的父节点也有可能是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归调整颜色。<br>（b）N的叔叔U是黑色的，且N是右孩子</p><p>如上图所示，我们对P进行一次左旋转调换新节点和其父节点的角色; 接着，按情形(c)处理以前的父节点P以解决仍然失效的性质4。<br>（c）N的叔叔U是黑色的，且N是左孩子</p><p>如上图所示，对祖父节点G 的一次右旋转; 在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G 的父节点， 然后交换以前的父节点P和祖父节点G的颜色，结果的树满足性质4，同时性质5[4]也仍然保持满足。<br>3.2 删除操作<br>删除操作可以概括为以下几个步骤：<br>(1) 查找要删除位置，时间复杂度为：O(N)<br>(2) 用删除节点后继或者节点替换该节点（只进行数据替换即可，不必调整指针，后继节点是中序遍历中紧挨着该节点的节点，即：右孩子的最左孩子节点）<br>(3) 如果删除节点的替换节点为黑色，则需重新调整该树为红黑树<br>其中，第(1)步的查找方法跟普通二叉查找树一样，第(2)步之所以用后继节点替换删除节点，是因为这样可以保证该后继节点之上仍是一个红黑树，而后继节点可能是一个叶节点或者只有右子树的节点，这样只需用有节点替换后继节点即可达到删除的目的。如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。（没看懂？？？可参考：<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a> ）在第(3)步中，如果，如果删除节点为红色节点，则他的父亲和孩子全为黑节点，这样直接删除该节点即可，不必进行任何调整。如果删除节点是黑节点，分四种情况：<br>设要删除的节点为N，其父节点为P，其兄弟节点为S。<br>由于N是黑色的，则P可能是黑色的，也可能是红色的，S也可能是黑色的或者红色的<br>（1）S是红色的<br>此时P肯定是红色的。我们对N的父节点进行左旋转，然后把红色兄弟转换成N的祖父。我们接着对调 N 的父亲和祖父的颜色。尽管所有的路径仍然有相同数目的黑色节点，现在 N 有了一个黑色的兄弟和一个红色的父亲，所以我们可以接下去按 (2)、(3)或(4)情况来处理。</p><p>（2）S和S的孩子全是黑色的<br>在这种情况下，P可能是黑色的或者红色的，我们简单的重绘S 为红色。结果是通过S的所有路径，它们就是以前不通过 N 的那些路径，都少了一个黑色节点。因为删除 N 的初始的父亲使通过 N 的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过 P 的所有路径现在比不通过 P 的路径少了一个黑色节点。接下来，要调整以P作为N递归调整树。</p><p>（3）S是黑色的，S的左孩子是红色，右孩子是黑色<br>这种情况下我们在 S 上做右旋转，这样 S 的左儿子成为 S 的父亲和 N 的新兄弟。我们接着交换 S 和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在 N 有了一个右儿子是红色的黑色兄弟，所以我们进入了情况（4）。N 和它的父亲都不受这个变换的影响。</p><p>（4）S是黑色的，S的右孩子是红色<br>在这种情况下我们在 N 的父亲上做左旋转，这样 S 成为 N 的父亲和 S 的右儿子的父亲。我们接着交换 N 的父亲和 S 的颜色，并使 S 的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以属性 3 没有被违反。但是，N 现在增加了一个黑色祖先: 要么 N 的父亲变成黑色，要么它是黑色而 S 被增加为一个黑色祖父。所以，通过 N 的路径都增加了一个黑色节点。</p><p>部分IT公司笔试算法题<br>个人总结，算法未必最合理，仅供参考: <a href="mailto:&#115;&#x68;&#x61;&#x79;&#103;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;">&#115;&#x68;&#x61;&#x79;&#103;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#109;</a><br>1、将一整数逆序后放入一数组中（要求递归实现）</p><pre><code>void convert(int *result, int n) &#123;
    if(n&gt;=10)
        convert(result+1, n/10);
    *result = n%10;    
&#125;
int main(int argc, char* argv[]) &#123;
    int n = 123456789, result[20]=&#123;&#125;;
    convert(result, n);
    printf(&quot;%d:&quot;, n);
    for(int i=0; i&lt;9; i++)
        printf(&quot;%d&quot;, result[i]);
&#125;
</code></pre><p>2、求高于平均分的学生学号及成绩（学号和成绩人工输入）</p><pre><code>double find(int total, int n) &#123;
    int number, score,  average;
    scanf(&quot;%d&quot;, &amp;number);
    if(number != 0) &#123;
        scanf(&quot;%d&quot;, &amp;score);
        average = find(total+score, n+1);
        if(score &gt;= average)
            printf(&quot;%d:%d\n&quot;, number, score);
        return average;
    &#125; else &#123;
        printf(&quot;Average=%d\n&quot;, total/n);
        return total/n;
    &#125;
&#125;
int main(int argc, char* argv[]) &#123;
    find(0, 0);
&#125;
</code></pre><p>3、递归实现回文判断（如：abcdedbca就是回文，判断一个面试者对递归理解的简单程序）</p><pre><code>int find(char *str, int n) &#123;
    if(n&lt;=1)    return 1;
    else if(str[0]==str[n-1])    return find(str+1, n-2);
    else        return 0;
&#125;

int main(int argc, char* argv[]) &#123;
    char *str = &quot;abcdedcba&quot;;
    printf(&quot;%s: %s\n&quot;, str, find(str, strlen(str)) ? &quot;Yes&quot; : &quot;No&quot;);
&#125;
</code></pre><p>4、组合问题（从M个不同字符中任取N个字符的所有组合）</p><pre><code>void find(char *source, char *result, int n) &#123;
    if(n==1) &#123;
        while(*source)
           printf(&quot;%s%c\n&quot;, result, *source++);
    &#125; else &#123;
        int i, j;
        for(i=0; source[i] != 0; i++);
        for(j=0; result[j] != 0; j++);
        for(; i&gt;=n; i--) &#123;
            result[j] = *source++;
            result[j+1] = &#39;\0&#39;;
            find(source, result, n-1);
        &#125;
    &#125;
&#125;

int main(int argc, char* argv[]) &#123;
    int const n = 3;
    char *source = &quot;ABCDE&quot;, result[n+1] = &#123;0&#125;;
    if(n&gt;0 &amp;&amp; strlen(source)&gt;0 &amp;&amp; n&lt;=strlen(source))
        find(source, result, 3);
&#125;
</code></pre><p>5、分解成质因数(如435234=251<em>17</em>17<em>3</em>2，据说是华为笔试题)</p><pre><code>void prim(int m, int n) &#123;
    if(m&gt;n) &#123;
        while(m%n != 0) n++;
        m /= n;
        prim(m, n);
        printf(&quot;%d*&quot;, n);
    &#125;
&#125;
int main(int argc, char* argv[]) &#123;
    int n = 435234;
    printf(&quot;%d=&quot;, n);
    prim(n, 2);
&#125;
</code></pre><p>6、寻找迷宫的一条出路，o：通路； X：障碍。（大家经常谈到的一个小算法题）</p><pre><code>#define MAX_SIZE  8
int H[4] = &#123;0, 1, 0, -1&#125;; 
int V[4] = &#123;-1, 0, 1, 0&#125;;           
char Maze[MAX_SIZE][MAX_SIZE] = &#123;&#123;'X','X','X','X','X','X','X','X'&#125;,
                                 &#123;'o','o','o','o','o','X','X','X'&#125;,
                                 &#123;'X','o','X','X','o','o','o','X'&#125;,
                           		&#123;'X','o','X','X','o','X','X','o'&#125;,
                      			&#123;'X','o','X','X','X','X','X','X'&#125;,
&#123;'X','o','X','X','o','o','o','X'&#125;,
  							&#123;'X','o','o','o','o','X','o','o'&#125;,
                                 &#123;'X','X','X','X','X','X','X','X'&#125;&#125;;
void FindPath(int X, int Y) &#123;
    if(X == MAX_SIZE || Y == MAX_SIZE) &#123;
          for(int i = 0; i &lt; MAX_SIZE; i++)
for(int j = 0; j &lt; MAX_SIZE; j++)
                  printf(&quot;%c%c&quot;, Maze[i][j], j &lt; MAX_SIZE-1 ? &#39; &#39; : &#39;\n&#39;);
&#125;else for(int k = 0; k &lt; 4; k++) 
if(X &gt;= 0 &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; MAX_SIZE &amp;&amp; X &lt; MAX_SIZE &amp;&amp; &#39;o&#39; == Maze[X][Y]) &#123;
                      Maze[X][Y] = &#39; &#39;;
                      FindPath(X+V[k], Y+H[k]);
                      Maze[X][Y] =&#39;o&#39;; 
&#125;
&#125;
int main(int argc, char* argv[]) &#123;
    FindPath(1,0);
&#125;
</code></pre><p>7、随机分配座位，共50个学生，使学号相邻的同学座位不能相邻(早些时候用C#写的，没有用C改写）。</p><pre><code>static void Main(string[] args)
&#123;
    int Tmp = 0, Count = 50;            
    int[] Seats = new int[Count];            
    bool[] Students = new bool[Count];
    System.Random RandStudent=new System.Random();
    Students[Seats[0]=RandStudent.Next(0,Count)]=true;
    for(int i = 1; i &lt; Count; ) &#123;
        Tmp=(int)RandStudent.Next(0,Count);
        if((!Students[Tmp])&amp;&amp;(Seats[i-1]-Tmp!=1) &amp;&amp; (Seats[i-1] - Tmp) != -1) &#123;
            Seats[i++] = Tmp;
Students[Tmp] = true;
        &#125;
    &#125;
    foreach(int Student in Seats)
        System.Console.Write(Student + &quot; &quot;);
    System.Console.Read();
&#125;
</code></pre><p>8、求网格中的黑点分布。现有6*7的网格，在某些格子中有黑点，已知各行与各列中有黑点的点数之和，请在这张网格中画出黑点的位置。（这是一网友提出的题目，说是他笔试时遇到算法题）</p><pre><code>#define ROWS 6
#define COLS 7
int iPointsR[ROWS] = &#123;2, 0, 4, 3, 4, 0&#125;;           // 各行黑点数和的情况
int iPointsC[COLS] = &#123;4, 1, 2, 2, 1, 2, 1&#125;;        // 各列黑点数和的情况
int iCount, iFound;
int iSumR[ROWS], iSumC[COLS], Grid[ROWS][COLS];

int Set(int iRowNo) &#123;
if(iRowNo == ROWS) &#123; 
        for(int iColNo=0; iColNo &lt; COLS &amp;&amp; iSumC[iColNo]==iPointsC[iColNo]; iColNo++) 
           if(iColNo == COLS-1) &#123;
               printf(&quot;\nNo.%d:\n&quot;, ++iCount); 
               for(int i=0; i &lt; ROWS; i++)
                  for(int j=0; j &lt; COLS; j++)
                      printf(&quot;%d%c&quot;, Grid[i][j], (j+1) % COLS ? &#39; &#39; : &#39;\n&#39;);
               iFound = 1;    // iFound = 1，有解
           &#125;
    &#125; else &#123;
        for(int iColNo=0; iColNo &lt; COLS; iColNo++) &#123;
            if(iPointsR[iRowNo] == 0) &#123; 
                Set(iRowNo + 1);
   &#125; else if(Grid[iRowNo][iColNo]==0) &#123; 
Grid[iRowNo][iColNo] = 1; 
iSumR[iRowNo]++; iSumC[iColNo]++;                                  if(iSumR[iRowNo]&lt;iPointsR[iRowNo] &amp;&amp; iSumC[iColNo]&lt;=iPointsC[iColNo])
                     Set(iRowNo);
else if(iSumR[iRowNo]==iPointsR[iRowNo] &amp;&amp; iRowNo &lt; ROWS)
                     Set(iRowNo + 1);
                Grid[iRowNo][iColNo] = 0;
                iSumR[iRowNo]--; 
iSumC[iColNo]--;
            &#125;
        &#125;
    &#125;
return iFound;           // 用于判断是否有解
&#125;
int main(int argc, char* argv[]) &#123;
    if(!Set(0))
        printf(&quot;Failure!&quot;); 
&#125;
</code></pre><p>9、有4种面值的邮票很多枚，这4种邮票面值分别1, 4, 12, 21，现从多张中最多任取5张进行组合，求取出这些邮票的最大连续组合值。（据说是华为2003年校园招聘笔试题）<br>#define N 5<br>#define M 5<br>int k, Found, Flag[N];<br>int Stamp[M] = {0, 1, 4, 12, 21};</p><p>// 在剩余张数n中组合出面值和Value<br>int Combine(int n, int Value) {<br>if(n &gt;= 0 &amp;&amp; Value == 0) {<br>Found = 1;<br>int Sum = 0;<br>for(int i=0; i&lt;N &amp;&amp; Flag[i] != 0; i++) {<br>Sum += Stamp[Flag[i]];<br>printf(“%d “, Stamp[Flag[i]]);<br>}<br>printf(“\tSum=%d\n\n”, Sum);<br>}else for(int i=1; i&lt;M &amp;&amp; !Found &amp;&amp; n&gt;0; i++)<br>if(Value-Stamp[i] &gt;= 0) {<br>Flag[k++] = i;<br>Combine(n-1, Value-Stamp[i]);<br>Flag[–k] = 0;<br>}<br>return Found;<br>}</p><p>int main(int argc, char* argv[]) {<br>for(int i=1; Combine(N, i); i++, Found=0);<br>}</p><p>10、大整数数相乘的问题。（这是2002年在一考研班上遇到的算法题）<br>void Multiple(char A[], char B[], char C[]) {<br>int TMP, In=0, LenA=-1, LenB=-1;<br>while(A[++LenA] != ‘\0’);<br>while(B[++LenB] != ‘\0’);<br>int Index, Start = LenA + LenB - 1;<br>for(int i=LenB-1; i&gt;=0; i–) {<br>Index = Start–;<br>if(B[i] != ‘0’) {<br>for(int In=0, j=LenA-1; j&gt;=0; j–) {<br>TMP = (C[Index]-‘0’) + (A[j]-‘0’) * (B[i] - ‘0’) + In;<br>C[Index–] = TMP % 10 + ‘0’;<br>In = TMP / 10;<br>}<br>C[Index] = In + ‘0’;<br>}<br>}<br>}</p><p>int main(int argc, char* argv[]) {<br>char A[] = “21839244444444448880088888889”;<br>char B[] = “38888888888899999999999999988”;<br>char C[sizeof(A) + sizeof(B) - 1];</p><pre><code>for(int k=0; k&lt;sizeof(C); k++)
    C[k] = &#39;0&#39;;
C[sizeof(C)-1] = &#39;\0&#39;;

Multiple(A, B, C);
for(int i=0; C[i] != &#39;\0&#39;; i++)
    printf(&quot;%c&quot;, C[i]);
</code></pre><p>}</p><p>11、求最大连续递增数字串（如“ads3sl456789DF3456ld345AA”中的“456789”）<br>int GetSubString(char *strSource, char <em>strResult) {<br>int iTmp=0, iHead=0, iMax=0;<br>for(int Index=0, iLen=0; strSource[Index]; Index++) {<br>if(strSource[Index] &gt;= ‘0’ &amp;&amp; strSource[Index] &lt;= ‘9’ &amp;&amp;<br>strSource[Index-1] &gt; ‘0’ &amp;&amp; strSource[Index] == strSource[Index-1]+1) {<br>iLen++; // 连续数字的长度增1<br>} else { // 出现字符或不连续数字<br>if(iLen &gt; iMax) {<br>iMax = iLen; iHead = iTmp;<br>}<br>// 该字符是数字，但数字不连续<br>if(strSource[Index] &gt;= ‘0’ &amp;&amp; strSource[Index] &lt;= ‘9’) {<br>iTmp = Index;<br>iLen = 1;<br>}<br>}<br>}<br>for(iTmp=0 ; iTmp &lt; iMax; iTmp++) // 将原字符串中最长的连续数字串赋值给结果串<br>strResult[iTmp] = strSource[iHead++];<br>strResult[iTmp]=’\0’;<br>return iMax; // 返回连续数字的最大长度<br>}<br>int main(int argc, char</em> argv[]) {<br>char strSource[]=”ads3sl456789DF3456ld345AA”, char strResult[sizeof(strSource)];<br>printf(“Len=%d, strResult=%s \nstrSource=%s\n”,<br>GetSubString(strSource, strResult), strResult, strSource);<br>}</p><p>12、四个工人，四个任务，每个人做不同的任务需要的时间不同，求任务分配的最优方案。（2005年5月29日全国计算机软件资格水平考试——软件设计师的算法题）。<br>#include “stdafx.h”<br>#define N 4<br>int Cost[N][N] = { {2, 12, 5, 32}, // 行号：任务序号，列号：工人序号<br>{8, 15, 7, 11}, // 每行元素值表示这个任务由不同工人完成所需要的时间<br>{24, 18, 9, 6},<br>{21, 1, 8, 28}};<br>int MinCost=1000;<br>int Task[N], TempTask[N], Worker[N];<br>void Assign(int k, int cost) {<br>if(k == N) {<br>MinCost = cost;<br>for(int i=0; i&lt;N; i++)<br>TempTask[i] = Task[i];<br>} else {<br>for(int i=0; i&lt;N; i++) {<br>if(Worker[i]==0 &amp;&amp; cost+Cost[k][i] &lt; MinCost) { // 为提高效率而进行剪枝<br>Worker[i] = 1; Task[k] = i;<br>Assign(k+1, cost+Cost[k][i]);<br>Worker[i] = 0; Task[k] = 0;<br>}<br>}<br>}<br>}<br>int main(int argc, char* argv[]) {<br>Assign(0, 0);<br>printf(“最佳方案总费用=%d\n”, MinCost);<br>for(int i=0; i&lt;N; i++) /* 输出最佳方案 */<br>printf(“\t任务%d由工人%d来做：%d\n”, i, TempTask[i], Cost[i][TempTask[i]]);<br>}<br>13、八皇后问题，输出了所有情况，不过有些结果只是旋转了90度而已。（回溯算法的典型例题，是数据结构书上算法的具体实现，大家都亲自动手写过这个程序吗？）<br>#define N 8<br>int Board[N][N];<br>int Valid(int i, int j) { // 判断下棋位置是否有效<br>int k = 1;<br>for(k=1; i&gt;=k &amp;&amp; j&gt;=k;k++)<br>if(Board[i-k][j-k]) return 0;<br>for(k=1; i&gt;=k;k++)<br>if(Board[i-k][j]) return 0;<br>for(k=1; i&gt;=k &amp;&amp; j+k&lt;N;k++)<br>if(Board[i-k][j+k]) return 0;<br>return 1;<br>}</p><p>void Trial(int i, int n) { // 寻找合适下棋位置<br>if(i == n) {<br>for(int k=0; k&lt;n; k++) {<br>for(int m=0; m&lt;n; m++)<br>printf(“%d “, Board[k][m]);<br>printf(“\n”);<br>}<br>printf(“\n”);<br>} else {<br>for(int j=0; j&lt;n; j++) {<br>Board[i][j] = 1;<br>if(Valid(i,j))<br>Trial(i+1, n);<br>Board[i][j] = 0;<br>}<br>}<br>}</p><p>int main(int argc, char* argv[]) {<br>Trial(0, N);<br>}</p><p>14、实现strstr功能，即在父串中寻找子串首次出现的位置。（笔试中常让面试者实现标准库中的一些函数）<br>char * strstring(char *ParentString, char *SubString) {<br>char *pSubString, *pPareString;<br>for(char *pTmp=ParentString; *pTmp; pTmp++) {<br>pSubString = SubString;<br>pPareString = pTmp;<br>while(*pSubString == *pPareString &amp;&amp; *pSubString != ‘\0’) {<br>pSubString++;<br>pPareString++;<br>}<br>if(*pSubString == ‘\0’) return pTmp;<br>}<br>return NULL;<br>}</p><p>int main(int argc, char* argv[]) {<br>char *ParentString = “happy birthday to you!”;<br>char *SubString = “birthday”;<br>printf(“%s”,strstring(ParentString, SubString));<br>}</p><p>15、现在小明一家过一座桥，过桥的时候是黑夜，所以必须有灯。现在小明过桥要1分，小明的弟弟要3分，小明的爸爸要6分，小明的妈妈要8分，小明的爷爷要12分。每次此桥最多可过两人，而过桥的速度依过桥最慢者而定，而且灯在点燃后30分就会熄灭。问小明一家如何过桥时间最短？（原本是个小小智力题，据说是外企的面试题，在这里用程序来求解）<br>#include “stdafx.h”<br>#define N 5<br>#define SIZE 64</p><p>// 将人员编号：小明-0，弟弟-1，爸爸-2，妈妈-3，爷爷-4<br>// 每个人的当前位置：0–在桥左边， 1–在桥右边<br>int Position[N];<br>// 过桥临时方案的数组下标； 临时方案； 最小时间方案；<br>int Index, TmpScheme[SIZE], Scheme[SIZE];<br>// 最小过桥时间总和，初始值100；每个人过桥所需要的时间<br>int MinTime=100, Time[N]={1, 3, 6, 8, 12};<br>// 寻找最佳过桥方案。Remnant:未过桥人数; CurTime:当前已用时间;<br>// Direction:过桥方向,1–向右,0–向左<br>void Find(int Remnant, int CurTime, int Direction) {<br>if(Remnant == 0) { // 所有人已经过桥，更新最少时间及方案<br>MinTime=CurTime;<br>for(int i=0; i&lt;SIZE &amp;&amp; TmpScheme[i]&gt;=0; i++)<br>Scheme[i] = TmpScheme[i];<br>} else if(Direction == 1) { // 过桥方向向右，从桥左侧选出两人过桥<br>for(int i=0; i&lt;N; i++)<br>if(Position[i] == 0 &amp;&amp; CurTime + Time[i] &lt; MinTime) {<br>TmpScheme[Index++] = i;<br>Position[i] = 1;<br>for(int j=0; j&lt;N; j++) {<br>int TmpMax = (Time[i] &gt; Time[j] ? Time[i] : Time[j]);<br>if(Position[j] == 0 &amp;&amp; CurTime + TmpMax &lt; MinTime) {<br>TmpScheme[Index++] = j;<br>Position[j] = 1;<br>Find(Remnant - 2, CurTime + TmpMax, !Direction);<br>Position[j] = 0;<br>TmpScheme[–Index] = -1;<br>}<br>}<br>Position[i] = 0;<br>TmpScheme[–Index] = -1;<br>}<br>} else { // 过桥方向向左，从桥右侧选出一个人回来送灯<br>for(int j=0; j&lt;N; j++) {<br>if(Position[j] == 1 &amp;&amp; CurTime+Time[j] &lt; MinTime) {<br>TmpScheme[Index++] = j;<br>Position[j] = 0;<br>Find(Remnant+1, CurTime+Time[j], !Direction);<br>Position[j] = 1;<br>TmpScheme[–Index] = -1;<br>}<br>}<br>}<br>}<br>int main(int argc, char* argv[]) {<br>for(int i=0; i&lt;SIZE; i++) // 初始方案内容为负值，避免和人员标号冲突<br>Scheme[i] = TmpScheme[i] = -1;</p><p>Find(N, 0, 1); // 查找最佳方案</p><pre><code>printf(&quot;MinTime=%d:&quot;, MinTime);    // 输出最佳方案
for(int i=0; i&lt;SIZE &amp;&amp; Scheme[i]&gt;=0; i+=3)
    printf(&quot;  %d-%d  %d&quot;, Scheme[i], Scheme[i+1], Scheme[i+2]);
printf(&quot;\b\b  &quot;);
</code></pre><p>}</p><p>16、2005年11月金山笔试题。编码完成下面的处理函数。函数将字符串中的字符’<em>‘移到串的前部分，前面的非’</em>‘字符后移，但不能改变非’<em>‘字符的先后顺序，函数返回串中字符’</em>‘的数量。如原始串为：ab<strong>cd</strong>e<em>12，处理后为*****abcde12，函数并返回值为5。（要求使用尽量少的时间和辅助空间）<br>int change(char <em>str) { /</em> 这个算法并不高效，从后向前搜索效率要高些 <em>/<br>int count = 0; /</em> 记录串中字符’</em>‘的个数 <em>/<br>for(int i=0, j=0; str[i]; i++) { /</em> 重串首开始遍历 <em>/<br>if(str[i]==’</em>‘) { /* 遇到字符’<em>‘ <em>/<br>for(j=i-1; str[j]!=’</em>‘&amp;&amp;j&gt;=0; j–) /</em> 采用类似插入排序的思想，将<em>前面 <em>/<br>str[j+1]=str[j]; /</em> 的非</em>字符逐个后移，直到遇到<em>字符 <em>/<br>str[j+1] = ‘</em>‘;<br>count++;<br>}<br>}<br>return count;<br>}<br>int main(int argc, char</em> argv[]) {<br>char str[] = “ab<strong>cd</strong>e<em>12”;<br>printf(“str1=%s\n”, str);<br>printf(“str2=%s, count=%d”, str, change(str));<br>}<br>// 终于得到一个比较高效的算法，一个网友提供，估计应该和金山面试官的想法一致。算法如下：<br>int change(char <em>str) {<br>int i,j=strlen(str)-1;<br>for(i=j; j&gt;=0; j–) {<br>if(str[i]!=’</em>‘) {<br>i–;<br>} else if(str[j]!=’</em>‘) {<br>str[i] = str[j];<br>str[j] = ‘*’;<br>i–;<br>}<br>}<br>return i+1;<br>}</p><p>17、2005年11月15日华为软件研发笔试题。实现一单链表的逆转。<br>#include “stdafx.h”<br>typedef char eleType; // 定义链表中的数据类型<br>typedef struct listnode { // 定义单链表结构<br>eleType data;<br>struct listnode *next;<br>}node;</p><p>node *create(int n) { // 创建单链表，n为节点个数<br>node *p = (node *)malloc(sizeof(node));<br>node *head = p; head-&gt;data = ‘A’;<br>for(int i=’B’; i&lt;’A’+n; i++) {<br>p = (p-&gt;next = (node *)malloc(sizeof(node)));<br>p-&gt;data = i;<br>p-&gt;next = NULL;<br>}<br>return head;<br>}</p><p>void print(node *head) { // 按链表顺序输出链表中元素<br>for(; head; head = head-&gt;next)<br>printf(“%c “, head-&gt;data);<br>printf(“\n”);<br>}</p><p>node *reverse(node *head, node *pre) { // 逆转单链表函数。这是笔试时需要写的最主要函数<br>node *p=head-&gt;next;<br>head-&gt;next = pre;<br>if(p) return reverse(p, head);<br>else return head;<br>}</p><p>int main(int argc, char* argv[]) {<br>node *head = create(6);<br>print(head);<br>head = reverse(head, NULL);<br>print(head);<br>}</p><p>18、编码实现字符串转整型的函数（实现函数atoi的功能），据说是神州数码笔试题。如将字符串 ”+123”123, ”-0123”-123, “123CS45”123, “123.45CS”123, “CS123.45”0<br>#include “stdafx.h”<br>int str2int(const char *str) { // 字符串转整型函数<br>int i=0, sign=1, value = 0;<br>if(str==NULL) return NULL; // 空串直接返回 NULL<br>if(str[0]==’-‘ || str[0]==’+’) { // 判断是否存在符号位<br>i = 1;<br>sign = (str[0]==’-‘ ? -1 : 1);<br>}<br>for(; str[i]&gt;=’0’ &amp;&amp; str[i]&lt;=’9’; i++) // 如果是数字，则继续转换<br>value = value * 10 + (str[i] - ‘0’);<br>return sign * value;<br>}</p><p>int main(int argc, char *argv[]) {<br>char *str = “-123.45CS67”;<br>int val = str2int(str);<br>printf(“str=%s\tval=%d\n”, str, val);<br>}</p><p>19、歌德巴赫猜想。任何一个偶数都可以分解为两个素数之和。（其实这是个C二级考试的模拟试题）<br>#include “stdafx.h”<br>#include “math.h”<br>int main(int argc, char* argv[]) {<br>int Even=78, Prime1, Prime2, Tmp1, Tmp2;<br>for(Prime1=3; Prime1&lt;=Even/2; Prime1+=2) {<br>for(Tmp1=2,Tmp2=sqrt(float(Prime1)); Tmp1&lt;=Tmp2 &amp;&amp; Prime1%Tmp1 != 0; Tmp1++);<br>if(Tmp1&lt;=Tmp2) continue;<br>Prime2 = Even-Prime1;<br>for(Tmp1=2,Tmp2=sqrt(float(Prime2)); Tmp1&lt;=Tmp2 &amp;&amp; Prime2%Tmp1 != 0; Tmp1++);<br>if(Tmp1&lt;=Tmp2) continue;<br>printf(“%d=%d+%d\n”, Even, Prime1, Prime2);<br>}<br>}</p><p>20、快速排序（东软喜欢考类似的算法填空题，又如堆排序的算法等）<br>#include “stdafx.h”<br>#define N 10<br>int part(int list[], int low, int high) { // 一趟排序，返回分割点位置<br>int tmp = list[low];<br>while(low&lt;high) {<br>while(low&lt;high &amp;&amp; list[high]&gt;=tmp) –high;<br>list[low] = list[high];<br>while(low&lt;high &amp;&amp; list[low]&lt;=tmp) ++low;<br>list[high] = list[low];<br>}<br>list[low] = tmp;<br>return low;<br>}<br>void QSort(int list[], int low, int high) { // 应用递归进行快速排序<br>if(low&lt;high) {<br>int mid = part(list, low, high);<br>QSort(list, low, mid-1);<br>QSort(list, mid+1, high);<br>}<br>}<br>void show(int list[], int n) { // 输出列表中元素<br>for(int i=0; i&lt;n; i++)<br>printf(“%d “, list[i]);<br>printf(“\n”);<br>}<br>int main(int argc, char* argv[]) {<br>int list[N] = {23, 65, 26, 1, 6, 89, 3, 12, 33, 8};<br>show(list, N); // 输出排序前序列<br>QSort(list, 0, N-1); // 快速排序<br>show(list, N); // 输出排序后序列<br>}</p><p>21、2005年11月23日慧通笔试题：写一函数判断某个整数是否为回文数，如12321为回文数。可以用判断入栈和出栈是否相同来实现（略微复杂些），这里是将整数逆序后形成另一整数，判断两个整数是否相等来实现的。<br>#include “stdafx.h”<br>int IsEchoNum(int num) {<br>int tmp = 0;<br>for(int n = num; n; n/=10)<br>tmp = tmp *10 + n%10;<br>return tmp==num;<br>}</p><p>int main(int argc, char* argv[]) {<br>int num = 12321;<br>printf(“%d %d\n”, num, IsEchoNum(num));<br>}</p><p>22、删除字符串中的数字并压缩字符串（神州数码以前笔试题），如字符串”abc123de4fg56”处理后变为”abcdefg”。注意空间和效率。（下面的算法只需要一次遍历，不需要开辟新空间，时间复杂度为O(N)）<br>#include “stdafx.h”<br>void delNum(char *str) {<br>int i, j=0;<br>// 找到串中第一个数字的位子<br>for(i=j=0; str[i] &amp;&amp; (str[i]&lt;’0’ || str[i]&gt;’9’); j=++i);</p><pre><code>// 从串中第一个数字的位置开始，逐个放入后面的非数字字符
for(; str[i]; i++)            
    if(str[i]&lt;&#39;0&#39; || str[i]&gt;&#39;9&#39;) 
        str[j++] = str[i];
str[j] = &#39;\0&#39;;
</code></pre><p>}</p><p>int main(int argc, char* argv[]) {<br>char str[] = “abc123ef4g4h5”;<br>printf(“%s\n”, str);<br>delNum(str);<br>printf(“%s\n”, str);<br>}</p><p>23、求两个串中的第一个最长子串（神州数码以前试题）。如”abractyeyt”,”dgdsaeactyey”的最大子串为”actyet”。<br>#include “stdafx.h”<br>char *MaxSubString(char *str1, char *str2) {<br>int i, j, k, index, max=0;<br>for(i=0; str1[i]; i++)<br>for(j=0; str2[j]; j++) {<br>for(k=0; str1[i+k]==str2[j+k] &amp;&amp; (str2[i+k] || str1[i+k]); k++);<br>if(k&gt;max) { // 出现大于当前子串长度的子串，则替换子串位置和程度<br>index = j; max = k;<br>}<br>}<br>char *strResult = (char *)calloc(sizeof(char), max+1);<br>for(i=0; i&lt;max; i++)<br>strResult[i] = str2[index++];<br>return strResult;<br>}</p><p>int main(int argc, char* argv[]) {<br>char str1[] = “abractyeyt”, str2[] = “dgdsaeactyey”;<br>char *strResult = MaxSubString(str1, str2);<br>printf(“str1=%s\nstr2=%s\nMaxSubString=%s\n”, str1, str2, strResult);<br>}</p><p>24、不开辟用于交换数据的临时空间，如何完成字符串的逆序(在技术一轮面试中，有些面试官会这样问)<br>#include “stdafx.h”<br>void change(char <em>str) {<br>for(int i=0,j=strlen(str)-1; i&lt;j; i++, j–){<br>str[i] ^= str[j] ^= str[i] ^= str[j];<br>}<br>}<br>int main(int argc, char</em> argv[]) {<br>char str[] = “abcdefg”;<br>printf(“strSource=%s\n”, str);<br>change(str);<br>printf(“strResult=%s\n”, str);<br>return getchar();<br>}</p><p>25、删除串中指定的字符（做此题时，千万不要开辟新空间，否则面试官可能认为你不适合做嵌入式开发）<br>#include “stdafx.h”<br>void delChar(char *str, char c) {<br>int i, j=0;<br>for(i=0; str[i]; i++)<br>if(str[i]!=c) str[j++]=str[i];<br>str[j] = ‘\0’;<br>}</p><p>int main(int argc, char* argv[]) {<br>char str[] = “abcdefgh”; // 注意，此处不能写成char *str = “abcdefgh”;<br>printf(“%s\n”, str);<br>delChar(str, ‘c’);<br>printf(“%s\n”, str);<br>}</p><p>26、判断单链表中是否存在环（网上说的笔试题）<br>#include “stdafx.h”<br>typedef char eleType; // 定义链表中的数据类型<br>typedef struct listnode { // 定义单链表结构<br>eleType data;<br>struct listnode *next;<br>}node;</p><p>node *create(int n) { // 创建单链表，n为节点个数<br>node *p = (node *)malloc(sizeof(node));<br>node *head = p; head-&gt;data = ‘A’;<br>for(int i=’B’; i&lt;’A’+n; i++) {<br>p = (p-&gt;next = (node *)malloc(sizeof(node)));<br>p-&gt;data = i;<br>p-&gt;next = NULL;<br>}<br>return head;<br>}</p><p>void addCircle(node *head, int n) { // 增加环，将链尾指向链中第n个节点<br>node *q, *p = head;<br>for(int i=1; p-&gt;next; i++) {<br>if(i==n) q = p;<br>p = p-&gt;next;<br>}<br>p-&gt;next = q;<br>}</p><p>int isCircle(node *head) { // 这是笔试时需要写的最主要函数，其他函数可以不写<br>node *p=head,*q=head;<br>while( p-&gt;next &amp;&amp; q-&gt;next) {<br>p = p-&gt;next;<br>if (NULL == (q=q-&gt;next-&gt;next)) return 0;<br>if (p == q) return 1;<br>}<br>return 0;<br>}</p><p>int main(int argc, char* argv[]) {<br>node *head = create(12);<br>addCircle(head, 8); // 注释掉此行，连表就没有环了<br>printf(“%d\n”, isCircle(head));<br>}</p><ol start="4"><li>算法与编程</li><li>判断身份证：要么是15位，要么是18位，最后一位可以为字母，并写程序提出其中的年月日。<br>答：我们可以用正则表达式来定义复杂的字符串格式，(\d{17}[0-9a-zA-Z]|\d{14}[0-9a-zA-Z])可以用来判断是否为合法的15位或18位身份证号码。<br>因为15位和18位的身份证号码都是从7位到第12位为身份证为日期类型。这样我们可以设计出更精确的正则模式，使身份证号的日期合法，这样我们的正则模式可以进一步将日期部分的正则修改为[12][0-9]{3}[01][0-9][123][0-9]，当然可以更精确的设置日期。<br>在jdk的java.util.Regex包中有实现正则的类,Pattern和Matcher。以下是实现代码：</li></ol><p>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;</p><p>public class RegexTest {</p><pre><code>/**
 * @param args
 */
public static void main(String[] args) &#123;
    
    // 测试是否为合法的身份证号码
    String[] strs = &#123; &quot;130681198712092019&quot;, &quot;13068119871209201x&quot;,
            &quot;13068119871209201&quot;, &quot;123456789012345&quot;, &quot;12345678901234x&quot;,
            &quot;1234567890123&quot; &#125;;
    Pattern p1 = Pattern.compile(&quot;(\\d&#123;17&#125;[0-9a-zA-Z]|\\d&#123;14&#125;[0-9a-zA-Z])&quot;);
    for (int i = 0; i &lt; strs.length; i++) &#123;
        Matcher matcher = p1.matcher(strs[i]);
        System.out.println(strs[i] + &quot;:&quot; + matcher.matches());
    &#125;

    Pattern p2 = Pattern.compile(&quot;\\d&#123;6&#125;(\\d&#123;8&#125;).*&quot;); // 用于提取出生日字符串
    Pattern p3 = Pattern.compile(&quot;(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)&quot;);// 用于将生日字符串进行分解为年月日
    for (int i = 0; i &lt; strs.length; i++) &#123;
        Matcher matcher = p2.matcher(strs[i]);
        boolean b = matcher.find();
        if (b) &#123;
            String s = matcher.group(1);
            Matcher matcher2 = p3.matcher(s);
            if (matcher2.find()) &#123;
                System.out
                        .println(&quot;生日为&quot; + matcher2.group(1) + &quot;年&quot;
                                + matcher2.group(2) + &quot;月&quot;
                                + matcher2.group(3) + &quot;日&quot;);
            &#125;
        &#125;

    &#125;

&#125;
</code></pre><p>}</p><p>1、编写一个程序，将a.txt文件中的单词与b.txt文件中的单词交替合并到c.txt文件中，a.txt文件中的单词用回车符分隔，b.txt文件中用回车或空格进行分隔。<br>答：<br>package cn.itcast;</p><p>import java.io.File;<br>import java.io.FileReader;<br>import java.io.FileWriter;</p><p>public class MainClass{<br>public static void main(String[] args) throws Exception{<br>FileManager a = new FileManager(“a.txt”,new char[]{‘\n’});<br>FileManager b = new FileManager(“b.txt”,new char[]{‘\n’,’ ‘});<br>FileWriter c = new FileWriter(“c.txt”);<br>String aWord = null;<br>String bWord = null;<br>while((aWord = a.nextWord()) !=null ){<br>c.write(aWord + “\n”);<br>bWord = b.nextWord();<br>if(bWord != null)<br>c.write(bWord + “\n”);<br>}</p><pre><code>    while((bWord = b.nextWord()) != null)&#123;
        c.write(bWord + &quot;\n&quot;);
    &#125;    
    c.close();
&#125;
</code></pre><p>}</p><p>class FileManager{</p><pre><code>String[] words = null;
int pos = 0;
public FileManager(String filename,char[] seperators) throws Exception&#123;
    File f = new File(filename);
    FileReader reader = new FileReader(f);
    char[] buf = new char[(int)f.length()];
    int len = reader.read(buf);
    String results = new String(buf,0,len);
    String regex = null;
    if(seperators.length &gt;1 )&#123;
        regex = &quot;&quot; + seperators[0] + &quot;|&quot; + seperators[1];
    &#125;else&#123;
        regex = &quot;&quot; + seperators[0];
    &#125;
    words = results.split(regex);
&#125;

public String nextWord()&#123;
    if(pos == words.length)
        return null;
    return words[pos++];
&#125;
</code></pre><p>}</p><p>1、编写一个程序，将d:\java目录下的所有.java文件复制到d:\jad目录下，并将原来文件的扩展名从.java改为.jad。<br>（大家正在做上面这道题，网上迟到的朋友也请做做这道题，找工作必须能编写这些简单问题的代码！）<br>答：listFiles方法接受一个FileFilter对象，这个FileFilter对象就是过虑的策略对象，不同的人提供不同的FileFilter实现，即提供了不同的过滤策略。<br>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.FilenameFilter;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.OutputStream;</p><p>public class Jad2Java {</p><pre><code>public static void main(String[] args) throws Exception &#123;
    File srcDir = new File(&quot;java&quot;);
    if(!(srcDir.exists() &amp;&amp; srcDir.isDirectory()))
            throw new Exception(&quot;目录不存在&quot;);
    File[] files = srcDir.listFiles(
        new FilenameFilter()&#123;

                public boolean accept(File dir, String name) &#123;
                    return name.endsWith(&quot;.java&quot;);
                &#125;
                
            &#125;
    );
    
    System.out.println(files.length);
    File destDir = new File(&quot;jad&quot;);
    if(!destDir.exists()) destDir.mkdir();
    for(File f :files)&#123;
        FileInputStream  fis = new FileInputStream(f);
        String destFileName = f.getName().replaceAll(&quot;\\.java$&quot;, &quot;.jad&quot;);
        FileOutputStream fos = new FileOutputStream(new File(destDir,destFileName));
        copy(fis,fos);
        fis.close();
        fos.close();
    &#125;
&#125;

private static void copy(InputStream ips,OutputStream ops) throws Exception&#123;
    int len = 0;
    byte[] buf = new byte[1024];
    while((len = ips.read(buf)) != -1)&#123;
        ops.write(buf,0,len);
    &#125;

&#125;
</code></pre><p>}</p><p>由本题总结的思想及策略模式的解析：<br>1.<br>class jad2java{<br>1. 得到某个目录下的所有的java文件集合<br>1.1 得到目录 File srcDir = new File(“d:\java”);<br>1.2 得到目录下的所有java文件：File[] files = srcDir.listFiles(new MyFileFilter());<br>1.3 只想得到.java的文件： class MyFileFilter implememyts FileFilter{<br>public boolean accept(File pathname){<br>return pathname.getName().endsWith(“.java”)<br>}<br>}</p><pre><code>2.将每个文件复制到另外一个目录，并改扩展名
    2.1 得到目标目录，如果目标目录不存在，则创建之
    2.2 根据源文件名得到目标文件名，注意要用正则表达式，注意.的转义。
    2.3 根据表示目录的File和目标文件名的字符串，得到表示目标文件的File。
        //要在硬盘中准确地创建出一个文件，需要知道文件名和文件的目录。 
    2.4 将源文件的流拷贝成目标文件流，拷贝方法独立成为一个方法，方法的参数采用抽象流的形式。
        //方法接受的参数类型尽量面向父类，越抽象越好，这样适应面更宽广。    
</code></pre><p>}</p><p>分析listFiles方法内部的策略模式实现原理<br>File[] listFiles(FileFilter filter){<br>File[] files = listFiles();<br>//Arraylist acceptedFilesList = new ArrayList();<br>File[] acceptedFiles = new File[files.length];<br>int pos = 0;<br>for(File file: files){<br>boolean accepted = filter.accept(file);<br>if(accepted){<br>//acceptedFilesList.add(file);<br>acceptedFiles[pos++] = file;<br>}<br>}</p><pre><code>Arrays.copyOf(acceptedFiles,pos);
//return (File[])accpetedFilesList.toArray();
</code></pre><p>}<br>1、编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。<br>答：<br>首先要了解中文字符有多种编码及各种编码的特征。<br>假设n为要截取的字节数。<br>public static void main(String[] args) throws Exception{<br>String str = “我a爱中华abc我爱传智def’;<br>String str = “我ABC汉”;<br>int num = trimGBK(str.getBytes(“GBK”),5);<br>System.out.println(str.substring(0,num) );<br>}</p><pre><code>public static int  trimGBK(byte[] buf,int n)&#123;
    int num = 0;
    boolean bChineseFirstHalf = false;
    for(int i=0;i&lt;n;i++)
    &#123;
        if(buf[i]&lt;0 &amp;&amp; !bChineseFirstHalf)&#123;
            bChineseFirstHalf = true;
        &#125;else&#123;
            num++;
            bChineseFirstHalf = false;                
        &#125;
    &#125;
    return num;
&#125;
</code></pre><p>1、有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数。<br>答：哈哈，其实包含中文字符、英文字符、数字字符原来是出题者放的烟雾弹。<br>String content = “中国aadf的111萨bbb菲的zz萨菲”;<br>HashMap map = new HashMap();<br>for(int i=0;i&lt;content.length;i++)<br>{<br>char c = content.charAt(i);<br>Integer num = map.get(c);<br>if(num == null)<br>num = 1;<br>else<br>num = num + 1;<br>map.put(c,num);<br>}<br>for(Map.EntrySet entry : map)<br>{<br>system.out.println(entry.getkey() + “:” + entry.getValue());<br>}<br>估计是当初面试的那个学员表述不清楚，问题很可能是：<br>如果一串字符如”aaaabbc中国1512”要分别统计英文字符的数量，中文字符的数量，和数字字符的数量，假设字符中没有中文字符、英文字符、数字字符之外的其他特殊字符。<br>int engishCount;<br>int chineseCount;<br>int digitCount;<br>for(int i=0;i&lt;str.length;i++)<br>{<br>char ch = str.charAt(i);<br>if(ch&gt;=’0’ &amp;&amp; ch&lt;=’9’)<br>{<br>digitCount++<br>}<br>else if((ch&gt;=’a’ &amp;&amp; ch&lt;=’z’) || (ch&gt;=’A’ &amp;&amp; ch&lt;=’Z’))<br>{<br>engishCount++;<br>}<br>else<br>{<br>chineseCount++;<br>}<br>}<br>System.out.println(……………);</p><p>1、说明生活中遇到的二叉树，用java实现二叉树<br>这是组合设计模式。<br>我有很多个(假设10万个)数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据，（我想说出二叉树的好处，该怎么说呢？那就是说别人的缺点），假如存在数组中，那么，碰巧要找的数字位于99999那个地方，那查找的速度将很慢，因为要从第1个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序，中序，后序）效率要比数组低很多，原理如下图：</p><p>代码如下：<br>package com.huawei.interview;</p><p>public class Node {<br>public int value;<br>public Node left;<br>public Node right;</p><pre><code>public void store(int value)
&#123;
    if(value&lt;this.value)
    &#123;
        if(left == null)
        &#123;
            left = new Node();
            left.value=value;
        &#125;
        else
        &#123;
            left.store(value);
        &#125;
    &#125;
    else if(value&gt;this.value)
    &#123;
        if(right == null)
        &#123;
            right = new Node();
            right.value=value;
        &#125;
        else
        &#123;
            right.store(value);
        &#125;            
    &#125;
&#125;

public boolean find(int value)
&#123;    
    System.out.println(&quot;happen &quot; + this.value);
    if(value == this.value)
    &#123;
        return true;
    &#125;
    else if(value&gt;this.value)
    &#123;
        if(right == null) return false;
        return right.find(value);
    &#125;else
    &#123;
        if(left == null) return false;
        return left.find(value);
    &#125;

&#125;

public  void preList()
&#123;
    System.out.print(this.value + &quot;,&quot;);
    if(left!=null) left.preList();
    if(right!=null) right.preList();
&#125;

public void middleList()
&#123;
    if(left!=null) left.preList();
    System.out.print(this.value + &quot;,&quot;);
    if(right!=null) right.preList();        
&#125;
public void afterList()
&#123;
</code></pre><p>if(left!=null) left.preList();<br>if(right!=null) right.preList();<br>System.out.print(this.value + “,”);<br>}<br>public static void main(String [] args)<br>{<br>int [] data = new int[20];<br>for(int i=0;i&lt;data.length;i++)<br>{<br>data[i] = (int)(Math.random()*100) + 1;<br>System.out.print(data[i] + “,”);<br>}<br>System.out.println();</p><pre><code>    Node root = new Node();
    root.value = data[0];
    for(int i=1;i&lt;data.length;i++)
    &#123;
        root.store(data[i]);
    &#125;
    
    root.find(data[19]);
    
    root.preList();
    System.out.println();
    root.middleList();
    System.out.println();        
    root.afterList();
&#125;
</code></pre><p>}<br>—————–又一次临场写的代码—————————<br>import java.util.Arrays;<br>import java.util.Iterator;</p><p>public class Node {<br>private Node left;<br>private Node right;<br>private int value;<br>//private int num;</p><pre><code>public Node(int value)&#123;
    this.value = value;
&#125;
public void add(int value)&#123;
    
    if(value &gt; this.value)
    &#123;
        if(right != null)
            right.add(value);
        else
        &#123;
            Node node = new Node(value);                
            right = node;
        &#125;
    &#125;
    else&#123;
        if(left != null)
            left.add(value);
        else
        &#123;
            Node node = new Node(value);                
            left = node;
        &#125;            
    &#125;
&#125;

public boolean find(int value)&#123;
    if(value == this.value) return true;
    else if(value &gt; this.value)&#123;
        if(right == null) return false;
        else return right.find(value);
    &#125;else&#123;
        if(left == null) return false;
        else return left.find(value);            
    &#125;

&#125;

public void display()&#123;
    System.out.println(value);
    if(left != null) left.display();
    if(right != null) right.display();
    
&#125;

/*public Iterator iterator()&#123;
    
&#125;*/

public static void main(String[] args)&#123;
    int[] values = new int[8];
    for(int i=0;i&lt;8;i++)&#123;
        int num = (int)(Math.random() * 15);
        //System.out.println(num);
        //if(Arrays.binarySearch(values, num)&lt;0)
        if(!contains(values,num))
            values[i] = num;
        else
            i--;
    &#125;
    
    System.out.println(Arrays.toString(values));
    
    Node root  = new Node(values[0]);
    for(int i=1;i&lt;values.length;i++)&#123;
        root.add(values[i]);
    &#125;
    
    System.out.println(root.find(13));
    
    root.display();
    
&#125;

public static boolean contains(int [] arr, int value)&#123;
    int i = 0;
    for(;i&lt;arr.length;i++)&#123;
        if(arr[i] == value) return true;
        
    &#125;
    return false;
&#125;
</code></pre><p>}<br>1、从类似如下的文本文件中读取出所有的姓名，并打印出重复的姓名和重复的次数，并按重复次数排序：<br>1,张三,28<br>2,李四,35<br>3,张三,28<br>4,王五,35<br>5,张三,28<br>6,李四,35<br>7,赵六,28<br>8,田七,35</p><p>程序代码如下（答题要博得用人单位的喜欢，包名用该公司，面试前就提前查好该公司的网址，如果查不到，现场问也是可以的。还要加上实现思路的注释）：<br>package com.huawei.interview;</p><p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.InputStreamReader;<br>import java.util.Comparator;<br>import java.util.HashMap;<br>import java.util.Iterator;<br>import java.util.Map;<br>import java.util.TreeSet;</p><p>public class GetNameTest {</p><pre><code>/**
 * @param args
 */
public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    //InputStream ips = GetNameTest.class.getResourceAsStream(&quot;/com/huawei/interview/info.txt&quot;);
    //用上一行注释的代码和下一行的代码都可以，因为info.txt与GetNameTest类在同一包下面，所以，可以用下面的相对路径形式
    
    Map results = new HashMap();
    InputStream ips = GetNameTest.class.getResourceAsStream(&quot;info.txt&quot;);
    BufferedReader in = new BufferedReader(new InputStreamReader(ips));
    String line = null;
    try &#123;
        while((line=in.readLine())!=null)
        &#123;
            dealLine(line,results);
        &#125;
        sortResults(results);
    &#125; catch (IOException e) &#123;
        // TODO Auto-generated catch block
        e.printStackTrace();
    &#125;
&#125;

static class User
&#123;
    public  String name;
    public Integer value;
    public User(String name,Integer value)
    &#123;
        this.name = name;
        this.value = value;
    &#125;

    @Override
    public boolean equals(Object obj) &#123;
        // TODO Auto-generated method stub
            
        //下面的代码没有执行，说明往treeset中增加数据时，不会使用到equals方法。
        boolean result = super.equals(obj);
        System.out.println(result);
        return result;
    &#125;
&#125;

private static void sortResults(Map results) &#123;
    // TODO Auto-generated method stub
    TreeSet sortedResults = new TreeSet(
            new Comparator()&#123;
                public int compare(Object o1, Object o2) &#123;
                    // TODO Auto-generated method stub
                    User user1 = (User)o1;
                    User user2 = (User)o2;
                    /*如果compareTo返回结果0，则认为两个对象相等，新的对象不会增加到集合中去
                     * 所以，不能直接用下面的代码，否则，那些个数相同的其他姓名就打印不出来。
                     * */
                    
                    //return user1.value-user2.value;
                    //return user1.value&lt;user2.value?-1:user1.value==user2.value?0:1;
                    if(user1.value&lt;user2.value)
                    &#123;
                        return -1;
                    &#125;else if(user1.value&gt;user2.value)
                    &#123;
                        return 1;
                    &#125;else
                    &#123;
                        return user1.name.compareTo(user2.name);
                    &#125;
                &#125;
                
            &#125;
    );
    Iterator iterator = results.keySet().iterator();
    while(iterator.hasNext())
    &#123;
        String name = (String)iterator.next();
        Integer value = (Integer)results.get(name);
        if(value &gt; 1)
        &#123;                
            sortedResults.add(new User(name,value));                
        &#125;
    &#125;
    
    printResults(sortedResults);
&#125;
private static void printResults(TreeSet sortedResults) 
&#123;
    Iterator iterator  = sortedResults.iterator();
    while(iterator.hasNext())
    &#123;
        User user = (User)iterator.next();
        System.out.println(user.name + &quot;:&quot; + user.value);
    &#125;    
&#125;
public static void dealLine(String line,Map map)
&#123;
    if(!&quot;&quot;.equals(line.trim()))
    &#123;
        String [] results = line.split(&quot;,&quot;);
        if(results.length == 3)
        &#123;
            String name = results[1];
            Integer value = (Integer)map.get(name);
            if(value == null) value = 0;
            map.put(name,value + 1);
        &#125;
    &#125;
&#125;
</code></pre><p>}<br>48、写一个Singleton出来。<br>第一种：饱汉模式<br>public class SingleTon {<br>private SingleTon(){<br>}</p><pre><code>//实例化放在静态代码块里可提高程序的执行效率，但也可能更占用空间    
private final static SingleTon instance = new SingleTon();
public static SingleTon getInstance()&#123;
    return instance;
&#125;
</code></pre><p>}</p><p>第二种：饥汉模式<br>public class SingleTon {<br>private SingleTon(){}</p><pre><code>private static instance = null;//new SingleTon();

public static synchronized SingleTon getInstance()&#123;
    if(instance == null)
        instance = new SingleTon();
    return instance;
&#125;
</code></pre><p>}</p><p>第三种：用枚举<br>public enum SingleTon{<br>ONE;</p><pre><code>&#125;
</code></pre><p>第三：更实际的应用（在什么情况用单例）<br>public class SequenceGenerator{<br>//下面是该类自身的业务功能代码<br>private int count = 0;</p><pre><code>public synchronized int getSequence()&#123;
    ++count;
&#125;

//下面是把该类变成单例的代码
private SequenceGenerator()&#123;&#125;
private final static instance = new SequenceGenerator();
public static SingleTon getInstance()&#123;
    return instance;
&#125;    
</code></pre><p>}</p><p>第四：<br>public class MemoryDao<br>{<br>private HashMap map = new HashMap();</p><pre><code>   public void add(Student stu1)&#123; 
        map.put(SequenceGenerator.getInstance().getSequence(),stu1);
&#125;
</code></pre><p>//把MemoryDao变成单例<br>}</p><p>Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。<br>一般Singleton模式通常有几种种形式:<br>第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。<br>public class Singleton {<br>private Singleton(){}<br>　　 //在自己内部定义自己一个实例，是不是很奇怪？<br>　　 //注意这是private 只供内部调用<br>　　 private static Singleton instance = new Singleton();<br>　　 //这里提供了一个供外部访问本class的静态方法，可以直接访问　　<br>　　 public static Singleton getInstance() {<br>　　　　 return instance; 　　<br>　　 }<br>}<br>第二种形式:<br>public class Singleton {<br>　　private static Singleton instance = null;<br>　　public static synchronized Singleton getInstance() {<br>　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　 　<br>　　//使用时生成实例，提高了效率！<br>　　if (instance==null)<br>　　　　instance＝new Singleton();<br>return instance; 　　<br>}<br>}<br>其他形式:<br>定义一个类，它的构造函数为private的，所有方法为static的。<br>一般认为第一种形式要更加安全些<br>7、递归算法题1<br>一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。<br>例：n=1237<br>则输出为：<br>1237，<br>2474，<br>4948，<br>9896，<br>9896，<br>4948，<br>2474，<br>1237，<br>提示：写程序时，先致谢按递增方式的代码，写好递增的以后，再增加考虑递减部分。<br>public static void doubleNum(int n)<br>{<br>System.out.println(n);<br>if(n&lt;=5000)<br>doubleNum(n*2);<br>System.out.println(n);<br>}</p><p>7、递归算法题2<br>第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？<br>package cn.itcast;</p><p>import java.util.Date;</p><p>public class A1 {</p><pre><code>public static void main(String [] args)
&#123;
    System.out.println(computeAge(8));
&#125;

public static int computeAge(int n)
&#123;
    if(n==1) return 10;
    return computeAge(n-1) + 2;
&#125;
</code></pre><p>}</p><pre><code>public static void toBinary(int n,StringBuffer result)
&#123;

    if(n/2 != 0)
        toBinary(n/2,result);
    result.append(n%2);        
&#125;
</code></pre><p>94、排序都有哪几种方法？请列举。用JAVA实现一个快速排序。<br>本人只研究过冒泡排序、选择排序和快速排序，下面是快速排序的代码：<br>public class QuickSort {<br>/**</p><ul><li>快速排序</li><li>@param strDate</li><li>@param left</li><li>@param right</li><li>/<br>public void quickSort(String[] strDate,int left,int right){<br>String middle,tempDate;<br>int i,j;<br>i=left;<br>j=right;<br>middle=strDate[(i+j)/2];<br>do{<br>while(strDate[i].compareTo(middle)&lt;0&amp;&amp; i&lt;right)<br>i++; //找出左边比中间值大的数<br>while(strDate[j].compareTo(middle)&gt;0&amp;&amp; j&gt;left)<br>j–; //找出右边比中间值小的数<br>if(i&lt;=j){ //将左边大的数和右边小的数进行替换<br>tempDate=strDate[i];<br>strDate[i]=strDate[j];<br>strDate[j]=tempDate;<br>i++;<br>j–;<br>}<br>}while(i&lt;=j); //当两者交错时停止</li></ul><p>if(i&lt;right){<br>quickSort(strDate,i,right);//从<br>}<br>if(j&gt;left){<br>quickSort(strDate,left,j);<br>}<br>}<br>/**<br>  * @param args<br>  */<br>public static void main(String[] args){<br>String[] strVoid=new String[]{“11”,”66”,”22”,”0”,”55”,”22”,”0”,”32”};<br>QuickSort sort=new QuickSort();<br>sort.quickSort(strVoid,0,strVoid.length-1);<br>for(int i=0;i&lt;strVoid.length;i++){<br>System.out.println(strVoid[i]+” “);<br>}<br>}</p><p>}<br>7、有数组a[n]，用java代码将数组元素顺序颠倒<br>//用下面的也可以<br>//for(int i=0,int j=a.length-1;i&lt;j;i++,j–) 是否等效于 for(int i=0;i&lt;a.length/2;i++)呢？</p><p>import java.util.Arrays;</p><p>public class SwapDemo{</p><pre><code>public static void main(String[] args)&#123;
    int [] a = new int[]&#123;
                    (int)(Math.random() * 1000),
                    (int)(Math.random() * 1000),
                    (int)(Math.random() * 1000),
                    (int)(Math.random() * 1000),                        
                    (int)(Math.random() * 1000)                                                                        
    &#125;;    
    
    System.out.println(a);
    System.out.println(Arrays.toString(a));
    swap(a);
    System.out.println(Arrays.toString(a));        
&#125;

public static void swap(int a[])&#123;
    int len = a.length;
    for(int i=0;i&lt;len/2;i++)&#123;
        int tmp = a[i];
        a[i] = a[len-1-i];
        a[len-1-i] = tmp;
    &#125;
&#125;
</code></pre><p>}<br>2．金额转换，阿拉伯数字的金额转换成中国传统的形式如：（￥1011）－&gt;（一千零一拾一元整）输出。<br>去零的代码：<br>return sb.reverse().toString().replaceAll(“零[拾佰仟]”,”零”).replaceAll(“零+万”,”万”).replaceAll(“零+元”,”元”).replaceAll(“零+”,”零”);</p><p>public class RenMingBi {</p><pre><code>/**
 * @param args add by zxx ,Nov 29, 2008
 */
private static final char[] data = new char[]&#123;
        &#39;零&#39;,&#39;壹&#39;,&#39;贰&#39;,&#39;叁&#39;,&#39;肆&#39;,&#39;伍&#39;,&#39;陆&#39;,&#39;柒&#39;,&#39;捌&#39;,&#39;玖&#39;
    &#125;; 
private static final char[] units = new char[]&#123;
    &#39;元&#39;,&#39;拾&#39;,&#39;佰&#39;,&#39;仟&#39;,&#39;万&#39;,&#39;拾&#39;,&#39;佰&#39;,&#39;仟&#39;,&#39;亿&#39;
&#125;;
public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    System.out.println(
            convert(135689123));
&#125;

public static String convert(int money)
&#123;
    StringBuffer sbf = new StringBuffer();
    int unit = 0;
    while(money!=0)
    &#123;
        sbf.insert(0,units[unit++]);
        int number = money%10;
        sbf.insert(0, data[number]);
        money /= 10;
    &#125;

    return sbf.toString();
&#125;
</code></pre><p>}<br>5. html&amp;JavaScript&amp;ajax部分</p><ol><li>判断第二个日期比第一个日期大<br>如何用脚本判断用户输入的的字符串是下面的时间格式2004-11-21 必须要保证用户的输入是此格式，并且是时间，比如说月份不大于12等等，另外我需要用户输入两个，并且后一个要比前一个晚，只允许用JAVASCRIPT，请详细帮助作答，,<br>//这里可用正则表达式判断提前判断一下格式，然后按下提取各时间字段内容<script type="text/javascript">function compareDate(e,t){var n=e.split("-"),a=new Date(n[0],n[1],n[2]),r=t.split("-");return!(a>new Date(r[0],r[1],r[2]))}function verifyDate(e){return/^\d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2]\d|3[0-1])$/.test(e)}window.onload=function(){document.getElementById("frm1").onsubmit=function(){var e=this.d1.value,t=this.d2.value;return verifyDate(e)?verifyDate(t)?compareDate(e,t)?void 0:(alert("第二个日期比第一日期小"),!1):(alert("第二个日期格式不对"),!1):(alert("第一个日期格式不对"),!1)}}</script></li></ol><form id="frm1" action="xxx.html"><input type="text" name="d1"> <input type="text" name="d2"> <input type="submit"></form>140、编程：编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取 的字符串。 但是要保证汉字不 被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC 汉 DEF”，6，应该输出为“我 ABC”而不是“我ABC+汉的半 个”。 答：代码如下： package test;<p>class SplitString</p><p>{<br>String SplitStr;<br>int SplitByte;<br>public SplitString(String str,int bytes)<br>{</p><p>SplitStr=str;</p><p>———- 15 ———-</p><p>*** JAVA面试题.txt ***<br>SplitByte=bytes;<br>System.out.println(“The String is:’”+SplitStr+”‘;SplitBytes=”+SplitByte);<br>}<br>public void SplitIt()<br>{<br>int loopCount;</p><p>loopCount=(SplitStr.length()%SplitByte==0)?(SplitStr.length()/SplitByte):(SplitStr.length()/Split</p><p>Byte+1);<br>System.out.println(“Will Split into “+loopCount);<br>for (int i=1;i&lt;=loopCount ;i++ )<br>{</p><p>if (i==loopCount){</p><p>System.out.println(SplitStr.substring((i-1)*SplitByte,SplitStr.length()));<br>} else {</p><p>System.out.println(SplitStr.substring((i-1)<em>SplitByte,(i</em>SplitByte)));<br>}</p><p>}<br>}<br>public static void main(String[] args)<br>{</p><p>SplitString ss = new SplitString(“test中 dd文 dsaf中男大 3443n中国43 中国人</p><p>0ewldfls=103”,4);<br>ss.SplitIt();<br>}<br>}</p><p>143、ORACLE 大数据量下的分页解决方法。一般用截取 ID方法，还有是三层嵌套方法。<br>答:一种分页方法<br>&lt;%</p><p>int i=1;<br>int numPages=14;<br>String pages = request.getParameter(“page”) ;<br>int currentPage = 1;<br>currentPage=(pages==null)?(1):{Integer.parseInt(pages)}<br>sql = “select count(*) from tables”;<br>ResultSet rs = DBLink.executeQuery(sql) ;<br>while(rs.next()) i = rs.getInt(1) ;<br>int intPageCount=1;<br>intPageCount=(i%numPages==0)?(i/numPages):(i/numPages+1);<br>int nextPage ;<br>int upPage;<br>nextPage = currentPage+1; if (nextPage&gt;=intPageCount) nextPage=intPageCount;<br>upPage = currentPage-1;<br>if (upPage&lt;=1) upPage=1;</p><p>———- 17 ———-</p><p>*** JAVA面试题.txt ***<br>rs.close();<br>sql=”select * from tables”;<br>rs=DBLink.executeQuery(sql);<br>i=0;<br>while((i&lt;numPages*(currentPage-1))&amp;&amp;rs.next()){i++;}<br>%&gt;<br>//输出内容<br>//输出翻页连接<br>合计:&lt;%=currentPage%&gt;/&lt;%=intPageCount%&gt;<a href="List.jsp?page=1">第一页</a>&lt;a</p><p>href=”List.jsp?page=&lt;%=upPage%&gt;”&gt;上一页</p><p>&lt;%<br>for(int j=1;j&lt;=intPageCount;j++){<br>if(currentPage!=j){</p><p>%&gt;<br><a href="list.jsp?page=<%=j%>">[&lt;%=j%&gt;]</a></p><p>&lt;%<br>}else{<br>out.println(j);<br>}<br>}</p><p>%&gt;<br><a href="List.jsp?page=<%=nextPage%>">下 一 页 </a><a href="List.jsp?page=<%=intPageCount%>">最后页</a></p><p>144、用 jdom解析xml 文件时如何解决中文问题?如何解析?<br>答:看如下代码,用编码方式加以解决<br>package test;<br>import java.io.*;<br>public class DOMTest<br>{</p><p>private String inFile = “c:\people.xml”;<br>private String outFile = “c:\people.xml”;<br>public static void main(String args[])<br>{</p><p>new DOMTest();</p><p>}<br>public DOMTest()<br>{</p><p>try<br>{<br>javax.xml.parsers.DocumentBuilder builder =</p><p>javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder();<br>org.w3c.dom.Document doc = builder.newDocument();<br>org.w3c.dom.Element root = doc.createElement(“老师”);<br>org.w3c.dom.Element wang = doc.createElement(“王”);</p><p>org.w3c.dom.Element liu = doc.createElement(“刘”);<br>wang.appendChild(doc.createTextNode(“我是王老师”));<br>root.appendChild(wang);<br>doc.appendChild(root);<br>javax.xml.transform.Transformer transformer =</p><p>javax.xml.transform.TransformerFactory.newInstance().newTransformer();<br>transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, “gb2312”);<br>transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, “yes”);</p><p>transformer.transform(new javax.xml.transform.dom.DOMSource(doc),<br>new</p><p>javax.xml.transform.stream.StreamResult(outFile));<br>}<br>catch (Exception e)<br>{<br>System.out.println (e.getMessage());<br>}<br>}<br>}</p><p>下面的程序代码输出的结果是多少？<br>public class smallT<br>{<br>public static void main(String args[])<br>{<br>smallT t = new smallT();<br>int b = t.get();<br>System.out.println(b);<br>}</p><pre><code>public int  get()
&#123;
    try
    &#123;
        return 1 ;
    &#125;
    finally
    &#123;
        return 2 ;
    &#125;
&#125;
</code></pre><p>}</p><p>返回的结果是2。<br>我可以通过下面一个例子程序来帮助我解释这个答案，从下面例子的运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。<br>在讲解答案时可以用下面的程序来帮助分析：<br>public class Test {</p><pre><code>/**
 * @param args add by zxx ,Dec 9, 2008
 */
public static void main(String[] args) &#123;
    // TODO Auto-generated method stub
    System.out.println(new Test().test());;
&#125;

int test()
&#123;
    try
    &#123;
        return func1();
    &#125;
    finally
    &#123;
        return func2();
    &#125;
&#125;

int func1()
&#123;
    System.out.println(&quot;func1&quot;);
    return 1;
&#125;
int func2()
&#123;
    System.out.println(&quot;func2&quot;);
    return 2;
&#125;    
</code></pre><p>}<br>———–执行结果—————–</p><p>func1<br>func2<br>2</p><p>结论：finally中的代码比return 和break语句后执行</p><p>1.写一段把本地文件formfile拷贝到本地文件tofile的程序<br>public class ChangeJtdToJava {<br>public static void main(String[] args) {<br>File dir = new File(“f:/jtd”);<br>// 得到d:/jtd 下的所有文件对象<br>File[] files = dir.listFiles();<br>for (File file : files) {<br>String fileName = file.getName(); // 得到文件名<br>int index = fileName.indexOf(“.”);// .的索引位置<br>String fileName2 = fileName.substring(0, index); // 不带后缀名的文件名<br>String houZui = fileName.substrinxg(index);<br>if (houZui.equals(“.jtd”)) {<br>// “f:/java/“ + fileName2 + “.java”<br>// 要移到的地方<br>file.renameTo(new File(“f:/java/“ + fileName2 + “.java”));<br>}<br>}<br>}<br>}</p><p>2.写出删除表中重复记录的语句 oracle<br>delete from people<br>where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) and rowid not in (select min(rowid) from people group by</p><p>3.JAVA实现向数据库添加一列<br>Connection con = null;<br>ResultSet rs = null;<br>Class.forName(“com.microsoft.jdbc.sqlserver.SQLServerDriver”);<br>String url=”jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=db_name”;<br>Connection con = DriverManager.getConnection(url,””,””);<br>StateManager sm =con.createStateMent();<br>String sql = “ alter table student add age int; “;<br>rs = sm.excute(sql);</p><p>4.写出删除表中重复记录的语句 oracle<br>delete from people<br>where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) and rowid not in (select min(rowid) from people group</p><p>5.用4 个0，用你所知道的数学方法计算出24<br>0的阶乘等于1 即 0！＝１那么４个0就是４了<br>又4的阶乘为２４ ４！＝２４</p><p>6.手写个程序在本页面中心弹出一个窗体，里面有学生的成绩，可以修改学生的成绩，并且可以关闭窗口，把每个要用的jsp页面显示出来。（用 JavaScript）<br>到显示页面的ShowStudentServlet<br>public void doGet(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>request.setCharacterEncoding(“gbk”);<br>response.setCharacterEncoding(“gbk”);<br>response.setContentType(“text/html”);<br>StudentDao dao=new StudentDao();<br>List<student>sts=dao.stlist();<br>request.setAttribute(“sts”, sts);<br>request.getRequestDispatcher(“/showStu.jsp”).forward(request, response);<br>}<br>学生成绩的显示页面：showStu.jsp</student></p><table><tr><th>学号</th><th>姓名</th><th>成绩</th><th>修改</th></tr><c:foreach items="${sts}" var="st"><tr><td>${st.sid}</td><td>${st.name}</td><td>${st.score}</td><td><button onclick='window.showModalDialog("UpdateStudentServlet?sid=${st.sid }&rand="+Math.random()),location.reload()'>修改</button></td></tr></c:foreach></table>请求修改的UpdateStudentServlet public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding("gbk"); response.setCharacterEncoding("gbk"); response.setContentType("text/html"); String s=request.getParameter("sid"); if(s!=null&&!s.equals("")){ StudentDao dao=new StudentDao(); Integer sid=Integer.parseInt(s); Student st=dao.findById(sid); request.setAttribute("st", st); request.getRequestDispatcher("/updateStu.jsp").forward(request, response); }else{ throw new ServletException("需要传递一个名为sid的int类型参数"); } } 可以修改成绩的页面:updateStu.jsp<base href="<%=basePath%>" target="_self"><form action="UpdateScoreServlet" method="post"><table><tr><th>编号</th><td><input type="text" name="sid" value="${st.sid }" readonly></td></tr><tr><th>姓名</th><td><input type="text" name="name" value="${st.name }" readonly></td></tr><tr><th>分数</th><td><input type="text" name="score" value="${st.score }"></td></tr><tr><td colspan="2"><input type="submit" value="修改"></td></tr></table></form>负责修改成绩的UpdateScoreServlet public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<pre><code>    request.setCharacterEncoding(&quot;gbk&quot;);
    response.setCharacterEncoding(&quot;gbk&quot;);
    response.setContentType(&quot;text/html&quot;);
    String sid=request.getParameter(&quot;sid&quot;);
    String score=request.getParameter(&quot;score&quot;);
    if(sid!=null&amp;&amp;!sid.equals(&quot;&quot;)&amp;&amp;score!=null&amp;&amp;!&quot;&quot;.equals(score))&#123;
        StudentDao dao=new StudentDao();
        Student st=new Student();
        st.setSid(Integer.parseInt(sid));
        st.setScore(Double.parseDouble(score));
        dao.update(st);
        response.getWriter().println(&quot;&lt;script type=&#39;text/javascript&#39;&gt;alert(&#39;修改成功&#39;);window.close();&lt;/script&gt;&quot;);
    &#125;
&#125;
</code></pre><p>7.用main涵数输出一到一百的和。<br>#include &lt;stdio.h&gt;<br>int main() {<br>printf(“sum:%d\n”, sum());<br>return 0;<br>}</p><p>int sum() {<br>int i;<br>int sum = 0;<br>for (i = 1; i &lt;= 100; i++)<br>sum += i;<br>return sum;<br>}<br>8.在main方法中将字符串中的。数字排序并输出 STRING A=”56.89.5.3.75.98.98.26.15.44”</p><p>String s=” 56.89.5.3.75.98.98.26.15.44”;<br>String s1[]=s. split (“.”);<br>Integer ii[]=new Integer[s1.length];<br>For(int i=0;i&lt;s1.length;i++){<br>ii[i]=Integer.parseInt(s1[i]);<br>}<br>Arrays.sort(ii);<br>for(Integer o: ii){<br>System.out.println(o+” s”);<br>}</p><p>9.用一个方法查出宜个数值类型数组的最大值，用递归方式实现<br>方法1<br>public class Test1 {<br>public static int a(int[] i,int j){<br>if(i.length-1&gt;j){<br>if(i[j]&gt;i[j+1]){<br>i[j+1]=i[j];<br>}<br>return a(i,j+1);<br>}else{<br>return i[i.length-1];<br>}<br>}</p><p>}<br>方法2 – 非递归<br>public static int test(int []num) { int x=0; int log = num.Length;for(intt=0;t&lt;log;t++){ if(num[t]&gt;x){ x=num[t]; } }return x;}</p><p>方法3 — 递归 不改变原数组中的元素<br>public static int getMax(int[]a, int index,int max){<br>int len = a.length;<br>if(len==1){<br>return a[len-1];<br>}<br>if(index==0){<br>max = a[index];<br>}<br>if(index==len){<br>return max;<br>}<br>if(max&lt;a[index]){<br>max = a[index];<br>}<br>index++;<br>return getMax(a,index,max);<br>}<br>// 测试<br>int max = getMax(new int[]{2,5,18,3,38,10,2},0,0);<br>System.out.println(max);</p><p>10.设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。<br>public class ThreadTest1{   <br>private int j;   <br>public static void main(String args[]){   <br>ThreadTest1 tt=new ThreadTest1(); <br>Inc inc=tt.new Inc();   Dec dec=tt.new Dec();   <br>for(int i=0;i &lt;2;i++){   <br>Thread t=new Thread(inc);   <br>t.start();   <br>t=new Thread(dec);  //???这个前面不要加Thread吗<br>t.start();   <br>}   <br>}   <br>private synchronized void inc(){  //???为什么要加锁呢 不加可以吗 <br>j++;   <br>System.out.println(Thread.currentThread().getName()+”-inc:”+j);   <br>}                      //???currentThread()有什么作用呢是什么方法<br>                            //???getname呢<br>private synchronized void dec(){   <br>j–;   <br>System.out.println(Thread.currentThread().getName()+”-dec:”+j);   <br>}   <br>class Inc implements Runnable{   <br>public void run(){   <br>for(int i=0;i &lt;100;i++){   <br>inc();   <br>}   <br>}   <br>}   <br>class Dec implements Runnable{   <br>public void run(){   <br>for(int i=0;i &lt;100;i++){   <br>dec();    }    }    }    }</p><p>11.定义两个变量a和b，不使用第三个变量，使两个值交换<br>public class testMain {<br>public void test(int a,int b){<br>System.out.println(“交换前a = “+a);<br>System.out.println(“交换前b = “+b);</p><pre><code>    a=a+b;
    b=a-b;
    a=a-b;
    
   System.out.println(&quot;交换后a = &quot; +a);
   System.out.print(&quot;交换后b = &quot;+b);
&#125;
public static void main(String args[])&#123;        
    new testMain().test(10,13);
&#125;
</code></pre><p>}<br>12.题目：JS树形菜单<br>&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;<br>&lt;%<br>String path = request.getContextPath();<br>String basePath = request.getScheme()+”://“+request.getServerName()+”:”+request.getServerPort()+path+”/“;<br>%&gt;</p><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><base href="<%=basePath%>"><pre><code>&lt;title&gt;My JSP &#39;scriptTree.jsp&#39; starting page&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
   function fun1()&#123;
     window.showModalDialog(&quot;$&#123;pageContext.request.contextPath&#125;/user.do?method=login&quot;,&quot;700&quot;);
     window.dialogHeight=800;
   &#125;
   function fun(isd)&#123;
   
      var tabIds=document.getElementById(isd); 
      
      if(tabIds.style.display==&#39;none&#39;)&#123;
         tabIds.style.display=&#39;inline&#39;;
      &#125;else&#123;
         tabIds.style.display=&#39;none&#39;;
      &#125;
   &#125;
&lt;/script&gt;
</code></pre></head><body><table border="2" bordercolor="green" width="75%"><tr><td onclick='fun("tableId1")'>树型菜单</td><td>菜单名称</td></tr><tr><td colspan="2"><table id="tableId1" border="2" bordercolor="red"><tr style="display:inline"><td>kongjian</td></tr><tr style="display:inline"><td><a href="">xiaoxin</a></td></tr></table></td></tr></table></body></html><p>13.将字符串str（例：”abcrepefd”）中的”rep”部分替换成”with”字符串(不能用jdk自带的replace方法)<br>答案如下:<br>public void replace(String str,String rep,String with){<br>try{<br>int i = str.indexOf(rep);<br>String s1 = str.substring(0, i);<br>String s2 = str.substring(i, rep.length()+i);<br>String s3 = str.substring(rep.length()+i, str.length());<br>s2 = with;<br>String mes = s1+s2+s3;<br>System.out.println(“替换前：”+str);<br>System.out.println(“替换后：”+mes);<br>}catch(Exception e){<br>System.out.println(“字符串”+str+”中不含有”+rep+”字符串！”);<br>}<br>}</p><p>14.Java Reflection是什么？<br>答：<br>1.JAVA反射，Reflection是Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说”自审”，并能直接操作程序的内部属性。例如，使用它能获得 Java 类中各成员的名称并显示出来;<br>2.一个简单的例子<br>import java.lang.reflect.*;<br>public class DumpMethods {<br>   public static void main(String args[]) {<br>try {<br>Class c = Class.forName(args[0]);<br>Method m[] = c.getDeclaredMethods();<br>for (int i = 0; i &lt; m.length; i++)<br>System.out.println(m.toString());<br>}<br>catch (Throwable e) {<br>System.err.println(e);<br>}<br>}}</p><p>15.1到11相加是奇数还是偶数?<br>偶数</p><p>16.一个圆上有6个点，可以连多少条直线？<br>15条线段</p><p>17.Stack堆栈，实现进栈，出栈<br>package t1;<br>public class mystack {<br>private Object[] data;<br>private int top=-1;<br>private int size;<br>public mystack()<br>{<br>data=new Object[5];<br>size=5;<br>}<br>public mystack(int size)<br>{<br>data=new Object[size];<br>this.size=size;<br>}<br>public void push(Object obj)<br>{<br>if(this.isfull())<br>{<br>return ;<br>}<br>top++;<br>data[top]=obj;<br>}<br>public Object pop() {<br>if(this.isempty())<br>{<br>return null;<br>}<br>Object obj=data[top];<br>top–;<br>return obj ;<br>}</p><pre><code>public boolean isfull()
&#123;
    if(top==data.length)
    &#123;
        return true;
    &#125;
    else
    &#123;
        return false;
    &#125;
&#125;
public boolean isempty()
&#123;
    if(top==-1)
    &#123;
        return true;
    &#125;
    else
    &#123;
        return false;
    &#125;
&#125;
</code></pre><p>}</p><p>18.每周的工作效率要提高24％，每周工作6天，那么每天工作效率要提高多少？（6％，4%,24%）<br>答：24%</p><p>19..前一天是星期一，又是第二个工作日，那么今天是星期几？<br>答：星期三</p><p>20.一个字符串中可能存在A-Z的全角字符，写一个方法把里面的全角字符转变成半角字符？<br>答：采用建立字典表进行查找转换<br>public  static String translate(String s){<br>        String qj = “ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ”;<br>        String bj = “ABCDEFGHIJKLMNOPQRSTUVWXYZ”;<br>        StringBuffer sb = new StringBuffer();<br>        for(int i=0;i&lt;s.length();i++){<br>            char c = s.charAt(i);<br>            int pos = qj.indexOf(c);<br>            if(pos&gt;=0){<br>                System.out.println(c + “,” + pos);<br>                sb.append(bj.charAt(pos));<br>            }else{<br>                sb.append(c);<br>            }<br>        }<br>        return sb.toString();<br>    }</p><p>21.写一个方法，传入一个int 型的数字，把它的四个字节码取出来，并且把它按大小顺序通过控制台输出？<br>public static void main(String[] args) {<br>        int num = -800000000;<br>        String str = Integer.toBinaryString(num); //获得num 的二进制 <br>        if(num&gt;=0) {    //如果输入的数为正数,位数可能不足32位，要补0；负数肯定是32位<br>            if(str.length()&lt;32) { //二进制不足32位，就在前面补0<br>                int n0 = 32-str.length(); //看差几个0<br>                String temp = “”;<br>                for(int i=0;i&lt;n0;i++) {<br>                    temp = temp + “0”; //拼0<br>                }<br>                str = temp + str;<br>            }<br>        }<br>        String s1 = str.substring(0, 8);<br>        String s2 = str.substring(8, 16);<br>        String s3 = str.substring(16, 24);<br>        String s4 = str.substring(24, 32);<br>        <br>        System.out.println(str);<br>        System.out.println(s1);<br>        System.out.println(s2);<br>        System.out.println(s3);<br>        System.out.println(s4);<br>        <br>        <br>        int n1=Integer.parseInt(s1,2);//以二进制把字符串解析为 10进制的数<br>        int n2=Integer.parseInt(s2,2);<br>        int n3=Integer.parseInt(s3,2);<br>        int n4=Integer.parseInt(s4,2);<br>        System.out.println(n1);<br>        System.out.println(n2);<br>        System.out.println(n3);<br>        System.out.println(n4);        //整数大小自己比较吧</p><p>    }</p><p>22.编程题:有一个数据文件:123 34 17 651234 345….这些数据都是随机产生的,编写程序读出该文件.并将其以从大到小的顺序输出到另一个文件中.<br>public void readtext(){<br>File file = new File(“D:\test.txt”);<br>List list= new ArrayList();<br>try {<br>BufferedReader br=new BufferedReader(new FileReader(file));<br>String data = “”;<br>String line = null;<br>while ( (line = br.readLine()) != null) {<br>data = data.concat(line);<br>}<br>StringTokenizer stoken = new StringTokenizer(data, “ “);<br>while (stoken.hasMoreTokens()) {<br>int i = Integer.parseInt(stoken.nextToken());<br>list.add(i);<br>}<br>} catch(Exception ex) {}<br>String[] str = new String[list.size()];<br>for(int i=0;i&lt;list.size();i++){<br>str[i]=list.get(i);<br>}<br>Object iTemp= null;<br>for(int i=1;i&lt;list.size();i++) {<br>　　 for(int j=list.size()-1;j&gt;=i;j–) {<br>　　 if(str[j]&gt;str[j-1]) {<br>　　 iTemp = str[j-1];<br>　　 str[j-1] = str[j];<br>　　 str[j] = iTemp;<br>　　 }<br>}<br>String result = “”;<br>for(int i=0;i&lt;str.length;i++){<br>result +=str[i]+” “;<br>}<br>//将result写入另外一个文件即可。<br>}</p><p>23.从一到十九共十九个数,打印出利用这十九个整数任意多个相加等于20所以可能性,每个数字在同一个算式中只出现一次.<br>public void test(){<br>Integer[] a = new Integer[19];<br>for(int i=1;i&lt;20;i++){<br>a[i-1]=i;<br>}<br>for(int i=0;i&lt;18;i++){<br>for(int j=18-i;j&lt;18;j++)<br>if(a[i]+a[j]==20)<br>System.out.println(a[i]+”+”+a[i+1]+”=”+20);<br>}<br>}<br>24.哪几个方法可以实现一个线程？<br>一种是声明 Thread 的子类,重载 Thread 类的方法 run。 另一种途径是声明一个类，该类实现 Runnable 接口。然后再实现方法 run。</p><p>25.//编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。<br>//但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6应该输出为“我ABC”而不是“我ABC+汉的半个”。</p><pre><code>
public static void main(String[] args) throws Exception&#123;
        String str = &quot;我a爱中华abc def&#39;;
        String str = &quot;我ABC汉&quot;;
        int num = trimGBK(str.getBytes(&quot;GBK&quot;),5);
        System.out.println(str.substring(0,num) );
    &#125;
    
    public static int  trimGBK(byte[] buf,int n)&#123;
        int num = 0;
        boolean bChineseFirstHalf = false;
        for(int i=0;i&lt;n;i++)
        &#123;
            if(buf[i]&lt;0 &amp;&amp; !bChineseFirstHalf)&#123;
                bChineseFirstHalf = true;
            &#125;else&#123;
                num++;
                bChineseFirstHalf = false;                
            &#125;
        &#125;
        return num;
    &#125;
</code></pre><p>26.java程序每天12点打印”hello”<br>public static void main(String[] args) {<br>Date date = new Date();<br>System.out.println(date.getHours());<br>while (true) {<br>while (date.getHours() == 12) {<br>if (date.getMinutes() == 0) {<br>if (date.getSeconds() == 0) {<br>System.out.println(“hello world!”);<br>}<br>}<br>}<br>}<br>}</p><p>27.编程题：读取一个文件在控制台打印出来<br>File file = new File(“E:\课件\二期课件\Java\T09 src\JRadioButtonDemo.java”);<br>long file_length= file.length();<br>try {<br>//输入流<br>FileInputStream input = new FileInputStream(file);<br>byte b_data [] = new byte[(int)file_length];<br>input.read(b_data);<br>System.out.println(new String(b_data));<br>input.close();<br>} catch (FileNotFoundException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (IOException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>}</p><p>28.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?<br>　也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果：<br>public class Test {<br>public static void main(String[] args) {<br>// TODO Auto-generated method stub<br>System.out.println(new Test().test());;<br>}<br>static int test()<br>{<br>int x = 1;<br>try<br>{<br>return x;<br>}<br>finally<br>{<br>++x;<br>}<br>}</p><p>}</p><p>———执行结果 ———<br>1</p><p>运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。<br>29.有一些奇数和偶数，无序的，要求写一个方法，实现将所有的奇数放在全部的偶数前面<br>主要代码如下：主要采用快速排序的算法。<br>int[] n = {1,2,5,6,4,7,10,9,3,8};<br>int m = n[0];<br>int j = n.length -1;<br>int i= 0;<br>while(i&lt;j){<br>while(i&lt;j &amp;&amp; n[j]%2==0){j–;}<br>if(j&gt;=i){<br>n[i++] = n[j];<br>}</p><pre><code>       while(i&lt;j &amp;&amp; n[i]%2!=0)&#123;i++;&#125;
       if(i&lt;=j)&#123;
           n[j--] = n[i];
       &#125;           
   &#125;
   n[i] = m;

   for(int k=0;k&lt;n.length;k++)&#123;
     System.out.print(n[k] + &quot;  &quot;);   
   &#125;
</code></pre></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/ff5236f93fe2.html" rel="prev" title="项目设计"><i class="fa fa-angle-left"></i> 项目设计</a></div><div class="post-nav-item"><a href="/publishes/64b56da2b088.html" rel="next" title="面试技巧">面试技巧 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>