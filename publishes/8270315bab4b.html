<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"defalut"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="什么是垃圾收集（GC）垃圾收集（GC），是Java虚拟机释放内存的机制，目的在于清除不再使用的对象。 GC通过确定对象是否被活动对象引用来确定是否收集该对象，判断是否可以收集的方式是对象引用遍历。对象引用遍历从一组对象（GC Root）开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象到达，则将它作为垃圾收集的目标对象。在对象遍历阶段，GC必须"><meta property="og:type" content="article"><meta property="og:title" content="Java虚拟机（JVM）"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/8270315bab4b.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="什么是垃圾收集（GC）垃圾收集（GC），是Java虚拟机释放内存的机制，目的在于清除不再使用的对象。 GC通过确定对象是否被活动对象引用来确定是否收集该对象，判断是否可以收集的方式是对象引用遍历。对象引用遍历从一组对象（GC Root）开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象到达，则将它作为垃圾收集的目标对象。在对象遍历阶段，GC必须"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:08:40.000Z"><meta property="article:modified_time" content="2024-01-09T09:20:01.677Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="JVM"><meta property="article:tag" content="GC"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/8270315bab4b.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/8270315bab4b.html","path":"publishes/8270315bab4b.html","title":"Java虚拟机（JVM）"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java虚拟机（JVM） | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%88GC%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">什么是垃圾收集（GC）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">几种垃圾回收机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sun-HotSpot-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">3.</span> <span class="nav-text">Sun HotSpot 虚拟机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="nav-number">4.</span> <span class="nav-text">堆内存分区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Major-GC%E5%92%8CFull-GC%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">Major GC和Full GC区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E2%BD%A4%E7%9A%84GC%E7%AD%96%E7%95%A5%E5%92%8C%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">6.</span> <span class="nav-text">常⽤的GC策略和触发时机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="nav-number">7.</span> <span class="nav-text">什么时候会触发一个对象的回收</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">Java中存在四种引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">9.</span> <span class="nav-text">JVM内存结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">10.</span> <span class="nav-text">垃圾收集器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">11.</span> <span class="nav-text">JVM的内存分配与回收策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E5%AF%B9%E8%B1%A1A%E5%88%9B%E5%BB%BA%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AF%B9%E8%B1%A1A%E5%9C%A8%E5%90%84%E4%B8%AA%E5%8C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">当对象A创建之后，对象A在各个区之间的流转过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">13.</span> <span class="nav-text">JVM内存模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">14.</span> <span class="nav-text">Java 中堆和栈有什么不同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="nav-number">15.</span> <span class="nav-text">JVM调优</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91full-gc%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5"><span class="nav-number">16.</span> <span class="nav-text">触发full gc的场景及应对策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BJVM%E5%86%85%E5%AD%98%E4%BD%BF%E2%BD%A4%E6%83%85%E5%86%B5"><span class="nav-number">17.</span> <span class="nav-text">如何查看JVM内存使⽤情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E2%BD%85%E6%B3%95"><span class="nav-number">18.</span> <span class="nav-text">内存溢出的可能原因和解决⽅法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">19.</span> <span class="nav-text">内存泄漏的原因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BD%85%E6%B3%95%E5%8C%BAoom"><span class="nav-number">20.</span> <span class="nav-text">⽅法区oom</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E5%AF%B9%E8%B1%A1%E4%BC%9A%E8%BF%9B%E2%BC%8A%E2%BD%BC%E5%B9%B4%E4%BB%A3"><span class="nav-number">21.</span> <span class="nav-text">哪些情况下对象会进⼊⽼年代</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SafePoint%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">22.</span> <span class="nav-text">SafePoint是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">23.</span> <span class="nav-text">简述Java垃圾回收机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AEJVM%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="nav-number">24.</span> <span class="nav-text">查看配置JVM内存信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE"><span class="nav-number">25.</span> <span class="nav-text">虚拟机设置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7"><span class="nav-number">26.</span> <span class="nav-text">调优工具</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/8270315bab4b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java虚拟机（JVM） | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java虚拟机（JVM）</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:08:40" itemprop="dateCreated datePublished" datetime="2023-12-20T15:08:40+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-09 17:20:01" itemprop="dateModified" datetime="2024-01-09T17:20:01+08:00">2024-01-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是垃圾收集（GC）"><a href="#什么是垃圾收集（GC）" class="headerlink" title="什么是垃圾收集（GC）"></a>什么是垃圾收集（GC）</h1><p>垃圾收集（GC），是Java虚拟机释放内存的机制，目的在于清除不再使用的对象。</p><p>GC通过确定对象是否被活动对象引用来确定是否收集该对象，判断是否可以收集的方式是对象引用遍历。对象引用遍历从一组对象（GC Root）开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象到达，则将它作为垃圾收集的目标对象。在对象遍历阶段，GC必须记住哪些对象可以到达，以便后续删除不可到达的对象，这个过程称为标记（marking）对象。</p><p>下一步，GC要删除不可到达的对象。删除对象分两种情况，清除和压缩。如果GC只是扫描堆栈，删除未标记的对象，并释放它们的内存，这叫做清除（sweeping），清除的问题在于会造成内存碎片，也就是内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大。如果GC将对象进行移动规整，这叫做压缩（compact），这样可以重新组织内存中的对象，避免内存碎片。</p><p>Java中可作为GC Root的对象有：虚拟机栈中引用的对象（本地变量表）、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中引用的对象（Native对象）。</p><p>有3个内存区域不需要垃圾回收：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期和线程是同步的，随着线程的销毁，他们占用的内存会自动释放。只有方法区和堆区需要进行垃圾回收。</p><h1 id="几种垃圾回收机制"><a href="#几种垃圾回收机制" class="headerlink" title="几种垃圾回收机制"></a>几种垃圾回收机制</h1><p><strong>标记-清除收集器</strong><br>这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片。</p><p><strong>标记-压缩收集器</strong><br>有时也叫标记-清除-压缩收集器，与标记-清除收集器有相同的标记阶段，在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种收集器也停止其他操作。由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。该算法适用于旧生代。</p><p><strong>复制收集器</strong><br>这种收集器将堆栈分为两个域，常称为半空间，每次仅使用一半的空间，JVM生成的新对象则放在另一半空间中，GC运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域。当存活的对象较少时，复制算法会比较高效，新生代的Eden区就是采用这种算法，其带来的成本是需要一块额外的空闲空间和对象的移动。</p><p><strong>增量收集器</strong><br>增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾，这会造成较小的应用程序中断。</p><p><strong>分代收集器</strong><br>这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象。JVM生成的新对象一般放在其中的某个域中，过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中。分代收集器对不同的域使用不同的算法以优化性能。</p><p><strong>并发收集器</strong><br>并发收集器与应用程序同时运行，这些收集器在某点上（比如压缩时）一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低。</p><p><strong>并行收集器</strong><br>并行收集器使用某种传统的算法，并使用多线程并行的执行它们的工作。</p><h1 id="Sun-HotSpot-虚拟机"><a href="#Sun-HotSpot-虚拟机" class="headerlink" title="Sun HotSpot 虚拟机"></a>Sun HotSpot 虚拟机</h1><p>Sun HotSpot 使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域。JVM生成的所有新对象放在新域中，一旦对象经历了一定数量的垃圾收集循环后，便进入旧域。在永久域中存储class和method对象。可使用<code>-Xms</code>和<code>-Xmx</code>控制整个堆的原始大小或最大值。</p><p>默认状态下，HotSpot在新域中使用复制收集器，对旧域使用标记-清除-压缩收集器。新域一般分为三个部分：Eden空间、2个救助空间。Eden用于生成新的对象，当Eden充满时，收集器停止应用程序，把所有可到达对象复制到from救助空间，一旦当前的from救助空间充满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们达到进入旧域的所需年龄并转入旧域。</p><p>在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。如果能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能只适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价。</p><h1 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h1><p>JVM中的堆，一般分为三大部分：新生代、老年代、永久代。</p><p><strong>新生代（Youn Generation）</strong><br>主要是用来存放新生的对象，一般占据堆的1&#x2F;3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。Eden区是Java新对象的出生地，但如果新创建的对象占用内存很大，则直接分配到老年代。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。ServivorTo是保留了一次MinorGC过程中的幸存者。ServivorFrom是上一次GC的幸存者，作为这一次GC的被扫描者。当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。</p><p>MinorGC的过程采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则复制到老年代区）；同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</p><p><strong>老年代（Old Generation）</strong><br>老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时，也会提前触发一次MajorGC进行垃圾回收腾出空间。MajorGC采用标记—清除算法，首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p><p><strong>永久代（Permanent Generation）</strong><br>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在被加载的时候被放入永久区域。它和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代，元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代之间最大的区别在于，元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中。这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。在Sun的JVM中就是方法区的意思，尽管大多数JVM没有这一代。</p><h1 id="Major-GC和Full-GC区别"><a href="#Major-GC和Full-GC区别" class="headerlink" title="Major GC和Full GC区别"></a>Major GC和Full GC区别</h1><p>Full GC收集young gen、old gen、perm gen；Major GC，有时又叫old gc，只收集old gen。</p><h1 id="常⽤的GC策略和触发时机"><a href="#常⽤的GC策略和触发时机" class="headerlink" title="常⽤的GC策略和触发时机"></a>常⽤的GC策略和触发时机</h1><p><strong>YGC（Young GC）</strong><br>Young GC是对新⽣代堆进⾏GC。频率⽐较⾼，因为⼤部分对象的存活寿命较短，在新⽣代⾥被回收。性能耗费较⼩。触发时机是Eden区空间不⾜。</p><p><strong>FGC（Full GC）</strong><br>Full GC是全堆范围的GC。默认堆空间使⽤到达80%(可调整)的时候会触发FGC。以我们⽣产环境为例，⼀般⽐较少会触发FGC，有时10天或⼀周左右会有⼀次。触发时机是Old空间不⾜或者Perm空间不⾜。</p><h1 id="什么时候会触发一个对象的回收"><a href="#什么时候会触发一个对象的回收" class="headerlink" title="什么时候会触发一个对象的回收"></a>什么时候会触发一个对象的回收</h1><ul><li>对象没有引用</li><li>作用域发生未捕获异常</li><li>程序在作用域正常执行完毕</li><li>程序执行了System.exit()</li><li>程序发生意外终止（被杀进程等）</li></ul><h1 id="Java中存在四种引用"><a href="#Java中存在四种引用" class="headerlink" title="Java中存在四种引用"></a>Java中存在四种引用</h1><p><strong>强引用</strong><br>只要引用存在，垃圾回收器永远不会回收。new出来的对象都是强引用，GC无论如何都不会回收，即使抛出OOM异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p><strong>软引用</strong><br>非必须引用，只有当JVM内存不足时才会被回收，内存溢出之前进行回收，可以通过以下代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">sf.get(); <span class="comment">// 有时候会返回null</span></span><br></pre></td></tr></table></figure><p>这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象。当这个对象被标记为需要回收的对象时，则返回null。软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p><p><strong>弱引用</strong><br>第二次垃圾回收时回收，可以通过如下代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wf.get(); <span class="comment">// 有时候会返回null</span></span><br><span class="line">wf.isEnQueued(); <span class="comment">// 返回是否被垃圾回收器标记为即将回收的垃圾</span></span><br></pre></td></tr></table></figure><p>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记，只要GC,就会立马回收，不管内存是否充足。</p><p><strong>虚引用（幽灵&#x2F;幻影引用）</strong><br>垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj=<span class="literal">null</span>;</span><br><span class="line">pf.get(); <span class="comment">// 永远返回null</span></span><br><span class="line">pf.isEnQueued(); <span class="comment">// 返回从内存中已经删除</span></span><br></pre></td></tr></table></figure><p>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。它唯一的作用就是做一些跟踪记录，辅助finalize函数的使用。</p><h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p>JVM把内存划分成了如下5个区域：方法区（Method Area）、堆区（Heap）、虚拟机栈（VM Stack）、本地方法栈（Native Method Stack）、程序计数器（Program Counter Register）。线程共享区域包含包括堆和方法区。线程不共享区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。</p><p><strong>方法区（Method Area）</strong><br>主要存放类与类之间关系的数据，而这部分数据被加载到内存之后，基本上是不会发生变更的。方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出<code>OutOfMemory：PermGen Space</code>异常。在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation）。一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载。方法区的数据因为回收率非常小，而成本又比较高，一般认为是“性价比”非常差的，所以Sun自己的虚拟机HotSpot中是不回收的。但是在现在高性能分布式J2EE的系统中，我们大量用到了反射、动态代理、CGLIB、JSP和OSGI等，这些类频繁的调用自定义类加载器，都需要动态的加载和卸载了，以保证永久带不会溢出，他们通过自定义的类加载器进行了各项操作，因此在实际的应用开发中，类也是被经常加载和卸载的，方法区也是会被回收的。</p><p>方法区的回收条件非常苛刻，只有同时满足以下三个条件才会被回收：该类的所有实例都已经被回收；加载该类的ClassLoad已经被回收；Class对象无法通过任何途径访问(包括反射)，该类对应的反射类java.lang.Class对象没有被任何地方引用。</p><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的<code>intern()</code>方法，作用是String类维护了一个常量池，如果调用的字符<code>&quot;hello&quot;</code>已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。保存装载的类的元信息包括类型的常量池，字段、⽅法信息，⽅法字节码。jdk6时，String等常量信息置于⽅法区，jdk7移到了堆中，通常和永久区（Perm）关联在⼀起。</p><p><strong>堆区（Heap）</strong><br>堆区是GC最频繁的，也是理解GC机制最重要的区域。堆区由所有线程共享，在虚拟机启动时创建。堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。应⽤系统对象都保存在java堆中。对分代GC来说，堆也是分代的。</p><p><strong>虚拟机栈（VM Stack）</strong><br>虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样。每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。局部变量表中存储着方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：内存空间可以在编译期间就确定，运行时不再改变。虚拟机栈定义了两种异常类型：StackOverFlowError（栈溢出）和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError，不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</p><p><strong>本地方法栈（Native Method Stack）</strong><br>本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法。在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</p><p><strong>程序计数器（Program Counter Register）(PC寄存器)</strong><br>主要用于记录线程执行的行号等一些信息，这块区域也是被认为是唯一一块不会内存溢出的区域。在SunHostSpot的虚拟机中，对于程序计数器是不回收的。每个线程拥有⼀个pc寄存器，指向下⼀条指令的地址。程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序员无法操作它。 它的作用是，JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。每个程序计数器只能记录一个线程的行号，因此它是线程私有的，如果程序当前正在执行的是一个java方法，则程序计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则计数器的值为空。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><strong>Serial收集器</strong><br>Serial收集器属于串行收集器。比较适合于只有一个处理器的系统。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，直到它回收结束为止，因此又号称“Stop The World”的垃圾回收器。串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld。在串行处理器中minor和major GC过程都是用一个线程进行回收的。</p><p><strong>ParNew收集器</strong><br>ParNew收集器其实就是多线程版本的Serial收集器。同样有Stop The World的问题，它是多CPU模式下的首选回收器，该回收器在单CPU的环境下回收效率远远低于Serial收集器。它是Server模式下的默认收集器。它可以与CMS GC配合。</p><p><strong>ParallelScavenge</strong><br>ParallelScavenge又被称为是吞吐量优先的收集器。ParallelScavenge所提到的吞吐量&#x3D;程序运行时间&#x2F;(JVM执行回收的时间+程序运行时间)，假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在交互不多的云端，比较适合使用该回收器。在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式。</p><p><strong>ParallelOld</strong><br>ParallelOld是老生代并行收集器的一种，使用标记整理算法，是老生代吞吐量优先的一个收集器。Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p><strong>SerialOld</strong><br>SerialOld是旧生代Client模式下的默认收集器，单线程执行。Serial Old是Serial收集器的老年代版本。它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。</p><p><strong>CMS</strong><br>CMS又称响应时间优先（最短回收停顿）的回收器。使用并发模式回收垃圾。CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。</p><p>CMS对CPU是非常敏感的，它的回收线程数&#x3D;（CPU+3）&#x2F;4，因此当CPU是2核的时候，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。</p><p>CMS模式主要分为4个过程。在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程。并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。CMS为了确保能够扫描到所有的对象，避免在Initial Marking中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack中，如依赖的对象地址在其之后，则仅标记该对象。在进行Concurrent Marking时minor GC也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS为了应对这样的并发现象，提供了一个Mod Union Table来进行记录，在这个Mod Union Table中记录每次minor GC后修改了的Card的信息。这也是ParallelScavenge不能和CMS一起使用的原因。由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收。</p><p>收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间。常见的B&#x2F;S架构的应用就适合这种收集器，因为其高并发、高响应的特点。CMS收集器的优点：并发收集、低停顿，但远没有达到完美。CMS收集器的缺点：CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降；CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC；</p><p><strong>GarbageFirst(G1)</strong><br>他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间。相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿。</p><h1 id="JVM的内存分配与回收策略"><a href="#JVM的内存分配与回收策略" class="headerlink" title="JVM的内存分配与回收策略"></a>JVM的内存分配与回收策略</h1><p>优先在Edon上分配对象，对象直接进入老生代。年长者（长期存活对象）进入老生代。担保GC（担保minorGC），就是担保minorGC能够满足当前的存储空间，而无需触发老生代的回收，由于大部分对象都是朝生夕死的，因此，在实际开发中这种很起效。但是也有可能会发生担保失败的情况，当担保失败的时候会触发FullGC，但是失败毕竟是少数，因此这种一般是很划算的。默认情况是是开启担保的，无需设置参数。</p><h1 id="当对象A创建之后，对象A在各个区之间的流转过程"><a href="#当对象A创建之后，对象A在各个区之间的流转过程" class="headerlink" title="当对象A创建之后，对象A在各个区之间的流转过程"></a>当对象A创建之后，对象A在各个区之间的流转过程</h1><p>对象A被new出来之后，是被存放在Eden（伊甸园）区的。当发⽣⼀次GC后，Eden区存活下来的对象A会被复制到s1区，s0中存活的对象也会被复制到s1中。如果对象年龄超过阈值年龄（默认15岁），会被复制到⽼年区。部分对象也需要⽼年代分担。GC会清空Eden和s0中存储的所有对象；交换s0和s1的⻆⾊； 重复上⾯的步骤。</p><h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>每⼀个线程有⼀个⼯作内存，和主存独⽴。⼯作内存存放主存中变量的值的拷⻉。对于普通变量，⼀个线程中更新的值，不能⻢上反应在其他变量中，如果需要在其他线程中⽴即可⻅，需要使⽤volatile关键字。volatile不能代替锁，⼀般认为volatile⽐锁性能好（不绝对）。</p><h1 id="Java-中堆和栈有什么不同"><a href="#Java-中堆和栈有什么不同" class="headerlink" title="Java 中堆和栈有什么不同"></a>Java 中堆和栈有什么不同</h1><p>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p><h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><p><strong>调优时机</strong><br>heap 内存（⽼年代）持续上涨达到设置的最⼤内存值；Full GC 次数频繁；GC 停顿时间过⻓（超过1秒）；应⽤出现OutOfMemory 等内存异常；应⽤中有使⽤本地缓存且占⽤⼤量内存空间；系统吞吐量与响应性能不⾼或下降。</p><p><strong>调优原则</strong><br>多数的Java应⽤不需要在服务器上进⾏JVM优化；多数导致GC问题的Java应⽤，都不是因为我们参数设置错误，⽽是代码问题；在应⽤上线之前，先考虑将机器的JVM参数设置到最优（最适合）；减少创建对象的数量；减少使⽤全局变量和⼤对象；JVM优化是到最后不得已才采⽤的⼿段；在实际使⽤中，分析GC情况优化代码⽐优化JVM参数更好。</p><p><strong>调优⽬标</strong><br>GC低停顿；GC低频率；低内存占⽤；⾼吞吐量。</p><p><strong>调优步骤</strong><br>分析GC⽇志及dump⽂件，判断是否需要优化，确定瓶颈问题点；确定JVM调优量化⽬标；确定JVM调优参数（根据历史JVM参数来调整）；调优⼀台服务器，对⽐观察调优前后的差异；不断的分析和调整，知道找到合适的JVM参数配置；找到最合适的参数，将这些参数应⽤到所有服务器，并进⾏后续跟踪。</p><h1 id="触发full-gc的场景及应对策略"><a href="#触发full-gc的场景及应对策略" class="headerlink" title="触发full gc的场景及应对策略"></a>触发full gc的场景及应对策略</h1><ul><li><code>System.gc()</code>⽅法的调⽤，应对策略：通过<code>-XX:+DisableExplicitGC</code>来禁⽌调⽤<code>System.gc()</code>;</li><li>⽼年代代空间不⾜，应对策略：让对象在Minor GC阶段被回收，让对象在新⽣代多存活⼀段时间，不要创建过⼤的对象及数组;</li><li>永⽣区空间不⾜，应对策略：增⼤PermGen空间；</li><li>GC时出现promotionfailed和concurrent mode failure，应对策略：增⼤survivor space；</li><li>Minor GC后晋升到旧⽣代的对象⼤⼩⼤于⽼年代的剩余空间，应对策略：增⼤Tenured space 或下调<code>CMSInitiatingOccupancyFraction=60</code>；</li><li>内存持续增涨达到上限导致Full GC，应对策略：通过dumpheap 分析是否存在内存泄漏。</li></ul><h1 id="如何查看JVM内存使⽤情况"><a href="#如何查看JVM内存使⽤情况" class="headerlink" title="如何查看JVM内存使⽤情况"></a>如何查看JVM内存使⽤情况</h1><p>可以使⽤JDK⾃带的JConsole、JVisualVM、JMap、JHat等⼯具，或者使⽤第三⽅⼯具，⽐如 Eclipse Memory Analyzer。</p><h1 id="内存溢出的可能原因和解决⽅法"><a href="#内存溢出的可能原因和解决⽅法" class="headerlink" title="内存溢出的可能原因和解决⽅法"></a>内存溢出的可能原因和解决⽅法</h1><p><strong>内存溢出原因</strong><br>数据加载过多，如一次性从数据库中取出过多数据；集合类中有对对象的引⽤，⽤完后没有清空或者集合对象未置空导致引⽤存在等，使得JVM⽆法回收；死循环，过多重复对象；启动参数内存值设定的过⼩。</p><p><strong>解决⽅法</strong><br>修改JVM启动参数，加内存(-Xms，-Xmx)；错误⽇志，是否还有其他错误；代码⾛查。</p><h1 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h1><p>未对作废数据内存单元置为null，尽早释放⽆⽤对象的引⽤，使⽤临时变量时，让引⽤变量在推出活动域后⾃动设置为null，暗示垃圾收集器收集；程序避免⽤String拼接，⽤StringBuffer，因为每个String会占⽤内存⼀块区域；尽量少⽤静态变量（全局不会回收）；不要集中创建对象尤其⼤对象，可以使⽤流操作；尽量使⽤对象池，不再循环中创建对象，优化配置；创建对象到单例getInstance中，对象⽆法回收被单例引⽤；服务器session时间设置过⻓也会引起内存泄漏。</p><h1 id="⽅法区oom"><a href="#⽅法区oom" class="headerlink" title="⽅法区oom"></a>⽅法区oom</h1><p>原因是运⾏时产⽣⼤量的类去填满⽅法区，直到溢出。⽅法区⽤于存放Class的相关信息，如：类名，访问修饰符，常量池，字符描述，⽅法描述等。</p><h1 id="哪些情况下对象会进⼊⽼年代"><a href="#哪些情况下对象会进⼊⽼年代" class="headerlink" title="哪些情况下对象会进⼊⽼年代"></a>哪些情况下对象会进⼊⽼年代</h1><p>新⽣代对象每次经历⼀次minor gc，年龄会加1，当达到年龄阈值（默认为15岁）会直接进⼊⽼年代；⼤对象直接进⼊⽼年代；新⽣代复制算法需要⼀个survivor区进⾏轮换备份，如果出现⼤量对象在minor gc后仍然存活的情况时，就需要⽼年代进⾏分配担保，让survivor⽆法容纳的对象直接进⼊⽼年代；如果在Survivor空间中相同年龄所有对象⼤⼩的总和⼤于Survivor空间的⼀半，年龄⼤于或等于该年龄的对象就可以直接进⼊年⽼代。</p><h1 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h1><p>GC的时候必须要等到Java线程都进入到safepoint的时候VMThread才能开始执行GC。SafePoint包括：循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)、方法返回前、调用方法的call之后、抛出异常的位置。</p><h1 id="简述Java垃圾回收机制"><a href="#简述Java垃圾回收机制" class="headerlink" title="简述Java垃圾回收机制"></a>简述Java垃圾回收机制</h1><p>在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h1 id="查看配置JVM内存信息"><a href="#查看配置JVM内存信息" class="headerlink" title="查看配置JVM内存信息"></a>查看配置JVM内存信息</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().maxMemory(); <span class="comment">// 最大可用内存，对应-Xmx</span></span><br><span class="line">Runtime.getRuntime().freeMemory(); <span class="comment">// 当前JVM空闲内存</span></span><br><span class="line">Runtime.getRuntime().totalMemory(); <span class="comment">// 当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和</span></span><br></pre></td></tr></table></figure><h1 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h1><ul><li><code>-server</code>启用服务器模式（如果CPU多，服务器机建议使用此项）</li><li><code>-Xms</code>设置启动JVM时的堆内存空间</li><li><code>-Xmx</code>设置堆内存最⼤限制</li><li><code>-XX:NewRatio</code>设置新⽣代和⽼年代的占⽐</li><li><code>-XX:NewSize</code>设置新⽣代空间</li><li><code>-XX:SurvivorRatio</code>设置伊甸园空间和幸存者空间的占⽐</li><li><code>-XX:MaxTenuringThreshold</code>设置对象进⼊⽼年代的年龄阈值</li><li>设定垃圾回收器<ul><li>年轻代：<code>-XX:+UseParNewGC</code></li><li>⽼年代：<code>-XX:+UseConcMarkSweepGC</code></li></ul></li></ul><h1 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h1><ul><li>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</li><li>jps，JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>jstack，用于生成java虚拟机当前时刻的线程快照</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数</li><li>jstack可以看当前栈的情况，jmap查看内存，jhat 进行dump堆的信息</li><li>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto</li><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等</li><li>GChisto，一款专业分析gc日志的工具</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a> <a href="/tags/GC/" rel="tag"><i class="fa fa-tag"></i> GC</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/c0d8e27e97f4.html" rel="prev" title="多线程"><i class="fa fa-angle-left"></i> 多线程</a></div><div class="post-nav-item"><a href="/publishes/4a23c7da79c0.html" rel="next" title="Spring cloud">Spring cloud <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">450k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:49</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>