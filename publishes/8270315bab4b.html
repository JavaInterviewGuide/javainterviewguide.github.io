<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="gc概述 垃圾收集机制是指jvm用于释放那些不再使用的对象所占用的内存 java语言并不要求jvm有gc，也没有规定gc如何工作 不过常用的jvm都有gc，而且大多数gc都使用类似的算法管理内存和执行收集操作 垃圾收集的目的在于清除不再使用的对象 gc通过确定对象是否被活动对象引用来确定是否收集该对象 gc首先要判断该对象是否是时候可以收集，两种常用的方法是引用计数和对象引用遍历 引用计数 引用计"><meta property="og:type" content="article"><meta property="og:title" content="Java虚拟机（JVM）"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/8270315bab4b.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="gc概述 垃圾收集机制是指jvm用于释放那些不再使用的对象所占用的内存 java语言并不要求jvm有gc，也没有规定gc如何工作 不过常用的jvm都有gc，而且大多数gc都使用类似的算法管理内存和执行收集操作 垃圾收集的目的在于清除不再使用的对象 gc通过确定对象是否被活动对象引用来确定是否收集该对象 gc首先要判断该对象是否是时候可以收集，两种常用的方法是引用计数和对象引用遍历 引用计数 引用计"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:08:40.000Z"><meta property="article:modified_time" content="2023-12-20T07:09:12.551Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/8270315bab4b.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/8270315bab4b.html","path":"publishes/8270315bab4b.html","title":"Java虚拟机（JVM）"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java虚拟机（JVM） | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#gc%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">gc概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">几种垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">标记-清除收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">标记-压缩收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">复制收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.0.0.4.</span> <span class="nav-text">增量收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.0.0.5.</span> <span class="nav-text">分代收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.0.0.6.</span> <span class="nav-text">并发收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.0.0.7.</span> <span class="nav-text">并行收集器</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Sun-HotSpot"><span class="nav-number">3.</span> <span class="nav-text">Sun HotSpot</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8EJVM%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%B0%83%E6%95%B4"><span class="nav-number">4.</span> <span class="nav-text">如何从JVM中获取信息来进行调整</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AEJVM%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="nav-number">5.</span> <span class="nav-text">查看配置JVM内存信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EmaxMemory-%EF%BC%8CfreeMemory-%E5%92%8CtotalMemory-%EF%BC%9A"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">关于maxMemory()，freeMemory()和totalMemory()：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="nav-number">6.</span> <span class="nav-text">堆内存分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%88Youn-Generation%EF%BC%89"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">新生代（Youn Generation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">老年代（Old Generation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88Permanent-Generation%EF%BC%89"><span class="nav-number">6.0.0.3.</span> <span class="nav-text">永久代（Permanent Generation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Major-GC%E5%92%8CFull-GC%E5%8C%BA%E5%88%AB"><span class="nav-number">6.0.0.4.</span> <span class="nav-text">Major GC和Full GC区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E2%BD%A4%E7%9A%84GC%E7%AD%96%E7%95%A5%E5%92%8C%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">7.</span> <span class="nav-text">常⽤的GC策略和触发时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#YGC-Young-GC"><span class="nav-number">7.0.0.1.</span> <span class="nav-text">YGC(Young GC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FGC-Full-GC"><span class="nav-number">7.0.0.2.</span> <span class="nav-text">FGC(Full GC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E8%B0%83%E2%BD%A4System-gc-%EF%BC%8C%E5%8C%85%E6%8B%ACRMI%E7%AD%89%E7%9A%84%E5%AE%9A%E6%97%B6%E8%A7%A6%E5%8F%91"><span class="nav-number">7.0.0.3.</span> <span class="nav-text">显示调⽤System.gc() ，包括RMI等的定时触发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#YGC%E6%97%B6%E7%9A%84%E6%82%B2%E8%A7%82%E7%AD%96%E7%95%A5"><span class="nav-number">7.0.0.4.</span> <span class="nav-text">YGC时的悲观策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dump-live%E7%9A%84%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%E6%97%B6-jmap-%E2%80%93dump-live-%E3%80%82"><span class="nav-number">7.0.0.5.</span> <span class="nav-text">dump live的内存信息时(jmap –dump:live)。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%93JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">8.</span> <span class="nav-text">深入理解JVM–JVM垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC%E4%B8%BA%E6%88%91%E4%BB%AC%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E5%91%A2%EF%BC%9F"><span class="nav-number">8.0.0.1.</span> <span class="nav-text">GC为我们做了什么操作呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0GC%E4%BD%9C%E7%94%A8"><span class="nav-number">8.0.0.2.</span> <span class="nav-text">学习GC作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="nav-number">8.0.0.3.</span> <span class="nav-text">什么时候会触发一个对象的回收</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">Java中存在四种引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">9.0.0.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="nav-number">9.0.0.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">9.0.0.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88%E5%B9%BD%E7%81%B5-%E5%B9%BB%E5%BD%B1%E5%BC%95%E7%94%A8%EF%BC%89"><span class="nav-number">9.0.0.4.</span> <span class="nav-text">虚引用（幽灵&#x2F;幻影引用）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E7%BB%93%E6%9E%84"><span class="nav-number">10.</span> <span class="nav-text">JVM结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="nav-number">10.0.0.1.</span> <span class="nav-text">方法区（Method Area）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%8C%BA%EF%BC%88Heap%EF%BC%89"><span class="nav-number">10.0.0.2.</span> <span class="nav-text">堆区（Heap）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88VM-Stack%EF%BC%89"><span class="nav-number">10.0.0.3.</span> <span class="nav-text">虚拟机栈（VM Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="nav-number">10.0.0.4.</span> <span class="nav-text">本地方法栈（Native Method Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88Program-Counter-Register%EF%BC%89-PC%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">10.0.0.5.</span> <span class="nav-text">程序计数器（Program Counter Register）(PC寄存器)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">11.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.0.0.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">11.0.0.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParallelScavenge"><span class="nav-number">11.0.0.3.</span> <span class="nav-text">ParallelScavenge</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ParallelOld"><span class="nav-number">12.</span> <span class="nav-text">ParallelOld</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SerialOld"><span class="nav-number">12.0.0.1.</span> <span class="nav-text">SerialOld</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS"><span class="nav-number">12.0.0.2.</span> <span class="nav-text">CMS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GarbageFirst-G1"><span class="nav-number">12.0.0.3.</span> <span class="nav-text">GarbageFirst(G1)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RTSJ%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">12.0.0.4.</span> <span class="nav-text">RTSJ垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">13.</span> <span class="nav-text">JVM的内存分配与回收策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.</span> <span class="nav-text">jvm内存模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">15.</span> <span class="nav-text">Java 中堆和栈有什么不同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">16.</span> <span class="nav-text">java类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">16.0.0.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">16.0.0.2.</span> <span class="nav-text">类⽣命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">16.0.0.3.</span> <span class="nav-text">什么是类加载器，类加载器有哪些?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">16.0.0.4.</span> <span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E8%B5%B7%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BA%94%E4%B8%AA%E2%BE%8F%E4%B8%BA"><span class="nav-number">16.0.0.5.</span> <span class="nav-text">引起类加载的五个⾏为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="nav-number">16.0.0.6.</span> <span class="nav-text">java对象创建时机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E8%B0%83%E4%BC%98"><span class="nav-number">17.</span> <span class="nav-text">jvm调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E6%97%B6%E6%9C%BA"><span class="nav-number">17.0.0.1.</span> <span class="nav-text">调优时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E5%8E%9F%E5%88%99"><span class="nav-number">17.0.0.2.</span> <span class="nav-text">调优原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E2%BD%AC%E6%A0%87"><span class="nav-number">17.0.0.3.</span> <span class="nav-text">调优⽬标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E6%AD%A5%E9%AA%A4"><span class="nav-number">17.0.0.4.</span> <span class="nav-text">调优步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-number">18.</span> <span class="nav-text">jvm调优参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91full-gc%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5"><span class="nav-number">19.</span> <span class="nav-text">触发full gc的场景及应对策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%8E%87%E4%BB%A5%E5%8F%8AMinor-GC%E5%92%8CMajor-GC"><span class="nav-number">20.</span> <span class="nav-text">简述java内存分配与回收策率以及Minor GC和Major GC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bjvm%E5%86%85%E5%AD%98%E4%BD%BF%E2%BD%A4%E6%83%85%E5%86%B5"><span class="nav-number">21.</span> <span class="nav-text">如何查看jvm内存使⽤情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E2%BD%85%E6%B3%95"><span class="nav-number">22.</span> <span class="nav-text">内存溢出的可能原因和解决⽅法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%8E%9F%E5%9B%A0"><span class="nav-number">22.0.0.1.</span> <span class="nav-text">内存溢出原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E2%BD%85%E6%B3%95"><span class="nav-number">22.0.0.2.</span> <span class="nav-text">解决⽅法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">23.</span> <span class="nav-text">内存泄漏的原因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BD%85%E6%B3%95%E5%8C%BAoom"><span class="nav-number">24.</span> <span class="nav-text">⽅法区oom</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E5%AF%B9%E8%B1%A1%E4%BC%9A%E8%BF%9B%E2%BC%8A%E2%BD%BC%E5%B9%B4%E4%BB%A3"><span class="nav-number">25.</span> <span class="nav-text">哪些情况下对象会进⼊⽼年代</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E5%AF%B9%E8%B1%A1A%E5%88%9B%E5%BB%BA%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AF%B9%E8%B1%A1A%E5%9C%A8%E5%90%84%E4%B8%AA%E5%8C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B"><span class="nav-number">26.</span> <span class="nav-text">当对象A创建之后，对象A在各个区之间的流转过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E4%BD%93%E7%B3%BB%E6%80%BB%E4%BD%93%E5%88%86%E5%9B%9B%E5%A4%A7%E5%9D%97"><span class="nav-number">27.</span> <span class="nav-text">jvm体系总体分四大块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E5%91%BD%E4%BB%A4"><span class="nav-number">28.</span> <span class="nav-text">调优命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7"><span class="nav-number">29.</span> <span class="nav-text">调优工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SafePoint%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">30.</span> <span class="nav-text">SafePoint是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">31.</span> <span class="nav-text">简述java垃圾回收机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE"><span class="nav-number">32.</span> <span class="nav-text">虚拟机设置</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">26</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/8270315bab4b.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java虚拟机（JVM） | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java虚拟机（JVM）</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:08:40 / 修改时间：15:09:12" itemprop="dateCreated datePublished" datetime="2023-12-20T15:08:40+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="gc概述"><a href="#gc概述" class="headerlink" title="gc概述"></a>gc概述</h1><ul><li>垃圾收集机制是指jvm用于释放那些不再使用的对象所占用的内存</li><li>java语言并不要求jvm有gc，也没有规定gc如何工作</li><li>不过常用的jvm都有gc，而且大多数gc都使用类似的算法管理内存和执行收集操作</li><li>垃圾收集的目的在于清除不再使用的对象</li><li>gc通过确定对象是否被活动对象引用来确定是否收集该对象</li><li>gc首先要判断该对象是否是时候可以收集，两种常用的方法是引用计数和对象引用遍历<ul><li>引用计数<ul><li>引用计数存储对特定对象的所有引用数</li><li>当应用程序创建引用以及引用超出范围时，jvm必须适当增减引用数</li><li>当某对象的引用数为0时，便可以进行垃圾收集</li></ul></li><li>对象引用遍历<ul><li>早期的jvm使用引用计数，现在大多数jvm采用对象引用遍历</li><li>对象引用遍历从一组对象（GC ROOT）开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象</li><li>如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集</li><li>在对象遍历阶段，gc必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象</li><li>下一步，gc要删除不可到达的对象</li><li>删除时，有些gc只是简单的扫描堆栈，删除未标记的对象，并释放它们的内存以生成新的对象，这叫做清除（sweeping）</li><li>这种方法的问题在于内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大</li><li>因此，许多gc可以重新组织内存中的对象，并进行压缩（compact），形成可利用的空间</li><li>为此，gc需要停止其他的活动活动，这种方法意味着所有与应用程序相关的工作停止，只有gc运行，结果，在响应期间增减了许多混杂请求</li><li>另外，更复杂的gc不断增加或同时运行以减少或者清除应用程序的中断，有的gc使用单线程完成这项工作，有的则采用多线程以增加效率。</li><li>java中可作为GC Root的对象有<ul><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native对象）</li></ul></li></ul></li></ul></li><li>有3个内存区域是不需要进行垃圾回收的：本地方法栈、程序计数器、虚拟机栈。因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。</li></ul><h1 id="几种垃圾回收机制"><a href="#几种垃圾回收机制" class="headerlink" title="几种垃圾回收机制"></a>几种垃圾回收机制</h1><h4 id="标记-清除收集器"><a href="#标记-清除收集器" class="headerlink" title="标记-清除收集器"></a>标记-清除收集器</h4><ul><li>这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存</li><li>这种收集器一般使用单线程工作并停止其他操作</li><li>标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片</li></ul><h4 id="标记-压缩收集器"><a href="#标记-压缩收集器" class="headerlink" title="标记-压缩收集器"></a>标记-压缩收集器</h4><ul><li>有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段</li><li>在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈</li><li>这种收集器也停止其他操作</li><li>由于进行了移动规整动作，该算法避免了标记-清除的碎片问题，但由于需要进行移动，因此成本也增加了。（该算法适用于旧生代）</li></ul><h4 id="复制收集器"><a href="#复制收集器" class="headerlink" title="复制收集器"></a>复制收集器</h4><ul><li>这种收集器将堆栈分为两个域，常称为半空间</li><li>每次仅使用一半的空间，jvm生成的新对象则放在另一半空间中</li><li>gc运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈</li><li>这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低</li><li>复制算法采用的方式为从根集合进行扫描，将存活的对象移动到一块空闲的区域</li><li>当存活的对象较少时，复制算法会比较高效（新生代的Eden区就是采用这种算法），其带来的成本是需要一块额外的空闲空间和对象的移动</li></ul><h4 id="增量收集器"><a href="#增量收集器" class="headerlink" title="增量收集器"></a>增量收集器</h4><ul><li>增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾</li><li>这会造成较小的应用程序中断</li></ul><h4 id="分代收集器"><a href="#分代收集器" class="headerlink" title="分代收集器"></a>分代收集器</h4><ul><li>这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象</li><li>jvm生成的新对象一般放在其中的某个域中，过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中</li><li>分代收集器对不同的域使用不同的算法以优化性能</li></ul><h4 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h4><ul><li>并发收集器与应用程序同时运行</li><li>这些收集器在某点上（比如压缩时）一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低</li></ul><h4 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h4><ul><li>并行收集器使用某种传统的算法并使用多线程并行的执行它们的工作</li><li>在多cpu机器上使用多线程技术可以显著的提高java应用程序的可扩展性</li></ul><h1 id="Sun-HotSpot"><a href="#Sun-HotSpot" class="headerlink" title="Sun HotSpot"></a>Sun HotSpot</h1><ul><li>Sun HotSpot 使用分代收集器，它把堆分为三个主要的域：新域、旧域以及永久域</li><li>Jvm生成的所有新对象放在新域中</li><li>一旦对象经历了一定数量的垃圾收集循环后，便获得使用期并进入旧域</li><li>在永久域中jvm则存储class和method对象</li><li>就配置而言，永久域是一个独立域并且不认为是堆的一部分</li><li>可使用-Xms和-Xmx 控制整个堆的原始大小或最大值</li><li>默认状态下，HotSpot在新域中使用复制收集器，该域一般分为三个部分<ul><li>第一部分为Eden，用于生成新的对象</li><li>另两部分称为救助空间，当Eden充满时，收集器停止应用程序，把所有可到达对象复制到当前的from救助空间，一旦当前的from救助空间充满，收集器则把可到达对象复制到当前的to救助空间。From和to救助空间互换角色。维持活动的对象将在救助空间不断复制，直到它们获得使用期并转入旧域</li></ul></li><li>默认状态下HotSpot对新域使用复制收集器，对旧域使用标记－清除－压缩收集器</li><li>在新域中使用复制收集器有很多意义，因为应用程序生成的大部分对象是短寿命的。理想状态下，所有过渡对象在移出Eden空间时将被收集。如果能够这样的话，并且移出Eden空间的对象是长寿命的，那么理论上可以立即把它们移进旧域，避免在救助空间反复复制。但是，应用程序不能适合这种理想状态，因为它们有一小部分中长寿命的对象。最好是保持这些中长寿命的对象并放在新域中，因为复制小部分的对象总比压缩旧域廉价</li></ul><h1 id="如何从JVM中获取信息来进行调整"><a href="#如何从JVM中获取信息来进行调整" class="headerlink" title="如何从JVM中获取信息来进行调整"></a>如何从JVM中获取信息来进行调整</h1><ul><li>-verbose.gc开关可显示gc的操作内容。打开它，可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等。</li><li>打开-xx：+ printgcdetails开关，可以详细了解gc中的变化</li><li>打开-XX： + PrintGCTimeStamps开关，可以了解这些垃圾收集发生的时间，自jvm启动以后以秒计量</li><li>通过-xx： + PrintHeapAtGC开关了解堆的更详细的信息</li><li>为了了解新域的情况，可以通过-XX：=PrintTenuringDistribution开关了解获得使用期的对象权。</li></ul><h1 id="查看配置JVM内存信息"><a href="#查看配置JVM内存信息" class="headerlink" title="查看配置JVM内存信息"></a>查看配置JVM内存信息</h1><ul><li>Runtime.getRuntime().maxMemory();//最大可用内存，对应-Xmx</li><li>Runtime.getRuntime().freeMemory();//当前JVM空闲内存</li><li>Runtime.getRuntime().totalMemory();//当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和<h4 id="关于maxMemory-，freeMemory-和totalMemory-："><a href="#关于maxMemory-，freeMemory-和totalMemory-：" class="headerlink" title="关于maxMemory()，freeMemory()和totalMemory()："></a>关于maxMemory()，freeMemory()和totalMemory()：</h4></li><li>maxMemory()为JVM的最大可用内存，可通过-Xmx设置，默认值为物理内存的1/4，设值不能高于计算机物理内存；</li><li>totalMemory()为当前JVM占用的内存总数，其值相当于当前JVM已使用的内存及freeMemory()的总和，会随着JVM使用内存的增加而增加；</li><li>freeMemory()为当前JVM空闲内存，因为JVM只有在需要内存时才占用物理内存使用，所以freeMemory()的值一般情况下都很小，而JVM实际可用内存并不等于freeMemory()，而应该等于maxMemory()-totalMemory()+freeMemory()。及其配置JVM内存分配。</li></ul><h1 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h1><ul><li>JVM的新生代、老年代、MinorGC、MajorGC</li><li>JVM中的堆，一般分为三大部分：新生代、老年代、永久代</li></ul><h4 id="新生代（Youn-Generation）"><a href="#新生代（Youn-Generation）" class="headerlink" title="新生代（Youn Generation）"></a>新生代（Youn Generation）</h4><ul><li>主要是用来存放新生的对象</li><li>一般占据堆的1/3空间</li><li>由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收</li><li>新生代又分为 Eden区、ServivorFrom、ServivorTo三个区<ul><li>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收</li><li>ServivorTo：保留了一次MinorGC过程中的幸存者</li><li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者</li></ul></li><li>当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。</li><li>MinorGC的过程：采用复制算法<ul><li>首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则赋值到老年代区）</li><li>同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）</li><li>然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</li></ul></li><li>新建的对象都是从新生代分配内存，Eden区不足的时候，会把存活的对象转移到Survivor区</li></ul><h4 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h4><ul><li>老年代的对象比较稳定，所以MajorGC不会频繁执行</li><li>在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发</li><li>当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间</li><li>MajorGC采用标记—清除算法：<ul><li>首先扫描一次所有老年代，标记出存活的对象</li><li>然后回收没有标记的对象</li></ul></li><li>MajorGC的耗时比较长，因为要扫描再回收</li><li>MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配</li><li>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常</li><li>旧生代用于存放新生代多次回收依然存活的对象，如缓存对象。当旧生代满了的时候就需要对旧生代进行回收，旧生代的垃圾回收称作Major GC</li></ul><h4 id="永久代（Permanent-Generation）"><a href="#永久代（Permanent-Generation）" class="headerlink" title="永久代（Permanent Generation）"></a>永久代（Permanent Generation）</h4><ul><li>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息</li><li>Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常</li><li>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现</li><li>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</li><li>类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中</li><li>这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制</li><li>在Sun 的JVM中就是方法区的意思，尽管大多数JVM没有这一代</li></ul><h4 id="Major-GC和Full-GC区别"><a href="#Major-GC和Full-GC区别" class="headerlink" title="Major GC和Full GC区别"></a>Major GC和Full GC区别</h4><ul><li>Full GC：收集young gen、old gen、perm gen</li><li>Major GC：有时又叫old gc，只收集old gen</li></ul><h1 id="常⽤的GC策略和触发时机"><a href="#常⽤的GC策略和触发时机" class="headerlink" title="常⽤的GC策略和触发时机"></a>常⽤的GC策略和触发时机</h1><h4 id="YGC-Young-GC"><a href="#YGC-Young-GC" class="headerlink" title="YGC(Young GC)"></a>YGC(Young GC)</h4><ul><li>概念：对新⽣代堆进⾏GC。频率⽐较⾼，因为⼤部分对象的存活寿命较短，在新⽣代⾥被回收。性能耗费较⼩。</li><li>触发时机：Eden区空间不⾜</li></ul><h4 id="FGC-Full-GC"><a href="#FGC-Full-GC" class="headerlink" title="FGC(Full GC)"></a>FGC(Full GC)</h4><ul><li>概念：全堆范围的GC。默认堆空间使⽤到达80%(可调整)的时候会触发FGC。以我们⽣产环境为例，⼀般⽐较少会触发FGC，有时10天或⼀周左右会有⼀次。</li><li>触发时机：<ul><li>Old空间不⾜</li><li>Perm空间不⾜</li></ul></li></ul><h4 id="显示调⽤System-gc-，包括RMI等的定时触发"><a href="#显示调⽤System-gc-，包括RMI等的定时触发" class="headerlink" title="显示调⽤System.gc() ，包括RMI等的定时触发"></a>显示调⽤System.gc() ，包括RMI等的定时触发</h4><h4 id="YGC时的悲观策略"><a href="#YGC时的悲观策略" class="headerlink" title="YGC时的悲观策略"></a>YGC时的悲观策略</h4><h4 id="dump-live的内存信息时-jmap-–dump-live-。"><a href="#dump-live的内存信息时-jmap-–dump-live-。" class="headerlink" title="dump live的内存信息时(jmap –dump:live)。"></a>dump live的内存信息时(jmap –dump:live)。</h4><h1 id="深入理解JVM–JVM垃圾回收机制"><a href="#深入理解JVM–JVM垃圾回收机制" class="headerlink" title="深入理解JVM–JVM垃圾回收机制"></a>深入理解JVM–JVM垃圾回收机制</h1><h4 id="GC为我们做了什么操作呢？"><a href="#GC为我们做了什么操作呢？" class="headerlink" title="GC为我们做了什么操作呢？"></a>GC为我们做了什么操作呢？</h4><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><h4 id="学习GC作用"><a href="#学习GC作用" class="headerlink" title="学习GC作用"></a>学习GC作用</h4><ul><li>排查内存溢出</li><li>排查内存泄漏</li><li>性能调优，排查并发瓶颈</li></ul><h4 id="什么时候会触发一个对象的回收"><a href="#什么时候会触发一个对象的回收" class="headerlink" title="什么时候会触发一个对象的回收"></a>什么时候会触发一个对象的回收</h4><ul><li>对象没有引用</li><li>作用域发生未捕获异常</li><li>程序在作用域正常执行完毕</li><li>程序执行了System.exit()</li><li>程序发生意外终止（被杀进程等）</li></ul><h1 id="Java中存在四种引用"><a href="#Java中存在四种引用" class="headerlink" title="Java中存在四种引用"></a>Java中存在四种引用</h1><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>只要引用存在，垃圾回收器永远不会回收</li><li>Object obj = new Object();</li><li>new出来的对象都是强引用，GC无论如何都不会回收，即使抛出OOM异常</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul><li>非必须引用，内存溢出之前进行回收，可以通过以下代码实现</li><li>只有当JVM内存不足时才会被回收<br>Object obj = new Object();<br>SoftReference<object>sf = new SoftReference<object>(obj);<br>obj = null;<br>sf.get();//有时候会返回null<br>这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；<br>软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</object></object></li></ul><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul><li>第二次垃圾回收时回收，可以通过如下代码实现<br>Object obj = new Object();<br>WeakReference<object>wf = new WeakReference<object>(obj);<br>obj = null;<br>wf.get();//有时候会返回null<br>wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾<br>弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。<br>弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器</object></object></li><li>只要GC,就会立马回收，不管内存是否充足</li></ul><h4 id="虚引用（幽灵-幻影引用）"><a href="#虚引用（幽灵-幻影引用）" class="headerlink" title="虚引用（幽灵/幻影引用）"></a>虚引用（幽灵/幻影引用）</h4><ul><li>垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现<br>Object obj = new Object();<br>PhantomReference<object>pf = new PhantomReference<object>(obj);<br>obj=null;<br>pf.get();//永远返回null<br>pf.isEnQueued();//返回从内存中已经删除<br>虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。<br>虚引用主要用于检测对象是否已经从内存中删除。</object></object></li><li>它唯一的作用就是做一些跟踪记录，辅助finalize函数的使用</li></ul><h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><p>JVM把内存划分成了如下几个区域：<br>1.方法区（Method Area）<br>2.堆区（Heap）<br>3.虚拟机栈（VM Stack）<br>4.本地方法栈（Native Method Stack）<br>5.程序计数器（Program Counter Register）<br>其中，方法区和堆所有线程共享。</p><ul><li>线程不共享区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的</li><li>线程共享区域 线程共享区域包含：堆和方法区</li></ul><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><ul><li>主要存放类与类之间关系的数据，而这部分数据被加载到内存之后，基本上是不会发生变更的</li><li>方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息</li><li>方法区是全局共享的，在一定条件下也会被GC。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常</li><li>在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation）</li><li>一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载</li><li>在方法区上进行GC，条件相当苛刻而且困难。</li><li>方法区的数据因为回收率非常小，而成本又比较高，一般认为是“性价比”非常差的，所以Sun自己的虚拟机HotSpot中是不回收的！但是在现在高性能分布式J2EE的系统中，我们大量用到了反射、动态代理、CGLIB、JSP和OSGI等，这些类频繁的调用自定义类加载器，都需要动态的加载和卸载了，以保证永久带不会溢出，他们通过自定义的类加载器进行了各项操作，因此在实际的应用开发中，类也是被经常加载和卸载的，方法区也是会被回收的！但是方法区的回收条件非常苛刻，只有同时满足以下三个条件才会被回收！<ul><li>该类的所有实例都已经被回收</li><li>加载该类的ClassLoad已经被回收</li><li>Class对象无法通过任何途径访问(包括反射)，该类对应的反射类java.lang.Class对象没有被任何地方引用</li></ul></li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用</li><li>一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</li><li>保存装载的类的元信息：类型的常量池，字段、⽅法信息，⽅法字节码</li><li>jdk6时，String等常量信息置于⽅法区，jdk7移到了堆中</li><li>通常和永久区（Perm）关联在⼀起</li></ul><h4 id="堆区（Heap）"><a href="#堆区（Heap）" class="headerlink" title="堆区（Heap）"></a>堆区（Heap）</h4><ul><li>Java堆中的数据基本上是朝生夕死的，我们用完之后要马上回收的，而Java栈和本地方法栈中的数据，因为有后进先出的原则，当我取下面的数据之前，必须要把栈顶的元素出栈，因此回收率可认为是100%</li><li>堆区是GC最频繁的，也是理解GC机制最重要的区域</li><li>堆区由所有线程共享，在虚拟机启动时创建</li><li>堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。</li><li>应⽤系统对象都保存在java堆中</li><li>所有线程共享java堆</li><li>对分代GC来说，堆也是分代的</li></ul><h4 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h4><ul><li>虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈</li><li>局部变量表中存储着方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：内存空间可以在编译期间就确定，运行时不再改变</li><li>虚拟机栈定义了两种异常类型：StackOverFlowError(栈溢出)和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError；不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</li><li>线程私有</li><li>栈由⼀系列帧组成（因此java栈也叫做帧栈）</li><li>帧保存⼀个⽅法的局部变量（局部变量表）、操作数栈、常量池指针</li><li>每⼀次⽅法调⽤创建⼀个帧，并压栈</li></ul><h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><ul><li>本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态</li><li>本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法</li><li>在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</li></ul><h4 id="程序计数器（Program-Counter-Register）-PC寄存器"><a href="#程序计数器（Program-Counter-Register）-PC寄存器" class="headerlink" title="程序计数器（Program Counter Register）(PC寄存器)"></a>程序计数器（Program Counter Register）(PC寄存器)</h4><ul><li>主要用于记录线程执行的行号等一些信息，这块区域也是被认为是唯一一块不会内存溢出的区域。在SunHostSpot的虚拟机中，对于程序计数器是不回收的</li><li>每个线程拥有⼀个pc寄存器，指向下⼀条指令的地址</li><li>程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它</li><li>它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的</li><li>每个程序计数器只能记录一个线程的行号，因此它是线程私有的</li><li>如果程序当前正在执行的是一个java方法，则程序计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则计数器的值为空</li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ul><li>属于串行收集器</li><li>Serial收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下ServerVM 4核4GB以下机器的默认垃圾回收器</li><li>比较适合于只有一个处理器的系统</li><li>串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World”的垃圾回收器</li><li>串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。</li><li>Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</li><li>在串行处理器中minor和major GC过程都是用一个线程进行回收的</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul><li>ParNew收集器其实就是多线程版本的Serial收集器</li><li>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器</li><li>它可以与CMS GC配合，所以，更加有理由将他用于server端</li></ul><h4 id="ParallelScavenge"><a href="#ParallelScavenge" class="headerlink" title="ParallelScavenge"></a>ParallelScavenge</h4><ul><li>ParallelScavenge又被称为是吞吐量优先的收集器</li><li>ParallelScavenge所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%，在交互不多的云端，比较适合使用该回收器。</li><li>在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式</li></ul><h1 id="ParallelOld"><a href="#ParallelOld" class="headerlink" title="ParallelOld"></a>ParallelOld</h1><ul><li>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器</li><li>这个收集器是JDK1.6之后刚引入的一款收集器，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先</li><li>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法</li></ul><h4 id="SerialOld"><a href="#SerialOld" class="headerlink" title="SerialOld"></a>SerialOld</h4><ul><li>SerialOld是旧生代Client模式下的默认收集器，单线程执行</li><li>在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器</li><li>Serial Old是Serial收集器的老年代版本</li><li>它同样使用一个单线程执行收集，使用“标记-整理”算法</li><li>主要使用在Client模式下的虚拟机</li></ul><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><ul><li>CMS又称响应时间优先(最短回收停顿)的回收器</li><li>使用并发模式回收垃圾</li><li>使用标记-清除算法</li><li>CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%</li><li>CMS模式主要分为4个过程</li><li>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程</li><li>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</li><li>CMS为了确保能够扫描到所有的对象，避免在Initial Marking中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack中，如依赖的对象地址在其之后，则仅标记该对象。在进行Concurrent Marking时minor GC也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS为了应对这样的并发现象，提供了一个Mod Union Table来进行记录，在这个Mod Union Table中记录每次minor GC后修改了的Card的信息。这也是ParallelScavenge不能和CMS一起使用的原因。</li><li>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收</li><li>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收</li><li>该收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间</li><li>常见的B/S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清楚算法实现的</li><li>CMS收集器的优点：并发收集、低停顿，但远没有达到完美</li><li>CMS收集器的缺点：<ul><li>CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。</li><li>CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。</li><li>CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。</li></ul></li></ul><h4 id="GarbageFirst-G1"><a href="#GarbageFirst-G1" class="headerlink" title="GarbageFirst(G1)"></a>GarbageFirst(G1)</h4><ul><li>SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器</li><li>他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间</li><li>相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿</li></ul><h4 id="RTSJ垃圾收集器"><a href="#RTSJ垃圾收集器" class="headerlink" title="RTSJ垃圾收集器"></a>RTSJ垃圾收集器</h4><ul><li>RTSJ垃圾收集器，用于Java实时编程</li></ul><h1 id="JVM的内存分配与回收策略"><a href="#JVM的内存分配与回收策略" class="headerlink" title="JVM的内存分配与回收策略"></a>JVM的内存分配与回收策略</h1><ul><li>优先在Edon上分配对象</li><li>大对象直接进入老生代</li><li>年长者(长期存活对象)进入老生代</li><li>群体效应(大批中年对象进入老生代)</li><li>担保GC(担保minorGC)<ul><li>担保GC就是担保minorGC能够满足当前的存储空间，而无需触发老生代的回收，由于大部分对象都是朝生夕死的，因此，在实际开发中这种很起效，但是也有可能会发生担保失败的情况，当担保失败的时候会触发FullGC，但是失败毕竟是少数，因此这种一般是很划算的。</li><li>默认情况是是开启担保的，无需设置参数</li></ul></li></ul><h1 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h1><ul><li>每⼀个线程有⼀个⼯作内存，和主存独⽴</li><li>⼯作内存存放主存中变量的值的拷⻉</li><li>对于普通变量，⼀个线程中更新的值，不能⻢上反应在其他变量中；如果需要在其他线程中⽴即可⻅，需要使⽤volatile关键字</li><li>volatile不能代替锁，⼀般认为volatile⽐锁性能好(不绝对)，使⽤volatile的条件是语义是否满⾜应⽤</li><li>可⻅性：⼀个线程修改了变量，其他线程可以⽴即知道。<ul><li>volatile；</li><li>synchronized（unlock之前，写变量值回主存）</li><li>final（⼀旦初始化完成，其他线程可⻅）</li></ul></li></ul><h1 id="Java-中堆和栈有什么不同"><a href="#Java-中堆和栈有什么不同" class="headerlink" title="Java 中堆和栈有什么不同"></a>Java 中堆和栈有什么不同</h1><ul><li>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的</li><li>而堆是所有线程共享的一片公用内存区域</li><li>对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile变量就可以发挥作用了，它要求线程从主存中读取变量的值。</li></ul><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>虚拟机把描述类的数据⽂件（字节码）加载到内存，并对数据进⾏验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使⽤的java类型（java.lang.Class对象）</li><li>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</li></ul><h4 id="类⽣命周期"><a href="#类⽣命周期" class="headerlink" title="类⽣命周期"></a>类⽣命周期</h4><ul><li>类加载过程：读取⼆进制字节流到jvm—&gt;验证格式语义等—&gt;为静态变量分配内存空间—&gt;常量池引⽤解析—&gt;执⾏static标识的代码<ul><li>a. 加载过程：通过⼀个类的全限定名来获取定义此类的⼆进制字节流，将这个字节流所代表的静态存储结构转化为⽅法区的运⾏时数据结构。在内存中(⽅法区)⽣成⼀个代表这个类的java.lang.Class对象，作为⽅法区这个类的各种数据的访问⼊⼝；</li><li>b. 验证过程：为了确保Class⽂件的字节流中包含的信息符合当前虚拟机的要求，⽂件格式验证、元数据验证、字节码验证、符号引⽤验证；</li><li>c. 准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在⽅法区中进⾏分配；准备阶段，static对象会被设置默认值，static ﬁnal对象会被赋上给予的值。</li><li>d. 解析阶段：虚拟机将常量池内的符号引⽤替换为直接引⽤的过程。<ul><li>i. 符号引⽤：字符串，引⽤对象不⼀定被加载；</li><li>ii. 直接引⽤：指针或者地址偏移量，引⽤对象⼀定在内存中。</li></ul></li><li>e. 初始化阶段：类初始化阶段是类加载过程的最后⼀步。初始化阶段就是执⾏类构造器<clint>()⽅法的过程。</clint></li><li>f. 使⽤阶段</li><li>g. 卸载阶段：</li></ul></li></ul><h4 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h4><ul><li>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</li><li>主要有一下四种类加载器:<ul><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ul></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li>java默认提供三个类加载器：<ul><li>a. 启动类加载器（BootStrap ClassLoader） 启动ClassLoader（sun.boot.class.path）：最顶层的加载类，主要加载jdk中的核⼼库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。Bootstrap ClassLoader不继承⾃ClassLoader，因为它不是⼀个普通的Java类，底层由C++编写，已嵌⼊到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核⼼类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</li><li>b. 扩展类加载器（Extension ClassLoader）扩展ClassLoader（java.ext.dirs）：扩展的类加载器，加载⽬录%JRE_HOME%\lib\ext⽬录下的jar包和class⽂件。还可以加载-D java.ext.dirs选项指定的⽬录。</li><li>c. App ClassLoader应⽤ClassLoader/系统ClassLoader（java.class.path）：也称为SystemAppClass 加载当前应⽤的classpath的所有类。除了BootStrap ClassLoader，每个ClassLoader都有⼀个Parent作为⽗亲。</li></ul></li><li>双亲委派机制：<ul><li>定义：当⼀个ClassLoader实例需要加载某个类时，它会试图亲⾃搜索某个类之前，先把这个任务委托给它的⽗类加载器，这个过程是由上⾄下依次检查的，⾸先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader进⾏加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的⽂件系统或⽹络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类⽣成⼀个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</li><li>作⽤：<ul><li>避免重复加载；</li><li>考虑到安全因素，避免⾃定义的类去替代系统类，如String。</li><li>jvm如何判定两个class是否相同？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，⽽且要判断是否由同⼀个类加载器实例加载的。只有两者同时满⾜的情况下，JVM才认为这两个class是相同的。<ul><li>⾃底向上检查类是否已经加载；</li><li>⾃顶向下尝试加载类。</li></ul></li></ul></li></ul></li><li>custom classloader：⾃定义classloader<ul><li>Java中提供的默认ClassLoader，只加载指定⽬录下的jar和class，如果我们想加载其它位置的类或jar时，就需要定义⾃⼰的ClassLoader。</li><li>步骤：<ul><li>继承java.lang.ClassLoader</li><li>重写⽗类的findClass⽅法</li></ul></li></ul></li></ul><h4 id="引起类加载的五个⾏为"><a href="#引起类加载的五个⾏为" class="headerlink" title="引起类加载的五个⾏为"></a>引起类加载的五个⾏为</h4><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li><li>反射调⽤的时候，如果类没有进⾏过初始化，则需要先触发其初始化</li><li>⼦类初始化的时候，如果其⽗类还没初始化，则需先触发其⽗类的初始化</li><li>虚拟机执⾏主类的时候(有 main(string[] args))</li><li>JDK1.7 动态语⾔⽀持</li></ul><h4 id="java对象创建时机"><a href="#java对象创建时机" class="headerlink" title="java对象创建时机"></a>java对象创建时机</h4><ul><li>使⽤new关键字创建对象</li><li>使⽤Class类的newInstance⽅法(反射机制)</li><li>使⽤Constructor类的newInstance⽅法(反射机制)</li><li>使⽤Clone⽅法创建对象</li><li>使⽤(反)序列化机制创建对象</li></ul><h1 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h1><h4 id="调优时机"><a href="#调优时机" class="headerlink" title="调优时机"></a>调优时机</h4><ul><li>heap 内存（⽼年代）持续上涨达到设置的最⼤内存值；</li><li>Full GC 次数频繁；</li><li>GC 停顿时间过⻓（超过1秒）；</li><li>应⽤出现OutOfMemory 等内存异常；</li><li>应⽤中有使⽤本地缓存且占⽤⼤量内存空间；</li><li>系统吞吐量与响应性能不⾼或下降。</li></ul><h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><ul><li>多数的Java应⽤不需要在服务器上进⾏JVM优化；</li><li>多数导致GC问题的Java应⽤，都不是因为我们参数设置错误，⽽是代码问题；</li><li>在应⽤上线之前，先考虑将机器的JVM参数设置到最优（最适合）；</li><li>减少创建对象的数量；</li><li>减少使⽤全局变量和⼤对象；</li><li>JVM优化是到最后不得已才采⽤的⼿段；</li><li>在实际使⽤中，分析GC情况优化代码⽐优化JVM参数更好；</li></ul><h4 id="调优⽬标"><a href="#调优⽬标" class="headerlink" title="调优⽬标"></a>调优⽬标</h4><ul><li>GC低停顿；</li><li>GC低频率；</li><li>低内存占⽤；</li><li>⾼吞吐量；</li></ul><h4 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a>调优步骤</h4><ul><li>分析GC⽇志及dump⽂件，判断是否需要优化，确定瓶颈问题点；</li><li>确定jvm调优量化⽬标；</li><li>确定jvm调优参数（根据历史jvm参数来调整）；</li><li>调优⼀台服务器，对⽐观察调优前后的差异；</li><li>不断的分析和调整，知道找到合适的jvm参数配置；</li><li>找到最合适的参数，将这些参数应⽤到所有服务器，并进⾏后续跟踪。</li></ul><h1 id="jvm调优参数"><a href="#jvm调优参数" class="headerlink" title="jvm调优参数"></a>jvm调优参数</h1><ul><li>设定堆内存⼤⼩，这是最基本的。</li><li>-Xms：启动JVM时的堆内存空间。</li><li>-Xmx：堆内存最⼤限制。</li><li>设定新⽣代⼤⼩。</li><li>新⽣代不宜太⼩，否则会有⼤量对象涌⼊⽼年代。</li><li>-XX:NewRatio：新⽣代和⽼年代的占⽐。</li><li>-XX:NewSize：新⽣代空间。</li><li>-XX:SurvivorRatio：伊甸园空间和幸存者空间的占⽐。</li><li>-XX:MaxTenuringThreshold：对象进⼊⽼年代的年龄阈值。</li><li>设定垃圾回收器<ul><li>年轻代：-XX:+UseParNewGC。</li><li>⽼年代：-XX:+UseConcMarkSweepGC。</li><li>CMS可以将STW时间降到最低，但是不对内存进⾏压缩，有可能出现“并⾏模式失败”。⽐如⽼年代空间还有300MB空间，但是⼀些10MB的对象⽆法被顺序的存储。这时候会触发压缩处理，但是CMS GC模式下的压缩处理时间要⽐Parallel GC⻓很多。</li><li>G1采⽤”标记-整理“算法，解决了内存碎⽚问题，建⽴了可预测的停顿时间类型，能让使⽤者指定在⼀个⻓度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。</li></ul></li></ul><h1 id="触发full-gc的场景及应对策略"><a href="#触发full-gc的场景及应对策略" class="headerlink" title="触发full gc的场景及应对策略"></a>触发full gc的场景及应对策略</h1><ul><li>System.gc()⽅法的调⽤，应对策略：通过-XX:+DisableExpl icitGC来禁⽌调⽤System.gc ;</li><li>⽼年代代空间不⾜，应对策略：让对象在Minor GC阶段被回收，让对象在新⽣代多存活⼀段时间，不要创建过⼤的对象及数组;</li><li>永⽣区空间不⾜，应对策略：增⼤PermGen空间；</li><li>GC时出现promotionfailed和concurrent mode failure，应对策略：增⼤survivor space；</li><li>Minor GC后晋升到旧⽣代的对象⼤⼩⼤于⽼年代的剩余空间，应对策略：增⼤Tenured space 或下调CMSInitiatingOccupancyFraction=60；</li><li>内存持续增涨达到上限导致Full GC，应对策略：通过dumpheap 分析是否存在内存泄漏。</li></ul><h1 id="简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述java内存分配与回收策率以及Minor GC和Major GC"></a>简述java内存分配与回收策率以及Minor GC和Major GC</h1><ul><li>对象优先在堆的Eden区分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将直接进入老年代</li><li>当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度</li></ul><h1 id="如何查看jvm内存使⽤情况"><a href="#如何查看jvm内存使⽤情况" class="headerlink" title="如何查看jvm内存使⽤情况"></a>如何查看jvm内存使⽤情况</h1><ul><li>可以使⽤JDK⾃带的JConsole、JVisualVM、JMap、JHat等⼯具，或者使⽤第三⽅⼯具，⽐如 Eclipse Memory Analyzer</li></ul><h1 id="内存溢出的可能原因和解决⽅法"><a href="#内存溢出的可能原因和解决⽅法" class="headerlink" title="内存溢出的可能原因和解决⽅法"></a>内存溢出的可能原因和解决⽅法</h1><h4 id="内存溢出原因"><a href="#内存溢出原因" class="headerlink" title="内存溢出原因"></a>内存溢出原因</h4><ul><li>数据加载过多，如1次从数据库中取出过多数据</li><li>集合类中有对对象的引⽤，⽤完后没有清空或者集合对象未置空导致引⽤存在等，是的JVM⽆法回收</li><li>死循环，过多重复对象</li><li>第三⽅软件的bug</li><li>启动参数内存值设定的过⼩</li></ul><h4 id="解决⽅法"><a href="#解决⽅法" class="headerlink" title="解决⽅法"></a>解决⽅法</h4><ul><li>修改JVM启动参数，加内存(-Xms，-Xmx)</li><li>错误⽇志，是否还有其他错误</li><li>代码⾛查</li></ul><h1 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h1><ul><li>未对作废数据内存单元置为null，尽早释放⽆⽤对象的引⽤，使⽤临时变量时，让引⽤变量在推出活动域后⾃动设置为null，暗示垃圾收集器收集；</li><li>程序避免⽤String拼接，⽤StringBuffer，因为每个String会占⽤内存⼀块区域；</li><li>尽量少⽤静态变量（全局不会回收）；</li><li>不要集中创建对象尤其⼤对象，可以使⽤流操作；</li><li>尽量使⽤对象池，不再循环中创建对象，优化配置；</li><li>创建对象到单例getInstance中，对象⽆法回收被单例引⽤；</li><li>服务器session时间设置过⻓也会引起内存泄漏。</li></ul><h1 id="⽅法区oom"><a href="#⽅法区oom" class="headerlink" title="⽅法区oom"></a>⽅法区oom</h1><ul><li>⽅法区⽤于存放Class的相关信息，如：类名，访问修饰符，常量池，字符描述，⽅法描述等。</li><li>原因：运⾏时产⽣⼤量的类去填满⽅法区，直到溢出。</li></ul><h1 id="哪些情况下对象会进⼊⽼年代"><a href="#哪些情况下对象会进⼊⽼年代" class="headerlink" title="哪些情况下对象会进⼊⽼年代"></a>哪些情况下对象会进⼊⽼年代</h1><ul><li>新⽣代对象每次经历⼀次minor gc，年龄会加1，当达到年龄阈值（默认为15岁）会直接进⼊⽼年代</li><li>⼤对象直接进⼊⽼年代</li><li>新⽣代复制算法需要⼀个survivor区进⾏轮换备份，如果出现⼤量对象在minor gc后仍然存活的情况时，就需要⽼年代进⾏分配担保，让survivor⽆法容纳的对象直接进⼊⽼年代</li><li>如果在Survivor空间中相同年龄所有对象⼤⼩的总和⼤于Survivor空间的⼀半，年龄⼤于或等于该年龄的对象就可以直接进⼊年⽼代</li></ul><h1 id="当对象A创建之后，对象A在各个区之间的流转过程"><a href="#当对象A创建之后，对象A在各个区之间的流转过程" class="headerlink" title="当对象A创建之后，对象A在各个区之间的流转过程"></a>当对象A创建之后，对象A在各个区之间的流转过程</h1><ul><li>对象A被new出来之后，是被存放在Eden（伊甸园）区的</li><li>当发⽣⼀次GC后，Eden区存活下来的对象A会被复制到s1区，s0中存活的对象也会被复制到s1中。如果对象年龄超过阈值年龄（默认15岁），会被复制到⽼年区。部分对象也需要⽼年代分担。<br>c. GC会清空Eden和s0中存储的所有对象；<br>d. 交换s0和s1的⻆⾊；<br>e. 重复上⾯的步骤。</li></ul><h1 id="jvm体系总体分四大块"><a href="#jvm体系总体分四大块" class="headerlink" title="jvm体系总体分四大块"></a>jvm体系总体分四大块</h1><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul><h1 id="调优命令"><a href="#调优命令" class="headerlink" title="调优命令"></a>调优命令</h1><ul><li>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</li><li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>jstack，用于生成java虚拟机当前时刻的线程快照</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数</li><li>jstack可以看当前栈的情况，jmap查看内存，jhat 进行dump堆的信息</li></ul><h1 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h1><ul><li>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto</li><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等</li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>GChisto，一款专业分析gc日志的工具</li></ul><h1 id="SafePoint是什么"><a href="#SafePoint是什么" class="headerlink" title="SafePoint是什么"></a>SafePoint是什么</h1><ul><li>比如GC的时候必须要等到Java线程都进入到safepoint的时候VMThread才能开始执行GC，</li><li>循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)</li><li>方法返回前</li><li>调用方法的call之后</li><li>抛出异常的位置</li></ul><h1 id="简述java垃圾回收机制"><a href="#简述java垃圾回收机制" class="headerlink" title="简述java垃圾回收机制"></a>简述java垃圾回收机制</h1><ul><li>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行</li><li>在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</li></ul><h1 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h1><ul><li>－server 启用服务器模式（如果CPU多，服务器机建议使用此项）</li><li>－Xms，－Xmx一般设为同样大小。 800m</li><li>－Xmn 是将NewSize与MaxNewSize设为一致。320m</li><li>－XX：PerSize 64m</li><li>－XX：NewSize 320m 此值设大可调大新对象区，减少Full GC次数</li><li>－XX：MaxNewSize 320m</li><li>－XX：NewRato NewSize设了可不设。4</li><li>－XX： SurvivorRatio 4</li><li>－XX：userParNewGC 可用来设置并行收集</li><li>－XX：ParallelGCThreads 可用来增加并行度 4</li><li>－XXUseParallelGC 设置后可以使用并行清除收集器</li><li>－XX：UseAdaptiveSizePolicy 与上面一个联合使用效果更好，利用它可以自动优化新域大小以及救助空间比值</li><li>-XmxJavaHeap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；</li><li>-XmsJavaHeap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JVM/" rel="tag"># JVM</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/c0d8e27e97f4.html" rel="prev" title="多线程"><i class="fa fa-angle-left"></i> 多线程</a></div><div class="post-nav-item"><a href="/publishes/4a23c7da79c0.html" rel="next" title="Spring cloud">Spring cloud <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>