<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="什么是缓存雪崩如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了。 我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除 + 定期删除两种策略对过期键删除。如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。这就是缓存雪崩：Redi"><meta property="og:type" content="article"><meta property="og:title" content="Redis"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/5788a7088796.html"><meta property="og:site_name" content="Java后端面试指南"><meta property="og:description" content="什么是缓存雪崩如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了。 我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除 + 定期删除两种策略对过期键删除。如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。这就是缓存雪崩：Redi"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T08:24:36.000Z"><meta property="article:modified_time" content="2023-12-20T10:30:03.016Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="缓存"><meta property="article:tag" content="redis"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/5788a7088796.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/5788a7088796.html","path":"publishes/5788a7088796.html","title":"Redis"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Redis | Java后端面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java后端面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">1.</span> <span class="nav-text">什么是缓存雪崩</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">2.</span> <span class="nav-text">如何解决缓存雪崩</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">3.</span> <span class="nav-text">什么是缓存穿透</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">4.</span> <span class="nav-text">如何解决缓存穿透</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="nav-number">5.</span> <span class="nav-text">缓存与数据库双写一致</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">什么是缓存与数据库双写一致问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">7.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">8.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-number">9.</span> <span class="nav-text">缓存预热</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0"><span class="nav-number">10.</span> <span class="nav-text">缓存更新</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="nav-number">11.</span> <span class="nav-text">缓存降级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Redis"><span class="nav-number">12.</span> <span class="nav-text">为什么使用 Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">12.0.0.1.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">12.0.0.2.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Redis-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="nav-number">12.0.0.3.</span> <span class="nav-text">使用 Redis 有什么缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-number">12.0.0.4.</span> <span class="nav-text">单线程的 Redis 为什么这么快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">12.0.0.5.</span> <span class="nav-text">I&#x2F;O 多路复用机制</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%AF%8F%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">13.</span> <span class="nav-text">Redis 的数据类型，以及每种数据类型的使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">13.0.0.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash"><span class="nav-number">13.0.0.2.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">13.0.0.3.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">13.0.0.4.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sorted-Set"><span class="nav-number">13.0.0.5.</span> <span class="nav-text">Sorted Set</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">14.</span> <span class="nav-text">Redis 的过期策略以及内存淘汰机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">14.0.0.1.</span> <span class="nav-text">为什么不用定时删除策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4-%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="nav-number">14.0.0.2.</span> <span class="nav-text">定期删除+惰性删除是如何工作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#maxmemory-policy-volatile-lru"><span class="nav-number">15.</span> <span class="nav-text">maxmemory-policy volatile-lru</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">16.</span> <span class="nav-text">Redis 和数据库双写一致性问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="nav-number">17.</span> <span class="nav-text">如何应对缓存穿透和缓存雪崩问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-1"><span class="nav-number">17.0.0.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-1"><span class="nav-number">17.0.0.2.</span> <span class="nav-text">缓存雪崩</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Redis-%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89-Key-%E9%97%AE%E9%A2%98"><span class="nav-number">18.</span> <span class="nav-text">如何解决 Redis 的并发竞争 Key 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%AF%B9%E8%BF%99%E4%B8%AA-Key-%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%8D%E8%A6%81%E6%B1%82%E9%A1%BA%E5%BA%8F"><span class="nav-number">18.0.0.1.</span> <span class="nav-text">如果对这个 Key 操作，不要求顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%AF%B9%E8%BF%99%E4%B8%AA-Key-%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%A6%81%E6%B1%82%E9%A1%BA%E5%BA%8F"><span class="nav-number">18.0.0.2.</span> <span class="nav-text">如果对这个 Key 操作，要求顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%97%E4%B8%BE%E2%BC%80%E4%B8%AA%E5%B8%B8%E2%BD%A4%E7%9A%84Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="nav-number">19.</span> <span class="nav-text">列举⼀个常⽤的Redis客户端的并发模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%8C%E2%BC%80%E8%87%B4%E6%80%A7hash"><span class="nav-number">20.</span> <span class="nav-text">分布式缓存，⼀致性hash</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LRU%E7%AE%97%E6%B3%95%EF%BC%8C-slab%E5%88%86%E9%85%8D%EF%BC%8C%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%86%85%E5%AD%98%E7%A2%8E%E2%BD%9A"><span class="nav-number">21.</span> <span class="nav-text">LRU算法， slab分配，如何减少内存碎⽚</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%8D%95%E6%9C%BA%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98"><span class="nav-number">22.</span> <span class="nav-text">如何解决缓存单机热点问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#memcache%E4%B8%8Eredis%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">23.</span> <span class="nav-text">memcache与redis的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis-%E6%9C%AC%E8%BA%AB%E6%9C%89%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%86%99%E8%BF%9B-mysql-%E5%91%A2%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">redis 本身有持久化，为什么还要写进 mysql 呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%90%84%E7%A7%8D%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">redis的数据结构和各种应⽤场景？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">redis数据结构？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#codis%E5%92%8Credis%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">codis和redis集群的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E5%92%8Cmemcached%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E6%9C%89%E6%97%B6%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84redis%E6%AF%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84memcached%E6%95%88%E7%8E%87%E8%A6%81%E9%AB%98"><span class="nav-number">28.</span> <span class="nav-text">redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9Fredis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9Fredis%E7%9A%84key%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80%E7%9A%84%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8redis%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%EF%BC%9F%E4%BD%BF%E7%94%A8zk%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A5%E9%81%93redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E5%90%97%EF%BC%9F%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">知道redis的持久化吗？底层如何实现的？有什么优点缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FLRU%E7%AE%97%E6%B3%95%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F%E5%86%99%E4%B8%80%E4%B8%8Bjava%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">缓存穿透、缓存击穿、缓存雪崩解决方案？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E9%80%89%E6%8B%A9%E7%BC%93%E5%AD%98%E6%97%B6%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9redis%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9memcached"><span class="nav-number">34.</span> <span class="nav-text">在选择缓存时，什么时候选择redis，什么时候选择memcached</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">35.</span> <span class="nav-text">缓存与数据库不一致怎么办</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">36.</span> <span class="nav-text">主从数据库不一致如何解决</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%B8%B8%E8%A7%81%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">37.</span> <span class="nav-text">Redis常见的性能问题和解决方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">38.</span> <span class="nav-text">Redis的数据淘汰策略有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%BD%93%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">39.</span> <span class="nav-text">Redis当中有哪些数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%81%87%E5%A6%82Redis%E9%87%8C%E9%9D%A2%E6%9C%891%E4%BA%BF%E4%B8%AAkey%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%8910w%E4%B8%AAkey%E6%98%AF%E4%BB%A5%E6%9F%90%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%89%8D%E7%BC%80%E5%BC%80%E5%A4%B4%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B0%86%E5%AE%83%E4%BB%AC%E5%85%A8%E9%83%A8%E6%89%BE%E5%87%BA%E6%9D%A5"><span class="nav-number">40.</span> <span class="nav-text">假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%81%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97%E5%90%97%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">41.</span> <span class="nav-text">使用Redis做过异步队列吗，是如何实现的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="nav-number">42.</span> <span class="nav-text">Redis如何实现延时队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%B9%9F%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-number">43.</span> <span class="nav-text">Redis为什么使用单进程单线程方式也这么快</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">44.</span> <span class="nav-text">Redis对象类型简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDB-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">45.</span> <span class="nav-text">RDB 持久化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOF"><span class="nav-number">46.</span> <span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">47.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="nav-number">48.</span> <span class="nav-text">全量同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="nav-number">49.</span> <span class="nav-text">增量同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="nav-number">50.</span> <span class="nav-text">Redis主从同步策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">51.</span> <span class="nav-text">redis的过期策略以及内存淘汰机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98-1"><span class="nav-number">52.</span> <span class="nav-text">如何应对缓存穿透和缓存雪崩问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3redis%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89key%E9%97%AE%E9%A2%98"><span class="nav-number">53.</span> <span class="nav-text">如何解决redis的并发竞争key问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4"><span class="nav-number">54.</span> <span class="nav-text">集群</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis%E5%92%8Cmemcached%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89"><span class="nav-number">55.</span> <span class="nav-text">redis和memcached的区别（总结）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Redis%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">什么是 Redis？</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">44</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/5788a7088796.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java后端面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Redis | Java后端面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 16:24:36 / 修改时间：18:30:03" itemprop="dateCreated datePublished" datetime="2023-12-20T16:24:36+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h1><p>如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了。</p><p>我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除 + 定期删除两种策略对过期键删除。<br>如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。<br>这就是缓存雪崩：Redis挂掉了，请求全部走数据库。<br>缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！</p><h1 id="如何解决缓存雪崩"><a href="#如何解决缓存雪崩" class="headerlink" title="如何解决缓存雪崩"></a>如何解决缓存雪崩</h1><p>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。<br>对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：<br>事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。<br>事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)<br>事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</p><h1 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h1><p>缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存<br>这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。</p><p>这就是缓存穿透：请求的数据在缓存大量不命中，导致请求走数据库。<br>缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！</p><h1 id="如何解决缓存穿透"><a href="#如何解决缓存穿透" class="headerlink" title="如何解决缓存穿透"></a>如何解决缓存穿透</h1><p>解决缓存穿透也有两种方案：<br>由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！<br>当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。<br>这种情况我们一般会将空对象设置一个较短的过期时间</p><h1 id="缓存与数据库双写一致"><a href="#缓存与数据库双写一致" class="headerlink" title="缓存与数据库双写一致"></a>缓存与数据库双写一致</h1><p>对于读操作，流程是这样的<br>如果我们的数据在缓存里边有，那么就直接取缓存的。<br>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。最后将数据返回给请求</p><h1 id="什么是缓存与数据库双写一致问题"><a href="#什么是缓存与数据库双写一致问题" class="headerlink" title="什么是缓存与数据库双写一致问题"></a>什么是缓存与数据库双写一致问题</h1><p>如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要更新时候呢？各种情况很可能就造成数据库和缓存的数据不一致了。<br>这里不一致指的是：数据库的数据跟缓存的数据不一致<br>从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。<br>因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。<br>除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br>缓存失效时的雪崩效应对底层系统的冲击非常可怕！大多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>以下简单介绍两种实现方式的伪代码：<br>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队</p><p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！<br>注意：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！<br>（2）还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存</p><p>解释说明：<br>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；<br>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。<br>关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！</p><p>把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。</p><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>解决思路：<br>1、直接写个缓存刷新页面，上线时手工操作下；<br>2、数据量不大，可以在项目启动的时候自动进行加载；<br>3、定时刷新缓存；</p><h1 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h1><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>（1）定时去清理过期的缓存；<br>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><h1 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h1><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：<br>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；<br>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><h1 id="为什么使用-Redis"><a href="#为什么使用-Redis" class="headerlink" title="为什么使用 Redis"></a>为什么使用 Redis</h1><p>我觉得在项目中使用 Redis，主要是从两个角度去考虑：性能和并发。<br>当然，Redis 还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件，如 ZooKpeer 等代替，并不是非要使用 Redis。因此，这个问题主要从性能和并发两个角度去答。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p><p>题外话：忽然想聊一下这个迅速响应的标准。根据交互效果的不同，这个响应时间没有固定标准。<br>不过曾经有人这么告诉我：”在理想状态下，我们的页面跳转需要在瞬间解决，对于页内操作则需要在刹那间解决。<br>另外，超过一弹指的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”<br>那么瞬间、刹那、一弹指具体是多少时间呢？<br>根据《摩诃僧祗律》记载：<br>一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。<br>那么，经过周密的计算，一瞬间为 0.36 秒、一刹那有 0.018 秒、一弹指长达 7.2 秒。</p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。<br>这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库。</p><h4 id="使用-Redis-有什么缺点"><a href="#使用-Redis-有什么缺点" class="headerlink" title="使用 Redis 有什么缺点"></a>使用 Redis 有什么缺点</h4><p>大家用 Redis 这么久，这个问题是必须要了解的，基本上使用 Redis 都会碰到一些问题，常见的也就几个。<br>回答主要是四个问题：<br>缓存和数据库双写一致性问题<br>缓存雪崩问题<br>缓存击穿问题<br>缓存的并发竞争问题</p><h4 id="单线程的-Redis-为什么这么快"><a href="#单线程的-Redis-为什么这么快" class="headerlink" title="单线程的 Redis 为什么这么快"></a>单线程的 Redis 为什么这么快</h4><p>这个问题是对 Redis 内部机制的一个考察。根据我的面试经验，很多人都不知道Redis 是单线程工作模型。所以，这个问题还是应该要复习一下的。<br>回答主要是以下三点：</p><ul><li>纯内存操作</li><li>单线程操作，避免了频繁的上下文切换</li><li>采用了非阻塞 I/O 多路复用机制</li></ul><h4 id="I-O-多路复用机制"><a href="#I-O-多路复用机制" class="headerlink" title="I/O 多路复用机制"></a>I/O 多路复用机制</h4><p>题外话：我们现在要仔细的说一说 I/O 多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。<br>打一个比方：小曲在 S 城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。<br>经营方式一<br>客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。<br>慢慢的小曲就发现了这种经营方式存在下述问题：<br>几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递。<br>随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了。<br>快递员之间的协调很花时间。<br>综合上述缺点，小曲痛定思痛，提出了下面的经营方式。<br>经营方式二<br>小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。<br>最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。<br>上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢？<br>在上述比喻中：<br>每个快递员→每个线程<br>每个快递→每个 Socket(I/O 流)<br>快递的送达地点→Socket 的不同状态<br>客户送快递请求→来自客户端的请求<br>小曲的经营方式→服务端运行的代码<br>一辆车→CPU 的核数<br>于是我们有如下结论：<br>经营方式一就是传统的并发模型，每个 I/O 流(快递)都有一个新的线程(快递员)管理。<br>经营方式二就是 I/O 多路复用。只有单个线程(一个快递员)，通过跟踪每个 I/O 流的状态(每个快递的送达地点)，来管理多个 I/O 流。</p><p>简单来说，就是我们的 redis-client 在操作的时候，会产生具有不同事件类型的 Socket。<br>在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。<br>需要说明的是，这个 I/O 多路复用机制，Redis 还提供了 select、epoll、evport、kqueue 等多路复用函数库，大家可以自行去了解。</p><h1 id="Redis-的数据类型，以及每种数据类型的使用场景"><a href="#Redis-的数据类型，以及每种数据类型的使用场景" class="headerlink" title="Redis 的数据类型，以及每种数据类型的使用场景"></a>Redis 的数据类型，以及每种数据类型的使用场景</h1><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>这个没啥好说的，最常规的 set/get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存</p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。<br>我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 Set 进行去重？<br>因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><h4 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h4><p>Sorted Set多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。<br>可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。最后一个应用就是可以做范围查找。</p><h1 id="Redis-的过期策略以及内存淘汰机制"><a href="#Redis-的过期策略以及内存淘汰机制" class="headerlink" title="Redis 的过期策略以及内存淘汰机制"></a>Redis 的过期策略以及内存淘汰机制</h1><p>这个问题相当重要，到底 Redis 有没用到家，这个问题就可以看出来。<br>比如你 Redis 只能存 5G 数据，可是你写了 10G，那会删 5G 的数据。怎么删的，这个问题思考过么？<br>还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?<br>回答：Redis 采用的是定期删除+惰性删除策略。</p><h4 id="为什么不用定时删除策略"><a href="#为什么不用定时删除策略" class="headerlink" title="为什么不用定时删除策略"></a>为什么不用定时删除策略</h4><p>定时删除，用一个定时器来负责监视 Key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。<br>在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。</p><h4 id="定期删除-惰性删除是如何工作"><a href="#定期删除-惰性删除是如何工作" class="headerlink" title="定期删除+惰性删除是如何工作"></a>定期删除+惰性删除是如何工作</h4><p>定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。<br>需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。<br>因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。<br>也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。<br>采用定期删除+惰性删除就没其他问题了么?<br>不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在 redis.conf 中有一行配置：</p><h1 id="maxmemory-policy-volatile-lru"><a href="#maxmemory-policy-volatile-lru" class="headerlink" title="maxmemory-policy volatile-lru"></a>maxmemory-policy volatile-lru</h1><p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)：<br>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。<br>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。<br>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。<br>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。<br>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。<br>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。<br>PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。</p><h1 id="Redis-和数据库双写一致性问题"><a href="#Redis-和数据库双写一致性问题" class="headerlink" title="Redis 和数据库双写一致性问题"></a>Redis 和数据库双写一致性问题</h1><p>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。<br>答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。<br>另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。<br>回答：首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p><h1 id="如何应对缓存穿透和缓存雪崩问题"><a href="#如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="如何应对缓存穿透和缓存雪崩问题"></a>如何应对缓存穿透和缓存雪崩问题</h1><h4 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。<br>缓存穿透解决方案：<br>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。<br>采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。</p><h4 id="缓存雪崩-1"><a href="#缓存雪崩-1" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。<br>缓存雪崩解决方案：<br>给缓存的失效时间，加上一个随机值，避免集体失效。<br>使用互斥锁，但是该方案吞吐量明显下降了。<br>双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。<br>然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。</p><h1 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h1><p>这个问题大致就是，同时有多个子系统去 Set 一个 Key。这个时候大家思考过要注意什么呢？<br>需要说明一下，我提前百度了一下，发现答案基本都是推荐用 Redis 事务机制。<br>我并不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。<br>你一个事务中有涉及到多个 Key 操作的时候，这多个 Key 不一定都存储在同一个 redis-server 上。因此，Redis 的事务机制，十分鸡肋。</p><h4 id="如果对这个-Key-操作，不要求顺序"><a href="#如果对这个-Key-操作，不要求顺序" class="headerlink" title="如果对这个 Key 操作，不要求顺序"></a>如果对这个 Key 操作，不要求顺序</h4><p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。</p><h4 id="如果对这个-Key-操作，要求顺序"><a href="#如果对这个-Key-操作，要求顺序" class="headerlink" title="如果对这个 Key 操作，要求顺序"></a>如果对这个 Key 操作，要求顺序</h4><p>假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。<br>期望按照 key1 的 value 值按照 valueA &gt; valueB &gt; valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。<br>假设时间戳如下：<br>系统A key 1 {valueA 3:00}<br>系统B key 1 {valueB 3:05}<br>系统C key 1 {valueC 3:10}<br>那么，假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。<br>其他方法，比如利用队列，将 set 方法变成串行访问也可以。总之，灵活变通。</p><h1 id="列举⼀个常⽤的Redis客户端的并发模型"><a href="#列举⼀个常⽤的Redis客户端的并发模型" class="headerlink" title="列举⼀个常⽤的Redis客户端的并发模型"></a>列举⼀个常⽤的Redis客户端的并发模型</h1><pre><code>lock = 0;
while (timeout &gt; 0) &#123;
if (setnxexpire(key, value)) &#123;
lock = 1;
return lock;
&#125;

timeout -= sleeptime
sleep(sleeptime);
 &#125;
</code></pre><h1 id="分布式缓存，⼀致性hash"><a href="#分布式缓存，⼀致性hash" class="headerlink" title="分布式缓存，⼀致性hash"></a>分布式缓存，⼀致性hash</h1><p>1、⼀致性hash算法：我们的memcached客户端（这⾥我看的spymemcache的源码），使⽤了⼀致性hash算法<br>ketama进⾏数据存储节点的选择。与常规的hash算法思路不同，只是对我们要存储数据的key进⾏hash计算，分配到不同节点<br>存储。⼀致性hash算法是对我们要存储数据的服务器进⾏hash计算，进⽽确认每个key的存储位置。这⾥提到的⼀致性hash算<br>法ketama的做法是：选择具体的机器节点不在只依赖需要缓存数据的key的hash本身了，⽽是机器节点本身也进⾏了hash运<br>算。<br>1、⼀致性hash算法是分布式系统中常⽤算法，设计⽬的是为了解决因特⽹中的热点(hot spot)问题。解决了P2P<br>环境最为关键问题—如何在动态⽹络拓扑中分布存储和路由；<br>2、⼀致性hash算法引⼊虚拟节点机制，解决服务节点少时数据倾斜问题(即对每⼀个服务节点计算多个哈希，每<br>个计算结果位置都放置⼀个此服务节点，称为虚拟节点。)；<br>2、具体做法：如果有⼀个写⼊缓存的请求，其中Key值为K，计算器hash值Hash(K)， Hash(K) 对应于图 – 1环中的<br>某⼀个点，如果该点对应没有映射到具体的某⼀个机器节点，那么顺时针查找，直到第⼀次找到有映射机器的节点，该节点就<br>是确定的⽬标节点，如果超过了2^32仍然找不到节点，则命中第⼀个机器节点。⽐如 Hash(K) 的值介于A~B之间，那么命中<br>的机器节点应该是B节点（如上图 ）。<br>3、数据保存流程：<br>1、⾸先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。<br>2、然后采⽤同样的⽅法求出存储数据的键的哈希值，并映射到相同的圆上。<br>3、然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第⼀个服务器上。如果超过232仍然找不到<br>服务器，就会保存到第⼀台memcached服务器上。</p><h1 id="LRU算法，-slab分配，如何减少内存碎⽚"><a href="#LRU算法，-slab分配，如何减少内存碎⽚" class="headerlink" title="LRU算法， slab分配，如何减少内存碎⽚"></a>LRU算法， slab分配，如何减少内存碎⽚</h1><p>memcached预先将分配的内存分割成各种尺⼨的块(chunk)，并把尺⼨相同的块分成组(chunk的集合)，以此克服内<br>存碎⽚化问题</p><h1 id="如何解决缓存单机热点问题"><a href="#如何解决缓存单机热点问题" class="headerlink" title="如何解决缓存单机热点问题"></a>如何解决缓存单机热点问题</h1><p>a. 原因：<br>1、缓存服务器⾃身有限流保持<br>缓存服务器数量 * 单机能够承受的qps &gt; ⽤户最⼤的QPS 就会触发限流保护<br>针对这个原因：可以做横向扩容。加机器即可<br>2、⽤户访问过来cache服务器集中打到⼀台上⾯了。⼤流量并没有按预期的那样分摊到不同的cache机器上<br>导致出现单机热点。(热点数据)<br>针对这个原因：只要计算cache-hash算法不出问题，那基本上可以做到缓存的随机分布均匀的<br>3、缓存⾥⾯的value过⼤，导致虽然QPS不⾼，但⽹络流量（qps * 单个value的⼤⼩）还是过⼤，触发了cache<br>机器单台机器的⽹络流量限流；<br>针对这个原因：需要把⼤value进⾏精简，部分可以放在本机内存⽽不需要⾛远程获取这种⽅式的。<br>b. 解决⽅法：针对cache中元素key的访问监控。⼀旦发现cache有qps限流或⽹络⼤⼩限流时，能够通过监控看到到<br>底是哪个key并发访问量过⼤导致，或者哪些key返回的value⼤⼩较⼤，再结合cache散列算法，通过⼀定的规则动态<br>修改key值去平摊到各个cache机器上去。</p><h1 id="memcache与redis的区别"><a href="#memcache与redis的区别" class="headerlink" title="memcache与redis的区别"></a>memcache与redis的区别</h1><ol><li>Redis中，并不是所有的数据都⼀直存储在内存中的，这是和Memcached相⽐⼀个最⼤的区别。</li><li>Memcache仅仅⽀持简单的k/v类型的数据，Redis同时还提供String, list，set，hash等数据结构的存储。</li><li>Redis⽀持数据的备份，即master-slave模式的数据备份。</li><li>Redis⽀持数据的持久化，可以将内存中的数据保持在磁盘中（rdb定时快照和aof实时记录操作命令的⽇志备<br>份），重启的时候可以再次加载进⾏使⽤。Redis在很多⽅⾯具备数据库的特征，或者说就是⼀个数据库系统，⽽<br>Memcached只是简单的K/V缓存</li><li>Redis可以做⼀些聚合、排序操作。</li><li>memcache使⽤cas乐观锁做⼀致性：拿版本号，操作，对⽐版本号，如果⼀致就操作，不⼀致就放弃任何操作；</li><li>⼤数据memcached性能更⾼。由于Redis只使⽤单核，⽽Memcached可以使⽤多核，所以平均每⼀个核上<br>Redis在存储⼩数据时⽐Memcached性能更 ⾼。⽽在100k以上的数据中，Memcached性能要⾼于Redis 。</li></ol><h1 id="redis-本身有持久化，为什么还要写进-mysql-呢？"><a href="#redis-本身有持久化，为什么还要写进-mysql-呢？" class="headerlink" title="redis 本身有持久化，为什么还要写进 mysql 呢？"></a>redis 本身有持久化，为什么还要写进 mysql 呢？</h1><p>RDB：快照形式是直接把内存中的数据保存到⼀个 dump ⽂件中，定时保存，保存策略。<br>AOF：把所有的对Redis的服务器进⾏修改的命令都存到⼀个⽂件⾥，命令的集合。<br>RDB会丢数据，AOP性能不⾏<br>有改动先插⼊数据库，再插缓存，⽐较靠谱但性能⼀般；<br>有改动先插缓存，批量更新到数据库，靠谱度略差，但性能好。</p><h1 id="redis的数据结构和各种应⽤场景？"><a href="#redis的数据结构和各种应⽤场景？" class="headerlink" title="redis的数据结构和各种应⽤场景？"></a>redis的数据结构和各种应⽤场景？</h1><p>a. 更多的数据结构；<br>b. 可持久化；<br>c. 计数器；<br>d. 发布-订阅功能；<br>e. 事务功能；<br>f. 过期回调功能；<br>g. 队列功能；<br>h. 排序、聚合查询功能。</p><h1 id="redis数据结构？"><a href="#redis数据结构？" class="headerlink" title="redis数据结构？"></a>redis数据结构？</h1><p>a. Redis有5个基本数据结构，string、list、hash、set和zset。<br>b. String：string表示的是⼀个可变的字节数组，我们初始化字符串的内容、可以拿到字符串的⻓度，可以获<br>取string的⼦串，可以覆盖string的⼦串内容，可以追加⼦串。<br>c. List：Redis将列表数据结构命名为list⽽不是array，是因为列表的存储结构⽤的是链表⽽不是数组，⽽且链<br>表还是双向链表。因为它是链表，所以随机定位性能较弱，⾸尾插⼊删除性能较优。如果list的列表⻓度很<br>⻓，使⽤时我们⼀定要关注链表相关操作的时间复杂度。<br>d. hash：哈希等价于Java语⾔的HashMap或者是Python语⾔的dict，在实现结构上它使⽤⼆维结构，第⼀维是数<br>组，第⼆维是链表，hash的内容key和value存放在链表中，数组⾥存放的是链表的头指针。通过key查找元素时，先<br>计算key的hashcode，然后⽤hashcode对数组的⻓度进⾏取模定位到链表的表头，再对链表进⾏遍历获取到相应的<br>value值，链表的作⽤就是⽤来将产⽣了「hash碰撞」的元素串起来。Java语⾔开发者会感到⾮常熟悉，因为这样的<br>结构和HashMap是没有区别的。哈希的第⼀维数组的⻓度也是2^n。<br>e. set：Java程序员都知道HashSet的内部实现使⽤的是HashMap，只不过所有的value都指向同⼀个对象。<br>Redis的set结构也是⼀样，它的内部也使⽤hash结构，所有的value都指向同⼀个内部值。<br>f. SortedSet(zset)：是Redis提供的⼀个⾮常特别的数据结构，⼀⽅⾯它等价于Java的数据结构Map&lt;String,<br>Double&gt;，可以给每⼀个元素value赋予⼀个权重score，另⼀⽅⾯它⼜类似于TreeSet，内部的元素会按照权重<br>score进⾏排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><h1 id="codis和redis集群的区别？"><a href="#codis和redis集群的区别？" class="headerlink" title="codis和redis集群的区别？"></a>codis和redis集群的区别？</h1><h1 id="redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高"><a href="#redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高" class="headerlink" title="redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高"></a>redis和memcached什么区别？为什么高并发下有时单线程的redis比多线程的memcached效率要高</h1><p>区别：<br>1.mc可缓存图片和视频。rd支持除k/v更多的数据结构;<br>2.rd可以使用虚拟内存，rd可持久化和aof灾难恢复，rd通过主从支持数据备份;<br>3.rd可以做消息队列。<br>原因：mc多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。</p><h1 id="redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？"><a href="#redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？" class="headerlink" title="redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？"></a>redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？</h1><p>主从复制实现：主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数据恢复到内存中。之后再每次增加新数据的时候，主节点以类似于mysql的二进制日志方式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放。<br>分片方式：<br>-客户端分片<br>-基于代理的分片<br>● Twemproxy<br>● codis<br>-路由查询分片<br>● Redis-cluster（本身提供了自动将数据分散到Redis Cluster不同节点的能力，整个数据集合的某个数据子集存储在哪个节点对于用户来说是透明的）<br>redis-cluster分片原理：Cluster中有一个16384长度的槽(虚拟槽)，编号分别为0-16383。每个Master节点都会负责一部分的槽，当有某个key被映射到某个Master负责的槽，那么这个Master负责为这个key提供服务，至于哪个Master节点负责哪个槽，可以由用户指定，也可以在初始化的时候自动生成，只有Master才拥有槽的所有权。Master节点维护着一个16384/8字节的位序列，Master节点用bit来标识对于某个槽自己是否拥有。比如对于编号为1的槽，Master只要判断序列的第二位（索引从0开始）是不是为1即可。这种结构很容易添加或者删除节点。比如如果我想新添加个节点D, 我需要从节点A、B、 C中得部分槽到D上。</p><h1 id="使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？"><a href="#使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？" class="headerlink" title="使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？"></a>使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？</h1><p>redis:<br>1.线程A setnx(上锁的对象,超时时的时间戳t1)，如果返回true，获得锁。<br>2.线程B 用get获取t1,与当前时间戳比较,判断是是否超时,没超时false,若超时执行第3步;<br>3.计算新的超时时间t2,使用getset命令返回t3(该值可能其他线程已经修改过),如果t1==t3，获得锁，如果t1!=t3说明锁被其他线程获取了。<br>4.获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）。<br>zk:<br>1.客户端对某个方法加锁时，在zk上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点node1;<br>2.客户端获取该路径下所有已经创建的子节点，如果发现自己创建的node1的序号是最小的，就认为这个客户端获得了锁。<br>3.如果发现node1不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。<br>4.获取锁后，处理完逻辑，删除自己创建的node1即可。<br>区别:zk性能差一些，开销大，实现简单。</p><h1 id="知道redis的持久化吗？底层如何实现的？有什么优点缺点？"><a href="#知道redis的持久化吗？底层如何实现的？有什么优点缺点？" class="headerlink" title="知道redis的持久化吗？底层如何实现的？有什么优点缺点？"></a>知道redis的持久化吗？底层如何实现的？有什么优点缺点？</h1><p>RDB(Redis DataBase:在不同的时间点将redis的数据生成的快照同步到磁盘等介质上):内存到硬盘的快照，定期更新。缺点：耗时，耗性能(fork+io操作)，易丢失数据。<br>AOF(Append Only File：将redis所执行过的所有指令都记录下来，在下次redis重启时，只需要执行指令就可以了):写日志。缺点：体积大，恢复速度慢。</p><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会消耗比较长的时间，不够实时，在停机的时候会导致大量的数据丢失，需要aof来配合，在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复。Redis会定期做aof重写，压缩aof文件日志大小。Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。bgsave的原理，fork和cow, fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h1 id="redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？"><a href="#redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？" class="headerlink" title="redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？"></a>redis过期策略都有哪些？LRU算法知道吗？写一下java代码实现？</h1><p>过期策略:<br>定时过期(一key一定时器)，惰性过期：只有使用key时才判断key是否已过期，过期则清除。定期过期：前两者折中。<br>LRU:new LinkedHashMap&lt;K, V&gt;(capacity, DEFAULT_LOAD_FACTORY, true);<br>//第三个参数置为true，代表linkedlist按访问顺序排序，可作为LRU缓存；设为false代表按插入顺序排序，可作为FIFO缓存<br>LRU算法实现：1.通过双向链表来实现，新数据插入到链表头部；2.每当缓存命中（即缓存数据被访问），则将数据移到链表头部；3.当链表满的时候，将链表尾部的数据丢弃。</p><p>LinkedHashMap：HashMap和双向链表合二为一即是LinkedHashMap。HashMap是无序的，LinkedHashMap通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插入顺序（默认），也可以是访问顺序。</p><h1 id="缓存穿透、缓存击穿、缓存雪崩解决方案？"><a href="#缓存穿透、缓存击穿、缓存雪崩解决方案？" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩解决方案？"></a>缓存穿透、缓存击穿、缓存雪崩解决方案？</h1><p>缓存穿透：指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，可能导致DB挂掉。<br>解决方案：1.查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短；2.布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对DB的查询。<br>缓存击穿：对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮。<br>解决方案：1.使用互斥锁：当缓存失效时，不立即去load db，先使用如Redis的setnx去设置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的方法。2.永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新）。<br>缓存雪崩：设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。<br>解决方案：将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h1 id="在选择缓存时，什么时候选择redis，什么时候选择memcached"><a href="#在选择缓存时，什么时候选择redis，什么时候选择memcached" class="headerlink" title="在选择缓存时，什么时候选择redis，什么时候选择memcached"></a>在选择缓存时，什么时候选择redis，什么时候选择memcached</h1><p>选择redis的情况：</p><p>      1、复杂数据结构，value的数据是哈希，列表，集合，有序集合等这种情况下，会选择redis, 因为memcache无法满足这些数据结构，最典型的的使用场景是，用户订单列表，用户消息，帖子评论等。</p><p>      2、需要进行数据的持久化功能，但是注意，不要把redis当成数据库使用，如果redis挂了，内存能够快速恢复热数据，不会将压力瞬间压在数据库上，没有cache预热的过程。对于只读和数据一致性要求不高的场景可以采用持久化存储</p><p>      3、高可用，redis支持集群，可以实现主动复制，读写分离，而对于memcache如果想要实现高可用，需要进行二次开发。</p><p>      4、存储的内容比较大，memcache存储的value最大为1M。</p><p>选择memcache的场景：</p><p>     1、纯KV,数据量非常大的业务，使用memcache更合适，原因是，</p><p>           a)memcache的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时间，redis是临时申请空间，可能导致碎片化。</p><p>           b)虚拟内存使用，memcache将所有的数据存储在物理内存里，redis有自己的vm机制，理论上能够存储比物理内存更多的数据，当数据超量时，引发swap,把冷数据刷新到磁盘上，从这点上，数据量大时，memcache更快</p><p>           c)网络模型，memcache使用非阻塞的IO复用模型，redis也是使用非阻塞的IO复用模型，但是redis还提供了一些非KV存储之外的排序，聚合功能，复杂的CPU计算，会阻塞整个IO调度，从这点上由于redis提供的功能较多，memcache更快些</p><p>           d) 线程模型，memcache使用多线程，主线程监听，worker子线程接受请求，执行读写，这个过程可能存在锁冲突。redis使用的单线程，虽然无锁冲突，但是难以利用多核的特性提升吞吐量。</p><h1 id="缓存与数据库不一致怎么办"><a href="#缓存与数据库不一致怎么办" class="headerlink" title="缓存与数据库不一致怎么办"></a>缓存与数据库不一致怎么办</h1><p>假设采用的主存分离，读写分离的数据库，</p><p>如果一个线程A先删除缓存数据，然后将数据写入到主库当中，这个时候，主库和从库同步没有完成，线程B从缓存当中读取数据失败，从从库当中读取到旧数据，然后更新至缓存，这个时候，缓存当中的就是旧的数据。</p><p>发生上述不一致的原因在于，主从库数据不一致问题，加入了缓存之后，主从不一致的时间被拉长了</p><p>处理思路：在从库有数据更新之后，将缓存当中的数据也同时进行更新，即当从库发生了数据更新之后，向缓存发出删除，淘汰这段时间写入的旧数据。</p><h1 id="主从数据库不一致如何解决"><a href="#主从数据库不一致如何解决" class="headerlink" title="主从数据库不一致如何解决"></a>主从数据库不一致如何解决</h1><p>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</p><p>1、忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</p><p>2、强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</p><p>3、选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</p><h1 id="Redis常见的性能问题和解决方案"><a href="#Redis常见的性能问题和解决方案" class="headerlink" title="Redis常见的性能问题和解决方案"></a>Redis常见的性能问题和解决方案</h1><p>1、master最好不要做持久化工作，如RDB内存快照和AOF日志文件<br>2、如果数据比较重要，某个slave开启AOF备份，策略设置成每秒同步一次<br>3、为了主从复制的速度和连接的稳定性，master和Slave最好在一个局域网内<br>4、尽量避免在压力大得主库上增加从库<br>5、主从复制不要采用网状结构，尽量是线性结构，<code>Master&lt;-- Slave1 &lt;--Slave2</code></p><h1 id="Redis的数据淘汰策略有哪些"><a href="#Redis的数据淘汰策略有哪些" class="headerlink" title="Redis的数据淘汰策略有哪些"></a>Redis的数据淘汰策略有哪些</h1><p>voltile-lru 从已经设置过期时间的数据集中挑选最近最少使用的数据淘汰<br>voltile-ttl 从已经设置过期时间的数据库集当中挑选将要过期的数据<br>voltile-random 从已经设置过期时间的数据集任意选择淘汰数据<br>allkeys-lru 从数据集中挑选最近最少使用的数据淘汰<br>allkeys-random 从数据集中任意选择淘汰的数据<br>no-eviction 禁止驱逐数据</p><h1 id="Redis当中有哪些数据结构"><a href="#Redis当中有哪些数据结构" class="headerlink" title="Redis当中有哪些数据结构"></a>Redis当中有哪些数据结构</h1><p>字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。如果是高级用户，那么还会有，如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。</p><h1 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来</h1><p>使用keys指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h1 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h1><p>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p><h1 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h1><p>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理</p><h1 id="Redis为什么使用单进程单线程方式也这么快"><a href="#Redis为什么使用单进程单线程方式也这么快" class="headerlink" title="Redis为什么使用单进程单线程方式也这么快"></a>Redis为什么使用单进程单线程方式也这么快</h1><p>Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。<br>Redis快的主要原因是：<br>完全基于内存<br>数据结构简单，对数据操作也简单<br>使用多路 I/O 复用模型<br>第一、二点不细讲，主要围绕第三点采用多路 I/O 复用技术来展开。<br>多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p>单进程单线程好处<br>代码更清晰，处理逻辑更简单<br>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗<br>不存在多进程或者多线程导致的切换而消耗CPU<br>单进程单线程弊端<br>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；<br>其他一些优秀的开源软件采用的模型<br>多进程单线程模型：Nginx<br>单进程多线程模型：Memcached</p><h1 id="Redis对象类型简介"><a href="#Redis对象类型简介" class="headerlink" title="Redis对象类型简介"></a>Redis对象类型简介</h1><p>字符串：int，raw或者embstr。Long 简单动态字符串<br>列表：ziplist(压缩列表) 和 linkedlist(双端链表)<br>哈希：ziplist 或者 hashtable。<br>集合对象：intset 或者 hashtable。整数集合，字典。<br>有序集合： ziplist 或者 skiplist。压缩列表，跳跃表</p><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>  跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。<br>  在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。<br>  Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。<br>  和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p><p>简单动态字符串</p><p>链表<br>　Redis链表特性：<br>　　①、双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。<br>　　②、无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。　　<br>　　③、带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。<br>　　④、多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</p><p>字典<br>　Redis 的字典使用哈希表作为底层实现<br>有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。<br>redis支持多种数据结构，其中dict是使用频率相当高，也是非常实用的一种结构。在redis的具体实现中，使用了一种叫做渐进式哈希(rehashing)的机制来提高dict的缩放效率，<br>渐进式哈希的精髓在于：数据的迁移不是一次性完成的，而是可以通过dictRehash()这个函数分步规划的，并且调用方可以及时知道是否需要继续进行渐进式哈希操作。如果dict数据结构中存储了海量的数据，那么一次性迁移势必带来redis性能的下降，别忘了redis是单线程模型，在实时性要求高的场景下这可能是致命的。而渐进式哈希则将这种代价可控地分摊了，调用方可以在dict做插入，删除，更新的时候执行dictRehash()，最小化数据迁移的代价。 </p><p>跳跃表<br>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：<br>　　1、由很多层结构组成；<br>　　2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；<br>　　3、最底层的链表包含了所有的元素；<br>　　4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；<br>　　5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；<br>整数集合<br>支持升级，不支持降级<br>　整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。<br>压缩列表<br>压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。<br>　　压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。</p><h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><p>Redis 相对于 Memcache 等其他的缓存产品，有一个比较明显的优势就是 Redis 不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。这几种丰富的数据类型我们花了两篇文章进行了详细的介绍，接下来我们要介绍 Redis 的另外一大优势——持久化。<br>Redis 支持两种形式的持久化，一种是RDB快照（snapshotting），另外一种是AOF（append-only-file）。</p><p>　RDB 有两种触发方式，分别是自动触发和手动触发。<br>在 redis.conf 配置文件中的 SNAPSHOTTING 下<br>save：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。<br>bgsave<br>　　执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</p><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>开启 AOF<br>　　将 redis.conf 的 appendonly 配置改为 yes 即可。<br>Redis的持久化方式之一RDB是通过保存数据库中的键值对来记录数据库的状态。而另一种持久化方式 AOF 则是通过保存Redis服务器所执行的写命令来记录数据库状态。<br>优点：<br>　　①、AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。<br>　　②、AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。<br>　　③、AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。<br>　　缺点：<br>　　①、对于具有相同数据的的 Redis，AOF 文件通常会比 RDF 文件体积更大。<br>　　②、虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。<br>　　③、RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。<br> 　　那么对于 AOF 和 RDB 两种持久化方式，我们应该如何选择呢？<br>　　如果可以忍受一小段时间内数据的丢失，毫无疑问使用 RDB 是最好的，定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，而且使用 RDB 还可以避免 AOF 一些隐藏的 bug；否则就使用 AOF 重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。Redis后期官方可能都有将两种持久化方式整合为一种持久化模型。</p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>通常会采取的一种方式是主从架构Master/Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。<br>1 redis-server –port 6380 –slaveof<master-ip><master-port>，配置当前服务为某Redis服务的Slave<br>2 SLAVEOF host port命令，将当前服务器状态从Master修改为别的服务器的Slave<br>redis&gt;SLAVEOF 192.169.0.110 6379，将服务器转换为Slave<br>redis&gt;SLAVEOF NO ONE 将服务器状态重新恢复到Master，不会丢弃已同步的数据<br>3 配置方式：启动时，服务器读取配置文件，并自动成为指定服务器的从服务器<br>slaveof <master-ip><master-port><br>slaveof 127.0.0.1 6379</master-port></master-ip></master-port></master-ip></p><h1 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h1><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： <br>-  从服务器连接主服务器，发送SYNC命令； <br>-  主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； <br>-  主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； <br>-  从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； <br>-  主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； <br>-  从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p><h1 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h1><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 <br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。  </p><h1 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h1><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p><p>如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</p><p>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。<br> 不持久化的主服务器自动重启非常危险呢？</p><p>复制原理<br>       1、Slave启动成功连接到master后会发送一个sync命令；<br>       2、Master接到命令启动后的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master<br>            将传送整个数据文件到slave，以完成一次完全同步；<br>       3、全量复制：而slave服务在数据库文件数据后，将其存盘并加载到内存中；<br>       4、增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步；<br>       5、但是只要是重新连接master，一次完全同步（全量复制）将被自动执行。<br>五、哨兵模式（sentinel）<br>       反客为主的自动版，能够后台监控Master库是否故障，如果故障了根据投票数自动将slave库转换为主库。一组sentinel能<br>       同时监控多个Master。<br>       使用步骤：<br>       1、在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；<br>       2、配置哨兵，在sentinel.conf文件中填入内容：<br>             sentinel monitor 被监控数据库名字（自己起名字） ip port 1<br>             说明：上面最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机。<br>      3、启动哨兵模式：<br>            命令键入：redis-sentinel  /myredis/sentinel.conf<br>           注：上述sentinel.conf路径按各自实际情况配置<br>六、复制的缺点<br>            延时，由于所有的写操作都是在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定<br>       的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使得这个问题更加严重。</p><h1 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h1><p>分析:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?<br>回答:<br>redis采用的是定期删除+惰性删除策略。<br>为什么不用定时删除策略?<br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.<br>定期删除+惰性删除是如何工作的呢?<br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p><h1 id="如何应对缓存穿透和缓存雪崩问题-1"><a href="#如何应对缓存穿透和缓存雪崩问题-1" class="headerlink" title="如何应对缓存穿透和缓存雪崩问题"></a>如何应对缓存穿透和缓存雪崩问题</h1><p>分析:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。<br>回答:如下所示<br>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。<br>解决方案:<br>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。<br>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。<br>解决方案:<br>(一)给缓存的失效时间，加上一个随机值，避免集体失效。<br>(二)使用互斥锁，但是该方案吞吐量明显下降了。<br>(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点<br>I 从缓存A读数据库，有则直接返回<br>II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。<br>III 更新线程同时更新缓存A和缓存B。</p><h1 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h1><p>分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。<br>回答:如下所示<br>(1)如果对这个key操作，不要求顺序<br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下<br>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。<br>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。<br>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的时候看到set 和 get 的时候，直接跳转到了7000端口的节点。<br>Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。<br>需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</p><h1 id="redis和memcached的区别（总结）"><a href="#redis和memcached的区别（总结）" class="headerlink" title="redis和memcached的区别（总结）"></a>redis和memcached的区别（总结）</h1><p>Redis和Memcache都是将数据存放在内存中<br>1.数据类型<br>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；<br>2.过期<br>过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；<br>3.持久化，数据恢复，快照，aof<br>4.集群，主从复制</p><h1 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h1><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统<br>加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为<br>是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能<br>最快的 Key-Value DB。<br>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个<br>value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用<br>来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能<br>消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入的<br>Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。<br>Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因<br>此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。<br>2、Redis 相比 memcached 有哪些优势？<br>(1) memcached 所有的值均是简单的字符串，Redis 作为其替代者，支持更为丰富的数据类<br>型<br>(2) Redis 的速度比 memcached 快很多<br>(3) Redis 可以持久化其数据<br>3、Redis 支持哪几种数据类型？<br>String、List、Set、Sorted Set、hashes<br>4、Redis 主要消耗什么物理资源？<br>内存。<br>5、Redis 的全称是什么？<br>Remote Dictionary Server。<br>6、Redis 有哪几种数据淘汰策略？<br>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大<br>部分的写入指令，但 DEL 和几个例外）<br>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。<br>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据<br>有空间存放。<br>allkeys-random: 回收随机的键使得新添加的数据有空间存放。<br>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。<br>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的<br>数据有空间存放。<br>7、Redis 官方为什么不提供 Windows 版本？<br>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来<br>兼容性等问题。<br>8、一个字符串类型的值能存储最大容量是多少？<br>512M<br>9、为什么 Redis 需要把所有数据放到内存中？<br>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。<br>所以 Redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重<br>影响 Redis 的性能。在内存越来越便宜的今天，Redis 将会越来越受欢迎。<br>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。<br>10、Redis 集群方案应该怎么做？都有哪些方案？<br>1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 Redis 无任何区别，<br>设置好它下属的多个 Redis 实例后，使用时在本需要连接 Redis 的地方改为连接<br>twemproxy，它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具<br>体 Redis，将结果再返回 twemproxy。使用方式简便(相对 Redis 只需修改连接端口)，对<br>旧项目扩展的首选。 问题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对<br>Redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。<br>2. codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点<br>数量改变情况下，旧节点数据可恢复到新 hash 节点。<br>3. Redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash<br>槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。<br>4.在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 key 进行 hash 计算，<br>然后去对应的 Redis 实例操作数据。 这种方式对 hash 层代码要求比较高，考虑部分包括，<br>节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。<br>11、Redis 集群方案什么情况下会导致整个集群不可用？<br>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就<br>会以为缺少 5501-11000 这个范围的槽而不可用。<br>12、MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，<br>如何保证 Redis 中的数据都是热点数据？<br>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。<br>13、Redis 有哪些适合的场景？<br>（1）、会话缓存（Session Cache）<br>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他<br>存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性<br>的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样<br>吗？<br>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文<br>档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。<br>（2）、全页缓存（FPC）<br>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启<br>了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极<br>大改进，类似 PHP 本地 FPC。<br>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。<br>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-Redis，这个插件<br>能帮助你以最快速度加载你曾浏览过的页面。<br>（3）、队列<br>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个<br>很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如<br>Python）对 list 的 push/pop 操作。<br>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些<br>项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery<br>有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。<br>（4）、排行榜/计数器<br>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted<br>Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据<br>结构。所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为<br>“user_scores”，我们只需要像下面一样执行即可：<br>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你<br>需要这样执行：<br>ZRANGE user_scores 0 10 WITHSCORES<br>Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储<br>数据的，你可以在这里看到。<br>（5）、发布/订阅<br>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非<br>常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至<br>用 Redis 的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。<br>14、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？<br>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。<br>15、Redis 和 Redisson 有什么关系？<br>Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一<br>些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。<br>16、Jedis 与 Redisson 对比有什么优缺点？<br>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；<br>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支<br>持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使<br>用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。<br>17、Redis 如何设置密码及验证密码？<br>设置密码：config set requirepass 123456<br>授权密码：auth 123456<br>18、说说 Redis 哈希槽的概念？<br>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，<br>每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分<br>hash 槽。<br>19、Redis 集群的主从复制模型是怎样的？<br>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主<br>从复制模型,每个节点都会有 N-1 个复制品. 20、Redis 集群会有写操作丢失吗？为什么？<br>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操<br>作。<br>21、Redis 集群之间是如何复制的？<br>异步复制<br>22、Redis 集群最大节点个数是多少？<br>16384 个。<br>23、Redis 集群如何选择数据库？<br>Redis 集群目前无法做数据库选择，默认在 0 数据库。<br>24、怎么测试 Redis 的连通性？<br>ping<br>25、Redis 中的管道有什么用？<br>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命<br>令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。<br>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现<br>支持这个功能，大大加快了从服务器下载新邮件的过程。<br>26、怎么理解 Redis 事务？<br>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的<br>过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<br>27、Redis 事务相关的命令有哪几个？<br>MULTI、EXEC、DISCARD、WATCH<br>28、Redis key 的过期时间和永久有效分别怎么设置？<br>EXPIRE 和 PERSIST 命令。<br>29、Redis 如何做内存优化？<br>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，<br>所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个<br>用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户<br>的所有信息存储到一张散列表里面. 30、Redis 回收进程如何工作的？<br>一个客户端运行了新的命令，添加了新的数据。<br>Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。<br>一个新的命令被执行，等等。<br>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。<br>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不<br>用多久内存限制就会被这个内存使用量超越。<br>31、Redis 回收使用的是什么算法？<br>LRU 算法<br>32、Redis 如何做大量数据插入？<br>Redis2.6 开始 Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工<br>作。<br>33、为什么要做 Redis 分区？<br>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你<br>最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提<br>升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。<br>34、你知道有哪些 Redis 分区实现方案？<br>客户端分区就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节<br>点读取。大多数客户端已经实现了客户端分区。<br>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。<br>代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。<br>Redis 和 memcached 的一种代理实现就是 Twemproxy<br>查询路由(Query routing) 的意思是客户端随机地请求任意一个 Redis 实例，然后由 Redis<br>将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不<br>是直接将请求从一个 Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接<br>redirected 到正确的 Redis 节点。<br>35、Redis 分区有什么缺点？<br>涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存<br>储到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。<br>同时操作多个 key,则不能使用 Redis 事务. 分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning<br>granularity is the key, so it is not possible to shard a dataset with a single huge<br>key like a very big sorted set）. 当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的 Redis 实例和主<br>机同时收集 RDB / AOF 文件。<br>分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除 Redis 节点，能<br>做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持<br>这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。<br>36、Redis 持久化数据和缓存怎么做扩容？<br>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。<br>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的<br>数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运<br>行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。<br>37、分布式 Redis 是前期做还是后期规模上来了再做好？为<br>什么？<br>既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是<br>一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的<br>方式运行，使用分区，在同一台服务器上启动多个实例。<br>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来<br>可能比较麻烦，但是从长久来看做这点牺牲是值得的。<br>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis<br>实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了<br>另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。<br>38、Twemproxy 是什么？<br>Twemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的 ASCII 协议和 Redis<br>协议。它是单线程程序，使用 c 语言编写，运行起来非常快。它是采用 Apache 2.0 license<br>的开源软件。<br>Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动将该节点<br>排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存时使<br>用 Twemproxy)。<br>Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实例，然后让你的客<br>户端去连接任意一个 Twemproxy 实例。<br>Twemproxy 是 Redis 客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，<br>并且应该算比较可靠的。<br>39、支持一致性哈希的客户端有哪些？<br>Redis-rb、PRedis 等。<br>40、Redis 与其他 key-value 存储有什么不同？<br>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库<br>的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外<br>的抽象。<br>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡<br>内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上<br>相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性<br>很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需<br>要进行随机访问。<br>41、Redis 的内存占用情况怎么样？<br>给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的<br>32 位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB， 这是<br>因为键值有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis<br>的开销要小一点点，因为 Redis 会记录类型信息引用计数等等。<br>当然，大键值对时两者的比例要好很多。<br>64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为 64 位的系<br>统里指针占用了 8 个字节。 但是，当然，64 位系统支持更大的内存，所以为了运行大型<br>的 Redis 服务器或多或少的需要使用 64 位的系统。<br>42、都有哪些办法可以降低 Redis 的内存使用情况呢？<br>如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，<br>因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。<br>43、查看 Redis 使用情况及状态信息用什么命令？<br>info<br>44、Redis 的内存用完了会发生什么？<br>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或<br>者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。<br>45、Redis 是单线程的，如何提高多核 CPU 的利用率？<br>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时<br>候，无论如何一个服务器是不够的，<br>所以，如果你想使用多个 CPU，你可以考虑一下分片（shard）。<br>46、一个 Redis 实例最多能存放多少的 keys？List、Set、<br>Sorted Set 他们最多能存放多少元素？<br>理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2<br>亿 5 千万的 keys。我们正在测试一些较大的值。<br>任何 list、set、和 sorted set 都可以放 232 个元素。<br>换句话说，Redis 的存储极限是系统中的可用内存值。<br>47、Redis 常见性能问题和解决方案？<br>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件<br>(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2<br>&lt;- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可<br>以立刻启用 Slave1 做 Master，其他不变。<br>48、Redis 提供了哪几种持久化方式？<br>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储. AOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来<br>恢复原始的数据,AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾.Redis 还能对<br>AOF 文件进行后台重写,使得 AOF 文件的体积不至于过大. 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式. 你也可以同时开启两种持久化方式, 在这种情况下, 当 Redis 重启的时候会优先载入 AOF<br>文件来恢复原始的数据,因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数<br>据集要完整. 最重要的事情是了解 RDB 和 AOF 持久化方式的不同,让我们以 RDB 持久化方式开始。<br>49、如何选择合适的持久化方式？<br>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久<br>化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以<br>只使用 RDB 持久化。<br>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照<br>（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复<br>的速度要快，除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug。<br>50、修改配置不重启 Redis 会实时生效吗？<br>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何<br>形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式<br>而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。<br>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前<br>CONFIG 命令还不支持的配置参数的时候。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"># 缓存</a> <a href="/tags/redis/" rel="tag"># redis</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/b9efb3c36627.html" rel="prev" title="Dubbo"><i class="fa fa-angle-left"></i> Dubbo</a></div><div class="post-nav-item"><a href="/publishes/4d12791836df.html" rel="next" title="Spring boot">Spring boot <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>