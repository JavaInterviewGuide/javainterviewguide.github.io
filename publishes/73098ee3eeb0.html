<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="Collection和Collections的区别 Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。 Java中还有一个Collections类，专门用来操作集合类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。  集合和数组的比较（为什么引入集合） 数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数"><meta property="og:type" content="article"><meta property="og:title" content="集合"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/73098ee3eeb0.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="Collection和Collections的区别 Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。 Java中还有一个Collections类，专门用来操作集合类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。  集合和数组的比较（为什么引入集合） 数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-30T06:39:17.000Z"><meta property="article:modified_time" content="2024-01-04T09:09:38.387Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="集合"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/73098ee3eeb0.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/73098ee3eeb0.html","path":"publishes/73098ee3eeb0.html","title":"集合"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>集合 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection%E5%92%8CCollections%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">Collection和Collections的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E9%9B%86%E5%90%88%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">集合和数组的比较（为什么引入集合）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TreeSet%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">TreeSet的原理和使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashSet%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">HashSet的使用和原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">5.</span> <span class="nav-text">ArrayList和LinkedList的区别和联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">6.</span> <span class="nav-text">HashMap和Hashtable的区别和联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vector%E5%92%8CArrayList%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">7.</span> <span class="nav-text">Vector和ArrayList的区别和联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">8.</span> <span class="nav-text">Java集合体系结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TreeMap%E5%92%8CTreeSet%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%97%B6%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9FCollections%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E7%9A%84sort-%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#List%E3%80%81Map%E3%80%81Set-%E4%B8%89%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">List、Map、Set 三个接口，存取元素时，各有什么特点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E5%87%BAArrayList%E3%80%81Vector%E3%80%81LinkedList-%E7%9A%84%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">说出ArrayList、Vector、LinkedList 的存储性能和特性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#List%E3%80%81Set%E3%80%81Map-%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E8%87%AA-Collection-%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">List、Set、Map 是否继承自 Collection 接口？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TreeMap-%E5%92%8C-TreeSet-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%97%B6%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9FCollections%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E7%9A%84-sort%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Set%E9%87%8C%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%86%E9%87%8D%E5%A4%8D%E4%B8%8E%E5%90%A6%E5%91%A2-%E6%98%AF%E7%94%A8-%E8%BF%98%E6%98%AFequals-%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#List-%E5%92%8C-Map-%E5%8C%BA%E5%88%AB"><span class="nav-number">15.</span> <span class="nav-text">List 和 Map 区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-java-%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%9A%84%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">你是怎么理解 java 的泛型的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Iterator-%E5%92%8C-ListIterator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">Iterator 和 ListIterator 有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">什么是迭代器？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9B%86%E5%90%88%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0-Cloneable-%E5%92%8C-Serializable-%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">为什么集合类没有实现 Cloneable 和 Serializable 接口？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E9%9B%86%E5%90%88%E7%B1%BB%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">Java 集合类框架的基本接口有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ArrayList-%E6%98%AF%E5%90%A6%E4%BC%9A%E8%B6%8A%E7%95%8C%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">ArrayList 是否会越界？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-Array-%E5%92%8C%E5%88%97%E8%A1%A8-ArrayList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-Array-%E8%80%8C%E4%B8%8D%E6%98%AF-ArrayList%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map%E3%80%81Set%E3%80%81List%E3%80%81Queue%E3%80%81Stack%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E7%94%A8%E6%B3%95%E3%80%82"><span class="nav-number">23.</span> <span class="nav-text">Map、Set、List、Queue、Stack的特点与用法。</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/73098ee3eeb0.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="集合 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">集合</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-30 14:39:17" itemprop="dateCreated datePublished" datetime="2023-12-30T14:39:17+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 17:09:38" itemprop="dateModified" datetime="2024-01-04T17:09:38+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h1><ul><li>Collection是Java提供的集合接口，存储一组不唯一，无序的对象。它有两个子接口List和Set。</li><li>Java中还有一个Collections类，专门用来操作集合类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li></ul><h1 id="集合和数组的比较（为什么引入集合）"><a href="#集合和数组的比较（为什么引入集合）" class="headerlink" title="集合和数组的比较（为什么引入集合）"></a>集合和数组的比较（为什么引入集合）</h1><ul><li>数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框架类可适用于不同场合</li><li>具体如下：<ul><li>数组的效率高于集合类.</li><li>数组能存放基本数据类型和对象，而集合类中只能放对象。</li><li>数组容量固定且无法动态改变，集合类容量动态改变。</li><li>数组无法判断其中实际存有多少元素，length只告诉了array的容量。</li><li>集合有多种实现方式和不同的适用场合，而不像数组仅采用顺序表方式。</li><li>集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。</li></ul></li></ul><h1 id="TreeSet的原理和使用"><a href="#TreeSet的原理和使用" class="headerlink" title="TreeSet的原理和使用"></a>TreeSet的原理和使用</h1><ul><li>TreeSet集合，元素不允许重复且有序(自然顺序)</li><li>TreeSet采用树结构存储数据，存入元素时需要和树中元素进行对比，需要指定比较策略。</li><li>可以通过Comparable(外部比较器)和Comparator(内部比较器)来指定比较策略，实现了Comparable的系统类可以顺利存入TreeSet。自定义类可以实现Comparable接口来指定比较策略。</li><li>可创建Comparator接口实现类来指定比较策略，并通过TreeSet构造方法参数传入。这种方式尤其对系统类非常适用。</li></ul><h1 id="HashSet的使用和原理"><a href="#HashSet的使用和原理" class="headerlink" title="HashSet的使用和原理"></a>HashSet的使用和原理</h1><ul><li>哈希表的查询速度特别快，时间复杂度为O（1）。</li><li>HashMap、Hashtable、HashSet这些集合采用的是哈希表结构，需要用到hashCode哈希码，hashCode是一个整数值。</li><li>系统类已经覆盖了hashCode方法 自定义类如果要放入hash类集合，必须重写hashcode。如果不重写，调用的是Object的hashcode，而Object的hashCode实际上是地址。</li><li>向哈希表中添加数据的原理：当向集合Set中增加对象时，首先集合计算要增加对象的hashCode码，根据该值来得到一个位置用来存放当前对象，如在该位置没有一个对象存在的话，那么集合Set认为该对象在集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接着将准备增加到集合中的对象与该位置上的对象进行equals方法比较，如果该equals方法返回false,那么集合认为集合中不存在该对象，在进行一次散列，将该对象放到散列后计算出的新地址里。如果equals方法返回true，那么集合认为集合中已经存在该对象了，不会再将该对象增加到集合中了。</li><li>在哈希表中判断两个元素是否重复要使用到hashCode()和equals()。hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。</li><li>Y&#x3D;K(X) ：K是函数，X是哈希码，Y是地址</li></ul><h1 id="ArrayList和LinkedList的区别和联系"><a href="#ArrayList和LinkedList的区别和联系" class="headerlink" title="ArrayList和LinkedList的区别和联系"></a>ArrayList和LinkedList的区别和联系</h1><ul><li>相同点：两者都实现了List接口，都具有List中元素有序、不唯一的特点。</li><li>不同点：ArrayList实现了长度可变的数组，在内存中分配连续空间。遍历元素和随机访问元素的效率比较高；LinkedList采用链表存储方式。插入、删除元素时效率比较高</li></ul><h1 id="HashMap和Hashtable的区别和联系"><a href="#HashMap和Hashtable的区别和联系" class="headerlink" title="HashMap和Hashtable的区别和联系"></a>HashMap和Hashtable的区别和联系</h1><ul><li>相同点：实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用</li><li>不同点：<ul><li>Hashtable是早期提供的接口，HashMap是新版JDK提供的接口</li><li>Hashtable继承Dictionary类，HashMap实现Map接口</li><li>Hashtable线程安全，HashMap线程非安全</li><li>Hashtable不允许null值，HashMap允许null值</li></ul></li></ul><h1 id="Vector和ArrayList的区别和联系"><a href="#Vector和ArrayList的区别和联系" class="headerlink" title="Vector和ArrayList的区别和联系"></a>Vector和ArrayList的区别和联系</h1><ul><li>相同点：<ul><li>实现原理相同—底层都使用数组</li><li>功能相同—实现增删改查等操作的方法相似</li><li>都是长度可变的数组结构，很多情况下可以互用</li></ul></li><li>不同点：<ul><li>Vector是早期JDK接口，ArrayList是替代Vector的新接口</li><li>Vector线程安全，ArrayList重速度轻安全，线程非安全</li><li>长度需增长时，Vector默认增长一倍，ArrayList增长50%</li></ul></li></ul><h1 id="Java集合体系结构"><a href="#Java集合体系结构" class="headerlink" title="Java集合体系结构"></a>Java集合体系结构</h1><ul><li>Collection 接口存储一组不唯一，无序的对象</li><li>List 接口存储一组不唯一，有序（插入顺序）的对象</li><li>Set 接口存储一组唯一，无序的对象</li><li>Map接口存储一组键值对象，提供key到value的映射。Key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）</li></ul><h1 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h1><ul><li>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。</li><li>TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。</li><li>Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul><h1 id="List、Map、Set-三个接口，存取元素时，各有什么特点？"><a href="#List、Map、Set-三个接口，存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set 三个接口，存取元素时，各有什么特点？"></a>List、Map、Set 三个接口，存取元素时，各有什么特点？</h1><ul><li>List以特定索引来存取元素，可有重复元素。</li><li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）</li><li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一</li><li>Set和Map容器都有基于哈希存储和排序树（红黑树）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</li></ul><p> </p><h1 id="说出ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#说出ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="说出ArrayList、Vector、LinkedList 的存储性能和特性？"></a>说出ArrayList、Vector、LinkedList 的存储性能和特性？</h1><ul><li>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。</li><li>遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖）。同理，Stack类继承Vector也是不正确的。</li></ul><p> </p><h1 id="List、Set、Map-是否继承自-Collection-接口？"><a href="#List、Set、Map-是否继承自-Collection-接口？" class="headerlink" title="List、Set、Map 是否继承自 Collection 接口？"></a>List、Set、Map 是否继承自 Collection 接口？</h1><ul><li>List、Set 的父接口是 Collection，Map 不是其子接口，而是与Collection 接口是平行关系，互不包含。</li><li>Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</li></ul><h1 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的-sort（）方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的-sort（）方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的 sort（）方法如何比较元素？</h1><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会 回调该方法比较元素的大小</li><li>TreeMap 要求存放的键值对映射的键必须实现 Comparable接口从而根据键对元素进行排序</li><li>Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。</li></ul><h1 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?</h1><ul><li>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。</li><li>equals()和&#x3D;&#x3D;方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值</li></ul><h1 id="List-和-Map-区别"><a href="#List-和-Map-区别" class="headerlink" title="List 和 Map 区别?"></a>List 和 Map 区别?</h1><ul><li>一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复</li><li>Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</li></ul><h1 id="你是怎么理解-java-的泛型的？"><a href="#你是怎么理解-java-的泛型的？" class="headerlink" title="你是怎么理解 java 的泛型的？"></a>你是怎么理解 java 的泛型的？</h1><ul><li>在 Java SE 1.5 之前，没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</li><li>泛型是 Java SE 1.5 的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</li></ul><h1 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h1><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h1 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h1><ul><li>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接口,每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合的元素进行迭代操作. 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除.</li></ul><h1 id="为什么集合类没有实现-Cloneable-和-Serializable-接口？"><a href="#为什么集合类没有实现-Cloneable-和-Serializable-接口？" class="headerlink" title="为什么集合类没有实现 Cloneable 和 Serializable 接口？"></a>为什么集合类没有实现 Cloneable 和 Serializable 接口？</h1><ul><li>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</li><li>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。</li><li>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化</li></ul><h1 id="Java-集合类框架的基本接口有哪些？"><a href="#Java-集合类框架的基本接口有哪些？" class="headerlink" title="Java 集合类框架的基本接口有哪些？"></a>Java 集合类框架的基本接口有哪些？</h1><ul><li>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</li><li>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基本的接口有：<ul><li>Collection：代表一组对象，每一个对象都是它的子元素。</li><li>Set：不包含重复元素的 Collection。</li><li>List：有顺序的 collection，并且可以包含重复元素。</li><li>Map：可以把键(key)映射到值(value)的对象，键不能重复。</li></ul></li></ul><h1 id="ArrayList-是否会越界？"><a href="#ArrayList-是否会越界？" class="headerlink" title="ArrayList 是否会越界？"></a>ArrayList 是否会越界？</h1><ul><li>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构</li><li>对于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList并发 add()可能出现数组下标越界异常</li></ul><h1 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？"><a href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？"></a>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</h1><ul><li>Array 和 ArrayList 的不同点：<ul><li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li><li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li><li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li><li>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li></ul></li></ul><h1 id="Map、Set、List、Queue、Stack的特点与用法。"><a href="#Map、Set、List、Queue、Stack的特点与用法。" class="headerlink" title="Map、Set、List、Queue、Stack的特点与用法。"></a>Map、Set、List、Queue、Stack的特点与用法。</h1><ul><li>Map map集合，k-v键值对存储</li><li>HashTable 和 HashMap 是 Map 的实现类   </li><li>HashTable 是线程安全的，不能存储 null 值   </li><li>HashMap 不是线程安全的，可以存储 null 值  </li><li>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。</li><li>Set 集合，无序，不重复</li><li>List 数组集合，ArrayList ， Vector ， LinkedList 是 List 的实现类</li><li>ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的</li><li>LinkedList 是线程不安全的，底层是由链表实现的   </li><li>Queue 队列，提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。</li><li>Stack 栈，继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E9%9B%86%E5%90%88/" rel="tag"><i class="fa fa-tag"></i> 集合</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/3aaab7406978.html" rel="prev" title="IO"><i class="fa fa-angle-left"></i> IO</a></div><div class="post-nav-item"><a href="/publishes/fec4be92fa21.html" rel="next" title="架构">架构 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">450k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:49</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>