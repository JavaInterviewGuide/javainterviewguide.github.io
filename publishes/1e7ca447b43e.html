<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="高并发原则 ⽆状态 ⽆状态应⽤，便于⽔平扩展 有状态配置可通过配置中⼼实现⽆状态 实践: Disconf、Yaconf、Zookpeer、Consul、Confd、Diamond、Xdiamond等   拆分 系统维度：按照系统功能、业务拆分，如购物⻋，结算，订单等 功能维度：对系统功能在做细粒度拆分 读写维度：根据读写⽐例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表 AOP维度： 根据访"><meta property="og:type" content="article"><meta property="og:title" content="分布式"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/1e7ca447b43e.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="高并发原则 ⽆状态 ⽆状态应⽤，便于⽔平扩展 有状态配置可通过配置中⼼实现⽆状态 实践: Disconf、Yaconf、Zookpeer、Consul、Confd、Diamond、Xdiamond等   拆分 系统维度：按照系统功能、业务拆分，如购物⻋，结算，订单等 功能维度：对系统功能在做细粒度拆分 读写维度：根据读写⽐例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表 AOP维度： 根据访"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T07:04:09.000Z"><meta property="article:modified_time" content="2024-01-05T11:39:03.311Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="分布式"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/1e7ca447b43e.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/1e7ca447b43e.html","path":"publishes/1e7ca447b43e.html","title":"分布式"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>分布式 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%88%99"><span class="nav-number">1.</span> <span class="nav-text">高并发原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%BE%BC%E5%8F%AF%E2%BD%A4%E5%8E%9F%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">⾼可⽤原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%8D%E7%BA%A7"><span class="nav-number">2.1.</span> <span class="nav-text">降级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E6%B5%81"><span class="nav-number">2.2.</span> <span class="nav-text">限流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E6%B5%81%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">切流量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%9B%9E%E6%BB%9A"><span class="nav-number">2.4.</span> <span class="nav-text">可回滚</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">3.</span> <span class="nav-text">业务设计原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">分布式与集群的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.</span> <span class="nav-text">分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%BC%86%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">5.1.</span> <span class="nav-text">⼆阶段提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">5.2.</span> <span class="nav-text">三阶段提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.3.</span> <span class="nav-text">柔性事务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E2%BC%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E2%BD%85%E6%A1%88%E4%B9%8BRabbitMQ%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">消息最终⼀致性解决⽅案之RabbitMQ实现：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E2%BD%A4%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">什么时候⽤到分布式开发：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">7.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">7.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cdn%EF%BC%88%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">cdn（异地多活）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB"><span class="nav-number">8.1.</span> <span class="nav-text">异地多活</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%9F%8E%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB"><span class="nav-number">8.2.</span> <span class="nav-text">多城异地多活</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%95%E6%9C%BA%E7%9A%84%E5%A4%84%E7%90%86%E2%BD%85%E6%A1%88"><span class="nav-number">9.</span> <span class="nav-text">分布式环境下宕机的处理⽅案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">分布式、高并发、多线程，到底有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">10.1.</span> <span class="nav-text">什么是分布式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">10.2.</span> <span class="nav-text">什么是高并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">10.3.</span> <span class="nav-text">什么是多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">10.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%AF%94%E5%A6%82%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E6%89%A3%E6%AC%BE%EF%BC%89%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">分布式服务接口的幂等性如何设计（比如不能重复扣款）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BD%A0%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">分布式事务了解吗？你们是如何解决分布式事务问题的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%96%B9%E6%A1%88-XA%E6%96%B9%E6%A1%88"><span class="nav-number">12.1.</span> <span class="nav-text">两阶段提交方案&#x2F;XA方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCC-%E6%96%B9%E6%A1%88"><span class="nav-number">12.2.</span> <span class="nav-text">TCC 方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="nav-number">12.3.</span> <span class="nav-text">本地消息表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88"><span class="nav-number">12.4.</span> <span class="nav-text">可靠消息最终一致性方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88"><span class="nav-number">12.5.</span> <span class="nav-text">最大努力通知方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%EF%BC%9F"><span class="nav-number">12.6.</span> <span class="nav-text">你们公司是如何处理分布式事务的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%AD%A5%E5%BC%8F%E9%94%81"><span class="nav-number">13.</span> <span class="nav-text">分步式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9A"><span class="nav-number">13.1.</span> <span class="nav-text">三种分布式锁：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper"><span class="nav-number">13.1.1.</span> <span class="nav-text">Zookeeper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memcached"><span class="nav-number">13.1.2.</span> <span class="nav-text">memcached</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis"><span class="nav-number">13.1.3.</span> <span class="nav-text">redis</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E8%BF%98%E4%BA%86%E8%A7%A3%E5%88%AB%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%90%97%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">你还了解别的分布式框架吗？</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="mailto:bluespacecapt@gmail.com" title="E-Mail → mailto:bluespacecapt@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/1e7ca447b43e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="分布式 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">分布式</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 15:04:09" itemprop="dateCreated datePublished" datetime="2023-12-20T15:04:09+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-05 19:39:03" itemprop="dateModified" datetime="2024-01-05T19:39:03+08:00">2024-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="高并发原则"><a href="#高并发原则" class="headerlink" title="高并发原则"></a>高并发原则</h1><ul><li>⽆状态<ul><li>⽆状态应⽤，便于⽔平扩展</li><li>有状态配置可通过配置中⼼实现⽆状态</li><li>实践: Disconf、Yaconf、Zookpeer、Consul、Confd、Diamond、Xdiamond等</li></ul></li><li>拆分<ul><li>系统维度：按照系统功能、业务拆分，如购物⻋，结算，订单等</li><li>功能维度：对系统功能在做细粒度拆分</li><li>读写维度：根据读写⽐例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表</li><li>AOP维度： 根据访问特征，按照AOP进⾏拆分，⽐如商品⻚可分为CDN、⻚⾯渲染系统，CDN就是⼀个AOP系统</li><li>模块维度：对整体代码结构划分Web、Service、DAO</li></ul></li><li>服务化<ul><li>服务化演进: 进程内服务-单机远程服务-集群⼿动注册服务-⾃动注册和发现服务-服务的分组、隔离、路由-服务治理</li><li>考虑服务分组、隔离、限流、⿊⽩名单、超时、重试机制、路由、故障补偿等</li><li>实践：利⽤Nginx、HaProxy、LVS等实现负载均衡，ZooKeeper、Consul等实现⾃动注册和发现服</li></ul></li><li>消息队列<ul><li>⽬的: 服务解耦(⼀对多消费)、异步处理、流量削峰缓冲等</li><li>⼤流量缓冲： 牺牲强⼀致性，保证最终⼀致性(案例：库存扣减，现在Redis中做扣减，记录扣减⽇志，通过后台进程将扣减⽇志应⽤到DB)</li><li>数据校对: 解决异步消息机制下消息丢失问题</li></ul></li><li>数据异构<ul><li>数据异构: 通过消息队列机制接收数据变更，原⼦化存储</li><li>数据闭环: 屏蔽多从数据来源，将数据异构存储，形成闭环</li></ul></li><li>缓存银弹<ul><li>⽤户层:<ul><li>DNS缓存</li><li>浏览器DNS缓存</li><li>操作系统DNS缓存</li><li>本地DNS服务商缓存</li><li>DNS服务器缓存</li><li>客户端缓存<ul><li>浏览器缓存(Expires、Cache-Control、Last-Modified、Etag)* App</li><li>客户缓存(js&#x2F;css&#x2F;image…)</li></ul></li></ul></li><li>代理层：<ul><li>CDN缓存(⼀般基于ATS、Varnish、Nginx、Squid等构建,边缘节点-⼆级节点-中⼼节点-源站)</li></ul></li><li>接⼊层：<ul><li>Nginx为例：<ul><li>Proxy_cache： 代理缓存,可以存储到&#x2F;dev&#x2F;shm或者SSD</li><li>FastCGI Cache</li><li>Nginx+Lua+Redis: 业务数据缓存</li></ul></li><li>PHP为例：<ul><li>Opcache： 缓存PHP的Opcodes</li></ul></li></ul></li><li>应⽤层：<ul><li>⻚⾯静态化</li><li>业务数据缓存(Redis&#x2F;Memcached&#x2F;本地⽂件等)</li><li>消息队列</li></ul></li><li>数据层：<ul><li>NoSQL： Redis、Memcache、SSDB等</li><li>MySQL： Innodb&#x2F;MyISAM等Query Cache、Key Cache、Innodb</li><li>Buffer Size等</li></ul></li><li>系统层：<ul><li>CPU : L1&#x2F;L2&#x2F;L3 Cache&#x2F;NUMA</li><li>内存</li><li>磁盘：磁盘本身缓存、dirty_ratio&#x2F;dirty_background_ratio、阵列卡本身缓存</li><li>并发化</li></ul></li></ul></li></ul><h1 id="⾼可⽤原则"><a href="#⾼可⽤原则" class="headerlink" title="⾼可⽤原则"></a>⾼可⽤原则</h1><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><ul><li>降级开关集中化管理：将开关配置信息推送到各个应⽤</li><li>可降级的多级读服务：如服务调⽤降级为只读本地缓存</li><li>开关前置化：如Nginx+lua(OpenResty)配置降级策略，引流流量；可基于此做灰度策略</li><li>业务降级：⾼并发下，保证核⼼功能，次要功能可由同步改为异步策略或屏蔽功能</li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><ul><li>⽬的: 防⽌恶意请求攻击或超出系统峰值</li><li>实践：<ul><li>恶意请求流量只访问到Cache</li><li>穿透后端应⽤的流量使⽤Nginx的limit处理</li><li>恶意IP使⽤Nginx Deny策略或者iptables拒绝</li></ul></li></ul><h2 id="切流量"><a href="#切流量" class="headerlink" title="切流量"></a>切流量</h2><ul><li>⽬的：屏蔽故障机器</li><li>实践:<ul><li>DNS: 更改域名解析⼊⼝，如DNSPOD可以添加备⽤IP，正常IP故障时，会⾃主切换到备⽤地址;⽣效实践较慢</li><li>HttpDNS: 为了绕过运营商LocalDNS实现的精准流量调度</li><li>LVS&#x2F;HaProxy&#x2F;Nginx: 摘除故障节点</li></ul></li></ul><h2 id="可回滚"><a href="#可回滚" class="headerlink" title="可回滚"></a>可回滚</h2><ul><li>发布版本失败时可随时快速回退到上⼀个稳定版本</li></ul><h1 id="业务设计原则"><a href="#业务设计原则" class="headerlink" title="业务设计原则"></a>业务设计原则</h1><ul><li>防重设计</li><li>幂等设计</li><li>流程定义</li><li>状态与状态机</li><li>后台系统操作可反馈</li><li>后台系统审批化</li><li>⽂档注释</li><li>备份</li></ul><h1 id="分布式与集群的区别"><a href="#分布式与集群的区别" class="headerlink" title="分布式与集群的区别"></a>分布式与集群的区别</h1><ul><li>分布式是指将不同的业务分布在不同的地⽅</li><li>⽽集群指的是将⼏台服务器集中在⼀起，实现同⼀业务</li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="⼆阶段提交"><a href="#⼆阶段提交" class="headerlink" title="⼆阶段提交"></a>⼆阶段提交</h2><ul><li>概念：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中⽌操作。</li><li>作⽤：主要保证了分布式事务的原⼦性；第⼀阶段为准备阶段，第⼆阶段为提交阶段；</li><li>缺点：不仅要锁住参与者的所有资源，⽽且要锁住协调者资源，开销⼤。⼀句话总结就是：2PC效率很低，对⾼并发很不友好。</li></ul><h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><ul><li>概念：三阶段提交协议在协调者和参与者中都引⼊超时机制，并且把两阶段提交协议的第⼀个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</li><li>缺点：如果进⼊PreCommit后，Coordinator发出的是abort请求，假设只有⼀个Cohort收到并进⾏了abort操作，⽽其他对于系统状态未知的Cohort会根据3PC选择继续Commit，此时系统状态发⽣不⼀致性。</li></ul><h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><ul><li>概念：所谓柔性事务是相对强制锁表的刚性事务⽽⾔。流程⼊下：服务器A的事务如果执⾏顺利，那么事务A就先⾏提交，如果事务B也执⾏顺利，则事务B也提交，整个事务就算完成。但是如果事务B执⾏失败，事务B本身回滚，这时事务A已经被提交，所以需要执⾏⼀个补偿操作，将已经提交的事务A执⾏的操作作反操作，恢复到未执⾏前事务A的状态。</li><li>缺点：业务侵⼊性太强，还要补偿操作，缺乏普遍性，没法⼤规模推⼴。</li></ul><h1 id="消息最终⼀致性解决⽅案之RabbitMQ实现："><a href="#消息最终⼀致性解决⽅案之RabbitMQ实现：" class="headerlink" title="消息最终⼀致性解决⽅案之RabbitMQ实现："></a>消息最终⼀致性解决⽅案之RabbitMQ实现：</h1><ul><li>实现：发送⽅确认+消息持久化+消费者确认。</li></ul><h1 id="什么时候⽤到分布式开发："><a href="#什么时候⽤到分布式开发：" class="headerlink" title="什么时候⽤到分布式开发："></a>什么时候⽤到分布式开发：</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>模块解耦：把模块拆分,使⽤接⼝通信,降低模块之间的耦合度.</li><li>项⽬拆分，不同团队负责不同的⼦项⽬：把项⽬拆分成若⼲个⼦项⽬,不同的团队负责不同的⼦项⽬.</li><li>提⾼项⽬扩展性：增加功能时只需要再增加⼀个⼦项⽬,调⽤其他系统的接⼝就可以。</li><li>分布式部署：可以灵活的进⾏分布式部署.</li><li>提⾼代码的复⽤性：⽐如service层,如果不采⽤分布式rest服务⽅式架构就会在⼿机wap商城,信商城,pc,android，ios每个端都要写⼀个service层逻辑,开发量⼤,难以维护⼀起升级,这时候可以采⽤分布式rest服务⽅式,公⽤⼀个service层。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>系统之间的交互要使⽤远程通信,接⼝开发增⼤⼯作量；</li><li>⽹络请求有延时；</li><li>事务处理⽐较麻烦，需要使⽤分布式事务。</li></ul><h1 id="cdn（异地多活）"><a href="#cdn（异地多活）" class="headerlink" title="cdn（异地多活）"></a>cdn（异地多活）</h1><h2 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h2><ul><li>异地多活指分布在异地的多个站点同时对外提供服务的业务场景。异地多活是⾼可⽤架构设计的⼀种，与传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。</li><li>两地容灾切换⽅案：容灾是异地多活中最核⼼的⼀环， 以两个城市异地多活部署架构图为例，在两个城市（城市1位于华南1地域、城市2位于华东1地域）均部署⼀套完整的业务系统。下单业务按照“user_id”％ 100 进⾏分⽚，在正常情况下：<ul><li>[00~49]分⽚所有的读写都在城市1的数据库实例主库。</li><li>[50～99]分⽚所有的读写都在城市2的数据库实例主库。</li><li>“城市1的数据库实例主库”和 “城市2的数据库实例主库”建⽴DTS双向复制。</li><li>当出现异常时，需要进⾏容灾切换。可能出现的场景有以下4种：<ul><li>将第2种、第3种异常情况，全部采⽤第2种⽅案进⾏处理，那么不管是所有的APP Server异常、所有的数据库异常、整个城市异常，就直接按照城市级容灾⽅案处理，直接将APP Server、数据库切换到到另⼀个城市。</li></ul></li></ul></li></ul><h2 id="多城异地多活"><a href="#多城异地多活" class="headerlink" title="多城异地多活"></a>多城异地多活</h2><ul><li>多城市异地多活模式指的是3个或者3个以上城市间部署异地多活</li><li>该模式下存在中⼼节点和单元节点：<ul><li>中⼼节点：指单元节点的增量数据都需要实时的同步到中⼼节点，同时中⼼节点将所有分⽚的增量数据同步到其他单元节点。</li><li>单元节点：即对应分⽚读写的节点，该节点需要将该分⽚的增量同步到中⼼节点，并且接收来⾃于中⼼节点的其他分⽚的增量数据。</li></ul></li></ul><h1 id="分布式环境下宕机的处理⽅案"><a href="#分布式环境下宕机的处理⽅案" class="headerlink" title="分布式环境下宕机的处理⽅案"></a>分布式环境下宕机的处理⽅案</h1><ul><li>dubbo：服务器宕机，zk临时被删除；</li><li>springcloud：每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。</li><li>apm监控</li></ul><h1 id="分布式、高并发、多线程，到底有什么区别？"><a href="#分布式、高并发、多线程，到底有什么区别？" class="headerlink" title="分布式、高并发、多线程，到底有什么区别？"></a>分布式、高并发、多线程，到底有什么区别？</h1><ul><li>当提起这三个词的时候，是不是很多人都认为分布式&#x3D;高并发&#x3D;多线程？</li><li>在一开始接触的时候，不少人都会将三者混淆，误以为所谓的分布式高并发的系统就是能同时供海量用户访问，而采用多线程手段不就是可以提供系统的并发能力吗</li><li>实际上，他们三个总是相伴而生，但侧重点又有不同</li></ul><h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><ul><li>分布式更多的一个概念，是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段</li><li>该领域需要解决的问题极多，在不同的技术层面上，又包括：分布式文件系统、分布式缓存、分布式数据库、分布式计算等，一些名词如Hadoop、zookeeper、MQ等都跟分布式有关</li><li>从理念上讲，分布式的实现有两种形式：<ul><li>水平扩展：当一台机器扛不住流量时，就通过添加机器的方式，将流量平分到所有服务器上，所有机器都可以提供相当的服务；</li><li>垂直拆分：前端有多种查询需求时，一台机器扛不住，可以将不同的需求分发到不同的机器上，比如A机器处理余票查询的请求，B机器处理支付的请求。</li></ul></li></ul><h2 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h2><ul><li>相对于分布式来讲，高并发在解决的问题上会集中一些，其反应的是同时有多少量：比如在线直播服务，同时有上万人观看</li><li>高并发可以通过分布式技术去解决，将并发流量分不到不同的物理服务器上</li><li>但除此之外，还可以有很多其他优化手段：比如使用缓存系统，将所有的，静态内容放到CDN等；还可以使用多线程技术将一台服务器的服务能力最大化。</li></ul><h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><ul><li>多线程是指从软件或者硬件上实现多个线程并发执行的技术</li><li>它更多的是解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行（实际是交替运行的）</li><li>多线程解决的问题是最明确的，手段也是比较单一的，基本上遇到的最大问题就是线程安全</li><li>在JAVA语言中，需要对JVM内存模型、指令重排等深入了解，才能写出一份高质量的多线程代码。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>分布式是从物理资源的角度去将不同的机器组成一个整体对外服务，技术范围非常广且难度非常大，有了这个基础，高并发、高吞吐等系统很容易构建；</li><li>高并发是从业务角度去描述系统的能力，实现高并发的手段可以采用分布式，也可以采用诸如缓存、CDN等，当然也包括多线程；</li><li>多线程则聚焦于如何使用编程语言将CPU调度能力最大化</li></ul><h1 id="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"><a href="#分布式服务接口的幂等性如何设计（比如不能重复扣款）？" class="headerlink" title="分布式服务接口的幂等性如何设计（比如不能重复扣款）？"></a>分布式服务接口的幂等性如何设计（比如不能重复扣款）？</h1><ul><li>这个不是技术问题，这个没有通用的一个方法，这个应该结合业务来保证幂等性。</li><li>所谓幂等性，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</li><li>其实保证幂等性主要是三点：<ul><li>对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单id，一个订单 id 最多支付一次。</li><li>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql中记录个状态，比如支付之前记录一条这个订单的支付流水。</li><li>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。</li></ul></li><li>实际运作过程中，你要结合自己的业务来，比如说利用 redis，用 orderId作为唯一键</li><li>只有成功插入这个支付流水，才可以执行实际的支付扣款。</li><li>要求是支付一个订单，必须插入一条支付流水，<code>order_id</code> 建一个唯一键unique key。你在支付一个订单之前，先插入一条支付流水，<code>order_id</code>就已经进去了。你就可以写一个标识到 redis 里面去，<code>set order_id payed</code>，下一次重复请求过来了，先查 redis 的 order_id 对应的 value，如果是payed就说明已经支付过了，你就别重复支付了。</li></ul><h1 id="分布式事务了解吗？你们是如何解决分布式事务问题的？"><a href="#分布式事务了解吗？你们是如何解决分布式事务问题的？" class="headerlink" title="分布式事务了解吗？你们是如何解决分布式事务问题的？"></a>分布式事务了解吗？你们是如何解决分布式事务问题的？</h1><ul><li>分布式事务的实现主要有以下 5 种方案：</li><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h2 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案&#x2F;XA方案"></a>两阶段提交方案&#x2F;XA方案</h2><ul><li>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</li><li>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。</li><li>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</li><li>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</li><li>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</li><li>distributed-transacion-XA</li></ul><h2 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h2><ul><li>TCC 的全称是：Try、Confirm、Cancel。<ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。</li><li>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul></li><li>这种方案说实话几乎很少人使用，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大。</li><li>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</li><li>而且最好是你的各个业务执行的时间都比较短。</li><li>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</li><li>distributed-transacion-TCC</li></ul><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><ul><li>本地消息表其实是国外的 ebay 搞出来的这么一套思想。这个大概意思是这样的：<ul><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B那边成功为止。</li></ul></li><li>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</li><li>distributed-transaction-local-message-table</li></ul><h2 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h2><ul><li>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ就支持消息事务。大概的意思就是：<ul><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li></ul></li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用RocketMQ支持的，要不你就自己基于类似ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li><li>distributed-transaction-reliable-message</li></ul><h2 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h2><ul><li>这个方案的大致意思就是：<ul><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ul></li></ul><h2 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h2><ul><li>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性</li><li>然后其他的一些场景基于阿里的 RocketMQ 来实现了分布式事务。</li><li>找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案</li><li>如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</li></ul><h1 id="分步式锁"><a href="#分步式锁" class="headerlink" title="分步式锁"></a>分步式锁</h1><ul><li>基本原理：⽤⼀个状态值表示锁，对锁的占⽤和释放通过状态值来标识。</li></ul><h2 id="三种分布式锁："><a href="#三种分布式锁：" class="headerlink" title="三种分布式锁："></a>三种分布式锁：</h2><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul><li>基于zookeeper瞬时有序节点实现的分布式锁</li><li>⼤致思想即为：每个客户端对某个功能加锁时，在zookeeper上的与该功能对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点</li><li>判断是否获取锁的⽅式很简单，只需要判断有序节点中序号最⼩的⼀个</li><li>当释放锁的时候，只需将这个瞬时节点删除即可</li><li>同时，其可以避免服务宕机导致的锁⽆法释放，⽽产⽣的死锁问题。</li><li>优点<ul><li>锁安全性⾼，zk可持久化，且能实时监听获取锁的客户端状态</li><li>⼀旦客户端宕机，则瞬时节点随之消失，zk因⽽能第⼀时间释放锁</li><li>这也省去了⽤分布式缓存实现锁的过程中需要加⼊超时时间判断的这⼀逻辑。</li></ul></li><li>缺点<ul><li>性能开销⽐较⾼</li><li>因为其需要动态产⽣、销毁瞬时节点来实现锁功能</li><li>所以不太适合直接提供给⾼并发的场景使⽤</li></ul></li><li>实现<ul><li>可以直接采⽤zookeeper第三⽅库curator即可⽅便地实现分布式锁</li></ul></li><li>适⽤场景<ul><li>对可靠性要求⾮常⾼，且并发程度不⾼的场景下使⽤</li><li>如核⼼数据的定时全量&#x2F;增量同步等。</li></ul></li></ul><h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><ul><li>memcached带有add函数，利⽤add函数的特性即可实现分布式锁</li><li>add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。⽽add的话则相反，add会添加第⼀个到达的值，并返回true，后续的添加则都会返回false。利⽤该点即可很轻松地实现分布式锁。</li><li>优点：并发⾼效</li><li>缺点<ul><li>memcached采⽤列⼊LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。</li><li>memcached⽆法持久化，⼀旦重启，将导致信息丢失。</li></ul></li><li>使⽤场景<ul><li>⾼并发场景。需要<ul><li>加上超时时间避免死锁</li><li>提供⾜够⽀撑锁服务的内存空间</li><li>稳定的集群化管理</li></ul></li></ul></li></ul><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul><li>redis分布式锁即可以结合zk分布式锁锁⾼度安全和memcached并发场景下效率很好的优点</li><li>其实现⽅式和memcached类似，采⽤setnx即可实现</li><li>需要注意的是，这⾥的redis也需要设置超时时间，以避免死锁。</li></ul><h1 id="你还了解别的分布式框架吗？"><a href="#你还了解别的分布式框架吗？" class="headerlink" title="你还了解别的分布式框架吗？"></a>你还了解别的分布式框架吗？</h1><ul><li>别的还有 spring 的 spring cloud，facebook 的 thrift，twitter 的 finagle 等</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 分布式</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/52555cb3db5d.html" rel="prev" title="Docker"><i class="fa fa-angle-left"></i> Docker</a></div><div class="post-nav-item"><a href="/publishes/c0d8e27e97f4.html" rel="next" title="多线程">多线程 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">452k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:51</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>