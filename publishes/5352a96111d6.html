<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="说说反射的用途及实现 Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架 Java反射的主要功能： 确定一个对象的类 取出类的modifiers,数据成员,方法,构造器,和超类. 找出某个接口里定义的常量和方法说明. 创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象). 取得和设定"><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="说说反射的用途及实现 Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架 Java反射的主要功能： 确定一个对象的类 取出类的modifiers,数据成员,方法,构造器,和超类. 找出某个接口里定义的常量和方法说明. 创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象). 取得和设定"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T01:28:17.000Z"><meta property="article:modified_time" content="2023-12-30T07:35:42.590Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="java"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/5352a96111d6.html","path":"publishes/5352a96111d6.html","title":"Java基础"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java基础 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">说说反射的用途及实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E5%86%99%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">重载 重写（覆写）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC-%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">JDBC 流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">HashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashSet-%E5%92%8C-HashMap-%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">HashSet 和 HashMap 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">HashMap 和 ConcurrentHashMap 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">Java中创建线程主要有三种方式：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sleep-%E3%80%81join%EF%BC%88%EF%BC%89%E3%80%81yield%EF%BC%88%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">sleep() 、join（）、yield（）有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">java反射的作用与原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9"><span class="nav-number">10.</span> <span class="nav-text">泛型常用特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90XML%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%89%B9%E7%82%B9%EF%BC%9ADOM%E3%80%81SAX"><span class="nav-number">11.</span> <span class="nav-text">解析XML的几种方式的原理与特点：DOM、SAX</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">38</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">29</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">52</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java基础 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java基础</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-30 15:35:42" itemprop="dateModified" datetime="2023-12-30T15:35:42+08:00">2023-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1254k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>19:01</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h1><ul><li>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架</li><li>Java反射的主要功能：<ul><li>确定一个对象的类</li><li>取出类的modifiers,数据成员,方法,构造器,和超类.</li><li>找出某个接口里定义的常量和方法说明.</li><li>创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).</li><li>取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.</li><li>在运行时刻调用动态对象的方法.</li></ul></li></ul><h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul><li>方法名称相同，参数的类型或个数不同</li><li>方法名称、参数类型、返回值类型全部相同</li><li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li><li>范围 发生在一个类中 发生在继承类中</li><li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li><li>反射的应用很多，很多框架都有用到<ul><li>spring 的 ioc&#x2F;di 也是反射…</li><li>javaBean和jsp之间调用也是反射…</li><li>struts的 FormBean 和页面之间…也是通过反射调用…</li><li>JDBC 的 classForName()也是反射…</li><li>hibernate的 find(Class clazz) 也是反射…</li><li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li></ul></li></ul><h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul><li>加载JDBC驱动程序</li><li>提供JDBC连接的URL</li><li>创建数据库的连接</li><li>创建一个Statement</li><li>执行SQL语句</li><li>处理结果</li><li>关闭JDBC对象</li></ul><h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><p>1.hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和<br>containsKey（）方法。<br>2.hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。<br>3.hashMap允许空键值，而hashTable不允许。<br>注意：<br>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状<br>态。<br>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p><h1 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h1><p>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是<br>用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过<br>key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象</p><h1 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h1><p>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上<br>都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更<br>好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>HashMap 的工作原理及代码实现<br>参考：<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，<br>当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时<br>间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，<br>16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一<br>个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来<br>决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步<br>机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只<br>是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个<br>Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此<br>HashTable已经被淘汰了。</p><h1 id="Java中创建线程主要有三种方式："><a href="#Java中创建线程主要有三种方式：" class="headerlink" title="Java中创建线程主要有三种方式："></a>Java中创建线程主要有三种方式：</h1><p>一、继承Thread类创建线程类<br>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完<br>成的任务。因此把run()方法称为执行体。<br>（2）创建Thread子类的实例，即创建了线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。getName()方法返<br>回调用该方法的线程的名字。<br>二、通过Runnable接口创建线程类<br>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是<br>该线程的线程执行体。<br>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该<br>Thread对象才是真正的线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>三、通过Callable和Future创建线程<br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且<br>有返回值。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对<br>象封装了该Callable对象的call()方法的返回值。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><h1 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h1><p>1、sleep()方法<br>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度<br>程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如<br>果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常<br>比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一<br>个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级<br>的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。<br>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的<br>线程有执行的机会。<br>2、yield()方法<br>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方<br>法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态<br>后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也<br>和sleep()方法不同。<br>3、join()方法<br>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，<br>B不能工作。<br>保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有<br>存活，则当前线程不需要停止。<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲<br>突。<br>在Java里，线程安全一般体现在两个方面：<br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关<br>键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有<br>synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，<br>问题就出现了。<br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在<br>java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>volatile 实现原理<br>聊聊并发（一）——深入分析Volatile的实现原理<br>悲观锁 乐观锁<br>乐观锁 悲观锁<br>是一种思想。可以用在很多方面。<br>比如数据库方面。<br>悲观锁就是for update（锁定查询的行）<br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读­<br>比较­写的操作。）<br>JDK方面：<br>悲观锁就是sync<br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。<br>乐观锁就认为，基本没人抢。<br>CAS 乐观锁<br>乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出<br>当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重<br>复读­比较­写的操作。<br>CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。<br>CAS顶多算是乐观锁写那一步操作的一种实现方式罢了，不用CAS自己加锁也是可以的。<br>ABA 问题<br>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A，当前线程的CAS<br>操作无法分辨当前V值是否发生过变化。<br>参考：<br>Java CAS 和ABA问题<br>乐观锁的业务场景及实现方式<br>乐观锁（Optimistic Lock）：<br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，<br>但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不<br>进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，<br>期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可<br>能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量<br>的查询操作，降低了系统的吞吐量。<br>核心篇<br>数据存储<br>MySQL 索引使用的注意事项<br>参考：<br>mysql索引使用技巧及注意事项<br>说说反模式设计<br>参考：<br>每个程序员要注意的 9 种反模式<br>说说分库与分表设计<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策<br>说说 SQL 优化之道<br>sql优化的几种方法<br>微服务哪些框架<br>Spring Cloud、Dubbo、Hsf等<br>你怎么理解 RPC 框架<br>RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这<br>个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。<br>说说 RPC 的实现原理<br>参考：<br>你应该知道的 RPC 原理<br>从零开始实现RPC框架 ­ RPC原理及实现</p><p>分布式<br>谈谈业务中使用分布式的场景<br>一、解决java集群的session共享的解决方案：<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>二、分布式事务的解决方案:<br>1.TCC解决方案：try confirm cancel。<br>参考：<br>为什么说传统分布式事务不再适用于微服务架构？<br>Session 分布式方案<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库<br>更多Java技术资料视频分享+QQ2118797017<br>来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>分布式锁的场景<br>比如交易系统的金额修改，同一时间只能又一个人操作，比如秒杀场景，同一时间只能一个<br>用户抢到，比如火车站抢票等等<br>分布式锁的实现方案<br>26. 基于数据库实现分布式锁<br>27. 基于缓存实现分布式锁<br>28. 基于Zookeeper实现分布式锁<br>参考：<br>分布式锁的多种实现方式<br>分布式事务<br>参考：<br>深入理解分布式事务,高并发下分布式事务的解决方案<br>集群与负载均衡的算法与实现<br>参考：<br>负载均衡算法及手段<br>说说分库与分表设计<br>参考：<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>安全&amp;性能<br>安全问题<br>安全要素与 STRIDE 威胁<br>防范常见的 Web 攻击<br>XSS攻击<br>跨站脚本攻击;<br>是什么：攻击者向有XSS漏洞的网站中输入恶意的HTML代码，当其浏览器浏览该网站<br>时，这段HTML代码会自­ ­ 动执行。（理论上所有可以输入的地方没有对输入的数据进<br>行处理，都会存在XSS攻击）;<br>危害： 盗取用户cookie，破坏页面结构，重定向到其他网站;<br>防御：对用户输入的信息进行处理，只允许合法的值;<br>CSRF攻击<br>跨站请求伪造<br>是什么：攻击者盗用了你的身份，以你的名义发送恶意请求;<br>危害：以你的名义发送邮件，盗取帐号，购买东西等;<br>原理： 首先个登录某网站，并在本地生成cookie;然后在不登出的情况下，访问危害网<br>站。<br>防御： 可以从服务端和客户端两方面进行考虑。但是在服务端的效果好。<br>a. 随机的cookie<br>b. 添加验证码<br>c. 不同的表单包含一个不同的伪随机值<br>注意：如果用户在一个站点上同时打开了两个不同的表单。CSRF保护措施不应该影响<br>到他对任何表单的提交<br>SQL注入<br>是什么：通过sql命令伪装成正常的http请求参数，传递到服务端，服务器执行sql命令<br>造成对数据库进行攻击<br>原理：sql语句伪造参数，然后在对参数机型拼接后形成破坏性的sql语句，最后导致数<br>据库收到攻击<br>防御：<br>a. 对参数进行转义<br>b. 数据库中的密码不应明文存储，可以对密码使用md5进行加密。<br>DDOS攻击（分布式拒绝服务攻击）<br>是什么：简单来说就是ifasong大量的请求使服务器瘫痪。<br>被攻击的原因：服务器带宽不足，不能挡住攻击者的攻击流量。<br>防御：<br>a. 最直接的方法就是增加带宽;<br>b. 使用硬件防火墙;<br>c. 优化资源使用提高 web server 的负载能力<br>服务端通信安全攻防<br>HTTPS 原理剖析<br>HTTPS 降级攻击<br>授权与认证<br>基于角色的访问控制<br>基于数据的访问控制<br>基于角色的访问控制，只验证访问数据的角色，但是没有对角色内的用户做细分。举个例<br>子，用户甲与用户乙都具有用一个角色，但是如果只建立基于角色的访问控制，那么用户甲<br>可以对用户乙的数据进行任意操作，从而发生了越权访问。因此，在业务场景中仅仅使用基<br>于角色的访问控制是不够的，还需要引入基于数据的访问控制。如果将基于角色的访问控制<br>视为一种垂直权限控制，那么，基于数据的访问控制就是一种水平权限控制。在业务场景<br>中，往往对基于数据的访问控制不够重视，举个例子，评论功能是一个非常常见的功能，用<br>户可以在客户端发起评论，回复评论，查看评论，删除评论等操作。一般情况下，只有本人<br>才可以删除自己的评论，如果此时，业务层面没有建立数据的访问控制，那么用户甲可以试<br>图绕过客户端，通过调用服务端RESTful API 接口，猜测评论 ID 并修改评论 ID 就可以删除<br>别人的评论。事实上，这是非常严重的越权操作。除此之外，用户之间往往也存在一些私有<br>的数据，而这些私有的数据在正常情况下，只有用户自己才能访问。<br>基于数据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引<br>起重视。这里，再次使用删除评论的案例，通过 Java 语言进行介绍。在这个案例中，核心<br>的代码片段在于，判断当前用户是否是评论的创建者，如果是则通过，不是则报出没有权限<br>的错误码。那么，这样就可以很好地防止数据的越权操作。<br>总结下，基于角色的访问控制是一种垂直权限控制，通过建立用户与角色的对应关系，使得<br>不同角色之间具有高低之分。用户根据拥有的角色进行操作与资源访问。基于数据的访问控<br>制是一种水平权限控制，它对角色内的用户做细分，确保用户的数据不能越权操作。基于数<br>据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引起重<br>视。<br>性能优化<br>性能指标有哪些<br>如何发现性能瓶颈<br>性能调优的常见手段<br>说说你在项目中如何进行性能调优</p><p>1.八种基本数据类型的大小，以及他们的封装类<br>double—Double 8位0.0d<br>float —Float 4位0.0f<br>long —Long8位0L<br>int —Integer 4位0<br>short —Short 2位(short)0<br>byte —byte1位(byte)0<br>char —Character 2位null\u0000<br>boolean —Boolean – false<br>2.引用数据类型<br>数组，类，接口<br>3.Switch能否用string做参数<br>以前只能支持byte、short、char、int，可以强转<br>Jdk7.0以后可以，整型、枚举类型、boolean、字符串都可以<br>4.equals与&#x3D;&#x3D;的区别*<br>&#x3D;&#x3D;比较的是2个对象的地址，而equals比较的是2个对象的内容<br>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。<br>Equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。<br>5.自动装箱，常量池<br>自动装箱：基本数据类型对象类型<br>自动拆箱：对象类型基本数据类型<br>常量池：Byte,Short,Integer,Long,Character在自动装箱时对于值从–128到127之间的值（共享），会存在内存中被重用<br>字符串常量池<br>常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s &#x3D; “java”这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。<br>6.Object有哪些公用方法<br>clone(),hashCode(),equals(),notify(),notifyAll(),wait(),getClass(),toString,finalize()<br>8.Hashcode的作用*<br>利用哈希算法，配合基于散列的集合一起正常运行，Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值，降低equals的调用，实现存放的值不会重复。<br>Note:重写equals必须重写hashcode方法，equals相等，hashcode也必须相等。<br>一般对于存放到Set集合或者Map中键值对的元素，需要按需要重写hashCode与equals方法，以保证唯一性！<br>例如hashset存放多个对象，重写equals和hashcode<br>两个对象相等，其HashCode一定相同;<br>两个对象不相等，其HashCode有可能相同;<br>HashCode相同的两个对象，不一定相等;<br>HashCode不相同的两个对象，一定不相等;<br>9.HashMap的hashcode的作用*<br>Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 equals方法可用于保证元素不重复，但是，如果每增加一个元素就检查一次，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次equals方法。这显然会大大降低效率。<br>HashMap的数据结构是 数组+链表形式存储数据，继承AbstractMap，实现Map接口，主要用于查找的快捷性。<br>10.为什么重载hashCode方法？*<br>一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是object对象，必须重载hashCode和equal方法。<br>11.ArrayList、LinkedList、Vector的区别*<br>ArrayList： 线程不安全，数组，适合查找，可自动扩容50%<br>三个构造器，无参，容量，Collection接口，transient Object[] elementData;不被序列化。<br>LinkedList：线程不安全，链表，审核插入，删除<br>Vector： 线程安全，数组，适合查找，可自动扩容100%<br>12.String、StringBuffer与StringBuilder的区别*<br>String 是final修饰的，字符串常量，String对象一旦创建之后该对象是不可更改的<br>StringBuffer 字符串变量，对象可变，线程安全，适合多线程下字符缓冲区大量操作<br>StringBuider 字符串变量，对象可变，线程不安全，适用单线程下载字符缓冲区进行大量操作的情况，都是继承AbstractStringBuilder super.容量为16<br>13.Map、Set、List、Queue、Stack的特点与用法。<br>Map map集合，k-v键值对存储<br>HashTable 和 HashMap 是 Map 的实现类   <br>HashTable 是线程安全的，不能存储 null 值   <br>HashMap 不是线程安全的，可以存储 null 值  <br>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。<br>Set 集合，无序，不重复<br>List 数组集合，ArrayList ， Vector ， LinkedList 是 List 的实现类<br>ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的<br>LinkedList 是线程不安全的，底层是由链表实现的   <br>Queue 队列，提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。<br>Stack 栈，继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。<br>HashMap和HashTable的区别<br>14.JDK7与JDK8中HashMap的实现*<br>JDK8在JDK7的基础上引入了红黑树-b，因为链表过长，会导致效率很低，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率<br>15.HashMap和ConcurrentHashMap的区别，HashMap的底层源码*<br>HashMap是线程不安全的，ConcurrentHashMap是线程安全的，适用于高并发，ConcurrentHashMap就是一个分段的hashtable，根据自定的hashcode算法生成的对象来获取对应hashcode的分段块进行加锁，不用整体加锁，提高了效率。<br>HashMap的get（key）方法是获取key的hash值，计算hash&amp;（n-1）得到在链表数组中的位置first&#x3D;tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可。<br>HashMap的put（key）方法是判断键值对数组tab[]是否为空或位null，否则以默认大小resize()；根据键值key计算hash值得到插入的数组索引i，如果tab[i]&#x3D;&#x3D;null,直接新建节点添加，否则判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可)，分别处理。<br>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比<em>Node.length）重新调整HashMap大小 变为原来2倍大小,扩容很耗时<br>16.ConcurrentHashMap能完全替代HashTable吗？<br>Hash table虽然性能上不如ConcurrentHashMap，但并不能完全被取代，两者的迭代器的一致性不同的，ConcurrentHashMap由于分段锁，弱一致性主要是为了提升效率。<br>强一致性就如hashtable一样，锁整个map。<br>17.为什么HashMap是线程不安全的</em><br>在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，如图中a1、a2，这个时候需要解决碰撞冲突，而解决冲突的办法上面已经说过，对于链表的结构在这里不再赘述，暂且不讨论是从链表头部插入还是从尾部初入，这个时候两个线程如果恰好都取到了对应位置的头结点e1，而最终的结果可想而知，a1、a2两个数据中势必会有一个会丢失<br>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。<br>18.多并发情况下HashMap是否还会产生死循环*<br>不会，jdk1.8版本以后已经没有这个问题了，没有transfer这个函数了do while可能造成的死循环，对原有造成死锁的关键原因点（新table复制在头端添加元素）改进为依次在末端添加新的元素<br>19.TreeMap、HashMap、LindedHashMap的区别*<br>LinkedHashMap可以保证HashMap集合有序。存入的顺序和取出的顺序一致。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。<br>HashMap不保证顺序，即为无序的，具有很快的访问速度。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步。<br>20.Collection包结构，与Collections的区别<br>Collection是个java.util下的接口，它是各种集合结构的父接口。<br>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<br>21.try?catch?finally，try里有return，finally还执行么<br>如果finally没有return 相同返回值变量，则返回try里面的return，否则finally 的return 值会影响 try里面return结果。<br>finally还是会执行的，除非中途遇到jvm退出。<br>22.Excption与Error包结构，OOM你遇到过哪些情况，SOF你遇到过哪些情况<br>都是Throwable的子类，Exception指出了合理的应用程序想要捕获的条件。Error 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件<br>Java Heap 溢出，虚拟机栈和本地方法栈溢出，运行时常量池溢出，方法区溢出<br>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br>23.Java(OOP)面向对象的三个特征与含义<br>封装：可见性封装，setget读写，将类的某些特征隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。<br>继承：子类继承父类，可以得到父类的全部属性和方法（除了父类中的构造方法），java中的多继承可以通过接口来实现。<br>多态：一种是编译时多态，另外一种是运行时多态，编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。<br>26.Static?class?与non?static?class的区别<br>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。<br>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。<br>27.foreach与正常for循环效率对比<br>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。<br>28.Java?IO与NIO*<br>NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I&#x2F;O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征<br>IO是面向流的，NIO是面向块（缓冲区）的。<br>IO是阻塞的，NIO是非阻塞的。<br>多连接，少数据可以用NIO<br>少连接，大数据可以用IO</p><h1 id="java反射的作用与原理"><a href="#java反射的作用与原理" class="headerlink" title="java反射的作用与原理"></a>java反射的作用与原理</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>在JAVA中，只有给定类的名字，就可以通过反射机制来获取类的所有信息，可以动态的创建对象和编译。<br>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。</p><h1 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h1><p>泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。<br>使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。<br>通过类型擦除来实现</p><h1 id="解析XML的几种方式的原理与特点：DOM、SAX"><a href="#解析XML的几种方式的原理与特点：DOM、SAX" class="headerlink" title="解析XML的几种方式的原理与特点：DOM、SAX"></a>解析XML的几种方式的原理与特点：DOM、SAX</h1><p>DOM分析器是把整个XML文档转化为DOM树放在内存中<br>SAX解析采用事件驱动，通过事件处理函数实现对xml文档的访问。</p><p>21.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？<br>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>22.Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？<br>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。<br>而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性<br>Put和读取多线程导致的问题。<br>23.ConcurrentHashMap的并发度是什么？*<br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势<br>24.ReentrantReadWriteLock读写锁的使用？<br>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 <br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；<br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！<br>36.高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？*<br>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看： 　　<br>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 　　<br>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换<br>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。<br>39.如果同步块内的线程抛出异常会发生什么？<br>只要退出了synchronized块，无论是正常还是异常，都会释放锁。<br>40.并发编程（concurrency）并行编程（parallellism）有什么区别？*<br>并发（concurrency）和并行（parallellism）是：<br>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>解释三：并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群<br>41.如何保证多线程下 i++ 结果正确？<br>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。<br>42.一个线程如果出现了运行时异常会怎么样?<br>如果该异常被捕获或抛出，则程序继续运行。 <br>如果异常没有被捕获该线程将会停止执行。 <br>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理<br>46.Java中用到的线程调度算法是什么*<br>操作系统的核心，它实际就是一个常驻内存的程序，不断地对线程队列进行扫描，利用特定的算法（时间片轮转法、优先级调度法、多级反馈队列调度法等）找出比当前占有CPU的线程更有CPU使用权的线程，并从之前的线程中收回处理器，再使待运行的线程占用处理器。<br>10.分派：静态分派与动态分派。<br>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的<br>动态分派：（重写）<br>数据结构与算法<br>1.链表与数组。<br>数组：ArrayList—静态分配内存，内存连续。数组元素在栈区。<br>链表：LinkedList—手持下一个人的地址，动态内存分配，内存不连续。数组元素在堆区<br>2.队列和栈，出栈与入栈。<br>queue队列是先进先出<br>入栈，s.push(x)<br>出栈，s.pop()<br>访问栈顶，s.top()<br>判断栈空，s.empty()<br>访问栈中的元素个数，s.size()<br>stack栈是先入后出<br>入队，q.push(x)<br>出队，q.pop()<br>访问队首元素，q.front()、访问队尾元素，q.back()<br>判断队列空，q.empty()<br>访问队列中的元素个数，q.size()<br>3.链表的删除、插入、反向。*<br>数据域，指针域，当前节点<br>删除需要找到上一个节点，然后指向下下节点，size减去1<br>插入，找上一个节点，设置next到新节点，新节点初始化上一节点的current.next<br>反向：head.getnext获取末尾节点，然后以此重新指向反转（递归反转法）<br>遍历反转法，按顺序依次反转。<br>4.字符串操作。<br>(1)字符串的连接<br>public String concat(String str) <br>该方法的参数为一个String类对象,作用是将参数中的字符串str连接到原来字符串的后面. <br>(2)求字符串的长度<br>public int length()<br>返回字串的长度,这里的长度指的是字符串中Unicode字符的数目.<br>(3)求字符串中某一位置的字符<br>public char charAt(int index)<br>该方法在一个特定的位置索引一个字符串,以得到字符串中指定位置的字符.值得注意的是,在字符串中第一个字符的索引是0,第二个字符的索引是1,依次类推,最后一个字符的索引是length()-1. <br>(4)字符串的比较<br>比较字符串可以利用String类提供的下列方法:<br>1)public int compareTo(String anotherString)<br>该方法比较两个字符串,和Character类提供的compareTo方法相似,Character类提供的compareTo方法比较的是两个字符类数据,而这里比较的是字符串数据.<br>其比较过程实际上是两个字符串中相同位置上的字符按Unicode中排列顺序逐个比较的结果.如果在整个比较过程中,没有发现任何不同的地方,则表明两个字符串是完全相等的,compareTo方法返回0;如果在比较过程中,发现了不同的地方,则比较过程会停下来,这时一定是两个字符串在某个位置上不相同,如果当前字符串在这个位置上的字符大于参数中的这个位置上的字符,compareTo方法返回一个大于0的整数,否则返回一个小于0的整数. <br>2)public boolean equals(Object anObject)<br>该方法比较两个字符串,和Character类提供的equals方法相似,因为它们都是重载Object类的方法.该方法比较当前字符串和参数字符串,在两个字符串相等的时候返回true,否则返回false.<br>3)public boolean equalsIgnoreCase(String anotherString)<br>该方法和equals方法相似,不同的地方在于,equalsIgnoreCase方法将忽略字母大小写的区别.<br>(5)从字符串中提取子串<br>利用String类提供的substring方法可以从一个大的字符串中提取一个子串,该方法有两种常用的形式:<br>1)public String substring(int beginIndex)<br>该方法从beginIndex位置起,从当前字符串中取出剩余的字符作为一个新的字符串返回.<br>2)public String substring(int beginIndex, int endIndex)<br>该方法从当前字符串中取出一个子串,该子串从beginIndex位置起至endIndex-1为结束.子串返的长度为endIndex-beginIndex. <br>(6)判断字符串的前缀和后缀<br>判断字符串的前缀是否为指定的字符串利用String类提供的下列方法:<br>1)public boolean startsWith(String prefix)<br>该方法用于判断当前字符串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>2)public boolean startsWith(String prefix, int toffset)<br>该方法用于判断当前字符串从toffset位置开始的子串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>判断字符串的后缀是否为指定的字符串利用String类提供的方法:<br>public boolean endsWith(String suffix)<br>该方法用于判断当前字符串的后缀是否和参数中指定的字符串suffix一致,如果是,返回true,否则返回false.<br>(7)字符串中单个字符的查找<br>字符串中单个字符的查找可以利用String类提供的下列方法:<br>1)public int indexOf(int ch)<br>该方法用于查找当前字符串中某一个特定字符ch出现的位置.该方法从头向后查找,如果在字符串中找到字符ch,则返回字符ch在字符串中第一次出现的位置;如果在整个字符串中没有找到字符ch,则返回-1. <br>2)public int indexOf(int ch, int fromIndex)<br>该方法和第一种方法类似,不同的地方在于,该方法从fromIndex位置向后查找,返回的仍然是字符ch在字符串第一次出现的位置. <br>3)public int lastIndexOf(int ch)<br>该方法和第一种方法类似,不同的地方在于,该方法从字符串的末尾位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>4)public int lastIndexOf(int ch, int fromIndex)<br>该方法和第二种方法类似,不同的地方在于,该方法从fromIndex位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>(8)字符串中子串的查找<br>字符串中子串的查找与字符串中单个字符的查找十分相似,可以利用String类提供的下列方法:<br>1)public int indexOf(String str)<br>2)public int indexOf(String str, int fromIndex)<br>3)public int lastIndexOf(String str)<br>4)public int lastIndexOf(String str, int fromIndex) <br>(9)字符串中字符大小写的转换<br>字符串中字符大小写的转换,可以利用String类提供的下列方法:<br>1)public String toLowerCase()<br>该方法将字符串中所有字符转换成小写,并返回转换后的新串.<br>2)public String toUpperCase()<br>该方法将字符串中所有字符转换成大写,并返回转换后的新串. <br>(10)字符串中多余空格的去除<br>public String trim()<br>该方法只是去掉开头和结尾的空格,并返回得到的新字符串.值得注意的是,在原来字符串中间的空格并不去掉. <br>(11)字符串中字符的替换<br>1)public String replace(char oldChar,char newChar)<br>该方法用字符newChar替换当前字符串中所有的字符oldChar,并返回一个新的字符串.<br>2)public String replaceFirst(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的第一个和字符串regex相一致的子串,并将产生的新字符串返回. <br>3)public String replaceAll(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的所有和字符串regex相一致的子串,并将产生的新字符串返回. <br>字符串变量与StringBuffer类 <br>1.创建StringBuffer类对象<br>StringBuffer类对象表示的是字符串变量,每一个StringBuffer类对象都是可以扩充和修改的字符串变量.以下是常用的StringBuffer类构造函数:<br>(1)public StringBuffer()<br>(2)public StringBuffer(int length) <br>(3)public StringBuffer(String str)  <br>5.Hash表的hash函数，冲突解决方法有哪些。<br>开放定址法或者叫再散列法；<br>1&gt;线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    2&gt;二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    3&gt;伪随机探测再散列：di&#x3D;伪随机序列；<br>再哈希法；<br>拉链法。<br>6.各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。<br>相连元素两两比较，大的往后放，第一次完毕后，最大值就出现在了最大索引处。同理，，继续，即可得到一个排好序的数组。<br>选择排序原理：<br>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i&#x3D;1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>插入排序原理：<br>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>归并排序的原理:<br>从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。<br>快速排序的原理:<br>从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。<br>堆排序的原理:<br>堆排序从小到大排序：首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，再将除了最后一个数的n-1个元素建立成大顶堆，再将最大元素和数组倒数第二个元素进行交换，重复直至堆大小减为1。<br>希尔排序的原理:<br>希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。<br>桶排序的原理:<br>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。<br>7.快排的partition函数与归并的Merge函数。<br>partition函数：双向扫描<br>Merge函数:最后再看每一组（一对）子表的归并，其原理是相同的，只是子表表长不同，换句话说，是子表的首记录号与尾记录号不同，把这个归并操作作为核心算法写成函数 merge <br>8.对冒泡与快排的改进。*<br>8.1 对冒泡的改进<br>    改进1：设置一个标志位，标志位代表在某一个冒泡遍历时候是否发生位置数据的交换，如果没有交换，则表明序列已经排序完成，否则继续排序。减少不必要的遍历。 <br>    改进2：再设置一个标志位，标志位是序列的某个下标，下标之后的代表已经排序完成，下标之前未排序，则遍历大于标志位时，不再遍历。减少一次遍历中已排完序的序列的遍历 <br>    改进3：在一次遍历时，同时找出最大值和最小值，从而提高效率。 <br>参考：排序算法（一）——冒泡排序及改进<br>8.2对快排的改进<br>基准的选取影响快排的效率，一般基准的选取有三种： <br>    1）固定位置。选序列第一位或者最后一位，算法的导论中提到的就是固定选择最后一位。 <br>    2）随机选取。对于序列中部分有序的情况，如果选择固定位置作为基准，会导致全序列都需要交换位置，这会使得效率低下。因此会采用随机选取数据作为基准。 <br>    3）三数取中。最佳划分是将序列划分成等长的两个子序列，因此提出三数取中的思想。取序列中，下标第一位，下标中间一位，下标最后一位的三个数进行排序，取排序结果中排中间的数据作为基准。（此外，也可以取5个数作为数据的基准。） <br>参考：三种快速排序以及快速排序的优化 <br>    针对以上三种情况中，三数取中效果最优，但是依然无法解决序列中出现重复情况，对此进行再次优化： <br>    优化1：当待排序序列的长度分割到一定大小后，使用插入排序。对于很小和部分有序的数组，快排不如插排好。 <br>    优化2：与基准值相同的不加入分割。在每一次分割结束后，可以把与基准相等的元素聚在一起，继续下次分割时，不用再对与基准相等元素分割。减少重复序列的反复分割 <br>    优化3：优化递归操作，快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。 <br>    这里提一下尾递归，如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归。需要说明的是递归调用必须整个函数体中最后执行的语句且它的返回值不属于表达式的一部分。 <br>尾递归的优点： <br>    1）尾递归通过迭代的方式，不存在子问题被多次计算的情况 <br>    2）尾递归的调用发生在方法的末尾，在计算过程中，完全可以把上一次留在堆栈的状态擦掉，保证程序以O(1)的空间复杂度运行。 <br>    可惜的是，在jvm中第二点并没有被优化。 <br>9.二分查找，与变种二分查找。<br>二分查找的中间下标：mid&#x3D;low+0.5∗(high−low)mid&#x3D;low+0.5∗(high−low) <br>    二分+插值： <br>    如果序列长度为1000，查找的关键字在10位置上，则还是需要从500中间开始二分查找，这样会产生多次无效查询，因此优化的方式就是更改分割的比例，采用三分，四分，分割位置：mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key)mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key) <br>    插值查找是根据要查找的关键字的key与查找表中最大最小记录的关键字比较之后的查找算法。 <br>    黄金分割比：用黄金分割比来作为mid值<br>10.二叉树、B+树、AVL树、红黑树、哈夫曼树。<br>二叉树：<br>二叉树的数据结构就不多说了，这里列举一些常见题目 <br>1）求解二叉树的节点 <br>    递归求解： <br>        a) 树为空，节点数为0 <br>        b) 二叉树节点个数 &#x3D; 左子树节点个数 + 右子树节点个数 + 1 <br>2）求二叉树的深度 <br>    递归解法： <br>        a）如果二叉树为空，二叉树的深度为0 <br>        b）如果二叉树不为空，二叉树的深度 &#x3D; max(左子树深度， 右子树深度) + 1 1. 先根遍历，中序遍历，后序遍历 <br>    依然递归求解 <br>4）广度优先 <br>    借助队列。 <br>5）将二叉查找树变为有序的双向链表 <br>    要求不能创建新节点，只调整指针。 <br>    递归解法： <br>        a）如果二叉树查找树为空，对应双向链表的第一个节点和最后一个节点是NULL <br>        b）如果二叉查找树不为空： <br>        设置参数flag，代表父节点与子节点的关系。如果修正的是左子树与父节点的关系，则递归返回的是序列最后的节点。 <br>6)求二叉树第K层的节点个数 <br>    递归解法： <br>        a）如果二叉树为空或者k&lt;1返回0 <br>        b）如果二叉树不为空并且k&#x3D;&#x3D;1，返回1 <br>        c）如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 <br>7)求二叉树中叶子节点的个数 <br>    递归解法： <br>        a）如果二叉树为空，返回0 <br>        b）如果二叉树不为空且左右子树为空，返回1 <br>        c）如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 <br>8)判断二叉树是不是平衡二叉树(AVL树) <br>    递归解法： <br>        a）如果二叉树为空，返回真 <br>        b）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假 <br>9)由前序遍历序列和中序遍历序列重建二叉树 <br>    二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。 <br>    递归解法： <br>        a）如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL; <br>        b）创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树 <br>10)判断是不是完全二叉树<br>11.二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。<br>12.图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。<br>13.KMP算法。<br>14.排列组合问题。<br>15.动态规划、贪心算法、分治算法。（一般不会问到）<br>16.大数据处理：类似10亿条数据找出最大的1000个数………等等<br>17.算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看数据库<br>1.事务四大特性（ACID）原子性、一致性、隔离性、持久性*<br>原子性：是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性: 是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。<br>隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。<br>事务之间的相互影响：脏读，不可重复读，幻读，丢失更新。<br>脏读 意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的<br>不可重复读 意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。<br>  幻读 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.<br>丢失更新 两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。<br>持久性：<br>意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><p>7.索引有B+索引和hash索引，各自的区别<br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。<br>在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。<br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。<br>8.B+索引数据结构，和B树的区别<br>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。<br>根节点至少有两个子节点<br>每个节点有M-1个key，并且以升序排列<br>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>其它节点至少有M&#x2F;2个子节点<br>B+树是对B树的一种变形树，它与B树的差异在于：<br>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</p><p>12.关系型数据库和非关系型数据库区别<br>1.关系型数据库通过外键关联来建立表与表之间的关系，<br>2.非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定</p><p>15.使用explain优化sql和索引<br>表的读取顺序<br>数据读取操作的操作类型<br>哪些索引可以使用<br>哪些索引被实际使用<br>表之间的引用<br>每张表有多少行被优化器查询<br>说了这么多使用explain的好处,那么实际上到底该怎么玩? 答案： explain + 待执行的sql<br>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化<br>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL<br>all: full table scan ;MySQL将遍历全表以找到匹配的行；<br>index ： index scan; index 和 all的区别在于index类型只遍历索引；<br>range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，&lt; ,&gt;等查询；<br>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；<br>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；<br>const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。<br>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句<br>key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：MySQL认为必须检查的用来返回请求数据的行数<br>Extra：关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。<br>16.long_query怎么解决*<br>慢查询日志：默认情况下，MySQL数据库是不开启慢查询日志的，long_query_time的默认值为10（即10秒，通常设置为1秒），即运行10秒以上的语句是慢查询语句。<br>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。<br>slow_query_log 慢查询开启状态。<br>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。<br>long_query_time 查询超过多少秒才记录。<br>17.内连接、外连接、交叉连接、笛卡儿积等<br>内连接(INNER JOIN)：  <br>    分为三种：等值连接、自然连接、不等连接<br>  <br>外连接(OUTER JOIN)：  <br>    分为三种：  <br>    左外连接(LEFT OUTER JOIN或LEFT JOIN)  <br>    右外连接(RIGHT OUTER JOIN或RIGHT JOIN)  <br>    全外连接(FULL OUTER JOIN或FULL JOIN)  交叉连接(CROSS JOIN)：  <br>    没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积<br>笛卡尔积是两个表每一个字段相互匹配，去掉where 或者inner join的等值 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。内连接: 只连接匹配的行。<br>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。<br>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。<br>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。<br>交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>20.mysql并发情况下怎么解决（通过事务、隔离级别、锁）<br>MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。。。。。<br>需求分析：互联网单位 每天大量数据读取，写入，并发性高。<br>现有解决方式：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。<br>集群方案：解决DB宕机带来的单点DB不能访问问题。<br>读写分离策略：极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。<br>21.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）<br>Undo Log<br>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了UndoLog来实现多版本并发控制(简称：MVCC)。<br>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>之所以能同时保证原子性和持久化，是因为以下特点：<br>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。<br>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。<br>Redo Log<br>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。<br>22.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序<br>Join where limit group by having12.Spring如何解决循环依赖？<br>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。<br>Spring的单例对象的初始化主要分为三步：<br>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>（3）initializeBean：调用spring xml中的init 方法。<br>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。<br>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。<br>13.Spring 如何保证 Controller 并发的安全？*<br>在Controller中使用ThreadLocal变量<br>在spring配置文件Controller中声明 scope&#x3D;”prototype”，每次都创建新的controller<br>在控制器中不使用实例变量7.Netty的高性能表现在哪些方面*<br>异步非阻塞通信<br> Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都 是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。另外，由于Netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。<br>零拷贝<br>  1) Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>       2) Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>       3) Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>内存池<br>   随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty提供了基于内存池的缓冲区重用机制（PooledByteBuf）。<br>高效的Reactor线程模型1. Reactor单线程模型；<br>       2) Reactor多线程模型；<br>       3) 主从Reactor多线程模型<br>无锁化的串行设计理念<br> 在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。<br>       为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。<br>       Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程 操作导致的锁的竞争，从性能角度看是最优的。<br>高效的并发编程<br>Netty的高效并发编程主要体现在如下几点：<br>       1) volatile的大量、正确使用;<br>       2) CAS和原子类的广泛使用；<br>       3) 线程安全容器的使用；<br>       4) 通过读写锁提升并发性能。<br>高性能的序列化框架<br>影响序列化性能的关键因素总结如下：<br>       1) 序列化后的码流大小（网络带宽的占用）；<br>       2) 序列化&amp;反序列化的性能（CPU资源占用）；<br>       3) 是否支持跨语言（异构系统的对接和开发语言切换）。<br>Netty默认提供了对Google Protobuf的支持，通过扩展Netty的编解码接口，用户可以实现其它的高性能序列化框架，例如Thrift的压缩二进制编解码框架。<br>灵活的TCP参数配置能力<br> 合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和SO_SNDBUF。如果设置不当，对性能的影响是非常大的。下面总结下对性能影响比较大的几个配置项：<br>       1) SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；<br>       2) SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；<br>       3) 软中断：如果Linux内核版本支持RPS（2.6.35以上版本），开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个 hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。<br>Netty在启动辅助类中可以灵活的配置TCP参数，满足不同的用户场景。<br>缓存<br>4.Redis的并发竞争问题如何解决<br>1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。  <br>2.服务器角度，利用setnx实现锁。<br>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。<br>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。<br>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p><p>3.Netty是如何使用线程池的，为什么这么使用*<br>EventExecutorGroup 自己实现了Future和submit<br>AbstractEventExecutorGroup，最上层实现的还是Executor接口<br>只不过通过 配置数量，配置线程模型</p><p>3.HTTP协议<br>http：+地址+端口+url<br>基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），B&#x2F;C架构<br>HTTP request请求：<br>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>GET说明请求类型为GET,[&#x2F;562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息<br>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<br>第三部分：空行，请求头部后面的空行是必须的<br>即使第四部分的请求数据为空，也必须有空行。<br>第四部分：请求数据也叫主体，可以添加任意的其他数据。<br>这个例子的请求数据为空。<br>HTTP之响应消息Response<br>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文<br>4.TCP协议：面向连接的、可靠的、基于字节流的传输层通信协议<br>IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。<br>简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包<br>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。5.一致性Hash算法*<br>一致性hash作为一个负载均衡算法，可以用在分布式缓存、数据库的分库分表等场景中，还可以应用在负载均衡器中作为作为负载均衡算法。在有多台服务器时，对于某个请求资源通过hash算法，映射到某一个台服务器，当增加或减少一台服务器时，可能会改变这些资源对应的hash值，这样可能导致一部分缓存或数据失效了。一致性hash就是尽可能在将同一个资源请求路由到同一台服务器中。<br>一致性哈希采用的做法如下：引入一个环的概念，如上面的第一个图。先将机器映射到这个环上，再将数据也通过相同的哈希函数映射到这个环上，数据存储在它顺时针走向的那台机器上。以环为中介，实现了数据与机器数目之间的解耦。这样，当机器的数目变化时，只会影响到增加或删除的那台机器所在的环的邻接机器的数据存储，而其他机器上的数据不受影响。</p><p>10.HTTP连接池实现原理<br>1、降低延迟：如果不采用连接池，每次连接发起Http请求的时候都会重新建立TCP连接(经历3次握手)，用完就会关闭连接(4次挥手)，如果采用连接池则减少了这部分时间损耗，别小看这几次握手，本人经过测试发现，基本上3倍的时间延迟<br>2、支持更大的并发：如果不采用连接池，每次连接都会打开一个端口，在大并发的情况下系统的端口资源很快就会被用完，导致无法建立新的连接<br>PoolingHttpClientConnectionManager<br>配置请求超时设置—RequestConfig<br>CloseableHttpClient 获取httpClient对象，post，get封装<br>11.数据库连接池实现原理<br>装载数据库驱动程序；<br>通过jdbc建立数据库连接；<br>访问数据库，执行sql语句；<br>断开数据库连接。<br>创建连接池，获取连接，用完后返回给连接池。<br>12.数据库的实现原理分布式<br>1.什么是CAP定理<br>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本），换句话就是说，任何时刻，所用的应用程序都能访问得到相同的数据。<br>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性），换句话就是说，任何时候，任何应用程序都可以读写数据。<br>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，换句话说，系统可以跨网络分区线性的伸缩和扩展。<br>2.CAP 理论和 BASE 理论<br>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。<br>基本可用（Basically Available）<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。<br>软状态（ Soft State）<br>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。<br>最终一致性（ Eventual Consistency）<br>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。<br>3.CAP 理论1. CAP理论<br>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。<br>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。<br>1.1 一致性（Consistency）<br>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。<br>1.2 可用性（Availability）<br>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。<br>1.3 分区容错性（Partition tolerance）<br>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。<br>4.CAP 理论和最终一致性<br>一言以蔽之：过程松，结果紧，最终结果必须保持一致性<br>最终一致性是弱一致性的一种特例。假如A首先write了一个值到存储系统，存储系统保证如果在A,B,C后续读取之前没有其它写操作更新同样的值的话，最终所有的读取操作都会读取到最A写入的最新值。此种情况下，如果没有失败发生的话，“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制技术中replica的个数（这个可以理解为master&#x2F;salve模式中，salve的个数），最终一致性方面最出名的系统可以说是DNS系统，当更新一个域名的IP以后，根据配置策略以及缓存控制策略的不同，最终所有的客户都会看到最新的值<br>5.最终一致性实现方式<br>6.一致性 Hash<br>7.分布式事务，两阶段提交。<br>两阶段提交涉及到多个节点的网络通信,通信时间如果过长,事务的相对时间也就会过长,那么锁定资源的时间也就长了.在高并发的服务中,就会存在严重的性能瓶颈</p><p>9.如何实现分布式Session*<br>2. 基于数据库的Session共享<br>3. 基于NFS共享文件系统<br>4. 基于memcached 的session，如何保证 memcached 本身的高可用性？<br>5. 基于resin&#x2F;tomcat web容器本身的session复制机制<br>6. 基于TT&#x2F;Redis 或 jbosscache 进行 session 共享。<br>7. 基于cookie 进行session共享<br>10.如何保证消息的一致性*11.负载均衡<br>负载均衡是高可用网络基础架构的的一个关键组成部分，有了负载均衡，我们通常可以将我们的应用服务器部署多台，然后通过负载均衡将用户的请求分发到不同的服务器用来提高网站、应用、数据库或其他服务的性能以及可靠性<br>12.正向代理（客户端代理）和反向代理（服务器端代理）*<br>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>（1）访问原来无法访问的资源，如google<br>    （2）可以做缓存，加速访问资源<br>　　（3）对客户端访问授权，上网进行认证<br>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息<br>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击<br>（2）负载均衡，通过反向代理服务器来优化网站的负载<br>nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。<br>13.CDN实现原理<br>（1）CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br>（2）大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。<br>CDN即内容分发网络，加速的意思，那么网站CND服务是网站加速服务。<br>CDN加速将网站的内容缓存在网络边缘（离用户接入网络最近的地方），然后在用户访问网站内容的时候，通过调度系统将用户的请求路由或者引导到离用户接入网络最近或者访问效果的缓存服务器上，有该缓存服务器为用户提供内容服务；相对于直接访问源站，这种方式缩短了用户和内容之间的网络距离，从而达到加速的效果<br>14.怎么提升系统的QPS和吞吐量*<br>QPS（TPS）：每秒钟request&#x2F;事务 数量<br>并发数：系统同时处理的request&#x2F;事务数<br>响应时间：一般取平均响应时间<br>简单而言通过增加集群来提升qps和吞吐量<br>实际上要比这个要复杂<br>首先我们需要知道系统的瓶颈<br>我们所知道的系统拓扑架构<br>对于rest接口而言<br>系统设施依次是：<br>dns<br>　　nginx<br>　　　　tomcat<br>　　　　　　db&#x2F;soa<br>首先我们可以通过增加集群来增加qps和吞吐量<br>其次考虑到负载均衡的问题，我们可以通过其他设施来保证集群节点的负载均衡，进一步提高系统qps<br>于是就有nginx集群+负载均衡<br>tomcat集群+负载均衡<br>到db&#x2F;soa这一层的时候，同样也可以通过增加集群+负载均衡的方式来解决<br>我们还可以在每一层增加缓存来应对热点数据<br>然而另外一个方面，可以系统拆分，服务拆分，分别针对瓶颈的系统单独增加集群和负载均衡来解决<br>同样db也可以分库分表，<br>因为单表超过1000万条数据时就很慢了，所以这个时候就需要库拆分，于是就有垂直拆分，水平拆分。　　　<br>异步化，可以不同调用的异步化，使用mq，比如发送短信，发送邮件等<br> <br>综上所述：<br>集群+负载均衡<br>增加缓存<br>系统拆分<br>分库分表<br>垂直拆分+水平拆分<br>异步化+MQ</p><p>16.描述一个服务从发布到被消费的详细过程*<br>创建接口服务<br>配置文件配置服务注册中心，配置接口服务<br>启动后，服务提供者启动时，向注册中心注册自己提供的服务，服务消费者在启动时，向注册中心订阅自己所需的服务<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br>17.分布式系统怎么做服务治理服务自动注册<br>客户端自动发现<br>变更下发<br>18.接口的幂等性的概念<br>在数学里，幂等有两种主要的定义：<br>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 即 s <em>s &#x3D; s<br>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) &#x3D; f(x)。<br>HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。如通过PUT接口将数据的Status置为1，无论是第一次执行还是多次执行，获取到的结果应该是相同的，即执行完成之后Status &#x3D;1。<br>orderStatus由0-&gt;1 是需要幂等性的<br>19.消息中间件如何解决消息丢失问题</em><br>消息持久化<br>ACK确认机制<br>设置集群镜像模式<br>1）单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。<br>2）普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。<br>3）镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案<br>消息补偿机制：息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。<br>20.Dubbo的服务请求失败怎么处理<br>因此，将应用拆分，并抽取出核心服务来解决上述问题，还要考虑负载均衡、服务监控、高可用性、服务隔离与降级、路由策略、完善的容错机制、序列化方案的选择、通信框架的选择、开发人员对底层细节无感知、服务升级兼容性等问题。Dubbo满足了以上所有需求。<br>21.重连机制会不会造成错误<br>dubbo在调用服务不成功时，默认会重试2次。<br>Dubbo的路由机制，会把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机制也能一定程度的保证服务的质量。<br>但是如果不合理的配置重试次数，当失败时会进行重试多次，这样在某个时间点出现性能问题，调用方再连续重复调用。<br>系统请求变为正常值的retries倍，系统压力会大增，容易引起服务雪崩，需要根据业务情况规划好如何进行异常处理，何时进行重试。<br>22.对分布式事务的理解<br>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。<br>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交，包括上面提到的消息事务+最终一致性、TCC模式，而完全控制就是完全实现两阶段提交。部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。<br>下单—涉及扣库存和更新订单状态。<br>23.如何实现负载均衡，有哪些算法可以实现？<br>既然要解决后端系统的承载能力：nginx的配置<br>均衡算法主要解决将请求如何发送给后端服务<br>随机（random）、轮训（round-robin）、一致哈希（consistent-hash）和主备（master-slave）。<br>24.Zookeeper的用途，选举的原理是什么？<br>分布式系统基本上都是主从结构，所以需要zookeeper进行协调服务，他做很多事情的，比如命名服务，配置管理，集群管理，分布式协调通知等等<br>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。1.服务器初始化时Leader选举<br>zookeeper由于其自身的性质，一般建议选取奇数个节点进行搭建分布式服务器集群。以3个节点组成的服务器集群为例，说明服务器初始化时的选举过程。启动第一台安装zookeeper的节点时，无法单独进行选举，启动第二台时，两节点之间进行通信，开始选举Leader。1）每个Server投出一票。他们两都选自己为Leader，投票的内容为（SID，ZXID）。SID即Server的id，安装zookeeper时配置文件中所配置的myid；ZXID，事务id，为节点的更新程度，ZXID越大，代表Server对Znode的操作越新。由于服务器初始化，每个Sever上的Znode为0，所以Server1投的票为（1,0），Server2为（2,0）。两Server将各自投票发给集群中其他机器。2）每个Server接收来自其他Server的投票。集群中的每个Server先判断投票有效性，如检查是不是本轮的投票，是不是来Looking状态的服务器投的票。3）对投票结果进行处理。先了解下处理规则</p><ul><li>首先对比ZXID。ZXID大的服务器优先作为Leader</li><li>若ZXID相同，比如初始化的时候，每个Server的ZXID都为0，就会比较myid，myid大的选出来做Leader。对于Server而言，他接受到的投票为（2,0），因为自身的票为（1,0），所以此时它会选举Server2为Leader，将自己的更新为（2,0）。而Server2收到的投票为Server1的（1,0）由于比他自己小，Server2的投票不变。Server1和Server2再次将票投出，投出的票都为（2,0）。4） 统计投票。每次投票之后，服务器都会统计投票信息，如果判定某个Server有过半的票数投它，那么该Server将会作为Leader。对于Server1和Server2而言,统计出已经有两台机器接收了（2,0）的投票信息，此时认为选出了Leader。5）改变服务器状态。当确定了Leader之后，每个Server更新自己的状态，Leader将状态更新为Leading，Follower将状态更新为Following。2.服务器运行期间的Leader选举<br>zookeeper运行期间，如果有新的Server加入，或者非Leader的Server宕机，那么Leader将会同步数据到新Server或者寻找其他备用Server替代宕机的Server。若Leader宕机，此时集群暂停对外服务，开始在内部选举新的Leader。假设当前集群中有Server1、Server2、Server3三台服务器，Server2为当前集群的Leader，由于意外情况，Server2宕机了，便开始进入选举状态。过程如下<br>1） 变更状态。其他的非Observer服务器将自己的状态改变为Looking，开始进入Leader选举。<br>2） 每个Server发出一个投票（myid，ZXID），由于此集群已经运行过，所以每个Server上的ZXID可能不同。假设Server1的ZXID为145，Server3的为122，第一轮投票中，Server1和Server3都投自己，票分别为（1，145）、（3,122）,将自己的票发送给集群中所有机器。<br>3） 每个Server接收接收来自其他Server的投票，降下来的步骤与启动时步骤相同。25.数据的垂直拆分水平拆分。<br>垂直拆分，对于表来说，可以按业务模型进行拆分<br>水平拆分，对于表来说，是分多个票取模存放到不同数据库<br>26.zookeeper原理和适用场景*<br>Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储， Zookeeper 作用主要是用来维护和监控存储的数据的状态变化，通过监控这些数据状态的变化，从而达到基于数据的集群管理<br>简单的说，zookeeper&#x3D;文件系统+通知机制。<br>ZooKeeper以Fast Paxos（帕克索斯）算法为基础，让集群中的每个zk实例数据保持一致。一般部署集群，机器数设置为奇数个，更容易满足&gt;N&#x2F;2的投票条件。<br>Zookeeper应用场景<br>统一命名服务<br>       分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别不同服务。类似于域名与ip之间对应关系，域名容易记住。通过名称来获取资源或服务的地址，提供者等信息按照层次结构组织服务&#x2F;应用名称可将服务名称以及地址信息写到Zookeeper上，客户端通过Zookeeper获取可用服务列表类。<br>配置管理<br>       分布式环境下，配置文件管理和同步是一个常见问题。一个集群中，所有节点的配置信息是一致的，比如Hadoop。对配置文件修改后，希望能够快速同步到各个节点上配置管理可交由Zookeeper实现。可将配置信息写入Zookeeper的一个znode上。各个节点监听这个znode。一旦znode中的数据被修改，zookeeper将通知各个节点。<br>集群管理<br>       分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态作出一些调整。Zookeeper可将节点信息写入Zookeeper的一个znode上。监听这个znode可获取它的实时状态变化。典型应用比如Hbase中Master状态监控与选举。<br>分布式通知&#x2F;协调<br>       分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。例如，NameNode须知道各DataNode的状态，JobTracker须知道各TaskTracker的状态。心跳检测机制和信息推送也是可通过Zookeeper实现。<br>分布式锁<br>       Zookeeper是强一致的。多个客户端同时在Zookeeper上创建相同znode，只有一个创建成功。Zookeeper实现锁的独占性。多个客户端同时在Zookeeper上创建相同znode ，创建成功的那个客户端得到锁，其他客户端等待。Zookeeper 控制锁的时序。各个客户端在某个znode下创建临时znode （类型为CreateMode. EPHEMERAL _SEQUENTIAL），这样，该znode可掌握全局访问时序。<br>分布式队列<br>       两种队列。当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。（可通过分布式锁实现）<br>       同步队列。一个job由多个task组成，只有所有任务完成后，job才运行完成。可为job创建一个&#x2F;job目录，然后在该目录下，为每个完成的task创建一个临时znode，一旦临时节点数目达到task总数，则job运行完成。<br>27.zookeeper watch机制<br>监视是一种简单的机制，使客户端收到关于ZooKeeper集合中的更改的通知。客户端可以在读取特定znode时设置Watches。Watches会向注册的客户端发送任何znode（客户端注册表）更改的通知。<br>Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。<br>28.redis&#x2F;zk节点宕机如何处理*<br>解决方法是连接从服务器，做save操作。将会在从服务器的data目录保存一份从服务器最新的dump.rdb文件。将这份dump.rdb文件拷贝到主服务器的data目录下。再重启主服务器。<br>29.分布式集群下如何做到唯一序列号*<br><a target="_blank" rel="noopener" href="http://stor.51cto.com/art/201711/558600.htm">http://stor.51cto.com/art/201711/558600.htm</a><br>1、利用数据库递增，全数据库唯一。<br>优点：明显，可控。<br>缺点：单库单表，数据库压力大。<br>2、UUID， 生成的是length&#x3D;32的16进制格式的字符串，如果回退为byte数组共16个byte元素，即UUID是一个128bit长的数字，一般用16进制表示。<br>优点：对数据库压力减轻了。<br>缺点：但是排序怎么办？<br>此外还有UUID的变种，增加一个时间拼接，但是会造成id非常长。<br>3、twitter在把存储系统从MySQL迁移到Cassandra的过程中由于Cassandra没有顺序ID生成机制，于是自己开发了一套全局唯一ID生成服务：Snowflake。<br>41位的时间序列（精确到毫秒，41位的长度可以使用69年）<br>10位的机器标识（10位的长度最多支持部署1024个节点）<br>12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 最高位是符号位，始终为0。<br>优点：高性能，低延迟；独立的应用；按时间有序。<br>缺点：需要独立的开发和部署。<br>4、Redis生成ID<br>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作INCR和INCRBY来实现。<br>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。<br>30.用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗*<br>可靠消费<br>Redis：没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理<br>RabbitMQ：具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费<br>可靠发布<br>Reids：不提供，需自行实现<br>RabbitMQ：具有发布确认功能，保证消息被发布到服务器<br>高可用<br>Redis：采用主从模式，读写分离，但是故障转移还没有非常完善的官方解决方案<br>RabbitMQ：集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作<br>持久化<br>Redis：将整个Redis实例持久化到磁盘<br>RabbitMQ：队列，消息，都可以选择是否持久化<br>消费者负载均衡<br>Redis：不提供，需自行实现<br>RabbitMQ：根据消费者情况，进行消息的均衡分发<br>队列监控<br>Redis：不提供，需自行实现<br>RabbitMQ：后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）<br>流量控制<br>Redis：不提供，需自行实现<br>RabbitMQ：服务器过载的情况，对生产者速率会进行限制，保证服务可靠性<br>kafka，<br>activemq，<br>RocketMQ<br>31.MQ系统的数据如何保证不丢失<br>32.列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询<br>１、中间变量　＝ user_id%（库数量*每个库的表数量）;<br>２、库序号　＝　取整（中间变量／每个库的表数量）;<br>３、表序号　＝　中间变量％每个库的表数量;<br>Join连表查询，或者多sql查询系统架构<br>1.如何搭建一个高可用系统<br>容灾<br>集群<br>主备<br>熔断<br>限流<br>监控<br>降级<br>日志<br>分库分表<br>读写分离<br>Nginx反向代理<br>CDN加速<br>SSD硬盘持久化<br>自动备份<br>2.哪些设计模式可以增加系统的可扩展性<br>工厂模式<br>抽象工厂模式<br>观察者模式：很方便增加观察者，方便系统扩展<br>模板方法模式：很方便的实现不稳定的扩展点，完成功能的重用<br>适配器模式：可以很方便地对适配其他接口<br>代理模式：可以很方便在原来功能的基础上增加功能或者逻辑<br>责任链模式：可以很方便得增加拦截器&#x2F;过滤器实现对数据的处理，比如struts2的责任链<br>策略模式：通过新增策略从而改变原来的执行策略<br>3.介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。5.什么是高内聚低耦合，请举例子如何实现*<br>同一类功能放一块，如utils包，但是各个模块功能不依赖关联，这就是低耦合<br>接口、继承、多态也是低耦合的实现<br>6.什么情况用接口，什么情况用消息<br>接口的特点是同步调用，接口实时响应，阻塞等待<br>消息的特点是异步处理，非实时响应，消息发送后则返回，消息队列可以削峰<br>一般对实时性要求比较高的功能采用接口<br>对实时性要求不高的功能可以采用消息，削峰时可以采用消息<br>7.如果AB两个系统互相依赖，如何解除依赖*<br>A—&gt;B，同时B—&gt;A<br>解除这种双向依赖的话，需要在AB之外增加一个C，用C封装A依赖的B的那部分功能，让A改为依赖C，C依赖B<br>然后就是这样<br>A—&gt;C，C—-&gt;B，B—&gt;A<br>不过这样依然存在环路依赖<br>8.如何写一篇设计文档，目录是什么<br>基于此我认为主要会分为8个部分。分别为 项目背景，项目目标，需求分析，方案对比，概要设计，详细设计（存储模型设计，接口设计），开发以及上线计划，方案排期。<br>9.什么场景应该拆分系统，什么场景应该合并系统<br>拆分系统：<br>当系统通过集群的方式已经无法解决性能问题的时候，或者业务扩展到很大的时候，需要把拆分系统<br>按照业务的方式垂直拆分：将业务功能结合比较紧密的部分拆分成独立的系统，独立维护<br>按照性能瓶颈点拆分：将系统性能瓶颈点拆分出一个独立的系统，可以针对这个独立的系统集群部署，增加可伸缩性，提高系统整体的性能<br>合并系统：<br>或者系统间通过跨进程访问的性能损耗过高，可以将系统合并成一个系统，减少跨进程访问的消耗<br>10.系统和模块的区别，分别在什么场景下使用<br>系统和模块<br>系统是一个完整功能的系统，拥有独立的访问方式，和部署方式，拥有完整的生命周期，系统由模块组成<br>模块是系统的组成部分，不能单独工作，需要依附于系统才能发挥作用，通常是解决一定场景下的问题<br>系统用于系统性解决问题的方案<br>模块是针对单个问题方面的解决方案<br>11.实战能力<br>12.有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。<br>13.开发中有没有遇到什么技术问题？如何解决的<br>14.如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。<br>15.新浪微博是如何实现把微博推给订阅者<br>16.Google是如何在一秒内把搜索结果返回给用户的。<br>17.12306网站的订票系统如何实现，如何保证不会票不被超卖。<br>18.如何实现一个秒杀系统，保证只有几位用户能买到某件商品。<br>设计这个系统是一个考虑全面的问题，可以发散出很多问题，考察很多方面，不是仅仅回答通过redis的自减操作完成<br>比如简单的方案：<br>1，页面开启倒计时，要保证不能把下单接口暴露过早暴露出来，防止机器刷下单接口<br>2，前端限流，比如nginx对下单接口限流，命中限流则返回302到秒杀页<br>3，后端单独部署，独立域名和nginx，与线上正常运行的系统隔离开来，避免影响到线上环境<br>4，由于生成订单操作比较耗时，采用队列的方式来解耦下单成功和生成订单，针对进入后端的请求，采用redis自减，针对自减结果&gt;0的请求则认为下单成功，触发一个生成订单的消息，然后立即返回给用户结果<br>5，用户方面，针对秒杀成功有两种处理方式<br>　　a，用户端收到秒杀成功的结果，则开启提示页面，并进入倒计时，倒计时时间为订单生成的预估时间<br>　　b，秒杀成功后，给当前用户在redis中生成一个订单生成状态的标识，用户端开启提示页面，loading，并轮询后端订单生成状态，生成成功之后让前端跳转到订单页面<br>6，订单服务订阅下单系统发送的消息，并开始生成订单，生成订单成功之后更新redis中用户秒杀订单的状态为已生成订单</li></ul><p> <br>系统应该有页面和接口<br>页面用于展示用户界面，接口用于获取数据<br>界面：秒杀页面，秒杀成功页面，秒杀失败页面，命中限流页面（查看订单页面不算秒杀系统的功能）<br>接口：秒杀下单接口，秒杀成功获取订单生成状态接口TCP&#x2F;IP<br>1.OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议。*<br>OSI模型—应用层，表示层，回话层，传输层，网络层，数据链路层，物理层<br>1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 <br>2.数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 <br>3.网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 <br>4.传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 <br>5.会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） <br>6.表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 <br>7.应用层： 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。2.TCP与UDP的区别。*<br>TCP(Transmission Control Protocol)：传输控制协议<br>UDP(User Datagram Protocol)：用户数据报协议<br>TCP是面向连接的、可靠的、有序的、速度慢的协议；<br>UDP是无连接的、不可靠的、无序的、速度快的协议。<br>TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。<br>TCP无界有拥塞控制，UDP有界无拥塞控制。3.TCP报文结构。<br>1、端口号：用来标识同一台计算机的不同的应用进程。<br>1）源端口：源端口和IP地址的作用是标识报文的返回地址。<br>2）目的端口：端口指明接收方计算机上的应用程序接口。<br>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。<br>2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。<br>3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32&#x2F;8 &#x3D; 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。<br>4、保留：为将来定义新的用途保留，现在一般置0。<br>5、控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。<br>1）URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。<br>2）ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。<br>3）PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。<br>4）RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。<br>5）SYN：同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。<br>6）FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。<br>6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。<br>7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。<br>8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。<br>9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。<br>10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。<br>4.TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。<br>5.TCP拥塞控制。<br>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或者链路不会导致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制<br>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。<br>（1）在通信子网出现过多数据包的情况，使得网络的性能下降，甚至不能正常工作，这种现象就称为拥塞。<br>（2）网络拥塞的成因主要有三：1、处理器的速度太慢。2、线路容量的限制。3、节点输出包的能力小于输入包的能力。<br>（3）拥塞控制与流量控制是相关的，流量控制在数据链路层对一条通信路径上的流量进行控制，其的是保证发送者的发送速度不超过接收者的接收速度，它只涉及一全发送者和一个接收者，是局部控制。拥塞控制是对整个通信子网的流量进行控制，其目的是保证通信子网中的流量与其资源相匹配，使子网不会出现性能下降和恶化、甚至崩溃，是全局控制。<br>（4）拥塞控制的最终目标是：1、防止由于过载而使吞吐量下降，损失效率；2、合理分配网络资源；3、避免死锁；4、匹配传输速度。<br>（5）对拥塞控制，可用的方法有两类：开环控制和闭环控制。<br>1、开环控制的思想是通过良好的设计避免拥塞问题的出现，确保拥塞问题在开始时就不可能发生。开环控制方法包括何时接受新的通信何时丢弃包、丢弃哪些包。其特点是在作出决定时不考虑网络当前的状态。<br>2、闭环控制的思想是反馈控制。即通过将网络工作的动态信息反馈给网络中节点的有关进程，节点根据网络当前的动态信息，调整转发数据包的策略。闭环控制过程包括三部分： ①监视系统  检测网络发生或将要发生拥塞的时间和地点。②报告  将监视中检测到的信息传送到可以进行拥塞控制的节点。③决策  调整系统的操作行为，以解决问题。<br>（6）对应于开环控制的方法有：（基于拥塞预防）<br>1、预定缓冲区 2、合理分配缓冲区 3、通信量整形法（A、许可证算法，B、漏桶算法，C、令牌漏桶算法。）<br>对应于闭环控制的方法有：（基于拥塞抑制，即拥塞出现或即将出现时采取适当的措施进行控制，直到消除拥塞）<br>1、阻塞包法。 2、负载丢弃法<br>6.TCP滑动窗口与回退N针协议。<br>7.Http的报文结构。<br>（1）HTTP请求报文<br>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。（2）HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。<br>8.Http的状态码含义。<br>1xx: 信息<br>消息：	描述：<br>100 Continue	服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。<br>101 Switching Protocols	服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。<br>103 Checkpoint	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>2xx: 成功<br>消息：	描述：<br>200 OK	请求成功（这是对HTTP请求成功的标准应答。）<br>201 Created	请求被创建完成，同时新的资源被创建。<br>202 Accepted	供处理的请求已被接受，但是处理未完成。<br>203 Non-Authoritative Information	请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。<br>204 No Content	请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br>205 Reset Content	请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。<br>206 Partial Content	客户发送了一个带有Range头的GET请求，服务器完成了它。<br>3xx: 重定向<br>消息：	描述：<br>300 Multiple Choices	多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。<br>301 Moved Permanently	所请求的页面已经转移至新的 URL 。<br>302 Found	所请求的页面已经临时转移至新的 URL 。<br>303 See Other	所请求的页面可在别的 URL 下被找到。<br>304 Not Modified	未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br>305 Use Proxy	客户请求的文档应该通过Location头所指明的代理服务器提取。<br>306 Switch Proxy	目前已不再使用，但是代码依然被保留。<br>307 Temporary Redirect	被请求的页面已经临时移至新的 URL 。<br>308 Resume Incomplete	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>4xx: 客户端错误<br>消息：	描述：<br>400 Bad Request	因为语法错误，服务器未能理解请求。<br>401 Unauthorized	合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。<br>402 Payment Required	此代码尚无法使用。<br>403 Forbidden	合法请求，但对被请求页面的访问被禁止。<br>404 Not Found	服务器无法找到被请求的页面。<br>405 Method Not Allowed	请求中指定的方法不被允许。<br>406 Not Acceptable	服务器生成的响应无法被客户端所接受。<br>407 Proxy Authentication Required	用户必须首先使用代理服务器进行验证，这样请求才会被处理。<br>408 Request Timeout	请求超出了服务器的等待时间。<br>409 Conflict	由于冲突，请求无法被完成。<br>410 Gone	被请求的页面不可用。<br>411 Length Required	“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。<br>412 Precondition Failed	请求中的前提条件被服务器评估为失败。<br>413 Request Entity Too Large	由于所请求的实体太大，服务器不会接受请求。<br>414 Request-URI Too Long	由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。<br>415 Unsupported Media Type	由于媒介类型不被支持，服务器不会接受请求。<br>416 Requested Range Not Satisfiable	客户端请求部分文档，但是服务器不能提供被请求的部分。<br>417 Expectation Failed	服务器不能满足客户在请求中指定的请求头。<br>5xx: 服务器错误<br>消息：	描述：<br>500 Internal Server Error	请求未完成。服务器遇到不可预知的情况。<br>501 Not Implemented	请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。<br>502 Bad Gateway	请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。<br>503 Service Unavailable	服务器当前不可用（过载或者当机）。<br>504 Gateway Timeout	网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。<br>505 HTTP Version Not Supported	服务器不支持请求中指明的HTTP协议版本。<br>511 Network Authentication Required	用户需要提供身份验证来获取网络访问入口。9.Http?request的几种类型。*<br>1.  OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’<em>‘的请求来测试服务器的功能性。<br>2.  HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>3.  GET：向特定的资源发出请求。<br>4.  POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>5.  PUT：向指定资源位置上传其最新内容。<br>6.  DELETE：请求服务器删除Request-URI所标识的资源。<br>7.  TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>8.  CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>10.Http1.1和Http1.0的区别</em><br>长连接<br>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。<br>HTTP是基于TCP&#x2F;IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。<br>节约带宽<br>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。<br>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。<br>HOST域<br>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。<br>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。<br>11.Http怎么处理长连接。*<br>在HTTP1.0和HTTP1.1协议中都有对长连接的支持。其中HTTP1.0需要在request中增加Connection： keep-alive header才能够支持，而HTTP1.1默认支持。<br>http1.0请求与服务端的交互过程:<br>（1）客户端发出带有包含一个header：”Connection： keep-alive“的请求<br>（2）服务端接收到这个请求后,根据http1.0和”Connection： keep-alive“判断出这是一个长连接,就会在response的header中也增加”Connection： keep-alive“，同时不会关闭已建立的tcp连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>http1.1请求与服务端的交互过程:<br>（1）客户端发出http1.1的请求<br>（2）服务端收到http1.1后就认为这是一个长连接,会在返回的response设置Connection： keep-alive,同时不会关闭已建立的连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>基于http协议的长连接减少了请求,减少了建立连接的时间,但是每次交互都是由客户端发起的,客户端发送消息,服务端才能返回客户端消息。<br>12.Cookie与Session的作用于原理。<br>1.1 Cookie机制<br>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。<br>而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。<br>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。<br>1.2 Session机制<br>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。<br>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。<br>Java Web规范支持通过配置的方式禁用Cookie。下面举例说一下怎样通过配置禁止使用Cookie，可以使用重定向url。 <br>cookie数据保存在客户端，session数据保存在服务器端 <br>第一次请求服务器，生成session和sessionID，sessionID用cookie保存 <br>第二次请求服务器，携带seesionID，服务器从请求中取出sessionID<br>13.电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。<br>应用层：<br>连接：当我们输入一个url请求时，首先要建立socket连接，因为socket是通过ip和端口建立的，所有有一个DNS解析的过程，首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。现在已经拥有了目标ip和端口号，这样我们就可以打开socket连接了。<br>请求：连接成功建立后，开始向web服务器发送请求，这个请求一般是GET或POST命令（POST用于FORM参数的传递）。GET命令的格式为：　　GET 路径&#x2F;文件名 HTTP&#x2F;1.0<br>文件名指出所访问的文件，HTTP&#x2F;1.0指出Web浏览器使用的HTTP版本。现在可以发送GET命令：<br>GET &#x2F;mytest&#x2F;index.html HTTP&#x2F;1.0，<br>应用层：<br>1. DNS（53）：<br>我们输入的是一个URL需要转化成IP地址。首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。1. HTTP（80）<br>HTTP协议的主要职责是生成针对目标web服务器的http请求报文（请求行、请求头部）<br>传输层<br>2. TCP<br>将http请求报文分割成报文段，按序号分为多个报文段。（三次握手）<br>网络层<br>3. IP<br>搜索目标的地址，一边中转一边传送。（路由）<br>4. ARP<br>因为最终都要在数据链路层上进行传输，而数据链路层并不认识IP地址，所以ARP的职责就是把IP地址转换成数据链路层认识的MAC地址。<br>通过数据链路层到达目标机器之后<br>网络层<br>5. RARP<br>这其实是ARP的逆过程，将MAC地址转换成Ip地址<br>传输层<br>6. TCP<br>将接收到的报文段按序号进行重组。<br>应用层<br>7. HTTP<br>14.Ping的整个过程。ICMP报文是什么。<br>ICMP（网际控制报文协议）：用来测试网络层是不是有故障，若有故障，该协议还能报告故障。Ping命令来使用这个协议<br>15.C&#x2F;S模式下使用socket通信，几个关键函数。*<br>client ： socket（ip，端口）<br>socket.close();<br>server：serversocket（端口）<br>socket &#x3D; server.accept()<br>16.IP地址分类。<br>IP地址分类（A类 B类 C类 D类 E类）<br>     IP地址由四段组成，每个字段是一个字节，8位，最大值是255，,<br>     IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。<br>  IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。<br>     IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。    全0和全1的都保留不用。<br>     A类：（1.0.0.0-126.0.0.0）（默认子网掩码：255.0.0.0或 0xFF000000）<br>     第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1<del>126之间。<br>     一般用于大型网络。<br>     B类：（128.1.0.0-191.255.0.0）（默认子网掩码：255.255.0.0或0xFFFF0000）<br>     前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128</del>191之间。<br>     一般用于中等规模网络。<br>     C类：（192.0.1.0-223.255.255.0）（子网掩码：255.255.255.0或 0xFFFFFF00）<br>     前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192<del>223之间。<br>     一般用于小型网络。<br>    D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224</del>239之间。一般用于多路广播用户[1]  。<br>    E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。<br>  回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。 <br>       一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP&#x2F;IP是否正常。<br>17.路由器与交换机区别。<br>一、工作所在的OSI层次不一样（根本区别，导致接下来的区别） <br>交换机工作在 OSI模型的数据链路层，所以工作原理比较简单； <br>路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。<br>二、数据转发所依据的对象也不一样。 <br>交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。 <br>路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。<br>三、是否可以分割广播域 <br>由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵； <br>连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。<br>18.网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。<br>19.推荐书籍：《TCP&#x2F;IP协议族》1．JDK,JRE,JVM(掌握)<br>(1)JVM<br>保证Java语言跨平台。针对不同的操心系统提供不同的JVM。<br>问题：java语言是跨平台的吗?JVM是跨平台的吗?<br>(2)JRE<br>java程序的运行环境。包括JVM和核心类库<br>(3)JDK<br>java开发环境。包括JRE和开发工具(javac,java)<br>(4)一个Java程序的开发流程<br>A:编写Java源程序<br>B:通过javac命令编译java程序，生成字节码文件<br>C:通过java命令运行字节码文件<br>2．主从数据库切换<br>一般使用多个dataSource，然后创建多个SessionFactory，入侵明显，修改多，session处理比较麻烦。<br>合适的方案使用AbstractRoutingDataSource实现类通过AOP或者手动处理实现动态使用我们的数据源，入侵低。determineTargetDataSource –<br>determineCurrentLookupKey<br>Why：如果主库故障，可以切换从库<br>Why：针对与mysql，怎么保证主从同步，怎么通知代码切换1. Bean获取它所在的Spring容器，可以让该Bean实现ApplicationContextAware接口，Bean获取它所在的Spring容器，可以通过这个上下文环境对象得到Spring容器中的Bean。<br>Why：针对于非web项目的spring2. ehcache:<br>String：字符串常量 每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉，<br>　　　StringBuffer：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>　　　StringBuilder：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>String 字符串常量 线程安全 操作少量数据<br>StringBuffer 字符串变量 线程安全 操作大量数据 速度慢 多线程适合用<br>StringBuilder 字符串变量 线程不安全 操作大量数据 速度快 单线程适合用<br>String str &#x3D; new String(“xyz”);创建了几个对象。<br>如果String常量池中，已经创建了”xyz”,则不会继续创建，此时只创建了一个对象new String(“xyz”);<br>如果String常量池中没有创建”xyz”,则会创建两个对象，一个对象的值是”xyz”,一个对象是new String(“xyz”);<br>6．关系型数据库和非关系型数据库种类和关系<br>数据库<br>类型	特性	优点	缺点<br>关系型数据库<br>SQLite、Oracle、mysql	1、关系型数据库，是指采用了关系模型来组织<br>数据的数据库；<br>2、关系型数据库的最大特点就是事务的一致性；<br>3、简单来说，关系模型指的就是二维表格模型，<br>而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。	1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。	1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、高并发读写需求；<br>4、海量数据的高效率读写；<br>非关系型数据库<br>MongoDb、redis、HBase	1、使用键值对存储数据；<br>2、分布式；<br>3、一般不支持ACID特性；<br>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。	1、无需经过sql层的解析，读写性能很高；<br>2、基于键值对，数据没有耦合性，容易扩展；<br>3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。	1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理，附加功能bi和报表等支持也不好；4. Vector ,ArrayList 和LinkedList的区别？<br> 1、Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。<br> 2、Vector线程同步，ArrayList、LinkedList线程不同步。<br> 3、LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。<br> 4、ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省。8.注解<br>登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。9.反射<br>反射就是把java类中的各种成分映射成一个个的Java对象<br>可以获取类的相关信息，可以进行设置，可以代理<br>spring 的 ioc&#x2F;di 也是反射….<br>javaBean和jsp之间调用也是反射….<br>struts的 FormBean 和页面之间…也是通过反射调用….<br>JDBC 的 classForName()也是反射…..<br>hibernate的 find(Class clazz) 也是反射….<br>10.加载器11.ajax<br>运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换；2. statement<br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>3. 数据库基础查询<br>1、 加载JDBC驱动程序： <br>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机）， <br>这通过java.lang.Class类的静态方法forName(String className)实现。 <br>例如：<br>try{<br>&#x2F;&#x2F;加载MySql的驱动类<br>Class.forName(“com.mysql.jdbc.Driver”) ;<br>}catch(ClassNotFoundException e){<br>System.out.println(“找不到驱动程序类 ，加载驱动失败！”);<br>e.printStackTrace() ;<br>}<br>成功加载后，会将Driver类的实例注册到DriverManager类中。<br>2、 提供JDBC连接的URL * 连接URL定义了连接数据库时的协议、子协议、数据源标识。 </p><ul><li>书写形式：协议：子协议：数据源标识<br>协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。 <br>数据源标识：标记找到数据库来源的地址与连接端口。 <br>例如： <br>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;gbk;useUnicode&#x3D;true;（MySql的连接URL） <br>表示使用Unicode字符集。如果characterEncoding设置为 gb2312或GBK，本参数必须设置为true 。characterEncoding&#x3D;gbk：字符编码方式。<br>3、创建数据库的连接 </li><li>要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。 </li><li>使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。<br>例如： &#x2F;&#x2F;连接MySql数据库，用户名和密码都是root<br>String url &#x3D; “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test” ;<br>String username &#x3D; “root” ;<br>String password &#x3D; “root” ;<br>try{<br>Connection con &#x3D; DriverManager.getConnection(url , username , password ) ;<br>}catch(SQLException se){<br>System.out.println(“数据库连接失败！”);<br>se.printStackTrace() ;<br>}<br>4、 创建一个Statement <br>•要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型： <br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>具体的实现方式： <br>Statement stmt &#x3D; con.createStatement() ; PreparedStatement pstmt &#x3D; con.prepareStatement(sql) ; CallableStatement cstmt &#x3D; con.prepareCall(“{CALL demoSp(? , ?)}”) ; <br>5、执行SQL语句 <br>Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute <br>1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。 <br>2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等 <br>3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码： <br>ResultSet rs &#x3D; stmt.executeQuery(“SELECT * FROM …”) ; int rows &#x3D; stmt.executeUpdate(“INSERT INTO …”) ; boolean flag &#x3D; stmt.execute(String sql) ; <br>6、处理结果 <br>两种情况： <br>1、执行更新返回的是本次操作影响到的记录数。 <br>2、执行查询返回的结果是一个ResultSet对象。 <br>• ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些 行中数据的访问。 <br>• 使用结果集（ResultSet）对象的访问方法获取数据： <br>while(rs.next()){ <br>String name &#x3D; rs.getString(“name”) ; <br>String pass &#x3D; rs.getString(1) ; &#x2F;&#x2F; 此方法比较高效 <br>} <br>（列是从左到右编号的，并且从列1开始）<br>7、关闭JDBC对象 <br>操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反： <br>1、关闭记录集 <br>2、关闭声明 <br>3、关闭连接对象</li></ul><p>17.使用Spring框架的好处是什么？<br>  轻量：Spring 是轻量的，基本的版本大约2MB。<br>  控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>  容器：Spring 包含并管理应用中对象的生命周期和配置。<br>  MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br>  事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br>  异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。1. ~8等于多少？8&gt;&gt;&gt;2等于多少？<br>第一个答案是-9，第二个答案是2，无符号右移高位补0	。2. 子类能否重写父类的静态方法<br>不能，类对象，从属于对应的类。3. 什么是线程？<br>  线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。4. 线程和进程有什么区别？<br>  线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。5. 如何在Java中实现线程？<br>  两种方式：java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。6. Java 关键字volatile 与 synchronized 作用与区别？<br>1，volatile<br>    它所修饰的变量不保留拷贝，直接访问主内存中的。<br>2，synchronized<br>    当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。24.不同的线程生命周期？<br>  当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。<br>        1. 程优先级的理解是什么？<br>  每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。26.是死锁(Deadlock)？如何分析和避免死锁？<br>  死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。<br>  分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。<br>  避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。27.么是线程安全？Vector是一个线程安全类吗？ <br>所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。28.Java中如何停止一个线程？<br>  Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程29.什么是ThreadLocal?<br>  ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。<br>  每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。30.Sleep()、suspend()和wait()之间有什么区别？<br>  Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。<br>  注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。<br>  object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()&#x2F;notify()与sleep()&#x2F;interrupt()类似，只是前者需要获取对象锁。31.什么是线程饿死，什么是活锁？<br>  当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI中线程活锁可能发生在以下情形：<br>  1，当所有线程在程序中执行Object.wait(0)，参数为0的wait方法。程序将发生活锁直到在相应的对象上有线程调用Object.notify()或者Object.notifyAll()。<br>  2，当所有线程卡在无限循环中。32.什么是Java Timer类？如何创建一个有特定时间间隔的任务？<br>  java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br>  java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。<br>33.Java中的同步集合与并发集合有什么区别？<br>  同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。<br>  在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。<br>  Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。34.同步方法和同步块，哪个是更好的选择？<br>  同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。35.么是线程池？ 为什么要使用它？<br>  创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。<br>  为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。<br>  从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。36．java中invokeAndWait 和 invokeLater有什么区别？<br>  这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。1. 多线程中的忙循环是什么?<br>  忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存。<br>  在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。2. Array不可以用泛型？<br>是的，list的可以，推荐用list，List可以提供编译期的类型安全保证，而Array却不能。<br>int num&#x3D;Integer.valueOf(“12”);<br>int num2&#x3D;Integer.parseInt(“12”);<br>double num3&#x3D;Double.valueOf(“12.2”);<br>double num4&#x3D;Double.parseDouble(“12.2”);<br>&#x2F;&#x2F;其他的类似。通过基本数据类型的包装来的valueOf和parseXX来实现String转为XX<br>String a&#x3D;String.valueOf(“1234”);&#x2F;&#x2F;这里括号中几乎可以是任何类型<br>String b&#x3D;String.valueOf(true);<br>String c&#x3D;new Integer(12).toString();&#x2F;&#x2F;通过包装类的toString()也可以<br>String d&#x3D;new Double(2.3).toString();3. AJAX有哪些有点和缺点？<br>优点：<br>  1、最大的一点是页面无刷新，用户的体验非常好。<br>  2、使用异步方式与服务器通信，具有更加迅速的响应能力。<br>  3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。<br>   4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。<br>缺点：<br>   1、ajax不支持浏览器back按钮。<br>   2、安全问题 AJAX暴露了与服务器交互的细节。<br>   3、对搜索引擎的支持比较弱。<br>   4、破坏了程序的异常机制。<br>   5、不容易调试。40.集合解析<br>List 和 Set 区别<br>List,Set都是继承自Collection接口<br>List特点：元素有放入顺序，元素可重复<br>Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉<br>（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）<br>Set和List对比：<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。<br>ArrayList 与 Vector 区别<br>public ArrayList(int initialCapacity)&#x2F;&#x2F;构造一个具有指定初始容量的空列表。<br>public ArrayList()&#x2F;&#x2F;构造一个初始容量为10的空列表。<br>public ArrayList(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 的元素的列表<br>Vector有四个构造方法：<br>public Vector()&#x2F;&#x2F;使用指定的初始容量和等于零的容量增量构造一个空向量。<br>public Vector(int initialCapacity)&#x2F;&#x2F;构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。<br>public Vector(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 中的元素的向量<br>public Vector(int initialCapacity,int capacityIncrement)&#x2F;&#x2F;使用指定的初始容量和容量增量构造一个空的向量<br>ArrayList和Vector都是用数组实现的，主要有这么三个区别：<br>Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；<br>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。<br>Vector可以设置增长因子，而ArrayList不可以。<br>Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。<br>适用场景分析：<br>Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。<br>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。<br>HashSet 和 HashMap 区别<br>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象<br>HashMap 和 ConcurrentHashMap 的区别<br>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。41.线程解析</p><ol><li>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore<br>CountDownLatch用法<br>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。<br>CyclicBarrier用法<br>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。<br>Semaphore用法<br>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。下面对上面说的三个辅助类进行一个总结：<br>　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。<br>　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。<br>说说 CountDownLatch 与 CyclicBarrier 区别<br>CountDownLatch	CyclicBarrier<br>减计数方式	加计数方式<br>计算为0时释放所有等待的线程	计数达到指定值时释放所有等待线程<br>计数为0时，无法重置	计数达到指定值时，计数置为0重新开始<br>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响	调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞<br>不可重复利用	可重复利用java.util.concurrent.Exchanger应用范例与原理浅析<br>此类提供对外的操作是同步的；<br>用于成对出现的线程之间交换数据；<br>可以视作双向的同步队列；<br>可应用于基因算法、流水线设计等场景。<br>ThreadLocal 原理分析<br>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。<br>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。<br>讲讲线程池的实现原理<br>线程池的几种方式<br>newFixedThreadPool(int nThreads) <br>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程<br>newCachedThreadPool() <br>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制<br>newSingleThreadExecutor() <br>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行<br>newScheduledThreadPool(int corePoolSize) <br>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br>线程的生命周期<br>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态<br>(1)生命周期的五种状态<br>新建（new Thread） <br>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 <br>例如：Thread t1&#x3D;new Thread();<br>就绪（runnable） <br>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();<br>运行（running） <br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。<br>死亡（dead） <br>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。<br>自然终止：正常运行run()方法后终止<br>异常终止：调用stop()方法让一个线程终止运行<br>堵塞（blocked） <br>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。<br>正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）1. 锁机制<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。 <br>在Java里，线程安全一般体现在两个方面： <br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。 <br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>Volatile<br>在多线程并发编程中synchronized和Volatile都扮演着重要的角色，Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。悲观锁 乐观锁<br>乐观锁 悲观锁 <br>是一种思想。可以用在很多方面。<br>比如数据库方面。 <br>悲观锁就是for update（锁定查询的行） <br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）<br>JDK方面： <br>悲观锁就是sync <br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。 <br>乐观锁就认为，基本没人抢。<br>乐观锁（Optimistic Lock）： <br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。数据存储分析<br>mysql索引使用技巧及注意事项<br> INSERT 与 UPDATE 语句在拥有索引的表中执行会花费更多的时间，而SELECT 语句却会执行得更快。这是因为，在进行插入或更新时，数据库也需要插入或更新索引值。<br>索引的类型：<br>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值<br>INDEX(普通索引)：允许出现相同的索引内容<br>PROMARY KEY(主键索引)：不允许出现相同的值<br>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维<br>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一<br>(1)使用ALTER TABLE语句创建索性<br>ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）<br>(2)使用CREATE INDEX语句对表增加索引<br>CREATE INDEX index_name ON table_name(username(length));<br>&#x2F;&#x2F;create只能添加这两种索引;<br>CREATE INDEX index_name ON table_name (column_list)<br>CREATE UNIQUE INDEX index_name ON table_name (column_list)<br>(3)删除索引<br>删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下：<br>drop index index_name on table_name ;alter table table_name drop index index_name ;alter table table_name drop primary key ;<br>(4) 组合索引与前缀索引<br>create table USER_DEMO<br>(<br>ID int not null auto_increment comment ‘主键’,<br>LOGIN_NAME varchar(100) not null comment ‘登录名’,<br>PASSWORD varchar(100) not null comment ‘密码’,<br>CITY varchar(30) not null comment ‘城市’,<br>AGE int not null comment ‘年龄’,<br>SEX int not null comment ‘性别(0:女 1：男)’,<br>primary key (ID)<br>);<br>ALTER TABLE USER_DEMO ADD INDEX name_city_age (LOGIN_NAME(16),CITY,AGE);索引的使用及注意事项<br>Explain select * from user where id&#x3D;1;<br>    1.索引不会包含有NULL的列<br>       只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。<br>    2.使用短索引<br>       对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。<br>    3.索引列排序<br>       mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。<br>    4.like语句操作<br>      一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。<br>    5.不要在列上进行运算<br>    6.不使用NOT IN 、&lt;&gt;、！&#x3D;操作，但&lt;,&lt;&#x3D;，&#x3D;，&gt;,&gt;&#x3D;,BETWEEN,IN是可以用到索引的<br>    7.索引要建立在经常进行select操作的字段上。<br>       这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。<br>    8.索引要建立在值比较唯一的字段上。<br>    9.对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。<br>    10.在where和join中出现的列需要建立索引。<br>    11.where的查询条件里有不等号(where column !&#x3D; …),mysql将无法使用索引。<br>    12.如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…),mysql将无法使用索引。<br>    13.在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。<br>分表与分库使用场景以及设计方式<br>对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表！场景：分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master<br>服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。<br>因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!<br>MySQL有三种锁的级别：页级、表级、行级。<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br>存储引擎的 InnoDB 与 MyISAM<br>1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。<br>2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用<br>3）InnoDB支持外键，MyISAM不支持<br>4）从MySQL5.5.5以后，InnoDB是默认引擎<br>5）InnoDB不支持FULLTEXT类型的索引<br>6）InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表<br>7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引<br>8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表<br>9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’<br>索引数据结构设相关的计算机原理<br>上文说过，二叉树、红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-&#x2F;+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-&#x2F;+Tree作为索引的理论基础。<br>当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，你需增加order by，并且order by字段需要建立索引。<br>   如果使用子查询去优化LIMIT的话，则子查询必须是连续的，某种意义来讲，子查询不应该有where条件，where会过滤数据，使数据失去连续性。<br>   如果你查询的记录比较大，并且数据传输量比较大，比如包含了text类型的field，则可以通过建立子查询。<br>分布式系统唯一ID生成方案汇总<br>关系型数据库 MySQL<br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。<br>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>文档数据库 MongoDB<br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。<br>列族数据库 HBase<br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。<br>全文搜索引擎 ElasticSearch<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。<br>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。<br>MongoDB 特性	优势<br>事务支持	MongoDB 目前只支持单文档事务，需要复杂事务支持的场景暂时不适合<br>灵活的文档模型	JSON 格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代<br>高可用复制集	满足数据高可靠、服务高可用的需求，运维简单，故障自动切换<br>可扩展分片集群	海量数据存储，服务能力水平扩展<br>高性能	mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足各种场景需求<br>强大的索引支持	地理位置索引可用于构建 各种 O2O 应用、文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求<br>Gridfs	解决文件存储的需求<br>aggregation &amp; mapreduce	解决数据分析场景需求，用户可以自己写查询语句或脚本，将请求都分发到 MongoDB 上完成<br>从目前阿里云 MongoDB 云数据库上的用户看，MongoDB 的应用已经渗透到各个领域，比如游戏、物流、电商、内容管理、社交、物联网、视频直播等，以下是几个实际的应用案例。<br>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新<br>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。<br>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能<br>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析<br>视频直播，使用 MongoDB 存储用户信息、礼物信息等redis内部数据结构深入浅出<br>redis 是 key-value 存储系统，其中 key 类型一般为字符串，而 value 类型则为 redis 对象（redis object），可以绑定各种类型的数据，譬如 string、list 和set，redis.h 中定义了 struct redisObject，它是一个简单优秀的数据结构Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>Redis 如何实现持久化1. snapshotting(快照)<br>也是默认方式.(把数据做一个备份，将数据存储到文件)<br>快照是默认的持久化方式，这种方式是将内存中数据以快照的方式写到二进制文件中，默认的文件名称为dump.rdb.可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key键修改就自动做快照.<br> 2. Append-onlyfile(缩写aof)的方式        <br>aof方式:由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。aof比快照方式有更好的持久化性，是由于在使用aof时，redis会将每一个收到的写命令都通过write函数追加到文件中，当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。      <br>当然由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。可以通过配置文件告诉redis我们想要通过fsync函数强制os写入到磁盘的时机。<br>Redis 为什么是单线程的<br>要知道Redis的数据结构并不全是简单的Key-Value，还有列表，hash，map等等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，等等。这些操作还可以合成MULTI&#x2F;EXEC的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。这还带来一个恶果就是吞吐量虽然增大，但是响应延迟可能会增加。 <br>Redis在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用Lua脚本这样的功能。对于多线程来说这需要高得多的代价。44.使用传统的 Socket 开发挺简单的，我为什么要切换到 NIO 进行编程呢？<br>1.线程模型存在致命缺陷：一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>2.性能差：频繁的线程上下文切换导致 CPU 利用效率不高；<br>3.可靠性差：由于所有的 IO 操作都是同步的，所以业务线程只要进行 IO 操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br>4.采用非阻塞 IO（NIO）之后，同步阻塞 IO 的三个缺陷都将迎刃而解：<br>5.Nio 采用 Reactor 模式，一个 Reactor 线程聚合一个多路复用器 Selector，它可以同时注册、监听和轮询成百上千个 Channel，一个 IO 线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为 CPU 核数 + 1， N &lt; 进程可用的最大句柄数)；<br>6.由于 IO 线程总数有限，不会存在频繁的 IO 线程之间上下文切换和竞争，CPU 利用率高；<br>7.所有的 IO 操作都是异步的，即使业务线程直接进行 IO 操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。由于切换到 NIO 编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用 NIO 进行通信已经逐渐成为主流。# 什么是WebSockets？WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信信道。WebSocket是双向的 -使用WebSocket客户端或服务器可以发起消息发送。<br>WebSocket是全双工的 -客户端和服务器通信是相互独立的。<br>单个TCP连接 -初始连接使用HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信<br>Light -与http相比，WebSocket消息数据交换要轻得多。# 什么是CSRF攻击CSRF代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web应用程序上执行不需要的操作。CSRF攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。NOWCODER.COM<br>Java 面试题库<br>牛客网出品<br>NOWCODER.COM<br>Java 工程师校招面试题库导读<br>一、学习说明<br>本题库均来自海量真实校招面试题目大数据进行的整理，后续也会不断更新，可免费在线观<br>看，如需下载，也可在页面<br>载需要用牛币兑换，一次兑换可享受永久下载权限，因为后续会更新）<br>需要严肃说明的是：面试题库作为帮助同学准备面试的辅助资料，但是绝对不能作为备考唯<br>一途径，因为面试是一个考察真实水平的，不是背会了答案就可以的，需要你透彻理解的，<br>否则追问问题答不出来反而减分，毕竟技术面试中面试官最痛恨的就是背答案这个事情了。<br>学完这个题库，把此题库都理解透彻应对各家企业面试完全没有问题。（当然，要加上好的<br>项目以及透彻掌握）<br>另外，此面试题库中不包括面试中问到的项目，hr 面以及个人技术发展类。<br> 项目是比较个性化的，没办法作为一个题库来给大家参考，但是如果你有一个非常有含<br>金量的项目的话，是非常加分的，而且你的项目可能也会被问的多一些；<br> hr 面的话一般来说技术面通过的话个人没有太大的和公司不符合的问题都能通过；<br> 技术发展类的话这个就完全看自己啦，主要考察的会是你对技术的热爱和学习能力，比<br>如会问一些你是如何学习 xxx 技术的，或者能表达出你对技术的热爱的地方等等。此处<br>不做赘述。<br>那么抛开这些，Java 工程师中技术面中考察的占比如下：<br>需要注意的是：此图不绝对，因为实际面试中面试官会根据你的简历去问，比如你的项目多<br>NOWCODER.COM<br>可能就问的项目多一些，或者你说哪里精通可能面试官就多去问你这些。而且此图是根据题<br>库数据整理出来，并不是根据实际单场面试整理，比如基础部分不会考那么多，会从中抽着<br>考<br>但是面试中必考的点且占比非常大的有 Java 基础和算法。<br>决定你是否能拿 sp offer（高薪 offer）以及是否进名企的是项目和算法。<br>可以看出，算法除了是面试必过门槛以外，更是决定你是否能进名企或高薪 offer 的决定性<br>因素。<br>另外关于算法部分，想要系统的学习算法思想，实现高频面试题最优解等详细讲解的话可以<br>报名算法名企校招冲刺班或算法高薪校招冲刺班，你将能学到更先进的算法思想以及又一套<br>系统的校招高频题目的解题套路和方法论。<br>多出来的服务如下：<br>NOWCODER.COM<br>如果有什么问题，也可以加 qq 咨询 1440073724，如果是早鸟的话，还可以领取早鸟优惠哦<br>二、面试技巧<br>面试一般分为技术面和 hr 面，形式的话很少有群面，少部分企业可能会有一个交叉面，不<br>过总的来说，技术面基本就是考察你的专业技术水平的，hr 面的话主要是看这个人的综合<br>素质以及家庭情况符不符合公司要求，一般来讲，技术的话只要通过了技术面 hr 面基本上<br>是没有问题（也有少数企业 hr 面会刷很多人）<br>那我们主要来说技术面，技术面的话主要是考察专业技术知识和水平，我们是可以有一定的<br>技巧的，但是一定是基于有一定的能力水平的。<br>所以也慎重的告诉大家，技巧不是投机取巧，是起到辅助效果的，技术面最主要的还是要有<br>实力，这里是基于实力水平之上的技巧。<br>这里告诉大家面试中的几个技巧：<br>1、简历上做一个引导：<br>在词汇上做好区分，比如熟悉 Java，了解 python，精通 c 语言<br>这样的话对自己的掌握程度有个区分，也好让面试官有个着重去问，python 本来写的也只<br>是了解，自然就不会多问你深入的一些东西了。<br>2、在面试过程中做一个引导：<br>面试过程中尽量引导到自己熟知的一个领域，比如问到你说一下 DNS 寻址，然后你简单回<br>答（甚至这步也可以省略）之后，可以说一句，自己对这块可能不是特别熟悉，对计算机网<br>络中的运输层比较熟悉，如果有具体的，甚至可以再加一句，比如 TCP 和 UDP<br>这样的话你可以把整个面试过程往你熟知的地方引导，也能更倾向于体现出你的优势而不是<br>劣势，但是此方法仅限于掌握合适的度，比如有的知识点是必会的而你想往别处引就有点说<br>不过去了，比如让你说几个 Java 的关键字，你一个也说不上来，那可能就真的没辙了。<br>3、在自我介绍中做一个引导：<br>一般面试的开头都会有一个自我介绍，在这个位置你也可以尽情的为自己的优势方面去引导。<br>4、面试过程中展示出自信：<br>面试过程中的态度也要掌握好，不要自卑，也不要傲娇，自信的回答出每个问题，尤其遇到<br>不会的问题，要么做一些引导，实在不能引导也可以先打打擦边球，和面试官交流一下问题，<br>看起来像是没听懂题意，这个过程也可以再自己思考一下，如果觉得这个过程可以免了的话<br>也直接表明一下这个地方不太熟悉或者还没有掌握好，千万不要强行回答。<br>面试前的准备：<br>NOWCODER.COM<br>最重要的肯定是系统的学习了，有一个知识的框架，基础知识的牢靠程度等。<br>其中算法尤其重要，越来越多公司还会让你现场或者视频面试中手写代码；<br>另一大重要的和加分项就是项目，在面试前，一定要练习回答自己项目的三个问题：<br> 这是一个怎样的项目<br> 用到了什么技术，为什么用这项技术（以及每项技术很细的点以及扩展）<br> 过程中遇到了什么问题，怎么解决的。<br>那么话说回来，这个的前提是你要有一个好的项目，牛客网 CEO 叶向宇有带大家做项目，<br>感兴趣的可以去了解一下<br> 竞争力超过 70%求职者的项目：<br>（专属优惠码：DjPgy3x，每期限量前 100 个）<br> 竞争力超过 80%求职者的项目：<br>（专属优惠码：DMVSexJ，每期限量前 100 个）<br>知识都掌握好后，剩下的就是一个心态和模拟练习啦，因为你面试的少的话现场难免紧张，<br>而且没在那个环境下可能永远不知道自己回答的怎么样。<br>因为哪怕当你都会了的情况下，你的表达和心态就显得更重要了，会了但是没有表达的很清<br>晰就很吃亏了，牛客网这边有 AI 模拟面试，完全模拟了真实面试环境，正好大家可以真正<br>的去练习一下，还能收获一份面试报告：<br>面试后需要做的：<br>面试完了的话就不用太在意结果了，有限的时间就应该做事半功倍的事情，当然，要保持电<br>话邮箱畅通，不然别给你发 offer 你都不知道。<br>抛开这些，我们需要做的是及时将面试中的问题记录下来，尤其是自己回答的不够好的问题，<br>一定要花时间去研究，并解决这些问题，下次面试再遇到相同的问题就能很好的解决，当然，<br>即使不遇到，你这个习惯坚持住，后面也可以作为一个经历去跟面试官说，能表现出你对技<br>术的喜爱和钻研的一个态度，同时，每次面试后你会发现自己的不足，查缺补漏的好机会，<br>及时调整，在不断的调整和查缺补漏的过程中，你会越来越好。 三、面试考点导图<br>NOWCODER.COM<br>NOWCODER.COM<br>四、一对一答疑讲解戳这里<br>如果你对校招求职或者职业发展很困惑，欢迎与牛客网专业老师沟通，老师会帮你一对一讲<br>解答疑哦（可以扫下方二维码或者添加微信号：niukewang985）<br>NOWCODER.COM<br>目录<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>②关键字<br>③面向对象<br>④集合部分<br>2、Java 高级知识<br>①线程<br>②锁<br>③JDK<br>④反射<br>⑤JVM<br>⑥GC<br>⑦ IO 和 NIO，AIO<br>二、JavaEE 部分<br>1、Spring<br>①IoC 与 Bean 配置、管理<br>②AOP 与事务、权限控制<br>③S2SH 整合开发<br>④Spring，JPA 整合<br>2、Hibernate<br>①ORM 与持久化映射<br>②延迟加载、性能优化<br>③HQL 查询、条件查询、SQL 查询<br>④二级缓存与查询缓存<br>3、Struts<br>①MVC 模式与 Struts 体系<br>4、mybatis<br>5、MVC 框架<br>6、各框架对比与项目优化<br>7、JPA<br>①EJB<br>三、Java web 开发核心内容<br>1、web 编程基础<br>①Tomcat 服务器<br>NOWCODER.COM<br>②JSP 语法，EL，内置对象<br>③Listener 和 filter<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>②redis<br>③MVC 和 DAO<br>④JSTL、DisplayTag 等常见标签库的用法<br>3、Web 编程原理<br>① HTTP 协议<br>②请求&#x2F;相应架构原理<br>③web 容器<br>四、JDBC 编程<br>1、SQL 基础<br>2、JDBC 基础<br>①数据库<br>②数据库连接池<br>③事物管理，批处理<br>3、JDBC 进阶<br>五、XML 编程<br>1、XML 基础<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>六、计算机网络<br>1、网络概述<br>①关于分层<br>2、运输层<br>①TCP 与 UDP<br>②协议<br>3、网络层<br>①网际协议 IP<br>②网际控制报文协议 ICMP<br>③因特网的路由器选择协议<br>4、应用层<br>①域名系统 DNS<br>②电子邮件<br>NOWCODER.COM<br>七、操作系统<br>1、操作系统概论<br>2、进程的描述与控制<br>3、输入输出系统<br>4、存储器管理<br>5、处理机调度与死锁<br>八、算法与数据结构<br>1、哈希<br>2、树<br>3、遍历<br>4、链表<br>5、数组<br>6、排序<br>7、堆与栈<br>8、队列<br>9、高级算法<br>九、设计模式<br>1、结构型模式<br>①代理模式<br>②装饰模式<br>③适配器模式<br>2、创建型模式<br>①单例模式<br>3、行为型模式<br>①策略模式<br>②观察者模式<br>4、所有模式汇总<br>十、场景题<br>十一、UML<br>更多名企历年笔试真题可点击直接进行练习：<br>NOWCODER.COM<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>1、为什么重写 equals 还要重写 hashcode？<br>考点：java 基础<br>参考回答：<br>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()<br>方法继承于 Object 类，其 hashcode 码为默认的内存地址，这样即便有相同含义的两个对象，比<br>较也是不相等的。HashMap 中的比较 key 是这样的，先求出 key 的 hashcode(),比较其值是否相<br>等，若相等再比较 equals(),若相等则认为他们是相等的。若 equals()不相等则认为他们不相等。<br>如果只重写 hashcode()不重写 equals()方法，当比较 equals()时只是看他们是否为同一对象（即<br>进行内存地址的比较）,所以必定要两个方法一起重写。HashMap 用来判断 key 是否相等的方法，<br>其实是调用了 HashSet 判断加入元素 是否相等。重载 hashCode()是为了对同一个 key，能得到<br>相同的 Hash Code，这样 HashMap 就可以定位到我们指定的 key 上。重载 equals()是为了向<br>HashMap 表明当前对象和 key 上所保存的对象是相等的，这样我们才真正地获得了这个 key 所对<br>应的这个键值对。<br>2、说一下 map 的分类和常见的情况<br>考点：java 基础<br>参考回答：<br>java 为数据结构中的映射定义了一个接口 java.util.Map;它有四个实现类,分别是 HashMap<br>Hashtable LinkedHashMap 和 TreeMap.<br>Map 主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重<br>复。<br>Hashmap 是一个最常用的 Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的<br>值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap 最多只允许一条<br>记录的键为 Null;允许多条记录的值为 Null;HashMap 不支持线程的同步，即任一时刻可以有多<br>个线程同时写 HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections 的<br>synchronizedMap 方法使 HashMap 具有同步的能力，或者使用 ConcurrentHashMap。<br>Hashtable 与 HashMap 类似,它继承自 Dictionary 类，不同的是:它不允许记录的键或者值<br>为空;它支持线程的同步，即任一时刻只有一个线程能写 Hashtable,因此也导致了 Hashtable<br>在写入时会比较慢。<br>NOWCODER.COM<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排<br>序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，<br>遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和<br>容量无关，而 HashMap 的遍历速度和他的容量有关。<br>TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>一般情况下，我们用的最多的是 HashMap,在 Map 中插入、删除和定位元素，HashMap 是最<br>好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。如果需要输出的<br>顺序和输入的相同,那么用 LinkedHashMap 可以实现,它还可以按读取顺序来排列.<br>HashMap 是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的<br>值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。<br>HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的<br>不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的<br>能力。<br>Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，<br>即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。<br>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的<br>记录肯定是先插入的。<br>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，<br>也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？<br>考点：基础<br>参考回答：<br>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回<br>对象的 内存地址。<br>4、&#x3D;&#x3D;比较的是什么？<br>考点：基础<br>参考回答：<br>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，<br>“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。<br>NOWCODER.COM<br>5、若对一个类不重写，它的 equals()方法是如何比较的？<br>考点：基础<br>参考回答：<br>比较是对象的地址。<br>6、java8 新特性<br>考察点：java8<br>参考回答：<br>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。<br>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）<br>的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。<br>新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。<br>Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到<br>Java 中。<br>Date Time API − 加强对日期与时间的处理。<br>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许<br>我们在 JVM 上运行特定的 javascript 应用。<br>7、说说 Lamda 表达式的优缺点。<br>考察点：Java 基础<br>参考回答：<br>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。<br>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时<br>需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码<br>不容易让其他语言的程序员看懂。<br>8、一个十进制的数在内存中是怎么存的？<br>考察点：计算机基础<br>NOWCODER.COM<br>参考回答：<br>补码的形式。<br>9、为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？<br>考察点：计算机基础<br>参考回答：<br>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小<br>数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。<br>10、Java 支持的数据类型有哪些？什么是自动拆装箱？<br>考察点：JAVA 数据类型<br>参考回答：<br>Java 语言支持的 8 种基本数据类型是：<br>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：<br>把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。<br>11、什么是值传递和引用传递？<br>考察点：JAVA 引用传递<br>参考回答：<br>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。<br>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递. 12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不<br>是 ArrayList？<br>考察点：Array<br>NOWCODER.COM<br>参考回答：<br>Array 和 ArrayList 的不同点：<br>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。<br>Array 大小是固定的，ArrayList 的大小是动态变化的。<br>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类<br>型的时候，这种方式相对比较慢。<br>13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？<br>考察点：JAVA notation<br>参考回答：<br>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下<br>有多么好。<br>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般<br>使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一<br>个很好的说明。<br>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。<br>其函数表示是：<br>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));<br>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。<br>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使<br>用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好<br>的说明。<br>14、String 是最基本的数据类型吗?<br>考察点：数据类型<br>参考回答：<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效<br>率节省空间，我们应该用 StringBuffer 类。<br>15、int 和 Integer 有什么区别<br>考察点：数据类型<br>NOWCODER.COM<br>参考回答：<br>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据<br>类型，Integer 是 java 为 int 提供的封装类。<br>Java 为每个原始类型提供了封装类。<br>原始类型封装类<br>booleanBoolean<br>charCharacter<br>byteByte<br>shortShort<br>intInteger<br>longLong<br>floatFloat<br>doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同<br>的特征和用法，它们包括：大小和速<br>度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时<br>所指定的缺省值。对象引用实例变量<br>的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。<br>16、String 和 StringBuffer 的区别<br>考察点：数据类型<br>参考回答：<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多<br>个字符的字符数据。这个 String 类提供了<br>数值不可改变的字符串。而这个 StringBuffer 类提供的字符串进行修改。当你知道字符数据要<br>改变的时候你就可以使用 StringBuffer 。典型地，你可以使用 StringBuffers 来动态构造字符数据。<br>17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1<br>等，如何输出一个某种编码的字符串？<br>考察点：数据类型<br>参考回答：<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1″), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>NOWCODER.COM<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>18、int 和 Integer 有什么区别？<br>考察点：数据类型<br>参考回答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，<br>但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的<br>包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱<br>机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：* 原始类型: boolean，char，byte，short，int，long，float，double</li></ol><ul><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<br>如：<br>class AutoUnboxingTest {<br>public static void main(String[] args) {<br>Integer a &#x3D; new Integer(3);<br>Integer b &#x3D; 3; &#x2F;&#x2F; 将 3 自动装箱成 Integer 类型<br>int c &#x3D; 3;<br>System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false 两个引用没有引用同一对象<br>System.out.println(a &#x3D;&#x3D; c); &#x2F;&#x2F; true a 自动拆箱成 int 类型再和 c 比较<br>}<br>}<br>19、&amp;和&amp;&amp;的区别？<br>考察点：运算符<br>参考回答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的<br>差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是<br>NOWCODER.COM<br>true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直<br>接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定<br>用户名不是 null 而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，<br>二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的<br>equals 比较，否则会产生 NullPointerException 异常。<br>20、在 Java 中，如何跳出当前的多重嵌套循环？<br>考察点：循环<br>参考回答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标<br>签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时<br>候甚至有相反的作用，所以这种语法其实不知道更好）<br>21、你能比较一下 Java 和 JavaSciprt 吗？<br>考察：Java&amp;JavaScript<br>参考回答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司<br>推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape<br>公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对<br>象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：</li><li>基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设<br>计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软<br>件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身<br>提供了非常丰富的内部对象供设计人员使用。</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，<br>其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技<br>术来提升 JavaScript 的运行效率）</li><li>强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；<br>JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行<br>时检查推断其数据类型。</li><li>代码格式不一样。<br>22、简述正则表达式及其用途。<br>考察点：正则表达式<br>参考回答：<br>NOWCODER.COM<br>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式<br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的<br>信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大<br>的工具，绝大多数语言都提供了对正则表达式的支持。<br>23、Java 中是如何支持正则表达式操作的？<br>考察点：正则表达式<br>参考回答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、<br>replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰<br>富的 API 进行各种正则表达式操作，如：<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;<br>class RegExpTest {<br>public static void main(String[] args) {<br>String str &#x3D; “成都市(成华区)(武侯区)(高新区)”;<br>Pattern p &#x3D; Pattern.compile(“.*?(?&#x3D;\()”);<br>Matcher m &#x3D; p.matcher(str);<br>if(m.find()) {<br>System.out.println(m.group());<br>}<br>}<br>}<br>24、请你说说 Java 和 PHP 的区别？<br>考察点：Java 特性<br>参考回答：<br>PHP 暂时还不支持像 Java 那样 JIT 运行时编译热点代码,但是 PHP 具有 opcache 机制,能够<br>把脚本对应的 opcode 缓存在内存,PHP7 中还支持配置 opcache.file_cache 导出 opcode 到文件. 第三方的 Facebook HHVM 也支持 JIT.另外 PHP 官方基于 LLVM 围绕 opcache 机制构建的 Zend JIT<br>分支也正在开发测试中.在 php-src&#x2F;Zend&#x2F;bench.php 测试显示,PHP JIT 分支速度是 PHP 5.4 的<br>10 倍.<br>PHP 的库函数用 C 实现,而 Java 核心运行时类库(jdk&#x2F;jre&#x2F;lib&#x2F;rt.jar,大于 60MB)用 Java 编写<br>(jdk&#x2F;src.zip), 所以 Java 应用运行的时候,用户编写的代码以及引用的类库和框架都要在 JVM<br>上解释执行. Java 的 HotSpot 机制,直到有方法被执行 10000 次才会触发 JIT 编译, 在此之前运<br>行在解释模式下,以避免出现 JIT 编译花费的时间比方法解释执行消耗的时间还要多的情况.<br>PHP 内置模板引擎,自身就是模板语言.而 Java Web 需要使用 JSP 容器如 Tomcat 或第三方模<br>板引擎.<br>NOWCODER.COM<br>PHP 也可以运行在多线程模式下,比如 Apache 的 event MPM 和 Facebook 的 HHVM 都是多线程<br>架构.不管是多进程还是多线程的 PHP Web 运行模式,都不需要 PHP 开发者关心和控制,也就是说<br>PHP 开发者不需要写代码参与进程和线程的管理,这些都由 PHP-FPM&#x2F;HHVM&#x2F;Apache 实现.PHP-FPM<br>进程管理和并发实现并不需要 PHP 开发者关心,而 Java 多线程编程需要 Java 开发者编码参<br>与.PHP 一个 worker 进程崩溃,master 进程会自动新建一个新的 worker 进程,并不会导致 PHP 服<br>务崩溃.而 Java 多线程编程稍有不慎(比如没有捕获异常)就会导致 JVM 崩溃退出.对于 PHP-FPM<br>和 Apache MOD_PHP 来说,服务进程常驻内存,但一次请求释放一次资源,这种内存释放非常彻底.<br>PHP 基于引用计数的 GC 甚至都还没发挥作用程序就已经结束了。 ②关键字<br>1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什<br>么？如果修饰成员方法，锁住了什么？<br>考点：java 关键字<br>参考回答：<br>synchronized 修饰静态方法以及同步代码块的 synchronized (类.class)用法锁的是类，线<br>程想要执行对应同步代码，需要获得类锁。<br>synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。<br>2、介绍一下 volatile？<br>考察点：java 关键字<br>参考回答：<br>volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。比如我们所写的<br>代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，<br>这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高 CPU 的执行效<br>率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有<br>happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面<br>对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先 Java 内存模<br>型分为，主内存，工作内存。比如线程 A 从主内存把变量从主内存读到了自己的工作内存中，做<br>了加 1 的操作，但是此时没有将 i 的最新值刷新会主内存中，线程 B 此时读到的还是 i 的旧值。<br>加了 volatile 关键字的代码生成的汇编代码发现，会多出一个 lock 前缀指令。Lock 指令对 Intel<br>平台的 CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多<br>核之间数据不一致性问题。<br>3、锁有了解嘛，说一下 Synchronized 和 lock<br>考察点：java 关键字<br>NOWCODER.COM<br>参考回答：<br>synchronized 是 Java 的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证<br>在同一时刻最多只有一个线程执行该段代码。JDK1.5 以后引入了自旋锁、锁粗化、轻量级锁，<br>偏向锁来有优化关键字的性能。<br>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；<br>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock<br>在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock<br>时需要在 finally 块中释放锁；Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，<br>使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没<br>有成功获取锁，而 synchronized 却无法办到。<br>4、讲一讲 Java 里面的 final 关键字怎么用的？<br>考察点：关键字<br>参考回答：<br>当用 final 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他<br>被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注<br>意 final 类中的所有成员方法都会被隐式地指定为 final 方法。<br>“使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；<br>第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法<br>过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final<br>方法进行这些优化了。“<br>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；<br>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 ③面向对象<br>1、wait 方法底层原理<br>考察点：基础<br>参考回答：<br>ObjectSynchronizer::wait 方法通过 object 的对象中找到 ObjectMonitor 对象调用方法<br>void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)<br>通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队<br>列的末尾中然后在 ObjectMonitor::exit 释放锁，接着 thread_ParkEvent-&gt;park 也就是 wait。<br>NOWCODER.COM<br>2、Java 有哪些特性，举个多态的例子。<br>考察点：语言特性<br>参考回答：<br>封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据<br>发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）<br>3、String 为啥不可变？<br>考察点：面向对象<br>参考回答：<br>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不<br>能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对<br>象，引用类型指向的对象的状态也不能改变。<br>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字<br>节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以<br>在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串<br>是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得<br>数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不<br>可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安<br>全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，<br>这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的<br>所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计<br>算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是<br>HashMap 中的键往往都使用字符串的原因。<br>4、类和对象的区别<br>考察点：面向对象<br>参考回答：<br>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。<br>比如：“人”是一个类，而“教师”则是“人”的一个实例。<br>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性<br>的对象集合体。<br>5、请列举你所知道的 Object 类的方法。<br>考察点：面向对象<br>NOWCODER.COM<br>参考回答：<br>Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指<br>示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引<br>用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回<br>该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此<br>对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等<br>待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导<br>致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超<br>过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此<br>对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某<br>个实际时间量。<br>6、重载和重写的区别？相同参数不同返回值能重载吗？<br>考察点：重载<br>参考回答：<br>重载(Overloading)<br>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，<br>具有不同的参数个数&#x2F;类型。<br>重载 Overloading 是一个类中多态性的一种表现。<br>（2） Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同<br>的参数和不同的定义。<br>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是<br>多态性。<br>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可<br>以不相同。无法以返回型别作为重载函数的区分标准。<br>重写（Overriding）<br>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与<br>其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类<br>中的方法，而不需要重新编写相同的方法。<br>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的<br>重写。<br>方法重写又称方法覆盖。<br>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法<br>将覆盖原有的方法。<br>如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。<br>NOWCODER.COM<br>（3）子类函数的访问修饰权限不能少于父类的。<br>7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private<br>或者是 static 的方法？<br>考察点：static 变量<br>参考回答：<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情<br>况下被访问。<br>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编<br>译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。<br>8、String 能继承吗？<br>考察点：String<br>参考回答：<br>不能，char 数组用 final 修饰的。<br>9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？<br>考察点：类<br>参考回答：<br>StringBuffer 线程安全，StringBuilder 线程不安全，底层实现上的话，StringBuffer 其<br>实就是比 StringBuilder 多了 Synchronized 修饰符。<br>10、类加载机制，双亲委派模型，好处是什么？<br>考察点：类<br>参考回答：<br>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，<br>如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才<br>自己去加载。<br>使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次<br>关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最<br>终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各<br>种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的<br>话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现<br>NOWCODER.COM<br>多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的<br>Java 类，可以正常编译，但是永远无法被加载运行。<br>11、静态变量存在哪?<br>考察点：类<br>参考回答：<br>方法区<br>12、讲讲什么是泛型？<br>考察点：JAVA 泛型<br>参考回答：<br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法<br>时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，<br>类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;<br>调用时传入具体的类型（类型实参）。</li></ul><p>采用泛型写法后，在&#x2F;&#x2F;1 处想加入一个 Integer 类型的对象时会出现编译错误，通过<br>List&lt;String&gt;，直接限定了 list 集合中只能含有 String 类型的元素，从而在&#x2F;&#x2F;2 处无须进行强<br>制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是 String 类型<br>了。<br>13、解释 extends 和 super 泛型限定符-上界不存下界不取<br>考察点：JAVA 泛型<br>参考回答：<br>（1）泛型中上界和下界的定义<br>上界 &lt;? extend Fruit&gt;<br>下界 &lt;? super Apple&gt;<br>（2）上界和下界的特点<br>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）<br>下界的 list 只能 add，不能 get<br>（3）示例代码</p><p>（4）上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确<br>定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，<br>不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把<br>所有的子类向上转型为 Fruit。<br>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。<br>那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父<br>类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple<br>及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接<br>着呢，除了 Object，其他的都接不住。<br>NOWCODER.COM<br>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。<br>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引<br>用就必须得用 cast。<br>14、是否可以在 static 环境中访问非 static 变量？<br>考察点：static 变量<br>参考回答：<br>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机<br>载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，<br>编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。<br>15、谈谈如何通过反射创建对象？<br>考察点：类<br>参考回答：</p><ul><li>方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()</li><li>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器<br>（Constructor）对象并调用其 newInstance()方法创建对象，例如：<br>String.class.getConstructor(String.class).newInstance(“Hello”);<br>16、Java 支持多继承么？<br>考察点：JAVA 多继承<br>参考回答：<br>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口<br>支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子<br>接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。<br>17、接口和抽象类的区别是什么？<br>考察点：抽象类<br>参考回答：<br>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：<br>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象<br>的。<br>NOWCODER.COM<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。<br>Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者<br>是 public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main 方法<br>的话是可以被调用的。<br>也可以参考 JDK8 中抽象类和接口的区别<br>18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。<br>考察点：comparable 接口<br>参考回答：<br>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象<br>排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两<br>个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()<br>方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也<br>是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回<br>true。</li></ul><p>23、Static Nested Class 和 Inner Class 的不同<br>考察点：声明<br>参考回答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被<br>实例化。而通常的内部类需要在外部类实<br>例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义<br>为动态的(instance).Nested Class 的静态成员(Method)只能对 Outer Class 的静态成员(static<br>memebr)进行操作(ACCESS), 而不能 Access Outer Class 的动态成员(instance member).而<br>Nested Class 的动态成员(instance method) 却可以 Access Outer Class 的所有成员, 这个概<br>念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而 动<br>态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)<br>永远不可以 Access 跟 object 相关的动态成员(instance member),反过来就可以, 一个 CLASS<br>的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，<br>并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>考察点：对象<br>参考回答：<br>是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中<br>时，参数的值就是对该对象的引用。对象<br>的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。<br>25、Java 的接口和 C++的虚类的相同和不同处。<br>考察点：接口<br>参考回答：<br>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或<br>属性，现有的单继承机制就不能满足要求。<br>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，<br>该类要实现接口里面所有的方法和属<br>NOWCODER.COM<br>性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。<br>26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally<br>分别代表什么意义？在 try 块中可以抛出异常吗？<br>考察点：异常<br>参考回答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接<br>口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个<br>异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个<br>异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br>用 try 来指定一块预防所有”异常”的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指<br>定你想要捕捉的”异常”的类型。throw 语句用来明确地抛出一个”异常”。throws 用来标明一<br>个成员函数可能抛出的各种”异常”。Finally 为确保一段代码不管发生什么”异常”都被执行<br>一段代码。可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try<br>语句保护其他代码。每当遇到一个 try 语句，”异常“的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有<br>处理这种”异常”的 try 语句。<br>27、内部类可以引用他包含类的成员吗？有没有什么限制？<br>考察点：类<br>参考回答：<br>一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是 static 的，那么它<br>可以访问创建它的外部类对象的所有属性内部类如果是 sattic 的，即为 nested class，那么它<br>只可以访问创建它的外部类对象的所有 static 属性一般普通类只有 public 或 package 的访问修<br>饰，而内部类可以实现 static，protected，private 等访问修饰。当从外部类继承的时候，内<br>部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明<br>确地继承，就可以覆盖原来内部类的方法。<br>28、两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code 说法<br>是否正确？<br>考察点：对象<br>参考回答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当<br>相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals<br>方法返回 true），那么它们的 hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它<br>NOWCODER.COM<br>们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容<br>器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存<br>储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>30、如何通过反射获取和设置对象私有字段的值？<br>考察点：类<br>参考回答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段对象的<br>setAccessible(true)将其设置为可以访问，接下来就可以通过 get&#x2F;set 方法来获取&#x2F;设置字段的<br>值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段<br>的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如<br>ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得 dog 对象的主人的汽车的引擎的<br>ID 号。31、谈一下面向对象的”六原则一法则”。<br>考察点：Java 对象<br>参考回答：<br>NOWCODER.COM</p><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写<br>代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功<br>能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内<br>聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到<br>变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶<br>皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到<br>其他系统中使用的，这样才能实现软件复用的目标。）- 开闭原则：软件实体应当对扩展开放，<br>对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系<br>统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是<br>关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可<br>变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不<br>清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- 依赖倒<br>转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类<br>型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一<br>个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换<br>掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简<br>单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，<br>如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。<br>例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容<br>易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的<br>能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示<br>能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分<br>别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方<br>法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会<br>几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、<br>代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- 合成聚合复用<br>原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用<br>得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之<br>间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其<br>中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A<br>关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可<br>以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例<br>子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错<br>误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置<br>为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。<br>记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- 迪<br>米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂<br>的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter<br>不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的<br>请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内<br>存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到<br>一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设<br>备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。<br>NOWCODER.COM<br>32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？<br>考察点：接口<br>参考回答：<br>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的<br>前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使<br>用 iterate()方法可以减少性能开销。<br>② list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题<br>33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？<br>考察点：方法<br>参考回答：<br>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的<br>情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参<br>数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。<br>34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？<br>考察点：JAVA 构造函数<br>参考回答：<br>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提<br>供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。<br>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必<br>须有它自己唯一的参数列表。<br>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，<br>Java 不会创建默认的复制构造函数。<br>35、hashCode()和 equals()方法有什么联系？<br>考点：基础<br>参考回答：<br>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<br>➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>➁ 如果两个对象的 hashCode 相同，它们并不一定相同。<br>NOWCODER.COM<br>④集合部分<br>1、Map 和 ConcurrentHashMap 的区别？<br>考点：集合<br>参考回答：<br>hashmap 是线程不安全的，put 时在多线程情况下，会形成环从而导致死循环。<br>CoucurrentHashMap 是线程安全的，采用分段锁机制，减少锁的粒度。<br>2、hashMap 内部具体如何实现的？<br>考点：集合<br>参考回答：<br>Hashmap 基于数组实现的，通过对 key 的 hashcode &amp; 数组的长度得到在数组中位置，如当<br>前数组有元素，则数组当前元素 next 指向要插入的元素，这样来解决 hash 冲突的，形成了拉链<br>式的结构。put 时在多线程情况下，会形成环从而导致死循环。数组长度一般是 2n，从 0 开始编<br>号，所以 hashcode &amp; （2n-1），（2n-1）每一位都是 1，这样会让散列均匀。需要注意的是，<br>HashMap 在 JDK1.8 的版本中引入了红黑树结构做优化，当链表元素个数大于等于 8 时，链表转<br>换成树结构；若桶中链表元素个数小于等于 6 时，树结构还原成链表。因为红黑树的平均查找长<br>度是 log(n)，长度为 8 的时候，平均查找长度为 3，如果继续使用链表，平均查找长度为 8&#x2F;2&#x3D;4，<br>这才有转换为树的必要。链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，虽然速度也很快的，但是转化为<br>树结构和生成树的时间并不会太短。还有选择 6 和 8，中间有个差值 7 可以有效防止链表和树频<br>繁转换。假设一下，如果设计成链表个数超过 8 则链表转换成树结构，链表个数小于 8 则树结构<br>转换成链表，如果一个 HashMap 不停的插入、删除元素，链表个数在 8 左右徘徊，就会频繁的发<br>生树转链表、链表转树，效率会很低。<br>3、如果 hashMap 的 key 是一个自定义的类，怎么办？<br>考点：集合<br>参考回答：<br>使用 HashMap，如果 key 是自定义的类，就必须重写 hashcode()和 equals()。<br>4、ArrayList 和 LinkedList 的区别，如果一直在 list 的尾部添加元素，用哪<br>个效率高？<br>考点：集合<br>参考回答：<br>NOWCODER.COM<br>ArrayList 采用数组数组实现的，查找效率比 LinkedList 高。LinkedList 采用双向链表实<br>现的，插入和删除的效率比 ArrayList 要高。一直在 list 的尾部添加元素，LinkedList 效率要<br>高。<br>5、HashMap 底层，负载因子，为啥是 2^n？<br>考点：集合<br>参考回答：<br>负载因子默认是 0.75， 2^n 是为了让散列更加均匀，例如出现极端情况都散列在数组中的<br>一个下标，那么 hashmap 会由 O（1）复杂退化为 O（n）的。<br>6、ConcurrentHashMap 锁加在了哪些地方？<br>考点：集合<br>参考回答：<br>加在每个 Segment 上面。<br>7、TreeMap 底层，红黑树原理？<br>考点：集合<br>参考回答：<br>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证<br>当需要快速检索指定节点。<br>红黑树的插入、删除、遍历时间复杂度都为 O(lgN)，所以性能上低于哈希表。但是哈希表<br>无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑<br>树性质：<br>性质 1：每个节点要么是红色，要么是黑色。<br>性质 2：根节点永远是黑色的。<br>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。<br>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续<br>的红色节点）<br>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。<br>8、concurrenthashmap 有啥优势，1.7，1.8 区别？<br>NOWCODER.COM<br>考点：集合<br>参考回答：<br>Concurrenthashmap 线程安全的，1.7 是在 jdk1.7 中采用 Segment + HashEntry 的方式进<br>行实现的，lock 加在 Segment 上面。1.7size 计算是先采用不加锁的方式，连续计算元素的个数，<br>最多计算 3 次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果<br>前后两次计算结果都不同，则给每个 Segment 进行加锁，再计算一次元素的个数；<br>1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node + CAS + Synchronized 来<br>保证并发安全进行实现，1.8 中使用一个 volatile 类型的变量 baseCount 记录元素的个数，当<br>插入新数据或则删除数据时，会通过 addCount()方法更新 baseCount，通过累加 baseCount 和<br>CounterCell 数组中的数量，即可得到元素的总个数；<br>9、ArrayList 是否会越界？<br>考点：集合<br>参考回答：<br>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构 2. 对<br>于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList<br>并发 add()可能出现数组下标越界异常<br>10、什么是 TreeMap?<br>考察点：key-value 集合<br>参考回答：<br>TreeMap 是一个有序的 key-value 集合，基于红黑树（Red-Black tree）的 NavigableMap<br>实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，<br>具体取决于使用的构造方法。<br>TreeMap 的特性：<br>根节点是黑色<br>每个节点都只能是红色或者黑色<br>每个叶节点（NIL 节点，空节点）是黑色的。<br>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个<br>红色的节点。<br>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>NOWCODER.COM<br>11、ConcurrentHashMap 的原理是什么？<br>考察点：JAVA 内存模型<br>参考回答：<br>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封<br>装映射表的键 &#x2F; 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的<br>若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例<br>中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在<br>HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。<br>static final class HashEntry&lt;K,V&gt; {<br>final K key; &#x2F;&#x2F; 声明<br>key 为 final 型<br>final int hash; &#x2F;&#x2F; 声明 hash<br>值为 final 型<br>volatile V value; &#x2F;&#x2F; 声明 value 为<br>volatile 型<br>final HashEntry&lt;K,V&gt; next; &#x2F;&#x2F; 声明 next 为 final 型<br>HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) {<br>this.key &#x3D; key;<br>this.hash &#x3D; hash;<br>this.next &#x3D; next;<br>this.value &#x3D; value;<br>}<br>}<br>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰<br>撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，<br>所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry<br>对象后的结构图：<br>图 1. 插入三个节点后桶的结构示意图：<br>NOWCODER.COM<br>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。<br>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个<br>Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。<br>12、Java 集合类框架的基本接口有哪些？<br>考察点：JAVA 集合<br>参考回答：<br>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它<br>自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基<br>本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的 Collection。<br>List：有顺序的 collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。<br>13、为什么集合类没有实现 Cloneable 和 Serializable 接口？<br>考察点：JAVA 集合<br>参考回答：<br>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，<br>应该由集合类的具体实现来决定如何被克隆或者是序列化。<br>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创<br>建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果<br>你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应<br>用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化<br>14、什么是迭代器？<br>考察点：JAVA 迭代器<br>参考回答：<br>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接<br>口,<br>NOWCODER.COM<br>每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合<br>的元素进行迭代操作. 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出<br>ConcurrentModificationException<br>异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除. 15、Iterator 和 ListIterator 的区别是什么？<br>考察点：迭代器<br>参考回答：<br>Iterator 和 ListIterator 的区别是：<br>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。<br>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前<br>一个和后一个元素的索引，等等。<br>16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？<br>考察点：集合<br>参考回答：<br>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。<br>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的<br>类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全<br>失败的迭代器永远不会抛出这样的异常。<br>18、ArrayList 和 LinkedList 有什么区别？<br>考察点：ArrayList<br>参考回答：<br>NOWCODER.COM<br>ArrayList 和 LinkedList 都实现了 List 接口，他们有以下的不同点：<br>ArrayList 是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行随机<br>访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个<br>和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。<br>相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任<br>意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向<br>前一个元素，一个指向下一个元素。<br>19、ArrayList,Vector,LinkedList 的存储性能和特性是什么？<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索<br>引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector<br>由于使用了 synchronized 方法（线程<br>安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据<br>需要进行前向或后向遍历，但是插入数<br>据时只需要记录本项的前后项即可，所以插入速度较快。<br>20、Collection 和 Collections 的区别。<br>考察点：集合<br>参考回答：<br>Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.<br>Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、<br>线程安全化等操作。<br>21、你所知道的集合类都有哪些？主要方法？<br>考察点：集合<br>参考回答：<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可<br>变大小的列表，比较适合构建、存储和操<br>作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其<br>中每个键映射到一个值。<br>22、List、Set、Map 是否继承自 Collection 接口？<br>NOWCODER.COM<br>考察点：collection 接口<br>参考回答：<br>List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set<br>存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，<br>适用于按数值索引访问元素的情形。<br>23、阐述 ArrayList、Vector、LinkedList 的存储性能和特性<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操<br>作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector<br>是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使<br>用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号<br>索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号<br>索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速<br>度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、<br>BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和<br>LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具<br>类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢<br>模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。<br>24、List、Map、Set 三个接口存取元素时，各有什么特点？<br>考察点：List<br>参考回答：<br>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals()<br>方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一<br>或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理<br>论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的<br>键（key）构成排序树从而达到排序和去重的效果。<br>NOWCODER.COM<br>2、Java 高级知识<br>①线程<br>1、多线程中的 i++线程安全吗？为什么？<br>考察点：多线程<br>参考回答：<br>不安全。i++不是原子性操作。i++分为读取 i 值，对 i 值加一，再赋值给 i++，执行期中任<br>何一步都是有可能被其他线程抢占的。<br>2、如何线程安全的实现一个计数器？<br>考察点：多线程<br>参考回答：<br>可以使用加锁，比如 synchronized 或者 lock。也可以使用 Concurrent 包下的原子类。<br>3、多线程同步的方法<br>考察点：多线程<br>参考回答：<br>可以使用 synchronized、lock、volatile 和 ThreadLocal 来实现同步。<br>4、介绍一下生产者消费者模式？<br>考察点：线程<br>参考回答：<br>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储<br>空间，生产者向空间里生产数据，而消费者取走数据。<br>优点：支持并发、解耦。<br>5、线程，进程，然后线程创建有很大开销，怎么优化？<br>NOWCODER.COM<br>考察点：多线程<br>参考回答：<br>可以使用线程池。<br>6、线程池运行流程，参数，策略<br>考察点：线程池<br>参考回答：<br>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线<br>程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列<br>满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝<br>策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。<br>7、讲一下 AQS 吧。<br>考察点：多线程<br>参考回答：<br>AQS 其实就是一个可以给我们实现锁的框架<br>内部实现的关键是：先进先出的队列、state 状态<br>定义了内部类 ConditionObject<br>拥有两种线程模式独占模式和共享模式。<br>在 LOCK 包中的相关锁(常用的有 ReentrantLock、 ReadWriteLock)都是基于 AQS 来构建，<br>一般我们叫 AQS 为同步器。<br>10、Java 中有几种线程池？<br>考察点：线程池<br>参考回答：<br>1、newFixedThreadPool 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一<br>个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>2、newCachedThreadPool 创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1<br>分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个<br>工作线程。<br>3、newSingleThreadExecutor 创建一个单线程化的 Executor，即只创建唯一的工作者线程<br>来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特<br>色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个<br>线程是活动的 。<br>4、newScheduleThreadPool 创建一个定长的线程池，而且支持定时的以及周期性的任务执<br>行，类似于 Timer。(这种线程池原理暂还没完全了解透彻)<br>11、线程池有什么好处？<br>考察点：线程池<br>参考回答：<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。<br>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。<br>参考回答：<br>所谓回调，就是客户程序 C 调用服务程序 S 中的某个方法 A，然后 S 又在某个时候反过来调<br>用 C 中的某个方法 B，对于 C 来说，这个 B 便叫做回调方法。<br>17、同步方法和同步代码块的区别是什么？<br>考察点：JAVA 代码块同步<br>参考回答：<br>区别：<br>同步方法默认用 this 或者当前类 class 对象作为锁；<br>NOWCODER.COM<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步<br>问题的部分代码而不是整个方法；<br>18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同<br>步？<br>考察点：JAVA 线程同步<br>参考回答：<br>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一<br>个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行<br>同步代码。<br>26、线程的 sleep()方法和 yield()方法有什么区别？<br>考察点：线程<br>参考回答：<br>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行<br>的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）<br>状态；<br>③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。<br>27、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进<br>入此对象的 synchronized 方法 B？<br>考察点：线程<br>参考回答：<br>NOWCODER.COM<br>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的<br>synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被<br>取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。<br>28、请说出与线程同步以及线程调度相关的方法。<br>考察点：线程同步<br>参考回答：* wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理<br>InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一<br>个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让<br>它们竞争，只有获得锁的线程才能进入就绪状态；<br>通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。<br>Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()<br>方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），<br>信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须<br>得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必<br>须向信号量归还许可（调用 Semaphore 对象的 release()方法）。<br>29、举例说明同步和异步<br>考察点：线程<br>参考回答：<br>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据<br>以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就<br>必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个<br>需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，<br>在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是<br>非阻塞式操作。<br>31、说说线程的基本状态以及状态之间的关系？<br>考察点：线程<br>参考回答：<br>其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表<br>示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait()方法进入等待池，也可能是执行<br>同步方法或同步代码块进入等锁池，或者是调用了 sleep()方法或 join()方法等待休眠或其他线<br>程结束，或是因为发生了 I&#x2F;O 中断。<br>1、Java 中的 LongAdder 和 AtomicLong 的区别<br>考点：JDK<br>参考回答：<br>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到<br>修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在<br>大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合<br>ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。<br>虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger<br>NOWCODER.COM<br>的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字<br>进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元<br>cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进<br>行了有效的分离，提高了并行度。<br>2、JDK 和 JRE 的区别是什么？<br>考察点：JDK<br>参考回答：<br>Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet<br>需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其<br>他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应用程序。 ④反射<br>1、反射的实现与作用<br>考察点：反射<br>参考回答；<br>JAVA 语言编译之后会生成一个.class 文件，反射就是通过字节码文件找到某一个类、类中<br>的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构<br>造方法，Field：类中的属性对象，Method：类中的方法对象。<br>作用：反射机制指的是程序在运行时能够获取自身的信息。在 JAVA 中，只要给定类的名字，<br>那么就可以通过反射机制来获取类的所有信息。 ⑤JVM</li></ul><p>5、JAVA 虚拟机的作用?<br>考察点：java 虚拟机<br>参考回答：<br>解释运行字节码程序 消除平台相关性。<br>NOWCODER.COM<br>jvm 将 java 字节码解释为具体平台的具体指令。一般的高级语言如要在不同的平台上运行，<br>至少需要编译成不同的目标代码。而引入 JVM 后，Java 语言在不同平台上运行时不需要重新编<br>译。Java 语言使用模式 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言编译程序只<br>需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java<br>虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<br>假设一个场景，要求 stop the world 时间非常短，你会怎么设计垃圾回收机制？<br>绝大多数新创建的对象分配在 Eden 区。<br>在 Eden 区发生一次 GC 后，存活的对象移到其中一个 Survivor 区。<br>在 Eden 区发生一次 GC 后，对象是存放到 Survivor 区，这个 Survivor 区已经存在其他存活<br>的对象。<br>一旦一个 Survivor 区已满，存活的对象移动到另外一个 Survivor 区。然后之前那个空间已<br>满 Survivor 区将置为空，没有任何数据。<br>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。<br>9、jvm 是如何实现线程？<br>考察点：JVM<br>参考回答：<br>NOWCODER.COM<br>线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开。<br>一个进程里可以启动多条线程，各个线程可共享该进程的资源(内存地址，文件 IO 等)，又可以<br>独立调度。线程是 CPU 调度的基本单位。<br>主流 OS 都提供线程实现。Java 语言提供对线程操作的同一 API，每个已经执行 start()，<br>且还未结束的 java.lang.Thread 类的实例，代表了一个线程。<br>Thread 类的关键方法，都声明为 Native。这意味着这个方法无法或没有使用平台无关的手<br>段来实现，也可能是为了执行效率。<br>实现线程的方式<br>A.使用内核线程实现内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核支持<br>的线程。<br>内核来完成线程切换<br>内核通过调度器 Scheduler 调度线程，并将线程的任务映射到各个 CPU 上<br>程序使用内核线程的高级接口，轻量级进程(Light Weight Process,LWP)<br>用户态和内核态切换消耗内核资源<br>使用用户线程实现<br>系统内核不能感知线程存在的实现<br>用户线程的建立、同步、销毁和调度完全在用户态中完成<br>所有线程操作需要用户程序自己处理，复杂度高<br>用户线程加轻量级进程混合实现<br>轻量级进程作为用户线程和内核线程之间的桥梁<br>10、jvm 最大内存限制多少<br>考察点：JVM<br>参考回答：<br>(1)堆内存分配<br>JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1&#x2F;64；JVM 最大分配的内存由-Xmx 指<br>定，默认是物理内存的 1&#x2F;4。默认空余堆内存小 于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；<br>空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。因此服务器一般设置-Xms、 -Xmx 相等以避免在每次 GC 后调整堆的大小。<br>(2)非堆内存分配<br>JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1&#x2F;64；由 XX:MaxPermSize<br>设置最大非堆内存的大小，默认是物理内存的 1&#x2F;4。<br>NOWCODER.COM<br>(3)VM 最大内存<br>首先 JVM 内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM 内存的最大值跟<br>操作系统有很大的关系。简单的说就 32 位处理器虽 然可控内存空间有 4GB,但是具体的操作系<br>统会给一个限制，这个限制一般是 2GB-3GB（一般来说 Windows 系统下为 1.5G-2G，Linux 系 统<br>下为 2G-3G），而 64bit 以上的处理器就不会有限制了。<br>(3)下面是当前比较流行的几个不同公司不同版本 JVM 最大堆内存:<br>11、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？<br>考察点：JVM<br>参考回答：<br>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚<br>拟机执行的字节码文件。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或<br>者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。<br>12、描述一下 JVM 加载 class 文件的原理机制?<br>考察点：JVM<br>参考回答：<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的<br>Java 运行时系统组件。它负责在运行时查找和装入类文件的类。<br>Java 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，<br>而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的<br>加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要<br>的类。<br>NOWCODER.COM<br>类装载方式，有两种<br>（1）隐式装载， 程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载<br>对应的类到 jvm 中，<br>（2）显式装载， 通过 class.forname()等方法，显式加载需要的类 , 隐式加载与显式加载的<br>区别：两者本质是一样的。<br>Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行<br>的基础类(像是基类)完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了<br>节省内存开销。 ⑥GC<br>1、java 中内存泄露是啥，什么时候出现内存泄露？<br>考察点：内存泄漏<br>参考回答：<br>Java 中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就<br>是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。<br>2、minor gc 如果运行的很频繁，可能是什么原因引起的，minor gc 如果运行的<br>很慢，可能是什么原因引起的?<br>考察点：GC<br>参考回答：<br>可能是堆内存太小。<br>3、阐述 GC 算法<br>考察点：JVM<br>参考回答：<br>①GC（GarbageCollection 垃圾收集），GC 的对象是堆空间和永久区<br>②GC 算法包含：引用计数法，标记清除，标记压缩，复制算法。<br>③引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用<br>计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A<br>就不可能再被使用。<br>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：<br>标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开<br>始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有<br>未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对<br>象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正<br>NOWCODER.COM<br>在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对<br>象，交换两个内存的角色，完成垃圾回收。<br>4、GC 是什么? 为什么要有 GC?<br>考察点：回收<br>参考回答：<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，<br>忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监<br>测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显<br>示操作方法。<br>5、垃圾回收的优点和原理。并考虑 2 种回收机制<br>考察点：垃圾回收<br>参考回答：<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的<br>问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回<br>收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以<br>有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的<br>线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，<br>程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃<br>圾回收和标记垃圾回收，增量垃圾回收。<br>6、java 中会存在内存泄漏吗，请简单描述。<br>考察点：内存<br>参考回答：<br>Java 中的确存在 Java 的内存泄漏, 并且事态可以变得相当严重<br>Java garbage collector 自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的<br>其他程序上下文的内存泄漏. 但是 Java 应用程序依旧会有相当的内存泄漏. 查找原因会十分困<br>难. 有两类主要的 Java 内存泄漏:* 不再需要的对象引用</p><ul><li>未释放的系统资源<br>2.2 非必要的对象引用<br>Java 代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java 对<br>象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如<br>下问题:</li><li>在向数组添加对象以后遗漏了对于他们的处理</li><li>直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并<br>且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.</li><li>在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面<br>保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当<br>中.<br>NOWCODER.COM</li><li>允许一个长久执行的线程所引用的对象. 设置引用为 NULL 也无济于事, 在线程退出和空闲之<br>前, 对象不会被收集释放<br>2.3 未释放的系统资源<br>Java 方法可以定位 Java 实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java 常常通过<br>JNI(Java Native Interface)调用 C&#x2F;C++子程序定位这些资源. 7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办<br>法主动通知虚拟机进行垃圾回收？（垃圾回收）<br>考察点：垃圾回收<br>参考回答：<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆<br>(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当<br>GC 确定一些对象为”不可达”时，GC 就有责<br>任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。 ⑦ IO 和 NIO，AIO<br>1、怎么打印日志？<br>考察点：异常<br>参考回答：<br>cat &#x2F;var&#x2F;log&#x2F;*.log<br>如果日志在更新，如何实时查看 tail -f &#x2F;var&#x2F;log&#x2F;messages<br>还可以使用 watch -d -n 1 cat &#x2F;var&#x2F;log&#x2F;messages<br>-d 表示高亮不同的地方，-n 表示多少秒刷新一次。<br>2、运行时异常与一般异常有何异同？<br>考察点：异常<br>参考回答：<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异<br>常，但是并不要求必须声明抛出未被捕获的运行时异常。<br>3、error 和 exception 有什么区别?<br>考察点：异常<br>NOWCODER.COM<br>参考回答：<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。<br>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。<br>4、给我一个你最常见到的 runtime exception<br>考察点：异常<br>参考回答：<br>ArithmeticException,<br>ArrayStoreException,<br>BufferOverflowException,<br>BufferUnderflowException,<br>CannotRedoException,<br>CannotUndoException,<br>ClassCastException,<br>CMMException,<br>ConcurrentModificationException,<br>DOMException,<br>EmptyStackException,<br>IllegalArgumentException,<br>IllegalMonitorStateException,<br>IllegalPathStateException,<br>IllegalStateException,<br>ImagingOpException,<br>IndexOutOfBoundsException,<br>MissingResourceException,<br>NegativeArraySizeException,<br>NoSuchElementException,<br>NullPointerException,<br>ProfileDataException,<br>NOWCODER.COM<br>ProviderException,<br>RasterFormatException, SecurityException, SystemException,<br>UndeclaredThrowableException, UnmodifiableSetException,<br>UnsupportedOperationException<br>5、Java 中的异常处理机制的简单原理和应用。<br>考察点：异常<br>参考回答：<br>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。<br>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发<br>IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就<br>是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。<br>6、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，<br>请说出他们分别是哪些类？<br>考察点：stream<br>参考回答：<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于<br>InputStreamReader OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高<br>性能和使用方便。<br>7、什么是 java 序列化，如何实现 java 序列化？<br>考察点：序列化<br>参考回答：<br>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对<br>流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象<br>流进行读写操作时所引发的问题。<br>序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，<br>implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如：<br>FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象，接着，使用<br>ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即<br>保存其状态)，要恢复的话则用输入流。<br>8、运行时异常与受检异常有什么区别？<br>考察点：异常<br>参考回答：<br>NOWCODER.COM<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序<br>运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求<br>方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异<br>常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用<br>给出了以下指导原则：* 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流<br>而使用异常）</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在 catch 中忽略掉捕获到的异常<br>二、JavaEE 部分<br>3、Spring 里面注解用过没有？autowired 和 resource 区别？<br>考察点：Spring<br>参考回答：<br>1、共同点<br>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter<br>方法。<br>2、不同点<br>（1）@Autowired<br>@Autowired 为 Spring 提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired;只按照 byType 注入。<br>NOWCODER.COM<br>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存<br>在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）<br>来装配，可以结合@Qualifier 注解一起使用。<br>（2）@Resource<br>@Resource 默认按照 ByName 自动注入，由 J2EE 提供，需要导入包<br>javax.annotation.Resource。@Resource 有两个重要的属性：name 和 type，而 Spring 将<br>@Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以，如<br>果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入<br>策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。<br>4、@Controller 和@RestController 的区别？<br>考察点：spring<br>参考回答：<br>@RestController 注解相当于@ResponseBody ＋ @Controller 合在一起的作用<br>2、Struts 拦截器和 Spring AOP 区别？<br>考察点：框架<br>参考回答：<br>拦截器是 AOP 的一种实现，struts2 拦截器采用 xwork2 的 interceptor！而 spring 的 AOP<br>基于 IoC 基础,其底层采用动态代理与 CGLIB 代理两种方式结合的实现方式。<br>4、选择使用 Spring 框架的原因（Spring 框架为企业级开发带来的好处有哪些）？<br>考察点：框架<br>参考回答：<br>NOWCODER.COM</li><li>非侵入式：支持基于 POJO 的编程模式，不强制性的要求实现 Spring 框架中的接口或继承<br>Spring 框架中的类。</li><li>IoC 容器：IoC 容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如<br>果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建<br>和完整的回归测试。有了 IoC 容器，程序员再也不需要自己编写工厂、单例，这一点特别符合<br>Spring 的精神”不要重复的发明轮子”。</li><li>AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将<br>横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，<br>有了 AOP 程序员可以省去很多自己写代理类的工作。</li><li>MVC：Spring 的 MVC 框架为 Web 表示层提供了更好的解决方案。</li><li>事务管理：Spring 以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，<br>在不需要任何一行代码的情况下就能够完成事务管理。</li><li>其他：选择 Spring 框架的原因还远不止于此，Spring 为 Java 企业级开发提供了一站式选择，<br>你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到 Spring 存在的情<br>况下，在你的项目中使用 Spring 提供的各种优秀的功能。 ④Spring，JPA 整合<br>1、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？<br>考察点：框架<br>参考回答：<br>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中<br>的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统<br>中专注于实现数据持久化的相对独立的层面。<br>持久层设计的目标包括：</li><li>数据存储逻辑的分离，提供抽象化的数据访问接口。</li><li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。</li><li>资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。</li><li>数据抽象，提供更面向对象的数据操作。<br>持久层框架有：</li><li>Hibernate</li><li>MyBatis</li><li>TopLink</li><li>Guzz</li><li>jOOQ</li><li>Spring Data</li><li>ActiveJDBC<br>NOWCODER.COM<br>2、Hibernate<br>①ORM 与持久化映射<br>1、阐述实体对象的三种状态以及转换关系。<br>考察点：JAVA 实体<br>参考回答：<br>最新的 Hibernate 文档中为 Hibernate 对象定义了四种状态（原来是三种状态，面试的时候<br>基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or<br>persistent）、游状态（detached）和移除态（removed，以前 Hibernate 文档中定义的三种状<br>态中没有移除态），如下图所示，就以前的 Hibernate 文档中移除态被视为是瞬时态。<br>瞬时态：当 new 一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数<br>据的内存区域，如果没有变量引用这个对象，则会被 JVM 的垃圾回收机制回收。这个对象所保存<br>的数据与数据库没有任何关系，除非通过 Session 的 save()、saveOrUpdate()、persist()、merge()<br>方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对<br>象。<br>持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态<br>对象进行 delete 操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存<br>在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上<br>同步到数据库，直到数据库事务提交。<br>游离态：当 Session 进行了 close()、clear()、evict()或 flush()后，实体对象从持久态变成<br>游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除<br>掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象<br>是十分相似的，只是它还含有持久化标识。 ②延迟加载、性能优化<br>1、Hibernate 中 SessionFactory 是线程安全的吗？Session 是线程安全的吗（两<br>个线程能够共享同一个 Session 吗）？<br>考察点：session<br>参考回答：<br>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线<br>程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将<br>SessionFactory 通过单例模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象<br>（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。Session 是由<br>SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接<br>口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的<br>session，可以使用 ThreadLocal 将 session 和当前线程绑定在一起，这样可以让同一个线程获<br>得的总是同一个 session。Hibernate 3 中 SessionFactory 的 getCurrentSession()方法就可以<br>做到。<br>NOWCODER.COM<br>2、Hibernate 中 Session 的 load 和 get 方法的区别是什么？<br>考察点：请求方式<br>参考回答：<br>主要有以下三项区别：<br>① 如果没有找到符合条件的记录，get 方法返回 null，load 方法抛出异常。<br>② get 方法直接返回实体类对象，load 方法返回实体类对象的代理。<br>③ 在 Hibernate 3 之前，get 方法只在一级缓存中进行数据查找，如果没有找到对应的数据则<br>越过二级缓存，直接发出 SQL 语句完成数据读取；load 方法则可以从二级缓存中获取数据；从<br>Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。<br>对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加<br>载，如果没有数据就抛出异常，而通过 get()方法获取的数据可以不存在。<br>3、如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session<br>关闭的矛盾是如何处理的？<br>考察点：hibernate 框架<br>参考回答：<br>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate<br>使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load()方法加载数据或者一对多关联<br>映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给<br>用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据<br>库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。<br>延迟加载与 session 关闭的矛盾一般可以这样处理：<br>① 关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通<br>过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or<br>session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询<br>的开销都会变得很大。<br>② 在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized()<br>判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize()方法加载对象。<br>③ 使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提<br>供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。<br>4、简述 Hibernate 常见优化策略。<br>考察点：Hibernate<br>参考回答：<br>①制定合理的缓存策略（二级缓存、查询缓存）。<br>② 采用合理的 Session 管理机制。<br>③ 尽量使用延迟加载特性。<br>④ 设定合理的批处理参数。<br>⑤ 如果可以，选用 UUID 作为主键生成器。<br>⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。<br>⑦ 在开发过程中, 开启 hibernate.show_sql 选项查看生成的 SQL，从而了解底层的状况；开发<br>完成后关闭此选项。<br>NOWCODER.COM<br>⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观<br>的提升，但这些需要专业的 DBA（数据库管理员）提供支持。<br>5、锁机制有什么用？简述 Hibernate 的悲观锁和乐观锁机制。<br>考察点：锁<br>参考回答：<br>有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此<br>过程中数据被锁住不会被外界修改，这就是所谓的锁机制。<br>Hibernate 支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极<br>有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理<br>的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，<br>乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过<br>更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐<br>观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加 1，<br>然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的<br>当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate 中通过 Session 的 get()和<br>load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加<br>整型的版本字段再通过 XML 或@Version 注解进行配置。<br>使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了<br>空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间<br>换时间的策略。 ③HQL 查询、条件查询、SQL 查询<br>1、Hibernate 如何实现分页查询？<br>考察点：框架<br>参考回答：<br>通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()<br>方法）或查询条件（调用 Session 的 createCriteria()方法）、设置查询起始行数（调用 Query<br>或 Criteria 接口的 setFirstResult()方法）和最大查询行数（调用 Query 或 Criteria 接口的<br>setMaxResults()方法），并调用 Query 或 Criteria 接口的 list()方法，Hibernate 会自动生成<br>分页查询的 SQL 语句。 ④二级缓存与查询缓存<br>1、谈一谈 Hibernate 的一级缓存、二级缓存和查询缓存。<br>考察点：缓存<br>参考回答：<br>NOWCODER.COM<br>Hibernate 的 Session 提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实<br>体、修改持久化实体时，Session 并不会立即把这种改变提交到数据库，而是缓存在当前的<br>Session 中，除非显示调用了 Session 的 flush()方法或通过 close()方法关闭 Session。通过一<br>级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。<br>SessionFactory 级别的二级缓存是全局性的，所有的 Session 可以共享这个二级缓存。不过二<br>级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供<br>的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory 就会缓<br>存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。<br>一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓<br>存，可以使用查询缓存。查询缓存是将 HQL 或 SQL 语句以及它们的查询结果作为键值对进行缓存，<br>对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。<br>3、Struts<br>①MVC 模式与 Struts 体系<br>1、说说 STRUTS 的应用<br>考察点：STRUTS 架构<br>参考回答：<br>Struts 是采用 Java Servlet&#x2F;JavaServer Pages 技术，开发 Web 应用程序的开放源码的<br>framework。采用 Struts 能开发出基于 MVC(Model-View-Controller)设计模式的应用构架。<br>Struts 有如下的主要功能：<br>包含一个 controller servlet，能将用户的请求发送到相应的 Action 对象。二.JSP 自由<br>tag 库，并且在 controller servlet 中提供关联支持，帮助开发员创建交互式表单应用。<br>提供了一系列实用对象：XML 处理、通过 Java reflection APIs 自动处理 JavaBeans 属性、<br>国际化的提示和消息。<br>4、Mybatis<br>1、解释一下 MyBatis 中命名空间（namespace）的作用。<br>考察点：Mybatis<br>参考回答：<br>在大型项目中，可能存在大量的 SQL 语句，这时候为每个 SQL 语句起一个唯一的标识（ID）<br>就变得并不容易了。为了解决这个问题，在 MyBatis 中，可以为每个映射文件起一个唯一的命名<br>空间，这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只<br>要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不<br>会再产生冲突了。<br>NOWCODER.COM<br>2、MyBatis 中的动态 SQL 是什么意思？<br>考察点：SQL<br>参考回答：<br>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，<br>需要根据用户指定的条件动态生成 SQL 语句。如果不使用持久层框架我们可能需要自己拼装 SQL<br>语句，还好 MyBatis 提供了动态 SQL 的功能来解决这个问题。MyBatis 中用于实现动态 SQL 的元<br>素主要有：</li><li>if</li><li>choose &#x2F; when &#x2F; otherwise</li><li>trim</li><li>where</li><li>set</li><li>foreach<br>5、MVC<br>1、Spring MVC 注解的优点<br>考察点：spring mvc<br>参考回答：<br>1、XML 配置起来有时候冗长，此时注解可能是更好的选择，如 jpa 的实体映射；注解在处<br>理一些不变的元数据时有时候比 XML 方便的多，比如 springmvc 的数据绑定，如果用 xml 写的代<br>码会多的多；<br>2、注解最大的好处就是简化了 XML 配置；其实大部分注解一定确定后很少会改变，所以在<br>一些中小项目中使用注解反而提供了开发效率，所以没必要一头走到黑；<br>3、注解相对于 XML 的另一个好处是类型安全的，XML 只能在运行期才能发现问题。<br>2、springmvc 和 spring-boot 区别？<br>考察点：spring<br>参考回答：<br>总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA 等等。但<br>他们的基础都是 Spring 的 IOC 和 AOP，IOC 提供了依赖注入的容器，而 AOP 解决了面向切面的<br>编程，然后在此两者的基础上实现了其他衍生产品的高级功能；因为 Spring 的配置非常复杂，<br>各种 xml，properties 处理起来比较繁琐。于是为了简化开发者的使用，Spring 社区创造性地<br>推出了 Spring Boot，它遵循约定优于配置，极大降低了 Spring 使用门槛，<br>但又不失 Spring 原本灵活强大的功能。<br>3、SpringMVC 的运行机制，运行机制的每一部分的相关知识？<br>考察点：spring<br>NOWCODER.COM<br>参考回答：<br>1、用户发送请求时会先从 DispathcherServler 的 doService 方法开始，在该方法中会将<br>ApplicationContext、localeResolver、themeResolver 等对象添加到 request 中，紧接着就是<br>调用 doDispatch 方法。<br>2、进入该方法后首先会检查该请求是否是文件上传的请求(校验的规则是是否是 post 并且<br>contenttType 是否为 multipart&#x2F;为前缀)即调用的是 checkMultipart 方法；如果是的将 request<br>包装成 MultipartHttpServletRequest。<br>3、然后调用 getHandler 方法来匹配每个 HandlerMapping 对象，如果匹配成功会返回这个<br>Handle 的处理链 HandlerExecutionChain 对象，在获取该对象的内部其实也获取我们自定定义<br>的拦截器，并执行了其中的方法。<br>4、执行拦截器的 preHandle 方法，如果返回 false 执行 afterCompletion 方法并理解返回<br>5、通过上述获取到了 HandlerExecutionChain 对象，通过该对象的 getHandler()方法获得<br>一个 object 通过 HandlerAdapter 进行封装得到 HandlerAdapter 对象。<br>6、该对象调用 handle 方法来执行 Controller 中的方法，该对象如果返回一个 ModelAndView 给 DispatcherServlet。<br>7、DispatcherServlet借助ViewResolver完成逻辑试图名到真实视图对象的解析，得到View 后 DispatcherServlet 使用这个 View 对 ModelAndView 中的模型数据进行视图渲染。</li></ul><p>6、各框架对比与项目优化<br>1、Mybatis 和 Hibernate 区别？<br>NOWCODER.COM<br>考察点：Spring 框架<br>参考回答：1. 简介<br>Hibernate：Hibernate 是当前最流行的 ORM 框架之一，对 JDBC 提供了较为完整的封装。<br>Hibernate 的 O&#x2F;R Mapping 实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。<br>Mybatis：Mybatis 同样也是非常流行的 ORM 框架，主要着力点在于 POJO 与 SQL 之间的映<br>射关系。然后通过映射配置文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO 。<br>相对 Hibernate“O&#x2F;R”而言，Mybatis 是一种“Sql Mapping”的 ORM 实现。<br>2、缓存机制对比<br>相同点<br>Hibernate 和 Mybatis 的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己<br>的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。<br>不同点<br>Hibernate 的二级缓存配置在 SessionFactory 生成的配置文件中进行详细配置，然后再在<br>具体的表-对象映射中配置是那种缓存。<br>MyBatis 的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的<br>表可以自定义不同的缓存机制。并且 Mybatis 可以在命名空间中共享相同的缓存配置和实例，通<br>过 Cache-ref 来实现。<br>两者比较<br>因为 Hibernate 对查询对象有着良好的管理机制，用户无需关心 SQL。所以在使用二级缓存<br>时如果出现脏数据，系统会报出错误并提示。而 MyBatis 在这一方面，使用二级缓存时需要特别<br>小心。如果不能完全确定数据更新操作的波及范围，避免 Cache 的盲目使用。否则，脏数据的出<br>现会给系统的正常运行带来很大的隐患。<br>Mybatis：小巧、方便、高效、简单、直接、半自动化<br>Hibernate：强大、方便、高效、复杂、间接、全自动化<br>2、介绍一下你了解的 Java 领域的 Web Service 框架。<br>考察点：框架<br>参考回答：<br>Java 领域的 Web Service 框架很多，包括 Axis2（Axis 的升级版本）、Jersey（RESTful<br>的 Web Service 框架）、CXF（XFire 的延续版本）、Hessian、Turmeric、JBoss SOA 等，其中<br>绝大多数都是开源框架。<br>NOWCODER.COM<br>7、JPA<br>①EJB<br>1、EJB 是基于哪些技术实现的？并说出 SessionBean 和 EntityBean 的区别，<br>StatefulBean 和 StatelessBean 的区别。<br>考察点：JAVA EJB<br>参考回答：<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技<br>术实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用<br>其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象<br>视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种<br>的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的<br>实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是<br>说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会<br>消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者<br>的状态。<br>2、EJB 与 JAVA BEAN 的区别？<br>考察点：EJB<br>参考回答：<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java<br>类都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所以<br>Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于<br>实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，它是不<br>能被跨进程访问的。EnterpriseJava Bean 相当于 DCOM，即分布式组件。它是基于 Java 的远程<br>方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。但 EJB 必须被布署<br>在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正的 EJB 组件，而是通过<br>其容器访问。EJB 容器是 EJB 组件的代理， EJB 组件由容器所创建和管理。客户通过容器来访问<br>真正的 EJB 组件。<br>3、EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事<br>务的？<br>考察点：JAVA EJB<br>NOWCODER.COM<br>参考回答：<br>SessionBean： Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求<br>要建立一个 Bean 的实例时，EJB 容器不一定<br>要创建一个新的 Bean 的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户<br>机第一次调用一个 Stateful Session<br>Bean 时，容器必须立即在服务器中创建一个新的 Bean 实例，并关联到客户机上，以后此客户机<br>调用 Stateful Session Bean 的方法<br>时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不<br>是按照应用程序或者服务进程来说的。即使 EJB 容器崩溃了，Entity beans 也是存活的。Entity<br>Beans 生命周期能够被容器或者<br>Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、<br>Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。<br>4、EJB 的角色和三个对象是什么？<br>考察点：EJB<br>参考回答：<br>一个完整的基于 EJB 的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提<br>供，每个角色所作的工作必须遵循 Sun 公司<br>提供的 EJB 规范，以保证彼此之间的兼容性。这六个角色分别是 EJB 组件开发者（Enterprise Bean<br>Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供<br>者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System<br>Administrator）<br>三个对象是 Remote（Local）接口、Home（LocalHome）接口，Bean 类<br>5、说说 EJB 规范规定 EJB 中禁止的操作有哪些？<br>考察点：EJB<br>参考回答：<br>1.不能操作线程和线程 API(线程 API 指非线程对象的方法如 notify,wait 等)，<br>2.不能操作 awt，<br>3.不能实现服务器功能，<br>4.不能对静态属生存取，<br>5.不能使用 IO 操作直接存取文件系统，<br>6.不能加载本地库.，<br>7.不能将 this 作为变量和返回，<br>NOWCODER.COM<br>8.不能循环调用。<br>6、EJB 的激活机制是什么？<br>考察点：EJB<br>参考回答：<br>以 Stateful Session Bean 为例：其 Cache 大小决定了内存中可以同时存在的 Bean 实例的<br>数量，根据 MRU 或 NRU 算法，实例在激活和去<br>激活状态之间迁移，激活机制是当客户端调用某个 EJB 实例业务方法时，如果对应 EJB Object<br>发现自己没有绑定对应的 Bean 实例则从<br>其去激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。<br>7、EJB 的几种类型分别是什么<br>考察点：EJB<br>参考回答：<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean，会话<br>Bean 又可分为有状态（Stateful）和无状态（Stateless）两种，<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种。<br>8、EJB 需直接实现它的业务接口或 Home 接口吗，请简述理由。<br>考察点：EJB<br>参考回答：<br>在 EJB 中则至少要包括 10 个 class:<br>Bean 类，特定 App Server 的 Bean 实现类 Bean 的 remote 接口，特定 App Server 的 remote 接<br>口实现类，特定 App Server 的 remote 接口的实现类的 stub 类和 skeleton 类。<br>Bean 的 home 接口，特定 App Server 的 home 接口实现类，特定 App Server 的 home 接口的实现<br>类的 stub 类和 skeleton 类。<br>和 RMI 不同的是，EJB 中这 10 个 class 真正需要用户写的只有 3 个，Bean 类，remote 接口，home<br>接口，其它的 7 个究竟怎么生成，被打包在哪里，是否需要更多的类文件，否根据不同的 App<br>Server 表现出较大的差异。<br>Weblogic：<br>home 接口和 remote 接口的 weblogic 的实现类的 stub 类和 skeleton 类是在 EJB 被部署到<br>weblogic 的时候，由 weblogic 动态生成 stub 类和 skeleton 类的字节码，所以看不到这 4 个类<br>文件。<br>对于一次客户端远程调用 EJB，要经过两个远程对象的多次 RMI 循环。首先是通过 JNDI 查找 Home<br>接口，获得 Home 接口的实现类，这个过程其实相当复杂，首先是找到 Home 接口的 Weblogic 实<br>现类，然后创建一个 Home 接口的 Weblogic 实现类的 stub 类的对象实例，将它序列化传送给客<br>户端（注意 stub 类的实例是在第 1 次 RMI 循环中，由服务器动态发送给客户端的，因此不需要<br>客户端保存 Home 接口的 Weblogic 实现类的 stub 类），最后客户端获得该 stub 类的对象实例<br>（普通的 RMI 需要在客户端保存 stub 类，而 EJB 不需要，因为服务器会把 stub 类的对象实例发<br>送给客户端）。<br>客户端拿到服务器给它的 Home 接口的 Weblogic 实现类的 stub 类对象实例以后，调用 stub 类的<br>NOWCODER.COM<br>create 方法， (在代码上就是 home.create()，但是后台要做很多事情),于是经过第 2 次 RMI<br>循环，在服务器端，Home 接口的 Weblogic 实现类的 skeleton 类收到 stub 类的调用信息后，由<br>它再去调用 Home 接口的 Weblogic 实现类的 create 方法。<br>在服务端， Home 接口的 Weblogic 实现类的 create 方法再去调用 Bean 类的 Weblogic 实现类的<br>ejbCreate 方法，在服务端创建或者分配一个 EJB 实例，然后将这个 EJB 实例的远程接口的<br>Weblogic 实现类的 stub 类对象实例序列化发送给客户端。 三、Java web 编程<br>1、web 编程基础<br>①Tomcat 服务器<br>1、启动项目时如何实现不在链接里输入项目名就能启动?<br>考察点：tomcat<br>参考回答：<br>可在 taomcat 配置虚拟目录。<br>2、1 分钟之内只能处理 1000 个请求，你怎么实现，手撕代码?<br>考察点：tomcat<br>参考回答：<br>限流的几种方法：计数器，滑动窗口、漏桶法、令牌桶<br>3、什么时候用 assert<br>考察点：JAVA 调试<br>参考回答：<br>assertion (断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。<br>在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的<br>状态下，系统将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正确性。<br>assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常<br>是关闭的。<br>4、JAVA 应用服务器有那些？<br>考察点：服务器<br>参考回答：<br>NOWCODER.COM<br>BEA WebLogic Server，<br>IBM WebSphere Application Server，<br>Oracle9i Application Server<br>jBoss，<br>Tomcat<br>5、说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的<br>helloWorld.jsp 放入何目录下,然后在浏览器上就可打入主机？<br>考察点：目录结构<br>参考回答：<br>端口号&#x2F;&#x2F;helloword.jsp 就可以看到运行结果了? 又比如这其中用到了一个自己写的<br>javaBean 该如何办?<br>NOWCODER.COM<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果是<br>Web 应用，应用目录需要满足 Web 应用<br>目录要求，jsp 文件可以直接放在应用目录中，Javabean 需要放在应用目录的 WEB-INF 目录的<br>classes 目录中，设置服务器的缺省应用<br>将可以实现在浏览器上无需输入应用名。<br>6、jsp 有哪些动作?作用分别是什么?<br>考察点：JSP<br>参考回答：<br>JSP 共有以下 6 种基本动作 jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>jsp:setProperty：设置 JavaBean 的属性。 jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。<br>8、说一下表达式语言（EL）的隐式对象及其作用<br>考察点：EL<br>NOWCODER.COM<br>参考回答：<br>EL 的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、<br>paramValues、header（访问请求头）、headerValues、cookie（访问 cookie）、applicationScope<br>（访问 application 作用域）、sessionScope（访问 session 作用域）、requestScope（访问 request<br>作用域）、pageScope（访问 page 作用域）。<br>9、JSP 中的静态包含和动态包含有什么区别？<br>考察点：JSP<br>参考回答：<br>静态包含是通过 JSP 的 include指令包含页面，动态包含是通过 JSP 标准动作<a href="jsp:forward">jsp:forward</a><br>包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的<br>“contentType”属性应保持一致，因为两个页面会合二为一，只产生一个 class 文件，因此被包<br>含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含<br>的页面传递参数，包含页面和被包含页面是独立的，会编译出两个 class 文件，如果被包含的页<br>面不存在，不会产生编译错误，也不影响页面其他部分的执行。<br>例如：&lt;%– 静态包含 –%&gt;<br>&lt;%@ include file&#x3D;”…” %&gt;<br>&lt;%– 动态包含 –%&gt;<br>&lt;jsp:include page&#x3D;”…”&gt;<br>&lt;jsp:param name&#x3D;”…” value&#x3D;”…” &#x2F;&gt;<br>&lt;&#x2F;jsp:include&gt;<br>③Listener 和 Filter<br>1、过滤器有哪些作用和用法？<br>考察点：过滤器<br>参考回答：<br>Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在 Servlet<br>2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web 组件，它可以截取<br>客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当 Web 容器接受到一个对资源<br>的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进<br>行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发<br>送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器<br>中你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、<br>对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求<br>或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT 等。<br>和过滤器相关的接口主要有：Filter、FilterConfig 和 FilterChain。<br>3、说说 web.xml 文件中可以配置哪些内容？<br>考察点：xml 文件<br>参考回答：<br>web.xml 用于配置 Web 应用的相关信息，如：监听器（listener）、过滤器（filter）、Servlet、<br>相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：<br>①配置 Spring 上下文加载监听器加载 Spring 配置文件并创建 IoC 容器：<br>&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; &lt;listener&gt; &lt;listener-class&gt;<br>org.springframework.web.context.ContextLoaderListener &lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt;<br>②配置 Spring 的 OpenSessionInView 过滤器来解决延迟加载和 Hibernate 会话关闭的矛盾： &lt;filter&gt; &lt;filter-name&gt;openSessionInView&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;<br>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter &lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;<br>NOWCODER.COM<br>③配置会话超时时间为 10 分钟： &lt;session-config&gt; &lt;session-timeout&gt;10&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt;<br>④配置 404 和 Exception 的错误页面： &lt;error-page&gt; &lt;error-code&gt;404&lt;&#x2F;error-code&gt; &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;&#x2F;exception-type&gt; &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt;<br>⑤配置安全认证方式： &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;ProtectedArea&lt;&#x2F;web-resource-name&gt; &lt;url-pattern&gt;&#x2F;admin&#x2F;<em>&lt;&#x2F;url-pattern&gt; &lt;http-method&gt;GET&lt;&#x2F;http-method&gt; &lt;http-method&gt;POST&lt;&#x2F;http-method&gt; &lt;&#x2F;web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;&#x2F;role-name&gt; &lt;&#x2F;auth-constraint&gt; &lt;&#x2F;security-constraint&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;&#x2F;auth-method&gt; &lt;&#x2F;login-config&gt; &lt;security-role&gt; &lt;role-name&gt;admin&lt;&#x2F;role-name&gt; &lt;&#x2F;security-role&gt;<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>1、forward 与 redirect 区别，说一下你知道的状态码，redirect 的状态码是多<br>少？<br>考察点：Servlet<br>参考回答：<br>1.从地址栏显示来说<br>NOWCODER.COM<br>forward 是服务器请求资源,服务器直接访问目标地址的 URL,把那个 URL 的响应内容读取过<br>来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地<br>址栏还是原来的地址.<br>redirect 是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址<br>栏显示的是新的 URL.<br>2.从数据共享来说<br>forward:转发页面和转发到的页面可以共享 request 里面的数据.<br>redirect:不能共享数据.<br>3.从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.<br>4.从效率来说<br>forward:高.<br>redirect:低.<br>redirect 的状态码是 302<br>2、servlet 生命周期，是否单例，为什么是单例。<br>考察点：servlet<br>参考回答：<br>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：<br>Servlet 通过调用 init () 方法进行初始化。<br>Servlet 调用 service() 方法来处理客户端的请求。<br>Servlet 通过调用 destroy() 方法终止（结束）。<br>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。<br>Servlet 单实例，减少了产生 servlet 的开销；<br>3、说出 Servlet 的生命周期，并说出 Servlet 和 CGI 的区别。<br>考察点：servlet<br>参考回答：<br>NOWCODER.COM<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，<br>service 方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实<br>例销毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个实<br>例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，服务完<br>成后就销毁，所以效率上低于 servlet。<br>4、Servlet 执行时一般实现哪几个方法？<br>考察点：servlet<br>参考回答：<br>public void init(ServletConfig config)<br>public ServletConfig getServletConfig()<br>public String getServletInfo()<br>public void service(ServletRequest request,ServletResponse response)<br>public void destroy()<br>init ()方法在 servlet 的生命周期中仅执行一次，在服务器装载 servlet 时执行。缺省的 init()<br>方法通常是符合要求的，不过也可以根据需要进行 override，比如管理服务器端资源，一次性<br>装入 GIF 图像，初始化数据库连接等，缺省的 inti()方法设置了 servlet 的初始化参数，并用<br>它的 ServeltConfig 对象参数来启动配置，所以覆盖 init()方法时，应调用 super.init()以确<br>保仍然执行这些任务。service ()方法是 servlet 的核心，在调用 service()方法之前，应确保<br>已完成 init()方法。对于 HttpServlet，每当客户请求一个 HttpServlet 对象，该对象的 service()<br>方法就要被调用，HttpServlet 缺省的 service()方法的服务功能就是调用与 HTTP 请求的方法<br>相应的 do 功能，doPost()和 doGet()，所以对于 HttpServlet，一般都是重写 doPost()和 doGet()<br>方法。destroy()方法在 servlet 的生命周期中也仅执行一次，即在服务器停止卸载 servlet 时<br>执行，把 servlet 作为服务器进程的一部分关闭。缺省的 destroy()方法通常是符合要求的，但<br>也可以 override，比如在卸载 servlet 时将统计数字保存在文件中，或是关闭数据库连接<br>getServletConfig()方法返回一个 servletConfig 对象，该对象用来返回初始化参<br>servletContext。servletContext 接口提供有关 servlet 的环境信息。getServletInfo()方法<br>提供有关 servlet 的信息，如作者，版本，版权。<br>5、阐述一下阐述 Servlet 和 CGI 的区别?<br>考察点：servlet<br>参考回答：<br>Servlet与 CGI 的区别在于 Servlet 处于服务器进程中，它通过多线程方式运行其 service()<br>方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的<br>进程，服务完成后就销毁，所以效率上低于 Servlet。<br>6、说说 Servlet 接口中有哪些方法？<br>考察点：Servlet 接口<br>参考回答：<br>NOWCODER.COM<br>Servlet 接口定义了 5 个方法，其中前三个方法与 Servlet 生命周期相关：</em> void init(ServletConfig config) throws ServletException</p><ul><li>void service(ServletRequest req, ServletResponse resp) throws ServletException,<br>java.io.IOException</li><li>void destory()</li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()<br>Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init()方法进行<br>Servlet 的初始化；请求到达时调用 Servlet 的 service()方法，service()方法会根据需要调用<br>与请求对应的 doGet 或 doPost 等方法；当服务器关闭或项目被卸载时服务<br>器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy()方法。<br>7、Servlet 3 中的异步处理指的是什么？<br>考察点：servlet<br>参考回答：<br>在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然<br>都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那<br>么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将<br>会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝<br>服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行<br>时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交<br>给 Executor 并立即返回即可。</li></ul><p>8、如何在基于 Java 的 Web 项目中实现文件上传和下载？<br>考察点：文件传输<br>参考回答：<br>在 Sevlet 3 以前，Servlet API 中没有支持上传功能的 API，因此要实现上传功能需要引<br>入第三方工具从 POST 请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们<br>推荐使用 Apache 的 commons-fileupload。<br>从 Servlet 3 开始，文件上传变得简单许多。</p><p>9、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()<br>方法？<br>考察点：servlet<br>参考回答：<br>HTML 的&lt;form&gt;元素有一个 method 属性，用来指定提交表单的方式，其值可以是 get 或 post。<br>我们自定义的 Servlet 一般情况下会重写 doGet()或 doPost()两个方法之一或全部，如果是 GET<br>请求就调用 doGet()方法，如果是 POST 请求就调用 doPost()方法，那为什么为什么这样呢？我<br>们自定义的 Servlet 通常继承自 HttpServlet，HttpServlet 继承自 GenericServlet 并重写了其<br>中的 service()方法，这个方法是 Servlet 接口中定义的。HttpServlet 重写的 service()方法<br>会先获取用户请求的方法，然后根据请求方法调用 doGet()、doPost()、doPut()、doDelete()<br>等方法，如果在自定义 Servlet 中重写了这些方法，那么显然会调用重写过的（自定义的）方法，<br>这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java 与模式》一书的第 37<br>章）。当然，自定义 Servlet 中也可以直接重写 service()方法，那么不管是哪种方式的请求，<br>都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。<br>10、Servlet 中如何获取用户提交的查询参数或表单数据？<br>考察点：servlet<br>参考回答：<br>可以通过请求对象（HttpServletRequest）的 getParameter()方法通过参数名获得参数值。<br>如果有包含多个值的参数（例如复选框），可以通过请求对象的 getParameterValues()方法获<br>得。当然也可以通过请求对象的 getParameterMap()获得一个参数名和参数值的映射（Map）。<br>11、Servlet 中如何获取用户配置的初始化参数以及服务器上下文参数？<br>考察点：初始化<br>参考回答：<br>可以通过重写 Servlet 接口的 init(ServletConfig)方法并通过 ServletConfig 对象的<br>getInitParameter()方法来获取 Servlet 的初始化参数。可以通过 ServletConfig 对象的<br>getServletContext()方法获取 ServletContext 对象，并通过该对象的 getInitParameter()方<br>法来获取服务器上下文参数。当然，ServletContext 对象也在处理用户请求的方法（如 doGet()<br>方法）中通过请求对象的 getServletContext()方法来获得。<br>NOWCODER.COM<br>2、什么是 DAO 模式？<br>考察点：对象<br>参考回答：<br>NOWCODER.COM<br>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的<br>对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，<br>应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API 中。用程序设计语言来说，就<br>是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当<br>需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑<br>上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 Data Accessor（数据<br>访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的<br>是如何用对象封装数据。<br>3、请问 Java Web 开发的 Model 1 和 Model 2 分别指的是什么？<br>考察点：Model<br>参考回答：<br>Model 1 是以页面为中心的 Java Web 开发，使用 JSP+JavaBean 技术将页面显示逻辑和业务<br>逻辑处理分开，JSP 实现页面显示，JavaBean 对象用来保存数据和实现业务逻辑。Model 2 是基<br>于 MVC（模型-视图-控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视<br>图的彻底分离，利于团队开发和代码复用。 ④JSTL、DisplayTag 等常见标签库的用法<br>1、你的项目中使用过哪些 JSTL 标签？<br>考察点：JSTL<br>参考回答：<br>项目中主要使用了 JSTL 的核心标签库，包括&lt;c:if&gt;、&lt;c:choose&gt;、&lt;c: when&gt;、&lt;c: otherwise&gt;、<br>&lt;c:forEach&gt;等，主要用于构造循环和分支结构以控制显示逻辑。<br>虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库，但是实际开发中建议只使用核心<br>标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到<br>数据显示和业务逻辑的分离，这才是最佳实践。<br>2、使用标签库有什么好处？如何自定义 JSP 标签？（JSP 标签）<br>考察点：JSP 标签<br>参考回答：<br>使用标签库的好处包括以下几个方面：</p><ul><li>分离 JSP 页面的内容和逻辑，简化了 Web 开发；</li><li>开发者可以创建自定义标签来封装业务逻辑和显示逻辑；</li><li>标签具有很好的可移植性、可维护性和可重用性；</li><li>避免了对 Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在 JSP 中书写小脚本）<br>编写一个 Java 类实现实现 Tag&#x2F;BodyTag&#x2F;IterationTag 接口（开发中通常不直接实现这些<br>接口而是继承 TagSupport&#x2F;BodyTagSupport&#x2F;SimpleTagSupport 类，这是对缺省适配模式的应用），<br>重写 doStartTag()、doEndTag()等方法，定义标签要完成的功能：<br>NOWCODER.COM</li><li>编写扩展名为 tld 的标签描述文件对自定义标签进行部署，tld 文件通常放在 WEB-INF 文件夹<br>下或其子目录中</li><li>在 JSP 页面中使用 taglib 指令引用该标签库<br>3、Web 编程原理<br>①HTTP 协议<br>1、get 和 post 区别？<br>考察点：HTTP 请求<br>参考回答：<br>（1）在客户端， Get 方式在通过 URL 提交数据，数据 在 URL 中可以看到；POST 方式，数据<br>放置在 HTML HEADER 内提交。<br>（2）GET 方式提交的数据最多只能有 1024 字节，而 POST 则没有此限制。<br>（3）安全性问题。正如在（ 1 ）中提到，使用 Get 的时候，参数会显示在地址栏上，<br>而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get ；如果<br>用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post 为好。<br>安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同<br>一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，<br>GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从<br>自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的<br>一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。<br>POST 请求就不那么轻松了。 POST 表示可能改变服务器上的资源的请求。仍然以新闻站点<br>为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比<br>方说文章下面出现一条注解）。</li></ul><p>3、BS 与 CS 的联系与区别。<br>考察点：客户端&#x2F;服务器模式<br>NOWCODER.COM<br>参考回答：<br>C&#x2F;S 是 Client&#x2F;Server 的缩写。服务器通常采用高性能的 PC、工作站或小型机，并采用大型<br>数据库系统，如 Oracle、Sybase、Informix 或 SQL Server。客户端需要安装专用的客户端软件。<br>B&#x2F;Ｓ是 Brower&#x2F;Server 的缩写，客户机上只要安装一个浏览器（Browser），如 Netscape Navigator<br>或 Internet Explorer，服务器安<br>装 Oracle、Sybase、Informix 或 SQL Server 等数据库。在这种结构下，用户界面完全通过 WWW<br>浏览器实现，一部分事务逻辑在前端实<br>现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C&#x2F;S 与 B&#x2F;S 区别：<br>硬件环境不同:<br>C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供<br>连接和数据交换服务.<br>B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自<br>己管理. 有比 C&#x2F;S 更强的适应范围, 一<br>般只要有操作系统和浏览器就行<br>２．对安全要求不同<br>C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统<br>采用 C&#x2F;S 结构适宜. 可以通过 B&#x2F;S 发布<br>部分可公开信息.<br>B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同<br>C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.<br>B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比 C&#x2F;S 有更高<br>的要求 B&#x2F;S 结构的程序架构是发展的趋<br>势, 从 MS 的.Net 系列的 BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN<br>和 IBM 推的 JavaBean 构件技术等,使<br>B&#x2F;S 更加成熟. ４．软件重用不同<br>C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在 B&#x2F;S 要求下的构件的重用性好.<br>B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以<br>再利用,而不是做在墙上的石头桌子<br>５．系统维护不同<br>C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再<br>做一个全新的系统<br>B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从<br>网上自己下载安装就可以实现升级. ６．处理问题不同<br>C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应<br>该都是相同的系统<br>B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是 C&#x2F;S 无法作到的. 与操作系统<br>平台关系最小. ７．用户接口不同<br>C&#x2F;S 多是建立的 Window 平台上,表现方法有限,对程序员普遍要求较高<br>B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减<br>低开发成本. ８．信息流不同<br>C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低<br>B&#x2F;S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。<br>NOWCODER.COM<br>4、如何设置请求的编码以及响应内容的类型？<br>考察点：请求类型<br>参考回答：<br>通过请求对象（ServletRequest）的 setCharacterEncoding(String)方法可以设置请求的<br>编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java 程序都使用统一的<br>编码，最好的选择当然是 UTF-8；通过响应对象（ServletResponse）的 setContentType(String)<br>方法可以设置响应内容的类型，当然也可以通过 HttpServletResponsed 对象的<br>setHeader(String, String)方法来设置。<br>5、什么是 Web Service（Web 服务）？<br>考察点：web service<br>参考回答：<br>从表面上看，Web Service 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用<br>的 API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，<br>跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的 Web Service，那么无论你<br>用哪种编程语言开发的应用都可以通过调用它的 API 并传入城市信息来获得该城市的天气预报。<br>之所以称之为 Web Service，是因为它基于 HTTP 协议传输数据，这使得运行在不同机器上的不<br>同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。<br>SOA（Service-Oriented Architecture，面向服务的架构），SOA 是一种思想，它将应用程<br>序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种<br>形式的功能单元能够更好的集成。显然，Web Service 是 SOA 的一种较好的解决方案，它更多的<br>是一种标准，而不是一种具体的技术。<br>6、谈谈 Session 的 save()、update()、merge()、lock()、saveOrUpdate()和<br>persist()方法分别是做什么的？有什么区别？<br>考察点：session<br>参考回答：<br>Hibernate 的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态<br>（detached），如第 135 题中的图所示。瞬时态的实例可以通过调用 save()、persist()或者<br>saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()<br>或者 replicate()变成持久态。save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()<br>或 merge()会引发 UPDATE 语句。save()和 update()的区别在于一个是将瞬时态对象变成持久态，<br>一个是将游离态对象变为持久态。merge()方法可以完成 save()和 update()方法的功能，它的意<br>图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于 persist()方法，按照<br>官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填<br>入到持久化实例中，标识符的填入可能被推迟到 flush 的时间；② persist()方法保证当它在一<br>个事务外部被调用的时候并不触发一个 INSERT 语句，当需要封装一个长会话流程的时候，<br>persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执<br>行 INSERT 语句，不管是在事务内部还是外部。至于 lock()方法和 update()方法的区别，update()<br>方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱<br>管状态的对象变成持久状态。<br>NOWCODER.COM<br>7、大型网站在架构上应当考虑哪些问题？<br>考察点：Java 架构<br>参考回答：</p><ul><li>分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个<br>层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形<br>成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI&#x2F;RM）和 Internet 的 TCP&#x2F;IP<br>模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储<br>和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。<br>需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备<br>上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之<br>间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</li><li>分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚<br>低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模<br>块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另<br>一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</li><li>分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独<br>立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的<br>加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式<br>部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，<br>例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce<br>分布式计算框架来处理。</li><li>集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</li><li>缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓<br>存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。</li><li>异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，<br>二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影<br>响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用<br>Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能<br>推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</li><li>冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可<br>以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。 ③Web 容器<br>1、请对以下在 J2EE 中常用的名词进行解释(或简单描述)<br>考察点：J2EE<br>参考回答：<br>web 容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP,SERVLET<br>直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有 WEB 服务器来实现。例如：<br>TOMCAT,WEBLOGIC,WEBSPHERE 等。该容器提供的接口严格遵守 J2EE 规范中的 WEBAPPLICATION 标<br>准。我们把遵守以上标准的 WEB 服务器就叫做 J2EE 中的 WEB 容器。<br>Web container：实现 J2EE 体系结构中 Web 组件协议的容器。这个协议规定了一个 Web 组件运行<br>时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和 JSP 和<br>J2EE 平台 APIs 界面相同服务的容器。一个 Web container 由 Web 服务器或者 J2EE 服务器提供。<br>EJB 容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件 EJB<br>NOWCODER.COM<br>各种管理功能。只要满足 J2EE 规范的 EJB 放入该容器，马上就会被容器进行高效率的管理。并<br>且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了 J2EE 体<br>系结构中 EJB 组件规范的容器。这个规范指定了一个 Enterprise bean 的运行时环境，包括安全，<br>一致性，生命周期，事务，配置，和其他的服务。<br>JNDI：（Java Naming &amp; Directory Interface）JAVA 命名目录服务。主要提供的功能是：提供<br>一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布<br>式应用程序的功能。<br>JMS：（Java Message Service）JAVA 消息服务。主要实现各个应用程序之间的通讯。包括点对<br>点和广播。<br>JTA：（Java Transaction API）JAVA 事务服务。提供各种分布式事务服务。应用程序只需调用<br>其提供的接口即可。<br>JAF：（Java Action FrameWork）JAVA 安全认证框架。提供一些安全控制方面的框架。让开发<br>者通过各种部署和自定义实现自己的个性安全控制策略。<br>RMI&#x2F;IIOP: （Remote Method Invocation &#x2F;internet 对象请求中介协议）他们主要用于通过远<br>程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地<br>计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI<br>是 JAVA 特有的。RMI-IIOP 出现以前，只有 RMI 和 CORBA 两种选择来进行分布式程序设计。<br>RMI-IIOP 综合了 RMI 和 CORBA 的优点，克服了他们的缺点，使得程序员能更方便的编写分布式<br>程序设计，实现分布式计算。首先，RMI-IIOP 综合了 RMI 的简单性和 CORBA 的多语言性（兼容<br>性），其次 RMI-IIOP 克服了 RMI 只能用于 Java 的缺点和 CORBA 的复杂性。 四、JDBC 编程</li></ul><p>2、JDBC 基础<br>①数据库<br>1、数据库水平切分，垂直切分<br>考察点：数据库<br>参考回答：<br>NOWCODER.COM<br>垂直拆分就是要把表按模块划分到不同数据库表中（当然原则还是不破坏第三范式），这种<br>拆分在大型网站的演变过程中是很常见的。当一个网站还在很小的时候，只有小量的人来开发和<br>维护，各模块和表都在一起，当网站不断丰富和壮大的时候，也会变成多个子系统来支撑，这时<br>就有按模块和功能把表划分出来的需求。其实，相对于垂直切分更进一步的是服务化改造，说得<br>简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，<br>因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，淘宝在架构不断演<br>变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成独立<br>的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。<br>垂直拆分：单表大数据量依然存在性能瓶颈<br>水平拆分，上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量<br>的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。例如像计费<br>系统，通过按时间来划分表就比较合适，因为系统都是处理某一时间段的数据。而像 SaaS 应用，<br>通过按用户维度来划分数据比较合适，因为用户与用户之间的隔离的，一般不存在处理多个用户<br>数据的情况，简单的按 user_id 范围来水平切分。<br>通俗理解：水平拆分行，行数据拆分到不同表中， 垂直拆分列，表数据拆分到不同表中。</p><p>10、leftjoin 和 rightjoin 的区别？<br>考察点：表结构<br>参考回答：<br>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录<br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>比如：<br>表 A 记录如下：<br>aID aNum<br>1 a20050111<br>2 a20050112<br>3 a20050113<br>4 a20050114<br>5 a20050115<br>表 B 记录如下:<br>bID bName<br>1 2006032401<br>2 2006032402<br>3 2006032403<br>4 2006032404<br>8 2006032408<br>left join 是以 A 表的记录为基础的,A 可以看成左表,B 可以看成右表,left join 是以左表<br>为准的. 换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为:<br>A.aID &#x3D; B.bID).<br>B 表记录不足的地方均为 NULL. 11、数据库优化方法<br>考察点：数据库<br>参考回答：<br>（1）选取最适用的字段属性<br>MySQL 可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行<br>的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度<br>设得尽可能小。<br>例如，在定义邮政编码这个字段时，如果将其设置为 CHAR(255),显然给数据库增加了不必<br>要的空间，甚至使用 VARCHAR 这种类型也是多余的，因为 CHAR(6)就可以很好的完成任务了。同<br>样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段。<br>NOWCODER.COM<br>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为 NOTNULL，这样在将来<br>执行查询的时候，数据库不用去比较 NULL 值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL<br>中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。<br>这样，我们又可以提高数据库的性能。<br>（2）使用连接（JOIN）来代替子查询(Sub-Queries)<br>MySQL 从 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查<br>询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没<br>有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户 ID 取出<br>来，然后将结果传递给主查询<br>（3）使用联合(UNION)来代替手动创建的临时表<br>MySQL 从 4.0 的版本开始支持 union 查询，它可以把需要使用临时表的两条或更多的 select<br>查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据<br>库整齐、高效。使用 union 来创建查询的时候，我们只需要用 UNION 作为关键字把多个 select<br>语句连接起来就可以了，要注意的是所有 select 语句中的字段数目要想同。下面的例子就演示<br>了一个使用 UNION 的查询。<br>（4）事务<br>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样<br>的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时<br>候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句<br>运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两<br>个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，<br>造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。<br>要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失<br>败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以 BEGIN 关键字开始，COMMIT<br>关键字结束。在这之间的一条 SQL 操作失败，那么，ROLLBACK 命令就可以把数据库恢复到 BEGIN<br>开始之前的状态。<br>12、谈一下你对继承映射的理解。<br>考察点：映射<br>参考回答：<br>继承关系的映射策略有三种：<br>① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。<br>② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。<br>③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。<br>第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态<br>查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是<br>需要进行连接查询，不适合多态查询。<br>NOWCODER.COM<br>②数据库连接池<br>1、说出数据连接池的工作机制是什么?<br>考察点：连接池<br>参考回答：<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连<br>接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用<br>完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 ③事物管理，批处理<br>1、事务的 ACID 是指什么？<br>考察点：数据库<br>参考回答：</p><ul><li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导<br>致整个事务的失败； - 一致性(Consistent)：事务结束后系统状态是一致的； - 隔离性<br>(Isolated)：并发执行的事务彼此无法看到对方的中间状态； - 持久性(Durable)：事务完成后<br>所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建<br>数据。<br>关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，<br>只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括<br>3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类<br>丢失更新）。<br>2、JDBC 中如何进行事务处理？<br>考察点：数据库<br>参考回答：<br>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置手动提交事<br>务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中发生异常则通过 rollback()<br>进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代<br>码设置保存点并让事务回滚到指定的保存点。<br>NOWCODER.COM<br>3、JDBC 进阶<br>1、JDBC 的反射，反射都是什么？<br>考察点：jdbc<br>参考回答：<br>通过反射 com.mysql.jdbc.Driver 类，实例化该类的时候会执行该类内部的静态代码块，该<br>代码块会在 Java 实现的 DriverManager 类中注册自己,DriverManager 管理所有已经注册的驱动<br>类，当调用 DriverManager.geConnection 方法时会遍历这些驱动类，并尝试去连接数据库，只<br>要有一个能连接成功，就返回 Connection 对象，否则则报异常。<br>2、Jdo 是什么?<br>考察点：JAVA API<br>参考回答：<br>JDO 是 Java 对象持久化的新的规范，为 java data object 的简称,也是一个用于存取某种<br>数据仓库中的对象的标准化 API。JDO 提供了透明的对象存储，因此对开发人员来说，存储数据<br>对象完全不需要额外的代码（如 JDBC API 的使用）。这些繁琐的例行工作已经转移到 JDO 产品<br>提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO 很灵活，因<br>为它可以在任何数据底层上运行。JDBC 只是面向关系数据库（RDBMS）JDO 更通用，提供到任何<br>数据底层的存储功能，比如关系数据库、文件、XML 以及对象数据库（ODBMS）等等，使得应用<br>可移植性更强。<br>3、Statement 和 PreparedStatement 有什么区别？哪个性能更好？<br>考察点：Statement<br>参考回答：<br>与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以<br>减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement<br>中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；③当批量处<br>理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以<br>将编译优化后的 SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成<br>执行计划）。<br>为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程<br>（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数<br>据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然<br>调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移<br>时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。<br>4、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性<br>能？<br>考察点：JDBC 优化<br>NOWCODER.COM<br>参考回答：<br>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()方法指<br>定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用<br>PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。 五、XML 编程<br>1、XML 基础<br>1、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种<br>方式？<br>考察点：XML<br>参考回答：<br>a: 两种形式 dtd schema<br>b: 本质区别:schema 本身是 xml 的，可以被 XML 解析器解析(这也是从 DTD 上发展 schema 的根<br>本目的)<br>c:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这种结构占<br>用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML 的随机访问<br>SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文件，不需要一次全部装载<br>整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用<br>户通过在其回调事件中写入处理代码来处理 XML 文件，适合对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)<br>xml 文档有两种定义方法：<br>dtd：数据类型定义（data type definition），用以描述 XML 文档的文档结构，是早期的 XML<br>文档定义形式。<br>schema：其本身是基于 XML 语言编写的，在类型和语法上的限定能力比 dtd 强，处理也比较方便，<br>因为此正逐渐代替 dtd 成为新的模式定义语言。<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>1、WEB SERVICE 名词解释，JSWDL 开发包的介绍，JAXP、JAXM 的解释。SOAP、<br>UDDI,WSDL 解释。<br>考察点：web service<br>NOWCODER.COM<br>参考回答：<br>Web ServiceWeb Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 WebService 能与其他兼容的组件进行互操作。JAXP(Java API for<br>XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。这样在你的程序中你只要<br>使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。JAXM(Java API for XML<br>Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。WSDL 是一种 XML 格式，用于将网<br>络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格<br>式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。<br>相关的具体端点即组合成为抽象端点（服务）。SOAP 即简单对象访问协议(Simple Object Access<br>Protocol)，它是用于交换 XML 编码信息的轻量级协议。UDDI 的目的是为电子商务建立标准；UDDI<br>是一套基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范，同时也<br>包含一组使企业能将自身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标<br>准。soap 是 web service 最关键的技术，是 web service 中数据和方法调传输的介质。WSDL（web<br>service definition language）描述了 web service 的接口和功能。<br>2、请你谈谈对 SOAP、WSDL、UDDI 的了解？<br>考察点：协议&amp;语言<br>参考回答：</li><li>SOAP：简单对象访问协议（Simple Object Access Protocol），是 Web Service 中交换<br>数据的一种协议规范。</li><li>WSDL：Web 服务描述语言（Web Service Description Language），它描述了 Web 服务的公共<br>接口。这是一个基于 XML 的关于如何与 Web 服务通讯和使用的服务描述；也就是描述与目录中列<br>出的 Web 服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作<br>和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。</li><li>UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它<br>是一个基于 XML 的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服<br>务。简单的说，UDDI 是访问各种 WSDL 的一个门面（可以参考设计模式中的门面模式）。<br>3、谈谈 Java 规范中和 Web Service 相关的规范有哪些？<br>考察点：规范<br>参考回答：<br>Java 规范中和 Web Service 相关的有三个：</li><li>JAX-WS(JSR 224)：这个规范是早期的基于 SOAP 的 Web Service 规范 JAX-RPC 的替代版本，它<br>并不提供向下兼容性，因为 RPC 样式的 WSDL 以及相关的 API 已经在 Java EE5 中被移除了。<br>WS-MetaData 是 JAX-WS 的依赖规范，提供了基于注解配置 Web Service 和 SOAP 消息的相关 API。</li><li>JAXM(JSR 67)：定义了发送和接收消息所需的 API,相当于 Web Service 的服务器端。</li><li>JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是 Java 针对 REST（Representation State Transfer）<br>架构风格制定的一套 Web Service 规范。REST 是一种软件架构模式，是一种风格，它不像 SOAP<br>那样本身承载着一种消息协议，(两种风格的 Web Service 均采用了 HTTP 做传输协议，因为 HTTP<br>协议能穿越防火墙，Java 的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因<br>此可以将 REST 视为基于 HTTP 协议的软件架构。REST 中最重要的两个概念是资源定位和资源操<br>作，而 HTTP 协议恰好完整的提供了这两个点。HTTP 协议中的 URI 可以完成资源定位，而 GET、<br>POST、OPTION、DELETE 方法可以完成资源操作。因此 REST 完全依赖 HTTP 协议就可以完成 Web<br>NOWCODER.COM<br>Service，而不像 SOAP 协议那样只利用了 HTTP 的传输特性，定位和操作都是由 SOAP 协议自身完<br>成的，也正是由于 SOAP 消息的存在使得基于 SOAP 的 Web Service 显得笨重而逐渐被淘汰。 六、计算机网络<br>1、网络概述<br>①关于分层<br>1、TCP 协议在哪一层？IP 协议在那一层？HTTP 在哪一层？<br>考察点：网络七层模型<br>参考回答：<br>运输层，网络层，应用层。<br>2、运输层<br>①TCP 与 UDP<br>1、讲一下 TCP 的连接和释放连接。<br>考察点：网络基础<br>参考回答：<br>三次握手的过程<br>1）主机 A 向主机 B 发送 TCP 连接请求数据包，其中包含主机 A 的初始序列号 seq(A)&#x3D;x。（其<br>中报文中同步标志位 SYN&#x3D;1，ACK&#x3D;0，表示这是一个 TCP 连接请求数据报文；序号 seq&#x3D;x，表明传<br>输数据时的第一个数据字节的序号是 x）；<br>2）主机 B 收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位 SYN&#x3D;1，ACK&#x3D;1，<br>表示这是一个 TCP 连接响应数据报文，并含主机 B 的初始序列号 seq(B)&#x3D;y，以及主机 B 对主机 A<br>初始序列号的确认号 ack(B)&#x3D;seq(A)+1&#x3D;x+1）<br>3）第三次，主机 A 收到主机 B 的确认报文后，还需作出确认，即发送一个序列号 seq(A)&#x3D;x+1；<br>确认号为 ack(A)&#x3D;y+1 的报文；<br>四次挥手过程<br>NOWCODER.COM<br>假设主机 A 为客户端，主机 B 为服务器，其释放 TCP 连接的过程如下：<br>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数<br>据传送，然后等待服务器的确认。其中终止标志位 FIN&#x3D;1，序列号 seq&#x3D;u。<br>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。<br>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。<br>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加<br>1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>三次握手<br>四次挥手<br>2、TCP 有哪些应用场景<br>考察点：TCP 协议<br>参考回答：<br>NOWCODER.COM<br>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一<br>些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议<br>3、tcp 为什么可靠<br>考察点：TCP<br>参考回答：<br>三次握手，超时重传，滑动窗口，拥塞控制。<br>4、tcp 为什么要建立连接<br>考察点：TCP<br>参考回答：<br>保证可靠传输。<br>5、阐述 TCP 的 4 次挥手<br>考察点：TCP 协议<br>参考回答：<br>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的<br>数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上<br>没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动<br>关闭，而另一方执行被动关闭。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服<br>务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。<br>（1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送。<br>（2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，<br>一个 FIN 将占用一个序号。<br>（3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A。<br>（4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。<br>NOWCODER.COM<br>②协议<br>1、讲一下浏览器从接收到一个 URL 到最后展示出页面，经历了哪些过程。tag<br>考察点：http 协议<br>参考回答：<br>1.DNS 解析 2.TCP 连接 3.发送 HTTP 请求 4.服务器处理请求并返回 HTTP 报文<br>5.浏览器解析渲染页面<br>2、http 和 https 的区别<br>考察点：http 协议<br>参考回答；<br>https 协议要申请证书到 ca，需要一定经济成本；2） http 是明文传输，https 是加密的安<br>全传输；3） 连接的端口不一样，http 是 80，https 是 443；4）http 连接很简单，没有状态；<br>https 是 ssl 加密的传输，身份认证的网络协议，相对 http 传输比较安全。<br>3、http 的请求有哪些，应答码 502 和 504 有什么区别<br>考察点：http 协议<br>参考回答：<br>OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送<br>‘*‘的请求来测试服务器的功能性。<br>HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以<br>在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>NOWCODER.COM<br>GET：向特定的资源发出请求。<br>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请<br>求体中。POST 请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>PUT：向指定资源位置上传其最新内容。<br>DELETE：请求服务器删除 Request-URI 所标识的资源。<br>TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求<br>方式也都可以通过这两种方式间接的来实现。<br>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识<br>出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。<br>4、http1.1 和 1.0 的区别<br>考察点：http<br>参考回答：<br>主要区别主要体现在：<br>缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判<br>断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since,<br>If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。<br>带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要<br>某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在<br>请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），<br>这样就方便了开发者自由的选择以便于充分利用带宽和连接。<br>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请<br>求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。<br>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中<br>的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以<br>存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求<br>消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad<br>Request）。<br>长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）<br>处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，<br>在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创<br>建连接的缺点。<br>NOWCODER.COM<br>5、说说 ssl 四次握手的过程<br>考察：HTTP 加密协议<br>参考回答：<br>1、 客户端发出请求<br>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello<br>请求。<br>2、服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。<br>3、客户端回应<br>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书<br>中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还<br>要继续通信。<br>4、服务器的最后回应<br>服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的”会话密<br>钥”。然后，向客户端最后发送下面信息。<br>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所<br>有内容的 hash 值，用来供客户端校验。<br>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通<br>的 HTTP 协议，只不过用”会话密钥”加密内容。<br>6、304 状态码有什么含义？<br>考察点：http<br>参考回答：<br>304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页<br>内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为<br>If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，<br>进而节省带宽和开销。<br>3、网络层<br>①网际协议 IP<br>1、arp 协议，arp 攻击<br>NOWCODER.COM<br>考察点：ARP 协议<br>参考回答：<br>地址解析协议。ARP 攻击的第一步就是 ARP 欺骗。由上述“ARP 协议的工作过程”我们知道，<br>ARP 协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正<br>确和快速的完成——ARP 协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在<br>向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现 ARP 应答中的 IP 地址和 MAC<br>地址中的信息是可以伪造的，并不一定是自己的真实 IP 地址和 MAC 地址，由此，ARP 欺骗就产<br>生了。 ②网际控制报文协议 ICMP<br>1、icmp 协议<br>考察点：ICMP 协议<br>参考回答：<br>它是 TCP&#x2F;IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息。控制消息是<br>指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用<br>户数据，但是对于用户数据的传递起着重要的作用。 ③因特网的路由器选择协议<br>1、讲一下路由器和交换机的区别？<br>考察点：路由器<br>参考回答：<br>交换机用于同一网络内部数据的快速传输转发决策通过查看二层头部完成转发不需要修改<br>数据帧工作在 TCP&#x2F;IP 协议的二层 —— 数据链路层工作简单，直接使用硬件处理路由器用于不<br>同网络间数据的跨网络传输转发决策通过查看三层头部完成转发需要修改 TTL ，IP 头部校验和<br>需要重新计算，数据帧需要重新封装工作在 TCP&#x2F;IP 协议的三层 —— 网络层工作复杂，使用软<br>件处理。<br>4、应用层<br>①域名系统 DNS<br>1、DNS 寻址过程<br>考察点：DNS<br>NOWCODER.COM<br>参考回答：<br>1、在浏览器中输入 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个<br>网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。<br>2、如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射<br>关系，如果有，直接返回，完成域名解析。<br>3、如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP&#x2F;ip 参数中<br>设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域<br>名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。<br>4、如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关<br>系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。<br>5、如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是<br>否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服<br>务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的<br>一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com<br>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS 服务器地<br>址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，<br>重复上面的动作，进行查询，直至找到 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 主机。<br>6、如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服<br>务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不<br>管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此<br>DNS 服务器再返回给客户机。<br>从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查<br>询。②电子邮件<br>1、负载均衡反向代理模式优点及缺点<br>考察点：反向代理<br>参考回答：<br>（1）反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然<br>后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接<br>的客户端，此时代理服务器对外就表现为一个服务器。<br>（2）反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转<br>发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。<br>（3）反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，<br>也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡<br>策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由<br>于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有<br>此优点）。<br>NOWCODER.COM<br>（4）其缺点主要表现在以下两个方面<br>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反<br>向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器<br>的负载均衡。<br>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接<br>请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的<br>瓶颈。<br>一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点<br>进行负载均衡，如 search 等。 七、操作系统<br>1、操作系统概论<br>1、CentOS 和 Linux 的关系？<br>考察点：操作系统<br>参考回答：<br>CentOS是Linux众多得发行版本之一，linux有三大发行版本（：Slackware、debian、redhat）, 而 Redhat 有收费的商业版和免费的开源版,商业版的业内称之为 RHEL 系列，CentOS 是来自于依<br>照开放源代码规定而公布的源代码重新编译而成。可以用 CentOS 替代商业版的 RHEL 使用。两者<br>的不同，CentOS 不包含封闭源代码软件，是免费的。<br>2、64 位和 32 位的区别？<br>考察点：<br>操作系统<br>参考回答：<br>操作系统只是硬件和应用软件中间的一个平台。32 位操作系统针对的 32 位的 CPU 设计。64<br>位操作系统针对的 64 位的 CPU 设计。<br>2、进程的描述与控制<br>1、怎么杀死进程？<br>考察点：进程<br>参考回答：<br>NOWCODER.COM<br>Kill pid<br>2、线程，进程区别<br>考察点：进程，线程<br>参考回答：<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，<br>一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路<br>径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个<br>进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要<br>差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。1. 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li></ul><ol start="2"><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高<br>了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序<br>执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多<br>个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这<br>就是进程和线程的重要区别。<br>3、系统线程数量上限是多少？<br>考察点：线程<br>参考回答：<br>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。<br>这个限制可以在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;local_lim.h 中查看 ，对 linuxthreads 这个值一般<br>是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。<br>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程<br>栈大小，一般情况下，这个值是 8M&#x3D;8192KB。<br>4、进程和线程的区别是什么？<br>考察点：JAVA 进程<br>参考回答：<br>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。<br>线程又叫做轻量级进程。<br>NOWCODER.COM<br>5、解释一下 LINUX 下线程，GDI 类。<br>考察点：线程<br>参考回答：<br>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心<br>轻量级进程，而线程之间的管理在核外函数库中实现。<br>GDI 类为图像设备编程接口类库。<br>3、输入输出系统<br>1、socket 编程，BIO，NIO，epoll？<br>考察点：I&#x2F;O 多路复用<br>参考回答：<br>阻塞，非阻塞，io 多路复用，epoll 支持文件符数目没有限制，fd 集合只会从用户进程拷<br>贝到内核一次，自己维护一个事件队列，不用每次遍历 fd 集合发现是否有就绪状态。<br>4、存储器管理<br>1、什么是页式存储？<br>考察点：页式存储<br>参考回答：<br>主存被等分成大小相等的片，称为主存块，又称为实页。<br>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为 2n ,通常为 1KB、2KB、<br>2n KB 等<br>2、操作系统里的内存碎片你怎么理解，有什么解决办法？<br>考察点：内存碎片<br>参考回答：<br>内存碎片分为：内部碎片和外部碎片。<br>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；<br>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存<br>储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才<br>有可能利用这个存储块。<br>NOWCODER.COM<br>单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。<br>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存<br>空间的新进程的内存空闲区域。<br>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前<br>申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br>使用伙伴系统算法。<br>5、处理机调度与死锁<br>1、什么情况下会发生死锁，解决策略有哪些？<br>考察点：死锁<br>参考回答：<br>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个<br>进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如 CD-ROM 驱动器，打印机等<br>等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属<br>性所决定的。<br>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至<br>少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但<br>是，它在等待新资源之时，仍继续占用已占有的资源。<br>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源<br>的占有者进程自行释放。<br>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。<br>解决方法：银行家算法<br>2、系统 CPU 比较高是什么原因？<br>考察点：处理机<br>参考回答：<br>1、首先查看是哪些进程的 CPU 占用率最高（如下可以看到详细的路径）<br>ps -aux –sort -pcpu | more# 定位有问题的线程可以用如下命令ps -mp pid -o THREAD,tid,time | more<br>2、查看 JAVA 进程的每个线程的 CPU 占用率<br>ps -Lp 5798 cu | more # 5798 是查出来进程 PID<br>NOWCODER.COM<br>3、追踪线程，查看负载过高的原因，使用 JDK 下的一个工具<br>jstack 5798 # 5798 是 PID<br>jstack -J-d64 -m 5798 # -j-d64 指定 64 为系统<br>jstack 查出来的线程 ID 是 16 进制，可以把输出追加到文件，导出用记事本打开，再根据<br>系统中的线程 ID 去搜索查看该 ID 的线程运行内容，可以和开发一起排查。<br>3、系统如何提高并发性？<br>考察：操作系统综合性<br>参考回答：<br>1、提高 CPU 并发计算能力<br>（1）多进程&amp;多线程<br>（2）减少进程切换，使用线程，考虑进程绑定 CPU<br>（3）减少使用不必要的锁，考虑无锁编程<br>（4）考虑进程优先级<br>（5）关注系统负载<br>2、改进 I&#x2F;O 模型<br>(1)DMA 技术<br>(2)异步 I&#x2F;O<br>(3)改进多路 I&#x2F;O 就绪通知策略，epoll<br>(4)Sendfile<br>(5)内存映射<br>(6)直接 I&#x2F;O<br>八、算法与数据结构<br>1、哈希<br>1、hashset 存的数是有序的吗？<br>考察点：哈希<br>NOWCODER.COM<br>参考回答：<br>Hashset 是无序的。<br>2、Object 作为 HashMap 的 key 的话，对 Object 有什么要求吗？<br>考察点：哈希表<br>参考回答：<br>要求 Object 中 hashcode 不能变。<br>3、一致性哈希算法<br>考察点：哈希算法<br>参考回答：<br>先构造一个长度为 232 的整数环（这个环被称为一致性 Hash 环），根据节点名称的 Hash<br>值（其分布为[0, 232-1]）将服务器节点放置在这个 Hash 环上，然后根据数据的 Key 值计算得<br>到其 Hash 值（其分布也为[0, 232-1]），接着在 Hash 环上顺时针查找距离这个 Key 值的 Hash<br>值最近的服务器节点，完成 Key 到服务器的映射查找。<br>这种算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况<br>下尽量有多的请求命中原来路由到的服务器。<br>4、什么是 hashmap?<br>考察点：哈希表<br>参考回答：<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于 AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null。此<br>外，HashMap 中的映射不是有序的。<br>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表<br>中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前<br>可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该<br>哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少<br>了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操<br>作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便<br>最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生<br>rehash 操作。<br>hashmap 共有 4 个构造函数：<br>&#x2F;&#x2F; 默认构造函数。HashMap()<br>&#x2F;&#x2F; 指定“容量大小”的构造函数<br>NOWCODER.COM<br>HashMap(int capacity)<br>&#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数<br>HashMap(int capacity, float loadFactor)<br>&#x2F;&#x2F; 包含“子 Map”的构造函数<br>HashMap(Map&lt;? extends K, ? extends V&gt; map)<br>5、Java 中的 HashMap 的工作原理是什么？<br>考察点：JAVA 哈希表<br>参考回答：<br>HashMap 类有一个叫做 Entry 的内部类。这个 Entry 类包含了 key-value 作为实例变量。每<br>当往 hashmap 里面存放 key-value 对的时候，都会为它们实例化一个 Entry 对象，这个 Entry<br>对象就会存储在前面提到的 Entry 数组 table 中。Entry 具体存在 table 的那个位置是 根据 key<br>的 hashcode()方法计算出来的 hash 值（来决定）。<br>6、hashCode()和 equals()方法的重要性体现在什么地方？<br>考察点：JAVA 哈希表<br>参考回答：<br>Java 中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值<br>的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的<br>hash 值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这<br>两个方法的实现对 HashMap 的精确性和正确性是至关重要的。<br>2、树<br>1、说一下 B+树和 B-树？<br>考察点：树<br>参考回答：<br>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；<br>b+树查询必须查找到叶子节点，b 树只要匹配到即可不用管元素位置，因此 b+树查找更稳定<br>（并不慢）；<br>对于范围查找来说，b+树只需遍历叶子节点链表即可，b 树却需要重复地中序遍历。<br>2、怎么求一个二叉树的深度?手撕代码?<br>考察点：二叉树<br>NOWCODER.COM<br>参考回答：<br>public int maxDepth(TreeNode root) {<br>if (root &#x3D;&#x3D; null) {<br>return 0;<br>}<br>int left &#x3D; maxDepth(root.left);<br>int right &#x3D; maxDepth(root.right);<br>int bigger &#x3D; Math.max(left, right);<br>return bigger + 1;<br>}<br>3、算法题：二叉树层序遍历，进一步提问：要求每层打印出一个换行符<br>考察点：二叉树<br>参考回答：<br>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {<br>List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();<br>LinkedList&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;TreeNode&gt;();<br>if (root &#x3D;&#x3D; null) {<br>return res;<br>}<br>queue.offer(root);<br>while (queue.size() !&#x3D; 0) {<br>List&lt;Integer&gt; l &#x3D; new ArrayList&lt;Integer&gt;();<br>int size &#x3D; queue.size();<br>for (int i &#x3D; 0; i &lt; size; i++) {<br>TreeNode temp &#x3D; queue.poll();<br>l.add(temp.val);<br>if (temp.left !&#x3D; null) {<br>NOWCODER.COM<br>queue.offer(temp.left);<br>}<br>if (temp.right !&#x3D; null) {<br>queue.offer(temp.right);<br>}<br>}<br>res.add(l);<br>}<br>return res;<br>}<br>4、二叉树任意两个节点之间路径的最大长度<br>考察点：树<br>参考回答：<br>int maxDist(Tree root) {<br>&#x2F;&#x2F;如果树是空的，则返回 0<br>if(root &#x3D;&#x3D; NULL)<br>return 0;<br>if(root-&gt;left !&#x3D; NULL) {<br>root-&gt;lm &#x3D; maxDist(root-&gt;left) + 1;<br>}<br>if(root-&gt;right !&#x3D; NULL)<br>root-&gt;rm &#x3D; maxDist(root-&gt;right) + 1;<br>&#x2F;&#x2F;如果以该节点为根的子树中有最大的距离，那就更新最大距离<br>int sum &#x3D; root-&gt;rm + root-&gt;lm;<br>if(sum &gt; max) {<br>max &#x3D; sum;<br>NOWCODER.COM<br>}<br>return root-&gt;rm &gt; root-&gt;lm ? root-&gt;rm : root-&gt;lm;<br>}<br>5、如何实现二叉树的深度？<br>考察点：二叉树<br>参考回答：<br>实现二叉树的深度方式有两种，递归以及非递归。<br>①递归实现：<br>为了求树的深度，可以先求其左子树的深度和右子树的深度，可以用递归实现，递归的出口<br>就是节点为空。返回值为 0；<br>②非递归实现：<br>利用层次遍历的算法，设置变量 level 记录当前节点所在的层数，设置变量 last 指向当前<br>层的最后一个节点，当处理完当前层的最后一个节点，让 level 指向+1 操作。设置变量 cur 记<br>录当前层已经访问的节点的个数，当 cur 等于 last 时，表示该层访问结束。<br>层次遍历在求树的宽度、输出某一层节点，某一层节点个数，每一层节点个数都可以采取类<br>似的算法。<br>树的宽度：在树的深度算法基础上，加一个记录访问过的层节点个数最多的变量 max,在访<br>问每层前 max 与 last 比较，如果 max 比较大，max 不变，如果 max 小于 last，把 last 赋值给<br>max;<br>6、如何打印二叉树每层的节点？<br>考察点：二叉树<br>参考回答：<br>7、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()<br>方法如何比较元素？<br>考察点：Tree<br>NOWCODER.COM<br>参考回答：<br>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的<br>compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映<br>射的键必须实现 Comparable 接口从而根据键对元素进行排序。Collections 工具类的 sort 方法<br>有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实<br>现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参<br>数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定<br>义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中<br>对函数式编程的支持）。<br>4、bucket 如果用链表存储，它的缺点是什么？<br>考察点：链表<br>参考回答：<br>①查找速度慢，因为查找时，需要循环链表访问<br>②如果进行频繁插入和删除操作，会导致速度很慢。<br>5、如何判断链表检测环<br>考察点：链表<br>参考回答：<br>单链表有环，是指单链表中某个节点的 next 指针域指向的是链表中在它之前的某一个节点，<br>这样在链表的尾部形成一个环形结构。<br>&#x2F;&#x2F; 链表的节点结构如下 typedef struct node { int data; struct node *next; } NODE;<br>最常用方法：定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针<br>一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指<br>针走到了链表的末尾（next 指向 NULL）都没有追上第一个指针，那么链表就不是环形链表。<br>通过使用 STL 库中的 map 表进行映射。首先定义 map&lt;NODE , int&gt; m; 将一个 NODE * 指<br>针映射成数组的下标，并赋值为一个 int 类型的数值。然后从链表的头指针开始往后遍历，每<br>次遇到一个指针 p，就判断 m[p] 是否为 0。如果为 0，则将 m[p]赋值为 1，表示该节点第一次<br>访问；而如果 m[p]的值为 1，则说明这个节点已经被访问过一次了，于是就形成了环。</li></ol><p>6、排序<br>1、排序算法知道哪些，时间复杂度是多少，解释一下快排？<br>考察点：快排<br>参考回答：<br>快排：快速排序有两个方向，左边的 i 下标一直往右走（当条件 a[i] &lt;&#x3D; a[center_index]<br>时），其中 center_index 是中枢元素的数组下标，一般取为数组第 0 个元素。<br>而右边的 j 下标一直往左走（当 a[j] &gt; a[center_index]时）。<br>如果 i 和 j 都走不动了，i &lt;&#x3D; j, 交换 a[i]和 a[j],重复上面的过程，直到 i&gt;j。交换 a[j]<br>和 a[center_index]，完成一趟快速排序。<br>2、如何得到一个数据流中的中位数？<br>考察点：排序<br>参考回答：<br>数据是从一个数据流中读出来的，数据的数目随着时间的变化而增加。如果用一个数据容器<br>来保存从流中读出来的数据，当有新的数据流中读出来时，这些数据就插入到数据容器中。<br>数组是最简单的容器。如果数组没有排序，可以用 Partition 函数找出数组中的中位数。<br>在没有排序的数组中插入一个数字和找出中位数的时间复杂度是 O(1)和 O(n)。<br>我们还可以往数组里插入新数据时让数组保持排序，这是由于可能要移动 O(n)个数，因此<br>需要 O(n)时间才能完成插入操作。在已经排好序的数组中找出中位数是一个简单的操作，只需<br>要 O(1)时间即可完成。<br>排序的链表时另外一个选择。我们需要 O(n)时间才能在链表中找到合适的位置插入新的数<br>据。如果定义两个指针指向链表的中间结点（如果链表的结点数目是奇数，那么这两个指针指向<br>同一个结点），那么可以在 O（1）时间得出中位数。此时时间效率与及基于排序的数组的时间<br>效率一样。<br>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有<br>排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大<br>NOWCODER.COM<br>数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆<br>中找出最小数。<br>因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右<br>边的数据容器。往堆中插入一个数据的时间效率是 O(logn)。由于只需 O(1)时间就可以得到位<br>于堆顶的数据，因此得到中位数的时间效率是 O(1)。<br>3、堆排序的原理是什么？<br>考察点：堆排序<br>参考回答：<br>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大<br>数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：<br>（1）最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。<br>（2）创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆。<br>（3）堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算<br>4、归并排序的原理是什么？<br>考察点：归并排序<br>参考回答：<br>（1）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and<br>Conquer）的一个非常典型的应用。<br>（2）首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个<br>数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那<br>直接将另一个数列的数据依次取出即可。<br>（3）解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组<br>A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让<br>这二组组内数据有序了？<br>NOWCODER.COM<br>可以将 A，B 组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这<br>个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，<br>再合并数列就完成了归并排序。<br>5、排序都有哪几种方法？请列举出来。<br>考察点：排序<br>参考回答：<br>排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），<br>选择排序（直接选择排序、堆排序），<br>归并排序，分配排序（箱排序、基数排序）<br>快速排序的伪代码。<br>&#x2F; &#x2F;使用快速排序方法对 a[ 0 :n- 1 ]排序<br>从 a[ 0 :n- 1 ]中选择一个元素作为 m i d d l e，该元素为支点<br>把余下的元素分割为两段 left 和 r i g h t，使得 l e f t 中的元素都小于等于支点，而 right<br>中的元素都大于等于支点<br>递归地使用快速排序方法对 left 进行排序<br>递归地使用快速排序方法对 right 进行排序<br>所得结果为 l e f t + m i d d l e + r i g h t<br>7、堆与栈<br>1、堆与栈的不同是什么？<br>考察点：堆，栈<br>参考回答：<br>（1）Java 的堆是一个运行时数据区，类的对象从中分配空间。通过比如：new 等指令建立，<br>不需要代码显式的释放，由垃圾回收来负责。<br>优点：可以动态地分配内存大小，垃圾收集器会自动回收垃圾数据。<br>缺点：由于其优点，所以存取速度较慢。<br>（2）栈：<br>其数据项的插入和删除都只能在称为栈顶的一端完成，后进先出。栈中存放一些基本类型的<br>变量 和 对象句柄。<br>优点：读取数度比堆要快，仅次于寄存器，栈数据可以共享。<br>NOWCODER.COM<br>缺点：比堆缺乏灵活性，存在栈中的数据大小与生存期必须是确定的。<br>举例：<br>String 是一个特殊的包装类数据。可以用：<br>String str &#x3D; new String(“csdn”);<br>String str &#x3D; “csdn”;<br>两种的形式来创建，第一种是用 new()来新建对象的，它会在存放于堆中。每调用一次就会<br>创建一个新的对象。而第二种是先在栈中创建一个对 String 类的对象引用变量 str，然后查找<br>栈中有没有存放”csdn”，如果没有，则将”csdn”存放进栈，并令 str 指向”abc”，如果已经<br>有”csdn” 则直接令 str 指向“csdn”。<br>2、heap 和 stack 有什么区别。<br>考察点：堆与栈<br>参考回答：<br>栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。<br>堆是栈的一个组成元素。<br>3、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。<br>考察点：堆栈<br>参考回答：<br>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都<br>使用内存中的栈空间；而通过 new 关键字和构造器创建的对象放在堆空间；程序中的字面量<br>（literal）如直接书写的 100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈<br>很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上<br>的虚拟内存都可以被当成堆空间来使用。<br>String str &#x3D; new String(“hello”);<br>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面<br>量放在静态区。<br>8、队列<br>1、什么是 Java 优先级队列(Priority Queue)？<br>考察点：队列<br>参考回答：<br>PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)<br>排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue 不允<br>NOWCODER.COM<br>许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，<br>PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。<br>2、id 全局唯一且自增，如何实现？<br>考察点：SnowFlake 雪花算法<br>参考回答；<br>SnowFlake 雪花算法<br>雪花 ID 生成的是一个 64 位的二进制正整数，然后转换成 10 进制的数。64 位二进制数由如<br>下部分组成：<br>snowflake id 生成规则<br>1 位标识符：始终是 0，由于 long 基本类型在 Java 中是带符号的，最高位是符号位，正数<br>是 0，负数是 1，所以 id 一般是正数，最高位是 0。<br>41 位时间戳：41 位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间<br>截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的 id 生成器开始使用的时间，<br>由我们程序来指定的。<br>10 位机器标识码：可以部署在 1024 个节点，如果机器分机房（IDC）部署，这 10 位可以由<br>5 位机房 ID + 5 位机器 ID 组成。<br>NOWCODER.COM<br>12 位序列：毫秒内的计数，12 位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)<br>产生 4096 个 ID 序号<br>优点<br>简单高效，生成速度快。<br>时间戳在高位，自增序列在低位，整个 ID 是趋势递增的，按照时间有序递增。<br>灵活度高，可以根据业务需求，调整 bit 位的划分，满足不同的需求。<br>缺点<br>依赖机器的时钟，如果服务器时钟回拨，会导致重复 ID 生成。<br>在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况。<br>3、如何设计算法压缩一段 URL？<br>考察点：MD5 加密算法<br>参考回答：<br>该算法主要使用 MD5 算法对原始链接进行加密（这里使用的 MD5 加密后的字符串长度为 32<br>位），然后对加密后的字符串进行处理以得到短链接的地址。<br>4、为什么要设计后缀表达式，有什么好处？<br>考察点：逆波兰表达式<br>参考回答：<br>后缀表达式又叫逆波兰表达式，逆波兰记法不需要括号来标识操作符的优先级。<br>5、LRU 算法的实现原理？<br>考察点：LRU 算法<br>参考回答：<br>①LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数<br>据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也很高”，反过来说“如果<br>数据最近这段时间一直都没有访问,那么将来被访问的概率也会很低”，两种理解是一样的；常<br>用于页面置换算法，为虚拟页式存储管理服务。<br>②达到这样一种情形的算法是最理想的：每次调换出的页面是所有内存页面中最迟将被使用<br>的；这可以最大限度的推迟页面调换，这种算法，被称为理想页面置换算法。可惜的是，这种算<br>法是无法实现的。<br>为了尽量减少与理想算法的差距，产生了各种精妙的算法，最近最少使用页面置换算法便是其中<br>一个。LRU 算法的提出，是基于这样一个事实：在前面几条指令中使用频繁的页面很可能在后面<br>的几条指令中频繁使用。反过来说，已经很久没有使用的页面很可能在未来较长的一段时间内不<br>NOWCODER.COM<br>会被用到 。这个，就是著名的局部性原理——比内存速度还要快的 cache，也是基于同样的原<br>理运行的。因此，我们只需要在每次调换时，找到最近最少使用的那个页面调出内存。<br>算法实现的关键<br>命中率：<br>当存在热点数据时，LRU 的效率很好，但偶发性的、周期性的批量操作会导致 LRU 命中率急剧<br>下降，缓存污染情况比较严重。<br>复杂度：<br>实现起来较为简单。<br>存储成本：<br>几乎没有空间上浪费。<br>代价：<br>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。 九、设计模式<br>1、结构型模式<br>①代理模式<br>1、java 中有哪些代理模式？<br>考察点：代理模式<br>参考回答：<br>静态代理，动态代理，Cglib 代理。<br>2、如何实现动态代理<br>考察点：动态代理流程<br>参考回答：<br>Java 实现动态代理的大致步骤如下：<br>1.定义一个委托类和公共接口。<br>2.自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是<br>指定运行时将生成的代理类需要完成的具体任务（包括 Preprocess 和 Postprocess），即代理<br>类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。<br>3.生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口<br>(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器<br>实例。<br>4.Java 实现动态代理主要涉及以下几个类：<br>NOWCODER.COM<br>①java.lang.reflect.Proxy: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承<br>了 Proxy 类，即 DynamicProxyClass extends Proxy。<br>②java.lang.reflect.InvocationHandler: 这里称他为”调用处理器”，他是一个接口，我<br>们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现<br>InvocationHandler 接口。<br>示例代码：<br>public final class <code>$Proxy1 extends Proxy implements Subject&#123; private InvocationHandler h; private $</code>Proxy1(){}<br>public $Proxy1(InvocationHandler h){<br>this.h &#x3D; h; }<br>public int request(int i){<br>Method method &#x3D; Subject.class.getMethod(“request”, new Class[]{int.class}); &#x2F;&#x2F;<br>创建 method 对象<br>return (Integer)h.invoke(this, method, new Object[]{new Integer(i)}); &#x2F;&#x2F;调用了<br>invoke 方法 } }<br>②适配器模式<br>1、IO 流熟悉吗，用的什么设计模式？<br>考察点：装饰模式，适配器模式<br>参考回答：<br>装饰模式和适配器模式<br>2、创建型模式<br>①单例模式<br>1、介绍一下单例模式？懒汉式的单例模式如何实现单例？<br>考察点：单例模式<br>参考回答：<br>NOWCODER.COM<br>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。优点：单例类只有一个<br>实例、共享资源，全局使用节省创建时间，提高性能。可以用静态内部实现，保证是懒加载就行<br>了，就是使用才会创建实例对象。<br>3、行为型模式<br>①策略模式<br>1、介绍一下策略模式？<br>考察点：策略模式<br>参考回答：<br>策略模式也叫政策模式，是一种行为型设计模式，是一种比较简单的设计模式。策略模式<br>采用了面向对象的继承和多态机制。略模式适合使用在：1.多个类只有在算法或行为上稍有不同<br>的场景。2.算法需要自由切换的场景。3.需要屏蔽算法规则的场景。 使用策略模式当然也有需<br>要注意的地方，那么就是策略类不要太多，如果一个策略家族的具体策略数量超过 4 个，则需要<br>考虑混合模式，解决策略类膨胀和对外暴露问题。在实际项目中，我们一般通过工厂方法模式来<br>实现策略类的声明。<br>优点：算法可以自由切换。2.避免使用多重条件判断。3.扩展性良好。 ②观察者模式<br>1、设计模式了解哪些，手写一下观察者模式？<br>考察点：观察者模式<br>参考回答：<br>NOWCODER.COM<br>观察者模式优点：<br>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个<br>具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个<br>具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，<br>因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然<br>跨越抽象化和具体化层次。<br>观察者模式缺点：<br>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费<br>很多时间。<br>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩<br>溃。在使用观察者模式是要特别注意这一点。<br>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方<br>式进行的。<br>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应<br>的机制使观察者知道所观察的对象是怎么发生变化的。<br>4、模式汇总<br>1、说说你所熟悉或听说过的 j2ee 中的几种常用模式?及对设计模式的一些看法<br>考察点：J2EE 设计模式<br>参考回答：<br>Session Facade Pattern：使用 SessionBean 访问 EntityBean Message Facade Pattern：<br>实现异步调用 EJB Command Pattern：使用 Command JavaBeans 取代 SessionBean，实现轻量级<br>访问 Data Transfer Object Factory：通过 DTO Factory 简化 EntityBean 数据提供特性 Generic<br>Attribute Access：通过 AttibuteAccess 接口简化 EntityBean 数据提供特性 Business<br>NOWCODER.COM<br>Interface：通过远程（本地）接口和 Bean 类实现相同接口规范业务逻辑一致性ＥＪＢ架构的设<br>计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率。项目越复杂，<br>项目队伍越庞大则越能体现良好设计的重要性。<br>2、j2ee 常用的设计模式？说明工厂模式。<br>考察点：j2ee 设计模式<br>参考回答：<br>Java 中的 23 种设计模式：<br>Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），Prototype<br>（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式），<br>Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元<br>模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor<br>（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），<br>Observer（观察者模式）， State（状态模式）， Strategy（策略模式），Template Method<br>（模板方法模式）， Chain Of Responsibleity（责任链模式）工厂模式：工厂模式是一种经常<br>被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通<br>常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了<br>不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需<br>要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员<br>可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。<br>3、开发中都用到了那些设计模式?用在什么场合?<br>考察点：设计模式<br>参考回答：<br>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核<br>心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用<br>到了 MVC 的设计模式。用来开发 JSP&#x2F;Servlet 或者 J2EE 的相关应用。简单工厂模式等。<br>4、简述一下你了解的 Java 设计模式<br>考察点：设计模式<br>参考回答：<br>所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一<br>个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。<br>设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模<br>式也会使新系统开发者更加容易理解其设计思路。<br>在 GoF 的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三<br>类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的<br>结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：<br>Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模<br>式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter<br>（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight<br>（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor<br>（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），<br>NOWCODER.COM<br>Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模<br>板方法模式）， Chain Of Responsibility（责任链模式）。 十、场景题<br>1、情景题：如果一个外卖配送单子要发布，现在有 200 个骑手都想要接这一单，如何保证只有<br>一个骑手接到单子？<br>2、场景题：美团首页每天会从 10000 个商家里面推荐 50 个商家置顶，每个商家有一个权值，你<br>如何来推荐？第二天怎么更新推荐的商家？<br>可以借鉴下 stackoverflow，视频网站等等的推荐算法。<br>3、场景题：微信抢红包问题<br>悲观锁，乐观锁，存储过程放在 mysql 数据库中。<br>4、场景题：1000 个任务，分给 10 个人做，你怎么分配，先在纸上写个最简单的版本，然后优<br>化。<br>全局队列，把 1000 任务放在一个队列里面，然后每个人都是取，完成任务。<br>分为 10 个队列，每个人分别到自己对应的队列中去取务。<br>5、场景题：保证发送消息的有序性，消息处理的有序性。<br>6、如何把一个文件快速下发到 100w 个服务器<br>7、给每个组分配不同的 IP 段，怎么设计一种结构使的快速得知 IP 是哪个组的?<br>8、10 亿个数，找出最大的 10 个。<br>建议一个大小为 10 的小根堆。<br>9、有几台机器存储着几亿淘宝搜索日志，你只有一台 2g 的电脑，怎么选出搜索热度最高的十个<br>搜索关键词？<br>10、分布式集群中如何保证线程安全？<br>11、给个淘宝场景，怎么设计一消息队列？<br>12、10 万个数，输出从小到大？<br>先划分成多个小文件，送进内存排序，然后再采用多路归并排序。<br>13、有十万个单词，找出重复次数最高十个？<br>十一、UML<br>1、请你谈一下 UML 中有哪些常用的图？<br>考察点：用例图<br>参考回答：<br>UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用<br>例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图<br>（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、<br>构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有<br>三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解<br>系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、<br>NOWCODER.COM<br>时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收<br>的消息也就是说对象能够向外界提供的服务）。 十二、惊喜福利<br>此面试题库将根据当下面试形式大数据随时更新，如果你已获得下载权限，那么你可以终身<br>在牛币兑换中心里去兑换此面试题库的电子版，如果电子版有更新，会通过牛客站内信进行<br>通知（前提是你已获得下载权限）。<br>b.14. ⽹络相关：<br>a. tcp三次握⼿、四次挥⼿<br>b. http机制<br>c. https机制15. 项⽬亮点：16. 画架构图：17. 平时看过什么书？18. 接⼝与抽象类区别<br>1、⼀个类声明可否既是abstract的,⼜是final的? 不能,这两个修式符⽭盾（abstract就是要被继承）<br>2、抽象类不⼀定包含抽象⽅法<br>3、有抽象⽅法,则⼀定是抽象类<br>4、抽象类不能被实例化，⼀般⽤作基类使⽤；<br>a. 类可以实现多个接⼝但只能继承⼀个抽象类<br>b. 接⼝⾥⾯所有的⽅法都是Public的，抽象类允许Private、Protected⽅法<br>c. JDK8前接⼝⾥⾯所有的⽅法都是抽象的且不允许有静态⽅法，抽象类可以有普通、静态⽅法，JDK8 接⼝可以实现默认⽅法<br>和静态⽅法，前⾯加default、static关键字。19. java中的异常有哪⼏类，分别怎么使⽤？<br>分为错误和异常，异常⼜包括运⾏时异常、⾮运⾏时异常<br>a. 错误，如StackOverflowError、OutOfMemoryError<br>b. 异常：<br>i. 运⾏时异常，如NullPointerException、IndexOutOfBoundsException，都是RuntimeException及其⼦类<br>ii. ⾮运⾏时异常，如IOException、SQLException,都是Exception及其⼦类，这些异常是⼀定需要try catch捕获的20. 常⽤的集合类有哪些？⽐如list如何排序？<br>主要分为三类，Map、Set、List<br>a. Map: HashMap、LinkedHashMap、TreeMap<br>b. Set：HashSet、LinkedHashSet、TreeSet<br>c. List: ArrayList、LinkedList<br>1 Collections.sort(list);21. ArrayList和LinkedList内部实现⼤致是怎样的？他们之间的区别和优缺点？<br>a. ArrayList：内部使⽤数组的形式实现了存储，利⽤数组的下标进⾏元素的访问，因此对元素的随机访问速度⾮常快。因为是<br>数组，所以ArrayList在初始化的时候，有初始⼤⼩10，插⼊新元素的时候，会判断是否需要扩容，扩容的步⻓是0.5倍原容量，<br>扩容⽅式是利⽤数组的复制，因此有⼀定的开销。<br>b. LinkedList：内部使⽤双向链表的结构实现存储，LinkedList有⼀个内部类作为存放元素的单元，⾥⾯有三个属性，⽤来存放<br>元素本身以及前后2个单元的引⽤，另外LinkedList内部还有⼀个header属性，⽤来标识起始位置，LinkedList的第⼀个单元和<br>最后⼀个单元都会指向header，因此形成了⼀个双向的链表结构。<br>c. ArrayList查找较快，插⼊、删除较慢，LinkedList查找较慢，插⼊、删除较快。22. 内存溢出是怎么回事？举个例⼦。<br>a. 内存溢出 out of memory，是指程序在申请内存时，没有⾜够的内存空间供其使⽤，出现out of memory。<br>1 List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();<br>2 while (true) {<br>3 list.add(new Object());<br>4 }<br>b. 内存溢出可能的原因：<br>i. 程序中存在死循环<br>ii. 静态变量和静态⽅法太多了<br>iii. 内存泄漏：⽐如说⼀个静态的list，⼀直往⾥放值，⼜因为静态变量不会被释放，所以迟早是要内存溢出的<br>iv. ⼤对象过多：java中的⼤对象是直接进⼊⽼年代的，然后当多个⼤对象同时⼯作时造成程序的可⽤内存⾮常⼩，⽐如我<br>list中原本最多可以放1000个对象，因为可⽤内存太⼩，放了500个就放不下了。<br>v. 程序分配内存过⼩：还有⼀种很常⻅的情况，在把⼀个很⼤的程序直接导⼊，直接就内存溢出了，原因就是内存相对这<br>个程序就是太⼩了，需要⼿动增加内存。<br>c. 内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄漏堆<br>积后果很严重，⽆论多少内存,迟早会被占光。23. &#x3D;&#x3D;和equals的区别<br>&#x3D;&#x3D;是运算符，⽽equals是Object的基本⽅法，&#x3D;&#x3D;⽤于基本类型的数据的⽐较，或者是⽐较两个对象的引⽤是否相同，equals⽤<br>于⽐较两个对象的值是否相等，例如字符串的⽐较。24. hashCode⽅法的作⽤<br>1、hashCode的存在主要是⽤于查找的快捷性，为了配合基于散列的集合正常运⾏，如Hashtable，HashMap等，hashCode是<br>⽤来在散列存储结构中确定对象的存储地址的；<br>2、如果两个对象相同，就是适⽤于equals(java.lang.Object) ⽅法，那么这两个对象的hashCode⼀定要相同；<br>3、如果对象的equals⽅法被重写，那么对象的hashCode也尽量重写，并且产⽣hashCode使⽤的对象，⼀定要和equals⽅法中<br>使⽤的⼀致，否则就会违反上⾯提到的第2点；<br>4、两个对象的hashCode相同，并不⼀定表示两个对象就相同，也就是不⼀定适⽤于equals(java.lang.Object) ⽅法，只能够说<br>明这两个对象在散列存储结构中，它们存放在同⼀个桶⾥⾯。25. NIO是什么？适⽤于何种场景？<br>a. NIO是为了弥补IO操作的不⾜⽽诞⽣的，NIO的⼀些新特性有：⾮阻塞I&#x2F;O，选择器，缓冲以及管道。<br>b. 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候⽤NIO处理数据可<br>能是个很好的选择。(适⽤于⼩数据多连接)<br>c. ⽽如果只有少量的连接，⽽这些连接每次要发送⼤量的数据，这时候传统的IO更合适。使⽤哪种处理数据，需要在数据的响<br>应等待时间和检查缓冲区数据的时间上作⽐较来权衡选择。<br>d. NIO：<br>i. 概念：NIO(new IO)，是⼀种⾮阻塞式I&#x2F;O；java NIO采⽤了双向通道进⾏数据传输，在通道上我们可以注册我们感兴趣的<br>事件：连接事件、读写事件；NIO主要有三⼤核⼼部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)。传统IO基于字<br>节流和字符流进⾏操作，⽽NIO基于Channel和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区<br>写⼊到通道中。Selector(选择区)⽤于监听多个通道的事件（⽐如：连接打开，数据到达）。因此，单个线程可以监听多个<br>数据通道。<br>ii. 原理：26. 由⼀个专⻔的线程来处理所有的 IO 事件，并负责分发。27. 事件驱动机制：事件到的时候触发，⽽不是同步的去监视事件。28. 线程通讯：线程之间通过 wait,notify 等⽅式通讯。保证每次上下⽂切换都是有意义的。减少⽆谓的线程切换。29. Hashmap实现原理？如何保证HashMap线程安全？<br>a. HashMap简单说就是它根据键的hashCode值存储数据，⼤多数情况下可以直接定位到它的值，因⽽具有很快的访问速度，<br>但遍历顺序却是不确定的。<br>b. HashMap基于哈希表，底层结构由数组来实现，添加到集合中的元素以“key–value”形式保存到数组中，在数组中key–<br>value被包装成⼀个实体来处理—也就是上⾯Map接⼝中的Entry。<br>c. 在HashMap中，Entry[]保存了集合中所有的键值对，当我们需要快速存储、获取、删除集合中的元素时，HashMap会根据<br>hash算法来获得“键值对”在数组中存在的位置，以来实现对应的操作⽅法。<br>d. HashMap底层是采⽤数组来维护的.Entry静态内部类的数组<br>1 &#x2F;**<br>2 * The table, resized as necessary. Length MUST Always be a power of two.<br>3 *&#x2F;<br>4 transient Entry[] table;<br>5<br>6 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>7 final K key;<br>8 V value;<br>9 Entry&lt;K,V&gt; next;<br>10 final int hash;<br>11 ……<br>12 }<br>c. HashMap添加元素：将准备增加到map中的对象与该位置上的对象进⾏⽐较(equals⽅法),如果相同,那么就将该位置上的那<br>个对象(Entry类型)的value值替换掉,否则沿着该Entry的链继续重复上述过程,如果到链的最后任然没有找到与此对象相同的对象,那么这个<br>时候就会被增加到数组中,将数组中该位置上的那个Entry对象链到该对象的后⾯(先hashcode计算位置，如果找到相同位置便替换值，找<br>不到则重复hashcode计算，直到最后在添加到hashmap最后⾯；)<br>d. HashMap是基于哈希表的Map接⼝的⾮同步实现，允许null键值，但不保证映射的顺序；底层使⽤数组实现，数组中的每项<br>是⼀个链表；存储时根据key的hash算法来决定其存储位置；数组扩容需要重新计算扩容后每个元素在数组中的位置很耗性能；<br>e. ConcurrentHashMap是HashMap的线程安全实现，允许多个修改操作同时进⾏(使⽤了锁分离技术)，它使⽤了多个锁来控制<br>对hash表的不同段进⾏的修改，每个段其实就是⼀个⼩的hashtable，它们有⾃⼰的锁。使⽤了多个⼦hash表(段Segment)，允<br>许多个读操作并发进⾏，读操作并不需要锁，因为它的HashEntry⼏乎是不可变的：30. jvm内存结构？为什么需要GC？<br>a. 内存结构：<br>b. 垃圾回收：垃圾回收可以有效的防⽌内存泄漏，有效的使⽤可以使⽤的内存。垃圾回收器通常是作为⼀个单独的低优先级的<br>线程运⾏，不可预知的情况下对内存堆中已经死亡的或者⻓时间没有使⽤的对象进⾏清除和回收，程序员不能实时的调⽤垃圾<br>回收器对某个对象或所有对象进⾏垃圾回收。回收机制有分代复制垃圾回收、标记垃圾回收、增量垃圾回收等⽅式。31. NIO模型，select&#x2F;epoll的区别，多路复⽤的原理？<br>1、io多路复⽤：<br>1、概念：IO多路复⽤是指内核⼀旦发现进程指定的⼀个或者多个IO条件准备读取，它就通知该进程。<br>2、优势：与多进程和多线程技术相⽐，I&#x2F;O多路复⽤技术的最⼤优势是系统开销⼩，系统不必创建进程&#x2F;线程，也不必维护<br>这些进程&#x2F;线程，从⽽⼤⼤减⼩了系统的开销。<br>3、系统：⽬前⽀持I&#x2F;O多路复⽤的系统调⽤有 select，pselect，poll，epoll。<br>2、select：select⽬前⼏乎在所有的平台上⽀持，其良好跨平台⽀持也是它的⼀个优点。select的⼀个缺点在于单个进程能够<br>监视的⽂件描述符的数量存在最⼤限制，在Linux上⼀般为1024，可以通过修改宏定义甚⾄重新编译内核的⽅式提升这⼀限制，<br>但是这样也会造成效率的降低。<br>3、poll：它没有最⼤连接数的限制，原因是它是基于链表来存储的，但是同样有⼀个缺点：<br>a. ⼤量的fd的数组被整体复制于⽤户态和内核地址空间之间，⽽不管这样的复制是不是有意义。<br>b. poll还有⼀个特点是“⽔平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<br>epoll跟select都能提供多路I&#x2F;O复⽤的解决⽅案。在现在的Linux内核⾥有都能够⽀持，其中epoll是Linux所特有，⽽select则应该是<br>POSIX所规定，⼀般操作系统均有实现。32. java中⼀个字符占多少个字节？int，long，double占多少个字节？<br>a. 1字节： byte , boolean<br>b. 2字节： short , char<br>c. 4字节： int , float<br>d. 8字节： long , double33. 创建⼀个类的实例都有哪些⽅法？<br>1 Object o &#x3D; new Object();<br>2 Object o &#x3D; oo.clone();<br>3 Object o &#x3D; Class.forName(“xxx”).newInstance();34. final&#x2F;finaly&#x2F;finalize区别？<br>a. final是定义类、⽅法、字段的修饰符，表示类不可被继承，⽅法不能被重写，字段值不能被修改<br>b. finally是异常处理机制的关键字，表示最后执⾏<br>c. finalize是Object的⼀个⽅法，在对象被虚拟机回收时会判断是否执⾏该⽅法，当对象没有覆盖finalize⽅法，或者finalize⽅法<br>已经被虚拟机调⽤过，虚拟机将这两种情况都视为“没有必要执⾏”35. Session&#x2F;Cookie区别？<br>Session存储在服务器端，类型可以是任意的Java对象，Cookie存储在客户端，类型只能为字符串36. String&#x2F;StringBuffer&#x2F;StringBuilder的区别以及实现？<br>a. String、StringBuffer是线程安全的，StringBuilder不是<br>b. String不继承任何类，StringBuffer、StringBuilder继承⾃AbstractStringBuilder<br>StringBuffer线程安全但效率低，应该使⽤在多线程情况下；<br>StringBuilder线程不安全，在单线程情况下效率⾼；37. Servlet⽣命周期<br>a. Servlet⽣命周期分为三个阶段：<br>1、初始化阶段 调⽤init()⽅法<br>　　2、响应客户请求阶段　　调⽤service()⽅法<br>　　3、终⽌阶段　　调⽤destroy()⽅法38. 如何⽤java分配⼀段连续的1G的内存空间?需要注意些什么？<br>1 ByteBuffer.allocateDirect(1024<em>1024</em>1024);<br>要注意内存溢出问题。39. Java有⾃⼰的内存回收机制，但为什么还存在内存泄漏的问题呢？<br>a. ⾸先内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄<br>漏堆积后果很严重，⽆论多少内存,迟早会被占光。<br>b. ⽐如下⾯这段代码，list持有o的引⽤，o暂时是⽆法被JVM垃圾回收的，只有当list被垃圾回收或者o从对象list删除掉后，o才<br>能被JVM垃圾回收。<br>1 List list &#x3D; new ArrayList();<br>2 Object o &#x3D; new Object();<br>3 list.add(o);<br>4 o &#x3D; null;40. 什么是java序列化，如何实现java序列化（写⼀个例⼦）<br>a.<br>1、原理：将对象写⼊流中,再从流中还原.ObjectOutPutStream<br>2、对象中的成员对象也是可序列化的,但可通过transient关键字标示不序列化<br>3、通过序列化进⾏深拷⻉,从流中还原对象<br>4、序列化作⽤：对象保存(保存为⼀组字节，只保存对象的成员变量)；当使⽤RMI(远程⽅法调⽤)，或者在⽹络中传递对象<br>时，都会使⽤对象序列化；<br>5、serialVersionUID 主要是解决序列化后与再反序列化时有修改的不兼容问题.<br>b. 序列化⼆叉树：<br>41. String s &#x3D; new String(“abc”)创建了⼏个String Object？<br>1、2个，会创建String对象在常量池和堆中。<br>2、String中的intern(),⾸先检查String pool是否有对应的字符串对象,如果有则返回，如果没有则在String pool中⽣成字符串，<br>并返回地址；<br>3.String中字⾯值”ab”之间拼接是在String pool中产⽣,⽽字⾯值与变量拼接字符串或者new String(“”)则是在堆中产⽣对象;42. 静态对象：<br>1.在main⽅法开始运⾏时需要注意static的先后顺序：静态变量和静态代码块(按代码先后顺序)—-匿名块和成员变量(按代码先<br>后顺序)—-构造函数—静态⽅法(调⽤时加载)<br>2.先执⾏⽗类的静态块,再执⾏⼦类的静态块,再执⾏⽗类的构造⽅法,再执⾏⼦类的构造⽅法<br>1、静态块&gt;构造⽅法；<br>2、⽗&gt;⼦43. final关键字：<br>1、⽤在类上不能被继承，abstract(需要被继承)和final不能共存；<br>2、⽤在⽅法上不能被重写<br>3、⽤在变量上表示⽅变量不能被改变<br>--对于final类的成员变量的初使化⽅式(基本数据类型)<br>1.申明变量时直接赋值<br>2.在构造⽅法中完成赋值,如果有多个构造⽅法,则每个都要完成final类变量的赋值<br>3.如果⼀个变量为static final则只能在申明时赋值<br>--对于final类型的引⽤变量来说,所谓的不能改变指的是该引⽤不能改变,值是可以改变的（如StringBuffer）<br>--为什么⼀般在public类final终态成员变量申明时要加static?<br>static对象存放在静态空间，不会在运⾏时被释放，可以节省内存，类的多个对象同时引⽤只有⼀份,没有多份拷⻉44. HashMap与HashTable的区别：<br>1.线程安全上,hashtable是同步的线程安全；hashmap是⾮同步的线程不安全，可接受null的值和value（hashtable不允许）；<br>2.对单线程来说,hashTable效率低<br>3、线程安全的类：vector(⽐arrayList多了同步机制，效率低不建议使⽤)、stack(堆栈类，先进后出)、hashtable(⽐hashmap<br>多了同步机制)、enumeration(枚举类)45. 多态：<br>1、多态条件：1.有继承 2. 有重写 3. 要有⽗类引⽤指向⼦类对象；如Animal a &#x3D; new Tiger();46. ⽗类或者接⼝引⽤指向⼦类或者实现该接⼝的类的对象；47. 多态是运⾏时⾏为,不是编绎时⾏为；48. 多态要有动态绑定，通过⽅法重写与⽅法重载来实现多态?? 这种说法是错误，因为⽅法重载是编译期决定好的,没有后期也就<br>是运⾏期的动态绑定；49. 集合删除：<br>注意: List底层为数组,删除时数组元素下标会被改变50. 跌代器调⽤.next()⽅法时,会检测是否有被修改过51. 如果要删除集合中的元素⼀定要⽤跌代器的remove()⽅法.52. 参数传递与引⽤传递：<br>1.基本数据类型传参,是数据值的拷⻉互不影响.<br>2.引⽤对象传参,是传地址,两个引⽤指向同⼀个对象,则对象改变两个引⽤也都改变(java编程只有值传递参数)53. hash冲突：<br>1、描述：当关键字值域远⼤于哈希表的⻓度，⽽且事先并不知道关键字的具体取值时，冲突就难免会发⽣。（两个或两个以上<br>的值hash计算的结果有相同的，造成冲突）<br>2、解决⽅法：<br>1、开放地址法：插⼊元素时，如果发⽣冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下⼀个空<br>槽，并将该元素放⼊该槽中（会导致相同hash值的元素挨在⼀起和其他hash值对应的槽被占⽤）。查找元素时，⾸先散列值所<br>指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到⼀个空槽，指示查找的元<br>素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）<br>2、链地址法：现⾏探测法的基本思想是将所有哈希地址为i的元素构成⼀个称为同义词链的单链表，并将单链表的头指针<br>存在哈希表的第i个单元中，因⽽查找、插⼊和删除主要在同义词链中进⾏。链地址法适⽤于经常进⾏插⼊和删除的情况。<br>3、在散列(双&#x2F;多重散列)：当发⽣冲突时，使⽤第⼆个、第三个、哈希函数计算地址，直到⽆冲突时。缺点：计算时间增<br>加。<br>4、建⽴⼀个公共溢出区：假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设⽴存储空间向量<br>OverTable[0..v]⽤以存储发⽣冲突的记录。54. 在java中⼀个字符能否表示⼀个汉字：<br>在java中,⼀个字符表示16位,相当于2个字节,⼀个汉字正好是2个字节55. ⼀致性hash：<br>1、⼀致性hash算法：我们的memcached客户端（这⾥我看的spymemcache的源码），使⽤了⼀致性hash算法ketama进⾏数据存储节点<br>的选择。与常规的hash算法思路不同，只是对我们要存储数据的key进⾏hash计算，分配到不同节点存储。⼀致性hash算法是对我们要存储数<br>据的服务器进⾏hash计算，进⽽确认每个key的存储位置。这⾥提到的⼀致性hash算法ketama的做法是：选择具体的机器节点不在只依赖需要<br>缓存数据的key的hash本身了，⽽是机器节点本身也进⾏了hash运算。<br>1、⼀致性hash算法是分布式系统中常⽤算法，设计⽬的是为了解决因特⽹中的热点(hot spot)问题。解决了P2P环境最为关键问<br>题—如何在动态⽹络拓扑中分布存储和路由；<br>2、⼀致性hash算法引⼊虚拟节点机制，解决服务节点少时数据倾斜问题(即对每⼀个服务节点计算多个哈希，每个计算结果位置都<br>放置⼀个此服务节点，称为虚拟节点。)；<br>2、具体做法：如果有⼀个写⼊缓存的请求，其中Key值为K，计算器hash值Hash(K)， Hash(K) 对应于图 – 1环中的某⼀个点，如果<br>该点对应没有映射到具体的某⼀个机器节点，那么顺时针查找，直到第⼀次找到有映射机器的节点，该节点就是确定的⽬标节点，如果超过了<br>2^32仍然找不到节点，则命中第⼀个机器节点。⽐如 Hash(K) 的值介于A~B之间，那么命中的机器节点应该是B节点（如上图 ）。<br>3、数据保存流程：<br>1、⾸先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。<br>2、然后采⽤同样的⽅法求出存储数据的键的哈希值，并映射到相同的圆上。<br>3、然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第⼀个服务器上。如果超过232仍然找不到服务器，就会保存到第<br>⼀台memcached服务器上。56. java反射机制<br>可以在运⾏时判断⼀个对象所属的类，构造⼀个类的对象，判断类具有的成员变量和⽅法，调⽤1个对象的⽅法。<br>4个关键的类：Class，Constructor，Field，Method。 getConstructor获得构造函数&#x2F;getDeclardConstructor；<br>getField&#x2F;getFields&#x2F;getDeclardFields获得类所⽣命的所有字段；getMethod&#x2F;getMethods&#x2F;getDeclardMethod获得类声明的所有⽅法，正<br>常⽅法是⼀个类创建对象，⽽反射是1个对象找到1个类。57. 幂等的处理⽅式：<br>接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。<br>⼀、查询操作是天然幂等<br>⼆、唯⼀索引，防⽌新增脏数据<br>三、token机制，防⽌⻚⾯重复提交<br>四、悲观锁 for update<br>五、乐观锁（通过版本号&#x2F;时间戳实现， 通过条件限制where avai_amount-#subAmount# &gt;&#x3D; 0）<br>六、分布式锁<br>七、状态机幂等（如果状态机已经处于下⼀个状态，这时候来了⼀个上⼀个状态的变更，理论上是不能够变更的，这样的话，保证<br>了有限状态机的幂等。）58. hashmap在jdk1.8中的改动?59. Jdk1.8以前是进⾏四次扰动计算，可能从速度功效各⽅⾯考虑，jdk1.8变成扰动⼀次，低16位和⾼16位进⾏异或计算。取模的时<br>候考虑取模运算的速度⽐较慢，改⽤与操作优化效率，很巧妙，hash table就没设计的这么好。60. JDK1.8⾥对hashmap最⼤的改变是引⼊了红⿊树，这⼀点在hash不均匀并且元素个数很多的情况时，对hashmap的性能提升⾮<br>常⼤。Hashmap的底层实现是使⽤⼀个entry数组存储，默认初始⼤⼩16，不过jdk8换了名字叫node，可能是因为引⼊了树，叫<br>node更合适吧，另外我也不喜欢entry这个名字，不能望⽂⽣义，我在刚学的时候还以为是什么神秘的东⻄呢，其实就是个键值对对<br>象⽽已。Node⾥有next引⽤指向下⼀个节点，因为hashmap解决冲突的思路是拉链法。61. 另外变化⽐较⼤的还有扩容机制，也就是resize⽅法。62. java 8 流式使⽤：<br>1 List&lt;Integer&gt; evens &#x3D; nums.stream().filter(num -&gt; num % 2 &#x3D;&#x3D; 0).collect(Collectors.toList());<br>2 &#x2F;&#x2F;1、stream()操作将集合转换成⼀个流，<br>3 &#x2F;&#x2F;2、filter()执⾏我们⾃定义的筛选处理，这⾥是通过lambda表达式筛选出所有偶数，<br>4 &#x2F;&#x2F;3、最后我们通过collect()对结果进⾏封装处理，并通过Collectors.toList()指定其封装成为⼀个List集合返回。63. java域的概念：<br>field，域是⼀种属性，可以是⼀个类变量，⼀个对象变量，⼀个对象⽅法变量或者是⼀个函数的参数。64. jdk1.8中ConcurrentHashMap size⼤于8时会转化成红⿊树，请问有什么作⽤，如果通过remove操作，size⼩于8了，会发⽣什<br>么？<br>put时如果链表size&gt;&#x3D;8并且table.length&gt;&#x3D;64，这时链表会转变成⼀个红⿊树（红⿊树是⼀个⾃平衡的⼆叉查找树，查找效率会从<br>链表的o(n)降低为o(logn)，效率是⾮常⼤的提⾼），但是remove不会逆转。65. 描述⼀下Hibernate的三个状态？<br>a. transient(瞬时状态)：new出来⼀个对象，还没被保存到数据库中<br>b. persistent(持久化状态)：对象已经保存到数据库中并且在hibernate session也存在该对象<br>c. detached(离线状态)：对象在数据库中存在，hibernate session不存在66. struts⼯作流程<br>1、客户端浏览器发出HTTP请求。<br>2、根据web.xml配置，该请求被FilterDispatcher接收。<br>3、根据struts.xml配置，找到需要调⽤的Action类和⽅法， 并通过IoC⽅式，将值注⼊给Aciton。<br>4、Action调⽤业务逻辑组件处理业务逻辑，这⼀步包含表单验证。<br>5、Action执⾏完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应⻚⾯。<br>6、返回HTTP响应到客户端浏览器。67. Hibernate对⼀⼆级缓存的使⽤， Lazy-Load的理解;<br>a. ⼀级缓存：hibernate的⼀级缓存是由session提供的，因此它只存在session的⽣命周期中。也就是说session关闭的时<br>候该session所管理的⼀级缓存也随之被清除。hibernate的⼀级缓存是session所内置的，默认开启，不能被卸载，也不<br>能进⾏任何配置。在缓存中的对象,具有持久性,session对象负责管理.⼀级缓存的优点是使⽤同⼀个session对象多次查询<br>同⼀个数据对象,仅对数据库查询⼀次。⼀级缓存采⽤的是Key-Value的MAP⽅式来实现的。在缓存实体对象时，对象的<br>主关键字ID是MAP的Key，实体对象就是对象的值。所以说⼀级缓存是以实体对象为单位进⾏存储的。访问的时候使⽤的<br>是主键关键字ID。⼀级缓存使⽤的是⾃动维护的功能。但可以通过session提供的⼿动⽅法对⼀级缓存的管理进⾏⼿动⼲<br>预。evict()⽅法⽤于将某个对象从session的⼀级缓存中清除。clear()⽅法⽤于将session缓存中的⽅法全部清除。<br>b. ⼆级缓存：⼆级缓存的实现原理与⼀级缓存是⼀样的。也是通过Key-Value的Map来实现对对象的缓存。⼆级缓存是作<br>⽤在SessionFactory范围内的。因此它可被所有的Session对象所共享。需要注意的是放⼊缓存中的数据不能有第三⽅的<br>应⽤对数据进⾏修改。⼆级缓存默认关闭，需要程序员⼿动开启，默认为ehcache实现.<br>c. 懒加载：当⽤到数据的时候才向数据库查询，这就是hibernate的懒加载特性。延迟加载策略能避免加载应⽤程序不需<br>要访问的关联对象，以提⾼应⽤程序的性能。68. mybatis如何实现批量提交？<br>a. 通过标签：</p><p>b. 通过ExecutorType.BATCH：<br>69. session机制？70. session是服务器的⽣成,并传⾄客户端浏览器,后续请求,都会通过URL重写传⾄服务器进⾏session⽐较.71. session是基于cookie72. session可以保存⽤户信息,但cookie如果浏览器被禁⽤,则⽆法保存⽤户信息73. 如果浏览器禁⽤会话cookie，则每次请求都⽆法将第⼀次请求获得的sessionId传⾄后台服务器.所以每次请求刷新⻚⾯服务<br>器都会⽣成新的sessionid给到浏览器74. 因HTTP协议为⽆状态的协议（⼀旦数据交互完毕，客户端和服务端的连接就会关闭，再次交换数据时需要建⽴新的连接）,需要<br>通过session或者cookie保存和跟踪⽤户信息<br>6、sessionID放在浏览器客户端cookie,其它信息放在服务器内存中，也可以做持久化管理memcached、redis中；75. Struts2表单重复提交问题（token拦截器）<br>1.访问⻚⾯前保存token(服务器后台⽣成的⼀串序列时间串放到session中)，并传⾄前台jsp⻚⾯中的隐藏域<br>2.提交时验证token,将前台的隐藏的token传⾄后台进⾏验证是否⼀致，提交随机⽣成新的token，可以防⽌重复提交；76. shiro：<br>1、定义：apache shiro是java的⼀个安全框架，简单易⽤，基本功能有：认证、授权、加密、会话管理、与Web集成、缓存<br>等。Shiro不会去维护⽤户、维护权限；这些需要我们⾃⼰去设计&#x2F;提供；然后通过相应的接⼝注⼊给Shiro即可(五张表)。<br>2、功能点：Authentication：身份认证&#x2F;登录，验证⽤户是不是拥有相应的身份；<br>Authorization：授权，即权限验证，验证某个已认证的⽤户是否拥有某个权限；即判断⽤户是否能做事情，常⻅的如：验<br>证某个⽤户是否拥有某个⻆⾊。或者细粒度的验证某个⽤户对某个资源是否具有某个权限；<br>Session Manager：会话管理，即⽤户登录后就是⼀次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通<br>JavaSE环境的，也可以是如Web环境的；<br>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，⽽不是明⽂存储；<br>Web Support：Web⽀持，可以⾮常容易的集成到Web环境；<br>Caching：缓存，⽐如⽤户登录后，其⽤户信息、拥有的⻆⾊&#x2F;权限不必每次去查，这样可以提⾼效率；<br>Concurrency：shiro⽀持多线程应⽤的并发验证，即如在⼀个线程中开启另⼀个线程，能把权限⾃动传播过去；<br>Testing：提供测试⽀持；<br>Run As：允许⼀个⽤户假装为另⼀个⽤户（如果他们允许）的身份进⾏访问；<br>Remember Me：记住我，这个是⾮常常⻅的功能，即⼀次登录后，下次再来的话不⽤登录了。<br>3、⼯作流程：<br>1、应⽤代码通过Subject(主体，代表当前”⽤户”)来进⾏认证和授权，⽽Subject⼜委托给SecurityManager(安全管理<br>器，shiro核⼼)；<br>2、我们需要给Shiro的SecurityManager注⼊Realm(域，Shiro从Realm获取安全数据（如⽤户、⻆⾊、权限）)，从⽽<br>让SecurityManager能得到合法的⽤户及其权限进⾏判断。1. Tomcat Filter过滤器责任链模式,过滤器拦截器区别?<br>1、责任链模式：将⼀个事件处理流程分派到⼀组执⾏对象上去，这⼀组执⾏对象形成⼀个链式结构，事件处理请求在这⼀组执⾏对<br>象上进⾏传递。<br>2、过滤器和拦截器：<br>1、过滤器filter：是在java web中，你传⼊的request,response提前过滤掉⼀些信息，或者提前设置⼀些参数，然后<br>再传⼊servlet或者struts的 action进⾏业务逻辑，⽐如过滤掉⾮法url（不是login.do的地址请求，如果⽤户没有登陆都过滤<br>掉）,或者在传⼊servlet或者 struts的action前统⼀设置字符集，或者去除掉⼀些⾮法字符；<br>2、拦截器interceptor：是在⾯向切⾯编程的就是在你的service或者⼀个⽅法，前调⽤⼀个⽅法，或者在⽅法后调⽤⼀个<br>⽅法⽐如动态代理就是拦截器的简单实现，在你调⽤⽅法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调⽤⽅法后打印出<br>字符串，甚⾄在你抛出异常的时候做业务逻辑的操作。拦截是AOP的⼀种实现策略；<br>3、区别：<br>a. 拦截器是基于java的反射机制的，⽽过滤器是基于函数回调。<br>b. 拦截器不依赖于servlet容器，过滤器依赖与servlet容器。<br>c. 拦截器只能对action请求起作⽤，⽽过滤器则可以对⼏乎所有的请求起作⽤。<br>d. 拦截器可以访问action上下⽂、值栈⾥的对象，⽽过滤器不能访问。<br>e. 在action的⽣命周期中，拦截器可以多次被调⽤，⽽过滤器只能在容器初始化时被调⽤⼀次<br>2. Git与Svn的区别：<br>1、Git是分布式的，⽽Svn不是；<br>2、GIT把内容按元数据⽅式存储，⽽SVN是按⽂件<br>3、分⽀不同：git分⽀切换很⽅便；svn分⽀就是版本库的另外⼀个⽬录；<br>4、GIT没有⼀个全局的版本号，⽽svn有，SVN的版本号实际是任何⼀个相应时间的源代码快照。<br>5、GIT的内容完整性要优于SVN(GIT的内容存储使⽤的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和⽹<br>络问题时降低对版本库的破坏。)<br>3. Git命令底层原理：<br>4. git init：使⽤git init初始化⼀个新的⽬录时，会⽣成⼀个.git的⽬录，该⽬录即为本地仓库。⼀个新初始化的本地仓库<br>是这样的：<br>1 !”” HEAD<br>2 !”” branches<br>3 !”” config<br>4 !”” description<br>5 !”” hooks<br>6 !”” objects<br>7 # !”” info<br>8 # <code>$&quot;&quot; pack 9 $</code>“” refs<br>10 !”” heads<br>11 $“” tags<br>description⽤于GitWeb程序<br>config配置特定于该仓库的设置（还记得git config的三个配置级别么）<br>hooks放置客户端或服务端的hook脚本<br>HEAD传说中的HEAD指针，指明当前处于哪个分⽀<br>objectsGit对象存储⽬录<br>refsGit引⽤存储⽬录<br>branches放置分⽀引⽤的⽬录<br>其中description、config和hooks这些不在讨论中，后⽂会直接忽略。<br>5. git add：Git commit之前先要通过git add添加⽂件：<br>可以看到，多了⼀个index⽂件。并且在objects⽬录下多了⼀个9f的⽬录，其中多了⼀个<br>4d96d5b00d98959ea9960f069585ce42b1349a⽂件。<br>其实9f4d96d5b00d98959ea9960f069585ce42b1349a就是⼀个Git对象，称为blob对象。<br>6. git commit：<br>7. JSP的执⾏过程：<br>1）客户端发出请求。<br>2）Web容器将JSP转译成Servlet源代码。<br>3）Web容器将产⽣的源代码进⾏编译。<br>4）Web容器加载编译后的代码并执⾏。<br>5）把执⾏结果响应⾄客户端。<br>8. ZK⾼可⽤：<br>9. ZooKeeper 运⾏期间，集群中⾄少有过半的机器保存了最新数据。集群超过半数的机器能够正常⼯作，集群就能够对<br>外提供服务。<br>10. zookeeper有什么功能，选举算法如何进⾏：<br>1、选举算法：<br>1、Fast Leader(领导者选举)选举算法：<br>1.server启动时默认选举⾃⼰，并向整个集群⼴播<br>2.收到消息时，通过3层判断：选举轮数，zxid，server id⼤⼩判断是否同意对⽅，如果同意，则修改⾃⼰的选<br>票，并向集群⼴播<br>3.QuorumCnxManager负责IO处理，每2个server建⽴⼀个连接，只允许id⼤的server连id⼩的server，每个<br>server启动单独的读写线程处理，使⽤阻塞IO<br>4.默认超过半数机器同意时，则选举成功，修改⾃身状态为LEADING或FOLLOWING<br>5.Obserer机器不参与选举<br>2、原理：选举结果的影响权重关系是:⾸先看数据id,数据id⼤者胜出;其次再判断leader id,leader id⼤者胜出。<br>3、举例：<br>假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数<br>据量这⼀点上,都是⼀样的.假设这些服务器依序启动,来看看会发⽣什么.1. 服务器1启动,此时只有它⼀台服务器启动了,它发出去的报没有任何响应,所以它的选举状态⼀直是LOOKING<br>状态；<br>2. 服务器2启动,它与最开始启动的服务器1进⾏通信,互相交换⾃⼰的选举结果,由于两者都没有历史数据,所以id<br>值较⼤的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例⼦中的半数以上是3),所以服务器1,2<br>还是继续保持LOOKING状态.<br>3. 服务器3启动,根据前⾯的理论分析,服务器3成为服务器1,2,3中的⽼⼤,⽽与上⾯不同的是,此时有三台服务器<br>选举了它,所以它成为了这次选举的leader.<br>4. 服务器4启动,根据前⾯的分析,理论上服务器4应该是服务器1,2,3,4中最⼤的,但是由于前⾯已经有半数以上的<br>服务器选举了服务器3,所以它只能接收当⼩弟的命了.<br>5. 服务器5启动,同4⼀样,当⼩弟.<br>4、zookeeper管理员指南：<br>1、集群中过半存活即可⽤，故集群选择奇数台机器；1. RPC、RMI、MQ、SOAP：<br>1、RPC:远程过程调⽤协议，采⽤C&#x2F;S模式，分布式跨语⾔平台，更多⽤于同步调⽤，⽐如Web Service(SOAP)；<br>2、RMI:远程⽅法调⽤，依赖于java远程消息交换协议，要求服务端与客户端都为java编写；每个⽅法都具有⽅法签名，只有签名<br>匹配才可以调⽤，返回值是基本类型和对象；<br>3、MQ:队列，更多⽤于异步传输；<br>4、SOAP最主要的⼯作是使⽤标准的XML描述了RPC的请求信息(URI&#x2F;类&#x2F;⽅法&#x2F;参数&#x2F;返回值)。理论上，SOAP就是⼀段xml，你可<br>以通过http,smtp等发送它(复制到软盘上，叫快递公司送去也⾏?)。同样SOAP也是跨语⾔的。<br>2. Netty⾼性能：<br>1、NIO异步⾮阻塞通信<br>2、“零拷⻉”<br>3、内存池ByteBuf<br>4、Netty提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。<br>5、⾼效的Reactor线程模型：Reactor单线程(多线程、主从)模型，指的是所有的IO操作都在同⼀个NIO线程上⾯完成<br>6、为了尽可能提升性能，Netty采⽤了串⾏⽆锁化设计，在IO线程内部进⾏串⾏操作，避免多线程竞争导致的性能下降。表⾯上<br>看，串⾏化设计似乎CPU利⽤率不⾼，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串⾏化的线程并⾏运<br>⾏，这种局部⽆锁化的串⾏线程设计相⽐⼀个队列-多个⼯作线程模型性能更优。<br>7、⾼效的并发编程：Netty的⾼效并发编程主要体现在如下⼏点：1. volatile的⼤量、正确使⽤;<br>2. CAS和原⼦类的⼴泛使⽤；<br>3. 线程安全容器的使⽤；<br>4. 通过读写锁提升并发性能。<br>8、⾼效的序列化框架：<br>9、灵活的TCP参数配置能⼒：合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和<br>SO_SNDBUF。如果设置不当，对性能的影响是⾮常⼤的。1. 如何保证服务的幂等性？<br>1、概念：接⼝的幂等性实际上就是接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。有些<br>接⼝可以天然的实现幂等性，⽐如查询接⼝，对于查询来说，你查询⼀次和两次，对于系统来说，没有任何影响，查出<br>的结果也是⼀样。<br>2、GET幂等：值得注意，幂等性指的是作⽤于结果⽽⾮资源本身。怎么理解呢？例如，这个HTTP GET⽅法可能会每次<br>得到不同的返回内容，但并不影响资源。<br>3、POST⾮幂等：因为它会对资源本身产⽣影响，每次调⽤都会有新的资源产⽣，因此不满⾜幂等性。<br>4、如何保证幂等性：<br>1、全局唯⼀id：如果使⽤全局唯⼀ID，就是根据业务的操作和内容⽣成⼀个全局ID，在执⾏操作前先根据这个全局唯<br>⼀ID是否存在，来判断这个操作是否已经执⾏。如果不存在则把全局ID，存储到存储系统中，⽐如数据库、redis等。如<br>果存在则表示该⽅法已经执⾏。<br>从⼯程的⻆度来说，使⽤全局ID做幂等可以作为⼀个业务的基础的微服务存在，在很多的微服务中都会⽤到这样的<br>服务，在每个微服务中都完成这样的功能，会存在⼯作量重复。另外打造⼀个⾼可靠的幂等服务还需要考虑很多问题，<br>⽐如⼀台机器虽然把全局ID先写⼊了存储，但是在写⼊之后挂了，这就需要引⼊全局ID的超时机制。<br>使⽤全局唯⼀ID是⼀个通⽤⽅案，可以⽀持插⼊、更新、删除业务操作。但是这个⽅案看起来很美但是实现起来⽐<br>较麻烦，下⾯的⽅案适⽤于特定的场景，但是实现起来⽐较简单。<br>2、去重表：这种⽅法适⽤于在业务中有唯⼀标的插⼊场景中，⽐如在以上的⽀付场景中，如果⼀个订单只会⽀付⼀<br>次，所以订单ID可以作为唯⼀标识。这时，我们就可以建⼀张去重表，并且把唯⼀标识作为唯⼀索引，在我们实现时，<br>把创建⽀付单据和写⼊去去重表，放在⼀个事务中，如果重复创建，数据库会抛出唯⼀约束异常，操作就会回滚。<br>3、插⼊或更新：这种⽅法插⼊并且有唯⼀索引的情况，⽐如我们要关联商品品类，其中商品的ID和品类的ID可以构成<br>唯⼀索引，并且在数据表中也增加了唯⼀索引。这时就可以使⽤InsertOrUpdate操作。在mysql数据库中如下：<br>1 insert into goods_category (goods_id,category_id,create_time,update_time)<br>2 values(#{goodsId},#{categoryId},now(),now())<br>3 on DUPLICATE KEY UPDATE<br>4 update_time&#x3D;now()<br>4、多版本控制：这种⽅法适合在更新的场景中，⽐如我们要更新商品的名字，这时我们就可以在更新的接⼝中增加⼀<br>个版本号，来做幂等<br>1 boolean updateGoodsName(int id,String newName,int version);<br>在实现时可以如下<br>1 update goods set name&#x3D;#{newName},version&#x3D;#{version} where id&#x3D;#{id} and version&lt;${version}<br>5、状态机控制：这种⽅法适合在有状态机流转的情况下，⽐如就会订单的创建和付款，订单的付款肯定是在之前，这<br>时我们可以通过在设计状态字段时，使⽤int类型，并且通过值类型的⼤⼩来做幂等，⽐如订单的创建为0，付款成功为<br>100。付款失败为99<br>在做状态机更新时，我们就这可以这样控制<br>1 update <code>order</code> set status&#x3D;#{status} where id&#x3D;#{id} and status&lt;#{status}<br>2. zookeeper⼯作原理？<br>1、定义：zookeeper是⼀种为分布式应⽤所设计的⾼可⽤、⾼性能且⼀致的开源协调服务，它提供了⼀项基本服务：分<br>布式锁服务。后来摸索出了其他使⽤⽅法：配置维护、组服务、分布式消息队列、分布式通知&#x2F;协调等。<br>2、特点：<br>1、能够⽤在⼤型分布式系统中；<br>2、具有⼀致性、可⽤性、容错性，不会因为⼀个节点的错误⽽崩溃；<br>3、⽤途：⽤户⼤型分布式系统，作协调服务⻆⾊；<br>1、分布式锁应⽤：通过对集群进⾏master选举，来解决分布式系统中的单点故障（⼀主n从，主挂全挂）。<br>2、协调服务；<br>3、注册中⼼；<br>4、原理：<br>术语：<br>数据结构Znode：zookeeper数据采⽤树形层次结构，和标准⽂件系统⾮常相似，树中每个节点被称为Znode；<br>通知机制Watcher：zookeeper可以为所有的读操作（exists()、getChilden()及getData()）设置watch，<br>watch事件是⼀次性出发器，当watch的对象状态发⽣改变时，将会触发次对象上watch所对应的事件。watch事件将被异步的发送<br>给客户端，并且zookeeper为watch机制提供了有序的⼀致性保证。<br>基本流程：分布式锁应⽤场景<br>1、传统的⼀主n从分布式系统，容易发⽣单点故障，传统解决⽅式是增加⼀个备⽤节点，定期给主节点发送Ping包，主<br>节点回复ack，但是如果⽹络原因ack丢失，那么会出现两个主节点，造成数据混乱。<br>2、zookeeper的引⼊可以管理两个主节点，其中挂了⼀个，会将另外⼀个作为新的主节点，挂的节点回来时担任备⽤节<br>点；<br>3. cap理论：<br>1、概念：⼀个分布式系统最多只能同时满⾜⼀致性（Consistency）、可⽤性（Availability）和分区容错性（Partition<br>tolerance）这三项中的两项。<br>2、⼀致性：更新操作成功并返回客户端完成后，所有节点在同⼀时间的数据完全⼀致，所以，⼀致性，说的就是数据⼀<br>致性。<br>3、可⽤性：服务⼀直可⽤，⽽且是正常响应时间。<br>4、分区容错性：分布式系统在遇到某节点或⽹络分区故障的时候，仍然能够对外提供满⾜⼀致性和可⽤性的服务。Java 基础<br>1.JDK 和 JRE 有什么区别？<br>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。<br>2.&#x3D;&#x3D; 和 equals 的区别是什么？<br>&#x3D;&#x3D; 解读<br>对于基本类型和引用类型 &#x3D;&#x3D; 的作用效果是不同的，如下所示：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：<br>String x &#x3D; “string”;<br>String y &#x3D; “string”;<br>String z &#x3D; new String(“string”);<br>System.out.println(xy); &#x2F;&#x2F; true<br>System.out.println(xz); &#x2F;&#x2F; false<br>System.out.println(x.equals(y)); &#x2F;&#x2F; true<br>System.out.println(x.equals(z)); &#x2F;&#x2F; true<br>代码解读：因为 x 和 y 指向的是同一个引用，所以 &#x3D;&#x3D; 也是 true，而 new String()方法则重写开辟了内存空间，所以 &#x3D;&#x3D; 结果为 false，而 equals 比较的一直是值，所以结果都为 true。<br>equals 解读<br>equals 本质上就是 &#x3D;&#x3D;，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。<br>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：<br>class Cat {<br>public Cat(String name) {<br>this.name &#x3D; name;<br>}<br>private String name;public String getName() {<br>return name;<br>}public void setName(String name) {<br>this.name &#x3D; name;<br>}<br>}<br>Cat c1 &#x3D; new Cat(“王磊”);<br>Cat c2 &#x3D; new Cat(“王磊”);<br>System.out.println(c1.equals(c2)); &#x2F;&#x2F; false<br>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：<br>public boolean equals(Object obj) {<br>return (this &#x3D;&#x3D; obj);<br>}<br>原来 equals 本质上就是 &#x3D;&#x3D;。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：<br>String s1 &#x3D; new String(“老王”);<br>String s2 &#x3D; new String(“老王”);<br>System.out.println(s1.equals(s2)); &#x2F;&#x2F; true<br>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：<br>public boolean equals(Object anObject) {<br>if (this &#x3D;&#x3D; anObject) {<br>return true;<br>}<br>if (anObject instanceof String) {<br>String anotherString &#x3D; (String)anObject;<br>int n &#x3D; value.length;<br>if (n &#x3D;&#x3D; anotherString.value.length) {<br>char v1[] &#x3D; value;<br>char v2[] &#x3D; anotherString.value;<br>int i &#x3D; 0;<br>while (n– !&#x3D; 0) {<br>if (v1[i] !&#x3D; v2[i])<br>return false;<br>i++;<br>}<br>return true;<br>}<br>}<br>return false;<br>}<br>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br>总结 ：&#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。<br>3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？<br>不对，两个对象的 hashCode() 相同，equals() 不一定 true。<br>代码示例：<br>String str1 &#x3D; “通话”;<br>String str2 &#x3D; “重地”;<br>System. out. println(String. format(“str1：%d | str2：%d”, str1. hashCode(),str2. hashCode()));<br>System. out. println(str1. equals(str2));<br>执行的结果：<br>str1：1179395 | str2：1179395<br>false<br>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。<br>4.final 在 Java 中有什么作用？<br>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。<br>5.Java 中的 Math. round(-1. 5) 等于多少？<br>等于 -1，Math. round 四舍五入大于 0. 5 向上取整的。<br>6.String 属于基础的数据类型吗？<br>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。<br>7.Java 中操作字符串都有哪些类？它们之间有什么区别？<br>操作字符串的类有：String、StringBuffer、StringBuilder。<br>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br>8.String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？<br>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。<br>9.如何将字符串反转？<br>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br>示例代码：<br>&#x2F;&#x2F; StringBuffer reverse<br>StringBuffer stringBuffer &#x3D; new StringBuffer();<br>stringBuffer. append(“abcdefg”);<br>System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba<br>&#x2F;&#x2F; StringBuilder reverse<br>StringBuilder stringBuilder &#x3D; new StringBuilder();<br>stringBuilder. append(“abcdefg”);<br>System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba1. String 类的常用方法都有那些？<br>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。<br>2. 抽象类必须要有抽象方法吗？<br>不需要，抽象类不一定非要有抽象方法。<br>示例代码：<br>abstract class Cat {<br>public static void sayHi() {<br>System. out. println(“hi~”);<br>}<br>}<br>上面代码，抽象类并没有抽象方法但完全可以正常运行。<br>12.普通类和抽象类有哪些区别？<br>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。<br>13.抽象类能使用 final 修饰吗？<br>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：<br>编译器保存图<br>14.接口和抽象类有什么区别？<br>默认方法实现：抽象类可以有默认的方法实现；接口不能有默认的方法实现。<br>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>构造函数：抽象类可以有构造函数；接口不能有。<br>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。<br>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。<br>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。<br>15.Java 中 IO 流分为几种？<br>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。<br>16.BIO、NIO、AIO 有什么区别？<br>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。<br>17.Files的常用方法都有哪些？<br>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。<br>容器<br>18.Java 容器都有哪些？<br>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：<br>Collection<br>List<br>ArrayList<br>LinkedList<br>Vector<br>Stack<br>Set<br>HashSet<br>LinkedHashSet<br>TreeSet<br>Map<br>HashMap<br>LinkedHashMap<br>TreeMap<br>ConcurrentHashMap<br>Hashtable<br>3. Collection 和 Collections 有什么区别？<br>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。<br>4. List、Set、Map 之间的区别是什么？<br>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：<br>区别图<br>22.如何决定使用 HashMap 还是 TreeMap？<br>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。<br>23.说一下 HashMap 的实现原理？<br>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。<br>24.说一下 HashSet 的实现原理？<br>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。<br>25.ArrayList 和 LinkedList 的区别是什么？<br>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。<br>26.如何实现数组和 List 之间的转换？<br>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：<br>&#x2F;&#x2F; list to array<br>List list &#x3D; new ArrayList();<br>list. add(“王磊”);<br>list. add(“的博客”);<br>list. toArray();<br>&#x2F;&#x2F; array to list<br>String[] array &#x3D; new String[]{“王磊”,“的博客”};<br>Arrays. asList(array);<br>5. ArrayList 和 Vector 的区别是什么？<br>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。<br>6. Array 和 ArrayList 有何区别？<br>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。<br>7. 在 Queue 中 poll()和 remove()有什么区别？<br>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。<br>代码示例：<br>Queue queue &#x3D; new LinkedList();<br>queue. offer(“string”); &#x2F;&#x2F; add<br>System. out. println(queue. poll());<br>System. out. println(queue. remove());<br>System. out. println(queue. size());<br>8. 哪些集合类是线程安全的？<br>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。<br>31.迭代器 Iterator 是什么？<br>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。<br>32.Iterator 怎么使用？有什么特点？<br>Iterator 使用代码如下：<br>List list &#x3D; new ArrayList&lt;&gt;();<br>Iterator it &#x3D; list. iterator();<br>while(it. hasNext()){<br>String obj &#x3D; it. next();<br>System. out. println(obj);<br>}<br>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。<br>33.Iterator 和 ListIterator 有什么区别？<br>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。<br>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。<br>34.怎么确保一个集合不能被修改？<br>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下：<br>List list &#x3D; new ArrayList&lt;&gt;();<br>list. add(“x”);<br>Collection clist &#x3D; Collections. unmodifiableCollection(list);<br>clist. add(“y”); &#x2F;&#x2F; 运行时此行报错<br>System. out. println(list. size());<br>多线程<br>9. 并行和并发有什么区别？<br>并行：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>并发：多个处理器或多核处理器同时处理多个任务。<br>如下图：<br>并发和并行<br>并发 &#x3D; 两个队列和一台咖啡机。<br>并行 &#x3D; 两个队列和两台咖啡机。<br>36.线程和进程的区别？<br>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。<br>37.守护线程是什么？<br>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。<br>47.在 Java 程序中怎么保证多线程的运行安全？<br>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：<br>Lock lock &#x3D; new ReentrantLock();<br>lock. lock();<br>try {<br>System. out. println(“获得锁”);<br>} catch (Exception e) {<br>&#x2F;&#x2F; TODO: handle exception<br>} finally {<br>System. out. println(“释放锁”);<br>lock. unlock();<br>}<br>13. 多线程中 synchronized 锁升级的原理是什么？<br>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。<br>52.说一下 synchronized 底层实现原理？<br>synchronized 是由一对 monitorenter&#x2F;monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。<br>53.synchronized 和 volatile 的区别是什么？<br>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。<br>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>14. 说一下 atomic 的原理？<br>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>反射<br>15. 什么是反射？<br>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。<br>58.什么是 Java 序列化？什么情况下需要序列化？<br>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：<br>想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>想用套接字在网络上传送对象的时候；<br>想通过RMI（远程方法调用）传输对象的时候。<br>16. 动态代理是什么？有哪些应用？<br>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。<br>60.怎么实现动态代理？<br>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。<br>对象拷贝<br>17. 为什么要使用克隆？<br>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。<br>62.如何实现对象克隆？<br>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。<br>63.深拷贝和浅拷贝区别是什么？<br>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。<br>Java Web<br>64.JSP 和 servlet 有什么区别？<br>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。<br>71.如何避免 SQL 注入？<br>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。<br>72.什么是 XSS 攻击，如何避免？<br>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br>预防 XSS 的核心是必须对输入的数据做过滤处理。<br>73.什么是 CSRF 攻击，如何避免？<br>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br>防御手段：<br>验证请求来源地址；<br>关键操作添加验证码；<br>在请求地址添加 token 并验证。<br>异常<br>21. throw 和 throws 的区别？<br>throw：是真实抛出一个异常。<br>throws：是声明可能会抛出一个异常。<br>23. try-catch-finally 中哪个部分可以省略？<br>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。<br>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？<br>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。<br>78.常见的异常类有哪些？<br>NullPointerException 空指针异常<br>ClassNotFoundException 指定类不存在<br>NumberFormatException 字符串转换为数字异常<br>IndexOutOfBoundsException 数组下标越界异常<br>ClassCastException 数据类型转换异常<br>FileNotFoundException 文件未找到异常<br>NoSuchMethodException 方法不存在异常<br>IOException IO 异常<br>SocketException Socket 异常<br>网络<br>79.http 响应码 301 和 302 代表的是什么？有什么区别？<br>301：永久重定向。<br>302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。<br>80.forward 和 redirect 的区别？<br>forward 是转发 和 redirect 是重定向：<br>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；<br>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；<br>效率：forward 比 redirect 效率高。<br>24. 简述 tcp 和 udp的区别？<br>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：<br>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；<br>tcp 提供可靠的服务（数据传输），udp 无法保证；<br>tcp 面向字节流，udp 面向报文；<br>tcp 数据传输慢，udp 数据传输快；<br>83.说一下 tcp 粘包是怎么产生的？<br>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<br>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。<br>26. OSI 的七层模型都有哪些？<br>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>数据链路层：负责建立和管理节点间的链路。<br>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。<br>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>会话层：向两个实体的表示层提供建立和使用连接的方法。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。<br>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。<br>27. get 和 post 请求有哪些区别？<br>get 请求会被浏览器主动缓存，而 post 不会。<br>get 传递参数有大小限制，而 post 没有。<br>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。<br>28. 如何实现跨域？<br>实现跨域有以下几种方案：<br>服务器端运行跨域 设置 CORS 等于 *；<br>在单个接口使用注解 @CrossOrigin 运行跨域；<br>使用 jsonp 跨域；<br>29. 说一下 JSONP 实现原理？<br>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。<br>设计模式<br>32. 为什么要使用 spring？<br>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。<br>spring 提供了事务支持，使得事务操作变的更加方便。<br>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。<br>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。<br>106.spring boot 核心配置文件是什么？<br>spring boot 核心的两个配置文件：<br>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。<br>36. spring boot 配置文件有哪几种类型？它们有什么区别？<br>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。<br>. properties 配置如下：<br>spring. RabbitMQ. port&#x3D;5672<br>. yml 配置如下：<br>spring:<br>RabbitMQ:<br>port: 5672<br>. yml 格式不支持 @PropertySource 注解导入。<br>108.spring boot 有哪些方式可以实现热部署？<br>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，沟上自动编译或手动重新编译。<br>109.jpa 和 hibernate 有什么区别？<br>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。<br>110.什么是 spring cloud？<br>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。<br>111.spring cloud 断路器的作用是什么？<br>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。<br>112.spring cloud 的核心组件有哪些？<br>Eureka：服务注册于发现。<br>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。<br>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。<br>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。<br>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。<br>Hibernate<br>113.为什么要使用 hibernate？<br>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。<br>可以很方便的进行数据库的移植工作。<br>提供了缓存机制，是程序执行更改的高效。<br>114.什么是 ORM 框架？<br>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。<br>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。<br>115.hibernate 中如何在控制台查看打印的 SQL 语句？<br>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。<br>116.hibernate 有几种查询方式？<br>三种：hql、原生 SQL、条件查询 Criteria。<br>117.hibernate 实体类可以被定义为 final 吗？<br>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。<br>118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？<br>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。<br>119.hibernate 是如何工作的？<br>读取并解析配置文件。<br>读取并解析映射文件，创建 SessionFactory。<br>打开 Session。<br>创建事务。<br>进行持久化操作。<br>提交事务。<br>关闭 Session。<br>关闭 SessionFactory。<br>120.get()和 load()的区别？<br>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。<br>load()支持延迟加载；get() 不支持延迟加载。<br>121.说一下 hibernate 的缓存机制？<br>hibernate 常用的缓存有一级缓存和二级缓存：<br>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；<br>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。<br>122.hibernate 对象有哪些状态？<br>临时&#x2F;瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>持久化状态：当调用 Session 的 save&#x2F;saveOrupdate&#x2F;get&#x2F;load&#x2F;list 等方法的时候，对象就是持久化状态。<br>游离状态：Session 关闭之后对象就是游离状态。<br>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？<br>getCurrentSession 会绑定当前线程，而 openSession 则不会。<br>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。<br>124.hibernate 实体类必须要有无参构造函数吗？为什么？<br>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。<br>MyBatis<br>37. MyBatis 中 #{}和 的区别是什么？#是预编译处理，{}的区别是什么？#{}是预编译处理，的区别是什么？#是预编译处理，{}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。<br>126.MyBatis 有几种分页方式？<br>分页方式：逻辑分页和物理分页。<br>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。<br>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。<br>127.RowBounds 是一次性查询全部结果吗？为什么？<br>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更的数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。<br>Fetch Size 官方相关文档：<a target="_blank" rel="noopener" href="http://t/">http://t</a>. cn&#x2F;EfSE2g3<br>128.MyBatis 逻辑分页和物理分页的区别是什么？<br>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。<br>129.MyBatis 是否支持延迟加载？延迟加载的原理是什么？<br>MyBatis 支持延迟加载，设置 lazyLoadingEnabled&#x3D;true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。<br>130.说一下 MyBatis 的一级缓存和二级缓存？<br>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session&#x2F;二级缓存 Mapper)进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。<br>131.MyBatis 和 hibernate 的区别有哪些？<br>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。<br>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。<br>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。<br>132.MyBatis 有哪些执行器（Executor）？<br>MyBatis 有三种基本的Executor执行器：<br>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；<br>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；<br>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。<br>38. MyBatis 分页插件的实现原理是什么？<br>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。<br>134.MyBatis 如何编写一个自定义插件？<br>自定义插件实现原理<br>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：<br>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；<br>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；<br>ParameterHandler：拦截参数的处理；<br>ResultSetHandler：拦截结果集的处理。<br>自定义插件实现关键<br>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：<br>public interface Interceptor {<br>Object intercept(Invocation invocation) throws Throwable;<br>Object plugin(Object target);<br>void setProperties(Properties properties);<br>}<br>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；<br>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；<br>intercept 方法就是要进行拦截的时候要执行的方法。<br>自定义插件实现示例<br>官方插件实现：<br>@Intercepts({@Signature(type &#x3D; Executor. class, method &#x3D; “query”,<br>args &#x3D; {MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class})})<br>public class TestInterceptor implements Interceptor {<br>public Object intercept(Invocation invocation) throws Throwable {<br>Object target &#x3D; invocation. getTarget(); &#x2F;&#x2F;被代理对象<br>Method method &#x3D; invocation. getMethod(); &#x2F;&#x2F;代理方法<br>Object[] args &#x3D; invocation. getArgs(); &#x2F;&#x2F;方法参数<br>&#x2F;&#x2F; do something . . . . . . 方法拦截前执行代码块<br>Object result &#x3D; invocation. proceed();<br>&#x2F;&#x2F; do something . . . . . . . 方法拦截后执行代码块<br>return result;<br>}<br>public Object plugin(Object target) {<br>return Plugin. wrap(target, this);<br>}<br>}<br>RabbitMQ<br>39. RabbitMQ 的使用场景有哪些？<br>抢购活动，削峰填谷，防止系统崩塌。<br>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。<br>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。<br>40. RabbitMQ 有哪些重要的角色？<br>RabbitMQ 中重要的角色有：生产者、消费者和代理：<br>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。<br>41. RabbitMQ 有哪些重要的组件？<br>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。<br>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。<br>42. RabbitMQ 中 vhost 的作用是什么？<br>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。<br>139.RabbitMQ 的消息是怎么发送的？<br>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。<br>140.RabbitMQ 怎么保证消息的稳定性？<br>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。<br>141.RabbitMQ 怎么避免消息丢失？<br>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。<br>142.要保证消息持久化成功的条件有哪些？<br>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。<br>143.RabbitMQ 持久化有什么缺点？<br>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。<br>144.RabbitMQ 有几种广播类型？<br>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。<br>145.RabbitMQ 怎么实现延迟消息队列？<br>延迟队列的实现有两种方式：<br>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。<br>43. RabbitMQ 集群有什么用？<br>集群主要有以下两个用途：<br>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。<br>44. RabbitMQ 节点的类型有哪些？<br>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。<br>45. RabbitMQ 集群搭建需要注意哪些问题？<br>各节点之间使用“–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。<br>46. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？<br>不是，原因有以下两个：<br>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。<br>47. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？<br>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<br>不能创建队列<br>不能创建交换器<br>不能创建绑定<br>不能添加用户<br>不能更改权限<br>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。<br>151.RabbitMQ 对集群节点停止顺序有要求吗？<br>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。<br>Kafka<br>48. kafka 可以脱离 zookeeper 单独使用吗？为什么？<br>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。<br>153.kafka 有几种数据保留的策略？<br>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。<br>154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？<br>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。<br>155.什么情况会导致 kafka 运行变慢？<br>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈<br>156.使用 kafka 集群需要注意什么？<br>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。<br>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。<br>Zookeeper<br>157.zookeeper 是什么？<br>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>158.zookeeper 都有哪些功能？<br>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。<br>159.zookeeper 有几种部署模式？<br>zookeeper 有三种部署模式：<br>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。<br>49. zookeeper 怎么保证主从节点的状态同步？<br>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。<br>161.集群中为什么要有主节点？<br>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。<br>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？<br>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。<br>163.说一下 zookeeper 的通知机制？<br>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。<br>MySQL<br>50. 数据库的三范式是什么？<br>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。<br>51. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？<br>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。<br>166.如何获取当前数据库版本？<br>使用 select version() 获取当前 MySQL 数据库版本。<br>167.说一下 ACID 是什么？<br>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>168.char 和 varchar 的区别是什么？<br>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。<br>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。<br>169.float 和 double 的区别是什么？<br>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。<br>170.MySQL 的内连接、左连接、右连接有什么区别？<br>内连接关键字：inner join；左连接：left join；右连接：right join。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。<br>171.MySQL 索引是怎么实现的？<br>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。<br>172.怎么验证 MySQL 的索引是否满足需求？<br>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br>explain 语法：explain select * from table where type&#x3D;1。<br>173.说一下数据库的事务隔离？<br>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：<br>transaction-isolation &#x3D; REPEATABLE-READ<br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。<br>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。<br>177.MySQL 问题排查都有哪些手段？<br>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。<br>185.Redis 支持的 Java 客户端都有哪些？<br>支持的 Java 客户端有 Redisson、jedis、lettuce 等。<br>186.jedis 和 Redisson 有哪些区别？<br>jedis：提供了比较全面的 Redis 命令的支持。<br>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p><p>191.Redis 如何做内存优化？<br>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。<br>192.Redis 淘汰策略有哪些？<br>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。<br>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。<br>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。<br>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。<br>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。<br>193.Redis 常见的性能问题有哪些？该如何解决？<br>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。<br>JVM<br>194.说一下 JVM 的主要组成部分？及其作用？<br>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）<br>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。<br>195.说一下 JVM 运行时数据区？<br>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：<br>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；<br>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<br>196.说一下堆栈的区别？<br>功能方面：堆是用来存放对象的，栈是用来执行程序的。<br>共享性：堆是线程共享的，栈是线程私有的。<br>空间大小：堆大小远远大于栈。<br>197.队列和栈是什么？有什么区别？<br>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。<br>198.什么是双亲委派模型？<br>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br>类加载器分类：<br>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。<br>199.说一下类加载的执行过程？<br>类加载分为以下 5 个步骤：<br>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。<br>57. 怎么判断对象是否可以被回收？<br>一般有两种方法来判断：<br>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。<br>58. Java 中都有哪些引用类型？<br>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。<br>207.说一下 JVM 调优的工具？<br>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。<br>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。<br>62. 常用的 JVM 调优的参数都有哪些？<br>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。<br>一、Java 基础部分</p><ol><li>JAVA 的基本数据类型有哪些 ? String 是不是基本数据类型 ?<br>Java 有 8 种基本数据类型: byte int short long double float Boolean char<br>byte int short long 都属于整数类型. Double float 属于浮点类型. Boolean 为布尔类型<br>Char 为字符型<br>String 不是基本数据类型.它定义的为对象</li><li>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>可以有多个类，但只能有一个 public 的类，并且 public 的类名必须与文件名相一致。</li><li>Java 有没有 goto?<br>java 中的保留字，现在没有在 java 中使用。</li><li>说说&amp;和&amp;&amp;的区别. &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都<br>为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。<br>&amp;&amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，例如，对<br>于 if(str !&#x3D; null &amp;&amp; !str.equals(“”))表达式，当 str 为 null 时，后面的表达式不会执行，所以不<br>会出现 NullPointerException 如果将&amp;&amp;改为&amp;，则会抛出 NullPointerException 异常。If(x&#x3D;&#x3D;33<br>&amp; ++y&gt;0) y 会增长，If(x&#x3D;&#x3D;33 &amp;&amp; ++y&gt;0)不会增长<br>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是 boolean 类型时，&amp;表示按位与操作，<br>我们通常使用 0x0f 来与一个整数进行&amp;运算，来获取该整数的最低 4 个 bit 位，例如，0x31<br>&amp; 0x0f 的结果为 0x01。<br>备注：这道题先说两者的共同点，再说出&amp;&amp;和&amp;的特殊之处，并列举一些经典的例子来表<br>明自己理解透彻深入、实际经验丰富。</li><li>在 JAVA 中如何跳出当前的多重嵌套循环？<br>在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环<br>体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如，<br>另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里<br>层循环体代码的控制，例如，要在二维数组中查找到某个数字。</li><li>switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上?<br>在 switch（expr1）中，expr1 只能是一个整数表达式或者枚举常量（更大字体），整数表达<br>式可以是 int 基本类型或 Integer 包装类型，由于，byte,short,char 都可以隐含转换为 int，所<br>以，这些类型以及这些类型的包装类型也是可以的。显然，long 和 String 类型都不符合 switch<br>的语法规定，并且不能被隐式转换成 int 类型，所以，它们不能作用于 swtich 语句中。</li><li>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 由于 s1+1 运算时会自动提升表达式的类型，所以结果是 int 型，<br>再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误。<br>对于 short s1 &#x3D; 1; s1 +&#x3D; 1;由于 +&#x3D; 是 java 语言规定的运算符，java 编译器会对它进行特殊处<br>理，因此可以正确编译。</li><li>char 型变量中能不能存贮一个中文汉字?为什么?<br>char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，<br>char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码<br>字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占<br>用两个字节，所以，char 类型的变量也是占用两个字节。</li><li>用最有效率的方法算出 2 乘以 8 等於几?<br>2 &lt;&lt; 3，<br>因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3<br>位即可，而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2 &lt;&lt;<br>3。</li><li>请设计一个一百亿的计算器<br>首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要<br>知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的<br>面向对象的设计思想。<br>首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一<br>定的范围的，为了便于讲解和理解，我们先以 byte 类型的整数为例，它用 1 个字节进行存<br>储，表示的最大数值范围为-128 到+127。-1 在内存中对应的二进制数据为 11111111，如果<br>两个-1 相加，不考虑 Java 运算时的类型提升，运算后会产生进位，二进制结果为 1,11111110，<br>由于进位后超过了 byte 类型的存储空间，所以进位部分被舍弃，即最终的结果为 11111110，<br>也就是-2，这正好利用溢位的方式实现了负数的运算。-128 在内存中对应的二进制数据为<br>10000000，如果两个-128 相加，不考虑 Java 运算时的类型提升，运算后会产生进位，二进<br>制结果为 1,00000000，由于进位后超过了 byte 类型的存储空间，所以进位部分被舍弃，即<br>最终的结果为 00000000，也就是 0，这样的结果显然不是我们期望的，这说明计算机中的算<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。<br>由于 Java 中涉及表达式运算时的类型自动提升，我们无法用 byte 类型来做演示这种问题和<br>现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下：<br>int a &#x3D; Integer.MAX_VALUE;<br>int b &#x3D; Integer.MAX_VALUE;<br>int sum &#x3D; a + b;<br>System.out.println(“a&#x3D;”+a+”,b&#x3D;”+b+”,sum&#x3D;”+sum);<br>先不考虑 long 类型，由于 int 的正数范围为 2 的 31 次方，表示的最大数值约等于<br>2<em>1000</em>1000*1000，也就是 20 亿的大小，所以，要实现一个一百亿的计算器，我们得自己<br>设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大<br>概功能如下：<br>（1）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数<br>（2）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中<br>（3）提供加减乘除的功能<br>public class BigInteger{<br>int sign;<br>byte[] val;<br>public Biginteger(String val){<br>sign &#x3D; ;<br>val &#x3D; ;<br>}<br>public BigInteger add(BigInteger other){<br>}<br>public BigInteger subtract(BigInteger other){<br>}<br>public BigInteger multiply(BigInteger other){<br>}<br>public BigInteger divide(BigInteger other){<br>}<br>}<br>备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看 jdk 中自带<br>的 java.math.BigInteger 类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整<br>代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你<br>不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证<br>明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什<br>么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，<br>拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，<br>体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这<br>也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能<br>力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一<br>千元。</li><li>使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？<br>使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>还是可以改变的。例如，对于如下语句：<br>final StringBuffer a&#x3D;new StringBuffer(“immutable”);<br>执行如下语句将报告编译期错误：<br>a&#x3D;new StringBuffer(“”);<br>但是，执行如下语句则可以通过编译：<br>a.append(“ broken!”);<br>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：<br>public void method(final StringBuffer param){<br>}<br>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：<br>param.append(“a”);</li><li>“&#x3D;&#x3D;”和 equals 方法究竟有什么区别？<br>&#x3D;&#x3D;操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存<br>储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用&#x3D;&#x3D;操作<br>符。<br>如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块<br>内存（堆内存），变量也占用一块内存，例如 Objet obj &#x3D; new Object();变量 obj 是一个内存，<br>new Object()是另一个内存，此时，变量 obj 所对应的内存中存储的数值就是对象占用的那块<br>内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要<br>看这两个变量所对应的内存中的数值是否相等，这时候就需要用&#x3D;&#x3D;操作符进行比较。<br>equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相<br>同，它比较的两个对象是独立的。例如，对于下面的代码：<br>String a&#x3D;new String(“foo”);<br>String b&#x3D;new String(“foo”);<br>两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向了其中一个对象，这是两个<br>不同的对象，它们的首地址是不同的，即 a 和 b 中存储的数值是不相同的，所以，表达式<br>a&#x3D;&#x3D;b 将返回 false，而这两个对象中的内容是相同的，所以，表达式 a.equals(b)将返回 true。<br>在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input &#x3D; …;input.equals(“quit”)，许多人稍不注意就使用&#x3D;&#x3D;进行比较了，这是错误的，随便从网上<br>找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都<br>是使用 equals 方法。<br>如果一个类没有自己定义 equals 方法，那么它将继承 Object 类的 equals 方法，Object 类的<br>equals 方法的实现代码如下：<br>boolean equals(Object o){<br>return this&#x3D;&#x3D;o;<br>}<br>这说明，如果一个类没有自己定义 equals 方法，它默认的 equals 方法（从 Object 类继承的）<br>就是使用&#x3D;&#x3D;操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals<br>和使用&#x3D;&#x3D;会得到同样的结果，如果比较的是两个独立的对象则总返回 false。如果你编写的<br>类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖 equals 方法，由<br>你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。</li><li>静态变量和实例变量的区别？<br>语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量<br>才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所<br>以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分<br>配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来<br>使用，静态变量则可以直接使用类名来引用。<br>例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并<br>且每创建一个实例对象，这个 staticVar 就会加 1；但是，每创建一个实例对象，就会分配一<br>个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。<br>public class VariantTest{<br>public static int staticVar &#x3D; 0;<br>public int instanceVar &#x3D; 0;<br>public VariantTest(){<br>staticVar++;<br>instanceVar++;<br>System.out.println(“staticVar&#x3D;” + staticVar + ”,instanceVar&#x3D;” + instanceVar);<br>}<br>}<br>备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，<br>体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！</li><li>是否可从一个 static 方法内发出对非 static 方法的调用？<br>不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对<br>象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一<br>个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非<br>static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，<br>一个 static 方法内部发出对非 static 方法的调用。</li><li>Integer 与 int 的区别<br>int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 java<br>为 int 提供的封装类。int 的默认值为 0，而 Integer 的默认值为 null，即 Integer 可以区分出<br>未赋值和值为 0 的区别，int 则无法表达出未赋值的情况，例如，要想表达出没有参加考试<br>和考试成绩为 0 的区别，则只能使用 Integer。在 JSP 开发中，Integer 的默认为 null，所以用<br>el 表达式在文本框中显示时，值为空白字符串，而 int 默认的默认值为 0，所以用 el 表达式<br>在文本框中显示时，结果为 0，所以，int 不适合作为 web 层的表单数据的类型。<br>在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可以根据其值是否为 null<br>而判断一个对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中<br>设置其 unsaved-value 属性为 0。<br>另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer<br>中还定义了表示整数的最大值和最小值的常量。</li><li>Math.round(11.5)等於多少? Math.round(-11.5)等於多少?<br>Math 类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英<br>文名称的含义相对应，例如，ceil 的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)<br>的结果为 12,Math.ceil(-11.3)的结果是-11；floor 的英文意义是地板，该方法就表示向下取整，<br>Math.ceil(11.6)的结果为 11,Math.ceil(-11.6)的结果是-12；最难掌握的是 round 方法，它表示<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>“四舍五入”，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，<br>Math.round(11.5)的结果为 12，Math.round(-11.5)的结果为-11。</li><li>下面的代码有什么不妥之处?</li><li>if(username.equals(“zxx”){}<br>2.int x &#x3D; 1;<br>return x&#x3D;&#x3D;1?true:false;</li><li>请说出作用域 public，private，protected，以及不写时的区别<br>说明：如果在修饰的元素上面没有写任何访问修饰符，则表示 friendly。<br>作用域 当前类 同一 package 子孙类 其他 package<br>public √ √ √ √<br>protected √ √ √ ×<br>friendly √ √ × ×<br>private √ × × ×<br>备注：只要记住了有 4 种访问权限，4 个访问范围，然后将全选和范围在水平和垂直方向上<br>分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。</li><li>Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型?<br>Overload 是重载的意思，Override 是覆盖的意思，也就是重写。<br>重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相<br>同（即参数个数或类型不同）。<br>重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类<br>创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个<br>完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法<br>时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决<br>父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能<br>更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增<br>加了一个全新的方法。<br>至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这<br>个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也<br>可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它<br>们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因<br>为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，<br>我们调用 map.remove(key)方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接<br>收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回<br>类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型<br>来判断。<br>override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达<br>到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法<br>进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，<br>我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：<br>1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；<br>2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；<br>3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>4、被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行<br>覆盖。<br>overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的<br>方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数<br>样式，来选择合适的方法执行。在使用重载要注意以下的几点：<br>1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不<br>同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，<br>但是不能为 fun(int,int)）；<br>2、不能通过访问权限、返回类型、抛出的异常进行重载；<br>3、方法的异常类型和数目不会对重载造成影响；<br>4、对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进<br>行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</li><li>同学贡献的一些题?<br>1.搞了多个重载方法，参数分别是 int ,char,和 double，然后将 double x &#x3D; 2，传递进去，会选<br>择哪个方法？<br>2.说说对 javaee 中的 session 的理解，你是怎么用 session 的？cvs&#x2F;svn 下载<br>3.jdk 中哪些类是不能继承的：System,String,StringBuffer 等。<br>4.在 eclipse 中调试时，怎样查看一个变量的值。<br>5.判断身份证：要么是 15 位，要么是 18 位，最后一位可以为字母，并写程序提出其中的年<br>月日。<br>6.一个房子里有椅子，椅子有腿和背，房子与椅子是什么关系，椅子与腿和背是什么关系？<br>7.如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关<br>联。椅子与腿和背时组合关系。<br>8.说说 has a 与 is a 的区别。<br>9.工厂模式的类图</li><li>线程如何同步和通讯？<br>同学回答说 synchronized 方法或代码块！面试官似乎不太满意！<br>只有多个 synchronized 代码块使用的是同一个监视器对象，这些 synchronized 代码块之间才<br>具有线程互斥的效果，假如 a 代码块用 obj1 作为监视器对象，假如 b 代码块用 obj2 作为监<br>视器对象，那么，两个并发的线程可以同时分别进入这两个代码块中。 …这里还可以分析<br>一下同步的原理。<br>对于同步方法的分析，所用的同步监视器对象是 this<br>接着对于静态同步方法的分析，所用的同步监视器对象是该类的 Class 对象<br>接着对如何实现代码块与方法的同步进行分析。</li><li>ClassLoader 如何加载 class ？<br>jvm 里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap 类加载负责<br>加载 jre&#x2F;lib&#x2F;rt.jar 中的类， 我们平时用的 jdk 中的类都位于 rt.jar 中。extclassloader 负责加载<br>jar&#x2F;lib&#x2F;ext&#x2F;*.jar 中的类，appclassloader 负责 classpath 指定的目录或 jar 中的类。除了 bootstrap<br>之外，其他的类加载器本身也都是 java 类，它们的父类是 ClassLoader。</li><li>Servlet 的生命周期？<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销<br>毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个<br>实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，<br>服务完成后就销毁，所以效率上低于 servlet</li><li>抽象类的作用？</li><li>ArrayList 如何实现插入的数据按自定义的方式有序存放？<br>class MyBean implements Comparable{<br>public int compareTo(Object obj){<br>if(! obj instanceof MyBean)<br>throw new ClassCastException() &#x2F;&#x2F;具体异常的名称，我要查 jdk 文档。<br>MyBean other &#x3D; (MyBean) obj;<br>return age &gt; other.age?1:age&#x3D;&#x3D; other.age?0:-1;<br>}<br>}<br>class MyTreeSet {<br>private ArrayList datas &#x3D; new ArrayList();<br>public void add(Object obj){<br>for(int i&#x3D;0;i&lt;datas.size();i++){<br>if(obj.compareTo(datas.get(i) !&#x3D; 1){<br>datas.add(i,obj);<br>}<br>}<br>}<br>}</li><li>分层设计的好处？<br>把各个功能按调用流程进行了模块化，模块化带来的好处就是可以随意组合，举例说明：如<br>果要注册一个用户，流程为显示界面并通过界面接收用户的输入，接着进行业务逻辑处理，<br>在处理业务逻辑又访问数据库，如果我们将这些步骤全部按流水帐的方式放在一个方法中编<br>写，这也是可以的，但这其中的坏处就是，当界面要修改时，由于代码全在一个方法内，可<br>能会碰坏业务逻辑和数据库访问的码，同样，当修改业务逻辑或数据库访问的代码时，也会<br>碰坏其他部分的代码。分层就是要把界面部分、业务逻辑部分、数据库访问部分的代码放在<br>各自独立的方法或类中编写，这样就不会出现牵一发而动全身的问题了。这样分层后，还可<br>以方便切换各层，譬如原来的界面是 Swing，现在要改成 BS 界面，如果最初是按分层设计<br>的，这时候不需要涉及业务和数据访问的代码，只需编写一条 web 界面就可以了。<br>下面的仅供参考，不建议照搬照套，一定要改成自己的语言，发现内心的感受：<br>分层的好处：1.实现了软件之间的解耦；2.便于进行分工；3.便于维护；4.提高软件组件的重<br>用；5.便于替换某种产品，比如持久层用的是 hibernate,需要更换产品用 toplink，就不用其他<br>业务代码，直接把配置一改；6.便于产品功能的扩展；7.便于适用用户需求的不断变化</li><li>序列化接口的 id 有什么用？<br>对象经常要通过 IO 进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某<br>种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”Person，既然大家都要这么干，并且没<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有个统一的干法，于是，sun 公司就提出一种统一的解决方案，它会把对象变成某个格式进<br>行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想<br>能被 sun 的这种方案处理，必须实现 Serializable 接口。<br>ObjectOutputStream.writeObject(obj);<br>Object obj &#x3D; ObjectInputStream.readObject();<br>假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了<br>另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun 的 jdk 就<br>会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本<br>号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，<br>则直接报版本号不同的错!</li><li>StringBuffer 与 StringBuilder 的区别？<br>因为 StringBuilder sbuilder &#x3D; ;是线程不安全的，运行效率高，如果一个字符串变量是在方法<br>里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用 StringBuilder。<br>如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用<br>StringBuffer。</li><li>hashCode 方法的作用？<br>首先，想要明白 hashCode 的作用，你必须要先知道 Java 中的集合。<br>总的来说，Java 中的集合（Collection）有两类，一类是 List，再有一类是 Set。你知道<br>它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重<br>复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该<br>依据什么来判断呢？这就是 Object.equals 方法了。但是，如果每增加一个元素就检查一次，<br>那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中<br>现在已经有 1000 个元素，那么第 1001 个元素加入集合时，它就要调用 1000 次 equals 方法。<br>这显然会大大降低效率。于是，Java 采用了哈希表的原理。可以简单理解，hashCode 方法<br>实际上返回的就是对象存储的物理地址（实际可能并不是）。这样一来，当集合要添加新的<br>元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。<br>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果<br>这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，<br>不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用 equals<br>方法的次数就大大降低了，几乎只需要一两次。<br>所以，Java 对于 eqauls 方法和 hashCode 方法是这样规定的：<br>1、如果两个对象相同，那么它们的 hashCode 值一定要相同；<br>2、如果两个对象的 hashCode 相同，它们并不一定相同<br>上面说的对象相同指的是用 eqauls 方法比较。<br>你当然可以不按要求去做了，但你会发现，相同的对象可以出现在 Set 集合中。同时，增<br>加新元素的效率会大大下降。</li><li>webservice 问得很多</li><li>设计出计算任意正整数的阶层？</li><li>在 oracle 数据库中需要查询出前 8 条记录的 sql 语句怎么写？</li><li>什么是 SOA，谈谈你的 SOA 的理解。service orientied architecture？<br>SOA 是指为了解决在 Internet 环境下业务集成的需要，通过连接能完成特定任务的独立功能<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实体实现的一种软件系统架构。1. 软件系统架构：SOA 不是一种语言，也不是一种具体的技术而是一种软件系统架构，<br>它尝试给出在特定环境下推荐采用的一种架构，从这个角度上来说，它更像一种模式<br>(Pattern)。因此它与很多已有的软件技术比如面向对象技术，是互补的而非互斥的。它们分<br>别面向不同的应用场景，用来满足不同的特定需求。</li><li>SOA 的使用范围：需求决定同时也限制功能。SOA 并不是包治百病的万灵丹，它最<br>主要的应用场合在于解决在 Internet 环境下的不同商业应用之间的业务集成问题。1. 如何实现线程间的通讯？<br>在 Java 语言中，提供了各种各样的输入输出流（stream）,使我们能够很方便的对数据进行<br>操作，其中，管道（pipe）流是一种特殊的流，用于在不同线程（threads）间直接传送数据。<br>一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同<br>线程间的通讯。无需求助于类似临时文件之类的东西。本文在简要介绍管道的基本概念后，<br>将以一个具体的实例 pipeapp 加以详细说明。<br>1．管道的创建与使用<br>Java 提供了两个特殊的专门的类专门用于处理管道，它们就是 pipedinputstream 类和<br>pipeoutputstream 类。<br>Pipedinputstream 代表了数据在管道中的输出端，也就是线程向管道读数据的一端；<br>pipeoutputstream 代表了数据在管道中的输入端，也就是线程向管道写数据的一端，这两个<br>类一起使用可以提供数据的管道流。<br>为了创建一个管道流，我们必须首先创建一个 pipeoutstream 对象，然后，创建<br>pipeinputstream 对象，实例如下：<br>pipeout&#x3D; new pipedyoutstream();<br>pipein&#x3D; new pipedputsteam(pipepout); 一旦创建了一个管道后，就可以象操作文件一样对管道进行数据的读写。<br>2．演示程序： pipeapp<br>应用程序由三个程序组成：主线程（pipeapp.Java）及由主线程启动的两个二级线程<br>（ythread.Java 和 zthread.Java）,它们使用管道来处理数据。程序从一个内容为一行一行”x” 字母的”input.txt”文件中读取数据，使用管道传输数据，第一次是利用线程 ythread 将数据”x” 转换为”y”，最后利用线程 zthread 将”y”转换为”z”,之后，程序在屏幕上显示修改后的数据。<br>主线程 （pipeapp.Java）<br>在 main()方法中，程序首先创建一个应用对象：pipeapp pipeapp&#x3D;new pipeapp();<br>由于程序中流操作都需要使用 IOException 异常处理，所以设置了一个 try 块。在 try 中，为<br>了从源文件中读取数据，程序为”input.txt”文件创建了一个输入流 Xfileln,:<br>fileinputstream xfileln&#x3D; new fileinputstream(“input.txt”);<br>新的输入流传递给 changetoy()方法，让线程 ythread 能读取该文件：<br>inputstream ylnpipe &#x3D;pipeapp.changetoy(xfileln);<br>changetoy()方法创建将输入数据”x”改变到”y”的线程 ythread,并返回该线程的输入管道：<br>inputstream zlnpipe &#x3D; pipeapp.changetoz(ylnpipe);<br>changetoz()方法启动将数据从”y”改变到”z”的线程 zehread,主程序将使用从 changetoz()<br>返回的输入管道。得到以修改的数据。<br>然后，程序将管道输入流定位到 datainputstream 对象，使程序能够使用 readline()方法读<br>取数据：<br>datainputstream inputstream &#x3D; new datainputstream(zlnpiepe);<br>创建了输入流以后，程序就可以以行一行的读取数据病显示在屏幕上。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>String str&#x3D; inputstream.readline();<br>While(str!&#x3D;null){<br>system.out.println(str);<br>str&#x3D;inputstream.readline();<br>}<br>显示完成之后，程序关闭输入流：<br>inputstream.close();<br>changetoy()方法<br>changetoy()方法首先通过传递一个参数 inputstream 给 datainputstream 对象来定位资源的<br>输入流，使程序能使用 readline()方法从流中读取数据：<br>datainputstream xfileln &#x3D;new datainutstream(inputstream)；<br>然后，changetoy()创建输出管道和输入管道：<br>pipeoutstream pipeout &#x3D; new pipeoutputstream();<br>pipeinputstream pipeln &#x3D; new pipedinputsteam(pipeout);<br>为了能够使用 println()方法输出修改的后的文本行到管道，程序将输出管道定位到<br>printstream 对象：<br>printstream printstream &#x3D; new printstream(pipeout);<br>现在，程序可以创建将数据从 x 改变到 y 的线程，该线程是 ythread 类的一个对象，他<br>传递两个参数：输入文件（xfileln）和输出管道（调用 printstream）<br>ythread ythread &#x3D;new thread(xfileln,printstream);<br>之后，程序启动线程：<br>changetoz（）方法<br>changetoz()方法与 changetoy()方法很相似，他从 changetoy()返回的输入流开始：<br>datainputstream yfileln&#x3D; new datainputstream(inputstream);<br>程序创建一个新的管道：<br>pipedoutstream pipeout2 &#x3D; new pipedoutputstream();<br>pipedinputstream pipeln2 &#x3D; new pipedinputsream(pipeout2);<br>该线程通过这个新的管道发出修改后的数据（输入流 pipeln2）给主程序。</li></ol><p>Ythread 类和 Zthread 类<br>由于 ythread 类与 zthread 类基本一样，在此仅以 ythread 为例加以说明。<br>Ythread 的构造器接收两个参数：输入的文件和第一个管道的输出端，构造器存储这两<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>个参数作为类的数据成员：<br>Ythread(datainputstream xfileln,pringstream printstream){<br>this.xfileln &#x3D; xfileln;<br>this.printstream &#x3D; printstream;<br>}<br>线程通过 run()方法来处理数据。首先读取一行数据，确保 xstring 不为空的情况下循环<br>执行：<br>string xstring &#x3D; xfileln.readline();<br>每读一行数据，完成一次转换<br>string ystring &#x3D; xstring.replace(‘x’,’y’);<br>然后将修改后的数据输出到管道的输出端：<br>prinstream.prinrln(ystring);<br>为了确保所有缓冲区的数据完全进入管道的输出端：<br>pringstram.flush();<br>循环完成后，线程关闭管道输出流：<br>pringstram.close();<br>ythread 类的源程序如下：<br>6. 构造器 Constructor 是否可被 override?<br>构造器 Constructor 不能被继承，因此不能重写 Override，但可以被重载 Overload。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>7. 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具<br>体类(concrete class)? 抽象类中是否可以有静态的 main 方法？<br>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类<br>中可以有静态的 main 方法。<br>备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是 java<br>语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道<br>理不提供，那答案就是肯定的了。<br>只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有 abstract 方法。<br>8. 写 clone()方法时，通常都有一行代码，是什么？<br>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己<br>的成员。<br>9. 谈谈你对面向对象的理解<br>面向对象是一种程序的设计方法，或者说它是一种程序设计范型，其基本思想是使用对象，<br>类，继承，封装，消息等基本概念来进行程序设计。<br>它是从现实世界中客观存在的事物（即对象）出发来构造软件系统，并在系统构造中尽可能<br>运用人类的自然思维方式，强调直接以问题域（现实世界）中的事物为中心来思考问题，认<br>识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的对象，作为系统的基本<br>构成单位（而不是用一些与现实世界中的事物相关比较远，并且没有对应关系的其它概念来<br>构造系统）。这可以使系统直接地映射问题域，保持问题域中事物及其相互关系的本来面貌。<br>它可以有不同层次的理解：<br>从世界观的角度可以认为：面向对象的基本哲学是认为世界是由各种各样具有自己的运动规<br>律和内部状态的对象所组成的；不同对象之间的相互作用和通讯构成了完整的现实世界。因<br>此，人们应当按照现实世界这个本来面貌来理解世界，直接通过对象及其相互关系来反映世<br>界。这样建立起来的系统才能符合现实世界的本来面目。<br>从方法学的角度可以认为：面向对象的方法是面向对象的世界观在开发方法中的直接运用。<br>它强调系统的结构应该直接与现实世界的结构相对应，应该围绕现实世界中的对象来构造系<br>统，而不是围绕功能来构造系统。<br>从程序设计的角度来看，面向对象的程序设计语言必须有描述对象及其相互之间关系的语言<br>成分。这些程序设计语言可以归纳为以下几类：系统中一切皆为对象；对象是属性及其操作<br>的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间<br>的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息<br>的序列。<br>10. 面向对象的特征有哪些方面？<br>面向对象的编程语言有封装、继承 、抽象、多态等 4 个主要的特征。<br>1．封装：<br>封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、<br>低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装<br>的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就<br>是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变<br>量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要<br>记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只<br>有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同<br>一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类<br>中。<br>例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个<br>对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中<br>定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两<br>个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配<br>在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个<br>体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例<br>子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配<br>给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能<br>完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动<br>作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。<br>2．抽象：<br>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些<br>事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与<br>当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是<br>抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个 Person 类，如下：<br>class Person{<br>String name;<br>int age;<br>}<br>人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上<br>面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些<br>与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及<br>的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。<br>3．继承：<br>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在<br>的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适<br>合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一<br>种关系，提高了软件的可重用性和可扩展性。<br>4．多态：<br>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编<br>程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，<br>该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<br>因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到<br>各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以<br>改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性<br>增强了软件的灵活性和扩展性。例如，下面代码中的 UserDao 是一个接口，它定义引用变量<br>userDao 指向的实例对象由 daofactory.getDao()在执行的时候返回，有时候指向的是<br>UserJdbcDao 这个实现，有时候指向的是 UserHibernateDao 这个实现，这样，不用修改源代<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>码，就可以改变 userDao 指向的具体类实现，从而导致 userDao.insertUser()方法调用的具体<br>代码也随之改变，即有时候调用的是 UserJdbcDao 的 insertUser 方法，有时候调用的是<br>UserHibernateDao 的 insertUser 方法：<br>UserDao userDao &#x3D; daofactory.getDao();<br>userDao.insertUser(user);<br>比喻：人吃饭，你看到的是左手，还是右手？<br>11. java 中实现多态的机制是什么？<br>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方<br>法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运<br>行的那个对象的方法，而不是引用变量的类型中定义的方法。<br>12. abstract class 和 interface 有什么区别?<br>含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方<br>法的类必须定义为 abstract class，abstract class 类中的方法不必是抽象的。abstract class 类中<br>定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方<br>法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。<br>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口<br>中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final。<br>下面比较一下两者的语法区别：<br>1.抽象类可以有构造方法，接口中不能有构造方法。<br>2.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象<br>的普通方法。<br>4.抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型,虽然 eclipse 下不报<br>错，但应该也不行），但接口抽象方法只能是 public 类型的，并且默认即为 public abstract<br>类型。<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任<br>意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。<br>7.一个类可以实现多个接口，但只能继承一个抽象类。<br>下面接着再说说两者在应用上的区别：<br>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类<br>在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个<br>典型应用，假设某个项目的所有 Servlet 类都要用相同的方式进行权限判断、记录访问日志<br>和处理异常，那么就可以定义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在<br>抽象基类的 service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中<br>只是完成各自的业务逻辑代码，伪代码如下：<br>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。<br>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，<br>最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普<br>通成员变量和方法（包括抽象方法），静态变量和方法，继承性等 6 个方面逐一去比较回答，<br>接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功<br>底。<br>13. abstract 的 method 是 否可 同 时是 static,是 否可 同 时是 native， 是否 可 同时 是<br>synchronized?<br>abstract 的 method 不可以是 static 的，因为抽象的方法是要被子类实现的，而 static 与子类<br>扯不上关系！<br>native 方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问<br>题，所以，它也不能是抽象的，不能与 abstract 混用。例如，FileOutputSteam 类要和硬件打<br>交道，底层的实现用的是操作系统相关的 api 实现，例如，在 windows 用 c 语言实现的，所<br>以，查看 jdk 的源代码，可以发现 FileOutputStream 的 open 方法的定义如下：<br>private native void open(String name) throws FileNotFoundException;<br>如果我们要用 java 调用别人写的 c 语言函数，我们是无法直接调用的，我们需要按照 java<br>的要求写一个 c 语言的函数，又我们的这个 c 语言函数去调用别人的 c 语言函数。由于我们<br>的 c 语言函数是按 java 的要求来写的，我们这个 c 语言函数就可以与 java 对接上，java 那<br>边的对接方式就是定义出与我们这个 c 函数相对应的方法，java 中对应的方法不需要写具体<br>的代码，但需要在前面声明 native。<br>关于 synchronized 与 abstract 合用的问题，我觉得也不行，因为在我几年的学习和开发中，<br>从来没见到过这种情况，并且我觉得 synchronized 应该是作用在一个具体的方法上才有意<br>义。而且，方法上的 synchronized 同步所使用的同步锁对象是 this，而抽象方法上无法确定<br>this 是什么。<br>14. 什么是内部类？Static Nested Class 和 Inner Class 的不同？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>使用 static 声明的内部类就是外部类，可以通过外部类.内部类直接访问。<br>普通内部类是不能够直接被外部所访问的，需要通过外部类实例在找到内部类实例。<br>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特<br>性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放<br>到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。<br>我想可能是既然静态成员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，<br>所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该<br>被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，<br>也可以定义在外部类的方法体中，如下所示：<br>在方法体外面定义的内部类的访问类型可以是 public,protecte,默认的，private 等 4 种类型，<br>这就好像类中定义的成员变量有 4 种访问类型一样，它们决定这个内部类的定义对其他类是<br>否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象<br>时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对<br>象，代码如下：<br>Outer outer &#x3D; new Outer();<br>Outer.Inner1 inner1 &#x3D; outer.new Innner1();<br>在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，<br>但这种内部类的前面可以使用 final 或 abstract 修饰符。这种内部类对其他类是不可见的其他<br>类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部<br>类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局<br>部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但<br>是，该局部变量前必须加 final 修饰符。<br>对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误信息就可以马上<br>了解到。<br>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同<br>时，还创建了该子类的实例对象，无需为该子类定义名称：<br>public class Outer {<br>public void start() {<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>new Thread(new Runnable() {<br>public void run() {<br>};<br>}).start();<br>}<br>}<br>最后，在方法外部定义的内部类前面可以加上 static 关键字，从而成为 Static Nested Class，<br>它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class 与普通类<br>在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定<br>义成 public、protected、默认的、private 等多种类型，而普通类只能定义成 public 和默认的<br>这两种类型。在外面引用 Static Nested Class 类的名称为“外部类名.内部类名”。在外面不<br>需要创建外部类的实例对象，就可以直接创建 Static Nested Class，例如，假设 Inner 是定义<br>在 Outer 类中的 Static Nested Class，那么可以使用如下语句创建 Inner 类：<br>Outer.Inner inner &#x3D; new Outer.Inner();<br>由于 static Nested Class 不依赖于外部类的实例对象，所以，static Nested Class 能访问外部类<br>的非 static 成员变量。当在外部访问 Static Nested Class 时，可以直接使用 Static Nested Class<br>的名字，而不需要加上外部类的名字了，在 Static Nested Class 中也可以直接引用外部类的<br>static 的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是 Static Nested Class，这时候不能在类前面加 static 关键字，<br>静态方法中的 Static Nested Class 与普通方法中的内部类的应用方式很相似，它除了可以直<br>接访问外部类中的 static 的成员变量，还可以访问静态方法中的局部变量，但是，该局部变<br>量前必须加 final 修饰符。<br>备注：首先根据你印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可<br>以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知<br>识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。<br>15. 内部类可以引用它的包含类的成员吗？有没有什么限制？<br>完全可以。如果不是静态内部类，那没有什么限制！<br>如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员<br>变量，而只能访问外部类中的静态成员，例如，下面的代码：</p><p>答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问<br>外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情<br>况，让人家吃惊。<br>16. Anonymous Inner Class (匿名内部类) 是否可继承其它类，是否可以 implements 接<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>口?<br>可以继承其他类或实现其他接口。不仅是可以，而是必须!因为匿名内部类就是在抽象类和<br>接口的基础上发展起来的。<br>17. class.forName 的作用？<br>调用该访问 返回一个以字符串指定类名的类的对象。<br>返回字节码，返回字节码的方式有几种:<br>①：这份字节码曾经被加载过已经存在 java 虚拟机中了直接返回。<br>②：java 虚拟机中还没有这份字节码 用类加载器去加载 把加载进来的字节码缓存在虚拟机<br>中，以后再得到这个字节码就不用再加载。<br>得到字节码对应的实例对象: 类名.class ; 对象.getClass(),例如 new Date; 类名.class，<br>例如，System.class<br>对 象 .getClass() ， 例 如 ， new Date().getClass() Class.forName( “ 类 名 ” ) ， 例 如 ，<br>Class.forName(“java.util.Date”);<br>③：静态方法去查询或者加载这个字符串所对应哪个类的字节码<br>因为在写源程序的时候还不知道类的名字，在我运行的时候人家传递我一个字符串，这个字<br>符串里面包含了一个类的名字，再写程序的时候把 java.util.Date 换成一个字符串变量， 等<br>程序运行起来的时候这个变量的值从一个配置文件里面装再进来，这个类的名字在写原程序<br>的时候不用知道而是等运行的时候给我临时送进来。<br>》》》》》》》》》》》》》》》》》》》》》》》》》》》《《《《《《《《《《《《《《《《《《《《《《《《《《《《《<br>按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，<br>则返回代表该字节码的 Class 实例对象，否则，按类加载器的委托机制去搜索和加载该类，<br>如果所有的类加载器都无法加载到该类，则抛出 ClassNotFoundException。加载完这个 Class<br>字节码后，接着就可以使用 Class 字节码的 newInstance 方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时<br>才能确定，这时候就需要使用 Class.forName 去动态加载该类，这个类名通常是在配置文件<br>中配置的，例如，spring 的 ioc 中每次依赖注入的具体类就是这样配置的，jdbc 的驱动类名<br>通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类<br>名<br>18. super.getClass()方法调用？<br>下面程序的输出结果是多少？<br>import java.util.Date;<br>public class Test extends Date{<br>public static void main(String[] args) {<br>new Test().test();<br>}<br>public void test(){<br>System.out.println(super.getClass().getName());<br>}<br>}<br>很奇怪，结果是 Test<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>这属于脑筋急转弯的题目，在一个 qq 群有个网友正好问过这个问题，我觉得挺有趣，就研<br>究了一下，没想到今天还被你面到了，哈哈。<br>在 test 方法中，直接调用 getClass().getName()方法，返回的是 Test 类名<br>由于 getClass()在 Object 类中定义成了 final，子类不能覆盖该方法，所以，在 test 方法中调<br>用 getClass().getName()方法，其实就是在调用从父类继承的 getClass()方法，等效于调用<br>super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是 Test。<br>如果想得到父类的名称，应该用如下代码：<br>getClass().getSuperClass().getName();<br>19. String 是最基本的数据类型吗?<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型，因此不可继承这个类、不能修改这个类。为提高效率节省空<br>间，我们应用 StringBuffer 类。<br>20. String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的 String 对象中的内容<br>到底变了没有？<br>没有。因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。这段<br>代码中，s 原先指向一个 String 对象，内容是 “Hello”，然后我们对 s 进行了+操作，那么 s<br>所指向那个对象是否发生了改变呢？答案是没有。这时，s 不指向原来那个对象，而指向了<br>另一个 String 对象，内容为”Hello world!”，原来那个对象还存在于内存中，只是 s 这个引用<br>变量不再指向它了。<br>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，<br>或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。因为<br>String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来<br>表示。这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生<br>成一个新的对象。并且，这两种类的对象转换十分容易。<br>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如<br>我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这<br>样做：<br>public class Demo {<br>private String s;<br>public Demo() {<br>s &#x3D; “Initial Value”;<br>}<br>}<br>而非 s &#x3D; new String(“Initial Value”);<br>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String<br>对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，<br>多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。<br>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表<br>同一个 String 对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是<br>否相同。<br>至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多<br>Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变<br>类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不<br>同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一<br>个可变版本，即 StringBuffer。<br>21. 是否可以继承 String 类?<br>String 类是 final 类故不可以继承. 55. String s &#x3D; new String(“xyz”);创建了几个 String Object? 二者之间有什么区别？<br>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多<br>少遍，都是缓冲区中的那一个。New String 每写一遍，就创建一个新的对象，它一句那个常<br>量”xyz”对象的内容来创建出一个新 String 对象。如果以前就用过’xyz’，这句代表就不会创<br>建”xyz”自己了，直接从缓冲区拿。<br>22. String 和 StringBuffer 的区别？<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多个<br>字符的字符数据。这个 String 类提供了数值不可改变的字符串。而这个 StringBuffer 类提供<br>的字符串进行修改。当你知道字符数据要改变的时候你就可以使用 StringBuffer。典型地，<br>你可以使用 StringBuffers 来动态构造字符数据。另外，String 实现了 equals 方法，new<br>String(“abc”).equals(new String(“abc”)的结果为 true,而 StringBuffer 没有实现 equals 方法，所<br>以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为 false。接着要举一个具<br>体的例子来说明，我们要把 1 到 100 的所有数字拼起来，组成一个串。<br>StringBuffer sbf &#x3D; new StringBuffer();<br>for(int i&#x3D;0;i&lt;100;i++){<br>sbf.append(i);<br>}<br>上面的代码效率很高，因为只创建了一个 StringBuffer 对象，而下面的代码效率很低，因为<br>创建了 101 个对象。<br>String str &#x3D; new String();<br>for(int i&#x3D;0;i&lt;100;i++){<br>str &#x3D; str + i;<br>}<br>在讲两者区别时，应把循环的次数搞成 10000，然后用 endTime-beginTime 来比较两者执行<br>的时间差异，最后还要讲讲 StringBuilder 与 StringBuffer 的区别。<br>String 覆盖了 equals 方法和 hashCode 方法，而 StringBuffer 没有覆盖 equals 方法和 hashCode<br>方法，所以，将 StringBuffer 对象存储进 Java 集合类中时会出现问题。<br>23. 如何把一段逗号分割的字符串转换成一个数组?<br>如果不查 jdk api，我很难写出来！我可以说说我的思路：用正则表达式，代码大概为：<br>String [] result &#x3D; orgStr.split(“,”);<br>用 StingTokenizer ,代码为：StringTokenizer tokener &#x3D; StringTokenizer(orgStr,”,”);<br>String [] result &#x3D; new String[tokener .countTokens()];<br>Int i&#x3D;0;<br>while(tokener.hasNext(){result[i++]&#x3D;toker.nextToken();}<br>24. 数组有没有 length()这个方法? String 有没有 length()这个方法？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>数组没有 length()这个方法，有 length 的属性。String 有有 length()这个方法。<br>25. 下面这条语句一共创建了多少个对象：String s&#x3D;”a”+”b”+”c”+”d”？<br>答：对于如下代码：<br>String s1 &#x3D; “a”;<br>String s2 &#x3D; s1 + “b”;<br>String s3 &#x3D; “a” + “b”;<br>System.out.println(s2 &#x3D;&#x3D; “ab”);<br>System.out.println(s3 &#x3D;&#x3D; “ab”);<br>第一条语句打印的结果为 false，第二条语句打印的结果为 true，这说明 javac 编译可以对字<br>符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译<br>时去掉其中的加号，直接将其编译成一个这些常量相连的结果。<br>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所<br>以，上面的代码应该只创建了一个 String 对象。写如下两行代码，<br>String s &#x3D; “a” + “b” + “c” + “d”;<br>System.out.println(s &#x3D;&#x3D; “abcd”);<br>最终打印的结果应该为 true。<br>26. try {}里有一 return 语句，那紧跟在这个 try 后的 finally {}里的 code 是否被执行，什<br>么时候被执行，在 return 前还是后?<br>也许你的答案是在 return 之前，但往更细地说，我的答案是在 return 中间执行，请看下面程<br>序代码的运行结果：<br>public class Test {<br>public static void main(String[] args) {<br>System.out.println(new Test().test());<br>}<br>static int test(){<br>int x &#x3D; 1;<br>try{<br>return x;<br>}<br>finally{<br>++x;<br>}<br>}<br>}<br>运行结果是 1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐<br>子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓<br>返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说<br>这话之前放进罐子里的。<br>29. error 和 exception 有什么区别?<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程<br>序运行正常，从不会发生的情况。<br>Error 表示有 JVM 进行处理的,是 JVM 出错. Exctption 是可以用程序进行处理的,使用 try…catch 进行处理. 65. Java 中的异常处理机制的简单原理和应用。<br>异常是指 java 程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很<br>相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个<br>对象来表示，Java 使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封<br>装到一个对象来表示的，该对象中包含有异常的信息。<br>Java 对异常进行了分类，不同类型的异常分别用不同的 Java 类表示，所有异常的根类为<br>java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception，Error 表示应<br>用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程<br>死锁等系统问题。Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普<br>通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问<br>题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者<br>让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常<br>（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化<br>或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样<br>的异常后，程序不应该死掉。<br>java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处<br>理或用 throws 声明继续抛给上层调用方法处理，所以普通异常也称为 checked 异常，而系统<br>异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用 throws 声明，所以<br>系统异常也称为 unchecked 异常。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉<br>的错误，程序不应该死掉的错误；<br>30. 请写出你最常见到的 5 个 runtime exception。<br>这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面<br>的异常，你不一定真要回答出 5 个具体的系统异常，但你要能够说出什么是系统异常，以及<br>几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，<br>那就用中文吧，有总比没有强！<br>所 谓 系 统 异 常 ， 就 是 ….. ， 它 们 都 是 RuntimeException 的 子 类 ， 在 jdk doc 中 查<br>RuntimeException 类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比<br>较 有 印 象 的 系 统 异 常 有 ： NullPointerException 、 ArrayIndexOutOfBoundsException 、<br>ClassCastException。<br>31. java 如何进行异常处理，throws,throw,try,catch,finally 代表什么意义？在 try 块中可<br>以抛出异常吗？<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。<br>在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到<br>这个异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一<br>个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来<br>处理；<br>try 用来指定一块预防所有“异常”的程序；<br>catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的类型；<br>throw 语句用来明确地抛出一个“异常”；<br>throws 用来标明一个成员函数可能抛出的各种“异常”；<br>finally 为确保一段代码不管发生什么“异常”都被执行一段代码；<br>可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try 语<br>句保护其他代码。每当遇到一个 try 语句，“异常”的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇<br>到有处理这种“异常”的 try 语句。<br>32. 在 java 中如何进行 socket 编程。<br>答：Sockets 有两种主要的操作方式:面向连接的和无连接的。<br>无连接的操作使用数据报协议.这个模式下的 socket 不需要连接一个目的的 socket,它只是简<br>单地投出数据报.无连接的操作是快速的和高效的,但是数据安全性不佳.面向连接的操作使<br>用 TCP 协议.一个这个模式下的 socket 必须在发送数据之前与目的地的 socket 取得一个连接. 一旦连接建立了,sockets 就可以使用一个流接口:打开-读-写-关闭.所有的发送的信息都会在<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>另一端以同样的顺序被接收.面向连接的操作比无连接的操作效率更低,但是数据的安全性更<br>高. 在服务器，使用 ServerSocket 监听指定的端口，端口可以随意指定（由于 1024 以下的端口<br>通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于 1024 的端口），<br>等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。在客户端，使用<br>Socket 对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话<br>完成后，关闭 Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个 1024<br>以上的端口。<br>40. 线程的基本概念、线程的基本状态以及状态之间的关系<br>一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程<br>上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，<br>即 main 方法执行的那个线程。如果只是一个 cpu，它怎么能够同时执行多段程序呢？这是<br>从宏观上来看的，cpu 一会执行 a 线索，一会执行 b 线索，切换时间很快，给人的感觉是 a,b<br>在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一<br>会为 a 传数据，一会为 b 传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。<br>状态：就绪，运行，synchronize 阻塞，wait 和 sleep 挂起，结束。wait 必须在 synchronized<br>内部调用。<br>调用线程的 start 方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状<br>态，遇到 synchronized 语句时，由运行状态转为阻塞，当 synchronized 获得锁后，由阻塞转<br>为运行，在这种情况可以调用 wait 方法转为挂起状态，当线程关联的代码执行完后，线程<br>变为结束状态。<br>44. 介绍 Collection 框架的结构<br>答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。<br>Collection<br>├List<br>│├LinkedList<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>│├ArrayList<br>│└Vector<br>│ └Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap<br>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素<br>（Elements）<br>Map 提供 key 到 value 的映射<br>45. Collection 框架中实现比较要实现什么接口<br>comparable&#x2F;comparator<br>46. ArrayList 和 Vector 的区别<br>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存<br>储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位<br>置索引号取出某个元素，并且其中的数据是允许重复的，这是 HashSet 之类的集合的最大不<br>同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本<br>来题目问的与 hashset 没有任何关系，但为了说清楚 ArrayList 与 Vector 的功能，我们使用对<br>比方式，更有利于说明问题）。<br>接着才说 ArrayList 与 Vector 的区别，这主要包括两个方面：. （1）同步性：<br>Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安<br>全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用<br>ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是<br>使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。<br>(备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全问题，记住 Vector 与<br>Hashtable 是旧的，是 java 一诞生就提供的，它们是线程安全的，ArrayList 与 HashMap 是 java2<br>时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。)<br>（2）数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量<br>时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加一个<br>存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率<br>之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没<br>有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始<br>的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方<br>法。<br>总结：即 Vector 增长原来的一倍，ArrayList 增加原来的 0.5 倍。<br>49. List, Set, Map 是否继承自 Collection 接口?<br>List，Set 是，Map 不是<br>50. List、Map、Set 三个接口，存取元素时，各有什么特点？<br>这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内<br>容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不<br>明白。<br>首先，List 与 Set 具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接<br>口，叫 Collection。Set 里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不<br>是仅仅是相同）的对象 ，即假设 Set 集合中有了一个 A 对象，现在我要向 Set 集合再存入<br>一个 B 对象，但 B 对象与 A 对象 equals 相等，则 B 对象存储不进去，所以，Set 集合的 add<br>方法有一个 boolean 的返回值，当集合中没有某个元素，此时 add 方法可成功加入该元素时，<br>则返回 true，当集合含有与某个元素 equals 相等的元素时，此时 add 方法无法加入该元素，<br>返回结果为 false。Set 取元素时，没法说取第几个，只能以 Iterator 接口取得所有的元素，<br>再逐一遍历各个元素。<br>List 表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我<br>们多次调用 add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>到的顺序排序。有时候，也可以插队，即调用 add(int index,Obj e)方法，就可以指定当前对<br>象在集合中的存放位置。一个对象可以被反复存储进 List 中，每调用一次 add 方法，这个对<br>象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用<br>一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指向了<br>这个对象，如图 x 所示。List 除了可以以 Iterator 接口取得所有的元素，再逐一遍历各个元<br>素之外，还可以调用 get(index i)来明确说明取第几个。<br>Map 与 List 和 Set 不同，它是双列的集合，其中有 put 方法，定义如下：put(obj key,obj value)，<br>每次存储时，要存储一对 key&#x2F;value，不能存储重复的 key，这个重复的规则也是按 equals<br>比较相等。取则可以根据 key 获得相应的 value，即 get(Object key)返回值为 key 所对应的<br>value。另外，也可以获得所有的 key 的结合，还可以获得所有的 value 的结合，还可以获得<br>key 和 value 组合成的 Map.Entry 对象的集合。<br>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存<br>key-value 值，value 可多值。<br>HashSet 按照 hashcode 值的某种运算方式进行存储，而不是直接按 hashCode 值的大小进行<br>存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65 在 hashSet 中的存储顺序不是 62,65,78，<br>LinkedHashSet 按插入的顺序存储，那被存储对象的 hashcode 方法还有什么作用呢？我们想<br>想!hashset 集合比较两个对象是否相等，首先看 hashcode 方法是否相等，然后看 equals 方法<br>是否相等。new 两个 Student 插入到 HashSet 中，看 HashSet 的 size，实现 hashcode 和 equals<br>方法后再看 size。<br>同一个对象可以在 Vector 中加入多次。往集合里面加元素，相当于集合里用一根绳子连接<br>到了目标对象。往 HashSet 中却加不了多次的。<br>51. 说出 ArrayList,Vector, LinkedList 的存储性能和特性<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增<br>加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存<br>操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），<br>通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进<br>行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。<br>LinkedList 也是线程不安全的，LinkedList 提供了一些方法，使得 LinkedList 可以被当作堆<br>栈和队列来使用。<br>52. 去掉一个 Vector 集合中重复的元素<br>Vector newVector &#x3D; new Vector();<br>For (int i&#x3D;0;i&lt;vector.size();i++){<br>Object obj &#x3D; vector.get(i);<br>53. if(!newVector.contains(obj);<br>newVector.add(obj);<br>}<br>还有一种简单的方式，HashSet set &#x3D; new HashSet(vector);<br>54. Collection 和 Collections 的区别。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>Collection： 是集合类的上级接口，继承与他的接口主要有 Set 和 List. Collections：是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、<br>排序、线程安全化等操作。<br>55. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是<br>equals()? 它们有何区别?<br>Set 里的元素是不能重复的，元素重复与否是使用 equals()方法进行判断的。<br>equals()和&#x3D;&#x3D;方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个分<br>离的对象的内容和类型相配的话，返回真值。<br>56. 链表和数组的区别？<br>创建数组时，必须明确说明数组的长度,(即数组中元素的个数),以便在内存中留出一块空间<br>存放所有的数组元素,数组中各数据元素在内存中是顺序存放的。<br>创建链表时，不需要给出链表中元素(称为节点)的个数,可以先只创建一个链表头,其他元素<br>在需要时动态地创建并加入到链表,链表的数据无素在内存中不是连续存放的。<br>57. 你所知道的集合类都有哪些？主要方法？<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变<br>大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索<br>引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），<br>其中每个键映射到一个值。<br>ArrayList&#x2F;VectorList<br>Collection<br>HashSet&#x2F;TreeSetSet<br>PropetiesHashTable<br>Map<br>Treemap&#x2F;HashMap<br>我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，<br>我记得不是很清楚，对于 set，大概的方法是 add,remove, contains；对于 map，大概的方法<br>就是 put,remove，contains 等，因为，我只要在 eclispe 下按点操作符，很自然的这些方法就<br>出来了。我记住的一些思想就是 List 类会有 get(int index)这样的方法，因为它可以按顺序取<br>元素，而 set 类中没有 get(int index)这样的方法。List 和 set 都可以迭代出所有元素，迭代时<br>先要得到一个 iterator 对象，所以，set 和 list 类都有一个 iterator 方法，用于返回那个 iterator<br>对象。map 可以返回三个集合，一个是返回所有的 key 的集合，另外一个返回的是所有 value<br>的集合，再一个返回的 key 和 value 组合成的 EntrySet 对象的集合，map 也有 get 方法，参<br>数是 key，返回值是 key 对应的 value。<br>58. 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code，这句话对不对?<br>对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode<br>值就必须相等。<br>如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode<br>不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没有理由不实<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>现，通常都会去实现的。<br>59. TreeSet 里面放对象，如同时放入父类和子类实例对象，比较时使用的是父类的<br>compareTo 方法，还是子类的 compareTo 方法，还是抛异常！<br>（应该是没有针对问题的确切的答案，当前的 add 方法放入的是哪个对象，就调用哪个对象<br>的 compareTo 方法，至于这个 compareTo 方法怎么做，就看当前这个对象的类中是如何编写<br>这个方法的）</p><ol start="60"><li><p>说出一些常用的类，包，接口，请各举 5 个<br>要让人家感觉你对 java ee 开发很熟，所以，不能仅仅只列 core java 中的那些东西，要多列<br>你在做 ssh 项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。<br>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer<br>java.util.Date，System，Class，List,HashMap<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>常 用 的 包 ： java.lang java.io java.util<br>java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate<br>常 用 的 接 口 ： Remote List Map Document<br>NodeList ,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate) 、<br>Session(Hibernate),HttpSession</p></li><li><p>java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出<br>他们分别是哪些类？<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于 InputStreamReader<br>OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</p></li><li><p>字节流与字符流的区别<br>要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数<br>据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进<br>行描述，这个抽象描述方式起名为 IO 流，对应的抽象类为 OutputStream 和 InputStream ，<br>不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。<br>在实际应用中，经常需要把完全是字符的一段文本输出去或读进来，用字节流可以吗？计算<br>机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的<br>字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，<br>我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。<br>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进<br>行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写<br>入底层设备，这为我们向 IO 设别写入或读取字符串提供了一点点方便。<br>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某<br>种编码的字节形式，读取也是反之的道理。<br>讲解字节流与字符流关系的代码案例：</p></li><li><p>什么是 java 序列化，如何实现 java 序列化？或者请解释 Serializable 接口的作用。<br>我们有时候将一个 java 对象变成字节流的形式传出去或者从一个字节流中恢复成一个 java<br>对象，例如，要将 java 对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可<br>以自己写代码去把一个 java 对象变成某个格式的字节流再传输，但是，jre 本身就提供了这<br>种支持，我们可以调用 OutputStream 的 writeObject 方法来做，如果要让 java 帮我们做，要<br>被传输的对象必须实现 serializable 接口，这样，javac 编译时就会进行特殊处理，编译的类<br>才可以被 writeObject 方法操作，这就是所谓的序列化。需要被序列化的类必须实现<br>Serializable 接口，该接口是一个 mini 接口，其中没有需要实现的方法，implements Serializable<br>只是为了标注该对象是可被序列化的。<br>例如，在 web 开发中，如果对象被保存在了 Session 中，tomcat 在重启时要把 Session 对象<br>序列化到硬盘，这个对象就必须实现 Serializable 接口。如果对象要经过分布式系统进行网<br>络传输或通过 rmi 等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现<br>Serializable 接口。</p></li><li><p>描述一下 JVM 加载 class 文件的原理机制?<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的 Java<br>运行时系统组件。它负责在运行时查找和装入类文件的类。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p></li><li><p>heap 和 stack 有什么区别。<br>java 的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会<br>为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结<br>束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。<br>堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new<br>创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final<br>修饰后，放在堆中，而不是栈中。</p></li><li><p>GC 是什么? 为什么要有 GC?<br>GC：垃圾回收，使用 GC 可以进行垃圾空间释放操作。<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘<br>记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动<br>监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存<br>的显示操作方法。</p></li><li><p>垃圾回收的优点和原理。并考虑 2 种回收机制。<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的问<br>题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾<br>回收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收<br>可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的<br>低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进<br>行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回<br>收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。<br>简单答法:将无用的空间对象进行释放. 俩中回收机制:自动回收和手工调用 System.gc()方法,实际上调用 System.gc 就相当于调用了<br>Runtime.getRuntime().gc()方法. 104. 垃圾回收器的基本原理是？垃圾回收器可以马上回收内存吗？如何主动通知虚拟机<br>进行垃圾回收？<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对<br>象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回<br>收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。</p></li><li><p>什么时候用 assert。<br>JDK1.4 之后增加的新关键字——assert，表示断言，即程序执行到某个地方之后值肯定是预<br>计好的；一般开发中很少使用 assert；要想使用断言，就必须使用-ea 参数。<br>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在<br>实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确<br>的状态下，assert 将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正<br>确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检<br>查通常是关闭的。</p></li><li><p>java 中会存在内存泄漏吗，请简单描述。<br>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java 中有垃圾<br>回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被<br>垃圾回收器从内存中清除掉。由于 Java 使用有向图的方式进行垃圾回收管理，可以消除引<br>用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可<br>以回收它们的，例如下面的代码可以看到这种情况的内存回收：</p></li></ol><p>java 中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存<br>泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不<br>能被回收，这就是 java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对<br>象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃<br>圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了<br>一个对象放在缓存中(例如放在一个全局 map 对象中)，然后一直不再使用它，这个对象一直<br>被缓存引用，但却不再被使用。<br>检查 java 中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某<br>个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。<br>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引<br>用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外<br>部类对象将不会被垃圾回收，这也会造成内存泄露。<br>下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，<br>而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中<br>消失，将那个元素所在的位置的值设置为 null 即可）：<br>我实在想不到比那个堆栈更经典的例子了,以致于我还要引用别人的例子，下面的例子不是<br>我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可<br>是那时我说是我自己想到的也没有人相信的。</p><p>上面的原理应该很简单，假如堆栈加了 10 个元素，然后全部弹出来，虽然堆栈是空的，没<br>有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，<br>无法回收。<br>但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪<br>费了几个 K 内存而已，反正我们的内存都上 G 了，哪里会有什么影响，再说这个东西很快<br>就会被回收的，有什么关系。下面看两个例子。<br>例子 1</p><p>因为是 static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果<br>你的 Stack 最多有 100 个对象，那么最多也就只有 100 个对象无法被回收其实这个应该很容<br>易理解，Stack 内部持有 100 个引用，最坏的情况就是他们都是无用的，因为我们一旦放新<br>的进取，以前的引用自然消失！<br>内存泄露的另外一种情况：当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合<br>中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的<br>参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet<br>集合中单独删除当前对象，造成内存泄露。<br>70. 能不能自己写个类，也叫 java.lang.String？<br>可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去<br>加载 jre.jar 包中的那个 java.lang.String。由于在 tomcat 的 web 应用程序中，都是由 webapp<br>自己的类加载器先自己加载 WEB-INF&#x2F;classess 目录中的类，然后才委托上级的类加载器加<br>载，如果我们在 tomcat 的 web 应用程序中写一个 java.lang.String，这时候 Servlet 程序加载<br>的就是我们自己写的 java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了<br>java.lang.String 类的都将出现问题。<br>虽然 java 提供了 endorsed 技术，可以覆盖 jdk 中的某些类，具体做法是….。但是，能够被<br>覆盖的类是有限制范围，反正不包括 java.lang 这样的包中的类。<br>（下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题<br>目泄露了）例如，运行下面的程序：<br>package java.lang;<br>public class String {<br>public static void main(String[] args) {<br>System.out.println(“string”);<br>}<br>}<br>报告的错误如下：<br>java.lang.NoSuchMethodError: main<br>Exception in thread “main” 这是因为加载了 jre 自带的 java.lang.String，而该类中没有 main 方法。 二、Java 代码查错<br>abstract class Name {<br>private String name;<br>public abstract boolean isStupidName(String name) {}<br>}<br>大侠们，这有何错误?<br>答案: 错。abstract method 必须以分号结尾，且不带花括号。<br>2.public class Something {<br>void doSomething () {<br>private String s &#x3D; “”;<br>int l &#x3D; s.length();<br>}<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有错吗?<br>答案: 错。局部变量前不能放置任何访问修饰符 (private，public，和 protected)。final 可以<br>用来修饰局部变量<br>(final 如同 abstract 和 strictfp，都是非访问修饰符，strictfp 只能修饰 class 和 method 而非<br>variable)。<br>3.abstract class Something {<br>private abstract String doSomething ();<br>}<br>这好像没什么错吧?<br>答案: 错。abstract 的methods不能以private修饰。abstract的 methods就是让子类 implement(实<br>现)具体细节的，怎么可以用 private 把 abstract<br>method 封锁起来呢? (同理，abstract method 前不能加 final)。<br>4.public class Something {<br>public int addOne(final int x) {<br>return ++x;<br>}<br>}<br>这个比较明显。<br>答案: 错。int x 被修饰成 final，意味着 x 不能在 addOne method 中被修改。<br>5.public class Something {<br>public static void main(String[] args) {<br>Other o &#x3D; new Other();<br>new Something().addOne(o);<br>}<br>public void addOne(final Other o) {<br>o.i++;<br>}<br>}<br>class Other {<br>public int i;<br>}<br>和上面的很相似，都是关于 final 的问题，这有错吗?<br>答案: 正确。在 addOne method 中，参数 o 被修饰成 final。如果在 addOne method 里我们修<br>改了 o 的 reference<br>(比如: o &#x3D; new Other();)，那么如同上例这题也是错的。但这里修改的是 o 的 member vairable<br>(成员变量)，而 o 的 reference 并没有改变。<br>6.class Something {<br>int i;<br>public void doSomething() {<br>System.out.println(“i &#x3D; “ + i);<br>}<br>}<br>有什么错呢? 看不出来啊。<br>答案: 正确。输出的是”i &#x3D; 0”。int i 属於 instant variable (实例变量，或叫成员变量)。instant<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>variable 有 default value。int 的 default value 是 0。<br>7.class Something {<br>final int i;<br>public void doSomething() {<br>System.out.println(“i &#x3D; “ + i);<br>}<br>}<br>和上面一题只有一个地方不同，就是多了一个 final。这难道就错了吗?<br>答案: 错。final int i 是个 final 的 instant variable (实例变量，或叫成员变量)。final 的 instant<br>variable 没有 default value，必须在 constructor (构造器)结束之前被赋予一个明确的值。可以<br>修改为”final int i &#x3D; 0;”。<br>8.public class Something {<br>public static void main(String[] args) {<br>Something s &#x3D; new Something();<br>System.out.println(“s.doSomething() returns “ + doSomething());<br>}<br>public String doSomething() {<br>return “Do something …”;<br>}<br>}<br>看上去很完美。<br>答案: 错。看上去在 main 里 call doSomething 没有什么问题，毕竟两个 methods 都在同一个<br>class 里。但仔细看，main 是 static 的。static method 不能直接 call non-static methods。可改<br>成”System.out.println(“s.doSomething() returns “ + s.doSomething());”。同理，static method 不<br>能访问 non-static instant variable。<br>9.此处，Something 类的文件名叫 OtherThing.java<br>class Something {<br>private static void main(String[] something_to_do) {<br>System.out.println(“Do something …”);<br>}<br>}<br>这个好像很明显。<br>答案: 正确。从来没有人说过 Java 的 Class 名字必须和其文件名相同。但 public class 的名字<br>必须和文件名相同。<br>10．interface A{<br>int x &#x3D; 0;<br>}<br>class B{<br>int x &#x3D;1;<br>}<br>class C extends B implements A {<br>public void pX(){<br>System.out.println(x);<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public static void main(String[] args) {<br>new C().pX();<br>}<br>}<br>答案：错误。在编译时会发生错误(错误描述不同的 JVM 有不同的信息，意思就是未明确的<br>x 调用，两个 x 都匹配（就象在同时 import java.util 和 java.sql 两个包时直接声明 Date 一样）。<br>对于父类的变量,可以用 super.x 来明确，而接口的属性默认隐含为 public static final.所以可<br>以通过 A.x 来明确。<br>11.interface Playable {<br>void play();<br>}<br>interface Bounceable {<br>void play();<br>}<br>interface Rollable extends Playable, Bounceable {<br>Ball ball &#x3D; new Ball(“PingPang”);<br>}<br>class Ball implements Rollable {<br>private String name;<br>public String getName() {<br>return name;<br>}<br>public Ball(String name) {<br>this.name &#x3D; name;<br>}<br>public void play() {<br>ball &#x3D; new Ball(“Football”);<br>System.out.println(ball.getName());<br>}<br>}<br>这个错误不容易发现。<br>答案: 错。”interface Rollable extends Playable, Bounceable”没有问题。interface 可继承多个<br>interfaces，所以这里没错。问题出在 interface Rollable 里的”Ball ball &#x3D; new Ball(“PingPang”);”。<br>任何在 interface 里声明的 interface variable (接口变量，也可称成员变量)，默认为 public static<br>final。也就是说”Ball ball &#x3D; new Ball(“PingPang”);”实际上是”public static final Ball ball &#x3D; new<br>Ball(“PingPang”);”。在 Ball 类的 Play()方法中，”ball &#x3D; new Ball(“Football”);”改变了 ball 的<br>reference，而这里的 ball 来自 Rollable interface，Rollable interface 里的 ball 是 public static final<br>的，final 的 object 是不能被改变 reference 的。因此编译器将在”ball &#x3D; new Ball(“Football”);” 这里显示有错。 三、算法与编程<br>71. 用 java 实现一种排序；java 类实现序列化的方法(二种)？ 如在 collection 框架中，<br>实现比较要实现什么样的接口？</p><p>JAVA 类实现序例化的方法是实现 java.io.Serializable 接口<br>Collection 框架中实现比较要实现 Comparable 接口和 Comparator 接口<br>127. 说说你用过那些 ajax 技术和框架，说说它们的区别<br>答:去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存<br>五、Java web 部分<br>128. Tomcat 的优化经验<br>答:去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。<br>有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存<br>129. HTTP 的请求过程？<br>当点击一个链接时,浏览器首先找到站点的 IP 地址,这是通过 DNS 来实现的,在找到 IP 地址后<br>就可以建立 TCP 连接了,连接建立后我们就可以发送请求了.但这个请求是什么样子的呢 ?<br>我们现在假设点击了一个从 <a target="_blank" rel="noopener" href="http://www.webmonkey.com/HTML/96/47/Index2A">www.webmonkey.com/HTML/96/47/Index2A</a> , HTML 点击了<br><a href="WWW.GRIPY.ORG/MATTARG/">WWW.GRIPY.ORG/MATTARG/</a> 这时浏览器会发出下面的请求:<br>Get&#x2F;MATTARG&#x2F;HTML&#x2F;1.0<br>User-Agent: Mozilla&#x2F;2.0(macitosh;1;PPC)<br>Accept: text&#x2F;html: <em>&#x2F;</em> Cookie: name &#x3D; value<br>Refetet: <a target="_blank" rel="noopener" href="http://www.webmonkey.com/html/96/47/index2a.html">http://www.webmonkey.com/html/96/47/index2a.html</a><br>Host: <a target="_blank" rel="noopener" href="http://www.gtippy.org/">www.gtippy.org</a><br>第一行称为请求,它告诉服务器从 MATTMARG 取得文件,这是的目录一般是要加 &#x2F; 的,下面<br>几行通知服务器你所使用的浏览器是什么类型,你所接收的数据是什么类型,如果你以前访问<br>过这个站点,站点可能向你发送了 Cookie ,如果你已经有了一个这样的 Cookie ,浏览器会将<br>这个 Cookie 返回给服务器, referer 行通知服务器用户从哪一页到达此页的. 下面服务器就要返回文件了,每次服务器返回文件时,都要返回一个 Http&#x2F;1.0 响应,同进带有<br>状态码,在此之后是述内部的头信息,下面就是一个响应:<br>HTTP&#x2F;1.0 200 Pound<br>Data: Mon 10 Feb 1997 23:48:22 GMT<br>Server: Apache&#x2F;1.1 1 Hot&amp;ired&#x2F;1.0<br>Content-type: text&#x2F;html<br>Last-Moditied: Tues,11 Feb 1997 22:45:55 GMT<br>不同的数据可能返回不同的 Content-type ，因此不同的内容需要不同的 Content-type ，因<br>此有时候这个过程是很慢的。<br>130. HTTP 请求的 GET 与 POST 方式的区别<br>答：Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST<br>方法。二者主要区别如下：<br>1）Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据；<br>2）Get 将表单中数据按照 variable&#x3D;value 的形式，添加到 action 所指向的 URL 后面，<br>并且两者使用“?”连接，而各个变量之间使用“&amp;”连接；Post 是将表单中的数据放在 form<br>的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL；<br>3）Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中；Post 的所有操作对<br>用户来说都是不可见的；<br>4）Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，<br>所以在上传文件只能使用 Post；<br>5）Get 限制 Form 表单的数据集必须为 ASCII 字符，而 Post 支持整个 ISO10646 字符集；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>6）Get 是 Form 的默认方法。<br>131. 解释一下什么是 servlet？<br>Servlet 是一种独立于平台和协议的服务器端的 Java 技术，可以用来生成动态的 Web 页面。<br>与传统的 CGI（计算机图形接口）和许多其他类似 CGI 技术相比，Servlet 具有更好的可移<br>植性、更强大的功能，更少的投资，更高的效率，更好的安全性等特点。<br>Servlet 是使用 Java Servlet 应用程序接口（API）及相关类和方法的 Java 程序。Java 语言<br>能够实现的功能，Servlet 基本上都能实现（除了图形界面之外）。Servlet 主要用于处理客<br>户端传来的 Http 请求，并返回一个响应。通常所说的 Servlet 就是指 HttpServlet，用于处理<br>Http 请求，其能够处理的请求有 doGet()、doPost()、service()等方法。在开发 Servlet 时，可<br>以直接继承 javax.servlet.http.HttpServlet。<br>Servlet 需要在 web.xml 中进行描述，例如：映射执行 Servlet 的名字，配置 Servlet 类、初<br>始化参数，进行安全配置、URL 映射和设置启动的优先权等。Servlet 不仅可以生成 HTML<br>脚本输出，也可以生成二进制表单输出。<br>Servlet 应用范围很广泛，我们现在用的很多流行的框架技术，其最基本的代码离不开<br>Servelt 的支持。比如我所熟悉的 SSH 框架，Spring 容器启动时，要在 web.xml 中装载 Spring<br>容器的 ActionContext 类来初始化 Spring 的一些参数，如进行依赖注入、数据库表的映射、<br>初始化系统的安全配置设置 read 等属性等一些相关操作。<br>132. 说一说 Servlet 的生命周期?<br>答:servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。<br>这个生存期由 javax.servlet.Servlet 接口的 init,service 和 destroy 方法表达。<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service<br>方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销<br>毁的时候调用其 destroy 方法。<br>web 容器加载 servlet，生命周期开始。通过调用 servlet 的 init()方法进行 servlet 的初始化。<br>通过调用 service()方法实现，根据请求的不同调用不同的 do***()方法。结束服务，web 容<br>器调用 servlet 的 destroy()方法。<br>133. Servlet 的基本架构<br>package test;<br>import java.io.IOException;<br>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>public class ServletName extends HttpServlet {<br>public void doPost(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public void doGet(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>}<br>}<br>134. SERVLET API 中 forward()与 redirect()的区别？<br>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后<br>者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的<br>地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量<br>使用 forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳<br>转到一个其它服务器上的资源，则必须使用 sendRedirect()方法。<br>135. 什么情况下调用 doGet()和 doPost()？<br>Jsp 页面中的 FORM 标签里的 method 属性为 get 时调用 doGet()，为 post 时调用 doPost()。<br>136. Request 对象的主要方法：<br>setAttribute(String name,Object)：设置名字为 name 的 request 的参数值<br>getAttribute(String name)：返回由 name 指定的属性值<br>getAttributeNames()：返回 request 对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有 Cookie 对象，结果是一个 Cookie 数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的 Body 的长度<br>getHeader(String name)：获得 HTTP 协议定义的文件头信息<br>getHeaders(String name)：返回指定名字的 request Header 的所有值，结果是一个枚举的实例<br>getHeaderNames()：返回所以 request Header 的名字，结果是一个枚举的实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有 name 指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实<br>例<br>getParametervalues(String name)：获得有 name 指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的 IP 地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关 Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性<br>137. 简述 HttpSession 的作用、使用方法，可用代码说明。<br>HttpSession 中 可 以 跟 踪 并 储 存 用 户 信 息 ， 把 值 设 置 到 属 性 中 ， 有 2 个 方 法 ：<br>setAttribute(),getAttrribute()；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>例如：在一个方法中用 session.setAttribute(“student”,student);在 session 中设置一个属性名为<br>student,值为一个名为 student 的对象。而后可在同一 session 范围内用 getAttribute(“student”)<br>取出该属性，得到 student 对象。<br>138. 请画出 Servlet 2.2 以上 Web Application 的基本目录结构<br>答：目录结构如下图所示：<br>webapps<br>|<br>Applocation<br>| __________________<br>| |<br>JSP 页面 WEB-INF<br>| ___________________<br>| | |<br>classes lib web.xml<br>139. cookie 和 session 的区别？<br>注意 cookie 有时候禁不掉<br>Cookie session<br>存储在客户端 存储在服务器端<br>两种类型<br>有声明周期<br>无声明周期<br>两种实现方式<br>依赖于 cookie<br>url 重写<br>父路径不能访问子路径的 cookie 同一个 session 的窗口共享一个 session<br>典型应用：<br>3 个月不用再登陆<br>购物车（<a target="_blank" rel="noopener" href="http://www.china-pub.com/%EF%BC%89">http://www.china-pub.com/）</a><br>典型应用：<br>用户登陆<br>购物车也可以用 session 实现。·<br>不可靠 可靠<br>140. forward 和 redirect 的区别<br>forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读<br>取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，<br>所以它的地址栏中还是原来的地址。<br>redirect 就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏<br>览器会用刚才请求的所有参数重新请求，所以 session,request 参数都可以获取。<br>141. request.getAttribute() 和 request.getParameter() 有何区别?<br>当你要传递普通的数据类型给下一个页面时，你在下一个页面中就可以用 getParameter()方<br>法来获得上一个页面传递过来的数据了！（普通的数据类型是指 int,float,double,string 等在<br>Java 中常用的基本类型，但是在下一个页面中你用 getParameter()方法获得的值永远只能时<br>String 类型的，你可以把 String 类型转换为你所需要的类型！）<br>当你要传递一个对象给下一个页面时，你就要使用 getAttribut()方法了！如：你要把一个 List<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>或 Map 传递到下一个页面，这时你就必须要用 setAttribut()和 getAttribut()方法传递数据了！<br>从更深层次的考虑，getParameter()方法传递数据，只会从 WEB 客户端传递到 WEB 服务器，<br>代表 HTTP 请求数据，getParameter()方法返回 String 类型的数据！setAttribut()和 getAttribut()<br>方法传递的数据只会在 WEB 服务器内部，在具有转发关系的 WEB 组件之间传递，这两个<br>方法能设置 Object 类型的共享数据！<br>142. jsp 有哪些内置对象?作用分别是什么? 分别有什么方法？<br>答:JSP 共有以下 9 个内置的对象：<br>request 用户端请求，此请求会包含来自 GET&#x2F;POST 请求的参数<br>response 网页传回用户端的回应<br>pageContext 网页的属性是在这里管理<br>session 与请求有关的会话期<br>application servlet 正在执行的内容<br>out 用来传送回应的输出<br>config servlet 的构架部件<br>page JSP 网页本身<br>exception 针对错误网页，未捕捉的例外<br>request：表示 HttpServletRequest 对象。它包含了有关浏览器请求的信息，并且提供了几个<br>用于获取 cookie, header, 和 session 数据的有用的方法。<br>response：表示 HttpServletResponse 对象，并提供了几个用于设置送回 浏览器的响应的方法<br>（如 cookies,头信息等）<br>out：对象是 javax.jsp.JspWriter 的一个实例，并提供了几个方法使你能用于向浏览器回送输<br>出结果。<br>pageContext：表示一个 javax.servlet.jsp.PageContext 对象。它是用于方便存取各种范围的名<br>字空间、servlet 相关的对象的 API，并且包装了通用的 servlet 相关功能的方法。<br>session：表示一个请求的 javax.servlet.http.HttpSession 对象。Session 可以存贮用户的状态信<br>息<br>applicaton ：表示一个 javax.servle.ServletContext 对象。这有助于查找有关 servlet 引擎和<br>servlet 环境的信息<br>config：表示一个 javax.servlet.ServletConfig 对象。该对象用于存取 servlet 实例的初始化参<br>数。<br>page：表示从该页面产生的一个 servlet 实例<br>143. 介绍在 JSP 中如何使用 JavaBeans？<br>答：在 JSP 中使用 JavaBean 常用的动作有：<br>1）&lt;jsp:useBean &#x2F;&gt;：用来创建和查找 bean 对象；<br>2）&lt;jsp:setProperty &#x2F;&gt;：用来设置 bean 的属性，即调用其 setXxx()方法；<br>3）&lt;jsp:getProperty &#x2F;&gt;：用来获得 bean 的属性，即调用其 getXxx()方法。<br>144. jsp 有哪些动作?作用分别是什么?<br>（这个问题似乎不重要，不明白为何有此题）<br>答:JSP 共有以下 6 种基本动作<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>jsp:setProperty：设置 JavaBean 的属性。<br>jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记<br>145. JSP 的常用指令<br>isErrorPage(是否能使用 Exception 对象)，isELIgnored(是否忽略表达式)<br>146. jsp 的四种范围？<br>答：a.page 是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类<br>（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括<br>被编译成 servlet 的 JSP 页面<br>b.request 是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越<br>多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系）<br>c.session 是代表与用于某个 Web 客户机的一个用户体验相关对象和属性。一个 Web<br>会话可以也经常会跨越多个客户机请求<br>d.application 是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个<br>Web 应用程序，包括多个页面、请求和会话的一个全局作用域。<br>147. JSP 中动态 INCLUDE 与静态 INCLUDE 的区别？<br>答：动态 INCLUDE 用 jsp:include 动作实现<br>&lt;jsp:include page&#x3D;included.jsp flush&#x3D;true &#x2F;&gt;它总是会检查所含文件中的变化，适合用于包含动<br>态页面，并且可以带参数 静态 INCLUDE 用 include 伪码实现,定不会检查所含文件的变化，<br>适用于包含静态页面 &lt;%@ include file&#x3D;included.htm %&gt;<br>148. 两种跳转方式分别是什么?有什么区别?<br>（下面的回答严重错误，应该是想问 forward 和 sendRedirect 的区别，毕竟出题的人不是专<br>业搞文字艺术的人，可能表达能力并不见得很强，用词不一定精准，加之其自身的技术面也<br>可能存在一些问题，不一定真正将他的意思表达清楚了，严格意思上来讲，一些题目可能根<br>本就无人能答，所以，答题时要掌握主动，只要把自己知道的表达清楚就够了，而不要去推<br>敲原始题目的具体含义是什么，不要一味想着是在答题）<br>答：有两种，分别为：<br>&lt;jsp:include page&#x3D;included.jsp flush&#x3D;true&gt;<br>&lt;jsp:forward page&#x3D; nextpage.jsp&#x2F;&gt;<br>前者页面不会转向 include 所指的页面，只是显示该页的结果，主页面还是原来的页面。执<br>行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。<br>相当于 go to 语句. 149. 页面间对象传递的方法<br>request，session，application，cookie 等<br>150. 过滤器有哪些作用？<br>答：可以验证客户是否来自可信的网络，可以对客户提交的数据进行重新编码，可以从系统<br>里获得配置的信息，可以过滤掉客户的某些不应该出现的词汇，可以验证用户是否登录，可<br>以验证客户的浏览器是否支持当前的应用，可以记录系统的日志等等。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>151. 过滤器的用法？（对客户端的请求统一编码和对客户端进行认证）<br>答：首先要实现（implements）Filter 接口，同时覆盖 Filter 接口的三个方法：<br>init(FilterConfig config) &#x2F;&#x2F;用于获得 FilterConfig 对象；<br>doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &#x2F;&#x2F;进行过滤处<br>理一些业务；<br>destroy() &#x2F;&#x2F;销毁 Filter。<br>152. JSP 和 Servlet 中的请求转发分别如何实现？<br>答：JSP 中的请求转发可利用 forward 动作实现：&lt;jsp:forward &#x2F;&gt;；<br>Serlvet 中实现请求转发的方式为：<br>getServletContext().getRequestDispatcher(path).forward(req,res)。<br>153. JSP 和 Servlet 有哪些相同点和不同点，他们之间的联系是什么？<br>JSP 是 Servlet 技术的扩展，本质上是 Servlet 的简易方式，更强调应用的外表表达。JSP 编<br>译后是”类 servlet”。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件<br>中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成<br>一个扩展名为.jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。<br>154. 详细描述 MVC。<br>答：基于 Java 的 Web 应用系统采用 MVC 架构模式，即 model（模型）、view（视图）、control<br>（控制）分离设计；这是目前 WEB 应用服务系统的主流设计方向。<br>Model：即处理业务逻辑的模块，每一种处理一个模块；<br>View：负责页面显示，显示 MODEL 处理结果给用户，主要实现数据到页面转换过程；<br>Control：负责每个请求的分发，把 FORM 数据传递给 MODEL 处理，把处理结果的数<br>据传递给 VIEW 显示。<br>155. MVC 的各个部分都有那些技术来实现?如何实现?<br>答:MVC 是 Model－View－Controller 的简写。Model 代表的是应用的业务逻辑（通过<br>JavaBean，EJB 组件实现）， View 是应用的表示面（由 JSP 页面产生），Controller 是提<br>供应用的处理过程控制（一般是一个 Servlet），通过这种设计模型把应用逻辑，处理过程<br>和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。<br>156. 在 web 应用开发过程中经常遇到输出某种编码字符，如 iso8859-1 等，如何输出一个<br>某种编码字符串？<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1”), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>157. 现在输入 n 个数字，以逗号，分开；然后可选择升或者降序排序；按提交键就在另一<br>页面显示按什么排序，结果为，提供 reset.(答案有点疑惑,问题有点不清不楚)<br>答案（1） public static String[] splitStringByComma(String source){<br>if(source&#x3D;&#x3D;null||source.trim().equals(“”))<br>return null;<br>StringTokenizer commaToker &#x3D; new StringTokenizer(source,”,”);<br>String[] result &#x3D; new String[commaToker.countTokens()];<br>int i&#x3D;0;<br>while(commaToker.hasMoreTokens()){<br>result[i] &#x3D; commaToker.nextToken();<br>i++;<br>}<br>return result;<br>}<br>循环遍历 String 数组<br>Integer.parseInt(String s)变成 int 类型<br>组成 int 数组<br>Arrays.sort(int[] a), a 数组升序<br>降序可以从尾部开始输出<br>158. 说出数据连接池的工作机制是什么?<br>答：J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客<br>户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没<br>有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用<br>的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>159. javascript 的优缺点和内置对象。<br>答：1）优点：简单易用，与 Java 有类似的语法，可以使用任何文本编辑工具编写，只需要<br>浏览器就可执行程序，并且事先不用编译，逐行执行，无需进行严格的变量声明，而且内置<br>大量现成对象，编写少量程序可以完成目标；<br>2）缺点：不适合开发大型应用程序；<br>3）Javascript 有 11 种内置对象： Array、String、Date、Math、Boolean、Number、<br>Function、Global、Error、RegExp、Object。 六、数据库部分<br>160. 存储过程和函数的区别<br>存储过程是用户定义的一系列 sql 语句的集合，涉及特定表或其它对象的任务，用户可以调<br>用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉<br>及特定用户表。<br>161. 事务是什么？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为<br>ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务：<br>原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。<br>一致性：事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都<br>必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如<br>B 树索引或双向链表）都必须是正确的。<br>隔离性：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时<br>数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状<br>态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且<br>重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。<br>持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直<br>保持。<br>162. 游标的作用？如何知道游标已经到了最后？<br>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS 可以判断是否到了最后，<br>通常此变量不等于 0 表示出错或到了最后。<br>163. 触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何<br>区别？<br>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触<br>发器可以获取事件之前和新的字段值。 语句级触发器可以在语句执行前或后执行，而行级<br>触发在触发器所影响的每一行触发一次。<br>164. 存储过程，触发器，范式，事务的概念及作用？<br>存储过程：是数据库管理系统里的一个很重要的对象。用它可以封装一些功能。把多个 SQL<br>语句封装到存储过程里面。起到封装功能的作用。类似面向对象里，封装对象的一个功能一<br>样。几乎任何可写成批处理的 Transact-SQL 代码都可用于创建存储过程。<br>触发器：触发器是在用户进行某项操作的时候，会触发触发器的执行。它类似于 JAVA 中图<br>形截面编程里的事件操作一样，是触发执行。和存储过程的主要区别在于：存储过程类似<br>JAVA 里面的对象一样，进行功能的封装（方法）。在调用的时候才会执行。而触发器只能<br>在别的操作执行的时候才会触发触发器的执行。<br>事务：类似于 JAVA 里面线程的同步一样，作为一个单元执行。它有四大特性：原子性，隔<br>离性，一致性，持久性。在 SQL SERVER 2000 里面还支持存储点的用法。大家都知道，事<br>务是做为一个单元运行，要么全部执行，要么全部不执行。但是有时候我们可以保证事务的<br>一部分可能正确执行，并且这些执行可以直接刷新到数据库里面。那么我们就可以在这个事<br>务的中间部分设置一个或者多个存储点。这样在这个事务大单元里就分成了几个小部分。如<br>果上面的部分执行正确，下面的部分执行错误，那么就没必要回滚整个事务，只需要回滚到<br>存储点的地方就可以了<br>范式：目地：规范化目的是使结构更合理，消除存储异常，使数据冗余尽量小，便于插入、<br>删除和更新<br>原则：遵从概念单一化 “一事一地”原则，即一个关系模式描述一个实体或实体间的一种联<br>系。规范的实质就是概念的单一化。<br>方法：将关系模式投影分解成两个或两个以上的关系模式。<br>要求：分解后的关系模式集合应当与原关系模式”等价”，即经过自然联接可以恢复原关系而<br>不丢失信息，并保持属性间合理联系。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>165. 写一个 SQL Server 中的存储过程:<br>以下为一个带有一个输入参数 Vdeptno ,返回部门为 Vdeptnor 的所有职员的信息. create procedure Emp_dept<br>@Vdeptno number(2) AS<br>begin<br>select * from emp where deptno&#x3D;@Vdeptno<br>end<br>166. 写一个 Oracle 中的存储过程:<br>带 IN 参数的过程<br>create or replace procedure addnew(dno IN number, name IN varchar2, location IN varchar2)IS<br>begin<br>insert into dept values(dno,name,location);<br>dbms_output.put_line(‘1 record inserted’);<br>end;<br>带 OUT 参数的过程<br>create or replace procedure getsal(name IN varchar2, salary OUT number)AS<br>begin<br>select sal into salary from emp where ename&#x3D;name;<br>end;<br>167. 数据库 SQL 语句题<br>106、有 3 个表（15 分钟）：【基础】<br>Student 学生表 (学号，姓名，性别，年龄，组织部门)<br>Course 课程表 (编号，课程名称)<br>Sc 选课表 (学号，课程编号，成绩)<br>表结构如下：<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>1）写一个 SQL 语句，查询选修了’计算机原理’的学生学号和姓名（3 分钟）<br>2）写一个 SQL 语句，查询’周星驰’同学选修了的课程名字（3 分钟）<br>3）写一个 SQL 语句，查询选修了 5 门课程的学生学号和姓名（9 分钟）<br>答：1）SQL 语句如下：<br>select stu.sno, stu.sname from Student stu<br>where (select count(<em>) from sc where sno&#x3D;stu.sno and cno &#x3D;<br>(select cno from Course where cname&#x3D;’计算机原理’)) !&#x3D; 0;<br>2）SQL 语句如下：<br>select cname from Course<br>where cno in ( select cno from sc where sno &#x3D;<br>(select sno from Student where sname&#x3D;’周星驰’));<br>3）SQL 语句如下：<br>select stu.sno, stu.sname from student stu<br>where (select count(</em>) from sc where sno&#x3D;stu.sno) &#x3D; 5;<br>107、有三张表,学生表 S,课程 C,学生课程表 SC,学生可以选修多门课程,一门课程可以被多个<br>学生选修,通过 SC 表关联。【基础】<br>1）写出建表语句；<br>2）写出 SQL 语句,查询选修了所有选修课程的学生；<br>3）写出 SQL 语句,查询选修了至少 5 门以上的课程的学生。<br>答：1）建表语句如下（mysql 数据库）：<br>create table s(id integer primary key, name varchar(20));<br>create table c(id integer primary key, name varchar(20));<br>create table sc(<br>sid integer references s(id), cid integer references c(id), primary key(sid,cid)<br>);<br>2）SQL 语句如下：<br>select stu.id, stu.name from s stu<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>where (select count(<em>) from sc where sid&#x3D;stu.id) &#x3D; (select count(</em>) from c);<br>3）SQL 语句如下：<br>select stu.id, stu.name from s stu<br>where (select count(<em>) from sc where sid&#x3D;stu.id)&gt;&#x3D;5;<br>108、数据库表(Test)结构如下：【基础】<br>ID NAME AGE MANAGER(所属主管人 ID)<br>106 A 30 104<br>109 B 19 104<br>104 C 20 111<br>107 D 35 109<br>112 E 25 120<br>119 F 45 NULL<br>要求:列出所有年龄比所属主管年龄大的人的 ID 和名字?<br>答：SQL 语句如下：<br>select employee.name from test employee<br>where employee.age &gt; (select manager.age from test manager<br>where manager.id&#x3D;employee.manager);<br>109、有如下两张表：【中等难度】<br>表 city： 表 state：<br>欲得到如下结果：<br>City No City Name State No State Name<br>BJ 北京 （Null） （Null）<br>DL 大连 LN 辽宁<br>GZ 广州 GD 广东<br>SH 上海 （Null） （Null）<br>写相应的 SQL 语句。<br>答：SQL 语句为：<br>SELECT C.CITYNO, C.CITYNAME, C.STATENO, S.STATENAME<br>FROM CITY C, STATE S<br>WHERE C.STATENO&#x3D;S.STATENO(+)<br>ORDER BY(C.CITYNO);<br>168. 用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。<br>employee:<br>eid,ename,salary,deptid;<br>select * from employee order by deptid desc,salary<br>169. 列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序<br>CityNo CityName StateNo<br>BJ 北京 （Null）<br>SH 上海 （Null）<br>GZ 广州 GD<br>DL 大连 LN<br>State No State Name<br>GD 广东<br>LN 辽宁<br>SD 山东<br>NMG 内蒙古<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>创建表：<br>mysql&gt; create table employee921(id int primary key auto_increment,name varchar(5<br>0),salary bigint,deptid int);<br>插入实验数据：<br>mysql&gt; insert into employee921 values(null,’zs’,1000,1),(null,’ls’,1100,1),(null<br>,’ww’,1100,1),(null,’zl’,900,1) ,(null,’zl’,1000,2), (null,’zl’,900,2) ,(null,’z<br>l’,1000,2) , (null,’zl’,1100,2);<br>编写 sql 语句：<br>（）select avg(salary) from employee921 group by deptid;<br>（）mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 where deptid &#x3D;<br>tid);<br>效率低的一个语句，仅供学习参考使用（在 group by 之后不能使用 where，只能使用<br>having，在 group by 之前可以使用 where，即表示对过滤后的结果分组）：<br>mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 group by deptid<br>having deptid &#x3D; tid);<br>（）select count(</em>) ,tid<br>from (<br>select employee921.id,employee921.name,employee921.salary,employee921.deptid tid<br>from employee921<br>where salary &gt;<br>(select avg(salary) from employee921 where deptid &#x3D; tid)<br>) as t<br>group by tid ;<br>另外一种方式：关联查询<br>select a.ename,a.salary,a.deptid<br>from emp a, (select deptd,avg(salary) avgsal from emp group by deptid ) b<br>where a.deptid&#x3D;b.deptid and a.salary&gt;b.avgsal;<br>170. 存储过程与触发器必须讲，经常被面试到?<br>create procedure insert_Student (_name varchar(50),_age int ,out _id int)<br>begin<br>insert into student value(null,_name,_age);<br>select max(stuId) into _id from student;<br>end;<br>call insert_Student(‘wfz’,23,@id);<br>select @id;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>mysql&gt; create trigger update_Student BEFORE update on student FOR EACH ROW<br>-&gt; select * from student;<br>触发器不允许返回结果<br>create trigger update_Student BEFORE update on student FOR EACH ROW<br>insert into student value(null,’zxx’,28);<br>mysql 的触发器目前不能对当前表进行操作<br>create trigger update_Student BEFORE update on student FOR EACH ROW<br>delete from articles where id&#x3D;8;<br>这个例子不是很好，最好是用删除一个用户时，顺带删除该用户的所有帖子<br>这里要注意使用 OLD.id<br>触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，<br>其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而 UCH<br>没有用触发器，效率和数据处理能力都很低。<br>存储过程的实验步骤：<br>mysql&gt; delimiter |<br>mysql&gt; create procedure insertArticle_Procedure (pTitle varchar(50),pBid int,out<br>pId int)<br>-&gt; begin<br>-&gt; insert into article1 value(null,pTitle,pBid); -&gt; select max(id) into pId from article1; -&gt; end; -&gt; |<br>Query OK, 0 rows affected (0.05 sec)<br>mysql&gt; call insertArticle_Procedure(‘中国北京’,1,@pid); -&gt; |<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; delimiter ;<br>mysql&gt; select @pid;<br>+——+<br>| @pid |<br>+——+<br>| 3 |<br>+——+<br>1 row in set (0.00 sec)<br>mysql&gt; select * from article1;<br>+—-+————–+——+<br>| id | title | bid |<br>+—-+————–+——+<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>| 1 | test | 1 |<br>| 2 | chuanzhiboke | 1 |<br>| 3 | 中国北京 | 1 |<br>+—-+————–+——+<br>3 rows in set (0.00 sec)<br>触发器的实验步骤：<br>create table board1(id int primary key auto_increment,name varchar(50),ar<br>ticleCount int);<br>create table article1(id int primary key auto_increment,title varchar(50)<br>,bid int references board1(id));<br>delimiter |<br>create trigger insertArticle_Trigger after insert on article1 for each ro<br>w begin<br>-&gt; update board1 set articleCount&#x3D;articleCount+1 where id&#x3D; NEW.bid; -&gt; end; -&gt; |<br>delimiter ;<br>insert into board1 value (null,’test’,0);<br>insert into article1 value(null,’test’,1);<br>还有，每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，<br>用触发器做效率就很高。下次课设计这样一个案例，写触发器时，对于最后发帖时间可能需<br>要用 declare 方式声明一个变量，或者是用 NEW.posttime 来生成。<br>171. 数据库三范式是什么?<br>第一范式（1NF）：字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式）<br>数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一<br>个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的<br>字段。<br>第二范式（2NF）：第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足<br>第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以<br>被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被<br>称为主关键字或主键。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依<br>赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一<br>部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通<br>常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非<br>部分依赖于主关键字。<br>第三范式的要求如下： 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。所以<br>第三范式具有如下特征：<br>1，每一列只有一个值 。2，每一行都能区分。3，每一个表都不包含其他表已经包含<br>的非主关键字信息。<br>例如，帖子表中只能出现发帖人的 id，而不能出现发帖人的 id，还同时出现发帖人姓名，<br>否则，只要出现同一发帖人 id 的所有记录，它们中的姓名部分都必须严格保持一致，这就<br>是数据冗余。<br>172. 说出一些数据库优化方面的经验?<br>用 PreparedStatement 一般来说比 Statement 性能高：一个 sql 发给服务器执行，步骤：语法<br>检查、语义分析， 编译，缓存<br>“inert into user values(1,1,1)”-二进制<br>“inert into user values(2,2,2)”-二进制<br>“inert into user values(?,?,?)”-二进制<br>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就<br>去掉外键。（比喻：就好比免检产品，就是为了提高效率，充分相信产品的制造商）<br>（对于 hibernate 来说，就应该有一个变化：empleyee-&gt;Deptment 对象，现在设计时就成了<br>employeedeptid）<br>看 mysql 帮助文档子查询章节的最后部分，例如，根据扫描的原理，下面的子查询语句要比<br>第二条关联查询的效率高：</p><ol><li>select e.name,e.salary where e.managerid&#x3D;(select id from employee where name&#x3D;’zxx’);</li><li>select e.name,e.salary,m.name,m.salary from employees e,employees m where<br>e.managerid &#x3D; m.id and m.name&#x3D;’zxx’;<br>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等<br>将姓名和密码单独从用户表中独立出来。这可以是非常好的一对一的案例哟！<br>sql 语句全部大写，特别是列名和表名都大写。特别是 sql 命令的缓存功能，更加需要统一<br>大小写，sql 语句发给 oracle 服务器语法检查和编译成为内部指令缓存和执行指令。<br>根据缓存的特点，不要拼凑条件，而是用?和 PreparedStatment<br>还有索引对查询性能的改进也是值得关注的。<br>备注：下面是关于性能的讨论举例<br>4 航班 3 个城市<br>m*n<br>select * from flight,city where flight.startcityid&#x3D;city.cityid and city.name&#x3D;’beijing’;<br>m + n<br>select * from flight where startcityid &#x3D; (select cityid from city where cityname&#x3D;’beijing’);<br>select flight.id,’beijing’,flight.flightTime from flight where startcityid &#x3D; (select cityid from city<br>where cityname&#x3D;’beijing’)</li><li>union 和 union all 有什么不同?<br>假设我们有一个表 Student，包括以下字段与数据：<br>drop table student;<br>create table student<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(<br>id int primary key, name nvarchar2(50) not null, score number not null<br>);<br>insert into student values(1,’Aaron’,78);<br>insert into student values(2,’Bill’,76);<br>insert into student values(3,’Cindy’,89);<br>insert into student values(4,’Damon’,90);<br>insert into student values(5,’Ella’,73);<br>insert into student values(6,’Frado’,61);<br>insert into student values(7,’Gill’,99);<br>insert into student values(8,’Hellen’,56);<br>insert into student values(9,’Ivan’,93);<br>insert into student values(10,’Jay’,90);<br>commit;<br>Union 和 Union All 的区别。<br>select *from studentwhere id &lt; 4union<br>select *from studentwhere id &gt; 2 and id &lt; 6<br>结果将是<br>1 Aaron 78<br>2 Bill 76<br>3 Cindy 89<br>4 Damon 90<br>5 Ella 73<br>如果换成 Union All 连接两个结果集，则返回结果是：<br>1 Aaron 78<br>2 Bill 76<br>3 Cindy 89<br>3 Cindy 89<br>4 Damon 90<br>5 Ella 73<br>可以看到，Union 和 Union All 的区别之一在于对重复结果的处理。<br>UNION 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进<br>行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常<br>见的是过程表与历史表 UNION。如：<br>select * from gc_dfys<br>union<br>select * from ls_jg_dfys<br>这个 SQL 在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后<br>返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。<br>而 UNION ALL 只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有<br>重复的数据，那么返回的结果集就会包含重复的数据了。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>从效率上说，UNION ALL 要比 UNION 快很多，所以，如果可以确认合并的两个结果集<br>中不包含重复的数据的话，那么就使用 UNION ALL，</li><li>分页语句<br>取出 sql 表中第 31 到 40 的记录（以自动增长 ID 为主键）<br>sql server 方案 1：<br>select top 10 * from t where id not in (select top 30 id from t order by id ) orde by id<br>sql server 方案 2：<br>select top 10 * from t where id in (select top 40 id from t order by id) order by id desc<br>mysql 方案：select * from t order by id limit 30,10<br>oracle 方案：select * from (select rownum r,* from t where r&lt;&#x3D;40) where r&gt;30<br>——————–待整理进去的内容————————————- pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>1.分页技术 1（直接利用 sql 语句进行分页，效率最高和最推荐的）<br>mysql:sql &#x3D; “select * from articles limit “ + (pageNo-1)<em>pageSize + “,” + pageSize;<br>oracle: sql &#x3D; “select * from “ +”(select rownum r,</em> from “ +”(select * from articles order by<br>postime desc)” +”where rownum&lt;&#x3D; “ + pageNo*pageSize +”) tmp “ +”where r&gt;” +<br>(pageNo-1)*pageSize;<br>注释：第 7 行保证 rownum 的顺序是确定的，因为 oracle 的索引会造成 rownum 返回不同的<br>值<br>简洋提示：没有 order by 时，rownum 按顺序输出，一旦有了 order by，rownum 不按顺序输<br>出了，这说明 rownum 是排序前的编号。如果对 order by 从句中的字段建立了索引，那么，<br>rownum 也是按顺序输出的，因为这时候生成原始的查询结果集时会参照索引表的顺序来构<br>建。<br>sqlserver:sql &#x3D; “select top 10 * from id not id(select top “ + (pageNo-1)*pageSize + “id from<br>articles)” DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D; cn.prepareSatement(sql);<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>while(rs.next()){<br>out.println(rs.getString(1));<br>}<br>2.不可滚动的游标<br>pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>cn &#x3D; null<br>stmt &#x3D; null;<br>rs &#x3D; null;<br>try{<br>sqlserver:sql &#x3D; “select * from articles”;<br>DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D; cn.prepareSatement(sql);<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>for(int j&#x3D;0;j&lt;(pageNo-1)*pageSize;j++){<br>rs.next();<br>}<br>int i&#x3D;0;<br>while(rs.next() &amp;&amp; i&lt;10){<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly{<br>if(rs!&#x3D;null)try{rs.close();}catch(Exception e){}<br>if(stm……… if(cn………… }<br>3.可滚动的游标<br>pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>cn &#x3D; null<br>stmt &#x3D; null;<br>rs &#x3D; null;<br>try{<br>sqlserver:sql &#x3D; “select * from articles”;<br>DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D;<br>cn.prepareSatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,…);<br>&#x2F;&#x2F;根据上面这行代码的异常 SQLFeatureNotSupportedException，就可判断驱动是否支持可滚<br>动游标<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>rs.absolute((pageNo-1)*pageSize)<br>int i&#x3D;0;<br>while(rs.next() &amp;&amp; i&lt;10){<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly{<br>if(rs!&#x3D;null)try{rs.close();}catch(Exception e){}<br>if(stm……… if(cn………… }</li><li>用一条 SQL 语句 查询出每门课都大于 80 分的学生姓名<br>name kecheng fenshu<br>张三 语文 81<br>张三 数学 75<br>李四 语文 76<br>李四 数学 90<br>王五 语文 81<br>王五 数学 100<br>王五 英语 90<br>准备数据的 sql 代码：<br>create table score(id int primary key auto_increment,name varchar(20),subject varchar(20),score<br>int);<br>insert into score values<br>(null,’张三’,’语文’,81), (null,’张三’,’数学’,75), (null,’李四’,’语文’,76), (null,’李四’,’数学’,90), (null,’王五’,’语文’,81), (null,’王五’,’数学’,100), (null,’王五 ‘,’英语’,90);<br>提示：当百思不得其解时，请理想思维，把小变成大做，把大变成小做，<br>答案：<br>A: select distinct name from score where name not in (select distinct name from score where<br>score&lt;&#x3D;80)<br>B:select distince name t1 from score where 80&lt; all (select score from score where name&#x3D;t1);</li><li>所有部门之间的比赛组合<br>一个叫 department 的表，里面只有一个字段 name,一共有 4 条纪录，分别是 a,b,c,d,对应四个<br>球对，现在四个球对进行比赛，用一条 sql 语句显示所有可能的比赛组合.<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>答：select a.name, b.name from team a, team b where a.name &lt; b.name</li><li>每个月份的发生额都比 101 科目多的科目<br>请用 SQL 语句实现：从 TestDB 数据表中查询出所有月份的发生额都比 101 科目相应月份的<br>发生额高的科目。请注意：TestDB 中有很多科目，都有 1－12 月份的发生额。<br>AccID：科目代码，Occmonth：发生额月份，DebitOccur：发生额。<br>数据库名：JcyAudit，数据集：Select * from TestDB<br>准备数据的 sql 代码：<br>drop table if exists TestDB;<br>create table TestDB(id int primary key auto_increment,AccID varchar(20), Occmonth date, DebitOccur bigint);<br>insert into TestDB values<br>(null,’101’,’1988-1-1’,100), (null,’101’,’1988-2-1’,110), (null,’101’,’1988-3-1’,120), (null,’101’,’1988-4-1’,100), (null,’101’,’1988-5-1’,100), (null,’101’,’1988-6-1’,100), (null,’101’,’1988-7-1’,100), (null,’101’,’1988-8-1’,100); –复制上面的数据，故意把第一个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’102’,’1988-1-1’,90), (null,’102’,’1988-2-1’,110), (null,’102’,’1988-3-1’,120), (null,’102’,’1988-4-1’,100), (null,’102’,’1988-5-1’,100), (null,’102’,’1988-6-1’,100), (null,’102’,’1988-7-1’,100), (null,’102’,’1988-8-1’,100); –复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’103’,’1988-1-1’,150), (null,’103’,’1988-2-1’,160), (null,’103’,’1988-3-1’,180), (null,’103’,’1988-4-1’,120), (null,’103’,’1988-5-1’,120), (null,’103’,’1988-6-1’,120), (null,’103’,’1988-7-1’,120), (null,’103’,’1988-8-1’,120); –复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’104’,’1988-1-1’,130), (null,’104’,’1988-2-1’,130), (null,’104’,’1988-3-1’,140),<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(null,’104’,’1988-4-1’,150), (null,’104’,’1988-5-1’,160), (null,’104’,’1988-6-1’,170), (null,’104’,’1988-7-1’,180), (null,’104’,’1988-8-1’,140); –复制最上面的数据，故意把第二个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’105’,’1988-1-1’,100), (null,’105’,’1988-2-1’,80), (null,’105’,’1988-3-1’,120), (null,’105’,’1988-4-1’,100), (null,’105’,’1988-5-1’,100), (null,’105’,’1988-6-1’,100), (null,’105’,’1988-7-1’,100), (null,’105’,’1988-8-1’,100);<br>答案：<br>select distinct AccID from TestDB<br>where AccID not in<br>(select TestDB.AccIDfrom TestDB, (select * from TestDB where AccID&#x3D;’101’) as db101<br>where TestDB.Occmonth&#x3D;db101.Occmonth and TestDB.DebitOccur&lt;&#x3D;db101.DebitOccur<br>);</li><li>统计每年每月的信息<br>year month amount<br>1991 1 1.1<br>1991 2 1.2<br>1991 3 1.3<br>1991 4 1.4<br>1992 1 2.1<br>1992 2 2.2<br>1992 3 2.3<br>1992 4 2.4<br>查成这样一个结果<br>year m1 m2 m3 m4<br>1991 1.1 1.2 1.3 1.4<br>1992 2.1 2.2 2.3 2.4<br>提示：这个与工资条非常类似，与学生的科目成绩也很相似。<br>准备 sql 语句：<br>drop table if exists sales;<br>create table sales(id int auto_increment primary key,year varchar(10), month varchar(10), amount<br>float(2,1));<br>insert into sales values<br>(null,’1991’,’1’,1.1),<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(null,’1991’,’2’,1.2), (null,’1991’,’3’,1.3), (null,’1991’,’4’,1.4), (null,’1992’,’1’,2.1), (null,’1992’,’2’,2.2), (null,’1992’,’3’,2.3), (null,’1992’,’4’,2.4);<br>答案一、select sales.year , (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘1’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘2’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘3’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) as ‘4’ from sales group by year;</li><li>显示文章标题，发帖人、最后回复时间<br>表：id,title,postuser,postdate,parentid<br>准备 sql 语句：<br>drop table if exists articles;<br>create table articles(id int auto_increment primary key,title varchar(50), postuser varchar(10), postdate datetime,parentid int references articles(id));<br>insert into articles values<br>(null,’第一条’,’张三’,’1998-10-10 12:32:32’,null), (null,’第二条’,’张三’,’1998-10-10 12:34:32’,null), (null,’第一条回复 1’,’李四’,’1998-10-10 12:35:32’,1), (null,’第二条回复 1’,’李四’,’1998-10-10 12:36:32’,2), (null,’第一条回复 2’,’王五’,’1998-10-10 12:37:32’,1), (null,’第一条回复 3’,’李四’,’1998-10-10 12:38:32’,1), (null,’第二条回复 2’,’李四’,’1998-10-10 12:39:32’,2), (null,’第一条回复 4’,’王五’,’1998-10-10 12:39:40’,1);<br>答案：<br>select a.title,a.postuser, (select max(postdate) from articles where parentid&#x3D;a.id) reply<br>from articles a where a.parentid is null;<br>注释：子查询可以用在选择列中，也可用于 where 的比较条件中，还可以用于 from 从句中。</li><li>删除除了 id 号不同,其他都相同的学生冗余信息<br>2.学生表 如下:<br>id 号 学号 姓名 课程编号 课程名称 分数<br>1 2005001 张三 0001 数学 69<br>2 2005002 李四 0001 数学 89<br>3 2005001 张三 0001 数学 69<br>A: delete from tablename where id 号 not in(select min(id 号) from tablename group by 学号,姓<br>名,课程编号,课程名称,分数)<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实验：<br>create table student2(id int auto_increment primary key,code varchar(20),name varchar(20));<br>insert into student2 values(null,’2005001’,’张三’),(null,’2005002’,’李四’),(null,’2005001’,’张三’);<br>&#x2F;&#x2F;如下语句，mysql 报告错误，可能删除依赖后面统计语句，而删除又导致统计语句结果不<br>一致。<br>delete from student2 where id not in(select min(id) from student2 group by name);<br>&#x2F;&#x2F;但是，如下语句没有问题：<br>select * from student2 where id not in(select min(id) from student2 group by name);<br>&#x2F;&#x2F;于是，我想先把分组的结果做成虚表，然后从虚表中选出结果，最后再将结果作为删除的<br>条件数据。<br>delete from student2 where id not in(select mid from (select min(id) mid<br>from student2 group by name) as t);<br>或者：<br>delete from student2 where id not in(select min(id) from (select * from s<br>tudent2) as t group by t.name);</li><li>航空网的几个航班查询题：<br>表结构如下：<br>flight{flightID,StartCityID ,endCityID,StartTime}<br>city{cityID, CityName)<br>实验环境：<br>create table city(cityID int auto_increment primary key,cityName varchar(20));<br>create table flight (flightID int auto_increment primary key, StartCityID int references city(cityID), endCityID int references city(cityID), StartTime timestamp);<br>&#x2F;&#x2F;航班本来应该没有日期部分才好，但是下面的题目当中涉及到了日期<br>insert into city values(null,’北京’),(null,’上海’),(null,’广州’);<br>insert into flight values<br>(null,1,2,’9:37:23’),(null,1,3,’9:37:23’),(null,1,2,’10:37:23’),(null,2,3,’10:37:23’);<br>1、查询起飞城市是北京的所有航班，按到达城市的名字排序<br>参与运算的列是我起码能够显示出来的那些列，但最终我不一定把它们显示出来。各个表组<br>合出来的中间结果字段中必须包含所有运算的字段。<br>select * from flight f,city c<br>where f.endcityid &#x3D; c.cityid and startcityid &#x3D;<br>(select c1.cityid from city c1 where c1.cityname &#x3D; “北京”)<br>order by c.cityname asc;<br>mysql&gt; select flight.flightid,’北京’ startcity, e.cityname from flight,city e wh<br>ere flight.endcityid&#x3D;e.cityid and flight.startcityid&#x3D;(select cityid from city wh<br>ere cityname&#x3D;’北京’);<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>mysql&gt; select flight.flightid,s.cityname,e.cityname from flight,city s,city e wh<br>ere flight.startcityid&#x3D;s.cityid and s.cityname&#x3D;’北京’ and flight.endCityId&#x3D;e.cit<br>yID order by e.cityName desc;<br>2、查询北京到上海的所有航班纪录（起飞城市，到达城市，起飞时间，航班号）<br>select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID&#x3D;c1.cityID<br>and f.endCityID&#x3D;c2.cityID<br>and c1.cityName&#x3D;’北京’ and c2.cityName&#x3D;’上海’ 3、查询具体某一天（2005-5-8）的北京到上海的的航班次数<br>select count(<em>) from<br>(select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID&#x3D;c1.cityID<br>and f.endCityID&#x3D;c2.cityID<br>and c1.cityName&#x3D;’北京’ and c2.cityName&#x3D;’上海’ and 查帮助获得的某个日期处理函数(startTime) like ‘2005-5-8%’ mysql 中提取日期部分进行比较的示例代码如下：<br>select * from flight where date_format(starttime,’%Y-%m-%d’)&#x3D;’1998-01-02’ 182. 查出比经理薪水还高的员工信息：<br>Drop table if not exists employees;<br>create table employees(id int primary key auto_increment,name varchar(50)<br>,salary int,managerid int references employees(id));<br>insert into employees values (null,’ lhm’,10000,null), (null,’ zxx’,15000,1<br>),(null,’flx’,9000,1),(null,’tg’,10000,2),(null,’wzg’,10000,3);<br>Wzg 大于 flx,lhm 大于 zxx<br>解题思路：<br>根据 sql 语句的查询特点，是逐行进行运算，不可能两行同时参与运算。<br>涉及了员工薪水和经理薪水，所有，一行记录要同时包含两个薪水，所有想到要把这个表自<br>关联组合一下。<br>首先要组合出一个包含有各个员工及该员工的经理信息的长记录，譬如，左半部分是员工，<br>右半部分是经理。而迪卡尔积会组合出很多垃圾信息，先去除这些垃圾信息。<br>select e.</em> from employees e,employees m where e.managerid&#x3D;m.id and e.sala<br>ry&gt;m.salary;</li><li>求出小于 45 岁的各个老师所带的大于 12 岁的学生人数<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>数据库中有 3 个表 teacher 表，student 表，tea_stu 关系表。<br>teacher 表 teaID name age<br>student 表 stuID name age<br>teacher_student 表 teaID stuID<br>要求用一条 sql 查询出这样的结果<br>1.显示的字段要有老师 name, age 每个老师所带的学生人数<br>2.只列出老师 age 为 40 以下，学生 age 为 12 以上的记录<br>预 备 知 识 : 1.sql 语 句 是 对 每 一 条 记 录 依 次 处 理 ， 条 件 为 真 则 执 行 动 作<br>（select,insert,delete,update）<br>2.只要是迪卡尔积，就会产生“垃圾”信息，所以，只要迪卡尔积了，我们首先<br>就要想到清除“垃圾”信息<br>实验准备： drop table if exists tea_stu;<br>drop table if exists teacher;<br>drop table if exists student;<br>create table teacher(teaID int primary key,name varchar(50),age int);<br>create table student(stuID int primary key,name varchar(50),age int);<br>create table tea_stu(teaID int references teacher(teaID),stuID int references<br>student(stuID));<br>insert into teacher values(1,’zxx’,45), (2,’lhm’,25) , (3,’wzg’,26) , (4,’tg’,27);<br>insert into student values(1,’wy’,11), (2,’dh’,25) , (3,’ysq’,26) , (4,’mxc’,27);<br>insert into tea_stu values(1,1), (1,2), (1,3);<br>insert into tea_stu values(2,2), (2,3), (2,4);<br>insert into tea_stu values(3,3), (3,4), (3,1);<br>insert into tea_stu values(4,4), (4,1), (4,2) , (4,3);<br>结果：23,32,43<br>解题思路：（真实面试答题时，也要写出每个分析步骤，如果纸张不够，就找别人要）<br>1.要会统计分组信息，统计信息放在中间表中：<br>select teaid,count(<em>) from tea_stu group by teaid;<br>2.接着其实应该是筛除掉小于 12 岁的学生，然后再进行统计，中间表必须与 student 关联才<br>能得到 12 岁以下学生和把该学生记录从中间表中剔除，代码是：<br>select tea_stu.teaid,count(</em>) total from student,tea_stu<br>where student.stuid&#x3D;tea_stu.stuid and student.age&gt;12 group by tea_stu.teaid<br>3.接着把上面的结果做成虚表与 teacher 进行关联，并筛除大于 45 的老师<br>select teacher.teaid,teacher.name,total from teacher ,(select tea_stu.tea<br>id,count(*) total from student,tea_stu where student.stuid&#x3D;tea_stu.stuid and stu<br>dent.age&gt;12 group by tea_stu.teaid) as tea_stu2 where teacher.teaid&#x3D;tea_stu2.tea<br>id and teacher.age&lt;45;</li><li>求出发帖最多的人：<br>select authorid,count(<em>) total from articles<br>group by authorid<br>having total&#x3D;(select max(total2) from (select count(</em>) total2 from articles group by authorid) as t);<br>select t.authorid,max(t.total) from（select authorid,count(<em>) total from articles ）as t<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>这条语句不行，因为 max 只有一列，不能与其他列混淆。<br>select authorid,count(</em>) total from articles<br>group by authorid having total&#x3D;max(total)也不行。</li><li>一个用户表中有一个积分字段，假如数据库中有 100 多万个用户，若要在每年第一天<br>凌晨将积分清零，你将考虑什么，你将想什么办法解决?<br>alter table drop column score;<br>alter table add colunm score int;<br>可能会很快，但是需要试验，试验不能拿真实的环境来操刀，并且要注意，<br>这样的操作时无法回滚的，在我的印象中，只有 inert update delete 等 DML 语句才能回滚，<br>对于 create table,drop table ,alter table 等 DDL 语句是不能回滚。<br>解决方案一，update user set score&#x3D;0;<br>解决方案二，假设上面的代码要执行好长时间，超出我们的容忍范围，那我就 alter table user<br>drop column score;alter table user add column score int。<br>下面代码实现每年的那个凌晨时刻进行清零。<br>Runnable runnable &#x3D;<br>new Runnable(){<br>public void run(){<br>clearDb();<br>schedule(this,new Date(new Date().getYear()+1,0,0));<br>}<br>};<br>schedule(runnable, new Date(new Date().getYear()+1,0,1));</li><li>一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。<br>select count(*) as num,tb.id from tb, (select role from tb where id&#x3D;xxx) as t1<br>where tb.role &#x3D; t1.role and tb.id !&#x3D; t1.id<br>group by tb.id<br>having num &#x3D; select count(role) from tb where id&#x3D;xxx;</li><li>xxx 公司的 sql 面试<br>Table EMPLOYEES Structure:<br>EMPLOYEE_ID NUMBER Primary Key, FIRST_NAME VARCHAR2(25), LAST_NAME VARCHAR2(25), Salary number(8,2), HiredDate DATE, Departmentid number(2)<br>Table Departments Structure:<br>Departmentid number(2) Primary Key, DepartmentName VARCHAR2(25).<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(2）基于上述 EMPLOYEES 表写出查询：写出雇用日期在今年的，或者工资在[1000,2000]<br>之间的，或者员工姓名（last_name）以’Obama’打头的所有员工，列出这些员工的全部个人<br>信息。（4 分）<br>select * from employees<br>where Year(hiredDate) &#x3D; Year(date())<br>or (salary between 1000 and 200)<br>or left(last_name,3)&#x3D;’abc’;<br>(3) 基于上述 EMPLOYEES 表写出查询：查出部门平均工资大于 1800 元的部门的所有员工，<br>列出这些员工的全部个人信息。<br>mysql&gt; select id,name,salary,deptid did from employee1 where (select avg(salary)<br>from employee1 where deptid &#x3D; did) &gt; 1800;<br>(4) 基于上述 EMPLOYEES 表写出查询：查出个人工资高于其所在部门平均工资的员工，<br>列出这些员工的全部个人信息及该员工工资高出部门平均工资百分比。（5 分）<br>select employee1.*,(employee1.salary-t.avgSalary)*100&#x2F;employee1.salary<br>from employee1, (select deptid,avg(salary) avgSalary from employee1 group by deptid) as t<br>where employee1.deptid &#x3D; t.deptid and employee1.salary&gt;t.avgSalary;</li><li>注册 Jdbc 驱动程序的三种方式?<br>如下:</li><li>Class.forName(“com.mysql.jdbc.Driver”);</li><li>System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”);</li><li>DriverManager.registerDriver(new com.mysql.jdbc.Driver());<br>1 中，不需要.newInstance()<br>2 中，通过系统的属性设置即可<br>3 中，是看起来比较直观的一种方式，注册相应的 db 的 jdbc 驱动，<br>总结：推荐 1，和 2 两种方式。<br>原因：3 在编译时需要导入对应的 lib。1，2 不需要。<br>补充：2 的方式的话，可以同时导入多个 jdbc 驱动，中间用冒号“：”分开</li><li>用 JDBC 如何调用存储过程<br>代码如下：<br>package com.huawei.interview.lym;<br>import java.sql.CallableStatement;<br>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;<br>import java.sql.Types;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public class JdbcTest {<br>public static void main(String[] args) {<br>Connection cn &#x3D; null;<br>CallableStatement cstmt &#x3D; null;<br>try {<br>&#x2F;&#x2F;这里最好不要这么干，因为驱动名写死在程序中了<br>Class.forName(“com.mysql.jdbc.Driver”);<br>&#x2F;&#x2F;实际项目中，这里应用 DataSource 数据，如果用框架，<br>&#x2F;&#x2F;这个数据源不需要我们编码创建，我们只需 Datasource ds &#x3D; context.lookup()<br>&#x2F;&#x2F;cn &#x3D; ds.getConnection();<br>cn &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;&#x2F;test”,”root”,”root”);<br>cstmt &#x3D; cn.prepareCall(“{call insert_Student(?,?,?)}”);<br>cstmt.registerOutParameter(3,Types.INTEGER);<br>cstmt.setString(1, “wangwu”);<br>cstmt.setInt(2, 25);<br>cstmt.execute();<br>&#x2F;&#x2F;get 第几个，不同的数据库不一样，建议不写<br>System.out.println(cstmt.getString(3));<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>finally{<br>&#x2F;<em>try{cstmt.close();}catch(Exception e){}<br>try{cn.close();}catch(Exception e){}</em>&#x2F;<br>try {<br>if(cstmt !&#x3D; null)<br>cstmt.close();<br>if(cn !&#x3D; null)<br>cn.close();<br>} catch (SQLException e) {<br>e.printStackTrace();<br>}<br>}<br>}</li><li>JDBC 中的 PreparedStatement 相比 Statement 的好处<br>答：一个 sql 命令发给服务器去执行的步骤为：语法检查，语义分析，编译成内部指令，缓<br>存指令，执行指令等过程。<br>select * from student where id &#x3D;3—-缓存–xxxxx 二进制命令<br>select * from student where id &#x3D;3—-直接取-xxxxx 二进制命令<br>select * from student where id &#x3D;4— -会怎么干？<br>如果当初是 select * from student where id &#x3D;?— -又会怎么干？<br>上面说的是性能提高<br>可以防止 sql 注入。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</li><li>写一个用 jdbc 连接并访问 oracle 数据的程序代码, 能够完成修改和查询工作。<br>public void testJdbc(){<br>Connection con &#x3D; null;<br>PreparedStatement ps &#x3D; null;<br>ResultSet rs &#x3D; null;<br>try{<br>&#x2F;&#x2F;step1：注册驱动；<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>&#x2F;&#x2F;step 2：获取数据库连接；<br>con&#x3D;DriverManager.getConnection( “jdbc:oracle:thin:@192.168.0.39:1521:TARENADB”, “sd0605”,”sd0605”);<br>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>查 询</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>&#x2F;<br>&#x2F;&#x2F;step 3：创建 Statement；<br>String sql &#x3D; “SELECT id, fname, lname, age, FROM Person_Tbl”;<br>ps &#x3D; con.prepareStatement(sql);<br>&#x2F;&#x2F;step 4 ：执行查询语句，获取结果集；<br>rs &#x3D; ps.executeQuery();<br>&#x2F;&#x2F;step 5：处理结果集—输出结果集中保存的查询结果；<br>while (rs.next()){<br>System.out.print(“id &#x3D; “ + rs.getLong(“id”));<br>System.out.print(“ , fname &#x3D; “ + rs.getString(“fname”));<br>System.out.print(“ , lname &#x3D; “ + rs.getString(“lname”));<br>System.out.print(“ , age &#x3D; “ + rs.getInt(“age”));<br>}<br>&#x2F;***<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>JDBC 修 改</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F;<br>sql &#x3D; “UPDATE Person_Tbl SET age&#x3D;23 WHERE id &#x3D; ?”;<br>ps &#x3D; con.prepareStatement(sql);<br>ps.setLong(1, 88);<br>int rows &#x3D; ps.executeUpdate();<br>System.out.println(rows + “ rows affected.”);<br>} catch (Exception e){<br>e.printStackTrace();<br>} finally{<br>try{<br>con.close(); &#x2F;&#x2F;关闭数据库连接，以释放资源。<br>} catch (Exception e1) {<br>}<br>}<br>}</li><li>Class.forName 的作用?为什么要用?<br>答：按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载<br>过，则返回代表该字节码的 Class 实例对象，否则，按类加载器的委托机制去搜索和加载该<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>类，如果所有的类加载器都无法加载到该类，则抛出 ClassNotFoundException。加载完这个<br>Class 字节码后，接着就可以使用 Class 字节码的 newInstance 方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时<br>才能确定，这时候就需要使用 Class.forName 去动态加载该类，这个类名通常是在配置文件<br>中配置的，例如，spring 的 ioc 中每次依赖注入的具体类就是这样配置的，jdbc 的驱动类名<br>通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类<br>名。</li><li>大数据量下的分页解决方法。<br>答：最好的办法是利用 sql 语句进行分页，这样每次查询出的结果集中就只包含某页的数据<br>内容。再 sql 语句无法实现分页的情况下，可以考虑对大的结果集通过游标定位方式来获取<br>某页的数据。<br>sql 语句分页，不同的数据库下的分页方案各不一样，下面是主流的三种数据库的分页 sql：<br>sql server:<br>String sql &#x3D; “select top “ + pageSize + “ * from students where id not in” +<br>“(select top “ + pageSize * (pageNumber-1) + “ id from students order by id)” +<br>“order by id”;<br>mysql:String sql &#x3D; “select * from students order by id limit “ + pageSize*(pageNumber-1) + “,” +<br>pageSize;<br>oracle:String sql &#x3D; “select * from “ + (select <em>,rownum rid from (select * from students order<br>by postime desc) where rid&lt;&#x3D;” + pagesize</em>pagenumber + “) as t” + “where t&gt;” +<br>pageSize*(pageNumber-1);</li><li>用 JDBC 查询学生成绩单, 把主要代码写出来（考试概率极大）. Connection cn &#x3D; null;<br>PreparedStatement pstmt &#x3D;null;<br>Resultset rs &#x3D; null;<br>try{<br>Class.forname(driveClassName);<br>cn &#x3D; DriverManager.getConnection(url,username,password);<br>pstmt &#x3D; cn.prepareStatement(“select score.* from score ,student “ +<br>“where score.stuId &#x3D; student.id and student.name &#x3D; ?”);<br>pstmt.setString(1,studentName);<br>Resultset rs &#x3D; pstmt.executeQuery();<br>while(rs.next()){<br>system.out.println(rs.getInt(“subject”) + “ ” + rs.getFloat(“score”) );<br>}<br>}catch(Exception e){e.printStackTrace();}<br>finally{<br>if(rs !&#x3D; null) try{ rs.close() }catch(exception e){}<br>if(pstmt !&#x3D; null) try{pstmt.close()}catch(exception e){}<br>if(cn !&#x3D; null) try{ cn.close() }catch(exception e){}<br>}</li><li>这段代码有什么不足之处?<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>try {<br>Connection conn &#x3D; …;<br>Statement stmt &#x3D; …;<br>ResultSet rs &#x3D; stmt.executeQuery(“select * from table1”);<br>while(rs.next()) {<br>}<br>} catch(Exception ex) {<br>}<br>答：没有 finally 语句来关闭各个对象，另外，使用 finally 之后，要把变量的定义放在 try 语<br>句块的外面，以便在 try 语句块之外的 finally 块中仍可以访问这些变量。</li><li>说出数据连接池的工作机制是什么?<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空<br>闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池<br>连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>实现方式，返回的 Connection 是原始 Connection 的代理，代理 Connection 的 close 方法不是<br>真正关连接，而是把它代理的 Connection 对象还回到连接池中。</li><li>为什么要用 ORM? 和 JDBC 有何不一样?<br>orm 是一种思想，就是把 object 转变成数据库中的记录，或者把数据库中的记录转变成<br>objecdt，我们可以用 jdbc 来实现这种思想，其实，如果我们的项目是严格按照 oop 方式编<br>写的话，我们的 jdbc 程序不管是有意还是无意，就已经在实现 orm 的工作了。<br>现在有许多 orm 工具，它们底层调用 jdbc 来实现了 orm 工作，我们直接使用这些工具，就<br>省去了直接使用 jdbc 的繁琐细节，提高了开发效率，现在用的较多的 orm 工具是 hibernate。<br>也听说一些其他 orm 工具，如 toplink,ojb 等。</li><li>121、在 ORACLE 大数据量下的分页解决方法。一般用截取 ID 方法，还有是三层嵌<br>套方法。<br>答:一种分页方法<br>&lt;%<br>int i&#x3D;1;<br>int numPages&#x3D;14;<br>String pages &#x3D; request.getParameter(“page”) ;<br>int currentPage &#x3D; 1;<br>currentPage &#x3D; (pages&#x3D;&#x3D;null)?(1):{Integer.parseInt(pages)}<br>sql &#x3D; “select count(<em>) from tables”;<br>ResultSet rs &#x3D; DBLink.executeQuery(sql) ;<br>while(rs.next()) i &#x3D; rs.getInt(1) ;<br>int intPageCount&#x3D;1;<br>intPageCount&#x3D;(i%numPages&#x3D;&#x3D;0)?(i&#x2F;numPages):(i&#x2F;numPages+1);<br>int nextPage ;<br>int upPage;<br>nextPage &#x3D; currentPage+1;<br>if (nextPage&gt;&#x3D;intPageCount) nextPage&#x3D;intPageCount;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>upPage &#x3D; currentPage-1;<br>if (upPage&lt;&#x3D;1) upPage&#x3D;1;<br>rs.close();<br>sql&#x3D;”select * from tables”;<br>rs&#x3D;DBLink.executeQuery(sql);<br>i&#x3D;0;<br>while((i&lt;numPages</em>(currentPage-1))&amp;&amp;rs.next()){i++;}<br>%&gt;<br>&#x2F;&#x2F;输出内容<br>&#x2F;&#x2F;输出翻页连接<br>合计:&lt;%&#x3D;currentPage%&gt;&#x2F;&lt;%&#x3D;intPageCount%&gt;页<br><a href>第一页</a><br><a href>上一页</a><br>&lt;%<br>for(int j&#x3D;1;j&lt;&#x3D;intPageCount;j++){<br>if(currentPage!&#x3D;j){<br>%&gt;<br><a href>[&lt;%&#x3D;j%&gt;]</a><br>&lt;%<br>}else{<br>out.println(j);<br>}<br>}<br>%&gt;<br><a href>下一页</a><br><a href>最后页</a></li><li>JDBC，Hibernate 分页怎样实现？<br>答：方法分别为：</li></ol><ol><li>Hibernate 的分页：<br>Query query &#x3D; session.createQuery(“from Student”);<br>query.setFirstResult(firstResult);&#x2F;&#x2F;设置每页开始的记录号<br>query.setMaxResults(resultNumber);&#x2F;&#x2F;设置每页显示的记录数<br>Collection students &#x3D; query.list();</li><li>JDBC 的分页：根据不同的数据库采用不同的 sql 分页语句<br>例 如 : Oracle 中 的 sql 语 句 为 : “SELECT * FROM (SELECT a.*, rownum r FROM<br>TB_STUDENT) WHERE r between 2 and 10” 查询从记录号 2 到记录号 10 之间的所有记录<br>七、 XML 部分</li></ol><ol start="200"><li>xml 有哪些解析技术?区别是什么?<br>答:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>种结构占用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML<br>的随机访问 SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文<br>件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结<br>束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理 XML 文件，适合<br>对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)</li><li>你在项目中用到了 xml 技术的哪些方面?如何实现的?<br>答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成<br>XML 文件，然后将 XML 文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩<br>后再同 XML 文件中还原相关信息进行处理。在做软件配置时，利用 XML 可以很方便的进<br>行，软件的各种配置参数都存贮在 XML 文件中。</li><li>谈谈你对 SSH 的理解<br>典型的 JavaEE 三层结构，分为表现层、中间层（业务逻辑层）和数据服务层。三层体系将<br>业务规则、数据访问及合法性校验等工作放在中间层处理。客户端不直接与数据库交互，而<br>是通过组件与中间层建立连接，再由中间层与数据库交互。<br>表现层是传统的 JSP 技术，自 1999 年问世以来，经过多年的发展，其广泛的应用和稳定的<br>表现，为其作为表现层技术打下了坚实的基础。<br>中间层采用的是流行的 Spring+Hibernate，为了将控制层与业务逻辑层分离，又细分为以下<br>几种。<br>Web 层，就是 MVC 模式里面的“C”（controller），负责控制业务逻辑层与表现层的交互，<br>调用业务逻辑层，并将业务数据返回给表现层作组织表现，该系统的 MVC 框架采用 Struts。<br>Service 层（就是业务逻辑层），负责实现业务逻辑。业务逻辑层以 DAO 层为基础，通过对<br>DAO 组件的正面模式包装，完成系统所要求的业务逻辑。<br>DAO 层，负责与持久化对象交互。该层封装了数据的增、删、查、改的操作。<br>PO，持久化对象。通过实体关系映射工具将关系型数据库的数据映射成对象，很方便地实<br>现以面向对象方式操作数据库，该系统采用 Hibernate 作为 ORM 框架。<br>Spring 的作用贯穿了整个中间层，将 Web 层、Service 层、DAO 层及 PO 无缝整合，其数据<br>服务层用来存放数据。</li><li>谈谈你对 Hibernate 的理解。</li><li>面向对象设计的软件内部运行过程可以理解成就是在不断创建各种新对象、建立对象之<br>间的关系，调用对象的方法来改变各个对象的状态和对象消亡的过程，不管程序运行的过程<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>和操作怎么样，本质上都是要得到一个结果，程序上一个时刻和下一个时刻的运行结果的差<br>异就表现在内存中的对象状态发生了变化。<br>2.为了在关机和内存空间不够的状况下，保持程序的运行状态，需要将内存中的对象状态保<br>存到持久化设备和从持久化设备中恢复出对象的状态，通常都是保存到关系数据库来保存大<br>量对象信息。从 Java 程序的运行功能上来讲，保存对象状态的功能相比系统运行的其他功<br>能来说，应该是一个很不起眼的附属功能，java 采用 jdbc 来实现这个功能，这个不起眼的<br>功能却要编写大量的代码，而做的事情仅仅是保存对象和恢复对象，并且那些大量的 jdbc<br>代码并没有什么技术含量，基本上是采用一套例行公事的标准代码模板来编写，是一种苦活<br>和重复性的工作。<br>3.通过数据库保存 java 程序运行时产生的对象和恢复对象，其实就是实现了 java 对象与关<br>系数据库记录的映射关系，称为 ORM（即 Object Relation Mapping），人们可以通过封装<br>JDBC 代码来实现了这种功能，封装出来的产品称之为 ORM 框架，Hibernate 就是其中的一<br>种流行 ORM 框架。使用 Hibernate 框架，不用写 JDBC 代码，仅仅是调用一个 save 方法，<br>就可以将对象保存到关系数据库中，仅仅是调用一个 get 方法，就可以从数据库中加载出一<br>个对象。<br>4.使用 Hibernate 的基本流程是：配置 Configuration 对象、产生 SessionFactory、创建 session<br>对象，启动事务，完成 CRUD 操作，提交事务，关闭 session。<br>5.使用 Hibernate 时，先要配置 hibernate.cfg.xml 文件，其中配置数据库连接信息和方言等，<br>还要为每个实体配置相应的 hbm.xml 文件，hibernate.cfg.xml 文件中需要登记每个 hbm.xml<br>文件。<br>6.在应用 Hibernate 时，重点要了解 Session 的缓存原理，级联，延迟加载和 hql 查询。</li><li>hibernate 中的 update()和 saveOrUpdate()的区别，session 的 load()和 get()的区别。</li><li>简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件. 216. Hibernate 的应用（Hibernate 的结构）？<br>答：&#x2F;&#x2F;首先获得 SessionFactory 的对象<br>SessionFactory sessionFactory &#x3D; new Configuration().configure().buildSessionFactory();<br>&#x2F;&#x2F;然后获得 session 的对象<br>Session session &#x3D; sessionFactory.openSession();<br>&#x2F;&#x2F;其次获得 Transaction 的对象<br>Transaction tx &#x3D; session.beginTransaction();<br>&#x2F;&#x2F;执行相关的数据库操作:增,删,改,查<br>session.save(user); &#x2F;&#x2F;增加, user 是 User 类的对象<br>session.delete(user); &#x2F;&#x2F;删除<br>session.update(user); &#x2F;&#x2F;更新<br>Query query &#x3D; session.createQuery(“from User”); &#x2F;&#x2F;查询<br>List list &#x3D; query.list();<br>&#x2F;&#x2F;提交事务<br>tx.commit();<br>&#x2F;&#x2F;如果有异常,我们还要作事务的回滚,恢复到操作之前<br>tx.rollback();<br>&#x2F;&#x2F;最后还要关闭 session,释放资源<br>session.close()</li><li>112、Hibernate 有哪 5 个核心接口？<br>答：Configuration 接口：配置 Hibernate，根据其启动 hibernate，创建 SessionFactory 对象；<br>SessionFactory 接口：初始化 Hibernate，充当数据存储源的代理，创建 session 对象，<br>sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量<br>级、二级缓存；<br>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个<br>线程共享同一个 session，是轻量级、一级缓存；<br>Transaction 接口：管理事务；<br>Query 和 Criteria 接口：执行数据库的查询。</li><li>iBatis 与 Hibernate 有什么不同?<br>相同点：屏蔽 jdbc api 的底层访问细节，使用我们不用与 jdbc api 打交道，就可以访问数据。<br>jdbc api 编程流程固定，还将 sql 语句与 java 代码混杂在了一起，经常需要拼凑 sql 语句，细<br>节很繁琐。<br>ibatis 的好处：屏蔽 jdbc api 的底层访问细节；将 sql 语句与 java 代码进行分离;提供了将结<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>果集自动封装称为实体对象和对象的集合的功能，queryForList 返回对象集合，用<br>queryForObject 返回单个对象；提供了自动将实体对象的属性传递给 sql 语句的参数。<br>Hibernate 是一个全自动的 orm 映射工具，它可以自动生成 sql 语句,ibatis 需要我们自己在 xml<br>配置文件中写 sql 语句，hibernate 要比 ibatis 功能负责和强大很多。因为 hibernate 自动生成<br>sql 语句，我们无法控制该语句，我们就无法去写特定的高效率的 sql。对于一些不太复杂的<br>sql 查询，hibernate 可以很好帮我们完成，但是，对于特别复杂的查询，hibernate 就很难适<br>应了，这时候用 ibatis 就是不错的选择，因为 ibatis 还是由我们自己写 sql 语句。</li><li>写 Hibernate 的一对多和多对一双向关联的 orm 配置?</li><li>什么是 ORM？<br>答：对象关系映射（Object—Relational Mapping，简称 ORM）是一种为了解决面向对象与<br>面向关系数据库存在的互不匹配的现象的技术；简单的说，ORM 是通过使用描述对象和数<br>据库之间映射的元数据，将 java 程序中的对象自动持久化到关系数据库中；本质上就是将<br>数据从一种形式转换到另外一种形式。</li><li>hibernate 的 inverse 属性的作用?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</li><li>在 DAO 中如何体现 DAO 设计模式?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</li><li>spring+Hibernate 中委托方案怎么配置?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</li><li>spring+Hibernate 中委托方案怎么配置?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</li><li>hibernate 进行多表查询每表中各取几个字段，就是说查询出的结果集没有一个实体<br>类与之对应如何解决<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</li><li>介绍一下 Hibernate 的二级缓存<br>按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了 hibernate 的 Session 就<br>是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置 Hibernate<br>的二级缓存。<br>（1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），<br>这个数据结构通常是类似于 Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个<br>对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在<br>缓存中，以便下次使用。下面是缓存的伪代码：<br>引出 hibernate 的第二级缓存，用下面的伪代码分析了 Cache 的实现原理<br>（2）Hibernate 的 Session 就是一种缓存，我们通常将之称为 Hibernate 的一级缓存，当想使<br>用 session 从数据库中查询出一个对象时，Session 也是先从自己内部查看是否存在这个对象，<br>存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于 Session<br>代表一次会话过程，一个 Session 与一个数据库连接相关连，所以 Session 最好不要长时间<br>保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且 Session 是线程不安全<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，<br>才有较大的缓存价值，因此，Hibernate 的 Session 这一级缓存的缓存作用并不明显，应用价<br>值不大。Hibernate 的二级缓存就是要为 Hibernate 配置一种全局缓存，让多个线程和多个事<br>务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session 没有这<br>种效果。<br>（3）二级缓存是独立于 Hibernate 的软件部件，属于第三方的产品，多个厂商和组织都提供<br>有缓存产品，例如，EHCache 和 OSCache 等等。在 Hibernate 中使用二级缓存，首先就要在<br>hibernate.cfg.xml 配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己<br>的配置文件，最后要配置 Hibernate 中的哪些实体对象要纳入到二级缓存的管理中。明白了<br>二级缓存原理和有了这个思路后，很容易配置起 Hibernate 的二级缓存。扩展知识：一个<br>SessionFactory 可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数<br>据，当使用 Hibernate 的二级缓存后，注意不要有其他的应用或 SessionFactory 来更改当前<br>数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。</li><li>解释 Spring 的依赖注入? 给一个 Bean 的 message 属性, 字符串类型, 注入值为<br>“Hello”的 XML 配置文件该怎么写?</li><li>Jdo 是什么?<br>JDO 是 Java 对象持久化的新的规范，为 java data object 的简称,也是一个用于存取某种数据<br>仓库中的对象的标准化 API。JDO 提供了透明的对象存储，因此对开发人员来说，存储数据<br>对象完全不需要额外的代码（如 JDBC API 的使用）。这些繁琐的例行工作已经转移到 JDO<br>产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO<br>很灵活，因为它可以在任何数据底层上运行。JDBC 只是面向关系数据库（RDBMS）JDO<br>更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML 以及对象数据库<br>（ODBMS）等等，使得应用可移植性更强。</li><li>spring 与 EJB 的区别！<br>九、软件工程与设计模式</li><li>UML 方面<br>标准建模语言 UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作<br>图),实现图。</li><li>BS 与 CS 的联系与区别。<br>C&#x2F;S 是 Client&#x2F;Server 的缩写。服务器通常采用高性能的 PC、工作站或小型机，并采用大型<br>数据库系统，如 Oracle、Sybase、InFORMix 或 SQL Server。客户端需要安装专用的客户端<br>软件。<br>B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator<br>或 Internet Explorer，服务器安装 Oracle、Sybase、InFORMix 或 SQL Server 等数据库。在这<br>种结构下，用户界面完全通过 WWW 浏览器实现，一部分事务逻辑在前端实现，但是主要<br>事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C&#x2F;S 与 B&#x2F;S 区别：<br>１．硬件环境不同:<br>C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提<br>供连接和数据交换服务. B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息<br>自己管理. 有比 C&#x2F;S 更强的适应范围, 一般只要有操作系统和浏览器就行<br>２．对安全要求不同<br>C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系<br>统采用 C&#x2F;S 结构适宜. 可以通过 B&#x2F;S 发布部分可公开信息. B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同<br>C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑. B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比 C&#x2F;S 有更<br>高的要求 B&#x2F;S 结构的程序架构是发展的趋势, 从 MS 的.Net 系列的 BizTalk 2000 Exchange<br>2000 等, 全面支持网络的构件搭建的系统. SUN 和 IBM 推的 JavaBean 构件技术等,使 B&#x2F;S<br>更加成熟. ４．软件重用不同<br>C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性<br>好. B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可<br>以再利用,而不是做在墙上的石头桌子<br>５．系统维护不同<br>C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是<br>再做一个全新的系统<br>B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户<br>从网上自己下载安装就可以实现升级. ６．处理问题不同<br>C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统<br>B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是 C&#x2F;S 无法作到的. 与操作系<br>统平台关系最小.<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>７．用户接口不同<br>C&#x2F;S 多是建立的 Window 平台上,表现方法有限,对程序员普遍要求较高<br>B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低, 减低开发成本. ８．信息流不同<br>C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低<br>B&#x2F;S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。</li><li>应用服务器与 WEB SERVER 的区别？</li><li>应用服务器有那些？<br>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，<br>Tomcat</li><li>J2EE 是什么？<br>答:Je22 是 Sun 公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的<br>企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为<br>不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客<br>户层(clietn tier)组件,web 层和组件,Business 层和组件,企业信息系统(EIS)层。<br>一个另类的回答：j2ee 就是增删改查。</li><li>J2EE 是技术还是平台还是框架？ 什么是 J2EE?<br>J2EE 本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br>J2EE 也是一个框架，包括 JDBC、JNDI、RMI、JMS、EJB、JTA 等技术。</li><li>请对以下在 J2EE 中常用的名词进行解释(或简单描述)<br>web 容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP,SERVLET<br>直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有 WEB 服务器来实现。<br>例如：TOMCAT,WEBLOGIC,WEBSPHERE 等。该容器提供的接口严格遵守 J2EE 规范中的<br>WEB APPLICATION 标准。我们把遵守以上标准的 WEB 服务器就叫做 J2EE 中的 WEB 容<br>器。<br>EJB 容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件 EJB<br>各种管理功能。只要满足 J2EE 规范的 EJB 放入该容器，马上就会被容器进行高效率的管理。<br>并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。<br>JNDI：（Java Naming &amp; Directory Interface）JAVA 命名目录服务。主要提供的功能是：提供<br>一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位<br>分布式应用程序的功能。<br>JMS：（Java Message Service）JAVA 消息服务。主要实现各个应用程序之间的通讯。包括<br>点对点和广播。<br>JTA：（Java Transaction API）JAVA 事务服务。提供各种分布式事务服务。应用程序只需调<br>用其提供的接口即可。<br>JAF：（Java Action FrameWork）JAVA 安全认证框架。提供一些安全控制方面的框架。让开<br>发者通过各种部署和自定义实现自己的个性安全控制策略。<br>RMI&#x2F;IIOP:（Remote Method Invocation &#x2F;internet 对象请求中介协议）他们主要用于通过远程<br>调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本<br>地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>信。RMI 是 JAVA 特有的。</li><li>如何给 weblogic 指定大小的内存?<br>（这个问题不作具体回答，列出来只是告诉读者可能会遇到什么问题，你不需要面面俱到，<br>什么都精通。）<br>在启动 Weblogic 的脚本中（位于所在 Domian 对应服务器目录下的 startServerName），增加<br>set MEM_ARGS&#x3D;-Xms32m -Xmx200m，可以调整最小内存为 32M，最大 200M</li><li>如何设定的 weblogic 的热启动模式(开发模式)与产品发布模式?<br>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启<br>动文件或者 commenv 文件，增加 set PRODUCTION_MODE&#x3D;true。</li><li>如何启动时不需输入用户名与密码?<br>修改服务启动文件，增加 WLS_USER 和 WLS_PW 项。也可以在 boot.properties 文件中增加<br>加密过的用户名和密码. 243. 在 weblogic 管理制台中对一个应用域(或者说是一个网站,Domain)进行 jms 及 ejb 或<br>连接池等相关信息进行配置后,实际保存在什么文件中?<br>保存在此 Domain 的 config.xml 文件中，它是服务器的核心配置文件。</li><li>说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的 helloWorld.jsp<br>放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp 就可以看<br>到运行结果了? 又比如这其中用到了一个自己写的 javaBean 该如何办?<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果<br>是 Web 应用，应用目录需要满足 Web 应用目录要求，jsp 文件可以直接放在应用目录中，<br>Javabean 需要放在应用目录的 WEB-INF 目录的 classes 目录中，设置服务器的缺省应用将可<br>以实现在浏览器上无需输入应用名。</li><li>在 weblogic 中发布 ejb 需涉及到哪些配置文件<br>不 同 类 型 的 EJB 涉 及 的 配 置 文 件 不 同 ， 都 涉 及 到 的 配 置 文 件 包 括<br>ejb-jar.xml,weblogic-ejb-jar.xmlCMP 实体 Bean 一般还需要 weblogic-cmp-rdbms-jar.xml</li><li>如何在 weblogic 中进行 ssl 配置与客户端的认证配置或说说 j2ee(标准)进行 ssl 的配<br>置?<br>缺省安装中使用 DemoIdentity.jks 和 DemoTrust.jks KeyStore 实现 SSL，需要配置服务器使<br>用 Enable SSL，配置其端口，在产品模式下需要从 CA 获取私有密钥和数字证书，创建 identity<br>和 trust keystore，装载获得的密钥和数字证书。可以配置此 SSL 连接是单向还是双向的。</li><li>如何查看在 weblogic 中已经发布的 EJB?<br>可以使用管理控制台，在它的 Deployment 中可以查看所有已发布的 EJB<br>十一、 ejb 部分</li><li>EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和<br>StatelessBean 区别。<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技术<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调<br>用其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对<br>象视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的<br>Session Bean 都可以将系统逻辑放在 method 之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean<br>的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就<br>是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗<br>J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状<br>态。</li><li>简要讲一下 EJB 的 7 个 Transaction Level?</li><li>EJB 与 JAVA BEAN 的区别？<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类<br>都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所<br>以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用<br>于实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，<br>它是不能被跨进程访问的。Enterprise Java Bean 相当于 DCOM，即分布式组件。它是基于<br>Java 的远程方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。<br>但 EJB 必须被布署在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正<br>的 EJB 组件，而是通过其容器访问。EJB 容器是 EJB 组件的代理，EJB 组件由容器所创建<br>和管理。客户通过容器来访问真正的 EJB 组件。</li><li>EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？<br>SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立<br>一个 Bean 的实例时，EJB 容器不一定要创建一个新的 Bean 的实例供客户机调用，而是随便<br>找一个现有的实例提供给客户机。当客户机第一次调用一个 Stateful Session Bean 时，容器<br>必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful<br>Session Bean 的方法时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不是按照应用程序或者服务进程来说的。即使 EJB 容器<br>崩溃了，Entity beans 也是存活的。Entity Beans 生命周期能够被容器或者 Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。</li><li>EJB 容器提供的服务<br>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</li><li>EJB 的激活机制<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>以Stateful Session Bean 为例：其 Cache大小决定了内存中可以同时存在的Bean实例的数量，<br>根据 MRU 或 NRU 算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某<br>个 EJB 实例业务方法时，如果对应 EJB Object 发现自己没有绑定对应的 Bean 实例则从其去<br>激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。</li><li>EJB 的几种类型<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean<br>会话 Bean 又可分为有状态（Stateful）和无状态（Stateless）两种<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种</li><li>客服端调用 EJB 对象的几个基本步骤<br>设置 JNDI 服务工厂以及 JNDI 服务地址系统属性，查找 Home 接口，从 Home 接口调用 Create<br>方法创建 Remote 接口，通过 Remote 接口调用其业务方法。 十二、 webservice 部分</li><li>名词解释：①WEB SERVICE ②JAXP ③JAXM ④SOAP ⑤UDDI ⑥WSDL。<br>JSWDL 开发包的介绍。<br>Web Service：Web Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 Web Service 能与其他兼容的组件进行互操作。<br>JAXP：(Java API for XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。<br>这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改<br>代码。<br>JAXM：(Java API for XML Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。<br>SOAP：即简单对象访问协议(Simple Object Access Protocol)，它是用于交换 XML 编码信息<br>的轻量级协议。<br>UDDI：的目的是为电子商务建立标准；UDDI 是一套基于 Web 的、分布式的、为 Web Service<br>提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的 Web Service<br>注册，以使别的企业能够发现的访问协议的实现标准。<br>WSDL：是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信<br>息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑<br>定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服<br>务）。</li><li>CORBA 是什么?用途是什么?<br>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象<br>管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为：用不同的程序<br>设计语言书写在不同的进程中运行，为不同的操作系统开发。 十三、 Linux</li><li>LINUX 下线程，GDI 类的解释。<br>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>轻量级进程，而线程之间的管理在核外函数库中实现。<br>GDI 类为图像设备编程接口类库。 十四、 问得稀里糊涂的题</li><li>简述逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别。<br>区别主要答两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以<br>操作数值型<br>b.逻辑操作不会产生短路<br>1，堆和栈的区别，有一个 64k 的字符串，是放到堆上，还是放到栈上，为什么？<br>2，什么时候用到接口，什么时候用到抽象类，二者区别<br>3，有一个 100 万的数组，里边有两个市重复的，如何设计算法找到。<br>4，设计数据库时，n 维，如何设计。<br>例如[省份][城市][网吧]，这是三维关系，它的表也应该有三个，网吧有外键引用城市，城市<br>有外键应用省份，这个规律就是下层的要有一外键去引用上层。</li><li>Java1.5 的新特性<br>一：Java 基础部分新特性：<br>自动拆箱<br>可变参数与 for each 循环<br>静态导入<br>二：IO 流部分：<br>printf 格式输出<br>Scanner<br>三：其他<br>泛型<br>枚举<br>Annotation<br>MyBatis 面试题<br>1、什么是 Mybatis？<br>1、Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时<br>只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建<br>statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性<br>能，灵活度高。<br>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数<br>据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过<br>java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最<br>后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返<br>回 result 的过程）。<br>2、Mybaits 的优点：<br>1、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任<br>何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML<br>标签，支持编写动态 SQL 语句，并可重用。<br>2、与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不<br>需要手动开关连接；<br>3、很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要<br>JDBC 支持的数据库 MyBatis 都支持）。<br>4、能够与 Spring 很好的集成；<br>5、提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射<br>标签，支持对象关系组件维护。<br>3、MyBatis 框架的缺点：<br>1、SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写<br>SQL 语句的功底有一定要求。<br>2、SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。<br>4、MyBatis 框架适用场合：<br>1、MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。<br>2、对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是<br>不错的选择。<br>5、MyBatis 与 Hibernate 有哪些不同？<br>1、Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要<br>程序员自己编写 Sql 语句。<br>2、Mybatis 直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高，非常<br>适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需<br>求变化要求迅速输出成果。但是灵活的前提是 mybatis 无法做到数据库无关性，<br>如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映射文件，工作量大。<br>3、Hibernate 对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的<br>软件，如果用 hibernate 开发可以节省很多代码，提高效率。<br>6、#{}和<code>$&#123;&#125;的区别是什么？ #&#123;&#125;是预编译处理，$</code>{}是字符串替换。<br>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的<br>set 方法来赋值；<br>Mybatis 在处理<code>$&#123;&#125;时，就是把$</code>{}替换成变量的值。<br>使用#{}可以有效的防止 SQL 注入，提高系统安全性。<br>7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？<br>第 1 种： 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类<br>的属性名一致。<br>&lt;select id&#x3D;”selectorder” parametertype&#x3D;”int” resultetype&#x3D;”<br>me.gacl.domain.order”&gt;<br>select order_id id, order_no orderno ,order_price price form<br>orders where order_id&#x3D;#{id};<br>&lt;&#x2F;select&gt;第 2 种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。 &lt;select id&#x3D;”getOrder” parameterType&#x3D;”int”<br>resultMap&#x3D;”orderresultmap”&gt;<br>select * from orders where order_id&#x3D;#{id} &lt;&#x2F;select&gt; &lt;resultMap type&#x3D;”me.gacl.domain.order” id&#x3D;”orderresultmap”&gt;<br>&lt;!–用 id 属性来映射主键字段–&gt; &lt;id property&#x3D;”id” column&#x3D;”order_id”&gt;<br>&lt;!–用 result 属性来映射非主键字段，property 为实体类属性名，column<br>为数据表中的属性–&gt; &lt;result property &#x3D; “orderno” column &#x3D;”order_no”&#x2F;&gt; &lt;result property&#x3D;”price” column&#x3D;”order_price” &#x2F;&gt; &lt;&#x2F;reslutMap&gt;<br>8、 模糊查询 like 语句该怎么写?<br>第 1 种：在 Java 代码中添加 sql 通配符。<br>string wildcardname &#x3D; “%smi%”;<br>list&lt;name&gt; names &#x3D; mapper.selectlike(wildcardname);<br>&lt;select id&#x3D;”selectlike”&gt;<br>select * from foo where bar like #{value} &lt;&#x2F;select&gt;<br>第 2 种：在 sql 语句中拼接通配符，会引起 sql 注入<br>string wildcardname &#x3D; “smi”;<br>list&lt;name&gt; names &#x3D; mapper.selectlike(wildcardname); &lt;select id&#x3D;”selectlike”&gt;<br>select * from foo where bar like “%”#{value}”%” &lt;&#x2F;select&gt;<br>9、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，<br>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，<br>参数不同时，方法能重载吗？<br>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；<br>接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的<br>参数，就是传递给 sql 的参数。<br>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符<br>串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个 &lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个<br>MapperStatement 对象。<br>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯<br>一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为<br>findStudentById 的 MapperStatement。<br>Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻<br>找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK<br>动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而<br>执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。<br>10、Mybatis 是如何进行分页的？分页插件的原理是什么？<br>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内<br>存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分<br>页功能，也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件<br>的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物<br>理分页语句和物理分页参数。<br>11、Mybatis是如何将sql执行结果封装为目标对象并返回的？<br>都有哪些映射形式？<br>第一种是使用&lt;resultMap&gt;标签，逐一定义数据库列名和对象属性名之间的映<br>射关系。<br>第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名。<br>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给<br>对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。<br>12、如何执行批量插入?<br>首先,创建一个简单的 insert 语句: &lt;insert id&#x3D;”insertname”&gt;<br>insert into names (name) values (#{value}) &lt;&#x2F;insert&gt;<br>然后在 java 代码中像下面这样执行批处理插入:<br>list &lt; string &gt; names &#x3D; new arraylist();<br>names.add(“fred”);<br>names.add(“barney”);<br>names.add(“betty”);<br>names.add(“wilma”);<br>&#x2F;&#x2F; 注意这里 executortype.batch<br>sqlsession sqlsession &#x3D;<br>sqlsessionfactory.opensession(executortype.batch);<br>try {<br>namemapper mapper &#x3D; sqlsession.getmapper(namemapper.class);<br>for (string name: names) {<br>mapper.insertname(name);<br>}<br>sqlsession.commit();<br>} catch (Exception e) {<br>e.printStackTrace();<br>sqlSession.rollback();<br>throw e;<br>}<br>finally {<br>sqlsession.close();<br>}<br>13、如何获取自动生成的(主)键值?<br>insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。<br>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入<br>的参数对象中。<br>示例：<br>&lt;insert id&#x3D;”insertname” usegeneratedkeys&#x3D;”true” keyproperty&#x3D;”<br>id”&gt;<br>insert into names (name) values (#{name}) &lt;&#x2F;insert&gt;<br>name name &#x3D; new name();<br>name.setname(“fred”);<br>int rows &#x3D; mapper.insertname(name);<br>&#x2F;&#x2F; 完成后,id 已经被设置到对象中<br>system.out.println(“rows inserted &#x3D; ” + rows);<br>system.out.println(“generated key value &#x3D; ” + name.getid());<br>14、在 mapper 中如何传递多个参数?<br>1、第一种：<br>DAO 层的函数<br>public UserselectUser(String name,String area);<br>对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第二<br>参数，更多参数一致往后加即可。<br>&lt;select id&#x3D;”selectUser”resultMap&#x3D;”BaseResultMap”&gt;<br>select * fromuser_user_t whereuser_name &#x3D; #{0}<br>anduser_area&#x3D;#{1} &lt;&#x2F;select&gt;<br>2、第二种： 使用 @param 注解:<br>public interface usermapper {<br>user selectuser(@param(“username”) string<br>username,@param(“hashedpassword”) string hashedpassword);<br>}<br>然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给<br>mapper): &lt;select id&#x3D;”selectuser” resulttype&#x3D;”user”&gt;<br>select id, username, hashedpassword<br>from some_table<br>where username &#x3D; #{username}<br>and hashedpassword &#x3D; #{hashedpassword} &lt;&#x2F;select&gt;<br>3、第三种：多个参数封装成 map<br>try {<br>&#x2F;&#x2F;映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的<br>SQL<br>&#x2F;&#x2F;由于我们的参数超过了两个，而方法中只有一个 Object 参数收集，因此<br>我们使用 Map 集合来装载我们的参数<br>Map &lt; String, Object &gt; map &#x3D; new HashMap();<br>map.put(“start”, start);<br>map.put(“end”, end);<br>return sqlSession.selectList(“StudentID.pagination”, map);<br>} catch (Exception e) {<br>e.printStackTrace();<br>sqlSession.rollback();<br>throw e;<br>} finally {<br>MybatisUtil.closeSqlSession();<br>}<br>15、Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？<br>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理<br>是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。<br>Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose<br>| when | otherwise | bind。<br>16、Xml 映射文件中，除了常见的 select|insert|updae|delete<br>标签之外，还有哪些标签？<br>答：&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、 &lt;selectKey&gt;，加上动态 sql 的 9 个标签，其中&lt;sql&gt;为 sql 片段标签，通过 &lt;include&gt;标签引入 sql 片段，&lt;selectKey&gt;为不支持自增的主键生成策略标<br>签。<br>17、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？<br>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配<br>置 namespace，那么 id 不能重复；<br>原因就是 namespace+id 是作为 Map&lt;String, MapperStatement&gt;的 key<br>使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。<br>有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然<br>也就不同。<br>18、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动<br>的区别在哪里？<br>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联<br>集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis<br>在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自<br>动 ORM 映射工具。<br>&lt;select id&#x3D;”getClass” parameterType&#x3D;”int”<br>resultMap&#x3D;”ClassesResultMap”&gt;<br>select * from class c,teacher t where c.teacher_id&#x3D;t.t_id and<br>c.c_id&#x3D;#{id} &lt;&#x2F;select&gt; &lt;resultMap type&#x3D;”com.lcb.user.Classes” id&#x3D;”ClassesResultMap”&gt;&lt;id property&#x3D;”id” column&#x3D;”c_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”c_name”&#x2F;&gt;<br>&lt;association property&#x3D;”teacher”<br>javaType&#x3D;”com.lcb.user.Teacher”&gt;<br>&lt;id property&#x3D;”id” column&#x3D;”t_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”t_name”&#x2F;&gt;<br>&lt;&#x2F;association&gt;<br>&lt;&#x2F;resultMap&gt;&lt;select id&#x3D;”getClass2” parameterType&#x3D;”int”<br>resultMap&#x3D;”ClassesResultMap2”&gt;<br>select * from class c,teacher t,student s where c.teacher_id&#x3D;t.t_id<br>and c.c_id&#x3D;s.class_id and c.c_id&#x3D;#{id}<br>&lt;&#x2F;select&gt;<br>&lt;resultMap type&#x3D;”com.lcb.user.Classes” id&#x3D;”ClassesResultMap2”&gt;<br>&lt;id property&#x3D;”id” column&#x3D;”c_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”c_name”&#x2F;&gt;<br>&lt;association property&#x3D;”teacher”<br>javaType&#x3D;”com.lcb.user.Teacher”&gt;<br>&lt;id property&#x3D;”id” column&#x3D;”t_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”t_name”&#x2F;&gt;<br>&lt;&#x2F;association&gt;<br>&lt;collection property&#x3D;”student”<br>ofType&#x3D;”com.lcb.user.Student”&gt;<br>&lt;id property&#x3D;”id” column&#x3D;”s_id”&#x2F;&gt;<br>&lt;result property&#x3D;”name” column&#x3D;”s_name”&#x2F;&gt;<br>&lt;&#x2F;collection&gt;<br>&lt;&#x2F;resultMap&gt;<br>&lt;&#x2F;mapper&gt;<br>20、MyBatis 实现一对一有几种方式?具体怎么操作的？<br>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在<br>resultMap 里面配置 association 节点配置一对一的类就可以完成；<br>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面<br>查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。<br>21、MyBatis 实现一对多有几种方式,怎么操作的？<br>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在<br>resultMap 里面的 collection 节点配置一对多的类就可以完成；嵌套查询是先查<br>一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过<br>配置 collection,但另外一个表的查询通过 select 节点配置。<br>22、Mybatis 是否支持延迟加载？如果支持，它的实现原理是<br>什么？<br>答：Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加<br>载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis<br>配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。<br>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦<br>截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是<br>null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，<br>然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()<br>方法的调用。这就是延迟加载的基本原理。<br>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都<br>是一样的。<br>23、Mybatis 的一级、二级缓存:<br>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为<br>Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就<br>将清空，默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap<br>存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，<br>如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要<br>实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br>&lt;cache&#x2F;&gt; ；<br>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存<br>Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将<br>被 clear。<br>24、什么是 MyBatis 的接口绑定？有哪些实现方式？<br>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑<br>定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可<br>以有更加灵活的选择和设置。<br>接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上<br>@Select、@Update 等注解，里面包含 Sql 语句来绑定；另外一种就是通过 xml<br>里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须<br>为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂<br>时候,用 xml 绑定,一般用 xml 绑定的比较多。<br>25、使用 MyBatis 的 mapper 接口调用时有哪些要求？<br>1、Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；<br>2、Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的<br>parameterType 的类型相同；<br>3、Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的<br>resultType 的类型相同；<br>4、Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。<br>26、Mapper 编写有哪几种方式？<br>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写<br>mapper 接口，mapper 接口实现类、mapper.xml 文件。<br>1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置<br>&lt;mappers&gt;<br>&lt;mapper resource&#x3D;”mapper.xml 文件的地址” &#x2F;&gt;<br>&lt;mapper resource&#x3D;”mapper.xml 文件的地址” &#x2F;&gt;<br>&lt;&#x2F;mappers&gt;<br>1、定义 mapper 接口<br>3、实现类集成 SqlSessionDaoSupport<br>mapper 方法中可以 this.getSqlSession()进行数据增删改查。<br>4、spring 配置<br>&lt;bean id&#x3D;” “ class&#x3D;”mapper 接口的实现”&gt;<br>&lt;property name&#x3D;”sqlSessionFactory”<br>ref&#x3D;”sqlSessionFactory”&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：<br>1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和<br>mappre 接口的名称相同且在同一个目录，这里可以不用配置<br>&lt;mappers&gt;<br>&lt;mapper resource&#x3D;”mapper.xml 文件的地址” &#x2F;&gt;<br>&lt;mapper resource&#x3D;”mapper.xml 文件的地址” &#x2F;&gt;<br>&lt;&#x2F;mappers&gt;<br>2、定义 mapper 接口：<br>1、mapper.xml 中的 namespace 为 mapper 接口的地址<br>2、mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一<br>致<br>3、Spring 中定义<br>&lt;bean id&#x3D;”” class&#x3D;”org.mybatis.spring.mapper.MapperFactoryBean”&gt;<br>&lt;property name&#x3D;”mapperInterface” value&#x3D;”mapper 接口地址” &#x2F;&gt;<br>&lt;property name&#x3D;”sqlSessionFactory” ref&#x3D;”sqlSessionFactory” &#x2F;&gt;<br>&lt;&#x2F;bean&gt;<br>第三种：使用 mapper 扫描器：<br>1、mapper.xml 文件编写：<br>mapper.xml 中的 namespace 为 mapper 接口的地址；<br>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；<br>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml<br>中进行配置。<br>2、定义 mapper 接口：<br>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录<br>3、配置 mapper 扫描器：<br>&lt;bean class&#x3D;”org.mybatis.spring.mapper.MapperScannerConfigurer”&gt;<br>&lt;property name&#x3D;”basePackage” value&#x3D;”mapper 接口包地址<br>“&gt;&lt;&#x2F;property&gt;<br>&lt;property name&#x3D;”sqlSessionFactoryBeanName”<br>value&#x3D;”sqlSessionFactory”&#x2F;&gt;<br>&lt;&#x2F;bean&gt;<br>4、使用扫描器后从 spring 容器中获取 mapper 的实现对象。<br>27、简述 Mybatis 的插件运行原理，以及如何编写一个插件。<br>答：Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、<br>StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代<br>理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种<br>接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()<br>方法，当然，只会拦截那些你指定需要拦截的方法。<br>编写插件：实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给<br>插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文<br>件中配置你编写的插件。<br>ZooKeeper 面试题1. ZooKeeper 面试题？<br>ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群<br>中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用<br>的接口和性能高效、功能稳定的系统提供给用户。<br>分布式应用程序可以基于 Zookeeper 实现诸如数据发布&#x2F;订阅、负载均衡、命名<br>服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。<br>Zookeeper 保证了如下分布式一致性特性：<br>1、顺序一致性<br>2、原子性<br>3、单一视图<br>4、可靠性<br>5、实时性（最终一致性）<br>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了<br>监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些<br>请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，<br>随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。<br>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个<br>更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。<br>而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个<br>zookeeper 最新的 zxid。</li><li>ZooKeeper 提供了什么？<br>1、文件系统<br>2、通知机制</li><li>Zookeeper 文件系统<br>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不<br>同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放<br>数据而目录节点不行。<br>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这<br>种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为<br>1M。</li><li>ZAB 协议？<br>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广<br>播协议。<br>ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。<br>当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导<br>致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进<br>入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务<br>器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader<br>服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始<br>接收客户端的事务请求生成事物提案来进行事务请求处理。</li><li>四种类型的数据节点 Znode<br>1、PERSISTENT-持久节点<br>除非手动删除，否则节点一直存在于 Zookeeper 上<br>2、EPHEMERAL-临时节点<br>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与<br>zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都<br>会被移除。<br>3、PERSISTENT_SEQUENTIAL-持久顺序节点<br>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维<br>护的自增整型数字。<br>4、EPHEMERAL_SEQUENTIAL-临时顺序节点<br>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的<br>自增整型数字。</li><li>Zookeeper Watcher 机制 – 数据变更通知<br>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务<br>端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通<br>知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出<br>业务上的改变。<br>工作机制：<br>1、客户端注册 watcher<br>2、服务端处理 watcher<br>3、客户端回调 watcher<br>Watcher 特性总结：<br>1、一次性<br>无论是服务端还是客户端，一旦一个 Watcher 被触发，Zookeeper 都会将其从相<br>应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频<br>繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的<br>压力都非常大。<br>2、客户端串行执行<br>客户端 Watcher 回调的过程是一个串行同步的过程。<br>3、轻量<br>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具<br>体内容。<br>3.2、客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对<br>象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。<br>4、watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步<br>的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于<br>网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身<br>提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode<br>发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。<br>Zookeeper 只能保证最终的一致性，而无法保证强一致性。<br>5、注册 watcher getData、exists、getChildren<br>6、触发 watcher create、delete、setData<br>7、当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。<br>当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接<br>时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全<br>透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode<br>的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上<br>之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</li><li>客户端注册 Watcher 实现<br>1、调用 getData()&#x2F;getChildren()&#x2F;exist()三个 API，传入 Watcher 对象<br>2、标记请求 request，封装 Watcher 到 WatchRegistration<br>3、封装成 Packet 对象，发服务端发送 request<br>4、收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理<br>5、请求返回，完成注册。</li><li>服务端处理 Watcher 实现<br>1、服务端接收 Watcher 并存储<br>接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点<br>的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现<br>了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在<br>WatcherManager 的 WatchTable 和 watch2Paths 中去。<br>2、Watcher 触发<br>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：<br>2.1 封装 WatchedEvent<br>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路<br>径封装成一个 WatchedEvent 对象<br>2.2 查询 Watcher<br>从 WatchTable 中根据节点路径查找 Watcher<br>2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher<br>2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里<br>可以看出 Watcher 在服务端是一次性的，触发一次就失效了）<br>3、调用 process 方法来触发 Watcher<br>这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。</li><li>客户端回调 Watcher<br>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。<br>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。</li><li>ACL 权限控制机制<br>UGO（User&#x2F;Group&#x2F;Others）<br>目前在 Linux&#x2F;Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗<br>粒度的文件系统权限控制模式。<br>ACL（Access Control List）访问控制列表<br>包括三个方面：<br>权限模式（Scheme）<br>1、IP：从 IP 地址粒度进行权限控制<br>2、Digest：最常用，用类似于 username:password 的权限标识来进行权限配<br>置，便于区分不同应用来进行权限控制<br>3、World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标<br>识“world:anyone”<br>4、Super：超级用户<br>授权对象<br>授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。<br>权限 Permission<br>1、CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点<br>2、DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点<br>3、READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内<br>容或子节点列表等<br>4、WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作<br>5、ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置<br>操作</li><li>Chroot 特性<br>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名<br>空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将<br>会被限制在其自己的命名空间下。<br>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对<br>应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相<br>互隔离非常有帮助。</li><li>会话管理<br>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进<br>行不同区块的隔离处理以及同一区块的统一处理。<br>分配原则：每个会话的“下次超时时间点”（ExpirationTime）<br>计算公式：<br>ExpirationTime_ &#x3D; currentTime + sessionTimeout<br>ExpirationTime &#x3D; (ExpirationTime_ &#x2F; ExpirationInrerval + 1) *<br>ExpirationInterval , ExpirationInterval 是指 Zookeeper 会话超时检查时间<br>间隔，默认 tickTime</li><li>服务器角色<br>Leader<br>1、事务请求的唯一调度和处理者，保证集群事务处理的顺序性<br>2、集群内部各服务的调度者<br>Follower<br>1、处理客户端的非事务请求，转发事务请求给 Leader 服务器<br>2、参与事务请求 Proposal 的投票<br>3、参与 Leader 选举投票<br>Observer<br>1、3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提<br>升集群的非事务处理能力<br>2、处理客户端的非事务请求，转发事务请求给 Leader 服务器<br>3、不参与任何形式的投票</li><li>Zookeeper 下 Server 工作状态<br>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。<br>1、LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中<br>没有 Leader，因此需要进入 Leader 选举状态。<br>2、FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。<br>3、LEADING：领导者状态。表明当前服务器角色是 Leader。<br>4、OBSERVING：观察者状态。表明当前服务器角色是 Observer。</li><li>数据同步<br>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）回向<br>Leader 服务器进行注册。当 Learner 服务器想 Leader 服务器完成注册后，进入<br>数据同步环节。<br>数据同步流程：（均以消息传递的方式进行）<br>Learner 向 Learder 注册<br>数据同步<br>同步确认<br>Zookeeper 的数据同步通常分为四类：<br>1、直接差异化同步（DIFF 同步）<br>2、先回滚再差异化同步（TRUNC+DIFF 同步）<br>3、仅回滚同步（TRUNC 同步）<br>4、全量同步（SNAP 同步）<br>在进行数据同步前，Leader 服务器会完成数据同步初始化：<br>peerLastZxid：<br> 从 learner 服务器注册时发送的 ACKEPOCH 消息中提取 lastZxid（该<br>Learner 服务器最后处理的 ZXID）<br>minCommittedLog：<br> Leader 服务器 Proposal 缓存队列 committedLog 中最小 ZXID<br>maxCommittedLog：<br> Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID<br>直接差异化同步（DIFF 同步）<br> 场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog<br>之间<br>先回滚再差异化同步（TRUNC+DIFF 同步）<br> 场景：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没<br>有的事务记录，那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader<br>服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID<br>仅回滚同步（TRUNC 同步）<br> 场景：peerLastZxid 大于 maxCommittedLog<br>全量同步（SNAP 同步）<br> 场景一：peerLastZxid 小于 minCommittedLog<br> 场景二：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等<br>于 lastProcessZxid</li><li>zookeeper 是如何保证事务的顺序一致性的？<br>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被<br>提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时<br>期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch<br>会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两<br>阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能<br>执行并且能够成功，那么就会开始执行。</li><li>分布式集群中为什么会有 Master？<br>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机<br>器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行<br>leader 选举。</li><li>zk 节点宕机如何处理？<br>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保<br>证当一个节点宕机时，其他节点会继续提供服务。<br>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数<br>据是有多个副本的，数据并不会丢失；<br>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。<br>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK<br>节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。<br>所以<br>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)<br>2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;&#x3D;1)</li><li>zookeeper 负载均衡和 nginx 负载均衡区别<br>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写<br>插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。</li><li>Zookeeper 有哪几种几种部署模式？<br>部署模式：单机模式、伪集群模式、集群模式。</li><li>集群最少要几台机器，集群规则是怎样的?<br>集群规则为 2N+1 台，N&gt;0，即 3 台。</li><li>集群支持动态添加机器吗？<br>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：<br>全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的<br>会话。<br>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供<br>服务。这是比较常用的方式。<br>3.5 版本开始支持动态扩容。</li><li>Zookeeper 对节点的 watch监听通知是永久的吗？为什么<br>不是永久的?<br>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch<br>的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，<br>以便通知它们。<br>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况<br>下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。<br>一般是客户端执行 getData(“&#x2F;节点 A”,true)，如果节点 A 发生了变更或删除，<br>客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没<br>有设置 watch 事件，就不再给客户端发送。<br>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我<br>只要最新的数据即可。</li><li>Zookeeper 的 java 客户端都有哪些？<br>java 客户端：zk 自带的 zkclient 及 Apache 开源的 Curator。</li><li>chubby 是什么，和 zookeeper 比你怎么看？<br>chubby 是 google 的，完全实现 paxos 算法，不开源。zookeeper 是 chubby<br>的开源实现，使用 zab 协议，paxos 算法的变种。</li><li>说几个 zookeeper 常用的命令。<br>常用命令：ls get set create delete 等。</li><li>ZAB 和 Paxos 算法的联系与区别？<br>相同点：<br>1、两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程<br>的运行<br>2、Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提<br>案进行提交<br>3、ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader<br>周期，Paxos 中名字为 Ballot<br>不同点：<br>ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建<br>分布式一致性状态机系统。</li><li>Zookeeper 的典型应用场景<br>Zookeeper 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员<br>可以使用它来进行分布式数据的发布和订阅。<br>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机<br>制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：<br>1、数据发布&#x2F;订阅<br>2、负载均衡<br>3、命名服务<br>4、分布式协调&#x2F;通知<br>5、集群管理<br>6、Master 选举<br>7、分布式锁<br>8、分布式队列</li><li>数据发布&#x2F;订阅<br>介绍<br>数据发布&#x2F;订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者<br>进行数据订阅。<br>目的<br>动态获取数据（配置信息）<br>实现数据（配置信息）的集中式管理和数据的动态更新<br>设计模式<br>Push 模式<br>Pull 模式<br>数据（配置信息）特性<br>1、数据量通常比较小<br>2、数据内容在运行时会发生动态更新<br>3、集群中各机器共享，配置一致<br>如：机器列表信息、运行时开关配置、数据库配置信息等<br>基于 Zookeeper 的实现方式<br> 数据存储：将数据（配置信息）存储到 Zookeeper 上的一个数据节点<br> 数据获取：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并<br>在该节点上注册一个数据变更 Watcher<br> 数据变更：当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper<br>会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即<br>可。</li><li>负载均衡<br>zk 的命名服务<br>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局<br>的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，<br>或者一个远程的对象等等。<br>分布式通知和协调<br>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，<br>然后 zk 将这些变化发送给注册了这个节点的 watcher 的所有客户端。<br>对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工<br>作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时<br>的全局情况。<br>zk 的命名服务（文件系统）<br>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局<br>的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，<br>提供的服务的地址，或者一个远程的对象等等。<br>zk 的配置管理（文件系统、通知机制）<br>程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有<br>配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的<br>内容，利用 watcher 通知给各个客户端，从而更改配置。<br>Zookeeper 集群管理（文件系统、通知机制）<br>所谓集群管理无在乎两点：是否有机器退出和加入、选举 master。<br>对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点<br>的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper 的连接断开，其所创<br>建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于<br>是，所有人都知道：它上船了。<br>新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount 又有了，<br>对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选<br>取编号最小的机器作为 master 就好。<br>Zookeeper 分布式锁（文件系统、通知机制）<br>有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，<br>一个是保持独占，另一个是控制时序。<br>对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode<br>的方式来实现。所有客户端都去创建 &#x2F;distribute_lock 节点，最终成功创建的那<br>个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放<br>出锁。<br>对于第二类， &#x2F;distribute_lock 已经预先存在，所有客户端在它下面创建临时顺<br>序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便。<br>Zookeeper 队列管理（文件系统、通知机制）<br>两种类型的队列：<br>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有<br>成员到达。<br>2、队列按照 FIFO 方式进行入队和出队操作。<br>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。<br>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按<br>编号。在特定的目录下创建 PERSISTENT_SEQUENTIAL 节点，创建成功时<br>Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下<br>Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内<br>容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持<br>久化的，所以不必担心队列消息的丢失问题。</li></ol><p>7、服务提供者能实现失效踢出是什么原理？<br>服务失效踢出基于 zookeeper 的临时节点原理。<br>8、服务上线怎么不影响旧版本？<br>采用多版本开发，不影响旧版本。<br>9、如何解决服务调用链过长的问题？<br>可以结合 zipkin 实现分布式服务追踪。</p><p>12、同一个服务多个注册的情况下可以直连某一个服务吗？<br>可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。<br>13、画一画服务注册与发现的流程图？<br>14、Dubbo 集群容错有几种方案？<br>集群容错方案 说明<br>Failover Cluster 失败自动切换，自动重试其它服务器（默认）<br>Failfast Cluster 快速失败，立即报错，只发起一次调用<br>Failsafe Cluster 失败安全，出现异常时，直接忽略<br>Failback Cluster 失败自动恢复，记录失败请求，定时重发<br>Forking Cluster 并行调用多个服务器，只要一个成功即返回<br>Broadcast Cluster 广播逐个调用所有提供者，任意一个报错则报错<br>15、Dubbo 服务降级，失败重试怎么做？<br>可以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修<br>改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口<br>名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑<br>16、Dubbo 使用过程中都遇到了些什么问题？<br>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解<br>无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确<br>17、Dubbo Monitor 实现原理？<br>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是<br>先走 filter 链，然后才进行真正的业务逻辑处理。<br>默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。<br>1、MonitorFilter 向 DubboMonitor 发送数据<br>2、DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到<br>ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个<br>含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，<br>调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕<br>一个，就重置当前的 Statistics 的 AtomicReference<br>3、SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队<br>列大写为 100000）<br>4、SimpleMonitorService 使用一个后台线程（线程名为：<br>DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以<br>死循环的形式来写）<br>5、SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：<br>DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</p><p>19、Dubbo 配置文件是如何加载到 Spring 中的？<br>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自<br>定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，<br>NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为<br>需要加载的 bean 对象！<br>20、Dubbo SPI 和 Java SPI 区别？<br>JDK SPI<br>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展吃实话很耗时，但<br>也没用上，很浪费资源。<br>所以只希望加载某个的实现，就不现实了<br>DUBBO SPI<br>1，对 Dubbo 进行扩展，不需要改动 Dubbo 的源码<br>2，延迟加载，可以一次只加载自己想要加载的扩展实现。<br>3，增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其<br>它扩展点。<br>3，Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。<br>21、Dubbo 支持分布式事务吗？<br>目前暂时不支持，可与通过 tcc-transaction 框架实现<br>介绍：tcc-transaction 是开源的 TCC 补偿性分布式事务框架<br>Git 地址：<br>TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。<br>22、Dubbo 可以对结果进行缓存吗？<br>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作<br>量<br>&lt;dubbo:reference cache&#x3D;”true” &#x2F;&gt;<br>其实比普通的配置文件就多了一个标签 cache&#x3D;”true”<br>23、服务上线怎么兼容旧版本？<br>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不<br>同的服务相互间不引用。这个和服务分组的概念有一点类似。<br>24、Dubbo 必须依赖的包有哪些？<br>Dubbo 必须依赖 JDK，其他为可选。<br>25、Dubbo telnet 命令能做什么？<br>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。<br>Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令<br>连接服务<br>telnet localhost 20880 &#x2F;&#x2F;键入回车进入 Dubbo 命令模式。<br>查看服务列表<br>dubbo&gt;ls<br>com.test.TestService<br>dubbo&gt;ls com.test.TestService<br>create<br>delete<br>query<br> ls (list services and methods)<br> ls : 显示服务列表。<br> ls -l : 显示服务详细信息列表。<br> ls XxxService：显示服务的方法列表。<br> ls -l XxxService：显示服务的方法详细信息列表。<br>26、Dubbo 支持服务降级吗？<br>以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修改<br>为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名<br>称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑<br>27、Dubbo 如何优雅停机？<br>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用<br>kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才<br>会执行。<br>28、Dubbo 和 Dubbox 之间的区别？<br>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如<br>加了服务可 Restful 调用，更新了开源组件等。</p><p>30、你还了解别的分布式框架吗？<br>别的还有 spring 的 spring cloud，facebook 的 thrift，twitter 的 finagle 等</p><p>仅索引层面调优手段：<br>1.1、设计阶段调优<br>1、根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索<br>引；<br>2、使用别名进行索引管理；<br>3、每天凌晨定时对索引做 force_merge 操作，以释放空间；<br>4、采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink<br>操作，以缩减存储；<br>5、采取 curator 进行索引的生命周期管理；<br>6、仅针对需要分词的字段，合理的设置分词器；<br>7、Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。……..<br>1.2、写入调优<br>1、写入前副本数设置为 0；<br>2、写入前关闭 refresh_interval 设置为-1，禁用刷新机制；<br>3、写入过程中：采取 bulk 批量写入；<br>4、写入后恢复副本数和刷新间隔；<br>5、尽量使用自动生成的 id。<br>1.3、查询调优<br>1、禁用 wildcard；<br>2、禁用批量 terms（成百上千的场景）；<br>3、充分利用倒排索引机制，能 keyword 类型尽量 keyword；<br>4、数据量大时候，可以先基于时间敲定索引再检索；<br>5、设置合理的路由机制。<br>1.4、其他调优<br>部署调优，业务调优等。<br>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。<br>2、elasticsearch 的倒排索引是什么<br>面试官：想了解你对基础概念的认知。<br>解答：通俗解释一下就可以。<br>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。<br>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表<br>即为倒排索引。<br>有了倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了<br>检索效率。<br>学术的解答方式：<br>倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文<br>档中出现过，由两部分组成——词典和倒排表。<br>加分项：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结<br>构。<br>lucene 从 4+版本后开始大量使用的数据结构是 FST。FST 有两个优点：<br>1、空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；<br>2、查询速度快。O(len(str))的查询时间复杂度。<br>3、elasticsearch 索引数据多了怎么办，如何调优，部署<br>面试官：想了解大数据量的运维能力。<br>解答：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，<br>这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户<br>检索或者其他业务受到影响。<br>如何调优，正如问题 1 所说，这里细化一下：<br>3.1 动态索引层面<br>基于模板+时间+rollover api 滚动创建索引，举例：设计阶段定义：blog 索<br>引的模板格式为：blog_index_时间戳的形式，每天递增数据。<br>这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线 2 的<br>32 次幂-1，索引存储达到了 TB+甚至更大。<br>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。<br>3.2 存储层面<br>冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。<br>对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，<br>节省存储空间和检索效率。<br>3.3 部署层面<br>一旦之前没有规划，这里就属于应急策略。<br>结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注<br>意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。<br>4、elasticsearch 是如何实现 master 选举的<br>面试官：想了解 ES 集群的底层原理，不再只关注业务层面了。<br>解答：<br>前置前提：<br>1、只有候选主节点（master：true）的节点才能成为主节点。<br>2、最小主节点数（min_master_nodes）的目的是防止脑裂。<br>这个我看了各种网上分析的版本和源码分析的书籍，云里雾里。<br>核对了一下代码，核心入口为 findMaster，选择主节点成功返回对应 Master，否<br>则返回 null。选举流程大致描述如下：<br>第一步：确认候选主节点数达标，elasticsearch.yml 设置的值<br>discovery.zen.minimum_master_nodes；<br>第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；<br>若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。<br>题外话：获取节点 id 的方法。<br>1GET &#x2F;_cat&#x2F;nodes?v&amp;h&#x3D;ip,port,heapPercent,heapMax,id,name<br>2ip port heapPercent heapMax id name<br>5、详细描述一下 Elasticsearch 索引文档的过程<br>面试官：想了解 ES 的底层原理，不再只关注业务层面了。<br>解答：<br>这里的索引文档应该理解为文档写入 ES，创建索引的过程。<br>文档写入包含：单文档写入和批量 bulk 写入，这里只解释一下：单文档写入流程。<br>记住官方文档中的这个图。<br>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由&#x2F;协调节点，<br>请求的节点扮演路由节点的角色。）<br>第二步：节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转<br>到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。<br>第三步：节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1<br>和节点 2 的副本分片上，等待结果返回。所有的副本分片都报告成功，节点 3 将<br>向协调节点（节点 1）报告成功，节点 1 向请求客户端报告写入成功。<br>如果面试官再问：第二步中的文档获取分片的过程？<br>回答：借助路由算法获取，路由算法就是根据路由和文档 id 计算目标的分片 id 的<br>过程。<br>1shard &#x3D; hash(*routing) % (num_of_primary_shards)<br>6、详细描述一下 Elasticsearch 搜索的过程？<br>面试官：想了解 ES 搜索的底层原理，不再只关注业务层面了。<br>解答：<br>搜索拆解为“query then fetch” 两个阶段。<br>query 阶段的目的：定位到位置，但不取。<br>步骤拆解如下：<br>1、假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本<br>分片中）的一个。<br>2、每个分片在本地进行查询，结果返回到本地有序的优先队列中。<br>3、第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。<br>fetch 阶段的目的：取数据。<br>路由节点获取所有文档，返回给客户端。<br>7、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法<br>面试官：想了解对 ES 集群的运维能力。<br>解答：<br>1、关闭缓存 swap;<br>2、堆内存设置为：Min（节点内存&#x2F;2, 32GB）;<br>3、设置最大文件句柄数；<br>4、线程池+队列大小根据业务需要做调整；<br>5、磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单<br>节点存储故障。</p><p>9、Elasticsearch 是如何实现 Master 选举的？<br>1、Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之<br>间通过这个 RPC 来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪<br>些节点需要 ping 通）这两部分；<br>2、对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排<br>序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第 0 位）<br>节点，暂且认为它是 master 节点。<br>3、如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n&#x2F;2+1）并<br>且该节点自己也选举自己，那这个节点就是 master。否则重新选举一直到满足上<br>述条件。<br>4、补充：master 节点的职责主要包括集群、节点和索引的管理，不负责文档级<br>别的管理；data 节点可以关闭 http 功能*。<br>10、Elasticsearch 中的节点（比如共 20 个），其中的 10 个<br>选了一个 master，另外 10 个选了另一个 master，怎么办？<br>1、当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量<br>（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解<br>决脑裂问题；<br>2、当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data<br>节点，避免脑裂问题。<br>11、客户端在和集群连接时，如何选择特定的节点执行请求的？<br>1、TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并<br>不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮<br>询 的方式与这些地址进行通信。<br>12、详细描述一下 Elasticsearch 索引文档的过程。<br>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合<br>适的分片。<br>shard &#x3D; hash(document_id) % (num_of_primary_shards)<br>1、当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory<br>Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Momery<br>Buffer 到 Filesystem Cache 的过程就叫做 refresh；<br>2、当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会<br>丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请<br>求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中<br>时，才会清除掉，这个过程叫做 flush；<br>3、在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync<br>将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一<br>个新的 translog。<br>4、flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认<br>为 512M）时；<br>补充：关于 Lucene 的 Segement：<br>1、Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。<br>2、段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重<br>建索引。<br>3、对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗<br>CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。<br>4、为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并<br>段到磁盘，并删除那些旧的小段。<br>13、详细描述一下 Elasticsearch 更新和删除文档的过程。<br>1、删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不<br>能被删除或者改动以展示其变更；<br>2、磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真<br>的被删除，而是在.del 文件中被标记为删除。该文档依然能匹配查询，但是会在<br>结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入<br>新段。<br>3、在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新<br>时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。<br>旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。<br>14、详细描述一下 Elasticsearch 搜索的过程。<br>1、搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；<br>2、在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分<br>片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的<br>优先队列。<br>PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory<br>Buffer，所以搜索是近实时的。<br>3、每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并<br>这些值到自己的优先队列中来产生一个全局排序后的结果列表。<br>4、接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片<br>提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回<br>文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。<br>5、补充：Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分<br>片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增<br>加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，<br>但是性能会变差。*<br>15、在 Elasticsearch 中，是怎么根据一个词找到对应的倒排索<br>引的？<br>SEE：<br> Lucene 的索引文件格式(1)<br> Lucene 的索引文件格式(2)<br>16、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方<br>法？<br>1、64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。<br>少于 8 GB 会适得其反。<br>2、如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多<br>个内核提供的额外并发远胜过稍微快一点点的时钟频率。<br>3、如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查<br>询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。<br>4、即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群<br>跨越大的地理距离。<br>5、请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在<br>Elasticsearch 的几个地方，使用 Java 的本地序列化。<br>6、通过设置 gateway.recover_after_nodes、gateway.expected_nodes、<br>gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可<br>能会让数据恢复从数个小时缩短为几秒钟。<br>7、Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只<br>有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。<br>8、不要随意修改垃圾回收器（CMS）和各个线程池的大小。<br>9、把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过<br>ES_HEAP_SIZE 环境变量设置。<br>10、内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个<br>100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起<br>来。 不难看出 swapping 对于性能是多么可怕。<br>11、Lucene 使用了大量 的文件。同时，Elasticsearch 在节点和 HTTP 客户端<br>之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你<br>应该增加你的文件描述符，设置一个很大的值，如 64,000。<br>补充：索引阶段性能提升方法<br>1、使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。<br>2、存储：使用 SSD<br>3、段和合并：Elasticsearch 默认值是 20 MB&#x2F;s，对机械磁盘应该是个不错的设<br>置。如果你用的是 SSD，可以考虑提高到 100–200 MB&#x2F;s。如果你在做批量导入，<br>完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加<br>index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的<br>值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。<br>4、如果你的搜索结果不需要近实时的准确度，考虑把每个索引的<br>index.refresh_interval 改到 30s。<br>5、如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副<br>本。<br>17、对于 GC 方面，在使用 Elasticsearch 时要注意什么？<br>1、SEE：<br>2、倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment<br>memory 增长趋势。<br>3、各类缓存，field cache, filter cache, indexing cache, bulk queue 等等，要<br>设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓<br>存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache<br>等“自欺欺人”的方式来释放内存。<br>4、避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用<br>scan &amp; scroll api 来实现。<br>5、cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集<br>群通过 tribe node 连接。<br>6、想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做<br>持续的监控。<br>18、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？<br>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，<br>即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对<br>我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到<br>基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；<br>小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内<br>存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。<br>19、在并发情况下，Elasticsearch 如果保证读写一致？<br>1、可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用<br>层来处理具体的冲突；<br>2、另外对于写操作，一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum，即只<br>有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络<br>等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点<br>上重建。<br>3、对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副<br>本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜<br>索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。<br>20、如何监控 Elasticsearch 集群状态？<br>Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你<br>的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。<br>21、介绍下你们电商搜索的整体技术架构。<br>22、介绍一下你们的个性化搜索方案？<br>SEE 基于 word2vec 和 Elasticsearch 实现个性化搜索<br>23、是否了解字典树？<br>常用字典数据结构如下所示：<br>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以<br>达到提高效率的目的。它有 3 个基本性质：<br>1、根节点不包含字符，除根节点外每一个节点都只包含一个字符。<br>2、从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>3、每个节点的所有子节点包含的字符都不相同。<br>1、可以看到，trie 树每一层的节点数是 26^i 级别的。所以为了节省空间，我们<br>还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数×单<br>词长度。<br>2、实现：对每个结点开一个字母集大小的数组，每个结点挂一个链表，使用左儿<br>子右兄弟表示法记录这棵树；<br>3、对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太<br>大的空间，而且查询速度上可以保留哈希的复杂度 O(1)。<br>24、拼写纠错是如何实现的？<br>1、拼写纠错是基于编辑距离来实现；编辑距离是一种标准的方法，它用来表示经<br>过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数；<br>2、编辑距离的计算过程：比如要计算 batyu 和 beauty 的编辑距离，先创建一个<br>7×8 的表（batyu 长度为 5，coffee 长度为 6，各加 2），接着，在如下位置填入<br>黑色数字。其他格的计算过程是取以下三个值的最小值：<br>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字<br>+1。（对于 3,3 来说为 0）<br>左方数字+1（对于 3,3 格来说为 2）<br>上方数字+1（对于 3,3 格来说为 2）<br>最终取右下角的值即为编辑距离的值 3。<br>对于拼写纠错，我们考虑构造一个度量空间（Metric Space），该空间内任何关<br>系满足以下三条基本条件：<br>d(x,y) &#x3D; 0 – 假如 x 与 y 的距离为 0，则 x&#x3D;y<br>d(x,y) &#x3D; d(y,x) – x 到 y 的距离等同于 y 到 x 的距离<br>d(x,y) + d(y,z) &gt;&#x3D; d(x,z) – 三角不等式<br>1、根据三角不等式，则满足与 query 距离在 n 范围内的另一个字符转 B，其与 A<br>的距离最大为 d+n，最小为 d-n。<br>2、BK 树的构造就过程如下：每个节点有任意个子节点，每条边有个值表示编辑<br>距离。所有子节点到父节点的边上标注 n 表示编辑距离恰好为 n。比如，我们有棵<br>树父节点是”book”和两个子节点”cake”和”books”，”book”到”books”<br>的边标号 1，”book”到”cake”的边上标号 4。从字典里构造好树后，无论何<br>时你想插入新单词时，计算该单词与根节点的编辑距离，并且查找数值为<br>d(neweord, root)的边。递归得与各子节点进行比较，直到没有子节点，你就可<br>以创建新的子节点并将新单词保存在那。比如，插入”boo”到刚才上述例子的树<br>中，我们先检查根节点，查找 d(“book”, “boo”) &#x3D; 1 的边，然后检查标号为<br>1 的边的子节点，得到单词”books”。我们再计算距离 d(“books”, “boo”)&#x3D;2，<br>则将新单词插在”books”之后，边标号为 2。<br>3、查询相似词如下：计算单词与根节点的编辑距离 d，然后递归查找每个子节点<br>标号为 d-n 到 d+n（包含）的边。假如被检查的节点与搜索单词的距离 d 小于 n，<br>则返回该节点并继续查询。比如输入 cape 且最大容忍距离为 1，则先计算和根的<br>编辑距离 d(“book”, “cape”)&#x3D;4，然后接着找和根节点之间编辑距离为 3 到<br>5 的，这个就找到了 cake 这个节点，计算 d(“cake”, “cape”)&#x3D;1，满足条件<br>所以返回 cake，然后再找和 cake 节点编辑距离是 0 到 2 的，分别找到 cape 和<br>cart 节点，这样就得到 cape 这个满足条件的结果。</p><p>2、Memcached 服务分布式集群如何实现？<br>特殊说明：Memcached 集群和 web 服务集群是不一样的，所有 Memcached 的<br>数据总和才是数据库的数据。每台 Memcached 都是部分数据。<br>（一台 memcached 的数据，就是一部分 mysql 数据库的数据）<br>a、程序端实现<br>程序加载所有 mc 的 ip 列表，通过对 key 做 hash (一致性哈希算法)<br>例如：web1 (key)&#x3D;&#x3D;&#x3D;&gt;对应 A,B,C,D,E,F,G…..若干台服务器。（通过哈希算法实<br>现）<br>b、负载均衡器<br>通过对 key 做 hash (一致性哈希算法)<br>一致哈希算法的目的是不但保证每个对象只请求一个对应的服务器，而且当节点<br>宕机，缓存服务器的更新重新分配比例降到最低。<br>3、Memcached 服务特点及工作原理是什么？<br>a、完全基于内存缓存的<br>b、节点之间相互独立<br>c、C&#x2F;S 模式架构，C 语言编写，总共 2000 行代码。<br>d、异步Ｉ&#x2F;O 模型，使用 libevent 作为事件通知机制。<br>e、被缓存的数据以 key&#x2F;value 键值对形式存在的。<br>f、全部数据存放于内存中，无持久性存储的设计，重启服务器，内存里的数据会<br>丢失。<br>g、当内存中缓存的数据容量达到启动时设定的内存值时，就自动使用 LRU 算法<br>删除过期的缓存数据。<br>h、可以对存储的数据设置过期时间，这样过期后的数据自动被清除，服务本身不<br>会监控过期，而是在访问的时候查看 key 的时间戳,判断是否过期。<br>j、memcache 会对设定的内存进行分块，再把块分组，然后再提供服务。<br>4、简述 Memcached 内存管理机制原理？<br>早期的 Memcached 内存管理方式是通过 malloc 的分配的内存，使用完后通过<br>free 来回收内存，这种方式容易产生内存碎片，并降低操作系统对内存的管理效<br>率。加重操作系统内存管理器的负担，最坏的情况下，会导致操作系统比<br>memcached 进程本身还慢，为了解决这个问题，Slab Allocation 内存分配机制<br>就延生了。<br>现在 Memcached 利用 Slab Allocation 机制来分配和管理内存。<br>Slab<br>Allocation 机制原理是按照预先规定的大小，将分配给 memcached 的内存分割<br>成特定长度的内存块（chunk)，再把尺寸相同的内存块，分成组<br>（chunks slab class),这些内存块不会释放，可以重复利用。<br>而且，slab allocator 还有重复使用已分配的内存的目的。 也就是说，分配到的<br>内存不会释放，而是重复利用。<br>Slab Allocation 的主要术语<br>Page<br>分配给 Slab 的内存空间，默认是 1MB。分配给 Slab 之后根据 slab 的大小切分成<br>chunk。<br>Chunk<br>用于缓存记录的内存空间。<br>SlabClass<br>特定大小的 chunk 的组。<br>集群架构方面的问题</p><p>7、memcached 和 MySQL 的 query<br>cache 相比，有什么优缺点？<br>把 memcached 引入应用中，还是需要不少工作量的。MySQL 有个使用方便的<br>query cache，可以自动地缓存 SQL 查询的结果，被缓存的 SQL 查询可以被反复<br>地快速执行。Memcached 与之相比，怎么样呢？MySQL 的 query cache 是集中<br>式的，连接到该 query cache 的 MySQL 服务器都会受益。<br> 当您修改表时，MySQL 的 query cache 会立刻被刷新（flush）。存储<br>一个 memcached item 只需要很少的时间，但是当写操作很频繁时，MySQL<br>的 query cache 会经常让所有缓存数据都失效。<br> 在多核 CPU 上，MySQL 的 query cache 会遇到扩展问题（scalability<br>issues）。在多核 CPU 上，query cache 会增加一个全局锁（global lock）, 由<br>于需要刷新更多的缓存数据，速度会变得更慢。<br> 在 MySQL 的 query cache 中，我们是不能存储任意的数据的（只能是<br>SQL 查询结果）。而利用 memcached，我们可以搭建出各种高效的缓存。比<br>如，可以执行多个独立的查询，构建出一个用户对象（user object），然后将<br>用户对象缓存到 memcached 中。而 query cache 是 SQL 语句级别的，不可能<br>做到这一点。在小的网站中，query cache 会有所帮助，但随着网站规模的增加，<br>query cache 的弊将大于利。<br> query cache能够利用的内存容量受到MySQL服务器空闲内存空间的限<br>制。给数据库服务器增加更多的内存来缓存数据，固然是很好的。但是，有了<br>memcached，只要您有空闲的内存，都可以用来增加 memcached 集群的规<br>模，然后您就可以缓存更多的数据。<br>8、memcached 和服务器的 local cache（比如 PHP 的 APC、<br>mmap 文件等）相比，有什么优缺点？<br>首先，local cache 有许多与上面(query cache)相同的问题。local cache 能够利<br>用的内存容量受到（单台）服务器空闲内存空间的限制。不过，local<br>cache 有一点比 memcached 和 query cache 都要好，那就是它不但可以存储任<br>意的数据，而且没有网络存取的延迟。<br> local cache 的数据查询更快。考虑把 highly common 的数据放在 local<br>cache 中吧。如果每个页面都需要加载一些数量较少的数据，考虑把它们放在<br>local<br>cached 吧。<br> local cache 缺少集体失效（group<br>invalidation）的特性。在 memcached 集群中，删除或更新一个 key 会让所有<br>的观察者觉察到。但是在local cache中, 我们只能通知所有的服务器刷新cache<br>（很慢，不具扩展性），或者仅仅依赖缓存超时失效机制。<br> local cache 面临着严重的内存限制，这一点上面已经提到。<br>9、memcached 的 cache 机制是怎样的？<br>Memcached 主要的 cache 机制是 LRU（最近最少用）算法+超时失效。当您存<br>数据到 memcached 中，可以指定该数据在缓存中可以呆多久 Which is forever,<br>or some time in the future。如果 memcached 的内存不够用了，过期的 slabs<br>会优先被替换，接着就轮到最老的未被使用的 slabs。<br>10、memcached 如何实现冗余机制？<br>不实现！我们对这个问题感到很惊讶。Memcached 应该是应用的缓存层。它的设<br>计本身就不带有任何冗余机制。如果一个 memcached 节点失去了所有数据，您<br>应该可以从数据源（比如数据库）再次获取到数据。您应该特别注意，您的应用<br>应该可以容忍节点的失效。不要写一些糟糕的查询代码，寄希望于 memcached<br>来保证一切！如果您担心节点失效会大大加重数据库的负担，那么您可以采取一<br>些办法。比如您可以增加更多的节点（来减少丢失一个节点的影响），热备节点<br>（在其他节点 down 了的时候接管 IP），等等。<br>11、memcached 如何处理容错的？<br>不处理！ 在 memcached 节点失效的情况下，集群没有必要做任何容错处理。如<br>果发生了节点失效，应对的措施完全取决于用户。节点失效时，下面列出几种方<br>案供您选择：<br> 忽略它！ 在失效节点被恢复或替换之前，还有很多其他节点可以应对节<br>点失效带来的影响。<br> 把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下<br>（余数式哈希算法），客户端添加或移除节点，会导致所有的缓存数据不可用！<br>因为哈希参照的节点列表变化了，大部分 key 会因为哈希值的改变而被映射到<br>（与原来）不同的节点上。<br> 启动热备节点，接管失效节点所占用的 IP。这样可以防止哈希紊乱<br>（hashing chaos）。<br> 如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈<br>希算法（consistent hashing）。您可以百度一下一致性哈希算法。支持一致性<br>哈希的客户端已经很成熟，而且被广泛使用。去尝试一下吧！<br> 两次哈希（reshing）。当客户端存取数据时，如果发现一个节点 down<br>了，就再做一次哈希（哈希算法与前一次不同），重新选择另一个节点（需要注<br>意的时，客户端并没有把 down 的节点从节点列表中移除，下次还是有可能先<br>哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和<br>坏的节点上都可能存在脏数据（stale data）。<br>12、如何将 memcached 中 item 批量导入导出？<br>您不应该这样做！Memcached 是一个非阻塞的服务器。任何可能导致<br>memcached 暂停或瞬时拒绝服务的操作都应该值得深思熟虑。向 memcached<br>中批量导入数据往往不是您真正想要的！想象看，如果缓存数据在导出导入之间<br>发生了变化，您就需要处理脏数据了；<br>13、如果缓存数据在导出导入之间过期了，您又怎么处理这些<br>数据呢？<br>因此，批量导出导入数据并不像您想象中的那么有用。不过在一个场景倒是很有<br>用。如果您有大量的从不变化的数据，并且希望缓存很快热（warm）起来，批量<br>导入缓存数据是很有帮助的。虽然这个场景并不典型，但却经常发生，因此我们<br>会考虑在将来实现批量导出导入的功能。<br>如果一个 memcached 节点 down 了让您很痛苦，那么您还会陷入其他很多麻烦。<br>您的系统太脆弱了。您需要做一些优化工作。比如处理”惊群”问题（比如<br>memcached 节点都失效了，反复的查询让您的数据库不堪重负…这个问题在 FAQ<br>的其他提到过），或者优化不好的查询。记住，Memcached 并不是您逃避优化<br>查询的借口。<br>14、memcached 是如何做身份验证的？<br>没有身份认证机制！memcached 是运行在应用下层的软件（身份验证应该是应用<br>上层的职责）。memcached 的客户端和服务器端之所以是轻量级的，部分原因就<br>是完全没有实现身份验证机制。这样，memcached 可以很快地创建新连接，服务<br>器端也无需任何配置。<br>如果您希望限制访问，您可以使用防火墙，或者让 memcached 监听 unix domain<br>socket。<br>15、memcached 的多线程是什么？如何使用它们？<br>线程就是定律（threads rule）！在 Steven Grimm 和 Facebook 的努力下，<br>memcached 1.2 及更高版本拥有了多线程模式。多线程模式允许 memcached 能<br>够充分利用多个 CPU，并在 CPU 之间共享所有的缓存数据。memcached 使用一<br>种简单的锁机制来保证数据更新操作的互斥。相比在同一个物理机器上运行多个<br>memcached 实例，这种方式能够更有效地处理 multi gets。<br>如果您的系统负载并不重，也许您不需要启用多线程工作模式。如果您在运行一<br>个拥有大规模硬件的、庞大的网站，您将会看到多线程的好处。<br>简单地总结一下：命令解析（memcached 在这里花了大部分时间）可以运行在多<br>线程模式下。memcached 内部对数据的操作是基于很多全局锁的（因此这部分工<br>作不是多线程的）。未来对多线程模式的改进，将移除大量的全局锁，提高<br>memcached 在负载极高的场景下的性能。<br>16、memcached 能接受的 key 的最大长度是多少？<br>key 的最大长度是 250 个字符。需要注意的是，250 是 memcached 服务器端内<br>部的限制，如果您使用的客户端支持”key 的前缀”或类似特性，那么 key（前缀<br>+原始 key）的最大长度是可以超过 250 个字符的。我们推荐使用使用较短的 key，<br>因为可以节省内存和带宽。<br>memcached 对 item 的过期时间有什么限制？<br>过期时间最大可以达到 30 天。memcached 把传入的过期时间（时间段）解释成<br>时间点后，一旦到了这个时间点，memcached 就把 item 置为失效状态。这是一<br>个简单但 obscure 的机制。<br>17、memcached 最大能存储多大的单个 item？<br>1MB。如果你的数据大于 1MB，可以考虑在客户端压缩或拆分到多个 key 中。<br>为什么单个 item 的大小被限制在 1M byte 之内？<br>啊…这是一个大家经常问的问题！<br>简单的回答：因为内存分配器的算法就是这样的。<br>详细的回答：Memcached 的内存存储引擎（引擎将来可插拔…），使用 slabs 来<br>管理内存。内存被分成大小不等的 slabs chunks（先分成大小相等的 slabs，然后<br>每个 slab 被分成大小相等 chunks，不同 slab 的 chunk 大小是不相等的）。chunk<br>的大小依次从一个最小数开始，按某个因子增长，直到达到最大的可能值。<br>18、memcached 能够更有效地使用内存吗？<br>Memcache 客户端仅根据哈希算法来决定将某个 key 存储在哪个节点上，而不考<br>虑节点的内存大小。因此，您可以在不同的节点上使用大小不等的缓存。但是一<br>般都是这样做的：拥有较多内存的节点上可以运行多个 memcached 实例，每个<br>实例使用的内存跟其他节点上的实例相同。<br>19、什么是二进制协议，我该关注吗？<br>关于二进制最好的信息当然是二进制协议规范：<br>二进制协议尝试为端提供一个更有效的、可靠的协议，减少客户端&#x2F;服务器端因处<br>理协议而产生的 CPU 时间。<br>根据 Facebook 的测试，解析 ASCII 协议是 memcached 中消耗 CPU 时间最多的<br>环节。所以，我们为什么不改进 ASCII 协议呢？<br>20、memcached 的内存分配器是如何工作的？为什么不适用<br>malloc&#x2F;free！？为何要使用 slabs？<br>实际上，这是一个编译时选项。默认会使用内部的 slab 分配器。您确实确实应该<br>使用内建的 slab 分配器。最早的时候，memcached 只使用 malloc&#x2F;free 来管理<br>内存。然而，这种方式不能与 OS 的内存管理以前很好地工作。反复地 malloc&#x2F;free<br>造成了内存碎片，OS 最终花费大量的时间去查找连续的内存块来满足 malloc 的<br>请求，而不是运行 memcached 进程。如果您不同意，当然可以使用 malloc！只<br>是不要在邮件列表中抱怨啊<br>slab 分配器就是为了解决这个问题而生的。内存被分配并划分成 chunks，一直被<br>重复使用。因为内存被划分成大小不等的 slabs，如果 item 的大小与被选择存放<br>它的 slab 不是很合适的话，就会浪费一些内存。Steven Grimm 正在这方面已经<br>做出了有效的改进。<br>21、memcached 是原子的吗？<br>所有的被发送到 memcached 的单个命令是完全原子的。如果您针对同一份数据<br>同时发送了一个 set 命令和一个 get 命令，它们不会影响对方。它们将被串行化、<br>先后执行。即使在多线程模式，所有的命令都是原子的，除非程序有 bug:)<br>命令序列不是原子的。如果您通过 get 命令获取了一个 item，修改了它，然后想<br>把它 set 回 memcached，我们不保证这个 item 没有被其他进程（process，未<br>必是操作系统中的进程）操作过。在并发的情况下，您也可能覆写了一个被其他<br>进程 set 的 item。<br>memcached 1.2.5 以及更高版本，提供了 gets 和 cas 命令，它们可以解决上面<br>的问题。如果您使用 gets 命令查询某个 key 的 item，memcached 会给您返回<br>该 item 当前值的唯一标识。如果您覆写了这个 item 并想把它写回到 memcached<br>中，您可以通过 cas 命令把那个唯一标识一起发送给 memcached。如果该 item<br>存放在 memcached 中的唯一标识与您提供的一致，您的写操作将会成功。如果<br>另一个进程在这期间也修改了这个 item，那么该 item 存放在 memcached 中的<br>唯一标识将会改变，您的写操作就会失败<br>22、如何实现集群中的 session 共享存储？<br>Session 是运行在一台服务器上的，所有的访问都会到达我们的唯一服务器上，这<br>样我们可以根据客户端传来的 sessionID，来获取 session，或在对应 Session 不<br>存在的情况下（session 生命周期到了&#x2F;用户第一次登录），创建一个新的 Session；<br>但是，如果我们在集群环境下，假设我们有两台服务器 A，B，用户的请求会由<br>Nginx 服务器进行转发（别的方案也是同理），用户登录时，Nginx 将请求转发<br>至服务器 A 上，A 创建了新的 session，并将 SessionID 返回给客户端，用户在浏<br>览其他页面时，客户端验证登录状态，Nginx 将请求转发至服务器 B，由于 B 上<br>并没有对应客户端发来 sessionId 的 session，所以会重新创建一个新的 session，<br>并且再将这个新的 sessionID 返回给客户端，这样，我们可以想象一下，用户每<br>一次操作都有 1&#x2F;2 的概率进行再次的登录，这样不仅对用户体验特别差，还会让<br>服务器上的 session 激增，加大服务器的运行压力。<br>为了解决集群环境下的 seesion 共享问题，共有 4 种解决方案：<br>1.粘性 session<br>粘性 session 是指 Ngnix 每次都将同一用户的所有请求转发至同一台服务器上，<br>即将用户与服务器绑定。<br>2.服务器 session 复制<br>即每次 session 发生变化时，创建或者修改，就广播给所有集群中的服务器，使<br>所有的服务器上的 session 相同。<br>3.session 共享<br>缓存 session，使用 redis， memcached。<br>4.session 持久化<br>将 session 存储至数据库中，像操作数据一样才做 session。<br>23、memcached 与 redis 的区别？<br>1、Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash<br>等数据结构的存储。而 memcache 只支持简单数据类型，需要客户端自己处理复<br>杂对象<br>2、Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可<br>以再次加载进行使用（PS：持久化在 rdb、aof）。<br>3、由于 Memcache 没有持久化机制，因此宕机所有缓存数据失效。Redis 配置<br>为持久化，宕机重启后，将自动加载宕机时刻的数据到缓存系统中。具有更好的<br>灾备机制。<br>4、Memcache 可以使用 Magent 在客户端进行一致性 hash 做分布式。Redis 支<br>持在服务器端做分布式（PS:Twemproxy&#x2F;Codis&#x2F;Redis-cluster 多种分布式实现方<br>式）<br>5、Memcached 的简单限制就是键（key）和 Value 的限制。最大键长为 250 个<br>字符。可以接受的储存数据不能超过 1MB（可修改配置文件变大），因为这是典<br>型 slab 的最大值，不适合虚拟机使用。而 Redis 的 Key 长度支持到 512k。<br>6、Redis 使用的是单线程模型，保证了数据按顺序提交。Memcache 需要使用<br>cas 保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属<br>于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操<br>作，不一致就放弃任何操作<br>cpu 利用。由于 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每<br>一个核上 Redis 在存储小数据时比 Memcached 性能更 高。而在 100k 以上的数<br>据中，Memcached 性能要高于 Redis 。<br>7、memcache 内存管理：使用 Slab Allocation。原理相当简单，预先分配一系<br>列大小固定的组，然后根据数据大小选择最合适的块存储。避免了内存碎片。（缺<br>点：不能变长，浪费了一定空间）memcached 默认情况下下一个 slab 的最大值<br>为前一个的 1.25 倍。<br>8、redis 内存管理： Redis 通过定义一个数组来记录所有的内存分配情况， Redis<br>采用的是包装的 malloc&#x2F;free，相较于 Memcached 的内存 管理方法来说，要简<br>单很多。由于 malloc 首先以链表的方式搜索已管理的内存中可用的空间分配，导<br>致内存碎片比较多<br>7、redis一个字符串类型的值能存储最大容量是多少？<br>答：512M<br>9、Redis 常见性能问题和解决方案：<br>1、Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave<br>函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性<br>暂停服务<br>2、如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一<br>3、为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网<br>4、尽量避免在压力很大的主库上增加从<br>5、主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1<br>&lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现 Slave 对 Master<br>的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。</p><p>12、为什么 edis 需要把所有数据放到内存中？<br>答：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数<br>据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，<br>磁盘 I&#x2F;O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越<br>来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不<br>能继续插入新值。<br>14、Pipeline 有什么好处，为什么要用 pipeline？<br>答：可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有<br>因果相关性。使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS<br>峰值的一个重要因素是 pipeline 批次指令的数目。<br>19、Redis 如何设置密码及验证密码？<br>设置密码：config set requirepass 123456<br>授权密码：auth 123456<br>20、说说 Redis 哈希槽的概念？<br>答：Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有<br>16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，<br>集群的每个节点负责一部分 hash 槽。<br>21、Redis 集群的主从复制模型是怎样的？<br>答：为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所<br>以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.<br>22、Redis 集群会有写操作丢失吗？为什么？<br>答：Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可<br>能会丢失写操作。<br>23、Redis 集群之间是如何复制的？<br>答：异步复制<br>24、Redis 集群最大节点个数是多少？<br>答：16384 个。<br>25、Redis 集群如何选择数据库？<br>答：Redis 集群目前无法做数据库选择，默认在 0 数据库。<br>26、怎么测试 Redis 的连通性？<br>答：使用 ping 命令。<br>27、怎么理解 Redis 事务？<br>答：<br>1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。<br>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<br>28、Redis 事务相关的命令有哪几个？<br>答：MULTI、EXEC、DISCARD、WATCH<br>29、Redis key 的过期时间和永久有效分别怎么设置？<br>答：EXPIRE 和 PERSIST 命令。<br>30、Redis 如何做内存优化？<br>答：尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用<br>的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比<br>如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码<br>设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面.<br>31、Redis 回收进程如何工作的？<br>答：一个客户端运行了新的命令，添加了新的数据。Redi 检查内存使用情况，如<br>果大于 maxmemory 的限制, 则根据设定好的策略进行回收。一个新的命令被执<br>行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地<br>回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合<br>的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。<br>32、都有哪些办法可以降低 Redis 的内存使用情况呢？<br>答：如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set<br>等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放<br>到一起。<br>33、Redis 的内存用完了会发生什么？<br>答：如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正<br>常返回。）或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存<br>上限时会冲刷掉旧的内容。<br>34、一个 Redis 实例最多能存放多少的 keys？List、Set、<br>Sorted Set 他们最多能存放多少元素？<br>答：理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实<br>例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list、set、<br>和 sorted set 都可以放 232 个元素。换句话说，Redis 的存储极限是系统中的可<br>用内存值。<br>35、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如<br>何保证 redis 中的数据都是热点数据？<br>答：Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。<br>36、Redis 最适合的场景？<br>1、会话缓存（Session Cache）<br>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会<br>话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不<br>是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不<br>高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容<br>易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台<br>Magento 也提供 Redis 的插件。<br>2、全页缓存（FPC）<br>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，<br>即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的<br>下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento<br>提供一个插件来使用 Redis 作为全页缓存后端。 此外，对 WordPress 的用户来<br>说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加<br>载你曾浏览过的页面。<br>3、队列<br>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis<br>能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本<br>地程序语言（如 Python）对 list 的 push&#x2F;pop 操作。 如果你快速的在 Google<br>中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就<br>是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一<br>个后台就是使用 Redis 作为 broker，你可以从这里去查看。<br>4，排行榜&#x2F;计数器<br>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序<br>集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是<br>正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10<br>个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，<br>这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，<br>你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就<br>是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，<br>你可以在这里看到。<br>5、发布&#x2F;订阅<br>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景<br>确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚<br>本触发器，甚至用 Redis 的发布&#x2F;订阅功能来建立聊天系统！<br>37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以<br>某个固定的已知的前缀开头的，如果将它们全部找出来？<br>答：使用 keys 指令可以扫出指定模式的 key 列表。<br>对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会<br>有什么问题？<br>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线<br>程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时<br>候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但<br>是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间<br>会比直接用 keys 指令长。<br>38、如果有大量的 key 需要设置同一时间过期，一般需要注意<br>什么？<br>答：如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能<br>会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一<br>些。<br>39、使用过 Redis 做异步队列么，你是怎么用的？<br>答：一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有<br>消息的时候，要适当 sleep 一会再重试。<br>如果对方追问可不可以不用 sleep 呢？<br>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对<br>方追问能不能生产一次消费多次呢？使用 pub&#x2F;sub 主题订阅者模式，可以实现<br>1:N 的消息队列。<br>如果对方追问 pub&#x2F;sub 有什么缺点？<br>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ<br>等。<br>如果对方追问 redis 如何实现延时队列？<br>我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这<br>么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为<br>score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令<br>获取 N 秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇<br>指。但是他不知道的是此刻你却竖起了中指，在椅子背后。<br>40、使用过 Redis 分布式锁么，它是什么回事？<br>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了<br>释放。<br>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire<br>之前进程意外 crash 或者要重启维护了，那会怎么样？<br>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你<br>需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，<br>然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和<br>expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子<br>还不错。<br>11、列对比运算符是什么？<br>在 SELECT 语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，<br>OR 或 LIKE 运算符。</p><p>17、可以使用多少列创建索引？<br>任何标准表最多可以创建 16 个索引列。<br>18、NOW（）和 CURRENT_DATE（）有什么区别？<br>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。<br>CURRENT_DATE（）仅显示当前年份，月份和日期。<br>20、什么是通用 SQL 函数？<br>1、CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个<br>或多个字段合并为一个字段。<br>2、FORMAT(X, D)- 格式化数字 X 到 D 有效数字。<br>3、CURRDATE(), CURRTIME()- 返回当前日期或时间。<br>4、NOW（） – 将当前日期和时间作为一个值返回。<br>5、MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期<br>值中提取给定数据。<br>6、HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。<br>7、DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄<br>8、SUBTIMES（A，B） – 确定两次之间的差异。<br>9、FROMDAYS（INT） – 将整数天数转换为日期值。</p><p>23、MySQL 有关权限的表都有哪几个？<br>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 MySQL 数<br>据库里，由 MySQL_install_db 脚本初始化。这些权限表分别 user，db，table_priv，<br>columns_priv 和 host。<br>24、列的字符串类型可以是什么？<br>字符串类型是：<br>1、SET<br>2、BLOB<br>3、ENUM<br>4、CHAR<br>5、TEXT<br>25、MySQL 数据库作发布系统的存储，一天五万条以上的增量，<br>预计运维三年,怎么优化？<br>1、设计良好的数据库结构，允许部分数据冗余，尽量避免 join 查询，提高效率。<br>2、选择合适的表字段数据类型和存储引擎，适当的添加索引。<br>3、MySQL 库主从读写分离。<br>4、找规律分表，减少单表中的数据量提高查询速度。<br>5、添加缓存机制，比如 memcached，apc 等。<br>6、不经常改动的页面，生成静态页面。<br>7、书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1,<br>field_2, field_3 FROM TABLE.<br>26、锁的优化策略<br>1、读写分离<br>2、分段加锁<br>3、减少锁持有的时间<br>4.多个线程尽量以相同的顺序去获取资源<br>不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效<br>率不如一次加一把大锁。<br>27、索引的底层实现原理和优化<br>B+树，经过优化的 B+树<br>主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此 InnoDB 建<br>议为大部分表使用默认自增的主键作为主索引。<br>28、什么情况下设置了索引但无法使用<br>1、以“%”开头的 LIKE 语句，模糊匹配<br>2、OR 语句前后没有同时使用索引<br>3、数据类型出现隐式转化（如 varchar 不加单引号的话可能会自动转换为 int 型）<br>29、实践中如何优化 MySQL<br>最好是按照以下顺序优化：<br>1、SQL 语句及索引的优化<br>2、数据库表结构的优化<br>3、系统配置的优化<br>4、硬件的优化<br>详细可以查看 阿里 P8 架构师谈：MySQL 慢查询优化、索引优化、以及表等优化<br>总结<br>30、优化数据库的方法<br>1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL，<br>例如’省份’、’性别’最好适用 ENUM<br>2、使用连接(JOIN)来代替子查询<br>3、适用联合(UNION)来代替手动创建的临时表<br>4、事务处理<br>5、锁定表、优化事务处理<br>6、适用外键，优化锁定表<br>7、建立索引<br>8、优化查询语句<br>31、简单描述 MySQL 中，索引，主键，唯一索引，联合索引<br>的区别，对数据库的性能有什么影响（从读写两方面）<br>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们<br>包含着对数据表里所有记录的引用指针。<br>普通索引(由关键字 KEY 或 INDEX 定义的索引)的唯一任务是加快对数据的访问速<br>度。<br>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼<br>此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它<br>定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。<br>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯<br>一标识一条记录，使用关键字 PRIMARY KEY 来创建。<br>索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引，这就是联合索<br>引。<br>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，<br>因为在执行这些写操作时，还要操作索引文件。</p><p>33、SQL 注入漏洞产生的原因？如何防止？<br>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进<br>行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。<br>防止 SQL 注入的方式：<br>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置<br>执行 sql 语句时使用 addslashes 进行 sql 语句转换<br>Sql 语句书写尽量不要省略双引号和单引号。<br>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。<br>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不<br>易被猜到的。<br>34、为表中得字段选择合适得数据类型<br>字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text<br>优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得<br>数据类型，应该优先选择占用空间小的数据类型<br>35、存储时期<br>Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，<br>占用 8 个字节得存储空间，datatime 类型与时区无关<br>Timestamp:以时间戳格式存储，占用 4 个字节，范围小 1970-1-1 到 2038-1-19，<br>显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改<br>timestamp 列得值<br>Date:（生日）占用得字节数比使用字符串.datatime.int 储存要少，使用 date 只<br>需要 3 个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算<br>Time:存储时间部分得数据<br>注意:不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小，<br>在进行查找过滤可以利用日期得函数）<br>使用 int 存储日期时间不如使用 timestamp 类型<br>36、对于关系型数据库而言，索引是相当重要的概念，请回答<br>有关索引的几个问题：<br>1、索引的目的是什么？<br>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间<br>2、索引对数据库系统的负面影响是什么？<br>负面影响：<br>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需<br>要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；<br>当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速<br>度。<br>3、为数据表建立索引的原则有哪些？<br>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引<br>4、什么情况下不宜建立索引？<br>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等<br>37、解释 MySQL 外连接、内连接与自连接的区别<br>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一<br>个表的所有记录和另一个表中的所有记录一一匹配。<br>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合<br>条件的记录不会出现在结果集中，即内连接只连接匹配的行。<br>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个<br>表中<br>的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。<br>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，<br>对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以<br>NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现<br>在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。<br>38、Myql 中的事务回滚机制概述<br>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个<br>不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤<br>销。<br>要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修<br>改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依<br>旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个<br>事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和<br>第二个表都要回到未修改的状态，这就是所谓的事务回滚<br>39、SQL 语言包括哪几部分？每部分都有哪些操作关键字？<br>SQL 语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）<br>四个部分。<br>数据定义：Create Table,Alter Table,Drop Table, Craete&#x2F;Drop Index 等<br>数据操纵：Select ,insert,update,delete,<br>数据控制：grant,revoke<br>数据查询：select<br>40、完整性约束包括哪些？<br>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。<br>分为以下四类：<br>1、实体完整性：规定表的每一行在表中是惟一的实体。<br>2、域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括<br>取值范围、精度等规定。<br>3、参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间<br>的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。<br>4、用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需<br>要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束<br>条件，它反映某一具体应用必须满足的语义要求。<br>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、<br>foreign key、check、UNIQUE) 。<br>41、什么是锁？<br>答：数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数<br>据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可<br>能会读取和存储不正确的数据，破坏数据库的一致性。<br>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进<br>行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定<br>的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。<br>基本锁类型：锁包括行级锁和表级锁<br>42、什么叫视图？游标是什么？<br>答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，<br>查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影<br>响基本表。它使得我们获取数据更容易，相比多表查询。<br>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元<br>中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。<br>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。<br>43、什么是存储过程？用什么来调用？<br>答：存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需<br>创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，<br>使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。<br>44、如何通俗地理解三个范式？<br>答：第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>第二范式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，<br>它要求字段没有冗余。。<br>范式化设计优缺点:<br>优点:<br>可以尽量得减少数据冗余，使得更新快，体积小<br>缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引<br>优化<br>反范式化:<br>优点:可以减少表得关联，可以更好得进行索引优化<br>缺点:数据冗余以及数据异常，数据得修改需要更多的成本<br>45、什么是基本表？什么是视图？<br>答：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从<br>一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表<br>46、试述视图的优点？<br>答：(1) 视图能够简化用户的操作 (2) 视图使用户能以多种角度看待同一数据；<br>(3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供<br>安全保护。<br>47、 NULL 是什么意思<br>答：NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这<br>个值的任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比<br>较，并在逻辑上希望获得一个答案。<br>使用 IS NULL 来进行 NULL 判断<br>48、主键、外键和索引的区别？<br>主键、外键和索引的区别<br>定义：<br>主键–唯一标识一条记录，不能有重复的，不允许为空<br>外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值<br>索引–该字段没有重复值，但可以有一个空值<br>作用：<br>主键–用来保证数据完整性<br>外键–用来和其他表建立联系用的<br>索引–是提高查询排序的速度<br>个数：<br>主键–主键只能有一个<br>外键–一个表可以有多个外键<br>索引–一个表可以有多个唯一索引<br>49、你可以用什么来确保表格里的字段只接受特定范围里的值?<br>答：Check 限制，它在数据库表格里被定义，用来限制输入该列的值。<br>触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求<br>触发器在表格里被定义，这可能会在某些情况下影响到性能。<br>50、说说对 SQL 语句优化有哪些方法？（选择几条）<br>1、Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可<br>以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。<br>2、用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。<br>3、 避免在索引列上使用计算<br>4、避免在索引列上使用 IS NULL 和 IS NOT NULL<br>5、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉<br>及的列上建立索引。<br>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃<br>使用索引而进行全表扫描<br>7、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用<br>索引而进行全表扫描<br>Java 并发编程（一）<br>1、在 java 中守护线程和本地线程区别？<br>java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。<br>任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(bool<br>on)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()<br>必须在 Thread.start()之前调用，否则运行时会抛出异常。<br>两者的区别：<br>唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果<br>全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可<br>以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的<br>线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产<br>生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线<br>程时，Java 虚拟机会自动离开。<br>扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护<br>进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break<br>的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。<br>2、线程与进程的区别？<br>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。<br>一个程序至少有一个进程,一个进程至少有一个线程。<br>3、什么是多线程中的上下文切换？<br>多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，<br>为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU<br>发生的切换数据等就是上下文切换。<br>4、死锁与活锁的区别，死锁与饥饿的区别？<br>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成<br>的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br>产生死锁的必要条件：<br>1、互斥条件：所谓互斥就是进程在某一时间内独占资源。<br>2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3、不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。<br>4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，<br>失败，尝试，失败。<br>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而<br>处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。<br>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执<br>行的状态。<br>Java 中导致饥饿的原因：<br>1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。<br>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前<br>持续地对该同步块进行访问。<br>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方<br>法)，因为其他线程总是被持续地获得唤醒。<br>5、Java 中用到的线程调度算法是什么？<br>采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优<br>先级上，如非特别需要，尽量不要用，防止线程饥饿。<br>6、什么是线程组，为什么在 Java 中不推荐使用？<br>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，<br>也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。<br>为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使<br>用，推荐使用线程池。<br>8、在 Java 中 Executor 和 Executors 的区别？<br>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务<br>的需求。<br>Executor 接口对象能执行我们的线程任务。<br>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我<br>们能获得任务执行的状态并且可以获取任务的返回值。<br>使用 ThreadPoolExecutor 可以创建自定义线程池。<br>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的<br>完成，并可以使用 get()方法获取计算的结果。<br>9、如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时<br>间最长？<br>参考：<br><a target="_blank" rel="noopener" href="http://daiguahub.com/2016/07/31/%E4%BD%BF%E7%94%A8">http://daiguahub.com/2016/07/31/使用</a> jstack 找出消耗 CPU 最多的线程代码<br>&#x2F;<br>10、什么是原子操作？在 Java Concurrency API 中有哪些原<br>子类(atomic classes)？<br>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。<br>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。<br>在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——<br>Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持 CAS<br>的原子操作。<br>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境<br>下避免数据不一致必须的手段。<br>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程<br>有可能会读到之前的值，这就会引发错误。<br>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同<br>步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和<br>long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需<br>要使用同步。<br>java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程<br>环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当<br>某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像<br>自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个<br>线程进入，这只是一种逻辑上的理解。<br>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference<br>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray<br>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，<br>AtomicReferenceFieldUpdater<br>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean<br>来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累<br>加来反映中间有没有变过）<br>11、Java Concurrency API 中的 Lock 接口(Lock interface)<br>是什么？对比同步它有什么优势？<br>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。<br>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的<br>条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的<br>(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多<br>条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平<br>锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非<br>公平锁是高效的选择。<br>12、什么是 Executors 框架？<br>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框<br>架。<br>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的<br>解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用<br>Executors 框架可以非常方便的创建一个线程池。<br>13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用<br>阻塞队列来实现生产者-消费者模型？<br>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<br>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当<br>队列满时，存储元素的线程会等待队列可用。<br>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消<br>费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者<br>也只从容器里拿元素。<br>JDK7 提供了 7 个阻塞队列。分别是：<br>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。<br>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作<br>和线程同步可以实现生产者，消费者模式，主要的技术就是用好，<br>wait ,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻<br>塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面<br>也有保障。<br>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是<br>作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向<br>BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图<br>从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这<br>个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，<br>它可以很好的控制线程之间的通信。<br>阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线<br>程不断将数据放入队列，然后解析线程不断从队列取数据解析。<br>14、什么是 Callable 和 Future?<br>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返<br>回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执<br>行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到<br>异步执行任务的返回值。<br>可以认为是带有回调的 Runnable。<br>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable<br>用于产生结果，Future 用于获取结果。<br>15、什么是 FutureTask?使用 ExecutorService 启动任务。<br>在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消<br>运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才<br>能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用<br>了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable<br>接口所以它可以提交给 Executor 来执行。<br>16、什么是并发容器的实现？<br>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有<br>多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，<br>以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。<br>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容<br>器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上<br>关键字 synchronized。<br>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，<br>例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段<br>锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作<br>的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程<br>并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。<br>17、多线程同步和互斥有几种实现方法，都是什么？<br>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程<br>的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。<br>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若<br>干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它<br>要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成<br>是一种特殊的线程同步。<br>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式<br>就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，<br>而用户模式就是不需要切换到内核态，只在用户态完成操作。<br>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模<br>式下的方法有：事件，信号量，互斥量。<br>18、什么是竞争条件？你怎样发现和解决竞争？<br>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的<br>顺序时，则我们认为这发生了竞争条件（race condition）。<br>19、你将如何使用 thread dump？你将如何分析 Thread<br>dump？<br>新建状态（New）<br>用 new 语句创建的线程处于新建状态，此时它和其他 Java 对象一样，仅仅在堆区<br>中被分配了内存。<br>就绪状态（Runnable）<br>当一个线程对象创建后，其他线程调用它的 start()方法，该线程就进入就绪状态，<br>Java 虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运<br>行池中，等待获得 CPU 的使用权。<br>运行状态（Running）<br>处于这个状态的线程占用 CPU，执行程序代码。只有处于就绪状态的线程才有机<br>会转到运行状态。<br>阻塞状态（Blocked）<br>阻塞状态是指线程因为某些原因放弃 CPU，暂时停止运行。当线程处于阻塞状态<br>时，Java 虚拟机不会给线程分配 CPU。直到线程重新进入就绪状态，它才有机会<br>转到运行状态。<br>阻塞状态可分为以下 3 种：<br>位于对象等待池中的阻塞状态（Blocked in object’s wait pool）：<br>当线程处于运行状态时，如果执行了某个对象的 wait()方法，Java 虚拟机就会把<br>线程放到这个对象的等待池中，这涉及到“线程通信”的内容。<br>位于对象锁池中的阻塞状态（Blocked in object’s lock pool）：<br>当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已<br>经被其他线程占用，Java 虚拟机就会把这个线程放到这个对象的锁池中，这涉及<br>到“线程同步”的内容。<br>其他阻塞状态（Otherwise Blocked）：<br>当前线程执行了 sleep()方法，或者调用了其他线程的 join()方法，或者发出了 I&#x2F;O<br>请求时，就会进入这个状态。<br>死亡状态（Dead）<br>当线程退出 run()方法时，就进入死亡状态，该线程结束生命周期。<br>我们运行之前的那个死锁代码 SimpleDeadLock.java，然后尝试输出信息(<br>&#x2F;* 时间，jvm 信息 <em>&#x2F;<br>2017-11-01 17:36:28<br>Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed<br>mode):<br>&#x2F;</em> 线程名称：DestroyJavaVM<br>编号：#13<br>优先级：5<br>系统优先级：0<br>jvm 内部线程 id：0x0000000001c88800<br>对应系统线程 id（NativeThread ID）：0x1c18<br>线程状态： waiting on condition [0x0000000000000000] （等待某个条件）<br>线程详细状态：java.lang.Thread.State: RUNNABLE 及之后所有*&#x2F;<br>“DestroyJavaVM” #13 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x0000000001c88800<br>nid&#x3D;0x1c18 waiting on condition [0x0000000000000000]<br>java.lang.Thread.State: RUNNABLE<br>“Thread-1” #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x0000000018d49000<br>nid&#x3D;0x17b8 waiting for monitor entry [0x0000000019d7f000]<br>&#x2F;* 线程状态：阻塞（在对象同步上）<br>代码位置：at<br>com.leo.interview.SimpleDeadLock&#96;$B.run(SimpleDeadLock.java:56)<br>等待锁：0x00000000d629b4d8<br>已经获得锁：0x00000000d629b4e8*&#x2F;</p><p>25、Java 中用到的线程调度算法是什么？<br>计算机通常只有一个 CPU,在任意时刻只能执行一条机器指令,每个线程只有获得<br>CPU 的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线<br>程轮流获得 CPU 的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状<br>态的线程在等待 CPU,JAVA 虚拟机的一项任务就是负责线程的调度,线程调度是指<br>按照特定机制为多个线程分配 CPU 的使用权.<br>有两种调度模型：分时调度模型和抢占式调度模型。<br>分时调度模型是指让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占<br>用的 CPU 的时间片这个也比较好理解。<br>java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用<br>CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用<br>CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。<br>26、什么是线程组，为什么在 Java 中不推荐使用？<br>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程<br>的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。<br>27、为什么使用 Executor 框架比使用应用创建和管理线程好？<br>为什么要使用 Executor 线程池框架<br>1、每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗<br>时、耗资源的。<br>2、调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的<br>创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程<br>之间的频繁交替也会消耗很多系统资源。<br>3、直接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、<br>定时定期执行、线程中断等都不便实现。<br>使用 Executor 线程池框架的优点<br>1、能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开<br>销。<br>2、可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。<br>3、框架中已经有定时、定期、单线程、并发数控制等功能。<br>综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。<br>29、如何停止一个正在运行的线程？<br>使用共享变量的方式<br>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的<br>线程用来作为是否中断的信号，通知中断线程的执行。<br>使用 interrupt 方法终止线程<br>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种<br>情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用<br>Thread.join()方法，或者 Thread.sleep()方法，在网络中调用<br>ServerSocket.accept()方法，或者调用了 DatagramSocket.receive()方法时，都<br>有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程<br>的共享变量设置为 true，但该线程此时根本无法检查循环标志，当然也就无法立<br>即中断。这里我们给出的建议是，不要使用 stop()方法，而是使用 Thread 提供的<br>interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一<br>个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代<br>码。</p><p>36、SynchronizedMap 和 ConcurrentHashMap 有什么区<br>别？<br>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来<br>访为 map。<br>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。<br>ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将<br>hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。<br>这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提<br>升是显而易见的。<br>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当<br>iterator 被创建后集合再发生改变就不再是抛出<br>ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而<br>不影响原有的数据 ，iterator 完成后再将头指针替换为新的数据 ，这样 iterator<br>线程可以使用原来老的数据，而写线程也可以并发的完成改变。<br>37、CopyOnWriteArrayList 可以用于什么应用场景？<br>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这<br>个列表时，不会抛出 ConcurrentModificationException。在<br>CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保<br>留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。<br>1、由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的<br>情况下，可能导致 young gc 或者 full gc；<br>2、不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set<br>操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致<br>性,但是还是没法满足实时性要求；<br>CopyOnWriteArrayList 透露的思想<br>1、读写分离，读和写分开<br>2、最终一致性<br>3、使用另外开辟空间的思路，来解决并发冲突<br>38、什么叫线程安全？servlet 是线程安全吗?<br>线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够<br>正确地处理多个线程之间的共享变量，使程序功能正确完成。<br>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个<br>方法，是不能保证共享变量的线程安全性的。<br>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一<br>个新的 action 分配给这个请求，请求完成后销毁。<br>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。<br>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安<br>全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多<br>线程的问题。<br>39、volatile 有什么用？能否用一句话说明下 volatile 的应用<br>场景？<br>volatile 保证内存可见性和禁止指令重排。<br>volatile 用于多线程环境下的单次操作(单次读或者单次写)。<br>40、为什么代码会重排序？<br>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是<br>不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：<br>在单线程环境下不能改变程序运行的结果；<br>存在数据依赖关系的不允许重排序<br>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执<br>行语义。</p><p>48、Java 中 interrupted 和 isInterrupted 方法的区别？<br>interrupt<br>interrupt 方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监<br>视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出<br>interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状<br>态被置为“中断状态”，就会抛出中断异常。<br>interrupted<br>查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调<br>用 interrupted 则返回 true，第二次和后面的就返回 false 了。<br>isInterrupted<br>仅仅是查询当前线程的中断状态<br>49、为什么 wait 和 notify 方法要在同步块中调用？<br>Java API 强制要求这样做，如果你不这么做，你的代码会抛出<br>IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify<br>之间产生竞态条件。<br>50、为什么你应该在循环中检查等待条件?<br>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条<br>件，程序就会在没有满足结束条件的情况下退出。<br>51、Java 中的同步集合与并发集合有什么区别？<br>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发<br>集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发<br>的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像<br>ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高<br>了可扩展性。</p><p>57、Java 中 ConcurrentHashMap 的并发度是什么？<br>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安<br>全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一<br>个可选参数，默认值为 16，这样在多线程情况下就能避免争用。<br>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实<br>现,利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看<br>源码吧。</p><p>61、Java 中的 ReadWriteLock 是什么？<br>读写锁是用来提升并发程序性能的锁分离技术的成果。<br>62、volatile 变量和 atomic 变量有什么不同？<br>Volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不<br>能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子<br>性的。<br>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如<br>getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型<br>和引用变量也可以进行相似操作。</p><p>64、如何让正在运行的线程暂停一段时间？<br>我们可以使用 Thread 类的 Sleep()方法让线程暂停一段时间。需要注意的是，这<br>并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，<br>并且根据线程调度，它将得到执行。<br>65、你对线程优先级的理解是什么？<br>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，<br>但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我<br>们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线<br>程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最<br>高优先级。<br>java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级<br>有关，如非特别需要，一般无需设置线程优先级。<br>66、什么是线程调度器(Thread Scheduler)和时间分片(Time<br>Slicing )？<br>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。<br>一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。<br>同上一个问题，线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是<br>更好的选择（也就是说不要让你的程序依赖于线程的优先级）。<br>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU<br>时间可以基于线程优先级或者线程等待的时间。<br>67、你如何确保 main()方法所在的线程是 Java 程序最后结束<br>的线程？<br>我们可以使用 Thread 类的 join()方法来确保所有程序创建的线程在 main()方法退<br>出前结束。<br>71、为什么 Thread 类的 sleep()和 yield ()方法是静态的？<br>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他<br>处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静<br>态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在<br>其他非运行线程调用这些方法。<br>72、如何确保线程安全？<br>在 Java 中可以有很多方法来保证线程安全——同步，使用原子类(atomic<br>concurrent classes)，实现并发锁，使用 volatile 关键字，使用不变类和线程安<br>全类。<br>73、同步方法和同步块，哪个是更好的选择？<br>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对<br>象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通<br>常会导致他们停止执行并需要等待获得这个对象上的锁。<br>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样<br>从侧面来说也可以避免死锁。<br>74、如何创建守护线程？<br>使用 Thread 类的 setDaemon(true)方法可以将线程设置为守护线程，需要注意<br>的是，需要在调用 start()方法前调用这个方法，否则会抛出<br>IllegalThreadStateException 异常。<br>75、什么是 Java Timer 类？如何创建一个有特定时间间隔的<br>任务？<br>java.util.Timer 是一个工具类，可以用于安排一个线程在未来的某个特定时间执<br>行。Timer 类可以用安排一次性任务或者周期任务。<br>java.util.TimerTask 是一个实现了 Runnable 接口的抽象类，我们需要去继承这<br>个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。<br>Java 并发编程（二）<br>1、并发编程三要素？<br>1、原子性<br>原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操<br>作打断，要么就全部都不执行。<br>2、可见性<br>可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他<br>线程可以立即看到修改的结果。<br>3、有序性<br>有序性，即程序的执行顺序按照代码的先后顺序来执行。<br>2、实现可见性的方法有哪些？<br>synchronized 或者 Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放<br>之前把最新的值刷新到主内存，实现可见性。<br>17、什么是 Future？<br>在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不<br>管是继承 thread 类还是实现 runnable 接口，都无法保证获取到之前的执行结果。<br>通过实现 Callback 接口，并用 Future 可以来接收多线程的执行结果。<br>Future 表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加<br>Callback 以便在任务执行成功或失败后作出相应的操作。<br>18、什么是 AQS<br>AQS 是 AbustactQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步<br>工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管<br>理这个同步状态。<br>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广<br>泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如<br>ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于<br>AQS 的。<br>19、AQS 支持两种同步方式：<br>1、独占式<br>2、共享式<br>这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如<br>Semaphore，CountDownLatch，组合式的如 ReentrantReadWriteLock。总之，<br>AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。<br>20、ReadWriteLock 是什么<br>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局<br>限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在<br>读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，<br>读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。<br>因为这个，才诞生了读写锁 ReadWriteLock。ReadWriteLock 是一个读写锁接口，<br>ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写<br>的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、<br>写和写之间才会互斥，提升了读写的性能。<br>21、FutureTask 是什么<br>这个其实前面有提到过，FutureTask 表示一个异步运算的任务。FutureTask 里面<br>可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等<br>待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是<br>Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p><p>24、线程 B 怎么知道线程 A 修改了变量<br>1、volatile 修饰变量<br>2、synchronized 修饰修改变量的方法<br>3、wait&#x2F;notify<br>4、while 轮询<br>25、synchronized、volatile、CAS 比较<br>1、synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。<br>2、volatile 提供多线程共享变量可见性和禁止指令重排序优化。<br>3、CAS 是基于冲突检测的乐观锁（非阻塞）</p><p>29、多线程同步有哪几种方法？<br>Synchronized 关键字，Lock 锁实现，分布式锁等。<br>30、线程的调度策略<br>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线<br>程的运行：<br>1、线程体中调用了 yield 方法让出了对 cpu 的占用权利<br>2、线程体中调用了 sleep 方法使线程进入睡眠状态<br>3、线程由于 IO 操作受到阻塞<br>4、另外一个更高优先级线程出现<br>5）在支持时间片的系统中，该线程的时间片用完<br>31、ConcurrentHashMap 的并发度是什么<br>ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最<br>多同时可以有 16 条线程操作 ConcurrentHashMap，这也是<br>ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同<br>时有两条线程获取 Hashtable 中的数据吗？<br>32、Linux 环境下如何查找哪个线程使用 CPU 最长<br>1、获取项目的 pid，jps 或者 ps -ef | grep java，这个前面有讲过<br>2、top -H -p pid，顺序不能改变<br>33、Java 死锁以及如何避免？<br>Java 中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java 死锁情况<br>出现至少两个线程和两个或更多资源。<br>Java 发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。<br>34、死锁的原因<br>1、是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖<br>的闭环。<br>例如：线程在获得了锁 A 并且没有释放的情况下去申请锁 B，这时，另一个线程<br>已经获得了锁 B，在释放锁 B 之前又要先获得锁 A，因此闭环发生，陷入死锁循环。<br>2、默认的锁申请操作是阻塞的。<br>所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对<br>象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免<br>在一个同步方法中调用其它对象的延时方法和同步方法。</p><p>40、什么是线程调度器(Thread Scheduler)和时间分片(Time<br>Slicing)？<br>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。<br>一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分<br>片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可<br>以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所<br>以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优<br>先级）。<br>41、什么是自旋<br>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等<br>待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核<br>态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线<br>程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多<br>次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。<br>42、Java Concurrency API 中的 Lock 接口(Lock interface)<br>是什么？对比同步它有什么优势？<br>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结<br>构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>1、可以使锁更公平<br>2、可以使线程在等待锁的时候响应中断<br>3、可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>4、可以在不同的范围，以不同的顺序获取和释放锁</p><p>46、线程类的构造方法、静态块是被哪个线程调用的<br>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new<br>这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用<br>的。<br>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了<br>Thread1，main 函数中 new 了 Thread2，那么：<br>1、Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是<br>Thread2 自己调用的<br>2、Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是<br>Thread1 自己调用的<br>47、同步方法和同步块，哪个是更好的选择?<br>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代<br>码的效率。请知道一条原则：同步的范围越小越好。<br>48、Java 线程数过多会造成什么异常？<br>1、线程的生命周期开销非常高<br>2、消耗过多的 CPU 资源<br>如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空<br>闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU<br>资源时还将产生其他性能的开销。<br>3、降低稳定性<br>JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，<br>并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的<br>大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出<br>OutOfMemoryError 异常。<br>Java 面试题（一）<br>1、面向对象的特征有哪些方面？<br>答：<br>面向对象的特征主要有以下几个方面：<br> 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽<br>象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的<br>细节是什么。<br> 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类<br>被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让<br>变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要<br>手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中<br>关于桥梁模式的部分）。<br> 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问<br>只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自<br>治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写<br>一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，<br>只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，<br>明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是<br>封装得足够好的，因为几个按键就搞定了所有的事情）。<br> 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。<br>简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分<br>为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的<br>服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B<br>系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须<br>刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，<br>甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道<br>供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载<br>（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）<br>实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的<br>东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已<br>有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样<br>的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。<br>2、访问修饰符 public,private,protected,以及不写（默认）<br>时的区别？<br>答：<br>修饰符 当前类 同 包 子 类 其他包<br>public √ √ √ √<br>protecte<br>d<br>√ √ √ ×<br>default √ √ × ×<br>private √ × × ×<br>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公<br>开（public），对于不是同一个包中的其他类相当于私有（private）。受保护<br>（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私<br>有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的<br>修饰符可以是以上四种。<br>3、String 是最基本的数据类型吗？<br>答：<br>不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、<br>char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference<br>type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。<br>4、float f&#x3D;3.4;是否正确？<br>答:不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于<br>下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换<br>float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。<br>5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;<br>有错吗？<br>答：<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int<br>型，需要强制转换类型才能赋值给 short 型。而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确<br>编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short)(s1 + 1);其中有隐含的强制类型转换。<br>6、Java 有没有 goto？<br>答：<br>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 James Gosling<br>（Java 之父）编写的《The Java Programming Language》一书的附录中给出<br>了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的<br>关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意<br>义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词<br>或单词的组合都被视为保留字）<br>7、int 和 Integer 有什么区别？<br>答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本<br>数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本<br>数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，<br>从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：<br> 原始类型: boolean，char，byte，short，int，long，float，double<br> 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，<br>Double<br>class AutoUnboxingTest {<br>public static void main(String[] args) {<br>Integer a &#x3D; new Integer(3);<br>Integer b &#x3D; 3; &#x2F;&#x2F; 将 3 自动装箱成 Integer 类型<br>int c &#x3D; 3;<br>System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false 两个引用没有引用同一对<br>象<br>System.out.println(a &#x3D;&#x3D; c); &#x2F;&#x2F; true a 自动拆箱成 int 类型再和 c<br>比较<br>}<br>}<br>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：<br>public class Test03 {<br>public static void main(String[] args) {<br>Integer f1 &#x3D; 100, f2 &#x3D; 100, f3 &#x3D; 150, f4 &#x3D; 150;<br>System.out.println(f1 &#x3D;&#x3D; f2);<br>System.out.println(f3 &#x3D;&#x3D; f4);<br>}<br>}<br>如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的<br>是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，所以下面的&#x3D;&#x3D;运算比较的不<br>是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的<br>时候，会调用 Integer 类的静态方法 valueOf，如果看看 valueOf 的源代码就知<br>道发生了什么。<br>简单的说，如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer<br>对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1f4 的结果<br>是 false。<br>提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。<br>8、&amp;和&amp;&amp;的区别？<br>答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与<br>跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是<br>true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的<br>表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我<br>们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是 null 而且不<br>是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者<br>的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行<br>字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或<br>运算符（|）和短路或运算符（||）的差别也是如此。<br>补充：如果你熟悉 JavaScript，那你可能更能感受到短路运算的强大，想成为<br>JavaScript 的高手就先从玩转短路运算开始吧。<br>9、解释内存中的栈(stack)、堆(heap)和方法区(method area)<br>的用法。<br>答：<br>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的<br>现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在<br>堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收<br>集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、<br>Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都<br>是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变<br>量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”<br>hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来<br>最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM<br>的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量<br>池空间不足则会引发 OutOfMemoryError。<br>String str &#x3D; new String(“hello”);<br>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”<br>hello”这个字面量是放在方法区的。<br>补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发<br>展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一<br>定分配在堆上这件事情已经变得不那么绝对了。<br>补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求<br>常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String<br>类的 intern()方法就是这样的。<br>看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否<br>一致。<br>String s1 &#x3D; new StringBuilder(“go”)<br>.append(“od”).toString();<br>System.out.println(s1.intern() &#x3D;&#x3D; s1);<br>String s2 &#x3D; new StringBuilder(“ja”)<br>.append(“va”).toString();<br>System.out.println(s2.intern() &#x3D;&#x3D; s2);<br>10、Math.round(11.5) 等于多少？Math.round(-11.5)等于<br>多少？<br>答：<br>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五<br>入的原理是在参数上加 0.5 然后进行下取整。<br>11、switch 是否能作用在 byte 上，是否能作用在 long 上，<br>是否能作用在 String 上？<br>答：<br>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java<br>5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，<br>expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是<br>不可以的。<br>12、用最有效率的方法计算 2 乘以 8？<br>答：<br>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。<br>补充：我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代码，其<br>实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为<br>什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答案你可以自己<br>百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，从而得到更好的性<br>能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移 5<br>位相当于乘以 2 的 5 次方再减去自身就相当于乘以 31，现在的 VM 都能自动完成<br>这个优化。</p><p>13、数组有没有 length()方法？String 有没有 length()方法？<br>答：<br>数组没有 length()方法，有 length 的属性。String 有 length()方法。JavaScript<br>中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。<br>14、在 Java 中，如何跳出当前的多重嵌套循环？<br>答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中<br>支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语<br>句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，<br>因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法<br>其实不知道更好）<br>15、构造器（constructor）是否可被重写（override）？<br>答：<br>构造器不能被继承，因此不能被重写，但可以被重载。<br>16、两个对象值相同(x.equals(y) ++++&#x3D;&#x3D; true)，但却可有不同的<br>hash code，这句话对不对？<br>答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) &#x3D;&#x3D;++++ true，它们的哈希码（hash code）<br>应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个<br>对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；(2)<br>如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求<br>去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现<br>在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，<br>如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>补充：关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人也就是<br>仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，<br>《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java<br>程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍<br>equals 方法的：首先 equals 方法必须满足自反性（x.equals(x)必须返回 true）、<br>对称性（x.equals(y)返回 true 时，y.equals(x)也必须返回 true）、传递性<br>（x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true）和一<br>致性（当 x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同<br>样的返回值），而且对于任何非 null 值的引用 x，x.equals(null)必须返回 false。<br>实现高质量的 equals 方法的诀窍包括：1. 使用&#x3D;&#x3D;操作符检查”参数是否为这个<br>对象的引用”；2. 使用 instanceof 操作符检查”参数是否为正确的类型”；3. 对<br>于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完 equals<br>方法后，问自己它是否满足对称性、传递性、一致性；5. 重写 equals 时总是要<br>重写 hashCode；6. 不要将 equals 方法参数中的 Object 对象替换为其他的类型，<br>在重写时不要忘掉@Override 注解。<br>17、是否可以继承 String 类？<br>答：<br>String 类是 final 类，不可以被继承。<br>补充：继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关<br>联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。<br>18、当一个对象被当作参数传递到一个方法后，此方法可改变<br>这个对象的属性，并可返回变化后的结果，那么这里到底是值传<br>递还是引用传递？<br>答：<br>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个<br>参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调<br>用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和 C#中可以<br>通过传引用或传输出参数来改变传入的参数的值。在 C#中可以编写如下所示的代<br>码，但是在 Java 中却做不到。<br>using System;<br>namespace CS01 {<br>class Program {<br>public static void swap(ref int x, ref int y) {<br>int temp &#x3D; x;<br>x &#x3D; y;<br>y &#x3D; temp;<br>}<br>public static void Main (string[] args) {<br>int a &#x3D; 5, b &#x3D; 10;<br>swap (ref a, ref b);<br>&#x2F;&#x2F; a &#x3D; 10, b &#x3D; 5;<br>Console.WriteLine (“a &#x3D; {0}, b &#x3D; {1}”, a, b);<br>}<br>}<br>}<br>说明：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到<br>改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过<br>方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），<br>这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++转型为 Java 程序员的开<br>发者无法容忍。<br>19、String 和 StringBuilder、StringBuffer 的区别？<br>答：<br>Java 平台提供了两种类型的字符串：String 和 StringBuffer&#x2F;StringBuilder，它<br>们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的<br>字符串内容是不能被改变的。而 StringBuffer&#x2F;StringBuilder 类表示的字符串对象<br>可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方<br>法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被<br>synchronized 修饰，因此它的效率也比 StringBuffer 要高。<br>面试题 1 - 什么情况下用+运算符进行字符串连接比调用<br>StringBuffer&#x2F;StringBuilder 对象的 append 方法连接字符串性能更好？<br>面试题 2 - 请说出下面程序的输出。<br>class StringEqualTest {<br>public static void main(String[] args) {<br>String s1 &#x3D; “Programming”;<br>String s2 &#x3D; new String(“Programming”);<br>String s3 &#x3D; “Program”;<br>String s4 &#x3D; “ming”;<br>String s5 &#x3D; “Program” + “ming”;<br>String s6 &#x3D; s3 + s4;<br>System.out.println(s1 &#x3D;&#x3D; s2);<br>System.out.println(s1 &#x3D;&#x3D; s5);<br>System.out.println(s1 &#x3D;&#x3D; s6);<br>System.out.println(s1 &#x3D;&#x3D; s6.intern());<br>System.out.println(s2 &#x3D;&#x3D; s2.intern());<br>}<br>}<br>补充：解答上面的面试题需要清除两点：1. String 对象的 intern 方法会得到字符<br>串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象<br>的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加<br>到常量池中，然后返回常量池中字符串的引用；2. 字符串的+操作其本质是创建<br>了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用<br>toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class<br>命令获得 class 文件对应的 JVM 字节码指令就可以看出来。<br>20、重载（Overload）和重写（Override）的区别。重载的<br>方法能否根据返回类型进行区分？<br>答：<br>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，<br>而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同<br>的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写<br>发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返<br>回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里<br>氏代换原则）。重载对返回类型没有特殊的要求。<br>面试题：华为的面试题中曾经问过这样一个问题 - “为什么不能根据返回类型来<br>区分重载”，快说出你的答案吧！<br>21、描述一下 JVM 加载 class 文件的原理机制？<br>答：<br>JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的<br>类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件<br>中的类。<br>由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一<br>个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、<br>连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读<br>入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应<br>的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类<br>被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设<br>置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对<br>类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么<br>就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。<br>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加<br>载器（Extension）、系统加载器（System）和用户自定义类加载器<br>（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采<br>取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制<br>中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载<br>器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载<br>器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类<br>加载器的说明：<br> Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；<br> Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父<br>加载器是 Bootstrap；<br> System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的<br>类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目<br>录中记载类，是用户自定义加载器的默认父加载器。<br>22、char 型变量中能不能存贮一个中文汉字，为什么？<br>答：<br>char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择<br>任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一<br>个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。<br>补充：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM<br>内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统<br>中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节<br>流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，<br>这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程<br>序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体&#x2F;共用体）共享内<br>存的特征来实现了。<br>23、抽象类（abstract class）和接口（interface）有什么异<br>同？<br>答：<br>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如<br>果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实<br>现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中<br>可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其<br>中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、<br>public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接<br>口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而<br>抽象类未必要有抽象方法。<br>24、静态嵌套类(Static Nested Class)和内部类（Inner Class）<br>的不同？<br>答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类<br>实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起<br>来挺诡异的，如下所示。<br>面试题 - 下面的代码哪些地方会产生编译错误？<br>class Outer {<br>class Inner {}<br>public static void foo() { new Inner(); }<br>public void bar() { new Inner(); }<br>public static void main(String[] args) {<br>new Inner();<br>}<br>}<br>注意：Java 中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中 foo<br>和 main 方法都是静态方法，静态方法中没有 this，也就是说没有所谓的外部类对<br>象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样<br>做：<br>new Outer().new Inner();<br>25、Java 中会存在内存泄漏吗，请简单描述。<br>答：<br>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被<br>广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无<br>用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。例如<br>Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收<br>这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）<br>或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存<br>泄露。<br>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明<br>显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在<br>内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾<br>回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过<br>期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，<br>这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起<br>来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，<br>即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，<br>从而对性能造成重大影响，极端情况下会引发 Disk Paging（物理内存与硬盘的虚<br>拟内存交换数据），甚至造成 OutOfMemoryError。<br>26、抽象的（abstract）方法是否可同时是静态的（static）,<br>是否可同时是本地方法（native），是否可同时被 synchronized<br>修饰？<br>答：<br>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛<br>盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现<br>的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细<br>节，因此也是相互矛盾的。<br>27、阐述静态变量和实例变量的区别。<br>答：<br>静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的<br>任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷<br>贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。<br>静态变量可以实现让多个对象共享内存。<br>补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。<br>28、是否可以从一个静态（static）方法内部发出对非静态<br>（non-static）方法的调用？<br>答：<br>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在<br>调用静态方法时可能对象并没有被初始化。<br>29、如何实现对象克隆？<br>答：<br>有两种方式：<br>1). 实现 Cloneable 接口并重写 Object 类中的 clone()方法；<br>2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真<br>正的深度克隆，代码如下。<br>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛<br>型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，<br>不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对<br>象。让问题在编译的时候暴露出来总是好过把问题留到运行时。<br>31、String s &#x3D; new String(“xyz”);创建了几个字符串对象？<br>答：<br>两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。<br>32、接口是否可继承（extends）接口？抽象类是否可实现<br>（implements）接口？抽象类是否可继承具体类（concrete<br>class）？<br>答：<br>接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽<br>象类可继承具体类也可以继承抽象类。<br>33、一个”.java”源文件中是否可以包含多个类（不是内部类）？<br>有什么限制？<br>答：<br>可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和<br>公开类的类名完全保持一致。<br>34、Anonymous Inner Class(匿名内部类)是否可以继承其它<br>类？是否可以实现接口？<br>答：<br>可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来<br>实现事件监听和回调。<br>35、内部类可以引用它的包含类（外部类）的成员吗？有没有<br>什么限制？<br>答：<br>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。<br>36、Java 中的 final 关键字有哪些用法？<br>答：<br>(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变<br>量：表示变量只能一次赋值以后值不能被修改（常量）。<br>38、数据类型之间的转换：<br> 如何将字符串转换为基本数据类型？<br> 如何将基本数据类型转换为字符串？<br>答：<br> 调用基本数据类型对应的包装类中的方法 parseXXX(String)或<br>valueOf(String)即可返回相应基本类型；<br> 一种方法是将基本数据类型与空字符串（”“）连接（+）即可获得其所<br>对应的字符串；另一种方法是调用 String 类中的 valueOf()方法返回相应字符<br>串<br>39、如何实现字符串的反转及替换？<br>答：<br>方法很多，可以自己写实现也可以使用 String 或 StringBuffer&#x2F;StringBuilder 中<br>的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：<br>public static String reverse(String originStr) {<br>if(originStr &#x3D;&#x3D; null || originStr.length() &lt;&#x3D; 1)<br>return originStr;<br>return reverse(originStr.substring(1)) + originStr.charAt(0);<br>}<br>40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的<br>字符串？<br>答：<br>代码如下所示：<br>String s1 &#x3D; “你好”;<br>String s2 &#x3D; new String(s1.getBytes(“GB2312”), “ISO-8859-1”);<br>41、日期和时间：<br> 如何取得年月日、小时分钟秒？<br> 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？<br> 如何取得某月的最后一天？<br> 如何格式化日期？<br>答：<br>问题 1：创建 java.util.Calendar 实例，调用其 get()方法传入不同的参数即可获<br>得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTimel 来获取，代码<br>如下所示。<br>问题 2：以下方法均可获得该毫秒数。<br>Calendar.getInstance().getTimeInMillis();<br>System.currentTimeMillis();<br>Clock.systemDefaultZone().millis(); &#x2F;&#x2F; Java 8<br>问题 3：代码如下所示。<br>Calendar time &#x3D; Calendar.getInstance();<br>time.getActualMaximum(Calendar.DAY_OF_MONTH);<br>问题 4：利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的<br>format(Date)方法可将日期格式化。Java 8 中可以用<br>java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。<br>补充：Java 的时间日期 API 一直以来都是被诟病的东西，为了解决这一问题，Java<br>8 中引入了新的时间日期 API，其中包括 LocalDate、LocalTime、LocalDateTime、<br>Clock、Instant 等类，这些的类的设计都使用了不变模式，因此是线程安全的设<br>计。如果不理解这些内容，可以参考我的另一篇文章《关于 Java 并发编程的总结<br>和思考》。<br>43、比较一下 Java 和 JavaSciprt。<br>答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun<br>Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序<br>开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功<br>能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。<br>JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：<br> 基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发<br>简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络<br>无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和<br>事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对<br>象供设计人员使用。<br> 解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是<br>一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏<br>览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率）<br> 强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编<br>译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作<br>声明，JavaScript 的解释器在运行时检查推断其数据类型。<br> 代码格式不一样。<br>补充：上面列出的四点是网上流传的所谓的标准答案。其实 Java 和 JavaScript<br>最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势<br>是函数式语言和动态语言。在 Java 中类（class）是一等公民，而 JavaScript 中<br>函数（function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda<br>函数和闭包（closure），当然 Java 8 也开始支持函数式编程，提供了对 Lambda<br>表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的<br>语言回答会更加靠谱，不要背网上所谓的标准答案。<br>44、什么时候用断言（assert）？<br>答：<br>断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一<br>般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试<br>时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言<br>是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表<br>达式的值为 false，那么系统会报告一个 AssertionError。断言的使用如下面的代<br>码所示：<br>assert(a &gt; 0); &#x2F;&#x2F; throws an AssertionError if a &lt;&#x3D; 0<br>断言可以有两种形式：<br>assert Expression1;<br>assert Expression1 : Expression2 ;<br>Expression1 应该总是产生一个布尔值。<br>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信<br>息的字符串消息。<br>要在运行时启用断言，可以在启动 JVM 时使用-enableassertions 或者-ea 标记。<br>要在运行时选择禁用断言，可以在启动 JVM 时使用-da 或者-disableassertions<br>标记。要在系统类中启用或禁用断言，可使用-esa 或-dsa 标记。还可以在包的基<br>础上启用或者禁用断言。<br>注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某<br>些条件时阻止代码的执行，就可以考虑用断言来阻止它。<br>45、Error 和 Exception 有什么区别？<br>答：<br>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情<br>况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；<br>Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；<br>也就是说，它表示如果程序运行正常，从不会发生的情况。<br>面试题：2005 年摩托罗拉的面试中曾经问过这么一个问题“If a process reports<br>a stack overflow run-time error, what’s the most possible cause?”，给了<br>四个选项 a. lack of memory; b. write on an invalid memory space; c.<br>recursive function calling; d. array index out of boundary. Java 程序在运行<br>时也可能会遭遇 StackOverflowError，这是一个无法恢复的错误，只能重新修改<br>代码了，这个面试题的答案是 c。如果写了不能迅速收敛的递归，则很有可能引发<br>栈溢出的错误，如下所示：<br>class StackOverflowErrorTest {<br>public static void main(String[] args) {<br>main(null);<br>}<br>}<br>提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候<br>就不再继续递归）。<br>46、try{}里有一个 return 语句，那么紧跟在这个 try 后的<br>finally{}里的代码会不会被执行，什么时候被执行，在 return<br>前还是后?<br>答：<br>会执行，在方法返回调用者前执行。<br>注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try<br>中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完<br>毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改<br>后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中<br>直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升<br>编译器的语法检查级别来产生警告或错误，Eclipse 中可以在如图所示的地方进行<br>设置，强烈建议将此项设置为编译错误。<br>47、Java 语言如何进行异常处理，关键字：throws、throw、<br>try、catch、finally 分别如何使用？<br>答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了<br>良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类<br>的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，<br>调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理<br>是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况<br>下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过<br>它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用<br>来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要<br>捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个<br>方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段<br>代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语<br>句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的<br>try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这<br>种异常的 try 语句或者最终将异常抛给 JVM。<br>48、运行时异常与受检异常有何异同？<br>答：<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常<br>操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就<br>不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可<br>能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常，<br>但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对<br>象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用给出了以下指<br>导原则：<br> 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调<br>用者为了正常的控制流而使用异常）<br> 对可以恢复的情况使用受检异常，对编程错误使用运行时异常<br> 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发<br>生）<br> 优先使用标准的异常<br> 每个方法抛出的异常都要有文档<br> 保持异常的原子性<br> 不要在 catch 中忽略掉捕获到的异常<br>49、列出一些你常见的运行时异常？<br>答：<br> ArithmeticException（算术异常）<br> ClassCastException （类转换异常）<br> IllegalArgumentException （非法参数异常）<br> IndexOutOfBoundsException （下标越界异常）<br> NullPointerException （空指针异常）<br> SecurityException （安全异常）<br>51、类 ExampleA 继承 Exception，类 ExampleB 继承<br>ExampleA。<br>有如下代码片断：<br>try {<br>throw new ExampleB(“b”)<br>} catch（ExampleA e）{<br>System.out.println(“ExampleA”);<br>} catch（Exception e）{<br>System.out.println(“Exception”);<br>}<br>**请问执行此段代码的输出是什么？<br>答：<br>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，<br>抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的<br>异常）<br>52、List、Set、Map 是否继承自 Collection 接口？<br>答：<br>List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，<br>而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List<br>是线性结构的容器，适用于按数值索引访问元素的情形。<br>53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。<br>答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的<br>数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉<br>及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由<br>于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较<br>ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存<br>储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索<br>引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更<br>高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本<br>项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中<br>提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties<br>都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非<br>线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类<br>Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这<br>是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强<br>实现）。<br>补充：遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，Properties<br>是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个<br>Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中的<br>Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代码的<br>方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继承工具<br>类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或<br>Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun 公司的工<br>程师们也会犯这种低级错误，让人唏嘘不已。<br>54、Collection 和 Collections 的区别？<br>答：<br>Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个<br>工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、<br>排序、线程安全化等等。<br>55、List、Map、Set 三个接口存取元素时，各有什么特点？<br>答：<br>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的<br>equals()方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，<br>映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的<br>两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树<br>版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达<br>到排序和去重的效果。<br>56、TreeMap 和 TreeSet 在排序时如何比较元素？<br>Collections 工具类中的 sort()方法如何比较元素？<br>答：<br>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比<br>较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。<br>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元<br>素进行排序。Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入<br>的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二<br>种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是<br>Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于<br>一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对<br>回调模式的应用（Java 中对函数式编程的支持）。<br>58、线程的 sleep()方法和 yield()方法有什么区别？<br>答：<br>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的<br>线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的<br>机会；<br>② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转<br>入就绪（ready）状态；<br>③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异<br>常；<br>④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</p><p>60、请说出与线程同步以及线程调度相关的方法。<br>答：<br> wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br> sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用<br>此方法要处理 InterruptedException 异常；<br> notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并<br>不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且<br>与优先级无关；<br> notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给<br>所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；<br>提示：关于 Java 多线程和并发编程的问题，建议大家看我的另一篇文章《关于 Java<br>并发编程的总结和思考》。<br>补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活<br>性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方<br>法，同时还提供了 newCondition()方法来产生用于线程之间通信的 Condition 对<br>象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对<br>某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信<br>号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，<br>线程必须向信号量归还许可（调用 Semaphore 对象的 release()方法）。<br>下面的例子演示了 100 个线程同时向一个银行账户中存入 1 元钱，在没有使用同<br>步机制和使用同步机制情况下的执行情况。<br> 银行账户类：</p><p>在没有同步的情况下，执行结果通常是显示账户余额在 10 元以下，出现这种状况<br>的原因是，当一个线程 A 试图存入 1 元的时候，另外一个线程 B 也能够进入存款<br>的方法中，线程 B 读取到的账户余额仍然是线程 A 存入 1 元钱之前的账户余额，<br>因此也是在原来的余额 0 上面做了加 1 元的操作，同理线程 C 也会做类似的事情，<br>所以最后 100 个线程执行结束时，本来期望账户余额为 100 元，但实际得到的通<br>常在 10 元以下（很可能是 1 元哦）。解决这个问题的办法就是同步，当一个线程<br>对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行<br>操作，代码有如下几种调整方案：<br> 在银行账户的存款（deposit）方法上同步（synchronized）关键字<br> 通过 Java 5 显示的锁机制，为每个银行账户创建一个锁对象，在存款操<br>作进行加锁和解锁的操作<br>按照上述三种方式对代码进行修改后，重写执行测试代码 Test01，将看到最终的<br>账户余额为 100 元。当然也可以使用 Semaphore 或 CountdownLatch 来实现同<br>步。<br>62、synchronized 关键字的用法？<br>答：<br>synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互<br>斥访问，可以用 synchronized(对象) { … }定义同步代码块，或者在声明方法时<br>将 synchronized 作为方法的修饰符。在第 60 题的例子中已经展示了<br>synchronized 关键字的用法。<br>63、举例说明同步和异步。<br>答：<br>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正<br>在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线<br>程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好<br>的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并<br>且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异<br>步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻<br>塞式操作。<br>68、Java 中如何实现序列化，有什么意义？<br>答：<br>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流<br>化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会<br>存在数据乱序的问题）。<br>要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，<br>标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通<br>过 writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要<br>反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中<br>读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆<br>（可以参考第 29 题）。<br>69、Java 中有几种类型的流？<br>答：<br>字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承于<br>Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使<br>用方便。关于 Java 的 I&#x2F;O 需要注意的有两点：一是两种对称性（输入和输出的对<br>称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。<br>另外 Java 中的流不同于 C#的是它只有一个维度一个方向。<br>面试题 - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给<br>出了两种实现方案）<br>注意：上面用到 Java 7 的 TWR，使用 TWR 后可以不用在 finally 中释放外部资源 ，<br>从而让代码更加优雅。</p><p>73、XML 文档定义有几种形式？它们之间有何本质区别？解析<br>XML 文档有哪几种方式？<br>答：<br>XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束，其<br>本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且<br>可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。对 XML 的解析主<br>要有 DOM（文档对象模型，Document Object Model）、SAX（Simple API for<br>XML）和 StAX（Java 6 中引入的新的解析 XML 的方式，Streaming API for XML），<br>其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构占<br>用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内<br>存，适合对 XML 的随机访问（典型的用空间换取时间的策略）；SAX 是事件驱动<br>型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当<br>遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，<br>用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问；顾名思义，<br>StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程序<br>能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新<br>颖（SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐<br>个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。<br>74、你在项目中哪些地方用到了 XML？<br>答：<br>XML 的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML 将数<br>据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与<br>解压缩后再从 XML 文件中还原相关信息进行处理，XML 曾经是异构系统间交换数<br>据的事实标准，但此项功能几乎已经被 JSON（JavaScript Object Notation）取<br>而代之。当然，目前很多软件仍然使用 XML 来存储配置信息，我们在很多项目中<br>通常也会将作为配置信息的硬代码写在 XML 文件中，Java 的很多框架也是这么做<br>的，而且这些框架都选择了 dom4j 作为处理 XML 的工具，因为 Sun 公司的官方<br>API 实在不怎么好用。<br>补充：现在有很多时髦的软件（如 Sublime）已经开始将配置文件书写成 JSON<br>格式，我们已经强烈的感受到 XML 的另一项功能也将逐渐被业界抛弃。<br>75、阐述 JDBC 操作数据库的步骤。<br>答：<br>下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。<br> 加载驱动。<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);<br> 创建连接。<br>Connection con &#x3D;<br>DriverManager.getConnection(“jdbc:oracle:thin:@localhost:1521:orcl”,<br>“scott”, “tiger”);<br> 创建语句。<br>PreparedStatement ps &#x3D; con.prepareStatement(“select * from emp<br>where sal between ? and ?”);<br>ps.setInt(1, 1000);<br>ps.setInt(2, 3000);<br> 执行语句。<br>ResultSet rs &#x3D; ps.executeQuery();<br> 处理结果。<br>while(rs.next()) {<br>System.out.println(rs.getInt(“empno”) + “ - “ +<br>rs.getString(“ename”));<br>}<br> 关闭资源。<br>finally {<br>if(con !&#x3D; null) {<br>try {<br>con.close();<br>} catch (SQLException e) {<br>e.printStackTrace();<br>}<br>}<br>}<br>提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、<br>再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连<br>接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，<br>但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载<br>驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保<br>留。<br>76、Statement 和 PreparedStatement 有什么区别？哪个性<br>能更好？<br>答：<br>与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优<br>势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可<br>能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串<br>连接拼接 SQL 语句的麻烦和不安全；③当批量处理 SQL 或频繁执行相同的查询时，<br>PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的<br>SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成<br>执行计划）。<br>补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接<br>口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语<br>句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数<br>（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全<br>性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，<br>因为每种数据库的存储过程在书写上存在不少的差别。<br>77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如<br>何提升更新数据的性能？<br>答：<br>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()<br>方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能<br>可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处<br>理中执行。<br>78、在进行数据库编程时，连接池有什么作用？<br>答：<br>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每<br>次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成<br>的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连<br>接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭<br>连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间<br>的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在<br>Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的<br>开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。<br>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性<br>能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓<br>存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数<br>据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快<br>过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对<br>于这个问题的讨论已经超出了这里要阐述的范围。<br>79、什么是 DAO 模式？<br>答：<br>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了<br>抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访<br>问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在<br>一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应<br>用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交<br>互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该<br>类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 Data<br>Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访<br>问数据的问题，而后者要解决的是如何用对象封装数据。<br>80、事务的 ACID 是指什么？<br>答：<br> 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作<br>的失败都会导致整个事务的失败；<br> 一致性(Consistent)：事务结束后系统状态是一致的；<br> 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态；<br> 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难<br>性的失败。通过日志和同步备份可以在故障发生后重建数据。<br>补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。<br>首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一<br>数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻<br>读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类丢失更新）。<br>脏读（Dirty Read）：A 事务读取 B 事务尚未提交的数据并在此基础上操作，而 B<br>事务执行回滚，那么 A 读取到的数据就是脏数据。<br>时间 转账事务 A 取款事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 查询账户余额为 1000 元<br>T4 取出 500 元余额修改为 500<br>元<br>T5 查询账户余额为 500 元（脏读）<br>T6 撤销事务余额恢复为 1000 元<br>T7 汇入 100 元把余额修改为 600<br>元<br>T8 提交事务<br>不可重复读（Unrepeatable Read）：事务 A 重新读取前面读取过的数据，发现<br>该数据已经被另一个已提交的事务 B 修改过了。<br>时间 转账事务 A 取款事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 查询账户余额为 1000 元<br>T4 查询账户余额为 1000 元<br>T5 取出 100 元修改余额为 900<br>元<br>T6 提交事务<br>T7 查询账户余额为 900 元（不可重复读）<br>幻读（Phantom Read）：事务 A 重新执行一个查询，返回一系列符合查询条件<br>的行，发现其中插入了被事务 B 提交的行。<br>时间 统计金额事务 A 转账事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 统计总存款为 10000 元<br>T4 新增一个存款账户存入 100<br>元<br>T5 提交事务<br>T6 再次统计总存款为 10100 元（幻读）<br>第 1 类丢失更新：事务 A 撤销时，把已经提交的事务 B 的更新数据覆盖了。<br>时间 取款事务 A 转账事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 查询账户余额为 1000 元<br>T4 查询账户余额为 1000 元<br>T5 汇入 100 元修改余额为 1100<br>元<br>T6 提交事务<br>T7 取出 100 元将余额修改为 900 元<br>T8 撤销事务<br>T9 余额恢复为 1000 元（丢失更新）<br>第 2 类丢失更新：事务 A 覆盖事务 B 已经提交的数据，造成事务 B 所做的操作丢<br>失。<br>时间 转账事务 A 取款事务 B<br>T1 开始事务<br>T2 开始事务<br>T3 查询账户余额为 1000 元<br>T4 查询账户余额为 1000 元<br>T5 取出 100 元将余额修改为 900<br>元<br>T6 提交事务<br>T7 汇入 100 元将余额修改为 1100 元<br>T8 提交事务<br>T9 查询账户余额为 1100 元（丢失更新）<br>数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能<br>就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不<br>同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具<br>体的内容大家可以自行查阅资料进行了解。<br>直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定<br>会话的事务隔离级别，数据库就会通过分析 SQL 语句然后为事务访问的资源加上<br>合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对<br>用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI&#x2F;ISO<br>SQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示：<br>隔离级别 脏读 不可重复读 幻读 第一类丢失更新 第二类丢失更新<br>READ<br>UNCOMMITED<br>允许 允许 允许 不允许 允许<br>READ<br>COMMITTED<br>不允许 允许 允许 不允许 允许<br>REPEATABLE<br>READ<br>不允许 不允许 允许 不允许 不允许<br>SERIALIZABLE 不允许 不允许 不允许 不允许 不允许<br>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高<br>并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没<br>有万能的原则。<br>**81、JDBC 中如何进行事务处理？<br>答：<br>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置<br>手动提交事务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中<br>发生异常则通过 rollback()进行事务回滚。除此之外，从 JDBC 3.0 中还引入了<br>Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保<br>存点。<br>82、JDBC 能否处理 Blob 和 Clob？<br>答：<br>Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象<br>（Character Large Objec），因此其中 Blob 是为存储大的二进制数据而设计的，<br>而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和<br>ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。下面的代码展示了如<br>何使用 JDBC 操作 LOB：<br>下面以 MySQL 数据库为例，创建一个张有三个字段的用户表，包括编号（id）、<br>姓名（name）和照片（photo），建表语句如下：<br>create table tb_user<br>(<br>id int primary key auto_increment,<br>name varchar(20) unique not null,<br>photo longblob<br>);<br>下面的 Java 代码向数据库中插入一条记录：</p><p>83、简述正则表达式及其用途。<br>答：<br>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。<br>正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本<br>规则的代码。<br>说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用<br>计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符<br>串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支<br>持。<br>84、Java 中是如何支持正则表达式操作的？<br>答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、<br>replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则<br>表达式对象，它提供了丰富的 API 进行各种正则表达式操作，请参考下面面试题<br>的代码。<br>面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京<br>市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;<br>class RegExpTest {<br>public static void main(String[] args) {<br>String str &#x3D; “北京市(朝阳区)(西城区)(海淀区)”;<br>Pattern p &#x3D; Pattern.compile(“.*?(?&#x3D;\()”);<br>Matcher m &#x3D; p.matcher(str);<br>if(m.find()) {<br>System.out.println(m.group());<br>}<br>}<br>}<br>说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐<br>读一下网上很有名的《正则表达式 30 分钟入门教程》。<br>85、获得一个类的类对象有哪些方式？<br>答：<br> 方法 1：类型.class，例如：String.class<br> 方法 2：对象.getClass()，例如：”hello”.getClass()<br> 方法 3：Class.forName()，例如：Class.forName(“java.lang.String”)<br>**86、如何通过反射创建对象？<br>答：<br> 方法 1：通过类对象调用 newInstance()方法，例如：<br>String.class.newInstance()<br> 方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()<br>方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象，<br>例如：String.class.getConstructor(String.class).newInstance(“Hello”);<br>**87、如何通过反射获取和设置对象私有字段的值？<br>答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段<br>对象的 setAccessible(true)将其设置为可以访问，接下来就可以通过 get&#x2F;set 方<br>法来获取&#x2F;设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静<br>态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类<br>型且支持多级对象操作，例如 ReflectionUtil.get(dog, “owner.car.engine.id”);<br>可以获得 dog 对象的主人的汽车的引擎的 ID 号。</p><p>88、如何通过反射调用对象的方法？<br>答：<br>请看下面的代码：<br>import java.lang.reflect.Method;<br>class MethodInvokeTest {<br>public static void main(String[] args) throws Exception {<br>String str &#x3D; “hello”;<br>Method m &#x3D; str.getClass().getMethod(“toUpperCase”);<br>System.out.println(m.invoke(str)); &#x2F;&#x2F; HELLO<br>}<br>}<br>**89、简述一下面向对象的”六原则一法则”。<br>答：<br> 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”<br>高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝<br>典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一<br>个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，<br>而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我<br>们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那<br>么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单<br>一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基<br>本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速<br>器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定<br>是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模<br>块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）<br> 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，<br>当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类<br>就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关<br>键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系<br>统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系<br>统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》<br>一书中对桥梁模式的讲解的章节。）<br> 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方<br>法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不<br>用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里<br>氏替换原则。）<br>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的<br>描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父<br>类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如<br>果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对<br>代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都<br>是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：<br>子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更<br>多，把能力多的对象当成能力少的对象来用当然没有任何问题。）<br> 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的<br>污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高<br>度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口<br>中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，<br>毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现<br>几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能<br>力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）<br> 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复<br>用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例<br>外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，<br>Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关<br>联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是<br>Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关<br>系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在<br>Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable<br>类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在<br>Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符<br>串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来<br>存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，<br>而不是拿来继承的。）<br> 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有<br>尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和<br>调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你<br>去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对<br>这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要<br>做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。<br>再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控<br>制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所<br>知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可<br>以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡<br>各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，<br>计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它<br>将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统<br>的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人<br>打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）<br>92、什么是 UML？<br>答：<br>UML 是统一建模语言（Unified Modeling Language）的缩写，它发表于 1997<br>年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型<br>化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支<br>持。使用 UML 可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系<br>统的结构和行为。<br>93、UML 中有哪些常用的图？<br>答：<br>UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结<br>构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence<br>diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、<br>活动图（activity diagram）、构件图（component diagram）、部署图（deployment<br>diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来<br>捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、<br>类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描<br>述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能<br>接收的消息也就是说对象能够向外界提供的服务）。<br>用例图：<br>类图：<br>时序图：<br>1、Java 中能创建 volatile 数组吗？<br>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不<br>是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，<br>但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护<br>作用了。<br>2、volatile 能使得一个非原子操作变成原子操作吗？<br>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量<br>会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？<br>因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正<br>在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。<br>但是对一个 volatile 型的 long 或 double 变量的读写是原子。<br>3、volatile 修饰符的有过什么实践？<br>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。<br>double 和 long 都是 64 位宽，因此对这两种类型的读是分为两部分的，第一次<br>读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中<br>volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个<br>作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的<br>说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write<br>barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意<br>思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，<br>在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其<br>他所有写的值更新到缓存。<br>4、volatile 类型变量提供什么保证？<br>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT 为了获得更好的性能<br>会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会<br>与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的<br>修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位<br>数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和<br>long 就是原子的。<br>5、10 个线程和 2 个线程的同步代码，哪个更容易写？<br>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互<br>独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的<br>竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。<br>6、你是如何调用 wait（）方法的？使用 if 块还是循环？为什<br>么？<br>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条<br>件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段<br>标准的使用 wait 和 notify 方法的代码：<br>&#x2F;&#x2F; The standard idiom for using the wait method<br>synchronized (obj) {<br>while (condition does not hold)<br>obj.wait(); &#x2F;&#x2F; (Releases lock, and reacquires on wakeup)<br>… &#x2F;&#x2F; Perform action appropriate to condition<br>}<br>参见 [Effective Java]第 69 条，获取更多关于为什么应该在循环中来调用 wait<br>方法的内容。<br>###7、什么是多线程环境下的伪共享（false sharing）？<br>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问<br>题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如<br>下图所示：<br>有经验程序员的 Java 面试题<br>伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧<br>在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审<br>查代码，根据缓存行来调整你的数据结构。<br>8、什么是 Busy spin？我们为什么要使用它？<br>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢<br>失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。<br>所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可<br>以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的<br>好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个<br>高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概<br>念实现的，使用 busy spin 循环 EventProcessors 等待屏障。<br>9、Java 中怎么获取一份线程 dump 文件？<br>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java<br>应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这<br>样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在<br>控制台或者日志文件中，具体位置依赖应用的配置。如果你使用 Tomcat。<br>10、Swing 是线程安全的？<br>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如<br>JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。<br>这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其<br>他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以<br>一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学<br>习到更详细的内容。<br>11、什么是线程局部变量？<br>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共<br>享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方<br>式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，<br>在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线<br>程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。<br>12、用 wait-notify 写一段代码来解决生产者-消费者问题？<br>答案<br>请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如<br>果阻塞，通过循环来测试等待条件。<br>15、什么是不可变对象（immutable object）？Java 中怎么<br>创建一个不可变对象？<br>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的<br>对象，如 String、Integer 及其它包装类。详情参见答案，一步一步指导你在 Java<br>中创建一个不可变的类。<br>16、我们能创建一个包含可变对象的不可变对象吗？<br>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，<br>不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。<br>最常见的例子就是对象中包含一个日期对象的引用。<br>数据类型和 Java 基础面试问题<br>17、Java 中应该使用什么数据类型来代表价格？<br>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的<br>double 类型。<br>18、怎么将 byte 转换为 String？<br>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用<br>的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也<br>可能不同。<br>19、Java 中怎样将 bytes 转换为 long 类型？<br>这个问题你来回答 :-)<br>20、我们能将 int 强制转换为 byte 类型的变量吗？如果该值<br>大于 byte 类型的范围，将会出现什么现象？<br>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位<br>的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围<br>是从 -128 到 128。<br>21、存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为<br>C 么？如 C &#x3D; (C) B；<br>答案<br>ss-interface-example.html<br>22、哪个类包含 clone 方法？是 Cloneable 还是 Object？<br>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在<br>object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由<br>c 或 c++ 或 其他本地语言实现的。<br>23、Java 中 ++ 操作符是线程安全的吗？<br>答案：不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存<br>储回内存，这个过程可能会出现多个线程交差。<br>23、不是线程安全的操作。它涉及到多个指令，如读取变量值，<br>增加，然后存储回内存，这个过程可能会出现多个线程交差。<br>24、a &#x3D; a + b 与 a +&#x3D; b 的区别<br>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相<br>加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法<br>操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是<br>a +&#x3D; b 没问题，如下：<br>byte a &#x3D; 127;<br>byte b &#x3D; 127;<br>b &#x3D; a + b; &#x2F;&#x2F; error : cannot convert from int to byte<br>b +&#x3D; a; &#x2F;&#x2F; ok<br>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会<br>报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte<br>就会编译出错）<br>25、我能在不进行强制转换的情况下将一个 double 值赋值给<br>long 类型的变量吗？<br>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型<br>的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。<br>26、3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？<br>false，因为有些浮点数不能完全精确的表示出来。<br>27、int 和 Integer 哪个会占用更多的内存？<br>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。<br>但是 int 是一个原始类型的数据，所以占用的空间更少。<br>28、为什么 Java 中的 String 是不可变的（Immutable）？<br>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字<br>符串设置为不可变可以允许多个客户端之间共享相同的字符串。<br>29、我们能在 Switch 中使用 String 吗？<br>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法<br>糖。内部实现在 switch 中使用字符串的 hash code。<br>30、Java 中的构造器链是什么？<br>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在<br>重载了类的构造器的时候才会出现。<br>JVM 底层 与 GC（Garbage Collection） 的面试问题<br>31、64 位 JVM 中，int 的长度是多数？<br>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就<br>是说，在 32 位 和 64 位 的 Java 虚拟机中，int 类型的长度是相同的。<br>32、Serial 与 Parallel GC 之间的不同之处？<br>Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要<br>不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而<br>parallel 收集器使用多个 GC 线程来执行。<br>33、32 位和 64 位的 JVM，int 类型变量的长度是多数？<br>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4<br>个字节。<br>34、Java 中 WeakReference 与 SoftReference 的区别？<br>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，<br>但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用<br>虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。<br>35、WeakHashMap 是怎么工作的？<br>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，<br>意思就是当 key 对象没有任何引用时，key&#x2F;value 将会被回收。<br>36、JVM 选项 -XX:+UseCompressedOops 有什么作用？<br>为什么要使用？<br>当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从<br>32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU<br>缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM<br>主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过<br>-XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位<br>的 OOP。<br>37、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64<br>位？<br>你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。<br>38、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？<br>理论上说上 32 位的 JVM 堆内存可以到达 2&#x3D;&#x3D;&#x3D;&#x3D;^32，即 4GB，但实际上会比这个<br>小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约<br>3GB。64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^&#x3D;&#x3D;&#x3D;&#x3D;64，这是一个非<br>常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，<br>堆内存到 1000G 都是可能的。<br>39、JRE、JDK、JVM 及 JIT 之间有什么不同？<br>JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代<br>表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java<br>编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它<br>的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当<br>代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主<br>要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。<br>3 年工作经验的 Java 面试题<br>40、解释 Java 堆空间及 GC？<br>当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于<br>创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内<br>部的一个进程，回收无效对象的内存用于将来的分配。<br>JVM 底层面试题及答案<br>41、你能保证 GC 执行吗？<br>不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC<br>的执行。<br>42、怎么获取 Java 程序使用的内存？堆使用的百分比？<br>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及<br>最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。<br>Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory()<br>方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。<br>43、Java 中堆和栈有什么区别？<br>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局<br>部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，<br>而堆被整个 JVM 的所有线程共享。<br>关于内存的的面试问题和答案<br>Java 基本概念面试题<br>44、“a&#x3D;&#x3D;b”和”a.equals(b)”有什么区别？<br>如果 a 和 b 都是对象，则 a&#x3D;&#x3D;b 是比较两个对象的引用，只有当 a 和 b 指<br>向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以<br>通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方<br>法，所以可以用于两个不同对象，但是包含的字母相同的比较。<br>45、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？<br>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，<br>如 Hashtable、HashMap、LinkedHashMap 等等。它与 equals() 方法关系特<br>别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有<br>相同的 hash code。<br>46、final、finalize 和 finally 的不同之处？<br>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该<br>变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，<br>给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally<br>是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，<br>无论在 try 块中是否有发生异常。<br>47、Java 中的编译期常量是什么？使用它又什么风险？<br>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里<br>的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些<br>变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你<br>使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改<br>变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了<br>避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。<br>Java 集合框架的面试题<br>这部分也包含数据结构、算法及数组的面试问题<br>48、List、Set、Map 和 Queue 之间的区别(答案)<br>List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量<br>访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。<br>49、poll() 方法和 remove() 方法的区别？<br>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败<br>的时候会返回空，但是 remove() 失败的时候会抛出异常。<br>50、Java 中 LinkedHashMap 和 PriorityQueue 的区别是<br>什么？<br>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是<br>LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue<br>时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺<br>序。<br>51、ArrayList 与 LinkedList 的不区别？<br>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而<br>LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，<br>ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见<br>答案。<br>52、用哪两种方式来实现集合的排序？<br>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，<br>如 list，然后通过 Collections.sort() 来排序。<br>53、Java 中怎么打印数组？<br>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由<br>于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println()<br>方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。<br>54、Java 中的 LinkedList 是单向链表还是双向链表？<br>是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，<br>直接在编辑器中打开该类。<br>55、Java 中的 TreeMap 是采用什么树实现的？(答案)<br>Java 中的 TreeMap 是使用红黑树实现的。<br>56、Hashtable 与 HashMap 有什么不同之处？<br>这两个类有许多不同的地方，下面列出了一部分：<br>a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。<br>b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。<br>c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。<br>更多的不同之处参见答案。<br>57、Java 中的 HashSet，内部是如何工作的？<br>HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以<br>所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的<br>key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。<br>58、写一段代码在遍历 ArrayList 时移除一个元素？<br>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的<br>remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移<br>除元素，而不会出现 ConcurrentModificationException 异常的示例代码。<br>59、我们能自己写一个容器类，然后使用 for-each 循环码？<br>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，<br>你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。<br>60、ArrayList 和 HashMap 的默认大小是多数？<br>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是<br>16 个元素（必须是 2 的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的<br>代码片段：<br>&#x2F;&#x2F; from ArrayList.java JDK 1.7<br>private static final int DEFAULT_CAPACITY &#x3D; 10;<br>&#x2F;&#x2F;from HashMap.java JDK 7<br>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16<br>61、有没有可能两个不相等的对象有有相同的 hashcode？<br>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在<br>hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必<br>须有相同的 hashcode 值，但是没有关于不相等对象的任何规定。<br>62、两个相同的对象会有不同的的 hash code 吗？<br>不能，根据 hash code 的规定，这是不可能的。<br>63、我们可以在 hashcode() 中使用随机数字吗？<br>答案<br>ple.html<br>不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中<br>重写 hashCode() 方法的知识。<br>64、Java 中，Comparator 与 Comparable 有什么不同？<br>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户<br>定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义<br>对象的顺序。<br>65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？(答案)<br>因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，<br>如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。<br>Java IO 和 NIO 的面试题<br>IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以<br>及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。<br>66、在我 Java 程序中，我有三个 socket，我需要多少个线<br>程来处理？<br>67、Java 中怎么创建 ByteBuffer？<br>byte[] bytes &#x3D; new byte[10];<br>ByteBuffer buf &#x3D; ByteBuffer.wrap(bytes);<br>68、Java 中，怎么读写 ByteBuffer ？<br>69、Java 采用的是大端还是小端？<br>70、ByteBuffer 中的字节序是什么？<br>71、Java 中，直接缓冲区与非直接缓冲器有什么区别？<br>答案<br>72、Java 中的内存映射缓存区是什么？<br>答案<br>ava.html<br>73、socket 选项 TCP NO DELAY 是指什么？<br>74、TCP 协议与 UDP 协议有什么区别？<br>答案<br>-udp-protocol.html<br>75、Java 中，ByteBuffer 与 StringBuffer 有什么区别？(答<br>案)<br>Java 最佳实践的面试问题<br>包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常<br>处理，设计模式等等。<br>76、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？<br>这是我在写 Java 并发程序的时候遵循的一些最佳实践：<br>a）给线程命名，这样可以帮助调试。<br>b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。<br>c）如果可以，更偏向于使用 volatile 而不是 synchronized。<br>d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通<br>信，如 BlockingQueue，CountDownLatch 及 Semeaphore。<br>e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。<br>77、说出几点 Java 中使用 Collections 的最佳实践<br>这是我在使用 Java 中 Collectionc 类的一些最佳实践：<br>a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是<br>Vector。<br>b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。<br>c）使用接口代表和访问集合，如使用 List 存储 ArrayList，使用 Map 存储<br>HashMap 等等。<br>d）使用迭代器来循环集合。<br>e）使用集合的时候使用泛型。<br>78、说出至少 5 点在 Java 中使用线程的最佳实践。<br>答案<br>gthread-in-java.html<br>这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：<br>a）对线程命名<br>b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。<br>c）使用线程池<br>79、说出 5 条 IO 的最佳实践(答案)<br>IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上<br>避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：<br>a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。<br>b）使用 NIO 和 NIO2<br>c）在 finally 块中关闭流，或者使用 try-with-resource 语句。<br>d）使用内存映射文件获取更快的 IO。<br>80、列出 5 个应该遵循的 JDBC 最佳实践<br>答案<br>ava.html))<br>有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：<br>a）使用批量的操作来插入和更新数据<br>b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。<br>c）使用数据库连接池<br>d）通过列名来获取结果集，不要使用列的下标来获取。<br>81、说出几条 Java 中方法重载的最佳实践？<br>下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。<br>a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参<br>数。<br>b）不要重载参数数量一致，而只是参数顺序不同的方法。<br>c）如果重载的方法参数个数多于 5 个，采用可变参数。<br>Date、Time 及 Calendar 的面试题<br>82、在多线程环境下，SimpleDateFormat 是线程安全的吗？<br>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是<br>线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中<br>使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，<br>在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、<br>时间处理的所有实践来说，我强力推荐 joda-time 库。<br>83、Java 中如何格式化一个日期？如格式化为 ddMMyyyy<br>的形式？<br>答案<br>dateformat.html<br>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。<br>DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代<br>码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。<br>84、Java 中，怎么在格式化的日期中显示时区？<br>答案<br>85、Java 中 java.util.Date 与 java.sql.Date 有什么区别？<br>答案<br>86、Java 中，如何计算两个日期之间的差距？<br>程序<br>87、Java 中，如何将字符串 YYYYMMDD 转换为日期？<br>答案<br>hreading.html<br>单元测试 JUnit 面试题<br>89、如何测试静态方法？(答案)<br>可以使用 PowerMock 库来测试静态方法。<br>90、怎么利用 JUnit 来测试一个方法的异常？<br>答案<br>91、你使用过哪个单元测试库来测试你的 Java 程序？<br>92、@Before 和 @BeforeClass 有什么区别？<br>答案<br>编程和代码相关的面试题<br>93、怎么检查一个字符串只包含数字？解决方案<br>mbers-in-String.html<br>94、Java 中如何利用泛型写一个 LRU 缓存？<br>95、写一段 Java 程序将 byte 转换为 long？<br>95、在不使用 StringBuffer 的前提下，怎么反转一个字符串？<br>解决方案<br>buffer-stringbuilder.htm<br>97、Java 中，怎么获取一个文件中单词出现的最高频率？<br>解决方案<br>ds-and-count.html<br>98、如何检查出两个给定的字符串是反序的？<br>解决方案<br>tring-are-anagrams-example-tutorial.html<br>99、Java 中，怎么打印出一个字符串的所有排列？<br>解决方案<br>100、Java 中，怎样才能打印出数组中的重复元素？<br>解决方案<br>ents-in-array-java.html<br>101、Java 中如何将字符串转换为整数？<br>String s&#x3D;”123”;<br>int i;<br>第一种方法：i&#x3D;Integer.parseInt(s);<br>第二种方法：i&#x3D;Integer.valueOf(s).intValue();<br>102、在没有使用临时变量的情况如何交换两个整数变量的值？<br>解决方案<br>关于 OOP 和设计模式的面试题<br>这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，<br>接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。<br>也包含了 GOF 设计模式的问题。<br>103、接口是什么？为什么要使用接口而不是直接使用具体类？<br>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，<br>因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机<br>访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写<br>代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这<br>种方法是具体的。<br>104、Java 中，抽象类与接口之间有什么不同？<br>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个<br>类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类<br>的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。<br>105、除了单例模式，你在生产环境中还用过什么设计模式？<br>这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰<br>模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的<br>基于你选择的模式的问题。<br>106、你能解释一下里氏替换原则吗?<br>答案<br>迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。<br>108、适配器模式是什么？什么时候使用？<br>适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一<br>些接口，你就可以写一个适配去来连接这些接口。<br>109、什么是“依赖注入”和“控制反转”？为什么有人使用？<br>控制反转（IOC）是 Spring 框架的核心思想，用我自己的话说，就是你要做一件<br>事，别自己可劲 new 了，你就说你要干啥，然后外包出去就好~<br>依赖注入（DI） 在我浅薄的想法中，就是通过接口的引用和构造方法的表达，将<br>一些事情整好了反过来传给需要用到的地方~<br>110、抽象类是什么？它与接口有什么区别？你为什么要使用过<br>抽象类？<br>接口用于规范，抽象类用于共性.<br>声明方法的存在而不去实现它的类被叫做抽象类<br>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。<br>111、构造器注入和 setter 依赖注入，那种方式更好？<br>每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是<br>setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，<br>Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使<br>用 setter 注入。<br>112、依赖注入和工程模式之间有什么不同？<br>虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式<br>更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获<br>取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用<br>工厂模式更容易测试。<br>113、适配器模式和装饰器模式有什么区别？<br>虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配<br>器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加<br>新的功能。<br>114、适配器模式和代理模式之前有什么不同？<br>这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由<br>于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是<br>适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便<br>支持分配、控制或智能访问。<br>115、什么是模板方法模式？<br>模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序<br>算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用<br>Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方<br>法就是众所周知的模板方法。<br>116、什么时候使用访问者模式？<br>访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模<br>式采用双派发的形式来增加中间层。<br>117、什么时候使用组合模式？<br>组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式<br>来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采<br>用组合模式。<br>118、继承和组合之间有什么不同？<br>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行<br>时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。<br>119、描述 Java 中的重载和重写？<br>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，<br>而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方<br>法。重写必须要有继承。<br>120、Java 中，嵌套公共静态类与顶级类有什么不同？<br>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公<br>共类，并且顶级公共类的名称与源文件名称必须一致。<br>121、 OOP 中的 组合、聚合和关联有什么区别？<br>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中<br>的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一<br>个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B<br>组合的，则 A 不存在的话，B 一定不存在，但是如果 A 对象聚合了一个对象 B，<br>则即使 A 不存在了，B 也可以单独存在。<br>122、给我一个符合开闭原则的设计模式的例子？<br>开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增<br>加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代<br>码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策<br>略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是<br>Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的<br>对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。<br>123、抽象工厂模式和原型模式之间的区别？<br>抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方<br>法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产<br>品。当要切换为另一个系列的产品，换一个工厂类即可。<br>原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同<br>样复杂的工厂类的继承体系。我们可以把工厂类中的工厂方法放到产品类自身之<br>中吗？如果这样的话，就可以将两个继承体系为一个。这也就是原型模式的思想，<br>原型模式中的工厂方法为 clone，它会返回一个拷贝（可以是浅拷贝，也可以是深<br>拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用 clone 来动<br>态绑定地生成所需的具体的类。这些原型对象必须事先构造好。<br>原型模式想对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。<br>124、什么时候使用享元模式？<br>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保<br>你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池<br>以及 Long 池都是很好的使用了享元模式的例子。<br>Java 面试中其他各式各样的问题<br>这部分包含 Java 中关于 XML 的面试题，正则表达式面试题，Java 错误和异常<br>及序列化面试题<br>125、嵌套静态类与顶级类有什么区别？<br>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个<br>嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如<br>HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry 是一个嵌<br>套静态类。<br>126、你能写出一个正则表达式来判断一个字符串是否是一个数<br>字吗？<br>一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，<br>你可以下一个如下的正则表达式来判断给定的字符串是不是数字。<br>首先要 import java.util.regex.Pattern 和 java.util.regex.Matcher<br>public boolean isNumeric(String str){<br>Pattern pattern &#x3D; Pattern.compile(“[0-9]*“);<br>Matcher isNum &#x3D; pattern.matcher(str);<br>if( !isNum.matches() ){<br>return false;<br>}<br>return true;<br>}<br>127、Java 中，受检查异常 和 不受检查异常的区别？<br>受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过<br>throws 子句声明。其中一种情况是 Exception 的子类但不是<br>RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶<br>段不受编译器的检查。<br>128、Java 中，throw 和 throws 有什么区别<br>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通<br>过关键字 throw 抛出一个 Error 或者 一个 Exception，如：<br>throw new IllegalArgumentException(“size must be multiple of 2″ )<br>而 throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便<br>调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。<br>129、Java 中，Serializable 与 Externalizable 的区别？<br>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输<br>或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、<br>脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进<br>制格式，增加安全机制。<br>130、Java 中，DOM 和 SAX 解析器有什么不同？<br>DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以<br>更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，<br>不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要<br>求更多的内存，不适合于解析大 XML 文件。<br>131、说出 JDK 1.7 中的三个新特性？<br>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，<br>如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关<br>闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。<br>允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需<br>要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一<br>个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。<br>132、说出 5 个 JDK 1.8 引入的新特性？<br>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。<br>133、Java 中，Maven 和 ANT 有什么区别？<br>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，<br>在基于“约定优于配置”的概念下，提供标准的 Java 项目结构，同时能为应用自<br>动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之<br>处请参见答案。<br>这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的<br>所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，<br>这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也<br>没有包含主流的框架如 Spring MVC，Struts 2.0，Hibernate，也没有包含 SOAP<br>和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web<br>开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基<br>础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了<br>的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建<br>一份最新的、最优的 Java 面试问题列表。<br>3.1、什么是 spring bean？<br> 它们是构成用户应用程序主干的对象。<br> Bean 由 Spring IoC 容器管理。<br> 它们由 Spring IoC 容器实例化，配置，装配和管理。<br> Bean 是基于用户提供给容器的配置元数据创建。</p><p>5、数据访问<br>5.1、spring DAO 有什么用？<br>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一<br>种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写<br>代码时，无需考虑捕获每种技术不同的异常。<br>5.2、列举 Spring DAO 抛出的异常。<br>5.3、spring JDBC API 中存在哪些类？<br> JdbcTemplate<br> SimpleJdbcTemplate<br> NamedParameterJdbcTemplate<br> SimpleJdbcInsert<br> SimpleJdbcCall<br>5.4、使用 Spring 访问 Hibernate 的方法有哪些？<br>我们可以通过两种方式使用 Spring 访问 Hibernate：<br>1、 使用 Hibernate 模板和回调进行控制反转<br>2、 扩展 HibernateDAOSupport 并应用 AOP 拦截器节点<br>5.5、列举 spring 支持的事务管理类型<br>Spring 支持两种类型的事务管理：<br>1、 程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大<br>的灵活性，但维护起来非常困难。<br>2、 声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML<br>的配置来管理事务。</p><p>4、核心容器（应用上下文) 模块。<br>这是基本的 Spring 模块，提供 spring 框架的基础功能，BeanFactory 是 任何<br>以 spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使 Spring 成<br>为一个容器。<br>5、BeanFactory – BeanFactory 实现举例。<br>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依<br>赖从正真的应用代码中分离。<br>最常用的 BeanFactory 实现是 XmlBeanFactory 类。<br>6、XMLBeanFactory<br>最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory ，它<br>根据 XML 文件中的定义加载 beans。该容器从 XML 文件读取配置元数据并用它<br>去创建一个完全配置的系统或应用。</p><p>8、解释 JDBC 抽象和 DAO 模块。<br>通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源<br>错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一<br>的异常访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务<br>管理服务。<br>9、解释对象&#x2F;关系映射集成模块。<br>Spring 通过提供 ORM 模块，支持我们在直接 JDBC 之上使用一个对象&#x2F;关系映射<br>映射(ORM)工具，Spring 支持集成主流的 ORM 框架，如 Hiberate,JDO 和 iBATIS<br>SQL Maps。Spring 的事务管理同样支持以上所有 ORM 框架及 JDBC。<br>10、解释 WEB 模块。<br>Spring 的 WEB 模块是构建在 application context 模块基础之上，提供一个适<br>合 web 应用的上下文。这个模块也包括支持多种面向 web 的任务，如透明地处理<br>多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对 Jakarta<br>Struts 的支持。</p><p>15、ApplicationContext 通常的实现是什么?<br> FileSystemXmlApplicationContext ：此容器从一个 XML 文件中加<br>载 beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。<br> ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加<br>载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath<br>里找 bean 配置。<br> WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定<br>义了一个 WEB 应用的所有 bean。<br>23、如何给 Spring 容器提供配置元数据?<br>这里有三种重要的方法给 Spring 容器提供配置元数据。<br>XML 配置文件。<br>基于注解的配置。<br>基于 java 的配置。<br>24、你怎样定义类的作用域?<br>当定义一个 在 Spring 里，我们还能给这个 bean 声明一个作用域。它可以通过<br>bean 定义中的 scope 属性来定义。如，当 Spring 要在需要的时候每次生产一个<br>新的 bean 实例，bean 的 scope 属性被指定为 prototype。另一方面，一个 bean<br>每次使用的时候必须返回同一个实例，这个 bean 的 scope 属性 必须设为<br>singleton。<br>28、哪些是重要的 bean 生命周期方法？你能重载它们吗？<br>有两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean<br>的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。<br>The bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们<br>你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和<br>@PreDestroy）。<br>30、在 Spring 中如何注入一个 java 集合？<br>Spring 提供以下几种集合的配置元素：<br> 类型用于注入一列值，允许有相同的值。<br> 类型用于注入一组值，不允许有相同的值。<br> 类型用于注入一组键值对，键和值都可以为任意类型。<br> 类型用于注入一组键值对，键和值都只能为 String 类型。</p><p>35、你可以在 Spring 中注入一个 null 和一个空字符串吗？<br>可以。<br>Spring 注解<br>36、什么是基于 Java 的 Spring 注解配置? 给一些注解的例子.<br>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring<br>配置而非通过 XML 文件。<br>以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被<br>Spring IOC 容器使用。另一个例子是@Bean 注解，它表示此方法将要返回一个<br>对象，作为一个 bean 注册进 Spring 应用上下文。<br>37、什么是基于注解的容器配置?<br>相对于 XML 文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号<br>的声明。<br>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，<br>而不是使用 xml 表述 bean 的装配关系。</p><p>42.在 Spring 框架中如何更有效地使用 JDBC?<br>使用 SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只<br>需写 statements 和 queries 从数据存取数据，JDBC 也可以在 Spring 框架提供<br>的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate （例子见这里<br>here）<br>43、JdbcTemplate<br>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据<br>类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处<br>理。<br>44、Spring 对 DAO 的支持<br>Spring 对数据访问对象（DAO）的支持旨在简化它和数据访问技术如 JDBC，<br>Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心<br>会捕获每种技术特有的异常。<br>45、使用 Spring 通过什么方式访问 Hibernate?<br>在 Spring 中有两种方式访问 Hibernate：<br> 控制反转 Hibernate Template 和 Callback。<br> 继承 HibernateDAOSupport 提供一个 AOP 拦截器。<br>46、Spring 支持的 ORM<br>Spring 支持以下 ORM：<br> Hibernate<br> iBatis<br> JPA (Java Persistence API)<br> TopLink<br> JDO (Java Data Objects)<br> OJB<br>47.如何通过HibernateDaoSupport将Spring和Hibernate<br>结合起来？<br>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<br> 配置 the Hibernate SessionFactory。<br> 继承 HibernateDaoSupport 实现一个 DAO。<br> 在 AOP 支持的事务中装配。</p><p>49、Spring 框架的事务管理有哪些优点？<br> 它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供<br>一个不变的编程模式。<br> 它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API<br>如<br> 它支持声明式事务管理。<br> 它和 Spring 各种数据访问抽象层很好得集成。<br>50、你更倾向用那种事务管理类型？<br>大多数 Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，<br>因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务<br>管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵<br>活性。</p><p>微服务 面试题<br>1、您对微服务有何了解？<br>微服务，又称微服务 架构，是一种架构风格，它将应用程序构建为以业务领域为<br>模型的小型自治服务集合 。<br>通俗地说，你必须看到蜜蜂如何通过对齐六角形蜡细胞来构建它们的蜂窝状物。<br>他们最初从使用各种材料的小部分开始，并继续从中构建一个大型蜂箱。这些细<br>胞形成图案，产生坚固的结构，将蜂窝的特定部分固定在一起。这里，每个细胞<br>独立于另一个细胞，但它也与其他细胞相关。这意味着对一个细胞的损害不会损<br>害其他细胞，因此，蜜蜂可以在不影响完整蜂箱的情况下重建这些细胞。<br>图 1：微服务的蜂窝表示 – 微服务访谈问题<br>请参考上图。这里，每个六边形形状代表单独的服务组件。与蜜蜂的工作类似，<br>每个敏捷团队都使用可用的框架和所选的技术堆栈构建单独的服务组件。就像在<br>蜂箱中一样，每个服务组件形成一个强大的微服务架构，以提供更好的可扩展性。<br>此外，敏捷团队可以单独处理每个服务组件的问题，而对整个应用程序没有影响<br>或影响最小。<br>2、微服务架构有哪些优势？<br>图 2：微服务的 优点 – 微服务访谈问题<br> 独立开发 – 所有微服务都可以根据各自的功能轻松开发<br> 独立部署 – 基于其服务，可以在任何应用程序中单独部署它们<br> 故障隔离 – 即使应用程序的一项服务不起作用，系统仍可继续运行<br> 混合技术堆栈 – 可以使用不同的语言和技术来构建同一应用程序的不同<br>服务<br> 粒度缩放 – 单个组件可根据需要进行缩放，无需将所有组件缩放在一起<br>3。微服务有哪些特点？<br>图 3：微服务的 特点 – 微服务访谈问题<br> 解耦 – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻<br>松构建，更改和扩展<br> 组件化 – 微服务被视为可以轻松更换和升级的独立组件<br> 业务能力 – 微服务非常简单，专注于单一功能<br> 自治 – 开发人员和团队可以彼此独立工作，从而提高速度<br> 持续交付 – 通过软件创建，测试和批准的系统自动化，允许频繁发布软<br>件<br> 责任 – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他<br>们负责的产品<br> 分散治理 – 重点是使用正确的工具来做正确的工作。这意味着没有标准<br>化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题<br> 敏捷 – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃<br>4、设计微服务的最佳实践是什么？<br>以下是设计微服务的最佳实践：<br>图 4：设计微服务的最佳实践 – 微服务访谈问题<br>5、微服务架构如何运作？<br>微服务架构具有以下组件：<br>图 5：微服务 架构 – 微服务面试问题<br> 客户端 – 来自不同设备的不同用户发送请求。<br> 身份提供商 – 验证用户或客户身份并颁发安全令牌。<br> API 网关 – 处理客户端请求。<br> 静态内容 – 容纳系统的所有内容。<br> 管理 – 在节点上平衡服务并识别故障。<br> 服务发现 – 查找微服务之间通信路径的指南。<br> 内容交付网络 – 代理服务器及其数据中心的分布式网络。<br> 远程服务 – 启用驻留在 IT 设备网络上的远程访问信息。<br>6、微服务架构的优缺点是什么？<br>7、单片，SOA 和微服务架构有什么区别？<br>图 6： 单片 SOA 和微服务之间的比较 – 微服务访谈问题<br> 单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密<br>封装。<br> 一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数<br>据传递，也可以涉及两个或多个协调某些活动的服务。<br> 微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型<br>自治服务集合。<br>8、在使用微服务架构时，您面临哪些挑战？<br>开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。<br> 自动化组件：难以自动化，因为有许多较小的组件。因此，对于每个组件，<br>我们必须遵循 Build，Deploy 和 Monitor 的各个阶段。<br> 易感性：将大量组件维护在一起变得难以部署，维护，监控和识别问题。<br>它需要在所有组件周围具有很好的感知能力。<br> 配置管理：有时在各种环境中维护组件的配置变得困难。<br> 调试：很难找到错误的每一项服务。维护集中式日志记录和仪表板以调试<br>问题至关重要。<br>9、SOA 和微服务架构之间的主要区别是什么？<br>SOA 和微服务之间的主要区别如下：<br>10、微服务有什么特点？<br>您可以列出微服务的特征，如下所示：<br>图 7：微服务的特征 – 微服务访谈问题<br>11、什么是领域驱动设计？<br>图 8： DDD 原理 – 微服务面试问题<br>12、为什么需要域驱动设计（DDD）？<br>图 9：我们需要 DDD 的因素 – 微服务面试问题<br>13、什么是无所不在的语言？<br>如果您必须定义泛在语言（UL），那么它是特定域的开发人员和用户使用的通用<br>语言，通过该语言可以轻松解释域。<br>无处不在的语言必须非常清晰，以便它将所有团队成员放在同一页面上，并以机<br>器可以理解的方式进行翻译。<br>14、什么是凝聚力？<br>模块内部元素所属的程度被认为是凝聚力。<br>15、什么是耦合？<br>组件之间依赖关系强度的度量被认为是耦合。一个好的设计总是被认为具有高内<br>聚力和低耦合性。<br>16、什么是 REST &#x2F; RESTful 以及它的用途是什么？<br>Representational State Transfer（REST）&#x2F; RESTful Web 服务是一种帮助计<br>算机系统通过 Internet 进行通信的架构风格。这使得微服务更容易理解和实现。<br>微服务可以使用或不使用 RESTful API 实现，但使用 RESTful API 构建松散耦合<br>的微服务总是更容易。<br>17、你对 Spring Boot 有什么了解？<br>事实上，随着新功能的增加，弹簧变得越来越复杂。如果必须启动新的 spring 项<br>目，则必须添加构建路径或添加 maven 依赖项，配置应用程序服务器，添加 spring<br>配置。所以一切都必须从头开始。<br>Spring Boot 是解决这个问题的方法。使用 spring boot 可以避免所有样板代码<br>和配置。因此，基本上认为自己就好像你正在烘烤蛋糕一样，春天就像制作蛋糕<br>所需的成分一样，弹簧靴就是你手中的完整蛋糕。<br>图 10： Spring Boot 的因素 – 微服务面试问题<br>18、什么是 Spring 引导的执行器？<br>Spring Boot 执行程序提供了 restful Web 服务，以访问生产环境中运行应用程序<br>的当前状态。在执行器的帮助下，您可以检查各种指标并监控您的应用程序。<br>19、什么是 Spring Cloud？<br>根据 Spring Cloud 的官方网站，Spring Cloud 为开发人员提供了快速构建分布<br>式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，<br>领导选举，分布式会话，集群状态）。<br>20、Spring Cloud 解决了哪些问题？<br>在使用 Spring Boot 开发分布式微服务时，我们面临的问题很少由 Spring Cloud<br>解决。<br> 与分布式系统相关的复杂性 – 包括网络问题，延迟开销，带宽问题，安<br>全问题。<br> 处理服务发现的能力 – 服务发现允许集群中的进程和服务找到彼此并进<br>行通信。<br> 解决冗余问题 – 冗余问题经常发生在分布式系统中。<br> 负载平衡 – 改进跨多个计算资源（例如计算机集群，网络链接，中央处<br>理单元）的工作负载分布。<br> 减少性能问题 – 减少因各种操作开销导致的性能问题。<br>21、在 Spring MVC 应用程序中使用 WebMvcTest 注释有什<br>么用处？<br>在测试目标只关注 Spring MVC 组件的情况下，WebMvcTest 注释用于单元测试<br>Spring MVC 应用程序。在上面显示的快照中，我们只想启动 ToTestController。<br>执行此单元测试时，不会启动所有其他控制器和映射。<br>22。你能否给出关于休息和微服务的要点？<br>虽然您可以通过多种方式实现微服务，但 REST over HTTP 是实现微服务的一种<br>方式。REST 还可用于其他应用程序，如 Web 应用程序，API 设计和 MVC 应用程<br>序，以提供业务数据。<br>微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件<br>可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用<br>程序。<br>简而言之，您可以说 REST 是构建微服务的媒介。<br>23、什么是不同类型的微服务测试？<br>在使用微服务时，由于有多个微服务协同工作，测试变得非常复杂。因此，测试<br>分为不同的级别。<br> 在底层，我们有面向技术的测试，如单元测试和性能测试。这些是完全自<br>动化的。<br> 在中间层面，我们进行了诸如压力测试和可用性测试之类的探索性测试。<br> 在顶层， 我们的 验收测试数量很少。这些验收测试有助于利益相关者理<br>解和验证软件功能。<br>24、您对 Distributed Transaction 有何了解？<br>分布式事务是指单个事件导致两个或多个不能以原子方式提交的单独数据源的突<br>变的任何情况。在微服务的世界中，它变得更加复杂，因为每个服务都是一个工<br>作单元，并且大多数时候多个服务必须协同工作才能使业务成功。<br>25、什么是 Idempotence 以及它在哪里使用？<br>幂等性是能够以这样的方式做两次事情的特性，即最终结果将保持不变，即好像<br>它只做了一次。<br>用法：在远程服务或数据源中使用 Idempotence，这样当它多次接收指令时，它<br>只处理指令一次。<br>26、什么是有界上下文？<br>有界上下文是域驱动设计的核心模式。DDD 战略设计部门的重点是处理大型模型<br>和团队。DDD 通过将大型模型划分为不同的有界上下文并明确其相互关系来处理<br>大型模型。<br>27、什么是双因素身份验证？<br>双因素身份验证为帐户登录过程启用第二级身份验证。<br>图 11： 双因素认证的表示 – 微服务访谈问题<br>因此，假设用户必须只输入用户名和密码，那么这被认为是单因素身份验证。<br>28、双因素身份验证的凭据类型有哪些？<br>这三种凭证是：<br>图 12： 双因素认证的证书类型 – 微服务面试问题<br>29、什么是客户证书？<br>客户端系统用于向远程服务器发出经过身份验证的请求的一种数字证书称为客户<br>端证书。客户端证书在许多相互认证设计中起着非常重要的作用，为请求者的身<br>份提供了强有力的保证。<br>30、PACT 在微服务架构中的用途是什么？<br>PACT 是一个开源工具，允许测试服务提供者和消费者之间的交互，与合同隔离，<br>从而提高微服务集成的可靠性。<br>微服务中的用法<br> 用于在微服务中实现消费者驱动的合同。<br> 测试微服务的消费者和提供者之间的消费者驱动的合同。<br>查看即将到来的批次<br>31、什么是 OAuth？<br>OAuth 代表开放授权协议。这允许通过在 HTTP 服务上启用客户端应用程序（例<br>如第三方提供商 Facebook，GitHub 等）来访问资源所有者的资源。因此，您可<br>以在不使用其凭据的情况下与另一个站点共享存储在一个站点上的资源。<br>32、康威定律是什么？<br>“任何 设计 系统 的组 织（ 广泛 定义 ）都 将产 生一 种设 计， 其结 构是 组织 通信 结构<br>的副 本。” – Mel Conway<br>图 13： Conway 定律的表示 – 微服务访谈问题<br>该法律基本上试图传达这样一个事实：为了使软件模块起作用，整个团队应该进<br>行良好的沟通。因此，系统的结构反映了产生它的组织的社会边界。<br>33、合同测试你懂什么？<br>根据 Martin Flower 的说法，合同测试是在外部服务边界进行的测试，用于验证<br>其是否符合消费服务预期的合同。<br>此外，合同测试不会深入测试服务的行为。更确切地说，它测试该服务调用的输<br>入＆输出包含所需的属性和所述响应延迟，吞吐量是允许的限度内。<br>34、什么是端到端微服务测试？<br>端到端测试验证了工作流中的每个流程都正常运行。这可确保系统作为一个整体<br>协同工作并满足所有要求。<br>通俗地说，你可以说端到端测试是一种测试，在特定时期后测试所有东西。<br>图 14：测试层次 – 微服务面试问题<br>35、Container 在微服务中的用途是什么？<br>容器是管理基于微服务的应用程序以便单独开发和部署它们的好方法。您可以将<br>微服务封装在容器映像及其依赖项中，然后可以使用它来滚动按需实例的微服务，<br>而无需任何额外的工作。<br>图 15： 容器的表示及其在微服务中的使用方式 – 微服务访谈问题<br>36、什么是微服务架构中的 DRY？<br>DRY 代表不要重复自己。它基本上促进了重用代码的概念。这导致开发和共享库，<br>这反过来导致紧密耦合。<br>37、什么是消费者驱动的合同（CDC）？<br>这基本上是用于开发微服务的模式，以便它们可以被外部系统使用。当我们处理<br>微服务时，有一个特定的提供者构建它，并且有一个或多个使用微服务的消费者。<br>通常，提供程序在 XML 文档中指定接口。但在消费者驱动的合同中，每个服务消<br>费者都传达了提供商期望的接口。<br>38、Web，RESTful API 在微服务中的作用是什么？<br>微服务架构基于一个概念，其中所有服务应该能够彼此交互以构建业务功能。因<br>此，要实现这一点，每个微服务必须具有接口。这使得 Web API 成为微服务的一<br>个非常重要的推动者。RESTful API 基于 Web 的开放网络原则，为构建微服务架<br>构的各个组件之间的接口提供了最合理的模型。<br>39、您对微服务架构中的语义监控有何了解？<br>语义监控，也称为 综合监控， 将自动化测试与监控应用程序相结合，以检测业<br>务失败因素。<br>40、我们如何进行跨功能测试？<br>跨功能测试是对非功能性需求的验证，即那些无法像普通功能那样实现的需求。<br>41、我们如何在测试中消除非决定论？<br>非确定性测试（NDT）基本上是不可靠的测试。所以，有时可能会发生它们通过，<br>显然有时它们也可能会失败。当它们失败时，它们会重新运行通过。<br>从测试中删除非确定性的一些方法如下：<br>1、 隔离<br>2、 异步<br>3、 远程服务<br>4、 隔离<br>5、 时间<br>6、 资源泄漏<br>42、Mock 或 Stub 有什么区别？<br>存根<br> 一个有助于运行测试的虚拟对象。<br> 在某些可以硬编码的条件下提供固定行为。<br> 永远不会测试存根的任何其他行为。<br>例如，对于空堆栈，您可以创建一个只为 empty（）方法返回 true 的存根。因此，<br>这并不关心堆栈中是否存在元素。<br>嘲笑<br> 一个虚拟对象，其中最初设置了某些属性。<br> 此对象的行为取决于 set 属性。<br> 也可以测试对象的行为。<br>例如，对于 Customer 对象，您可以通过设置名称和年龄来模拟它。您可以将 age<br>设置为 12，然后测试 isAdult（）方法，该方法将在年龄大于 18 时返回 true。因<br>此，您的 Mock Customer 对象适用于指定的条件。<br>43、您对 Mike Cohn 的测试金字塔了解多少？<br>Mike Cohn 提供了一个名为 Test Pyramid 的模型。这描述了软件开发所需的自<br>动化测试类型。<br>图 16： Mike Cohn 的测试金字塔 – 微服务面试问题<br>根据金字塔，第一层的测试数量应该最高。在服务层，测试次数应小于单元测试<br>级别，但应大于端到端级别。<br>44、Docker 的目的是什么？<br>Docker 提供了一个可用于托管任何应用程序的容器环境。在此，软件应用程序和<br>支持它的依赖项紧密打包在一起。<br>因此，这个打包的产品被称为 Container，因为它是由 Docker 完成的，所以它<br>被称为 Docker 容器！<br>45、什么是金丝雀释放？<br>Canary Releasing 是一种降低在生产中引入新软件版本的风险的技术。这是通过<br>将变更缓慢地推广到一小部分用户，然后将其发布到整个基础架构，即将其提供<br>给每个人来完成的。<br>46、什么是持续集成（CI）？<br>持续集成（CI）是每次团队成员提交版本控制更改时自动构建和测试代码的过程。<br>这鼓励开发人员通过在每个小任务完成后将更改合并到共享版本控制存储库来共<br>享代码和单元测试。<br>47、什么是持续监测？<br>持续监控深入监控覆盖范围，从浏览器内前端性能指标，到应用程序性能，再到<br>主机虚拟化基础架构指标。<br>48、架构师在微服务架构中的角色是什么？<br>微服务架构中的架构师扮演以下角色：<br> 决定整个软件系统的布局。<br> 帮助确定组件的分区。因此，他们确保组件相互粘合，但不紧密耦合。<br> 与开发人员共同编写代码，了解日常生活中面临的挑战。<br> 为开发微服务的团队提供某些工具和技术的建议。<br> 提供技术治理，以便技术开发团队遵循微服务原则。<br>49、我们可以用微服务创建状态机吗？<br>我们知道拥有自己的数据库的每个微服务都是一个可独立部署的程序单元，这反<br>过来又让我们可以创建一个状态机。因此，我们可以为特定的微服务指定不同的<br>状态和事件。<br>例如，我们可以定义 Order 微服务。订单可以具有不同的状态。Order 状态的转<br>换可以是 Order 微服务中的独立事件。<br>50、什么是微服务中的反应性扩展？<br>Reactive Extensions 也称为 Rx。这是一种设计方法，我们通过调用多个服务来<br>收集结果，然后编译组合响应。这些调用可以是同步或异步，阻塞或非阻塞。Rx<br>是分布式系统中非常流行的工具，与传统流程相反。<br>希望 这些 微服 务面 试问 题可 以帮 助您 进行 微服 务架 构师 访谈 。<br>翻译来源：<br>w-questions&#x2F;<br>Linux 面试题<br>1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？<br>主目录用什么表示? 切换目录用什么命令？<br>答案：<br>绝对路径： 如&#x2F;etc&#x2F;init.d<br>当前目录和上层目录： .&#x2F; ..&#x2F;<br>主目录： ~&#x2F;<br>切换目录： cd<br>2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？<br>答案：<br>查看当前进程： ps<br>执行退出： exit<br>查看当前路径： pwd<br>3、怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当<br>前用户 id？查看指定帮助用什么命令？<br>答案：<br>清屏： clear<br>退出当前命令： ctrl+c 彻底退出<br>执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台<br>查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组<br>及用户名<br>查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser –help 这<br>个告诉你一些常用参数； info adduesr；<br>4、Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？<br>答案：<br>ls 执行的功能： 列出指定目录中的目录，以及文件<br>哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行<br>的权限等<br>5、建立软链接(快捷方式)，以及硬链接的命令。<br>答案：<br>软链接： ln -s slink source<br>硬链接： ln link source<br>6、目录创建用什么命令？创建文件用什么命令？复制文件用什<br>么命令？<br>答案：<br>创建目录： mkdir<br>创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件<br>输出，都会创建文件<br>复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？<br>文件权限修改： chmod<br>格式如下：<br>chmodu+xfile 给 file 的属主增加执行权限 chmod 751 file 给 file 的属主分配<br>读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户<br>分配执行(1)的权限<br>chmodu&#x3D;rwx,g&#x3D;rx,o&#x3D;xfile 上例的另一种形式 chmod &#x3D;r file 为所有用户分配<br>读权限<br>chmod444file 同上例 chmod a-wx,a+r file 同上例<br><code>$chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属 主分配读的权限 7、查看文件内容有哪些命令可以使用？ 答案： vi 文件名 #编辑方式查看，可修改 cat 文件名 #显示全部文件内容 more 文件名 #分页显示文件内容 less 文件名 #与 more 相似，更好的是可以往前翻页 tail 文件名 #仅查看尾部，还可以指定行数 head 文件名 #仅查看头部,还可以指定行数 8、随意写文件命令？怎么向屏幕输出带空格的字符串，比如” hello world”? 答案： 写文件命令：vi 向屏幕输出带空格的字符串:echo hello world 9、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下 的哪个命令？ 答案： 终端 /dev/tty 黑洞文件 /dev/null 10、移动文件用哪个命令？改名用哪个命令？ 答案： mv mv 11、复制文件用哪个命令？如果需要连同文件夹一块复制呢？ 如果需要有提示功能呢？ 答案： cp cp -r ？？？？ 12、删除文件用哪个命令？如果需要连目录及目录下文件一块 删除呢？删除空文件夹用什么命令？ 答案： rm rm -r rmdir 13、Linux 下命令有哪几种可使用的通配符？分别代表什么含 义? 答案： “？”可替代单个字符。 “*”可替代任意多个字符。 方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC] 14、用什么命令对一个文件的内容进行统计？(行号、单词数、 字节数) 答案： wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。 15、Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含 该串的行? 答案： 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印 出来。 grep [stringSTRING] filename grep [^string] filename 16、Linux 中进程有哪几种状态？在 ps 显示出来的信息中， 分别用什么符号表示的？ 答案： 1、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。 2、暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而 进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个 特殊的状态。 正被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。 3、就绪状态：在 run_queue 队列里的状态 4、运行状态：在 run_queue 队列里的状态 5、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起 6、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程 的尸体（task_struct）也释放掉 7、退出状态 D 不可中断 Uninterruptible（usually IO） R 正在运行，或在队列中的进程 S 处于休眠状态 T 停止或被追踪 Z 僵尸进程 W 进入内存交换（从内核 2.6 开始无效） X 死掉的进程 17、怎么使一个命令在后台运行? 答案： 一般都是使用 &amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格) 18、利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进 程的信息？ 答案： ps -ef (system v 输出) ps -aux bsd 格式输出 ps -ef | grep pid 19、哪个命令专门用来查看后台任务? 答案： job -l 20、把后台任务调到前台执行使用什么命令?把停下的后台任务 在后台执行起来用什么命令? 答案： 把后台任务调到前台执行 fg 把停下的后台任务在后台执行起来 bg 21、终止进程用什么命令? 带什么参数? 答案： kill [-s &amp;lt;信息名称或编号&amp;gt;][程序] 或 kill [-l &amp;lt;信息编号&amp;gt;] kill-9 pid 22、怎么查看系统支持的所有信号？ 答案： kill -l 23、搜索文件用什么命令? 格式是怎么样的? 答案： find &amp;lt;指定目录&amp;gt; &amp;lt;指定条件&amp;gt; &amp;lt;指定动作&amp;gt; whereis 加参数与文件名 locate 只加文件名 find 直接搜索磁盘，较慢。 find / -name &quot;string*&quot; 24、查看当前谁在使用该主机用什么命令? 查找自己所在的终 端信息用什么命令? 答案： 查找自己所在的终端信息：who am i 查看当前谁在使用该主机：who 25、使用什么命令查看用过的命令列表? 答案： history 26、使用什么命令查看磁盘使用空间？ 空闲空间呢? 答案： df -hl 文件系统 容量 已用 可用 已用% 挂载点 Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% / /dev/hda1 494M 19M 450M 4% /boot 27、使用什么命令查看网络是否连通? 答案： netstat 28、使用什么命令查看 ip 地址及接口信息？ 答案： ifconfig 29、查看各类环境变量用什么命令? 答案： 查看所有 env 查看某个，如 home： env$</code>HOME<br>30、通过什么命令指定命令提示符?<br>答案：<br> \u：显示当前用户账号<br> \h：显示当前主机名<br> \W：只显示当前路径最后一个目录<br> \w：显示当前绝对路径（当前用户目录会以~代替）<br> <code>$PWD：显示当前全路径  $</code>：显示命令行’<code>$&#39;或者’#&#39;符号  #：下达的第几个命令  \d：代表日期，格式为 week day month date，例如：&quot;MonAug1&quot;  \t：显示时间为 24 小时格式，如：HH：MM：SS  \T：显示时间为 12 小时格式  \A：显示时间为 24 小时格式：HH：MM  \v：BASH 的版本信息 如 export PS1=’[\u@\h\w#]$</code>‘<br>31、查找命令的可执行文件是去哪查找的? 怎么对其进行设置<br>及添加?<br>答案：<br>whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…]<br>补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性<br>应属于原始代码，二进制文件，或是帮助文件。<br> -b 只查找二进制文件。<br> -B &lt;目录&gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的<br>路径名称。<br> -m 只查找说明文件。<br> -M &lt;目录&gt; 只在设置的目录下查找说明文件。-s 只查找原始代码文件。<br> -S &lt;目录&gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定<br>类型的文件。<br>w -h ich 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且<br>返回第一个搜索结果。<br> -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件<br>名。<br> -p 与-n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位<br>的宽度。<br> -V 显示版本信息<br>32、通过什么命令查找执行命令?<br>答案：<br>which 只能查可执行文件<br>whereis 只能查二进制文件、说明文档，源文件等<br>33、怎么对命令进行取别名？<br>答案：<br>alias la&#x3D;’ls -a’<br>34、du 和 df 的定义，以及区别？<br>答案：<br>du 显示目录或文件的大小<br>df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。<br>（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘<br>分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，<br>通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df<br>命令则查看文件系统的磁盘分配图并考虑 Meta Data。<br>df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。<br>35、awk 详解。<br>答案：<br>awk ‘{pattern + action}’ {filenames}<br>#cat &#x2F;etc&#x2F;passwd |awk -F ‘:’ ‘{print 1”\t”7}’ &#x2F;&#x2F;-F 的意思是以’:’分隔 root<br>&#x2F;bin&#x2F;bash<br>daemon &#x2F;bin&#x2F;sh 搜索&#x2F;etc&#x2F;passwd 有 root 关键字的所有行<br>#awk -F: ‘&#x2F;root&#x2F;‘ &#x2F;etc&#x2F;passwd root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<br>36、当你需要给命令绑定一个宏或者按键的时候，应该怎么做<br>呢？<br>答案：<br>可以使用 bind 命令，bind 可以很方便地在 shell 中实现宏或按键的绑定。<br>在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。<br>比如获取 F12 的字符序列获取方法如下：先按下 Ctrl+V,然后按下 F12 .我们就可<br>以得到 F12 的字符序列 ^[[24<del>。<br>接着使用 bind 进行绑定。<br>[root@localhost ~]# bind ‘”\e[24</del>“:”date”‘<br>注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。<br>【附】也可以使用 showkey -a 命令查看按键对应的字符序列。<br>37、如果一个 linux 新手想要知道当前系统支持的所有命令的<br>列表，他需要怎么做？<br>答案：<br>使用命令 compgen -c，可以打印出所有支持的命令列表。<br>[root@localhost ~]$ compgen -c<br>l.<br>ll<br>ls<br>which<br>if<br>then<br>else<br>elif<br>fi<br>case<br>esac<br>for<br>select<br>while<br>until<br>do<br>done<br>…<br>38、如果你的助手想要打印出当前的目录栈，你会建议他怎么<br>做？<br>答案：<br>使用 Linux 命令 dirs 可以将当前的目录栈打印出来。<br>[root@localhost ~]# dirs<br>&#x2F;usr&#x2F;share&#x2F;X11<br>【附】：目录栈通过 pushd popd 来操作。<br>39、你的系统目前有许多正在运行的任务，在不重启机器的条<br>件下，有什么方法可以把所有正在运行的进程移除呢？<br>答案：<br>使用 linux 命令 ’disown -r ’可以将所有正在运行的进程移除。<br>40、bash shell 中的 hash 命令有什么作用？<br>答案：<br>linux 命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径,<br>用该命令可以打印出你所使用过的命令以及执行的次数。<br>[root@localhost ~]# hash<br>hits command<br>2 &#x2F;bin&#x2F;ls<br>2 &#x2F;bin&#x2F;su<br>41、哪一个 bash 内置命令能够进行数学运算。<br>答案：<br>bash shell 的内置命令 let 可以进行整型数的数学运算。<br>#! &#x2F;bin&#x2F;bash<br>…<br>…<br>let c&#x3D;a+b<br>…<br>…<br>42、怎样一页一页地查看一个大文件的内容呢？<br>答案：<br>通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个<br>需要.<br>[root@localhost ~]# cat file_name.txt | more<br>43、数据字典属于哪一个用户的？<br>答案：<br>数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动<br>创建的<br>44、怎样查看一个 linux 命令的概要与用法？假设你在&#x2F;bin 目<br>录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用<br>和用法呢？<br>答案：<br>使用命令 whatis 可以先出显示出这个命令的用法简要，比如，你可以使用 whatis<br>zcat 去查看‘zcat’的介绍以及使用简要。<br>[root@localhost ~]# whatis zcat<br>zcat [gzip] (1) – compress or expand files<br>45、使用哪一个命令可以查看自己文件系统的磁盘空间配额<br>呢？<br>答案：<br>使用命令 repquota 能够显示出一个文件系统的配额信息<br>【附】只有 root 用户才能够查看其它用户的配额。<br>Spring Boot 面试题<br>1、什么是 Spring Boot？<br>多年来，随着新功能的增加，spring 变得越来越复杂。只需访问<br>所有 Spring 项目的不同功能。如果必须启动一个新的 Spring 项目，我们必须添<br>加构建路径或添加 Maven 依赖关系，配置应用程序服务器，添加 spring 配置。<br>因此，开始一个新的 spring 项目需要很多努力，因为我们现在必须从头开始做所<br>有事情。<br>Spring Boot 是解决这个问题的方法。Spring Boot 已经建立在现有 spring 框架<br>之上。使用 spring 启动，我们避免了之前我们必须做的所有样板代码和配置。因<br>此，Spring Boot 可以帮助我们以最少的工作量，更加健壮地使用现有的 Spring<br>功能。<br>2、Spring Boot 有哪些优点？<br>Spring Boot 的优点有：<br>1、减少开发，测试时间和努力。<br>2、使用 JavaConfig 有助于避免使用 XML。<br>3、避免大量的 Maven 导入和各种版本冲突。<br>4、提供意见发展方法。<br>5、通过提供默认值快速开始开发。<br>6、没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish<br>或其他任何东西。<br>7、需要更少的配置 因为没有 web.xml 文件。只需添加用@ Configuration 注释<br>的类，然后添加用@Bean 注释的方法，Spring 将自动加载对象并像以前一样对其<br>进行管理。您甚至可以将@Autowired 添加到 bean 方法中，以使 Spring 自动装<br>入需要的依赖关系中。<br>8、基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：<br>-Dspring.profiles.active &#x3D; {enviornment}。在加载主应用程序属性文件后，<br>Spring 将在（application{environment} .properties）中加载后续的应用程序属<br>性文件。<br>3、什么是 JavaConfig？<br>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯<br>Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：<br>1、面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分<br>利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方<br>法等。<br>2、减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，<br>许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供<br>了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，<br>只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将<br>JavaConfig 与 XML 混合匹配是理想的。<br>3、类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring<br>容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不<br>需要任何强制转换或基于字符串的查找。<br>4、如何重新加载 Spring Boot 上的更改，而无需重新启动服务<br>器？<br>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式<br>tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于<br>提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部<br>署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，<br>而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布<br>它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完<br>全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制<br>台以更好地测试应用程序。<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;<br>&lt;optional&gt;true&lt;&#x2F;optional&gt;<br>5、Spring Boot 中的监视器是什么？<br>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视<br>器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在<br>生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向<br>相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的<br>REST 端点来检查状态。<br>6、如何在 Spring Boot 中禁用 Actuator 端点安全性？<br>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用<br>户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实<br>施的。 我们可以使用<br>来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。<br>7、如何在自定义端口上运行 Spring Boot 应用程序？<br>为了在自定义端口上运行 Spring Boot 应用程序，您可以在<br>application.properties 中指定端口。<br>server.port &#x3D; 8090<br>8、什么是 YAML？<br>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。<br>与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加<br>结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。<br>9、如何实现 Spring Boot 应用程序的安全性？<br>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖<br>项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展<br>WebSecurityConfigurerAdapter 并覆盖其方法。<br>10、如何集成 Spring Boot 和 ActiveMQ？<br>对于集成 Spring Boot 和 ActiveMQ，我们使用<br>依赖关系。 它只需要很少的配置，并且不需要样板代码。<br>11、如何使用 Spring Boot 实现分页和排序？<br>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页<br>的<br>传递给存储库方法。<br>12、什么是 Swagger？你用 Spring Boot 实现了它吗？<br>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。<br>Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实<br>现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消<br>费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger<br>消除了调用服务时的猜测。<br>13、什么是 Spring Profiles？<br>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因<br>此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION<br>中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环<br>境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用<br>配置文件非常简单。<br>14、什么是 Spring Batch？<br>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包<br>括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。<br>它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量<br>和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式<br>利用框架处理重要大量的信息。<br>15、什么是 FreeMarker 模板？<br>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动<br>态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员<br>可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用<br>freemarker 可以将这些结合起来，给出最终的输出页面。<br>16、如何使用 Spring Boot 实现异常处理？<br>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通<br>过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。<br>17、您使用了哪些 starter maven 依赖项？<br>使用了下面的一些依赖项<br>spring-boot-starter-activemq<br>spring-boot-starter-security<br>这有助于增加更少的依赖关系，并减少版本的冲突。<br>18、什么是 CSRF 攻击？<br>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的<br>Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是<br>数据窃取，因为攻击者无法查看对伪造请求的响应。<br>19、什么是 WebSockets？<br>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。<br>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。<br>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。<br>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。<br>然后这个单一连接用于所有未来的通信<br>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。<br>20、什么是 AOP？<br>在软件开发过程中，跨越应用程序多个点的功能称为交叉问题。这些交叉问题与<br>应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向方<br>面编程（AOP）的地方。<br>21、什么是 Apache Kafka？<br>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的<br>发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶<br>级项目。Kafka 适合离线和在线消息消费。<br>22、我们如何监视所有 Spring Boot 微服务？<br>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应<br>用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运<br>行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应<br>用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，<br>管理员将不得不击中所有 50 个应用程序的执行终端。<br>为了帮助我们处理这种情况，我们将使用位于<br>的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使<br>我们能够可视化多个应用程序的度量。<br>Spring Cloud 面试题<br>1、什么是 Spring Cloud？<br>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，<br>提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，<br>用于快速构建执行有限数据处理的应用程序。<br>2、使用 Spring Cloud 有什么优势？<br>使用 Spring Boot 开发分布式微服务时，我们面临以下问题<br>1、与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，<br>安全问题。<br>2、服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉<br>及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。<br>3、冗余-分布式系统中的冗余问题。<br>4、负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机<br>集群，网络链路，中央处理单元，或磁盘驱动器的分布。<br>5、性能-问题 由于各种运营开销导致的性能问题。<br>6、部署复杂性-Devops 技能的要求。<br>3、服务注册和发现是什么意思？Spring Cloud 如何实现？<br>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多<br>的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，<br>而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册<br>和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通<br>过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。<br>4、负载平衡的意义什么？<br>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元<br>或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最<br>大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负<br>载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉<br>及专用软件或硬件，例如多层交换机或域名系统服务器进程。<br>5、什么是 Hystrix？它如何实现容错？<br>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当<br>出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。<br>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。<br>思考以下微服务<br>假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。但<br>这仍然会导致整个系统崩溃。<br>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.<br>这是 hystrix 出现的地方 我们将使用 Hystrix 在这种情况下的 Fallback 方法功能。<br>我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。<br>简化图如下所示<br>现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这<br>种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服务相<br>同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。<br>6、什么是 Hystrix 断路器？我们需要它吗？<br>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用<br>Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回<br>一些默认值。<br>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工<br>使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第<br>一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发<br>生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。<br>7、什么是 Netflix Feign？它的优点是什么？<br>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。<br>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。<br>在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST<br>模板公开的 REST 服务。<br>但是我们必须编写大量代码才能执行以下步骤<br>1、使用功能区进行负载平衡。<br>2、获取服务实例，然后获取基本 URL。<br>3、利用 REST 模板来使用服务。 前面的代码如下</p><p>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如<br>何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关<br>系也在类路径中，那么 Feign 默认也会负责负载平衡。<br>8、什么是 Spring Cloud Bus？我们需要它吗？<br>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而<br>Spring Cloud Config 从 GIT 读取这些属性。<br>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注<br>册的财产。<br>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什<br>么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。<br>还有另一种使用执行器端点&#x2F;刷新的方式。但是我们将不得不为每个模块单独调用<br>这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：<br>&#x2F;&#x2F; localhost：8080 &#x2F; refresh。同样对于 Employee Producer2 http：&#x2F;&#x2F;<br>localhost：8081 &#x2F; refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥<br>作用的地方。<br>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，<br>如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果<br>我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个<br>消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微<br>服务，并且它们也会刷新。可以通过使用端点&#x2F;总线&#x2F;刷新来实现对任何单个实例的<br>刷新。<br>RabbitMQ 面试题<br>1、什么是 rabbitmq<br>采用 AMQP 高级消息队列协议的一种消息队列技术,最大的特点就是消费并不需<br>要确保提供方存在,实现了服务之间的高度解耦<br>2、为什么要使用 rabbitmq<br>1、在分布式系统下具备异步,削峰,负载均衡等一系列高级功能;<br>2、拥有持久化的机制，进程消息，队列中的信息也可以保存下来。<br>3、实现消费者和生产者之间的解耦。<br>4、对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量<br>的限流，利于数据库的操作。<br>5.可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。<br>3、使用 rabbitmq 的场景<br>1、服务间异步通信<br>2、顺序消费<br>3、定时任务<br>4、请求削峰<br>4、如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接<br>收方消费了消息？<br>发送方确认模式<br>将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都<br>会被指派一个唯一的 ID。<br>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信<br>道会发送一个确认给生产者（包含消息唯一 ID）。<br>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（not<br>acknowledged，未确认）消息。<br>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消<br>息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来<br>处理确认消息。<br>接收方确认机制<br>接收方消息确认机制<br>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操<br>作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。<br>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否<br>需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足<br>够长的时间来处理消息。保证数据的最终一致性；<br>下面罗列几种特殊情况<br>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为<br>消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消<br>费的隐患，需要去重）<br>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消<br>费者繁忙，将不会给该消费者分发更多的消息。<br>5.如何避免消息重复投递或重复消费？<br>在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id，作<br>为去重的依据（消息投递失败并重传），避免重复的消息进入队列；<br>在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支<br>付 ID、订单 ID、帖子 ID 等）作为去重的依据，避免同一条消息被重复消费。<br>6、消息基于什么传输？<br>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶<br>颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的<br>虚拟连接，且每条 TCP 连接上的信道数量没有限制。<br>7、消息如何分发？<br>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消<br>费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息<br>并进行确认）。<br>通过路由可实现多消费的功能<br>8、消息怎么路由？<br>消息提供方-&gt;路由-&gt;一至多个队列<br>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设<br>定。<br>通过队列路由键，可以把队列绑定到交换器上。<br>消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针<br>对不同的交换器有不同的路由规则）；<br>常用的交换器主要分为一下三种<br>fanout：如果交换器收到消息，将会广播到所有绑定的队列上<br>direct：如果路由键完全匹配，消息就被投递到相应的队列<br>topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，<br>可以使用通配符<br>9、如何确保消息不丢失？<br>消息持久化，当然前提是队列必须持久化<br>RabbitMQ 确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上<br>的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit 会在<br>消息提交到日志文件后才发送响应。<br>一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ 会在持久化日志中<br>把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前 RabbitMQ 重启，<br>那么 Rabbit 会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件<br>中的消息到合适的队列。<br>10、使用 RabbitMQ 有什么好处？<br>1、服务间高度解耦<br>2、异步通信性能高<br>3、流量削峰<br>11、RabbitMQ 的集群<br>镜像集群模式<br>你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，然后<br>每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息<br>同步。<br>好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第<br>一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很<br>重！第二，这么玩儿，就没有扩展性可言了，如果某个 queue 负载很重，你加机<br>器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue<br>12、mq 的缺点<br>系统可用性降低<br>系统引入的外部依赖越多，越容易挂掉，本来你就是 A 系统调用 BCD 三个系统的<br>接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一<br>MQ 挂了咋整？MQ 挂了，整套系统崩溃了，你不就完了么。<br>系统复杂性提高<br>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？<br>怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已<br>一致性问题<br>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要<br>是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？<br>你这数据就不一致了。<br>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对<br>它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈<br>呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还<br>是得用的<br>kafka 面试题<br>1、如何获取 topic 主题的列表<br>bin&#x2F;kafka-topics.sh –list –zookeeper localhost:2181<br>2、生产者和消费者的命令行是什么？<br>生产者在主题上发布消息：<br>bin&#x2F;kafka-console-producer.sh –broker-list 192.168.43.49:9092 –topic<br>Hello-Kafka<br>注意这里的 IP 是 server.properties 中的 listeners 的配置。接下来每个新行就是<br>输入一条新消息。<br>消费者接受消息：<br>bin&#x2F;kafka-console-consumer.sh –zookeeper localhost:2181 –topic<br>Hello-Kafka –from-beginning<br>3、consumer 是推还是拉？<br>Kafka 最初考虑的问题是，customer 应该从 brokes 拉取消息还是 brokers 将消<br>息推送到 consumer，也就是 pull 还 push。在这方面，Kafka 遵循了一种大部分<br>消息系统共同的传统的设计：producer 将消息推送到 broker，consumer 从<br>broker 拉取消息。<br>一些消息系统比如 Scribe 和 Apache Flume 采用了 push 模式，将消息推送到下<br>游的 consumer。这样做有好处也有坏处：由 broker 决定消息推送的速率，对于<br>不同消费速率的 consumer 就不太好处理了。消息系统都致力于让 consumer 以<br>最大的速率最快速的消费消息，但不幸的是，push 模式下，当 broker 推送的速<br>率远大于 consumer 消费的速率时，consumer 恐怕就要崩溃了。最终 Kafka 还<br>是选取了传统的 pull 模式。<br>Pull 模式的另外一个好处是 consumer 可以自主决定是否批量的从 broker 拉取数<br>据。Push 模式必须在不知道下游 consumer 消费能力和消费策略的情况下决定是<br>立即推送每条消息还是缓存之后批量推送。如果为了避免 consumer 崩溃而采用<br>较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull 模式下，<br>consumer 就可以根据自己的消费能力去决定这些策略。<br>Pull 有个缺点是，如果 broker 没有可供消费的消息，将导致 consumer 不断在循<br>环中轮询，直到新消息到 t 达。为了避免这点，Kafka 有个参数可以让 consumer<br>阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可<br>以批量发送)。<br>4、讲讲 kafka 维护消费状态跟踪的方法<br>大部分消息系统在 broker 端的维护消息被消费的记录：一个消息被分发到<br>consumer 后 broker 就马上进行标记或者等待 customer 的通知后进行标记。这<br>样也可以在消息在消费后立马就删除以减少空间占用。<br>但是这样会不会有什么问题呢？如果一条消息发送出去之后就立即被标记为消费<br>过的，一旦 consumer 处理消息时失败了（比如程序崩溃）消息就丢失了。为了<br>解决这个问题，很多消息系统提供了另外一个个功能：当消息被发送出去之后仅<br>仅被标记为已发送状态，当接到 consumer 已经消费成功的通知后才标记为已被<br>消费的状态。这虽然解决了消息丢失的问题，但产生了新问题，首先如果 consumer<br>处理消息成功了但是向 broker 发送响应时失败了，这条消息将被消费两次。第二<br>个问题时，broker 必须维护每条消息的状态，并且每次都要先锁住消息然后更改<br>状态然后释放锁。这样麻烦又来了，且不说要维护大量的状态数据，比如如果消<br>息发送出去但没有收到消费成功的通知，这条消息将一直处于被锁定的状态，<br>Kafka 采用了不同的策略。Topic 被分成了若干分区，每个分区在同一时间只被一<br>个 consumer 消费。这意味着每个分区被消费的消息在日志中的位置仅仅是一个<br>简单的整数：offset。这样就很容易标记每个分区消费状态就很容易了，仅仅需要<br>一个整数而已。这样消费状态的跟踪就很简单了。<br>这带来了另外一个好处：consumer 可以把 offset 调成一个较老的值，去重新消<br>费老的消息。这对传统的消息系统来说看起来有些不可思议，但确实是非常有用<br>的，谁规定了一条消息只能被消费一次呢？<br>5、讲一下主从同步**<br>6、为什么需要消息系统，mysql 不能满足需求吗？<br>1.解耦：<br>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。<br>2.冗余：<br>消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据<br>丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队<br>列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保<br>你的数据被安全的保存直到你使用完毕。<br>3.扩展性：<br>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，<br>只要另外增加处理过程即可。<br>4.灵活性 &amp; 峰值处理能力：<br>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不<br>常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪<br>费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负<br>荷的请求而完全崩溃。<br>5.可恢复性：<br>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合<br>度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复<br>后被处理。<br>6.顺序保证：<br>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，<br>并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消<br>息的有序性）<br>7.缓冲：<br>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度<br>不一致的情况。<br>8.异步通信：<br>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允<br>许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放<br>多少，然后在需要的时候再去处理它们。<br>7、Zookeeper 对于 Kafka 的作用是什么？<br>Zookeeper 是一个开放源码的、高性能的协调服务，它用于 Kafka 的分布式应用。<br>Zookeeper 主要用于在集群中不同节点之间进行通信<br>在 Kafka 中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都<br>可以从之前提交的偏移量中获取<br>除此之外，它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新<br>节点何时离开或连接、集群、节点实时状态等等。<br>8、数据传输的事务定义有哪三种？<br>和 MQTT 的事务定义一样都是 3 种。<br>（1）最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输<br>（2）最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.<br>（3）精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输<br>被一次而且仅仅被传输一次，这是大家所期望的<br>9、Kafka 判断一个节点是否还活着有那两个条件？<br>（1）节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每<br>个节点的连接<br>（2）如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太<br>久<br>10、Kafka 与传统 MQ 消息系统之间有三个关键区别<br>(1).Kafka 持久化日志，这些日志可以被重复读取和无限期保留<br>(2).Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过<br>复制数据提升容错能力和高可用性<br>(3).Kafka 支持实时的流式处理<br>11、讲一讲 kafka 的 ack 的三种机制<br>request.required.acks 有三个值 0 1 -1(all)<br>0:生产者不会等待 broker 的 ack，这个延迟最低但是存储的保证最弱当 server 挂<br>掉的时候就会丢数据。<br>1：服务端会等待 ack 值 leader 副本确认接收到消息后发送 ack 但是如果 leader<br>挂掉后他不确保是否复制完成新 leader 也会导致数据丢失。<br>-1(all)：服务端会等所有的 follower 的副本受到数据后才会受到 leader 发出的<br>ack，这样数据不会丢失<br>12、消费者如何不自动提交偏移量，由应用提交？<br>将 auto.commit.offset 设为 false，然后在处理一批消息后 commitSync() 或者<br>异步提交 commitAsync()<br>即：<br>ConsumerRecords&lt;&gt; records &#x3D; consumer.poll();<br>for (ConsumerRecord&lt;&gt; record : records){<br>。。。<br>tyr{<br>consumer.commitSync()<br>}<br>。。。<br>}<br>13、消费者故障，出现活锁问题如何解决？<br>出现“活锁”的情况，是它持续的发送心跳，但是没有处理。为了预防消费者在<br>这种情况下一直持有分区，我们使用 max.poll.interval.ms 活跃检测机制。 在此<br>基础上，如果你调用的 poll 的频率大于最大间隔，则客户端将主动地离开组，以<br>便其他消费者接管该分区。 发生这种情况时，你会看到 offset 提交失败（调用<br>commitSync（）引发的 CommitFailedException）。这是一种安全机制，保障<br>只有活动成员能够提交 offset。所以要留在组中，你必须持续调用 poll。<br>消费者提供两个配置设置来控制 poll 循环：<br>max.poll.interval.ms：增大 poll 的间隔，可以为消费者提供更多的时间去处理返<br>回的消息（调用 poll(long)返回的消息，通常返回的消息都是一批）。缺点是此值<br>越大将会延迟组重新平衡。<br>max.poll.records：此设置限制每次调用 poll 返回的消息数，这样可以更容易的<br>预测每次 poll 间隔要处理的最大值。通过调整此值，可以减少 poll 间隔，减少重<br>新平衡分组的<br>对于消息处理时间不可预测地的情况，这些选项是不够的。 处理这种情况的推荐<br>方法是将消息处理移到另一个线程中，让消费者继续调用 poll。 但是必须注意确<br>保已提交的 offset 不超过实际位置。另外，你必须禁用自动提交，并只有在线程<br>完成处理后才为记录手动提交偏移量（取决于你）。 还要注意，你需要 pause 暂<br>停分区，不会从 poll 接收到新消息，让线程处理完之前返回的消息（如果你的处<br>理能力比拉取消息的慢，那创建新线程将导致你机器内存溢出）。<br>14、如何控制消费的位置<br>kafka 使用 seek(TopicPartition, long)指定新的消费位置。用于查找服务器保留<br>的最早和最新的 offset 的特殊的方法也可用（seekToBeginning(Collection) 和<br>seekToEnd(Collection)）<br>15、kafka 分布式（不是单机）的情况下，如何保证消息的顺<br>序消费?<br>Kafka 分布式的单位是 partition，同一个 partition 用一个 write ahead log 组织，<br>所以可以保证 FIFO 的顺序。不同 partition 之间不能保证顺序。但是绝大多数用<br>户都可以通过 message key 来定义，因为同一个 key 的 message 可以保证只发<br>送到同一个 partition。<br>Kafka 中发送 1 条消息的时候，可以指定(topic, partition, key) 3 个参数。<br>partiton 和 key 是可选的。如果你指定了 partition，那就是所有消息发往同 1<br>个 partition，就是有序的。并且在消费端，Kafka 保证，1 个 partition 只能被<br>1 个 consumer 消费。或者你指定 key（比如 order id），具有同 1 个 key 的<br>所有消息，会发往同 1 个 partition。<br>16、kafka 的高可用机制是什么？<br>这个问题比较系统，回答出 kafka 的系统特点，leader 和 follower 的关系，消息<br>读写的顺序即可。</p><p>17、kafka 如何减少数据丢失<br>18、kafka 如何不消费重复数据？比如扣款，我们不能重复的<br>扣。<br>其实还是得结合业务来思考，我这里给几个思路：<br>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入<br>了，update 一下好吧。<br>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。<br>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据<br>的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费<br>到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消<br>费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保<br>证别重复处理相同的消息即可。<br>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束<br>了，重复数据插入只会报错，不会导致数据库中出现脏数据。<br>互联网 Java 工程师面试题<br>内容涵盖：Java、MyBatis、ZooKeeper、Dubbo、Elasticsearch、Memcached、<br>Redis、MySQL、Spring、Spring Boot、Spring Cloud、RabbitMQ、Kafka、<br>Linux 等技术栈<br>6、虚拟机jVM编译class类的原理？<br>JVM可以称为软件模拟的计算机，它可以在任何处理器安全地兼容并且执行.class字节码。其实 JVM兼容的二进制字节码和操作系统的本地机器码有一定的区别，只是针对 JVM上层的调用程序而言，执行过程效果一样，所以我们一般理解就是说直接用JVM来执行二进制码，实际上二者本质 有一定的差异，但是这一点可以理解JVM具有跨平台性。一般情况下，编程人员都是直接编写.java的 源文件，然后用Java编译器（javac命 令）对源文件进行编译，生成.class文件，生成的.class文件就是我们平时所说的包含了“机 器码”的文件，实际上JVM在编译和运行过程做了两件事，先是直接将源文件编译成二进制字节码.class文件，然后进行第二次处理：解释 器负责将这些二进制字节码根据本地操作系统宿主环境生成相应的本地机器码解释执行。所以可以理解的一点是为什么Java语言具有跨平台性， 因为JVM提供了Java运行的一个中间层，使得操作系统和上层应用相互之间是依靠JVM中间层进行通信的，也就是说Java编写的程序是运行在JVM上 的；再者尽管Java确实可以做到“一次编译，多处运行”，但是在不同结构的操作系统平台生成的.class文件真正在执行的时候是存在一定差异的，只是 JVM本身会根据安装的不同版本进行不同的操作系统平台下本地机器码的生成及运行，所以虽然我们在Sun公司官方网站可以下载到很多不同操作系统版本的 JDK，但是执行效果一样。而且还有一点，这一步操作针对开发人员是透明的，所以真正在开发过程可以放心的是不需要去担心这种问题，只要下载的版本是和符 合我们运行的操作系统的，只管进行普通编程的编译、解释运行操作就可以了。　　Java语言既是编译型语言，也是解释型语言，在.class文件生成之前，JVM通过javac命令对源代码进行编译操作， 然后用JVM根据包含了二进制码的.class生成机器码并且解释执行。所以Java程序的跨平台特性主要是指字节码文件可以在任何具有Java虚拟机的计算机或者电 子设备上运行，Java虚拟机中的Java解释器负责将字节码文件解释成为特定的机器码进行运行。Java虚拟机的建立需要针对不同的软硬件平台来实现， 既要考虑处理器的型号，也要考虑操作系统的种类。由此在SPARC结构、X86结构、MIPS和PPC等嵌入式处理芯片上，在UNIX、Linux、 Windows和部分实时操作系统上都可实现Java虚拟机，这也是为了在运行过程生成本地机器码而考虑的，使得JVM可以兼容不同的软硬件平台。7、Servlet怎么实现单一线程？原理？<br>&lt;%@ page isThreadSafe&#x3D;”true|false” %&gt;<br>默认值为trueisThreadSafe&#x3D;false模式表示它是以Singleton模式运行。<br>该模式implements了接口SingleThreadMode,<br>该模式同一时刻只有一个实例，不会出现信息同步与否的概念。<br>若多个用户同时访问一个这种模式的页面，<br>那么先访问者完全执行完该页面后，后访问者才开始执行。<br>10、怎么用SqlServer数据库实现无限量数据的存储，原理是什么?<br>将SQL数据库设为文件自动增长是为了简化系统管理，当磁盘上有剩余空间，数据库总能装下新输入的数据。数据库文件自动增长只发生在当现有剩余空间不足以装新输入数据时才增长，对数据库的只读访问无论多少次都不使数据库增长，新增&#x2F;修改数据时也只有在剩余空间不足时才增大文件；而删除数据时，释放的空间满足一定条件时这部分空间可以被重新使用。由于增长文件大小需要消耗大量系统资源，数据库管理系统总是尽可能减少增长文件的操作。其增长方式通常有按百分比增长，假如文件初始大小是100MB，百分比是10%，那么下次自动增长时，文件大小将变为110MB，即增加原大小的10%，再发生增长时，文件大小变为121MB；另一种常用的方式是固定大小增长，假如文件初始大小是100MB，每次增加10MB，则下次自动增长时，文件大小将变为110MB，再发生增长时，文件大小变为120MB.<br>3.类型转换Java语言是一种强类型的语言。强类型的语言有以下几个要求：<br>l 变量或常量必须有类型<br>要求声明变量或常量时必须声明类型，而且只能在声明以后才能使用。<br>l 赋值时类型必须一致<br>值的类型必须和变量或常量的类型完全一致。<br>l 运算时类型必须一致<br>参与运算的数据类型必须一致才能运算。<br>但是在实际的使用中，经常需要在不同类型的值之间进行操作，这就需要一种新的语法来适应这种需要，这个语法就是数据类型转换。<br>在数值处理这部分，计算机和现实的逻辑不太一样，对于现实来说，1和1.0没有什么区别，但是对于计算机来说，1是整数类型，而1.0是小数类型，其在内存中的存储方式以及占用的空间都不一样，所以类型转换在计算机内部是必须的。Java语言中的数据类型转换有两种：<br>l 自动类型转换<br>编译器自动完成类型转换，不需要在程序中编写代码。<br>l 强制类型转换<br>强制编译器进行类型转换，必须在程序中编写代码。<br>由于基本数据类型中boolean类型不是数字型，所以基本数据类型的转换是出了boolean类型以外的其它7种类型之间的转换。下面来具体介绍两种类型转换的规则、适用场合以及使用时需要注意的问题。<br>3.7.1 自动类型转换<br>自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以Java语言在设计时，没有为该操作设计语法，而是由JVM自动完成。<br>l 转换规则<br>从存储范围小的类型到存储范围大的类型。<br>具体规则为：<br>byte→short(char)→int→long→float→double<br>也就是说byte类型的变量可以自动转换为short类型，示例代码：<br>byte b &#x3D; 10;<br>short sh &#x3D; b;<br>这里在赋值时，JVM首先将b的值转换为short类型，然后再赋值给sh。<br>在类型转换时可以跳跃。示例代码：<br>byte b1 &#x3D; 100;<br>int n &#x3D; b1;<br>l 注意问题<br>在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。<br>3.7.2 强制类型转换<br>强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。<br>l 转换规则<br>从存储范围大的类型到存储范围小的类型。<br>具体规则为：<br>double→float→long→int→short(char)→byte<br>语法格式为：<br>(转换到的类型)需要转换的值<br>示例代码：<br>double d &#x3D; 3.10;<br>int n &#x3D; (int)d;<br>这里将double类型的变量d强制转换成int类型，然后赋值给变量n。需要说明的是小数强制转换为整数，采用的是“去1法”，也就是无条件的舍弃小数点的所有数字，则以上转换出的结果是3。整数强制转换为整数时取数字的低位，例如int类型的变量转换为byte类型时，则只去int类型的低8位(也就是最后一个字节)的值。<br>示例代码：<br>int n &#x3D; 123;<br>byte b &#x3D; (byte)n;<br>int m &#x3D; 1234;<br>byte b1 &#x3D; (byte)m;<br>则b的值还是123，而b1的值为-46。b1的计算方法如下：m的值转换为二进制是10011010010，取该数字低8位的值作为b1的值，则b1的二进制值是11010010，按照机器数的规定，最高位是符号位，1代表负数，在计算机中负数存储的是补码，则该负数的原码是10101110，该值就是十进制的-46。4.修饰符的作用域<br>1、类的修饰符分为：可访问控制符和非访问控制符两种。可访问控制符是：公共类修饰符 public非访问控制符有：抽象类修饰符 abstract ；最终类修饰符 final1 ）公共类修饰符 public ： Java 语言中类的可访问控制符只有一个： public 即公共的。每个 Java 程序的主类都必须是 public 类作为公共工具供其它类和程序使用的应定义为 public 类。2 ）抽象类修饰符 abstract ：凡是用 abstract 修饰符修饰的类，被称为抽象类。所谓抽象类是指这种类没有具体对象的一种概念类。这样的类就是 Java 语言的 abstract 类。3 ） 最终类修饰符 final ：当一个类不可能有子类时可用修饰符 final 把它说明为最终类。被定义为 final 的类通常是一些有固定作用、用来完成某种标准功能的类。4 ）类缺省访问控制符：如果一个类没有访问控制符，说明它具有缺省的访问控制符特性。此时，这个类只能被同一个包中的类访问或引用。这一访问特性又称为包访问性。2 ．域的控制修饰符也分为：可访问控制符和非访问控制符两类。可访问控制符有 4 种：公共访问控制符： public ；私有访问控制符： private ；保护访问控制符： protected ；私有保护访问控制符： private protected非访问控制符有 4 种：静态域修饰符： static ；最终域修饰符： final ；易失 ( 共享 ) 域修饰符： volatile ；暂时性域修饰符： transient1 ）公共访问控制符 public ：用 public 修饰的域称为公共域。如果公共域属于一个公共类，则可以被所有其它类所引用。由于 public 修饰符会降低运行的安全性和数据的封装性，所以一般应减少 public 域的使用。2 ）私有访问控制符 private ： 用 private 修饰的成员变量 ( 域 ) 只能被该类自身所访问，而不能被任何其它类 ( 包括子类 ) 所引用。3 ）保护访问控制符 protected ：用 protected 修饰的成员变量可以被三种类所引用：①该类自身；②与它在同一个包中的其它类；③在其它包中的该类的子类。使用修饰符 protected 的主要作用是允许其它包中它的子类来访问父类的特定属性。4 ）私有保护访问控制符 private protected ：用修饰符 private protected 修饰的成员变量可以被该类本身或该类的子类两种类访问和引用。5 ）静态域修饰符 static ：用 static 修饰的成员变量仅属于类的变量，而不属于任何一个具体的对象，静态成员变量的值是保存在类的内存区域的公共存储单元，而不是保存在某一个对象的内存区间。任何一个类的对象访问它时取到的都是相同的数据；任何一个类的对象修改它时 , 也都是对同一个内存单元进行操作。6 ）最终域修饰符 final ：最终域修饰符 final 是用来定义符号常量的。一个类的域 ( 成员变量 ) 如果被修饰符 final 说明，则它的取值在程序的整个执行过程中都是不变的。7 ）易失 ( 共享 ) 域修饰符 volatile ：易失 ( 共享 ) 域修饰符 volatile 是用来说明这个成员变量可能被几个线程所控制和修改。也就是说在程序运行过程中，这个成员变量有可能被其它的程序影响或改变它的取值。因此，在使用中要注意这种成员变量取值的变化。通常 volatile 用来修饰接受外部输入的域。8 ）暂时性域修饰符 transient ：暂时性域修饰符 transient 用来定义一个暂时性变量。其特点是：用修饰符 transient 限定的暂时性变量，将指定 Java 虚拟机认定该暂时性变量不属于永久状态，以实现不同对象的存档功能。否则，类中所有变量都是对象的永久状态的一部分，存储对象时必须同时保存这些变量。3 ．方法的控制修饰符也分为：可访问控制符和非访问控制符两类。可访问控制符有 4 种：公共访问控制符： public ；私有访问控制符： private ；保护访问控制符： protected ；私有保护访问控制符： private protected非访问控制符有 5 种：抽象方法控制符： abstract ；静态方法控制符： static ；最终方法控制符： final ；本地方法控制符： native ；同步方法控制符： synchronized1 ）抽象方法控制符 abstract ：用修饰符 abstract 修饰的方法称为抽象方法。抽象方法是一种仅有方法头，没有方法体和操作实现的一种方法。2 ）静态方法控制符 static ：用修饰符 static 修饰的方法称为静态方法。静态方法是属于整个类的类方法；而不使用 static 修饰、限定的方法是属于某个具体类对象的方法。 由于 static 方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量，即 static 方法只能处理 static 的域。3 ）最终方法控制符 final ：用修饰符 final 修饰的方法称为最终方法。最终方法是功能和内部语句不能更改的方法，即最终方法不能重载。这样，就固定了这个方法所具有的功能和操作，防止当前类的子类对父类关键方法的错误定义，保证了程序的安全性和正确性。所有被 private 修饰符限定为私有的方法，以及所有包含在 final 类 ( 最终类 ) 中的方法，都被认为是最终方法。4 ）本地方法控制符 native ：用修饰符 native 修饰的方法称为本地方法。为了提高程序的运行速度，需要用其它的高级语言书写程序的方法体，那么该方法可定义为本地方法用修饰符 native 来修饰；5 ）同步方法控制符 synchronized ：该修饰符主要用于多线程共存的程序中的协调和同步。5.STATIC修饰符<br>希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static(静态的)就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static 成员的最常见的例子是main( ) 。因为在程序开始执行时必须调用main() ，所以它被声明为static。声明为static的变量实质上就是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。声明为static的方法有以下几条限制：<br>·<br>它们仅能调用其他的static 方法。<br>·<br>它们只能访问static数据。<br>·<br>它们不能以任何方式引用this 或super（关键字super 与继承有关，在下一章中描述）。<br>如果你需要通过计算来初始化你的static变量，你可以声明一个static块，Static 块仅在该类被加载时执行一次6.字符串的大小写转换<br>1.把一个ASP网站改成JSP网站要怎么做<br>1.在IIS环境配置并测试成功后，打开站点属性——主目录——配置——映射选项卡——添加<br>可执行文件找到c:\windows\system32\inetsrv\asp.dll<br>扩展名输入.jsp<br>确定（若此时确定为灰色，请单击可执行文件中的路径）<br>2.将所有.asp文件扩展名改为.jsp（内页中的包含文件路径等也要替换.jsp，避免找不到文件）<br>3.运行网站2.STRUTS1与STUSTS2的区别是什么Struts 1和Struts 2对比2.1. 在Action实现类方面的对比：<br>Struts 1要求Action类继承一个抽象基类；Struts 1的一个具体问题是使用抽象类编程而不是接口。<br>Struts 2 Action类可以实现一个Action接口，也可以实现其他接口，使可选和定制的服务成为可能。Struts 2提供一个ActionSupport基类去实现常用的接口。即使Action接口不是必须实现的，只有一个包含execute方法的POJO类都可以用作Struts 2的Action。<br>2.2. 线程模式方面的对比：<br>Struts 1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts 1 Action能做的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的；<br>Struts 2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。<br>2.3. Servlet依赖方面的对比：<br>Struts 1 Action依赖于Servlet API，因为Struts 1 Action的execute方法中有HttpServletRequest和HttpServletResponse方法。<br>Struts 2 Action不再依赖于Servlet API，从而允许Action脱离Web容器运行，从而降低了测试Action的难度。当然，如果Action需要直接访问HttpServletRequest和HttpServletResponse参数，Struts 2 Action仍然可以访问它们。但是，大部分时候，Action都无需直接访问HttpServetRequest和 HttpServletResponse，从而给开发者更多灵活的选择。<br>2.4. 可测性方面的对比：<br>测试Struts 1 Action的一个主要问题是execute方法依赖于Servlet API，这使得Action的测试要依赖于Web容器。为了脱离Web容器测试Struts 1的Action，必须借助于第三方扩展：Struts TestCase，该扩展下包含了系列的Mock对象（模拟了HttpServetRequest和HttpServletResponse对象），从而可以脱离Web容器测试Struts 1的Action类。<br>Struts 2 Action可以通过初始化、设置属性、调用方法来测试。<br>2.5. 封装请求参数的对比：<br>Struts 1使用ActionForm对象封装用户的请求参数，所有的ActionForm必须继承一个基类：ActionForm。普通的JavaBean不能用作ActionForm，因此，开发者必须创建大量的ActionForm类封装用户请求参数。虽然Struts 1提供了动态ActionForm来简化ActionForm的开发，但依然需要在配置文件中定义ActionForm；<br>Struts 2直接使用Action属性来封装用户请求属性，避免了开发者需要大量开发ActionForm类的烦琐，实际上，这些属性还可以是包含子属性的Rich 对象类型。如果开发者依然怀念Struts 1 ActionForm的模式，Struts 2提供了ModelDriven模式，可以让开发者使用单独的Model对象来封装用户请求参数，但该Model对象无需继承任何Struts 2基类，是一个POJO，从而降低了代码污染。<br>2.6. 表达式语言方面的对比：<br>Struts 1整合了JSTL，因此可以使用JSTL表达式语言。这种表达式语言有基本对象图遍历，但在对集合和索引属性的支持上则功能不强；<br>Struts 2可以使用JSTL，但它整合了一种更强大和灵活的表达式语言：OGNL（Object Graph Notation Language），因此，Struts 2下的表达式语言功能更加强大。<br>2.7. 绑定值到视图的对比：<br>Struts 1使用标准JSP机制把对象绑定到视图页面；<br>Struts 2使用“ValueStack”技术，使标签库能够访问值，而不需要把对象和视图页面绑定在一起。<br>2.8. 类型转换的对比：<br>Struts 1 ActionForm 属性通常都是String类型。Struts 1使用Commons-Beanutils进行类型转换，每个类一个转换器，转换器是不可配置的；<br>Struts 2使用OGNL进行类型转换，支持基本数据类型和常用对象之间的转换。<br>2.9. 数据校验的对比：<br>Struts 1支持在ActionForm重写validate方法中手动校验，或者通过整合Commons alidator框架来完成数据校验。<br>Struts 2支持通过重写validate方法进行校验，也支持整合XWork校验框架进行校验。<br>2.10. Action执行控制的对比：<br>Struts 1支持每一个模块对应一个请求处理（即生命周期的概念），但是模块中的所有Action必须共享相同的生命周期。<br>Struts 2支持通过拦截器堆栈（Interceptor Stacks）为每一个Action创建不同的生命周期。开发者可以根据需要创建相应堆栈，从而和不同的Action一起使用1.简述MVC模式<br>MVC架构是”Model-View-Controller”的缩写，中文翻译为”模型-视图-控制器”。MVC应用程序总是由这三个部分组成。Event(事件)导致Controller改变Model或View，或者同时改变两者。只要Controller改变了Models的数据或者属性，所有依赖的View都会自动更新。类似的，只要Controller改变了View，View会从潜在的Model中获取数据来刷新自己。MVC架构最早是smalltalk语言研究团提出的，应用于用户交互应用程序中。smalltalk语言和java语言有很多相似性,都是面向对象语言，很自然的SUN在petstore(宠物店)事例应用程序中就推荐MVC架构作为开发Web应用的架构模式。MVC架构是一种架构，其实需要其他模式协作完成。在J2EE模式目录中，通常采用service to worker模式实现，而service to worker模式可由集中控制器模式，派遣器模式和Page Helper模式组成。而Struts只实现了MVC的View和Controller两个部分，Model部分需要开发者自己来实现，Struts提供了抽象类Action使开发者能将Model应用于Struts框架中。2.述说STRING的作用<br>要理解 java中String的运作方式，必须明确一点：String是一个非可变类（immutable）。什么是非可变类呢？简单说来，非可变类的实例是不能被修改的，每个实例中包含的信息都必须在该实例创建的时候就提供出来，并且在对象的整个生<br>要理解 java中String的运作方式，必须明确一点：String是一个非可变类（immutable）。什么是非可变类呢？简单说来，非可变类的实例是不能被修改的，每个实例中包含的信息都必须在该实例创建的时候就提供出来，并且在对象的整个生存周期内固定不变。但是非可变类确实有着自身的优势，如状态单一，对象简单，便于维护。其次，该类对象对象本质上是线程安全的，不要求同步。此外用户可以共享非可变对象，甚至可以共享它们的内部信息。。String类在java中被大量运用，甚至在class文件中都有其身影，因此将其设计为简单轻便的非可变类是比较合适的。<br>一、创建。<br>好了，知道String是非可变类以后，我们可以进一步了解String的构造方式了。创建一个Stirng对象，主要就有以下两种方式：java 代码<br>String str1 &#x3D; new String( “abc” );<br>Stirng str2 &#x3D; “abc” ;<br>虽然两个语句都是返回一个String对象的引用，但是jvm对两者的处理方式是不一样的。对于第一种，jvm会马上在heap中创建一个String对象，然后将该对象的引用返回给用户。对于第二种，jvm首先会在内部维护的strings pool中通过String的 equels 方法查找是对象池中是否存放有该String对象，如果有，则返回已有的String对象给用户，而不会在heap中重新创建一个新的String对象；如果对象池中没有该String对象，jvm则在heap中创建新的String对象，将其引用返回给用户，同时将该引用添加至strings pool中。注意：使用第一种方法创建对象时，jvm是不会主动把该对象放到strings pool里面的，除非程序调用 String的intern方法。看下面的例子：java 代码<br>String str1 &#x3D; new String( “abc” ); &#x2F;&#x2F;jvm 在堆上创建一个String对象&#x2F;&#x2F;jvm 在strings pool中找不到值为“abc”的字符串，因此<br>&#x2F;&#x2F;在堆上创建一个String对象，并将该对象的引用加入至strings pool中<br>&#x2F;&#x2F;此时堆上有两个String对象<br>Stirng str2 &#x3D; “abc” ;if (str1 &#x3D;&#x3D; str2){<br>System.out.println( “str1 &#x3D;&#x3D; str2” );<br>} else {<br>System.out.println( “str1 !&#x3D; str2” );<br>}<br>&#x2F;&#x2F;打印结果是 str1 !&#x3D; str2,因为它们是堆上两个不同的对象String str3 &#x3D; “abc” ;<br>&#x2F;&#x2F;此时，jvm发现strings pool中已有“abc”对象了，因为“abc”equels “abc”<br>&#x2F;&#x2F;因此直接返回str2指向的对象给str3，也就是说str2和str3是指向同一个对象的引用<br>if (str2 &#x3D;&#x3D; str3){<br>System.out.println( “str2 &#x3D;&#x3D; str3” );<br>} else {<br>System.out.println( “str2 !&#x3D; str3” );<br>}<br>&#x2F;&#x2F;打印结果为 str2 &#x3D;&#x3D; str3<br>再看下面的例子：java 代码<br>String str1 &#x3D; new String( “abc” ); &#x2F;&#x2F;jvm 在堆上创建一个String对象str1 &#x3D; str1.intern();<br>&#x2F;&#x2F;程序显式将str1放到strings pool中，intern运行过程是这样的：首先查看strings pool<br>&#x2F;&#x2F;有没“abc”对象的引用，没有，则在堆中新建一个对象，然后将新对象的引用加入至<br>&#x2F;&#x2F;strings pool中。执行完该语句后，str1原来指向的String对象已经成为垃圾对象了，随时会<br>&#x2F;&#x2F;被GC收集。&#x2F;&#x2F;此时，jvm发现strings pool中已有“abc”对象了，因为“abc”equels “abc”<br>&#x2F;&#x2F;因此直接返回str1指向的对象给str2，也就是说str2和str1引用着同一个对象，<br>&#x2F;&#x2F;此时，堆上的有效对象只有一个。<br>Stirng str2 &#x3D; “abc” ;if (str1 &#x3D;&#x3D; str2){<br>System.out.println( “str1 &#x3D;&#x3D; str2” );<br>} else {<br>System.out.println( “str1 !&#x3D; str2” );<br>}<br>&#x2F;&#x2F;打印结果是 str1 &#x3D;&#x3D; str2为什么jvm可以这样处理String对象呢？就是因为String的非可变性。既然所引用的对象一旦创建就永不更改，那么多个引用共用一个对象时互不影响。二、串接（Concatenation）。<br>java程序员应该都知道滥用String的串接操作符是会影响程序的性能的。性能问题从何而来呢？归根结底就是String类的非可变性。既然 String对象都是非可变的，也就是对象一旦创建了就不能够改变其内在状态了，但是串接操作明显是要增长字符串的，也就是要改变String的内部状态，两者出现了矛盾。怎么办呢？要维护String的非可变性，只好在串接完成后新建一个String 对象来表示新产生的字符串了。也就是说，每一次执行串接操作都会导致新对象的产生，如果串接操作执行很频繁，就会导致大量对象的创建，性能问题也就随之而来了。<br>为了解决这个问题，jdk为String类提供了一个可变的配套类，StringBuffer。使用StringBuffer对象，由于该类是可变的，串接时仅仅时改变了内部数据结构，而不会创建新的对象，因此性能上有很大的提高。针对单线程，jdk 5.0还提供了StringBuilder类，在单线程环境下，由于不用考虑同步问题，使用该类使性能得到进一步的提高。三、String的长度<br>我们可以使用串接操作符得到一个长度更长的字符串，那么，String对象最多能容纳多少字符呢？查看String的源代码我们可以得知类String中是使用域 count 来记录对象字符的数量，而count 的类型为 int，因此，我们可以推测最长的长度为 2^32，也就是4G。<br>不过，我们在编写源代码的时候，如果使用 Sting str &#x3D; “aaaa”;的形式定义一个字符串，那么双引号里面的ASCII字符最多只能有 65534 个。为什么呢？因为在class文件的规范中， CONSTANT_Utf8_info表中使用一个16位的无符号整数来记录字符串的长度的，最多能表示 65536个字节，而java class 文件是使用一种变体UTF-8格式来存放字符的，null值使用两个字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。也正是变体UTF-8的原因，如果字符串中含有中文等非ASCII字符，那么双引号中字符的数量会更少（一个中文字符占用三个字节）。如果超出这个数量，在编译的时候编译器会报错。3.简述一下EJB与SPRING的区别与联系<br>Spring+hibernate提供了大部分原来只有ejb才有的服务，而且spring提供的有些服务比ejb做的更细致，更周到。<br>那么是不是有了spring，ejb3就没有作用吗？<br>否定。因为ejb设计的初衷是用于分布式场合，而spring一开始就没有打算提供分布式功能。所以两者的偏重点是不一样的，像ejb比较适合用于大型企业，因为大型企业一般都　会存在多个信息系统，而这些信息系统又相互关联。为了避免业务功能重复开发，实现最大程度的重用，有必要把业务层独立出来，让多个信息系统共享一个业务中心，这样应用就需要具备分布式能力。它的主要优点就是：分离出业务层，软件功能改变，只需修改业务层，为后期软件维护提供了方便。实现业务功能共享。软件实现了最大程度的组件方面的重用。4.述说一下STRUSTS1和STRUSTS2的区别1，strust2.0的配置文件:struts.xml(取代了struts1里面的strut-config.xml<br>2.strust2.0提供了，拦截器（interceptot），而struts1没有此技术<br>3，Struts2的核心框架是当作一个filter来实现其功能的,而Struts1是ActionServlet.<br>4，Struts 1要求Action类继承一个抽象基类；Struts 1的一个具体问题是使用抽象类编程而不是接口。Struts 2 Action类可以实现一个Action接口，也可以实现其他接口，使可选和定制的服务成为可能。Struts 2提供一个ActionSupport基类去实现常用的接口。即使Action接口不是必须实现的，只有一个包含execute方法的POJO类都可以用作Struts 2的Action。<br>5，数据校验的对比：Struts 1支持在ActionForm重写validate方法中手动校验，或者通过整合Commons alidator框架来完成数据校验。Struts 2支持通过重写validate方法进行校验，也支持整合XWork校验框架进行校验。5.说一下MYSQL数据库的配置文件<br>可以使用的MySQL配置文件共有５个。最后４个位于&#x2F;usr&#x2F;share&#x2F;doc&#x2F;mysql-server-*&#x2F;目录中。<br>·&#x2F;etc&#x2F;my.cnf是默认的MySQL配置文件。应该对这个文件配置修改。它是为学习目的而设计的。<br>·my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。<br>·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。<br>·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。<br>·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。6.MYSQL数据库的备份与还原<br>1.将数据库mydb导出到e:\mysql\mydb.sql文件中：<br>打开开始-&gt;运行-&gt;输入cmd进入命令行模式<br>c:&gt;mysqldump -h localhost -u root -p mydb &gt;e:\mysql\mydb.sql<br>然后输入密码，等待一会导出就成功了，可以到目标文件中检查是否成功。<br>2.将数据库mydb中的mytable导出到e:\mysql\mytable.sql文件中：<br>c:&gt;mysqldump -h localhost -u root -p mydb mytable&gt;e:\mysql\mytable.sql<br>3.将数据库mydb的结构导出到e:\mysql\mydb_stru.sql文件中：<br>c:&gt;mysqldump -h localhost -u root -p mydb –add-drop-table &gt;e:\mysql\mydb_stru.sql<br>四.从外部文件导入数据到数据库中：<br>从e:\mysql\mydb2.sql中将文件中的SQL语句导入数据库中：<br>1.从命令行进入mysql，然后用命令CREATE DATABASE mydb2;创建数据库mydb2。<br>2.退出mysql 可以输入命令exit；或者quit；<br>3.在CMD中输入下列命令：<br>c:&gt;mysql -h localhost -u root -p mydb2 &lt; e:\mysql\mydb2.sql<br>然后输入密码，就OK了。3、spring的JDBC与传统JDBC的区别及其核心类是什么？<br>对于JDBC来说，Spring提供了3个模板类：<br>nJdbcTemplate：Spring里最基本的JDBC模板，利用JDBC和简单的索引参数查询提供对数据库的简单访问。<br>nNamedParameterJdbcTemplate：能够在执行查询时把值绑定到SQL里的命名参数，而不是使用索引参数。<br>nSimpleJdbcTemplate：利用Java 5的特性，比如自动装箱、通用（generic）和可变参数列表来简化JDBC模板的使用。<br>JDBC是在关系型数据库里访问数据的最基本方式，Spring的JDBC模板让我们不必编写处理连接资源和异常的重复代码，把精力集中于查询和更新数据的工作。<br>虽然Spring处理了使用JDBC时必需的很多工作，但随着程序规模增加、复杂程度提高，使用JDBC仍然会变得繁琐。为了帮助管理大型程序的存留工作，我们可以使用像Hibernate这样的存留框架。4、web service 是什么 及其运行机制。<br>W3C组织对其的定义如下，它是一个软件系统，为了支持跨网络的机器间相互操作交互而设计。Web Service服务通常被定义为一组模块化的API，它们可以通过网络进行调用，来执行远程系统的请求服务。这里我们从一个程序员的视角来观察web service。在传统的程序编码中，存在这各种的函数方法调用。通常，我们知道一个程序模块M中的方法A，向其发出调用请求，并传入A方法需要的参数P，方法A执行完毕后，返回处理结果R。这种函数或方法调用通常发生在同一台机器上的同一程序语言环境下。现在的我们需要一种能够在不同计算机间的不同语言编写的应用程序系统中，通过网络通讯实现函数和方法调用的能力，而Web service正是应这种需求而诞生的。web service的构成组件web service的工作原理分为两步，第一步是在服务器上创造服务并将其在一台“目录服务器”上注册；第二步是客户端查找并调用该服务。要在网络使用服务，必须先有人提供服务；如何提供服务，首先必须有一个服务的发布场所；如何发布服务，就是要向“发布场所”声明你有一个服务可以对外提供，这就是服务的注册。就如在淘宝上发布了一件商品，把价格等必要信息写上去，让要的人来买。这个发布的场所是人所周知的，就如淘宝，卖东西的人知道，买东西的人也知道，所以web service的服务端和客户端都必须知道这台注册服务用的服务器。有了市场，就可以开始做生意了，厂商开始生产自己的东西，并拿到市场上去卖，而客户则通过商品目录来查找自己所需要的产品。这其中会涉及到一些买卖术语，厂商要把商品属性通知市场，而市场又要为厂商打广告，把商品目录告知客户，最后厂商和客户交易还需要传递数量、颜色、等级等信息，并且最终交付产品。在网络上，这些交流需要专门的术语，否则就会变成“鸡同鸭讲”了。6、JNDI JMS JTA 是什么意思？<br>JNDI(Java Naming and Directory Interface)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI SPI的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。集群JNDI实现了高可靠性JNDI[8]，通过服务器的集群，保证了JNDI的负载平衡和错误恢复。在全局共享的方式下，集群中的一个应用服务器保证本地JNDI树的独立性，并拥有全局的JNDI树。每个应用服务器在把部署的服务对象绑定到自己本地的JNDI树的同时，还绑定到一个共享的全局JNDI树，实现全局JNDI和自身JNDI的联系。JNDI(Java Naming and Directory Interface)是一个应用程序设计的API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。<br>JNDI可访问的现有的目录及服务有：<br>DNS、XNam 、Novell目录服务、LDAP(Lightweight Directory Access Protocol 轻型目录访问协议)、 CORBA对象服务、文件系统、Windows XP&#x2F;2000&#x2F;NT&#x2F;Me&#x2F;9x的注册表、RMI、DSML v1&amp;v2、NIS。<br>JNDI优点：<br>包含了大量的命名和目录服务，使用通用接口来访问不同种类的服务；<br>可以同时连接到多个命名或目录服务上；<br>建立起逻辑关联，允许把名称同Java对象或资源关联起来，而不必指导对象或资源的物理ID。JTA :<br>JTA(Java Transaction API) 为 J2EE 平台提供了分布式事务服务。<br>要用 JTA 进行事务界定，应用程序要调用 javax.transaction.UserTransaction 接口中的方法<br>“用 JTA 界定事务，那么就需要有一个实现 javax.sql.XADataSource 、 javax.sql.XAConnection 和 javax.sql.XAResource 接口的 JDBC 驱动程序。一个实现了这些接口的驱动程序将可以参与 JTA 事务。一个 XADataSource 对象就是一个 XAConnection 对象的工厂。 XAConnection s 是参与 JTA 事务的 JDBC 连接。”<br>要使用JTA事务，必须使用XADataSource来产生数据库连接，产生的连接为一个XA连接。<br>JMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，翻译为Java消息服务。JMS支持点对点和发布&#x2F;订阅两种消息模型。JMS基本概念<br>1.JMS(Java Message Service)是访问企业消息系统的标准API,它便于消息系<br>统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。1. JMS基本功能<br>JMS是用于和面向消息的中间件相互通信的应用程序接口。它既支持点对点(point-to-point)的域，又支持发布&#x2F;订阅(publish&#x2F;subscribe)类型的域，并且提供对下列类型的支持：经认可的消息传递,事务型消息的传递，一致性消息和具有持久性的订阅者支持。JMS还提供了另一种方式来对您的应用与旧的后台系统相集成。<br>2. WebLogic JMS Server介绍<br>WebLogic Server8.1符合JAVA规范,并通过Sun Microsystems J2EE 1.3认<br>证.作为WebLogic的一部分,当然WebLogic JMS Server也完全遵从JMS规范,还支持集群,并可以应用于实际企业系统.下图是WebLogic JMS Server体系结构.图中可以看到WebLogic JMS Server主要组件有: WebLogic JMS servers(用于消息通信),Java客户端,JNDI(用于域名查找), 后备存储(用于持久消息存储,基于文件或者JDBC数据库).7、spring 在SSH 框架中的作用。<br>在SSH框假中spring充当了管理容器的角色。我们都知道Hibernate用来做持久层，因为它将JDBC做了一个良好的封装，程序员在与数据库进行交互时可以不用书写大量的SQL语句。Struts是用来做应用层的，他它负责调用业务逻辑serivce层。所以SSH框架的流程大致控制Service（业务逻辑处理类），从而控制了Service的生命周期，这样层与层之间的依赖和强，属于耦合。这时，使用spring框架就起到了控制Action对象（Strus中的）和Service类的作用，两者之间的关系就松散了，Spring的Ioc机制（控制反转和依赖注入）正是用在此处。<br>Spring的Ioc（控制反转和依赖注入）<br>控制反转：就是由容器控制程序之间的（依赖）关系，而非传统实现中，由程序代码直接操控。<br>依赖注入：组件之间的依赖关系由容器在运行期决定 ，由容器动态的将某种依赖关系注入到组件之中。从上面我们不难看出：从头到尾Action仅仅是充当了Service的控制工具，这些具体的业务方法是怎样实现的，他根本就不会管，也不会问，他只要知道这些业务实现类所提供的方法接口就可以了。而在以往单独使用Struts框架的时候，所有的业务方法类的生命周期，甚至是一些业务流程都是由Action来控制的。层与层之间耦合性太紧密了，既降低了数据访问的效率又使业务逻辑看起来很复杂，代码量也很多。，Spring容器控制所有Action对象和业务逻辑类的生命周期，由与上层不再控制下层的生命周期，层与层之间实现了完全脱耦，使程序运行起来效率更高，维护起来也方便。 使用Spring的第二个好处（AOP应用）：事务的处理：在以往的JDBCTemplate中事务提交成功，异常处理都是通过Try&#x2F;Catch 来完成，而在Spring中。Spring容器集成了TransactionTemplate，她封装了所有对事务处理的功能，<br>包括异常时事务回滚，操作成功时数据提交等复杂业务功能。这都是由Spring容器来管理，大大减少了程序员的代码量，也对事务有了很好的管理控制。Hibernate中也有对事务的管理，hibernate中事务管理是通过SessionFactory创建和维护Session来完成。而Spring对SessionFactory配置也进行了整合，不需要在通过hibernate.cfg.xml来对SessionaFactory进行设定。这样的话就可以很好的利用Sping对事务管理强大功能。避免了每次对数据操作都要现获得Session实例来启动事务&#x2F;提交&#x2F;回滚事务还有繁琐的<br>Try&#x2F;Catch操作。这些也就是Spring中的AOP（面向切面编程）机制很好的应用。一方面使开发业务逻辑更清晰、专业分工更加容易进行。另一方面就是应用Spirng AOP隔离降低了程序的耦合性使我们可以在不同的应用中将各个切面结合起来使用大大提高了代码重用度。9、J2EE 是什么？<br>J2EE Java2平台企业版（Java 2 Platform,Enterprise Edition）<br>　　J2EE是一套全然不同于传统应用开发的技术架构，包含许多组件，主要可简化且规范应用系统的开发与部署，进而提高可移植性、安全与再用价值。<br>　　J2EE核心是一组技术规范与指南，其中所包含的各类组件、服务架构及技术层次，均有共通的标准及规格，让各种依循J2EE架构的不同平台之间，存在良好的兼容性，解决过去企业后端使用的信息产品彼此之间无法兼容,，企业内部或外部难以互通的窘境。1.string类修饰的值是否可以改变？为什么？它在内存中是怎么样运作的？<br>String类的值在初始后不能改变，如果要改变，可转换为StringBuffer类，这个类的值是可以动态改变的<br>Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！全面解析 Java 中的 String 数据类型<br>April 6th, 2008 | Categories: Java | Tags: Java1. 首先String不属于8种基本数据类型，String是一个对象。<br>因为对象的默认值是null，所以String的默认值也是null；但它又是一种特殊的对象，有其它对象没有的一些特性。2. new String()和new String(””)都是申明一个新的空字符串，是空串不是null；3. String str&#x3D;”kvill”；String str&#x3D;new String (”kvill”);的区别：在这里，我们不谈堆，也不谈栈，只先简单引入常量池这个简单的概念。<br>常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。看例1：String s0&#x3D;”kvill”;<br>String s1&#x3D;”kvill”;<br>String s2&#x3D;”kv” + “ill”;<br>System.out.println( s0&#x3D;&#x3D;s1 );<br>System.out.println( s0&#x3D;&#x3D;s2 );<br>结果为：<br>true<br>true首先，我们要知结果为道Java会确保一个字符串常量只有一个拷贝。<br>因为例子中的s0和s1中的”kvill”都是字符串常量，它们在编译期就被确定了，所以s0&#x3D;&#x3D;s1为true；而”kv”和”ill”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中” kvill”的一个引用。<br>所以我们得出s0&#x3D;&#x3D;s1&#x3D;&#x3D;s2；用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。　　看例2：<br>String s0&#x3D;”kvill”;<br>String s1&#x3D;new String(“kvill”);<br>String s2&#x3D;”kv” + new String(“ill”);<br>System.out.println( s0&#x3D;&#x3D;s1 );<br>System.out.println( s0&#x3D;&#x3D;s2 );<br>System.out.println( s1&#x3D;&#x3D;s2 );<br>结果为：<br>false<br>false<br>false例2中s0还是常量池中”kvill”的应用，s1因为无法在编译期确定，所以是运行时创建的新对象”kvill”的引用，s2因为有后半部分 new String(”ill”)所以也无法在编译期确定，所以也是一个新创建对象”kvill”的应用;明白了这些也就知道为何得出此结果了。1. String.intern()：<br>再补充介绍一点：存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；看例3就清楚了　　例3：<br>String s0&#x3D; “kvill”;<br>String s1&#x3D;new String(“kvill”);<br>String s2&#x3D;new String(“kvill”);<br>System.out.println( s0&#x3D;&#x3D;s1 );<br>System.out.println( “**********“ );<br>s1.intern();<br>s2&#x3D;s2.intern(); &#x2F;&#x2F;把常量池中”kvill”的引用赋给s2<br>System.out.println( s0&#x3D;&#x3D;s1);<br>System.out.println( s0&#x3D;&#x3D;s1.intern() );<br>System.out.println( s0&#x3D;&#x3D;s2 );<br>结果为：<br>false<em>*<em>false &#x2F;&#x2F;虽然执行了s1.intern(),但它的返回值没有赋给s1<br>true &#x2F;&#x2F;说明s1.intern()返回的是常量池中”kvill”的引用<br>true最后我再破除一个错误的理解：有人说，“使用 String.intern() 方法则可以将一个 String 类的保存到一个全局 String 表中，如果具有相同值的 Unicode 字符串已经在这个表中，那么该方法返回表中已有字符串的地址，如果在表中没有相同值的字符串，则将自己的地址注册到表中”如果我把他说的这个全局的 String 表理解为常量池的话，他的最后一句话，”如果在表中没有相同值的字符串，则将自己的地址注册到表中”是错的：　　看例4：<br>String s1&#x3D;new String(“kvill”);<br>String s2&#x3D;s1.intern();<br>System.out.println( s1&#x3D;&#x3D;s1.intern() );<br>System.out.println( s1+” “+s2 );<br>System.out.println( s2&#x3D;&#x3D;s1.intern() );<br>结果：<br>false<br>kvill kvill<br>true在这个类中我们没有声名一个”kvill”常量，所以常量池中一开始是没有”kvill”的，当我们调用s1.intern()后就在常量池中新添加了一个”kvill”常量，原来的不在常量池中的”kvill”仍然存在，也就不是“将自己的地址注册到常量池中”了。<br>s1&#x3D;&#x3D;s1.intern()为false说明原来的”kvill”仍然存在；s2现在为常量池中”kvill”的地址，所以有s2&#x3D;&#x3D;s1.intern()为true。1. 关于equals()和&#x3D;&#x3D;:<br>这个对于String简单来说就是比较两字符串的Unicode序列是否相当，如果相等返回true;而&#x3D;&#x3D;是比较两字符串的地址是否相同，也就是是否是同一个字符串的引用。1. 关于String是不可变的<br>这一说又要说很多，大家只要知道String的实例一旦生成就不会再改变了，比如说：String str&#x3D;”kv”+”ill”+” “+”ans”;<br>就是有4个字符串常量，首先”kv”和”ill”生成了”kvill”存在内存中，然后”kvill”又和” ” 生成 “kvill “存在内存中，最后又和生成了”kvill ans”;并把这个字符串的地址赋给了str,就是因为String的”不可变”产生了很多临时变量，这也就是为什么建议用StringBuffer的原因了，因为StringBuffer是可改变的。1. mxj said:<br>April 11th, 2008 at 11:44 pm单独的这样一条语句String str&#x3D;”kv”+”ill”+” “+”ans”;应该不会产生临时变量吧，等号后面的一长串东西应该在编译期就直接变成一个常量字符串，放在常量池里了。。<br>做了个测试：<br>源代码<br>public class Test{<br>public static void main(String[] s){<br>String b&#x3D;”xxx”;<br>String a&#x3D;”bbb”+”ccc”+”ddd”;<br>System.out.println(a+b);<br>}<br>}<br>javac 编译后，用javap看他的机器码。<br>可以看到只有一个已经编译成”bbbcccddd”的常量字符串。<br>可以看到编译器自动调用StringBuilder来处理字符串拼接，编译器还是很AI的。（StringBuilder是1.5的新类，1.4应该是StringBuffer，两者区别后面说。） 到底coding的时候要不要用StringBuffer呢？貌似编译器会自动把字符串拼接，用StringBuffer来处理。。<br>好比c里面，到底要不要把c&#x2F;2改成c&gt;&gt;1提高效率，编译器有时候做的比我们想象的好的多。。 到了JDK1.5多了一个StringBuilder类，这个类比StringBuffer应该更快 一点，毕竟StringBuffer是线程安全的。<br>但是不知道怎么做个测试案例，来测试这两个类的性能差异。2.struts是用什么设计模式实现的？<br>MVC模式(Model-View-Controller 模型-视图-控制器)<br>Struts主要担当了控制器的作用3.struts的工作流程是什么？<br>通常我们在配置Struts框架的时候，所使用的Controller都是默认的org\apache\struts\action\ActionServlet类,它继承自javax.servlet.http.HttpServlet,因此具有一般servlet的所有特征,必须在web.xml中对其进行注册。当我们的container第一次启动的时候(这个说法不是很准确，或者是ActionServlet第一次被请求调用得时候)，会自动加载ActionServlet，同时调用其中的init()方法。在init()方法中将发生如下动作：1.initInternal():初始化框架的内部消息绑定，这些消息用来输出提示，警告，和错误信息到日志文件中，主要操作是internal &#x3D; MessageResources.getMessageResources(internalName);其中internal是MessageResources的一个实例。2.initOther():加载web.xml中定义的不同参数，如config，用以控制ActionServlet的不同行为，主要是读取&lt;init-param&gt;&lt;&#x2F;init-param&gt;中所定义的参数。3.initServlet():加载并初始化web.xml文件所定义的servlet名称和servlet映射信息4.initModuleConfigFactory()和ModuleConfig moduleConfig &#x3D; initModuleConfig(“”, config):加载并初始化struts-config.xml配置文件,默认配置文件被解析，产生一个ModuleConfig对象于ServletContext5.initModuleMessageResources(moduleConfig):struts-config.xml配置文件中指定的每一个消息资源都被加载，初始化6.initModuleDataSources(moduleConfig):struts-config.xml配置文件中声明的每一个数据源被加载并且初始化，如果没有配置数据源，这一步跳过。7.initModulePlugIns(moduleConfig):加载并初始化struts-config.xml配置文件中指定的插件。每一个插件的init()方法被调用。8.当默认应用加载完成，init()方法判断是否有应用模块需要加载，如果有，重复步骤4—7完成应用模块的加载。 然后，在应用程序的运行过程中，当有用户发出请求的时候(当然这个请求必须得映射到ActionServlet上面去)，ActionServlet就会收到这个请求，此时它的doPost或者doGet方法就会自动的被调用，这是servlet的内部机制。至于究竟是哪个方法会被调用取决于所请求的方法的类型，即html表单中的method属性。但是,不管是哪个方法会被调用ActionServlet中的process(HttpServletRequest request, HttpServletResponse response)方法都会被调用。ActionServlet中的process方法的主要作用就是得到一个相应的RequestProcessor类或者其子类的对象，然后调用这个它的process(HttpServletRequest request, HttpServletResponse response)方法来处理用户的需求。现在ActionServlet就已经完成了它的使命,剩下的任务就由RequestProcessor来完成了,在RequestProcessor中将主要执行如下操作:1.processMultipart(request):对用户的请求进行预处理，如果HttpServletRequest是POST方式，且请求为multipart&#x2F;form-data ，Struts框架将请求对象包装成处理multipart请求专用的请求对象，否则，只是简单地返回原有的请求对象。一般来说，除非需要处理文件上传，否则不用关心multipart 功能的具体细节。进行包装处理的类是MultipartRequestWrapper类，它以用户的请求为包装对象。2.processPath(request, response):该方法用来从请求URL中获应用取路径部分，获取到的信息在稍后的步骤中用于选择合适的Struts Action调用，与action标签的path属性相对应。3.processLocale(request, response):处理一些国际化的事务。4.processContent(request, response):设置响应体的编码方式，response.setContentType(contentType)。5.processNoCache(request, response):根据noCache属性的设置调用processNoCache( ) 方法，如果noCache设置为true.则添加合适的响应头到响应对象中，使得页面保留在浏览器的Cache中。这些响应头包含Pragma, Cache-Control, 和Expires6.processPreprocess(request, response):该方法只是简单的返回一个true值,它是以如下方式调用的:if(!processPreprocess(request, response)) return;因此我们可以在processPreprocess方法中进行一点的预处理，如果用户的请求不符合要求的话，我们就让它返回一个false值，这样的话action就不会调用。7.processMapping(request, response, path):利用前面所获取的path值，在struts-config.xml中寻找对应的action。即根据path在action－mappings标签中寻找其对应的action，如果找不到则返回一个error。8.processRoles(request, response, mapping):可忽略，一般没啥用处。9.processActionForm(request, response, mapping):第一步,查看是否存在着为这个ActionMapping配置得ActionForm,具体的查看流程如下:1.该action元素的attribute是否为null，如果为null，则返回null;2.如果attribute属性不为null则取得它的 name属性,然后根据name的值在<form-beans></form-beans>中寻找相应的ActionForm，也是通过name属性来配对的,如果找不到的话，则会产生错误日志,并且返回null。第二步,如果存在这样的ActionForm，我们就根据上面的attribute的值，在作用域查看是否存在着这样的ActionForm的实例，如果存 在则复用之，并把它作为返回值,否则的话，就重新创建这个ActionForm的一个实例，并且返回它，最后这个实例将会保存在相应的作用域中10.processPopulate(request, response, form, mapping):如果存在为ActionMapping配置的ActionForm，则封装请求对象中的数据到ActionForm 中，在进行封装之前，先调用ActionForm 的reset( )方法进行属性值的默认化。11.processValidate(request, response, form, mapping):如果ActionForm被配置好，并且Action元素的属性validate被设置为true ，则进一步调用validate( )方法进行规则校 验。如果validate()方法校验失败，就会保存一个ActionErrors 对象到请求区域中，请求将会自动重定向到action映射的input属性所指定的页面中。如果校验通过或在action映射中没有配置ActionForm，则继续处理请求。12.processForward(request, response, mapping)&amp;processInclude(request, response, mapping):根据action 映射是否配置了forward属性或include属性来决定下一步操作。如果配置了任意一个，则相应地调用RequestDispatcher对象的forward( )方法或include( )方法，调用后，对客户请求的处理结束。否则，继续处理请求。13.processActionCreate(request, response, mapping):创建或获取一个Action对象实例处理请求。processActionCreate( )方法会在缓存中查找是否存在已经创 建好的Action实例，如果存在，则复用，否则，则重新创建并将其存于缓存中。如果该方法返回null，则请求处理结束(注：根据action映射得type属性来寻找对应得Action类)。14.processActionPerform(request, response, action, form, mapping):调用action 实例的execute( )方法。15.processForwardConfig(request, response, forward):传入action的execute( )方法所返回的ActionForward对象实例，方法通过检查ActionForward对象实例，决定用 redirect或forword方式进行重定向。究竟采用redirect还是forword取决于forward元素的redirect属性值。在oracle数据库中 表的内连接与外连接的区别是什么？分别用在什么场合？<br>两个表的连接，是通过将一个表中的一列或者多列同另一个表中的列链接而建立起来的。用来连接两张表的表达式组成了连接条件。当连接成功后，第二张表中的数据就同第一张表连接起来了，并形成了复合结果集–包括两张表中数据行的计划。简单地说，就是两张表有了子集，虽然只是暂时的有两者基本类型的的连接，inner和outer连接。两种类型的主要区别在于，即使是在连接条件不满足的情况下，外部连接也会在结果集内返回行，而内部连接不会在结果集类返回行<br>当外部连接不满足连接条件时，通常返回一个表中的列，但是第二个表中没有返回值–为null（一）内连接<br>　　内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的<br>列值。内连接分三种：<br>　　1、等值连接：在连接条件中使用等于号(&#x3D;)运算符比较被连接列的列值，其查询结<br>果中列出被连接表中的所有列，包括其中的重复列。<br>　　<br>　　2、不等连接： 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的<br>列的列值。这些运算符包括&gt;、&gt;&#x3D;、&lt;&#x3D;、&lt;、!&gt;、!&lt;和&lt;&gt;。　　3、自然连接：在连接条件中使用等于(&#x3D;)运算符比较被连接列的列值，但它使用选<br>择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。(二) 外连接　　<br>　　外连接，返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左<br>外连接或左连接))、右表(右外连接或右连接)或两个边接表(全外连接)中的所有数据行。<br>　　left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录；<br>　　right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录；<br>例如1：SELECT a.</em>,b.* FROM luntan LEFT JOIN usertable as b<br>　　 ON a.username&#x3D;b.username<br>例如2：SELECT a.</em>,b.*<br>　　 FROM city as a FULL OUTER JOIN user as b<br>　　 ON a.username&#x3D;b.username<br>(三) 交叉连接 　　<br>　　交叉连接不带WHERE 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到<br>结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查<br>询条件的数据行数。例，titles表中有6类图书，而publishers表中有8家出版社，则下<br>列交叉连接检索到的记录数将等于6*8&#x3D;48行。 　　<br>　　例如：SELECT type,pub_name<br>　　 FROM titles CROSS JOIN publishers<br>　　 ORDER BY type1.AJAX的工作原理<br>Ajax的工作原理Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。在创建Web站点时，在客户端执行屏幕更新为用户提供了很大的灵活性。下面是使用Ajax可以完成的功能：动态更新购物车的物品总数，无需用户单击Update并等待服务器重新发送整个页面。<br>提升站点的性能，这是通过减少从服务器下载的数据量而实现的。例如，在Amazon的购物车页面，当更新篮子中的一项物品的数量时，会重新载入整个页面，这必须下载32K的数据。如果使用Ajax计算新的总量，服务器只会返回新的总量值，因此所需的带宽仅为原来的百分之一。<br>消除了每次用户输入时的页面刷新。例如，在Ajax中，如果用户在分页列表上单击Next，则服务器数据只刷新列表而不是整个页面。<br>直接编辑表格数据，而不是要求用户导航到新的页面来编辑数据。对于Ajax，当用户单击Edit时，可以将静态表格刷新为内容可编辑的表格。用户单击Done之后，就可以发出一个Ajax请求来更新服务器，并刷新表格，使其包含静态、只读的数据。2.三大框架的特点及应用<br>Struts的原理和优点.Struts工作原理MVC即Model-View-Controller的缩写，是一种常用的设计模式。MVC 减弱了业务逻辑接口和数据接口之间的耦合，以及让视图层更富于变化。MVC的工作原理,如下图1所示：<br>Struts 是MVC的一种实现，它将 Servlet和 JSP 标记（属于 J2EE 规范）用作实现的一部分。Struts继承了MVC的各项特性，并根据J2EE的特点，做了相应的变化与扩展。Struts的工作原理，<br>视图：主要由JSP生成页面完成视图，Struts提供丰富的JSP 标签库： Html，Bean，Logic，Template等，这有利于分开表现逻辑和程序逻辑。<br>控制：在Struts中，承担MVC中Controller角色的是一个Servlet，叫ActionServlet。ActionServlet是一个通用的控制组件。这个控制组件提供了处理所有发送到Struts的HTTP请求的入口点。它截取和分发这些请求到相应的动作类（这些动作类都是Action类的子类）。另外控制组件也负责用相应的请求参数填充 Action From（通常称之为FromBean）,并传给动作类（通常称之为ActionBean）。动作类实现核心商业逻辑，它可以访问java bean 或调用EJB。最后动作类把控制权传给后续的JSP 文件，后者生成视图。所有这些控制逻辑利用Struts-config.xml文件来配置。<br>模型：模型以一个或多个java bean的形式存在。这些bean分为三类：Action Form、Action、JavaBean or EJB。Action Form通常称之为FormBean，封装了来自于Client的用户请求信息，如表单信息。Action通常称之为ActionBean，获取从ActionSevlet传来的FormBean，取出FormBean中的相关信息，并做出相关的处理，一般是调用Java Bean或EJB等。<br>流程：在Struts中，用户的请求一般以*.do作为请求服务名，所有的*.do请求均被指向ActionSevlet，ActionSevlet根据Struts-config.xml中的配置信息，将用户请求封装成一个指定名称的FormBean，并将此FormBean传至指定名称的ActionBean，由ActionBean完成相应的业务操作，如文件操作，数据库操作等。每一个*.do均有对应的FormBean名称和ActionBean名称，这些在Struts-config.xml中配置。<br>核心：Struts的核心是ActionSevlet，ActionSevlet的核心是Struts-config.xml。<br>Struts优缺点<br>优点：<br>1.开源软件，能更深入的了解其内部实现机制。<br>2.Taglib标记库，灵活动用，能大大提高开发效率。<br>3.页面导航使系统的脉络更加清晰。通过一个配置文件，即可把握整个系统各部分之间的联系，这对于后期的维护有着莫大的好处。尤其是当另一批开发者接手这个项目时，这种优势体现得更加明显。1. 提供Exception处理机制 .<br>2. 数据库链接池管理<br>3. Struts 的Action必需是thread－safe方式，它仅仅允许一个实例去处理所有的请求。所以action用到的所有的资源都必需统一同步，这个就引起了线程安全的问题。<br>缺点：<br>Taglib是Struts的一大优势，但对于初学者而言，却需要一个持续学习的过程，甚至还会打乱你网页编写的习惯，但是，当你习惯了它时，你会觉得它真的很棒。<br>Struts将MVC的Controller一分为三，在获得结构更加清晰的同时，也增加了系统的复杂度。<br>ActionForms使用不便、无法进行单元测试（StrutsTestCase只能用于集成）<br>Spring的原理和优点<br>Spring真正的精华是它的Ioc模式实现的BeanFactory和AOP，它自己在这个基础上延伸的功能有些画蛇添足。<br>Ioc模式是什么<br>可伸缩性和重&#x2F;轻量，谁是实用系统的架构主选？<br>Spring<br>它是一个开源的项目，而且目前非常活跃；它基于IoC（Inversion of Control，反向控制）和AOP的构架多层j2ee系统的框架，但它不强迫你必须在每一层 中必须使用Spring，因为它模块化的很好，允许你根据自己的需要选择使用它的某一个模块；它实现了很优雅的MVC，对不同的数据访问技术提供了统一的 接口，采用IoC使得可以很容易的实现bean的装配，提供了简洁的AOP并据此实现Transcation Managment，等等<br>优点<br>a. Spring能有效地组织你的中间层对象，不管你是否选择使用了EJB。如果你仅仅使用了Struts或其他为J2EE的 API特制的framework，Spring致力于解决剩下的问题。<br>b. Spring能消除在许多工程中常见的对Singleton的过多使用。根据我的经验，这是一个很大的问题，它降低了系统的可测试性和面向对象的程度。<br>c. 通过一种在不同应用程序和项目间一致的方法来处理配置文件，Spring能消除各种各样自定义格式的属性文件的需要。曾经对某个类要寻找的是哪个魔法般的属性项或系统属性感到不解，为此不得不去读Javadoc甚至源编码？有了Spring，你仅仅需要看看类的JavaBean属性。Inversion of Control的使用（在下面讨论）帮助完成了这种简化。<br>d.? 通过把对接口编程而不是对类编程的代价几乎减少到没有，Spring能够促进养成好的编程习惯。<br>e. Spring被设计为让使用它创建的应用尽可能少的依赖于他的APIs。在Spring应用中的大多数业务对象没有依赖于Spring。<br>f. 使用Spring构建的应用程序易于单元测试。<br>g. Spring能使EJB的使用成为一个实现选择,而不是应用架构的必然选择。你能选择用POJOs或local EJBs来实现业务接口，却不会影响调用代码。<br>h. Spring帮助你解决许多问题而无需使用EJB。Spring能提供一种EJB的替换物，它们适用于许多web应用。例如，Spring能使用AOP提供声明性事务管理而不通过EJB容器，如果你仅仅需要与单个数据库打交道，甚至不需要一个JTA实现。<br>i. Spring为数据存取提供了一个一致的框架,不论是使用的是JDBC还是O&#x2F;R mapping产品（如Hibernate）。<br>Spring确实使你能通过最简单可行的解决办法来解决你的问题。而这是有有很大价值的。缺点：使用人数不多、jsp中要写很多代码、控制器过于灵活，缺少一个公用控制器Hibernate的原理和优点。<br>Hibernate使用了J2EE架构中的如下技术：JDBC、JTA、JNDI。其中JDBC是一个支持关系数据库操作的一个基础层；它与JNDI和JTA一起结合，使得Hibernate可以方便地集成到J2EE应用服务器中去。 　　在这里，我们不会详细地去讨论Hibernate API接口中的所有方法，我们只简要讲一下每个主要接口的功能，如果你想了解得更多的话，你可以在Hibernate的源码包中的net.sf.hibernate子包中去查看这些接口的源代码。下面我们依次讲一下所有的主要接口： 　　核心接口 　　以下5个核心接口几乎在任何实际开发中都会用到。通过这些接口，你不仅可以存储和获得持久对象，并且能够进行事务控制。 　　<br>Session接口 　　Session接口对于Hibernate 开发人员来说是一个最重要的接口。然而在Hibernate中，实例化的Session是一个轻量级的类，创建和销毁它都不会占用很多资源。这在实际项目中确实很重要，因为在客户程序中，可能会不断地创建以及销毁Session对象，如果Session的开销太大，会给系统带来不良影响。　　<br>SessionFactory 接口 　这里用到了一个设计模式――工厂模式，用户程序从工厂类SessionFactory中取得Session的实例。 　　令你感到奇怪的是SessionFactory并不是轻量级的！实际上它的设计者的意图是让它能在整个应用中共享。典型地来说，一个项目通常只需要一个SessionFactory就够了，但是当你的项目要操作多个数据库时，那你必须为每个数据库指定一个SessionFactory。 SessionFactory在Hibernate中实际起到了一个缓冲区的作用，它缓冲了Hibernate自动生成的SQL语句和一些其它的映射数据，还缓冲了一些将来有可能重复利用的数据。 　　<br>Configuration 接口 　Configuration接口的作用是对Hibernate进行配置，以及对它进行启动。在Hibernate的启动过程中，Configuration类的实例首先定位映射文档的位置，读取这些配置，然后创建一个SessionFactory对象。 　　　　<br>Query和Criteria接口 Query接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。Query经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。 　　Criteria接口与Query接口非常类似，它允许你创建并执行面向对象的标准化查询。 值得注意的是Query接口也是轻量级的，它不能在Session之外使用。 　　<br>Callback 接口 当一些有用的事件发生时――例如持久对象的载入、存储、删除时，Callback接口会通知Hibernate去接收一个通知消息。一般而言，Callback接口在用户程序中并不是必须的，但你要在你的项目中创建审计日志时，你可能会用到它。以下是它的策略接口：<br>· 主键的生成 (IdentifierGenerator 接口) 　　<br>· 本地SQL语言支持 (Dialect 抽象类) 　　<br>· 缓冲机制 (Cache 和CacheProvider 接口) 　　<br>· JDBC 连接管理 (ConnectionProvider接口) 　　<br>.事务管理 (TransactionFactory, Transaction, 和 TransactionManagerLookup 接口) 　　<br>· ORM 策略 (ClassPersister 接口) 　　<br>· 属性访问策略 (PropertyAccessor 接口) 　　<br>· 代理对象的创建 (ProxyFactory接口) 　　<br>Hibernate为以上所列的机制分别创建了一个缺省的实现，因此如果你只是要增强它的某个策略的功能的话，只需简单地继承这个类就可以了，没有必要从头开始写代码。<br>Hibernate运行在两种环境下：可管理环境和不可管理环境 　　<br>· 可管理环境――这种环境可管理如下资源：池资源管理，诸如数据库连接池和，还有事务管理、安全定义。一些典型的J2EE服务器（JBoss、Weblogic、WebSphere）已经实现了这些。 　　<br>· 不可管理环境――只是提供了一些基本的功能，诸如像Jetty或Tomcat这样的servlet容器环境。<br>优点：<br>Hibernate是JDBC的轻量级的对象封装，它是一个独立的对象持久层框架。Hibernate可以用在任何JDBC可以使用的场合，例如Java应用程序的数据库访问代码，DAO接口的实现类，甚至可以是BMP里面的访问数据库的代码。<br>Hibernate是一个和JDBC密切关联的框架，所以Hibernate的兼容性和JDBC驱动，和数据库都有一定的关系，但是和使用它的Java程序，和App Server没有任何关系，也不存在兼容性问题。<br>Hibernate不能用来直接和Entity Bean做对比，只有放在整个J2EE项目的框架中才能比较。并且即使是放在软件整体框架中来看，Hibernate也是做为JDBC的替代者出现的，而不是Entity Bean的替代者出现的，<br>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。<br>Hibernate可以应用在任何使用JDBC的场合。<br>Hibernate 使用 Java 反射机制 而不是字节码增强程序来实现透明性。<br>Hibernate 的性能非常好，因为它是个轻量级框架。 映射的灵活性很出色。<br>它支持各种关系数据库，从一对一到多对多的各种复杂关系。<br>缺点：它限制您所使用的对象模型。(例如，一个持久性类不能映射到多个表)。<br>让我再列一次我已经列n次的框架结构：<br>传统的架构：1. Session Bean &lt;-&gt; Entity Bean &lt;-&gt; DB<br>为了解决性能障碍的替代架构：<br>2. Session Bean &lt;-&gt; DAO &lt;-&gt; JDBC &lt;-&gt; DB<br>使用Hibernate来提高上面架构的开发效率的架构：<br>3. Session Bean &lt;-&gt; DAO &lt;-&gt; Hibernate &lt;-&gt; DB<br>就上面3个架构来分析：<br>1、内存消耗：采用JDBC的架构2无疑是最省内存的，Hibernate的架构次之，EB的架构1最差。<br>2、运行效率：如果JDBC的代码写的非常优化，那么JDBC架构运行效率最高，但是实际项目中，这一点几乎做不到，这需要程序员非常精通JDBC，运用Batch语句，调整PreapredStatement的Batch Size和Fetch Size等参数，以及在必要的情况下采用结果集cache等等。而一般情况下程序员是做不到这一点的。因此Hibernate架构表现出最快的运行效率。EB的架构效率会差的很远。<br>3、开发效率：在有JBuilder的支持下以及简单的项目，EB架构开发效率最高，JDBC次之，Hibernate最差。但是在大的项目，特别是持久层关系映射很复杂的情况下，Hibernate效率高的惊人，JDBC次之，而EB架构很可能会失败。3.介绍FREEMARK技术 URLWRITE技术<br>FreeMarker允许Java servlet保持图形设计同应用程序逻辑的分离，这是通过在模板中密封HTML完成的。模板用servlet提供的数据动态地生成 HTML。模板语言是强大的直观的，编译器速度快，输出接近静态HTML页面的速度。<br>　　FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯Java编写<br>　　FreeMarker被设计用来生成HTML Web页面，特别是基于MVC模式的应用程序<br>　　虽然FreeMarker具有一些编程的能力，但通常由Java程序准备要显示的数据，由FreeMarker生成页面，通过模板显示准备的数据<br>　　FreeMarker不是一个Web应用框架，而适合作为Web应用框架一个组件<br>　　FreeMarker与容器无关，因为它并不知道HTTP或Servlet；FreeMarker同样可以应用于非Web应用程序环境<br>　　FreeMarker更适合作为Model2框架（如Struts）的视图组件，你也可以在模板中使用JSP标记库<br>　　FreeMarker是免费的把动态的地址转换成静态的地址，增大搜索引擎化，我解释的不是很明白，大致就是这样的吧， 下面给大家一个小例子，大家需要帮助多的看看。。indexx.jsp:&lt;%@ page language&#x3D;”java” import&#x3D;”java.util.*“ pageEncoding&#x3D;”UTF-8”%&gt;<br>urlrewrite.xml :(和web.xml同级)&lt;?xml version&#x3D;”1.0” encoding&#x3D;”utf-8”?&gt;&lt;!DOCTYPE urlrewrite PUBLIC “-&#x2F;&#x2F;tuckey.org&#x2F;&#x2F;DTD UrlRewrite 3.0&#x2F;&#x2F;EN”<br>“<a target="_blank" rel="noopener" href="http://tuckey.org/res/dtds/urlrewrite3.0.dtd&quot;">http://tuckey.org/res/dtds/urlrewrite3.0.dtd&quot;</a>&gt;&lt;urlrewrite&gt;<rule><br><from>&#x2F;world&#x2F;(\w+)&#x2F;(\w+)</from><br><to>&#x2F;indexx.jsp?country&#x3D;$1&amp;city&#x3D;$2</to><br></rule>&lt;&#x2F;urlrewrite&gt;web.xml: &lt;display-name&gt;url rewrite filter build&lt;&#x2F;display-name&gt; &lt;description&gt;build context&lt;&#x2F;description&gt;<filter><br><filter-name>UrlRewriteFilter</filter-name><br><filter-class>org.tuckey.web.filters.urlrewrite.UrlRewriteFilter</filter-class><br><init-param><br><param-name>confReloadCheckInterval</param-name><br><param-value>30</param-value><br></init-param><br><init-param><br><param-name>logLevel</param-name><br><param-value>DEBUG</param-value><br></init-param><br><init-param><br><param-name>statusEnabled</param-name><br><param-value>true</param-value><br></init-param><br><init-param><br><param-name>statusPath</param-name><br><param-value>&#x2F;status</param-value><br></init-param><br></filter><br><filter-mapping><br><filter-name>UrlRewriteFilter</filter-name><br><url-pattern>&#x2F;*</url-pattern><br></filter-mapping>4.C&#x2F;S与B&#x2F;S的区别<br>C&#x2F;S是Client&#x2F;Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。B&#x2F;Ｓ是Brower&#x2F;Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。C&#x2F;S 与 B&#x2F;S 区别：<br>１．硬件环境不同: C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；　B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C&#x2F;S更强的适应范围, 一般只要有操作系统和浏览器就行<br>２．对安全要求不同 ：C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C&#x2F;S 结构适宜. 可以通过B&#x2F;S发布部分可公开信息.B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同 ：　C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.　B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上.<br>４．软件重用不同： C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在B&#x2F;S要求下的构件的重用性好.　B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。<br>５．系统维护不同 ：C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统，　B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级.<br>６．处理问题不同 ：C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C&#x2F;S无法作到的. 与操作系统平台关系最小.<br>７．用户接口不同： C&#x2F;S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本.<br>８．信息流不同 ：　C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B&#x2F;S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心。5.怎么布署项目（不在MYECLIPSE下部署）到外网<br>在Tomcat中部署Java Web应用程序在Tomcat中部署Java Web应用程序有两种方式：静态部署和动态部署。在下文中<code>$CATALINA_HOME指的是Tomcat根目录。 一、静态部署 静态部署指的是我们在服务器启动之前部署我们的程序，只有当服务器启动之后，我们的Web应用程序才能访问。以下3中方式都可以部署： 1、将PetWeb目录拷贝到$</code>CATALINA_HOME\webapps下，然后启动服务器就可以了。这种方式比较简单，但是web应用程序必须在webapps目录下。访问地址如下：<br><a target="_blank" rel="noopener" href="http://localhost:8080/PetWeb/">http://localhost:8080/PetWeb/</a><br>2、这种方式可以不必将PetWeb目录拷贝到webapps下，直接在F:\部署。方法如下，更改<code>$CATALINA_HOME\conf\server.xml文件，在&lt;host&gt;标签内添加&lt;Context&gt;标签，内容如下： &lt;Context docBase=&quot;F:/PetWeb&quot; reloadable=&quot;false&quot; path=&quot;/Pet&quot;/&gt; 其中reloadable=&quot;false&quot;表示当应用程序中的内容发生更改之后服务器不会自动加载，这个属性在开发阶段通常都设为true，方便开发，在发布阶段应该设置为false，提高应用程序的访问速度。docBase为路径，可以使用绝对路径，也可以使用相对路径，相对路径相对于webapps。path属性的值是访问时的根地址。访问地址如下：http://localhost:8080/Pet/ 3、这种方式和第二种方式差不多，但是不是在Server.xml文件中添加Context标签，而是在$</code>CATALINA_HOME\conf\Catalina\localhost中添加一个xml文件，如Pet.xml，内容如下： &lt;Context docBase&#x3D;”F:&#x2F;PetWeb” reloadable&#x3D;”false” &#x2F;&gt;大家可能发现和第二种方式差不多，但是缺少了path属性，这种方式服务器会使用.xml的名字作为path属性的值。访问地址如下：<a target="_blank" rel="noopener" href="http://localhost:8080/Pet/">http://localhost:8080/Pet/</a> 我们刚才是将PetWeb文件夹部署在了服务器中，我们知道可以将Web应用程序的内容打成.war包，然后在部署在服务器上。打包请参考如下步骤：<br>1、打开命令提示符（Start–&gt;Run–&gt;cmd）<br>2、设置jdk环境变量（如果我教过的学生不会配置，以后别说孙老师教过你）<br>3、在命令提示符中进入F:\PetWeb文件后，键入如下命令：jar ..\Pet.war <em>.</em> 这样在F:\下应该有Pet.war文件。其中..表示当前目录的父目录。<br>部署Pet.war文件非常简单，将刚才有docBase&#x3D;”F:\PetWeb”更改为docBase&#x3D;”F:\Pet.war”或者直接将其拷贝到 webapps下也可以。重新启动服务器就可以将Pet.war部署为一个Web应用程序了。如果你够细心的话你会发现，服务器将Pet.war文件解开，并且在webapps下面又生成了一个Pet文件夹，然后把Pet.war的内容拷贝到里面去了。我们可以通过以下方式取消自动解压缩，配置方式如下： &lt;Context docBase&#x3D;”F:&#x2F;PetWeb” reloadable&#x3D;”false” unpackWAR&#x3D;”false”&#x2F;&gt;<br>二、动态部署<br>动态部署是指可以在服务器启动之后部署web应用程序，而不用重新启动服务器。动态部署要用到服务器提供的manager.war文件，如果在<code>$CATALINA_HOME\webapps\下没有该文件，你必须去重新下载tomcat，否则不能完成以下的功能。要想使用该管理程序必须首先编辑$</code>CATALINA_HOME\conf\tomcat-users.xml文件，内容如下：关于这个文件的更多内容，请参考Java Web应用程序的安全模型二 &lt;tomcat-users&gt; &lt;role rolename&#x3D;”tomcat”&#x2F;&gt; &lt;role rolename&#x3D;”role1”&#x2F;&gt; &lt;role rolename&#x3D;”manager”&#x2F;&gt; &lt;user username&#x3D;”coresun” password&#x3D;”coresun” roles&#x3D;”manager”&#x2F;&gt; &lt;user username&#x3D;”tomcat” password&#x3D;”tomcat” roles&#x3D;”tomcat”&#x2F;&gt; &lt;user username&#x3D;”both” password&#x3D;”tomcat” roles&#x3D;”tomcat,role1”&#x2F;&gt; &lt;user username&#x3D;”role1” password&#x3D;”tomcat” roles&#x3D;”role1”&#x2F;&gt; &lt;&#x2F;tomcat-users&gt;<br>然后在浏览器中键入如下地址：<br><a target="_blank" rel="noopener" href="http://localhost:8080/%E5%BA%94%E8%AF%A5%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%8A%A0%E8%8F%B2%E7%8C%AB%E4%BA%86%E5%90%A7%E3%80%82%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%E7%9A%84Tomcat">http://localhost:8080/应该看到一个漂亮的加菲猫了吧。点击左边的Tomcat</a> Manager链接，提示输入用户名和密码，本文都是coresun，然后可以看到以下页面：<br>在Context Path(option):中输入&#x2F;Pet<br>XML Configration file URL中要指定一个.xml文件，比如我们在F:\下建立一个Pet.xml文件，内容如下： &lt;Context reloadable&#x3D;”false” &#x2F;&gt;docBase不用写了，因为在下一个文本框中填入。或者更简单点，这个文本框什么都不填。<br>在WAR or Directory URL:中键入F:\PetWet或者F:\Pet.war都可以，然后点击Deploy按钮，看看上面是不是已经看到了你web应用程序，名字就是你Context Path(option):中的名字。如果你部署.war文件还有更加简单的方式，下面还有个Select WAR file uploae点击浏览选择.war文件，然后点击Deploy也可以6.为什么要使用HIBERMATE框架，描述HIBERMATE的映射（如一对的 多对的）SSH中的H指的就是Hibernate ，这个已经被炒烂了的o&#x2F;r mapping的开源项目，那为什么我们在项目中的和数据库交互的那块操作（说的书面点就是持久化部分）要用它了，它比我们以前用的JDBC的硬编码或是 使用了DTO（POJO），DAO这样的模式的模块又好在哪里了？（当然JDBC硬编码的做法确实比较ugly,现在这样做的也比较少了吧）<br>要想说清这个，当然有很多种说法，观点也不尽一致，所以我们先来看看HIbernate具体都有些什么，我们怎么来使用它，然后再对比和分析。<br>Hibernate既然是持久化的框架，干得自然是和数据库打交道的事，所以其概念和使用上应该不难，但是其文档（中文）也有200多页，可以看出其内容 还是不少（在这里向翻译文档的团队表示感谢，呵呵）。从整体上看要使用它需要两种配置文件，一个是hibernate.cfg.xml，它是与数据库连接 的配置文件（事务类型也是在其中配置的），支持普通的JDBC连接，也支持使用JNDI的数据源连接，它是放在class-path下；另一个配置文件是 xxx.hbm.xml，它是某个POJO和一个或多个数据库表的对应关系的配置文件，也即是o&#x2F;r映射的配置文件，也是放在class-path下，而 且在hibernate.cfg.xml中要引入这些xxx.hbm.xml。<br>我们在代码阶段要先new一个Configuration，它需要载入hibernate.cfg.xml；然后根据这个Configuration build出一个SessionFactory，注意当sessionFactory建立后，如果在改动configuration, sessionFactory不会受影响，而且sessionFactory的建立是很耗资源的，所以我们对一个数据库的应用应该只创建一个 SessionFactory。如果我们的操作要涉及多个库，我们可以配置多个hibernate.cfg.xml，从而生成多个 Configuration，进而创建多个SessionFactory。<br>当得到SessionFactory后我们就可以建立Session对象了，我个人感觉Session有点像JDBC中的Connection和 Statement的混合，因为它确实是和数据库连接的一个具体实例，同时它下面有save,update等方法，可以操作数据库，所以又不单单是个 Connection，也有Statement的意思。得到了Session后，我们通过它下面的各种方法，就可以完成对对象的CRUD，那在 hibernate中对象和数据库表之间是有对应关系的，所以通过对对象的操作，hibernate自动完成对数据库表的操作，它底层也是通过JDBC的 PreparedStatement来完成的。<br>但在hibernate3.x以后情况又有些不同了，在3.x中，HQL的功能加强了很多，具有了update,delete的功能，再加上 Session的find方法的取消，所以对于Query的使用越来越多，于是Session就越来越像Connection了。HQL很像传统的SQL 语言，但它们两者还是有很明显的不同，SQL面向的是二维的结构化的数据，而HQL则是面向的数据对象。<br>HQL中包括简单的实体查询，对象属性的查询（相当于SQL 中的select某几个字段），分组和排序，where条件查询（注意在这里，我们为了避免sql injection问题，对于条件变量要采用现在HQL语句中用占位符的方法，再set进去，相当于PrepareStatement），联合查询 （SQL中的join) ，子查询，删除和修改。对于HQL，我们还可以在配置文件中写，然后通过代码找到，不用再代码中直接写HQL字符串。另外有一点要说明的是我们如果要调用 存储过程，则相对麻烦而且只能调用带返回结果集的存储过程，简单的做法是不用hibernate的API来做，我们可以通过Session得到 Connection对象，从而按照JDBC的方式来调用，本身hibernate并不提倡用存储过程 ，它认为存储过程和具体的DBMS有很强的耦合性。。hibernate3中还提供了一个Criteria的对象来进行查询工作，它本身只是一个查询容 器，具体的查询条件要通过Criteria.add方法来添加到对象中。不过其功能现在没有HQL强。而且在hibernate3中还提供了一个 Criteria的实现–DetachedCriteria，它可以脱离Session实例独立存在，具体的就不多说了，用到的时候看看文档吧。<br>由以上的知识点我们不能看出hibernate是比较简单和容易使用的，但事实并不完全是这样，我们知道o&#x2F;r mapping中，数据库表是二维的关系型数据库表，而我们的POJO是面向对象的结构（面向对象的特点有封装，继承，多态），这两者之间的映射并不是那 么简单，下面我们来看一下hibernate中比较难的那个方面。<br>一个是复杂的实体映射，另一个是数据关联int 和 Integer 有什么区别<br>1.Integer 是对象类型 int是原始类型<br>适用场合有很大的不同 之所以要把int封装成Integer 型 是因为<br>很多方法参数就只接收对象类型(Object)<br>还比如 范型 就只支持 对象类型<br>2.如果在数据库操作中某数值列允许为null的话，那接受该列数据的类型就只能为<br>Integer，而不能为int，所以在一般性的持久化对象中尽量少地使用基本类型，<br>除非确定它不会为空。<br>3.类可以是null 但是基本数据类型不能为空<br>Ingeter i&#x3D;null; int j&#x3D;i;<br>对象的比较不能用＝＝号了 呵呵<br>Integer i＝0; Integer j&#x3D;0;<br>但是 i!&#x3D;j<br>虽然你说你执行了以下这个程序：<br>public static void main(String[] args) {<br>Integer b &#x3D; 0;<br>int c &#x3D; 0;<br>if (b &#x3D;&#x3D; c) {<br>System.out.println(true);<br>} else {<br>System.out.println(false);<br>}<br>输出的结果为true，但并不意味这他们两个不同类型的值就相等，是因为其过程中系统自动拆箱造成的，b&#x3D;&#x3D;c的时候java自动拆箱了,最后比较的是两个int下列说法错误的有（c ）<br>A． 能被java.exe成功运行的java class文件必须有main()方法<br>B． J2SDK就是Java API<br>C． Appletviewer.exe可利用jar选项运行.jar文件判断题<br>Java程序中的起始类名称必须与存放该类的文件名相同。　　<br>Unicode是用16位来表示一个字的吗。√×　　<br>原生类中的数据类型均可任意转换吗。　机试题：<br>1.新闻查询Web程序要求：<br>使用 MVC设计模式，运用jsp、Bean及Servlet，结合jdbc制作一个简单的新闻查询Web程序。<br>需要进行查询的新闻如下所示：新闻标题	发布时间	新闻内容<br>微软向非洲支援二手电脑	2005-06-09 15:49:00	微软在最近宣布它正计划向非洲国家提供技术帮助，以加速该地区的数字化进程。据悉，微软已经与纳米比亚政府达成了协议，将在两年内向该国13所学校提供从发达国家淘汰的二手电脑，这些电脑将运行Windows系统，可以登录Google、雅虎等热门网站，不过微软并没有透露出售Windows系统给这些学校的价格。<br>韩国失窃手机大量流入中国	2005-06-09 10:49:44	据韩国信息部提供的消息称，目前已经发现中国商人在韩国以每部400—500元(人民币)的价格收购被盗或丢失的市价1—2万元(人民币)的手机，然后成批走私到中国，以每部3000元以下的价格出售。<br>明基宣布收购西门子手机	2005-06-07 16:50:33	明基7日下午正式对外宣布收购德国西门子手机事业，这起并购将使BenQ成为全球第四大手机品牌、大中华区第一大手机科技公司，合并后公司年营收将超过100亿美元。<br>Google股价飙升	2005-06-03 11:30:20	现今的Google已经成为华尔街的宠儿。上市后的前三个季度里，Google的业绩均超过了分析师的预期。主要竞争对手雅虎和微软都在广告战中大把烧钱，而Google却毫不费力的依靠人们的口口相传继续保持着搜索市场的领先位置。与此同时，Google的股价也一路飙升，目前已较发行价上涨226%，达到227美元。使用jsp制作查询页面，在输入框中输入查询关键字内容，然后将查询关键字提交到servlet进行处理，在bean中制作针对关键字执行查询的部分，并将查询结果返回，最后将查询结果的标题按照时间顺序在结果页面中输出成为规则的列表。点击标题，在弹出的新窗口中显示本条新闻的全部详细内容，包括标题，发布时间，以及新闻内容。注意：本题目的重点在于提交查询关键字时，要求可以同时提交多项关键字，每项关键字之间用空格间隔，查询结果范围为全部满足多项关键字的条目，也就是说，假如同时提出了三个关键字，那么只有在标题或内容中都能够找到这三个查询关键字的条目才会进入查询结果。提交的关键字越多，查询出来的结果就越少，如果由于提交的关键字太多，造成没有条目符合查询请求，就需要在页面中显示“查询无结果”字样，不能造成异常。<br>create table t_news<br>(<br>id int primary key,<br>title char(20),<br>pubTime Date,<br>cont char(50)<br>)其他1. 什么是幂等？什么情况下需要考虑幂等？你怎么解决幂等的问题？<br>Java<br>2. 多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决<br>并发的问题？你会选择加什么样的锁？<br>3. JAVA的AQS是否了解，它是⼲嘛的？<br>4. 除了synchronized关键字之外，你是怎么来保障线程安全的？<br>5. 什么时候需要加volatile关键字？它能保证线程安全吗？<br>6. 线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部<br>塞满了之后，还是忙，再提交会发⽣什么？<br>7. Tomcat本身的参数你⼀般会怎么调整？<br>8. synchronized关键字锁住的是什么东⻄？在字节码中是怎么表示的？在内<br>存中的对象上表现为什么？<br>9. wait&#x2F;notify&#x2F;notifyAll⽅法需不需要被包含在synchronized块中？这是为什<br>么？<br>10. ExecutorService你⼀般是怎么⽤的？是每个service放⼀个还是⼀个项⽬<br>⾥⾯放⼀个？有什么好处？<br>Spring<br>11. 你有没有⽤过Spring的AOP? 是⽤来⼲嘛的? ⼤概会怎么使⽤？<br>12. 如果⼀个接⼝有2个不同的实现, 那么怎么来Autowire⼀个指定的实现？<br>13. Spring的声明式事务 @Transaction注解⼀般写在什么位置? 抛出了异常<br>会⾃动回滚吗？有没有办法控制不触发回滚?<br>14. 如果想在某个Bean⽣成并装配完毕后执⾏⾃⼰的逻辑，可以什么⽅式实<br>现？<br>15. SpringBoot没有放到web容器⾥为什么能跑HTTP服务？<br>16. SpringBoot中如果你想使⽤⾃定义的配置⽂件⽽不仅仅是<br>application.properties，应该怎么弄？<br>17. SpringMVC中RequestMapping可以指定GET, POST⽅法么？怎么指定？<br>18. SpringMVC如果希望把输出的Object(例如XXResult或者XXResponse)这<br>种包装为JSON输出, 应该怎么处理?<br>19. 怎样拦截SpringMVC的异常，然后做⾃定义的处理，⽐如打⽇志或者包装<br>成JSON<br>MySQL<br>20. 如果有很多数据插⼊MYSQL 你会选择什么⽅式?<br>21. 如果查询很慢，你会想到的第⼀个⽅式是什么？索引是⼲嘛的?<br>22. 如果建了⼀个单列索引，查询的时候查出2列，会⽤到这个单列索引吗？<br>23. 如果建了⼀个包含多个列的索引，查询的时候只⽤了第⼀列，能不能⽤上<br>这个索引？查三列呢？<br>24. 接上题，如果where条件后⾯带有⼀个 i + 5 &lt; 100 会使⽤到这个索引吗？<br>25. 怎么看是否⽤到了某个索引？<br>26. like %aaa%会使⽤索引吗? like aaa%呢?<br>27. drop、truncate、delete的区别？<br>28. 平时你们是怎么监控数据库的? 慢SQL是怎么排查的？<br>29. 你们数据库是否⽀持emoji表情，如果不⽀持，如何操作?<br>30. 你们的数据库单表数据量是多少？⼀般多⼤的时候开始出现查询性能急<br>剧下降？<br>31. 查询死掉了，想要找出执⾏的查询进程⽤什么命令？找出来之后⼀般你<br>会⼲嘛？<br>32. 读写分离是怎么做的？你认为中间件会怎么来操作？这样操作跟事务有<br>什么关系？<br>33. 分库分表有没有做过？线上的迁移过程是怎么样的？如何确定数据是正<br>确的？<br>JVM<br>34. 你知道哪些或者你们线上使⽤什么GC策略? 它有什么优势，适⽤于什么<br>场景？<br>35. JAVA类加载器包括⼏种？它们之间的⽗⼦关系是怎么样的？双亲委派机<br>制是什么意思？有什么好处？<br>36. 如何⾃定义⼀个类加载器？你使⽤过哪些或者你在什么场景下需要⼀个⾃<br>定义的类加载器吗？<br>37. 堆内存设置的参数是什么？<br>38. Perm Space中保存什么数据? 会引起OutOfMemory吗？<br>39. 做gc时，⼀个对象在内存各个Space中被移动的顺序是什么？<br>40. 你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理<br>过程中有哪些收获？<br>41. 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是<br>你们会通过什么⽅式来指定⼤⼩?<br>42. Jstack是⼲什么的? Jstat呢? 如果线上程序周期性地出现卡顿，你怀疑可<br>能是gc导致的，你会怎么来排查这个问题？线程⽇志⼀般你会看其中的什么<br>部分？<br>43. StackOverFlow异常有没有遇到过？⼀般你猜测会在什么情况下被触<br>发？如何指定⼀个线程的堆栈⼤⼩？⼀般你们写多少？<br>Linux命令<br>44. ⽇志特别⼤只想看最后100⾏怎么弄? 如果想⼀直看⽇志的持续输出，⽤<br>什么命令?<br>45. 如果⽇志⼀边输出，⼀边想实时看到有没有某个关键字应该怎么弄？<br>46. grep如果忽略⼤⼩写应该怎么弄? 正则表达式呢？<br>47. vim往下⼀⾏是什么键？往下30⾏呢? 跳到⽂件末尾⼀⾏是什么? 跳回来<br>是什么? 向后搜索是什么?<br>48. 如果有个⽂本⽂件，按空格作为列的分隔符，如果想统计第三列⾥⾯的每<br>个单词的出现次数应该怎么弄？<br>49. 如果把上⾯的出现次数排个序应该怎么弄? 想按照数字本身的顺序⽽不是<br>字符串的顺序排列怎么弄？<br>50. Linux环境变量是以什么作为分隔符的？环境变量通过什么命令设置？<br>51. 给某个⽂件权设置限⽐如设置为644 是⽤什么命令？这个6是什么意思？<br>52. Linux下⾯如果想看某个进程的资源占⽤情况是怎么看的？系统load⼤概<br>指的什么意思？你们线上系统load⼀般多少？如果⼀个4核机器，你认为多<br>少load是⽐较正常的？top命令⾥⾯按⼀下1会发⽣什么?<br>53. top命令⾥⾯，有时候所有进程的CPU使⽤率加起来超过100%是怎么回<br>事？<br>54. 还有哪些查看系统性能或者供你发现问题的命令？你⼀般是看哪个参<br>数？<br>55. 想看某个进程打开了哪些⽹络连接是什么命令？⾥⾯连接的状态你⽐较<br>关⼼哪⼏种？<br>-- 偏题<br>56. 有没有做过Linux系统参数⽅⾯的优化，⼤概优化过什么？<br>57. 系统参数⾥⾯有个叫做backlog的可以⽤来⼲什么？<br>58. 查看⽹络连接发现好多TIME_WAIT 可能是什么原因？对你的应⽤会有什<br>么影响？你会选择什么样的⽅式来减少这些TIME_WAIT<br>59. 可否介绍⼀下TCP三次握⼿的过程，如果现在有个⽹络程序，你⽤第三⽅<br>的library来发送数据，你怀疑这个library发送的数据有问题，那么怎么来验<br>证？tcpdump导出的⽂件你⼀般是怎么分析的？<br>60. KeepAlive是⽤来⼲什么的？这样的好处是什么？<br>Redis<br>-- 开发<br>61. 缓存穿透可以介绍⼀下么？你认为应该如何解决这个问题<br>62. 你是怎么触发缓存更新的？(⽐如设置超时时间(被动⽅式), ⽐如更新的时<br>候主动update)？如果是被动的⽅式如何控制多个⼊⼝同时触发某个缓存更<br>新？<br>63. 你们⽤Redis来做什么？为什么不⽤其他的KV存储例如Memcached,<br>Cassandra等?<br>64. 你们⽤什么Redis客户端? Redis⾼性能的原因⼤概可以讲⼀些?<br>65. 你熟悉哪些Redis的数据结构? zset是⼲什么的? 和set有什么区别?<br>66. Redis的hash, 存储和获取的具体命令叫什么名字?<br>67. LPOP和BLPOP的区别?<br>68. Redis的有⼀些包含SCAN关键字的命令是⼲嘛的? SCAN返回的数据量是<br>固定的吗?<br>69. Redis中的Lua有没有使⽤过? 可以⽤来做什么? 为什么可以这么⽤?<br>70. Redis的Pipeline是⽤来⼲什么的?<br>-- 运维<br>71. Redis持久化⼤概有⼏种⽅式? aof和rdb的区别是什么? AOF有什么优缺<br>点吗?<br>72. Redis Replication的⼤致流程是什么? bgsave这个命令的执⾏过程?<br>-- 偏题<br>73. 如果有很多 KV数据要存储到Redis, 但是内存不⾜, 通过什么⽅式可以缩<br>减内存? 为什么这样可以缩⼩内存?<br>74. Redis中List, HashTable都⽤到了ZipList, 为什么会选择它?<br>监控、稳定性<br>75. 业务⽇志是通过什么⽅式来收集的？<br>76. 线上机器如何监控？采⽤什么开源产品或者⾃研的产品？它是分钟级的还<br>是秒级的？<br>77. 如果让你来想办法收集⼀个JAVA后端应⽤的性能数据，你会在意哪些⽅<br>⾯? 你会选择什么样的⼯具、思路来收集?<br>78. ⼀般你调⽤第三⽅的时候会不会监控调⽤情况？java 基于TCP协议的Socket编程和通信<br>在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)程序，简称客户端，而在第一次通讯中等待连接的程序被称作服务器端(Server)程序，简称服务器。一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。<br>“请求-响应”模式：1. Socket类：发送TCP消息。<br>2. ServerSocket类：创建服务器。<br>套接字是一种进程间的数据交换机制。这些进程既可以在同一机器上，也可以在通过网络连接的不同机器上。换句话说，套接字起到通信端点的作用。单个套接字是一个端点，而一对套接字则构成一个双向通信信道，使非关联进程可以在本地或通过网络进行数据交换。一旦建立套接字连接，数据即可在相同或不同的系统中双向或单向发送，直到其中一个端点关闭连接。套接字与主机地址和端口地址相关联。主机地址就是客户端或服务器程序所在的主机的IP地址。端口地址是指客户端或服务器程序使用的主机的通信端口。<br>在客户端和服务器中，分别创建独立的Socket，并通过Socket的属性，将两个Socket进行连接，这样，客户端和服务器通过套接字所建立的连接使用输入输出流进行通信。<br>TCP&#x2F;IP套接字是最可靠的双向流协议，使用TCP&#x2F;IP可以发送任意数量的数据。<br>实际上，套接字只是计算机上已编号的端口。如果发送方和接收方计算机确定好端口，他们就可以通信了。<br>如图所示为客户端与服务器端的通信关系图：TCP&#x2F;IP通信连接的简单过程：<br>位于A计算机上的TCP&#x2F;IP软件向B计算机发送包含端口号的消息，B计算机的TCP&#x2F;IP软件接收该消息，并进行检查，查看是否有它知道的程序正在该端口上接收消息。如果有，他就将该消息交给这个程序。<br>要使程序有效地运行，就必须有一个客户端和一个服务器。<br>通过Socket的编程顺序：1. 创建服务器ServerSocket，在创建时，定义ServerSocket的监听端口(在这个端口接收客户端发来的消息)。<br>2. ServerSocket调用accept()方法，使之处于阻塞状态。<br>3. 创建客户端Socket，并设置服务器的IP及端口。<br>4. 客户端发出连接请求，建立连接。<br>5. 分别取得服务器和客户端Socket的InputStream和OutputStream。<br>6. 利用Socket和ServerSocket进行数据传输。<br>7. 关闭流及Socket。<br>【示例12-7】TCP：单向通信Socket之服务器端</p><p>【示例12-8】TCP：单向通信Socket之客户端</p><p>【示例12-9】TCP：双向通信Socket之服务器端</p><p>【示例12-10】TCP：双向通信Socket之客户端</p><p>执行结果如图所示菜鸟雷区<br>运行时，要先启动服务器端，再启动客户端，才能得到正常的运行效果。<br>但是，上面这个程序，必须按照安排好的顺序，服务器和客户端一问一答!不够灵活!!可以使用多线程实现更加灵活的双向通讯!!<br>服务器端：一个线程专门发送消息，一个线程专门接收消息。<br>客户端：一个线程专门发送消息，一个线程专门接收消息。<br>【示例12-11】TCP：聊天室之服务器端<br>【示例12-12】TCP：聊天室之客户端<br>执行结果如图所示：<br>44. JVM<br>(1) 基本概念：<br>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、<br>一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接<br>的交互。<br>(2) 运行过程：<br>13&#x2F;04&#x2F;2018 Page 20 of 283<br>我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，<br>而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。<br>也就是如下：<br>① Java 源文件—-&gt;编译器—-&gt;字节码文件<br>② 字节码文件—-&gt;JVM—-&gt;机器码<br>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够<br>跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会<br>存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不<br>能共享。<br>2.1.线程<br>这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。<br>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓<br>冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。<br>Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可<br>用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，<br>13&#x2F;04&#x2F;2018 Page 21 of 283<br>会释放原生线程和 Java 线程的所有资源。<br>Hotspot JVM 后台运行的系统线程主要有下面几个：<br>虚拟机线程<br>（VM thread）<br>这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当<br>堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-the￾world 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。<br>周期性任务线程 这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。<br>GC 线程 这些线程支持 JVM 中不同的垃圾回收活动。<br>编译器线程 这些线程在运行时将字节码动态编译成本地平台相关的机器码。<br>信号分发线程 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</p><p>2.8. JAVA IO&#x2F;NIO<br>2.8.1. 阻塞 IO 模型<br>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内<br>核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用<br>户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用<br>13&#x2F;04&#x2F;2018 Page 35 of 283<br>户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data &#x3D; socket.read();如果数据没有就<br>绪，就会一直阻塞在 read 方法。<br>2.8.2. 非阻塞 IO 模型<br>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个<br>error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备<br>好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO<br>不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：<br>while(true){<br>data &#x3D; socket.read();<br>if(data!&#x3D; error){<br>处理数据<br>break;<br>}<br>}<br>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就<br>绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。<br>2.8.3. 多路复用 IO 模型<br>多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO<br>模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真<br>正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个<br>socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有<br>socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通<br>过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这<br>种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当<br>socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连<br>接数比较多的情况。<br>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态<br>时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效<br>率要比用户线程要高的多。<br>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件<br>逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件<br>迟迟得不到处理，并且会影响新的事件轮询。<br>13&#x2F;04&#x2F;2018 Page 36 of 283<br>2.8.4. 信号驱动 IO 模型<br>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函<br>数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到<br>信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。<br>2.8.5. 异步 IO 模型<br>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就<br>可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，<br>它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内<br>核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程<br>发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何<br>进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接<br>去使用数据了。<br>也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完<br>成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的<br>读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据<br>已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号<br>表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。<br>注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。<br>更多参考： <a target="_blank" rel="noopener" href="http://www.importnew.com/19816.html">http://www.importnew.com/19816.html</a><br>2.8.1. JAVA IO 包<br>13&#x2F;04&#x2F;2018 Page 37 of 283<br>2.8.2. JAVA NIO<br>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统 IO 基于字节流和字<br>符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区<br>中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，<br>数据到达）。因此，单个线程可以监听多个数据通道。<br>13&#x2F;04&#x2F;2018 Page 38 of 283<br>NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。<br>2.8.2.1. NIO 的缓冲区<br>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何<br>地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓<br>存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在<br>缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所<br>有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的<br>数据。<br>2.8.2.2. NIO 的非阻塞<br>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有<br>一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，<br>使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可<br>用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以<br>继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它<br>完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上<br>执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。<br>13&#x2F;04&#x2F;2018 Page 39 of 283<br>13&#x2F;04&#x2F;2018 Page 40 of 283<br>2.8.3. Channel<br>首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个<br>等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向<br>的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有：<br>55. FileChannel<br>56. DatagramChannel<br>57. SocketChannel<br>58. ServerSocketChannel<br>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。<br>下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。<br>2.8.4. Buffer<br>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、<br>网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。<br>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送<br>数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必<br>须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。<br>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：<br>ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、<br>ShortBuffer<br>2.8.5. Selector<br>Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事<br>件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可<br>以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用<br>函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护<br>多个线程，并且避免了多线程之间的上下文切换导致的开销。<br>71. JAVA 集合<br>3.1.接口继承关系和实现<br>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。<br>72. Collection：Collection 是集合 List、Set、Queue 的最基本的接口。<br>73. Iterator：迭代器，可以通过迭代器遍历集合中的数据<br>74. Map：是映射表的基础接口<br>13&#x2F;04&#x2F;2018 Page 46 of 283<br>13&#x2F;04&#x2F;2018 Page 47 of 283<br>3.2.List<br>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类：<br>分别是 ArrayList、Vector 和 LinkedList。<br>3.2.1. ArrayList（数组）<br>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数<br>组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数<br>组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进<br>行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br>3.2.2. Vector（数组实现、线程同步）<br>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一<br>个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，<br>访问它比访问 ArrayList 慢。<br>3.2.3. LinkList（链表）<br>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较<br>慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆<br>栈、队列和双向队列使用。<br>13&#x2F;04&#x2F;2018 Page 48 of 283<br>3.3.Set<br>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重<br>复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断<br>的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方<br>法。<br>3.3.1.1. HashSet（Hash 表）<br>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不<br>同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的<br>hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较<br>equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是<br>同一个元素。<br>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相<br>同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情<br>况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。<br>13&#x2F;04&#x2F;2018 Page 49 of 283<br>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元<br>素。<br>3.3.1.2. TreeSet（二叉树）<br>75. TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增<br>加一个对象都会进行排序，将对象插入的二叉树指定的位置。<br>76. Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自<br>己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使<br>用。<br>77. 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序<br>78. 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整<br>数、零或正整数。<br>3.3.1.3. LinkHashSet（HashSet+LinkedHashMap）<br>对 于 LinkedHashSet 而 言 ， 它 继 承与 HashSet、 又 基于 LinkedHashMap 来 实 现的 。<br>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法<br>操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并<br>通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操<br>作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。<br>13&#x2F;04&#x2F;2018 Page 50 of 283<br>3.4.Map<br>3.4.1. HashMap（数组+链表+红黑树）<br>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快<br>的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记<br>录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导<br>致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使<br>HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍<br>HashMap 的结构。<br>3.4.1.1. JAVA7 实现<br>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色<br>的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。<br>79. capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。<br>80. loadFactor：负载因子，默认为 0.75。<br>13&#x2F;04&#x2F;2018 Page 51 of 283<br>81. threshold：扩容的阈值，等于 capacity * loadFactor<br>3.4.1.2. JAVA8 实现<br>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑<br>树 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的<br>具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决<br>于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，<br>会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br>3.4.2. ConcurrentHashMap<br>3.4.2.1. Segment 段<br>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的<br>意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个<br>segment。<br>3.4.2.2. 线程安全（Segment 继承 ReentrantLock 加锁）<br>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每<br>个 Segment 是线程安全的，也就实现了全局的线程安全。<br>13&#x2F;04&#x2F;2018 Page 52 of 283<br>3.4.2.3. 并行度（默认 16）<br>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，<br>也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支<br>持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时<br>候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实<br>每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。<br>3.4.2.4. Java8 实现 （引入了红黑树）<br>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。<br>13&#x2F;04&#x2F;2018 Page 53 of 283<br>3.4.3. HashTable（线程安全）<br>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，<br>并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，<br>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全<br>的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。<br>3.4.4. TreeMap（可排序）<br>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。<br>参考：<br>3.4.5. LinkHashMap（记录插入顺序）<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。<br>参考 1：<a target="_blank" rel="noopener" href="http://www.importnew.com/28263.html">http://www.importnew.com/28263.html</a><br>参考 2：<a target="_blank" rel="noopener" href="http://www.importnew.com/20386.html#comment-648123">http://www.importnew.com/20386.html#comment-648123</a><br>13&#x2F;04&#x2F;2018 Page 54 of 283<br>4.1.11. 线程上下文切换<br>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存<br>下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做<br>上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。<br>4.1.11.1. 进程<br>（有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且<br>与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量<br>级的进程。<br>4.1.11.2. 上下文<br>是指某一时间点 CPU 寄存器和程序计数器的内容。<br>4.1.11.3. 寄存器<br>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内<br>存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速<br>度。<br>4.1.11.4. 程序计数器<br>是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令<br>的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。<br>4.1.11.5. PCB-“切换桢”<br>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下<br>文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称<br>作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。<br>13&#x2F;04&#x2F;2018 Page 76 of 283<br>4.1.11.6. 上下文切换的活动：<br>58. 挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。<br>59. 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。<br>60. 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序<br>中。<br>4.1.11.7. 引起线程上下文切换的原因<br>61. 当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；<br>62. 当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；<br>63. 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；<br>64. 用户代码挂起当前任务，让出 CPU 时间；<br>65. 硬件中断；</p><p>4.1.14. JAVA 阻塞队列原理<br>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：<br>85. 当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放<br>入队列。<br>86. 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有<br>空的位置，线程被自动唤醒。<br>13&#x2F;04&#x2F;2018 Page 80 of 283<br>4.1.14.1. 阻塞队列的主要方法<br> 抛出异常：抛出一个异常；<br> 特殊值：返回一个特殊值（null 或 false,视情况而定）<br> 则塞：在成功操作之前，一直阻塞线程<br> 超时：放弃前只在最大的时间内阻塞<br>插入操作：<br>1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行<br>且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛<br>出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。<br>2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行<br>且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。<br>3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插<br>入此队列中，将等待可用的空间（如果有必要）<br>public void put(E paramE) throws InterruptedException {<br>checkNotNull(paramE);<br>ReentrantLock localReentrantLock &#x3D; this.lock;<br>localReentrantLock.lockInterruptibly();<br>try {<br>while (this.count &#x3D;&#x3D; this.items.length)<br>this.notFull.await();&#x2F;&#x2F;如果队列满了，则线程阻塞等待<br>enqueue(paramE);<br>13&#x2F;04&#x2F;2018 Page 81 of 283<br>localReentrantLock.unlock();<br>} finally {<br>localReentrantLock.unlock();<br>}<br>}<br>4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间<br>内，还不能往队列中加入 BlockingQueue，则返回失败。<br>获取数据操作：<br>1：poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数<br>规定的时间,取不到时返回 null;<br>2：poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在<br>指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数<br>据可取，返回失败。<br>3：take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状<br>态直到 BlockingQueue 有新的数据被加入。<br>4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个<br>数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。<br>4.1.14.2. Java 中的阻塞队列<br>87. ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。<br>88. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。<br>89. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。<br>90. DelayQueue：使用优先级队列实现的无界阻塞队列。<br>91. SynchronousQueue：不存储元素的阻塞队列。<br>92. LinkedTransferQueue：由链表结构组成的无界阻塞队列。<br>93. LinkedBlockingDeque：由链表结构组成的双向阻塞队列<br>13&#x2F;04&#x2F;2018 Page 82 of 283<br>4.1.14.3. ArrayBlockingQueue（公平、非公平）<br>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下<br>不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当<br>队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入<br>元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐<br>量。我们可以使用以下代码创建一个公平的阻塞队列：<br>ArrayBlockingQueue fairQueue &#x3D; new ArrayBlockingQueue(1000,true);<br>4.1.14.4. LinkedBlockingQueue（两个独立锁提高并发）<br>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对<br>元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者<br>端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费<br>者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。<br>4.1.14.5. PriorityBlockingQueue（compareTo 排序实现优先）<br>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现<br>compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造<br>参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。<br>4.1.14.6. DelayQueue（缓存失效、定时任务 ）<br>是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实<br>现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才<br>能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景：<br>94. 缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询<br>DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。<br>13&#x2F;04&#x2F;2018 Page 83 of 283<br>95. 定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从<br>DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。<br>4.1.14.7. SynchronousQueue（不存储数据、可用于传递数据）<br>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。<br>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线<br>程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给<br>另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和<br>ArrayBlockingQueue。<br>4.1.14.8. LinkedTransferQueue<br>是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，<br>LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。<br>96. transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的<br>poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如<br>果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素<br>被消费者消费了才返回。<br>97. tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费<br>者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否<br>接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。<br>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传<br>入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时<br>还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。<br>4.1.14.9. LinkedBlockingDeque<br>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。<br>双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其<br>他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，<br>peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队<br>列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另<br>外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同<br>于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。<br>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在<br>“工作窃取”模式中。<br>13&#x2F;04&#x2F;2018 Page 84 of 283</p><p>4.1.20. ConcurrentHashMap 并发<br>4.1.20.1. 减小锁粒度<br>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减<br>小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高<br>性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我<br>们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被<br>称为 ConcurrentHashMap 的并发度。<br>4.1.20.2. ConcurrentHashMap 分段锁<br>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下<br>一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。<br>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首<br>先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程<br>环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以<br>做到真正的并行。<br>13&#x2F;04&#x2F;2018 Page 93 of 283<br>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成<br>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可<br>重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值<br>对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap<br>类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是<br>一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的<br>数据进行修改时，必须首先获得它对应的 Segment 锁。</p><p>5.1.1. JAVA 异常分类及处理<br>5.1.1.1. 概念<br>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下<br>会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用<br>这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。<br>5.1.1.2. 异常分类<br>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception<br>Error<br>138.Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果<br>出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。<br>Exception（RuntimeException、CheckedException）<br>139.Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是<br>CheckedException。<br>RuntimeException 如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常<br>CheckedException，如 I&#x2F;O 错误导致的 IOException、SQLException。 RuntimeException 是<br>那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一<br>定是程序员的错误.<br>13&#x2F;04&#x2F;2018 Page 102 of 283<br>检查异常 CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强<br>制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一<br>般包括几个方面：<br>140.试图在文件尾部读取数据<br>141.试图打开一个错误格式的 URL<br>142.试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在<br>5.1.1.3. 异常的处理方式<br>遇到问题不进行具体处理，而是继续抛给调用者 （throw,throws）<br>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。<br>public static void main(String[] args) {<br>String s &#x3D; “abc”;<br>if(s.equals(“abc”)) {<br>throw new NumberFormatException();<br>} else {<br>System.out.println(s);<br>}<br>}<br>int div(int a,int b) throws Exception{<br>return a&#x2F;b;}<br>try catch 捕获异常针对性处理方式<br>5.1.1.4. Throw 和 throws 的区别：<br>位置不同<br>143.throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的<br>是异常对象。<br>功能不同：<br>144.throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方<br>式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并<br>将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语<br>句，因为执行不到。<br>145.throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，<br>执行 throw 则一定抛出了某种异常对象。<br>13&#x2F;04&#x2F;2018 Page 103 of 283<br>146.两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异<br>常，真正的处理异常由函数的上层调用处理。<br>5.1.2. JAVA 反射<br>5.1.2.1. 动态语言<br>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结<br>构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，<br>而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。<br>5.1.2.2. 反射机制概念 （运行状态中知道类所有的属性和方法）<br>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；<br>并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方<br>法的功能成为 Java 语言的反射机制。<br>5.1.2.3. 反射的应用场合<br>编译时类型和运行时类型<br>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由<br>声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：<br>Person p&#x3D;new Student();<br>其中编译时类型为 Person，运行时类型为 Student。<br>13&#x2F;04&#x2F;2018 Page 104 of 283<br>的编译时类型无法获取具体方法<br>程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用<br>该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。<br>然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象<br>和类的真实信息，此时就必须使用到反射了。<br>5.1.2.4. Java 反射 API<br>反射 API 用来生成 JVM 中的类、接口或则对象的信息。<br>147.Class 类：反射的核心类，可以获取类的属性，方法等信息。<br>148.Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性<br>值。<br>149.Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或<br>者执行方法。<br>150.Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。<br>5.1.2.5. 反射使用步骤（获取 Class 对象、调用对象方法）<br>151.获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方<br>法。<br>152.调用 Class 类中的方法，既就是反射的使用阶段。<br>153.使用反射 API 来操作这些信息。<br>5.1.2.6. 获取 Class 对象的 3 种方法<br>调用某个对象的 getClass()方法<br>Person p&#x3D;new Person();<br>Class clazz&#x3D;p.getClass();<br>调用某个类的 class 属性来获取该类对应的 Class 对象<br>Class clazz&#x3D;Person.class;<br>使用 Class 类中的 forName()静态方法(最安全&#x2F;性能最好)<br>Class clazz&#x3D;Class.forName(“类的全路径”); (最常用)<br>当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法<br>和属性。<br>&#x2F;&#x2F;获取 Person 类的 Class 对象<br>Class clazz&#x3D;Class.forName(“reflection.Person”);<br>13&#x2F;04&#x2F;2018 Page 105 of 283<br>&#x2F;&#x2F;获取 Person 类的所有方法信息<br>Method[] method&#x3D;clazz.getDeclaredMethods();<br>for(Method m:method){<br>System.out.println(m.toString());<br>}<br>&#x2F;&#x2F;获取 Person 类的所有成员属性信息<br>Field[] field&#x3D;clazz.getDeclaredFields();<br>for(Field f:field){<br>System.out.println(f.toString());<br>}<br>&#x2F;&#x2F;获取 Person 类的所有构造方法信息<br>Constructor[] constructor&#x3D;clazz.getDeclaredConstructors();<br>for(Constructor c:constructor){<br>System.out.println(c.toString());<br>}<br>5.1.2.7. 创建对象的两种方法<br>Class 对象的 newInstance()<br>154.使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求<br>该 Class 对象对应的类有默认的空构造器。<br>调用 Constructor 对象的 newInstance()<br>155.先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()<br>方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。<br>&#x2F;&#x2F;获取 Person 类的 Class 对象<br>Class clazz&#x3D;Class.forName(“reflection.Person”);<br>&#x2F;&#x2F;使用.newInstane 方法创建对象<br>Person p&#x3D;(Person) clazz.newInstance();<br>&#x2F;&#x2F;获取构造方法并创建对象<br>Constructor c&#x3D;clazz.getDeclaredConstructor(String.class,String.class,int.class);<br>&#x2F;&#x2F;创建对象并设置属性<br>13&#x2F;04&#x2F;2018 Page 106 of 283<br>Person p1&#x3D;(Person) c.newInstance(“李四”,”男”,20);<br>5.1.3. JAVA 注解<br>5.1.3.1. 概念<br>Annotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径<br>和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation<br>对象，然后通过该 Annotation 对象来获取注解中的元数据信息。<br>5.1.3.2. 4 种标准元注解<br>元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被<br>用来提供对其它 annotation 类型作说明。<br>@Target 修饰的对象范围<br>@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、<br>接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数<br>和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰<br>其修饰的目标<br>@Retention 定义 被保留的时间长短<br>Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描<br>述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：<br> SOURCE:在源文件中有效（即源文件保留）<br> CLASS:在 class 文件中有效（即 class 保留）<br> RUNTIME:在运行时有效（即运行时保留）<br>@Documented 描述-javadoc<br>@ Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因<br>此可以被例如 javadoc 此类的工具文档化。<br>@Inherited 阐述了某个被标注的类型是被继承的<br>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一<br>个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该<br>class 的子类。<br>13&#x2F;04&#x2F;2018 Page 107 of 283<br>5.1.3.3. 注解处理器<br>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，<br>很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API，以帮助程序员快速<br>的构造自定义注解处理器。下面实现一个注解处理器。<br>&#x2F;1：*** 定义注解*&#x2F;<br>@Target(ElementType.FIELD)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>public @interface FruitProvider {<br>&#x2F;<em>供应商编号</em>&#x2F;<br>public int id() default -1;<br>&#x2F;** 供应商名称*&#x2F;<br>public String name() default “”；<br>13&#x2F;04&#x2F;2018 Page 108 of 283<br>&#x2F;** * 供应商地址*&#x2F;<br>public String address() default “”;<br>}<br>&#x2F;&#x2F;2：注解使用<br>public class Apple {<br>@FruitProvider(id &#x3D; 1, name &#x3D; “陕西红富士集团”, address &#x3D; “陕西省西安市延安路”)<br>private String appleProvider;<br>public void setAppleProvider(String appleProvider) {<br>this.appleProvider &#x3D; appleProvider;<br>}<br>public String getAppleProvider() {<br>return appleProvider;<br>}<br>}<br>&#x2F;3：*********** 注解处理器 ***************&#x2F;<br>public class FruitInfoUtil {<br>public static void getFruitInfo(Class&lt;?&gt; clazz) {<br>String strFruitProvicer &#x3D; “供应商信息：”;<br>Field[] fields &#x3D; clazz.getDeclaredFields();&#x2F;&#x2F;通过反射获取处理注解<br>for (Field field : fields) {<br>if (field.isAnnotationPresent(FruitProvider.class)) {<br>FruitProvider fruitProvider &#x3D; (FruitProvider) field.getAnnotation(FruitProvider.class);<br>&#x2F;&#x2F;注解信息的处理地方<br>strFruitProvicer &#x3D; “ 供应商编号：” + fruitProvider.id() + “ 供应商名称：”* fruitProvider.name() + “ 供应商地址：”+ fruitProvider.address();<br>System.out.println(strFruitProvicer);<br>}<br>}<br>}<br>}<br>13&#x2F;04&#x2F;2018 Page 109 of 283<br>public class FruitRun {<br>public static void main(String[] args) {<br>FruitInfoUtil.getFruitInfo(Apple.class);<br>&#x2F;<em><strong>输出结果</strong></em>****&#x2F;<br>&#x2F;&#x2F; 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延<br>}<br>}<br>5.1.4. JAVA 内部类<br>Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根<br>据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。<br>5.1.4.1. 静态内部类<br>定义在类内部的静态类，就是静态内部类。<br>public class Out {<br>private static int a;<br>private int b;<br>public static class Inner {<br>public void print() {<br>System.out.println(a);<br>}<br>}<br>}1. 静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。2. 静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。3. 其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：Out.Inner inner &#x3D;<br>new Out.Inner();inner.print();4. Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，<br>HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部<br>类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。<br>13&#x2F;04&#x2F;2018 Page 110 of 283<br>5.1.4.2. 成员内部类<br>定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final 修饰的<br>除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内<br>部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。<br>public class Out {<br>private static int a;<br>private int b;<br>public class Inner {<br>public void print() {<br>System.out.println(a);<br>System.out.println(b);<br>}<br>}<br>}<br>5.1.4.3. 局部内部类（定义在方法中的类）<br>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。<br>public class Out {<br>private static int a;<br>private int b;<br>public void test(final int c) {<br>final int d &#x3D; 1;<br>class Inner {<br>public void print() {<br>System.out.println(c);<br>}<br>}<br>}<br>}<br>13&#x2F;04&#x2F;2018 Page 111 of 283<br>5.1.4.4. 匿名内部类（要继承一个父类或者实现一个接口、直接使用<br>new 来生成一个对象的引用）<br>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一<br>个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引<br>用。<br>public abstract class Bird {<br>private String name;<br>public String getName() {<br>return name;<br>}<br>public void setName(String name) {<br>this.name &#x3D; name;<br>}<br>public abstract int fly();<br>}<br>public class Test {<br>public void test(Bird bird){<br>System.out.println(bird.getName() + “能够飞 “ + bird.fly() + “米”);<br>}<br>public static void main(String[] args) {<br>Test test &#x3D; new Test();<br>test.test(new Bird() {<br>public int fly() {<br>return 10000;<br>}<br>public String getName() {<br>return “大雁”;<br>}<br>});<br>}<br>}<br>13&#x2F;04&#x2F;2018 Page 112 of 283<br>5.1.5. JAVA 泛型<br>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本<br>质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，<br>能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。<br>5.1.5.1. 泛型方法（&lt;E&gt;）<br>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数<br>类型，编译器适当地处理每一个方法调用。<br>&#x2F;&#x2F; 泛型方法 printArray<br>public static &lt; E &gt; void printArray( E[] inputArray )<br>{<br>for ( E element : inputArray ){<br>System.out.printf( “%s “, element );<br>}<br>}5. &lt;? extends T&gt;表示该通配符所代表的类型是 T 类型的子类。6. &lt;? super T&gt;表示该通配符所代表的类型是 T 类型的父类。5.1.5.2. 泛型类&lt;T&gt;<br>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一<br>样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，<br>也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，<br>这些类被称为参数化的类或参数化的类型。<br>public class Box&lt;T&gt; {<br>private T t;<br>public void add(T t) {<br>this.t &#x3D; t;<br>}<br>public T get() {<br>return t;<br>}<br>13&#x2F;04&#x2F;2018 Page 113 of 283<br>5.1.5.3. 类型通配符?<br>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List&lt;?&gt; 在逻辑上是<br>List&lt;String&gt;,List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt;的父类。<br>5.1.5.4. 类型擦除<br>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛<br>型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个<br>过程就称为类型擦除。如在代码中定义的 List&lt;Object&gt;和 List&lt;String&gt;等类型，在编译之后<br>都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。<br>类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般<br>是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换<br>成具体的类。<br>5.1.6. JAVA 序列化(创建可复用的 Java 对象)<br>保存(持久化)对象及其状态到内存或者磁盘<br>Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，<br>这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，<br>就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。<br>Java 对象序列化就能够帮助我们实现该功能。<br>序列化对象以字节数组保持-静态成员不保存<br>使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装<br>成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对<br>象序列化不会关注类中的静态变量。<br>序列化用户远程对象传输<br>除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，<br>都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。<br>Serializable 实现序列化<br>在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。<br>ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化<br>通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。<br>writeObject 和 readObject 自定义序列化策略<br>在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。<br>序列化 ID<br>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个<br>类的序列化 ID 是否一致（就是 private static final long serialVersionUID）<br>13&#x2F;04&#x2F;2018 Page 114 of 283<br>序列化并不保存静态变量<br>序列化子父类说明<br>要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。<br>Transient 关键字阻止该变量被序列化到文件中1. 在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列<br>化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。<br>2. 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串<br>等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在<br>客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的<br>数据安全。<br>5.1.7. JAVA 复制<br>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式<br>是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。<br>5.1.7.1. 直接赋值复制<br>直接赋值。在 Java 中，A a1 &#x3D; a2，我们需要理解的是这实际上复制的是引用，也就是<br>说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟<br>着变化。<br>5.1.7.2. 浅复制（复制引用但不复制引用的对象）<br>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，<br>那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。<br>因此，原始对象及其副本引用同一个对象。<br>class Resume implements Cloneable{<br>public Object clone() {<br>try {<br>return (Resume)super.clone();<br>} catch (Exception e) {<br>e.printStackTrace();<br>return null;<br>}<br>}<br>}<br>13&#x2F;04&#x2F;2018 Page 115 of 283<br>5.1.7.3. 深复制（复制对象和其应用对象）<br>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。<br>class Student implements Cloneable {<br>String name;<br>int age;<br>Professor p;<br>Student(String name, int age, Professor p) {<br>this.name &#x3D; name;<br>this.age &#x3D; age;<br>this.p &#x3D; p;<br>}<br>public Object clone() {<br>Student o &#x3D; null;<br>try {<br>o &#x3D; (Student) super.clone();<br>} catch (CloneNotSupportedException e) {<br>System.out.println(e.toString());<br>}<br>o.p &#x3D; (Professor) p.clone();<br>return o;<br>}<br>}<br>5.1.7.4. 序列化（深 clone 一中实现）<br>在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对<br>象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。<br>13&#x2F;04&#x2F;2018 Page 116 of 283<br>6.1.10. Spring Boot 原理<br>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭<br>建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的<br>配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application<br>development)成为领导者。其特点如下：<br>1. 创建独立的 Spring 应用程序<br>2. 嵌入的 Tomcat，无需部署 WAR 文件<br>3. 简化 Maven 配置<br>4. 自动配置 Spring<br>5. 提供生产就绪型功能，如指标，健康检查和外部配置<br>6. 绝对没有代码生成和对 XML 没有要求配置 [1]<br>6.1.11. JPA 原理<br>6.1.11.1. 事务<br>事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性 ( Atomicity )、一致性<br>( Consistency )、隔离性 ( Isolation ) 和持久性 ( Durabilily )。<br>6.1.11.2. 本地事务<br>紧密依赖于底层资源管理器（例如数据库连接 )，事务处理局限在当前事务资源内。此种事务处理<br>方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。在数据库连<br>接中使用本地事务示例如下：<br>public void transferAccount() {<br>Connection conn &#x3D; null;<br>Statement stmt &#x3D; null;<br>try{<br>conn &#x3D; getDataSource().getConnection();<br>&#x2F;&#x2F; 将自动提交设置为 false，若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交<br>conn.setAutoCommit(false);<br>stmt &#x3D; conn.createStatement();<br>&#x2F;&#x2F; 将 A 账户中的金额减少 500<br>stmt.execute(“update t_account set amount &#x3D; amount - 500 where account_id &#x3D; ‘A’”);<br>13&#x2F;04&#x2F;2018 Page 135 of 283<br>&#x2F;&#x2F; 将 B 账户中的金额增加 500<br>stmt.execute(“update t_account set amount &#x3D; amount + 500 where account_id &#x3D; ‘B’”);<br>&#x2F;&#x2F; 提交事务<br>conn.commit();<br>&#x2F;&#x2F; 事务提交：转账的两步操作同时成功<br>} catch(SQLException sqle){<br>&#x2F;&#x2F; 发生异常，回滚在本事务中的操做<br>conn.rollback();<br>&#x2F;&#x2F; 事务回滚：转账的两步操作完全撤销<br>stmt.close();<br>conn.close();<br>}<br>}<br>6.1.11.1. 分布式事务<br>Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction<br>Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务<br>管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource<br>Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务<br>参与单元的协调与控制。<br>public void transferAccount() {<br>UserTransaction userTx &#x3D; null;<br>Connection connA &#x3D; null; Statement stmtA &#x3D; null;<br>Connection connB &#x3D; null; Statement stmtB &#x3D; null;<br>try{<br>&#x2F;&#x2F; 获得 Transaction 管理对象<br>userTx &#x3D; (UserTransaction)getContext().lookup(“java:comp&#x2F;UserTransaction”);<br>connA &#x3D; getDataSourceA().getConnection();&#x2F;&#x2F; 从数据库 A 中取得数据库连接<br>connB &#x3D; getDataSourceB().getConnection();&#x2F;&#x2F; 从数据库 B 中取得数据库连接<br>userTx.begin(); &#x2F;&#x2F; 启动事务<br>stmtA &#x3D; connA.createStatement();&#x2F;&#x2F; 将 A 账户中的金额减少 500<br>stmtA.execute(“update t_account set amount &#x3D; amount - 500 where account_id &#x3D; ‘A’”);<br>&#x2F;&#x2F; 将 B 账户中的金额增加 500<br>stmtB &#x3D; connB.createStatement();<br>13&#x2F;04&#x2F;2018 Page 136 of 283<br>stmtB.execute(“update t_account set amount &#x3D; amount + 500 where account_id &#x3D; ‘B’”);<br>userTx.commit();&#x2F;&#x2F; 提交事务<br>&#x2F;&#x2F; 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新）<br>} catch(SQLException sqle){<br>&#x2F;&#x2F; 发生异常，回滚在本事务中的操纵<br>userTx.rollback();&#x2F;&#x2F; 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销<br>} catch(Exception ne){ }<br>}<br>6.1.11.1. 两阶段提交<br>两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段<br>是指：第一阶段：准备阶段；第二阶段：提交阶段。<br>1 准备阶段<br>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回<br>失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一<br>种“万事俱备，只欠东风”的状态。<br>2 提交阶段：<br>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，<br>发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过<br>程中使用的锁资源。(注意:必须在最后阶段释放锁资源)<br>13&#x2F;04&#x2F;2018 Page 137 of 283<br>将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成<br>所有能完成的工作。<br>6.1.12. Mybatis 缓存<br>Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存<br>是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以<br>后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存<br>是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的<br>sqlsession 是可以共享的。<br>13&#x2F;04&#x2F;2018 Page 138 of 283<br>6.1.12.1. Mybatis 的一级缓存原理（sqlsession 级别）<br>第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一<br>个 map。<br>key：MapperID+offset+limit+Sql+所有的入参<br>value：用户信息<br>同一个 sqlsession 再次发出相同的 sql，就从缓存中取出数据。如果两次中间出现 commit 操作<br>（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所<br>以要从数据库查询，从数据库查询到再写入缓存。<br>6.1.12.2. 二级缓存原理（mapper 基本）<br>二级缓存的范围是 mapper 级别（mapper 同一个命名空间），mapper 以命名空间为单位创建缓<br>存数据结构，结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor<br>13&#x2F;04&#x2F;2018 Page 139 of 283<br>其实是 Executor 的代理对象。所有的查询操作，在 CacheExecutor 中都会先匹配缓存中是否存<br>在，不存在则查询数据库。<br>key：MapperID+offset+limit+Sql+所有的入参<br>具体使用需要配置：<br>1. Mybatis 全局配置中启用二级缓存配置<br>2. 在对应的 Mapper.xml 中配置 cache 节点<br>3. 在对应的 select 查询节点中添加 useCache&#x3D;true<br>6.1.13. Tomcat 架构<br><a target="_blank" rel="noopener" href="http://www.importnew.com/21112.html">http://www.importnew.com/21112.html</a><br>13&#x2F;04&#x2F;2018 Page 140 of 283<br>7. 微服务<br>7.1.1. 服务注册发现<br>服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记<br>簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服<br>务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种<br>形式：客户端注册和第三方注册。<br>7.1.1.1. 客户端注册（zookeeper）<br>客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下<br>线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心<br>负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一<br>套注册逻辑。<br>7.1.1.2. 第三方注册（独立的服务 Registrar）<br>第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，<br>然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不<br>可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统，否则注册<br>工作没法进展。<br>13&#x2F;04&#x2F;2018 Page 141 of 283<br>7.1.1.3. 客户端发现<br>客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而<br>且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多<br>语言时的重复工作，每个语言实现相同的逻辑。<br>13&#x2F;04&#x2F;2018 Page 142 of 283<br>7.1.1.4. 服务端发现<br>服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。<br>这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。<br>7.1.1.5. Consul<br>7.1.1.6. Eureka<br>7.1.1.7. SmartStack<br>7.1.1.8. Etcd<br>7.1.2. API 网关<br>API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的<br>Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有<br>其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一<br>个适应当前架构的 API Gateway。<br>13&#x2F;04&#x2F;2018 Page 143 of 283<br>API Gateway 负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过 API Gateway，<br>然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以<br>及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如<br>HTTP 协议、WebSocket 协议。<br>7.1.2.1. 请求转发<br>服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上<br>7.1.2.2. 响应合并<br>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。<br>7.1.2.3. 协议转换<br>重点是支持 SOAP，JMS，Rest 间的协议转换。<br>7.1.2.4. 数据转换<br>重点是支持 XML 和 Json 之间的报文格式转换能力（可选）<br>13&#x2F;04&#x2F;2018 Page 144 of 283<br>7.1.2.5. 安全认证<br>1. 基于 Token 的客户端访问控制和安全策略<br>2. 传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包<br>3. 基于 Https 的传输加密，客户端和服务端数字证书支持<br>4. 基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）<br>7.1.3. 配置中心<br>配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访<br>问。<br>7.1.3.1. zookeeper 配置中心<br>实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点<br>监听机制来实现实时感知。<br>7.1.3.2. 配置中心数据分类<br>7.1.4. 事件调度（kafka）<br>消息服务和事件的统一调度，常用用 kafka ，activemq 等。<br>7.1.5. 服务跟踪（starter-sleuth）<br>随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， Spring<br>Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这<br>样你就能跟踪某个请求是如何从一个微服务传递到下一个。<br>13&#x2F;04&#x2F;2018 Page 145 of 283<br>1. 为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求<br>创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标<br>识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。通过 Trace ID 的记<br>录，我们就能将所有请求过程日志关联起来。<br>2. 为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态<br>时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到<br>的 Span ID，对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结<br>束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一<br>些其他元数据，比如：事件名称、请求信息等。<br>3. 在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloud￾starter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloud￾starter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：<br> 通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息<br>中间件）传递的请求。<br> 通过 Zuul 代理传递的请求。<br> 通过 RestTemplate 发起的请求。<br>7.1.6. 服务熔断（Hystrix）<br>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个<br>系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不<br>可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。<br>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到<br>许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序<br>不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU<br>时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经<br>修正，应用程序会再次尝试调用操作。<br>13&#x2F;04&#x2F;2018 Page 146 of 283<br>7.1.6.1. Hystrix 断路器机制<br>断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会<br>切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态<br>一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况,<br>如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器<br>就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效<br>请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。<br>7.1.7. API 管理<br>SwaggerAPI 管理工具。<br>13&#x2F;04&#x2F;2018 Page 147 of 283<br>8. Netty 与 RPC<br>8.1.1. Netty 原理<br>Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对<br>TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞<br>的，通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。<br>8.1.2. Netty 高性能<br>在 IO 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者 IO 多路复用技术<br>进行处理。IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞上，从而使得系统在<br>单线程的情况下可以同时处理多个客户端请求。与传统的多线程&#x2F;多进程模型比，I&#x2F;O 多路复用的<br>最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程<br>的运行，降低了系统的维护工作量，节省了系统资源。<br>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel<br>两种不同的套接字通道实现。<br>8.1.2.1. 多路复用通讯方式<br>Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下：<br>客户端通信序列图如下：<br>13&#x2F;04&#x2F;2018 Page 148 of 283<br>Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个<br>客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于<br>频繁 IO 阻塞导致的线程挂起。<br>8.1.2.1. 异步通讯 NIO<br>由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作，这从根<br>本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极<br>大的提升。<br>13&#x2F;04&#x2F;2018 Page 149 of 283<br>8.1.2.2. 零拷贝（DIRECT BUFFERS 使用堆外直接内存）<br>1. Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，<br>不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，<br>JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，<br>消息在发送过程中多了一次缓冲区的内存拷贝。<br>2. Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样<br>方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的<br>Buffer。<br>3. Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，<br>避免了传统通过循环 write 方式导致的内存拷贝问题<br>8.1.2.3. 内存池（基于内存池的缓冲区重用机制）<br>随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓<br>冲区 Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽<br>量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。<br>8.1.2.4. 高效的 Reactor 线程模型<br>常用的 Reactor 线程模型有三种，Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模<br>型。<br>Reactor 单线程模型<br>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：<br>1) 作为 NIO 服务端，接收客户端的 TCP 连接；<br>2) 作为 NIO 客户端，向服务端发起 TCP 连接；<br>3) 读取通信对端的请求或者应答消息；<br>4) 向通信对端发送消息请求或者应答消息。<br>13&#x2F;04&#x2F;2018 Page 150 of 283<br>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独<br>立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过<br>Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer<br>派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。<br>Reactor 多线程模型<br>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。 有专门一个<br>NIO 线程-Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求； 网络 IO 操作-读、写<br>等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N<br>个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；<br>主从 Reactor 多线程模型<br>服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。<br>Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的<br>SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责<br>SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅只用于客户端的登陆、握手和安全<br>认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负<br>责后续的 IO 操作。<br>13&#x2F;04&#x2F;2018 Page 151 of 283<br>8.1.2.5. 无锁设计、线程绑定<br>Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。<br>表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程<br>参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-<br>多个工作线程模型性能更优。<br>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的<br>fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用<br>到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁<br>的竞争，从性能角度看是最优的。<br>8.1.2.6. 高性能的序列化框架<br>Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的<br>高性能序列化框架，例如 Thrift 的压缩二进制编解码框架。<br>1. SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K。<br>13&#x2F;04&#x2F;2018 Page 152 of 283<br>小包封大包，防止网络阻塞<br>2. SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量<br>小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算<br>法。<br>软中断 Hash 值和 CPU 绑定<br>3. 软中断：开启 RPS 后可以实现软中断，提升网络吞吐量。RPS 根据数据包的源地址，目的地址以<br>及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu，从上层<br>来看，也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上，提升<br>网络并行处理性能。<br>8.1.3. Netty RPC 实现<br>8.1.3.1. 概念<br>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一<br>样。RPC 可以很好的解耦系统，如 WebService 就是一种基于 Http 协议的 RPC。这个 RPC 整体框架<br>如下：<br>8.1.3.2. 关键技术<br>1. 服务发布与订阅：服务端使用 Zookeeper 注册服务地址，客户端从 Zookeeper 获取可用的服务<br>地址。<br>2. 通信：使用 Netty 作为通信框架。<br>3. Spring：使用 Spring 配置服务，加载 Bean，扫描注解。<br>4. 动态代理：客户端使用代理模式透明化服务调用。<br>5. 消息编解码：使用 Protostuff 序列化和反序列化消息。<br>8.1.3.3. 核心流程<br>1. 服务消费方（client）调用以本地调用方式调用服务；<br>13&#x2F;04&#x2F;2018 Page 153 of 283<br>2. client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3. client stub 找到服务地址，并将消息发送到服务端；<br>4. server stub 收到消息后进行解码；<br>5. server stub 根据解码结果调用本地的服务；<br>6. 本地服务执行并将结果返回给 server stub；<br>7. server stub 将返回结果打包成消息并发送至消费方；<br>8. client stub 接收到消息，并进行解码；<br>9. 服务消费方得到最终结果。<br>RPC 的目标就是要 2~8 这些步骤都封装起来，让用户对这些细节透明。JAVA 一般使用动态代<br>理方式实现远程调用。<br>8.1.3.1. 消息编解码<br>息数据结构（接口名称+方法名+参数类型和参数值+超时时间+ requestID）<br>客户端的请求消息结构一般需要包括以下内容：<br>1. 接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪<br>个接口了；<br>2. 方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；<br>3. 参数类型和参数值：参数类型有很多，比如有 bool、int、long、double、string、map、list，<br>甚至如 struct（class）；以及相应的参数值；<br>4. 超时时间：<br>5. requestID，标识唯一请求 id，在下面一节会详细描述 requestID 的用处。<br>6. 服务端返回的消息 ： 一般包括以下内容。返回值+状态 code+requestID<br>13&#x2F;04&#x2F;2018 Page 154 of 283<br>序列化<br>目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案来搭建 RPC 框架，这<br>些都是久经考验的解决方案。<br>8.1.3.1. 通讯过程<br>核心问题(线程暂停、消息乱序)<br>如果使用 netty 的话，一般会用 channel.writeAndFlush()方法来发送消息二进制串，这个方<br>法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的，即对于当前线程来说，<br>将请求发送出来后，线程就可以往后执行了，至于服务端的结果，是服务端处理完成后，再以消息<br>的形式发送给客户端的。于是这里出现以下两个问题：<br>1. 怎么让当前线程“暂停”，等结果回来后，再向后执行？<br>2. 如果有多个线程同时进行远程方法调用，这时建立在 client server 之间的 socket 连接上<br>会有很多双方发送的消息传递，前后顺序也可能是随机的，server 处理完结果后，将结<br>果消息发送给 client，client 收到很多消息，怎么知道哪个消息结果是原先哪个线程调用<br>的？如下图所示，线程 A 和线程 B 同时向 client socket 发送请求 requestA 和 requestB，<br>socket 先后将 requestB 和 requestA 发送至 server，而 server 可能将 responseB 先返<br>回，尽管 requestB 请求到达时间更晚。我们需要一种机制保证 responseA 丢给<br>ThreadA，responseB 丢给 ThreadB。<br>通讯流程<br>requestID 生成-AtomicLong<br>1. client 线程每次通过 socket 调用一次远程接口前，生成一个唯一的 ID，即 requestID<br>（requestID 必需保证在一个 Socket 连接里面是唯一的），一般常常使用 AtomicLong<br>从 0 开始累计数字生成唯一 ID；<br>存放回调对象 callback 到全局 ConcurrentHashMap<br>2. 将 处 理 结 果 的 回 调 对 象 callback ， 存 放 到 全 局 ConcurrentHashMap 里 面<br>put(requestID, callback)；<br>synchronized 获取回调对象 callback 的锁并自旋 wait<br>3. 当线程调用 channel.writeAndFlush()发送消息后，紧接着执行 callback 的 get()方法试<br>图获取远程返回的结果。在 get()内部，则使用 synchronized 获取回调对象 callback 的<br>锁，再先检测是否已经获取到结果，如果没有，然后调用 callback 的 wait()方法，释放<br>callback 上的锁，让当前线程处于等待状态。<br>13&#x2F;04&#x2F;2018 Page 155 of 283<br>监听消息的线程收到消息，找到 callback 上的锁并唤醒<br>4. 服务端接收到请求并处理后，将 response 结果（此结果中包含了前面的 requestID）发<br>送给客户端，客户端 socket 连接上专门监听消息的线程收到消息，分析结果，取到<br>requestID ， 再 从 前 面 的 ConcurrentHashMap 里 面 get(requestID) ， 从 而 找 到<br>callback 对象，再用 synchronized 获取 callback 上的锁，将方法调用结果设置到<br>callback 对象里，再调用 callback.notifyAll()唤醒前面处于等待状态的线程。<br>public Object get() {<br>synchronized (this) { &#x2F;&#x2F; 旋锁<br>while (true) { &#x2F;&#x2F; 是否有结果了<br>If （!isDone）{<br>wait(); &#x2F;&#x2F;没结果释放锁，让当前线程处于等待状态<br>}else{&#x2F;&#x2F;获取数据并处理<br>}<br>}<br>}<br>}<br>private void setDone(Response res) {<br>this.res &#x3D; res;<br>isDone &#x3D; true;<br>synchronized (this) { &#x2F;&#x2F;获取锁，因为前面 wait()已经释放了 callback 的锁了<br>notifyAll(); &#x2F;&#x2F; 唤醒处于等待的线程<br>}<br>}<br>8.1.4. RMI 实现方式<br>Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用<br>于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远<br>程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接<br>口对象的使用。8.1.4.1. 实现步骤1. 编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出<br>java.rmi.RemoteException 异常；<br>2. 编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；<br>3. 运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类;<br>4. 启动一个 RMI 注册表，以便驻留这些服务;<br>13&#x2F;04&#x2F;2018 Page 156 of 283<br>5. 在 RMI 注册表中注册服务；<br>6. 客户端查找远程对象，并调用远程方法；<br>1：创建远程接口，继承 java.rmi.Remote 接口<br>public interface GreetService extends java.rmi.Remote {<br>String sayHello(String name) throws RemoteException;<br>}<br>2：实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类<br>public class GreetServiceImpl extends java.rmi.server.UnicastRemoteObject<br>implements GreetService {<br>private static final long serialVersionUID &#x3D; 3434060152387200042L;<br>public GreetServiceImpl() throws RemoteException {<br>super();<br>}<br>@Override<br>public String sayHello(String name) throws RemoteException {<br>return “Hello “ + name;<br>}<br>}<br>3：生成 Stub 和 Skeleton;<br>4：执行 rmiregistry 命令注册服务<br>5：启动服务<br>LocateRegistry.createRegistry(1098);<br>Naming.bind(“rmi:&#x2F;&#x2F;10.108.1.138:1098&#x2F;GreetService”, new GreetServiceImpl());<br>6.客户端调用<br>GreetService greetService &#x3D; (GreetService)<br>Naming.lookup(“rmi:&#x2F;&#x2F;10.108.1.138:1098&#x2F;GreetService”);<br>System.out.println(greetService.sayHello(“Jobs”));<br>8.1.5. Protoclol Buffer<br>protocol buffer 是 google 的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，<br>例如 XML，不过它比 xml 更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器<br>生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。<br>13&#x2F;04&#x2F;2018 Page 157 of 283<br>8.1.5.1. 特点<br>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：<br>7. 编码 &#x2F; 解码 方式简单（只需要简单的数学运算 &#x3D; 位移等等）<br>8. 采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成<br>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：<br>9. a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等<br>10. b. 采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑<br>8.1.6. Thrift<br>Apache Thrift 是 Facebook 实现的一种高效的、支持多种编程语言的远程服务调用的框架。本文将从<br>Java 开发人员角度详细介绍 Apache Thrift 的架构、开发和部署，并且针对不同的传输协议和服务类<br>型给出相应的 Java 实例，同时详细介绍 Thrift 异步客户端的实现，最后提出使用 Thrift 需要注意的事<br>项。<br>目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式<br>的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输<br>效率低，JSON 体积较小，新颖，但还不够完善。本文将介绍由 Facebook 开发的远程服务调用框架<br>Apache Thrift，它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码<br>生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa,<br>Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，<br>对于高并发、大数据量和多语言的环境更有优势。本文将详细介绍 Thrift 的使用，并且提供丰富的实例<br>代码加以解释说明，帮助使用者快速构建服务。<br>为什么要 Thrift：<br>1、多语言开发的需要 2、性能问题<br>13&#x2F;04&#x2F;2018 Page 158 of 283<br>13&#x2F;04&#x2F;2018 Page 159 of 283<br>11. 网络<br>9.1.1. 网络 7 层架构<br>7 层模型主要包括：<br>12. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率<br>等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为<br>1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。<br>13. 数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这<br>一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。<br>14. 网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工<br>作的设备是路由器，常把这一层的数据叫做数据包。<br>15. 传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，<br>传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，<br>与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这<br>种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。<br>常常把这一层数据叫做段。<br>16. 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间<br>发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）<br>17. 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够<br>识别的东西转换成人能够能识别的东西（如图片、声音等））<br>18. 应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你<br>就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。<br>13&#x2F;04&#x2F;2018 Page 160 of 283<br>9.1.2. TCP&#x2F;IP 原理<br>TCP&#x2F;IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP&#x2F;IP 协议族。从协议分层<br>模型方面来讲，TCP&#x2F;IP 由四个层次组成：网络接口层、网络层、传输层、应用层。<br>9.1.2.1. 网络访问层(Network Access Layer)<br>19. 网络访问层(Network Access Layer)在 TCP&#x2F;IP 参考模型中并没有详细描述，只是指出主机<br>必须使用某种协议与网络相连。<br>9.1.2.2. 网络层(Internet Layer)<br>20. 网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网<br>络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也<br>可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。互联网层使用因特<br>网协议(IP，Internet Protocol)。<br>9.1.2.3. 传输层(Tramsport Layer-TCP&#x2F;UDP)<br>21. 传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。在这一层定义了<br>两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协<br>议(UDP，User Datagram Protocol)。TCP 是面向连接的协议，它提供可靠的报文传输和对<br>上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路<br>复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需<br>要 TCP 的排序和流量控制等功能的应用程序。<br>9.1.2.4. 应用层(Application Layer)<br>22. 应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，<br>TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件<br>传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name<br>13&#x2F;04&#x2F;2018 Page 161 of 283<br>Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议<br>(HTTP，HyperText Transfer Protocol)等。<br>9.1.3. TCP 三次握手&#x2F;四次挥手<br>TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般<br>称为“四次挥手”。<br>9.1.3.1. 数据包说明<br>23. 源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。<br>24. 目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值<br>加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接。<br>25. 顺序号 seq（ 32 位）：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个<br>报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则<br>TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2 的 32 次方 － 1 后<br>又从 0 开始。当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该<br>连接的初始顺序号 ISN （ Initial Sequence Number ）。<br>26. 确认号 ack（ 32 位）：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当<br>是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效。 TCP 为<br>应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必<br>须保持每个方向上的传输数据顺序号。<br>27. TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，它实际上指明数据从哪里开始。需要这<br>个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然<br>而，没有任选字段，正常的长度是 20 字节。<br>28. 保留位（ 6 位）：保留给将来使用，目前必须置为 0 。<br>29. 控制位（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设<br>置为 1 。依次为：<br> URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。<br> ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。<br> PSH ：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层<br>而不用等待缓冲区装满。<br> RST ：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报<br>文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些<br>问题。<br> SYN ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。<br> FIN ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。<br>30. 窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源<br>方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。<br>31. 校验和（ 16 位）：此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字<br>进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。<br>32. 紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。TCP 的紧急方式是发送端向另<br>一端发送紧急数据的一种方式。<br>13&#x2F;04&#x2F;2018 Page 162 of 283<br>33. 选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连<br>接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，<br>它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充<br>位，使得报头长度成为整字数。<br>34. 数据： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报<br>文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数<br>据。在处理超时的许多情况中，也会发送不带任何数据的报文段。<br>9.1.3.2. 三次握手<br>第一次握手：主机 A 发送位码为 syn＝1,随机产生 seq number&#x3D;1234567 的数据包到服务器，主机 B<br>由 SYN&#x3D;1 知道，A 要求建立联机；<br>第二次握手：主机 B 收到请求后要确认联机信息，向 A 发 送 ack number&#x3D;( 主 机 A 的<br>seq+1),syn&#x3D;1,ack&#x3D;1,随机产生 seq&#x3D;7654321 的包<br>第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码<br>ack 是否为 1，若正确，主机 A 会再发送 ack number&#x3D;(主机 B 的 seq+1),ack&#x3D;1，主机 B 收到后确认<br>13&#x2F;04&#x2F;2018 Page 163 of 283<br>seq 值与 ack&#x3D;1 则连接建立成功。<br>9.1.3.3. 四次挥手<br>TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连<br>接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单<br>方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个<br>方向的连接。<br>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，<br>然后等待服务器的确认。其中终止标志位 FIN&#x3D;1，序列号 seq&#x3D;u<br>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。<br>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。<br>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。<br>首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>13&#x2F;04&#x2F;2018 Page 164 of 283<br>主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即<br>给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高<br>层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给<br>B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释<br>放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注<br>意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到<br>close 状态。<br>9.1.4. HTTP 原理<br>HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，<br>这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服<br>务器端不保留连接的有关信息.HTTP 遵循请求(Request)&#x2F;应答(Response)模型。客户机（浏览器）向<br>服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。<br>9.1.4.1. 传输流程<br>1：地址解析<br>如用客户端浏览器请求这个页面：<a target="_blank" rel="noopener" href="http://localhost.com:8080/index.htm">http://localhost.com:8080/index.htm</a> 从中分解出协议名、主机名、<br>端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：<br>协议名：http<br>主机名：localhost.com<br>端口：8080<br>对象路径：&#x2F;index.htm<br>13&#x2F;04&#x2F;2018 Page 165 of 283<br>在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。<br>2：封装 HTTP 请求数据包<br>把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包<br>3：封装成 TCP 包并建立连接<br>封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）<br>4：客户机发送请求命<br>4）客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资<br>源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。<br>5：服务器响应<br>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或<br>错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。<br>6：服务器关闭 TCP 连接<br>服务器关闭 TCP 连接：一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连<br>接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送<br>后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求<br>建立新连接所需的时间，还节约了网络带宽。<br>9.1.4.2. HTTP 状态<br>状态码 原因短语<br>消息响应<br>100 Continue(继续)<br>101 Switching Protocol(切换协议)<br>13&#x2F;04&#x2F;2018 Page 166 of 283<br>成功响应<br>200 OK(成功)<br>201 Created(已创建)<br>202 Accepted(已创建)<br>203 Non-Authoritative Information(未授权信息)<br>204 No Content(无内容)<br>205 Reset Content(重置内容)<br>206 Partial Content(部分内容)<br>重定向<br>300 Multiple Choice(多种选择)<br>301 Moved Permanently(永久移动)<br>302 Found(临时移动)<br>303 See Other(查看其他位置)<br>304 Not Modified(未修改)<br>305 Use Proxy(使用代理)<br>306 unused(未使用)<br>307 Temporary Redirect(临时重定向)<br>308 Permanent Redirect(永久重定向)<br>客户端错误<br>400 Bad Request(错误请求)<br>401 Unauthorized(未授权)<br>402 Payment Required(需要付款)<br>403 Forbidden(禁止访问)<br>404 Not Found(未找到)<br>405 Method Not Allowed(不允许使用该方法)<br>406 Not Acceptable(无法接受)<br>407 Proxy Authentication Required(要求代理身份验证)<br>408 Request Timeout(请求超时)<br>409 Conflict(冲突)<br>410 Gone(已失效)<br>411 Length Required(需要内容长度头)<br>412 Precondition Failed(预处理失败)<br>413 Request Entity Too Large(请求实体过长)<br>414 Request-URI Too Long(请求网址过长)<br>415 Unsupported Media Type(媒体类型不支持)<br>416 Requested Range Not Satisfiable(请求范围不合要求)<br>417 Expectation Failed(预期结果失败)<br>服务器端错误<br>500 Internal Server Error(内部服务器错误)<br>501 Implemented(未实现)<br>502 Bad Gateway(网关错误)<br>503 Service Unavailable(服务不可用)<br>504 Gateway Timeout (网关超时)<br>505 HTTP Version Not Supported(HTTP 版本不受支持)<br>9.1.4.3. HTTPS<br>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的<br>HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用<br>的端口号是 443。 过程大致如下：<br>13&#x2F;04&#x2F;2018 Page 167 of 283<br>建立连接获取证书<br>1） SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握<br>手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算<br>法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所<br>需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书<br>的公司，公共秘钥）。<br>证书验证<br>2） Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公<br>共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。<br>数据加密和传输<br>3） 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务<br>器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。<br>9.1.5. CDN 原理<br>CND 一般包含分发服务系统、负载均衡系统和管理系统<br>9.1.5.1. 分发服务系统<br>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还<br>负责内容更新，保证和源站内容的同步。<br>13&#x2F;04&#x2F;2018 Page 168 of 283<br>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务、流媒体加速<br>服务、应用加速服务等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部<br>署的 Cache 集群组成。<br>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个<br>Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由<br>哪个 Cache 设备来响应用户的请求。<br>9.1.5.2. 负载均衡系统：<br>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问<br>地址。<br>使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。<br>GSLB 根据用户地址和用户请求的内容，主要根据就近性原则，确定向用户服务的节点。一般通过 DNS<br>解析或者应用层重定向（Http 3XX 重定向）的方式实现。<br>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个<br>Cache 设备的工作状况和内容分布情况等对用户请求重定向。SLB 的实现有四层调度（LVS）、七层调<br>度（Nginx）和链路负载调度等。<br>9.1.5.3. 管理系统：<br>分为运营管理和网络管理子系统。<br>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资<br>源的可视化的集中管理，通常用 web 方式实现。<br>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、<br>交付工作。包括用户管理、产品管理、计费管理、统计分析等。<br>13&#x2F;04&#x2F;2018 Page 169 of 283<br>35. 日志<br>10.1.1. Slf4j<br>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接<br>口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不<br>能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带<br>的 java.util.logging.Logger 等。<br>10.1.2. Log4j<br>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、<br>文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控<br>制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。<br>Log4j 由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。<br>1.Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制<br>2.Appenders : 指定了日志将打印到控制台还是文件中<br>3.Layout : 控制日志信息的显示格式<br>Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为 DEBUG、INFO、WARN、ERROR 和 FATAL，<br>当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况<br>下要输出的内容，而不需要更改代码。<br>10.1.3. LogBack<br>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。<br>Logback 主要由三个模块组成：logback-core，logback-classic。logback-access<br>logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的<br>通用机制。<br>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单<br>日志门面 SLF4J；<br>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与<br>HTTP 访问相关的功能。<br>10.1.3.1. Logback 优点<br> 同样的代码路径，Logback 执行更快<br> 更充分的测试<br> 原生实现了 SLF4J API（Log4J 还需要有一个中间转换层）<br> 内容更丰富的文档<br> 支持 XML 或者 Groovy 方式配置<br> 配置文件自动热加载<br>13&#x2F;04&#x2F;2018 Page 170 of 283<br> 从 IO 错误中优雅恢复<br> 自动删除日志归档<br> 自动压缩日志成为归档文件<br> 支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件<br> 支持配置文件中加入条件判断来适应不同的环境<br> 更强大的过滤器<br> 支持 SiftingAppender（可筛选 Appender）<br> 异常栈信息带有包信息<br>10.1.4. ELK<br>ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打<br>造大规模日志实时处理系统。<br> Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将<br>日志索引并存储起来，方便业务方检索查询。<br> Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收<br>集、过滤后，转发给 Elasticsearch 进行下一步处理。<br> Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业<br>务方，比如各类饼图、直方图、区域图等。<br>13&#x2F;04&#x2F;2018 Page 171 of 283<br>36. Zookeeper<br>11.1.1. Zookeeper 概念<br>Zookeeper 是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。<br>Zookeeper 提供了一个类似于 Linux 文件系统的树形结构（可认为是轻量级的内存文件系统，但<br>只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与<br>通知机制。<br>11.1.1. Zookeeper 角色<br>Zookeeper 集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种<br>11.1.1.1. Leader<br>37. 一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader，它会发起并维护与各 Follwer<br>及 Observer 间的心跳。<br>38. 所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。只要有超过<br>半数节点（不包括 observeer 节点）写入成功，该写请求就会被提交（类 2PC 协议）。<br>11.1.1.2. Follower<br>39. 一个 Zookeeper 集群可能同时存在多个 Follower，它会响应 Leader 的心跳，<br>40. Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理，<br>41. 并且负责在 Leader 处理写请求时对请求进行投票。<br>11.1.1.3. Observer<br>角色与 Follower 类似，但是无投票权。Zookeeper 需保证高可用和强一致性，为了支持更多的客<br>户端，需要增加更多 Server；Server 增多，投票阶段延迟增大，影响性能；引入 Observer，<br>Observer 不参与投票； Observers 接受客户端的连接，并将写请求转发给 leader 节点； 加入更<br>多 Observer 节点，提高伸缩性，同时不影响吞吐率。<br>13&#x2F;04&#x2F;2018 Page 172 of 283<br>11.1.1.1. ZAB 协议<br>事务编号 Zxid（事务请求计数器+ epoch）<br>在 ZAB ( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议） 协议的事务编号 Zxid<br>设计中，Zxid 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，针对客户端每<br>一个事务请求，计数器加 1；而高 32 位则代表 Leader 周期 epoch 的编号，每个当选产生一个新<br>的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务的 ZXID，并从中读取<br>epoch 值，然后加 1，以此作为新的 epoch，并将低 32 位从 0 开始计数。<br>Zxid（Transaction id）类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal（提议）<br>ID。为了保证顺序性，该 zkid 必须单调递增。<br>epoch<br>epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所<br>以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算旧的 leader 崩溃<br>恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令。<br>Zab 协议有两种模式-恢复模式（选主）、广播模式（同步）<br>Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导<br>者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状<br>态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。<br>ZAB 协议 4 阶段<br>Leader election（选举阶段-选出准 Leader）<br>42. Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数<br>节点的票数，它就可以当选准 leader。只有到达 广播阶段（broadcast） 准 leader 才会成<br>为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。<br>13&#x2F;04&#x2F;2018 Page 173 of 283<br>Discovery（发现阶段-接受提议、生成 epoch、接受 epoch）<br>43. Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers<br>最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且<br>准 leader 生成新的 epoch，让 followers 接受，更新它们的 accepted Epoch<br>一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f<br>在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入重新选举阶段。<br>Synchronization（同步阶段-同步 follower 副本）<br>44. Synchronization（同步阶段）：同步阶段主要是利用 leader 前一阶段获得的最新提议历史，<br>同步集群中所有的副本。只有当 大多数节点都同步完成，准 leader 才会成为真正的 leader。<br>follower 只会接收 zxid 比自己的 lastZxid 大的提议。<br>Broadcast（广播阶段-leader 消息广播）<br>45. Broadcast（广播阶段）：到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，<br>并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。<br>ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK，只需要得到超过半数的节点的 ACK 就<br>可以了。<br>ZAB 协议 JAVA 实现（FLE-发现阶段和同步合并为 Recovery Phase（恢复阶段））<br>协议的 Java 版本实现跟上面的定义有些不同，选举阶段使用的是 Fast Leader Election（FLE），<br>它包含了 选举的发现职责。因为 FLE 会选举拥有最新提议历史的节点作为 leader，这样就省去了<br>发现最新提议的步骤。实际的实现将 发现阶段 和 同步合并为 Recovery Phase（恢复阶段）。所<br>以，ZAB 的实现只有三个阶段：Fast Leader Election；Recovery Phase；Broadcast Phase。<br>11.1.1.2. 投票机制<br>每个 sever 首先给自己投票，然后用自己的选票和其他 sever 选票对比，权重大的胜出，使用权<br>重较大的更新自身选票箱。具体选举过程如下：<br>46. 每个 Server 启动以后都询问其它的 Server 它要投票给谁。对于其他 server 的询问，<br>server 每次根据自己的状态都回复自己推荐的 leader 的 id 和上一次处理事务的 zxid（系<br>统启动时每个 server 都会推荐自己）<br>47. 收到所有 Server 回复以后，就计算出 zxid 最大的哪个 Server，并将这个 Server 相关信<br>息设置成下一次要投票的 Server。<br>48. 计算这过程中获得票数最多的的 sever 为获胜者，如果获胜者的票数超过半数，则改<br>server 被选为 leader。否则，继续这个过程，直到 leader 被选举出来<br>49. leader 就会开始等待 server 连接<br>50. Follower 连接 leader，将最大的 zxid 发送给 leader<br>51. Leader 根据 follower 的 zxid 确定同步点，至此选举阶段完成。<br>52. 选举阶段完成 Leader 同步后通知 follower 已经成为 uptodate 状态<br>53. Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了<br>13&#x2F;04&#x2F;2018 Page 174 of 283<br>目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是 1,2,3,4,5,按编号依次启动，它们<br>的选择举过程如下：<br>54. 服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反<br>馈信息，服务器 1 的状态一直属于 Looking。<br>55. 服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号<br>大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是<br>LOOKING。<br>56. 服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编<br>号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器<br>1,2 成为小弟。<br>57. 服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的<br>编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。<br>58. 服务器 5 启动，后面的逻辑同服务器 4 成为小弟。<br>11.1.2. Zookeeper 工作原理（原子广播）<br>59. Zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制<br>的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。<br>60. 当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多<br>数 server 的完成了和 leader 的状态同步以后，恢复模式就结束了。<br>61. 状态同步保证了 leader 和 server 具有相同的系统状态<br>62. 一旦 leader 已经和多数的 follower 进行了状态同步后，他就可以开始广播消息了，即进<br>入广播状态。这时候当一个 server 加入 zookeeper 服务中，它会在恢复模式下启动，发<br>现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。Zookeeper<br>服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的<br>followers 支持。<br>63. 广播模式需要保证 proposal 被按顺序处理，因此 zk 采用了递增的事务 id 号(zxid)来保<br>证。所有的提议(proposal)都在被提出的时候加上了 zxid。<br>64. 实现中 zxid 是一个 64 为的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，<br>每次一个 leader 被选出来，它都会有一个新的 epoch。低 32 位是个递增计数。<br>65. 当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式<br>需要重新选举出一个新的 leader，让所有的 server 都恢复到一个正确的状态。<br>11.1.3. Znode 有四种形式的目录节点<br>66. PERSISTENT：持久的节点。<br>67. EPHEMERAL：暂时的节点。<br>68. PERSISTENT_SEQUENTIAL：持久化顺序编号目录节点。<br>69. EPHEMERAL_SEQUENTIAL：暂时化顺序编号目录节点。<br>13&#x2F;04&#x2F;2018 Page 175 of 283<br>70. Kafka<br>12.1.1. Kafka 概念<br>Kafka 是一种高吞吐量、分布式、基于发布&#x2F;订阅的消息系统，最初由 LinkedIn 公司开发，使用<br>Scala 语言编写，目前是 Apache 的开源项目。<br>71. broker：Kafka 服务器，负责消息存储和转发<br>72. topic：消息类别，Kafka 按照 topic 来分类消息<br>73. partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个<br>partition 上<br>74. offset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的<br>唯一序号<br>75. Producer：消息生产者<br>76. Consumer：消息消费者<br>77. Consumer Group：消费者分组，每个 Consumer 必须属于一个 group<br>78. Zookeeper：保存着集群 broker、topic、partition 等 meta 数据；另外，还负责 broker 故<br>障发现，partition leader 选举，负载均衡等功能<br>12.1.2. Kafka 数据存储设计<br>12.1.2.1. partition 的数据文件（offset，MessageSize，data）<br>partition 中的每条 Message 包含了以下三个属性：offset，MessageSize，data，其中 offset 表<br>示 Message 在这个 partition 中的偏移量，offset 不是该 Message 在 partition 数据文件中的实<br>13&#x2F;04&#x2F;2018 Page 176 of 283<br>际存储位置，而是逻辑上一个值，它唯一确定了 partition 中的一条 Message，可以认为 offset 是<br>partition 中 Message 的 id；MessageSize 表示消息内容 data 的大小；data 为 Message 的具<br>体内容。<br>12.1.2.2. 数据文件分段 segment（顺序读写、分段命令、二分查找）<br>partition 物理上由多个 segment 文件组成，每个 segment 大小相等，顺序读写。每个 segment<br>数据文件以该段中最小的 offset 命名，文件扩展名为.log。这样在查找指定 offset 的 Message 的<br>时候，用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。<br>12.1.2.3. 数据文件索引（分段索引、稀疏存储）<br>Kafka 为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩<br>展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引，而是采用了稀疏存<br>储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以<br>将索引文件保留在内存中。<br>12.1.3. 生产者设计<br>12.1.3.1. 负载均衡（partition 会均衡分布到不同 broker 上）<br>由于消息 topic 由多个 partition 组成，且 partition 会均衡分布到不同 broker 上，因此，为了有<br>效利用 broker 集群的性能，提高消息的吞吐量，producer 可以通过随机或者 hash 等方式，将消<br>息平均发送到多个 partition 上，以实现负载均衡。<br>13&#x2F;04&#x2F;2018 Page 177 of 283<br>12.1.3.2. 批量发送<br>是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后，以一次请求的方式发<br>送了批量的消息给 broker，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响<br>了消息的实时性，相当于以时延代价，换取更好的吞吐量。<br>12.1.3.3. 压缩（GZIP 或 Snappy）<br>Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer 端进行压缩之后，在<br>Consumer 端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大<br>数据处理上，瓶颈往往体现在网络上而不是 CPU（压缩和解压会耗掉部分 CPU 资源）。<br>12.1.1. 消费者设计<br>13&#x2F;04&#x2F;2018 Page 178 of 283<br>12.1.1.1. Consumer Group<br>同一 Consumer Group 中的多个 Consumer 实例，不同时消费同一个 partition，等效于队列模<br>式。partition 内消息是有序的，Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息<br>对于 partition，顺序读写磁盘数据，以时间复杂度 O(1)方式提供消息持久化能力。<br>13&#x2F;04&#x2F;2018 Page 179 of 283<br>79. RabbitMQ<br>13.1.1. 概念<br>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。<br>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为<br>面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言<br>等条件的限制。<br>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可<br>用性等方面表现不俗。具体特点包括：<br>80. 可靠性（Reliability）：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布<br>确认。<br>81. 灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对<br>于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路<br>由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。<br>82. 消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。<br>83. 高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节<br>点出问题的情况下队列仍然可用。<br>84. 多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT<br>等等。<br>85. 多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、<br>Ruby 等等。<br>86. 管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控<br>和管理消息 Broker 的许多方面。<br>87. 跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生<br>了什么。<br>88. 插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编<br>写自己的插件。<br>13.1.2. RabbitMQ 架构<br>13&#x2F;04&#x2F;2018 Page 180 of 283<br>13.1.2.1. Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系<br>列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优<br>先权）、delivery-mode（指出该消息可能需要持久性存储）等。<br>13.1.2.2. Publisher<br>89. 消息的生产者，也是一个向交换器发布消息的客户端应用程序。<br>13.1.2.3. Exchange（将消息路由给队列 ）<br>90. 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>13.1.2.4. Binding（消息队列和交换器之间的关联）<br>91. 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连<br>接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。<br>13.1.2.5. Queue<br>92. 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息<br>可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。<br>13.1.2.6. Connection<br>93. 网络连接，比如一个 TCP 连接。<br>13.1.2.7. Channel<br>94. 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内地虚<br>拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这<br>些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所<br>以引入了信道的概念，以复用一条 TCP 连接。<br>13.1.2.8. Consumer<br>95. 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。<br>13.1.2.9. Virtual Host<br>96. 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密<br>环境的独立服务器域。<br>13&#x2F;04&#x2F;2018 Page 181 of 283<br>13.1.2.10.Broker<br>97. 表示消息队列服务器实体。<br>13.1.3. Exchange 类型<br>Exchange 分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、<br>topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和<br>direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：<br>13.1.3.1. Direct 键（routing key）分布：<br>98. Direct：消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，<br>交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。<br>13.1.3.2. Fanout（广播分发）<br>99. Fanout：每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。很像子<br>网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快<br>的。<br>13&#x2F;04&#x2F;2018 Page 182 of 283<br>13.1.3.3. topic 交换器（模式匹配）<br>100.topic 交换器：topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模<br>式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成<br>单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号<br>“”。#匹配 0 个或多个单词，匹配不多不少一个单词。<br>13&#x2F;04&#x2F;2018 Page 183 of 283<br>101.Hbase<br>14.1.1. 概念<br>base 是分布式、面向列的开源数据库（其实准确的说是面向列族）。HDFS 为 Hbase 提供可靠的<br>底层数据存储服务，MapReduce 为 Hbase 提供高性能的计算能力，Zookeeper 为 Hbase 提供<br>稳定服务和 Failover 机制，因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存<br>储和读取的分布式数据库解决方案。<br>14.1.2. 列式存储<br>列方式所带来的重要好处之一就是，由于查询中的选择规则是通过列来定义的，因此整个数据库<br>是自动索引化的。<br>这里的列式存储其实说的是列族存储，Hbase 是根据列族来存储数据的。列族下面可以有非常多<br>的列，列族在创建表的时候就必须指定。为了加深对 Hbase 列族的理解，下面是一个简单的关系<br>型数据库的表和 Hbase 数据库的表：<br>13&#x2F;04&#x2F;2018 Page 184 of 283<br>14.1.3. Hbase 核心概念<br>14.1.3.1. Column Family 列族<br>Column Family 又叫列族，Hbase 通过列族划分数据的存储，列族下面可以包含任意多的列，实<br>现灵活的数据存取。Hbase 表的创建的时候就必须指定列族。就像关系型数据库创建的时候必须<br>指定具体的列是一样的。Hbase 的列族不是越多越好，官方推荐的是列族最好小于或者等于 3。我<br>们使用的场景一般是 1 个列族。<br>14.1.3.2. Rowkey（Rowkey 查询，Rowkey 范围扫描，全表扫描）<br>Rowkey 的概念和 mysql 中的主键是完全一样的，Hbase 使用 Rowkey 来唯一的区分某一行的数<br>据。Hbase 只支持 3 中查询方式：基于 Rowkey 的单行查询，基于 Rowkey 的范围扫描，全表扫<br>描。<br>14.1.3.3. Region 分区<br> Region：Region 的概念和关系型数据库的分区或者分片差不多。Hbase 会将一个大表的数<br>据基于 Rowkey 的不同范围分配到不通的 Region 中，每个 Region 负责一定范围的数据访问<br>和存储。这样即使是一张巨大的表，由于被切割到不通的 region，访问起来的时延也很低。<br>14.1.3.4. TimeStamp 多版本<br> TimeStamp 是实现 Hbase 多版本的关键。在 Hbase 中使用不同的 timestame 来标识相同<br>rowkey 行对应的不通版本的数据。在写入数据的时候，如果用户没有指定对应的<br>timestamp，Hbase 会自动添加一个 timestamp，timestamp 和服务器时间保持一致。在<br>Hbase 中，相同 rowkey 的数据按照 timestamp 倒序排列。默认查询的是最新的版本，用户<br>可同指定 timestamp 的值来读取旧版本的数据。<br>14.1.4. Hbase 核心架构<br>Hbase 是由 Client、Zookeeper、Master、HRegionServer、HDFS 等几个组建组成。<br>13&#x2F;04&#x2F;2018 Page 185 of 283<br>14.1.4.1. Client：<br> Client 包含了访问 Hbase 的接口，另外 Client 还维护了对应的 cache 来加速 Hbase 的<br>访问，比如 cache 的.META.元数据的信息。<br>14.1.4.2. Zookeeper：<br> Hbase 通过 Zookeeper 来做 master 的高可用、RegionServer 的监控、元数据的入口<br>以及集群配置的维护等工作。具体工作如下：<br>102.通过 Zoopkeeper 来保证集群中只有 1 个 master 在运行，如果 master 异<br>常，会通过竞争机制产生新的 master 提供服务<br>103.通过 Zoopkeeper 来监控 RegionServer 的状态，当 RegionSevrer 有异常的<br>时候，通过回调的形式通知 Master RegionServer 上下限的信息<br>104.通过 Zoopkeeper 存储元数据的统一入口地址。<br>14.1.4.3. Hmaster<br> master 节点的主要职责如下：<br>105.为 RegionServer 分配 Region<br>106.维护整个集群的负载均衡<br>107.维护集群的元数据信息发现失效的 Region，并将失效的 Region 分配到正常<br>RegionServer 上当 RegionSever 失效的时候，协调对应 Hlog 的拆分<br>14.1.4.4. HregionServer<br> HregionServer 直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如<br>下：<br>108.管理 master 为其分配的 Region<br>13&#x2F;04&#x2F;2018 Page 186 of 283<br>109.处理来自客户端的读写请求<br>110.负责和底层 HDFS 的交互，存储数据到 HDFS<br>111.负责 Region 变大以后的拆分<br>112.负责 Storefile 的合并工作<br>14.1.4.5. Region 寻址方式（通过 zookeeper .META）<br>第 1 步：Client 请求 ZK 获取.META.所在的 RegionServer 的地址。<br>第 2 步：Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地<br>址，client 会将.META.的相关信息 cache 下来，以便下一次快速访问。<br>第 3 步：Client 请求数据所在的 RegionServer，获取所需要的数据。<br>14.1.4.6. HDFS<br> HDFS 为 Hbase 提供最终的底层数据存储服务，同时为 Hbase 提供高可用（Hlog 存储在<br>HDFS）的支持。<br>13&#x2F;04&#x2F;2018 Page 187 of 283<br>14.1.5. Hbase 的写逻辑<br>14.1.5.1. Hbase 的写入流程<br>从上图可以看出氛围 3 步骤：<br>获取 RegionServer<br>第 1 步：Client 获取数据写入的 Region 所在的 RegionServer<br>请求写 Hlog<br>第 2 步：请求写 Hlog, Hlog 存储在 HDFS，当 RegionServer 出现异常，需要使用 Hlog 来<br>恢复数据。<br>请求写 MemStore<br>第 3 步：请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。<br>MemStore 后续会逐渐刷到 HDFS 中。<br>14.1.5.2. MemStore 刷盘<br>为了提高 Hbase 的写入性能，当写请求写入 MemStore 后，不会立即刷盘。而是会等到一<br>定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢？总结成如下的几个场景：<br>13&#x2F;04&#x2F;2018 Page 188 of 283<br>全局内存控制<br>113.这个全局的参数是控制内存整体的使用情况，当所有 memstore 占整个 heap 的最大比<br>例的时候，会触发刷盘的操作。这个参数是<br>hbase.regionserver.global.memstore.upperLimit，默认为整个 heap 内存的 40%。<br>但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘，而是通过<br>另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制，默认是整个<br>heap 内存的 35%。当 flush 到所有 memstore 占整个 heap 内存的比率为 35%的时<br>候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的<br>目的。<br>MemStore 达到上限<br>114.当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷<br>盘，默认 128M 大小<br>RegionServer 的 Hlog 数量达到上限<br>115.前面说到 Hlog 为了保证 Hbase 数据的一致性，那么如果 Hlog 太多的话，会导致故障<br>恢复的时间太长，因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数<br>的时候，会强制刷盘。这个参数是 hase.regionserver.max.logs，默认是 32 个。<br>手工触发<br>116.可以通过 hbase shell 或者 java api 手工触发 flush 的操作。<br>关闭 RegionServer 触发<br>117.在正常关闭 RegionServer 会触发刷盘的操作，全部数据刷盘后就不需要再使用 Hlog 恢<br>复数据。<br>Region 使用 HLOG 恢复完数据后触发<br>118.：当 RegionServer 出现故障的时候，其上面的 Region 会迁移到其他正常的<br>RegionServer 上，在恢复完 Region 的数据后，会触发刷盘，当刷盘完成后才会提供给<br>业务访问。<br>14.1.6. HBase vs Cassandra<br>HBase Cassandra<br>语言 Java Java<br>出发点 BigTable BigTable and Dynamo<br>License Apache Apache<br>Protocol HTTP&#x2F;REST (also Thrift) Custom, binary (Thrift)<br>数据分布 表划分为多个 region 存在不同 region<br>server 上<br>改进的一致性哈希（虚拟节点）<br>存储目标 大文件 小文件<br>一致性 强一致性 最终一致性，Quorum NRW 策略<br>架构 master&#x2F;slave p2p<br>高可用性 NameNode 是 HDFS 的单点故障点 P2P 和去中心化设计，不会出现单点故障<br>伸缩性 Region Server 扩容，通过将自身发布到<br>Master，Master 均匀分布 Region<br>扩容需在 Hash Ring 上多个节点间调整数据分布<br>13&#x2F;04&#x2F;2018 Page 189 of 283<br>读写性能 数据读写定位可能要通过最多 6 次的网<br>络 RPC，性能较低。<br>数据读写定位非常快<br>数据冲突处理 乐观并发控制（optimistic concurrency<br>control）<br>向量时钟<br>临时故障处理 Region Server 宕机，重做 HLog 数据回传机制：某节点宕机，hash 到该节点的新数据自<br>动路由到下一节点做 hinted handoff，源节点恢复后，推<br>送回源节点。<br>永久故障恢复 Region Server 恢复，master 重新给其<br>分配 region<br>Merkle 哈希树，通过 Gossip 协议同步 Merkle Tree，维<br>护集群节点间的数据一致性<br>成员通信及错误检测 Zookeeper 基于 Gossip<br>CAP 1，强一致性，0 数据丢失。2，可用性<br>低。3，扩容方便。<br>1，弱一致性，数据可能丢失。2，可用性高。3，扩容方<br>便。<br>13&#x2F;04&#x2F;2018 Page 190 of 283<br>119.MongoDB<br>15.1.1. 概念<br>MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情<br>况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为 WEB 应用提供可扩展的高性能<br>数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似<br>于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<br>15.1.2. 特点<br> MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。<br> 你可以在 MongoDB 记录中设置任何属性的索引 (如：FirstName&#x3D;”Sameer”,Address&#x3D;”8 Ga<br>ndhi Road”)来实现更快的排序。<br> 你可以通过本地或者网络创建数据镜像，这使得 MongoDB 有更强的扩展性。<br> 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其<br>他节点上这就是所谓的分片。<br> Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的<br>对象及数组。<br> MongoDb 使用 update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。<br> Mongodb 中的 Map&#x2F;reduce 主要是用来对数据进行批量处理和聚合操作。<br> Map 和 Reduce。Map 函数调用 emit(key,value)遍历集合中所有的记录，将 key 与 value 传<br>给 Reduce 函数进行处理。<br> Map 函数和 Reduce 函数是使用 Javascript 编写的，并可以通过 db.runCommand 或 mapre<br>duce 命令来执行 MapReduce 操作。<br>13&#x2F;04&#x2F;2018 Page 191 of 283<br> GridFS 是 MongoDB 中的一个内置功能，可以用于存放大量小文件。<br> MongoDB 允许在服务端执行脚本，可以用 Javascript 编写某个函数，直接在服务端执行，也<br>可以把函数的定义存储在服务端，下次直接调用即可。<br>13&#x2F;04&#x2F;2018 Page 192 of 283<br>120.Cassandra<br>16.1.1. 概念<br>Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL 数据库。 Cassandra 旨在处理许<br>多商品服务器上的大量数据，提供高可用性而无需担心单点故障。<br>Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，<br>以获得高可用性，而无需担心单点故障。<br>16.1.2. 数据模型<br>Key Space（对应 SQL 数据库中的 database）<br>121.一个 Key Space 中可包含若干个 CF，如同 SQL 数据库中一个 database 可包含多个 table<br>Key（对应 SQL 数据库中的主键）<br>122.在 Cassandra 中，每一行数据记录是以 key&#x2F;value 的形式存储的，其中 key 是唯一标识。<br>column（对应 SQL 数据库中的列）<br>123.Cassandra 中每个 key&#x2F;value 对中的 value 又称为 column，它是一个三元组，即：name，<br>value 和 timestamp，其中 name 需要是唯一的。<br>super column（SQL 数据库不支持）<br>124.cassandra 允许 key&#x2F;value 中的 value 是一个 map(key&#x2F;value_list)，即某个 column 有多个<br>子列。<br>Standard Column Family（相对应 SQL 数据库中的 table）<br>125.每个 CF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 column。<br>Super Column Family（SQL 数据库不支持）<br>126.每个 SCF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 super column。<br>16.1.3. Cassandra 一致 Hash 和虚拟节点<br>一致性 Hash（多米诺 down 机）<br>为每个节点分配一个 token，根据这个 token 值来决定节点在集群中的位置以及这个节点所存储<br>的数据范围。<br>13&#x2F;04&#x2F;2018 Page 193 of 283<br>虚拟节点（down 机多节点托管）<br>由于这种方式会造成数据分布不均的问题，在 Cassandra1.2 以后采用了虚拟节点的思想：不需要<br>为每个节点分配 token，把圆环分成更多部分，让每个节点负责多个部分的数据，这样一个节点移<br>除后，它所负责的多个 token 会托管给多个节点处理，这种思想解决了数据分布不均的问题。<br>如图所示，上面部分是标准一致性哈希，每个节点负责圆环中连续的一段，如果 Node2 突然<br>down 掉，Node2 负责的数据托管给 Node1，即 Node1 负责 EFAB 四段，如果 Node1 里面有<br>很多热点用户产生的数据导致 Node1 已经有点撑不住了，恰巧 B 也是热点用户产生的数据，这样<br>一来 Node1 可能会接着 down 机，Node1down 机，Node6 还 hold 住吗？<br>下面部分是虚拟节点实现，每个节点不再负责连续部分，且圆环被分为更多的部分。如果 Node2<br>突然 down 掉，Node2 负责的数据不全是托管给 Node1，而是托管给多个节点。而且也保持了一<br>致性哈希的特点。<br>16.1.4. Gossip 协议<br>Gossip 算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都<br>会知道该八卦的信息，这种方式也与病毒传播类似，因此 Gossip 有众多的别名“闲话算法”、<br>“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 Gossip 的特点：在一个有界网络中，<br>每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一<br>致。因为 Gossip 不要求节点知道所有其他节点，因此又具有去中心化的特点，节点之间完全对等，<br>不需要任何的中心节点。实际上 Gossip 可以用于众多能接受“最终一致性”的领域：失败检测、<br>路由同步、Pub&#x2F;Sub、动态负载均衡。<br>13&#x2F;04&#x2F;2018 Page 194 of 283<br>Gossip 节点的通信方式及收敛性<br>Gossip 两个节点（A、B）之间存在三种通信方式（push、pull、push&amp;pull）<br>127.push: A 节点将数据(key,value,version)及对应的版本号推送给 B 节点，B 节点更新 A 中比自<br>己新的数据。<br>128.pull：A 仅将数据 key,version 推送给 B，B 将本地比 A 新的数据（Key,value,version）推送<br>给 A，A 更新本地。<br>129.push&#x2F;pull：与 pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 更新本地。<br>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push 需通信 1 次，pull 需 2 次，<br>push&#x2F;pull 则需 3 次，从效果上来讲，push&#x2F;pull 最好，理论上一个周期内可以使两个节点完全一<br>致。直观上也感觉，push&#x2F;pull 的收敛速度是最快的。<br>gossip 的协议和 seed list（防止集群分列）<br>cassandra 使用称为 gossip 的协议来发现加入 C 集群中的其他节点的位置和状态信息。gossip 进<br>程每秒都在进行，并与至多三个节点交换状态信息。节点交换他们自己和所知道的信息，于是所<br>有的节点很快就能学习到整个集群中的其他节点的信息。gossip 信息有一个相关的版本号，于是<br>在一次 gossip 信息交换中，旧的信息会被新的信息覆盖重写。要阻止分区进行 gossip 交流，那么<br>在集群中的所有节点中使用相同的 seed list，种子节点的指定除了启动起 gossip 进程外，没有其<br>他的目的。种子节点不是一个单点故障，他们在集群操作中也没有其他的特殊目的，除了引导节<br>点以外<br>16.1.5. 数据复制<br>Partitioners（计算 primary key token 的 hash 函数）<br>在 Cassandra 中，table 的每行由唯一的 primarykey 标识，partitioner 实际上为一 hash 函数用<br>以计算 primary key 的 token。Cassandra 依据这个 token 值在集群中放置对应的行<br>两种可用的复制策略：<br>SimpleStrategy：仅用于单数据中心，<br>将第一个 replica 放在由 partitioner 确定的节点中，其余的 replicas 放在上述节点顺时针方向的<br>后续节点中。<br>NetworkTopologyStrategy：可用于较复杂的多数据中心。<br>可以指定在每个数据中心分别存储多少份 replicas。<br>复制策略在创建 keyspace 时指定，如<br>CREATE KEYSPACE Excelsior WITH REPLICATION &#x3D; { ‘class’ :<br>‘SimpleStrategy’,’replication_factor’ : 3 };<br>CREATE KEYSPACE Excalibur WITH REPLICATION &#x3D; {‘class’ :’NetworkTopologyStrategy’,<br>‘dc1’ : 3, ‘dc2’ : 2};<br>13&#x2F;04&#x2F;2018 Page 195 of 283<br>16.1.6. 数据写请求和协调者<br>协调者(coordinator)<br>协调者(coordinator)将 write 请求发送到拥有对应 row 的所有 replica 节点，只要节点可用便获取<br>并执行写请求。写一致性级别(write consistency level)确定要有多少个 replica 节点必须返回成功<br>的确认信息。成功意味着数据被正确写入了 commit log 和 memtable。<br>其中 dc1、dc2 这些数据中心名称要与 snitch 中配置的名称一致.上面的拓扑策略表示在 dc1 配置<br>3 个副本,在 dc2 配置 2 个副本<br>16.1.7. 数据读请求和后台修复<br>130.协调者首先与一致性级别确定的所有 replica 联系，被联系的节点返回请求的数据。<br>131.若多个节点被联系，则来自各 replica 的 row 会在内存中作比较，若不一致，则协调者使用含<br>最新数据的 replica 向 client 返回结果。那么比较操作过程中只需要传递时间戳就可以,因为要<br>比较的只是哪个副本数据是最新的。<br>132.协调者在后台联系和比较来自其余拥有对应 row 的 replica 的数据，若不一致，会向过时的<br>replica 发写请求用最新的数据进行更新 read repair。<br>13&#x2F;04&#x2F;2018 Page 196 of 283<br>16.1.8. 数据存储（CommitLog、MemTable、SSTable）<br>写请求分别到 CommitLog 和 MemTable, 并且 MemTable 的数据会刷写到磁盘 SSTable 上. 除<br>了写数据,还有索引也会保存到磁盘上.<br>先将数据写到磁盘中的 commitlog，同时追加到中内存中的数据结构 memtable 。这个时候就会<br>返回客户端状态 ， memtable 内 容 超 出 指 定 容 量 后 会 被 放 进 将 被 刷 入 磁 盘 的 队 列<br>(memtable_flush_queue_size 配置队列长度)。若将被刷入磁盘的数据超出了队列长度，将内存<br>数据刷进磁盘中的 SSTable,之后 commit log 被清空。<br>SSTable 文件构成（BloomFilter、index、data、static）<br>SSTable 文件有 fileer（判断数据 key 是否存在，这里使用了 BloomFilter 提高效率），index（寻<br>找对应 column 值所在 data 文件位置）文件，data（存储真实数据）文件，static（存储和统计<br>column 和 row 大小）文件。<br>16.1.9. 二级索引（对要索引的 value 摘要，生成 RowKey）<br>在 Cassandra 中，数据都是以 Key-value 的形式保存的。<br>13&#x2F;04&#x2F;2018 Page 197 of 283<br>KeysIndex 所创建的二级索引也被保存在一张 ColumnFamily 中。在插入数据时，对需要进行索<br>引的 value进行摘要，生成独一无二的key，将其作为 RowKey保存在索引的 ColumnFamily 中；<br>同时在 RowKey 上添加一个 Column，将插入数据的 RowKey 作为 name 域的值，value 域则赋<br>空值，timestamp 域则赋为插入数据的时间戳。<br>如果有相同的 value 被索引了，则会在索引 ColumnFamily 中相同的 RowKey 后再添加新的<br>Column。如果有新的 value 被索引，则会在索引 ColumnFamily 中添加新的 RowKey 以及对应<br>新的 Column。<br>当对 value 进行查询时，只需计算该 value 的 RowKey，在索引 ColumnFamily 中的查找该<br>RowKey，对其 Columns 进行遍历就能得到该 value 所有数据的 RowKey。<br>16.1.10. 数据读写<br>数据写入和更新（数据追加）<br>Cassandra 的设计思路与这些系统不同，无论是 insert 还是 remove 操作，都是在已有的数据后<br>面进行追加，而不修改已有的数据。这种设计称为 Log structured 存储，顾名思义就是系统中的<br>数据是以日志的形式存在的，所以只会将新的数据追加到已有数据的后面。Log structured 存储<br>系统有两个主要优点：<br>数据的写和删除效率极高<br> 传统的存储系统需要更新元信息和数据，因此磁盘的磁头需要反复移动，这是一个比较耗时<br>的操作，而 Log structured 的系统则是顺序写，可以充分利用文件系统的 cache，所以效率<br>很高。<br>错误恢复简单<br> 由于数据本身就是以日志形式保存，老的数据不会被覆盖，所以在设计 journal 的时候不需<br>要考虑 undo，简化了错误恢复。<br>读的复杂度高<br> 但是，Log structured 的存储系统也引入了一个重要的问题：读的复杂度和性能。理论上<br>说，读操作需要从后往前扫描数据，以找到某个记录的最新版本。相比传统的存储系统，这<br>是比较耗时的。<br>数据删除（column 的墓碑）<br>如果一次删除操作在一个节点上失败了（总共 3 个节点，副本为 3， RF&#x3D;3).整个删除操作仍然被<br>认为成功的（因为有两个节点应答成功，使用 CL.QUORUM 一致性）。接下来如果读发生在该节<br>点上就会变的不明确，因为结果返回是空，还是返回数据，没有办法确定哪一种是正确的。<br>13&#x2F;04&#x2F;2018 Page 198 of 283<br>Cassandra 总是认为返回数据是对的，那就会发生删除的数据又出现了的事情，这些数据可以叫”<br>僵尸”，并且他们的表现是不可预见的。<br>墓碑<br>删除一个 column 其实只是插入一个关于这个 column 的墓碑（tombstone），并不直接删除原<br>有的 column。该墓碑被作为对该 CF 的一次修改记录在 Memtable 和 SSTable 中。墓碑的内容<br>是删除请求被执行的时间，该时间是接受客户端请求的存储节点在执行该请求时的本地时间<br>（local delete time），称为本地删除时间。需要注意区分本地删除时间和时间戳，每个 CF 修改<br>记录都有一个时间戳，这个时间戳可以理解为该 column 的修改时间，是由客户端给定的。<br>垃圾回收 compaction<br>由于被删除的 column 并不会立即被从磁盘中删除，所以系统占用的磁盘空间会越来越大，这就<br>需要有一种垃圾回收的机制，定期删除被标记了墓碑的 column。垃圾回收是在 compaction 的过<br>程中完成的。<br>数据读取（memtable+SStables）<br>为了满足读 cassandra 读取的数据是 memtable 中的数据和 SStables 中数据的合并结果。读取<br>SSTables 中的数据就是查找到具体的哪些的 SSTables 以及数据在这些 SSTables 中的偏移量<br>(SSTables 是按主键排序后的数据块)。首先如果 row cache enable 了话，会检测缓存。缓存命中<br>直接返回数据，没有则查找 Bloom filter，查找可能的 SSTable。然后有一层 Partition key cache，<br>找 partition key 的位置。如果有根据找到的 partition 去压缩偏移量映射表找具体的数据块。如果<br>缓存没有，则要经过 Partition summary,Partition index 去找 partition key。然后经过压缩偏移<br>量映射表找具体的数据块。<br>133.检查 memtable<br>134.如果 enabled 了,检查 row cache<br>135.检查 Bloom filter<br>136.如果 enable 了,检查 partition key 缓存<br>137.如果在 partition key 缓存中找到了 partition key,直接去 compression offset 命中，如果没<br>有，检查 partition summary<br>138.根据 compression offset map 找到数据位置<br>139.从磁盘的 SSTable 中取出数据<br>13&#x2F;04&#x2F;2018 Page 199 of 283<br>行缓存和键缓存请求流程图<br>MemTable：如果 memtable 有目标分区数据，这个数据会被读出来并且和从 SSTables 中读出<br>来的数据进行合并。SSTable 的数据访问如下面所示的步骤。<br>Row Cache（SSTables 中频繁被访问的数据）<br>在 Cassandra2.2+，它们被存储在堆外内存，使用全新的实现避免造成垃圾回收对 JVM 造成压力。<br>存在在 row cache 的子集数据可以在特定的一段时间内配置一定大小的内存。row cache 使用<br>LRU(least-recently-userd)进行回收在申请内存。存储在 row cache 中的数据是 SSTables 中频繁<br>被访问的数据。存储到row cache中后，数据就可以被后续的查询访问。row cache不是写更新。<br>如果写某行了，这行的缓存就会失效，并且不会被继续缓存，直到这行被读到。类似的，如果一<br>个partition更新了，整个partition的cache都会被移除，但目标的数据在row cache中找不到，<br>就会去检查 Bloom filter。<br>13&#x2F;04&#x2F;2018 Page 200 of 283<br>Bloom Filter（查找数据可能对应的 SSTable）<br>首先，Cassandra 检查 Bloom filter 去发现哪个 SSTables 中有可能有请求的分区数据。Bloom<br>filter 是存储在堆外内存。每个 SSTable 都有一个关联的 Bloom filter。一个 Bloom filter 可以建<br>立一个 SSTable 没有包含的特定的分区数据。同样也可以找到分区数据存在 SSTable 中的可能性。<br>它可以加速查找 partition key 的查找过程。然而，因为 Bloom filter 是一个概率函数，所以可能<br>会得到错误的结果，并不是所有的 SSTables 都可以被 Bloom filter 识别出是否有数据。如果<br>Bloom filter 不能够查找到 SSTable，Cassandra 会检查 partition key cache。Bloom filter 大小<br>增长很适宜，每 10 亿数据 1~2GB。在极端情况下，可以一个分区一行。都可以很轻松的将数十<br>亿的 entries 存储在单个机器上。Bloom filter 是可以调节的，如果你愿意用内存来换取性能。<br>Partition Key Cache（查找数据可能对应的 Partition key）<br>partition key 缓存如果开启了，将 partition index 存储在堆外内存。key cache 使用一小块可配<br>置大小的内存。在读的过程中，每个”hit”保存一个检索。如果在 key cache 中找到了 partition<br>key。就直接到 compression offset map 中招对应的块。partition key cache 热启动后工作的更<br>好，相比较冷启动，有很大的性能提升。如果一个节点上的内存非常受限制，可能的话，需要限<br>制保存在 key cache 中的 partition key 数目。如果一个在 key cache 中没有找到 partition key。<br>就会去partition summary中去找。partition key cache 大小是可以配置的，意义就是存储在key<br>cache 中的 partition keys 数目。<br>Partition Summary（内存中存储一些 partition index 的样本）<br>partition summary 是存储在堆外内存的结构，存储一些 partition index 的样本。如果一个<br>partition index 包含所有的 partition keys。鉴于一个 partition summary 从每 X 个 keys 中取<br>样，然后将每 X 个 key map 到 index 文件中。例如，如果一个 partition summary 设置了 20keys<br>进行取样。它就会存储 SSTable file 开始的一个 key,20th 个 key，以此类推。尽管并不知道<br>partition key 的具体位置，partition summary 可以缩短找到 partition 数据位置。当找到了<br>partition key 值可能的范围后，就会去找 partition index。通过配置取样频率，你可以用内存来<br>换取性能，当 partition summary 包含的数据越多，使用的内存越多。可以通过表定义的 index<br>interval 属性来改变样本频率。固定大小的内存可以通过 index_summary_capacity_in_mb 属性<br>来设置，默认是堆大小的 5%。<br>Partition Index（磁盘中）<br>partition index 驻扎在磁盘中，索引所有 partition keys 和偏移量的映射。如果 partition<br>summary 已经查到 partition keys 的范围，现在的检索就是根据这个范围值来检索目标 partition<br>key。需要进行单次检索和顺序读。根据找到的信息。然后去 compression offset map 中去找磁<br>盘中有这个数据的块。如果 partition index 必须要被检索，则需要检索两次磁盘去找到目标数据。<br>Compression offset map（磁盘中）<br>compression offset map 存储磁盘数据准确位置的指针。存储在堆外内存，可以被 partition key<br>cache 或者 partition index 访问。一旦 compression offset map 识别出来磁盘中的数据位置，<br>就会从正确的 SStable(s)中取出数据。查询就会收到结果集。<br>13&#x2F;04&#x2F;2018 Page 201 of 283<br>141.负载均衡<br>负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带<br>宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>18.1.1. 四层负载均衡 vs 七层负载均衡<br>18.1.1.1. 四层负载均衡（目标地址和端口交换）<br>主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择<br>的内部服务器。<br>以常见的 TCP 为例，负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选<br>择一个最佳的服务器，并对报文中目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务<br>器。TCP 的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类<br>似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在<br>转发报文的同时可能还会对报文原来的源地址进行修改。实现四层负载均衡的软件有：<br>F5：硬件负载均衡器，功能很好，但是成本很高。<br>lvs：重量级的四层负载软件。<br>nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活。<br>haproxy：模拟四层转发，较灵活。<br>18.1.1.2. 七层负载均衡（内容交换）<br>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，<br>再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。<br>13&#x2F;04&#x2F;2018 Page 204 of 283<br>七层应用负载的好处，是使得整个网络更智能化。例如访问一个网站的用户流量，可以通过七层<br>的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可<br>以转发到特定的文字服务器并可以使用压缩技术。实现七层负载均衡的软件有：<br>haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移；<br>nginx：只在 http 协议和 mail 协议上功能比较好，性能与 haproxy 差不多；<br>apache：功能较差<br>Mysql proxy：功能尚可。<br>18.1.2. 负载均衡算法&#x2F;策略<br>18.1.2.1. 轮循均衡（Round Robin）<br>每一次来自网络的请求轮流分配给内部中的服务器，从 1 至 N 然后重新开始。此种均衡算法适合<br>于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。<br>18.1.2.2. 权重轮循均衡（Weighted Round Robin）<br>根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请<br>求。例如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则服务器 A、B、C 将分<br>别接受到 10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用<br>率，避免低性能的服务器负载过重。<br>18.1.2.3. 随机均衡（Random）<br>把来自网络的请求随机分配给内部中的多个服务器。<br>18.1.2.4. 权重随机均衡（Weighted Random）<br>此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。<br>18.1.2.5. 响应速度均衡（Response Time 探测时间）<br>负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测<br>请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映<br>服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时<br>间，而不是客户端与服务器间的最快响应时间。<br>13&#x2F;04&#x2F;2018 Page 205 of 283<br>18.1.2.6. 最少连接数均衡（Least Connection）<br>最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在<br>处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡<br>更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如 FTP。<br>18.1.2.7. 处理能力均衡（CPU、内存）<br>此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器 CPU 型号、CPU 数量、内存大小<br>及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行<br>状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况<br>下。<br>18.1.2.8. DNS 响应均衡（Flash DNS）<br>在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在<br>同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端，则客户端将以最先收到<br>的域名解析 IP 地址来继续请求服务，而忽略其它的 IP 地址响应。在种均衡策略适合应用在全局负<br>载均衡的情况下，对本地负载均衡是没有意义的。<br>18.1.2.9. 哈希算法<br>一致性哈希一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往<br>该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。<br>18.1.2.10. IP 地址散列（保证客户端服务器对应关系稳定）<br>通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分<br>组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信<br>时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处<br>理。<br>18.1.2.11.URL 散列<br>通过管理客户端请求 URL 信息的散列，将发送至相同 URL 的请求转发至同一服务器的算法。<br>13&#x2F;04&#x2F;2018 Page 206 of 283<br>18.1.3. LVS<br>18.1.3.1. LVS 原理<br>IPVS<br>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的，IPVS 是 LVS 集群系统的核心软件，它的主要<br>作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通<br>过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。访问的请求<br>首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server 列表中选取一个服务节点响应用<br>户的请求。 在用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的 Real Server 节<br>点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。<br>ipvs ： 工作于内核空间，主要用于使用户定义的策略生效<br>ipvsadm : 工作于用户空间，主要用于用户定义和管理集群服务的工具<br>ipvs 工作于内核空间的 INPUT 链上，当收到用户请求某集群服务时，经过 PREROUTING 链，经<br>检查本机路由表，送往 INPUT 链；在进入 netfilter 的 INPUT 链时，ipvs 强行将请求报文通过<br>ipvsadm 定义的集群服务策略的路径改为 FORWORD 链，将报文转发至后端真实提供服务的主机。<br>13&#x2F;04&#x2F;2018 Page 207 of 283<br>18.1.3.1. LVS NAT 模式<br>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP(客户端 IP),后面统称为 CIP)，目<br>标地址为 VIP(负载均衡器前端地址，后面统称为 VIP)。<br>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的目<br>标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去。<br>③.报文送到 Real Server 后，由于报文的目标地址是自己，所以会响应该请求，并将响应报文返还<br>给 LVS。<br>④.然后 lvs 将此报文的源地址修改为本机并发送给客户端。<br>注意：在 NAT 模式中，Real Server 的网关必须指向 LVS，否则报文无法送达客户端<br>特点：<br>1、NAT 技术将请求的报文和响应的报文都需要通过 LB 进行地址改写，因此网站访问量比较大的<br>时候 LB 负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点<br>2、只需要在 LB 上配置一个公网 IP 地址就可以了。<br>3、每台内部的 realserver 服务器的网关地址必须是调度器 LB 的内网地址。<br>4、NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。<br>优点：<br>集群中的物理服务器可以使用任何支持 TCP&#x2F;IP 操作系统，只有负载均衡器需要一个合法的 IP 地<br>址。<br>缺点：<br>13&#x2F;04&#x2F;2018 Page 208 of 283<br>扩展性有限。当服务器节点（普通 PC 服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因<br>为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇<br>在负载均衡器那，速度就会变慢！<br>18.1.3.2. LVS DR 模式（局域网改写 mac 地址）<br>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。<br>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的源<br>MAC 地址改为自己 DIP 的 MAC 地址，目标 MAC 改为了 RIP 的 MAC 地址，并将此包发送给 RS。<br>③.RS 发现请求报文中的目的 MAC 是自己，就会将次报文接收下来，处理完请求报文后，将响应<br>报文通过 lo 接口送给 eth0 网卡直接发送给客户端。<br>注意：需要设置 lo 接口的 VIP 不能响应本地网络内的 arp 请求。<br>总结：<br>1、通过在调度器 LB 上修改数据包的目的 MAC 地址实现转发。注意源地址仍然是 CIP，目的地址<br>仍然是 VIP 地址。<br>2、请求的报文经过调度器，而 RS 响应处理后的报文无需经过调度器 LB，因此并发访问量大时使<br>用效率很高（和 NAT 模式比）<br>3、因为 DR 模式是通过 MAC 地址改写机制实现转发，因此所有 RS 节点和调度器 LB 只能在一个<br>局域网里面<br>4、RS 主机需要绑定 VIP 地址在 LO 接口（掩码 32 位）上，并且需要配置 ARP 抑制。<br>5、RS 节点的默认网关不需要配置成 LB，而是直接配置为上级路由的网关，能让 RS 直接出网就<br>可以。<br>13&#x2F;04&#x2F;2018 Page 209 of 283<br>6、由于 DR 模式的调度器仅做 MAC 地址的改写，所以调度器 LB 就不能改写目标端口，那么 RS<br>服务器就得使用和 VIP 相同的端口提供服务。<br>7、直接对外的业务比如 WEB 等，RS 的 IP 最好是使用公网 IP。对外的服务，比如数据库等最好<br>使用内网 IP。<br>优点：<br>和 TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户<br>端。与 VS-TUN 相比，VS-DR 这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为<br>物理服务器。<br>DR 模式的效率很高，但是配置稍微复杂一点，因此对于访问量不是特别大的公司可以用<br>haproxy&#x2F;nginx取代。日1000-2000W PV或者并发请求1万一下都可以考虑用haproxy&#x2F;nginx。<br>缺点：<br>所有 RS 节点和调度器 LB 只能在一个局域网里面<br>18.1.3.3. LVS TUN 模式（IP 封装、跨网段）<br>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。<br>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将在客户端请求报文的<br>首部再封装一层 IP 报文,将源地址改为 DIP，目标地址改为 RIP,并将此包发送给 RS。<br>③.RS 收到请求报文后，会首先拆开第一层封装,然后发现里面还有一层 IP 首部的目标地址是自己<br>lo 接口上的 VIP，所以会处理次请求报文，并将响应报文通过 lo 接口送给 eth0 网卡直接发送给客<br>户端。<br>注意：需要设置 lo 接口的 VIP 不能在共网上出现。<br>13&#x2F;04&#x2F;2018 Page 210 of 283<br>总结：<br>1.TUNNEL 模式必须在所有的 realserver 机器上面绑定 VIP 的 IP 地址<br>2.TUNNEL 模式的 vip ——&gt;realserver 的包通信通过 TUNNEL 模式，不管是内网和外网都能通<br>信，所以不需要 lvs vip 跟 realserver 在同一个网段内。<br>3.TUNNEL 模式 realserver 会把 packet 直接发给 client 不会给 lvs 了<br>4.TUNNEL 模式走的隧道模式，所以运维起来比较难，所以一般不用。<br>优点：<br>负载均衡器只负责将请求包分发给后端节点服务器，而 RS 将应答包直接发给用户。所以，减少了<br>负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方<br>式，一台负载均衡器能够为很多 RS 进行分发。而且跑在公网上就能进行不同地域的分发。<br>缺点：<br>隧道模式的 RS 节点需要合法 IP，这种方式需要所有的服务器支持”IP Tunneling”(IP<br>Encapsulation)协议，服务器可能只局限在部分 Linux 系统上。<br>18.1.3.4. LVS FULLNAT 模式<br>无论是 DR 还是 NAT 模式，不可避免的都有一个问题：LVS 和 RS 必须在同一个 VLAN 下，否则<br>LVS 无法作为 RS 的网关。这引发的两个问题是：<br>1、同一个 VLAN 的限制导致运维不方便，跨 VLAN 的 RS 无法接入。<br>2、LVS 的水平扩展受到制约。当 RS 水平扩容时，总有一天其上的单点 LVS 会成为瓶颈。<br>Full-NAT 由此而生，解决的是 LVS 和 RS 跨 VLAN 的问题，而跨 VLAN 问题解决后，LVS 和 RS<br>不再存在 VLAN 上的从属关系，可以做到多个 LVS 对应多个 RS，解决水平扩容的问题。<br>Full-NAT 相比 NAT 的主要改进是，在 SNAT&#x2F;DNAT 的基础上，加上另一种转换，转换过程如下：<br>13&#x2F;04&#x2F;2018 Page 211 of 283<br>142.在包从 LVS 转到 RS 的过程中，源地址从客户端 IP 被替换成了 LVS 的内网 IP。内网 IP 之间<br>可以通过多个交换机跨 VLAN 通信。目标地址从 VIP 修改为 RS IP.<br>143.当 RS 处理完接受到的包，处理完成后返回时，将目标地址修改为 LVS ip，原地址修改为 RS<br>IP，最终将这个包返回给 LVS 的内网 IP，这一步也不受限于 VLAN。<br>144.LVS 收到包后，在 NAT 模式修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内<br>网 IP 改为客户端的 IP,并将原地址修改为 VIP。<br>Full-NAT 主要的思想是把网关和其下机器的通信，改为了普通的网络通信，从而解决了跨 VLAN<br>的问题。采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的<br>便利性。<br>总结<br>145.FULL NAT 模式不需要 LBIP 和 realserver ip 在同一个网段；<br>146.full nat 因为要更新 sorce ip 所以性能正常比 nat 模式下降 10%<br>18.1.4. Keepalive<br>keepalive 起初是为 LVS 设计的，专门用来监控 lvs 各个服务节点的状态，后来加入了 vrrp 的功<br>能，因此除了 lvs，也可以作为其他服务（nginx，haproxy）的高可用软件。VRRP 是 virtual<br>router redundancy protocal（虚拟路由器冗余协议）的缩写。VRRP 的出现就是为了解决静态路<br>由出现的单点故障，它能够保证网络可以不间断的稳定的运行。所以 keepalive 一方面具有 LVS<br>cluster node healthcheck 功能，另一方面也具有 LVS director failover。<br>18.1.5. Nginx 反向代理负载均衡<br>普通的负载均衡软件，如 LVS，其实现的功能只是对请求数据包的转发、传递，从负载均衡下的节<br>点服务器来看，接收到的请求还是来自访问负载均衡器的客户端的真实用户；而反向代理就不一<br>13&#x2F;04&#x2F;2018 Page 212 of 283<br>样了，反向代理服务器在接收访问用户请求后，会代理用户 重新发起请求代理下的节点服务器，<br>最后把数据返回给客户端用户。在节点服务器看来，访问的节点服务器的客户端用户就是反向代<br>理服务器，而非真实的网站访问用户。<br>18.1.5.1. upstream_module 和健康检测<br>ngx_http_upstream_module 是负载均衡模块，可以实现网站的负载均衡功能即节点的健康检<br>查，upstream 模块允许 Nginx 定义一组或多组节点服务器组，使用时可通过 proxy_pass 代理方<br>式把网站的请求发送到事先定义好的对应 Upstream 组 的名字上。<br>upstream 模块<br>内参数<br>参数说明<br>weight 服务器权重<br>max_fails Nginx 尝试连接后端主机失败的此时，这是值是配合 proxy_next_upstream、<br>fastcgi_next_upstream 和 memcached_next_upstream 这三个参数来使用的。当 Nginx<br>接收后端服务器返回这三个参数定义的状态码时，会将这个请求转发给正常工作的的后端服<br>务器。如 404、503、503,max_files&#x3D;1<br>fail_timeout max_fails 和 fail_timeout 一般会关联使用，如果某台 server 在 fail_timeout 时间内出现了<br>max_fails 次连接失败，那么 Nginx 会认为其已经挂掉，从而在 fail_timeout 时间内不再去<br>请求它，fail_timeout 默认是 10s，max_fails 默认是 1，即默认情况只要是发生错误就认为<br>服务器挂了，如果将 max_fails 设置为 0，则表示取消这项检查<br>backup 表示当前 server 是备用服务器，只有其它非 backup 后端服务器都挂掉了或很忙才会分配请<br>求给它<br>down 标志服务器永远不可用，可配合 ip_hash 使用<br>upstream lvsServer{<br>server 191.168.1.11 weight&#x3D;5 ;<br>server 191.168.1.22:82;<br>server example.com:8080 max_fails&#x3D;2 fail_timeout&#x3D;10s backup;<br>#域名的话需要解析的哦，内网记得 hosts<br>}<br>18.1.5.1. proxy_pass 请求转发<br>proxy_pass 指令属于 ngx_http_proxy_module 模块，此模块可以将请求转发到另一台服务器，<br>在实际的反向代理工作中，会通过 location 功能匹配指定的 URI，然后把接收到服务匹配 URI 的<br>请求通过 proyx_pass 抛给定义好的 upstream 节点池。<br>location &#x2F;download&#x2F; {<br>proxy_pass <a target="_blank" rel="noopener" href="http://download/vedio/">http://download/vedio/</a>;<br>}<br>#这是前端代理节点的设置<br>13&#x2F;04&#x2F;2018 Page 213 of 283<br>#交给后端 upstream 为 download 的节点<br>proxy 模块参数 说明<br>proxy_next_upstream 什么情况下将请求传递到下一个 upstream<br>proxy_limite_rate 限制从后端服务器读取响应的速率<br>proyx_set_header 设置 http 请求 header 传给后端服务器节点，如：可实现让代<br>理后端的服务器节点获取访问客户端的这是 ip<br>client_body_buffer_size 客户端请求主体缓冲区大小<br>proxy_connect_timeout 代理与后端节点服务器连接的超时时间<br>proxy_send_timeout 后端节点数据回传的超时时间<br>proxy_read_timeout 设置 Nginx 从代理的后端服务器获取信息的时间，表示连接成<br>功建立后，Nginx 等待后端服务器的响应时间<br>proxy_buffer_size 设置缓冲区大小<br>proxy_buffers 设置缓冲区的数量和大小<br>proyx_busy_buffers_size 用于设置系统很忙时可以使用的 proxy_buffers 大小，推荐为<br>proxy_buffers*2<br>proxy_temp_file_write_size 指定 proxy 缓存临时文件的大小<br>18.1.6. HAProxy<br>13&#x2F;04&#x2F;2018 Page 214 of 283<br>147.数据库<br>19.1.1. 存储引擎<br>19.1.1.1. 概念<br>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、<br>更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同<br>的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引<br>擎。存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。<br>19.1.1.2. InnoDB（B+树）<br>InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，<br>一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。<br>适用场景：<br>1）经常更新的表，适合处理多重并发的更新请求。<br>2）支持事务。<br>3）可以从灾难中恢复（通过 bin-log 日志等）。<br>4）外键约束。只有他支持外键。<br>5）支持自动增加列属性 auto_increment。<br>13&#x2F;04&#x2F;2018 Page 215 of 283<br>19.1.1.3. TokuDB（Fractal Tree-节点带数据）<br>TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree<br>中，每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个<br>Message Buffer 是一个 FIFO 的队列，用来缓存更新操作。<br>例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶<br>子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。<br>TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优<br>势。 他主要适用于访问频率不高的数据或历史数据归档。<br>19.1.1.4. MyIASM<br>MyIASM是 MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，<br>因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。<br>ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织<br>成有固定长度的记录，按顺序存储的。—ISAM 是一种静态索引结构。<br>缺点是它不 支持事务处理。<br>19.1.1.5. Memory<br>Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应<br>一个磁盘文件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用<br>HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉。 Memory 同时支持散列索引和 B 树索<br>引，B树索引可以使用部分查询和通配查询，也可以使用&lt;,&gt;和&gt;&#x3D;等操作符方便数据挖掘，散列索<br>引相等的比较快但是对于范围的比较慢很多。<br>19.1.2. 索引<br>索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二<br>叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree）<br>13&#x2F;04&#x2F;2018 Page 216 of 283<br>19.1.2.1. 常见索引原则有<br>1.选择唯一性索引<br>1．唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。<br>2.为经常需要排序、分组和联合操作的字段建立索引：<br>3．为常作为查询条件的字段建立索引。<br>4．限制索引的数目：<br>越多的索引，会使更新表变得很浪费时间。<br>尽量使用数据量少的索引<br>6．如果索引的值很长，那么查询的速度会受到影响。<br>尽量使用前缀来索引<br>7．如果索引字段的值很长，最好使用值的前缀来索引。<br>7．删除不再使用或者很少使用的索引<br>8 . 最左前缀匹配原则，非常重要的原则。<br>10 . 尽量选择区分度高的列作为索引<br>区分度的公式是表示字段不重复的比例<br>11 .索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。<br>12 .尽量的扩展索引，不要新建索引。<br>19.1.3. 数据库三范式<br>范式是具有最小冗余的表结构。3 范式具体如下：<br>19.1.3.1. 第一范式(1st NF －列都是不可再分)<br>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子<br>单元），则满足第一范式（1NF）<br>19.1.3.2. 第二范式(2nd NF－每个表只描述一件事情)<br>13&#x2F;04&#x2F;2018 Page 217 of 283<br>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一<br>件事情。<br>19.1.3.3. 第三范式(3rd NF－ 不存在对非主键列的传递依赖)<br>第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编<br>号外，顾客姓名依赖于非主键顾客编号。<br>19.1.4. 数据库是事务<br>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向<br>系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元<br>事务必须具备以下四个属性，简称 ACID 属性：<br>原子性（Atomicity）<br>148.事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执<br>行。<br>一致性（Consistency）<br>149.当事务完成时，数据必须处于一致状态。<br>13&#x2F;04&#x2F;2018 Page 218 of 283<br>隔离性（Isolation）<br>150.对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方<br>式依赖于或影响其他事务。<br>永久性（Durability）<br>151.事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。<br>19.1.5. 存储过程(特定功能的 SQL 语句集)<br>一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次<br>编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过<br>程是数据库中的一个重要对象。<br>存储过程优化思路：<br>152.尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。<br>153.中间结果存放于临时表，加索引。<br>154.少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如<br>对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次<br>读取。<br>155.事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成<br>并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。<br>156.使用 try-catch 处理错误异常。<br>157.查找语句尽量不要放在循环内。<br>19.1.6. 触发器(一段能自动执行的程序)<br>触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：<br>触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统<br>会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和<br>DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、<br>alter、drop 语句。<br>19.1.7. 数据库并发策略<br>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。<br>19.1.7.1. 乐观锁<br>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自<br>己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间<br>戳就是不加锁，通过时间戳来控制并发出现的问题。<br>13&#x2F;04&#x2F;2018 Page 219 of 283<br>19.1.7.2. 悲观锁<br>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加<br>锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数<br>据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允<br>许其他用户访问那部分数据。<br>19.1.7.3. 时间戳<br>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字<br>段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数<br>据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁<br>机制，但是这种方法可以大大提高数据库处理的并发量，<br>以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。<br>19.1.11. 两阶段提交协议<br>分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独<br>立，通过网络进行沟通和协调。<br>13&#x2F;04&#x2F;2018 Page 221 of 283<br>XA 就是 X&#x2F;Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件<br>用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。<br>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统<br>架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提<br>交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功<br>或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事<br>务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并<br>最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，<br>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者<br>的反馈情报决定各参与者是否要提交操作还是中止操作。<br>19.1.11.1. 准备阶段<br>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回<br>失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一<br>种“万事俱备，只欠东风”的状态。<br>19.1.11.2. 提交阶段<br>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，<br>发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过<br>程中使用的锁资源。(注意:必须在最后阶段释放锁资源)<br>19.1.11.3. 缺点<br>同步阻塞问题<br>1、执行过程中，所有参与节点都是事务阻塞型的。<br>单点故障<br>2、由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。<br>数据不一致（脑裂问题）<br>3、在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异<br>常或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了<br>commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。<br>二阶段无法解决的问题（数据状态不确定）<br>4、协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那<br>么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道<br>事务是否被已经提交。<br>13&#x2F;04&#x2F;2018 Page 222 of 283<br>19.1.12. 三阶段提交协议<br>三阶段提交（ Three-phase commit ） ， 也 叫 三 阶 段 提 交 协 议 （ Three-phase commit<br>protocol），是二阶段提交（2PC）的改进版本。<br>与两阶段提交不同的是，三阶段提交有两个改动点。<br>1、引入超时机制。同时在协调者和参与者中都引入超时机制。<br>2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是<br>一致的。也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段<br>提交就有 CanCommit、PreCommit、DoCommit 三个阶段。<br>19.1.12.1. CanCommit 阶段<br>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。<br>19.1.12.2. PreCommit 阶段<br>协调者根据参与者的反应情况来决定是否可以继续进行，有以下两种可能。假如协调者从所有的<br>参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行假如有任何一个参与者向协调者发送<br>了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。<br>19.1.12.3. doCommit 阶段<br>该阶段进行真正的事务提交，主要包含 1.协调这发送提交请求 2.参与者提交事务 3.参与者响应反<br>馈（ 事务提交完之后，向协调者发送 Ack 响应。）4.协调者确定完成事务。<br>19.1.13. 柔性事务<br>19.1.13.1. 柔性事务<br>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式<br>领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分<br>区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基<br>础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性<br>（Eventual Consistency）。<br>通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。<br>两阶段型<br>1、就是分布式事务两阶段提交，对应技术上的 XA、JTA&#x2F;JTS。这是分布式环境下事务处理的<br>典型模式。<br>补偿型<br>2、TCC 型事务（Try&#x2F;Confirm&#x2F;Cancel）可以归为补偿型。<br>13&#x2F;04&#x2F;2018 Page 223 of 283<br>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，<br>服务器 B 参与事务，服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行<br>顺利，则事务 B 也提交，整个事务就算完成。但是如果事务 B 执行失败，事务 B 本身回滚，这时<br>事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢<br>复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是<br>提高了 long-running 事务的可用性。<br>异步确保型<br>3、通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步<br>阻塞操作的影响。<br>最大努力通知型（多次尝试）<br>4、这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不<br>同的一点是, 在消息由 MQ Server 投递到消费者之后, 允许在达到最大重试次数之后正常<br>结束事务。<br>13&#x2F;04&#x2F;2018 Page 224 of 283<br>19.1.14. CAP<br>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability<br>（可用性）、Partition tolerance（分区容错性），三者不可得兼。<br>一致性（C）：<br>164.在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份<br>最新的数据副本）<br>可用性（A）：<br>165.在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备<br>高可用性）<br>分区容忍性（P）：<br>166.以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，<br>就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。<br>13&#x2F;04&#x2F;2018 Page 225 of 283<br>167.一致性算法<br>20.1.1. Paxos<br>Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，<br>在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么<br>他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执<br>行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的<br>一个实现。 在 Paxos 算法中，有三种角色：Proposer，Acceptor，Learners<br>Paxos 三种角色：Proposer，Acceptor，Learners<br>Proposer：<br>只要 Proposer 发的提案被半数以上 Acceptor 接受，Proposer 就认为该提案里的 value 被选定<br>了。<br>Acceptor：<br>只要 Acceptor 接受了某个提案，Acceptor 就认为该提案里的 value 被选定了。<br>Learner：<br>Acceptor 告诉 Learner 哪个 value 被选定，Learner 就认为那个 value 被选定。<br>Paxos 算法分为两个阶段。具体如下：<br>阶段一（准 leader 确定 ）：<br>(a) Proposer 选择一个提案编号 N，然后向半数以上的 Acceptor 发送编号为 N 的 Prepare 请求。<br>(b) 如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的<br>所有 Prepare 请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响<br>应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。<br>阶段二（leader 确认）：<br>(a) 如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它<br>就会发送一个针对[N,V]提案的 Accept 请求给半数以上的 Acceptor。注意：V 就是收到的响应中<br>编号最大的提案的 value，如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定。<br>(b) 如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号<br>大于 N 的 Prepare 请求做出过响应，它就接受该提案。<br>20.1.2. ZabZAB( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议）协议包括两种基本的模<br>式：崩溃恢复和消息广播<br>13&#x2F;04&#x2F;2018 Page 226 of 2831. 当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断崩溃退出与重启等异常情<br>况时，ZAB 就会进入恢复模式并选举产生新的 Leader 服务器。<br>2. 当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了<br>状态同步之后，ZAB 协议就会退出崩溃恢复模式，进入消息广播模式。<br>3. 当有新的服务器加入到集群中去，如果此时集群中已经存在一个 Leader 服务器在负责进行消<br>息广播，那么新加入的服务器会自动进入数据恢复模式，找到 Leader 服务器，并与其进行数<br>据同步，然后一起参与到消息广播流程中去。<br>以上其实大致经历了三个步骤：<br>1.崩溃恢复：主要就是 Leader 选举过程<br>2.数据同步：Leader 服务器与其他服务器进行数据同步<br>3.消息广播：Leader 服务器将数据发送给其他服务器<br>说明：zookeeper 章节对该协议有详细描述。<br>20.1.3. Raft<br>与 Paxos 不同 Raft 强调的是易懂（Understandability），Raft 和 Paxos 一样只要保证 n&#x2F;2+1 节<br>点正常就能够提供服务；raft 把算法流程分为三个子问题：选举（Leader election）、日志复制<br>（Log replication）、安全性（Safety）三个子问题。<br>20.1.3.1. 角色<br>Raft 把集群中的节点分为三种状态：Leader、 Follower 、Candidate，理所当然每种状态负<br>责的任务也是不一样的，Raft 运行时提供服务的时候只存在 Leader 与 Follower 两种状态；<br>Leader（领导者-日志管理）<br>负责日志的同步管理，处理来自客户端的请求，与 Follower 保持这 heartBeat 的联系；<br>Follower（追随者-日志同步）<br>刚启动时所有节点为Follower状态，响应Leader的日志同步请求，响应Candidate的请求，<br>把请求到 Follower 的事务转发给 Leader；<br>Candidate（候选者-负责选票）<br>负责选举投票，Raft 刚启动时由一个节点从 Follower 转为 Candidate 发起选举，选举出<br>Leader 后从 Candidate 转为 Leader 状态；<br>20.1.3.2. Term（任期）<br>在 Raft 中使用了一个可以理解为周期（第几届、任期）的概念，用 Term 作为一个周期，每<br>个 Term 都是一个连续递增的编号，每一轮选举都是一个 Term 周期，在一个 Term 中只能产生一<br>个 Leader；当某节点收到的请求中 Term 比当前 Term 小时则拒绝该请求。<br>13&#x2F;04&#x2F;2018 Page 227 of 283<br>20.1.3.3. 选举（Election）<br>选举定时器<br>Raft 的选举由定时器来触发，每个节点的选举定时器时间都是不一样的，开始时状态都为<br>Follower 某个节点定时器触发选举后 Term 递增，状态由 Follower 转为 Candidate，向其他节点<br>发起 RequestVote RPC 请求，这时候有三种可能的情况发生：<br>1：该 RequestVote 请求接收到 n&#x2F;2+1（过半数）个节点的投票，从 Candidate 转为 Leader，<br>向其他节点发送 heartBeat 以保持 Leader 的正常运转。<br>2：在此期间如果收到其他节点发送过来的 AppendEntries RPC 请求，如该节点的 Term 大<br>则当前节点转为 Follower，否则保持 Candidate 拒绝该请求。<br>3：Election timeout 发生则 Term 递增，重新发起选举<br>在一个 Term 期间每个节点只能投票一次，所以当有多个 Candidate 存在时就会出现每个<br>Candidate 发起的选举都存在接收到的投票数都不过半的问题，这时每个 Candidate 都将 Term<br>递增、重启定时器并重新发起选举，由于每个节点中定时器的时间都是随机的，所以就不会多次<br>存在有多个 Candidate 同时发起投票的问题。<br>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过<br>heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送<br>ACK，当 Leader 收到大多数（n&#x2F;2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到<br>本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在<br>自己的本地磁盘中。<br>20.1.3.4. 安全性（Safety）<br>安全性是用于保证每个节点都执行相同序列的安全机制如当某个 Follower 在当前 Leader commit<br>Log 时变得不可用了，稍后可能该 Follower 又会倍选举为 Leader，这时新 Leader 可能会用新的<br>Log 覆盖先前已 committed 的 Log，这就是导致节点执行不同序列；Safety 就是用于保证选举出<br>来的 Leader 一定包含先前 commited Log 的机制；<br>选举安全性（Election Safety）：每个 Term 只能选举出一个 Leader<br>Leader 完整性（Leader Completeness）：这里所说的完整性是指 Leader 日志的完整性，<br>Raft 在选举阶段就使用 Term 的判断用于保证完整性：当请求投票的该 Candidate 的 Term 较大<br>或 Term 相同 Index 更大则投票，该节点将容易变成 leader。<br>20.1.3.5. raft 协议和 zab 协议区别<br>相同点<br> 采用 quorum 来确定整个系统的一致性,这个 quorum 一般实现是集群中半数以上的服务器,<br> zookeeper 里还提供了带权重的 quorum 实现.<br> 都由 leader 来发起写操作.<br> 都采用心跳检测存活性<br>13&#x2F;04&#x2F;2018 Page 228 of 283<br> leader election 都采用先到先得的投票方式<br>不同点<br> zab 用的是 epoch 和 count 的组合来唯一表示一个值, 而 raft 用的是 term 和 index<br> zab 的 follower 在投票给一个 leader 之前必须和 leader 的日志达成一致,而 raft 的 follower<br>则简单地说是谁的 term 高就投票给谁<br> raft 协议的心跳是从 leader 到 follower, 而 zab 协议则相反<br> raft 协议数据只有单向地从 leader 到 follower(成为 leader 的条件之一就是拥有最新的 log),<br>而 zab 协议在 discovery 阶段, 一个 prospective leader 需要将自己的 log 更新为 quorum 里面<br>最新的 log,然后才好在 synchronization 阶段将 quorum 里的其他机器的 log 都同步到一致.<br>20.1.4. NWR<br>N：在分布式存储系统中，有多少份备份数据<br>W：代表一次成功的更新操作要求至少有 w 份数据写入成功<br>R： 代表一次成功的读数据操作要求至少有 R 份数据成功读取<br>NWR值的不同组合会产生不同的一致性效果，当W+R&gt;N 的时候，整个系统对于客户端来讲能保<br>证强一致性。而如果 R+W&lt;&#x3D;N，则无法保证数据的强一致性。以常见的 N&#x3D;3、W&#x3D;2、R&#x3D;2 为例：<br>N&#x3D;3，表示，任何一个对象都必须有三个副本（Replica），W&#x3D;2 表示，对数据的修改操作<br>（Write）只需要在 3 个 Replica 中的 2 个上面完成就返回，R&#x3D;2 表示，从三个对象中要读取到 2<br>个数据对象，才能返回。<br>20.1.5. Gossip<br>Gossip 算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，代表杂乱无章，而反熵<br>就是在杂乱无章中寻求一致，这充分说明了 Gossip 的特点：在一个有界网络中，每个节点都随机<br>13&#x2F;04&#x2F;2018 Page 229 of 283<br>地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可<br>能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的<br>状态都是一致的，当然这也是疫情传播的特点。<br>20.1.6. 一致性 Hash<br>一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。<br>Memcached client 也选择这种算法，解决将 key-value 均匀分配到众多 Memcached server 上<br>的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删 Memcached Server 的问题<br>(增删 server 会导致同一个 key,在 get 操作时分配不到数据真正存储的 server，命中率会急剧下<br>降)。<br>20.1.6.1. 一致性 Hash 特性<br> 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得<br>所有的缓冲空间都得到利用。<br> 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，<br>又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓<br>冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。容易看到，上面的简单求余算法<br>hash(object)%N 难以满足单调性要求。<br> 平滑性(Smoothness)：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致<br>的。<br>20.1.6.2. 一致性 Hash 原理<br>1.建构环形 hash 空间：<br>4. 考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的<br>数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环。<br>2.把需要缓存的内容(对象)映射到 hash 空间<br>5. 接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分<br>布<br>3.把服务器(节点)映射到 hash 空间<br>6. Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并<br>且使用相同的 hash 算法。一般的方法可以使用 服务器(节点) 机器的 IP 地址或者机器名作为<br>hash 输入。<br>4.把对象映射到服务节点<br>7. 现在服务节点和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，首先确定对象<br>hash 值在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位<br>到的服务器。<br>13&#x2F;04&#x2F;2018 Page 230 of 283<br>考察 cache 的变动<br>8. 通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时，<br>cache 会失效。<br>5.1 移除 cache：考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是<br>那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象。<br>5.2 添加 cache：再考虑添加一台新的 cache D 的情况，这时受影响的将仅是那些沿 cache<br>D 逆时针遍历直到下一个 cache 之间的对象，将这些对象重新映射到 cache D 上即可。<br>虚拟节点<br>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，<br>为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：<br>虚拟节点（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了<br>若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash<br>值排列。<br>仍以仅部署 cache A 和 cache C 的情况为例。现在我们引入虚拟节点，并设置“复制个数”为 2 ，<br>这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A； cache C1,<br>cache C2 代表了 cache C 。此时，对象到“虚拟节点”的映射关系为：<br>objec1-&gt;cache A2 ； objec2-&gt;cache A1 ； objec3-&gt;cache C1 ； objec4-&gt;cache C2 ；<br>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache<br>C 上；平衡性有了很大提高。<br>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所<br>在 cache 时的映射关系如下图 所示。<br>13&#x2F;04&#x2F;2018 Page 231 of 283<br>13&#x2F;04&#x2F;2018 Page 232 of 283<br>21.1.1. 二分查找<br>又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置<br>的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，<br>则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p><p>21.1.2. 冒泡排序算法<br>（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。<br>（2）这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就“沉”到数组第<br>N-1 个位置。<br>（3）N&#x3D;N-1，如果 N 不为 0 就重复前面二步，否则排序完成。</p><p>21.1.3. 插入排序算法<br>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。<br>插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从<br>桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将<br>它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。<br>如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函<br>数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。<br>21.1.4. 快速排序算法<br>快速排序的原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），<br>比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。<br>一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有<br>继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比<br>较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的<br>值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值<br>来说，左右两边就是有序的了。<br>21.1.1. 希尔排序算法<br>基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列<br>中的记录“基本有序”时，再对全体记录进行依次直接插入排序。1. 操作方法：<br>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk&#x3D;1；<br>2. 按增量序列个数 k，对序列进行 k 趟排序；<br>3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进<br>行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长<br>度。<br>21.1.2. 归并排序算法<br>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列<br>分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br>21.1.3. 桶排序算法<br>桶排序的基本思想是： 把数组 arr 划分为 n 个大小相同子区间（桶），每个子区间各自排序，最<br>后合并 。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。<br>1.找出待排序数组中的最大值 max、最小值 min<br>2.我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max￾min)&#x2F;arr.length+1<br>3.遍历数组 arr，计算每个元素 arr[i] 放的桶<br>4.每个桶各自排序<br>21.1.4. 基数排序算法<br>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位<br>开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序<br>列。<br>21.1.5. 剪枝算法<br>在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是<br>剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即<br>确定哪些枝条应当舍弃，哪些枝条应当保留的方法。<br>21.1.6. 回溯算法<br>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现<br>已不满足求解条件时，就“回溯”返回，尝试别的路径。<br>21.1.7. 最短路径算法<br>从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最<br>短路径。解决最短路的问题有以下算法，Dijkstra 算法，Bellman-Ford 算法，Floyd 算法和 SPFA<br>算法等。<br>21.1.8. 最大子数组算法<br>21.1.9. 最长公共子序算法<br>21.1.10. 最小生成树算法<br>现在假设有一个很实际的问题：我们要在 n 个城市中建立一个通信网络，则连通这 n 个城市需要<br>布置 n-1 一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？<br>于是我们就可以引入连通图来解决我们遇到的问题，n 个城市就是图上的 n 个顶点，然后，边表示<br>两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有 n 个<br>顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连<br>通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。<br>13&#x2F;04&#x2F;2018 Page 244 of 283<br>构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST 性质（假设<br>N&#x3D;(V,{E})是一个连通网，U 是顶点集 V 的一个非空子集，如果（u，v）是一条具有最小权值的边，<br>其中 u 属于 U，v 属于 V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使<br>用 MST 性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。<br>13&#x2F;04&#x2F;2018 Page 245 of 2831. 数据结构<br>22.1.1. 栈（stack）<br>栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶<br>（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，<br>前者相当于插入，后者相当于删除最后的元素。<br>22.1.2. 队列（queue）<br>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的<br>后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为<br>队尾，进行删除操作的端称为队头。<br>22.1.3. 链表（Link）<br>链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而<br>LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。<br>13&#x2F;04&#x2F;2018 Page 246 of 283<br>22.1.4. 散列表（Hash Table）<br>散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法<br>在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据<br>元素）的比较操作。<br>散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素，因而必<br>须要在数据元素的存储位置和它的关键字（可用 key 表示）之间建立一个确定的对应关系，使每个<br>关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定<br>关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用 h(key)表示)。<br>用的构造散列函数的方法有：<br>（1）直接定址法： 取关键字或关键字的某个线性函数值为散列地址。<br>即：h(key) &#x3D; key 或 h(key) &#x3D; a * key + b，其中 a 和 b 为常数。<br>（2）数字分析法<br>（3）平方取值法： 取关键字平方后的中间几位为散列地址。<br>（4）折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。<br>（5）除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，<br>即：h(key) &#x3D; key MOD p p ≤ m<br>（6）随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址，<br>即：h(key) &#x3D; random(key)<br>22.1.5. 排序二叉树<br>首先如果普通二叉树每个节点满足：左子树所有节点值小于它的根节点值，且右子树所有节点值<br>大于它的根节点值，则这样的二叉树就是排序二叉树。<br>22.1.5.1. 插入操作<br>首先要从根节点开始往下找到自己要插入的位置（即新节点的父节点）；具体流程是：新节点与<br>当前节点比较，如果相同则表示已经存在且不能再重复插入；如果小于当前节点，则到左子树中<br>13&#x2F;04&#x2F;2018 Page 247 of 283<br>寻找，如果左子树为空则当前节点为要找的父节点，新节点插入到当前节点的左子树即可；如果<br>大于当前节点，则到右子树中寻找，如果右子树为空则当前节点为要找的父节点，新节点插入到<br>当前节点的右子树即可。<br>22.1.5.2. 删除操作<br>删除操作主要分为三种情况，即要删除的节点无子节点，要删除的节点只有一个子节点，要删除<br>的节点有两个子节点。<br>2. 对于要删除的节点无子节点可以直接删除，即让其父节点将该子节点置空即可。<br>3. 对于要删除的节点只有一个子节点，则替换要删除的节点为其子节点。<br>4. 对于要删除的节点有两个子节点，则首先找该节点的替换节点（即右子树中最小的节点），<br>接着替换要删除的节点为替换节点，然后删除替换节点。<br>13&#x2F;04&#x2F;2018 Page 248 of 283<br>22.1.5.3. 查询操作<br>查找操作的主要流程为：先和根节点比较，如果相同就返回，如果小于根节点则到左子树中<br>递归查找，如果大于根节点则到右子树中递归查找。因此在排序二叉树中可以很容易获取最<br>大（最右最深子节点）和最小（最左最深子节点）值。<br>22.1.6. 红黑树<br>R-B Tree，全称是 Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每<br>个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。<br>22.1.6.1. 红黑树的特性<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL 或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<br>22.1.6.1. 左旋<br>对 x 进行左旋，意味着，将“x 的右孩子”设为“x 的父亲节点”；即，将 x 变成了一个左节点(x<br>成了为 z 的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。<br>13&#x2F;04&#x2F;2018 Page 249 of 283<br>LEFT-ROTATE(T, x)<br>y ← right[x] &#x2F;&#x2F; 前提：这里假设 x 的右孩子为 y。下面开始正式操作<br>right[x] ← left[y] &#x2F;&#x2F; 将 “y 的左孩子” 设为 “x 的右孩子”，即 将β设为 x 的右孩子<br>p[left[y]] ← x &#x2F;&#x2F; 将 “x” 设为 “y 的左孩子的父亲”，即 将β的父亲设为 x<br>p[y] ← p[x] &#x2F;&#x2F; 将 “x 的父亲” 设为 “y 的父亲”<br>if p[x] &#x3D; nil[T]<br>then root[T] ← y &#x2F;&#x2F; 情况 1：如果 “x 的父亲” 是空节点，则将 y 设为根节点<br>else if x &#x3D; left[p[x]]<br>then left[p[x]] ← y &#x2F;&#x2F; 情况 2：如果 x 是它父节点的左孩子，则将 y 设为“x 的父节点<br>的左孩子”<br>else right[p[x]] ← y &#x2F;&#x2F; 情况 3：(x 是它父节点的右孩子) 将 y 设为“x 的父节点的右孩<br>子”<br>left[y] ← x &#x2F;&#x2F; 将 “x” 设为 “y 的左孩子”<br>p[x] ← y &#x2F;&#x2F; 将 “x 的父节点” 设为 “y”<br>22.1.6.1. 右旋<br>对 x 进行右旋，意味着，将“x 的左孩子”设为“x 的父亲节点”；即，将 x 变成了一个右节点(x<br>成了为 y 的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。<br>13&#x2F;04&#x2F;2018 Page 250 of 283<br>RIGHT-ROTATE(T, y)<br>x ← left[y] &#x2F;&#x2F; 前提：这里假设 y 的左孩子为 x。下面开始正式操作<br>left[y] ← right[x] &#x2F;&#x2F; 将 “x 的右孩子” 设为 “y 的左孩子”，即 将β设为 y 的左孩子<br>p[right[x]] ← y &#x2F;&#x2F; 将 “y” 设为 “x 的右孩子的父亲”，即 将β的父亲设为 y<br>p[x] ← p[y] &#x2F;&#x2F; 将 “y 的父亲” 设为 “x 的父亲”<br>if p[y] &#x3D; nil[T]<br>then root[T] ← x &#x2F;&#x2F; 情况 1：如果 “y 的父亲” 是空节点，则将 x 设为根节点<br>else if y &#x3D; right[p[y]]<br>then right[p[y]] ← x &#x2F;&#x2F; 情况 2：如果 y 是它父节点的右孩子，则将 x 设为“y 的父节<br>点的左孩子”<br>else left[p[y]] ← x &#x2F;&#x2F; 情况 3：(y 是它父节点的左孩子) 将 x 设为“y 的父节点的左孩<br>子”<br>right[x] ← y &#x2F;&#x2F; 将 “y” 设为 “x 的右孩子”<br>p[y] ← x &#x2F;&#x2F; 将 “y 的父节点” 设为 “x”<br>22.1.6.1. 添加<br>第一步: 将红黑树当作一颗二叉查找树，将节点插入。<br>第二步：将插入的节点着色为”红色”。<br>根据被插入节点的父节点的情况，可以将”当节点 z 被着色为红色节点，并插入二叉树”划分为三<br>种情况来处理。<br>① 情况说明：被插入的节点是根节点。<br>处理方法：直接把此节点涂为黑色。<br>② 情况说明：被插入的节点的父节点是黑色。<br>处理方法：什么也不需要做。节点被插入后，仍然是红黑树。<br>13&#x2F;04&#x2F;2018 Page 251 of 283<br>③ 情况说明：被插入的节点的父节点是红色。这种情况下，被插入节点是一定存在非空祖父节点<br>的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节<br>点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为 3<br>种情况(Case)。<br>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。<br>22.1.6.2. 删除<br>第一步：将红黑树当作一颗二叉查找树，将节点删除。<br>这和”删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况：<br>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就 OK 了。<br>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给<br>“该节点的内容”；之后，删除“它的后继节点”。<br>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。<br>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正<br>该树，使之重新成为一棵红黑树。<br>选择重着色 3 种情况。<br>① 情况说明：x 是“红+黑”节点。<br>处理方法：直接把 x 设为黑色，结束。此时红黑树性质全部恢复。<br>② 情况说明：x 是“黑+黑”节点，且 x 是根。<br>处理方法：什么都不做，结束。此时红黑树性质全部恢复。<br>③ 情况说明：x 是“黑+黑”节点，且 x 不是根。<br>处理方法：这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示：<br>13&#x2F;04&#x2F;2018 Page 252 of 283<br>参考：<br>代码实现：<br>22.1.7. B-TREE<br>B-tree 又叫平衡多路查找树。一棵 m 阶的 B-tree (m 叉树)的特性如下（其中 ceil(x)是一个取上限<br>的函数）：<br>5. 树中每个结点至多有 m 个孩子；<br>6. 除根结点和叶子结点外，其它每个结点至少有有 ceil(m &#x2F; 2)个孩子；<br>7. 若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子<br>结点，整棵树只有一个根节点）；<br>8. 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询<br>失败的结点，实际上这些结点不存在，指向这些结点的指针都为 null)；<br>9. 每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其<br>中：<br>a) Ki (i&#x3D;1…n)为关键字，且关键字按顺序排序 K(i-1)&lt; Ki。<br>b) Pi 为指向子树根的接点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-<br>1)。<br>c) 关键字的个数 n 必须满足： ceil(m &#x2F; 2)-1 &lt;&#x3D; n &lt;&#x3D; m-1。<br>13&#x2F;04&#x2F;2018 Page 253 of 283<br>一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于：<br>1.有 n 棵子树的结点中含有 n 个关键字； (B-tree 是 n 棵子树有 n-1 个关键字)<br>2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本<br>身依关键字的大小自小而大的顺序链接。 (B-tree 的叶子节点并没有包括全部需要查找的信息)<br>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。<br>(B-tree 的非终节点也包含需要查找的有效信息)<br>参考：<br>13&#x2F;04&#x2F;2018 Page 254 of 283<br>22.1.8. 位图<br>位图的原理就是用一个 bit 来标识一个数字是否存在，采用一个 bit 来存储一个数据，所以这样可<br>以大大的节省空间。 bitmap 是很常用的数据结构，比如用于 Bloom Filter 中；用于无重复整数的<br>排序等等。bitmap 通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素<br>组成更大的二进制集合。<br>13&#x2F;04&#x2F;2018 Page 255 of 283<br>10. 加密算法<br>23.1.1. AES<br>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传<br>输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下<br>图：<br>23.1.2. RSA<br>RSA 加密算法是一种典型的非对称加密算法，它基于大数的因式分解数学难题，它也是应用最广<br>泛的非对称加密算法。<br>非对称加密是通过两个密钥（公钥-私钥）来实现对数据的加密和解密的。公钥用于加密，私钥用<br>于解密。<br>13&#x2F;04&#x2F;2018 Page 256 of 283<br>23.1.3. CRC<br>循环冗余校验(Cyclic Redundancy Check, CRC)是一种根据网络数据包或电脑文件等数据产生简<br>短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。<br>它是利用除法及余数的原理来作错误侦测的。<br>23.1.4. MD5<br>MD5 常常作为文件的签名出现，我们在下载文件的时候，常常会看到文件页面上附带一个扩展<br>名为.MD5 的文本或者一行字符，这行字符就是就是把整个文件当作原数据通过 MD5 计算后的值，<br>我们下载文件后，可以用检查文件 MD5 信息的软件对下载到的文件在进行一次计算。两次结果对<br>比就可以确保下载到文件的准确性。 另一种常见用途就是网站敏感信息加密，比如用户名密码，<br>支付签名等等。随着 https 技术的普及，现在的网站广泛采用前台明文传输到后台，MD5 加密<br>（使用偏移量）的方式保护敏感数据保护站点和数据安全。<br>13&#x2F;04&#x2F;2018 Page 257 of 283<br>11. 分布式缓存<br>24.1.1. 缓存雪崩<br>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都<br>去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列<br>连锁反应，造成整个系统崩溃。一般有三种处理办法：<br>12. 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。<br>13. 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓<br>存。<br>14. 为 key 设置不同的缓存失效时间。<br>24.1.2. 缓存穿透<br>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在<br>缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请<br>求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈<br>希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存<br>储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不<br>存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br>通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。<br>24.1.3. 缓存预热<br>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，<br>先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>24.1.4. 缓存更新<br>缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以<br>根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>（1）定时去清理过期的缓存；<br>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数<br>据并更新缓存。<br>24.1.5. 缓存降级<br>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然<br>需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开<br>关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的<br>（如加入购物车、结算）。<br>13&#x2F;04&#x2F;2018 Page 258 of 283<br>13&#x2F;04&#x2F;2018 Page 259 of 283<br>15. Hadoop<br>25.1.1. 概念<br>就是一个大数据解决方案。它提供了一套分布式系统基础架构。 核心内容包含 hdfs 和<br>mapreduce。hadoop2.0 以后引入 yarn.<br>hdfs 是提供数据存储的，mapreduce 是方便数据计算的。<br>16. hdfs 又对应 namenode 和 datanode. namenode 负责保存元数据的基本信息，<br>datanode 直接存放数据本身；<br>17. mapreduce 对应 jobtracker 和 tasktracker. jobtracker 负责分发任务，tasktracker 负<br>责执行具体任务；<br>18. 对应到 master&#x2F;slave 架构，namenode 和 jobtracker 就应该对应到 master, datanode<br>和 tasktracker 就应该对应到 slave.<br>25.1.2. HDFS<br>25.1.2.1. Client<br>Client（代表用 户） 通过与 NameNode 和 DataNode 交互访问 HDFS 中 的文件。 Client 提供<br>了一个类似 POSIX 的文件系统接口供用户调用。<br>25.1.2.2. NameNode<br>整个 Hadoop 集群中只有一个 NameNode。 它是整个系统的“ 总管”， 负责管理 HDFS 的目<br>录树和相关的文件元数据信息。 这些信息是以“ fsimage”（ HDFS 元数据镜像文件）和<br>“ editlog”（HDFS 文件改动日志）两个文件形式存放在本地磁盘，当 HDFS 重启时重新构造出<br>来的。此外， NameNode 还负责监控各个 DataNode 的健康状态， 一旦发现某个 DataNode 宕<br>掉，则将该 DataNode 移出 HDFS 并重新备份其上面的数据。<br>25.1.2.3. Secondary NameNode<br>Secondary NameNode 最重要的任务并不是为 NameNode 元数据进行热备份， 而是定期合并<br>fsimage 和 edits 日志， 并传输给 NameNode。 这里需要注意的是，为了减小 NameNode 压<br>力， NameNode 自己并不会合并 fsimage 和 edits， 并将文件存储到磁盘上， 而是交由<br>Secondary NameNode 完成。<br>25.1.2.4. DataNode<br>一般而言， 每个 Slave 节点上安装一个 DataNode， 它负责实际的数据存储， 并将数据信息定期<br>汇报给 NameNode。 DataNode 以固定大小的 block 为基本单位组织文件内容， 默认情况下<br>block 大小为 64MB。 当用户上传一个大的文件到 HDFS 上时， 该文件会被切分成若干个 block，<br>分别存储到不同的 DataNode ； 同时，为了保证数据可靠， 会将同一个 block 以流水线方式写到<br>13&#x2F;04&#x2F;2018 Page 260 of 283<br>若干个（默认是 3，该参数可配置）不同的 DataNode 上。 这种文件切割后存储的过程是对用户<br>透明的。<br>25.1.3. MapReduce<br>同 HDFS 一样，Hadoop MapReduce 也采用了 Master&#x2F;Slave（M&#x2F;S）架构，具体如图所示。它<br>主要由以下几个组件组成：Client、JobTracker、TaskTracker 和 Task。 下面分别对这几个组件<br>进行介绍。<br>25.1.3.1. Client<br>用户编写的 MapReduce 程序通过 Client 提交到 JobTracker 端； 同时， 用户可通过 Client 提<br>供的一些接口查看作业运行状态。 在 Hadoop 内部用“作业”（Job） 表示 MapReduce 程序。<br>一个 MapReduce 程序可对应若干个作业，而每个作业会被分解成若干个 Map&#x2F;Reduce 任务<br>（Task）。<br>25.1.3.2. JobTracker<br>JobTracker 主要负责资源监控和作业调度。JobTracker 监控所有 TaskTracker 与作业的健康状况，<br>一旦发现失败情况后，其会将相应的任务转移到其他节点；同时 JobTracker 会跟踪任务的执行进<br>度、资源使用量等信息，并将这些信息告诉任务调度器，而调度器会在资源出现空闲时，选择合<br>适的任务使用这些资源。在 Hadoop 中，任务调度器是一个可插拔的模块，用户可以根据自己的<br>需要设计相应的调度器。<br>13&#x2F;04&#x2F;2018 Page 261 of 283<br>25.1.3.3. TaskTracker<br>TaskTracker 会周期性地通过 Heartbeat 将本节点上资源的使用情况和任务的运行进度汇报给<br>JobTracker， 同时接收 JobTracker 发送过来的命令并执行相应的操作（如启动新任务、 杀死任<br>务等）。TaskTracker 使用“slot” 等量划分本节点上的资源量。“slot” 代表计算资源（CPU、<br>内存等）。一个 Task 获取到一个 slot 后才有机会运行，而 Hadoop 调度器的作用就是将各个<br>TaskTracker 上的空闲 slot 分配给 Task 使用。 slot 分为 Map slot 和 Reduce slot 两种，分别供<br>MapTask 和 Reduce Task 使用。 TaskTracker 通过 slot 数目（可配置参数）限定 Task 的并发<br>度。<br>25.1.3.4. Task<br>Task 分为 Map Task 和 Reduce Task 两种， 均由 TaskTracker 启动。 HDFS 以固定大小的 block<br>为基本单位存储数据， 而对于 MapReduce 而言， 其处理单位是 split。split 与 block 的对应关<br>系如图所示。 split 是一个逻辑概念， 它只包含一些元数据信息， 比如数据起始位置、数据长度、<br>数据所在节点等。它的划分方法完全由用户自己决定。 但需要注意的是，split 的多少决定了 Map<br>Task 的数目 ，因为每个 split 会交由一个 Map Task 处理。<br>Map Task 执行过程如图所示。 由该图可知，Map Task 先将对应的 split 迭代解析成一个个<br>key&#x2F;value 对，依次调用用户自定义的 map() 函数进行处理，最终将临时结果存放到本地磁盘上，<br>其中临时数据被分成若干个 partition，每个 partition 将被一个 Reduce Task 处理。<br>25.1.3.5. Reduce Task 执行过程<br>该过程分为三个阶段<br>19. 从远程节点上读取 MapTask 中间结果（称为“Shuffle 阶段”）；<br>20. 按照 key 对 key&#x2F;value 对进行排序（称为“ Sort 阶段”）；<br>21. 依次读取&lt;key, value list&gt;，调用用户自定义的 reduce() 函数处理，并将最终结果存到 HDFS<br>上（称为“ Reduce 阶段”）。<br>13&#x2F;04&#x2F;2018 Page 262 of 283<br>25.1.4. Hadoop MapReduce 作业的生命周期<br>1.作业提交与初始化<br>22. 用户提交作业后， 首先由 JobClient 实例将作业相关信息， 比如将程序 jar 包、作业配置文<br>件、 分片元信息文件等上传到分布式文件系统（ 一般为 HDFS）上，其中，分片元信息文件<br>记录了每个输入分片的逻辑位置信息。 然后 JobClient 通过 RPC 通知 JobTracker。<br>JobTracker 收到新作业提交请求后， 由 作业调度模块对作业进行初始化：为作业创建一个<br>JobInProgress 对象以跟踪作业运行状况， 而 JobInProgress 则会为每个 Task 创建一个<br>TaskInProgress 对象以跟踪每个任务的运行状态， TaskInProgress 可能需要管理多个<br>“ Task 运行尝试”（ 称为“ Task Attempt”）。<br>2.任务调度与监控。<br>23. 前面提到，任务调度和监控的功能均由 JobTracker 完成。TaskTracker 周期性地通过<br>Heartbeat 向 JobTracker 汇报本节点的资源使用 情况， 一旦出 现空闲资源， JobTracker<br>会按照一定的策略选择一个合适的任务使用该空闲资源， 这由任务调度器完成。 任务调度器<br>是一个可插拔的独立模块， 且为双层架构， 即首先选择作业， 然后从该作业中选择任务， 其<br>中，选择任务时需要重点考虑数据本地性。 此外，JobTracker 跟踪作业的整个运行过程，并<br>为作业的成功运行提供全方位的保障。 首先， 当 TaskTracker 或者 Task 失败时， 转移计算<br>任务 ； 其次， 当某个 Task 执行进度远落后于同一作业的其他 Task 时，为之启动一个相同<br>Task， 并选取计算快的 Task 结果作为最终结果。<br>3.任务运行环境准备<br>24. 运行环境准备包括 JVM 启动和资源隔 离， 均由 TaskTracker 实现。 TaskTracker 为每个<br>Task 启动一个独立的 JVM 以避免不同 Task 在运行过程中相互影响 ； 同时，TaskTracker 使<br>用了操作系统进程实现资源隔离以防止 Task 滥用资源。<br>4.任务执行<br>25. TaskTracker 为 Task 准备好运行环境后， 便会启动 Task。 在运行过程中， 每个 Task 的最<br>新进度首先由 Task 通过 RPC 汇报给 TaskTracker， 再由 TaskTracker 汇报给 JobTracker。<br>5.作业完成。<br>26. 待所有 Task 执行完毕后， 整个作业执行成功。<br>13&#x2F;04&#x2F;2018 Page 263 of 283<br>27. Spark<br>26.1.1. 概念<br>Spark 提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据<br>集和数据源（批量数据或实时的流数据）的大数据处理的需求。<br>26.1.2. 核心架构<br>Spark Core<br>包含 Spark 的基本功能；尤其是定义 RDD 的 API、操作以及这两者上的动作。其他 Spark 的库都<br>是构建在 RDD 和 Spark Core 之上的<br>Spark SQL<br>提供通过 Apache Hive 的 SQL 变体 Hive 查询语言（HiveQL）与 Spark 进行交互的 API。每个<br>数据库表被当做一个 RDD，Spark SQL 查询被转换为 Spark 操作。<br>Spark Streaming<br>对实时数据流进行处理和控制。Spark Streaming 允许程序能够像普通 RDD 一样处理实时数据<br>Mllib<br>一个常用机器学习算法库，算法被实现为对 RDD 的 Spark 操作。这个库包含可扩展的学习算法，<br>比如分类、回归等需要对大量数据集进行迭代的操作。<br>GraphX<br>控制图、并行图操作和计算的一组算法和工具的集合。GraphX 扩展了 RDD API，包含控制图、<br>创建子图、访问路径上所有顶点的操作<br>13&#x2F;04&#x2F;2018 Page 264 of 283<br>26.1.3. 核心组件<br>Cluster Manager-制整个集群，监控 worker<br>在 standalone 模式中即为 Master 主节点，控制整个集群，监控 worker。在 YARN 模式中为资<br>源管理器<br>Worker 节点-负责控制计算节点<br>从节点，负责控制计算节点，启动 Executor 或者 Driver。<br>Driver： 运行 Application 的 main()函数<br>Executor：执行器，是为某个 Application 运行在 worker node 上的一个进程<br>26.1.4. SPARK 编程模型<br>Spark 应用程序从编写到提交、执行、输出的整个过程如图所示，图中描述的步骤如下：<br>13&#x2F;04&#x2F;2018 Page 265 of 283<br>28. 用户使用 SparkContext 提供的 API（常用的有 textFile、sequenceFile、runJob、stop 等）<br>编写 Driver application 程序。此外 SQLContext、HiveContext 及 StreamingContext 对<br>SparkContext 进行封装，并提供了 SQL、Hive 及流式计算相关的 API。<br>29. 使用SparkContext提交的用户应用程序，首先会使用BlockManager和BroadcastManager<br>将任务的 Hadoop 配置进行广播。然后由 DAGScheduler 将任务转换为 RDD 并组织成 DAG，<br>DAG 还将被划分为不同的 Stage。最后由 TaskScheduler 借助 ActorSystem 将任务提交给<br>集群管理器（Cluster Manager）。<br>30. 集群管理器（ClusterManager）给任务分配资源，即将具体任务分配到Worker上，Worker<br>创建 Executor 来处理任务的运行。Standalone、YARN、Mesos、EC2 等都可以作为 Spark<br>的集群管理器。<br>26.1.5. SPARK 计算模型<br>RDD 可以看做是对各种数据计算模型的统一抽象，Spark 的计算过程主要是 RDD 的迭代计算过<br>程。RDD 的迭代计算过程非常类似于管道。分区数量取决于 partition 数量的设定，每个分区的数<br>据只会在一个 Task 中计算。所有分区可以在多个机器节点的 Executor 上并行执行。<br>13&#x2F;04&#x2F;2018 Page 266 of 283<br>26.1.6. SPARK 运行流程<br>13&#x2F;04&#x2F;2018 Page 267 of 283<br>31. 构建 Spark Application 的运行环境，启动 SparkContext<br>32. SparkContext 向资源管理器（可以是 Standalone，Mesos，Yarn）申请运行 Executor 资源，<br>并启动 StandaloneExecutorbackend，<br>33. Executor 向 SparkContext 申请 Task<br>34. SparkContext 将应用程序分发给 Executor<br>35. SparkContext 构建成 DAG 图，将 DAG 图分解成 Stage、将 Taskset 发送给 Task Scheduler，<br>最后由 Task Scheduler 将 Task 发送给 Executor 运行<br>36. Task 在 Executor 上运行，运行完释放所有资源<br>26.1.7. SPARK RDD 流程<br>37. 创建 RDD 对象<br>38. DAGScheduler 模块介入运算，计算 RDD 之间的依赖关系，RDD 之间的依赖关系就形成了<br>DAG<br>39. 每一个 Job 被分为多个 Stage。划分 Stage 的一个主要依据是当前计算因子的输入是否是确<br>定的，如果是则将其分在同一个 Stage，避免多个 Stage 之间的消息传递开销<br>26.1.8. SPARK RDD<br>（1）RDD 的创建方式<br>1）从 Hadoop 文件系统（或与Hadoop兼容的其他持久化存储系统，如Hive、Cassandra、<br>HBase）输入（例如 HDFS）创建。<br>2）从父 RDD 转换得到新 RDD。<br>13&#x2F;04&#x2F;2018 Page 268 of 283<br>3）通过 parallelize 或 makeRDD 将单机数据创建为分布式 RDD。<br>（2）RDD 的两种操作算子（转换（Transformation）与行动（Action））<br>对于 RDD 可以有两种操作算子：转换（Transformation）与行动（Action）。<br>1）转换（Transformation）：Transformation操作是延迟计算的，也就是说从一个RDD转<br>换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触<br>发运算。<br>2）行动（Action）：Action 算子会触发 Spark 提交作业（Job），并将数据输出 Spark 系统。<br>13&#x2F;04&#x2F;2018 Page 269 of 283<br>40. Storm<br>27.1.1. 概念<br>Storm 是一个免费并开源的分布式实时计算系统。利用 Storm 可以很容易做到可靠地处理无限的<br>数据流，像 Hadoop 批量处理大数据一样，Storm 可以实时处理数据。<br>27.1.1. 集群架构<br>27.1.1.1. Nimbus（master-代码分发给 Supervisor）<br>Storm 集群的 Master 节点，负责分发用户代码，指派给具体的 Supervisor 节点上的 Worker 节<br>点，去运行 Topology 对应的组件（Spout&#x2F;Bolt）的 Task。<br>27.1.1.2. Supervisor（slave-管理 Worker 进程的启动和终止）<br>Storm 集群的从节点，负责管理运行在 Supervisor 节点上的每一个 Worker 进程的启动和终止。<br>通过 Storm 的配置文件中的 supervisor.slots.ports 配置项，可以指定在一个 Supervisor 上最大<br>允许多少个 Slot，每个 Slot 通过端口号来唯一标识，一个端口号对应一个 Worker 进程（如果该<br>Worker 进程被启动）。<br>27.1.1.3. Worker（具体处理组件逻辑的进程）<br>运行具体处理组件逻辑的进程。Worker 运行的任务类型只有两种，一种是 Spout 任务，一种是<br>Bolt 任务。<br>13&#x2F;04&#x2F;2018 Page 270 of 283<br>27.1.1.4. Task<br>worker中每一个spout&#x2F;bolt的线程称为一个task. 在storm0.8 之后，task不再与物理线程对应，<br>不同 spout&#x2F;bolt 的 task 可能会共享一个物理线程，该线程称为 executor。<br>27.1.1.5. ZooKeeper<br>用来协调 Nimbus 和 Supervisor，如果 Supervisor 因故障出现问题而无法运行 Topology，<br>Nimbus 会第一时间感知到，并重新分配 Topology 到其它可用的 Supervisor 上运行<br>27.1.2. 编程模型（spout-&gt;tuple-&gt;bolt）<br>strom 在运行中可分为 spout 与 bolt 两个组件，其中，数据源从 spout 开始，数据以 tuple 的方<br>式发送到 bolt，多个 bolt 可以串连起来，一个 bolt 也可以接入多个 spot&#x2F;bolt.运行时原理如下图：<br>27.1.2.1. Topology<br>Storm 中运行的一个实时应用程序的名称。将 Spout、 Bolt 整合起来的拓扑图。定义了 Spout 和<br>Bolt 的结合关系、并发数量、配置等等。<br>27.1.2.2. Spout<br>在一个 topology 中获取源数据流的组件。通常情况下 spout 会从外部数据源中读取数据，然后转<br>换为 topology 内部的源数据。<br>27.1.2.3. Bolt<br>接受数据然后执行处理的组件,用户可以在其中执行自己想要的操作。<br>27.1.2.4. Tuple<br>一次消息传递的基本单元，理解为一组消息就是一个 Tuple。<br>13&#x2F;04&#x2F;2018 Page 271 of 283<br>27.1.2.5. Stream<br>Tuple 的集合。表示数据的流向。<br>27.1.3. Topology 运行<br>在 Storm 中,一个实时应用的计算任务被打包作为 Topology 发布，这同 Hadoop MapReduce<br>任务相似。但是有一点不同的是:在 Hadoop 中，MapReduce 任务最终会执行完成后结束；而在<br>Storm 中，Topology 任务一旦提交后永远不会结束，除非你显示去停止任务。计算任务<br>Topology 是由不同的 Spouts 和 Bolts，通过数据流（Stream）连接起来的图｡一个 Storm 在集<br>群上运行一个 Topology 时，主要通过以下 3 个实体来完成 Topology 的执行工作：<br>(1). Worker（进程）<br>(2). Executor（线程）<br>(3). Task<br>27.1.3.1. Worker(1 个 worker 进程执行的是 1 个 topology 的子集)<br>1 个 worker 进程执行的是 1 个 topology 的子集（注：不会出现 1 个 worker 为多个 topology<br>服务）。1 个 worker 进程会启动 1 个或多个 executor 线程来执行 1 个 topology 的<br>component(spout 或 bolt)。因此，1 个运行中的 topology 就是由集群中多台物理机上的多个<br>worker 进程组成的。<br>27.1.3.2. Executor(executor 是 1 个被 worker 进程启动的单独线程)<br>executor 是 1 个被 worker 进程启动的单独线程。每个 executor 只会运行 1 个 topology 的 1 个<br>component(spout 或 bolt)的 task（注：task 可以是 1 个或多个，storm 默认是 1 个<br>component 只生成 1 个 task，executor 线程里会在每次循环里顺序调用所有 task 实例）。<br>13&#x2F;04&#x2F;2018 Page 272 of 283<br>27.1.3.3. Task(最终运行 spout 或 bolt 中代码的单元)<br>是最终运行 spout 或 bolt 中代码的单元（注：1 个 task 即为 spout 或 bolt 的 1 个实例，<br>executor 线程在执行期间会调用该 task 的 nextTuple 或 execute 方法）。topology 启动后，1<br>个 component(spout 或 bolt)的 task 数目是固定不变的，但该 component 使用的 executor 线<br>程数可以动态调整（例如：1 个 executor 线程可以执行该 component 的 1 个或多个 task 实<br>例）。这意味着，对于 1 个 component 存在这样的条件：#threads&lt;&#x3D;#tasks（即：线程数小于<br>等于 task 数目）。默认情况下 task 的数目等于 executor 线程数目，即 1 个 executor 线程只运<br>行 1 个 task。<br>27.1.4. Storm Streaming Grouping<br>Storm 中最重要的抽象，应该就是 Stream grouping 了，它能够控制 Spot&#x2F;Bolt 对应的 Task 以<br>什么样的方式来分发 Tuple，将 Tuple 发射到目的 Spot&#x2F;Bolt 对应的 Task.<br>13&#x2F;04&#x2F;2018 Page 273 of 283<br>目前，Storm Streaming Grouping 支持如下几种类型：<br>27.1.4.1. huffle Grouping<br>随机分组，尽量均匀分布到下游 Bolt 中将流分组定义为混排。这种混排分组意味着来自 Spout 的<br>输入将混排，或随机分发给此 Bolt 中的任务。shuffle grouping 对各个 task 的 tuple 分配的比<br>较均匀。<br>27.1.4.2. Fields Grouping<br>按字段分组，按数据中 field 值进行分组；相同 field 值的 Tuple 被发送到相同的 Task 这种<br>grouping 机制保证相同 field 值的 tuple 会去同一个 task。<br>27.1.4.3. All grouping ：广播<br>广播发送， 对于每一个 tuple 将会复制到每一个 bolt 中处理。<br>13&#x2F;04&#x2F;2018 Page 274 of 283<br>27.1.4.4. Global grouping<br>全局分组，Tuple 被分配到一个 Bolt 中的一个 Task，实现事务性的 Topology。Stream 中的所<br>有的 tuple 都会发送给同一个 bolt 任务处理，所有的 tuple 将会发送给拥有最小 task_id 的 bolt<br>任务处理。<br>27.1.4.5. None grouping ：不分组<br>不关注并行处理负载均衡策略时使用该方式，目前等同于 shuffle grouping,另外 storm 将会把<br>bolt 任务和他的上游提供数据的任务安排在同一个线程下。<br>27.1.4.6. Direct grouping ：直接分组 指定分组<br>由 tuple 的发射单元直接决定 tuple 将发射给那个 bolt，一般情况下是由接收 tuple 的 bolt 决定<br>接收哪个 bolt 发射的 Tuple。这是一种比较特别的分组方法，用这种分组意味着消息的发送者指<br>定由消息接收者的哪个 task 处理这个消息。 只有被声明为 Direct Stream 的消息流可以声明这种<br>分组方法。而且这种消息 tuple 必须使用 emitDirect 方法来发射。消息处理者可以通过<br>TopologyContext 来获取处理它的消息的 taskid (OutputCollector.emit 方法也会返回<br>taskid)。<br>13&#x2F;04&#x2F;2018 Page 275 of 283<br>41. YARN<br>28.1.1. 概念<br>YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、<br>NodeManager（NM）、ApplicationMaster（AM）。其中，ResourceManager 负责所有资<br>源 的 监 控 、 分配 和 管 理； ApplicationMaster 负 责 每 一 个 具体 应 用 程序 的 调 度 和 协调 ；<br>NodeManager 负责每一个节点的维护。对于所有的 applications，RM 拥有绝对的控制权和对资<br>源的分配权。而每个 AM 则会和 RM 协商资源，同时和 NodeManager 通信来执行和监控 task。<br>几个模块之间的关系如图所示。<br>28.1.2. ResourceManager<br>42. ResourceManager 负责整个集群的资源管理和分配，是一个全局的资源管理系统。<br>43. NodeManager 以心跳的方式向 ResourceManager 汇报资源使用情况（目前主要是 CPU 和<br>内存的使用情况）。RM 只接受 NM 的资源回报信息，对于具体的资源处理则交给 NM 自己<br>处理。<br>44. YARN Scheduler 根据 application 的请求为其分配资源，不负责 application job 的监控、<br>追踪、运行状态反馈、启动等工作。<br>28.1.3. NodeManager<br>45. NodeManager 是每个节点上的资源和任务管理器，它是管理这台机器的代理，负责该节点<br>程序的运行，以及该节点资源的管理和监控。YARN集群每个节点都运行一个NodeManager。<br>13&#x2F;04&#x2F;2018 Page 276 of 283<br>46. NodeManager 定时向 ResourceManager 汇报本节点资源（CPU、内存）的使用情况和<br>Container 的运行状态。当 ResourceManager 宕机时 NodeManager 自动连接 RM 备用节<br>点。<br>47. NodeManager 接收并处理来自 ApplicationMaster 的 Container 启动、停止等各种请求。<br>28.1.4. ApplicationMaster<br>用户提交的每个应用程序均包含一个 ApplicationMaster，它可以运行在 ResourceManager 以外<br>的机器上。<br>48. 负责与 RM 调度器协商以获取资源（用 Container 表示）。<br>49. 将得到的任务进一步分配给内部的任务(资源的二次分配)。<br>50. 与 NM 通信以启动&#x2F;停止任务。<br>51. 监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务。<br>52. 当前 YARN 自带了两个 ApplicationMaster 实现，一个是用于演示 AM 编写方法的实例程序<br>DistributedShell，它可以申请一定数目的 Container 以并行运行一个 Shell 命令或者 Shell<br>脚本；另一个是运行 MapReduce 应用程序的 AM—MRAppMaster。<br>注：RM 只负责监控 AM，并在 AM 运行失败时候启动它。RM 不负责 AM 内部任务的容错，任务<br>的容错由 AM 完成。<br>13&#x2F;04&#x2F;2018 Page 277 of 283<br>28.1.5.YARN 运行流程<br>53. client 向 RM 提交应用程序，其中包括启动该应用的 ApplicationMaster 的必须信息，例如<br>ApplicationMaster 程序、启动 ApplicationMaster 的命令、用户程序等。<br>54. ResourceManager 启动一个 container 用于运行 ApplicationMaster。<br>55. 启动中的ApplicationMaster向ResourceManager注册自己，启动成功后与RM保持心跳。<br>56. ApplicationMaster 向 ResourceManager 发送请求，申请相应数目的 container。<br>57. ResourceManager 返回 ApplicationMaster 的申请的 containers 信息。申请成功的<br>container，由 ApplicationMaster 进行初始化。container 的启动信息初始化后，AM 与对<br>应的 NodeManager 通信，要求 NM 启动 container。AM 与 NM 保持心跳，从而对 NM 上<br>运行的任务进行监控和管理。<br>58. container 运行期间，ApplicationMaster 对 container 进行监控。container 通过 RPC 协议<br>向对应的 AM 汇报自己的进度和状态等信息。<br>59. 应用运行期间，client 直接与 AM 通信获取应用的状态、进度更新等信息。<br>60. 应用运行结束后，ApplicationMaster 向 ResourceManager 注销自己，并允许属于它的<br>container 被收回。<br>13&#x2F;04&#x2F;2018 Page 278 of 283<br>61. 机器学习<br>29.1.1. 决策树<br>29.1.2. 随机森林算法<br>29.1.3. 逻辑回归<br>29.1.4. SVM<br>29.1.5. 朴素贝叶斯<br>29.1.6. K 最近邻算法<br>29.1.7. K 均值算法<br>29.1.8. Adaboost 算法<br>29.1.9. 神经网络<br>29.1.10. 马尔可夫<br>参考：<a target="_blank" rel="noopener" href="http://www.cyzone.cn/a/20170422/310196.html">http://www.cyzone.cn/a/20170422/310196.html</a><br>13&#x2F;04&#x2F;2018 Page 279 of 283<br>62. 云计算<br>30.1.1. SaaS<br>SaaS 是 Software-as-a-Service（软件即服务）<br>30.1.2. PaaS<br>PaaS 是 Platform-as-a-Service 的缩写，意思是平台即服务。 把服务器平台作为一种服务提供的<br>商业模式。通过网络进行程序提供的服务称之为 SaaS(Software as a Service)，而云计算时代相<br>应的服务器平台或者开发环境作为服务进行提供就成为了 PaaS(Platform as a Service)。<br>30.1.3. IaaS<br>IaaS（Infrastructure as a Service），即基础设施即服务。提供给消费者的服务是对所有设施的<br>利用，包括处理、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作<br>系统和应用程序。<br>30.1.4. Docker<br>30.1.4.1. 概念<br>Docker 镜像<br>(Images)<br>Docker 镜像是用于创建 Docker 容器的模板。<br>13&#x2F;04&#x2F;2018 Page 280 of 283<br>Docker 的出现一定是因为目前的后端在开发和运维阶段确实需要一种虚拟化技术解决开发环境和<br>生产环境环境一致的问题，通过 Docker 我们可以将程序运行的环境也纳入到版本控制中，排除因<br>为环境造成不同运行结果的可能。但是上述需求虽然推动了虚拟化技术的产生，但是如果没有合<br>适的底层技术支撑，那么我们仍然得不到一个完美的产品。本文剩下的内容会介绍几种 Docker 使<br>用的核心技术，如果我们了解它们的使用方法和原理，就能清楚 Docker 的实现原理。Docker 使<br>用客户端-服务器 (C&#x2F;S) 架构模式，使用远程 API 来管理和创建 Docker 容器。Docker 容器通过<br>Docker 镜像来创建。<br>30.1.4.2. Namespaces<br>命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间<br>通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的<br>需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能<br>看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，<br>我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。<br>Docker 容器<br>(Container)<br>容器是独立运行的一个或一组应用。<br>Docker 客户端<br>(Client)<br>Docker 客户端通过命令行或者其他工具使用 Docker API 与 Docker 的守护进程通信。<br>Docker 主机<br>(Host)<br>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。<br>Docker 仓库<br>(Registry)<br>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。<br>Docker Hub 提供了庞大的镜像集合供使用。<br>Docker<br>Machine<br>Docker Machine 是一个简化 Docker 安装的命令行工具，通过一个简单的命令行即可在相<br>应的平台上安装 Docker，比如 VirtualBox、 Digital Ocean、Microsoft Azure。<br>13&#x2F;04&#x2F;2018 Page 281 of 283<br>Linux 的命名空间机制提供了以下七种不同的命名空间，包括 CLONE_NEWCGROUP、<br>CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、<br>CLONE_NEWUSER 和 CLONE_NEWUTS，通过这七个选项我们能在创建新的进程时设置新进程<br>应该在哪些资源上与宿主机器进行隔离。<br>30.1.4.3. 进程(CLONE_NEWPID 实现的进程隔离)<br>docker 创建新进程时传入 CLONE_NEWPID 实现的进程隔离，也就是使用 Linux 的命名空间实现<br>进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。当我们每次运行<br>docker run 或者 docker start 时，都会在创建一个用于设置进程间隔离的 Spec，同时会设置进<br>程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间，所有命名空间相关<br>的设置 Spec 最后都会作为 Create 函数的入参在创建新的容器时进行设置。<br>30.1.4.4. Libnetwork 与网络隔离<br>如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却有没有办法通过宿<br>主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离<br>的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。<br>Docker 整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的，它提供了一个连接不同<br>容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。<br>libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、<br>Endpoint 和 Network。在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前<br>容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，Linux 使用网络命名空间实现这个<br>Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡<br>veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux<br>网桥或者 VLAN。<br>每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同<br>的网络模式，Host、Container、None 和 Bridge 模式。<br>在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。在这种模式下，除了分配隔离的网<br>络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建<br>新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。在默认情况下，<br>13&#x2F;04&#x2F;2018 Page 282 of 283<br>每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的<br>容器中，会加入到名为 docker0 网桥中。<br>30.1.4.5. 资源隔离与 CGroups<br>Control Groups（简称 CGroups）能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I&#x2F;O 和网<br>络带宽。每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关<br>系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。<br>30.1.4.6. 镜像与 UnionFS<br>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统<br>的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需<br>要解决 - 也就是镜像。<br>Docker 镜像其实本质就是一个压缩包，我们可以使用命令将一个 Docker 镜像中的文件导出，你<br>可以看到这个镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说<br>Docker 镜像就是一个文件。<br>30.1.4.7. 存储驱动<br>Docker 使用了一系列不同的存储驱动管理镜像内的文件系统并运行容器，这些存储驱动与<br>Docker 卷（volume）有些不同，存储引擎管理着能够在多个容器之间共享的存储。<br>当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对<br>于运行时容器的修改其实都是对这个容器读写层的修改。<br>13&#x2F;04&#x2F;2018 Page 283 of 283<br>容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写<br>的层，也就是同一个镜像可以对应多个容器<br>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文<br>件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀<br>的性能和效率。<br>AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，<br>包括 aufs、devicemapper、overlay2、zfs 和 vfs 等等，在最新的 Docker 中，overlay2 取代了<br>aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs 作为 Docker<br>的默认驱动。时间 版本 说明<br>2019-2-27 v 1.0 初版发布<br>2019-3-2 v 2.0 对于第一版进行了大幅度更新，除了修改了一些小错误之外，还增加了一些内容。<br>2019-4-18 v3.0 修复错误，完善内容，增加了少部分内容。<br>必看<br>本文档由 SnailClimb 整理，文章大部分内容来源于本人的开源项目 JavaGuide，你可以把这个文档看做JavaGuide<br>的精简版，适合面试前的突击。更多精彩内容，欢迎关注我的公众号：JavaGuide。如需转载对应的文章，请附上下<br>面一段内容：<br>本文转载自JavaGuide，地址：<br>历史更新记录<br>建议阅读本文档的方式<br>本文档提供详细的目录，建议大家使用电脑阅读。如果大家用手机阅读的话，可以下载一个不错的PDF阅读器，比如<br>很多人常用的福昕PDF阅读器。<br>本文档提供详细的目录，大家可以根据自己的实际需要选择自己薄弱的知识章节阅读。<br>前言<br>不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有<br>章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。<br>运筹帷幄之后，决胜千里之外！不打毫无准备的仗，我觉得大家可以先从下面几个方面来准备面试：1. 自我介绍。（你可千万这样介绍：“我叫某某，性别，来自哪里，学校是那个，自己爱干什么”，记住：多说点简<br>历上没有的，多说点自己哪里比别人强！）<br>2. 自己面试中可能涉及哪些知识点、那些知识点是重点。<br>3. 面试中哪些问题会被经常问到、面试中自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多<br>少？能记住多久？第二：背题的方式的学习很难坚持下去！)<br>4. 自己的简历该如何写。<br>“80%的offer掌握在20%的人手中” 这句话也不是不无道理的。决定你面试能否成功的因素中实力固然占有很大一部<br>分比例，但是如果你的心态或者说运气不好的话，依然无法拿到满意的 offer。运气暂且不谈，就拿心态来说，千万<br>不要因为面试失败而气馁或者说怀疑自己的能力，面试失败之后多总结一下失败的原因，后面你就会发现自己会越来<br>越强大。<br>另外，大家要明确的很重要的几点是：<br>5. 写在简历上的东西一定要慎重，这可能是面试官大量提问的地方；<br>6. 大部分应届生找工作的硬伤是没有工作经验或实习经历；<br>7. 将自己的项目经历完美的展示出来非常重要。<br>笔主能力有限，如果有不对的地方或者和你想法不同的地方，敬请雅正、不舍赐教。<br>一 面试前的准备<br>1.1 如何准备一场面试<br>不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有<br>章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。 我其实特别不喜欢那种临近考试就提前<br>背啊记啊各种题的行为，非常反对！我觉得这种方法特别极端，而且在稍有一点经验的面试官面前是根本没有用的。<br>建议大家还是一步一个脚印踏踏实实地走。<br>1.1.1 如何获取大厂面试机会？<br>在讲如何获取大厂面试机会之前，先来给大家科普&#x2F;对比一下两个校招非常常见的概念——春招和秋招。<br>8. 招聘人数 ：秋招多于春招 ；<br>9. 招聘时间 ： 秋招一般7月左右开始，大概一直持续到10月底。但是大厂（如BAT）都会早开始早结束，所以一<br>定要把握好时间。春招最佳时间为3月，次佳时间为4月，进入5月基本就不会再有春招了（金三银四）。<br>10. 应聘难度 ：秋招略大于春招；<br>11. 招聘公司： 秋招数量多，而春招数量较少，一般为秋招的补充。<br>综上，一般来说，秋招的含金量明显是高于春招的。<br>下面我就说一下我自己知道的一些方法，不过应该也涵盖了大部分获取面试机会的方法。<br>12. 关注大厂官网，随时投递简历（走流程的网申）；<br>13. 线下参加宣讲会，直接投递简历；<br>14. 找到师兄师姐&#x2F;认识的人，帮忙内推（能够让你避开网申简历筛选，笔试筛选，还是挺不错的，不过也还是需要<br>你的简历够棒）；<br>15. 博客发文被看中&#x2F;Github优秀开源项目作者，大厂内部人员邀请你面试；<br>16. 求职类网站投递简历（不是太推荐，适合海投）；<br>除了这些方法，我也遇到过这样的经历：有些大公司的一些部门可能暂时没招够人，然后如果你的亲戚或者朋友刚好<br>在这个公司，而你正好又在寻求offer，那么面试机会基本上是有了，而且这种面试的难度好像一般还普遍比其他正<br>规面试低很多。<br>1.1.2 面试必知<br>下面几点概括起来就是：了解自己的能力、要应聘的公司、自己要应聘的岗位，提前做好自己我介绍以及项目介绍等<br>等方面的功课，确保你能在面试过程中简短清晰的回答出来（可以用Star法则来组织自己的语言）。1. 准备自己的自我介绍<br>从HR面、技术面到高管面&#x2F;部门主管面，面试官一般会让你先自我介绍一下，所以好好准备自己的自我介绍真的非常<br>重要。网上一般建议的是准备好两份自我介绍：一份对hr说的，主要讲能突出自己的经历，会的编程技术一语带过；<br>另一份对技术面试官说的，主要讲自己会的技术细节，项目经验，经历那些就一语带过。<br>我这里简单分享一下我自己的自我介绍的一个简单的模板吧：<br>面试官，您好！我叫某某。大学时间我主要利用课外时间学习某某。在校期间参与过一个某某系统的开发，另<br>外，自己学习过程中也写过很多系统比如某某系统。在学习之余，我比较喜欢通过博客整理分享自己所学知<br>识。我现在是某某社区的认证作者，写过某某很不错的文章。另外，我获得过某某奖,我的Github上开源的某个<br>项目已经有多少Star了。<br>2. 关于着装<br>穿西装、打领带、小皮鞋？NO！NO！NO！这是互联网公司面试又不是去走红毯，所以你只需要穿的简单大方就<br>好，不需要太正式。<br>3. 随身带上自己的成绩单和简历<br>有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。<br>4. 如果需要笔试就提前刷一些笔试题<br>平时空闲时间多的可以刷一下笔试题目（牛客网上有很多）。但是不要只刷面试题，不动手code，程序员不是为了<br>考试而存在的。<br>5. 花时间一些逻辑题<br>面试中发现有些公司都有逻辑题测试环节，并且都把逻辑笔试成绩作为很重要的一个参考。<br>6. 准备好自己的项目介绍<br>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：1. 对项目整体设计的一个感受（面试官可能会让你画系统的架构图）<br>2. 在这个项目中你负责了什么、做了什么、担任了什么角色<br>3. 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用<br>4. 另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个<br>棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高<br>访问速度和并发量、使用消息队列削峰和降流等等。1. 提前了解公司以及要应聘的岗位<br>面试之前一定要提前对要应聘的公司以及岗位有所了解，这一点对于喜欢海投的同学来说要格外注意。如果你去一个<br>公司面试连公司的主要业务或者主要产品都不了解的话，那么面试官打心里肯定会觉得你并没有很重视他们公司，所<br>以他们为什么要重视你呢？你也要提前了解你所要应聘岗位对你的专业能力或者其他能力的要求，比如有的岗位就是<br>需要英语水平比较高，需要你通过六级或者托福雅思，假如你不满足的话，那就没必要再去投递简历面试了。<br>1.1.3 提前准备技术面试<br>搞清楚自己面试中可能涉及哪些知识点、那些知识点是重点。面试中哪些问题会被经常问到、自己改如何回答。(强<br>烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)<br>1.1.4 面试之前做好定向复习<br>所谓定向复习就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面<br>经。<br>举个栗子：在我面试 ThoughtWorks 的前几天我就在网上找了一些关于 ThoughtWorks 的技术面的一些文章。然后<br>知道了 ThoughtWorks 的技术面会让我们在之前做的作业的基础上增加一个或两个功能，所以我提前一天就把我之<br>前做的程序重新重构了一下。然后在技术面的时候，简单的改了几行代码之后写个测试就完事了。如果没有提前准<br>备，我觉得 20 分钟我很大几率会完不成这项任务。<br>1.1.5 面试之后复盘<br>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你<br>强的多，反之亦然。我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试<br>失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！<br>1.2 简历该如何写<br>俗话说的好：“工欲善其事，必先利其器”。准备一份好的简历对于能不能找到一份好工作起到了至关重要的作<br>用。<br>1.2.1 为什么说简历很重要？<br>先从面试前来说<br>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一<br>关是Fail还是Pass。<br>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。<br>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。<br>所以，简历就像是我们的一个门面一样，它在很大程度上决定了你能否进入到下一轮的面试中。<br>再从面试中来说<br>我发现大家比较喜欢看面经 ，这点无可厚非，但是大部分面经都没告诉你很多问题都是在特定条件下才问的。举个<br>简单的例子：一般情况下你的简历上注明你会的东西才会被问到（Java、数据结构、网络、算法这些基础是每个人必<br>问的），比如写了你会 redis,那面试官就很大概率会问你 redis 的一些问题。比如：redis的常见数据类型及应用场<br>景、redis是单线程为什么还这么快、 redis 和 memcached 的区别、redis 内存淘汰机制等等。<br>所以，首先，你要明确的一点是：你不会的东西就不要写在简历上。另外，你要考虑你该如何才能让你的亮点在简历<br>中凸显出来，比如：你在某某项目做了什么事情解决了什么问题（只要有项目就一定有要解决的问题）、你的某一个<br>项目里使用了什么技术后整体性能和并发量提升了很多等等。<br>面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是<br>两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。<br>1.2.2 这3点你必须知道1. 大部分公司的HR都说我们不看重学历（骗你的！），但是如果你的学校不出众的话，很难在一堆简历中脱颖而<br>出，除非你的简历上有特别的亮点，比如：某某大厂的实习经历、获得了某某大赛的奖等等。<br>2. 大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错<br>过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的<br>工作<br>3. 写在简历上的东西一定要慎重，这是面试官大量提问的地方；<br>4. 将自己的项目经历完美的展示出来非常重要。<br>1.2.3 你必须知道的两大法则<br>①STAR法则（Situation Task Action Result）：<br>Situation： 事情是在什么情况下发生；<br>Task:： 你是如何明确你的任务的；<br>Action： 针对这样的情况分析，你采用了什么行动方式；<br>Result： 结果怎样，在这样的情况下你学习到了什么。<br>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理<br>熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。<br>下面这段内容摘自百度百科，我觉得写的非常不错：<br>STAR法则，500强面试题回答时的技巧法则，备受面试者成功者和500强HR的推崇。 由于这个法则被广泛应用<br>于面试问题的回答，尽管我们还在写简历阶段，但是，写简历时能把面试的问题就想好，会使自己更加主动和<br>自信，做到简历，面试关联性，逻辑性强，不至于在一个月后去面试，却把简历里的东西都忘掉了（更何况有<br>些朋友会稍微夸大简历内容）。在我们写简历时，每个人都要写上自己的工作经历，活动经历，想必每一个同<br>学，都会起码花上半天甚至更长的时间去搜寻脑海里所有有关的经历，争取找出最好的东西写在简历上。但是<br>此时，我们要注意了，简历上的任何一个信息点都有可能成为日后面试时的重点提问对象，所以说，不能只管<br>写上让自己感觉最牛的经历就完事了，要想到今后，在面试中，你所写的经历万一被面试官问到，你真的能回<br>答得流利，顺畅，且能通过这段经历，证明自己正是适合这个职位的人吗？<br>②FAB 法则（Feature Advantage Benefit）：<br>Feature： 是什么；<br>Advantage： 比别人好在哪些地方；<br>Benefit： 如果雇佣你，招聘方会得到什么好处。<br>简单来说，这个法则主要是让你的面试官知道你的优势、招了你之后对公司有什么帮助。<br>1.2.4 项目经历怎么写？<br>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑<br>从如下几点来写：<br>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑<br>从如下几点来写：<br>5. 对项目整体设计的一个感受<br>6. 在这个项目中你负责了什么、做了什么、担任了什么角色<br>7. 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用<br>8. 另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个<br>棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高<br>访问速度和并发量、使用消息队列削峰和降流等等。<br>1.2.5 专业技能该怎么写？<br>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可<br>能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可</p><p>1.2.6 开源程序员简历模板分享<br>分享一个Github上开源的程序员简历模板。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模<br>板、Web前端程序员简历模板、Java程序员简历模板、C&#x2F;C++程序员简历模板、NodeJS程序员简历模板、架构师简历<br>模板以及通用程序员简历模板 。 Github地址：<br>如果想学如何用 Markdown 写简历写一份高质量简历，请看这里:<br>1.2.7 其他的一些关于写简历的小tips<br>9. 尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。<br>10. 注意排版（不需要花花绿绿的），尽量使用Markdown语法。<br>11. 如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。<br>12. 如果自己的Github比较活跃的话，写上去也会为你加分很多。<br>13. 注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容<br>14. 项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。<br>15. 如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。<br>16. 简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。<br>1.3 如果面试官问你“你有什么问题问我吗？”时，你该如何回答<br>我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了<br>你这么多问题了，你有什么问题问我吗？”。这个时候很多人内心就会陷入短暂的纠结中:我该问吗？不问的话面试官<br>会不会对我影响不好？问什么问题？问这个问题会不会让面试官对我的影响不好啊？<br>1.3.1 这个问题对最终面试结果的影响到底大不大?<br>就技术面试而言，回答这个问题的时候，只要你不是触碰到你所面试的公司的雷区，那么我觉得这对你能不能拿到最<br>终offer来说影响确实是不大的。我说这些并不代表你就可以直接对面试官说：“我没问题了。”，笔主当时面试的时候<br>确实也说过挺多次“没问题要问了。”，最终也没有导致笔主被pass掉（可能是前面表现比较好，哈哈，自恋一下）。<br>我现在回想起来，觉得自己当时做法其实挺不对的。面试本身就是一个双向选择的过程，你对这个问题的回答也会侧<br>面反映出你对这次面试的上心程度，你的问题是否有价值，也影响了你最终的选择与公司是否选择你。<br>面试官在技术面试中主要考察的还是你这样个人到底有没有胜任这个工作的能力以及你是否适合公司未来的发展需<br>要，很多公司还需要你认同它的文化，我觉得你只要不是太笨，应该不会栽在这里。除非你和另外一个人在能力上相<br>同，但是只能在你们两个人中选一个，那么这个问题才对你能不能拿到offer至关重要。有准备总比没准备好，给面<br>试官留一个好的影响总归是没错的。<br>但是，就非技术面试来说，我觉得好好回答这个问题对你最终的结果还是比较重要的。<br>总的来说不管是技术面试还是非技术面试，如果你想赢得公司的青睐和尊重，我觉得我们都应该重视这个问题。<br>1.3.2 真诚一点,不要问太 Low 的问题<br>回答这个问题很重要的一点就是你没有必要放低自己的姿态问一些很虚或者故意讨好面试官的问题，也不要把自己从<br>面经上学到的东西照搬下来使用。面试官也不是傻子，特别是那种特别有经验的面试官，你是真心诚意的问问题，还<br>是从别处照搬问题来讨好面试官，人家可能一听就听出来了。总的来说，还是要真诚。除此之外，不要问太Low的问<br>题，会显得你整个人格局比较小或者说你根本没有准备（侧面反映你对这家公司不伤心，既然你不上心，为什么要要<br>你呢）。举例几个比较 Low 的问题，大家看看自己有没有问过其中的问题：<br>贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？）<br>贵公司的男女比例如何？（考虑脱单？记住你是来工作的！）<br>贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！）<br>……<br>1.3.3 有哪些有价值的问题值得问?<br>针对这个问题。笔主专门找了几个专门做HR工作的小哥哥小姐姐们询问并且查阅了挺多前辈们的回答，然后结合自<br>己的实际经历，我概括了下面几个比较适合问的问题。<br>面对HR或者其他Level比较低的面试官时<br>17. 能不能谈谈你作为一个公司老员工对公司的感受? (这个问题比较容易回答，不会让面试官陷入无话可说的尴尬<br>境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样<br>或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离。)<br>18. 能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?有什么地方你觉<br>得还不太好或者可以继续完善吗？ （类似第一个问题，都是问面试官个人对于公司的看法，）<br>19. 我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？(这个是我常问的。我觉得说自己表现不好只是<br>这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)<br>20. 接下来我会有一段空档期，有什么值得注意或者建议学习的吗？ （体现出你对工作比较上心，自助学习意识比<br>较强。）<br>21. 这个岗位为什么还在招人？ (岗位真实性和价值咨询)<br>22. 大概什么时候能给我回复呢？ (终面的时候，如果面试官没有说的话，可以问一下)<br>23. ……<br>面对部门领导<br>24. 部门的主要人员分配以及对应的主要工作能简单介绍一下吗？<br>25. 未来如果我要加入这个团队，你对我的期望是什么？ （部门领导一般情况下是你的直属上级了，你以后和他打<br>交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且<br>愿意倾听的候选人。）<br>26. 公司对新入职的员工的培养机制是什么样的呢？ （正规的公司一般都有培养机制，提前问一下是对你自己的负<br>责也会显的你比较上心）<br>27. 以您来看，这个岗位未来在公司内部的发展如何？ (在我看来，问这个问题也是对你自己的负责吧，谁不想发展<br>前景更好的岗位呢？)<br>28. 团队现在面临的最大挑战是什么？ (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或<br>困难有一个提前的预期。)<br>面对Level比较高的(比如总裁,老板)<br>29. 贵公司的发展目标和方向是什么？ （看下公司的发展是否满足自己的期望）<br>30. 与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？ （充分了解自己的优势和劣势）<br>31. 公司现在面临的最大挑战是什么？<br>1.3.4 来个补充,顺便送个祝福给大家<br>薪酬待遇和相关福利问题一般在终面的时候（最好不要在前面几面的时候就问到这个问题），面试官会提出来或者在<br>面试完之后以邮件的形式告知你。一般来说，如果面试官很愿意为你回答问题，对你的问题也比较上心的话，那他肯<br>定是觉得你就是他们要招的人。<br>大家在面试的时候，可以根据自己对于公司或者岗位的了解程度，对上面提到的问题进行适当修饰或者修改。上面提<br>到的一些问题只是给没有经验的朋友一个参考，如果你还有其他比较好的问题的话，那当然也更好啦！<br>金三银四。过了二月就到了面试高峰期或者说是黄金期。几份惊喜几份愁，愿各位能始终不忘初心！每个人都有每个<br>人的难处。引用一句《阿甘正传》里面的台词：“生活就像一盒巧克力，你永远不知道下一块是什么味道“。<br>1.4 面试官问你的优点是什么，应该如何回答?<br>回答这样的问题，最好能够结合你要应聘的职位来做针对性回答。一般面试官问这个问题的时候，很可能会只让你说<br>几个你觉得最能体现你能力的优点，为了避免自己在面试过程中不知道该说自己的那些优点，你可以在面试之前好好<br>准备一下。 面试的时候最好可以说几个你要应聘的职位所做的事情需要的优点或者说你要应聘的公司比较看重的优<br>点(企业文化)。<br>1.5 面试官问你的缺点是什么，应该如何回答?<br>缺点肯定不能是目标岗位需要的关键能力！！！<br>总之，记住一点，面试官问你这个问题的话，你可以说一些不影响你这个职位工作需要的一些缺点。比如你面试后端<br>工程师，面试官问你的缺点是什么的话，你可以这样说：自己比较内向，平时不太爱与人交流，但是考虑到以后可能<br>要和客户沟通，自己正在努力改。<br>1.6 七个大部分程序员在面试前很关心的问题<br>身边的朋友或者公众号的粉丝很多人都向我询问过:“我是双非&#x2F;三本&#x2F;专科学校的，我有机会进入大厂吗？”、“非计<br>算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学那些东西？”、“我该如何准备Java面试？”……这些方<br>面的问题。我会根据自己的一点经验对大部分人关心的这些问题进行答疑解惑。现在又刚好赶上考研结束，这篇文章<br>也算是给考研结束准备往Java后端方向发展的朋友们指名一条学习之路。道理懂了如果没有实际行动，那这篇文章对<br>你或许没有任何意义。<br>Question1:我是双非&#x2F;三本&#x2F;专科学校的，我有机会进入大厂吗？<br>我自己也是非985非211学校的，结合自己的经历以及一些朋友的经历，我觉得让我回答这个问题再好不过。<br>首先，我觉得学校歧视很正常，真的太正常了，如果要抱怨的话，你只能抱怨自己没有进入名校。但是，千万不<br>要动不动说自己学校差，动不动拿自己学校当做自己进不了大厂的借口，学历只是筛选简历的很多标准中的一个而<br>已，如果你够优秀，简历够丰富，你也一样可以和名校同学一起同台竞争。<br>企业HR肯定是更喜欢高学历的人，毕竟985，211优秀人才比例肯定比普通学校高很多，HR团队肯定会优先在这<br>些学校里选。这就好比相亲，你是愿意在很多优秀的人中选一个优秀的，还是愿意在很多普通的人中选一个优秀的<br>呢？ 双非本科甚至是二本、三本甚至是专科的同学也有很多进入大厂的，不过比率相比于名校的低很多而<br>已。从大厂招聘的结果上看，高学历人才的数量占据大头，那些成功进入BAT、美团，京东，网易等大厂的双非本科<br>甚至是二本、三本甚至是专科的同学往往是因为具备丰富的项目经历或者在某个含金量比较高的竞赛比如ACM中取得<br>了不错的成绩。一部分学历不突出但能力出众的面试者能够进入大厂并不是说明学历不重要，而是学历的软肋能够通<br>过其他的优势来弥补。 所以，如果你的学校不够好而你自己又想去大厂的话，建议你可以从这几点来做：①尽量在<br>面试前最好有一个可以拿的出手的项目；②有实习条件的话，尽早出去实习，实习经历也会是你的简历的一个亮点<br>（有能力在大厂实习最佳！）；③参加一些含金量比较高的比赛，拿不拿得到名次没关系，重在锻炼。<br>Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？<br>当然可以！现在非科班的程序员很多，很大一部分原因是互联网行业的工资比较高。我们学校外面的培训班里面<br>90%都是非科班，我觉得他们很多人学的都还不错。另外，我的一个朋友本科是机械专业，大一开始自学安卓，技术<br>贼溜，在我看来他比大部分本科是计算机的同学学的还要好。参考Question1的回答，即使你是非科班程序员，如果<br>你想进入大厂的话，你也可以通过自己的其他优势来弥补。<br>我觉得我们不应该因为自己的专业给自己划界限或者贴标签，说实话，很多科班的同学可能并不如你，你以为科<br>班的同学就会认真听讲吗？还不是几乎全靠自己课下自学！不过如果你是非科班的话，你想要学好，那么注定就要舍<br>弃自己本专业的一些学习时间，这是无可厚非的。<br>建议非科班的同学，首先要打好计算机基础知识基础：①计算机网络、②操作系统、③数据机构与算法，我个人<br>觉得这3个对你最重要。这些东西就像是内功，对你以后的长远发展非常有用。当然，如果你想要进大厂的话，这些<br>知识也是一定会被问到的。另外，“一定学好数据机构与算法！一定学好数据机构与算法！一定学好数据机构与算<br>法！”，重要的东西说3遍。<br>Question3: 我没有实习经历的话找工作是不是特别艰难？<br>没有实习经历没关系，只要你有拿得出手的项目或者大赛经历的话，你依然有可能拿到大厂的 offer 。笔主当时<br>找工作的时候就没有实习经历以及大赛获奖经历，单纯就是凭借自己的项目经验撑起了整个面试。<br>如果你既没有实习经历，又没有拿得出手的项目或者大赛经历的话，我觉得在简历关，除非你有其他特别的亮<br>点，不然，你应该就会被刷。<br>Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？<br>下面是我总结的一些准备面试的Tips以及面试必备的注意事项：<br>32. 准备一份自己的自我介绍，面试的时候根据面试对象适当进行修改（突出重点，突出自己的优势在哪里，切忌<br>流水账）；<br>33. 注意随身带上自己的成绩单和简历复印件； （有的公司在面试前都会让你交一份成绩单和简历当做面试中的参<br>考。）<br>34. 如果需要笔试就提前刷一些笔试题，大部分在线笔试的类型是选择题+编程题，有的还会有简答题。（平时空闲<br>时间多的可以刷一下笔试题目（牛客网上有很多），但是不要只刷面试题，不动手code，程序员不是为了考试<br>而存在的。）另外，注意抓重点，因为题目太多了，但是有很多题目几乎次次遇到，像这样的题目一定要搞<br>定。<br>35. 提前准备技术面试。 搞清楚自己面试中可能涉及哪些知识点、那些知识点是重点。面试中哪些问题会被经常问<br>到、自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方<br>式的学习很难坚持下去！)<br>36. 面试之前做好定向复习。 也就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你<br>要面试的公司的面经。<br>37. 准备好自己的项目介绍。 如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你<br>可以从下面几个方向来考虑：①对项目整体设计的一个感受（面试官可能会让你画系统的架构图；②在这个项<br>目中你负责了什么、做了什么、担任了什么角色；③ 从这个项目中你学会了那些东西，使用到了那些技术，学<br>会了那些新技术的使用；④项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开<br>发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能<br>比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。<br>38. 面试之后记得复盘。 面试遭遇失败是很正常的事情，所以善于总结自己的失败原因才是最重要的。如果失败，<br>不要灰心；如果通过，切勿狂喜。<br>一些还算不错的 Java面试&#x2F;学习相关的仓库，相信对大家准备面试一定有帮助：盘点一下Github上开源的Java面试&#x2F;<br>学习相关的仓库，看完弄懂薪资至少增加10k<br>Question5: 我该自学还是报培训班呢？<br>我本人更加赞同自学（你要知道去了公司可没人手把手教你了，而且几乎所有的公司都对培训班出生的有偏见。<br>为什么有偏见，你学个东西还要去培训班，说明什么，同等水平下，你的自学能力以及自律能力一定是比不上自学的<br>人的）。但是如果，你连每天在寝室坚持学上8个小时以上都坚持不了，或者总是容易半途而废的话，我还是推荐你<br>去培训班。观望身边同学去培训班的，大多是非计算机专业或者是没有自律能力以及自学能力非常差的人。<br>另外，如果自律能力不行，你也可以通过结伴学习、参加老师的项目等方式来督促自己学习。<br>总结：去不去培训班主要还是看自己，如果自己能坚持自学就自学，坚持不下来就去培训班。<br>Question6: 没有项目经历&#x2F;博客&#x2F;Github开源项目怎么办？<br>从现在开始做！<br>网上有很多非常不错的项目视频，你就跟着一步一步做，不光要做，还要改进，改善。另外，如果你的老师有相<br>关 Java 后台项目的话，你也可以主动申请参与进来。<br>如果有自己的博客，也算是简历上的一个亮点。建议可以在掘金、Segmentfault、CSDN等技术交流社区写博<br>客，当然，你也可以自己搭建一个博客（采用 Hexo+Githu Pages 搭建非常简单）。写一些什么？学习笔记、实战内<br>容、读书笔记等等都可以。<br>多用 Github，用好 Github，上传自己不错的项目，写好 readme 文档，在其他技术社区做好宣传。相信你也会<br>收获一个不错的开源项目！<br>Question7: 大厂到底青睐什么样的应届生？<br>从阿里、腾讯等大厂招聘官网对于Java后端方向&#x2F;后端方向的应届实习生的要求，我们大概可以总结归纳出下面<br>这 4 点能给简历增加很多分数：<br>参加过竞赛（含金量超高的是ACM）；<br>对数据结构与算法非常熟练；<br>参与过实际项目（比如学校网站）；<br>参与过某个知名的开源项目或者自己的某个开源项目很不错；<br>除了我上面说的这三点，在面试Java工程师的时候，下面几点也提升你的个人竞争力：<br>熟悉Python、Shell、Perl等脚本语言；<br>熟悉 Java 优化，JVM调优；<br>熟悉 SOA 模式；<br>熟悉自己所用框架的底层知识比如Spring；<br>了解分布式一些常见的理论；<br>具备高并发开发经验；大数据开发经验等等。<br>二 Java<br>2.1 Java 基础知识<br>2.1.1 重载和重写的区别<br>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以<br>不同，发生在编译时。<br>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，<br>访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。<br>2.1.2 String 和 StringBuffer、StringBuilder 的区别是什么？String 为什<br>么是不可变的？<br>可变性<br>简单的来说：String 类中使用 final 关键字字符数组保存字符串， private final char value[] ，所以 String<br>对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder<br>中也是使用字符数组保存字符串 char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。<br>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自<br>行查阅源码。<br>AbstractStringBuilder.java<br>线程安全性<br>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与<br>StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共<br>方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对<br>方法进行加同步锁，所以是非线程安全的。<br>性能<br>abstract class AbstractStringBuilder implements Appendable, CharSequence {<br>char[] value;<br>int count;<br>AbstractStringBuilder() {<br>}<br>AbstractStringBuilder(int capacity) {<br>value &#x3D; new char[capacity];<br>}<br>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。<br>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<br>StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。<br>对于三者使用的总结：<br>39. 操作少量的数据 &#x3D; String<br>40. 单线程操作字符串缓冲区下操作大量数据 &#x3D; StringBuilder<br>41. 多线程操作字符串缓冲区下操作大量数据 &#x3D; StringBuffer<br>2.1.3 自动装箱与拆箱<br>装箱：将基本类型用它们对应的引用类型包装起来；<br>拆箱：将包装类型转换为基本数据类型；<br>2.1.4 &#x3D;&#x3D; 与 equals<br>&#x3D;&#x3D; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型&#x3D;&#x3D;比较的是<br>值，引用数据类型&#x3D;&#x3D;比较的是内存地址)<br>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：<br>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。<br>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相<br>等，则返回 true (即，认为这两个对象相等)。<br>举个例子：<br>说明：<br>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的<br>equals 方法比较的是对象的值。<br>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有<br>就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。<br>public class test1 {<br>public static void main(String[] args) {<br>String a &#x3D; new String(“ab”); &#x2F;&#x2F; a 为一个引用<br>String b &#x3D; new String(“ab”); &#x2F;&#x2F; b为另一个引用,对象的内容一样<br>String aa &#x3D; “ab”; &#x2F;&#x2F; 放在常量池中<br>String bb &#x3D; “ab”; &#x2F;&#x2F; 从常量池中查找<br>if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true<br>System.out.println(“aa&#x3D;&#x3D;bb”);<br>if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象<br>System.out.println(“a&#x3D;&#x3D;b”);<br>if (a.equals(b)) &#x2F;&#x2F; true<br>System.out.println(“aEQb”);<br>if (42 &#x3D;&#x3D; 42.0) { &#x2F;&#x2F; true<br>System.out.println(“true”);<br>}<br>}<br>}<br>2.1.5 关于 final 关键字的一些总结<br>final关键字主要用在三个地方：变量、方法、类。<br>42. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的<br>变量，则在对其初始化之后便不能再让其指向另一个对象。<br>43. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。<br>44. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。<br>在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的<br>任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地<br>指定为fianl。<br>2.1.6 Object类的常见方法总结<br>Object类是一个特殊的类，是所有类的父类。它主要提供了以下11个方法：<br>2.1.7 Java 中的异常处理<br>public final native Class&lt;?&gt; getClass()&#x2F;&#x2F;native方法，用于返回当前运行时对象的Class对象，使用了<br>final关键字修饰，故不允许子类重写。<br>public native int hashCode() &#x2F;&#x2F;native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的<br>HashMap。<br>public boolean equals(Object obj)&#x2F;&#x2F;用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户<br>比较字符串的值是否相等。<br>protected native Object clone() throws CloneNotSupportedException&#x2F;&#x2F;naitive方法，用于创建并返回<br>当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() !&#x3D; x 为true，x.clone().getClass()<br>=&#x3D; x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生<br>CloneNotSupportedException异常。<br>public String toString()&#x2F;&#x2F;返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方<br>法。<br>public final native void notify()&#x2F;&#x2F;native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视<br>器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。<br>public final native void notifyAll()&#x2F;&#x2F;native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒<br>在此对象监视器上等待的所有线程，而不是一个线程。<br>public final native void wait(long timeout) throws InterruptedException&#x2F;&#x2F;native方法，并且不能<br>重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。<br>public final void wait(long timeout, int nanos) throws InterruptedException&#x2F;&#x2F;多了nanos参数，<br>这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。<br>public final void wait() throws InterruptedException&#x2F;&#x2F;跟之前的2个wait方法一样，只不过该方法一直等<br>待，没有超时时间这个概念<br>protected void finalize() throws Throwable { }&#x2F;&#x2F;实例被垃圾回收器回收的时候触发的操作<br>Java异常类层次结构图<br>在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable： 有两个重要的子类：<br>Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。<br>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无<br>关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当<br>JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一<br>般会选择线程终止。<br>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual<br>MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和<br>处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错<br>误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。<br>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。<br>RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该<br>异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和<br>ArrayIndexOutOfBoundsException （下标越界异常）。<br>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。<br>Throwable类常用方法<br>public string getMessage():返回异常发生时的详细信息<br>public string toString():返回异常发生时的简要描述<br>public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可<br>以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同<br>public void printStackTrace():在控制台上打印Throwable对象封装的异常信息<br>异常处理总结<br>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。<br>catch 块：用于处理try捕获到的异常。<br>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句<br>时，finally语句块将在方法返回之前被执行。<br>在以下4种特殊情况下，finally块不会被执行：<br>45. 在finally语句块中发生了异常。<br>46. 在前面的代码中用了System.exit()退出程序。<br>47. 程序所在的线程死亡。<br>48. 关闭CPU。<br>2.1.8 获取用键盘输入常用的的两种方法<br>方法1：通过 Scanner<br>方法2：通过 BufferedReader<br>2.1.9 接口和抽象类的区别是什么<br>49. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以<br>有非抽象的方法<br>50. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定<br>51. 一个类可以实现多个接口，但最多只能实现一个抽象类<br>52. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定<br>53. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽<br>象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br>备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现<br>两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。(详见<br>issue:<br>2.2 Java 集合框架<br>2.2.1 Arraylist 与 LinkedList 异同<br>54. 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>55. 底层数据结构： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之<br>前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别：）； 详细可阅读JDK1.7-LinkedList<br>循环链表优化<br>Scanner input &#x3D; new Scanner(System.in);<br>String s &#x3D; input.nextLine();<br>input.close();<br>BufferedReader input &#x3D; new BufferedReader(new InputStreamReader(System.in));<br>String s &#x3D; input.readLine();<br>56. 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素<br>位置的影响。 比如：执行 add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种<br>情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（ add(int index, E element) ）时<br>间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向<br>前移一位的操作。 ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是<br>近似 O（1）而数组为近似 O（n）。<br>57. 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通<br>过元素的序号快速获取元素对象(对应于 get(int index) 方法)。<br>58. 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空<br>间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数<br>据）。<br>补充内容:RandomAccess接口<br>public interface RandomAccess {<br>}<br>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个<br>标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。<br>在binarySearch（）方法中，它要判断传入的list 是否RamdomAccess的实例，如果是，调用<br>indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法<br>public static &lt;T&gt;<br>int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {<br>if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>return Collections.indexedBinarySearch(list, key);<br>else<br>return Collections.iteratorBinarySearch(list, key);<br>}<br>ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！<br>ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随<br>机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，<br>ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不<br>是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！<br>下面再总结一下 list 的遍历方式选择：<br>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,<br>未实现RandomAccess接口的list， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大<br>size的数据，千万不要使用普通for循环<br>补充：数据结构基础之双向链表<br>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从<br>双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表，如<br>下图所示，同时下图也是LinkedList 底层使用的是双向循环链表数据结构。<br>2.2.2 ArrayList 与 Vector 区别<br>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要<br>在同步操作上耗费大量的时间。<br>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。<br>2.2.3 HashMap的底层实现<br>JDK1.8之前<br>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经<br>过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的<br>长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的<br>话，直接覆盖，不相同就通过拉链法解决冲突。<br>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的<br>hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。<br>JDK 1.8 HashMap 的 hash 方法源码:<br>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。<br>对比一下 JDK1.7的 HashMap 的 hash 方法源码.<br>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。<br>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希<br>冲突，则将冲突的值加到链表中即可。<br>static final int hash(Object key) {<br>int h;<br>&#x2F;&#x2F; key.hashCode()：返回散列值也就是hashcode<br>&#x2F;&#x2F; ^ ：按位异或<br>&#x2F;&#x2F; &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐<br>return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}<br>static int hash(int h) {<br>&#x2F;&#x2F; This function ensures that hashCodes that differ only by<br>&#x2F;&#x2F; constant multiples at each bit position have a bounded<br>&#x2F;&#x2F; number of collisions (approximately 8 at default load factor).<br>h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>}<br>JDK1.8之后<br>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转<br>化为红黑树，以减少搜索时间。<br>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺<br>陷，因为二叉查找树在某些情况下会退化成一个线性结构。<br>推荐阅读：<br>《Java 8系列之重新认识HashMap》 ：<br>2.2.5 HashMap 的长度为什么是2的幂次方<br>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的<br>范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应<br>用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之<br>前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算<br>方法是“ (n - 1) &amp; hash ”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。<br>这个算法应该如何设计呢？<br>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其<br>除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采<br>用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。<br>2.2.6 HashMap 多线程操作导致死循环问题<br>在多线程下，进行 put 操作会导致 HashMap 死循环，原因在于 HashMap 的扩容 resize()方法。由于扩容是新建一<br>个数组，复制原数据到数组。由于数组下标挂有链表，所以需要复制链表，但是多线程操作有可能导致环形链表。复<br>制链表过程如下:<br>以下模拟2个线程同时扩容。假设，当前 HashMap 的空间为2（临界值为1），hashcode 分别为 0 和 1，在散列地</p><p>址 0 处有元素 A 和 B，这时候要添加元素 C，C 经过 hash 运算，得到散列地址为 1，这时候由于超过了临界值，空<br>间不够，需要调用 resize 方法进行扩容，那么在多线程条件下，会出现条件竞争，模拟过程如下：<br>线程一：读取到当前的 HashMap 情况，在准备扩容时，线程二介入<br>线程二：读取 HashMap，进行扩容<br>线程一：继续执行<br>这个过程为，先将 A 复制到新的 hash 表中，然后接着复制 B 到链头（A 的前边：B.next&#x3D;A），本来 B.next&#x3D;null，<br>到此也就结束了（跟线程二一样的过程），但是，由于线程二扩容的原因，将 B.next&#x3D;A，所以，这里继续复制A，让<br>A.next&#x3D;B，由此，环形链表出现：B.next&#x3D;A; A.next&#x3D;B<br>注意：jdk1.8已经解决了死循环的问题。<br>2.2.7 HashSet 和 HashMap 区别<br>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常<br>少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是<br>直接调用 HashMap 中的方法。）<br>2.2.8 ConcurrentHashMap 和 Hashtable 的区别<br>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。<br>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟<br>HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类<br>似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；<br>实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了<br>分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁<br>竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑<br>树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很<br>多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，<br>但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，<br>效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用<br>put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。<br>两者的对比图：<br>图片来源：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/chengxiao/p/6842045.html">http://www.cnblogs.com/chengxiao/p/6842045.html</a><br>HashTable:<br>JDK1.7的ConcurrentHashMap：<br>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：<br>2.2.9 ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现<br>JDK1.7（上面有示意图）<br>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的<br>数据也能被其他线程访问。<br>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。<br>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数<br>据。<br>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结<br>构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个<br>HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。<br>JDK1.8 （上面有示意图）<br>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8<br>的结构类似，数组+链表&#x2F;红黑二叉树。<br>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br>2.2.10 集合框架底层数据结构总结<br>Collection1. List<br>Arraylist： Object数组<br>Vector： Object数组<br>LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) 详细可阅读JDK1.7-LinkedList循环链表优<br>化<br>2. Set<br>HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素<br>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类<br>似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。<br>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)<br>Map<br>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希<br>冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默<br>认为8）时，将链表转化为红黑树，以减少搜索时间<br>LinkedHashMap: LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和<br>链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以<br>保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<br>《LinkedHashMap 源码详细分析（JDK1.8）》<br>HashTable: 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的<br>TreeMap: 红黑树（自平衡的排序二叉树）<br>2.3 Java多线程<br>关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁（ 具体可以看我的这篇文章：面试必备之乐<br>观锁与悲观锁）、②synchronized和lock区别以及volatile和synchronized的区别，③可重入锁与非可重入锁的区<br>别、④多线程是解决什么问题的、⑤线程池解决什么问题、⑥线程池的原理、⑦线程池使用时的注意事项、⑧AQS原<br>理、⑨ReentranLock源码，设计原理，整体过程 等等问题。<br>static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {<br>}<br>面试官在多线程这一部分很可能会问你有没有在项目中实际使用多线程的经历。所以，如果你在你的项目中有实<br>际使用Java多线程的经历 的话，会为你加分不少哦！<br>一 面试中关于 synchronized 关键字的 5 连击<br>1.1 说一说自己对于 synchronized 关键字的了解<br>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者<br>代码块在任意时刻只能有一个线程执行。<br>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操<br>作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，<br>都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要<br>相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后<br>Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对<br>锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的<br>开销。<br>1.2 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗<br>synchronized关键字最主要的三种使用方式：<br>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁<br>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作<br>用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态<br>资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实<br>例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允<br>许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态<br>synchronized 方法占用的锁是当前实例对象锁。<br>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和 synchronized 方<br>法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和<br>synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态<br>方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量<br>池具有缓冲功能！<br>下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理<br>呗！”<br>双重校验锁实现对象单例（线程安全）<br>public class Singleton {<br>private volatile static Singleton uniqueInstance;<br>private Singleton() {<br>}<br>public static Singleton getUniqueInstance() {<br>&#x2F;&#x2F;先判断对象是否已经实例过，没有实例化过才进入加锁代码<br>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分<br>为三步执行：<br>3. 为 uniqueInstance 分配内存空间<br>4. 初始化 uniqueInstance<br>5. 将 uniqueInstance 指向分配的内存地址<br>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在<br>多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用<br>getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被<br>初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。<br>1.3 讲一下 synchronized 关键字的底层原理<br>synchronized 关键字底层原理属于 JVM 层面。<br>① synchronized 同步语句块的情况<br>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac<br>SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行 javap -c -s -v -l<br>SynchronizedDemo.class 。</p><p>从上面我们可以看出：<br>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同<br>步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图<br>获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取<br>锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设<br>为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当<br>前线程就要阻塞等待，直到锁被另外一个线程释放为止。<br>② synchronized 修饰方法的的情况<br>public class SynchronizedDemo2 {<br>public synchronized void method() {<br>System.out.println(“synchronized 方法”);<br>}<br>}<br>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<br>ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来<br>辨别一个方法是否声明为同步方法，从而执行相应的同步调用。<br>1.4 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优<br>化吗<br>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减<br>少锁操作的开销。<br>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐<br>渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。<br>关于这几种优化的详细信息可以查看：synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和<br>ReenTrantLock 的对比</p><p>四 面试中关于 Atomic 原子类的 4 连击<br>4.1 介绍一下Atomic 原子类<br>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割<br>的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不<br>会被其他线程干扰。<br>所以，所谓原子类说简单点就是具有原子&#x2F;原子操作特征的类。<br>并发包 java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic 下,如下图所示。<br>4.2 JUC 包中的原子类是哪4类?<br>基本类型<br>使用原子的方式更新基本类型<br>AtomicInteger：整形原子类<br>AtomicLong：长整型原子类<br>AtomicBoolean ：布尔型原子类<br>数组类型<br>使用原子的方式更新数组里的某个元素<br>AtomicIntegerArray：整形数组原子类<br>AtomicLongArray：长整形数组原子类<br>AtomicReferenceArray ：引用类型数组原子类<br>引用类型<br>AtomicReference：引用类型原子类<br>AtomicStampedRerence：原子更新引用类型里的字段原子类<br>AtomicMarkableReference ：原子更新带有标记位的引用类型<br>对象的属性修改类型<br>AtomicIntegerFieldUpdater:原子更新整形字段的更新器<br>AtomicLongFieldUpdater：原子更新长整形字段的更新器<br>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原<br>子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。<br>4.3 讲讲 AtomicInteger 的使用<br>AtomicInteger 类常用方法<br>AtomicInteger 类的使用示例<br>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。<br>4.4 能不能给我简单介绍一下 AtomicInteger 类的原理<br>AtomicInteger 线程安全原理简单分析<br>AtomicInteger 类的部分源码：<br>public final int get() &#x2F;&#x2F;获取当前的值<br>public final int getAndSet(int newValue)&#x2F;&#x2F;获取当前的值，并设置新的值<br>public final int getAndIncrement()&#x2F;&#x2F;获取当前的值，并自增<br>public final int getAndDecrement() &#x2F;&#x2F;获取当前的值，并自减<br>public final int getAndAdd(int delta) &#x2F;&#x2F;获取当前的值，并加上预期的值<br>boolean compareAndSet(int expect, int update) &#x2F;&#x2F;如果输入的数值等于预期值，则以原子方式将该值设置为输<br>入值（update）<br>public final void lazySet(int newValue)&#x2F;&#x2F;最终设置为newValue,使用 lazySet 设置之后可能导致其他线程<br>在之后的一小段时间内还是可以读到旧的值。<br>class AtomicIntegerTest {<br>private AtomicInteger count &#x3D; new AtomicInteger();<br>&#x2F;&#x2F;使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。<br>public void increment() {<br>count.incrementAndGet();<br>}<br>public int getCount() {<br>return count.get();<br>}<br>}<br>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免<br>synchronized 的高开销，执行效率大为提升。<br>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法<br>是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变<br>量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。<br>关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：JUC 中的 Atomic 原子类总结<br>3.2 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程<br>百度好像最喜欢问这个问题。<br>打开一个网页，整个过程会使用哪些协议<br>图片来源：《图解HTTP》<br>总体来说分为以下几个过程:<br>3. DNS解析<br>4. TCP连接<br>5. 发送HTTP请求<br>6. 服务器处理请求并返回HTTP报文<br>7. 浏览器解析渲染页面<br>8. 连接结束<br>具体可以参考下面这篇文章：<br>3.3 各种协议与HTTP协议之间的关系<br>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。<br>图片来源：《图解HTTP》<br>3.4 HTTP长连接、短连接<br>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中<br>断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像<br>文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。<br>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客<br>户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时<br>间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。<br>—— 《HTTP长连接、短连接究竟是什么？》<br>3.5 TCP 三次握手和四次挥手(面试常客)<br>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。<br>漫画图解：<br>图片来源：《图解HTTP》<br>Connection:keep-alive<br>简单示意图：<br>客户端–发送带有 SYN 标志的数据包–一次握手–服务端<br>服务端–发送带有 SYN&#x2F;ACK 标志的数据包–二次握手–客户端<br>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端<br>为什么要三次握手?<br>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<br>双方确认自己与对方的发送与接收是正常的。<br>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常<br>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发<br>送正常<br>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，<br>对方发送接收正常<br>所以三次握手就能确认双发收发功能都正常，缺一不可。<br>为什么要传回 SYN<br>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。<br>SYN 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先<br>发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以<br>ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表<br>示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据<br>才可以在客户机和服务器之间传递。*传了 SYN,为啥还要传 ACK<br>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送<br>方的通道还需要 ACK 信号来进行验证。<br>断开一个 TCP 连接则需要“四次挥手”：<br>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送<br>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1<br>为什么要四次挥手<br>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送<br>的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。<br>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的<br>话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道<br>了”，这样通话才算结束。<br>上面讲的比较概括，推荐一篇讲的比较细致的文章：<br>四 Linux<br>4.1 简单介绍一下 Linux 文件系统？<br>Linux文件系统简介<br>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文<br>件或是目录都被看作是一个文件。<br>也就是说在LINUX系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而<br>来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬<br>件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。<br>文件类型与目录结构<br>Linux支持5种文件类型 ：<br>Linux的目录结构如下：<br>Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<br>常见目录说明：<br>&#x2F;bin： 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；<br>&#x2F;etc： 存放系统管理和配置文件；<br>&#x2F;home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以<br>用~user表示；<br>&#x2F;usr ： 用于存放系统应用程序；<br>&#x2F;opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；<br>&#x2F;proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；<br>&#x2F;root： 超级用户（系统管理员）的主目录（特权阶级~~^o^~~）；<br>&#x2F;sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程<br>序。如ifconfig等；<br>&#x2F;dev： 用于存放设备文件；<br>&#x2F;mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；<br>&#x2F;boot： 存放用于系统引导时使用的各种文件；<br>&#x2F;lib ： 存放着和系统运行相关的库文件 ；<br>&#x2F;tmp： 用于存放各种临时文件，是公用的临时文件存储点；<br>&#x2F;var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启<br>动日志等。）等；<br>&#x2F;lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在<br>这里。<br>4.2 一些常见的 Linux 命令了解吗？<br>目录切换命令<br>cd usr ： 切换到该目录下usr目录<br>cd ..（或cd..&#x2F;） ： 切换到上一层目录<br>cd &#x2F; ： 切换到系统根目录<br>cd ~ ： 切换到用户主目录<br>cd - ： 切换到上一个所在目录<br>目录的操作命令（增删改查）1. mkdir 目录名称 ： 增加目录<br>2. ls或者ll （ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息<br>3. find 目录 参数 ： 寻找目录（查）<br>4. mv 目录名称 新目录名称 ： 修改目录的名称（改）<br>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用<br>来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。<br>5. mv 目录名称 目录的新位置 ： 移动目录的位置—剪切（改）<br>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不<br>同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。<br>6. cp -r 目录名称 目录拷贝的目标位置 ： 拷贝目录（改），-r代表递归拷贝<br>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归<br>7. rm [-rf] 目录 : 删除目录（删）<br>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文<br>件，都直接使用 rm -rf 目录&#x2F;文件&#x2F;压缩包<br>文件的操作命令（增删改查）<br>8. touch 文件名称 : 文件的创建（增）<br>9. cat&#x2F;more&#x2F;less&#x2F;tail 文件名称 文件的查看（查）<br>cat ： 只能显示最后一屏内容<br>more ： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看<br>less ： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看<br>tail-10 ： 查看文件的后10行，Ctrl+C结束<br>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变<br>化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化<br>10. vim 文件 ： 修改文件的内容（改）<br>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐<br>述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。<br>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：<br>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输<br>入:wq&#x2F;q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）<br>11. rm -rf 文件 ： 删除文件（删）<br>同目录删除：熟记 rm -rf 文件 即可<br>压缩文件的操作命令<br>1）打包并压缩文件：<br>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令： tar -zcvf 打包压缩后的<br>文件名 要打包压缩的文件 其中：<br>z：调用gzip压缩命令进行压缩<br>c：打包文件<br>v：显示运行过程<br>f：指定文件名<br>比如：加入test目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt,如果我们要打包test目录并指定压缩后的压缩包名<br>称为test.tar.gz可以使用命令： tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt 或： tar -zcvf<br>test.tar.gz &#x2F;test&#x2F;<br>2）解压压缩包：<br>命令：tar [-xvf] 压缩文件<br>其中：x：代表解压<br>示例：<br>1 将&#x2F;test下的test.tar.gz解压到当前目录下可以使用命令： tar -xvf test.tar.gz<br>2 将&#x2F;test下的test.tar.gz解压到根目录&#x2F;usr下: tar -xvf xxx.tar.gz -C &#x2F;usr （- C代表指定解压的位置）<br>其他常用命令<br>pwd ： 显示当前所在位置<br>grep 要搜索的字符串 要搜索的文件 –color ： 搜索命令，–color代表高亮显示<br>ps -ef &#x2F; ps aux ： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看<br>特定的进程可以使用这样的格式： ps aux|grep redis （查看包括redis字符串的进程）<br>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的<br>状态。<br>kill -9 进程的pid ： 杀死进程（-9 表示强制终止。）<br>先用ps查找进程，然后用kill杀掉<br>网络通信命令：<br>查看当前系统的网卡信息：ifconfig<br>查看与某台机器的连接情况：ping<br>查看当前系统的端口使用：netstat -an<br>shutdown ： shutdown -h now ： 指定现在立即关机； shutdown +5 “System will shutdown after 5<br>minutes” :指定5分钟后关机，同时送出警告信息给登入用户。<br>reboot ： reboot ： 重开机。 reboot -w ： 做个重开机的模拟（只有纪录并不会真的重开机）。<br>五 MySQL<br>5.1 说说自己对于 MySQL 常见的两种存储引擎：MyISAM与<br>InnoDB的理解<br>关于二者的对比与总结:<br>12. count运算上的区别：因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好<br>的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。<br>13. 是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型<br>更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务<br>(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID<br>compliant))型表。<br>14. 是否支持外键： MyISAM不支持，而InnoDB支持。<br>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作<br>为主库的存储引擎。 一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以<br>当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压<br>缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择。<br>5.2 数据库索引了解吗？<br>系列思维导图源文件（数据库+架构）以及思维导图制作软件—XMind8 破解安装，公众号（JavaGuide）后台<br>回复：“思维导图” 免费领取！（下面的图片不是很清楚，原图非常清晰，另外提供给大家源文件也是为了大家<br>根据自己需要进行修改）<br>下面是我补充的一些内容<br>5.2.1 为什么索引能提高查询速度?<br>先从 MySQL 的基本存储结构说起<br>MySQL的基本存储结构是页(记录都存在页里边)：<br>各个数据页可以组成一个双向链表<br>每个数据页中的记录又可以组成一个单向链表<br>每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录<br>中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录<br>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。<br>所以说，如果我们写select * from user where indexname &#x3D; ‘xxx’这样没有进行任何优化的sql语句，默认会这样<br>做：<br>15. 定位到记录所在的页:需要遍历双向链表，找到所在的页<br>16. 从所在的页内中查找相应的记录:由于不是根据主键查询，只能遍历所在页的单链表了<br>很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。<br>使用索引之后<br>索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：<br>要找到id为8的记录简要步骤：<br>很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 “目录” 就可以很快地定位到对应的页<br>上了！（二分查找，时间复杂度近似为O(logn)）<br>其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。<br>以下内容整理自：《Java工程师修炼之道》<br>5.2.2 最左前缀原则<br>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是<br>(name,city)o而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以<br>被用到。如下：<br>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city&#x3D; xx and name ＝xx ，那么现在<br>的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的.<br>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。<br>ORDERBY子句也遵循此规则。<br>注意避免冗余索引<br>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两<br>个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而<br>不是创建新索引。<br>MySQLS.7 版本后，可以通过查询 sys 库的 schemal_r dundant_indexes 表来查看冗余索引<br>5.2.3 Mysql如何为表字段添加索引？？？<br>1.添加PRIMARY KEY（主键索引）<br>2.添加UNIQUE(唯一索引)<br>3.添加INDEX(普通索引)<br>4.添加FULLTEXT(全文索引)<br>5.添加多列索引<br>select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引<br>select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引<br>select * from user where city&#x3D;xx; &#x2F;&#x2F; 无法命中索引<br>ALTER TABLE <code>table_name</code> ADD PRIMARY KEY ( <code>column</code> )<br>ALTER TABLE <code>table_name</code> ADD UNIQUE ( <code>column</code> )<br>ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column</code> )<br>ALTER TABLE <code>table_name</code> ADD FULLTEXT ( <code>column</code>)<br>ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code> )<br>5.3 当MySQL单表记录数过大时，数据库的CRUD性能会明显下<br>降，一些常见的优化措施如下：<br>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：<br>17. 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时<br>候，我们可以控制在一个月的范围内。；<br>18. 读&#x2F;写分离： 经典的数据库拆分方案，主库负责写，从库负责读；<br>19. 垂直分区： 根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信<br>息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，<br>把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。<br>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简<br>化表的结构，易于维护。垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过<br>在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；<br>20. 水平分区： 保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达<br>到了分布式的目的。 水平拆分可以支撑非常大的数据量。 水平拆分是指数据表行的拆分，表的行数超过200万<br>行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多<br>个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。<br>水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的<br>数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。水平拆分能<br>够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。<br>《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂<br>度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择<br>客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。<br>下面补充一下数据库分片的两种常见方案：<br>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding￾JDBC 、阿里的TDDL是两种比较常用的实现。<br>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat<br>、360的Atlas、网易的DDB等等都是这种架构的实现。<br>5.4 事务隔离级别(图文详解)<br>什么是事务?<br>事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就<br>是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩<br>溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要<br>失败。<br>并发事务带来的问题<br>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操<br>作）。并发虽然是必须的，但可能会导致以下的问题。<br>脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这<br>时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个<br>事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<br>丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事<br>务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢<br>隔离级别 脏读 不可重复读 幻影读<br>READ-UNCOMMITTED √ √ √<br>READ-COMMITTED × √ √<br>REPEATABLE-READ × × √<br>SERIALIZABLE × × ×<br>失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最<br>终结果A&#x3D;19，事务1的修改被丢失。<br>不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务<br>也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的<br>数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<br>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发<br>事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就<br>好像发生了幻觉一样，所以称为幻读。<br>不可重复度和幻读区别：<br>不可重复读的重点是修改，幻读的重点在于新增或者删除。<br>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操<br>作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复<br>读。<br>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所<br>有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记<br>录就变为了5条，这样就导致了幻读。<br>6.3 为什么要用 redis 而不用 map&#x2F;guava 做缓存?<br>下面的内容来自 segmentfault 一位网友的提问，地址：<br>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是<br>轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓<br>存不具有一致性。<br>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致<br>性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。<br>6.6 redis 设置过期时间<br>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，<br>这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统<br>的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。<br>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的<br>时间。<br>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？<br>定期删除+惰性删除。<br>通过名字大概就能猜出这两个删除方式的意思了。<br>定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删<br>除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所<br>有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！<br>惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期<br>key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这<br>就是所谓的惰性删除，也是够懒的哈！<br>sinterstore key1 key2 key3 将交集存在key1内<br>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，<br>也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题<br>呢？<br>redis 内存淘汰机制。<br>6.11 如何解决 Redis 的并发竞争 Key 问题<br>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺<br>序不同，这样也就导致了结果的不同！<br>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问<br>题，不要使用分布式锁，这样会影响性能）<br>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的<br>与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有<br>序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁<br>无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。<br>在实践中，当然是从以可靠性为主。所以首推Zookeeper。<br>参考：<br>八 消息队列<br>“RabbitMQ？”“Kafka？”“RocketMQ？”…在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在<br>我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不<br>了解消息队列，本文都将带你搞懂消息队列的一些基本理论。如果你是老手，你可能从本文学到你之前不曾注意的一<br>些关于消息队列的重要概念，如果你是新手，相信本文将是你打开消息队列大门的一板砖。<br>8.1 什么是消息队列<br>我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队<br>列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前<br>使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ，我们后面会一一对比这些消息队列。<br>另外，我们知道队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者<br>发送消息1,2,3…对于消费者就会按照1,2,3…的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某<br>个消息消费失败又或者一个 queue 多个consumer 也会导致消息被消费的顺序不对，我们一定要保证消息被消费的<br>顺序正确。<br>除了上面说的消息消费顺序的问题，使用消息队列，我们还要考虑如何保证消息不被重复消费？如何保证消息的<br>可靠性传输（如何处理消息丢失的问题）？……等等问题。所以说使用消息队列也不是十全十美的，使用它也会让系<br>统可用性降低、复杂度提高，另外需要我们保障一致性等问题。<br>8.2 为什么要用消息队列<br>我觉得使用消息队列主要有两点好处：1.通过异步处理提高系统性能（削峰、减少响应所需时间）;2.降低系统耦<br>合性。如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，<br>这个时候推荐你结合你自己的项目来回答。<br>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。<br>(1) 通过异步处理提高系统性能（削峰、减少响应所需时间）<br>如上图，在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧<br>增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列<br>的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数<br>据库有更好的伸缩性），因此响应速度得到大幅改善。<br>通过以上分析我们可以得出消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事<br>务消息存储在消息队列中，从而削平高峰期的并发事务。 举例：在电子商务一些秒杀、促销活动中，合理使用消息<br>队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：<br>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中<br>可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单<br>数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚<br>至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。<br>(2) 降低系统耦合性<br>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展<br>性无疑更好一些。<br>我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下<br>图所示：<br>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅<br>消息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送<br>至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该<br>消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现<br>网站业务的可扩展性设计。<br>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接<br>受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。<br>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，<br>等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务<br>器集群中的其他服务器发布消息。<br>备注： 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。<br>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。 另外，<br>这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。<br>8.3 使用消息队列带来的一些问题<br>系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或<br>者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！<br>系统复杂性提高： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺<br>序性等等问题！<br>一致性问题： 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万<br>一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!<br>8.4 JMS VS AMQP<br>8.4.1 JMS<br>JMS 简介<br>JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的<br>消息传输。JMS（JAVA Message Service,Java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序<br>组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<br>ActiveMQ 就是基于 JMS 规范实现的。<br>JMS两种消息模型<br>①点到点（P2P）模型<br>使用队列<br>（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队<br>列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按<br>照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）<br>② 发布&#x2F;订阅（Pub&#x2F;Sub）模型<br>发布订阅模型（Pub&#x2F;Sub） 使用主题<br>（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一<br>条消息广播之后才订阅的用户则是收不到该条消息的。<br>JMS 五种不同的消息正文格式<br>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现<br>有消息格式的一些级别的兼容性。<br>StreamMessage – Java原始值的数据流<br>MapMessage–一套名称-值对<br>TextMessage–一个字符串对象<br>ObjectMessage–一个序列化的 Java对象<br>BytesMessage–一个字节的数据流<br>8.4.2 AMQP<br>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准 高级消息队列协议（二<br>进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消<br>息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。<br>RabbitMQ 就是基于 AMQP 协议实现的。<br>8.4.3 JMS vs AMQP<br>对<br>比<br>方<br>向<br>JMS AMQP<br>定<br>义<br>Java API 协议<br>跨<br>语<br>言<br>否 是<br>跨<br>平<br>台<br>否 是<br>支<br>持<br>消<br>息<br>类<br>型<br>提供两种消息模<br>型：①Peer-2-<br>Peer;②Pub&#x2F;sub<br>提供了五种消息模型：①direct exchange；②fanout exchange；③topic<br>change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的<br>pub&#x2F;sub模型没有太大差别，仅是在路由机制上做了更详细的划分；<br>支<br>持<br>消<br>息<br>类<br>型<br>支持多种消息类<br>型 ，我们在上面<br>提到过<br>byte[]（二进制）<br>总结：<br>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个<br>client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平<br>台、跨语言特性。<br>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可<br>序列化后发送）。<br>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队<br>列 和 主题&#x2F;订阅 方式两种。<br>8.5 常见的消息队列对比<br>对<br>比<br>方<br>向<br>概要<br>吞<br>吐<br>量<br>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的<br>RocketMQ 和 Kafka 低一个数量级。<br>可<br>用<br>性<br>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式<br>架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用<br>时<br>效<br>性<br>RabbitMQ 基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是<br>ms 级。<br>功<br>能<br>支<br>持<br>除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的MQ功能，在大数据领域<br>的实时计算以及日志采集被大规模使用，是事实上的标准<br>消<br>息<br>丢<br>失<br>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。<br>总结：<br>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使<br>用。<br>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，<br>性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做<br>erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列<br>中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，<br>绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。<br>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且<br>RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文<br>档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是<br>阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用<br>RocketMQ 挺好的<br>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用<br>性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。<br>kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及<br>日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</p><p>十 数据结构<br>数据结构比较常问的就是：二叉树、红黑树（很可能让你手绘一个红黑树出来哦！）、二叉查找树（BST）、平<br>衡二叉树（Self-balancing binary search tree）、B-树，B+树与B*树的优缺点比较、 LSM 树这些知识点。<br>数据结构很重要，而且学起来也相对要难一些。建议学习数据结构一定要循序渐进的来，一步一个脚印的走好。<br>一定要搞懂原理，最好自己能用代码实现一遍。<br>Queue<br>什么是队列<br>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们<br>生活中的排队类似。<br>队列的种类<br>单队列（单队列就是常见的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却<br>不能添加的情况）<br>循环队列（避免了“假溢出”的问题）<br>Java 集合框架中的队列 Queue<br>Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了<br>它。 Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。 除了继承 Collection 接口的一些<br>方法，Queue 还添加了额外的 添加、删除、查询操作。<br>推荐文章<br>Java 集合深入理解（9）：Queue 队列<br>Set<br>什么是 Set<br>Set 继承于 Collection 接口，是一个不允许出现重复元素，并且无序的集合，主要 HashSet 和 TreeSet 两大实现<br>类。<br>在判断重复元素的时候，Set 集合会调用 hashCode()和 equal()方法来实现。<br>补充：有序集合与无序集合说明<br>有序集合：集合里的元素可以根据 key 或 index 访问 (List、Map)<br>无序集合：集合里的元素只能遍历。（Set）<br>HashSet 和 TreeSet 底层数据结构<br>HashSet 是哈希表结构，主要利用 HashMap 的 key 来存储元素，计算插入元素的 hashCode 来获取元素在集合中<br>的位置；<br>TreeSet 是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；<br>推荐文章<br>Java集合–Set(基础)<br>List<br>什么是List<br>在 List 中，用户可以精确控制列表中每个元素的插入位置，另外用户可以通过整数索引（列表中的位置）访问元素，<br>并搜索列表中的元素。 与 Set 不同，List 通常允许重复的元素。 另外 List 是有序集合而 Set 是无序集合。<br>List的常见实现类<br>ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。<br>LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机<br>插入、随机删除效率高。<br>Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而<br>Vector是线程安全的。<br>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。相关阅读：java数据结构与算法之<br>栈（Stack）设计与实现<br>ArrayList 和 LinkedList 源码学习<br>ArrayList 源码学习<br>LinkedList 源码学习<br>推荐阅读<br>java 数据结构与算法之顺序表与链表深入分析<br>Map<br>集合框架源码学习之 HashMap(JDK1.8)<br>ConcurrentHashMap 实现原理及源码分析<br>树<br>1 二叉树<br>二叉树（百度百科）<br>(1)完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有<br>叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。<br>(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。<br>(3)平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它<br>是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>2 完全二叉树<br>完全二叉树（百度百科）<br>完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二<br>叉树<br>3 满二叉树<br>满二叉树（百度百科，国内外的定义不同）<br>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，<br>如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。<br>堆<br>数据结构之堆的定义<br>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结<br>点的值都小于或等于其左右孩子结点的值，称为小顶堆<br>4 二叉查找树（BST）<br>浅谈算法和数据结构: 七 二叉查找树<br>二叉查找树的特点：<br>61. 若任意节点的左子树不空，则左子树上所有结点的 值均小于它的根结点的值；<br>62. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>63. 任意节点的左、右子树也分别为二叉查找树。<br>64. 没有键值相等的节点（no duplicate nodes）。<br>5 平衡二叉树（Self-balancing binary search tree）<br>平衡二叉树（百度百科，平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等）<br>6 红黑树<br>红黑树特点:<br>65. 每个节点非红即黑；<br>66. 根节点总是黑色的；<br>67. 每个叶子节点都是黑色的空节点（NIL节点）；<br>68. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；<br>69. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）<br>红黑树的应用：<br>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。<br>为什么要用红黑树<br>简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。<br>详细了解可以查看 漫画：什么是红黑树？（也介绍到了二叉查找树，非常推荐）<br>推荐文章：<br>漫画：什么是红黑树？（也介绍到了二叉查找树，非常推荐）<br>寻找红黑树的操作手册（文章排版以及思路真的不错）<br>红黑树深入剖析及Java实现（美团点评技术团队）<br>7 B-，B+，B<em>树<br>二叉树学习笔记之B树、B+树、B</em>树<br>《B-树，B+树，B<em>树详解》<br>《B-树，B+树与B</em>树的优缺点比较》<br>B-树（或B树）是一种平衡的多路查找(又称排序)树，在文件系统中有所应用。主要用作文件的索引。其中的B<br>就表示平衡(Balance)<br>70. B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。<br>71. B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。<br>72. B<em>树 是B+树的变体，B</em>树分配新结点的概率比B+树要低，空间使用率更高；<br>8 LSM 树<br>[HBase] LSM树 VS B+树<br>B+树最大的性能问题是会产生大量的随机IO<br>为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。<br>LSM树由来、设计思想以及应用到HBase的索引<br>图<br>BFS及DFS<br>《使用BFS及DFS遍历树和图的思路及实现》<br>十一 算法<br>常见的加密算法、排序算法都需要自己提前了解一下，排序算法最好自己能够独立手写出来。<br>我觉得面试中最刺激、最有压力或者说最有挑战的一个环节就是手撕算法了。面试中大部分算法题目都是来自于<br>Leetcode、剑指offer上面，建议大家可以每天挤出一点时间刷一下算法题。<br>推荐两个刷题必备网站：<br>LeetCode：<br>LeetCode（中国）官网<br>如何高效地使用 LeetCode<br>牛客网：<br>牛客网首页<br>十二 实际场景题<br>我觉得实际场景题就是对你的知识运用能力以及思维能力的考察。建议大家在平时养成多思考问题的习惯，这样<br>面试的时候碰到这样的问题就不至于慌了。另外，如果自己实在不会就给面试官委婉的说一下，面试官可能会给你提<br>醒一下。切忌不懂装懂，乱答一气。 面试官可能会问你类似这样的问题：①假设你要做一个银行app，有<br>可能碰到多个人同时向一个账户打钱的情况，有可能碰到什么问题，如何解决（锁）②你是怎么保证你的代码质量和<br>正确性的？③下单过程中是下订单减库存还是付款减库存，分析一下两者的优劣；④同时给10万个人发工资，怎么样<br>设计并发方案，能确保在1分钟内全部发完。⑤如果让你设计xxx系统的话，你会如何设计。<br>十三 BATJ真实面试题<br>美团基础篇<br>73. System.out.println(3|9)输出什么?<br>正确答案：11.<br>考察知识点：&amp;和&amp;&amp;；|和||<br>&amp;和&amp;&amp;：<br>共同点：两者都可做逻辑运算符。它们都表示运算符的两边都是true时，结果为true；<br>不同点: &amp;也是位运算符。&amp; 表示在运算时两边都会计算，然后再判断；&amp;&amp;表示先运算符号左边的东西，然后判断是<br>否为true，是true就继续运算右边的然后判断并输出，是false就停下来直接输出不会再运行后面的东西。<br>|和||：<br>共同点：两者都可做逻辑运算符。它们都表示运算符的两边任意一边为true，结果为true，两边都不是true，结果就<br>为false；<br>不同点：|也是位运算符。| 表示两边都会运算，然后再判断结果；|| 表示先运算符号左边的东西，然后判断是否为<br>true，是true就停下来直接输出不会再运行后面的东西，是false就继续运算右边的然后判断并输出。<br>回到本题：<br>3 | 9&#x3D;0011（二进制） | 1001（二进制）&#x3D;1011（二进制）&#x3D;11（十进制）<br>74. 说一下转发(Forward)和重定向(Redirect)的区别<br>转发是服务器行为，重定向是客户端行为。<br>转发（Forword） 通过RequestDispatcher对象的 forward（HttpServletRequest<br>request,HttpServletResponse response） 方法实现的。 RequestDispatcher 可以通过 HttpServletRequest<br>的 getRequestDispatcher() 方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。<br>重定向（Redirect） 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状<br>态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者<br>302，则浏览器会到新的网址重新请求该资源。<br>request.getRequestDispatcher(“login_success.jsp”).forward(request, response);<br>75. 从地址栏显示来说: forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,<br>然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.<br>76. 从数据共享来说: forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.<br>77. 从运用地方来说: forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登<br>陆时返回主页面和跳转到其它的网站等<br>78. 从效率来说: forward:高. redirect:低.<br>79. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些<br>协议<br>图片来源：《图解HTTP》：<br>总体来说分为以下几个过程:<br>80. DNS解析<br>81. TCP连接<br>82. 发送HTTP请求<br>83. 服务器处理请求并返回HTTP报文<br>84. 浏览器解析渲染页面<br>85. 连接结束<br>具体可以参考下面这篇文章：<br>86. TCP 三次握手和四次挥手<br>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。<br>漫画图解：<br>图片来源：《图解HTTP》<br>简单示意图：<br>客户端–发送带有 SYN 标志的数据包–一次握手–服务端<br>服务端–发送带有 SYN&#x2F;ACK 标志的数据包–二次握手–客户端<br>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端<br>为什么要三次握手<br>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<br>双方确认自己与对方的发送与接收是正常的。<br>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。<br>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发<br>送正常<br>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，<br>对方发送接收正常<br>所以三次握手就能确认双发收发功能都正常，缺一不可。<br>为什么要传回 SYN<br>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。<br>SYN 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先<br>发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以<br>ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表<br>示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据<br>才可以在客户机和服务器之间传递。<br>传了 SYN,为啥还要传 ACK<br>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方（主动关闭方）到接收方（被动关闭方）的通<br>道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。<br>断开一个 TCP 连接则需要“四次挥手”：<br>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送<br>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1<br>为什么要四次挥手<br>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送<br>的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。<br>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的<br>话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道<br>了”，这样通话才算结束。<br>87. IP地址与MAC地址的区别<br>IP地址是指互联网协议地址（Internet Protocol Address）IP Address的缩写。IP地址是IP协议提供的一种统一的地<br>址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。<br>MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡<br>的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一<br>个唯一的MAC地址。<br>88. HTTP请求,响应报文格式<br>HTTP请求报文主要由请求行、请求头部、请求正文3部分组成<br>HTTP响应报文主要由状态行、响应头部、响应正文3部分组成<br>89. 为什么要使用索引?索引这么多优点,为什么不对表中的每一个列<br>创建一个索引呢?索引是如何提高查询速度的?说一下使用索引的注<br>意事项?Mysql索引主要使用的两种数据结构?什么是覆盖索引?<br>为什么要使用索引？<br>90. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>91. 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。<br>92. 帮助服务器避免排序和临时表<br>93. 将随机IO变为顺序IO<br>94. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？<br>95. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。<br>96. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索<br>引，那么需要的空间就会更大。<br>97. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>索引是如何提高查询速度的？<br>将无序的数据变成相对有序的数据（就像查目录一样）<br>说一下使用索引的注意事项<br>98. 避免 where 子句中对字段施加函数，这会造成无法命中索引。<br>99. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。<br>100.将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描<br>101.删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的<br>chema_unused_indexes 视图来查询哪些索引从未被使用<br>102.在使用 limit offset 查询缓慢时，可以借助索引来提高性能<br>Mysql索引主要使用的哪两种数据结构？<br>哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可<br>以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。<br>BTree索引：Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）<br>的实现方式是不同的。<br>更多关于索引的内容可以查看我的这篇文章：【思维导图-索引篇】搞定数据库索引就是这么简单<br>什么是覆盖索引?<br>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为“覆盖索引”。我们知道在InnoDB存储引<br>擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就<br>会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！<br>103.进程与线程的区别是什么?进程间的几种通信方式说一下?线程间<br>的几种通信方式知道不?<br>进程与线程的区别是什么？<br>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同<br>的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工<br>作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正是因为共享资源，所以线程中执<br>行时一般都要进行同步和互斥。总的来说，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。<br>进程间的几种通信方式说一下？<br>104.管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。<br>进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双<br>工的通信方式，但是它允许无亲缘关系进程间通信。<br>105.信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁<br>机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同<br>线程之间的同步手段。<br>106.消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消<br>息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信<br>相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件<br>接收特定类型的消息。<br>107.信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。<br>108.共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进<br>程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专<br>门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。<br>109.套接字（socket）：socket，即套接字是一种通信机制，凭借这种机制，客户&#x2F;服务器（即要进行通信的进程）<br>系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网<br>络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。<br>线程间的几种通信方式知道不？<br>1、锁机制<br>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。<br>读写锁：允许多个线程同时读共享数据，而对写操作互斥。<br>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行<br>的。条件变量始终与互斥锁一起使用。<br>2、信号量机制：包括无名线程信号量与有名线程信号量<br>3、信号机制：类似于进程间的信号处理。<br>线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。<br>110.为什么要用单例模式?手写几种线程安全的单例模式?<br>简单来说使用单例模式可以带来下面几个好处:<br>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统<br>开销；<br>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。<br>懒汉式(双重检查加锁版本)<br>public class Singleton {<br>&#x2F;&#x2F;volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理<br>uniqueInstance变量<br>private volatile static Singleton uniqueInstance;<br>private Singleton() {<br>}<br>public static Singleton getInstance() {<br>&#x2F;&#x2F;检查实例，如果不存在，就进入同步代码块<br>if (uniqueInstance &#x3D;&#x3D; null) {<br>&#x2F;&#x2F;只有第一次才彻底执行这里的代码<br>synchronized(Singleton.class) {<br>&#x2F;&#x2F;进入同步代码块后，再检查一次，如果仍是null，才创建实例<br>if (uniqueInstance &#x3D;&#x3D; null) {<br>uniqueInstance &#x3D; new Singleton();<br>}<br>}<br>}<br>return uniqueInstance;<br>}<br>}<br>静态内部类方式<br>静态内部实现的单例是懒加载的且线程安全。<br>只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用<br>这个单例的实例的时候才加载，同时不会有线程安全问题）。<br>public class Singleton {<br>private static class SingletonHolder {<br>private static final Singleton INSTANCE &#x3D; new Singleton();<br>}<br>private Singleton (){}<br>public static final Singleton getInstance() {<br>return SingletonHolder.INSTANCE;<br>}<br>}<br>美团进阶篇<br>1 消息队列MQ的套路<br>消息队列&#x2F;消息中间件应该是Java程序员必备的一个技能了，如果你之前没接触过消息队列的话，建议先去百度一下<br>某某消息队列入门，然后花2个小时就差不多可以学会任何一种消息队列的使用了。如果说仅仅学会使用是万万不够<br>的，在实际生产环境还要考虑消息丢失等等情况。关于消息队列面试相关的问题，推荐大家也可以看一下视频《Java<br>工程师面试突击第1季-中华石杉老师》，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关<br>键字“1”即可！<br>1.1 介绍一下消息队列MQ的应用场景&#x2F;使用消息队列的好处<br>面试官一般会先问你这个问题，预热一下，看你知道消息队列不，一般在第一面的时候面试官可能只会问消息队列<br>MQ的应用场景&#x2F;使用消息队列的好处、使用消息队列会带来什么问题、消息队列的技术选型这几个问题，不会太深究<br>下去，在后面的第二轮&#x2F;第三轮技术面试中可能会深入问一下。<br>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。<br>1)通过异步处理提高系统性能<br>如上图，在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使<br>得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费<br>者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有<br>更好的伸缩性），因此响应速度得到大幅改善。<br>通过以上分析我们可以得出消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消<br>息存储在消息队列中，从而削平高峰期的并发事务。 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列<br>可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：<br>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能<br>失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据<br>写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出<br>库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。<br>2)降低系统耦合性<br>我们知道模块分布式部署以后聚合方式通常有两种：1.分布式消息队列和2.分布式服务。<br>先来简单说一下分布式服务：<br>目前使用比较多的用来构建SOA（Service Oriented Architecture面向服务体系结构）的分布式服务框架是阿里巴<br>巴开源的Dubbo.<br>再来谈我们的分布式消息队列：<br>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无<br>疑更好一些。<br>我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所<br>示：<br>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消<br>息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至<br>分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消<br>息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网<br>站业务的可扩展性设计。<br>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者<br>订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。<br>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消<br>息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集<br>群中的其他服务器发布消息。<br>备注： 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，<br>比如在我们的ActiveMQ消息队列中还有点对点工作模式，具体的会在后面的文章给大家详细介绍，这一篇文章主要<br>还是让大家对消息队列有一个更透彻的了解。<br>这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重<br>视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！<br>1.2 那么使用消息队列会带来什么问题?考虑过这些问题吗?<br>系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或<br>者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！<br>系统复杂性提高： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺<br>序性等等问题！<br>一致性问题： 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万<br>一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!<br>了解下面这个问题是为了我们更好的进行技术选型！该部分摘自：《Java工程师面试突击第1季-中华石杉老<br>师》，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关键字“1”即可！<br>1.3 介绍一下你知道哪几种消息队列,该如何选择呢?<br>特性 ActiveMQ RabbitMQ RocketMQ Kafaka<br>单机<br>吞吐<br>量<br>万级，吞<br>吐量比<br>RocketMQ<br>和Kafka要<br>低了一个<br>数量级<br>万级，吞吐量比RocketMQ和<br>Kafka要低了一个数量级<br>10万级，RocketMQ也是可<br>以支撑高吞吐的一种MQ<br>10万级别，这是<br>kafka最大的优<br>点，就是吞吐量<br>高。一般配合大<br>数据类的系统来<br>进行实时数据计<br>算、日志采集等<br>场景<br>topic<br>数量<br>对吞<br>吐量<br>的影<br>响<br>topic可以达到几百，几千个<br>的级别，吞吐量会有较小幅<br>度的下降这是RocketMQ的<br>一大优势，在同等机器下，<br>可以支撑大量的topic<br>topic从几十个到<br>几百个的时候，<br>吞吐量会大幅度<br>下降。所以在同<br>等机器下，kafka<br>尽量保证topic数<br>量不要过多。如<br>果要支撑大规模<br>topic，需要增加<br>更多的机器资源<br>可用<br>性<br>高，基于<br>主从架构<br>实现高可<br>用性<br>高，基于主从架构实现高可用<br>性<br>非常高，分布式架构<br>非常高，kafka是<br>分布式的，一个<br>数据多个副本，<br>少数机器宕机，<br>不会丢失数据，<br>不会导致不可用<br>消息<br>可靠<br>性<br>有较低的<br>概率丢失<br>数据<br>经过参数优化配置，可以做<br>到0丢失<br>经过参数优化配<br>置，消息可以做<br>到0丢失<br>时效<br>性<br>ms级<br>微秒级，这是rabbitmq的一大<br>特点，延迟是最低的 ms级 延迟在ms级以内<br>功能<br>支持<br>MQ领域的<br>功能极其<br>完备<br>基于erlang开发，所以并发能<br>力很强，性能极其好，延时很<br>低<br>MQ功能较为完善，还是分<br>布式的，扩展性好<br>功能较为简单，<br>主要支持简单的<br>MQ功能，在大<br>数据领域的实时<br>计算以及日志采<br>集被大规模使<br>用，是事实上的<br>标准<br>特性 ActiveMQ RabbitMQ RocketMQ Kafaka<br>优劣<br>势总<br>结<br>非常成<br>熟，功能<br>强大，在<br>业内大量<br>的公司以<br>及项目中<br>都有应<br>用。偶尔<br>会有较低<br>概率丢失<br>消息，而<br>且现在社<br>区以及国<br>内应用都<br>越来越<br>少，官方<br>社区现在<br>对<br>ActiveMQ<br>5.x维护越<br>来越少，<br>几个月才<br>发布一个<br>版本而且<br>确实主要<br>是基于解<br>耦和异步<br>来用的，<br>较少在大<br>规模吞吐<br>的场景中<br>使用<br>erlang语言开发，性能极其<br>好，延时很低；吞吐量到万<br>级，MQ功能比较完备而且开<br>源提供的管理界面非常棒，用<br>起来很好用。社区相对比较活<br>跃，几乎每个月都发布几个版<br>本分在国内一些互联网公司近<br>几年用rabbitmq也比较多一些<br>但是问题也是显而易见的，<br>RabbitMQ确实吞吐量会低一<br>些，这是因为他做的实现机制<br>比较重。而且erlang开发，国<br>内有几个公司有实力做erlang<br>源码级别的研究和定制？如果<br>说你没这个实力的话，确实偶<br>尔会有一些问题，你很难去看<br>懂源码，你公司对这个东西的<br>掌控很弱，基本职能依赖于开<br>源社区的快速维护和修复<br>bug。而且rabbitmq集群动态<br>扩展会很麻烦，不过这个我觉<br>得还好。其实主要是erlang语<br>言本身带来的问题。很难读源<br>码，很难定制和掌控。<br>接口简单易用，而且毕竟在<br>阿里大规模应用过，有阿里<br>品牌保障。日处理消息上百<br>亿之多，可以做到大规模吞<br>吐，性能也非常好，分布式<br>扩展也很方便，社区维护还<br>可以，可靠性和可用性都是<br>ok的，还可以支撑大规模的<br>topic数量，支持复杂MQ业<br>务场景。而且一个很大的优<br>势在于，阿里出品都是java<br>系的，我们可以自己阅读源<br>码，定制自己公司的MQ，<br>可以掌控。社区活跃度相对<br>较为一般，不过也还可以，<br>文档相对来说简单一些，然<br>后接口这块不是按照标准<br>JMS规范走的有些系统要迁<br>移需要修改大量代码。还有<br>就是阿里出台的技术，你得<br>做好这个技术万一被抛弃，<br>社区黄掉的风险，那如果你<br>们公司有技术实力我觉得用<br>RocketMQ挺好的<br>kafka的特点其实<br>很明显，就是仅<br>仅提供较少的核<br>心功能，但是提<br>供超高的吞吐<br>量，ms级的延<br>迟，极高的可用<br>性以及可靠性，<br>而且分布式可以<br>任意扩展。同时<br>kafka最好是支撑<br>较少的topic数量<br>即可，保证其超<br>高吞吐量。而且<br>kafka唯一的一点<br>劣势是有可能消<br>息重复消费，那<br>么对数据准确性<br>会造成极其轻微<br>的影响，在大数<br>据领域中以及日<br>志采集中，这点<br>轻微影响可以忽<br>略这个特性天然<br>适合大数据实时<br>计算以及日志收<br>集。<br>这部分内容，我这里不给出答案，大家可以自行根据自己学习的消息队列查阅相关内容，我可能会在后面的文<br>章中介绍到这部分内容。另外，下面这些问题在视频《Java工程师面试突击第1季-中华石杉老师》中都有提<br>到，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关键字“1”即可！<br>1.4 关于消息队列其他一些常见的问题展望<br>115.引入消息队列之后如何保证高可用性<br>116.如何保证消息不被重复消费呢？<br>117.如何保证消息的可靠性传输（如何处理消息丢失的问题）？<br>118.我该怎么保证从消息队列里拿到的数据按顺序执行？<br>119.如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，<br>说说怎么解决？<br>120.如果让你来开发一个消息队列中间件，你会怎么设计架构？<br>3 聊聊 Java 中的集合吧!<br>3.1 Arraylist 与 LinkedList 有什么不同?(注意加上从数据结构分析的内容)<br>124.是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>125.底层数据结构： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（注意双向<br>链表和双向循环链表的区别：）；<br>126.插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素<br>位置的影响。 比如：执行 add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种<br>情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（ add(int index, E element) ）时<br>间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向<br>前移一位的操作。 ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是<br>近似 O（1）而数组为近似 O（n）。<br>127.是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通<br>过元素的序号快速获取元素对象(对应于 get(int index) 方法)。<br>128.内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空<br>间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数<br>据）。<br>补充内容:RandomAccess接口<br>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个<br>标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。<br>public interface RandomAccess {<br>}<br>在binarySearch（）方法中，它要判断传入的list 是否RamdomAccess的实例，如果是，调用<br>indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法<br>ArraysList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！<br>ArraysList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速<br>随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访<br>问。，ArraysList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标<br>识，并不是说 ArraysList 实现 RandomAccess 接口才具有快速随机访问功能的！<br>下面再总结一下 list 的遍历方式选择：<br>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,<br>未实现RandomAccess接口的ist， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size<br>的数据，千万不要使用普通for循环<br>Java 中的集合这类问题几乎是面试必问的，问到这类问题的时候，HashMap 又是几乎必问的问题，所以大家<br>一定要引起重视！<br>3.2 HashMap的底层实现<br>1)JDK1.8之前<br>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经<br>过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的时数组的<br>长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的<br>话，直接覆盖，不相同就通过拉链法解决冲突。<br>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的<br>hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。<br>JDK 1.8 HashMap 的 hash 方法源码:<br>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。<br>public static &lt;T&gt;<br>int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {<br>if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>return Collections.indexedBinarySearch(list, key);<br>else<br>return Collections.iteratorBinarySearch(list, key);<br>}<br>static final int hash(Object key) {<br>int h;<br>&#x2F;&#x2F; key.hashCode()：返回散列值也就是hashcode<br>&#x2F;&#x2F; ^ ：按位异或<br>&#x2F;&#x2F; &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐<br>return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}<br>对比一下 JDK1.7的 HashMap 的 hash 方法源码.<br>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。<br>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希<br>冲突，则将冲突的值加到链表中即可。<br>2)JDK1.8之后<br>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转<br>化为红黑树，以减少搜索时间。<br>static int hash(int h) {<br>&#x2F;&#x2F; This function ensures that hashCodes that differ only by<br>&#x2F;&#x2F; constant multiples at each bit position have a bounded<br>&#x2F;&#x2F; number of collisions (approximately 8 at default load factor).<br>h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>}<br>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为<br>二叉查找树在某些情况下会退化成一个线性结构。<br>问完 HashMap 的底层原理之后，面试官可能就会紧接着问你 HashMap 底层数据结构相关的问题！<br>3.3 既然谈到了红黑树,你给我手绘一个出来吧,然后简单讲一下自己对于红黑<br>树的理解<br>红黑树特点:<br>129.每个节点非红即黑；<br>130.根节点总是黑色的；<br>131.每个叶子节点都是黑色的空节点（NIL节点）；<br>132.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；<br>133.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）<br>红黑树的应用：<br>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。<br>为什么要用红黑树<br>简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。<br>3.4 红黑树这么优秀,为何不直接使用红黑树得了?<br>说一下自己对于这个问题的看法：我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，<br>红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，这费事啊。你说说我们引入红黑树就是<br>为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是<br>链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的<br>最好的一个值。<br>139.Object类有哪些方法?<br>这个问题，面试中经常出现。我觉得不论是出于应付面试还是说更好地掌握Java这门编程语言，大家都要掌握！<br>1.1 Object类的常见方法总结<br>Object类是一个特殊的类，是所有类的父类。它主要提供了以下11个方法：<br>public final native Class&lt;?&gt; getClass()&#x2F;&#x2F;native方法，用于返回当前运行时对象的Class对象，使用了<br>final关键字修饰，故不允许子类重写。<br>问完上面这个问题之后，面试官很可能紧接着就会问你“hashCode与equals”相关的问题。<br>1.2 hashCode与equals<br>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”<br>1.2.1 hashCode()介绍<br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在<br>哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函<br>数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将<br>对象的 内存地址 转换为整数之后返回。<br>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！<br>（可以快速找到所需要的对象）<br>1.2.2 为什么要有hashCode<br>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：<br>public native int hashCode() &#x2F;&#x2F;native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的<br>HashMap。<br>public boolean equals(Object obj)&#x2F;&#x2F;用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户<br>比较字符串的值是否相等。<br>protected native Object clone() throws CloneNotSupportedException&#x2F;&#x2F;naitive方法，用于创建并返回<br>当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() !&#x3D; x 为true，x.clone().getClass()<br>=&#x3D; x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生<br>CloneNotSupportedException异常。<br>public String toString()&#x2F;&#x2F;返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方<br>法。<br>public final native void notify()&#x2F;&#x2F;native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视<br>器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。<br>public final native void notifyAll()&#x2F;&#x2F;native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒<br>在此对象监视器上等待的所有线程，而不是一个线程。<br>public final native void wait(long timeout) throws InterruptedException&#x2F;&#x2F;native方法，并且不能<br>重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。<br>public final void wait(long timeout, int nanos) throws InterruptedException&#x2F;&#x2F;多了nanos参数，<br>这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。<br>public final void wait() throws InterruptedException&#x2F;&#x2F;跟之前的2个wait方法一样，只不过该方法一直等<br>待，没有超时时间这个概念<br>protected void finalize() throws Throwable { }&#x2F;&#x2F;实例被垃圾回收器回收的时候触发的操作<br>public native int hashCode();<br>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加<br>入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相<br>同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，<br>HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist<br>java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。<br>1.2.3 hashCode()与equals()的相关规定<br>140.如果两个对象相等，则hashcode一定也是相同的<br>141.两个对象相等,对两个对象分别调用equals方法都返回true<br>142.两个对象有相同的hashcode值，它们也不一定是相等的<br>143.因此，equals方法被覆盖过，则hashCode方法也必须被覆盖<br>144.hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何<br>都不会相等（即使这两个对象指向相同的数据）<br>1.2.4 为什么两个对象有相同的hashcode值,它们也不一定是相等的?<br>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。<br>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这<br>也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。<br>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断<br>是否真的相同。也就是说 hashcode 只是用来缩小查找成本。<br>&#x3D;&#x3D;与equals 的对比也是比较常问的基础问题之一！<br>1.3 &#x3D;&#x3D;与equals<br>&#x3D;&#x3D; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型&#x3D;&#x3D;比较的是<br>值，引用数据类型&#x3D;&#x3D;比较的是内存地址)<br>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：<br>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。<br>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，<br>则返回true(即，认为这两个对象相等)。<br>举个例子：<br>public class test1 {<br>public static void main(String[] args) {<br>String a &#x3D; new String(“ab”); &#x2F;&#x2F; a 为一个引用<br>String b &#x3D; new String(“ab”); &#x2F;&#x2F; b为另一个引用,对象的内容一样<br>String aa &#x3D; “ab”; &#x2F;&#x2F; 放在常量池中<br>String bb &#x3D; “ab”; &#x2F;&#x2F; 从常量池中查找<br>if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true<br>System.out.println(“aa&#x3D;&#x3D;bb”);<br>if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象<br>System.out.println(“a&#x3D;&#x3D;b”);<br>if (a.equals(b)) &#x2F;&#x2F; true<br>System.out.println(“aEQb”);<br>if (42 &#x3D;&#x3D; 42.0) { &#x2F;&#x2F; true<br>System.out.println(“true”);<br>说明：<br>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方<br>法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就<br>把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。<br>在【备战春招&#x2F;秋招系列5】美团面经总结进阶篇 （附详解答案） 这篇文章中，我们已经提到了一下关于<br>HashMap 在面试中常见的问题：HashMap 的底层实现、简单讲一下自己对于红黑树的理解、红黑树这么优<br>秀，为何不直接使用红黑树得了、HashMap 和 Hashtable 的区别&#x2F;HashSet 和 HashMap 区别。HashMap 和<br>ConcurrentHashMap 这俩兄弟在一般只要面试中问到集合相关的问题就一定会被问到，所以各位务必引起重<br>视！<br>2 ConcurrentHashMap 相关问题<br>2.1 ConcurrentHashMap 和 Hashtable 的区别<br>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。<br>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟<br>HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类<br>似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；<br>实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了<br>分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁<br>竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经<br>摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用<br>synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且<br>线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容<br>旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步<br>方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用<br>put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。<br>两者的对比图：<br>图片来源：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/chengxiao/p/6842045.html">http://www.cnblogs.com/chengxiao/p/6842045.html</a><br>HashTable:<br>}<br>}<br>}<br>JDK1.7的ConcurrentHashMap：<br>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：<br>2.2 ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现<br>JDK1.7(上面有示意图)<br>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的<br>数据也能被其他线程访问。<br>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。<br>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数<br>据。<br>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结<br>构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个<br>HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。<br>JDK1.8(上面有示意图)<br>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8<br>的结构类似，数组+链表&#x2F;红黑二叉树。<br>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br>5 Nginx<br>5.1 简单介绍一下Nginx<br>Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。 Nginx 主要提供反向代<br>理、负载均衡、动静分离(静态资源服务)等服务。下面我简单地介绍一下这些名词。<br>反向代理<br>谈到反向代理，就不得不提一下正向代理。无论是正向代理，还是反向代理，说到底，就是代理模式的衍生版本罢了<br>正向代理：某些情况下，代理我们用户去访问服务器，需要用户手动的设置代理服务器的ip和端口号。正向代<br>理比较常见的一个例子就是 VPN了。<br>反向代理： 是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内<br>部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。<br>通过下面两幅图，大家应该更好理解（图源：<a target="_blank" rel="noopener" href="http://blog.720ui.com/2016/nginx_action_05_proxy/%EF%BC%89%EF%BC%9A">http://blog.720ui.com/2016/nginx_action_05_proxy/）：</a><br>}<br>所以，简单的理解，就是正向代理是为客户端做代理，代替客户端去访问服务器，而反向代理是为服务器做代理，代<br>替服务器接受客户端请求。<br>负载均衡<br>在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集<br>群)共同完成工作任务，从而提高了数据的吞吐量。<br>Nginx支持的weight轮询（默认）、ip_hash、fair、url_hash这四种负载均衡调度算法，感兴趣的可以自行查阅。<br>负载均衡相比于反向代理更侧重的时将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大<br>于两台时才有意义。<br>动静分离<br>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以<br>后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。<br>5.2 为什么要用 Nginx?<br>这部分内容参考极客时间—Nginx核心知识100讲的内容。<br>如果面试官问你这个问题，就一定想看你知道 Nginx 服务器的一些优点吗。<br>Nginx 有以下5个优点：<br>145.高并发、高性能（这是其他web服务器不具有的）<br>146.可扩展性好（模块化设计，第三方插件生态圈丰富）<br>147.高可靠性（可以在服务器行持续不间断的运行数年）<br>148.热部署（这个功能对于 Nginx 来说特别重要，热部署指可以在不停止 Nginx服务的情况下升级 Nginx）<br>149.BSD许可证（意味着我们可以将源代码下载下来进行修改然后使用自己的版本）<br>5.3 Nginx 的四个主要组成部分了解吗?<br>这部分内容参考极客时间—Nginx核心知识100讲的内容。<br>Nginx 二进制可执行文件：由各模块源码编译出一个文件<br>Nginx.conf 配置文件：控制Nginx 行为<br>acess.log 访问日志： 记录每一条HTTP请求信息<br>error.log 错误日志:定位问题<br>写在最后<br>最后，再强调几点：<br>150.一定要谨慎对待写在简历上的东西，一定要对简历上的东西非常熟悉。因为一般情况下，面试官都是会根据你<br>的简历来问的； 2. 能有一个上得了台面的项目也非常重要，这很可能是面试官会大量发问的地方，所以在面试<br>之前好好回顾一下自己所做的项目；<br>151.和面试官聊基础知识比如设计模式的使用、多线程的使用等等，可以结合具体的项目场景或者是自己在平时是<br>如何使用的；<br>152.注意自己开源的Github项目，面试官可能会挖你的Github项目提问；<br>153.建议提前了解一下自己想要面试的公司的价值观，判断一下自己究竟是否适合这个公司。<br>另外，我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、<br>丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！<br>本文档由 SnailClimb 整理，文章大部分内容来源于本人的开源项目 JavaGuide，你可以把这个文档看做JavaGuide<br>的精简版，适合面试前的突击。更多精彩内容，欢迎关注我的公众号：JavaGuide。如需转载对应的文章，请附上下<br>面一段内容：<br>本文转载自 JavaGuide 地址：<br>我们眼中的哈希<br>在计算机领域中哈希涉及的范围非常广泛，而且是较长使用的一种算法和数据结构，对此我们在后端开发中不断地使用由jdk提供的方法进行使用。由于长时间的使用，很少人会去对里面的核心进行分析和学习。HashMap是通过一个Entry的数组实现的。而Entry的结构有三个属性，key，value，next。如果在c中，我们遇到next想到的必然是指针，其实在java这就是个指针。每次通过hashcode的值，来散列存储数据。今天就来看下那些对于一个专业的开发者而言必要了解的东西。<br>引用一句百度对于哈希算法的定义：哈希算法可以将任意长度的二进制值引用为较短的且固定长度的二进制值，把这个小的二进制值称为哈希值。<br>一、HashMap<br>HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。HashMap数组每一个元素的初始值都是Null。<br>HashMap的默认初始长度？为什么?<br>HashMap的初始化长度是16，负载因子是0.75，并且每次自动扩展或是手动初始化时，长度必须是2的幂。之所以选择16，是因为有效提供给key映射到index的Hash算法。从Key映射到HashMap数组的对应位置，会用到一个Hash函数。利用Key的HashCode值来做某种运算来达到一种尽可能均匀分布的Hash函数，这种算法采用的是位运算的方式实现,这也是初始化长度为16的另一个原因，使用16的长度可以比其他相对范围内的数值运算后出现的数更独立，减少了同一个数值出现的次数，实现了更均匀的结果。<br>如何进行位运算呢？有如下的公式（Length是HashMap的长度）：<br>index &#x3D; HashCode（Key） &amp; （Length - 1）<br>下面我们以值为“book”的Key来演示整个过程：<br>1.计算book的hashcode，结果为十进制的3029737，二进制的101110001110101110 1001。<br>2.假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111。<br>3.把以上两个结果做与运算，101110001110101110 1001 &amp; 1111 &#x3D; 1001，十进制是9，所以 index&#x3D;9。<br>可以说，Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位。<br>假设HashMap的长度是10，重复刚才的运算步骤：<br>HashCode：10 1110 0011 1010 1110 1001<br>Length-1：1001<br>Index： 1001<br>单独看这个结果，表面上并没有问题。我们再来尝试一个新的HashCode 101110001110101110 1011 ：<br>HashCode：10 1110 0011 1010 1110 1011<br>Length-1：1001<br>Index： 1001<br>让我们再换一个HashCode 101110001110101110 1111 试试 ：<br>HashCode：10 1110 0011 1010 1110 1111<br>Length-1：1001<br>Index： 1001<br>是的，虽然HashCode的倒数第二第三位从0变成了1，但是运算的结果都是1001。也就是说，当HashMap长度为10的时候，有些index结果的出现几率会更大，而有些index结果永远不会出现（比如0111）！<br>这样，显然不符合Hash算法均匀分布的原则。<br>反观长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。高并发下的HashMap<br>在高并发下使用HashMap，它的容量是有限的，所以HashMap会通过ReHash的方式进行扩容，使用ReHash能够使容量扩大本身的两倍。所以ReHash是在HashMap扩容时的一个步骤。当经过多次元素插入，使得HashMap达到一定的饱和度，key映射位置发生冲突的几率会逐渐增高。这个情况我们需要进行Resize，那么影响Resize的因素有两个：Capacity 初始长度 、LoadFactor 负载因子.<br>HashMap.Size &gt;&#x3D; Capacity * LoadFactor<br>1<br>HashMap的Resize经过两个步骤：<br>1.扩容：创建一个新的Entry空数组，长度是原来的两倍<br>2.ReHash：遍历原来的Entry数组，把所有的Entry重新Hash到新数组。因为长度扩大之后Hash的规则会发生变动，因此需要重新Hash。<br>回顾一下Hash公式： index &#x3D; HashCode（Key） &amp; （Length - 1）<br>当原数组长度为8时，Hash运算是和111B做与运算；新数组长度为16，Hash运算是和1111B做与运算。Hash结果显然不同。<br>Resize前的HashMap：Resize后的HashMap：ReHash的Java代码如下：<br>&#x2F;*** Transfers all entries from current table to newTable.<br>*&#x2F;<br>void transfer(Entry[] newTable, boolean rehash) {<br>int newCapacity &#x3D; newTable.length;<br>for (Entry&lt;K,V&gt; e : table) {<br>while(null !&#x3D; e) {<br>Entry&lt;K,V&gt; next &#x3D; e.next;<br>if (rehash) {<br>e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);<br>}<br>int i &#x3D; indexFor(e.hash, newCapacity);<br>e.next &#x3D; newTable[i];<br>newTable[i] &#x3D; e;<br>e &#x3D; next;<br>}<br>}<br>}<br>HashMap线程问题（参考JDK1.7）<br>上面的情况使用在单线程下是没有问题的，但是一旦使用在多线程中，那么就会出现破坏内部数据结构的链表数组。其中一些链接可能会丢失，或者形成了回路，从而导致数据结构不可用。在ConcurrentHashMap中是不会发生的,高并发的情况下使用这个集合类兼顾了线程安全和性能。为保证线程安全可以使用HashTable、collections、synchronizedMap。<br>内容包括:<br>1.Hashmap在插入元素过多的时候需要进行Resize，Resize的条件是 <br>HashMap.Size &gt;&#x3D; Capacity * LoadFactor。<br>2.Hashmap的Resize包含扩容和ReHash两个步骤，ReHash在并发的情况下可能会形成链表环。<br>原理：<br>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：<br>e &#x3D; Entry3 <br>next &#x3D; Entry2<br>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。线程B刚才的状态是：<br>e &#x3D; Entry3 <br>next &#x3D; Entry2<br>当执行到上面这一行时，显然 i &#x3D; 3，因为刚才线程A对于Entry3的hash结果也是3。我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：<br>e &#x3D; Entry2 <br>next &#x3D; Entry2<br>整体情况如图所示：接着是新一轮循环，又执行到红框内的代码行：e &#x3D; Entry2 <br>next &#x3D; Entry3<br>整体情况如图所示：接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：整体情况如图所示：第三次循环开始，又执行到红框的代码：e &#x3D; Entry3 <br>next &#x3D; Entry3.next &#x3D; null<br>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：newTable[i] &#x3D; Entry2 <br>e &#x3D; Entry3 <br>Entry2.next &#x3D; Entry3 <br>Entry3.next &#x3D; Entry2<br>链表出现了环形！<br>整体情况如图所示：此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！ConcurrentHashMap的出现确保了线程的安全且高效率<br>1.这里介绍的ConcurrentHashMap原理和代码，都是基于Java1.7的。在Java8中会有些许差别。<br>2.ConcurrentHashMap在对Key求Hash值的时候，为了实现Segment均匀分布，进行了两次Hash。有兴趣的朋友可以研究一下源代码。String中的HashCode（）<br>String类有个私有的实例字段hash表示这串哈希值，第一次调用的时候，字符串的哈希值会被计算并且赋值给Hash字段，之后再调用HashCode的方法直接取hash字段返回。算法中的方式是，以31为乘法算式中的因数，再和每个字符进行ASCII码对应值作运算。<br>public int hashCode() {<br>int h &#x3D; hash;<br>if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) {<br>char val[] &#x3D; value;for (int i &#x3D; 0; i &lt; value.length; i++) {<br>h &#x3D; 31 * h + val[i];<br>}<br>hash &#x3D; h;<br>}<br>return h;}<br>字符串哈希可以做很多事情，通常是类似于字符串判等，判回文之类的。<br>但是仅仅依赖于哈希值来判断其实是不严谨的，除非能够保证不会有哈希冲突，通常这一点很难做到。<br>就拿jdk中String类的哈希方法来举例，字符串”gdejicbegh”与字符串”hgebcijedg”具有相同的hashCode()返回值-801038016，并且它们具有reverse的关系。这个例子说明了用jdk中默认的hashCode方法判断字符串相等或者字符串回文，都存在反例。部分的原理来自数据算法与数据结构和程序员小灰的文章观点，针对某些原理本人进行一些个人的理解，大部分自己进行了深入的理解和探索。对某些问题进行了许多补充。学习是我们开始研究并且进行创造的基本需要，我们引用学习并且使用这些基础进行延伸的创造和提供价值，这是我们人类历史上进化的必需过程。Java中Lambda表达式的使用<br>Lambda表达式概述<br>Lambda表达式的本质只是一个”语法糖”,由编译器推断并帮我们转换包装为常规的代码,因此我们可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘。<br>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许我们通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。<br>Lambda表达式还增强了集合库。 Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及java.util.stream 包。 流(stream)就如同迭代器(iterator),但附加了许多额外的功能。 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。 在本文中,我们将从简单到复杂的示例中见认识lambda表达式和stream的强悍。<br>环境准备<br>如果还没有安装Java 8,那么我们应该先安装才能使用lambda和stream(译者建议在虚拟机中安装,测试使用)。 像NetBeans 和IntelliJ IDEA 一类的工具和IDE就支持Java 8特性,包括lambda表达式,可重复的注解,紧凑的概要文件和其他特性。Lambda表达式的语法<br>基本语法:<br>(parameters) -&gt; expression<br>或<br>(parameters) -&gt;{ statements; }Java lambda表达式的简单例子:&#x2F;&#x2F; 1. 不需要参数,返回值为 5<br>() -&gt; 5&#x2F;&#x2F; 2. 接收一个参数(数字类型),返回其2倍的值<br>x -&gt; 2 * x&#x2F;&#x2F; 3. 接受2个参数(数字),并返回他们的差值<br>(x, y) -&gt; x – y&#x2F;&#x2F; 4. 接收2个int型整数,返回他们的和<br>(int x, int y) -&gt; x + y&#x2F;&#x2F; 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)<br>(String s) -&gt; System.out.print(s)基本的Lambda例子<br>现在,我们已经知道什么是lambda表达式,让我们先从一些基本的例子开始。 在本节中,我们将看到lambda表达式如何影响我们编码的方式。 假设有一个玩家List ,程序员可以使用 for 语句 (“for 循环”)来遍历,在Java SE 8中可以转换为另一种形式:String[] atp &#x3D; {“Rafael Nadal”, “Novak Djokovic”,<br>“Stanislas Wawrinka”,<br>“David Ferrer”,”Roger Federer”,<br>“Andy Murray”,”Tomas Berdych”,<br>“Juan Martin Del Potro”};<br>List&lt;String&gt; players &#x3D; Arrays.asList(atp);&#x2F;&#x2F; 以前的循环方式<br>for (String player : players) {<br>System.out.print(player + “; “);<br>}&#x2F;&#x2F; 使用 lambda 表达式以及函数操作(functional operation)<br>players.forEach((player) -&gt; System.out.print(player + “; “));&#x2F;&#x2F; 在 Java 8 中使用双冒号操作符(double colon operator)<br>players.forEach(System.out::println);正如我们看到的,lambda表达式可以将我们的代码缩减到一行。 另一个例子是在图形用户界面程序中,匿名类可以使用lambda表达式来代替。 同样,在实现Runnable接口时也可以这样使用:&#x2F;&#x2F; 使用匿名内部类<br>btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() {<br>@Override<br>public void handle(ActionEvent event) {<br>System.out.println(“Hello World!”);<br>}<br>});&#x2F;&#x2F; 或者使用 lambda expression<br>btn.setOnAction(event -&gt; System.out.println(“Hello World!”));使用lambdas 来实现 Runnable接口 的示例:<br>Runnable就是一个函数式接口：他只有一个方法run()方法。<br>1、因为run()方法没有参数，所以 -&gt;前面的()中不需要声明形参<br>2、run返回的是void，所以不需要return。<br>3、-&gt;后面写的代码其实就是定义在run方法内的代码。因为此处代码只有一行，所以{}也可以省略。如果此处多与一行，则无法省略。&#x2F;&#x2F; 1.1使用匿名内部类<br>new Thread(new Runnable() {<br>@Override<br>public void run() {<br>System.out.println(“Hello world !”);<br>}<br>}).start();&#x2F;&#x2F; 1.2使用 lambda expression<br>new Thread(() -&gt; System.out.println(“Hello world !”)).start();&#x2F;&#x2F; 2.1使用匿名内部类<br>Runnable race1 &#x3D; new Runnable() {<br>@Override<br>public void run() {<br>System.out.println(“Hello world !”);<br>}<br>};&#x2F;&#x2F; 2.2使用 lambda expression<br>Runnable race2 &#x3D; () -&gt; System.out.println(“Hello world !”);&#x2F;&#x2F; 直接调用 run 方法(没开新线程哦!)<br>race1.run();<br>race2.run();Runnable 的 lambda表达式,使用块格式,将五行代码转换成单行语句。 接下来,在下一节中我们将使用lambdas对集合进行排序。<br>使用Lambdas排序集合<br>在Java中,Comparator 类被用来排序集合。 在下面的例子中,我们将根据球员的 name, surname, name 长度 以及最后一个字母。 和前面的示例一样,先使用匿名内部类来排序,然后再使用lambda表达式精简我们的代码。<br>在第一个例子中,我们将根据name来排序list。 使用旧的方式,代码如下所示:String[] players &#x3D; {“Rafael Nadal”, “Novak Djokovic”,<br>“Stanislas Wawrinka”, “David Ferrer”,<br>“Roger Federer”, “Andy Murray”,<br>“Tomas Berdych”, “Juan Martin Del Potro”,<br>“Richard Gasquet”, “John Isner”};&#x2F;&#x2F; 1.1 使用匿名内部类根据 name 排序 players<br>Arrays.sort(players, new Comparator&lt;String&gt;() {<br>@Override<br>public int compare(String s1, String s2) {<br>return (s1.compareTo(s2));<br>}<br>});使用lambdas,可以通过下面的代码实现同样的功能:&#x2F;&#x2F; 1.2 使用 lambda expression 排序 players<br>Comparator&lt;String&gt; sortByName &#x3D; (String s1, String s2) -&gt; (s1.compareTo(s2));<br>Arrays.sort(players, sortByName);&#x2F;&#x2F; 1.3 也可以采用如下形式:<br>Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2)));其他的排序如下所示。 和上面的示例一样,代码分别通过匿名内部类和一些lambda表达式来实现Comparator :&#x2F;&#x2F; 1.1 使用匿名内部类根据 surname 排序 players<br>Arrays.sort(players, new Comparator&lt;String&gt;() {<br>@Override<br>public int compare(String s1, String s2) {<br>return (s1.substring(s1.indexOf(“ “)).compareTo(s2.substring(s2.indexOf(“ “))));<br>}<br>});&#x2F;&#x2F; 1.2 使用 lambda expression 排序,根据 surname<br>Comparator&lt;String&gt; sortBySurname &#x3D; (String s1, String s2) -&gt;<br>( s1.substring(s1.indexOf(“ “)).compareTo( s2.substring(s2.indexOf(“ “)) ) );<br>Arrays.sort(players, sortBySurname);&#x2F;&#x2F; 1.3 或者这样,怀疑原作者是不是想错了,括号好多…<br>Arrays.sort(players, (String s1, String s2) -&gt;<br>( s1.substring(s1.indexOf(“ “)).compareTo( s2.substring(s2.indexOf(“ “)) ) )<br>);&#x2F;&#x2F; 2.1 使用匿名内部类根据 name lenght 排序 players<br>Arrays.sort(players, new Comparator&lt;String&gt;() {<br>@Override<br>public int compare(String s1, String s2) {<br>return (s1.length() - s2.length());<br>}<br>});&#x2F;&#x2F; 2.2 使用 lambda expression 排序,根据 name lenght<br>Comparator&lt;String&gt; sortByNameLenght &#x3D; (String s1, String s2) -&gt; (s1.length() - s2.length());<br>Arrays.sort(players, sortByNameLenght);&#x2F;&#x2F; 2.3 or this<br>Arrays.sort(players, (String s1, String s2) -&gt; (s1.length() - s2.length()));&#x2F;&#x2F; 3.1 使用匿名内部类排序 players, 根据最后一个字母<br>Arrays.sort(players, new Comparator&lt;String&gt;() {<br>@Override<br>public int compare(String s1, String s2) {<br>return (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));<br>}<br>});&#x2F;&#x2F; 3.2 使用 lambda expression 排序,根据最后一个字母<br>Comparator&lt;String&gt; sortByLastLetter &#x3D;<br>(String s1, String s2) -&gt;<br>(s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));<br>Arrays.sort(players, sortByLastLetter);&#x2F;&#x2F; 3.3 or this<br>Arrays.sort(players, (String s1, String s2) -&gt; (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1)));<br>就是这样,简洁又直观。 在下一节中我们将探索更多lambdas的能力,并将其与 stream 结合起来使用。<br>使用Lambdas和Streams<br>Stream是对集合的包装,通常和lambda一起使用。 使用lambdas可以支持许多操作,如 map, filter, limit, sorted, count, min, max, sum, collect 等等。 同样,Stream使用懒运算,他们并不会真正地读取所有数据,遇到像getFirst() 这样的方法就会结束链式语法。 在接下来的例子中,我们将探索lambdas和streams 能做什么。 我们创建了一个Person类并使用这个类来添加一些数据到list中,将用于进一步流操作。 Person 只是一个简单的POJO类:public class Person {private String firstName, lastName, job, gender;<br>private int salary, age;public Person(String firstName, String lastName, String job,<br>String gender, int age, int salary) {<br>this.firstName &#x3D; firstName;<br>this.lastName &#x3D; lastName;<br>this.gender &#x3D; gender;<br>this.age &#x3D; age;<br>this.job &#x3D; job;<br>this.salary &#x3D; salary;<br>}<br>&#x2F;&#x2F; Getter and Setter<br>&#x2F;&#x2F; . . . . .<br>}接下来,我们将创建两个list,都用来存放Person对象:List&lt;Person&gt; javaProgrammers &#x3D; new ArrayList&lt;Person&gt;() {<br>{<br>add(new Person(“Elsdon”, “Jaycob”, “Java programmer”, “male”, 43, 2000));<br>add(new Person(“Tamsen”, “Brittany”, “Java programmer”, “female”, 23, 1500));<br>add(new Person(“Floyd”, “Donny”, “Java programmer”, “male”, 33, 1800));<br>add(new Person(“Sindy”, “Jonie”, “Java programmer”, “female”, 32, 1600));<br>add(new Person(“Vere”, “Hervey”, “Java programmer”, “male”, 22, 1200));<br>add(new Person(“Maude”, “Jaimie”, “Java programmer”, “female”, 27, 1900));<br>add(new Person(“Shawn”, “Randall”, “Java programmer”, “male”, 30, 2300));<br>add(new Person(“Jayden”, “Corrina”, “Java programmer”, “female”, 35, 1700));<br>add(new Person(“Palmer”, “Dene”, “Java programmer”, “male”, 33, 2000));<br>add(new Person(“Addison”, “Pam”, “Java programmer”, “female”, 34, 1300));<br>}<br>};List&lt;Person&gt; phpProgrammers &#x3D; new ArrayList&lt;Person&gt;() {<br>{<br>add(new Person(“Jarrod”, “Pace”, “PHP programmer”, “male”, 34, 1550));<br>add(new Person(“Clarette”, “Cicely”, “PHP programmer”, “female”, 23, 1200));<br>add(new Person(“Victor”, “Channing”, “PHP programmer”, “male”, 32, 1600));<br>add(new Person(“Tori”, “Sheryl”, “PHP programmer”, “female”, 21, 1000));<br>add(new Person(“Osborne”, “Shad”, “PHP programmer”, “male”, 32, 1100));<br>add(new Person(“Rosalind”, “Layla”, “PHP programmer”, “female”, 25, 1300));<br>add(new Person(“Fraser”, “Hewie”, “PHP programmer”, “male”, 36, 1100));<br>add(new Person(“Quinn”, “Tamara”, “PHP programmer”, “female”, 21, 1000));<br>add(new Person(“Alvin”, “Lance”, “PHP programmer”, “male”, 38, 1600));<br>add(new Person(“Evonne”, “Shari”, “PHP programmer”, “female”, 40, 1800));<br>}<br>};现在我们使用forEach方法来迭代输出上述列表:System.out.println(“所有程序员的姓名:”);<br>javaProgrammers.forEach((p) -&gt; System.out.printf(“%s %s; “, p.getFirstName(), p.getLastName()));<br>phpProgrammers.forEach((p) -&gt; System.out.printf(“%s %s; “, p.getFirstName(), p.getLastName()));我们同样使用forEach方法,增加程序员的工资5%:System.out.println(“给程序员加薪 5% :”);<br>Consumer&lt;Person&gt; giveRaise &#x3D; e -&gt; e.setSalary(e.getSalary() &#x2F; 100 * 5 + e.getSalary());javaProgrammers.forEach(giveRaise);<br>phpProgrammers.forEach(giveRaise);另一个有用的方法是过滤器filter() ,让我们显示月薪超过1400美元的PHP程序员:System.out.println(“下面是月薪超过 $1,400 的PHP程序员:”)<br>phpProgrammers.stream()<br>.filter((p) -&gt; (p.getSalary() &gt; 1400))<br>.forEach((p) -&gt; System.out.printf(“%s %s; “, p.getFirstName(), p.getLastName()));我们也可以定义过滤器,然后重用它们来执行其他操作:&#x2F;&#x2F; 定义 filters<br>Predicate&lt;Person&gt; ageFilter &#x3D; (p) -&gt; (p.getAge() &gt; 25);<br>Predicate&lt;Person&gt; salaryFilter &#x3D; (p) -&gt; (p.getSalary() &gt; 1400);<br>Predicate&lt;Person&gt; genderFilter &#x3D; (p) -&gt; (“female”.equals(p.getGender()));System.out.println(“下面是年龄大于 24岁且月薪在$1,400以上的女PHP程序员:”);<br>phpProgrammers.stream()<br>.filter(ageFilter)<br>.filter(salaryFilter)<br>.filter(genderFilter)<br>.forEach((p) -&gt; System.out.printf(“%s %s; “, p.getFirstName(), p.getLastName()));&#x2F;&#x2F; 重用filters<br>System.out.println(“年龄大于 24岁的女性 Java programmers:”);<br>javaProgrammers.stream()<br>.filter(ageFilter)<br>.filter(genderFilter)<br>.forEach((p) -&gt; System.out.printf(“%s %s; “, p.getFirstName(), p.getLastName()));使用limit方法,可以限制结果集的个数:System.out.println(“最前面的3个 Java programmers:”);<br>javaProgrammers.stream()<br>.limit(3)<br>.forEach((p) -&gt; System.out.printf(“%s %s; “, p.getFirstName(), p.getLastName()));System.out.println(“最前面的3个女性 Java programmers:”);<br>javaProgrammers.stream()<br>.filter(genderFilter)<br>.limit(3)<br>.forEach((p) -&gt; System.out.printf(“%s %s; “, p.getFirstName(), p.getLastName()));排序呢? 我们在stream中能处理吗? 答案是肯定的。 在下面的例子中,我们将根据名字和薪水排序Java程序员,放到一个list中,然后显示列表:System.out.println(“根据 name 排序,并显示前5个 Java programmers:”);<br>List&lt;Person&gt; sortedJavaProgrammers &#x3D; javaProgrammers<br>.stream()<br>.sorted((p, p2) -&gt; (p.getFirstName().compareTo(p2.getFirstName())))<br>.limit(5)<br>.collect(toList());sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(“%s %s; %n”, p.getFirstName(), p.getLastName()));System.out.println(“根据 salary 排序 Java programmers:”);<br>sortedJavaProgrammers &#x3D; javaProgrammers<br>.stream()<br>.sorted( (p, p2) -&gt; (p.getSalary() - p2.getSalary()) )<br>.collect( toList() );sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(“%s %s; %n”, p.getFirstName(), p.getLastName()));如果我们只对最低和最高的薪水感兴趣,比排序后选择第一个&#x2F;最后一个 更快的是min和max方法:System.out.println(“工资最低的 Java programmer:”);<br>Person pers &#x3D; javaProgrammers<br>.stream()<br>.min((p1, p2) -&gt; (p1.getSalary() - p2.getSalary()))<br>.get()System.out.printf(“Name: %s %s; Salary: $%,d.”, pers.getFirstName(), pers.getLastName(), pers.getSalary())System.out.println(“工资最高的 Java programmer:”);<br>Person person &#x3D; javaProgrammers<br>.stream()<br>.max((p, p2) -&gt; (p.getSalary() - p2.getSalary()))<br>.get()System.out.printf(“Name: %s %s; Salary: $%,d.”, person.getFirstName(), person.getLastName(), person.getSalary())上面的例子中我们已经看到 collect 方法是如何工作的。 结合 map 方法,我们可以使用 collect 方法来将我们的结果集放到一个字符串,一个 Set 或一个TreeSet中:System.out.println(“将 PHP programmers 的 first name 拼接成字符串:”);<br>String phpDevelopers &#x3D; phpProgrammers<br>.stream()<br>.map(Person::getFirstName)<br>.collect(joining(“ ; “)); &#x2F;&#x2F; 在进一步的操作中可以作为标记(token)System.out.println(“将 Java programmers 的 first name 存放到 Set:”);<br>Set&lt;String&gt; javaDevFirstName &#x3D; javaProgrammers<br>.stream()<br>.map(Person::getFirstName)<br>.collect(toSet());System.out.println(“将 Java programmers 的 first name 存放到 TreeSet:”);<br>TreeSet&lt;String&gt; javaDevLastName &#x3D; javaProgrammers<br>.stream()<br>.map(Person::getLastName)<br>.collect(toCollection(TreeSet::new));Streams 还可以是并行的(parallel)。 示例如下:System.out.println(“计算付给 Java programmers 的所有money:”);<br>int totalSalary &#x3D; javaProgrammers<br>.parallelStream()<br>.mapToInt(p -&gt; p.getSalary())<br>.sum();我们可以使用summaryStatistics方法获得stream 中元素的各种汇总数据。 接下来,我们可以访问这些方法,比如getMax, getMin, getSum或getAverage:&#x2F;&#x2F;计算 count, min, max, sum, and average for numbers<br>List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);<br>IntSummaryStatistics stats &#x3D; numbers<br>.stream()<br>.mapToInt((x) -&gt; x)<br>.summaryStatistics();System.out.println(“List中最大的数字 : “ + stats.getMax());<br>System.out.println(“List中最小的数字 : “ + stats.getMin());<br>System.out.println(“所有数字的总和 : “ + stats.getSum());<br>System.out.println(“所有数字的平均值 : “ + stats.getAverage());OK,就这样,希望我们喜欢它!总结<br>在本文中,我们学会了使用lambda表达式的不同方式,从基本的示例,到使用lambdas和streams的复杂示例。 此外,我们还学习了如何使用lambda表达式与Comparator 类来对Java集合进行排序。Java注解详解<br>注解概述<br>定义：<br>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。<br>注解的作用：<br>编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】<br>代码分析：通过代码里标识的元数据对代码进行分析【使用反射】<br>编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】<br>一、为什么要学习注解呢？<br>在实际的项目中我们会使用大量的框架，很多框架就会使用大量的注解。学习注解能够使我们读懂别人的代码。我们也可以使用注解，自定义注解使我们的代码更清晰更整洁。<br>二、JDK注解。<br>1、@Override代表实现和覆盖父类的方法<br>2、@Deprecated代表这个方法已经过时<br>3、@SuppressWarnings()意思是忽略，这里是忽略这个deprecation过时的警告<br>  <br>package note.demo;public interface People {public String name();<br>public String age();<br>&#x2F;&#x2F;代表这个方法已经过时<br>@Deprecated<br>public void song();}package note.demo;public class ChilePeople implements People{<br>&#x2F;&#x2F;@Override代表实现和覆盖父类的方法<br>@Override<br>public String name() {<br>&#x2F;&#x2F; TODO Auto-generated method stub<br>return null;<br>}<code>@Override public String age() &#123; // TODO Auto-generated method stub return null; &#125; //@SuppressWarnings()意思是忽略，这里是忽略这个deprecation过时的警告 @SuppressWarnings(&quot;deprecation&quot;) @Override public void song() &#123; // TODO Auto-generated method stub People people = new ChilePeople(); //化了横线代表此方法已经过时 people.song(); &#125;</code>}<br>三、注解的分类。<br>1，按照运行机制划分<br>源码注解：注解只在源码中存在，编译成Class文件就不存在。<br>编译时注解:注解在源码和Class文件中都会存在注解信息。<br>运行时注解：在运行阶段还会起作用，甚至会影响运行逻辑的注解。比如很多第三方类库的自定义注解。<br>2、按照来源划分<br>   JDK注解、第三方注解、自定义的注解<br>3、元注解<br>   就是注解的注解<br>四、自定义注解<br>1、使用@interface关键字定义注解<br>2、成员的基本类型包括所有的基本类型和String,Class,Annotation,Enumeration<br>3、如果注解只有一个成员，成员名必须取名为value().<br>4、注解类可以没有成员，没有成员的注解类成为标识注解<br>5、@Target({ElementType.METHOD,ElementType.TYPE})表示注解的作用域（元注解）<br>6、@Retention(RetentionPolicy.RUNTIME) 注解的生命周期（元注解）<br>7、@Inherited 标识允许子注解来继承这个注解 （注意这里只能是继承不能是接口上使用，而且只能继承类上的注解，不能继承方法上的注解）（元注解）<br>8、@Documented 生成javadoc时会包含注解 （元注解）<br> <br>package note.demo;import java.lang.annotation.Documented;<br>import java.lang.annotation.ElementType;<br>import java.lang.annotation.Inherited;<br>import java.lang.annotation.Retention;<br>import java.lang.annotation.RetentionPolicy;<br>import java.lang.annotation.Target;&#x2F;&#x2F;表示注解的作用域METHOD方法上，TYPE类或接口<br>@Target({ElementType.METHOD,ElementType.TYPE})<br>&#x2F;&#x2F;生命周期，运行时<br>@Retention(RetentionPolicy.RUNTIME)<br>&#x2F;&#x2F;表示子注解可以继承<br>@Inherited<br>&#x2F;&#x2F;生成doc文档依然存在<br>@Documented<br>&#x2F;&#x2F;使用@interface关键字定义注解<br>public @interface CustomNoto {<br>&#x2F;**<br>* 成员的基本类型包括所有的基本类型和String,Class,Annotation,Enumeration<br>* *&#x2F;<br>String desc(); &#x2F;&#x2F;这个表示注解的成员，不是方法。成员必须是无参数，无异常<br>String author();<br>int age() default 18; &#x2F;&#x2F;可以用default给成员制定一个默认的值<br>}五、解析注解<br>通过反射来获取类，方法，接口，或成员上的运行时注解信息，从而实现动态控制程序运行时的逻辑。<br>反射是在运行时的，所以我们使用反射时解析，必须注解的生命周期是运行时。<br>package note.demo;import java.lang.reflect.Method;&#x2F;&#x2F;解析注解<br>public class ParseNoto {public static void main(String[] args) {<br>&#x2F;&#x2F; TODO Auto-generated method stub<br>&#x2F;&#x2F;第一步拿到类类型<br>try {<br>Class class1 &#x3D; Class.forName(“note.demo.ChilePeople”);<br>&#x2F;&#x2F;判断这个类型是否存在这个注解<br>boolean is &#x3D; class1.isAnnotationPresent(CustomNoto.class);<br>if (is &#x3D;&#x3D; true) {<br>CustomNoto noto &#x3D; (CustomNoto) class1.getAnnotation(CustomNoto.class);<br>System.out.println(noto.desc());<br>}</p><pre><code>    //解析方法上的注解
    Method[] methods = class1.getMethods();
    for (Method method : methods) &#123;
        boolean isx = method.isAnnotationPresent(CustomNoto.class);
        if (isx) &#123;
            CustomNoto cNoto = (CustomNoto)method.getAnnotation(CustomNoto.class);
            System.out.println(cNoto.age()+&quot;&quot;);
        &#125;
    &#125;
&#125; catch (ClassNotFoundException e) &#123;
    // TODO Auto-generated catch block
    e.printStackTrace();
&#125;
</code></pre><p>}一、JDK常用的包<br>　java.lang： 这个是系统的基础类，比如String、Math、Integer、System和Thread， 提供常用功能。<br>　java.io: 这里面是所有输入输出有关的类，比如文件操作等<br>　java.net: 这里面是与网络有关的类，比如URL,URLConnection等。<br>　java.util : 这个是系统辅助类，特别是集合类Collection,List,Map等。<br>　java.sql: 这个是数据库操作的类，Connection, Statememt，ResultSet等二、Get和Post的区别<br>1.get是从服务器上获取数据，post是向服务器传送数据，<br>2.get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。<br>3.get安全性非常低，post安全性较高。但是执行效率却比Post方法好。<br>4.在进行文件上传时只能使用post而不能是get。三、Java多态的具体体现<br>面向对象编程有四个特征：抽象，封装，继承，多态。<br>多态有四种体现形式：1. 接口和接口的继承。<br>2. 类和类的继承。<br>3. 重载。<br>4. 重写。<br>其中重载和重写为核心。<br>重载：重载发生在同一个类中，在该类中如果存在多个同名方<br>法，但是方法的参数类型和个数不一样，那么说明该方法被重<br>载了。重写：重写发生在子类继承父类的关系中，父类中的方法被子<br>类继承，方法名，返回值类型，参数完全一样，但是方法体不<br>一样，那么说明父类中的该方法被子类重写了。四、StringBuffer StringBuilder String 区别<br>String 字符串常量 不可变 使用字符串拼接时是不同的2个空间<br>StringBuffer 字符串变量 可变 线程安全 字符串拼接直接在字符串后追加<br>StringBuilder 字符串变量 可变 非线程安全 字符串拼接直接在字符串后追加1.StringBuilder执行效率高于StringBuffer高于String.<br>2.String是一个常量，是不可变的，所以对于每一次+&#x3D;赋值都会创建一个新的对象， StringBuffer和StringBuilder都是可变的，当进行字符串拼接时采用append方 法，在原来的基础上进行追加，所以性能比String要高，又因为StringBuffer 是 线程安全的而StringBuilder是线程非安全的，所以StringBuilder的效率高于 StringBuffer.<br>3.对于大数据量的字符串的拼接，采用StringBuffer,StringBuilder.五、Hashtable与HashMap的区别<br>HashMap不是线程安全的，HashTable是线程安全。<br>HashMap允许空（null）的键和值（key），HashTable则不允许。<br>HashMap性能优于Hashtable。Map<br>1.Map是一个以键值对存储的接口。Map下有两个具体的实现，分别是HashMap和HashTable.<br>2.HashMap是线程非安全的，HashTable是线程安全的，所以HashMap的效率高于HashTable.<br>3.HashMap允许键或值为空，而HashTable不允许键或值为空.六、九大隐式对象<br>输入&#x2F;输出对象： request response out<br>作用域通信对象： session application pageContext<br>Servlet 对象： page config<br>错误对象： exception七、Forword(请求转发)与Redirect(重定向)<br>1、从数据共享上<br>Forword是一个请求的延续，可以共享request的数据<br>Redirect开启一个新的请求，不可以共享request的数据<br>2、从地址栏<br>Forword转发地址栏不发生变化<br>Redirect转发地址栏发生变化八、JQurey总结<br>jquery是一个轻量级的js框架，具有跨浏览器的特性，兼容性好，<br>并且封装了很多工具，方便使用。<br>常用的有: 选择器 ，dom操作 ，ajax(ajax不能跨域) ，特效，工具类<br>九、XML和Json的特点<br>Xml特点：<br>　　1、有且只有一个根节点；<br>　　2、数据传输的载体<br>　　3、所有的标签都需要自定义<br>　　4、是纯文本文件<br>　　<br>Json（JavaScript Object Notation）特点：<br>　　json分为两种格式:json对象(就是在{}中存储键值对，键和值之间用冒号分隔，<br>键 值 对之间用逗号分隔);json数组(就是[]中存储多个json对象，json对象之间用逗号分隔)<br>（两者间可以进行相互嵌套）数据传输的载体之一区别：<br>　　传输同样格式的数据，xml需要使用更多的字符进行描述，<br>流行的是基于json的数据传输。<br>xml的层次结构比json更清晰。共同点：<br>xml和json都是数据传输的载体，并且具有跨平台跨语言的特性。<br>十、request.getSession()、reqeust.getSession(false)和 request.getSession(true)<br>getSession()&#x2F;getSession(true)：当session存在时返回该session，否则新建一个 session并返回该对象<br>getSession(false)：当session存在时返回该session，否则返回null十一、Page和PageContext的区别<br>Page是servlet对象；使用this关键字，它的作用范围是在同一页面。<br>PageContext是作用域通信对象；通常使用setAttribute()和getAttribute()来设置和获取存放对象的值。十二、Ajax总结<br>AJAX 全称： 异步JavaScript及 XML（Asynchronous JavaScript And XML）<br>Ajax的核心是JavaScript对象XmlHttpRequest(XHR)。Ajax的优点:<br>　　　　提高用户体验度(UE)<br>　　　　提高应用程序的性能<br>　　　　进行局部刷新<br>AJAX不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的 Web 应用程序的技术。1. 通过 AJAX，我们的 JavaScript 可使用JavaScript的XMLHttpRequest对象来直接与服务器进行通信。通过这个对象，我们的 JavaScript 可在不重载页面的情况与Web服务器交换数据，即可局部刷新。<br>2. AJAX 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面，减轻服务器的负担，提升站点的性能。<br>AJAX 可使因特网应用程序更小、更快，更友好，用户体验（UE）好。<br>3. Ajax是基于标准化并被广泛支持的技术，并且不需要插件和下载小程序十三、JSP9大隐视对象中四个作用域的大小与作用范围<br>四个作用域从大到小：appliaction&gt;session&gt;request&gt;page<br>application：全局作用范围，整个应用程序共享.生命周期为：应用程序启动到停止。<br>session：会话作用域，当用户首次访问时，产生一个新的会话，以后服务器就可以记 住这个会话状态。<br>request：请求作用域，就是客户端的一次请求。<br>page：一个JSP页面。<br>以上作用范围使越来越小， request和page的生命周期都是短暂的，他们之间的区别就是：一个request可以包含多个page页(include，forward)。十四、List,Set,Collection,Collections<br>1.List和Set都是接口，他们都继承于接口Collection,List是一个有序的可重复的集合，而Set的无序的不可重复的集合。Collection是集合的顶层接口，Collections是一个封装了众多关于集合操作的静态方法的工具类,因为构造方法是私有的，所以不能实例化。2.List接口实现类有ArrayList,LinkedList,Vector。ArrayList和Vector是基于数组实现的,所以查询的时候速度快，而在进行增加和删除的时候速度较慢LinkedList是基于链式存储结构，所以在进行查询的时候速度较慢但在进行增加和删除的时候速度较快。又因为Vector是线程安全的，所以他和ArrayList相比而言，查询效率要低。十五、java的基本数据类型<br>数据类型	大小<br>byte(字节)	1(8位)<br>shot(短整型) 2(16位)<br>int(整型)	4(32位)<br>long(长整型) 8(32位)<br>float(浮点型)	4(32位)<br>double(双精度)	8(64位)<br>char(字符型)	2(16位)<br>boolean(布尔型)	1位<br>附加：<br>String是基本数据类型吗?(String不是基本数据类型)<br>String的长度是多少，有限制?(长度受内存大小的影响)<br>二十、UE和UI的区别<br>UE 是用户体验度<br>UI 界面原型（用户界面）（相当于买房时用的模型）设计UI的作用：<br>1、帮助程序员工作（界面已由美工设计完成）<br>2、提前让用户对项目有个宏观的了解，知道效果是什么样子。二十一、osi七层模型<br>第一层：物理层<br>第二层：数据链路层<br>第三层：网络层<br>第四层：传输层<br>第五层：会话层<br>第六层：表示层<br>第七层：应用层二十二、线程和进程的区别<br>1.线程(Thread)与进程（Process）<br>进程定义的是应用程序与应用程序之间的边界，通常来说一个进程就代表一个与之对应的应用程序。不同的进程之间不能共享代码和数据空间，而同一进程的不同线程可以共享代码和数据空间。2.一个进程可以包括若干个线程，同时创建多个线程来完成某项任务，便是多线程。<br>3.实现线程的两种方式：继承Thread类，实现Runable接口<br>二十三、jvm的内存结构<br>java虚拟机的内存结构分为堆(heap)和栈(stack),堆里面存放是对象实例也就是new出来的对象。栈里面存放的是基本数据类型以及引用数据类型的地址。对于所谓的常量是存储在方法区的常量池里面。二十四、内存泄露和内存溢出<br>内存泄露 (memory leak)，是指应用程序在申请内存后，<br>无法释放已经申请的内存空间.一次内存泄露危害可以忽略，<br>但如果任其发展最终会导致内存溢出(out of memory).<br>如读取文件后流要进行及时的关闭以及对数据库连接的释放。内存溢出（out of memory）是指应用程序在申请内存时，<br>没有足够的内存空间供其使用。<br>如我们在项目中对于大批量数据的导入，采用分段批量提交的方式。<br>二十六、解析xml文件的几种技术<br>1、 解析xml的几种技术<br>1.dom4j<br>2.sax<br>3.jaxb<br>4.jdom<br>5.dom<br>1.dom4j<br>　　dom4j是一个Java的XML API，类似于jdom，用来读写XML文件的。dom4j是一个非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。<br>2.sax<br>SAX（simple API for XML）是一种XML解析的替代方法。相比于DOM，SAX是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。而且相比于DOM，SAX可以在解析文档的任意时刻停止解析，但任何事物都有其相反的一面，对于SAX来说就是操作复杂。<br>3.jaxb<br>JAXB（Java Architecture for XML Binding) 是一个业界的标准，是一项可以根据XML Schema产生Java类的技术。该过程中，JAXB也提供了将XML实例文档反向生成Java对象树的方法，并能将Java对象树的内容重新写到XML实例文档。从另一方面来讲，JAXB提供了快速而简便的方法将XML模式绑定到Java表示，从而使得Java开发者在Java应用程序中能方便地结合XML数据和处理函数。2、dom4j 与 sax 之间的对比：【注：必须掌握！】<br>dom4j不适合大文件的解析，因为它是一下子将文件加载到内存中，所以有可能出现内存溢出，<br>sax是基于事件来对xml进行解析的，所以他可以解析大文件的xml<br>也正是因为如此，所以dom4j可以对xml进行灵活的增删改查和导航，而sax没有这么强的灵活性<br>所以sax经常是用来解析大型xml文件，而要对xml文件进行一些灵活（crud）操作就用dom4j二十七、项目的生命周期<br>1.需求分析<br>2.概要设计<br>3.详细设计(用例图，流程图，类图)<br>4.数据库设计(powerdesigner)<br>5.代码开发（编写）<br>6.单元测试（junit 白盒测试）(开发人员)<br>svn版本管理工具(提交，更新代码，文档)<br>7.集成测试 （黑盒测试，loadrunner（编写测试脚本）(高级测试)）<br>8.上线试运行 （用户自己体验）<br>9.压力测试（loadrunner）<br>10.正式上线<br>11.维护二十八、OSCache的判断<br>Object obj &#x3D; CacheManager.getInstance().getObj(“oaBrandList”);<br>&#x2F;&#x2F;从缓存中取数据<br>if (null &#x3D;&#x3D; obj) {<br>obj &#x3D; brandDao.getBrandList();<br>&#x2F;&#x2F;如果为空再从数据库获取数据<br>&#x2F;&#x2F;获取之后放入缓存中<br>CacheManager.getInstance().putObj(“oaBrandList”, obj);<br>}<br>return (List&lt;OaBrand&gt;)obj;二十九、经常访问的技术网站<br>1.csdn(详细步骤的描述)<br>2.iteye(详细步骤的描述)<br>3.oschina（开源中国获取java开源方面的信息技术）<br>4.java开源大全 <a target="_blank" rel="noopener" href="http://www.open-open.com(获取java开源方面的信息技术)/">www.open-open.com(获取java开源方面的信息技术)</a><br>5.infoq(对java,php,.net等这些语言的一些最新消息的报道)三十、项目团队中交流的工具<br>飞秋(局域网) qq(局域网，外网)<br>RTX（局域网，外网）	邮箱 （局域网，外网）<br>三十一、平时浏览的书籍<br>实战经验：<br>　　*** in action(实战)<br>　　*** 深入浅出<br>　　*** 入门指南<br>思想基础:<br>　　大话设计模式 重构三十二、java Exception体系结构<br>java 异常是程序运行过程中出现的错误。Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中定义了许多异常类,分为两大类，错误Error和异常Exception。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常(非runtimeException)，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。1、Error与Exception<br>Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。<br>这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。 2、运行时异常和非运行时异常<br>运行时异常: 都是RuntimeException类及其子类异常： IndexOutOfBoundsException 索引越界异常<br>ArithmeticException：数学计算异常<br>NullPointerException：空指针异常<br>ArrayOutOfBoundsException：数组索引越界异常<br>ClassNotFoundException：类文件未找到异常<br>ClassCastException：造型异常（类型转换异常）这些异常是不检查异常（Unchecked Exception），程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的。</p><p>非运行时异常:是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如：<br>IOException、文件读写异常<br>FileNotFoundException：文件未找到异常<br>EOFException：读写文件尾异常<br>MalformedURLException：URL格式错误异常<br>SocketException：Socket异常<br>SQLException：SQL数据库异常三十三、session和cookie的区别<br>session是存储在服务器端，cookie是存储在客户端的，所以安全来讲session的安全性要比cookie高，然后我们获取session里的信息是通过存放在会话cookie里的sessionid获取的。又由于session是存放在服务器的内存中，所以session里的东西不断增加会造成服务器的负担，所以会把很重要的信息存储在session中，而把一些次要东西存储在客户端的cookie里，然后cookie确切的说分为两大类分为会话cookie和持久化cookie，会话cookie确切的说是，存放在客户端浏览器的内存中,所以说他的生命周期和浏览器是一致的，浏览器关了会话cookie也就消失了，然而持久化cookie是存放在客户端硬盘中，而持久化cookie的生命周期就是我们在设置cookie时候设置的那个保存时间，然后我们考虑一问题当浏览器关闭时session会不会丢失，从上面叙述分析session的信息是通过会话cookie的sessionid获取的，当浏览器关闭的时候会话cookie消失所以我们的sessionid也就消失了，但是session的信息还存在服务器端，这时我们只是查不到所谓的session但它并不是不存在。那么，session在什么情况下丢失，就是在服务器关闭的时候，或者是session过期(默认时间是30分钟)，再或者调用了invalidate()的或者是我们想要session中的某一条数据消失调用session.removeAttribute()方法，然后session在什么时候被创建呢，确切的说是通过调用getsession()来创建，这就是session与cookie的区别.<br>访问HTML页面是不会创建session,但是访问index.JSP时会创建session(JSP实际上是一个Servlet, Servlet中有getSession方法)<br>三十四、字节流与字符流的区别<br>stream结尾都是字节流，reader和writer结尾都是字符流<br>两者的区别就是读写的时候一个是按字节读写，一个是按字符。<br>实际使用通常差不多。<br>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。<br>只是读写文件，和文件内容无关的，一般选择字节流。三十五、final,finally,finalize 三者区别<br>Final是一个修饰符：<br>当final修饰一个变量的时候，变量变成一个常量，它不能被二次赋值<br>当final修饰的变量为静态变量（即由static修饰）时，必须在声明这个变	量的时候给它赋值<br>当final修饰方法时，该方法不能被重写<br>当final修饰类时，该类不能被继承<br>Final不能修饰抽象类，因为抽象类中会有需要子类实现的抽	象方法，（抽	象类中可以有抽象方法，也可以有普通方法，当一个抽象类中没有抽象方	法时，这个抽象类也就没有了它存在的必要）<br>Final不能修饰接口，因为接口中有需要其实现类来实现的方法<br>Finally：<br>Finally只能与try&#x2F;catch语句结合使用，finally语句块中的语句一定会执行，	并且会在return，continue，break关键字之前执行<br>finalize：<br>Finalize是一个方法，属于java.lang.Object类，finalize()方法是GC	（garbage collector垃圾回收）运行机制的一部分，finalize()方法是在	GC清理它所从	属的对象时被调用的<br>三十六、Io流的层次结构从流的方向<br>输入流 输出流从流的类型上<br>字符流字节流inputstream和outputstream都是抽象类它们下面的实现包括FileInputStream,BufferedInputStreamFileOutputStream,BufferedOutputStreamreader 和 writerFileReader,BufferedReader,StringReader<br>FileWriter,BufferedWriter,StringWriter,PrintWriter三十七、JAVA:<br>Java是面向对象的，跨平台的，它通过java虚拟机来进行跨平台操作，它可以进行自动垃圾回收的【c语言是通过人工进行垃圾回收】，java还会进行自动分配内存。【c语言是通过指定进行分配内存的】，只需要new一个对象，这个对象占用了多少空间，不需要我们来管，java虚拟机负责管这些，用完之后也不需要我们来释放，java虚拟机会自动释放三十八、JavaSE JavaEE JavaME区别<br>是什么：<br>Java SE&#x3D;Java Standard Edition&#x3D;j2se &#x3D; java 标准版<br>Java EE&#x3D;Java Enterprise Edition&#x3D;j2ee&#x3D; java 企业版<br>Java ME&#x3D;Java Mobile Edition&#x3D;j2me &#x3D; java移动版<br>特点：<br>SE主要用于桌面程序（swing）,控制台开发(main程序)。EE企业级开发(JSP,EJB,Spring MVC,Struts,hibernate,ibatis等)，<br>用于企业级软件开发，网络开发，web开发。ME嵌入式开发(手机,小家电，PDA)。[苹果的ios，黑莓]三者之间的关系：<br>Java SE（Java Platform, Standard Edition，Java标准版）就是基于JDK和JRE的。Java SE为Java EE提供了基础。Java EE除了基于我们这个所谓的Java SE外，还新加了企业应用所需的类库三十九、JDK JRE JVM的区别：<br>Jdk【Java Development ToolKit】就是java开发工具箱， JDK是整个JAVA的核心里边包含了jre，它除了包含jre之外还包含了一些javac的工具类，把java源文件编译成class文件，java文件是用来运行这个程序的，除此之外，里边还包含了java源生的API，java.lang.integer在rt的jar包里边【可以在项目中看到】，通过rt这个jar包来调用我们的这些io流写入写出等<br>JDK有以下三种版本：J2SE，standard edition，标准版，是我们通常用的一个版本<br>J2EE，enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序<br>J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序<br>Jre【Java Runtime Enviromental】是java运行时环境，那么所谓的java运行时环境，就是为了保证java程序能够运行时，所必备的一基础环境，也就是它只是保证java程序运行的，不能用来开发，而jdk才是用来开发的，所有的Java程序都要在JRE下才能运行。<br>包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。Jre里边包含jvm<br>Jvm：【Java Virtual Mechinal】因为jre是java运行时环境，java运行靠什么运行，而底层就是依赖于jvm，即java虚拟机，java虚拟机用来加载类文件，java中之所以有跨平台的作用，就是因为我们的jvm关系：<br>J2se是基于jdk和jre，<br>JDK是整个JAVA的核心里边包含了jre，<br>Jre里边包含jvm<br>四十、报错的状态码：<br>301 永久重定向<br>302 临时重定向<br>304 服务端 未改变<br>403 访问无权限<br>200 正常<br>404 路径<br>500 内部错误<br>四十一、协议以及默认的端口号<br>ftp 21文件传输协议<br>Pop3 110 它是因特网 <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1706.htm">http://baike.baidu.com/view/1706.htm</a>电子邮件 <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1524.htm">http://baike.baidu.com/view/1524.htm</a>的第一个离线 <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/113466.htm">http://baike.baidu.com/view/113466.htm</a>协议标准<br>Smtp 25 简单邮件传输协议<br>http 80 超文本传输协议<br>oracle 默认端口号1521<br>mysql默认端口号 3306<br>四十二、抽象类与接口的区别1.一个类只能进行单继承，但可以实现多个接口。2.有抽象方法的类一定是抽象类，但是抽象类里面不一定有抽象方法；<br>接口里面所有的方法的默认修饰符为public abstract，接口里的成员变 量默认的修饰符为 pulbic static final。 关系	接口和接口 继承<br>接口和抽象类抽象类实现接口<br>类和抽象类 类继承抽象类<br>类和类 继承<br>四十三、修饰符的作用<br>修饰符的作用范围:private default protected public<br>同一个类中 可以 可以 可以 可以<br>同一个包的类中 可以 可以 可以<br>不同包的子类中 可以 可以<br>不同包的类中 可以<br>四十四、onready和onload的区别<br>1.onready比onload先执行<br>2.onready是在页面解析完成之后执行，而onload是在页面所有元素加载后执行<br>3.onload只执行最后一个而onready可以执行多个。<br>参考：<br>1.执行时间 window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 <code>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 2.编写个数不同 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个 $</code>(document).ready()可以同时编写多个，并且都可以得到执行 3.简化写法 window.onload没有简化写法 <code>$(document).ready(function()&#123;&#125;)可以简写成$</code>(function(){}); 另外，需要注意一点，由于在<code>$(document).ready() 方法内注册的事件，只要DOM 就绪就会被执行，因此可能此时元素的关联文件未下载完。例如与图片有关的html 下载完毕，并且已经解析为DOM 树了，但很有可能图片还没有加载完毕，所以例如图片的高度和宽度这样的属性此时不一定有效。要解决这个问题，可以使用Jquery 中另一个关于页面加载的方法---load() 方法。Load() 方法会在元素的onload 事件中绑定一个处理函数。如果处理函数绑定给window 对象，则会在所有内容( 包括窗口、框架、对象和图像等) 加载完毕后触发，如果处理函数绑定在元素上，则会在元素的内容加载完毕后触发。 Jquery 代码如下： $</code>(window).load(function (){ &#x2F;&#x2F; 编写代码 });等价于JavaScript 中的以下代码 Window.onload &#x3D; function (){ &#x2F;&#x2F; 编写代码 }<br>四十五、switch默认接受的几种数据类型<br>Short, int, byte, char<br>四十六、request 跟session的区别<br>1.他们的生命周期不同，<br>request对应的是一次请求，<br>session对应的是一次会话<br>2.request占用资源比较少,相对来说缺乏持续性,<br>而session资源消耗比较大，所以通常使用request来保存信息<br>四十七、找到解决svn冲突方法<br>对于svn冲突，可以采用手工处理将冲突的部分进行整合，<br>之后备份最新整合后的文件，采用覆盖更新的方式处理完<br>冲突之后，再把最新整合后的文件进行提交。四十八、反射的描述<br>通过字符串可以动态创建java对象，并且可以动态访问方法，<br>属性等。<br>我们在项目中的时候封装过数据库jdbc的持久层，<br>其中就利用反射这项<br>技术来达到通用<br>和灵活的目的。<br>十一、Hibernate 中get 和 load的区别<br>加载方式：<br>　　　　load为延迟加载(返回的是一个只有id属性的代理,只有使用该对象属性时,才 发出sql语句)；<br>　　　　get为立即加载(执行时,会立即向数据库发出sql语句)<br>返回结果：<br>　　　　load检索不到记录时,会抛ObjectNotFoundException异常<br>　　　　get检索不到记录时,会返回null<br>十二、Hibernate、Ibatis、Jdbc三者的区别<br>Hibernate属于全自动， Ibatis属于半自动，Jdbc属于手动，从开发效率上讲hibernate较高，ibatis居中，jdbc较低，从执行效率上讲hibernate较低，ibatis居中，jdbc较高，因为jdbc是手工写sql语句，程序员对sql的控制能力更大，可以根据业务需要进行优化，而ibatis虽然也可以对sql进行优化，但是他里面将resultset封装为实体的过程中采用了反射机制所以一定程度上影响了性能，而hibernate因为高度封装所以开发效率相对较高，但正因为这个原因，所以程序员在对sql语句的控制和优化方面相对比较弱，而且在将resultset封装成实体的过程中也采用了反射机制，所以在性能方面较低<br>十三、Hibernate的运行原理<br>首先通过configuration去加载hibernate.cfg.xml这个配置文件，根据<br>配置文件的信息去创建sessionFactory,sessionFactory是线程安全的，<br>是一个session工厂，用来创建session,session是线程不安全的，相当于<br>jdbc的connection，最后通过session去进行数据库的各种操作，在进行操作<br>的时候通过transaction进行事务的控制。<br>十四、Hibernate五大核心（类&#x2F;接口）简述<br>1 .Configuration接口的作用是对Hibernate进行配置，以及对它进行启动。（加载 hibernate.cfg.xml）并创建一个SessionFactory对象。<br>2 .SessionFactory接口<br>SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建 Session对象。SessionFactory是线程安全的。<br>3 .Session接口<br>Session（会话）接口是Hibernate应用使用的主要接口。Session接口负责执行被持久化对象的CRUD操作(增删改查)。Session对象是非线程安全的。Session 相当于jdbc的connection<br>4 .Query与Criteria接口<br>总之Query和Criteria接口负责执行各种数据库查询。<br>5 .Transaction接口<br>Transaction（事务）负责操作相关的事务。<br>十五、Hibernate与JDBC的区别<br>1、hibernate和jdbc主要区别就是，hibernate先检索缓存中的映射对象( 即hibernate操作的是对象)，而jdbc则是直接操作数据库.<br>2、Hibernate是JDBC的轻量级的对象封装，它是一个独立的对象持久层框架。Hibernate可以用在任何JDBC可以使用的场合<br>3、Hibernate是一个和JDBC密切关联的框架，所以Hibernate的兼容性和JDBC驱动，和数据库都有一定的关系，但是和使用它的Java程序，和App Server没有任何关系，也不存在兼容性问题。<br>4、如果正确的使用JDBC技术,它的执行效率一定比hibernate要好,因为hibernate是基于jdbc的技术.<br>5、JDBC使用的是SQL语句，Hibernate使用的是HQL语句，但是HQL语句最终还会隐式转换成SQL语句执行。<br>十六、Hibernate中的两大配置文件<br><em>.hbm.xml：主键生成策略，映射关系，一对多，一对一的关系。<br>Hibernate.cfg.xml：方言(用哪个数据库)，数据库连接信息，包含</em>.hbm.xml内容，映射 文件，也可以配事务。<br>十七、Hibernate事务处理<br>开启事务 session.beginTransaction();<br>执行相关的操作，如果成功则session.getTransaction().commit();<br>执行操作失败则 session.getTransaction.rollback();<br>十八、Hibernate的三种状态以及状态的转换<br>Transient(临时)<br>new 一个初始化对象后，并没有在数据库里保存数据，处于临时状态；<br>Persistent(持久化)<br>当执行save()方法，调用session.close()方法之前，内存中的对象与数据库有 对应关系处于持久化状态；<br>Detached(托管&#x2F;游离)<br>　　　当执行session.close()之后，处于托管状态；<br>状态的转换<br>处于托管状态下，调用update()方法后，转换为持久化状态；<br>在持久化状态下，执行delete()方法后，转换为临时状态；<br>在未初始化对象之前，调用get(),load(),find(),iterate()之后，直接进入持久化 状态。<br>十九、分页步骤<br>①前台封装一个显示分页的组件<br>②查询总条数<br>③后台封装分页工具类，计算开始位置、结束位置、总页数<br>④后台写支持分页的sql语句<br>⑤前台包含分页组件，实现分页效果注意:<br>查询总条数的where和查询列表信息的where条件要保证一致。<br>二十、hibernate缓存概述<br>hibernate分为一级缓存即session缓存也叫事务级别的缓存以及<br>二级缓存sessionFactory即应用级别的缓存,还有查询缓存即三级缓存.<br>一级缓存的生命周期和session的生命周期保持一致，<br>hibernate默认就启用了一级缓存，<br>不能将其关闭，可以通过session.clear()和session.evict(object)来管理一级缓存。其中get,load,iterate都会使用一级缓存，一级缓存缓存的是对象。<br>二级缓存的生命周期和sessionFactory的生命周期保持一致，可以跨session,被多个session共享，hibernate3默认开启二级缓存,也可以手动开启并指定缓存插件如ehcache,oscache<br>等。二级缓存也只能缓存对象。<br>三级缓存也叫查询缓存，查询缓存是针对普通属性结果集的缓存,<br>对实体对象的结果集只缓存id。对query.list()起作用，query.iterate不起作用，也就是query.iterate不使用查询缓存二十一、Ssh的概述：<br>ssh是web开发中常见的一种框架<br>s-struts<br>s-spring<br>h-hibernate<br>其中struts在框架中充当控制器，实现MVC，主要用来处理用户的请求，和跳转页面。使项目结构清晰，开发者只需要关注业务逻辑的实现即可。<br>spring在ssh充当粘合剂，粘合struts-sping-hibernate，主要用来进行事物的控制，<br>hibernate-充当数据库持久层，主要用它来与数据库交互，提高开发效率，减轻程序员sql控制要求，而且hibernate通过反射机制，有灵活的映射性，还支持各种关系，一对一，一对多，多对多。<br>在进行ssh整合的时候，我们应该注意：1. Action继承于ActionSupport<br>引入struts-spring-plugin.jar包，从而完成struts和spring的整合<br>在struts2的action中注入service，保证service的名字和配置文件中的一致，并生成get,set方法<br>Dao层继承于hibernateDaoSupport<br>在dao层的配置文件中注入sessionFactory二十二、防止表单重复提交<br>针对于重复提交的整体解决方案：<br>1.用redirect来解决重复提交的问题<br>2.点击一次之后，按钮失效<br>3.通过loading<br>4.自定义重复提交过滤器<br>5.解决struts2重复提交<br>可以结合s:token标签来解决重复提交问题利用token的原理：<br>1.在前端的jsp页面中加入s:token标签，在访问该页面时就会生成<br>隐藏域，该隐藏域中包含一个随机生成的字符串，并把该字符串<br>存入session中2.在struts2的配置文件中加入token拦截器后，当正常访问action<br>的时候，会从session中取出该字符串，然后和页面隐藏域中提交<br>字符串做对比，如果一致则正常执行并删除session中存储的字符串。<br>二十五、拦截器的理解<br>什么是拦截器：<br>拦截器是AOP中的概念，它本身是一段代码，可以通过定义“织入点”，来指定拦截器的代码在“织入点”的前后执行，从而起到拦截的作用<br>正如上面 Struts2的Reference中讲述的，Struts2的Interceptor，其拦截的对象是Action代码，可以定义在Action代码之前或者之后执行拦截器的代码。<br>在项目中，我们经常用来拦截通过非正常程序而进行的访问<br>Struts2的拦截器和Servlet过滤器类似。在执行Action的execute方法之前，Struts2会首先执行在struts.xml中引用的拦截器，在执行完所有引用的拦截器的intercept方法后，会执行Action的execute方法。<br>其中intercept方法是拦截器的核心方法，所有安装的拦截器都会调用之个方法。在Struts2中已经在struts-default.xml中预定义了一些自带的拦截器，如timer、params等。如果在&lt;package&gt;标签中继承struts-default，则当前package就会自动拥有struts-default.xml中的所有配置。代码如下： &lt;package name&#x3D;”demo” extends&#x3D;”struts-default” &gt; … &lt;&#x2F;package&gt;<br>拦截器是Struts2框架的核心，它主要完成解析请求参数、将请求参数赋值给Action属性、执行数据校验、文件上传等工作<br>在struts-default.xml中有一个默认的引用，在默认情况下（也就是&lt;action&gt;中未引用拦截器时）会自动引用一些拦截器。struts2中默认的拦截器是defaultStack.<br>自定义拦截器需要特别注意的是不要忘记引入struts2默认的拦截器。为了实现某些操作，我们可以自定义拦截器，<br>自定义拦截器有三种方式定义。分别为实现Interceptor接口，继承抽象类AbstractInterceptor，继承MethodFilterInteceptor类。<br>拦截器在项目中的运用：<br>同时可以减轻代码冗余，提高重用率。<br>如果要求用户密码、权限等的验证，就可以用自定义的拦截器进行密码验证和权限限制。对符合的登入者才跳转到正确页面。<br>二十六、Spring融入框架<br>我们通过在web.xml中配置ContextLoaderListener这个监听器也加载<br>spring的配置文件，从而融入到项目框架中。<br>二十七、项目的部署方式<br>1、如果项目单独部署到tomcat中的时候，应该看tomcat中的server.xml;<br>2、如果和eclipse结合使用进行项目部署的时候，应该看eclipse里面的server.xml.数据库篇<br>二、数据库连接池<br>数据库连接池的优点运行原理:<br>在我们不使用数据库连接池的时候，每次访问数据库都需要创建连接，<br>使用完成之后需要释放关闭连接，而这样是很耗费资源的。当我们使用<br>数据库连接池的时候，在tomcat启动的时候就创建了指定数量的连接，<br>之后当我们程序使用的时候就直接从连接池里面取，而不需要创建，同理，<br>当我们使用完的时候也不需要关闭连接，而是将连接返回到连接池中，供<br>其他请求继续使用。DBCP：比较稳定。<br>C3P0: 性能比较高。<br>三、mysql的数据库导入导出<br>配置：<br>首先找到mysql的安装目录，进入bin目录下复制路径<br>将mysql的bin目录粘贴在计算机环境变量的path中<br>授权：<br>登录mysql<br>将某张表的某个权限赋给某个用户<br>grant [select,insert,update,delete,create,drop] on [databaseName].[tableName]to [userName]@[userIP] identified by [‘连接口令’]<br>grant select,insert,update,delete,create,drop on oa_ssh.user to root@[IP] identified by ‘root’;<br>将所有库的所有权限赋给某个用户<br>grant all privileges on <em>.</em> to [userName]@[userIp] identified by [‘连接口令’]<br>grant all privileges on <em>.</em> to root@[IP] identified by ‘root’;<br>将所有库的所有权限赋给所有用户<br>　　　　grant all privileges on <em>.</em> to root@’%’ identified by ‘root’;　　　　导出本地数据库：<br>　　　　mysqldump -u 用户名 -p 数据库名 &gt; 磁盘：导出的文件名(加后缀)<br>　　　　远程导出数据库：<br>　　　　mysqldump -h IP -u 用户名 -p 数据库名称 &gt;导出的文件名(加后缀)<br>　　　　远程导出数据表：<br>　　　　mysqldump -u root -p -d –add-drop-table 数据库名称 &gt; 导出文件<br>名(加后缀)　　　　导入数据：<br>　　　　mysql -u root -p登录成功后 &#x3D;&#x3D;》 source 磁盘：导入的文件名(加后缀)四、jdbc分段批量提交的时候出现异常怎么处理?<br>通过Map来解决性能问题。首先在分段批量提交的时候，我们不采用事务，这样就保证了合法的数据就自动提交，不合法的数据就自己自动进行回滚，为了避免不合法数据影响后续合法数据的提交，采用定义业务规则字典表，实现对数据的验证，将不合法的数据记录下来，供用户进行后续处理，而合法的数据就全部提交。五、jdbc批量处理数据<br>批量处理数据:(代码优化:提高程序执行性能)降低了java程序代码(客户端)和数据库之间的 网络通信的次数。在jdbc中进行批量插入的核心API为 addBatch,executeBatch大数据量的插入问题:（jdbc,hibernate,ibatis）1.每次只插入一条和数据库交互多次(很耗时间)2.批量插入和数据库只交互一次(内存溢出)3.分段批量插入(推荐)jdbc批量处理数据是通过PreparedStatement对象的 addbatch(), executebatch（） clearbatch()进行和数据库的交互。通常我们使用分段批量处理的方式 这样可以提高程序的性能 ，防止内存溢出。　1.每个sql语句都和数据库交互一次(非批量操作)<br>　2.只和数据库交互一次(批量操作)(内存溢出)<br>　当数据达到一定额度的时候就和数据库进行交互，分多次进行(分段批量操作)<br>　 (500或者1000)<br>pst.addBatch();<br>if (i &gt; 0 &amp;&amp; i%1000 &#x3D;&#x3D; 0) {<br>pst.executeBatch();<br>pst.clearBatch();<br>}六、Oracle分页<br>select * from (select * from (select s.*,rownum rn from student s ) where rn&lt;&#x3D;5) where rn&gt;0七、Oracle的基本数据类型<br>Oracle的基本数据类型（常用）：1、字符型<br>Char 固定长度字符串 占2000个字节<br>Varchar2 可变长度字符串 占4000个字节<br>Nvarchar2 占2000个字符（最多能存2000个字母&#x2F;中文）<br>2、大对象型（lob）<br>Blob ：二进制数据 最大长度4G<br>Blob 用于存一些图片，视频，文件。<br>比如：当我们在进行文件上传时，我们一般把上传的文件存在硬盘上，可以不占用 数据库，下载时，如果项目迁移时，文件也要跟着迁移。因此我们可以把用blob把它存在数据库中。但这样也增加了数据库的负担。<br>Clob ：字符数据 最大长度4G，可以存大字符串 varchar2和nvarchar2都具有一定的局限性，它们长度有限，但数据库中无论用varchar2或nvarchar2类型，还是用clob，在java端都使用String接收。<br>3、数值型<br>Integer 整数类型，小的整数。<br>Float 浮点数类型。<br>Real 实数类型。<br>Number（p,s）包含小数位的数值类型。P表示精度，s表示小数后的位数。<br>Eg: number(10,2) 表示小数点之前可有8位数字，小数点后有2位。<br>4、日期类型<br>Date 日期（日-月-年） DD-MM-YY(HH-MI-SS)<br>Timestamp 跟date比 它可以精确到微秒。精确范围0~9 默认为6.八、id、rowid、rownum的区别<br>rowid物理位置的唯一标识。<br>而id是逻辑上的唯一标识，所以rowid查找速度要快于id,是目前最快的<br>定位一条记录的方式<br>rowid和rownum都是”伪数列”<br>所谓“伪数列”也就是默认隐藏的一个数列。<br>rownum用于标记结果集中结果顺序的一个字段，<br>它的特点是按顺序标记，而且是连续的，<br>换句话说就是只有有rownum&#x3D;1的记录，才可能有rownum&#x3D;2的记录。<br>rownum关键字只能和&lt;或者&lt;&#x3D;直接关联<br>如果是&gt;或者&#x3D;则需要给他起个别名<br>九、主键和唯一索引的区别？<br>在创建主键的同时会生成对应的唯一索引，主键在保证数据唯一性的同时不允许为 空，而唯一可以有一个为空数据项，一个表中只能有一个主键，但是一个主键可以 有多个字段，一个表中可以有多个唯一索引。十、Preparedstatement和statement的区别<br>用Prepared statement进行开发。Prepared statement是预编译的，而statement不是，在每次执行sql语句的增删改时，如果是一条数据两者没差距，但如果数据量大于1，那么每次执行sql语句statement都要重新编译一次，而Prepared statement不用，Prepared statement的运行效率大于statement；从代码的可维护性和可读性来说，虽然用Prepared statement来代替statement会使代码多出几行，但这样的代码无论从可读性还是可维护性来说，都比直接使用statement的代码高很多档次；最重要的一点，从安全角度来说，使用Prepared statement可以大大提高程序的安全性，因为Prepared statement是用‘？’传参,可以防止sql注入，具有安全性，而statement用的是‘+’字符串拼接，安全性较低。<br>十二、视图概述<br>视图可以视为“虚拟表”或“存储的查询”<br>创建视图所依据的表称为“基表”<br>视图的优点：<br>提供了另外一种级别的表安全性:隐藏了一些关键的字段<br>简化的用户的SQL命令<br>隔离基表结构的改变十三、存储过程概述<br>存储过程（Stored Procedure）<br>　　可以包含逻辑判断的sql语句集合。<br>　　是经过预编译，存在于数据库中。<br>　　通过调用指定存储过程的名字（可有参，可无参）来执行。<br>优点：<br>　　简化了复杂的业务逻辑，根据需要可重复使用<br>　　屏蔽了底层细节，不暴露表信息即可完成操作<br>　　降低网络的通信量，多条语句可以封装成一个存储过程来执行<br>　　设置访问权限来提高安全性<br>　　提高执行效率，因为它是预编译以及存储在数据库中<br>缺点：<br>　　可移植性差，相同的存储过程并不能跨多个数据库进行操作<br>　　大量使用存储过程后，首先会使服务器压力增大，而且维护难度逐渐增加存储过程的语法：--下面是在oracle数据库下最基本的语法<br>--仅创建一个名为testProcedure 的无参的存储过程<br>--IS也可以是AS<br>--如果已经存在名为 testProcedure 的存储过程，下面的语法会出现 名称已被使用的错误<br>--解决办法：<br>--第一句可以写成 create or replace procedure testProcedure<br>--这样会替换原有的存储过程<br>--NULL表示任何可以正确执行的sql 语句，但至少一句create procedure testProcedure<br>IS<br>BEGINNULLEND;存储过程的参数的分类:<br>IN<br>OUT<br>INOUT注意：<br>　　存储过程之间可相互调用<br>　　存储过程一般修改后，立即生效。十四、索引概述1、索引的概念<br>索引就是为了提高数据的检索速度。<br>数据库的索引类似于书籍的索引。<br>在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。<br>在数据库中，索引也允许数据库程序迅速地找到表中的数据，<br>而不必扫描整个数据库.2、索引的优点<br>　　1.创建唯一性索引，保证数据库表中每一行数据的唯一性<br>　　2.大大加快数据的检索速度，这也是创建索引的最主要的原因<br>　　3.减少磁盘IO（向字典一样可以直接定位）<br>3、索引的缺点<br>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加<br>2.索引需要占用额外的物理空间<br>3.当对表中的数据进行增加、删除和修改的时候，<br>索引也要动态的维护，降低了数据的维护速度<br>4、索引的分类<br>　　1.普通索引和唯一性索引<br>　　普通索引：CREATE INDEX mycolumn_index ON mytable (myclumn)<br>　　唯一性索引：保证在索引列中的全部数据是唯一的<br>　　CREATE unique INDEX mycolumn_index ON mytable (myclumn)<br>　　<br>2. 单个索引和复合索引<br>　　单个索引：对单个字段建立索引<br>　　复合索引：又叫组合索引，在索引建立语句中同时包含多个字段名，<br>　　最多16个字段<br>　　CREATE INDEX name_index ON userInfo(firstname,lastname)<br>　　<br>3.顺序索引，散列索引,位图索引十五、必背的sql语句<br>1：oracle 分页 select * from (select t.<em>, rownum rn from (select * from menu order by id desc) t where rownum &lt; 10) where rn &gt;&#x3D;52: mysql 分页 select * from music where id limit 5,53：oracle中如何快速将一张表的数据复制到另外一张表中(另外一张表不存在，另外一张 表存在，但数据为空)<br>1、.不存在另一张表时：<br>create table 新表 as select * from 将要复制的表<br>2、存在另一张表时：<br>insert into 新表名 select 字段 from 将要复制的表名4：音乐专辑查询出special <a href="app:ds:special">app:ds:special</a>表中的id 专辑名 并下面有多少首歌曲 Select s.id , min(s.sname),count(m.mid) from special s inner<br>join ms m on s.id&#x3D;m.id group by s.id 5：快速删除一张表（不可事物回滚，也就是没有日志记录） TRUNCATE from 表名6：inner joinselect 查找信息 from 表名 1 inner join 表名2 on 表名1.列名 &#x3D; 表名2.列名7：left join左外连接select 查找信息 from 表名1 left join 表名2 on 表名1.列名 &#x3D; 表名2.列名8：right join右外连接 select 查找信息 from 表名1 right join 表名2 on 表名1.列名 &#x3D; 表名2.列名9：oracle中查询遍历树形结构（start with）	select * from extmenu<br>start with pid&#x3D;1connect by prior id &#x3D; pid<br>快速删除父节点以及父节点下的所有节点：<br>Delete from extmenu where id in (<br>elect * from extmenu<br>start with pid&#x3D;1<br>connect by prior id &#x3D; pid<br>)10：查询出来60-70,80-90,95-100学生的信息select * from stu where chengji between 60 and 70 or between 80 and 90 or between 95 and 100<br>select * from stu where chengji &gt; 60 and chengji &lt; 70 or chengji &gt; 80 and chengji &lt; 90 or chengji &gt; 95 and chengji &lt; 10011：用exists替换in——进行联表查询<br>select * from dept where exists(select * from emp where emp.deptno&#x3D;dept.deptno);<br>或<br>select * from dept d inner join emp e on d.deptno &#x3D; e.deptno(只查询出两表共同拥有的字段数据)12：删除表中的重复数据：<br>delete from xin a where a.rowid !&#x3D; (<br>select max(b.rowid) from xin b<br>where a.name &#x3D; b.name<br>);13：row_number()，rank() over ，dense_rank() over 按工资排序<br>select sal,<br>row_number() over(order by sal desc) rank1,<br>rank() over(order by sal desc) rank,<br>dense_rank() over(order by sal desc) drank<br>from emp14：select * from (select emp.* from(<br>dense_rank() over(partition by departNo order by sal desc)<br>rk from emp )<br>Where rk&#x3D;4十六、ibatis批量<br>this.getSqlMapClientTemplate().execute(<br>new SqlMapClientCallback() {<br>public Object doInSqlMapClient(<br>SqlMapExecutor executor)<br>throws SQLException {<br>executor.startBatch();<br>for (int i &#x3D; 0, n &#x3D; list.size(); i &lt; n; i++) {<br>executor.insert(<br>“productAttach.insertProductAttach”,<br>list.get(i));<br>}<br>executor.executeBatch();<br>return null;<br>}<br>});ibatis,jdbc,hibernate的分段的实现:<br>都应该在组装list的时候进行拆分（如：action层加入）<br>if(list.size() % 1000 &#x3D;&#x3D; 0)<br>{<br>productAttachService.addBatch(list);<br>list.clear();<br>}if (list.size() &gt; 0)<br>productAttachService.addBatch(list);业务场景篇<br>三、权限概述<br>权限涉及到5张表：<br>用户表，角色表，权限表(菜单表)，用户角色关联表，角色权限关联表当用户登录时，根据用户名和密码到用户表验证信息是否合法，如果合法<br>则获取用户信息，之后根据用户id再到用户角色关联表中得到相关连的角色<br>id集合,之后根据角色id再到角色权限关联表中获取该角色所拥有的权限id集合，<br>然后再根据权限id集合到权限表（菜单表）中获取具体的菜单，展现给当前<br>登录用户，从而达到不同用用户看到不同的菜单权限。我们通过ZTree来给角色赋权并且通过ZTree来展示菜单，以及通过ZTree来管 理菜单即增加和编辑菜单。<br>我们做的权限控制到url级别,为了防止用户不登录直接输入url访问的这个弊端，通过拦截器进行拦截验证。四、OSCache业务场景<br>在我以前的项目中，我们考虑了系统性能问题，这个时候我们采用了Oscache缓存，刚开始把这个功能交给了项目组中的另外一个同事来做的，但是他做完的时候他发现缓存中明明已经缓存了数据，但是在取得时候发现没有数据，我们项目经理让我去帮忙看看这个问题，我阅读完他的代码之后，我发现了他每次缓存的时候都是调用一个新的缓存对象的方法，结果出现了明明已经走了缓存的方法而取不到数据的问题，通过我多年的工作经验，我就想到了应该用单例模式去封装一个单例工具类来调用oscache。但是，在后来的测试过程中，发现当并发访问的时候也会出现上述的问题，这个时候我直接采取的DCL（双重判定锁）单例模式封装了工具类，既解决了线程安全问题，相对的性能问题也考虑到了，这个问题才得到了完善的解决。五、<br>六、Ajax请求Session超时问题<br>我在做项目时有时会遇到session超时问题，如果session超时，平常请求没有什么问题，通过拦截器可以正确跳到登陆页面，可是你如果用ajax请求的话这就出现问题了，因为ajax是异步的，局部刷新，所以登陆界面不会再全页面中显示，他只会显示到页面的一部分当中。所以根据我这几年的经验找到了我认为比较好的一种方法。因为那我用的框架是和struts2集成的，所以就在拦截器中进行设置：<br>首先判断session是否为空就是判断session是否超时，如果超时就取出请求的head头信息request.getHeader(“x-requested-with”)，如果不为空就和XMLHttpRequest(Ajax标识)进行比较 (request.getHeader(“x-requested-with”).equalsIgnoreCase(“XMLHttpRequest”))) 如果相等说明此请求是ajax请求。<br>如果是ajax请求就可以用response.setHeader(“键”,”值”)来设置一个标识来告诉用户这是ajax请求并且session超时时发出的，这样我就可以在回调函数中取出自己设置的那个唯一标识：XMLHttpRequest.getResponseHeader(“”);如果取出的值是和自己在后台中设置的值一样的话，就证明session已经超时，这样就可以设置window.location.replace(“登陆界面”)，来跳转到登陆界面了。<br>这样做虽然解决了问题，但是，会在每个回调函数中写入那些代码，这样的话代码就会显得特别零散，所以就想能不能定义一个全局的设置所以就找到了jqery的ajaxSetUp方法，通过ajaxSetUp对jqery的ajax进行全局的判断(ajaxSetUp就相当于ajax的拦截器)，通过设置ajaxSetUp里的complete，它就相当于回调函数，这样那就弥补了上一方法的不足。<br>我做项目时还用到<code>$(document).ajaxStart()，这是ajax请求时的事件；$</code>(document).ajaxSuccess()，这是AJAX请求成功后的事件。我一般用他们来显示遮罩层和隐藏遮罩层用的加遮罩层是为了不让用户重复提交，更提高了用户体验度，让用户知道已经提交了。七：java线程池概述<br>java线程池的工作原理和数据库连接池的差不多，因为每次重新创建线程<br>都是很耗资源的操作，所以我们可以建立一个线程池，这样当需要用到线程<br>进行某些操作时，就可以直接去线程池里面找到空闲的线程，这样就可以直接<br>使用，而不用等到用到的时候再去创建，用完之后可以把该线程重新放入线程池<br>供其他请求使用从而提高应用程序的性能。线程池的核心流程:<br>1.构建一个 ThreadPoolExecutor 并指定默认要创建的线程的数量<br>2.通过 threadPool.execute()<br>去添加一个个要执行的线程即实现了Runable接口的java类<br>3.在实现了Runable接口的java类的run方法中写入具体的业务代码<br>线程池的业务场景：<br>我在工作的时候，当时一个同事给我提了一个需求，目前有大量的图片<br>需要处理生产缩略图并进行加水印，因为按照普通的处理方法一个个的<br>进行处理太慢了，问我有没有好的解决方案，这个时候我就想到了java中<br>的线程池，我构建了一个线程数为5个线程池，然后采用分段批量提取的<br>方式每500条为一组数据进行图片信息的提取，然后再把这些通过Threadpool的<br>execute方法交给线程池中的线程进行处理，即充分使用了CPU硬件资源又加快<br>了大数据情况下程序的处理效率。我当时在工作的过程中，认识一个做电商的朋友，他们当时公司才起步，很多<br>技术都不成熟，所以就常常和我探讨一些技术问题，有次他向我请教一个问题，<br>问我如何才能提高网站的性能，我根据自己在项目中的经验以及自己以前阅读的<br>关于优化方面的资料给他提出了很多建议，如用lucene进行全文检索，用memcached<br>进行分布式缓存，以及通过spring定时器结合freeMarker模板引擎来生成静态<br>页面，由于要生成的页面的数量比较多，考虑到程序的性能，我建议他结合<br>java的线程池进行工作，这样就可以充分使用了CPU硬件资源又加快<br>了大数据情况下程序的处理效率。八、OSCache概述<br>oscache是一个高性能的j2ee框架，可以和任何java代码进行集成，并且还可以通过标签对页面内容进行缓存，还以缓存请求。<br>我们通常将那些频繁访问但是又不是经常改变的数据进行缓存。为了保证缓存数据的有效性，在数据发生改变的时候，我们要刷新缓存，避免脏数据的出现。刷新缓存的策略有两种，一种是定时刷新，一种手动刷新。缓存数据的时机通常也分为两种，即在tomcat(web容器)启动时候加载数据进行缓存，另外也可以在用户第一次访问数据的时候进行缓存，这个相当于缓存的立即加载和按需加载。缓存的层次如下:jsp–&gt;action–&gt;service–&gt;dao,缓存越靠前对性能的提升越大一个action里面可以有多个service,一个service中可以有多个dao或者多个service任何类之间都可以进行相互调用，可以通过构造函数传参，set,get传参或者是方法传 参将相关的类连接起来。九、OSCache+autocomplete+单例业务场景<br>在我以前做某项目的过程中，其中我们在做产品列表的查询的时候为了提高用户的体验度，我们使用了autocomplete插件来代替select进行品牌的选择，才开始的时候每次都要根据用户输入的信息去查询数据库进行模糊匹配返回结果，后来我们考虑到系统的性能，因此我们采用了oscache缓存，才开始这个功能是交给我们项目组中的另外一个同事来做的，但是他做完后，我们在使用这个工具类的时候，发现有时缓存中明明已经有时我们需要的数据，但是从缓存里面取的时候，发现没有，之后项目经理让我去帮这个同事看看这个问题，我经过阅读他的代码发现，它里面在使用缓存的时候，针对于每次方法的调用都产生一个新的实例，结果导致了上面的问题，这个时候我想起了可以使用设计模式中的单例模式来解决这个问题，才开始我直接采用了普通的单列模式，但是后来在测试的过程中，发现当用户并发量大的时候还是会出现上面的问题，之后我再次考虑了代码，最后发现是因为没有给单列模式加锁的原因，从而导致了大用户并发的时候，线程安全的问题，之后我便在方法上加上了synchronized关键字，解决上述的问题，但是后来测试人员反馈，觉的这段的性能有问题，我考虑之后便采用在方法体内加锁并结合双重判定的方式解决了上面的问题。我们是将数据在tomcat启动的时候加载到缓存中，之后用户进行查询的时候直接从缓存中获取数据，根据前缀匹配进行查询，将结果返回给用户。这样在提高用户体验度的同时也提高性能。十、缓存概述<br>应用程序为了提高性能，可以通过使用缓存来达到目的，缓存的存储介质可以<br>内存或者硬盘，通常将数据存储在内存里，确切的说是jvm的内存中，缓存是<br>基于Map这种思想构建的，以键值对的方式进行存取，之所以还可以将<br>缓存的数据存储在硬盘中，是因为内存资源相当有限和宝贵，所以当内存资源<br>不足的时候，就可以将其存储到硬盘中，虽然硬盘的存取速度比内存要慢，但是<br>因为减少了网络通信量，所以还是提高程序的性能。缓存可以分为客户端缓存和<br>服务器端缓存，所谓的客户端缓存通常指的是IE浏览器的缓存，服务器端缓存指<br>的web服务器的缓存，通常可以通过第三方组件实现，如oscache,memcache我们通常将那些频繁访问但是又不是经常改变的数据进行缓存。为了保证缓存数据的<br>有效性，在数据发生改变的时候，我们要刷新缓存，避免脏数据的出现。刷新缓存的<br>策略有两种，一种是定时刷新，一种手动刷新。缓存的层次如下:jsp–&gt;action–&gt;service(通常放置在service)–&gt;dao,<br>缓存越靠前对性能的提升越大缓存的策略:(缓存空间不足需要进行清理的时候使用)<br>LRU:最近最少使用原则.(理解:存储书)<br>FIFO:先进先出的缓存策略.(理解:排队)你来说说缓存？说说你对缓存的理解（如果遇到重复的，就可以省略）我们在项目中使用缓存的目的是为了提高应用程序的性能，减少访问数据库<br>的次数，从而提高应用程序的吞吐量。我们通常将权限，菜单,组织机构<br>这些频繁访问但是不经常改变的基础数据进行缓存，其中我在做()某某项目的时候<br>就通过oscache对ZTree的树形菜单进行了缓存，并且在做的时候和单列设计<br>模式进行结合，考虑到多线程下的安全问题，还对单例模式加入了双重判定锁<br>的检查方式。<br>十一、实现页面静态化业务场景<br>我们在做某项目时，涉及到程序访问的性能问题，这时候我们想到可以通过静态化来提高用户访问时候的性能，所以我们就采用了freemarker模板引擎，考虑到页面也是要有动态的变化的，所以我们采用spring定时器在每天晚上2点钟的时候定时再次生成html静态页面，考虑发布时候的性能问题，我们又采取线程池技术，让多个线程同时发布，从而缩减发布时间。十二、servlet线程安全描述<br>servlet是单列的，对于所有请求都使用一个实例，所以如果有全局变量被多<br>线程使用的时候，就会出现线程安全问题。解决这个问题有三种方案:<br>1.实现singleThreadModel接口，这样对于每次请求都会创建一个新的servlet实例，这样就会消耗服务端内存，降低性能，但是这个接口已经过时，不推荐使用。<br>2.可以通过加锁(synchroniezd关键字)来避免线程安全问题。这个时候虽然还是单列，但是对于多线程的访问，每次只能有一个请求进行方法体内执行，只有执行完毕后，其他线程才允许访问，降低吞吐量。<br>3.避免使用全局变量，使用局部变量可以避免线程安全问题，强烈推荐使用此方法来解决servlet线程安全的问题。十三、(jbpm4)工作流引擎描述:<br>JPBM是JBOSS旗下的一个开源的基于hibernate的工作流引擎。工作流就是在日常生活中，我们一些常见的如请假流程、采购流程、入职流程，通俗的来讲就是一些在现实生活中的流程以信息化以程序的方式实现。<br>一个工作流首先需要进行流程定义，流程定义是由节点和跳转组成的，节点又可以称为环节、活动节点、活动环节，并且节点也可以分为两大类型：人工节点和自动节点，人工节点有start开始节点、end结束节点、task任务节点，自动节点有decision判断节点、fork分支节点、join聚合节点和state状态节点，并且一个流程有且只有一个开始节点，但可以有多个结束节点。<br>流程定义是静止的，它在运行状态时会转换成流程实例，一个流程定义可以对应多个流程实例。流程运行后，会产生两个文件，</em>.jdpl.xml文件和*.png图片文件，也会生成18张数据库表，常用且核心的表有JBPM4_LOB 存储表，主要存储xml文件和png图片、JBPM4_TASK 任务表、JBPM4_EXECUTION 流程实例表、JBPM4_VARIABLE变量表。图形化的灵活定制（主动说）<br>可以根据需求进行流程图的改变的，即定义的流程图是可以根据需要改变的，而不是死的。<br>可以进行图形化的监控(主动说)<br>输出图片<br>获取活动节点的坐标<br>进行叠加<br>判断节点:(主动说，也可以了解)<br>实现implements DecisionHandler接口并重写decide方法,<br>返回的字符串要和xml中配置的transition的name保持一致。<br>分支判定节点JBPM有五大核心类：<br>ProcessEngine：主要获取各种的Service<br>RepositoryService：主要发布流程定义<br>ExecutionService：主要操作流程实例<br>TaskService：主要操作人工服务<br>HistoryService：主要操作历史服务。核心方法：<br>读取jbpm定义的文件生成zip包存到lob表中：createDeployment()<br>获取流程定义列表：createProcessDefinitionQuery<br>根据定义的key或id来启动流程实例：startProcessInstanceByKey(id)<br>获取待办任务列表：findPersonalTasks(userName)<br>完成指定任务列表：completeTask(*.getActivityId())<br>获取历史任务列表：createHistoryTaskQuery()<br>获取流程实例的ID：task.getExecutionId()(了解的表)<br>JBPM4_HIST_ACTINST 流程活动(节点) 实例表<br>JBPM4_HIST_DETAIL 流程历史详细表<br>JBPM4_HIST_PROCINST 流程实例历史表<br>JBPM4_HIST_TASK 流程任务实例历史表<br>JBPM4_HIST_VAR 流程变量( 上下文) 历史表十四、JPBM业务场景<br>首先进行请假的流程定义，我们流程的定义是（员工提交请假单—》经理审批—》总监审批—》总经理审批—》结束），通过repositoryService将其发布部署到jbpm4_lob表中，<br>之后获取流程定义列表，选中请假的流程定义，员工开始进行请假单的填写，保存并通过executionService开启流程实例，然后用taskService获取经理的待办任务列表，选中待办任务，进行审批，通过调用taskService.completeTask()进入到总监审批环节，然后用总监进行登录，同样获取待办任务列表，然后调用taskService.completeTask()进入总经理审批环节，总经理审批之后，结束流程。在这个过程中我们还可以根据historyService查看当前登录人已办的任务列表。<br>十五、Ant描述<br>Ant是apache旗下的对项目进行自动打包、编译、部署的构建工具，他主要具有 轻量级并且跨平台的特性，而且基于jvm，默认文件名为build.xml<br>Ant主要的标签：<br>Project 根标签，<br>target 任务标签，<br>property 属性标签，自定义键&#x2F;值 供多次使用，<br>java 执行编译后的java文件<br>javac 编译java文件<br>war 打成war包<br>其它标签：copy，delete，mkdir，move，echo等。十六、FreeMarker描述<br>FreeMarker是一个用Java语言编写的模板引擎，它是基于模板来生成文本输出的通用工具。Freemarker可以生成HTML， XML，JSP或Java等多种文本输出。工作原理：定义模板文件，嵌入数据源，通过模板显示准备的数据<br>（数据	+ 模板	&#x3D; 输出）<br>　　我们在使用模板中发现freemarker具有许多优点，它彻底的分离表现层和业务逻辑，模板只负责数据在页面中的表现，不涉及任何的逻辑代码，所以使得开发过程中的人员分工更加明确，作为界面开发人员，只需专心创建HTML文件、图像以及Web页面的其他可视化方面，不用理会数据；而程序开发人员则专注于系统实现，负责为页面准备要显示的数据。<br>如果使用jsp来展示，开发阶段进行功能调适时，需要频繁的修改JSP，每次修改都要编译和转换，浪费了大量时间，FreeMarker模板技术不存在编译和转换的问题，在开发过程中，我们在不必在等待界面设计开发人员完成页面原型后再来开发程序。由此使用freemarker还可以大大提高开发效率。十七、webService描述<br>（主动说）<br>webservice是SOA（面向服务编程）的一种实现，<br>主要是用来实现异构平台通信也就<br>是不同平台不同项目之间的数据传输，从而避免了信息孤岛的问题，<br>它之所以能够<br>进行异构平台通信是因为它是完全基于xml的，<br>所以说，webService是跨平台，<br>跨语言，跨框架的，在java中通常有三种技术框架分别是xfire,cxf,axis2。<br>我们为了保证<br>webservice的安全性，采用了基于<br>WS-Security标准的安全验证(使用回调函数)。（没必要主动说）<br>webservice的三要素分别是：<br>wsdl（webservice description language）<br>用来描述发布的接口（服务）</p><p>soap(simple object access protocol)<br>是xml和http的结合，是webservice数据通信的协议</p><p>uddi 用来管理，查询webService的服务（没必要主动说）<br>webservice的具体三种实现方式（框架）或者三种实现框架的区别</p><ol><li>Axis2:可以用多种语言开发，<br>是一个重量级框架，功能非常强大，<br>但是它的性能比较低。 2. Xfire：它相比Axis2来说是一个轻量级框架，<br>它的性能要比Axis2高。 3. cxf：是Xfire的升级版，就好比是，<br>struts2是webwork的升级，<br>然后cxf和spring集成起来非常方便，简易，<br>性能方面也要比Xfire高。<br>【注】jdk6 自带的webservice jws（主动说）<br>业务场景<br>我在以前做项目的时候，其中遇到一个功能，<br>需要进行两个项目之间的数据的传输，<br>项目经理让我去完成这个任务，我根据以往的项目经验，<br>想到两种解决方案，第一种<br>就是开放另外一个项目的数据库的权限给我，<br>然后我直接通过访问另外一个项目的数据<br>库，来得到需要的信息，但后来我分析了下，觉的这种方式不安全，<br>而且因为当时<br>这个项目是另外一家公司负责在做，所以数据库里面的表结构，<br>以及以后牵涉<br>到的责任问题都很多，所以我就采用了第二种方案，<br>即通过webservices的方式，进行<br>异构系统之间数据信息的传递，webservices的具体实现，<br>有xfire,cxf,axis2,<br>我根据以往的项目经验，了解到cxf是xfire的升级版本，适用于java语言，<br>xfire&#x2F;cxf 性能比axis2要高，并且和spring整合起来也比较方便，<br>而axis2支持更多的语言，<br>性能相对于cxf要低，通过上面分析，<br>结合我们目前的两个项目都是基于java<br>语言的，所以我采用cxf这种方式实现了两个项目之间数据的传递，<br>我们为了保证<br>webservice的安全性我们采用了基于<br>WS-Security标准的安全验证(使用CXF回调函数)。（没必要主动说）<br>webservice服务端配置流程<br>首先在web.xml中引入cxfServlet核心类，<br>指定对以&#x2F;cxf开头的url路径提供webservice服务，<br>之后我们在要发布成webservice接口上添加@Webservice 注解，<br>而且还要在实现类上添加同样的webservice注解并且要说明实现了哪个接口，<br>之后在spring-webservice.xml中发布webservice服务，<br>通过jaxws:endpoint这个标签，<br>并且在标签配置implementor和address来表明实现服务的类，<br>以及发布的地址，<br>最后在浏览器中输入相关的webservice地址?wsdl来验证服务是否发布成功。（没必要主动说）<br>webservice客户端的配置<br>首先通过wsdl2java根据发布的webservice服务端地址的wsdl<br>生成客户端调用的中间桥梁java类，<br>将生成的java类拷贝到客户端项目中，<br>配置spring-client.xml文件，<br>通过jaxws:client定义一个bean,<br>并通过address属性指明要访问的webservice的服务地址，<br>通过serviceClass指明充当中间桥梁的服务类，之后获取该bean,<br>就可以通过它来访问发布的webservice接口中的方法。十八、oracle索引概述<br>索引呢 是与表相关的一个可选结构，可以提高sql语句的检索效率，相当于我们的字典目录 ，可以快速进行定位 ，所以可以减少磁盘I&#x2F;O, 但是因为索引在物理与逻辑上都是独立于表的数据 它会占用一定的物理空间(额外磁盘空间) 所以并不是索引越多越好,而我们应该根据业务需求去创建索引,而且进行增删改操作时 oracle又要自动维护索引 所以在一定程度上也降低了维护速度，而且我们在创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加，我们一般创建索引呢 是这样创建的 create index 索引名 on 表名(字段)，索引又分为普通索引 唯一索引(unique) 单个索引 复合索引(又叫组合索引，在索引建立语句中同时可包含多个字段名)，顺序索引，散列索引,位图索引。十九、oracle存储过程<br>存储过程就是封装一些sql的集合，也就是一条条的sql语句，过程的优点就是简化了sql命令加上它是预编译的，所以它的执行效率和性能较高，再者，如果不调用过程的话就要和数据库发生多次交互，调用过程只需传一个命令所有的那些执行逻辑都在数据库端执行，所以说它降低了网络的通信量，其次，存储过程大大提高了安全性，这就是优点<br>缺点呢，就是不同的数据库对过程支持的关键字支持的关键字都是不一样的，所以它的移植性是非常差的，再者，它的维护性难度也比较大，因为它没有专业的调试和维护工具，所以说它维护起来比较麻烦，这就是存储过程的基本概述.<br>二十、Junit 业务场景<br>在我们开发项目的时候为了提高代码的性能和保证逻辑正确性，在我们编写代码后往往都要进行单元测试，来验证代码，当时我们公司开发人员全部使用的main方法来进行验证，但是使用mian的最大缺点就是不能将多个类同时进行验证，验证的结果不直观，测试复杂（每个类都要写main方法，单个运行），一定程度上浪费时间，所有我和项目经理提议使用专业测试工具Junit来进行测试，因为Junit是一个Java语言的单元测试框架 ，测试简单，不仅可以提供工作效率和代码的质量，也提高团队的合作能力，我提议后我们进行了Junit的培训使用Junit4加注解的方式来测试。二十一、Apache+Tomcat 实现负载均衡及seesion复制<br>当我们tomcat访问量大,线程连接数不够时,我们考虑到了tomcat的负载均衡来分担过多的访问.性能方面负载均衡也能利用多台tomcat来增大内存量,<br>流程,准备工作apache,Jk_mod,tomcat,在apache的conf&#x2F;httpd.conf文件中 使用include 标签引入我们自定义的一个mood_jl.conf,在modules中引入下载的k_mod-apache-X.X.XX.so文件,在其中引入我们的.so,及work.properties文件,及指定负载分配控制器controller,在work.properties文件中worker.list&#x3D;controller,tomcat1,tomcat2指定service,worker.tomcat1.port Ajp端口号,type 是ajp,host为指定ip,lbfactor 指定分配权重值越大分担请求越多,worker.controller.type&#x3D;lbworker.controller.balanced_workers&#x3D;tomcat1,tomcat2 指定分担请求的tomcat Session的复制在tomcat中service.xml中Engine标签加入 jvmRoute 值为work,properties中指定的tomcat名称,然后打开&lt;Cluster标签的注释,最后在应用中程序的web.xml文件中增加&lt;distributable&#x2F;&gt;。我们在做这个项目时，我们考虑到服务器性能的问题，我们最开始想到使用纵向扩展，来增加硬件的配置提高其性能，但这样做比较耗费资金，而且服务器内存空间也是有限的；所以后来就想到使用横向扩展来达到这一目的<br>当时我们的apache是通过jk借助于ajp协议与tomcat进行通信的，在我们不进行负载均衡之前，那所有的请求都由一台tomcat进行处理，这样会使我们的tomcat所承受的压力增大，而我们进行负载均衡之后，同样数量的请求经过apache和jk将其分发到多台tomcat进行处理，从而降低每台tomcat所承受的压力,而且当其中一台机器宕机时，其他机器还可以继续提供服务，保证服务不间断。<br>在这个过程中，我们遇到了session问题，然后我此昂到用session复制来解决这个问题；<br>在apache的配置文件中增加session粘带特性:<br>worker.lb.sticky_session&#x3D;1<br>worker.lb.sticky_session_force&#x3D;0<br>Tomcat的配置<br>修改server.xml文件： &lt;Engine name&#x3D;”Catalina” defaultHost&#x3D;”localhost” jvmRoute&#x3D;”tomcat2”&gt;<br>增加jvmRoute&#x3D;”tomcat2” *. jvmRoute赋的值为worker.properties中配置的相应的server名一致 &lt;Cluster className&#x3D;”org.apache.catalina.ha.tcp.SimpleTcpCluster”&#x2F;&gt; 将此配置的注释去掉<br>修改应用的web.xml文件<br>在应用中的web.xml文件中增加&lt;distributable&#x2F;&gt;。<br>如果这样做，当第一次访问的时候，会把所以数据全部缓存到第一台服务器上，通过web配置文件，会把第一台缓存的数据全部复制到第二胎服务器上，这样做就加大网路通信量，导致阻塞，所以我们就想到了可以通过memcached分布式缓存来存取session从而解决上述问题。二十二、Ant业务场景<br>Ant是基于java语言编写的，因此具有跨平台的特性，此外还具有简洁方便，灵活<br>配置的特性，因此我就在XX项目中使用ant进行项目的编译，打包，部署操作。使用ant<br>之后，如果我们在客户那里修改代码后，就可以直接使用ant进行编译，打包，部署，而不需要为了编译，打包，部署专门在客户那里安装eclipse.此外使用ant也可以直接和svn进行交互，下载源码的同时进行编译，打包，部署。<br>二十三、maven业务场景<br>maven业务场景前段时间在研究maven，知道maven是一个项目管理工具，其核心特点就是通过<br>maven可以进行包的依赖管理，保证jar包版本的一致性，以及可以使多个项目共享<br>jar包，从而能够在开发大型j2ee应用的时候，减小项目的大小，并且和ant<br>比起来，maven根据“约定优于配置”的特性，可以对其项目的编译打包部署进行了<br>更为抽象的封装，使得自己不需要像ant那样进行详细配置文件的编写，直接使用<br>系统预定好的mvn clean,compile,test,package等命令进行项目的操作。于是我就<br>在XX项目中采用了maven,为了保证团队中的成员能够节省下载jar包所需要的时间，<br>于是我就采用nexus搭建了在局域网内的maven私服，然后通过配置settings.xml中<br>建立mirror镜像，将所有下载jar包的请求都转发到maven私服上，之后通过在pom.xml<br>即(project object model)中配置项目所依赖的jar包，从而达到在构建项目的时候，<br>先从本地仓库中查找，如果不存在从内部私服查找，如果不存在最后再从外网central<br>服务器查找的机制，达到了节省下载带宽，提高开发效率，以及jar包重用的目的。ant业务场景ant是基于java语言编写的，因此具有跨平台的特性，此外还具有简洁方便，灵活<br>配置的特性，因此我就在XX项目中使用ant进行项目的编译，打包，部署操作。使用ant<br>之后，如果我们在客户那里修改代码后，就可以直接使用ant进行编译，打包，部署，<br>而不需要为了编译，打包，部署专门在客户那里安装eclipse.此外使用ant也可以<br>直接和svn进行交互，下载源码的同时进行编译，打包，部署。maven的常用命令<br>mvn eclipse:clean eclipse:eclipse -Dwtpversion&#x3D;2.0mvn clean packagemaven的生命周期是独立的，但是生命周期下的阶段是相互关联并且延续的。maven的生命周期clean(清理):clean;default(默认):compile,test,packageinstall;site(站点)二十四、Servlet的概述：<br>Servlet是一个web容器，我们通常用的servlet是httpservlet，而httpservlet又是继承于genericservlet，而genericservlet又实现了servlet接口<br>servlet的生命周期是 ：先进行实例化，然后是初始化，然后是提高服务，然后销毁，最后不可用，在这五个生命周期，其中，初始化是调用的init方法，这个方法只有一个，而提高服务的时候调用的是service方法，而我们具体在我们所写的这个方法中，因为我们继承了httpservlet，其实就是对应了doGet（），doPost(),这种方法，然后据我了解，servlet是单例的。非线程安全的，我们通常有一下几种方案来解决：<br>第一种，继承SingleThreadModel但是这样每次都会创建一个新的servlet实例，但这样消耗服务器的内存，降低了性能，并且这个接口现在已经过时了，不推荐使用。<br>第二种：我们尽量避免使用全局变量，就我个人而言，我比较喜欢使用这种方法。<br>第三种，我们可以通过使用ThreadLocal， 内部结构是一个Map结构，用当前线程作为key,他会创建多个副本。get,set方法<br>第四种，我们当然还可以来加锁，进行解决线程问题。<br>而且我还知道，向我们这种常用的MVC框架，struts1，spring这些MVC框架，都是基于servlet发展而来的，就比如struts1 的核心总控制器是ActionServlet，而springMVC的前端总控制器是dispatchServlet，在项目我们曾经用serlet来生成 图片验证码的，防止用户进行暴力破解（别人问了，再回答）<br>servlet的配置文件 web.xml &lt;servlet&gt; &lt;servlet-name&gt;ImageCodeServlet&lt;&#x2F;servlet-name&gt;	&lt;servlet-class&gt;org.leopard.code.ImageCodeServlet&lt;&#x2F;servlet-class&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ImageCodeServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;d&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt;<br>描述：<br>我在web.xml中，我首先需要写一个servlet标签，servlet标签中有两个子标签，一个叫servlet-name，这个name可以随便起，但是要保证唯一性，除此之外，在这个servlet-name下有一个servlet-class，这个servlet-class对应的就是我后台提高服务的servlet，除此之外还有一个servlet-mapping，这个里边首先有一个servl-name。，这个servl-name首先要保证和上边的servlet-name保持一致，除此之外还有一个url-pattern，这是一个虚拟路径，是用来发送请求的url地址<br>二十五、bugfree的操作步骤<br>我们在使用bugfree的时候我们首先登陆的时候是以测试员的身份登陆的，也就是系统管理员用户；测试员在登陆后首先应该给要测试的项目的相关负责人，每人创建一个账号（也就是在登陆后的页面的后台管理中创建用户），用户都新建完成之后就新建组，把要测试的项目的用户添加到组中。最后就新建项目并且新建该项目的模块。新建完项目之后就是开始测试程序，在程序中遇到bug以后就把错误截图，在到bugfree中新建bug填写相关的信息和要指派的人（出错模块的负责人）和把刚才的错误截图作为附件一并传送过去。<br>开发人员每天早上上班的第一件事就是用自己的用户登录bugfree，然后输入查询条件看看前一天有没有指派给自己的bug需要解决的如果有就进行解决。<br>开发人员把对应的bug解决之后就去bugfree上把bug对应的状态改成已解决状态，然后进行保存提交，这样bug的状态就变成已解决状态。测试人员上线查看已解决状态的bug并再次进行测试，如果经过测试bug的问题已解决，就可以把bug关闭；如果经过测试，发现仍然存在bug，就把bug激活；这样等开发人员再次登录的时候就可以再次看到这个未解决的bug，再次进行解决，如此反复直到bug全部解决，因为bugfree对bug的修改都有保留，所有我们可以看到bug的一步步的完善，直到最后把bug关闭。<br>Bug的三种状态：未解决(Active)（测试人员）、已解决(Resolved)(开发人员)、关闭(Closed)（测试人员）二十六、Axis2 的配置axis2服务端配置流程1.引入相关的jar包并且在web.xml中配置axis2的核心控制器 axisServlet2.在web-inf下建立相关的三层文件夹结构:<br>services–&gt;自定义文件夹名–&gt;META-INF–&gt;servies.xml3.在servies.xml中配置service的name以及对应的springBeanName4.在浏览器中输入webservice的服务端地址并加上?wsdl来进行测试，看<br>是否发布成功axis2客户端配置流程1.通过wsdl2java根据webservice服务端的url生成客户端代码2.将代码引入项目的文件夹中进行正常访问<br>二十六、spring定时器<br>每隔固定的时间执行1.建立一个triggers触发器集合2.建立SimpleTriggerBean并且指定每次间隔的时间以及执行的次数以及要执行的目标3.通过 targetObject以及targetMethod找到要执行的具体类的具体方法目标对象是一个普通的java类每到指定的时间执行1.建立一个triggers触发器集合.2.建立CronTriggerBean指定cron表达式以及要执行的目标3.通过 targetObject以及targetMethod找到要执行的具体类的具体方法目标对象是一个普通的java类<br>二十七、Ext概述<br>据我了解Ext是一个用js编写RIA框架，它可以和各种后台语言结合使用。<br>我在项目中用Ext来完成的模块大概情况是这个样子，首先我通过layout<br>等于border的这种方式来进行布局，分为上下左右中，然后在左边用ext<br>tree来进行菜单的展示，之后在中间区域通过tabs来加入选项卡，而在<br>选项卡中就是一个个的grid以及form，其中我在做grid的时候，首先通过<br>store来存取后台返回的符合model格式数据集，store是通过proxy和后台的<br>contoller进行交互，之后把store赋值给grid的store属性并且通过renderTO<br>在指定的位置进行渲染展示。Grid问题:<br>当时我在做grid的时候，发现数据没有展示出来，<br>我通过f12进行跟踪，发现压根就没有发送请求，后来我分析了下，发现因为<br>没有调用store的loadPage方法，所以导致了这个问题。除此之外在我们做<br>项目的过程中，我手底下带的一个人同样在负责grid的时候，数据可以正常展示，但<br>分页信息没有展示，通过跟踪他的代码发现是因为他没有把store属性赋值给<br>分页工具条，所以才导致了这个问题。tabs选项卡：<br>当我在做tab选项卡这一模块的时候，<br>我首先在加载页面的时候用TabPanel创建了一个<br>tab页面，让它展示在中间位置，<br>然后点击左边Tree菜单调用add方法动态添加一个个<br>的tab选项卡，但是做的过程中出现了相同的选项卡会重复添加的问题，<br>我查了一些相关资料，最后通过tab的id或者一个唯一标识判断tab是否选中，<br>如果选中则调用setActiveTab来激活该选项卡，让它选中，<br>否则就添加一个tab。<br>最后达到了tab不存在就添加，存在就选中的效果。了解:<br>Ext4.0也支持前端的MVC开发模式.为啥没采用mvc的开发模式？<br>我们当时因为时间方面的原因，项目经理就决定用普通的这种<br>开发模式进行开发，并没有采用Ext4.0这种mvc模式的特性。但<br>我认为他们的核心操作流程是一致的所以对我来说去学习和使用<br>这种方式并没有什么难度。<br>二十八、lucene的概述<br>lucene是一个全文检索引擎，在进行模糊匹配的时候，他可以<br>用来替代数据库中的like,从而在匹配准确性以及性能进行大幅度<br>的提高。我在做XX项目的XX模块的时候，就是用lucene来进行全文检索<br>用IK分词器来进行分词。从而实现了高亮显示关键词，分页，排序，<br>多字段，多条件的高性能搜索。在从数据中取数据生成索引的时候，<br>因为表中的数据量比较大，防止一次取出所导致内存溢出问题，我采用了<br>分段批量提取的方式进行，除此之外我们对后续增加的数据根据优先级的<br>不同采取不同的策略，对于那些需要及时显示的数据我们通过spring<br>定时器 在短时间内(30分钟)进行增量索引的生成，对于那些不需要<br>及时展示的数据,我们通过spring定时器在每天晚上凌晨的时候进行索<br>引的重新生成。二十九、线程池作用<br>1.减少了创建和销毁线程的次数，<br>每个线程都可以被重复利用，<br>可执行多个任务。2.可以根据系统的承受能力，<br>调整线程池中线程的数目，<br>防止因为消耗过多的内存，<br>而导致服务器宕机<br>(每个线程需要大约1MB内存，线程开的越多，<br>消耗的内存也就越大，最后宕机)。通常我们使用的线程池是实现了ExecutorService的<br>ThreadPoolExecutor。<br>三十、jbpm是如何和spring进行整合<br>1.通过在spring-common.xml配置文件中配置springHelper，通过springHelper创建<br>processEngine，再通过processEngine获取各种工作流的Service，<br>如repositoryService，executionService，historyService，taskService2.在src根目录下新建jbpm.cfg.xml文件<br>三十一、Tomcat优化<br>增大内存(堆，持久代)并开启server模式<br>我在做XXX项目时,用到了poi导入和导出数据,由于公司的业务比较繁多,数据量很大,测试时报内存溢出,经过我的分析再结合上网查阅资料,发现可能是tomcat内存不足,需要增大,修改配置文件后测试不再报错.<br>tomcat增大内存的方式通过修改tomcat配置文件<br>window下， 在bin&#x2F;catalina.bat文件中最前面添加：<br>set JAVA_OPTS&#x3D;-XX:PermSize&#x3D;64M -XX:MaxPermSize&#x3D;128m –Xms1024m -Xmx1024m<br>linux下，在catalina.sh最前面增加：<br>JAVA_OPTS&#x3D;”-XX:PermSize&#x3D;64M -XX:MaxPermSize&#x3D;128m –Xms1024m -Xmx1024m “<br>-client –service<br>当我们在cmd中运行-java时,黑窗口会出现-client -service这两参数.其作用是设置虚拟机运行模式;client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。server模式启动比client慢，但可获得更高的运行性能。Windows默认为client，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上,默认值为server模式.<br>JDK版本<br>影响虚拟机还有JDK的版本,JDK分为32位,64位两种版本,32位装在32位系统,64位系统可以装32位和64位JDK.64位JDK性能优于32位JDK.<br>测试的命令 java -xmx数值m –version 报错配置大小失败,反之成功增加Tomcat最大连接数<br>使用场景<br>我在做完一个XXX项目后,测试时发现并发数量增加到一定程度就会很卡,于是我想到了是不是tomcat最大连接数设置有限制.果不其然,配置文件中最大值才500,于是我更改了最大连接数,根据业务我修改了连接数为2000,完美的解决了这个问题;<br>修改方法在conf&#x2F;service.xml中默认值 &lt;Connector port&#x3D;”8080” maxHttpHeaderSize&#x3D;”8192” maxThreads&#x3D;”1500”<br>minSpareThreads&#x3D;”30” maxSpareThreads&#x3D;”75” enableLookups&#x3D;”false”<br>redirectPort&#x3D;”8443” acceptCount&#x3D;”100” connectionTimeout&#x3D;”20000”<br>disableUploadTimeout&#x3D;”true” &#x2F;&gt;,修改maxthreads的值即可tomcat进行gzip压缩从而降低网络传输量<br>tomcat 压缩设置tomcat压缩gzip启用HTTP 压缩可以大大提高浏览网站的速度，它的原理是，<br>在客户端请求服务器对应资源后，从服务器端将资源文件压缩，<br>再输出到客户端，由客户端的浏览器负责解压缩并浏览。<br>相对于普通的浏览过程HTML ,CSS,Javascript , Text ，<br>它可以节省60%左右的流量。更为重要的是，它可以对动态生成的，<br>包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，<br>压缩效率也很高。<br>启用tomcat 的gzip压缩<br>要使用gzip压缩功能，你需要在Connector节点中加上如下属性记住来源：<a target="_blank" rel="noopener" href="http://www.qi788.com/info-42.html">http://www.qi788.com/info-42.html</a>compression&#x3D;”on” 打开压缩功能<br>compressionMinSize&#x3D;”50” 启用压缩的输出内容大小，默认为2KB<br>noCompressionUserAgents&#x3D;”gozilla, traviata” 对于以下的浏览器，不启用压缩<br>compressableMimeType&#x3D;”text&#x2F;html,text&#x2F;xml,text&#x2F;javascript,text&#x2F;css,text&#x2F;plain”　哪些资源类型需要压缩 &lt;Connector port&#x3D;”80” protocol&#x3D;”HTTP&#x2F;1.1”<br>connectionTimeout&#x3D;”20000”<br>redirectPort&#x3D;”8443” executor&#x3D;”tomcatThreadPool” URIEncoding&#x3D;”utf-8”<br>compression&#x3D;”on”<br>compressionMinSize&#x3D;”50” noCompressionUserAgents&#x3D;”gozilla, traviata”<br>compressableMimeType&#x3D;”text&#x2F;html,text&#x2F;xml,text&#x2F;javascript,text&#x2F;css,text&#x2F;plain” &#x2F;&gt;三十二、memcached的介绍<br>memcached是一个用C语言开发的分布式的缓存，内部基于类似hashMap的结构。<br>它的优点是协议简单，内置内存存储，并且他的<br>分布式算法是在客户端完成的，不需要服务器端进行<br>通信，我们当时在做项目的时候因为考虑到项目<br>的高可用性高扩展性，因此在服务器部署方面采用<br>了apache+jk+tomcat这种负载均衡的方式，但是也带来了一个问题<br>就是session共享的问题，虽然可以通过session复制来解决这个<br>问题，但是在性能方面存在缺陷，所以最后我们采用了<br>用memcached来存储session，这样既解决了session共享<br>问题，也解决了session复制那种方式所产生的性能问题。了解(不必主动说，但别人问的话一定要知道)memcached是以KEY-VALUE的方式进行数据存储的，<br>KEY的大小限制：Key（max）&lt;&#x3D;250个字符；<br>VALUE在存储时有限制：Value（max）&lt;&#x3D; 1M；根据最近最少使用原则删除对象即LRU.memcached默认过期时间：ExpiresTime（max）&#x3D; 30（days）优化篇<br>一、代码优化<br>代码结构层次的优化(目的:更加方便代码的维护–可维护性，可读性)<br>1.代码注释(代码规范)<br>2.工具类的封装(方便代码的维护，使代码结构更加清晰不臃肿，保证团队里代码 质量一致性)<br>3.公共部分的提取代码性能的优化(目的:使程序的性能最优化)<br>1.使用一些性能比较高的类(bufferInputStream)<br>2.缓冲区块的大小(4k或者8k)<br>3.公共部分的提取<br>4.通常要用stringbuffer替代string加号拼接二、业务优化<br>我们做项目的时候业务优化这方面最主要是从用户体验度角度进行考虑,减少用户操 作的步骤提高工作效率，通常有以下几种：<br>　　1.可以通过tabindex属性来改变tab键盘的操作顺序<br>　　2.可以通过回车键来进行搜索或者提交操作<br>　　3.对于单选按钮和复选按钮可以通过操作后面的文本来选择前面的单选按钮以及复选按钮<br>　　4.添加的信息要按照id倒序进行排列<br>　　5.进行搜索操作时加入js loading操作（不仅告诉用户所进行的请求正在被处理，而 且防止用户多次点击提交操作）<br>　　6.当进行删除操作的时候要弹出提示框，警告用户要进行删除操作，是否确认。<br>　　7.根据returnURL在用户登录成功后直接跳到想要访问的资源。<br>　　8.进行删除操作时通过confirm提示用户是否确认删除操作，操作完后提示操作是否 成功。<br>　　9.减少用户操作的步骤<br>10.使用autocomplete插件快速进行搜索必背，必做:<br>　1.可以通过回车键来进行搜索或者提交操作<br>　　2.添加的信息要按照id倒序进行排列<br>　　3.进行搜索操作时加入js loading操作（不仅告诉用户所进行的请求正在被处理，而且防止用户多次点击提交操作）<br>　　4.当进行删除操作的时候要弹出提示框，警告用户要进行删除操作，是否确认,如果删除成功则弹出提示框告诉用户。<br>　　5.减少用户操作的步骤<br>6.通过ztree，以及kindeiditor来提高用户的体验度三、sql优化<br>1、SELECT子句中避免使用 *， 尽量应该根据业务需求按字段进行查询2、尽量多使用COMMIT如对大数据量的分段批量提交释放了资源，减轻了服务器压力3、在写sql语句的话，尽量保持每次查询的sql语句字段用大写，因为oracle总是先解析 sql语句，把小写的字母转换成大写的再执行4、用UNION-ALL 替换UNION，因为UNION-ALL不会过滤重复数据，所执行效率要快于UNION,并且UNION可以自动排序，而UNION-ALL不会5、避免在索引列上使用计算和函数,这样索引就不能使用Sql优化精简版：1.(重点)(必须说) SELECT语句中避免使用 *，<br>尽量应该根据业务需求按字段进行查询举例：如果表中有个字段用的是clob或者是blob这种大数据字段的话，<br>他们的查询应该根据业务需要来进行指定字段的查询，切记勿直接用*2.(重点) 删除重复记录(oracle)：<br>最高效的删除重复记录方法 ( 因为使用了ROWID)例子：<br>DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID)<br>FROM EMP X WHERE X.EMP_NO &#x3D; E.EMP_NO);1. 用&gt;&#x3D;替换&gt;如一个表有100万记录，一个数值型字段A，<br>A&#x3D;0时，有30万条；<br>A&#x3D;1时，有30万条；<br>A&#x3D;2时，有39万条；<br>A&#x3D;3时，有1万记录。<br>那么执行 A&gt;2 与 A&gt;&#x3D;3 的效果就有很大的区别了，因为 A&gt;2 时，<br>ORACLE会先找出为2的记录索引再进行比较，<br>而A&gt;&#x3D;3时ORACLE则直接找到&#x3D;3的记录索引。4.(重点)尽量多使用COMMIT<br>如对大数据量的分段批量提交1. (重点)用NOT EXISTS 或（外连接+判断为空）方案 替换 NOT IN操作符此操作是强列推荐不使用的，因为它不能应用表的索引。<br>推荐方案：用NOT EXISTS 或（外连接+判断为空）方案代替6.(重点 必须说)LIKE操作符(大数据的全文检索使用luncene)(solr)<br>因为使用like不当，会导致性能问题，原因是like在左右两边都有<br>%的时候，不会使用索引。如LIKE ‘%5400%’ 这种查询不会引用索引，<br>而LIKE ‘X5400%’ 则会引用范围索引。<br>一个实际例子：<br>查询营业编号 YY_BH LIKE ‘%5400%’ 这个条件会产生全表扫描，<br>如果改成 YY_BH LIKE ‘X5400%’ OR YY_BH LIKE ‘B5400%’<br>则会利用YY_BH 的索引进行两个范围的查询，性能肯定大大提高。7.(重点,必须说)避免在索引列上使用计算和函数,这样索引就不能使用<br>举例:<br>低效：<br>SELECT … FROM DEPT WHERE SAL * 12 &gt; 25000;<br>高效:<br>SELECT … FROM DEPT WHERE SAL &gt; 25000&#x2F;12;8.(重点 必须说)用UNION-ALL 替换UNION，<br>因为UNION-ALL不会过滤重复数据而且不会自动排序，<br>所执行效率要快于UNION。1. （优化,重点,3个方面 a.缓存 b.分段批量 c.存储过程）减少访问数据库的次数<br>举例:如果批量删除多条数据，可以用 delete from tableName where id<br>in (1,2,3)<br>而不要用多条delete语句进行删除10.（重点 必须说）用TRUNCATE替代DELETE<br>TRUNCATE不记录日志，DELETE记录日志，所以TRUNCATE要快于DELETE<br>但是一旦用TRUNCATE进行删除就不能进行恢复,TRUNCATE是删除整张表的数据<br>不能加where条件。<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;mysql,sqlserver中如果<br>id为自增类型，那么如果用TRUNCATE删除，则id字段再插入数据时从1开始，<br>如果delete删除的话，则从删除之前的id的值继续增长。四、防sql注入<br>针对防sql注入，我们通常是这样做的：<br>首先在前台页面对用户输入信息进行js验证，对一些特殊字符进行屏蔽，<br>比如：or ,单引号，–，&#x3D; ，还有就是限制用户名输入的长度，我们一般<br>将其限制在6—13位。另外，对于用户的敏感信息我们进行Md5加密，还有<br>，为了增加用户体验度和用户友好度，为了不使用户看到一些详细的异常信息<br>我们会进行错误信息页面的定制，像404,500错误。另一个我层面讲，这样做<br>也是为了保护我们的一些重要信息。此外，我们会给特定的人分配定定的权限<br>，而不是给其分配管理员权限！<br>sql注入所谓SQL注入，就是通过一些含有特殊字符的sql语句发送到服务器欺骗服务器并进行攻击。（特殊字符：or, 单引号，–，空格）<br>Sql注入的防护<br>1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式（js正则或者java后台正则），或限制长度；对单引号和双”-“进行转换等。<br>2.永远不要使用动态拼装sql，使用参数化的sql。（永远不要使用+号拼接sql字符串，而是使用？传参的方式进行）<br>3.不要给用户太高的权限而根据需求进行赋权<br>4.对敏感信息进行加密 如md5(单向加密不可逆转)。<br>5.自定义错误页面。目的是为了不把我们的程序的bug暴露在别有用心的人的面前。而去不会让用户看到报错的页面，也提高了用户的体验度。SQL注入防范<br>使用参数化的过滤性语句<br>　　要防御SQL注入，用户的输入就绝对不能直接被嵌入到SQL语句中。恰恰相反，用户的输入必须进行过滤，或者使用参数化的语句。参数化的语句使用参数而不是将用户输入嵌入到语句中。在多数情况中，SQL语句就得以修正。然后，用户输入就被限于一个参数。<br>输入验证　　检查用户输入的合法性，确信输入的内容只包含合法的数据。数据检查应当在客户端和服务器端（java代码）都执行之所以要执行服务器端验证，是为了弥补客户端验证机制脆弱的安全性。<br>　　在客户端，攻击者完全有可能获得网页的源代码，修改验证合法性的脚本（或者直接删除脚本），然后将非法内容通过修改后的表单提交给服务器。因此，要保证验证操作确实已经执行，唯一的办法就是在服务器端也执行验证。你可以使用许多内建的验证对象，例如Regular Expression Validator，它们能够自动生成验证用的客户端脚本，当然你也可以插入服务器端的方法调用。如果找不到现成的验证对象，你可以通过Custom Validator自己创建一个。<br>错误消息处理　　防范SQL注入，还要避免出现一些详细的错误消息，因为黑客们可以利用这些消息。要使用一种标准的输入确认机制来验证所有的输入数据的长度、类型、语句、企业规则等。<br>加密处理<br>将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入SQL命令。<br>存储过程来执行所有的查询　　SQL参数的传递方式将防止攻击者利用单引号和连字符实施攻击。此外，它还使得数据库权限可以限制到只允许特定的存储过程执行，所有的用户输入必须遵从被调用的存储过程的安全上下文，这样就很难再发生注入式攻击了。<br>使用专业的漏洞扫描工具　　攻击者们目前正在自动搜索攻击目标并实施攻击，其技术甚至可以轻易地被应用于其它的Web架构中的漏洞。企业应当投资于一些专业的漏洞扫描工具，如大名鼎鼎的Acunetix的Web漏洞扫描程序等。一个完善的漏洞扫描程序不同于网络扫描程序，它专门查找网站上的SQL注入式漏洞。最新的漏洞扫描程序可以查找最新发现的漏洞。<br>确保数据库安全　　锁定你的数据库的安全，只给访问数据库的web应用功能所需的最低的权限，撤销不必要的公共许可，使用强大的加密技术来保护敏感数据并维护审查跟踪。如果web应用不需要访问某些表，那么确认它没有访问这些表的权限。如果web应用只需要只读的权限，那么就禁止它对此表的 drop 、insert、update、delete 的权限，并确保数据库打了最新补丁。<br>安全审评<br>在部署应用系统前，始终要做安全审评。建立一个正式的安全过程，并且每次做更新时，要对所有的编码做审评。开发队伍在正式上线前会做很详细的安全审评，然后在几周或几个月之后他们做一些很小的更新时，他们会跳过安全审评这关， “就是一个小小的更新，我们以后再做编码审评好了”。请始终坚持做安全审评。<br>五、数据库中常用术语：<br>ddl:数据定义语言 Create Drop Alter<br>dml:数据操纵语言 insert update delete select<br>dcl:数据控制语言 grant revoke<br>tcl:事务控制语言 commit rollback<br>深入java虚拟机以及大数据1.jvm的相关概念<br>当List放了大量的数据超过jvm中所能容纳的内存后，就会发生堆溢出。<br>当递归调用没有临界退出条件就会出现 栈溢出。当批量导入大量数据或者用dom4j解析大的xml文件的时候，<br>会出现 堆溢出，这个时候可以通过分段批量提交以及用<br>sax代替dom4j来解决问题。heap(堆)，stack(栈)jvm的结构细分及其概述?Java 虚拟机有一个堆，堆是运行时数据区域，<br>所有类实例和数组的内存均从此处分配。<br>堆是在 Java 虚拟机启动时创建的。”<br>“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。<br>可以看出JVM主要管理两种类型的内存：堆和非堆。<br>简单来说堆就是Java代码可及的内存，是留给开发人员使用的；<br>非堆就是JVM留给自己用的。jvm 内存结构？<br>堆： 逻辑上是连续,物理上可以处于不连续的内存空间中，<br>里面存储的是对象实例以及数组。可以细分为新生代，老生代。<br>通过-Xmx和-Xms控制大小。虚拟机栈：基本数据类型，对象引用(地址，指针)。本地方法栈（了解）:它与虚拟机栈发挥的作用差不多，区别在于虚拟机栈为java方法<br>的执行提供服务，而本地方法栈为虚拟机使用到的Native(本地)方法服务。方法区：放了所加载的类的信息（名称、修饰符等）、类中的静态变量、<br>类中定义为final类型的常量、类中的Field信息、类中的方法信息<br>在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代，<br>默认为64M，可通过-XX:PermSize以及-XX:MaxPermSize来指定其大小在服务器启动的时候报内存溢出是因为方法区太小，也就相当于持久代的内存太小。<br>通过-XX:PermSize以及-XX:MaxPermSize来指定其大小，可以解决这个问题。常量池是方法区的一部分,用来存储常量信息。如String就存储在<br>常量池中。计数器（了解）:通过该计数器的值来选取下一条要执行的字节码指令。GC是什么，为什么要有GC？<br>GC就是垃圾回收，java这种语言是动态分配内存大小的，并且依靠<br>垃圾回收机制来完成对分配内存空间的回收，从而来避免内存溢出的问题，<br>也在一定程度上降低了程序员工作的复杂度。jvm中的GC采用了generation（分代回收）算法，<br>因为大多数的对象存活的时间比较短，<br>而少部分的对象才能够长时间存活。<br>因此，jvm将堆内存划分为年轻代（young generation）和<br>年老代（old generation）。<br>年轻代中的对象通常建立时间不久，且大部分生命周期也很短；<br>年老代中的对象则已经创建比较久了，<br>其声明周期也相对年轻代比较长。<br>按照上面的划分，jvm在做GC时也进行了区别对待，<br>对年轻代GC会相对比较频繁，且采用了copying(复制)算法；<br>年老代的GC相对比较少，且采用的是tracing算法的一种，<br>是标记-清除-压缩。JVM内存限制(最大值)JVM内存的最大值跟操作系统有很大的关系。<br>简单的说就32位处理器虽然 可控内存空间有4GB,<br>但是具体的操作系统会给一个限制，<br>这个限制一般是2GB-3GB<br>（一般来说Windows系统下为1.5G-2G，Linux系统 下为2G-3G），<br>而64bit以上的处理器就不会有限制了。Java 监视和管理控制台：<br>JConsole 使您能够在运行时监视各种 JVM 资源统计信息。<br>这种特性特别适用于检测死锁、内存泄漏。<br>它可以连接到一个本地或远程 JVM 并可用来进行监视：<br>线程状态（包括相关的锁）<br>内存使用情况<br>垃圾收集<br>运行时信息<br>JVM 信息jvm的调优?开启-Server模式，增大堆的大小，以及持久代的大小，从而<br>提高程序的运行效率，并且将初始堆大小和最大堆大小设置为<br>一样的值从而避免了堆增长会带来额外压力。持久代大小的设置<br>同理，也设置为初始大小和最大大小一样大。jvm的类加载机制? jvm中类的生命周期？生命周期：加载、连接、初始化，使用，卸载对象基本上都是在jvm的堆区中创建，在创建对象之前，<br>会触发类加载（加载、连接、初始化），<br>当类初始化完成后，<br>根据类信息在堆中实例化类对象，<br>初始化非静态变量、非静态代码以及默认构造方法，<br>当对象使用完之后会在合适的时候被jvm垃圾收集器回收。要经过三步：加载（Load），链接（Link），初始化（Initializ）。<br>其中链接又可分为校验（Verify），准备（Prepare），解析（Resolve）三步。<br>ClassLoader就是用来装载的。通过指定的className，找到二进制码，<br>生成Class实例，放到JVM中。ClassLoader从顶向下分为 :Bootstrap ClassLoader:引导类加载器，<br>它负责加载Java的核心类(如rt.jar)Extension ClassLoader:扩展类加载器,<br>它负责加载JRE的扩展目录<br>（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext）中的JAR包System ClassLoader:系统（也称为应用）类加载器，<br>它负责在JVM被启动时加载来自在命令java中的-classpath<br>中的JAR包User-Defined ClassLoader：用户自定义的类加载器linux中的命令：ps -ef | grep :查看进程信息vi:文件编辑命令more:分页查看命令top:常用的性能分析工具,能够实时显示系统中各个进程的资源占用状况ifconfig:显示或配置网络设备的命令ping:它通常用来测试与目标主机的连通性rsync、scp：文件同步命令<br>2.云计算+大数据的具体技术实现方案:Hadoop是一个能够对大量数据进行分布式处理的软件框架。<br>它以并行的方式工作，通过并行处理加快处理速度,<br>维护多个工作数据副本,<br>具有可伸缩性，能够处理 PB 级数据.hadoop 由许多元素构成。其最底部是HDFS，<br>它存储 Hadoop 集群中所有存储节点上的文件。<br>HDFS的上一层是MapReduce 引擎.hadoop下的子项目:<br>HDFS:Hadoop分布式文件系统<br>MapReduce：并行计算框架（建立在HDFS上的）<br>HBase: 类似Google BigTable的分布式NoSQL 列数据库<br>Hive：数据仓库工具<br>Zookeeper：分布式锁设施<br>Pig: 大数据分析平台，为用户提供多种接口行业知识(了解):<br>存储容量：是该存储设备上可以存储数据的最大数量，通常使用千字节（kb kilobyte）、兆字节（MB megabyte）、吉字节（GB, gigabyte）、太字节（TB ，terabyte）和PB(Petabyte)、EB(Exabyte)等来衡量。<br>1KB&#x3D;2(10)B&#x3D;1024B； 括号中的数字为2的指数(即多少次方)<br>1MB&#x3D;2(10)KB&#x3D;1024KB&#x3D;2(20)B；<br>1GB&#x3D;2(10)MB&#x3D;1024MB&#x3D;2(30)B。<br>1TB&#x3D;2(10) GB&#x3D;1024GB&#x3D;2(40)B<br>1PB&#x3D;2(10) TB&#x3D;1024TB&#x3D;2(50)B<br>1EB&#x3D;2(10) PB&#x3D;1024PB&#x3D;2(60)B<br>1Byte(相當於一個英文字母，您的名字相當6Bytes(6B)。<br>Kilobyte(KB)&#x3D;1024B相當於一則短篇故事的內容。<br>Megabyte(MB)&#x3D;l024KB相當於一則短篇小說的文字內容。<br>Gigabyte(GB)&#x3D;1024MB相當於貝多芬第五樂章交響曲的樂譜內容。<br>Terabyte(TB)&#x3D;1024GB相當於一家大型醫院中所有的X光圖片資訊量。<br>Petabyte(PB)&#x3D;l024TB相當於50%的全美學術研究圖書館藏書資訊內容。<br>Exabyte (EB)&#x3D;1024PB；5EB相當於至今全世界人類所講過的話語。<br>Zettabyte(ZB)&#x3D;1024EB如同全世界海灘上的沙子數量總和。<br>Yottabyte(YB)&#x3D;1024ZB相當於7000位人類體內的微細胞總和。1、注册Jdbc驱动程序的三种方式1、用JDBC如何调用存储过程<br>代码如下：<br>1、JDBC中的PreparedStatement相比Statement的好处<br>答：一个sql命令发给服务器去执行的步骤为：语法检查，语义分析，编译成内部指令，缓存指令，执行指令等过程。<br>select * from student where id &#x3D;3—-缓存–xxxxx二进制命令<br>select * from student where id &#x3D;3—-直接取-xxxxx二进制命令<br>select * from student where id &#x3D;4— -会怎么干？<br>如果当初是select * from student where id &#x3D;?— -又会怎么干？<br>上面说的是性能提高<br>可以防止sql注入。1. 写一个用jdbc连接并访问oracle数据的程序代码<br>2、Class.forName的作用?为什么要用?<br>答：按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，则返回代表该字节码的Class实例对象，否则，按类加载器的委托机制去搜索和加载该类，如果所有的类加载器都无法加载到该类，则抛出ClassNotFoundException。加载完这个Class字节码后，接着就可以使用Class字节码的newInstance方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时才能确定，这时候就需要使用Class.forName去动态加载该类，这个类名通常是在配置文件中配置的，例如，spring的ioc中每次依赖注入的具体类就是这样配置的，jdbc的驱动类名通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类名。<br>3、大数据量下的分页解决方法。<br>答：最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。再sql语句无法实现分页的情况下，可以考虑对大的结果集通过游标定位方式来获取某页的数据。<br>sql语句分页，不同的数据库下的分页方案各不一样，下面是主流的三种数据库的分页sql：<br>sql server:<br>36、说出数据连接池的工作机制是什么?<br>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>实现方式，返回的Connection是原始Connection的代理，代理Connection的close方法不是真正关连接，而是把它代理的Connection对象还回到连接池中。4、为什么要用 ORM?  和 JDBC 有何不一样?<br>orm是一种思想，就是把object转变成数据库中的记录，或者把数据库中的记录转变成objecdt，我们可以用jdbc来实现这种思想，其实，如果我们的项目是严格按照oop方式编写的话，我们的jdbc程序不管是有意还是无意，就已经在实现orm的工作了。<br>现在有许多orm工具，它们底层调用jdbc来实现了orm工作，我们直接使用这些工具，就省去了直接使用jdbc的繁琐细节，提高了开发效率，现在用的较多的orm工具是hibernate。也听说一些其他orm工具，如toplink,ojb等。jdbc<br>1 JDBC连接数据库6步<br>1.Load the JDBC Driver<br>2.Establish the Database Connection<br>3.Create a Statement Object<br>4.Execute a Query<br>5.Process the Results<br>6.Close the Connection<br>3.select count（<em>） from student 和select count（id） from student 之间的区别。<br>答案：<br>select count(</em>) 统计所有学生的记录个数，包括空记录。<br>Select count(Id) 统计所有学生的记录个数，不包括null记录。<br>4假设现在有表system.table1，表中有三个字段：id(数值型)、name（字符型）、age（数值型）写出SQL语句完成如下功能：在表中查出年龄大于20，且名字以“王”开头的记录，并且按照年龄的倒叙排列出来（年龄大的在前面）。<br>答案：<br>Select * from system.table1 where age&gt;20 and name like ‘王%’ order by age DESC;<br>5 .创建CUSTOMERS表，字段为：ID：（非空，主键）bigint，NAME：（非空）varchar，AGE：int类型；创建ORDERS表，字段为：ID：（非空，主键，）bigint，ORDER_NUMBER：（非空）varchar，PRICE：double，CUSTOMER_ID ：（外键）bigint，设置级连删除；<br>答案：create table CUSTOMBERS(<br>ID bigint not null,<br>NAME varchar(15),<br>AGE int,<br>primary key (ID)<br>);<br>create table ORDERS(<br>ID bigint not null,<br>ORDER_NUMBER varchar(15) not nulll,<br>PRICE double precision,<br>CUSTOMER_ID bigint,<br>primary key(ID),<br>);<br>alter table ORDERS add constraint FK_CUSTOMER foreign key (CUSTOMER_ID) references CUSTOMERS(ID) on delete cascade;<br>6.使用左外连接查询，ORDERS 和 CUSTOMERS 表，<br>答案：select c.ID, o.CUSTOMER_ID,c.NAME, o.ID ORDER_ID,ORDER_NUMBER from CUSTOMERS c left outer join ORDERS o no c.ID&#x3D;o.CUSTOMER_ID;<br>29 .简述数据库事务的生命周期？（可画流程图）<br>答案：7.delete from tablea &amp; truncate table tablea的区别<br>　　 truncate 语句执行速度快,占资源少,并且只记录页删除的日志；<br>　　 delete 对每条记录的删除均需要记录日志jdbc数据访问技术<br>1、JDBC如何做事务处理？<br>Con.setAutoCommit(false)<br>Con.commit();<br>Con.rollback();<br>2、写出几个在Jdbc中常用的接口<br>preparedStatement,callableStatement,statement,Connection,ResultSet<br>3、简述你对Statement,PreparedStatement,CallableStatement的理解<br>statement用于执行静态 SQL 语句并返回它所生成结果的对象，在执行时确定sql。PreparedStatement表示预编译的 SQL 语句的对象。 SQL 语句被预编译并且存储在 PreparedStatement 对象中。然后可以使用此对象高效地多次执行该语句，可以传参数，在得到PreparedStatement对象时确定sql.<br>CallableStatement用于执行 SQL 存储过程的接口。如果有输出参数要注册说明是输出参数。4、Java中访问数据库的步骤？<br>1连接Oracle数据库<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>Connection con&#x3D;DriverManager.openConnection(“jdbc:oracle:thin:@localhost:1521:DataBase ”,” UserName”,”Password ”)<br>1.利用JDBC检索出表中的数据<br>Class.forName(“”);<br>Connection con&#x3D;DriverManager.openConnection(“ ”,” ”,” ”)<br>preparedStatment ps&#x3D;Con.preparedStatment(“select * from ［table］”);<br>ResultSet rs&#x3D;ps.executeQuery();<br>While(rs.next)<br>{<br>Rs.getString(1) 或rs.getString(“字段名”)<br>}<br>5、JDBC中的核心类及其作用是什么?<br>DriverManager<br>Class.forName();<br>DriverManager.openConnection(“”,”sa”,””)<br>Connection<br>PreparedStatement(Statement)<br>ResultSet rs&#x3D;executeQuery() dql<br>While(rs.next())<br>{}<br>executeUpdate() dml ddl<br>6、执行存储过程用那一个类，如何操作输出参数?(操作)<br>CallableStatement c&#x3D;con. prepareCall (“{call getCustomerName(?,?)}”);<br>c.setString(1,”1”);<br>c.registerOutParameter(2,java.sql.Types.VARCHAR);<br>c.execute();<br>c.getString(2);<br>8、可能会让你写一段Jdbc连Oracle的程序.<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>Connection con&#x3D;DriverManager.getConnection(“jdbc:oracle:thin:@localhost:1521:accp”,”system”,”system”);<br>9、Class.forName的作用?为什么要用?<br>注册一个数据库驱动，将驱动加载到当前的JVM中。<br>10、Jdo是什么?<br>JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。(o&#x2F;rMapping工具 集合处理)<br>11、在ORACLE大数据量下的分页解决方法。一般用截取ID方法，还有是三层嵌套方法<br>1、注册Jdbc驱动程序的三种方式1、用JDBC如何调用存储过程<br>代码如下：<br>1、JDBC中的PreparedStatement相比Statement的好处<br>答：一个sql命令发给服务器去执行的步骤为：语法检查，语义分析，编译成内部指令，缓存指令，执行指令等过程。<br>select * from student where id &#x3D;3—-缓存–?xxxxx二进制命令<br>select * from student where id &#x3D;3—-直接取-?xxxxx二进制命令<br>select * from student where id &#x3D;4— -?会怎么干？<br>如果当初是select * from student where id &#x3D;?— -?又会怎么干？<br>上面说的是性能提高<br>可以防止sql注入。1. 写一个用jdbc连接并访问oracle数据的程序代码<br>2、Class.forName的作用?为什么要用?<br>答：按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，则返回代表该字节码的Class实例对象，否则，按类加载器的委托机制去搜索和加载该类，如果所有的类加载器都无法加载到该类，则抛出ClassNotFoundException。加载完这个Class字节码后，接着就可以使用Class字节码的newInstance方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时才能确定，这时候就需要使用Class.forName去动态加载该类，这个类名通常是在配置文件中配置的，例如，spring的ioc中每次依赖注入的具体类就是这样配置的，jdbc的驱动类名通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类名。<br>3、大数据量下的分页解决方法。<br>答：最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。再sql语句无法实现分页的情况下，可以考虑对大的结果集通过游标定位方式来获取某页的数据。<br>sql语句分页，不同的数据库下的分页方案各不一样，下面是主流的三种数据库的分页sql：</li></ol><p>9.Class.forName的作用?为什么要用：<br>答：调用该访问返回一个以字符串指定类名的类的对象。<br>10.Jdo是什么：<br>答:JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。21.存储过程和函数的区别：<br>存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。<br>22.事务是什么：<br>事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务：<br>原子性：<br>事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。<br>一致性：<br>事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。<br>隔离性：<br>由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。<br>持久性：<br>事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。<br>23.游标的作用？如何知道游标已经到了最后：<br>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。<br>24.触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：<br>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。<br>语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。<br>25.bean 实例的生命周期：<br>         对于Stateless Session Bean、Entity Bean、Message Driven Bean一般存在缓冲池管理，而对于Entity Bean和Statefull Session Bean存在Cache管理，通常包含创建实例，设置上下文、创建EJB Object（create）、业务方法调用、remove等过程，对于存在缓冲池管理的Bean，在create之后实例并不从内存清除，而是采用缓冲池调度机制不断重用实例，而对于存在Cache管理的Bean则通过激活和去激活机制保持Bean的状态并限制内存中实例数量。1.dao 是什么及作用<br>dao 是数据访问对象 DAO负责管理与数据源的连接来获取和储存其中的数据2.SQL中有个PrepardStatement对象，用Java实现连接Oracle数据库，运用PrepardStatement对象。ConnDB.java<br>package demo.bean;<br>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.PreparedStatement;<br>import java.sql.ResultSet;public class ConnDB {public static void main(String[] args) {<br>try{<br>String driver &#x3D; “oracle.jdbc.driver.OracleDriver”;<br>String url&#x3D;”jdbc:oracle:thin:@localhost:1521:yf”;<br>String username &#x3D; “scott”;<br>String password &#x3D; “tiger”;<br>DriverManager.registerDriver( new oracle.jdbc.OracleDriver());<br>Connection con &#x3D; DriverManager.getConnection(url, username, password);<br>PreparedStatement stm &#x3D; con.prepareStatement(“select sysdate from dual”);</p><pre><code>    ResultSet rs = stm.executeQuery();			
    while(rs.next())&#123;
        System.out.print(rs.getString(1));				
    &#125;
    
&#125;catch(Exception e)&#123;
    e.printStackTrace();
&#125;		
</code></pre><p>}}JDK1.8-Stream()使用详解<br>为什么需要Stream<br>Stream作为Java8的一大亮点，它与java.io包里的InputStream和OutputStream是完全不同的概念。它也不同于SAX对XML解析的Stream，也不是AmazonKinesis对大数据实时处理的Stream。<br>Java8中的Stream是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregateoperation），或者大批量数据操作(bulkdataoperation)。StreamAPI借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用fork&#x2F;join并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错,但使用StreamAPI无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java8中首次出现的java.util.stream是一个函数式语言+多核时代综合影响的产物。<br>什么是聚合操作<br>传统的J2EE应用中，Java代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：<br>客户每月平均消费金额<br>最昂贵的在售商品<br>本周完成的有效订单（排除了无效的）<br>取十个数据样本作为首页推荐这类的操作。<br>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而Java的集合API中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用Iterator来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在Java7中，如果要发现type为grocery的所有交易，然后返回以交易值降序排序好的交易ID集合，我们需要这样写：<br>清单1.Java7的排序、取值实现<br>List&lt;Transaction&gt;groceryTransactions&#x3D;newArraylist&lt;&gt;();<br>for(Transactiont:transactions){<br>if(t.getType()&#x3D;&#x3D;Transaction.GROCERY){<br>groceryTransactions.add(t);<br>}<br>}<br>Collections.sort(groceryTransactions,newComparator(){<br>publicintcompare(Transactiont1,Transactiont2){<br>returnt2.getValue().compareTo(t1.getValue());<br>}<br>});<br>List&lt;Integer&gt;transactionIds&#x3D;newArrayList&lt;&gt;();<br>for(Transactiont:groceryTransactions){<br>transactionsIds.add(t.getId());<br>}<br>而在Java8使用Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。<br>清单2.Java8的排序、取值实现<br>List&lt;Integer&gt;transactionsIds&#x3D;transactions.parallelStream().<br>filter(t-&gt;t.getType()&#x3D;&#x3D;Transaction.GROCERY).<br>sorted(comparing(Transaction::getValue).reversed()).<br>map(Transaction::getId).<br>collect(Collectors.toList());<br>Stream总览<br>什么是流<br>Stream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。<br>Stream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br>而和迭代器又不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream的并行操作依赖于Java7中引入的Fork&#x2F;Join框架（JSR166y）来拆分任务和加速处理过程。Java的并行API演变历程基本如下：<br>1.1.0-1.4中的java.lang.Thread<br>2.5.0中的java.util.concurrent<br>02.6.0中的Phasers等<br>10.7.0中的Fork&#x2F;Join框架<br>1.8.0中的Lambda<br>Stream的另外一大特点是，数据源本身可以是无限的。<br>流的构成<br>当我们使用一个流的时候，通常包括三个基本步骤：<br>获取一个数据源（source）→数据转换→执行操作获取想要的结果，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。<br>图1.流管道(StreamPipeline)的构成有多种方式生成StreamSource：<br>从Collection和数组<br>Collection.stream()<br>Collection.parallelStream()<br>Arrays.stream(Tarray)orStream.of()<br>从BufferedReader<br>java.io.BufferedReader.lines()<br>静态工厂<br>java.util.stream.IntStream.range()<br>java.nio.file.Files.walk()<br>自己构建<br>java.util.Spliterator<br>其它<br>Random.ints()<br>BitSet.stream()<br>Pattern.splitAsStream(java.lang.CharSequence)<br>JarFile.stream()<br>流的操作类型分为两种：<br>Intermediate：一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射&#x2F;过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。<br>Terminal：一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个sideeffect。<br>在对于一个Stream进行多次转换操作(Intermediate操作)，每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是N（转换次数）个for循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是lazy的，多个转换操作只会在Terminal操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在Terminal操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。<br>还有一种操作被称为short-circuiting。用以指：<br>对于一个intermediate操作，如果它接受的是一个无限大（infinite&#x2F;unbounded）的Stream，但返回一个有限的新Stream。<br>对于一个terminal操作，如果它接受的是一个无限大的Stream，但能在有限的时间计算出结果。<br>当操作一个无限大的Stream，而又希望在有限时间内完成操作，则在管道内拥有一个short-circuiting操作是必要非充分条件。<br>清单3.一个流操作的示例<br>intsum&#x3D;widgets.stream()<br>.filter(w-&gt;w.getColor()&#x3D;&#x3D;RED)<br>.mapToInt(w-&gt;w.getWeight())<br>.sum();<br>stream()获取当前小物件的source，filter和mapToInt为intermediate操作，进行数据筛选和转换，最后一个sum()为terminal操作，对符合条件的全部小物件作重量求和。<br>流的使用详解<br>简单说，对Stream的使用就是实现一个filter-map-reduce过程，产生一个最终结果，或者导致一个副作用（sideeffect）。<br>流的构造与转换<br>下面提供最常见的几种构造Stream的样例。<br>清单4.构造流的几种常见方法<br>&#x2F;&#x2F;1.Individualvalues<br>Streamstream&#x3D;Stream.of(“a”,”b”,”c”);<br>&#x2F;&#x2F;2.Arrays<br>String[]strArray&#x3D;newString[]{“a”,”b”,”c”};<br>stream&#x3D;Stream.of(strArray);<br>stream&#x3D;Arrays.stream(strArray);<br>&#x2F;&#x2F;3.Collections<br>List&lt;String&gt;list&#x3D;Arrays.asList(strArray);<br>stream&#x3D;list.stream();<br>需要注意的是，对于基本数值型，目前有三种对应的包装类型Stream：<br>IntStream、LongStream、DoubleStream。当然我们也可以用Stream&lt;Integer&gt;、Stream&lt;Long&gt;&gt;、Stream&lt;Double&gt;，但是boxing和unboxing会很耗时，所以特别为这三种基本数值型提供了对应的Stream。<br>Java8中还没有提供其它数值型Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种Stream进行。<br>清单5.数值流的构造<br>IntStream.of(newint[]{1,2,3}).forEach(System.out::println);<br>IntStream.range(1,3).forEach(System.out::println);<br>IntStream.rangeClosed(1,3).forEach(System.out::println);<br>清单6.流转换为其它数据结构<br>&#x2F;&#x2F;1.Array<br>String[]strArray1&#x3D;stream.toArray(String[]::new);<br>&#x2F;&#x2F;2.Collection<br>List&lt;String&gt;list1&#x3D;stream.collect(Collectors.toList());<br>List&lt;String&gt;list2&#x3D;stream.collect(Collectors.toCollection(ArrayList::new));<br>Setset1&#x3D;stream.collect(Collectors.toSet());<br>Stackstack1&#x3D;stream.collect(Collectors.toCollection(Stack::new));<br>&#x2F;&#x2F;3.String<br>Stringstr&#x3D;stream.collect(Collectors.joining()).toString();<br>一个Stream只可以使用一次，上面的代码为了简洁而重复使用了数次。<br>流的操作<br>接下来，当把一个数据结构包装成Stream后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。<br>Intermediate（中间操作）<br>map(mapToInt,flatMap等)、filter、distinct、sorted、peek、limit、skip、parallel、sequential、unordered<br>Terminal（末端操作）<br>forEach、forEachOrdered、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst、findAny、iterator<br>Short-circuiting（由无限的流，转到有限的流，不管是中间操作还是终结操作都叫做短路）<br>anyMatch、allMatch、noneMatch、findFirst、findAny、limit<br>我们下面看一下Stream的比较典型用法。<br>map&#x2F;flatMap我们先来看map。如果你熟悉scala这类函数式语言，对这个方法应该很了解，它的作用就是把inputStream的每一个元素，映射成outputStream的另外一个元素。<br>清单7.转换大写<br>List&lt;String&gt;output&#x3D;wordList.stream().<br>map(String::toUpperCase).<br>collect(Collectors.toList());<br>这段代码把所有的单词转换为大写。<br>清单8.平方数<br>List&lt;Integer&gt;nums&#x3D;Arrays.asList(1,2,3,4);<br>List&lt;Integer&gt;squareNums&#x3D;nums.stream().<br>map(n-&gt;n*n).<br>collect(Collectors.toList());<br>这段代码生成一个整数list的平方数{1,4,9,16}。<br>从上面例子可以看出，map生成的是个1:1映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要flatMap。<br>清单9.一对多<br>Stream&lt;List&lt;Integer&gt;&gt;inputStream&#x3D;Stream.of(<br>Arrays.asList(1),<br>Arrays.asList(2,3),<br>Arrays.asList(4,5,6)<br>);<br>Stream&lt;Integer&gt;outputStream&#x3D;inputStream.<br>flatMap((childList)-&gt;childList.stream());<br>flatMap把inputStream中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终output的新Stream里面已经没有List了，都是直接的数字。<br>filterfilter对原始Stream进行某项测试，通过测试的元素被留下来生成一个新Stream。<br>清单10.留下偶数<br>Integer[]sixNums&#x3D;{1,2,3,4,5,6};<br>Integer[]evens&#x3D;<br>Stream.of(sixNums).filter(n-&gt;n%2&#x3D;&#x3D;0).toArray(Integer[]::new);<br>经过条件“被2整除”的filter，剩下的数字为{2,4,6}。<br>清单11.把单词挑出来<br>List&lt;String&gt;output&#x3D;reader.lines().<br>flatMap(line-&gt;Stream.of(line.split(REGEXP))).<br>filter(word-&gt;word.length()&gt;0).<br>collect(Collectors.toList());<br>这段代码首先把每行的单词用flatMap整理到新的Stream，然后保留长度不为0的，就是整篇文章中的全部单词了。<br>forEachforEach方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式。<br>清单12.打印姓名（forEach和pre-java8的对比）<br>&#x2F;&#x2F;Java8<br>roster.stream()<br>.filter(p-&gt;p.getGender()&#x3D;&#x3D;Person.Sex.MALE)<br>.forEach(p-&gt;System.out.println(p.getName()));<br>&#x2F;&#x2F;Pre-Java8<br>for(Personp:roster){<br>if(p.getGender()&#x3D;&#x3D;Person.Sex.MALE){<br>System.out.println(p.getName());<br>}<br>}<br>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach是为Lambda而设计的，保持了最紧凑的风格。而且Lambda表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时forEach本身的实现不需要调整，而Java8以前的for循环code可能需要加入额外的多线程逻辑。<br>但一般认为，forEach和常规for循环的差异不涉及到性能，它们仅仅是函数式风格与传统Java风格的差别。<br>另外一点需要注意，forEach是terminal操作，因此它执行后，Stream的元素就被“消费”掉了，你无法对一个Stream进行两次terminal运算。下面的代码是错误的：<br>stream.forEach(element-&gt;doOneThing(element));<br>stream.forEach(element-&gt;doAnotherThing(element));<br>相反，具有相似功能的intermediate操作peek可以达到上述目的。如下是出现在该apijavadoc上的一个示例。<br>清单13.peek对每个元素执行操作并返回一个新的Stream<br>Stream.of(“one”,”two”,”three”,”four”)<br>.filter(e-&gt;e.length()&gt;3)<br>.peek(e-&gt;System.out.println(“Filteredvalue:”+e))<br>.map(String::toUpperCase)<br>.peek(e-&gt;System.out.println(“Mappedvalue:”+e))<br>.collect(Collectors.toList());<br>forEach不能修改自己包含的本地变量值，也不能用break&#x2F;return之类的关键字提前结束循环。<br>findFirst这是一个termimal兼short-circuiting操作，它总是返回Stream的第一个元素，或者空。<br>这里比较重点的是它的返回值类型：Optional。这也是一个模仿Scala语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免NullPointerException。<br>清单14.Optional的两个用例<br>StringstrA&#x3D;”abcd”,strB&#x3D;null;<br>print(strA);<br>print(“”);<br>print(strB);<br>getLength(strA);<br>getLength(“”);<br>getLength(strB);<br>publicstaticvoidprint(Stringtext){<br>&#x2F;&#x2F;Java8<br>Optional.ofNullable(text).ifPresent(System.out::println);<br>&#x2F;&#x2F;Pre-Java8<br>if(text!&#x3D;null){<br>System.out.println(text);<br>}<br>}<br>publicstaticintgetLength(Stringtext){<br>&#x2F;&#x2F;Java8<br>returnOptional.ofNullable(text).map(String::length).orElse(-1);<br>&#x2F;&#x2F;Pre-Java8<br>&#x2F;&#x2F;returnif(text!&#x3D;null)?text.length():-1;<br>};<br>在更复杂的if(xx!&#x3D;null)的情况中，使用Optional代码的可读性更好，而且它提供的是编译时检查，能极大的降低NPE这种RuntimeException对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。<br>Stream中的findAny、max&#x2F;min、reduce等方法等返回Optional值。还有例如IntStream.average()返回OptionalDouble等等。<br>reduce这个方法的主要作用是把Stream元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面Stream的第一个、第二个、第n个元素组合。从这个意义上说，字符串拼接、数值的sum、min、max、average都是特殊的reduce。例如Stream的sum就相当于Integersum&#x3D;integers.reduce(0,(a,b)-&gt;a+b);或Integersum&#x3D;integers.reduce(0,Integer::sum);<br>也有没有起始值的情况，这时会把Stream的前面两个元素组合起来，返回的是Optional。<br>清单15.reduce的用例<br>&#x2F;&#x2F;字符串连接，concat&#x3D;”ABCD”<br>Stringconcat&#x3D;Stream.of(“A”,”B”,”C”,”D”).reduce(“”,String::concat);<br>&#x2F;&#x2F;求最小值，minValue&#x3D;-3.0<br>doubleminValue&#x3D;Stream.of(-1.5,1.0,-3.0,-2.0).reduce(Double.MAX_VALUE,Double::min);<br>&#x2F;&#x2F;求和，sumValue&#x3D;10,有起始值<br>intsumValue&#x3D;Stream.of(1,2,3,4).reduce(0,Integer::sum);<br>&#x2F;&#x2F;求和，sumValue&#x3D;10,无起始值<br>sumValue&#x3D;Stream.of(1,2,3,4).reduce(Integer::sum).get();<br>&#x2F;&#x2F;过滤，字符串连接，concat&#x3D;”ace”<br>concat&#x3D;Stream.of(“a”,”B”,”c”,”D”,”e”,”F”).<br>filter(x-&gt;x.compareTo(“Z”)&gt;0).<br>reduce(“”,String::concat);<br>上面代码例如第一个示例的reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为BinaryOperator。这类有起始值的reduce()都返回具体的对象。而对于第四个示例没有起始值的reduce()，由于可能没有足够的元素，返回的是Optional，请留意这个区别。<br>limit&#x2F;skiplimit返回Stream的前面n个元素；skip则是扔掉前n个元素（它是由一个叫subStream的方法改名而来）。<br>清单16.limit和skip对运行次数的影响<br>publicvoidtestLimitAndSkip(){<br>List&lt;Person&gt;persons&#x3D;newArrayList();<br>for(inti&#x3D;1;i&lt;&#x3D;10000;i++){<br>Personperson&#x3D;newPerson(i,”name”+i);<br>persons.add(person);<br>}<br>List&lt;String&gt;personList2&#x3D;persons.stream().<br>map(Person::getName).limit(10).skip(3).collect(Collectors.toList());<br>System.out.println(personList2);<br>}<br>privateclassPerson{<br>publicintno;<br>privateStringname;<br>publicPerson(intno,Stringname){<br>this.no&#x3D;no;<br>this.name&#x3D;name;<br>}<br>publicStringgetName(){<br>System.out.println(name);<br>returnname;<br>}<br>}<br>输出结果为：<br>name1<br>name2<br>name3<br>name4<br>name5<br>name6<br>name7<br>name8<br>name9<br>name10<br>[name4,name5,name6,name7,name8,name9,name10]<br>这是一个有10，000个元素的Stream，但在short-circuiting操作limit和skip的作用下，管道中map操作指定的getName()方法的执行次数为limit所限定的10次，而最终返回结果在跳过前3个元素后只有后面7个返回。<br>有一种情况是limit&#x2F;skip无法达到short-circuiting目的的，就是把它们放在Stream的排序操作后，原因跟sorted这个intermediate操作有关：此时系统并不知道Stream排序后的次序如何，所以sorted中的操作看上去就像完全没有被limit或者skip一样。<br>清单17.limit和skip对sorted后的运行次数无影响<br>List&lt;Person&gt;persons&#x3D;newArrayList();<br>for(inti&#x3D;1;i&lt;&#x3D;5;i++){<br>Personperson&#x3D;newPerson(i,”name”+i);<br>persons.add(person);<br>}<br>List&lt;Person&gt;personList2&#x3D;persons.stream().sorted((p1,p2)-&gt;<br>p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());<br>System.out.println(personList2);<br>上面的示例对清单13做了微调，首先对5个元素的Stream排序，然后进行limit操作。输出结果为：<br>name2<br>name1<br>name3<br>name2<br>name4<br>name3<br>name5<br>name4<br>[stream.StreamDW<code>$Person@816f27d,stream.StreamDW$</code>Person@87aac27]<br>即虽然最后的返回元素数量是2，但整个管道中的sorted表达式执行次数没有像前面例子相应减少。<br>最后有一点需要注意的是，对一个parallel的Steam管道来说，如果其元素是有序的，那么limit操作的成本会比较大，因为它的返回对象必须是前n个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用parallelStream。<br>sorted对Stream的排序通过sorted进行，它比数组的排序更强之处在于你可以首先对Stream进行各类map、filter、limit、skip甚至distinct来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单14进行优化：<br>清单18.优化：排序前进行limit和skip<br>List&lt;Person&gt;persons&#x3D;newArrayList();<br>for(inti&#x3D;1;i&lt;&#x3D;5;i++){<br>Personperson&#x3D;newPerson(i,”name”+i);<br>persons.add(person);<br>}<br>List&lt;Person&gt;personList2&#x3D;persons.stream().limit(2).sorted((p1,p2)-&gt;p1.getName().compareTo(p2.getName())).collect(Collectors.toList());<br>System.out.println(personList2);<br>结果会简单很多：<br>name2<br>name1<br>[stream.StreamDW<code>$Person@6ce253f1,stream.StreamDW$</code>Person@53d8d10a]<br>当然，这种优化是有businesslogic上的局限性的：即不要求排序后再取值。<br>min&#x2F;max&#x2F;distinctmin和max的功能也可以通过对Stream元素先排序，再findFirst来实现，但前者的性能会更好，为O(n)，而sorted的成本是O(nlogn)。同时它们作为特殊的reduce方法被独立出来也是因为求最大最小值是很常见的操作。<br>清单19.找出最长一行的长度<br>BufferedReaderbr&#x3D;newBufferedReader(newFileReader(“c:\SUService.log”));<br>intlongest&#x3D;br.lines().<br>mapToInt(String::length).<br>max().<br>getAsInt();<br>br.close();<br>System.out.println(longest);<br>下面的例子则使用distinct来找出不重复的单词。<br>清单20.找出全文的单词，转小写，并排序<br>List&lt;String&gt;words&#x3D;br.lines().<br>flatMap(line-&gt;Stream.of(line.split(“”))).<br>filter(word-&gt;word.length()&gt;0).<br>map(String::toLowerCase).<br>distinct().<br>sorted().<br>collect(Collectors.toList());<br>br.close();<br>System.out.println(words);<br>MatchStream有三个match方法，从语义上说：<br>allMatch：Stream中全部元素符合传入的predicate，返回true<br>anyMatch：Stream中只要有一个元素符合传入的predicate，返回true<br>noneMatch：Stream中没有一个元素符合传入的predicate，返回true<br>它们都不是要遍历全部元素才能返回结果。例如allMatch只要一个元素不满足条件，就skip剩下的所有元素，返回false。对清单13中的Person类稍做修改，加入一个age属性和getAge方法。<br>清单21.使用Match<br>List&lt;Person&gt;persons&#x3D;newArrayList();<br>persons.add(newPerson(1,”name”+1,10));<br>persons.add(newPerson(2,”name”+2,21));<br>persons.add(newPerson(3,”name”+3,34));<br>persons.add(newPerson(4,”name”+4,6));<br>persons.add(newPerson(5,”name”+5,55));<br>booleanisAllAdult&#x3D;persons.stream().<br>allMatch(p-&gt;p.getAge()&gt;18);<br>System.out.println(“Allareadult?”+isAllAdult);<br>booleanisThereAnyChild&#x3D;persons.stream().<br>anyMatch(p-&gt;p.getAge()&lt;12);<br>System.out.println(“Anychild?”+isThereAnyChild);<br>输出结果：<br>Allareadult?false<br>Anychild?true<br>进阶：自己生成流<br>Stream.generate通过实现Supplier接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的Stream，或者需要前后元素间维持着某种状态信息的Stream。把Supplier实例传递给Stream.generate()生成的Stream，默认是串行（相对parallel而言）但无序的（相对ordered而言）。由于它是无限的，在管道中，必须利用limit之类的操作限制Stream大小。<br>清单22.生成10个随机整数<br>Randomseed&#x3D;newRandom();<br>Supplier&lt;Integer&gt;random&#x3D;seed::nextInt;<br>Stream.generate(random).limit(10).forEach(System.out::println);<br>&#x2F;&#x2F;Anotherway<br>IntStream.generate(()-&gt;(int)(System.nanoTime()%100)).<br>limit(10).forEach(System.out::println);<br>Stream.generate()还接受自己实现的Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算Stream的每个元素值。这些都是维持状态信息的情形。<br>清单23.自实现Supplier<br>Stream.generate(newPersonSupplier()).<br>limit(10).<br>forEach(p-&gt;System.out.println(p.getName()+”,”+p.getAge()));<br>privateclassPersonSupplierimplementsSupplier&lt;Person&gt;{<br>privateintindex&#x3D;0;<br>privateRandomrandom&#x3D;newRandom();<br>@Override<br>publicPersonget(){<br>returnnewPerson(index++,”StormTestUser”+index,random.nextInt(100));<br>}<br>}<br>输出结果：<br>StormTestUser1,9<br>StormTestUser2,12<br>StormTestUser3,88<br>StormTestUser4,51<br>StormTestUser5,22<br>StormTestUser6,28<br>StormTestUser7,81<br>StormTestUser8,51<br>StormTestUser9,4<br>StormTestUser10,76<br>iterate跟reduce操作很像，接受一个种子值，和一个UnaryOperator（例如f）。然后种子值成为Stream的第一个元素，f(seed)为第二个，f(f(seed))第三个，以此类推。<br>清单24.生成一个等差数列<br>Stream.iterate(0,n-&gt;n+3).limit(10).forEach(x-&gt;System.out.print(x+””));<br>输出结果：<br>0369121518212427<br>1<br>与Stream.generate相仿，在iterate时候管道必须有limit这样的操作来限制Stream大小。<br>进阶：用Collectors来进行reduction操作<br>java.util.stream.Collectors类的主要作用就是辅助进行各类有用的reduction操作，例如转变输出为Collection，把Stream元素进行归组。<br>groupingBy&#x2F;partitioningBy<br>清单25.按照年龄归组<br>Map&lt;Integer,List&lt;Person&gt;&gt;personGroups&#x3D;Stream.generate(newPersonSupplier()).<br>limit(100).<br>collect(Collectors.groupingBy(Person::getAge));<br>Iteratorit&#x3D;personGroups.entrySet().iterator();<br>while(it.hasNext()){<br>Map.Entry&lt;Integer,List&lt;Person&gt;&gt;persons&#x3D;(Map.Entry)it.next();<br>System.out.println(“Age”+persons.getKey()+”&#x3D;”+persons.getValue().size());<br>}<br>上面的code，首先生成100人的信息，然后按照年龄归组，相同年龄的人放到同一个list中，可以看到如下的输出：<br>Age0&#x3D;2<br>Age1&#x3D;2<br>Age5&#x3D;2<br>Age8&#x3D;1<br>Age9&#x3D;1<br>Age11&#x3D;2<br>……<br>清单26.按照未成年人和成年人归组<br>Map&lt;Boolean,List&lt;Person&gt;&gt;children&#x3D;Stream.generate(newPersonSupplier()).<br>limit(100).<br>collect(Collectors.partitioningBy(p-&gt;p.getAge()&lt;18));<br>System.out.println(“Childrennumber:”+children.get(true).size());<br>System.out.println(“Adultnumber:”+children.get(false).size());<br>输出结果：<br>Childrennumber:23<br>Adultnumber:77<br>在使用条件“年龄小于18”进行分组后可以看到，不到18岁的未成年人是一组，成年人是另外一组。partitioningBy其实是一种特殊的groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true)和get(false)能即为全部的元素对象。<br>结束语<br>总之，Stream的特性可以归纳为：<br>不是数据结构<br>它没有内部存储，它只是用操作管道从source（数据结构、数组、generatorfunction、IOchannel）抓取数据。<br>它也绝不修改自己所封装的底层数据结构的数据。例如Stream的filter操作会产生一个不包含被过滤元素的新Stream，而不是从source删除那些元素。<br>所有Stream的操作必须以lambda表达式为参数<br>不支持索引访问<br>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。<br>很容易生成数组或者List<br>惰性化<br>很多Stream操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。<br>Intermediate操作永远是惰性化的。<br>并行能力<br>当一个Stream是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。<br>可以是无限的<br>集合有固定大小，Stream则不必。limit(n)和findFirst()这类的short-circuiting操作可以对无限的Stream进行运算并很快完成。JDK1.8 十大新特性详解<br>一、接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：interface Formula {<br>double calculate(int a);<br>default double sqrt(int a) {<br>return Math.sqrt(a);<br>}<br>}Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。<br>代码如下:Formula formula &#x3D; new Formula() {<br>@Override<br>public double calculate(int a) {<br>return sqrt(a * 100);<br>}<br>};<br>formula.calculate(100); &#x2F;&#x2F; 100.0<br>formula.sqrt(16); &#x2F;&#x2F; 4.0文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。<br>： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。二、Lambda 表达式首先看看在老版本的Java中是如何排列字符串的：代码如下:List&lt;String&gt; names &#x3D; Arrays.asList(“peter”, “anna”, “mike”, “xenia”);<br>Collections.sort(names, new Comparator&lt;String&gt;() {<br>@Override<br>public int compare(String a, String b) {<br>return b.compareTo(a);<br>}<br>});只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：代码如下:Collections.sort(names, (String a, String b) -&gt; {<br>return b.compareTo(a);<br>});看到了吧，代码变得 更短且更具有可读性，但是实际上还可以写得更短：<br>代码如下:Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：<br>代码如下:Collections.sort(names, (a, b) -&gt; b.compareTo(a));Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：三、函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。<br>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。示例如下：代码如下:@FunctionalInterface<br>interface Converter&lt;F, T&gt; {<br>T convert(F from);<br>}<br>Converter&lt;String, Integer&gt; converter &#x3D; (from) -&gt; Integer.valueOf(from);<br>Integer converted &#x3D; converter.convert(“123”);<br>System.out.println(converted);&#x2F;&#x2F; 123需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。<br>将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。四、方法与构造函数引用<br>前一节中的代码还可以通过静态方法引用来表示：代码如下:Converter&lt;String, Integer&gt; converter &#x3D; Integer::valueOf;<br>Integer converted &#x3D; converter.convert(“123”);<br>System.out.println(converted); &#x2F;&#x2F; 123Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：<br>代码如下:converter &#x3D; something::startsWith;<br>String converted &#x3D; converter.convert(“Java”);<br>System.out.println(converted);&#x2F;&#x2F; “J”接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：<br>代码如下:class Person {<br>String firstName;<br>String lastName;<br>Person() {}Person(String firstName, String lastName) {<br>this.firstName &#x3D; firstName;<br>this.lastName &#x3D; lastName;<br>}}接下来我们指定一个用来创建Person对象的对象工厂接口：<br>代码如下:interface PersonFactory</p><p>{<br>P create(String firstName, String lastName);<br>}这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：<br>代码如下:PersonFactory&lt;Person&gt; personFactory &#x3D; Person::new;<br>Person person &#x3D; personFactory.create(“Peter”, “Parker”);我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。<br>五、Lambda 作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。访问局部变量我们可以直接在lambda表达式中访问外层的局部变量：代码如下:final int num &#x3D; 1;<br>Converter&lt;Integer, String&gt; stringConverter &#x3D;<br>(from) -&gt; String.valueOf(from + num);<br>stringConverter.convert(2); &#x2F;&#x2F; 3但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：<br>代码如下:int num &#x3D; 1;<br>Converter&lt;Integer, String&gt; stringConverter &#x3D;<br>(from) -&gt; String.valueOf(from + num);<br>stringConverter.convert(2); &#x2F;&#x2F; 3不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：<br>代码如下:int num &#x3D; 1;<br>Converter&lt;Integer, String&gt; stringConverter &#x3D;<br>(from) -&gt; String.valueOf(from + num);<br>num &#x3D; 3;在lambda表达式中试图修改num同样是不允许的。七、访问对象字段与静态变量<br>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：代码如下:<br>class Lambda4 {<br>static int outerStaticNum;<br>int outerNum;<br>void testScopes() {<br>Converter&lt;Integer, String&gt; stringConverter1 &#x3D; (from) -&gt; {<br>outerNum &#x3D; 23;<br>return String.valueOf(from);<br>};Converter&lt;Integer, String&gt; stringConverter2 &#x3D; (from) -&gt; {<br>outerStaticNum &#x3D; 72;<br>return String.valueOf(from);<br>};<br>}}八、访问接口的默认方法还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：<br>代码如下:Formula formula &#x3D; (a) -&gt; sqrt( a * 100);<br>Built-in Functional InterfacesJDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。Predicate接口<br>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：代码如下:Predicate&lt;String&gt; predicate &#x3D; (s) -&gt; s.length() &gt; 0;<br>predicate.test(“foo”); &#x2F;&#x2F; true<br>predicate.negate().test(“foo”); &#x2F;&#x2F; falsePredicate&lt;Boolean&gt; nonNull &#x3D; Objects::nonNull;<br>Predicate&lt;Boolean&gt; isNull &#x3D; Objects::isNull;Predicate&lt;String&gt; isEmpty &#x3D; String::isEmpty;<br>Predicate&lt;String&gt; isNotEmpty &#x3D; isEmpty.negate();Function 接口<br>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：代码如下:Function&lt;String, Integer&gt; toInteger &#x3D; Integer::valueOf;<br>Function&lt;String, String&gt; backToString &#x3D; toInteger.andThen(String::valueOf);<br>backToString.apply(“123”); &#x2F;&#x2F; “123”Supplier 接口Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数<br>代码如下:Supplier&lt;Person&gt; personSupplier &#x3D; Person::new;<br>personSupplier.get(); &#x2F;&#x2F; new PersonConsumer 接口Consumer 接口表示执行在单个参数上的操作。<br>代码如下:Consumer&lt;Person&gt; greeter &#x3D; (p) -&gt; System.out.println(“Hello, “ + p.firstName);<br>greeter.accept(new Person(“Luke”, “Skywalker”));Comparator 接口Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：<br>代码如下:Comparator&lt;Person&gt; comparator &#x3D; (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);<br>Person p1 &#x3D; new Person(“John”, “Doe”);<br>Person p2 &#x3D; new Person(“Alice”, “Wonderland”);comparator.compare(p1, p2); &#x2F;&#x2F; &gt; 0<br>comparator.reversed().compare(p1, p2); &#x2F;&#x2F; &lt; 0Optional 接口<br>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。代码如下:Optional&lt;String&gt; optional &#x3D; Optional.of(“bam”);<br>optional.isPresent(); &#x2F;&#x2F; true<br>optional.get(); &#x2F;&#x2F; “bam”<br>optional.orElse(“fallback”);&#x2F;&#x2F; “bam”optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); &#x2F;&#x2F; “b”Stream 接口<br>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。首先看看Stream是怎么用，首先创建实例代码的用到的数据List：代码如下:List&lt;String&gt; stringCollection &#x3D; new ArrayList&lt;&gt;();<br>stringCollection.add(“ddd2”);<br>stringCollection.add(“aaa2”);<br>stringCollection.add(“bbb1”);<br>stringCollection.add(“aaa1”);<br>stringCollection.add(“bbb3”);<br>stringCollection.add(“ccc”);<br>stringCollection.add(“bbb2”);<br>stringCollection.add(“ddd1”);Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：<br>Filter 过滤过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。代码如下:stringCollection<br>.stream()<br>.filter((s) -&gt; s.startsWith(“a”))<br>.forEach(System.out::println);<br>&#x2F;&#x2F; “aaa2”, “aaa1”Sort 排序<br>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。代码如下:stringCollection<br>.stream()<br>.sorted()<br>.filter((s) -&gt; s.startsWith(“a”))<br>.forEach(System.out::println);<br>&#x2F;&#x2F; “aaa1”, “aaa2”需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：<br>代码如下:System.out.println(stringCollection);<br>&#x2F;&#x2F; ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1Map 映射中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。<br>代码如下:stringCollection<br>.stream()<br>.map(String::toUpperCase)<br>.sorted((a, b) -&gt; b.compareTo(a))<br>.forEach(System.out::println);<br>&#x2F;&#x2F; “DDD2”, “DDD1”, “CCC”, “BBB3”, “BBB2”, “AAA2”, “AAA1”Match 匹配<br>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。代码如下:boolean anyStartsWithA &#x3D;<br>stringCollection<br>.stream()<br>.anyMatch((s) -&gt; s.startsWith(“a”));<br>System.out.println(anyStartsWithA); &#x2F;&#x2F; trueboolean allStartsWithA &#x3D;<br>stringCollection<br>.stream()<br>.allMatch((s) -&gt; s.startsWith(“a”));System.out.println(allStartsWithA); &#x2F;&#x2F; falseboolean noneStartsWithZ &#x3D;<br>stringCollection<br>.stream()<br>.noneMatch((s) -&gt; s.startsWith(“z”));System.out.println(noneStartsWithZ); &#x2F;&#x2F; trueCount 计数计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。代码如下:long startsWithB &#x3D;<br>stringCollection<br>.stream()<br>.filter((s) -&gt; s.startsWith(“b”))<br>.count();<br>System.out.println(startsWithB);&#x2F;&#x2F; 3Reduce 规约<br>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：代码如下:Optional&lt;String&gt; reduced &#x3D;<br>stringCollection<br>.stream()<br>.sorted()<br>.reduce((s1, s2) -&gt; s1 + “#” + s2);<br>reduced.ifPresent(System.out::println);<br>&#x2F;&#x2F; “aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2”并行Streams<br>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。下面的例子展示了是如何通过并行Stream来提升性能：首先我们创建一个没有重复元素的大表：代码如下:int max &#x3D; 1000000;<br>List&lt;String&gt; values &#x3D; new ArrayList&lt;&gt;(max);<br>for (int i &#x3D; 0; i &lt; max; i++) {<br>UUID uuid &#x3D; UUID.randomUUID();<br>values.add(uuid.toString());<br>}然后我们计算一下排序这个Stream要耗时多久，<br>串行排序：<br>代码如下:long t0 &#x3D; System.nanoTime();<br>long count &#x3D; values.stream().sorted().count();<br>System.out.println(count);long t1 &#x3D; System.nanoTime();long millis &#x3D; TimeUnit.NANOSECONDS.toMillis(t1 - t0);<br>System.out.println(String.format(“sequential sort took: %d ms”, millis));&#x2F;&#x2F; 串行耗时: 899 ms<br>并行排序：代码如下:long t0 &#x3D; System.nanoTime();<br>long count &#x3D; values.parallelStream().sorted().count();<br>System.out.println(count);long t1 &#x3D; System.nanoTime();long millis &#x3D; TimeUnit.NANOSECONDS.toMillis(t1 - t0);<br>System.out.println(String.format(“parallel sort took: %d ms”, millis));&#x2F;&#x2F; 并行排序耗时: 472 ms<br>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。Map前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。代码如下:Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();<br>for (int i &#x3D; 0; i &lt; 10; i++) {<br>map.putIfAbsent(i, “val” + i);<br>}map.forEach((id, val) -&gt; System.out.println(val));<br>以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。下面的例子展示了map上的其他有用的函数：代码如下:map.computeIfPresent(3, (num, val) -&gt; val + num);<br>map.get(3); &#x2F;&#x2F; val33<br>map.computeIfPresent(9, (num, val) -&gt; null);<br>map.containsKey(9); &#x2F;&#x2F; falsemap.computeIfAbsent(23, num -&gt; “val” + num);<br>map.containsKey(23);&#x2F;&#x2F; truemap.computeIfAbsent(3, num -&gt; “bam”);<br>map.get(3); &#x2F;&#x2F; val33接下来展示如何在Map里删除一个键值全都匹配的项：<br>代码如下:map.remove(3, “val3”);<br>map.get(3); &#x2F;&#x2F; val33<br>map.remove(3, “val33”);<br>map.get(3); &#x2F;&#x2F; null另外一个有用的方法：<br>代码如下:map.getOrDefault(42, “not found”); &#x2F;&#x2F; not found对Map的元素做合并也变得很容易了：<br>代码如下:map.merge(9, “val9”, (value, newValue) -&gt; value.concat(newValue));<br>map.get(9); &#x2F;&#x2F; val9<br>map.merge(9, “concat”, (value, newValue) -&gt; value.concat(newValue));<br>map.get(9); &#x2F;&#x2F; val9concatMerge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。<br>九、Date APIJava 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：<br>Clock 时钟<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。代码如下:Clock clock &#x3D; Clock.systemDefaultZone();<br>long millis &#x3D; clock.millis();<br>Instant instant &#x3D; clock.instant();<br>Date legacyDate &#x3D; Date.from(instant); &#x2F;&#x2F; legacy java.util.Date<br>Timezones 时区<br>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:System.out.println(ZoneId.getAvailableZoneIds());<br>&#x2F;&#x2F; prints all available timezone ids<br>ZoneId zone1 &#x3D; ZoneId.of(“Europe&#x2F;Berlin”);<br>ZoneId zone2 &#x3D; ZoneId.of(“Brazil&#x2F;East”);<br>System.out.println(zone1.getRules());<br>System.out.println(zone2.getRules());&#x2F;&#x2F; ZoneRules[currentStandardOffset&#x3D;+01:00]<br>&#x2F;&#x2F; ZoneRules[currentStandardOffset&#x3D;-03:00]<br>LocalTime 本地时间<br>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：代码如下:LocalTime now1 &#x3D; LocalTime.now(zone1);<br>LocalTime now2 &#x3D; LocalTime.now(zone2);<br>System.out.println(now1.isBefore(now2)); &#x2F;&#x2F; falselong hoursBetween &#x3D; ChronoUnit.HOURS.between(now1, now2);<br>long minutesBetween &#x3D; ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); &#x2F;&#x2F; -3<br>System.out.println(minutesBetween); &#x2F;&#x2F; -239LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。<br>代码如下:LocalTime late &#x3D; LocalTime.of(23, 59, 59);<br>System.out.println(late); &#x2F;&#x2F; 23:59:59<br>DateTimeFormatter germanFormatter &#x3D;<br>DateTimeFormatter<br>.ofLocalizedTime(FormatStyle.SHORT)<br>.withLocale(Locale.GERMAN);LocalTime leetTime &#x3D; LocalTime.parse(“13:37”, germanFormatter);<br>System.out.println(leetTime); &#x2F;&#x2F; 13:37LocalDate 本地日期LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天&#x2F;月&#x2F;年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:LocalDate today &#x3D; LocalDate.now();<br>LocalDate tomorrow &#x3D; today.plus(1, ChronoUnit.DAYS);<br>LocalDate yesterday &#x3D; tomorrow.minusDays(2);<br>LocalDate independenceDay &#x3D; LocalDate.of(2014, Month.JULY, 4);<br>DayOfWeek dayOfWeek &#x3D; independenceDay.getDayOfWeek();System.out.println(dayOfWeek);&#x2F;&#x2F; FRIDAY<br>从字符串解析一个LocalDate类型和解析LocalTime一样简单：<br>代码如下:DateTimeFormatter germanFormatter &#x3D;<br>DateTimeFormatter<br>.ofLocalizedDate(FormatStyle.MEDIUM)<br>.withLocale(Locale.GERMAN);<br>LocalDate xmas &#x3D; LocalDate.parse(“24.12.2014”, germanFormatter);<br>System.out.println(xmas); &#x2F;&#x2F; 2014-12-24LocalDateTime 本地日期时间<br>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。代码如下:LocalDateTime sylvester &#x3D; LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);<br>DayOfWeek dayOfWeek &#x3D; sylvester.getDayOfWeek();<br>System.out.println(dayOfWeek); &#x2F;&#x2F; WEDNESDAYMonth month &#x3D; sylvester.getMonth();<br>System.out.println(month); &#x2F;&#x2F; DECEMBERlong minuteOfDay &#x3D; sylvester.getLong(ChronoField.MINUTE_OF_DAY);<br>System.out.println(minuteOfDay);&#x2F;&#x2F; 1439只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。<br>代码如下:Instant instant &#x3D; sylvester<br>.atZone(ZoneId.systemDefault())<br>.toInstant();<br>Date legacyDate &#x3D; Date.from(instant);<br>System.out.println(legacyDate); &#x2F;&#x2F; Wed Dec 31 23:59:59 CET 2014格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：<br>代码如下:DateTimeFormatter formatter &#x3D;<br>DateTimeFormatter<br>.ofPattern(“MMM dd, yyyy - HH:mm”);<br>LocalDateTime parsed &#x3D; LocalDateTime.parse(“Nov 03, 2014 - 07:13”, formatter);<br>String string &#x3D; formatter.format(parsed);<br>System.out.println(string); &#x2F;&#x2F; Nov 03, 2014 - 07:13<br>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>十、Annotation 注解在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：代码如下:@interface Hints {<br>Hint[] value();<br>}<br>@Repeatable(Hints.class)<br>@interface Hint {<br>String value();<br>}Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。<br>例 1: 使用包装类当容器来存多个注解（老方法）代码如下:@Hints({@Hint(“hint1”), @Hint(“hint2”)})<br>class Person {}例 2：使用多重注解（新方法）<br>代码如下:@Hint(“hint1”)<br>@Hint(“hint2”)<br>class Person {}第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：<br>代码如下:Hint hint &#x3D; Person.class.getAnnotation(Hint.class);<br>System.out.println(hint); &#x2F;&#x2F; null<br>Hints hints1 &#x3D; Person.class.getAnnotation(Hints.class);<br>System.out.println(hints1.value().length); &#x2F;&#x2F; 2Hint[] hints2 &#x3D; Person.class.getAnnotationsByType(Hint.class);<br>System.out.println(hints2.length); &#x2F;&#x2F; 2即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了：<br>代码如下:@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})<br>@interface MyAnnotation {}1. 用table显示n条记录，每3行换一次颜色，即1，2，3用红色字体，4，5，6用绿色字体，7，8，9用红颜色字体。&lt;body&gt;<table id="tbl"><br><tr><td>1</td></tr><br><tr><td>2</td></tr><br><tr><td>3</td></tr><br><tr><td>4</td></tr><br><tr><td>5</td></tr><br><tr><td>6</td></tr><br><tr><td>7</td></tr><br><tr><td>8</td></tr><br><tr><td>9</td></tr><br><tr><td>10</td></tr></table></p>&lt;/body&gt; &lt;script type="text/javascript"&gt; window.onload=function() { var tbl = document.getElementById("tbl"); rows = tbl.getElementsByTagName("tr"); for(i=0;i&lt;rows.length;i++) { var j = parseInt(i/3); if(j%2==0) rows[i].style.backgroundColor="#f00"; else rows[i].style.backgroundColor="#0f0"; } } &lt;/script&gt; 1、HTML 的 form 提交之前如何验证数值文本框的内容全部为数字? 否则的话提示用户并终止提交? &lt;form onsubmit=’return chkForm(this)’&gt; &lt;input type="text" name="d1"/&gt; &lt;input type="submit"/&gt; &lt;/form&gt; &lt;script type=”text/javascript” /&gt; function chkForm(this) { var value = thist.d1.value; var len = value.length; for(var i=0;i&lt;len;i++) { if(value.charAt(i)&gt;"9" || value.charAt(i)&lt;"0") { alert("含有非数字字符"); return false; } } return true; } &lt;/script&gt;2、请写出用于校验HTML文本框中输入的内容全部为数字的javascript代码 \<input type="text" id="d1" onblur="chkNumber(this)">\<script type="”text/javascript”">function chkNumber(eleText){ var value = eleText.value; var len = value.length; for(var i=0;i&lt;len;i++) { if(value.charAt(i)&gt;"9" || value.charAt(i)&lt;"0") { alert("含有非数字字符"); eleText.focus(); break; } } }\除了写完代码，还应该在网页上写出实验步骤和在代码中加入实现思路，让面试官一看就明白你的意图和检查你的结果。1、说说你用过那些ajax技术和框架，说说它们的区别 答:去掉对web.xml的监视，把jsp提前编辑成Servlet。 有富余物理内存的情况，加大tomcat使用的jvm的内存1. Java web部分 1、Tomcat的优化经验 答:去掉对web.xml的监视，把jsp提前编辑成Servlet。 有富余物理内存的情况，加大tomcat使用的jvm的内存1、HTTP请求的GET与POST方式的区别 答\:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。 4、request.getAttribute() 和 request.getParameter() 有何区别? 59、JSP的常用指令 isErrorPage(是否能使用Exception对象)，isELIgnored(是否忽略表达式)2. JSP中动态INCLUDE与静态INCLUDE的区别？ 答：动态INCLUDE用jsp\:include动作实现 \<jsp \:include page="included.jsp" flush="true">它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数 静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 <%@ include file=included.htm %>4、两种跳转方式分别是什么?有什么区别? （下面的回答严重错误，应该是想问forward和sendRedirect 的区别，毕竟出题的人不是专业搞文字艺术的人，可能表达能力并不见得很强，用词不一定精准，加之其自身的技术面也可能存在一些问题，不一定真正将他的意思表达清楚了，严格意思上来讲，一些题目可能根本就无人能答，所以，答题时要掌握主动，只要把自己知道的表达清楚就够了，而不要去推敲原始题目的具体含义是什么，不要一味想着是在答题） 答：有两种，分别为： \<jsp \:include page="included.jsp" flush="true">\<jsp \:forward page="nextpage.jsp/">前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。63、页面间对象传递的方法 request，session，application，cookie等 64、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？ JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是"类servlet"。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。1、MVC的各个部分都有那些技术来实现?如何实现? 答\:MVC是Model－View－Controller的简写。Model 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， View 是应用的表示面（由JSP页面产生），Controller 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。68、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？ Public String translate (String str) { String tempStr = ""; try { tempStr = new String(str.getBytes("ISO-8859-1"), "GBK"); tempStr = tempStr.trim(); } catch (Exception e) { System.err.println(e.getMessage()); } return tempStr; } 1．现在输入n个数字，以逗号，分开；然后可选择升或者降序排序；按提交键就在另一页面显示按什么排序，结果为，提供reset1. 实际项目开发 1、在eclipse中调试时，怎样查看一个变量的值？ 在要查看的变量前先设置断点，然后选中变量，右键选debug as-->Java Application，打开debug透视图，这时在Variables窗口中可以看到变量当前的值。 如果是局部变量，也可以在局部变量窗口中查看。 要知道一个方法被调用的方法调用链，可以在方法栈中查看。2、你们公司使用的代码配置管理工具是什么？ 除了说以前使用cvs，现在新项目使用svn了，还简要说一下使用的过程，如果有可能，还说说仓库的概念和如何使用锁之类的细节。3、你们的项目总金额多少，多少人开发，总共花了多少个月？ 像巴巴运动网这种规模的项目，可以说是4、5个人、开发了4、5个月，费用则是4、50万。按每人每月两万收入去计算，就差不多了。Jsp\&servlet 1 三个Statment区别，用法 Statment,基本的；PreparedStatement是可编译的，提高效率，callablestatment,存储过程 2 Cookie 答：临时cookie存在于内存中，（公话），长时cookic存在于硬盘上长时coolkie和临时cookie 路径问题 3 servlet调试方式几种方法 答：使用打印语句，使用TOMCAT日志，返回错误页面，使用IDE集成，重起服务器，直接查看HTML源代码，分别处理请求和响应数据。 4.Cookie 与session 的区别是：session为短对话，Cookie可以设置任意时间的有效期。 8.JSP构架模型 Model1：纯jsp 维护难，代码可复用性差 Model2：jsp+javabean 在jsp中使用usebean标签，代码在jsp中本质同Model1 Mvc：jsp+servlet+javabean 2. JSP隐含变量 request 用户端请求，此请求会包含来自GET/POST请求的参数 response 网页传回用户端的回应 pageContext 网页的属性是在这里管理 session 与请求有关的会话期 applicationservlet 正在执行的内容 configservlet的构架部件 out 用来传送回应的输出 (用来向客户端输出数据) page JSP网页本身 exception 针对错误网页，未捕捉的例外 (异常)<p>11.MVC——如何理解MVC<br>答: MVC是Model－View－Controller的简写。<br>“Model” 代表的是应用的业务逻辑 （通过JavaBean，EJB组件实现），<br>“View” 是应用的表示面（由JSP页面产生），<br>“Controller” 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。1. JSP生命周期</p><ol start="3"><li>从 BeanFactoy或 ApplicationContext是通过什么模式取得实例的？如果要取得多个实例在配制文件中要怎样做映射<br>答：是通过单态模式取得实例的，在配制文件中可以改，好像是isthread…设成false<br>16.请简述Session的特点有哪些？<br>答案：<br>(1)不是线程安全的<br>(2)Session实例是轻量级的<br>(3)(3)在Session 中，每个数据库操作都是在一个事务(transaction)中进行的</li><li>叙述Session的缓存的作用<br>答案：<br>（1）减少访问数据库的频率。<br>（2）保证缓存中的对象与数据库中的相关记录保持同步。<br>18、如何设置&#x2F;取得Bean 中的属性值？<br>答：设置属性值&lt;jsp:setPropertyname&#x3D;”haha”,property&#x3D;”haha的属性” value&#x3D;”变量值”&#x2F;&gt;<br>&lt; jsp:setProperty name&#x3D;”haha”,property&#x3D;”*” &#x2F;&gt;获取从上一个表单中提交过来的，与Bean中变量名字相同的所有属性.<br>取得属性值：&lt;jsp:getProperty name&#x3D;”haha” property&#x3D;”bean的属性”&#x2F;&gt;<br>相当于：&lt;%&#x3D;getA()%&gt;<br>19、JavaBean的使用：&lt;jsp:useBean id&#x3D;”name” class&#x3D;”sist.md5” scope&#x3D;”page”&#x2F;&gt;或者&lt;jsp:useBean id&#x3D;”name” class&#x3D;”sist.md5” scope&#x3D;”page”&gt;&lt;&#x2F;jsp:useBean&gt;<br>20、实现页面跳转的两种方法：<br>答：a、&lt;jsp:forward page&#x3D;”for2.jsp”&#x2F;&gt;<br>b、&lt;%response.sendRedirect(“for2.jsp”);%&gt;<br>21、include指令标签:<br>&lt;%@include file&#x3D;”inc1.jsp”%&gt; 简单的代码复制。<br>include动作标签：&lt;jsp:include page &#x3D;”inc2.jsp”&gt;获取inc2.jsp的执行结果。<br>22、页面之间的值传递：<br>答：a、设置Session 变量：session.setAttribute(“name”,”sist”);<br>获取Session 变量：session.getAttribute(“name”);<br>b、地址方式传递：show.jsp?id&#x3D;变量值<br>23、内置对象的作用域分为4种：<br>答：a、page 当前页面。<br>b、session 同一个网站内。<br>c、request 从上一页到下一个页面。<br>d、application 同一个网站内。<br>24、获取session ID: &lt;%&#x3D;session.getId()%&gt;；判断session是否有效：session.isNew();<br>25、使用Cookie对象<br>答：Cookie ck&#x3D;new Cookie(“name”,”sist”);<br>写入：response.addCookie(ck);<br>读取：Cookie[] ck&#x3D;request.getCookies();<br>If(ck&#x3D;&#x3D;null)<br>for(int a&#x3D;0;a&lt;ck.length;a++)<br>{<br>If(“name”.equals(ck[a].getName()))<br>Out.print(ck[a].getValue());<br>}<br>26、什么是servlet:在web容器中运行的服务器端JAVA程序，主要用于响应HTTP请求。Servlet一般用于MVC中的控制器部分。<br>27、什么是servlet容器:用来管理servlet生命周期的应用程序如（tomcat）。<br>28、什么是JSP Page:java server page 是servlet的扩展，强调web页面表达，编译后是一个类servlet。<br>29、JSP标签<br>动作标签：jsp:include jsp:forword jsp:usebean jsp:set&#x2F;get Property<br>指令标签：&lt;%@page……%&gt; &lt;%@include…..%&gt; &lt;%@taglib…..%&gt;<br>30、servlet中如何<br>A、从HTML表单中获得参数<br>request.getParameterNames();enumer;<br>request.getParameter(); String<br>b、如何获得请求头部的信息<br>Enumeration enumer&#x3D;request.getHeaderNames();<br>While(enumer. HasMoreElements())<br>{<br>String header&#x3D; enumer.next();<br>String result&#x3D;request.getHeader(header);<br>Out.print(result);<br>}<br>C、如何获得客户cookie的信息<br>request.getCookies();array[]<br>d、如何设置response的头部信息<br>response.setHeader();<br>e、如何设置响应的content type<br>response.setContentType(“text&#x2F;html charset&#x3D;utf-8”);<br>f、如何获得I&#x2F;O流、text流、二进制流<br>g、如何从当前的servlet重定向到其他的URL<br>response.sendRedirect(“url”)<br>RequstDispatcher rd&#x3D;request.get RequstDispatcher(“url”)<br>Rd.forword(request,response);<br>h如何向客户端写cookie<br>Cookie cookie&#x3D;new Cookie(“object”,”jklj”);<br>Cookie.setMaxAge(时间);<br>Response.addCookie(cookie);<br>31、描述servlet的生命周期，谁来控制servlet的生命周期，servlet生命周期在J2EE规范中是如何来定义的<br>服务器实例化一个servlet对象，容器运行其init方法，请求到达时运行其service方法，service方法根据请求的类型调用（doGet，doPost）方法，当服务器决定将实例销毁时调用其destory方法。32、如何创建Request Dispatcher对象,如何将请求转发给其它的web资源（包含其它的web资源），描述如何利用request来存状态，以及与其它保存状态方法有什么区别<br>RequstDispatcher rd&#x3D;request.get RequstDispatcher(“url”)<br>Rd.forword(request,response);<br>Request.setAttribute(“object”,”内容”);<br>一旦产生响应request的生命周期就结束了<br>33、如何在web.xml中配置servlet定义 &lt;servlet&gt; &lt;servlet-name&gt;name&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;package&lt;&#x2F;servlet-class&gt; &lt;&#x2F;servlet&gt;<br>映射 &lt;servlet-mapping&gt; &lt;servlet-name&gt;name&lt;&#x2F;servlet-name&gt; &lt;url-patten&gt;&#x2F;patten&lt;&#x2F;url-patten&gt; &lt;&#x2F;servlet-mapping&gt;<br>34、获得ServletConfig对象<br>ServletConfig sc&#x3D;getServletConfig();<br>35、如何获得servletContext对象<br>servletContext sc&#x3D;getservletContext();<br>36、<html>&lt;body&gt; <a href>POST</a>&lt;&#x2F;body&gt;</html><br>调用servlet时采用了doPost、doGet、doForm、doHref中的哪个方法<br>doGet方法<br>37、说明如下的web的资源应该放在web容器中的什么目录下，静态页面JSP、servlet class、web.xml、Tag libraries、JAR File、java class以及需要保护的资源文件<br>tomcat容器 web.xml, Tag libraries: \webapps\工程名\WEB-INF<br>servlet,javaclass: \webapps\工程名\WEB-INF\classes<br>jar: \webapps\工程名\WEB-INF\lib<br>38、描述request session web application的区别，创建监听器类来监听每个scope的生命周期<br>生命周期不同request产生响应时生命周期结束，session在web.xml中设置生命周期时间、手动清除web容器重启生命周期结束。Webapplication容器重启、手动清除<br>43、根据JSP的生命周期完成下面表格&#96;&#96;&#96;<br>页面首次编写完成	请求#1	请求#2	服务器重起	请求#3	请求#4	页面被修改	请求#5	请求#6</li></ol><pre><code class="JSP页面转换成servlet">Servlet编译
创建servlet实例并载入服务器的内存
Init（或类似的函数）被调用
DoGet（或类似的函数）被调用6.什么是Web容器?
　　实现J2EE规范中web协议的应用.该协议定义了web程序的运行时环境,包括:并发性,安全性,生命周期管理等等.
7.什么是Web Service?
　　Web Service就是为了使原来各孤立的站点之间的信息能够相互通信、共享而提出的一种接口。
Web Service所使用的是Internet上统一、开放的标准，如HTTP、XML、SOAP（简单对象访问协议）、WSDL等，所以Web Service可以在任何支持这些标准的环境（Windows,Linux）中使用。
　　注：SOAP协议（Simple Object Access Protocal,简单对象访问协议）,它是一个用于分散和分布式环境下网络信息交换的基于XML的通讯协议。在此协议下，软件组件或应用程序能够通过标准的HTTP协议进行通讯。它的设计目标就是简单性和扩展性，这有助于大量异构程序和平台之间的互操作性，从而使存在的应用程序能够被广泛的用户访问。
　　优势：
　　(1).跨平台。
　　(2).SOAP协议是基于XML和HTTP这些业界的标准的，得到了所有的重要公司的支持。
　　(3).由于使用了SOAP，数据是以ASCII文本的方式而非二进制传输，调试很方便；并且由于这样，它的数据容易通过防火墙，不需要防火墙为了程序而单独开一个“漏洞”。
　　(4).此外，WebService实现的技术难度要比CORBA和DCOM小得多。
　　(5).要实现B2B集成，EDI比较完善与比较复杂；而用WebService则可以低成本的实现，小公司也可以用上。
　　(6).在C/S的程序中，WebService可以实现网页无整体刷新的与服务器打交道并取数。
　　缺点：
　　(1).WebService使用了XML对数据封装，会造成大量的数据要在网络中传输。
　　(2).WebService规范没有规定任何与实现相关的细节，包括对象模型、编程语言，这一点，它不如CORBA。
91、Servlet执行时一般实现哪几个方法？
public void init(ServletConfig config)
public ServletConfig getServletConfig()
public String getServletInfo()
public void service(ServletRequest request,ServletResponse response)
public void destroy()1.servlet 创建过程以及ruquest，response，session的生命周期？
Servlet的创建过程：
第一步\
public class AAA extends HttpServlet&#123;
实现对应的doxxx方法
&#125;
第二步:
在web.xml中配置 \&lt;servlet&gt; \&lt;servlet-name&gt;\&lt;/servlet-name&gt; \&lt;servlet-class&gt;\&lt;/servlet-class&gt; \&lt;/servlet&gt;\&lt;servlet-mapping&gt;
\&lt;servlet-name&gt;\&lt;/servlet-name&gt;
\&lt;url-pattern&gt;\&lt;/url-pattern&gt;
\&lt;/servlet-mapping&gt;servlet的生命周期：
servlet容器创建servlet的一个实例
容器调用该实例的init()方法
如果容器对该servlet有请求，则调用此实例的service()方法
容器在销毁本实例前调用它的destroy()方法
销毁并标记该实例以供作为垃圾收集
一旦请求了一个servlet，就没有办法阻止容器执行一个完整的生命周期。
容器在servlet首次被调用时创建它的一个实例，并保持该实例在内存中，让它对所有的请求进行处理。容器可以决定在任何时候把这个实例从内存中移走。在典型的模型中，容器为每个servlet创建一个单独的实例，容器并不会每接到一个请求就创建一个新线程，而是使用一个线程池来动态的将线程分配给到来的请求，但是这从servlet的观点来看，效果和为每个请求创建一个新线程的效果相同。
一旦请求提交给容器，容器会自动创建相应的request、response，一旦回应完毕则request、response自动销毁。客户端第一次请求时，容器会建立相应的会话，直到会话超时，会话随即销毁。2.JSP与SERVLET区别
JSP在本质上就是SERVLET,但是两者的创建方式不一样.Servlet完全是JAVA程序代码构成，擅长于流程控制和事务处理，通过Servlet来生成动态网页很不直观.JSP由HTML代码和JSP标签构成，可以方便地编写动态网页.因此在实际应用中采用Servlet来控制业务流程，而采用JSP来生成动态网页.在struts框架中，JSP位于MVC设计模式的视图层，而Servlet位于控制层.JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP是Java和HTML组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。3.xmlhttprequest.open()里面有几个方法?
XMLHttpRequest.open()
初始化 HTTP 请求参数
语法
open (method, url, async, username, password)
method 参数是用于请求的 HTTP 方法。值包括 GET、POST 和 HEAD。
( 大小写不敏感 。
POST：用&quot;POST&quot;方式发送数据,可以大到4MB
GET：用&quot;GET&quot;方式发送数据,只能256KB
如果请求带有参数的化实用POST方式，POST方式将参数放置在页面的隐藏控件内
没有参数使用GET方式
对于请求的页面在中途可能发生更改的，也最好用POST方式
)
url 参数是请求的主体。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。
async 参数指示请求使用应该异步地执行。如果这个参数是 false，请求是同步的，后续对 send() 的调用将阻塞，直到响应完全接收。
如果这个参数是 true 或省略，请求是异步的，且通常需要一个 onreadystatechange 事件句柄。
username 和 password 参数是可选的，为 url 所需的授权提供认证资格。如果指定了，它们会覆盖 url 自己指定的任何资格。4.css是什么？ABSTRACT是什么意思？（层叠样式表，抽象）
Css:（层叠样式表，抽象）
abstract 修饰符可以用于类、方法、属性、事件和索引指示器（indexer），表示其为抽象成员，abstract 不可以和 static 、virtual 一起使用   声明为 abstract 成员可以不包括实现代码，但只要类中还有未实现的抽象成员（即抽象类），那么它的对象就不能被实例化，通常用于强制继承类必须实现某一成员技术总结
102.JRE、JDK、JVM 的关系。
JDK:包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。
JRE:是 java 的运行环境，其中包含了 JVM、runtime class libraries 和 Java application
launcher
JVM\:java 虚拟机，java 文件编译成.class 文件，在虚拟机上执行。是 java 能够跨平台使
用的基础。
2.八大数据类型。
short（16）、int（32）、long（64）、boolean、byte（8）、char（2）、double（64）3.403E38、
float（32）1.798E38
3.面向对象的四大特性和理解(面向对象的理解？设
计类的方式？)。
理解和设计时，结合每个阶段的项目来理解。
1
抽象：
(就是把现实世界中的某一类东西,提取出来,用程序代码表示,抽象出来的一般叫做类或者接
口).抽象并不打算了解全部问题,而是选择其中的一部分,暂时不用部分细节.抽象包括两个方
面,一个数据抽象,而是过程抽象. 数据抽象 --&gt;表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)
过程抽象 --&gt;表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)
封装
封装就是把过程和数据包围起来,对数据的访问只能通过特定的界面.如私有变量,用 set,get
方法获取
继承：
继承是指一个子类从一个现有的父类中派生出来，并具有原始类的属性和方法，子类可以
override 父类的方法，也可以添加新的属性和方法。Java 中父类和子类是一对多的关系。
多态：
.总的来说,方法的重写,重载与动态链接构成多态性.java 引入多态的概念原因之一就是弥补
类的单继承带来的功能不足. 动态链接 --&gt;对于父类中定义的方法,如果子类中重写了该方法,那么父类类型的引用将调用
子类中的这个方法,这就是动态链接. 4.重载和重写的理解？
重写（override）：指子类重写父类的方法，或重写接口的方法。
重载:在一个类中，相同名但参数的类型不同，或个数不同的方法。
访问权限的区别（private、protected、public、default）
6.运行时异常与一般异常有何异同？
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中
可能遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运
行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
7.接口是否可以使用继承？
一个接口可以继承多个接口，
不允许类多重继承的主要原因是，如果 A 同时继承 B 和 C，而 b 和 c 同时有一个 D 方法，
A 如何决定该继承那一个呢？
但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接
口。
8.简单说明什么是递归？什么情况会使用？并使用
java 实现一个简单的递归程序。
1）递归做为一种算法在程序设计语言中广泛应用.是指函数/过程/子程序在运行过程中
直接或间接调用自身而产生的重入现象。
2）递归算法一般用于解决三类问题：
a.数据的定义是按递归定义的。(Fibonacci（斐波那契）函数)
b.问题解法按递归算法实现。(回溯)
c.数据的结构形式是按递归定义的。(树的遍历，图的搜索)
3）这是一个排列的例子，它所做的工作是将输入的一个字符串中的所有元素进行排序
并输出，例如：你给出的参数是&quot;abc&quot; 则程序会输出：abc acb bac bca cab cba
a.算法的出口在于：ｌｏｗ＝ｈｉｇｈ也就是现在给出的排列元素只有一个时。
b.算法的逼近过程：先确定排列的第一位元素，也就是循环中ｉ所代表的元素，然
后ｌｏｗ＋１开始减少排列元素，如此下去，直到ｌｏｗ＝ｈｉｇｈ
9.接口和抽象类的区别？（说完后可以再补充 1.8 后
的新特性）
接口和抽象类的中的抽象方法，实现类或子类一定要去实现这个抽象方法。
抽象类的可以有具体实现方法和成员变量，而接口都是抽象方法（1.8 中引入 default 方法）
一个类只能继承一个抽象类，而可以实现多个接口。
抽象类能够提高代码复用率，一般我们将多个类共有的属性或方法放在一个父类中(如
Baseservice)
而接口表示的是功能的扩展，如 DAO 接口
104.String、StringBuilder、StringBuffer 的区别。
1.可变与不可变
String
通过查看 String 的源码我们知道 String 是通过字符数组来保存一个对象的，且在这个字符数
组前面加了 final 修饰符，说明 String 对象是不可变的。这就导致每次 String 的操作就会生成
新的对象，导致效率低下且浪费空间。
2.是否线程安全
String 对象不可变，可理解为它是线程安全的；
StringBuffer 是线程安全的，而 StringBuider 是非线程安全的。从源码可以看出，StringBuffer
在方法或调用方法前面加上了 Synchronized 同步锁，所以是线程安全的。
每个字符串缓冲区都有一定的容量。只要字符串缓冲区所包含的字符序列的长度没有超出此
容量（通常是 16 个字节），就无需分配新的内部缓冲区数组。如果内部缓冲区溢出，则此
容量自动增大。从 JDK 5 开始，为 StringBuffer 类补充了一个单个线程使用的等价类，即
StringBuilder。与该类相比，通常应该优先使用 StringBuilder 类，因为它支持所有相同的操作，
但由于它不执行同步，所以速度更快。
StringBuffer 和 StringBuilder 上的主要操作是 append 和 insert 方法，可重载这些方法，以接
受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字
符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而
insert 方法则在指定的点添加字符。
3.共同点
StringBuffer 和 StingBuilder 都继承自 AbstractStringBuilder（抽象类）
抽象类和接口的区别是：抽象类可以定义一些子类公共的方法，子类只需要增加新的功能，
而不需要重复写已经存在的功能。接口只是定义一些常量和对方法的声明。
String 转其他基本数据的方式。
105.Error 和 Exception 的内容和理解，区别？
4
Error 和 Exception 都继承自 Throwable，他们下列不同处：
Exceptions
1．可以是 可被控制(checked) 或 不可控制的(unchecked)
2．表示一个由程序员导致的错误
3．应该在应用程序级被处理
Errors
1．总是 不可控制的(unchecked)
2．经常用来用于表示系统错误或低层资源的错误
3．如何可能的话，应该在系统级被捕捉
106.throw throws Throwable 关联于区别？
throw 是在方法中抛出一个异常，不能单独使用 。
throws 是在方法定义处或者类定义处声明该类或方法可能产生的异常，（一个或
者多个）.----也可以理解为将方法内部异常不处理直接抛出，让调用处去处理。
throwable 是所有错误和异常的超类，所以当不知道要产生的异常是什么类型时
候，直接 throws Throwable 即可
5
107.集合框架图以及各个集合的数据结构、每个集合
的区别。（数据结构、增删改查、以及应用的场景）
集合框架的解释和回答需要靠平时的积累，以及对数据结构的理解。多从数据结构去分析理
解吧。
集合的体系结构:
\|--Collection(单列集合的根接口)
\|--List(子接口):元素是有序的，元素可以重复。因为该集合体系有索引。
\|--ArrayList:底层的数据结构使用的是数组结构。特点：查询速度很快。但是增删
稍慢。线程不同步。
\|--因为底层采用数组的数据结构,而数组中的元素在堆内存中是连续分配的, 而且有索引,所以查询快,增删稍慢
\|--在使用迭代器遍历元素时,不能再使用集合的方法操作集合中的元素
\|--调用集合的 contains()或 remove()方法时底层会调用 equals 方法,如果存入
集合的对象没有实现 equals(),则调用 Object 的 equals()方法
\|--LinkedList:底层使用的链表数据结构。特点：增删速度很快，查询稍慢。线程
不同步。
\|--Vector:底层是数组数据结构。线程同步。被 ArrayList 替代了。因为效率低。
\|--Set(子接口):元素是无序(存入和取出的顺序不一定一致),元素不可以重复。
\|--HashSet:底层数据结构是哈希表。是线程不安全的。不同步。
\|--HashSet 是如何保证元素唯一性的呢？
\|--是通过元素的两个方法，hashCode 和 equals 来完成。
\|--如果元素的 HashCode 值相同，才会判断 equals 是否为 true。
\|--如果元素的 hashcode 值不同，不会调用 equals。
\|--注意,对于判断元素是否存在，以及删除等操作，依赖的方法是元素的 hashcode 和 equals
方法。
\|--LinkedHashSet
\|--TreeSet：可以对 Set 集合中的元素进行排序。
\|--底层数据结构是二叉树。 保证元素唯一性的依据：compareTo 方法
return 0.
\|--TreeSet 排序的第一种方式：让元素自身具备比较性。元素需要实现
Comparable 接口，覆盖 compareTo 方法。
这种方式也成为元素的自然顺序，或者叫做默认顺序。
\|--TreeSet 的第二种排序方式。当元素自身不具备比较性时，或者具备的
比较性不是所需要的。
这时就需要让集合自身具备比较性。在集合初始化时，就有了比较方
式。
创建一个比较器(实现 Comparator 接口,重写 compare 方法),在创建
TreeSet 集合时将比较器传递给集合.
\|--Map 集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。
6
\|--Hashtable:底层是哈希表数据结构，不可以存入 null 键 null 值。该集合是线程同步
的。jdk1.0.效率低。
\|--HashMap：底层是哈希表数据结构，允许使用 null 值和 null 键，该集合是不同
步的。将 hashtable 替代，jdk1.2.效率高。
\|--TreeMap：底层是二叉树数据结构。不同步。可以用于给 map 集合中的进行键排
序。
\|--和 Set 很像。其实，Set 底层就是使用了 Map 集合
\|--map 集合的两种取出方式:
\|--Set\&lt;k&gt; keySet：将 map 中所有的键存入到 Set 集合。因为 set 具备迭代器。
所有可以迭代方式取出所有的键，在根据 get 方法。获取每一个键对应的
值。
Map 集合的取出原理：将 map 集合转成 set 集合。在通过迭代器取出。
\|--Set\&lt;Map.Entry\&lt;k,v&gt;&gt; entrySet：将 map 集合中的映射关系存入到了 set
集合中，而这个关系的数据类型就是：Map.Entry
Entry 其实就是 Map 中的一个 static 内部接口。
为什么要定义在内部呢？
因为只有有了 Map 集合，有了键值对，才会有键值的映射关系。
关系属于 Map 集合中的一个内部事物。而且该事物在直接访问 Map 集合
中的元素
108.Collections 与 Collection 的区别？
Collections 是个 java.util 下的类，它包含有各种有关集合操作的静态方法。
Collection 是个 java.util 下的接口，它是各种集合结构的父接口。
109.列出自己常用的 jdk 包.
JDK 常用的 package
java.lang：这个是系统的基础类，比如 String 等都是这里面的，这个 package 是唯一
一个可以不用 import 就可以使用的 Package。
java.io:这里面是所有输入输出有关的类，比如文件操作等
java.net: 这里面是与网络有关的类，比如 URL,URLConnection 等。
java.util :这个是系统辅助类，特别是集合类 Collection,List,Map 等。
java.sql:这个是数据库操作的类，Connection, Statememt，ResultSet 等 。
110.列出自己常用的 jdk 中的数据结构
线性表，链表，哈希表是常用的数据结构。
7
111.Java 反射机制的作用？
Java 反射机制的作用是：
1）在运行时判断任意一个对象所属的类。
2）在运行时构造任意一个类的对象。
3）在运行时判断任意一个类所具有的成员变量和方法。
4）在运行时调用任意一个对象的方法。
112.你是怎么理解 java 的泛型的？
在 Java SE 1.5 之前，没有泛型的情况的下，通过对类型 Object 的引用来实现
参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求
开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器
可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。
泛型是 Java SE 1.5 的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型
被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、
泛型接口、泛型方法。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都
是自动和隐式的，提高代码的重用率。
113.JAVA源文件中是否可以包括多个类,有什么限制
一个 java 源文件中可以包含多个类，每个源文件中至多有一个 public 类，如果有的话，么
源文件的名字必须与之相同。如果源文件中没有 public 类，则源文件用什么名字都可以，但
最好还是具有特定的意义，免得自己都不记得里面写的是什么了。
114.请写出 5 种常见到的 runtime exception。
NullPointerException：当操作一个空引用时会出现此错误。
NumberFormatException：数据格式转换出现问题时出现此异常。
ClassCastException：强制类型转换类型不匹配时出现此异常。
ArrayIndexOutOfBoundsException：数组下标越界，当使用一个不存在的数组下标时出现
此异常。
ArithmeticException：数学运行错误时出现此异常。
115.数组有没有 length()这个方法？String 有没有
length()这个方法？
8
数组没有 length（）方法它有 length 属性 String 有 length（）方法。
116.char 类型能否存储一个中文字符？为什么
可以。一个 char 是两个字节，而一个中文也是两个字节。
117.Switch 选择语句能否作用在 String【字符串】
上，也就是能否这么写：Switch(一个字符串变
量)？
不可以，只能处理 int,byte,short,char，（其实是只能处理 int,其它三种是可以
promotion 到 int 型）不能处理 Sring。
118.关键字 final 分别修饰一个类，一个方法，一个
变量，各起什么作用
final 修饰类是不能被继承
fianl 修饰方法不能在子类中被覆盖。
final 修饰变量，称为常量，初始化以后不能改变值。
119.是否可以继承 String 类
不可以。因为 String 类有 final 修饰。
120.Java 异常处理中，try &#123;&#125;里有一个 return 语句，
那么紧跟在这个 try 后的 finally &#123;&#125;里的 code 会
不会被执行，什么时候被执行，在 return 前还是
后?
9
会执行，在 return 前执行。
121.Class.forName（String className）这个方法
的作用
解答：通过类的全名获得该类的类对象。
122.在 java 语言中 int 和 Integer 有什么区别
int 是基本数据类型，Integer 是 int 的包装类，属于引用类型
123.位运算
25&amp;3 = 25|3= 解答：25 的二进制是 11001，3 的二进制是 00011，按位与的结果是：00001，
按位或的结果是：11010，因此转成 10 进制分别为：1 和 27
124.垃圾回收
什么是垃圾回收？什么时候触发垃圾回收？如何降低垃圾回收的触发频率？它能保证
程序有足够的可用内存吗？
解答：垃圾回收(GC)是 Java 语言的一个重要特性，作用是释放不再被使用的内存。垃
圾回收由系统进行管理。在系统认为需要的时候自动启动一个线程进行处理。尽量减少垃圾
内存，也就是新建对象的数量，可以降低垃圾回收的频率。垃圾回收机制无法保证有足够的
内存。
125.谈谈对 ClassLoader 的理解？
解答：ClassLoader 加载类用的是全盘负责委托机制。所谓全盘负责，即是当一个
classloader 加载一个 Class 的时候，这个 Class 所依赖的和引用的所有 Class 也由这个
classloader 负责载入，除非是显式的使用另外一个 classloader 载入；委托机制则是先让 parent
（父）类加载器(而不是 super，它与 parent classloader 类不是继承关系)寻找，只有在 parent
找不到的时候才从自己的类路径中去寻找。此外类加载还采用了 cache 机制，也就是如果
cache 中保存了这个 Class 就直接返回它，如果没有才从文件中读取和转换成 Class，并存入
cache，这就是为什么我们修改了 Class 但是必须重新启动 JVM 才能生效的原因。
126.构造器 Constructor 是否可以被继承？是否可
10
以被 Override?
解答：构造器 Constructor 不能被继承，因此不能重写 Overriding，但可以被重载
Overloading。
127.什么是 java 序列化，如何实现 java 序列化？
解答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流
化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是
为了解决在对对象流进行读写操作时所引发的问题；
序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需实现的方法，
implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如
FileOutputStream) 来 构 造 一 个 ObjectOutputStream( 对 象 流 ) 对 象 ， 接 着 ， 使 用
ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保
存其状态)，要恢复的话则用输入流。
128.Bit 和 Byte 是什么意思?它们之间有什么关系?
解答：bit 中文名称是位，是用以描述电脑数据量的最小单位。
byte（字节）是计算机信息技术用于计量存储容量和传输容量的一种计量单位
1byte=8bit
129.你认为 java 与其他（你所了解的）语言相比，
有什么优点和缺点?
解答：1). Java 没有预处理指令。（如 C 中的#define , #include , #ifdef 等）。C 中的常量
定义在 Java 中用 static final 来取代。
2\)．Java 中没有 C 中的全局变量。
3\)．Java 中的主类型的 size 是确定的，而 C 中主类型的 size 跟平台相关。
4\)．Java 中没有了指针，它使用了类似的句柄来取代指针，但是 Java 中不允许对句
柄进行加减，没有取地址操作符之类的东东。
5\)．Java 有垃圾收集机制，不需要自己释放空间。
6\)．Java 没有 goto 语句。Java 在 C 提供的控制语句基础上增加了异常处理和标签 break 和
continue 语句。这些可以替代 goto 的作用。
7\)． C 要求一个方法或块中使用的所有局部变量的定义在该方法或块的最开始处定义，
而 Java 允许这些定义在方法或块的任意地方出现。
8\)． Java 不要求在调用一个函数以前已经定义了该函数，可以在调用点后面定义。而 C
有这个要求。
9\)．Java 不支持 C 中的 strut 和 union 类型。Java 支持方法重载。
11
10\)．Java 不支持 C 中的 enum 关键字。
11\)．Java 不支持 C 中的 bitfields 能力。
12\)．Java 不支持 C 的 typedef。
13\)．Java 不支持 C 的方法指针。
14\). Java 不支持 C 的可变参数表。
java 和.net 的都不适合做桌面程序,这两个比较适合写 WEB 的程序;
c++比较适合写桌面程序 c++/java 都是强类型的静态预编译型语言。优点是结构性强，
程序可读性好，开发效率高，适合开发大型应用。就本人的经验而言，java 的开发效率优于
c++，实际上 java 大行其道的首要因素就是它够简单。java 尤其不适合开发桌面程序，GUI 的
API 一直都是 java 的弱点；
perl/python 是动态解释型语言。perl 是弱类型的而 python 是强类型的，后者的变量
一旦赋值，就拥有了类型，不能再赋其他类型的值。不象 javascript/perl 可以随便定义。
perl 是 unix 下的王牌工具，在缺乏 IDE 的字符界面下，很好地弥补了 unix；
shell/utility 的不足，并且部分继承了面向对象语言的灵活性。适合用来搭建大程序。
130.一个 subclass 怎样调用 superclass 中的方法
（myMethod）和构造函数?
用 super 关键字,子类去调用父类的方法，如：super.myMethod();子类去调用父
类的构造函数，如：super();。 二阶段
131.Java数据库编程包含哪些类？Java 数据库编程
的基本过程是什么？
解答：用到的类：Connection、ResultSet、错误！超链接引用无效。错误！超链接引用
无效。Java 中访问数据库的步骤如下：
1）注册驱动；
2）建立连接；
3）创建 Statement；
4）执行 sql 语句；
5）处理结果集（若 sql 语句为查询语句）；
6）关闭连接。
132.Statement,PreparedStatement,CallableStatm
12
ent 的区别。
区别有以下几点：
1）Statement 是 PreparedStatement 和 CallableStatement 的父类；
2） Statement 是直接发送 Sql 语句到数据库，事先没有进行预编译。 PreparedStatement
会将 sql 进行预编译，当 sql 语句要重复执行时，数据库会调用以前预编译好的 sql 语句，所
以 PreparedStatement 在性能方面会更好；
3）PreparedStatement 在执行 sql 时，对传入的参数可以进行强制的类型转换。以保
证数据格式与底层的数据库格式一致。
4）CallableStatement 适用与存储过程的查询表达语句
133.JDBC 为什么要使用 PreparedStatement 而不是
Statement
PreparedStatement 是 用 来 执 行 SQL 查 询 语 句 的 API 之 一 ， Java 提 供 了 Statement 、
PreparedStatement 和 CallableStatement 三种方式来执行查询语句，其中 Statement 用于通用
查询， PreparedStatement 用于执行参数化查询，而 CallableStatement 则是用于存储过程。
同时 PreparedStatement 还经常会在 Java 面试被提及，譬如：Statement 与 PreparedStatement
的 区 别 以 及 如 何 避 免 SQL 注 入 式 攻 击 ？ 这 篇 教 程 中 我 们 会 讨 论 为 什 么 要 用
PreparedStatement？使用 PreparedStatement 有什么样的优势？PreparedStatement 又是如何
避免 SQL 注入攻击的？
PreparedStatement 可以写动态参数化的查询
用 PreparedStatement 你可以写带参数的 sql 查询语句，通过使用相同的 sql 语句和不同的参
数值来做查询比创建一个不同的查询语句要好，下面是一个参数化查询：
1SELECT interest\_rate FROM loan WHERE loan\_type=?
现在你可以使用任何一种 loan 类型如：”personal loan”,”home loan” 或者”gold loan”
来查询，这个例子叫做参数化查询，因为它可以用不同的参数调用它，这里的”?”就是参
数的占位符。
PreparedStatement 比 Statement 更快
使用 PreparedStatement 最重要的一点好处是它拥有更佳的性能优势，SQL 语句会预编译在
数据库系统中。执行计划同样会被缓存起来，它允许数据库做参数化查询。使用预处理语句
比普通的查询更快，因为它做的工作更少（数据库对 SQL 语句的分析，编译，优化已经在第
一次查询前完成了）。为了减少数据库的负载，生产环境中德 JDBC 代码你应该总是使用
PreparedStatement 。值得注意的一点是：为了获得性能上的优势，应该使用参数化 sql 查询
而不是字符串追加的方式。下面两个 SELECT 查询，第一个 SELECT 查询就没有任何性能优势。
关于 PreparedStatement 接口，需要重点记住的是：
13
134.PreparedStatement 可以写参数化查询，比 Statement 能获得更好的性能。
135.对于 PreparedStatement 来说，数据库可以使用已经编译过及定义好的执行计划，这种预
处理语句查询比普通的查询运行速度更快。
136.PreparedStatement 可以阻止常见的 SQL 注入式攻击。
137.PreparedStatement 可以写动态查询语句
138.PreparedStatement 与 java.sql.Connection 对象是关联的，一旦你关闭了 connection，
PreparedStatement 也没法使用了。
139.“?” 叫做占位符。
140.PreparedStatement 查询默认返回 FORWARD\_ONLY 的 ResultSet，你只能往一个方向移动结
果集的游标。当然你还可以设定为其他类型的值如：”CONCUR\_READ\_ONLY”。
141.不支持预编译 SQL 查询的 JDBC 驱动，在调用 connection.prepareStatement(sql)的时候，它
不会把 SQL 查询语句发送给数据库做预处理，而是等到执行查询动作的时候（调用
executeQuery()方法时）才把查询语句发送个数据库，这种情况和使用 Statement 是一样的。
142.占位符的索引位置从 1 开始而不是 0，如果填入 0 会导致*java.sql.SQLException invalid
column index*异常。所以如果 PreparedStatement 有两个占位符，那么第一个参数的索引时
1，第二个参数的索引是 2. 以上就是为什么要使用 PreparedStatement 的全部理由，不过你仍然可以使用 Statement 对
象用来做做测试。但是在生产环境下你一定要考虑使用 PreparedStatement 。
143.设计模式：策略模式、观察者模式、工厂、单例、
动态代理、适配器模式。
参考书籍《设计模式之禅》
144.连接池的工作原理：
参考三阶段写的连接池代码，最好自己理解后写一个。
145.为什么使用连接池？连接池的好处？
连接池放了 N 个 Connection 对象，本质上放在内存当中，在内存中划出一块缓存对象，应
用程序每次从池里获得 Connection 对象，而不是直接从数据里获得，这样不占用服务器的
内存资源。
2 .如果不使用连接池会出现的情况：
a.占用服务器的内存资源
b.导致服务器的速度非常慢
14
3 .应用连接池的三种方式：
a.自定义连接池
b.使用第三方连接池
c.使用服务器自带的连接池
连接池一般比直接连接更有优越性,因为它提高了性能的同时还保存了宝贵的资源。在
整个应用程序的使用过程,当中重复的打开直接连接将导致性能的下降。而池连接只在服务
器启动时打开一次，从而消除了这种性能问题。
连接池主要考虑的是性能，每次获取连接和释放连接都有很大的工作量，会对性能有很
大影响；而对资源来说起的是反作用，因为保存一定数量的连接是要消耗内存的。应用程序
每次从池里获得 Connection 对象，而不是直接从数据里获得，这样不占用服务器的内存资
源。所以一般要建立连接池，而连接的数量要适当，不能太大，太大会过多消耗资源。(所
以，考虑 2 个方面，一个是内存，另一个是资源)。
连接池就是为了避免重复多次的打开数据库连接而造成的性能的下降和系统资源的浪
费。
146.连接池的实现
（着重从怎么实现从池中拿出和放回池中，用什么数据类型存储连接，close 方法的重写）
147.I/O 流两种流（字符、字节）、四个接口：
Read/Write，Input/Output
148.NIO 的原理以及 NIO 和 BIO 的区别：
15
NIO 本身是基于事件驱动思想来完成的，其主要想解决的是 BIO 的大并发问题： 在使用同
步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器
进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单
独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个
线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线
程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客
户端的请求，甚至服务器可能会因此而瘫痪。
NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程
序进行处理，应用再将流读取到缓冲区或写入操作系统。 也就是说，这个时候，已经不是
一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，
是没有工作线程来处理的。
BIO 与 NIO 一个比较重要的不同，是我们使用 BIO 的时候往往会引入多线程，每个连接一
个单独的线程；而 NIO 则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。
参考这篇博客内容：&lt;http://blog.csdn.net/skiof007/article/details/52873421&gt;
16
149.网络的继承结构、TCP、UDP、HTTP 等协议的特
性和理解。
17
先来一个讲 TCP、UDP 和 HTTP 关系的
1、TCP/IP 是个协议组，可分为三个层次：网络层、传输层和应用层。
在网络层有 IP 协议、ICMP 协议、ARP 协议、RARP 协议和 BOOTP 协议。
在传输层中有 TCP 协议与 UDP 协议。
在应用层有 FTP、HTTP、TELNET、SMTP、DNS 等协议。
因此，HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协
议。
2、HTTP 协议是建立在请求/响应模型上的。首先由客户建立一条与服务器的 TCP
链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的
MIME 样式的消息。服务器响应一个状态行，包含消息的协议版本、一个成功和失败码
18
以及相关的 MIME 式样的消息。
HTTP/1.0 为每一次 HTTP 的请求/响应建立一条新的 TCP 链接，因此一个包含 HTML
内容和图片的页面将需要建立多次的短期的 TCP 链接。一次 TCP 链接的建立将需要 3
次握手。
另外，为了获得适当的传输速度，则需要 TCP 花费额外的回路链接时间（RTT）。每一
次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的
可靠性，因此 HTTP/1.1 提出了可持续链接的实现方法。HTTP/1.1 将只建立一次 TCP
的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经
常性的链接开销。
3、结论：虽然 HTTP 本身是一个协议，但其最终还是基于 TCP 的。不过，目前，
有人正在研究基于 TCP+UDP 混合的 HTTP 协议。
二、IP,TCP,UDP,HTTP,TCP/IP,Socket
IP 协议，为计算机网络相互连接进行通信而设计的协议。
TCP/UDP 协议，基于二进制流的控制间传输协议。 TCP 是面向链接的，虽然说网络
的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但 TCP 的三次握手在最
低限度上(实际上也很大程度上保证了)保证了连接的可靠性；而 UDP 不是面向连接的，UDP
传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是
否会正确接收，当然也不用重发，所以说 UDP 是无连接的、不可靠的一种数据传输协议。
HTTP 协议，超文本传送协议(Hypertext Transfer Protocol )，HTTP 协议是建立在
TCP 协议之上的一种应用。
IP 协议对应于网络层，TCP 协议对应于传输层，而 HTTP 协议对应于应用层。注意
TPC/IP 位于传输层，它主要用来解决数据如何在网络中传输，与 IP 协议要区分开。
IP 协议规定网络之间互连的协议；TPC/IP 协议是传输层协议，主要解决数据如何在网
络中传输；HTTP 是应用层协议，主要用于包装数据。
Socket 相当于调用接口(API)，用来调取 TCP/IP 协议。
19
150.TCP 与 UDP 如何加以区分使用？
TCP 用于在传输层有必要实现可靠性传输的情况。由于它是面向有连接并具备顺序
控制、重发控制等机制的。所以它可以为应用提供可靠传输。
另一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。
举一个 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失会被重发，但是
这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用 UDP，它不会进行
重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是影响
某一小部分的通话。此外，在多播与广播通信中也使用 UDP 而不是 UDP。RIP、DHCP 等
基于广播的协议也要依赖于 UDP。
151.TCP 与 UDP 区别总结：
1、TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不需
要建立连接
2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重
复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付
3、TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流;UDP 是面向报文的
UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，
如 IP 电话，实时视频会议等）
4、每一条 TCP 连接只能是点到点的;UDP 支持一对一，一对多，多对一和多对多的交互通
信
5、TCP 首部开销 20 字节;UDP 的首部开销小，只有 8 个字节
6、TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道
152.HTTP 特性（与 ajax、websocket 做比较）：
1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有
GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简
单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
20
2、灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标
记。
3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收
到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4.无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状
态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据
量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
5、支持 B/S 及 C/S 模式
HTTP 请求格式
HTTP 返回消息格式
21
153.TCP 通信的流程。
22
154.多线程：线程和进程的区别？
1.定义
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源
分配和调度的一个独立单位. 线程是进程的一个实体,是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本
单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器, 一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 2.关系
一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数
据，但拥有自己的栈空间，拥有独立的执行序列。
3.区别
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，
一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执
行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就
等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源
较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用
线程，不能用进程。1.  简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
2.  另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了
程序的运行效率。
3.  线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执
行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供
多个线程执行控制。
4.  从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但
操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。
这就是进程和线程的重要区别。
4.优缺点
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正
相反。同时，线程适合于在 SMP 机器上运行，而进程则可以跨机器迁移。
线程与进程的区别归纳：
a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其
它进程不可见。
b.通信：进程间通信 IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——
需要进程同步和互斥手段的辅助，以保证数据的一致性。
c.调度和切换：线程上下文切换比进程上下文切换要快得多。
23
d.在多线程 OS 中，进程不是一个可执行的实体。1.  线程的生命周期？
10. 为什么使用Oracle？？？(通过对比其他数据库
的区别？)
Oracle 和 MySQL 的主要区别
Oracle:客户端和命令窗口，都是由用户决定内容-&gt; conn user\_name/password;
MySQL:客户端和命令窗口，都是由数据库决定内容-&gt; use datebase;
都可以创建多数据库多用户，个人倾向于 Oracle 一个数据库中多个用户的形式，MySQL 多
个数据库多个用户形式（最好每个数据库对应一个用户）
Oracle 是大型数据库而 MySQL 是中小型数据库，Oracle 市场占有率达 40%，MySQL 只有 20%
左右，同时 MySQL 是开源的而 Oracle 价格非常高。
Oracle 支持大并发，大访问量，是 OLTP（On-Line Transaction Processing 联机事务处理系统）
最好的工具。
安装所用的空间差别也是很大的，MySQL 安装完后才 152M 而 Oracle 有 3G 左右，且使用的
时候 Oracle 占用特别大的内存空间和其他机器性能。
Oracle 也与 MySQL 操作上的一些区别
具体参考：&lt;http://www.cnblogs.com/whyhappy/p/5449630.html&gt;
11. C/S 和 B/S 的区别和联系(结合二阶段和三阶段
27
的项目讲，可以从现在的网速和安全性等来谈谈自
己对未来架构的想法)？
C/S 架构的概念
C/S 是 Client/Server，即客户端/服务器端架构，一种典型的两层架构。
客户端包含一个或多个在用户的电脑上运行的程序
服务器端有两种，一种是数据库服务器端，客户端通过数据库连接访问服务器端的数据；另
一种是 Socket 服务器端，服务器端的程序通过 Socket 与客户端的程序通信。
C/S 可以看做是胖客户端架构
因为客户端需要实现绝大多数的业务逻辑和界面展示。作为客户端的部分需要承受很大的压
力，因为显示逻辑和事务处理都包含在其中，
通过与数据库的交互（通常是 SQL 或存储过程的实现）来达到持久化数据，以此满足实际项
目的需要。
C/S 优点和缺点
优点：（1）界面和操作可以很丰富 （2） 安全性能可以很容易保证，实现多层认证也不难
（3）由于只有一层交互，因此响应速度较快。
缺点：（1）适用面窄，通常用于局域网中
（2）用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户
（3）维护成本高。发生一次升级，则所有客户端的程序都需要改变。
B/S 架构的概念
B/S 是 Browser/Server，即浏览器/服务器架构。
Browser 指的是 Web 浏览器，极少数事务逻辑在前端实现，但主要事务逻辑在服务器端实现，
Browser 客户端，WebApp 服务器端和 DB 端构成所谓的三层架构。
B/S 架构的系统无须特别安装，只有 Web 浏览器即可。
B/S 可以看做是瘦客户端架构
B/S 架构中，显示逻辑交给了 Web 浏览器，事务处理逻辑在放在了 WebApp 上，这样就避免
了庞大的胖客户端，减少了客户端的压力。因为客户端包含的逻辑很少，因此也被成为瘦客
户端。
C/S 优点和缺点
优点：（1）客户端无需安装，有 Web 浏览器即可 （2）BS 架构可以直接放在广域网上，
通过一定的权限控制实现多客户访问的目的，交互性较强。
（3）BS 架构无需升级多个客户端，升级服务器即可。
缺点：（1）在跨浏览器上，BS 架构不尽如人意。（2）表现要达到 CS 程序的程度需要花费
不少精力。
（3）在速度和安全性上需要花费巨大的设计成本，这是 BS 架构的最大问题。
（4）C 和 S 交互是请求-响应模式，通常需要刷新页面，这并不是客户乐意看到的。（在
Ajax 风行后此问题得到了一定程度的缓解）
28
20. AJAX 和 websocket 的详解？
问这两个的具体原理时，先阐述 HTTP 协议的特点，再去描述这 ajax 和 websocket 的特点以
及他们的应用场景，应用场景通过自己的项目去描述。
21. J2EE 是什么？它包括哪些技术？
解答：从整体上讲，J2EE 是使用 Java 技术开发企业级应用的工业标准，它是 Java 技
术不断适应和促进企业级应用过程中的产物。适用于企业级应用的 J2EE，提供一个平台独
立的、可移植的、多用户的、安全的和基于标准的企业级平台，从而简化企业应用的开发、
管理和部署。J2EE 是一个标准，而不是一个现成的产品。
主要包括以下这些技术：1.  Servlet
Servlet 是 Java 平台上的 CGI 技术。 Servlet 在服务器端运行，动态地生成 Web 页面。与传
统的 CGI 和许多其它类似 CGI 的技术相比，Java Servlet 具有更高的效率并更容易使用。对于
Servlet，重复的请求不会导致同一程序的多次转载，它是依靠线程的方式来支持并发访问的。
2\)JSP
JSP(Java Server Page)是一种实现普通静态 HTML 和动态页面输出混合编码的技术。从这
一点来看，非常类似 Microsoft ASP、PHP 等技术。借助形式上的内容和外观表现的分离，
Web 页面制作的任务可以比较方便地划分给页面设计人员和程序员，并方便地通过 JSP 来
合成。在运行时态，JSP 将会被首先转换成 Servlet，并以 Servlet 的形态编译运行，因此它的
效率和功能与 Servlet 相比没有差别，一样具有很高的效率。
2.  EJB
EJB 定义了一组可重用的组件：Enterprise Beans。开发人员可以利用这些组件，像搭积
木一样建立分布式应用。
4\)JDBC
JDBC(Java Database Connectivity， Java 数据库连接)API 是一个标准 SQL(Structured Query
Language，结构化查询语言)数据库访问接口，它使数据库开发人员能够用标准 Java API 编
写数据库应用程序。JDBC API 主要用来连接数据库和直接调用 SQL 命令执行各种 SQL 语句。
利用 JDBC API 可以执行一般的 SQL 语句、动态 SQL 语句及带 IN 和 OUT 参数的存储过程。Java
中的 JDBC 相当于 Microsoft 平台中的 ODBC(Open Database Connectivity)。1.  什么是 Web 容器
解答：容器就是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这
个程序就是处理从客户端发出的请求，如 JAVA 中的 Tomcat 容器， ASP 的 IIS 或 PWS 都是这
样的容器。
2.  谈谈对 XML 的理解？说明 Web 应用中 Web.xml 文
件的作用？
解答：XML（Extensible Markup Language）即可扩展标记语言，它与 HTML 一样，都是
SGML(Standard Generalized Markup Language,标准通用标记语言)。Xml 是 Internet 环境中跨平
台的，依赖于内容的技术，是当前处理结构化文档信息的有力工具。扩展标记语言 XML 是
一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式
建立，虽然 XML 占用的空间比二进制数据要占用更多的空间，但 XML 极其简单易于掌握和
使用。
web.xml 的作用是配置欢迎页，servlet，filter，listener 等的。
3.  描述 J2EE 框架的多层结构，并简要说明各层的
作用1.  Presentation layer（表示层）
a. 表示逻辑（生成界面代码）
b.接收请求
c. 处理业务层抛出的异常
d.负责规则验证（数据格式，数据非空等）
e.流程控制
2.  Service layer（服务层/业务层）
a.封装业务逻辑处理，并且对外暴露接口
b.负责事务，安全等服务
3.  Persistence layer（持久层）
a.封装数据访问的逻辑，暴露接口
b.提供方便的数据访问的方案（查询语言，API，映射机制等）
4）Domain layer（域层）
a. 业务对象以及业务关系的表示
b.处理简单的业务逻辑
c. 域层的对象可以穿越表示层，业务层，持久层
软件分层结构使得代码维护非常方便，设计明确，各层独立，专注自己擅长的领域。1.  请说明 meta 标签的作用
meta 是用来在 HTML 文档中模拟 HTTP 协议的响应头报文。meta 标签用于网页的＜
head＞与＜/head＞中，meta 标签的用处很多。meta 的属性有两种：name 和 http-equiv。
name 属性主要用于描述网页，对应于 content （网页内容），以便于搜索引擎机器人查找、
分类（目前几乎所有的搜索引擎都使用网上机器人自动查找 meta 值来给网页分类）。这
其中最重要的是 description（站点在搜索引擎上的描述）和 keywords（分类关键词），所
以应该给每页加一个 meta 值。比较常用的有以下几个：name 属性
1\)．＜meta name=&quot;Generator&quot; contect=&quot;&quot;＞用以说明生成工具（如 Microsoft FrontPage
4.0）等；
35
2\)．＜meta name=&quot;KEYWords&quot; contect=&quot;&quot;＞向搜索引擎说明你的网页的关键词；
3\)．＜meta name=&quot;DEscription&quot; contect=&quot;&quot;＞告诉搜索引擎你的站点的主要内容；
4\).＜meta name=&quot;Author&quot; contect=&quot;你的姓名&quot;＞告诉搜索引擎你的站点的制作的作者；
5\).＜meta name=&quot;Robots&quot; contect= &quot;all|none|index|noindex|follow|nofollow&quot;＞其中的
属性说明如下：
设定为 all：文件将被检索，且页面上的链接可以被查询；设定为 none：文件将不被
检索，且页面上的链接不可以被查询；设定为 index：文件将被检索；
设定为 follow：页面上的链接可以被查询；
设定为 noindex：文件将不被检索，但页面上的链接可以被查询；设定为 nofollow：文件将
不被检索，页面上的链接可以被查询。
6\).http-equiv 属性
A.＜meta http-equiv=&quot;Content-Type&quot; contect=&quot;text/html&quot;;charset=gbk&quot;＞和＜meta
http-equiv=&quot;Content-Language&quot; contect=&quot;zh-CN&quot;＞用以说明主页制作所使用的文字以及语言；
B.＜meta http-equiv=&quot;Refresh&quot; contect=&quot;n;url=&lt;http://yourlink&quot;＞定时让网页在指定的时&gt;
间 n 内，跳转到页面 http;//yourlink；
C.＜meta http-equiv=&quot;Expires&quot; contect=&quot;Mon,12 May 2001 00:20:00 GMT&quot;＞可以用于设
定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用 GMT 时
间格式；
D.＜meta http-equiv=&quot;Pragma&quot; contect=&quot;no-cache&quot;＞是用于设定禁止浏览器从本地机的
缓存中调阅页面内容，设定后一旦离开网页就无法从 Cache 中再调出；
E.＜meta http-equiv=&quot;set-cookie&quot; contect=&quot;Mon,12 May 2001 00:20:00 GMT&quot;＞cookie 设
定，如果网页过期，存盘的 cookie 将被删除。需要注意的也是必须使用 GMT 时间格式；
F.＜meta http-equiv=&quot;Pics-label&quot; contect=&quot;&quot;＞网页等级评定，在 IE 的 internet 选项中
有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过 meta 属
性来设置的；G.＜meta http-equiv=&quot;windows-Target&quot; contect=&quot;\_top&quot;＞强制页面在当前窗口
中以独立页面显示，可以防止自己的网页被别人当作一个 frame 页调用；
H.＜meta http-equiv=&quot;Page-Enter&quot; contect=&quot;revealTrans(duration=10,transtion=50)&quot;＞和
＜meta http-equiv=&quot;Page-Exit&quot; contect=&quot;revealTrans(duration=20， transtion=6)&quot;＞设定进入和
离
开页面时的特殊效果，这个功能即 FrontPage 中的“格式/网页过渡”，不过所加的页面不
能够是一个 frame 页面。
3.  Tomcat 服务器的默认端口是多少？怎样修改
36
tomcat 的端口？
默认端口为 8080，可以通过 service.xml 的 Connector 元素的 port 属性来修
改端口。
4.  MVC 的各个部分都有哪些技术来实现？如何实
现？
：MVC 是 Model-View-Controller 的缩写，Model 代表的是应用的业务逻辑（通过
JavaBean，EJB 组件实现），View 是应用的表示面（由 JSP 页面产生）Controller 是通过应用
的处理过程控制，（一般是一个 servert）通过这种设计模型把应用逻辑，处理过程和显示
逻辑分成不同的组件实现，这些组件可以进行交互和重用。
5.  什么是 AJAX？
Ajax 的全称是：AsynchronousJavaScript And XML。Ajax 不是一个技术，它实际
上是几种技术，每种技术都有其独特这处，合在一起就成了一个功能强大的新技术。 Ajax
包括：XHTML 和 CSS 使用文档对象模型(Document Object Model)作动态显示和交互使用 XML
和 XSLT 做数据交互和操作使用 XMLHttpRequest 进行异步数据接收使用 JavaScript 将它们绑
定在一起。
6.  简要说明 JVM、JSP、Servlet、Web Server、Web
Browser 之间的关系
解答：当用户在 JSP 页面上提交了需要服务器处理的数据后，通过 Web Browser 发送
到服务器端，Servlet 会根据用户的请求产生必要的相应，如果需要还会通过 JVM 或 Web
Server 来获取资源，最后把服务器端的相应结果返回给用户
7.  Servlet 是线程安全吗？以下代码中使用
synchronized 关键字的意义是什么？
Synchronized(aList)&#123;
aList.remove (1);
&#125;
解答：默认不是线程安全的，但是 servlet 实现了 SingthreadModel 接口就能单线程
执行。此题中代码的意思是给 aList 对象加同步锁，保证 aList 对象在多线程任务环境中，每
次只能够有一个线程调用 remove 方法。从而提高对 aList 对象操作的安全性和正确性。
37
38
8.  Session 的基本原理是什么？
Session 对象的原理在于，服务器可以为客户端创建并维护一个所谓的 Session 对
象，用于存放数据。在创建 Session 对象的同时，服务器将会为该 Session 对象产生一个唯一
编号，这个编号称之为 SessionID，服务器以 Cookie 的方式将 SessionID 存放在客户端。当浏
览器再次访问该服务器时，会将 SessionID 作为 Cookie 信息带到服务器，服务器可以通过该
SessionID 检索到以前的 Session 对象，并对其进行访问。需要注意的是，此时的 Cookie 中仅
仅保存了一个 SessionID，而相对较多的会话数据保存在服务器端对应的 Session 对象中，由
服务器来统一维护，这样一定程度保证了会话数据安全性，但增加了服务器端的内存开销。
存放在客户端的用于保存 SessionID 的 Cookie 会在浏览器关闭时清除。我们把用户打开一个
浏览器访问某个应用开始，到关闭浏览器为止交互过程称为一个 “会话”。在一个“会话”
过程中，可能会向同一个应用发出了多次请求，这些请求将共享一个 Session 对象，因为这
些请求携带了相同的 SessionID 信息。Session 对象的正常使用要依赖于 Cookie。如果考虑到
客户端浏览器可能出于安全的考虑禁用了 Cookie，应该使用 URL 重写的方式使 Session 在
客户端禁用 Cookie 的情况下继续生效。
jsp 有哪些动作？作用分别是什么？
JSP 共有以下 6 种基本动作：
jsp\:include：在页面被请求的时候引入一个文件；jsp\:useBean：寻找或者实例化一个
JavaBean。；jsp\:setProperty：设置 JavaBean 的属性。；jsp\:getProperty：输出某个 JavaBean 的
属性；jsp\:forward：把请求转到一个新的页面；jsp\:plugin：根据浏览器类型为 Java 插件生成
OBJECT 或 EMBED 标记。 四阶段
9.  tomcat 基本原理
1– Tomcat Server 处理一个 http 请求的过程
假设来自客户的请求为：
&lt;http://localhost:8080/wsota/wsota_index.jsp&gt;1.  请求被发送到本机端口 8080，被在那里侦听的 Coyote HTTP/1.1 Connector 获得
（1-1）Connector 的主要任务是负责接收浏览器的发过来的 tcp 连接请求，创建一个
Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请
求并把产生的 Request 和 Response 对象传给处理这个请求的线程
2.  Connector 把该请求交给它所在的 Service 的 Engine 来处理，并等待来自 Engine 的回应
3.  Engine 获得请求 localhost/wsota/wsota\_index.jsp，匹配它所拥有的所有虚拟主机 Host
4.  Engine 匹配到名为 localhost 的 Host（即使匹配不到也把请求交给该 Host 处理，因为该 Host
被定义为该 Engine 的默认主机）
5.  localhost Host 获得请求/wsota/wsota\_index.jsp，匹配它所拥有的所有 Context
6.  Host 匹配到路径为/wsota 的 Context（如果匹配不到就把该请求交给路径名为”&quot;的 Context
去处理）
39
7.  path=”/wsota”的 Context 获得请求/wsota\_index.jsp，在它的 mapping table 中寻找对应的
servlet
8.  Context 匹配到 URL PATTERN 为\*.jsp 的 servlet，对应于 JspServlet 类
9.  构造 HttpServletRequest 对象和 HttpServletResponse 对象，作为参数调用 JspServlet 的
doGet 或 doPost 方法
10\)Context 把执行完了之后的 HttpServletResponse 对象返回给 Host
11\)Host 把 HttpServletResponse 对象返回给 Engine
12\)Engine 把 HttpServletResponse 对象返回给 Connector
13\)Connector 把 HttpServletResponse 对象返回给客户 browser1.  简述基于 Struts 框架 Web 应用的工作流程
在 web 应用启动时就会加载初始化 ActionServlet,ActionServlet 从
struts-config.xml 文件中读取配置信息,把它们存放到各种配置对象中， 当 ActionServlet 接收
到一个客户请求时,将执行如下流程. 1)检索和用户请求匹配的 ActionMapping 实例,如果不存在,就返回请求路径无效信息;
2\)如果 ActionForm 实例不存在,就创建一个 ActionForm 对象,把客户提交的表单数据保存到
ActionForm 对象中;
3\)根据配置信息决定是否需要表单验证.如果需要验证,就调用 ActionForm 的 validate()方
法;
4\)如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的 ActionErrors
对象,就表示表单验证成功;1.  ActionServlet 根据 ActionMapping 所包含的映射信息决定将请求转发给哪个 Action,如果相
应的 Action 实例不存在,就先创建这个实例,然后调用 Action 的 execute()方法;
2.  Action 的 execute()方法返回一个 ActionForward 对象,ActionServlet 在把客户请求转发给
ActionForward 对象指向的 JSP 组件;
3.  ActionForward 对象指向 JSP 组件生成动态网页,返回给客户;1.  请简单画出 struts 技术构建 mvc 的流程图2.  什么是 ORM？
解答：对象关系映射（Object—Relational Mapping，简称 ORM）是一种为了解决面向
对象与面向关系数据库存在的互不匹配的现象的技术；简单的说，ORM 是通过使用描述对
象和数据库之间映射的元数据，将 java 程序中的对象自动持久化到关系数据库中；本质上
就是将数据从一种形式转换到另外一种形式。3.  为什么要使用 Spring 框架，它有什么优点？
(1)轻量级的框架
(2)非侵入性的
(3)可以整合其它的框架，比如 Struts，Hibernate 等
(4)可以提供事务管理4.  MyBatis 原理,为什么使用，优点是什么
封装了 JDBC 操作,将 SQL 查询结果映射为对象,将对象属性值映射到 SQL. 步骤：
1\)解析 SqlMapConfig.xml 和 SqlMap.xml(定义 SQL)
2\)将解析出的 SQL 生成 MappedStatement(预编译 Statement)
3\)将传入的 SQL 参数给 Statement 绑定,参数类型可以为 java 对象,Map 类型,int,String 类
型
4\)执行 mappedstatement,返回 sql 结果
5\)将返回的 SQL 结果转为 Java 对象,Map,int,String 类型返回
优点:简化数据库访问操作,便于实现 DAO 操作
405.  Mybatis 和 Hibernate 的区别
共同点：
Hibernate 和 Mybatis 都是 orm 对象关系映射框架，都是用于将数据持久化的框架技术。
区别：6.  Hiberante 较深度的封装了 jdbc，对开发者写 sql 的能力要求的不是那么的高，我们只要
通过 hql 语句操作对象即可完成对数据持久化的操作了。7.  hibernate 可移植性好，使用 hibernate 只需改变一下数据库方言即可搞定。用 hibernate
框架，数据库的移植变的非常方便。
3 .hibernate 生成的 sql 语句耗费程序资源，优化起来也不是很方便，且对存储过程支持
的也不够太强大。8.  Mybatis 是对 jdbc 的封装，但是封装的没有 hibernate 那么深，我们可以再配置文件中
写 sql 语句，可以根据需求定制 sql 语句，数据优化起来较 hibernate 容易很多。9.  Mybatis 要求程序员写 sql 的能力要相对使用 hibernate 的开发人员要高的多，且可移植
性也不是很好。
6.处理大数据时使用 Mybatis 比较好，因为优化较方便。10. 什么是 AOP 和 OOP，IOC 和 DI 有什么不同
1）面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计
算机编程架构。AOP 是 OOP 的延续，是 Aspect Oriented Programming 的缩写，意思是面向
方面编程。将通用需求功能从不相关类之中分离出来；同时，能够使得很多类共享一个行为，
一旦行为发生变化，不必修改很多类，只要修改这个行为就可以。AOP 就是这种实现分散关
注的编程方法，它将“关注”封装在“方面”中。
2）控制反转 IOC(Inversion of Control)控制指的就是程序相关类之间的依赖关系.传统观
念设计中,通常由调用者来创建被调用者的实例,在 Spring 里,创建被调用者的工作不再由调
用者来完成,而是由 Spring 容器完成，依赖关系被反转了，称为控制反转，目的是为了获得
更好的扩展性和良好的可维护性。依赖注入(Dependency injection)创建被调用者的工作由
Spring 容器完成，然后注入调用者，因此也称依赖注入。控制反转和依赖注入是同一个概念。11. 介绍一下 springMVC 的工作原理、为什么用
spring？
springMVC 工作原理：
1）.spring mvc 请所有的请求都提交给 DispatcherServlet,它会委托应用系统的其他模块
负责负责对请求进行真正的处理工作。
2）.DispatcherServlet 查询一个或多个 HandlerMapping,找到处理请求的 Controller. 3）.DispatcherServlet 请请求提交到目标 Controller
4）.Controller 进行业务逻辑处理后，会返回一个 ModelAndView
5）.Dispathcher 查询一个或多个 ViewResolver 视图解析器,找到 ModelAndView 对象
指定的视图对象
41
6）.视图对象负责渲染返回给客户端。为什么用 spring：
AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用
程序代码中。使用 AOP 后，公共服务（比如日志、持久性、事务等）就可以分解成方面并
应用到域对象上，同时不会增加域对象的对象模型的复杂性。IOC 允许创建一个可以构造对
象的应用环境，然后向这些对象传递它们的协作对象。正如单词倒置所表明的，IOC 就像反
过来的 JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight
construction），每一个对象都是用其协作对象构造的。因此是由容器管理协作对象
（collaborator）。Spring 既是一个 AOP 框架，也是一 IOC 容器。Spring 最好的地方是它有助
于您替换对象。有了 Spring，只要用 JavaBean 属性和配置文件加入依赖性（协作对象）。然
后可以很容易地在需要时替换具有类似接口的协作对象。12. spring 常用注解
@Repository、@Service、@Controller
@Controller 对应表现层的 Bean，也就是 Action
@Service 对应的是业务层 Bean
@Repository 对应数据访问层 Bean13. AOP 里面重要的几个名词概念解释
切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是
J2EE 应用中一个关于横切关注点的很好的例子。 在 Spring AOP 中，切面可以使用通用类
（基于模式的风格）或者在普通类中以@Aspect 注解（@AspectJ 风格）来实现。
连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处
理异常的时候。在 Spring AOP 中，一个连接点总是代表一个方法的执行。通过声明一个
org.aspectj.lang.JoinPoint 类型的参数可以使通知（Advice）的主体部分获得连接点信息。
通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种
类型，其中包括“around”、“before”和“after”等通知。通知的类型将在后面部分进行
讨论。许多 AOP 框架，包括 Spring，都是以拦截器做通知模型，并维护一个以连接点为中
心的拦截器链。
切入点（Pointcut）：匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，
并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达
式如何和连接点匹配是 AOP 的核心：Spring 缺省使用 AspectJ 切入点语法。
引入（Introduction）： （也被称为内部类型声明（inter-type declaration））。声明额外的
方法或者某个类型的字段。Spring 允许引入新的接口（以及一个对应的实现）到任何被代
理的对象。例如，你可以使用一个引入来使 bean 实现 IsModified 接口，以便简化缓存机制。
目标对象（Target Object）：被一个或者多个切面（aspect）所通知（advise）的对象。
也有人把它叫做被通知（advised）对象。既然 Spring AOP 是通过运行时代理实现的，这个
对象永远是一个被代理（proxied）对象。
AOP 代理（AOP Proxy）：AOP 框架创建的对象，用来实现切面契约（aspect contract）
（包括通知方法执行等功能）。 在 Spring 中， AOP 代理可以是 JDK 动态代理或者 CGLIB 代
理。
注意：Spring 2.0 最新引入的基于模式（schema-based）风格和@AspectJ 注解风格的切面声
42
明，对于使用这些风格的用户来说，代理的创建是透明的。
织入（Weaving）：把切面（aspect）连接到其它的应用程序类型或者对象上，并创建
一个被通知（advised）的对象。这些可以在编译时（例如使用 AspectJ 编译器），类加载
时和运行时完成。Spring 和其他纯 Java AOP 框架一样，在运行时完成织入。14. Spring 的 MVC 和 Struts 的 MVC 的区别
1.机制：spring mvc 的入口是 servlet，而 struts2 是 filter. 2.性能：spring 会稍微比 struts 快。
3.参数传递：struts 是在接受参数的时候，可以用属性来接受参数，这就说明参数是让
多个方法共享的。
4.设计思想上： struts 更加符合 oop 的编程思想， spring 就比较谨慎，在 servlet 上扩展。15. intercepter 的实现机制：struts 有以自己的 interceptor 机制，spring mvc 用的是独立的
AOP 方式。
6.另外，spring3 mvc 的验证也是一个亮点，支持 JSR303，处理 ajax 的请求更是方便，
只需一个注解@ResponseBody，然后直接返回响应文本即可。 算法类16. 排序都有哪几种方法？用伪代码实现一个快速
排序
解答：排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速
排序），选择排序（直接选择排序、堆排序），归并排序，分配排序（箱排序、基数排序）
快速排序的伪代码：使用快速排序方法对 a\[ 0 \:n- 1 ]排序从 a\[ 0 \:n- 1 ]中选择一个元素作为
middle，该元素为支点；把余下的元素分割为两段 left 和 right，使得 left 中的元素都小于等
于支点，而 right 中的元素都大于等于支点；递归地使用快速排序方法对 left 进行排序；递
归地使用快速排序方法对 right 进行排序；所得结果为 left + middle + right。 数据库17. Java数据库编程包含哪些类？Java 数据库编程
的基本过程是什么？
用到的类：Connection、ResultSet、错误！超链接引用无效。错误！超链接引用
43
无效。Java 中访问数据库的步骤如下：
1）注册驱动；
2）建立连接；
3）创建 Statement；
4）执行 sql 语句；
5）处理结果集（若 sql 语句为查询语句）；
6）关闭连接。18. 事务是什么？有哪些属性，并简要说明这些属性
的含义
事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元
(unit)。事务通常由高级数据库操纵语言或编程语言（如 SQL，C++或 Java）书写的用户程序
的执行所引起，并用形如 begin transaction 和 end transaction 语句（或函数调用）来界定。
事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。
事务应该具有 4 个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为 ACID
特性。原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要
么都做，要么都不做。一致性（consistency）。事务必须是使数据库从一个一致性状态变到
另一个一致性状态。一致性与原子性是密切相关的。隔离性（isolation）。一个事务的执行
不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并
发执行的各个事务之间不能互相干扰。持久性（durability）。持续性也称永久性
（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接
下来的其他操作或故障不应该对其有任何影响。19. 如何优化数据库，如何提高数据库的性能?
解答：
1）硬件调整性能最有可能影响性能的是磁盘和网络吞吐量,解决办法扩大虚拟内存，
并保证有足够可以扩充的空间；把数据库服务器上的不必要服务关闭掉；把数据库服务器
和主域服务器分开；把 SQL 数据库服务器的吞吐量调为最大；在具有一个以上处理器的机器
上运行 SQL。
2）调整数据库若对该表的查询频率比较高，则建立索引；建立索引时，想尽对该表的
所有查询搜索操作，按照 where 选择条件建立索引，尽量为整型键建立为有且只有一个簇
集索引，数据在物理上按顺序在数据页上，缩短查找范围，为在查询经常使用的全部列建立
非簇集索引，能最大地覆盖查询；但是索引不可太多，执行 UPDATE DELETE INSERT 语句需要
用于维护这些索引的开销量急剧增加；避免在索引中有太多的索引键；避免使用大型数据类
型的列为索引；保证每个索引键值有少数行。
3）使用存储过程应用程序的实现过程中，能够采用存储过程实现的对数据库的操作尽
量通过存储过程来实现，因为存储过程是存放在数据库服务器上的一次性被设计、编码、
测试，并被再次使用，需要执行该任务的应用可以简单地执行存储过程，并且只返回结果
集或者数值，这样不仅可以使程序模块化，同时提高响应速度，减少网络流量，并且通过
输入参数接受输入，使得在应用中完成逻辑的一致性实现。
44
45
4）应用程序结构和算法建立查询条件索引仅仅是提高速度的前提条件，响应速度的提
高还依赖于对索引的使用。因为人们在使用 SQL 时往往会陷入一个误区，即太关注于所得的
结果是否正确，特别是对数据量不是特别大的数据库操作时，是否建立索引和使用索引的好
坏对程序的响应速度并不大，因此程序员在书写程序时就忽略了不同的实现方法之间可能存
在的性能差异，这种性能差异在数据量特别大时或者大型的或是复杂的数据库环境中（如联
机事务处理 OLTP 或决策支持系统 DSS）中表现得尤为明显。在工作实践中发现，不良的 SQL
往往来自于不恰当的索引设计、不充份的连接条件和不可优化的 where 子句。在对它们进
行适当的优化后，其运行速度有了明显地提高！20. 请说出两种以上扩大数据库的方式
1\)修改现有表空间的大小；
2\)向表空间插入一个新的数据文件
(1) 基本概念：
JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、
一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接
的交互。
(2) 运行过程：
13/04/2018 Page 20 of 283
我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，
而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。
也就是如下：
① Java 源文件—-&gt;编译器—-&gt;字节码文件
② 字节码文件—-&gt;JVM—-&gt;机器码
每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够
跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会
存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不
能共享。
 
笔记本： Java面试题
创建时间： 2018/9/8 星期六 15:57 更新时间： 2018/9/9 星期日 19:24
作者： 这个名字其实还是很长很长的
第二题 Exception 和 Error 有什么区别
请对比Exception和Error,另外,运行时异常与一般异常有什么区
别?
典型回答:
Exception和Error都是继承了Throwable类,在Java中只有Throwable类型
的实例才可以被抛出或者捕获,它是异常处理机制的基本组成类型。Exceptoin
和Error体现了Java平台设计者对于不同异常情况的分类。Exception是程序正
常运行中,可以预料的意外情况,可以并且应该被捕获,进行相应处理。Error是
指在正常情况下,不大可能出现的情况,绝大部分的Error都会导致处于非正常的
不可恢复状态。既然是非正常情况,所以不便于也不需要捕获,常见的比如
OutofMemoryError之类,都是Error的子类。
Exceptoin又分为可检查异常和不检查异常,可检查异常在代码里必须显示
地进行捕获处理,这是编译器检查的一部分。不检查异常就是所谓的运行时异
常,类似于NullPointerException ArrayIndexOutofBoundsException之类,通
常是可以编码避免的逻辑错误,具体根据需要来进行判断是否需要捕获,并不会
在编译期强制要求。
知识扩展:
在开发中尽量不要捕获类似Exceptio这样的通用异常,而是应该捕获特定异
常.这是因为我们在日常的开发和合作中,我们读代码的机会往往超过写代码,软
件工程是门协作的艺术,所以我们有义务让自己的代码能够直接地体现出尽量多
的信息,而泛泛的Exception之类,恰恰隐藏了我们的目的。另外,我们也要保证
程序不会捕获到我们不希望捕获的异常。比如,你可能更希望RuntimeException
被扩散出来,而不是被捕获。
在开发中不要生吞异常。这是异常处理中要特别注意的事情,因为很可能会
导致非常难以诊断的诡异情况。生吞异常,往往是基于假设这段代码可能不会发
生,或者感觉忽略异常是无所谓的,但是千万不要在产品代码做这种假设！如果
我们不把异常抛出来,或者也没有输出日志之类,程序可能在后续代码以不可控
的方式结束。没有人能够轻易判断究竟是哪里出了异常,以及是什么原因产生了
异常。
在开发中不要输出标准错误（STERR）,因为有时候你很难判断出到底输出
到哪里去了。尤其是分布式系统,如果发生异常,但是无法找到堆栈轨迹,这纯属
是为诊断设置障碍。所以最好使用产品日志,详细地输出到日志系统里。
Throw early,catch late。在开发中可能会出现各种情况,比如获取配置
失败之类的。在发现问题的时候,第一时间抛出,能够更加清晰地反映问题,这是
Throw early。catch late就是我们经常烦恼的问题,捕获异常后,需要怎么处
理?最差的方式,就是我们前面提到的&quot;生吞异常&quot;,本质上就是掩盖问题。如果实
在不知道如何处理,可以选择保留原有异常的cause 信息,直接再抛出或者构建
新的异常抛出去。在更高层,因为有了清晰的(业务)逻辑,往往会更清楚合适的
处理方式是什么。
有时候,我们会根据需要自己定义异常,这个时候除了保证提供足够的信息,
还需要考虑两点。一是否需要定异常CheckedException,因为这种类型的设计初
衷是为了从异常情况恢复,作为异常设计者,我们往往有充足信息进行分类。在
保证诊断信息足够的同时,也要考虑避免包含敏感信息,因为那样可能会导致潜
在的安全问题。如果我们看Java的标准类库,你可能注意到类似
java.net.ConnectException,出错信息是类似&quot;Connection refused&quot;,而不包
含具体的机器名 IP 端口等,一个重要的考量就是信息安全。类似的情况在日志
系统中也有,比如,用户数据一般是不可以输出到日志里面的。
try-catch 代码段会产生额外的性能开销,或者换个角度来说,它往往会影
响JVM对代码进行优化,所以建议仅捕获有必要的代码段.尽量不要一个大的try
包住整段代码,与此同时,利用异常控制代码流程,也不是一个好主意,远比我们
通常意义上的条件语句要低效。
额外:
NoClassDeFoundError和ClassNotFoundException的区别?
首先NoClassDeFoundError是一个错误,ClassNotFoundException是一个异
常。ClassNotFoundException的产生原因,Java支持使用Class.froName方法
来动态地加载类,任意一个类的类名如果被作为参数传递给这个方法都将导致该
类被加载到JVM内存中,如果这个类在类路径中没有被找到,那么此时就会在运行
时抛出ClassNotFoundException异常。另外还有一个导致
ClassNotFoundException的原因就是,当一个类已经被某个类加载器加载到内
存中,此时另一个类加载器又尝试着动态地从同一个包中加载这个类。
NoClassDeFoundError产生的原因在于:如果JVM或者ClassLoader实例尝试加载
类的时候找不到类的定义。例如要查找的类在编译的时候是存在的,运行的时候
找不到了。这个时候就会导致NoClassDefFoundError。造成该问题的原因可能
是打包过程中漏掉了部分类,或者jar包出现损坏或者篡改。解决这个问题的办
法就是查找那些在开发期间存在与类路径下,但在运行期间却不在类路径下的
类。笔记本： Java面试题
创建时间： 2018-10-27 8:52 更新时间： 2018-10-27 12:26
作者： 这个名字其实还是很长很长的
第三题 对比Hashtable、HashMap、TreeMap有什么不同？
对比Hashtable、HashMap、TreeMap有什么不同？
典型回答:
HashTable HashMap TreeMap都是最常见的一些Map实现,是以键值对的形式存储和操作
数据的容器类型。
HashTable是早期Java类库提供的一个哈希表实现,本身是同步的,不支持null键和值,由
于同步导致的性能开销,所以已经很少被推荐使用。
HashMap是应用更加广泛的哈希表实现,行为大致上与HashTable一致,主要区别在于
HashMap不是同步的,支持null键和值等。通常情况下,HashMap进行put或者get操作,可
以达到常数时间的性能,所以它是绝大部分利用键值对存储场景的首选,比如,实现一个用
户ID和用户信息对应的运行时存储结构。
TreeMap则是基于红黑树的一种提供顺序访问的Map,和HashMap不同,它的get remove之
类操作都是O(long(n)的时间复杂度,具体顺序可以由指定的Comparator来决定或者根据
键的自然顺序来判断。
知识扩展:
HashMap实现原理是经常被问到的一个问题,以下基于JDK1.8分析。
一 内部存储
HashMap的内部存储是一个数组,数组的元素Node实现了Map.Entry接口
(hash,key,value,next),next非空时指向定位相同的另一个Entry,如图:
JDK 8 之前，其内部是由数组+链表来实现的，而 JDK 8 对于链表长度超过 8 的链表将
转储为红黑树。
二 容量(capacity)和负载因子(loadFactor)
简单的说,capacity就是数组的大小,loadFactory就是数组填满程度的最大比列。当数
组中的元素的数目大于capacity\*loadFactor时就需要扩容,调整数组的大小为当前的2
倍。同时初始化容量的大小也是2的次幂(大于等于设定容量的最小次幂),则数组的大小
在扩容前后都将是2的次幂。默认的容量为16,负载因子为0.75。
三 put方法的大致的思路
1 如果key的值为null,则将该键值对 添加到table\[0]处，遍历该链表，如果有key为
null，则将value替换。
2 如果key不为null,获取key的hashCode值,经过indexFor()方法运算得到的值作为标识,但
由于hashCode的值并不唯一,经过运算获取的值也不能保证唯一(哈希冲突),所以,经过以上
运算得来的数值只能作为数组的索引。
3 当通过索引定位到这个节点时,在遍历该链表,判断是否存在相同的key对象,如果存在 就
用新的value覆盖旧的value
4 如果不存在,就创建一个Entry对象添加到table\[i]处,如果table\[i]已经存在其他元素,
那么新Entry对象将会保存在链表的表头,通过next指针指向原有的Entry对象,形成链表结
构。
5 当链表的结构太长时(默认超过8个元素),链表就会转为红黑树。
四 get方法的大致的思路
1 对key进行null检查。如果key是null，table\[0]这个位置的元素将被返回
2 key的hashcode()方法被调用，然后计算hash值。
3 indexFor(hash,table.length)用来计算要获取的Entry对象在table数组中的精确的位置
(使用刚才计算的hash值)
4 在获取了table数组的索引之后，会迭代链表，调用equals()方法检查key的相等性，如
果equals()方法返回true，get方法返回Entry对象的value，否则，返回null。笔记本： Java面试题
创建时间： 2018-10-28 9:18 更新时间： 2018-10-28 9:46
作者： 这个名字其实还是很长很长的
第四题 ArrayList Vector LinkedList的区别?
ArrayList Vector LinkedList的区别?
典型回答:
这三者都是实现集合框架中的List,也就是所谓的有序集合,因此具体功能也比较类似,比如
都提供按照位置进行定位 添加或者删除的操作,都提供迭代器以遍历其内容等。但因为具
体的设计区别 在行为 性能 线程安全等方面,表现又有很大不同。
Vector是Java早期提供的线程安全的动态数组,如果不需要线程安全,并不建议选择,毕竟同
步是有额外开销的。Vector内部是使用对象数组来保存数据,可以根据需要自动的增加容
量,当数组以满时,会创建新的数组,并拷贝原有数组数据。
ArrayList是应用更加广泛的动态数组实现,它本身不是线程安全的,所以性能要好很多。与
Vector近似,ArrayList也是可以根据需要调整容量,不过两者的调整逻辑有所区别,Vector
在扩容时会提高1倍,而ArrayList则是增加50%。
LinkedList顾明思议是Java提供的双向链表,所以它不需要像上面两种那样调整容量,它也
不是线程安全的。
Vector和ArrayList作为动态数组,其内部元素以数组形式顺序存储的,所以非常适合随即访
问的场合。除了尾部出入元素和删除元素,往往性能会相对较差,比如我们在中间位置插入
一个元素,需要移动后续所有元素。而LinkedList进行节点插入 删除却要高效得很多,但是
随即访问性能则要比动态数组慢。笔记本： Java面试题
创建时间： 2018-10-27 14:29 更新时间： 2018-10-27 16:58
作者： 这个名字其实还是很长很长的
第五题 如何保证集合是线程安全的?ConcurrentHashMap 如何实现高效的线程安全?
如何保证集合是线程安全的? ConcurrentHashMap 如何实现高效的
线程安全?
典型回答:
Java提供了不同层面的线程安全支持。在传统集合框架内部,除了Hashtable Vector等同步
容器,还提供了同步包装器,我们可以调用Collections工具类提供的包装方法,来获取一个
同步的包装容器(例如Collections.synchronizedMap),但是它们都是利用非常粗粒度的同
步方式,在高并发情况下,性能比较底下,另外,更加普遍的选择是利用并发包提供的线程安
全容器类。具体保证线程安全的方式,包括有从简单的synchronize方式,到基于更加精细化
的,比如基于分离式锁实现的ConcurrentHashMap等并发实现等。具体选择要看开发的场景
需求,总体来说,并发包内提供的容器通用场景,远优于早期的简单同步实现。
知识扩展
1 为什么需要ConcurrentHashMap?
Hashtable本身比较低效,因为它的实现基本就是put get size等各种方法加
上&quot;synchronized&quot;。简单来说,这就导致了所有并发操作都要竞争同一把锁,一个线程在进
行同步操作时,其他线程只能等待,大大降低了并发操作的效率。前面说过HashMap不是线程
安全的,那么能不能利用Collections提供的同步包装器来解决问题?实际上同步器只是利用
输入Map构造了另一个同步版本,所有操作不再声明为synchronized方法,但是还是利用
了&quot;this&quot;作为互斥的mutex,没有真正意义上的改进。
所以,Hashtable或者同步包装版本,都只是适合在非高度并发的场景下。
2 ConcurrentHashMap工作机制
在早期的ConcurrentHashMap,其实现是基于分离锁,也就是将内部进行分段,里面则是
HashEntry的数据。和HashMap类似,哈希相同的条目也是以链表形式存放。(简单点来说,就
是在ConcurrentHashMap中,把Map分成了N个Segment,put和get的时候,都是现根据
key.hashCode()算出放到哪个Segment中)
在构造的时候,Segment的数量由所谓的concurrentcyLevel来决定,默认是16,也可以在相应
构造函数直接指定。注意,Java需要它是2的幂数值,如果输入是类似15这种非幂值,会自动
调整到16之类2的幂数值。
我们创建了3个线程分别向ConcurrentHashMap中添加数据,根据
ConcurrentHashMap.segmentFor的算法，当我们向ConcurrentHashMap中put key
为3或者4的数据时,此时他们对应的Segment都是segments\[1]，而put key为7对应的
数据时,此时对应的Segment是segments\[12]。那么当线程1在put(3,33)时,线程2也想
put(4,44)时,因为线程1和线程2操作的都是同一个Segment,线程1会首先获取到锁,可
以进入,线程2则会阻塞在锁上。线程3在put数据时,他对应的segments是12,他不会上
锁。 以上就是ConcurrentHashMap的工作机制，通过把整个Map分为N个Segment（类似
HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。笔记本： Java面试题
创建时间： 2018/9/8 14:54 更新时间： 2018/9/8 16:16
作者： 这个名字其实还是很长很长的
第一题 谈谈你对Java平台的理解
谈谈你对Java平台的理解? &quot;Java 是解释执行&quot;
,这句话正确么?
典型回答:
Java本身是一种面向对象的语言,最显著的特点有两个方面,一个是所谓的&quot;书写一
次,到处运行&quot;;能够非常容易地获得跨平台能力;另外就是垃圾收集器(GC)，Java通过垃
圾收集器回收分配内存,大部分情况下,程序员不需要自己操心内存的分配和回收。我们
日常接触到JRE或者JDK。JRE也就是Java运行环境,包含了JVM和Java类库,以及一些模块
等。而JDK可以看作是JRE的一个超集,提供了更多的工具,比如编译器 各种诊断工具。
&quot;对于Java是解释执行&quot;这句话,这个说法不准确。我们开发的Java的源代码,首先通
过Javac编译成为字节码,然后在运行时通过Java虚拟机内嵌的解释器将字节码转换为最
终的机器码。但是常见的JVM,比如我们大数据情况使用的Oracle JDK提供的Hostpot
JVM,提供了JIT编译器,就是通常所说的动态编译器,JIT能够在运行时将热点代码(高频
调用的方法和代码块)编译成机器码,这种情况下部分热点就属于编译执行,而不是解释执
行。这样类似于缓存技术,运行时在遇到热点代码可以直接执行,而不是先解释在执行。
知识扩展:
在运行时,JVM通过类加载器加载字节码,解释或者编译执行。就像我们前面提到的,
主流的Java版本中,如 JDK8实际是解释和编译混合的一种模式,即所谓的混合模式。JIT
编译器分为多种模式(Server模式 Client模式 AOT模式) 通常运行在Server模式的JVM,
会进行上万次调用以收集足够的信息进行高效编译,client模式这个门限是1500次。
Oracle Hostpot JVM 内置了两个不同的JIT compiler,C1对应前面说的client模式,适
用于对于启动速度敏感的应用,比如普通Java桌面应用;C2对应Server模式,它的优点是
为长时间运行的服务器端应用设计的。
Java虚拟机启动时,可以指定不同的参数对运行模式进行选择。比如,执行&quot;-Xint&quot;,
就是告诉JVM只进行解释执行,不对代码进行编译,这种模式抛弃了JIT可能带来的性能优
势。毕竟解释器是逐条读入,逐条解释运行的。与其相对性的,还有一个&quot;Xcomp&quot;参数,这
是告诉JVM关闭解释器,不要进行解释执行,或者叫做最大优化级别。那你可能会问这种
模式是不是最高效啊?简单来说,还真未必。&quot;-Xcomp&quot;会导致JVM启动变慢非常多.
除了日常最常见的Java使用模式,其实还有一种新的编译方式,即所谓的AOT,直接将
字节码编译成机器码,这样就避免了JIT预热等各方面的开销,比如Oracle JDK 9就引入
了实性质的AOT特性,并且增加了jaotc工具。
另外,JVM作为一个强大的平台,不仅仅只有Java语言可以运行在JVM上,本质上合规
的字节码都可以运行,Java语言自身也为此提供了便利,我们可以看到类似Clojure
Scala Groovy JRuby Jython等大量JVM语言,活跃在不同的场景。3、介绍Collection框架的结构
答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。3、Collection框架中实现比较要实现什么接口
comparable/comparator
3、ArrayList和Vector的区别
答：
这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与hashset没有任何关系，但为了说清楚ArrayList与Vector的功能，我们使用对比方式，更有利于说明问题）。接着才说ArrayList与Vector的区别，这主要包括两个方面：.
（1）同步性：
Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。备注：对于Vector\&amp;ArrayList、Hashtable\&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。
（2）数据增长：
ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。
总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。
4、HashMap和Hashtable的区别
（条理上还需要整理，也是先说相同点，再说不同点）
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。
HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。
HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。
最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。就HashMap与HashTable主要从三方面来说。
一.历史原因\:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现
二.同步性\:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的
三.值：只有HashMap可以让你将空值作为一个表的条目的key或value
5、List 和 Map 区别?
一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。
35、List, Set, Map是否继承自Collection接口?
List，Set是，Map不是109、List、Map、Set三个接口，存取元素时，各有什么特点？
这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不明白。首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。
List表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。
Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。HashSet按照hashcode值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储。例如，&quot;abc&quot; ---&gt; 78，&quot;def&quot; ---&gt; 62，&quot;xyz&quot; ---&gt; 65在hashSet中的存储顺序不是62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet按插入的顺序存储，那被存储对象的hashcode方法还有什么作用呢？学员想想!hashset集合比较两个对象是否相等，首先看hashcode方法是否相等，然后看equals方法是否相等。new 两个Student插入到HashSet中，看HashSet的size，实现hashcode和equals方法后再看size。同一个对象可以在Vector中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往HashSet中却加不了多次的。7、说出ArrayList,Vector, LinkedList的存储性能和特性
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。
4、去掉一个Vector集合中重复的元素
Vector newVector = new Vector();
For (int i=0;i\&lt;vector.size();i++)
&#123;
Object obj = vector.get(i);
if(!newVector.contains(obj);
newVector.add(obj);
&#125;
还有一种简单的方式，HashSet set = new HashSet(vector);
9、Collection 和 Collections的区别。
　　Collection是集合类的上级接口，继承与他的接口主要有Set 和List.
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
39、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?
Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。
equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。53、你所知道的集合类都有哪些？主要方法？
最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。
Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作&quot;键&quot;和&quot;值&quot;），其中每个键映射到一个值。ArrayList/VectorList
Collection
HashSet/TreeSetSetPropetiesHashTable
Map
Treemap/HashMap我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，我记得不是很清楚，对于set，大概的方法是add,remove, contains；对于map，大概的方法就是put,remove，contains等，因为，我只要在eclispe下按点操作符，很自然的这些方法就出来了。我记住的一些思想就是List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value。45、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?
对。
如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。
如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的，例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。
46、TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！
（应该是没有针对问题的确切的答案，当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的）
112、说出一些常用的类，包，接口，请各举5个
要让人家感觉你对java ee开发很熟，所以，不能仅仅只列core java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。常用的类：BufferedReader  BufferedWriter  FileReader  FileWirter  String  Integer
java.util.Date，System，Class，List,HashMap常用的包：java.lang   java.io  java.util  java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate
常用的接口：Remote  List  Map  Document  NodeList ,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate)、Session(Hibernate),HttpSession1.Spring 是如何解决循环依赖的问题的？比如A autowired B，Bautowired A，内部是如何是如何实现的？
4.Spring boot何时启动结束；（58、）
5.Spring boot 启动类上的注解 @spring boot Application说明？
Spring boot如何判断当前应用是否时web应用？
spring boot启动流程：
1）构造SpringApplication实例，在构造过程中有判断当前应用的类型，代码如下：
this.webApplicationType = WebApplicationType.deduceFromClasspath();
2）、执行run方法：
（1）、创建并应用监听；
（2）、加载配置文件；
（3）、准备并刷新上下文；
6.Bean Factory与FactoryBean有什么区别？@Bean这个注解时如何实现Bean的注入的？
BeanFactory是一个工厂类的接口，是spring IOC的容器的核心接口，它的职责实例化、定位、配置应用程序中的对象即建立这些对象的依赖；
FactoryBean是一个Bean，它是实现了FactoryBean\&lt;T&gt; 接口的bean，根据该Bean的Id从BeanFactory中获取的实际是BeanFactory的getObject返回的对象，而不是Factory Bean本身；即BeanFactory是用来获取对象的，Bean Factory是用来管理对象的。
7.Java中的静态方法只有一个实例，如果想用多个实例怎么办？
8.深度克隆的主要实现方式？
9.Java面向对象的基本特征，继承、封装与多态；
10.重写和重载的是什么意思？
11.怎样生命一个类不会被继承？final
12.Integer是基本数据类型还是引用数据类型？
13.HashMap中jdk1.7与jdk1.8的区别（58）；
二叉树-》平衡二叉树-》红黑树；
14.concurrenthashMap 的底层实现原理（58）；
15.spring、spring boot、springcloud之间的关系；
16.Java种的自增是线程安全的吗，如何实现线程安全的自增？
17.Jdk1.8种的stream有用过吗，stream的并行操作原理，stream并行的线程池是从哪里来的；
18.Jdk1.8的completableFuture有用过吗；
19.Java种的代理有几种实现方式；Java 并发及JVM相关:
1.线上部署时出现内存溢出该如何处理？
1、使用top命令查看当前进程对应的内存大小信息，并使用shift+M按照内存大小进行排序，查看进程中内存占用较大的进程；
2、利用jstat查看某一进程虚拟机的GC情况；
3、生成dump文件，通过dump文件查看当时内存对象相关的信息；生成dump文件有两种方式：
1）、使用jmap直接生成dump文件；
jmap -dump\:format=b,file=heap.prof  17561 ；
format=b:表示生成二进制类型的dump文件；
file=：后面写的四输出的dump文件路径；
17561：jvm进程ID；
2.Java多线程几种状态变更的图，图中包括线程所处的状态及线程各个状态之间是如何切换的？
3.Java中的wait和sleep的区别与联系？
4.Java.untils.concurrent包主要用到了哪些知识？
并发容器：
同步锁（两种）：
线程池：
并发工具(3种):
5.如何在方法栈中进行数据传递？
使用volatile关键字
6.ThreadLocal的底层实现形式及实现的数据结构？
7.Java有返回值的多线程使用？
8.Java中值类型和引用类型的区别（==与equals()的区别、Java中的引用类型：值引用与）；
9.Java中方法参数的传递时值传递还引用传递？
10.Java中堆和栈的区别？
11.JVM 内存划分与垃圾收集算法：fullGC与youngGC；
12.Java JVM相关内容结合项目介绍；
13.线上如何排查JVM内存溢出问题？
1.可以通过idea进行远程debugger；
2.相关命令jstat、jmap、jconsole等；
3.相关的工具，如阿里的阿尔萨斯等；
14.服务器CPU占用特别高，怎么查看（58），面试重点JVM及多线程；
15.Array List是线程安全的吗？
16.ConcurrentHash Map是如何实现线程安全的；
17.Sychornized是否是公平锁；
18.JVM为什么要增加元空间；
19.Javam如何查看问题，并进行jvm调优；
20.堆G1垃圾收集器有了解么，有什么特点；Mysql面试题：
1.Mysql MVCC、MySQL为什么选择B+树作为它的存储结构，为什么不选择Hash、二叉、红黑树（58）；
a)如果仅仅是select \* from  table where id =45,上面三种数据结构都可以实现，但是如果是select \* from table where id &lt;45;则它们的查找方式就类似于全表扫描。B+树只在最末端叶子节点存数据，叶子节点是以链表形式相互指向的；
b)为什么不选择Hash索引：Hash索引不适合范围查找，而B+树特别适合范围查找；Hash索引每次查询都需要加载所有的索引数据到内存中，而B+树只需要根据匹配规则选择对应的叶子数据加载即可；
2.Mysql如何写sql才能提高sql的执行效率；
3.Mysql数据库的事务与锁的理解；
4.数据库临时表有没有用过，是怎么用的？
5.添加索引的缺点？
6.Mysql的最左原则；
7.Mysql的锁：两条sql语句分别执行如下：
sql1：更新数据的ID between 10 and 20 ；
sql2：更新数据的ID为11；
那么这个锁是如何保证11这条数据不被更新的呢？
8.Mysql的sql优化
1、Mysql使用过程中走索引的语句；
2、索引的优化
3、亿级的数据必须使用like进行查询，如何优化
9.多数据源情况下如何进行事物的管理；
10.Union和union all有什么区别；
11.dateTime和timestamp有什么区别；
12.mysql数据库事务的几种形式，模式事务级别，Oracle、SQL server默认事务级别；
读未提交；
读已提交；
不可重复读；
可序列化；
13.mysql主从模式的实现；
14.如何解析sql语句；即explain关键字的使用；
a)Select\_type:查询类型，是简单查询还是复核查询；
b)Type：对表的访问类型：All、index、range、ref、eq\_ref、const、system、null；从左到右，性能从差到好；
c)Possible\_keys:指出mysql能使用按个索引在表中找到记录；
d)Key：该列显示mysql实际使用的索引；
e)Filtered：按表条件过滤行的百分比；
f)Extra：执行情况的描述和说明；
15.为什么不对mysql的所有表都添加索引？
16.Mysql索引为什么不用hash而用B+树;Hash的时间复杂度是多少；
17.B+树索引可以进行范围查询吗，比如大于小于；
18.应用种mysql是集群还是单节点，最大表数据量是多少；
19.Mysql的主从同步原理，mysql主从复制主要有几种模式；
a)Mysql主库在事务提交时会把数据库变更作为事件event记录在二进制文件binlog中；mysql主库上的sys\_binlog控制binlog日志刷新到磁盘；
b)主库推送二进制文件binlog中的事件到从库的中继日志relay log，知乎从库根据中继日志重做数据库变更操作。通过逻辑复制，以此来达到数据一致。
c)Mysql通过三个线程来完成主从库之间的数据复制：其中binLog Dump线程泡在主库上，I/O线程和SQL线程泡在从库上。当从库启动复制时，首先创建一个I/O线程连接主库，主库随后创建binlog dump线程读取数据库时间并发送给I/O线程，I/O线程获取到数据库事件更新到从库的中继日志realy log中，之后从库上的sql线程读取中继日志relay log中更新的数据库事件并应用；Mysql主从复制主要有三种模式：
d)基于sql语句的复制（statement-based replication,SBR）;
e)基于行的复制（row-based replication,RBR）;
f)混合模式复制（mixed-based replication,MBR）;Java框架相关：
1.RabbitMQ的使用；
2.Zookeeper的原理，什么情况下会使用zookeeper，zookeeper如何监听生成的节点，zk内部是如何实现的；
3.Springcloud eureka是如何注册服务、如何监测心跳的，它注册的流程是怎么样的；
4.Redis在项目中是如何使用的；
5.在分布式环境中如何快速发现某一台服务有问题；
6.Mysql中如何设置一个字段为自增的；
7.分布式集群系统对外提供接口的时候如何验证对方的身份；
8.Spring boot整合jsp的流程，需要注意哪些点；
9.Eureka和zookeeper作为注册中心有什么区别（58）；
a)CAP理论：一致性（consistency）、可用性（Aviailability）、分区容错性（Partition tolerance）三者只能满足其二；
b)CA：不是分布式架构，就使用这种，关系数据库按照CA进行设计，放弃分区容错性，因为没有分区；
c)AP：加强可用性和分区容错性，放弃立即一致性（强一致性），追求最终一致性。比如eureka；比如微信提现，提示两小时到账，而不是马上到账；
d)CP：强调强一致性和分区容错性，放弃可用性，比如zookeeper，master在宕机后进行选举leader期间服务不饿能提供；比如夸张转账，就是立即到账，你这边转出，那边收进，才任务一个事务完成；
e)由于ZK采用的时cp原则，所以其可用性降低，这是致命的问题，springcloud集成的eureka采用的是ap原则，牺牲了一致性，但是保证了可用性；
10.Zookeeper0、zookeeper1、zookeeper2，三个节点的集群描述一下从zk启动，到zk对外提供服务的整个过程（58）；
a)Zookeeper集群leader的选举；
i.服务器初始化阶段和服务器运行期间leader挂掉情况选举机制大体相同，此处仅对服务器初始化启动期间进行说明；
ii.先后启动两台服务器，启动后两台服务器进行通信，每台服务器都试图找到lead，于是进入leader选举过程，过程如下：
iii.每个server发出一个投票，由于初始概况，server1和server2都会将自己作为leader服务器来进行投票，每次投票都会包含所推举的服务器的myId和ZXID，使用（myid，ZXID）来表示，此时server1的投票为（1，0），server2的投票为（2，0），然后各自将这个投票发给集群中的其他机器。
iv.接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票，是否来自lookiing状态的服务器。
v.处理投票：针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，pk规则如下：
优先检查ZXID。ZXID比较大的服务器优先作为leader。
如果ZXID相同，那么就比较myid。Myid比较大的服务作为leader服务器。
vi.统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受相同的投票信息，对于server1，server2而言，都统计出集群中已经有两台机器接受了（2，0）的投票信息，此时便认为已经选举出了leader；
vii.改变服务器状态。一旦确定了leader，每个服务器就会更新自己的状态，如果是follower，就会变成Followiing，如果是leader，就会变成Leading。
b)Zookeeper数据同步；
c)Zookeeper对外提供服务；
11.有一个key，往zk写入，到写入成功它的大体过程是什么样的（58）；a)此处有一个客户端client和zookeeper服务器；
b)Client向zookeeper的某一个server上写数据，发送一个写请求；
c)如果server1不是leader，那么server1会把接收到的请求进一步转发给leader，印美每个zookeeper集群里有一个是leader，这个leader会将写请求广播给各个server；各个server写陈工后就会通知leader；
d)当leader收到大多数server（超过一半）数据写成功了，那么就说明数据写成功了，如果是三个节点的话，只要有两个节点数据写成功了，那么就默认数据写陈工l ，写成功之后，leader会告诉server1数据写成功了。
e)Server1会进一步通知client数据写成功了，这时就认为整个写操作成功；12.Zookeeper监听器的原理；
a)首先要由一个main（）线程；
b)在main线程中创建zookeeper客户端，这是就会创建两个线程，一个负责网络连接通信，一个负责监听；
c)通过connect线程将注册的监听事件发送给zookeeper。
d)在zookeeper的注册监听器列表中将注册的监听时间添加到列表中。
e)Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。
f)listener线程内部调用了process方法；
13.排行榜功能的实现：使用redis的zset；zset的底层数据结构是什么样的；除了redis的zset还有什么其他的数据结构可以实现这个功能；1.a)Redis的zset底层实现是跳跃表，跳跃表的底层实现是链表+索引（如上图），具体详情请点 
15.Sychronized和ReentryLock的区别（重点:底层实现的区别）;
区别：1、2、3、4：Sychronized底层是unsafe方法、ReentryLock底层是（AQS）；
16.Redis集群种类：主从模式、cluster模式及其应用；
17.Redis种数据类型及应用场景；
18.Redis的使用场景及存储格式；redis的持久化；RDB与AOF的设置，redis种哪个版本开始可以进行分布式的使用；
a)Redis默认持久化方式为RDB：有三个策略：save 900 1\save 300 10\save 60 10000;
b)AOF默认是关闭的；
19.Nginx如何做限流？令牌桶算法与漏桶算法；
20.Tomcat调优；
21.为什么使用RPC框架，什么时候会使用http请求；
22.什么场景下会使用MQ；MQ的优势与劣势，什么时候不能用MQ（MQ做不到同步）；
23.Springcloud组件介绍；Linux服务器：
1.Linux如何查看应用占用内存情况；
2.Linux脚本编写会么；
3.线上应用的debugger；
idea有插件，可以远程链接服务器的代码，并在本地debugger；
其他工具\:pingpoint(分布式性能监测工具)；
4.服务器CPU数量及线程池数量的关系；
1、服务器cpu数量（n）；
2、是IO密集型（2n个线程）应用还是计算密集型（n+1个线程）应用；
算法题:
1.将一个矩阵顺时针旋转90°，请写出伪代码；
A11，A12，A13，							A31，A21，A11，
A21，A22，A23，  ——顺时针旋转90°——》  A32，A22，A22，
A31，A32，A33，							A33，A23，A13，
(行,列)
第i行第j列——》第（j）行第（n-i）列；
2.输入：a boy is good ，输出：good is boy a ；3.链表：1-&gt;2-&gt;3-&gt;4-&gt;5；请写一个程序，将链表反转过来：5-&gt;4-&gt;3-&gt;2-&gt;1;
综合考察：
1.如何做一个秒杀系统；
1、MQ做限流：保证只有1000个人可以访问系统；
2、使用redis做缓存；
3、redis往mysql中进行持久化
2.如何实现高可用、高并发、高吞吐的技术方案？
详细讲解请点这里 ，讲的非常好，需要仔细的看！（我给下载下来了，具体请看附件吧）高并发:应用缓存、HTTP缓存、多级缓存、池化、异步并发、扩容、队列；
高吞吐：分布式集群；
高可用：负载均衡与反向代理（nginx）、隔离（hystrix）、限流（MQ/nginx）、降级（hytrix）、超时与重试（hystrix）、回滚（hystrix）；
3.A给B发请求，B执行往数据库insert的操作；设计一个架构，保证能够提供最大的并发量，架构如下：20.分布式锁：
Redis实现方式：
redis：为什么使用setnx，或者说set 和setNx有什么区别；
setNx:系统在10：05 设置一个值，并给出5分钟的过期时间，系统刚刚set完之后redis集群崩溃，10：11分系统重启成功，那么redis中set的值是否还存在？
考察点：
1、redis 的持久化：刚set完是否能够被持久化到快照或者binlog日志中；
2、假设redis被持久化，且系统重启时间超过了redis设置的过期时间，那么key是否会被清理；
zookeeper实现方式：
4.缓存数据如何同DB同步更新？（mysql读取redis的binlog，进行数据的更新操作）其他：
1.处于什么目的考PMP；
2.一个项目启动大会，大概是一个什么过程？
1.介绍项目启动；
2.任命项目经理；
3.宣布项目正式启动；
3.对于自己来说，最近接触的比较新的东西或者知识；JVM、python；
4.Python2和python3的区别（因为我上一个回答了python，所以这里会问）；
5.对自己开发的系统的服务器硬件的了解；
6.在什么应用场景下需要升级服务器配置，什么场景下需要扩充集群；附件
1
前言
本题集由尚学堂学员整理，列举了众多 IT 公司面试真题，对应聘 Java 程序
员职位的常见考点和知识体系都进行的分类和归纳整理。
本题集适合应聘 Java 和 JavaEE 职位的程序员作为面试复习、学习和强化的
资料，也适合其他程序员作为拓展读物进行阅读。
本题集包含了常见的算法、面试题，也包含了新的高级技术，比如：微服务
架构等技术的面试题目。本题集非常全面，对于工作 1-5 年左右的 java 程序员
面试有非常好的指导作用。
Java 基础、语法：
696.Java 跨平台原理（字节码文件、虚拟机）
C/C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相
应的编译器重新编译。
Java 源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字
节码文件再解释成机器码运行。解释是通过 Java 虚拟机来执行的。
字节码文件不面向任何具体平台，只面向虚拟机。
Java 虚拟机是可运行 Java 字节码文件的虚拟计算机。不同平台的虚拟机是
不同的，但它们都提供了相同的接口。
Java 语言具有一次编译，到处运行的特点。就是说编译后的.class 可以跨平
台运行，前提是该平台具有相应的 Java 虚拟机。但是性能比 C/C++要低。
Java 的跨平台原理决定了其性能没有 C/C++高。
697.Java 的安全性
语言层次的安全性主要体现在：
Java 取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，
指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，
因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，
并且使用指针也容易数组越界。
垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动
回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错
误回收程序核心类库的内存，导致系统崩溃。
异常处理机制：Java 异常机制主要依赖于 try、catch、finally、throw、throws
五个关键字。
强制类型转换：只有在满足强制转换规则的情况下才能强转成功。
底层的安全性可以从以下方面来说明
Java 在字节码的传输过程中使用了公开密钥加密机制(PKC)。
在运行环境提供了四级安全性保障机制：
46
字节码校验器 -类装载器 -运行时内存布局 -文件访问限制
698.Java 三大版本
Java2 平台包括标准版（J2SE）、企业版（J2EE）和微缩版（J2ME）三个版
本：
Standard Edition(标准版) J2SE 包含那些构成 Java 语言核心的类。
比如：数据库连接、接口定义、输入/输出、网络编程
Enterprise Edition(企业版) J2EE 包含 J2SE 中的类，并且还包含用于开发
企业级应用的类。
比如 servlet、JSP、XML、事务控制
Micro Edition(微缩版) J2ME 包含 J2SE 中一部分类，用于消费类电子产品
的软件开发。
比如：呼机、智能卡、手机、PDA、机顶盒
他们的范围是：J2SE 包含于 J2EE 中，J2ME 包含了 J2SE 的核心类，但新添
加了一些专有类
应用场合，API 的覆盖范围各不相同。
699.什么是 JVM？什么是 JDK？ 什么是 JRE？
JVM：JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，它是整个 java
实现跨平台的最核心的部分，所有的 java 程序会首先被编译为.class 的类文
件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操
作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释
给本地系统执行。JVM 是 Java 平台的基础，和实际的机器一样，它也有自
47
己的指令集，并且在运行时操作不同的内存区域。 JVM 通过抽象操作系统
和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方
法、主机硬件、主机操作系统无关。JVM 的主要工作是解释自己的指令集（即
字节码）到 CPU 的指令集或对应的系统调用，保护用户免被恶意程序骚
扰。 JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的
类文件（.class 文件）
JRE：JRE 是 java runtime environment（java 运行环境）的缩写。光有 JVM
还不能让 class 文件执行，因为在解释 class 的时候 JVM 需要调用解释所需
要的类库 lib。在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件
夹 bin 和 lib,在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要
的类库，而 jvm 和 lib 和起来就称为 jre。所以，在你写完 java 程序编译
成.class 之后，你可以把这个.class 文件和 jre 一起打包发给朋友，这样你的
朋友就可以运行你写程序了（jre 里有运行.class 的 java.exe）。JRE 是 Sun
公司发布的一个更大的系统，它里面就有一个 JVM。JRE 就与具体的 CPU
结构和操作系统有关，是运行 Java 程序必不可少的（除非用其他一些编译
环境编译成.exe 可执行文件……），JRE 的地位就象一台 PC 机一样，我们写
好的 Win32 应用程序需要操作系统帮我们运行，同样的，我们编写的 Java
程序也必须要 JRE 才能运行。
JDK：JDK 是 java development kit（java 开发工具包）的缩写。每个学 java
的人都会先在机器上装一个 JDK，那 让我们看一下 JDK 的安装目录。在目
录下面有六个文件夹、一个 src 类库源码压缩包、和其他几个声明文件。其
48
中，真正在运行 java 时起作用的是以下四个文件夹：bin、include、lib、jre。
现在我们可以看出这样一个关系，JDK 包含 JRE，而 JRE 包含 JVM。
bin : 最主要的是编译器(javac.exe)
include : java 和 JVM 交互用的头文件
lib：类库
jre\:java 运行环境
（注意：这里的 bin、lib 文件夹和 jre 里的 bin、lib 是不同的）总的来说 JDK
是用于 java 程序的开发,而 jre 则是只能运行 class 而没有编译的功能。
eclipse、idea 等其他 IDE 有自己的编译器而不是用 JDK bin 目录中自带的，
所以在安装时你会发现他们只要求你选 jre 路径就 ok 了。
JDK,JRE,JVM 三者关系概括如下：
jdk 是 JAVA 程序开发时用的开发工具包，其内部也有 JRE 运行环境 JRE。
JRE 是 JAVA 程序运行时需要的运行环境，就是说如果你光是运行 JAVA 程
序而不是去搞开发的话，只安装 JRE 就能运行已经存在的 JAVA 程序了。JDk、
JRE 内部都包含 JAVA 虚拟机 JVM，JAVA 虚拟机内部包含许多应用程序的
类的解释器和类加载器等等。
700.Java 三种注释类型
共有单行注释、多行注释、文档注释 3 种注释类型。使用如下：
单行注释，采用“//”方式.只能注释一行代码。如：//类成员变量
多行注释，采用“/*...*/”方式，可注释多行代码，其中不允许出现嵌套。
如：
49
50
/*System.out.println(&quot;a&quot;);
System.out.println(&quot;b&quot;);
System.out.println(&quot;c&quot;);*/
文档注释，采用“/**...\*/”方式。如：
/***   子类 Dog
*   @author Administrator
*\*/
public class Dog extends Animal&#123;&#125;
511.  8 种基本数据类型及其字节数
数据类型 关键字 字节数
数值型
整数型
byte 1
short 2
int 4
long 8
浮点型
float 4
double 8
布尔型 boolean 1（位）
字符型 char 2
2.  i++和++i 的异同之处
共同点：
1、i++和++i 都是变量自增 1，都等价于 i=i+1
2、如果 i++,++i 是一条单独的语句，两者没有任何区别
3、i++和++i 的使用仅仅针对变量。 5++和++5 会报错，因为 5
不是变量。
不同点：
如果 i++,++i 不是一条单独的语句，他们就有区别
i++ ：先运算后增 1。如：int x=5;
int y=x++;
System.out.println(&quot;x=&quot;+x+&quot;, y=&quot;+y);
52
//以上代码运行后输出结果为：x=6, y=5
++i ： 先增 1 后运算。如：
int x=5;
int y=++x;
System.out.println(&quot;x=&quot;+x+&quot;, y=&quot;+y);
//以上代码运行后输出结果为：x=6, y=61.  &amp;和&amp;&amp;的区别和联系，|和||的区别和联系
&amp;和&amp;&amp;的联系(共同点)：
&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。
操作数 1&amp;操作数 2，操作数 1&amp;&amp;操作数 2，
表达式 1&amp;表达式 2，表达式 1&amp;&amp;表达式 2，
情况 1：当上述的操作数是 boolean 类型变量时，&amp;和&amp;&amp;都可以用作逻辑
与运算符。
情况 2：当上述的表达式结果是 boolean 类型变量时，&amp;和&amp;&amp;都可以用作
逻辑与运算符。
表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为 true 时，整
个运算结果才为 true，否则，只要有一方为 false，结果都为 false。
&amp;和&amp;&amp;的区别(不同点)：
(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，
也可叫逻辑与运算符。
对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。
对于&amp;&amp;：当&amp;&amp;左边的操作数为 false 或左边表达式结果为 false 时，
&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为 false。
综上所述，如果逻辑与运算的第一个操作数是 false 或第一个表达式的
结果为 false 时，对于第二个操作数或表达式是否进行运算，对最终的结果
没有影响，结果肯定是 false。推介平时多使用&amp;&amp;，因为它效率更高些。
&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是
boolean 类型时，&amp;用于按位与运算符的操作。
|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似
2.  用最有效率的方法算出 2 乘以 8 等于多少
使用位运算来实现效率最高。位运算符是对操作数以二进制比特位为单
位进行操作和运算，操作数和结果都是整型数。对于位运算符“&lt;&lt;”, 是将
一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要
将其左移 3 位即可，位运算 cpu 直接支持的，效率最高。所以，2 乘以 8
等于几的最效率的方法是 2 &lt;&lt; 3
3.  基本数据类型的类型转换规则
基本类型转换分为自动转换和强制转换。
自动转换规则：容量小的数据类型可以自动转换成容量大的数据类型，也可
以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的
范围。
53
54
强制转换规则：高级变为低级需要强制转换。
如何转换：
（1） 赋值运算符“=”右边的转换，先自动转换成表达式中级别最高
的数据类型，再进行运算。
（2） 赋值运算符“=”两侧的转换，若左边级别&gt;右边级别，会自动
转换；若左边级别 == 右边级别，不用转换；若左边级别 &lt; 右边级别，需
强制转换。
（3） 可以将整型常量直接赋值给 byte, short, char 等类型变量，而不
需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。
4.  if 多分支语句和 switch 多分支语句的异同之处
相同之处：
都是分支语句，多超过一种的情况进行判断处理。
不同之处：
switch 更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件
类型单一，只有一个入口，在分支执行完后（如果没有 break 跳出），不加
判断地执行下去;而if—elseif---else多分枝主要适用于分支较少的分支结构，
判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。
switch 为等值判断（不允许比如&gt;= &lt;=），而 if 为等值和区间都可以，if 的
使用范围大。
5.  while 和 do-while 循环的区别
while 先判断后执行，第一次判断为 false,循环体一次都不执行
do while 先执行 后判断，最少执行 1 次。
如果 while 循环第一次判断为 true, 则两种循环没有区别。
6.  break 和 continue 的作用
break: 结束当前循环并退出当前循环体。
break 还可以退出 switch 语句
continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环
条件的判断（for 循环还会 i++）。continue 只是结束本次循环。
7.  请使用递归算法计算 n！
package com.bjsxt;
public class Test &#123;
55
56
public int factorial(int n) &#123;
if (n == 1 || n == 0)&#123;
return n;
&#125;else&#123;
return n \* factorial(n - 1);
&#125;
&#125;
public static void main(String\[] args) &#123;
Test test = new Test();
System.out.println(test.factorial(6));
&#125;
&#125;
8.  递归的定义和优缺点
递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，
递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易
于理解。
递归算法解决问题的特点：
(1) 递归就是在过程或函数里调用自身。
(2) 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。
(3) 递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递
归算法设计程序。
(4) 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存
储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。
9.  数组的特征
数组是（相同类型数据）的（有序）（集合）
数组会在内存中开辟一块连续的空间，每个空间相当于之前的一个变量，称
57
为数组的元素 element
元素的表示 数组名\[下标或者索引] scores\[7] scores\[0] scores\[9]
索引从 0 开始
每个数组元素有默认值 double 0.0 boolean false int 0
数组元素有序的，不是大小顺序，是索引 的顺序
数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组
而言，数组的类型是固定的，只能是一个
length:数组的长度
数组的长度是固定的，一经定义，不能再发生变化（数组的扩容）
13. 可变参数的作用和特点
总结 1：可变参数
14. 可变参数的形式 ...
15. 可变参数只能是方法的形参
16. 可变参数对应的实参可以 0,1,2.....个，也可以是一个数组
17. 在可变参数的方法中，将可变参数当做数组来处理
18. 可变参数最多有一个，只能是最后一个
60
19. 可变参数好处：方便 简单 减少重载方法的数量
20. 如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方
法
总结 2：数组做形参和可变参数做形参联系和区别
联系：
21. 实参都可以是数组；
22. 方法体中，可变参数当做数组来处理
区别：
23. 个数不同 可变参数只能有一个数组参数可以多个
24. 位置不同 可变参数只能是最后一个 数组参数位置任意
25. 实参不同 可变参数实参可以 0,1,2.....个，也可以是一个数组，数组
的实参只能是数组
26. 类和对象的关系
类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对
象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特
定类型的对象中的方法和变量的软件模板。
类和对象好比图纸和实物的关系，模具和铸件的关系。
比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说
话等方法。小明就是一个具体的人，也就是实例，他的属性是具体的身高 200cm，
体重 180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。
27. 面向过程和面向对象的区别
两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针
对面向过程的不足推出了面向对象开发思想。
比喻
蒋介石和毛泽东分别是面向过程和面向对象的杰出代表，这样充分说明，在
解决复制问题时，面向对象有更大的优越性。
面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分
离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用
软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度
比较低。
区别
编程思路不同： 面向过程以实现功能的函数开发为主，而面向对象要首先
抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。
封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的
是数据和功能。
61
62
面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向
对象优势是明显。
方法重载和方法重写（覆盖）的区别
英文 位置不同 作用不同
重载 overload 同一个类中 在一个类里面为一种行为提供多种实
现方式并提高可读性
重写 override 子类和父类间 父类方法无法满足子类的要求，子类通
过方法重写满足要求
修饰符 返回值 方法名 参数 抛出异常
重载 无关 无关 相同 不同 无关
重写 大于等于 小于等于 相同 相同 小于等于
28. this 和 super 关键字的作用
this 是对象内部指代自身的引用,同时也是解决成员变量和局部变量同
名问题；this 可以调用成员变量，不能调用局部变量；this 也可以调用成员
方法，但是在普通方法中可以省略 this，在构造方法中不允许省略，必须是
构造方法的第一条语句。，而且在静态方法当中不允许出现 this 关键字。
super 代表对当前对象的直接父类对象的引用，super 可以调用直接父
类的成员变量（注意权限修饰符的影响，比如不能访问 private 成员）
super 可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访
问 private 成员）；super 可以调用直接父类的构造方法，只限构造方法中使
用，且必须是第一条语句。
29. static 关键字的作用
static 可以修饰变量、方法、代码块和内部类
static 属性属于这个类所有，即由该类创建的所有对象共享同一个 static 属
性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也
可以在没有创建任何对象之前通过类名.属性名的方式来访问。
.static 变量和非 static 变量的区别(都是成员变量，不是局部变量)
1.在内存中份数不同
不管有多少个对象，static 变量只有 1 份。对于每个对象，实例变量都会有
单独的一份
static 变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，
也称为实例变量
2.在内存中存放的位置不同
静态变量存在方法区中，实例变量存在堆内存中 \*
3.访问的方式不同
实例变量：对象名.变量名 stu1.name=&quot;小明明&quot;;
静态变量：对象名.变量名 stu1.schoolName=&quot;西二旗小学&quot;; 不推荐如此
使用
类名.变量名 Student.schoolName=&quot;东三旗小学&quot;; 推荐使用
4.在内存中分配空间的时间不同
实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候
63
Student.schoolName=&quot;东三旗小学&quot;;或者 Student stu1 = new
Student(&quot;小明&quot;,&quot;男&quot;,20,98);
static 方法也可以通过对象名.方法名和类名.方法名两种方式来访问
static 代码块。当类被第一次使用时（可能是调用 static 属性和方法，或者
创建其对象）执行静态代码块，且只被执行一次，主要作用是实现 static 属
性的初始化。
static 内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问
外部类的非静态成员（变量或者方法），.可以访问外部类的静态成员
30. final 和 abstract 关键字的作用
final 和 abstract 是功能相反的两个关键字，可以对比记忆
abstract 可以用来修饰类和方法，不能用来修饰属性和构造方法；使用
abstract 修饰的类是抽象类，需要被继承，使用 abstract 修饰的方法是抽
象方法，需要子类被重写。
final 可以用来修饰类、方法和属性，不能修饰构造方法。使用 final 修
饰的类不能被继承，使用 final 修饰的方法不能被重写，使用 final 修饰的变
量的值不能被修改，所以就成了常量。
特别注意：final 修饰基本类型变量，其值不能改变，由原来的变量变为
常量；但是 final 修饰引用类型变量，栈内存中的引用不能改变，但是所指
向的堆内存中的对象的属性值仍旧可以改变。例如
package com.bjsxt;
class Test &#123;
public static void main(String\[] args) &#123;
64
65
final Dog dog = new Dog(&quot;欧欧&quot;);
dog.name = &quot;美美&quot;;//正确
dog = new Dog(&quot;亚亚&quot;);//错误
&#125;
&#125;
32. 写出 java.lang.Object 类的六个常用方法
(1) public boolean equals(java.lang.Object)
比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等；
(2)public native int hashCode() 获取哈希码
(3)public java.lang.String toString() 把数据转变成字符串
(4)public final native java.lang.Class getClass() 获取类结构信息
(5)protected void finalize() throws java.lang.Throwable
垃圾回收前执行的方法
(6)protected native Object clone() throws
java.lang.CloneNotSupportedException 克隆
(7)public final void wait() throws java.lang.InterruptedException
多线程中等待功能
(8)public final native void notify() 多线程中唤醒功能
(9)public final native void notifyAll() 多线程中唤醒所有等待线程的功能
33. private/默认/protected/public 权限修饰符的区别
类的访问权限只有两种
public 公共的 可被同一项目中所有的类访问。(必须与文件名同名)
default 默认的 可被同一个包中的类访问。
成员（成员变量或成员方法）访问权限共有四种：
public 公共的 可以被项目中所有的类访问。(项目可见性)
protected 受保护的 可以被这个类本身访问；同一个包中的所有其他
的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见
性）
default 默认的被这个类本身访问；被同一个包中的类访问。（包可见
性）
private 私有的只能被这个类本身访问。（类可见性）
34. 继承条件下构造方法的执行过程
继承条件下构造方法的调用规则如下：
情况 1：如果子类的构造方法中没有通过 super 显式调用父类的有参构造方
法，也没有通过 this 显式调用自身的其他构造方法，则系统会默认先调用父
类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样
的。
情况 2：如果子类的构造方法中通过 super 显式调用父类的有参构造方法，
那将执行父类相应构造方法，而不执行父类无参构造方法。
情况 3：如果子类的构造方法中通过 this 显式调用自身的其他构造方法，在
相应构造方法中应用以上两条规则。
特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则
会多次向更高一级父类应用，一直到执行顶级父类 Object 类的无参构造方
法为止。
67
35. ==和 equals 的区别和联系
“==”是关系运算符，equals()是方法，同时他们的结果都返回布尔值；
“==”使用情况如下：
a) 基本类型，比较的是值
b) 引用类型，比较的是地址
c) 不能比较没有父子关系的两个对象
equals()方法使用如下：
a) 系统类一般已经覆盖了 equals()，比较的是内容。
b) 用户自定义类如果没有覆盖 equals()，将调用父类的 equals （比
如是 Object），而 Object 的 equals 的比较是地址（return (this == obj);）
c) 用户自定义类需要覆盖父类的 equals()
注意：Object 的==和 equals 比较的都是地址，作用相同
36. 谈谈 Java 的多态
实现多态的三个条件（前提条件，向上转型、向下转型）
1、继承的存在；（继承是多态的基础，没有继承就没有多态）
2、子类重写父类的方法。（多态下会调用子类重写后的方法）
3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）
向上转型 Student person = new Student()
将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。
此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是
父类的方法此时通过父类引用变量无法调用子类特有的方法。
68
向下转型 Student stu = (Student)person;
将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必
须进行强制类型转换。向下转型必须转换为父类引用指向的真实子类类
型，，否则将出现 ClassCastException，不是任意的强制转换
向下转型时可以结合使用 instanceof 运算符进行强制类型转换，比如出
现转换异常---ClassCastException
37. 简述 Java 的垃圾回收机制
传统的 C/C++语言，需要程序员负责回收已经分配内存。
显式回收垃圾回收的缺点：
1）程序忘记及时回收，从而导致内存泄露，降低系统性能。
2）程序错误回收程序核心类库的内存，导致系统崩溃。
Java 语言不需要程序员直接控制内存回收，是由 JRE 在后台自动回收不再使
用的内存，称为垃圾回收机制，简称 GC；
1）可以提高编程效率。
2）保护程序的完整性。
3）其开销影响性能。Java 虚拟机必须跟踪程序中有用的对象，确定哪
些是无用的。
垃圾回收机制的特点
1）垃圾回收机制回收 JVM 堆内存里的对象空间,不负责回收栈内存数
据。
2）对其他物理连接，比如数据库连接、输入流输出流、Socket 连接无
69
70
能为力。
3）垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执
行。
4）可以将对象的引用变量设置为 null，暗示垃圾回收机制可以回收该
对象。
现在的 JVM 有多种垃圾回收实现算法，表现各异。
垃圾回收机制回收任何对象之前，总会先调用它的 finalize 方法（如果覆盖
该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。
程序员可以通过 System.gc()或者 Runtime.getRuntime().gc()来通知系统
进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。
永远不要主动调用某个对象的 finalize 方法，应该交给垃圾回收机制调用。
38. 基本数据类型和包装类1.  八个基本数据类型的包装类
基本数据类型 包装类
byte Byte
boolean Boolean
short Short
char Character
int Integer
long Long
float Float
71
double Double
2.  为什么为基本类型引入包装类
2.1 基本数据类型有方便之处，简单、高效。
2.2 但是 Java 中的基本数据类型却是不面向对象的（没有属性、方法），
这在实际使用时存在很多的不便（比如集合的元素只能是 Object）。
为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的
类进行包装，这样八个和基本数据类型对应的类统称为包装类(Wrapper
Class)。
3.  包装类和基本数据类型之间的转换
3.1 包装类------ wrapperInstance.xxxValue() ------&gt;基本数据类型
3.2 包装类-------new WrapperClass(primitive)
new WrapperClass(string)------基本数据类型
4.  自动装箱和自动拆箱
JDK1.5 提供了自动装箱（autoboxing）和自动拆箱（autounboxing）
功能, 从而实现了包装类和基本数据类型之间的自动转换
5.  包装类还可以实现基本类型变量和字符串之间的转换
基本类型变量------------String.valueof()------------&gt;字符串
基本类型变量
&lt;------------WrapperClass.parseXxx(string)------------字符串1.  Integer 与 int 的区别
int 是 java 提供的 8 种原始数据类型之一，Java 为每个原始类型提供了封装
类，Integer 是 java 为 int 提供的封装类。
int 的默认值为 0，而 Integer 的默认值为 null，即 Integer 可以区分出未赋
值和值为 0 的区别，int 则无法表达出未赋值的情况，例如，要想表达出没
有参加考试和考试成绩为 0 的区别，则只能使用 Integer。在 JSP 开发中，
Integer 的默认为 null，所以用 el 表达式在文本框中显示时，值为空白字符
串，而 int 默认的默认值为 0，所以用 el 表达式在文本框中显示时，结果为
0，所以，int 不适合作为 web 层的表单数据的类型。
在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可
以根据其值是否为 null 而判断一个对象是否是临时的，如果将 OID 定义为
了 int 类型，还需要在 hbm 映射文件中设置其 unsaved-value 属性为 0。
另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转
换成整数，Integer 中还定义了表示整数的最大值和最小值的常量。
2.  java.sql.Date 和 java.util.Date 的联系和区别
1） java.sql.Date 是 java.util.Date 的子类，是一个包装了毫秒值的瘦包装
器，允许 JDBC 将毫秒值标识为 SQL DATE 值。毫秒值表示自 1970 年 1
月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义
一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫
秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，
java.sql.Date 就是与数据库 Date 相对应的一个类型，而 java.util.Date 是
纯 java 的 Date。
2）JAVA 里提供的日期和时间类，java.sql.Date 和 java.sql.Time,只会从数
72
73
据库里读取某部分值，这有时会导致丢失数据。例如一个包含 2002/05/22
5:00:57 PM 的字段，读取日期时得到的是 2002/05/22,而读取时间时得到
的是 5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如
MySQL,精度为毫秒，然而另一些数据库，包括 Oracle,存储 SQL DATE 类
型数据时，毫秒部分的数据是不保存的。以下操作中容易出现不易被发现的
BUG：获得一个 JAVA 里的日期对象。 从数据库里读取日期 试图比较两个
日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用
Equals 方法可能返回 false。.sql.Timestamp 类比 java.util.Date 类精确度
要高。这个类包了一个 getTime()方法，但是它不会返回额外精度部分的数
据，因此必须使用...
总之，java.util.Date 就是 Java 的日期对象，而 java.sql.Date 是针对 SQL
语句使用的，只包含日期而没有时间部分。
3.  使用递归算法输出某个目录下所有文件和子目录列表
package com.bjsxt;
import java.io.File;
public class \$ &#123;
public static void main(String\[] args) &#123;
String path = &quot;D:/301SXT&quot;;
test(path);
&#125;
private static void test(String path) &#123;
File f = new File(path);
File\[] fs = f.listFiles();
if (fs == null) &#123;
return;
&#125;
for (File file : fs) &#123;
if (file.isFile()) &#123;
System.out.println(file.getPath());
&#125; else &#123;
74
test(file.getPath());
&#125;
&#125;
&#125;
4.  关于 Java 编译，下面哪一个正确（）（选择一项）
A Java程序经编译后产生machine code
B. Java 程序经编译后会生产 byte code
C. Java程序经编译后会产生DLL
D. 以上都不正确
答案：B
分析： Java 是解释型语言，编译出来的是字节码； 因此 A 不正确，C 是
C/C++语言编译动态链接库的文件为.DLL； 正确答案为 B
5.  下列说法正确的有（）（选择一项）
A class中的construtor不可省略
B. construtor 与 class 同名，但方法不能与 class 同名
C. construtor在一个对象被new时执行
D. 一个 class 只能定义一个 construtor
答案：C
分析：A：如果 class 中的 construtor 省略不写，系统会默认提供一个无
参构造
B：方法名可以与类名同名，只是不符合命名规范
75
D：一个 class 中可以定义 N 多个 construtor，这些 construtor
构成构造方法的重载
6.  Java 中接口的修饰符可以为（）（选择一项）
A private
B. protected
C. final
D. abstract
答案：D
分析：接口中的访问权限修饰符只可以是 public 或 default
接口中的所有的方法必须要实现类实现，所以不能使用 final
接口中所有的方法默认都是 abstract 的，所以接口可以使用
abstract 修饰，但通常 abstract 可以省略不写
7.  给定以下代码，程序将输出 （）（选择一项）
class A &#123;
public A()&#123;
System.out.println(&quot;A&quot;);
&#125;
&#125;
class B extends A&#123;
public B()&#123;
System.out.println(&quot;B&quot;);
&#125;
public static void main(String\[] args) &#123;
B b=new B();
&#125;
&#125;
A 不能通过编译
B. 通过编译，输出 AB
C. 通过编译，输出B
D. 通过编译，输出 A
答案：B
分析：在继承关系下，创建子类对象，先执行父类的构造方法，再执行子
类的构造方法。
8.  下列关于关键字的使用说法错误的是（）（选择一项）
A. abstract不能与final并列修饰同一个类
B. abstract 类中可以有 private 的成员
C. abstract方法必须在abstract类中
D. static 方法能处理非 static 的属性
答案：D
分析：因为 static 得方法在装载 class 得时候首先完成，比 构造方法早，
此时非 static 得属性和方法还没有完成初始化所以不能调用。
9.  下列哪些语句关于内存回收的说法是正确的（）（选择一项）
A. 程序员必须创建一个线程来释放内存
B. 内存回收程序负责释放无用内存
C. 内存回收程序允许程序员直接释放内存
D. 内存回收程序可以在指定的时间释放内存对象
答案：B
分析： A. 程序员不需要创建线程来释放内存.
76
C. 也不允许程序员直接释放内存.
D. 不一定在什么时刻执行垃圾回收.
10. 选出合理的标识符（）（选择两项）
A. \_sysl\_111
B. 2 mail
C. `$change
D. class
答案：AC
分析： 标识符的命令规范，可以包含字母、数字、下划线、$`，不能以数
字开头，不能是 Java 关键字
11. 下列说法正确的是（）（选择多项）
A. java.lang.Cloneable是类
B. java.langRunnable 是接口
C. Double对象在java.lang包中
D. Double a=1.0 是正确的 java 语句
答案：BCD
分析：java.lang.Cloneable 是接口
12. 定义一个类名为”MyClass.java”的类，并且该类可被一个
工程中的所有类访问，那么该类的正确声明为（）（选择两项）
A. private class MyClass extends Object
77
78
B. class MyClass extends Object
C. public class MyClass
D. public class MyClass extends Object
答案：CD
分析： A 类的访问权限只能是 public 或 default
B 使用默认访问权限的类，只能在本包中访问
13. 面向对象的特征有哪些方面？请用生活中的例子来描述。
答: 面向对象的三大特征：封装、继承、多态。
举例：（比如设计一个游戏）我现在创建了一个对象，名叫战士。
战士的属性是—性别，年龄，职业，等级，战斗力，血量。
它的方法—战斗，逃跑，吃饭，睡觉，死。
后来，我又建了一个对象，叫人。
属性:性别，年龄，职业，等级，血量
方法:逃跑，吃饭，睡觉，死。
我让人，成为战士的父类，战士可以直接继承人的属性和方法。
战士修改成—
属性:战斗力。
方法:战斗。
看上去战士的资料变少了，实际上没有，我们仍然可以调用方法—战士.死。
而且我们还可以重载战士.死的方法，简称重载死法。
我还建了一个对象—法师，父类也是人。
属性:法力值
方法:施法，泡妞。
你看，用了继承，创建对象变得更方便了。
再后来，我又建立了一个对象，叫怪物。
属性:等级，战力，血量。
方法:战斗，死。
建了个对象，叫白兔怪，父类怪物，可继承怪物所有的属性和方法。
属性:毛色。
方法:卖萌，吃胡萝卜。
14. 说明内存泄漏和内存溢出的区别和联系，结合项目经验描述
Java 程序中如何检测？如何解决？
答：
内存溢出 out of memory，是指程序在申请内存时，没有足够的内存
空间供其使用，出现 out of memory；比如申请了一个 integer,但给它存了
long 才能存下的数，那就是内存溢出。
内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的
内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论
多少内存,迟早会被占光。
memory leak 会最终会导致 out of memory！
79
80
15. 什么是 Java 的序列化，如何实现 Java 的序列化？列举在哪
些程序中见过 Java 序列化？
答：Java 中的序列化机制能够将一个实例对象（只序列化对象的属性值，而
不会去序列化什么所谓的方法。）的状态信息写入到一个字节流中使其可以
通过 socket 进行传输、或者持久化到存储数据库或文件系统中；然后在需
要的时候通过字节流中的信息来重构一个相同的对象。一般而言，要使得一
个类可以序列化，只需简单实现 java.io.Serializable 接口即可。
对象的序列化主要有两种用途：
1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
2） 在网络上传送对象的字节序列。
在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入
住物理硬盘，以便长期保存。比如最常见的是 Web 服务器中的 Session 对
象，当有 10 万用户并发访问，就有可能出现 10 万个 Session 对象，内存
可能吃不消，于是 Web 容器就会把一些 seesion 先序列化到硬盘中，等要
用了，再把保存在硬盘中的对象还原到内存中。
当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是
何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这
个 Java 对象转换为字节序列，才能在网络上传送；接收方则需要把字节序
列再恢复为 Java 对象。
81
16. 不通过构造函数也能创建对象吗？
答：Java 创建对象的几种方式（重要）：
1、 用 new 语句创建对象，这是最常见的创建对象的方法。
2、运用反射手段,调用 java.lang.Class 或者 java.lang.reflect.Constructor
类的 newInstance()实例方法。
3、 调用对象的 clone()方法。
4、运用反序列化手段，调用 java.io.ObjectInputStream 对象的
readObject()方法。
(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，
所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函
数。
17. 匿名内部类可不可以继承或实现接口。为什么？
答：匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作
为一个接口,由另一个内部类实现.
1、由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，
所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把
创建对象的任务交给了父类去完成。
2、在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的
方法达到神奇效果，如上例所示。这是多态性的体现。
3、因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对
82
一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。
18. 在 Java 中，为什么基本类型不能做为 HashMap 的键值，而
只能是引用类型，把引用类型做为 HashMap 的健值，需要注意
哪些地方。
答:
(1) 在 Java 中是使用泛型来约束 HashMap 中的 key 和 value 的类型的，
即 HashMap\&lt;K, V&gt;；而泛型在 Java 的规定中必须是对象 Object 类型的，
也就是说 HashMap\&lt;K, V&gt;可以理解为 HashMap\&lt;Object, Object&gt;，很显
然基本数据类型不是 Object 类型的，因此不能作为键值，只能是引用类型。
虽然我们在 HashMap 中可以这样添加数据：“map.put(1, “Java”)；”，
但实际上是将其中的 key 值 1 进行了自动装箱操作，变为了 Integer 类型。
(2) 引用数据类型分为两类：系统提供的引用数据类型（如包装类、String
等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了
HashCode()和 equals()两个方法，所以能够保证 Map 中 key 值的唯一性；
但是自定义的引用数据类型需要自己重写 HashCode()和 equals()这两个方
法，以保证 Map 中 key 值的唯一性。
19. 简述 Java 中如何实现多态
答:
实现多态有三个前提条件：
1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。
2、子类重写父类的方法。（多态下会调用子类重写后的方法）。
83
3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）。
最后使用父类的引用变量调用子类重写的方法即可实现多态。
20. 以下对继承的描述锚误的是 ()
A.
Java 中的继承允许一个子类继承多个父类
B. 父类更具有通用性，子类更具体
C.
Java 中的继承存在着传递性
D. 当实例化子类时会递归调用父类中的构造方法
答案：A
分析：
Java 是单继承的，一个类只能继承一个父类。
21. Java 中 Math.random（）/Math.random（）值为？
答:
如果除数与被除数均不为 0.0 的话，则取值范围为\[0, +∞]。+∞在 Java 中
显示的结果为 Infinity。
如果除数与被除数均为 0.0 的话，则运行结果为 NaN（Not a Number 的
简写），计算错误。
22. Java 中，如果 Manager 是 Employee 的子类，那么
Pair\&lt;Manager&gt;是 Pair\&lt;Employee&gt;的子类吗？
答:
不是，两者没有任何关联；
Pair 是单独的类，只不过用不同类型的参数（泛型）进行了相应的实例
化而已；所以，Pair\&lt;Manager&gt;和 Pair\&lt;Employee&gt;不是子类的关系。
23. 接口和抽象类的区别
答:
相同点
➢ 抽象类和接口均包含抽象方法，类必须实现所有的抽象方法，否则是抽
象类
➢ 抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继
承和实现
两者的区别主要体现在两方面：语法方面和设计理念方面
语法方面的区别是比较低层次的，非本质的，主要表现在：
➢ 接口中只能定义全局静态常量，不能定义变量。抽象类中可以定义常量
和变量。
➢ 接口中所有的方法都是全局抽象方法。抽象类中可以有 0 个、1 个或多
个，甚至全部都是抽象方法。
➢ 抽象类中可以有构造方法，但不能用来实例化，而在子类实例化是执行，
完成属于抽象类的初始化操作。接口中不能定义构造方法。
➢ 一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接
口。一个类使用 extends 来继承抽象类，使用 implements 来实现接
口。
二者的主要区别还是在设计理念上，其决定了某些情况下到底使用抽象类还
是接口。
84
85
➢ 抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子
类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，
而子类是“最终产品”。父类和子类之间必须存在“is-a”的关系，即父
类和子类在概念本质上应该是相同的。
➢ 接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定
义的约定或者能力而已。接口定义了“做什么”，而实现类负责完成“怎
么做”，体现了功能（规范）和实现分离的原则。接口和实现之间可以
认为是一种“has-a 的关系”
24. 同步代码块和同步方法有什么区别
答:
相同点：
同步方法就是在方法前加关键字 synchronized，然后被同步的方法一次只
能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括
号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同
步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。
一般情况下，如果此“目标”为 this，同步方法和代码块没有太大的区别。
区别：
同步方法直接在方法上加 synchronized 实现加锁，同步代码块则在方法内
部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一
般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围
越小越好，这样性能更好。
86
25. 静态内部类和内部类有什么区别
答:
静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类
的引用。
静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成
员(方法，属性)。
非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外
部类的非静态成员，只能访问外部类的静态成员。
实例化方式不同：1.  静态内部类：不依赖于外部类的实例，直接实例化内部类对象
2.  非静态内部类：通过外部类的对象实例生成内部类对象1.  反射的概念与作用
答:
反射的概念：
反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行
为的一种能力。
⚫ Java 反射可以于运行时加载,探知和使用编译期间完全未知的类.
⚫ 程序在运行状态中, 可以动态加载一个只有名称的类, 对于任意一个已
经加载的类,都能够知道这个类的所有属性和方法; 对于任意一个对象,
都能调用他的任意一个方法和属性;
⚫ 加载完类之后, 在堆内存中会产生一个 Class 类型的对象(一个类只有一
87
个 Class 对象), 这个对象包含了完整的类的结构信息,而且这个 Class 对
象就像一面镜子,透过这个镜子看到类的结构,所以被称之为:反射.
⚫ java 反射使得我们可以在程序运行时动态加载一个类，动态获取类的基
本信息和定义的方法,构造函数,域等。
⚫ 除了检阅类信息外，还可以动态创建类的实例，执行类实例的方法，获
取类实例的域值。反射使 java 这种静态语言有了动态的特性。
反射的作用：
通过反射可以使程序代码访问装载到 JVM 中的类的内部信息1.  获取已装载类的属性信息
2.  获取已装载类的方法
3.  获取已装载类的构造方法信息
反射的优点：
增加程序的灵活性。
如 struts 中。请求的派发控制。
当请求来到时。struts 通过查询配置文件。找到该请求对应的 action。已经
方法。
然后通过反射实例化 action。并调用响应 method。
如果不适用反射，那么你就只能写死到代码里了。
所以说，一个灵活，一个不灵活。
很少情况下是非用反射不可的。大多数情况下反射是为了提高程序的灵活性。
因此一般框架中使用较多。因为框架要适用更多的情况。对灵活性要求较高。
1.  提供 Java 存取数据库能力的包是（）
A. java.sql
B. java.awt
C. java.lang
D. java.swing
答案：A
分析：
java.awt 和 javax.swing 两个包是图形用户界面编程所需要的包；
java.lang 包则提供了 Java 编程中用到的基础类。
2.  下列运算符合法的是（）（多选）
A. &amp;&amp;
B. &lt;&gt;
C. if
D. =
答案：AD
分析：
&amp;&amp;是逻辑运算符中的短路与；
&lt;&gt;表示不等于，但是 Java 中不能这么使用，应该是!=；
if 不是运算符；
\=是赋值运算符。
88
89
3.  执行如下程序代码，c 的值打印出来是（）
public class Test1 &#123;
public static void main(String\[] args) &#123;
int a = 0;
int c = 0;
do&#123;
\--c;
a = a - 1;
&#125; while (a &gt; 0);
System.out.println(c);
&#125;
&#125;
A. 0
B. 1
C. -1
D. 死循环
答案：C
分析：
do-while 循环的特点是先执行后判断，所以代码先执行--c 操作，得到 c
为-1，之后执行 a=a-1 的操作，得到 a 为-1，然后判断 a 是否大于 0，判
断条件不成立，退出循环，输出 c 为-1。
4.  下列哪一种叙述是正确的（）
A. abstract 修饰符可修饰字段，方法和类
B. 抽象方法的 body 部分必须用一对大括号&#123;&#125;包住
C. 声明抽象方法，大括号可有可无
D. 声明抽象方法不可写出大括号
90
答案：D
分析：
abstract 只能修饰方法和类，不能修饰字段；
抽象方法不能有方法体，即没有&#123;&#125;；
同 B。
5.  下列语句正确的是（）
A. 形式参数可被视为 local Variable
B. 形式参数可被所有的字段修饰符修饰
C. 形式参数为方法被调用时，真正被传递的参数
D. 形式参数不可以是对象
答案：A
分析：
local Variable 为局部变量，形参和局部变量一样都只有在方法内才会发生
作用，也只能在方法中使用，不会在方法外可见；
对于形式参数只能用 final 修饰符，其它任何修饰符都会引起编译器错误；
真正被传递的参数是实参；
形式参数可是基本数据类型也可以是引用类型（对象）。
6.  下列哪种说法是正确的（）
A. 实例方法可直接调用超类的实例方法
B. 实例方法可直接调用超类的类方法
C. 实例方法可直接调用其他类的实例方法
D. 实例方法可直接调用本类的类方法
答案：D
分析：
实例方法不可直接调用超类的私有实例方法；
实例方法不可直接调用超类的私有的类方法；
要看访问权限。
7.  Java 程序的种类有（）(多选)
A. 类 (Class)
B. Applet
C. Application
D. Servlet
答案：BCD
分析：
是 Java 中的类，不是程序；
内嵌于 Web 文件中，由浏览器来观看的 Applet；
可独立运行的 Application；
服务器端的 Servlet。
8.  下列说法正确的有（）(多选)
A. 环境变量可在编译 source code 时指定
B. 在編译程序时，所指定的环境变置不包括 class path
C. javac —次可同时编译数个 Java 源文件
91
D. javac.exe 能指定编译结果要置于哪个目录（directory)
答案：BCD
分析：
环境变量一般都是先配置好再编译源文件。
9.  下列标识符不合法的有（）(多选)
A. new
B. \$Usdollars
C. 1234
D. car.taxi
答案：ACD
分析：
new 是 Java 的关键字；
C. 数字不能开头；
D. 不能有“.”。
10. 下列说法错误的有（）(多选)
A. 数组是—种对象
B. 数组属于一种原生类
C. int number\[]=(31,23,33,43,35,63)
D. 数组的大小可以任意改变
答案：BCD
分析：
92
B. Java 中的原生类（即基本数据类型）有 8 种，但不包括数组；
C. 语法错误，应该“&#123;···&#125;”，而不是“(···)”；
D. 数组的长度一旦确定就不能修改。
11. 不能用来修饰 interface 的有（）(多选)
A. private
B. public
C. protected
D. static
答案：ACD
分析：
能够修饰 interface 的只有 public、abstract 以及默认的三种修饰符。
12. 下列正确的有（）(多选)
A. call by value 不会改变实际参数的数值
B. call by reference 能改变实际参数的参考地址
C. call by reference 不能改变实际参数的参考地址
D. call by reference 能改变实际参数的内容
答案：ACD
分析：
Java 中参数的传递有两种，一种是按值传递（call by value：传递的是具
体的值，如基础数据类型），另一种是按引用传递（call by reference：传
递的是对象的引用，即对象的存储地址）。前者不能改变实参的数值，后者
93
虽然不能改变实参的参考地址，但可以通过该地址访问地址中的内容从而
实现内容的改变。
13. 下列说法错误的有（）(多选)
A. 在类方法中可用 this 来调用本类的类办法
B. 在类方法中调用本类的类方法时可以直接调用
C. 在类方法中只能调用本类中的类方法
D. 在类方法中绝对不能调用实例方法
答案：ACD
分析：
类方法是在类加载时被加载到方法区存储的，此时还没有创建对象，所以
不能使用 this 或者 super 关键字；
C. 在类方法中还可以调用其他类的类方法；
D. 在类方法可以通过创建对象来调用实例方法。
14. 下列说法错误的有（）(多选)
A. Java 面向对象语言容许单独的过栈与函数存在
B. Java 面向对象语言容许单独的方法存在
C. Java 语言中的方法属于类中的成员（member）
D. Java 语言中的方法必定隶属于某一类（对象），调用方法与过程或函
数相同
答案：ABC
分析：
94
B. Java 不允许单独的方法，过程或函数存在，需要隶属于某一类中；
C. 静态方法属于类的成员，非静态方法属于对象的成员。
15. 下列说法错误的有（）(多选)
A. 能被 java.exe 成功运行的 java class 文件必须有 main()方法
B. J2SDK 就是 Java API
C. Appletviewer.exe 可利用 jar 选项运行.jar 文件
D. 能被 Appletviewer 成功运行的 java class 文件必须有 main()方法
答案：BCD
分析：
B. J2SDK 是 sun 公司编程工具，API 是指的应用程序编程接口；
C. Appletviewer.exe 就是用来解释执行 java applet 应用程序的，一种执
行 HTML 文件上的 Java 小程序类的 Java 浏览器；
D. 能被 Appletviewer 成功运行的 java class 文件可以没有 main（）方
法。
16. 请问 0.3332 的数据类型是（）
A. float
B. double
C. Float
D. Double
答案：B
分析：
95
小数默认是双精度浮点型即 double 类型的。
17. Java 接口的修饰符可以为（）
A. private
B. protected
C. final
D. abstract
答案：D
分析：
能够修饰 interface 的只有 public、abstract 以及默认的三种修饰符。
18. 不通过构造函数也能创建对象么（）
A. 是
B. 否
答案：A
分析：
Java 创建对象的几种方式：
(1) 用 new 语句创建对象，这是最常见的创建对象的方法。
(2) 运用反射手段,调用 java.lang.Class 或者
java.lang.reflect.Constructor 类的 newInstance()实例方法。
(3) 调用对象的 clone()方法。
(4) 运用反序列化手段，调用 java.io.ObjectInputStream 对象的
readObject()方法。
96
97
(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影
印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构
造函数。
19. 存在使 i+1\&lt;i 的数么?
答:
存在, int 的最大值, 加 1 后变为负数.
20. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可
继承实体类？
答:
接口可以继承接口，抽象类可以实现接口，抽象类可以继承实体类。
21. int 与 Integer 有什么区别？
答:
int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供
了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer
的默认值为 null，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无
法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为 0
的区别，则只能使用 Integer。在 JSP 开发中，Integer 的默认为 null，所
以用 el 表达式在文本框中显示时，值为空白字符串，而 int 默认的默认值为
0，所以用 el 表达式在文本框中显示时，结果为 0，所以，int 不适合作为
web 层的表单数据的类型。
在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate
就可以根据其值是否为 null 而判断一个对象是否是临时的，如果将 OID 定
98
义为了 int 类型，还需要在 hbm 映射文件中设置其 unsaved-value 属性为
0。另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符
串转换成整数，Integer 中还定义了表示整数的最大值和最小值的常量。
22. 可序列化对象为什么要定义 serialversionUID 值?
答:
SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版
本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧
版本，反序列化时会抛出 InvalidClassException 异常。如果修改较小，比
如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那
就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不
兼容旧数据，这时就应该手动更新版本号，即 SerialVersionUid。
23. 写一个 Java 正则，能过滤出 html 中的 &lt;a href&gt;title&lt;/a&gt;形式中的链接地址和标题.
答:
\&lt;a\b\[^&gt;]+\bhref=&quot;(\[^&quot;]*)&quot;\[^&gt;]*&gt;(\[\s\S]\*?)&lt;/a&gt;
分组 1 和分组 2 即为 href 和 value
24. 十进制数 72 转换成八进制数是多少？
答: 110
99
25. Java 程序中创建新的类对象，使用关键字 new，回收无用的
类对象使用关键字 free 正确么？
答:
Java 程序中创建新的类对象，使用关键字 new 是正确的; 回收无用的类
对象使用关键字 free 是错误的.
26. Class 类的 getDeclaredFields()方法与 getFields()的区
别？
答:
getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的
方法
getFields(): 只能获取所有 public 声明的方法, 包括继承的方法
27. 在 switch 和 if-else 语句之间进行选取，当控制选择的条件
不仅仅依赖于一个 x 时，应该使用 switch 结构；正确么？
答:
不正确。
通常情况下，进行比较判断的处理，switch 和 if-else 可以互相转换来
写；if-else 作用的范围比 switch-case 作用范围要大，但是当 switch-case
和 if-else 都可以用的情况下，通常推荐使用 switch-case。
比如：
switch (ch) &#123;
case &#39;a&#39;:
System.out.println(&quot;A&quot;);
break;
case &#39;b&#39;:
100
System.out.println(&quot;B&quot;);
break;
case &#39;c&#39;:
System.out.println(&quot;C&quot;);
break;
case &#39;d&#39;:
System.out.println(&quot;D&quot;);
break;
case &#39;e&#39;:
System.out.println(&quot;E&quot;);
break;
default:
System.out.println(&quot;other&quot;);
break;
&#125;
换为if-else
if (ch == &#39;a&#39;) &#123;
System.out.println(&quot;A&quot;);
&#125; else if (ch == &#39;b&#39;) &#123;
System.out.println(&#39;B&#39;);
&#125; else if (ch == &#39;c&#39;) &#123;
System.out.println(&quot;C&quot;);
&#125; else if (ch == &#39;d&#39;) &#123;
System.out.println(&quot;D&quot;);
&#125; else if (ch == &#39;e&#39;) &#123;
System.out.println(&quot;E&quot;);
&#125; else &#123;
System.out.println(&quot;Other&quot;);
&#125;
28. 描述&amp;和&amp;&amp;的区别。
&amp;和&amp;&amp;的联系(共同点)：
&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。
操作数 1&amp;操作数 2，操作数 1&amp;&amp;操作数 2，
表达式 1&amp;表达式 2，表达式 1&amp;&amp;表达式 2，
情况 1：当上述的操作数是 boolean 类型变量时，&amp;和&amp;&amp;都可以用作逻辑
与运算符。
情况 2：当上述的表达式结果是 boolean 类型变量时，&amp;和&amp;&amp;都可以用作
逻辑与运算符。
表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为 true 时，整
个运算结果才为 true，否则，只要有一方为 false，结果都为 false。
&amp;和&amp;&amp;的区别(不同点)：
(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算
符，也可叫逻辑与运算符。
对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。
对于&amp;&amp;：当&amp;&amp;左边的操作数为 false 或左边表达式结果为 false 时，&amp;&amp;
右边的操作数或表达式将不参与计算，此时最终结果都为 false。
综上所述，如果逻辑与运算的第一个操作数是 false 或第一个表达式的结果
为 false 时，对于第二个操作数或表达式是否进行运算，对最终的结果没有
影响，结果肯定是 false。推介平时多使用&amp;&amp;，因为它效率更高些。
(2)、&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是
boolean 类型时，&amp;用于按位与运算符的操作。
29. 使用 final 关键字修饰符一个变量时，是引用不能变，还是引
用的对象不能变？
final 修饰基本类型变量，其值不能改变。
但是 final 修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆
内存中的对象的属性值仍旧可以改变。
101
例如
class Test &#123;
public static void main(String\[] args) &#123;
final Dog dog = new Dog(&quot;欧欧&quot;);
dog.name = &quot;美美&quot;;//正确
dog = new Dog(&quot;亚亚&quot;);//错误
&#125;
&#125;
30. 请解释以下常用正则含义：\d,\D,\s,.,\*,?,|,\[0-9]&#123;6&#125;,\d+
\d: 匹配一个数字字符。等价于\[0-9]
\D: 匹配一个非数字字符。等价于\[^0-9]
\s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 \[ \f\n\r\t\v]
. ：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。
\*：匹配前面的子表达式零次或多次。要匹配 \* 字符，请使用 \*。
\+：匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。
\|:将两个匹配条件进行逻辑“或”（Or）运算
\[0-9]&#123;6&#125;:匹配连续 6 个 0-9 之间的数字
\d+：匹配至少一个 0-9 之间的数字
31. 已知表达式 int m\[] = &#123;0,1,2,3,4,5,6&#125;; 下面那个表达式的值
与数组的长度相等（）
A. m.length()
102
B. m.length
C. m.length()+1
D. m.length+1
答案：B
分析：数组的长度是.length
32. 下面那些声明是合法的？（）
A. long l = 4990
B. int i = 4L
C. float f = 1.1
D. double d = 34.4
答案：AD
分析：B int 属于整数型应该是 int=4 C 应该是 float f=1.1f
33. 以下选项中选择正确的 java 表达式（）
A. int k=new String(“aa”)
B. String str = String(“bb”)
C. char c=74;
D. long j=8888;
答案：CD
分析：A 需要强制类型转换 B String str =new String(“bb”)
34. 下列代码的输出结果是
System.out.println(&quot;&quot;+(&quot;12&quot;==&quot;12&quot;&amp;&amp;&quot;12&quot;.equals(&quot;12&quot;)));
103
104
(“12”==”12”&amp;&amp;”12”.equals(“12”))
“12”==”12”&amp;&amp;”12”.equals(“12”)
true
false
35. 以下哪些运算符是含有短路运算机制的？请选择：（）
A. &amp;
B. &amp;&amp;
C. |
D. ||
答案：BD
分析：A C 是逻辑与计算
36. 下面哪个函数是 public void example()&#123;....&#125;的重载函数？（）
A. private void example（int m）&#123;...&#125;
B. public int example（）&#123;...&#125;
C. public void example2（）&#123;...&#125;
D. public int example（int m.float f）&#123;...&#125;
答案：AD
分析：BC 定义的是新函数
37. 给定某 java 程序片段，该程序运行后，j 的输出结果为（）
int i=1；
Int j=i++；
105
If（（j&gt;++j）&amp;&amp;(i++==j)）&#123;j+=i:&#125;
System.out.println(j);
A. 1
B. 2
C. 3
D. 4
答案：B
分析： i++先引用后。++i 先增加后引用
38. 在 java 中，无论测试条件是什么，下列（）循环将至少执行
一次。
A. for
B. do...while
C. while
D. while...do
答案：B
分析： ACD 都不一定进行循环
39. 打印结果：
package com.bjsxt;
public class smaillT&#123;
public static void main(String args\[])&#123;
smaillT t=new smaillT();
int b = t.get();
System.out.println(b);
&#125;
106
public int get()
&#123;
try&#123;
return 1;
&#125;finally&#123;
return 2;
&#125;
&#125;
&#125;
输出结果：2
40. 指出下列程序的运行结果
int i=9;
switch (i) &#123;
default:
System.out.println(&quot;default&quot;);
case 0:
System.out.println(&quot;zero&quot;);
break;
case 1:
System.out.println(&quot;one&quot;);
break;
case 2:
System.out.println(&quot;two&quot;);
break;
&#125;
打印结果：
default
zero
41. 解释继承、重载、覆盖。
继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个
类别 A“继承自”另一个类别 B，就把这个 A 称为“B 的子类别”，而把 B
称为“A 的父类别”也可以称“B 是 A 的超类”。继承可以使得子类别具有
107
父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承
父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的
原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的
属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静
态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。
那么如何使用继承呢？用 extends 关键字来继承父类。
如上面 A 类与 B 类，当写继承语句时， class A 类 extends B 类&#123; &#125; 其中 A
类是子类，B 类是父类。
英文 位置不同 作用不同
重载 overload 同一个类中 在一个类里面为一种行为提供多种实
现方式并提高可读性
重写 override 子类和父类间 父类方法无法满足子类的要求，子类通
过方法重写满足要求
修饰符 返回值 方法名 参数 抛出异常
重载 无关 无关 相同 不同 无关
重写 大于等于 小于等于 相同 相同 小于等于
42. 什么是编译型语言，什么是解释型语言？java 可以归类到那
种？
计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要
把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译
的方式有两种，一个是编译，一个是解释。
用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译
系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比
如 windows 下的 exe 文件。以后就可以直接运行而不需要编译了，因为翻
译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行
效率高。
解释型语言在运行的时候才翻译，比如 VB 语言，在执行的时候，专门
有一个解释器能够将 VB 语言翻译成机器语言，每个语句都是执行时才翻译。
这样解释型语言每执行一次就要翻译一次，效率比较低。
编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件
下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时
都采用它，像 C/C++、Pascal/Object Pascal（Delphi）等都是编译语言，
而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不
同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如
JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。
JAVA 语言是一种编译型-解释型语言，同时具备编译特性和解释特性
（其实，确切的说 java 就是解释型语言，其所谓的编译过程只是将.java 文
件编程成平台无关的字节码.class 文件，并不是向 C 一样编译成可执行的机
器语言，在此请读者注意 Java 中所谓的“编译”和传统的“编译”的区别）。
作为编译型语言，JAVA 程序要被统一编译成字节码文件——文件后缀是
class。此种文件在 java 中又称为类文件。java 类文件不能再计算机上直接
执行，它需要被 java 虚拟机翻译成本地的机器码后才能执行，而 java 虚拟
108
机的翻译过程则是解释性的。java 字节码文件首先被加载到计算机内存中，
然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为 java 语
言的解释执行，是由 java 虚拟机完成的。
43. 简述操作符（&amp;，|）与操作符（&amp;&amp;，||）的区别
&amp;和&amp;&amp;的联系(共同点)：
&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。
操作数 1&amp;操作数 2，操作数 1&amp;&amp;操作数 2，
表达式 1&amp;表达式 2，表达式 1&amp;&amp;表达式 2，
情况 1：当上述的操作数是 boolean 类型变量时，&amp;和&amp;&amp;都可以用作逻辑
与运算符。
情况 2：当上述的表达式结果是 boolean 类型变量时，&amp;和&amp;&amp;都可以用作
逻辑与运算符。
表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为 true 时，整
个运算结果才为 true，否则，只要有一方为 false，结果都为 false。
&amp;和&amp;&amp;的区别(不同点)：
(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，
也可叫逻辑与运算符。
对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。
对于&amp;&amp;：当&amp;&amp;左边的操作数为 false 或左边表达式结果为 false 时，&amp;&amp;
右边的操作数或表达式将不参与计算，此时最终结果都为 false。
综上所述，如果逻辑与运算的第一个操作数是 false 或第一个表达式的结果
109
110
为 false 时，对于第二个操作数或表达式是否进行运算，对最终的结果没有
影响，结果肯定是 false。推介平时多使用&amp;&amp;，因为它效率更高些。
(2)、&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是
boolean 类型时，&amp;用于按位与运算符的操作。
|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似
44. try&#123;&#125;里面有一个 return 语句，那么紧跟在这个 try 后的
finally, 里面的语句在异常出现后，都会执行么？为什么？
在异常处理时提供 finally 块来执行任何清除操作。
如果有 finally 的话，则不管是否发生异常，finally 语句都会被执行，包括
遇到 return 语句。
finally 中语句不执行的唯一情况中执行了 System.exit(0)语句。
45. 有一段 java 应用程序，它的主类名是 al，那么保存它的源文
件可以是？()
A. al.java
B. al.class
C. al
D. 都对
答案：A
分析：.class 是 java 的解析文件
46. Java 类可以作为（）
A 类型定义机制
111
B. 数据封装机制
C. 类型定义机制和数据封装机制
D. 上述都不对
答案： C
47. 在调用方法时，若要使方法改变实参的值，可以？（）
A 用基本数据类型作为参数
B. 用对象作为参数
C. A和B都对
D. A 和 B 都不对
答案：B
分析：基本数据类型不能改变实参的值
48. Java 语言具有许多优点和特点，哪个反映了 java 程序并行机
制的（）
A 安全性
B. 多线性
C. 跨平台
D. 可移植
答案：BC
49. 下关于构造函数的描述错误是（）
A 构造函数的返回类型只能是void型
B.
构造函数是类的一种特殊函数，它的方法名必须与类名相同
112
C. 构造函数的主要作用是完成对类的对象的初始化工作
D. 一般在创建新对象时，系统会自动调用构造函数
答案：A
分析：构造函数的名字与类的名字相同，并且不能指定返回类型。
50. 若需要定义一个类域或类方法，应使用哪种修饰符？（）
A static
B. package
C. private
D. public
答案：A
51. 下面代码执行后的输出是什么（）
package com.bjsxt;
public class Test &#123;
public static void main(String\[] args) &#123;
outer: for (int i = 0; i &lt; 3; i++)
inner: for (int j = 0; j &lt; 2; j++) &#123;
if (j == 1)
continue outer;
System.out.println(j + &quot; and &quot; + i);
&#125;
&#125;
&#125;
A 0 and 0
0 and 1
0 and 2
B. 1 and 0
113
1 and 1
1 and 2
C. 2 and 0
2 and1
2 and 2
答案：A
52. 给出如下代码，如何使成员变量 m 被函数 fun()直接访问（）
package com.bjsxt;
public class Test &#123;
private int m;
public static void fun() &#123;
// some code…
&#125;
&#125;
A 将 private int m 改为 protected int m
B. 将 private int m 改为 public int m
C. 将 private int m 改为 static int m
D. 将 private int m 改为 int m
答案：C
53. 下面哪几个函数是 public void example（）&#123;….&#125;的重载函
数（）
A public void example（int m）&#123;…&#125;
B. public int example（int m）&#123;…&#125;
C. public void example2（）&#123;…&#125;
114
D. public int example（int m，float f）&#123;…&#125;
答案：ABD
54. 请问以下代码执行会打印出什么？
父类：
package com.bjsxt;
public class FatherClass &#123;
public FatherClass() &#123;
System.out.println(&quot;FatherClassCreate&quot;);
&#125;
&#125;
子类：
package com.bjsxt;
import com.bjsxt.FatherClass;
public class ChildClass extends FatherClass &#123;
public ChildClass() &#123;
System.out.println(&quot;ChildClass Create&quot;);
&#125;
public static void main(String\[] args) &#123;
FatherClass fc = new FatherClass();
ChildClass cc = new ChildClass();
&#125;
&#125;
执行：C：&gt;java com.bjsxt.ChildClass
输出结果：？
答：
FatherClassCreate
FatherClassCreate
ChildClass Create
115
55. 如果有两个类 A、B（注意不是接口），你想同时使用这两个
类的功能，那么你会如何编写这个 C 类呢？
答：
因为类 A、B 不是接口，所以是不可以直接实现的，但可以将 A、B 类
定义成父子类，那么 C 类就能实现 A、B 类的功能了。假如 A 为 B 的父
类，B 为 C 的父类，此时 C 就能使用 A、B 的功能。
56. 一个类的构造方法是否可以被重载（overloading），是否可
以被子类重写（overrding）？
答：
构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父
类的构造方法
57. Java 中 byte 表示的数值范围是什么？
答：范围是-128 至 127
58. 如何将日期类型格式化为：2013-02-18 10:53:10？
public class TestDateFormat2 &#123;
public static void main(String\[] args) throws Exception &#123;
//第一步：将字符串（2013-02-18 10:53:10）转换成日期Date
DateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd
hh\:mm\:ss&quot;);
String sdate=&quot;2013-02-18 10:53:10&quot;;
Date date=sdf.parse(sdate);
System.out.println(date);
//第二步：将日期Date转换成字符串String
DateFormat sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd
hh\:mm\:ss&quot;);
String sdate2=sdf2.format(date);
116
System.out.println(sdate2);
&#125;
&#125;
59. 不通过构造函数也能创建对象吗（）
A. 是
B. 否
分析：答案：A
Java 创建对象的几种方式（重要）：
(1) 用 new 语句创建对象，这是最常见的创建对象的方法。
(2) 运用反射手段,调用 java.lang.Class 或者
java.lang.reflect.Constructor 类的 newInstance()实例方法。
(3) 调用对象的 clone()方法。
(4) 运用反序列化手段，调用 java.io.ObjectInputStream 对象的
readObject()方法。
(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影
印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用
构造函数。
60. 下面哪些是对称加密算法（）
A. DES
B. MD5
C. DSA
117
D. RSA
答案：A
分析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES
常用的非对称加密算法有：RSA、DSA、ECC
使用单向散列函数的加密算法：MD5、SHA
61. 下面的代码段，当输入为 2 的时候返回值是（）
publicstaticint get Value(int i)&#123;
int result=0;
switch(i)&#123;
case 1:
result=result +i
case 2:
result=result+i*2
case 3:
result=result+i*3
&#125;
return result;
&#125;
A 0
B. 2
C. 4
D. 10
答案：C
分析：result = 0 + 2 \* 2;
62. 以下 Java 代码段会产生几个对象
publicvoid test()&#123;
String a=&quot;a&quot;;
String b=&quot;b&quot;;
String c=&quot;c&quot;;
c=a+&quot;&quot;+b+&quot;&quot;+c;
118
System.out.print(c);
&#125;
分析：答案: 一个对象，因为编译期进行了优化，3 个字符串常量直接折
叠为一个
63. Math.round（-11.2）的运行结果是。
答案: -11
分析：小数点后第一位=5
正数：Math.round(11.5)=12
负数：Math.round(-11.5)=-11
小数点后第一位&lt;5
正数：Math.round(11.46)=11
负数：Math.round(-11.46)=-11
小数点后第一位&gt;5
正数：Math.round(11.68)=12
负数：Math.round(-11.68)=-12
根据上面例子的运行结果，我们还可以按照如下方式总结，或许更加容易
记忆：
参数的小数点后第一位&lt;5，运算结果为参数整数部分。
参数的小数点后第一位&gt;5，运算结果为参数整数部分绝对值+1，符号（即
正负）不变。
参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果
119
为整数部分。
终结：大于五全部加，等于五正数加，小于五全不加。
64. 十进制数 278 的对应十六进制数
分析：十进制数 278 的对应十六进制数是 116
65. Java 中 int.long 占用的字节数分别是
分析：
1：“字节”是 byte，“位”是 bit ；
2： 1 byte = 8 bit ；
char 在 Java 中是 2 个字节。java 采用 unicode，2 个字节（16 位）来表
示一个字符。
short 2 个字节
int 4 个字节
long 8 个字节
66. System.out.println(‘a’+1);的结果是
分析：&#39;a&#39;是 char 型，1 是 int 行，int 与 char 相加，char 会被强转为 int
行，char 的 ASCII 码对应的值是 97，所以加一起打印 98
67. 下列语句那一个正确（）
A. java 程序经编译后会产生 machine code
B. java 程序经编译后会产生 byte code
C. java 程序经编译后会产生 DLL
D. 以上都不正确
120
答案：B
分析：java 程序编译后会生成字节码文件,就是.class 文件
68. 下列说法正确的有（）
A. class 中的 constructor 不可省略
B. constructor 必须与 class 同名，但方法不能与 class 同名
C. constructor 在一个对象被 new 时执行
D. 一个 class 只能定义一个 constructor
答案：C
69. 执行如下程序代码（）
a=0；c=0；
do&#123;
——c；
a=a-1；
｝while（a＞0）；
后，c的值是（）
A.
0
B. 1
C. -1
D. 死循环
答案：C do&#123;...&#125;while(...);语句至少执行一次
121
70. 下列哪一种叙述是正确的（）
A. abstract 修饰符可修饰字段、方法和类
B. 抽象方法的 body 部分必须用一对大括号｛｝包住
C. 声明抽象方法，大括号可有可无
D. 声明抽象方法不可写出大括号
答案：D
分析： abstract 不能修饰字段。既然是抽象方法，当然是没有实现的方法，
根本就没有 body 部分。
71. 下列语句正确的是（）
A. 形式参数可被视为 local variable
B. 形式参数可被字段修饰符修饰
C. 形式参数为方法被调用时，真正被传递的参数
D. 形式参数不可以是对象
答案 A：
分析：
A：形式参数可被视为 local variable。形参和局部变量一样都不能离开方
法。都只有在方法内才会发生作用，也只有在方法中使用，不会在方法外
可见。
B：对于形式参数只能用 final 修饰符，其它任何修饰符都会引起编译器错
误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何
122
修改。 不过一般情况下，一个方法的形参不用 final 修饰。只有在特殊情
况下，那就是：方法内部类。 一个方法内的内部类如果使用了这个方法
的参数或者局部变量的话，这个参数或局部变量应该是 final。
C：形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值
（指针、引用皆在此列），也就是说真正被传递的是实参。
D：方法的参数列表指定要传递给方法什么样的信息，采用的都是对象的
形式。因此，在参数列表中必须指定每个所传递对象的类型及名字。想 JAVA
中任何传递对象的场合一样，这里传递的实际上也是引用，并且引用的类
型必须正确。--《Thinking in JAVA》
72. 成员变量用 static 修饰和不用 static 修饰有什么区别？
1、两个变量的生命周期不同。
成员变量随着对象的创建而存在，随着对象的被回收而释放。
静态变量随着类的加载而存在，随着类的消失而消失。
2、调用方式不同。
成员变量只能被对象调用。
静态变量可以被对象调用，还可以被类名调用。
对象调用：p.country
类名调用 ：Person.country
3、别名不同。
成员变量也称为实例变量。
静态变量称为类变量。
4、数据存储位置不同。
成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.
静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享
数据.
73. 如果变量用 final 修饰，则怎样？如果方法 final 修饰，则怎
样？
1、用 final 修饰的类不能被扩展，也就是说不可能有子类；
2、用 final 修饰的方法不能被替换或隐藏：
① 使用 final 修饰的实例方法在其所属类的子类中不能被替换
（overridden）；
② 使用 final 修饰的静态方法在其所属类的子类中不能被重定义
（redefined）而隐藏 （hidden）；
3、用 final 修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或
稍有不同：
① 静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员
的静态变量，赋值可以在其声明中通过初始化表达式完成，也可以在静态初
始化块中进行；作为接口成员的静态变量，赋值只能在其声明中通过初始化
表达式完成；
② 实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可
以在其声明中通过初始化表达式完成，也可以在实例初始化块或构造器中进
行；
123
124
③ 方法参数变量在方法被调用时创建，同时被初始化为对应实参值，
终止于方法体 （body）结束，在此期间其值不能改变；
④ 构造器参数变量在构造器被调用（通过实例创建表达式或显示的构
造器调用）时创建，同时被初始化，为对应实参值，终止于构造器体结束，
在此期间其值不能改变；
⑤ 异常处理器参数变量在有异常被 try 语句的 catch 子句捕捉到时创
建，同时被初始化为实际的异常对象，终止于 catch 语句块结束，在此期间
其值不能改变；
⑥ 局部变量在其值被访问之前必须被明确赋值；
74. 在二进制数据中，小数点向右移一位，则数据（）
A. 除以 10
B. 除以 2
C. 乘以 2
D. 乘以 10
答案：C
分析：可以看个例子
101.1 对应的十进制为 2^2*1 + 2^1*0 + 2^0*1 + 2^-1*1 = 5.5
小数点右移一位
1011 对应的十进制为 2^3*1 + 2^2*0 + 2^1*1 + 2^0*1 = 11
所以是扩大到原来的2倍
75. 面向对象的特征有哪些方面?
答：面向对象的特征主要有以下几个方面：
1、抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据
抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些
行为的细节是什么。
2、继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的
类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。
继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变
因素的重要手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计
模式精解》中关于桥梁模式的部分）。
3、封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访
问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完
全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；
我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切
可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全
自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们
现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事
情）。
4、多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。
简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态
性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外
125
界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供
的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的
（就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池
供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用
供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获
得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑
定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。
运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法
重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用
父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类
对象的不同而表现出不同的行为）。
76. float f=3.4;是否正确?
答:不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）
属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强
制类型转换 float f =(float)3.4; 或者写成 float f =3.4F;。
77. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;
有错吗?
答：对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结
果也是 int 型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1
\+= 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short)(s1 + 1);其中有隐含
的强制类型转换。
126
78. Java 有没有 goto?
答： goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据
James Gosling（Java 之父）编写的《The Java Programming Language》
一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const，但是这
两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留
字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类
库中使用过的有特殊意义的单词或单词的组合都被视为保留字）
79. int 和 Integer 有什么区别?
答：Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引
入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操
作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），
int 的包装类就是 Integer，从 JDK 1.5 开始引入了自动装箱/拆箱机制，使
得二者可以相互转换。
Java 为每个原始类型提供了包装类型：
原始类型: boolean，char，byte，short，int，long，float，double
包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，
Double
package com.bjsxt;public class AutoUnboxingTest &#123;public static void main(String\[] args) &#123;
Integer a = new Integer(3);
Integer b = 3; // 将 3 自动装箱成 Integer 类型
int c = 3;
127
128
System.out.println(a == b); // false 两个引用没有引用同一
对象
System.out.println(a == c); // true a 自动拆箱成 int 类
型再和 c 比较
&#125;
&#125;
补充：最近还遇到一个面试题，也是和自动装箱和拆箱相关的，代码如下所示：
public class Test03 &#123;public static void main(String\[] args) &#123;
Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
System.out.println(f1 == f2);
System.out.println(f3 == f4);
&#125;
&#125;
如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要
注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象，所以下面的==运算
比较的不是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象
赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf，如果看看
valueOf 的源代码就知道发生了什么。
public static Integer valueOf(int i) &#123;
if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
return IntegerCache.cache\[i + (-IntegerCache.low)];
return new Integer(i);
&#125;
IntegerCache 是 Integer 的内部类，其代码如下所示：
/\* Cache to support the object identity semantics of autoboxing
for values between*   \-128 and 127 (inclusive) as required by JLS.
*
*   The cache is initialized on first usage. The size of the
cache
*   may be controlled by the &#123;@code -XX\:AutoBoxCacheMax=\&lt;size&gt;&#125;
option.
*   During VM initialization,
java.lang.Integer.IntegerCache.high property
*   may be set and saved in the private system properties in the
*   sun.misc.VM class.
\*/private static class IntegerCache &#123;
static final int low = -128;
static final int high;
static final Integer cache\[];static &#123;
// high value may be configured by property
int h = 127;
String integerCacheHighPropValue =sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.h
igh&quot;);
if (integerCacheHighPropValue != null) &#123;
try &#123;
int i = parseInt(integerCacheHighPropValue);
i = Math.max(i, 127);
// Maximum array size is Integer.MAX\_VALUE
h = Math.min(i, Integer.MAX\_VALUE - (-low) -1);
&#125; catch( NumberFormatException nfe) &#123;
// If the property cannot be parsed into an int,
ignore it.
&#125;
&#125;
high = h;129
cache = new Integer\[(high - low) + 1];
int j = low;
for(int k = 0; k &lt; cache.length; k++)
cache\[k] = new Integer(j++);// range \[-128, 127] must be interned (JLS7 5.1.7)
assert IntegerCache.high &gt;= 127;
&#125;private IntegerCache() &#123;&#125;
&#125;
简单的说，如果字面量的值在-128 到 127 之间，那么不会 new 新的 Integer
对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1==f2
的结果是 true，而 f3==f4 的结果是 false。越是貌似简单的面试题其中的
玄机就越多，需要面试者有相当深厚的功力。1.  &amp;和&amp;&amp;的区别？
答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。
逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布
尔值都是 true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算是因为，
如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进
行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时
判定用户名不是 null 而且不是空字符串，应当写为：username != null
&amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，
因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会
产生 NullPointerException 异常。注意：逻辑或运算符（|）和短路或运算
符（||）的差别也是如此。
130
补充：如果你熟悉 JavaScript，那你可能更能感受到短路运算的强大，想
成为 JavaScript 的高手就先从玩转短路运算开始吧。
2.  Math.round(11.5) 等于多少? Math.round(-11.5)等于多
少?
答：Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。
四舍五入的原理是在参数上加 0.5 然后进行下取整。
3.  swtich 是否能作用在 byte 上，是否能作用在 long 上，是
否能作用在 String 上?
答：早期的 JDK 中，switch（expr）中，expr 可以是 byte、short、char、
int。从 1.5 版开始，Java 中引入了枚举类型（enum），expr 也可以是枚
举，从 JDK 1.7 版开始，还可以是字符串（String）。长整型（long）是不
可以的。
4.  用最有效率的方法计算 2 乘以 8?
答： 2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的
3 次方）。
补充： 我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代
码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），
而且为什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答
案你可以自己百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，
从而得到更好的性能。说到这里你可能已经想到了：31 \* num &lt;==&gt; (num
&lt;&lt; 5) - num，左移 5 位相当于乘以 2 的 5 次方（32）再减去自身就相当于
131
132
乘以 31。现在的 VM 都能自动完成这个优化。
package com.bjsxt;public class PhoneNumber &#123;
private int areaCode;
private String prefix;
private String lineNumber;@Override
public int hashCode() &#123;
final int prime = 31;
int result = 1;
result = prime \* result + areaCode;
result = prime \* result*   ((lineNumber == null) ? 0 :
lineNumber.hashCode());
result = prime \* result + ((prefix == null) ? 0 :
prefix.hashCode());
return result;
&#125;@Override
public boolean equals(Object obj) &#123;
if (this == obj)
return true;
if (obj == null)
return false;
if (getClass() != obj.getClass())
return false;
PhoneNumber other = (PhoneNumber) obj;
if (areaCode != other.areaCode)
return false;
if (lineNumber == null) &#123;
if (other.lineNumber != null)
return false;
&#125; else if (!lineNumber.equals(other.lineNumber))
return false;
if (prefix == null) &#123;
if (other.prefix != null)
return false;
&#125; else if (!prefix.equals(other.prefix))
return false;
133
return true;
&#125;&#125;
143\. 在 Java 中，如何跳出当前的多重嵌套循环？
答：在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。
（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++
中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的
break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有
相反的作用，所以这种语法其实不知道更好）1.  构造器（constructor）是否可被重写（override）?
答：构造器不能被继承，因此不能被重写，但可以被重载。
2.  两个对象值相同(x.equals(y) == true)，但却可有不同的
hash code，这句话对不对？
答：不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码
（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样
规定的：(1)如果两个对象相同（equals 方法返回 true），那么它们的
hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它们并不
一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会
发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的
效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造
成存取性能急剧下降）。
补充：关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人
也就是仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软
件公司，《Effective Java》、《Java 编程思想》以及《重构：改善既有代
码质量》是 Java 程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买
一本吧）中是这样介绍 equals 方法的：首先 equals 方法必须满足自反性
（x.equals(x)必须返回 true）、对称性（x.equals(y)返回 true 时，y.equals(x)
也必须返回 true）、传递性（x.equals(y)和 y.equals(z)都返回 true 时，
x.equals(z)也必须返回 true）和一致性（当 x 和 y 引用的对象信息没有被修
改时，多次调用 x.equals(y)应该得到同样的返回值），而且对于任何非 null
值的引用 x，x.equals(null)必须返回 false。实现高质量的 equals 方法的诀
窍包括：1. 使用==操作符检查“参数是否为这个对象的引用”；2. 使用
instanceof 操作符检查“参数是否为正确的类型”；3. 对于类中的关键属
性，检查参数传入对象的属性是否与之相匹配；4. 编写完 equals 方法后，
问自己它是否满足对称性、传递性、一致性；5. 重写 equals 时总是要重写
hashCode；6. 不要将 equals 方法参数中的 Object 对象替换为其他的类
型，在重写时不要忘掉@Override 注解。
3.  当一个对象被当作参数传递到一个方法后，此方法可改变这个
对象的属性，并可返回变化后的结果，那么这里到底是值传递还
是引用传递?
答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个
参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在
134
被调用过程中被改变，但对象的引用是永远不会改变的。C++和 C#中可以
通过传引用或传输出参数来改变传入的参数的值。
补充：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没
有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将
需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对
象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++转
型为 Java 程序员的开发者无法容忍。
4.  重载（Overload）和重写（Override）的区别。重载的方法
能否根据返回类型进行区分?
答：Java 的三大特征之一，多态机制，包括方法的多态和对象的多态；方法
的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，
而后者实现的是运行时的多态性。重载（overload）发生在同一个类中，相
同的方法，如果有不同的参数列表（参数类型不同、参数个数不同或者二者
都不同）则视为重载；重写（override）发生在子类与父类之间也就是继承
机制当中，当父类的方法不能满足子类的要求，此时子类重写父类的方法；
要求：方法名、形参列表相同；返回值类型和异常类型，子类小于等于父类；
访问权限，子类大于等于父类，切记父类的私有方法以及被 final 修饰的方
法不能被子类重写；重载对返回类型没有特殊的要求。
135
5.  华为的面试题中曾经问过这样一个问题：为什么不能根据返回
类型来区分重载，为什么？
答：方法的重载，即使返回值类型不同，也不能改变实现功能相同或类似这
一既定事实；同时方法的重载只是要求两同三不同，即在同一个类中，相同
的方法名称，参数列表当中的参数类型、个数、顺序不同；跟权限修饰符和
返回值类无关
6.  静态嵌套类(Static Nested Class)和内部类（Inner Class）
的不同？
答：内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静
态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中
而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供
内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成
员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，所以，
把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，
就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定
义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示：
public class Outer
&#123;
int out\_x = 0;
public void method()
&#123;
Inner1 inner1 = new Inner1();
public class Inner2 //在方法体内部定义的内部类
&#123;
public method()
&#123;
136
out\_x = 3;
&#125;
&#125;
Inner2 inner2 = new Inner2();
&#125;
public class Inner1 //在方法体外面定义的内部类
&#123;
&#125;&#125;
在方法体外面定义的内部类的访问类型可以是 public,protecte,默认的，
private 等 4 种类型，这就好像类中定义的成员变量有 4 种访问类型一样，
它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以
在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外
部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，
代码如下：
Outer outer = new Outer();
Outer.Inner1 inner1 = outer.new Innner1();
在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的
局部变量一样，但这种内部类的前面可以使用 final 或 abstract 修饰符。这
种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类
创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，
即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须
先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，
137
138
但是，该局部变量前必须加 final 修饰符。
对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误
信息就可以马上了解到。
在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口
或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：
public class Outer
&#123;
public void start()
&#123;
new Thread(
new Runable()&#123;
public void run()&#123;&#125;;
&#125;
).start();
&#125;
&#125;
最后，在方法外部定义的内部类前面可以加上 static 关键字，从而成为 Static
Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部
类。Static Nested Class 与普通类在运行时的行为和功能上没有什么区别，
只是在编程引用时的语法上有一些差别，它可以定义成 public、protected、
默认的、private 等多种类型，而普通类只能定义成 public 和默认的这两种
类型。在外面引用 Static Nested Class 类的名称为“外部类名.内部类名”。
在外面不需要创建外部类的实例对象，就可以直接创建 Static Nested Class，
例如，假设 Inner 是定义在 Outer 类中的 Static Nested Class，那么可以
使用如下语句创建 Inner 类：
Outer.Inner inner = newOuter.Inner();
由于 static Nested Class 不依赖于外部类的实例对象，所以，static Nested
Class 能访问外部类的非 static 成员变量(不能直接访问，需要创建外部类实
例才能访问非静态变量)。当在外部类中访问 Static Nested Class 时，可以
直接使用 Static Nested Class 的名字，而不需要加上外部类的名字了，在
Static Nested Class 中也可以直接引用外部类的 static 的成员变量，不需要
加上外部类的名字。
在静态方法中定义的内部类也是 Static Nested Class，这时候不能在类前面
加 static 关键字，静态方法中的 Static Nested Class 与普通方法中的内部
类的应用方式很相似，它除了可以直接访问外部类中的 static 的成员变量，
还可以访问静态方法中的局部变量，但是，该局部变量前必须加 final 修饰
符。
备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个
地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的
特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静
139
140
态内部类，以及匿名内部类。
Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于
外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，
其语法看起来挺诡异的，如下所示。
1.  抽象的（abstract）方法是否可同时是静态的（static）,是否
可同时是本地方法（native），是否可同时被 synchronized 修饰?
答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此
二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方
法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽
象方法不涉及实现细节，因此也是相互矛盾的。
2.  静态变量和实例变量的区别？
答：静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不
属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有
且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过
对象才能访问到它，静态变量可以实现让多个对象共享内存。两者的相同点：
都有默认值而且在类的任何地方都可以调用。在 Java 开发中，上下文类和
工具类中通常会有大量的静态成员。
3.  是否可以从一个静态（static）方法内部发出对非静态
（non-static）方法的调用？
答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建
对象，因此在调用静态方法时可能对象并没有被初始化。
4.  如何实现对象克隆？
package com.bjsxt;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;public class MyUtil &#123;
private MyUtil() &#123;
throw new AssertionError();
&#125;
public static \&lt;T&gt; T clone(T obj) throws Exception &#123;
ByteArrayOutputStream bout = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(bout);
oos.writeObject(obj);
ByteArrayInputStream bin = new
ByteArrayInputStream(bout.toByteArray());
ObjectInputStream ois = new ObjectInputStream(bin);
return (T) ois.readObject();
// 说明：调用ByteArrayInputStream或ByteArrayOutputStream
对象的close方法没有任何意义
// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源
&#125;
&#125;
答：有两种方式：
1.实现 Cloneable 接口并重写 Object 类中的 clone()方法；
2.实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实
145
现真正的深度克隆，代码如下。
下面是测试代码：
注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通
过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器
完成的，不是在运行时抛出异常，这种是方案明显优于使用 Object 类的
clone 方法克隆对象。1.  接口是否可继承（extends）接口? 抽象类是否可实现
（implements）接口? 抽象类是否可继承具体类（concrete
class）?
答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继
承具体类。抽象类中可以有静态的 main 方法。
备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想
149
想，如果你是 java 语言的设计者，你是否会提供这样的支持，如果不提供
的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。
只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有
abstract 方法。
2.  一个“.java”源文件中是否可以包含多个类（不是内部类）？
有什么限制？
答：可以，但一个源文件中最多只能有一个公开类（public class）而且文
件名必须和公开类的类名完全保持一致。
3.  Anonymous Inner Class(匿名内部类)是否可以继承其它类？
是否可以实现接口？
答：可以继承其他类或实现其他接口，在 Swing 编程中常用此方式来实现事
件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。
4.  内部类可以引用它的包含类（外部类）的成员吗？有没有什么
限制？
答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。
如果要访问外部类的局部变量，此时局部变量必须使用 final 修饰，否则无
法访问。
5.  Java 中的 final 关键字有哪些用法？
答：
(1) 修饰类：表示该类不能被继承；
(2) 修饰方法：表示方法不能被重写但是允许重载；
150
(3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）；
(4) 修饰对象：对象的引用地址不能变，但是对象的初始化值可以变。
6.  指出下面程序的运行结果:
package com.bjsxt;
class A&#123;
static&#123;
System.out.print(&quot;1&quot;);
&#125;
public A()&#123;
System.out.print(&quot;2&quot;);
&#125;
&#125;
class B extends A&#123;
static&#123;
System.out.print(&quot;a&quot;);
&#125;
public B()&#123;
System.out.print(&quot;b&quot;);
&#125;
&#125;public class Hello&#123;
public static void main(String\[] args)&#123;
A ab = new B();
ab = new B();
&#125;
&#125;
答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态
成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。
考点：静态代码块优先级 &gt; 构造方法的优先级
如果再加一个普通代码块，优先顺序如下：
静态代码块&gt;普通代码块&gt;构造方法
1511.  说说数据类型之间的转换:
1 ) 如何将字符串转换为基本数据类型？
2 ) 如何将基本数据类型转换为字符串？
答：
1 ) 调用基本数据类型对应的包装类中的方法 parseXXX(String)或
valueOf(String)即可返回相应基本类型；
2 ) 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其
所对应的字符串；另一种方法是调用 String 类中的 valueOf(…)方法返回相
应字符串
2.  如何实现字符串的反转及替换？
答：方法很多，可以自己写实现也可以使用 String 或 StringBuffer /
StringBuilder 中的方法。有一道很常见的面试题是用递归实现字符串反转，
代码如下所示：
package com.bjsxt;
public class A&#123;
public static String reverse(String originStr) &#123;
if(originStr == null || originStr.length() &lt;= 1)
return originStr;
return reverse(originStr.substring(1)) +
originStr.charAt(0);
&#125;
&#125;
3.  怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字
符串？
答：代码如下所示:
152
String s1 = &quot;你好&quot;;
String s2 = newString(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);
在 String 类的构造方法当中，存在一个字符集设置的方法，具体如下：
4.  Java 中的日期和时间：
1 ) 如何取得年月日、小时分钟秒？
2 ) 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？
3 ) 如何取得某月的最后一天？
4 ) 如何格式化日期？
答：操作方法如下所示：
1 ) 创建 java.util.Calendar 实例，调用其 get()方法传入不同的参数即可获
得参数所对应的值
2 ) 以下方法均可获得该毫秒数:
Calendar.getInstance().getTimeInMillis();
System.currentTimeMillis();
3 ) 示例代码如下:
Calendar time = Calendar.getInstance();
time.getActualMaximum(Calendar.DAY\_OF\_MONTH);
4 ) 利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的
format(Date)方法可将日期格式化。
5.  打印昨天的当前时刻。
答：
package com.bjsxt;
import java.util.Calendar;
public class YesterdayCurrent &#123;
public static void main(String\[] args)&#123;
Calendar cal = Calendar.getInstance();
153
cal.add(Calendar.DATE, -1);
System.out.println(cal.getTime());
&#125;
&#125;
6.  Java 反射技术主要实现类有哪些，作用分别是什么？
在 JDK 中，主要由以下类来实现 Java 反射机制，这些类都位于
java.lang.reflect 包中
1）Class 类：代表一个类
2）Field 类：代表类的成员变量(属性)
3）Method 类：代表类的成员方法
4）Constructor 类：代表类的构造方法
5）Array 类：提供了动态创建数组，以及访问数组的元素的静态方法
7.  Class 类的作用？生成 Class 对象的方法有哪些？
Class 类是 Java 反射机制的起源和入口，用于获取与类相关的各种信
息，提供了获取类信息的相关方法。Class 类继承自 Object 类
Class 类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实
物的关系；每个类也可看做是一个对象，有共同的图纸 Class，存放类的 结
构信息，能够通过相应方法取出相应信息：类的名字、属性、方法、构造方
法、父类和接口
方 法 示 例
对象名
.getClass()
String str=&quot;bdqn&quot;;
Class clazz = str.getClass();
154
对象名
.getSuperClass()
Student stu = new Student();
Class c1 = stu.getClass();
Class c2 = stu.getSuperClass();
Class.forName()
Class clazz = Class.forName(&quot;java.lang.Object&quot;);
Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
类名.class
Class c1 = String.class;
Class c2 = Student.class;
Class c2 = int.class
包装类.TYPE
Class c1 = Integer.TYPE;
Class c2 = Boolean.TYPE;
8.  反射的使用场合和作用、及其优缺点
1）使用场合
在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息
来发现该对象和类的真实信息。
2）主要作用
通过反射可以使程序代码访问装载到 JVM 中的类的内部信息，获取已装载
类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息
3）反射的优点
反射提高了 Java 程序的灵活性和扩展性，降低耦合性，提高自适应能力。
它允许程序创建和控制任何类的对象，无需提前硬编码目标类；反射是其它
一些常用语言，如 C、C++、Fortran 或者 Pascal 等都不具备的
4） Java 反射技术应用领域很广，如软件测试等；许多流行的开源框架例如
Struts、Hibernate、Spring 在实现过程中都采用了该技术
5）反射的缺点
性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要
远慢于直接代码。因此 Java 反射机制主要应用在对灵活性和扩展性要求很
高的系统框架上,普通程序不建议使用。
使用反射会模糊程序内部逻辑：程序人员希望在源代码中看到程序的逻
辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的
直接代码更复杂。
9.  面向对象设计原则有哪些
面向对象设计原则是面向对象设计的基石，面向对象设计质量的依据和
保障，设计模式是面向对象设计原则的经典应用
1）单一职责原则 SRP
2）开闭原则 OCP
3）里氏替代原则 LSP
4）依赖注入原则 DIP
5）接口分离原则 ISP
6）迪米特原则 LOD
7）组合/聚合复用原则 CARP
8）开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其
155
156
他设计原则都可以看作是开闭原则的实现手段或方法
String 相关：
10. 下面程序的运行结果是（）（选择一项）
String str1=&quot;hello&quot;;
String str2=new String(&quot;hello&quot;);
System.out.println(str1==str2);
A. true
B. false
C. hello
D. he
答案：B
分析：str1 没有使用 new 关键字，在堆中没有开辟空间，其值”hello”
在常量池中，str2 使用 new 关键字创建了一个对象，在堆中开辟了空
间，”==”比较的是对象的引用，即内存地址，所以 str1 与 str2 两个对
157
象的内存地址是不相同的
11. Java 语言中，String 类中的 indexOf()方法返回值的类型是
（）
A. int16
B. int32
C. int
D. long
答案：C
12. 给定以下代码，程序的运行结果是 （）（选择一项）
public class Example &#123;
String str=new String(&quot;good&quot;);
char \[] ch=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
public static void main(String\[] args) &#123;
Example ex=new Example();
ex.change(ex.str, ex.ch);
System.out.print(ex.str+&quot;and&quot;);
System.out.print(ex.ch);
&#125;
public void change(String str,char ch\[])&#123;
str=&quot;test ok&quot;;
ch\[0]=&#39;g&#39;;
&#125;
&#125;
A goodandabc
B. goodandgbc
C. test okandabc
D. test okandgbc
158
答案：B
分析：在方法调用时，在 change 方法中对 str 的值进行修改，是将 str 指
向了常量江池中的”test ok”，而主方法中的 ex.str 仍然指向的是常量池
中的”good”。字符型数组在方法调用时，将主方法中 ex.ch 的引用传递
给 change 方法中的 ch，指向是堆中的同一堆空间，所以修改 ch\[0]的时
候,ex.ch 可以看到相同的修改后的结果。
13. 执行下列代码后，哪个结论是正确的（）（选择两项）
String\[] s=new String\[10];
A. s\[10]为””
B. s\[9]为 null
C. s\[0]为未定义
D. s.length 为 10
答案：BD
分析： 引用数据类型的默认值均为 null
s.length 数组的长度
14. 实现 String 类的 replaceAll 方法
思路说明：replaceAll 方法的本质是使用正则表达式进行匹配，最终调用的
其实是 Matcher 对象的 replaceAll 方法。
import java.util.regex.Matcher;
import java.util.regex.Pattern;
159
public class TestStringReplaceAll &#123;
public static void main(String\[] args) &#123;
String str = &quot;a1s2d3f4h5j6k7&quot;;
// 将字符串中的数字全部替换为 0
System.out.println(replaceAll(str, &quot;\d&quot;, &quot;0&quot;));
&#125;
/\*\**   @param str:源字符串
*   @param regex:正则表达式
*   @param newStr:替换后的子字符串
*   @return 返回替换成功后的字符串
\*/
public static String replaceAll(String str, String regex, String newStr)
&#123;
Pattern pattern = Pattern.compile(regex);
Matcher mathcer = pattern.matcher(str);
String reslut = mathcer.replaceAll(newStr);
return reslut;
&#125;
&#125;
1601.  在“=”后填写适当的内容：
String \[]a=new String\[10];
则：a\[0]~a\[9]=null;
a.length=10;
如果是 int\[]a=new int\[10];
则：a\[0]~a\[9]= (0)
a.length= (10)
2.  是否可以继承 String 类?
答:
不可以，因为 String 类有 final 修饰符，而 final 修饰的类是不能被继承的，
实现细节不允许改变。
public final class String implements java.io.Serializable,
Comparable\&lt;String&gt;, CharSequence
3.  给定两个字符串 s 和 t， 写一个函数来决定是否 t 是 s 的重
组词。你可以假设字符串只包含小写字母。
public class Solution &#123;
public boolean isAnagram(String s, String t) &#123;
if(s.length()!=t.length())
return false;
int bit\[] = new int\[26];
for(int i=0;i\&lt;s.length();i++)&#123;
bit\[s.charAt(i)-&#39;a&#39;]++;
&#125;
for(int i=0;i\&lt;s.length();i++)&#123;
if(--bit\[t.charAt(i)-&#39;a&#39;]&lt;0)
return false;
&#125;
return true;
&#125;
&#125;
4.  String s=new String(“abc”);创建了几个 String 对象。
两个或一个，”abc”对应一个对象，这个对象放在字符串常量缓冲区，常
量”abc”不管出现多少遍，都是缓冲区中的那一个。New String 每写一遍，
就创建一个新的对象，它一句那个常量”abc”对象的内容来创建出一个新
String 对象。如果以前就用过’abc’，这句代表就不会创建”abc”自己
了，直接从缓冲区拿。
5.  输出结果？
String str1=“hello”；
Sring str2=“he”+new String(“llo”)；
Sysem.out.println(str1==str2));
161
162
Sysem.out.println(str.equal(str2));
false
true
6.  下列程序的输出结果是什么？
import java.util.\*;
public class Test 6&#123;
public static void main(String\[] args) &#123;
for (int i = 0; i &lt; 10; i++) &#123;
Integer k=new Integer(i);
System.out.println(k+&quot; Hello world&quot;);
&#125;
&#125;
&#125;
0 Hello world
1 Hello world
2 Hello world
3 Hello world
4 Hello world
5 Hello world
163
6 Hello world
7 Hello world
8 Hello world
9 Hello world
7.  关于 java.lang.String 类，以下描述正确的一项是（）
A. String类是final类故不可继承
B. String 类 final 类故可以继承
C. String类不是final类故不可继承
D. String;类不是 final 类故可以继承
答案：A
8.  下面哪个是正确的（）
A. String temp\[ ] = new String&#123;“a”,”b”,”c”&#125;;
B. String temp\[ ] = &#123;“a”,”b”,”c”&#125;;
C. String temp= &#123;“a”,”b”,”c”&#125;;
D. String\[ ] temp = &#123;“a”,”b”,”c”&#125;;
答案：BD
9.  已知如下代码：执行结果是什么（）
package com.bjsxt;
public class Test &#123;
public static void main(String\[] args) &#123;
String s1 = new String(&quot;Hello&quot;);
String s2 = new String(&quot;Hello&quot;);
System.out.print(s1 == s2);
String s3 = &quot;Hello&quot;;
String s4 = &quot;Hello&quot;;
164
System.out.print(s3 == s4);
s1 = s3;
s2 = s4;
System.out.print(s1 == s2);
&#125;
&#125;
A false true true
B. true false true
C. true true false
D. true true false
答案：A
10. 字符串如何转换为 int 类型
public class Test &#123;
public static void main(String\[] args) &#123;
//方式一
int num=Integer.parseInt(&quot;123&quot;);
//方式二
int num2=Integer.valueOf(&quot;123&quot;);
System.out.println(num+&quot; &quot;+num2);
&#125;
&#125;
11. 写一个方法，实现字符串的反转，如：输入 abc，输出 cba
public class Test &#123;
public static void main(String\[] args) &#123;
String result=reverse(&quot;abc&quot;);
System.out.println(result);
&#125;
public static String reverse(String str)&#123;
StringBuilder result=new StringBuilder(&quot;&quot;);
char\[] chArra=str.toCharArray();
for(int i=chArra.length-1;i&gt;=0;i--)&#123;
char ch=chArra\[i];
result.append(ch);
165
&#125;
return result.toString();
&#125;
&#125;
12. 编写 java，将“I follow Bill Gate.Tom Gate.John Gate”
中的“Gate”全部替换为“Gates”
public classDemo1 &#123;
publicstaticvoid main(String\[] args) &#123;
String s=&quot;I follow Bill Gate.Tom Gate.John Gate&quot;;
System.out.println(s);
s=s.replaceAll(&quot;Gate&quot;,&quot;Gates&quot;);
System.out.println(s);
&#125;
&#125;
13. String 是最基本的数据类型吗?
答： 不是 。Java 中的基本数据类型只有 8 个：byte、short、int、long、
float、double、char、boolean；除了基本类型（primitive type）和枚举
类型（enumeration type），剩下的都是引用类型（reference type）。
14. String 和 StringBuilder、StringBuffer 的区别?
答： Java 平台提供了两种类型的字符串：String 和 StringBuffer /
StringBuilder
相同点：
它们都可以储存和操作字符串，同时三者都使用 final 修饰，都属于终结类
不能派生子类，操作的相关方法也类似例如获取字符串长度等；
不同点：
其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被
改变的，而 StringBuffer 和 StringBuilder 类表示的字符串对象可以直接进
166
行修改，在修改的同时地址值不会发生改变。StringBuilder 是 JDK 1.5 中
引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下
使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也
比 StringBuffer 略高。在此重点说明一下，String、StringBuffer、
StringBuilder 三者类型不一样，无法使用 equals()方法比较其字符串内容
是否一样！
补充 1：有一个面试题问：有没有哪种情况用+做字符串连接比调用
StringBuffer / StringBuilder 对象的 append 方法性能更好？如果连接后
得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于
StringBuffer / StringBuilder 的 append 方法的。
补充 2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答
案。
package com.bjsxt;
public class smallT &#123;
public static void main(String\[] args) &#123;
String a = &quot;Programming&quot;;
String b = new String(&quot;Programming&quot;);
String c = &quot;Program&quot; + &quot;ming&quot;;
System.out.println(a == b);
System.out.println(a == c);
System.out.println(a.equals(b));
System.out.println(a.equals(c));
System.out.println(a.intern() == b.intern());
&#125;
&#125;
解析：
String 类存在 intern()方法，含义如下：返回字符串对象的规范化表示形
式。它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t)
167
为 true 时，s.intern() == t.intern() 才为 true。
字符串比较分为两种形式，一种使用比较运算符”==”比较，他们比较的是各
自的字符串在内存当中的地址值是否相同；一种是使用 equals()方法进行
比较，比较的是两个字符串的内容是否相同！
结果如下：
a == b--&gt;false
a == c--&gt;true
a.equals(b)--&gt;true
a.equals(c)--&gt;true
a.intern() == b.intern()--&gt;true
15. String 类为什么是 final 的
答：
1）为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。
2）为了安全。JDK 中提供的好多核心类比如 String，这类的类的内部好多
方法的实现都不是 java 编程语言本身编写的，好多方法都是调用的操作系统
本地的 API，这就是著名的“本地方法调用”，也只有这样才能做事，这种
类是非常底层的，和操作系统交流频繁的，那么如果这种类可以被继承的话，
如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质
的代码什么的，这不就成了核心病毒了么？不希望别人改，这个类就像一个
工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让
我们随便能改，其实说白了还是安全性，如果随便能改了，那么 java 编写的
程序肯定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人
来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的， 所以这
个安全性是很重要的，java 和 C++相比，优点之一就包括这一点。
16. String 类型是基本数据类型吗？基本数据类型有哪些
1） 基本数据类型包括 byte、short/char、int、long、float、double、
boolean
2 ) java.lang.String 类是引用数据类型，并且是 final 类型的，因此不可以
继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用
StringBuffer 类
17. String s=&quot;Hello&quot;;s=s+&quot;world!&quot;;执行后，是否是对前面 s
指向空间内容的修改？
答：不是对前面 s 指向空间内容的直接修改。
因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变
对象。在这段代码中，s 原先指向一个 String 对象，内容是 &quot;Hello&quot;，然后
我们对 s 进行了+操作，那么 s 所指向的那个对象是否发生了改变呢？答案
168
是没有。这时，s 不指向原来那个对象了，而指向了另一个 String 对象，内
容为&quot;Hello world!&quot;，原来那个对象还存在于内存之中，只是 s 这个引用变
量不再指向它了。
通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种
各样的修改，或者说，不可预见的修改，那么使用 String 来代表字符串的话
会引起很大的内存开销。因为 String 对象建立之后不能再改变，所以对于
每一个不同的字符串，都需要一个 String 对象来表示。这时，应该考虑使用
StringBuffer 类，它允许修改，而不是每个不同的字符串都要生成一个新的
对象。并且，这两种类的对象转换十分容易。
同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new
一个 String。例如我们要在构造器中对一个名叫 s 的 String 引用变量进行
初始化，把它设置为初始值，应当这样做：
public class Demo &#123;
private String s;
...
public Demo &#123;
s = &quot;Initial Value&quot;;
&#125;
...
&#125;
而非
169
s = new String(&quot;Initial Value&quot;);
后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有
意义，因为 String 对象不可改变，所以对于内容相同的字符串，只要一个
String 对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，
他们的 String 类型属性 s 都指向同一个对象。
上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java
认为它们代表同一个 String 对象。而用关键字 new 调用构造器，总是会创
建一个新的对象，无论内容是否相同。
至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只
String，很多 Java 标准类库中的类都是不可变的。在开发一个系统的时候，
我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思
想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程
并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要
一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了
一个可变版本，即 StringBuffer。
18. String s = new String(&quot;xyz&quot;);创建几个 String Object?
答：两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，
常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String 每写一
遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一
个新 String 对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”
自己了，直接从缓冲区拿。
170
171
19. 下面这条语句一共创建了多少个对象：String
s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;
答：对于如下代码：
String s1 = &quot;a&quot;;
String s2 = s1 + &quot;b&quot;;
String s3 = &quot;a&quot; + &quot;b&quot;;
System.out.println(s2 == &quot;ab&quot;);
System.out.println(s3 == &quot;ab&quot;);
第一条语句打印的结果为 false，第二条语句打印的结果为 true，这说明
javac 编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行
期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一
个这些常量相连的结果。
题目中的第一行代码被编译器在编译时优化后，相当于直接定义一个”abcd”
的字符串，所以，上面的代码应该只创建了一个 String 对象。
写如下两行代码，
String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; + &quot;d&quot;;
System.out.println(s == &quot;abcd&quot;);
最终打印的结果应该为 true。
集合：
20. Java 集合体系结构（List、Set、Collection、Map 的区别
和联系）
1、Collection 接口存储一组不唯一，无序的对象
2、List 接口存储一组不唯一，有序（插入顺序）的对象
3、Set 接口存储一组唯一，无序的对象
4、Map 接口存储一组键值对象，提供 key 到 value 的映射。Key 无序，唯
172
一。value 不要求有序，允许重复。（如果只使用 key 存储，而不使用
value，那就是 Set）
21. Vector 和 ArrayList 的区别和联系
相同点：
1）实现原理相同---底层都使用数组
2）功能相同---实现增删改查等操作的方法相似
3）都是长度可变的数组结构，很多情况下可以互用
不同点：
1）Vector 是早期 JDK 版本提供，ArrayList 是新版本替代 Vector 的
2）Vector 线程安全，ArrayList 重速度轻安全，线程非安全
长度需增长时，Vector 默认增长一倍，ArrayList 增长 50%
22. ArrayList 和 LinkedList 的区别和联系
相同点：
两者都实现了 List 接口，都具有 List 中元素有序、不唯一的特点。
不同点：
ArrayList 实现了长度可变的数组，在内存中分配连续空间。遍历元素和
随机访问元素的效率比较高；
LinkedList 采用链表存储方式。插入、删除元素时效率比较高
173
24. HashSet 的使用和原理（hashCode()和 equals()）
1）哈希表的查询速度特别快，时间复杂度为 O（1）。
2）HashMap、Hashtable、HashSet 这些集合采用的是哈希表结构，需要
用到 hashCode 哈希码，hashCode 是一个整数值。
3）系统类已经覆盖了 hashCode 方法 自定义类如果要放入 hash 类集合，
必须重写 hashcode。如果不重写，调用的是 Object 的 hashcode，而
Object 的 hashCode 实际上是地址。
4）向哈希表中添加数据的原理：当向集合 Set 中增加对象时，首先集合计
算要增加对象的 hashCode 码，根据该值来得到一个位置用来存放当前
对象，如在该位置没有一个对象存在的话，那么集合 Set 认为该对象在
集合中不存在，直接增加进去。如果在该位置有一个对象存在的话，接
着将准备增加到集合中的对象与该位置上的对象进行 equals 方法比较，
174
如果该 equals 方法返回 false,那么集合认为集合中不存在该对象，在进
行一次散列，将该对象放到散列后计算出的新地址里。如果 equals 方法
返回 true，那么集合认为集合中已经存在该对象了，不会再将该对象增
加到集合中了。
5）在哈希表中判断两个元素是否重复要使用到 hashCode()和 equals()。
hashCode决定数据在表中的存储位置，而equals判断是否存在相同数据。
6）Y=K(X) ：K 是函数，X 是哈希码，Y 是地址
25. TreeSet 的原理和使用（Comparable 和 comparator）
1）TreeSet 集合，元素不允许重复且有序(自然顺序)
2）TreeSet 采用树结构存储数据，存入元素时需要和树中元素进行对比，需
要指定比较策略。
3）可以通过 Comparable(外部比较器)和 Comparator(内部比较器)来指定
比较策略，实现了 Comparable 的系统类可以顺利存入 TreeSet。自定
义类可以实现 Comparable 接口来指定比较策略。
4）可创建 Comparator 接口实现类来指定比较策略，并通过 TreeSet 构造
方法参数传入。这种方式尤其对系统类非常适用。
26. 集合和数组的比较（为什么引入集合）
数组不是面向对象的，存在明显的缺陷，集合完全弥补了数组的一些
缺点，比数组更灵活更实用，可大大提高软件的开发效率而且不同的集合框
架类可适用于不同场合。具体如下：
1）数组的效率高于集合类.
175
2）数组能存放基本数据类型和对象，而集合类中只能放对象。
3）数组容量固定且无法动态改变，集合类容量动态改变。
4）数组无法判断其中实际存有多少元素，length 只告诉了 array 的容
量。
5）集合有多种实现方式和不同的适用场合，而不像数组仅采用顺序表
方式。
6）集合以类的形式存在，具有封装、继承、多态等类的特性，通过简
单的方法和属性调用即可实现各种复杂操作，大大提高软件的开发效率。
27. Collection 和 Collections 的区别
1）Collection 是 Java 提供的集合接口，存储一组不唯一，无序的对象。它
有两个子接口 List 和 Set。
2）Java 中还有一个 Collections 类，专门用来操作集合类 ，它提供一系列
静态方法实现对各种集合的搜索、排序、线程安全化等操作。
28. 下列说法正确的有（）（选择一项）
A. LinkedList继承自List
B. AbstractSet 继承自 Set
C. HashSet继承自AbstractSet
D. TreeMap 继承自 HashMap
答案： C
分析：A：LinkedList 实现 List 接口
B：AbstractSet 实现 Set 接口
176
D：TreeMap 继承 AbstractMap
30. 列出 Java 中的集合类层次结构？
答:
Java 中集合主要分为两种：Collection 和 Map。Collection 是 List 和 Set 接口的父接
口；ArrayList 和 LinkedList 是 List 的实现类；HashSet 和 TreeSet 是 Set 的实现类；
LinkedHashSet 是 HashSet 的子类。HashMap 和 TreeMap 是 Map 的实现类；
LinkedHashMap 是 HashMap 的子类。
图中：虚线框中为接口，实线框中为类。
31. List，Set，Map 各有什么特点
答:
List 接口存储一组不唯一，有序（插入顺序）的对象。
Set 接口存储一组唯一，无序的对象。
Map 接口存储一组键值对象，提供 key 到 value 的映射。key 无序，唯一。
value 不要求有序，允许重复。（如果只使用 key 存储，而不使用 value，那
就是 Set）。
178
179
32. ArrayList list=new ArrayList(20);中的 list 扩充几次（）
A 0
B. 1
C. 2
D. 3
答案：A
分析：已经指定了长度, 所以不扩容
33. List、Set、Map 哪个继承自 Collection 接口，一下说法正
确的是（）
A List Map
B. Set Map
C. List Set
D. List Map Set
答案：C
分析：Map 接口继承了 java.lang.Object 类,但没有实现任何接口.
34. 合并两个有序的链表
public class Solution &#123;
public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
if (l1 == null || l2 == null) &#123;
return l1 != null ? l1 : l2;
&#125;
ListNode head = l1.val &lt; l2.val ? l1 : l2;
ListNode other = l1.val &gt;= l2.val ? l1 : l2;
ListNode prevHead = head;
ListNode prevOther = other;
while (prevHead != null) &#123;
ListNode next = prevHead.next;
if (next != null &amp;&amp; next.val &gt; prevOther.val) &#123;
prevHead.next = prevOther;
prevOther = next;
&#125;
if(prevHead.next==null)&#123;
prevHead.next=prevOther;
break;
&#125;
prevHead=prevHead.next;
&#125;
return head;
&#125;
&#125;
35. 用递归方式实现链表的转置。
/\*\*
Definition for singly-linked list.
public class ListNode &#123;
int val;
ListNode next;
ListNode(int x) &#123; val = x; &#125;*   &#125;
\*/
public class Solution &#123;
public ListNode reverseList(ListNode head) &#123;
if(head==null||head.next ==null)
return head;
ListNode prev = reverseList(head.next);
head.next.next = head;
head.next = null;
return prev;
&#125;
&#125;1.  给定一个不包含相同元素的整数集合，nums，返回所有可能
的子集集合。解答中集合不能包含重复的子集。
public class Solution &#123;
180
public List\&lt;List\&lt;Integer&gt;&gt; subsets (int\[] nums) &#123;
List\&lt;List\&lt;Integer&gt;&gt; res = new
ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt;();
List\&lt;Integer&gt; item = new ArrayList\&lt;Integer&gt;();
if(nums.length == 0 || nums == null)
return res;
Arrays.sort(nums); //排序
dfs(nums, 0, item, res); //递归调用
res.add(new ArrayList\&lt;Integer&gt;()); //最后加上一个空集
return res;
&#125;
public static void dfs(int\[] nums, int start, List\&lt;Integer&gt;
item, List\&lt;List\&lt;Integer&gt;&gt; res)&#123;
for(int i = start; i &lt; nums.length; i ++)&#123;
item.add(nums\[i]);
//item 是以整数为元素的动态数组，而 res 是以数组为元素的数
组，在这一步，当 item 增加完元素后，item 所有元素构成一个完整的子串，
再由 res 纳入
res.add(new ArrayList\&lt;Integer&gt;(item));
dfs(nums, i + 1, item, res);
item.remove(item.size() - 1);
&#125;
&#125;
&#125;
2.  以下结构中，哪个具有同步功能（）
A. HashMap
B. ConcurrentHashMap
C. WeakHashMap
D. TreeMap
答案：B
181
182
分析：
A，C，D 都线程不安全，B 线程安全，具有同步功能
3.  以下结构中，插入性能最高的是（）
A ArrayList
B. Linkedlist
C. tor
D. Collection
答案：B
分析：
数组插入、删除效率差，排除 A
tor 不是 java 里面的数据结构，是一种网络路由技术；因此排除 C
Collection 是集合的接口，不是某种数据结构；因此排除 D
4.  以下结构中，哪个最适合当作 stack 使用（）
A LinkedHashMap
B. LinkedHashSet
C. LinkedList
答案：C
分析：
Stack 是先进后出的线性结构；所以链表比较合适；不需要散列表的数据
结构
183
5.  Map 的实现类中，哪些是有序的，哪些是无序的，有序的是
如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好
或者更高效的实现方式？
答：
6.  Map 的实现类有 HashMap,LinkedHashMap,TreeMap
7.  HashMap 是有无序的，LinkedHashMap 和 TreeMap 都是有序的
（LinkedHashMap记录了添加数据的顺序；TreeMap默认是自然升序）
8.  LinkedHashMap 底层存储结构是哈希表+链表，链表记录了添加数据
的顺序
9.  TreeMap 底层存储结构是二叉树，二叉树的中序遍历保证了数据的有
序性
10. LinkedHashMap 有序性能比较高，因为底层数据存储结构采用的哈希
表
11. 下面的代码在绝大部分时间内都运行得很正常，请问什么情况
下会出现问题？根源在哪里？
package com.bjsxt;
import java.util.LinkedList;
public class Stack &#123;
LinkedList list = new LinkedList();
public synchronized void push(Object x) &#123;
synchronized (list) &#123;
list.addLast(x);
notify();
&#125;
&#125;
public synchronized Object pop() throws Exception&#123;
synchronized(list)&#123;
if(list.size()&lt;=0)&#123;
184
wait();
&#125;
return list.removeLast( );
&#125;
&#125;
&#125;
答：
将 if( list.size() &lt;= 0 )
改成：
while( list.size() &lt;= 0 )
12. TreeMap 和 TreeSet 在排序时如何比较元素？Collections
工具类中的 sort（）方法如何比较元素？
答：
TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提
供了比较元素的 compareTo()方法，当插入元素时会 回调该方法比较元
素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable
接口从而根据键对元素进行排序。Collections 工具类的 sort 方法有两种
重载的形式，第一种要求传入的待排序容器中存放的对象比较实现
Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元
素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的
子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定
义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回
调模式的应用。
185
13. List 里面如何剔除相同的对象？请简单用代码实现一种方法
public class Test &#123;
public static void main(String\[] args) &#123;
List\&lt;String&gt; li1 = new ArrayList\&lt;String&gt;();
li1.add(&quot;8&quot;);
li1.add(&quot;8&quot;);
li1.add(&quot;9&quot;);
li1.add(&quot;9&quot;);
li1.add(&quot;0&quot;);
System.out.println(li1);
//方法:将List中数据取出来来存到Set中
HashSet\&lt;String&gt; set = new HashSet\&lt;String&gt;();
for(int i=0;i\&lt;li1.size();i++)&#123;
set.add(li1.get(i));
&#125;
System.out.println(set);
&#125;
&#125;
14. Java.util.Map 的实现类有
分析：Java 中的 java.util.Map 的实现类
1、HashMap
2、Hashtable
3、LinkedHashMap
4、TreeMap
15. 下列叙述中正确的是（）
A. 循环队列有队头和队尾两个指针，因此，循环队列是非线性结构
B. 在循环队列中，只需要队头指针就能反映队列中元素的动态变化情况
C. 在循环队列中，只需要队尾指针就能反映队列中元素的动态变化情况
D. 在循环队列中元素的个数是由队头指针和队尾指针共同决定的
答案：D
分析：
循环队列中元素的个数是由队首指针和队尾指针共同决定的，元素的动态
变化也是通过队首指针和队尾指针来反映的，当队首等于队尾时，队列为
空。
16. List、Set、Map 是否继承自 Collection 接口？
答：List、Set 的父接口是 Collection，Map 不是其子接口，而是与
Collection 接口是平行关系，互不包含。
Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散
的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的
容器，适用于按数值索引访问元素的情形。
17. 说出 ArrayList、Vector、LinkedList 的存储性能和特性？
答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实
际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是
插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，
Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList
186
差，而 LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过
附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储
方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引
数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即
可，所以插入速度较快。Vector 属于遗留容器（早期的 JDK 中使用的容器，
除此之外 Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留
容器），现在已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非
线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类
Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使
用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创
建新的对象来增加新功能）。
补充：遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，
Properties 是一个键和值都是字符串的特殊的键值对映射，在设计上应该是
关联一个 Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API
中的 Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里
复用代码的方式应该是 HAS-A 关系而不是 IS-A 关系，另一方面容器都属于
工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是
HAS-A 关系（关联）或 USE-A 关系（依赖） 。同理，Stack 类继承 Vector
也是不正确的。
18. List、Map、Set 三个接口，存取元素时，各有什么特点？
答：List 以特定索引来存取元素，可有重复元素。
187
Set 不能存放重复元素（用对象的 equals()方法来区分元素是否重复） 。
Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。
Set 和 Map 容器都有基于哈希存储和排序树（红黑树）的两种实现版本，
基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树版本的实现
在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排
序和去重的效果。
19. TreeMap 和 TreeSet 在排序时如何比较元素？Collections
工具类中的 sort()方法如何比较元素？
答：TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口
提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素
的大小。
TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据
键对元素进行排序。
Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排
序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二种
不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数
是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），
相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的
算法，也是对回调模式的应用。
188
189
例子 1：
Student.java
package com.bjsxt;
public class Student implements Comparable\&lt;Student&gt; &#123;
private String name; // 姓名
private int age; // 年龄
public Student(String name, int age) &#123;
this.name = name;
this.age = age;
&#125;
@Override
public String toString() &#123;
return &quot;Student \[name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
&#125;
@Override
public int compareTo(Student o) &#123;
return this.age - o.age; // 比较年龄(年龄的升序)
&#125;
&#125;
Test01.java
package com.bjsxt;
import java.util.Set;
import java.util.TreeSet;
class Test01 &#123;
public static void main(String\[] args) &#123;
Set\&lt;Student&gt; set = new TreeSet&lt;&gt;(); // Java 7的钻石语
法(构造器后面的尖括号中不需要写类型)
set.add(new Student(&quot;Hao LUO&quot;, 33));
set.add(new Student(&quot;XJ WANG&quot;, 32));
set.add(new Student(&quot;Bruce LEE&quot;, 60));
190
set.add(new Student(&quot;Bob YANG&quot;, 22));
for(Student stu : set) &#123;
System.out.println(stu);
&#125;
// 输出结果:
// Student \[name=Bob YANG, age=22]
// Student \[name=XJ WANG, age=32]
// Student \[name=Hao LUO, age=33]
// Student \[name=Bruce LEE, age=60]
&#125;
&#125;
例子 2：
Student.java
package com.bjsxt;
public class Student &#123;
private String name; // 姓名
private int age; // 年龄
public Student(String name, int age) &#123;
this.name = name;
this.age = age;
&#125;
/\*\**   获取学生姓名
*/
public String getName() &#123;
return name;
&#125;
/*\*
*   获取学生年龄
\*/
public int getAge() &#123;
return age;
&#125;
@Override
191
public String toString() &#123;
return &quot;Student \[name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
&#125;
&#125;
Test02.java
package com.bjsxt;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
class Test02 &#123;
public static void main(String\[] args) &#123;
List\&lt;Student&gt; list = new ArrayList&lt;&gt;(); // Java 7
的钻石语法(构造器后面的尖括号中不需要写类型)
list.add(new Student(&quot;Hao LUO&quot;, 33));
list.add(new Student(&quot;XJ WANG&quot;, 32));
list.add(new Student(&quot;Bruce LEE&quot;, 60));
list.add(new Student(&quot;Bob YANG&quot;, 22));// 通过sort方法的第二个参数传入一个Comparator接口对象
// 相当于是传入一个比较对象大小的算法到sort方法中
// 由于Java中没有函数指针、仿函数、委托这样的概念
// 因此要将一个算法传入一个方法中唯一的选择就是通过接口回
调
Collections.sort(list, new Comparator\&lt;Student&gt; () &#123;
@Override
public int compare(Student o1, Student o2) &#123;
return o1.getName().compareTo(o2.getName());
// 比较学生姓名
&#125;
&#125;);for(Student stu : list) &#123;
192
System.out.println(stu);
&#125;
// 输出结果:
// Student \[name=Bob YANG, age=22]
// Student \[name=Bruce LEE, age=60]
// Student \[name=Hao LUO, age=33]
// Student \[name=XJ WANG, age=32]
&#125;
&#125;
多线程：1.  下面程序的运行结果（）（选择一项）
public static void main(String\[] args) &#123;
Thread t=new Thread()&#123;
public void run()&#123;
pong();
&#125;
&#125;;
t.run();
System.out.println(&quot;ping&quot;);
&#125;
static void pong()&#123;
System.out.println(&quot;pong&quot;);
&#125;
A. pingpong
B. pongping
C. pingpong和pongping都有可能
D. 都不输出
答案：B
分析：启动线程需要调用 start()方法，而 t.run()方法，则是使用对象名.
方法名()并没有启动线程，所以程序从上到下依次执行，先执行 run()中的
静态方法 pong()输出 pong 然执行打印输出 ping
2.  下列哪个方法可用于创建一个可运行的类（）
A. public class X implements Runnable&#123;public void run() &#123;……&#125;&#125;
B. public class X extends Thread&#123;public void run() &#123;……&#125;&#125;
C. public class X extends Thread&#123;public int run() &#123;……&#125;&#125;
D. public class X implements Runnable&#123;protected void run()
&#123;……&#125;&#125;
答案：AB
分析： 继承 Thread 和实现 Runable 接口
3.  说明类 java.lang.ThreadLocal 的作用和原理。列举在哪些
程序中见过 ThreadLocal 的使用？
作用：
要编写一个多线程安全(Thread-safe)的程序是困难的，为了让线程共享资源，
必须小心地对共享资源进行同步，同步带来一定的效能延迟，而另一方面，
在处理同步的时候，又要注意对象的锁定与释放，避免产生死结，种种因素
都使得编写多线程程序变得困难。
尝试从另一个角度来思考多线程共享资源的问题，既然共享资源这么困难，
那么就干脆不要共享，何不为每个线程创造一个资源的复本。将每一个线程
存取数据的行为加以隔离，实现的方法就是给予每个线程一个特定空间来保
193
194
管该线程所独享的资源。
比如：在 Hibernate 中的 Session 就有使用。
ThreadLocal 的原理
ThreadLocal 是如何做到为每一个线程维护变量的副本的呢？其实实现的
思路很简单，在 ThreadLocal 类中有一个 Map，用于存储每一个线程的变
量的副本。
4.  说说乐观锁与悲观锁
答：
悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时
候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这
个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这
种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时
候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此
期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多
读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于
write\_condition 机制的其实都是提供的乐观锁。
两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较
少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大
了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行 retry，
这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。
195
5.  在 Java 中怎么实现多线程?描述线程状态的变化过程。
答：当多个线程访问同一个数据时，容易出现线程安全问题，需要某种方式
来确保资源在某一时刻只被一个线程使用。需要让线程同步，保证数据安全
线程同步的实现方案：同步代码块和同步方法，均需要使用 synchronized
关键字
同步代码块：public void makeWithdrawal(int amt) &#123;
synchronized (acct) &#123; &#125;
&#125;
同步方法：public synchronized void makeWithdrawal(int amt) &#123; &#125;
线程同步的好处：解决了线程安全问题
线程同步的缺点：性能下降，可能会带来死锁
6.  请写出多线程代码使用 Thread 或者 Runnable，并说出两种
的区别。
方式 1：继承 Java.lang.Thread 类，并覆盖 run() 方法。优势：编写简单；
劣势：无法继承其它父类
public class ThreadDemo1 &#123;
public static void main(String args\[]) &#123;
MyThread1 t = new MyThread1();
t.start();
while (true) &#123;
System.out.println(&quot;兔子领先了，别骄傲&quot;);
196
&#125;
&#125;
&#125;
class MyThread1 extends Thread &#123;
public void run() &#123;
while (true) &#123;
System.out.println(&quot;乌龟领先了，加油&quot;);
&#125;
&#125;
&#125;
方式 2：实现 Java.lang.Runnable 接口，并实现 run()方法。优势：可继承其
它类，多线程可共享同一个 Thread 对象；劣势：编程方式稍微复杂，如需访
问当前线程，需调用 Thread.currentThread()方法
public class ThreadDemo2 &#123;
public static void main(String args\[]) &#123;
MyThread2 mt = new MyThread2();
Thread t = new Thread(mt);
t.start();
while (true) &#123;
System.out.println(&quot;兔子领先了，加油&quot;);
197
&#125;
&#125;
&#125;
class MyThread2 implements Runnable &#123;
public void run() &#123;
while (true) &#123;
System.out.println(&quot;乌龟超过了，再接再厉&quot;);
&#125;
&#125;
&#125;
7.  在多线程编程里，wait 方法的调用方式是怎样的？
答:
wait 方法是线程通信的方法之一，必须用在 synchronized 方法或者
synchronized 代码块中，否则会抛出异常，这就涉及到一个“锁”的概念，
而 wait 方法必须使用上锁的对象来调用，从而持有该对象的锁进入线程等
待状态，直到使用该上锁的对象调用 notify 或者 notifyAll 方法来唤醒之前
进入等待的线程，以释放持有的锁。
8.  Java 线程的几种状态
答:
线程是一个动态执行的过程，它有一个从产生到死亡的过程，共五种状态：
新建（new Thread）
当创建 Thread 类的一个实例（对象）时，此线程进入新建状态（未被启动）
例如：Thread t1=new Thread();
就绪（runnable）
线程已经被启动，正在等待被分配给 CPU 时间片，也就是说此时线程正在
就绪队列中排队等候得到 CPU 资源。例如：t1.start();
运行（running）
线程获得 CPU 资源正在执行任务（run()方法），此时除非此线程自动放弃
CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。
死亡（dead）
当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能
再进入就绪状态等待执行。
自然终止：正常运行 run()方法后终止
异常终止：调用 stop()方法让一个线程终止运行
堵塞（blocked）
由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵
塞状态。
正在睡眠：用 sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线
程在指定的时间过去可进入就绪状态。
正在等待：调用 wait()方法。（调用 motify()方法回到就绪状态）
被另一个线程所阻塞：调用 suspend()方法。（调用 resume()方法恢复）
198
199
9.  在 Java 多线程中，请用下面哪种方式不会使线程进入阻塞状
态（）
A sleep()
B. Suspend()
C. wait()
D. yield()
答案：D
分析：
yield 会是线程进入就绪状态
10. volatile 关键字是否能保证线程安全？
答:
不能。虽然 volatile 提供了同步的机制，但是知识一种弱的同步机制，如需
要强线程安全，还需要使用 synchronized。
Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量
的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器与运行时
都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起
重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因
此在读取 volatile 类型的变量时总会返回最新写入的值。
一、volatile 的内存语义是：
当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量
值立即刷新到主内存中。
当读一个 volatile 变量时，JMM 会把该线程对应的本地内存设置为无效，
直接从主内存中读取共享变量。
二、volatile 底层的实现机制
如果把加入 volatile 关键字的代码和未加入 volatile 关键字的代码都生成汇
编代码，会发现加入 volatile 关键字的代码会多出一个 lock 前缀指令。
1 、重排序时不能把后面的指令重排序到内存屏障之前的位置
2、使得本 CPU 的 Cache 写入内存
3、写入动作也会引起别的 CPU 或者别的内核无效化其 Cache，相当于让
新写入的值对别的线程可见。
11. 请写出常用的 Java 多线程启动方式，Executors 线程池有几
种常用类型？
(1) 继承 Thread 类
public class java\_thread extends Thread&#123;
public static void main(String args\[]) &#123;
new java\_thread().run();
System.out.println(&quot;main thread run &quot;);
&#125;
public synchronized void run() &#123;
System.out.println(&quot;sub thread run &quot;);
&#125;
&#125;
200
201
(2) 实现 Runnable 接口
public class java\_thread implements Runnable&#123;
public static void main(String args\[]) &#123;
new Thread(new java\_thread()).start();
System.out.println(&quot;main thread run &quot;);
&#125;
public void run() &#123;
System.out.println(&quot;sub thread run &quot;);
&#125;
&#125;
在 Executor 框架下，利用 Executors 的静态方法可以创建三种类型的常用线程
池：
1）FixedThreadPool 这个线程池可以创建固定线程数的线程池。
2）SingleThreadExecutor 是使用单个 worker 线程的 Executor。
3）CachedThreadPool 是一个”无限“容量的线程池，它会根据需要创建
新线程。
12. 关于 sleep()和 wait()，以下描述错误的一项是（）
A. sleep 是线程类（Thread）的方法，wait 是 Object 类的方法
B. Sleep 不释放对象锁，wait 放弃对象锁
202
C. Sleep 暂停线程、但监控状态任然保持，结束后会自动恢复
D. Wait 后进入等待锁定池，只针对此对象发出 notify 方法后获取对象
锁进入运行状态。
答案：D
分析：
针对此对象的 notify 方法后获取对象锁并进入就绪状态，而不是运行状态。
另外针对此对象的 notifyAll 方法后也可能获取对象锁并进入就绪状态，而
不是运行状态
13. 进程和线程的区别是什么？
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程
是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能
独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中
必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程
的其他的线程共享进程所拥有的全部资源.
区别 进程 线程
根本区别 作为资源分配的单位 调度和执行的单位
开销 每个进程都有独立的代
码和数据空间(进程上下
文)，进程间的切换会有
线程可以看成时轻量级的进程，同
一类线程共享代码和数据空间，每
个线程有独立的运行栈和程序计
203
较大的开销。 数器(PC)，线程切换的开销小。
所处环境 在操作系统中能同时运
行多个任务(程序)
在同一应用程序中有多个顺序流
同时执行
分配内存 系统在运行的时候会为
每个进程分配不同的内
存区域
除了 CPU 之外，不会为线程分配
内存（线程所使用的资源是它所属
的进程的资源），线程组只能共享
资源
包含关系 没有线程的进程是可以
被看作单线程的，如果
一个进程内拥有多个线
程，则执行过程不是一
条线的，而是多条线（线
程）共同完成的。
线程是进程的一部分，所以线程有
的时候被称为是轻权进程或者轻
量级进程。
14. 以下锁机机制中，不能保证线程安全的是（）
A. Lock
B. Synchronized
C. Volatile
答案：C
204
15. 创建 n 多个线程，如何保证这些线程同时启动？看清，是“同
时”。
答：用一个 for 循环创建线程对象，同时调用 wait()方法，让所有线程
等待；直到最后一个线程也准备就绪后，调用 notifyAll(), 同时启动所有线
程。
比如：给你 n 个赛车，让他们都在起跑线上就绪后，同时出发，Java
多线程如何写代码？
思路是，来一辆赛车就加上一把锁，并修改对应的操作数，如果没有全
部就绪就等待，并释放锁，直到最后一辆赛车到场后唤醒所有的赛车线程。
代码参考如下：
public class CarCompetion &#123;
// 参赛赛车的数量
protected final int totalCarNum = 10;
// 当前在起跑线的赛车数量
protected int nowCarNum = 0;
&#125;
public class Car implements Runnable&#123;
private int carNum;
private CarCompetion competion = null;
public Car(int carNum, CarCompetion competion) &#123;
this.carNum = carNum;
this.competion = competion;
&#125;
@Override
public void run() &#123;
synchronized (competion) &#123;
competion.nowCarNum++;
while (competion.nowCarNum &lt;
competion.totalCarNum) &#123;
try &#123;
competion.wait();
205
&#125; catch (InterruptedException e) &#123;
e.printStackTrace();
&#125;
&#125;
competion.notifyAll();
&#125;
startCar();
&#125;
private void startCar() &#123;
System.out.println(&quot;Car num &quot; + this.carNum + &quot; start
to run.&quot;);
try &#123;
Thread.sleep(3000);
&#125; catch (InterruptedException e) &#123;
e.printStackTrace();
&#125;
System.out.println(&quot;Car num &quot; + this.carNum + &quot; get
to the finish line.&quot;);
&#125;
&#125;
public static void main(String\[] args) &#123;
CarCompetion carCompetion = new CarCompetion();
final ExecutorService carPool =Executors.newFixedThreadPool(carCompetion.totalCarNum);
for (int i = 0; i &lt; carCompetion.totalCarNum; i++) &#123;
carPool.execute(new Car(i, carCompetion));
&#125;1.  同步和异步有何异同，在什么情况下分别使用它们？
答：
1.如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，
或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数
据，必须进行同步存取。
206
2.当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不
希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异
步途径往往更有效率。
3.举个例子: 打电话是同步 发消息是异步
2.  Java 线程中，sleep()和 wait()区别
答：
sleep 是线程类(Thread)的方法；作用是导致此线程暂停执行指定时间，给
执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复；调用
sleep()不会释放对象锁。
wait 是 Object 类的方法；对此对象调用 wait 方法导致本线程放弃对象锁，
进入等 待此对象的等待锁定池。只有针对此对象发出 notify 方法(或
notifyAll)后本线程才进入对象锁定池，准备获得对象锁进行运行状态。
3.  下面所述步骤中，是创建进程做必须的步骤是（）
A 由调度程序为进程分配 CPU
B. 建立一个进程控制块
C. 为进程分配内存
D. 为进程分配文件描述符
答案：BC
4.  无锁化编程有哪些常见方法？（）
A 针对计数器，可以使用原子加
207
B.
只有一个生产者和一个消费者，那么就可以做到免锁访问环形缓冲区
（Ring Buffer）
C. RCU（Read-Copy-Update），新旧副本切换机制，对于旧副本可以
采用延迟释放的做法
D. CAS（Compare-and-Swap），如无锁栈，无锁队列等待
答案：D
分析：
A 这方法虽然不太好，但是常见
B ProducerConsumerQueue就是这个，到处都是
C linux kernel里面大量使用
D 本质上其实就是乐观锁，操作起来很困难。。单生产者多消费者或者多
生产者单消费者的情况下比较常见，也不容易遇到 ABA 问题。
5.  sleep()和 yield()有什么区别?
答：
① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优
先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线
程以运行的机会；
② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法
后转入就绪（ready）状态；
③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任
何异常；
④ sleep()方法比 yield()方法（跟操作系统相关）具有更好的可移植性。
208
6.  当一个线程进入一个对象的 synchronized 方法 A 之后，其
它线程是否可进入此对象的 synchronized 方法？
答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。
只有等待当前线程执行完毕释放锁资源之后，其他线程才有可能进行执行该
同步方法！
延伸 对象锁分为三种：共享资源、this、当前类的字节码文件对象
7.  请说出与线程同步相关的方法。
答：
8.  wait():使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
9.  sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此
方法要捕捉 InterruptedException 异常；
10. notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不
能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而
且与优先级无关；
11. notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一
个对象的锁，而是让它们竞争；
12. JDK 1.5 通过 Lock 接口提供了显式(explicit)的锁机制，增强了灵活性以
及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁(unlock())的方
法，同时还提供了 newCondition()方法来产生用于线程之间通信的
Condition 对象；
13. JDK 1.5 还提供了信号量(semaphore)机制，信号量可以用来限制对某个
209
共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信
号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的
访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release()
方法）。
下面的例子演示了 100 个线程同时向一个银行账户中存入 1 元钱，在没有
使用同步机制和使用同步机制情况下的执行情况。
银行账户类：
 
在没有同步的情况下，执行结果通常是显示账户余额在 10 元以下，出现这种状
况的原因是，当一个线程 A 试图存入 1 元的时候，另外一个线程 B 也能够进入
存款的方法中，线程 B 读取到的账户余额仍然是线程 A 存入 1 元钱之前的账户
余额，因此也是在原来的余额 0 上面做了加 1 元的操作，同理线程 C 也会做类
似的事情，所以最后 100 个线程执行结束时，本来期望账户余额为 100 元，但
实际得到的通常在 10 元以下。解决这个问题的办法就是同步，当一个线程对银
行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，
代码有如下几种调整方案：1.  在银行账户的存款（deposit）方法上同步（synchronized）关键字
 
 1.  通过 JDK 1.5 显示的锁机制，为每个银行账户创建一个锁对象，在存款
操作进行加锁和解锁的操作
按照上述三种方式对代码进行修改后，重写执行测试代码 Test01，将看到
最终的账户余额为 100 元。1.  编写多线程程序有几种实现方式？
答：Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一
种是实现 Runnable 接口。两种方式都要通过重写 run()方法来定义线程的
行为，推荐使用后者，因为 Java 中的继承是单继承，一个类有一个父类，
215
如果继承了 Thread 类就无法再继承其他类了，同时也可以实现资源共享，
显然使用 Runnable 接口更为灵活。
补充：Java 5 以后创建线程还有第三种方式：实现 Callable 接口，该接口中
的 call 方法可以在线程执行结束时产生一个返回值，代码如下所示：
IO 流：
12. 下面哪个流类属于面向字符的输入流（）选择一项）
A. BufferedWriter
B. FileInputStream
C. ObjectInputStream
D. InputStreamReader
答案：D
分析：A：字符输出的缓冲流
227
B：字节输入流
C：对象输入流
13. 要从文件”file.dat”文件中读出第 10 个字节到变量 c 中，
下列哪个正确（）（选择一项）
A. FileInputStream in=new FileInputStream(&quot;file.dat&quot;);
in.skip(9);
int c=in.read();
B. FileInputStream in=new FileInputStream(&quot;file.dat&quot;);
in.skip(10);
int c=in.read();
C. FileInputStream in=new FileInputStream(&quot;file.dat&quot;);
int c=in.read();
D. RandomAccessFile in=new RandomAccessFile(&quot;file.dat&quot;);
in.skip(7);
int c=in.readByte();
答案：A
分析： skip(long n)该方法中的 n 指的是要跳过的字节数
14. 新建一个流对象，下面那个选项的代码是错误的？（）
A. new BufferedWriter(new FileWriter(“a.txt”));
B. new BufferedReader (new FileInputStream(“a.dat”));
C. new GZIPOutputStream(new FileOutputStream(“a.zip”));
228
D. new ObjectInputStream(new FileInputStream(“a.dat”));
答案：B
分析：
BufferedReader 类的参数只能是 Reader 类型的，不能是 InputStream 类型。
15. 下面哪个流是面向字符的输入流（）
A BufferedWriter
B. FileInputStream
C. ObjectInputStream
D. InputStreamReader
答案：D
分析：
以 InputStream（输入流）/OutputStream（输出流）为后缀的是字节流；
以 Reader（输入流）/Writer（输出流）为后缀的是字符流。
16. Java 类库中，将信息写入内存的类是（）
A Java.io.FileOutputStream
B. java.ByteArrayOutputStream
C. java.io.BufferedOutputStream
D. java,.io.DataOutputStream
答案：B
分析： ACD都是io到文件
229
17. 请写出一段代码，能够完成将字符串写入文件
public class test &#123;
public static void main(String\[] args) &#123;
String str = &quot;bjsxt&quot;;
writeFile(str);
&#125;
public static void writeFile(String str) &#123;
File file = new File(&quot;c:/test.txt&quot;);
PrintStream ps = null;
try &#123;
OutputStream fos = new FileOutputStream(file);
ps = new PrintStream(fos);
ps.print(str);
&#125; catch (FileNotFoundException e) &#123;
e.printStackTrace();
&#125; finally &#123;
ps.close();
&#125;
&#125;
&#125;
18. 下面哪个流类属于面向字符的输入流（）
A. BufferedWriter
B. FileInputStream
C. ObjectInputStream
D. InputStreamReader
答案：D
19. Java 中如何实现序列化，有什么意义？
答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内
容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输
于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不
进行序列化可能会存在数据乱序的问题）。
要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性
接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象
输出流并通过 writeObject(Object obj)方法就可以将实现对象写出(即保存
其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过
readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，
还能够用于对象的深度克隆（参见 Java 面试题集 1-29 题）
20. Java 中有几种类型的流？
答：两种流分别是字节流，字符流。
字节流继承于 InputStream、OutputStream，字符流继承于 Reader、
Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方
便。
补充：关于 Java 的 IO 需要注意的有两点：一是两种对称性（输入和输出的
对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模
式）。另外 Java 中的流不同于 C#的是它只有一个维度一个方向。
补充：下面用 IO 和 NIO 两种方式实现文件拷贝，这个题目在面试的时候是
经常被问到的。
 
注意：上面用到 Java 7 的 TWR，使用 TWR 后可以不用在 finally 中释放外
部资源 ，从而让代码更加优雅。1.  写一个方法，输入一个文件名和一个字符串，统计这个字符串
在这个文件中出现的次数。
答：代码如下：
package com.bjsxt;
import java.io.BufferedReader;
import java.io.FileReader;public class Account &#123;
// 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象
(绝对好习惯)
1.  输入流和输出流联系和区别，节点流和处理流联系和区别
首先，你要明白什么是“流”。直观地讲，流就像管道一样，在程序和
文件之间，输入输出的方向是针对程序而言，向程序中读入东西，就是输入
流，从程序中向外读东西，就是输出流。
输入流是得到数据，输出流是输出数据，而节点流，处理流是流的另一
种划分，按照功能不同进行的划分。节点流，可以从或向一个特定的地方(节
点)读写数据。处理流是对一个已存在的流的连接和封装，通过所封装的流的
功能调用实现数据读写。如 BufferedReader。处理流的构造方法总是要带
一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链
接。
2.  字符流字节流联系区别；什么时候使用字节流和字符流?
字符流和字节流是流的一种划分，按处理照流的数据单位进行的划分。
两类都分为输入和输出操作。在字节流中输出数据主要是使用
OutputStream 完成，输入使的是 InputStream，在字符流中输出主要是使
234
用 Writer 类完成，输入流主要使用 Reader 类完成。这四个都是抽象类。
字符流处理的单元为 2 个字节的 Unicode 字符，分别操作字符、字符
数组或字符串，而字节流处理单元为 1 个字节，操作字节和字节数组。字节
流是最基本的，所有的 InputStrem 和 OutputStream 的子类都是,主要用在
处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提
出了字符流的概念，它是按虚拟机的编码来处理，也就是要进行字符集的转
化 这两个之间通过 InputStreamReader,OutputStreamWriter 来关联，
实际上是通过 byte\[]和 String 来关联的。
3.  列举常用字节输入流和输出流并说明其特点，至少 5 对。
答：
FileInputStream 从文件系统中的某个文件中获得输入字节。
FileOutputStream 从程序当中的数据，写入到指定文件。
ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本
数据和对象进行反序列化。ObjectOutputStream 和 ObjectInputStream
分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用
程序提供对对象图形的持久存储。ObjectInputStream 用于恢复那些以前
序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于
编组和解组远程通信系统中的实参和形参。
ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读
取的字节。内部计数器跟踪 read 方法要提供的下一个字节。
FilterInputStream 包含其他一些输入流，它将这些流用作其基本数据
源，它可以直接传输数据或提供一些额外的功能。FilterInputStream 类本
身只是简单地重写那些将所有请求传递给所包含输入流的 InputStream
的所有方法。FilterInputStream 的子类可进一步重写这些方法中的一些方
法，并且还可以提供一些额外的方法和字段。
StringBufferInputStream 此类允许应用程序创建输入流，在该流中读
取的字节由字符串内容提供。应用程序还可以使用 ByteArrayInputStream
从 byte 数组中读取字节。 只有字符串中每个字符的低八位可以由此类使
用。
ByteArrayOutputStream 此类实现了一个输出流，其中的数据被写入
一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用
toByteArray() 和 toString() 获取数据。
FileOutputStream 文件输出流是用于将数据写入 File 或
FileDescriptor 的输出流。文件是否可用或能否可以被创建取决于基础平台。
特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）
打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中
的构造方法将失败。
FilterOutputStream 类是过滤输出流的所有类的超类。这些流位于已
存在的输出流（基础 输出流）之上，它们将已存在的输出流作为其基本数
据接收器，但可能直接传输数据或提供一些额外的功能。
FilterOutputStream 类本身只是简单地重写那些将所有请求传递给所包含
输出流的 OutputStream 的所有方法。FilterOutputStream 的子类可进
235
236
一步地重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。
ObjectOutputStream 将 Java 对象的基本数据类型和图形写入
OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过
在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以
在另一台主机上或另一个进程中重构对象。
PipedOutputStream 可以将管道输出流连接到管道输入流来创建通信
管道。管道输出流是管道的发送端。通常，数据由某个线程写入
PipedOutputStream 对象，并由其他线程从连接的 PipedInputStream
读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程
死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再
处于活动状态，则该管道被视为处于毁坏状态。
4.  说明缓冲流的优点和原理
不带缓冲的流的工作原理：
它读取到一个字节/字符，就向用户指定的路径写出去，读一个写一个，
所以就慢了。
带缓冲的流的工作原理：
读取到一个字节/字符，先不输出，等凑足了缓冲的最大容量后一次性
写出去，从而提高了工作效率
优点：减少对硬盘的读取次数，降低对硬盘的损耗。
5.  序列化的定义、实现和注意事项
想把一个对象写在硬盘上或者网络上，对其进行序列化，把他序列化成为一
237
个字节流。
实现和注意事项：
1）实现接口 Serializable Serializable 接口中没有任何的方法，实现该
接口的类不需要实现额外的方法。
2）如果对象中的某个属性是对象类型，必须也实现 Serializable 接口才
可以，序列化对静态变量无效
3）如果不希望某个属性参与序列化，不是将其 static，而是 transient
串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存
序列化版本不兼容
6.  使用 IO 流完成文件夹复制
（结合递归）
  
2.  IP 地址和端口号
1）IP 地址
用来标志网络中的一个通信实体的地址。通信实体可以是计算机，路由器等。
2）IP 地址分类
IPV4：32 位地址，以点分十进制表示，如 192.168.0.1
IPV6：128 位（16 个字节）写成 8 个 16 位的无符号整数，每个整数用
四个十六进制位表示，数之间用冒号（：）分开，如：
241
3ffe:3201:1401:1280\:c8ff\:fe4d\:db39:1984
3）特殊的 IP 地址
127.0.0.1 本机地址
192.168.0.0--192.168.255.255 私有地址，属于非注册地址，专门为组
织机构内部使用。
4）端口\:port
IP 地址用来标志一台计算机，但是一台计算机上可能提供多种应用程序，
使用端口来区分这些应用程序。 端口是虚拟的概念，并不是说在主机上
真的有若干个端口。通过端口，可以在一个主机上运行多个网络应用程
序。 端口范围 0---65535,16 位整数
5）端口分类
公认端口 0—1023 比如80端口分配给WWW，21端口分配给FTP，
22 端口分配给 SSH,23 端口分配给 telnet，25 端口分配给 smtp
注册端口 1024—49151 分配给用户进程或应用程序
动态/私有端口 49152--65535
6）理解 IP 和端口的关系
IP 地址好比每个人的地址（门牌号），端口好比是房间号。必须同时指定
IP 地址和端口号才能够正确的发送数据
IP 地址好比为电话号码，而端口号就好比为分机号。
242
3.  介绍 OSI 七层模型和 TCP/IP 模型
OSI(Open System Interconnection)，开放式系统互联参考模型 。是
一个逻辑上的定义，一个规范，它把网络协议从逻辑上分为了 7 层。每一层
都有相关、相对应的物理设备，比如常规的路由器是三层交换设备，常规的
交换机是二层交换设备。OSI 七层模型是一种框架性的设计方法，建立七层
模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的
功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口
和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系
统不同的网络之间实现可靠的通讯。
TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，
主要由网络层的 IP 协议和传输层的 TCP 协议组成。TCP/IP 定义了电子设
备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了 4 层
的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。
ISO 制定的 OSI 参考模型的过于庞大、复杂招致了许多批评。伴随着互
联网的流行，其本身所采用的 TCP/IP 协议栈获得了更为广泛的应用和认可。
在 TCP/IP 参考模型中，去掉了 OSI 参考模型中的会话层和表示层（这两层
的功能被合并到应用层实现）。同时将 OSI 参考模型中的数据链路层和物理
层合并为主机到网络层。
243
4.  TCP 协议和 UDP 协议的比较
TCP 和 UDP 是 TCP/IP 协议栈中传输层的两个协议，它们使用 IP 路由功能
把数据包发送到目的地，从而为应用程序及应用层协议（包括：HTTP、SMTP、
SNMP、FTP 和 Telnet）提供网络服务。
TCP 的 server 和 client 之间通信就好比两个人打电话，需要互相知道
对方的电话号码，然后开始对话。所以在两者的连接过程中间需要指定端口
和地址。
UDP 的 server 和 client 之间的通信就像两个人互相发信。我只需要知
道对方的地址，然后就发信过去。对方是否收到我不知道，也不需要专门对
口令似的来建立连接。具体区别如下：
1）TCP 是面向连接的传输。UDP 是无连接的传输
2）TCP 有流量控制、拥塞控制，检验数据数据按序到达，而 UDP 则相
反。
3）TCP 的路由选择只发生在建立连接的时候，而 UDP 的每个报文都要
244
245
进行路由选择
4）TCP 是可靠性传输，他的可靠性是由超时重发机制实现的，而 UDP
则是不可靠传输
5）UDP 因为少了很多控制信息，所以传输速度比 TCP 速度快
6）TCP 适合用于传输大量数据，UDP 适合用于传输小量数据
5.  什么是 Socket 编程
Socket 编程的定义如下：
所谓 socket 通常也称作&quot;套接字&quot;，用于描述 IP 地址和端口，是一个通
信链的句柄。应用程序通常通过&quot;套接字&quot;向网络发出请求或者应答网络请求。
我们开发的网络应用程序位于应用层，TCP 和 UDP 属于传输层协议，
在应用层如何使用传输层的服务呢？在应用层和传输层之间，则是使用套接
字来进行分离。
套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向
远程发送数据，或者接收远程发来的数据；而这个小口以内，也就是数据进
入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也
不会关心它如何传输，这属于网络其它层次的工作。
Socket 实际是传输层供给应用层的编程接口。传输层则在网络层的基
础上提供进程到进程问的逻辑通道，而应用层的进程则利用传输层向另一台
主机的某一进程通信。Socket 就是应用层与传输层之间的桥梁
使用 Socket 编程可以开发客户机和服务器应用程序，可以在本地网络
上进行通信，也可通过 Internet 在全球范围内通信。
生活案例 1 如果你想写封邮件发给远方的朋友，如何写信、将信打包，
属于应用层。信怎么写，怎么打包完全由我们做主；而当我们将信投入邮筒
时，邮筒的那个口就是套接字，在进入套接字之后，就是传输层、网络层等
（邮局、公路交管或者航线等）其它层次的工作了。我们从来不会去关心信
是如何从西安发往北京的，我们只知道写好了投入邮筒就 OK 了。
生活案例 2：可以把 Socket 比作是一个港口码头，应用程序只要将数
据交给 Socket，就算完成了数据的发送，具体细节由 Socket 来完成，细节
不必了解。同理，对于接收方，应用程序也要创建一个码头，等待数据的到
达，并获取数据。
6.  简述基于 TCP 和 UDP 的 Socket 编程的主要步骤
Java 分别为 TCP 和 UDP 两种通信协议提供了相应的 Socket 编程类，
这些类存放在 java.net 包中。与 TCP 对应的是服务器的 ServerSocket 和客
246
247
户端的 Socket，与 UDP 对应的是 DatagramSocket。
基于 TCP 创建的套接字可以叫做流套接字，服务器端相当于一个监听器，
用来监听端口。服务器与客服端之间的通讯都是输入输出流来实现的。基于
UDP 的套接字就是数据报套接字，• 两个都要先构造好相应的数据包。
基于 TCP 协议的 Socket 编程的主要步骤
服务器端（server）：
7.  构建一个 ServerSocket 实例，指定本地的端口。这个 socket 就是
用来监听指定端口的连接请求的。
8.  重复如下几个步骤：
a. 调用 socket 的 accept()方法来获得下面客户端的连接请求。通过
accept()方法返回的 socket 实例，建立了一个和客户端的新连接。
b. 通过这个返回的 socket 实例获取 InputStream 和
OutputStream,可以通过这两个 stream 来分别读和写数据。
c. 结束的时候调用 socket 实例的 close()方法关闭 socket 连接。
客户端（client）：
1.构建 Socket 实例，通过指定的远程服务器地址和端口来建立连接。
2.通过 Socket 实例包含的 InputStream 和 OutputStream 来进行
数据的读写。
3.操作结束后调用 socket 实例的 close 方法，关闭。
UDP
服务器端（server）：
9.  构造 DatagramSocket 实例，指定本地端口。
10. 通过 DatagramSocket 实例的 receive 方法接收
DatagramPacket.DatagramPacket 中间就包含了通信的内容。
11. 通过 DatagramSocket 的 send 和 receive 方法来收和发
DatagramPacket.
客户端（client）：
12. 构造 DatagramSocket 实例。
13. 通过 DatagramSocket 实例的 send 和 receive 方法发送
DatagramPacket 报文。
14. 结束后，调用 DatagramSocket 的 close 方法关闭。
248
异常处理：
15. 下列哪种异常是检查型异常，需要在编写程序时声明（）
A. NullPointerException
B. ClassCastException
C. FileNotFoundException
D. IndexOutOfBoundsException
答案：C
分析：NullPointerException 空指针异常
ClassCastException 类型转换异常
IndexOutOfBoundsException 索引超出边界的异常
以上这些异常都是程序在运行时发生的异常，所以不需要在编写程序时声
明
16. Java 出现 OutOf MemoryError（OOM 错误)的原因有哪
些？出现 OOM 错误后，怎么解决？
答:
OutOf MemoryError 这种错误可以细分为多种不同的错误，每种错误都有
自身的原因和解决办法，如下所示：
java.lang.OutOfMemoryError: Java heap space
错误原因：此 OOM 是由于 JVM 中 heap 的最大值不满足需要。
解决方法：1) 调高 heap 的最大值，即-Xmx 的值调大。2) 如果你的程序
存在内存泄漏，一味的增加 heap 空间也只是推迟该错误出现的时间而已，
249
250
所以要检查程序是否存在内存泄漏。
java.lang.OutOfMemoryError: GC overhead limit exceeded
错误原因：此 OOM 是由于 JVM 在 GC 时，对象过多，导致内存溢出，建
议调整 GC 的策略，在一定比例下开始 GC 而不要使用默认的策略，或者将
新代和老代设置合适的大小，需要进行微调存活率。
解决方法：改变 GC 策略，在老代 80%时就是开始 GC，并且将
\-XX\:SurvivorRatio（-XX\:SurvivorRatio=8）和-XX\:NewRatio
（-XX\:NewRatio=4）设置的更合理。
java.lang.OutOfMemoryError: Java perm space
错误原因：此 OOM 是由于 JVM 中 perm 的最大值不满足需要。
解决方法：调高 heap 的最大值，即-XX\:MaxPermSize 的值调大。
另外，注意一点，Perm 一般是在 JVM 启动时加载类进来，如果是 JVM 运
行较长一段时间而不是刚启动后溢出的话，很有可能是由于运行时有类被动
态加载进来，此时建议用 CMS 策略中的类卸载配置。如：
\-XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled。
java.lang.OutOfMemoryError: unable to create new native thread
错误原因：当 JVM 向 OS 请求创建一个新线程时，而 OS 却由于内存不足无
法创建新的 native 线程。
解决方法：如果 JVM 内存调的过大或者可利用率小于 20%，可以建议将
heap及perm的最大值下调，并将线程栈调小，即-Xss调小，如：-Xss128k。
java.lang.OutOfMemoryError: Requested array size exceeds VM limit
错误原因：此类信息表明应用程序（或者被应用程序调用的 APIs）试图分配
一个大于堆大小的数组。例如，如果应用程序 new 一个数组对象，大小为
512M，但是最大堆大小为 256M，因此 OutOfMemoryError 会抛出，因
为数组的大小超过虚拟机的限制。
解决方法：1) 首先检查 heap 的-Xmx 是不是设置的过小。2) 如果 heap
的-Xmx 已经足够大，那么请检查应用程序是不是存在 bug，例如：应用程
序可能在计算数组的大小时，存在算法错误，导致数组的 size 很大，从而导
致巨大的数组被分配。
java.lang.OutOfMemoryError: request \&lt;size&gt; bytes for \&lt;reason&gt;.
Out of swap space
错误原因：抛出这类错误，是由于从 native 堆中分配内存失败，并且堆内
存可能接近耗尽。这类错误可能跟应用程序没有关系，例如下面两种原因也
会导致错误的发生：1) 操作系统配置了较小的交换区。2)系统的另外一个
进程正在消耗所有的内存。
解决办法：1) 检查 os 的 swap 是不是没有设置或者设置的过小。2) 检查
是否有其他进程在消耗大量的内存，从而导致当前的 JVM 内存不够分配。
注意：虽然有时\&lt;reason&gt;部分显示导致 OOM 的原因，但大多数情况下， \&lt;reason&gt;显示的是提示分配失败的源模块的名称，所以有必要查看日志文
件，如 crash 时的 hs 文件。
17. 列举常见的运行时异常
答:
251
ClassCastException(类转换异常)
比如 Object obj=new Object(); String s=(String)obj;
IndexOutOfBoundsException(下标越界异常)
NullPointerException(空指针异常)
ArrayStoreException(数据存储异常，操作数组时类型不一致)
BufferOverflowException(IO 操作时出现的缓冲区上溢异常)
InputMismatchException(输入类型不匹配异常)
ArithmeticException(算术异常)
注意：运行时异常都是 RuntimeException 子类异常。
18. 下面关于 Java.lang.Exception 类的说法正确的是（）
A. 继承自 Throwable
B. 不支持 Serializable
C. 继承自 AbstractSet
D. 继承自 FitelnputStream
答案：A
分析：
Throwable 是 Exception 和 Error 的父类，Exception 虽然没有实现
Serializable 接口，但是其父类 Throwable 已经实现了该接口，因此
Exception 也支持 Serializable。
252
19. Unsupported major.minor version 52 是什么异常，怎么
造成的，如何解决？
答：问题的根本原因是工程中某个 jar 包的版本（jar 包编译时的所用的 jdk
版本）高于工程 build path 中 jdk 的版本，这个是不兼容的! 编程中遇到此
异常 Unsupported major.minor version 52.0（根据版本号，这里可以为
其他数值，52 是 1.8jdk jar 包与 1.8 以下低版本 jdk 不匹配），在将 build
path 中 jdk 的版本调整与 jar 包匹配后，解决异常。
20. try&#123;&#125;里有一个 return 语句，那么紧跟在这个 try 后的 finally&#123;&#125;
里的 code 会不会被执行，什么时候被执行，在 return 前还是后?
答：会执行，在方法返回调用者前执行。Java 允许在 finally 中改变返回值
的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立
马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用
者返回其值，然后如果在 finally 中修改了返回值，这会对程序造成很大的
困扰，C#中就从语法上规定不能做这样的事。
(也许你的答案是在 return 之前，但往更细地说，我的答案是在 return 中间
执行，请看下面程序代码的运行结果：
   
1
运行结果是 1，为什么呢？主函数调用子函数并得到结果的过程，好比主函
数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再
将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函
数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。1.  Java 语言如何进行异常处理，关键字：throws、throw、try、
catch、finally 分别如何使用？
答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，
并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable
类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中
包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。
Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws
254
和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛
出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，
或最后（finally）由缺省处理器来处理；try 用来指定一块预防所有“异常”
的程序；catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的
类型；throw 语句用来明确地抛出一个“异常”；throws 用来标明一个成
员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么
“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个 try 语
句，在这个成员函数内部写另一个 try 语句保护其他代码。每当遇到一个 try
语句，“异常”的框架就放到栈上面，直到所有的 try 语句都完成。如果下
一级的 try 语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处
理这种“异常”的 try 语句。
2.  运行时异常与受检异常有何异同？
答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟
机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没
有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序
设计无误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛
出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。
异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective
Java》中对异常的使用给出了以下指导原则：
• 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调
用者为了正常的控制流而使用异常）
255
256
• 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
• 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常发生）
• 优先使用标准的异常
• 每个方法抛出的异常都要有文档
• 保持异常的原子性
• 不要在 catch 中忽略掉捕获到的异常
(异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的
通常操作中可能遇到的异常，是一种常见运行错误。java 编译器要求方法必
须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获
的运行时异常。)
3.  类 ExampleA 继承 Exception，类 ExampleB 继承
ExampleA
有如下代码片断：
try&#123;
throw new ExampleB(&quot;b&quot;)
&#125;catch（ExampleA e）&#123;
System.out.println(&quot;ExampleA&quot;);
&#125;catch（Exception e）&#123;
System.out.println(&quot;Exception&quot;);
&#125;
&#125;
请问执行此段代码的输出是什么？
答：输出：ExampleA。（根据里氏代换原则\[能使用父类型的地方一定能使
用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的
257
ExampleB 类型的异常）
补充： 比此题略复杂的一道面试题如下所示（此题的出处是《Java 编程思
想》），说出你的答案吧！
package com.bjsxt;
class Annoyance extends Exception &#123;&#125;
class Sneeze extends Annoyance &#123;&#125;
class Human &#123;
public static void main(String\[] args)
throws Exception &#123;
try &#123;
try &#123;
throw new Sneeze();
&#125;
catch ( Annoyance a ) &#123;
System.out.println(&quot;Caught Annoyance&quot;);
throw a;
&#125;
&#125;
catch ( Sneeze s ) &#123;
System.out.println(&quot;Caught Sneeze&quot;);
return ;
&#125;
finally &#123;
System.out.println(&quot;Hello World!&quot;);
&#125;
&#125;
&#125;
输出为：
Caught Annoyance
Caught Sneeze
Hello World!
4.  Error 和 Exception 的区别
Error 类，表示仅靠程序本身无法恢复的严重错误，比如说内存溢出、动
态链接异常、虚拟机错误。应用程序不应该抛出这种类型的对象。假如出现
这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。所以在
进行程序设计时，应该更关注 Exception 类。
Exception 类，由 Java 应用程序抛出和处理的非严重错误，比如所需文
件没有找到、零作除数，数组下标越界等。它的各种不同子类分别对应不同
类型异常。可分为两类：Checked 异常和 Runtime 异常
5.  Java 异常处理 try-catch-finally 的执行过程
try-catch-finally 程序块的执行流程以及执行结果比较复杂。
基本执行过程如下：
1）程序首先执行可能发生异常的 try 语句块。
2）如果 try 语句没有出现异常则执行完后跳至 finally 语句块执行；
3）如果 try 语句出现异常，则中断执行并根据发生的异常类型跳至相应的
258
catch 语句块执行处理。
4）catch 语句块可以有多个，分别捕获不同类型的异常。
5）catch 语句块执行完后程序会继续执行 finally 语句块。
finally 语句是可选的，如果有的话，则不管是否发生异常，finally 语句都会
被执行。需要注意的是即使 try 和 catch 块中存在 return 语句，finally 语
句也会执行，是在执行完 finally 语句后再通过 return 退出。
6.  异常处理中 throws 和 throw 的区别
1）作用不同：
throw 用于程序员自行产生并抛出异常；
throws 用于声明在该方法内抛出了异常
2） 使用的位置不同：
throw 位于方法体内部，可以作为单独语句使用；
throws 必须跟在方法参数列表的后面，不能单独使用。
3）内容不同：
throw 抛出一个异常对象，且只能是一个；
throws 后面跟异常类，而且可以有多个。
Web 方面相关：
7.  WEB 应用中如果有.class 和.jar 类型的文件一般分别应该放
在什么位置？
答:
259
260
.class 文件放在 WEB-INF/classes 文件下，.jar 文件放在 WEB-INF/lib
文件夹下
8.  元素中有一个输入框（\&lt;input type=”text” name=”
username”id=”username”value=””/&gt;,请用 JavaScript
语言写一行代码，取得这个输入框中的值。
答:
document.getElementById(“username”).value;
9.  简单描述一下 Servlet 与 JSP 的的相同点和区别点。
区别：
JSP 是在 HTML 代码里写 JAVA 代码,框架是 HTML;而 Servlet 是在 JAVA 代
码中写 HTML 代码，本身是个 JAVA 类。
JSP 使人们把显示和逻辑分隔成为可能，这意味着两者的开发可并行进行；
而 Servlet 并没有把两者分开。
Servlet 独立地处理静态表示逻辑与动态业务逻辑.这样,任何文件的变动都
需要对此服务程序重新编译;JSP 允许用特殊标签直接嵌入到 HTML 页面,
HTML内容与JAVA内容也可放在单独文件中,HTML内容的任何变动会自动
编译装入到服务程序.
Servlet 需要在 web.xml 中配置，而 JSP 无需配置。
目前 JSP 主要用在视图层，负责显示，而 Servlet 主要用在控制层，负责调
度
联系：
都是 Sun 公司推出的动态网页技术。
先有 Servlet，针对 Servlet 缺点推出 JSP。JSP 是 Servlet 的一种特殊形式，
每个 JSP 页面就是一个 Servlet 实例——JSP 页面由系统翻译成 Servlet，
Servlet 再负责响应用户请求。
10. 请简单描述下几个您熟悉 JavaScript 库，它们有哪些作用和
特点？
JavaScript 高级程序设计（特别是对浏览器差异的复杂处理），通常很困难
也很耗时。为了应对这些调整，许多的 JavaScript 库应运而生。这些
JavaScript 库常被称为 JavaScript 框架。
jQuery:
Ext JS - 可定制的 widget，用于构建富因特网应用程序（rich Internet
applications）。
Prototype
MooTools。
YUI - Yahoo! User Interface Framework，涵盖大量函数的大型库，从简
单的 JavaScript 功能到完整的 internet widget。
11. 简单描述 HTML，CSS，Javascript 在 Web 开发中分别起
什么作用？
1、什么是 HTML（超文本标记语言 Hyper Text Markup Language），
HTML 是用来描述网页的一种语言。
2、CSS(层叠样式表 Cascading Style Sheets),样式定义如何显示 HTML
261
262
元素，语法为：selector &#123;property：value&#125; (选择符 &#123;属性：值&#125;)
3、JavaScript 是一种脚本语言，其源代码在发往客户端运行之前不需经过
编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行
对于一个网页，HTML 定义网页的结构，CSS 描述网页的样子，JavaScript
设置一个很经典的例子是说 HTML 就像 一个人的骨骼、器官，而 CSS 就是
人的皮肤，有了这两样也就构成了一个植物人了，加上 javascript 这个植物
人就可以对外界刺激做出反应，可以思 考、运动、可以给自己整容化妆（改
变 CSS）等等，成为一个活生生的人。
如果说 HTML 是肉身、CSS 就是皮相、Javascript 就是灵魂。没有
Javascript,HTML+CSS 是植物人，没有 Javascript、CSS 是个毁容的植物
人。
如果说 HTML 是建筑师，CSS 就是干装修的，Javascript 是魔术师。
12. 当 DOM 加载完成后要执行的函数，下面哪个是正确的()
A JQuery（expression, \[context]）
B. JQuery（html, \[ownerDocument]）
C. JQuery（callback）
答案：C
13. 举例说明 JAVA 中如何解析 xml，不同方式有和优缺点？
答：
14. DOM（Document Object Model)
263
DOM是用与平台和语言无关的方式表示XML文档的官方W3C标准。DOM
是以层次结构组织的节点或信息片断的集合。这个层次结构允许开发人员在
树中寻找特定信息。分析该结构通常需要加载整个文档和构造层次结构，然
后才能做任何工作。由于它是基于信息层次的，因而 DOM 被认为是基于树
或基于对象的。
【优点】
①允许应用程序对数据和结构做出更改。
②访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的
数据。
【缺点】
①通常需要加载整个 XML 文档来构造层次结构，消耗资源大。
15. SAX（Simple API for XML)
SAX 处理的优点非常类似于流媒体的优点。分析能够立即开始，而不是等待
所有的数据被处理。而且，由于应用程序只是在读取数据时检查数据，因此
不需要将数据存储在内存中。这对于大型文档来说是个巨大的优点。事实上，
应用程序甚至不必解析整个文档；它可以在某个条件得到满足时停止解析。
一般来说，SAX 还比它的替代者 DOM 快许多。
选择 DOM 还是选择 SAX？ 对于需要自己编写代码来处理 XML 文档的开
发人员来说， 选择 DOM 还是 SAX 解析模型是一个非常重要的设计决策。
DOM采用建立树形结构的方式访问XML文档，而SAX采用的是事件模型。
DOM 解析器把 XML 文档转化为一个包含其内容的树，并可以对树进行遍
历。用DOM解析模型的优点是编程容易，开发人员只需要调用建树的指令，
然后利用 navigation APIs 访问所需的树节点来完成任务。可以很容易的添
加和修改树中的元素。然而由于使用 DOM 解析器的时候需要处理整个 XML
文档，所以对性能和内存的要求比较高，尤其是遇到很大的 XML 文件的时
候。由于它的遍历能力，DOM 解析器常用于 XML 文档需要频繁的改变的
服务中。
SAX 解析器采用了基于事件的模型，它在解析 XML 文档的时候可以触发一
系列的事件，当发现给定的 tag 的时候，它可以激活一个回调方法，告诉该
方法制定的标签已经找到。SAX 对内存的要求通常会比较低，因为它让开发
人员自己来决定所要处理的 tag.特别是当开发人员只需要处理文档中所包
含的部分数据时，SAX 这种扩展能力得到了更好的体现。但用 SAX 解析器
的时候编码工作会比较困难，而且很难同时访问同一个文档中的多处不同数
据。
【优势】
①不需要等待所有数据都被处理，分析就能立即开始。
②只在读取数据时检查数据，不需要保存在内存中。
③可以在某个条件得到满足时停止解析，不必解析整个文档。
④效率和性能较高，能解析大于系统内存的文档。
【缺点】
①需要应用程序自己负责 TAG 的处理逻辑（例如维护父/子关系等），文档
越复杂程序就越复杂。
264
②单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，
不支持 XPath。
16. JDOM(Java-based Document Object Model)
JDOM 的目的是成为 Java 特定文档模型，它简化与 XML 的交互并且比使用
DOM 实现更快。由于是第一个 Java 特定模型，JDOM 一直得到大力推广
和促进。正在考虑通过“Java 规范请求 JSR-102”将它最终用作“Java 标
准扩展”。从 2000 年初就已经开始了 JDOM 开发。
JDOM 与 DOM 主要有两方面不同。首先，JDOM 仅使用具体类而不使用
接口。这在某些方面简化了 API，但是也限制了灵活性。第二，API 大量使
用了 Collections 类，简化了那些已经熟悉这些类的 Java 开发者的使用。
JDOM 文档声明其目的是“使用 20%（或更少）的精力解决 80%（或更多）
Java/XML 问题”（根据学习曲线假定为 20%）。JDOM 对于大多数 Java/XML
应用程序来说当然是有用的，并且大多数开发者发现 API 比 DOM 容易理解
得多。JDOM 还包括对程序行为的相当广泛检查以防止用户做任何在 XML
中无意义的事。然而，它仍需要您充分理解 XML 以便做一些超出基本的工
作（或者甚至理解某些情况下的错误）。这也许是比学习 DOM 或 JDOM 接
口都更有意义的工作。
JDOM 自身不包含解析器。它通常使用 SAX2 解析器来解析和验证输入 XML
文档（尽管它还可以将以前构造的 DOM 表示作为输入）。它包含一些转换
器以将 JDOM 表示输出成 SAX2 事件流、DOM 模型或 XML 文本文档。
JDOM 是在 Apache 许可证变体下发布的开放源码。
265
【优点】
①使用具体类而不是接口，简化了 DOM 的 API。
②大量使用了 Java 集合类，方便了 Java 开发人员。
【缺点】
①没有较好的灵活性。
②性能较差。
17. DOM4J(Document Object Model for Java)
虽然 DOM4J 代表了完全独立的开发结果，但最初，它是 JDOM 的一种智
能分支。它合并了许多超出基本 XML 文档表示的功能，包括集成的 XPath
支持、XML Schema 支持以及用于大文档或流化文档的基于事件的处理。
它还提供了构建文档表示的选项，它通过 DOM4J API 和标准 DOM 接口具
有并行访问功能。从 2000 下半年开始，它就一直处于开发之中。
为支持所有这些功能，DOM4J 使用接口和抽象基本类方法。DOM4J 大量
使用了 API 中的 Collections 类，但是在许多情况下，它还提供一些替代方
法以允许更好的性能或更直接的编码方法。直接好处是，虽然 DOM4J 付出
了更复杂的 API 的代价，但是它提供了比 JDOM 大得多的灵活性。
在添加灵活性、XPath 集成和对大文档处理的目标时，DOM4J 的目标与
JDOM 是一样的：针对 Java 开发者的易用性和直观操作。它还致力于成为
比 JDOM 更完整的解决方案，实现在本质上处理所有 Java/XML 问题的目
标。在完成该目标时，它比 JDOM 更少强调防止不正确的应用程序行为。
DOM4J 是一个非常非常优秀的 Java XML API，具有性能优异、功能强大
266
和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看
到越来越多的 Java 软件都在使用 DOM4J 来读写 XML，特别值得一提的是
连 Sun 的 JAXM 也在用 DOM4J.
【优点】
①大量使用了 Java 集合类，方便 Java 开发人员，同时提供一些提高性能的
替代方法。
②支持 XPath。
③有很好的性能。
【缺点】
①大量使用了接口，API 较为复杂。
二、比较
18. DOM4J 性能最好，连 Sun 的 JAXM 也在用 DOM4J。目前许多开源项目
中大量采用 DOM4J，例如大名鼎鼎的 Hibernate 也用 DOM4J 来读取 XML
配置文件。如果不考虑可移植性，那就采用 DOM4J.
19. JDOM 和 DOM 在性能测试时表现不佳，在测试 10M 文档时内存溢出，
但可移植。在小文档情况下还值得考虑使用 DOM 和 JDOM.虽然 JDOM 的
开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来
看，它确实没有值得推荐之处。另外，DOM 仍是一个非常好的选择。DOM
实现广泛应用于多种编程语言。它还是许多其它与 XML 相关的标准的基础，
因为它正式获得 W3C 推荐（与基于非标准的 Java 模型相对），所以在某些
类型的项目中可能也需要它（如在 JavaScript 中使用 DOM）。
267
20. SAX 表现较好，这要依赖于它特定的解析方式－事件驱动。一个 SAX 检
测即将到来的 XML 流，但并没有载入到内存（当然当 XML 流被读入时，会
有部分文档暂时隐藏在内存中）。
我的看法：如果 XML 文档较大且不考虑移植性问题建议采用 DOM4J；如
果 XML 文档较小则建议采用 JDOM；如果需要及时处理而不需要保存数据
则考虑 SAX。但无论如何，还是那句话：适合自己的才是最好的，如果时间
允许，建议大家讲这四种方法都尝试一遍然后选择一种适合自己的即可。
21. char 型变量中能不能存储一个中文汉字？
答：
1.java 采用 unicode 编码，2 个字节（16 位）来表示一个字符， 无论是汉
字还是数字，字母，或其他语言都可以存储。
2.char 在 java 中是 2 个字节，所以可以存储中文
22. 一个类可以实现多个接口，但只能继承一个抽象类。
下面接着再说说两者在应用上的区别：
接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信
契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模
板方法设计模式是抽象类的一个典型应用，假设某个项目的所有 Servlet 类
都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定
义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在抽象基类的
service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子
类中只是完成各自的业务逻辑代码，伪代码如下：
268
public abstract classBaseServlet extends HttpServlet&#123;
public final void service(HttpServletRequest
request,HttpServletResponse response) throws
IOExcetion,ServletException &#123;
记录访问日志
进行权限判断
if(具有权限)&#123;
try&#123;
doService(request,response);
&#125;
catch(Excetpion e) &#123;
记录异常信息
&#125;
&#125;
&#125;
protected abstract void doService(HttpServletRequest
request,HttpServletResponse response) throws
IOExcetion,ServletException;
//注意访问权限定义成 protected，显得既专业，又严谨，因为它是专门给
子类用的
&#125;
269
public class MyServlet1 extendsBaseServlet
&#123;
protected voiddoService(HttpServletRequest request,
HttpServletResponse response) throwsIOExcetion,ServletException
&#123;
本 Servlet 只处理的具体业务逻辑代码
&#125;
&#125;
父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。
备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较
两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理
是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静
态变量和方法，继承性等 6 个方面逐一去比较回答，接着从第三者继承的角
度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。
23. 比较一下 Java 和 JavaSciprt
答：JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun
公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而
JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功能而
开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言，
它的前身是 LiveScript；而 Java 的前身是 Oak 语言。
270
下面对两种语言间的异同作如下比较：
1）基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发
简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与
网络无关的，与用户交互作用的复杂软件。它是一种基于对象
（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身
提供了非常丰富的内部对象供设计人员使用；
2）解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是
一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；
3）强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编
译之前必须作声明；JavaScript 中变量声明，采用其弱类型。即变量在使用
前不需作声明，而是解释器在运行时检查其数据类型；
4）代码格式不一样。
补充：上面列出的四点是原来所谓的标准答案中给出的。其实 Java 和
JavaScript 最重要的区别是一个是静态语言，一个是动态语言。目前的编程
语言的发展趋势是函数式语言和动态语言。在 Java 中类（class）是一等公
民，而 JavaScript 中函数（function）是一等公民。对于这种问题，在面试
时还是用自己的语言回答会更加靠谱。
24. 什么时候用 assert？
答：assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中
都支持这种机制。一般来说，assertion 用于保证程序最基本、关键的正确
性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布
271
后， assertion 检查通常是关闭的。在实现中，断言是一个包含布尔表达式
的语句，在执行这个语句时假定该表达式为 true；如果表达式计算为 false，
那么系统会报告一个 AssertionError。
断言用于调试目的：
assert(a &gt; 0); // throws an AssertionError if a &lt;= 0
断言可以有两种形式：
assert Expression1;
assert Expression1 : Expression2 ;
Expression1 应该总是产生一个布尔值。
Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调
试信息的字符串消息。
断言在默认情况下是禁用的，要在编译时启用断言，需使用 source 1.4 标
记：
javac -source 1.4 Test.java
要在运行时启用断言，可使用-enableassertions 或者-ea 标记。
要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。
要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上
启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。
断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递
给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。
不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。
272
另外，断言不应该以任何方式改变程序的状态。
25. UML 是什么？UML 中有哪些图？
答：UML 是统一建模语言（Unified Modeling Language）的缩写，它发
表于 1997 年，综合了当时已经存在的面向对象的建模语言、方法和过程，
是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提
供模型化和可视化支持。使用 UML 可以帮助沟通与交流，辅助应用设计和
文档的生成，还能够阐释系统的结构和行为。UML 定义了多种图形化的符
号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use
case diagram）、类图（class diagram）、时序图（sequence diagram）、
协作图（collaboration diagram）、状态图（statechart diagram）、活动
图（activity diagram）、构件图（component diagram）、部署图
（deployment diagram）等。在这些图形化符号中，有三种图最为重要，
分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了
解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过
该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关
系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向
外界提供的服务）。
用例图：
273
类图：
时序图：
274
26. XML 文档定义有几种形式？它们之间有何本质区别？解析
XML 文档有哪几种方式？
答： XML 文档定义分为 DTD 和 Schema 两种形式；其本质区别在于
Schema 本身也是一个 XML 文件，可以被 XML 解析器解析。对 XML 的解
析主要有 DOM（文档对象模型）、SAX、StAX（JDK 1.6 中引入的新的解析
XML 的方式，Streaming API for XML） 等，其中 DOM 处理大型文件时
其性能下降的非常厉害，这个问题是由 DOM 的树结构所造成的，这种结构
占用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适
合对 XML 的随机访问（典型的用空间换取时间的策略）；SAX 是事件驱动
型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。
当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个
事件，用户通过在其回调事件中写入处理代码来处理 XML 文件，适合对 XML
的顺序访问；如其名称所暗示的那样，StAX 把重点放在流上。实际上，StAX
与其他方法的区别就在于应用程序能够把 XML 作为一个事件流来处理。将
275
XML 作为一组事件来处理的想法并不新颖（事实上 SAX 已经提出来了），
但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提
供在解析器方便时从解析器中接收事件的处理程序。
27. 你在项目中哪些地方用到了 XML？
答： XML 的主要作用有两个方面：数据交换（曾经被称为业界数据交换的
事实标准，现在此项功能在很多时候都被 JSON 取代）和信息配置。在做数
据交换时，XML 将数据用标签组装成起来，然后压缩打包加密后通过网络
传送给接收者，接收解密与解压缩后再从 XML 文件中还原相关信息进行处
理。目前很多软件都使用 XML 来存储配置信息，很多项目中我们通常也会
将作为配置的硬代码（hard code）写在 XML 文件中，Java 的很多框架也
是这么做的。
28. 用 JavaScript 实现用正则表达式验证，某个字符串是合法的
6 位数字的邮编的函数
Function testE(ss)&#123;
var reg=/^\[1-9]\[0-9]&#123;5&#125;\$/；
if(req.test(ss))&#123;
alert(“邮编 OK”)
&#125;else&#123;
alert(“邮编格式不正确”)；
&#125;
&#125;
276
29. 请使用 JQuery 将页面上的所有元素边框设置为 2pix 宽的虚
线？
\$(“\*”).css(“border”,”2px dashed”)
30. 如何设定 JQuery 异步调用还是同步调用？
答案：
调用 jQuery 中的 ajax 函数，设置其 async 属性来表明是异步还是同步，
如下：
\$.ajax(&#123;
async\:true//表示异步，false 表示同步
&#125;)
31. 说出 3 条以上 firefox 和 IE 的浏览器兼容问题？
答案：
兼容 firefox 的 outerHTML，FF 中没有 outerHtml 的方法
IE 下,可以使用()或\[]获取集合类对象;Firefox 下,只能使用\[]获取集合类对象.
解决方法:统一使用\[]获取集合类对象.
IE 下,可以使用获取常规属性的方法来获取自定义属性,也可以使用
getAttribute()获取自定义属性;Firefox 下,只能使用 getAttribute()获取自
定义属性.解决方法:统一通过 getAttribute()获取自定义属性
32. 请用 Jquery 语言写出 ajax 请求或者 post 请求代码
\$.post(“show”,&#123;uname=”张三”，pwd=”123”&#125;,function(data)&#123;
277
278
alert(data)
&#125;)
33. body中的onload（）函数和jQuery中document.ready()
有什么区别？
答案：
ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体
文件）
onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。
34. jQuery 中有哪几种类型的选择器？
答案：
基本选择器
层次选择器
基本过滤选择器
内容过滤选择器
可见性过滤选择器
属性过滤选择器
子元素过滤选择器
表单选择器
表单过滤选择器
35. EasyUI 中 datagrid 刷新当前数据的方法？
答案：使用 reload()即可
36. 分别写出一个 div 居中和其中的内容居中的 css 属性设置
Div 居中：
margin\:auto 0px;
内容居中:
text-align\:center;
37. 概述一下 session 与 cookie 的区别
答案：
存储角度：
Session 是服务器端的数据存储技术，cookie 是客户端的数据存储技术
解决问题角度：
Session 解决的是一个用户不同请求的数据共享问题，cookie 解决的是不
同请求的请求数据的共享问题
生命周期角度：
Session 的 id 是依赖于 cookie 来进行存储的，浏览器关闭 id 就会失效
Cookie 可以单独的设置其在浏览器的存储时间。
38. JavaScript 中 null 和 undefined 是否有区别？有哪些区
别？
答案：
赋值角度说明：
null 表示此处没有值，undefined 表示此处定义了但是没有赋值
从数据转换角度：
279
280
Null 在做数值转换时会被转换为 0，undefined 会被转换为 NaN
39. Servlet 中的 doPost 和 doGet 方法有什么区别?它们在传递
和获取参数上有什么区别？
答案：
区别：doPost 用来处理 post 请求，doGet 用来处理 get 请求，获取参数：
获取的参数是相同的都是 HttpServletRequest \HttpServletResponse
40. 请写出一段 jQuery 代码，实现把当前页面中所有的 a 元索中
class 属性为“view-link”的链接都改为在新窗口中打开
答案：
\$(“a\[class=view-link]”).attr(“target”,”\_blank”)
41. 如下 JavaScript 代码的输出为：
var scope =&quot;global scope&quot;;
function checkscope() &#123;
var scope =&quot;local scope”；
return function() &#123; return scope&#125;
&#125;
console.log (checkscope()());
输出：global scope
42. Jquery 中’.get()’与’.eq()’的区别
eq 返回的是一个 jquery 对象 get 返回的是一个 html 对象
43. 如何给 weblogic 定内存的大小？
在启动 Weblogic 的脚本中（位于所在 Domian 对应服务器目录下的
startServerName），增加 set MEM\_ARGS=-Xms32m -Xmx200m，可以
调整最小内存为 32M，最大 200M
44. TCP 为何采用三次握手来建立连接，若釆用二次握手可以吗，
请说明理由？
三次握手是为了防止已失效的连接请求再次传送到服务器端。 二次握手不
可行，因为：如果由于网络不稳定，虽然客户端以前发送的连接请求以到达
服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送
连接请求，若采用二次握手，服务方收到重传的请求连接后，会以为是新的
请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资
源的无谓浪费
45. 以下 HTTP 相应状态码的含义描述正确的是（）
A. 200ok表示请求成功
B. 400 不良请求表示服务器未发现与请求 URL 匹配内容
C. 404未发现表示由于语法错误儿导致服务器无法理解请求信息
D. 500 内部服务器错误，无法处理请求
答案：D
分析：
A 200ok 表示的意思是一切正常。一般用于相应 GET 和 POST 请求。这
个状态码对 servlet 是缺省的；如果没有调用 setStatus 方法的话，就会得
到 200。
B 400 表示指出客户端请求中的语法错误
C 404 客户端所给的地址无法找到任何资源
281
46. JSP 页面包括哪些元素？（）
A. JSP命令
B. JSP Action
C. JSP脚本
D. JSP 控件
答案：C
分析：JSP 页面元素构成如下，因此 ABD 错误
47. Ajax 有四种技术组成：DOM,CSS,JavaScript，
XmlHttpRequest，其中控制文档结构的是（）
A. DOM
B. CSS
C. JavaScript
D. XmlHttpRequest
答案：A
282
48. 下面关于 session 的用法哪些是错误的？（）
A. HttpSession session=new HttpSession();
B. String haha=session getParameler(\:haha”);
C. session.removeAttribute(“haha”);
D. session.setAttribute(\:haha:);XmlHttpRequest
答案：A
49. Jsp 九大内置对象
答案：
1、request 对象
request 对象是 javax.servlet.httpServletRequest 类型的对象。 该对象代
表了客户端的请求信息，主要用于接受通过 HTTP 协议传送到服务器的数据。
（包括头信息、系统信息、请求方式以及请求参数等）。request 对象的作用
域为一次请求。
2、response 对象
response 代表的是对客户端的响应，主要是将 JSP 容器处理过的对象传回到
客户端。response 对象也具有作用域，它只在 JSP 页面内有效。
3、session 对象
session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用
户都生成一个 session 对象，用于保存该用户的信息，跟踪用户的操作状态。
session 对象内部使用 Map 类来保存数据，因此保存数据的格式为
283
“Key/value”。 session 对象的 value 可以使复杂的对象类型，而不仅仅局
限于字符串类型。
4、application 对象
application 对象可将信息保存在服务器中，直到服务器关闭，否则
application 对象中保存的信息会在整个应用中都有效。与 session 对象相比，
application 对象生命周期更长，类似于系统的“全局变量”。
5、out 对象
out 对象用于在 Web 浏览器内输出信息，并且管理应用服务器上的输出缓冲
区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓
冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时
关闭输出流。
6、pageContext 对象
pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP 页面
的 out、request、reponse、session、application 等对象。pageContext
对象的创建和初始化都是由容器来完成的，在 JSP 页面中可以直接使用
pageContext 对象。
7、config 对象
config 对象的主要作用是取得服务器的配置信息。通过 pageConext 对象的
getServletConfig() 方法可以获取一个 config 对象。当一个 Servlet 初始化
时，容器把某些信息通过 config 对象传递给这个 Servlet。 开发者可以在
web.xml 文件中为应用程序环境中的 Servlet 程序和 JSP 页面提供初始化参
284
数。
8、page 对象
page 对象代表 JSP 本身，只有在 JSP 页面内才是合法的。 page 隐含对象
本质上包含当前 Servlet 接口引用的变量，类似于 Java 编程中的 this 指针。
9、exception 对象
exception 对象的作用是显示异常信息，只有在包含 isErrorPage=&quot;true&quot; 的
页面中才可以被使用，在一般的 JSP 页面中使用该对象将无法编译 JSP 文件。
excepation 对象和 Java 的所有对象一样，都具有系统提供的继承结构。
exception 对象几乎定义了所有异常情况。在 Java 程序中，可以使用
try/catch 关键字来处理异常情况； 如果在 JSP 页面中出现没有捕获到的异
常，就会生成 exception 对象，并把 exception 对象传送到在 page 指令
中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。
50. 如何配置一个 servlet?
在 web.xml 中使用如下标签:
\&lt;servlet&gt;\&lt;servlet-name&gt;\&lt;/servlet-name&gt; \&lt;servlet-class&gt;\&lt;/servlet-class&gt; \&lt;/servlet&gt; \&lt;servlet-mapping&gt; \&lt;servlet-name&gt;\&lt;/servlet-name&gt; \&lt;url-pattern&gt;\&lt;/url-pattern&gt;
285
 \&lt;/servlet-mapping&gt;
或者使用注解方式：
@WebServlet(name=&quot;servlet&quot;, urlPatterns=&#123;&quot;/\*&quot;&#125;)1.  JavaScript，如何定义含有数值 1 至 8 的数组？
答： var arr=\[1,2,3,4,5,6,7,8]
2.  以下 JavaScipt 语句会产生运行错误的是\_（）
A. var obj=( );
B. var obj=\[ ];
C. var obj=//;
D. var obj=1;
答案：AC
3.  在 JSP 中，下面\_\_（）\_\_块中可以定义一个新类：
A. &lt;% %&gt;
B. &lt;% ! %&gt;
C. &lt;%@ %&gt;
D. &lt;%=%&gt;
答案：B
分析：B &lt;% ! %&gt; 可用作声明
A 不正确
C 为引用 xxx，比如&lt;% @page xxxxx%&gt;
D 为表达式
286
4.  HTML 含义和版本变化
HTML 含义：
Hyper Text Markup Language 超文本标记语言，是一种用来制作“网页”
的简单标记语言；用 HTML 编写的超文本文档称为 HTML 文档，HTML 文
档的扩展名是 html 或者 htm
版本变化：
HTML1.0——在 1993 年 6 月作为 IETF 工作草案发布（并非标准）
HTML 2.0——1995 年 11 月作为 RFC 1866 发布
HTML 3.2——1997 年 1 月 14 日，W3C 推荐标准
HTML 4.0——1997 年 12 月 18 日，W3C 推荐标准
HTML 4.01（微小改进）——1999 年 12 月 24 日，W3C 推荐标准
HTML 5—2014 年 10 月 28 日，W3C 推荐标准 HTML 文档结构；
HTML 5.1 - 2016 年
HTML 5.2 – 2018 年最新版本
HTML 5.3 is coming…
5.  什么是锚链接
锚链接是带有文本的超链接。可以跳转到页面的某个位置，适用于页面内容
较多，超过一屏的场合 。分为页面内的锚链接和页面间的锚链接 。
例如：
287
288 &lt;a&gt;1F&lt;/a&gt;&lt;a&gt;2F&lt;/a&gt; &lt;a href&gt;跳转到 2F 标记位置&lt;/a&gt;
说明：
1.在标记位置利用 a 标签的 name 属性设置标记。
2.在导航位置通过 a 标签的 href 属性用#开头加 name 属性值即可跳转
锚点位置。
6.  HTML 字符实体的作用及其常用字符实体
有些字符，比如说“&lt;”字符，在 HTML 中有特殊的含义，因此不能在文本
中使用。想要在 HTML 中显示一个小于号“&lt;”，需要用到字符实体：&lt;
或者&lt;
字符实体拥有三个部分：一个 and 符号（&amp;），一个实体名或者一个实体号，
最后是一个分号（;）
常用字符实体：
显示
结果
描述 实体名 实体
号
空格   \&amp;#
160;
&lt; 小于 &lt; \&amp;#
60;&gt; 大于 &gt; \&amp;#
&gt; 
&gt; 289
&gt; 62;
&gt; &amp; and 符号 &amp; \&amp;#
&gt; 38;
&gt; &#39; 单引号 &#39; (IE 不
&gt; 支持)
&gt; \&amp;#
&gt; 39;
&gt; &quot; 引号 &quot; \&amp;#
&gt; 34;
&gt; £ 英镑 £ \&amp;#
&gt; 163;
&gt; ¥ 人民币元 ¥ \&amp;#
&gt; 165;
&gt; § 章节 § \&amp;#
&gt; 167;
&gt; © 版权 © \&amp;#
&gt; 169;1.  HTML 表单的作用和常用表单项类型
表单的作用：
利用表单可以收集客户端提交的有关信息。
常用表单项类型：
290input 标签
type 属性
功能 input 标签
type 属性
功能
text 单行本框 reset 重置按钮
password 密码框 submit 提交按钮
radio 单选按钮 textarea 文本域
checkbox 复选框 select 下拉框
button 普通按钮 hidden 隐藏域1.  表格、框架、div 三种 HTML 布局方式的特点
优点 缺点 应用场合
表格 方便排列有规律、结
构均匀的内容或数据
产生垃圾代码、影响
页面下载时间、灵活
性不大难于修改
内容或数据整齐的
页面
框架 支持滚动条、方便导
航
节省页面下载时间等
兼容性不好，保存时
不方便、应用范围有
限
小型商业网站、论坛
后台管理
Div 代码精简、提高页面
下载速度、表现和内
容分离
比较灵活、难于控制 复杂的不规则页面、
业务种类较多的大
型商业网站
2.  form 中 input 设置为 readonly 和 disabled 的区别
readonly disabled
291
有效对象 .只针对 type 为
text/password 有效
对所有表单元素有效
表单提交 当表单元素设置 readonly
后，表单提交能将该表单元
素的值传递出去。
当表单元素设置 disabled 后，表
单提交不能将该表单元素的值传
递出去。
3.  CSS 的定义和作用
CSS 的定义：CSS 是 Cascading Style Sheets(层叠样式表)的简称。
CSS 是一系列格式规则，它们控制网页内容的外观。CSS 简单来说就是用来
美化网页用的。
CSS 的具体作用包括：
使网页丰富多彩，易于控制。
页面的精确控制，实现精美、复杂页面 。
样式表能实现内容与样式的分离，方便团队开发。
样式复用、方便网站的后期维护。
4.  CSS2 常用选择器类型及其含义
选择器名称 案例 语法格式
标签选择器 h3&#123;font-size:24px;font-famil
y:&quot;隶书“; &#125;&lt;h3&gt;JSP&lt;/h3&gt;
元素标签名&#123;样式属性&#125;
类选择器 .red &#123;color:#F00;&#125; . 元素标签 class 属性值
292
&lt;li&gt;Oracle&lt;/li&gt;
&#123;样式属性&#125;
ID 选择器 #p1 
&#123;background-color:#0F0;&#125;
&lt;p id=&quot;p1&quot;&gt;content&lt;/p&gt;
#元素标签 id 属性值&#123;样式
属性&#125;
包含选择器 div h3&#123;color:red;&#125;
&lt;div&gt;
 &lt;h3&gt;CSS 层叠样式表
&lt;/h3&gt;
&lt;/div&gt;
父元素标签 子元素标签&#123;
 样式属性
&#125;
子选择器 div&amp;gt;ul&#123;color:blue;&#125;
&lt;div&gt;
&lt;ul&gt;
 &lt;li&gt;测试 1
 &lt;ol&gt;
 &lt;li&gt;嵌套元素
&lt;/li&gt;
&lt;li&gt;嵌套元素&lt;/li&gt;
&lt;li&gt;嵌套元素&lt;/li&gt;
&lt;li&gt;嵌套元素&lt;/li&gt;
&lt;/ol&gt;
父元素标签名&amp;gt;子元素名&#123;
 样式属性
&#125;
&lt;/li&gt;
&lt;li&gt;测试 1&lt;/li&gt;
&lt;li&gt;测试 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
340. 盒子模型
 盒子模型类似于生活中的盒子，具有 4 个属性，外边距，内
边距，边框，内容。
 外边距：margin，用于设置元素和其他元素之间的距离。
 内边距：padding,用于设置元素内容和边框之间的距离。
 边框：border,用于设置元素边框粗细，颜色，线型。
 内容：width,height,用于设置元素内容显示的大小。
 例如：
&amp;lt;style&amp;gt;
 body&#123;
 margin: 0; /*取消body默认的外边距*/
 &#125; 
#img1&#123;
width:200px; /*设置图片的宽度*/
border: 2px solid black; /*设置图片边框*/
295
margin: 5px; 
/*设置图片外边距（表示该图片与其他图片的距离为5px）*/
padding:10px; /*设置图片与边框之间的距离*/
&#125;
#img2&#123;
height: 200px; /* 设置图片的高度*/
border: 2px solid black; /*设置图片的边框*/
margin: 5px; /*设置图片外边距*/
padding: 20px; /*设置图片与边框之间的距离*/
&#125;
&amp;lt;/style&amp;gt;
&lt;img id=&quot;img1&quot; src /&gt;
&lt;img id=&quot;img2&quot; src /&gt;
341. JavaScript 语言及其特点
Javascript 一种基于对象(object-based)和事件驱动(Event Driven)的简单
的并具有安全性能的脚本语言。特点：
解释性： JavaScript 不同于一些编译性的程序语言，例如 C、C++等，它
是一种解释性的程序语言，它的源代码不需要经过编译，而直接在浏览器中
运行时被解释。
基于对象：JavaScript 是一种基于对象的语言。这意味着它能运用自己已经
296
创建的对象。因此，许多功能可以来自于脚本环境中对象的方法与脚本的相
互作用。
事件驱动：JavaScript 可以直接对用户或客户输入做出响应，无须经过 Web
服务程序。它对用户的响应，是以事件驱动的方式进行的。所谓事件驱动，
就是指在主页中执行了某种操作所产生的动作，此动作称为“事件”。比如
按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会
引起相应的事件响应。
跨平台:JavaScript 依赖于浏览器本身，与操作环境无关，只要能运行浏览器
的计算机，并支持 JavaScript 的浏览器就可正确执行。
342. JavaScript 常用数据类型有哪些
1、数值型(Number)：整数和浮点数统称为数值。例如 85 或 3.1415926
等。
2、字符串型(String)：由 0 个,1 个或多个字符组成的序列。在 JavaScript
中，用双引号或单引号括起来表示，如“您好”、‘学习 JavaScript’等。
不区分单引号、双引号。
3、逻辑（布尔）型(Boolean)：用 true 或 false 来表示。
4、空（null）值(Null)：表示没有值，用于定义空的或不存在的引用。
要注意，空值不等同于空字符串&quot;&quot;或 0。
5、未定义（Undefined）值：它也是一个保留字。表示变量虽然已经声明，
但却没有赋值。
除了以上五种基本的数据类型之外，JavaScript 还支持复合数据类型，包括
297
对象和数组两种。
343. html 语法中哪条命令用于使一行文本折行，而不是插入一个
新的段落？ (B)
A. &lt;td&gt;
B. &lt;br&gt;
C. &lt;p&gt;
D. &lt;h1&gt;
分析：
A &lt;td&gt;定义标准表格
C &lt;p&gt;表示文本一个段落
D &lt;h1&gt;表示对文本标题进行强调的一种标签
344. Ajax 的优点和缺点
优点：减轻服务器的负担,按需取数据,最大程度的减少冗余请求，局部
刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验，基于 xml
标准化,并被广泛支持,不需安装插件等，进一步促进页面和数据的分离
 缺点：AJAX 大量的使用了 javascript 和 ajax 引擎,这些取决于浏览器
的支持.在编写的时候考虑对浏览器的兼容性.
345. 怎样防止表单刷新重复提交问题？（说出思路即可）
JS 脚本方式:
第一种：定义全局变量，在 form 提交前判断是否已有提交过
298
&amp;lt;script&amp;gt; 
 var checkSubmitFlg = false; 
 function checkSubmit()&#123; 
 if(checkSubmitFlg == true)&#123; 
return false; 
 &#125; 
 checkSubmitFlg = true; 
 return true; 
 &#125; 
&amp;lt;/script&amp;gt; 
&amp;lt;form action=&quot;&quot; onsubmit=&quot;return checkSubmit();&quot;&amp;gt;
&amp;lt;/form&amp;gt;
第二种：单击提交按钮后，立刻禁用改按钮
第三种：单击提交按钮后，弹出屏蔽层，防止用户第二次点击
346. JQuery.get()和 JQuery.ajax()方法之间的区别是什么？
JQuery.ajax()是对原生的 javaScript 的 ajax 的封装，简化了 ajax 的步骤，
用户可用 JQuery.ajax()发送 get 或者 post 方式请求,Jquery.get()是对 ajax
的 get 方式的封装，只能发送 get 方式的请求。
347. Jquery 里的缓存问题如何解决？例如（$.ajax()以及$.get()）
$.ajax()请求时候加上 cache:false 的参数，如：
$.ajax(&#123; 
 type : &quot;get&quot;, 
 url : &quot;XX&quot;, 
 dataType : &quot;json&quot;, 
 cache:false, 
 success : function(json) &#123; 
 &#125; 
&#125;);
$.get()请求时候加上时间，如:
$.get(&quot;url&quot;,&quot;data&quot;+new Date(),function(data)&#123;
);
348. Javascript 是面向对象的，怎么体现 Javascript 的继承关
系？
Javascript 里面没有像 java 那样的继承，javascript 中的继承机制仅仅是靠
模拟的，可以使用 prototype 原型来实现
349. Javascript 的有几种种变量。变量范围有什么不同？
可以分为三种
 1、原生类型（string,number,boolean）
 2、对象（Date,Array）
 3、特殊类型（var vara;(只什么没有定义),var varb = null;(定义一个变
299
300
量并赋值为 null)）
350. Js 如何获取页面的 dom 对象
1、直接获取
//1.1 -- id 方式获取
var varid = document.getElementById(&quot;unameid&quot;);
//1.2 -- name 获取(获取的是数组对象)
var varname = document.getElementsByName(&quot;sex&quot;);
//1.3 -- 元素获取(获取的是数组对象)
var varinput = document.getElementsByTagName(&quot;input&quot;);
2、间接方式获取
//2.1 父子关系 --childNodes
var varchilds = document.getElementById(&quot;div01&quot;).childNodes;
//2.2 子父关系--parentNode
var varfather2 = 
document.getElementById(&quot;unameid&quot;).parentNode;
//2.3 兄弟之间相互获取 nextSibling：下一个节点 
previousSibling：上一个节点
351. Servlet API 中 forward() 与 redirect()的区别？
答：
为实现程序的模块化，就需要保证在不同的 Servlet 之间可以相互跳转，
而 Servlet 中主要有两种实现跳转的方式：FORWARD 方式与 redirect 方
式。
Forward() : 是服务器内部的重定向，服务器直接访问目标地址的 URL，
把那个 URL 的响应内容读取出来，而客户端并不知道，因此在客户端浏览
器的地址栏里不会显示跳转后的地址，还是原来的地址。由于在整个定向的
过程中用的是同一个 Request，因此 FORWARD 会将 Request 的信息带到
被定向的ＪＳＰ或 Servlet 中使用。
Redirect():则是客户端的重定向，是完全的跳转，即客户端浏览器会获
取跳转后的地址，然后重新发送请求，因此浏览器中会显示跳转后的地址。
同时，由于这种方式比 FORWARD 方式多了一次网络请求，因此其效率低
于 FORWARD 方式，需要注意到的是，客户端的重定向可以通过设置特定
的 HTTP 头或写 JavaScript 脚本来实现。
鉴于以上的区别，一般当 FORWARD 方式可以满足需求时，尽可能的
使用 FORWARD 方式。但在有些情况下，例如，需要跳转到一个其他服务
器上的资源时，则必须使用 redirect 方式。
352. Session 域和 request 域什么区别？
作用域：存放数据，获取数据（传递数据）
 有效的作用域：生命周期，作用范围
 httpServeltRequest: 
301
302
 生命周期：一次请求之间
 作用范围：所有被请求转发过的 servlet 都能获取到
 httpSession:
 生命周期：一次会话
作用范围：所有的 servlet 都可以获取到
 servletContex:
 生命周期：从项目开始运行到服务器关闭
 作用范围：所有的 servlet 都可以获取到
 作用域如何选用？
 httpServeltRequest：和当前请求有关的信息
 httpSession：和当前用户有关的信息
 servletContex：访问量比较大，不易更改
353. 页面中有一个命名为 bankNo 的下拉列表，写 js 脚本获取当
前选项的索引值，如果用 jquery 如何获取
var a = document.getElementsByName(&quot;bankNo&quot;)[0].value;
var b = $(&quot;select[name=bankNo]&quot;).val();
354. 写出要求 11 位数字的正则表达式
^[1-9]\d&#123;10&#125;$
303
355. 分别获取指定 name、Id 的 javascript 对象，如果用 jquey
如何获取
js:
 id--document.getElementById(&quot;id&quot;);
 name--document.getElementsByName(&quot;name&quot;);
jquery
 id--$(&quot;#id&quot;);
 name--$(&quot;元素名称[name=&quot;name 值&quot;]&quot;）;
356. 一个页面有两个 form，如何获取第一个 form
用 id 方式获取；document.getElementById(&quot;id&quot;); 
357. 如何设置一个层的可见/隐藏
可见 : document.getElementById(&quot;divid&quot;).style.display = &quot;block&quot;;
隐藏 : document.getElementById(&quot;divid&quot;).style.display = &quot;none&quot;;
358. 描述 JSP 中动态 INCLUDE 与静态 INCLUDE 的区别？
动态导入
1、会将多个 jsp 页面分别再编写成 java 文件，编译成 class 文件
2、jsp 文件中允许有相同的变量名，每个页面互不影响
3、当 java 代码比较多优先选用动态导入
4、效率相对较低，耦合性低
静态导入
1、会将多个 jsp 页面合成一个 jsp 页面，再编写成 java 文件，编译成
304
class 文件
2、jsp 文件中不允许有相同的变量名
3、当 java 代码比较少或者没有 java 代码是优先选用静态导入
4、效率相对较高，耦合性高
359. 列举 JSP 的内置对象及方法
request 表示 HttpServletRequest 对象。它包含了有关浏览器请求的信息，
并且提供了几个用于获取 cookie, header, 和 session 数据的有用的方法。
response表示HttpServletResponse 对象，并提供了几个用于设置送回 浏
览器的响应的方法（如 cookies,头信息等）
out 对象是 javax.jsp.JspWriter 的一个实例，提供了几个方法使你能用于向
浏览器回送输出结果
pageContext 表示一个 javax.servlejt.sp.PageContext 对象。它是用于方
便存取各种范围的名字空间、servlet 相关的对象的 API，并且包装了通用的
servlet 相关功能的方法。
session 表示一个请求的 javax.servlet.http.HttpSession 对象。Session
可以存贮用户的状态信息
applicaton 表示一个 javax.servle.ServletContext 对象。这有助于查找有
关 servlet 引擎和 servlet 环境的信息
config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet
实例的初始化参数。
page 表示从该页面产生的一个 servlet 实例
Exception 异常
360. 列举 jsp 的四大作用域
page、request、session、application
361. html 和 xhtml 的区别是什么？
HTML 与 XHTML 之间的差别，粗略可以分为两大类比较：一个是功能上的
差别，另外是书写习惯的差别。关于功能上的差别，主要是 XHTML 可兼容
各大浏览器、手机以及 PDA，并且浏览器也能快速正确地编译网页。
因为 XHTML 的语法较为严谨， 所以如果你是习惯松散结构的 HTML 编写
者，那需要特别注意 XHTML 的规则。但也不必太过担心，因为 XHTML 的
规则并不太难。下面列出了几条容易犯的错误，供大家引用。
1:所有标签都必须小写
在 XHTML 中，所有的标签都必须小写，不能大小写穿插其中，也不能全部
都是大写。看一个例子。
错误：&amp;lt;Head&amp;gt;&amp;lt;/Head&amp;gt;&amp;lt;Body&amp;gt;&amp;lt;/Body&amp;gt;
正确：&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
2:标签必须成双成对
像是&lt;p&gt;...&lt;/p&gt;、&lt;a&gt;...&lt;/a&gt;、&lt;div&gt;...&lt;/div&gt;标签等，当出现一个标签
时，必须要有对应的结束标签，缺一不可，就像在任何程序语言中的括号一
样。
错误：大家好&lt;p&gt;我是 muki
正确：&lt;p&gt;大家好&lt;/p&gt;&lt;p&gt;我是 muki&lt;/p&gt;
305
306
3:标签顺序必须正确
标签由外到内，一层层包覆着，所以假设你先写 div 后写 h1，结尾就要先
写 h1 后写 div。只要记住一个原则“先进后出”，先弹出的标签要后结尾。
错误：&lt;div&gt;&lt;h1&gt;大家好&lt;/div&gt;&lt;/h1&gt;
正确：&lt;div&gt;&lt;h1&gt;大家好&lt;/h1&gt;&lt;/div&gt;
4:所有属性都必须使用双引号
在 XHTML 1.0 中规定连单引号也不能使用，所以全程都得用双引号。
错误：&lt;div style=&quot;font-size:11px;&quot;&gt;hello&lt;/div&gt;
正确：&lt;div style=&quot;font-size:11px;&quot;&gt;hello&amp;lt;/div
5:不允许使用 target=&quot;_blank&quot;
从 XHTML 1.1 开始全面禁止 target 属性，如果想要有开新窗口的功能，就
必须改写为 rel=&quot;external&quot;，并搭配 JavaScript 实现此效果。
错误：&lt;a href=&quot;http://blog.mukispace.com&quot; target=&quot;_blank&quot;&gt;MUKI 
space&lt;/a&gt;
正确：&lt;a href=&quot;http://blog.mukispace.com&quot;&gt;MUKI 
space&lt;/a&gt;
362. 你做的页面用哪些浏览器测试过？这些测试的内核分别是什
么？
1、Trident 内核代表产品 Internet Explorer，又称其为 IE 内核。
Trident（又称为 MSHTML），是微软开发的一种排版引擎。使用 Trident
渲染引擎的浏览器包括：IE、傲游、世界之窗浏览器、Avant、腾讯 TT、
Netscape 8、NetCaptor、Sleipnir、GOSURF、GreenBrowser 和 KKman
等。
2、Gecko 内核代表作品 Mozilla
FirefoxGecko 是一套开放源代码的、以 C++编写的网页排版引擎。Gecko
是最流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、
Netscape6 至 9。
3、WebKit 内核代表作品 Safari、Chromewebkit
是一个开源项目，包含了来自 KDE 项目和苹果公司的一些组件，主要用于
Mac OS 系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页
代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作
品有 Safari 和 Google 的浏览器 Chrome。
4、Presto 内核代表作品 OperaPresto
是由 Opera Software 开发的浏览器排版引擎，供 Opera 7.0 及以上使用。
它取代了旧版 Opera 4 至 6 版本使用的 Elektra 排版引擎，包括加入动态功
能，例如网页或其部分可随着 DOM 及 Script 语法的事件而重新排版。
363. 你遇到了哪些浏览器的兼容性问题？怎么解决的？
答：因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统
一的情况；这是我们常见的兼容性问题。
解决方法：
1、针对不同的浏览器写不同的代码
2、使用 jquery 屏蔽浏览器差异
307
遇到不同的兼容问题，需要针对前端进行兼容适配；
364. 你知道的常用的 js 库有哪些？
1.moment.js 
举个例子：
用 js 转换时间戳为日期
let date = new Date(1437925575663);
 let year = date.getFullYear() + &#39;-&#39;;
 let month = ( date.getMonth() + 1 &amp;lt; 10 ? &#39;0&#39; + 
(date.getMonth() + 1) : 
date.getMonth() + 1 ) + &#39;-&#39;;
 let day = date.getDate();
...
 return year + month + day;
用 moment.js
return moment(1437925575663).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)
2.chart.js
绘制简单的柱状图，曲线图，蛛网图，环形图，饼图等完全够用，用法比较
简单。
3.D3.js
功能太强大了，看首页就知道了，感觉没有什么图 d3 绘不出来的。
4.Rx.js
308
很好的解决了异步和事件组合的问题。
5.lodash.js
365. Js 中的三种弹出式消息提醒（警告窗口、确认窗口、信息输
入窗口）的命令是什么？
alter(),confirm(),prompt()
366. 谈谈 js 的闭包
答：闭包无处不在，比如：jQuery、zepto 的核心代码都包含在一个大的闭
包中，所以下面我先写一个最简单最原始的闭包，以便让你在大脑里产生闭
包的画面：
function A()&#123; 
function B()&#123; 
console.log(&quot;Hello Closure!&quot;); 
&#125; 
return B; 
&#125; 
var C = A(); 
C();//Hello Closure!
这是最简单的闭包。
有了初步认识后，我们简单分析一下它和普通函数有什么不同，上面代码翻
译成自然语言如下：
（1）定义普通函数 A
（2）在 A 中定义普通函数 B
（3）在 A 中返回 B
（4）执行 A, 并把 A 的返回结果赋值给变量 C
309
310
（5）执行 C
把这 5 步操作总结成一句话就是：
函数 A 的内部函数 B 被函数 A 外的一个变量 c 引用。
把这句话再加工一下就变成了闭包的定义：
当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。
因此，当你执行上述 5 步操作时，就已经定义了一个闭包！
这就是闭包。
367. 写一段 js，遍历所有的 li，将每个 li 的内容逐个 alert 出来
&amp;lt;body&amp;gt;
 &lt;ul&gt;
 &lt;li&gt;张三：123&lt;/li&gt;
 &lt;li&gt;李四：456&lt;/li&gt;
 &lt;li&gt;王五：789&lt;/li&gt;
 &lt;li&gt;赵六：147&lt;/li&gt;
&lt;ul&gt;
 &amp;lt;body&amp;gt;
function test()&#123;
 var varli = document.getElementsByTagName(&quot;li&quot;);
 for (var i=0;i&amp;lt;varli.length;i++) &#123;
 alert(varli[i].innerText);
 &#125;
&#125;
368. 页面上如何用 JavaScript 对多个 checkbox 全选
//全选
function checkAll()&#123;
311
//获取复选框对象--数组对象
var varcheck = document.getElementsByName(&quot;name&quot;);
//alert(varcheck.length);
//遍历 for
for(var i=0;i&amp;lt;varcheck.length;i++)&#123;
varcheck[i].checked = true;
&#125;
&#125;
369. 写一个简单的 JQuery 的 ajax
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.9.1.js&quot; 
charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
function testJqAjax()&#123;
//url :请求地址
//type :请求的方式 get/post
//data :请求的参数(json/String)
//cache:true(走缓存 ) false(不走缓存)
//result:当 ajax 发送成功后会调用 success 后面的函数，
result：相当于形参，返回的数据
//async:是否为异步请求 默认 true 异步 , false 同步
$.ajax(&#123;
url:&quot;TestJqAjax&quot;,
type:&quot;get&quot;,
312
/* data:&quot;uname=zhangsan&amp;realname=张三丰&quot;, */
data:&#123;uname:&quot;zhangsan&quot;,realname:&quot;张三丰&quot;&#125;,
cache:false,
async:false,
success:function(result)&#123;
alert(result);
&#125;
&#125;);
&#125;
//ajax 的 get 方式的请求
function jqAjaxGet()&#123;
//url,[data],[callback](当 ajax 发送成功后调用的函数)
$.get(&quot;TestJqAjax&quot;,&#123;uname:&quot;zhangsan&quot;,realname:&quot;张三丰
&quot;&#125;,function(result)&#123;
alert(result);
&#125;);
&#125;
function jqAjaxPost() &#123;
//url,[data],[callback](当 ajax 发送成功后调用的函数)
$.post(&quot;TestJqAjax&quot;,&#123;uname:&quot;zhangsan&quot;,realname:&quot;张三
丰&quot;&#125;,function(result)&#123;
alert(result);
&#125;);
&#125;
&amp;lt;/script&amp;gt;
370. Js 截取字符串 abcdefg 的 efg
function test2()&#123;
var str = &quot;abcdefg&quot;;
var substr = str.substring(4);
313
alert(substr);
&#125;
371. http 的请求头信息包含了什么?
请求行（请求方式，资源路径，协议和协议版本号）
若干请求头
请求实体内容
372. http 的响应码 200，404，302，500 表示的含义分别是？
200 - 确定。客户端请求已成功
302 - 临时移动转移，请求的内容已临时移动新的位置
404 - 未找到文件或目录
500 - 服务器内部错误
373. Servlet 中 request 对象的方法有？
//获取网络信息
private void getNet(HttpServletRequest req, 
HttpServletResponse resp) &#123;
System.out.println(&quot;TestHttpRequest.getNet(获取客户端的
ip):&quot;+req.getRemoteAddr());
System.out.println(&quot;TestHttpRequest.getNet(获取客户端的端
口):&quot;+req.getRemotePort());
System.out.println(&quot;TestHttpRequest.getNet(获取服务器的
ip):&quot;+req.getLocalAddr());
System.out.println(&quot;TestHttpRequest.getNet(获取服务器的端
口):&quot;+req.getLocalPort());
314
&#125;
//获取实体内容
private void getContent(HttpServletRequest req, 
HttpServletResponse resp) &#123;
//获取单条信息
String uname = req.getParameter(&quot;uname&quot;);
//获取多条信息，数组格式
String[] favs = req.getParameterValues(&quot;fav&quot;);
//遍历数组
//判断
if(favs!=null&amp;&amp;favs.length&amp;gt;0)&#123;
for (int i = 0; i &amp;lt; favs.length; i++) &#123;
System.out.println(&quot;TestHttpRequest.getContent(fav):&quot;+favs[
i]);
&#125;
&#125;
String un = req.getParameter(&quot;un&quot;);
System.out.println(&quot;TestHttpRequest.getContent():&quot;+uname+&quot;-
-&quot;+favs+&quot;--&quot;+un);
&#125;
//获取请求头信息
private void getHeads(HttpServletRequest req, 
HttpServletResponse resp) &#123;
//获取单条头信息
//System.out.println(&quot;TestHttpRequest.getHeads(获取请求头
315
信息-浏览器头信息)：&quot;+req.getHeader(&quot;User-Agent&quot;));
//获取所有头信息--返回枚举类型
Enumeration strHeads = req.getHeaderNames();
//遍历枚举类型
while (strHeads.hasMoreElements()) &#123;
String strhead = (String) strHeads.nextElement();
System.out.println(&quot;TestHttpRequest.getHeads(获取头信
息):&quot;+req.getHeader(strhead));
&#125;
&#125;
//获取请求行的信息
private void getLines(HttpServletRequest req, 
HttpServletResponse resp) &#123;
System.out.println(&quot;TestHttpRequest.getLines(请求方式
***):&quot;+req.getMethod());
System.out.println(&quot;TestHttpRequest.getLines(资源路
径):&quot;+req.getRequestURI());
System.out.println(&quot;TestHttpRequest.getLines(地
址):&quot;+req.getRequestURL());
System.out.println(&quot;TestHttpRequest.getLines(协
议):&quot;+req.getScheme());
System.out.println(&quot;TestHttpRequest.getLines(协议的版本
号):&quot;+req.getProtocol());
System.out.println(&quot;TestHttpRequest.getLines(获取参数信
316
息):&quot;+req.getQueryString());
System.out.println(&quot;TestHttpRequest.getLines(项目名称
***):&quot;+req.getContextPath());
&#125;
374. Javascript 的常用对象有哪些
常用对象包括日期对象Date，字符串对象String，数组对象Array
//获取并显示系统当前时间
function testDate()&#123; 
var date = new Date();
var fmtDate = date.getFullYear()+&quot;-&quot;+(date.getMonth()+1)+
&quot;-&quot;+date.getDate()+&quot;-&quot;+date.getHours()
+&quot;:&quot;+date.getMinutes()+&quot;:&quot;+date.getSeconds();
alert(fmtDate);
&#125;
//获取出’sxt’的下标位置
function testString()&#123;
var str = &#39;welcome to beijingsxt&#39;;
alert(str.indexOf(&#39;sxt&#39;));
&#125;
//遍历数组信息
317
function testArray()&#123;
var arr = new Array(&#39;a&#39;,123,&#39;c&#39;,true,&#39;e&#39;);
for(var item in arr)&#123;
document.write(arr[item]+&quot; &quot;);
&#125;
&#125;
375. DOM 和 BOM 及其关系
BOM 浏览器对象模型，由一系列对象组成，是访问、控制、修改浏览器的属性的方法。
DOM 文档对象模型，由一系列对象组成，是访问、检索、修改 XHTML 文档内容与
结构的标准方法。
关系：
– BOM 描述了与浏览器进行交互的方法和接口
– DOM 描述了处理网页内容的方法和接口
– DOM 属于 BOM 的一个属性
376. JavaScript 中获取某个元素的三种方式 JavaScript 中的三种弹出式消
息提醒命令是什么?
window.alert() 显示一个提示信息
window.confirm() 显示一个带有提示信息、确定和取消按钮的对话框
window.prompt()显示可提示用户输入的对话框
setTimeout 与 setInterval 的区别
setTimeout 和 setInterval 的语法相同。它们都有两个参数，一个是将要执行的代码字
符串，还有一个是以毫秒为单位的时间间隔，当过了那个时间段之后就将执行那段代码。
不过这两个函数还是有区别的，setInterval 在执行完一次代码之后，经过了那个固定的
时间间隔，它还会自动重复执行代码，而 setTimeout 只执行一次那段代码。
window.setTimeout(&quot;function&quot;,time)；//设置一个超时对象，只执行一次,无周期
window.setInterval(&quot;function&quot;,time)；//设置一个超时对象，周期＝&#39;交互时间&#39;
377. JavaScript 操作 CSS 的两种方式
 第一种方式：操作元素的属性（对象.style.样式名=样式值;）
//改变直接样式
 var child2 = document.createElement(&quot;div&quot;);
 child2.innerHTML = &quot;child2&quot;;
 child2.style.fontWeight = &quot;bold&quot;;
 parent.appendChild(child2);
 第二种方式：操作元素的类（对象.className=类;）
例如：
var parent = document.getElementById(&quot;parent&quot;); 
 //改变 className
318
319
 var child0 = document.createElement(&quot;div&quot;); 
 child0.innerHTML = &quot;child0&quot;;
 child0.className = &quot;newDiv&quot;;
parent.appendChild(child0);
378. 静态网页和动态网页的联系和区别
联系：
1）静态网页是网站建设的基础，静态网页和动态网页都要使用到 HTMl 语言。
2）静态网页是相对于动态网页而言，指没有后台数据库、不含程序和不可交互的网
页、是标准的 HTML 文件，它的文件扩展名是.htm 或.html。你编的是什么它显示的就
是什么、不会有任何改变。
3）静态网页和动态网页之间并不矛盾，为了网站适应搜索引擎检索的需要，动态网
站可以采用静动结合的原则，适合采用动态网页的地方用动态网页，如果必要使用静态
网页，则可以考虑用静态网页的方法来实现，在同一个网站上，动态网页内容和静态网
页内容同时存在也是很常见的事情。
区别：
1）程序是否在服务器端运行，是重要标志。在服务器端运行的程序、网页、组件，
属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如 ASP、PHP、JSP、
ASP.net、CGI 等。运行于客户端的程序、网页、插件、组件，属于静态网页，例如 html
页、Flash、javascript、VBscript 等等，它们是永远不变的。
2）编程技术不同。静态网页和动态网页主要根据网页制作的语言来区分。静态网页
使用语言：HTML。 动态网页使用语言：HTML＋ASP 或 HTML＋PHP 或 HTML＋JSP 
等其它网站动态语言。
3）被搜索引擎收录情况不同。由于编程技术不容，静态网页是纯粹 HTML 格式的网
页，页面内容稳定，不论是网页是否被访问，页面都被保存在网站服务器上，很容易被
搜索引擎收录。而动态网页的内容是当用户点击请求时才从数据库中调出返回给用户一
个网页的内容，并不是存放在服务器上的独立文件，相比较于静态网页而言，动态网页
很难被搜索引擎收录。
4）用户访问速度不同。用户访问动态网页时，网页在获得搜索指令后经过数据库
的调查匹配，再将与指令相符的内容传递给服务器，通过服务器的编译将网页编译成标
准的 HTML 代码，从而传递给用户浏览器，多个读取过程大大降低了用户的访问速度。
而静态网页不同，由于网页内容直接存取在服务器上，省去了服务器的编译过程，用户
访问网页速度很快。
5）制作和后期维护工作量不同。动态网页的设计以数据库技术为基础，可以实现
多种功能，降低了网站维护的工作量。而静态网页由于没有数据库的支持，网页内容更
改时需要直接修改代码，在网站内容制作和维护中，所需的工作量更大。动态网页与静
态网页各有特点，网站设计师在网页设计时，主要根据网站的功能需求和网站内容多少
选择不同网页。如，网站包含信息量太大时，就需要选择动态网页，反之，则选择静态
网页。
379. JSP/ASP/PHP 的比较
 ASP(Active Server Pages),JSP(JavaServer Pages),PHP(Hypertext Preprocessor)
是目前主流的三种动态网页语言。
 ASP 是微软（Microsoft）所开发的一种后台脚本语言，它的语法和 Visual BASIC
类似，可以像 SSI（Server Side Include）那样把后台脚本代码内嵌到 HTML 页面中。
虽然 ASP 简单易用，但是它自身存在着许多缺陷，最重要的就是安全性问题。
320
 PHP 是一种跨平台的服务器端的嵌入式脚本语言。它大量地借用 C,Java 和 Perl 语
言的语法, 并耦合 PHP 自己的特性,使 WEB 开发者能够快速地写出动态产生页面。它支
持目前绝大多数数据库。
JSP 是一个简化的 Servlet，它是由 Sun 公司倡导、许多公司参与一起建立的一种动
态网页技术标准。JSP 技术有点类似 ASP 技术，它是在传统的网页 HTML 中插入 Java
程序段和 JSP 标记(tag)，从而形成 JSP 文件，后缀名为(*.jsp)。 用 JSP 开发的 Web 应
用是跨平台的，既能在 Linux 下运行，也能在其他操作系统上运行。
ASP 优点: 无需编译、易于生成、独立于浏览器、面向对象、与任何 ActiveX scripting 
语言兼容、源程序码不会外漏。
缺点:
1）Windows 本身的所有问题都会一成不变的也累加到了它的身上。安全性、稳定
性、跨平台性都会因为与 NT 的捆绑而显现出来。
2）ASP 由于使用了 COM 组件所以它会变的十分强大，但是这样的强大由于
Windows NT 系统最初的设计问题而会引发大量的安全问题。只要在这样的组件或是操
作中一不注意，那么外部攻击就可以取得相当高的权限而导致网站瘫痪或者数据丢失。
3）还无法完全实现一些企业级的功能：完全的集群、负载均横。
PHP 优点：
 1）一种能快速学习、跨平台、有良好数据库交互能力的开发语言。
 2）简单轻便，易学易用。
 3 ) 与 Apache 及其它扩展库结合紧密。
321
缺点：
 1 ) 数据库支持的极大变化。
 2 ) 不适合应用于大型电子商务站点。
JSP 优点：
 1 ) 一处编写随处运行。
 2 ) 系统的多台平支持。
 3 ) 强大的的可伸缩性。
 4 ) 多样化和功能强大的开发工具支持。
缺点：
 1） 与 ASP 一样，Java 的一些优势正是它致命的问题所在。
 2 ) 开发速度慢
380. CGI/Servlet/JSP 的比较
CGI(Common Gateway Interface)，通用网关接口,是一种根据请求信息动态产生回
应内容的技术。
通过 CGI，Web 服务器可以将根据请求不同启动不同的外部程序，并将请求内容转
发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于
每个请求，都要产生一个新的进程进行处理。
Servlet 是在服务器上运行的小程序。在实际运行的时候 Java Servlet 与 Web 服务
器会融为一体。与 CGI 不同的是，Servlet 对每个请求都是单独启动一个线程，而不是进
程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。322
比较：
1） JSP 从本质上说就是 Servlet。JSP 技术产生于 Servlet 之后，两者分工协
作，Servlet 侧重于解决运算和业务逻辑问题，JSP 则侧重于解决展示问题。
2 ) 与 CGI 相比，Servlet 效率更高。Servlet 处于服务器进程中，它通过多线
程方式运行其 service 方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。
而 CGI 对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于 Servlet 。
3）与 CGI 相比，Servlet 更容易使用，功能更强大，具有更好的可移植性，更节
省投资。在未来的技术发展过程中，Servlet 有可能彻底取代 CGI。1.  HTTP 协议工作原理及其特点
超文本传输协议（HTTP：Hypertext Transport Protocol）是万维网应用层的协议，
它通过两个程序实现：一个是客户端程序（各种浏览器），另一个是服务器 （常称 Web
服务器）。这两个通常运行在不同的主机上，通过交换报文来完成网页请求和响应，报文
可简单分为请求报文和响应报文。
工作原理（流程）：
客户机与服务器建立连接后，浏览器可以向 web 服务器发送请求并显示收到的网页，
当用户在浏览器地址栏中输入一个 URL 或点击一个超连接时，浏览器就向服务器发出了
HTTP 请求，请求方式的格式为：统一资源标识符、协议版本号，后边是 MIME
（Multipurpose Internet Mail Extensions）信息包括请求修饰符、客户机信息和可能
的内容。该请求被送往由 URL 指定的 WEB 服务器，WEB 服务器接收到请求后，进行相
应反映，其格式为：一个状态行包括信息的协议版本号、一个成功或错误的代码，后边
服务器信息、实体信息和可能的内容。即以 HTTP 规定的格式送回所要求的文件或其他
323
相关信息，再由用户计算机上的浏览器负责解释和显示。
特点：
1）支持客户/服务器模式。
2）简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的
有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP
协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
3）灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以
标记。
4）无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，
并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5）无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺
少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接
传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
2.  get 和 post 的区别
3.  Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中；Post 的所有操作对用
户来说都是不可见的。
4.  Get 传送的数据量较小，这主要是因为受 URL 长度限制；Post 传送的数据量较大，一
324
般被默认为不受限制。
5.  Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字
符集。
6.  Get 执行效率却比 Post 方法好。Get 是 form 提交的默认方法。
7.  如何解决表单提交的中文乱码问题
1）设置页面编码，若是 jsp 页面，需编写代码
&lt;%@page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;
contentType=&quot;text/html;charset=UTF-8&quot; %&gt;
若是 html 页面，在网页头部（\&lt;head&gt;\&lt;/head&gt;）中添加下面这段代码
\&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;2）将 form 表单提交方式变为 post 方式，即添加 method=&quot;post&quot;；）在 Servlet 类中
编写代码 request.setCharacterEncoding(&quot;UTF-8&quot;)，而且必须写在第一行。
3）如果是 get 请求，在 Servlet 类中编写代码
byte \[] bytes = str.getBytes(&quot;iso-8859-1&quot;);
String cstr = new String(bytes,&quot;utf-8&quot;);
或者直接修改 Tomcat 服务器配置文件 server.xml 增加内容：
URIEncoding=&quot;utf-8&quot;1.  绝对路径、根路径、相对路径的含义及其区别
绝对路径指对站点的根目录而言某文件的位置，相对路径指以当前文件所处目录而
言某文件的位置,相对路径-以引用文件之网页所在位置为参考基础，而建立出的目录路
径。绝对路径-以 Web 站点根目录为参考基础的目录路径。
325
先给出一个网站结构图做实例加深理解，A 网站（域名为 &lt;http://www.a.com）：&gt;
/include/a-test.html，/img/a-next.jpg；B 网站（域名为 &lt;http://www.b.com）：&gt;
/include/b-test.html，/img/b-next.jpg。
相对路径是从引用的网页文件本身开始构建的，如果在 A 网站中的 a-test.html 中要
插入图片 a-next.jpg，可以这样做:&lt;img src=&quot;../img/a-next.jpg&quot; /&gt;，重点是 img 前
面的../，表示从 html 处于的 include 开始起步，输入一个../表示回到上面一级父文件夹
下，然后再接着 img/表示又从父级文件夹下的 img 文件开始了，最后定位 img 下面的
next.jpg。
根路径是从网站的最底层开始起，一般的网站的根目录就是域名下对应的文件夹，就
如 D 盘是一个网站，双击 D 盘进入到 D 盘看到的就是网站的根目录，这种路径的链接
样式是这样的：如果在 A 网站中的 a-test.html 中要插入图片 a-next.jpg，可以这样
做:&lt;img src=&quot;/img/a-next.jpg&quot;&gt;，以/开头表示从网站根目录算起，找到根目录下面
的 img 文件夹下的 next.jpg。
绝对路径就很好理解了，这种路径一般带有网站的域名，如果在 A 网站中的
a-test.html 中要插入图片 a-next.jpg，需要这样这样写:&lt;img src=&quot;http://www.a.com/img/a-next.jpg&quot;&gt;，将图片路径上带有了域名信息，再打个
比方：如果在 A 网站中的 a-test.html 中要插入 B 网站的图片 b-next.jpg，就需要这样
写：&lt;img src=&quot;http://www.b.com/img/b-next.jpg&quot;&gt;，这种方法适用与在不同网站
之间插入外部网站的图片。
2.  如实现 servlet 的单线程模式
实现 servlet 的单线程的 jsp 命令是： &lt;%@ page isThreadSafe=”false”%&gt;。
326
默认 isThreadSafe 值为 true。
属性isThreadSafe=false模式表示它是以Singleton模式运行，该模式implements
了接口 SingleThreadMode, 该模式同一时刻只有一个实例，不会出现信息同步与否的
概念。若多个用户同时访问一个这种模式的页面，那么先访问者完全执行完该页面后，
后访问者才开始执行。
属性 isThreadSafe=true 模式表示它以多线程方式运行。该模式的信息同步，需访
问同步方法(用 synchronized 标记的)来实现。 一般格式如下：
public synchronized void syncmethod(...)&#123;
while(...) &#123;
this.wait();
&#125;
this.notifyAll();
&#125;
3.  Servlet 的生命周期
1、加载：在下列时刻加载 Servlet：（1）如果已配置自动加载选项，则在启动服务器时
自动 2、加载 (web.xml 中设置\&lt;load-on-start&gt;)；（2）在服务器启动后，客户机首次
向 Servlet 发出请求时;（3）重新加载 Servlet 时（只执行一次）
3、实例化：加载 Servlet 后，服务器创建一个 Servlet 实例。（只执行一次）
4、初始化：调用 Servlet 的 init() 方法。在初始化阶段，Servlet 初始化参数被传递给
Servlet 配置对象 ServletConfig。 （只执行一次）
5、请求处理：对于到达服务器的客户机请求，服务器创建针对此次请求的一个“请求”
327
对象和一个“响应”对象。服务器调用 Servlet 的 service() 方法，该方法用于传递“请
求”和“响应”对象。service() 方法从“请求”对象获得请求信息、处理该请求并用“响
应”对象的方法以将响应传回客户机。service() 方法可以调用其它方法来处理请求，例
如 doGet()、doPost() 或其它的方法。（每次请求都执行该步骤）
6、销毁：当服务器不再需要 Servlet, 或重新装入 Servlet 的新实例时，服务器会调用
Servlet 的 destroy() 方法。（只执行一次）
4.  转发和重定向的区别
转发是在服务端直接做的事情，是对客户端的同一个 request 进行传递，浏览器并不知
道。重定向是由浏览器来做的事情。重定向时，服务端返回一个 response，里面包含了
跳转的地址，由浏览器获得后，自动发送一个新 request。转发像呼叫转移或者 110 报
警中心，重定向似 114 查号台。
a) 区别 1:跳转效率的不同
328
转发效率相对高；重定向效率相对低
b) 区别 2:实现语句不同
转发 request.getRequestDispatcher(&quot;xxxx&quot;).forward(request,response) ;
重定向 response.sendRedirect(&quot;xxxx&quot;)
c) 区别 3:是否共有同一个 request 的数据
转发源组件与目标组件共有同一个 request 数据
重定向源组件与目标组件不共有同一个 request 数据（可使用 session 共有数据）
d) 区别 4:浏览器 URL 地址的不同
转发后浏览器 URL 地址保持不变（源组件地址）
重定向后浏览器 URL 地址改变为重定向后的地址（目标组件地址）
e) 区别 5:&quot;/&quot;路径的含义不同
转发时&quot;/&quot;代表当前项目的根路径 ；重定向时&quot;/&quot;代表当前服务器的根路径
f) 区别 6:跳转范围的不同
只能转发到同一应用中的 URL（默认） ；可以重定向任何服务器、任何应用的 URL
g) 区别 7:刷新是否导致重复提交
转发会导致重复提交(可以通过同步令牌解决)；重定向不会导致重复提交
h) 区别 8:是否经过过滤器
转发不经过过滤器（默认情况）；重定向经过过滤器
5.  JSP 的执行过程
在 JSP 运行过程中，首先由客户端发出请求，Web 服务器接收到请求后，如果是第一次
访问某个 jsp 页面，Web 服务器对它进行以下 3 个操作。
329
1.  翻译：由.jsp 变为.java,由 JSP 引擎实现。
2.  编译：由.java 变为.class,由 Java 编译器实现。
3.  执行：由.class 变为.html,用 Java 虚拟机执行编译文件,然后将执行结果返回给 Web
服务器，并最终返回给客户端
如果不是第一次访问某个 JSP 页面，则只执行第三步。所以第一次访问 JSP 较慢。1.  JSP 动作有哪些,简述作用?
jsp\:include：在页面被请求的时候引入一个文件。
jsp\:useBean：寻找或者实例化一个 JavaBean。 jsp\:setProperty：设置 JavaBean 的属
性。
jsp\:getProperty：输出某个 JavaBean 的属性。
jsp\:forward：把请求转到一个新的页面。 jsp\:plugin：根据浏览器类型为 Java 插件生
成 OBJECT 或 EMBED 标记。
2.  page/request/session/application 作用域区别
page：当前页面范围
request：当前页面范围+转发页面（forward）+包含页面（include）
session：当前会话：session 在以下几种情况下失效1.  销毁 session：Session.invalidate();
2.  超过最大非活动间隔时间
3.  手动关闭浏览器（session 并没有立刻失效，因为服务器端 session 仍旧存在，超过
最大非活动间隔时间后真正失效）
application：当前应用；服务器重新启动前一直有效
330
1.  JSP 和 Servlet 的区别和联系
区别：1.  JSP 是在 HTML 代码里写 JAVA 代码,框架是 HTML;而 Servlet 是在 JAVA 代码中写
HTML 代码，本身是个 JAVA 类。
2.  JSP 使人们把显示和逻辑分隔成为可能，这意味着两者的开发可并行进行；而 Servlet
并没有把两者分开。
3.  Servlet 独立地处理静态表示逻辑与动态业务逻辑.这样,任何文件的变动都需要对此
服务程序重新编译;JSP 允许用特殊标签直接嵌入到 HTML 页面, HTML 内容与 JAVA
内容也可放在单独文件中,HTML 内容的任何变动会自动编译装入到服务程序.
4.  Servlet 需要在 web.xml 中配置，而 JSP 无需配置。
5.  目前 JSP 主要用在视图层，负责显示，而 Servlet 主要用在控制层，负责调度
联系：
6.  都是 Sun 公司推出的动态网页技术。
7.  先有 Servlet，针对 Servlet 缺点推出 JSP。JSP 是 Servlet 的一种特殊形式，每个 JSP
页面就是一个 Servlet 实例——JSP 页面由系统翻译成 Servlet，Servlet 再负责响应
用户请求。1.  谈谈过滤器原理及其作用?
原理:
⚫ 过滤器是运行在服务器端的一个拦截作用的 web 组件，一个请求来到时，web 容器
会判断是否有过滤器与该信息资源相关联，如果有则交给过滤器处理，然后再交给目
标资源，响应的时候则以相反的顺序交给过滤器处理，最后再返回给用户浏览器
331
⚫ 一般用于日志记录、性能、安全、权限管理等公共模块。
过滤器开发:
⚫ 过滤器是一个实现了 javax.servlet.Filter 接口的 java 类
⚫ 主要业务代码放在 doFilter 方法中
⚫ 业务代码完成后要将请求向后传递，即调用 FilterChain 对象的 doFilter 方法
配置:
在web.xml中增加如下代码
\&lt;filter&gt;\&lt;filter-name&gt;MyFilter\&lt;/filter-name&gt; \&lt;filter-class&gt;Filter完整类名\&lt;/filter-class&gt; \&lt;/filter&gt; \&lt;filter-mapping&gt; \&lt;filter-name&gt;MyFilter\&lt;/filter-name&gt; \&lt;url-pattern&gt;/*(要过虑的url，此处*表示过虑所有的
url)\&lt;/url-pattern&gt; \&lt;/filter-mapping&gt;
谈谈监听器作用及其分类?
监听器也叫 Listener，是一个实现特定接口的 java 类，使用时需要在 web.xml 中配置，
它是 web 服务器端的一个组件，它们用于监听的事件源分别为
SerlvetConext,HttpSession 和 ServletRequest 这三个域对象
主要有以下三种操作:
– 监听三个域对象创建和销毁的事件监听器
– 监听域对象中属性的增加和删除的事件监听器
– 监听绑定到 HttpSession 域中的某个对象的状态的时间监听器
332
接口分类:
– ServletContextListener
– HttpSessionListener
– ServletRequestListener
– ServletContextAttributeListener
– HttpSessionAttributeListener
– ServletRequestAttributeListener
– HttpSessionBindingListener(不需要配置)
– HttpSessionActivationListener(不需要配置)
配置： \&lt;listener&gt;\&lt;listener-class&gt;实现以上任意接口的 java 类全名 \&lt;/listener-class&gt;\&lt;/listener&gt;1.  jQuery 相比 JavaScript 的优势在哪里
jQuery 的语法更加简单。
jQuery 消除了 JavaScript 跨平台兼容问题。
相比其他 JavaScript 和 JavaScript 库，jQuery 更容易使用。
jQuery 有一个庞大的库/函数。
jQuery 有良好的文档和帮助手册。
jQuery 支持 AJAX
2.  DOM 对象和 jQuery 对象的区别及其转换
DOM 对象，是我们用传统的方法(javascript)获得的对象，jQuery 对象即是用 jQuery
333
类库的选择器获得的对象，它是对 DOM 对象的一种封装，jQuery 对象不能使用 DOM
对象的方法，只能使用 jQuery 对象自己的方法。
普通的 dom 对象一般可以通过`$()转换成 jquery 对象
如：var cr=document.getElementById(&quot;cr&quot;); //dom 对象
var $`cr = `$(cr); //转换成 jquery 对象
由于 jquery 对象本身是一个集合。所以如果 jquery 对象要转换为 dom 对象则必须取出
其中的某一项，一般可通过索引取出
如：$`(&quot;#msg&quot;)\[0]，`$(&quot;div&quot;).eq(1)[0]，$`(&quot;div&quot;).get()\[1]，\$(&quot;td&quot;)\[5]这几种语法在 jQuery
中都是合法的
3.  jQuery 中\$的作用主要有哪些1.  `$用作选择器
例如:根据 id 获得页面元素$`(&quot;#元素 ID&quot;)
2.  `$相当于 window.onload 和 $`(document).ready(...)
例如:\$(function()&#123;...&#125;); function()&#123;...&#125;会在 DOM 树加载完毕之后执行。
3.  `$用作 JQuery 的工具函数的前缀
例如： var str = &#39; Welcome to shanghai.com &#39;;
str = $`.trim(str);去掉空格
4.  `$(element)：把 DOM 节点转化成 jQuery 节点
例如：var cr=document.getElementById(&quot;cr&quot;); //dom 对象
var $`cr = `$(cr); //转换成 jquery 对象
5）$`(html)：使用 HTML 字符串创建 jQuery 节点
334
例如：var obj = \$(&quot;&lt;div&gt;尚学堂，实战化教学第一品牌&lt;/div&gt;&quot;)1.  Ajax 含义及其主要技术
Ajax (Asynchronous JavaScript and XML 阿贾克斯)不是一个新的技术，事实上，它
是一些旧有的成熟的技术以一种全新的更加强大的方式整合在一起。
Ajax 的关键技术：1.  使用 CSS 构建用户界面样式，负责页面排版和美工
2.  使用 DOM 进行动态显示和交互，对页面进行局部修改
3.  使用 XMLHttpRequest 异步获取数据
4.  使用 JavaScript 将所有元素绑定在一起1.  Ajax 的工作原理
Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得
数据，然后用 javascript 来操作 DOM 而更新页面。这其中最关键的一步就是从服务器
获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest 有所了解。
XMLHttpRequest 是 ajax 的核心机制，它是在 IE5 中首先引入的，是一种支持异步请求
的技术。简单的说，也就是 javascript 可以及时向服务器提出请求和处理响应，而不阻
塞用户。达到无刷新的效果。
2.  JSON 及其作用
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，采用完全独立于语
言的文本格式，是理想的数据交换格式。同时，JSON 是 JavaScript 原生格式，这意味
着在 JavaScript 中处理 JSON 数据不须要任何特殊的 API 或工具包。
在 JSON 中，有两种结构：对象和数组。
335
➢ &#123;&#125; 对象
➢ \[] 数组
➢ , 分隔属性
➢ : 左边为属性名，右边为属性值
属性名可用可不用引号括起，属性值为字符串一定要用引号括起
举例：
varo=&#123;
&quot;xlid&quot;: &quot;cxh&quot;,
&quot;xldigitid&quot;: 123456,
&quot;topscore&quot;: 2000,
&quot;topplaytime&quot;: &quot;2009-08-20&quot;
&#125;；
jsonranklist=\[
&#123;
&quot;xlid&quot;: &quot;cxh&quot;,
&quot;xldigitid&quot;: 123456,
&quot;topscore&quot;: 2000,
&quot;topplaytime&quot;: &quot;2009-08-20&quot;
&#125;,
&#123;
&quot;xlid&quot;: &quot;zd&quot;,
&quot;xldigitid&quot;: 123456,
&quot;topscore&quot;: 1500,
&quot;topplaytime&quot;: &quot;2009-11-20&quot;
&#125;
];
3.  文件上传组件 Common-fileUpload 的常用类及其作用？
DiskFileItemFactory：磁盘文件工厂类，设置上传文件保存的磁盘目录，缓冲区大小。
336
ServletFileUpload：上传处理类，此类真正读取客户上传的文件，同时可以设置最大接
收大小。
FileItem：上传的文件对象，可以是多个文件，每个上传的文件都是一个单独的 FileItem
对象。
4.  说出 Servlet 的生命周期，并说出 Servlet 和 CGI 的区别?
答：Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init()
方法进行 Servlet 的初始化；请求到达时调用 Servlet 的 service 方法，service 方法会
调用与请求对应的 doGet 或 doPost 等方法；当服务器关闭会项目被卸载时服务器会将
Servlet 实例销毁，此时会调用 Servlet 的 destroy 方法。Servlet 与 CGI 的区别在于
Servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个实例可以服务
于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，服务完成
后就销毁，所以效率上低于 Servlet。
【补充 1】SUN 公司在 1996 年发布 Servlet 技术就是为了和 CGI 进行竞争，Servlet
是一个特殊的 Java 程序，一个基于 Java 的 Web 应用通常包含一个或多个 Servlet 类。
Servlet 不能够自行创建并执行，它是在 Servlet 容器中运行的，容器将用户的请求传递
给 Servlet 程序，此外将 Servlet 的响应回传给用户。通常一个 Servlet 会关联一个或多
个 JSP 页面。以前 CGI 经常因为性能开销上的问题被诟病，然而 Fast CGI 早就已经解决
了 CGI 效率上的问题，所以面试的时候大可不必诟病 CGI，腾讯的网站就使用了 CGI 技
术，相信你也没感觉它哪里不好。
【补充 2】Servlet 接口定义了 5 个方法，其中前三个方法与 Servlet 生命周期相关：
void init(ServletConfig config) throws ServletException
337
void service(ServletRequest req, ServletResponse resp) throws ServletException,
java.io.IOException
void destory()
java.lang.String getServletInfo()
ServletConfig getServletConfig()
5.  JSP 和 Servlet 有有什么关系？
答：其实这个问题在上面已经阐述过了，Servlet 是一个特殊的 Java 程序，它运行于服
务器的 JVM 中，能够依靠服务器的支持向浏览器提供显示内容。JSP 本质上是 Servlet
的一种简易形式， JSP 会被服务器处理成一个类似于 Servlet 的 Java 程序，可以简化页
面内容的生成。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文
件中，并且完全从表示层中的 HTML 分离开来。而 JSP 的情况是 Java 和 HTML 可以组
合成一个扩展名为.jsp 的文件（有人说，Servlet 就是在 Java 中写 HTML，而 JSP 就是
在 HTML 中写 Java 代码，当然，这个说法还是很片面的）。JSP 侧重于视图，Servlet
更侧重于控制逻辑，在 MVC 架构模式中，JSP 适合充当视图（view）而 Servlet 适合充
当控制器（controller）。
7.  如何实现 JSP 或 Servlet 的单线程模式？
&lt;%@page isThreadSafe=”false”%&gt;
【补充】Servlet 默认的工作模式是单实例多线程，如果 Servlet 实现了标识接口
SingleThreadModel 又或是 JSP 页面通过 page 指令设置 isThreadSafe 属性为 false，
那么它们生成的 Java 代码会以单线程多实例方式工作。显然，这样做会导致每个请求创
建一个 Servlet 实例，这种实践将导致严重的性能问题。
9.  过滤器有哪些作用和用法？
答： Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在
Servlet 2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web
340
组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当
Web 容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果
有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或
者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响
应时候，容器同样会将响应先转发给过滤器，再过滤器中，你可以对响应的内容进行转
换，然后再将响应发送到客户端。
常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和
审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少
传输量、对请求或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT
等。
和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain
11. 你的项目中使用过哪些 JSTL 标签？
答：项目中主要使用了 JSTL 的核心标签库，包括\&lt;c\:if&gt;、\&lt;c\:choose&gt;、\&lt;c: when&gt;、
\&lt;c: otherwise&gt;、\&lt;c\:forEach&gt;等，主要用于构造循环和分支结构以控制显示逻辑。
【说明】虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库，但是实际开发中建议
只使用核心标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），
这样才能真正做到数据显示和业务逻辑的分离，这才是最佳实践。
12. 使用标签库有什么好处？如何自定义 JSP 标签？
答：使用标签库的好处包括以下几个方面：
分离 JSP 页面的内容和逻辑，简化了 Web 开发；
开发者可以创建自定义标签来封装业务逻辑和显示逻辑；
标签具有很好的可移植性、可维护性和可重用性；
避免了对 Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在 JSP 中书写小脚
本）
自定义 JSP 标签包括以下几个步骤：
编写一个 Java 类实现实现 Tag/BodyTag/IterationTag 接口(通常不直接实现这些接口而
是继承 TagSupport/BodyTagSupport/SimpleTagSupport 类，这是对适配器模式中缺
省适配模式的应用)
重写 doStartTag()、doEndTag()等方法，定义标签要完成的功能
342
编写扩展名为 tld 的标签描述文件对自定义标签进行部署，tld 文件通常放在 WEB-INF
文件夹或其子目录
在 JSP 页面中使用 taglib 指令引用该标签库
【注意】如果要将自定义的标签库发布成 JAR 文件，需要将标签库描述文件（tld 文件）
放在 JAR 文件的 META-INF 目录下，可以 JDK 自带的 jar 工具完成 JAR 文件的生成。
409. 表达式语言（EL）的隐式对象及其作用？
答：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、
header（访问请求头）、headerValues、cookie（访问 cookie）、applicationScope（访
问 application 作用域）、sessionScope（访问 session 作用域）、requestScope（访问
request 作用域）、pageScope（访问 page 作用域）。用法如下所示：
$&#123;pageContext.request.method&#125;
$&#123;pageContext[&quot;request&quot;][&quot;method&quot;]&#125;
$&#123;pageContext.request[&quot;method&quot;]&#125;
$&#123;pageContext[&quot;request&quot;].method&#125;
348
$&#123;initParam.defaultEncoding&#125;
$&#123;header[&quot;accept-language&quot;]&#125;
$&#123;headerValues[&quot;accept-language&quot;][0]&#125;
$&#123;cookie.jsessionid.value&#125;
$&#123;sessionScope.loginUser.username&#125;
【补充】表达式语言的.和[]运算作用是一致的，唯一的差别在于如果访问的属性名不符合
Java 标识符命名规则，例如上面的 accept-language 就不是一个有效的 Java 标识符，
那么这时候就只能用[]运算符而不能使用.获取它的值
410. 表达式语言（EL）支持哪些运算符？
答：除了.和[]运算符，EL 还提供了：
算术运算符：+、-、*、/或 div、%或 mod
关系运算符：==或 eq、!=或 ne、&amp;gt;或 gt、&amp;gt;=或 ge、&amp;lt;或 lt、&amp;lt;=或 le
逻辑运算符：&amp;&amp;或 and、||或 or、!或 not
条件运算符：$&#123;statement? A : B&#125;（跟 Java 的条件运算符类似）
empty 运算符：检查一个值是否为 null 或者空（数组长度为 0 或集合中没有元素也返回
true）
411. Servlet 3 中的异步处理指的是什么？
答：在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，
既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时
间相当长，那么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用
户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而
349
后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应
用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不
需要得到结果则直接将一个 Runnable 对象交给 Executor（如果不清楚请查看前文关于
多线程和线程池的部分）并立即返回即可。
【补充】多线程在 Java 诞生初期无疑是一个亮点，而 Servlet 单实例多线程的工作方式
也曾为其赢得美名，然而技术的发展往往会颠覆我们很多的认知，就如同当年爱因斯坦
的相对论颠覆了牛顿的经典力学一般。事实上，异步处理绝不是 Serlvet 3 首创，如果你
了解 Node.js 的话，对 Servlet 3 的这个重要改进就不以为奇了。
412. 如何在基于 Java 的 Web 项目中实现文件上传和下载？
答：（稍后呈现，我准备用 HTML5 写一个带进度条的客户端，然后再用 Servlet 3 提供
的文件上传支持来做一个多文件上传的例子）
413. 简述值栈(Value-Stack)的原理和生命周期
答： Value-Stack 贯穿整个 Action 的生命周期，保存在 request 作用域中，所以它和
request 的生命周期一样。当 Struts 2 接受一个请求时，会创建 ActionContext、
Value-Stack 和 Action 对象，然后把 Action 存放进 Value-Stack，所以 Action 的实例
变量可以通过 OGNL 访问。由于 Action 是多实例的，和使用单例的 Servlet 不同， 每
个 Action 都有一个对应的 Value-Stack，Value-Stack 存放的数据类型是该 Action 的实
例，以及该 Action 中的实例变量，Action 对象默认保存在栈顶。
414. 阐述 Session 加载实体对象的过程。
答：Session 加载实体对象的步骤是：
① Session 在调用数据库查询功能之前, 首先会在缓存中进行查询, 在一级缓存中, 通
350
过实体类型和主键进行查找, 如果一级缓存查找命中且数据状态合法, 则直接返回
③ 如果一级缓存没有命中, 接下来 Session 会在当前 NonExists 记录(相当于一个查询
黑名单, 如果出现重复的无效查询可以迅速判断, 从而提升性能)中进行查找, 如果
NonExists 中存在同样的查询条件,则返回 null
③ 对于 load 方法, 如果一级缓存查询失败则查询二级缓存, 如果二级缓存命中则直接
返回
④ 如果之前的查询都未命中, 则发出 SQL 语句, 如果查询未发现对应记录则将此次查询
添加到 Session 的 NonExists 中加以记录, 并返回 null
⑤ 根据映射配置和 SQL 语句得到 ResultSet,并创建对应的实体对象
⑥ 将对象纳入 Session(一级缓存)管理
⑦ 执行拦截器的 onLoad 方法(如果有对应的拦截器)
⑧将数据对象纳入二级缓存
⑨返回数据对象
415. 怎么防止重复提交
1.禁掉提交按钮。表单提交后使用 Javascript 使提交按钮 disable。这种方法防止心急的
用户多次点击按钮。但有个问题，如果客户端把 Javascript 给禁止掉，这种方法就无效
了。
2.Post/Redirect/Get 模式。在提交后执行页面重定向，这就是所谓的
Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的
重定向，转到提交成功信息页面。
这能避免用户按 F5 导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能
351
352
消除按浏览器前进和后退按导致的同样问题。
3.在 session 中存放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，
存在 session 中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否
存在，并立即从 session 中删除它，然后正常处理数据。
如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。
4.在数据库里添加约束。在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。
这是最有效的防止重复提交数据的方法。
416. $(document).ready(function()&#123;&#125;) 
jQuery(document).ready(function()&#123;&#125;); 有什么区别？
window.jQuery = window.$ = jQuery;
这两者可以互换使用。一般建议优先使用$
417. 写出输出结果
&amp;lt;script&amp;gt;
function Foo() &#123;
getName = function ()&#123;alert(1);&#125;; 
return this;
&#125;
Foo.getName = function() &#123;alert (2);&#125;; 
Foo.prototype.getName = function ()&#123; alert (3);&#125;;
var getName = function ()&#123;alert (4);&#125;; 
function getName()&#123;alert (5);&#125;
&amp;lt;/script&amp;gt;
//请写出以下输出结果：
Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1
353
getName(); // 1
new Foo.getName(); // 2 
new Foo().getName(); // 3 
new new Foo().getName(); // 3
418. web 项目从浏览器发起交易响应缓慢，请简述从哪些方面如数分析
从前端后端分别取考虑，后台是不是数据库死锁等。
前台看看是不是 js 错误，或者图片过大，dom 渲染 dom 树，画面优化。cmd amd 规
范等
设计模式：
431. 什么是 Maven？
Maven 使用项目对象模型(POM)的概念，可以通过一小段描述信息来管理项目的构建，
371
报告和文档的软件项目管理工具。
Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的
缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项
目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发布时使用 Maven，而
且公司项目采用 Maven 的比例在持续增长。
Maven 的出现，解决了开发过程中的 jar 包升级及依赖的难题。它可以对项目依赖的 jar
包进行管理，可以让你的项目保持基本的依赖，排除冗余 jar 包，并且可以让你非常轻松的
对依赖的 jar 包进行版本升级。而这些仅仅是 Maven 最基本的功能，它可以在这基础上对项
目进行清理、编译、测试、打包、发布等等构建项目的工作。
可以说，Maven 是现在 Java 社区中最强大的项目管理和项目构建工具，而更加值得庆幸的
是，这样一个强大的工具，它的使用也是非常简单的。
现在，JavaEE 项目使用的开源软件都可以通过 Maven 来获取，并且，越来越多的公司
也开始使用 Maven 来管理构建项目了。
432. Maven 和 ANT 的区别
1.maven&amp;ant 同属 apach 是流行的构建工具。
都是为了简化软件开发而存在的。但是 maven 因为自身管理一个项目对象模型（project 
object model），这个模型其实就是抽象了一个项目的开发流程，它包含了一个项目的生命
周期的各个阶段，并将这个周期固定下来，这也就是约定大于配置。约定大于配置的意思就
是，我 maven 将项目开发的各个阶段固定起来了，每个文件的存放位置，每个阶段要生成
什么文件、保存为什么格式并且要把它放在什么位置，我都固定好了。我知道一个软件是怎
372
么开发出来，如果一个项目要使用 maven，可以，但你要遵循我的规则，文件目录不要乱建
乱放，只有这样 maven 才会将源码用起来。这就是约定大于配置，因为 maven 已经将流程
固定下来了，只要遵守约定，就不需要自己手动去配置了，这将大大地提高开发效率。
就像是开车一样，只要知道点火、油门、方向、刹车，就可以将车子开东起来（当然出于安
全和法律考虑，还是要考驾照的。），关于车子内部的传动原理，电气原理，工程原理，普通
人并不需要了解多少，日常够用就好了。这也是约定大于配置的一个例子。配置就是自己造
一辆车去开，有必要，有能力，有时间吗？
2.maven 的中央仓库和 pom.xml 文件。中央仓库统一存放了开发用到的各种 jar 包，要用
时只需要添加依赖到 pom 文件中，maven 就会自动下载，当然为了方便一般会在本地建一
个仓库，减少下载时间。pom 文件是 maven 的配置文件，maven 就是通过管理 pom 文件
和一些核心插件来管理项目。当然我前面将 maven 拟人化了，其实 maven 是没有智力的，
一切都是封装好的流程，只是 maven 将很多操作隐藏起来了。
3.ant 的 build.xml 文件。build 文件是 ant 的配置文件，ant 依靠它来执行操作，与 maven
不同的是 ant 没有固定一条程序链。你想要执行什么操作以及操作之间的顺序和依赖关系，
都需要手动添加到 build 文件中，一点一滴都要写清楚，否则 ant 就不会执行。
4.maven 和 ant 区别
Maven 拥有约定，只要遵守约定，它就知道你的源代码在哪里。Maven 是声明式的。你需
要做的只是创建一个 pom.xml 文件然后将源代码放到默认的目录。Maven 会帮你处理其
它的事情。Maven 有一个生命周期，当你运行 mvn install 的时候被调用。这条命令告诉
Maven 执行一系列的有序的步骤，直到到达你指定的生命周期。缺点是运行许多默认目标。
而 ant 没有约定，项目生命周期，它是命令式的。所有操作都要手动去创建、布置。甚至连
373
build.xml 文件都需要手动创建。
433. Maven 仓库是什么
Maven 仓库是基于简单文件系统存储的，集中化管理 Java API 资源（构件）的一个
服务。仓库中的任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯
一存储路径。得益于 Maven 的坐标机制，任何 Maven 项目使用任何一个构件的方式
都是完全相同的，Maven 可以在某个位置统一存储所有的 Maven 项目共享的构件，这
个统一的位置就是仓库，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其
它项目使用。
对于 Maven 来说，仓库分为两类：本地仓库和远程仓库。
434. Maven 的工程类型有哪些？
POM 工程
POM 工程是逻辑工程。用在父级工程或聚合工程中。用来做 jar 包的版本控制。
JAR 工程
将会打包成 jar 用作 jar 包使用。即常见的本地工程 - Java Project。
WAR 工程
将会打包成 war，发布在服务器上的工程。如网站或服务。即常见的网络工程 -
Dynamic Web Project。war 工程默认没有 WEB-INF 目录及 web.xml 配置文件，IDE
通常会显示工程错误，提供完整工程结构可以解决。
435. Maven 常用命令有哪些？
install
本地安装， 包含编译，打包，安装到本地仓库
374
编译 - javac
打包 - jar， 将 java 代码打包为 jar 文件
安装到本地仓库 - 将打包的 jar 文件，保存到本地仓库目录中。
clean
清除已编译信息。
删除工程中的 target 目录。
compile
只编译。 javac 命令
deploy
部署。 常见于结合私服使用的命令。
相当于是 install+上传 jar 到私服。
包含编译，打包，安装到本地仓库，上传到私服仓库。
package
打包。 包含编译，打包两个功能。
436. ZooKeeper 的作用是什么？
配置管理
在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等。一般我们
都是使用配置文件的方式，在代码中引入这些配置文件。当我们只有一种配置，只有一
台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配
置非常多，有很多服务器都需要这个配置，这时使用配置文件就不是个好主意了。这个
时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有
375
对这个配置感兴趣的都可以获得变更。Zookeeper 就是这种服务，它使用 Zab 这种一致
性协议来提供一致性。现在有很多开源项目使用 Zookeeper 来维护配置，比如在 HBase
中，客户端就是连接一个 Zookeeper，获得必要的 HBase 集群的配置信息，然后才可
以进一步操作。还有在开源的消息队列 Kafka 中，也使用 Zookeeper 来维护 broker 的
信息。在 Alibaba 开源的 SOA 框架 Dubbo 中也广泛的使用 Zookeeper 管理一些配置
来实现服务治理。
名字服务
名字服务这个就很好理解了。比如为了通过网络访问一个系统，我们得知道对方的
IP 地址，但是 IP 地址对人非常不友好，这个时候我们就需要使用域名来访问。但是计算
机是不能是域名的。怎么办呢？如果我们每台机器里都备有一份域名到 IP 地址的映射，
这个倒是能解决一部分问题，但是如果域名对应的 IP 发生变化了又该怎么办呢？于是我
们有了 DNS 这个东西。我们只需要访问一个大家熟知的(known)的点，它就会告诉你这
个域名对应的 IP 是什么。在我们的应用中也会存在很多这类问题，特别是在我们的服务
特别多的时候，如果我们在本地保存服务的地址的时候将非常不方便，但是如果我们只
需要访问一个大家都熟知的访问点，这里提供统一的入口，那么维护起来将方便得多了。
分布式锁
其实在第一篇文章中已经介绍了 Zookeeper 是一个分布式协调服务。这样我们就可
以利用 Zookeeper 来协调多个分布式进程之间的活动。比如在一个分布式环境中，为了
提高可靠性，我们的集群的每台服务器上都部署着同样的服务。但是，一件事情如果集
群中的每个服务器都进行的话，那相互之间就要协调，编程起来将非常复杂。而如果我
们只让一个服务进行操作，那又存在单点。通常还有一种做法就是使用分布式锁，在某
376
个时刻只让一个服务去干活，当这台服务出问题的时候锁释放，立即 fail over 到另外的
服务。这在很多分布式系统中都是这么做，这种设计有一个更好听的名字叫 Leader 
Election(leader 选举)。比如 HBase 的 Master 就是采用这种机制。但要注意的是分布
式锁跟同一个进程的锁还是有区别的，所以使用的时候要比同一个进程里的锁更谨慎的
使用。
集群管理
在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有
些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其
他机器需要感知到这种变化，然后根据这种变化做出对应的决策。比如我们是一个分布式
存储系统，有一个中央控制节点负责存储的分配，当有新的存储进来的时候我们要根据现
在集群目前的状态来分配存储节点。这个时候我们就需要动态感知到集群目前的状态。还
有，比如一个分布式的 SOA 架构中，服务是一个集群提供的，当消费者访问某个服务时，
就需要采用某种机制发现现在有哪些节点可以提供该服务(这也称之为服务发现，比如
Alibaba 开源的 SOA 框架 Dubbo 就采用了 Zookeeper 作为服务发现的底层机制)。还
有开源的 Kafka 队列就采用了 Zookeeper 作为 Cosnumer 的上下线管理。
437. 什么是 Znode？
在 Zookeeper 中，znode 是一个跟 Unix 文件系统路径相似的节点，可以往这个节
点存储或获取数据。
Zookeeper 底层是一套数据结构。这个存储结构是一个树形结构，其上的每一个节
点，我们称之为“znode”
zookeeper 中的数据是按照“树”结构进行存储的。而且 znode 节点还分为 4 中不
377
378
同的类型。
每一个 znode 默认能够存储 1MB 的数据（对于记录状态性质的数据来说，够了）
可以使用 zkCli 命令，登录到 zookeeper 上，并通过 ls、create、delete、get、set
等命令操作这些 znode 节点
438. Znode 节点类型有哪些？
答：
(1)PERSISTENT 持久化节点: 所谓持久节点，是指在节点创建后，就一直存在，直
到有删除操作来主动清除这个节点。否则不会因为创建该节点的客户端会话失效而消失。
(2)PERSISTENT_SEQUENTIAL 持久顺序节点：这类节点的基本特性和上面的节点
类型是一致的。额外的特性是，在 ZK 中，每个父节点会为他的第一级子节点维护一份
时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以
设置这个属性，那么在创建节点过程中，ZK 会自动为给定节点名加上一个数字后缀，作
为新的节点名。这个数字后缀的范围是整型的最大值。 在创建节点的时候只需要传入节
点 “/test_”，这样之后，zookeeper 自动会给”test_”后面补充数字。
(3)EPHEMERAL 临时节点：和持久节点不同的是，临时节点的生命周期和客户端会 
话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这
里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。
这里还要注意一件事，就是当你客户端会话失效后，所产生的节点也不是一下子就消
失了，也要过一段时间，大概是 10 秒以内，可以试一下，本机操作生成节点，在服务器
端用命令来查看当前的节点数目，你会发现客户端已经 stop，但是产生的节点还在。
379
EPHEMERAL_SEQUENTIAL 临时自动编号节点：此节点是属于临时节点，不过带有
顺序，客户端会话结束节点就消失。
 
442. Dubbo 执行流程什么是？
0 start: 启动 Spring 容器时,自动启动 Dubbo 的 Provider
381
1、register: Dubbo 的 Provider 在启动后自动会去注册中心注册内容.注册的内容
包括:
1.1 Provider 的 IP
1.2 Provider 的端口.
1.3 Provider 对外提供的接口列表.哪些方法.哪些接口类
1.4 Dubbo 的版本.
1.5 访问 Provider 的协议.
2、subscribe: 订阅.当 Consumer 启动时,自动去 Registry 获取到所已注册的服务
的信息.
3、notify: 通知.当 Provider 的信息发生变化时, 自动由 Registry 向 Consumer 推
送通知.
4、invoke: 调用. Consumer 调用 Provider 中方法
4.1 同步请求.消耗一定性能.但是必须是同步请求,因为需要接收调用方法后的
结果.
5、count:次数. 每隔 2 分钟,provoider 和 consumer 自动向 Monitor 发送访问次
数.Monitor 进行统计.
443. 说说 Dubbo 支持的协议有哪些？
1、Dubbo 协议(官方推荐协议)
优点：
采用 NIO 复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，
性能较好（推荐使用）
382
缺点：
大文件上传时,可能出现问题(不使用 Dubbo 文件上传)
2、RMI(Remote Method Invocation)协议
优点:
JDK 自带的能力。可与原生 RMI 互操作，基于 TCP 协议
缺点:
偶尔连接失败.
3、Hessian 协议
优点:
可与原生 Hessian 互操作，基于 HTTP 协议
缺点:
需 hessian.jar 支持，http 短连接的开销大
444. Dubbo 支持的注册中心有哪些？
1、Zookeeper(官方推荐)
优点:支持分布式.很多周边产品.
缺点: 受限于 Zookeeper 软件的稳定性.Zookeeper 专门分布式辅助软件,稳定较优
2、Multicast
优点:去中心化,不需要单独安装软件.
缺点:Provider 和 Consumer 和 Registry 不能跨机房(路由)
3、Redis
383
优点:支持集群,性能高
缺点:要求服务器时间同步.否则可能出现集群失败问题.
4、Simple
优点: 标准 RPC 服务.没有兼容问题
缺点: 不支持集群.
445. SessionFactory 是线程安全的吗？Session 是线程安全的吗，两个线程
能够共享同一个 Session 吗？
答：SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被
多个线程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好
将 SessionFactory 通过单例的模式进行封装以便于访问。Session 是一个轻量级非线程
安全的对象（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。
Session 是由 SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层
服务对外提供的主要接口。Session 会延迟获取数据库连接（也就是在需要的时候才会
获取）。为了避免创建太多的 session，可以使用 ThreadLocal 来取得当前的 session，
无论你调用多少次 getCurrentSession()方法，返回的都是同一个 session。
446. Session 的 load 和 get 方法的区别是什么？
答：主要有以下三项区别：
1）如果没有找到符合条件的记录, get 方法返回 null,load 方法抛出异常
2）get 方法直接返回实体类对象, load 方法返回实体类对象的代理
3）在 Hibernate 3 之前，get 方法只在一级缓存(内部缓存)中进行数据查找, 如果没有
找到对应的数据则越过二级缓存, 直接发出 SQL 语句完成数据读取; load 方法则可以充
384
分利用二级缓存中的现有数据；当然从 Hibernate 3 开始，get 方法不再是对二级缓存
只写不读，它也是可以访问二级缓存的
简单的说，对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用
代理来实现延迟加载，如果没有数据就抛出异常，而通过 get()方法去取的数据可以不存
在。
447. Session 的 save()、update()、merge()、lock()、saveOrUpdate()
和 persist()方法有什么区别？
答：Hibernate 的对象有三种状态：瞬态、持久态和游离态。游离状态的实例可以通过
调用 save()、persist()或者 saveOrUpdate()方法进行持久化；脱管状态的实例可以通过
调用 update()、0saveOrUpdate()、lock()或者 replicate()进行持久化。save()和 persist()
将会引发 SQL 的 INSERT 语句，而 update()或 merge()会引发 UPDATE 语句。save()
和 update()的区别在于一个是将瞬态对象变成持久态，一个是将游离态对象变为持久态。
merge 方法可以完成 save()和 update()方法的功能，它的意图是将新的状态合并到已有
的持久化对象上或创建新的持久化对象。按照官方文档的说明：(1)persist()方法把一个
瞬态的实例持久化，但是并&quot;不保证&quot;标识符被立刻填入到持久化实例中，标识符的填入
可能被推迟到 flush 的时间；(2) persist&quot;保证&quot;，当它在一个事务外部被调用的时候并不
触发一个 Insert 语句，当需要封装一个长会话流程的时候，一个 persist 这样的函数是
需要的。(3)save&quot;不保证&quot;第 2 条,它要返回标识符，所以它会立即执行 Insert 语句，不管
是不是在事务内部还是外部。update()方法是把一个已经更改过的脱管状态的对象变成
持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。
385
448. 什么是 VSFTPD？
vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。
vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、
BSD、Solaris、 HP-UNIX 等系统上面，是一个完全免费的、开放源代码的 ftp 服务器
软件，支持很多其他的 FTP 服务器所不支持的特征。
449. 什么是 Nginx？
Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务。Nginx 是由伊戈尔·赛
索耶夫为俄罗斯访问量第二的 Rambler.ru 站点（俄文：Рамблер）开发的，第一个公
开版本 0.1.0 发布于 2004 年 10 月 4 日。
Nginx 是一个很强大的高性能 Web 和反向代理服务，它具有很多非常优越的特性：
在连接高并发的情况下，Nginx 是 Apache 服务不错的替代品：Nginx 在美国是做虚拟
主机生意的老板们经常选择的软件平台之一。
450. Nginx 有哪些作用？
答：
http 协议代理
搭建虚拟主机
服务的反向代理
在反向代理中配置集群的负载均衡
451. 什么是正向代理？
正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从
原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向
386
387
原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。
452. 什么是反向代理？
反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，
然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请
求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。
460. 什么是全文检索？
答：什么叫做全文检索呢？这要从我们生活中的数据说起。
我们生活中的数据总体分为两种：结构化数据和非结构化数据。
1）结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。
2）非结构化数据：指不定长或无固定格式的数据，如邮件，word 文档等。
非结构化数据又一种叫法叫全文数据。
按照数据的分类，搜索也分为两种：
1）对结构化数据的搜索：如对数据库的搜索，用 SQL 语句。
2）对非结构化数据的搜索：如利用 windows 的搜索也可以搜索文件内容，
393
全文检索： 就是一种将文件中所有文本与检索项匹配的文字资料检索方法。全文检索首
先将要查询的目标文档中的词提取出来，组成索引，通过查询索引达到搜索目标文档的
目的。这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。
461. 什么是 Lucene？
Lucene 是一个高效的，基于 Java 的全文检索库。
Lucene 是 apache 软件基金会 4 jakarta 项目组的一个子项目，是一个开放源代码
的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的
架构，Lucene 的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系
统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene 是一
套用于全文检索和搜寻的开源程序库，由 Apache 软件基金会支持和提供。Lucene 提供
了一个简单却强大的应用程序接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene
是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免
费 Java 信息检索程序库。
462. 什么是 Solr？
答：Solr 是一个独立的企业级搜索应用服务器，它对外提供类似于 Web-service 的 API
接口。
Solr 是一个高性能，采用 Java 开发，基于 Lucene 的全文搜索服务器。同时对其进
行了扩展，提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展并对查
询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文检索
引擎。
文档通过 Http 利用 XML 加到一个搜索集合中。查询该集合也是通过 http 收到一
394
个 XML/JSON 响应来实现。它的主要特性包括：高效、灵活的缓存功能，垂直搜索功能，
高亮显示搜索结果，通过索引复制来提高可用性，提供一套强大 Data Schema 来定义
字段，类型和设置文本分析，提供基于 Web 的管理界面等。
463. Solr 是由哪两个部分构成？
答：如下两个部分
Solr 的 web 服务
Solr 的索引库
464. 什么是正排索引？
正排索引是以文档的 ID 为关键字，索引文档中每个字的位置信息，查找时扫描索引中每
个文档中字的信息直到找出所有包含查询关键字的文档。
但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大
延长，检索效率低下。
尽管正排索引的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，
否则实用性价值不大。
465. 什么是倒排索引？
对数据进行分析，抽取出数据中的词条，以词条作为 key，对应数据的存储位置作为 value，
实现索引的存储。这种索引称为倒排索引。
当 solr 存储文档时，solr 会首先对文档数据进行分词，创建索引库和文档数据库。所谓
的分词是指：将一段字符文本按照一定的规则分成若干个单词。
466. 什么是 ActiveMQ？
ActiveMQ 是一种开源的，实现了 JMS1.1 规范的，面向消息(MOM)的中间件，为应用
395
程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。ActiveMQ 使用 Apache 提
供的授权，任何人都可以对其实现代码进行修改。
ActiveMQ 的设计目标是提供标准的，面向消息的，能够跨越多语言和多系统的应用集成
消息通信中间件。
ActiveMQ 实现了 JMS 标准并提供了很多附加的特性。这些附加的特性包括，JMX 管理
（java Management Extensions，即 java 管理扩展），主从管理（master/salve，这是集
群模式的一种，主要体现在可靠性方面，当主中介（代理）出现故障，那么从代理会替代主
代理的位置，不至于使消息系统瘫痪）、消息组通信（同一组的消息，仅会提交给一个客户进
行处理）、有序消息管理（确保消息能够按照发送的次序被接受者接收）。消息优先级（优先
级高的消息先被投递和处理）、订阅消息的延迟接收（订阅消息在发布时，如果订阅者没有开
启连接，那么当订阅者开启连接时，消息中介将会向其提交之前的，其未处理的消息）、接收
者处理过慢（可以使用动态负载平衡，将多数消息提交到处理快的接收者，这主要是对 PTP
消息所说）、虚拟接收者（降低与中介的连接数目）、成熟的消息持久化技术（部分消息需要
持久化到数据库或文件系统中，当中介崩溃时，信息不会丢失）、支持游标操作（可以处理大
消息）、支持消息的转换、通过使用 Apache 的 Camel 可以支持 EIP、使用镜像队列的形式
轻松的对消息队列进行监控等。
467. 消息服务的应用场景有哪些？
答：如下 3 个场景都可以使用消息服务
1、异步处理
2、应用的解耦
3、流量的削峰
396
468. 什么是 JMS？
JMS（Java Messaging Service）是 Java 平台上有关面向消息中间件的技术规范，它便
于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的
接口，简化企业应用的开发。
469. JMS 有哪些模型？
答：
JMS 消息机制主要分为两种模型：PTP 模型和 Pub/Sub 模型。
1、PTP 模型：（Point to Point 对点模型) 每一个消息传递给一个消息消费者，保证
消息传递给消息消费者，且消息不会同时被多个消费者接收。如果消息消费者暂时不在连接
范围内，JMS 会自动保证消息不会丢失，直到消息消费者进入连接，消息将自动送达。因此，
JMS 需要将消息保存到永久性介质上，例如数据库或者文件。
2、Pub-Sub 模型：(publish-subscription 发布者订阅者模型)每个主题可以拥有多个
订阅者。JMS 系统负责将消息的副本传给该主题的每个订阅者。
如果希望每一条消息都能够被处理，那么应该使用 PTP 消息模型。如果并不要求消息
都必须被消息消费者接收到的情况下，可使用 pub-sub 消息模型。Pub-Sub 模型可以在一
对多的消息广播时使用。
470. 什么是 JsonP？
Jsonp(JSON with Padding) 是 json 的一种&quot;使用模式&quot;，可以让网页从别的域名（网
站）那获取资料，即跨域读取数据。
471. 什么是跨域？
跨域是指一个域（网站）下的文档或脚本试图去请求另一个域（网站）下的资源。
397
472. 什么是同源策略？
同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏
览器，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用
这个策略。如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指&quot;协
议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源
473. 什么是 MyCat？
MyCat 是目前最流行的基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议
的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，
而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多
数主流数据库服务器通信，其核心功能是分库分表。配合数据库的主从模式还可实现读写分
离。
MyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构
和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。
 MyCat 发展到目前的版本，已经不是一个单纯的 MySQL 代理了，它的后端可以支持
MySQL、SQL Server、Oracle、DB2、PostgreSQL 等主流数据库，也支持 MongoDB 这
种新型 NoSQL 方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那
种存储方式，在 MyCat 里，都是一个传统的数据库表，支持标准的 SQL 语句进行数据的操
作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度。
474. 什么是纵向切分/垂直切分？
就是把原本存储于一个库的数据存储到多个库上。
398
由于对数据库的读写都是对同一个库进行操作，所以单库并不能解决大规模并发写入的
问题。
例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日
志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表
等。
优点
1）减少增量数据写入时的锁对查询的影响。
2）由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询
所需的检索行数变少，减少了磁盘 IO，时延变短。
缺点：无法解决单表数据量太大的问题。
横向切分/水平切分
把原本存储于一个表的数据分块存储到多个表上。当一个表中的数据量过大时，我们可
以把该表的数据按照某种规则，进行划分，然后存储到多个结构相同的表，和不同的库上。
例如，我们 userDB 中的 userTable 中数据量很大，那么可以把 userDB 切分为结构相
同的多个 userDB：part0DB、part1DB 等，再将 userDB 上的 userTable，切分为很多
userTable：userTable0、userTable1 等，然后将这些表按照一定的规则存储到多个 userDB
上。
优点：
1）单表的并发能力提高了，磁盘 I/O 性能也提高了。
2）如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。
399
400
缺点：无法实现表连接查询。
475. 简述 Tomcat，Apache，JBoss 和 WebLogic 的区别和联系
答：
Apache：全球应用最广泛的 http 服务器，免费，出自 apache 基金组织
Tomcat：应用也算非常广泛的 web 服务器，支持部分 j2ee，免费，出自 apache 基金
组织
JBoss：开源的应用服务器，比较受人喜爱，免费（文档要收费）
weblogic：应该说算是业界第一的 app server，全部支持 j2ee1.4（收费）
JBoss 也支持 j2ee
JBoss 和 WebLogic 都含有 Jsp 和 Servlet 容器,也就可以做 web 容器,
JBoss 和 WebLogic 也包含 EJB 容器,是完整的 J2EE 应用服务器
tomcat 只能做 jsp 和 servlet 的 container
476. 以下可以实现负载均衡的是（）
A. nagios
B. Jenkins
C. nginx
D. docker
分析：答案: C Nginx 是一款轻量级的 Web 服务器/反向代理服务器
及电子邮件（IMAP/POP3）代理服务器，并在一个 BSD-like 协议下发行。
其特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类
型的网页服务器中表现较好，中国大陆使用 nginx 网站用户有：百度、京
401
东、新浪、网易、腾讯、淘宝等
477. Tomcat/ WebSphere/WebLogic 的作用和特点
作用：
Tomcat：目前应用非常广泛的免费 web 服务器，支持部分 j2ee。
WebSphere：是 IBM 集成软件平台。可做 web 服务器，WebSphere 提供了可靠、灵
活和健壮的集成软件。 
Weblogic：是美国 bea 公司出品的一个基于 j2ee 架构的中间件。BEA WebLogic 是用
于开发、集成、部署和管理大型分布式 Web 应用、网络应用和数据库应用的 Java 应用
服务器。
特点（区别）：
1）价位不同：Tomcat 的是免费的；WebLogic 与 WebSphere 是收费的，而且价格不
菲。
2）开源性不同：Tomcat 的是完全开源的，而其他两个不是。WebLogic 与 WebSphere
都是对业内多种标准的全面支持，包括 JSB、JMS、JDBC、XML 和 WML，使 Web 应
用系统实施更简单，且保护投资，同时也使基于标准的解决方案的开发更加简便。
3）扩展性的不同：WebLogic 和 WebSphere 都是以其高扩展的架构体系闻名于业内，
包括客户机连接的共享、资源 pooling 以及动态网页。
4）应用范围的区别：Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发
访问用户不是很多的场合下被普遍使用，是开发和调试 JSP 程序的首选。WebLogic 和
WebSphere 是商业软件,功能齐全强大,主要应用于大型企业的大型项目。
5）安全性问题区别：因为 Tomcat 是开源的，所以它们的安全性相对来说比较低，万
一应用服务器本身有什么漏洞，你是没办法向 Apache 索赔的。而 WebLogic 和
WebSphere 其容错、系统管理和安全性能已经在全球数以千记的关键任务环境中得以验
证。
478. B/S 和 C/S 的含义及其区别
C/S 结构，即 Client/Server(客户机/服务器)结构，通过将任务合理分配到 Client 端和
Server 端，降低了系统的通讯开销，可充分利用两端硬件环境优势。早期软件系统多以
此作为首选设计标准。
B/S 结构，即 Browser/Server(浏览器/服务器)结构，是随着 Internet 技术的兴起，对
C/S 结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过 WWW 浏览器
实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，节约了开发成
本，便于软件维护。
区别
1、C/S 是建立在局域网的基础上的。B/S 是建立在广域网的基础上的，但并不是说 B/S
结构不能在局域网上使用。
2、B/S 业务扩展简单方便，通过增加页面即可增加服务器功能。C/S 的客户端还需要安
装专用的客户端软件，不利于扩展。
3、B/S 维护简单方便。开发、维护等几乎所有工作也都集中在服务器端，当企业对网络
应用进行升级时，只需更新服务器端的软件就可以，这减轻了异地用户系统维护与升级
的成本。。 
4、B/S 响应速度不及 C/S；
5、B/S 用户体验效果不是很理想
402
479. 说说你对容器的理解
容器也是 java 程序，它的主要作用是为应用程序提供运行环境。容器用来接管安全性、
并发性、事务处理、交换到辅助存储器和其它服务的责任
以 tomcat 为例：Tomcat 是一个后台服务进程，其它的 servlet（相当于 DLL）是在 Tomcat
容器内运行,Broswer 只与 Tomcat 通迅; Tomcat 接受 browser 的请求，经过一系列
动作（如果是静态网页，那么装载，按 http 协议形成响应流;如果是动态的如 JSP，那就
要调用 JDK 中的 servlet.jsp 接口，解释形成静态网页，按 http 协议生成响应流发送回
browser）后，形成静态网页，返回响应。
480. 为什么要使用连接池？
• 传统的数据库连接方式
一个连接对象对应一个物理连接
每次操作都打开一个物理连接，
使用完都关闭连接，造成系统性能低下。
• 连接池技术
客户程序得到的连接对象是连接池中物理连接的一个句柄，调用连接对象的 close()方法,
物理连接并没有关闭,数据源的实现只是删除了客户程序中的连接对象和池中的连接对
象之间的联系.
• 数据库连接的建立及关闭是耗费系统资源的操作，在大型应用中对系统的性能影响尤
为明显。为了能重复利用数据库连接对象,缩短请求的响应时间和提高服务器的性能,支
持更多的客户，应采用连接池技术.
403
481. 数据库连接池的原理
数据库连接池的原理
传统连接方式:
首先调用 Class.forName()方法加载数据库驱动，
然后调用 DriverManager.getConnection()方法建立连接.
连接池技术:
连接池解决方案是在应用程序启动时就预先建立多个数据库连接对象,然后将连接对象保
存到连接池中。
当客户请求到来时,从池中取出一个连接对象为客户服务。
当请求完成时,客户程序调用 close()方法,将连接对象放回池中. 
对于多于连接池中连接数的请求，排队等待。
应用程序还可根据连接池中连接的使用率，动态增加或减少池中的连接数。
404
482. MVC 模式及其优缺点
一、MVC 原理
MVC 是一种程序开发设计模式,它实现了显示模块与功能模块的分离。提高了程序的可维
护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。它主要分模型、视图、
控制器三层。
1、模型(model)它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与
数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一
次就可以被多个视图重用，所以减少了代码的重复性
2、视图(view) 用户与之交互的界面、在 web 中视图一般由 jsp,html 组成
3、控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不
做任何处理只是起到了一个连接的作用
二、MVC 的优点
1、降低代码耦合性。在 MVC 模式中，三个层各施其职，所以如果一旦哪一层的需求发
生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。
2、有利于分工合作。在 MVC 模式中，由于按层把系统分开，那么就能更好的实现开发
405
中的分工。网页设计人员可进行开发视图层中的 JSP，而对业务熟悉的人员可开发业务层，
而其他开发人员可开发控制层。
3、有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作
界面。可以为一个模型在运行时同时建立和使用多个视图。
三、MVC 的不足之处
1、增加了系统结构和实现的复杂性。对于简单的界面，严格遵循 MVC，使模型、视图
与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。
2、视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部
件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立
重用。
3、视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才
能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。
4、目前，一般高级的界面工具或构造器不支持模式。改造这些工具以适应 MVC 需要和
建立分离的部件的代价是很高的，从而造成 MVC 使用的困难。
483. MVC 模式完成分页功能的基本思路是什么？
1）页面提交页码(第几页)到 Servlet 中
2）Servlet 接收到页码后，将页码传递给分页工具类(PageBean)
3）Servlet 中调用 Service 层传入 PageBean 对象
4）Service 层调用 DAO 层传入 PageBean 对象
5）Servlet 中得到查询出来的数据，并 setAttrivute 保存
6）在页面中得到(getAttribute)数据，遍历输出
406
484. 常用的 Web 容器
答：Unix和Linux平台下使用最广泛的免费HTTP服务器是Apache服务器，而Windows
平台的服务器通常使用 IIS 作为 Web 服务器。选择 Web 服务器应考虑的因素有：性能、
安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对
常用服务器的简介：
IIS：Microsoft 的 Web 服务器产品为 Internet Information Services。IIS 是允许在公
共 Intranet 或 Internet 上发布信息的 Web 服务器。IIS 是目前最流行的 Web 服务器产
品之一，很多著名的网站都是建立在 IIS 的平台上。IIS 提供了一个图形界面的管理工具，
称为 Internet 服务管理器，可用于监视配置和控制 Internet 服务。IIS 是一种 Web 服务
组件，其中包括 Web 服务器、FTP 服务器、NNTP 服务器和 SMTP 服务器，分别用于
网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域
网）上发布信息成了一件很容易的事。它提供 ISAPI(Intranet Server API）作为扩展
Web 服务器功能的编程接口；同时，它还提供一个 Internet 数据库连接器，可以实现对
数据库的查询和更新。
Kangle：Kangle Web 服务器是一款跨平台、功能强大、安全稳定、易操作的高性能
Web 服务器和反向代理服务器软件。此外，Kangle 也是一款专为做虚拟主机研发的 Web
服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题
不影响其他用户。支持 PHP、ASP、ASP.NET、Java、Ruby 等多种动态开发语言。
WebSphere：WebSphere Application Server 是功能完善、开放的 Web 应用程序服
务器，是 IBM 电子商务计划的核心部分，它是基于 Java 的应用环境，用于建立、部署
和管理 Internet 和 Intranet Web 应用程序，适应各种 Web 应用程序服务器的需要，
407
范围从简单到高级直到企业级。
WebLogic：BEA WebLogic Server 是一种多功能、基于标准的 Web 应用服务器，为
企业构建自己的应用提供了坚实的基础。各种应用开发、部署所有关键性的任务，无论
是集成各种系统和数据库，还是提交服务、跨 Internet 协作，Weblogic 都提供了相应
的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开
发，基于 Internet 的企业都选择它来开发、部署最佳的应用。BEA WebLogic Server
在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业
级应用提供了稳固的基础，它们以 Internet 的容量和速度，在连网的企业之间共享信息、
提交服务，实现协作自动化。
Apache：目前 Apache 仍然是世界上用得最多的 Web 服务器，市场占有率约为 60%左
右。世界上很多著名的网站都是 Apache 的产物，它的成功之处主要在于它的源代码开
放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的 Unix、Windows、
Linux 系统平台上）以及它的可移植性等方面。
Tomcat：Tomcat 是一个开放源代码、运行 Servlet 和 JSP 的容器。TomcatServer 实
现了 Servlet 和 JSP 规范。此外，Tomcat 还实现了 Apache-Jakarta 规范而且比绝大多
数商业应用软件服务器要好，因此目前也有不少的 Web 服务器都选择了 Tomcat。
Nginx：读作&quot;engine x&quot;，是一个高性能的 HTTP 和反向代理服务器，也是一个
IMAP/POP3/SMTP 代理服务器。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的
Rambler.ru 站点开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。其将源代
码以类 BSD 许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统
资源的消耗而闻名。
408
409
485. Java Web 开发的 Model 1 和 Model 2 分别指的是什么？
答：Model 1 是以页面为中心的 Java Web 开发，只适合非常小型的应用程序，Model 2
是基于 MVC 架构模式的应用，这一点在前文的面试题中已经详细讲解过了。1.  说说什么是框架：
框架(framework)是一个框子--》指约束性，也是一个架子--》指支撑性 IT 语境中
的框架，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，在此结构上
可以根据具体问题扩展、按插更多的组成部分，从而更迅速和方便地架构完整的解决问
题的方案。
1）框架本身一般不完整到可以解决特定问题，但是可以帮助您快速解决特定问题：
没有框架所有的工作都从零开始做，有了框架，为我们提供了一定的功能。我们就
可以在框架的基础上开发，极大的解决了生产力。
410
不同的框架，是为了解决不同领域的问题，一定要为了解决问题才去学习框架。
2）框架天生就是为了扩展而设计的
3）框架里面可以为后续的组件提供很多辅助性、支撑性的方便易用的实用工具
(utilities)，也就是框架时常配套一些帮组解决某类问题的库(libraries）或工具（tools）.
在 java 中就是一系列的 jar 包，其本质就是对 jdk 功能的扩展。
2.  简单说一下 MVC 框架？
是为了解决传统 MVC 模式(jsp+servlet+javabean)一些问题而出现的框架
传统 MVC 模式模式问题：
1）所有的 Servlet 和 Servlet 映射都要配置在 web.xml 中，如果项目太大，web.xml
就太庞大并且不能实现模块化管理。
2）Servlet 的主要功能就是接受参数、调用逻辑、跳转页面，比如像其他字符编码、
文件上传等功能也要写在 Servlet 中，不能让 Servlet 主要功能而需要做处理一些特例。
3）接受参数比较麻烦
(String name = request.getParameter(“name”))，不能通过 model 接受，只
能单个接收，接收完成后转换封装 model。
4）跳转页面方式比较单一(forward,redirect)，并且当我们的页面名称发生改变时
需要改变 Servlet 源代码。
现在比较常用的 MVC 框架：
webwork
Struts
Struts2
SpringMVC
9.  什么是 ORM
对象关系映射(Object Relation Mapping，简称 ORM)模式是一种为了解决面向对
象与关系数据库存在的互不匹配的现象的技术，简单的说，ORM 是通过使用描述对象和
数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中，那么到底如何
实现持久化呢？一种简单的方案时采用硬编码方式(jdbc 操作 sql 方式)，为每一种可能
417
418
的数据库访问操作提供单独的方法。
这种方案存在以下不足：
10. 持久化层缺乏弹性，一旦出现业务需求变更，就必须修改持久化层的接口
11. 持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型
发生变化，都要修改持久化层的相关程序代码，增加软件的维护难度。
ORM 提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，
使得 ORM 中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁，Java 典型
的 ORM 框架有：Hibernate，ibatis(mybtis)，speedframework。
ORM 框架的方法论基于三个核心原则：
简单：以最基本的形式建模数据
传达性：数据库结构被任何人都能理解的语言文档化
精确性：基于数据模型创建正确标准化了结构
对象关系映射(Object Relation Mapping，简称 ORM)模式是一种为了解决面向对
象与关系数据库存在的互不匹配的现象的技术，可以简单的方案采用硬编码方式(jdbc
操作 sql 方式)，为每一种可能的数据库访问操作提供单独的方法，这种方法存在很多缺
陷，使用 ORM 框架(为了解决面向对象与关系数据库存在互不匹配的现象的框架)来解决。
12. Hibernate 对象的状态
临时状态/瞬时状态(transient)：刚刚用 new 语句创建，没有被持久化，无 id
不处于 session 中(没有使用 session 的方法去操作临时对象)，该对象成为临时对象
持久化状态，托管状态(persistent)：已经被持久化，加入 session 的缓存中，session
是没有关闭
该状态的对象为持久化对象。
游离状态，脱管状态(detached)：已经被持久化，但不处于 session 中，该状态的
对象为游离对象。
删除状态(removed)：对象有关联的 id，并且在 session 管理下，但是已经被计划(事
务提交的时候，commit)删除，如果没有事务就不能删除
相互转换
13. 介绍一下 Hibernate 的缓存
答：
一、why(为什么要用 Hibernate 缓存？)
Hibernate 是一种持久化层框架，经常访问物理数据库。
为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能
缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，
在特定的时刻或事件会同步缓存和物理数据源的数据。
为了提高访问速度，把磁盘或者数据库访问变成内存访问
二、what(Hibernate 缓存原理是怎样的？)Hibernate 缓存包括两大类：Hibernate
一级缓存和 Hibernate 二级缓存
14. Hibernate 一级缓存又称为”session 的缓存”。
session 缓存内置不能被卸载，session 的缓存是事务范围的缓存(session 对象的生
命周期通常对应一个数据库事务或者一个应用事务)。
一级缓存中，持久化类的每个实例都具有唯一的 OID
15. Hibernate 的二级缓存又称为”sessionFactory 的缓存”。
419
由于 sessionFactory 对象的生命周期和应用程序的整个过程对应，因此 Hibernate
二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的
并发访问策略，该策略为被缓存的数据提供了事务隔离级别。
第二级缓存是可选的，是一个可配置的插件，默认下 sessionFactory 不会启用这个
插件。
什么样的数据适合存放到二级缓存中？1.  很少被修改的数据 (帖子的最后回复时间)
2.  经常被查询的数据 (电商的地点)
3.  不是很重要的数据，允许出现偶尔并发的数据
4.  不会被并发访问的数据
5.  常量数据
扩展：Hibernate 的二级缓存默认是不支持分布式缓存的，使用 memcache，redis
等中央缓存来代替二级缓存。1.  简单讲一下 webservice 使用的场景
webservice 是一个 SOA(面向服务的编程)的架构，它是不依赖于语言，不依赖于平
台，可以实现不同的语言间的相互调用，通过 Internet 进行基于 http 协议的网络应用
间的交互。
1、异构系统(不同的开发语言)的整合
2、不同客户端的整合 (浏览器、手机端(android\ios)、微信)
3、实实在在的例子：
天气预报：可以通过实现 webservice 客户端调用远程天气服务实现的
420
4、单点登录：一个服务实现所有系统的登录
2.  简单介绍一下 activity？
Activity 是一个业务流程管理(BPM)和工作流系统，适用于开发人员和系统管理员，
其核心是超快速，稳定的 BPMN2 的流程引擎，它易于与 Spring 集成使用。
主要用在 OA 中，把线下流程放在线上，把现实生活中一些流程固话定义到系统中，
然后通过输入表单数据完成业务。
他可以用在 OA 系统的流程管理中
请假流程(小于三天，一级主管审批，大于三天二级主管审批)
报销流程(价格区间)
3.  什么是 MyBatis？
答：MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。
4.  Mybatis 是如何进行分页的？分页插件的原理是什么？
答：
1）Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可
以使用 Mybatis 的分页插件。
2）分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截
方法内拦截待执行的 sql，然后重写 sql。
举例：select \* from student，拦截 sql 后重写为：select t.\* from （select \* from
student）t limit 0，10
5.  MyBatis 与 Hibernate 有哪些不同？
答：
421
422
1）Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要
程序员自己编写 Sql 语句，不过 mybatis 可以通过 XML 或注解方式灵活配置要运行的
sql 语句，并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再
映射生成 java 对象。
2）Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql
执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、
企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但
是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件
则需要自定义多套 sql 映射文件，工作量大。
3）Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软
件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。
但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性
能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件
架构都是好架构，所以框架只有适合才是最好。
6.  简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关
系？
答：Mybatis 将所有Xml 配置信息都封装到All-In-One 重量级对象 Configuration
内部。在 Xml 映射文件中，\&lt;parameterMap&gt;标签会被解析为 ParameterMap 对象，
其每个子元素会被解析为 ParameterMapping 对象。\&lt;resultMap&gt;标签会被解析为
ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个\&lt;select&gt;、
 \&lt;insert&gt;、\&lt;update&gt;、\&lt;delete&gt;标签均会被解析为 MappedStatement 对象，标签
内的 sql 会被解析为 BoundSql 对象。
7.  什么是 MyBatis 的接口绑定,有什么好处？
答：接口映射就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句
绑定,我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有
更加灵活的选择和设置.
8.  Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以
及它们之间的区别？
答：能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，
多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为
selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为
selectList()即可。
关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给
主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，
一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql
查询，就可以把主对象和其关联对象查出来。
9.  MyBatis 里面的动态 Sql 是怎么设定的?用什么语法?
答：MyBatis 里面的动态 Sql 一般是通过 if 节点来实现,通过 OGNL 语法来实现,但
是如果要写的完整,必须配合 where,trim 节点,where 节点是判断包含节点有内容就插入
where,否则不插入,trim 节点是用来判断如果动态语句是以 and 或 or 开始,那么会自动
把这个 and 或者 or 取掉。
423
10. 使用 MyBatis 的 mapper 接口调用时有哪些要求？
答：
1）Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同
2）Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的
parameterType 的类型相同
3）Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的
resultType 的类型相同
4）Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。
11. Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映
射形式？
答：
第一种是使用\&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。
第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T\_NAME AS
NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列
名大小写，智能找到与之对应对象属性名，你甚至可以写成 T\_NAME AS NaMe，Mybatis
一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对
象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
12. MyBatis 接口绑定有几种实现方式,分别是怎么实现的?
答：接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上
@Select\@Update 等注解里面包含 Sql 语句来绑定,另外一种就是通过 xml 里面写 SQL
424
425
来绑定,在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名.
13. MyBatis 实现一对一有几种方式?具体怎么操作的？
答：有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在
resultMap 里面配置 association 节点配置一对一的类就可以完成;嵌套查询是先查一个
表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association
配置,但另外一个表的查询通过 select 属性配置。
14. 什么情况下用注解绑定,什么情况下用 xml 绑定？
答：当 Sql 语句比较简单时候,用注解绑定；当 SQL 语句比较复杂时候,用 xml 绑定,
一般用 xml 绑定的比较多
15. MyBatis 的好处是什么？
答：
1）MyBatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写，
给程序的维护带来了很大便利。
2） MyBatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 Java
Bean 对象，大大简化了 Java 数据库编程的重复工作。
3） 因为 MyBatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的
特点灵活控制 sql 语句， 因此能够实现比 Hibernate 等全自动 orm 框架更高的查询效
率，能够完成复杂查询。
微服务框架：
16. Spring Boot 有哪些优点？
答：Spring Boot 的优点有：
减少开发，测试时间和努力。
使用 JavaConfig 有助于避免使用 XML。
避免大量的 Maven 导入和各种版本冲突。
提供意见发展方法。
通过提供默认值快速开始开发。
没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish 或其
他任何东西。
需要更少的配置 因为没有web.xml文件。只需添加用@ Configuration注释的类，
然后添加用@Bean 注释的方法，Spring 将自动加载对象并像以前一样对其进行管理。
您甚至可以将@Autowired 添加到 bean 方法中，以使 Spring 自动装入需要的依赖关系
中。
基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：
\-Dspring.profiles.active = &#123;enviornment&#125;。在加载主应用程序属性文件后，Spring 将
在（application&#123;environment&#125; .properties）中加载后续的应用程序属性文件。
17. 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？
答：
这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式
tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高
426
开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器
并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服
务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有
这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模
块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。
\&lt;dependency&gt;\&lt;groupId&gt;org.springframework.boot\&lt;/groupId&gt; \&lt;artifactId&gt;spring-boot-devtools\&lt;/artifactId&gt; \&lt;optional&gt;true\&lt;/optional&gt; \&lt;/dependency&gt;1.  常见的系统架构风格有哪些？各有什么优缺点？
1、单体架构
单体架构也称之为单体系统或者是单体应用。就是一种把系统中所有的功能、模块耦
合在一个应用中的架构方式。
单体架构特点：打包成一个独立的单元(导成一个唯一的 jar 包或者是 war 包)，会一个进
程的方式来运行。
单体架构的优点、缺点
优点：
项目易于管理
部署简单
缺点：
测试成本高
可伸缩性差
可靠性差
427
428
迭代困难
跨语言程度差
团队协作难
2、MVC 架构
MVC 架构特点：
MVC 是模型(Model)、视图(View)、控制器(Controller)3 个单词的缩写。 下面我们从
这 3 个方面来讲解 MVC 中的三个要素。
Model 是指数据模型，是对客观事物的抽象。如一篇博客文章，我们可能会以一个 Post
类来表示，那么，这个 Post 类就是数据对象。 同时，博客文章还有一些业务逻辑，如
发布、回收、评论等，这一般表现为类的方法，这也是 model 的内容和范畴。 对于
Model，主要是数据、业务逻辑和业务规则。相对而言，这是 MVC 中比较稳定的部分，
一般成品后不会改变。 开发初期的最重要任务，主要也是实现 Model 的部分。这一部
分写得好，后面就可以改得少，开发起来就快。
View 是指视图，也就是呈现给用户的一个界面，是 model 的具体表现形式，也是收集
用户输入的地方。如你在某个博客上看到的某一篇文章，就是某个 Post 类的表现形式。
View 的目的在于提供与用户交互的界面。换句话说，对于用户而言，只有 View 是可见
的、可操作的。事实上也是如此，你不会让用户看到 Model，更不会让他直接操作 Model。
你只会让用户看到你想让他看的内容。 这就是 View 要做的事，他往往是 MVC 中变化
频繁的部分，也是客户经常要求改来改去的地方。 今天你可能会以一种形式来展示你的
429
博文，明天可能就变成别的表现形式了。
Contorller 指的是控制器，主要负责与 model 和 view 打交道。 换句话说，model 和
view 之间一般不直接打交道，他们老死不相往来。view 中不会对 model 作任何操作，
model 不会输出任何用于表现的东西，如 HTML 代码等。这俩甩手不干了，那总得有人
来干吧，只能 Controller 上了。 Contorller 用于决定使用哪些 Model，对 Model 执
行什么操作，为视图准备哪些数据，是 MVC 中沟通的桥梁。
MVC 架构优缺点
优点：
各施其职，互不干涉。
在 MVC 模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需
要更改相应的层中的代码而不会影响到其它层中的代码。
有利于开发中的分工。
在 MVC 模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设
计人员可以进行开发视图层中的 JSP，对业务熟悉的开发人员可开发业务层，而其它开
发人员可开发控制层。
有利于组件的重用。
分层后更有利于组件的重用。如控制层可独立成一个能用的组件，视图层也可做成通
用的操作界面。
缺点：
增加了系统结构和实现的复杂性。
视图与控制器间的过于紧密的连接。
视图对模型数据的低效率访问。
3、面向服务架构(SOA)
面向服务的架构（SOA）是一个组件模型，它将应用程序拆分成不同功能单元（称
为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进
行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各
种各样的系统中的服务可以以一种统一和通用的方式进行交互。
面向服务架构特点：
系统是由多个服务构成
每个服务可以单独独立部署
每个服务之间是松耦合的。服务内部是高内聚的，外部是低耦合的。高内聚就是每个
服务只关注完成一个功能。
服务的优点、缺点
优点：
测试容易
可伸缩性强
可靠性强
跨语言程度会更加灵活
团队协作容易
系统迭代容易
430
缺点：
运维成本过高，部署数量较多
接口兼容多版本
分布式系统的复杂性
分布式事务
2.  什么是 AKF 拆分原则？
业界对于可扩展的系统架构设计有一个朴素的理念,就是：通过加机器就可以解决容
量和可用性问题。(如果一台不行那就两台)。
我是个段子：（世界上没有什么事是一顿烧烤不能解决的。如果有，那就两顿。）
这一理念在“云计算”概念疯狂流行的今天，得到了广泛的认可！对于一个规模迅速
增长的系统而言，容量和性能问题当然是首当其冲的。但是随着时间的向前，系统规模
的增长，除了面对性能与容量的问题外，还需要面对功能与模块数量上的增长带来的系
统复杂性问题以及业务的变化带来的提供差异化服务问题。而许多系统，在架构设计时
并未充分考虑到这些问题，导致系统的重构成为常态，从而影响业务交付能力，还浪费
人力财力！对此，《可扩展的艺术》一书提出了一个更加系统的可扩展模型—— AKF 可
扩展立方（Scalability Cube） 。这个立方体中沿着三个坐标轴设置分别为：X、Y、Z。
Y 轴扩展会将庞大的整体应用拆分为多个服务。每个服务实现一组相关的功能，如订
单管理、客户管理等。在工程上常见的方案是 服务化架构(SOA) 。比如对于一个电子商
务平台，我们可以拆分成不同的服务
X 轴扩展与我们前面朴素理念是一致的，通过绝对平等地复制服务与数据，以解决容量
和可用性的问题。其实就是将微服务运行多个实例，做集群加负载均衡的模式。
431
Z 轴扩展通常是指基于请求者或用户独特的需求，进行系统划分，并使得划分出来的
子系统是相互隔离但又是完整的。以生产汽车的工厂来举例：福特公司为了发展在中国
的业务，或者利用中国的廉价劳动力，在中国建立一个完整的子工厂，与美国工厂一样，
负责完整的汽车生产。这就是一种 Z 轴扩展。
3.  什么是 Spring Cloud？
Spring Cloud 是一个微服务框架，相比 Dubbo 等 RPC 框架, Spring Cloud 提供的全套
的分布式系统解决方案。
Spring Cloud 对微服务基础框架 Netflix 的多个开源组件进行了封装，同时又实现了和
云端平台以及和 Spring Boot 开发框架的集成。
Spring Cloud 为微服务架构开发涉及的配置管理，服务治理，熔断机制，智能路由，微
代理，控制总线，一次性 token，全局一致性锁，leader 选举，分布式 session，集群状态
管理等操作提供了一种简单的开发方式。
Spring Cloud 为开发者提供了快速构建分布式系统的工具，开发者可以快速的启动服务
或构建应用、同时能够快速和云平台资源进行对接

5.  什么是 Eureka 注册中心？
Eureka 是 Netflix 开发的服务发现组件，本身是一个基于 REST 的服务。Spring Cloud
将它集成在其子项目 spring-cloud-netflix 中，以实现 Spring Cloud 的服务注册于发现，
同时还提供了负载均衡、故障转移等能力。
6.  简单谈一下 Eureka 中的三种角色分别是什么？
1、Eureka Server
通过 Register、Get、Renew 等接口提供服务的注册和发现。
2、Application Service (Service Provider)
服务提供方
把自身的服务实例注册到 Eureka Server 中
3、Application Client (Service Consumer)
服务调用方
通过 Eureka Server 获取服务列表，消费服务。
7.  什么是 Ribbon
1.Ribbon 是一个基于 Http 和 TCP 的客服端负载均衡工具，它是基于 Netflix Ribbon
实现的。
2.它不像 spring cloud 服务注册中心、配置中心、API 网关那样独立部署，但是它几乎
存在于每个 spring cloud 微服务中。包括 feign 提供的声明式服务调用也是基于该 Ribbon
实现的。
3.ribbon 默认提供很多种负载均衡算法，例如 轮询、随机 等等。甚至包含自定义的负
433
434
载均衡算法。
8.  集中式与进程内负载均衡的区别
目前业界主流的负载均衡方案可分成两类：
第一类：集中式负载均衡, 即在 consumer 和 provider 之间使用独立的负载均衡设施(可
以是硬件，如 F5, 也可以是软件，如 nginx), 由该设施负责把 访问请求 通过某种策略转发
至 provider；
第二类：进程内负载均衡，将负载均衡逻辑集成到 consumer，consumer 从服务注册
中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的 provider。
Ribbon 就属于后者，它只是一个类库，集成于 consumer 进程，consumer 通过它来
获取到 provider 的地址。
9.  Ribbon 的常见负载均衡策略有哪些？
id 策略名称 策略对应的类名 实现原理
1 轮询策略（默认） RoundRobinRule
轮询策略表示每次都顺序取下一个
provider，比如一共有 5 个 provider，
第 1 次取第 1 个，第 2 次取第 2 个，第
3 次取第 3 个，以此类推
2 权重轮询策略
WeightedResponseTime
Rule
1.根据每个 provider 的响应时间分配
一个权重，响应时间越长，权重越小，
被选中的可能性越低。
435
2.原理：一开始为轮询策略，并开启一
个计时器，每 30 秒收集一次每个
provider 的平均响应时间，当信息足够
时，给每个 provider 附上一个权重，
并按权重随机选择 provider，高权越重
的 provider 会被高概率选中。
3 随机策略 RandomRule
从 provider 列表中随机选择一个
provider
4 最少并发数策略 BestAvailableRule
选择正在请求中的并发数最小的
provider，除非这个 provider 在熔断
中。
5
在“选定的负载均
衡策略”基础上进
行重试机制
RetryRule
1.“选定的负载均衡策略”这个策略是
轮询策略 RoundRobinRule
2.该重试策略先设定一个阈值时间段，
如果在这个阈值时间段内当选择
provider 不成功，则一直尝试采用“选
定的负载均衡策略：轮询策略”最后选
择一个可用的 provider
6 可用性敏感策略 AvailabilityFilteringRule
过滤性能差的 provider,有 2 种：
第一种：过滤掉在 eureka 中处于一直
连接失败 provider
第二种：过滤掉高并发的 provider
1.以一个区域为单位考察可用性，对于
不可用的区域整个丢弃，从剩下区域中
选可用的 provider
7 区域敏感性策略 ZoneAvoidanceRule
2.如果这个ip区域内有一个或多个实例
不可达或响应变慢，都会降低该 ip 区域
内其他 ip 被选中的权重。
10. 简单说说什么是 Feign？
Feign 是一种声明式、模板化的 HTTP 客户端技术(仅在 consumer 中使用)。
11. 什么是声明式，有什么作用，解决什么问题？
声明式调用就像调用本地方法一样调用远程方法;无感知远程 http 请求。
1、Spring Cloud 的声明式调用, 可以做到使用 HTTP 请求远程服务时能就像调用本地
方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。
2、它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规
的 Http Client 构造请求再解析返回数据。
3、它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，
更无需关注分布式环境开发。
12. 什么是服务的灾难性的雪崩效应？
在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问 A 服务，
而 A 服务需要调用 B 服务，B 服务需要调用 C 服务，由于网络原因或者自身的原因，如
436
437
果 B 服务或者 C 服务不能及时响应，A 服务将处于阻塞状态，直到 B 服务 C 服务响应。
此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之
间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，
这就是服务故障的“雪崩”效应
13. 如何解决灾难性雪崩效应？
降级
超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。
实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的
值.
隔离（线程池隔离和信号量隔离）
限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。
熔断
当失败率(如因网络故障/超时造成的失败率高)达到阀值自动触发降级，熔断器触发
的快速失败会进行快速恢复。
缓存
提供了请求缓存。
请求合并
提供请求合并。
14. 线程池隔离和信号量隔离的区别
15. 请回答微服务架构的六种常用设计模式是什么？
答：如下这六种
代理设计模式
聚合设计模式
链条设计模式
聚合链条设计模式
数据共享设计模式
异步消息设计模式
16. 什么是网关服务？
答：网关服务，通常是外部访问服务的唯一接口，访问内部的所有服务都必须先经过网
438
关服务。网关服务的主要功能是消息解析过滤，路由，转发等。
17. 网关服务中，路由器的 4 种路由规则方法是什么？
答：
采用 URL 指定路由方式
采用服务名称指定路由方式
路由的排除方法
路由的添加前缀方法
18. 为什么要使用 spring cloud config 配置中心？它解决了什么问题？
19. 什么是 Spring Cloud Bus
439
20. 消息驱动 Stream 解决了什么问题？
21. 为什么要使用微服务跟踪？它解决了什么问题？
440
22. 什么是 ELK（ElasticSearch, Logstash, Kibana）
ELK 是三个工具的集合，Elasticsearch + Logstash + Kibana，这三个工具组合形成了
一套实用、易用的监控架构，很多公司利用它来搭建可视化的海量日志分析平台。
23. ElasticSearch
ElasticSearch 是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全
文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 开发的，并作为 Apache 许
可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实
时搜索，稳定，可靠，快速，安装使用方便。
24. Logstash
Logstash 是一个用于管理日志和事件的工具，你可以用它去收集日志、转换日志、解析
日志并将他们作为数据提供给其它模块调用，例如搜索、存储等。
25. Kibana
Kibana 是一个优秀的前端日志展示框架，它可以非常详细的将日志转化为各种图表，为
用户提供强大的数据可视化支持。
26. 为什么要用 ELK，它解决了什么问题？
441
27. 什么是分布式跟踪 : Zipki？
数据库：
28. 下列属于关系型数据库的是（）（选择两项）
A. Oracle
B. MySql
C. IMS
D. MongoDB
答案：AB
分析： IMS 是 IP Mulitimedia Subsystem 的缩写，是 IP 多媒体系统
MongoDB 分布式文档存储数据库
29. 请列出 Java 常见的开源数据连接池，并对参数做出简单的说明
答：在 Java 中开源的常用的数据库连接池有以下几种 ：
（1）DBCP
DBCP 是一个依赖 Jakarta commons-pool 对象池机制的数据库连接池.DBCP 可以直接
的在应用程序中使用，Tomcat 的数据源使用的就是 DBCP。
442
（2）c3p0
c3p0 是一个开放源代码的 JDBC 连接池，它在 lib 目录中与 Hibernate 一起发布,包括了
实现jdbc3和jdbc2 扩展规范说明的Connection 和Statement 池的DataSources 对
象。
（3）Druid
阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包
含一个 ProxyDriver，一系列内置的 JDBC 组件库，一个 SQL Parser。支持所有 JDBC
兼容的数据库，包括 Oracle、MySql、Derby、Postgresql、SQL Server、H2 等等。
30. 储蓄所有多个储户，储户在多个储户所存取款，储蓄所与储户之间是（）
A. 一对一的联系
B. 多对一的联系
C. 一对多的联系
D. 多对多的联系
答案：D
31. 视图是一个“虚表”，视图的构造基于（）
A. 基本表或视图
B. 视图
C. 数据字典
D. 基本表
答案：A
443
32. 设有关系 R(A,B,C,D)及其上的函数相关性集合 F=&#123;B→A,BC→D&#125;,那么
关系 R 最高是（）
A. 第一范式的
B. 第二范式的
C. 第三范式的
D. BCNF 范式的
答案: A
分析：
根据数据库三大范式的依赖性要求，从 B,BC 函数确定 A 和 D 这一点上,
明显看出 B,BC 都有可能是主码.
若B是主码的话,仔细看会发现,F中竟然没有谁去函数确定C,这显然是说不
通的,(因为 C 至少会被 B 这个主码函数确定);
若 BC 是主码,那么 F 中存在非主属性对候选码的部分依赖,不满足第二范式
的要求,故为第一范式.
33. 什么是 DAO 模式？
答：DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽
象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作。为了建立一个
健壮的 Java EE 应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API
中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的
所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，
并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO
444
445
模式实际上包含了两个模式，一是 Data Accessor（数据访问器），二是 Data Object
（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。
34. 数据库 MySQL，Oracle，SqlServer 分页时用的语句
Mysql:使用 limit 关键字
Select \* from 表名 where 条件 limit 开始位置，结束位置。通过动态的改
变开始和结束位置的值来实现分页。
Oracle：通过 rownum 来实现
select \* from ( select rownum rn,t.\* from addressbook where rownum&lt;=
20 ) where rownum &gt; 10
Sqlserver:
select top 20 \* from addressbook where id not in (select top 10 id from
addressbook)
35. Oracle 完成分页功能的三层子查询语句及其含义？
如：
select \* from (select t.*,rownum r from (select \* from A) t where rownum &lt; 10)
where r &gt;5
select \* from A:要查询的数据
select t.*,rownum r from (select \* from A) t where rownum &lt; 10：取前 10 行
select \* from (select t.\*,rownum r from (select \* from A) t where rownum &lt; 10)
where r &gt;5：取 5-10 行
36. 问 SQL 怎么优化执行效率更高
答：
37. SQL 优化的原则是：将一次操作需要读取的 BLOCK 数减到最低,即在最短的时间达到
最大的数据吞吐量。
调整不良 SQL 通常可以从以下几点切入：1.  检查不良的 SQL，考虑其写法是否还有可优化内容
2.  检查子查询 考虑 SQL 子查询是否可以用简单连接的方式进行重新书写
3.  检查优化索引的使用
4.  考虑数据库的优化器1.  避免出现 SELECT \* FROM table 语句，要明确查出的字段。
2.  在一个 SQL 语句中，如果一个 where 条件过滤的数据库记录越多，定位越准确，则
该 where 条件越应该前移。
3.  查询时尽可能使用索引覆盖。即对 SELECT 的字段建立复合索引，这样查询时只进行
索引扫描，不读取数据块。
4.  在判断有无符合条件的记录时建议不要用 SELECT COUNT （\*）和 select top 1 语
句。
5.  使用内层限定原则，在拼写 SQL 语句时，将查询条件分解、分类，并尽量在 SQL 语
句的最里层进行限定，以减少数据的处理量。
6.  应绝对避免在 order by 子句中使用表达式。
7.  如果需要从关联表读数据，关联的表一般不要超过 7 个。
446
8.  小心使用 IN 和 OR，需要注意 In 集合中的数据量。建议集合中的数据不超过 200
个。
9.  &lt;&gt; 用 &lt; 、 &gt; 代替，&gt;用&gt;=代替，&lt;用&lt;=代替，这样可以有效的利用索引。
10. 在查询时尽量减少对多余数据的读取包括多余的列与多余的行。
11. 对于复合索引要注意，例如在建立复合索引时列的顺序是 F1，F2，F3，则在 where
或 order by 子句中这些字段出现的顺序要与建立索引时的字段顺序一致，且必须包含第
一列。只能是 F1 或 F1，F2 或 F1，F2，F3。否则不会用到该索引。
12. 谈谈数据库去空格的情况
一、表中字符串带空格的原因
1、空格就是空格。
2、控制符 显示为 空格。
二、解决方法
第一种情况，去空格的处理的比较简单，Replace(column,&#39; &#39;,&#39;&#39;) 就可以解决。
第二种情况，解决方法就比较麻烦点：需要先查出相应的 ASCII 码，再用
Replace(column,char(ascii 码),&#39;&#39;)解决，以下举个栗子：
CREATE TABLE #temp
(NAME NVARCHAR(50))INSERT INTO #temp SELECT &#39;明天就是国庆了&#39;+CHAR(10) --换行符SELECT \* FROM #temp --末尾显示为空格
447
SELECT REPLACE(NAME,&#39; &#39;,&#39;&#39;) FROM #temp --去不掉这个空格
SELECT REPLACE(NAME,CHAR(10),&#39;&#39;) FROM #temp --去掉空格
SELECT REPLACE(NAME,CHAR(ASCII(RIGHT(NAME,1))),&#39;&#39;) FROM #temp --在
不知道是最后一位是什么字符导致空格的情况下，先转 ASCII 码，在替换
DROP TABLE #temp
\----下面是查询结果:
\--&#39;明天就是国庆了 &#39;
\--&#39;明天就是国庆了 &#39;
\--&#39;明天就是国庆了&#39;
\--&#39;明天就是国庆了&#39;1.  根据你以往的经验简单叙述一下 MYSQL 的优化
答：
1.数据库的设计
尽量把数据库设计的更小的占磁盘空间.
1\).尽可能使用更小的整数类型.(mediumint 就比 int 更合适).
2\).尽可能的定义字段为 not null,除非这个字段需要 null.
3\).如果没有用到变长字段的话比如 varchar,那就采用固定大小的纪录格式比如 char.
4\).表的主索引应该尽可能的短.这样的话每条纪录都有名字标志且更高效.
5\).只创建确实需要的索引。索引有利于检索记录，但是不利于快速保存记录。如果总是
要在表的组合字段上做搜索，那么就在这些字段上创建索引。索引的第一部分必须是最
常使用的字段.如果总是需要用到很多字段，首先就应该多复制这些字段，使索引更好的
448
压缩。
6\).所有数据都得在保存到数据库前进行处理。
7\).所有字段都得有默认值。
8\).在某些情况下,把一个频繁扫描的表分成两个速度会快好多。在对动态格式表扫描以取
得相关记录时，它可能使用更小的静态格式表的情况下更是如此。
2.系统的用途
1\).尽量使用长连接.
2\).explain 复杂的 SQL 语句。
3\).如果两个关联表要做比较话，做比较的字段必须类型和长度都一致.
4\).LIMIT 语句尽量要跟 order by 或者 distinct.这样可以避免做一次 full table
scan.
5\).如果想要清空表的所有记录,建议用 truncate table tablename 而不是 delete
from tablename.
6\).能使用 STORE PROCEDURE 或者 USER FUNCTION 的时候.
7\).在一条insert语句中采用多重纪录插入格式.而且使用load data infile来导入大
量数据，这比单纯的 indert 快好多.
8\).经常 OPTIMIZE TABLE 来整理碎片.
9\).还有就是 date 类型的数据如果频繁要做比较的话尽量保存在 unsigned int
类型比较快。
3.系统的瓶颈
1\).磁盘搜索.
449
并行搜索,把数据分开存放到多个磁盘中，这样能加快搜索时间.
2\).磁盘读写(IO)
可以从多个媒介中并行的读取数据。
3\).CPU 周期
数据存放在主内存中.这样就得增加 CPU 的个数来处理这些数据。
4\).内存带宽
当 CPU 要将更多的数据存放到 CPU 的缓存中来的话,内存的带宽就成了瓶颈.
2.  以 Oracle11R 为例简述数据库集群部署
命令行工具
–crsctl 管理集群相关的操作：
\-启动和关闭 Oracle 集群
\-启用和禁用 Oracle 集群后台进程
\-注册集群资源
\-srvctl 管理 Oracle 资源相关操作
\-启动和关闭数据库实例和服务
在 Oracle Grid 安装的 home 路径下的命令行工具 crsctl 和 srvctl 用来管理 Oracle
集群。使用 crsctl 可以监控和管理任何集群节点的集群组件和资源。srvctl 工具提供了
类似的功能，来监控和管理 Oracle 相关的资源，例如数据库实例和数据库服务。crsctl
命令只能是集群管理者来运行，srvctl 命令可以是其他用户，例如数据库管理员来使用。
450
3.  说一下数据库的存储过程？
一、存储过程与函数的区别：
1.一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。
2.对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。
3.存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分
来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于 FROM 关键字的
后面。
二、存储过程的优点：
1.执行速度更快 – 在数据库中保存的存储过程语句都是编译过的
2.允许模块化程序设计 – 类似方法的复用
3.提高系统安全性 – 防止 SQL 注入
4.减少网络流通量 – 只要传输存储过程的名称
系统存储过程一般以 sp 开头，用户自定义的存储过程一般以 usp 开头
4.  数据库创建索引的缺点？
缺点：
第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物
理空间，如果要建立聚簇索引，那么需要的空间就会更大。
第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降
低了数据的维护速度。
451
5.  有两张表；请用 SQL 查询，所有的客户订单日期最新的前五条订单记录。
（分别注明 MySQL. Oracle 写法）
客户信息表(c CUSTOM)有以下字段：
id、name、mobile
客户订单表(C\_ORDER)有以下字段：
id、custom\_id、commodity、count、order \_date
Mysql:
Select \* from c\_order order by order\_date desc limit 0,5;
Oracle:
Select o.\*,rownum n
from c\_order order by order\_date desc where n&lt;6;
6.  关于 HQL 与 SQL,以下哪些说法正确？（）
A. HQL与SQL没什么差别
B. HQL 面向对象，而 SQL 操纵关系数据库
C. 在 HQL 与 SQL 中，都包含 select,insert,update,delete 语句
D. HQL 仅用于査询数据，不支持 insert,update 和 delete 语句
答案： BC
452
453
7.  下面是学生表（student）的结构说明
字段名称 字段解释 字段类型 字段长度 约束
s\_id 学号 字符 10 PK
s\_name 学生姓名 字符 50 Not null
s\_age 学生年龄 数值 3 Not null
s-sex 学生性别 字符（男：1 女：0） 1 Not null
下面是教师表（Teacher ）的结构说明
字段名称 字段解释 字段类型 字段长度 约束
t\_id 教师编号 字符 10 PK
t\_name 教师名字 字符 50 Not null
下面是课程表（Course）的结构说明
字段名称 字段解释 字段类型 字段长度 约束
c\_id 课程编号 字符 10 Pk
c\_name 课程名字 字符 50 Not null
t\_id 教师编号 字符 10 Not null
下面是成绩表（SC）的结构说明
字段名称 字段解释 字段类型 字段长度 约束
s\_id 学号 字符 10 Pk
c\_id 课程编号 字符 10 Pk
score 成绩 数值 3 Not null
1、查询“001”课程比“002”课程成绩高的所有学生的学号；
select a.s\_id from (select s\_id,score from SC where C\_ID=&#39;001&#39;) a,(select
s\_id,score
from SC where C\_ID=&#39;002&#39;) b
where a.score&gt;b.score and a.s\_id=b.s\_id;
2、查询平均成绩大于 60 分的同学的学号和平均成绩；
select S\_ID,avg(score)
from sc
group by S\_ID having avg(score) &gt;60;
3、查询所有同学的学号、姓名、选课数、总成绩；
select Student.S\_ID,Student.Sname,count(SC.C\_ID),sum(score)
from Student left Outer join SC on Student.S\_ID=SC.S\_ID
group by Student.S\_ID,Sname
4、查询姓“李”的老师的个数；
select count(distinct(Tname))
from Teacher
where Tname like &#39;李%&#39;;
5、查询没学过“叶平”老师课的同学的学号、姓名；
select Student.S\_ID,Student.Sname
from Student
where S\_ID not in (select distinct( SC.S\_ID) from SC,Course,Teacher where
SC.C\_ID=Course.C\_ID and Teacher.T#=Course.T# and Teacher.Tname=&#39;叶平&#39;);
454
6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；
select Student.S\_ID,Student.Sname from Student,SC where
Student.S\_ID=SC.S\_ID and SC.C\_ID=&#39;001&#39;and exists( Select \* from SC as SC\_2
where SC\_2.S\_ID=SC.S\_ID and SC\_2.C\_ID=&#39;002&#39;);
7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；
select S\_ID,Sname
from Student
where S\_ID in (select S\_ID from SC ,Course ,Teacher where SC.C\_ID=Course.C\_ID
and Teacher.T#=Course.T# and Teacher.Tname=&#39;叶平&#39; group by S\_ID having
count(SC.C\_ID)=(select count(C\_ID) from Course,Teacher where
Teacher.T#=Course.T# and Tname=&#39;叶平&#39;));
8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；
Select S\_ID,Sname from (select Student.S\_ID,Student.Sname,score ,(select score
from SC SC\_2 where SC\_2.S\_ID=Student.S\_ID and SC\_2.C\_ID=&#39;002&#39;) score2
from Student,SC where Student.S\_ID=SC.S\_ID and C\_ID=&#39;001&#39;) S\_2 where score2
\&lt;score;
9、查询所有课程成绩小于 60 分的同学的学号、姓名；
select S\_ID,Sname
from Student
where S\_ID not in (select S.S\_ID from Student AS S,SC where S.S\_ID=SC.S\_ID and
score&gt;60);
455
10、查询没有学全所有课的同学的学号、姓名；
select Student.S\_ID,Student.Sname
from Student,SC
where Student.S\_ID=SC.S\_ID group by Student.S\_ID,Student.Sname having
count(C\_ID) &lt;(select count(C\_ID) from Course);
11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；
select distinct S\_ID,Sname from Student,SC where Student.S\_ID=SC.S\_ID and
SC.C\_ID in (select C\_ID from SC where S\_ID=&#39;1001&#39;);
12、查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；
select distinct SC.S\_ID,Sname
from Student,SC
where Student.S\_ID=SC.S\_ID and C\_ID in (select C\_ID from SC where
S\_ID=&#39;001&#39;);
8.  为管理岗位业务培训信息，有如下 3 个表：
S（S#,SN,SD,SA)，其中 S#，SN,SD,SA 分别代表学号、学员姓名、所属单位、学员年龄。
C (C#,CN )，其中 C#,CN 分别代表课程编号、课程名称
SC(S#,C#，G)，其中 S#,C#，G 分别代表学号、所选修的课程编号、学习成绩
请使用 2 种标准 SQL 语句査洵选修课程名称为“税收基础”的学员学号和姓名，并说明
其优缺点 。
SQL92 标准：
SELECT SN,SD FROM S
456
WHERE \[S#] IN(
SELECT \[S#] FROM C,SC
WHERE C.\[C#]=SC.\[C#]
AND CN=N&#39;税收基础&#39;)
SQL99 标准：
select s.s#,s.sn from s
join sc on s.s#=sc.s#
join c on sc.c#=c.c#
where c.cn=&#39;税收基础&#39;
优点：
SQL99 将连接条件和过滤条件分开，显得代码清晰。
SQL92 书写简单易于理解。
缺点：
SQL92 连接条件和过滤条件都写在一起，不利于查看。
SQL99 书写相对麻烦不易于理解。
9.  用 Java 怎么实现有每天有 1 亿条记录的 DB 储存？MySQL 上亿记录数
据量的数据库如何设计？
1.这么大数据量首先建议 使用大数据的 DB，可以用 spring batch 来做类似这样的处理。
定量向 DB 存储数据。如果需要定时，可以考虑 quartz。
Mysql 数据库设计:
1.读写分离；
457
2.纵向横向拆分库、表。
MySQL 的基本功能中包括 replication（复制）功能。所谓 replication，就是确定 master
以及与之同步的 slave 服务器，再加上 slave 将 master 中写入的内容 polling 过来更新
自身内容的功能。这样 slave 就是 master 的 replica（复制品）。这样就可以准备多台内
容相同的服务器。
通过 master 和 salve 的 replication，准备好多台服务器之后，让应用程序服务器通
过负载均衡器去处理查询 slave。这样就能将查询分散到多台服务器上。
应用程序实现上应该只把 select 等读取之类的查询发送给负载均衡器，而更新应当
直接发送给 master。要是在 slave 上执行更新操作，slave 和 master 的内容就无法同
步。MySQL 会检测到 master 和 slave 之间内容差异，并停止 replication，这回导致系
统故障。Slave 可以采用 LVS（linux 系统自带的负载均衡器）实现查询的负载均衡。
使用 MySQL 的 replication 是利用的冗余化，实现冗余化需要实现的最小服务器数量是
4 台，三台 slave 和一台 master，slave 为什么是需要三台呢，比如一台 slave 死机了，
现在需要修复再次上线，那么意味着你必须停止一台 slave 来复制 MySQL 的数据，如
果只有两台 slave，一台坏了，你就必须停止服务，如果有三台，坏了一台，你复制数据
时停止一台，还有一台可以运维。
对于数据的处理是能放入到内存中就尽量放入到内存中如果不能放入到内存中，可以利
用 MySQL 的 Partitioning。
Partitioning 就是表分割也就是讲 A 表和 B 表放在不同的服务器上。简单来说，
Partitioning 就是充分利用局部性进行分割，提高缓存利用效率，从而实现 Partitioning
458
的效果。其中最重要的一点就是以 Partitioning 为前提设计的系统将表分割开，用
RDBMS 的方式的话，对于一对多的关系经常使用 JOIN 查询将两张表连接起来。但是如
果将表分割开了之后，也就是两张表不在同一个数据库，不在同一个服务器上怎样使用
JOIN 操作，这里需要注意的是如果是用 where in 操作不是省了一些麻烦了嘛。
10. Mysql 的引擎有哪些？支持事物么？DB 储存引擎有哪些？
MySQL 有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：
MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、
FEDERATED、ARCHIVE、CSV、BLACKHOLE。
MySQL 支持数个存储引擎作为对不同表的类型的处理器。MySQL 存储引擎包括处理事
务安全表的引擎和处理非事务安全表的引擎。
· MyISAM 管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM 在所
有 MySQL 配置里被支持，它是默认的存储引擎，除非你配置 MySQL 默认使用另外一
个引擎。
· MEMORY 存储引擎提供“内存中”表。MERGE 存储引擎允许集合将被处理同样的
MyISAM 表作为一个单独的表。就像 MyISAM 一样，MEMORY 和 MERGE 存储引擎处
理非事务表，这两个引擎也都被默认包含在 MySQL 中。
注释：MEMORY 存储引擎正式地被确定为 HEAP 引擎。
· InnoDB 和 BDB 存储引擎提供事务安全表。BDB 被包含在为支持它的操作系统发布的
MySQL-Max 二进制分发版里。InnoDB 也默认被包括在所 有 MySQL 5.1 二进制分发
版里，你可以按照喜好通过配置 MySQL 来允许或禁止任一引擎。
· EXAMPLE 存储引擎是一个“存根”引擎，它不做什么。你可以用这个引擎创建表，但
459
460
没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL 源代码中的
一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。
· NDB Cluster 是被 MySQL Cluster 用来实现分割到多台计算机上的表的存储引擎。它
在 MySQL-Max 5.1 二进制分发版里提供。这个存储引擎当前只被 Linux, Solaris, 和
Mac OS X 支持。在未来的 MySQL 分发版中，我们想要添加其它平台对这个引擎的支
持，包括 Windows。
· ARCHIVE 存储引擎被用来无索引地，非常小地覆盖存储的大量数据。
· CSV 存储引擎把数据以逗号分隔的格式存储在文本文件中。
· BLACKHOLE 存储引擎接受但不存储数据，并且检索总是返回一个空集。
· FEDERATED 存储引擎把数据存在远程数据库中。在 MySQL 5.1 中，它只和 MySQL
一起工作，使用 MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动
器或客户端连接方法连接到另外的数据源。
11. 以下是学生考试结果表
fname kecheng fenshu
张三 语文 81
张三 数学 65
李四 语文 76
李四 数学 90
王五 语文 61
王五 数学 100
王五 英语 90
1.请用一条 sql 语句从 t\_result 表中查询出每门课都大于 75 分的学生姓名；
select b.fname from
(select fname,count(kecheng) c from t\_result group by fname)a,
(Select fname,kecheng,count(fname) c from t\_result where fenshu &gt;75 group by
fname)b
where a.fname = b.fname and a.c = b.c
2.请用一条 sql 写出总分排名前三的学生姓名，总分，平均分
select fname,sum(fenshu),avg(fenshu) from t\_result GROUP By fname order by
SUM(fenshu) desc;
12. 库中已经存在雇用表表名：
org\_employee;表中字段：雇员编号（emp\_id）,雇员姓名（em\_name）,雇员年龄
（emp\_age）,雇员部门（depart\_name）;请写出执行以下操作的 sql 语句：
1）向表中增加一条数据：雇员编号（1001），雇员姓名（张三），雇员年龄（24），雇员
部门（研发部）；
INSERT INTO org\_employee
VALUES(‘1001’,’张三’,’24’,’研发部’);
2）查询雇员年龄在 55（包含）至 60（不包含）岁之间的雇员数据
SELECT \* FROM org\_employee
WHERE emp\_age&gt;=55 and emp\_age &lt;60;
3）分部门查询各个部门的雇员数量
SELECT COUNT(\*),depart\_name group by depart\_name;
461
462
4）删除姓名为张三的雇员数据
Delete from org\_employee where em\_name =’张三’;
5）在表中增加一个日期类型的字段雇员出生日期，字段为 emp\_brithday
Alter table org\_employee add(emp\_brithday date);
6）将表 org\_employee 删除
drop org\_employee;
13. 如下表 1 中的数据，表名为：t\_test,记录某场比赛的结果。
请用 sql 语句实现表 2 的查询结果
ID matchdate result
1 2015-02-04 胜
2 2015-02-04 负
3 2015-02-04 胜
4 2015-04-07 负
5 2015-04-07 胜
6 2015-04-07 负
表 1
比赛日期 胜 负
2015-02-04 2 1
2015-04-07 1 2
表 2
SQL 语句：
463
create table t\_second(
matchdate date,
win varchar(3),
lose varchar(3)
);
insert into t\_second (matchdate,win) select matchdate,count(result) from t\_test
where result =&#39;胜&#39; GROUP BY matchdate;
update t\_second,(select matchdate,count(result) as lose from t\_test where result
\=&#39;负&#39; GROUP BY matchdate)s set t\_second.lose = s.lose where
t\_second.matchdate = s.matchdate;
14. 请将如下数据库语句进行优化，使其执行效率更高（提示：…不需要更
改）
SELECT…
FROM EMP
WHERE DEPT\_NO NOT IN (SELECT DEPT\_NO
FROM DEPT
WHERE DEPT\_CAT=’A’);
优化后：
464
SELECT…
FROM EMP
WHERE DEPT\_NO NOT EXISTS(SELECT DEPT\_NO
FROM DEPT
WHERE DEPT\_CAT=’A’);
优化的理由：not in 和 not exists
如果查询语句使用了 not in 那么内外表都进行全表扫描，没有用到索引；
而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not
in 要快。
15. 请简述如何将 Oracle 中的数据库转至 DB2 中，需要保证表结构和数据
不变
使用 ETL 工具，如 infomatic,datastage,kettle 等，可以完成异构数据库的迁移
以 kettle 为例
表输入选择 oracle 库
表输出选择 DB 库
循环执行可以进行全库迁移
16. 学生成绩表
姓名：name 课程：subject 分数：score 学号：stuid
张三 数学 89 1
张三 语文 80 1
465
张三 英语 70 1
李四 数学 90 2
李四 语文 70 2
李四 英语 80 2
1.计算每个人的总成绩并排名（要求显示字段：姓名，总成绩）
select name,sum(score) s from t\_stu GROUP BY name;
2.列出各门课程成绩最好的学生（要求显示字段：学号，姓名，科目，成绩）
select t1.stuid,t1.name,t1.subject,t1.score from t\_stu t1,(
select subject,MAX(score) as maxscore from t\_stu group by subject)t2
where t1.subject = t2.subject and t1.score = t2.maxscore;
3.列出各个课程的平均成绩（要求显示字段；课程，平均成绩）
select subject,AVG(score)平均成绩 from t\_stu
group by subject;
17. Oracl 数据库中有两张表 Stu（学生表）和 Grade（分数表），如下图所
示：
Stu 表
sid（学生 ID） sname(姓名) sage（年龄）
1 张三 23
2 李四 25
3 王五 24
Grade 表
466
gid（分数主键） cid（课程 ID） sid(学生主键) grade（分数）
1 2 3 86
2 2 2 79
3 1 2 80
4 1 1 81
5 1 3 70
6 2 1 78
请写 sql 统计出有两门以上的课的分数在 80 分以上的学生的姓名和年龄？
Select sname,sage from Stu where Stu.sid in (
Select sid from Grade where grade &gt;80
)
18. 下面是学生表（Student）的结构说明：
字段名称 字段解释 字段类型 字段长度 约束
s\_id 学号 字符 10 PK
s\_name 学生姓名 字符 50 Not null
s\_age 学生年龄 数值 3 Not null
s\_sex 学生性别 字符（男：1 女：0） 1 Not null
下面是教师表（Teacher）
字段名称 字段解释 字段类型 字段长度 约束
t\_id 教师编号 字符 10 PK
t\_name 教师名字 字符 50 Not null
467
下面是课程表（Course）的结构说明：
字段名称 字段解释 字段类型 字段长度 约束
c\_id 课程编号 字符 10 PK
c\_name 课程名字 字符 50 Not null
t\_id 教师编号 字符 10 Not null
下面是成绩表（SC）的结构说明：
字段名称 字段解释 字段类型 字段长度 约束
s\_id 字符 字符 10 PK
c\_id 课程编号 字符 10 PK
score 成绩 数值 3 Not null
查询同名同姓学生名单，并统计同名人数
select 姓名，count(学号) as num
from 学生表
group by 姓名
having count(学号)&gt;1 --保证查找到的都是存在 2 个以上（包括 2）的同名同姓的姓名
及人数。
查询平均成绩大于 60 分的学生的学号和平均成绩；
Select s\_id,avg(score) from sc groupby s\_id having avg(score)&gt;60
查询姓“李”的老师的个数；
Select count(\*),teacher.t\_name from teacher where teacher.t\_name like &#39;李%&#39;
468
19. 取出 sql 表中低 31 到 40 的记录（以自动增长 ID 为主键）
Sql server 方案：
select top 10 \* from t where id not in
(select top 30 id from t order by id ) orde by id
Mysql 方案：select \* from t order by id limit 30,10
Oracle 方案：
select rownum num,tid from (select rownum num,tid from t\_test)
where num&gt;=30 and num&lt;=41;
20. 下列两个表，需要用一条 sql 语句把 b 表中的 ID 和 NAME 字段的数值
复制到 A 表中
A 表
ID NAME
B 表
ID NAME OTHER
1 Aaa Ddd
2 Bbb Eee
insert into a select id,name from b;
21. 什么是基本表，什么是视图，两者的区别和联系是什么？
它是从一个或几个基本表中导出的 表，是从现有基本表中抽取若干子集组成用户的“专
用表”。
基本表：基本表的定义指建立基本关系模式,
而变更则是指对数据库中已存在的基本表进行删除与修改。
区别：
1、视图是已经编译好的 sql 语句。而表不是
2、视图没有实际的物理记录。而表有。
3、表是内容，视图是窗口
4、表只用物理空间而视图不占用物理空间，
视图只是逻辑概念的存在，表可以及时对它进行修改，
但视图只能有创建的语句来修改
5、表是内模式，试图是外模式
6、视图是查看数据表的一种方法，
可以查询数据表中某些字段构成的数据，
只是一些 SQL 语句的集合。从安全的角度说，
视图可以不给用户接触数据表，从而不知道表结构。
7、表属于全局模式中的表，是实表；视图属于局部模式的表，
是虚表。
8、视图的建立和删除只影响视图本身，不影响对应的基本表。
联系：视图（view）是在基本表之上建立的表，它的结构（
即所定义的列）和内容（即所有数据行）都来自基本表，
它依据基本表存在而存在。一个视图可以对应一个基本表，
也可以对应多个基本表。
469
视图是基本表的抽象和在逻辑意义上建立的新关系
22. 什么是事务？什么是锁？
事务与锁是不同的。事务具有 ACID（
原子性、一致性、隔离性和持久性），锁是用于解决隔离性的一种机制。事务的隔离级别
通过锁的机制来实现。另外锁有不同的粒度，同时事务也是有不同的隔离级别的（一般
有四种：读未提交 Read uncommitted，
读已提交 Read committed，
可重复读 Repeatable read，
可串行化 Serializable）。
在具体的程序设计中，开启事务其实是要数据库支持才行的，如果数据库本身不支持事
务，那么仍然无法确保你在程序中使用的事务是有效的。
锁可以分为乐观锁和悲观锁：
悲观锁：认为在修改数据库数据的这段时间里存在着也想修改此数据的事务；
乐观锁：认为在短暂的时间里不会有事务来修改此数据库的数据；
我们一般意义上讲的锁其实是指悲观锁，在数据处理过程中，将数据置于锁定状态（由
数据库实现）
如果开启了事务，在事务没提交之前，别人是无法修改该数据的；如果 rollback，你在
本次事务中的修改将撤消（不是别人修改的会没有，因为别人此时无法修改）。当然，前
提是你使用的数据库支持事务。还有一个要注意的是，部分数据库支持自定义 SQL 锁覆
盖事务隔离级别默认的锁机制，如果使用了自定义的锁，那就另当别论。
重点：一般事务使用的是悲观锁（具有排他性）
470
23. Student 学生表（学号，姓名、性别、年龄、组织部门），Course 课程
表（编号，课程名称），Sc 选课表（学号，课程编号，成绩）
写一个 SQL 语句，查询选修了计算机原理的学生学号和姓名
select 学号，姓名 from Student where 学号 in
（select 学号 from Sc where 课程编号 in
(Select 课程编号 from Course where 课程名称 = ‘计算机原理’)）
写一个 SQL 语句，查询“周星驰”同学选修了的课程名字
select 课程名称 from Course where 编号 in (
select Sc.课程编号 from Student,Sc where Student.姓名=’周星驰’ and
Student.学号 = Sc.学号)
写一个 SQL 语句，查询选修了 5 门课程的学生学号和姓名
Select 学号，姓名 from Student where 学号 in (
Select 学号，count(课程编号) from Sc group by 学号 having count(课程编号)&gt;=5)
24. sql 查询
Student(S#,Sname,Sage,Ssex)学生表
S#：学号
Sname:学生姓名
Sage：学生年龄
Ssex: 学生性别
Course(C#,Cname,T#)课程表
471
C#,课程编号；
Cname:课程名字；
T#：教师编号；
SC(S#,C#,score)成绩表
S#:学号；
C#,课程编号；
Score：成绩；
Teacher(T#,Tname)教师表
T#:教师编号；
Tname:教师名字
查询“001”课程比“002”课程成绩高的所有学生学号
select SC1.S#
from SC SC1 JOIN SC SC2 ON SC1.S#=SC2.S#
WHERE SC1.C#=&#39;001&#39; AND SC2.C#=&#39;002&#39; AND SC1.score&gt;SC2.score
查询平均成绩大于 60 分的同学的学号和平均成绩
select S#,AVG(score) 平均成绩
from SC
group by S#
having AVG(score)&gt;60
472
查询所有同学的学号、姓名、选课数、总成绩
select Student.S#,Sname,COUNT(*) 选课数,SUM(score) 总成绩
from Student JOIN SC on Student.S#=SC.S#
group by Student.S#,Sname
查询姓“李”的老师的个数
Select count(*) from Teacher where Tname like ‘李%’;查询没学过“叶平”老师课的同学的学号、姓名
SELECT stu2.s#,stu2.stuname FROM Student stu2 WHERE stu2.s# NOT IN
(SELECT DISTINCT stu.s# FROM student stu, course c,teacher tea,score score
WHERE stu.s#= score.s# AND course.c#= score.c#
AND tea.t#= course.t#AND tea.tname= &#39;叶平&#39; )
JVM：1.  简述 Java 内存管理机制，以及垃圾回收的原理和使用过 Java 调优工具
内存管理的职责为分配内存，回收内存。 没有自动内存管理的语言/平台容易发生
错误。
典型的问题包括悬挂指针问题，一个指针引用了一个已经被回收的内存地址，导致
程序的运行完全不可知。
另一个典型问题为内存泄露，内存已经分配，但是已经没有了指向该内存的指针，
473
导致内存泄露。 程序员要花费大量时间在调试该类问题上。
2.  描述 JVM 加载 class 文件的原理机制
JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类
加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。
由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个
或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接
（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读入到内存中，
通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的 Class 对象。加载
完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，
这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号
引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：1)如果类存在直接
的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，
就依次执行这些初始化语句。
类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加
载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader
的子类）。从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM
更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，
其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加
载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap
的引用。下面是关于几个类加载器的说明：
Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；
474
Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是
Bootstrap；
System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。
它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户
自定义加载器的默认父加载器。
3.  说说 JVM 原理？内存泄漏与溢出的区别？何时产生内存泄漏？
答:
JVM 原理：
JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，它是整个 java 实现跨平台的最
核心的部分，所有的 Java 程序会首先被编译为.class 的类文件，这种类文件可以在虚拟
机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与
操作系统交互，由虚拟机将程序解释给本地系统执行。JVM 是 Java 平台的基础，和实
际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。JVM 通过抽
象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、
主机硬件、主机操作系统无关。JVM 的主要工作是解释自己的指令集（即字节码）到 CPU
的指令集或对应的系统调用，保护用户免被恶意程序骚扰。JVM 对上层的 Java 源文件
是不关心的，它关注的只是由源文件生成的类文件（.class 文件）。
内存泄漏与溢出的区别：1.  内存泄漏是指分配出去的内存无法回收了。
2.  内存溢出是指程序要求的内存，超出了系统所能分配的范围，从而发生溢出。比如用
475
byte 类型的变量存储 10000 这个数据，就属于内存溢出。
3.  内存溢出是提供的内存不够；内存泄漏是无法再提供内存资源。
何时产生内存泄漏：
4.  静态集合类：在使用 Set、Vector、HashMap 等集合类的时候需要特别注意，有可
能会发生内存泄漏。当这些集合被定义成静态的时候，由于它们的生命周期跟应用程序
一样长，这时候，就有可能会发生内存泄漏。
5.  监听器：在 Java 中，我们经常会使用到监听器，如对某个控件添加单击监听器
addOnClickListener()，但往往释放对象的时候会忘记删除监听器，这就有可能造成内
存泄漏。好的方法就是，在释放对象的时候，应该记住释放所有监听器，这就能避免了
因为监听器而导致的内存泄漏。
6.  各种连接：Java 中的连接包括数据库连接、网络连接和 io 连接，如果没有显式调用
其 close()方法，是不会自动关闭的，这些连接就不能被 GC 回收而导致内存泄漏。一般
情况下，在 try 代码块里创建连接，在 finally 里释放连接，就能够避免此类内存泄漏。
7.  外部模块的引用：调用外部模块的时候，也应该注意防止内存泄漏。如模块 A 调用了
外部模块 B 的一个方法，如：public void register(Object o)。这个方法有可能就使得
A 模块持有传入对象的引用，这时候需要查看 B 模块是否提供了去除引用的方法，如
unregister()。这种情况容易忽略，而且发生了内存泄漏的话，比较难察觉，应该在编写
代码过程中就应该注意此类问题。
8.  单例模式：使用单例模式的时候也有可能导致内存泄漏。因为单例对象初始化后将在
JVM 的整个生命周期内存在，如果它持有一个外部对象（生命周期比较短）的引用，那
476
么这个外部对象就不能被回收，而导致内存泄漏。如果这个外部对象还持有其它对象的
引用，那么内存泄漏会更严重，因此需要特别注意此类情况。这种情况就需要考虑下单
例模式的设计会不会有问题，应该怎样保证不会产生内存泄漏问题。1.  GC 线程是否为守护线程？
GC 线程是守护线程。线程分为守护线程和非守护线程（即用户线程）。只要当前 JVM 实
例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守
护线程结束时，守护线程随着 JVM 一同结束工作。
2.  Java 的类加载器都有哪些，每个类加载器都有加载那些类，什么是双亲
委派模型，是做什么的？
答：
类加载器按照层次，从顶层到底层，分为以下三种：
（1）启动类加载器（Bootstrap ClassLoader）
这个类加载器负责将存放在 JAVA\_HOME/lib 下的，或者被-Xbootclasspath 参数所
指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法
被 Java 程序直接引用。
（2）扩展类加载器（Extension ClassLoader）
这个加载器负责加载 JAVA\_HOME/lib/ext 目录中的，或者被 java.ext.dirs 系统变量
所指定的路径中的所有类库，开发者可以直接使用扩展类加载器
（3）应用程序类加载器（Application ClassLoader）
这个加载器是 ClassLoader 中 getSystemClassLoader()方法的返回值，所以一般也
称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，可直
477
接使用这个加载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是
程序中默认的类加载器
双亲委派模型：
双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类
加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合
关系来复用父加载器的代码
工作过程：
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把
这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加
载请求最终都应该传递到顶层的启动类加载器中，只有当父类加载器反馈自己无法完
成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
好处：
Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 Object，
它放在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器
进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类，判断两个类
是否相同是通过 classloader.class 这种方式进行的，所以哪怕是同一个 class 文件如
果被两个 classloader 加载，那么他们也是不同的类。
加载过程如图：
3.  垃圾回收器（GC）的基本原理是什么？垃圾回收器可以马上回收内存吗？
如何通知虚拟机进行垃圾回收？
答：
478
479
1、对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及
使用情况。通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这
种方式确定哪些对象是&quot;可达的&quot;，哪些对象是&quot;不可达的&quot;。当 GC 确定一些对象为&quot;不
可达”时，GC 就有责任回收这些内存空间。
2、可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并
不保证 GC 一定会执行。
4.  System.gc();或者 Runtime.getRuntime().gc();
5.  Java 中会存在内存泄漏吗，请简单描述。
答：理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广
泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达
的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是hibernate的Session
（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象
中可能存在无用的垃圾对象。下面的例子也展示了 Java 中发生内存泄露的情况：
package com.bjsxt;
import java.util.Arrays;
import java.util.EmptyStackException;public class MyStack\&lt;T&gt; &#123;
private T\[] elements;
private int size = 0;
private static final int INIT\_CAPACITY = 16;
public MyStack() &#123;
elements = (T\[]) new Object\[INIT\_CAPACITY];
&#125;
public void push(T elem) &#123;
ensureCapacity();
elements\[size++] = elem;
&#125;
public T pop() &#123;
480
if(size == 0)
throw new EmptyStackException();
return elements\[--size];
&#125;
private void ensureCapacity() &#123;
if(elements.length == size) &#123;
elements = Arrays.copyOf(elements, 2 \* size + 1);
&#125;
&#125;
&#125;
上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问
题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在内存泄露的问
题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的
程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete
reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是
无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处
理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可
能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会
引发 Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成
OutOfMemoryError。1.  GC 是什么？为什么要有 GC？
答：GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的
内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象
是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显
示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求
垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，
但 JVM 可以屏蔽掉显示的垃圾回收调用。
垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作
为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时
间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所
有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务
器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已
经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好
的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。
补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回
收等方式。标准的 Java 进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建
的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和清除，但是 Java 对
其进行了改进，采用“分代式垃圾收集”。这种方法会跟 Java 对象的生命周期将堆内存
划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：
• 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯
一存在过的区域。
• 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。
• 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）
过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发
一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的
空间。
与垃圾回收相关的 JVM 参数：
481
• -Xms / -Xmx --- 堆的初始大小 / 堆的最大大小
• -Xmn --- 堆中年轻代的大小
• -XX:-DisableExplicitGC --- 让 System.gc()不产生任何作用
• -XX:+PrintGCDetail --- 打印 GC 的细节
• -XX:+PrintGCDateStamps --- 打印 GC 操作的时间戳
Linux 操作：
2.  请写出常用的 linux 指令不低于 10 个，请写出 linux tomcat 启动。
答：linux 指令
arch 显示机器的处理器架构(1)
uname -m 显示机器的处理器架构(2)
shutdown -h now 关闭系统(1)
shutdown -r now 重启(1)
cd /home 进入 &#39;/ home&#39; 目录&#39;
cd .. 返回上一级目录
cd ../.. 返回上两级目录
mkdir dir1 创建一个叫做 &#39;dir1&#39; 的目录&#39;
mkdir dir1 dir2 同时创建两个目录
find / -name file1 从 &#39;/&#39; 开始进入根文件系统搜索文件和目录
find / -user user1 搜索属于用户 &#39;user1&#39; 的文件和目录
linuxtomcat 启动
482
进入 tomcat 下的 bin 目录执行 ./catalina.sh start 直接启动即可，然后使用 tail -f
/usr/local/tomcat6/logs/catalina.out 查看 tomcat 启动日志。
3.  当使用 RMI 技术实现远程方法调用时，能为远程对象生成 Sub 和
Skeleton 命令的是（）
A. Mic
B. mid
C. mitegistry
D. policytool
答案：A
4.  以下哪个是服务（）
A. kill
B. tar
C. rsyne
D. lsof
答案\:c
分析：
A\:kill 命令,常用于杀死进程;
B\:tar 命令,tar 命令是 Unix/Linux 系统中备份文件的可靠方法，几乎可以
工作于任何环境中，它的使用权限是所有用户
C:类 unix 系统下的数据镜像备份工具
D:在终端下输入 lsof 即可显示系统打开的文件，因为 lsof 需要访问核心
483
484
内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥
其功能
5.  下面的网络协议中，面向连接的的协议是： （）
A. 传输控制协议
B. 用户数据报协议
C. 网际协议
D. 网际控制报文协议
答案：A
6.  在/etc/fstab 文件中指定的文件系统加载参数中， （） 参数一般用于
CD-ROM 等移动设备。
A. defaults
B. sw
C. rw 和 ro
D. noauto
答案：D
7.  Linux 文件权限一共 10 位长度，分成四段，第三段表示的内容是 （）
A. 文件类型
B. 文件所有者的权限
C. 文件所有者所在组的权限
D. 其他用户的权限
答案：C
8.  终止一个前台进程可能用到的命令和操作 （）
A. kill
B. \&lt;CTRL&gt;;+C
C. shut down
D. halt
答案：B
9.  在使用 mkdir 命令创建新的目录时，在其父目录不存在时先创建父目录
的选项是 （）
A. -m
B. -d
C. -f
D. -p
答案：D
10. 下面关于 i 节点描述错误的是 （）
A. i 节点和文件是一一对应的（每个文件都有唯一一个索引结点号与之
对应，而对于一个索引结点号，却可以有多个文件名与之对应）
B. i 节点能描述文件占用的块数
C. i 节点描述了文件大小和指向数据块的指针
D. 通过i 节点实现文件的逻辑结构和物理结构的转换
答案：A
485
486
11. 一个文件名字为 rr.Z，可以用来解压缩的命令是： （）
A. tar
B. gzip
C. compress
D. uncompress
答案：D
12. 具有很多 C 语言的功能，又称过滤器的是 （）
A. csh
B. tcsh
C. awk
D. sed
答案：C
13. 一台主机要实现通过局域网与另一个局域网通信，需要做的工作是 （）
A. 配置域名服务器
B. 定义一条本机指向所在网络的路由
C. 定义一条本机指向所在网络网关的路由
D. 定义一条本机指向目标网络网关的路由
答案：C
14. 建立动态路由需要用到的文件有 （）
A. /etc/hosts
B. /etc/HOSTNAME
C. /etc/resolv.conf
D. /etc/gateways
答案：D
15. 局域网的网络地址 192.168.1.0/24，局域网络连接其它网络的网关地址
是 192.168.1.1。主机 192.168.1.20 访问 172.16.1.0/24 网络时，其路
由设置正确的是 （）
A. route add –net 192.168.1.0 gw 192.168.1.1 netmask
255.255.255.0 metric 1
B. route add –net 172.16.1.0 gw 192.168.1.1 netmask
255.255.255.0 metric 1
C. route add –net 172.16.1.0 gw 172.16.1.1 netmask
255.255.255.0 metric 1
D. route add default 192.168.1.0 netmask 172.168.1.1 metric 1
答案：B
16. 下列提法中，不属于 ifconfig 命令作用范围的是 （）
A. 配置本地回环地址
B. 配置网卡的IP地址
C. 激活网络适配器
D. 加载网卡到内核中
答案：D
487
17. 下列关于链接描述，错误的是（）
A. 硬链接就是让链接文件的i 节点号指向被链接文件的i 节点
B. 硬链接和符号连接都是产生一个新的i 节点
C. 链接分为硬链接和符号链接
D. 硬连接不能链接目录文件
答案：B
18. 在局域网络内的某台主机用 ping 命令测试网络连接时发现网络内部的
主机都可以连同，而不能与公网连通，问题可能是（）
A. 主机IP设置有误
B. 没有设置连接局域网的网关
C. 局域网的网关或主机的网关设置有误
D. 局域网DNS服务器设置有误
答案：C
19. 下列文件中，包含了主机名到 IP 地址的映射关系的文件是：
A. /etc/HOSTNAME
B. /etc/hosts
C. /etc/resolv.conf
D. /etc/networks
答案：B
488
489
20. 不需要编译内核的情况是（）
A. 删除系统不用的设备驱动程序时
B. 升级内核时
C. 添加新硬件时
D. 将网卡激活
答案：D
21. 在 shell 中变量的赋值有四种方法，其中，采用 name=12 的方法称（）
A. 直接赋值
B. 使用read命令
C. 使用命令行参数
D. 使用命令的输出
答案：A
22. （）命令可以从文本文件的每一行中截取指定内容的数据。
A. cp
B. dd
C. fmt
D. cut
答案：D
23. 下列不是 Linux 系统进程类型的是（）
A. 交互进程
B. 批处理进程
C. 守护进程
D. 就绪进程
答案：D
24. 在日常管理中，通常 CPU 会影响系统性能的情况是： （）
A. CPU 已满负荷地运转
B. CPU 的运行效率为30%
C. CPU 的运行效率为50%
D. CPU 的运行效率为80%
答案：A
25. 若一台计算机的内存为 128MB，则交换分区的大小通常是
A. 64MB
B. 128MB
C. 256MB
D. 512MB
答案：C
26. 在安装 Linux 的过程中的第五步是让用户选择安装方式，如果用户希望
安装部分组件（软件程序），并在选择好后让系统自动安装，应该选择的选项
是（）
A. full
B. expert
C. newbie
490
D. menu
答案：D
27. Linux 有三个查看文件的命令，若希望在查看文件内容过程中可以用光
标上下移动来查看文件内容，应使用（）命令
A. cat
B. more
C. less
D. menu
答案：C
28. 下列信息是某系统用 ps –ef 命令列出的正在运行的进程 （）进程是运
行 Internet 超级服务器，它负责监听 Internet sockets 上的连接，并调
用合适的服务器来处理接收的信息。
A. root 1 4.0 0.0 344 204? S 17:09 0:00 init
B. root 2 0.0 0.1 2916 1520? S 17:09 0:00 /sbin/getty
C. root 3 0.0 0.2 1364 632? S 17:09 0:00 /usr/sbin/syslogd
D. root 4 0.0 1344 1204? S 17:09 0:10 /usr/sbin/inetd
答案：D
29. 在 TCP/IP 模型中，应用层包含了所有的高层协议，在下列的一些应用
协议中， （）是能够实现本地与远程主机之间的文件传输工作
A. telnet
491
B. FTP
C. SNMP
D. NFS
答案：B
30. 当我们与某远程网络连接不上时，就需要跟踪路由查看，以便了解在网
络的什么位置出现了问题，满足该目的的命令是（）
A. ping
B. ifconfig
C. traceroute
D. netstat
答案：C
31. 对名为 fido 的文件用 chmod 551 fido 进行了修改，则它的许可权是
（）
A. -rwxr-xr-x
B. -rwxr--r--
C. -r--r--r--
D. -r-xr-x—x
答案：D
32. 用 ls –al 命令列出下面的文件列表，（）文件是符号连接文件
A. -rw-rw-rw- 2 hel-s users 56 Sep 09 11:05 hello
B. -rwxrwxrwx 2 hel-s users 56 Sep 09 11:05 goodbey
492
C. drwxr--r-- 1 hel users 1024 Sep 10 08:10 zhang
D. lrwxr--r-- 1 hel users 2024 Sep 12 08:12 cheng
答案：D
33. DNS 域名系统主要负责主机名和（）之间的解析。
A. IP地址
B. MAC地址
C. 网络地址
D. 主机别名
答案：A
34. WWW 服务器是在 Internet 上使用最为广泛，它采用的是（）结构
A. 服务器/工作站
B. B/S
C. 集中式
D. 分布式
答案：B
35. Linux 系统通过（）命令给其他用户发消息。
A. less
B. mesg
C. write
D. echo to
答案：C
493
36. NFS 是（）系统。
A. 文件
B. 磁盘
C. 网络文件
D. 操作
答案：C
37. （）命令可以在 Linux 的安全系统中完成文件向磁带备份的工作
A. cp
B. tr
C. dir
D. cpio
答案：D
38. Linux 文件系统的文件都按其作用分门别类地放在相关的目录中，对于
外部设备文件，一般应将其放在（）目录中
A. /bin
B. /etc
C. /dev
D. /lib
答案：C
494
39. 在重新启动 Linux 系统的同时把内存中的信息写入硬盘，应使用（）命
令实现
A. # reboot
B. # halt
C. # reboot
D. # shutdown –r now
答案：D
40. 网络管理具备以下几大功能：配置管理、（）、性能管理、安全管理和计
费管理等
A. 故障管理
B. 日常备份管理
C. 升级管理
D. 发送邮件
答案：A
41. 关闭 linux 系统（不重新启动）可使用命令（）
A. Ctrl+Alt+Del
B. halt
C. shutdown -r now
D. reboot
答案：B
495
42. 实现从 IP 地址到以太网 MAC 地址转换的命令为： （）
A. ping
B. ifconfig
C. arp
D. traceroute
答案：C
43. 在 vi 编辑器中的命令模式下，键入（）可在光标当前所在行下添加一新
行
A. &lt;a&gt;;
B. \&lt;o&gt;;
C. &lt;i&gt;;
D. A
答案：B
44. 在 vi 编辑器中的命令模式下，删除当前光标处的字符使用（）命令
A. \&lt;x&gt;;
B. \&lt;d&gt;;\&lt;w&gt;;
C. \&lt;D&gt;;
D. \&lt;d&gt;;\&lt;d&gt;;
答案：A
496
45. 在 vi 编辑器中的命令模式下，重复上一次对编辑的文本进行的操作，可
使用（）命令
A. 上箭头
B. 下箭头
C. &lt;.&gt;;
D. &lt;\*&gt;;
答案：C
46. 删除文件命令为： （）
A. mkdir
B. rmdir
C. mv
D. rm
答案：D
47. 退出交互模式的 shell，应键入（）
A. \&lt;Esc&gt;;
B. ^q
C. exit
D. quit\_\_
答案：C
497
498
算法分析及手写代码：
48. 判断身份证：要么是 15 位，要么是 18 位，最后一位可以为字母，并写
出程序提出其中年月日。要求：
写出合格的身份证的正则表达式，
^(\d&#123;15&#125;|\d&#123;17&#125;\[\dx])\$
写程序提取身份证中的年月日
public class IdCard
&#123;
private String idCard;//私有变量
public IdCard()&#123;&#125;//构造方法
//构造方法
public IdCard(String idCard)&#123;
this.idCard=idCard;
&#125;public void setIdCard(String idCard)
&#123;
this.idCard=idCard;
&#125;public String getIdCard()
&#123;
return idCard;
&#125;//从身份证号码中截取生日
public String getBirthday()
&#123;
return this.getIdCard().substring(6, 14);
&#125;public static void main(String args\[])
499
&#123;
ShenFenZheng sfz = new
ShenFenZheng(&quot;420154199908157841&quot;);
//调用 getBirthday()方法获取生日
System.out.println(&quot;生日：&quot; + sfz.getBirthday());
&#125;
&#125;1.  对于一个字符串，请设计一个高效算法，找到第一次重复出现的字符保
证字符串中有重复的字符，字符串的长度小于等于 500.
package com.bjsxt;
import java.util.ArrayList;
import java.util.List;
public class FirstRepeat &#123;
public static void main(String\[] args) &#123;
System.out.println(findFirstRepeat(&quot;pmedmitjtckhxwhvpwemznh
mhzhpueainchqrftkmbjlradhmjekcqzansyzkvqhwnrdgzdbzewdmxkzrscik
daugbvygntrifnolehdtrqjlasofuvzeijbmzehkxknmjekcxswqldknysfsxr
qaqzp&quot;,152));
&#125;
//返回\:y
public static char findFirstRepeat(String A, int n) &#123;
String\[] str=A.split(&quot;&quot;);
for(int x=0;x\&lt;n;x++)&#123;
int index=0;
int num=0;
//对于每一个值，都需要从前开始遍历
while(index&lt;=x)&#123;
if(str\[index].equals(str\[x]))&#123;
num++;
&#125;
index++;
&#125;
500
//该值出现了两次，说明重复了
if(num&gt;1)&#123;
char flag=&#39;x&#39;;
flag=str\[x].toCharArray()\[0];
return flag;
&#125;
&#125;
//返回该值说明已经没有重复的
return &#39;p&#39;;
&#125;
&#125;
2.  写一个完整函数，实现拷贝数组
public class test &#123;
public static void main(String\[] args) &#123;
int \[] arr1 = &#123;10,20,30,40,50&#125;;
int \[] arr2 = CopyArray(arr1);
System.out.println(Arrays.toString(arr2));
&#125;
private static int\[] CopyArray(int\[] arr) &#123;
int \[] arr2 = new int\[arr.length];
for (int i = 0; i &lt; arr.length; i++) &#123;
arr2\[i] = arr\[i];
&#125;
return null;
&#125;
&#125;
3.  写一排序算法，输入 10 个数字，以逗号分开，可根据参数选择升序或者
降序排序，须注明是何种排序算法。
package cn.bjsxt.demo;
501
import java.util.Scanner;
public class SortDemo &#123;
/\*\**   给定的字符串使用，号分隔
*   @param strNumber
*   @return
*/
public static String \[] split(String strNumber)&#123;
String \[] strSplit=strNumber.split(&quot;,&quot;);
return strSplit;
&#125;
/*\*
*   将String类型的数组转换成int类型的数组
*   @param strSplit
*   @return
*/
public static int \[] getInt(String \[] strSplit)&#123;
int arr\[]=new int\[strSplit.length];
for (int i = 0; i &lt; strSplit.length; i++) &#123;
arr\[i]=Integer.parseInt(strSplit\[i]);
&#125;
return arr;
&#125;
/*\*
*   冒泡排序
*   @param arr
*/
public static void sort(int \[] arr)&#123;
for (int i = 0; i &lt; arr.length-1; i++) &#123;
for (int j = 0; j &lt; arr.length-1-i; j++) &#123;
if (arr\[j]&gt;arr\[j+1]) &#123;
change(arr,j,j+1);
&#125;
&#125;
&#125;
&#125;
/*\*
502
*   两数交换的方法
*   @param arr 数组
*   @param x 数组中元素的下标
*   @param y 数组中元素的下标
*/
public static void change(int \[] arr,int x,int y)&#123;
int temp=arr\[x];
arr\[x]=arr\[y];
arr\[y]=temp;
&#125;
/*\*
*   测试类
*   @param args
\*/
public static void main(String\[] args) &#123;
Scanner input=new Scanner(System.in);
System.out.println(&quot;请输入一个数字串，每个数字以逗号分隔
&quot;);
String str=input.next();
//调用方法
String \[] s=split(str);//使用逗号分隔
int \[] arr=getInt(s);//调有获得整型数组的方法
sort(arr);//调用排序的方法
for (int i : arr) &#123;
System.out.print(i+&quot;\t&quot;);
&#125;
&#125;
&#125;
5031.  判断字符串是否是这样的组成的，第一个字母，后面可以是字母、数字、
下划线、总长度为 5-20。
package cn.bjsxt.demo;
import java.util.Scanner;
public class StringDemo &#123;
public static void main(String\[] args) &#123;
Scanner input=new Scanner(System.in);
System.out.println(&quot;请输入一个字符串，第一个字符必须是字母：
&quot;);
String str=input.next();
if (str.length()&lt;5||str.length()&gt;20) &#123;
System.out.println(&quot;对不起，字符串的长度必须在5-20之
间!&quot;);
&#125;else&#123;
char \[]ch=str.toCharArray();
if (Character.isLetter(ch\[0])) &#123;//判断第一个字符是否是
字母
for (int i = 1; i &lt; ch.length; i++) &#123;
if
(!Character.isLetterOrDigit(ch\[i])&amp;\&amp;ch\[i]!=&#39;\_&#39;) &#123;
System.out.println(&quot;字符串不符合要求&quot;);
break;
&#125;
&#125;
&#125;
&#125;
&#125;
&#125;
504
2.  已排好序的数组 A，一般来说可用二分查找可以很快找到，现有一特殊
数组 A，它是循环递增的，如 a\[]=&#123;17, 19 ,20, 25, 1, 4, 7, 9&#125;，在这样的
数组中找一元素，看看是否存在。请写出你的算法，必要时可写伪代码，并
分析其空间，时间复杂度。
思路说明：循环递增数组有这么一个性质：以数组中间元素将循环递增数组划分为两部
分，则一部分为一个严格递增数组，而另一部分为一个更小的循环递增数组。当中间元
素大于首元素时，前半部分为严格递增数组，后半部分为循环递增数组；当中间元素小
于首元素时，前半部分为循环递增数组；后半部分为严格递增数组。
记要检索的元素为 e，数组的首元素为 a\[low]，中间元素为 a\[mid]，末尾元素为 a\[high]。
则当 e 等于 a\[mid] 时，直接返回 mid 的值即可；当 e 不等于 a\[mid] 时:1.  a\[mid] &gt; a\[low]，即数组前半部分为严格递增数组，后半部分为循环递增数组时，若
key 小于 a\[mid]并且不小于 a\[low]时，则 key 落在数组前半部分；否则，key 落在数组
后半部分。
2.  a\[mid] &lt; a\[high]，即数组前半部分为循环递增数组，后半部分为严格递增数组时，
若 key 大于 a\[mid]并且不大于 a\[high]时，则 key 落在数组后半部分；否则，key 落在
数组前半部分。
这种方式的时间复杂度为：O(log(n))，空间复杂度为 O(1)。
public class TestBinarySearch &#123;
public static void main(String\[] args) &#123;
// 定义数组
int\[] a = &#123; 17, 19, 20, 21, 25, 1, 4, 7 &#125;;
// 调用改进后的二分查找法求索引
int pos = search(a, 7);
System.out.println(&quot;要查找的元素的索引为：&quot; + pos);
&#125;
505
/\*\* 改进后的二分查找法：e 为要查找的元素 \*/
public static int search(int\[] a, int e) &#123;
int low = 0;
int high = a.length - 1;
int mid = 0;
int pos = -1; // 返回-1，表示查找失败
// 如果 low &lt; high，说明循环查找结束，直接返回-1;否则循环查
找
while (low &lt;= high) &#123;
// mid 为中间值索引
mid = (low + high) / 2;
// 如果中间值刚好是 e，则查找成功，终止查找，e 的索引为 mid
if (a\[mid] == e) &#123;
pos = mid;
break;
&#125;
// 如果 a\[low] &lt;= a\[mid]，说明原数组的前半部分是严格递增
的，后半部分是一个更小的循环递增数组
if (a\[low] &lt;= a\[mid]) &#123;
// 如果要查找的元素 e 小于 a\[mid]并且不小于 a\[low]时，
则说明 e 落在数组前半部分
if (a\[low] &lt;= e &amp;&amp; e &lt; a\[mid]) &#123;
high = mid - 1;
&#125; else &#123;// 否则的话，需要在数组的后半部分继续查找
low = mid + 1;
&#125;
&#125; else &#123;// 否则，后半部分是严格递增的，前半部分是一个更
小的循环递增数组
// 如果要查找的元素 e 大于 a\[mid]并且不大于 a\[high]时，
则说明 e 落在数组后半部分
if (a\[mid] &lt; e &amp;&amp; e &lt;= a\[high]) &#123;
low = mid + 1;
&#125; else &#123;// 否则的话，需要在数组的前半部分继续查找
high = mid - 1;
&#125;
&#125;
&#125;
return pos;
&#125;
&#125;
5061.  请编写一个完整的程序，实现如下功能：从键盘输入数字 n，程序自动
计算 n!并输出。（注 1：n！=1*2*3...\*n, 注 2：请使用递归实现）
思路说明：因为 n! = (n-1)! \* n，所以要求 n!首先要求出(n-1)!，而(n-1)! = (n-1-1)! \*
(n-1)，以此类推，直到 n = 1 为止。
import java.util.Scanner;
public class TestFactorial &#123;
public static void main(String\[] args) &#123;
System.out.print(&quot;请输入一个整数：&quot;);
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
System.out.println(n + &quot;的阶乘是：&quot; + factorial(n));
&#125;
/\**求阶乘的方法*/
public static int factorial(int n) &#123;
if(n == 1)&#123;
return 1;
&#125;
return factorial(n - 1) \* n;
&#125;
&#125;
2.  请用递归的方法计算斐波那契数列的同项 F（n），已知
F0=0,F1=1,F(n)=F(n-1)+F(n-2)(n&gt;=2,n∈N\*).
思路说明：斐波那契数列的排列是：0，1，1，2，3，5，8，13，21，34，55，89，
144……，特别指出的是 0 不是第一项而是第 0 项；因为 F(n)=F(n-1)+F(n-2)，所以要
求 F(n)首先要求出 F(n-1)和 F(n-2)，而 F(n-1)=F(n-1-1)+F(n-1-2)，以此类推，直
到,F(2)=F(1)+F(0)为止，已知 F(1) = 1，F(0) = 0。
import java.util.Scanner;
public class TestFibo &#123;
public static void main(String\[] args) &#123;
507
System.out.print(&quot;请输要求斐波那契数列的第几项：&quot;);
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
System.out.println(&quot;斐波那契数列的第&quot;+ n + &quot;是：&quot; +
fibo(n));
&#125;
public static int fibo(int n) &#123;
if(n == 0)&#123;
return 0;
&#125; else if(n == 1)&#123;
return 1;
&#125;
return fibo(n -1) + fibo(n - 2);
&#125;
&#125;
3.  现在有整数数组&#123;11,66,22,0,55,32&#125;，请任意选择一种排序算法，用
Java 程序实现
冒泡思路说明：
(1) 最开始将数组看做一个无序数列(个数是数组的长度)与一个有序数列(0 个)的组合；
(2) 每一趟比较完后, 找到了无序数列的最大值, 将其放到有序数列中(有序数列个数+1)；
(3) N 个数, 比较 N-1 趟；
(4) 每一趟挨个进行比较：从数组的第一个元素开始, 到无序数列的最后一个为止；
(5) 如果前边一个大于后边一个, 那么交换位置；
(6) 每趟比较的次数与趟数有关；
(7) 根据每趟比较是否发生了交换判断数据是否已经有序，从而进行优化。
public class TestSort &#123;
public static void main(String\[] args) &#123;
int\[] arr = &#123;11, 66, 22, 0, 55, 32&#125;;
508
// 调用排序方法
sort(arr);
// 输出排除后的数组
for (int num : arr) &#123;
System.out.print(num + &quot;\t&quot;);
&#125;
&#125;
public static void sort(int\[] arr) &#123;
// 定义标记
boolean flag = false;
int temp;
// 排序
// 外层循环控制的是比较的趟数
for (int i = 0; i &lt; arr.length - 1; i++) &#123;
// 每一趟比较之前初始化, 否则会保留上一堂比较的结果
flag = false;
// 内层循环控制的是每趟比较的次数
for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;
// 挨个进行比较: 从数组的第一个元素开始, 到无序数列的
最后一个
if (arr\[j] &gt; arr\[j + 1]) &#123;
// 交换
temp = arr\[j];
arr\[j] = arr\[j + 1];
arr\[j + 1] = temp;
//如果发生交换，改变 flag 的值
flag = true;
&#125;
&#125;
if (!flag) &#123;
509
break;
&#125;
&#125;
&#125;
&#125;
4.  请根据注释，编码实现下面类的方法
// 这个类用于存取一组权限，每个权限用非负整数表示的.这组枳限存储在
// righiString 属性中。如果权限 N 权限存在，rightString 第 N 个字符为“1”,
否则， 为空格。
class RightStore &#123;
public String righString = &quot;&quot;;
// 如果传入的权限 right 存在，该方法返回 true.否期，为 false.,
// right 为传入的权限的整数值.
public boolean getRight(int right) &#123;
return true;
&#125;
// 该方法存储或消除传入的权限.如果 value 为 true,存储传入的权限,
// 否则淸除该权限.
// right 为传入的权限的整数值.
public void setRight(int right, boolean value) &#123;
&#125;
&#125;
思路说明：我们首先要读懂这道题的意思：righString 这个字符串是用来存储一系列权
限的，并且权限的取值只有两种：有和没有；在 righString 中使用字符‘1’表示有权
限，字符空格‘ ’表示没有权限。举个例子：如果 righString 的长度为 3，第一位表示
对订单系统是否有权限，第二位表示对人员管理系统是否有权限，第三位表示对库存系
510
统是否有权限。而方法中的 int right 参数则表示的是字符串的第几位。
上边这些搞明白之后，方法的编写就简单多了。
public class RightStore &#123;
public String righString = &quot;&quot;;
public boolean getRight(int right) &#123;
//先求得第 right 个字符
char ch = righString.charAt(right - 1);
//如果 ch 为&#39;1&#39;，返回 true，否则返回 false
return ch == &#39;1&#39;;
&#125;
public void setRight(int right, boolean value) &#123;
//如果 value 为 true,存储传入的权限，否则消除权限（改为空格）
righString.replace(righString.charAt(right - 1), value ?
&#39;1&#39; : &#39; &#39;);
&#125;
&#125;
5.  二分法查询（递归实现）
思路说明：假设在一个已经排好序的有序序列(N 个元素，升序排列)，首先让序列中的中
间的元素与需要查找的关键字进行比较，如果相等，则查找成功，否则利用中间位置将
序列分成两个子序列，如果待查找的关键字小于中间的元素，则在前一个子序列中同样
的方法进一步查找，如果待查找的关键字大于中间的元素，则在后一个子序列中同样的
方法进一步查找，重复以上过程一直到查找结束！
import java.util.Scanner;
public class TestBinarySearchRecursion &#123;
public static void main(String\[] args) &#123;
int\[] a = &#123; 1, 3, 5, 7, 9, 11, 13 &#125;;
System.out.print(&quot;请输入要查找的元素：&quot;);
int e = new Scanner(System.in).nextInt();
511
int index = binarySearch(a, 0, a.length - 1, e);
System.out.println(index != -1 ? &quot;元素索引为&quot; + index : &quot;
没有该元素&quot;);
&#125;
private static int binarySearch(int\[] a, int low, int high,
int e) &#123;
int mid = 0;
if (low &lt;= high) &#123;
mid = (low + high) / 2;
if (a\[mid] == e) &#123;
return mid;
&#125; else if (a\[mid] &gt; e) &#123;
return binarySearch(a, low, mid - 1, e);
&#125; else &#123;
return binarySearch(a, mid + 1, high, e);
&#125;
&#125;
return -1;
&#125;
&#125;
6.  编写一段 Java 程序，把一句英语中的每个单词中的字母次序倒转，单词
次序保持不变，例入输入为“There is a dog.”,输出结果应该是“erehT si
a god.”要求不使用 Java 的库函数，例如 String 类的 split，reverse 方
法。
函数形如：
public static String reverseWords(String input) &#123;
String str = &quot;&quot;;
return str;
&#125;
512
思路说明：将字符串转化成字符数组，然后根据数组中空格的位置判断每个单词所占的
索引范围，根据得到的索引将数组中的每个单词逆序后拼接到新的字符串中。
public class TestStringReverse&#123;
public static void main(String\[] args) &#123;
String input = &quot;There is a dog&quot;;
System.out.println(&quot;逆转后的字符串为：&quot; +
reverseWords(input));
&#125;
public static String reverseWords(String input) &#123;
String str = &quot;&quot;;
//将字符串转化成字符数组
char\[] arr = input.toCharArray();
//index 用来记录每个单词的起始索引
int index = 0;
//遍历字符数组，将空格前边的单词挨个拼接到 str 中
for (int i = 0; i &lt; arr.length; i++) &#123;
if(arr\[i] == &#39; &#39;)&#123;
//根据空格的位置将空格前边一个单词密续追加到 str 中
for(int j = i - 1; j &gt;= index; j--)&#123;
str += arr\[j];
&#125;
//单词拼接完成后，拼接一个空格
str += &#39; &#39;;
//让 index 指向下一个单词的起始位置
index = i + 1;
&#125;
&#125;
//将最后一个单词拼接上
for(int i = arr.length - 1; i &gt;= index; i--)&#123;
str += arr\[i];
&#125;
return str;
513
&#125;
&#125;
7.  手写 9x9 乘法表，冒泡排序
9x9 乘法表:
class Demo &#123;
public static void main(String\[] args) &#123;
for(int x = 0;x &lt;= 9; x++) &#123;
for(int y = 1;y &lt;= x; y++) &#123;
System.out.print(y+&quot;*&quot;+x+&quot;=&quot;+x*y+&quot;\t&quot;);
&#125;
System.out.println();
&#125;
&#125;
&#125;
冒泡排序:
public class BubbleSort&#123;
public static void main(String\[] args)&#123;
int score\[] = &#123;67, 69, 75, 87, 89, 90, 99, 100&#125;;
for (int i = 0; i &lt; score.length -1; i++)&#123;//最多做 n-1 趟
排序
for(int j = 0 ;j &lt; score.length - i - 1; j++)&#123;//对当
前无序区间 score\[0......length-i-1]进行排序(j 的范围很关键，这个范围
是在逐步缩小的)
if(score\[j] &lt; score\[j + 1])&#123; //把小的值交换到后面
int temp = score\[j];
score\[j] = score\[j + 1];
score\[j + 1] = temp;
&#125;
&#125;
System.out.print(&quot;第&quot; + (i + 1) + &quot;次排序结果：&quot;);
for(int a = 0; a &lt; score.length; a++)&#123;
System.out.print(score\[a] + &quot;\t&quot;);
&#125;
System.out.println(&quot;&quot;);
&#125;
System.out.print(&quot;最终排序结果：&quot;);
for(int a = 0; a &lt; score.length; a++)&#123;
System.out.print(score\[a] + &quot;\t&quot;);
&#125;
&#125;
&#125;
8.  题目： 给定一个整数数组，找到是否该数组包含任何重复数字。你的函
数应该返回 true 只要有任何数字 在该数组中重复出现，否则返回 false。
public class Solution &#123;
public boolean containsDuplicate(int\[] nums) &#123;
Set\&lt;Integer&gt; numSet = new HashSet\&lt;Integer&gt;();
for(int i=0;i\&lt;nums.length;i++)&#123;·
if(numSet.contains(nums\[i]))
return true;
else
numSet.add(nums\[i]);
&#125;
return false;
&#125;
&#125;
9.  给定一个数组 nums， 写一个函数来移动所有 0 元素到数组末尾，同时
维持数组中非 0 元素的相对顺序不变。要求不能申请额外的内存空间，并且
最小化操作次数。
public void moveZeroes(int\[] nums) &#123;
514
int size = nums.length;
int startIndex = 0;
// 0 元素开始的位置
int endIndex = 0;
// 0 元素结束的位置
int currentNum;
int i= 0;
// 第一步：找到第一个 0 元素开始的位置
// 并将第一个 0 元素的游标赋值给 startIndex\&amp;endIndex
while(i &lt; size)&#123;
currentNum = nums\[i];
if (currentNum == 0) &#123;
startIndex = i;
endIndex = i;
break;
&#125;
++i;
&#125;
// 如果当前数组中没有找到 0 元素，则推出
if (nums\[endIndex] != 0)
return;
// 将当前 i 的值加 1；直接从刚才 0 元素位置的后一位置开始循环
++i;
while (i &lt; size) &#123;
currentNum = nums\[i];
if (currentNum == 0)&#123;//如果当前元素等于 0，则将 i 值赋值
给 endIndex
endIndex = i;
&#125; else &#123;
// 如果不为 0
//则将当前元素赋值给 nums\[startIndex]
515
// 并将当前位置的元素赋值为 0
// startIndex 和 endIndex 都加 1；
nums\[startIndex] = currentNum;
nums\[i] = 0;
++startIndex;
++endIndex;
&#125;
\++i;
&#125;
&#125;
10. 给定一颗二叉树，返回节点值得先序遍历，请使用迭代（非递归）方式
实现。
public class Solution &#123;
public List\&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
List\&lt;Integer&gt; result = new ArrayList\&lt;Integer&gt;();
if(root == null)
return result;
Stack\&lt;TreeNode&gt; stack = new Stack\&lt;TreeNode&gt;();
stack.push(root);
while(!stack.isEmpty()) &#123;
TreeNode node = stack.pop();
result.add(node.val);
if(node.right != null)
stack.push(node.right);
if(node.left != null)
stack.push(node.left);
&#125;
return result;
&#125;
&#125;
516
517
11. 验证一棵树是否为有效的二叉搜索树 BST
public class Solution &#123;
private static int lastVisit = Integer.MIN\_VALUE;
public boolean isValidBST(TreeNode root) &#123;
if(root == null) return true;
boolean judgeLeft = isValidBST(root.left); // 先判断左子
树if(root.data &gt;= lastVisit &amp;&amp; judgeLeft) &#123; // 当前节点比上
次访问的数值要大
lastVisit = root.data;
&#125; else &#123;
return false;
&#125;
boolean judgeRight = isValidBST(root.right); // 后判断右
子树
return judgeRight;
&#125;
&#125;1.  从一个链表中删除节点
题目： 写一个函数用于在一个单向链表中删除一个节点（⾮非尾节点），前提是仅仅能够访
问要删除的那个节点。
比如给定链表 1 -&gt; 3 -&gt; 5 -&gt; 7 -&gt; 9 -&gt; 16，给定你值为 3 的那个节点， 调⽤用你的函数
后，链表变为
1 -&gt; 5 -&gt; 7 -&gt; 9 -&gt; 16。
/\*\*
518
Definition for singly-linked list.
public class ListNode &#123;
int val;
ListNode next;
ListNode(int x) &#123; val = x; &#125;*   &#125;
\*/
public class Solution &#123;
public void deleteNode(ListNode node) &#123;
if(node==null||node.next==null) &#123;
System.out.println(&quot;节点不存在或者是尾节点&quot;);
&#125;else&#123;
node.val=node.next.val;
node.next=node.next.next;
&#125;
&#125;
&#125;1.  二叉搜索树 BST 中第 Kth 小的元素 题目：给定⼀个 BST，写一个函数
kthSmallest 来找到第 kth 小的元素
/\*\*
Definition for a binary tree node.
public class TreeNode &#123;
int val;
TreeNode left;
TreeNode right;
TreeNode(int x) &#123; val = x; &#125;*   &#125;
\*/
public class Solution2 &#123;
public int kthSmallest(TreeNode root, int k) &#123;
Stack\&lt;TreeNode&gt; store = new Stack\&lt;TreeNode&gt;();
if (root == null) &#123;
return -1;
&#125;
store.push(root);
while (root.left != null) &#123;
store.push(root.left);
root = root.left;
&#125;
519
while (!store.empty()) &#123;
TreeNode cur = store.pop();
k--;
if (k == 0) &#123;
return cur.val;
&#125;
if (cur.right != null) &#123;
root = cur.right;// let cur.right be the current node
store.push(root);
while (root.left != null) &#123;
store.push(root.left);
root = root.left;
&#125;
&#125;
&#125;
return -1;
&#125;
&#125;1.  题目：给定含有 n 个整数的数组 S，S 中是否存在三个元素 a,b,c 使得 a*   b + c = 0? 找到所有这样的三元 组，并且结果集中不包含重复的三元组。
比如，
S = \[-1, 0, 1, 2, -1, -4],,
结果集为: \[
\[-1, 0, 1],
\[-1, -1, 2]
]
/\*\**   给定一个 n 个元素的数组，是否存在 a，b，c 三个元素，使用得 a+b+c=0，找
出所有符合这个条件的三元组
*   注意： - 三元组中的元素必须是非递减的 - 结果不能包含重复元素
\*/
public class Solution &#123;public static void main(String\[] args) &#123;
int\[] S = &#123;-1, 0, 1, 2, -1, -4,-3,-4,4,3&#125;;
new Solution().get3Sum(S);
&#125;public Set\&lt;String&gt; get3Sum(int\[] S)&#123;if(S.length&lt;3 || S==null)&#123;
return null;
&#125;//接收拼接的字符串
StringBuffer sb = new StringBuffer();
for(int i=0; i\&lt;S.length; i++)&#123;
for(int j=0; j\&lt;S.length; j++)&#123;
for(int z=0; z\&lt;S.length; z++)&#123;
//筛选出不是递减的一组元素
if(S\[i]&lt;=S\[j] &amp;&amp; S\[j]&lt;=S\[z])&#123;
int sum = S\[i] + S\[j] + S\[z];
if(sum==0)&#123;
String str =
&quot;(&quot;+S\[i]+&quot;,&quot;+S\[j]+&quot;,&quot;+S\[z]+&quot;)&quot;;
sb.append(str+&quot;;&quot;);
&#125;
&#125;
&#125;
&#125;
&#125;String s = sb.toString();
s = s.substring(0, sb.length()-1);
String\[] arr = s.split(&quot;;&quot;);Set\&lt;String&gt; set = new HashSet\&lt;String&gt;();
//将所筛选出来的元素放入 Set 集合中，去重
for (int k = 0; k &lt; arr.length; k++) &#123;
520
set.add(arr\[k]);
&#125;
System.out.println(set);
return set;
&#125;public List\&lt;List\&lt;Integer&gt;&gt; threeSum(int\[] nums) &#123;
List\&lt;List\&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();if (nums != null &amp;&amp; nums.length &gt; 2) &#123;
// 先对数组进行排序
Arrays.sort(nums);
// i 表示假设取第 i 个数作为结果
for (int i = 0; i &lt; nums.length - 2; ) &#123;
// 第二个数可能的起始位置
int j = i + 1;
// 第三个数可能是结束位置
int k = nums.length - 1;
while (j &lt; k) &#123;
// 如果找到满足条件的解
if (nums\[j] + nums\[k] == -nums\[i]) &#123;
// 将结果添加到结果含集中
List\&lt;Integer&gt; list = new ArrayList&lt;&gt;(3);
list.add(nums\[i]);
list.add(nums\[j]);
list.add(nums\[k]);
result.add(list);
// 移动到下一个位置，找下一组解
k--;
j++;// 从左向右找第一个与之前处理的数不同的数的下标
while (j &lt; k &amp;&amp; nums\[j] == nums\[j - 1]) &#123;
j++;
521
&#125;
// 从右向左找第一个与之前处理的数不同的数的下标
while (j &lt; k &amp;&amp; nums\[k] == nums\[k + 1]) &#123;
k--;
&#125;
&#125;
// 和大于 0
else if (nums\[j] + nums\[k] &gt; -nums\[i]) &#123;
k--;
// 从右向左找第一个与之前处理的数不同的数的下标
while (j &lt; k &amp;&amp; nums\[k] == nums\[k + 1]) &#123;
k--;
&#125;
&#125;
// 和小于 0
else &#123;
j++;
// 从左向右找第一个与之前处理的数不同的数的下标
while (j &lt; k &amp;&amp; nums\[j] == nums\[j - 1]) &#123;
j++;
&#125;
&#125;
&#125;
// 指向下一个要处理的数
i++;
// 从左向右找第一个与之前处理的数不同的数的下标
while (i &lt; nums.length - 2 &amp;&amp; nums\[i] == nums\[i - 1])
&#123;
i++;
&#125;
&#125;
&#125;
return result;
&#125;
&#125;
522
1.  子集问题
题目： 给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答
中集合不能包含重 复的子集。
比如，
nums = \[1, 2, 3], ⼀一种解答为：
\[
\[3],
\[1],
\[2],
\[1,2,3],
\[1,3],
\[2,3],
\[1,2], \[]
]
/\*\**   不重复集合求子集
解答采用的是深度优先遍历，先取原数组一个元素，再构造包括这个元素的两个，
三个……n 个元素的集合。dfs 中的 start 就指向这个元素的，它在不断地后移
（i+1)。
*   @param S: A set of numbers.
523
*   @return: A list of lists. All valid subsets.
\*/
public class Solution1 &#123;
public static void main(String\[] args) &#123;
int\[] first = new int\[]&#123;1, 2, 3&#125;;
ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt; res = subsets(first);
for(int i = 0; i &lt; res.size(); i ++)&#123;
System.out.println(res.get(i));
&#125;
&#125;
public static ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt; subsets(int\[]
nums) &#123;
ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt; res = new
ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt;();
ArrayList\&lt;Integer&gt; item = new ArrayList\&lt;Integer&gt;();
if(nums.length ++++== 0 || nums ==++++ null)
return res;
Arrays.sort(nums); //排序
dfs(nums, 0, item, res); //递归调用
res.add(new ArrayList\&lt;Integer&gt;()); //最后加上一个空集
return res;
&#125;
public static void dfs(int\[] nums, int start,
ArrayList\&lt;Integer&gt;item, ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt;res)&#123;
for(int i = start; i &lt; nums.length; i ++)&#123;
item.add(nums\[i]);
//item 是以整数为元素的动态数组，而 res 是以数组为元素的数
组，在这一步，当 item 增加完元素后，item 所有元素构成一个完整的子串，
再由 res 纳入
res.add(new ArrayList\&lt;Integer&gt;(item));
dfs(nums, i + 1, item, res);
item.remove(item.size() - 1);
&#125;
&#125;
&#125;
524
1.  迭代方法实现二叉树的先序遍历：题目： 给定一颗⼆叉树，返回节点值
得先序遍历，请使用迭代（非递归）方式实现。
比如， 给定二叉树&#123;1,#,2,3&#125;, 返回 \[1,2,3]
/\*\*
Definition for a binary tree node.
public class TreeNode &#123;
int val;
TreeNode left;
TreeNode right;
TreeNode(int x) &#123; val = x; &#125;*   &#125;
\*/
public class Solution &#123;List\&lt;Integer&gt; result = new ArrayList\&lt;Integer&gt;();/\*\**   迭代实现，维护一个栈，因为入栈顺序按照根右左进行入栈，因此首先
将根出栈，然后出栈左子节点，
*   最后出栈右子节点。
*   @param root
*   @return
\*/
public List\&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
if(root == null)
return result;
Stack\&lt;TreeNode&gt; stack = new Stack\&lt;TreeNode&gt;();
stack.push(root);
while(!stack.isEmpty()) &#123;
TreeNode node = stack.pop();
result.add(node.val);
if(node.right != null)
stack.push(node.right);
if(node.left != null)
stack.push(node.left);
&#125;
525
526
return result;
&#125;
&#125;1.  验证二叉搜索树 BST：题目： 验证一棵树是否为有效的二叉搜索树 BST
比如，二叉树\[2, 1, 3]，返回 true 二叉树\[1, 2, 3], 返回 false
class TreeNode &#123;
int val;
TreeNode left;
TreeNode right;
TreeNode(int x) &#123; val = x; &#125;
&#125;
public class BSTChecker &#123;
private static int lastVisit = Integer.MIN\_VALUE;public static boolean isBST(TreeNode root) &#123;
if(root == null) return true;boolean judgeLeft = isBST(root.left); // 先判断左子树if(root.val &gt;= lastVisit &amp;&amp; judgeLeft) &#123; // 当前节点比上
次访问的数值要大
lastVisit = root.val;
&#125; else &#123;
return false;
&#125;boolean judgeRight = isBST(root.right); // 后判断右子树return judgeRight;
&#125;
&#125;
5271.  编辑距离题目： 给定两个单词 word1 和 word2，找到最小的操作步骤
使得 word1 转换成 word2，每次操作算作一 步。你可以对单词进行以下
三种操作：1）插入一个字符 2）删除一个字符 3）替换一个字符
参考地址：&lt;http://www.cnblogs.com/masterlibin/p/5785092.html&gt;
2.  买卖股票问题：题目： 你有一个数组，第 i 个元素表示第 i 天某个股票
的价格，设计一个算法找到最大的利润，并且你只能最多完成两次交易。
参考地址：没有完全理解的
&lt;http://www.mamicode.com/info-detail-1087177.html&gt;
&lt;http://blog.csdn.net/cumt_cx/article/details/48015735&gt;
/\*\**   解题思路：
*   比如给定一组数组，\[1，2，3，6，9，3，10]
*   最多可以 2 次去获取最大的利益，可以用 2 分的思想，分成 2 部分，
*   从 0 元素开始遍历分别求出左右 2 边的最大利益，求出的左右 2 边最大的利
益即为解
\*/
class Solution &#123;
public static int maxProfit(int\[] prices) &#123;
// write your code here
if(null==prices||0==prices.length) return 0;
int sumProfit = 0;
for(int i=1;i\&lt;prices.length;i++)&#123;
int tmpsum = maxProfit(prices, 0, i)*   maxProfit(prices, i+1, prices.length-1);
sumProfit = Math.max(sumProfit, tmpsum);
&#125;
return sumProfit;
528
&#125;
public static int maxProfit(int\[] prices,int s,int e)&#123;
if(e&lt;=s) return 0;
int min = prices\[s];
int maxProfit = 0;
for(int i=s+1;i&lt;=e;i++)&#123;
maxProfit = Math.max(maxProfit, prices\[i]-min);
min = Math.min(min, prices\[i]);
&#125;
return maxProfit;
&#125;
public static void main(String\[] args) &#123;
int arr \[] = &#123;4,4,6,1,1,4,2,5&#125;;
System.out.println(maxProfit(arr));
&#125;
&#125;1.  \[编程]任给 n 个整数和一个整数 x。请计算 n 个整数中有多少对整数之
和等于 x。
public class Test8 &#123;
public static void main(String\[] args) &#123;
//输入 n 个整数和一个整数
Scanner input = new Scanner(System.in);
System.out.println(&quot;请输入 n 个整数，数量任意,以逗号分隔
&quot;);
String str = input.next();
System.out.println(&quot;请输入一个整数：&quot;);
int x = input.nextInt();
//将 n 个整数的字符串转换为数组
String arr1\[] = str.split(&quot;,&quot;);
int \[] arr2 = new int\[arr1.length];
for(int i=0;i\&lt;arr1.length;i++)&#123;
arr2\[i] = Integer.parseInt(arr1\[i]);
&#125;
System.out.println(Arrays.toString(arr2));
529
//判断并输出 n 个整数中有几对的和等于 x
int count = 0;
for(int i=0;i\&lt;arr2.length-1;i++)&#123;
for(int j = i+1;j\&lt;arr2.length;j++)&#123;
if(arr2\[i]+arr2\[j]==x)&#123;
count++;
&#125;
&#125;
&#125;
System.out.println(count);
&#125;
&#125;
2.  \[编程]请说明快速排序算法的设计思想和时间复杂度，并用高级语言写出
对整数数组进行一趟快排的函数实现。
快速排序由 C. A. R. Hoare 在 1962 年提出。它的基本思想是：通过一趟排序将要排序
的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，
然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此
达到整个数据变成有序序列。
设要排序的数组是 A\[0]……A\[N-1]，首先任意选取一个数据（通常选用数组的第一个数）
作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，
这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就
是说，多个相同的值的相对位置也许会在算法结束时产生变动。
一趟快速排序的算法是：
1、设置两个变量 i、j，排序开始的时候：i=0，j=N-1；
2、以第一个数组元素作为关键数据，赋值给 key，即 key=A\[0]；
530
3、从 j 开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于 key 的值 A\[j]，将 A\[j]和 A\[i]互
换；
4、从 i 开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于 key 的 A\[i]，将 A\[i]和 A\[j]互换；
5、重复第 3、4 步，直到 i=j； (3,4 步中，没找到符合条件的值，即 3 中 A\[j]不小于 key,4 中 A\[i]
不大于 key 的时候改变 j、i 的值，使得 j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交
换的时候 i，j 指针位置不变。另外，i==j 这一过程一定正好是 i+或 j-完成的时候，此时令循环结束）。
public class Quick &#123;
public static void main(String\[] args) &#123;
int arr \[] = &#123;90,60,70,50,40,80,20,100,10&#125;;
sort(arr,0,arr.length-1);
System.out.println(Arrays.toString(arr));
&#125;
public static void sort(int arr\[], int low, int high) &#123;
//设置两个变量 l、h，排序开始的时候：l=0，h=N-1
int l = low;
int h = high;
//以第一个数组元素作为关键数据，赋值给 key，即 key=A\[0]
int key = arr\[low];
//重复操作，直到 i=j
while (l &lt; h) &#123;
//从 h 开始向前搜索，即由后开始向前搜索(h--)，找到第一个
小于 key 的值 arr\[h]，将 arr\[h]和 arr\[l]互换
while (l &lt; h &amp;&amp; arr\[h] &gt;= key)
h--;
if (l &lt; h) &#123;
int temp = arr\[h];
arr\[h] = arr\[l];
arr\[l] = temp;
l++;
&#125;
531
//从 l 开始向后搜索，即由前开始向后搜索(l++)，找到第一个
大于 key 的 arr\[l]，将 arr\[l]和 arr\[h]互换；
while (l &lt; h &amp;&amp; arr\[l] &lt;= key)
l++;
if (l &lt; h) &#123;
int temp = arr\[h];
arr\[h] = arr\[l];
arr\[l] = temp;
h--;
&#125;
&#125;
//对前一部分进行快速排序
if (l &gt; low)
sort(arr, low, l - 1);
//对前一部分进行快速排序
if (h &lt; high)
sort(arr, l + 1, high);
&#125;
&#125;
3.  对于一段形如：1，-1~3,1~15×3 的输入
输入会依照以下规则：
1、所有输入为整数、
2、“,”为分隔符
3、“~”表示一个区间，比如“-1~3”表示-1 到 3 总共 5 个整数，同时“~”前的数小
于“~”后的数：
4、“x”表示步长，“x3”指每 3 个整数一个，比如“1~15×3”表示 1，4,7,10,13；
根据以上得到的结果进行打印，打印的规则为：
1、所有得到的整数按从小到大排列，以“，”分隔，不计重复；
532
2、每行最多显示 3 个整数；
3、如果两个整数是连续的，可以放在同一行，否则自动换行。
例如对于输入“1，-1~3,1~15×3”的输出结果为：
\-1,0,1，
2,3,4，
7,
10，
13
public class Test &#123;
public static void main(String\[] args) &#123;
Map\&lt;Integer, Integer&gt; map = new TreeMap\&lt;Integer,
Integer&gt;();
String str = &quot;5~20x3,1,-1~3,1~15x3&quot;;
String\[] s = str.split(&quot;,&quot;);
for (int i = 0; i &lt; s.length; i++) &#123;
if (s\[i].contains(&quot;~&quot;)) &#123;
String ss\[] = s\[i].split(&quot;~&quot;);
int first = Integer.parseInt(ss\[0]);
if (s\[i].contains(&quot;x&quot;)) &#123;
String sss\[] = ss\[1].split(&quot;x&quot;);
int end = Integer.parseInt(sss\[0]);
int l = Integer.parseInt(sss\[1]);
for (int j = first; j &lt; end;) &#123;
map.put(j, j);
j += l;
&#125;
&#125; else &#123;
int end = Integer.parseInt(ss\[ss.length*   1]);
for (int j = first; j &lt;= end; j++) &#123;
map.put(j, j);
&#125;
&#125;
&#125; else &#123;
533
int j = Integer.parseInt(s\[i]);
map.put(j, j);
&#125;
&#125;
List\&lt;Integer&gt; list = new ArrayList\&lt;Integer&gt;();
Set\&lt;Integer&gt; set = map.keySet();
Iterator\&lt;Integer&gt; ite = set.iterator();
while (ite.hasNext()) &#123;
int key = ite.next();
int value = map.get(key);
list.add(value);
System.out.println(&quot;v :&quot; + value);
&#125;
System.out.println(&quot;=================&quot;);
for (int i = 0; i &lt; list.size();) &#123;
int value = list.get(i);
List\&lt;Integer&gt; co = new ArrayList\&lt;Integer&gt;();
co.add(value + 1);
co.add(value + 2);
if (list.containsAll(co)) &#123;
System.out.println(value + &quot;,&quot; + (value + 1)*   &quot;,&quot;
*   (value + 2));
i += 3;
&#125; else &#123;
System.out.println(value);
i++;
&#125;
&#125;
&#125;
&#125;1.  有两个字符串：目标串 S=“s1s2.......sn”，模式串 T=&quot;t1t2.......tm&quot;。
若存在 T 的每个字符一次和 S 中的一个连续字符序列相等，则匹配成功，返
回 T 中第一个字符在 S 中的位置。否则匹配不成功，返回 0。写出你的算法，
要求线性时间复杂度
答：
534
字符串匹配操作定义：
目标串 S=&quot;S0S1S2...Sn-1&quot; , 模式串 T=“T0T1T2...Tm-1”
对合法位置 0&lt;= i &lt;= n-m （i 称为位移）依次将目标串的字串 S\[i ... i+m-1] 和
模式串 T\[0 ... m-1] 进行比较，若：
1、S\[i ... i+m-1] = T\[0 ... m-1] ， 则从位置 i 开始匹配成功，称模式串 T 在目标
串 S 中出现。
2、S\[i ... i+m-1] != T\[0 ... m-1] ，则从位置 i 开始匹配失败。
字符串匹配算法 —— Brute-Force 算法
字符串匹配过程中，对于位移 i （i 在目标串中的某个位置），当第一次 Sk != Tj 时，
i 向后移动 1 位 ，及 i = i+1，此时 k 退回到 i+1 位置 ;模式串要退回到第一个字符。
该算法时间复杂度 O（M\*N），但是实际情况中时间复杂度接近于 O（M + N），以下
为 Brute-Force 算法的 Java 实现版本：
public static int bruteForce(String target, String pattern,
int pos) &#123;
if (target == null || pattern == null) &#123;
return -1;
&#125;
int k = pos - 1, j = 0, tLen = target.length(), pLen =
pattern.length();
while (k &lt; tLen &amp;&amp; j &lt; pLen) &#123;
if (target.charAt(k) == pattern.charAt(j)) &#123;
j++;
k++;
&#125; else &#123;
k = k - j + 1;
j = 0;
&#125;
&#125;
if (j == pLen) &#123;
return k - j + 1;
535
&#125;
return -1;
&#125;
2.  如何生成一个 0-100 的随机整数？
public class Test &#123;
public static void main(String\[] args) &#123;
int num=(int)(Math.random()\*101);
System.out.println(num);
&#125;
&#125;
3.  请编写一段 Java 程序将两个有序数组合并成一个有序数组
import java.util.Arrays;
publicclass Demo1 &#123;
publicstaticvoid main(String\[] args) &#123;
int\[] a = &#123; 1, 2, 3, 4, 5, 7, 8, 9, 10 &#125;;
int\[] b = &#123; 3, 5, 7, 9, 10 &#125;;
int\[] target = newint\[a.length + b.length];
for (inti = 0; i\&lt;a.length; i++)
target\[i] = a\[i];
for (intj = 0; j\&lt;b.length; j++)
target\[a.length + j] = b\[j];
Arrays.sort(target);
for (inti = 0; i\&lt;target.length; i++)
System.out.println(target\[i]);
&#125;
&#125;
4.  在最佳情况下，以下哪个时间复杂度最高（D）
A. 直接插入排序
B. 直接选择排序
536
C. 冒泡排序
D. 归并排序
分析：答案: D
排序方法 最坏时间复杂度 最好时间复杂度 平均时间复杂度
直接插入 O(n2) O(n) O(n2)
简单选择 O(n2) O(n2) O(n2)
冒泡排序 O(n2) O(n) O(n2)
快速排序 O(n2) O(nlog2n) O(nlog2n)
堆排序 O(nlog2n) O(nlog2n) O(nlog2n)
归并排序 O(nlog2n) O(nlog2n) O(nlog2n)
5.  一个数组，元素为从 0 到 m 的整数，判断其中是否有重复元素，使用 java
语言编写一个方法publicstaticboolean demo(int\[] arr)&#123;
for (inti = 0; i\&lt;arr.length; i++) &#123;
for (intj = i + 1; j\&lt;arr.length; j++) &#123;
if (arr\[i] == arr\[j]) &#123;
returntrue;
&#125;
&#125;
&#125;
returnfalse;
&#125;
5371.  某二叉树的先序遍历是 12453，中序遍历是 42513，那么其后序遍历是
(A)
A 45231
B. 42351
C. 12345
D. 54321
2.  设一颗二叉树中有 3 个叶子节点，有八个度为 1 的节点，则该二叉树中
总的节点数为（）
A 12
B. 13
C. 14
D. 15
分析：选 b 子叶节点是度为零的节点,而二叉树的性质可知,度是 0 的节点
比度是 2 的节点数多 1 个,所以度是 2 的节点为 2 个,所以共有 3+8+2=13
3.  给出下面的二叉树先序、中序、后序遍历的序列？
答：先序序列：ABDEGHCF；中序序列：DBGEHACF；后序序列：DGHEBFCA。
补充：二叉树也称为二分树，它是树形结构的一种，其特点是每个结点至多有二棵子树，并且二叉树
的子树有左右之分，其次序不能任意颠倒。二叉树的遍历序列按照访问根节点的顺序分为先序（先访
问根节点，接下来先序访问左子树，再先序访问右子树）、中序（先中序访问左子树，然后访问根节
点，最后中序访问右子树）和后序（先后序访问左子树，再后序访问右子树，最后访问根节点）。如
果知道一棵二叉树的先序和中序序列或者中序和后序序列，那么也可以还原出该二叉树。
例如，已知二叉树的先序序列为：xefdzmhqsk，中序序列为：fezdmxqhks，那么还原出该二叉树
应该如下图所示：
538
4.  你知道的排序算法都哪些？用 Java 写一个排序系统
答：稳定的排序算法有：插入排序、选择排序、冒泡排序、鸡尾酒排序、归并排序、二
叉树排序、基数排序等；不稳定排序算法包括：希尔排序、堆排序、快速排序等。
下面是关于排序算法的一个列表：
下面按照策略模式给出一个排序系统，实现了冒泡、归并和快速排序。
package com.bjsxt;
import java.util.Comparator;
/\*\*
539
540*   排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们
可以相互替换)
*   @author SXT李端阳
*\*/
public interface Sorter &#123;/\*\**   排序
*   @param list 待排序的数组
\*/
public \&lt;T extends Comparable\&lt;T&gt;&gt; void sort(T\[] list);/\*\**   排序
*   @param list 待排序的数组
*   @param comp 比较两个对象的比较器
*/
public \&lt;T&gt; void sort(T\[] list, Comparator\&lt;T&gt; comp);
&#125;
BubbleSorter.java
package com.bjsxt;
import java.util.Comparator;
/*\*
*   冒泡排序
*   @author SXT李端阳
*\*/
541
public class BubbleSorter implements Sorter &#123;@Override
public \&lt;T extends Comparable\&lt;T&gt;&gt; void sort(T\[] list) &#123;
boolean swapped = true;
for(int i = 1; i &lt; list.length &amp;&amp; swapped;i++) &#123;
swapped= false;
for(int j = 0; j &lt; list.length - i; j++) &#123;
if(list\[j].compareTo(list\[j+ 1]) &gt; 0 ) &#123;
T temp = list\[j];
list\[j]= list\[j + 1];
list\[j+ 1] = temp;
swapped= true;
&#125;
&#125;
&#125;
&#125;public \&lt;T&gt; void sort(T\[] list,Comparator\&lt;T&gt; comp) &#123;
boolean swapped = true;
for(int i = 1; i &lt; list.length &amp;&amp; swapped; i++) &#123;
swapped = false;
for(int j = 0; j &lt; list.length - i; j++) &#123;
if(comp.compare(list\[j], list\[j + 1]) &gt; 0 ) &#123;
T temp = list\[j];
list\[j]= list\[j + 1];
list\[j+ 1] = temp;
swapped= true;
&#125;
&#125;
&#125;
&#125;
&#125;
package com.bjsxt;
import java.util.Comparator;
/\*\*
542*   归并排序
*   归并排序是建立在归并操作上的一种有效的排序算法。
*   该算法是采用分治法（divide-and-conquer）的一个非常典型的应用，
*   先将待排序的序列划分成一个一个的元素，再进行两两归并，
*   在归并的过程中保持归并之后的序列仍然有序。
*   @author SXT李端阳
*\*/
public class MergeSorter implements Sorter &#123;@Override
public \&lt;T extends Comparable\&lt;T&gt;&gt; void sort(T\[] list) &#123;
T\[] temp = (T\[]) new Comparable\[list.length];
mSort(list,temp, 0, list.length- 1);
&#125;private \&lt;T extends Comparable\&lt;T&gt;&gt; void mSort(T\[] list, T\[]
temp, int low, int high) &#123;
if(low == high) &#123;
return ;
&#125;
else &#123;
int mid = low + ((high -low) &gt;&gt; 1);
mSort(list,temp, low, mid);
mSort(list,temp, mid + 1, high);
merge(list,temp, low, mid + 1, high);
&#125;
&#125;private \&lt;T extends Comparable\&lt;T&gt;&gt; void merge(T\[] list, T\[]
temp, int left, int right, int last) &#123;
int j = 0;
int lowIndex = left;
int mid = right - 1;
int n = last - lowIndex + 1;
while (left &lt;= mid &amp;&amp; right &lt;= last)&#123;
543
if (list\[left].compareTo(list\[right]) &lt; 0)&#123;
temp\[j++] = list\[left++];
&#125; else &#123;
temp\[j++] = list\[right++];
&#125;
&#125;
while (left &lt;= mid) &#123;
temp\[j++] = list\[left++];
&#125;
while (right &lt;= last) &#123;
temp\[j++] = list\[right++];
&#125;
for (j = 0; j &lt; n; j++) &#123;
list\[lowIndex + j] = temp\[j];
&#125;
&#125;@Override
public \&lt;T&gt; void sort(T\[] list, Comparator\&lt;T&gt; comp) &#123;
T\[]temp = (T\[])new Comparable\[list.length];
mSort(list,temp, 0, list.length- 1, comp);
&#125;private \&lt;T&gt; void mSort(T\[] list, T\[] temp, int low, int high,
Comparator\&lt;T&gt; comp) &#123;
if(low == high) &#123;
return ;
&#125;
else &#123;
int mid = low + ((high -low) &gt;&gt; 1);
mSort(list,temp, low, mid, comp);
mSort(list,temp, mid + 1, high, comp);
merge(list,temp, low, mid + 1, high, comp);
&#125;
&#125;private \&lt;T&gt; void merge(T\[] list, T\[]temp, int left, int
right, int last, Comparator\&lt;T&gt; comp) &#123;
int j = 0;
int lowIndex = left;
int mid = right - 1;
int n = last - lowIndex + 1;
544
while (left &lt;= mid &amp;&amp; right &lt;= last)&#123;
if (comp.compare(list\[left], list\[right]) &lt;0) &#123;
temp\[j++] = list\[left++];
&#125; else &#123;
temp\[j++] = list\[right++];
&#125;
&#125;
while (left &lt;= mid) &#123;
temp\[j++] = list\[left++];
&#125;
while (right &lt;= last) &#123;
temp\[j++] = list\[right++];
&#125;
for (j = 0; j &lt; n; j++) &#123;
list\[lowIndex + j] = temp\[j];
&#125;
&#125;&#125;
QuickSorter.java
package com.bjsxt;
import java.util.Comparator;
/\*\**   快速排序
*   快速排序是使用分治法（divide-and-conquer）依选定的枢轴
*   将待排序序列划分成两个子序列，其中一个子序列的元素都小于枢轴，
*   另一个子序列的元素都大于或等于枢轴，然后对子序列重复上面的方法，
*   直到子序列中只有一个元素为止
*   @author Hao
*\*/
public class QuickSorter implements Sorter &#123;@Override
public \&lt;T extends Comparable\&lt;T&gt;&gt; void sort(T\[] list) &#123;
quickSort(list, 0, list.length- 1);
&#125;@Override
public \&lt;T&gt; void sort(T\[] list, Comparator\&lt;T&gt; comp) &#123;
quickSort(list, 0, list.length- 1, comp);
&#125;private \&lt;T extends Comparable\&lt;T&gt;&gt; void quickSort(T\[] list, int
first, int last) &#123;
if (last &gt; first) &#123;
int pivotIndex = partition(list, first, last);
quickSort(list, first, pivotIndex - 1);
quickSort(list, pivotIndex, last);
&#125;
&#125;private \&lt;T&gt; void quickSort(T\[] list, int first, int
last,Comparator\&lt;T&gt; comp) &#123;
if (last &gt; first) &#123;
int pivotIndex = partition(list, first, last, comp);
quickSort(list, first, pivotIndex - 1, comp);
quickSort(list, pivotIndex, last, comp);
&#125;
&#125;private \&lt;T extends Comparable\&lt;T&gt;&gt; int partition(T\[] list, int
first, int last) &#123;
T pivot = list\[first];
int low = first + 1;
int high = last;while (high &gt; low) &#123;
while (low &lt;= high &amp;&amp; list\[low].compareTo(pivot) &lt;= 0) &#123;
low++;
&#125;
while (low &lt;= high &amp;&amp; list\[high].compareTo(pivot) &gt;= 0) &#123;
high--;
545
&#125;
if (high &gt; low) &#123;
T temp = list\[high];
list\[high]= list\[low];
list\[low]= temp;
&#125;
&#125;while (high &gt; first&amp;&amp; list\[high].compareTo(pivot) &gt;= 0) &#123;
high--;
&#125;
if (pivot.compareTo(list\[high])&gt; 0) &#123;
list\[first]= list\[high];
list\[high]= pivot;
return high;
&#125;
else &#123;
return low;
&#125;
&#125;private \&lt;T&gt; int partition(T\[] list, int first, int last,
Comparator\&lt;T&gt; comp) &#123;
T pivot = list\[first];
int low = first + 1;
int high = last;while (high &gt; low) &#123;
while (low &lt;= high&amp;&amp; comp.compare(list\[low], pivot) &lt;= 0)
&#123;
low++;
&#125;
while (low &lt;= high&amp;&amp; comp.compare(list\[high], pivot) &gt;= 0)
&#123;
high--;
&#125;
if (high &gt; low) &#123;
T temp = list\[high];
list\[high] = list\[low];
list\[low]= temp;
&#125;
&#125;
546
547while (high &gt; first&amp;&amp; comp.compare(list\[high], pivot) &gt;= 0)
&#123;
high--;
&#125;
if (comp.compare(pivot,list\[high]) &gt; 0) &#123;
list\[first]= list\[high];
list\[high]= pivot;
return high;
&#125;
else &#123;
return low;
&#125;
&#125;&#125;
663\. 写一个二分查找（折半搜索）的算法。
答：折半搜索，也称二分查找算法、二分搜索，是一种在有序数组中查找某一特定元素
的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则
搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元
素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，
则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。
package com.bjsxt;
import java.util.Comparator;
public class MyUtil1 &#123;public static \&lt;T extends Comparable\&lt;T&gt;&gt; int binarySearch(T\[] x, T
key) &#123;
return binarySearch(x, 0, x.length- 1, key);
&#125;public static \&lt;T&gt; int binarySearch(T\[] x, T key, Comparator\&lt;T&gt;
548
comp) &#123;
int low = 0;
int high = x.length - 1;
while (low &lt;= high) &#123;
int mid = (low + high) &gt;&gt;&gt; 1;
int cmp = comp.compare(x\[mid], key);
if (cmp &lt; 0) &#123;
low = mid + 1;
&#125;
else if (cmp &gt; 0) &#123;
high = mid - 1;
&#125;
else &#123;
return mid;
&#125;
&#125;
return -1;
&#125;private static \&lt;T extends Comparable\&lt;T&gt;&gt; int binarySearch(T\[] x,
int low, int high, T key) &#123;
if(low &lt;= high) &#123;
int mid = low + ((high -low) &gt;&gt; 1);
if(key.compareTo(x\[mid]) == 0) &#123;
return mid;
&#125;
else if(key.compareTo(x\[mid])&lt; 0) &#123;
return binarySearch(x,low, mid - 1, key);
&#125;
else &#123;
return binarySearch(x, mid + 1, high, key);
&#125;
&#125;
return -1;
&#125;
&#125;
说明：两个版本一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应
该使用(high+ low) / 2 的方式，因为加法运算可能导致整数越界，这里应该使用一下三
种方式之一：low+ (high – low) / 2 或 low + (high – low) &gt;&gt; 1 或（low + high）&gt;&gt;&gt;
1（注：&gt;&gt;&gt;是逻辑右移，不带符号位的右移）1.  统计一篇英文文章单词个数。
答：
package com.bjsxt;
import java.io.FileReader;
public class WordCounting &#123;
public static void main(String\[] args) &#123;
try(FileReader fr = new FileReader(&quot;a.txt&quot;)) &#123;
int counter = 0;
boolean state = false;
int currentChar;
while((currentChar= fr.read()) != -1) &#123;
if(currentChar== &#39; &#39; || currentChar == &#39;\n&#39;
|| currentChar == &#39;\t&#39; || currentChar == &#39;\r&#39;) &#123;
state = false;
&#125;
else if(!state) &#123;
state = true;
counter++;
&#125;
&#125;
System.out.println(counter);
&#125;
catch(Exception e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;
补充：这个程序可能有很多种写法，这里选择的是 Dennis M. Ritchie 和 Brian W.
Kernighan 老师在他们不朽的著作《The C Programming Language》中给出的代码，
向两位老师致敬。下面的代码也是如此。
549
550
2.  输入年月日，计算该日期是这一年的第几天。
package com.bjsxt;
import java.util.Scanner;
public class DayCounting &#123;public static void main(String\[] args) &#123;
int\[]\[] data = &#123;
&#123;31,28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;,
&#123;31,29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;
&#125;;
Scanner sc = new Scanner(System.in);
System.out.print(&quot;请输入年月日(1980 11 28): &quot;);
int year = sc.nextInt();
int month = sc.nextInt();
int date = sc.nextInt();
int\[] daysOfMonth = data\[(year % 4 == 0 &amp;&amp; year % 100 !=
0 || year % 400 == 0)?1 : 0];
int sum = 0;
for(int i = 0; i &lt; month -1; i++) &#123;
sum += daysOfMonth\[i];
&#125;
sum += date;
System.out.println(sum);
sc.close();
&#125;
&#125;1.  回文素数：所谓回文数就是顺着读和倒着读一样的数(例如：11，121，
1991…)，回文素数就是既是回文数又是素数(只能被 1 和自身整除的数)的
数。编程找出 11～9999 之间的回文素数。
答：
package com.bjsxt;
public class PalindromicPrimeNumber &#123;
551public static void main(String\[] args) &#123;
for(int i = 11; i &lt;= 9999; i++) &#123;
if(isPrime(i) &amp;&amp; isPalindromic(i)) &#123;
System.out.println(i);
&#125;
&#125;
&#125;public static boolean isPrime(int n) &#123;
for(int i = 2; i &lt;= Math.sqrt(n); i++) &#123;
if(n % i == 0) &#123;
return false;
&#125;
&#125;
return true;
&#125;public static boolean isPalindromic(int n) &#123;
int temp = n;
int sum = 0;
while(temp &gt; 0) &#123;
sum= sum \* 10 + temp % 10;
temp/= 10;
&#125;
return sum == n;
&#125;
&#125;1.  全排列：给出五个数字 12345 的所有排列。
package com.bjsxt;
public class FullPermutation &#123;public static void perm(int\[] list) &#123;
perm(list,0);
&#125;private static void perm(int\[] list, int k) &#123;
if (k == list.length) &#123;
552
for (int i = 0; i &lt; list.length; i++) &#123;
System.out.print(list\[i]);
&#125;
System.out.println();
&#125;else&#123;
for (int i = k; i &lt; list.length; i++) &#123;
swap(list, k, i);
perm(list, k + 1);
swap(list, k, i);
&#125;
&#125;
&#125;private static void swap(int\[] list, int pos1, int pos2)
&#123;
int temp = list\[pos1];
list\[pos1] = list\[pos2];
list\[pos2] = temp;
&#125;public static void main(String\[] args) &#123;
int\[] x = &#123;1, 2, 3, 4, 5&#125;;
perm(x);
&#125;
&#125;1.  对于一个有 N 个整数元素的一维数组，找出它的子数组（数组中下标连
续的元素组成的数组）之和的最大值。
答：下面给出几个例子（最大子数组用粗体表示）：
数组：&#123; 1, -2, 3,5, -3, 2 &#125;，结果是：81.  数组：&#123; 0, -2, 3, 5, -1, 2 &#125;，结果是：9
2.  数组：&#123; -9, -2,-3, -5, -3 &#125;，结果是：-2
可以使用动态规划的思想求解：
553
package com.bjsxt;
public class MaxSum &#123;private static int max(int x, int y) &#123;
return x &gt; y? x: y;
&#125;public static int maxSum(int\[] array) &#123;
int n = array.length;
int\[] start = new int\[n];
int\[] all = new int\[n];
all\[n - 1] = start\[n - 1] = array\[n - 1];
for(int i = n - 2; i &gt;= 0;i--) &#123;
start\[i] = max(array\[i], array\[i] + start\[i + 1]);
all\[i] = max(start\[i], all\[i + 1]);
&#125;
return all\[0];
&#125;public static void main(String\[] args) &#123;
int\[] x1 = &#123; 1, -2, 3, 5,-3, 2 &#125;;
int\[] x2 = &#123; 0, -2, 3, 5,-1, 2 &#125;;
int\[] x3 = &#123; -9, -2, -3,-5, -3 &#125;;
System.out.println(maxSum(x1)); // 8
System.out.println(maxSum(x2)); // 9
System.out.println(maxSum(x3)); //-2
&#125;
&#125;1.  用递归实现字符串倒转
package com.bjsxt;
public class StringReverse &#123;public static String reverse(String originStr) &#123;
if(originStr == null || originStr.length()== 1) &#123;
return originStr;
&#125;
return reverse(originStr.substring(1))+
originStr.charAt(0);
554
&#125;public static void main(String\[] args) &#123;
System.out.println(reverse(&quot;hello&quot;));
&#125;
&#125;1.  输入一个正整数，将其分解为素数的乘积。
package com.bjsxt;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class DecomposeInteger &#123;private static List\&lt;Integer&gt; list = new
ArrayList\&lt;Integer&gt;();public static void main(String\[] args) &#123;
System.out.print(&quot;请输入一个数: &quot;);
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
decomposeNumber(n);
System.out.print(n + &quot; = &quot;);
for(int i = 0; i &lt; list.size() - 1; i++) &#123;
System.out.print(list.get(i) + &quot; \* &quot;);
&#125;
System.out.println(list.get(list.size() - 1));
&#125;public static void decomposeNumber(int n) &#123;
if(isPrime(n)) &#123;
list.add(n);
list.add(1);
&#125;
else &#123;
doIt(n, (int)Math.sqrt(n));
555
&#125;
&#125;public static void doIt(int n, int div) &#123;
if(isPrime(div) &amp;&amp; n % div == 0) &#123;
list.add(div);
decomposeNumber(n / div);
&#125;
else &#123;
doIt(n, div - 1);
&#125;
&#125;public static boolean isPrime(int n) &#123;
for(int i = 2; i &lt;= Math.sqrt(n);i++) &#123;
if(n % i == 0) &#123;
return false;
&#125;
&#125;
return true;
&#125;
&#125;1.  一个有 n 级的台阶，一次可以走 1 级、2 级或 3 级，问走完 n 级台阶有
多少种走法。
答：可以通过递归求解。
package com.bjsxt;
public class GoSteps &#123;public static int countWays(int n) &#123;
if(n &lt; 0) &#123;
return 0;
&#125;
else if(n == 0) &#123;
return 1;
&#125;
else &#123;
return countWays(n - 1) + countWays(n - 2) +
556
countWays(n -3);
&#125;
&#125;public static void main(String\[] args) &#123;
System.out.println(countWays(5)); // 13
&#125;
&#125;1.  写一个算法判断一个英文单词的所有字母是否全都不同（不区分大小写）
package com.bjsxt;
public class AllNotTheSame &#123;public static boolean judge(String str) &#123;
String temp = str.toLowerCase();
int\[] letterCounter = new int\[26];
for(int i = 0; i \&lt;temp.length(); i++) &#123;
int index = temp.charAt(i)- &#39;a&#39;;
letterCounter\[index]++;
if(letterCounter\[index] &gt; 1) &#123;
return false;
&#125;
&#125;
return true;
&#125;public static void main(String\[] args) &#123;
System.out.println(judge(&quot;hello&quot;));
System.out.print(judge(&quot;smile&quot;));
&#125;
&#125;
5571.  有一个已经排好序的整数数组，其中存在重复元素，请将重复元素删除
掉，例如，A= \[1, 1, 2, 2, 3]，处理之后的数组应当为 A= \[1, 2, 3]。
package com.bjsxt;
import java.util.Arrays;
public class RemoveDuplication &#123;public static int\[] removeDuplicates(int a\[]) &#123;
if(a.length &lt;= 1) &#123;
return a;
&#125;
int index = 0;
for(int i = 1; i &lt; a.length; i++) &#123;
if(a\[index] != a\[i]) &#123;
a\[++index] = a\[i];
&#125;
&#125;
int\[] b = new int\[index + 1];
System.arraycopy(a, 0, b, 0, b.length);
return b;
&#125;public static void main(String\[] args) &#123;
int\[] a = &#123;1, 1, 2, 2, 3&#125;;
a = removeDuplicates(a);
System.out.println(Arrays.toString(a));
&#125;
&#125;1.  给一个数组，其中有一个重复元素占半数以上，找出这个元素。
package com.bjsxt;
public class FindMost &#123;public static \&lt;T&gt; T find(T\[] x)&#123;
T temp = null;
for(int i = 0, nTimes = 0; i&lt; x.length;i++) &#123;
if(nTimes == 0) &#123;
558
temp= x\[i];
nTimes= 1;
&#125;
else &#123;
if(x\[i].equals(temp)) &#123;
nTimes++;
&#125;
else &#123;
nTimes--;
&#125;
&#125;
&#125;
return temp;
&#125;public static void main(String\[] args) &#123;
String\[]strs =
&#123;&quot;hello&quot;,&quot;kiss&quot;,&quot;hello&quot;,&quot;hello&quot;,&quot;maybe&quot;&#125;;
System.out.println(find(strs));
&#125;
&#125;1.  编写一个方法求一个字符串的字节长度?
public int getWordCount(String s)
&#123;
int length = 0;
for(int i = 0; i &lt; s.length(); i++)
&#123;
int ascii = Character.codePointAt(s, i);
if(ascii &gt;= 0 &amp;&amp; ascii &lt;=255)
length++;
else
length += 2;&#125;
return length;
&#125;
559
就业实战和面试技巧篇
一 招聘程序员的内幕
1． 面试和相亲
面试其实本质上是一个交流的过程，它跟你去相亲本质完全一样。那么，把握面试官的
心理状态，从面试官的角度出发思考问题，将是你可以顺利收到 offer 的关键。
如果你知道面试官的动机，就可以建立共通点，很容易就能恰当地回应问题。从而为你
的面试加分、添彩。
相亲时，你期望碰到美女的渴望和美女期望碰到白马王子的渴望，二者的“渴望程度”
完全是一样的。 那么，你如果是男方，你需要做的事情就是“包装”自己，让自己显得比实
际上“更高，更富，更帅”，接近女方的心中白马王子的高度，越接近越容易成功。这个过程
也存在“心理博弈”的过程，双方聊过去、聊现在、聊未来。 有辉煌过去的喜欢聊过去来证
明自己的未来；现在辉煌的就喜欢聊当下；过去不行，现在不行的就喜欢聊未来，展现自己
的雄心。
同上面相亲的案例，面试中，面试官需要人才的热烈程度等于你求职的热烈程度。 我们
首先要明白面试官需要什么样的人才，然后展示自己，告诉他，我就是这样的人才！
明白上面的道理，我们就需要针对整个招聘的过程进行详细的分析，让大家心里更有底，
更容易把握面试官的心理状态。
560
2．为什么要招聘程序员？为什么绝大部分总能找到工作？
一般公司招聘员工有三大类原因：1.  公司计划性扩张
2.  特定项目
3.  有员工离职
因此，招聘者也是“求贤若渴”，他也面临公司给他的绩效压力。如何能尽快、低成本的招
聘到合适的人到岗，而不耽误业务的进展，这是招聘者最大的工作。
通常如果受到高层压力，感觉招聘进度已经限制了公司业务的发展、已经阻碍了业务推
广的时间，招聘者就会变“急”。 就跟开发人员迫于项目时间的压力，凑合完成一段不合格的
代码一样。招聘者也会由于这些压力，有可能降低招聘的岗位标准(这种降低不是明面上通知
降低标准，而是各个环节把控较松)。 这也就是为什么很多人技术并不太好，也能找到工作
的原因。公司最大的成本有时候不是金钱、而是时间。 这也就像很多优秀的男生女生 30 岁
之后，迫于时间压力，降低标准找对象的道理一样。
虽然学习编程的人员很多，但是各行各业都需要信息化，人员需求也非常巨大，缺口仍
然很大。 如果某个公司招聘并不顺利，连续面试很多人都不合格，那么可能就在面试你的时
候降低“标准”。 这也是为什么很多技术很水的人也能找到工作的原因。对于招聘者来说，如
果你心态好，很踏实，即使现在技术不行，花一点时间培养你，也没什么大不了。
当然，这不能成为你不好好学习技术的理由。”技术强、心态好、踏实”将会让你面临更多
561
的人生机会。
3．为什么有人会找不到工作？
任何一个行业都有失败者，这就是规律。 就像婚姻、恋爱市
场，总会有打光棍的问题(100%是男同胞，男女比例严重失调啊)。
为什么会有人找不到工作？为什么会有人找不到老婆？这是个大
课题。想明白了，你将会走向人生巅峰。
我们先以婚姻、恋爱市场为例。研究研究为什么会有人找不
到老婆？ 有人说，打光棍是因为这个人没钱。 但你总会发现比
他还没钱的人娶了老婆，有的还很漂亮。老婆还很贤惠，出去打工养老公。 有人说，打光棍
是因为这个人没能力。 但你总会发现很多没能力的人也娶了老婆，有的也很漂亮。 这时候，
你只能仰天长叹，“好白菜都让猪拱了”。有人说，打光棍是因为这个人长得丑，个子矮、家
里穷等等。但你总会找到层出不穷的反例。这时候，你可能就会迷茫了。到底什么才是关键、
才是问题的核心？
好吧，我告诉你，是心态！心态！心态！重要的问题说三遍！ 心态积极，勤奋努力什么
事情都能干成。 心态消极，懒惰不努力，什么条件都没戏！ 很多“懒屌丝”宁愿天天宅在家
里睡懒觉、玩游戏，也不愿意走出去。宁愿窝在家里练习右手臂力，也不愿意出去多跟异性
接触。 这些人，不管什么条件都将被淘汰。
大家如果看过电影《夏洛特烦恼》，里面的“大傻”，智商低，但是人实在。就是靠死缠烂
打硬泡的方式，竟然也追上了自己的女神。 追女神也是概率问题，努力去追，提高成功率，
女神总有空虚、心理没底的时候，这时候可能就会有机会了。 某天，女神忽然微信呼你：“忙
吗？”，这时候机会就来了。 但是，如果你不努力，你连女神的候选名单都上不去，怎么可
能有机会？
在招聘市场，应聘者面临的是同样的问题。 即使你技术水平差，只要多面试、多总结、
多努力，没有不成功的。 你想想，面试是个概率事件，技术差你的成功率即使只有 1%，面
562
试 100 家也上去了。 技术好你的成功率是 10%，不去面试，面试的少，你可能也没戏。 因
此，我们要千方百计提高自己“面试的机会”，至少可以让自己进入企业“眼里”，一旦有机会，
即可成功。
我们曾经碰到一个学员，大学学的是文科，学历是专科， 毕业后做了一名“光荣的水手”，
环球航行了两年，决定回归陆地。 开始学习编程，学了 1 个多月后，仍然在纠结什么是变量
的问题。 但是，这个同学心态好，积极向上，毕业后，积极主动的去面试，结果很快搞定了
工作，刚开始工资并不高。 工作两年后，成了项目经理，年薪 30 万。风风光光的回尚学堂
招聘学弟学妹了。 积极努力，一天当两天用，起点再低也会成功。
我们也碰到过一个奇葩的学员，在尚学堂学完后，就纠结于你们不是“推荐就业”吗？窝在
宿舍等着。 企业来了，老师通知也不来参加面试，偶尔来了，结果窝在宿舍根本没有锻炼出
能力，也无法面试成功，这是极其个别的案例。 即使你是千里马，不出去跑，天天窝在家
里，消极等待，最终你也会成为一匹“废马”。
所以，无论你是什么条件，高富帅还是矮矬穷，心态不对，恋爱和工作都不可能成功。 希
望大家积极起来，大着胆子冲向社会，千方百计进入企业招聘环节，即使不成功，就当做一
次锻炼机会，锻炼多了，一旦机会来了，是不是成功率就大大提高了？ 做“屌丝”可以，自
嘲一下也不错，但千万不要做“懒屌丝”，那样你就完蛋了。
4.  公司最喜欢什么样的程序员？
公司喜欢什么样的程序员？特别简单，三个特点：
第一、 态度好
态度永远是第一要素，面试者通常都是你以后的直接上级。如果跟你交流顺畅，看你态度也不错，这
样对他来说，领导起来就容易一些。 因此，态度通常是面试官看人的第一要素。 态度不端正，一切
免谈。能力强我也驾驭不了，要你何用？ 能力差态度好也勉强能接受，能力差态度还差那就分分钟
被灭掉。
第二、 技术能力较强
企业招聘人员毕竟是来做事的，技术能力是考察的重点。技术能力能胜任目前的工作，是面试官主要
看重的。
第三、 热爱技术工作，学习能力强
通过跟面试官的交流，能让别人觉得你热爱技术工作，会让你具备极大的优势。即使感觉你现在水平
较差，也没有关系。兴趣是最好的老师，喜欢技术，把加班当成玩游戏一样的态度，面试官显然会大
大的给你点个赞。
PS：这里顺便给个技巧，可以让你身价立刻增加 30%以上(本来你值 8000，可以拿到 1 万，
一下子让你一年多挣 3 万)，那就是学习本专业的一些新的技术、高级一点的技术。不需要多
么精通，了解即可。可以在面试的时候说出来。这样就会令面试官对你刮目相看，薪水标准
也会立刻增加。因为你说的这些技术，可能是面试官也不会的，这种对你的好感度和惊诧的
眼神立刻就会让你身价暴增。 很多 java 学员学完后再学大数据或者架构师班，都有这样的
误解，觉得一定要学到多么多么好。其实，没必要，了解大数据或者架构师班某些技术能交
流即可，面试时优势已经极大了； 而且，即使上了班，用到这些技术，查查资料加加班能弄
出来就 OK 了。
如上三点决定了你是否能被录用。大家掌握这三点，也可以互相补充。比如，你技术差，
563
可以通过展现态度好，爱技术，爱学习来获得加分。 当然，如果技术好，也要通过展现态度
好，爱技术，爱学习获得更多的分。
面试官经常会碰到技术非常合适，但是态度较差，计较是否加班的面试者，基本都被 pass。
毕竟，技术再强也不是地球上只有你会，对不对？ 如果态度差，加入团队变成团队的负能量，
那就损失大了。
5．我到底值多少钱？
“我是谁？”这是人生最大的命题，找工作最大的命题是什么呢？显然，就是“我到底值多
少钱？”。给自己确定了合适的定位，才能找到合适的工作。 如果你能力只值 5000，一定要
找 3 万的工作，那怎么可能找得到？
一般情况，面试官评价你的薪资标准通常从下面几项：
5.  个人素质和口才(占比：20%)
这其实是个印象分，所以要被别人认可的其实就是上一个话题《公司最喜欢什么样的程
序员》中表示的第一特点：“态度好”。
如果你向面试官充分表达了良好的个人素质、对工作积极的态度，整个面试过程中让面
试官都觉得非常的顺畅、很投缘，即使你技术较差，也可以让你顺利拿到 offer。
564
“个人素质和口才”是你拿到 offer 的最关键因素。
6.  基础技术（占比：40%）
基础编程能力、理论知识是否扎实、知识体系是否系统是面试官比较看重的。老师讲课
过程中的基本知识点要尽力吃透，良好的知识体系对于后期面试极其有利。
如果面试官感觉你项目经验不丰富，但是基础扎实，也可以完全的弥补项目经验欠缺的
问题。这也是很多应届毕业生能顺利就业的法宝。 当然，如果项目经验欠缺的话，高薪的概
率就降低了， 需要降低薪资要求，保持较普通的薪水来实现就业。
“基础技术”是你能否就业的基础因素。
7.  项目经验（占比：40%）
项目经验显然是面试官极其看重的一项。从项目经验的描述中可以体现你的个人素质、
基础技术等等。尽量多的积累项目案例，尽量多的敲代码，可以完成基本的项目模块，会成
为你以后面试的杀手锏。
在培训期间，老师讲的项目案例大家要学会举一反三，毕竟这些案例对着几十人、几百
人讲过，你在面试时直接写到简历上并不是特别好的做法。最好的做法是，做一个有心人，
多留意和查找适合自己的项目案例。 项目案例是你的，里面的项目流程和开发中遇到的问题
是老师课上讲过的。说白了，就是将你的项目案例换了个衣服，“换汤不换药”，这样就可以
在面试中起到更好的效果。
565
566
“项目经验”是你能否实现高薪的关键因素。
8.  最新和高级技术了解程度(额外，增值 30%--50%)
前面 3 项如果做好了就可以完全保证就业了。“最新和高级技术了解度”是能否争取到合理
范围内更高薪水的关键，也就是让你实现更高“溢价”，“超额把你自己卖出去“。
面试官通常由于平时工作忙，无暇学习新的技术和知识，除非是项目用到的技术。但是，
作为一个“技术控“，通常会关注最新技术的信息，拥有学习这些技术的渴望，但是没有时间
和精力。 这个时候，应聘者简历上写的新技术、面试时聊的新技术，都会成为让”面试官欣
赏你的理由“。但是，注意千万不要有心理负担，这种”欣赏的眼神“是上级发现一个得力下属
的”喜欢的眼神“，而不是好基友。 面试官也知道你基础一般、项目经验一般，但是这些新技
术你都在学，证明你是个”技术好胚子“，很像曾经的”他自己“而已。
如果前三项决定了你的薪水是 8000，那么有了第四项，你的薪水标准通常会提高至少
30%，最高 50%。也就是实现了”你的溢价”, 每个月可以多赚：4000 元左右。 而且，你会发
现拿 8000 和溢价拿 1 万,1 万 2， 最后干的活其实差别不大。
这里有个经过我们统计的”1.5 倍定律”: 就是经过”最新和高级技术”的助力，你的薪水会在
原定值上增加 50%，薪水是原来的 1.5 倍。
6.找工作最重要的是什么？薪水?机会?
什么最重要，因人而异。一般分为如下几类：
567
第一种情况：offer 多，可以挑
这种情况，我也不多说。缺钱就看薪水，不缺就看机会。个人建议，看机会。
第二种情况：offer 少，没得挑
这种情况，当然，就是”别挑了。先进入行业，再寻找机会”。时间浪费不起，如果因
为薪水纠结，两个月不上班，损失两个月薪水不说，还浪费了两个月时间。
第三种情况：没 offer
这种情况，就是降低标准，千方百计就业，不管什么企业，先进去再说。进去行业后，再学习，
再进步，再找更大的机会。
我们始终强调”机会成本”，差不多的前提下，尽快就业，不要纠结于薪水多 500 少 1000
的问题，进入行业后，还需要再学习再提高。 现在就业不是你的终点，而是你的起点。
9.  学习很多技术，现在的公司不用，不是亏了吗？
很多朋友还是跟小孩一样， 感觉学习了东西后如果考试不考，公司暂时不用就没有价值，
不想学习。 感觉学习好累啊，是给老师学的，给尚学堂交了学费，是给尚学堂学的。别不承
认，很多人潜意识里面就是这种”应试教育”思维。
多学东西到底是为什么？其实，很简单。掌握更多的技术，意味着更多的机会，有更多
选择的机会。 人和人之间本质的差距就是“选择权“的差距。 农民自家种蔬菜、养猪吃，很
干净很有机；千万富翁可能还要吃着普通的猪肉和蔬菜；他们之间的差距在于：千万富翁可
以随便选择，可以随时过农民的生活；而农民却没有选择过千万富翁生活的权利。多学技术，
就意味着有更多选择的机会，发展的机会，就会造成工作和生活的差距。
同时，在 IT 行业多学东西，除了这些“机会和选择权“之外，更直
接的就是能带来金钱的收益。举例来说，同样招聘一个java程序员。
小 A 只会 java 已经合格了。 小 B 除了会 java，还会一点大数据和
架构知识，要价比小 A 高 20%。 关键是，我们公司现在也不需要大
数据和架构技术，小 A 和小 B 来了以后还是写 java 代码。 你猜，面试官会选择小 A 还是小
568
B? 绝大多数面试官会选择小 B。 有了小 B，一旦后期有大数据和架构的需求，技术经理就
多了一个选择。 而且，小 B 显然更好学，成长性更好，虽然薪水高 20%，但是几个月时间
就能把这 20%的薪水赚回来。
掌握或了解更多的技术知识，抛开企业用和不用的角度，单纯看应聘者就是一个态度的
问题、成长潜力的问题。 面试官显然会要态度更好、成长力更大的员工。
另外，你的企业现在不用，以后可能会用呀，这个时候你可能就具备强大的话语权和机
会了。 我们一个大数据的学员毕业后，他还是应届生，去了一家公司做 java 开发，没多久
老板成立大数据业务的公司，结果公司就他会，直接就被任命为大数据业务的技术负责人。你
可以说，这个学员还年轻，技术不行什么的，但是他有这个技术负责人的平台，还要学习和
提高，现在不行，一年后呢？
多学习，意味着更多的机会和选择；更多的机会，意味着完全不同的人生。
二 找工作前需要准备的杀手锏
高考前，我们要练兵考试和集训。”临阵磨枪不快也光 ”，找工作前，我们也必须要花很
多精力去完成一些必要的准备。 “不打无准备之仗”， 精心准备和训练会对你有相当正面的
作用。
有人认为“找工作要靠能力”。这话没错，我要说的是，“临阵磨枪准备的内容也是能力的
一部分”。 找工作其实是结果导向的一个事情，而不是过程导向。小 A 和小 B 技术实力差不
多， 小 A 经过精心的准备和策划，获得的机会显然要远远多于小 B。也许一个机会，就能
完全将小 A 的命运改变了。
10. 职场的十大基本素质
大家进入职场前,非常有必要明白职场的一些基本要领。其实,道理都非常简单，甚至可以
说是常识, 关键是我们能否执行下去。很多人不明白这些基本的道理，几年下来，坏的行为
固化成习惯，习惯进一步融入到命运，最后很悲惨的成为人人鄙视的 loser。所以，我希望大
家从看到这篇文章起，就遵守这样的行为准则，你将会在职场中很快迎来自己的好运。
① 着装整洁、个人卫生合格
这个都不能算作职场素质，应该是做人的素质。每天逢头垢面出门、指甲里面都是污垢、
身体有异味，如何让别人觉得你是个靠谱的人？千万不要跟我说，你不拘小节。不拘小节是
谦词，别人可以给你面子这么说你，但你不能这么说自己。每天出门前，男士花十分钟打理
一下自己，穿一身干净的衣服。你可以没有阿玛尼，穿地摊货都可以，关键是干净整洁。干
净整洁、形象良好，马上可以让人对你的印象提高 N 个档次。
记得几年前，一个学员过来找我，说：“老师，我面试了好多家了。为什么都是几分钟就
被人打发了”。我极其惊讶地看着他，N 天没有洗澡，乱糟糟的头发，满脸油腻，“逢头垢面”
就是形容他的。那时候是夏天，估计 N 天没洗澡，一股异味。基本上我可以断定，这个哥们
的处境。第一、没朋友，无论男女。没有人会愿意跟他呆的距离在 1 米以内，那真是一种折
磨。第二、没前途。不知道哪个瞎眼的面试官会要他？于是，我很残忍的告诉他现在的处境。
我问他：“你个人卫生是不是太差了。这个仪表，人家跟你说十分钟都是给你天大的面子
了”。他说：“我知道卫生有点差。但我觉得别人不会那么庸俗的，应该更多的关注我的技术
569
和我的人品”。
我说：”大家时间都很有限，都很忙。第一、跟你技术水平相当的人多得是，没必要花时
间透过你这个外表去琢磨你的内在。第二、你太自我为中心了。别人应该关注你的内在，你
怎么不说，你应该改改你的外在？连基本外在卫生都没有，你还能做什么？“。
他仍然固执：”讲卫生很简单，我每天花点时间整理一下就行了。但是…“。
我打断他的话：”先回去洗个澡，换身干净的衣服。你这样的仪表，第一、不尊重你自己。
第二。不尊重别人。不说工作了，你这样怎么找女朋友？想改变你的处境，先改变你的仪表，
改变你的行为。以后，每天早上花十分钟整理一下自己，不然，你完蛋了“。
后来，就没再来找我。一年后，我收到一个短信：“高老师，感谢你的醍醐灌顶。以前，
太自以为是，以为世界都是围绕我的。那天回去后，我就真的“洗心革面”了，每天早上整理
一下外表，都不用十分钟，五分钟就够了。后来，我再面试只花了一周时间就上班了。这一
年里，收获很大，也有了女朋友，也有了很多男性朋友，整个人生都感觉改变了。再次谢谢
您的直言不讳”。
② 有正常的交流习惯
一个正常的交流习惯也是及其重要的。正常的交流习惯有如下五点：
1.不打断对方说话
这是对别人最基本的尊重，把话让别人讲完，也是最基本的礼貌。
11. 说话时，盯着对方的眼睛。眼神坚定，不飘忽
眼睛是心灵的窗户。跟人交流时，千万不要边说话，眼睛边四处看。要紧盯着对方的
眼睛，如果你实在不好意思，可以盯着鼻梁看。盯着鼻梁，在对方看来也是盯着眼睛
的，效果差不多。
12. 说话时，语气不拖拉。
说话语气肯定，有自信，千万不要嗯嗯啊啊。
13. 没有小动作，但可以适当增加手势
抖腿、搓手、动手碰别人这都是不礼貌的习惯。交流时，不要有这些不良动作，但是
570
可以适当增加手势，让你的交流更顺畅。
14. 表情放松，多一些微笑
不要将跟别人的交流搞得太过正式，放松一些，多一些微笑。
③ 准时，不迟到
一个没有时间观念的人，怎么可能做好事情？因此，面试不迟到、约会不迟到，这都是最
基本的礼仪。而且，所有的面试、约会最好保证提前十分钟到达。
但是，万一发生了迟到的状况，怎么办？万一由于堵车等原因迟到，要立刻打电话联系对
方，告知对方原因，并表示抱歉。
④ 领导不下班，你也不走
对于初入职场的你来说，非常有必要让领导看到你的工作态度。你可以工作做的慢，但是
态度必须端正，至少要让领导觉得你是可造之材而不是烂泥。
如果你的直接上级仍然在加班工作，你非常有必要保持同步。如果能帮上忙，可以上前问
问有没有需要你做的事情。如果暂时帮不上忙，可以坐在电脑前学习一些专业性的知识。能
做到这一点的人，其实真的不多。做到了，也基本就可以奠定你工作认真、愿意付出的形象，
为以后创造更多的机会打下基础。
⑤ 和周围的同事打成一片
多跟同事交流、打成一片，是职场最基本的规矩。这在平
时工作和休息时，一定要多注意不能落单。最典型的：中午午
餐时间，一定跟同事们一起吃饭，不要落单。
571
⑥ 有困难，就马上寻求帮助
工作中遇到问题，自己通过查资料无法解决。立刻寻求同事帮忙，千万不要因为不好意思
开口而耽误工作时间，影响公司整体的工作进度。
⑦ 有责任心、事情到我这里结束
基本的责任心及其重要！千万不要以分工清楚、不是我的事情作为推脱的借口。在大公司，
分工过细是事实，但是你也经常需要参与工作之外的事情。在中小企业就更不用说了。事情
到你这里，你能把他解决掉，本身就是能力的锻炼和提升，是让自己升值的机会。如果，你
把它推脱开，不仅丧失了锻炼的机会，也让别人看到了你的态度，看清了你的前途。
以前遇到过一个“搬椅子”的小事情。一次开会，会
议室少五把椅子，老板已经坐下，说：“多了 5 个人，
少 5 把椅子”。负责安排会议的人竟然问：“让我去搬
吗？”他也许是想说，我是个女孩哎，搬不动。也许是
想说，我是个经理哎，让我去搬椅子，多没面子。总
之，他说了这 5 个字。老板一脸错愕，没说什么。一周后，这个女孩辞职走人。
工作中，你碰到了就是你的事情。解决的事情越多，你得到的锻炼机会越多，你的能力就
越强，还怕没有升职和发展的机会吗？
很遗憾的是，工作中很大一部分都是责任心缺失的人。这也很幸运，这些无责任心的人会
让出很多的机会给你。一定要相信，你有没有责任心，你的上级、你的女朋友一定能第一时
间知道。
⑧ 学习的心态对待同事和上级、包容的心态对待同事和下级
“懂得配合才能有领导力、才能有协作力”，对待你的上级一定要抱着学习的态度。他能做
到这个位置，肯定有过人之处、肯定有比你强的地方。把他这些优点学习到位，再进行改进，
青出于蓝，你不就有机会了吗？
572
工作中，很多同事都会私下议论上级，觉得这个决定好傻、那个决定好呆。往往是由于下
级和上级看问题的角度不一样导致的，“屁股决定脑袋”。那么，为什么不尝试配合一下领导
的决定看看到底行不行呢？或者，你觉得确实有问题，完全可以私下跟领导说说你的感想。
在企业中的人事关系要比政府关系简单的多，你私下有礼貌的提出来你的意见，往往还能博
得上级的好感。
⑨ 忠诚
如果你不忠于你的公司，私下贪污公款、私下为其他公司牟利。一旦有这些行为，基本上
你就为人所不齿了。在公司你肯定不会有好的前途，其他公司看你这样，无非就是利用一下
你，但绝对不可能重用你。
永远不要以自己的小聪明耍弄你的上级和你的同事，这个世界，智商都差不多，谁比谁笨
呀？你可以蒙他一次，两次，不可能蒙他三次、四次。就像你考试作弊一样，自以为很聪明，
但如果你坐在讲台上监考，你就明白，下面的动作一览无余，更多的时候，只是老师不愿意
去把你拎出来而已。
所以，职场上，忠诚是人的最基本的素养。
⑩ 办法总比问题多，积极的心态面对问题
工作中遇到问题，不要害怕。工作就是解决一个个问题呀！既然
是问题，就有应对的办法。想尽办法，总能解决。不要遇到问题就牢
骚满腹：“完蛋了。这绝对不能解决”。发牢骚的人，在公司里面不仅
毫无价值，而且是负价值。
15. 公司调研
对于你即将要面试的公司，一定要做到“知己知彼”，在面试前做充分的调研。这样既能让
573
你在面试的时候与 HR 有充分的互动机会，也可以避免很多无良公司的“坑”。
做公司调研需要做到如下几个关键点：
16. 公司发展的历程
17. 公司的产品或者项目以及周期
18. 公司下一步的发展规划
19. 公司开发使用的技术架构
20. 公司跟开发有关的组织结构（开发部、测试部、运维部、产品部等）
21. 项目调研
对于企业来说，会关注你大学期间成绩单呢，还是关注你的项目经验？答案显然是：项目
经验。甚至在很多研究生复试时候，导师看到你的简历上写了很多项目经验，也会极大的增
加你的分数。五年前，我的一个学生在尚学堂培训时的项目写在研究生复试简历上，被导师
问了又问，最终被中科院计算所录取。这就是项目的力量。
因此，前期的项目准备会让你的简历更加丰富，赢得更多的机会。一个小小的机会也许就
能完全改变你的命运。
对于项目调研，大家要避免误区。不是说，一定要将项目的商业源码搞到手，通读一遍才
算是完成调研；也不是说，一定要把这个项目代码写一遍；其实，项目调研的本质是让你开
阔眼界，增加和“面试官”的谈资。
项目调研最重要目的是要让你明白某个项目开发的流程、某个项目的内在逻辑，此类项目
常见的问题，开阔眼界，最终真正理解项目开发的整体流程。
项目调研关键是要做到有心！现代互联网这么发达，任何资料都可以在网络上找到。我可
以给大家提供各种项目调研的思路：
A. 打开各种网站，其实就是一个个项目。
B. 打开相关软件公司，下载他们软件的试用版，就可以去研究他的内在逻辑。
574
C. 下载各种 app，也是一个个完整的项目。
D. 各种开源网站下载的项目，也可以作为研究的对象。
E. 大胆出去，参加一些创业、创意相关的活动。比如：中关村创业一条街的各种会议。
22. 基础技术准备
就业前，大家需要将自己平时培训期间学习的技术捋一遍，全面复习一遍。临阵磨枪仍然
是最重要的应急手段，面试前的准备就像高考前一样，越充分越好。
但是，需要记住如下两点：
23. 对于一些常见的面试和笔试问题，一定要反复练习，最好能背下来。
24. 对于一些工作和面试不常见的问题，记住结论即可，不要纠结。不要因为一些小概率
的问题而浪费太多的时间。毕竟，任何人都没有必要有能力可以应对所有的问题，只要能应
对常见的问题足以实现就业。
25. 热门技术准备
软件行业技术更新较快，经常会出现新的技术。但是，这些技术通常不会马上应用于企业
中，企业一般都会使用稳定和大众化的技术。所以，企业应用技术都有 2-3 年的滞后期。
身处软件开发第一线的人往往对新技术学习也会滞后，毕竟企业不用，大家还是不愿意多
花时间和精力去学习。但是，作为程序猿往往对这些技术保留了极大的好奇心。绝大部分程
序猿会心想：“等我有时间，我一定要学习一下”。
575
这种滞后性，就是刚进入软件行业的新人的机会。如果你是做 IOS 开发的，简历上写明会
使用 swift 语言开发，就会引起一直使用 Object-C 开发项目的面试官极大的兴趣。如果你是
做 JAVA 开发的，会使用微服务架构，了解大数据相关的技术，也会引起面试官较大的兴趣。
而且，更有意思的是，你不需要精通这些新技术，只要了解即可。就能很快的引起面试官的
兴趣，毕竟“好奇心”是程序猿最大的特点。
对于热门新技术的了解，可以明明白白的告诉对方，你就是一个喜欢技术、喜欢钻研的典
型的程序猿。这会给你起到加薪加分的效果。”1.5 倍薪水定律”就会起到作用。
26. 更高端技术准备
技术行业是一个非常干净的行业，付出和得到基本是正比关系，你不需要靠关系靠背景。
作为程序猿，学习就是本能，学习跟你的薪水是成正比的！学习越多，薪水越高。作为一个
专业的程序猿，必须做好进一步提升的准备。千万不能有已经到头的想法！一个二三十岁，
刚入行的年轻人，如果产生了已经学够的想法，那说明你的前途也到尽头了！”观念决定行动，
最终决定命运”。
对于本专业更加高端的技术，一定要保持学习的心态。即使，这些技术暂时用不到。对于
开阔眼界，提高思维境界，应对面试都是极好的。掌握或了解本专业更高端的技术，加薪加
分效果也很明显。“1.5 倍薪水定律”效用也非常明显。
27. 本专业之外的技术准备
很多人会以：“专业贵精不贵多”，“一招鲜吃遍天”，作为不学习其他技术的借口。这些话
576
没有错，我也赞成这些话。但是，这些话不能作为不学习的理由。
一个学习安卓、IOS 开发的程序猿当然最重要的就是掌握本专业的开发技能，但是如果你
还了解后台服务器程序的开发，这就是你不同于普通程序猿的优势。
一个学习 JAVAEE 开发的程序猿，学好 JAVAEE 是最重要的，再了解大数据开发的知识、
人工智能开发的知识， 也可以触类旁通， 让自己获得更多技巧。同时，在面试 JAVAEE 的
时候，你竟然也懂大数据、懂人工智能（也许只是皮毛）？但也一定可以给你的面试加分。
知识面宽往往意味着好学，潜力巨大。经过两三年的磨练后，熟悉各种技术的你，必将迎
来一次发展的机遇。为什么机遇一定会给你？显然，一般人是做不到这一点的。
我们有一个学员学完 JAVAEE 后，又学习了大数据开发，很多人说他：“好傻，你去公司只
是做一份工作。学那么多干什么?“。但是，这些嘲笑他的人错了。这位学员三个月后，就成
了公司项目的负责人，很简单，就是因为他 JAVAEE 会，大数据也会，公司正好需要两方面
都懂的人。
“如果因为学习，别人说你傻”，我们只能回应：“别人笑我太疯癫，我笑他人看不穿”。这
个社会，如果不能跟别人拼爹，那就只能跟别人拼头脑拼血汗了。
28. 共同话题准备
面试你的人基本都是程序员，或者程序员出身，因此你们在对话中都可以找到很多共同话
题。那么，为了让我们的面试充满各种“亮点”，对于共同话题的准备就相当有必要了。“用心
去准备的面试，连面试官都会被你认真的态度打动；反过来说，如果连面试都不重视的人，
我怎么相信你会对工作更有责任？”。
我们可以准备以下这些问题：
29. 是否曾经耗费几个小时甚至几天的时间来追踪一个顽固的 bug？
30. 你有没有因为某个问题加班到半夜的经历？
31. 你喜欢某种编程语言的哪一点？
577
32. 经常访问哪个程序员的网站？
33. 你最喜欢看的编程类的书籍是什么？
34. 关于 IDE，什么事最让你抓狂？
35. 精心准备几个能说明你技术能力的专业问题，在面试时尽量发挥出来。
36. 自我模拟面试和对练
开始投递简历前，可以五人一组互相对练，进行角色扮演。分组练习
的好处非常明显，可以让我们在非常短的时间里得到提升。分组练习的
角色有：面试官、应聘者、旁观者。
分组练习的好处有：
37. 面试别人可以体会如何设问，对方回答是否得体。
38. 应聘者可以身临其境体验被面的过程。
39. 旁观者可以清晰的看到面试官的优缺点、应聘者的优缺点。加强学习，避免自己发生
这些问题。
但是，也不能过多的训练。以每人各扮演两次角色(两次面试官、两次应聘者)为宜。然后，
马上投递简历，开始实战！！！
三 面试准备
1.简历的作用
一份格式规范、要点突出的简历是你找工作的“敲门砖”，值得你花上一周、甚至两周时间
精心打磨。这样你会获得更多的机会。当然，简历仅仅是敲门砖，任何一个面试官都不可能
仅凭简历就雇佣一个人。
578
2.简历两个灵魂
第一要点：必须自己亲自写简历。
简历必须每个字都自己写，绝对不能抄！自己亲自写
一次简历，相当于把技术复习一遍，把项目捋一遍，对
于其中的关键点可以做到心中有数。 面试中的很多问题
都是根据简历问出来的，只有自己亲自写一遍才能灵活
应对。
第二要点：简历要突出自己的核心竞争力。
一个职位会有几十、几百份简历的投递！投递简历显然是存在竞争关系的，一定要对简
历作出适当的包装，就像去相亲要化妆一样。 不包装的简历如同没有穿衣服逛街一样，虽然
显得本真，但是也很神经病，很傻。在面试官看来，没有包装的简历会显得你这个人不识时
务，不灵活，而不会觉得你这个人本真(其实就是天真)。 处在世俗社会里面，我们要随“社会
大流”，别人化妆我们也要跟进，不求占别人便宜，但是也不能吃亏。但是，包装不能欺骗企
业，掌握好“度”。
3.一份完美的简历(6 大要素)
1.囊括相关技术关键词，注意上下文
公司每天会收到几十份简历，筛选这些简历往往是不懂技术的招聘人员，因此尽量写上你
会的技术的关键词。
2.文笔要好，要点突出，简明扼要
如果你不知道如何组织文字，可以先尝试将想表达的内容讲给朋友听，这非常有效。第一、
可以起到互动、交流的作用，让你的朋友给你指正。第二、可以捋思路。第三、为面试时的
回答打下坚实基础。
3.对工作经验、项目经验、实习经验作出解释
如果你声称具备某种工作经验、项目经验，那么就必须说明是如何获得的。如果简历上写
579
580
了“3 年 java 开发经验”、“3 年 ios 开发经验”，不进行进一步的说明，就显得太虚假了。 不说
明倒也没关系，但是面试官收到的简历可不止你这一份，毕竟还是有很多人进行了详细的说
明。你不说明就意味着白白丢失了很多机会。 就像去相亲见面，但是你不化妆、不打扮，穿
着拖鞋去了，那我想你太吃亏了。 我们不想占别人便宜，但绝不能吃亏。
4.工作经历不要留有情况不明的空白期
简历中，不要留下特别长的空白期，这会让人觉得你心中有鬼。
5.个人爱好和特殊证书
很多人会写上自己的个人爱好：“卡拉 ok，听音乐，看电影”。这些不能体现个人素质的内
容不如不写。但是，如果你是篮球校队、乒乒球学校冠军、厨艺大赛冠军这些倒是可以写在
自己的简历上。
6.简历结构明了，条理清晰
简历结构一定要清晰明了，便于招聘者快速阅读。不过，现在的招聘网站都有标准的模板，
应聘者往里填数据即可。
如下是一份比较规范的简历，该学员当时年薪为 30 万（税前，北京）。 大家可以作为奋
斗的参考。当然，写简历简单，掌握简历上的内容难。可以说，简历上的每个字都代表“一段
血泪史”。
姓名：孙悟空 性别：男 年龄：26 学历：本科 专业：软件工程
工作年限：3 年 电话：15388888888 英语：CET-6 邮箱：&lt;houzi@sxt.cn&gt;
目标职位：大数据研发、机器学习算法工程师
工作性质：全职 目标地点：北京 期望薪资：25K
2016.07-至今（3 年） 北京 xx 科技有限公司 大数据研发工程师
求职意向
工作经历
职业技能
581
⚫ 熟练掌握逻辑回归、朴素贝叶斯、基于物品协同过滤等算法原理，熟悉 K-Means 聚类、决
策树、随机森林、PCA 主成分分析等。熟悉 Mahout 和 Spark MLlib 机器学习框架。
⚫ 精通 Spark 运行原理，可以使用 Spark Streaming 和 Spark Sql 组件开发实时/离线分布式计
算系统，了解 Spark 资源调度和任务调度源码。
⚫ 擅长 Spark 性能调优，如内存调优、shuffle 调优、并行度调优、数据倾斜等
⚫ 熟练掌握 Hadoop 体系架构，理解 HDFS、YARN、MapReduce 原理。
⚫ 熟练使用 Hive 对数据进行预处理和分析。
⚫ 熟练使用 Mysql、Redis 等数据库。
⚫ 了解 Storm 流式处理框架。
⚫ 熟练使用 Java 编程，了解 Scala, Python, R 语言。
⚫ 熟悉分布式应用程序协调服务 Zookeeper，统一资源管理器和调度平台 Yarn，熟悉 Sqoop
进行对数据的迁移， 利用 Flume 进行数据采集，以及使用 Kafka 做消息缓冲，了解 CDH
平台，了解 Impala、 Oozie 的使用等。
⚫ 智慧旅游个性化推荐系统
项目描述：
国内现有的旅游推荐系统大部分仅根据用户输入的信息进行内容推荐,甚至只具备为用户提
供基本的旅游信息查询等功能,缺少鲜明的个性化旅游推荐服务。基于上述背景，该系统主要利
用大数据技术为旅游机构、景区景点打造个性化旅游目的地推荐系统。通过对以往游客对景区的
评分、咨询等不同历史行为进行数据分析，离线训练模型，根据游客的信息在线生成个性化的旅
游推荐方案，从而提高游客体验度，并使得推荐成功率更高。
责任描述：
⚫ 原始数据清洗，构建正负例样本
⚫ 构建特征索引文件，生成训练集与测试集。
⚫ 训练模型
⚫ 参与模型的评估与优化
⚫ 线上实时推荐功能，结合模型，返回推荐列表
相关技术：
⚫ 使用 SparkSQL 和 Hive 对数据进行清洗后存入 HDFS 中。
⚫ 运用逻辑回归算法预测模型，结果存入 Redis 数据库。
⚫ 利用随机梯度下降，调节算法的最大迭代次数和步长。
⚫ 基于物品协同过滤算法计算景区关联特征权重。
⚫ 根据模型和游客需要的目的地特征进行关联计算出商品基本特征权重防止冷启动问
项目经验
题。
⚫ 对算法进行 Robust 调优，提高模型的推广能力和泛化能力。
⚫ 通过 AUC 评估模型预测结果，对准确度进行量化评估。
项目架构：
Flume + Kafka + Hive + HDFS + Sqoop + Spark + MLlib + ZooKeeper + Redis + MySQL
⚫ 三正媒体消息推送系统
项目描述：
在这个信息量暴增的时代，人们面临着一个迫切而严重的问题，那就是信息过剩。随之将
新闻恰当精确推送给用户，同时也就成为了各大新闻门户关注的焦点。信息膨胀问题导致信息获
取效率也随之下降，让用户获取紧凑的个性化信息是每个新闻门户都面临着的最具挑战性的任
务。本项目通过爬虫获取各大网站近一周的新闻文档，对文档进行预处理提取出关键词，根据关
键词划分新闻的类别，同时实时采集用户的行为属性，对用户行为特征进行分类，然后依据新闻
的关键词，新闻的类别，用户的类别这三者的对应关系，精确恰当的将新闻推送给用户。
责任描述：
⚫ 需求分析、技术选型、方案可行性讨论
⚫ 筛选出新闻的关键词
⚫ 基于关键词对新闻进行分类
⚫ 基于用户行为对用户进行分类
⚫ 针对不同的用户分类推送不同的新闻。
相关技术：
⚫ 使用 Spark 和 Hive 完成数据的清洗，建立对应的 Hive 表，将数据存入到 HDFS 中。
⚫ 使用 IK 分词器对清洗后的数据进行分词。
⚫ 使用 TF-IDF 筛选出新闻的关键词。
⚫ 使用朴素贝叶斯算法基于关键词对新闻进行分类。
⚫ 使用 K-Means 聚类算法对用户行为进行分类。
项目架构：
Flume + Kafka + Hive + HDFS + Sqoop + Spark + MLlib + ZooKeeper + Redis + MySQL
⚫ AA 租车用户行为分析系统
项目描述：
本项目主要是基于租用汽车对用户行为进行分析，通过分析用户行为数据来获取用户的活
动规律和潜在价值。项目通过对采集到的大量数据进行实时分析和离线分析，从而获取用户的
582
583
访问量、新用户的注册率、活跃用户、订单的产出量、订单的成功率以及订单的地域分布等一
系列指标来分析整个项目运行状况，对项目的运营提供更好的数据支持，同时为公司的运营决
策提供依据。
责任描述：
⚫ 原始数据的清洗和格式化。
⚫ 获取用户访问量、新用户注册率。
⚫ 实时统计用户访问量、地域分布、订单量等数据信息。
相关技术：
⚫ 负责通过 Flume 对项目日志数据进行收集并保存到 HDFS 以及 Kafka 消息队列中。
⚫ 通过 Spark 和 Hive 进行数据清洗，建立 hive 外表。
⚫ 通过 Spark 获取用户访问量、新用户访问量和新用户注册率。
⚫ 通过 Spark Streaming 进行实时统计用户访问量、地域分布、订单量等数据信息。
技术架构：
HDFS + Spark + Spark Sql + Spark Streaming + Hive + Kafka + Flume
2016 年优秀毕业论文(知网检索)
2014 年第四届 APMCM 亚太地区大学生数学建模竞赛二等奖(3%)。
2014 年东北三省数学建模竞赛三等奖(20%)。
⚫ 逻辑思维能力强，具有较强的学习能力以及适应能力，善于思考。
⚫ 具备良好的团队合作意识与良好的沟通能力。
⚫ 有高度的责任感，对工作积极严谨，勇于承担压力。
⚫ 与人能友好相处，有责任心、执行力及抗压性强，能够积极的面对并解决工作中的问题。
⚫ 具有良好的英语阅读能力，能阅读英文资料、技术文档等
4.简历的常见错误
“千里之堤，溃于蚁穴”， 简历可以让招聘者对你形成第一印象。如果简历中存在细小的
错误，也会被视为不认真的体现，可能会让你失去很多机会。
通常有如下错误：
个人奖项
个人评价
1.手机号、qq 号错误、电子邮箱格式不正确
真的有傻瓜竟然会把自己手机号码写错，或者写了已经停机的旧手机号码。然后，坐等招
聘电话。 这些基本联系方式，一定要核准无误。
2.技术词汇拼写错误
这也是常见的错误，技术词汇单词错误、大小写不对等等，这会直接降低你的第一印象。
连自己的简历都不认真，还能做什么？ 就像出门不洗脸的人，还能期望他做什么？
3.排版混乱
排版必须清晰，大方，结构整齐。
4.抄袭别人的简历
这是对自己和他人最大的不负责任。想找工作连个简历都懒得写，这种态度如何处人处事？
面试中，针对简历提出的问题，你如何能回答？
所以，抄简历，一定是死路一条。
40. 注册招聘网站和简历投递
简历准备好以后，必须尽快的进入投递环节。不要等待，不要老琢磨“我要把各个环节搞
明白再投简历和面试”，这是错误的想法。我们必须在战场中提高自己，实战中提高自己是最
快的。
首先，注册著名招聘网站或者地方类招聘网站，并在这些网站上完善简历。智联招聘、51job、
中华英才、拉勾网等这些网站是必须要注册的，一个都不能少。如果在地方城市找工作，地
方类招聘网站也可以注册，比如：长沙的芙蓉人才网、太原人才网等。
简历投递一般采用海投的方式，并且要隔两三天海投一次。 海投会给企业招聘者带来一
定的麻烦，但是对于应聘者是最高效的方式。对于应聘者来说，时间很宝贵。千万不要把时
间花在一个个筛选企业上面，对于刚入行新人，还没有资格筛选企业。至于有善良的应聘者
害怕企业的 HR 麻烦，我只能说“你想多了”。
584
585
一份合格简历海投完后，你就会接到一些面试电话。下面就应学习怎么应对面试电话了。
41. 接面试电话如何应对
接到面试电话的时候，一些基本的电话礼仪你需要知道。通过如下的场景模拟，让你对接
电话后的流程有一个基本的了解。
流程如下：
42. 接听电话第一句通常是： “喂(二声)，你好”。
43. 对方通常会说：“我是 xxx 公司，我们这里收到你的简历。你明天上午 10 点有时间来我公
司面试吗？”
44. 你通常会说：“可以，没有问题。贵公司的地址在哪里？”。注意，如果时间上不允许，比
如跟你已经约好的一家公司冲突了。你也可以大方的告诉别人，明天上午有面试了，能不
能换一个时间。
45. 对方会说： “我们公司在海淀区 xx 大厦 12 层 1201”。
46. 你可以说： “那我到了以后，跟您联系吗？您怎么称呼？”
47. 对方会说： “我姓高。到了，你跟前台说找高七七就行”。
48. 如果你对自己查询交通路线不太放心，可以问一下对方，如何到他们公司。如果有信心，
就不用问了。
49. 最后，你一定要这样说，“好的。谢谢你。我跟您确认一下。您的公司名字是：xxx 公司。
明天上午 10 点，在海淀区 xx 大厦 12 层 1201。对吗？”
50. 对方回答： “是的。没有问题。还有其他问题吗？”
51. 你回答： “没有了。谢谢。我明天准时到贵公司”。
52. 对方回答： “好的。再见”。
53. 你回答：“OK。再见”。等对方挂掉电话后，你再挂掉电话。即可结束本次电话邀约。
通过一次交流，将公司名称、地址、面试时间、联系人问清楚即可。
然后，立刻马上，使用手机或者电脑查询这个公司相关的信息，越详细越好。直到能够回
答如下问题为止：
54. 公司发展的历程
55. 公司的产品或者项目(该公司同类型公司的产品和项目，各自的优劣势分析)
56. 公司下一步的发展规划
这些问题，将会让你在后续的面试中获得意向不到的收获。
57. 去公司之前的准备
去公司面试前，做到如下五点：
58. 查询和调研该公司的基本情况
59. 个人卫生整洁，着装干净
60. 提前 10-15 分钟到达，不迟到（万一迟到，一定电话通知对方，告知实情）
61. 将以前面试遇到的问题再预演一遍
62. 将笔试题再复习一遍
63. 笔试
去企业笔试，通常都会做一份该企业的笔试题目，作为基本的考核。通常，企业笔试题
目都大同小异，都是一些常见工作问题，不会出现偏题难题怪题。如果你之前，已经做过常
见笔试题目，绝大部分题目都可以囊括。所以，只要好好准备，笔试不会构成特别大的问题。
笔试过后，通常都会带你进入面试环节。面试官通常都是你以后的直接上级，这时候就需要
你好好表现了。
四 面试
64. 面试时，为什么没必要紧张？
第一、 从心态上你要把这次面试看做一次练习，成败都可。毕竟，说实话，面试成功是小概率事件，
按照一个人面试十家公司成功一家来看，每家成功的概率只有 10%。所以，完全没有必要紧
张。
586
第二、 面试官在跟你交流的时候，并不会将你说的每个字都记在心里。毕竟，他也有工作压力，他
可能在想：“下午开会，怎么跟老板交代的问题”。面试官多数时候，是处于一个完全放松的状
态，听你回答只是听个流程和大概，并不会全身心投入。所以，你尽可以放轻松的交流。你
的若干小问题，对方通常都不会注意到。
第三、 面试完你以后，面试官还要再面试 N 个人。最后留到脑子里的就是你当时表现的打分结果，
不会对你们这些应聘者每个都留下特别多的回忆。如果你觉得你说的做的每个细节，面试官
都看到了。通常，是你想多了。
第四、失败又有何惧？此地不留爷，自有留爷处！天下公司那么多，只要我多面试，多
总结问题。即使只有 1%的机会，面试 100 家不是也能面上吗？
当然，上面是给大家做“失败并不可怕的心态调整”，并不意味着你就可以浪费大把面试机
会而不珍惜。
65. 面试中的礼仪
面试中，遵循正常的职场礼仪即可。这是“最基本要求”，如果你有任何一点问题，都可以
让你的成功率立马降低 50%以上。
所以，一定要遵守基本原则：
66. 微笑、礼貌、大方
67. 有正常的交流习惯，没有小动作（抖腿、搓手等）
68. 绝对不能争论
69. 卫生干净，衣冠整洁即可（没必要西装领带）
面试开始时：
1.面试官进入、求职者从座位起立，微笑说：“你好”。
2.如果对方是男士，可以主动伸手握手。如果是女士，不要主动，看对方示意即可。
587
面试结束时：
1.结束时，一定要对面试官表示感谢。
2.将座位放回原位，帮助收拾一下桌面卫生，所有物品物归原位。
70. 常见技术面试场景分析
无论面试官是否是技术人员出身，我们一定要给出充分准备的回答，发音准确的技术名
称，不要有所保留，尽可能仔细地回答问题。一定要在面试前，准备本专业至少 20 个常见的
专业技术问题，能对答如流，可以变成自己的话说出来。当然，再完美的准备也会碰到不会
的问题，那么如何应对呢？
71. 面试官提出的某个技术，你不会。
第一，绝对不能就说“不会”两个字。太傻，太二，无法继续交流，典型直男癌。
第二，态度上正视差距，如实回答。“这个技术我确实不会。之前的项目没用到，只是用
了 xxx 技术。面试完后，我也想学习一下”。
这样，既说明了实际情况和自己的学习态度，也引向了你会的 xxx 技术，从而可能会小小
的带一波节奏。
72. 你对这个技术有一定的认知，但没有把握。
对策：可以告诉面试官去年项目不太忙的时候，我学习过几天，后来项目忙了就没继续
看。然后，简单说说对这个技术的理解。最后，问一下，我们公司是否在使用这个技术？我
也正想捡起来再学习一下。
73. 面试官提出尖锐的问题，质疑你的简历或者技术能力。
面试官：“我在你的简历中没有看到对我们有用的项目经验，你的技术能力也不符合我们
的要求。”
588
面试者：“可能是我的经历还是太浅。对咱们公司这块业务确实没涉及过。您这块还有什
么技术要求，我可以推荐我的朋友过来试试”。
当碰到直接质疑的情况，面试成功的概率就非常低了。但也不能紧张，天下公司这么多，
此处不留人，自有留我处。但要尽量多的跟面试官交流，获得更多的行业知识，为下一次面
试做准备。
74. 问到自己特别了解的技术
好吧，发挥吧，少年！还不眉飞色舞好好表现表现。
75. 十大非技术面试问题及策略
社会竞争很残酷、面试其实就是一场表演，企业永远喜欢可以随机应变、聪明的求职者。
而不喜欢看似老实、实则笨拙不懂变通的求职者。所以，大家也要按套路出牌，出面试官喜
欢的牌才能有更多的胜算。
面试官也知道求职者肯定是经过精心准备的表演，但是仍然会认可。如果你连面试都懒
得用心准备、你肯定也不会为了工作而用心。这是面试官内在的逻辑。
1.自我介绍
这个问题是面试的时候最常被问到的问题。很多人回答这些问题会陷入一个误区，以为
简单介绍一下自己的名字、多少岁、哪里工作过、什么大学什么专业、有什么爱好就好了。
如果这样回答，你的自我介绍只能算是 30 分。
589
“面试官最想听他想知道的内容”，换位思考一下，假如你是面试官最想知道什么？显然，
就是”应聘者能不能胜任现在的岗位”。所以，应聘者应该更多的从这个角度出发思考问题。
所以，我们一般建议应聘者在自我介绍中侧重于自己“实战经验”的介绍。比如：在 xxx 公
司从事过什么工作、做过什么项目、我为什么可以胜任贵公司的岗位。这些才是面试官最想
听到的内容。
好的自我介绍应该分如下几个部分：
a.实战经验描述
实战经验可以是在公司的工作经验、实习经验、甚至是参与大学老师的项目都可以。你
需要告诉面试官实战经验的公司名称、时间多长、做了什么项目、有什么收获。说到此处，
你这个问题就可以拿到 60 分了。
b.为什么来应聘贵公司
根据自己网上查到的该公司的基本信息，可以说一下对公司的了解情况：看好公司未来
发展前景、想进来以后多多学习。说到此处，你这个问题可以拿到 80 分。
c.我可以胜任贵公司这个岗位的原因
前面两点说完后。结合自己的实战经历和应聘公司的情况，
告诉面试官我可以胜任目前的岗位、并且有决心干好。说到此
处，你这个问题可以拿到 100 分。静等面试官欣赏的、色眯眯
590
的眼神吧。
2.你的优点是什么？
优缺点的描述是想看看应聘者对自己的了解程度。求职者关于优点的描述一定要跟工作
相关，并且有具体的案例描述你的优点。
面试官通常喜欢具备如下优点的程序猿：
76. 态度好
77. 技术实力强
78. 热爱技术、学习能力强
大家描述的自己的优点可以围绕这三点展开。可以参考：《公司喜欢什么样的程序猿》。
3.你的缺点是什么？
求职者面对这个问题一定要把握一个原则：“缺点不能
跟工作相关”。你不能说“我的缺点就是不喜欢技术、不喜
欢加班”，那你完蛋了。缺点尽量不跟工作相关。比如：我
觉得我的缺点是比较内向、比较宅。周末我可以一个人在
家闷头钻研技术、但是就是不想走出去跟别人去玩。这方面我觉得应该改一改。
缺点也不能说的太假。比如：我觉得我的缺点就是工作太拼命了，不注意身体。这么一
说，面试官立马就喷了。
4.对我们公司了解吗？
我一直强调，面试前一定要查询该公司相关的信息。所以，这个问题是必须要回答的。
如果面试官没问你这个问题。你也要在其他问题中说出你对他们公司的了解。
591
79. 为什么从上一家公司离职？
公司都希望稳定、有培养价值的员工。因此，都会特
别关注你的离职理由。离职理由尽量正能量、客观，绝对
不能表示对上一家公司和上级的不满。比如：我觉得上一
个公司太抠了，加班还没有加班费。好了，你这么负能量
的回答，等于判了自己死刑。哪个公司都是抠门的、IT 行
业加班普遍是没有加班费的。
80. 如何看待加班？
面试官问这个问题显然是他们公司经常加班的。如果你确实接受不了也可以说出来。但
是，对于刚入行的年轻人一定要了解，加班是非常正常的一件事。
回答这个问题，一定要客观的说。你说你喜欢加班，这有点太扯了。你可以说：“项目紧
的时候，加班也很正常。现在行业情况就是这样的，没有问题。而且，我还年轻，能扛的住”。
81. 如何看待出差？
出差在有的人眼里看是辛苦，在有的人眼里看是经历。有的年轻人就特喜欢出差，感觉
可以去不同的城市、有不同的体验。对于求职者来说，可以根据自己实际情况说出自己的真
实感受。如果你确实无法接受、也可以明确拒绝。
82. 你的职业规划是什么？
这个问题是想了解求职者的规划能力、对于自己是否有规划？求职者
可以根据自己的情况正常的说出自己的职业规划，不能太低人一等、也不
能好高骛远。
一般较好的回答如下：
“这三年，我还是想脚踏实地的钻研技术。希望通过三年的努力成为我们这个行业比较牛
592
的人。三年后，我想学着做管理。再用两年时间，一共五年，最终可以独当一面”。
三年钻研技术、显得你很踏实。五年进入管理，这是一个有心人的正常的晋升流程。
83. 你对跳槽怎么看？
公司非常不喜欢频繁跳槽的人，所以你对这个问题的回答一定要谨
慎对待。
经典回答如下：
“现在这个行业大家都很浮躁，跳槽频繁。但是，我并不喜欢频繁的换环境。我想，我只
要在一个公司扎扎实实做下去，不可能没有机会。做好了，薪水不可能比跳槽的低”。
84. 你还有什么问题要问我吗？
这是通常面试要结束的时候的问题。求职者一定不能说：“我没有问题”。一下子就把你搞
得很 low，最后一定要问一个问题问回去，即使面试官没有这个问题。结束时，也一定要问
个问题。
求职者也不能太过于急功近利的问：“今天我能面试上吗？你能给我多少钱？”。虽然你很
想知道，但这么一问，你的档次立马降低。通常的问题应该是跟工作相关。
技术人员可以这样问：
85. 今天我们聊到的某个技术，我想回去好好研究一下，您这里有什么资料吗？
86. XX 新技术，您怎么看他的发展？我想趁这几天时间宽裕，学习一下。
87. XXX 技术，我感觉您好像有比较深的研究。我也想学学，您能推荐些资料吗？
类似这样的问题，可以让你喜爱技术的特点，立马暴露的一览无余。本来面试 70 分的你，
立刻加到 80 分。而你，只是问了个问题而已，回答的竟然是面试官。这么好的无本生意，不
做是不是有点可惜？
593
5.面试后一定要总结
很多人面试后，就开始等公司的消息，焦躁不安，这绝对是错误的做法。面试后，大局
已定，战争已经打完了，还需要再纠结吗？我们应该做的事是为下一场面试做准备，立刻做
面试的总结，没有总结就没有进步。
必须总结如下内容：
88. 列出问了哪些问题？
89. 列出自己回答较好的问题
90. 列出自己回答交差的问题，并进行改进
心态上不要等待，”谋事在人，成事在天”，成了好，不成也无所谓，就当面试失败了。立
刻，投入紧张的复习和下一次面试中。
594
卓越班（保底年薪 18 万）
卓 越 班(保底年薪 18 万)
中国最高端的课程，没有之一
91. 大学生高端复合人才成长方案，保底年薪 18 万。
92. JAVA 专业，1000 课
93. Python 专业，500 课
94. 大数据专业，500 课
95. 人工智能专业，500 课
四个专业都要学，从零开始 2000 小时，成为高端人才，打下一生技术基础，不再是低端
码农。
96. 扫一扫，咨询详情：
595
百战小程序，扫描即学习
访问官网 [www.itbaizhan.cn](http://www.itbaizhan.cn)
596尚学堂Java面试题大全及其答案1.下面程序的运行结果是（B）（选择一项）
String str1=&quot;hello&quot;;
String str2=new String(&quot;hello&quot;);
System.out.println(str1==str2);A	true
B.	false
C.	hello
D.	he
分析：str1没有使用new关键字，在堆中没有开辟空间，其值”hello”在常量池中，str2使用new关键字创建了一个对象，在堆中开辟了空间，”==”比较的是对象的引用，即内存地址，所以str1与str2两个对象的内存地址是不相同的2.下列说法正确的有（C）（选择一项）
A	class中的construtor不可省略
B.	construtor与class同名，但方法不能与class同外
C.	construtor在一个对象被new时执行
D.	一个class只能定义一个construtor
分析：A：如果class中的construtor省略不写，系统会默认提供一个无参构造
B：方法名可以与类名同名，只是不符合命名规范
D：一个class中可以定义N多个construtor，这些construtor构成构造方法的重载
3.下面程序的运行结果（B）（选择一项）
public static void main(String\[] args) &#123;
Thread t=new Thread()&#123;
public void run()&#123;
pong();
&#125;
&#125;;
t.run();
System.out.println(&quot;ping&quot;);
&#125;
static void pong()&#123;
System.out.println(&quot;pong&quot;);
&#125;A	pingpong
B.	pongping
C.	pingpong和pongping都有可能
D.	都不输出
分析：启动线程需要调用start()方法，而t.run()方法，则是使用对象名.方法名()并没有启动线程，所以程序从上到下依次执行，先执行run()中的静态方法pong()输出pong然执行打印输出ping4.下列说法正确的有（C）（选择一项）
A.	LinkedList继承自List
B.	AbstractSet继承自Set
C.	HashSet继承自AbstractSet
D.	TreeMap继承自HashMap
分析：A：LinkedList实现List接口
B：AbstractSet实现Set接口
D：TreeMap继承AbstractMap
5.下面哪个流类属于面向字符的输入流（D）选择一项）
A	BufferedWriter
B.	FileInputStream
C.	ObjectInputStream
D.	InputStreamReader
分析：A：字符输出的缓冲流
B：字节输入流
C：对象输入流
6.Java中接口的修饰符可以为（D）（选择一项）
A	private
B.	protected
C.	final
D.	abstract
分析：接口中的访问权限修饰符只可以是public或default
接口中的所有的方法必须要实现类实现，所以不能使用final
接口中所有的方法默认都是abstract的，所以接口可以使用abstract修饰，但通常abstract可以省略不写
7.下列哪种异常是检查型异常，需要在编写程序时声明（C）
A	NullPointerException
B.	ClassCastException
C.	FileNotFoundException
D.	IndexOutOfBoundsException
分析：NullPointerException空指针异常
ClassCastException类型转换异常
IndexOutOfBoundsException索引超出边界的异常\
以上这些异常都是程序在运行时发生的异常，所以不需要在编写程序时声明
8.关于Java编译，下面哪一个正确（B）（选择一项）
A	Java程序经编译后产生machine code
B.	Java程序经编译后会生产byte code
C.	Java程序经编译后会产生DLL
D.	以上都不正确
分析： Java是解释型语言，编译出来的是字节码； 因此A不正确，C是C/C++语言编译动态链接库的文件为.DLL； 正确答案为B
9.给定以下代码，程序将输出 （B）（选择一项）
class A &#123;
public A()&#123;
System.out.println(&quot;A&quot;);
&#125;
&#125;
class B extends A&#123;
public B()&#123;
System.out.println(&quot;B&quot;);
&#125;
public static void main(String\[] args) &#123;
B b=new B();
&#125;
&#125;A	不能通过编译
B.	通过编译，输出AB
C.	通过编译，输出B
D.	通过编译，输出A
分析：在继承关系下，创建子类对象，先执行父类的构造方法，再执行子类的构造方法。
10.下面哪些是Thread类的方法（AD）（选择两项）
A.	start()
B.	run()
C.	exit()
D.	getPriority()
分析： run()方法是Runnable接口中的方法
exit()是System类中的方法
11.下列属于关系型数据库的是（AB）（选择两项）
A.	Oracle
B.	MySql
C.	IMS
D.	MongoDB
分析： IMS 是IP Mulitimedia Subsystem的缩写，是IP多媒体系统
MongoDB分布式文档存储数据库
12.下列关于关键字的使用说法错误的是（D）（选择一项）
A.	abstract不能与final并列修饰同一个类
B.	abstract类中可以有private的成员
C.	abstract方法必须在abstract类中
D.	static方法能处理非static的属性
分析：因为static得方法在装载class得时候首先完成，比 构造方法早，此时非static得属性和方法还没有完成初始化所以不能调用。
13.Java语言中，String类中的indexOf()方法返回值的类型是（C）
A	int16
B.	int32
C.	int
D.	long
分析：14.给定以下代码，程序的运行结果是 （ B）（选择一项）
public class Example &#123;
String str=new String(&quot;good&quot;);
char \[] ch=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
public static void main(String\[] args) &#123;
Example ex=new Example();
ex.change(ex.str, ex.ch);
System.out.print(ex.str+&quot;and&quot;);
System.out.print(ex.ch);
&#125;
public void change(String  str,char ch\[])&#123;
str=&quot;test ok&quot;;
ch\[0]=&#39;g&#39;;
&#125;
&#125;A	goodandabc
B.	goodandgbc
C.	test okandabc
D.	test okandgbc
分析：在方法调用时，在change方法中对str的值进行修改，是将str指向了常量江池中的”test ok”，而主方法中的ex.str仍然指向的是常量池中的”good”。字符型数组在方法调用时，将主方法中ex.ch的引用传递给change方法中的ch，指向是堆中的同一堆空间，所以修改ch\[0]的时候,ex.ch可以看到相同的修改后的结果。
15.要从文件”file.dat”文件中读出第10个字节到变量c中，下列哪个正确（A）（选择一项）
A.	FileInputStream in=new FileInputStream(&quot;file.dat&quot;);
in.skip(9);
int c=in.read();
B.	FileInputStream in=new FileInputStream(&quot;file.dat&quot;);
in.skip(10);
int c=in.read();
C.	FileInputStream in=new FileInputStream(&quot;file.dat&quot;);
int c=in.read();
D.	RandomAccessFile in=new RandomAccessFile(&quot;file.dat&quot;);
in.skip(7);
int c=in.readByte();
分析： skip(long n)该方法中的n指的是要跳过的字节数
16.下列哪些语句关于内存回收的说法是正确的（B）（选择一项）
A.	程序员必须创建一个线程来释放内存
B.	内存回收程序员负责释放无用内存
C.	内存回收程序允许程序员直接释放内存
D.	内存回收程序可以在指定的时间释放内存对象
分析： A. 程序员不需要创建线程来释放内存.
C. 也不允许程序员直接释放内存.
D. 不一定在什么时刻执行垃圾回收.17.执行下列代码后，哪个结论是正确的（BD）（选择两项）
String\[] s=new String\[10];A.	s\[10]为””
B.	s\[9]为null
C.	s\[0]为未定义
D.	s.length为10
分析： 引用数据类型的默认值均为null
s.length数组的长度
18.选出合理的标识符（AC）（选择两项）
A.	\_sysl\_111
B.	2 mail
C.	`$change
D.	class
分析： 标识符的命令规范，可以包含字母、数字、下划线、$`，不能以数字开头，不能是Java关键字
19.下列哪个方法可用于创建一个可运行的类（A）（选择两项）
A.	public class X implements Runnable&#123;public void run() &#123;……&#125;&#125;
B.	public class X extends Thread&#123;public void run() &#123;……&#125;&#125;
C.	public class X extends Thread&#123;public int run() &#123;……&#125;&#125;
D.	public class X implements Runnable&#123;protected void run() &#123;……&#125;&#125;
分析： 继承Thread和实现Runable借口
20.下列说法正确的是（BCD）（选择多项）
A.	java.lang.Cloneable是类
B.	java.langRunnable是接口
C.	Double对象在java.lang包中
D.	Double a=1.0是正确的java语句
分析：java.lang.Cloneable是接口
21.定义一个类名为”MyClass.java”的类，并且该类可被一个工程中的所有类访问，那么该类的正确声明为（CD）（选择两项）
A.	private class MyClass extends Object
B.	class MyClass extends Object
C.	public class MyClass
D.	public class MyClass extends Object
分析： A 类的访问权限只能是public或default
B使用默认访问权限的类，只能在本包中访问22.面向对象的特征有哪些方面？请用生活中的例子来描述。
答:	面向对象的三大特征：封装、继承、多态
23.说明类java.lang.ThreadLocal的作用和原理。列举在哪些程序中见过ThreadLocal的使用？
作用：
要编写一个多线程安全(Thread-safe)的程序是困难的，为了让线程共享资源，必须小心地对共享资源进行同步，同步带来一定的效能延迟，而另一方面，在处理同步的时候，又要注意对象的锁定与释放，避免产生死结，种种因素都使得编写多线程程序变得困难。尝试从另一个角度来思考多线程共享资源的问题，既然共享资源这么困难，那么就干脆不要共享，何不为每个线程创造一个资源的复本。将每一个线程存取数据的行为加以隔离，实现的方法就是给予每个线程一个特定空间来保管该线程所独享的资源。
ThreadLocal的原理
ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单，在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。
24.说明内存泄漏和内存溢出的区别和联系，结合项目经验描述Java程序中如何检测？如何解决？
答：
内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
memory leak会最终会导致out of memory！
25.什么是Java的序列化，如何实现Java的序列化？列举在哪些程序中见过Java序列化？
答：Java中的序列化机制能够将一个实例对象（只序列化对象的属性值，而不会去序列化什么所谓的方法。）的状态信息写入到一个字节流中使其可以通过socket进行传输、或者持久化到存储数据库或文件系统中；然后在需要的时候通过字节流中的信息来重构一个相同的对象。一般而言，要使得一个类可以序列化，只需简单实现java.io.Serializable接口即可。
26.String和StringBuffer、StringBuilder的区别是什么？
答：
1、String类是不可变类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。
2、 StringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setChartAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String
3、JDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder
27.不通过构造函数也能创建对象吗？
答：Java创建对象的几种方式（重要）：
1、 用new语句创建对象，这是最常见的创建对象的方法。
2、 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
3、 调用对象的clone()方法。
4、运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。
(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。
28.对象在虚拟机的大小中可不可以用size of取出。
答：可以
29.乐观锁与悲观锁
答：
悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write\_condition机制的其实都是提供的乐观锁。
两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。30.描述Java权限修饰符(public、private、protected、默认)的不同
答：
访问控制	public	protected	默认	private
同一类中成员	是	是	是	是
同一包中其它类	是	是	是
不同包中的子类	是	是
不同包中对非子类	是类的访问权限只有两种
public 公共的   可被同一项目中所有的类访问。 (必须与文件名同名)
default 默认的  可被同一个包中的类访问。
成员（成员变量或成员方法）访问权限共有四种：
public 公共的  可以被项目中所有的类访问。(项目可见性)
protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问。（子类可见性）
default 默认的 被这个类本身访问；被同一个包中的类访问。（包可见性）
private 私有的只能被这个类本身访问。（类可见性）
31.在Java中怎么实现多线程?描述线程状态的变化过程。
答：当多个线程访问同一个数据时，容易出现线程安全问题，需要某种方式来确保资源在某一时刻只被一个线程使用。需要让线程同步，保证数据安全
线程同步的实现方案：同步代码块和同步方法，均需要使用synchronized关键字
同步代码块：public void makeWithdrawal(int amt) &#123;
synchronized (acct) &#123;	&#125;
&#125;
同步方法：public synchronized void makeWithdrawal(int amt) &#123;	&#125;
线程同步的好处：解决了线程安全问题
线程同步的缺点：性能下降，可能会带来死锁
32.简述Java内存管理机制，以及垃圾回收的原理和使用过Java调优工具
内存管理的职责为分配内存，回收内存。 没有自动内存管理的语言/平台容易发生错误。
典型的问题包括悬挂指针问题，一个指针引用了一个已经被回收的内存地址，导致程序的运行完全不可知。
另一个典型问题为内存泄露，内存已经分配，但是已经没有了指向该内存的指针，导致内存泄露。 程序员要花费大量时间在调试该类问题上。
33.描述JVM加载class文件的原理机制
JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。
　类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。　　　　　　从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。
34.请列出Java常见的开源数据连接池，并对参数做出简单的说明
答：在Java中开源的常用的数据库连接池有以下几种 ：
（1）DBCP
DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池.DBCP可以直接的在应用程序中使用，Tomcat的数据源使用的就是DBCP。
（2）c3p0
c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。
（3）Druid
阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个SQL Parser。支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。35.请写出常用的linux指令不低于10个，请写出linux tomcat启动。
答：linux指令
arch 显示机器的处理器架构(1)
uname -m 显示机器的处理器架构(2)
shutdown -h now 关闭系统(1)
shutdown -r now 重启(1)
cd /home 进入 &#39;/ home&#39; 目录&#39;
cd .. 返回上一级目录
cd ../.. 返回上两级目录
mkdir dir1 创建一个叫做 &#39;dir1&#39; 的目录&#39;
mkdir dir1 dir2 同时创建两个目录
find / -name file1 从 &#39;/&#39; 开始进入根文件系统搜索文件和目录
find / -user user1 搜索属于用户 &#39;user1&#39; 的文件和目录
linuxtomcat启动
进入tomcat下的bin目录执行 ./catalina.sh start直接启动即可，然后使用tail -f /usr/local/tomcat6/logs/catalina.out查看tomcat启动日志。
36.请写出您熟悉的几种设计模式，并做简单介绍。
答：
工厂设计模式：程序在接口和子类之间加入了一个过渡端，通过此过渡端可以动态取得实现了共同接口的子类实例化对象。
代理设计模式：指由一个代理主题来操作真实主题，真实主题执行具体的业务操作，而代理主题负责其他相关业务的处理。比如生活中的通过代理访问网络，客户通过网络代理连接网络（具体业务），由代理服务器完成用户权限和访问限制等与上网相关的其他操作（相关业务）
适配器模式：如果一个类要实现一个具有很多抽象方法的接口，但是本身只需要实现接口中的部分方法便可以达成目的，所以此时就需要一个中间的过渡类，但此过渡类又不希望直接使用，所以将此类定义为抽象类最为合适，再让以后的子类直接继承该抽象类便可选择性的覆写所需要的方法，而此抽象类便是适配器类。
37.匿名内部类可不可以继承或实现接口。为什么？
答：匿名内部类是没有名字的内部类,不能继承其它类,但一个内部类可以作为一个接口,由另一个内部类实现.
1、由于匿名内部类没有名字，所以它没有构造函数。因为没有构造函数，所以它必须完全借用父类的构造函数来实例化，换言之：匿名内部类完全把创建对象的任务交给了父类去完成。
2、在匿名内部类里创建新的方法没有太大意义，但它可以通过覆盖父类的方法达到神奇效果，如上例所示。这是多态性的体现。
3、因为匿名内部类没有名字，所以无法进行向下的强制类型转换，持有对一个匿名内部类对象引用的变量类型一定是它的直接或间接父类类型。
38.Java的HashMap和Hashtable有什么区别HashSet和HashMap有什么区别？使用这些结构保存的数需要重载的方法是哪些？
答：
HashMap与Hashtable实现原理相同，功能相同，底层都是哈希表结构，查询速度快，在很多情况下可以互用
两者的主要区别如下
1、Hashtable是早期JDK提供的接口，HashMap是新版JDK提供的接口
2、Hashtable继承Dictionary类，HashMap实现Map接口
3、Hashtable线程安全，HashMap线程非安全
4、Hashtable不允许null值，HashMap允许null值
HashSet与HashMap的区别
1、HashSet底层是采用HashMap实现的。HashSet 的实现比较简单，HashSet 的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。
2、HashMap的key就是放进HashSet中对象，value是Object类型的。
3、当调用HashSet的add方法时，实际上是向HashMap中增加了一行(key-value对)，该行的key就是向HashSet增加的那个对象，该行的value就是一个Object类型的常量
39.写出你用过的设计模式，并至少写出2种模式的类图或关键代码。
工厂设计模式：
思路说明：由一个工厂类根据传入的参数（一般是字符串参数），动态决定应该创建哪一个产品子类（这些产品子类继承自同一个父类或接口）的实例，并以父类形式返回
优点：客户端不负责对象的创建，而是由专门的工厂类完成；客户端只负责对象的调用，实现了创建和调用的分离，降低了客户端代码的难度；
缺点：如果增加和减少产品子类，需要修改简单工厂类，违背了开闭原则；如果产品子类过多，会导致工厂类非常的庞大，违反了高内聚原则，不利于后期维护。
public class SimpleFactory &#123;
public static Product createProduct(String pname)&#123;
Product product=null;
if(&quot;p1&quot;.equals(pname))&#123;
product = new Product1();
&#125;else if(&quot;p2&quot;.equals(pname))&#123;
product = new Product2();
&#125;else if(&quot;pn&quot;.equals(pname))&#123;
product = new ProductN();
&#125;
return product;
&#125;
&#125;单例模式
/\*\**   饿汉式的单例模式
*   在类加载的时候创建单例实例，而不是等到第一次请求实例的时候的时候创建
*   1、私有 的无参数构造方法Singleton()，避免外部创建实例
*   2、私有静态属性instance
*   3、公有静态方法getInstance()
*/
public class Singleton &#123;
private static Singleton instance = new Singleton();
private Singleton()&#123;	&#125;
public static Singleton getInstance()&#123;
return instance;
&#125;
&#125;
/*\*
*   懒汉式的单例模式
*在类加载的时候不创建单例实例，只有在第一次请求实例的时候的时候创建
/
public class Singleton &#123;
private static Singleton instance;
private Singleton()&#123;	&#125;
/*
*   多线程情况的单例模式，避免创建多个对象
\*/
public static Singleton getInstance()&#123;
if(instance ==null)&#123;//避免每次加锁，只有第一次没有创建对象时才加锁
synchronized(Singleton.class)&#123;//加锁，只允许一个线程进入
if(instance==null)&#123; //只创建一次对象
instance = new Singleton();
&#125;
&#125;
&#125;
return instance;
&#125;
&#125;40.请写出多线程代码使用Thread或者Runnable，并说出两种的区别。
方式1：继承Java.lang.Thread类，并覆盖run() 方法。优势：编写简单；劣势：无法继承其它父类
public class ThreadDemo1 &#123;
public static void main(String args\[]) &#123;
MyThread1 t = new MyThread1();
t.start();
while (true) &#123;
System.out.println(&quot;兔子领先了，别骄傲&quot;);
&#125;
&#125;
&#125;
class MyThread1 extends Thread &#123;
public void run() &#123;
while (true) &#123;
System.out.println(&quot;乌龟领先了，加油&quot;);
&#125;
&#125;
&#125;方式2：实现Java.lang.Runnable接口，并实现run()方法。优势：可继承其它类，多线程可共享同一个Thread对象；劣势：编程方式稍微复杂，如需访问当前线程，需调用Thread.currentThread()方法
public class ThreadDemo2 &#123;
public static void main(String args\[]) &#123;
MyThread2 mt = new MyThread2();
Thread t = new Thread(mt);
t.start();
while (true) &#123;
System.out.println(&quot;兔子领先了，加油&quot;);
&#125;
&#125;
&#125;
class MyThread2 implements Runnable &#123;
public void run() &#123;
while (true) &#123;
System.out.println(&quot;乌龟超过了，再接再厉&quot;);
&#125;
&#125;
&#125;41.写一排序算法，输入10个数字，以逗号分开，可根据参数选择升序或者降序排序，须注明是何种排序算法。
package cn.bjsxt.demo;import java.util.Scanner;public class SortDemo &#123;
/\*\*
\* 给定的字符串使用，号分隔
\* @param strNumber
\* @return
*/
public static String \[] split(String strNumber)&#123;
String \[] strSplit=strNumber.split(&quot;,&quot;);
return strSplit;
&#125;
/*\*
\* 将String类型的数组转换成int类型的数组
\* @param strSplit
\* @return
*/
public static int \[] getInt(String \[] strSplit)&#123;
int arr\[]=new int\[strSplit.length];
for (int i = 0; i &lt; strSplit.length; i++) &#123;
arr\[i]=Integer.parseInt(strSplit\[i]);
&#125;
return arr;
&#125;
/*\*
\* 冒泡排序
\* @param arr
*/
public static void sort(int \[] arr)&#123;
for (int i = 0; i &lt; arr.length-1; i++) &#123;
for (int j = 0; j &lt; arr.length-1-i; j++) &#123;
if (arr\[j]&gt;arr\[j+1]) &#123;
change(arr,j,j+1);
&#125;
&#125;
&#125;
&#125;
/*\*
\* 两数交换的方法
\* @param arr 数组
\* @param x 数组中元素的下标
\* @param y 数组中元素的下标
*/
public static void change(int \[] arr,int x,int y)&#123;
int temp=arr\[x];
arr\[x]=arr\[y];
arr\[y]=temp;
&#125;
/*\*
\* 测试类
\* @param args
\*/
public static void main(String\[] args) &#123;
Scanner input=new Scanner(System.in);
System.out.println(&quot;请输入一个数字串，每个数字以逗号分隔&quot;);
String str=input.next();	//调用方法
    String [] s=split(str);//使用逗号分隔
    int [] arr=getInt(s);//调有获得整型数组的方法
    sort(arr);//调用排序的方法
    for (int i : arr) &#123;
        System.out.print(i+&quot;\t&quot;);
    &#125;
&#125;&#125;42.判断字符串是否是这样的组成的，第一个字母，后面可以是字母、数字、下划线、总长度为5-20。
package cn.bjsxt.demo;import java.util.Scanner;public class StringDemo &#123;
public static void main(String\[] args) &#123;
Scanner input=new Scanner(System.in);
System.out.println(&quot;请输入一个字符串，第一个字符必须是字母：&quot;);
String str=input.next();
if (str.length()&lt;5||str.length()&gt;20) &#123;
System.out.println(&quot;对不起，字符串的长度必须在5-20之间!&quot;);
&#125;else&#123;
char \[]ch=str.toCharArray();
if (Character.isLetter(ch\[0])) &#123;//判断第一个字符是否是字母
for (int i = 1; i &lt; ch.length; i++) &#123;
if (!Character.isLetterOrDigit(ch\[i])&amp;\&amp;ch\[i]!=&#39;\_&#39;) &#123;
System.out.println(&quot;字符串不符合要求&quot;);
break;
&#125;
&#125;
&#125;
&#125;
&#125;
&#125;43.在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方。
答:
在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap\&lt;K, V&gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说HashMap\&lt;K, V&gt;可以理解为HashMap\&lt;Object, Object&gt;，很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1, “Java”)；”，但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型。(2) 引用数据类型分为两类：系统提供的引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。
44.在多线程编程里，wait方法的调用方式是怎样的？
答:
wait方法是线程通信的方法之一，必须用在 synchronized方法或者synchronized代码块中，否则会抛出异常，这就涉及到一个“锁”的概念，而wait方法必须使用上锁的对象来调用，从而持有该对象的锁进入线程等待状态，直到使用该上锁的对象调用notify或者notifyAll方法来唤醒之前进入等待的线程，以释放持有的锁。
45.Java出现OutOf MemoryError（OOM 错误)的原因有哪些？出现OOM错误后，怎么解决？
答:
OutOf MemoryError这种错误可以细分为多种不同的错误，每种错误都有自身的原因和解决办法，如下所示：
java.lang.OutOfMemoryError: Java heap space
错误原因：此OOM是由于JVM中heap的最大值不满足需要。
解决方法：1) 调高heap的最大值，即-Xmx的值调大。2) 如果你的程序存在内存泄漏，一味的增加heap空间也只是推迟该错误出现的时间而已，所以要检查程序是否存在内存泄漏。
java.lang.OutOfMemoryError: GC overhead limit exceeded
错误原因：此OOM是由于JVM在GC时，对象过多，导致内存溢出，建议调整GC的策略，在一定比例下开始GC而不要使用默认的策略，或者将新代和老代设置合适的大小，需要进行微调存活率。
解决方法：改变GC策略，在老代80%时就是开始GC，并且将-XX\:SurvivorRatio（-XX\:SurvivorRatio=8）和-XX\:NewRatio（-XX\:NewRatio=4）设置的更合理。
java.lang.OutOfMemoryError: Java perm space
错误原因：此OOM是由于JVM中perm的最大值不满足需要。
解决方法：调高heap的最大值，即-XX\:MaxPermSize的值调大。
另外，注意一点，Perm一般是在JVM启动时加载类进来，如果是JVM运行较长一段时间而不是刚启动后溢出的话，很有可能是由于运行时有类被动态加载进来，此时建议用CMS策略中的类卸载配置。如：-XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled。
java.lang.OutOfMemoryError: unable to create new native thread
错误原因：当JVM向OS请求创建一个新线程时，而OS却由于内存不足无法创建新的native线程。
解决方法：如果JVM内存调的过大或者可利用率小于20%，可以建议将heap及perm的最大值下调，并将线程栈调小，即-Xss调小，如：-Xss128k。
java.lang.OutOfMemoryError: Requested array size exceeds VM limit
错误原因：此类信息表明应用程序（或者被应用程序调用的APIs）试图分配一个大于堆大小的数组。例如，如果应用程序new一个数组对象，大小为512M，但是最大堆大小为256M，因此OutOfMemoryError会抛出，因为数组的大小超过虚拟机的限制。
解决方法：1) 首先检查heap的-Xmx是不是设置的过小。2) 如果heap的-Xmx已经足够大，那么请检查应用程序是不是存在bug，例如：应用程序可能在计算数组的大小时，存在算法错误，导致数组的size很大，从而导致巨大的数组被分配。
java.lang.OutOfMemoryError: request \&lt;size&gt; bytes for \&lt;reason&gt;. Out of swap space
错误原因：抛出这类错误，是由于从native堆中分配内存失败，并且堆内存可能接近耗尽。这类错误可能跟应用程序没有关系，例如下面两种原因也会导致错误的发生：1) 操作系统配置了较小的交换区。2)系统的另外一个进程正在消耗所有的内存。
解决办法：1) 检查os的swap是不是没有设置或者设置的过小。2) 检查是否有其他进程在消耗大量的内存，从而导致当前的JVM内存不够分配。
注意：虽然有时\&lt;reason&gt;部分显示导致OOM的原因，但大多数情况下，\&lt;reason&gt;显示的是提示分配失败的源模块的名称，所以有必要查看日志文件，如crash时的hs文件。
46.简述Java中如何实现多态
答:
实现多态有三个前提条件：
1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。
2、子类重写父类的方法。（多态下会调用子类重写后的方法）。
3、父类引用变量指向子类对象。（涉及子类到父类的类型转换）。
最后使用父类的引用变量调用子类重写的方法即可实现多态。
47.简述Tomcat，Apache，JBoss的区别
Apache：是C语言实现的，专门用来提供HTTP服务。支持静态页（HTML），不支持动态请求如：CGI、Servlet/JSP、PHP、ASP等。
Tomcat：是Java开发的一个符合JavaEE的Servlet规范的JSP服务器（Servlet容器），是 Apache 的扩展。用于解析jsp，servlet的Servlet容器，是高效，轻量级的容器，但是不支持EJB，只能用于java应用。
Jboss：应用服务器，运行EJB的J2EE应用服务器，遵循J2EE规范，能够提供更多平台的支持和更多集成功能，如数据库连接，JCA等；其对servlet的支持是通过集成其他servlet容器来实现的，如tomcat和jetty。
48.已排好序的数组A，一般来说可用二分查找可以很快找到，现有一特殊数组A，它是循环递增的，如a\[]=&#123;17, 19 ,20, 25, 1, 4, 7, 9&#125;，在这样的数组中找一元素，看看是否存在。请写出你的算法，必要时可写伪代码，并分析其空间，时间复杂度。
思路说明：循环递增数组有这么一个性质：以数组中间元素将循环递增数组划分为两部分，则一部分为一个严格递增数组，而另一部分为一个更小的循环递增数组。当中间元素大于首元素时，前半部分为严格递增数组，后半部分为循环递增数组；当中间元素小于首元素时，前半部分为循环递增数组；后半部分为严格递增数组。
记要检索的元素为e，数组的首元素为a\[low]，中间元素为a\[mid]，末尾元素为a\[high]。则当e等于a\[mid] 时，直接返回mid的值即可；当e不等于a\[mid] 时:1.  a\[mid] &gt; a\[low]，即数组前半部分为严格递增数组，后半部分为循环递增数组时，若key小于a\[mid]并且不小于a\[low]时，则key落在数组前半部分；否则，key落在数组后半部分。
2.  a\[mid] &lt; a\[high]，即数组前半部分为循环递增数组，后半部分为严格递增数组时，若key大于a\[mid]并且不大于a\[high]时，则key落在数组后半部分；否则，key落在数组前半部分。
这种方式的时间复杂度为：O(log(n))，空间复杂度为O(1)。
public class TestBinarySearch &#123;
public static void main(String\[] args) &#123;
// 定义数组
int\[] a = &#123; 17, 19, 20, 21, 25, 1, 4, 7 &#125;;
// 调用改进后的二分查找法求索引
int pos = search(a, 7);
System.out.println(&quot;要查找的元素的索引为：&quot; + pos);
&#125;/\*\* 改进后的二分查找法：e为要查找的元素 \*/
public static int search(int\[] a, int e) &#123;
int low = 0;
int high = a.length - 1;
int mid = 0;
int pos = -1; // 返回-1，表示查找失败
// 如果low &lt; high，说明循环查找结束，直接返回-1;否则循环查找
while (low &lt;= high) &#123;
// mid为中间值索引
mid = (low + high) / 2;
// 如果中间值刚好是e，则查找成功，终止查找，e的索引为mid
if (a\[mid] == e) &#123;
pos = mid;
break;
&#125;
// 如果a\[low] &lt;= a\[mid]，说明原数组的前半部分是严格递增的，后半部分是一个更小的循环递增数组
if (a\[low] &lt;= a\[mid]) &#123;
// 如果要查找的元素e小于a\[mid]并且不小于a\[low]时，则说明e落在数组前半部分
if (a\[low] &lt;= e &amp;&amp; e &lt; a\[mid]) &#123;
high = mid - 1;
&#125; else &#123;// 否则的话，需要在数组的后半部分继续查找
low = mid + 1;
&#125;
&#125; else &#123;// 否则，后半部分是严格递增的，前半部分是一个更小的循环递增数组
// 如果要查找的元素e大于a\[mid]并且不大于a\[high]时，则说明e落在数组后半部分
if (a\[mid] &lt; e &amp;&amp; e &lt;= a\[high]) &#123;
low = mid + 1;
&#125; else &#123;// 否则的话，需要在数组的前半部分继续查找
high = mid - 1;
&#125;
&#125;
&#125;
return pos;
&#125;
&#125;49.请编写一个完整的程序，实现如下功能：从键盘输入数字n，程序自动计算n!并输出。（注1：n！=1*2*3...\*n, 注2：请使用递归实现）
思路说明：因为n! = (n-1)! \* n，所以要求n!首先要求出(n-1)!，而(n-1)! = (n-1-1)! \* (n-1)，以此类推，直到n = 1为止。
import java.util.Scanner;
public class TestFactorial &#123;
public static void main(String\[] args) &#123;
System.out.print(&quot;请输入一个整数：&quot;);
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
System.out.println(n + &quot;的阶乘是：&quot; + factorial(n));
&#125;
/\**求阶乘的方法*/
public static int factorial(int n) &#123;
if(n == 1)&#123;
return 1;
&#125;
return factorial(n - 1) \* n;
&#125;
&#125;
50.新建一个流对象，下面那个选项的代码是错误的？（B）
A.	new BufferedWriter(new FileWriter(“a.txt”));
B.	new BufferedReader (new FileInputStream(“a.dat”));
C.	new GZIPOutputStream(new FileOutputStream(“a.zip”));
D.	new ObjectInputStream(new FileInputStream(“a.dat”));
分析：
BufferedReader类的参数只能是Reader类型的，不能是InputStream类型。
51.以下对继承的描述锚误的是 (A)
A.	Java中的继承允许一个子类继承多个父类
B.	父类更具有通用性，子类更具体
C.	Java中的继承存在着传递性
D.	当实例化子类时会递归调用父类中的构造方法
分析：
Java是单继承的，一个类只能继承一个父类。52.列出Java中的集合类层次结构？
答:
Java中集合主要分为两种：Collection和Map。Collection是List和Set接口的父接口；ArrayList和LinkedList是List的实现类；HashSet和TreeSet是Set的实现类；LinkedHashSet是HashSet的子类。HashMap和TreeMap是Map的实现类；LinkedHashMap是HashMap的子类。
图中：虚线框中为接口，实线框中为类。53.Java 中 Math.random（）/Math.random（）值为？
答:
如果除数与被除数均不为0.0的话，则取值范围为\[0, +∞]。+∞在Java中显示的结果为Infinity。
如果除数与被除数均为0.0的话，则运行结果为NaN（Not a Number的简写），计算错误。
54.Java中，如果Manager是Employee的子类，那么Pair\&lt;Manager&gt;是Pair\&lt;Employee&gt;的子类吗？
答:
不是，两者没有任何关联。
55.请用递归的方法计算斐波那契数列的同项F（n），已知F0=0,F1=1,F(n)=F(n-1)+F(n-2)(n&gt;=2,n∈N\*).
思路说明：斐波那契数列的排列是：0，1，1，2，3，5，8，13，21，34，55，89，144……，特别指出的是0不是第一项而是第0项；因为F(n)=F(n-1)+F(n-2)，所以要求F(n)首先要求出F(n-1)和F(n-2)，而F(n-1)=F(n-1-1)+F(n-1-2)，以此类推，直到,F(2)=F(1)+F(0)为止，已知F(1) = 1，F(0) = 0。
import java.util.Scanner;
public class TestFibo &#123;
public static void main(String\[] args) &#123;
System.out.print(&quot;请输要求斐波那契数列的第几项：&quot;);
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
System.out.println(&quot;斐波那契数列的第&quot;+ n + &quot;是：&quot; + fibo(n));
&#125;
public static int fibo(int n) &#123;
if(n == 0)&#123;
return 0;
&#125; else if(n == 1)&#123;
return 1;
&#125;
return fibo(n -1) + fibo(n - 2);
&#125;
&#125;56.现在有整数数组&#123;11,66,22,0,55,32&#125;，请任意选择一种排序算法，用Java程序实现
冒泡思路说明：
(1) 最开始将数组看做一个无序数列(个数是数组的长度)与一个有序数列(0个)的组合；
(2) 每一趟比较完后, 找到了无序数列的最大值, 将其放到有序数列中(有序数列个数+1)；
(3) N个数, 比较N-1趟；
(4) 每一趟挨个进行比较：从数组的第一个元素开始, 到无序数列的最后一个为止；
(5) 如果前边一个大于后边一个, 那么交换位置；
(6) 每趟比较的次数与趟数有关；
(7) 根据每趟比较是否发生了交换判断数据是否已经有序，从而进行优化。
public class TestSort &#123;
public static void main(String\[] args) &#123;
int\[] arr = &#123;11, 66, 22, 0, 55, 32&#125;;
// 调用排序方法
sort(arr);
// 输出排除后的数组
for (int num : arr) &#123;
System.out.print(num + &quot;\t&quot;);
&#125;
&#125;public static void sort(int[] arr) &#123;
    // 定义标记
    boolean flag = false;
    int temp;
    // 排序
    // 外层循环控制的是比较的趟数
    for (int i = 0; i &lt; arr.length - 1; i++) &#123;
        // 每一趟比较之前初始化, 否则会保留上一堂比较的结果
        flag = false;
        // 内层循环控制的是每趟比较的次数
        for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;
            // 挨个进行比较: 从数组的第一个元素开始, 到无序数列的最后一个
            if (arr[j] &gt; arr[j + 1]) &#123;
                // 交换
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                //如果发生交换，改变flag的值
                flag = true;
            &#125;
        &#125;
        if (!flag) &#123;
            break;
        &#125;
    &#125;
&#125;&#125;
57.请根据注释，编码实现下面类的方法
// 这个类用于存取一组权限，每个权限用非负整数表示的.这组枳限存储在
// righiString属性中。如果权限N权限存在，rightString第N个字符为“1”,否则， 为空格。
class RightStore &#123;
public String righString = &quot;&quot;;// 如果传入的权限right存在，该方法返回true.否期，为false.,
// right为传入的权限的整数值.
public boolean getRight(int right) &#123;	return true;
&#125;// 该方法存储或消除传入的权限.如果value为true,存储传入的权限,
// 否则淸除该权限.
// right为传入的权限的整数值.
public void setRight(int right, boolean value) &#123;
&#125;&#125;思路说明：我们首先要读懂这道题的意思：righString这个字符串是用来存储一系列权限的，并且权限的取值只有两种：有和没有；在righString中使用字符‘1’表示有权限，字符空格‘ ’表示没有权限。举个例子：如果righString的长度为3，第一位表示对订单系统是否有权限，第二位表示对人员管理系统是否有权限，第三位表示对库存系统是否有权限。而方法中的int right参数则表示的是字符串的第几位。
上边这些搞明白之后，方法的编写就简单多了。
public class RightStore &#123;
public String righString = &quot;&quot;;public boolean getRight(int right) &#123;
    //先求得第right个字符
    char ch = righString.charAt(right - 1);
    //如果ch为&#39;1&#39;，返回true，否则返回false
    return ch == &#39;1&#39;;
&#125;public void setRight(int right, boolean value) &#123;
    //如果value为true,存储传入的权限，否则消除权限（改为空格）
    righString.replace(righString.charAt(right - 1), value ? &#39;1&#39; : &#39; &#39;);
&#125;&#125;58.接口和抽象类的区别
答:
相同点：
(1) 抽象类和接口均包含抽象方法，类必须实现所有的抽象方法，否则是抽象类
(2) 抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现
59.两者的区别主要体现在两方面：语法方面和设计理念方面
(1) 语法方面的区别是比较低层次的，非本质的，主要表现在：
1、 接口中只能定义全局静态常量，不能定义变量。抽象类中可以定义常量和变量。
2、 接口中所有的方法都是全局抽象方法。抽象类中可以有0个、1个或多个，甚至全部都是抽象方法。
3、 抽象类中可以有构造方法，但不能用来实例化，而在子类实例化是执行，完成属于抽象类的初始化操作。接口中不能定义构造方法。
4、 一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用extends来继承抽象类，使用implements来实现接口。
(2) 二者的主要区别还在设计理念上，其决定了某些情况下到底使用抽象类还是接口。
1、 抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子类的相同代码，可以认为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。父类和子类之间必须存在“is-a”的关系，即父类和子类在概念本质上应该是相同的。
2、 接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定义的约定或者能力而已。接口定义了“做什么”，而实现类负责完成“怎么做”，体现了功能（规范）和实现分离的原则。接口和实现之间可以认为是一种“has-a的关系”。
60.同步代码块和同步方法有什么区别
答:
相同点：
同步方法就是在方法前加关键字synchronized，然后被同步的方法一次只能有一个线程进入，其他线程等待。而同步代码块则是在方法内部使用大括号使得一个代码块得到同步。同步代码块会有一个同步的“目标”，使得同步块更加灵活一些（同步代码块可以通过“目标”决定需要锁定的对象）。一般情况下，如果此“目标”为this，那么同步方法和同步代码块没有太大的区别。区别：
同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁。很明显，同步方法锁的范围比较大，而同步代码块范围要小点。一般同步的范围越大，性能就越差。所以一般需要加锁进行同步的时候，范围越小越好，这样性能更好。
61.静态内部类和内部类有什么区别
答:
静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。
静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。
非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。
实例化方式不同：
1\) 静态内部类：不依赖于外部类的实例，直接实例化内部类对象
2\) 非静态内部类：通过外部类的对象实例生成内部类对象
62.反射的概念与作用
答:
反射的概念：
反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。
反射机制是Java动态性的重要体现。我们可以通过反射机制在运行时加载编译期完全未知的类。通过反射机制，我们可以在运行时加载需要的类，从而动态的改变了程序结构，使我们的程序更加灵活、更加开放。
反射的作用：
通过反射可以使程序代码访问装载到JVM 中的类的内部信息1.  获取已装载类的属性信息2.  获取已装载类的方法3.  获取已装载类的构造方法信息
63.提供Java存取数据库能力的包是（A）
A	java.sql
B.	java.awt
C.	java.lang
D.	java.swing
分析：
java.awt和javax.swing两个包是图形用户界面编程所需要的包；java.lang包则提供了Java编程中用到的基础类。
64.下列运算符合法的是（AD）（多选）
A	&amp;&amp;
B.	&lt;&gt;
C.	if
D.	=
分析：
&amp;&amp;是逻辑运算符中的短路与；
&lt;&gt;表示不等于，但是Java中不能这么使用，应该是!=；
if不是运算符；
\=是赋值运算符。
65.执行如下程序代码，c的值打印出来是（C）
public class Test1 &#123;
public static void main(String\[] args) &#123;
int a = 0;
int c = 0;
do&#123;
\--c;
a = a - 1;
&#125; while (a &gt; 0);
System.out.println(c);
&#125;
&#125;A	0
B.	1
C.	-1
D.	死循环
分析：
do-while循环的特点是先执行后判断，所以代码先执行--c操作，得到c为-1，之后执行a=a-1的操作，得到a为-1，然后判断a是否大于0，判断条件不成立，退出循环，输出c为-1。
66.下列哪一种叙述是正确的（D）
A	abstract修饰符可修饰字段，方法和类
B.	抽象方法的body部分必须用一对大括号&#123;&#125;包住
C.	声明抽象方法，大括号可有可无
D.	声明抽象方法不可写出大括号
分析：
abstract只能修饰方法和类，不能修饰字段；
抽象方法不能有方法体，即没有&#123;&#125;；
同B。
67.下列语句正确的是（A）
A	形式参数可被视为local Variable
B.	形式参数可被所有的字段修饰符修饰
C.	形式参数为方法被调用时，真正被传递的参数
D.	形式参数不可以是对象
分析：
local Variable为局部变量，形参和局部变量一样都只有在方法内才会发生作用，也只能在方法中使用，不会在方法外可见；
对于形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误；
真正被传递的参数是实参；
形式参数可是基本数据类型也可以是引用类型（对象）。
68.下列哪种说法是正确的（D）
A	实例方法可直接调用超类的实例方法
B.	实例方法可直接调用超类的类方法
C.	实例方法可直接调用其他类的实例方法
D.	实例方法可直接调用本类的类方法
分析：
实例方法不可直接调用超类的私有实例方法；
实例方法不可直接调用超类的私有的类方法；
要看访问权限。
69.Java程序的种类有（BCD）(多选)
A	类 (Class)
B.	Applet
C.	Application
D.	Servlet
分析：
是Java中的类，不是程序；
内嵌于Web文件中，由浏览器来观看的Applet；
可独立运行的 Application；
服务器端的 Servlet。
70.下列说法正确的有（BCD）(多选)
A	环境变量可在编译source code时指定
B.	在編译程序时，所指定的环境变置不包括class path
C.	javac —次可同时编译数个Java 源文件
D.	javac.exe能指定编译结果要置于哪个目录（directory)
分析：
环境变量一般都是先配置好再编译源文件。
71.下列标识符不合法的有（ACD）(多选)
A	new
B.	\$Usdollars
C.	1234
D.	car.taxi
分析：
new是Java的关键字；
C. 数字不能开头；
D. 不能有“.”。
72.下列说法错误的有（BCD）(多选)
A	数组是—种对象
B.	数组属于一种原生类
C.	int number\[]=(31,23,33,43,35,63)
D.	数组的大小可以任意改变
分析：
B. Java中的原生类（即基本数据类型）有8种，但不包括数组；
C. 语法错误，应该“&#123;···&#125;”，而不是“(···)”；
D. 数组的长度一旦确定就不能修改。
73.不能用来修饰interface的有（ACD）(多选)
A	private
B.	public
C.	protected
D.	static
分析：
能够修饰interface的只有public、abstract以及默认的三种修饰符。
74.下列正确的有（ACD）(多选)
A	call by value不会改变实际参数的数值
B.	call by reference能改变实际参数的参考地址
C.	call by reference 不能改变实际参数的参考地址
D.	call by reference 能改变实际参数的内容
分析：
Java中参数的传递有两种，一种是按值传递（call by value：传递的是具体的值，如基础数据类型），另一种是按引用传递（call by reference：传递的是对象的引用，即对象的存储地址）。前者不能改变实参的数值，后者虽然不能改变实参的参考地址，但可以通过该地址访问地址中的内容从而实现内容的改变。
75.下列说法错误的有（ACD）(多选)
A	在类方法中可用this来调用本类的类办法
B.	在类方法中调用本类的类方法时可以直接调用
C.	在类方法中只能调用本类中的类方法
D.	在类方法中绝对不能调用实例方法
分析：
类方法是在类加载时被加载到方法区存储的，此时还没有创建对象，所以不能使用this或者super关键字；
C. 在类方法中还可以调用其他类的类方法；
D. 在类方法可以通过创建对象来调用实例方法。
76.下列说法错误的有（ABC）(多选)
A	Java面向对象语言容许单独的过栈与函数存在
B.	Java面向对象语言容许单独的方法存在
C.	Java语言中的方法属于类中的成员（member）
D.	Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同
分析：
B. Java不允许单独的方法，过程或函数存在，需要隶属于某一类中；
C. 静态方法属于类的成员，非静态方法属于对象的成员。
77.下列说法错误的有（BCD）(多选)
A	能被java.exe成功运行的java class文件必须有main()方法
B.	J2SDK就是Java API
C.	Appletviewer.exe可利用jar选项运行.jar文件
D.	能被Appletviewer成功运行的java class文件必须有main()方法
分析：
B. J2SDK是sun公司编程工具，API是指的应用程序编程接口；
C. Appletviewer.exe就是用来解释执行java applet应用程序的，一种执行HTML文件上的Java小程序类的Java浏览器；
D. 能被Appletviewer成功运行的java class文件可以没有main（）方法。
78.Java线程的几种状态
答:
线程是一个动态执行的过程，它有一个从产生到死亡的过程，共五种状态：
新建（new Thread）
当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
例如：Thread  t1=new Thread();
就绪（runnable）
线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();
运行（running）
线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。
死亡（dead）
当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。
自然终止：正常运行run()方法后终止
异常终止：调用stop()方法让一个线程终止运行
堵塞（blocked）
由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。
正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。
正在等待：调用wait()方法。（调用motify()方法回到就绪状态）
被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）
79.List，Set，Map各有什么特点
答:
List 接口存储一组不唯一，有序（插入顺序）的对象。
Set 接口存储一组唯一，无序的对象。
Map接口存储一组键值对象，提供key到value的映射。key无序，唯一。value不要求有序，允许重复。（如果只使用key存储，而不使用value，那就是Set）。
80.常见的运行时异常
答:
ClassCastException(类转换异常)
IndexOutOfBoundsException(下标越界异常)
NullPointerException(空指针异常)
ArrayStoreException(数据存储异常，操作数组时类型不一致)
BufferOverflowException(IO操作时出现的缓冲区上溢异常)
InputMismatchException(输入类型不匹配异常)
ArithmeticException(算术异常)
81.实现String类的replaceAll方法
思路说明：replaceAll方法的本质是使用正则表达式进行匹配，最终调用的其实是Matcher对象的replaceAll方法。
import java.util.regex.Matcher;
import java.util.regex.Pattern;public class TestStringReplaceAll &#123;
public static void main(String\[] args) &#123;
String str = &quot;a1s2d3f4h5j6k7&quot;;
// 将字符串中的数字全部替换为0
System.out.println(replaceAll(str, &quot;\d&quot;, &quot;0&quot;));
&#125;/**
 * @param str:源字符串
 * @param regex:正则表达式
 * @param newStr:替换后的子字符串
 * @return 返回替换成功后的字符串
 */
public static String replaceAll(String str, String regex, String newStr) &#123;
    Pattern pattern = Pattern.compile(regex);
    Matcher mathcer = pattern.matcher(str);
    String reslut = mathcer.replaceAll(newStr);
    return reslut;
&#125;&#125;82.二分法查询（递归实现）
思路说明：假设在一个已经排好序的有序序列(N个元素，升序排列)，首先让序列中的中间的元素与需要查找的关键字进行比较，如果相等，则查找成功，否则利用中间位置将序列分成两个子序列，如果待查找的关键字小于中间的元素，则在前一个子序列中同样的方法进一步查找，如果待查找的关键字大于中间的元素，则在后一个子序列中同样的方法进一步查找，重复以上过程一直到查找结束！。
import java.util.Scanner;
public class TestBinarySearchRecursion &#123;
public static void main(String\[] args) &#123;
int\[] a = &#123; 1, 3, 5, 7, 9, 11, 13 &#125;;
System.out.print(&quot;请输入要查找的元素：&quot;);
int e = new Scanner(System.in).nextInt();
int index = binarySearch(a, 0, a.length - 1, e);
System.out.println(index != -1 ? &quot;元素索引为&quot; + index : &quot;没有该元素&quot;);
&#125;private static int binarySearch(int[] a, int low, int high, int e) &#123;
    int mid = 0;
    if (low &lt;= high) &#123;
        mid = (low + high) / 2;
        if (a[mid] == e) &#123;
            return mid;
        &#125; else if (a[mid] &gt; e) &#123;
            return binarySearch(a, low, mid - 1, e);
        &#125; else &#123;
            return binarySearch(a, mid + 1, high, e);
        &#125;
    &#125;
    return -1;
&#125;&#125;83.编写一段Java程序，把一句英语中的每个单词中的字母次序倒转，单词次序保持不变，例入输入为“There is a dog.”,输出结果应该是“erehT si a god.”要求不使用Java的库函数，例如String类的split，reverse方法。
函数形如：
public static String reverseWords(String input) &#123;
String str = &quot;&quot;;	return str;
&#125;思路说明：将字符串转化成字符数组，然后根据数组中空格的位置判断每个单词所占的索引范围，根据得到的索引将数组中的每个单词逆序后拼接到新的字符串中。
public class TestStringReverse&#123;
public static void main(String\[] args) &#123;
String input = &quot;There is a dog&quot;;
System.out.println(&quot;逆转后的字符串为：&quot; + reverseWords(input));
&#125;
public static String reverseWords(String input) &#123;
String str = &quot;&quot;;
//将字符串转化成字符数组
char\[] arr = input.toCharArray();
//index用来记录每个单词的起始索引
int index = 0;
//遍历字符数组，将空格前边的单词挨个拼接到str中
for (int i = 0; i &lt; arr.length; i++) &#123;
if(arr\[i] == &#39; &#39;)&#123;
//根据空格的位置将空格前边一个单词密续追加到str中
for(int j = i - 1; j &gt;= index; j--)&#123;
str += arr\[j];
&#125;
//单词拼接完成后，拼接一个空格
str += &#39; &#39;;
//让index指向下一个单词的起始位置
index = i + 1;
&#125;
&#125;
//将最后一个单词拼接上
for(int i = arr.length - 1; i &gt;= index; i--)&#123;
str += arr\[i];
&#125;
return str;
&#125;
&#125;84.说说JVM原理？内存泄漏与溢出的区别？何时产生内存泄漏？
答:
JVM原理：
JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个java实现跨平台的最核心的部分，所有的Java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。内存泄漏与溢出的区别：1.  内存泄漏是指分配出去的内存无法回收了。
2.  内存溢出是指程序要求的内存，超出了系统所能分配的范围，从而发生溢出。比如用byte类型的变量存储10000这个数据，就属于内存溢出。
3.  内存溢出是提供的内存不够；内存泄漏是无法再提供内存资源。何时产生内存泄漏：1.  静态集合类：在使用Set、Vector、HashMap等集合类的时候需要特别注意，有可能会发生内存泄漏。当这些集合被定义成静态的时候，由于它们的生命周期跟应用程序一样长，这时候，就有可能会发生内存泄漏。
2.  监听器：在Java中，我们经常会使用到监听器，如对某个控件添加单击监听器addOnClickListener()，但往往释放对象的时候会忘记删除监听器，这就有可能造成内存泄漏。好的方法就是，在释放对象的时候，应该记住释放所有监听器，这就能避免了因为监听器而导致的内存泄漏。
3.  各种连接：Java中的连接包括数据库连接、网络连接和io连接，如果没有显式调用其close()方法，是不会自动关闭的，这些连接就不能被GC回收而导致内存泄漏。一般情况下，在try代码块里创建连接，在finally里释放连接，就能够避免此类内存泄漏。
4.  外部模块的引用：调用外部模块的时候，也应该注意防止内存泄漏。如模块A调用了外部模块B的一个方法，如：public void register(Object o)。这个方法有可能就使得A模块持有传入对象的引用，这时候需要查看B模块是否提供了去除引用的方法，如unregister()。这种情况容易忽略，而且发生了内存泄漏的话，比较难察觉，应该在编写代码过程中就应该注意此类问题。
5.  单例模式：使用单例模式的时候也有可能导致内存泄漏。因为单例对象初始化后将在JVM的整个生命周期内存在，如果它持有一个外部对象（生命周期比较短）的引用，那么这个外部对象就不能被回收，而导致内存泄漏。如果这个外部对象还持有其它对象的引用，那么内存泄漏会更严重，因此需要特别注意此类情况。这种情况就需要考虑下单例模式的设计会不会有问题，应该怎样保证不会产生内存泄漏问题。
85.下面关于 Java.lang.Exception类的说法正确的是（A）
A	继承自 Throwable
B.	不支持Serializable
C.	继承自 AbstractSet
D.	继承自FitelnputStream
分析：
Throwable是Exception和Error的父类，Exception虽然没有实现Serializable接口，但是其父类Throwable已经实现了该接口，因此Exception也支持Serializable。
86.下列说法正确的是 （C）
A	LinkedList继承自List
B.	AbstractSet继承自Set
C.	HashSet继承自AbstractSet
D.	WeakHashMap继承自HashMap
分析：
LinkedList继承自AbstractSequentialList；
AbstractSet继承自AbstractCollection；
HashSet确实是继承自AbstractSet；
WeakHashMap继承自AbstractMap。
87.请问0.6332的数据类型是（B）
A	float
B.	double
C.	Float
D.	Double
分析：
小数默认是双精度浮点型即double类型的。
88.下面哪个流是面向字符的输入流(D)
A	BufferedWriter
B.	FileInputStream
C.	ObjectInputStream
D.	InputStreamReader
分析：
以InputStream（输入流）/OutputStream（输出流）为后缀的是字节流；以Reader（输入流）/Writer（输出流）为后缀的是字符流。
89.Java接口的修饰符可以为（D）A	private
B.	protected
C.	final
D.	abstract
分析：
能够修饰interface的只有public、abstract以及默认的三种修饰符。
90.不通过构造函数也能创建对象么（A）
A	是
B.	否
分析：
Java创建对象的几种方式：
(1) 用new语句创建对象，这是最常见的创建对象的方法。
(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
(3) 调用对象的clone()方法。
(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。
(1)和(2)都会明确的显式的调用构造函数；(3)是在内存上对已有对象的影印，所以不会调用构造函数；(4)是从文件中还原类的对象，也不会调用构造函数。
91.ArrayList list=new ArrayList(20);中的list扩充几次（A）
A	0
B.	1
C.	2
D.	3
分析：已经指定了长度, 所以不扩容
92.在Java多线程中，请用下面哪种方式不会使线程进入阻塞状态（D）
A	sleep()
B.	suspend()
C.	wait()
D.	yield()
分析：
yield会是线程进入就绪状态
93.Java类库中，将信息写入内存的类是（B）
A	Java.io.FileOutputStream
B.	java.ByteArrayOutputStream
C.	java.io.BufferedOutputStream
D.	java,.io.DataOutputStream
94.当使用RMI技术实现远程方法调用时，能为远程对象生成Sub和Skeleton命令的是（A）
A	Mic
B.	mid
C.	mitegistry
D.	policytool
95.List、Set、Map哪个继承自Collection接口，一下说法正确的是（C）
A	List Map
B.	Set Map
C.	List Set
D.	List Map Set
分析：Map接口继承了java.lang.Object类,但没有实现任何接口.96.在“=”后填写适当的内容：
String \[]a=new String\[10];
则：a\[0]~a\[9]=null;
a.length=10;
如果是int\[]a=new int\[10];
则：a\[0]~a\[9]= (0)
a.length= (10)
97.GC线程是否为守护线程？
GC线程是守护线程。线程分为守护线程和非守护线程（即用户线程）。只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
98.volatile关键字是否能保证线程安全？
答:
不能.
99.存在使i+1\&lt;i的数么?
答:
存在, int的最大值, 加1后变为负数.100.接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？
答:
接口可以继承接口，抽象类可以实现接口，抽象类可以继承实体类
101.是否可以继承String类?
答:
不可以, 因为String是抽象类
102.int与Integer有什么区别？
答:
int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。
在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。
另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。
103.可序列化对象为什么要定义serialversionUID值?
答:
SerialVersionUid，简言之，其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。
104.写一个Java正则，能过滤出html中的&lt;a href&gt;titl&lt;/a&gt;形式中的链接地址和标题.
答:
\&lt;a\b\[^&gt;]+\bhref=&quot;(\[^&quot;]*)&quot;\[^&gt;]*&gt;(\[\s\S]\*?)&lt;/a&gt;
分组1和分组2即为href和value
105.列出除Singleton外的常用的3种设计模式，并简单描述
答:
工厂模式：工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
适配器模式：适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。
模板模式：在模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
106.十进制数72转换成八进制数是多少？
答: 110
107.WEB应用中如果有.class和.jar类型的文件一般分别应该放在什么位置？
答:
.class文件放在WEB-INF/classes文件下，.jar文件放在WEB-INF/lib文件夹下
108.元素中有一个输入框（\&lt;input type=”text” name=”username”id=”username”value=””/&gt;,请用JavaScript语言写一行代码，取得这个输入框中的值。
答:
document.getElementById(“username”).value;
109.描述一下JVM加载class文件的原理机制?
答:
JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
　　由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。
　　类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。　　　　　　从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
　　Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
　	Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。110.Java程序中创建新的类对象，使用关键字new，回收无用的类对象使用关键字free正确么？
答:
Java程序中创建新的类对象，使用关键字new是正确的; 回收无用的类对象使用关键字free是错误的.
111.Class类的getDeclaredFields()方法与getFields()的区别？
答:
getDeclaredFields(): 可以获取所有本类自己声明的方法, 不能获取继承的方法
getFields(): 只能获取所有public声43明的方法, 包括继承的方法
112.在switch和if-else语句之间进行选取，当控制选择的条件不仅仅依赖于一个x时，应该使用switch结构；正确么？
答:
不正确
113.描述final、finally、finalize的区别。
答:
final修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。
finally在异常处理时提供 finally 块来执行任何清除操作。如果有finally的话，则不管是否发生异常，finally语句都会被执行。
finalize方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作。finalize() 方法是在垃圾收集器删除对象之前被调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。114.写一个Singleton例子package com.bjsxt;class Singleton&#123;\
private Singleton()&#123;&#125;\
private static volatile Singleton singleton ;\
public static Singleton getInstance()&#123;\
if(singleton==null)\
synchronized(Singleton.class)&#123;
if(singleton==null)
singleton = new Singleton();\
&#125;\
return singleton;\
&#125;\
&#125;115.请写出常用的Java多线程启动方式，Executors线程池有几种常用类型？(1) 继承Thread类
public class java\_thread extends Thread&#123;\
public static void main(String args\[]) &#123;\
new java\_thread().run();\
System.out.println(&quot;main thread run &quot;);\
&#125;\
public synchronized  void run() &#123;\
System.out.println(&quot;sub thread run &quot;);\
&#125;\
&#125;(2) 实现Runnable接口
public class java\_thread implements Runnable&#123;\
public static void main(String args\[]) &#123;\
new Thread(new java\_thread()).start();\
System.out.println(&quot;main thread run &quot;);\
&#125;\
public void run() &#123;\
System.out.println(&quot;sub thread run &quot;);\
&#125;\
&#125;116.手写9x9乘法表，冒泡排序
9x9乘法表:
class Demo &#123;\
public static void main(String\[] args) &#123;
for(int x = 0;x &lt;= 9; x++) &#123;\
for(int y = 1;y &lt;= x; y++) &#123;\
System.out.print(y+&quot;*&quot;+x+&quot;=&quot;+x*y+&quot;\t&quot;);\
&#125;\
System.out.println();\
&#125;\
&#125;\
&#125;冒泡排序:
public class BubbleSort&#123;
public static void main(String\[] args)&#123;
int score\[] = &#123;67, 69, 75, 87, 89, 90, 99, 100&#125;;
for (int i = 0; i &lt; score.length -1; i++)&#123;//最多做n-1趟排序
for(int j = 0 ;j &lt; score.length - i - 1; j++)&#123;//对当前无序区间score\[0......length-i-1]进行排序(j的范围很关键，这个范围是在逐步缩小的)
if(score\[j] &lt; score\[j + 1])&#123; //把小的值交换到后面
int temp = score\[j];
score\[j] = score\[j + 1];
score\[j + 1] = temp;
&#125;
&#125;
System.out.print(&quot;第&quot; + (i + 1) + &quot;次排序结果：&quot;);
for(int a = 0; a &lt; score.length; a++)&#123;
System.out.print(score\[a] + &quot;\t&quot;);
&#125;
System.out.println(&quot;&quot;);
&#125;
System.out.print(&quot;最终排序结果：&quot;);
for(int a = 0; a &lt; score.length; a++)&#123;
System.out.print(score\[a] + &quot;\t&quot;);
&#125;
&#125;
&#125;117.合并两个有序的链表
public class Solution &#123;
public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
if (l1 == null || l2 == null) &#123;\
return l1 != null ? l1 : l2;\
&#125;\
ListNode head = l1.val &lt; l2.val ? l1 : l2;\
ListNode other = l1.val &gt;= l2.val ? l1 : l2;\
ListNode prevHead = head;\
ListNode prevOther = other;\
while (prevHead != null) &#123;\
ListNode next = prevHead.next;\
if (next != null &amp;&amp; next.val &gt; prevOther.val) &#123;\
prevHead.next = prevOther;\
prevOther = next;\
&#125;\
if(prevHead.next==null)&#123;\
prevHead.next=prevOther;\
break;\
&#125;\
prevHead=prevHead.next;\
&#125;\
return head;
&#125;
&#125;118.用递归方式实现链表的转置。
/\*\*
Definition for singly-linked list.
public class ListNode &#123;
int val;
ListNode next;
ListNode(int x) &#123; val = x; &#125;*   &#125;
\*/
public class Solution &#123;
public ListNode reverseList(ListNode head) &#123;
if(head==null||head.next ==null)
return head;
ListNode prev = reverseList(head.next);
head.next.next = head;
head.next = null;
return prev;
&#125;
&#125;119.题目： 给定一个整数数组，找到是否该数组包含任何重复数字。你的函数应该返回true只要有任何数字 在该数组中重复出现，否则返回false。
public class Solution &#123;
public boolean containsDuplicate(int\[] nums) &#123;
Set\&lt;Integer&gt; numSet = new HashSet\&lt;Integer&gt;();
for(int i=0;i\&lt;nums.length;i++)&#123;·
if(numSet.contains(nums\[i]))
return true;
else
numSet.add(nums\[i]);
&#125;
return false;
&#125;
&#125;120.给定一个数组nums， 写一个函数来移动所有0元素到数组末尾，同时维持数组中非0元素的相对顺序不变。要求不能申请额外的内存空间，并且最小化操作次数。
public void moveZeroes(int\[] nums) &#123;
int size = nums.length;
int startIndex = 0;
// 0元素开始的位置
int endIndex = 0;
// 0元素结束的位置
int currentNum;
int i= 0;
// 第一步：找到第一个0元素开始的位置
// 并将第一个0元素的游标赋值给startIndex\&amp;endIndex
while(i &lt; size)&#123;
currentNum = nums\[i];
if (currentNum == 0) &#123;
startIndex = i;
endIndex = i;
break;
&#125;
\++i;
&#125;
// 如果当前数组中没有找到0元素，则推出
if (nums\[endIndex] != 0)
return;// 将当前i的值加1；直接从刚才0元素位置的后一位置开始循环
++i;
while (i &lt; size) &#123;
currentNum = nums[i];
if (currentNum == 0)&#123;//如果当前元素等于0，则将i值赋值给endIndex
endIndex = i;
&#125; else &#123;
// 如果不为0
//则将当前元素赋值给nums[startIndex]
// 并将当前位置的元素赋值为0
// startIndex和endIndex都加1；
nums[startIndex] = currentNum;
nums[i] = 0;
++startIndex;
++endIndex;
&#125;
++i;
&#125;
&#125;121.给定两个字符串s和t，  写一个函数来决定是否t是s的重组词。你可以假设字符串只包含小写字母。public class Solution &#123;
public boolean isAnagram(String s, String t) &#123;
if(s.length()!=t.length())
return false;
int bit\[] = new int\[26];
for(int i=0;i\&lt;s.length();i++)&#123;
bit\[s.charAt(i)-&#39;a&#39;]++;
&#125;for(int i=0;i&lt;s.length();i++)&#123;
if(--bit[t.charAt(i)-&#39;a&#39;]&lt;0)
return false;
&#125;
return true;
&#125;&#125;122.给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重复的子集。public class Solution &#123;
public List\&lt;List\&lt;Integer&gt;&gt; subsets (int\[] nums) &#123;
List\&lt;List\&lt;Integer&gt;&gt; res = new ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt;();
List\&lt;Integer&gt; item = new ArrayList\&lt;Integer&gt;();
if(nums.length == 0 || nums == null)
return res;
Arrays.sort(nums); //排序
dfs(nums, 0, item, res);  //递归调用
res.add(new ArrayList\&lt;Integer&gt;());  //最后加上一个空集
return res;
&#125;
public static void dfs(int\[] nums, int start, List\&lt;Integer&gt; item, List\&lt;List\&lt;Integer&gt;&gt; res)&#123;
for(int i = start; i &lt; nums.length; i ++)&#123;
item.add(nums\[i]);
//item是以整数为元素的动态数组，而res是以数组为元素的数组，在这一步，当item增加完元素后，item所有元素构成一个完整的子串，再由res纳入
res.add(new ArrayList\&lt;Integer&gt;(item));
dfs(nums, i + 1, item, res);
item.remove(item.size() - 1);
&#125;
&#125;
&#125;123.给定一颗二叉树，返回节点值得先序遍历，请使用迭代（非递归）方式实现。public class Solution &#123;\
public List\&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\
List\&lt;Integer&gt; result = new ArrayList\&lt;Integer&gt;();
if(root == null)\
return result;\
Stack\&lt;TreeNode&gt; stack = new Stack\&lt;TreeNode&gt;();\
stack.push(root);\
while(!stack.isEmpty()) &#123;\
TreeNode node = stack.pop();\
result.add(node.val);\
if(node.right != null)\
stack.push(node.right);\
if(node.left != null)\
stack.push(node.left);\
&#125;\
return result;\
&#125;\
&#125;124.验证一棵树是否为有效的二叉搜索树BST
public class Solution &#123;
private static int lastVisit = Integer.MIN\_VALUE;
public boolean isValidBST(TreeNode root) &#123;
if(root == null) return true;\
boolean judgeLeft = isValidBST(root.left); // 先判断左子树if(root.data &gt;= lastVisit &amp;&amp; judgeLeft) &#123; // 当前节点比上次访问的数值要大  
lastVisit = root.data;  
&#125; else &#123;  
return false;  
&#125;  
boolean judgeRight = isValidBST(root.right); // 后判断右子树  
return judgeRight;
&#125;&#125;125.从一个链表中删除节点
题目： 写一个函数用于在一个单向链表中删除一个节点（⾮非尾节点），前提是仅仅能够访问要删除的那个节点。
比如给定链表1 -&gt; 3 -&gt; 5 -&gt; 7 -&gt; 9 -&gt; 16，给定你值为3的那个节点， 调⽤用你的函数后，链表变为
1 -&gt; 5 -&gt; 7 -&gt; 9 -&gt; 16。
/\*\*
Definition for singly-linked list.
public class ListNode &#123;
int val;
ListNode next;
ListNode(int x) &#123; val = x; &#125;*   &#125;
\*/
public class Solution &#123;
public void deleteNode(ListNode node) &#123;
if(node==null||node.next==null) &#123;
System.out.println(&quot;节点不存在或者是尾节点&quot;);  &#125;else&#123;
      node.val=node.next.val; 
      node.next=node.next.next;
  &#125;&#125;
&#125;
126.二叉搜索树BST中第Kth小的元素 题目：给定⼀个BST，写一个函数kthSmallest来找到第kth小的元素
/\*\*
Definition for a binary tree node.
public class TreeNode &#123;
int val;
TreeNode left;
TreeNode right;
TreeNode(int x) &#123; val = x; &#125;*   &#125;
\*/
public class Solution2  &#123;
public int kthSmallest(TreeNode root, int k) &#123;
Stack\&lt;TreeNode&gt; store = new Stack\&lt;TreeNode&gt;();\
if (root == null) &#123;\
return -1;\
&#125;\
store.push(root);\
while (root.left != null) &#123;\
store.push(root.left);\
root = root.left;\
&#125;\
while (!store.empty()) &#123;\
TreeNode cur = store.pop();\
k--;\
if (k == 0) &#123;\
return cur.val;\
&#125;\
if (cur.right != null) &#123;\
root = cur.right;// let cur.right be the current node\
store.push(root);\
while (root.left != null) &#123;\
store.push(root.left);\
root = root.left;\
&#125;\
&#125;\
&#125;\
return -1;\
&#125;\
&#125;127.题目：给定含有n个整数的数组S，S中是否存在三个元素a,b,c使得a + b + c = 0? 找到所有这样的三元 组，并且结果集中不包含重复的三元组。
比如，
S = \[-1, 0, 1, 2, -1, -4],,
结果集为: \[
\[-1, 0, 1],
\[-1, -1, 2]
]
/\*\**   给定一个n个元素的数组，是否存在a，b，c三个元素，使用得a+b+c=0，找出所有符合这个条件的三元组
*   注意： - 三元组中的元素必须是非递减的  - 结果不能包含重复元素
\*/\
public class Solution &#123;public static void main(String\[] args) &#123;\
int\[] S = &#123;-1, 0, 1, 2, -1, -4,-3,-4,4,3&#125;;\
new Solution().get3Sum(S);\
&#125;public Set\&lt;String&gt; get3Sum(int\[] S)&#123; if(S.length&lt;3 || S==null)&#123;  
 return null;  
 &#125;  
   
 //接收拼接的字符串  
 StringBuffer sb = new StringBuffer();  
 for(int i=0; i&lt;S.length; i++)&#123;  
 for(int j=0; j&lt;S.length; j++)&#123;  
 for(int z=0; z&lt;S.length; z++)&#123;  
 //筛选出不是递减的一组元素  
 if(S[i]&lt;=S[j] &amp;&amp; S[j]&lt;=S[z])&#123;  
 int sum = S[i] + S[j] + S[z];  
 if(sum==0)&#123;  
 String str = &quot;(&quot;+S[i]+&quot;,&quot;+S[j]+&quot;,&quot;+S[z]+&quot;)&quot;;  
 sb.append(str+&quot;;&quot;);  
 &#125;  
 &#125;  
 &#125;  
 &#125;  
 &#125;  
   
 String s = sb.toString();  
 s = s.substring(0, sb.length()-1);  
 String[] arr = s.split(&quot;;&quot;);  
   
 Set&lt;String&gt; set = new HashSet&lt;String&gt;();  
 //将所筛选出来的元素放入Set集合中，去重  
 for (int k = 0; k &lt; arr.length; k++) &#123;  
 set.add(arr[k]);  
 &#125;  
 System.out.println(set);  
 return set;  &#125;public List\&lt;List\&lt;Integer&gt;&gt; threeSum(int\[] nums) &#123;\
List\&lt;List\&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (nums != null &amp;&amp; nums.length &gt; 2) &#123;  
 // 先对数组进行排序  
 Arrays.sort(nums);  
 // i表示假设取第i个数作为结果  
 for (int i = 0; i &lt; nums.length - 2; ) &#123;  
 // 第二个数可能的起始位置  
 int j = i + 1;  
 // 第三个数可能是结束位置  
 int k = nums.length - 1;
 while (j &lt; k) &#123;  
 // 如果找到满足条件的解  
 if (nums[j] + nums[k] == -nums[i]) &#123;  
 // 将结果添加到结果含集中  
 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(3);  
 list.add(nums[i]);  
 list.add(nums[j]);  
 list.add(nums[k]);  
 result.add(list);
 // 移动到下一个位置，找下一组解  
 k--;  
 j++;   // 从左向右找第一个与之前处理的数不同的数的下标  
 while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123;  
 j++;  
 &#125;  
 // 从右向左找第一个与之前处理的数不同的数的下标  
 while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123;  
 k--;  
 &#125;  
 &#125;  
 // 和大于0  
 else if (nums[j] + nums[k] &gt; -nums[i]) &#123;  
 k--;  
 // 从右向左找第一个与之前处理的数不同的数的下标  
 while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123;  
 k--;  
 &#125;  
 &#125;  
 // 和小于0  
 else &#123;  
 j++;  
 // 从左向右找第一个与之前处理的数不同的数的下标  
 while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123;  
 j++;  
 &#125;  
 &#125;  
 &#125;
 // 指向下一个要处理的数  
 i++;  
 // 从左向右找第一个与之前处理的数不同的数的下标  
 while (i &lt; nums.length - 2 &amp;&amp; nums[i] == nums[i - 1]) &#123;  
 i++;  
 &#125;  
 &#125;  
 &#125;   return result;  &#125;\
&#125;128.子集问题
题目： 给定一个不包含相同元素的整数集合，nums，返回所有可能的子集集合。解答中集合不能包含重 复的子集。
比如，
nums = \[1, 2, 3], ⼀一种解答为：
\[
\[3],
\[1],
\[2],
\[1,2,3],
\[1,3],
\[2,3],
\[1,2], \[]
]/\*\**   不重复集合求子集
解答采用的是深度优先遍历，先取原数组一个元素，再构造包括这个元素的两个，三个……n个元素的集合。dfs中的start就指向这个元素的，它在不断地后移（i+1)。
*   @param S: A set of numbers.
*   @return: A list of lists. All valid subsets.
\*/
public class Solution1 &#123;\
public static void main(String\[] args) &#123;
int\[] first = new int\[]&#123;1, 2, 3&#125;;
ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt; res = subsets(first);
for(int i = 0; i &lt; res.size(); i ++)&#123;
System.out.println(res.get(i));
&#125;
&#125;
public static ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt; subsets(int\[] nums) &#123;
ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt; res = new ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt;();
ArrayList\&lt;Integer&gt; item = new ArrayList\&lt;Integer&gt;();
if(nums.length ++++== 0 || nums ==++++ null)
return res;
Arrays.sort(nums); //排序
dfs(nums, 0, item, res);  //递归调用
res.add(new ArrayList\&lt;Integer&gt;());  //最后加上一个空集
return res;
&#125;
public static void dfs(int\[] nums, int start, ArrayList\&lt;Integer&gt;item, ArrayList\&lt;ArrayList\&lt;Integer&gt;&gt;res)&#123;
for(int i = start; i &lt; nums.length; i ++)&#123;
item.add(nums\[i]);
//item是以整数为元素的动态数组，而res是以数组为元素的数组，在这一步，当item增加完元素后，item所有元素构成一个完整的子串，再由res纳入
res.add(new ArrayList\&lt;Integer&gt;(item));
dfs(nums, i + 1, item, res);
item.remove(item.size() - 1);
&#125;
&#125;
&#125; 129.迭代方法实现二叉树的先序遍历：题目： 给定一颗⼆叉树，返回节点值得先序遍历，请使用迭代（非递归）方式实现。
比如， 给定二叉树&#123;1,#,2,3&#125;, 返回 \[1,2,3]
/\*\*
Definition for a binary tree node.
public class TreeNode &#123;
int val;
TreeNode left;
TreeNode right;
TreeNode(int x) &#123; val = x; &#125;*   &#125;
\*/
public class Solution &#123;List\&lt;Integer&gt; result = new ArrayList\&lt;Integer&gt;();/\*\**   迭代实现，维护一个栈，因为入栈顺序按照根右左进行入栈，因此首先将根出栈，然后出栈左子节点，
*   最后出栈右子节点。
*   @param root
*   @return 
\*/\
public List\&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\
if(root == null)\
return result;\
Stack\&lt;TreeNode&gt; stack = new Stack\&lt;TreeNode&gt;();\
stack.push(root);\
while(!stack.isEmpty()) &#123;\
TreeNode node = stack.pop();\
result.add(node.val);\
if(node.right != null)\
stack.push(node.right);\
if(node.left != null)\
stack.push(node.left);\
&#125;\
return result;\
&#125;\
&#125;130.验证二叉搜索树BST：题目： 验证一棵树是否为有效的二叉搜索树BST比如，二叉树\[2, 1, 3]，返回true二叉树\[1, 2, 3], 返回false
class TreeNode &#123;\
int val;\
 TreeNode left;\
TreeNode right;\
TreeNode(int x) &#123; val = x; &#125;
&#125;\
public class BSTChecker &#123;\
private static int lastVisit = Integer.MIN\_VALUE;public static boolean isBST(TreeNode root) &#123;  
if(root == null) return true;  boolean judgeLeft = isBST(root.left); // 先判断左子树  if(root.val &gt;= lastVisit &amp;&amp; judgeLeft) &#123; // 当前节点比上次访问的数值要大  
lastVisit = root.val;  
&#125; else &#123;  
return false;  
&#125;  boolean judgeRight = isBST(root.right); // 后判断右子树  return judgeRight;  
&#125;  &#125;131.编辑距离题目： 给定两个单词word1和word2，找到最小的操作步骤使得word1转换成word2，每次操作算作一 步。你可以对单词进行以下三种操作：1）插入一个字符2）删除一个字符3）替换一个字符
有些绕，理解不是很透彻。
参考地址：&lt;http://www.cnblogs.com/masterlibin/p/5785092.html&gt;
132.String s=new String(“abc”);创建了几个String对象。
两个或一个，”abc”对应一个对象，这个对象放在字符串常量缓冲区，常量”abc”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”abc”对象的内容来创建出一个新String对象。如果以前就用过’abc’，这句代表就不会创建”abc”自己了，直接从缓冲区拿。
133.买卖股票问题：题目： 你有一个数组，第i个元素表示第i天某个股票的价格，设计一个算法找到最大的利润，并且你只能最多完成两次交易。
参考地址：没有完全理解的
&lt;http://www.mamicode.com/info-detail-1087177.html&gt;
&lt;http://blog.csdn.net/cumt_cx/article/details/48015735&gt;/\*\**   解题思路：
*   比如给定一组数组，\[1，2，3，6，9，3，10]
*   最多可以2次去获取最大的利益，可以用2分的思想，分成2部分，
*   从0元素开始遍历分别求出左右2边的最大利益，求出的左右2边最大的利益即为解
\*/\
class Solution &#123;public static int maxProfit(int\[] prices) &#123;\
// write your code here\
if(null==prices||0==prices.length) return 0;\
int sumProfit = 0;\
for(int i=1;i\&lt;prices.length;i++)&#123;\
int tmpsum = maxProfit(prices, 0, i)
\+ maxProfit(prices, i+1, prices.length-1);\
sumProfit = Math.max(sumProfit, tmpsum);\
&#125;\
return sumProfit;\
&#125;\
public static int maxProfit(int\[] prices,int s,int e)&#123;\
if(e&lt;=s) return 0;\
int min = prices\[s];\
int maxProfit = 0;\
for(int i=s+1;i&lt;=e;i++)&#123;\
maxProfit = Math.max(maxProfit, prices\[i]-min);\
min = Math.min(min, prices\[i]);\
&#125;\
return maxProfit;\
&#125;
public static void main(String\[] args) &#123;
int arr \[] =  &#123;4,4,6,1,1,4,2,5&#125;;
System.out.println(maxProfit(arr));
&#125;
&#125;134.描述&amp;和&amp;&amp;的区别。
&amp;和&amp;&amp;的联系(共同点)：
&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。
操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，
表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，
情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。
情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。
表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。
&amp;和&amp;&amp;的区别(不同点)：
(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。
对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。
对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。
综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。
(2)、&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。135.使用final关键字修饰符一个变量时，是引用不能变，还是引用的对象不能变？
final修饰基本类型变量，其值不能改变。
但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如
class Test &#123;
public static void main(String\[] args) &#123;
final Dog dog = new Dog(&quot;欧欧&quot;);
dog.name = &quot;美美&quot;;//正确
dog = new Dog(&quot;亚亚&quot;);//错误
&#125;
&#125;136.简单描述一下Servlet与JSP的的相同点和区别点。
区别：
JSP是在HTML代码里写JAVA代码,框架是HTML;而Servlet是在JAVA代码中写HTML代码，本身是个JAVA类。
JSP使人们把显示和逻辑分隔成为可能，这意味着两者的开发可并行进行；而Servlet并没有把两者分开。
Servlet独立地处理静态表示逻辑与动态业务逻辑.这样,任何文件的变动都需要对此服务程序重新编译;JSP允许用特殊标签直接嵌入到HTML页面, HTML内容与JAVA内容也可放在单独文件中,HTML内容的任何变动会自动编译装入到服务程序.
Servlet需要在web.xml中配置，而JSP无需配置。
目前JSP主要用在视图层，负责显示，而Servlet主要用在控制层，负责调度
联系：
都是Sun公司推出的动态网页技术。
先有Servlet，针对Servlet缺点推出JSP。JSP是Servlet的一种特殊形式，每个JSP页面就是一个Servlet实例——JSP页面由系统翻译成Servlet，Servlet再负责响应用户请求。
137.请简单描述下几个您熟悉JavaScript库，它们有哪些作用和特点？
JavaScript 高级程序设计（特别是对浏览器差异的复杂处理），通常很困难也很耗时。为了应对这些调整，许多的 JavaScript库应运而生。这些 JavaScript 库常被称为 JavaScript 框架。
jQuery:
Ext JS - 可定制的 widget，用于构建富因特网应用程序（rich Internet applications）。
Prototype
MooTools。
YUI - Yahoo! User Interface Framework，涵盖大量函数的大型库，从简单的 JavaScript 功能到完整的 internet widget。
138.简单描述下几个HTML，CSS，Javascript在Web前端开发中分别起什么作用？
1、什么是HTML（超文本标记语言 Hyper Text Markup Language），HTML 是用来描述网页的一种语言。
2、CSS(层叠样式表 Cascading Style Sheets),样式定义如何显示 HTML 元素，语法为：selector &#123;property：value&#125; (选择符 &#123;属性：值&#125;)
3、JavaScript是一种脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行
对于一个网页，HTML定义网页的结构，CSS描述网页的样子，JavaScript设置一个很经典的例子是说HTML就像 一个人的骨骼、器官，而CSS就是人的皮肤，有了这两样也就构成了一个植物人了，加上javascript这个植物人就可以对外界刺激做出反应，可以思 考、运动、可以给自己整容化妆（改变CSS）等等，成为一个活生生的人。
如果说HTML是肉身、CSS就是皮相、Javascript就是灵魂。没有Javascript,HTML+CSS是植物人，没有Javascript、CSS是个毁容的植物人。
如果说HTML是建筑师，CSS就是干装修的，Javascript是魔术师。
139.输出结果？
String str1=“hello”；
Sring str2=“he”+new String(“llo”)；
Sysem.out.println(str1==str2));
Sysem.out.println(str.equal(str2));false
true
140.下列程序的输出结果是什么？
import java.util.\*;
public class Test 6&#123;
public static void main(String\[] args) &#123;
for (int i = 0; i &lt; 10; i++) &#123;
Integer k=new Integer(i);
System.out.println(k+&quot; Hello world&quot;);
&#125;
&#125;
&#125;0 Hello world
1 Hello world
2 Hello world
3 Hello world
4 Hello world
5 Hello world
6 Hello world
7 Hello world
8 Hello world
9 Hello world
141.写一个完整函数，实现拷贝数组
public class Test &#123;
public static void main(String\[] args) &#123;
int \[] arr1 = &#123;10,20,30,40,50&#125;;
int \[] arr2 = copyArray(arr1);
System.out.println(Arrays.toString(arr2));
&#125;public static int [] copyArray(int [] arr)&#123;
    int [] arr2 = new int[arr.length];
    for(int i=0;i&lt;arr.length;i++)&#123;
        arr2[i] = arr[i];
    &#125;
    return arr2;
&#125;&#125;142.请写出一段代码，能够完成将字符串写入文件
public class Test2 &#123;
public static void main(String\[] args) &#123;
String str =&quot;bjsxt&quot;;
writeFile(str);
&#125;
public static void writeFile(String str)&#123;
File file = new File(&quot;c:/test.txt&quot;);
PrintStream ps = null;
try &#123;
OutputStream fos = new FileOutputStream(file);
ps = new PrintStream(fos);
ps.print(str);
&#125; catch (FileNotFoundException e) &#123;
e.printStackTrace();
&#125;finally&#123;
ps.close();
&#125;
&#125;
&#125;143.请解释以下常用正则含义：\d,\D,\s,.,\*,?,|,\[0-9]&#123;6&#125;,\d+
\d: 匹配一个数字字符。等价于\[0-9]
\D: 匹配一个非数字字符。等价于\[^0-9]
\s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 \[ \f\n\r\t\v]
.	：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。
\*：匹配前面的子表达式零次或多次。要匹配 \* 字符，请使用 \*。
\+：匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。
\|:将两个匹配条件进行逻辑“或”（Or）运算
\[0-9]&#123;6&#125;:匹配连续6个0-9之间的数字
\d+：匹配至少一个0-9之间的数字
144.关于sleep()和wait()，以下描述错误的一项是（D）
A.	sleep是线程类（Thread）的方法，wait是Object类的方法
B.	Sleep不释放对象锁，wait放弃对象锁
C.	Sleep暂停线程、但监控状态任然保持，结束后会自动恢复
D.	Wait后进入等待锁定池，只针对此对象发出notify方法后获取对象锁进入运行状态。
分析：
针对此对象的notify方法后获取对象锁并进入就绪状态，而不是运行状态。另外针对此对象的notifyAll方法后也可能获取对象锁并进入就绪状态，而不是运行状态
145.已知表达式int m\[] = &#123;0,1,2,3,4,5,6&#125;; 下面那个表达式的值与数组的长度相等（B）
A.	m.length()
B.	m.length
C.	m.length()+1\
D.	m.length+1
分析：数组的长度是.length146.下面那些声明是合法的？（AD）
A.	long l = 4990\
B.	int i = 4L
C.	float f = 1.1
D.	double d = 34.4
分析：B int属于整数型应该是int=4 C应该是float f=1.1f
147.以下选项中选择正确的java表达式（CD）
A.	int k=new String(“aa”)\
B.	String str = String(“bb”)
C.	char c=74;
D.	long j=8888;
分析：A需要轻质类型转换  B  String str =new String(“bb”)
148.下列代码的输出结果是
System.out.println(&quot;&quot;+(&quot;12&quot;==&quot;12&quot;&amp;&amp;&quot;12&quot;.equals(&quot;12&quot;)));
(“12”==”12”&amp;&amp;”12”.equals(“12”))
“12”==”12”&amp;&amp;”12”.equals(“12”)true
false
149.以下哪些运算符是含有短路运算机制的？请选择：(BD)
A.	&amp;\
B.	&amp;&amp;
C.	|
D.	||
分析：A C是逻辑与计算
150.下面哪个函数是public void example()&#123;....&#125;的重载函数？（AD）
A.	private void example（int  m）&#123;...&#125;
B.	public int example（）&#123;...&#125;
C.	public void example2（）&#123;...&#125;
D.	public int example（int  m.float  f）&#123;...&#125;
分析：BC定义的是新函数
151.在调用方法时，若要使方法改变实参的值（即调用方法完成后，参数的内容可能发现改变），可以（B）
A.	用基本数据类型作为参数
B.	用对象作为参数
C.	A和B都对
D.	A和B都不对
分析：
152.给定某java程序片段，该程序运行后，j的输出结果为（B）
int  i=1；
Int  j=i++；
If（（j&gt;++j）&amp;&amp;(i++==j)）&#123;j+=i:&#125;
System.out.println(j);A.	1
B.	2
C.	3
D.	4
分析： i++先引用后。++i 先增加后引用
153.在java中，无论测试条件是什么，下列（B）循环将至少执行一次。
A.	for
B.	do...while
C.	while
D.	while...do
分析： ACD都不一定进行循环154.\[编程]任给n个整数和一个整数x。请计算n个整数中有多少对整数之和等于x。
public class Test8 &#123;
public static void main(String\[] args) &#123;
//输入n个整数和一个整数
Scanner input = new Scanner(System.in);
System.out.println(&quot;请输入n个整数，数量任意,以逗号分隔&quot;);
String str = input.next();
System.out.println(&quot;请输入一个整数：&quot;);
int x = input.nextInt();
//将n个整数的字符串转换为数组
String arr1\[] = str.split(&quot;,&quot;);
int \[] arr2 = new int\[arr1.length];
for(int i=0;i\&lt;arr1.length;i++)&#123;
arr2\[i] = Integer.parseInt(arr1\[i]);
&#125;
System.out.println(Arrays.toString(arr2));
//判断并输出n个整数中有几对的和等于x
int count = 0;
for(int i=0;i\&lt;arr2.length-1;i++)&#123;
for(int j = i+1;j\&lt;arr2.length;j++)&#123;
if(arr2\[i]+arr2\[j]==x)&#123;
count++;
&#125;
&#125;
&#125;
System.out.println(count);
&#125;
&#125;155.\[编程]请说明快速排序算法的设计思想和时间复杂度，并用高级语言写出对整数数组进行一趟快排的函数实现。
快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
设要排序的数组是A\[0]……A\[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。
一趟快速排序的算法是：
1、设置两个变量i、j，排序开始的时候：i=0，j=N-1；
2、以第一个数组元素作为关键数据，赋值给key，即key=A\[0]；
3、从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A\[j]，将A\[j]和A\[i]互换；
4、从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A\[i]，将A\[i]和A\[j]互换；
5、重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A\[j]不小于key,4中A\[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。
public class Quick &#123;
public static void main(String\[] args) &#123;
int arr \[] = &#123;90,60,70,50,40,80,20,100,10&#125;;
sort(arr,0,arr.length-1);
System.out.println(Arrays.toString(arr));
&#125;
public static void sort(int arr\[], int low, int high) &#123;
//设置两个变量l、h，排序开始的时候：l=0，h=N-1
int l = low;
int h = high;
//以第一个数组元素作为关键数据，赋值给key，即key=A\[0]
int key = arr\[low];
//重复操作，直到i=j
while (l &lt; h) &#123;
//从h开始向前搜索，即由后开始向前搜索(h--)，找到第一个小于key的值arr\[h]，将arr\[h]和arr\[l]互换
while (l &lt; h &amp;&amp; arr\[h] &gt;= key)
h--;
if (l &lt; h) &#123;
int temp = arr\[h];
arr\[h] = arr\[l];
arr\[l] = temp;
l++;
&#125;
//从l开始向后搜索，即由前开始向后搜索(l++)，找到第一个大于key的arr\[l]，将arr\[l]和arr\[h]互换；
while (l &lt; h &amp;&amp; arr\[l] &lt;= key)
l++;		if (l &lt; h) &#123;
            int temp = arr[h];
            arr[h] = arr[l];
            arr[l] = temp;
            h--;
        &#125;
    &#125;		
    //对前一部分进行快速排序
    if (l &gt; low)
        sort(arr, low, l - 1);
    //对前一部分进行快速排序
    if (h &lt; high)
        sort(arr, l + 1, high);
&#125;&#125;156.打印结果：2
package com.bjsxt;
public class smaillT&#123;
public static void main(String args\[])&#123;
smaillT t=new smaillT();
int b = t.get();
System.out.println(b);
&#125;public int get()
&#123;
    try
    &#123;
        return 1;
    &#125;finally&#123;
        return 2;
    &#125;
&#125;&#125;157.指出下列程序的运行结果
int i=9;
switch (i) &#123;
default:
System.out.println(&quot;default&quot;);
case 0:
System.out.println(&quot;zero&quot;);
break;
case 1:
System.out.println(&quot;one&quot;);
break;
case 2:
System.out.println(&quot;two&quot;);
break;default
zero
158.数组有没有length()这个方法？String呢？
数组没有length()方法，有length属性
String有length()方法
159.解释继承、重载、覆盖。
继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充。
那么如何使用继承呢？用extends关键字来继承父类。
如上面A类与B类，当写继承语句时， class A类 extends B类&#123; &#125; 其中A类是子类，B类是父类。
英文	位置不同	作用不同
重载	overload	同一个类中	在一个类里面为一种行为提供多种实现方式并提高可读性
重写	override	子类和父类间	父类方法无法满足子类的要求，子类通过方法重写满足要求修饰符	返回值	方法名	参数	抛出异常重载	无关	无关	相同	不同	无关
重写	大于等于	小于等于	相同	相同	小于等于160.进程和线程的区别是什么？
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.区别 	进程 	线程 
根本区别 	作为资源分配的单位 	调度和执行的单位
开销 	每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销。 	线程可以看成时轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小。 
所处环境 	在操作系统中能同时运行多个任务(程序) 	在同一应用程序中有多个顺序流同时执行 
分配内存 	系统在运行的时候会为每个进程分配不同的内存区域 	除了CPU之外，不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源 
包含关系 	没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。 	线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程。 161.什么是编译型语言，什么是解释型语言？java可以归类到那种？
计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。
用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。
解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行时才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。
编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。
JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。
162.简述操作符（&amp;，|）与操作符（&amp;&amp;，||）的区别
&amp;和&amp;&amp;的联系(共同点)：
&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。
操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，
表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，
情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。
情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。
表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。
&amp;和&amp;&amp;的区别(不同点)：
(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。
对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。
对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。
综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。
(2)、&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。
|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似
163.try&#123;&#125;里面有一个return语句，那么紧跟在这个try后的finally, 里面的语句在异常出现后，都会执行么？为什么？
在异常处理时提供 finally 块来执行任何清除操作。
如果有finally的话，则不管是否发生异常，finally语句都会被执行，包括遇到return语句。
finally中语句不执行的唯一情况中执行了System.exit(0)语句。
164.对于一段形如：1，-1++++~3,1~++++15×3的输入
输入会依照以下规则：
1、所有输入为整数、
2、“,”为分隔符
3、“++++~”表示一个区间，比如“-1~++++3”表示-1到3总共5个整数，同时“++++~”前的数小于“~++++”后的数：
4、“x”表示步长，“x3”指每3个整数一个，比如“1++++~15×3”表示1，4,7,10,13；
根据以上得到的结果进行打印，打印的规则为：
1、所有得到的整数按从小到大排列，以“，”分隔，不计重复；
2、每行最多显示3个整数；
3、如果两个整数是连续的，可以放在同一行，否则自动换行。
例如对于输入“1，-1~++++3,1++++~15×3”的输出结果为：
\-1,0,1，
2,3,4，
7,
10，
13
public class Test &#123;
public static void main(String\[] args) &#123;
Map\&lt;Integer, Integer&gt; map = new TreeMap\&lt;Integer, Integer&gt;();
String str = &quot;5~++++20x3,1,-1++++~3,1~++++15x3&quot;;
String\[] s = str.split(&quot;,&quot;);
for (int i = 0; i &lt; s.length; i++) &#123;
if (s\[i].contains(&quot;~&quot;)) &#123;
String ss\[] = s\[i].split(&quot;~&quot;);
int first = Integer.parseInt(ss\[0]);
if (s\[i].contains(&quot;x&quot;)) &#123;
String sss\[] = ss\[1].split(&quot;x&quot;);
int end = Integer.parseInt(sss\[0]);
int l = Integer.parseInt(sss\[1]);
for (int j = first; j &lt; end;) &#123;
map.put(j, j);
j += l;
&#125;
&#125; else &#123;
int end = Integer.parseInt(ss\[ss.length - 1]);
for (int j = first; j &lt;= end; j++) &#123;
map.put(j, j);
&#125;
&#125;
&#125; else &#123;
int j = Integer.parseInt(s\[i]);
map.put(j, j);
&#125;
&#125;
List\&lt;Integer&gt; list = new ArrayList\&lt;Integer&gt;();
Set\&lt;Integer&gt; set = map.keySet();
Iterator\&lt;Integer&gt; ite = set.iterator();
while (ite.hasNext()) &#123;
int key = ite.next();
int value = map.get(key);
list.add(value);
System.out.println(&quot;v :&quot; + value);
&#125;
System.out.println(&quot;=================&quot;);
for (int i = 0; i &lt; list.size();) &#123;
int value = list.get(i);
List\&lt;Integer&gt; co = new ArrayList\&lt;Integer&gt;();
co.add(value + 1);
co.add(value + 2);
if (list.containsAll(co)) &#123;
System.out.println(value + &quot;,&quot; + (value + 1) + &quot;,&quot;
\+ (value + 2));
i += 3;
&#125; else &#123;
System.out.println(value);
i++;
&#125;
&#125;
&#125;
&#125;165.有一段java应用程序，它的主类名是al，那么保存它的源文件可以是？(A)
A.	al.java
B.	al.class
C.	al
D.	都对
分析：.class是java的解析文件
166.Java类可以作为（c）A	类型定义机制
B.	数据封装机制
C.	类型定义机制和数据封装机制
D.	上述都不对
分析：
167.在调用方法时，若要使方法改变实参的值，可以？（B）
A	用基本数据类型作为参数
B.	用对象作为参数
C.	A和B都对
D.	A和B都不对
分析：基本数据类型不能改变实参的值
168.Java语言具有许多优点和特点，哪个反映了java程序并行机制的(BC)
A	安全性
B.	多线性
C.	跨平台
D.	可移植
分析：
169.下关于构造函数的描述错误是(A)
A	构造函数的返回类型只能是void型
B.	构造函数是类的一种特殊函数，它的方法名必须与类名相同
C.	构造函数的主要作用是完成对类的对象的初始化工作
D.	一般在创建新对象时，系统会自动调用构造函数
分析：构造函数的名字与类的名字相同，并且不能指定返回类型。
170.若需要定义一个类域或类方法，应使用哪种修饰符？（A）A	static
B.	package
C.	private
D.	public
分析：A
171.储蓄所有多个储户，储户在多个储户所存取款，储蓄所与储户之间是(D)
A	一对一的联系
B.	多对一的联系
C.	一对多的联系
D.	多对多的联系
分析：D
视图是一个“虚表”，视图的构造基于(A)
A	基本表或视图
B.	视图
C.	数据字典
D.	基本表
分析：A
172.设有关系R(A,B,C,D)及其上的函数相关性集合F=&#123;B→A,BC→D&#125;,那么关系R最高是(A)
A	第一范式的
B.	第二范式的
C.	第三范式的
D.	BCNF范式的
分析：A
173.已知如下代码：执行结果是什么(A)
package com.bjsxt;
public class Test &#123;
public static void main(String\[] args) &#123;
String s1 = new String(&quot;Hello&quot;);
String s2 = new String(&quot;Hello&quot;);
System.out.print(s1 == s2);
String s3 = &quot;Hello&quot;;
String s4 = &quot;Hello&quot;;
System.out.print(s3 == s4);
s1 = s3;
s2 = s4;
System.out.print(s1 == s2);
&#125;
&#125;A	false true true
B.	true false true
C.	true true false
D.	true true false
分析：A
174.下面代码执行后的输出是什么(A)
package com.bjsxt;
public class Test &#123;
public static void main(String\[] args) &#123;
outer: for (int i = 0; i &lt; 3; i++)
inner: for (int j = 0; j &lt; 2; j++) &#123;
if (j == 1)
continue outer;
System.out.println(j + &quot; and &quot; + i);
&#125;
&#125;
&#125;
A	0 and 0
0 and 1
0 and 2
B.	1 and 0
1 and 1
1 and 2
C.	2 and 0
2 and1
2 and 2
分析：A
175.给出如下代码，如何使成员变量m被函数fun()直接访问(C)
package com.bjsxt;
public class Test &#123;
private int m;public static void fun() &#123;
    // some code…
&#125;&#125;A	将private int m 改为 protected int m
B.	将private int m 改为 public int m
C.	将private int m 改为 static int m
D.	将private int m 改为int m
分析：C
176.下面哪几个函数是public void example（）&#123;….&#125;的重载函数(ABD)
A	public void example（int m）&#123;…&#125;
B.	public int example（int m）&#123;…&#125;
C.	public void example2（）&#123;…&#125;
D.	public int example（int m，float f）&#123;…&#125;
分析：ABD
177.当DOM加载完成后要执行的函数，下面哪个是正确的(C)
A	JQuery（expression, \[context]）
B.	JQuery（html, \[ownerDocument]）
C.	JQuery（callback）
分析：C
178.下面哪个是正确的（BD）
A	String temp\[ ] = new String&#123;“a”,”b”,”c”&#125;;
B.	String temp\[ ] = &#123;“a”,”b”,”c”&#125;;
C.	String temp= &#123;“a”,”b”,”c”&#125;;
D.	String\[ ] temp = &#123;“a”,”b”,”c”&#125;;
分析：BD
179.关于java.lang.String类，以下描述正确的一项是（A）
A	String类是final类故不可继承
B.	String类final类故可以继承
C.	String类不是final类故不可继承
D.	String;类不是final类故可以继承
分析：A
180.以下结构中，插入性能最高的是（B）
A	ArrayList
B.	Linkedlist
C.	tor
D.	Collection
分析：B
181.以下结构中，哪个具有同步功能（B）
A	HashMap
B.	ConcurrentHashMap
C.	WeakHashMap
D.	TreeMap
分析：B
182.以下结构中，哪个最适合当作stack使用（C）
A	LinkedHashMap
B.	LinkedHashSet
C.	LinkedList
分析：C183.以下锁机机制中，不能保证线程安全的是（C）
A	Lock
B.	Synchronized
C.	Volatile
分析：C
184.下面哪个流类属于面向字符的输入流（D）
A	BufferedWriter
B.	FileInputStream
C.	ObjectInputStream
D.	InputStreamReader
分析：D
不通过构造函数也能创建对象吗(A)
A	是
B.	否
分析：A
185.下面哪些是对称加密算法(A)
A	DES
B.	MD5
C.	DSA
D.	RSA
分析：A186.Map的实现类中，哪些是有序的，哪些是无序的，有序的是如何保证其有序性，你觉得哪个有序性性能更高，你有没有更好或者更高效的实现方式？
答：
1.Map的实现类有HashMap,LinkedHashMap,TreeMap
2.HashMap是有无序的，LinkedHashMap和TreeMap都是有序的（LinkedHashMap记录了添加数据的顺序；TreeMap默认是自然升序）1.  LinkedHashMap底层存储结构是哈希表+链表，链表记录了添加数据的顺序
2.  TreeMap底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性
3.  LinkedHashMap有序性能比较高，因为底层数据存储结构采用的哈希表
187.创建n多个线程，如何保证这些线程同时启动？看清，是“同时”。
答：
用一个for循环创建线程对象并调用start方法启动线程。
188.Java的类加载器都有哪些，每个类加载器都有加载那些类，什么是双亲委派模型，是做什么的？
答：
类加载器按照层次，从顶层到底层，分为以下三种：
（1）启动类加载器（Bootstrap ClassLoader）
这个类加载器负责将存放在JAVA\_HOME/lib下的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。
（2）扩展类加载器（Extension ClassLoader）
这个加载器负责加载JAVA\_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器
（3）应用程序类加载器（Application ClassLoader）
这个加载器是ClassLoader中getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，可直接使用这个加载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器
双亲委派模型：
双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器的代码
工作过程：
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
好处：
Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类Object，它放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类，判断两个类是否相同是通过classloader.class这种方式进行的，所以哪怕是同一个class文件如果被两个classloader加载，那么他们也是不同的类。
加载过程如图：189.Unsupported major.minor version 52是什么异常，怎么造成的，如何解决？
答：
问题的根本原因是工程中某个jar包的版本（jar包编译时的所用的jdk版本）高于工程build path中jdk的版本，这个是不兼容的! 编程中遇到此异常Unsupported major.minor version 52.0（根据版本号，这里可以为其他数值，52是1.8jdk jar包与 1.8以下低版本jdk不匹配），在将build path中jdk的版本调整与jar包匹配后，解决异常。190.垃圾回收器（GC）的基本原理是什么？垃圾回收器可以马上回收内存吗？如何通知虚拟机进行垃圾回收？
答：
1、对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是&quot;可达的&quot;，哪些对象是&quot;不可达的&quot;。当GC确定一些对象为&quot;不可达”时，GC就有责任回收这些内存空间。
2、可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。1.  System.gc();或者Runtime.getRuntime().gc();191.请问以下代码执行会打印出什么？
父类：
package com.bjsxt;
public class FatherClass &#123;
public FatherClass() &#123;
System.out.println(&quot;FatherClassCreate&quot;);
&#125;
&#125;子类：
package com.bjsxt;import com.bjsxt.FatherClass;
public class ChildClass extends FatherClass &#123;
public ChildClass() &#123;
System.out.println(&quot;ChildClass Create&quot;);
&#125;
public static void main(String\[] args) &#123;
FatherClass fc = new FatherClass();
ChildClass cc = new ChildClass();
&#125;
&#125;执行：C：&gt;java com.bjsxt.ChildClass
输出结果：？
答：
FatherClassCreate
FatherClassCreate
ChildClass Create
192.下面的代码在绝大部分时间内都运行得很正常，请问什么情况下会出现问题？根源在哪里？
package com.bjsxt;
import java.util.LinkedList;
public class Stack &#123;
LinkedList list = new LinkedList();
public synchronized void push(Object x) &#123;
synchronized (list) &#123;
list.addLast(x);
notify();
&#125;
&#125;
public  synchronized Object pop() throws  Exception&#123;
synchronized(list)&#123;
if(list.size()&lt;=0)&#123;
wait();
&#125;
return list.removeLast( );
&#125;
&#125;
&#125;
答：
将if( list.size() &lt;= 0 )\
改成：
while( list.size() &lt;= 0 )
193.同步和异步有何异同，在什么情况下分别使用它们？
答：
1.如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
2.当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。
3.举个例子: 打电话是同步 发消息是异步
194.Action是单实例还是多实例，为什么？
答：
struts2中action是多例的，即一个session产生一个action
背景:1.  Struts2会对每一个请求,产生一个Action的实例来处理.
2.  Spring的Ioc容器管理的bean默认是单实例的.
首先从数据安全性的问题上考虑，我们的Action应该保证是多例的，这样才不会出现数据问题。但是如果有的action比如只有admin才能操作，或者某些action，全站公用一个来提高性能，这样的话，就可以使用单例模式。
不过幸好，Spring的bean可以针对每一个设置它的scope，所以，上面的问题就不是问题了。如果用单例，就在spring的action bean配置的时候设置scope=”prototype”
如果是单例的话,若出现两个用户都修改一个对象的属性值,则会因为用户修改时间不同,两个用户访问得到的属性不一样,操作得出的结果不一样.
举个例子:有一块布长度300cm,能做一件上衣(用掉100cm)和一件裤子(用掉200cm);甲和乙同时访问得到的长度都是300cm,
甲想做上衣和裤子,他先截取100cm去做上衣,等上衣做完再去做裤子,而乙这时正好也拿100cm去做上衣,那好,等甲做完上衣再做裤子的时候发现剩下的布(100cm)已经不够做裤子了…..这就是影响系统的性能,解决的办法就是给甲和乙一人一块300cm的布,就不会出现布被别人偷用的事情,也是就单实例和多实例的区别
如果设置成单例，那么多个线程会共享一个ActionContext和ValueStack，这样并发访问的时候就会出现问题了
struts 2的Action是多实例的并非单例，也就是每次请求产生一个Action的对象。原因是：struts 2的Action中包含数据，例如你在页面填写的数据就会包含在Action的成员变量里面。如果Action是单实例的话，这些数据在多线程的环境下就会相互影响，例如造成别人填写的数据被你看到了。所以Struts2的Action是多例模式的。
问题出现了，可以让Struts2的action变成单例模式么？
Struts2中，可以使用注解开发,在Action上@Scope(“prototype”) 指定为多例 , 默认为singleton()单例)
基本上action的scope需要是prototype，就是每次请求都建立新的线程
不写的话，默认是singleton了
195.举例说明JAVA中如何解析xml，不同方式有和优缺点？
答：1.  DOM（Document Object Model)
DOM是用与平台和语言无关的方式表示XML文档的官方W3C标准。DOM是以层次结构组织的节点或信息片断的集合。这个层次结构允许开发人员在树中寻找特定信息。分析该结构通常需要加载整个文档和构造层次结构，然后才能做任何工作。由于它是基于信息层次的，因而DOM被认为是基于树或基于对象的。
【优点】
①允许应用程序对数据和结构做出更改。
②访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的数据。
【缺点】
①通常需要加载整个XML文档来构造层次结构，消耗资源大。
2.  SAX（Simple API for XML)
SAX处理的优点非常类似于流媒体的优点。分析能够立即开始，而不是等待所有的数据被处理。而且，由于应用程序只是在读取数据时检查数据，因此不需要将数据存储在内存中。这对于大型文档来说是个巨大的优点。事实上，应用程序甚至不必解析整个文档；它可以在某个条件得到满足时停止解析。一般来说，SAX还比它的替代者DOM快许多。
选择DOM还是选择SAX？ 对于需要自己编写代码来处理XML文档的开发人员来说， 选择DOM还是SAX解析模型是一个非常重要的设计决策。 DOM采用建立树形结构的方式访问XML文档，而SAX采用的是事件模型。
DOM解析器把XML文档转化为一个包含其内容的树，并可以对树进行遍历。用DOM解析模型的优点是编程容易，开发人员只需要调用建树的指令，然后利用navigation APIs访问所需的树节点来完成任务。可以很容易的添加和修改树中的元素。然而由于使用DOM解析器的时候需要处理整个XML文档，所以对性能和内存的要求比较高，尤其是遇到很大的XML文件的时候。由于它的遍历能力，DOM解析器常用于XML文档需要频繁的改变的服务中。
SAX解析器采用了基于事件的模型，它在解析XML文档的时候可以触发一系列的事件，当发现给定的tag的时候，它可以激活一个回调方法，告诉该方法制定的标签已经找到。SAX对内存的要求通常会比较低，因为它让开发人员自己来决定所要处理的tag.特别是当开发人员只需要处理文档中所包含的部分数据时，SAX这种扩展能力得到了更好的体现。但用SAX解析器的时候编码工作会比较困难，而且很难同时访问同一个文档中的多处不同数据。
【优势】
①不需要等待所有数据都被处理，分析就能立即开始。
②只在读取数据时检查数据，不需要保存在内存中。
③可以在某个条件得到满足时停止解析，不必解析整个文档。
④效率和性能较高，能解析大于系统内存的文档。
【缺点】
①需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等），文档越复杂程序就越复杂。
②单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，不支持XPath。
3.  JDOM(Java-based Document Object Model)
JDOM的目的是成为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。由于是第一个Java特定模型，JDOM一直得到大力推广和促进。正在考虑通过“Java规范请求JSR-102”将它最终用作“Java标准扩展”。从2000年初就已经开始了JDOM开发。
JDOM与DOM主要有两方面不同。首先，JDOM仅使用具体类而不使用接口。这在某些方面简化了API，但是也限制了灵活性。第二，API大量使用了Collections类，简化了那些已经熟悉这些类的Java开发者的使用。
JDOM文档声明其目的是“使用20%（或更少）的精力解决80%（或更多）Java/XML问题”（根据学习曲线假定为20%）。JDOM对于大多数Java/XML应用程序来说当然是有用的，并且大多数开发者发现API比DOM容易理解得多。JDOM还包括对程序行为的相当广泛检查以防止用户做任何在XML中无意义的事。然而，它仍需要您充分理解XML以便做一些超出基本的工作（或者甚至理解某些情况下的错误）。这也许是比学习DOM或JDOM接口都更有意义的工作。
JDOM自身不包含解析器。它通常使用SAX2解析器来解析和验证输入XML文档（尽管它还可以将以前构造的DOM表示作为输入）。它包含一些转换器以将JDOM表示输出成SAX2事件流、DOM模型或XML文本文档。JDOM是在Apache许可证变体下发布的开放源码。
【优点】
①使用具体类而不是接口，简化了DOM的API。
②大量使用了Java集合类，方便了Java开发人员。
【缺点】
①没有较好的灵活性。
②性能较差。
4.  DOM4J(Document Object Model for Java)
虽然DOM4J代表了完全独立的开发结果，但最初，它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项，它通过DOM4J API和标准DOM接口具有并行访问功能。从2000下半年开始，它就一直处于开发之中。
为支持所有这些功能，DOM4J使用接口和抽象基本类方法。DOM4J大量使用了API中的Collections类，但是在许多情况下，它还提供一些替代方法以允许更好的性能或更直接的编码方法。直接好处是，虽然DOM4J付出了更复杂的API的代价，但是它提供了比JDOM大得多的灵活性。
在添加灵活性、XPath集成和对大文档处理的目标时，DOM4J的目标与JDOM是一样的：针对Java开发者的易用性和直观操作。它还致力于成为比JDOM更完整的解决方案，实现在本质上处理所有Java/XML问题的目标。在完成该目标时，它比JDOM更少强调防止不正确的应用程序行为。
DOM4J是一个非常非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读写XML，特别值得一提的是连Sun的JAXM也在用DOM4J.
【优点】\
①大量使用了Java集合类，方便Java开发人员，同时提供一些提高性能的替代方法。\
②支持XPath。
③有很好的性能。
【缺点】
①大量使用了接口，API较为复杂。
二、比较
5.  DOM4J性能最好，连Sun的JAXM也在用DOM4J。目前许多开源项目中大量采用DOM4J，例如大名鼎鼎的Hibernate也用DOM4J来读取XML配置文件。如果不考虑可移植性，那就采用DOM4J.
6.  JDOM和DOM在性能测试时表现不佳，在测试10M文档时内存溢出，但可移植。在小文档情况下还值得考虑使用DOM和JDOM.虽然JDOM的开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来看，它确实没有值得推荐之处。另外，DOM仍是一个非常好的选择。DOM实现广泛应用于多种编程语言。它还是许多其它与XML相关的标准的基础，因为它正式获得W3C推荐（与基于非标准的Java模型相对），所以在某些类型的项目中可能也需要它（如在JavaScript中使用DOM）。
7.  SAX表现较好，这要依赖于它特定的解析方式－事件驱动。一个SAX检测即将到来的XML流，但并没有载入到内存（当然当XML流被读入时，会有部分文档暂时隐藏在内存中）。
我的看法：如果XML文档较大且不考虑移植性问题建议采用DOM4J；如果XML文档较小则建议采用JDOM；如果需要及时处理而不需要保存数据则考虑SAX。但无论如何，还是那句话：适合自己的才是最好的，如果时间允许，建议大家讲这四种方法都尝试一遍然后选择一种适合自己的即可。
196.char型变量中能不能存储一个中文汉字？
答：
1.java采用unicode编码，2个字节（16位）来表示一个字符， 无论是汉字还是数字，字母，或其他语言都可以存储。
2.char 在java中是2个字节，所以可以存储中文
197.Java线程中，sleep()和wait()区别
答：
sleep是线程类(Thread)的方法；作用是导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复；调用sleep()不会释放对象锁。
wait是Object类的方法；对此对象调用wait方法导致本线程放弃对象锁，进入等 待此对象的等待锁定池。只有针对此对象发出notify方法(或notifyAll)后本线程才进入对象锁定池，准备获得对象锁进行运行状态。
198.如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？
答：
因为类A、B不是接口，所以是不可以直接实现的，但可以将A、B类定义成父子类，那么C类就能实现A、B类的功能了。假如A为B的父类，B为C的父类，此时C就能使用A、B的功能。
199.一个类的构造方法是否可以被重载（overloading），是否可以被子类重写（overrding）？
答：
构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法
200.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort（）方法如何比较元素？
答：
TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会 回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections 工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。
201.Java中byte表示的数值范围是什么？
答：
范围是-128至127
202.如何将日期类型格式化为：2013-02-18 10:53:10？
public class TestDateFormat2 &#123;
public static void main(String\[] args) throws Exception &#123;
//第一步：将字符串（2013-02-18 10:53:10）转换成日期Date
DateFormat  sdf=new SimpleDateFormat(&quot;yyyy-MM-dd hh\:mm\:ss&quot;);
String sdate=&quot;2013-02-18 10:53:10&quot;;
Date date=sdf.parse(sdate);
System.out.println(date); //第二步：将日期Date转换成字符串String
 DateFormat  sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
 String sdate2=sdf2.format(date);
 System.out.println(sdate2);&#125;
&#125;203.List里面如何剔除相同的对象？
public class Test &#123;
public static void main(String\[] args) &#123;
List\&lt;String&gt; li1 = new ArrayList\&lt;String&gt;();
li1.add(&quot;8&quot;);
li1.add(&quot;8&quot;);
li1.add(&quot;9&quot;);
li1.add(&quot;9&quot;);
li1.add(&quot;0&quot;);
System.out.println(li1);
//方法:将List中数据取出来来存到Set中
HashSet\&lt;String&gt; set = new HashSet\&lt;String&gt;();
for(int i=0;i\&lt;li1.size();i++)&#123;
set.add(li1.get(i));
&#125;
System.out.println(set);
&#125;
&#125;
204.有两个字符串：目标串S=“s1s2.......sn”，模式串T=&quot;t1t2.......tm&quot;。若存在T的每个字符一次和S中的一个连续字符序列相等，则匹配成功，返回T中第一个字符在S中的位置。否则匹配不成功，返回0。写出你的算法，要求线性时间复杂度
答：
字符串匹配操作定义：
目标串S=&quot;S0S1S2...Sn-1&quot; , 模式串T=“T0T1T2...Tm-1”
对合法位置  0&lt;= i &lt;= n-m  （i称为位移）依次将目标串的字串 S\[i ... i+m-1] 和模式串T\[0 ... m-1] 进行比较，若：
1、S\[i ... i+m-1]  = T\[0 ... m-1]  ， 则从位置i开始匹配成功，称模式串 T 在目标串 S 中出现。
2、S\[i ... i+m-1]  != T\[0 ... m-1]  ，则从位置i开始匹配失败。
字符串匹配算法  —— Brute-Force 算法
字符串匹配过程中，对于位移i （i在目标串中的某个位置），当第一次 Sk != Tj 时，i 向后移动1位 ， 及 i = i+1，此时k退回到i+1位置 ;模式串要退回到第一个字符。该算法时间复杂度O（M\*N），但是实际情况中时间复杂度接近于O（M + N），以下为Brute-Force算法的Java实现版本：
public static int bruteForce(String target, String pattern, int pos) &#123;
if (target == null || pattern == null) &#123;
return -1;
&#125;
int k = pos - 1, j = 0, tLen = target.length(), pLen = pattern.length();
while (k &lt; tLen &amp;&amp; j &lt; pLen) &#123;
if (target.charAt(k) == pattern.charAt(j)) &#123;
j++;
k++;
&#125; else &#123;
k = k - j + 1;
j = 0;
&#125;
&#125;
if (j == pLen) &#123;
return k - j + 1;
&#125;
return -1;
&#125;
205.写一个方法，实现字符串的反转，如：输入abc，输出cba
public class Test &#123;
public static void main(String\[] args) &#123;
String result=reverse(&quot;abc&quot;);
System.out.println(result);
&#125;
public static String reverse(String str)&#123;
StringBuilder result=new StringBuilder(&quot;&quot;);
char\[] chArra=str.toCharArray();
for(int i=chArra.length-1;i&gt;=0;i--)&#123;
char ch=chArra\[i];
result.append(ch);
&#125;
return result.toString();
&#125;
&#125;
206.字符串如何转换为int类型
public class Test &#123;
public static void main(String\[] args) &#123;
 //方式一
 int num=Integer.parseInt(&quot;123&quot;);
 //方式二
 int num2=Integer.valueOf(&quot;123&quot;);
System.out.println(num+&quot;  &quot;+num2);
&#125;
&#125;
207.如何生成一个0-100的随机整数？
public class Test &#123;
public static void main(String\[] args) &#123;
int num=(int)(Math.random()\*101);
System.out.println(num);
&#125;
&#125;
208.不通过构造函数也能创建对象吗(A)
A.	是
B.	否
分析：答案：A
Java创建对象的几种方式（重要）：
(1) 用new语句创建对象，这是最常见的创建对象的方法。
(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
(3) 调用对象的clone()方法。
(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。
(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。
209.下面哪些是对称加密算法(A)
A.	DES
B.	MD5
C.	DSA
D.	RSA
分析：答案：A
解析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES
常用的非对称加密算法有：RSA、DSA、ECC
使用单向散列函数的加密算法：MD5、SHA210.下面的代码段，当输入为2的时候返回值是（C）
publicstaticint get Value(int i)&#123;
int result=0;
switch(i)&#123;
case 1:
result=result +i
case 2:
result=result+i*2
case 3:
result=result+i*3
&#125;
return result;
&#125;A	0
B.	2
C.	4
D.	10
分析：result = 0 + 2 \* 2;211.以下哪个是服务（C）
A.	kill\
B.	tar
C.	rsyne
D.	lsof
分析：答案\:c
A\:kill命令,常用于杀死进程;
B\:tar命令,tar命令是Unix/Linux系统中备份文件的可靠方法，几乎可以工作于任何环境中，它的使用权限是所有用户
C:类unix系统下的数据镜像备份工具
D:在终端下输入lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能212.以下可以实现负载均衡的是（C）
A.	nagios
B.	Jenkins
C.	nginx
D.	docker
分析：答案:  C   Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等213.在最佳情况下，以下哪个时间复杂度最高（D）
A.	直接插入排序
B.	直接选择排序
C.	冒泡排序
D.	归并排序
分析：答案: D
排序方法 最坏时间复杂度 最好时间复杂度 平均时间复杂度
直接插入 O(n2)O(n) O(n2)
简单选择 O(n2)O(n2)   O(n2)
冒泡排序 O(n2)   O(n)  O(n2)
快速排序 O(n2)   O(nlog2n)   O(nlog2n)
堆排序   O(nlog2n)O(nlog2n)   O(nlog2n)
归并排序 O(nlog2n) O(nlog2n)  O(nlog2n)214.以下Java代码段会产生几个对象
publicvoid test()&#123;
String a=&quot;a&quot;;
String b=&quot;b&quot;;
String c=&quot;c&quot;;
c=a+&quot;&quot;+b+&quot;&quot;+c;
System.out.print(c);
&#125;分析：答案: 一个对象，因为编译期进行了优化，3个字符串常量直接折叠为一个
215.Math.round（-7.2）的运行结果是。
分析：答案: -11
小数点后第一位=5
正数：Math.round(11.5)=12
负数：Math.round(-11.5)=-11
小数点后第一位&lt;5
正数：Math.round(11.46)=11
负数：Math.round(-11.46)=-11
小数点后第一位&gt;5
正数：Math.round(11.68)=12
负数：Math.round(-11.68)=-12
根据上面例子的运行结果，我们还可以按照如下方式总结，或许更加容易记忆：
参数的小数点后第一位&lt;5，运算结果为参数整数部分。
参数的小数点后第一位&gt;5，运算结果为参数整数部分绝对值+1，符号（即正负）不变。
参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分。 
终结：大于五全部加，等于五正数加，小于五全不加。216.请编写一段Java程序将两个有序数组合并成一个有序数组
import java.util.Arrays;publicclass Demo1 &#123;publicstaticvoid main(String[] args) &#123;
    
    int[] a = &#123; 1, 2, 3, 4, 5, 7, 8, 9, 10 &#125;;
    int[] b = &#123; 3, 5, 7, 9, 10 &#125;;
    int[] target = newint[a.length + b.length];	for (inti = 0; i&lt;a.length; i++)
        target[i] = a[i];
    for (intj = 0; j&lt;b.length; j++)
        target[a.length + j] = b[j];	Arrays.sort(target);
    for (inti = 0; i&lt;target.length; i++)
        System.out.println(target[i]);&#125;&#125;217.十进制数278的对应十六进制数
分析：十进制数278的对应十六进制数是116
218.线程的状态
分析：线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。
219.常见的RuntimeException
分析：NullPointerException：一般都是在null对象上调用方法了。
NumberFormatException：继承IllegalArgumentException，字符串转换为数字时。
比如int i= Integer.parseInt(&quot;ab3&quot;);
ArrayIndexOutOfBoundsException:数组越界
比如 int\[] a=new int\[3]; int b=a\[3]; 
StringIndexOutOfBoundsException：字符串越界
比如 String s=&quot;hello&quot;; char c=s.chatAt(6);
ClassCastException:类型转换错误
比如 Object obj=new Object(); String s=(String)obj; 
220.Java.util.Map的实现类有
分析：Java中的java.util.Map的实现类
1、HashMap
2、Hashtable
3、LinkedHashMap
4、TreeMap
221.Java中int.long占用的字节数分别是
分析：1：“字节”是byte，“位”是bit ；
2： 1 byte = 8 bit ；
char 在Java中是2个字节。java采用unicode，2个字节（16位）来表示一个字符。
short 2个字节
int 4个字节
long 8个字节
222.System.out.println(‘a’+1);的结果是
分析：&#39;a&#39;是char型，1 是int行，int与char相加，char会被强转为int行，char的ASCII码对应的值是97，所以加一起打印98
223.编写java，将“I follow Bill Gate.Tom Gate.John Gate”中的“Gate”全部替换为“Gates”
public classDemo1 &#123;
publicstaticvoid main(String\[] args) &#123;
String s=&quot;I follow Bill Gate.Tom Gate.John Gate&quot;;
System.out.println(s);
s=s.replaceAll(&quot;Gate&quot;,&quot;Gates&quot;);
System.out.println(s);
&#125;
&#125;
224.下列语句那一个正确（B）A	java程序经编译后会产生machine code
B.	java程序经编译后会产生 byte code
C.	java程序经编译后会产生DLL
D.	以上都不正确
分析：\:B  java程序编译后会生成字节码文件,就是.class文件
225.下列说法正确的有（C）
A	class中的constructor不可省略
B.	constructor必须与class同名，但方法不能与class同名
C.	constructor在一个对象被new时执行
D.	一个class只能定义一个constructor
分析：C226.下列运算符合法的是（B）
A	&amp;&amp;
B.	&lt;&gt;
C.	if
D.	=
分析：B &amp;&amp; 与运算227.执行如下程序代码(C)
a=0；c=0；
do&#123;
——c；
a=a-1；
｝while（a＞0）；
后，c的值是（）A	0
B.	1
C.	-1
D.	死循环
分析：C  do&#123;...&#125;while(...);语句至少执行一次228.下列哪一种叙述是正确的（D）
A	abstract修饰符可修饰字段、方法和类
B.	抽象方法的body部分必须用一对大括号｛｝包住
C.	声明抽象方法，大括号可有可无
D.	声明抽象方法不可写出大括号
分析：D abstract不能修饰字段。既然是抽象方法，当然是没有实现的方法，根本就没有body部分。229.下列语句正确的是（A）
A	形式参数可被视为local variable
B.	形式参数可被字段修饰符修饰
C.	形式参数为方法被调用时，真正被传递的参数
D.	形式参数不可以是对象
分析：答案A：
A：形式参数可被视为local variable。形参和局部变量一样都不能离开方法。都只有在方法内才会发生作用，也只有在方法中使用，不会在方法外可见。
B：对于形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。 不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是：方法内部类。  一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 
C：形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值（指针、引用皆在此列），也就是说真正被传递的是实参。
D：方法的参数列表指定要传递给方法什么样的信息，采用的都是对象的形式。因此，在参数列表中必须指定每个所传递对象的类型及名字。想JAVA中任何传递对象的场合一样，这里传递的实际上也是引用，并且引用的类型必须正确。--《Thinking in JAVA》230.一个数组，元素为从0到m的整数，判断其中是否有重复元素，使用java语言编写一个方法publicstaticboolean demo(int\[] arr)&#123;
for (inti = 0; i\&lt;arr.length; i++) &#123;
for (intj = i + 1; j\&lt;arr.length; j++) &#123;
if (arr\[i] == arr\[j]) &#123;
returntrue;
&#125;
&#125;
&#125;
returnfalse;
&#125;231.写一个方法，实现字符串的反转，如：输入abc，输出cba
publicstatic String reverse(String s) &#123;
intlength = s.length();
StringBuffer result = new StringBuffer(length);
for (inti = length - 1; i&gt;= 0; i--)
result.append(s.charAt(i));
returnresult.toString();
&#125;232.成员变量用static修饰和不用static修饰有什么区别？
i.1，两个变量的生命周期不同。
成员变量随着对象的创建而存在，随着对象的被回收而释放。
静态变量随着类的加载而存在，随着类的消失而消失。
2，调用方式不同。
成员变量只能被对象调用。
静态变量可以被对象调用，还可以被类名调用。
对象调用：p.country
类名调用 ：Person.country
3，别名不同。
成员变量也称为实例变量。
静态变量称为类变量。 
4，数据存储位置不同。
成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.
静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享   数据.
233.如果变量用final修饰，则怎样？如果方法final修饰，则怎样？
1、用final修饰的类不能被扩展，也就是说不可能有子类；
2、用final修饰的方法不能被替换或隐藏：
　　①使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；
　　②使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏	（hidden）；
3、用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：
　	　①静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，		赋值可以在其声明
　　　中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，	赋值只能在其
　　　声明中通过初始化表达式完成；
　　②实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通	过初始化表达式
　　　完成，也可以在实例初始化块或构造器中进行；
　　③方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体	（body）结束，在此
　　　期间其值不能改变；
　　④构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，	同时被初始化
　　　为对应实参值，终止于构造器体结束，在此期间其值不能改变；
　　⑤异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化	为实际的异常对象
　　　，终止于catch语句块结束，在此期间其值不能改变；
　　⑥局部变量在其值被访问之前必须被明确赋值；
234.下面所述步骤中，是创建进程做必须的步骤是（BC）
A	由调度程序为进程分配CPU
B.	建立一个进程控制块
C.	为进程分配内存
D.	为进程分配文件描述符
分析：BC235.下列叙述中正确的是（D）
A	循环队列有队头和队尾两个指针，因此，循环队列是非线性结构
B.	在循环队列中，只需要队头指针就能反映队列中元素的动态变化情况
C.	在循环队列中，只需要队尾指针就能反映队列中元素的动态变化情况
D.	在循环队列中元素的个数是由队头指针和队尾指针共同决定的
分析：正确答案：D
循环队列中元素的个数是由队首指针和队尾指针共同决定的，元素的动态变化也是通过队首指针和队尾指针来反映的，当队首等于队尾时，队列为空。236.某二叉树的先序遍历是12453，中序遍历是42513，那么其后序遍历是(A)
A	45231
B.	42351
C.	12345
D.	54321237.无锁化编程有哪些常见方法？
A	针对计数器，可以使用原子加
B.	只有一个生产者和一个消费者，那么就可以做到免锁访问环形缓冲区（Ring Buffer）
C.	RCU（Read-Copy-Update），新旧副本切换机制，对于旧副本可以采用延迟释放的做法
D.	CAS（Compare-and-Swap），如无锁栈，无锁队列等待
分析：答案：D。
A 这方法虽然不太好，但是常见
B ProducerConsumerQueue就是这个，到处都是
C linux kernel里面大量使用
D 本质上其实就是乐观锁，操作起来很困难。。单生产者多消费者或者多生产者单消费者的情况下比较常见，也不容易遇到ABA问题。
238.在N个乱序数字中查找第k大的数字，时间复杂度可以减小至(B)
A	O(N\*logN)
B.	O(N)
C.	O(1)
D.	O(2)
分析：答案：B
实现思路：利用hash保存数组中元素Si出现的次数，利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大数，平均情况下时间复杂度O(n)239.有一台带一个千兆网卡的服务器A，会把接收到的消息转发给另外两台带一个千兆网卡的服务器B和C，B和C上面的一个服务进程处理一条10K字节的消息需要2毫秒。如果在B和C上面各跑80个服务进程，在不考虑CPU负载和进程切换、内存占用、传输损耗和交互损耗的情况下，B和C服务器每秒一共大约可以处理\_\_\_\_\_\_条10K字节的消息
A	12500
B.	60000
C.	70000
D.	80000
分析：答案：A
1000Mbps=1000000Kbps=1000000/8 KBps = 125000KBps，也就是每秒125000KB，最多发送12500条。
240.以下指令集架构属于复杂指令集架构的是
A.	ARM
B.	MIPS
C.	SPARC
D.	以上皆不是
分析：241.在二进制数据中，小数点向右移一位，则数据
A.	除以10
B.	除以2
C.	乘以2
D.	乘以10
分析：可以看个例子
101.1  对应的十进制为 2^2*1 + 2^1*0 + 2^0*1 + 2^-1*1 = 5.5
小数点右移一位
1011 对应的十进制为 2^3*1 + 2^2*0 + 2^1*1 + 2^0*1 = 11
所以是扩大到原来的2倍242.设一颗二叉树中有3个叶子节点，有八个度为1的节点，则该二叉树中总的节点数为
A	12
B.	13
C.	14
D.	15
分析：选b 子叶节点是度为零的节点,而二叉树的性质可知,度是0的节点比度是2的节点数多1个,所以度是2的节点为2个,所以共有3+8+2=13243.在一个元素个数为N的数组里，找到升序排在N/5位置的元素的最优算法时间复杂度是
A	O(n)
B.	O(n log n)
C.	O(n (log n)2)
D.	O(n 3/2)
分析：244.下列叙述中正确的是
A	循环队列有队头和队尾两个指针，因此，循环队列是非线性结构
B.	在循环队列中，只需要队头指针就能反映队列中元素的动态变化情况
C.	在循环队列中，只需要队尾指针就能反映队列中元素的动态变化情况
D.	在循环队列中元素的个数是由队头指针和队尾指针共同决定的
分析：循环队列中元素的个数是由队首指针和队尾指针共同决定的，元素的动态变化也是通过队首指针和队尾指针来反映的，当队首等于队尾时，队列为空。245.面向对象的特征有哪些方面?
答：面向对象的特征主要有以下几个方面：
1、抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
2、继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。
3、封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。
4、多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。
246.访问修饰符public,private,protected,以及不写（默认）时的区别？
答：区别如下：
作用域    当前类  同包 子类 其他
public        √        √       √      √
protected  √        √       √      ×
default       √       √       ×      ×
private       √        ×      ×      ×
类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。
 
247.String 是最基本的数据类型吗?
答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。
248.float f=3.4;是否正确?
答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。
249.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?
答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。
250.Java 有没有goto?
答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）
251.int 和Integer 有什么区别?
答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
Java 为每个原始类型提供了包装类型：
原始类型: boolean，char，byte，short，int，long，float，double
包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。

简单的说，如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。
252.&amp;和&amp;&amp;的区别？
答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。
补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。
253.解释内存中的栈（stack）、堆(heap)和静态存储区的用法。
答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。
String str = new String(“hello”);
上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。
补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。
254.Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?
答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。
 
255.swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?
答：早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。
256.用最有效率的方法计算2乘以8?
答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。
补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 \* num &lt;==&gt; (num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方（32）再减去自身就相当于乘以31。现在的VM都能自动完成这个优化。

257.数组有没有length()方法?String 有没有length()方法？
答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。
258.在Java 中，如何跳出当前的多重嵌套循环？
答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）
259.构造器（constructor）是否可被重写（override）?
答：构造器不能被继承，因此不能被重写，但可以被重载。
260.两个对象值相同(x.equals(y) ++++== true)，但却可有不同的hash code，这句话对不对？
答：不对，如果两个对象x和y满足x.equals(y) ==++++ true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。
补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查“参数是否为这个对象的引用”；2. 使用instanceof操作符检查“参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。
261.是否可以继承String 类?
答：String 类是final类，不可以被继承。
补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。
262.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。
补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。
263.String 和StringBuilder、StringBuffer 的区别?
答：Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，
相同点：
它们都可以储存和操作字符串，同时三者都使用final修饰，都属于终结类不能派生子类，操作的相关方法也类似例如获取字符串长度等；
不同点：
其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的，而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改，在修改的同时地址值不会发生改变。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。在此重点说明一下，String、StringBuffer、StringBuilder三者类型不一样，无法使用equals()方法比较其字符串内容是否一样！
补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。
补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。
package com.bjsxt;
public class smallT &#123;\
public static void main(String\[] args) &#123;\
String a = &quot;Programming&quot;;\
String b = new String(&quot;Programming&quot;);\
String c = &quot;Program&quot; + &quot;ming&quot;;\
System.out.println(a == b);\
System.out.println(a == c);\
System.out.println(a.equals(b));\
System.out.println(a.equals(c));\
System.out.println(a.intern() == b.intern());\
&#125;\
&#125;   
解析：
String类存在intern()方法，含义如下：返回字符串对象的规范化表示形式。它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。
字符串比较分为两种形式，一种使用比较运算符”==”比较，他们比较的是各自的字符串在内存当中的地址值是否相同；一种是使用equals()方法进行比较，比较的是两个字符串的内容是否相同！结果如下：
a == b--&gt;false
a == c--&gt;true
a.equals(b)--&gt;true
a.equals(c)--&gt;true
a.intern() == b.intern()--&gt;true264.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?
答：Java的三大特征之一，多态机制，包括方法的多态和对象的多态；方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载（overload）发生在同一个类中，相同的方法，如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写（override）发生在子类与父类之间也就是继承机制当中，当父类的方法不能满足子类的要求，此时子类重写父类的方法；要求：方法名、形参列表相同；返回值类型和异常类型，子类小于等于父类；访问权限，子类大于等于父类，切记父类的私有方法以及被final修饰的方法不能被子类重写；重载对返回类型没有特殊的要求。
补充：华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，说出你的答案吧！
答：方法的重载，即使返回值类型不同，也不能改变实现功能相同或类似这一既定事实；同时方法的重载只是要求两同三不同，即在同一个类中，相同的方法名称，参数列表当中的参数类型、个数、顺序不同；跟权限修饰符和返回值类无关
 
char 型变量中能不能存贮一个中文汉字?为什么?
答：char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。
补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。 
抽象类（abstract class）和接口（interface）有什么异同?
答：含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。
接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。
下面比较一下两者的语法区别：
1.抽象类可以有构造方法，接口中不能有构造方法。
2.抽象类中可以有普通成员变量，接口中没有普通成员变量
3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。1.  抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然
eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
2.  抽象类中可以包含静态方法，接口中不能包含静态方法
3.  抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
4.  一个类可以实现多个接口，但只能继承一个抽象类。
下面接着再说说两者在应用上的区别：
接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：

父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。
备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。
266.静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？
答：内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示：

在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：
Outer outer = new Outer();
Outer.Inner1 inner1 = outer.new Innner1();
在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。
对于这些细节，只要在eclipse写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：
public class Outer
&#123;
public void start()
&#123;
new Thread(
new Runable()&#123;
public void run()&#123;&#125;;
&#125;
).start();
&#125;
&#125;最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类：
Outer.Inner inner = newOuter.Inner();
由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量(不能直接访问，需要创建外部类实例才能访问非静态变量)。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。
在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。
备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。
Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。

267.Java 中会存在内存泄漏吗，请简单描述。
答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。下面的例子也展示了Java中发生内存泄露的情况：
上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。 
268.抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?
答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。
269.静态变量和实例变量的区别？
答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存。两者的相同点：都有默认值而且在类的任何地方都可以调用。在Java开发中，上下文类和工具类中通常会有大量的静态成员。 
270.是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？
答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。 
271.如何实现对象克隆？
答：有两种方式：
1.实现Cloneable接口并重写Object类中的clone()方法；
2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。
下面是测试代码：
注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。

273.String s=new String(“xyz”);创建了几个字符串对象？
答：两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。
274.接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?
答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。
备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。
只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。 
275.一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。 
276.Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？
答：可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。 但是有一点需要注意，它只能继承一个类或一个接口。
277.内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？
答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。
    如果要访问外部类的局部变量，此时局部变量必须使用final修饰，否则无法访问。
278.Java 中的final关键字有哪些用法？
答：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写但是允许重载；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）；(4)修饰对象：对象的引用地址不能变，但是对象的初始化值可以变。

280.数据类型之间的转换:
1\)如何将字符串转换为基本数据类型？
2\)如何将基本数据类型转换为字符串？
答：
1\)调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；
2\)一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串 
281.如何实现字符串的反转及替换？
答：方法很多，可以自己写实现也可以使用String或StringBuffer / StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：
package com.bjsxt;
public class A&#123;\
public static String reverse(String originStr) &#123;\
if(originStr == null || originStr.length() &lt;= 1)\
return originStr;\
return reverse(originStr.substring(1)) + originStr.charAt(0);\
&#125;\
&#125;282.怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？
答：代码如下所示:
String s1 = &quot;你好&quot;;
String s2 = newString(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); 
在String类的构造方法当中，存在一个字符集设置的方法，具体如下：283.Java中的日期和时间：
1\)如何取得年月日、小时分钟秒？
2\)如何取得从1970年1月1日0时0分0秒到现在的毫秒数？
3\)如何取得某月的最后一天？
4\)如何格式化日期？
答：操作方法如下所示：
1\)创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值
2\)以下方法均可获得该毫秒数:
Calendar.getInstance().getTimeInMillis();\
System.currentTimeMillis();\
3\)示例代码如下:
Calendar time = Calendar.getInstance();\
time.getActualMaximum(Calendar.DAY\_OF\_MONTH);
4\)利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。
284.打印昨天的当前时刻。
答：
package com.bjsxt;
import java.util.Calendar;
public class YesterdayCurrent &#123;\
public static void main(String\[] args)&#123;\
Calendar cal = Calendar.getInstance();\
cal.add(Calendar.DATE, -1);\
System.out.println(cal.getTime());\
&#125;\
&#125; 
285.比较一下Java 和JavaSciprt
答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。
下面对两种语言间的异同作如下比较：
1）基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；
2）解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；
3）强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；
4）代码格式不一样。
补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。 
286.什么时候用assert？
答：assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。
断言用于调试目的：
assert(a &gt; 0); // throws an AssertionError if a &lt;= 0
断言可以有两种形式：
assert Expression1;
assert Expression1 : Expression2 ;
Expression1 应该总是产生一个布尔值。
Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。
断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记：
javac -source 1.4 Test.java
要在运行时启用断言，可使用-enableassertions 或者-ea 标记。
要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。
要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。 
287.Error 和Exception 有什么区别?
答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。
补充：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个错误无法恢复，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：
package com.bjsxt;
public class StackOverflowErrorTest &#123;\
public static void main(String\[] args) &#123;\
main(null);\
&#125;\
&#125;\
因此，用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再递归而是回溯了）。 
（error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。）
288.try&#123;&#125;里有一个return语句，那么紧跟在这个try后的finally&#123;&#125;里的code会不会被执行，什么时候被执行，在return前还是后?
答：会执行，在方法返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。 
(也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果：

运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。
)
289.Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？
答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。 
290.运行时异常与受检异常有何异同？
答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则：
不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
对可以恢复的情况使用受检异常，对编程错误使用运行时异常
避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常发生）
优先使用标准的异常
每个方法抛出的异常都要有文档
保持异常的原子性
不要在catch中忽略掉捕获到的异常 
(异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。)
291.列出一些你常见的运行时异常？
答：
ArithmeticException（算术异常）
ClassCastException （类转换异常）
IllegalArgumentException （非法参数异常）
IndexOutOfBoundsException （下表越界异常）
NullPointerException （空指针异常）
SecurityException （安全异常） 
NumberFormatException(数字格式化异常)
292.final, finally, finalize 的区别?
答：final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final 的方法也同样只能使用，不能在子类中被重写。finally：通常放在try…catch的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。finalize：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。
(final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……
finally是异常处理语句结构的一部分，表示总是执行。
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用
)
293.类ExampleA 继承Exception，类ExampleB 继承ExampleA
有如下代码片断：
try&#123;\
throw new ExampleB(&quot;b&quot;)\
&#125;catch（ExampleA e）&#123;\
System.out.println(&quot;ExampleA&quot;);\
&#125;catch（Exception e）&#123;\
System.out.println(&quot;Exception&quot;);\
&#125;\
&#125;请问执行此段代码的输出是什么？
答：输出：ExampleA。（根据里氏代换原则\[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）
补充：比此题略复杂的一道面试题如下所示（此题的出处是《Java编程思想》），说出你的答案吧！

294.List、Set、Map 是否继承自Collection 接口？
答：List、Set 的父接口是Collection，Map 不是其子接口，而是与Collection接口是平行关系，互不包含。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 295.说出ArrayList、Vector、LinkedList 的存储性能和特性？
答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（早期的JDK中使用的容器，除此之外Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），现在已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。
补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是HAS-A关系而不是IS-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是HAS-A关系（关联）或USE-A关系（依赖）。同理，Stack类继承Vector也是不正确的。 
296.Collection 和Collections 的区别？
答：Collection 是一个接口，它是Set、List等容器的父接口；
Collections 是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 
延伸：throw与throws之间的区别\
相同点： 都属于处理异常的方式
不同点：
位置不同：
throw是在语句内
throws是在语句上
内容不同：
throw后面跟的是具体异常类对象
throws后面跟的是具体异常类
Array与Arrays之间的区别
相同点：都可以访问 Java 数组对其进行操作。
不同点：所在的包不同  Array-----java.lang.reflect包
Arrays---java.util包
是否允许有子类---  Array因为使用final修饰不允许
\---  Arrays可以允许有子类
处理数组的方法
\---- Array类提供了动态创建和访问 Java 数组的方法。
\---Arrays包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂。
297.List、Map、Set 三个接口，存取元素时，各有什么特点？
答：List以特定索引来存取元素，可有重复元素。
Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树（红黑树）的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 
298.TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？
答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。
TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。
Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是是通过接口注入比较元素大小的算法，也是对回调模式的应用。

300.sleep()和yield()有什么区别?
答：
① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
④ sleep()方法比yield()方法（跟操作系统相关）具有更好的可移植性。 
301.当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法？
答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。 
只有等待当前线程执行完毕释放锁资源之后，其他线程才有可能进行执行该同步方法！
延伸  对象锁分为三种：共享资源、this、当前类的字节码文件对象
302.请说出与线程同步相关的方法。
答：
1.wait():使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
2.sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常；
3.notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
4.notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争；
5.JDK 1.5通过Lock接口提供了显式(explicit)的锁机制，增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁(unlock())的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；
6.JDK 1.5还提供了信号量(semaphore)机制，信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。
下面的例子演示了100个线程同时向一个银行账户中存入1元钱，在没有使用同步机制和使用同步机制情况下的执行情况。
银行账户类：
在没有同步的情况下，执行结果通常是显示账户余额在10元以下，出现这种状况的原因是，当一个线程A试图存入1元的时候，另外一个线程B也能够进入存款的方法中，线程B读取到的账户余额仍然是线程A存入1元钱之前的账户余额，因此也是在原来的余额0上面做了加1元的操作，同理线程C也会做类似的事情，所以最后100个线程执行结束时，本来期望账户余额为100元，但实际得到的通常在10元以下。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案：1.  在银行账户的存款（deposit）方法上同步（synchronized）关键字
按照上述三种方式对代码进行修改后，重写执行测试代码Test01，将看到最终的账户余额为100元。 

310.Java中如何实现序列化，有什么意义？
答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。
要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（参见Java面试题集1-29题） 
311.Java 中有几种类型的流？
答：两种流分别是字节流，字符流。
字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。
补充：关于Java的IO需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。
补充：下面用IO和NIO两种方式实现文件拷贝，这个题目在面试的时候是经常被问到的。

313.UML是什么？UML中有哪些图？
答：UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。
用例图：类图：时序图：

XML 文档定义有几种形式？它们之间有何本质区别？解析XML 文档有哪几种方式？
答：XML文档定义分为DTD和Schema两种形式；其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析。对XML的解析主要有DOM（文档对象模型）、SAX、StAX（JDK 1.6中引入的新的解析XML的方式，Streaming API for XML） 等，其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM 的树结构所造成的，这种结构占用的内存较多，而且DOM 必须在解析文件之前把整个文档装入内存,适合对XML 的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML 的顺序访问；如其名称所暗示的那样，StAX把重点放在流上。实际上，StAX与其他方法的区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（事实上 SAX 已经提出来了），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 
你在项目中哪些地方用到了XML？
答\:XML的主要作用有两个方面：数据交换（曾经被称为业界数据交换的事实标准，现在此项功能在很多时候都被JSON取代）和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理。目前很多软件都使用XML来存储配置信息，很多项目中我们通常也会将作为配置的硬代码（hard code）写在XML文件中，Java的很多框架也是这么做的。 
在进行数据库编程时，连接池有什么作用？
答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，再加上网络延迟，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有： C3P0、Proxool、DBCP、BoneCP、Druid等。
【补充】在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。 
什么是DAO模式？
答：DAO（DataAccess Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作。为了建立一个健壮的Java EE应用，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。
什么是ORM？
答：对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（可以用XML或者是注解），将Java程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。
给出下面的二叉树先序、中序、后序遍历的序列？答：先序序列：ABDEGHCF；中序序列：DBGEHACF；后序序列：DGHEBFCA。
补充：二叉树也称为二分树，它是树形结构的一种，其特点是每个结点至多有二棵子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树的遍历序列按照访问根节点的顺序分为先序（先访问根节点，接下来先序访问左子树，再先序访问右子树）、中序（先中序访问左子树，然后访问根节点，最后中序访问右子树）和后序（先后序访问左子树，再后序访问右子树，最后访问根节点）。如果知道一棵二叉树的先序和中序序列或者中序和后序序列，那么也可以还原出该二叉树。
例如，已知二叉树的先序序列为：xefdzmhqsk，中序序列为：fezdmxqhks，那么还原出该二叉树应该如下图所示：你知道的排序算法都哪些？用Java写一个排序系统
答：稳定的排序算法有：插入排序、选择排序、冒泡排序、鸡尾酒排序、归并排序、二叉树排序、基数排序等；不稳定排序算法包括：希尔排序、堆排序、快速排序等。
下面是关于排序算法的一个列表：下面按照策略模式给出一个排序系统，实现了冒泡、归并和快速排序。
package com.bjsxt;import java.util.Comparator;/\*\**   排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)
326.Java跨平台原理（字节码文件、虚拟机）C/C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。
Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。
字节码文件不面向任何具体平台，只面向虚拟机。
Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。
Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C/C++要低。
Java的跨平台原理决定了其性能没有C/C++高327.Java的安全性
语言层次的安全性主要体现在：
Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。
垃圾回收机制：不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。
异常处理机制：Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。
强制类型转换：只有在满足强制转换规则的情况下才能强转成功。
底层的安全性可以从以下方面来说明
Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。
在运行环境提供了四级安全性保障机制：
字节码校验器 -类装载器 -运行时内存布局 -文件访问限制
328.Java三大版本
Java2平台包括标准版（J2SE）、企业版（J2EE）和微缩版（J2ME）三个版本：
Standard Edition(标准版) J2SE 包含那些构成Java语言核心的类。
比如：数据库连接、接口定义、输入/输出、网络编程
Enterprise Edition(企业版) J2EE 包含J2SE 中的类，并且还包含用于开发企业级应用的类。
比如：EJB、servlet、JSP、XML、事务控制
Micro Edition(微缩版) J2ME 包含J2SE中一部分类，用于消费类电子产品的软件开发。
比如：呼机、智能卡、手机、PDA、机顶盒
他们的范围是：J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类
应用场合，API的覆盖范围各不相同。
329.Java开发运行过程
在安装好JDK并配置好path、classpath后开发运行步骤如下：
1、可以用任何文本编辑器创建并编辑Java源程序，Java源程序用“.java”作为文件扩展名
2、编译Java源程序编译器，使用命令“javac”编译“java源程序文件名.java”。最后编译成Java虚拟机能够明白的指令集合，且以字节码的形式保存在文件中。通常，字节码文件以“.class”作为扩展名。
3、执行java程序，使用“java”命令运行class（字节码）文件“java文件名”，Java解释器会读取字节码，取出指令并且翻译成计算机能执行的机器码，完成运行过程。330.Java开发环境配置
具体配置步骤如下：
0）找到自己的jdk安装路径，如：C:\Java\jdk1.7.0\_60\bin
1）右击桌面“我的电脑”，选择“属性”
2）选中“高级系统设置”--&gt;高级--&gt;环境变量设置
3）在系统变量中点击”新建”按钮，
变量名：JAVA\_HOME
变量值：C:\Java\jdk1.7.0\_60
4\)在系统变量中找到“path”并选中，点击“编辑”，在最后面或最前面
输入%JAVA\_HOME%\bin;
5）在系统变量中点击”新建”按钮，
变量名\:CLASSPATH
变量值: .;%JAVA\_HOME%\lib\dt.jar;%JAVA\_HOME%\lib\tools.jar;
6\)一路点击三个”确定”按钮，配置完毕。
331.什么是JVM？什么是JDK？ 什么是JRE？
JVM ：JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。
JRE：JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。 
JDK：JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，那 让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。
bin:最主要的是编译器(javac.exe)
include\:java和JVM交互用的头文件
lib：类库      
jre\:java运行环境 
（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。
4、JDK,JRE,JVM三者关系概括如下：
jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。
Java三种注释类型
共有单行注释、多行注释、文档注释3种注释类型。使用如下：
单行注释，采用“//”方式.只能注释一行代码。如：//类成员变量
多行注释，采用“/*...*/”方式，可注释多行代码，其中不允许出现嵌套。如：
/*System.out.println(&quot;a&quot;);
System.out.println(&quot;b&quot;);
System.out.println(&quot;c&quot;);*/
文档注释，采用“/**...\*/”方式。如：
/***   子类  Dog
*   @author Administrator
*\*/
public class Dog extends Animal&#123;&#125;332.8种基本数据类型及其字节数
数据类型	关键字	字节数
数值型	整数型	byte	1
short	2
int	4
long	8
浮点型	float	4
double	8
布尔型		boolean	1（位）
字符型		char	2333.i++和++i的异同之处
共同点：
1、i++和++i都是变量自增1，都等价于i=i+1
2、如果i++,++i是一条单独的语句，两者没有任何区别
3、i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。
不同点：
如果i++,++i不是一条单独的语句，他们就有区别
i++ ：先运算后增1。如：int x=5;
int y=x++;
System.out.println(&quot;x=&quot;+x+&quot;, y=&quot;+y);
//以上代码运行后输出结果为：x=6, y=5++i ： 先增1后运算。如： 
 
int x=5;
int y=++x;
System.out.println(&quot;x=&quot;+x+&quot;, y=&quot;+y);
//以上代码运行后输出结果为：x=6, y=6334.&amp;和&amp;&amp;的区别和联系，|和||的区别和联系
&amp;和&amp;&amp;的联系(共同点)：
&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。
操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，
表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，
情况1：当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。
情况2：当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。
表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。
&amp;和&amp;&amp;的区别(不同点)：
(1)、&amp;逻辑运算符称为逻辑与运算符，&amp;&amp;逻辑运算符称为短路与运算符，也可叫逻辑与运算符。
对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。
对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。
综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。
、&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。
|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似
</code></pre></jsp></jsp></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/7e68be57c290.html" rel="prev" title="消息队列（MQ）"><i class="fa fa-angle-left"></i> 消息队列（MQ）</a></div><div class="post-nav-item"><a href="/publishes/22829df8f04f.html" rel="next" title="Java基础">Java基础 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.6m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">24:05</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>