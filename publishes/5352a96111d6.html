<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="说说反射的用途及实现 Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架 Java反射的主要功能： 确定一个对象的类 取出类的modifiers,数据成员,方法,构造器,和超类. 找出某个接口里定义的常量和方法说明. 创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象). 取得和设定"><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="说说反射的用途及实现 Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架 Java反射的主要功能： 确定一个对象的类 取出类的modifiers,数据成员,方法,构造器,和超类. 找出某个接口里定义的常量和方法说明. 创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象). 取得和设定"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T01:28:17.000Z"><meta property="article:modified_time" content="2024-01-03T18:06:26.413Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="java"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/5352a96111d6.html","path":"publishes/5352a96111d6.html","title":"Java基础"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java基础 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">说说反射的用途及实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E5%86%99%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">重载 重写（覆写）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC-%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">JDBC 流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">HashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashSet-%E5%92%8C-HashMap-%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">HashSet 和 HashMap 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">HashMap 和 ConcurrentHashMap 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">Java中创建线程主要有三种方式：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sleep-%E3%80%81join%EF%BC%88%EF%BC%89%E3%80%81yield%EF%BC%88%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">sleep() 、join（）、yield（）有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">java反射的作用与原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9"><span class="nav-number">10.</span> <span class="nav-text">泛型常用特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90XML%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%89%B9%E7%82%B9%EF%BC%9ADOM%E3%80%81SAX"><span class="nav-number">11.</span> <span class="nav-text">解析XML的几种方式的原理与特点：DOM、SAX</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">58</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java基础 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java基础</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 02:06:26" itemprop="dateModified" datetime="2024-01-04T02:06:26+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>335k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5:04</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h1><ul><li>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架</li><li>Java反射的主要功能：<ul><li>确定一个对象的类</li><li>取出类的modifiers,数据成员,方法,构造器,和超类.</li><li>找出某个接口里定义的常量和方法说明.</li><li>创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).</li><li>取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.</li><li>在运行时刻调用动态对象的方法.</li></ul></li></ul><h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul><li>方法名称相同，参数的类型或个数不同</li><li>方法名称、参数类型、返回值类型全部相同</li><li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li><li>范围 发生在一个类中 发生在继承类中</li><li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li><li>反射的应用很多，很多框架都有用到<ul><li>spring 的 ioc&#x2F;di 也是反射…</li><li>javaBean和jsp之间调用也是反射…</li><li>struts的 FormBean 和页面之间…也是通过反射调用…</li><li>JDBC 的 classForName()也是反射…</li><li>hibernate的 find(Class clazz) 也是反射…</li><li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li></ul></li></ul><h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul><li>加载JDBC驱动程序</li><li>提供JDBC连接的URL</li><li>创建数据库的连接</li><li>创建一个Statement</li><li>执行SQL语句</li><li>处理结果</li><li>关闭JDBC对象</li></ul><h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><p>1.hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和<br>containsKey（）方法。<br>2.hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。<br>3.hashMap允许空键值，而hashTable不允许。<br>注意：<br>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状<br>态。<br>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p><h1 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h1><p>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是<br>用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过<br>key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象</p><h1 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h1><p>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上<br>都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更<br>好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>HashMap 的工作原理及代码实现<br>参考：<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，<br>当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时<br>间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，<br>16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一<br>个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来<br>决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步<br>机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只<br>是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个<br>Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此<br>HashTable已经被淘汰了。</p><h1 id="Java中创建线程主要有三种方式："><a href="#Java中创建线程主要有三种方式：" class="headerlink" title="Java中创建线程主要有三种方式："></a>Java中创建线程主要有三种方式：</h1><p>一、继承Thread类创建线程类<br>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完<br>成的任务。因此把run()方法称为执行体。<br>（2）创建Thread子类的实例，即创建了线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。getName()方法返<br>回调用该方法的线程的名字。<br>二、通过Runnable接口创建线程类<br>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是<br>该线程的线程执行体。<br>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该<br>Thread对象才是真正的线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>三、通过Callable和Future创建线程<br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且<br>有返回值。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对<br>象封装了该Callable对象的call()方法的返回值。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><h1 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h1><p>1、sleep()方法<br>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度<br>程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如<br>果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常<br>比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一<br>个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级<br>的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。<br>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的<br>线程有执行的机会。<br>2、yield()方法<br>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方<br>法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态<br>后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也<br>和sleep()方法不同。<br>3、join()方法<br>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，<br>B不能工作。<br>保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有<br>存活，则当前线程不需要停止。<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲<br>突。<br>在Java里，线程安全一般体现在两个方面：<br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关<br>键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有<br>synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，<br>问题就出现了。<br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在<br>java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>volatile 实现原理<br>聊聊并发（一）——深入分析Volatile的实现原理<br>悲观锁 乐观锁<br>乐观锁 悲观锁<br>是一种思想。可以用在很多方面。<br>比如数据库方面。<br>悲观锁就是for update（锁定查询的行）<br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读­<br>比较­写的操作。）<br>JDK方面：<br>悲观锁就是sync<br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。<br>乐观锁就认为，基本没人抢。<br>CAS 乐观锁<br>乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出<br>当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重<br>复读­比较­写的操作。<br>CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。<br>CAS顶多算是乐观锁写那一步操作的一种实现方式罢了，不用CAS自己加锁也是可以的。<br>ABA 问题<br>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A，当前线程的CAS<br>操作无法分辨当前V值是否发生过变化。<br>参考：<br>Java CAS 和ABA问题<br>乐观锁的业务场景及实现方式<br>乐观锁（Optimistic Lock）：<br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，<br>但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不<br>进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，<br>期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可<br>能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量<br>的查询操作，降低了系统的吞吐量。<br>核心篇<br>数据存储<br>MySQL 索引使用的注意事项<br>参考：<br>mysql索引使用技巧及注意事项<br>说说反模式设计<br>参考：<br>每个程序员要注意的 9 种反模式<br>说说分库与分表设计<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策<br>说说 SQL 优化之道<br>sql优化的几种方法<br>微服务哪些框架<br>Spring Cloud、Dubbo、Hsf等<br>你怎么理解 RPC 框架<br>RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这<br>个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。<br>说说 RPC 的实现原理<br>参考：<br>你应该知道的 RPC 原理<br>从零开始实现RPC框架 ­ RPC原理及实现</p><p>分布式<br>谈谈业务中使用分布式的场景<br>一、解决java集群的session共享的解决方案：<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>二、分布式事务的解决方案:<br>1.TCC解决方案：try confirm cancel。<br>参考：<br>为什么说传统分布式事务不再适用于微服务架构？<br>Session 分布式方案<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库<br>更多Java技术资料视频分享+QQ2118797017<br>来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>分布式锁的场景<br>比如交易系统的金额修改，同一时间只能又一个人操作，比如秒杀场景，同一时间只能一个<br>用户抢到，比如火车站抢票等等<br>分布式锁的实现方案<br>26. 基于数据库实现分布式锁<br>27. 基于缓存实现分布式锁<br>28. 基于Zookeeper实现分布式锁<br>参考：<br>分布式锁的多种实现方式<br>分布式事务<br>参考：<br>深入理解分布式事务,高并发下分布式事务的解决方案<br>集群与负载均衡的算法与实现<br>参考：<br>负载均衡算法及手段<br>说说分库与分表设计<br>参考：<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>安全&amp;性能<br>安全问题<br>安全要素与 STRIDE 威胁<br>防范常见的 Web 攻击<br>XSS攻击<br>跨站脚本攻击;<br>是什么：攻击者向有XSS漏洞的网站中输入恶意的HTML代码，当其浏览器浏览该网站<br>时，这段HTML代码会自­ ­ 动执行。（理论上所有可以输入的地方没有对输入的数据进<br>行处理，都会存在XSS攻击）;<br>危害： 盗取用户cookie，破坏页面结构，重定向到其他网站;<br>防御：对用户输入的信息进行处理，只允许合法的值;<br>CSRF攻击<br>跨站请求伪造<br>是什么：攻击者盗用了你的身份，以你的名义发送恶意请求;<br>危害：以你的名义发送邮件，盗取帐号，购买东西等;<br>原理： 首先个登录某网站，并在本地生成cookie;然后在不登出的情况下，访问危害网<br>站。<br>防御： 可以从服务端和客户端两方面进行考虑。但是在服务端的效果好。<br>a. 随机的cookie<br>b. 添加验证码<br>c. 不同的表单包含一个不同的伪随机值<br>注意：如果用户在一个站点上同时打开了两个不同的表单。CSRF保护措施不应该影响<br>到他对任何表单的提交<br>SQL注入<br>是什么：通过sql命令伪装成正常的http请求参数，传递到服务端，服务器执行sql命令<br>造成对数据库进行攻击<br>原理：sql语句伪造参数，然后在对参数机型拼接后形成破坏性的sql语句，最后导致数<br>据库收到攻击<br>防御：<br>a. 对参数进行转义<br>b. 数据库中的密码不应明文存储，可以对密码使用md5进行加密。<br>DDOS攻击（分布式拒绝服务攻击）<br>是什么：简单来说就是ifasong大量的请求使服务器瘫痪。<br>被攻击的原因：服务器带宽不足，不能挡住攻击者的攻击流量。<br>防御：<br>a. 最直接的方法就是增加带宽;<br>b. 使用硬件防火墙;<br>c. 优化资源使用提高 web server 的负载能力<br>服务端通信安全攻防<br>HTTPS 原理剖析<br>HTTPS 降级攻击<br>授权与认证<br>基于角色的访问控制<br>基于数据的访问控制<br>基于角色的访问控制，只验证访问数据的角色，但是没有对角色内的用户做细分。举个例<br>子，用户甲与用户乙都具有用一个角色，但是如果只建立基于角色的访问控制，那么用户甲<br>可以对用户乙的数据进行任意操作，从而发生了越权访问。因此，在业务场景中仅仅使用基<br>于角色的访问控制是不够的，还需要引入基于数据的访问控制。如果将基于角色的访问控制<br>视为一种垂直权限控制，那么，基于数据的访问控制就是一种水平权限控制。在业务场景<br>中，往往对基于数据的访问控制不够重视，举个例子，评论功能是一个非常常见的功能，用<br>户可以在客户端发起评论，回复评论，查看评论，删除评论等操作。一般情况下，只有本人<br>才可以删除自己的评论，如果此时，业务层面没有建立数据的访问控制，那么用户甲可以试<br>图绕过客户端，通过调用服务端RESTful API 接口，猜测评论 ID 并修改评论 ID 就可以删除<br>别人的评论。事实上，这是非常严重的越权操作。除此之外，用户之间往往也存在一些私有<br>的数据，而这些私有的数据在正常情况下，只有用户自己才能访问。<br>基于数据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引<br>起重视。这里，再次使用删除评论的案例，通过 Java 语言进行介绍。在这个案例中，核心<br>的代码片段在于，判断当前用户是否是评论的创建者，如果是则通过，不是则报出没有权限<br>的错误码。那么，这样就可以很好地防止数据的越权操作。<br>总结下，基于角色的访问控制是一种垂直权限控制，通过建立用户与角色的对应关系，使得<br>不同角色之间具有高低之分。用户根据拥有的角色进行操作与资源访问。基于数据的访问控<br>制是一种水平权限控制，它对角色内的用户做细分，确保用户的数据不能越权操作。基于数<br>据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引起重<br>视。<br>性能优化<br>性能指标有哪些<br>如何发现性能瓶颈<br>性能调优的常见手段<br>说说你在项目中如何进行性能调优</p><p>1.八种基本数据类型的大小，以及他们的封装类<br>double—Double 8位0.0d<br>float —Float 4位0.0f<br>long —Long8位0L<br>int —Integer 4位0<br>short —Short 2位(short)0<br>byte —byte1位(byte)0<br>char —Character 2位null\u0000<br>boolean —Boolean – false<br>2.引用数据类型<br>数组，类，接口<br>3.Switch能否用string做参数<br>以前只能支持byte、short、char、int，可以强转<br>Jdk7.0以后可以，整型、枚举类型、boolean、字符串都可以<br>4.equals与&#x3D;&#x3D;的区别*<br>&#x3D;&#x3D;比较的是2个对象的地址，而equals比较的是2个对象的内容<br>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。<br>Equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。<br>5.自动装箱，常量池<br>自动装箱：基本数据类型对象类型<br>自动拆箱：对象类型基本数据类型<br>常量池：Byte,Short,Integer,Long,Character在自动装箱时对于值从–128到127之间的值（共享），会存在内存中被重用<br>字符串常量池<br>常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s &#x3D; “java”这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。<br>6.Object有哪些公用方法<br>clone(),hashCode(),equals(),notify(),notifyAll(),wait(),getClass(),toString,finalize()<br>8.Hashcode的作用*<br>利用哈希算法，配合基于散列的集合一起正常运行，Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值，降低equals的调用，实现存放的值不会重复。<br>Note:重写equals必须重写hashcode方法，equals相等，hashcode也必须相等。<br>一般对于存放到Set集合或者Map中键值对的元素，需要按需要重写hashCode与equals方法，以保证唯一性！<br>例如hashset存放多个对象，重写equals和hashcode<br>两个对象相等，其HashCode一定相同;<br>两个对象不相等，其HashCode有可能相同;<br>HashCode相同的两个对象，不一定相等;<br>HashCode不相同的两个对象，一定不相等;<br>9.HashMap的hashcode的作用*<br>Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 equals方法可用于保证元素不重复，但是，如果每增加一个元素就检查一次，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次equals方法。这显然会大大降低效率。<br>HashMap的数据结构是 数组+链表形式存储数据，继承AbstractMap，实现Map接口，主要用于查找的快捷性。<br>10.为什么重载hashCode方法？*<br>一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是object对象，必须重载hashCode和equal方法。<br>11.ArrayList、LinkedList、Vector的区别*<br>ArrayList： 线程不安全，数组，适合查找，可自动扩容50%<br>三个构造器，无参，容量，Collection接口，transient Object[] elementData;不被序列化。<br>LinkedList：线程不安全，链表，审核插入，删除<br>Vector： 线程安全，数组，适合查找，可自动扩容100%<br>12.String、StringBuffer与StringBuilder的区别*<br>String 是final修饰的，字符串常量，String对象一旦创建之后该对象是不可更改的<br>StringBuffer 字符串变量，对象可变，线程安全，适合多线程下字符缓冲区大量操作<br>StringBuider 字符串变量，对象可变，线程不安全，适用单线程下载字符缓冲区进行大量操作的情况，都是继承AbstractStringBuilder super.容量为16<br>13.Map、Set、List、Queue、Stack的特点与用法。<br>Map map集合，k-v键值对存储<br>HashTable 和 HashMap 是 Map 的实现类   <br>HashTable 是线程安全的，不能存储 null 值   <br>HashMap 不是线程安全的，可以存储 null 值  <br>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。<br>Set 集合，无序，不重复<br>List 数组集合，ArrayList ， Vector ， LinkedList 是 List 的实现类<br>ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的<br>LinkedList 是线程不安全的，底层是由链表实现的   <br>Queue 队列，提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。<br>Stack 栈，继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。<br>HashMap和HashTable的区别<br>14.JDK7与JDK8中HashMap的实现*<br>JDK8在JDK7的基础上引入了红黑树-b，因为链表过长，会导致效率很低，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率<br>15.HashMap和ConcurrentHashMap的区别，HashMap的底层源码*<br>HashMap是线程不安全的，ConcurrentHashMap是线程安全的，适用于高并发，ConcurrentHashMap就是一个分段的hashtable，根据自定的hashcode算法生成的对象来获取对应hashcode的分段块进行加锁，不用整体加锁，提高了效率。<br>HashMap的get（key）方法是获取key的hash值，计算hash&amp;（n-1）得到在链表数组中的位置first&#x3D;tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可。<br>HashMap的put（key）方法是判断键值对数组tab[]是否为空或位null，否则以默认大小resize()；根据键值key计算hash值得到插入的数组索引i，如果tab[i]&#x3D;&#x3D;null,直接新建节点添加，否则判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可)，分别处理。<br>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比<em>Node.length）重新调整HashMap大小 变为原来2倍大小,扩容很耗时<br>16.ConcurrentHashMap能完全替代HashTable吗？<br>Hash table虽然性能上不如ConcurrentHashMap，但并不能完全被取代，两者的迭代器的一致性不同的，ConcurrentHashMap由于分段锁，弱一致性主要是为了提升效率。<br>强一致性就如hashtable一样，锁整个map。<br>17.为什么HashMap是线程不安全的</em><br>在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，如图中a1、a2，这个时候需要解决碰撞冲突，而解决冲突的办法上面已经说过，对于链表的结构在这里不再赘述，暂且不讨论是从链表头部插入还是从尾部初入，这个时候两个线程如果恰好都取到了对应位置的头结点e1，而最终的结果可想而知，a1、a2两个数据中势必会有一个会丢失<br>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。<br>18.多并发情况下HashMap是否还会产生死循环*<br>不会，jdk1.8版本以后已经没有这个问题了，没有transfer这个函数了do while可能造成的死循环，对原有造成死锁的关键原因点（新table复制在头端添加元素）改进为依次在末端添加新的元素<br>19.TreeMap、HashMap、LindedHashMap的区别*<br>LinkedHashMap可以保证HashMap集合有序。存入的顺序和取出的顺序一致。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。<br>HashMap不保证顺序，即为无序的，具有很快的访问速度。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步。<br>20.Collection包结构，与Collections的区别<br>Collection是个java.util下的接口，它是各种集合结构的父接口。<br>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<br>21.try?catch?finally，try里有return，finally还执行么<br>如果finally没有return 相同返回值变量，则返回try里面的return，否则finally 的return 值会影响 try里面return结果。<br>finally还是会执行的，除非中途遇到jvm退出。<br>22.Excption与Error包结构，OOM你遇到过哪些情况，SOF你遇到过哪些情况<br>都是Throwable的子类，Exception指出了合理的应用程序想要捕获的条件。Error 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件<br>Java Heap 溢出，虚拟机栈和本地方法栈溢出，运行时常量池溢出，方法区溢出<br>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br>23.Java(OOP)面向对象的三个特征与含义<br>封装：可见性封装，setget读写，将类的某些特征隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。<br>继承：子类继承父类，可以得到父类的全部属性和方法（除了父类中的构造方法），java中的多继承可以通过接口来实现。<br>多态：一种是编译时多态，另外一种是运行时多态，编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。<br>26.Static?class?与non?static?class的区别<br>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。<br>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。<br>27.foreach与正常for循环效率对比<br>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。<br>28.Java?IO与NIO*<br>NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I&#x2F;O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征<br>IO是面向流的，NIO是面向块（缓冲区）的。<br>IO是阻塞的，NIO是非阻塞的。<br>多连接，少数据可以用NIO<br>少连接，大数据可以用IO</p><h1 id="java反射的作用与原理"><a href="#java反射的作用与原理" class="headerlink" title="java反射的作用与原理"></a>java反射的作用与原理</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>在JAVA中，只有给定类的名字，就可以通过反射机制来获取类的所有信息，可以动态的创建对象和编译。<br>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。</p><h1 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h1><p>泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。<br>使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。<br>通过类型擦除来实现</p><h1 id="解析XML的几种方式的原理与特点：DOM、SAX"><a href="#解析XML的几种方式的原理与特点：DOM、SAX" class="headerlink" title="解析XML的几种方式的原理与特点：DOM、SAX"></a>解析XML的几种方式的原理与特点：DOM、SAX</h1><p>DOM分析器是把整个XML文档转化为DOM树放在内存中<br>SAX解析采用事件驱动，通过事件处理函数实现对xml文档的访问。</p><p>21.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？<br>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>22.Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？<br>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。<br>而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性<br>Put和读取多线程导致的问题。<br>23.ConcurrentHashMap的并发度是什么？*<br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势<br>24.ReentrantReadWriteLock读写锁的使用？<br>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 <br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；<br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！<br>36.高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？*<br>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看： 　　<br>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 　　<br>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换<br>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。<br>39.如果同步块内的线程抛出异常会发生什么？<br>只要退出了synchronized块，无论是正常还是异常，都会释放锁。<br>40.并发编程（concurrency）并行编程（parallellism）有什么区别？*<br>并发（concurrency）和并行（parallellism）是：<br>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>解释三：并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群<br>41.如何保证多线程下 i++ 结果正确？<br>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。<br>42.一个线程如果出现了运行时异常会怎么样?<br>如果该异常被捕获或抛出，则程序继续运行。 <br>如果异常没有被捕获该线程将会停止执行。 <br>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理<br>46.Java中用到的线程调度算法是什么*<br>操作系统的核心，它实际就是一个常驻内存的程序，不断地对线程队列进行扫描，利用特定的算法（时间片轮转法、优先级调度法、多级反馈队列调度法等）找出比当前占有CPU的线程更有CPU使用权的线程，并从之前的线程中收回处理器，再使待运行的线程占用处理器。<br>10.分派：静态分派与动态分派。<br>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的<br>动态分派：（重写）<br>数据结构与算法<br>1.链表与数组。<br>数组：ArrayList—静态分配内存，内存连续。数组元素在栈区。<br>链表：LinkedList—手持下一个人的地址，动态内存分配，内存不连续。数组元素在堆区<br>2.队列和栈，出栈与入栈。<br>queue队列是先进先出<br>入栈，s.push(x)<br>出栈，s.pop()<br>访问栈顶，s.top()<br>判断栈空，s.empty()<br>访问栈中的元素个数，s.size()<br>stack栈是先入后出<br>入队，q.push(x)<br>出队，q.pop()<br>访问队首元素，q.front()、访问队尾元素，q.back()<br>判断队列空，q.empty()<br>访问队列中的元素个数，q.size()<br>3.链表的删除、插入、反向。*<br>数据域，指针域，当前节点<br>删除需要找到上一个节点，然后指向下下节点，size减去1<br>插入，找上一个节点，设置next到新节点，新节点初始化上一节点的current.next<br>反向：head.getnext获取末尾节点，然后以此重新指向反转（递归反转法）<br>遍历反转法，按顺序依次反转。<br>4.字符串操作。<br>(1)字符串的连接<br>public String concat(String str) <br>该方法的参数为一个String类对象,作用是将参数中的字符串str连接到原来字符串的后面. <br>(2)求字符串的长度<br>public int length()<br>返回字串的长度,这里的长度指的是字符串中Unicode字符的数目.<br>(3)求字符串中某一位置的字符<br>public char charAt(int index)<br>该方法在一个特定的位置索引一个字符串,以得到字符串中指定位置的字符.值得注意的是,在字符串中第一个字符的索引是0,第二个字符的索引是1,依次类推,最后一个字符的索引是length()-1. <br>(4)字符串的比较<br>比较字符串可以利用String类提供的下列方法:<br>1)public int compareTo(String anotherString)<br>该方法比较两个字符串,和Character类提供的compareTo方法相似,Character类提供的compareTo方法比较的是两个字符类数据,而这里比较的是字符串数据.<br>其比较过程实际上是两个字符串中相同位置上的字符按Unicode中排列顺序逐个比较的结果.如果在整个比较过程中,没有发现任何不同的地方,则表明两个字符串是完全相等的,compareTo方法返回0;如果在比较过程中,发现了不同的地方,则比较过程会停下来,这时一定是两个字符串在某个位置上不相同,如果当前字符串在这个位置上的字符大于参数中的这个位置上的字符,compareTo方法返回一个大于0的整数,否则返回一个小于0的整数. <br>2)public boolean equals(Object anObject)<br>该方法比较两个字符串,和Character类提供的equals方法相似,因为它们都是重载Object类的方法.该方法比较当前字符串和参数字符串,在两个字符串相等的时候返回true,否则返回false.<br>3)public boolean equalsIgnoreCase(String anotherString)<br>该方法和equals方法相似,不同的地方在于,equalsIgnoreCase方法将忽略字母大小写的区别.<br>(5)从字符串中提取子串<br>利用String类提供的substring方法可以从一个大的字符串中提取一个子串,该方法有两种常用的形式:<br>1)public String substring(int beginIndex)<br>该方法从beginIndex位置起,从当前字符串中取出剩余的字符作为一个新的字符串返回.<br>2)public String substring(int beginIndex, int endIndex)<br>该方法从当前字符串中取出一个子串,该子串从beginIndex位置起至endIndex-1为结束.子串返的长度为endIndex-beginIndex. <br>(6)判断字符串的前缀和后缀<br>判断字符串的前缀是否为指定的字符串利用String类提供的下列方法:<br>1)public boolean startsWith(String prefix)<br>该方法用于判断当前字符串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>2)public boolean startsWith(String prefix, int toffset)<br>该方法用于判断当前字符串从toffset位置开始的子串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>判断字符串的后缀是否为指定的字符串利用String类提供的方法:<br>public boolean endsWith(String suffix)<br>该方法用于判断当前字符串的后缀是否和参数中指定的字符串suffix一致,如果是,返回true,否则返回false.<br>(7)字符串中单个字符的查找<br>字符串中单个字符的查找可以利用String类提供的下列方法:<br>1)public int indexOf(int ch)<br>该方法用于查找当前字符串中某一个特定字符ch出现的位置.该方法从头向后查找,如果在字符串中找到字符ch,则返回字符ch在字符串中第一次出现的位置;如果在整个字符串中没有找到字符ch,则返回-1. <br>2)public int indexOf(int ch, int fromIndex)<br>该方法和第一种方法类似,不同的地方在于,该方法从fromIndex位置向后查找,返回的仍然是字符ch在字符串第一次出现的位置. <br>3)public int lastIndexOf(int ch)<br>该方法和第一种方法类似,不同的地方在于,该方法从字符串的末尾位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>4)public int lastIndexOf(int ch, int fromIndex)<br>该方法和第二种方法类似,不同的地方在于,该方法从fromIndex位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>(8)字符串中子串的查找<br>字符串中子串的查找与字符串中单个字符的查找十分相似,可以利用String类提供的下列方法:<br>1)public int indexOf(String str)<br>2)public int indexOf(String str, int fromIndex)<br>3)public int lastIndexOf(String str)<br>4)public int lastIndexOf(String str, int fromIndex) <br>(9)字符串中字符大小写的转换<br>字符串中字符大小写的转换,可以利用String类提供的下列方法:<br>1)public String toLowerCase()<br>该方法将字符串中所有字符转换成小写,并返回转换后的新串.<br>2)public String toUpperCase()<br>该方法将字符串中所有字符转换成大写,并返回转换后的新串. <br>(10)字符串中多余空格的去除<br>public String trim()<br>该方法只是去掉开头和结尾的空格,并返回得到的新字符串.值得注意的是,在原来字符串中间的空格并不去掉. <br>(11)字符串中字符的替换<br>1)public String replace(char oldChar,char newChar)<br>该方法用字符newChar替换当前字符串中所有的字符oldChar,并返回一个新的字符串.<br>2)public String replaceFirst(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的第一个和字符串regex相一致的子串,并将产生的新字符串返回. <br>3)public String replaceAll(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的所有和字符串regex相一致的子串,并将产生的新字符串返回. <br>字符串变量与StringBuffer类 <br>1.创建StringBuffer类对象<br>StringBuffer类对象表示的是字符串变量,每一个StringBuffer类对象都是可以扩充和修改的字符串变量.以下是常用的StringBuffer类构造函数:<br>(1)public StringBuffer()<br>(2)public StringBuffer(int length) <br>(3)public StringBuffer(String str)  <br>5.Hash表的hash函数，冲突解决方法有哪些。<br>开放定址法或者叫再散列法；<br>1&gt;线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    2&gt;二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    3&gt;伪随机探测再散列：di&#x3D;伪随机序列；<br>再哈希法；<br>拉链法。<br>6.各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。<br>相连元素两两比较，大的往后放，第一次完毕后，最大值就出现在了最大索引处。同理，，继续，即可得到一个排好序的数组。<br>选择排序原理：<br>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i&#x3D;1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>插入排序原理：<br>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>归并排序的原理:<br>从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。<br>快速排序的原理:<br>从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。<br>堆排序的原理:<br>堆排序从小到大排序：首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，再将除了最后一个数的n-1个元素建立成大顶堆，再将最大元素和数组倒数第二个元素进行交换，重复直至堆大小减为1。<br>希尔排序的原理:<br>希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。<br>桶排序的原理:<br>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。<br>7.快排的partition函数与归并的Merge函数。<br>partition函数：双向扫描<br>Merge函数:最后再看每一组（一对）子表的归并，其原理是相同的，只是子表表长不同，换句话说，是子表的首记录号与尾记录号不同，把这个归并操作作为核心算法写成函数 merge <br>8.对冒泡与快排的改进。*<br>8.1 对冒泡的改进<br>    改进1：设置一个标志位，标志位代表在某一个冒泡遍历时候是否发生位置数据的交换，如果没有交换，则表明序列已经排序完成，否则继续排序。减少不必要的遍历。 <br>    改进2：再设置一个标志位，标志位是序列的某个下标，下标之后的代表已经排序完成，下标之前未排序，则遍历大于标志位时，不再遍历。减少一次遍历中已排完序的序列的遍历 <br>    改进3：在一次遍历时，同时找出最大值和最小值，从而提高效率。 <br>参考：排序算法（一）——冒泡排序及改进<br>8.2对快排的改进<br>基准的选取影响快排的效率，一般基准的选取有三种： <br>    1）固定位置。选序列第一位或者最后一位，算法的导论中提到的就是固定选择最后一位。 <br>    2）随机选取。对于序列中部分有序的情况，如果选择固定位置作为基准，会导致全序列都需要交换位置，这会使得效率低下。因此会采用随机选取数据作为基准。 <br>    3）三数取中。最佳划分是将序列划分成等长的两个子序列，因此提出三数取中的思想。取序列中，下标第一位，下标中间一位，下标最后一位的三个数进行排序，取排序结果中排中间的数据作为基准。（此外，也可以取5个数作为数据的基准。） <br>参考：三种快速排序以及快速排序的优化 <br>    针对以上三种情况中，三数取中效果最优，但是依然无法解决序列中出现重复情况，对此进行再次优化： <br>    优化1：当待排序序列的长度分割到一定大小后，使用插入排序。对于很小和部分有序的数组，快排不如插排好。 <br>    优化2：与基准值相同的不加入分割。在每一次分割结束后，可以把与基准相等的元素聚在一起，继续下次分割时，不用再对与基准相等元素分割。减少重复序列的反复分割 <br>    优化3：优化递归操作，快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。 <br>    这里提一下尾递归，如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归。需要说明的是递归调用必须整个函数体中最后执行的语句且它的返回值不属于表达式的一部分。 <br>尾递归的优点： <br>    1）尾递归通过迭代的方式，不存在子问题被多次计算的情况 <br>    2）尾递归的调用发生在方法的末尾，在计算过程中，完全可以把上一次留在堆栈的状态擦掉，保证程序以O(1)的空间复杂度运行。 <br>    可惜的是，在jvm中第二点并没有被优化。 <br>9.二分查找，与变种二分查找。<br>二分查找的中间下标：mid&#x3D;low+0.5∗(high−low)mid&#x3D;low+0.5∗(high−low) <br>    二分+插值： <br>    如果序列长度为1000，查找的关键字在10位置上，则还是需要从500中间开始二分查找，这样会产生多次无效查询，因此优化的方式就是更改分割的比例，采用三分，四分，分割位置：mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key)mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key) <br>    插值查找是根据要查找的关键字的key与查找表中最大最小记录的关键字比较之后的查找算法。 <br>    黄金分割比：用黄金分割比来作为mid值<br>10.二叉树、B+树、AVL树、红黑树、哈夫曼树。<br>二叉树：<br>二叉树的数据结构就不多说了，这里列举一些常见题目 <br>1）求解二叉树的节点 <br>    递归求解： <br>        a) 树为空，节点数为0 <br>        b) 二叉树节点个数 &#x3D; 左子树节点个数 + 右子树节点个数 + 1 <br>2）求二叉树的深度 <br>    递归解法： <br>        a）如果二叉树为空，二叉树的深度为0 <br>        b）如果二叉树不为空，二叉树的深度 &#x3D; max(左子树深度， 右子树深度) + 1 1. 先根遍历，中序遍历，后序遍历 <br>    依然递归求解 <br>4）广度优先 <br>    借助队列。 <br>5）将二叉查找树变为有序的双向链表 <br>    要求不能创建新节点，只调整指针。 <br>    递归解法： <br>        a）如果二叉树查找树为空，对应双向链表的第一个节点和最后一个节点是NULL <br>        b）如果二叉查找树不为空： <br>        设置参数flag，代表父节点与子节点的关系。如果修正的是左子树与父节点的关系，则递归返回的是序列最后的节点。 <br>6)求二叉树第K层的节点个数 <br>    递归解法： <br>        a）如果二叉树为空或者k&lt;1返回0 <br>        b）如果二叉树不为空并且k&#x3D;&#x3D;1，返回1 <br>        c）如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 <br>7)求二叉树中叶子节点的个数 <br>    递归解法： <br>        a）如果二叉树为空，返回0 <br>        b）如果二叉树不为空且左右子树为空，返回1 <br>        c）如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 <br>8)判断二叉树是不是平衡二叉树(AVL树) <br>    递归解法： <br>        a）如果二叉树为空，返回真 <br>        b）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假 <br>9)由前序遍历序列和中序遍历序列重建二叉树 <br>    二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。 <br>    递归解法： <br>        a）如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL; <br>        b）创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树 <br>10)判断是不是完全二叉树<br>11.二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。<br>12.图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。<br>13.KMP算法。<br>14.排列组合问题。<br>15.动态规划、贪心算法、分治算法。（一般不会问到）<br>16.大数据处理：类似10亿条数据找出最大的1000个数………等等<br>17.算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看数据库<br>1.事务四大特性（ACID）原子性、一致性、隔离性、持久性*<br>原子性：是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性: 是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。<br>隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。<br>事务之间的相互影响：脏读，不可重复读，幻读，丢失更新。<br>脏读 意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的<br>不可重复读 意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。<br>  幻读 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.<br>丢失更新 两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。<br>持久性：<br>意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><p>7.索引有B+索引和hash索引，各自的区别<br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。<br>在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。<br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。<br>8.B+索引数据结构，和B树的区别<br>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。<br>根节点至少有两个子节点<br>每个节点有M-1个key，并且以升序排列<br>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>其它节点至少有M&#x2F;2个子节点<br>B+树是对B树的一种变形树，它与B树的差异在于：<br>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</p><p>12.关系型数据库和非关系型数据库区别<br>1.关系型数据库通过外键关联来建立表与表之间的关系，<br>2.非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定</p><p>15.使用explain优化sql和索引<br>表的读取顺序<br>数据读取操作的操作类型<br>哪些索引可以使用<br>哪些索引被实际使用<br>表之间的引用<br>每张表有多少行被优化器查询<br>说了这么多使用explain的好处,那么实际上到底该怎么玩? 答案： explain + 待执行的sql<br>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化<br>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL<br>all: full table scan ;MySQL将遍历全表以找到匹配的行；<br>index ： index scan; index 和 all的区别在于index类型只遍历索引；<br>range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，&lt; ,&gt;等查询；<br>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；<br>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；<br>const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。<br>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句<br>key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：MySQL认为必须检查的用来返回请求数据的行数<br>Extra：关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。<br>16.long_query怎么解决*<br>慢查询日志：默认情况下，MySQL数据库是不开启慢查询日志的，long_query_time的默认值为10（即10秒，通常设置为1秒），即运行10秒以上的语句是慢查询语句。<br>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。<br>slow_query_log 慢查询开启状态。<br>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。<br>long_query_time 查询超过多少秒才记录。<br>17.内连接、外连接、交叉连接、笛卡儿积等<br>内连接(INNER JOIN)：  <br>    分为三种：等值连接、自然连接、不等连接<br>  <br>外连接(OUTER JOIN)：  <br>    分为三种：  <br>    左外连接(LEFT OUTER JOIN或LEFT JOIN)  <br>    右外连接(RIGHT OUTER JOIN或RIGHT JOIN)  <br>    全外连接(FULL OUTER JOIN或FULL JOIN)  交叉连接(CROSS JOIN)：  <br>    没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积<br>笛卡尔积是两个表每一个字段相互匹配，去掉where 或者inner join的等值 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。内连接: 只连接匹配的行。<br>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。<br>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。<br>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。<br>交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>20.mysql并发情况下怎么解决（通过事务、隔离级别、锁）<br>MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。。。。。<br>需求分析：互联网单位 每天大量数据读取，写入，并发性高。<br>现有解决方式：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。<br>集群方案：解决DB宕机带来的单点DB不能访问问题。<br>读写分离策略：极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。<br>21.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）<br>Undo Log<br>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了UndoLog来实现多版本并发控制(简称：MVCC)。<br>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>之所以能同时保证原子性和持久化，是因为以下特点：<br>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。<br>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。<br>Redo Log<br>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。<br>22.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序<br>Join where limit group by having12.Spring如何解决循环依赖？<br>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。<br>Spring的单例对象的初始化主要分为三步：<br>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>（3）initializeBean：调用spring xml中的init 方法。<br>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。<br>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。<br>13.Spring 如何保证 Controller 并发的安全？*<br>在Controller中使用ThreadLocal变量<br>在spring配置文件Controller中声明 scope&#x3D;”prototype”，每次都创建新的controller<br>在控制器中不使用实例变量7.Netty的高性能表现在哪些方面*<br>异步非阻塞通信<br> Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都 是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。另外，由于Netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。<br>零拷贝<br>  1) Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>       2) Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>       3) Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>内存池<br>   随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty提供了基于内存池的缓冲区重用机制（PooledByteBuf）。<br>高效的Reactor线程模型1. Reactor单线程模型；<br>       2) Reactor多线程模型；<br>       3) 主从Reactor多线程模型<br>无锁化的串行设计理念<br> 在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。<br>       为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。<br>       Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程 操作导致的锁的竞争，从性能角度看是最优的。<br>高效的并发编程<br>Netty的高效并发编程主要体现在如下几点：<br>       1) volatile的大量、正确使用;<br>       2) CAS和原子类的广泛使用；<br>       3) 线程安全容器的使用；<br>       4) 通过读写锁提升并发性能。<br>高性能的序列化框架<br>影响序列化性能的关键因素总结如下：<br>       1) 序列化后的码流大小（网络带宽的占用）；<br>       2) 序列化&amp;反序列化的性能（CPU资源占用）；<br>       3) 是否支持跨语言（异构系统的对接和开发语言切换）。<br>Netty默认提供了对Google Protobuf的支持，通过扩展Netty的编解码接口，用户可以实现其它的高性能序列化框架，例如Thrift的压缩二进制编解码框架。<br>灵活的TCP参数配置能力<br> 合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和SO_SNDBUF。如果设置不当，对性能的影响是非常大的。下面总结下对性能影响比较大的几个配置项：<br>       1) SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；<br>       2) SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；<br>       3) 软中断：如果Linux内核版本支持RPS（2.6.35以上版本），开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个 hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。<br>Netty在启动辅助类中可以灵活的配置TCP参数，满足不同的用户场景。<br>缓存<br>4.Redis的并发竞争问题如何解决<br>1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。  <br>2.服务器角度，利用setnx实现锁。<br>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。<br>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。<br>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p><p>3.Netty是如何使用线程池的，为什么这么使用*<br>EventExecutorGroup 自己实现了Future和submit<br>AbstractEventExecutorGroup，最上层实现的还是Executor接口<br>只不过通过 配置数量，配置线程模型</p><p>3.HTTP协议<br>http：+地址+端口+url<br>基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），B&#x2F;C架构<br>HTTP request请求：<br>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>GET说明请求类型为GET,[&#x2F;562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息<br>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<br>第三部分：空行，请求头部后面的空行是必须的<br>即使第四部分的请求数据为空，也必须有空行。<br>第四部分：请求数据也叫主体，可以添加任意的其他数据。<br>这个例子的请求数据为空。<br>HTTP之响应消息Response<br>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文<br>4.TCP协议：面向连接的、可靠的、基于字节流的传输层通信协议<br>IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。<br>简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包<br>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。5.一致性Hash算法*<br>一致性hash作为一个负载均衡算法，可以用在分布式缓存、数据库的分库分表等场景中，还可以应用在负载均衡器中作为作为负载均衡算法。在有多台服务器时，对于某个请求资源通过hash算法，映射到某一个台服务器，当增加或减少一台服务器时，可能会改变这些资源对应的hash值，这样可能导致一部分缓存或数据失效了。一致性hash就是尽可能在将同一个资源请求路由到同一台服务器中。<br>一致性哈希采用的做法如下：引入一个环的概念，如上面的第一个图。先将机器映射到这个环上，再将数据也通过相同的哈希函数映射到这个环上，数据存储在它顺时针走向的那台机器上。以环为中介，实现了数据与机器数目之间的解耦。这样，当机器的数目变化时，只会影响到增加或删除的那台机器所在的环的邻接机器的数据存储，而其他机器上的数据不受影响。</p><p>10.HTTP连接池实现原理<br>1、降低延迟：如果不采用连接池，每次连接发起Http请求的时候都会重新建立TCP连接(经历3次握手)，用完就会关闭连接(4次挥手)，如果采用连接池则减少了这部分时间损耗，别小看这几次握手，本人经过测试发现，基本上3倍的时间延迟<br>2、支持更大的并发：如果不采用连接池，每次连接都会打开一个端口，在大并发的情况下系统的端口资源很快就会被用完，导致无法建立新的连接<br>PoolingHttpClientConnectionManager<br>配置请求超时设置—RequestConfig<br>CloseableHttpClient 获取httpClient对象，post，get封装<br>12.数据库的实现原理分布式<br>1.什么是CAP定理<br>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本），换句话就是说，任何时刻，所用的应用程序都能访问得到相同的数据。<br>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性），换句话就是说，任何时候，任何应用程序都可以读写数据。<br>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，换句话说，系统可以跨网络分区线性的伸缩和扩展。<br>2.CAP 理论和 BASE 理论<br>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。<br>基本可用（Basically Available）<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。<br>软状态（ Soft State）<br>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。<br>最终一致性（ Eventual Consistency）<br>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。<br>3.CAP 理论1. CAP理论<br>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。<br>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。<br>1.1 一致性（Consistency）<br>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。<br>1.2 可用性（Availability）<br>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。<br>1.3 分区容错性（Partition tolerance）<br>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。<br>4.CAP 理论和最终一致性<br>一言以蔽之：过程松，结果紧，最终结果必须保持一致性<br>最终一致性是弱一致性的一种特例。假如A首先write了一个值到存储系统，存储系统保证如果在A,B,C后续读取之前没有其它写操作更新同样的值的话，最终所有的读取操作都会读取到最A写入的最新值。此种情况下，如果没有失败发生的话，“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制技术中replica的个数（这个可以理解为master&#x2F;salve模式中，salve的个数），最终一致性方面最出名的系统可以说是DNS系统，当更新一个域名的IP以后，根据配置策略以及缓存控制策略的不同，最终所有的客户都会看到最新的值<br>5.最终一致性实现方式<br>6.一致性 Hash<br>7.分布式事务，两阶段提交。<br>两阶段提交涉及到多个节点的网络通信,通信时间如果过长,事务的相对时间也就会过长,那么锁定资源的时间也就长了.在高并发的服务中,就会存在严重的性能瓶颈</p><p>9.如何实现分布式Session*<br>2. 基于数据库的Session共享<br>3. 基于NFS共享文件系统<br>4. 基于memcached 的session，如何保证 memcached 本身的高可用性？<br>5. 基于resin&#x2F;tomcat web容器本身的session复制机制<br>6. 基于TT&#x2F;Redis 或 jbosscache 进行 session 共享。<br>7. 基于cookie 进行session共享<br>10.如何保证消息的一致性*11.负载均衡<br>负载均衡是高可用网络基础架构的的一个关键组成部分，有了负载均衡，我们通常可以将我们的应用服务器部署多台，然后通过负载均衡将用户的请求分发到不同的服务器用来提高网站、应用、数据库或其他服务的性能以及可靠性<br>12.正向代理（客户端代理）和反向代理（服务器端代理）*<br>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>（1）访问原来无法访问的资源，如google<br>    （2）可以做缓存，加速访问资源<br>　　（3）对客户端访问授权，上网进行认证<br>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息<br>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击<br>（2）负载均衡，通过反向代理服务器来优化网站的负载<br>nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。<br>13.CDN实现原理<br>（1）CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br>（2）大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。<br>CDN即内容分发网络，加速的意思，那么网站CND服务是网站加速服务。<br>CDN加速将网站的内容缓存在网络边缘（离用户接入网络最近的地方），然后在用户访问网站内容的时候，通过调度系统将用户的请求路由或者引导到离用户接入网络最近或者访问效果的缓存服务器上，有该缓存服务器为用户提供内容服务；相对于直接访问源站，这种方式缩短了用户和内容之间的网络距离，从而达到加速的效果<br>14.怎么提升系统的QPS和吞吐量*<br>QPS（TPS）：每秒钟request&#x2F;事务 数量<br>并发数：系统同时处理的request&#x2F;事务数<br>响应时间：一般取平均响应时间<br>简单而言通过增加集群来提升qps和吞吐量<br>实际上要比这个要复杂<br>首先我们需要知道系统的瓶颈<br>我们所知道的系统拓扑架构<br>对于rest接口而言<br>系统设施依次是：<br>dns<br>　　nginx<br>　　　　tomcat<br>　　　　　　db&#x2F;soa<br>首先我们可以通过增加集群来增加qps和吞吐量<br>其次考虑到负载均衡的问题，我们可以通过其他设施来保证集群节点的负载均衡，进一步提高系统qps<br>于是就有nginx集群+负载均衡<br>tomcat集群+负载均衡<br>到db&#x2F;soa这一层的时候，同样也可以通过增加集群+负载均衡的方式来解决<br>我们还可以在每一层增加缓存来应对热点数据<br>然而另外一个方面，可以系统拆分，服务拆分，分别针对瓶颈的系统单独增加集群和负载均衡来解决<br>同样db也可以分库分表，<br>因为单表超过1000万条数据时就很慢了，所以这个时候就需要库拆分，于是就有垂直拆分，水平拆分。　　　<br>异步化，可以不同调用的异步化，使用mq，比如发送短信，发送邮件等<br> <br>综上所述：<br>集群+负载均衡<br>增加缓存<br>系统拆分<br>分库分表<br>垂直拆分+水平拆分<br>异步化+MQ</p><p>16.描述一个服务从发布到被消费的详细过程*<br>创建接口服务<br>配置文件配置服务注册中心，配置接口服务<br>启动后，服务提供者启动时，向注册中心注册自己提供的服务，服务消费者在启动时，向注册中心订阅自己所需的服务<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br>17.分布式系统怎么做服务治理服务自动注册<br>客户端自动发现<br>变更下发<br>18.接口的幂等性的概念<br>在数学里，幂等有两种主要的定义：<br>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 即 s <em>s &#x3D; s<br>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) &#x3D; f(x)。<br>HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。如通过PUT接口将数据的Status置为1，无论是第一次执行还是多次执行，获取到的结果应该是相同的，即执行完成之后Status &#x3D;1。<br>orderStatus由0-&gt;1 是需要幂等性的<br>19.消息中间件如何解决消息丢失问题</em><br>消息持久化<br>ACK确认机制<br>设置集群镜像模式<br>1）单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。<br>2）普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。<br>3）镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案<br>消息补偿机制：息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。<br>20.Dubbo的服务请求失败怎么处理<br>因此，将应用拆分，并抽取出核心服务来解决上述问题，还要考虑负载均衡、服务监控、高可用性、服务隔离与降级、路由策略、完善的容错机制、序列化方案的选择、通信框架的选择、开发人员对底层细节无感知、服务升级兼容性等问题。Dubbo满足了以上所有需求。<br>21.重连机制会不会造成错误<br>dubbo在调用服务不成功时，默认会重试2次。<br>Dubbo的路由机制，会把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机制也能一定程度的保证服务的质量。<br>但是如果不合理的配置重试次数，当失败时会进行重试多次，这样在某个时间点出现性能问题，调用方再连续重复调用。<br>系统请求变为正常值的retries倍，系统压力会大增，容易引起服务雪崩，需要根据业务情况规划好如何进行异常处理，何时进行重试。<br>22.对分布式事务的理解<br>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。<br>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交，包括上面提到的消息事务+最终一致性、TCC模式，而完全控制就是完全实现两阶段提交。部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。<br>下单—涉及扣库存和更新订单状态。<br>23.如何实现负载均衡，有哪些算法可以实现？<br>既然要解决后端系统的承载能力：nginx的配置<br>均衡算法主要解决将请求如何发送给后端服务<br>随机（random）、轮训（round-robin）、一致哈希（consistent-hash）和主备（master-slave）。<br>24.Zookeeper的用途，选举的原理是什么？<br>分布式系统基本上都是主从结构，所以需要zookeeper进行协调服务，他做很多事情的，比如命名服务，配置管理，集群管理，分布式协调通知等等<br>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。1.服务器初始化时Leader选举<br>zookeeper由于其自身的性质，一般建议选取奇数个节点进行搭建分布式服务器集群。以3个节点组成的服务器集群为例，说明服务器初始化时的选举过程。启动第一台安装zookeeper的节点时，无法单独进行选举，启动第二台时，两节点之间进行通信，开始选举Leader。1）每个Server投出一票。他们两都选自己为Leader，投票的内容为（SID，ZXID）。SID即Server的id，安装zookeeper时配置文件中所配置的myid；ZXID，事务id，为节点的更新程度，ZXID越大，代表Server对Znode的操作越新。由于服务器初始化，每个Sever上的Znode为0，所以Server1投的票为（1,0），Server2为（2,0）。两Server将各自投票发给集群中其他机器。2）每个Server接收来自其他Server的投票。集群中的每个Server先判断投票有效性，如检查是不是本轮的投票，是不是来Looking状态的服务器投的票。3）对投票结果进行处理。先了解下处理规则</p><ul><li>首先对比ZXID。ZXID大的服务器优先作为Leader</li><li>若ZXID相同，比如初始化的时候，每个Server的ZXID都为0，就会比较myid，myid大的选出来做Leader。对于Server而言，他接受到的投票为（2,0），因为自身的票为（1,0），所以此时它会选举Server2为Leader，将自己的更新为（2,0）。而Server2收到的投票为Server1的（1,0）由于比他自己小，Server2的投票不变。Server1和Server2再次将票投出，投出的票都为（2,0）。4） 统计投票。每次投票之后，服务器都会统计投票信息，如果判定某个Server有过半的票数投它，那么该Server将会作为Leader。对于Server1和Server2而言,统计出已经有两台机器接收了（2,0）的投票信息，此时认为选出了Leader。5）改变服务器状态。当确定了Leader之后，每个Server更新自己的状态，Leader将状态更新为Leading，Follower将状态更新为Following。2.服务器运行期间的Leader选举<br>zookeeper运行期间，如果有新的Server加入，或者非Leader的Server宕机，那么Leader将会同步数据到新Server或者寻找其他备用Server替代宕机的Server。若Leader宕机，此时集群暂停对外服务，开始在内部选举新的Leader。假设当前集群中有Server1、Server2、Server3三台服务器，Server2为当前集群的Leader，由于意外情况，Server2宕机了，便开始进入选举状态。过程如下<br>1） 变更状态。其他的非Observer服务器将自己的状态改变为Looking，开始进入Leader选举。<br>2） 每个Server发出一个投票（myid，ZXID），由于此集群已经运行过，所以每个Server上的ZXID可能不同。假设Server1的ZXID为145，Server3的为122，第一轮投票中，Server1和Server3都投自己，票分别为（1，145）、（3,122）,将自己的票发送给集群中所有机器。<br>3） 每个Server接收接收来自其他Server的投票，降下来的步骤与启动时步骤相同。25.数据的垂直拆分水平拆分。<br>垂直拆分，对于表来说，可以按业务模型进行拆分<br>水平拆分，对于表来说，是分多个票取模存放到不同数据库<br>26.zookeeper原理和适用场景*<br>Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储， Zookeeper 作用主要是用来维护和监控存储的数据的状态变化，通过监控这些数据状态的变化，从而达到基于数据的集群管理<br>简单的说，zookeeper&#x3D;文件系统+通知机制。<br>ZooKeeper以Fast Paxos（帕克索斯）算法为基础，让集群中的每个zk实例数据保持一致。一般部署集群，机器数设置为奇数个，更容易满足&gt;N&#x2F;2的投票条件。<br>Zookeeper应用场景<br>统一命名服务<br>       分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别不同服务。类似于域名与ip之间对应关系，域名容易记住。通过名称来获取资源或服务的地址，提供者等信息按照层次结构组织服务&#x2F;应用名称可将服务名称以及地址信息写到Zookeeper上，客户端通过Zookeeper获取可用服务列表类。<br>配置管理<br>       分布式环境下，配置文件管理和同步是一个常见问题。一个集群中，所有节点的配置信息是一致的，比如Hadoop。对配置文件修改后，希望能够快速同步到各个节点上配置管理可交由Zookeeper实现。可将配置信息写入Zookeeper的一个znode上。各个节点监听这个znode。一旦znode中的数据被修改，zookeeper将通知各个节点。<br>集群管理<br>       分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态作出一些调整。Zookeeper可将节点信息写入Zookeeper的一个znode上。监听这个znode可获取它的实时状态变化。典型应用比如Hbase中Master状态监控与选举。<br>分布式通知&#x2F;协调<br>       分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。例如，NameNode须知道各DataNode的状态，JobTracker须知道各TaskTracker的状态。心跳检测机制和信息推送也是可通过Zookeeper实现。<br>分布式锁<br>       Zookeeper是强一致的。多个客户端同时在Zookeeper上创建相同znode，只有一个创建成功。Zookeeper实现锁的独占性。多个客户端同时在Zookeeper上创建相同znode ，创建成功的那个客户端得到锁，其他客户端等待。Zookeeper 控制锁的时序。各个客户端在某个znode下创建临时znode （类型为CreateMode. EPHEMERAL _SEQUENTIAL），这样，该znode可掌握全局访问时序。<br>分布式队列<br>       两种队列。当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。（可通过分布式锁实现）<br>       同步队列。一个job由多个task组成，只有所有任务完成后，job才运行完成。可为job创建一个&#x2F;job目录，然后在该目录下，为每个完成的task创建一个临时znode，一旦临时节点数目达到task总数，则job运行完成。<br>27.zookeeper watch机制<br>监视是一种简单的机制，使客户端收到关于ZooKeeper集合中的更改的通知。客户端可以在读取特定znode时设置Watches。Watches会向注册的客户端发送任何znode（客户端注册表）更改的通知。<br>Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。<br>28.redis&#x2F;zk节点宕机如何处理*<br>解决方法是连接从服务器，做save操作。将会在从服务器的data目录保存一份从服务器最新的dump.rdb文件。将这份dump.rdb文件拷贝到主服务器的data目录下。再重启主服务器。<br>29.分布式集群下如何做到唯一序列号*<br><a target="_blank" rel="noopener" href="http://stor.51cto.com/art/201711/558600.htm">http://stor.51cto.com/art/201711/558600.htm</a><br>1、利用数据库递增，全数据库唯一。<br>优点：明显，可控。<br>缺点：单库单表，数据库压力大。<br>2、UUID， 生成的是length&#x3D;32的16进制格式的字符串，如果回退为byte数组共16个byte元素，即UUID是一个128bit长的数字，一般用16进制表示。<br>优点：对数据库压力减轻了。<br>缺点：但是排序怎么办？<br>此外还有UUID的变种，增加一个时间拼接，但是会造成id非常长。<br>3、twitter在把存储系统从MySQL迁移到Cassandra的过程中由于Cassandra没有顺序ID生成机制，于是自己开发了一套全局唯一ID生成服务：Snowflake。<br>41位的时间序列（精确到毫秒，41位的长度可以使用69年）<br>10位的机器标识（10位的长度最多支持部署1024个节点）<br>12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 最高位是符号位，始终为0。<br>优点：高性能，低延迟；独立的应用；按时间有序。<br>缺点：需要独立的开发和部署。<br>4、Redis生成ID<br>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作INCR和INCRBY来实现。<br>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。<br>30.用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗*<br>可靠消费<br>Redis：没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理<br>RabbitMQ：具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费<br>可靠发布<br>Reids：不提供，需自行实现<br>RabbitMQ：具有发布确认功能，保证消息被发布到服务器<br>高可用<br>Redis：采用主从模式，读写分离，但是故障转移还没有非常完善的官方解决方案<br>RabbitMQ：集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作<br>持久化<br>Redis：将整个Redis实例持久化到磁盘<br>RabbitMQ：队列，消息，都可以选择是否持久化<br>消费者负载均衡<br>Redis：不提供，需自行实现<br>RabbitMQ：根据消费者情况，进行消息的均衡分发<br>队列监控<br>Redis：不提供，需自行实现<br>RabbitMQ：后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）<br>流量控制<br>Redis：不提供，需自行实现<br>RabbitMQ：服务器过载的情况，对生产者速率会进行限制，保证服务可靠性<br>kafka，<br>activemq，<br>RocketMQ<br>31.MQ系统的数据如何保证不丢失<br>32.列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询<br>１、中间变量　＝ user_id%（库数量*每个库的表数量）;<br>２、库序号　＝　取整（中间变量／每个库的表数量）;<br>３、表序号　＝　中间变量％每个库的表数量;<br>Join连表查询，或者多sql查询系统架构<br>1.如何搭建一个高可用系统<br>容灾<br>集群<br>主备<br>熔断<br>限流<br>监控<br>降级<br>日志<br>分库分表<br>读写分离<br>Nginx反向代理<br>CDN加速<br>SSD硬盘持久化<br>自动备份<br>2.哪些设计模式可以增加系统的可扩展性<br>工厂模式<br>抽象工厂模式<br>观察者模式：很方便增加观察者，方便系统扩展<br>模板方法模式：很方便的实现不稳定的扩展点，完成功能的重用<br>适配器模式：可以很方便地对适配其他接口<br>代理模式：可以很方便在原来功能的基础上增加功能或者逻辑<br>责任链模式：可以很方便得增加拦截器&#x2F;过滤器实现对数据的处理，比如struts2的责任链<br>策略模式：通过新增策略从而改变原来的执行策略<br>3.介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。5.什么是高内聚低耦合，请举例子如何实现*<br>同一类功能放一块，如utils包，但是各个模块功能不依赖关联，这就是低耦合<br>接口、继承、多态也是低耦合的实现<br>6.什么情况用接口，什么情况用消息<br>接口的特点是同步调用，接口实时响应，阻塞等待<br>消息的特点是异步处理，非实时响应，消息发送后则返回，消息队列可以削峰<br>一般对实时性要求比较高的功能采用接口<br>对实时性要求不高的功能可以采用消息，削峰时可以采用消息<br>7.如果AB两个系统互相依赖，如何解除依赖*<br>A—&gt;B，同时B—&gt;A<br>解除这种双向依赖的话，需要在AB之外增加一个C，用C封装A依赖的B的那部分功能，让A改为依赖C，C依赖B<br>然后就是这样<br>A—&gt;C，C—-&gt;B，B—&gt;A<br>不过这样依然存在环路依赖<br>8.如何写一篇设计文档，目录是什么<br>基于此我认为主要会分为8个部分。分别为 项目背景，项目目标，需求分析，方案对比，概要设计，详细设计（存储模型设计，接口设计），开发以及上线计划，方案排期。<br>9.什么场景应该拆分系统，什么场景应该合并系统<br>拆分系统：<br>当系统通过集群的方式已经无法解决性能问题的时候，或者业务扩展到很大的时候，需要把拆分系统<br>按照业务的方式垂直拆分：将业务功能结合比较紧密的部分拆分成独立的系统，独立维护<br>按照性能瓶颈点拆分：将系统性能瓶颈点拆分出一个独立的系统，可以针对这个独立的系统集群部署，增加可伸缩性，提高系统整体的性能<br>合并系统：<br>或者系统间通过跨进程访问的性能损耗过高，可以将系统合并成一个系统，减少跨进程访问的消耗<br>10.系统和模块的区别，分别在什么场景下使用<br>系统和模块<br>系统是一个完整功能的系统，拥有独立的访问方式，和部署方式，拥有完整的生命周期，系统由模块组成<br>模块是系统的组成部分，不能单独工作，需要依附于系统才能发挥作用，通常是解决一定场景下的问题<br>系统用于系统性解决问题的方案<br>模块是针对单个问题方面的解决方案<br>11.实战能力<br>12.有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。<br>13.开发中有没有遇到什么技术问题？如何解决的<br>14.如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。<br>15.新浪微博是如何实现把微博推给订阅者<br>16.Google是如何在一秒内把搜索结果返回给用户的。<br>17.12306网站的订票系统如何实现，如何保证不会票不被超卖。<br>18.如何实现一个秒杀系统，保证只有几位用户能买到某件商品。<br>设计这个系统是一个考虑全面的问题，可以发散出很多问题，考察很多方面，不是仅仅回答通过redis的自减操作完成<br>比如简单的方案：<br>1，页面开启倒计时，要保证不能把下单接口暴露过早暴露出来，防止机器刷下单接口<br>2，前端限流，比如nginx对下单接口限流，命中限流则返回302到秒杀页<br>3，后端单独部署，独立域名和nginx，与线上正常运行的系统隔离开来，避免影响到线上环境<br>4，由于生成订单操作比较耗时，采用队列的方式来解耦下单成功和生成订单，针对进入后端的请求，采用redis自减，针对自减结果&gt;0的请求则认为下单成功，触发一个生成订单的消息，然后立即返回给用户结果<br>5，用户方面，针对秒杀成功有两种处理方式<br>　　a，用户端收到秒杀成功的结果，则开启提示页面，并进入倒计时，倒计时时间为订单生成的预估时间<br>　　b，秒杀成功后，给当前用户在redis中生成一个订单生成状态的标识，用户端开启提示页面，loading，并轮询后端订单生成状态，生成成功之后让前端跳转到订单页面<br>6，订单服务订阅下单系统发送的消息，并开始生成订单，生成订单成功之后更新redis中用户秒杀订单的状态为已生成订单</li></ul><p> <br>系统应该有页面和接口<br>页面用于展示用户界面，接口用于获取数据<br>界面：秒杀页面，秒杀成功页面，秒杀失败页面，命中限流页面（查看订单页面不算秒杀系统的功能）<br>接口：秒杀下单接口，秒杀成功获取订单生成状态接口TCP&#x2F;IP<br>1.OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议。*<br>OSI模型—应用层，表示层，回话层，传输层，网络层，数据链路层，物理层<br>1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 <br>2.数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 <br>3.网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 <br>4.传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 <br>5.会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） <br>6.表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 <br>7.应用层： 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。2.TCP与UDP的区别。*<br>TCP(Transmission Control Protocol)：传输控制协议<br>UDP(User Datagram Protocol)：用户数据报协议<br>TCP是面向连接的、可靠的、有序的、速度慢的协议；<br>UDP是无连接的、不可靠的、无序的、速度快的协议。<br>TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。<br>TCP无界有拥塞控制，UDP有界无拥塞控制。3.TCP报文结构。<br>1、端口号：用来标识同一台计算机的不同的应用进程。<br>1）源端口：源端口和IP地址的作用是标识报文的返回地址。<br>2）目的端口：端口指明接收方计算机上的应用程序接口。<br>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。<br>2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。<br>3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32&#x2F;8 &#x3D; 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。<br>4、保留：为将来定义新的用途保留，现在一般置0。<br>5、控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。<br>1）URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。<br>2）ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。<br>3）PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。<br>4）RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。<br>5）SYN：同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。<br>6）FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。<br>6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。<br>7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。<br>8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。<br>9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。<br>10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。<br>4.TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。<br>5.TCP拥塞控制。<br>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或者链路不会导致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制<br>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。<br>（1）在通信子网出现过多数据包的情况，使得网络的性能下降，甚至不能正常工作，这种现象就称为拥塞。<br>（2）网络拥塞的成因主要有三：1、处理器的速度太慢。2、线路容量的限制。3、节点输出包的能力小于输入包的能力。<br>（3）拥塞控制与流量控制是相关的，流量控制在数据链路层对一条通信路径上的流量进行控制，其的是保证发送者的发送速度不超过接收者的接收速度，它只涉及一全发送者和一个接收者，是局部控制。拥塞控制是对整个通信子网的流量进行控制，其目的是保证通信子网中的流量与其资源相匹配，使子网不会出现性能下降和恶化、甚至崩溃，是全局控制。<br>（4）拥塞控制的最终目标是：1、防止由于过载而使吞吐量下降，损失效率；2、合理分配网络资源；3、避免死锁；4、匹配传输速度。<br>（5）对拥塞控制，可用的方法有两类：开环控制和闭环控制。<br>1、开环控制的思想是通过良好的设计避免拥塞问题的出现，确保拥塞问题在开始时就不可能发生。开环控制方法包括何时接受新的通信何时丢弃包、丢弃哪些包。其特点是在作出决定时不考虑网络当前的状态。<br>2、闭环控制的思想是反馈控制。即通过将网络工作的动态信息反馈给网络中节点的有关进程，节点根据网络当前的动态信息，调整转发数据包的策略。闭环控制过程包括三部分： ①监视系统  检测网络发生或将要发生拥塞的时间和地点。②报告  将监视中检测到的信息传送到可以进行拥塞控制的节点。③决策  调整系统的操作行为，以解决问题。<br>（6）对应于开环控制的方法有：（基于拥塞预防）<br>1、预定缓冲区 2、合理分配缓冲区 3、通信量整形法（A、许可证算法，B、漏桶算法，C、令牌漏桶算法。）<br>对应于闭环控制的方法有：（基于拥塞抑制，即拥塞出现或即将出现时采取适当的措施进行控制，直到消除拥塞）<br>1、阻塞包法。 2、负载丢弃法<br>6.TCP滑动窗口与回退N针协议。<br>7.Http的报文结构。<br>（1）HTTP请求报文<br>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。（2）HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。<br>8.Http的状态码含义。<br>1xx: 信息<br>消息：	描述：<br>100 Continue	服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。<br>101 Switching Protocols	服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。<br>103 Checkpoint	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>2xx: 成功<br>消息：	描述：<br>200 OK	请求成功（这是对HTTP请求成功的标准应答。）<br>201 Created	请求被创建完成，同时新的资源被创建。<br>202 Accepted	供处理的请求已被接受，但是处理未完成。<br>203 Non-Authoritative Information	请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。<br>204 No Content	请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br>205 Reset Content	请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。<br>206 Partial Content	客户发送了一个带有Range头的GET请求，服务器完成了它。<br>3xx: 重定向<br>消息：	描述：<br>300 Multiple Choices	多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。<br>301 Moved Permanently	所请求的页面已经转移至新的 URL 。<br>302 Found	所请求的页面已经临时转移至新的 URL 。<br>303 See Other	所请求的页面可在别的 URL 下被找到。<br>304 Not Modified	未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br>305 Use Proxy	客户请求的文档应该通过Location头所指明的代理服务器提取。<br>306 Switch Proxy	目前已不再使用，但是代码依然被保留。<br>307 Temporary Redirect	被请求的页面已经临时移至新的 URL 。<br>308 Resume Incomplete	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>4xx: 客户端错误<br>消息：	描述：<br>400 Bad Request	因为语法错误，服务器未能理解请求。<br>401 Unauthorized	合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。<br>402 Payment Required	此代码尚无法使用。<br>403 Forbidden	合法请求，但对被请求页面的访问被禁止。<br>404 Not Found	服务器无法找到被请求的页面。<br>405 Method Not Allowed	请求中指定的方法不被允许。<br>406 Not Acceptable	服务器生成的响应无法被客户端所接受。<br>407 Proxy Authentication Required	用户必须首先使用代理服务器进行验证，这样请求才会被处理。<br>408 Request Timeout	请求超出了服务器的等待时间。<br>409 Conflict	由于冲突，请求无法被完成。<br>410 Gone	被请求的页面不可用。<br>411 Length Required	“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。<br>412 Precondition Failed	请求中的前提条件被服务器评估为失败。<br>413 Request Entity Too Large	由于所请求的实体太大，服务器不会接受请求。<br>414 Request-URI Too Long	由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。<br>415 Unsupported Media Type	由于媒介类型不被支持，服务器不会接受请求。<br>416 Requested Range Not Satisfiable	客户端请求部分文档，但是服务器不能提供被请求的部分。<br>417 Expectation Failed	服务器不能满足客户在请求中指定的请求头。<br>5xx: 服务器错误<br>消息：	描述：<br>500 Internal Server Error	请求未完成。服务器遇到不可预知的情况。<br>501 Not Implemented	请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。<br>502 Bad Gateway	请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。<br>503 Service Unavailable	服务器当前不可用（过载或者当机）。<br>504 Gateway Timeout	网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。<br>505 HTTP Version Not Supported	服务器不支持请求中指明的HTTP协议版本。<br>511 Network Authentication Required	用户需要提供身份验证来获取网络访问入口。9.Http?request的几种类型。*<br>1.  OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’<em>‘的请求来测试服务器的功能性。<br>2.  HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>3.  GET：向特定的资源发出请求。<br>4.  POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>5.  PUT：向指定资源位置上传其最新内容。<br>6.  DELETE：请求服务器删除Request-URI所标识的资源。<br>7.  TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>8.  CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>10.Http1.1和Http1.0的区别</em><br>长连接<br>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。<br>HTTP是基于TCP&#x2F;IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。<br>节约带宽<br>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。<br>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。<br>HOST域<br>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。<br>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。<br>11.Http怎么处理长连接。*<br>在HTTP1.0和HTTP1.1协议中都有对长连接的支持。其中HTTP1.0需要在request中增加Connection： keep-alive header才能够支持，而HTTP1.1默认支持。<br>http1.0请求与服务端的交互过程:<br>（1）客户端发出带有包含一个header：”Connection： keep-alive“的请求<br>（2）服务端接收到这个请求后,根据http1.0和”Connection： keep-alive“判断出这是一个长连接,就会在response的header中也增加”Connection： keep-alive“，同时不会关闭已建立的tcp连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>http1.1请求与服务端的交互过程:<br>（1）客户端发出http1.1的请求<br>（2）服务端收到http1.1后就认为这是一个长连接,会在返回的response设置Connection： keep-alive,同时不会关闭已建立的连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>基于http协议的长连接减少了请求,减少了建立连接的时间,但是每次交互都是由客户端发起的,客户端发送消息,服务端才能返回客户端消息。<br>12.Cookie与Session的作用于原理。<br>1.1 Cookie机制<br>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。<br>而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。<br>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。<br>1.2 Session机制<br>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。<br>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。<br>Java Web规范支持通过配置的方式禁用Cookie。下面举例说一下怎样通过配置禁止使用Cookie，可以使用重定向url。 <br>cookie数据保存在客户端，session数据保存在服务器端 <br>第一次请求服务器，生成session和sessionID，sessionID用cookie保存 <br>第二次请求服务器，携带seesionID，服务器从请求中取出sessionID<br>13.电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。<br>应用层：<br>连接：当我们输入一个url请求时，首先要建立socket连接，因为socket是通过ip和端口建立的，所有有一个DNS解析的过程，首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。现在已经拥有了目标ip和端口号，这样我们就可以打开socket连接了。<br>请求：连接成功建立后，开始向web服务器发送请求，这个请求一般是GET或POST命令（POST用于FORM参数的传递）。GET命令的格式为：　　GET 路径&#x2F;文件名 HTTP&#x2F;1.0<br>文件名指出所访问的文件，HTTP&#x2F;1.0指出Web浏览器使用的HTTP版本。现在可以发送GET命令：<br>GET &#x2F;mytest&#x2F;index.html HTTP&#x2F;1.0，<br>应用层：<br>1. DNS（53）：<br>我们输入的是一个URL需要转化成IP地址。首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。1. HTTP（80）<br>HTTP协议的主要职责是生成针对目标web服务器的http请求报文（请求行、请求头部）<br>传输层<br>2. TCP<br>将http请求报文分割成报文段，按序号分为多个报文段。（三次握手）<br>网络层<br>3. IP<br>搜索目标的地址，一边中转一边传送。（路由）<br>4. ARP<br>因为最终都要在数据链路层上进行传输，而数据链路层并不认识IP地址，所以ARP的职责就是把IP地址转换成数据链路层认识的MAC地址。<br>通过数据链路层到达目标机器之后<br>网络层<br>5. RARP<br>这其实是ARP的逆过程，将MAC地址转换成Ip地址<br>传输层<br>6. TCP<br>将接收到的报文段按序号进行重组。<br>应用层<br>7. HTTP<br>14.Ping的整个过程。ICMP报文是什么。<br>ICMP（网际控制报文协议）：用来测试网络层是不是有故障，若有故障，该协议还能报告故障。Ping命令来使用这个协议<br>15.C&#x2F;S模式下使用socket通信，几个关键函数。*<br>client ： socket（ip，端口）<br>socket.close();<br>server：serversocket（端口）<br>socket &#x3D; server.accept()<br>16.IP地址分类。<br>IP地址分类（A类 B类 C类 D类 E类）<br>     IP地址由四段组成，每个字段是一个字节，8位，最大值是255，,<br>     IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。<br>  IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。<br>     IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。    全0和全1的都保留不用。<br>     A类：（1.0.0.0-126.0.0.0）（默认子网掩码：255.0.0.0或 0xFF000000）<br>     第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1<del>126之间。<br>     一般用于大型网络。<br>     B类：（128.1.0.0-191.255.0.0）（默认子网掩码：255.255.0.0或0xFFFF0000）<br>     前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128</del>191之间。<br>     一般用于中等规模网络。<br>     C类：（192.0.1.0-223.255.255.0）（子网掩码：255.255.255.0或 0xFFFFFF00）<br>     前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192<del>223之间。<br>     一般用于小型网络。<br>    D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224</del>239之间。一般用于多路广播用户[1]  。<br>    E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。<br>  回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。 <br>       一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP&#x2F;IP是否正常。<br>17.路由器与交换机区别。<br>一、工作所在的OSI层次不一样（根本区别，导致接下来的区别） <br>交换机工作在 OSI模型的数据链路层，所以工作原理比较简单； <br>路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。<br>二、数据转发所依据的对象也不一样。 <br>交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。 <br>路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。<br>三、是否可以分割广播域 <br>由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵； <br>连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。<br>18.网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。<br>19.推荐书籍：《TCP&#x2F;IP协议族》1．JDK,JRE,JVM(掌握)<br>(1)JVM<br>保证Java语言跨平台。针对不同的操心系统提供不同的JVM。<br>问题：java语言是跨平台的吗?JVM是跨平台的吗?<br>(2)JRE<br>java程序的运行环境。包括JVM和核心类库<br>(3)JDK<br>java开发环境。包括JRE和开发工具(javac,java)<br>(4)一个Java程序的开发流程<br>A:编写Java源程序<br>B:通过javac命令编译java程序，生成字节码文件<br>C:通过java命令运行字节码文件<br>2．主从数据库切换<br>一般使用多个dataSource，然后创建多个SessionFactory，入侵明显，修改多，session处理比较麻烦。<br>合适的方案使用AbstractRoutingDataSource实现类通过AOP或者手动处理实现动态使用我们的数据源，入侵低。determineTargetDataSource –<br>determineCurrentLookupKey<br>Why：如果主库故障，可以切换从库<br>Why：针对与mysql，怎么保证主从同步，怎么通知代码切换1. Bean获取它所在的Spring容器，可以让该Bean实现ApplicationContextAware接口，Bean获取它所在的Spring容器，可以通过这个上下文环境对象得到Spring容器中的Bean。<br>Why：针对于非web项目的spring2. ehcache:<br>String：字符串常量 每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉，<br>　　　StringBuffer：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>　　　StringBuilder：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>String 字符串常量 线程安全 操作少量数据<br>StringBuffer 字符串变量 线程安全 操作大量数据 速度慢 多线程适合用<br>StringBuilder 字符串变量 线程不安全 操作大量数据 速度快 单线程适合用<br>String str &#x3D; new String(“xyz”);创建了几个对象。<br>如果String常量池中，已经创建了”xyz”,则不会继续创建，此时只创建了一个对象new String(“xyz”);<br>如果String常量池中没有创建”xyz”,则会创建两个对象，一个对象的值是”xyz”,一个对象是new String(“xyz”);<br>6．关系型数据库和非关系型数据库种类和关系<br>数据库<br>类型	特性	优点	缺点<br>关系型数据库<br>SQLite、Oracle、mysql	1、关系型数据库，是指采用了关系模型来组织<br>数据的数据库；<br>2、关系型数据库的最大特点就是事务的一致性；<br>3、简单来说，关系模型指的就是二维表格模型，<br>而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。	1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。	1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、高并发读写需求；<br>4、海量数据的高效率读写；<br>非关系型数据库<br>MongoDb、redis、HBase	1、使用键值对存储数据；<br>2、分布式；<br>3、一般不支持ACID特性；<br>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。	1、无需经过sql层的解析，读写性能很高；<br>2、基于键值对，数据没有耦合性，容易扩展；<br>3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。	1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理，附加功能bi和报表等支持也不好；4. Vector ,ArrayList 和LinkedList的区别？<br> 1、Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。<br> 2、Vector线程同步，ArrayList、LinkedList线程不同步。<br> 3、LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。<br> 4、ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省。8.注解<br>登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。9.反射<br>反射就是把java类中的各种成分映射成一个个的Java对象<br>可以获取类的相关信息，可以进行设置，可以代理<br>spring 的 ioc&#x2F;di 也是反射….<br>javaBean和jsp之间调用也是反射….<br>struts的 FormBean 和页面之间…也是通过反射调用….<br>JDBC 的 classForName()也是反射…..<br>hibernate的 find(Class clazz) 也是反射….<br>10.加载器11.ajax<br>运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换；2. statement<br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>3. 数据库基础查询<br>1、 加载JDBC驱动程序： <br>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机）， <br>这通过java.lang.Class类的静态方法forName(String className)实现。 <br>例如：<br>try{<br>&#x2F;&#x2F;加载MySql的驱动类<br>Class.forName(“com.mysql.jdbc.Driver”) ;<br>}catch(ClassNotFoundException e){<br>System.out.println(“找不到驱动程序类 ，加载驱动失败！”);<br>e.printStackTrace() ;<br>}<br>成功加载后，会将Driver类的实例注册到DriverManager类中。<br>2、 提供JDBC连接的URL * 连接URL定义了连接数据库时的协议、子协议、数据源标识。 </p><ul><li>书写形式：协议：子协议：数据源标识<br>协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。 <br>数据源标识：标记找到数据库来源的地址与连接端口。 <br>例如： <br>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;gbk;useUnicode&#x3D;true;（MySql的连接URL） <br>表示使用Unicode字符集。如果characterEncoding设置为 gb2312或GBK，本参数必须设置为true 。characterEncoding&#x3D;gbk：字符编码方式。<br>3、创建数据库的连接 </li><li>要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。 </li><li>使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。<br>例如： &#x2F;&#x2F;连接MySql数据库，用户名和密码都是root<br>String url &#x3D; “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test” ;<br>String username &#x3D; “root” ;<br>String password &#x3D; “root” ;<br>try{<br>Connection con &#x3D; DriverManager.getConnection(url , username , password ) ;<br>}catch(SQLException se){<br>System.out.println(“数据库连接失败！”);<br>se.printStackTrace() ;<br>}<br>4、 创建一个Statement <br>•要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型： <br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>具体的实现方式： <br>Statement stmt &#x3D; con.createStatement() ; PreparedStatement pstmt &#x3D; con.prepareStatement(sql) ; CallableStatement cstmt &#x3D; con.prepareCall(“{CALL demoSp(? , ?)}”) ; <br>5、执行SQL语句 <br>Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute <br>1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。 <br>2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等 <br>3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码： <br>ResultSet rs &#x3D; stmt.executeQuery(“SELECT * FROM …”) ; int rows &#x3D; stmt.executeUpdate(“INSERT INTO …”) ; boolean flag &#x3D; stmt.execute(String sql) ; <br>6、处理结果 <br>两种情况： <br>1、执行更新返回的是本次操作影响到的记录数。 <br>2、执行查询返回的结果是一个ResultSet对象。 <br>• ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些 行中数据的访问。 <br>• 使用结果集（ResultSet）对象的访问方法获取数据： <br>while(rs.next()){ <br>String name &#x3D; rs.getString(“name”) ; <br>String pass &#x3D; rs.getString(1) ; &#x2F;&#x2F; 此方法比较高效 <br>} <br>（列是从左到右编号的，并且从列1开始）<br>7、关闭JDBC对象 <br>操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反： <br>1、关闭记录集 <br>2、关闭声明 <br>3、关闭连接对象</li></ul><p>17.使用Spring框架的好处是什么？<br>  轻量：Spring 是轻量的，基本的版本大约2MB。<br>  控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>  容器：Spring 包含并管理应用中对象的生命周期和配置。<br>  MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br>  事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br>  异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。1. ~8等于多少？8&gt;&gt;&gt;2等于多少？<br>第一个答案是-9，第二个答案是2，无符号右移高位补0	。2. 子类能否重写父类的静态方法<br>不能，类对象，从属于对应的类。3. 什么是线程？<br>  线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。4. 线程和进程有什么区别？<br>  线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。5. 如何在Java中实现线程？<br>  两种方式：java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。6. Java 关键字volatile 与 synchronized 作用与区别？<br>1，volatile<br>    它所修饰的变量不保留拷贝，直接访问主内存中的。<br>2，synchronized<br>    当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。24.不同的线程生命周期？<br>  当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。<br>        1. 程优先级的理解是什么？<br>  每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。26.是死锁(Deadlock)？如何分析和避免死锁？<br>  死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。<br>  分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。<br>  避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。27.么是线程安全？Vector是一个线程安全类吗？ <br>所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。28.Java中如何停止一个线程？<br>  Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程29.什么是ThreadLocal?<br>  ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。<br>  每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。30.Sleep()、suspend()和wait()之间有什么区别？<br>  Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。<br>  注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。<br>  object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()&#x2F;notify()与sleep()&#x2F;interrupt()类似，只是前者需要获取对象锁。31.什么是线程饿死，什么是活锁？<br>  当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI中线程活锁可能发生在以下情形：<br>  1，当所有线程在程序中执行Object.wait(0)，参数为0的wait方法。程序将发生活锁直到在相应的对象上有线程调用Object.notify()或者Object.notifyAll()。<br>  2，当所有线程卡在无限循环中。32.什么是Java Timer类？如何创建一个有特定时间间隔的任务？<br>  java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br>  java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。<br>33.Java中的同步集合与并发集合有什么区别？<br>  同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。<br>  在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。<br>  Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。34.同步方法和同步块，哪个是更好的选择？<br>  同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。35.么是线程池？ 为什么要使用它？<br>  创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。<br>  为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。<br>  从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。36．java中invokeAndWait 和 invokeLater有什么区别？<br>  这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。1. 多线程中的忙循环是什么?<br>  忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存。<br>  在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。2. Array不可以用泛型？<br>是的，list的可以，推荐用list，List可以提供编译期的类型安全保证，而Array却不能。<br>int num&#x3D;Integer.valueOf(“12”);<br>int num2&#x3D;Integer.parseInt(“12”);<br>double num3&#x3D;Double.valueOf(“12.2”);<br>double num4&#x3D;Double.parseDouble(“12.2”);<br>&#x2F;&#x2F;其他的类似。通过基本数据类型的包装来的valueOf和parseXX来实现String转为XX<br>String a&#x3D;String.valueOf(“1234”);&#x2F;&#x2F;这里括号中几乎可以是任何类型<br>String b&#x3D;String.valueOf(true);<br>String c&#x3D;new Integer(12).toString();&#x2F;&#x2F;通过包装类的toString()也可以<br>String d&#x3D;new Double(2.3).toString();3. AJAX有哪些有点和缺点？<br>优点：<br>  1、最大的一点是页面无刷新，用户的体验非常好。<br>  2、使用异步方式与服务器通信，具有更加迅速的响应能力。<br>  3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。<br>   4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。<br>缺点：<br>   1、ajax不支持浏览器back按钮。<br>   2、安全问题 AJAX暴露了与服务器交互的细节。<br>   3、对搜索引擎的支持比较弱。<br>   4、破坏了程序的异常机制。<br>   5、不容易调试。40.集合解析<br>List 和 Set 区别<br>List,Set都是继承自Collection接口<br>List特点：元素有放入顺序，元素可重复<br>Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉<br>（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）<br>Set和List对比：<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。<br>ArrayList 与 Vector 区别<br>public ArrayList(int initialCapacity)&#x2F;&#x2F;构造一个具有指定初始容量的空列表。<br>public ArrayList()&#x2F;&#x2F;构造一个初始容量为10的空列表。<br>public ArrayList(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 的元素的列表<br>Vector有四个构造方法：<br>public Vector()&#x2F;&#x2F;使用指定的初始容量和等于零的容量增量构造一个空向量。<br>public Vector(int initialCapacity)&#x2F;&#x2F;构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。<br>public Vector(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 中的元素的向量<br>public Vector(int initialCapacity,int capacityIncrement)&#x2F;&#x2F;使用指定的初始容量和容量增量构造一个空的向量<br>ArrayList和Vector都是用数组实现的，主要有这么三个区别：<br>Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；<br>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。<br>Vector可以设置增长因子，而ArrayList不可以。<br>Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。<br>适用场景分析：<br>Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。<br>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。<br>HashSet 和 HashMap 区别<br>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象<br>HashMap 和 ConcurrentHashMap 的区别<br>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。41.线程解析</p><ol><li>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore<br>CountDownLatch用法<br>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。<br>CyclicBarrier用法<br>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。<br>Semaphore用法<br>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。下面对上面说的三个辅助类进行一个总结：<br>　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。<br>　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。<br>说说 CountDownLatch 与 CyclicBarrier 区别<br>CountDownLatch	CyclicBarrier<br>减计数方式	加计数方式<br>计算为0时释放所有等待的线程	计数达到指定值时释放所有等待线程<br>计数为0时，无法重置	计数达到指定值时，计数置为0重新开始<br>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响	调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞<br>不可重复利用	可重复利用java.util.concurrent.Exchanger应用范例与原理浅析<br>此类提供对外的操作是同步的；<br>用于成对出现的线程之间交换数据；<br>可以视作双向的同步队列；<br>可应用于基因算法、流水线设计等场景。<br>ThreadLocal 原理分析<br>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。<br>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。<br>讲讲线程池的实现原理<br>线程池的几种方式<br>newFixedThreadPool(int nThreads) <br>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程<br>newCachedThreadPool() <br>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制<br>newSingleThreadExecutor() <br>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行<br>newScheduledThreadPool(int corePoolSize) <br>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br>线程的生命周期<br>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态<br>(1)生命周期的五种状态<br>新建（new Thread） <br>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 <br>例如：Thread t1&#x3D;new Thread();<br>就绪（runnable） <br>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();<br>运行（running） <br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。<br>死亡（dead） <br>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。<br>自然终止：正常运行run()方法后终止<br>异常终止：调用stop()方法让一个线程终止运行<br>堵塞（blocked） <br>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。<br>正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）1. 锁机制<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。 <br>在Java里，线程安全一般体现在两个方面： <br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。 <br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>Volatile<br>在多线程并发编程中synchronized和Volatile都扮演着重要的角色，Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。悲观锁 乐观锁<br>乐观锁 悲观锁 <br>是一种思想。可以用在很多方面。<br>比如数据库方面。 <br>悲观锁就是for update（锁定查询的行） <br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）<br>JDK方面： <br>悲观锁就是sync <br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。 <br>乐观锁就认为，基本没人抢。<br>乐观锁（Optimistic Lock）： <br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。数据存储分析<br>mysql索引使用技巧及注意事项<br> INSERT 与 UPDATE 语句在拥有索引的表中执行会花费更多的时间，而SELECT 语句却会执行得更快。这是因为，在进行插入或更新时，数据库也需要插入或更新索引值。<br>索引的类型：<br>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值<br>INDEX(普通索引)：允许出现相同的索引内容<br>PROMARY KEY(主键索引)：不允许出现相同的值<br>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维<br>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一<br>(1)使用ALTER TABLE语句创建索性<br>ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）<br>(2)使用CREATE INDEX语句对表增加索引<br>CREATE INDEX index_name ON table_name(username(length));<br>&#x2F;&#x2F;create只能添加这两种索引;<br>CREATE INDEX index_name ON table_name (column_list)<br>CREATE UNIQUE INDEX index_name ON table_name (column_list)<br>(3)删除索引<br>删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下：<br>drop index index_name on table_name ;alter table table_name drop index index_name ;alter table table_name drop primary key ;<br>(4) 组合索引与前缀索引<br>create table USER_DEMO<br>(<br>ID int not null auto_increment comment ‘主键’,<br>LOGIN_NAME varchar(100) not null comment ‘登录名’,<br>PASSWORD varchar(100) not null comment ‘密码’,<br>CITY varchar(30) not null comment ‘城市’,<br>AGE int not null comment ‘年龄’,<br>SEX int not null comment ‘性别(0:女 1：男)’,<br>primary key (ID)<br>);<br>ALTER TABLE USER_DEMO ADD INDEX name_city_age (LOGIN_NAME(16),CITY,AGE);索引的使用及注意事项<br>Explain select * from user where id&#x3D;1;<br>    1.索引不会包含有NULL的列<br>       只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。<br>    2.使用短索引<br>       对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。<br>    3.索引列排序<br>       mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。<br>    4.like语句操作<br>      一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。<br>    5.不要在列上进行运算<br>    6.不使用NOT IN 、&lt;&gt;、！&#x3D;操作，但&lt;,&lt;&#x3D;，&#x3D;，&gt;,&gt;&#x3D;,BETWEEN,IN是可以用到索引的<br>    7.索引要建立在经常进行select操作的字段上。<br>       这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。<br>    8.索引要建立在值比较唯一的字段上。<br>    9.对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。<br>    10.在where和join中出现的列需要建立索引。<br>    11.where的查询条件里有不等号(where column !&#x3D; …),mysql将无法使用索引。<br>    12.如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…),mysql将无法使用索引。<br>    13.在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。<br>分表与分库使用场景以及设计方式<br>对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表！场景：分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master<br>服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。<br>因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!<br>MySQL有三种锁的级别：页级、表级、行级。<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br>存储引擎的 InnoDB 与 MyISAM<br>1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。<br>2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用<br>3）InnoDB支持外键，MyISAM不支持<br>4）从MySQL5.5.5以后，InnoDB是默认引擎<br>5）InnoDB不支持FULLTEXT类型的索引<br>6）InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表<br>7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引<br>8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表<br>9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’<br>索引数据结构设相关的计算机原理<br>上文说过，二叉树、红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-&#x2F;+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-&#x2F;+Tree作为索引的理论基础。<br>当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，你需增加order by，并且order by字段需要建立索引。<br>   如果使用子查询去优化LIMIT的话，则子查询必须是连续的，某种意义来讲，子查询不应该有where条件，where会过滤数据，使数据失去连续性。<br>   如果你查询的记录比较大，并且数据传输量比较大，比如包含了text类型的field，则可以通过建立子查询。<br>分布式系统唯一ID生成方案汇总<br>关系型数据库 MySQL<br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。<br>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>文档数据库 MongoDB<br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。<br>列族数据库 HBase<br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。<br>全文搜索引擎 ElasticSearch<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。<br>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。<br>MongoDB 特性	优势<br>事务支持	MongoDB 目前只支持单文档事务，需要复杂事务支持的场景暂时不适合<br>灵活的文档模型	JSON 格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代<br>高可用复制集	满足数据高可靠、服务高可用的需求，运维简单，故障自动切换<br>可扩展分片集群	海量数据存储，服务能力水平扩展<br>高性能	mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足各种场景需求<br>强大的索引支持	地理位置索引可用于构建 各种 O2O 应用、文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求<br>Gridfs	解决文件存储的需求<br>aggregation &amp; mapreduce	解决数据分析场景需求，用户可以自己写查询语句或脚本，将请求都分发到 MongoDB 上完成<br>从目前阿里云 MongoDB 云数据库上的用户看，MongoDB 的应用已经渗透到各个领域，比如游戏、物流、电商、内容管理、社交、物联网、视频直播等，以下是几个实际的应用案例。<br>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新<br>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。<br>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能<br>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析<br>视频直播，使用 MongoDB 存储用户信息、礼物信息等redis内部数据结构深入浅出<br>redis 是 key-value 存储系统，其中 key 类型一般为字符串，而 value 类型则为 redis 对象（redis object），可以绑定各种类型的数据，譬如 string、list 和set，redis.h 中定义了 struct redisObject，它是一个简单优秀的数据结构Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>Redis 如何实现持久化1. snapshotting(快照)<br>也是默认方式.(把数据做一个备份，将数据存储到文件)<br>快照是默认的持久化方式，这种方式是将内存中数据以快照的方式写到二进制文件中，默认的文件名称为dump.rdb.可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key键修改就自动做快照.<br> 2. Append-onlyfile(缩写aof)的方式        <br>aof方式:由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。aof比快照方式有更好的持久化性，是由于在使用aof时，redis会将每一个收到的写命令都通过write函数追加到文件中，当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。      <br>当然由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。可以通过配置文件告诉redis我们想要通过fsync函数强制os写入到磁盘的时机。<br>Redis 为什么是单线程的<br>要知道Redis的数据结构并不全是简单的Key-Value，还有列表，hash，map等等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，等等。这些操作还可以合成MULTI&#x2F;EXEC的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。这还带来一个恶果就是吞吐量虽然增大，但是响应延迟可能会增加。 <br>Redis在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用Lua脚本这样的功能。对于多线程来说这需要高得多的代价。44.使用传统的 Socket 开发挺简单的，我为什么要切换到 NIO 进行编程呢？<br>1.线程模型存在致命缺陷：一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>2.性能差：频繁的线程上下文切换导致 CPU 利用效率不高；<br>3.可靠性差：由于所有的 IO 操作都是同步的，所以业务线程只要进行 IO 操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br>4.采用非阻塞 IO（NIO）之后，同步阻塞 IO 的三个缺陷都将迎刃而解：<br>5.Nio 采用 Reactor 模式，一个 Reactor 线程聚合一个多路复用器 Selector，它可以同时注册、监听和轮询成百上千个 Channel，一个 IO 线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为 CPU 核数 + 1， N &lt; 进程可用的最大句柄数)；<br>6.由于 IO 线程总数有限，不会存在频繁的 IO 线程之间上下文切换和竞争，CPU 利用率高；<br>7.所有的 IO 操作都是异步的，即使业务线程直接进行 IO 操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。由于切换到 NIO 编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用 NIO 进行通信已经逐渐成为主流。# 什么是WebSockets？WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信信道。WebSocket是双向的 -使用WebSocket客户端或服务器可以发起消息发送。<br>WebSocket是全双工的 -客户端和服务器通信是相互独立的。<br>单个TCP连接 -初始连接使用HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信<br>Light -与http相比，WebSocket消息数据交换要轻得多。# 什么是CSRF攻击CSRF代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web应用程序上执行不需要的操作。CSRF攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。NOWCODER.COM<br>Java 面试题库<br>牛客网出品<br>NOWCODER.COM<br>Java 工程师校招面试题库导读<br>一、学习说明<br>本题库均来自海量真实校招面试题目大数据进行的整理，后续也会不断更新，可免费在线观<br>看，如需下载，也可在页面<br>载需要用牛币兑换，一次兑换可享受永久下载权限，因为后续会更新）<br>需要严肃说明的是：面试题库作为帮助同学准备面试的辅助资料，但是绝对不能作为备考唯<br>一途径，因为面试是一个考察真实水平的，不是背会了答案就可以的，需要你透彻理解的，<br>否则追问问题答不出来反而减分，毕竟技术面试中面试官最痛恨的就是背答案这个事情了。<br>学完这个题库，把此题库都理解透彻应对各家企业面试完全没有问题。（当然，要加上好的<br>项目以及透彻掌握）<br>另外，此面试题库中不包括面试中问到的项目，hr 面以及个人技术发展类。<br> 项目是比较个性化的，没办法作为一个题库来给大家参考，但是如果你有一个非常有含<br>金量的项目的话，是非常加分的，而且你的项目可能也会被问的多一些；<br> hr 面的话一般来说技术面通过的话个人没有太大的和公司不符合的问题都能通过；<br> 技术发展类的话这个就完全看自己啦，主要考察的会是你对技术的热爱和学习能力，比<br>如会问一些你是如何学习 xxx 技术的，或者能表达出你对技术的热爱的地方等等。此处<br>不做赘述。<br>那么抛开这些，Java 工程师中技术面中考察的占比如下：<br>需要注意的是：此图不绝对，因为实际面试中面试官会根据你的简历去问，比如你的项目多<br>NOWCODER.COM<br>可能就问的项目多一些，或者你说哪里精通可能面试官就多去问你这些。而且此图是根据题<br>库数据整理出来，并不是根据实际单场面试整理，比如基础部分不会考那么多，会从中抽着<br>考<br>但是面试中必考的点且占比非常大的有 Java 基础和算法。<br>决定你是否能拿 sp offer（高薪 offer）以及是否进名企的是项目和算法。<br>可以看出，算法除了是面试必过门槛以外，更是决定你是否能进名企或高薪 offer 的决定性<br>因素。<br>另外关于算法部分，想要系统的学习算法思想，实现高频面试题最优解等详细讲解的话可以<br>报名算法名企校招冲刺班或算法高薪校招冲刺班，你将能学到更先进的算法思想以及又一套<br>系统的校招高频题目的解题套路和方法论。<br>多出来的服务如下：<br>NOWCODER.COM<br>如果有什么问题，也可以加 qq 咨询 1440073724，如果是早鸟的话，还可以领取早鸟优惠哦<br>二、面试技巧<br>面试一般分为技术面和 hr 面，形式的话很少有群面，少部分企业可能会有一个交叉面，不<br>过总的来说，技术面基本就是考察你的专业技术水平的，hr 面的话主要是看这个人的综合<br>素质以及家庭情况符不符合公司要求，一般来讲，技术的话只要通过了技术面 hr 面基本上<br>是没有问题（也有少数企业 hr 面会刷很多人）<br>那我们主要来说技术面，技术面的话主要是考察专业技术知识和水平，我们是可以有一定的<br>技巧的，但是一定是基于有一定的能力水平的。<br>所以也慎重的告诉大家，技巧不是投机取巧，是起到辅助效果的，技术面最主要的还是要有<br>实力，这里是基于实力水平之上的技巧。<br>这里告诉大家面试中的几个技巧：<br>1、简历上做一个引导：<br>在词汇上做好区分，比如熟悉 Java，了解 python，精通 c 语言<br>这样的话对自己的掌握程度有个区分，也好让面试官有个着重去问，python 本来写的也只<br>是了解，自然就不会多问你深入的一些东西了。<br>2、在面试过程中做一个引导：<br>面试过程中尽量引导到自己熟知的一个领域，比如问到你说一下 DNS 寻址，然后你简单回<br>答（甚至这步也可以省略）之后，可以说一句，自己对这块可能不是特别熟悉，对计算机网<br>络中的运输层比较熟悉，如果有具体的，甚至可以再加一句，比如 TCP 和 UDP<br>这样的话你可以把整个面试过程往你熟知的地方引导，也能更倾向于体现出你的优势而不是<br>劣势，但是此方法仅限于掌握合适的度，比如有的知识点是必会的而你想往别处引就有点说<br>不过去了，比如让你说几个 Java 的关键字，你一个也说不上来，那可能就真的没辙了。<br>3、在自我介绍中做一个引导：<br>一般面试的开头都会有一个自我介绍，在这个位置你也可以尽情的为自己的优势方面去引导。<br>4、面试过程中展示出自信：<br>面试过程中的态度也要掌握好，不要自卑，也不要傲娇，自信的回答出每个问题，尤其遇到<br>不会的问题，要么做一些引导，实在不能引导也可以先打打擦边球，和面试官交流一下问题，<br>看起来像是没听懂题意，这个过程也可以再自己思考一下，如果觉得这个过程可以免了的话<br>也直接表明一下这个地方不太熟悉或者还没有掌握好，千万不要强行回答。<br>面试前的准备：<br>NOWCODER.COM<br>最重要的肯定是系统的学习了，有一个知识的框架，基础知识的牢靠程度等。<br>其中算法尤其重要，越来越多公司还会让你现场或者视频面试中手写代码；<br>另一大重要的和加分项就是项目，在面试前，一定要练习回答自己项目的三个问题：<br> 这是一个怎样的项目<br> 用到了什么技术，为什么用这项技术（以及每项技术很细的点以及扩展）<br> 过程中遇到了什么问题，怎么解决的。<br>那么话说回来，这个的前提是你要有一个好的项目，牛客网 CEO 叶向宇有带大家做项目，<br>感兴趣的可以去了解一下<br> 竞争力超过 70%求职者的项目：<br>（专属优惠码：DjPgy3x，每期限量前 100 个）<br> 竞争力超过 80%求职者的项目：<br>（专属优惠码：DMVSexJ，每期限量前 100 个）<br>知识都掌握好后，剩下的就是一个心态和模拟练习啦，因为你面试的少的话现场难免紧张，<br>而且没在那个环境下可能永远不知道自己回答的怎么样。<br>因为哪怕当你都会了的情况下，你的表达和心态就显得更重要了，会了但是没有表达的很清<br>晰就很吃亏了，牛客网这边有 AI 模拟面试，完全模拟了真实面试环境，正好大家可以真正<br>的去练习一下，还能收获一份面试报告：<br>面试后需要做的：<br>面试完了的话就不用太在意结果了，有限的时间就应该做事半功倍的事情，当然，要保持电<br>话邮箱畅通，不然别给你发 offer 你都不知道。<br>抛开这些，我们需要做的是及时将面试中的问题记录下来，尤其是自己回答的不够好的问题，<br>一定要花时间去研究，并解决这些问题，下次面试再遇到相同的问题就能很好的解决，当然，<br>即使不遇到，你这个习惯坚持住，后面也可以作为一个经历去跟面试官说，能表现出你对技<br>术的喜爱和钻研的一个态度，同时，每次面试后你会发现自己的不足，查缺补漏的好机会，<br>及时调整，在不断的调整和查缺补漏的过程中，你会越来越好。 三、面试考点导图<br>NOWCODER.COM<br>NOWCODER.COM<br>四、一对一答疑讲解戳这里<br>如果你对校招求职或者职业发展很困惑，欢迎与牛客网专业老师沟通，老师会帮你一对一讲<br>解答疑哦（可以扫下方二维码或者添加微信号：niukewang985）<br>NOWCODER.COM<br>目录<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>②关键字<br>③面向对象<br>④集合部分<br>2、Java 高级知识<br>①线程<br>②锁<br>③JDK<br>④反射<br>⑤JVM<br>⑥GC<br>⑦ IO 和 NIO，AIO<br>二、JavaEE 部分<br>1、Spring<br>①IoC 与 Bean 配置、管理<br>②AOP 与事务、权限控制<br>③S2SH 整合开发<br>④Spring，JPA 整合<br>2、Hibernate<br>①ORM 与持久化映射<br>②延迟加载、性能优化<br>③HQL 查询、条件查询、SQL 查询<br>④二级缓存与查询缓存<br>3、Struts<br>①MVC 模式与 Struts 体系<br>4、mybatis<br>5、MVC 框架<br>6、各框架对比与项目优化<br>7、JPA<br>①EJB<br>三、Java web 开发核心内容<br>1、web 编程基础<br>①Tomcat 服务器<br>NOWCODER.COM<br>②JSP 语法，EL，内置对象<br>③Listener 和 filter<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>②redis<br>③MVC 和 DAO<br>④JSTL、DisplayTag 等常见标签库的用法<br>3、Web 编程原理<br>① HTTP 协议<br>②请求&#x2F;相应架构原理<br>③web 容器<br>四、JDBC 编程<br>1、SQL 基础<br>2、JDBC 基础<br>①数据库<br>②数据库连接池<br>③事物管理，批处理<br>3、JDBC 进阶<br>五、XML 编程<br>1、XML 基础<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>六、计算机网络<br>1、网络概述<br>①关于分层<br>2、运输层<br>①TCP 与 UDP<br>②协议<br>3、网络层<br>①网际协议 IP<br>②网际控制报文协议 ICMP<br>③因特网的路由器选择协议<br>4、应用层<br>①域名系统 DNS<br>②电子邮件<br>NOWCODER.COM<br>七、操作系统<br>1、操作系统概论<br>2、进程的描述与控制<br>3、输入输出系统<br>4、存储器管理<br>5、处理机调度与死锁<br>八、算法与数据结构<br>1、哈希<br>2、树<br>3、遍历<br>4、链表<br>5、数组<br>6、排序<br>7、堆与栈<br>8、队列<br>9、高级算法<br>九、设计模式<br>1、结构型模式<br>①代理模式<br>②装饰模式<br>③适配器模式<br>2、创建型模式<br>①单例模式<br>3、行为型模式<br>①策略模式<br>②观察者模式<br>4、所有模式汇总<br>十、场景题<br>十一、UML<br>更多名企历年笔试真题可点击直接进行练习：<br>NOWCODER.COM<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>1、为什么重写 equals 还要重写 hashcode？<br>考点：java 基础<br>参考回答：<br>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()<br>方法继承于 Object 类，其 hashcode 码为默认的内存地址，这样即便有相同含义的两个对象，比<br>较也是不相等的。HashMap 中的比较 key 是这样的，先求出 key 的 hashcode(),比较其值是否相<br>等，若相等再比较 equals(),若相等则认为他们是相等的。若 equals()不相等则认为他们不相等。<br>如果只重写 hashcode()不重写 equals()方法，当比较 equals()时只是看他们是否为同一对象（即<br>进行内存地址的比较）,所以必定要两个方法一起重写。HashMap 用来判断 key 是否相等的方法，<br>其实是调用了 HashSet 判断加入元素 是否相等。重载 hashCode()是为了对同一个 key，能得到<br>相同的 Hash Code，这样 HashMap 就可以定位到我们指定的 key 上。重载 equals()是为了向<br>HashMap 表明当前对象和 key 上所保存的对象是相等的，这样我们才真正地获得了这个 key 所对<br>应的这个键值对。<br>2、说一下 map 的分类和常见的情况<br>考点：java 基础<br>参考回答：<br>java 为数据结构中的映射定义了一个接口 java.util.Map;它有四个实现类,分别是 HashMap<br>Hashtable LinkedHashMap 和 TreeMap.<br>Map 主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重<br>复。<br>Hashmap 是一个最常用的 Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的<br>值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap 最多只允许一条<br>记录的键为 Null;允许多条记录的值为 Null;HashMap 不支持线程的同步，即任一时刻可以有多<br>个线程同时写 HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections 的<br>synchronizedMap 方法使 HashMap 具有同步的能力，或者使用 ConcurrentHashMap。<br>Hashtable 与 HashMap 类似,它继承自 Dictionary 类，不同的是:它不允许记录的键或者值<br>为空;它支持线程的同步，即任一时刻只有一个线程能写 Hashtable,因此也导致了 Hashtable<br>在写入时会比较慢。<br>NOWCODER.COM<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排<br>序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，<br>遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和<br>容量无关，而 HashMap 的遍历速度和他的容量有关。<br>TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>一般情况下，我们用的最多的是 HashMap,在 Map 中插入、删除和定位元素，HashMap 是最<br>好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。如果需要输出的<br>顺序和输入的相同,那么用 LinkedHashMap 可以实现,它还可以按读取顺序来排列.<br>HashMap 是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的<br>值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。<br>HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的<br>不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的<br>能力。<br>Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，<br>即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。<br>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的<br>记录肯定是先插入的。<br>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，<br>也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？<br>考点：基础<br>参考回答：<br>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回<br>对象的 内存地址。<br>4、&#x3D;&#x3D;比较的是什么？<br>考点：基础<br>参考回答：<br>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，<br>“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。<br>NOWCODER.COM<br>5、若对一个类不重写，它的 equals()方法是如何比较的？<br>考点：基础<br>参考回答：<br>比较是对象的地址。<br>6、java8 新特性<br>考察点：java8<br>参考回答：<br>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。<br>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）<br>的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。<br>新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。<br>Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到<br>Java 中。<br>Date Time API − 加强对日期与时间的处理。<br>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许<br>我们在 JVM 上运行特定的 javascript 应用。<br>7、说说 Lamda 表达式的优缺点。<br>考察点：Java 基础<br>参考回答：<br>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。<br>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时<br>需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码<br>不容易让其他语言的程序员看懂。<br>8、一个十进制的数在内存中是怎么存的？<br>考察点：计算机基础<br>NOWCODER.COM<br>参考回答：<br>补码的形式。<br>9、为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？<br>考察点：计算机基础<br>参考回答：<br>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小<br>数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。<br>10、Java 支持的数据类型有哪些？什么是自动拆装箱？<br>考察点：JAVA 数据类型<br>参考回答：<br>Java 语言支持的 8 种基本数据类型是：<br>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：<br>把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。<br>11、什么是值传递和引用传递？<br>考察点：JAVA 引用传递<br>参考回答：<br>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。<br>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递. 12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不<br>是 ArrayList？<br>考察点：Array<br>NOWCODER.COM<br>参考回答：<br>Array 和 ArrayList 的不同点：<br>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。<br>Array 大小是固定的，ArrayList 的大小是动态变化的。<br>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类<br>型的时候，这种方式相对比较慢。<br>13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？<br>考察点：JAVA notation<br>参考回答：<br>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下<br>有多么好。<br>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般<br>使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一<br>个很好的说明。<br>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。<br>其函数表示是：<br>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));<br>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。<br>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使<br>用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好<br>的说明。<br>14、String 是最基本的数据类型吗?<br>考察点：数据类型<br>参考回答：<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效<br>率节省空间，我们应该用 StringBuffer 类。<br>15、int 和 Integer 有什么区别<br>考察点：数据类型<br>NOWCODER.COM<br>参考回答：<br>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据<br>类型，Integer 是 java 为 int 提供的封装类。<br>Java 为每个原始类型提供了封装类。<br>原始类型封装类<br>booleanBoolean<br>charCharacter<br>byteByte<br>shortShort<br>intInteger<br>longLong<br>floatFloat<br>doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同<br>的特征和用法，它们包括：大小和速<br>度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时<br>所指定的缺省值。对象引用实例变量<br>的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。<br>16、String 和 StringBuffer 的区别<br>考察点：数据类型<br>参考回答：<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多<br>个字符的字符数据。这个 String 类提供了<br>数值不可改变的字符串。而这个 StringBuffer 类提供的字符串进行修改。当你知道字符数据要<br>改变的时候你就可以使用 StringBuffer 。典型地，你可以使用 StringBuffers 来动态构造字符数据。<br>17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1<br>等，如何输出一个某种编码的字符串？<br>考察点：数据类型<br>参考回答：<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1″), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>NOWCODER.COM<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>18、int 和 Integer 有什么区别？<br>考察点：数据类型<br>参考回答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，<br>但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的<br>包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱<br>机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：* 原始类型: boolean，char，byte，short，int，long，float，double</li></ol><ul><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<br>如：<br>class AutoUnboxingTest {<br>public static void main(String[] args) {<br>Integer a &#x3D; new Integer(3);<br>Integer b &#x3D; 3; &#x2F;&#x2F; 将 3 自动装箱成 Integer 类型<br>int c &#x3D; 3;<br>System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false 两个引用没有引用同一对象<br>System.out.println(a &#x3D;&#x3D; c); &#x2F;&#x2F; true a 自动拆箱成 int 类型再和 c 比较<br>}<br>}<br>19、&amp;和&amp;&amp;的区别？<br>考察点：运算符<br>参考回答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的<br>差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是<br>NOWCODER.COM<br>true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直<br>接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定<br>用户名不是 null 而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，<br>二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的<br>equals 比较，否则会产生 NullPointerException 异常。<br>20、在 Java 中，如何跳出当前的多重嵌套循环？<br>考察点：循环<br>参考回答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标<br>签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时<br>候甚至有相反的作用，所以这种语法其实不知道更好）<br>21、你能比较一下 Java 和 JavaSciprt 吗？<br>考察：Java&amp;JavaScript<br>参考回答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司<br>推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape<br>公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对<br>象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：</li><li>基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设<br>计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软<br>件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身<br>提供了非常丰富的内部对象供设计人员使用。</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，<br>其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技<br>术来提升 JavaScript 的运行效率）</li><li>强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；<br>JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行<br>时检查推断其数据类型。</li><li>代码格式不一样。<br>22、简述正则表达式及其用途。<br>考察点：正则表达式<br>参考回答：<br>NOWCODER.COM<br>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式<br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的<br>信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大<br>的工具，绝大多数语言都提供了对正则表达式的支持。<br>23、Java 中是如何支持正则表达式操作的？<br>考察点：正则表达式<br>参考回答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、<br>replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰<br>富的 API 进行各种正则表达式操作，如：<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;<br>class RegExpTest {<br>public static void main(String[] args) {<br>String str &#x3D; “成都市(成华区)(武侯区)(高新区)”;<br>Pattern p &#x3D; Pattern.compile(“.*?(?&#x3D;\()”);<br>Matcher m &#x3D; p.matcher(str);<br>if(m.find()) {<br>System.out.println(m.group());<br>}<br>}<br>}<br>24、请你说说 Java 和 PHP 的区别？<br>考察点：Java 特性<br>参考回答：<br>PHP 暂时还不支持像 Java 那样 JIT 运行时编译热点代码,但是 PHP 具有 opcache 机制,能够<br>把脚本对应的 opcode 缓存在内存,PHP7 中还支持配置 opcache.file_cache 导出 opcode 到文件. 第三方的 Facebook HHVM 也支持 JIT.另外 PHP 官方基于 LLVM 围绕 opcache 机制构建的 Zend JIT<br>分支也正在开发测试中.在 php-src&#x2F;Zend&#x2F;bench.php 测试显示,PHP JIT 分支速度是 PHP 5.4 的<br>10 倍.<br>PHP 的库函数用 C 实现,而 Java 核心运行时类库(jdk&#x2F;jre&#x2F;lib&#x2F;rt.jar,大于 60MB)用 Java 编写<br>(jdk&#x2F;src.zip), 所以 Java 应用运行的时候,用户编写的代码以及引用的类库和框架都要在 JVM<br>上解释执行. Java 的 HotSpot 机制,直到有方法被执行 10000 次才会触发 JIT 编译, 在此之前运<br>行在解释模式下,以避免出现 JIT 编译花费的时间比方法解释执行消耗的时间还要多的情况.<br>PHP 内置模板引擎,自身就是模板语言.而 Java Web 需要使用 JSP 容器如 Tomcat 或第三方模<br>板引擎.<br>NOWCODER.COM<br>PHP 也可以运行在多线程模式下,比如 Apache 的 event MPM 和 Facebook 的 HHVM 都是多线程<br>架构.不管是多进程还是多线程的 PHP Web 运行模式,都不需要 PHP 开发者关心和控制,也就是说<br>PHP 开发者不需要写代码参与进程和线程的管理,这些都由 PHP-FPM&#x2F;HHVM&#x2F;Apache 实现.PHP-FPM<br>进程管理和并发实现并不需要 PHP 开发者关心,而 Java 多线程编程需要 Java 开发者编码参<br>与.PHP 一个 worker 进程崩溃,master 进程会自动新建一个新的 worker 进程,并不会导致 PHP 服<br>务崩溃.而 Java 多线程编程稍有不慎(比如没有捕获异常)就会导致 JVM 崩溃退出.对于 PHP-FPM<br>和 Apache MOD_PHP 来说,服务进程常驻内存,但一次请求释放一次资源,这种内存释放非常彻底.<br>PHP 基于引用计数的 GC 甚至都还没发挥作用程序就已经结束了。 ②关键字<br>1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什<br>么？如果修饰成员方法，锁住了什么？<br>考点：java 关键字<br>参考回答：<br>synchronized 修饰静态方法以及同步代码块的 synchronized (类.class)用法锁的是类，线<br>程想要执行对应同步代码，需要获得类锁。<br>synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。<br>2、介绍一下 volatile？<br>考察点：java 关键字<br>参考回答：<br>volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。比如我们所写的<br>代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，<br>这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高 CPU 的执行效<br>率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有<br>happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面<br>对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先 Java 内存模<br>型分为，主内存，工作内存。比如线程 A 从主内存把变量从主内存读到了自己的工作内存中，做<br>了加 1 的操作，但是此时没有将 i 的最新值刷新会主内存中，线程 B 此时读到的还是 i 的旧值。<br>加了 volatile 关键字的代码生成的汇编代码发现，会多出一个 lock 前缀指令。Lock 指令对 Intel<br>平台的 CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多<br>核之间数据不一致性问题。<br>3、锁有了解嘛，说一下 Synchronized 和 lock<br>考察点：java 关键字<br>NOWCODER.COM<br>参考回答：<br>synchronized 是 Java 的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证<br>在同一时刻最多只有一个线程执行该段代码。JDK1.5 以后引入了自旋锁、锁粗化、轻量级锁，<br>偏向锁来有优化关键字的性能。<br>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；<br>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock<br>在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock<br>时需要在 finally 块中释放锁；Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，<br>使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没<br>有成功获取锁，而 synchronized 却无法办到。<br>4、讲一讲 Java 里面的 final 关键字怎么用的？<br>考察点：关键字<br>参考回答：<br>当用 final 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他<br>被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注<br>意 final 类中的所有成员方法都会被隐式地指定为 final 方法。<br>“使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；<br>第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法<br>过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final<br>方法进行这些优化了。“<br>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；<br>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 ③面向对象<br>1、wait 方法底层原理<br>考察点：基础<br>参考回答：<br>ObjectSynchronizer::wait 方法通过 object 的对象中找到 ObjectMonitor 对象调用方法<br>void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)<br>通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队<br>列的末尾中然后在 ObjectMonitor::exit 释放锁，接着 thread_ParkEvent-&gt;park 也就是 wait。<br>NOWCODER.COM<br>2、Java 有哪些特性，举个多态的例子。<br>考察点：语言特性<br>参考回答：<br>封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据<br>发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）<br>3、String 为啥不可变？<br>考察点：面向对象<br>参考回答：<br>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不<br>能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对<br>象，引用类型指向的对象的状态也不能改变。<br>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字<br>节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以<br>在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串<br>是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得<br>数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不<br>可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安<br>全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，<br>这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的<br>所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计<br>算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是<br>HashMap 中的键往往都使用字符串的原因。<br>4、类和对象的区别<br>考察点：面向对象<br>参考回答：<br>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。<br>比如：“人”是一个类，而“教师”则是“人”的一个实例。<br>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性<br>的对象集合体。<br>5、请列举你所知道的 Object 类的方法。<br>考察点：面向对象<br>NOWCODER.COM<br>参考回答：<br>Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指<br>示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引<br>用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回<br>该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此<br>对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等<br>待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导<br>致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超<br>过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此<br>对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某<br>个实际时间量。<br>6、重载和重写的区别？相同参数不同返回值能重载吗？<br>考察点：重载<br>参考回答：<br>重载(Overloading)<br>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，<br>具有不同的参数个数&#x2F;类型。<br>重载 Overloading 是一个类中多态性的一种表现。<br>（2） Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同<br>的参数和不同的定义。<br>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是<br>多态性。<br>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可<br>以不相同。无法以返回型别作为重载函数的区分标准。<br>重写（Overriding）<br>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与<br>其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类<br>中的方法，而不需要重新编写相同的方法。<br>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的<br>重写。<br>方法重写又称方法覆盖。<br>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法<br>将覆盖原有的方法。<br>如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。<br>NOWCODER.COM<br>（3）子类函数的访问修饰权限不能少于父类的。<br>7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private<br>或者是 static 的方法？<br>考察点：static 变量<br>参考回答：<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情<br>况下被访问。<br>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编<br>译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。<br>8、String 能继承吗？<br>考察点：String<br>参考回答：<br>不能，char 数组用 final 修饰的。<br>9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？<br>考察点：类<br>参考回答：<br>StringBuffer 线程安全，StringBuilder 线程不安全，底层实现上的话，StringBuffer 其<br>实就是比 StringBuilder 多了 Synchronized 修饰符。<br>10、类加载机制，双亲委派模型，好处是什么？<br>考察点：类<br>参考回答：<br>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，<br>如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才<br>自己去加载。<br>使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次<br>关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最<br>终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各<br>种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的<br>话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现<br>NOWCODER.COM<br>多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的<br>Java 类，可以正常编译，但是永远无法被加载运行。<br>11、静态变量存在哪?<br>考察点：类<br>参考回答：<br>方法区<br>12、讲讲什么是泛型？<br>考察点：JAVA 泛型<br>参考回答：<br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法<br>时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，<br>类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;<br>调用时传入具体的类型（类型实参）。</li></ul><p>采用泛型写法后，在&#x2F;&#x2F;1 处想加入一个 Integer 类型的对象时会出现编译错误，通过<br>List&lt;String&gt;，直接限定了 list 集合中只能含有 String 类型的元素，从而在&#x2F;&#x2F;2 处无须进行强<br>制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是 String 类型<br>了。<br>13、解释 extends 和 super 泛型限定符-上界不存下界不取<br>考察点：JAVA 泛型<br>参考回答：<br>（1）泛型中上界和下界的定义<br>上界 &lt;? extend Fruit&gt;<br>下界 &lt;? super Apple&gt;<br>（2）上界和下界的特点<br>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）<br>下界的 list 只能 add，不能 get<br>（3）示例代码</p><p>（4）上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确<br>定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，<br>不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把<br>所有的子类向上转型为 Fruit。<br>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。<br>那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父<br>类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple<br>及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接<br>着呢，除了 Object，其他的都接不住。<br>NOWCODER.COM<br>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。<br>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引<br>用就必须得用 cast。<br>14、是否可以在 static 环境中访问非 static 变量？<br>考察点：static 变量<br>参考回答：<br>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机<br>载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，<br>编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。<br>15、谈谈如何通过反射创建对象？<br>考察点：类<br>参考回答：</p><ul><li>方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()</li><li>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器<br>（Constructor）对象并调用其 newInstance()方法创建对象，例如：<br>String.class.getConstructor(String.class).newInstance(“Hello”);<br>16、Java 支持多继承么？<br>考察点：JAVA 多继承<br>参考回答：<br>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口<br>支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子<br>接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</li></ul><p>18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。<br>考察点：comparable 接口<br>参考回答：<br>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象<br>排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两<br>个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()<br>方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也<br>是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回<br>true。</p><p>23、Static Nested Class 和 Inner Class 的不同<br>考察点：声明<br>参考回答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被<br>实例化。而通常的内部类需要在外部类实<br>例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义<br>为动态的(instance).Nested Class 的静态成员(Method)只能对 Outer Class 的静态成员(static<br>memebr)进行操作(ACCESS), 而不能 Access Outer Class 的动态成员(instance member).而<br>Nested Class 的动态成员(instance method) 却可以 Access Outer Class 的所有成员, 这个概<br>念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而 动<br>态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)<br>永远不可以 Access 跟 object 相关的动态成员(instance member),反过来就可以, 一个 CLASS<br>的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，<br>并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>考察点：对象<br>参考回答：<br>是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中<br>时，参数的值就是对该对象的引用。对象<br>的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。<br>25、Java 的接口和 C++的虚类的相同和不同处。<br>考察点：接口<br>参考回答：<br>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或<br>属性，现有的单继承机制就不能满足要求。<br>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，<br>该类要实现接口里面所有的方法和属<br>NOWCODER.COM<br>性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。<br>26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally<br>分别代表什么意义？在 try 块中可以抛出异常吗？<br>考察点：异常<br>参考回答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接<br>口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个<br>异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个<br>异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br>用 try 来指定一块预防所有”异常”的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指<br>定你想要捕捉的”异常”的类型。throw 语句用来明确地抛出一个”异常”。throws 用来标明一<br>个成员函数可能抛出的各种”异常”。Finally 为确保一段代码不管发生什么”异常”都被执行<br>一段代码。可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try<br>语句保护其他代码。每当遇到一个 try 语句，”异常“的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有<br>处理这种”异常”的 try 语句。<br>27、内部类可以引用他包含类的成员吗？有没有什么限制？<br>考察点：类<br>参考回答：<br>一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是 static 的，那么它<br>可以访问创建它的外部类对象的所有属性内部类如果是 sattic 的，即为 nested class，那么它<br>只可以访问创建它的外部类对象的所有 static 属性一般普通类只有 public 或 package 的访问修<br>饰，而内部类可以实现 static，protected，private 等访问修饰。当从外部类继承的时候，内<br>部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明<br>确地继承，就可以覆盖原来内部类的方法。<br>28、两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code 说法<br>是否正确？<br>考察点：对象<br>参考回答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当<br>相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals<br>方法返回 true），那么它们的 hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它<br>NOWCODER.COM<br>们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容<br>器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存<br>储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>30、如何通过反射获取和设置对象私有字段的值？<br>考察点：类<br>参考回答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段对象的<br>setAccessible(true)将其设置为可以访问，接下来就可以通过 get&#x2F;set 方法来获取&#x2F;设置字段的<br>值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段<br>的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如<br>ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得 dog 对象的主人的汽车的引擎的<br>ID 号。31、谈一下面向对象的”六原则一法则”。<br>考察点：Java 对象<br>参考回答：<br>NOWCODER.COM</p><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写<br>代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功<br>能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内<br>聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到<br>变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶<br>皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到<br>其他系统中使用的，这样才能实现软件复用的目标。）- 开闭原则：软件实体应当对扩展开放，<br>对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系<br>统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是<br>关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可<br>变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不<br>清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- 依赖倒<br>转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类<br>型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一<br>个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换<br>掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简<br>单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，<br>如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。<br>例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容<br>易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的<br>能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示<br>能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分<br>别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方<br>法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会<br>几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、<br>代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- 合成聚合复用<br>原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用<br>得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之<br>间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其<br>中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A<br>关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可<br>以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例<br>子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错<br>误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置<br>为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。<br>记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- 迪<br>米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂<br>的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter<br>不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的<br>请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内<br>存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到<br>一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设<br>备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。<br>NOWCODER.COM<br>32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？<br>考察点：接口<br>参考回答：<br>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的<br>前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使<br>用 iterate()方法可以减少性能开销。<br>② list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题<br>33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？<br>考察点：方法<br>参考回答：<br>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的<br>情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参<br>数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。<br>34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？<br>考察点：JAVA 构造函数<br>参考回答：<br>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提<br>供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。<br>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必<br>须有它自己唯一的参数列表。<br>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，<br>Java 不会创建默认的复制构造函数。<br>35、hashCode()和 equals()方法有什么联系？<br>考点：基础<br>参考回答：<br>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<br>➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>➁ 如果两个对象的 hashCode 相同，它们并不一定相同。<br>NOWCODER.COM<br>④集合部分<br>1、Map 和 ConcurrentHashMap 的区别？<br>考点：集合<br>参考回答：<br>hashmap 是线程不安全的，put 时在多线程情况下，会形成环从而导致死循环。<br>CoucurrentHashMap 是线程安全的，采用分段锁机制，减少锁的粒度。<br>2、hashMap 内部具体如何实现的？<br>考点：集合<br>参考回答：<br>Hashmap 基于数组实现的，通过对 key 的 hashcode &amp; 数组的长度得到在数组中位置，如当<br>前数组有元素，则数组当前元素 next 指向要插入的元素，这样来解决 hash 冲突的，形成了拉链<br>式的结构。put 时在多线程情况下，会形成环从而导致死循环。数组长度一般是 2n，从 0 开始编<br>号，所以 hashcode &amp; （2n-1），（2n-1）每一位都是 1，这样会让散列均匀。需要注意的是，<br>HashMap 在 JDK1.8 的版本中引入了红黑树结构做优化，当链表元素个数大于等于 8 时，链表转<br>换成树结构；若桶中链表元素个数小于等于 6 时，树结构还原成链表。因为红黑树的平均查找长<br>度是 log(n)，长度为 8 的时候，平均查找长度为 3，如果继续使用链表，平均查找长度为 8&#x2F;2&#x3D;4，<br>这才有转换为树的必要。链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，虽然速度也很快的，但是转化为<br>树结构和生成树的时间并不会太短。还有选择 6 和 8，中间有个差值 7 可以有效防止链表和树频<br>繁转换。假设一下，如果设计成链表个数超过 8 则链表转换成树结构，链表个数小于 8 则树结构<br>转换成链表，如果一个 HashMap 不停的插入、删除元素，链表个数在 8 左右徘徊，就会频繁的发<br>生树转链表、链表转树，效率会很低。<br>3、如果 hashMap 的 key 是一个自定义的类，怎么办？<br>考点：集合<br>参考回答：<br>使用 HashMap，如果 key 是自定义的类，就必须重写 hashcode()和 equals()。<br>4、ArrayList 和 LinkedList 的区别，如果一直在 list 的尾部添加元素，用哪<br>个效率高？<br>考点：集合<br>参考回答：<br>NOWCODER.COM<br>ArrayList 采用数组数组实现的，查找效率比 LinkedList 高。LinkedList 采用双向链表实<br>现的，插入和删除的效率比 ArrayList 要高。一直在 list 的尾部添加元素，LinkedList 效率要<br>高。<br>5、HashMap 底层，负载因子，为啥是 2^n？<br>考点：集合<br>参考回答：<br>负载因子默认是 0.75， 2^n 是为了让散列更加均匀，例如出现极端情况都散列在数组中的<br>一个下标，那么 hashmap 会由 O（1）复杂退化为 O（n）的。<br>6、ConcurrentHashMap 锁加在了哪些地方？<br>考点：集合<br>参考回答：<br>加在每个 Segment 上面。<br>7、TreeMap 底层，红黑树原理？<br>考点：集合<br>参考回答：<br>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证<br>当需要快速检索指定节点。<br>红黑树的插入、删除、遍历时间复杂度都为 O(lgN)，所以性能上低于哈希表。但是哈希表<br>无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑<br>树性质：<br>性质 1：每个节点要么是红色，要么是黑色。<br>性质 2：根节点永远是黑色的。<br>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。<br>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续<br>的红色节点）<br>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。<br>8、concurrenthashmap 有啥优势，1.7，1.8 区别？<br>NOWCODER.COM<br>考点：集合<br>参考回答：<br>Concurrenthashmap 线程安全的，1.7 是在 jdk1.7 中采用 Segment + HashEntry 的方式进<br>行实现的，lock 加在 Segment 上面。1.7size 计算是先采用不加锁的方式，连续计算元素的个数，<br>最多计算 3 次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果<br>前后两次计算结果都不同，则给每个 Segment 进行加锁，再计算一次元素的个数；<br>1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node + CAS + Synchronized 来<br>保证并发安全进行实现，1.8 中使用一个 volatile 类型的变量 baseCount 记录元素的个数，当<br>插入新数据或则删除数据时，会通过 addCount()方法更新 baseCount，通过累加 baseCount 和<br>CounterCell 数组中的数量，即可得到元素的总个数；<br>9、ArrayList 是否会越界？<br>考点：集合<br>参考回答：<br>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构 2. 对<br>于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList<br>并发 add()可能出现数组下标越界异常<br>10、什么是 TreeMap?<br>考察点：key-value 集合<br>参考回答：<br>TreeMap 是一个有序的 key-value 集合，基于红黑树（Red-Black tree）的 NavigableMap<br>实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，<br>具体取决于使用的构造方法。<br>TreeMap 的特性：<br>根节点是黑色<br>每个节点都只能是红色或者黑色<br>每个叶节点（NIL 节点，空节点）是黑色的。<br>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个<br>红色的节点。<br>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>NOWCODER.COM<br>11、ConcurrentHashMap 的原理是什么？<br>考察点：JAVA 内存模型<br>参考回答：<br>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封<br>装映射表的键 &#x2F; 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的<br>若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例<br>中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在<br>HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。<br>static final class HashEntry&lt;K,V&gt; {<br>final K key; &#x2F;&#x2F; 声明<br>key 为 final 型<br>final int hash; &#x2F;&#x2F; 声明 hash<br>值为 final 型<br>volatile V value; &#x2F;&#x2F; 声明 value 为<br>volatile 型<br>final HashEntry&lt;K,V&gt; next; &#x2F;&#x2F; 声明 next 为 final 型<br>HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) {<br>this.key &#x3D; key;<br>this.hash &#x3D; hash;<br>this.next &#x3D; next;<br>this.value &#x3D; value;<br>}<br>}<br>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰<br>撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，<br>所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry<br>对象后的结构图：<br>图 1. 插入三个节点后桶的结构示意图：<br>NOWCODER.COM<br>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。<br>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个<br>Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。<br>12、Java 集合类框架的基本接口有哪些？<br>考察点：JAVA 集合<br>参考回答：<br>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它<br>自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基<br>本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的 Collection。<br>List：有顺序的 collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。<br>13、为什么集合类没有实现 Cloneable 和 Serializable 接口？<br>考察点：JAVA 集合<br>参考回答：<br>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，<br>应该由集合类的具体实现来决定如何被克隆或者是序列化。<br>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创<br>建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果<br>你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应<br>用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化<br>14、什么是迭代器？<br>考察点：JAVA 迭代器<br>参考回答：<br>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接<br>口,<br>NOWCODER.COM<br>每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合<br>的元素进行迭代操作. 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出<br>ConcurrentModificationException<br>异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除. 15、Iterator 和 ListIterator 的区别是什么？<br>考察点：迭代器<br>参考回答：<br>Iterator 和 ListIterator 的区别是：<br>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。<br>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前<br>一个和后一个元素的索引，等等。<br>16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？<br>考察点：集合<br>参考回答：<br>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。<br>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的<br>类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全<br>失败的迭代器永远不会抛出这样的异常。<br>18、ArrayList 和 LinkedList 有什么区别？<br>考察点：ArrayList<br>参考回答：<br>NOWCODER.COM<br>ArrayList 和 LinkedList 都实现了 List 接口，他们有以下的不同点：<br>ArrayList 是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行随机<br>访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个<br>和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。<br>相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任<br>意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向<br>前一个元素，一个指向下一个元素。<br>19、ArrayList,Vector,LinkedList 的存储性能和特性是什么？<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索<br>引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector<br>由于使用了 synchronized 方法（线程<br>安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据<br>需要进行前向或后向遍历，但是插入数<br>据时只需要记录本项的前后项即可，所以插入速度较快。<br>20、Collection 和 Collections 的区别。<br>考察点：集合<br>参考回答：<br>Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.<br>Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、<br>线程安全化等操作。<br>21、你所知道的集合类都有哪些？主要方法？<br>考察点：集合<br>参考回答：<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可<br>变大小的列表，比较适合构建、存储和操<br>作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其<br>中每个键映射到一个值。</li></ul><p>23、阐述 ArrayList、Vector、LinkedList 的存储性能和特性<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操<br>作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector<br>是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使<br>用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号<br>索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号<br>索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速<br>度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、<br>BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和<br>LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具<br>类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢<br>模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。<br>24、List、Map、Set 三个接口存取元素时，各有什么特点？<br>考察点：List<br>参考回答：<br>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals()<br>方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一<br>或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理<br>论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的<br>键（key）构成排序树从而达到排序和去重的效果。<br>NOWCODER.COM<br>2、Java 高级知识<br>①线程<br>1、多线程中的 i++线程安全吗？为什么？<br>考察点：多线程<br>参考回答：<br>不安全。i++不是原子性操作。i++分为读取 i 值，对 i 值加一，再赋值给 i++，执行期中任<br>何一步都是有可能被其他线程抢占的。<br>2、如何线程安全的实现一个计数器？<br>考察点：多线程<br>参考回答：<br>可以使用加锁，比如 synchronized 或者 lock。也可以使用 Concurrent 包下的原子类。<br>3、多线程同步的方法<br>考察点：多线程<br>参考回答：<br>可以使用 synchronized、lock、volatile 和 ThreadLocal 来实现同步。<br>4、介绍一下生产者消费者模式？<br>考察点：线程<br>参考回答：<br>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储<br>空间，生产者向空间里生产数据，而消费者取走数据。<br>优点：支持并发、解耦。<br>5、线程，进程，然后线程创建有很大开销，怎么优化？<br>NOWCODER.COM<br>考察点：多线程<br>参考回答：<br>可以使用线程池。<br>6、线程池运行流程，参数，策略<br>考察点：线程池<br>参考回答：<br>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线<br>程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列<br>满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝<br>策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。<br>7、讲一下 AQS 吧。<br>考察点：多线程<br>参考回答：<br>AQS 其实就是一个可以给我们实现锁的框架<br>内部实现的关键是：先进先出的队列、state 状态<br>定义了内部类 ConditionObject<br>拥有两种线程模式独占模式和共享模式。<br>在 LOCK 包中的相关锁(常用的有 ReentrantLock、 ReadWriteLock)都是基于 AQS 来构建，<br>一般我们叫 AQS 为同步器。<br>10、Java 中有几种线程池？<br>考察点：线程池<br>参考回答：<br>1、newFixedThreadPool 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一<br>个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>2、newCachedThreadPool 创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1<br>分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个<br>工作线程。<br>3、newSingleThreadExecutor 创建一个单线程化的 Executor，即只创建唯一的工作者线程<br>来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特<br>色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个<br>线程是活动的 。<br>4、newScheduleThreadPool 创建一个定长的线程池，而且支持定时的以及周期性的任务执<br>行，类似于 Timer。(这种线程池原理暂还没完全了解透彻)<br>11、线程池有什么好处？<br>考察点：线程池<br>参考回答：<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。<br>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。<br>参考回答：<br>所谓回调，就是客户程序 C 调用服务程序 S 中的某个方法 A，然后 S 又在某个时候反过来调<br>用 C 中的某个方法 B，对于 C 来说，这个 B 便叫做回调方法。<br>17、同步方法和同步代码块的区别是什么？<br>考察点：JAVA 代码块同步<br>参考回答：<br>区别：<br>同步方法默认用 this 或者当前类 class 对象作为锁；<br>NOWCODER.COM<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步<br>问题的部分代码而不是整个方法；<br>18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同<br>步？<br>考察点：JAVA 线程同步<br>参考回答：<br>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一<br>个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行<br>同步代码。<br>26、线程的 sleep()方法和 yield()方法有什么区别？<br>考察点：线程<br>参考回答：<br>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行<br>的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）<br>状态；<br>③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。<br>27、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进<br>入此对象的 synchronized 方法 B？<br>考察点：线程<br>参考回答：<br>NOWCODER.COM<br>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的<br>synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被<br>取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。<br>28、请说出与线程同步以及线程调度相关的方法。<br>考察点：线程同步<br>参考回答：* wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p><ul><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理<br>InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一<br>个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让<br>它们竞争，只有获得锁的线程才能进入就绪状态；<br>通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。<br>Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()<br>方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），<br>信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须<br>得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必<br>须向信号量归还许可（调用 Semaphore 对象的 release()方法）。<br>29、举例说明同步和异步<br>考察点：线程<br>参考回答：<br>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据<br>以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就<br>必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个<br>需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，<br>在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是<br>非阻塞式操作。<br>31、说说线程的基本状态以及状态之间的关系？<br>考察点：线程<br>参考回答：<br>其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表<br>示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait()方法进入等待池，也可能是执行<br>同步方法或同步代码块进入等锁池，或者是调用了 sleep()方法或 join()方法等待休眠或其他线<br>程结束，或是因为发生了 I&#x2F;O 中断。<br>1、Java 中的 LongAdder 和 AtomicLong 的区别<br>考点：JDK<br>参考回答：<br>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到<br>修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在<br>大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合<br>ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。<br>虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger<br>NOWCODER.COM<br>的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字<br>进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元<br>cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进<br>行了有效的分离，提高了并行度。<br>2、JDK 和 JRE 的区别是什么？<br>考察点：JDK<br>参考回答：<br>Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet<br>需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其<br>他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应用程序。 ④反射<br>1、反射的实现与作用<br>考察点：反射<br>参考回答；<br>JAVA 语言编译之后会生成一个.class 文件，反射就是通过字节码文件找到某一个类、类中<br>的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构<br>造方法，Field：类中的属性对象，Method：类中的方法对象。<br>作用：反射机制指的是程序在运行时能够获取自身的信息。在 JAVA 中，只要给定类的名字，<br>那么就可以通过反射机制来获取类的所有信息。 ⑤JVM</li></ul><p>5、JAVA 虚拟机的作用?<br>考察点：java 虚拟机<br>参考回答：<br>解释运行字节码程序 消除平台相关性。<br>NOWCODER.COM<br>jvm 将 java 字节码解释为具体平台的具体指令。一般的高级语言如要在不同的平台上运行，<br>至少需要编译成不同的目标代码。而引入 JVM 后，Java 语言在不同平台上运行时不需要重新编<br>译。Java 语言使用模式 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言编译程序只<br>需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java<br>虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<br>假设一个场景，要求 stop the world 时间非常短，你会怎么设计垃圾回收机制？<br>绝大多数新创建的对象分配在 Eden 区。<br>在 Eden 区发生一次 GC 后，存活的对象移到其中一个 Survivor 区。<br>在 Eden 区发生一次 GC 后，对象是存放到 Survivor 区，这个 Survivor 区已经存在其他存活<br>的对象。<br>一旦一个 Survivor 区已满，存活的对象移动到另外一个 Survivor 区。然后之前那个空间已<br>满 Survivor 区将置为空，没有任何数据。<br>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。<br>9、jvm 是如何实现线程？<br>考察点：JVM<br>参考回答：<br>NOWCODER.COM<br>线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开。<br>一个进程里可以启动多条线程，各个线程可共享该进程的资源(内存地址，文件 IO 等)，又可以<br>独立调度。线程是 CPU 调度的基本单位。<br>主流 OS 都提供线程实现。Java 语言提供对线程操作的同一 API，每个已经执行 start()，<br>且还未结束的 java.lang.Thread 类的实例，代表了一个线程。<br>Thread 类的关键方法，都声明为 Native。这意味着这个方法无法或没有使用平台无关的手<br>段来实现，也可能是为了执行效率。<br>实现线程的方式<br>A.使用内核线程实现内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核支持<br>的线程。<br>内核来完成线程切换<br>内核通过调度器 Scheduler 调度线程，并将线程的任务映射到各个 CPU 上<br>程序使用内核线程的高级接口，轻量级进程(Light Weight Process,LWP)<br>用户态和内核态切换消耗内核资源<br>使用用户线程实现<br>系统内核不能感知线程存在的实现<br>用户线程的建立、同步、销毁和调度完全在用户态中完成<br>所有线程操作需要用户程序自己处理，复杂度高<br>用户线程加轻量级进程混合实现<br>轻量级进程作为用户线程和内核线程之间的桥梁<br>10、jvm 最大内存限制多少<br>考察点：JVM<br>参考回答：<br>(1)堆内存分配<br>JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1&#x2F;64；JVM 最大分配的内存由-Xmx 指<br>定，默认是物理内存的 1&#x2F;4。默认空余堆内存小 于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；<br>空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。因此服务器一般设置-Xms、 -Xmx 相等以避免在每次 GC 后调整堆的大小。<br>(2)非堆内存分配<br>JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1&#x2F;64；由 XX:MaxPermSize<br>设置最大非堆内存的大小，默认是物理内存的 1&#x2F;4。<br>NOWCODER.COM<br>(3)VM 最大内存<br>首先 JVM 内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM 内存的最大值跟<br>操作系统有很大的关系。简单的说就 32 位处理器虽 然可控内存空间有 4GB,但是具体的操作系<br>统会给一个限制，这个限制一般是 2GB-3GB（一般来说 Windows 系统下为 1.5G-2G，Linux 系 统<br>下为 2G-3G），而 64bit 以上的处理器就不会有限制了。<br>(3)下面是当前比较流行的几个不同公司不同版本 JVM 最大堆内存:<br>11、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？<br>考察点：JVM<br>参考回答：<br>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚<br>拟机执行的字节码文件。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或<br>者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。<br>12、描述一下 JVM 加载 class 文件的原理机制?<br>考察点：JVM<br>参考回答：<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的<br>Java 运行时系统组件。它负责在运行时查找和装入类文件的类。<br>Java 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，<br>而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的<br>加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要<br>的类。<br>NOWCODER.COM<br>类装载方式，有两种<br>（1）隐式装载， 程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载<br>对应的类到 jvm 中，<br>（2）显式装载， 通过 class.forname()等方法，显式加载需要的类 , 隐式加载与显式加载的<br>区别：两者本质是一样的。<br>Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行<br>的基础类(像是基类)完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了<br>节省内存开销。 ⑥GC<br>1、java 中内存泄露是啥，什么时候出现内存泄露？<br>考察点：内存泄漏<br>参考回答：<br>Java 中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就<br>是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。<br>2、minor gc 如果运行的很频繁，可能是什么原因引起的，minor gc 如果运行的<br>很慢，可能是什么原因引起的?<br>考察点：GC<br>参考回答：<br>可能是堆内存太小。<br>3、阐述 GC 算法<br>考察点：JVM<br>参考回答：<br>①GC（GarbageCollection 垃圾收集），GC 的对象是堆空间和永久区<br>②GC 算法包含：引用计数法，标记清除，标记压缩，复制算法。<br>③引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用<br>计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A<br>就不可能再被使用。<br>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：<br>标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开<br>始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有<br>未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对<br>象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正<br>NOWCODER.COM<br>在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对<br>象，交换两个内存的角色，完成垃圾回收。<br>4、GC 是什么? 为什么要有 GC?<br>考察点：回收<br>参考回答：<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，<br>忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监<br>测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显<br>示操作方法。<br>5、垃圾回收的优点和原理。并考虑 2 种回收机制<br>考察点：垃圾回收<br>参考回答：<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的<br>问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回<br>收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以<br>有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的<br>线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，<br>程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃<br>圾回收和标记垃圾回收，增量垃圾回收。<br>6、java 中会存在内存泄漏吗，请简单描述。<br>考察点：内存<br>参考回答：<br>Java 中的确存在 Java 的内存泄漏, 并且事态可以变得相当严重<br>Java garbage collector 自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的<br>其他程序上下文的内存泄漏. 但是 Java 应用程序依旧会有相当的内存泄漏. 查找原因会十分困<br>难. 有两类主要的 Java 内存泄漏:* 不再需要的对象引用</p><ul><li>未释放的系统资源<br>2.2 非必要的对象引用<br>Java 代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java 对<br>象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如<br>下问题:</li><li>在向数组添加对象以后遗漏了对于他们的处理</li><li>直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并<br>且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.</li><li>在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面<br>保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当<br>中.<br>NOWCODER.COM</li><li>允许一个长久执行的线程所引用的对象. 设置引用为 NULL 也无济于事, 在线程退出和空闲之<br>前, 对象不会被收集释放<br>2.3 未释放的系统资源<br>Java 方法可以定位 Java 实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java 常常通过<br>JNI(Java Native Interface)调用 C&#x2F;C++子程序定位这些资源. 7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办<br>法主动通知虚拟机进行垃圾回收？（垃圾回收）<br>考察点：垃圾回收<br>参考回答：<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆<br>(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当<br>GC 确定一些对象为”不可达”时，GC 就有责<br>任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。 ⑦ IO 和 NIO，AIO<br>1、怎么打印日志？<br>考察点：异常<br>参考回答：<br>cat &#x2F;var&#x2F;log&#x2F;*.log<br>如果日志在更新，如何实时查看 tail -f &#x2F;var&#x2F;log&#x2F;messages<br>还可以使用 watch -d -n 1 cat &#x2F;var&#x2F;log&#x2F;messages<br>-d 表示高亮不同的地方，-n 表示多少秒刷新一次。<br>2、运行时异常与一般异常有何异同？<br>考察点：异常<br>参考回答：<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异<br>常，但是并不要求必须声明抛出未被捕获的运行时异常。<br>3、error 和 exception 有什么区别?<br>考察点：异常<br>NOWCODER.COM<br>参考回答：<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。<br>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。<br>4、给我一个你最常见到的 runtime exception<br>考察点：异常<br>参考回答：<br>ArithmeticException,<br>ArrayStoreException,<br>BufferOverflowException,<br>BufferUnderflowException,<br>CannotRedoException,<br>CannotUndoException,<br>ClassCastException,<br>CMMException,<br>ConcurrentModificationException,<br>DOMException,<br>EmptyStackException,<br>IllegalArgumentException,<br>IllegalMonitorStateException,<br>IllegalPathStateException,<br>IllegalStateException,<br>ImagingOpException,<br>IndexOutOfBoundsException,<br>MissingResourceException,<br>NegativeArraySizeException,<br>NoSuchElementException,<br>NullPointerException,<br>ProfileDataException,<br>NOWCODER.COM<br>ProviderException,<br>RasterFormatException, SecurityException, SystemException,<br>UndeclaredThrowableException, UnmodifiableSetException,<br>UnsupportedOperationException<br>5、Java 中的异常处理机制的简单原理和应用。<br>考察点：异常<br>参考回答：<br>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。<br>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发<br>IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就<br>是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。<br>6、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，<br>请说出他们分别是哪些类？<br>考察点：stream<br>参考回答：<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于<br>InputStreamReader OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高<br>性能和使用方便。</li></ul><p>8、运行时异常与受检异常有什么区别？<br>考察点：异常<br>参考回答：<br>NOWCODER.COM<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序<br>运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求<br>方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异<br>常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用<br>给出了以下指导原则：* 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流<br>而使用异常）</p><ul><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在 catch 中忽略掉捕获到的异常<br>二、JavaEE 部分<br>3、Spring 里面注解用过没有？autowired 和 resource 区别？<br>考察点：Spring<br>参考回答：<br>1、共同点<br>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter<br>方法。<br>2、不同点<br>（1）@Autowired<br>@Autowired 为 Spring 提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired;只按照 byType 注入。<br>NOWCODER.COM<br>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存<br>在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）<br>来装配，可以结合@Qualifier 注解一起使用。<br>（2）@Resource<br>@Resource 默认按照 ByName 自动注入，由 J2EE 提供，需要导入包<br>javax.annotation.Resource。@Resource 有两个重要的属性：name 和 type，而 Spring 将<br>@Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以，如<br>果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入<br>策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。<br>4、@Controller 和@RestController 的区别？<br>考察点：spring<br>参考回答：<br>@RestController 注解相当于@ResponseBody ＋ @Controller 合在一起的作用<br>2、Struts 拦截器和 Spring AOP 区别？<br>考察点：框架<br>参考回答：<br>拦截器是 AOP 的一种实现，struts2 拦截器采用 xwork2 的 interceptor！而 spring 的 AOP<br>基于 IoC 基础,其底层采用动态代理与 CGLIB 代理两种方式结合的实现方式。<br>4、选择使用 Spring 框架的原因（Spring 框架为企业级开发带来的好处有哪些）？<br>考察点：框架<br>参考回答：<br>NOWCODER.COM</li><li>非侵入式：支持基于 POJO 的编程模式，不强制性的要求实现 Spring 框架中的接口或继承<br>Spring 框架中的类。</li><li>IoC 容器：IoC 容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如<br>果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建<br>和完整的回归测试。有了 IoC 容器，程序员再也不需要自己编写工厂、单例，这一点特别符合<br>Spring 的精神”不要重复的发明轮子”。</li><li>AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将<br>横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，<br>有了 AOP 程序员可以省去很多自己写代理类的工作。</li><li>MVC：Spring 的 MVC 框架为 Web 表示层提供了更好的解决方案。</li><li>事务管理：Spring 以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，<br>在不需要任何一行代码的情况下就能够完成事务管理。</li><li>其他：选择 Spring 框架的原因还远不止于此，Spring 为 Java 企业级开发提供了一站式选择，<br>你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到 Spring 存在的情<br>况下，在你的项目中使用 Spring 提供的各种优秀的功能。 ④Spring，JPA 整合<br>1、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？<br>考察点：框架<br>参考回答：<br>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中<br>的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统<br>中专注于实现数据持久化的相对独立的层面。<br>持久层设计的目标包括：</li><li>数据存储逻辑的分离，提供抽象化的数据访问接口。</li><li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。</li><li>资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。</li><li>数据抽象，提供更面向对象的数据操作。<br>持久层框架有：</li><li>Hibernate</li><li>MyBatis</li><li>TopLink</li><li>Guzz</li><li>jOOQ</li><li>Spring Data</li><li>ActiveJDBC<br>NOWCODER.COM<br>2、Hibernate<br>①ORM 与持久化映射<br>1、阐述实体对象的三种状态以及转换关系。<br>考察点：JAVA 实体<br>参考回答：<br>最新的 Hibernate 文档中为 Hibernate 对象定义了四种状态（原来是三种状态，面试的时候<br>基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or<br>persistent）、游状态（detached）和移除态（removed，以前 Hibernate 文档中定义的三种状<br>态中没有移除态），如下图所示，就以前的 Hibernate 文档中移除态被视为是瞬时态。<br>瞬时态：当 new 一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数<br>据的内存区域，如果没有变量引用这个对象，则会被 JVM 的垃圾回收机制回收。这个对象所保存<br>的数据与数据库没有任何关系，除非通过 Session 的 save()、saveOrUpdate()、persist()、merge()<br>方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对<br>象。<br>持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态<br>对象进行 delete 操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存<br>在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上<br>同步到数据库，直到数据库事务提交。<br>游离态：当 Session 进行了 close()、clear()、evict()或 flush()后，实体对象从持久态变成<br>游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除<br>掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象<br>是十分相似的，只是它还含有持久化标识。 ②延迟加载、性能优化<br>1、Hibernate 中 SessionFactory 是线程安全的吗？Session 是线程安全的吗（两<br>个线程能够共享同一个 Session 吗）？<br>考察点：session<br>参考回答：<br>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线<br>程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将<br>SessionFactory 通过单例模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象<br>（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。Session 是由<br>SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接<br>口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的<br>session，可以使用 ThreadLocal 将 session 和当前线程绑定在一起，这样可以让同一个线程获<br>得的总是同一个 session。Hibernate 3 中 SessionFactory 的 getCurrentSession()方法就可以<br>做到。<br>NOWCODER.COM<br>2、Hibernate 中 Session 的 load 和 get 方法的区别是什么？<br>考察点：请求方式<br>参考回答：<br>主要有以下三项区别：<br>① 如果没有找到符合条件的记录，get 方法返回 null，load 方法抛出异常。<br>② get 方法直接返回实体类对象，load 方法返回实体类对象的代理。<br>③ 在 Hibernate 3 之前，get 方法只在一级缓存中进行数据查找，如果没有找到对应的数据则<br>越过二级缓存，直接发出 SQL 语句完成数据读取；load 方法则可以从二级缓存中获取数据；从<br>Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。<br>对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加<br>载，如果没有数据就抛出异常，而通过 get()方法获取的数据可以不存在。<br>3、如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session<br>关闭的矛盾是如何处理的？<br>考察点：hibernate 框架<br>参考回答：<br>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate<br>使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load()方法加载数据或者一对多关联<br>映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给<br>用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据<br>库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。<br>延迟加载与 session 关闭的矛盾一般可以这样处理：<br>① 关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通<br>过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or<br>session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询<br>的开销都会变得很大。<br>② 在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized()<br>判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize()方法加载对象。<br>③ 使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提<br>供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。<br>4、简述 Hibernate 常见优化策略。<br>考察点：Hibernate<br>参考回答：<br>①制定合理的缓存策略（二级缓存、查询缓存）。<br>② 采用合理的 Session 管理机制。<br>③ 尽量使用延迟加载特性。<br>④ 设定合理的批处理参数。<br>⑤ 如果可以，选用 UUID 作为主键生成器。<br>⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。<br>⑦ 在开发过程中, 开启 hibernate.show_sql 选项查看生成的 SQL，从而了解底层的状况；开发<br>完成后关闭此选项。<br>NOWCODER.COM<br>⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观<br>的提升，但这些需要专业的 DBA（数据库管理员）提供支持。<br>5、锁机制有什么用？简述 Hibernate 的悲观锁和乐观锁机制。<br>考察点：锁<br>参考回答：<br>有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此<br>过程中数据被锁住不会被外界修改，这就是所谓的锁机制。<br>Hibernate 支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极<br>有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理<br>的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，<br>乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过<br>更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐<br>观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加 1，<br>然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的<br>当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate 中通过 Session 的 get()和<br>load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加<br>整型的版本字段再通过 XML 或@Version 注解进行配置。<br>使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了<br>空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间<br>换时间的策略。 ③HQL 查询、条件查询、SQL 查询<br>1、Hibernate 如何实现分页查询？<br>考察点：框架<br>参考回答：<br>通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()<br>方法）或查询条件（调用 Session 的 createCriteria()方法）、设置查询起始行数（调用 Query<br>或 Criteria 接口的 setFirstResult()方法）和最大查询行数（调用 Query 或 Criteria 接口的<br>setMaxResults()方法），并调用 Query 或 Criteria 接口的 list()方法，Hibernate 会自动生成<br>分页查询的 SQL 语句。 ④二级缓存与查询缓存<br>1、谈一谈 Hibernate 的一级缓存、二级缓存和查询缓存。<br>考察点：缓存<br>参考回答：<br>NOWCODER.COM<br>Hibernate 的 Session 提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实<br>体、修改持久化实体时，Session 并不会立即把这种改变提交到数据库，而是缓存在当前的<br>Session 中，除非显示调用了 Session 的 flush()方法或通过 close()方法关闭 Session。通过一<br>级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。<br>SessionFactory 级别的二级缓存是全局性的，所有的 Session 可以共享这个二级缓存。不过二<br>级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供<br>的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory 就会缓<br>存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。<br>一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓<br>存，可以使用查询缓存。查询缓存是将 HQL 或 SQL 语句以及它们的查询结果作为键值对进行缓存，<br>对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。<br>3、Struts<br>①MVC 模式与 Struts 体系<br>1、说说 STRUTS 的应用<br>考察点：STRUTS 架构<br>参考回答：<br>Struts 是采用 Java Servlet&#x2F;JavaServer Pages 技术，开发 Web 应用程序的开放源码的<br>framework。采用 Struts 能开发出基于 MVC(Model-View-Controller)设计模式的应用构架。<br>Struts 有如下的主要功能：<br>包含一个 controller servlet，能将用户的请求发送到相应的 Action 对象。二.JSP 自由<br>tag 库，并且在 controller servlet 中提供关联支持，帮助开发员创建交互式表单应用。<br>提供了一系列实用对象：XML 处理、通过 Java reflection APIs 自动处理 JavaBeans 属性、<br>国际化的提示和消息。<br>4、Mybatis<br>1、解释一下 MyBatis 中命名空间（namespace）的作用。<br>考察点：Mybatis<br>参考回答：<br>在大型项目中，可能存在大量的 SQL 语句，这时候为每个 SQL 语句起一个唯一的标识（ID）<br>就变得并不容易了。为了解决这个问题，在 MyBatis 中，可以为每个映射文件起一个唯一的命名<br>空间，这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只<br>要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不<br>会再产生冲突了。<br>NOWCODER.COM<br>2、MyBatis 中的动态 SQL 是什么意思？<br>考察点：SQL<br>参考回答：<br>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，<br>需要根据用户指定的条件动态生成 SQL 语句。如果不使用持久层框架我们可能需要自己拼装 SQL<br>语句，还好 MyBatis 提供了动态 SQL 的功能来解决这个问题。MyBatis 中用于实现动态 SQL 的元<br>素主要有：</li><li>if</li><li>choose &#x2F; when &#x2F; otherwise</li><li>trim</li><li>where</li><li>set</li><li>foreach<br>5、MVC<br>1、Spring MVC 注解的优点<br>考察点：spring mvc<br>参考回答：<br>1、XML 配置起来有时候冗长，此时注解可能是更好的选择，如 jpa 的实体映射；注解在处<br>理一些不变的元数据时有时候比 XML 方便的多，比如 springmvc 的数据绑定，如果用 xml 写的代<br>码会多的多；<br>2、注解最大的好处就是简化了 XML 配置；其实大部分注解一定确定后很少会改变，所以在<br>一些中小项目中使用注解反而提供了开发效率，所以没必要一头走到黑；<br>3、注解相对于 XML 的另一个好处是类型安全的，XML 只能在运行期才能发现问题。<br>2、springmvc 和 spring-boot 区别？<br>考察点：spring<br>参考回答：<br>总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA 等等。但<br>他们的基础都是 Spring 的 IOC 和 AOP，IOC 提供了依赖注入的容器，而 AOP 解决了面向切面的<br>编程，然后在此两者的基础上实现了其他衍生产品的高级功能；因为 Spring 的配置非常复杂，<br>各种 xml，properties 处理起来比较繁琐。于是为了简化开发者的使用，Spring 社区创造性地<br>推出了 Spring Boot，它遵循约定优于配置，极大降低了 Spring 使用门槛，<br>但又不失 Spring 原本灵活强大的功能。<br>3、SpringMVC 的运行机制，运行机制的每一部分的相关知识？<br>考察点：spring<br>NOWCODER.COM<br>参考回答：<br>1、用户发送请求时会先从 DispathcherServler 的 doService 方法开始，在该方法中会将<br>ApplicationContext、localeResolver、themeResolver 等对象添加到 request 中，紧接着就是<br>调用 doDispatch 方法。<br>2、进入该方法后首先会检查该请求是否是文件上传的请求(校验的规则是是否是 post 并且<br>contenttType 是否为 multipart&#x2F;为前缀)即调用的是 checkMultipart 方法；如果是的将 request<br>包装成 MultipartHttpServletRequest。<br>3、然后调用 getHandler 方法来匹配每个 HandlerMapping 对象，如果匹配成功会返回这个<br>Handle 的处理链 HandlerExecutionChain 对象，在获取该对象的内部其实也获取我们自定定义<br>的拦截器，并执行了其中的方法。<br>4、执行拦截器的 preHandle 方法，如果返回 false 执行 afterCompletion 方法并理解返回<br>5、通过上述获取到了 HandlerExecutionChain 对象，通过该对象的 getHandler()方法获得<br>一个 object 通过 HandlerAdapter 进行封装得到 HandlerAdapter 对象。<br>6、该对象调用 handle 方法来执行 Controller 中的方法，该对象如果返回一个 ModelAndView 给 DispatcherServlet。<br>7、DispatcherServlet借助ViewResolver完成逻辑试图名到真实视图对象的解析，得到View 后 DispatcherServlet 使用这个 View 对 ModelAndView 中的模型数据进行视图渲染。</li></ul><p>6、各框架对比与项目优化<br>1、Mybatis 和 Hibernate 区别？<br>NOWCODER.COM<br>考察点：Spring 框架<br>参考回答：1. 简介<br>Hibernate：Hibernate 是当前最流行的 ORM 框架之一，对 JDBC 提供了较为完整的封装。<br>Hibernate 的 O&#x2F;R Mapping 实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。<br>Mybatis：Mybatis 同样也是非常流行的 ORM 框架，主要着力点在于 POJO 与 SQL 之间的映<br>射关系。然后通过映射配置文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO 。<br>相对 Hibernate“O&#x2F;R”而言，Mybatis 是一种“Sql Mapping”的 ORM 实现。<br>2、缓存机制对比<br>相同点<br>Hibernate 和 Mybatis 的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己<br>的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。<br>不同点<br>Hibernate 的二级缓存配置在 SessionFactory 生成的配置文件中进行详细配置，然后再在<br>具体的表-对象映射中配置是那种缓存。<br>MyBatis 的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的<br>表可以自定义不同的缓存机制。并且 Mybatis 可以在命名空间中共享相同的缓存配置和实例，通<br>过 Cache-ref 来实现。<br>两者比较<br>因为 Hibernate 对查询对象有着良好的管理机制，用户无需关心 SQL。所以在使用二级缓存<br>时如果出现脏数据，系统会报出错误并提示。而 MyBatis 在这一方面，使用二级缓存时需要特别<br>小心。如果不能完全确定数据更新操作的波及范围，避免 Cache 的盲目使用。否则，脏数据的出<br>现会给系统的正常运行带来很大的隐患。<br>Mybatis：小巧、方便、高效、简单、直接、半自动化<br>Hibernate：强大、方便、高效、复杂、间接、全自动化<br>2、介绍一下你了解的 Java 领域的 Web Service 框架。<br>考察点：框架<br>参考回答：<br>Java 领域的 Web Service 框架很多，包括 Axis2（Axis 的升级版本）、Jersey（RESTful<br>的 Web Service 框架）、CXF（XFire 的延续版本）、Hessian、Turmeric、JBoss SOA 等，其中<br>绝大多数都是开源框架。<br>NOWCODER.COM<br>7、JPA<br>①EJB<br>1、EJB 是基于哪些技术实现的？并说出 SessionBean 和 EntityBean 的区别，<br>StatefulBean 和 StatelessBean 的区别。<br>考察点：JAVA EJB<br>参考回答：<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技<br>术实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用<br>其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象<br>视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种<br>的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的<br>实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是<br>说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会<br>消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者<br>的状态。<br>2、EJB 与 JAVA BEAN 的区别？<br>考察点：EJB<br>参考回答：<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java<br>类都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所以<br>Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于<br>实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，它是不<br>能被跨进程访问的。EnterpriseJava Bean 相当于 DCOM，即分布式组件。它是基于 Java 的远程<br>方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。但 EJB 必须被布署<br>在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正的 EJB 组件，而是通过<br>其容器访问。EJB 容器是 EJB 组件的代理， EJB 组件由容器所创建和管理。客户通过容器来访问<br>真正的 EJB 组件。<br>3、EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事<br>务的？<br>考察点：JAVA EJB<br>NOWCODER.COM<br>参考回答：<br>SessionBean： Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求<br>要建立一个 Bean 的实例时，EJB 容器不一定<br>要创建一个新的 Bean 的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户<br>机第一次调用一个 Stateful Session<br>Bean 时，容器必须立即在服务器中创建一个新的 Bean 实例，并关联到客户机上，以后此客户机<br>调用 Stateful Session Bean 的方法<br>时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不<br>是按照应用程序或者服务进程来说的。即使 EJB 容器崩溃了，Entity beans 也是存活的。Entity<br>Beans 生命周期能够被容器或者<br>Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、<br>Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。<br>4、EJB 的角色和三个对象是什么？<br>考察点：EJB<br>参考回答：<br>一个完整的基于 EJB 的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提<br>供，每个角色所作的工作必须遵循 Sun 公司<br>提供的 EJB 规范，以保证彼此之间的兼容性。这六个角色分别是 EJB 组件开发者（Enterprise Bean<br>Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供<br>者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System<br>Administrator）<br>三个对象是 Remote（Local）接口、Home（LocalHome）接口，Bean 类<br>5、说说 EJB 规范规定 EJB 中禁止的操作有哪些？<br>考察点：EJB<br>参考回答：<br>1.不能操作线程和线程 API(线程 API 指非线程对象的方法如 notify,wait 等)，<br>2.不能操作 awt，<br>3.不能实现服务器功能，<br>4.不能对静态属生存取，<br>5.不能使用 IO 操作直接存取文件系统，<br>6.不能加载本地库.，<br>7.不能将 this 作为变量和返回，<br>NOWCODER.COM<br>8.不能循环调用。<br>6、EJB 的激活机制是什么？<br>考察点：EJB<br>参考回答：<br>以 Stateful Session Bean 为例：其 Cache 大小决定了内存中可以同时存在的 Bean 实例的<br>数量，根据 MRU 或 NRU 算法，实例在激活和去<br>激活状态之间迁移，激活机制是当客户端调用某个 EJB 实例业务方法时，如果对应 EJB Object<br>发现自己没有绑定对应的 Bean 实例则从<br>其去激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。<br>7、EJB 的几种类型分别是什么<br>考察点：EJB<br>参考回答：<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean，会话<br>Bean 又可分为有状态（Stateful）和无状态（Stateless）两种，<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种。<br>8、EJB 需直接实现它的业务接口或 Home 接口吗，请简述理由。<br>考察点：EJB<br>参考回答：<br>在 EJB 中则至少要包括 10 个 class:<br>Bean 类，特定 App Server 的 Bean 实现类 Bean 的 remote 接口，特定 App Server 的 remote 接<br>口实现类，特定 App Server 的 remote 接口的实现类的 stub 类和 skeleton 类。<br>Bean 的 home 接口，特定 App Server 的 home 接口实现类，特定 App Server 的 home 接口的实现<br>类的 stub 类和 skeleton 类。<br>和 RMI 不同的是，EJB 中这 10 个 class 真正需要用户写的只有 3 个，Bean 类，remote 接口，home<br>接口，其它的 7 个究竟怎么生成，被打包在哪里，是否需要更多的类文件，否根据不同的 App<br>Server 表现出较大的差异。<br>Weblogic：<br>home 接口和 remote 接口的 weblogic 的实现类的 stub 类和 skeleton 类是在 EJB 被部署到<br>weblogic 的时候，由 weblogic 动态生成 stub 类和 skeleton 类的字节码，所以看不到这 4 个类<br>文件。<br>对于一次客户端远程调用 EJB，要经过两个远程对象的多次 RMI 循环。首先是通过 JNDI 查找 Home<br>接口，获得 Home 接口的实现类，这个过程其实相当复杂，首先是找到 Home 接口的 Weblogic 实<br>现类，然后创建一个 Home 接口的 Weblogic 实现类的 stub 类的对象实例，将它序列化传送给客<br>户端（注意 stub 类的实例是在第 1 次 RMI 循环中，由服务器动态发送给客户端的，因此不需要<br>客户端保存 Home 接口的 Weblogic 实现类的 stub 类），最后客户端获得该 stub 类的对象实例<br>（普通的 RMI 需要在客户端保存 stub 类，而 EJB 不需要，因为服务器会把 stub 类的对象实例发<br>送给客户端）。<br>客户端拿到服务器给它的 Home 接口的 Weblogic 实现类的 stub 类对象实例以后，调用 stub 类的<br>NOWCODER.COM<br>create 方法， (在代码上就是 home.create()，但是后台要做很多事情),于是经过第 2 次 RMI<br>循环，在服务器端，Home 接口的 Weblogic 实现类的 skeleton 类收到 stub 类的调用信息后，由<br>它再去调用 Home 接口的 Weblogic 实现类的 create 方法。<br>在服务端， Home 接口的 Weblogic 实现类的 create 方法再去调用 Bean 类的 Weblogic 实现类的<br>ejbCreate 方法，在服务端创建或者分配一个 EJB 实例，然后将这个 EJB 实例的远程接口的<br>Weblogic 实现类的 stub 类对象实例序列化发送给客户端。 三、Java web 编程<br>1、web 编程基础<br>①Tomcat 服务器<br>1、启动项目时如何实现不在链接里输入项目名就能启动?<br>考察点：tomcat<br>参考回答：<br>可在 taomcat 配置虚拟目录。<br>2、1 分钟之内只能处理 1000 个请求，你怎么实现，手撕代码?<br>考察点：tomcat<br>参考回答：<br>限流的几种方法：计数器，滑动窗口、漏桶法、令牌桶<br>3、什么时候用 assert<br>考察点：JAVA 调试<br>参考回答：<br>assertion (断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。<br>在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的<br>状态下，系统将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正确性。<br>assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常<br>是关闭的。<br>4、JAVA 应用服务器有那些？<br>考察点：服务器<br>参考回答：<br>NOWCODER.COM<br>BEA WebLogic Server，<br>IBM WebSphere Application Server，<br>Oracle9i Application Server<br>jBoss，<br>Tomcat<br>5、说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的<br>helloWorld.jsp 放入何目录下,然后在浏览器上就可打入主机？<br>考察点：目录结构<br>参考回答：<br>端口号&#x2F;&#x2F;helloword.jsp 就可以看到运行结果了? 又比如这其中用到了一个自己写的<br>javaBean 该如何办?<br>NOWCODER.COM<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果是<br>Web 应用，应用目录需要满足 Web 应用<br>目录要求，jsp 文件可以直接放在应用目录中，Javabean 需要放在应用目录的 WEB-INF 目录的<br>classes 目录中，设置服务器的缺省应用<br>将可以实现在浏览器上无需输入应用名。<br>6、jsp 有哪些动作?作用分别是什么?<br>考察点：JSP<br>参考回答：<br>JSP 共有以下 6 种基本动作 jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>jsp:setProperty：设置 JavaBean 的属性。 jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。<br>8、说一下表达式语言（EL）的隐式对象及其作用<br>考察点：EL<br>NOWCODER.COM<br>参考回答：<br>EL 的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、<br>paramValues、header（访问请求头）、headerValues、cookie（访问 cookie）、applicationScope<br>（访问 application 作用域）、sessionScope（访问 session 作用域）、requestScope（访问 request<br>作用域）、pageScope（访问 page 作用域）。<br>9、JSP 中的静态包含和动态包含有什么区别？<br>考察点：JSP<br>参考回答：<br>静态包含是通过 JSP 的 include指令包含页面，动态包含是通过 JSP 标准动作<a href="jsp:forward">jsp:forward</a><br>包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的<br>“contentType”属性应保持一致，因为两个页面会合二为一，只产生一个 class 文件，因此被包<br>含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含<br>的页面传递参数，包含页面和被包含页面是独立的，会编译出两个 class 文件，如果被包含的页<br>面不存在，不会产生编译错误，也不影响页面其他部分的执行。<br>例如：&lt;%– 静态包含 –%&gt;<br>&lt;%@ include file&#x3D;”…” %&gt;<br>&lt;%– 动态包含 –%&gt;<br>&lt;jsp:include page&#x3D;”…”&gt;<br>&lt;jsp:param name&#x3D;”…” value&#x3D;”…” &#x2F;&gt;<br>&lt;&#x2F;jsp:include&gt;<br>③Listener 和 Filter<br>1、过滤器有哪些作用和用法？<br>考察点：过滤器<br>参考回答：<br>Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在 Servlet<br>2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web 组件，它可以截取<br>客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当 Web 容器接受到一个对资源<br>的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进<br>行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发<br>送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器<br>中你可以对响应的内容进行转换，然后再将响应发送到客户端。<br>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、<br>对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求<br>或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT 等。<br>和过滤器相关的接口主要有：Filter、FilterConfig 和 FilterChain。<br>3、说说 web.xml 文件中可以配置哪些内容？<br>考察点：xml 文件<br>参考回答：<br>web.xml 用于配置 Web 应用的相关信息，如：监听器（listener）、过滤器（filter）、Servlet、<br>相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：<br>①配置 Spring 上下文加载监听器加载 Spring 配置文件并创建 IoC 容器：<br>&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; &lt;listener&gt; &lt;listener-class&gt;<br>org.springframework.web.context.ContextLoaderListener &lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt;<br>②配置 Spring 的 OpenSessionInView 过滤器来解决延迟加载和 Hibernate 会话关闭的矛盾： &lt;filter&gt; &lt;filter-name&gt;openSessionInView&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;<br>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter &lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;openSessionInView&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;<br>NOWCODER.COM<br>③配置会话超时时间为 10 分钟： &lt;session-config&gt; &lt;session-timeout&gt;10&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt;<br>④配置 404 和 Exception 的错误页面： &lt;error-page&gt; &lt;error-code&gt;404&lt;&#x2F;error-code&gt; &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;&#x2F;exception-type&gt; &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt;<br>⑤配置安全认证方式： &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;ProtectedArea&lt;&#x2F;web-resource-name&gt; &lt;url-pattern&gt;&#x2F;admin&#x2F;<em>&lt;&#x2F;url-pattern&gt; &lt;http-method&gt;GET&lt;&#x2F;http-method&gt; &lt;http-method&gt;POST&lt;&#x2F;http-method&gt; &lt;&#x2F;web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;&#x2F;role-name&gt; &lt;&#x2F;auth-constraint&gt; &lt;&#x2F;security-constraint&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;&#x2F;auth-method&gt; &lt;&#x2F;login-config&gt; &lt;security-role&gt; &lt;role-name&gt;admin&lt;&#x2F;role-name&gt; &lt;&#x2F;security-role&gt;<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>1、forward 与 redirect 区别，说一下你知道的状态码，redirect 的状态码是多<br>少？<br>考察点：Servlet<br>参考回答：<br>1.从地址栏显示来说<br>NOWCODER.COM<br>forward 是服务器请求资源,服务器直接访问目标地址的 URL,把那个 URL 的响应内容读取过<br>来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地<br>址栏还是原来的地址.<br>redirect 是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址<br>栏显示的是新的 URL.<br>2.从数据共享来说<br>forward:转发页面和转发到的页面可以共享 request 里面的数据.<br>redirect:不能共享数据.<br>3.从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.<br>4.从效率来说<br>forward:高.<br>redirect:低.<br>redirect 的状态码是 302<br>2、servlet 生命周期，是否单例，为什么是单例。<br>考察点：servlet<br>参考回答：<br>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：<br>Servlet 通过调用 init () 方法进行初始化。<br>Servlet 调用 service() 方法来处理客户端的请求。<br>Servlet 通过调用 destroy() 方法终止（结束）。<br>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。<br>Servlet 单实例，减少了产生 servlet 的开销；<br>3、说出 Servlet 的生命周期，并说出 Servlet 和 CGI 的区别。<br>考察点：servlet<br>参考回答：<br>NOWCODER.COM<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，<br>service 方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实<br>例销毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个实<br>例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，服务完<br>成后就销毁，所以效率上低于 servlet。<br>4、Servlet 执行时一般实现哪几个方法？<br>考察点：servlet<br>参考回答：<br>public void init(ServletConfig config)<br>public ServletConfig getServletConfig()<br>public String getServletInfo()<br>public void service(ServletRequest request,ServletResponse response)<br>public void destroy()<br>init ()方法在 servlet 的生命周期中仅执行一次，在服务器装载 servlet 时执行。缺省的 init()<br>方法通常是符合要求的，不过也可以根据需要进行 override，比如管理服务器端资源，一次性<br>装入 GIF 图像，初始化数据库连接等，缺省的 inti()方法设置了 servlet 的初始化参数，并用<br>它的 ServeltConfig 对象参数来启动配置，所以覆盖 init()方法时，应调用 super.init()以确<br>保仍然执行这些任务。service ()方法是 servlet 的核心，在调用 service()方法之前，应确保<br>已完成 init()方法。对于 HttpServlet，每当客户请求一个 HttpServlet 对象，该对象的 service()<br>方法就要被调用，HttpServlet 缺省的 service()方法的服务功能就是调用与 HTTP 请求的方法<br>相应的 do 功能，doPost()和 doGet()，所以对于 HttpServlet，一般都是重写 doPost()和 doGet()<br>方法。destroy()方法在 servlet 的生命周期中也仅执行一次，即在服务器停止卸载 servlet 时<br>执行，把 servlet 作为服务器进程的一部分关闭。缺省的 destroy()方法通常是符合要求的，但<br>也可以 override，比如在卸载 servlet 时将统计数字保存在文件中，或是关闭数据库连接<br>getServletConfig()方法返回一个 servletConfig 对象，该对象用来返回初始化参<br>servletContext。servletContext 接口提供有关 servlet 的环境信息。getServletInfo()方法<br>提供有关 servlet 的信息，如作者，版本，版权。<br>5、阐述一下阐述 Servlet 和 CGI 的区别?<br>考察点：servlet<br>参考回答：<br>Servlet与 CGI 的区别在于 Servlet 处于服务器进程中，它通过多线程方式运行其 service()<br>方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的<br>进程，服务完成后就销毁，所以效率上低于 Servlet。<br>6、说说 Servlet 接口中有哪些方法？<br>考察点：Servlet 接口<br>参考回答：<br>NOWCODER.COM<br>Servlet 接口定义了 5 个方法，其中前三个方法与 Servlet 生命周期相关：</em> void init(ServletConfig config) throws ServletException</p><ul><li>void service(ServletRequest req, ServletResponse resp) throws ServletException,<br>java.io.IOException</li><li>void destory()</li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()<br>Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init()方法进行<br>Servlet 的初始化；请求到达时调用 Servlet 的 service()方法，service()方法会根据需要调用<br>与请求对应的 doGet 或 doPost 等方法；当服务器关闭或项目被卸载时服务<br>器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy()方法。<br>7、Servlet 3 中的异步处理指的是什么？<br>考察点：servlet<br>参考回答：<br>在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然<br>都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那<br>么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将<br>会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝<br>服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行<br>时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交<br>给 Executor 并立即返回即可。</li></ul><p>8、如何在基于 Java 的 Web 项目中实现文件上传和下载？<br>考察点：文件传输<br>参考回答：<br>在 Sevlet 3 以前，Servlet API 中没有支持上传功能的 API，因此要实现上传功能需要引<br>入第三方工具从 POST 请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们<br>推荐使用 Apache 的 commons-fileupload。<br>从 Servlet 3 开始，文件上传变得简单许多。</p><p>9、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()<br>方法？<br>考察点：servlet<br>参考回答：<br>HTML 的&lt;form&gt;元素有一个 method 属性，用来指定提交表单的方式，其值可以是 get 或 post。<br>我们自定义的 Servlet 一般情况下会重写 doGet()或 doPost()两个方法之一或全部，如果是 GET<br>请求就调用 doGet()方法，如果是 POST 请求就调用 doPost()方法，那为什么为什么这样呢？我<br>们自定义的 Servlet 通常继承自 HttpServlet，HttpServlet 继承自 GenericServlet 并重写了其<br>中的 service()方法，这个方法是 Servlet 接口中定义的。HttpServlet 重写的 service()方法<br>会先获取用户请求的方法，然后根据请求方法调用 doGet()、doPost()、doPut()、doDelete()<br>等方法，如果在自定义 Servlet 中重写了这些方法，那么显然会调用重写过的（自定义的）方法，<br>这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java 与模式》一书的第 37<br>章）。当然，自定义 Servlet 中也可以直接重写 service()方法，那么不管是哪种方式的请求，<br>都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。<br>10、Servlet 中如何获取用户提交的查询参数或表单数据？<br>考察点：servlet<br>参考回答：<br>可以通过请求对象（HttpServletRequest）的 getParameter()方法通过参数名获得参数值。<br>如果有包含多个值的参数（例如复选框），可以通过请求对象的 getParameterValues()方法获<br>得。当然也可以通过请求对象的 getParameterMap()获得一个参数名和参数值的映射（Map）。<br>11、Servlet 中如何获取用户配置的初始化参数以及服务器上下文参数？<br>考察点：初始化<br>参考回答：<br>可以通过重写 Servlet 接口的 init(ServletConfig)方法并通过 ServletConfig 对象的<br>getInitParameter()方法来获取 Servlet 的初始化参数。可以通过 ServletConfig 对象的<br>getServletContext()方法获取 ServletContext 对象，并通过该对象的 getInitParameter()方<br>法来获取服务器上下文参数。当然，ServletContext 对象也在处理用户请求的方法（如 doGet()<br>方法）中通过请求对象的 getServletContext()方法来获得。<br>NOWCODER.COM</p><p>3、请问 Java Web 开发的 Model 1 和 Model 2 分别指的是什么？<br>考察点：Model<br>参考回答：<br>Model 1 是以页面为中心的 Java Web 开发，使用 JSP+JavaBean 技术将页面显示逻辑和业务<br>逻辑处理分开，JSP 实现页面显示，JavaBean 对象用来保存数据和实现业务逻辑。Model 2 是基<br>于 MVC（模型-视图-控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视<br>图的彻底分离，利于团队开发和代码复用。 ④JSTL、DisplayTag 等常见标签库的用法<br>1、你的项目中使用过哪些 JSTL 标签？<br>考察点：JSTL<br>参考回答：<br>项目中主要使用了 JSTL 的核心标签库，包括&lt;c:if&gt;、&lt;c:choose&gt;、&lt;c: when&gt;、&lt;c: otherwise&gt;、<br>&lt;c:forEach&gt;等，主要用于构造循环和分支结构以控制显示逻辑。<br>虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库，但是实际开发中建议只使用核心<br>标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到<br>数据显示和业务逻辑的分离，这才是最佳实践。<br>2、使用标签库有什么好处？如何自定义 JSP 标签？（JSP 标签）<br>考察点：JSP 标签<br>参考回答：<br>使用标签库的好处包括以下几个方面：</p><ul><li>分离 JSP 页面的内容和逻辑，简化了 Web 开发；</li><li>开发者可以创建自定义标签来封装业务逻辑和显示逻辑；</li><li>标签具有很好的可移植性、可维护性和可重用性；</li><li>避免了对 Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在 JSP 中书写小脚本）<br>编写一个 Java 类实现实现 Tag&#x2F;BodyTag&#x2F;IterationTag 接口（开发中通常不直接实现这些<br>接口而是继承 TagSupport&#x2F;BodyTagSupport&#x2F;SimpleTagSupport 类，这是对缺省适配模式的应用），<br>重写 doStartTag()、doEndTag()等方法，定义标签要完成的功能：<br>NOWCODER.COM</li><li>编写扩展名为 tld 的标签描述文件对自定义标签进行部署，tld 文件通常放在 WEB-INF 文件夹<br>下或其子目录中</li><li>在 JSP 页面中使用 taglib 指令引用该标签库<br>3、Web 编程原理<br>①HTTP 协议<br>1、get 和 post 区别？<br>考察点：HTTP 请求<br>参考回答：<br>（1）在客户端， Get 方式在通过 URL 提交数据，数据 在 URL 中可以看到；POST 方式，数据<br>放置在 HTML HEADER 内提交。<br>（2）GET 方式提交的数据最多只能有 1024 字节，而 POST 则没有此限制。<br>（3）安全性问题。正如在（ 1 ）中提到，使用 Get 的时候，参数会显示在地址栏上，<br>而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get ；如果<br>用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post 为好。<br>安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同<br>一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，<br>GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从<br>自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的<br>一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。<br>POST 请求就不那么轻松了。 POST 表示可能改变服务器上的资源的请求。仍然以新闻站点<br>为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比<br>方说文章下面出现一条注解）。</li></ul><p>3、BS 与 CS 的联系与区别。<br>考察点：客户端&#x2F;服务器模式<br>NOWCODER.COM<br>参考回答：<br>C&#x2F;S 是 Client&#x2F;Server 的缩写。服务器通常采用高性能的 PC、工作站或小型机，并采用大型<br>数据库系统，如 Oracle、Sybase、Informix 或 SQL Server。客户端需要安装专用的客户端软件。<br>B&#x2F;Ｓ是 Brower&#x2F;Server 的缩写，客户机上只要安装一个浏览器（Browser），如 Netscape Navigator<br>或 Internet Explorer，服务器安<br>装 Oracle、Sybase、Informix 或 SQL Server 等数据库。在这种结构下，用户界面完全通过 WWW<br>浏览器实现，一部分事务逻辑在前端实<br>现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C&#x2F;S 与 B&#x2F;S 区别：<br>硬件环境不同:<br>C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供<br>连接和数据交换服务.<br>B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自<br>己管理. 有比 C&#x2F;S 更强的适应范围, 一<br>般只要有操作系统和浏览器就行<br>２．对安全要求不同<br>C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统<br>采用 C&#x2F;S 结构适宜. 可以通过 B&#x2F;S 发布<br>部分可公开信息.<br>B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同<br>C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.<br>B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比 C&#x2F;S 有更高<br>的要求 B&#x2F;S 结构的程序架构是发展的趋<br>势, 从 MS 的.Net 系列的 BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN<br>和 IBM 推的 JavaBean 构件技术等,使<br>B&#x2F;S 更加成熟. ４．软件重用不同<br>C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在 B&#x2F;S 要求下的构件的重用性好.<br>B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以<br>再利用,而不是做在墙上的石头桌子<br>５．系统维护不同<br>C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再<br>做一个全新的系统<br>B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从<br>网上自己下载安装就可以实现升级. ６．处理问题不同<br>C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应<br>该都是相同的系统<br>B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是 C&#x2F;S 无法作到的. 与操作系统<br>平台关系最小. ７．用户接口不同<br>C&#x2F;S 多是建立的 Window 平台上,表现方法有限,对程序员普遍要求较高<br>B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减<br>低开发成本. ８．信息流不同<br>C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低<br>B&#x2F;S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。<br>NOWCODER.COM<br>4、如何设置请求的编码以及响应内容的类型？<br>考察点：请求类型<br>参考回答：<br>通过请求对象（ServletRequest）的 setCharacterEncoding(String)方法可以设置请求的<br>编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java 程序都使用统一的<br>编码，最好的选择当然是 UTF-8；通过响应对象（ServletResponse）的 setContentType(String)<br>方法可以设置响应内容的类型，当然也可以通过 HttpServletResponsed 对象的<br>setHeader(String, String)方法来设置。<br>5、什么是 Web Service（Web 服务）？<br>考察点：web service<br>参考回答：<br>从表面上看，Web Service 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用<br>的 API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，<br>跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的 Web Service，那么无论你<br>用哪种编程语言开发的应用都可以通过调用它的 API 并传入城市信息来获得该城市的天气预报。<br>之所以称之为 Web Service，是因为它基于 HTTP 协议传输数据，这使得运行在不同机器上的不<br>同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。<br>SOA（Service-Oriented Architecture，面向服务的架构），SOA 是一种思想，它将应用程<br>序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种<br>形式的功能单元能够更好的集成。显然，Web Service 是 SOA 的一种较好的解决方案，它更多的<br>是一种标准，而不是一种具体的技术。<br>6、谈谈 Session 的 save()、update()、merge()、lock()、saveOrUpdate()和<br>persist()方法分别是做什么的？有什么区别？<br>考察点：session<br>参考回答：<br>Hibernate 的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态<br>（detached），如第 135 题中的图所示。瞬时态的实例可以通过调用 save()、persist()或者<br>saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()<br>或者 replicate()变成持久态。save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()<br>或 merge()会引发 UPDATE 语句。save()和 update()的区别在于一个是将瞬时态对象变成持久态，<br>一个是将游离态对象变为持久态。merge()方法可以完成 save()和 update()方法的功能，它的意<br>图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于 persist()方法，按照<br>官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填<br>入到持久化实例中，标识符的填入可能被推迟到 flush 的时间；② persist()方法保证当它在一<br>个事务外部被调用的时候并不触发一个 INSERT 语句，当需要封装一个长会话流程的时候，<br>persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执<br>行 INSERT 语句，不管是在事务内部还是外部。至于 lock()方法和 update()方法的区别，update()<br>方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱<br>管状态的对象变成持久状态。<br>NOWCODER.COM<br>7、大型网站在架构上应当考虑哪些问题？<br>考察点：Java 架构<br>参考回答：</p><ul><li>分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个<br>层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形<br>成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI&#x2F;RM）和 Internet 的 TCP&#x2F;IP<br>模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储<br>和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。<br>需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备<br>上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之<br>间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</li><li>分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚<br>低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模<br>块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另<br>一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</li><li>分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独<br>立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的<br>加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式<br>部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，<br>例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce<br>分布式计算框架来处理。</li><li>集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</li><li>缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓<br>存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。</li><li>异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，<br>二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影<br>响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用<br>Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能<br>推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</li><li>冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可<br>以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。 ③Web 容器<br>1、请对以下在 J2EE 中常用的名词进行解释(或简单描述)<br>考察点：J2EE<br>参考回答：<br>web 容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP,SERVLET<br>直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有 WEB 服务器来实现。例如：<br>TOMCAT,WEBLOGIC,WEBSPHERE 等。该容器提供的接口严格遵守 J2EE 规范中的 WEBAPPLICATION 标<br>准。我们把遵守以上标准的 WEB 服务器就叫做 J2EE 中的 WEB 容器。<br>Web container：实现 J2EE 体系结构中 Web 组件协议的容器。这个协议规定了一个 Web 组件运行<br>时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和 JSP 和<br>J2EE 平台 APIs 界面相同服务的容器。一个 Web container 由 Web 服务器或者 J2EE 服务器提供。<br>EJB 容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件 EJB<br>NOWCODER.COM<br>各种管理功能。只要满足 J2EE 规范的 EJB 放入该容器，马上就会被容器进行高效率的管理。并<br>且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了 J2EE 体<br>系结构中 EJB 组件规范的容器。这个规范指定了一个 Enterprise bean 的运行时环境，包括安全，<br>一致性，生命周期，事务，配置，和其他的服务。<br>JNDI：（Java Naming &amp; Directory Interface）JAVA 命名目录服务。主要提供的功能是：提供<br>一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布<br>式应用程序的功能。<br>JMS：（Java Message Service）JAVA 消息服务。主要实现各个应用程序之间的通讯。包括点对<br>点和广播。<br>JTA：（Java Transaction API）JAVA 事务服务。提供各种分布式事务服务。应用程序只需调用<br>其提供的接口即可。<br>JAF：（Java Action FrameWork）JAVA 安全认证框架。提供一些安全控制方面的框架。让开发<br>者通过各种部署和自定义实现自己的个性安全控制策略。<br>RMI&#x2F;IIOP: （Remote Method Invocation &#x2F;internet 对象请求中介协议）他们主要用于通过远<br>程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地<br>计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI<br>是 JAVA 特有的。RMI-IIOP 出现以前，只有 RMI 和 CORBA 两种选择来进行分布式程序设计。<br>RMI-IIOP 综合了 RMI 和 CORBA 的优点，克服了他们的缺点，使得程序员能更方便的编写分布式<br>程序设计，实现分布式计算。首先，RMI-IIOP 综合了 RMI 的简单性和 CORBA 的多语言性（兼容<br>性），其次 RMI-IIOP 克服了 RMI 只能用于 Java 的缺点和 CORBA 的复杂性。 四、JDBC 编程</li></ul><p>2、JDBC 基础<br>①数据库<br>1、数据库水平切分，垂直切分<br>考察点：数据库<br>参考回答：<br>NOWCODER.COM<br>垂直拆分就是要把表按模块划分到不同数据库表中（当然原则还是不破坏第三范式），这种<br>拆分在大型网站的演变过程中是很常见的。当一个网站还在很小的时候，只有小量的人来开发和<br>维护，各模块和表都在一起，当网站不断丰富和壮大的时候，也会变成多个子系统来支撑，这时<br>就有按模块和功能把表划分出来的需求。其实，相对于垂直切分更进一步的是服务化改造，说得<br>简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，<br>因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，淘宝在架构不断演<br>变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成独立<br>的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。<br>垂直拆分：单表大数据量依然存在性能瓶颈<br>水平拆分，上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量<br>的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。例如像计费<br>系统，通过按时间来划分表就比较合适，因为系统都是处理某一时间段的数据。而像 SaaS 应用，<br>通过按用户维度来划分数据比较合适，因为用户与用户之间的隔离的，一般不存在处理多个用户<br>数据的情况，简单的按 user_id 范围来水平切分。<br>通俗理解：水平拆分行，行数据拆分到不同表中， 垂直拆分列，表数据拆分到不同表中。</p><p>10、leftjoin 和 rightjoin 的区别？<br>考察点：表结构<br>参考回答：<br>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录<br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>比如：<br>表 A 记录如下：<br>aID aNum<br>1 a20050111<br>2 a20050112<br>3 a20050113<br>4 a20050114<br>5 a20050115<br>表 B 记录如下:<br>bID bName<br>1 2006032401<br>2 2006032402<br>3 2006032403<br>4 2006032404<br>8 2006032408<br>left join 是以 A 表的记录为基础的,A 可以看成左表,B 可以看成右表,left join 是以左表<br>为准的. 换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为:<br>A.aID &#x3D; B.bID).<br>B 表记录不足的地方均为 NULL. 11、数据库优化方法<br>考察点：数据库<br>参考回答：<br>（1）选取最适用的字段属性<br>MySQL 可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行<br>的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度<br>设得尽可能小。<br>例如，在定义邮政编码这个字段时，如果将其设置为 CHAR(255),显然给数据库增加了不必<br>要的空间，甚至使用 VARCHAR 这种类型也是多余的，因为 CHAR(6)就可以很好的完成任务了。同<br>样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段。<br>NOWCODER.COM<br>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为 NOTNULL，这样在将来<br>执行查询的时候，数据库不用去比较 NULL 值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL<br>中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。<br>这样，我们又可以提高数据库的性能。<br>（2）使用连接（JOIN）来代替子查询(Sub-Queries)<br>MySQL 从 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查<br>询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没<br>有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户 ID 取出<br>来，然后将结果传递给主查询<br>（3）使用联合(UNION)来代替手动创建的临时表<br>MySQL 从 4.0 的版本开始支持 union 查询，它可以把需要使用临时表的两条或更多的 select<br>查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据<br>库整齐、高效。使用 union 来创建查询的时候，我们只需要用 UNION 作为关键字把多个 select<br>语句连接起来就可以了，要注意的是所有 select 语句中的字段数目要想同。下面的例子就演示<br>了一个使用 UNION 的查询。<br>（4）事务<br>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样<br>的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时<br>候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句<br>运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两<br>个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，<br>造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。<br>要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失<br>败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以 BEGIN 关键字开始，COMMIT<br>关键字结束。在这之间的一条 SQL 操作失败，那么，ROLLBACK 命令就可以把数据库恢复到 BEGIN<br>开始之前的状态。<br>12、谈一下你对继承映射的理解。<br>考察点：映射<br>参考回答：<br>继承关系的映射策略有三种：<br>① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。<br>② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。<br>③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。<br>第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态<br>查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是<br>需要进行连接查询，不适合多态查询。<br>NOWCODER.COM<br>②数据库连接池<br>1、说出数据连接池的工作机制是什么?<br>考察点：连接池<br>参考回答：<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连<br>接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用<br>完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 ③事物管理，批处理<br>1、事务的 ACID 是指什么？<br>考察点：数据库<br>参考回答：</p><ul><li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导<br>致整个事务的失败； - 一致性(Consistent)：事务结束后系统状态是一致的； - 隔离性<br>(Isolated)：并发执行的事务彼此无法看到对方的中间状态； - 持久性(Durable)：事务完成后<br>所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建<br>数据。<br>关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，<br>只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括<br>3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类<br>丢失更新）。<br>2、JDBC 中如何进行事务处理？<br>考察点：数据库<br>参考回答：<br>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置手动提交事<br>务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中发生异常则通过 rollback()<br>进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代<br>码设置保存点并让事务回滚到指定的保存点。<br>NOWCODER.COM<br>3、JDBC 进阶<br>1、JDBC 的反射，反射都是什么？<br>考察点：jdbc<br>参考回答：<br>通过反射 com.mysql.jdbc.Driver 类，实例化该类的时候会执行该类内部的静态代码块，该<br>代码块会在 Java 实现的 DriverManager 类中注册自己,DriverManager 管理所有已经注册的驱动<br>类，当调用 DriverManager.geConnection 方法时会遍历这些驱动类，并尝试去连接数据库，只<br>要有一个能连接成功，就返回 Connection 对象，否则则报异常。</li></ul><p>4、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性<br>能？<br>考察点：JDBC 优化<br>NOWCODER.COM<br>参考回答：<br>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()方法指<br>定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用<br>PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。 五、XML 编程<br>1、XML 基础<br>1、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种<br>方式？<br>考察点：XML<br>参考回答：<br>a: 两种形式 dtd schema<br>b: 本质区别:schema 本身是 xml 的，可以被 XML 解析器解析(这也是从 DTD 上发展 schema 的根<br>本目的)<br>c:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这种结构占<br>用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML 的随机访问<br>SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文件，不需要一次全部装载<br>整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用<br>户通过在其回调事件中写入处理代码来处理 XML 文件，适合对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)<br>xml 文档有两种定义方法：<br>dtd：数据类型定义（data type definition），用以描述 XML 文档的文档结构，是早期的 XML<br>文档定义形式。<br>schema：其本身是基于 XML 语言编写的，在类型和语法上的限定能力比 dtd 强，处理也比较方便，<br>因为此正逐渐代替 dtd 成为新的模式定义语言。<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>1、WEB SERVICE 名词解释，JSWDL 开发包的介绍，JAXP、JAXM 的解释。SOAP、<br>UDDI,WSDL 解释。<br>考察点：web service<br>NOWCODER.COM<br>参考回答：<br>Web ServiceWeb Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 WebService 能与其他兼容的组件进行互操作。JAXP(Java API for<br>XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。这样在你的程序中你只要<br>使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。JAXM(Java API for XML<br>Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。WSDL 是一种 XML 格式，用于将网<br>络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格<br>式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。<br>相关的具体端点即组合成为抽象端点（服务）。SOAP 即简单对象访问协议(Simple Object Access<br>Protocol)，它是用于交换 XML 编码信息的轻量级协议。UDDI 的目的是为电子商务建立标准；UDDI<br>是一套基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范，同时也<br>包含一组使企业能将自身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标<br>准。soap 是 web service 最关键的技术，是 web service 中数据和方法调传输的介质。WSDL（web<br>service definition language）描述了 web service 的接口和功能。<br>2、请你谈谈对 SOAP、WSDL、UDDI 的了解？<br>考察点：协议&amp;语言<br>参考回答：</p><ul><li>SOAP：简单对象访问协议（Simple Object Access Protocol），是 Web Service 中交换<br>数据的一种协议规范。</li><li>WSDL：Web 服务描述语言（Web Service Description Language），它描述了 Web 服务的公共<br>接口。这是一个基于 XML 的关于如何与 Web 服务通讯和使用的服务描述；也就是描述与目录中列<br>出的 Web 服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作<br>和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。</li><li>UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它<br>是一个基于 XML 的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服<br>务。简单的说，UDDI 是访问各种 WSDL 的一个门面（可以参考设计模式中的门面模式）。<br>3、谈谈 Java 规范中和 Web Service 相关的规范有哪些？<br>考察点：规范<br>参考回答：<br>Java 规范中和 Web Service 相关的有三个：</li><li>JAX-WS(JSR 224)：这个规范是早期的基于 SOAP 的 Web Service 规范 JAX-RPC 的替代版本，它<br>并不提供向下兼容性，因为 RPC 样式的 WSDL 以及相关的 API 已经在 Java EE5 中被移除了。<br>WS-MetaData 是 JAX-WS 的依赖规范，提供了基于注解配置 Web Service 和 SOAP 消息的相关 API。</li><li>JAXM(JSR 67)：定义了发送和接收消息所需的 API,相当于 Web Service 的服务器端。</li><li>JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是 Java 针对 REST（Representation State Transfer）<br>架构风格制定的一套 Web Service 规范。REST 是一种软件架构模式，是一种风格，它不像 SOAP<br>那样本身承载着一种消息协议，(两种风格的 Web Service 均采用了 HTTP 做传输协议，因为 HTTP<br>协议能穿越防火墙，Java 的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因<br>此可以将 REST 视为基于 HTTP 协议的软件架构。REST 中最重要的两个概念是资源定位和资源操<br>作，而 HTTP 协议恰好完整的提供了这两个点。HTTP 协议中的 URI 可以完成资源定位，而 GET、<br>POST、OPTION、DELETE 方法可以完成资源操作。因此 REST 完全依赖 HTTP 协议就可以完成 Web<br>NOWCODER.COM<br>Service，而不像 SOAP 协议那样只利用了 HTTP 的传输特性，定位和操作都是由 SOAP 协议自身完<br>成的，也正是由于 SOAP 消息的存在使得基于 SOAP 的 Web Service 显得笨重而逐渐被淘汰。 六、计算机网络<br>1、网络概述<br>①关于分层<br>1、TCP 协议在哪一层？IP 协议在那一层？HTTP 在哪一层？<br>考察点：网络七层模型<br>参考回答：<br>运输层，网络层，应用层。<br>2、运输层<br>①TCP 与 UDP<br>1、讲一下 TCP 的连接和释放连接。<br>考察点：网络基础<br>参考回答：<br>三次握手的过程<br>1）主机 A 向主机 B 发送 TCP 连接请求数据包，其中包含主机 A 的初始序列号 seq(A)&#x3D;x。（其<br>中报文中同步标志位 SYN&#x3D;1，ACK&#x3D;0，表示这是一个 TCP 连接请求数据报文；序号 seq&#x3D;x，表明传<br>输数据时的第一个数据字节的序号是 x）；<br>2）主机 B 收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位 SYN&#x3D;1，ACK&#x3D;1，<br>表示这是一个 TCP 连接响应数据报文，并含主机 B 的初始序列号 seq(B)&#x3D;y，以及主机 B 对主机 A<br>初始序列号的确认号 ack(B)&#x3D;seq(A)+1&#x3D;x+1）<br>3）第三次，主机 A 收到主机 B 的确认报文后，还需作出确认，即发送一个序列号 seq(A)&#x3D;x+1；<br>确认号为 ack(A)&#x3D;y+1 的报文；<br>四次挥手过程<br>NOWCODER.COM<br>假设主机 A 为客户端，主机 B 为服务器，其释放 TCP 连接的过程如下：<br>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数<br>据传送，然后等待服务器的确认。其中终止标志位 FIN&#x3D;1，序列号 seq&#x3D;u。<br>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。<br>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。<br>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加<br>1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>三次握手<br>四次挥手<br>2、TCP 有哪些应用场景<br>考察点：TCP 协议<br>参考回答：<br>NOWCODER.COM<br>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一<br>些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议<br>3、tcp 为什么可靠<br>考察点：TCP<br>参考回答：<br>三次握手，超时重传，滑动窗口，拥塞控制。<br>4、tcp 为什么要建立连接<br>考察点：TCP<br>参考回答：<br>保证可靠传输。<br>5、阐述 TCP 的 4 次挥手<br>考察点：TCP 协议<br>参考回答：<br>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的<br>数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上<br>没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动<br>关闭，而另一方执行被动关闭。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服<br>务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。<br>（1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送。<br>（2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，<br>一个 FIN 将占用一个序号。<br>（3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A。<br>（4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。<br>NOWCODER.COM<br>②协议<br>1、讲一下浏览器从接收到一个 URL 到最后展示出页面，经历了哪些过程。tag<br>考察点：http 协议<br>参考回答：<br>1.DNS 解析 2.TCP 连接 3.发送 HTTP 请求 4.服务器处理请求并返回 HTTP 报文<br>5.浏览器解析渲染页面<br>2、http 和 https 的区别<br>考察点：http 协议<br>参考回答；<br>https 协议要申请证书到 ca，需要一定经济成本；2） http 是明文传输，https 是加密的安<br>全传输；3） 连接的端口不一样，http 是 80，https 是 443；4）http 连接很简单，没有状态；<br>https 是 ssl 加密的传输，身份认证的网络协议，相对 http 传输比较安全。<br>3、http 的请求有哪些，应答码 502 和 504 有什么区别<br>考察点：http 协议<br>参考回答：<br>OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送<br>‘*‘的请求来测试服务器的功能性。<br>HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以<br>在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>NOWCODER.COM<br>GET：向特定的资源发出请求。<br>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请<br>求体中。POST 请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>PUT：向指定资源位置上传其最新内容。<br>DELETE：请求服务器删除 Request-URI 所标识的资源。<br>TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求<br>方式也都可以通过这两种方式间接的来实现。<br>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识<br>出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。<br>4、http1.1 和 1.0 的区别<br>考察点：http<br>参考回答：<br>主要区别主要体现在：<br>缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判<br>断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since,<br>If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。<br>带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要<br>某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在<br>请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），<br>这样就方便了开发者自由的选择以便于充分利用带宽和连接。<br>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请<br>求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。<br>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中<br>的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以<br>存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求<br>消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad<br>Request）。<br>长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）<br>处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，<br>在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创<br>建连接的缺点。<br>NOWCODER.COM<br>5、说说 ssl 四次握手的过程<br>考察：HTTP 加密协议<br>参考回答：<br>1、 客户端发出请求<br>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello<br>请求。<br>2、服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。<br>3、客户端回应<br>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书<br>中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还<br>要继续通信。<br>4、服务器的最后回应<br>服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的”会话密<br>钥”。然后，向客户端最后发送下面信息。<br>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所<br>有内容的 hash 值，用来供客户端校验。<br>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通<br>的 HTTP 协议，只不过用”会话密钥”加密内容。<br>6、304 状态码有什么含义？<br>考察点：http<br>参考回答：<br>304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页<br>内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为<br>If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，<br>进而节省带宽和开销。<br>3、网络层<br>①网际协议 IP<br>1、arp 协议，arp 攻击<br>NOWCODER.COM<br>考察点：ARP 协议<br>参考回答：<br>地址解析协议。ARP 攻击的第一步就是 ARP 欺骗。由上述“ARP 协议的工作过程”我们知道，<br>ARP 协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正<br>确和快速的完成——ARP 协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在<br>向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现 ARP 应答中的 IP 地址和 MAC<br>地址中的信息是可以伪造的，并不一定是自己的真实 IP 地址和 MAC 地址，由此，ARP 欺骗就产<br>生了。 ②网际控制报文协议 ICMP<br>1、icmp 协议<br>考察点：ICMP 协议<br>参考回答：<br>它是 TCP&#x2F;IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息。控制消息是<br>指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用<br>户数据，但是对于用户数据的传递起着重要的作用。 ③因特网的路由器选择协议<br>1、讲一下路由器和交换机的区别？<br>考察点：路由器<br>参考回答：<br>交换机用于同一网络内部数据的快速传输转发决策通过查看二层头部完成转发不需要修改<br>数据帧工作在 TCP&#x2F;IP 协议的二层 —— 数据链路层工作简单，直接使用硬件处理路由器用于不<br>同网络间数据的跨网络传输转发决策通过查看三层头部完成转发需要修改 TTL ，IP 头部校验和<br>需要重新计算，数据帧需要重新封装工作在 TCP&#x2F;IP 协议的三层 —— 网络层工作复杂，使用软<br>件处理。<br>4、应用层<br>①域名系统 DNS<br>1、DNS 寻址过程<br>考察点：DNS<br>NOWCODER.COM<br>参考回答：<br>1、在浏览器中输入 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个<br>网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。<br>2、如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射<br>关系，如果有，直接返回，完成域名解析。<br>3、如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP&#x2F;ip 参数中<br>设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域<br>名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。<br>4、如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关<br>系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。<br>5、如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是<br>否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服<br>务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的<br>一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com<br>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS 服务器地<br>址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，<br>重复上面的动作，进行查询，直至找到 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 主机。<br>6、如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服<br>务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不<br>管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此<br>DNS 服务器再返回给客户机。<br>从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查<br>询。②电子邮件<br>1、负载均衡反向代理模式优点及缺点<br>考察点：反向代理<br>参考回答：<br>（1）反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然<br>后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接<br>的客户端，此时代理服务器对外就表现为一个服务器。<br>（2）反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转<br>发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。<br>（3）反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，<br>也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡<br>策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由<br>于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有<br>此优点）。<br>NOWCODER.COM<br>（4）其缺点主要表现在以下两个方面<br>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反<br>向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器<br>的负载均衡。<br>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接<br>请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的<br>瓶颈。<br>一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点<br>进行负载均衡，如 search 等。 七、操作系统<br>1、操作系统概论<br>1、CentOS 和 Linux 的关系？<br>考察点：操作系统<br>参考回答：<br>CentOS是Linux众多得发行版本之一，linux有三大发行版本（：Slackware、debian、redhat）, 而 Redhat 有收费的商业版和免费的开源版,商业版的业内称之为 RHEL 系列，CentOS 是来自于依<br>照开放源代码规定而公布的源代码重新编译而成。可以用 CentOS 替代商业版的 RHEL 使用。两者<br>的不同，CentOS 不包含封闭源代码软件，是免费的。<br>2、64 位和 32 位的区别？<br>考察点：<br>操作系统<br>参考回答：<br>操作系统只是硬件和应用软件中间的一个平台。32 位操作系统针对的 32 位的 CPU 设计。64<br>位操作系统针对的 64 位的 CPU 设计。<br>2、进程的描述与控制<br>1、怎么杀死进程？<br>考察点：进程<br>参考回答：<br>NOWCODER.COM<br>Kill pid<br>2、线程，进程区别<br>考察点：进程，线程<br>参考回答：<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，<br>一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路<br>径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个<br>进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要<br>差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。1. 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li></ul><ol start="2"><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高<br>了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序<br>执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多<br>个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这<br>就是进程和线程的重要区别。<br>3、系统线程数量上限是多少？<br>考察点：线程<br>参考回答：<br>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。<br>这个限制可以在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;local_lim.h 中查看 ，对 linuxthreads 这个值一般<br>是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。<br>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程<br>栈大小，一般情况下，这个值是 8M&#x3D;8192KB。<br>4、进程和线程的区别是什么？<br>考察点：JAVA 进程<br>参考回答：<br>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。<br>线程又叫做轻量级进程。<br>NOWCODER.COM<br>5、解释一下 LINUX 下线程，GDI 类。<br>考察点：线程<br>参考回答：<br>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心<br>轻量级进程，而线程之间的管理在核外函数库中实现。<br>GDI 类为图像设备编程接口类库。<br>3、输入输出系统<br>1、socket 编程，BIO，NIO，epoll？<br>考察点：I&#x2F;O 多路复用<br>参考回答：<br>阻塞，非阻塞，io 多路复用，epoll 支持文件符数目没有限制，fd 集合只会从用户进程拷<br>贝到内核一次，自己维护一个事件队列，不用每次遍历 fd 集合发现是否有就绪状态。<br>4、存储器管理<br>1、什么是页式存储？<br>考察点：页式存储<br>参考回答：<br>主存被等分成大小相等的片，称为主存块，又称为实页。<br>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为 2n ,通常为 1KB、2KB、<br>2n KB 等<br>2、操作系统里的内存碎片你怎么理解，有什么解决办法？<br>考察点：内存碎片<br>参考回答：<br>内存碎片分为：内部碎片和外部碎片。<br>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；<br>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存<br>储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才<br>有可能利用这个存储块。<br>NOWCODER.COM<br>单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。<br>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存<br>空间的新进程的内存空闲区域。<br>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前<br>申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br>使用伙伴系统算法。<br>5、处理机调度与死锁<br>1、什么情况下会发生死锁，解决策略有哪些？<br>考察点：死锁<br>参考回答：<br>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个<br>进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如 CD-ROM 驱动器，打印机等<br>等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属<br>性所决定的。<br>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至<br>少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但<br>是，它在等待新资源之时，仍继续占用已占有的资源。<br>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源<br>的占有者进程自行释放。<br>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。<br>解决方法：银行家算法<br>2、系统 CPU 比较高是什么原因？<br>考察点：处理机<br>参考回答：<br>1、首先查看是哪些进程的 CPU 占用率最高（如下可以看到详细的路径）<br>ps -aux –sort -pcpu | more# 定位有问题的线程可以用如下命令ps -mp pid -o THREAD,tid,time | more<br>2、查看 JAVA 进程的每个线程的 CPU 占用率<br>ps -Lp 5798 cu | more # 5798 是查出来进程 PID<br>NOWCODER.COM<br>3、追踪线程，查看负载过高的原因，使用 JDK 下的一个工具<br>jstack 5798 # 5798 是 PID<br>jstack -J-d64 -m 5798 # -j-d64 指定 64 为系统<br>jstack 查出来的线程 ID 是 16 进制，可以把输出追加到文件，导出用记事本打开，再根据<br>系统中的线程 ID 去搜索查看该 ID 的线程运行内容，可以和开发一起排查。<br>3、系统如何提高并发性？<br>考察：操作系统综合性<br>参考回答：<br>1、提高 CPU 并发计算能力<br>（1）多进程&amp;多线程<br>（2）减少进程切换，使用线程，考虑进程绑定 CPU<br>（3）减少使用不必要的锁，考虑无锁编程<br>（4）考虑进程优先级<br>（5）关注系统负载<br>2、改进 I&#x2F;O 模型<br>(1)DMA 技术<br>(2)异步 I&#x2F;O<br>(3)改进多路 I&#x2F;O 就绪通知策略，epoll<br>(4)Sendfile<br>(5)内存映射<br>(6)直接 I&#x2F;O<br>八、算法与数据结构<br>1、哈希<br>1、hashset 存的数是有序的吗？<br>考察点：哈希<br>NOWCODER.COM<br>参考回答：<br>Hashset 是无序的。<br>2、Object 作为 HashMap 的 key 的话，对 Object 有什么要求吗？<br>考察点：哈希表<br>参考回答：<br>要求 Object 中 hashcode 不能变。<br>3、一致性哈希算法<br>考察点：哈希算法<br>参考回答：<br>先构造一个长度为 232 的整数环（这个环被称为一致性 Hash 环），根据节点名称的 Hash<br>值（其分布为[0, 232-1]）将服务器节点放置在这个 Hash 环上，然后根据数据的 Key 值计算得<br>到其 Hash 值（其分布也为[0, 232-1]），接着在 Hash 环上顺时针查找距离这个 Key 值的 Hash<br>值最近的服务器节点，完成 Key 到服务器的映射查找。<br>这种算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况<br>下尽量有多的请求命中原来路由到的服务器。<br>4、什么是 hashmap?<br>考察点：哈希表<br>参考回答：<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于 AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null。此<br>外，HashMap 中的映射不是有序的。<br>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表<br>中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前<br>可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该<br>哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少<br>了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操<br>作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便<br>最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生<br>rehash 操作。<br>hashmap 共有 4 个构造函数：<br>&#x2F;&#x2F; 默认构造函数。HashMap()<br>&#x2F;&#x2F; 指定“容量大小”的构造函数<br>NOWCODER.COM<br>HashMap(int capacity)<br>&#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数<br>HashMap(int capacity, float loadFactor)<br>&#x2F;&#x2F; 包含“子 Map”的构造函数<br>HashMap(Map&lt;? extends K, ? extends V&gt; map)<br>5、Java 中的 HashMap 的工作原理是什么？<br>考察点：JAVA 哈希表<br>参考回答：<br>HashMap 类有一个叫做 Entry 的内部类。这个 Entry 类包含了 key-value 作为实例变量。每<br>当往 hashmap 里面存放 key-value 对的时候，都会为它们实例化一个 Entry 对象，这个 Entry<br>对象就会存储在前面提到的 Entry 数组 table 中。Entry 具体存在 table 的那个位置是 根据 key<br>的 hashcode()方法计算出来的 hash 值（来决定）。<br>6、hashCode()和 equals()方法的重要性体现在什么地方？<br>考察点：JAVA 哈希表<br>参考回答：<br>Java 中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值<br>的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的<br>hash 值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这<br>两个方法的实现对 HashMap 的精确性和正确性是至关重要的。<br>2、树<br>1、说一下 B+树和 B-树？<br>考察点：树<br>参考回答：<br>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；<br>b+树查询必须查找到叶子节点，b 树只要匹配到即可不用管元素位置，因此 b+树查找更稳定<br>（并不慢）；<br>对于范围查找来说，b+树只需遍历叶子节点链表即可，b 树却需要重复地中序遍历。<br>2、怎么求一个二叉树的深度?手撕代码?<br>考察点：二叉树<br>NOWCODER.COM<br>参考回答：<br>public int maxDepth(TreeNode root) {<br>if (root &#x3D;&#x3D; null) {<br>return 0;<br>}<br>int left &#x3D; maxDepth(root.left);<br>int right &#x3D; maxDepth(root.right);<br>int bigger &#x3D; Math.max(left, right);<br>return bigger + 1;<br>}<br>3、算法题：二叉树层序遍历，进一步提问：要求每层打印出一个换行符<br>考察点：二叉树<br>参考回答：<br>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {<br>List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();<br>LinkedList&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;TreeNode&gt;();<br>if (root &#x3D;&#x3D; null) {<br>return res;<br>}<br>queue.offer(root);<br>while (queue.size() !&#x3D; 0) {<br>List&lt;Integer&gt; l &#x3D; new ArrayList&lt;Integer&gt;();<br>int size &#x3D; queue.size();<br>for (int i &#x3D; 0; i &lt; size; i++) {<br>TreeNode temp &#x3D; queue.poll();<br>l.add(temp.val);<br>if (temp.left !&#x3D; null) {<br>NOWCODER.COM<br>queue.offer(temp.left);<br>}<br>if (temp.right !&#x3D; null) {<br>queue.offer(temp.right);<br>}<br>}<br>res.add(l);<br>}<br>return res;<br>}<br>4、二叉树任意两个节点之间路径的最大长度<br>考察点：树<br>参考回答：<br>int maxDist(Tree root) {<br>&#x2F;&#x2F;如果树是空的，则返回 0<br>if(root &#x3D;&#x3D; NULL)<br>return 0;<br>if(root-&gt;left !&#x3D; NULL) {<br>root-&gt;lm &#x3D; maxDist(root-&gt;left) + 1;<br>}<br>if(root-&gt;right !&#x3D; NULL)<br>root-&gt;rm &#x3D; maxDist(root-&gt;right) + 1;<br>&#x2F;&#x2F;如果以该节点为根的子树中有最大的距离，那就更新最大距离<br>int sum &#x3D; root-&gt;rm + root-&gt;lm;<br>if(sum &gt; max) {<br>max &#x3D; sum;<br>NOWCODER.COM<br>}<br>return root-&gt;rm &gt; root-&gt;lm ? root-&gt;rm : root-&gt;lm;<br>}<br>5、如何实现二叉树的深度？<br>考察点：二叉树<br>参考回答：<br>实现二叉树的深度方式有两种，递归以及非递归。<br>①递归实现：<br>为了求树的深度，可以先求其左子树的深度和右子树的深度，可以用递归实现，递归的出口<br>就是节点为空。返回值为 0；<br>②非递归实现：<br>利用层次遍历的算法，设置变量 level 记录当前节点所在的层数，设置变量 last 指向当前<br>层的最后一个节点，当处理完当前层的最后一个节点，让 level 指向+1 操作。设置变量 cur 记<br>录当前层已经访问的节点的个数，当 cur 等于 last 时，表示该层访问结束。<br>层次遍历在求树的宽度、输出某一层节点，某一层节点个数，每一层节点个数都可以采取类<br>似的算法。<br>树的宽度：在树的深度算法基础上，加一个记录访问过的层节点个数最多的变量 max,在访<br>问每层前 max 与 last 比较，如果 max 比较大，max 不变，如果 max 小于 last，把 last 赋值给<br>max;<br>6、如何打印二叉树每层的节点？<br>考察点：二叉树<br>参考回答：</li></ol><p>4、bucket 如果用链表存储，它的缺点是什么？<br>考察点：链表<br>参考回答：<br>①查找速度慢，因为查找时，需要循环链表访问<br>②如果进行频繁插入和删除操作，会导致速度很慢。<br>5、如何判断链表检测环<br>考察点：链表<br>参考回答：<br>单链表有环，是指单链表中某个节点的 next 指针域指向的是链表中在它之前的某一个节点，<br>这样在链表的尾部形成一个环形结构。<br>&#x2F;&#x2F; 链表的节点结构如下 typedef struct node { int data; struct node *next; } NODE;<br>最常用方法：定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针<br>一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指<br>针走到了链表的末尾（next 指向 NULL）都没有追上第一个指针，那么链表就不是环形链表。<br>通过使用 STL 库中的 map 表进行映射。首先定义 map&lt;NODE , int&gt; m; 将一个 NODE * 指<br>针映射成数组的下标，并赋值为一个 int 类型的数值。然后从链表的头指针开始往后遍历，每<br>次遇到一个指针 p，就判断 m[p] 是否为 0。如果为 0，则将 m[p]赋值为 1，表示该节点第一次<br>访问；而如果 m[p]的值为 1，则说明这个节点已经被访问过一次了，于是就形成了环。</p><p>6、排序<br>1、排序算法知道哪些，时间复杂度是多少，解释一下快排？<br>考察点：快排<br>参考回答：<br>快排：快速排序有两个方向，左边的 i 下标一直往右走（当条件 a[i] &lt;&#x3D; a[center_index]<br>时），其中 center_index 是中枢元素的数组下标，一般取为数组第 0 个元素。<br>而右边的 j 下标一直往左走（当 a[j] &gt; a[center_index]时）。<br>如果 i 和 j 都走不动了，i &lt;&#x3D; j, 交换 a[i]和 a[j],重复上面的过程，直到 i&gt;j。交换 a[j]<br>和 a[center_index]，完成一趟快速排序。<br>2、如何得到一个数据流中的中位数？<br>考察点：排序<br>参考回答：<br>数据是从一个数据流中读出来的，数据的数目随着时间的变化而增加。如果用一个数据容器<br>来保存从流中读出来的数据，当有新的数据流中读出来时，这些数据就插入到数据容器中。<br>数组是最简单的容器。如果数组没有排序，可以用 Partition 函数找出数组中的中位数。<br>在没有排序的数组中插入一个数字和找出中位数的时间复杂度是 O(1)和 O(n)。<br>我们还可以往数组里插入新数据时让数组保持排序，这是由于可能要移动 O(n)个数，因此<br>需要 O(n)时间才能完成插入操作。在已经排好序的数组中找出中位数是一个简单的操作，只需<br>要 O(1)时间即可完成。<br>排序的链表时另外一个选择。我们需要 O(n)时间才能在链表中找到合适的位置插入新的数<br>据。如果定义两个指针指向链表的中间结点（如果链表的结点数目是奇数，那么这两个指针指向<br>同一个结点），那么可以在 O（1）时间得出中位数。此时时间效率与及基于排序的数组的时间<br>效率一样。<br>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有<br>排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大<br>NOWCODER.COM<br>数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆<br>中找出最小数。<br>因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右<br>边的数据容器。往堆中插入一个数据的时间效率是 O(logn)。由于只需 O(1)时间就可以得到位<br>于堆顶的数据，因此得到中位数的时间效率是 O(1)。<br>3、堆排序的原理是什么？<br>考察点：堆排序<br>参考回答：<br>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大<br>数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：<br>（1）最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。<br>（2）创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆。<br>（3）堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算<br>4、归并排序的原理是什么？<br>考察点：归并排序<br>参考回答：<br>（1）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and<br>Conquer）的一个非常典型的应用。<br>（2）首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个<br>数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那<br>直接将另一个数列的数据依次取出即可。<br>（3）解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组<br>A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让<br>这二组组内数据有序了？<br>NOWCODER.COM<br>可以将 A，B 组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这<br>个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，<br>再合并数列就完成了归并排序。<br>5、排序都有哪几种方法？请列举出来。<br>考察点：排序<br>参考回答：<br>排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），<br>选择排序（直接选择排序、堆排序），<br>归并排序，分配排序（箱排序、基数排序）<br>快速排序的伪代码。<br>&#x2F; &#x2F;使用快速排序方法对 a[ 0 :n- 1 ]排序<br>从 a[ 0 :n- 1 ]中选择一个元素作为 m i d d l e，该元素为支点<br>把余下的元素分割为两段 left 和 r i g h t，使得 l e f t 中的元素都小于等于支点，而 right<br>中的元素都大于等于支点<br>递归地使用快速排序方法对 left 进行排序<br>递归地使用快速排序方法对 right 进行排序<br>所得结果为 l e f t + m i d d l e + r i g h t<br>7、堆与栈<br>1、堆与栈的不同是什么？<br>考察点：堆，栈<br>参考回答：<br>（1）Java 的堆是一个运行时数据区，类的对象从中分配空间。通过比如：new 等指令建立，<br>不需要代码显式的释放，由垃圾回收来负责。<br>优点：可以动态地分配内存大小，垃圾收集器会自动回收垃圾数据。<br>缺点：由于其优点，所以存取速度较慢。<br>（2）栈：<br>其数据项的插入和删除都只能在称为栈顶的一端完成，后进先出。栈中存放一些基本类型的<br>变量 和 对象句柄。<br>优点：读取数度比堆要快，仅次于寄存器，栈数据可以共享。<br>NOWCODER.COM<br>缺点：比堆缺乏灵活性，存在栈中的数据大小与生存期必须是确定的。<br>举例：<br>String 是一个特殊的包装类数据。可以用：<br>String str &#x3D; new String(“csdn”);<br>String str &#x3D; “csdn”;<br>两种的形式来创建，第一种是用 new()来新建对象的，它会在存放于堆中。每调用一次就会<br>创建一个新的对象。而第二种是先在栈中创建一个对 String 类的对象引用变量 str，然后查找<br>栈中有没有存放”csdn”，如果没有，则将”csdn”存放进栈，并令 str 指向”abc”，如果已经<br>有”csdn” 则直接令 str 指向“csdn”。<br>2、heap 和 stack 有什么区别。<br>考察点：堆与栈<br>参考回答：<br>栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。<br>堆是栈的一个组成元素。<br>3、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。<br>考察点：堆栈<br>参考回答：<br>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都<br>使用内存中的栈空间；而通过 new 关键字和构造器创建的对象放在堆空间；程序中的字面量<br>（literal）如直接书写的 100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈<br>很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上<br>的虚拟内存都可以被当成堆空间来使用。<br>String str &#x3D; new String(“hello”);<br>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面<br>量放在静态区。<br>8、队列<br>1、什么是 Java 优先级队列(Priority Queue)？<br>考察点：队列<br>参考回答：<br>PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)<br>排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue 不允<br>NOWCODER.COM<br>许 null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，<br>PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n))。<br>2、id 全局唯一且自增，如何实现？<br>考察点：SnowFlake 雪花算法<br>参考回答；<br>SnowFlake 雪花算法<br>雪花 ID 生成的是一个 64 位的二进制正整数，然后转换成 10 进制的数。64 位二进制数由如<br>下部分组成：<br>snowflake id 生成规则<br>1 位标识符：始终是 0，由于 long 基本类型在 Java 中是带符号的，最高位是符号位，正数<br>是 0，负数是 1，所以 id 一般是正数，最高位是 0。<br>41 位时间戳：41 位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间<br>截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的 id 生成器开始使用的时间，<br>由我们程序来指定的。<br>10 位机器标识码：可以部署在 1024 个节点，如果机器分机房（IDC）部署，这 10 位可以由<br>5 位机房 ID + 5 位机器 ID 组成。<br>NOWCODER.COM<br>12 位序列：毫秒内的计数，12 位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)<br>产生 4096 个 ID 序号<br>优点<br>简单高效，生成速度快。<br>时间戳在高位，自增序列在低位，整个 ID 是趋势递增的，按照时间有序递增。<br>灵活度高，可以根据业务需求，调整 bit 位的划分，满足不同的需求。<br>缺点<br>依赖机器的时钟，如果服务器时钟回拨，会导致重复 ID 生成。<br>在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况。<br>3、如何设计算法压缩一段 URL？<br>考察点：MD5 加密算法<br>参考回答：<br>该算法主要使用 MD5 算法对原始链接进行加密（这里使用的 MD5 加密后的字符串长度为 32<br>位），然后对加密后的字符串进行处理以得到短链接的地址。<br>4、为什么要设计后缀表达式，有什么好处？<br>考察点：逆波兰表达式<br>参考回答：<br>后缀表达式又叫逆波兰表达式，逆波兰记法不需要括号来标识操作符的优先级。<br>5、LRU 算法的实现原理？<br>考察点：LRU 算法<br>参考回答：<br>①LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数<br>据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也很高”，反过来说“如果<br>数据最近这段时间一直都没有访问,那么将来被访问的概率也会很低”，两种理解是一样的；常<br>用于页面置换算法，为虚拟页式存储管理服务。<br>②达到这样一种情形的算法是最理想的：每次调换出的页面是所有内存页面中最迟将被使用<br>的；这可以最大限度的推迟页面调换，这种算法，被称为理想页面置换算法。可惜的是，这种算<br>法是无法实现的。<br>为了尽量减少与理想算法的差距，产生了各种精妙的算法，最近最少使用页面置换算法便是其中<br>一个。LRU 算法的提出，是基于这样一个事实：在前面几条指令中使用频繁的页面很可能在后面<br>的几条指令中频繁使用。反过来说，已经很久没有使用的页面很可能在未来较长的一段时间内不<br>NOWCODER.COM<br>会被用到 。这个，就是著名的局部性原理——比内存速度还要快的 cache，也是基于同样的原<br>理运行的。因此，我们只需要在每次调换时，找到最近最少使用的那个页面调出内存。<br>算法实现的关键<br>命中率：<br>当存在热点数据时，LRU 的效率很好，但偶发性的、周期性的批量操作会导致 LRU 命中率急剧<br>下降，缓存污染情况比较严重。<br>复杂度：<br>实现起来较为简单。<br>存储成本：<br>几乎没有空间上浪费。<br>代价：<br>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。 九、设计模式<br>1、结构型模式<br>①代理模式<br>1、java 中有哪些代理模式？<br>考察点：代理模式<br>参考回答：<br>静态代理，动态代理，Cglib 代理。<br>2、如何实现动态代理<br>考察点：动态代理流程<br>参考回答：<br>Java 实现动态代理的大致步骤如下：<br>1.定义一个委托类和公共接口。<br>2.自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是<br>指定运行时将生成的代理类需要完成的具体任务（包括 Preprocess 和 Postprocess），即代理<br>类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。<br>3.生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口<br>(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器<br>实例。<br>4.Java 实现动态代理主要涉及以下几个类：<br>NOWCODER.COM<br>①java.lang.reflect.Proxy: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承<br>了 Proxy 类，即 DynamicProxyClass extends Proxy。<br>②java.lang.reflect.InvocationHandler: 这里称他为”调用处理器”，他是一个接口，我<br>们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现<br>InvocationHandler 接口。<br>示例代码：<br>public final class <code>$Proxy1 extends Proxy implements Subject&#123; private InvocationHandler h; private $</code>Proxy1(){}<br>public $Proxy1(InvocationHandler h){<br>this.h &#x3D; h; }<br>public int request(int i){<br>Method method &#x3D; Subject.class.getMethod(“request”, new Class[]{int.class}); &#x2F;&#x2F;<br>创建 method 对象<br>return (Integer)h.invoke(this, method, new Object[]{new Integer(i)}); &#x2F;&#x2F;调用了<br>invoke 方法 } }<br>②适配器模式<br>1、IO 流熟悉吗，用的什么设计模式？<br>考察点：装饰模式，适配器模式<br>参考回答：<br>装饰模式和适配器模式<br>2、创建型模式<br>①单例模式<br>1、介绍一下单例模式？懒汉式的单例模式如何实现单例？<br>考察点：单例模式<br>参考回答：<br>NOWCODER.COM<br>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。优点：单例类只有一个<br>实例、共享资源，全局使用节省创建时间，提高性能。可以用静态内部实现，保证是懒加载就行<br>了，就是使用才会创建实例对象。<br>3、行为型模式<br>①策略模式<br>1、介绍一下策略模式？<br>考察点：策略模式<br>参考回答：<br>策略模式也叫政策模式，是一种行为型设计模式，是一种比较简单的设计模式。策略模式<br>采用了面向对象的继承和多态机制。略模式适合使用在：1.多个类只有在算法或行为上稍有不同<br>的场景。2.算法需要自由切换的场景。3.需要屏蔽算法规则的场景。 使用策略模式当然也有需<br>要注意的地方，那么就是策略类不要太多，如果一个策略家族的具体策略数量超过 4 个，则需要<br>考虑混合模式，解决策略类膨胀和对外暴露问题。在实际项目中，我们一般通过工厂方法模式来<br>实现策略类的声明。<br>优点：算法可以自由切换。2.避免使用多重条件判断。3.扩展性良好。 ②观察者模式<br>1、设计模式了解哪些，手写一下观察者模式？<br>考察点：观察者模式<br>参考回答：<br>NOWCODER.COM<br>观察者模式优点：<br>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个<br>具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个<br>具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，<br>因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然<br>跨越抽象化和具体化层次。<br>观察者模式缺点：<br>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费<br>很多时间。<br>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩<br>溃。在使用观察者模式是要特别注意这一点。<br>如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方<br>式进行的。<br>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应<br>的机制使观察者知道所观察的对象是怎么发生变化的。<br>4、模式汇总<br>1、说说你所熟悉或听说过的 j2ee 中的几种常用模式?及对设计模式的一些看法<br>考察点：J2EE 设计模式<br>参考回答：<br>Session Facade Pattern：使用 SessionBean 访问 EntityBean Message Facade Pattern：<br>实现异步调用 EJB Command Pattern：使用 Command JavaBeans 取代 SessionBean，实现轻量级<br>访问 Data Transfer Object Factory：通过 DTO Factory 简化 EntityBean 数据提供特性 Generic<br>Attribute Access：通过 AttibuteAccess 接口简化 EntityBean 数据提供特性 Business<br>NOWCODER.COM<br>Interface：通过远程（本地）接口和 Bean 类实现相同接口规范业务逻辑一致性ＥＪＢ架构的设<br>计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率。项目越复杂，<br>项目队伍越庞大则越能体现良好设计的重要性。<br>2、j2ee 常用的设计模式？说明工厂模式。<br>考察点：j2ee 设计模式<br>参考回答：<br>Java 中的 23 种设计模式：<br>Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），Prototype<br>（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式），<br>Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元<br>模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor<br>（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），<br>Observer（观察者模式）， State（状态模式）， Strategy（策略模式），Template Method<br>（模板方法模式）， Chain Of Responsibleity（责任链模式）工厂模式：工厂模式是一种经常<br>被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通<br>常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了<br>不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需<br>要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员<br>可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。<br>3、开发中都用到了那些设计模式?用在什么场合?<br>考察点：设计模式<br>参考回答：<br>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核<br>心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用<br>到了 MVC 的设计模式。用来开发 JSP&#x2F;Servlet 或者 J2EE 的相关应用。简单工厂模式等。<br>4、简述一下你了解的 Java 设计模式<br>考察点：设计模式<br>参考回答：<br>所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一<br>个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。<br>设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模<br>式也会使新系统开发者更加容易理解其设计思路。<br>在 GoF 的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三<br>类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的<br>结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：<br>Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模<br>式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter<br>（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight<br>（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor<br>（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），<br>NOWCODER.COM<br>Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模<br>板方法模式）， Chain Of Responsibility（责任链模式）。 十、场景题<br>1、情景题：如果一个外卖配送单子要发布，现在有 200 个骑手都想要接这一单，如何保证只有<br>一个骑手接到单子？<br>2、场景题：美团首页每天会从 10000 个商家里面推荐 50 个商家置顶，每个商家有一个权值，你<br>如何来推荐？第二天怎么更新推荐的商家？<br>可以借鉴下 stackoverflow，视频网站等等的推荐算法。<br>3、场景题：微信抢红包问题<br>悲观锁，乐观锁，存储过程放在 mysql 数据库中。<br>4、场景题：1000 个任务，分给 10 个人做，你怎么分配，先在纸上写个最简单的版本，然后优<br>化。<br>全局队列，把 1000 任务放在一个队列里面，然后每个人都是取，完成任务。<br>分为 10 个队列，每个人分别到自己对应的队列中去取务。<br>5、场景题：保证发送消息的有序性，消息处理的有序性。<br>6、如何把一个文件快速下发到 100w 个服务器<br>7、给每个组分配不同的 IP 段，怎么设计一种结构使的快速得知 IP 是哪个组的?<br>8、10 亿个数，找出最大的 10 个。<br>建议一个大小为 10 的小根堆。<br>9、有几台机器存储着几亿淘宝搜索日志，你只有一台 2g 的电脑，怎么选出搜索热度最高的十个<br>搜索关键词？<br>10、分布式集群中如何保证线程安全？<br>11、给个淘宝场景，怎么设计一消息队列？<br>12、10 万个数，输出从小到大？<br>先划分成多个小文件，送进内存排序，然后再采用多路归并排序。<br>13、有十万个单词，找出重复次数最高十个？<br>十二、惊喜福利<br>此面试题库将根据当下面试形式大数据随时更新，如果你已获得下载权限，那么你可以终身<br>在牛币兑换中心里去兑换此面试题库的电子版，如果电子版有更新，会通过牛客站内信进行<br>通知（前提是你已获得下载权限）。<br>b.14. ⽹络相关：<br>a. tcp三次握⼿、四次挥⼿<br>b. http机制<br>c. https机制15. 项⽬亮点：16. 画架构图：17. 平时看过什么书？18. 接⼝与抽象类区别<br>1、⼀个类声明可否既是abstract的,⼜是final的? 不能,这两个修式符⽭盾（abstract就是要被继承）<br>2、抽象类不⼀定包含抽象⽅法<br>3、有抽象⽅法,则⼀定是抽象类<br>4、抽象类不能被实例化，⼀般⽤作基类使⽤；<br>a. 类可以实现多个接⼝但只能继承⼀个抽象类<br>b. 接⼝⾥⾯所有的⽅法都是Public的，抽象类允许Private、Protected⽅法<br>c. JDK8前接⼝⾥⾯所有的⽅法都是抽象的且不允许有静态⽅法，抽象类可以有普通、静态⽅法，JDK8 接⼝可以实现默认⽅法<br>和静态⽅法，前⾯加default、static关键字。19. java中的异常有哪⼏类，分别怎么使⽤？<br>分为错误和异常，异常⼜包括运⾏时异常、⾮运⾏时异常<br>a. 错误，如StackOverflowError、OutOfMemoryError<br>b. 异常：<br>i. 运⾏时异常，如NullPointerException、IndexOutOfBoundsException，都是RuntimeException及其⼦类<br>ii. ⾮运⾏时异常，如IOException、SQLException,都是Exception及其⼦类，这些异常是⼀定需要try catch捕获的20. 常⽤的集合类有哪些？⽐如list如何排序？<br>主要分为三类，Map、Set、List<br>a. Map: HashMap、LinkedHashMap、TreeMap<br>b. Set：HashSet、LinkedHashSet、TreeSet<br>c. List: ArrayList、LinkedList<br>1 Collections.sort(list);21. ArrayList和LinkedList内部实现⼤致是怎样的？他们之间的区别和优缺点？<br>a. ArrayList：内部使⽤数组的形式实现了存储，利⽤数组的下标进⾏元素的访问，因此对元素的随机访问速度⾮常快。因为是<br>数组，所以ArrayList在初始化的时候，有初始⼤⼩10，插⼊新元素的时候，会判断是否需要扩容，扩容的步⻓是0.5倍原容量，<br>扩容⽅式是利⽤数组的复制，因此有⼀定的开销。<br>b. LinkedList：内部使⽤双向链表的结构实现存储，LinkedList有⼀个内部类作为存放元素的单元，⾥⾯有三个属性，⽤来存放<br>元素本身以及前后2个单元的引⽤，另外LinkedList内部还有⼀个header属性，⽤来标识起始位置，LinkedList的第⼀个单元和<br>最后⼀个单元都会指向header，因此形成了⼀个双向的链表结构。<br>c. ArrayList查找较快，插⼊、删除较慢，LinkedList查找较慢，插⼊、删除较快。22. 内存溢出是怎么回事？举个例⼦。<br>a. 内存溢出 out of memory，是指程序在申请内存时，没有⾜够的内存空间供其使⽤，出现out of memory。<br>1 List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();<br>2 while (true) {<br>3 list.add(new Object());<br>4 }<br>b. 内存溢出可能的原因：<br>i. 程序中存在死循环<br>ii. 静态变量和静态⽅法太多了<br>iii. 内存泄漏：⽐如说⼀个静态的list，⼀直往⾥放值，⼜因为静态变量不会被释放，所以迟早是要内存溢出的<br>iv. ⼤对象过多：java中的⼤对象是直接进⼊⽼年代的，然后当多个⼤对象同时⼯作时造成程序的可⽤内存⾮常⼩，⽐如我<br>list中原本最多可以放1000个对象，因为可⽤内存太⼩，放了500个就放不下了。<br>v. 程序分配内存过⼩：还有⼀种很常⻅的情况，在把⼀个很⼤的程序直接导⼊，直接就内存溢出了，原因就是内存相对这<br>个程序就是太⼩了，需要⼿动增加内存。<br>c. 内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄漏堆<br>积后果很严重，⽆论多少内存,迟早会被占光。23. &#x3D;&#x3D;和equals的区别<br>&#x3D;&#x3D;是运算符，⽽equals是Object的基本⽅法，&#x3D;&#x3D;⽤于基本类型的数据的⽐较，或者是⽐较两个对象的引⽤是否相同，equals⽤<br>于⽐较两个对象的值是否相等，例如字符串的⽐较。24. hashCode⽅法的作⽤<br>1、hashCode的存在主要是⽤于查找的快捷性，为了配合基于散列的集合正常运⾏，如Hashtable，HashMap等，hashCode是<br>⽤来在散列存储结构中确定对象的存储地址的；<br>2、如果两个对象相同，就是适⽤于equals(java.lang.Object) ⽅法，那么这两个对象的hashCode⼀定要相同；<br>3、如果对象的equals⽅法被重写，那么对象的hashCode也尽量重写，并且产⽣hashCode使⽤的对象，⼀定要和equals⽅法中<br>使⽤的⼀致，否则就会违反上⾯提到的第2点；<br>4、两个对象的hashCode相同，并不⼀定表示两个对象就相同，也就是不⼀定适⽤于equals(java.lang.Object) ⽅法，只能够说<br>明这两个对象在散列存储结构中，它们存放在同⼀个桶⾥⾯。25. NIO是什么？适⽤于何种场景？<br>a. NIO是为了弥补IO操作的不⾜⽽诞⽣的，NIO的⼀些新特性有：⾮阻塞I&#x2F;O，选择器，缓冲以及管道。<br>b. 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候⽤NIO处理数据可<br>能是个很好的选择。(适⽤于⼩数据多连接)<br>c. ⽽如果只有少量的连接，⽽这些连接每次要发送⼤量的数据，这时候传统的IO更合适。使⽤哪种处理数据，需要在数据的响<br>应等待时间和检查缓冲区数据的时间上作⽐较来权衡选择。<br>d. NIO：<br>i. 概念：NIO(new IO)，是⼀种⾮阻塞式I&#x2F;O；java NIO采⽤了双向通道进⾏数据传输，在通道上我们可以注册我们感兴趣的<br>事件：连接事件、读写事件；NIO主要有三⼤核⼼部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)。传统IO基于字<br>节流和字符流进⾏操作，⽽NIO基于Channel和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区<br>写⼊到通道中。Selector(选择区)⽤于监听多个通道的事件（⽐如：连接打开，数据到达）。因此，单个线程可以监听多个<br>数据通道。<br>ii. 原理：26. 由⼀个专⻔的线程来处理所有的 IO 事件，并负责分发。27. 事件驱动机制：事件到的时候触发，⽽不是同步的去监视事件。28. 线程通讯：线程之间通过 wait,notify 等⽅式通讯。保证每次上下⽂切换都是有意义的。减少⽆谓的线程切换。29. Hashmap实现原理？如何保证HashMap线程安全？<br>a. HashMap简单说就是它根据键的hashCode值存储数据，⼤多数情况下可以直接定位到它的值，因⽽具有很快的访问速度，<br>但遍历顺序却是不确定的。<br>b. HashMap基于哈希表，底层结构由数组来实现，添加到集合中的元素以“key–value”形式保存到数组中，在数组中key–<br>value被包装成⼀个实体来处理—也就是上⾯Map接⼝中的Entry。<br>c. 在HashMap中，Entry[]保存了集合中所有的键值对，当我们需要快速存储、获取、删除集合中的元素时，HashMap会根据<br>hash算法来获得“键值对”在数组中存在的位置，以来实现对应的操作⽅法。<br>d. HashMap底层是采⽤数组来维护的.Entry静态内部类的数组<br>1 &#x2F;**<br>2 * The table, resized as necessary. Length MUST Always be a power of two.<br>3 *&#x2F;<br>4 transient Entry[] table;<br>5<br>6 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>7 final K key;<br>8 V value;<br>9 Entry&lt;K,V&gt; next;<br>10 final int hash;<br>11 ……<br>12 }<br>c. HashMap添加元素：将准备增加到map中的对象与该位置上的对象进⾏⽐较(equals⽅法),如果相同,那么就将该位置上的那<br>个对象(Entry类型)的value值替换掉,否则沿着该Entry的链继续重复上述过程,如果到链的最后任然没有找到与此对象相同的对象,那么这个<br>时候就会被增加到数组中,将数组中该位置上的那个Entry对象链到该对象的后⾯(先hashcode计算位置，如果找到相同位置便替换值，找<br>不到则重复hashcode计算，直到最后在添加到hashmap最后⾯；)<br>d. HashMap是基于哈希表的Map接⼝的⾮同步实现，允许null键值，但不保证映射的顺序；底层使⽤数组实现，数组中的每项<br>是⼀个链表；存储时根据key的hash算法来决定其存储位置；数组扩容需要重新计算扩容后每个元素在数组中的位置很耗性能；<br>e. ConcurrentHashMap是HashMap的线程安全实现，允许多个修改操作同时进⾏(使⽤了锁分离技术)，它使⽤了多个锁来控制<br>对hash表的不同段进⾏的修改，每个段其实就是⼀个⼩的hashtable，它们有⾃⼰的锁。使⽤了多个⼦hash表(段Segment)，允<br>许多个读操作并发进⾏，读操作并不需要锁，因为它的HashEntry⼏乎是不可变的：30. jvm内存结构？为什么需要GC？<br>a. 内存结构：<br>b. 垃圾回收：垃圾回收可以有效的防⽌内存泄漏，有效的使⽤可以使⽤的内存。垃圾回收器通常是作为⼀个单独的低优先级的<br>线程运⾏，不可预知的情况下对内存堆中已经死亡的或者⻓时间没有使⽤的对象进⾏清除和回收，程序员不能实时的调⽤垃圾<br>回收器对某个对象或所有对象进⾏垃圾回收。回收机制有分代复制垃圾回收、标记垃圾回收、增量垃圾回收等⽅式。31. NIO模型，select&#x2F;epoll的区别，多路复⽤的原理？<br>1、io多路复⽤：<br>1、概念：IO多路复⽤是指内核⼀旦发现进程指定的⼀个或者多个IO条件准备读取，它就通知该进程。<br>2、优势：与多进程和多线程技术相⽐，I&#x2F;O多路复⽤技术的最⼤优势是系统开销⼩，系统不必创建进程&#x2F;线程，也不必维护<br>这些进程&#x2F;线程，从⽽⼤⼤减⼩了系统的开销。<br>3、系统：⽬前⽀持I&#x2F;O多路复⽤的系统调⽤有 select，pselect，poll，epoll。<br>2、select：select⽬前⼏乎在所有的平台上⽀持，其良好跨平台⽀持也是它的⼀个优点。select的⼀个缺点在于单个进程能够<br>监视的⽂件描述符的数量存在最⼤限制，在Linux上⼀般为1024，可以通过修改宏定义甚⾄重新编译内核的⽅式提升这⼀限制，<br>但是这样也会造成效率的降低。<br>3、poll：它没有最⼤连接数的限制，原因是它是基于链表来存储的，但是同样有⼀个缺点：<br>a. ⼤量的fd的数组被整体复制于⽤户态和内核地址空间之间，⽽不管这样的复制是不是有意义。<br>b. poll还有⼀个特点是“⽔平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<br>epoll跟select都能提供多路I&#x2F;O复⽤的解决⽅案。在现在的Linux内核⾥有都能够⽀持，其中epoll是Linux所特有，⽽select则应该是<br>POSIX所规定，⼀般操作系统均有实现。32. java中⼀个字符占多少个字节？int，long，double占多少个字节？<br>a. 1字节： byte , boolean<br>b. 2字节： short , char<br>c. 4字节： int , float<br>d. 8字节： long , double33. 创建⼀个类的实例都有哪些⽅法？<br>1 Object o &#x3D; new Object();<br>2 Object o &#x3D; oo.clone();<br>3 Object o &#x3D; Class.forName(“xxx”).newInstance();34. final&#x2F;finaly&#x2F;finalize区别？<br>a. final是定义类、⽅法、字段的修饰符，表示类不可被继承，⽅法不能被重写，字段值不能被修改<br>b. finally是异常处理机制的关键字，表示最后执⾏<br>c. finalize是Object的⼀个⽅法，在对象被虚拟机回收时会判断是否执⾏该⽅法，当对象没有覆盖finalize⽅法，或者finalize⽅法<br>已经被虚拟机调⽤过，虚拟机将这两种情况都视为“没有必要执⾏”35. Session&#x2F;Cookie区别？<br>Session存储在服务器端，类型可以是任意的Java对象，Cookie存储在客户端，类型只能为字符串36. String&#x2F;StringBuffer&#x2F;StringBuilder的区别以及实现？<br>a. String、StringBuffer是线程安全的，StringBuilder不是<br>b. String不继承任何类，StringBuffer、StringBuilder继承⾃AbstractStringBuilder<br>StringBuffer线程安全但效率低，应该使⽤在多线程情况下；<br>StringBuilder线程不安全，在单线程情况下效率⾼；37. Servlet⽣命周期<br>a. Servlet⽣命周期分为三个阶段：<br>1、初始化阶段 调⽤init()⽅法<br>　　2、响应客户请求阶段　　调⽤service()⽅法<br>　　3、终⽌阶段　　调⽤destroy()⽅法38. 如何⽤java分配⼀段连续的1G的内存空间?需要注意些什么？<br>1 ByteBuffer.allocateDirect(1024<em>1024</em>1024);<br>要注意内存溢出问题。39. Java有⾃⼰的内存回收机制，但为什么还存在内存泄漏的问题呢？<br>a. ⾸先内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄<br>漏堆积后果很严重，⽆论多少内存,迟早会被占光。<br>b. ⽐如下⾯这段代码，list持有o的引⽤，o暂时是⽆法被JVM垃圾回收的，只有当list被垃圾回收或者o从对象list删除掉后，o才<br>能被JVM垃圾回收。<br>1 List list &#x3D; new ArrayList();<br>2 Object o &#x3D; new Object();<br>3 list.add(o);<br>4 o &#x3D; null;<br>41. String s &#x3D; new String(“abc”)创建了⼏个String Object？<br>1、2个，会创建String对象在常量池和堆中。<br>2、String中的intern(),⾸先检查String pool是否有对应的字符串对象,如果有则返回，如果没有则在String pool中⽣成字符串，<br>并返回地址；<br>3.String中字⾯值”ab”之间拼接是在String pool中产⽣,⽽字⾯值与变量拼接字符串或者new String(“”)则是在堆中产⽣对象;42. 静态对象：<br>1.在main⽅法开始运⾏时需要注意static的先后顺序：静态变量和静态代码块(按代码先后顺序)—-匿名块和成员变量(按代码先<br>后顺序)—-构造函数—静态⽅法(调⽤时加载)<br>2.先执⾏⽗类的静态块,再执⾏⼦类的静态块,再执⾏⽗类的构造⽅法,再执⾏⼦类的构造⽅法<br>1、静态块&gt;构造⽅法；<br>2、⽗&gt;⼦43. final关键字：<br>1、⽤在类上不能被继承，abstract(需要被继承)和final不能共存；<br>2、⽤在⽅法上不能被重写<br>3、⽤在变量上表示⽅变量不能被改变<br>--对于final类的成员变量的初使化⽅式(基本数据类型)<br>1.申明变量时直接赋值<br>2.在构造⽅法中完成赋值,如果有多个构造⽅法,则每个都要完成final类变量的赋值<br>3.如果⼀个变量为static final则只能在申明时赋值<br>--对于final类型的引⽤变量来说,所谓的不能改变指的是该引⽤不能改变,值是可以改变的（如StringBuffer）<br>--为什么⼀般在public类final终态成员变量申明时要加static?<br>static对象存放在静态空间，不会在运⾏时被释放，可以节省内存，类的多个对象同时引⽤只有⼀份,没有多份拷⻉44. HashMap与HashTable的区别：<br>1.线程安全上,hashtable是同步的线程安全；hashmap是⾮同步的线程不安全，可接受null的值和value（hashtable不允许）；<br>2.对单线程来说,hashTable效率低<br>3、线程安全的类：vector(⽐arrayList多了同步机制，效率低不建议使⽤)、stack(堆栈类，先进后出)、hashtable(⽐hashmap<br>多了同步机制)、enumeration(枚举类)45. 多态：<br>1、多态条件：1.有继承 2. 有重写 3. 要有⽗类引⽤指向⼦类对象；如Animal a &#x3D; new Tiger();46. ⽗类或者接⼝引⽤指向⼦类或者实现该接⼝的类的对象；47. 多态是运⾏时⾏为,不是编绎时⾏为；48. 多态要有动态绑定，通过⽅法重写与⽅法重载来实现多态?? 这种说法是错误，因为⽅法重载是编译期决定好的,没有后期也就<br>是运⾏期的动态绑定；49. 集合删除：<br>注意: List底层为数组,删除时数组元素下标会被改变50. 跌代器调⽤.next()⽅法时,会检测是否有被修改过51. 如果要删除集合中的元素⼀定要⽤跌代器的remove()⽅法.52. 参数传递与引⽤传递：<br>1.基本数据类型传参,是数据值的拷⻉互不影响.<br>2.引⽤对象传参,是传地址,两个引⽤指向同⼀个对象,则对象改变两个引⽤也都改变(java编程只有值传递参数)53. hash冲突：<br>1、描述：当关键字值域远⼤于哈希表的⻓度，⽽且事先并不知道关键字的具体取值时，冲突就难免会发⽣。（两个或两个以上<br>的值hash计算的结果有相同的，造成冲突）<br>2、解决⽅法：<br>1、开放地址法：插⼊元素时，如果发⽣冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下⼀个空<br>槽，并将该元素放⼊该槽中（会导致相同hash值的元素挨在⼀起和其他hash值对应的槽被占⽤）。查找元素时，⾸先散列值所<br>指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到⼀个空槽，指示查找的元<br>素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）<br>2、链地址法：现⾏探测法的基本思想是将所有哈希地址为i的元素构成⼀个称为同义词链的单链表，并将单链表的头指针<br>存在哈希表的第i个单元中，因⽽查找、插⼊和删除主要在同义词链中进⾏。链地址法适⽤于经常进⾏插⼊和删除的情况。<br>3、在散列(双&#x2F;多重散列)：当发⽣冲突时，使⽤第⼆个、第三个、哈希函数计算地址，直到⽆冲突时。缺点：计算时间增<br>加。<br>4、建⽴⼀个公共溢出区：假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设⽴存储空间向量<br>OverTable[0..v]⽤以存储发⽣冲突的记录。54. 在java中⼀个字符能否表示⼀个汉字：<br>在java中,⼀个字符表示16位,相当于2个字节,⼀个汉字正好是2个字节55. ⼀致性hash：<br>1、⼀致性hash算法：我们的memcached客户端（这⾥我看的spymemcache的源码），使⽤了⼀致性hash算法ketama进⾏数据存储节点<br>的选择。与常规的hash算法思路不同，只是对我们要存储数据的key进⾏hash计算，分配到不同节点存储。⼀致性hash算法是对我们要存储数<br>据的服务器进⾏hash计算，进⽽确认每个key的存储位置。这⾥提到的⼀致性hash算法ketama的做法是：选择具体的机器节点不在只依赖需要<br>缓存数据的key的hash本身了，⽽是机器节点本身也进⾏了hash运算。<br>1、⼀致性hash算法是分布式系统中常⽤算法，设计⽬的是为了解决因特⽹中的热点(hot spot)问题。解决了P2P环境最为关键问<br>题—如何在动态⽹络拓扑中分布存储和路由；<br>2、⼀致性hash算法引⼊虚拟节点机制，解决服务节点少时数据倾斜问题(即对每⼀个服务节点计算多个哈希，每个计算结果位置都<br>放置⼀个此服务节点，称为虚拟节点。)；<br>2、具体做法：如果有⼀个写⼊缓存的请求，其中Key值为K，计算器hash值Hash(K)， Hash(K) 对应于图 – 1环中的某⼀个点，如果<br>该点对应没有映射到具体的某⼀个机器节点，那么顺时针查找，直到第⼀次找到有映射机器的节点，该节点就是确定的⽬标节点，如果超过了<br>2^32仍然找不到节点，则命中第⼀个机器节点。⽐如 Hash(K) 的值介于A~B之间，那么命中的机器节点应该是B节点（如上图 ）。<br>3、数据保存流程：<br>1、⾸先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。<br>2、然后采⽤同样的⽅法求出存储数据的键的哈希值，并映射到相同的圆上。<br>3、然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第⼀个服务器上。如果超过232仍然找不到服务器，就会保存到第<br>⼀台memcached服务器上。56. java反射机制<br>可以在运⾏时判断⼀个对象所属的类，构造⼀个类的对象，判断类具有的成员变量和⽅法，调⽤1个对象的⽅法。<br>4个关键的类：Class，Constructor，Field，Method。 getConstructor获得构造函数&#x2F;getDeclardConstructor；<br>getField&#x2F;getFields&#x2F;getDeclardFields获得类所⽣命的所有字段；getMethod&#x2F;getMethods&#x2F;getDeclardMethod获得类声明的所有⽅法，正<br>常⽅法是⼀个类创建对象，⽽反射是1个对象找到1个类。57. 幂等的处理⽅式：<br>接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。<br>⼀、查询操作是天然幂等<br>⼆、唯⼀索引，防⽌新增脏数据<br>三、token机制，防⽌⻚⾯重复提交<br>四、悲观锁 for update<br>五、乐观锁（通过版本号&#x2F;时间戳实现， 通过条件限制where avai_amount-#subAmount# &gt;&#x3D; 0）<br>六、分布式锁<br>七、状态机幂等（如果状态机已经处于下⼀个状态，这时候来了⼀个上⼀个状态的变更，理论上是不能够变更的，这样的话，保证<br>了有限状态机的幂等。）58. hashmap在jdk1.8中的改动?59. Jdk1.8以前是进⾏四次扰动计算，可能从速度功效各⽅⾯考虑，jdk1.8变成扰动⼀次，低16位和⾼16位进⾏异或计算。取模的时<br>候考虑取模运算的速度⽐较慢，改⽤与操作优化效率，很巧妙，hash table就没设计的这么好。60. JDK1.8⾥对hashmap最⼤的改变是引⼊了红⿊树，这⼀点在hash不均匀并且元素个数很多的情况时，对hashmap的性能提升⾮<br>常⼤。Hashmap的底层实现是使⽤⼀个entry数组存储，默认初始⼤⼩16，不过jdk8换了名字叫node，可能是因为引⼊了树，叫<br>node更合适吧，另外我也不喜欢entry这个名字，不能望⽂⽣义，我在刚学的时候还以为是什么神秘的东⻄呢，其实就是个键值对对<br>象⽽已。Node⾥有next引⽤指向下⼀个节点，因为hashmap解决冲突的思路是拉链法。61. 另外变化⽐较⼤的还有扩容机制，也就是resize⽅法。62. java 8 流式使⽤：<br>1 List&lt;Integer&gt; evens &#x3D; nums.stream().filter(num -&gt; num % 2 &#x3D;&#x3D; 0).collect(Collectors.toList());<br>2 &#x2F;&#x2F;1、stream()操作将集合转换成⼀个流，<br>3 &#x2F;&#x2F;2、filter()执⾏我们⾃定义的筛选处理，这⾥是通过lambda表达式筛选出所有偶数，<br>4 &#x2F;&#x2F;3、最后我们通过collect()对结果进⾏封装处理，并通过Collectors.toList()指定其封装成为⼀个List集合返回。63. java域的概念：<br>field，域是⼀种属性，可以是⼀个类变量，⼀个对象变量，⼀个对象⽅法变量或者是⼀个函数的参数。64. jdk1.8中ConcurrentHashMap size⼤于8时会转化成红⿊树，请问有什么作⽤，如果通过remove操作，size⼩于8了，会发⽣什<br>么？<br>put时如果链表size&gt;&#x3D;8并且table.length&gt;&#x3D;64，这时链表会转变成⼀个红⿊树（红⿊树是⼀个⾃平衡的⼆叉查找树，查找效率会从<br>链表的o(n)降低为o(logn)，效率是⾮常⼤的提⾼），但是remove不会逆转。65. 描述⼀下Hibernate的三个状态？<br>a. transient(瞬时状态)：new出来⼀个对象，还没被保存到数据库中<br>b. persistent(持久化状态)：对象已经保存到数据库中并且在hibernate session也存在该对象<br>c. detached(离线状态)：对象在数据库中存在，hibernate session不存在66. struts⼯作流程<br>1、客户端浏览器发出HTTP请求。<br>2、根据web.xml配置，该请求被FilterDispatcher接收。<br>3、根据struts.xml配置，找到需要调⽤的Action类和⽅法， 并通过IoC⽅式，将值注⼊给Aciton。<br>4、Action调⽤业务逻辑组件处理业务逻辑，这⼀步包含表单验证。<br>5、Action执⾏完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应⻚⾯。<br>6、返回HTTP响应到客户端浏览器。67. Hibernate对⼀⼆级缓存的使⽤， Lazy-Load的理解;<br>a. ⼀级缓存：hibernate的⼀级缓存是由session提供的，因此它只存在session的⽣命周期中。也就是说session关闭的时<br>候该session所管理的⼀级缓存也随之被清除。hibernate的⼀级缓存是session所内置的，默认开启，不能被卸载，也不<br>能进⾏任何配置。在缓存中的对象,具有持久性,session对象负责管理.⼀级缓存的优点是使⽤同⼀个session对象多次查询<br>同⼀个数据对象,仅对数据库查询⼀次。⼀级缓存采⽤的是Key-Value的MAP⽅式来实现的。在缓存实体对象时，对象的<br>主关键字ID是MAP的Key，实体对象就是对象的值。所以说⼀级缓存是以实体对象为单位进⾏存储的。访问的时候使⽤的<br>是主键关键字ID。⼀级缓存使⽤的是⾃动维护的功能。但可以通过session提供的⼿动⽅法对⼀级缓存的管理进⾏⼿动⼲<br>预。evict()⽅法⽤于将某个对象从session的⼀级缓存中清除。clear()⽅法⽤于将session缓存中的⽅法全部清除。<br>b. ⼆级缓存：⼆级缓存的实现原理与⼀级缓存是⼀样的。也是通过Key-Value的Map来实现对对象的缓存。⼆级缓存是作<br>⽤在SessionFactory范围内的。因此它可被所有的Session对象所共享。需要注意的是放⼊缓存中的数据不能有第三⽅的<br>应⽤对数据进⾏修改。⼆级缓存默认关闭，需要程序员⼿动开启，默认为ehcache实现.<br>c. 懒加载：当⽤到数据的时候才向数据库查询，这就是hibernate的懒加载特性。延迟加载策略能避免加载应⽤程序不需<br>要访问的关联对象，以提⾼应⽤程序的性能。68. mybatis如何实现批量提交？<br>a. 通过标签：</p><p>b. 通过ExecutorType.BATCH：<br>69. session机制？70. session是服务器的⽣成,并传⾄客户端浏览器,后续请求,都会通过URL重写传⾄服务器进⾏session⽐较.71. session是基于cookie72. session可以保存⽤户信息,但cookie如果浏览器被禁⽤,则⽆法保存⽤户信息73. 如果浏览器禁⽤会话cookie，则每次请求都⽆法将第⼀次请求获得的sessionId传⾄后台服务器.所以每次请求刷新⻚⾯服务<br>器都会⽣成新的sessionid给到浏览器74. 因HTTP协议为⽆状态的协议（⼀旦数据交互完毕，客户端和服务端的连接就会关闭，再次交换数据时需要建⽴新的连接）,需要<br>通过session或者cookie保存和跟踪⽤户信息<br>6、sessionID放在浏览器客户端cookie,其它信息放在服务器内存中，也可以做持久化管理memcached、redis中；75. Struts2表单重复提交问题（token拦截器）<br>1.访问⻚⾯前保存token(服务器后台⽣成的⼀串序列时间串放到session中)，并传⾄前台jsp⻚⾯中的隐藏域<br>2.提交时验证token,将前台的隐藏的token传⾄后台进⾏验证是否⼀致，提交随机⽣成新的token，可以防⽌重复提交；76. shiro：<br>1、定义：apache shiro是java的⼀个安全框架，简单易⽤，基本功能有：认证、授权、加密、会话管理、与Web集成、缓存<br>等。Shiro不会去维护⽤户、维护权限；这些需要我们⾃⼰去设计&#x2F;提供；然后通过相应的接⼝注⼊给Shiro即可(五张表)。<br>2、功能点：Authentication：身份认证&#x2F;登录，验证⽤户是不是拥有相应的身份；<br>Authorization：授权，即权限验证，验证某个已认证的⽤户是否拥有某个权限；即判断⽤户是否能做事情，常⻅的如：验<br>证某个⽤户是否拥有某个⻆⾊。或者细粒度的验证某个⽤户对某个资源是否具有某个权限；<br>Session Manager：会话管理，即⽤户登录后就是⼀次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通<br>JavaSE环境的，也可以是如Web环境的；<br>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，⽽不是明⽂存储；<br>Web Support：Web⽀持，可以⾮常容易的集成到Web环境；<br>Caching：缓存，⽐如⽤户登录后，其⽤户信息、拥有的⻆⾊&#x2F;权限不必每次去查，这样可以提⾼效率；<br>Concurrency：shiro⽀持多线程应⽤的并发验证，即如在⼀个线程中开启另⼀个线程，能把权限⾃动传播过去；<br>Testing：提供测试⽀持；<br>Run As：允许⼀个⽤户假装为另⼀个⽤户（如果他们允许）的身份进⾏访问；<br>Remember Me：记住我，这个是⾮常常⻅的功能，即⼀次登录后，下次再来的话不⽤登录了。<br>3、⼯作流程：<br>1、应⽤代码通过Subject(主体，代表当前”⽤户”)来进⾏认证和授权，⽽Subject⼜委托给SecurityManager(安全管理<br>器，shiro核⼼)；<br>2、我们需要给Shiro的SecurityManager注⼊Realm(域，Shiro从Realm获取安全数据（如⽤户、⻆⾊、权限）)，从⽽<br>让SecurityManager能得到合法的⽤户及其权限进⾏判断。1. Tomcat Filter过滤器责任链模式,过滤器拦截器区别?<br>1、责任链模式：将⼀个事件处理流程分派到⼀组执⾏对象上去，这⼀组执⾏对象形成⼀个链式结构，事件处理请求在这⼀组执⾏对<br>象上进⾏传递。<br>2、过滤器和拦截器：<br>1、过滤器filter：是在java web中，你传⼊的request,response提前过滤掉⼀些信息，或者提前设置⼀些参数，然后<br>再传⼊servlet或者struts的 action进⾏业务逻辑，⽐如过滤掉⾮法url（不是login.do的地址请求，如果⽤户没有登陆都过滤<br>掉）,或者在传⼊servlet或者 struts的action前统⼀设置字符集，或者去除掉⼀些⾮法字符；<br>2、拦截器interceptor：是在⾯向切⾯编程的就是在你的service或者⼀个⽅法，前调⽤⼀个⽅法，或者在⽅法后调⽤⼀个<br>⽅法⽐如动态代理就是拦截器的简单实现，在你调⽤⽅法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调⽤⽅法后打印出<br>字符串，甚⾄在你抛出异常的时候做业务逻辑的操作。拦截是AOP的⼀种实现策略；<br>3、区别：<br>a. 拦截器是基于java的反射机制的，⽽过滤器是基于函数回调。<br>b. 拦截器不依赖于servlet容器，过滤器依赖与servlet容器。<br>c. 拦截器只能对action请求起作⽤，⽽过滤器则可以对⼏乎所有的请求起作⽤。<br>d. 拦截器可以访问action上下⽂、值栈⾥的对象，⽽过滤器不能访问。<br>e. 在action的⽣命周期中，拦截器可以多次被调⽤，⽽过滤器只能在容器初始化时被调⽤⼀次<br>2. Git与Svn的区别：<br>1、Git是分布式的，⽽Svn不是；<br>2、GIT把内容按元数据⽅式存储，⽽SVN是按⽂件<br>3、分⽀不同：git分⽀切换很⽅便；svn分⽀就是版本库的另外⼀个⽬录；<br>4、GIT没有⼀个全局的版本号，⽽svn有，SVN的版本号实际是任何⼀个相应时间的源代码快照。<br>5、GIT的内容完整性要优于SVN(GIT的内容存储使⽤的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和⽹<br>络问题时降低对版本库的破坏。)<br>3. Git命令底层原理：<br>4. git init：使⽤git init初始化⼀个新的⽬录时，会⽣成⼀个.git的⽬录，该⽬录即为本地仓库。⼀个新初始化的本地仓库<br>是这样的：<br>1 !”” HEAD<br>2 !”” branches<br>3 !”” config<br>4 !”” description<br>5 !”” hooks<br>6 !”” objects<br>7 # !”” info<br>8 # <code>$&quot;&quot; pack 9 $</code>“” refs<br>10 !”” heads<br>11 $“” tags<br>description⽤于GitWeb程序<br>config配置特定于该仓库的设置（还记得git config的三个配置级别么）<br>hooks放置客户端或服务端的hook脚本<br>HEAD传说中的HEAD指针，指明当前处于哪个分⽀<br>objectsGit对象存储⽬录<br>refsGit引⽤存储⽬录<br>branches放置分⽀引⽤的⽬录<br>其中description、config和hooks这些不在讨论中，后⽂会直接忽略。<br>5. git add：Git commit之前先要通过git add添加⽂件：<br>可以看到，多了⼀个index⽂件。并且在objects⽬录下多了⼀个9f的⽬录，其中多了⼀个<br>4d96d5b00d98959ea9960f069585ce42b1349a⽂件。<br>其实9f4d96d5b00d98959ea9960f069585ce42b1349a就是⼀个Git对象，称为blob对象。<br>6. git commit：<br>7. JSP的执⾏过程：<br>1）客户端发出请求。<br>2）Web容器将JSP转译成Servlet源代码。<br>3）Web容器将产⽣的源代码进⾏编译。<br>4）Web容器加载编译后的代码并执⾏。<br>5）把执⾏结果响应⾄客户端。<br>8. ZK⾼可⽤：<br>9. ZooKeeper 运⾏期间，集群中⾄少有过半的机器保存了最新数据。集群超过半数的机器能够正常⼯作，集群就能够对<br>外提供服务。<br>10. zookeeper有什么功能，选举算法如何进⾏：<br>1、选举算法：<br>1、Fast Leader(领导者选举)选举算法：<br>1.server启动时默认选举⾃⼰，并向整个集群⼴播<br>2.收到消息时，通过3层判断：选举轮数，zxid，server id⼤⼩判断是否同意对⽅，如果同意，则修改⾃⼰的选<br>票，并向集群⼴播<br>3.QuorumCnxManager负责IO处理，每2个server建⽴⼀个连接，只允许id⼤的server连id⼩的server，每个<br>server启动单独的读写线程处理，使⽤阻塞IO<br>4.默认超过半数机器同意时，则选举成功，修改⾃身状态为LEADING或FOLLOWING<br>5.Obserer机器不参与选举<br>2、原理：选举结果的影响权重关系是:⾸先看数据id,数据id⼤者胜出;其次再判断leader id,leader id⼤者胜出。<br>3、举例：<br>假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数<br>据量这⼀点上,都是⼀样的.假设这些服务器依序启动,来看看会发⽣什么.1. 服务器1启动,此时只有它⼀台服务器启动了,它发出去的报没有任何响应,所以它的选举状态⼀直是LOOKING<br>状态；<br>2. 服务器2启动,它与最开始启动的服务器1进⾏通信,互相交换⾃⼰的选举结果,由于两者都没有历史数据,所以id<br>值较⼤的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例⼦中的半数以上是3),所以服务器1,2<br>还是继续保持LOOKING状态.<br>3. 服务器3启动,根据前⾯的理论分析,服务器3成为服务器1,2,3中的⽼⼤,⽽与上⾯不同的是,此时有三台服务器<br>选举了它,所以它成为了这次选举的leader.<br>4. 服务器4启动,根据前⾯的分析,理论上服务器4应该是服务器1,2,3,4中最⼤的,但是由于前⾯已经有半数以上的<br>服务器选举了服务器3,所以它只能接收当⼩弟的命了.<br>5. 服务器5启动,同4⼀样,当⼩弟.<br>4、zookeeper管理员指南：<br>1、集群中过半存活即可⽤，故集群选择奇数台机器；1. RPC、RMI、MQ、SOAP：<br>1、RPC:远程过程调⽤协议，采⽤C&#x2F;S模式，分布式跨语⾔平台，更多⽤于同步调⽤，⽐如Web Service(SOAP)；<br>2、RMI:远程⽅法调⽤，依赖于java远程消息交换协议，要求服务端与客户端都为java编写；每个⽅法都具有⽅法签名，只有签名<br>匹配才可以调⽤，返回值是基本类型和对象；<br>3、MQ:队列，更多⽤于异步传输；<br>4、SOAP最主要的⼯作是使⽤标准的XML描述了RPC的请求信息(URI&#x2F;类&#x2F;⽅法&#x2F;参数&#x2F;返回值)。理论上，SOAP就是⼀段xml，你可<br>以通过http,smtp等发送它(复制到软盘上，叫快递公司送去也⾏?)。同样SOAP也是跨语⾔的。<br>2. Netty⾼性能：<br>1、NIO异步⾮阻塞通信<br>2、“零拷⻉”<br>3、内存池ByteBuf<br>4、Netty提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。<br>5、⾼效的Reactor线程模型：Reactor单线程(多线程、主从)模型，指的是所有的IO操作都在同⼀个NIO线程上⾯完成<br>6、为了尽可能提升性能，Netty采⽤了串⾏⽆锁化设计，在IO线程内部进⾏串⾏操作，避免多线程竞争导致的性能下降。表⾯上<br>看，串⾏化设计似乎CPU利⽤率不⾼，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串⾏化的线程并⾏运<br>⾏，这种局部⽆锁化的串⾏线程设计相⽐⼀个队列-多个⼯作线程模型性能更优。<br>7、⾼效的并发编程：Netty的⾼效并发编程主要体现在如下⼏点：1. volatile的⼤量、正确使⽤;<br>2. CAS和原⼦类的⼴泛使⽤；<br>3. 线程安全容器的使⽤；<br>4. 通过读写锁提升并发性能。<br>8、⾼效的序列化框架：<br>9、灵活的TCP参数配置能⼒：合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和<br>SO_SNDBUF。如果设置不当，对性能的影响是⾮常⼤的。1. 如何保证服务的幂等性？<br>1、概念：接⼝的幂等性实际上就是接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。有些<br>接⼝可以天然的实现幂等性，⽐如查询接⼝，对于查询来说，你查询⼀次和两次，对于系统来说，没有任何影响，查出<br>的结果也是⼀样。<br>2、GET幂等：值得注意，幂等性指的是作⽤于结果⽽⾮资源本身。怎么理解呢？例如，这个HTTP GET⽅法可能会每次<br>得到不同的返回内容，但并不影响资源。<br>3、POST⾮幂等：因为它会对资源本身产⽣影响，每次调⽤都会有新的资源产⽣，因此不满⾜幂等性。<br>4、如何保证幂等性：<br>1、全局唯⼀id：如果使⽤全局唯⼀ID，就是根据业务的操作和内容⽣成⼀个全局ID，在执⾏操作前先根据这个全局唯<br>⼀ID是否存在，来判断这个操作是否已经执⾏。如果不存在则把全局ID，存储到存储系统中，⽐如数据库、redis等。如<br>果存在则表示该⽅法已经执⾏。<br>从⼯程的⻆度来说，使⽤全局ID做幂等可以作为⼀个业务的基础的微服务存在，在很多的微服务中都会⽤到这样的<br>服务，在每个微服务中都完成这样的功能，会存在⼯作量重复。另外打造⼀个⾼可靠的幂等服务还需要考虑很多问题，<br>⽐如⼀台机器虽然把全局ID先写⼊了存储，但是在写⼊之后挂了，这就需要引⼊全局ID的超时机制。<br>使⽤全局唯⼀ID是⼀个通⽤⽅案，可以⽀持插⼊、更新、删除业务操作。但是这个⽅案看起来很美但是实现起来⽐<br>较麻烦，下⾯的⽅案适⽤于特定的场景，但是实现起来⽐较简单。<br>2、去重表：这种⽅法适⽤于在业务中有唯⼀标的插⼊场景中，⽐如在以上的⽀付场景中，如果⼀个订单只会⽀付⼀<br>次，所以订单ID可以作为唯⼀标识。这时，我们就可以建⼀张去重表，并且把唯⼀标识作为唯⼀索引，在我们实现时，<br>把创建⽀付单据和写⼊去去重表，放在⼀个事务中，如果重复创建，数据库会抛出唯⼀约束异常，操作就会回滚。<br>3、插⼊或更新：这种⽅法插⼊并且有唯⼀索引的情况，⽐如我们要关联商品品类，其中商品的ID和品类的ID可以构成<br>唯⼀索引，并且在数据表中也增加了唯⼀索引。这时就可以使⽤InsertOrUpdate操作。在mysql数据库中如下：<br>1 insert into goods_category (goods_id,category_id,create_time,update_time)<br>2 values(#{goodsId},#{categoryId},now(),now())<br>3 on DUPLICATE KEY UPDATE<br>4 update_time&#x3D;now()<br>4、多版本控制：这种⽅法适合在更新的场景中，⽐如我们要更新商品的名字，这时我们就可以在更新的接⼝中增加⼀<br>个版本号，来做幂等<br>1 boolean updateGoodsName(int id,String newName,int version);<br>在实现时可以如下<br>1 update goods set name&#x3D;#{newName},version&#x3D;#{version} where id&#x3D;#{id} and version&lt;${version}<br>5、状态机控制：这种⽅法适合在有状态机流转的情况下，⽐如就会订单的创建和付款，订单的付款肯定是在之前，这<br>时我们可以通过在设计状态字段时，使⽤int类型，并且通过值类型的⼤⼩来做幂等，⽐如订单的创建为0，付款成功为<br>100。付款失败为99<br>在做状态机更新时，我们就这可以这样控制<br>1 update <code>order</code> set status&#x3D;#{status} where id&#x3D;#{id} and status&lt;#{status}<br>2. zookeeper⼯作原理？<br>1、定义：zookeeper是⼀种为分布式应⽤所设计的⾼可⽤、⾼性能且⼀致的开源协调服务，它提供了⼀项基本服务：分<br>布式锁服务。后来摸索出了其他使⽤⽅法：配置维护、组服务、分布式消息队列、分布式通知&#x2F;协调等。<br>2、特点：<br>1、能够⽤在⼤型分布式系统中；<br>2、具有⼀致性、可⽤性、容错性，不会因为⼀个节点的错误⽽崩溃；<br>3、⽤途：⽤户⼤型分布式系统，作协调服务⻆⾊；<br>1、分布式锁应⽤：通过对集群进⾏master选举，来解决分布式系统中的单点故障（⼀主n从，主挂全挂）。<br>2、协调服务；<br>3、注册中⼼；<br>4、原理：<br>术语：<br>数据结构Znode：zookeeper数据采⽤树形层次结构，和标准⽂件系统⾮常相似，树中每个节点被称为Znode；<br>通知机制Watcher：zookeeper可以为所有的读操作（exists()、getChilden()及getData()）设置watch，<br>watch事件是⼀次性出发器，当watch的对象状态发⽣改变时，将会触发次对象上watch所对应的事件。watch事件将被异步的发送<br>给客户端，并且zookeeper为watch机制提供了有序的⼀致性保证。<br>基本流程：分布式锁应⽤场景<br>1、传统的⼀主n从分布式系统，容易发⽣单点故障，传统解决⽅式是增加⼀个备⽤节点，定期给主节点发送Ping包，主<br>节点回复ack，但是如果⽹络原因ack丢失，那么会出现两个主节点，造成数据混乱。<br>2、zookeeper的引⼊可以管理两个主节点，其中挂了⼀个，会将另外⼀个作为新的主节点，挂的节点回来时担任备⽤节<br>点；<br>3. cap理论：<br>1、概念：⼀个分布式系统最多只能同时满⾜⼀致性（Consistency）、可⽤性（Availability）和分区容错性（Partition<br>tolerance）这三项中的两项。<br>2、⼀致性：更新操作成功并返回客户端完成后，所有节点在同⼀时间的数据完全⼀致，所以，⼀致性，说的就是数据⼀<br>致性。<br>3、可⽤性：服务⼀直可⽤，⽽且是正常响应时间。<br>4、分区容错性：分布式系统在遇到某节点或⽹络分区故障的时候，仍然能够对外提供满⾜⼀致性和可⽤性的服务。Java 基础<br>1.JDK 和 JRE 有什么区别？<br>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。<br>2.&#x3D;&#x3D; 和 equals 的区别是什么？<br>&#x3D;&#x3D; 解读<br>对于基本类型和引用类型 &#x3D;&#x3D; 的作用效果是不同的，如下所示：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：<br>String x &#x3D; “string”;<br>String y &#x3D; “string”;<br>String z &#x3D; new String(“string”);<br>System.out.println(xy); &#x2F;&#x2F; true<br>System.out.println(xz); &#x2F;&#x2F; false<br>System.out.println(x.equals(y)); &#x2F;&#x2F; true<br>System.out.println(x.equals(z)); &#x2F;&#x2F; true<br>代码解读：因为 x 和 y 指向的是同一个引用，所以 &#x3D;&#x3D; 也是 true，而 new String()方法则重写开辟了内存空间，所以 &#x3D;&#x3D; 结果为 false，而 equals 比较的一直是值，所以结果都为 true。<br>equals 解读<br>equals 本质上就是 &#x3D;&#x3D;，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。<br>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：<br>class Cat {<br>public Cat(String name) {<br>this.name &#x3D; name;<br>}<br>private String name;public String getName() {<br>return name;<br>}public void setName(String name) {<br>this.name &#x3D; name;<br>}<br>}<br>Cat c1 &#x3D; new Cat(“王磊”);<br>Cat c2 &#x3D; new Cat(“王磊”);<br>System.out.println(c1.equals(c2)); &#x2F;&#x2F; false<br>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：<br>public boolean equals(Object obj) {<br>return (this &#x3D;&#x3D; obj);<br>}<br>原来 equals 本质上就是 &#x3D;&#x3D;。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：<br>String s1 &#x3D; new String(“老王”);<br>String s2 &#x3D; new String(“老王”);<br>System.out.println(s1.equals(s2)); &#x2F;&#x2F; true<br>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：<br>public boolean equals(Object anObject) {<br>if (this &#x3D;&#x3D; anObject) {<br>return true;<br>}<br>if (anObject instanceof String) {<br>String anotherString &#x3D; (String)anObject;<br>int n &#x3D; value.length;<br>if (n &#x3D;&#x3D; anotherString.value.length) {<br>char v1[] &#x3D; value;<br>char v2[] &#x3D; anotherString.value;<br>int i &#x3D; 0;<br>while (n– !&#x3D; 0) {<br>if (v1[i] !&#x3D; v2[i])<br>return false;<br>i++;<br>}<br>return true;<br>}<br>}<br>return false;<br>}<br>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br>总结 ：&#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。<br>3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？<br>不对，两个对象的 hashCode() 相同，equals() 不一定 true。<br>代码示例：<br>String str1 &#x3D; “通话”;<br>String str2 &#x3D; “重地”;<br>System. out. println(String. format(“str1：%d | str2：%d”, str1. hashCode(),str2. hashCode()));<br>System. out. println(str1. equals(str2));<br>执行的结果：<br>str1：1179395 | str2：1179395<br>false<br>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。<br>4.final 在 Java 中有什么作用？<br>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。<br>5.Java 中的 Math. round(-1. 5) 等于多少？<br>等于 -1，Math. round 四舍五入大于 0. 5 向上取整的。<br>6.String 属于基础的数据类型吗？<br>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。<br>7.Java 中操作字符串都有哪些类？它们之间有什么区别？<br>操作字符串的类有：String、StringBuffer、StringBuilder。<br>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br>8.String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？<br>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。<br>9.如何将字符串反转？<br>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br>示例代码：<br>&#x2F;&#x2F; StringBuffer reverse<br>StringBuffer stringBuffer &#x3D; new StringBuffer();<br>stringBuffer. append(“abcdefg”);<br>System. out. println(stringBuffer. reverse()); &#x2F;&#x2F; gfedcba<br>&#x2F;&#x2F; StringBuilder reverse<br>StringBuilder stringBuilder &#x3D; new StringBuilder();<br>stringBuilder. append(“abcdefg”);<br>System. out. println(stringBuilder. reverse()); &#x2F;&#x2F; gfedcba1. String 类的常用方法都有那些？<br>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。<br>2. 抽象类必须要有抽象方法吗？<br>不需要，抽象类不一定非要有抽象方法。<br>示例代码：<br>abstract class Cat {<br>public static void sayHi() {<br>System. out. println(“hi~”);<br>}<br>}<br>上面代码，抽象类并没有抽象方法但完全可以正常运行。<br>12.普通类和抽象类有哪些区别？<br>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。<br>13.抽象类能使用 final 修饰吗？<br>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：<br>编译器保存图</p><p>15.Java 中 IO 流分为几种？<br>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。<br>16.BIO、NIO、AIO 有什么区别？<br>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。<br>17.Files的常用方法都有哪些？<br>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。<br>容器<br>18.Java 容器都有哪些？<br>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：<br>Collection<br>List<br>ArrayList<br>LinkedList<br>Vector<br>Stack<br>Set<br>HashSet<br>LinkedHashSet<br>TreeSet<br>Map<br>HashMap<br>LinkedHashMap<br>TreeMap<br>ConcurrentHashMap<br>Hashtable<br>3. Collection 和 Collections 有什么区别？<br>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。<br>4. List、Set、Map 之间的区别是什么？<br>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：<br>区别图<br>22.如何决定使用 HashMap 还是 TreeMap？<br>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。<br>23.说一下 HashMap 的实现原理？<br>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。<br>24.说一下 HashSet 的实现原理？<br>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。<br>25.ArrayList 和 LinkedList 的区别是什么？<br>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。<br>26.如何实现数组和 List 之间的转换？<br>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：<br>&#x2F;&#x2F; list to array<br>List list &#x3D; new ArrayList();<br>list. add(“王磊”);<br>list. add(“的博客”);<br>list. toArray();<br>&#x2F;&#x2F; array to list<br>String[] array &#x3D; new String[]{“王磊”,“的博客”};<br>Arrays. asList(array);<br>5. ArrayList 和 Vector 的区别是什么？<br>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。<br>6. Array 和 ArrayList 有何区别？<br>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。<br>7. 在 Queue 中 poll()和 remove()有什么区别？<br>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。<br>代码示例：<br>Queue queue &#x3D; new LinkedList();<br>queue. offer(“string”); &#x2F;&#x2F; add<br>System. out. println(queue. poll());<br>System. out. println(queue. remove());<br>System. out. println(queue. size());<br>8. 哪些集合类是线程安全的？<br>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。<br>31.迭代器 Iterator 是什么？<br>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。<br>32.Iterator 怎么使用？有什么特点？<br>Iterator 使用代码如下：<br>List list &#x3D; new ArrayList&lt;&gt;();<br>Iterator it &#x3D; list. iterator();<br>while(it. hasNext()){<br>String obj &#x3D; it. next();<br>System. out. println(obj);<br>}<br>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。<br>33.Iterator 和 ListIterator 有什么区别？<br>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。<br>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。<br>34.怎么确保一个集合不能被修改？<br>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下：<br>List list &#x3D; new ArrayList&lt;&gt;();<br>list. add(“x”);<br>Collection clist &#x3D; Collections. unmodifiableCollection(list);<br>clist. add(“y”); &#x2F;&#x2F; 运行时此行报错<br>System. out. println(list. size());<br>多线程<br>9. 并行和并发有什么区别？<br>并行：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>并发：多个处理器或多核处理器同时处理多个任务。<br>如下图：<br>并发和并行<br>并发 &#x3D; 两个队列和一台咖啡机。<br>并行 &#x3D; 两个队列和两台咖啡机。<br>36.线程和进程的区别？<br>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。<br>37.守护线程是什么？<br>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。<br>47.在 Java 程序中怎么保证多线程的运行安全？<br>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：<br>Lock lock &#x3D; new ReentrantLock();<br>lock. lock();<br>try {<br>System. out. println(“获得锁”);<br>} catch (Exception e) {<br>&#x2F;&#x2F; TODO: handle exception<br>} finally {<br>System. out. println(“释放锁”);<br>lock. unlock();<br>}<br>13. 多线程中 synchronized 锁升级的原理是什么？<br>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。<br>52.说一下 synchronized 底层实现原理？<br>synchronized 是由一对 monitorenter&#x2F;monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。<br>53.synchronized 和 volatile 的区别是什么？<br>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。<br>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>14. 说一下 atomic 的原理？<br>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>反射<br>15. 什么是反射？<br>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><ol start="16"><li>动态代理是什么？有哪些应用？<br>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。<br>60.怎么实现动态代理？<br>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。<br>对象拷贝</li><li>为什么要使用克隆？<br>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。<br>62.如何实现对象克隆？<br>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。<br>63.深拷贝和浅拷贝区别是什么？<br>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。<br>Java Web<br>64.JSP 和 servlet 有什么区别？<br>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。<br>71.如何避免 SQL 注入？<br>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。<br>72.什么是 XSS 攻击，如何避免？<br>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br>预防 XSS 的核心是必须对输入的数据做过滤处理。<br>73.什么是 CSRF 攻击，如何避免？<br>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br>防御手段：<br>验证请求来源地址；<br>关键操作添加验证码；<br>在请求地址添加 token 并验证。<br>异常</li><li>throw 和 throws 的区别？<br>throw：是真实抛出一个异常。<br>throws：是声明可能会抛出一个异常。</li><li>try-catch-finally 中哪个部分可以省略？<br>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。<br>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？<br>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。<br>78.常见的异常类有哪些？<br>NullPointerException 空指针异常<br>ClassNotFoundException 指定类不存在<br>NumberFormatException 字符串转换为数字异常<br>IndexOutOfBoundsException 数组下标越界异常<br>ClassCastException 数据类型转换异常<br>FileNotFoundException 文件未找到异常<br>NoSuchMethodException 方法不存在异常<br>IOException IO 异常<br>SocketException Socket 异常<br>网络<br>79.http 响应码 301 和 302 代表的是什么？有什么区别？<br>301：永久重定向。<br>302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。<br>80.forward 和 redirect 的区别？<br>forward 是转发 和 redirect 是重定向：<br>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；<br>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；<br>效率：forward 比 redirect 效率高。</li><li>简述 tcp 和 udp的区别？<br>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：<br>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；<br>tcp 提供可靠的服务（数据传输），udp 无法保证；<br>tcp 面向字节流，udp 面向报文；<br>tcp 数据传输慢，udp 数据传输快；<br>83.说一下 tcp 粘包是怎么产生的？<br>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<br>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li><li>OSI 的七层模型都有哪些？<br>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>数据链路层：负责建立和管理节点间的链路。<br>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。<br>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>会话层：向两个实体的表示层提供建立和使用连接的方法。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。<br>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li><li>get 和 post 请求有哪些区别？<br>get 请求会被浏览器主动缓存，而 post 不会。<br>get 传递参数有大小限制，而 post 没有。<br>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li><li>如何实现跨域？<br>实现跨域有以下几种方案：<br>服务器端运行跨域 设置 CORS 等于 *；<br>在单个接口使用注解 @CrossOrigin 运行跨域；<br>使用 jsonp 跨域；</li><li>说一下 JSONP 实现原理？<br>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。<br>设计模式</li><li>为什么要使用 spring？<br>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。<br>spring 提供了事务支持，使得事务操作变的更加方便。<br>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。<br>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。<br>106.spring boot 核心配置文件是什么？<br>spring boot 核心的两个配置文件：<br>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li><li>spring boot 配置文件有哪几种类型？它们有什么区别？<br>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。<br>. properties 配置如下：<br>spring. RabbitMQ. port&#x3D;5672<br>. yml 配置如下：<br>spring:<br>RabbitMQ:<br>port: 5672<br>. yml 格式不支持 @PropertySource 注解导入。<br>108.spring boot 有哪些方式可以实现热部署？<br>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，沟上自动编译或手动重新编译。<br>109.jpa 和 hibernate 有什么区别？<br>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。<br>110.什么是 spring cloud？<br>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。<br>111.spring cloud 断路器的作用是什么？<br>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。<br>112.spring cloud 的核心组件有哪些？<br>Eureka：服务注册于发现。<br>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。<br>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。<br>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。<br>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。<br>Hibernate<br>113.为什么要使用 hibernate？<br>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。<br>可以很方便的进行数据库的移植工作。<br>提供了缓存机制，是程序执行更改的高效。<br>114.什么是 ORM 框架？<br>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。<br>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。<br>115.hibernate 中如何在控制台查看打印的 SQL 语句？<br>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。<br>116.hibernate 有几种查询方式？<br>三种：hql、原生 SQL、条件查询 Criteria。<br>117.hibernate 实体类可以被定义为 final 吗？<br>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。<br>118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？<br>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。<br>119.hibernate 是如何工作的？<br>读取并解析配置文件。<br>读取并解析映射文件，创建 SessionFactory。<br>打开 Session。<br>创建事务。<br>进行持久化操作。<br>提交事务。<br>关闭 Session。<br>关闭 SessionFactory。<br>120.get()和 load()的区别？<br>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。<br>load()支持延迟加载；get() 不支持延迟加载。<br>121.说一下 hibernate 的缓存机制？<br>hibernate 常用的缓存有一级缓存和二级缓存：<br>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；<br>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。<br>122.hibernate 对象有哪些状态？<br>临时&#x2F;瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>持久化状态：当调用 Session 的 save&#x2F;saveOrupdate&#x2F;get&#x2F;load&#x2F;list 等方法的时候，对象就是持久化状态。<br>游离状态：Session 关闭之后对象就是游离状态。<br>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？<br>getCurrentSession 会绑定当前线程，而 openSession 则不会。<br>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。<br>124.hibernate 实体类必须要有无参构造函数吗？为什么？<br>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。<br>MyBatis</li><li>MyBatis 中 #{}和 的区别是什么？#是预编译处理，{}的区别是什么？#{}是预编译处理，的区别是什么？#是预编译处理，{}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。<br>126.MyBatis 有几种分页方式？<br>分页方式：逻辑分页和物理分页。<br>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。<br>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。<br>127.RowBounds 是一次性查询全部结果吗？为什么？<br>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更的数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。<br>Fetch Size 官方相关文档：<a target="_blank" rel="noopener" href="http://t/">http://t</a>. cn&#x2F;EfSE2g3<br>128.MyBatis 逻辑分页和物理分页的区别是什么？<br>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。<br>129.MyBatis 是否支持延迟加载？延迟加载的原理是什么？<br>MyBatis 支持延迟加载，设置 lazyLoadingEnabled&#x3D;true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。<br>130.说一下 MyBatis 的一级缓存和二级缓存？<br>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session&#x2F;二级缓存 Mapper)进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ol><p>132.MyBatis 有哪些执行器（Executor）？<br>MyBatis 有三种基本的Executor执行器：<br>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；<br>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；<br>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。<br>38. MyBatis 分页插件的实现原理是什么？<br>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。<br>134.MyBatis 如何编写一个自定义插件？<br>自定义插件实现原理<br>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：<br>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；<br>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；<br>ParameterHandler：拦截参数的处理；<br>ResultSetHandler：拦截结果集的处理。<br>自定义插件实现关键<br>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：<br>public interface Interceptor {<br>Object intercept(Invocation invocation) throws Throwable;<br>Object plugin(Object target);<br>void setProperties(Properties properties);<br>}<br>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；<br>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；<br>intercept 方法就是要进行拦截的时候要执行的方法。<br>自定义插件实现示例<br>官方插件实现：<br>@Intercepts({@Signature(type &#x3D; Executor. class, method &#x3D; “query”,<br>args &#x3D; {MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class})})<br>public class TestInterceptor implements Interceptor {<br>public Object intercept(Invocation invocation) throws Throwable {<br>Object target &#x3D; invocation. getTarget(); &#x2F;&#x2F;被代理对象<br>Method method &#x3D; invocation. getMethod(); &#x2F;&#x2F;代理方法<br>Object[] args &#x3D; invocation. getArgs(); &#x2F;&#x2F;方法参数<br>&#x2F;&#x2F; do something . . . . . . 方法拦截前执行代码块<br>Object result &#x3D; invocation. proceed();<br>&#x2F;&#x2F; do something . . . . . . . 方法拦截后执行代码块<br>return result;<br>}<br>public Object plugin(Object target) {<br>return Plugin. wrap(target, this);<br>}<br>}<br>RabbitMQ<br>39. RabbitMQ 的使用场景有哪些？<br>抢购活动，削峰填谷，防止系统崩塌。<br>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。<br>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。<br>40. RabbitMQ 有哪些重要的角色？<br>RabbitMQ 中重要的角色有：生产者、消费者和代理：<br>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。<br>41. RabbitMQ 有哪些重要的组件？<br>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。<br>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。<br>42. RabbitMQ 中 vhost 的作用是什么？<br>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。<br>139.RabbitMQ 的消息是怎么发送的？<br>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。<br>140.RabbitMQ 怎么保证消息的稳定性？<br>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。<br>141.RabbitMQ 怎么避免消息丢失？<br>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。<br>142.要保证消息持久化成功的条件有哪些？<br>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。<br>143.RabbitMQ 持久化有什么缺点？<br>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。<br>144.RabbitMQ 有几种广播类型？<br>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。<br>145.RabbitMQ 怎么实现延迟消息队列？<br>延迟队列的实现有两种方式：<br>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。<br>43. RabbitMQ 集群有什么用？<br>集群主要有以下两个用途：<br>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。<br>44. RabbitMQ 节点的类型有哪些？<br>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。<br>45. RabbitMQ 集群搭建需要注意哪些问题？<br>各节点之间使用“–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。<br>46. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？<br>不是，原因有以下两个：<br>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。<br>47. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？<br>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<br>不能创建队列<br>不能创建交换器<br>不能创建绑定<br>不能添加用户<br>不能更改权限<br>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。<br>151.RabbitMQ 对集群节点停止顺序有要求吗？<br>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。<br>Kafka<br>48. kafka 可以脱离 zookeeper 单独使用吗？为什么？<br>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。<br>153.kafka 有几种数据保留的策略？<br>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。<br>154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？<br>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。<br>155.什么情况会导致 kafka 运行变慢？<br>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈<br>156.使用 kafka 集群需要注意什么？<br>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。<br>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。<br>Zookeeper<br>157.zookeeper 是什么？<br>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>158.zookeeper 都有哪些功能？<br>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。<br>159.zookeeper 有几种部署模式？<br>zookeeper 有三种部署模式：<br>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。<br>49. zookeeper 怎么保证主从节点的状态同步？<br>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。<br>161.集群中为什么要有主节点？<br>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。<br>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？<br>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。<br>163.说一下 zookeeper 的通知机制？<br>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。<br>MySQL<br>50. 数据库的三范式是什么？<br>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。<br>51. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？<br>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。<br>166.如何获取当前数据库版本？<br>使用 select version() 获取当前 MySQL 数据库版本。<br>167.说一下 ACID 是什么？<br>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>168.char 和 varchar 的区别是什么？<br>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。<br>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。<br>169.float 和 double 的区别是什么？<br>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。<br>170.MySQL 的内连接、左连接、右连接有什么区别？<br>内连接关键字：inner join；左连接：left join；右连接：right join。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。<br>171.MySQL 索引是怎么实现的？<br>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。<br>172.怎么验证 MySQL 的索引是否满足需求？<br>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br>explain 语法：explain select * from table where type&#x3D;1。<br>173.说一下数据库的事务隔离？<br>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：<br>transaction-isolation &#x3D; REPEATABLE-READ<br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。<br>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。<br>177.MySQL 问题排查都有哪些手段？<br>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。<br>185.Redis 支持的 Java 客户端都有哪些？<br>支持的 Java 客户端有 Redisson、jedis、lettuce 等。<br>186.jedis 和 Redisson 有哪些区别？<br>jedis：提供了比较全面的 Redis 命令的支持。<br>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p><p>191.Redis 如何做内存优化？<br>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。<br>192.Redis 淘汰策略有哪些？<br>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。<br>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。<br>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。<br>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。<br>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。<br>193.Redis 常见的性能问题有哪些？该如何解决？<br>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。<br>JVM<br>194.说一下 JVM 的主要组成部分？及其作用？<br>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）<br>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。<br>195.说一下 JVM 运行时数据区？<br>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：<br>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；<br>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<br>196.说一下堆栈的区别？<br>功能方面：堆是用来存放对象的，栈是用来执行程序的。<br>共享性：堆是线程共享的，栈是线程私有的。<br>空间大小：堆大小远远大于栈。<br>197.队列和栈是什么？有什么区别？<br>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。<br>198.什么是双亲委派模型？<br>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br>类加载器分类：<br>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。<br>199.说一下类加载的执行过程？<br>类加载分为以下 5 个步骤：<br>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。<br>57. 怎么判断对象是否可以被回收？<br>一般有两种方法来判断：<br>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。<br>58. Java 中都有哪些引用类型？<br>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。<br>207.说一下 JVM 调优的工具？<br>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。<br>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。<br>62. 常用的 JVM 调优的参数都有哪些？<br>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。<br>一、Java 基础部分</p><ol><li>JAVA 的基本数据类型有哪些 ? String 是不是基本数据类型 ?<br>Java 有 8 种基本数据类型: byte int short long double float Boolean char<br>byte int short long 都属于整数类型. Double float 属于浮点类型. Boolean 为布尔类型<br>Char 为字符型<br>String 不是基本数据类型.它定义的为对象</li><li>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>可以有多个类，但只能有一个 public 的类，并且 public 的类名必须与文件名相一致。</li><li>Java 有没有 goto?<br>java 中的保留字，现在没有在 java 中使用。</li><li>说说&amp;和&amp;&amp;的区别. &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都<br>为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。<br>&amp;&amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，例如，对<br>于 if(str !&#x3D; null &amp;&amp; !str.equals(“”))表达式，当 str 为 null 时，后面的表达式不会执行，所以不<br>会出现 NullPointerException 如果将&amp;&amp;改为&amp;，则会抛出 NullPointerException 异常。If(x&#x3D;&#x3D;33<br>&amp; ++y&gt;0) y 会增长，If(x&#x3D;&#x3D;33 &amp;&amp; ++y&gt;0)不会增长<br>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是 boolean 类型时，&amp;表示按位与操作，<br>我们通常使用 0x0f 来与一个整数进行&amp;运算，来获取该整数的最低 4 个 bit 位，例如，0x31<br>&amp; 0x0f 的结果为 0x01。<br>备注：这道题先说两者的共同点，再说出&amp;&amp;和&amp;的特殊之处，并列举一些经典的例子来表<br>明自己理解透彻深入、实际经验丰富。</li><li>在 JAVA 中如何跳出当前的多重嵌套循环？<br>在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环<br>体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如，<br>另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里<br>层循环体代码的控制，例如，要在二维数组中查找到某个数字。</li><li>switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上?<br>在 switch（expr1）中，expr1 只能是一个整数表达式或者枚举常量（更大字体），整数表达<br>式可以是 int 基本类型或 Integer 包装类型，由于，byte,short,char 都可以隐含转换为 int，所<br>以，这些类型以及这些类型的包装类型也是可以的。显然，long 和 String 类型都不符合 switch<br>的语法规定，并且不能被隐式转换成 int 类型，所以，它们不能作用于 swtich 语句中。</li><li>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?<br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 由于 s1+1 运算时会自动提升表达式的类型，所以结果是 int 型，<br>再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误。<br>对于 short s1 &#x3D; 1; s1 +&#x3D; 1;由于 +&#x3D; 是 java 语言规定的运算符，java 编译器会对它进行特殊处<br>理，因此可以正确编译。</li><li>char 型变量中能不能存贮一个中文汉字?为什么?<br>char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，<br>char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码<br>字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占<br>用两个字节，所以，char 类型的变量也是占用两个字节。</li><li>用最有效率的方法算出 2 乘以 8 等於几?<br>2 &lt;&lt; 3，<br>因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3<br>位即可，而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2 &lt;&lt;<br>3。</li><li>请设计一个一百亿的计算器<br>首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要<br>知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的<br>面向对象的设计思想。<br>首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一<br>定的范围的，为了便于讲解和理解，我们先以 byte 类型的整数为例，它用 1 个字节进行存<br>储，表示的最大数值范围为-128 到+127。-1 在内存中对应的二进制数据为 11111111，如果<br>两个-1 相加，不考虑 Java 运算时的类型提升，运算后会产生进位，二进制结果为 1,11111110，<br>由于进位后超过了 byte 类型的存储空间，所以进位部分被舍弃，即最终的结果为 11111110，<br>也就是-2，这正好利用溢位的方式实现了负数的运算。-128 在内存中对应的二进制数据为<br>10000000，如果两个-128 相加，不考虑 Java 运算时的类型提升，运算后会产生进位，二进<br>制结果为 1,00000000，由于进位后超过了 byte 类型的存储空间，所以进位部分被舍弃，即<br>最终的结果为 00000000，也就是 0，这样的结果显然不是我们期望的，这说明计算机中的算<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。<br>由于 Java 中涉及表达式运算时的类型自动提升，我们无法用 byte 类型来做演示这种问题和<br>现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下：<br>int a &#x3D; Integer.MAX_VALUE;<br>int b &#x3D; Integer.MAX_VALUE;<br>int sum &#x3D; a + b;<br>System.out.println(“a&#x3D;”+a+”,b&#x3D;”+b+”,sum&#x3D;”+sum);<br>先不考虑 long 类型，由于 int 的正数范围为 2 的 31 次方，表示的最大数值约等于<br>2<em>1000</em>1000*1000，也就是 20 亿的大小，所以，要实现一个一百亿的计算器，我们得自己<br>设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大<br>概功能如下：<br>（1）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数<br>（2）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中<br>（3）提供加减乘除的功能<br>public class BigInteger{<br>int sign;<br>byte[] val;<br>public Biginteger(String val){<br>sign &#x3D; ;<br>val &#x3D; ;<br>}<br>public BigInteger add(BigInteger other){<br>}<br>public BigInteger subtract(BigInteger other){<br>}<br>public BigInteger multiply(BigInteger other){<br>}<br>public BigInteger divide(BigInteger other){<br>}<br>}<br>备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看 jdk 中自带<br>的 java.math.BigInteger 类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整<br>代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你<br>不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证<br>明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什<br>么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，<br>拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，<br>体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这<br>也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能<br>力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一<br>千元。</li><li>使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？<br>使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>还是可以改变的。例如，对于如下语句：<br>final StringBuffer a&#x3D;new StringBuffer(“immutable”);<br>执行如下语句将报告编译期错误：<br>a&#x3D;new StringBuffer(“”);<br>但是，执行如下语句则可以通过编译：<br>a.append(“ broken!”);<br>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：<br>public void method(final StringBuffer param){<br>}<br>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：<br>param.append(“a”);</li><li>“&#x3D;&#x3D;”和 equals 方法究竟有什么区别？<br>&#x3D;&#x3D;操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存<br>储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用&#x3D;&#x3D;操作<br>符。<br>如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块<br>内存（堆内存），变量也占用一块内存，例如 Objet obj &#x3D; new Object();变量 obj 是一个内存，<br>new Object()是另一个内存，此时，变量 obj 所对应的内存中存储的数值就是对象占用的那块<br>内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要<br>看这两个变量所对应的内存中的数值是否相等，这时候就需要用&#x3D;&#x3D;操作符进行比较。<br>equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相<br>同，它比较的两个对象是独立的。例如，对于下面的代码：<br>String a&#x3D;new String(“foo”);<br>String b&#x3D;new String(“foo”);<br>两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向了其中一个对象，这是两个<br>不同的对象，它们的首地址是不同的，即 a 和 b 中存储的数值是不相同的，所以，表达式<br>a&#x3D;&#x3D;b 将返回 false，而这两个对象中的内容是相同的，所以，表达式 a.equals(b)将返回 true。<br>在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input &#x3D; …;input.equals(“quit”)，许多人稍不注意就使用&#x3D;&#x3D;进行比较了，这是错误的，随便从网上<br>找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都<br>是使用 equals 方法。<br>如果一个类没有自己定义 equals 方法，那么它将继承 Object 类的 equals 方法，Object 类的<br>equals 方法的实现代码如下：<br>boolean equals(Object o){<br>return this&#x3D;&#x3D;o;<br>}<br>这说明，如果一个类没有自己定义 equals 方法，它默认的 equals 方法（从 Object 类继承的）<br>就是使用&#x3D;&#x3D;操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals<br>和使用&#x3D;&#x3D;会得到同样的结果，如果比较的是两个独立的对象则总返回 false。如果你编写的<br>类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖 equals 方法，由<br>你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。</li><li>静态变量和实例变量的区别？<br>语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量<br>才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所<br>以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分<br>配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来<br>使用，静态变量则可以直接使用类名来引用。<br>例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并<br>且每创建一个实例对象，这个 staticVar 就会加 1；但是，每创建一个实例对象，就会分配一<br>个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。<br>public class VariantTest{<br>public static int staticVar &#x3D; 0;<br>public int instanceVar &#x3D; 0;<br>public VariantTest(){<br>staticVar++;<br>instanceVar++;<br>System.out.println(“staticVar&#x3D;” + staticVar + ”,instanceVar&#x3D;” + instanceVar);<br>}<br>}<br>备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，<br>体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！</li><li>是否可从一个 static 方法内发出对非 static 方法的调用？<br>不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对<br>象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一<br>个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非<br>static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，<br>一个 static 方法内部发出对非 static 方法的调用。</li><li>Integer 与 int 的区别<br>int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 java<br>为 int 提供的封装类。int 的默认值为 0，而 Integer 的默认值为 null，即 Integer 可以区分出<br>未赋值和值为 0 的区别，int 则无法表达出未赋值的情况，例如，要想表达出没有参加考试<br>和考试成绩为 0 的区别，则只能使用 Integer。在 JSP 开发中，Integer 的默认为 null，所以用<br>el 表达式在文本框中显示时，值为空白字符串，而 int 默认的默认值为 0，所以用 el 表达式<br>在文本框中显示时，结果为 0，所以，int 不适合作为 web 层的表单数据的类型。<br>在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可以根据其值是否为 null<br>而判断一个对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中<br>设置其 unsaved-value 属性为 0。<br>另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer<br>中还定义了表示整数的最大值和最小值的常量。</li><li>Math.round(11.5)等於多少? Math.round(-11.5)等於多少?<br>Math 类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英<br>文名称的含义相对应，例如，ceil 的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)<br>的结果为 12,Math.ceil(-11.3)的结果是-11；floor 的英文意义是地板，该方法就表示向下取整，<br>Math.ceil(11.6)的结果为 11,Math.ceil(-11.6)的结果是-12；最难掌握的是 round 方法，它表示<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>“四舍五入”，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，<br>Math.round(11.5)的结果为 12，Math.round(-11.5)的结果为-11。</li><li>下面的代码有什么不妥之处?</li><li>if(username.equals(“zxx”){}<br>2.int x &#x3D; 1;<br>return x&#x3D;&#x3D;1?true:false;</li><li>请说出作用域 public，private，protected，以及不写时的区别<br>说明：如果在修饰的元素上面没有写任何访问修饰符，则表示 friendly。<br>作用域 当前类 同一 package 子孙类 其他 package<br>public √ √ √ √<br>protected √ √ √ ×<br>friendly √ √ × ×<br>private √ × × ×<br>备注：只要记住了有 4 种访问权限，4 个访问范围，然后将全选和范围在水平和垂直方向上<br>分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。</li><li>Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型?<br>Overload 是重载的意思，Override 是覆盖的意思，也就是重写。<br>重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相<br>同（即参数个数或类型不同）。<br>重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类<br>创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个<br>完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法<br>时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决<br>父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能<br>更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增<br>加了一个全新的方法。<br>至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这<br>个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也<br>可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它<br>们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因<br>为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，<br>我们调用 map.remove(key)方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接<br>收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回<br>类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型<br>来判断。<br>override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达<br>到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法<br>进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，<br>我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：<br>1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；<br>2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；<br>3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>4、被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行<br>覆盖。<br>overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的<br>方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数<br>样式，来选择合适的方法执行。在使用重载要注意以下的几点：<br>1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不<br>同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，<br>但是不能为 fun(int,int)）；<br>2、不能通过访问权限、返回类型、抛出的异常进行重载；<br>3、方法的异常类型和数目不会对重载造成影响；<br>4、对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进<br>行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</li><li>同学贡献的一些题?<br>1.搞了多个重载方法，参数分别是 int ,char,和 double，然后将 double x &#x3D; 2，传递进去，会选<br>择哪个方法？<br>2.说说对 javaee 中的 session 的理解，你是怎么用 session 的？cvs&#x2F;svn 下载<br>3.jdk 中哪些类是不能继承的：System,String,StringBuffer 等。<br>4.在 eclipse 中调试时，怎样查看一个变量的值。<br>5.判断身份证：要么是 15 位，要么是 18 位，最后一位可以为字母，并写程序提出其中的年<br>月日。<br>6.一个房子里有椅子，椅子有腿和背，房子与椅子是什么关系，椅子与腿和背是什么关系？<br>7.如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关<br>联。椅子与腿和背时组合关系。<br>8.说说 has a 与 is a 的区别。<br>9.工厂模式的类图</li><li>线程如何同步和通讯？<br>同学回答说 synchronized 方法或代码块！面试官似乎不太满意！<br>只有多个 synchronized 代码块使用的是同一个监视器对象，这些 synchronized 代码块之间才<br>具有线程互斥的效果，假如 a 代码块用 obj1 作为监视器对象，假如 b 代码块用 obj2 作为监<br>视器对象，那么，两个并发的线程可以同时分别进入这两个代码块中。 …这里还可以分析<br>一下同步的原理。<br>对于同步方法的分析，所用的同步监视器对象是 this<br>接着对于静态同步方法的分析，所用的同步监视器对象是该类的 Class 对象<br>接着对如何实现代码块与方法的同步进行分析。</li><li>ClassLoader 如何加载 class ？<br>jvm 里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap 类加载负责<br>加载 jre&#x2F;lib&#x2F;rt.jar 中的类， 我们平时用的 jdk 中的类都位于 rt.jar 中。extclassloader 负责加载<br>jar&#x2F;lib&#x2F;ext&#x2F;*.jar 中的类，appclassloader 负责 classpath 指定的目录或 jar 中的类。除了 bootstrap<br>之外，其他的类加载器本身也都是 java 类，它们的父类是 ClassLoader。</li><li>Servlet 的生命周期？<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销<br>毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个<br>实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，<br>服务完成后就销毁，所以效率上低于 servlet</li><li>抽象类的作用？</li><li>ArrayList 如何实现插入的数据按自定义的方式有序存放？<br>class MyBean implements Comparable{<br>public int compareTo(Object obj){<br>if(! obj instanceof MyBean)<br>throw new ClassCastException() &#x2F;&#x2F;具体异常的名称，我要查 jdk 文档。<br>MyBean other &#x3D; (MyBean) obj;<br>return age &gt; other.age?1:age&#x3D;&#x3D; other.age?0:-1;<br>}<br>}<br>class MyTreeSet {<br>private ArrayList datas &#x3D; new ArrayList();<br>public void add(Object obj){<br>for(int i&#x3D;0;i&lt;datas.size();i++){<br>if(obj.compareTo(datas.get(i) !&#x3D; 1){<br>datas.add(i,obj);<br>}<br>}<br>}<br>}</li><li>分层设计的好处？<br>把各个功能按调用流程进行了模块化，模块化带来的好处就是可以随意组合，举例说明：如<br>果要注册一个用户，流程为显示界面并通过界面接收用户的输入，接着进行业务逻辑处理，<br>在处理业务逻辑又访问数据库，如果我们将这些步骤全部按流水帐的方式放在一个方法中编<br>写，这也是可以的，但这其中的坏处就是，当界面要修改时，由于代码全在一个方法内，可<br>能会碰坏业务逻辑和数据库访问的码，同样，当修改业务逻辑或数据库访问的代码时，也会<br>碰坏其他部分的代码。分层就是要把界面部分、业务逻辑部分、数据库访问部分的代码放在<br>各自独立的方法或类中编写，这样就不会出现牵一发而动全身的问题了。这样分层后，还可<br>以方便切换各层，譬如原来的界面是 Swing，现在要改成 BS 界面，如果最初是按分层设计<br>的，这时候不需要涉及业务和数据访问的代码，只需编写一条 web 界面就可以了。<br>下面的仅供参考，不建议照搬照套，一定要改成自己的语言，发现内心的感受：<br>分层的好处：1.实现了软件之间的解耦；2.便于进行分工；3.便于维护；4.提高软件组件的重<br>用；5.便于替换某种产品，比如持久层用的是 hibernate,需要更换产品用 toplink，就不用其他<br>业务代码，直接把配置一改；6.便于产品功能的扩展；7.便于适用用户需求的不断变化</li><li>序列化接口的 id 有什么用？<br>对象经常要通过 IO 进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某<br>种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”Person，既然大家都要这么干，并且没<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有个统一的干法，于是，sun 公司就提出一种统一的解决方案，它会把对象变成某个格式进<br>行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想<br>能被 sun 的这种方案处理，必须实现 Serializable 接口。<br>ObjectOutputStream.writeObject(obj);<br>Object obj &#x3D; ObjectInputStream.readObject();<br>假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了<br>另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun 的 jdk 就<br>会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本<br>号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，<br>则直接报版本号不同的错!</li><li>StringBuffer 与 StringBuilder 的区别？<br>因为 StringBuilder sbuilder &#x3D; ;是线程不安全的，运行效率高，如果一个字符串变量是在方法<br>里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用 StringBuilder。<br>如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用<br>StringBuffer。</li><li>hashCode 方法的作用？<br>首先，想要明白 hashCode 的作用，你必须要先知道 Java 中的集合。<br>总的来说，Java 中的集合（Collection）有两类，一类是 List，再有一类是 Set。你知道<br>它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重<br>复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该<br>依据什么来判断呢？这就是 Object.equals 方法了。但是，如果每增加一个元素就检查一次，<br>那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中<br>现在已经有 1000 个元素，那么第 1001 个元素加入集合时，它就要调用 1000 次 equals 方法。<br>这显然会大大降低效率。于是，Java 采用了哈希表的原理。可以简单理解，hashCode 方法<br>实际上返回的就是对象存储的物理地址（实际可能并不是）。这样一来，当集合要添加新的<br>元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。<br>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果<br>这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，<br>不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用 equals<br>方法的次数就大大降低了，几乎只需要一两次。<br>所以，Java 对于 eqauls 方法和 hashCode 方法是这样规定的：<br>1、如果两个对象相同，那么它们的 hashCode 值一定要相同；<br>2、如果两个对象的 hashCode 相同，它们并不一定相同<br>上面说的对象相同指的是用 eqauls 方法比较。<br>你当然可以不按要求去做了，但你会发现，相同的对象可以出现在 Set 集合中。同时，增<br>加新元素的效率会大大下降。</li><li>webservice 问得很多</li><li>设计出计算任意正整数的阶层？</li><li>在 oracle 数据库中需要查询出前 8 条记录的 sql 语句怎么写？</li><li>什么是 SOA，谈谈你的 SOA 的理解。service orientied architecture？<br>SOA 是指为了解决在 Internet 环境下业务集成的需要，通过连接能完成特定任务的独立功能<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实体实现的一种软件系统架构。1. 软件系统架构：SOA 不是一种语言，也不是一种具体的技术而是一种软件系统架构，<br>它尝试给出在特定环境下推荐采用的一种架构，从这个角度上来说，它更像一种模式<br>(Pattern)。因此它与很多已有的软件技术比如面向对象技术，是互补的而非互斥的。它们分<br>别面向不同的应用场景，用来满足不同的特定需求。</li><li>SOA 的使用范围：需求决定同时也限制功能。SOA 并不是包治百病的万灵丹，它最<br>主要的应用场合在于解决在 Internet 环境下的不同商业应用之间的业务集成问题。1. 如何实现线程间的通讯？<br>在 Java 语言中，提供了各种各样的输入输出流（stream）,使我们能够很方便的对数据进行<br>操作，其中，管道（pipe）流是一种特殊的流，用于在不同线程（threads）间直接传送数据。<br>一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同<br>线程间的通讯。无需求助于类似临时文件之类的东西。本文在简要介绍管道的基本概念后，<br>将以一个具体的实例 pipeapp 加以详细说明。<br>1．管道的创建与使用<br>Java 提供了两个特殊的专门的类专门用于处理管道，它们就是 pipedinputstream 类和<br>pipeoutputstream 类。<br>Pipedinputstream 代表了数据在管道中的输出端，也就是线程向管道读数据的一端；<br>pipeoutputstream 代表了数据在管道中的输入端，也就是线程向管道写数据的一端，这两个<br>类一起使用可以提供数据的管道流。<br>为了创建一个管道流，我们必须首先创建一个 pipeoutstream 对象，然后，创建<br>pipeinputstream 对象，实例如下：<br>pipeout&#x3D; new pipedyoutstream();<br>pipein&#x3D; new pipedputsteam(pipepout); 一旦创建了一个管道后，就可以象操作文件一样对管道进行数据的读写。<br>2．演示程序： pipeapp<br>应用程序由三个程序组成：主线程（pipeapp.Java）及由主线程启动的两个二级线程<br>（ythread.Java 和 zthread.Java）,它们使用管道来处理数据。程序从一个内容为一行一行”x” 字母的”input.txt”文件中读取数据，使用管道传输数据，第一次是利用线程 ythread 将数据”x” 转换为”y”，最后利用线程 zthread 将”y”转换为”z”,之后，程序在屏幕上显示修改后的数据。<br>主线程 （pipeapp.Java）<br>在 main()方法中，程序首先创建一个应用对象：pipeapp pipeapp&#x3D;new pipeapp();<br>由于程序中流操作都需要使用 IOException 异常处理，所以设置了一个 try 块。在 try 中，为<br>了从源文件中读取数据，程序为”input.txt”文件创建了一个输入流 Xfileln,:<br>fileinputstream xfileln&#x3D; new fileinputstream(“input.txt”);<br>新的输入流传递给 changetoy()方法，让线程 ythread 能读取该文件：<br>inputstream ylnpipe &#x3D;pipeapp.changetoy(xfileln);<br>changetoy()方法创建将输入数据”x”改变到”y”的线程 ythread,并返回该线程的输入管道：<br>inputstream zlnpipe &#x3D; pipeapp.changetoz(ylnpipe);<br>changetoz()方法启动将数据从”y”改变到”z”的线程 zehread,主程序将使用从 changetoz()<br>返回的输入管道。得到以修改的数据。<br>然后，程序将管道输入流定位到 datainputstream 对象，使程序能够使用 readline()方法读<br>取数据：<br>datainputstream inputstream &#x3D; new datainputstream(zlnpiepe);<br>创建了输入流以后，程序就可以以行一行的读取数据病显示在屏幕上。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>String str&#x3D; inputstream.readline();<br>While(str!&#x3D;null){<br>system.out.println(str);<br>str&#x3D;inputstream.readline();<br>}<br>显示完成之后，程序关闭输入流：<br>inputstream.close();<br>changetoy()方法<br>changetoy()方法首先通过传递一个参数 inputstream 给 datainputstream 对象来定位资源的<br>输入流，使程序能使用 readline()方法从流中读取数据：<br>datainputstream xfileln &#x3D;new datainutstream(inputstream)；<br>然后，changetoy()创建输出管道和输入管道：<br>pipeoutstream pipeout &#x3D; new pipeoutputstream();<br>pipeinputstream pipeln &#x3D; new pipedinputsteam(pipeout);<br>为了能够使用 println()方法输出修改的后的文本行到管道，程序将输出管道定位到<br>printstream 对象：<br>printstream printstream &#x3D; new printstream(pipeout);<br>现在，程序可以创建将数据从 x 改变到 y 的线程，该线程是 ythread 类的一个对象，他<br>传递两个参数：输入文件（xfileln）和输出管道（调用 printstream）<br>ythread ythread &#x3D;new thread(xfileln,printstream);<br>之后，程序启动线程：<br>changetoz（）方法<br>changetoz()方法与 changetoy()方法很相似，他从 changetoy()返回的输入流开始：<br>datainputstream yfileln&#x3D; new datainputstream(inputstream);<br>程序创建一个新的管道：<br>pipedoutstream pipeout2 &#x3D; new pipedoutputstream();<br>pipedinputstream pipeln2 &#x3D; new pipedinputsream(pipeout2);<br>该线程通过这个新的管道发出修改后的数据（输入流 pipeln2）给主程序。</li></ol><p>Ythread 类和 Zthread 类<br>由于 ythread 类与 zthread 类基本一样，在此仅以 ythread 为例加以说明。<br>Ythread 的构造器接收两个参数：输入的文件和第一个管道的输出端，构造器存储这两<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>个参数作为类的数据成员：<br>Ythread(datainputstream xfileln,pringstream printstream){<br>this.xfileln &#x3D; xfileln;<br>this.printstream &#x3D; printstream;<br>}<br>线程通过 run()方法来处理数据。首先读取一行数据，确保 xstring 不为空的情况下循环<br>执行：<br>string xstring &#x3D; xfileln.readline();<br>每读一行数据，完成一次转换<br>string ystring &#x3D; xstring.replace(‘x’,’y’);<br>然后将修改后的数据输出到管道的输出端：<br>prinstream.prinrln(ystring);<br>为了确保所有缓冲区的数据完全进入管道的输出端：<br>pringstram.flush();<br>循环完成后，线程关闭管道输出流：<br>pringstram.close();<br>ythread 类的源程序如下：<br>6. 构造器 Constructor 是否可被 override?<br>构造器 Constructor 不能被继承，因此不能重写 Override，但可以被重载 Overload。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>7. 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具<br>体类(concrete class)? 抽象类中是否可以有静态的 main 方法？<br>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类<br>中可以有静态的 main 方法。<br>备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是 java<br>语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道<br>理不提供，那答案就是肯定的了。<br>只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有 abstract 方法。<br>8. 写 clone()方法时，通常都有一行代码，是什么？<br>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己<br>的成员。<br>9. 谈谈你对面向对象的理解<br>面向对象是一种程序的设计方法，或者说它是一种程序设计范型，其基本思想是使用对象，<br>类，继承，封装，消息等基本概念来进行程序设计。<br>它是从现实世界中客观存在的事物（即对象）出发来构造软件系统，并在系统构造中尽可能<br>运用人类的自然思维方式，强调直接以问题域（现实世界）中的事物为中心来思考问题，认<br>识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的对象，作为系统的基本<br>构成单位（而不是用一些与现实世界中的事物相关比较远，并且没有对应关系的其它概念来<br>构造系统）。这可以使系统直接地映射问题域，保持问题域中事物及其相互关系的本来面貌。<br>它可以有不同层次的理解：<br>从世界观的角度可以认为：面向对象的基本哲学是认为世界是由各种各样具有自己的运动规<br>律和内部状态的对象所组成的；不同对象之间的相互作用和通讯构成了完整的现实世界。因<br>此，人们应当按照现实世界这个本来面貌来理解世界，直接通过对象及其相互关系来反映世<br>界。这样建立起来的系统才能符合现实世界的本来面目。<br>从方法学的角度可以认为：面向对象的方法是面向对象的世界观在开发方法中的直接运用。<br>它强调系统的结构应该直接与现实世界的结构相对应，应该围绕现实世界中的对象来构造系<br>统，而不是围绕功能来构造系统。<br>从程序设计的角度来看，面向对象的程序设计语言必须有描述对象及其相互之间关系的语言<br>成分。这些程序设计语言可以归纳为以下几类：系统中一切皆为对象；对象是属性及其操作<br>的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间<br>的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息<br>的序列。<br>10. 面向对象的特征有哪些方面？<br>面向对象的编程语言有封装、继承 、抽象、多态等 4 个主要的特征。<br>1．封装：<br>封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、<br>低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装<br>的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就<br>是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变<br>量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要<br>记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只<br>有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同<br>一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类<br>中。<br>例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个<br>对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中<br>定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两<br>个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配<br>在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个<br>体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例<br>子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配<br>给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能<br>完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动<br>作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。<br>2．抽象：<br>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些<br>事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与<br>当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是<br>抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个 Person 类，如下：<br>class Person{<br>String name;<br>int age;<br>}<br>人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上<br>面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些<br>与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及<br>的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。<br>3．继承：<br>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在<br>的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适<br>合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一<br>种关系，提高了软件的可重用性和可扩展性。<br>4．多态：<br>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编<br>程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，<br>该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<br>因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到<br>各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以<br>改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性<br>增强了软件的灵活性和扩展性。例如，下面代码中的 UserDao 是一个接口，它定义引用变量<br>userDao 指向的实例对象由 daofactory.getDao()在执行的时候返回，有时候指向的是<br>UserJdbcDao 这个实现，有时候指向的是 UserHibernateDao 这个实现，这样，不用修改源代<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>码，就可以改变 userDao 指向的具体类实现，从而导致 userDao.insertUser()方法调用的具体<br>代码也随之改变，即有时候调用的是 UserJdbcDao 的 insertUser 方法，有时候调用的是<br>UserHibernateDao 的 insertUser 方法：<br>UserDao userDao &#x3D; daofactory.getDao();<br>userDao.insertUser(user);<br>比喻：人吃饭，你看到的是左手，还是右手？<br>11. java 中实现多态的机制是什么？<br>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方<br>法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运<br>行的那个对象的方法，而不是引用变量的类型中定义的方法。<br>12. abstract class 和 interface 有什么区别?<br>含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方<br>法的类必须定义为 abstract class，abstract class 类中的方法不必是抽象的。abstract class 类中<br>定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方<br>法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。<br>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口<br>中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final。<br>下面比较一下两者的语法区别：<br>1.抽象类可以有构造方法，接口中不能有构造方法。<br>2.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象<br>的普通方法。<br>4.抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型,虽然 eclipse 下不报<br>错，但应该也不行），但接口抽象方法只能是 public 类型的，并且默认即为 public abstract<br>类型。<br>5.抽象类中可以包含静态方法，接口中不能包含静态方法<br>6.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任<br>意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。<br>7.一个类可以实现多个接口，但只能继承一个抽象类。<br>下面接着再说说两者在应用上的区别：<br>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类<br>在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个<br>典型应用，假设某个项目的所有 Servlet 类都要用相同的方式进行权限判断、记录访问日志<br>和处理异常，那么就可以定义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在<br>抽象基类的 service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中<br>只是完成各自的业务逻辑代码，伪代码如下：<br>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。<br>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，<br>最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普<br>通成员变量和方法（包括抽象方法），静态变量和方法，继承性等 6 个方面逐一去比较回答，<br>接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功<br>底。<br>13. abstract 的 method 是 否可 同 时是 static,是 否可 同 时是 native， 是否 可 同时 是<br>synchronized?<br>abstract 的 method 不可以是 static 的，因为抽象的方法是要被子类实现的，而 static 与子类<br>扯不上关系！<br>native 方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问<br>题，所以，它也不能是抽象的，不能与 abstract 混用。例如，FileOutputSteam 类要和硬件打<br>交道，底层的实现用的是操作系统相关的 api 实现，例如，在 windows 用 c 语言实现的，所<br>以，查看 jdk 的源代码，可以发现 FileOutputStream 的 open 方法的定义如下：<br>private native void open(String name) throws FileNotFoundException;<br>如果我们要用 java 调用别人写的 c 语言函数，我们是无法直接调用的，我们需要按照 java<br>的要求写一个 c 语言的函数，又我们的这个 c 语言函数去调用别人的 c 语言函数。由于我们<br>的 c 语言函数是按 java 的要求来写的，我们这个 c 语言函数就可以与 java 对接上，java 那<br>边的对接方式就是定义出与我们这个 c 函数相对应的方法，java 中对应的方法不需要写具体<br>的代码，但需要在前面声明 native。<br>关于 synchronized 与 abstract 合用的问题，我觉得也不行，因为在我几年的学习和开发中，<br>从来没见到过这种情况，并且我觉得 synchronized 应该是作用在一个具体的方法上才有意<br>义。而且，方法上的 synchronized 同步所使用的同步锁对象是 this，而抽象方法上无法确定<br>this 是什么。<br>14. 什么是内部类？Static Nested Class 和 Inner Class 的不同？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>使用 static 声明的内部类就是外部类，可以通过外部类.内部类直接访问。<br>普通内部类是不能够直接被外部所访问的，需要通过外部类实例在找到内部类实例。<br>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特<br>性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放<br>到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。<br>我想可能是既然静态成员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，<br>所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该<br>被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，<br>也可以定义在外部类的方法体中，如下所示：<br>在方法体外面定义的内部类的访问类型可以是 public,protecte,默认的，private 等 4 种类型，<br>这就好像类中定义的成员变量有 4 种访问类型一样，它们决定这个内部类的定义对其他类是<br>否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象<br>时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对<br>象，代码如下：<br>Outer outer &#x3D; new Outer();<br>Outer.Inner1 inner1 &#x3D; outer.new Innner1();<br>在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，<br>但这种内部类的前面可以使用 final 或 abstract 修饰符。这种内部类对其他类是不可见的其他<br>类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部<br>类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局<br>部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但<br>是，该局部变量前必须加 final 修饰符。<br>对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误信息就可以马上<br>了解到。<br>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同<br>时，还创建了该子类的实例对象，无需为该子类定义名称：<br>public class Outer {<br>public void start() {<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>new Thread(new Runnable() {<br>public void run() {<br>};<br>}).start();<br>}<br>}<br>最后，在方法外部定义的内部类前面可以加上 static 关键字，从而成为 Static Nested Class，<br>它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class 与普通类<br>在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定<br>义成 public、protected、默认的、private 等多种类型，而普通类只能定义成 public 和默认的<br>这两种类型。在外面引用 Static Nested Class 类的名称为“外部类名.内部类名”。在外面不<br>需要创建外部类的实例对象，就可以直接创建 Static Nested Class，例如，假设 Inner 是定义<br>在 Outer 类中的 Static Nested Class，那么可以使用如下语句创建 Inner 类：<br>Outer.Inner inner &#x3D; new Outer.Inner();<br>由于 static Nested Class 不依赖于外部类的实例对象，所以，static Nested Class 能访问外部类<br>的非 static 成员变量。当在外部访问 Static Nested Class 时，可以直接使用 Static Nested Class<br>的名字，而不需要加上外部类的名字了，在 Static Nested Class 中也可以直接引用外部类的<br>static 的成员变量，不需要加上外部类的名字。<br>在静态方法中定义的内部类也是 Static Nested Class，这时候不能在类前面加 static 关键字，<br>静态方法中的 Static Nested Class 与普通方法中的内部类的应用方式很相似，它除了可以直<br>接访问外部类中的 static 的成员变量，还可以访问静态方法中的局部变量，但是，该局部变<br>量前必须加 final 修饰符。<br>备注：首先根据你印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可<br>以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知<br>识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。<br>15. 内部类可以引用它的包含类的成员吗？有没有什么限制？<br>完全可以。如果不是静态内部类，那没有什么限制！<br>如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员<br>变量，而只能访问外部类中的静态成员，例如，下面的代码：</p><p>答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问<br>外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情<br>况，让人家吃惊。<br>16. Anonymous Inner Class (匿名内部类) 是否可继承其它类，是否可以 implements 接<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>口?<br>可以继承其他类或实现其他接口。不仅是可以，而是必须!因为匿名内部类就是在抽象类和<br>接口的基础上发展起来的。<br>17. class.forName 的作用？<br>调用该访问 返回一个以字符串指定类名的类的对象。<br>返回字节码，返回字节码的方式有几种:<br>①：这份字节码曾经被加载过已经存在 java 虚拟机中了直接返回。<br>②：java 虚拟机中还没有这份字节码 用类加载器去加载 把加载进来的字节码缓存在虚拟机<br>中，以后再得到这个字节码就不用再加载。<br>得到字节码对应的实例对象: 类名.class ; 对象.getClass(),例如 new Date; 类名.class，<br>例如，System.class<br>对 象 .getClass() ， 例 如 ， new Date().getClass() Class.forName( “ 类 名 ” ) ， 例 如 ，<br>Class.forName(“java.util.Date”);<br>③：静态方法去查询或者加载这个字符串所对应哪个类的字节码<br>因为在写源程序的时候还不知道类的名字，在我运行的时候人家传递我一个字符串，这个字<br>符串里面包含了一个类的名字，再写程序的时候把 java.util.Date 换成一个字符串变量， 等<br>程序运行起来的时候这个变量的值从一个配置文件里面装再进来，这个类的名字在写原程序<br>的时候不用知道而是等运行的时候给我临时送进来。<br>》》》》》》》》》》》》》》》》》》》》》》》》》》》《《《《《《《《《《《《《《《《《《《《《《《《《《《《《<br>按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，<br>则返回代表该字节码的 Class 实例对象，否则，按类加载器的委托机制去搜索和加载该类，<br>如果所有的类加载器都无法加载到该类，则抛出 ClassNotFoundException。加载完这个 Class<br>字节码后，接着就可以使用 Class 字节码的 newInstance 方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时<br>才能确定，这时候就需要使用 Class.forName 去动态加载该类，这个类名通常是在配置文件<br>中配置的，例如，spring 的 ioc 中每次依赖注入的具体类就是这样配置的，jdbc 的驱动类名<br>通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类<br>名<br>18. super.getClass()方法调用？<br>下面程序的输出结果是多少？<br>import java.util.Date;<br>public class Test extends Date{<br>public static void main(String[] args) {<br>new Test().test();<br>}<br>public void test(){<br>System.out.println(super.getClass().getName());<br>}<br>}<br>很奇怪，结果是 Test<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>这属于脑筋急转弯的题目，在一个 qq 群有个网友正好问过这个问题，我觉得挺有趣，就研<br>究了一下，没想到今天还被你面到了，哈哈。<br>在 test 方法中，直接调用 getClass().getName()方法，返回的是 Test 类名<br>由于 getClass()在 Object 类中定义成了 final，子类不能覆盖该方法，所以，在 test 方法中调<br>用 getClass().getName()方法，其实就是在调用从父类继承的 getClass()方法，等效于调用<br>super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是 Test。<br>如果想得到父类的名称，应该用如下代码：<br>getClass().getSuperClass().getName();<br>19. String 是最基本的数据类型吗?<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型，因此不可继承这个类、不能修改这个类。为提高效率节省空<br>间，我们应用 StringBuffer 类。<br>20. String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的 String 对象中的内容<br>到底变了没有？<br>没有。因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。这段<br>代码中，s 原先指向一个 String 对象，内容是 “Hello”，然后我们对 s 进行了+操作，那么 s<br>所指向那个对象是否发生了改变呢？答案是没有。这时，s 不指向原来那个对象，而指向了<br>另一个 String 对象，内容为”Hello world!”，原来那个对象还存在于内存中，只是 s 这个引用<br>变量不再指向它了。<br>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，<br>或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。因为<br>String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来<br>表示。这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生<br>成一个新的对象。并且，这两种类的对象转换十分容易。<br>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如<br>我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这<br>样做：<br>public class Demo {<br>private String s;<br>public Demo() {<br>s &#x3D; “Initial Value”;<br>}<br>}<br>而非 s &#x3D; new String(“Initial Value”);<br>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String<br>对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，<br>多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。<br>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表<br>同一个 String 对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是<br>否相同。<br>至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多<br>Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变<br>类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不<br>同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一<br>个可变版本，即 StringBuffer。<br>21. 是否可以继承 String 类?<br>String 类是 final 类故不可以继承. 55. String s &#x3D; new String(“xyz”);创建了几个 String Object? 二者之间有什么区别？<br>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多<br>少遍，都是缓冲区中的那一个。New String 每写一遍，就创建一个新的对象，它一句那个常<br>量”xyz”对象的内容来创建出一个新 String 对象。如果以前就用过’xyz’，这句代表就不会创<br>建”xyz”自己了，直接从缓冲区拿。<br>22. String 和 StringBuffer 的区别？<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多个<br>字符的字符数据。这个 String 类提供了数值不可改变的字符串。而这个 StringBuffer 类提供<br>的字符串进行修改。当你知道字符数据要改变的时候你就可以使用 StringBuffer。典型地，<br>你可以使用 StringBuffers 来动态构造字符数据。另外，String 实现了 equals 方法，new<br>String(“abc”).equals(new String(“abc”)的结果为 true,而 StringBuffer 没有实现 equals 方法，所<br>以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为 false。接着要举一个具<br>体的例子来说明，我们要把 1 到 100 的所有数字拼起来，组成一个串。<br>StringBuffer sbf &#x3D; new StringBuffer();<br>for(int i&#x3D;0;i&lt;100;i++){<br>sbf.append(i);<br>}<br>上面的代码效率很高，因为只创建了一个 StringBuffer 对象，而下面的代码效率很低，因为<br>创建了 101 个对象。<br>String str &#x3D; new String();<br>for(int i&#x3D;0;i&lt;100;i++){<br>str &#x3D; str + i;<br>}<br>在讲两者区别时，应把循环的次数搞成 10000，然后用 endTime-beginTime 来比较两者执行<br>的时间差异，最后还要讲讲 StringBuilder 与 StringBuffer 的区别。<br>String 覆盖了 equals 方法和 hashCode 方法，而 StringBuffer 没有覆盖 equals 方法和 hashCode<br>方法，所以，将 StringBuffer 对象存储进 Java 集合类中时会出现问题。<br>23. 如何把一段逗号分割的字符串转换成一个数组?<br>如果不查 jdk api，我很难写出来！我可以说说我的思路：用正则表达式，代码大概为：<br>String [] result &#x3D; orgStr.split(“,”);<br>用 StingTokenizer ,代码为：StringTokenizer tokener &#x3D; StringTokenizer(orgStr,”,”);<br>String [] result &#x3D; new String[tokener .countTokens()];<br>Int i&#x3D;0;<br>while(tokener.hasNext(){result[i++]&#x3D;toker.nextToken();}<br>24. 数组有没有 length()这个方法? String 有没有 length()这个方法？<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>数组没有 length()这个方法，有 length 的属性。String 有有 length()这个方法。<br>25. 下面这条语句一共创建了多少个对象：String s&#x3D;”a”+”b”+”c”+”d”？<br>答：对于如下代码：<br>String s1 &#x3D; “a”;<br>String s2 &#x3D; s1 + “b”;<br>String s3 &#x3D; “a” + “b”;<br>System.out.println(s2 &#x3D;&#x3D; “ab”);<br>System.out.println(s3 &#x3D;&#x3D; “ab”);<br>第一条语句打印的结果为 false，第二条语句打印的结果为 true，这说明 javac 编译可以对字<br>符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译<br>时去掉其中的加号，直接将其编译成一个这些常量相连的结果。<br>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所<br>以，上面的代码应该只创建了一个 String 对象。写如下两行代码，<br>String s &#x3D; “a” + “b” + “c” + “d”;<br>System.out.println(s &#x3D;&#x3D; “abcd”);<br>最终打印的结果应该为 true。<br>26. try {}里有一 return 语句，那紧跟在这个 try 后的 finally {}里的 code 是否被执行，什<br>么时候被执行，在 return 前还是后?<br>也许你的答案是在 return 之前，但往更细地说，我的答案是在 return 中间执行，请看下面程<br>序代码的运行结果：<br>public class Test {<br>public static void main(String[] args) {<br>System.out.println(new Test().test());<br>}<br>static int test(){<br>int x &#x3D; 1;<br>try{<br>return x;<br>}<br>finally{<br>++x;<br>}<br>}<br>}<br>运行结果是 1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐<br>子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓<br>返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说<br>这话之前放进罐子里的。<br>29. error 和 exception 有什么区别?<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程<br>序运行正常，从不会发生的情况。<br>Error 表示有 JVM 进行处理的,是 JVM 出错. Exctption 是可以用程序进行处理的,使用 try…catch 进行处理. 65. Java 中的异常处理机制的简单原理和应用。<br>异常是指 java 程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很<br>相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个<br>对象来表示，Java 使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封<br>装到一个对象来表示的，该对象中包含有异常的信息。<br>Java 对异常进行了分类，不同类型的异常分别用不同的 Java 类表示，所有异常的根类为<br>java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception，Error 表示应<br>用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程<br>死锁等系统问题。Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普<br>通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问<br>题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者<br>让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常<br>（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化<br>或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样<br>的异常后，程序不应该死掉。<br>java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处<br>理或用 throws 声明继续抛给上层调用方法处理，所以普通异常也称为 checked 异常，而系统<br>异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用 throws 声明，所以<br>系统异常也称为 unchecked 异常。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉<br>的错误，程序不应该死掉的错误；<br>30. 请写出你最常见到的 5 个 runtime exception。<br>这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面<br>的异常，你不一定真要回答出 5 个具体的系统异常，但你要能够说出什么是系统异常，以及<br>几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，<br>那就用中文吧，有总比没有强！<br>所 谓 系 统 异 常 ， 就 是 ….. ， 它 们 都 是 RuntimeException 的 子 类 ， 在 jdk doc 中 查<br>RuntimeException 类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比<br>较 有 印 象 的 系 统 异 常 有 ： NullPointerException 、 ArrayIndexOutOfBoundsException 、<br>ClassCastException。<br>31. java 如何进行异常处理，throws,throw,try,catch,finally 代表什么意义？在 try 块中可<br>以抛出异常吗？<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。<br>在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到<br>这个异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一<br>个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来<br>处理；<br>try 用来指定一块预防所有“异常”的程序；<br>catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的类型；<br>throw 语句用来明确地抛出一个“异常”；<br>throws 用来标明一个成员函数可能抛出的各种“异常”；<br>finally 为确保一段代码不管发生什么“异常”都被执行一段代码；<br>可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try 语<br>句保护其他代码。每当遇到一个 try 语句，“异常”的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇<br>到有处理这种“异常”的 try 语句。<br>32. 在 java 中如何进行 socket 编程。<br>答：Sockets 有两种主要的操作方式:面向连接的和无连接的。<br>无连接的操作使用数据报协议.这个模式下的 socket 不需要连接一个目的的 socket,它只是简<br>单地投出数据报.无连接的操作是快速的和高效的,但是数据安全性不佳.面向连接的操作使<br>用 TCP 协议.一个这个模式下的 socket 必须在发送数据之前与目的地的 socket 取得一个连接. 一旦连接建立了,sockets 就可以使用一个流接口:打开-读-写-关闭.所有的发送的信息都会在<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>另一端以同样的顺序被接收.面向连接的操作比无连接的操作效率更低,但是数据的安全性更<br>高. 在服务器，使用 ServerSocket 监听指定的端口，端口可以随意指定（由于 1024 以下的端口<br>通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于 1024 的端口），<br>等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。在客户端，使用<br>Socket 对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话<br>完成后，关闭 Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个 1024<br>以上的端口。<br>40. 线程的基本概念、线程的基本状态以及状态之间的关系<br>一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程<br>上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，<br>即 main 方法执行的那个线程。如果只是一个 cpu，它怎么能够同时执行多段程序呢？这是<br>从宏观上来看的，cpu 一会执行 a 线索，一会执行 b 线索，切换时间很快，给人的感觉是 a,b<br>在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一<br>会为 a 传数据，一会为 b 传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。<br>状态：就绪，运行，synchronize 阻塞，wait 和 sleep 挂起，结束。wait 必须在 synchronized<br>内部调用。<br>调用线程的 start 方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状<br>态，遇到 synchronized 语句时，由运行状态转为阻塞，当 synchronized 获得锁后，由阻塞转<br>为运行，在这种情况可以调用 wait 方法转为挂起状态，当线程关联的代码执行完后，线程<br>变为结束状态。<br>44. 介绍 Collection 框架的结构<br>答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。<br>Collection<br>├List<br>│├LinkedList<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>│├ArrayList<br>│└Vector<br>│ └Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap<br>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素<br>（Elements）<br>Map 提供 key 到 value 的映射<br>45. Collection 框架中实现比较要实现什么接口<br>comparable&#x2F;comparator<br>46. ArrayList 和 Vector 的区别<br>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存<br>储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位<br>置索引号取出某个元素，并且其中的数据是允许重复的，这是 HashSet 之类的集合的最大不<br>同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本<br>来题目问的与 hashset 没有任何关系，但为了说清楚 ArrayList 与 Vector 的功能，我们使用对<br>比方式，更有利于说明问题）。<br>接着才说 ArrayList 与 Vector 的区别，这主要包括两个方面：. （1）同步性：<br>Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安<br>全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用<br>ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是<br>使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。<br>(备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全问题，记住 Vector 与<br>Hashtable 是旧的，是 java 一诞生就提供的，它们是线程安全的，ArrayList 与 HashMap 是 java2<br>时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。)<br>（2）数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量<br>时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加一个<br>存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率<br>之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没<br>有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始<br>的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方<br>法。<br>总结：即 Vector 增长原来的一倍，ArrayList 增加原来的 0.5 倍。<br>49. List, Set, Map 是否继承自 Collection 接口?<br>List，Set 是，Map 不是<br>50. List、Map、Set 三个接口，存取元素时，各有什么特点？<br>这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内<br>容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不<br>明白。<br>首先，List 与 Set 具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接<br>口，叫 Collection。Set 里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不<br>是仅仅是相同）的对象 ，即假设 Set 集合中有了一个 A 对象，现在我要向 Set 集合再存入<br>一个 B 对象，但 B 对象与 A 对象 equals 相等，则 B 对象存储不进去，所以，Set 集合的 add<br>方法有一个 boolean 的返回值，当集合中没有某个元素，此时 add 方法可成功加入该元素时，<br>则返回 true，当集合含有与某个元素 equals 相等的元素时，此时 add 方法无法加入该元素，<br>返回结果为 false。Set 取元素时，没法说取第几个，只能以 Iterator 接口取得所有的元素，<br>再逐一遍历各个元素。<br>List 表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我<br>们多次调用 add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>到的顺序排序。有时候，也可以插队，即调用 add(int index,Obj e)方法，就可以指定当前对<br>象在集合中的存放位置。一个对象可以被反复存储进 List 中，每调用一次 add 方法，这个对<br>象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用<br>一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指向了<br>这个对象，如图 x 所示。List 除了可以以 Iterator 接口取得所有的元素，再逐一遍历各个元<br>素之外，还可以调用 get(index i)来明确说明取第几个。<br>Map 与 List 和 Set 不同，它是双列的集合，其中有 put 方法，定义如下：put(obj key,obj value)，<br>每次存储时，要存储一对 key&#x2F;value，不能存储重复的 key，这个重复的规则也是按 equals<br>比较相等。取则可以根据 key 获得相应的 value，即 get(Object key)返回值为 key 所对应的<br>value。另外，也可以获得所有的 key 的结合，还可以获得所有的 value 的结合，还可以获得<br>key 和 value 组合成的 Map.Entry 对象的集合。<br>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存<br>key-value 值，value 可多值。<br>HashSet 按照 hashcode 值的某种运算方式进行存储，而不是直接按 hashCode 值的大小进行<br>存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65 在 hashSet 中的存储顺序不是 62,65,78，<br>LinkedHashSet 按插入的顺序存储，那被存储对象的 hashcode 方法还有什么作用呢？我们想<br>想!hashset 集合比较两个对象是否相等，首先看 hashcode 方法是否相等，然后看 equals 方法<br>是否相等。new 两个 Student 插入到 HashSet 中，看 HashSet 的 size，实现 hashcode 和 equals<br>方法后再看 size。<br>同一个对象可以在 Vector 中加入多次。往集合里面加元素，相当于集合里用一根绳子连接<br>到了目标对象。往 HashSet 中却加不了多次的。<br>51. 说出 ArrayList,Vector, LinkedList 的存储性能和特性<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增<br>加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存<br>操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），<br>通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进<br>行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。<br>LinkedList 也是线程不安全的，LinkedList 提供了一些方法，使得 LinkedList 可以被当作堆<br>栈和队列来使用。<br>52. 去掉一个 Vector 集合中重复的元素<br>Vector newVector &#x3D; new Vector();<br>For (int i&#x3D;0;i&lt;vector.size();i++){<br>Object obj &#x3D; vector.get(i);<br>53. if(!newVector.contains(obj);<br>newVector.add(obj);<br>}<br>还有一种简单的方式，HashSet set &#x3D; new HashSet(vector);<br>54. Collection 和 Collections 的区别。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>Collection： 是集合类的上级接口，继承与他的接口主要有 Set 和 List. Collections：是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、<br>排序、线程安全化等操作。<br>55. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是<br>equals()? 它们有何区别?<br>Set 里的元素是不能重复的，元素重复与否是使用 equals()方法进行判断的。<br>equals()和&#x3D;&#x3D;方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个分<br>离的对象的内容和类型相配的话，返回真值。<br>56. 链表和数组的区别？<br>创建数组时，必须明确说明数组的长度,(即数组中元素的个数),以便在内存中留出一块空间<br>存放所有的数组元素,数组中各数据元素在内存中是顺序存放的。<br>创建链表时，不需要给出链表中元素(称为节点)的个数,可以先只创建一个链表头,其他元素<br>在需要时动态地创建并加入到链表,链表的数据无素在内存中不是连续存放的。<br>57. 你所知道的集合类都有哪些？主要方法？<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变<br>大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索<br>引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），<br>其中每个键映射到一个值。<br>ArrayList&#x2F;VectorList<br>Collection<br>HashSet&#x2F;TreeSetSet<br>PropetiesHashTable<br>Map<br>Treemap&#x2F;HashMap<br>我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，<br>我记得不是很清楚，对于 set，大概的方法是 add,remove, contains；对于 map，大概的方法<br>就是 put,remove，contains 等，因为，我只要在 eclispe 下按点操作符，很自然的这些方法就<br>出来了。我记住的一些思想就是 List 类会有 get(int index)这样的方法，因为它可以按顺序取<br>元素，而 set 类中没有 get(int index)这样的方法。List 和 set 都可以迭代出所有元素，迭代时<br>先要得到一个 iterator 对象，所以，set 和 list 类都有一个 iterator 方法，用于返回那个 iterator<br>对象。map 可以返回三个集合，一个是返回所有的 key 的集合，另外一个返回的是所有 value<br>的集合，再一个返回的 key 和 value 组合成的 EntrySet 对象的集合，map 也有 get 方法，参<br>数是 key，返回值是 key 对应的 value。<br>58. 两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code，这句话对不对?<br>对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode<br>值就必须相等。<br>如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode<br>不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没有理由不实<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>现，通常都会去实现的。<br>59. TreeSet 里面放对象，如同时放入父类和子类实例对象，比较时使用的是父类的<br>compareTo 方法，还是子类的 compareTo 方法，还是抛异常！<br>（应该是没有针对问题的确切的答案，当前的 add 方法放入的是哪个对象，就调用哪个对象<br>的 compareTo 方法，至于这个 compareTo 方法怎么做，就看当前这个对象的类中是如何编写<br>这个方法的）</p><ol start="60"><li><p>说出一些常用的类，包，接口，请各举 5 个<br>要让人家感觉你对 java ee 开发很熟，所以，不能仅仅只列 core java 中的那些东西，要多列<br>你在做 ssh 项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。<br>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer<br>java.util.Date，System，Class，List,HashMap<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>常 用 的 包 ： java.lang java.io java.util<br>java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate<br>常 用 的 接 口 ： Remote List Map Document<br>NodeList ,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate) 、<br>Session(Hibernate),HttpSession</p></li><li><p>java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出<br>他们分别是哪些类？<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于 InputStreamReader<br>OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</p></li><li><p>字节流与字符流的区别<br>要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数<br>据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进<br>行描述，这个抽象描述方式起名为 IO 流，对应的抽象类为 OutputStream 和 InputStream ，<br>不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。<br>在实际应用中，经常需要把完全是字符的一段文本输出去或读进来，用字节流可以吗？计算<br>机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的<br>字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，<br>我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。<br>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进<br>行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写<br>入底层设备，这为我们向 IO 设别写入或读取字符串提供了一点点方便。<br>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某<br>种编码的字节形式，读取也是反之的道理。<br>讲解字节流与字符流关系的代码案例：</p></li><li><p>描述一下 JVM 加载 class 文件的原理机制?<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的 Java<br>运行时系统组件。它负责在运行时查找和装入类文件的类。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p></li><li><p>heap 和 stack 有什么区别。<br>java 的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会<br>为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结<br>束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。<br>堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new<br>创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final<br>修饰后，放在堆中，而不是栈中。</p></li><li><p>GC 是什么? 为什么要有 GC?<br>GC：垃圾回收，使用 GC 可以进行垃圾空间释放操作。<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘<br>记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动<br>监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存<br>的显示操作方法。</p></li><li><p>垃圾回收的优点和原理。并考虑 2 种回收机制。<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的问<br>题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾<br>回收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收<br>可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的<br>低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进<br>行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回<br>收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。<br>简单答法:将无用的空间对象进行释放. 俩中回收机制:自动回收和手工调用 System.gc()方法,实际上调用 System.gc 就相当于调用了<br>Runtime.getRuntime().gc()方法. 104. 垃圾回收器的基本原理是？垃圾回收器可以马上回收内存吗？如何主动通知虚拟机<br>进行垃圾回收？<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对<br>象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回<br>收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。</p></li><li><p>什么时候用 assert。<br>JDK1.4 之后增加的新关键字——assert，表示断言，即程序执行到某个地方之后值肯定是预<br>计好的；一般开发中很少使用 assert；要想使用断言，就必须使用-ea 参数。<br>assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在<br>实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确<br>的状态下，assert 将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正<br>确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检<br>查通常是关闭的。</p></li><li><p>java 中会存在内存泄漏吗，请简单描述。<br>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java 中有垃圾<br>回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被<br>垃圾回收器从内存中清除掉。由于 Java 使用有向图的方式进行垃圾回收管理，可以消除引<br>用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可<br>以回收它们的，例如下面的代码可以看到这种情况的内存回收：</p></li></ol><p>java 中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存<br>泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不<br>能被回收，这就是 java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对<br>象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃<br>圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了<br>一个对象放在缓存中(例如放在一个全局 map 对象中)，然后一直不再使用它，这个对象一直<br>被缓存引用，但却不再被使用。<br>检查 java 中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某<br>个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。<br>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引<br>用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外<br>部类对象将不会被垃圾回收，这也会造成内存泄露。<br>下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，<br>而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中<br>消失，将那个元素所在的位置的值设置为 null 即可）：<br>我实在想不到比那个堆栈更经典的例子了,以致于我还要引用别人的例子，下面的例子不是<br>我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可<br>是那时我说是我自己想到的也没有人相信的。</p><p>上面的原理应该很简单，假如堆栈加了 10 个元素，然后全部弹出来，虽然堆栈是空的，没<br>有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，<br>无法回收。<br>但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪<br>费了几个 K 内存而已，反正我们的内存都上 G 了，哪里会有什么影响，再说这个东西很快<br>就会被回收的，有什么关系。下面看两个例子。<br>例子 1</p><p>因为是 static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果<br>你的 Stack 最多有 100 个对象，那么最多也就只有 100 个对象无法被回收其实这个应该很容<br>易理解，Stack 内部持有 100 个引用，最坏的情况就是他们都是无用的，因为我们一旦放新<br>的进取，以前的引用自然消失！<br>内存泄露的另外一种情况：当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合<br>中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的<br>参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet<br>集合中单独删除当前对象，造成内存泄露。<br>70. 能不能自己写个类，也叫 java.lang.String？<br>可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去<br>加载 jre.jar 包中的那个 java.lang.String。由于在 tomcat 的 web 应用程序中，都是由 webapp<br>自己的类加载器先自己加载 WEB-INF&#x2F;classess 目录中的类，然后才委托上级的类加载器加<br>载，如果我们在 tomcat 的 web 应用程序中写一个 java.lang.String，这时候 Servlet 程序加载<br>的就是我们自己写的 java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了<br>java.lang.String 类的都将出现问题。<br>虽然 java 提供了 endorsed 技术，可以覆盖 jdk 中的某些类，具体做法是….。但是，能够被<br>覆盖的类是有限制范围，反正不包括 java.lang 这样的包中的类。<br>（下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题<br>目泄露了）例如，运行下面的程序：<br>package java.lang;<br>public class String {<br>public static void main(String[] args) {<br>System.out.println(“string”);<br>}<br>}<br>报告的错误如下：<br>java.lang.NoSuchMethodError: main<br>Exception in thread “main” 这是因为加载了 jre 自带的 java.lang.String，而该类中没有 main 方法。 二、Java 代码查错<br>abstract class Name {<br>private String name;<br>public abstract boolean isStupidName(String name) {}<br>}<br>大侠们，这有何错误?<br>答案: 错。abstract method 必须以分号结尾，且不带花括号。<br>2.public class Something {<br>void doSomething () {<br>private String s &#x3D; “”;<br>int l &#x3D; s.length();<br>}<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有错吗?<br>答案: 错。局部变量前不能放置任何访问修饰符 (private，public，和 protected)。final 可以<br>用来修饰局部变量<br>(final 如同 abstract 和 strictfp，都是非访问修饰符，strictfp 只能修饰 class 和 method 而非<br>variable)。<br>3.abstract class Something {<br>private abstract String doSomething ();<br>}<br>这好像没什么错吧?<br>答案: 错。abstract 的methods不能以private修饰。abstract的 methods就是让子类 implement(实<br>现)具体细节的，怎么可以用 private 把 abstract<br>method 封锁起来呢? (同理，abstract method 前不能加 final)。<br>4.public class Something {<br>public int addOne(final int x) {<br>return ++x;<br>}<br>}<br>这个比较明显。<br>答案: 错。int x 被修饰成 final，意味着 x 不能在 addOne method 中被修改。<br>5.public class Something {<br>public static void main(String[] args) {<br>Other o &#x3D; new Other();<br>new Something().addOne(o);<br>}<br>public void addOne(final Other o) {<br>o.i++;<br>}<br>}<br>class Other {<br>public int i;<br>}<br>和上面的很相似，都是关于 final 的问题，这有错吗?<br>答案: 正确。在 addOne method 中，参数 o 被修饰成 final。如果在 addOne method 里我们修<br>改了 o 的 reference<br>(比如: o &#x3D; new Other();)，那么如同上例这题也是错的。但这里修改的是 o 的 member vairable<br>(成员变量)，而 o 的 reference 并没有改变。<br>6.class Something {<br>int i;<br>public void doSomething() {<br>System.out.println(“i &#x3D; “ + i);<br>}<br>}<br>有什么错呢? 看不出来啊。<br>答案: 正确。输出的是”i &#x3D; 0”。int i 属於 instant variable (实例变量，或叫成员变量)。instant<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>variable 有 default value。int 的 default value 是 0。<br>7.class Something {<br>final int i;<br>public void doSomething() {<br>System.out.println(“i &#x3D; “ + i);<br>}<br>}<br>和上面一题只有一个地方不同，就是多了一个 final。这难道就错了吗?<br>答案: 错。final int i 是个 final 的 instant variable (实例变量，或叫成员变量)。final 的 instant<br>variable 没有 default value，必须在 constructor (构造器)结束之前被赋予一个明确的值。可以<br>修改为”final int i &#x3D; 0;”。<br>8.public class Something {<br>public static void main(String[] args) {<br>Something s &#x3D; new Something();<br>System.out.println(“s.doSomething() returns “ + doSomething());<br>}<br>public String doSomething() {<br>return “Do something …”;<br>}<br>}<br>看上去很完美。<br>答案: 错。看上去在 main 里 call doSomething 没有什么问题，毕竟两个 methods 都在同一个<br>class 里。但仔细看，main 是 static 的。static method 不能直接 call non-static methods。可改<br>成”System.out.println(“s.doSomething() returns “ + s.doSomething());”。同理，static method 不<br>能访问 non-static instant variable。<br>9.此处，Something 类的文件名叫 OtherThing.java<br>class Something {<br>private static void main(String[] something_to_do) {<br>System.out.println(“Do something …”);<br>}<br>}<br>这个好像很明显。<br>答案: 正确。从来没有人说过 Java 的 Class 名字必须和其文件名相同。但 public class 的名字<br>必须和文件名相同。<br>10．interface A{<br>int x &#x3D; 0;<br>}<br>class B{<br>int x &#x3D;1;<br>}<br>class C extends B implements A {<br>public void pX(){<br>System.out.println(x);<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public static void main(String[] args) {<br>new C().pX();<br>}<br>}<br>答案：错误。在编译时会发生错误(错误描述不同的 JVM 有不同的信息，意思就是未明确的<br>x 调用，两个 x 都匹配（就象在同时 import java.util 和 java.sql 两个包时直接声明 Date 一样）。<br>对于父类的变量,可以用 super.x 来明确，而接口的属性默认隐含为 public static final.所以可<br>以通过 A.x 来明确。<br>11.interface Playable {<br>void play();<br>}<br>interface Bounceable {<br>void play();<br>}<br>interface Rollable extends Playable, Bounceable {<br>Ball ball &#x3D; new Ball(“PingPang”);<br>}<br>class Ball implements Rollable {<br>private String name;<br>public String getName() {<br>return name;<br>}<br>public Ball(String name) {<br>this.name &#x3D; name;<br>}<br>public void play() {<br>ball &#x3D; new Ball(“Football”);<br>System.out.println(ball.getName());<br>}<br>}<br>这个错误不容易发现。<br>答案: 错。”interface Rollable extends Playable, Bounceable”没有问题。interface 可继承多个<br>interfaces，所以这里没错。问题出在 interface Rollable 里的”Ball ball &#x3D; new Ball(“PingPang”);”。<br>任何在 interface 里声明的 interface variable (接口变量，也可称成员变量)，默认为 public static<br>final。也就是说”Ball ball &#x3D; new Ball(“PingPang”);”实际上是”public static final Ball ball &#x3D; new<br>Ball(“PingPang”);”。在 Ball 类的 Play()方法中，”ball &#x3D; new Ball(“Football”);”改变了 ball 的<br>reference，而这里的 ball 来自 Rollable interface，Rollable interface 里的 ball 是 public static final<br>的，final 的 object 是不能被改变 reference 的。因此编译器将在”ball &#x3D; new Ball(“Football”);” 这里显示有错。 三、算法与编程<br>71. 用 java 实现一种排序；java 类实现序列化的方法(二种)？ 如在 collection 框架中，<br>实现比较要实现什么样的接口？</p><p>JAVA 类实现序例化的方法是实现 java.io.Serializable 接口<br>Collection 框架中实现比较要实现 Comparable 接口和 Comparator 接口<br>127. 说说你用过那些 ajax 技术和框架，说说它们的区别<br>答:去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存<br>五、Java web 部分<br>128. Tomcat 的优化经验<br>答:去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。<br>有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存<br>129. HTTP 的请求过程？<br>当点击一个链接时,浏览器首先找到站点的 IP 地址,这是通过 DNS 来实现的,在找到 IP 地址后<br>就可以建立 TCP 连接了,连接建立后我们就可以发送请求了.但这个请求是什么样子的呢 ?<br>我们现在假设点击了一个从 <a target="_blank" rel="noopener" href="http://www.webmonkey.com/HTML/96/47/Index2A">www.webmonkey.com/HTML/96/47/Index2A</a> , HTML 点击了<br><a href="WWW.GRIPY.ORG/MATTARG/">WWW.GRIPY.ORG/MATTARG/</a> 这时浏览器会发出下面的请求:<br>Get&#x2F;MATTARG&#x2F;HTML&#x2F;1.0<br>User-Agent: Mozilla&#x2F;2.0(macitosh;1;PPC)<br>Accept: text&#x2F;html: <em>&#x2F;</em> Cookie: name &#x3D; value<br>Refetet: <a target="_blank" rel="noopener" href="http://www.webmonkey.com/html/96/47/index2a.html">http://www.webmonkey.com/html/96/47/index2a.html</a><br>Host: <a target="_blank" rel="noopener" href="http://www.gtippy.org/">www.gtippy.org</a><br>第一行称为请求,它告诉服务器从 MATTMARG 取得文件,这是的目录一般是要加 &#x2F; 的,下面<br>几行通知服务器你所使用的浏览器是什么类型,你所接收的数据是什么类型,如果你以前访问<br>过这个站点,站点可能向你发送了 Cookie ,如果你已经有了一个这样的 Cookie ,浏览器会将<br>这个 Cookie 返回给服务器, referer 行通知服务器用户从哪一页到达此页的. 下面服务器就要返回文件了,每次服务器返回文件时,都要返回一个 Http&#x2F;1.0 响应,同进带有<br>状态码,在此之后是述内部的头信息,下面就是一个响应:<br>HTTP&#x2F;1.0 200 Pound<br>Data: Mon 10 Feb 1997 23:48:22 GMT<br>Server: Apache&#x2F;1.1 1 Hot&amp;ired&#x2F;1.0<br>Content-type: text&#x2F;html<br>Last-Moditied: Tues,11 Feb 1997 22:45:55 GMT<br>不同的数据可能返回不同的 Content-type ，因此不同的内容需要不同的 Content-type ，因<br>此有时候这个过程是很慢的。<br>130. HTTP 请求的 GET 与 POST 方式的区别<br>答：Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST<br>方法。二者主要区别如下：<br>1）Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据；<br>2）Get 将表单中数据按照 variable&#x3D;value 的形式，添加到 action 所指向的 URL 后面，<br>并且两者使用“?”连接，而各个变量之间使用“&amp;”连接；Post 是将表单中的数据放在 form<br>的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL；<br>3）Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中；Post 的所有操作对<br>用户来说都是不可见的；<br>4）Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，<br>所以在上传文件只能使用 Post；<br>5）Get 限制 Form 表单的数据集必须为 ASCII 字符，而 Post 支持整个 ISO10646 字符集；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>6）Get 是 Form 的默认方法。<br>131. 解释一下什么是 servlet？<br>Servlet 是一种独立于平台和协议的服务器端的 Java 技术，可以用来生成动态的 Web 页面。<br>与传统的 CGI（计算机图形接口）和许多其他类似 CGI 技术相比，Servlet 具有更好的可移<br>植性、更强大的功能，更少的投资，更高的效率，更好的安全性等特点。<br>Servlet 是使用 Java Servlet 应用程序接口（API）及相关类和方法的 Java 程序。Java 语言<br>能够实现的功能，Servlet 基本上都能实现（除了图形界面之外）。Servlet 主要用于处理客<br>户端传来的 Http 请求，并返回一个响应。通常所说的 Servlet 就是指 HttpServlet，用于处理<br>Http 请求，其能够处理的请求有 doGet()、doPost()、service()等方法。在开发 Servlet 时，可<br>以直接继承 javax.servlet.http.HttpServlet。<br>Servlet 需要在 web.xml 中进行描述，例如：映射执行 Servlet 的名字，配置 Servlet 类、初<br>始化参数，进行安全配置、URL 映射和设置启动的优先权等。Servlet 不仅可以生成 HTML<br>脚本输出，也可以生成二进制表单输出。<br>Servlet 应用范围很广泛，我们现在用的很多流行的框架技术，其最基本的代码离不开<br>Servelt 的支持。比如我所熟悉的 SSH 框架，Spring 容器启动时，要在 web.xml 中装载 Spring<br>容器的 ActionContext 类来初始化 Spring 的一些参数，如进行依赖注入、数据库表的映射、<br>初始化系统的安全配置设置 read 等属性等一些相关操作。<br>132. 说一说 Servlet 的生命周期?<br>答:servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。<br>这个生存期由 javax.servlet.Servlet 接口的 init,service 和 destroy 方法表达。<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service<br>方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销<br>毁的时候调用其 destroy 方法。<br>web 容器加载 servlet，生命周期开始。通过调用 servlet 的 init()方法进行 servlet 的初始化。<br>通过调用 service()方法实现，根据请求的不同调用不同的 do***()方法。结束服务，web 容<br>器调用 servlet 的 destroy()方法。<br>133. Servlet 的基本架构<br>package test;<br>import java.io.IOException;<br>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>public class ServletName extends HttpServlet {<br>public void doPost(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public void doGet(HttpServletRequest request, HttpServletResponse response)<br>throws ServletException, IOException {<br>}<br>}<br>134. SERVLET API 中 forward()与 redirect()的区别？<br>答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后<br>者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的<br>地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量<br>使用 forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳<br>转到一个其它服务器上的资源，则必须使用 sendRedirect()方法。<br>135. 什么情况下调用 doGet()和 doPost()？<br>Jsp 页面中的 FORM 标签里的 method 属性为 get 时调用 doGet()，为 post 时调用 doPost()。<br>136. Request 对象的主要方法：<br>setAttribute(String name,Object)：设置名字为 name 的 request 的参数值<br>getAttribute(String name)：返回由 name 指定的属性值<br>getAttributeNames()：返回 request 对象所有属性的名字集合，结果是一个枚举的实例<br>getCookies()：返回客户端的所有 Cookie 对象，结果是一个 Cookie 数组<br>getCharacterEncoding()：返回请求中的字符编码方式<br>getContentLength()：返回请求的 Body 的长度<br>getHeader(String name)：获得 HTTP 协议定义的文件头信息<br>getHeaders(String name)：返回指定名字的 request Header 的所有值，结果是一个枚举的实例<br>getHeaderNames()：返回所以 request Header 的名字，结果是一个枚举的实例<br>getInputStream()：返回请求的输入流，用于获得请求中的数据<br>getMethod()：获得客户端向服务器端传送数据的方法<br>getParameter(String name)：获得客户端传送给服务器端的有 name 指定的参数值<br>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实<br>例<br>getParametervalues(String name)：获得有 name 指定的参数的所有值<br>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称<br>getQueryString()：获得查询字符串<br>getRequestURI()：获取发出请求字符串的客户端地址<br>getRemoteAddr()：获取客户端的 IP 地址<br>getRemoteHost()：获取客户端的名字<br>getSession([Boolean create])：返回和请求相关 Session<br>getServerName()：获取服务器的名字<br>getServletPath()：获取客户端所请求的脚本文件的路径<br>getServerPort()：获取服务器的端口号<br>removeAttribute(String name)：删除请求中的一个属性<br>137. 简述 HttpSession 的作用、使用方法，可用代码说明。<br>HttpSession 中 可 以 跟 踪 并 储 存 用 户 信 息 ， 把 值 设 置 到 属 性 中 ， 有 2 个 方 法 ：<br>setAttribute(),getAttrribute()；<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>例如：在一个方法中用 session.setAttribute(“student”,student);在 session 中设置一个属性名为<br>student,值为一个名为 student 的对象。而后可在同一 session 范围内用 getAttribute(“student”)<br>取出该属性，得到 student 对象。<br>138. 请画出 Servlet 2.2 以上 Web Application 的基本目录结构<br>答：目录结构如下图所示：<br>webapps<br>|<br>Applocation<br>| __________________<br>| |<br>JSP 页面 WEB-INF<br>| ___________________<br>| | |<br>classes lib web.xml<br>139. cookie 和 session 的区别？<br>注意 cookie 有时候禁不掉<br>Cookie session<br>存储在客户端 存储在服务器端<br>两种类型<br>有声明周期<br>无声明周期<br>两种实现方式<br>依赖于 cookie<br>url 重写<br>父路径不能访问子路径的 cookie 同一个 session 的窗口共享一个 session<br>典型应用：<br>3 个月不用再登陆<br>购物车（<a target="_blank" rel="noopener" href="http://www.china-pub.com/%EF%BC%89">http://www.china-pub.com/）</a><br>典型应用：<br>用户登陆<br>购物车也可以用 session 实现。·<br>不可靠 可靠<br>140. forward 和 redirect 的区别<br>forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读<br>取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，<br>所以它的地址栏中还是原来的地址。<br>redirect 就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏<br>览器会用刚才请求的所有参数重新请求，所以 session,request 参数都可以获取。<br>141. request.getAttribute() 和 request.getParameter() 有何区别?<br>当你要传递普通的数据类型给下一个页面时，你在下一个页面中就可以用 getParameter()方<br>法来获得上一个页面传递过来的数据了！（普通的数据类型是指 int,float,double,string 等在<br>Java 中常用的基本类型，但是在下一个页面中你用 getParameter()方法获得的值永远只能时<br>String 类型的，你可以把 String 类型转换为你所需要的类型！）<br>当你要传递一个对象给下一个页面时，你就要使用 getAttribut()方法了！如：你要把一个 List<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>或 Map 传递到下一个页面，这时你就必须要用 setAttribut()和 getAttribut()方法传递数据了！<br>从更深层次的考虑，getParameter()方法传递数据，只会从 WEB 客户端传递到 WEB 服务器，<br>代表 HTTP 请求数据，getParameter()方法返回 String 类型的数据！setAttribut()和 getAttribut()<br>方法传递的数据只会在 WEB 服务器内部，在具有转发关系的 WEB 组件之间传递，这两个<br>方法能设置 Object 类型的共享数据！<br>142. jsp 有哪些内置对象?作用分别是什么? 分别有什么方法？<br>答:JSP 共有以下 9 个内置的对象：<br>request 用户端请求，此请求会包含来自 GET&#x2F;POST 请求的参数<br>response 网页传回用户端的回应<br>pageContext 网页的属性是在这里管理<br>session 与请求有关的会话期<br>application servlet 正在执行的内容<br>out 用来传送回应的输出<br>config servlet 的构架部件<br>page JSP 网页本身<br>exception 针对错误网页，未捕捉的例外<br>request：表示 HttpServletRequest 对象。它包含了有关浏览器请求的信息，并且提供了几个<br>用于获取 cookie, header, 和 session 数据的有用的方法。<br>response：表示 HttpServletResponse 对象，并提供了几个用于设置送回 浏览器的响应的方法<br>（如 cookies,头信息等）<br>out：对象是 javax.jsp.JspWriter 的一个实例，并提供了几个方法使你能用于向浏览器回送输<br>出结果。<br>pageContext：表示一个 javax.servlet.jsp.PageContext 对象。它是用于方便存取各种范围的名<br>字空间、servlet 相关的对象的 API，并且包装了通用的 servlet 相关功能的方法。<br>session：表示一个请求的 javax.servlet.http.HttpSession 对象。Session 可以存贮用户的状态信<br>息<br>applicaton ：表示一个 javax.servle.ServletContext 对象。这有助于查找有关 servlet 引擎和<br>servlet 环境的信息<br>config：表示一个 javax.servlet.ServletConfig 对象。该对象用于存取 servlet 实例的初始化参<br>数。<br>page：表示从该页面产生的一个 servlet 实例<br>143. 介绍在 JSP 中如何使用 JavaBeans？<br>答：在 JSP 中使用 JavaBean 常用的动作有：<br>1）&lt;jsp:useBean &#x2F;&gt;：用来创建和查找 bean 对象；<br>2）&lt;jsp:setProperty &#x2F;&gt;：用来设置 bean 的属性，即调用其 setXxx()方法；<br>3）&lt;jsp:getProperty &#x2F;&gt;：用来获得 bean 的属性，即调用其 getXxx()方法。<br>144. jsp 有哪些动作?作用分别是什么?<br>（这个问题似乎不重要，不明白为何有此题）<br>答:JSP 共有以下 6 种基本动作<br>jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>jsp:setProperty：设置 JavaBean 的属性。<br>jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记<br>145. JSP 的常用指令<br>isErrorPage(是否能使用 Exception 对象)，isELIgnored(是否忽略表达式)<br>146. jsp 的四种范围？<br>答：a.page 是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类<br>（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括<br>被编译成 servlet 的 JSP 页面<br>b.request 是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越<br>多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系）<br>c.session 是代表与用于某个 Web 客户机的一个用户体验相关对象和属性。一个 Web<br>会话可以也经常会跨越多个客户机请求<br>d.application 是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个<br>Web 应用程序，包括多个页面、请求和会话的一个全局作用域。<br>147. JSP 中动态 INCLUDE 与静态 INCLUDE 的区别？<br>答：动态 INCLUDE 用 jsp:include 动作实现<br>&lt;jsp:include page&#x3D;included.jsp flush&#x3D;true &#x2F;&gt;它总是会检查所含文件中的变化，适合用于包含动<br>态页面，并且可以带参数 静态 INCLUDE 用 include 伪码实现,定不会检查所含文件的变化，<br>适用于包含静态页面 &lt;%@ include file&#x3D;included.htm %&gt;<br>148. 两种跳转方式分别是什么?有什么区别?<br>（下面的回答严重错误，应该是想问 forward 和 sendRedirect 的区别，毕竟出题的人不是专<br>业搞文字艺术的人，可能表达能力并不见得很强，用词不一定精准，加之其自身的技术面也<br>可能存在一些问题，不一定真正将他的意思表达清楚了，严格意思上来讲，一些题目可能根<br>本就无人能答，所以，答题时要掌握主动，只要把自己知道的表达清楚就够了，而不要去推<br>敲原始题目的具体含义是什么，不要一味想着是在答题）<br>答：有两种，分别为：<br>&lt;jsp:include page&#x3D;included.jsp flush&#x3D;true&gt;<br>&lt;jsp:forward page&#x3D; nextpage.jsp&#x2F;&gt;<br>前者页面不会转向 include 所指的页面，只是显示该页的结果，主页面还是原来的页面。执<br>行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。<br>相当于 go to 语句. 149. 页面间对象传递的方法<br>request，session，application，cookie 等<br>150. 过滤器有哪些作用？<br>答：可以验证客户是否来自可信的网络，可以对客户提交的数据进行重新编码，可以从系统<br>里获得配置的信息，可以过滤掉客户的某些不应该出现的词汇，可以验证用户是否登录，可<br>以验证客户的浏览器是否支持当前的应用，可以记录系统的日志等等。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>151. 过滤器的用法？（对客户端的请求统一编码和对客户端进行认证）<br>答：首先要实现（implements）Filter 接口，同时覆盖 Filter 接口的三个方法：<br>init(FilterConfig config) &#x2F;&#x2F;用于获得 FilterConfig 对象；<br>doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &#x2F;&#x2F;进行过滤处<br>理一些业务；<br>destroy() &#x2F;&#x2F;销毁 Filter。<br>152. JSP 和 Servlet 中的请求转发分别如何实现？<br>答：JSP 中的请求转发可利用 forward 动作实现：&lt;jsp:forward &#x2F;&gt;；<br>Serlvet 中实现请求转发的方式为：<br>getServletContext().getRequestDispatcher(path).forward(req,res)。<br>153. JSP 和 Servlet 有哪些相同点和不同点，他们之间的联系是什么？<br>JSP 是 Servlet 技术的扩展，本质上是 Servlet 的简易方式，更强调应用的外表表达。JSP 编<br>译后是”类 servlet”。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件<br>中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成<br>一个扩展名为.jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。<br>154. 详细描述 MVC。<br>答：基于 Java 的 Web 应用系统采用 MVC 架构模式，即 model（模型）、view（视图）、control<br>（控制）分离设计；这是目前 WEB 应用服务系统的主流设计方向。<br>Model：即处理业务逻辑的模块，每一种处理一个模块；<br>View：负责页面显示，显示 MODEL 处理结果给用户，主要实现数据到页面转换过程；<br>Control：负责每个请求的分发，把 FORM 数据传递给 MODEL 处理，把处理结果的数<br>据传递给 VIEW 显示。<br>155. MVC 的各个部分都有那些技术来实现?如何实现?<br>答:MVC 是 Model－View－Controller 的简写。Model 代表的是应用的业务逻辑（通过<br>JavaBean，EJB 组件实现）， View 是应用的表示面（由 JSP 页面产生），Controller 是提<br>供应用的处理过程控制（一般是一个 Servlet），通过这种设计模型把应用逻辑，处理过程<br>和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。<br>156. 在 web 应用开发过程中经常遇到输出某种编码字符，如 iso8859-1 等，如何输出一个<br>某种编码字符串？<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1”), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>157. 现在输入 n 个数字，以逗号，分开；然后可选择升或者降序排序；按提交键就在另一<br>页面显示按什么排序，结果为，提供 reset.(答案有点疑惑,问题有点不清不楚)<br>答案（1） public static String[] splitStringByComma(String source){<br>if(source&#x3D;&#x3D;null||source.trim().equals(“”))<br>return null;<br>StringTokenizer commaToker &#x3D; new StringTokenizer(source,”,”);<br>String[] result &#x3D; new String[commaToker.countTokens()];<br>int i&#x3D;0;<br>while(commaToker.hasMoreTokens()){<br>result[i] &#x3D; commaToker.nextToken();<br>i++;<br>}<br>return result;<br>}<br>循环遍历 String 数组<br>Integer.parseInt(String s)变成 int 类型<br>组成 int 数组<br>Arrays.sort(int[] a), a 数组升序<br>降序可以从尾部开始输出<br>158. 说出数据连接池的工作机制是什么?<br>答：J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客<br>户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没<br>有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用<br>的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>159. javascript 的优缺点和内置对象。<br>答：1）优点：简单易用，与 Java 有类似的语法，可以使用任何文本编辑工具编写，只需要<br>浏览器就可执行程序，并且事先不用编译，逐行执行，无需进行严格的变量声明，而且内置<br>大量现成对象，编写少量程序可以完成目标；<br>2）缺点：不适合开发大型应用程序；<br>3）Javascript 有 11 种内置对象： Array、String、Date、Math、Boolean、Number、<br>Function、Global、Error、RegExp、Object。 六、数据库部分<br>160. 存储过程和函数的区别<br>存储过程是用户定义的一系列 sql 语句的集合，涉及特定表或其它对象的任务，用户可以调<br>用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉<br>及特定用户表。</p><ol start="162"><li><p>游标的作用？如何知道游标已经到了最后？<br>游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS 可以判断是否到了最后，<br>通常此变量不等于 0 表示出错或到了最后。</p></li><li><p>触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何<br>区别？<br>事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触<br>发器可以获取事件之前和新的字段值。 语句级触发器可以在语句执行前或后执行，而行级<br>触发在触发器所影响的每一行触发一次。</p></li><li><p>存储过程，触发器，范式，事务的概念及作用？<br>存储过程：是数据库管理系统里的一个很重要的对象。用它可以封装一些功能。把多个 SQL<br>语句封装到存储过程里面。起到封装功能的作用。类似面向对象里，封装对象的一个功能一<br>样。几乎任何可写成批处理的 Transact-SQL 代码都可用于创建存储过程。<br>触发器：触发器是在用户进行某项操作的时候，会触发触发器的执行。它类似于 JAVA 中图<br>形截面编程里的事件操作一样，是触发执行。和存储过程的主要区别在于：存储过程类似<br>JAVA 里面的对象一样，进行功能的封装（方法）。在调用的时候才会执行。而触发器只能<br>在别的操作执行的时候才会触发触发器的执行。<br>事务：类似于 JAVA 里面线程的同步一样，作为一个单元执行。它有四大特性：原子性，隔<br>离性，一致性，持久性。在 SQL SERVER 2000 里面还支持存储点的用法。大家都知道，事<br>务是做为一个单元运行，要么全部执行，要么全部不执行。但是有时候我们可以保证事务的<br>一部分可能正确执行，并且这些执行可以直接刷新到数据库里面。那么我们就可以在这个事<br>务的中间部分设置一个或者多个存储点。这样在这个事务大单元里就分成了几个小部分。如<br>果上面的部分执行正确，下面的部分执行错误，那么就没必要回滚整个事务，只需要回滚到<br>存储点的地方就可以了<br>范式：目地：规范化目的是使结构更合理，消除存储异常，使数据冗余尽量小，便于插入、<br>删除和更新<br>原则：遵从概念单一化 “一事一地”原则，即一个关系模式描述一个实体或实体间的一种联<br>系。规范的实质就是概念的单一化。<br>方法：将关系模式投影分解成两个或两个以上的关系模式。<br>要求：分解后的关系模式集合应当与原关系模式”等价”，即经过自然联接可以恢复原关系而<br>不丢失信息，并保持属性间合理联系。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p></li><li><p>写一个 SQL Server 中的存储过程:<br>以下为一个带有一个输入参数 Vdeptno ,返回部门为 Vdeptnor 的所有职员的信息. create procedure Emp_dept<br>@Vdeptno number(2) AS<br>begin<br>select * from emp where deptno&#x3D;@Vdeptno<br>end</p></li><li><p>写一个 Oracle 中的存储过程:<br>带 IN 参数的过程<br>create or replace procedure addnew(dno IN number, name IN varchar2, location IN varchar2)IS<br>begin<br>insert into dept values(dno,name,location);<br>dbms_output.put_line(‘1 record inserted’);<br>end;<br>带 OUT 参数的过程<br>create or replace procedure getsal(name IN varchar2, salary OUT number)AS<br>begin<br>select sal into salary from emp where ename&#x3D;name;<br>end;</p></li><li><p>数据库 SQL 语句题<br>106、有 3 个表（15 分钟）：【基础】<br>Student 学生表 (学号，姓名，性别，年龄，组织部门)<br>Course 课程表 (编号，课程名称)<br>Sc 选课表 (学号，课程编号，成绩)<br>表结构如下：<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>1）写一个 SQL 语句，查询选修了’计算机原理’的学生学号和姓名（3 分钟）<br>2）写一个 SQL 语句，查询’周星驰’同学选修了的课程名字（3 分钟）<br>3）写一个 SQL 语句，查询选修了 5 门课程的学生学号和姓名（9 分钟）<br>答：1）SQL 语句如下：<br>select stu.sno, stu.sname from Student stu<br>where (select count(<em>) from sc where sno&#x3D;stu.sno and cno &#x3D;<br>(select cno from Course where cname&#x3D;’计算机原理’)) !&#x3D; 0;<br>2）SQL 语句如下：<br>select cname from Course<br>where cno in ( select cno from sc where sno &#x3D;<br>(select sno from Student where sname&#x3D;’周星驰’));<br>3）SQL 语句如下：<br>select stu.sno, stu.sname from student stu<br>where (select count(</em>) from sc where sno&#x3D;stu.sno) &#x3D; 5;<br>107、有三张表,学生表 S,课程 C,学生课程表 SC,学生可以选修多门课程,一门课程可以被多个<br>学生选修,通过 SC 表关联。【基础】<br>1）写出建表语句；<br>2）写出 SQL 语句,查询选修了所有选修课程的学生；<br>3）写出 SQL 语句,查询选修了至少 5 门以上的课程的学生。<br>答：1）建表语句如下（mysql 数据库）：<br>create table s(id integer primary key, name varchar(20));<br>create table c(id integer primary key, name varchar(20));<br>create table sc(<br>sid integer references s(id), cid integer references c(id), primary key(sid,cid)<br>);<br>2）SQL 语句如下：<br>select stu.id, stu.name from s stu<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>where (select count(<em>) from sc where sid&#x3D;stu.id) &#x3D; (select count(</em>) from c);<br>3）SQL 语句如下：<br>select stu.id, stu.name from s stu<br>where (select count(*) from sc where sid&#x3D;stu.id)&gt;&#x3D;5;<br>108、数据库表(Test)结构如下：【基础】<br>ID NAME AGE MANAGER(所属主管人 ID)<br>106 A 30 104<br>109 B 19 104<br>104 C 20 111<br>107 D 35 109<br>112 E 25 120<br>119 F 45 NULL<br>要求:列出所有年龄比所属主管年龄大的人的 ID 和名字?<br>答：SQL 语句如下：<br>select employee.name from test employee<br>where employee.age &gt; (select manager.age from test manager<br>where manager.id&#x3D;employee.manager);<br>109、有如下两张表：【中等难度】<br>表 city： 表 state：<br>欲得到如下结果：<br>City No City Name State No State Name<br>BJ 北京 （Null） （Null）<br>DL 大连 LN 辽宁<br>GZ 广州 GD 广东<br>SH 上海 （Null） （Null）<br>写相应的 SQL 语句。<br>答：SQL 语句为：<br>SELECT C.CITYNO, C.CITYNAME, C.STATENO, S.STATENAME<br>FROM CITY C, STATE S<br>WHERE C.STATENO&#x3D;S.STATENO(+)<br>ORDER BY(C.CITYNO);</p></li><li><p>用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。<br>employee:<br>eid,ename,salary,deptid;<br>select * from employee order by deptid desc,salary</p></li><li><p>列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序<br>CityNo CityName StateNo<br>BJ 北京 （Null）<br>SH 上海 （Null）<br>GZ 广州 GD<br>DL 大连 LN<br>State No State Name<br>GD 广东<br>LN 辽宁<br>SD 山东<br>NMG 内蒙古<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>创建表：<br>mysql&gt; create table employee921(id int primary key auto_increment,name varchar(5<br>0),salary bigint,deptid int);<br>插入实验数据：<br>mysql&gt; insert into employee921 values(null,’zs’,1000,1),(null,’ls’,1100,1),(null<br>,’ww’,1100,1),(null,’zl’,900,1) ,(null,’zl’,1000,2), (null,’zl’,900,2) ,(null,’z<br>l’,1000,2) , (null,’zl’,1100,2);<br>编写 sql 语句：<br>（）select avg(salary) from employee921 group by deptid;<br>（）mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 where deptid &#x3D;<br>tid);<br>效率低的一个语句，仅供学习参考使用（在 group by 之后不能使用 where，只能使用<br>having，在 group by 之前可以使用 where，即表示对过滤后的结果分组）：<br>mysql&gt; select employee921.id,employee921.name,employee921.salary,employee921.dep<br>tid tid from employee921 where salary &gt; (select avg(salary) from employee921 group by deptid<br>having deptid &#x3D; tid);<br>（）select count(*) ,tid<br>from (<br>select employee921.id,employee921.name,employee921.salary,employee921.deptid tid<br>from employee921<br>where salary &gt;<br>(select avg(salary) from employee921 where deptid &#x3D; tid)<br>) as t<br>group by tid ;<br>另外一种方式：关联查询<br>select a.ename,a.salary,a.deptid<br>from emp a, (select deptd,avg(salary) avgsal from emp group by deptid ) b<br>where a.deptid&#x3D;b.deptid and a.salary&gt;b.avgsal;</p></li><li><p>存储过程与触发器必须讲，经常被面试到?<br>create procedure insert_Student (_name varchar(50),_age int ,out _id int)<br>begin<br>insert into student value(null,_name,_age);<br>select max(stuId) into _id from student;<br>end;<br>call insert_Student(‘wfz’,23,@id);<br>select @id;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>mysql&gt; create trigger update_Student BEFORE update on student FOR EACH ROW<br>-&gt; select * from student;<br>触发器不允许返回结果<br>create trigger update_Student BEFORE update on student FOR EACH ROW<br>insert into student value(null,’zxx’,28);<br>mysql 的触发器目前不能对当前表进行操作<br>create trigger update_Student BEFORE update on student FOR EACH ROW<br>delete from articles where id&#x3D;8;<br>这个例子不是很好，最好是用删除一个用户时，顺带删除该用户的所有帖子<br>这里要注意使用 OLD.id<br>触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，<br>其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而 UCH<br>没有用触发器，效率和数据处理能力都很低。<br>存储过程的实验步骤：<br>mysql&gt; delimiter |<br>mysql&gt; create procedure insertArticle_Procedure (pTitle varchar(50),pBid int,out<br>pId int)<br>-&gt; begin<br>-&gt; insert into article1 value(null,pTitle,pBid); -&gt; select max(id) into pId from article1; -&gt; end; -&gt; |<br>Query OK, 0 rows affected (0.05 sec)<br>mysql&gt; call insertArticle_Procedure(‘中国北京’,1,@pid); -&gt; |<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; delimiter ;<br>mysql&gt; select @pid;<br>+——+<br>| @pid |<br>+——+<br>| 3 |<br>+——+<br>1 row in set (0.00 sec)<br>mysql&gt; select * from article1;<br>+—-+————–+——+<br>| id | title | bid |<br>+—-+————–+——+<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>| 1 | test | 1 |<br>| 2 | chuanzhiboke | 1 |<br>| 3 | 中国北京 | 1 |<br>+—-+————–+——+<br>3 rows in set (0.00 sec)<br>触发器的实验步骤：<br>create table board1(id int primary key auto_increment,name varchar(50),ar<br>ticleCount int);<br>create table article1(id int primary key auto_increment,title varchar(50)<br>,bid int references board1(id));<br>delimiter |<br>create trigger insertArticle_Trigger after insert on article1 for each ro<br>w begin<br>-&gt; update board1 set articleCount&#x3D;articleCount+1 where id&#x3D; NEW.bid; -&gt; end; -&gt; |<br>delimiter ;<br>insert into board1 value (null,’test’,0);<br>insert into article1 value(null,’test’,1);<br>还有，每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，<br>用触发器做效率就很高。下次课设计这样一个案例，写触发器时，对于最后发帖时间可能需<br>要用 declare 方式声明一个变量，或者是用 NEW.posttime 来生成。</p></li><li><p>数据库三范式是什么?<br>第一范式（1NF）：字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式）<br>数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一<br>个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的<br>字段。<br>第二范式（2NF）：第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足<br>第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以<br>被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被<br>称为主关键字或主键。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依<br>赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一<br>部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通<br>常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非<br>部分依赖于主关键字。<br>第三范式的要求如下： 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。所以<br>第三范式具有如下特征：<br>1，每一列只有一个值 。2，每一行都能区分。3，每一个表都不包含其他表已经包含<br>的非主关键字信息。<br>例如，帖子表中只能出现发帖人的 id，而不能出现发帖人的 id，还同时出现发帖人姓名，<br>否则，只要出现同一发帖人 id 的所有记录，它们中的姓名部分都必须严格保持一致，这就<br>是数据冗余。</p></li><li><p>说出一些数据库优化方面的经验?<br>用 PreparedStatement 一般来说比 Statement 性能高：一个 sql 发给服务器执行，步骤：语法<br>检查、语义分析， 编译，缓存<br>“inert into user values(1,1,1)”-二进制<br>“inert into user values(2,2,2)”-二进制<br>“inert into user values(?,?,?)”-二进制<br>有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就<br>去掉外键。（比喻：就好比免检产品，就是为了提高效率，充分相信产品的制造商）<br>（对于 hibernate 来说，就应该有一个变化：empleyee-&gt;Deptment 对象，现在设计时就成了<br>employeedeptid）<br>看 mysql 帮助文档子查询章节的最后部分，例如，根据扫描的原理，下面的子查询语句要比<br>第二条关联查询的效率高：</p></li><li><p>select e.name,e.salary where e.managerid&#x3D;(select id from employee where name&#x3D;’zxx’);</p></li><li><p>select e.name,e.salary,m.name,m.salary from employees e,employees m where<br>e.managerid &#x3D; m.id and m.name&#x3D;’zxx’;<br>表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等<br>将姓名和密码单独从用户表中独立出来。这可以是非常好的一对一的案例哟！<br>sql 语句全部大写，特别是列名和表名都大写。特别是 sql 命令的缓存功能，更加需要统一<br>大小写，sql 语句发给 oracle 服务器语法检查和编译成为内部指令缓存和执行指令。<br>根据缓存的特点，不要拼凑条件，而是用?和 PreparedStatment<br>还有索引对查询性能的改进也是值得关注的。<br>备注：下面是关于性能的讨论举例<br>4 航班 3 个城市<br>m*n<br>select * from flight,city where flight.startcityid&#x3D;city.cityid and city.name&#x3D;’beijing’;<br>m + n<br>select * from flight where startcityid &#x3D; (select cityid from city where cityname&#x3D;’beijing’);<br>select flight.id,’beijing’,flight.flightTime from flight where startcityid &#x3D; (select cityid from city<br>where cityname&#x3D;’beijing’)</p></li><li><p>union 和 union all 有什么不同?<br>假设我们有一个表 Student，包括以下字段与数据：<br>drop table student;<br>create table student<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(<br>id int primary key, name nvarchar2(50) not null, score number not null<br>);<br>insert into student values(1,’Aaron’,78);<br>insert into student values(2,’Bill’,76);<br>insert into student values(3,’Cindy’,89);<br>insert into student values(4,’Damon’,90);<br>insert into student values(5,’Ella’,73);<br>insert into student values(6,’Frado’,61);<br>insert into student values(7,’Gill’,99);<br>insert into student values(8,’Hellen’,56);<br>insert into student values(9,’Ivan’,93);<br>insert into student values(10,’Jay’,90);<br>commit;<br>Union 和 Union All 的区别。<br>select *from studentwhere id &lt; 4union<br>select *from studentwhere id &gt; 2 and id &lt; 6<br>结果将是<br>1 Aaron 78<br>2 Bill 76<br>3 Cindy 89<br>4 Damon 90<br>5 Ella 73<br>如果换成 Union All 连接两个结果集，则返回结果是：<br>1 Aaron 78<br>2 Bill 76<br>3 Cindy 89<br>3 Cindy 89<br>4 Damon 90<br>5 Ella 73<br>可以看到，Union 和 Union All 的区别之一在于对重复结果的处理。<br>UNION 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进<br>行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常<br>见的是过程表与历史表 UNION。如：<br>select * from gc_dfys<br>union<br>select * from ls_jg_dfys<br>这个 SQL 在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后<br>返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。<br>而 UNION ALL 只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有<br>重复的数据，那么返回的结果集就会包含重复的数据了。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>从效率上说，UNION ALL 要比 UNION 快很多，所以，如果可以确认合并的两个结果集<br>中不包含重复的数据的话，那么就使用 UNION ALL，</p></li><li><p>分页语句<br>取出 sql 表中第 31 到 40 的记录（以自动增长 ID 为主键）<br>sql server 方案 1：<br>select top 10 * from t where id not in (select top 30 id from t order by id ) orde by id<br>sql server 方案 2：<br>select top 10 * from t where id in (select top 40 id from t order by id) order by id desc<br>mysql 方案：select * from t order by id limit 30,10<br>oracle 方案：select * from (select rownum r,* from t where r&lt;&#x3D;40) where r&gt;30<br>——————–待整理进去的内容————————————- pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>1.分页技术 1（直接利用 sql 语句进行分页，效率最高和最推荐的）<br>mysql:sql &#x3D; “select * from articles limit “ + (pageNo-1)<em>pageSize + “,” + pageSize;<br>oracle: sql &#x3D; “select * from “ +”(select rownum r,</em> from “ +”(select * from articles order by<br>postime desc)” +”where rownum&lt;&#x3D; “ + pageNo*pageSize +”) tmp “ +”where r&gt;” +<br>(pageNo-1)*pageSize;<br>注释：第 7 行保证 rownum 的顺序是确定的，因为 oracle 的索引会造成 rownum 返回不同的<br>值<br>简洋提示：没有 order by 时，rownum 按顺序输出，一旦有了 order by，rownum 不按顺序输<br>出了，这说明 rownum 是排序前的编号。如果对 order by 从句中的字段建立了索引，那么，<br>rownum 也是按顺序输出的，因为这时候生成原始的查询结果集时会参照索引表的顺序来构<br>建。<br>sqlserver:sql &#x3D; “select top 10 * from id not id(select top “ + (pageNo-1)*pageSize + “id from<br>articles)” DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D; cn.prepareSatement(sql);<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>while(rs.next()){<br>out.println(rs.getString(1));<br>}<br>2.不可滚动的游标<br>pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>cn &#x3D; null<br>stmt &#x3D; null;<br>rs &#x3D; null;<br>try{<br>sqlserver:sql &#x3D; “select * from articles”;<br>DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D; cn.prepareSatement(sql);<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>for(int j&#x3D;0;j&lt;(pageNo-1)*pageSize;j++){<br>rs.next();<br>}<br>int i&#x3D;0;<br>while(rs.next() &amp;&amp; i&lt;10){<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly{<br>if(rs!&#x3D;null)try{rs.close();}catch(Exception e){}<br>if(stm……… if(cn………… }<br>3.可滚动的游标<br>pageSize&#x3D;20;<br>pageNo &#x3D; 5;<br>cn &#x3D; null<br>stmt &#x3D; null;<br>rs &#x3D; null;<br>try{<br>sqlserver:sql &#x3D; “select * from articles”;<br>DataSource ds &#x3D; new InitialContext().lookup(jndiurl);<br>Connection cn &#x3D; ds.getConnection();<br>&#x2F;&#x2F;“select * from user where id&#x3D;?” —&gt;binary directive<br>PreparedStatement pstmt &#x3D;<br>cn.prepareSatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,…);<br>&#x2F;&#x2F;根据上面这行代码的异常 SQLFeatureNotSupportedException，就可判断驱动是否支持可滚<br>动游标<br>ResultSet rs &#x3D; pstmt.executeQuery()<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>rs.absolute((pageNo-1)*pageSize)<br>int i&#x3D;0;<br>while(rs.next() &amp;&amp; i&lt;10){<br>i++;<br>out.println(rs.getString(1));<br>}<br>}<br>cacth(){}<br>finnaly{<br>if(rs!&#x3D;null)try{rs.close();}catch(Exception e){}<br>if(stm……… if(cn………… }</p></li><li><p>用一条 SQL 语句 查询出每门课都大于 80 分的学生姓名<br>name kecheng fenshu<br>张三 语文 81<br>张三 数学 75<br>李四 语文 76<br>李四 数学 90<br>王五 语文 81<br>王五 数学 100<br>王五 英语 90<br>准备数据的 sql 代码：<br>create table score(id int primary key auto_increment,name varchar(20),subject varchar(20),score<br>int);<br>insert into score values<br>(null,’张三’,’语文’,81), (null,’张三’,’数学’,75), (null,’李四’,’语文’,76), (null,’李四’,’数学’,90), (null,’王五’,’语文’,81), (null,’王五’,’数学’,100), (null,’王五 ‘,’英语’,90);<br>提示：当百思不得其解时，请理想思维，把小变成大做，把大变成小做，<br>答案：<br>A: select distinct name from score where name not in (select distinct name from score where<br>score&lt;&#x3D;80)<br>B:select distince name t1 from score where 80&lt; all (select score from score where name&#x3D;t1);</p></li><li><p>所有部门之间的比赛组合<br>一个叫 department 的表，里面只有一个字段 name,一共有 4 条纪录，分别是 a,b,c,d,对应四个<br>球对，现在四个球对进行比赛，用一条 sql 语句显示所有可能的比赛组合.<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>答：select a.name, b.name from team a, team b where a.name &lt; b.name</p></li><li><p>每个月份的发生额都比 101 科目多的科目<br>请用 SQL 语句实现：从 TestDB 数据表中查询出所有月份的发生额都比 101 科目相应月份的<br>发生额高的科目。请注意：TestDB 中有很多科目，都有 1－12 月份的发生额。<br>AccID：科目代码，Occmonth：发生额月份，DebitOccur：发生额。<br>数据库名：JcyAudit，数据集：Select * from TestDB<br>准备数据的 sql 代码：<br>drop table if exists TestDB;<br>create table TestDB(id int primary key auto_increment,AccID varchar(20), Occmonth date, DebitOccur bigint);<br>insert into TestDB values<br>(null,’101’,’1988-1-1’,100), (null,’101’,’1988-2-1’,110), (null,’101’,’1988-3-1’,120), (null,’101’,’1988-4-1’,100), (null,’101’,’1988-5-1’,100), (null,’101’,’1988-6-1’,100), (null,’101’,’1988-7-1’,100), (null,’101’,’1988-8-1’,100); –复制上面的数据，故意把第一个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’102’,’1988-1-1’,90), (null,’102’,’1988-2-1’,110), (null,’102’,’1988-3-1’,120), (null,’102’,’1988-4-1’,100), (null,’102’,’1988-5-1’,100), (null,’102’,’1988-6-1’,100), (null,’102’,’1988-7-1’,100), (null,’102’,’1988-8-1’,100); –复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’103’,’1988-1-1’,150), (null,’103’,’1988-2-1’,160), (null,’103’,’1988-3-1’,180), (null,’103’,’1988-4-1’,120), (null,’103’,’1988-5-1’,120), (null,’103’,’1988-6-1’,120), (null,’103’,’1988-7-1’,120), (null,’103’,’1988-8-1’,120); –复制最上面的数据，故意把所有发生额数字改大一点<br>insert into TestDB values<br>(null,’104’,’1988-1-1’,130), (null,’104’,’1988-2-1’,130), (null,’104’,’1988-3-1’,140),<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(null,’104’,’1988-4-1’,150), (null,’104’,’1988-5-1’,160), (null,’104’,’1988-6-1’,170), (null,’104’,’1988-7-1’,180), (null,’104’,’1988-8-1’,140); –复制最上面的数据，故意把第二个月份的发生额数字改小一点<br>insert into TestDB values<br>(null,’105’,’1988-1-1’,100), (null,’105’,’1988-2-1’,80), (null,’105’,’1988-3-1’,120), (null,’105’,’1988-4-1’,100), (null,’105’,’1988-5-1’,100), (null,’105’,’1988-6-1’,100), (null,’105’,’1988-7-1’,100), (null,’105’,’1988-8-1’,100);<br>答案：<br>select distinct AccID from TestDB<br>where AccID not in<br>(select TestDB.AccIDfrom TestDB, (select * from TestDB where AccID&#x3D;’101’) as db101<br>where TestDB.Occmonth&#x3D;db101.Occmonth and TestDB.DebitOccur&lt;&#x3D;db101.DebitOccur<br>);</p></li><li><p>统计每年每月的信息<br>year month amount<br>1991 1 1.1<br>1991 2 1.2<br>1991 3 1.3<br>1991 4 1.4<br>1992 1 2.1<br>1992 2 2.2<br>1992 3 2.3<br>1992 4 2.4<br>查成这样一个结果<br>year m1 m2 m3 m4<br>1991 1.1 1.2 1.3 1.4<br>1992 2.1 2.2 2.3 2.4<br>提示：这个与工资条非常类似，与学生的科目成绩也很相似。<br>准备 sql 语句：<br>drop table if exists sales;<br>create table sales(id int auto_increment primary key,year varchar(10), month varchar(10), amount<br>float(2,1));<br>insert into sales values<br>(null,’1991’,’1’,1.1),<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(null,’1991’,’2’,1.2), (null,’1991’,’3’,1.3), (null,’1991’,’4’,1.4), (null,’1992’,’1’,2.1), (null,’1992’,’2’,2.2), (null,’1992’,’3’,2.3), (null,’1992’,’4’,2.4);<br>答案一、select sales.year , (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘1’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘2’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) ‘3’, (select t.amount from sales t where t.month&#x3D;’1’ and t.year&#x3D; sales.year) as ‘4’ from sales group by year;</p></li><li><p>显示文章标题，发帖人、最后回复时间<br>表：id,title,postuser,postdate,parentid<br>准备 sql 语句：<br>drop table if exists articles;<br>create table articles(id int auto_increment primary key,title varchar(50), postuser varchar(10), postdate datetime,parentid int references articles(id));<br>insert into articles values<br>(null,’第一条’,’张三’,’1998-10-10 12:32:32’,null), (null,’第二条’,’张三’,’1998-10-10 12:34:32’,null), (null,’第一条回复 1’,’李四’,’1998-10-10 12:35:32’,1), (null,’第二条回复 1’,’李四’,’1998-10-10 12:36:32’,2), (null,’第一条回复 2’,’王五’,’1998-10-10 12:37:32’,1), (null,’第一条回复 3’,’李四’,’1998-10-10 12:38:32’,1), (null,’第二条回复 2’,’李四’,’1998-10-10 12:39:32’,2), (null,’第一条回复 4’,’王五’,’1998-10-10 12:39:40’,1);<br>答案：<br>select a.title,a.postuser, (select max(postdate) from articles where parentid&#x3D;a.id) reply<br>from articles a where a.parentid is null;<br>注释：子查询可以用在选择列中，也可用于 where 的比较条件中，还可以用于 from 从句中。</p></li><li><p>删除除了 id 号不同,其他都相同的学生冗余信息<br>2.学生表 如下:<br>id 号 学号 姓名 课程编号 课程名称 分数<br>1 2005001 张三 0001 数学 69<br>2 2005002 李四 0001 数学 89<br>3 2005001 张三 0001 数学 69<br>A: delete from tablename where id 号 not in(select min(id 号) from tablename group by 学号,姓<br>名,课程编号,课程名称,分数)<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实验：<br>create table student2(id int auto_increment primary key,code varchar(20),name varchar(20));<br>insert into student2 values(null,’2005001’,’张三’),(null,’2005002’,’李四’),(null,’2005001’,’张三’);<br>&#x2F;&#x2F;如下语句，mysql 报告错误，可能删除依赖后面统计语句，而删除又导致统计语句结果不<br>一致。<br>delete from student2 where id not in(select min(id) from student2 group by name);<br>&#x2F;&#x2F;但是，如下语句没有问题：<br>select * from student2 where id not in(select min(id) from student2 group by name);<br>&#x2F;&#x2F;于是，我想先把分组的结果做成虚表，然后从虚表中选出结果，最后再将结果作为删除的<br>条件数据。<br>delete from student2 where id not in(select mid from (select min(id) mid<br>from student2 group by name) as t);<br>或者：<br>delete from student2 where id not in(select min(id) from (select * from s<br>tudent2) as t group by t.name);</p></li><li><p>航空网的几个航班查询题：<br>表结构如下：<br>flight{flightID,StartCityID ,endCityID,StartTime}<br>city{cityID, CityName)<br>实验环境：<br>create table city(cityID int auto_increment primary key,cityName varchar(20));<br>create table flight (flightID int auto_increment primary key, StartCityID int references city(cityID), endCityID int references city(cityID), StartTime timestamp);<br>&#x2F;&#x2F;航班本来应该没有日期部分才好，但是下面的题目当中涉及到了日期<br>insert into city values(null,’北京’),(null,’上海’),(null,’广州’);<br>insert into flight values<br>(null,1,2,’9:37:23’),(null,1,3,’9:37:23’),(null,1,2,’10:37:23’),(null,2,3,’10:37:23’);<br>1、查询起飞城市是北京的所有航班，按到达城市的名字排序<br>参与运算的列是我起码能够显示出来的那些列，但最终我不一定把它们显示出来。各个表组<br>合出来的中间结果字段中必须包含所有运算的字段。<br>select * from flight f,city c<br>where f.endcityid &#x3D; c.cityid and startcityid &#x3D;<br>(select c1.cityid from city c1 where c1.cityname &#x3D; “北京”)<br>order by c.cityname asc;<br>mysql&gt; select flight.flightid,’北京’ startcity, e.cityname from flight,city e wh<br>ere flight.endcityid&#x3D;e.cityid and flight.startcityid&#x3D;(select cityid from city wh<br>ere cityname&#x3D;’北京’);<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>mysql&gt; select flight.flightid,s.cityname,e.cityname from flight,city s,city e wh<br>ere flight.startcityid&#x3D;s.cityid and s.cityname&#x3D;’北京’ and flight.endCityId&#x3D;e.cit<br>yID order by e.cityName desc;<br>2、查询北京到上海的所有航班纪录（起飞城市，到达城市，起飞时间，航班号）<br>select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID&#x3D;c1.cityID<br>and f.endCityID&#x3D;c2.cityID<br>and c1.cityName&#x3D;’北京’ and c2.cityName&#x3D;’上海’ 3、查询具体某一天（2005-5-8）的北京到上海的的航班次数<br>select count(<em>) from<br>(select c1.CityName,c2.CityName,f.StartTime,f.flightID<br>from city c1,city c2,flight f<br>where f.StartCityID&#x3D;c1.cityID<br>and f.endCityID&#x3D;c2.cityID<br>and c1.cityName&#x3D;’北京’ and c2.cityName&#x3D;’上海’ and 查帮助获得的某个日期处理函数(startTime) like ‘2005-5-8%’ mysql 中提取日期部分进行比较的示例代码如下：<br>select * from flight where date_format(starttime,’%Y-%m-%d’)&#x3D;’1998-01-02’ 182. 查出比经理薪水还高的员工信息：<br>Drop table if not exists employees;<br>create table employees(id int primary key auto_increment,name varchar(50)<br>,salary int,managerid int references employees(id));<br>insert into employees values (null,’ lhm’,10000,null), (null,’ zxx’,15000,1<br>),(null,’flx’,9000,1),(null,’tg’,10000,2),(null,’wzg’,10000,3);<br>Wzg 大于 flx,lhm 大于 zxx<br>解题思路：<br>根据 sql 语句的查询特点，是逐行进行运算，不可能两行同时参与运算。<br>涉及了员工薪水和经理薪水，所有，一行记录要同时包含两个薪水，所有想到要把这个表自<br>关联组合一下。<br>首先要组合出一个包含有各个员工及该员工的经理信息的长记录，譬如，左半部分是员工，<br>右半部分是经理。而迪卡尔积会组合出很多垃圾信息，先去除这些垃圾信息。<br>select e.</em> from employees e,employees m where e.managerid&#x3D;m.id and e.sala<br>ry&gt;m.salary;</p></li><li><p>求出小于 45 岁的各个老师所带的大于 12 岁的学生人数<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>数据库中有 3 个表 teacher 表，student 表，tea_stu 关系表。<br>teacher 表 teaID name age<br>student 表 stuID name age<br>teacher_student 表 teaID stuID<br>要求用一条 sql 查询出这样的结果<br>1.显示的字段要有老师 name, age 每个老师所带的学生人数<br>2.只列出老师 age 为 40 以下，学生 age 为 12 以上的记录<br>预 备 知 识 : 1.sql 语 句 是 对 每 一 条 记 录 依 次 处 理 ， 条 件 为 真 则 执 行 动 作<br>（select,insert,delete,update）<br>2.只要是迪卡尔积，就会产生“垃圾”信息，所以，只要迪卡尔积了，我们首先<br>就要想到清除“垃圾”信息<br>实验准备： drop table if exists tea_stu;<br>drop table if exists teacher;<br>drop table if exists student;<br>create table teacher(teaID int primary key,name varchar(50),age int);<br>create table student(stuID int primary key,name varchar(50),age int);<br>create table tea_stu(teaID int references teacher(teaID),stuID int references<br>student(stuID));<br>insert into teacher values(1,’zxx’,45), (2,’lhm’,25) , (3,’wzg’,26) , (4,’tg’,27);<br>insert into student values(1,’wy’,11), (2,’dh’,25) , (3,’ysq’,26) , (4,’mxc’,27);<br>insert into tea_stu values(1,1), (1,2), (1,3);<br>insert into tea_stu values(2,2), (2,3), (2,4);<br>insert into tea_stu values(3,3), (3,4), (3,1);<br>insert into tea_stu values(4,4), (4,1), (4,2) , (4,3);<br>结果：23,32,43<br>解题思路：（真实面试答题时，也要写出每个分析步骤，如果纸张不够，就找别人要）<br>1.要会统计分组信息，统计信息放在中间表中：<br>select teaid,count(<em>) from tea_stu group by teaid;<br>2.接着其实应该是筛除掉小于 12 岁的学生，然后再进行统计，中间表必须与 student 关联才<br>能得到 12 岁以下学生和把该学生记录从中间表中剔除，代码是：<br>select tea_stu.teaid,count(</em>) total from student,tea_stu<br>where student.stuid&#x3D;tea_stu.stuid and student.age&gt;12 group by tea_stu.teaid<br>3.接着把上面的结果做成虚表与 teacher 进行关联，并筛除大于 45 的老师<br>select teacher.teaid,teacher.name,total from teacher ,(select tea_stu.tea<br>id,count(*) total from student,tea_stu where student.stuid&#x3D;tea_stu.stuid and stu<br>dent.age&gt;12 group by tea_stu.teaid) as tea_stu2 where teacher.teaid&#x3D;tea_stu2.tea<br>id and teacher.age&lt;45;</p></li><li><p>求出发帖最多的人：<br>select authorid,count(<em>) total from articles<br>group by authorid<br>having total&#x3D;(select max(total2) from (select count(</em>) total2 from articles group by authorid) as t);<br>select t.authorid,max(t.total) from（select authorid,count(<em>) total from articles ）as t<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>这条语句不行，因为 max 只有一列，不能与其他列混淆。<br>select authorid,count(</em>) total from articles<br>group by authorid having total&#x3D;max(total)也不行。</p></li><li><p>一个用户表中有一个积分字段，假如数据库中有 100 多万个用户，若要在每年第一天<br>凌晨将积分清零，你将考虑什么，你将想什么办法解决?<br>alter table drop column score;<br>alter table add colunm score int;<br>可能会很快，但是需要试验，试验不能拿真实的环境来操刀，并且要注意，<br>这样的操作时无法回滚的，在我的印象中，只有 inert update delete 等 DML 语句才能回滚，<br>对于 create table,drop table ,alter table 等 DDL 语句是不能回滚。<br>解决方案一，update user set score&#x3D;0;<br>解决方案二，假设上面的代码要执行好长时间，超出我们的容忍范围，那我就 alter table user<br>drop column score;alter table user add column score int。<br>下面代码实现每年的那个凌晨时刻进行清零。<br>Runnable runnable &#x3D;<br>new Runnable(){<br>public void run(){<br>clearDb();<br>schedule(this,new Date(new Date().getYear()+1,0,0));<br>}<br>};<br>schedule(runnable, new Date(new Date().getYear()+1,0,1));</p></li><li><p>一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。<br>select count(*) as num,tb.id from tb, (select role from tb where id&#x3D;xxx) as t1<br>where tb.role &#x3D; t1.role and tb.id !&#x3D; t1.id<br>group by tb.id<br>having num &#x3D; select count(role) from tb where id&#x3D;xxx;</p></li><li><p>xxx 公司的 sql 面试<br>Table EMPLOYEES Structure:<br>EMPLOYEE_ID NUMBER Primary Key, FIRST_NAME VARCHAR2(25), LAST_NAME VARCHAR2(25), Salary number(8,2), HiredDate DATE, Departmentid number(2)<br>Table Departments Structure:<br>Departmentid number(2) Primary Key, DepartmentName VARCHAR2(25).<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>(2）基于上述 EMPLOYEES 表写出查询：写出雇用日期在今年的，或者工资在[1000,2000]<br>之间的，或者员工姓名（last_name）以’Obama’打头的所有员工，列出这些员工的全部个人<br>信息。（4 分）<br>select * from employees<br>where Year(hiredDate) &#x3D; Year(date())<br>or (salary between 1000 and 200)<br>or left(last_name,3)&#x3D;’abc’;<br>(3) 基于上述 EMPLOYEES 表写出查询：查出部门平均工资大于 1800 元的部门的所有员工，<br>列出这些员工的全部个人信息。<br>mysql&gt; select id,name,salary,deptid did from employee1 where (select avg(salary)<br>from employee1 where deptid &#x3D; did) &gt; 1800;<br>(4) 基于上述 EMPLOYEES 表写出查询：查出个人工资高于其所在部门平均工资的员工，<br>列出这些员工的全部个人信息及该员工工资高出部门平均工资百分比。（5 分）<br>select employee1.*,(employee1.salary-t.avgSalary)*100&#x2F;employee1.salary<br>from employee1, (select deptid,avg(salary) avgSalary from employee1 group by deptid) as t<br>where employee1.deptid &#x3D; t.deptid and employee1.salary&gt;t.avgSalary;</p></li><li><p>注册 Jdbc 驱动程序的三种方式?<br>如下:</p></li><li><p>Class.forName(“com.mysql.jdbc.Driver”);</p></li><li><p>System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”);</p></li><li><p>DriverManager.registerDriver(new com.mysql.jdbc.Driver());<br>1 中，不需要.newInstance()<br>2 中，通过系统的属性设置即可<br>3 中，是看起来比较直观的一种方式，注册相应的 db 的 jdbc 驱动，<br>总结：推荐 1，和 2 两种方式。<br>原因：3 在编译时需要导入对应的 lib。1，2 不需要。<br>补充：2 的方式的话，可以同时导入多个 jdbc 驱动，中间用冒号“：”分开</p></li><li><p>用 JDBC 如何调用存储过程<br>代码如下：<br>package com.huawei.interview.lym;<br>import java.sql.CallableStatement;<br>import java.sql.Connection;<br>import java.sql.DriverManager;<br>import java.sql.SQLException;<br>import java.sql.Types;<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>public class JdbcTest {<br>public static void main(String[] args) {<br>Connection cn &#x3D; null;<br>CallableStatement cstmt &#x3D; null;<br>try {<br>&#x2F;&#x2F;这里最好不要这么干，因为驱动名写死在程序中了<br>Class.forName(“com.mysql.jdbc.Driver”);<br>&#x2F;&#x2F;实际项目中，这里应用 DataSource 数据，如果用框架，<br>&#x2F;&#x2F;这个数据源不需要我们编码创建，我们只需 Datasource ds &#x3D; context.lookup()<br>&#x2F;&#x2F;cn &#x3D; ds.getConnection();<br>cn &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;&#x2F;test”,”root”,”root”);<br>cstmt &#x3D; cn.prepareCall(“{call insert_Student(?,?,?)}”);<br>cstmt.registerOutParameter(3,Types.INTEGER);<br>cstmt.setString(1, “wangwu”);<br>cstmt.setInt(2, 25);<br>cstmt.execute();<br>&#x2F;&#x2F;get 第几个，不同的数据库不一样，建议不写<br>System.out.println(cstmt.getString(3));<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>finally{<br>&#x2F;<em>try{cstmt.close();}catch(Exception e){}<br>try{cn.close();}catch(Exception e){}</em>&#x2F;<br>try {<br>if(cstmt !&#x3D; null)<br>cstmt.close();<br>if(cn !&#x3D; null)<br>cn.close();<br>} catch (SQLException e) {<br>e.printStackTrace();<br>}<br>}<br>}</p></li><li><p>JDBC 中的 PreparedStatement 相比 Statement 的好处<br>答：一个 sql 命令发给服务器去执行的步骤为：语法检查，语义分析，编译成内部指令，缓<br>存指令，执行指令等过程。<br>select * from student where id &#x3D;3—-缓存–xxxxx 二进制命令<br>select * from student where id &#x3D;3—-直接取-xxxxx 二进制命令<br>select * from student where id &#x3D;4— -会怎么干？<br>如果当初是 select * from student where id &#x3D;?— -又会怎么干？<br>上面说的是性能提高<br>可以防止 sql 注入。<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p></li><li><p>写一个用 jdbc 连接并访问 oracle 数据的程序代码, 能够完成修改和查询工作。<br>public void testJdbc(){<br>Connection con &#x3D; null;<br>PreparedStatement ps &#x3D; null;<br>ResultSet rs &#x3D; null;<br>try{<br>&#x2F;&#x2F;step1：注册驱动；<br>Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>&#x2F;&#x2F;step 2：获取数据库连接；<br>con&#x3D;DriverManager.getConnection( “jdbc:oracle:thin:@192.168.0.39:1521:TARENADB”, “sd0605”,”sd0605”);<br>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>查 询</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>&#x2F;<br>&#x2F;&#x2F;step 3：创建 Statement；<br>String sql &#x3D; “SELECT id, fname, lname, age, FROM Person_Tbl”;<br>ps &#x3D; con.prepareStatement(sql);<br>&#x2F;&#x2F;step 4 ：执行查询语句，获取结果集；<br>rs &#x3D; ps.executeQuery();<br>&#x2F;&#x2F;step 5：处理结果集—输出结果集中保存的查询结果；<br>while (rs.next()){<br>System.out.print(“id &#x3D; “ + rs.getLong(“id”));<br>System.out.print(“ , fname &#x3D; “ + rs.getString(“fname”));<br>System.out.print(“ , lname &#x3D; “ + rs.getString(“lname”));<br>System.out.print(“ , age &#x3D; “ + rs.getInt(“age”));<br>}<br>&#x2F;***<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>JDBC 修 改</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F;<br>sql &#x3D; “UPDATE Person_Tbl SET age&#x3D;23 WHERE id &#x3D; ?”;<br>ps &#x3D; con.prepareStatement(sql);<br>ps.setLong(1, 88);<br>int rows &#x3D; ps.executeUpdate();<br>System.out.println(rows + “ rows affected.”);<br>} catch (Exception e){<br>e.printStackTrace();<br>} finally{<br>try{<br>con.close(); &#x2F;&#x2F;关闭数据库连接，以释放资源。<br>} catch (Exception e1) {<br>}<br>}<br>}</p></li><li><p>Class.forName 的作用?为什么要用?<br>答：按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载<br>过，则返回代表该字节码的 Class 实例对象，否则，按类加载器的委托机制去搜索和加载该<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>类，如果所有的类加载器都无法加载到该类，则抛出 ClassNotFoundException。加载完这个<br>Class 字节码后，接着就可以使用 Class 字节码的 newInstance 方法去创建该类的实例对象了。<br>有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时<br>才能确定，这时候就需要使用 Class.forName 去动态加载该类，这个类名通常是在配置文件<br>中配置的，例如，spring 的 ioc 中每次依赖注入的具体类就是这样配置的，jdbc 的驱动类名<br>通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类<br>名。</p></li><li><p>大数据量下的分页解决方法。<br>答：最好的办法是利用 sql 语句进行分页，这样每次查询出的结果集中就只包含某页的数据<br>内容。再 sql 语句无法实现分页的情况下，可以考虑对大的结果集通过游标定位方式来获取<br>某页的数据。<br>sql 语句分页，不同的数据库下的分页方案各不一样，下面是主流的三种数据库的分页 sql：<br>sql server:<br>String sql &#x3D; “select top “ + pageSize + “ * from students where id not in” +<br>“(select top “ + pageSize * (pageNumber-1) + “ id from students order by id)” +<br>“order by id”;<br>mysql:String sql &#x3D; “select * from students order by id limit “ + pageSize*(pageNumber-1) + “,” +<br>pageSize;<br>oracle:String sql &#x3D; “select * from “ + (select <em>,rownum rid from (select * from students order<br>by postime desc) where rid&lt;&#x3D;” + pagesize</em>pagenumber + “) as t” + “where t&gt;” +<br>pageSize*(pageNumber-1);</p></li><li><p>用 JDBC 查询学生成绩单, 把主要代码写出来（考试概率极大）. Connection cn &#x3D; null;<br>PreparedStatement pstmt &#x3D;null;<br>Resultset rs &#x3D; null;<br>try{<br>Class.forname(driveClassName);<br>cn &#x3D; DriverManager.getConnection(url,username,password);<br>pstmt &#x3D; cn.prepareStatement(“select score.* from score ,student “ +<br>“where score.stuId &#x3D; student.id and student.name &#x3D; ?”);<br>pstmt.setString(1,studentName);<br>Resultset rs &#x3D; pstmt.executeQuery();<br>while(rs.next()){<br>system.out.println(rs.getInt(“subject”) + “ ” + rs.getFloat(“score”) );<br>}<br>}catch(Exception e){e.printStackTrace();}<br>finally{<br>if(rs !&#x3D; null) try{ rs.close() }catch(exception e){}<br>if(pstmt !&#x3D; null) try{pstmt.close()}catch(exception e){}<br>if(cn !&#x3D; null) try{ cn.close() }catch(exception e){}<br>}</p></li><li><p>这段代码有什么不足之处?<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>try {<br>Connection conn &#x3D; …;<br>Statement stmt &#x3D; …;<br>ResultSet rs &#x3D; stmt.executeQuery(“select * from table1”);<br>while(rs.next()) {<br>}<br>} catch(Exception ex) {<br>}<br>答：没有 finally 语句来关闭各个对象，另外，使用 finally 之后，要把变量的定义放在 try 语<br>句块的外面，以便在 try 语句块之外的 finally 块中仍可以访问这些变量。</p></li><li><p>说出数据连接池的工作机制是什么?<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空<br>闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池<br>连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。<br>实现方式，返回的 Connection 是原始 Connection 的代理，代理 Connection 的 close 方法不是<br>真正关连接，而是把它代理的 Connection 对象还回到连接池中。</p></li><li><p>为什么要用 ORM? 和 JDBC 有何不一样?<br>orm 是一种思想，就是把 object 转变成数据库中的记录，或者把数据库中的记录转变成<br>objecdt，我们可以用 jdbc 来实现这种思想，其实，如果我们的项目是严格按照 oop 方式编<br>写的话，我们的 jdbc 程序不管是有意还是无意，就已经在实现 orm 的工作了。<br>现在有许多 orm 工具，它们底层调用 jdbc 来实现了 orm 工作，我们直接使用这些工具，就<br>省去了直接使用 jdbc 的繁琐细节，提高了开发效率，现在用的较多的 orm 工具是 hibernate。<br>也听说一些其他 orm 工具，如 toplink,ojb 等。</p></li><li><p>JDBC，Hibernate 分页怎样实现？<br>答：方法分别为：</p></li></ol><ol><li>Hibernate 的分页：<br>Query query &#x3D; session.createQuery(“from Student”);<br>query.setFirstResult(firstResult);&#x2F;&#x2F;设置每页开始的记录号<br>query.setMaxResults(resultNumber);&#x2F;&#x2F;设置每页显示的记录数<br>Collection students &#x3D; query.list();</li><li>JDBC 的分页：根据不同的数据库采用不同的 sql 分页语句<br>例 如 : Oracle 中 的 sql 语 句 为 : “SELECT * FROM (SELECT a.*, rownum r FROM<br>TB_STUDENT) WHERE r between 2 and 10” 查询从记录号 2 到记录号 10 之间的所有记录<br>七、 XML 部分</li></ol><ol start="200"><li><p>xml 有哪些解析技术?区别是什么?<br>答:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>种结构占用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML<br>的随机访问 SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文<br>件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结<br>束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理 XML 文件，适合<br>对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)</p></li><li><p>你在项目中用到了 xml 技术的哪些方面?如何实现的?<br>答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成<br>XML 文件，然后将 XML 文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩<br>后再同 XML 文件中还原相关信息进行处理。在做软件配置时，利用 XML 可以很方便的进<br>行，软件的各种配置参数都存贮在 XML 文件中。</p></li><li><p>谈谈你对 SSH 的理解<br>典型的 JavaEE 三层结构，分为表现层、中间层（业务逻辑层）和数据服务层。三层体系将<br>业务规则、数据访问及合法性校验等工作放在中间层处理。客户端不直接与数据库交互，而<br>是通过组件与中间层建立连接，再由中间层与数据库交互。<br>表现层是传统的 JSP 技术，自 1999 年问世以来，经过多年的发展，其广泛的应用和稳定的<br>表现，为其作为表现层技术打下了坚实的基础。<br>中间层采用的是流行的 Spring+Hibernate，为了将控制层与业务逻辑层分离，又细分为以下<br>几种。<br>Web 层，就是 MVC 模式里面的“C”（controller），负责控制业务逻辑层与表现层的交互，<br>调用业务逻辑层，并将业务数据返回给表现层作组织表现，该系统的 MVC 框架采用 Struts。<br>Service 层（就是业务逻辑层），负责实现业务逻辑。业务逻辑层以 DAO 层为基础，通过对<br>DAO 组件的正面模式包装，完成系统所要求的业务逻辑。<br>DAO 层，负责与持久化对象交互。该层封装了数据的增、删、查、改的操作。<br>PO，持久化对象。通过实体关系映射工具将关系型数据库的数据映射成对象，很方便地实<br>现以面向对象方式操作数据库，该系统采用 Hibernate 作为 ORM 框架。<br>Spring 的作用贯穿了整个中间层，将 Web 层、Service 层、DAO 层及 PO 无缝整合，其数据<br>服务层用来存放数据。</p></li><li><p>谈谈你对 Hibernate 的理解。</p></li><li><p>面向对象设计的软件内部运行过程可以理解成就是在不断创建各种新对象、建立对象之<br>间的关系，调用对象的方法来改变各个对象的状态和对象消亡的过程，不管程序运行的过程<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>和操作怎么样，本质上都是要得到一个结果，程序上一个时刻和下一个时刻的运行结果的差<br>异就表现在内存中的对象状态发生了变化。<br>2.为了在关机和内存空间不够的状况下，保持程序的运行状态，需要将内存中的对象状态保<br>存到持久化设备和从持久化设备中恢复出对象的状态，通常都是保存到关系数据库来保存大<br>量对象信息。从 Java 程序的运行功能上来讲，保存对象状态的功能相比系统运行的其他功<br>能来说，应该是一个很不起眼的附属功能，java 采用 jdbc 来实现这个功能，这个不起眼的<br>功能却要编写大量的代码，而做的事情仅仅是保存对象和恢复对象，并且那些大量的 jdbc<br>代码并没有什么技术含量，基本上是采用一套例行公事的标准代码模板来编写，是一种苦活<br>和重复性的工作。<br>3.通过数据库保存 java 程序运行时产生的对象和恢复对象，其实就是实现了 java 对象与关<br>系数据库记录的映射关系，称为 ORM（即 Object Relation Mapping），人们可以通过封装<br>JDBC 代码来实现了这种功能，封装出来的产品称之为 ORM 框架，Hibernate 就是其中的一<br>种流行 ORM 框架。使用 Hibernate 框架，不用写 JDBC 代码，仅仅是调用一个 save 方法，<br>就可以将对象保存到关系数据库中，仅仅是调用一个 get 方法，就可以从数据库中加载出一<br>个对象。<br>4.使用 Hibernate 的基本流程是：配置 Configuration 对象、产生 SessionFactory、创建 session<br>对象，启动事务，完成 CRUD 操作，提交事务，关闭 session。<br>5.使用 Hibernate 时，先要配置 hibernate.cfg.xml 文件，其中配置数据库连接信息和方言等，<br>还要为每个实体配置相应的 hbm.xml 文件，hibernate.cfg.xml 文件中需要登记每个 hbm.xml<br>文件。<br>6.在应用 Hibernate 时，重点要了解 Session 的缓存原理，级联，延迟加载和 hql 查询。</p></li><li><p>hibernate 中的 update()和 saveOrUpdate()的区别，session 的 load()和 get()的区别。</p></li><li><p>简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件. 216. Hibernate 的应用（Hibernate 的结构）？<br>答：&#x2F;&#x2F;首先获得 SessionFactory 的对象<br>SessionFactory sessionFactory &#x3D; new Configuration().configure().buildSessionFactory();<br>&#x2F;&#x2F;然后获得 session 的对象<br>Session session &#x3D; sessionFactory.openSession();<br>&#x2F;&#x2F;其次获得 Transaction 的对象<br>Transaction tx &#x3D; session.beginTransaction();<br>&#x2F;&#x2F;执行相关的数据库操作:增,删,改,查<br>session.save(user); &#x2F;&#x2F;增加, user 是 User 类的对象<br>session.delete(user); &#x2F;&#x2F;删除<br>session.update(user); &#x2F;&#x2F;更新<br>Query query &#x3D; session.createQuery(“from User”); &#x2F;&#x2F;查询<br>List list &#x3D; query.list();<br>&#x2F;&#x2F;提交事务<br>tx.commit();<br>&#x2F;&#x2F;如果有异常,我们还要作事务的回滚,恢复到操作之前<br>tx.rollback();<br>&#x2F;&#x2F;最后还要关闭 session,释放资源<br>session.close()</p></li><li><p>112、Hibernate 有哪 5 个核心接口？<br>答：Configuration 接口：配置 Hibernate，根据其启动 hibernate，创建 SessionFactory 对象；<br>SessionFactory 接口：初始化 Hibernate，充当数据存储源的代理，创建 session 对象，<br>sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量<br>级、二级缓存；<br>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个<br>线程共享同一个 session，是轻量级、一级缓存；<br>Transaction 接口：管理事务；<br>Query 和 Criteria 接口：执行数据库的查询。</p></li><li><p>iBatis 与 Hibernate 有什么不同?<br>相同点：屏蔽 jdbc api 的底层访问细节，使用我们不用与 jdbc api 打交道，就可以访问数据。<br>jdbc api 编程流程固定，还将 sql 语句与 java 代码混杂在了一起，经常需要拼凑 sql 语句，细<br>节很繁琐。<br>ibatis 的好处：屏蔽 jdbc api 的底层访问细节；将 sql 语句与 java 代码进行分离;提供了将结<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>果集自动封装称为实体对象和对象的集合的功能，queryForList 返回对象集合，用<br>queryForObject 返回单个对象；提供了自动将实体对象的属性传递给 sql 语句的参数。<br>Hibernate 是一个全自动的 orm 映射工具，它可以自动生成 sql 语句,ibatis 需要我们自己在 xml<br>配置文件中写 sql 语句，hibernate 要比 ibatis 功能负责和强大很多。因为 hibernate 自动生成<br>sql 语句，我们无法控制该语句，我们就无法去写特定的高效率的 sql。对于一些不太复杂的<br>sql 查询，hibernate 可以很好帮我们完成，但是，对于特别复杂的查询，hibernate 就很难适<br>应了，这时候用 ibatis 就是不错的选择，因为 ibatis 还是由我们自己写 sql 语句。</p></li><li><p>写 Hibernate 的一对多和多对一双向关联的 orm 配置?</p></li><li><p>什么是 ORM？<br>答：对象关系映射（Object—Relational Mapping，简称 ORM）是一种为了解决面向对象与<br>面向关系数据库存在的互不匹配的现象的技术；简单的说，ORM 是通过使用描述对象和数<br>据库之间映射的元数据，将 java 程序中的对象自动持久化到关系数据库中；本质上就是将<br>数据从一种形式转换到另外一种形式。</p></li><li><p>hibernate 的 inverse 属性的作用?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>在 DAO 中如何体现 DAO 设计模式?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>spring+Hibernate 中委托方案怎么配置?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>spring+Hibernate 中委托方案怎么配置?<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>hibernate 进行多表查询每表中各取几个字段，就是说查询出的结果集没有一个实体<br>类与之对应如何解决<br>解决方案一，按照 Object[]数据取出数据，然后自己组 bean<br>解决方案二，对每个表的 bean 写构造函数，比如表一要查出 field1,field2 两个字段，那么有<br>一个构造函数就是 Bean(type1 filed1,type2<br>field2) ，然后在 hql 里面就可以直接生成这个 bean 了。</p></li><li><p>应用服务器与 WEB SERVER 的区别？</p></li><li><p>应用服务器有那些？<br>BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，<br>Tomcat</p></li><li><p>J2EE 是什么？<br>答:Je22 是 Sun 公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的<br>企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为<br>不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客<br>户层(clietn tier)组件,web 层和组件,Business 层和组件,企业信息系统(EIS)层。<br>一个另类的回答：j2ee 就是增删改查。</p></li><li><p>J2EE 是技术还是平台还是框架？ 什么是 J2EE?<br>J2EE 本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br>J2EE 也是一个框架，包括 JDBC、JNDI、RMI、JMS、EJB、JTA 等技术。</p></li><li><p>如何设定的 weblogic 的热启动模式(开发模式)与产品发布模式?<br>可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启<br>动文件或者 commenv 文件，增加 set PRODUCTION_MODE&#x3D;true。</p></li><li><p>说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的 helloWorld.jsp<br>放入何目录下,然的在浏览器上就可打入 http:&#x2F;&#x2F;主机:端口号&#x2F;&#x2F;helloword.jsp 就可以看<br>到运行结果了? 又比如这其中用到了一个自己写的 javaBean 该如何办?<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果<br>是 Web 应用，应用目录需要满足 Web 应用目录要求，jsp 文件可以直接放在应用目录中，<br>Javabean 需要放在应用目录的 WEB-INF 目录的 classes 目录中，设置服务器的缺省应用将可<br>以实现在浏览器上无需输入应用名。</p></li><li><p>在 weblogic 中发布 ejb 需涉及到哪些配置文件<br>不 同 类 型 的 EJB 涉 及 的 配 置 文 件 不 同 ， 都 涉 及 到 的 配 置 文 件 包 括<br>ejb-jar.xml,weblogic-ejb-jar.xmlCMP 实体 Bean 一般还需要 weblogic-cmp-rdbms-jar.xml</p></li><li><p>如何在 weblogic 中进行 ssl 配置与客户端的认证配置或说说 j2ee(标准)进行 ssl 的配<br>置?<br>缺省安装中使用 DemoIdentity.jks 和 DemoTrust.jks KeyStore 实现 SSL，需要配置服务器使<br>用 Enable SSL，配置其端口，在产品模式下需要从 CA 获取私有密钥和数字证书，创建 identity<br>和 trust keystore，装载获得的密钥和数字证书。可以配置此 SSL 连接是单向还是双向的。</p></li><li><p>如何查看在 weblogic 中已经发布的 EJB?<br>可以使用管理控制台，在它的 Deployment 中可以查看所有已发布的 EJB<br>十一、 ejb 部分</p></li><li><p>EJB 基于哪些技术实现的？说出 SessionBean 和 EntityBean 区别，StatefulBean 和<br>StatelessBean 区别。<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技术<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调<br>用其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对<br>象视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的<br>Session Bean 都可以将系统逻辑放在 method 之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean<br>的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就<br>是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗<br>J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状<br>态。</p></li><li><p>简要讲一下 EJB 的 7 个 Transaction Level?</p></li><li><p>EJB 与 JAVA BEAN 的区别？<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类<br>都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所<br>以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用<br>于实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，<br>它是不能被跨进程访问的。Enterprise Java Bean 相当于 DCOM，即分布式组件。它是基于<br>Java 的远程方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。<br>但 EJB 必须被布署在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正<br>的 EJB 组件，而是通过其容器访问。EJB 容器是 EJB 组件的代理，EJB 组件由容器所创建<br>和管理。客户通过容器来访问真正的 EJB 组件。</p></li><li><p>EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？<br>SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立<br>一个 Bean 的实例时，EJB 容器不一定要创建一个新的 Bean 的实例供客户机调用，而是随便<br>找一个现有的实例提供给客户机。当客户机第一次调用一个 Stateful Session Bean 时，容器<br>必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful<br>Session Bean 的方法时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不是按照应用程序或者服务进程来说的。即使 EJB 容器<br>崩溃了，Entity beans 也是存活的。Entity Beans 生命周期能够被容器或者 Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。</p></li><li><p>EJB 容器提供的服务<br>主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。</p></li><li><p>EJB 的激活机制<br>北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<br>以Stateful Session Bean 为例：其 Cache大小决定了内存中可以同时存在的Bean实例的数量，<br>根据 MRU 或 NRU 算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某<br>个 EJB 实例业务方法时，如果对应 EJB Object 发现自己没有绑定对应的 Bean 实例则从其去<br>激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。</p></li><li><p>EJB 的几种类型<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean<br>会话 Bean 又可分为有状态（Stateful）和无状态（Stateless）两种<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种</p></li><li><p>客服端调用 EJB 对象的几个基本步骤<br>设置 JNDI 服务工厂以及 JNDI 服务地址系统属性，查找 Home 接口，从 Home 接口调用 Create<br>方法创建 Remote 接口，通过 Remote 接口调用其业务方法。 十二、 webservice 部分</p></li><li><p>名词解释：①WEB SERVICE ②JAXP ③JAXM ④SOAP ⑤UDDI ⑥WSDL。<br>JSWDL 开发包的介绍。<br>Web Service：Web Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 Web Service 能与其他兼容的组件进行互操作。<br>JAXP：(Java API for XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。<br>这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改<br>代码。<br>JAXM：(Java API for XML Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。<br>SOAP：即简单对象访问协议(Simple Object Access Protocol)，它是用于交换 XML 编码信息<br>的轻量级协议。<br>UDDI：的目的是为电子商务建立标准；UDDI 是一套基于 Web 的、分布式的、为 Web Service<br>提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的 Web Service<br>注册，以使别的企业能够发现的访问协议的实现标准。<br>WSDL：是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信<br>息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑<br>定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服<br>务）。</p></li><li><p>CORBA 是什么?用途是什么?<br>CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象<br>管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为：用不同的程序<br>设计语言书写在不同的进程中运行，为不同的操作系统开发。</p></li></ol><p>1、什么是 Mybatis？<br>1、Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时<br>只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建<br>statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性<br>能，灵活度高。<br>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数<br>据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。<br>3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过<br>java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最<br>后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返<br>回 result 的过程）。<br>2、Mybaits 的优点：<br>1、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任<br>何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML<br>标签，支持编写动态 SQL 语句，并可重用。<br>2、与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不<br>需要手动开关连接；<br>3、很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要<br>JDBC 支持的数据库 MyBatis 都支持）。<br>4、能够与 Spring 很好的集成；<br>5、提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射<br>标签，支持对象关系组件维护。<br>3、MyBatis 框架的缺点：<br>1、SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写<br>SQL 语句的功底有一定要求。<br>2、SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。<br>4、MyBatis 框架适用场合：<br>1、MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。<br>2、对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是<br>不错的选择。</p><p>6、#{}和<code>$&#123;&#125;的区别是什么？ #&#123;&#125;是预编译处理，$</code>{}是字符串替换。<br>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的<br>set 方法来赋值；<br>Mybatis 在处理<code>$&#123;&#125;时，就是把$</code>{}替换成变量的值。<br>使用#{}可以有效的防止 SQL 注入，提高系统安全性。<br>7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？<br>第 1 种： 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类<br>的属性名一致。<br>第 2 种： 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。</p><p>文件，都会写一个 Dao 接口与之对应，<br>请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，<br>参数不同时，方法能重载吗？<br>Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；<br>接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的<br>参数，就是传递给 sql 的参数。<br>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符<br>串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中，每一个 &lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个<br>MapperStatement 对象。<br>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯<br>一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为<br>findStudentById 的 MapperStatement。<br>Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻<br>找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK<br>动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而<br>执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。</p><p>13、如何获取自动生成的(主)键值?<br>insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。<br>如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入<br>的参数对象中。</p><p>14、在 mapper 中如何传递多个参数?<br>1、第一种：<br>DAO 层的函数<br>2、第二种： 使用 @param 注解:<br>3、第三种：多个参数封装成 map</p><p>15、Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？<br>Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，执行原理<br>是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。<br>Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose<br>| when | otherwise | bind。<br>16、Xml 映射文件中，除了常见的 select|insert|updae|delete<br>标签之外，还有哪些标签？<br>答：&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、 &lt;selectKey&gt;，加上动态 sql 的 9 个标签，其中&lt;sql&gt;为 sql 片段标签，通过 &lt;include&gt;标签引入 sql 片段，&lt;selectKey&gt;为不支持自增的主键生成策略标<br>签。<br>17、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？<br>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配<br>置 namespace，那么 id 不能重复；<br>原因就是 namespace+id 是作为 Map&lt;String, MapperStatement&gt;的 key<br>使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。<br>有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然<br>也就不同。<br>18、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动<br>的区别在哪里？<br>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联<br>集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis<br>在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自<br>动 ORM 映射工具。</p><p>20、MyBatis 实现一对一有几种方式?具体怎么操作的？<br>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在<br>resultMap 里面配置 association 节点配置一对一的类就可以完成；<br>嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面<br>查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。<br>21、MyBatis 实现一对多有几种方式,怎么操作的？<br>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在<br>resultMap 里面的 collection 节点配置一对多的类就可以完成；嵌套查询是先查<br>一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过<br>配置 collection,但另外一个表的查询通过 select 节点配置。<br>22、Mybatis 是否支持延迟加载？如果支持，它的实现原理是<br>什么？<br>答：Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加<br>载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis<br>配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。<br>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦<br>截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是<br>null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，<br>然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()<br>方法的调用。这就是延迟加载的基本原理。<br>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都<br>是一样的。<br>23、Mybatis 的一级、二级缓存:<br>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为<br>Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就<br>将清空，默认打开一级缓存。<br>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap<br>存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，<br>如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要<br>实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br>&lt;cache&#x2F;&gt; ；<br>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存<br>Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将<br>被 clear。<br>25、使用 MyBatis 的 mapper 接口调用时有哪些要求？<br>1、Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；<br>2、Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的<br>parameterType 的类型相同；<br>3、Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的<br>resultType 的类型相同；<br>4、Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。<br>26、Mapper 编写有哪几种方式？<br>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写<br>mapper 接口，mapper 接口实现类、mapper.xml 文件。<br>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：<br>第三种：使用 mapper 扫描器：</p><p>ZooKeeper 面试题1. ZooKeeper 面试题？<br>ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群<br>中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用<br>的接口和性能高效、功能稳定的系统提供给用户。<br>分布式应用程序可以基于 Zookeeper 实现诸如数据发布&#x2F;订阅、负载均衡、命名<br>服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。<br>Zookeeper 保证了如下分布式一致性特性：<br>1、顺序一致性<br>2、原子性<br>3、单一视图<br>4、可靠性<br>5、实时性（最终一致性）<br>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了<br>监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些<br>请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，<br>随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。<br>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个<br>更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。<br>而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个<br>zookeeper 最新的 zxid。<br>2. ZooKeeper 提供了什么？<br>1、文件系统<br>2、通知机制<br>3. Zookeeper 文件系统<br>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不<br>同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放<br>数据而目录节点不行。<br>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这<br>种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为<br>1M。<br>4. ZAB 协议？<br>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广<br>播协议。<br>ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。<br>当整个 zookeeper 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导<br>致不存在过半的服务器与 Leader 服务器保持正常通信时，所有进程（服务器）进<br>入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务<br>器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader<br>服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始<br>接收客户端的事务请求生成事物提案来进行事务请求处理。<br>5. 四种类型的数据节点 Znode<br>1、PERSISTENT-持久节点<br>除非手动删除，否则节点一直存在于 Zookeeper 上<br>2、EPHEMERAL-临时节点<br>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与<br>zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都<br>会被移除。<br>3、PERSISTENT_SEQUENTIAL-持久顺序节点<br>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维<br>护的自增整型数字。<br>4、EPHEMERAL_SEQUENTIAL-临时顺序节点<br>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的<br>自增整型数字。<br>6. Zookeeper Watcher 机制 – 数据变更通知<br>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务<br>端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通<br>知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出<br>业务上的改变。<br>工作机制：<br>1、客户端注册 watcher<br>2、服务端处理 watcher<br>3、客户端回调 watcher<br>Watcher 特性总结：<br>1、一次性<br>无论是服务端还是客户端，一旦一个 Watcher 被触发，Zookeeper 都会将其从相<br>应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频<br>繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的<br>压力都非常大。<br>2、客户端串行执行<br>客户端 Watcher 回调的过程是一个串行同步的过程。<br>3、轻量<br>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具<br>体内容。<br>3.2、客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对<br>象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。<br>4、watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步<br>的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于<br>网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身<br>提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode<br>发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。<br>Zookeeper 只能保证最终的一致性，而无法保证强一致性。<br>5、注册 watcher getData、exists、getChildren<br>6、触发 watcher create、delete、setData<br>7、当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。<br>当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接<br>时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全<br>透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode<br>的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上<br>之前又删除了，这种情况下，这个 watch 事件可能会被丢失。<br>7. 客户端注册 Watcher 实现<br>1、调用 getData()&#x2F;getChildren()&#x2F;exist()三个 API，传入 Watcher 对象<br>2、标记请求 request，封装 Watcher 到 WatchRegistration<br>3、封装成 Packet 对象，发服务端发送 request<br>4、收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理<br>5、请求返回，完成注册。<br>8. 服务端处理 Watcher 实现<br>1、服务端接收 Watcher 并存储<br>接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点<br>的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现<br>了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在<br>WatcherManager 的 WatchTable 和 watch2Paths 中去。<br>2、Watcher 触发<br>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：<br>2.1 封装 WatchedEvent<br>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路<br>径封装成一个 WatchedEvent 对象<br>2.2 查询 Watcher<br>从 WatchTable 中根据节点路径查找 Watcher<br>2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher<br>2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里<br>可以看出 Watcher 在服务端是一次性的，触发一次就失效了）<br>3、调用 process 方法来触发 Watcher<br>这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。<br>9. 客户端回调 Watcher<br>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。<br>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。<br>10. ACL 权限控制机制<br>UGO（User&#x2F;Group&#x2F;Others）<br>目前在 Linux&#x2F;Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗<br>粒度的文件系统权限控制模式。<br>ACL（Access Control List）访问控制列表<br>包括三个方面：<br>权限模式（Scheme）<br>1、IP：从 IP 地址粒度进行权限控制<br>2、Digest：最常用，用类似于 username:password 的权限标识来进行权限配<br>置，便于区分不同应用来进行权限控制<br>3、World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标<br>识“world:anyone”<br>4、Super：超级用户<br>授权对象<br>授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。<br>权限 Permission<br>1、CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点<br>2、DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点<br>3、READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内<br>容或子节点列表等<br>4、WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作<br>5、ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置<br>操作<br>11. Chroot 特性<br>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名<br>空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将<br>会被限制在其自己的命名空间下。<br>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对<br>应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相<br>互隔离非常有帮助。<br>12. 会话管理<br>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进<br>行不同区块的隔离处理以及同一区块的统一处理。<br>分配原则：每个会话的“下次超时时间点”（ExpirationTime）<br>计算公式：<br>ExpirationTime_ &#x3D; currentTime + sessionTimeout<br>ExpirationTime &#x3D; (ExpirationTime_ &#x2F; ExpirationInrerval + 1) *<br>ExpirationInterval , ExpirationInterval 是指 Zookeeper 会话超时检查时间<br>间隔，默认 tickTime<br>13. 服务器角色<br>Leader<br>1、事务请求的唯一调度和处理者，保证集群事务处理的顺序性<br>2、集群内部各服务的调度者<br>Follower<br>1、处理客户端的非事务请求，转发事务请求给 Leader 服务器<br>2、参与事务请求 Proposal 的投票<br>3、参与 Leader 选举投票<br>Observer<br>1、3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提<br>升集群的非事务处理能力<br>2、处理客户端的非事务请求，转发事务请求给 Leader 服务器<br>3、不参与任何形式的投票<br>14. Zookeeper 下 Server 工作状态<br>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。<br>1、LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中<br>没有 Leader，因此需要进入 Leader 选举状态。<br>2、FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。<br>3、LEADING：领导者状态。表明当前服务器角色是 Leader。<br>4、OBSERVING：观察者状态。表明当前服务器角色是 Observer。<br>15. 数据同步<br>整个集群完成 Leader 选举之后，Learner（Follower 和 Observer 的统称）回向<br>Leader 服务器进行注册。当 Learner 服务器想 Leader 服务器完成注册后，进入<br>数据同步环节。<br>数据同步流程：（均以消息传递的方式进行）<br>Learner 向 Learder 注册<br>数据同步<br>同步确认<br>Zookeeper 的数据同步通常分为四类：<br>1、直接差异化同步（DIFF 同步）<br>2、先回滚再差异化同步（TRUNC+DIFF 同步）<br>3、仅回滚同步（TRUNC 同步）<br>4、全量同步（SNAP 同步）<br>在进行数据同步前，Leader 服务器会完成数据同步初始化：<br>peerLastZxid：<br> 从 learner 服务器注册时发送的 ACKEPOCH 消息中提取 lastZxid（该<br>Learner 服务器最后处理的 ZXID）<br>minCommittedLog：<br> Leader 服务器 Proposal 缓存队列 committedLog 中最小 ZXID<br>maxCommittedLog：<br> Leader 服务器 Proposal 缓存队列 committedLog 中最大 ZXID<br>直接差异化同步（DIFF 同步）<br> 场景：peerLastZxid 介于 minCommittedLog 和 maxCommittedLog<br>之间<br>先回滚再差异化同步（TRUNC+DIFF 同步）<br> 场景：当新的 Leader 服务器发现某个 Learner 服务器包含了一条自己没<br>有的事务记录，那么就需要让该 Learner 服务器进行事务回滚–回滚到 Leader<br>服务器上存在的，同时也是最接近于 peerLastZxid 的 ZXID<br>仅回滚同步（TRUNC 同步）<br> 场景：peerLastZxid 大于 maxCommittedLog<br>全量同步（SNAP 同步）<br> 场景一：peerLastZxid 小于 minCommittedLog<br> 场景二：Leader 服务器上没有 Proposal 缓存队列且 peerLastZxid 不等<br>于 lastProcessZxid<br>16. zookeeper 是如何保证事务的顺序一致性的？<br>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被<br>提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时<br>期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch<br>会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两<br>阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能<br>执行并且能够成功，那么就会开始执行。<br>17. 分布式集群中为什么会有 Master？<br>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机<br>器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行<br>leader 选举。<br>18. zk 节点宕机如何处理？<br>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保<br>证当一个节点宕机时，其他节点会继续提供服务。<br>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数<br>据是有多个副本的，数据并不会丢失；<br>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。<br>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK<br>节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。<br>所以<br>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)<br>2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;&#x3D;1)<br>19. zookeeper 负载均衡和 nginx 负载均衡区别<br>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写<br>插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。<br>20. Zookeeper 有哪几种几种部署模式？<br>部署模式：单机模式、伪集群模式、集群模式。<br>21. 集群最少要几台机器，集群规则是怎样的?<br>集群规则为 2N+1 台，N&gt;0，即 3 台。<br>22. 集群支持动态添加机器吗？<br>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：<br>全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的<br>会话。<br>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供<br>服务。这是比较常用的方式。<br>3.5 版本开始支持动态扩容。<br>23. Zookeeper 对节点的 watch监听通知是永久的吗？为什么<br>不是永久的?<br>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch<br>的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，<br>以便通知它们。<br>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况<br>下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。<br>一般是客户端执行 getData(“&#x2F;节点 A”,true)，如果节点 A 发生了变更或删除，<br>客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没<br>有设置 watch 事件，就不再给客户端发送。<br>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我<br>只要最新的数据即可。<br>24. Zookeeper 的 java 客户端都有哪些？<br>java 客户端：zk 自带的 zkclient 及 Apache 开源的 Curator。<br>25. chubby 是什么，和 zookeeper 比你怎么看？<br>chubby 是 google 的，完全实现 paxos 算法，不开源。zookeeper 是 chubby<br>的开源实现，使用 zab 协议，paxos 算法的变种。<br>26. 说几个 zookeeper 常用的命令。<br>常用命令：ls get set create delete 等。<br>27. ZAB 和 Paxos 算法的联系与区别？<br>相同点：<br>1、两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程<br>的运行<br>2、Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提<br>案进行提交<br>3、ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader<br>周期，Paxos 中名字为 Ballot<br>不同点：<br>ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建<br>分布式一致性状态机系统。<br>28. Zookeeper 的典型应用场景<br>Zookeeper 是一个典型的发布&#x2F;订阅模式的分布式数据管理与协调框架，开发人员<br>可以使用它来进行分布式数据的发布和订阅。<br>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机<br>制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：<br>1、数据发布&#x2F;订阅<br>2、负载均衡<br>3、命名服务<br>4、分布式协调&#x2F;通知<br>5、集群管理<br>6、Master 选举<br>7、分布式锁<br>8、分布式队列<br>29. 数据发布&#x2F;订阅<br>介绍<br>数据发布&#x2F;订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者<br>进行数据订阅。<br>目的<br>动态获取数据（配置信息）<br>实现数据（配置信息）的集中式管理和数据的动态更新<br>设计模式<br>Push 模式<br>Pull 模式<br>数据（配置信息）特性<br>1、数据量通常比较小<br>2、数据内容在运行时会发生动态更新<br>3、集群中各机器共享，配置一致<br>如：机器列表信息、运行时开关配置、数据库配置信息等<br>基于 Zookeeper 的实现方式<br> 数据存储：将数据（配置信息）存储到 Zookeeper 上的一个数据节点<br> 数据获取：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并<br>在该节点上注册一个数据变更 Watcher<br> 数据变更：当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper<br>会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即<br>可。<br>30. 负载均衡<br>zk 的命名服务<br>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局<br>的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，<br>或者一个远程的对象等等。<br>分布式通知和协调<br>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，<br>然后 zk 将这些变化发送给注册了这个节点的 watcher 的所有客户端。<br>对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工<br>作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时<br>的全局情况。<br>zk 的命名服务（文件系统）<br>命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局<br>的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，<br>提供的服务的地址，或者一个远程的对象等等。<br>zk 的配置管理（文件系统、通知机制）<br>程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有<br>配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的<br>内容，利用 watcher 通知给各个客户端，从而更改配置。<br>Zookeeper 队列管理（文件系统、通知机制）<br>两种类型的队列：<br>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有<br>成员到达。<br>2、队列按照 FIFO 方式进行入队和出队操作。<br>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。<br>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按<br>编号。在特定的目录下创建 PERSISTENT_SEQUENTIAL 节点，创建成功时<br>Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下<br>Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内<br>容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持<br>久化的，所以不必担心队列消息的丢失问题。</p><p>7、服务提供者能实现失效踢出是什么原理？<br>服务失效踢出基于 zookeeper 的临时节点原理。<br>8、服务上线怎么不影响旧版本？<br>采用多版本开发，不影响旧版本。<br>9、如何解决服务调用链过长的问题？<br>可以结合 zipkin 实现分布式服务追踪。</p><p>12、同一个服务多个注册的情况下可以直连某一个服务吗？<br>可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。<br>13、画一画服务注册与发现的流程图？<br>14、Dubbo 集群容错有几种方案？<br>集群容错方案 说明<br>Failover Cluster 失败自动切换，自动重试其它服务器（默认）<br>Failfast Cluster 快速失败，立即报错，只发起一次调用<br>Failsafe Cluster 失败安全，出现异常时，直接忽略<br>Failback Cluster 失败自动恢复，记录失败请求，定时重发<br>Forking Cluster 并行调用多个服务器，只要一个成功即返回<br>Broadcast Cluster 广播逐个调用所有提供者，任意一个报错则报错<br>15、Dubbo 服务降级，失败重试怎么做？<br>可以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修<br>改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口<br>名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑<br>16、Dubbo 使用过程中都遇到了些什么问题？<br>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解<br>无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确<br>17、Dubbo Monitor 实现原理？<br>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是<br>先走 filter 链，然后才进行真正的业务逻辑处理。<br>默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。<br>1、MonitorFilter 向 DubboMonitor 发送数据<br>2、DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到<br>ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个<br>含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，<br>调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕<br>一个，就重置当前的 Statistics 的 AtomicReference<br>3、SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队<br>列大写为 100000）<br>4、SimpleMonitorService 使用一个后台线程（线程名为：<br>DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以<br>死循环的形式来写）<br>5、SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：<br>DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</p><p>19、Dubbo 配置文件是如何加载到 Spring 中的？<br>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自<br>定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，<br>NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为<br>需要加载的 bean 对象！<br>20、Dubbo SPI 和 Java SPI 区别？<br>JDK SPI<br>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展吃实话很耗时，但<br>也没用上，很浪费资源。<br>所以只希望加载某个的实现，就不现实了<br>DUBBO SPI<br>1，对 Dubbo 进行扩展，不需要改动 Dubbo 的源码<br>2，延迟加载，可以一次只加载自己想要加载的扩展实现。<br>3，增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其<br>它扩展点。<br>3，Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。<br>21、Dubbo 支持分布式事务吗？<br>目前暂时不支持，可与通过 tcc-transaction 框架实现<br>介绍：tcc-transaction 是开源的 TCC 补偿性分布式事务框架<br>Git 地址：<br>TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。<br>22、Dubbo 可以对结果进行缓存吗？<br>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作<br>量<br>&lt;dubbo:reference cache&#x3D;”true” &#x2F;&gt;<br>其实比普通的配置文件就多了一个标签 cache&#x3D;”true”<br>23、服务上线怎么兼容旧版本？<br>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不<br>同的服务相互间不引用。这个和服务分组的概念有一点类似。<br>24、Dubbo 必须依赖的包有哪些？<br>Dubbo 必须依赖 JDK，其他为可选。<br>25、Dubbo telnet 命令能做什么？<br>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。<br>Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令<br>连接服务<br>telnet localhost 20880 &#x2F;&#x2F;键入回车进入 Dubbo 命令模式。<br>查看服务列表<br>dubbo&gt;ls<br>com.test.TestService<br>dubbo&gt;ls com.test.TestService<br>create<br>delete<br>query<br> ls (list services and methods)<br> ls : 显示服务列表。<br> ls -l : 显示服务详细信息列表。<br> ls XxxService：显示服务的方法列表。<br> ls -l XxxService：显示服务的方法详细信息列表。<br>26、Dubbo 支持服务降级吗？<br>以通过 dubbo:reference 中设置 mock&#x3D;”return null”。mock 的值也可以修改<br>为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名<br>称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑<br>27、Dubbo 如何优雅停机？<br>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用<br>kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才<br>会执行。<br>28、Dubbo 和 Dubbox 之间的区别？<br>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如<br>加了服务可 Restful 调用，更新了开源组件等。</p><p>30、你还了解别的分布式框架吗？<br>别的还有 spring 的 spring cloud，facebook 的 thrift，twitter 的 finagle 等</p><p>仅索引层面调优手段：<br>1.1、设计阶段调优<br>1、根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索<br>引；<br>2、使用别名进行索引管理；<br>3、每天凌晨定时对索引做 force_merge 操作，以释放空间；<br>4、采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink<br>操作，以缩减存储；<br>5、采取 curator 进行索引的生命周期管理；<br>6、仅针对需要分词的字段，合理的设置分词器；<br>7、Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。……..<br>1.2、写入调优<br>1、写入前副本数设置为 0；<br>2、写入前关闭 refresh_interval 设置为-1，禁用刷新机制；<br>3、写入过程中：采取 bulk 批量写入；<br>4、写入后恢复副本数和刷新间隔；<br>5、尽量使用自动生成的 id。<br>1.3、查询调优<br>1、禁用 wildcard；<br>2、禁用批量 terms（成百上千的场景）；<br>3、充分利用倒排索引机制，能 keyword 类型尽量 keyword；<br>4、数据量大时候，可以先基于时间敲定索引再检索；<br>5、设置合理的路由机制。<br>1.4、其他调优<br>部署调优，业务调优等。<br>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。<br>2、elasticsearch 的倒排索引是什么<br>面试官：想了解你对基础概念的认知。<br>解答：通俗解释一下就可以。<br>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。<br>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表<br>即为倒排索引。<br>有了倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了<br>检索效率。<br>学术的解答方式：<br>倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文<br>档中出现过，由两部分组成——词典和倒排表。<br>加分项：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结<br>构。<br>lucene 从 4+版本后开始大量使用的数据结构是 FST。FST 有两个优点：<br>1、空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；<br>2、查询速度快。O(len(str))的查询时间复杂度。<br>3、elasticsearch 索引数据多了怎么办，如何调优，部署<br>面试官：想了解大数据量的运维能力。<br>解答：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，<br>这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户<br>检索或者其他业务受到影响。<br>如何调优，正如问题 1 所说，这里细化一下：<br>3.1 动态索引层面<br>基于模板+时间+rollover api 滚动创建索引，举例：设计阶段定义：blog 索<br>引的模板格式为：blog_index_时间戳的形式，每天递增数据。<br>这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线 2 的<br>32 次幂-1，索引存储达到了 TB+甚至更大。<br>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。<br>3.2 存储层面<br>冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。<br>对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，<br>节省存储空间和检索效率。<br>3.3 部署层面<br>一旦之前没有规划，这里就属于应急策略。<br>结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注<br>意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。<br>4、elasticsearch 是如何实现 master 选举的<br>面试官：想了解 ES 集群的底层原理，不再只关注业务层面了。<br>解答：<br>前置前提：<br>1、只有候选主节点（master：true）的节点才能成为主节点。<br>2、最小主节点数（min_master_nodes）的目的是防止脑裂。<br>这个我看了各种网上分析的版本和源码分析的书籍，云里雾里。<br>核对了一下代码，核心入口为 findMaster，选择主节点成功返回对应 Master，否<br>则返回 null。选举流程大致描述如下：<br>第一步：确认候选主节点数达标，elasticsearch.yml 设置的值<br>discovery.zen.minimum_master_nodes；<br>第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；<br>若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。<br>题外话：获取节点 id 的方法。<br>1GET &#x2F;_cat&#x2F;nodes?v&amp;h&#x3D;ip,port,heapPercent,heapMax,id,name<br>2ip port heapPercent heapMax id name<br>5、详细描述一下 Elasticsearch 索引文档的过程<br>面试官：想了解 ES 的底层原理，不再只关注业务层面了。<br>解答：<br>这里的索引文档应该理解为文档写入 ES，创建索引的过程。<br>文档写入包含：单文档写入和批量 bulk 写入，这里只解释一下：单文档写入流程。<br>记住官方文档中的这个图。<br>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由&#x2F;协调节点，<br>请求的节点扮演路由节点的角色。）<br>第二步：节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转<br>到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。<br>第三步：节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1<br>和节点 2 的副本分片上，等待结果返回。所有的副本分片都报告成功，节点 3 将<br>向协调节点（节点 1）报告成功，节点 1 向请求客户端报告写入成功。<br>如果面试官再问：第二步中的文档获取分片的过程？<br>回答：借助路由算法获取，路由算法就是根据路由和文档 id 计算目标的分片 id 的<br>过程。<br>1shard &#x3D; hash(*routing) % (num_of_primary_shards)<br>6、详细描述一下 Elasticsearch 搜索的过程？<br>面试官：想了解 ES 搜索的底层原理，不再只关注业务层面了。<br>解答：<br>搜索拆解为“query then fetch” 两个阶段。<br>query 阶段的目的：定位到位置，但不取。<br>步骤拆解如下：<br>1、假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本<br>分片中）的一个。<br>2、每个分片在本地进行查询，结果返回到本地有序的优先队列中。<br>3、第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。<br>fetch 阶段的目的：取数据。<br>路由节点获取所有文档，返回给客户端。<br>7、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法<br>面试官：想了解对 ES 集群的运维能力。<br>解答：<br>1、关闭缓存 swap;<br>2、堆内存设置为：Min（节点内存&#x2F;2, 32GB）;<br>3、设置最大文件句柄数；<br>4、线程池+队列大小根据业务需要做调整；<br>5、磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单<br>节点存储故障。</p><p>9、Elasticsearch 是如何实现 Master 选举的？<br>1、Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之<br>间通过这个 RPC 来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪<br>些节点需要 ping 通）这两部分；<br>2、对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排<br>序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第 0 位）<br>节点，暂且认为它是 master 节点。<br>3、如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n&#x2F;2+1）并<br>且该节点自己也选举自己，那这个节点就是 master。否则重新选举一直到满足上<br>述条件。<br>4、补充：master 节点的职责主要包括集群、节点和索引的管理，不负责文档级<br>别的管理；data 节点可以关闭 http 功能*。<br>10、Elasticsearch 中的节点（比如共 20 个），其中的 10 个<br>选了一个 master，另外 10 个选了另一个 master，怎么办？<br>1、当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量<br>（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解<br>决脑裂问题；<br>2、当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data<br>节点，避免脑裂问题。<br>11、客户端在和集群连接时，如何选择特定的节点执行请求的？<br>1、TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并<br>不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮<br>询 的方式与这些地址进行通信。<br>12、详细描述一下 Elasticsearch 索引文档的过程。<br>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合<br>适的分片。<br>shard &#x3D; hash(document_id) % (num_of_primary_shards)<br>1、当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory<br>Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Momery<br>Buffer 到 Filesystem Cache 的过程就叫做 refresh；<br>2、当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会<br>丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请<br>求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中<br>时，才会清除掉，这个过程叫做 flush；<br>3、在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync<br>将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一<br>个新的 translog。<br>4、flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认<br>为 512M）时；<br>补充：关于 Lucene 的 Segement：<br>1、Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。<br>2、段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重<br>建索引。<br>3、对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗<br>CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。<br>4、为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并<br>段到磁盘，并删除那些旧的小段。<br>13、详细描述一下 Elasticsearch 更新和删除文档的过程。<br>1、删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不<br>能被删除或者改动以展示其变更；<br>2、磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真<br>的被删除，而是在.del 文件中被标记为删除。该文档依然能匹配查询，但是会在<br>结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入<br>新段。<br>3、在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新<br>时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。<br>旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。<br>14、详细描述一下 Elasticsearch 搜索的过程。<br>1、搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；<br>2、在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分<br>片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的<br>优先队列。<br>PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory<br>Buffer，所以搜索是近实时的。<br>3、每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并<br>这些值到自己的优先队列中来产生一个全局排序后的结果列表。<br>4、接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片<br>提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回<br>文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。<br>5、补充：Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分<br>片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增<br>加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，<br>但是性能会变差。*<br>15、在 Elasticsearch 中，是怎么根据一个词找到对应的倒排索<br>引的？<br>SEE：<br> Lucene 的索引文件格式(1)<br> Lucene 的索引文件格式(2)<br>16、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方<br>法？<br>1、64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。<br>少于 8 GB 会适得其反。<br>2、如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多<br>个内核提供的额外并发远胜过稍微快一点点的时钟频率。<br>3、如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查<br>询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。<br>4、即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群<br>跨越大的地理距离。<br>5、请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在<br>Elasticsearch 的几个地方，使用 Java 的本地序列化。<br>6、通过设置 gateway.recover_after_nodes、gateway.expected_nodes、<br>gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可<br>能会让数据恢复从数个小时缩短为几秒钟。<br>7、Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只<br>有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。<br>8、不要随意修改垃圾回收器（CMS）和各个线程池的大小。<br>9、把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过<br>ES_HEAP_SIZE 环境变量设置。<br>10、内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个<br>100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起<br>来。 不难看出 swapping 对于性能是多么可怕。<br>11、Lucene 使用了大量 的文件。同时，Elasticsearch 在节点和 HTTP 客户端<br>之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你<br>应该增加你的文件描述符，设置一个很大的值，如 64,000。<br>补充：索引阶段性能提升方法<br>1、使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。<br>2、存储：使用 SSD<br>3、段和合并：Elasticsearch 默认值是 20 MB&#x2F;s，对机械磁盘应该是个不错的设<br>置。如果你用的是 SSD，可以考虑提高到 100–200 MB&#x2F;s。如果你在做批量导入，<br>完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加<br>index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的<br>值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。<br>4、如果你的搜索结果不需要近实时的准确度，考虑把每个索引的<br>index.refresh_interval 改到 30s。<br>5、如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副<br>本。<br>17、对于 GC 方面，在使用 Elasticsearch 时要注意什么？<br>1、SEE：<br>2、倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment<br>memory 增长趋势。<br>3、各类缓存，field cache, filter cache, indexing cache, bulk queue 等等，要<br>设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓<br>存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache<br>等“自欺欺人”的方式来释放内存。<br>4、避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用<br>scan &amp; scroll api 来实现。<br>5、cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集<br>群通过 tribe node 连接。<br>6、想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做<br>持续的监控。<br>18、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？<br>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，<br>即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对<br>我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到<br>基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；<br>小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内<br>存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。<br>19、在并发情况下，Elasticsearch 如果保证读写一致？<br>1、可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用<br>层来处理具体的冲突；<br>2、另外对于写操作，一致性级别支持 quorum&#x2F;one&#x2F;all，默认为 quorum，即只<br>有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络<br>等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点<br>上重建。<br>3、对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副<br>本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜<br>索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。<br>20、如何监控 Elasticsearch 集群状态？<br>Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你<br>的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/7e68be57c290.html" rel="prev" title="消息队列（MQ）"><i class="fa fa-angle-left"></i> 消息队列（MQ）</a></div><div class="post-nav-item"><a href="/publishes/22829df8f04f.html" rel="next" title="Java基础">Java基础 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">746k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">11:18</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>