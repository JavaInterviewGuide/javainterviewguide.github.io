<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#5391fe" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.png" color="#5391fe"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CComic+Sans+MS:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-material.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"javainterviewguide.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.19.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#5391fe","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8070896123414715" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TQWRP5B4WS"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TQWRP5B4WS")</script><meta name="description" content="说说反射的用途及实现 Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架 Java反射的主要功能： 确定一个对象的类 取出类的modifiers,数据成员,方法,构造器,和超类. 找出某个接口里定义的常量和方法说明. 创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象). 取得和设定"><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><meta property="og:site_name" content="Java面试指南"><meta property="og:description" content="说说反射的用途及实现 Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架 Java反射的主要功能： 确定一个对象的类 取出类的modifiers,数据成员,方法,构造器,和超类. 找出某个接口里定义的常量和方法说明. 创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象). 取得和设定"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-12-20T01:28:17.000Z"><meta property="article:modified_time" content="2024-01-04T03:43:00.073Z"><meta property="article:author" content="褚岩"><meta property="article:tag" content="java"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://javainterviewguide.github.io/publishes/5352a96111d6.html","path":"publishes/5352a96111d6.html","title":"Java基础"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Java基础 | Java面试指南</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Java面试指南</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">说说反射的用途及实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E5%86%99%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">重载 重写（覆写）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC-%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">JDBC 流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">HashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashSet-%E5%92%8C-HashMap-%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">HashSet 和 HashMap 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">HashMap 和 ConcurrentHashMap 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">Java中创建线程主要有三种方式：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sleep-%E3%80%81join%EF%BC%88%EF%BC%89%E3%80%81yield%EF%BC%88%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">sleep() 、join（）、yield（）有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">java反射的作用与原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9"><span class="nav-number">10.</span> <span class="nav-text">泛型常用特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90XML%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%89%B9%E7%82%B9%EF%BC%9ADOM%E3%80%81SAX"><span class="nav-number">11.</span> <span class="nav-text">解析XML的几种方式的原理与特点：DOM、SAX</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">褚岩</p><div class="site-description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">58</span> <span class="site-state-item-name">标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://javainterviewguide.github.io/publishes/5352a96111d6.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="褚岩"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Java面试指南"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Java基础 | Java面试指南"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java基础</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-20 09:28:17" itemprop="dateCreated datePublished" datetime="2023-12-20T09:28:17+08:00">2023-12-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-04 11:43:00" itemprop="dateModified" datetime="2024-01-04T11:43:00+08:00">2024-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>159k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2:24</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h1><ul><li>Java反射机制主要提供了以下功能：在运行时构造一个类的对象；判断一个类所具有的成员变量和方法；调用一个对象的方法；生成动态代理。反射最大的应用就是框架</li><li>Java反射的主要功能：<ul><li>确定一个对象的类</li><li>取出类的modifiers,数据成员,方法,构造器,和超类.</li><li>找出某个接口里定义的常量和方法说明.</li><li>创建一个类实例,这个实例在运行时刻才有名字(运行时间才生成的对象).</li><li>取得和设定对象数据成员的值,如果数据成员名是运行时刻确定的也能做到.</li><li>在运行时刻调用动态对象的方法.</li></ul></li></ul><h1 id="重载-重写（覆写）"><a href="#重载-重写（覆写）" class="headerlink" title="重载 重写（覆写）"></a>重载 重写（覆写）</h1><ul><li>方法名称相同，参数的类型或个数不同</li><li>方法名称、参数类型、返回值类型全部相同</li><li>权限 对权限没要求 被重写的方法不能拥有更严格的权限</li><li>范围 发生在一个类中 发生在继承类中</li><li>创建数组,数组大小和类型在运行时刻才确定,也能更改数组成员的值.</li><li>反射的应用很多，很多框架都有用到<ul><li>spring 的 ioc&#x2F;di 也是反射…</li><li>javaBean和jsp之间调用也是反射…</li><li>struts的 FormBean 和页面之间…也是通过反射调用…</li><li>JDBC 的 classForName()也是反射…</li><li>hibernate的 find(Class clazz) 也是反射…</li><li>反射还有一个不得不说的问题，就是性能问题，大量使用反射系统性能大打折扣</li></ul></li></ul><h1 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h1><ul><li>加载JDBC驱动程序</li><li>提供JDBC连接的URL</li><li>创建数据库的连接</li><li>创建一个Statement</li><li>执行SQL语句</li><li>处理结果</li><li>关闭JDBC对象</li></ul><h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><p>1.hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和<br>containsKey（）方法。<br>2.hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。<br>3.hashMap允许空键值，而hashTable不允许。<br>注意：<br>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状<br>态。<br>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p><h1 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h1><p>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是<br>用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过<br>key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象</p><h1 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h1><p>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上<br>都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更<br>好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>HashMap 的工作原理及代码实现<br>参考：<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，<br>当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时<br>间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，<br>16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一<br>个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来<br>决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步<br>机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只<br>是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个<br>Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此<br>HashTable已经被淘汰了。</p><h1 id="Java中创建线程主要有三种方式："><a href="#Java中创建线程主要有三种方式：" class="headerlink" title="Java中创建线程主要有三种方式："></a>Java中创建线程主要有三种方式：</h1><p>一、继承Thread类创建线程类<br>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完<br>成的任务。因此把run()方法称为执行体。<br>（2）创建Thread子类的实例，即创建了线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。getName()方法返<br>回调用该方法的线程的名字。<br>二、通过Runnable接口创建线程类<br>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是<br>该线程的线程执行体。<br>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该<br>Thread对象才是真正的线程对象。<br>（3）调用线程对象的start()方法来启动该线程。<br>三、通过Callable和Future创建线程<br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且<br>有返回值。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对<br>象封装了该Callable对象的call()方法的返回值。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><h1 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h1><p>1、sleep()方法<br>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度<br>程序精度和准确性的影响。 让其他线程有机会继续执行，但它并不释放对象锁。也就是如<br>果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常<br>比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一<br>个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级<br>的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。<br>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的<br>线程有执行的机会。<br>2、yield()方法<br>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方<br>法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态<br>后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也<br>和sleep()方法不同。<br>3、join()方法<br>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，<br>B不能工作。<br>保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有<br>存活，则当前线程不需要停止。<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲<br>突。<br>在Java里，线程安全一般体现在两个方面：<br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关<br>键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有<br>synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，<br>问题就出现了。<br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在<br>java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>volatile 实现原理<br>聊聊并发（一）——深入分析Volatile的实现原理<br>悲观锁 乐观锁<br>乐观锁 悲观锁<br>是一种思想。可以用在很多方面。<br>比如数据库方面。<br>悲观锁就是for update（锁定查询的行）<br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读­<br>比较­写的操作。）<br>JDK方面：<br>悲观锁就是sync<br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。<br>乐观锁就认为，基本没人抢。<br>CAS 乐观锁<br>乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出<br>当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重<br>复读­比较­写的操作。<br>CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。<br>CAS顶多算是乐观锁写那一步操作的一种实现方式罢了，不用CAS自己加锁也是可以的。<br>ABA 问题<br>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A，当前线程的CAS<br>操作无法分辨当前V值是否发生过变化。<br>参考：<br>Java CAS 和ABA问题<br>乐观锁的业务场景及实现方式<br>乐观锁（Optimistic Lock）：<br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，<br>但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不<br>进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，<br>期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可<br>能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量<br>的查询操作，降低了系统的吞吐量。<br>核心篇<br>数据存储<br>MySQL 索引使用的注意事项<br>参考：<br>mysql索引使用技巧及注意事项<br>说说反模式设计<br>参考：<br>每个程序员要注意的 9 种反模式<br>说说分库与分表设计<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策<br>说说 SQL 优化之道<br>sql优化的几种方法<br>微服务哪些框架<br>Spring Cloud、Dubbo、Hsf等<br>你怎么理解 RPC 框架<br>RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这<br>个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。<br>说说 RPC 的实现原理<br>参考：<br>你应该知道的 RPC 原理<br>从零开始实现RPC框架 ­ RPC原理及实现<br>分布式<br>谈谈业务中使用分布式的场景<br>一、解决java集群的session共享的解决方案：<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>二、分布式事务的解决方案:<br>1.TCC解决方案：try confirm cancel。<br>参考：<br>为什么说传统分布式事务不再适用于微服务架构？<br>Session 分布式方案<br>1.客户端cookie加密。（一般用于内网中企业级的系统中，要求用户浏览器端的cookie不能<br>禁用，禁用的话，该方案会失效）。<br>2.集群中，各个应用服务器提供了session复制的功能，tomcat和jboss都实现了这样的功<br>能。特点：性能随着服务器增加急剧下降，容易引起广播风暴；session数据需要序列化，<br>影响性能。<br>3.session的持久化，使用数据库<br>更多Java技术资料视频分享+QQ2118797017<br>来保存session。就算服务器宕机也没事儿，数据库中的<br>session照样存在。特点：每次请求session都要读写数据库，会带来性能开销。使用内存数<br>据库，会提高性能，但是宕机会丢失数据(像支付宝的宕机，有同城灾备、异地灾备)。<br>4.使用共享存储来保存session。和数据库类似，就算宕机了也没有事儿。其实就是专门搞<br>一台服务器，全部对session落地。特点：频繁的进行序列化和反序列化会影响性能。<br>5.使用memcached来保存session。本质上是内存数据库的解决方案。特点：存入<br>memcached的数据需要序列化，效率极低。<br>分布式锁的场景<br>比如交易系统的金额修改，同一时间只能又一个人操作，比如秒杀场景，同一时间只能一个<br>用户抢到，比如火车站抢票等等<br>分布式锁的实现方案<br>26. 基于数据库实现分布式锁<br>27. 基于缓存实现分布式锁<br>28. 基于Zookeeper实现分布式锁<br>参考：<br>分布式锁的多种实现方式<br>分布式事务<br>参考：<br>深入理解分布式事务,高并发下分布式事务的解决方案<br>集群与负载均衡的算法与实现<br>参考：<br>负载均衡算法及手段<br>说说分库与分表设计<br>参考：<br>分表与分库使用场景以及设计方式<br>分库与分表带来的分布式困境与应对之策<br>安全&amp;性能<br>安全问题<br>安全要素与 STRIDE 威胁<br>防范常见的 Web 攻击<br>XSS攻击<br>跨站脚本攻击;<br>是什么：攻击者向有XSS漏洞的网站中输入恶意的HTML代码，当其浏览器浏览该网站<br>时，这段HTML代码会自­ ­ 动执行。（理论上所有可以输入的地方没有对输入的数据进<br>行处理，都会存在XSS攻击）;<br>危害： 盗取用户cookie，破坏页面结构，重定向到其他网站;<br>防御：对用户输入的信息进行处理，只允许合法的值;<br>CSRF攻击<br>跨站请求伪造<br>是什么：攻击者盗用了你的身份，以你的名义发送恶意请求;<br>危害：以你的名义发送邮件，盗取帐号，购买东西等;<br>原理： 首先个登录某网站，并在本地生成cookie;然后在不登出的情况下，访问危害网<br>站。<br>防御： 可以从服务端和客户端两方面进行考虑。但是在服务端的效果好。<br>a. 随机的cookie<br>b. 添加验证码<br>c. 不同的表单包含一个不同的伪随机值<br>注意：如果用户在一个站点上同时打开了两个不同的表单。CSRF保护措施不应该影响<br>到他对任何表单的提交<br>SQL注入<br>是什么：通过sql命令伪装成正常的http请求参数，传递到服务端，服务器执行sql命令<br>造成对数据库进行攻击<br>原理：sql语句伪造参数，然后在对参数机型拼接后形成破坏性的sql语句，最后导致数<br>据库收到攻击<br>防御：<br>a. 对参数进行转义<br>b. 数据库中的密码不应明文存储，可以对密码使用md5进行加密。<br>DDOS攻击（分布式拒绝服务攻击）<br>是什么：简单来说就是ifasong大量的请求使服务器瘫痪。<br>被攻击的原因：服务器带宽不足，不能挡住攻击者的攻击流量。<br>防御：<br>a. 最直接的方法就是增加带宽;<br>b. 使用硬件防火墙;<br>c. 优化资源使用提高 web server 的负载能力<br>服务端通信安全攻防<br>HTTPS 原理剖析<br>HTTPS 降级攻击<br>授权与认证<br>基于角色的访问控制<br>基于数据的访问控制<br>基于角色的访问控制，只验证访问数据的角色，但是没有对角色内的用户做细分。举个例<br>子，用户甲与用户乙都具有用一个角色，但是如果只建立基于角色的访问控制，那么用户甲<br>可以对用户乙的数据进行任意操作，从而发生了越权访问。因此，在业务场景中仅仅使用基<br>于角色的访问控制是不够的，还需要引入基于数据的访问控制。如果将基于角色的访问控制<br>视为一种垂直权限控制，那么，基于数据的访问控制就是一种水平权限控制。在业务场景<br>中，往往对基于数据的访问控制不够重视，举个例子，评论功能是一个非常常见的功能，用<br>户可以在客户端发起评论，回复评论，查看评论，删除评论等操作。一般情况下，只有本人<br>才可以删除自己的评论，如果此时，业务层面没有建立数据的访问控制，那么用户甲可以试<br>图绕过客户端，通过调用服务端RESTful API 接口，猜测评论 ID 并修改评论 ID 就可以删除<br>别人的评论。事实上，这是非常严重的越权操作。除此之外，用户之间往往也存在一些私有<br>的数据，而这些私有的数据在正常情况下，只有用户自己才能访问。<br>基于数据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引<br>起重视。这里，再次使用删除评论的案例，通过 Java 语言进行介绍。在这个案例中，核心<br>的代码片段在于，判断当前用户是否是评论的创建者，如果是则通过，不是则报出没有权限<br>的错误码。那么，这样就可以很好地防止数据的越权操作。<br>总结下，基于角色的访问控制是一种垂直权限控制，通过建立用户与角色的对应关系，使得<br>不同角色之间具有高低之分。用户根据拥有的角色进行操作与资源访问。基于数据的访问控<br>制是一种水平权限控制，它对角色内的用户做细分，确保用户的数据不能越权操作。基于数<br>据的访问控制，需要业务层面去处理，但是这个也是最为经常遗落的安全点，需要引起重<br>视。<br>性能优化<br>性能指标有哪些<br>如何发现性能瓶颈<br>性能调优的常见手段<br>说说你在项目中如何进行性能调优</p><p>1.八种基本数据类型的大小，以及他们的封装类<br>double—Double 8位0.0d<br>float —Float 4位0.0f<br>long —Long8位0L<br>int —Integer 4位0<br>short —Short 2位(short)0<br>byte —byte1位(byte)0<br>char —Character 2位null\u0000<br>boolean —Boolean – false<br>2.引用数据类型<br>数组，类，接口<br>3.Switch能否用string做参数<br>以前只能支持byte、short、char、int，可以强转<br>Jdk7.0以后可以，整型、枚举类型、boolean、字符串都可以<br>4.equals与&#x3D;&#x3D;的区别*<br>&#x3D;&#x3D;比较的是2个对象的地址，而equals比较的是2个对象的内容<br>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。<br>Equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。<br>5.自动装箱，常量池<br>自动装箱：基本数据类型对象类型<br>自动拆箱：对象类型基本数据类型<br>常量池：Byte,Short,Integer,Long,Character在自动装箱时对于值从–128到127之间的值（共享），会存在内存中被重用<br>字符串常量池<br>常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s &#x3D; “java”这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。<br>6.Object有哪些公用方法<br>clone(),hashCode(),equals(),notify(),notifyAll(),wait(),getClass(),toString,finalize()<br>8.Hashcode的作用*<br>利用哈希算法，配合基于散列的集合一起正常运行，Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值，降低equals的调用，实现存放的值不会重复。<br>Note:重写equals必须重写hashcode方法，equals相等，hashcode也必须相等。<br>一般对于存放到Set集合或者Map中键值对的元素，需要按需要重写hashCode与equals方法，以保证唯一性！<br>例如hashset存放多个对象，重写equals和hashcode<br>两个对象相等，其HashCode一定相同;<br>两个对象不相等，其HashCode有可能相同;<br>HashCode相同的两个对象，不一定相等;<br>HashCode不相同的两个对象，一定不相等;<br>9.HashMap的hashcode的作用*<br>Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 equals方法可用于保证元素不重复，但是，如果每增加一个元素就检查一次，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次equals方法。这显然会大大降低效率。<br>HashMap的数据结构是 数组+链表形式存储数据，继承AbstractMap，实现Map接口，主要用于查找的快捷性。<br>10.为什么重载hashCode方法？*<br>一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是object对象，必须重载hashCode和equal方法。<br>11.ArrayList、LinkedList、Vector的区别*<br>ArrayList： 线程不安全，数组，适合查找，可自动扩容50%<br>三个构造器，无参，容量，Collection接口，transient Object[] elementData;不被序列化。<br>LinkedList：线程不安全，链表，审核插入，删除<br>Vector： 线程安全，数组，适合查找，可自动扩容100%<br>12.String、StringBuffer与StringBuilder的区别*<br>String 是final修饰的，字符串常量，String对象一旦创建之后该对象是不可更改的<br>StringBuffer 字符串变量，对象可变，线程安全，适合多线程下字符缓冲区大量操作<br>StringBuider 字符串变量，对象可变，线程不安全，适用单线程下载字符缓冲区进行大量操作的情况，都是继承AbstractStringBuilder super.容量为16<br>13.Map、Set、List、Queue、Stack的特点与用法。<br>Map map集合，k-v键值对存储<br>HashTable 和 HashMap 是 Map 的实现类   <br>HashTable 是线程安全的，不能存储 null 值   <br>HashMap 不是线程安全的，可以存储 null 值  <br>TreeMap可以保证顺序，HashMap不保证顺序，即为无序的。<br>Set 集合，无序，不重复<br>List 数组集合，ArrayList ， Vector ， LinkedList 是 List 的实现类<br>ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的<br>LinkedList 是线程不安全的，底层是由链表实现的   <br>Queue 队列，提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。<br>Stack 栈，继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。<br>HashMap和HashTable的区别<br>14.JDK7与JDK8中HashMap的实现*<br>JDK8在JDK7的基础上引入了红黑树-b，因为链表过长，会导致效率很低，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率<br>15.HashMap和ConcurrentHashMap的区别，HashMap的底层源码*<br>HashMap是线程不安全的，ConcurrentHashMap是线程安全的，适用于高并发，ConcurrentHashMap就是一个分段的hashtable，根据自定的hashcode算法生成的对象来获取对应hashcode的分段块进行加锁，不用整体加锁，提高了效率。<br>HashMap的get（key）方法是获取key的hash值，计算hash&amp;（n-1）得到在链表数组中的位置first&#x3D;tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可。<br>HashMap的put（key）方法是判断键值对数组tab[]是否为空或位null，否则以默认大小resize()；根据键值key计算hash值得到插入的数组索引i，如果tab[i]&#x3D;&#x3D;null,直接新建节点添加，否则判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可)，分别处理。<br>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比<em>Node.length）重新调整HashMap大小 变为原来2倍大小,扩容很耗时<br>16.ConcurrentHashMap能完全替代HashTable吗？<br>Hash table虽然性能上不如ConcurrentHashMap，但并不能完全被取代，两者的迭代器的一致性不同的，ConcurrentHashMap由于分段锁，弱一致性主要是为了提升效率。<br>强一致性就如hashtable一样，锁整个map。<br>17.为什么HashMap是线程不安全的</em><br>在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，如图中a1、a2，这个时候需要解决碰撞冲突，而解决冲突的办法上面已经说过，对于链表的结构在这里不再赘述，暂且不讨论是从链表头部插入还是从尾部初入，这个时候两个线程如果恰好都取到了对应位置的头结点e1，而最终的结果可想而知，a1、a2两个数据中势必会有一个会丢失<br>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。<br>18.多并发情况下HashMap是否还会产生死循环*<br>不会，jdk1.8版本以后已经没有这个问题了，没有transfer这个函数了do while可能造成的死循环，对原有造成死锁的关键原因点（新table复制在头端添加元素）改进为依次在末端添加新的元素<br>19.TreeMap、HashMap、LindedHashMap的区别*<br>LinkedHashMap可以保证HashMap集合有序。存入的顺序和取出的顺序一致。<br>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。<br>HashMap不保证顺序，即为无序的，具有很快的访问速度。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步。<br>20.Collection包结构，与Collections的区别<br>Collection是个java.util下的接口，它是各种集合结构的父接口。<br>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<br>21.try?catch?finally，try里有return，finally还执行么<br>如果finally没有return 相同返回值变量，则返回try里面的return，否则finally 的return 值会影响 try里面return结果。<br>finally还是会执行的，除非中途遇到jvm退出。<br>22.Excption与Error包结构，OOM你遇到过哪些情况，SOF你遇到过哪些情况<br>都是Throwable的子类，Exception指出了合理的应用程序想要捕获的条件。Error 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件<br>Java Heap 溢出，虚拟机栈和本地方法栈溢出，运行时常量池溢出，方法区溢出<br>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br>23.Java(OOP)面向对象的三个特征与含义<br>封装：可见性封装，setget读写，将类的某些特征隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。<br>继承：子类继承父类，可以得到父类的全部属性和方法（除了父类中的构造方法），java中的多继承可以通过接口来实现。<br>多态：一种是编译时多态，另外一种是运行时多态，编译时多态是通过方法的重载来实现的，运行时多态是通过方法的重写来实现的。<br>26.Static?class?与non?static?class的区别<br>内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。<br>非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。java多态的实现原理。<br>27.foreach与正常for循环效率对比<br>对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。<br>28.Java?IO与NIO*<br>NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I&#x2F;O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征<br>IO是面向流的，NIO是面向块（缓冲区）的。<br>IO是阻塞的，NIO是非阻塞的。<br>多连接，少数据可以用NIO<br>少连接，大数据可以用IO</p><h1 id="java反射的作用与原理"><a href="#java反射的作用与原理" class="headerlink" title="java反射的作用与原理"></a>java反射的作用与原理</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>在JAVA中，只有给定类的名字，就可以通过反射机制来获取类的所有信息，可以动态的创建对象和编译。<br>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。</p><h1 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h1><p>泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。<br>使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。<br>通过类型擦除来实现</p><h1 id="解析XML的几种方式的原理与特点：DOM、SAX"><a href="#解析XML的几种方式的原理与特点：DOM、SAX" class="headerlink" title="解析XML的几种方式的原理与特点：DOM、SAX"></a>解析XML的几种方式的原理与特点：DOM、SAX</h1><p>DOM分析器是把整个XML文档转化为DOM树放在内存中<br>SAX解析采用事件驱动，通过事件处理函数实现对xml文档的访问。<br>21.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？<br>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁<br>22.Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？<br>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。<br>而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性<br>Put和读取多线程导致的问题。<br>23.ConcurrentHashMap的并发度是什么？*<br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势<br>24.ReentrantReadWriteLock读写锁的使用？<br>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 <br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；<br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！<br>36.高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？*<br>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看： 　　<br>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 　　<br>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换<br>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。<br>39.如果同步块内的线程抛出异常会发生什么？<br>只要退出了synchronized块，无论是正常还是异常，都会释放锁。<br>40.并发编程（concurrency）并行编程（parallellism）有什么区别？*<br>并发（concurrency）和并行（parallellism）是：<br>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>解释三：并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务。如hadoop分布式集群<br>41.如何保证多线程下 i++ 结果正确？<br>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。<br>42.一个线程如果出现了运行时异常会怎么样?<br>如果该异常被捕获或抛出，则程序继续运行。 <br>如果异常没有被捕获该线程将会停止执行。 <br>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理<br>46.Java中用到的线程调度算法是什么*<br>操作系统的核心，它实际就是一个常驻内存的程序，不断地对线程队列进行扫描，利用特定的算法（时间片轮转法、优先级调度法、多级反馈队列调度法等）找出比当前占有CPU的线程更有CPU使用权的线程，并从之前的线程中收回处理器，再使待运行的线程占用处理器。<br>10.分派：静态分派与动态分派。<br>静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。（重载）在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的<br>动态分派：（重写）<br>数据结构与算法<br>1.链表与数组。<br>数组：ArrayList—静态分配内存，内存连续。数组元素在栈区。<br>链表：LinkedList—手持下一个人的地址，动态内存分配，内存不连续。数组元素在堆区<br>2.队列和栈，出栈与入栈。<br>queue队列是先进先出<br>入栈，s.push(x)<br>出栈，s.pop()<br>访问栈顶，s.top()<br>判断栈空，s.empty()<br>访问栈中的元素个数，s.size()<br>stack栈是先入后出<br>入队，q.push(x)<br>出队，q.pop()<br>访问队首元素，q.front()、访问队尾元素，q.back()<br>判断队列空，q.empty()<br>访问队列中的元素个数，q.size()<br>3.链表的删除、插入、反向。*<br>数据域，指针域，当前节点<br>删除需要找到上一个节点，然后指向下下节点，size减去1<br>插入，找上一个节点，设置next到新节点，新节点初始化上一节点的current.next<br>反向：head.getnext获取末尾节点，然后以此重新指向反转（递归反转法）<br>遍历反转法，按顺序依次反转。<br>4.字符串操作。<br>(1)字符串的连接<br>public String concat(String str) <br>该方法的参数为一个String类对象,作用是将参数中的字符串str连接到原来字符串的后面. <br>(2)求字符串的长度<br>public int length()<br>返回字串的长度,这里的长度指的是字符串中Unicode字符的数目.<br>(3)求字符串中某一位置的字符<br>public char charAt(int index)<br>该方法在一个特定的位置索引一个字符串,以得到字符串中指定位置的字符.值得注意的是,在字符串中第一个字符的索引是0,第二个字符的索引是1,依次类推,最后一个字符的索引是length()-1. <br>(4)字符串的比较<br>比较字符串可以利用String类提供的下列方法:<br>1)public int compareTo(String anotherString)<br>该方法比较两个字符串,和Character类提供的compareTo方法相似,Character类提供的compareTo方法比较的是两个字符类数据,而这里比较的是字符串数据.<br>其比较过程实际上是两个字符串中相同位置上的字符按Unicode中排列顺序逐个比较的结果.如果在整个比较过程中,没有发现任何不同的地方,则表明两个字符串是完全相等的,compareTo方法返回0;如果在比较过程中,发现了不同的地方,则比较过程会停下来,这时一定是两个字符串在某个位置上不相同,如果当前字符串在这个位置上的字符大于参数中的这个位置上的字符,compareTo方法返回一个大于0的整数,否则返回一个小于0的整数. <br>2)public boolean equals(Object anObject)<br>该方法比较两个字符串,和Character类提供的equals方法相似,因为它们都是重载Object类的方法.该方法比较当前字符串和参数字符串,在两个字符串相等的时候返回true,否则返回false.<br>3)public boolean equalsIgnoreCase(String anotherString)<br>该方法和equals方法相似,不同的地方在于,equalsIgnoreCase方法将忽略字母大小写的区别.<br>(5)从字符串中提取子串<br>利用String类提供的substring方法可以从一个大的字符串中提取一个子串,该方法有两种常用的形式:<br>1)public String substring(int beginIndex)<br>该方法从beginIndex位置起,从当前字符串中取出剩余的字符作为一个新的字符串返回.<br>2)public String substring(int beginIndex, int endIndex)<br>该方法从当前字符串中取出一个子串,该子串从beginIndex位置起至endIndex-1为结束.子串返的长度为endIndex-beginIndex. <br>(6)判断字符串的前缀和后缀<br>判断字符串的前缀是否为指定的字符串利用String类提供的下列方法:<br>1)public boolean startsWith(String prefix)<br>该方法用于判断当前字符串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>2)public boolean startsWith(String prefix, int toffset)<br>该方法用于判断当前字符串从toffset位置开始的子串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.<br>判断字符串的后缀是否为指定的字符串利用String类提供的方法:<br>public boolean endsWith(String suffix)<br>该方法用于判断当前字符串的后缀是否和参数中指定的字符串suffix一致,如果是,返回true,否则返回false.<br>(7)字符串中单个字符的查找<br>字符串中单个字符的查找可以利用String类提供的下列方法:<br>1)public int indexOf(int ch)<br>该方法用于查找当前字符串中某一个特定字符ch出现的位置.该方法从头向后查找,如果在字符串中找到字符ch,则返回字符ch在字符串中第一次出现的位置;如果在整个字符串中没有找到字符ch,则返回-1. <br>2)public int indexOf(int ch, int fromIndex)<br>该方法和第一种方法类似,不同的地方在于,该方法从fromIndex位置向后查找,返回的仍然是字符ch在字符串第一次出现的位置. <br>3)public int lastIndexOf(int ch)<br>该方法和第一种方法类似,不同的地方在于,该方法从字符串的末尾位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>4)public int lastIndexOf(int ch, int fromIndex)<br>该方法和第二种方法类似,不同的地方在于,该方法从fromIndex位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.<br>(8)字符串中子串的查找<br>字符串中子串的查找与字符串中单个字符的查找十分相似,可以利用String类提供的下列方法:<br>1)public int indexOf(String str)<br>2)public int indexOf(String str, int fromIndex)<br>3)public int lastIndexOf(String str)<br>4)public int lastIndexOf(String str, int fromIndex) <br>(9)字符串中字符大小写的转换<br>字符串中字符大小写的转换,可以利用String类提供的下列方法:<br>1)public String toLowerCase()<br>该方法将字符串中所有字符转换成小写,并返回转换后的新串.<br>2)public String toUpperCase()<br>该方法将字符串中所有字符转换成大写,并返回转换后的新串. <br>(10)字符串中多余空格的去除<br>public String trim()<br>该方法只是去掉开头和结尾的空格,并返回得到的新字符串.值得注意的是,在原来字符串中间的空格并不去掉. <br>(11)字符串中字符的替换<br>1)public String replace(char oldChar,char newChar)<br>该方法用字符newChar替换当前字符串中所有的字符oldChar,并返回一个新的字符串.<br>2)public String replaceFirst(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的第一个和字符串regex相一致的子串,并将产生的新字符串返回. <br>3)public String replaceAll(String regex, String replacement)<br>该方法用字符串replacement的内容替换当前字符串中遇到的所有和字符串regex相一致的子串,并将产生的新字符串返回. <br>字符串变量与StringBuffer类 <br>1.创建StringBuffer类对象<br>StringBuffer类对象表示的是字符串变量,每一个StringBuffer类对象都是可以扩充和修改的字符串变量.以下是常用的StringBuffer类构造函数:<br>(1)public StringBuffer()<br>(2)public StringBuffer(int length) <br>(3)public StringBuffer(String str)  <br>5.Hash表的hash函数，冲突解决方法有哪些。<br>开放定址法或者叫再散列法；<br>1&gt;线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；<br>    2&gt;二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di&#x3D;12 -12 22 -22….k2 -k2;<br>    3&gt;伪随机探测再散列：di&#x3D;伪随机序列；<br>再哈希法；<br>拉链法。<br>6.各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。<br>相连元素两两比较，大的往后放，第一次完毕后，最大值就出现在了最大索引处。同理，，继续，即可得到一个排好序的数组。<br>选择排序原理：<br>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i&#x3D;1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。<br>插入排序原理：<br>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>归并排序的原理:<br>从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。<br>快速排序的原理:<br>从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。<br>堆排序的原理:<br>堆排序从小到大排序：首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，再将除了最后一个数的n-1个元素建立成大顶堆，再将最大元素和数组倒数第二个元素进行交换，重复直至堆大小减为1。<br>希尔排序的原理:<br>希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。<br>桶排序的原理:<br>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。<br>7.快排的partition函数与归并的Merge函数。<br>partition函数：双向扫描<br>Merge函数:最后再看每一组（一对）子表的归并，其原理是相同的，只是子表表长不同，换句话说，是子表的首记录号与尾记录号不同，把这个归并操作作为核心算法写成函数 merge <br>8.对冒泡与快排的改进。*<br>8.1 对冒泡的改进<br>    改进1：设置一个标志位，标志位代表在某一个冒泡遍历时候是否发生位置数据的交换，如果没有交换，则表明序列已经排序完成，否则继续排序。减少不必要的遍历。 <br>    改进2：再设置一个标志位，标志位是序列的某个下标，下标之后的代表已经排序完成，下标之前未排序，则遍历大于标志位时，不再遍历。减少一次遍历中已排完序的序列的遍历 <br>    改进3：在一次遍历时，同时找出最大值和最小值，从而提高效率。 <br>参考：排序算法（一）——冒泡排序及改进<br>8.2对快排的改进<br>基准的选取影响快排的效率，一般基准的选取有三种： <br>    1）固定位置。选序列第一位或者最后一位，算法的导论中提到的就是固定选择最后一位。 <br>    2）随机选取。对于序列中部分有序的情况，如果选择固定位置作为基准，会导致全序列都需要交换位置，这会使得效率低下。因此会采用随机选取数据作为基准。 <br>    3）三数取中。最佳划分是将序列划分成等长的两个子序列，因此提出三数取中的思想。取序列中，下标第一位，下标中间一位，下标最后一位的三个数进行排序，取排序结果中排中间的数据作为基准。（此外，也可以取5个数作为数据的基准。） <br>参考：三种快速排序以及快速排序的优化 <br>    针对以上三种情况中，三数取中效果最优，但是依然无法解决序列中出现重复情况，对此进行再次优化： <br>    优化1：当待排序序列的长度分割到一定大小后，使用插入排序。对于很小和部分有序的数组，快排不如插排好。 <br>    优化2：与基准值相同的不加入分割。在每一次分割结束后，可以把与基准相等的元素聚在一起，继续下次分割时，不用再对与基准相等元素分割。减少重复序列的反复分割 <br>    优化3：优化递归操作，快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。 <br>    这里提一下尾递归，如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归。需要说明的是递归调用必须整个函数体中最后执行的语句且它的返回值不属于表达式的一部分。 <br>尾递归的优点： <br>    1）尾递归通过迭代的方式，不存在子问题被多次计算的情况 <br>    2）尾递归的调用发生在方法的末尾，在计算过程中，完全可以把上一次留在堆栈的状态擦掉，保证程序以O(1)的空间复杂度运行。 <br>    可惜的是，在jvm中第二点并没有被优化。 <br>9.二分查找，与变种二分查找。<br>二分查找的中间下标：mid&#x3D;low+0.5∗(high−low)mid&#x3D;low+0.5∗(high−low) <br>    二分+插值： <br>    如果序列长度为1000，查找的关键字在10位置上，则还是需要从500中间开始二分查找，这样会产生多次无效查询，因此优化的方式就是更改分割的比例，采用三分，四分，分割位置：mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key)mid′&#x3D;low+(high−low)∗(key−a[low])&#x2F;(a[high]−key) <br>    插值查找是根据要查找的关键字的key与查找表中最大最小记录的关键字比较之后的查找算法。 <br>    黄金分割比：用黄金分割比来作为mid值<br>10.二叉树、B+树、AVL树、红黑树、哈夫曼树。<br>二叉树：<br>二叉树的数据结构就不多说了，这里列举一些常见题目 <br>1）求解二叉树的节点 <br>    递归求解： <br>        a) 树为空，节点数为0 <br>        b) 二叉树节点个数 &#x3D; 左子树节点个数 + 右子树节点个数 + 1 <br>2）求二叉树的深度 <br>    递归解法： <br>        a）如果二叉树为空，二叉树的深度为0 <br>        b）如果二叉树不为空，二叉树的深度 &#x3D; max(左子树深度， 右子树深度) + 1 1. 先根遍历，中序遍历，后序遍历 <br>    依然递归求解 <br>4）广度优先 <br>    借助队列。 <br>5）将二叉查找树变为有序的双向链表 <br>    要求不能创建新节点，只调整指针。 <br>    递归解法： <br>        a）如果二叉树查找树为空，对应双向链表的第一个节点和最后一个节点是NULL <br>        b）如果二叉查找树不为空： <br>        设置参数flag，代表父节点与子节点的关系。如果修正的是左子树与父节点的关系，则递归返回的是序列最后的节点。 <br>6)求二叉树第K层的节点个数 <br>    递归解法： <br>        a）如果二叉树为空或者k&lt;1返回0 <br>        b）如果二叉树不为空并且k&#x3D;&#x3D;1，返回1 <br>        c）如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和 <br>7)求二叉树中叶子节点的个数 <br>    递归解法： <br>        a）如果二叉树为空，返回0 <br>        b）如果二叉树不为空且左右子树为空，返回1 <br>        c）如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数 <br>8)判断二叉树是不是平衡二叉树(AVL树) <br>    递归解法： <br>        a）如果二叉树为空，返回真 <br>        b）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假 <br>9)由前序遍历序列和中序遍历序列重建二叉树 <br>    二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。 <br>    递归解法： <br>        a）如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL; <br>        b）创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树 <br>10)判断是不是完全二叉树<br>11.二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。<br>12.图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。<br>13.KMP算法。<br>14.排列组合问题。<br>15.动态规划、贪心算法、分治算法。（一般不会问到）<br>16.大数据处理：类似10亿条数据找出最大的1000个数………等等<br>17.算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看数据库<br>1.事务四大特性（ACID）原子性、一致性、隔离性、持久性*<br>原子性：是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性: 是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。<br>隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。<br>事务之间的相互影响：脏读，不可重复读，幻读，丢失更新。<br>脏读 意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的<br>不可重复读 意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。<br>  幻读 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.<br>丢失更新 两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。<br>持久性：<br>意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。<br>7.索引有B+索引和hash索引，各自的区别<br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。<br>在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。<br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。<br>8.B+索引数据结构，和B树的区别<br>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。<br>根节点至少有两个子节点<br>每个节点有M-1个key，并且以升序排列<br>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>其它节点至少有M&#x2F;2个子节点<br>B+树是对B树的一种变形树，它与B树的差异在于：<br>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。<br>12.关系型数据库和非关系型数据库区别<br>1.关系型数据库通过外键关联来建立表与表之间的关系，<br>2.非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定<br>15.使用explain优化sql和索引<br>表的读取顺序<br>数据读取操作的操作类型<br>哪些索引可以使用<br>哪些索引被实际使用<br>表之间的引用<br>每张表有多少行被优化器查询<br>说了这么多使用explain的好处,那么实际上到底该怎么玩? 答案： explain + 待执行的sql<br>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化<br>table：显示这一行的数据是关于哪张表的<br>type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL<br>all: full table scan ;MySQL将遍历全表以找到匹配的行；<br>index ： index scan; index 和 all的区别在于index类型只遍历索引；<br>range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，&lt; ,&gt;等查询；<br>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；<br>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；<br>const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。<br>possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句<br>key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引<br>key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数<br>rows：MySQL认为必须检查的用来返回请求数据的行数<br>Extra：关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。<br>16.long_query怎么解决*<br>慢查询日志：默认情况下，MySQL数据库是不开启慢查询日志的，long_query_time的默认值为10（即10秒，通常设置为1秒），即运行10秒以上的语句是慢查询语句。<br>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。<br>slow_query_log 慢查询开启状态。<br>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。<br>long_query_time 查询超过多少秒才记录。<br>17.内连接、外连接、交叉连接、笛卡儿积等<br>内连接(INNER JOIN)：  <br>    分为三种：等值连接、自然连接、不等连接<br>  <br>外连接(OUTER JOIN)：  <br>    分为三种：  <br>    左外连接(LEFT OUTER JOIN或LEFT JOIN)  <br>    右外连接(RIGHT OUTER JOIN或RIGHT JOIN)  <br>    全外连接(FULL OUTER JOIN或FULL JOIN)  交叉连接(CROSS JOIN)：  <br>    没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积<br>笛卡尔积是两个表每一个字段相互匹配，去掉where 或者inner join的等值 得出的结果就是笛卡尔积。笛卡尔积也等同于交叉连接。内连接: 只连接匹配的行。<br>左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行。<br>右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行。<br>全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。<br>交叉连接 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配<br>20.mysql并发情况下怎么解决（通过事务、隔离级别、锁）<br>MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。。。。。<br>需求分析：互联网单位 每天大量数据读取，写入，并发性高。<br>现有解决方式：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。<br>集群方案：解决DB宕机带来的单点DB不能访问问题。<br>读写分离策略：极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。<br>21.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）<br>Undo Log<br>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了UndoLog来实现多版本并发控制(简称：MVCC)。<br>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>之所以能同时保证原子性和持久化，是因为以下特点：<br>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。<br>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。<br>Redo Log<br>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。<br>22.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序<br>Join where limit group by having12.Spring如何解决循环依赖？<br>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。<br>Spring的单例对象的初始化主要分为三步：<br>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>（3）initializeBean：调用spring xml中的init 方法。<br>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。<br>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。<br>13.Spring 如何保证 Controller 并发的安全？*<br>在Controller中使用ThreadLocal变量<br>在spring配置文件Controller中声明 scope&#x3D;”prototype”，每次都创建新的controller<br>在控制器中不使用实例变量7.Netty的高性能表现在哪些方面*<br>异步非阻塞通信<br> Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都 是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。另外，由于Netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。<br>零拷贝<br>  1) Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>       2) Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>       3) Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>内存池<br>   随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty提供了基于内存池的缓冲区重用机制（PooledByteBuf）。<br>高效的Reactor线程模型1. Reactor单线程模型；<br>       2) Reactor多线程模型；<br>       3) 主从Reactor多线程模型<br>无锁化的串行设计理念<br> 在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。<br>       为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。<br>       Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程 操作导致的锁的竞争，从性能角度看是最优的。<br>高效的并发编程<br>Netty的高效并发编程主要体现在如下几点：<br>       1) volatile的大量、正确使用;<br>       2) CAS和原子类的广泛使用；<br>       3) 线程安全容器的使用；<br>       4) 通过读写锁提升并发性能。<br>高性能的序列化框架<br>影响序列化性能的关键因素总结如下：<br>       1) 序列化后的码流大小（网络带宽的占用）；<br>       2) 序列化&amp;反序列化的性能（CPU资源占用）；<br>       3) 是否支持跨语言（异构系统的对接和开发语言切换）。<br>Netty默认提供了对Google Protobuf的支持，通过扩展Netty的编解码接口，用户可以实现其它的高性能序列化框架，例如Thrift的压缩二进制编解码框架。<br>灵活的TCP参数配置能力<br> 合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和SO_SNDBUF。如果设置不当，对性能的影响是非常大的。下面总结下对性能影响比较大的几个配置项：<br>       1) SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；<br>       2) SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；<br>       3) 软中断：如果Linux内核版本支持RPS（2.6.35以上版本），开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个 hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。<br>Netty在启动辅助类中可以灵活的配置TCP参数，满足不同的用户场景。<br>缓存<br>4.Redis的并发竞争问题如何解决<br>1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。  <br>2.服务器角度，利用setnx实现锁。<br>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。<br>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。<br>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。<br>3.Netty是如何使用线程池的，为什么这么使用*<br>EventExecutorGroup 自己实现了Future和submit<br>AbstractEventExecutorGroup，最上层实现的还是Executor接口<br>只不过通过 配置数量，配置线程模型<br>3.HTTP协议<br>http：+地址+端口+url<br>基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），B&#x2F;C架构<br>HTTP request请求：<br>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>GET说明请求类型为GET,[&#x2F;562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息<br>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<br>第三部分：空行，请求头部后面的空行是必须的<br>即使第四部分的请求数据为空，也必须有空行。<br>第四部分：请求数据也叫主体，可以添加任意的其他数据。<br>这个例子的请求数据为空。<br>HTTP之响应消息Response<br>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文<br>4.TCP协议：面向连接的、可靠的、基于字节流的传输层通信协议<br>IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。<br>简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包<br>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。5.一致性Hash算法*<br>一致性hash作为一个负载均衡算法，可以用在分布式缓存、数据库的分库分表等场景中，还可以应用在负载均衡器中作为作为负载均衡算法。在有多台服务器时，对于某个请求资源通过hash算法，映射到某一个台服务器，当增加或减少一台服务器时，可能会改变这些资源对应的hash值，这样可能导致一部分缓存或数据失效了。一致性hash就是尽可能在将同一个资源请求路由到同一台服务器中。<br>一致性哈希采用的做法如下：引入一个环的概念，如上面的第一个图。先将机器映射到这个环上，再将数据也通过相同的哈希函数映射到这个环上，数据存储在它顺时针走向的那台机器上。以环为中介，实现了数据与机器数目之间的解耦。这样，当机器的数目变化时，只会影响到增加或删除的那台机器所在的环的邻接机器的数据存储，而其他机器上的数据不受影响。<br>10.HTTP连接池实现原理<br>1、降低延迟：如果不采用连接池，每次连接发起Http请求的时候都会重新建立TCP连接(经历3次握手)，用完就会关闭连接(4次挥手)，如果采用连接池则减少了这部分时间损耗，别小看这几次握手，本人经过测试发现，基本上3倍的时间延迟<br>2、支持更大的并发：如果不采用连接池，每次连接都会打开一个端口，在大并发的情况下系统的端口资源很快就会被用完，导致无法建立新的连接<br>PoolingHttpClientConnectionManager<br>配置请求超时设置—RequestConfig<br>CloseableHttpClient 获取httpClient对象，post，get封装<br>12.数据库的实现原理分布式<br>1.什么是CAP定理<br>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本），换句话就是说，任何时刻，所用的应用程序都能访问得到相同的数据。<br>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性），换句话就是说，任何时候，任何应用程序都可以读写数据。<br>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，换句话说，系统可以跨网络分区线性的伸缩和扩展。<br>2.CAP 理论和 BASE 理论<br>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。<br>基本可用（Basically Available）<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。<br>软状态（ Soft State）<br>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。<br>最终一致性（ Eventual Consistency）<br>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。<br>3.CAP 理论1. CAP理论<br>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。<br>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。<br>1.1 一致性（Consistency）<br>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。<br>1.2 可用性（Availability）<br>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。<br>1.3 分区容错性（Partition tolerance）<br>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。<br>4.CAP 理论和最终一致性<br>一言以蔽之：过程松，结果紧，最终结果必须保持一致性<br>最终一致性是弱一致性的一种特例。假如A首先write了一个值到存储系统，存储系统保证如果在A,B,C后续读取之前没有其它写操作更新同样的值的话，最终所有的读取操作都会读取到最A写入的最新值。此种情况下，如果没有失败发生的话，“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制技术中replica的个数（这个可以理解为master&#x2F;salve模式中，salve的个数），最终一致性方面最出名的系统可以说是DNS系统，当更新一个域名的IP以后，根据配置策略以及缓存控制策略的不同，最终所有的客户都会看到最新的值<br>5.最终一致性实现方式<br>6.一致性 Hash<br>7.分布式事务，两阶段提交。<br>两阶段提交涉及到多个节点的网络通信,通信时间如果过长,事务的相对时间也就会过长,那么锁定资源的时间也就长了.在高并发的服务中,就会存在严重的性能瓶颈<br>9.如何实现分布式Session*<br>2. 基于数据库的Session共享<br>3. 基于NFS共享文件系统<br>4. 基于memcached 的session，如何保证 memcached 本身的高可用性？<br>5. 基于resin&#x2F;tomcat web容器本身的session复制机制<br>6. 基于TT&#x2F;Redis 或 jbosscache 进行 session 共享。<br>7. 基于cookie 进行session共享<br>10.如何保证消息的一致性*11.负载均衡<br>负载均衡是高可用网络基础架构的的一个关键组成部分，有了负载均衡，我们通常可以将我们的应用服务器部署多台，然后通过负载均衡将用户的请求分发到不同的服务器用来提高网站、应用、数据库或其他服务的性能以及可靠性<br>12.正向代理（客户端代理）和反向代理（服务器端代理）*<br>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>（1）访问原来无法访问的资源，如google<br>    （2）可以做缓存，加速访问资源<br>　　（3）对客户端访问授权，上网进行认证<br>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息<br>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击<br>（2）负载均衡，通过反向代理服务器来优化网站的负载<br>nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。<br>13.CDN实现原理<br>（1）CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br>（2）大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。<br>CDN即内容分发网络，加速的意思，那么网站CND服务是网站加速服务。<br>CDN加速将网站的内容缓存在网络边缘（离用户接入网络最近的地方），然后在用户访问网站内容的时候，通过调度系统将用户的请求路由或者引导到离用户接入网络最近或者访问效果的缓存服务器上，有该缓存服务器为用户提供内容服务；相对于直接访问源站，这种方式缩短了用户和内容之间的网络距离，从而达到加速的效果<br>14.怎么提升系统的QPS和吞吐量*<br>QPS（TPS）：每秒钟request&#x2F;事务 数量<br>并发数：系统同时处理的request&#x2F;事务数<br>响应时间：一般取平均响应时间<br>简单而言通过增加集群来提升qps和吞吐量<br>实际上要比这个要复杂<br>首先我们需要知道系统的瓶颈<br>我们所知道的系统拓扑架构<br>对于rest接口而言<br>系统设施依次是：<br>dns<br>　　nginx<br>　　　　tomcat<br>　　　　　　db&#x2F;soa<br>首先我们可以通过增加集群来增加qps和吞吐量<br>其次考虑到负载均衡的问题，我们可以通过其他设施来保证集群节点的负载均衡，进一步提高系统qps<br>于是就有nginx集群+负载均衡<br>tomcat集群+负载均衡<br>到db&#x2F;soa这一层的时候，同样也可以通过增加集群+负载均衡的方式来解决<br>我们还可以在每一层增加缓存来应对热点数据<br>然而另外一个方面，可以系统拆分，服务拆分，分别针对瓶颈的系统单独增加集群和负载均衡来解决<br>同样db也可以分库分表，<br>因为单表超过1000万条数据时就很慢了，所以这个时候就需要库拆分，于是就有垂直拆分，水平拆分。　　　<br>异步化，可以不同调用的异步化，使用mq，比如发送短信，发送邮件等<br> <br>综上所述：<br>集群+负载均衡<br>增加缓存<br>系统拆分<br>分库分表<br>垂直拆分+水平拆分<br>异步化+MQ<br>16.描述一个服务从发布到被消费的详细过程*<br>创建接口服务<br>配置文件配置服务注册中心，配置接口服务<br>启动后，服务提供者启动时，向注册中心注册自己提供的服务，服务消费者在启动时，向注册中心订阅自己所需的服务<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。<br>17.分布式系统怎么做服务治理服务自动注册<br>客户端自动发现<br>变更下发<br>18.接口的幂等性的概念<br>在数学里，幂等有两种主要的定义：<br>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 即 s <em>s &#x3D; s<br>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) &#x3D; f(x)。<br>HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。如通过PUT接口将数据的Status置为1，无论是第一次执行还是多次执行，获取到的结果应该是相同的，即执行完成之后Status &#x3D;1。<br>orderStatus由0-&gt;1 是需要幂等性的<br>19.消息中间件如何解决消息丢失问题</em><br>消息持久化<br>ACK确认机制<br>设置集群镜像模式<br>1）单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。<br>2）普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。<br>3）镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案<br>消息补偿机制：息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。<br>20.Dubbo的服务请求失败怎么处理<br>因此，将应用拆分，并抽取出核心服务来解决上述问题，还要考虑负载均衡、服务监控、高可用性、服务隔离与降级、路由策略、完善的容错机制、序列化方案的选择、通信框架的选择、开发人员对底层细节无感知、服务升级兼容性等问题。Dubbo满足了以上所有需求。<br>21.重连机制会不会造成错误<br>dubbo在调用服务不成功时，默认会重试2次。<br>Dubbo的路由机制，会把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机制也能一定程度的保证服务的质量。<br>但是如果不合理的配置重试次数，当失败时会进行重试多次，这样在某个时间点出现性能问题，调用方再连续重复调用。<br>系统请求变为正常值的retries倍，系统压力会大增，容易引起服务雪崩，需要根据业务情况规划好如何进行异常处理，何时进行重试。<br>22.对分布式事务的理解<br>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。以上是百度百科的解释，简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。<br>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交，包括上面提到的消息事务+最终一致性、TCC模式，而完全控制就是完全实现两阶段提交。部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。<br>下单—涉及扣库存和更新订单状态。<br>23.如何实现负载均衡，有哪些算法可以实现？<br>既然要解决后端系统的承载能力：nginx的配置<br>均衡算法主要解决将请求如何发送给后端服务<br>随机（random）、轮训（round-robin）、一致哈希（consistent-hash）和主备（master-slave）。<br>24.Zookeeper的用途，选举的原理是什么？<br>分布式系统基本上都是主从结构，所以需要zookeeper进行协调服务，他做很多事情的，比如命名服务，配置管理，集群管理，分布式协调通知等等<br>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。1.服务器初始化时Leader选举<br>zookeeper由于其自身的性质，一般建议选取奇数个节点进行搭建分布式服务器集群。以3个节点组成的服务器集群为例，说明服务器初始化时的选举过程。启动第一台安装zookeeper的节点时，无法单独进行选举，启动第二台时，两节点之间进行通信，开始选举Leader。1）每个Server投出一票。他们两都选自己为Leader，投票的内容为（SID，ZXID）。SID即Server的id，安装zookeeper时配置文件中所配置的myid；ZXID，事务id，为节点的更新程度，ZXID越大，代表Server对Znode的操作越新。由于服务器初始化，每个Sever上的Znode为0，所以Server1投的票为（1,0），Server2为（2,0）。两Server将各自投票发给集群中其他机器。2）每个Server接收来自其他Server的投票。集群中的每个Server先判断投票有效性，如检查是不是本轮的投票，是不是来Looking状态的服务器投的票。3）对投票结果进行处理。先了解下处理规则</p><ul><li>首先对比ZXID。ZXID大的服务器优先作为Leader</li><li>若ZXID相同，比如初始化的时候，每个Server的ZXID都为0，就会比较myid，myid大的选出来做Leader。对于Server而言，他接受到的投票为（2,0），因为自身的票为（1,0），所以此时它会选举Server2为Leader，将自己的更新为（2,0）。而Server2收到的投票为Server1的（1,0）由于比他自己小，Server2的投票不变。Server1和Server2再次将票投出，投出的票都为（2,0）。4） 统计投票。每次投票之后，服务器都会统计投票信息，如果判定某个Server有过半的票数投它，那么该Server将会作为Leader。对于Server1和Server2而言,统计出已经有两台机器接收了（2,0）的投票信息，此时认为选出了Leader。5）改变服务器状态。当确定了Leader之后，每个Server更新自己的状态，Leader将状态更新为Leading，Follower将状态更新为Following。2.服务器运行期间的Leader选举<br>zookeeper运行期间，如果有新的Server加入，或者非Leader的Server宕机，那么Leader将会同步数据到新Server或者寻找其他备用Server替代宕机的Server。若Leader宕机，此时集群暂停对外服务，开始在内部选举新的Leader。假设当前集群中有Server1、Server2、Server3三台服务器，Server2为当前集群的Leader，由于意外情况，Server2宕机了，便开始进入选举状态。过程如下<br>1） 变更状态。其他的非Observer服务器将自己的状态改变为Looking，开始进入Leader选举。<br>2） 每个Server发出一个投票（myid，ZXID），由于此集群已经运行过，所以每个Server上的ZXID可能不同。假设Server1的ZXID为145，Server3的为122，第一轮投票中，Server1和Server3都投自己，票分别为（1，145）、（3,122）,将自己的票发送给集群中所有机器。<br>3） 每个Server接收接收来自其他Server的投票，降下来的步骤与启动时步骤相同。25.数据的垂直拆分水平拆分。<br>垂直拆分，对于表来说，可以按业务模型进行拆分<br>水平拆分，对于表来说，是分多个票取模存放到不同数据库<br>26.zookeeper原理和适用场景*<br>Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储， Zookeeper 作用主要是用来维护和监控存储的数据的状态变化，通过监控这些数据状态的变化，从而达到基于数据的集群管理<br>简单的说，zookeeper&#x3D;文件系统+通知机制。<br>ZooKeeper以Fast Paxos（帕克索斯）算法为基础，让集群中的每个zk实例数据保持一致。一般部署集群，机器数设置为奇数个，更容易满足&gt;N&#x2F;2的投票条件。<br>Zookeeper应用场景<br>统一命名服务<br>       分布式环境下，经常需要对应用&#x2F;服务进行统一命名，便于识别不同服务。类似于域名与ip之间对应关系，域名容易记住。通过名称来获取资源或服务的地址，提供者等信息按照层次结构组织服务&#x2F;应用名称可将服务名称以及地址信息写到Zookeeper上，客户端通过Zookeeper获取可用服务列表类。<br>配置管理<br>       分布式环境下，配置文件管理和同步是一个常见问题。一个集群中，所有节点的配置信息是一致的，比如Hadoop。对配置文件修改后，希望能够快速同步到各个节点上配置管理可交由Zookeeper实现。可将配置信息写入Zookeeper的一个znode上。各个节点监听这个znode。一旦znode中的数据被修改，zookeeper将通知各个节点。<br>集群管理<br>       分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态作出一些调整。Zookeeper可将节点信息写入Zookeeper的一个znode上。监听这个znode可获取它的实时状态变化。典型应用比如Hbase中Master状态监控与选举。<br>分布式通知&#x2F;协调<br>       分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。例如，NameNode须知道各DataNode的状态，JobTracker须知道各TaskTracker的状态。心跳检测机制和信息推送也是可通过Zookeeper实现。<br>分布式锁<br>       Zookeeper是强一致的。多个客户端同时在Zookeeper上创建相同znode，只有一个创建成功。Zookeeper实现锁的独占性。多个客户端同时在Zookeeper上创建相同znode ，创建成功的那个客户端得到锁，其他客户端等待。Zookeeper 控制锁的时序。各个客户端在某个znode下创建临时znode （类型为CreateMode. EPHEMERAL _SEQUENTIAL），这样，该znode可掌握全局访问时序。<br>分布式队列<br>       两种队列。当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。（可通过分布式锁实现）<br>       同步队列。一个job由多个task组成，只有所有任务完成后，job才运行完成。可为job创建一个&#x2F;job目录，然后在该目录下，为每个完成的task创建一个临时znode，一旦临时节点数目达到task总数，则job运行完成。<br>27.zookeeper watch机制<br>监视是一种简单的机制，使客户端收到关于ZooKeeper集合中的更改的通知。客户端可以在读取特定znode时设置Watches。Watches会向注册的客户端发送任何znode（客户端注册表）更改的通知。<br>Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。<br>28.redis&#x2F;zk节点宕机如何处理*<br>解决方法是连接从服务器，做save操作。将会在从服务器的data目录保存一份从服务器最新的dump.rdb文件。将这份dump.rdb文件拷贝到主服务器的data目录下。再重启主服务器。<br>29.分布式集群下如何做到唯一序列号*<br><a target="_blank" rel="noopener" href="http://stor.51cto.com/art/201711/558600.htm">http://stor.51cto.com/art/201711/558600.htm</a><br>1、利用数据库递增，全数据库唯一。<br>优点：明显，可控。<br>缺点：单库单表，数据库压力大。<br>2、UUID， 生成的是length&#x3D;32的16进制格式的字符串，如果回退为byte数组共16个byte元素，即UUID是一个128bit长的数字，一般用16进制表示。<br>优点：对数据库压力减轻了。<br>缺点：但是排序怎么办？<br>此外还有UUID的变种，增加一个时间拼接，但是会造成id非常长。<br>3、twitter在把存储系统从MySQL迁移到Cassandra的过程中由于Cassandra没有顺序ID生成机制，于是自己开发了一套全局唯一ID生成服务：Snowflake。<br>41位的时间序列（精确到毫秒，41位的长度可以使用69年）<br>10位的机器标识（10位的长度最多支持部署1024个节点）<br>12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 最高位是符号位，始终为0。<br>优点：高性能，低延迟；独立的应用；按时间有序。<br>缺点：需要独立的开发和部署。<br>4、Redis生成ID<br>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作INCR和INCRBY来实现。<br>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。<br>30.用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗*<br>可靠消费<br>Redis：没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理<br>RabbitMQ：具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费<br>可靠发布<br>Reids：不提供，需自行实现<br>RabbitMQ：具有发布确认功能，保证消息被发布到服务器<br>高可用<br>Redis：采用主从模式，读写分离，但是故障转移还没有非常完善的官方解决方案<br>RabbitMQ：集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作<br>持久化<br>Redis：将整个Redis实例持久化到磁盘<br>RabbitMQ：队列，消息，都可以选择是否持久化<br>消费者负载均衡<br>Redis：不提供，需自行实现<br>RabbitMQ：根据消费者情况，进行消息的均衡分发<br>队列监控<br>Redis：不提供，需自行实现<br>RabbitMQ：后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）<br>流量控制<br>Redis：不提供，需自行实现<br>RabbitMQ：服务器过载的情况，对生产者速率会进行限制，保证服务可靠性<br>kafka，<br>activemq，<br>RocketMQ<br>31.MQ系统的数据如何保证不丢失<br>32.列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询<br>１、中间变量　＝ user_id%（库数量*每个库的表数量）;<br>２、库序号　＝　取整（中间变量／每个库的表数量）;<br>３、表序号　＝　中间变量％每个库的表数量;<br>Join连表查询，或者多sql查询系统架构<br>1.如何搭建一个高可用系统<br>容灾<br>集群<br>主备<br>熔断<br>限流<br>监控<br>降级<br>日志<br>分库分表<br>读写分离<br>Nginx反向代理<br>CDN加速<br>SSD硬盘持久化<br>自动备份<br>2.哪些设计模式可以增加系统的可扩展性<br>工厂模式<br>抽象工厂模式<br>观察者模式：很方便增加观察者，方便系统扩展<br>模板方法模式：很方便的实现不稳定的扩展点，完成功能的重用<br>适配器模式：可以很方便地对适配其他接口<br>代理模式：可以很方便在原来功能的基础上增加功能或者逻辑<br>责任链模式：可以很方便得增加拦截器&#x2F;过滤器实现对数据的处理，比如struts2的责任链<br>策略模式：通过新增策略从而改变原来的执行策略<br>3.介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。5.什么是高内聚低耦合，请举例子如何实现*<br>同一类功能放一块，如utils包，但是各个模块功能不依赖关联，这就是低耦合<br>接口、继承、多态也是低耦合的实现<br>6.什么情况用接口，什么情况用消息<br>接口的特点是同步调用，接口实时响应，阻塞等待<br>消息的特点是异步处理，非实时响应，消息发送后则返回，消息队列可以削峰<br>一般对实时性要求比较高的功能采用接口<br>对实时性要求不高的功能可以采用消息，削峰时可以采用消息<br>7.如果AB两个系统互相依赖，如何解除依赖*<br>A—&gt;B，同时B—&gt;A<br>解除这种双向依赖的话，需要在AB之外增加一个C，用C封装A依赖的B的那部分功能，让A改为依赖C，C依赖B<br>然后就是这样<br>A—&gt;C，C—-&gt;B，B—&gt;A<br>不过这样依然存在环路依赖<br>8.如何写一篇设计文档，目录是什么<br>基于此我认为主要会分为8个部分。分别为 项目背景，项目目标，需求分析，方案对比，概要设计，详细设计（存储模型设计，接口设计），开发以及上线计划，方案排期。<br>9.什么场景应该拆分系统，什么场景应该合并系统<br>拆分系统：<br>当系统通过集群的方式已经无法解决性能问题的时候，或者业务扩展到很大的时候，需要把拆分系统<br>按照业务的方式垂直拆分：将业务功能结合比较紧密的部分拆分成独立的系统，独立维护<br>按照性能瓶颈点拆分：将系统性能瓶颈点拆分出一个独立的系统，可以针对这个独立的系统集群部署，增加可伸缩性，提高系统整体的性能<br>合并系统：<br>或者系统间通过跨进程访问的性能损耗过高，可以将系统合并成一个系统，减少跨进程访问的消耗<br>10.系统和模块的区别，分别在什么场景下使用<br>系统和模块<br>系统是一个完整功能的系统，拥有独立的访问方式，和部署方式，拥有完整的生命周期，系统由模块组成<br>模块是系统的组成部分，不能单独工作，需要依附于系统才能发挥作用，通常是解决一定场景下的问题<br>系统用于系统性解决问题的方案<br>模块是针对单个问题方面的解决方案<br>11.实战能力<br>12.有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。<br>13.开发中有没有遇到什么技术问题？如何解决的<br>14.如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。<br>15.新浪微博是如何实现把微博推给订阅者<br>16.Google是如何在一秒内把搜索结果返回给用户的。<br>17.12306网站的订票系统如何实现，如何保证不会票不被超卖。<br>18.如何实现一个秒杀系统，保证只有几位用户能买到某件商品。<br>设计这个系统是一个考虑全面的问题，可以发散出很多问题，考察很多方面，不是仅仅回答通过redis的自减操作完成<br>比如简单的方案：<br>1，页面开启倒计时，要保证不能把下单接口暴露过早暴露出来，防止机器刷下单接口<br>2，前端限流，比如nginx对下单接口限流，命中限流则返回302到秒杀页<br>3，后端单独部署，独立域名和nginx，与线上正常运行的系统隔离开来，避免影响到线上环境<br>4，由于生成订单操作比较耗时，采用队列的方式来解耦下单成功和生成订单，针对进入后端的请求，采用redis自减，针对自减结果&gt;0的请求则认为下单成功，触发一个生成订单的消息，然后立即返回给用户结果<br>5，用户方面，针对秒杀成功有两种处理方式<br>　　a，用户端收到秒杀成功的结果，则开启提示页面，并进入倒计时，倒计时时间为订单生成的预估时间<br>　　b，秒杀成功后，给当前用户在redis中生成一个订单生成状态的标识，用户端开启提示页面，loading，并轮询后端订单生成状态，生成成功之后让前端跳转到订单页面<br>6，订单服务订阅下单系统发送的消息，并开始生成订单，生成订单成功之后更新redis中用户秒杀订单的状态为已生成订单</li></ul><p> <br>系统应该有页面和接口<br>页面用于展示用户界面，接口用于获取数据<br>界面：秒杀页面，秒杀成功页面，秒杀失败页面，命中限流页面（查看订单页面不算秒杀系统的功能）<br>接口：秒杀下单接口，秒杀成功获取订单生成状态接口TCP&#x2F;IP<br>1.OSI与TCP&#x2F;IP各层的结构与功能，都有哪些协议。*<br>OSI模型—应用层，表示层，回话层，传输层，网络层，数据链路层，物理层<br>1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 <br>2.数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 <br>3.网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 <br>4.传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 <br>5.会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） <br>6.表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 <br>7.应用层： 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。2.TCP与UDP的区别。*<br>TCP(Transmission Control Protocol)：传输控制协议<br>UDP(User Datagram Protocol)：用户数据报协议<br>TCP是面向连接的、可靠的、有序的、速度慢的协议；<br>UDP是无连接的、不可靠的、无序的、速度快的协议。<br>TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。<br>TCP无界有拥塞控制，UDP有界无拥塞控制。3.TCP报文结构。<br>1、端口号：用来标识同一台计算机的不同的应用进程。<br>1）源端口：源端口和IP地址的作用是标识报文的返回地址。<br>2）目的端口：端口指明接收方计算机上的应用程序接口。<br>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。<br>2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。<br>3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32&#x2F;8 &#x3D; 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。<br>4、保留：为将来定义新的用途保留，现在一般置0。<br>5、控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。<br>1）URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。<br>2）ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。<br>3）PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。<br>4）RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。<br>5）SYN：同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。<br>6）FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。<br>6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。<br>7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。<br>8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。<br>9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。<br>10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。<br>4.TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。<br>5.TCP拥塞控制。<br>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或者链路不会导致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制<br>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。<br>（1）在通信子网出现过多数据包的情况，使得网络的性能下降，甚至不能正常工作，这种现象就称为拥塞。<br>（2）网络拥塞的成因主要有三：1、处理器的速度太慢。2、线路容量的限制。3、节点输出包的能力小于输入包的能力。<br>（3）拥塞控制与流量控制是相关的，流量控制在数据链路层对一条通信路径上的流量进行控制，其的是保证发送者的发送速度不超过接收者的接收速度，它只涉及一全发送者和一个接收者，是局部控制。拥塞控制是对整个通信子网的流量进行控制，其目的是保证通信子网中的流量与其资源相匹配，使子网不会出现性能下降和恶化、甚至崩溃，是全局控制。<br>（4）拥塞控制的最终目标是：1、防止由于过载而使吞吐量下降，损失效率；2、合理分配网络资源；3、避免死锁；4、匹配传输速度。<br>（5）对拥塞控制，可用的方法有两类：开环控制和闭环控制。<br>1、开环控制的思想是通过良好的设计避免拥塞问题的出现，确保拥塞问题在开始时就不可能发生。开环控制方法包括何时接受新的通信何时丢弃包、丢弃哪些包。其特点是在作出决定时不考虑网络当前的状态。<br>2、闭环控制的思想是反馈控制。即通过将网络工作的动态信息反馈给网络中节点的有关进程，节点根据网络当前的动态信息，调整转发数据包的策略。闭环控制过程包括三部分： ①监视系统  检测网络发生或将要发生拥塞的时间和地点。②报告  将监视中检测到的信息传送到可以进行拥塞控制的节点。③决策  调整系统的操作行为，以解决问题。<br>（6）对应于开环控制的方法有：（基于拥塞预防）<br>1、预定缓冲区 2、合理分配缓冲区 3、通信量整形法（A、许可证算法，B、漏桶算法，C、令牌漏桶算法。）<br>对应于闭环控制的方法有：（基于拥塞抑制，即拥塞出现或即将出现时采取适当的措施进行控制，直到消除拥塞）<br>1、阻塞包法。 2、负载丢弃法<br>6.TCP滑动窗口与回退N针协议。<br>7.Http的报文结构。<br>（1）HTTP请求报文<br>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。（2）HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。<br>8.Http的状态码含义。<br>1xx: 信息<br>消息：	描述：<br>100 Continue	服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。<br>101 Switching Protocols	服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。<br>103 Checkpoint	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>2xx: 成功<br>消息：	描述：<br>200 OK	请求成功（这是对HTTP请求成功的标准应答。）<br>201 Created	请求被创建完成，同时新的资源被创建。<br>202 Accepted	供处理的请求已被接受，但是处理未完成。<br>203 Non-Authoritative Information	请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。<br>204 No Content	请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br>205 Reset Content	请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。<br>206 Partial Content	客户发送了一个带有Range头的GET请求，服务器完成了它。<br>3xx: 重定向<br>消息：	描述：<br>300 Multiple Choices	多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。<br>301 Moved Permanently	所请求的页面已经转移至新的 URL 。<br>302 Found	所请求的页面已经临时转移至新的 URL 。<br>303 See Other	所请求的页面可在别的 URL 下被找到。<br>304 Not Modified	未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br>305 Use Proxy	客户请求的文档应该通过Location头所指明的代理服务器提取。<br>306 Switch Proxy	目前已不再使用，但是代码依然被保留。<br>307 Temporary Redirect	被请求的页面已经临时移至新的 URL 。<br>308 Resume Incomplete	用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。<br>4xx: 客户端错误<br>消息：	描述：<br>400 Bad Request	因为语法错误，服务器未能理解请求。<br>401 Unauthorized	合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。<br>402 Payment Required	此代码尚无法使用。<br>403 Forbidden	合法请求，但对被请求页面的访问被禁止。<br>404 Not Found	服务器无法找到被请求的页面。<br>405 Method Not Allowed	请求中指定的方法不被允许。<br>406 Not Acceptable	服务器生成的响应无法被客户端所接受。<br>407 Proxy Authentication Required	用户必须首先使用代理服务器进行验证，这样请求才会被处理。<br>408 Request Timeout	请求超出了服务器的等待时间。<br>409 Conflict	由于冲突，请求无法被完成。<br>410 Gone	被请求的页面不可用。<br>411 Length Required	“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。<br>412 Precondition Failed	请求中的前提条件被服务器评估为失败。<br>413 Request Entity Too Large	由于所请求的实体太大，服务器不会接受请求。<br>414 Request-URI Too Long	由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。<br>415 Unsupported Media Type	由于媒介类型不被支持，服务器不会接受请求。<br>416 Requested Range Not Satisfiable	客户端请求部分文档，但是服务器不能提供被请求的部分。<br>417 Expectation Failed	服务器不能满足客户在请求中指定的请求头。<br>5xx: 服务器错误<br>消息：	描述：<br>500 Internal Server Error	请求未完成。服务器遇到不可预知的情况。<br>501 Not Implemented	请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。<br>502 Bad Gateway	请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。<br>503 Service Unavailable	服务器当前不可用（过载或者当机）。<br>504 Gateway Timeout	网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。<br>505 HTTP Version Not Supported	服务器不支持请求中指明的HTTP协议版本。<br>511 Network Authentication Required	用户需要提供身份验证来获取网络访问入口。9.Http?request的几种类型。*<br>1.  OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’<em>‘的请求来测试服务器的功能性。<br>2.  HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>3.  GET：向特定的资源发出请求。<br>4.  POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>5.  PUT：向指定资源位置上传其最新内容。<br>6.  DELETE：请求服务器删除Request-URI所标识的资源。<br>7.  TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>8.  CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>10.Http1.1和Http1.0的区别</em><br>长连接<br>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。<br>HTTP是基于TCP&#x2F;IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。<br>节约带宽<br>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。<br>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。<br>HOST域<br>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。<br>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。<br>11.Http怎么处理长连接。*<br>在HTTP1.0和HTTP1.1协议中都有对长连接的支持。其中HTTP1.0需要在request中增加Connection： keep-alive header才能够支持，而HTTP1.1默认支持。<br>http1.0请求与服务端的交互过程:<br>（1）客户端发出带有包含一个header：”Connection： keep-alive“的请求<br>（2）服务端接收到这个请求后,根据http1.0和”Connection： keep-alive“判断出这是一个长连接,就会在response的header中也增加”Connection： keep-alive“，同时不会关闭已建立的tcp连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>http1.1请求与服务端的交互过程:<br>（1）客户端发出http1.1的请求<br>（2）服务端收到http1.1后就认为这是一个长连接,会在返回的response设置Connection： keep-alive,同时不会关闭已建立的连接.<br>（3）客户端收到服务端的response后,发现其中包含”Connection： keep-alive“，就认为是一个长连接，不关闭这个连接。并用该连接再发送request.转到（1）<br>基于http协议的长连接减少了请求,减少了建立连接的时间,但是每次交互都是由客户端发起的,客户端发送消息,服务端才能返回客户端消息。<br>12.Cookie与Session的作用于原理。<br>1.1 Cookie机制<br>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。<br>而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。<br>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。<br>1.2 Session机制<br>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。<br>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。<br>Java Web规范支持通过配置的方式禁用Cookie。下面举例说一下怎样通过配置禁止使用Cookie，可以使用重定向url。 <br>cookie数据保存在客户端，session数据保存在服务器端 <br>第一次请求服务器，生成session和sessionID，sessionID用cookie保存 <br>第二次请求服务器，携带seesionID，服务器从请求中取出sessionID<br>13.电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。<br>应用层：<br>连接：当我们输入一个url请求时，首先要建立socket连接，因为socket是通过ip和端口建立的，所有有一个DNS解析的过程，首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。现在已经拥有了目标ip和端口号，这样我们就可以打开socket连接了。<br>请求：连接成功建立后，开始向web服务器发送请求，这个请求一般是GET或POST命令（POST用于FORM参数的传递）。GET命令的格式为：　　GET 路径&#x2F;文件名 HTTP&#x2F;1.0<br>文件名指出所访问的文件，HTTP&#x2F;1.0指出Web浏览器使用的HTTP版本。现在可以发送GET命令：<br>GET &#x2F;mytest&#x2F;index.html HTTP&#x2F;1.0，<br>应用层：<br>1. DNS（53）：<br>我们输入的是一个URL需要转化成IP地址。首先我们知道我们本地的机器上在配置网络时都会填写DNS，这样本机就会把这个url发给这个配置的DNS服务器，如果能够找到相应的url则返回其ip，否则该DNS将继续将该解析请求发送给上级DNS，整个DNS可以看做是一个树状结构，该请求将一直发送到根直到得到结果。1. HTTP（80）<br>HTTP协议的主要职责是生成针对目标web服务器的http请求报文（请求行、请求头部）<br>传输层<br>2. TCP<br>将http请求报文分割成报文段，按序号分为多个报文段。（三次握手）<br>网络层<br>3. IP<br>搜索目标的地址，一边中转一边传送。（路由）<br>4. ARP<br>因为最终都要在数据链路层上进行传输，而数据链路层并不认识IP地址，所以ARP的职责就是把IP地址转换成数据链路层认识的MAC地址。<br>通过数据链路层到达目标机器之后<br>网络层<br>5. RARP<br>这其实是ARP的逆过程，将MAC地址转换成Ip地址<br>传输层<br>6. TCP<br>将接收到的报文段按序号进行重组。<br>应用层<br>7. HTTP<br>14.Ping的整个过程。ICMP报文是什么。<br>ICMP（网际控制报文协议）：用来测试网络层是不是有故障，若有故障，该协议还能报告故障。Ping命令来使用这个协议<br>15.C&#x2F;S模式下使用socket通信，几个关键函数。*<br>client ： socket（ip，端口）<br>socket.close();<br>server：serversocket（端口）<br>socket &#x3D; server.accept()<br>16.IP地址分类。<br>IP地址分类（A类 B类 C类 D类 E类）<br>     IP地址由四段组成，每个字段是一个字节，8位，最大值是255，,<br>     IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。<br>  IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。<br>     IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。    全0和全1的都保留不用。<br>     A类：（1.0.0.0-126.0.0.0）（默认子网掩码：255.0.0.0或 0xFF000000）<br>     第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1<del>126之间。<br>     一般用于大型网络。<br>     B类：（128.1.0.0-191.255.0.0）（默认子网掩码：255.255.0.0或0xFFFF0000）<br>     前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128</del>191之间。<br>     一般用于中等规模网络。<br>     C类：（192.0.1.0-223.255.255.0）（子网掩码：255.255.255.0或 0xFFFFFF00）<br>     前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192<del>223之间。<br>     一般用于小型网络。<br>    D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224</del>239之间。一般用于多路广播用户[1]  。<br>    E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。<br>  回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。 <br>       一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP&#x2F;IP是否正常。<br>17.路由器与交换机区别。<br>一、工作所在的OSI层次不一样（根本区别，导致接下来的区别） <br>交换机工作在 OSI模型的数据链路层，所以工作原理比较简单； <br>路由器工作在OSI模型的网络层，具备更多的网络协议信息，所以可以做出更好的数据转发策略。<br>二、数据转发所依据的对象也不一样。 <br>交换机工作在数据链路层，所以交换机转发数据依靠的是每个物理地址（MAC地址），MAC地址一般是设备生产商在设备出厂时固定在设备中的，不能进行更改。 <br>路由器工作在网络层，所以其交换数据依靠网络地址（IP地址），而IP地址是由网络管理员自己分配或者系统自动获取的。<br>三、是否可以分割广播域 <br>由交换机连接的所有端口仍然属于同一个广播域，所以极有可能会产生数据拥堵； <br>连接到路由器上的所有端口不在属于同一个广播域，所以不会产生类似的数据拥堵问题。<br>18.网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。<br>19.推荐书籍：《TCP&#x2F;IP协议族》1．JDK,JRE,JVM(掌握)<br>(1)JVM<br>保证Java语言跨平台。针对不同的操心系统提供不同的JVM。<br>问题：java语言是跨平台的吗?JVM是跨平台的吗?<br>(2)JRE<br>java程序的运行环境。包括JVM和核心类库<br>(3)JDK<br>java开发环境。包括JRE和开发工具(javac,java)<br>(4)一个Java程序的开发流程<br>A:编写Java源程序<br>B:通过javac命令编译java程序，生成字节码文件<br>C:通过java命令运行字节码文件<br>2．主从数据库切换<br>一般使用多个dataSource，然后创建多个SessionFactory，入侵明显，修改多，session处理比较麻烦。<br>合适的方案使用AbstractRoutingDataSource实现类通过AOP或者手动处理实现动态使用我们的数据源，入侵低。determineTargetDataSource –<br>determineCurrentLookupKey<br>Why：如果主库故障，可以切换从库<br>Why：针对与mysql，怎么保证主从同步，怎么通知代码切换1. Bean获取它所在的Spring容器，可以让该Bean实现ApplicationContextAware接口，Bean获取它所在的Spring容器，可以通过这个上下文环境对象得到Spring容器中的Bean。<br>Why：针对于非web项目的spring2. ehcache:<br>String：字符串常量 每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉，<br>　　　StringBuffer：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>　　　StringBuilder：字符串变量 是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的<br>String 字符串常量 线程安全 操作少量数据<br>StringBuffer 字符串变量 线程安全 操作大量数据 速度慢 多线程适合用<br>StringBuilder 字符串变量 线程不安全 操作大量数据 速度快 单线程适合用<br>String str &#x3D; new String(“xyz”);创建了几个对象。<br>如果String常量池中，已经创建了”xyz”,则不会继续创建，此时只创建了一个对象new String(“xyz”);<br>如果String常量池中没有创建”xyz”,则会创建两个对象，一个对象的值是”xyz”,一个对象是new String(“xyz”);<br>6．关系型数据库和非关系型数据库种类和关系<br>数据库<br>类型	特性	优点	缺点<br>关系型数据库<br>SQLite、Oracle、mysql	1、关系型数据库，是指采用了关系模型来组织<br>数据的数据库；<br>2、关系型数据库的最大特点就是事务的一致性；<br>3、简单来说，关系模型指的就是二维表格模型，<br>而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。	1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。	1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、高并发读写需求；<br>4、海量数据的高效率读写；<br>非关系型数据库<br>MongoDb、redis、HBase	1、使用键值对存储数据；<br>2、分布式；<br>3、一般不支持ACID特性；<br>4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。	1、无需经过sql层的解析，读写性能很高；<br>2、基于键值对，数据没有耦合性，容易扩展；<br>3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。	1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理，附加功能bi和报表等支持也不好；4. Vector ,ArrayList 和LinkedList的区别？<br> 1、Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。<br> 2、Vector线程同步，ArrayList、LinkedList线程不同步。<br> 3、LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。<br> 4、ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省。8.注解<br>登陆、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit 提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。9.反射<br>反射就是把java类中的各种成分映射成一个个的Java对象<br>可以获取类的相关信息，可以进行设置，可以代理<br>spring 的 ioc&#x2F;di 也是反射….<br>javaBean和jsp之间调用也是反射….<br>struts的 FormBean 和页面之间…也是通过反射调用….<br>JDBC 的 classForName()也是反射…..<br>hibernate的 find(Class clazz) 也是反射….<br>10.加载器11.ajax<br>运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换；2. statement<br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>3. 数据库基础查询<br>1、 加载JDBC驱动程序： <br>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机）， <br>这通过java.lang.Class类的静态方法forName(String className)实现。 <br>例如：<br>try{<br>&#x2F;&#x2F;加载MySql的驱动类<br>Class.forName(“com.mysql.jdbc.Driver”) ;<br>}catch(ClassNotFoundException e){<br>System.out.println(“找不到驱动程序类 ，加载驱动失败！”);<br>e.printStackTrace() ;<br>}<br>成功加载后，会将Driver类的实例注册到DriverManager类中。<br>2、 提供JDBC连接的URL * 连接URL定义了连接数据库时的协议、子协议、数据源标识。 </p><ul><li>书写形式：协议：子协议：数据源标识<br>协议：在JDBC中总是以jdbc开始 子协议：是桥连接的驱动程序或是数据库管理系统名称。 <br>数据源标识：标记找到数据库来源的地址与连接端口。 <br>例如： <br>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;gbk;useUnicode&#x3D;true;（MySql的连接URL） <br>表示使用Unicode字符集。如果characterEncoding设置为 gb2312或GBK，本参数必须设置为true 。characterEncoding&#x3D;gbk：字符编码方式。<br>3、创建数据库的连接 </li><li>要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。 </li><li>使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。<br>例如： &#x2F;&#x2F;连接MySql数据库，用户名和密码都是root<br>String url &#x3D; “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test” ;<br>String username &#x3D; “root” ;<br>String password &#x3D; “root” ;<br>try{<br>Connection con &#x3D; DriverManager.getConnection(url , username , password ) ;<br>}catch(SQLException se){<br>System.out.println(“数据库连接失败！”);<br>se.printStackTrace() ;<br>}<br>4、 创建一个Statement <br>•要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型： <br>1、执行静态SQL语句。通常通过Statement实例实现。 <br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。 <br>3、执行数据库存储过程。通常通过CallableStatement实例实现。 <br>具体的实现方式： <br>Statement stmt &#x3D; con.createStatement() ; PreparedStatement pstmt &#x3D; con.prepareStatement(sql) ; CallableStatement cstmt &#x3D; con.prepareCall(“{CALL demoSp(? , ?)}”) ; <br>5、执行SQL语句 <br>Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate 和execute <br>1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句 ，返回一个结果集（ResultSet）对象。 <br>2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等 <br>3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的 语句。 具体实现的代码： <br>ResultSet rs &#x3D; stmt.executeQuery(“SELECT * FROM …”) ; int rows &#x3D; stmt.executeUpdate(“INSERT INTO …”) ; boolean flag &#x3D; stmt.execute(String sql) ; <br>6、处理结果 <br>两种情况： <br>1、执行更新返回的是本次操作影响到的记录数。 <br>2、执行查询返回的结果是一个ResultSet对象。 <br>• ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些 行中数据的访问。 <br>• 使用结果集（ResultSet）对象的访问方法获取数据： <br>while(rs.next()){ <br>String name &#x3D; rs.getString(“name”) ; <br>String pass &#x3D; rs.getString(1) ; &#x2F;&#x2F; 此方法比较高效 <br>} <br>（列是从左到右编号的，并且从列1开始）<br>7、关闭JDBC对象 <br>操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声 明顺序相反： <br>1、关闭记录集 <br>2、关闭声明 <br>3、关闭连接对象</li></ul><p>17.使用Spring框架的好处是什么？<br>  轻量：Spring 是轻量的，基本的版本大约2MB。<br>  控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>  面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>  容器：Spring 包含并管理应用中对象的生命周期和配置。<br>  MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br>  事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br>  异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。1. ~8等于多少？8&gt;&gt;&gt;2等于多少？<br>第一个答案是-9，第二个答案是2，无符号右移高位补0	。2. 子类能否重写父类的静态方法<br>不能，类对象，从属于对应的类。3. 什么是线程？<br>  线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。4. 线程和进程有什么区别？<br>  线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。5. 如何在Java中实现线程？<br>  两种方式：java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。6. Java 关键字volatile 与 synchronized 作用与区别？<br>1，volatile<br>    它所修饰的变量不保留拷贝，直接访问主内存中的。<br>2，synchronized<br>    当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。24.不同的线程生命周期？<br>  当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。<br>        1. 程优先级的理解是什么？<br>  每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。26.是死锁(Deadlock)？如何分析和避免死锁？<br>  死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。<br>  分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。<br>  避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。27.么是线程安全？Vector是一个线程安全类吗？ <br>所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。28.Java中如何停止一个线程？<br>  Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程29.什么是ThreadLocal?<br>  ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。<br>  每个线程都会拥有他们自己的Thread变量，它们可以使用get()\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。30.Sleep()、suspend()和wait()之间有什么区别？<br>  Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。<br>  注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。<br>  object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()&#x2F;notify()与sleep()&#x2F;interrupt()类似，只是前者需要获取对象锁。31.什么是线程饿死，什么是活锁？<br>  当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI中线程活锁可能发生在以下情形：<br>  1，当所有线程在程序中执行Object.wait(0)，参数为0的wait方法。程序将发生活锁直到在相应的对象上有线程调用Object.notify()或者Object.notifyAll()。<br>  2，当所有线程卡在无限循环中。32.什么是Java Timer类？如何创建一个有特定时间间隔的任务？<br>  java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br>  java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。<br>33.Java中的同步集合与并发集合有什么区别？<br>  同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。<br>  在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。<br>  Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。34.同步方法和同步块，哪个是更好的选择？<br>  同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。35.么是线程池？ 为什么要使用它？<br>  创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。<br>  为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。<br>  从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。36．java中invokeAndWait 和 invokeLater有什么区别？<br>  这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。1. 多线程中的忙循环是什么?<br>  忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存。<br>  在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。2. Array不可以用泛型？<br>是的，list的可以，推荐用list，List可以提供编译期的类型安全保证，而Array却不能。<br>int num&#x3D;Integer.valueOf(“12”);<br>int num2&#x3D;Integer.parseInt(“12”);<br>double num3&#x3D;Double.valueOf(“12.2”);<br>double num4&#x3D;Double.parseDouble(“12.2”);<br>&#x2F;&#x2F;其他的类似。通过基本数据类型的包装来的valueOf和parseXX来实现String转为XX<br>String a&#x3D;String.valueOf(“1234”);&#x2F;&#x2F;这里括号中几乎可以是任何类型<br>String b&#x3D;String.valueOf(true);<br>String c&#x3D;new Integer(12).toString();&#x2F;&#x2F;通过包装类的toString()也可以<br>String d&#x3D;new Double(2.3).toString();3. AJAX有哪些有点和缺点？<br>优点：<br>  1、最大的一点是页面无刷新，用户的体验非常好。<br>  2、使用异步方式与服务器通信，具有更加迅速的响应能力。<br>  3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。<br>   4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。<br>缺点：<br>   1、ajax不支持浏览器back按钮。<br>   2、安全问题 AJAX暴露了与服务器交互的细节。<br>   3、对搜索引擎的支持比较弱。<br>   4、破坏了程序的异常机制。<br>   5、不容易调试。40.集合解析<br>List 和 Set 区别<br>List,Set都是继承自Collection接口<br>List特点：元素有放入顺序，元素可重复<br>Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉<br>（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）<br>Set和List对比：<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。<br>ArrayList 与 Vector 区别<br>public ArrayList(int initialCapacity)&#x2F;&#x2F;构造一个具有指定初始容量的空列表。<br>public ArrayList()&#x2F;&#x2F;构造一个初始容量为10的空列表。<br>public ArrayList(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 的元素的列表<br>Vector有四个构造方法：<br>public Vector()&#x2F;&#x2F;使用指定的初始容量和等于零的容量增量构造一个空向量。<br>public Vector(int initialCapacity)&#x2F;&#x2F;构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。<br>public Vector(Collection&lt;? extends E&gt; c)&#x2F;&#x2F;构造一个包含指定 collection 中的元素的向量<br>public Vector(int initialCapacity,int capacityIncrement)&#x2F;&#x2F;使用指定的初始容量和容量增量构造一个空的向量<br>ArrayList和Vector都是用数组实现的，主要有这么三个区别：<br>Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；<br>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。<br>Vector可以设置增长因子，而ArrayList不可以。<br>Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。<br>适用场景分析：<br>Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。<br>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。<br>HashSet 和 HashMap 区别<br>set是线性结构，set中的值不能重复，hashset是set的hash实现，hashset中值不能重复是用hashmap的key来实现的。<br>map是键值对映射，可以空键空值。HashMap是Map接口的hash实现，key的唯一性是通过key值hash值的唯一来确定，value值是则是链表结构。<br>他们的共同点都是hash算法实现的唯一性，他们都不能持有基本类型，只能持有对象<br>HashMap 和 ConcurrentHashMap 的区别<br>ConcurrentHashMap是线程安全的HashMap的实现。<br>（1）ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。<br>（2）HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br>ConcurrentHashMap 的工作原理及代码实现<br>HashTable里使用的是synchronized关键字，这其实是对对象加锁，锁住的都是对象整体，当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。<br>ConcurrentHashMap算是对上述问题的优化，其构造函数如下，默认传入的是16，0.75，16。<br>ConcurrentHashMap引入了分割(Segment)，上面代码中的最后一行其实就可以理解为把一个大的Map拆分成N个小的HashTable，在put方法中，会根据hash(paramK.hashCode())来决定具体存放进哪个Segment，如果查看Segment的put操作，我们会发现内部使用的同步机制是基于lock操作的，这样就可以对Map的一部分（Segment）进行上锁，这样影响的只是将要放入同一个Segment的元素的put操作，保证同步的时候，锁住的不是整个Map（HashTable就是这么做的），相对于HashTable提高了多线程环境下的性能，因此HashTable已经被淘汰了。41.线程解析</p><ol><li>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore<br>CountDownLatch用法<br>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。<br>CyclicBarrier用法<br>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。<br>Semaphore用法<br>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。下面对上面说的三个辅助类进行一个总结：<br>　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。<br>　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。<br>说说 CountDownLatch 与 CyclicBarrier 区别<br>CountDownLatch	CyclicBarrier<br>减计数方式	加计数方式<br>计算为0时释放所有等待的线程	计数达到指定值时释放所有等待线程<br>计数为0时，无法重置	计数达到指定值时，计数置为0重新开始<br>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响	调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞<br>不可重复利用	可重复利用java.util.concurrent.Exchanger应用范例与原理浅析<br>此类提供对外的操作是同步的；<br>用于成对出现的线程之间交换数据；<br>可以视作双向的同步队列；<br>可应用于基因算法、流水线设计等场景。<br>ThreadLocal 原理分析<br>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。<br>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。<br>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。<br>讲讲线程池的实现原理<br>线程池的几种方式<br>newFixedThreadPool(int nThreads) <br>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程<br>newCachedThreadPool() <br>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制<br>newSingleThreadExecutor() <br>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行<br>newScheduledThreadPool(int corePoolSize) <br>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br>线程的生命周期<br>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态<br>(1)生命周期的五种状态<br>新建（new Thread） <br>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。 <br>例如：Thread t1&#x3D;new Thread();<br>就绪（runnable） <br>线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();<br>运行（running） <br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。<br>死亡（dead） <br>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。<br>自然终止：正常运行run()方法后终止<br>异常终止：调用stop()方法让一个线程终止运行<br>堵塞（blocked） <br>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。<br>正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用motify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）1. 锁机制<br>说说线程安全问题<br>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。 <br>在Java里，线程安全一般体现在两个方面： <br>1、多个thread对同一个java实例的访问（read和modify）不会相互干扰，它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronized关键字）。如果你在interator一个List对象时，其它线程remove一个element，问题就出现了。 <br>2、每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。<br>Volatile<br>在多线程并发编程中synchronized和Volatile都扮演着重要的角色，Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。悲观锁 乐观锁<br>乐观锁 悲观锁 <br>是一种思想。可以用在很多方面。<br>比如数据库方面。 <br>悲观锁就是for update（锁定查询的行） <br>乐观锁就是 version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）<br>JDK方面： <br>悲观锁就是sync <br>乐观锁就是原子类（内部使用CAS实现）<br>本质来说，就是悲观锁认为总会有人抢我的。 <br>乐观锁就认为，基本没人抢。<br>乐观锁（Optimistic Lock）： <br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。<br>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。数据存储分析<br>mysql索引使用技巧及注意事项<br> INSERT 与 UPDATE 语句在拥有索引的表中执行会花费更多的时间，而SELECT 语句却会执行得更快。这是因为，在进行插入或更新时，数据库也需要插入或更新索引值。<br>索引的类型：<br>UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值<br>INDEX(普通索引)：允许出现相同的索引内容<br>PROMARY KEY(主键索引)：不允许出现相同的值<br>fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维<br>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一<br>(1)使用ALTER TABLE语句创建索性<br>ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）<br>(2)使用CREATE INDEX语句对表增加索引<br>CREATE INDEX index_name ON table_name(username(length));<br>&#x2F;&#x2F;create只能添加这两种索引;<br>CREATE INDEX index_name ON table_name (column_list)<br>CREATE UNIQUE INDEX index_name ON table_name (column_list)<br>(3)删除索引<br>删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下：<br>drop index index_name on table_name ;alter table table_name drop index index_name ;alter table table_name drop primary key ;<br>(4) 组合索引与前缀索引<br>create table USER_DEMO<br>(<br>ID int not null auto_increment comment ‘主键’,<br>LOGIN_NAME varchar(100) not null comment ‘登录名’,<br>PASSWORD varchar(100) not null comment ‘密码’,<br>CITY varchar(30) not null comment ‘城市’,<br>AGE int not null comment ‘年龄’,<br>SEX int not null comment ‘性别(0:女 1：男)’,<br>primary key (ID)<br>);<br>ALTER TABLE USER_DEMO ADD INDEX name_city_age (LOGIN_NAME(16),CITY,AGE);索引的使用及注意事项<br>Explain select * from user where id&#x3D;1;<br>    1.索引不会包含有NULL的列<br>       只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。<br>    2.使用短索引<br>       对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。<br>    3.索引列排序<br>       mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。<br>    4.like语句操作<br>      一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。<br>    5.不要在列上进行运算<br>    6.不使用NOT IN 、&lt;&gt;、！&#x3D;操作，但&lt;,&lt;&#x3D;，&#x3D;，&gt;,&gt;&#x3D;,BETWEEN,IN是可以用到索引的<br>    7.索引要建立在经常进行select操作的字段上。<br>       这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。<br>    8.索引要建立在值比较唯一的字段上。<br>    9.对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。<br>    10.在where和join中出现的列需要建立索引。<br>    11.where的查询条件里有不等号(where column !&#x3D; …),mysql将无法使用索引。<br>    12.如果where字句的查询条件里使用了函数(如：where DAY(column)&#x3D;…),mysql将无法使用索引。<br>    13.在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。<br>分表与分库使用场景以及设计方式<br>对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表！场景：分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master<br>服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。<br>因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!<br>MySQL有三种锁的级别：页级、表级、行级。<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br>存储引擎的 InnoDB 与 MyISAM<br>1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。<br>2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用<br>3）InnoDB支持外键，MyISAM不支持<br>4）从MySQL5.5.5以后，InnoDB是默认引擎<br>5）InnoDB不支持FULLTEXT类型的索引<br>6）InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表<br>7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引<br>8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表<br>9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’<br>索引数据结构设相关的计算机原理<br>上文说过，二叉树、红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-&#x2F;+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-&#x2F;+Tree作为索引的理论基础。<br>当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，你需增加order by，并且order by字段需要建立索引。<br>   如果使用子查询去优化LIMIT的话，则子查询必须是连续的，某种意义来讲，子查询不应该有where条件，where会过滤数据，使数据失去连续性。<br>   如果你查询的记录比较大，并且数据传输量比较大，比如包含了text类型的field，则可以通过建立子查询。<br>分布式系统唯一ID生成方案汇总<br>关系型数据库 MySQL<br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。<br>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>文档数据库 MongoDB<br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。<br>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。<br>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。<br>列族数据库 HBase<br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。<br>全文搜索引擎 ElasticSearch<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。<br>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。<br>MongoDB 特性	优势<br>事务支持	MongoDB 目前只支持单文档事务，需要复杂事务支持的场景暂时不适合<br>灵活的文档模型	JSON 格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代<br>高可用复制集	满足数据高可靠、服务高可用的需求，运维简单，故障自动切换<br>可扩展分片集群	海量数据存储，服务能力水平扩展<br>高性能	mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足各种场景需求<br>强大的索引支持	地理位置索引可用于构建 各种 O2O 应用、文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求<br>Gridfs	解决文件存储的需求<br>aggregation &amp; mapreduce	解决数据分析场景需求，用户可以自己写查询语句或脚本，将请求都分发到 MongoDB 上完成<br>从目前阿里云 MongoDB 云数据库上的用户看，MongoDB 的应用已经渗透到各个领域，比如游戏、物流、电商、内容管理、社交、物联网、视频直播等，以下是几个实际的应用案例。<br>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新<br>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。<br>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能<br>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析<br>视频直播，使用 MongoDB 存储用户信息、礼物信息等redis内部数据结构深入浅出<br>redis 是 key-value 存储系统，其中 key 类型一般为字符串，而 value 类型则为 redis 对象（redis object），可以绑定各种类型的数据，譬如 string、list 和set，redis.h 中定义了 struct redisObject，它是一个简单优秀的数据结构Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。<br>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。<br>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。<br>Redis 如何实现持久化1. snapshotting(快照)<br>也是默认方式.(把数据做一个备份，将数据存储到文件)<br>快照是默认的持久化方式，这种方式是将内存中数据以快照的方式写到二进制文件中，默认的文件名称为dump.rdb.可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key键修改就自动做快照.<br> 2. Append-onlyfile(缩写aof)的方式        <br>aof方式:由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。aof比快照方式有更好的持久化性，是由于在使用aof时，redis会将每一个收到的写命令都通过write函数追加到文件中，当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。      <br>当然由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。可以通过配置文件告诉redis我们想要通过fsync函数强制os写入到磁盘的时机。<br>Redis 为什么是单线程的<br>要知道Redis的数据结构并不全是简单的Key-Value，还有列表，hash，map等等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，等等。这些操作还可以合成MULTI&#x2F;EXEC的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。这还带来一个恶果就是吞吐量虽然增大，但是响应延迟可能会增加。 <br>Redis在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用Lua脚本这样的功能。对于多线程来说这需要高得多的代价。44.使用传统的 Socket 开发挺简单的，我为什么要切换到 NIO 进行编程呢？<br>1.线程模型存在致命缺陷：一连接一线程的模型导致服务端无法承受大量客户端的并发连接；<br>2.性能差：频繁的线程上下文切换导致 CPU 利用效率不高；<br>3.可靠性差：由于所有的 IO 操作都是同步的，所以业务线程只要进行 IO 操作，也会存在被同步阻塞的风险，这会导致系统的可靠性差，依赖外部组件的处理能力和网络的情况。<br>4.采用非阻塞 IO（NIO）之后，同步阻塞 IO 的三个缺陷都将迎刃而解：<br>5.Nio 采用 Reactor 模式，一个 Reactor 线程聚合一个多路复用器 Selector，它可以同时注册、监听和轮询成百上千个 Channel，一个 IO 线程可以同时并发处理N个客户端连接，线程模型优化为1：N（N &lt; 进程可用的最大句柄数）或者 M : N (M通常为 CPU 核数 + 1， N &lt; 进程可用的最大句柄数)；<br>6.由于 IO 线程总数有限，不会存在频繁的 IO 线程之间上下文切换和竞争，CPU 利用率高；<br>7.所有的 IO 操作都是异步的，即使业务线程直接进行 IO 操作，也不会被同步阻塞，系统不再依赖外部的网络环境和外部应用程序的处理性能。由于切换到 NIO 编程之后可以为系统带来巨大的可靠性、性能提升，所以，目前采用 NIO 进行通信已经逐渐成为主流。# 什么是WebSockets？WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信信道。WebSocket是双向的 -使用WebSocket客户端或服务器可以发起消息发送。<br>WebSocket是全双工的 -客户端和服务器通信是相互独立的。<br>单个TCP连接 -初始连接使用HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信<br>Light -与http相比，WebSocket消息数据交换要轻得多。# 什么是CSRF攻击CSRF代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web应用程序上执行不需要的操作。CSRF攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。NOWCODER.COM<br>Java 面试题库<br>牛客网出品<br>NOWCODER.COM<br>Java 工程师校招面试题库导读<br>一、学习说明<br>本题库均来自海量真实校招面试题目大数据进行的整理，后续也会不断更新，可免费在线观<br>看，如需下载，也可在页面<br>载需要用牛币兑换，一次兑换可享受永久下载权限，因为后续会更新）<br>需要严肃说明的是：面试题库作为帮助同学准备面试的辅助资料，但是绝对不能作为备考唯<br>一途径，因为面试是一个考察真实水平的，不是背会了答案就可以的，需要你透彻理解的，<br>否则追问问题答不出来反而减分，毕竟技术面试中面试官最痛恨的就是背答案这个事情了。<br>学完这个题库，把此题库都理解透彻应对各家企业面试完全没有问题。（当然，要加上好的<br>项目以及透彻掌握）<br>另外，此面试题库中不包括面试中问到的项目，hr 面以及个人技术发展类。<br> 项目是比较个性化的，没办法作为一个题库来给大家参考，但是如果你有一个非常有含<br>金量的项目的话，是非常加分的，而且你的项目可能也会被问的多一些；<br> hr 面的话一般来说技术面通过的话个人没有太大的和公司不符合的问题都能通过；<br> 技术发展类的话这个就完全看自己啦，主要考察的会是你对技术的热爱和学习能力，比<br>如会问一些你是如何学习 xxx 技术的，或者能表达出你对技术的热爱的地方等等。此处<br>不做赘述。<br>那么抛开这些，Java 工程师中技术面中考察的占比如下：<br>需要注意的是：此图不绝对，因为实际面试中面试官会根据你的简历去问，比如你的项目多<br>NOWCODER.COM<br>可能就问的项目多一些，或者你说哪里精通可能面试官就多去问你这些。而且此图是根据题<br>库数据整理出来，并不是根据实际单场面试整理，比如基础部分不会考那么多，会从中抽着<br>考<br>但是面试中必考的点且占比非常大的有 Java 基础和算法。<br>决定你是否能拿 sp offer（高薪 offer）以及是否进名企的是项目和算法。<br>可以看出，算法除了是面试必过门槛以外，更是决定你是否能进名企或高薪 offer 的决定性<br>因素。<br>另外关于算法部分，想要系统的学习算法思想，实现高频面试题最优解等详细讲解的话可以<br>报名算法名企校招冲刺班或算法高薪校招冲刺班，你将能学到更先进的算法思想以及又一套<br>系统的校招高频题目的解题套路和方法论。<br>多出来的服务如下：<br>NOWCODER.COM<br>如果有什么问题，也可以加 qq 咨询 1440073724，如果是早鸟的话，还可以领取早鸟优惠哦<br>二、面试技巧<br>面试一般分为技术面和 hr 面，形式的话很少有群面，少部分企业可能会有一个交叉面，不<br>过总的来说，技术面基本就是考察你的专业技术水平的，hr 面的话主要是看这个人的综合<br>素质以及家庭情况符不符合公司要求，一般来讲，技术的话只要通过了技术面 hr 面基本上<br>是没有问题（也有少数企业 hr 面会刷很多人）<br>那我们主要来说技术面，技术面的话主要是考察专业技术知识和水平，我们是可以有一定的<br>技巧的，但是一定是基于有一定的能力水平的。<br>所以也慎重的告诉大家，技巧不是投机取巧，是起到辅助效果的，技术面最主要的还是要有<br>实力，这里是基于实力水平之上的技巧。<br>这里告诉大家面试中的几个技巧：<br>1、简历上做一个引导：<br>在词汇上做好区分，比如熟悉 Java，了解 python，精通 c 语言<br>这样的话对自己的掌握程度有个区分，也好让面试官有个着重去问，python 本来写的也只<br>是了解，自然就不会多问你深入的一些东西了。<br>2、在面试过程中做一个引导：<br>面试过程中尽量引导到自己熟知的一个领域，比如问到你说一下 DNS 寻址，然后你简单回<br>答（甚至这步也可以省略）之后，可以说一句，自己对这块可能不是特别熟悉，对计算机网<br>络中的运输层比较熟悉，如果有具体的，甚至可以再加一句，比如 TCP 和 UDP<br>这样的话你可以把整个面试过程往你熟知的地方引导，也能更倾向于体现出你的优势而不是<br>劣势，但是此方法仅限于掌握合适的度，比如有的知识点是必会的而你想往别处引就有点说<br>不过去了，比如让你说几个 Java 的关键字，你一个也说不上来，那可能就真的没辙了。<br>3、在自我介绍中做一个引导：<br>一般面试的开头都会有一个自我介绍，在这个位置你也可以尽情的为自己的优势方面去引导。<br>4、面试过程中展示出自信：<br>面试过程中的态度也要掌握好，不要自卑，也不要傲娇，自信的回答出每个问题，尤其遇到<br>不会的问题，要么做一些引导，实在不能引导也可以先打打擦边球，和面试官交流一下问题，<br>看起来像是没听懂题意，这个过程也可以再自己思考一下，如果觉得这个过程可以免了的话<br>也直接表明一下这个地方不太熟悉或者还没有掌握好，千万不要强行回答。<br>面试前的准备：<br>NOWCODER.COM<br>最重要的肯定是系统的学习了，有一个知识的框架，基础知识的牢靠程度等。<br>其中算法尤其重要，越来越多公司还会让你现场或者视频面试中手写代码；<br>另一大重要的和加分项就是项目，在面试前，一定要练习回答自己项目的三个问题：<br> 这是一个怎样的项目<br> 用到了什么技术，为什么用这项技术（以及每项技术很细的点以及扩展）<br> 过程中遇到了什么问题，怎么解决的。<br>那么话说回来，这个的前提是你要有一个好的项目，牛客网 CEO 叶向宇有带大家做项目，<br>感兴趣的可以去了解一下<br> 竞争力超过 70%求职者的项目：<br>（专属优惠码：DjPgy3x，每期限量前 100 个）<br> 竞争力超过 80%求职者的项目：<br>（专属优惠码：DMVSexJ，每期限量前 100 个）<br>知识都掌握好后，剩下的就是一个心态和模拟练习啦，因为你面试的少的话现场难免紧张，<br>而且没在那个环境下可能永远不知道自己回答的怎么样。<br>因为哪怕当你都会了的情况下，你的表达和心态就显得更重要了，会了但是没有表达的很清<br>晰就很吃亏了，牛客网这边有 AI 模拟面试，完全模拟了真实面试环境，正好大家可以真正<br>的去练习一下，还能收获一份面试报告：<br>面试后需要做的：<br>面试完了的话就不用太在意结果了，有限的时间就应该做事半功倍的事情，当然，要保持电<br>话邮箱畅通，不然别给你发 offer 你都不知道。<br>抛开这些，我们需要做的是及时将面试中的问题记录下来，尤其是自己回答的不够好的问题，<br>一定要花时间去研究，并解决这些问题，下次面试再遇到相同的问题就能很好的解决，当然，<br>即使不遇到，你这个习惯坚持住，后面也可以作为一个经历去跟面试官说，能表现出你对技<br>术的喜爱和钻研的一个态度，同时，每次面试后你会发现自己的不足，查缺补漏的好机会，<br>及时调整，在不断的调整和查缺补漏的过程中，你会越来越好。 三、面试考点导图<br>NOWCODER.COM<br>NOWCODER.COM<br>四、一对一答疑讲解戳这里<br>如果你对校招求职或者职业发展很困惑，欢迎与牛客网专业老师沟通，老师会帮你一对一讲<br>解答疑哦（可以扫下方二维码或者添加微信号：niukewang985）<br>NOWCODER.COM<br>目录<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>②关键字<br>③面向对象<br>④集合部分<br>2、Java 高级知识<br>①线程<br>②锁<br>③JDK<br>④反射<br>⑤JVM<br>⑥GC<br>⑦ IO 和 NIO，AIO<br>二、JavaEE 部分<br>1、Spring<br>①IoC 与 Bean 配置、管理<br>②AOP 与事务、权限控制<br>③S2SH 整合开发<br>④Spring，JPA 整合<br>2、Hibernate<br>①ORM 与持久化映射<br>②延迟加载、性能优化<br>③HQL 查询、条件查询、SQL 查询<br>④二级缓存与查询缓存<br>3、Struts<br>①MVC 模式与 Struts 体系<br>4、mybatis<br>5、MVC 框架<br>6、各框架对比与项目优化<br>7、JPA<br>①EJB<br>三、Java web 开发核心内容<br>1、web 编程基础<br>①Tomcat 服务器<br>NOWCODER.COM<br>②JSP 语法，EL，内置对象<br>③Listener 和 filter<br>2、Web 编程进阶<br>①Servlet、标签的作用<br>②redis<br>③MVC 和 DAO<br>④JSTL、DisplayTag 等常见标签库的用法<br>3、Web 编程原理<br>① HTTP 协议<br>②请求&#x2F;相应架构原理<br>③web 容器<br>四、JDBC 编程<br>1、SQL 基础<br>2、JDBC 基础<br>①数据库<br>②数据库连接池<br>③事物管理，批处理<br>3、JDBC 进阶<br>五、XML 编程<br>1、XML 基础<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>六、计算机网络<br>1、网络概述<br>①关于分层<br>2、运输层<br>①TCP 与 UDP<br>②协议<br>3、网络层<br>①网际协议 IP<br>②网际控制报文协议 ICMP<br>③因特网的路由器选择协议<br>4、应用层<br>①域名系统 DNS<br>②电子邮件<br>NOWCODER.COM<br>七、操作系统<br>1、操作系统概论<br>2、进程的描述与控制<br>3、输入输出系统<br>4、存储器管理<br>5、处理机调度与死锁<br>八、算法与数据结构<br>1、哈希<br>2、树<br>3、遍历<br>4、链表<br>5、数组<br>6、排序<br>7、堆与栈<br>8、队列<br>9、高级算法<br>九、设计模式<br>1、结构型模式<br>①代理模式<br>②装饰模式<br>③适配器模式<br>2、创建型模式<br>①单例模式<br>3、行为型模式<br>①策略模式<br>②观察者模式<br>4、所有模式汇总<br>十、场景题<br>十一、UML<br>更多名企历年笔试真题可点击直接进行练习：<br>NOWCODER.COM<br>一、JavaSE 部分<br>1、Java 基础<br>①Java 基础部分（基本语法，Java 特性等）<br>1、为什么重写 equals 还要重写 hashcode？<br>考点：java 基础<br>参考回答：<br>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()<br>方法继承于 Object 类，其 hashcode 码为默认的内存地址，这样即便有相同含义的两个对象，比<br>较也是不相等的。HashMap 中的比较 key 是这样的，先求出 key 的 hashcode(),比较其值是否相<br>等，若相等再比较 equals(),若相等则认为他们是相等的。若 equals()不相等则认为他们不相等。<br>如果只重写 hashcode()不重写 equals()方法，当比较 equals()时只是看他们是否为同一对象（即<br>进行内存地址的比较）,所以必定要两个方法一起重写。HashMap 用来判断 key 是否相等的方法，<br>其实是调用了 HashSet 判断加入元素 是否相等。重载 hashCode()是为了对同一个 key，能得到<br>相同的 Hash Code，这样 HashMap 就可以定位到我们指定的 key 上。重载 equals()是为了向<br>HashMap 表明当前对象和 key 上所保存的对象是相等的，这样我们才真正地获得了这个 key 所对<br>应的这个键值对。<br>2、说一下 map 的分类和常见的情况<br>考点：java 基础<br>参考回答：<br>java 为数据结构中的映射定义了一个接口 java.util.Map;它有四个实现类,分别是 HashMap<br>Hashtable LinkedHashMap 和 TreeMap.<br>Map 主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重<br>复。<br>Hashmap 是一个最常用的 Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的<br>值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap 最多只允许一条<br>记录的键为 Null;允许多条记录的值为 Null;HashMap 不支持线程的同步，即任一时刻可以有多<br>个线程同时写 HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections 的<br>synchronizedMap 方法使 HashMap 具有同步的能力，或者使用 ConcurrentHashMap。<br>Hashtable 与 HashMap 类似,它继承自 Dictionary 类，不同的是:它不允许记录的键或者值<br>为空;它支持线程的同步，即任一时刻只有一个线程能写 Hashtable,因此也导致了 Hashtable<br>在写入时会比较慢。<br>NOWCODER.COM<br>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排<br>序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，<br>遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和<br>容量无关，而 HashMap 的遍历速度和他的容量有关。<br>TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>一般情况下，我们用的最多的是 HashMap,在 Map 中插入、删除和定位元素，HashMap 是最<br>好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。如果需要输出的<br>顺序和输入的相同,那么用 LinkedHashMap 可以实现,它还可以按读取顺序来排列.<br>HashMap 是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的<br>值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。<br>HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的<br>不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的<br>能力。<br>Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，<br>即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。<br>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的<br>记录肯定是先插入的。<br>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，<br>也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？<br>考点：基础<br>参考回答：<br>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回<br>对象的 内存地址。<br>4、&#x3D;&#x3D;比较的是什么？<br>考点：基础<br>参考回答：<br>“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，<br>“&#x3D;&#x3D;”操作将返回 true，否则返回 false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。<br>NOWCODER.COM<br>5、若对一个类不重写，它的 equals()方法是如何比较的？<br>考点：基础<br>参考回答：<br>比较是对象的地址。<br>6、java8 新特性<br>考察点：java8<br>参考回答：<br>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。<br>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）<br>的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。<br>新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。<br>Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到<br>Java 中。<br>Date Time API − 加强对日期与时间的处理。<br>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许<br>我们在 JVM 上运行特定的 javascript 应用。<br>7、说说 Lamda 表达式的优缺点。<br>考察点：Java 基础<br>参考回答：<br>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。<br>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时<br>需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码<br>不容易让其他语言的程序员看懂。<br>8、一个十进制的数在内存中是怎么存的？<br>考察点：计算机基础<br>NOWCODER.COM<br>参考回答：<br>补码的形式。<br>9、为啥有时会出现 4.0-3.6&#x3D;0.40000001 这种现象？<br>考察点：计算机基础<br>参考回答：<br>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小<br>数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。<br>10、Java 支持的数据类型有哪些？什么是自动拆装箱？<br>考察点：JAVA 数据类型<br>参考回答：<br>Java 语言支持的 8 种基本数据类型是：<br>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：<br>把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。<br>11、什么是值传递和引用传递？<br>考察点：JAVA 引用传递<br>参考回答：<br>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量. 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。<br>所以对引用对象进行操作会同时改变原对象. 一般认为,java 内的传递都是值传递. 12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不<br>是 ArrayList？<br>考察点：Array<br>NOWCODER.COM<br>参考回答：<br>Array 和 ArrayList 的不同点：<br>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。<br>Array 大小是固定的，ArrayList 的大小是动态变化的。<br>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类<br>型的时候，这种方式相对比较慢。<br>13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？<br>考察点：JAVA notation<br>参考回答：<br>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下<br>有多么好。<br>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般<br>使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一<br>个很好的说明。<br>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。<br>其函数表示是：<br>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;&#x3D;c*g(n),则 f(n)&#x3D;O(g(n));<br>大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。<br>大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使<br>用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好<br>的说明。<br>14、String 是最基本的数据类型吗?<br>考察点：数据类型<br>参考回答：<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效<br>率节省空间，我们应该用 StringBuffer 类。<br>15、int 和 Integer 有什么区别<br>考察点：数据类型<br>NOWCODER.COM<br>参考回答：<br>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据<br>类型，Integer 是 java 为 int 提供的封装类。<br>Java 为每个原始类型提供了封装类。<br>原始类型封装类<br>booleanBoolean<br>charCharacter<br>byteByte<br>shortShort<br>intInteger<br>longLong<br>floatFloat<br>doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同<br>的特征和用法，它们包括：大小和速<br>度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时<br>所指定的缺省值。对象引用实例变量<br>的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。<br>16、String 和 StringBuffer 的区别<br>考察点：数据类型<br>参考回答：<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多<br>个字符的字符数据。这个 String 类提供了<br>数值不可改变的字符串。而这个 StringBuffer 类提供的字符串进行修改。当你知道字符数据要<br>改变的时候你就可以使用 StringBuffer 。典型地，你可以使用 StringBuffers 来动态构造字符数据。<br>17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1<br>等，如何输出一个某种编码的字符串？<br>考察点：数据类型<br>参考回答：<br>Public String translate (String str) {<br>String tempStr &#x3D; “”;<br>try {<br>tempStr &#x3D; new String(str.getBytes(“ISO-8859-1″), “GBK”);<br>tempStr &#x3D; tempStr.trim();<br>}<br>catch (Exception e) {<br>NOWCODER.COM<br>System.err.println(e.getMessage());<br>}<br>return tempStr;<br>}<br>18、int 和 Integer 有什么区别？<br>考察点：数据类型<br>参考回答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，<br>但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的<br>包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱<br>机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：* 原始类型: boolean，char，byte，short，int，long，float，double</li></ol><ul><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<br>如：<br>class AutoUnboxingTest {<br>public static void main(String[] args) {<br>Integer a &#x3D; new Integer(3);<br>Integer b &#x3D; 3; &#x2F;&#x2F; 将 3 自动装箱成 Integer 类型<br>int c &#x3D; 3;<br>System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false 两个引用没有引用同一对象<br>System.out.println(a &#x3D;&#x3D; c); &#x2F;&#x2F; true a 自动拆箱成 int 类型再和 c 比较<br>}<br>}<br>19、&amp;和&amp;&amp;的区别？<br>考察点：运算符<br>参考回答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的<br>差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是<br>NOWCODER.COM<br>true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直<br>接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定<br>用户名不是 null 而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，<br>二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的<br>equals 比较，否则会产生 NullPointerException 异常。<br>20、在 Java 中，如何跳出当前的多重嵌套循环？<br>考察点：循环<br>参考回答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标<br>签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时<br>候甚至有相反的作用，所以这种语法其实不知道更好）<br>21、你能比较一下 Java 和 JavaSciprt 吗？<br>考察：Java&amp;JavaScript<br>参考回答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司<br>推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape<br>公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对<br>象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：</li><li>基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设<br>计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软<br>件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身<br>提供了非常丰富的内部对象供设计人员使用。</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，<br>其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技<br>术来提升 JavaScript 的运行效率）</li><li>强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；<br>JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行<br>时检查推断其数据类型。</li><li>代码格式不一样。<br>22、简述正则表达式及其用途。<br>考察点：正则表达式<br>参考回答：<br>NOWCODER.COM<br>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式<br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的<br>信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大<br>的工具，绝大多数语言都提供了对正则表达式的支持。<br>23、Java 中是如何支持正则表达式操作的？<br>考察点：正则表达式<br>参考回答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、<br>replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰<br>富的 API 进行各种正则表达式操作，如：<br>import java.util.regex.Matcher;<br>import java.util.regex.Pattern;<br>class RegExpTest {<br>public static void main(String[] args) {<br>String str &#x3D; “成都市(成华区)(武侯区)(高新区)”;<br>Pattern p &#x3D; Pattern.compile(“.*?(?&#x3D;\()”);<br>Matcher m &#x3D; p.matcher(str);<br>if(m.find()) {<br>System.out.println(m.group());<br>}<br>}<br>}<br>24、请你说说 Java 和 PHP 的区别？<br>考察点：Java 特性<br>参考回答：<br>PHP 暂时还不支持像 Java 那样 JIT 运行时编译热点代码,但是 PHP 具有 opcache 机制,能够<br>把脚本对应的 opcode 缓存在内存,PHP7 中还支持配置 opcache.file_cache 导出 opcode 到文件. 第三方的 Facebook HHVM 也支持 JIT.另外 PHP 官方基于 LLVM 围绕 opcache 机制构建的 Zend JIT<br>分支也正在开发测试中.在 php-src&#x2F;Zend&#x2F;bench.php 测试显示,PHP JIT 分支速度是 PHP 5.4 的<br>10 倍.<br>PHP 的库函数用 C 实现,而 Java 核心运行时类库(jdk&#x2F;jre&#x2F;lib&#x2F;rt.jar,大于 60MB)用 Java 编写<br>(jdk&#x2F;src.zip), 所以 Java 应用运行的时候,用户编写的代码以及引用的类库和框架都要在 JVM<br>上解释执行. Java 的 HotSpot 机制,直到有方法被执行 10000 次才会触发 JIT 编译, 在此之前运<br>行在解释模式下,以避免出现 JIT 编译花费的时间比方法解释执行消耗的时间还要多的情况.<br>PHP 内置模板引擎,自身就是模板语言.而 Java Web 需要使用 JSP 容器如 Tomcat 或第三方模<br>板引擎.<br>NOWCODER.COM<br>PHP 也可以运行在多线程模式下,比如 Apache 的 event MPM 和 Facebook 的 HHVM 都是多线程<br>架构.不管是多进程还是多线程的 PHP Web 运行模式,都不需要 PHP 开发者关心和控制,也就是说<br>PHP 开发者不需要写代码参与进程和线程的管理,这些都由 PHP-FPM&#x2F;HHVM&#x2F;Apache 实现.PHP-FPM<br>进程管理和并发实现并不需要 PHP 开发者关心,而 Java 多线程编程需要 Java 开发者编码参<br>与.PHP 一个 worker 进程崩溃,master 进程会自动新建一个新的 worker 进程,并不会导致 PHP 服<br>务崩溃.而 Java 多线程编程稍有不慎(比如没有捕获异常)就会导致 JVM 崩溃退出.对于 PHP-FPM<br>和 Apache MOD_PHP 来说,服务进程常驻内存,但一次请求释放一次资源,这种内存释放非常彻底.<br>PHP 基于引用计数的 GC 甚至都还没发挥作用程序就已经结束了。 ②关键字<br>1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什<br>么？如果修饰成员方法，锁住了什么？<br>考点：java 关键字<br>参考回答：<br>synchronized 修饰静态方法以及同步代码块的 synchronized (类.class)用法锁的是类，线<br>程想要执行对应同步代码，需要获得类锁。<br>synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。<br>2、介绍一下 volatile？<br>考察点：java 关键字<br>参考回答：<br>volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。比如我们所写的<br>代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，<br>这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高 CPU 的执行效<br>率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有<br>happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面<br>对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先 Java 内存模<br>型分为，主内存，工作内存。比如线程 A 从主内存把变量从主内存读到了自己的工作内存中，做<br>了加 1 的操作，但是此时没有将 i 的最新值刷新会主内存中，线程 B 此时读到的还是 i 的旧值。<br>加了 volatile 关键字的代码生成的汇编代码发现，会多出一个 lock 前缀指令。Lock 指令对 Intel<br>平台的 CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多<br>核之间数据不一致性问题。<br>3、锁有了解嘛，说一下 Synchronized 和 lock<br>考察点：java 关键字<br>NOWCODER.COM<br>参考回答：<br>synchronized 是 Java 的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证<br>在同一时刻最多只有一个线程执行该段代码。JDK1.5 以后引入了自旋锁、锁粗化、轻量级锁，<br>偏向锁来有优化关键字的性能。<br>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；<br>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock<br>在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock<br>时需要在 finally 块中释放锁；Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，<br>使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没<br>有成功获取锁，而 synchronized 却无法办到。<br>4、讲一讲 Java 里面的 final 关键字怎么用的？<br>考察点：关键字<br>参考回答：<br>当用 final 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他<br>被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注<br>意 final 类中的所有成员方法都会被隐式地指定为 final 方法。<br>“使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；<br>第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法<br>过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final<br>方法进行这些优化了。“<br>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；<br>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 ③面向对象<br>1、wait 方法底层原理<br>考察点：基础<br>参考回答：<br>ObjectSynchronizer::wait 方法通过 object 的对象中找到 ObjectMonitor 对象调用方法<br>void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)<br>通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队<br>列的末尾中然后在 ObjectMonitor::exit 释放锁，接着 thread_ParkEvent-&gt;park 也就是 wait。<br>NOWCODER.COM<br>2、Java 有哪些特性，举个多态的例子。<br>考察点：语言特性<br>参考回答：<br>封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据<br>发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）<br>3、String 为啥不可变？<br>考察点：面向对象<br>参考回答：<br>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不<br>能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对<br>象，引用类型指向的对象的状态也不能改变。<br>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字<br>节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以<br>在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串<br>是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得<br>数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不<br>可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安<br>全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，<br>这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的<br>所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计<br>算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是<br>HashMap 中的键往往都使用字符串的原因。<br>4、类和对象的区别<br>考察点：面向对象<br>参考回答：<br>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。<br>比如：“人”是一个类，而“教师”则是“人”的一个实例。<br>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性<br>的对象集合体。<br>5、请列举你所知道的 Object 类的方法。<br>考察点：面向对象<br>NOWCODER.COM<br>参考回答：<br>Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指<br>示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引<br>用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回<br>该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此<br>对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等<br>待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导<br>致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超<br>过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此<br>对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某<br>个实际时间量。<br>6、重载和重写的区别？相同参数不同返回值能重载吗？<br>考察点：重载<br>参考回答：<br>重载(Overloading)<br>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，<br>具有不同的参数个数&#x2F;类型。<br>重载 Overloading 是一个类中多态性的一种表现。<br>（2） Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同<br>的参数和不同的定义。<br>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是<br>多态性。<br>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可<br>以不相同。无法以返回型别作为重载函数的区分标准。<br>重写（Overriding）<br>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与<br>其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类<br>中的方法，而不需要重新编写相同的方法。<br>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的<br>重写。<br>方法重写又称方法覆盖。<br>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法<br>将覆盖原有的方法。<br>如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。<br>NOWCODER.COM<br>（3）子类函数的访问修饰权限不能少于父类的。<br>7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private<br>或者是 static 的方法？<br>考察点：static 变量<br>参考回答：<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情<br>况下被访问。<br>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编<br>译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。<br>8、String 能继承吗？<br>考察点：String<br>参考回答：<br>不能，char 数组用 final 修饰的。<br>9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？<br>考察点：类<br>参考回答：<br>StringBuffer 线程安全，StringBuilder 线程不安全，底层实现上的话，StringBuffer 其<br>实就是比 StringBuilder 多了 Synchronized 修饰符。<br>10、类加载机制，双亲委派模型，好处是什么？<br>考察点：类<br>参考回答：<br>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，<br>如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才<br>自己去加载。<br>使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次<br>关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最<br>终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各<br>种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的<br>话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现<br>NOWCODER.COM<br>多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的<br>Java 类，可以正常编译，但是永远无法被加载运行。<br>11、静态变量存在哪?<br>考察点：类<br>参考回答：<br>方法区<br>12、讲讲什么是泛型？<br>考察点：JAVA 泛型<br>参考回答：<br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法<br>时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，<br>类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;<br>调用时传入具体的类型（类型实参）。</li></ul><p>采用泛型写法后，在&#x2F;&#x2F;1 处想加入一个 Integer 类型的对象时会出现编译错误，通过<br>List&lt;String&gt;，直接限定了 list 集合中只能含有 String 类型的元素，从而在&#x2F;&#x2F;2 处无须进行强<br>制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是 String 类型<br>了。<br>13、解释 extends 和 super 泛型限定符-上界不存下界不取<br>考察点：JAVA 泛型<br>参考回答：<br>（1）泛型中上界和下界的定义<br>上界 &lt;? extend Fruit&gt;<br>下界 &lt;? super Apple&gt;<br>（2）上界和下界的特点<br>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）<br>下界的 list 只能 add，不能 get<br>（3）示例代码</p><p>（4）上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确<br>定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，<br>不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把<br>所有的子类向上转型为 Fruit。<br>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。<br>那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父<br>类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple<br>及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接<br>着呢，除了 Object，其他的都接不住。<br>NOWCODER.COM<br>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。<br>具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引<br>用就必须得用 cast。<br>14、是否可以在 static 环境中访问非 static 变量？<br>考察点：static 变量<br>参考回答：<br>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机<br>载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，<br>编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。<br>15、谈谈如何通过反射创建对象？<br>考察点：类<br>参考回答：</p><ul><li>方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()</li><li>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器<br>（Constructor）对象并调用其 newInstance()方法创建对象，例如：<br>String.class.getConstructor(String.class).newInstance(“Hello”);<br>16、Java 支持多继承么？<br>考察点：JAVA 多继承<br>参考回答：<br>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口<br>支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子<br>接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。<br>18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。<br>考察点：comparable 接口<br>参考回答：<br>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象<br>排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两<br>个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()<br>方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也<br>是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回<br>true。</li></ul><p>23、Static Nested Class 和 Inner Class 的不同<br>考察点：声明<br>参考回答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被<br>实例化。而通常的内部类需要在外部类实<br>例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义<br>为动态的(instance).Nested Class 的静态成员(Method)只能对 Outer Class 的静态成员(static<br>memebr)进行操作(ACCESS), 而不能 Access Outer Class 的动态成员(instance member).而<br>Nested Class 的动态成员(instance method) 却可以 Access Outer Class 的所有成员, 这个概<br>念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而 动<br>态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)<br>永远不可以 Access 跟 object 相关的动态成员(instance member),反过来就可以, 一个 CLASS<br>的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). 24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，<br>并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>考察点：对象<br>参考回答：<br>是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中<br>时，参数的值就是对该对象的引用。对象<br>的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。<br>25、Java 的接口和 C++的虚类的相同和不同处。<br>考察点：接口<br>参考回答：<br>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或<br>属性，现有的单继承机制就不能满足要求。<br>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，<br>该类要实现接口里面所有的方法和属<br>NOWCODER.COM<br>性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public. 一个类可以实现多个接口。<br>26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally<br>分别代表什么意义？在 try 块中可以抛出异常吗？<br>考察点：异常<br>参考回答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接<br>口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出<br>现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个<br>异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws<br>和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个<br>异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br>用 try 来指定一块预防所有”异常”的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指<br>定你想要捕捉的”异常”的类型。throw 语句用来明确地抛出一个”异常”。throws 用来标明一<br>个成员函数可能抛出的各种”异常”。Finally 为确保一段代码不管发生什么”异常”都被执行<br>一段代码。可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try<br>语句保护其他代码。每当遇到一个 try 语句，”异常“的框架就放到堆栈上面，直到所有的 try<br>语句都完成。如果下一级的 try 语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有<br>处理这种”异常”的 try 语句。<br>27、内部类可以引用他包含类的成员吗？有没有什么限制？<br>考察点：类<br>参考回答：<br>一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是 static 的，那么它<br>可以访问创建它的外部类对象的所有属性内部类如果是 sattic 的，即为 nested class，那么它<br>只可以访问创建它的外部类对象的所有 static 属性一般普通类只有 public 或 package 的访问修<br>饰，而内部类可以实现 static，protected，private 等访问修饰。当从外部类继承的时候，内<br>部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明<br>确地继承，就可以覆盖原来内部类的方法。<br>28、两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的 hash code 说法<br>是否正确？<br>考察点：对象<br>参考回答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当<br>相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals<br>方法返回 true），那么它们的 hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它<br>NOWCODER.COM<br>们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容<br>器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存<br>储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。<br>30、如何通过反射获取和设置对象私有字段的值？<br>考察点：类<br>参考回答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段对象的<br>setAccessible(true)将其设置为可以访问，接下来就可以通过 get&#x2F;set 方法来获取&#x2F;设置字段的<br>值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段<br>的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如<br>ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得 dog 对象的主人的汽车的引擎的<br>ID 号。31、谈一下面向对象的”六原则一法则”。<br>考察点：Java 对象<br>参考回答：<br>NOWCODER.COM</p><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写<br>代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功<br>能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内<br>聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到<br>变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶<br>皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到<br>其他系统中使用的，这样才能实现软件复用的目标。）- 开闭原则：软件实体应当对扩展开放，<br>对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系<br>统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是<br>关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可<br>变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不<br>清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- 依赖倒<br>转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类<br>型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一<br>个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换<br>掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简<br>单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，<br>如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。<br>例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容<br>易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的<br>能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示<br>能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分<br>别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方<br>法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会<br>几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、<br>代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- 合成聚合复用<br>原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用<br>得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之<br>间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其<br>中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A<br>关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可<br>以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例<br>子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错<br>误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置<br>为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。<br>记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- 迪<br>米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂<br>的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter<br>不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的<br>请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内<br>存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到<br>一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设<br>备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。<br>NOWCODER.COM<br>32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？<br>考察点：接口<br>参考回答：<br>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的<br>前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使<br>用 iterate()方法可以减少性能开销。<br>② list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题<br>33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？<br>考察点：方法<br>参考回答：<br>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的<br>情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参<br>数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。<br>34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？<br>考察点：JAVA 构造函数<br>参考回答：<br>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提<br>供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。<br>Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必<br>须有它自己唯一的参数列表。<br>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，<br>Java 不会创建默认的复制构造函数。<br>35、hashCode()和 equals()方法有什么联系？<br>考点：基础<br>参考回答：<br>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<br>➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>➁ 如果两个对象的 hashCode 相同，它们并不一定相同。<br>NOWCODER.COM<br>④集合部分<br>1、Map 和 ConcurrentHashMap 的区别？<br>考点：集合<br>参考回答：<br>hashmap 是线程不安全的，put 时在多线程情况下，会形成环从而导致死循环。<br>CoucurrentHashMap 是线程安全的，采用分段锁机制，减少锁的粒度。<br>2、hashMap 内部具体如何实现的？<br>考点：集合<br>参考回答：<br>Hashmap 基于数组实现的，通过对 key 的 hashcode &amp; 数组的长度得到在数组中位置，如当<br>前数组有元素，则数组当前元素 next 指向要插入的元素，这样来解决 hash 冲突的，形成了拉链<br>式的结构。put 时在多线程情况下，会形成环从而导致死循环。数组长度一般是 2n，从 0 开始编<br>号，所以 hashcode &amp; （2n-1），（2n-1）每一位都是 1，这样会让散列均匀。需要注意的是，<br>HashMap 在 JDK1.8 的版本中引入了红黑树结构做优化，当链表元素个数大于等于 8 时，链表转<br>换成树结构；若桶中链表元素个数小于等于 6 时，树结构还原成链表。因为红黑树的平均查找长<br>度是 log(n)，长度为 8 的时候，平均查找长度为 3，如果继续使用链表，平均查找长度为 8&#x2F;2&#x3D;4，<br>这才有转换为树的必要。链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，虽然速度也很快的，但是转化为<br>树结构和生成树的时间并不会太短。还有选择 6 和 8，中间有个差值 7 可以有效防止链表和树频<br>繁转换。假设一下，如果设计成链表个数超过 8 则链表转换成树结构，链表个数小于 8 则树结构<br>转换成链表，如果一个 HashMap 不停的插入、删除元素，链表个数在 8 左右徘徊，就会频繁的发<br>生树转链表、链表转树，效率会很低。<br>3、如果 hashMap 的 key 是一个自定义的类，怎么办？<br>考点：集合<br>参考回答：<br>使用 HashMap，如果 key 是自定义的类，就必须重写 hashcode()和 equals()。<br>4、ArrayList 和 LinkedList 的区别，如果一直在 list 的尾部添加元素，用哪<br>个效率高？<br>考点：集合<br>参考回答：<br>NOWCODER.COM<br>ArrayList 采用数组数组实现的，查找效率比 LinkedList 高。LinkedList 采用双向链表实<br>现的，插入和删除的效率比 ArrayList 要高。一直在 list 的尾部添加元素，LinkedList 效率要<br>高。<br>5、HashMap 底层，负载因子，为啥是 2^n？<br>考点：集合<br>参考回答：<br>负载因子默认是 0.75， 2^n 是为了让散列更加均匀，例如出现极端情况都散列在数组中的<br>一个下标，那么 hashmap 会由 O（1）复杂退化为 O（n）的。<br>6、ConcurrentHashMap 锁加在了哪些地方？<br>考点：集合<br>参考回答：<br>加在每个 Segment 上面。<br>7、TreeMap 底层，红黑树原理？<br>考点：集合<br>参考回答：<br>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证<br>当需要快速检索指定节点。<br>红黑树的插入、删除、遍历时间复杂度都为 O(lgN)，所以性能上低于哈希表。但是哈希表<br>无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑<br>树性质：<br>性质 1：每个节点要么是红色，要么是黑色。<br>性质 2：根节点永远是黑色的。<br>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。<br>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续<br>的红色节点）<br>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。<br>8、concurrenthashmap 有啥优势，1.7，1.8 区别？<br>NOWCODER.COM<br>考点：集合<br>参考回答：<br>Concurrenthashmap 线程安全的，1.7 是在 jdk1.7 中采用 Segment + HashEntry 的方式进<br>行实现的，lock 加在 Segment 上面。1.7size 计算是先采用不加锁的方式，连续计算元素的个数，<br>最多计算 3 次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果<br>前后两次计算结果都不同，则给每个 Segment 进行加锁，再计算一次元素的个数；<br>1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node + CAS + Synchronized 来<br>保证并发安全进行实现，1.8 中使用一个 volatile 类型的变量 baseCount 记录元素的个数，当<br>插入新数据或则删除数据时，会通过 addCount()方法更新 baseCount，通过累加 baseCount 和<br>CounterCell 数组中的数量，即可得到元素的总个数；<br>9、ArrayList 是否会越界？<br>考点：集合<br>参考回答：<br>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构 2. 对<br>于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList<br>并发 add()可能出现数组下标越界异常<br>10、什么是 TreeMap?<br>考察点：key-value 集合<br>参考回答：<br>TreeMap 是一个有序的 key-value 集合，基于红黑树（Red-Black tree）的 NavigableMap<br>实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，<br>具体取决于使用的构造方法。<br>TreeMap 的特性：<br>根节点是黑色<br>每个节点都只能是红色或者黑色<br>每个叶节点（NIL 节点，空节点）是黑色的。<br>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个<br>红色的节点。<br>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>NOWCODER.COM<br>11、ConcurrentHashMap 的原理是什么？<br>考察点：JAVA 内存模型<br>参考回答：<br>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封<br>装映射表的键 &#x2F; 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的<br>若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例<br>中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在<br>HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。<br>static final class HashEntry&lt;K,V&gt; {<br>final K key; &#x2F;&#x2F; 声明<br>key 为 final 型<br>final int hash; &#x2F;&#x2F; 声明 hash<br>值为 final 型<br>volatile V value; &#x2F;&#x2F; 声明 value 为<br>volatile 型<br>final HashEntry&lt;K,V&gt; next; &#x2F;&#x2F; 声明 next 为 final 型<br>HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) {<br>this.key &#x3D; key;<br>this.hash &#x3D; hash;<br>this.next &#x3D; next;<br>this.value &#x3D; value;<br>}<br>}<br>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰<br>撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，<br>所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry<br>对象后的结构图：<br>图 1. 插入三个节点后桶的结构示意图：<br>NOWCODER.COM<br>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。<br>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个<br>Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。<br>12、Java 集合类框架的基本接口有哪些？<br>考察点：JAVA 集合<br>参考回答：<br>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它<br>自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基<br>本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的 Collection。<br>List：有顺序的 collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。<br>13、为什么集合类没有实现 Cloneable 和 Serializable 接口？<br>考察点：JAVA 集合<br>参考回答：<br>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，<br>应该由集合类的具体实现来决定如何被克隆或者是序列化。<br>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创<br>建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果<br>你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应<br>用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化<br>14、什么是迭代器？<br>考察点：JAVA 迭代器<br>参考回答：<br>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接<br>口,<br>NOWCODER.COM<br>每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合<br>的元素进行迭代操作. 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出<br>ConcurrentModificationException<br>异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除. 15、Iterator 和 ListIterator 的区别是什么？<br>考察点：迭代器<br>参考回答：<br>Iterator 和 ListIterator 的区别是：<br>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。<br>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前<br>一个和后一个元素的索引，等等。<br>16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？<br>考察点：集合<br>参考回答：<br>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。<br>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的<br>类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全<br>失败的迭代器永远不会抛出这样的异常。<br>18、ArrayList 和 LinkedList 有什么区别？<br>考察点：ArrayList<br>参考回答：<br>NOWCODER.COM<br>ArrayList 和 LinkedList 都实现了 List 接口，他们有以下的不同点：<br>ArrayList 是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行随机<br>访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个<br>和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。<br>相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任<br>意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向<br>前一个元素，一个指向下一个元素。<br>19、ArrayList,Vector,LinkedList 的存储性能和特性是什么？<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索<br>引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector<br>由于使用了 synchronized 方法（线程<br>安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据<br>需要进行前向或后向遍历，但是插入数<br>据时只需要记录本项的前后项即可，所以插入速度较快。<br>20、Collection 和 Collections 的区别。<br>考察点：集合<br>参考回答：<br>Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.<br>Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、<br>线程安全化等操作。<br>21、你所知道的集合类都有哪些？主要方法？<br>考察点：集合<br>参考回答：<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可<br>变大小的列表，比较适合构建、存储和操<br>作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其<br>中每个键映射到一个值。<br>23、阐述 ArrayList、Vector、LinkedList 的存储性能和特性<br>考察点：ArrayList<br>参考回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便<br>增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操<br>作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector<br>是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使<br>用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号<br>索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号<br>索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速<br>度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、<br>BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和<br>LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具<br>类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢<br>模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</li></ul><p>2、Java 高级知识<br>①线程<br>1、多线程中的 i++线程安全吗？为什么？<br>考察点：多线程<br>参考回答：<br>不安全。i++不是原子性操作。i++分为读取 i 值，对 i 值加一，再赋值给 i++，执行期中任<br>何一步都是有可能被其他线程抢占的。<br>2、如何线程安全的实现一个计数器？<br>考察点：多线程<br>参考回答：<br>可以使用加锁，比如 synchronized 或者 lock。也可以使用 Concurrent 包下的原子类。<br>3、多线程同步的方法<br>考察点：多线程<br>参考回答：<br>可以使用 synchronized、lock、volatile 和 ThreadLocal 来实现同步。<br>4、介绍一下生产者消费者模式？<br>考察点：线程<br>参考回答：<br>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储<br>空间，生产者向空间里生产数据，而消费者取走数据。<br>优点：支持并发、解耦。<br>5、线程，进程，然后线程创建有很大开销，怎么优化？<br>NOWCODER.COM<br>考察点：多线程<br>参考回答：<br>可以使用线程池。<br>6、线程池运行流程，参数，策略<br>考察点：线程池<br>参考回答：<br>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线<br>程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列<br>满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝<br>策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。<br>7、讲一下 AQS 吧。<br>考察点：多线程<br>参考回答：<br>AQS 其实就是一个可以给我们实现锁的框架<br>内部实现的关键是：先进先出的队列、state 状态<br>定义了内部类 ConditionObject<br>拥有两种线程模式独占模式和共享模式。<br>在 LOCK 包中的相关锁(常用的有 ReentrantLock、 ReadWriteLock)都是基于 AQS 来构建，<br>一般我们叫 AQS 为同步器。<br>10、Java 中有几种线程池？<br>考察点：线程池<br>参考回答：<br>1、newFixedThreadPool 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一<br>个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>2、newCachedThreadPool 创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1<br>分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个<br>工作线程。<br>3、newSingleThreadExecutor 创建一个单线程化的 Executor，即只创建唯一的工作者线程<br>来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特<br>色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个<br>线程是活动的 。<br>4、newScheduleThreadPool 创建一个定长的线程池，而且支持定时的以及周期性的任务执<br>行，类似于 Timer。(这种线程池原理暂还没完全了解透彻)<br>11、线程池有什么好处？<br>考察点：线程池<br>参考回答：<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。<br>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。<br>参考回答：<br>所谓回调，就是客户程序 C 调用服务程序 S 中的某个方法 A，然后 S 又在某个时候反过来调<br>用 C 中的某个方法 B，对于 C 来说，这个 B 便叫做回调方法。<br>17、同步方法和同步代码块的区别是什么？<br>考察点：JAVA 代码块同步<br>参考回答：<br>区别：<br>同步方法默认用 this 或者当前类 class 对象作为锁；<br>NOWCODER.COM<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步<br>问题的部分代码而不是整个方法；<br>18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同<br>步？<br>考察点：JAVA 线程同步<br>参考回答：<br>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一<br>个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行<br>同步代码。<br>26、线程的 sleep()方法和 yield()方法有什么区别？<br>考察点：线程<br>参考回答：<br>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行<br>的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）<br>状态；<br>③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。<br>27、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进<br>入此对象的 synchronized 方法 B？<br>考察点：线程<br>参考回答：<br>NOWCODER.COM<br>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的<br>synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被<br>取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。<br>28、请说出与线程同步以及线程调度相关的方法。<br>考察点：线程同步<br>参考回答：* wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p><ul><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理<br>InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一<br>个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让<br>它们竞争，只有获得锁的线程才能进入就绪状态；<br>通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。<br>Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()<br>方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），<br>信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须<br>得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必<br>须向信号量归还许可（调用 Semaphore 对象的 release()方法）。<br>29、举例说明同步和异步<br>考察点：线程<br>参考回答：<br>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据<br>以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就<br>必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个<br>需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，<br>在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是<br>非阻塞式操作。<br>31、说说线程的基本状态以及状态之间的关系？<br>考察点：线程<br>参考回答：<br>其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表<br>示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait()方法进入等待池，也可能是执行<br>同步方法或同步代码块进入等锁池，或者是调用了 sleep()方法或 join()方法等待休眠或其他线<br>程结束，或是因为发生了 I&#x2F;O 中断。<br>1、Java 中的 LongAdder 和 AtomicLong 的区别<br>考点：JDK<br>参考回答：<br>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到<br>修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在<br>大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合<br>ConcurrentHashMap 的实现思想，应该可以想到对一种传统 AtomicInteger 等原子类的改进思路。<br>虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger<br>NOWCODER.COM<br>的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字<br>进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元<br>cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进<br>行了有效的分离，提高了并行度。<br>2、JDK 和 JRE 的区别是什么？<br>考察点：JDK<br>参考回答：<br>Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet<br>需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其<br>他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应用程序。 ④反射<br>1、反射的实现与作用<br>考察点：反射<br>参考回答；<br>JAVA 语言编译之后会生成一个.class 文件，反射就是通过字节码文件找到某一个类、类中<br>的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构<br>造方法，Field：类中的属性对象，Method：类中的方法对象。<br>作用：反射机制指的是程序在运行时能够获取自身的信息。在 JAVA 中，只要给定类的名字，<br>那么就可以通过反射机制来获取类的所有信息。 ⑤JVM</li></ul><p>5、JAVA 虚拟机的作用?<br>考察点：java 虚拟机<br>参考回答：<br>解释运行字节码程序 消除平台相关性。<br>NOWCODER.COM<br>jvm 将 java 字节码解释为具体平台的具体指令。一般的高级语言如要在不同的平台上运行，<br>至少需要编译成不同的目标代码。而引入 JVM 后，Java 语言在不同平台上运行时不需要重新编<br>译。Java 语言使用模式 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言编译程序只<br>需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java<br>虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<br>假设一个场景，要求 stop the world 时间非常短，你会怎么设计垃圾回收机制？<br>绝大多数新创建的对象分配在 Eden 区。<br>在 Eden 区发生一次 GC 后，存活的对象移到其中一个 Survivor 区。<br>在 Eden 区发生一次 GC 后，对象是存放到 Survivor 区，这个 Survivor 区已经存在其他存活<br>的对象。<br>一旦一个 Survivor 区已满，存活的对象移动到另外一个 Survivor 区。然后之前那个空间已<br>满 Survivor 区将置为空，没有任何数据。<br>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。<br>9、jvm 是如何实现线程？<br>考察点：JVM<br>参考回答：<br>NOWCODER.COM<br>线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开。<br>一个进程里可以启动多条线程，各个线程可共享该进程的资源(内存地址，文件 IO 等)，又可以<br>独立调度。线程是 CPU 调度的基本单位。<br>主流 OS 都提供线程实现。Java 语言提供对线程操作的同一 API，每个已经执行 start()，<br>且还未结束的 java.lang.Thread 类的实例，代表了一个线程。<br>Thread 类的关键方法，都声明为 Native。这意味着这个方法无法或没有使用平台无关的手<br>段来实现，也可能是为了执行效率。<br>实现线程的方式<br>A.使用内核线程实现内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核支持<br>的线程。<br>内核来完成线程切换<br>内核通过调度器 Scheduler 调度线程，并将线程的任务映射到各个 CPU 上<br>程序使用内核线程的高级接口，轻量级进程(Light Weight Process,LWP)<br>用户态和内核态切换消耗内核资源<br>使用用户线程实现<br>系统内核不能感知线程存在的实现<br>用户线程的建立、同步、销毁和调度完全在用户态中完成<br>所有线程操作需要用户程序自己处理，复杂度高<br>用户线程加轻量级进程混合实现<br>轻量级进程作为用户线程和内核线程之间的桥梁<br>10、jvm 最大内存限制多少<br>考察点：JVM<br>参考回答：<br>(1)堆内存分配<br>JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1&#x2F;64；JVM 最大分配的内存由-Xmx 指<br>定，默认是物理内存的 1&#x2F;4。默认空余堆内存小 于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；<br>空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。因此服务器一般设置-Xms、 -Xmx 相等以避免在每次 GC 后调整堆的大小。<br>(2)非堆内存分配<br>JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1&#x2F;64；由 XX:MaxPermSize<br>设置最大非堆内存的大小，默认是物理内存的 1&#x2F;4。<br>NOWCODER.COM<br>(3)VM 最大内存<br>首先 JVM 内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM 内存的最大值跟<br>操作系统有很大的关系。简单的说就 32 位处理器虽 然可控内存空间有 4GB,但是具体的操作系<br>统会给一个限制，这个限制一般是 2GB-3GB（一般来说 Windows 系统下为 1.5G-2G，Linux 系 统<br>下为 2G-3G），而 64bit 以上的处理器就不会有限制了。<br>(3)下面是当前比较流行的几个不同公司不同版本 JVM 最大堆内存:<br>11、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？<br>考察点：JVM<br>参考回答：<br>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚<br>拟机执行的字节码文件。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或<br>者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。<br>12、描述一下 JVM 加载 class 文件的原理机制?<br>考察点：JVM<br>参考回答：<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的<br>Java 运行时系统组件。它负责在运行时查找和装入类文件的类。<br>Java 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，<br>而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的<br>加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要<br>的类。<br>NOWCODER.COM<br>类装载方式，有两种<br>（1）隐式装载， 程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载<br>对应的类到 jvm 中，<br>（2）显式装载， 通过 class.forname()等方法，显式加载需要的类 , 隐式加载与显式加载的<br>区别：两者本质是一样的。<br>Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行<br>的基础类(像是基类)完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了<br>节省内存开销。 ⑥GC<br>1、java 中内存泄露是啥，什么时候出现内存泄露？<br>考察点：内存泄漏<br>参考回答：<br>Java 中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就<br>是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。<br>2、minor gc 如果运行的很频繁，可能是什么原因引起的，minor gc 如果运行的<br>很慢，可能是什么原因引起的?<br>考察点：GC<br>参考回答：<br>可能是堆内存太小。<br>3、阐述 GC 算法<br>考察点：JVM<br>参考回答：<br>①GC（GarbageCollection 垃圾收集），GC 的对象是堆空间和永久区<br>②GC 算法包含：引用计数法，标记清除，标记压缩，复制算法。<br>③引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用<br>计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A<br>就不可能再被使用。<br>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：<br>标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开<br>始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有<br>未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对<br>象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正<br>NOWCODER.COM<br>在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对<br>象，交换两个内存的角色，完成垃圾回收。<br>4、GC 是什么? 为什么要有 GC?<br>考察点：回收<br>参考回答：<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，<br>忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监<br>测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显<br>示操作方法。<br>5、垃圾回收的优点和原理。并考虑 2 种回收机制<br>考察点：垃圾回收<br>参考回答：<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的<br>问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回<br>收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以<br>有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的<br>线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，<br>程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃<br>圾回收和标记垃圾回收，增量垃圾回收。<br>6、java 中会存在内存泄漏吗，请简单描述。<br>考察点：内存<br>参考回答：<br>Java 中的确存在 Java 的内存泄漏, 并且事态可以变得相当严重<br>Java garbage collector 自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的<br>其他程序上下文的内存泄漏. 但是 Java 应用程序依旧会有相当的内存泄漏. 查找原因会十分困<br>难. 有两类主要的 Java 内存泄漏:* 不再需要的对象引用</p><ul><li>未释放的系统资源<br>2.2 非必要的对象引用<br>Java 代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java 对<br>象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如<br>下问题:</li><li>在向数组添加对象以后遗漏了对于他们的处理</li><li>直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并<br>且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.</li><li>在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面<br>保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当<br>中.<br>NOWCODER.COM</li><li>允许一个长久执行的线程所引用的对象. 设置引用为 NULL 也无济于事, 在线程退出和空闲之<br>前, 对象不会被收集释放<br>2.3 未释放的系统资源<br>Java 方法可以定位 Java 实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java 常常通过<br>JNI(Java Native Interface)调用 C&#x2F;C++子程序定位这些资源. 7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办<br>法主动通知虚拟机进行垃圾回收？（垃圾回收）<br>考察点：垃圾回收<br>参考回答：<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆<br>(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当<br>GC 确定一些对象为”不可达”时，GC 就有责<br>任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言<br>规范并不保证 GC 一定会执行。 ⑦ IO 和 NIO，AIO<br>1、怎么打印日志？<br>考察点：异常<br>参考回答：<br>cat &#x2F;var&#x2F;log&#x2F;*.log<br>如果日志在更新，如何实时查看 tail -f &#x2F;var&#x2F;log&#x2F;messages<br>还可以使用 watch -d -n 1 cat &#x2F;var&#x2F;log&#x2F;messages<br>-d 表示高亮不同的地方，-n 表示多少秒刷新一次。<br>2、运行时异常与一般异常有何异同？<br>考察点：异常<br>参考回答：<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异<br>常，但是并不要求必须声明抛出未被捕获的运行时异常。<br>3、error 和 exception 有什么区别?<br>考察点：异常<br>NOWCODER.COM<br>参考回答：<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指<br>望程序能处理这样的情况。<br>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。<br>4、给我一个你最常见到的 runtime exception<br>考察点：异常<br>参考回答：<br>ArithmeticException,<br>ArrayStoreException,<br>BufferOverflowException,<br>BufferUnderflowException,<br>CannotRedoException,<br>CannotUndoException,<br>ClassCastException,<br>CMMException,<br>ConcurrentModificationException,<br>DOMException,<br>EmptyStackException,<br>IllegalArgumentException,<br>IllegalMonitorStateException,<br>IllegalPathStateException,<br>IllegalStateException,<br>ImagingOpException,<br>IndexOutOfBoundsException,<br>MissingResourceException,<br>NegativeArraySizeException,<br>NoSuchElementException,<br>NullPointerException,<br>ProfileDataException,<br>NOWCODER.COM<br>ProviderException,<br>RasterFormatException, SecurityException, SystemException,<br>UndeclaredThrowableException, UnmodifiableSetException,<br>UnsupportedOperationException<br>5、Java 中的异常处理机制的简单原理和应用。<br>考察点：异常<br>参考回答：<br>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。<br>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发<br>IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就<br>是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。<br>6、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，<br>请说出他们分别是哪些类？<br>考察点：stream<br>参考回答：<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于<br>InputStreamReader OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高<br>性能和使用方便。<br>8、运行时异常与受检异常有什么区别？<br>考察点：异常<br>参考回答：<br>NOWCODER.COM<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能<br>遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序<br>运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求<br>方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异<br>常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用<br>给出了以下指导原则：* 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流<br>而使用异常）</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在 catch 中忽略掉捕获到的异常<br>二、JavaEE 部分<br>3、Spring 里面注解用过没有？autowired 和 resource 区别？<br>考察点：Spring<br>参考回答：<br>1、共同点<br>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter<br>方法。<br>2、不同点<br>（1）@Autowired<br>@Autowired 为 Spring 提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired;只按照 byType 注入。<br>NOWCODER.COM<br>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存<br>在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）<br>来装配，可以结合@Qualifier 注解一起使用。<br>（2）@Resource<br>@Resource 默认按照 ByName 自动注入，由 J2EE 提供，需要导入包<br>javax.annotation.Resource。@Resource 有两个重要的属性：name 和 type，而 Spring 将<br>@Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以，如<br>果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入<br>策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。<br>4、@Controller 和@RestController 的区别？<br>考察点：spring<br>参考回答：<br>@RestController 注解相当于@ResponseBody ＋ @Controller 合在一起的作用<br>2、Struts 拦截器和 Spring AOP 区别？<br>考察点：框架<br>参考回答：<br>拦截器是 AOP 的一种实现，struts2 拦截器采用 xwork2 的 interceptor！而 spring 的 AOP<br>基于 IoC 基础,其底层采用动态代理与 CGLIB 代理两种方式结合的实现方式。<br>4、选择使用 Spring 框架的原因（Spring 框架为企业级开发带来的好处有哪些）？<br>考察点：框架<br>参考回答：<br>NOWCODER.COM</li><li>非侵入式：支持基于 POJO 的编程模式，不强制性的要求实现 Spring 框架中的接口或继承<br>Spring 框架中的类。</li><li>IoC 容器：IoC 容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如<br>果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建<br>和完整的回归测试。有了 IoC 容器，程序员再也不需要自己编写工厂、单例，这一点特别符合<br>Spring 的精神”不要重复的发明轮子”。</li><li>AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将<br>横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，<br>有了 AOP 程序员可以省去很多自己写代理类的工作。</li><li>MVC：Spring 的 MVC 框架为 Web 表示层提供了更好的解决方案。</li><li>事务管理：Spring 以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，<br>在不需要任何一行代码的情况下就能够完成事务管理。</li><li>其他：选择 Spring 框架的原因还远不止于此，Spring 为 Java 企业级开发提供了一站式选择，<br>你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到 Spring 存在的情<br>况下，在你的项目中使用 Spring 提供的各种优秀的功能。 ④Spring，JPA 整合<br>1、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？<br>考察点：框架<br>参考回答：<br>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中<br>的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统<br>中专注于实现数据持久化的相对独立的层面。<br>持久层设计的目标包括：</li><li>数据存储逻辑的分离，提供抽象化的数据访问接口。</li><li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。</li><li>资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。</li><li>数据抽象，提供更面向对象的数据操作。<br>持久层框架有：</li><li>Hibernate</li><li>MyBatis</li><li>TopLink</li><li>Guzz</li><li>jOOQ</li><li>Spring Data</li><li>ActiveJDBC<br>NOWCODER.COM<br>2、Hibernate<br>①ORM 与持久化映射<br>1、阐述实体对象的三种状态以及转换关系。<br>考察点：JAVA 实体<br>参考回答：<br>最新的 Hibernate 文档中为 Hibernate 对象定义了四种状态（原来是三种状态，面试的时候<br>基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or<br>persistent）、游状态（detached）和移除态（removed，以前 Hibernate 文档中定义的三种状<br>态中没有移除态），如下图所示，就以前的 Hibernate 文档中移除态被视为是瞬时态。<br>瞬时态：当 new 一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数<br>据的内存区域，如果没有变量引用这个对象，则会被 JVM 的垃圾回收机制回收。这个对象所保存<br>的数据与数据库没有任何关系，除非通过 Session 的 save()、saveOrUpdate()、persist()、merge()<br>方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对<br>象。<br>持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态<br>对象进行 delete 操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存<br>在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上<br>同步到数据库，直到数据库事务提交。<br>游离态：当 Session 进行了 close()、clear()、evict()或 flush()后，实体对象从持久态变成<br>游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除<br>掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象<br>是十分相似的，只是它还含有持久化标识。 ②延迟加载、性能优化<br>1、Hibernate 中 SessionFactory 是线程安全的吗？Session 是线程安全的吗（两<br>个线程能够共享同一个 Session 吗）？<br>考察点：session<br>参考回答：<br>SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线<br>程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将<br>SessionFactory 通过单例模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象<br>（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。Session 是由<br>SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接<br>口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的<br>session，可以使用 ThreadLocal 将 session 和当前线程绑定在一起，这样可以让同一个线程获<br>得的总是同一个 session。Hibernate 3 中 SessionFactory 的 getCurrentSession()方法就可以<br>做到。<br>NOWCODER.COM<br>2、Hibernate 中 Session 的 load 和 get 方法的区别是什么？<br>考察点：请求方式<br>参考回答：<br>主要有以下三项区别：<br>① 如果没有找到符合条件的记录，get 方法返回 null，load 方法抛出异常。<br>② get 方法直接返回实体类对象，load 方法返回实体类对象的代理。<br>③ 在 Hibernate 3 之前，get 方法只在一级缓存中进行数据查找，如果没有找到对应的数据则<br>越过二级缓存，直接发出 SQL 语句完成数据读取；load 方法则可以从二级缓存中获取数据；从<br>Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。<br>对于 load()方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加<br>载，如果没有数据就抛出异常，而通过 get()方法获取的数据可以不存在。<br>3、如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session<br>关闭的矛盾是如何处理的？<br>考察点：hibernate 框架<br>参考回答：<br>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate<br>使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load()方法加载数据或者一对多关联<br>映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给<br>用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据<br>库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。<br>延迟加载与 session 关闭的矛盾一般可以这样处理：<br>① 关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通<br>过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or<br>session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询<br>的开销都会变得很大。<br>② 在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized()<br>判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize()方法加载对象。<br>③ 使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提<br>供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。<br>4、简述 Hibernate 常见优化策略。<br>考察点：Hibernate<br>参考回答：<br>①制定合理的缓存策略（二级缓存、查询缓存）。<br>② 采用合理的 Session 管理机制。<br>③ 尽量使用延迟加载特性。<br>④ 设定合理的批处理参数。<br>⑤ 如果可以，选用 UUID 作为主键生成器。<br>⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。<br>⑦ 在开发过程中, 开启 hibernate.show_sql 选项查看生成的 SQL，从而了解底层的状况；开发<br>完成后关闭此选项。<br>NOWCODER.COM<br>⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观<br>的提升，但这些需要专业的 DBA（数据库管理员）提供支持。<br>5、锁机制有什么用？简述 Hibernate 的悲观锁和乐观锁机制。<br>考察点：锁<br>参考回答：<br>有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此<br>过程中数据被锁住不会被外界修改，这就是所谓的锁机制。<br>Hibernate 支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极<br>有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理<br>的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，<br>乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过<br>更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐<br>观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加 1，<br>然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的<br>当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate 中通过 Session 的 get()和<br>load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加<br>整型的版本字段再通过 XML 或@Version 注解进行配置。<br>使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了<br>空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间<br>换时间的策略。 ③HQL 查询、条件查询、SQL 查询<br>1、Hibernate 如何实现分页查询？<br>考察点：框架<br>参考回答：<br>通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()<br>方法）或查询条件（调用 Session 的 createCriteria()方法）、设置查询起始行数（调用 Query<br>或 Criteria 接口的 setFirstResult()方法）和最大查询行数（调用 Query 或 Criteria 接口的<br>setMaxResults()方法），并调用 Query 或 Criteria 接口的 list()方法，Hibernate 会自动生成<br>分页查询的 SQL 语句。 ④二级缓存与查询缓存<br>1、谈一谈 Hibernate 的一级缓存、二级缓存和查询缓存。<br>考察点：缓存<br>参考回答：<br>NOWCODER.COM<br>Hibernate 的 Session 提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实<br>体、修改持久化实体时，Session 并不会立即把这种改变提交到数据库，而是缓存在当前的<br>Session 中，除非显示调用了 Session 的 flush()方法或通过 close()方法关闭 Session。通过一<br>级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。<br>SessionFactory 级别的二级缓存是全局性的，所有的 Session 可以共享这个二级缓存。不过二<br>级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供<br>的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory 就会缓<br>存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。<br>一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓<br>存，可以使用查询缓存。查询缓存是将 HQL 或 SQL 语句以及它们的查询结果作为键值对进行缓存，<br>对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。<br>3、Struts<br>①MVC 模式与 Struts 体系<br>1、说说 STRUTS 的应用<br>考察点：STRUTS 架构<br>参考回答：<br>Struts 是采用 Java Servlet&#x2F;JavaServer Pages 技术，开发 Web 应用程序的开放源码的<br>framework。采用 Struts 能开发出基于 MVC(Model-View-Controller)设计模式的应用构架。<br>Struts 有如下的主要功能：<br>包含一个 controller servlet，能将用户的请求发送到相应的 Action 对象。二.JSP 自由<br>tag 库，并且在 controller servlet 中提供关联支持，帮助开发员创建交互式表单应用。<br>提供了一系列实用对象：XML 处理、通过 Java reflection APIs 自动处理 JavaBeans 属性、<br>国际化的提示和消息。<br>4、Mybatis<br>1、解释一下 MyBatis 中命名空间（namespace）的作用。<br>考察点：Mybatis<br>参考回答：<br>在大型项目中，可能存在大量的 SQL 语句，这时候为每个 SQL 语句起一个唯一的标识（ID）<br>就变得并不容易了。为了解决这个问题，在 MyBatis 中，可以为每个映射文件起一个唯一的命名<br>空间，这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只<br>要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不<br>会再产生冲突了。<br>NOWCODER.COM<br>2、MyBatis 中的动态 SQL 是什么意思？<br>考察点：SQL<br>参考回答：<br>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，<br>需要根据用户指定的条件动态生成 SQL 语句。如果不使用持久层框架我们可能需要自己拼装 SQL<br>语句，还好 MyBatis 提供了动态 SQL 的功能来解决这个问题。MyBatis 中用于实现动态 SQL 的元<br>素主要有：</li><li>if</li><li>choose &#x2F; when &#x2F; otherwise</li><li>trim</li><li>where</li><li>set</li><li>foreach<br>5、MVC<br>1、Spring MVC 注解的优点<br>考察点：spring mvc<br>参考回答：<br>1、XML 配置起来有时候冗长，此时注解可能是更好的选择，如 jpa 的实体映射；注解在处<br>理一些不变的元数据时有时候比 XML 方便的多，比如 springmvc 的数据绑定，如果用 xml 写的代<br>码会多的多；<br>2、注解最大的好处就是简化了 XML 配置；其实大部分注解一定确定后很少会改变，所以在<br>一些中小项目中使用注解反而提供了开发效率，所以没必要一头走到黑；<br>3、注解相对于 XML 的另一个好处是类型安全的，XML 只能在运行期才能发现问题。<br>2、springmvc 和 spring-boot 区别？<br>考察点：spring<br>参考回答：<br>总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA 等等。但<br>他们的基础都是 Spring 的 IOC 和 AOP，IOC 提供了依赖注入的容器，而 AOP 解决了面向切面的<br>编程，然后在此两者的基础上实现了其他衍生产品的高级功能；因为 Spring 的配置非常复杂，<br>各种 xml，properties 处理起来比较繁琐。于是为了简化开发者的使用，Spring 社区创造性地<br>推出了 Spring Boot，它遵循约定优于配置，极大降低了 Spring 使用门槛，<br>但又不失 Spring 原本灵活强大的功能。<br>3、SpringMVC 的运行机制，运行机制的每一部分的相关知识？<br>考察点：spring<br>NOWCODER.COM<br>参考回答：<br>1、用户发送请求时会先从 DispathcherServler 的 doService 方法开始，在该方法中会将<br>ApplicationContext、localeResolver、themeResolver 等对象添加到 request 中，紧接着就是<br>调用 doDispatch 方法。<br>2、进入该方法后首先会检查该请求是否是文件上传的请求(校验的规则是是否是 post 并且<br>contenttType 是否为 multipart&#x2F;为前缀)即调用的是 checkMultipart 方法；如果是的将 request<br>包装成 MultipartHttpServletRequest。<br>3、然后调用 getHandler 方法来匹配每个 HandlerMapping 对象，如果匹配成功会返回这个<br>Handle 的处理链 HandlerExecutionChain 对象，在获取该对象的内部其实也获取我们自定定义<br>的拦截器，并执行了其中的方法。<br>4、执行拦截器的 preHandle 方法，如果返回 false 执行 afterCompletion 方法并理解返回<br>5、通过上述获取到了 HandlerExecutionChain 对象，通过该对象的 getHandler()方法获得<br>一个 object 通过 HandlerAdapter 进行封装得到 HandlerAdapter 对象。<br>6、该对象调用 handle 方法来执行 Controller 中的方法，该对象如果返回一个 ModelAndView 给 DispatcherServlet。<br>7、DispatcherServlet借助ViewResolver完成逻辑试图名到真实视图对象的解析，得到View 后 DispatcherServlet 使用这个 View 对 ModelAndView 中的模型数据进行视图渲染。</li></ul><p>6、各框架对比与项目优化<br>1、Mybatis 和 Hibernate 区别？<br>NOWCODER.COM<br>考察点：Spring 框架<br>参考回答：1. 简介<br>Hibernate：Hibernate 是当前最流行的 ORM 框架之一，对 JDBC 提供了较为完整的封装。<br>Hibernate 的 O&#x2F;R Mapping 实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。<br>Mybatis：Mybatis 同样也是非常流行的 ORM 框架，主要着力点在于 POJO 与 SQL 之间的映<br>射关系。然后通过映射配置文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO 。<br>相对 Hibernate“O&#x2F;R”而言，Mybatis 是一种“Sql Mapping”的 ORM 实现。<br>2、缓存机制对比<br>相同点<br>Hibernate 和 Mybatis 的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己<br>的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。<br>不同点<br>Hibernate 的二级缓存配置在 SessionFactory 生成的配置文件中进行详细配置，然后再在<br>具体的表-对象映射中配置是那种缓存。<br>MyBatis 的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的<br>表可以自定义不同的缓存机制。并且 Mybatis 可以在命名空间中共享相同的缓存配置和实例，通<br>过 Cache-ref 来实现。<br>两者比较<br>因为 Hibernate 对查询对象有着良好的管理机制，用户无需关心 SQL。所以在使用二级缓存<br>时如果出现脏数据，系统会报出错误并提示。而 MyBatis 在这一方面，使用二级缓存时需要特别<br>小心。如果不能完全确定数据更新操作的波及范围，避免 Cache 的盲目使用。否则，脏数据的出<br>现会给系统的正常运行带来很大的隐患。<br>Mybatis：小巧、方便、高效、简单、直接、半自动化<br>Hibernate：强大、方便、高效、复杂、间接、全自动化<br>2、介绍一下你了解的 Java 领域的 Web Service 框架。<br>考察点：框架<br>参考回答：<br>Java 领域的 Web Service 框架很多，包括 Axis2（Axis 的升级版本）、Jersey（RESTful<br>的 Web Service 框架）、CXF（XFire 的延续版本）、Hessian、Turmeric、JBoss SOA 等，其中<br>绝大多数都是开源框架。<br>NOWCODER.COM<br>7、JPA<br>①EJB<br>1、EJB 是基于哪些技术实现的？并说出 SessionBean 和 EntityBean 的区别，<br>StatefulBean 和 StatelessBean 的区别。<br>考察点：JAVA EJB<br>参考回答：<br>EJB 包括 Session Bean、Entity Bean、Message Driven Bean，基于 JNDI、RMI、JAT 等技<br>术实现。<br>SessionBean 在 J2EE 应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用<br>其他 EJB 组件。EntityBean 被用来代表应用系统中用到的数据。<br>对于客户机，SessionBean 是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。<br>对于客户机，EntityBean 是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象<br>视图，或是一个由现有企业应用程序实现的实体。<br>Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种<br>的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可<br>以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的<br>实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是<br>说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的<br>Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个<br>Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面<br>来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会<br>消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者<br>的状态。<br>2、EJB 与 JAVA BEAN 的区别？<br>考察点：EJB<br>参考回答：<br>Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java<br>类都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所以<br>Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于<br>实现 Bean 的持久性。Java Bean 实际上相当于微软 COM 模型中的本地进程内 COM 组件，它是不<br>能被跨进程访问的。EnterpriseJava Bean 相当于 DCOM，即分布式组件。它是基于 Java 的远程<br>方法调用（RMI）技术的，所以 EJB 可以被远程访问（跨进程、跨计算机）。但 EJB 必须被布署<br>在诸如 Webspere、WebLogic 这样的容器中，EJB 客户从不直接访问真正的 EJB 组件，而是通过<br>其容器访问。EJB 容器是 EJB 组件的代理， EJB 组件由容器所创建和管理。客户通过容器来访问<br>真正的 EJB 组件。<br>3、EJB 包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事<br>务的？<br>考察点：JAVA EJB<br>NOWCODER.COM<br>参考回答：<br>SessionBean： Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求<br>要建立一个 Bean 的实例时，EJB 容器不一定<br>要创建一个新的 Bean 的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户<br>机第一次调用一个 Stateful Session<br>Bean 时，容器必须立即在服务器中创建一个新的 Bean 实例，并关联到客户机上，以后此客户机<br>调用 Stateful Session Bean 的方法<br>时容器会把调用分派到与此客户机相关联的 Bean 实例。<br>EntityBean：Entity Beans 能存活相对较长的时间，并且状态是持续的。只要数据库中的数据<br>存在，Entity beans 就一直存活。而不<br>是按照应用程序或者服务进程来说的。即使 EJB 容器崩溃了，Entity beans 也是存活的。Entity<br>Beans 生命周期能够被容器或者<br>Beans 自己管理。<br>EJB 通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems<br>的 Transaction Service（JTS）、<br>Java Transaction API（JTA），开发组（X&#x2F;Open）的 XA 接口。<br>4、EJB 的角色和三个对象是什么？<br>考察点：EJB<br>参考回答：<br>一个完整的基于 EJB 的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提<br>供，每个角色所作的工作必须遵循 Sun 公司<br>提供的 EJB 规范，以保证彼此之间的兼容性。这六个角色分别是 EJB 组件开发者（Enterprise Bean<br>Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供<br>者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System<br>Administrator）<br>三个对象是 Remote（Local）接口、Home（LocalHome）接口，Bean 类<br>5、说说 EJB 规范规定 EJB 中禁止的操作有哪些？<br>考察点：EJB<br>参考回答：<br>1.不能操作线程和线程 API(线程 API 指非线程对象的方法如 notify,wait 等)，<br>2.不能操作 awt，<br>3.不能实现服务器功能，<br>4.不能对静态属生存取，<br>5.不能使用 IO 操作直接存取文件系统，<br>6.不能加载本地库.，<br>7.不能将 this 作为变量和返回，<br>NOWCODER.COM<br>8.不能循环调用。<br>6、EJB 的激活机制是什么？<br>考察点：EJB<br>参考回答：<br>以 Stateful Session Bean 为例：其 Cache 大小决定了内存中可以同时存在的 Bean 实例的<br>数量，根据 MRU 或 NRU 算法，实例在激活和去<br>激活状态之间迁移，激活机制是当客户端调用某个 EJB 实例业务方法时，如果对应 EJB Object<br>发现自己没有绑定对应的 Bean 实例则从<br>其去激活 Bean 存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对<br>应的 ejbActive 和 ejbPassivate 方法。<br>7、EJB 的几种类型分别是什么<br>考察点：EJB<br>参考回答：<br>会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean，会话<br>Bean 又可分为有状态（Stateful）和无状态（Stateless）两种，<br>实体 Bean 可分为 Bean 管理的持续性（BMP）和容器管理的持续性（CMP）两种。<br>8、EJB 需直接实现它的业务接口或 Home 接口吗，请简述理由。<br>考察点：EJB<br>参考回答：<br>在 EJB 中则至少要包括 10 个 class:<br>Bean 类，特定 App Server 的 Bean 实现类 Bean 的 remote 接口，特定 App Server 的 remote 接<br>口实现类，特定 App Server 的 remote 接口的实现类的 stub 类和 skeleton 类。<br>Bean 的 home 接口，特定 App Server 的 home 接口实现类，特定 App Server 的 home 接口的实现<br>类的 stub 类和 skeleton 类。<br>和 RMI 不同的是，EJB 中这 10 个 class 真正需要用户写的只有 3 个，Bean 类，remote 接口，home<br>接口，其它的 7 个究竟怎么生成，被打包在哪里，是否需要更多的类文件，否根据不同的 App<br>Server 表现出较大的差异。<br>Weblogic：<br>home 接口和 remote 接口的 weblogic 的实现类的 stub 类和 skeleton 类是在 EJB 被部署到<br>weblogic 的时候，由 weblogic 动态生成 stub 类和 skeleton 类的字节码，所以看不到这 4 个类<br>文件。<br>对于一次客户端远程调用 EJB，要经过两个远程对象的多次 RMI 循环。首先是通过 JNDI 查找 Home<br>接口，获得 Home 接口的实现类，这个过程其实相当复杂，首先是找到 Home 接口的 Weblogic 实<br>现类，然后创建一个 Home 接口的 Weblogic 实现类的 stub 类的对象实例，将它序列化传送给客<br>户端（注意 stub 类的实例是在第 1 次 RMI 循环中，由服务器动态发送给客户端的，因此不需要<br>客户端保存 Home 接口的 Weblogic 实现类的 stub 类），最后客户端获得该 stub 类的对象实例<br>（普通的 RMI 需要在客户端保存 stub 类，而 EJB 不需要，因为服务器会把 stub 类的对象实例发<br>送给客户端）。<br>客户端拿到服务器给它的 Home 接口的 Weblogic 实现类的 stub 类对象实例以后，调用 stub 类的<br>NOWCODER.COM<br>create 方法， (在代码上就是 home.create()，但是后台要做很多事情),于是经过第 2 次 RMI<br>循环，在服务器端，Home 接口的 Weblogic 实现类的 skeleton 类收到 stub 类的调用信息后，由<br>它再去调用 Home 接口的 Weblogic 实现类的 create 方法。<br>在服务端， Home 接口的 Weblogic 实现类的 create 方法再去调用 Bean 类的 Weblogic 实现类的<br>ejbCreate 方法，在服务端创建或者分配一个 EJB 实例，然后将这个 EJB 实例的远程接口的<br>Weblogic 实现类的 stub 类对象实例序列化发送给客户端。 三、Java web 编程<br>1、web 编程基础<br>①Tomcat 服务器<br>1、启动项目时如何实现不在链接里输入项目名就能启动?<br>考察点：tomcat<br>参考回答：<br>可在 taomcat 配置虚拟目录。<br>2、1 分钟之内只能处理 1000 个请求，你怎么实现，手撕代码?<br>考察点：tomcat<br>参考回答：<br>限流的几种方法：计数器，滑动窗口、漏桶法、令牌桶<br>3、什么时候用 assert<br>考察点：JAVA 调试<br>参考回答：<br>assertion (断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。<br>在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确<br>程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的<br>状态下，系统将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正确性。<br>assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常<br>是关闭的。<br>4、JAVA 应用服务器有那些？<br>考察点：服务器<br>参考回答：<br>NOWCODER.COM<br>BEA WebLogic Server，<br>IBM WebSphere Application Server，<br>Oracle9i Application Server<br>jBoss，<br>Tomcat<br>5、说说 weblogic 中一个 Domain 的缺省目录结构?比如要将一个简单的<br>helloWorld.jsp 放入何目录下,然后在浏览器上就可打入主机？<br>考察点：目录结构<br>参考回答：<br>端口号&#x2F;&#x2F;helloword.jsp 就可以看到运行结果了? 又比如这其中用到了一个自己写的<br>javaBean 该如何办?<br>NOWCODER.COM<br>Domain 目录服务器目录 applications，将应用目录放在此目录下将可以作为应用访问，如果是<br>Web 应用，应用目录需要满足 Web 应用<br>目录要求，jsp 文件可以直接放在应用目录中，Javabean 需要放在应用目录的 WEB-INF 目录的<br>classes 目录中，设置服务器的缺省应用<br>将可以实现在浏览器上无需输入应用名。<br>6、jsp 有哪些动作?作用分别是什么?<br>考察点：JSP<br>参考回答：<br>JSP 共有以下 6 种基本动作 jsp:include：在页面被请求的时候引入一个文件。<br>jsp:useBean：寻找或者实例化一个 JavaBean。<br>jsp:setProperty：设置 JavaBean 的属性。 jsp:getProperty：输出某个 JavaBean 的属性。<br>jsp:forward：把请求转到一个新的页面。<br>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。<br>8、说一下表达式语言（EL）的隐式对象及其作用<br>考察点：EL<br>NOWCODER.COM<br>参考回答：<br>EL 的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、<br>paramValues、header（访问请求头）、headerValues、cookie（访问 cookie）、applicationScope<br>（访问 application 作用域）、sessionScope（访问 session 作用域）、requestScope（访问 request<br>作用域）、pageScope（访问 page 作用域）。<br>9、JSP 中的静态包含和动态包含有什么区别？<br>考察点：JSP<br>参考回答：<br>静态包含是通过 JSP 的 include指令包含页面，动态包含是通过 JSP 标准动作<a href="jsp:forward">jsp:forward</a><br>包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的<br>“contentType”属性应保持一致，因为两个页面会合二为一，只产生一个 class 文件，因此被包<br>含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含<br>的页面传递参数，包含页面和被包含页面是独立的，会编译出两个 class 文件，如果被包含的页<br>面不存在，不会产生编译错误，也不影响页面其他部分的执行。<br>例如：&lt;%– 静态包含 –%&gt;<br>&lt;%@ include file&#x3D;”…” %&gt;<br>&lt;%– 动态包含 –%&gt;<br>&lt;jsp:include page&#x3D;”…”&gt;<br>&lt;jsp:param name&#x3D;”…” value&#x3D;”…” &#x2F;&gt;<br>&lt;&#x2F;jsp:include&gt;<br>③Listener 和 Filter</p><p>2、Web 编程进阶<br>①Servlet、标签的作用<br>1、forward 与 redirect 区别，说一下你知道的状态码，redirect 的状态码是多<br>少？<br>考察点：Servlet<br>参考回答：<br>1.从地址栏显示来说<br>NOWCODER.COM<br>forward 是服务器请求资源,服务器直接访问目标地址的 URL,把那个 URL 的响应内容读取过<br>来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地<br>址栏还是原来的地址.<br>redirect 是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址<br>栏显示的是新的 URL.<br>2.从数据共享来说<br>forward:转发页面和转发到的页面可以共享 request 里面的数据.<br>redirect:不能共享数据.<br>3.从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.<br>4.从效率来说<br>forward:高.<br>redirect:低.<br>redirect 的状态码是 302<br>2、servlet 生命周期，是否单例，为什么是单例。<br>考察点：servlet<br>参考回答：<br>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：<br>Servlet 通过调用 init () 方法进行初始化。<br>Servlet 调用 service() 方法来处理客户端的请求。<br>Servlet 通过调用 destroy() 方法终止（结束）。<br>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。<br>Servlet 单实例，减少了产生 servlet 的开销；<br>3、说出 Servlet 的生命周期，并说出 Servlet 和 CGI 的区别。<br>考察点：servlet<br>参考回答：<br>NOWCODER.COM<br>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，<br>service 方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实<br>例销毁的时候调用其 destroy 方法。<br>与 cgi 的区别在于 servlet 处于服务器进程中，它通过多线程方式运行其 service 方法，一个实<br>例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，服务完<br>成后就销毁，所以效率上低于 servlet。<br>4、Servlet 执行时一般实现哪几个方法？<br>考察点：servlet<br>参考回答：<br>public void init(ServletConfig config)<br>public ServletConfig getServletConfig()<br>public String getServletInfo()<br>public void service(ServletRequest request,ServletResponse response)<br>public void destroy()<br>init ()方法在 servlet 的生命周期中仅执行一次，在服务器装载 servlet 时执行。缺省的 init()<br>方法通常是符合要求的，不过也可以根据需要进行 override，比如管理服务器端资源，一次性<br>装入 GIF 图像，初始化数据库连接等，缺省的 inti()方法设置了 servlet 的初始化参数，并用<br>它的 ServeltConfig 对象参数来启动配置，所以覆盖 init()方法时，应调用 super.init()以确<br>保仍然执行这些任务。service ()方法是 servlet 的核心，在调用 service()方法之前，应确保<br>已完成 init()方法。对于 HttpServlet，每当客户请求一个 HttpServlet 对象，该对象的 service()<br>方法就要被调用，HttpServlet 缺省的 service()方法的服务功能就是调用与 HTTP 请求的方法<br>相应的 do 功能，doPost()和 doGet()，所以对于 HttpServlet，一般都是重写 doPost()和 doGet()<br>方法。destroy()方法在 servlet 的生命周期中也仅执行一次，即在服务器停止卸载 servlet 时<br>执行，把 servlet 作为服务器进程的一部分关闭。缺省的 destroy()方法通常是符合要求的，但<br>也可以 override，比如在卸载 servlet 时将统计数字保存在文件中，或是关闭数据库连接<br>getServletConfig()方法返回一个 servletConfig 对象，该对象用来返回初始化参<br>servletContext。servletContext 接口提供有关 servlet 的环境信息。getServletInfo()方法<br>提供有关 servlet 的信息，如作者，版本，版权。<br>5、阐述一下阐述 Servlet 和 CGI 的区别?<br>考察点：servlet<br>参考回答：<br>Servlet与 CGI 的区别在于 Servlet 处于服务器进程中，它通过多线程方式运行其 service()<br>方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的<br>进程，服务完成后就销毁，所以效率上低于 Servlet。<br>6、说说 Servlet 接口中有哪些方法？<br>考察点：Servlet 接口<br>参考回答：<br>NOWCODER.COM<br>Servlet 接口定义了 5 个方法，其中前三个方法与 Servlet 生命周期相关：* void init(ServletConfig config) throws ServletException</p><ul><li>void service(ServletRequest req, ServletResponse resp) throws ServletException,<br>java.io.IOException</li><li>void destory()</li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()<br>Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init()方法进行<br>Servlet 的初始化；请求到达时调用 Servlet 的 service()方法，service()方法会根据需要调用<br>与请求对应的 doGet 或 doPost 等方法；当服务器关闭或项目被卸载时服务<br>器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy()方法。<br>7、Servlet 3 中的异步处理指的是什么？<br>考察点：servlet<br>参考回答：<br>在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然<br>都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那<br>么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将<br>会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝<br>服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行<br>时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交<br>给 Executor 并立即返回即可。</li></ul><p>8、如何在基于 Java 的 Web 项目中实现文件上传和下载？<br>考察点：文件传输<br>参考回答：<br>在 Sevlet 3 以前，Servlet API 中没有支持上传功能的 API，因此要实现上传功能需要引<br>入第三方工具从 POST 请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们<br>推荐使用 Apache 的 commons-fileupload。<br>从 Servlet 3 开始，文件上传变得简单许多。</p><p>9、服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()<br>方法？<br>考察点：servlet<br>参考回答：<br>HTML 的&lt;form&gt;元素有一个 method 属性，用来指定提交表单的方式，其值可以是 get 或 post。<br>我们自定义的 Servlet 一般情况下会重写 doGet()或 doPost()两个方法之一或全部，如果是 GET<br>请求就调用 doGet()方法，如果是 POST 请求就调用 doPost()方法，那为什么为什么这样呢？我<br>们自定义的 Servlet 通常继承自 HttpServlet，HttpServlet 继承自 GenericServlet 并重写了其<br>中的 service()方法，这个方法是 Servlet 接口中定义的。HttpServlet 重写的 service()方法<br>会先获取用户请求的方法，然后根据请求方法调用 doGet()、doPost()、doPut()、doDelete()<br>等方法，如果在自定义 Servlet 中重写了这些方法，那么显然会调用重写过的（自定义的）方法，<br>这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java 与模式》一书的第 37<br>章）。当然，自定义 Servlet 中也可以直接重写 service()方法，那么不管是哪种方式的请求，<br>都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。<br>10、Servlet 中如何获取用户提交的查询参数或表单数据？<br>考察点：servlet<br>参考回答：<br>可以通过请求对象（HttpServletRequest）的 getParameter()方法通过参数名获得参数值。<br>如果有包含多个值的参数（例如复选框），可以通过请求对象的 getParameterValues()方法获<br>得。当然也可以通过请求对象的 getParameterMap()获得一个参数名和参数值的映射（Map）。<br>11、Servlet 中如何获取用户配置的初始化参数以及服务器上下文参数？<br>考察点：初始化<br>参考回答：<br>可以通过重写 Servlet 接口的 init(ServletConfig)方法并通过 ServletConfig 对象的<br>getInitParameter()方法来获取 Servlet 的初始化参数。可以通过 ServletConfig 对象的<br>getServletContext()方法获取 ServletContext 对象，并通过该对象的 getInitParameter()方<br>法来获取服务器上下文参数。当然，ServletContext 对象也在处理用户请求的方法（如 doGet()<br>方法）中通过请求对象的 getServletContext()方法来获得。<br>NOWCODER.COM</p><p>3、请问 Java Web 开发的 Model 1 和 Model 2 分别指的是什么？<br>考察点：Model<br>参考回答：<br>Model 1 是以页面为中心的 Java Web 开发，使用 JSP+JavaBean 技术将页面显示逻辑和业务<br>逻辑处理分开，JSP 实现页面显示，JavaBean 对象用来保存数据和实现业务逻辑。Model 2 是基<br>于 MVC（模型-视图-控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视<br>图的彻底分离，利于团队开发和代码复用。 ④JSTL、DisplayTag 等常见标签库的用法<br>1、你的项目中使用过哪些 JSTL 标签？<br>考察点：JSTL<br>参考回答：<br>项目中主要使用了 JSTL 的核心标签库，包括&lt;c:if&gt;、&lt;c:choose&gt;、&lt;c: when&gt;、&lt;c: otherwise&gt;、<br>&lt;c:forEach&gt;等，主要用于构造循环和分支结构以控制显示逻辑。<br>虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库，但是实际开发中建议只使用核心<br>标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到<br>数据显示和业务逻辑的分离，这才是最佳实践。<br>2、使用标签库有什么好处？如何自定义 JSP 标签？（JSP 标签）<br>考察点：JSP 标签<br>参考回答：<br>使用标签库的好处包括以下几个方面：</p><ul><li>分离 JSP 页面的内容和逻辑，简化了 Web 开发；</li><li>开发者可以创建自定义标签来封装业务逻辑和显示逻辑；</li><li>标签具有很好的可移植性、可维护性和可重用性；</li><li>避免了对 Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在 JSP 中书写小脚本）<br>编写一个 Java 类实现实现 Tag&#x2F;BodyTag&#x2F;IterationTag 接口（开发中通常不直接实现这些<br>接口而是继承 TagSupport&#x2F;BodyTagSupport&#x2F;SimpleTagSupport 类，这是对缺省适配模式的应用），<br>重写 doStartTag()、doEndTag()等方法，定义标签要完成的功能：<br>NOWCODER.COM</li><li>编写扩展名为 tld 的标签描述文件对自定义标签进行部署，tld 文件通常放在 WEB-INF 文件夹<br>下或其子目录中</li><li>在 JSP 页面中使用 taglib 指令引用该标签库<br>3、Web 编程原理<br>①HTTP 协议<br>1、get 和 post 区别？<br>考察点：HTTP 请求<br>参考回答：<br>（1）在客户端， Get 方式在通过 URL 提交数据，数据 在 URL 中可以看到；POST 方式，数据<br>放置在 HTML HEADER 内提交。<br>（2）GET 方式提交的数据最多只能有 1024 字节，而 POST 则没有此限制。<br>（3）安全性问题。正如在（ 1 ）中提到，使用 Get 的时候，参数会显示在地址栏上，<br>而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get ；如果<br>用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post 为好。<br>安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同<br>一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，<br>GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从<br>自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的<br>一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。<br>POST 请求就不那么轻松了。 POST 表示可能改变服务器上的资源的请求。仍然以新闻站点<br>为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比<br>方说文章下面出现一条注解）。</li></ul><p>3、BS 与 CS 的联系与区别。<br>考察点：客户端&#x2F;服务器模式<br>NOWCODER.COM<br>参考回答：<br>C&#x2F;S 是 Client&#x2F;Server 的缩写。服务器通常采用高性能的 PC、工作站或小型机，并采用大型<br>数据库系统，如 Oracle、Sybase、Informix 或 SQL Server。客户端需要安装专用的客户端软件。<br>B&#x2F;Ｓ是 Brower&#x2F;Server 的缩写，客户机上只要安装一个浏览器（Browser），如 Netscape Navigator<br>或 Internet Explorer，服务器安<br>装 Oracle、Sybase、Informix 或 SQL Server 等数据库。在这种结构下，用户界面完全通过 WWW<br>浏览器实现，一部分事务逻辑在前端实<br>现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。<br>C&#x2F;S 与 B&#x2F;S 区别：<br>硬件环境不同:<br>C&#x2F;S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供<br>连接和数据交换服务.<br>B&#x2F;S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自<br>己管理. 有比 C&#x2F;S 更强的适应范围, 一<br>般只要有操作系统和浏览器就行<br>２．对安全要求不同<br>C&#x2F;S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统<br>采用 C&#x2F;S 结构适宜. 可以通过 B&#x2F;S 发布<br>部分可公开信息.<br>B&#x2F;S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。<br>３．对程序架构不同<br>C&#x2F;S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.<br>B&#x2F;S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比 C&#x2F;S 有更高<br>的要求 B&#x2F;S 结构的程序架构是发展的趋<br>势, 从 MS 的.Net 系列的 BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN<br>和 IBM 推的 JavaBean 构件技术等,使<br>B&#x2F;S 更加成熟. ４．软件重用不同<br>C&#x2F;S 程序可以不可避免的整体性考虑, 构件的重用性不如在 B&#x2F;S 要求下的构件的重用性好.<br>B&#x2F;S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以<br>再利用,而不是做在墙上的石头桌子<br>５．系统维护不同<br>C&#x2F;S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再<br>做一个全新的系统<br>B&#x2F;S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从<br>网上自己下载安装就可以实现升级. ６．处理问题不同<br>C&#x2F;S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应<br>该都是相同的系统<br>B&#x2F;S 建立在广域网上, 面向不同的用户群, 分散地域, 这是 C&#x2F;S 无法作到的. 与操作系统<br>平台关系最小. ７．用户接口不同<br>C&#x2F;S 多是建立的 Window 平台上,表现方法有限,对程序员普遍要求较高<br>B&#x2F;S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减<br>低开发成本. ８．信息流不同<br>C&#x2F;S 程序一般是典型的中央集权的机械式处理, 交互性相对低<br>B&#x2F;S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。<br>NOWCODER.COM<br>4、如何设置请求的编码以及响应内容的类型？<br>考察点：请求类型<br>参考回答：<br>通过请求对象（ServletRequest）的 setCharacterEncoding(String)方法可以设置请求的<br>编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java 程序都使用统一的<br>编码，最好的选择当然是 UTF-8；通过响应对象（ServletResponse）的 setContentType(String)<br>方法可以设置响应内容的类型，当然也可以通过 HttpServletResponsed 对象的<br>setHeader(String, String)方法来设置。<br>5、什么是 Web Service（Web 服务）？<br>考察点：web service<br>参考回答：<br>从表面上看，Web Service 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用<br>的 API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，<br>跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的 Web Service，那么无论你<br>用哪种编程语言开发的应用都可以通过调用它的 API 并传入城市信息来获得该城市的天气预报。<br>之所以称之为 Web Service，是因为它基于 HTTP 协议传输数据，这使得运行在不同机器上的不<br>同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。<br>SOA（Service-Oriented Architecture，面向服务的架构），SOA 是一种思想，它将应用程<br>序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种<br>形式的功能单元能够更好的集成。显然，Web Service 是 SOA 的一种较好的解决方案，它更多的<br>是一种标准，而不是一种具体的技术。<br>6、谈谈 Session 的 save()、update()、merge()、lock()、saveOrUpdate()和<br>persist()方法分别是做什么的？有什么区别？<br>考察点：session<br>参考回答：<br>Hibernate 的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态<br>（detached），如第 135 题中的图所示。瞬时态的实例可以通过调用 save()、persist()或者<br>saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()<br>或者 replicate()变成持久态。save()和 persist()将会引发 SQL 的 INSERT 语句，而 update()<br>或 merge()会引发 UPDATE 语句。save()和 update()的区别在于一个是将瞬时态对象变成持久态，<br>一个是将游离态对象变为持久态。merge()方法可以完成 save()和 update()方法的功能，它的意<br>图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于 persist()方法，按照<br>官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填<br>入到持久化实例中，标识符的填入可能被推迟到 flush 的时间；② persist()方法保证当它在一<br>个事务外部被调用的时候并不触发一个 INSERT 语句，当需要封装一个长会话流程的时候，<br>persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执<br>行 INSERT 语句，不管是在事务内部还是外部。至于 lock()方法和 update()方法的区别，update()<br>方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱<br>管状态的对象变成持久状态。<br>NOWCODER.COM<br>7、大型网站在架构上应当考虑哪些问题？<br>考察点：Java 架构<br>参考回答：</p><ul><li>分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个<br>层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形<br>成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI&#x2F;RM）和 Internet 的 TCP&#x2F;IP<br>模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储<br>和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。<br>需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备<br>上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之<br>间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</li><li>分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚<br>低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模<br>块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另<br>一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</li><li>分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独<br>立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的<br>加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式<br>部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，<br>例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce<br>分布式计算框架来处理。</li><li>集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</li><li>缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓<br>存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。</li><li>异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，<br>二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影<br>响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用<br>Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能<br>推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</li><li>冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可<br>以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。 ③Web 容器<br>1、请对以下在 J2EE 中常用的名词进行解释(或简单描述)<br>考察点：J2EE<br>参考回答：<br>web 容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP,SERVLET<br>直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有 WEB 服务器来实现。例如：<br>TOMCAT,WEBLOGIC,WEBSPHERE 等。该容器提供的接口严格遵守 J2EE 规范中的 WEBAPPLICATION 标<br>准。我们把遵守以上标准的 WEB 服务器就叫做 J2EE 中的 WEB 容器。<br>Web container：实现 J2EE 体系结构中 Web 组件协议的容器。这个协议规定了一个 Web 组件运行<br>时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和 JSP 和<br>J2EE 平台 APIs 界面相同服务的容器。一个 Web container 由 Web 服务器或者 J2EE 服务器提供。<br>EJB 容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件 EJB<br>NOWCODER.COM<br>各种管理功能。只要满足 J2EE 规范的 EJB 放入该容器，马上就会被容器进行高效率的管理。并<br>且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了 J2EE 体<br>系结构中 EJB 组件规范的容器。这个规范指定了一个 Enterprise bean 的运行时环境，包括安全，<br>一致性，生命周期，事务，配置，和其他的服务。<br>JNDI：（Java Naming &amp; Directory Interface）JAVA 命名目录服务。主要提供的功能是：提供<br>一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布<br>式应用程序的功能。<br>JMS：（Java Message Service）JAVA 消息服务。主要实现各个应用程序之间的通讯。包括点对<br>点和广播。<br>JTA：（Java Transaction API）JAVA 事务服务。提供各种分布式事务服务。应用程序只需调用<br>其提供的接口即可。<br>JAF：（Java Action FrameWork）JAVA 安全认证框架。提供一些安全控制方面的框架。让开发<br>者通过各种部署和自定义实现自己的个性安全控制策略。<br>RMI&#x2F;IIOP: （Remote Method Invocation &#x2F;internet 对象请求中介协议）他们主要用于通过远<br>程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地<br>计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI<br>是 JAVA 特有的。RMI-IIOP 出现以前，只有 RMI 和 CORBA 两种选择来进行分布式程序设计。<br>RMI-IIOP 综合了 RMI 和 CORBA 的优点，克服了他们的缺点，使得程序员能更方便的编写分布式<br>程序设计，实现分布式计算。首先，RMI-IIOP 综合了 RMI 的简单性和 CORBA 的多语言性（兼容<br>性），其次 RMI-IIOP 克服了 RMI 只能用于 Java 的缺点和 CORBA 的复杂性。 四、JDBC 编程</li></ul><p>2、JDBC 基础<br>①数据库<br>1、数据库水平切分，垂直切分<br>考察点：数据库<br>参考回答：<br>NOWCODER.COM<br>垂直拆分就是要把表按模块划分到不同数据库表中（当然原则还是不破坏第三范式），这种<br>拆分在大型网站的演变过程中是很常见的。当一个网站还在很小的时候，只有小量的人来开发和<br>维护，各模块和表都在一起，当网站不断丰富和壮大的时候，也会变成多个子系统来支撑，这时<br>就有按模块和功能把表划分出来的需求。其实，相对于垂直切分更进一步的是服务化改造，说得<br>简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，<br>因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，淘宝在架构不断演<br>变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成独立<br>的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。<br>垂直拆分：单表大数据量依然存在性能瓶颈<br>水平拆分，上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量<br>的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。例如像计费<br>系统，通过按时间来划分表就比较合适，因为系统都是处理某一时间段的数据。而像 SaaS 应用，<br>通过按用户维度来划分数据比较合适，因为用户与用户之间的隔离的，一般不存在处理多个用户<br>数据的情况，简单的按 user_id 范围来水平切分。<br>通俗理解：水平拆分行，行数据拆分到不同表中， 垂直拆分列，表数据拆分到不同表中。</p><p>10、leftjoin 和 rightjoin 的区别？<br>考察点：表结构<br>参考回答：<br>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录<br>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br>比如：<br>表 A 记录如下：<br>aID aNum<br>1 a20050111<br>2 a20050112<br>3 a20050113<br>4 a20050114<br>5 a20050115<br>表 B 记录如下:<br>bID bName<br>1 2006032401<br>2 2006032402<br>3 2006032403<br>4 2006032404<br>8 2006032408<br>left join 是以 A 表的记录为基础的,A 可以看成左表,B 可以看成右表,left join 是以左表<br>为准的. 换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为:<br>A.aID &#x3D; B.bID).<br>B 表记录不足的地方均为 NULL. 11、数据库优化方法<br>考察点：数据库<br>参考回答：<br>（1）选取最适用的字段属性<br>MySQL 可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行<br>的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度<br>设得尽可能小。<br>例如，在定义邮政编码这个字段时，如果将其设置为 CHAR(255),显然给数据库增加了不必<br>要的空间，甚至使用 VARCHAR 这种类型也是多余的，因为 CHAR(6)就可以很好的完成任务了。同<br>样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段。<br>NOWCODER.COM<br>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为 NOTNULL，这样在将来<br>执行查询的时候，数据库不用去比较 NULL 值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL<br>中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。<br>这样，我们又可以提高数据库的性能。<br>（2）使用连接（JOIN）来代替子查询(Sub-Queries)<br>MySQL 从 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查<br>询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没<br>有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户 ID 取出<br>来，然后将结果传递给主查询<br>（3）使用联合(UNION)来代替手动创建的临时表<br>MySQL 从 4.0 的版本开始支持 union 查询，它可以把需要使用临时表的两条或更多的 select<br>查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据<br>库整齐、高效。使用 union 来创建查询的时候，我们只需要用 UNION 作为关键字把多个 select<br>语句连接起来就可以了，要注意的是所有 select 语句中的字段数目要想同。下面的例子就演示<br>了一个使用 UNION 的查询。<br>（4）事务<br>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样<br>的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时<br>候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句<br>运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两<br>个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，<br>造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。<br>要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失<br>败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以 BEGIN 关键字开始，COMMIT<br>关键字结束。在这之间的一条 SQL 操作失败，那么，ROLLBACK 命令就可以把数据库恢复到 BEGIN<br>开始之前的状态。<br>12、谈一下你对继承映射的理解。<br>考察点：映射<br>参考回答：<br>继承关系的映射策略有三种：<br>① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。<br>② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。<br>③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。<br>第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态<br>查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是<br>需要进行连接查询，不适合多态查询。<br>NOWCODER.COM<br>②数据库连接池<br>1、说出数据连接池的工作机制是什么?<br>考察点：连接池<br>参考回答：<br>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端<br>程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连<br>接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用<br>完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 ③事物管理，批处理<br>1、事务的 ACID 是指什么？<br>考察点：数据库<br>参考回答：</p><ul><li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导<br>致整个事务的失败； - 一致性(Consistent)：事务结束后系统状态是一致的； - 隔离性<br>(Isolated)：并发执行的事务彼此无法看到对方的中间状态； - 持久性(Durable)：事务完成后<br>所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建<br>数据。<br>关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，<br>只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括<br>3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类<br>丢失更新）。<br>2、JDBC 中如何进行事务处理？<br>考察点：数据库<br>参考回答：<br>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置手动提交事<br>务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中发生异常则通过 rollback()<br>进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代<br>码设置保存点并让事务回滚到指定的保存点。<br>NOWCODER.COM<br>3、JDBC 进阶<br>1、JDBC 的反射，反射都是什么？<br>考察点：jdbc<br>参考回答：<br>通过反射 com.mysql.jdbc.Driver 类，实例化该类的时候会执行该类内部的静态代码块，该<br>代码块会在 Java 实现的 DriverManager 类中注册自己,DriverManager 管理所有已经注册的驱动<br>类，当调用 DriverManager.geConnection 方法时会遍历这些驱动类，并尝试去连接数据库，只<br>要有一个能连接成功，就返回 Connection 对象，否则则报异常。<br>4、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性<br>能？<br>考察点：JDBC 优化<br>NOWCODER.COM<br>参考回答：<br>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()方法指<br>定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用<br>PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。 五、XML 编程<br>1、XML 基础<br>1、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种<br>方式？<br>考察点：XML<br>参考回答：<br>a: 两种形式 dtd schema<br>b: 本质区别:schema 本身是 xml 的，可以被 XML 解析器解析(这也是从 DTD 上发展 schema 的根<br>本目的)<br>c:有 DOM,SAX,STAX 等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由 DOM 的树结构所造成的，这种结构占<br>用的内存较多，而且 DOM 必须在解析文件之前把整个文档装入内存,适合对 XML 的随机访问<br>SAX:不现于 DOM,SAX 是事件驱动型的 XML 解析方式。它顺序读取 XML 文件，不需要一次全部装载<br>整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用<br>户通过在其回调事件中写入处理代码来处理 XML 文件，适合对 XML 的顺序访问<br>STAX:Streaming API for XML (StAX)<br>xml 文档有两种定义方法：<br>dtd：数据类型定义（data type definition），用以描述 XML 文档的文档结构，是早期的 XML<br>文档定义形式。<br>schema：其本身是基于 XML 语言编写的，在类型和语法上的限定能力比 dtd 强，处理也比较方便，<br>因为此正逐渐代替 dtd 成为新的模式定义语言。<br>2、XML 进阶<br>3、Web service<br>①WSDL 与 SOAP 协议<br>1、WEB SERVICE 名词解释，JSWDL 开发包的介绍，JAXP、JAXM 的解释。SOAP、<br>UDDI,WSDL 解释。<br>考察点：web service<br>NOWCODER.COM<br>参考回答：<br>Web ServiceWeb Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守<br>具体的技术规范，这些规范使得 WebService 能与其他兼容的组件进行互操作。JAXP(Java API for<br>XML Parsing) 定义了在 Java 中使用 DOM, SAX, XSLT 的通用的接口。这样在你的程序中你只要<br>使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。JAXM(Java API for XML<br>Messaging) 是为 SOAP 通信提供访问方法和传输机制的 API。WSDL 是一种 XML 格式，用于将网<br>络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格<br>式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。<br>相关的具体端点即组合成为抽象端点（服务）。SOAP 即简单对象访问协议(Simple Object Access<br>Protocol)，它是用于交换 XML 编码信息的轻量级协议。UDDI 的目的是为电子商务建立标准；UDDI<br>是一套基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范，同时也<br>包含一组使企业能将自身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标<br>准。soap 是 web service 最关键的技术，是 web service 中数据和方法调传输的介质。WSDL（web<br>service definition language）描述了 web service 的接口和功能。<br>2、请你谈谈对 SOAP、WSDL、UDDI 的了解？<br>考察点：协议&amp;语言<br>参考回答：</li><li>SOAP：简单对象访问协议（Simple Object Access Protocol），是 Web Service 中交换<br>数据的一种协议规范。</li><li>WSDL：Web 服务描述语言（Web Service Description Language），它描述了 Web 服务的公共<br>接口。这是一个基于 XML 的关于如何与 Web 服务通讯和使用的服务描述；也就是描述与目录中列<br>出的 Web 服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作<br>和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。</li><li>UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它<br>是一个基于 XML 的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服<br>务。简单的说，UDDI 是访问各种 WSDL 的一个门面（可以参考设计模式中的门面模式）。<br>3、谈谈 Java 规范中和 Web Service 相关的规范有哪些？<br>考察点：规范<br>参考回答：<br>Java 规范中和 Web Service 相关的有三个：</li><li>JAX-WS(JSR 224)：这个规范是早期的基于 SOAP 的 Web Service 规范 JAX-RPC 的替代版本，它<br>并不提供向下兼容性，因为 RPC 样式的 WSDL 以及相关的 API 已经在 Java EE5 中被移除了。<br>WS-MetaData 是 JAX-WS 的依赖规范，提供了基于注解配置 Web Service 和 SOAP 消息的相关 API。</li><li>JAXM(JSR 67)：定义了发送和接收消息所需的 API,相当于 Web Service 的服务器端。</li><li>JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是 Java 针对 REST（Representation State Transfer）<br>架构风格制定的一套 Web Service 规范。REST 是一种软件架构模式，是一种风格，它不像 SOAP<br>那样本身承载着一种消息协议，(两种风格的 Web Service 均采用了 HTTP 做传输协议，因为 HTTP<br>协议能穿越防火墙，Java 的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因<br>此可以将 REST 视为基于 HTTP 协议的软件架构。REST 中最重要的两个概念是资源定位和资源操<br>作，而 HTTP 协议恰好完整的提供了这两个点。HTTP 协议中的 URI 可以完成资源定位，而 GET、<br>POST、OPTION、DELETE 方法可以完成资源操作。因此 REST 完全依赖 HTTP 协议就可以完成 Web<br>NOWCODER.COM<br>Service，而不像 SOAP 协议那样只利用了 HTTP 的传输特性，定位和操作都是由 SOAP 协议自身完<br>成的，也正是由于 SOAP 消息的存在使得基于 SOAP 的 Web Service 显得笨重而逐渐被淘汰。 六、计算机网络<br>1、网络概述<br>①关于分层<br>1、TCP 协议在哪一层？IP 协议在那一层？HTTP 在哪一层？<br>考察点：网络七层模型<br>参考回答：<br>运输层，网络层，应用层。<br>2、运输层<br>①TCP 与 UDP<br>1、讲一下 TCP 的连接和释放连接。<br>考察点：网络基础<br>参考回答：<br>三次握手的过程<br>1）主机 A 向主机 B 发送 TCP 连接请求数据包，其中包含主机 A 的初始序列号 seq(A)&#x3D;x。（其<br>中报文中同步标志位 SYN&#x3D;1，ACK&#x3D;0，表示这是一个 TCP 连接请求数据报文；序号 seq&#x3D;x，表明传<br>输数据时的第一个数据字节的序号是 x）；<br>2）主机 B 收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位 SYN&#x3D;1，ACK&#x3D;1，<br>表示这是一个 TCP 连接响应数据报文，并含主机 B 的初始序列号 seq(B)&#x3D;y，以及主机 B 对主机 A<br>初始序列号的确认号 ack(B)&#x3D;seq(A)+1&#x3D;x+1）<br>3）第三次，主机 A 收到主机 B 的确认报文后，还需作出确认，即发送一个序列号 seq(A)&#x3D;x+1；<br>确认号为 ack(A)&#x3D;y+1 的报文；<br>四次挥手过程<br>NOWCODER.COM<br>假设主机 A 为客户端，主机 B 为服务器，其释放 TCP 连接的过程如下：<br>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数<br>据传送，然后等待服务器的确认。其中终止标志位 FIN&#x3D;1，序列号 seq&#x3D;u。<br>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。<br>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。<br>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加<br>1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>三次握手<br>四次挥手<br>2、TCP 有哪些应用场景<br>考察点：TCP 协议<br>参考回答：<br>NOWCODER.COM<br>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一<br>些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议<br>3、tcp 为什么可靠<br>考察点：TCP<br>参考回答：<br>三次握手，超时重传，滑动窗口，拥塞控制。<br>4、tcp 为什么要建立连接<br>考察点：TCP<br>参考回答：<br>保证可靠传输。<br>5、阐述 TCP 的 4 次挥手<br>考察点：TCP 协议<br>参考回答：<br>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的<br>数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上<br>没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动<br>关闭，而另一方执行被动关闭。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服<br>务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。<br>（1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送。<br>（2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，<br>一个 FIN 将占用一个序号。<br>（3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A。<br>（4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。<br>NOWCODER.COM<br>②协议<br>1、讲一下浏览器从接收到一个 URL 到最后展示出页面，经历了哪些过程。tag<br>考察点：http 协议<br>参考回答：<br>1.DNS 解析 2.TCP 连接 3.发送 HTTP 请求 4.服务器处理请求并返回 HTTP 报文<br>5.浏览器解析渲染页面<br>2、http 和 https 的区别<br>考察点：http 协议<br>参考回答；<br>https 协议要申请证书到 ca，需要一定经济成本；2） http 是明文传输，https 是加密的安<br>全传输；3） 连接的端口不一样，http 是 80，https 是 443；4）http 连接很简单，没有状态；<br>https 是 ssl 加密的传输，身份认证的网络协议，相对 http 传输比较安全。<br>3、http 的请求有哪些，应答码 502 和 504 有什么区别<br>考察点：http 协议<br>参考回答：<br>OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送<br>‘*‘的请求来测试服务器的功能性。<br>HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以<br>在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>NOWCODER.COM<br>GET：向特定的资源发出请求。<br>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请<br>求体中。POST 请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。<br>PUT：向指定资源位置上传其最新内容。<br>DELETE：请求服务器删除 Request-URI 所标识的资源。<br>TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求<br>方式也都可以通过这两种方式间接的来实现。<br>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识<br>出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。<br>4、http1.1 和 1.0 的区别<br>考察点：http<br>参考回答：<br>主要区别主要体现在：<br>缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判<br>断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since,<br>If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。<br>带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要<br>某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在<br>请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），<br>这样就方便了开发者自由的选择以便于充分利用带宽和连接。<br>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请<br>求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。<br>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中<br>的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以<br>存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求<br>消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad<br>Request）。<br>长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）<br>处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，<br>在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创<br>建连接的缺点。<br>NOWCODER.COM<br>5、说说 ssl 四次握手的过程<br>考察：HTTP 加密协议<br>参考回答：<br>1、 客户端发出请求<br>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello<br>请求。<br>2、服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。<br>3、客户端回应<br>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书<br>中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还<br>要继续通信。<br>4、服务器的最后回应<br>服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的”会话密<br>钥”。然后，向客户端最后发送下面信息。<br>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所<br>有内容的 hash 值，用来供客户端校验。<br>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通<br>的 HTTP 协议，只不过用”会话密钥”加密内容。<br>6、304 状态码有什么含义？<br>考察点：http<br>参考回答：<br>304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页<br>内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为<br>If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，<br>进而节省带宽和开销。<br>3、网络层<br>①网际协议 IP<br>1、arp 协议，arp 攻击<br>NOWCODER.COM<br>考察点：ARP 协议<br>参考回答：<br>地址解析协议。ARP 攻击的第一步就是 ARP 欺骗。由上述“ARP 协议的工作过程”我们知道，<br>ARP 协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正<br>确和快速的完成——ARP 协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在<br>向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现 ARP 应答中的 IP 地址和 MAC<br>地址中的信息是可以伪造的，并不一定是自己的真实 IP 地址和 MAC 地址，由此，ARP 欺骗就产<br>生了。 ②网际控制报文协议 ICMP<br>1、icmp 协议<br>考察点：ICMP 协议<br>参考回答：<br>它是 TCP&#x2F;IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息。控制消息是<br>指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用<br>户数据，但是对于用户数据的传递起着重要的作用。 ③因特网的路由器选择协议<br>1、讲一下路由器和交换机的区别？<br>考察点：路由器<br>参考回答：<br>交换机用于同一网络内部数据的快速传输转发决策通过查看二层头部完成转发不需要修改<br>数据帧工作在 TCP&#x2F;IP 协议的二层 —— 数据链路层工作简单，直接使用硬件处理路由器用于不<br>同网络间数据的跨网络传输转发决策通过查看三层头部完成转发需要修改 TTL ，IP 头部校验和<br>需要重新计算，数据帧需要重新封装工作在 TCP&#x2F;IP 协议的三层 —— 网络层工作复杂，使用软<br>件处理。<br>4、应用层<br>①域名系统 DNS<br>1、DNS 寻址过程<br>考察点：DNS<br>NOWCODER.COM<br>参考回答：<br>1、在浏览器中输入 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个<br>网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。<br>2、如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射<br>关系，如果有，直接返回，完成域名解析。<br>3、如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP&#x2F;ip 参数中<br>设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域<br>名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。<br>4、如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关<br>系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。<br>5、如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是<br>否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服<br>务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的<br>一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com<br>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS 服务器地<br>址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，<br>重复上面的动作，进行查询，直至找到 <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 主机。<br>6、如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服<br>务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不<br>管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此<br>DNS 服务器再返回给客户机。<br>从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查<br>询。②电子邮件<br>1、负载均衡反向代理模式优点及缺点<br>考察点：反向代理<br>参考回答：<br>（1）反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然<br>后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接<br>的客户端，此时代理服务器对外就表现为一个服务器。<br>（2）反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转<br>发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。<br>（3）反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，<br>也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡<br>策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由<br>于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有<br>此优点）。<br>NOWCODER.COM<br>（4）其缺点主要表现在以下两个方面<br>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反<br>向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器<br>的负载均衡。<br>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接<br>请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的<br>瓶颈。<br>一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点<br>进行负载均衡，如 search 等。 七、操作系统<br>1、操作系统概论<br>1、CentOS 和 Linux 的关系？<br>考察点：操作系统<br>参考回答：<br>CentOS是Linux众多得发行版本之一，linux有三大发行版本（：Slackware、debian、redhat）, 而 Redhat 有收费的商业版和免费的开源版,商业版的业内称之为 RHEL 系列，CentOS 是来自于依<br>照开放源代码规定而公布的源代码重新编译而成。可以用 CentOS 替代商业版的 RHEL 使用。两者<br>的不同，CentOS 不包含封闭源代码软件，是免费的。<br>2、64 位和 32 位的区别？<br>考察点：<br>操作系统<br>参考回答：<br>操作系统只是硬件和应用软件中间的一个平台。32 位操作系统针对的 32 位的 CPU 设计。64<br>位操作系统针对的 64 位的 CPU 设计。<br>2、进程的描述与控制<br>1、怎么杀死进程？<br>考察点：进程<br>参考回答：<br>NOWCODER.COM<br>Kill pid<br>2、线程，进程区别<br>考察点：进程，线程<br>参考回答：<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，<br>一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路<br>径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个<br>进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要<br>差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。1. 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li></ul><ol start="2"><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高<br>了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序<br>执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多<br>个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这<br>就是进程和线程的重要区别。<br>3、系统线程数量上限是多少？<br>考察点：线程<br>参考回答：<br>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。<br>这个限制可以在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;local_lim.h 中查看 ，对 linuxthreads 这个值一般<br>是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。<br>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程<br>栈大小，一般情况下，这个值是 8M&#x3D;8192KB。<br>4、进程和线程的区别是什么？<br>考察点：JAVA 进程<br>参考回答：<br>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。<br>线程又叫做轻量级进程。<br>NOWCODER.COM<br>5、解释一下 LINUX 下线程，GDI 类。<br>考察点：线程<br>参考回答：<br>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心<br>轻量级进程，而线程之间的管理在核外函数库中实现。<br>GDI 类为图像设备编程接口类库。<br>3、输入输出系统<br>1、socket 编程，BIO，NIO，epoll？<br>考察点：I&#x2F;O 多路复用<br>参考回答：<br>阻塞，非阻塞，io 多路复用，epoll 支持文件符数目没有限制，fd 集合只会从用户进程拷<br>贝到内核一次，自己维护一个事件队列，不用每次遍历 fd 集合发现是否有就绪状态。<br>4、存储器管理<br>1、什么是页式存储？<br>考察点：页式存储<br>参考回答：<br>主存被等分成大小相等的片，称为主存块，又称为实页。<br>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为 2n ,通常为 1KB、2KB、<br>2n KB 等<br>2、操作系统里的内存碎片你怎么理解，有什么解决办法？<br>考察点：内存碎片<br>参考回答：<br>内存碎片分为：内部碎片和外部碎片。<br>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；<br>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存<br>储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才<br>有可能利用这个存储块。<br>NOWCODER.COM<br>单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。<br>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存<br>空间的新进程的内存空闲区域。<br>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前<br>申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。<br>使用伙伴系统算法。<br>5、处理机调度与死锁<br>1、什么情况下会发生死锁，解决策略有哪些？<br>考察点：死锁<br>参考回答：<br>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个<br>进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如 CD-ROM 驱动器，打印机等<br>等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属<br>性所决定的。<br>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至<br>少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但<br>是，它在等待新资源之时，仍继续占用已占有的资源。<br>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源<br>的占有者进程自行释放。<br>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。<br>解决方法：银行家算法<br>2、系统 CPU 比较高是什么原因？<br>考察点：处理机<br>参考回答：<br>1、首先查看是哪些进程的 CPU 占用率最高（如下可以看到详细的路径）<br>ps -aux –sort -pcpu | more# 定位有问题的线程可以用如下命令ps -mp pid -o THREAD,tid,time | more<br>2、查看 JAVA 进程的每个线程的 CPU 占用率<br>ps -Lp 5798 cu | more # 5798 是查出来进程 PID<br>NOWCODER.COM<br>3、追踪线程，查看负载过高的原因，使用 JDK 下的一个工具<br>jstack 5798 # 5798 是 PID<br>jstack -J-d64 -m 5798 # -j-d64 指定 64 为系统<br>jstack 查出来的线程 ID 是 16 进制，可以把输出追加到文件，导出用记事本打开，再根据<br>系统中的线程 ID 去搜索查看该 ID 的线程运行内容，可以和开发一起排查。<br>3、系统如何提高并发性？<br>考察：操作系统综合性<br>参考回答：<br>1、提高 CPU 并发计算能力<br>（1）多进程&amp;多线程<br>（2）减少进程切换，使用线程，考虑进程绑定 CPU<br>（3）减少使用不必要的锁，考虑无锁编程<br>（4）考虑进程优先级<br>（5）关注系统负载<br>2、改进 I&#x2F;O 模型<br>(1)DMA 技术<br>(2)异步 I&#x2F;O<br>(3)改进多路 I&#x2F;O 就绪通知策略，epoll<br>(4)Sendfile<br>(5)内存映射<br>(6)直接 I&#x2F;O<br>八、算法与数据结构<br>1、哈希<br>1、hashset 存的数是有序的吗？<br>考察点：哈希<br>NOWCODER.COM<br>参考回答：<br>Hashset 是无序的。<br>2、Object 作为 HashMap 的 key 的话，对 Object 有什么要求吗？<br>考察点：哈希表<br>参考回答：<br>要求 Object 中 hashcode 不能变。<br>3、一致性哈希算法<br>考察点：哈希算法<br>参考回答：<br>先构造一个长度为 232 的整数环（这个环被称为一致性 Hash 环），根据节点名称的 Hash<br>值（其分布为[0, 232-1]）将服务器节点放置在这个 Hash 环上，然后根据数据的 Key 值计算得<br>到其 Hash 值（其分布也为[0, 232-1]），接着在 Hash 环上顺时针查找距离这个 Key 值的 Hash<br>值最近的服务器节点，完成 Key 到服务器的映射查找。<br>这种算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况<br>下尽量有多的请求命中原来路由到的服务器。<br>4、什么是 hashmap?<br>考察点：哈希表<br>参考回答：<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于 AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null。此<br>外，HashMap 中的映射不是有序的。<br>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表<br>中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前<br>可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该<br>哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少<br>了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操<br>作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便<br>最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生<br>rehash 操作。<br>hashmap 共有 4 个构造函数：<br>&#x2F;&#x2F; 默认构造函数。HashMap()<br>&#x2F;&#x2F; 指定“容量大小”的构造函数<br>NOWCODER.COM<br>HashMap(int capacity)<br>&#x2F;&#x2F; 指定“容量大小”和“加载因子”的构造函数<br>HashMap(int capacity, float loadFactor)<br>&#x2F;&#x2F; 包含“子 Map”的构造函数<br>HashMap(Map&lt;? extends K, ? extends V&gt; map)<br>5、Java 中的 HashMap 的工作原理是什么？<br>考察点：JAVA 哈希表<br>参考回答：<br>HashMap 类有一个叫做 Entry 的内部类。这个 Entry 类包含了 key-value 作为实例变量。每<br>当往 hashmap 里面存放 key-value 对的时候，都会为它们实例化一个 Entry 对象，这个 Entry<br>对象就会存储在前面提到的 Entry 数组 table 中。Entry 具体存在 table 的那个位置是 根据 key<br>的 hashcode()方法计算出来的 hash 值（来决定）。<br>6、hashCode()和 equals()方法的重要性体现在什么地方？<br>考察点：JAVA 哈希表<br>参考回答：<br>Java 中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值<br>的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的<br>hash 值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这<br>两个方法的实现对 HashMap 的精确性和正确性是至关重要的。</li></ol></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a></div><div class="post-nav"><div class="post-nav-item"><a href="/publishes/7e68be57c290.html" rel="prev" title="消息队列（MQ）"><i class="fa fa-angle-left"></i> 消息队列（MQ）</a></div><div class="post-nav-item"><a href="/publishes/22829df8f04f.html" rel="next" title="Java基础">Java基础 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">褚岩</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">593k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">8:59</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script size="300" alpha="0.6" zindex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>